[00:00:30] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[00:00:36] <jdsanders> neat
[00:00:47] <kimundi> It would enable iterator users to call the .iter() themselfes, basically
[00:01:00] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[00:01:59] <kimundi> Ideally the iterator adapters can also use it, which would mean eg. 'vec.iter().map(...)' would become vec.map(...)' but still do the same
[00:03:06] *** Quits: roboguy (roboguy@moz-266CFD9E.cm.sunflower.com) (Input/output error)
[00:03:29] *** Joins: roboguy (roboguy@moz-266CFD9E.cm.sunflower.com)
[00:03:51] *** Quits: tjc (tjc@D3A278CC.854F919D.8B824544.IP) (Ping timeout)
[00:04:41] <jeaye> rusti: let s = ~"foo"; printf!("{}", s); printf!("{}", s);
[00:04:41] -rusti- <std-macros>:230:18: 230:34 error: too many arguments to fmt!. found 2, expected 1
[00:04:41] -rusti- <std-macros>:230             print(fmt!($($arg),+))
[00:04:41] -rusti-                                    ^~~~~~~~~~~~~~~~
[00:04:41] -rusti- application terminated with error code 101
[00:05:03] *** Joins: tjc (tjc@D3A278CC.854F919D.8B824544.IP)
[00:05:03] *** ChanServ sets mode: +o tjc
[00:05:30] *** Joins: eatkinson (eatkinson@moz-261EDE03.hsd1.ca.comcast.net)
[00:06:57] <jeaye> s is moved:
[00:07:01] <jeaye> rusti: let s = ~"foo"; println!("{}", s); println!("{}", s);
[00:07:03] -rusti- pastebinned 20 lines of output: http://ix.io/7Nz
[00:08:00] *** Quits: tikue_ (tkuehn@moz-FEADCD38.hsd1.pa.comcast.net) (Quit: tikue_)
[00:08:04] <jeaye> It says to use 'ref' to not move it. Where does that go?
[00:09:06] <kimundi> jeaye: I'm not sure that ref is useful in this situation
[00:09:31] <kimundi> The problem is that println! currently consumes its arguments
[00:09:46] <kimundi> so, for them not to be consumed you have to pass a reference
[00:09:53] <jeaye> rusti: let s = ~"foo"; println!(fmt!("%s", s)); println!(fmt!("%s", s));
[00:09:54] -rusti- <anon>:5:34: 5:47 error: format argument must be a string literal.
[00:09:54] -rusti- <anon>:5          let s = ~"foo"; println!(fmt!("%s", s)); println!(fmt!("%s", s));
[00:09:54] -rusti-                                            ^~~~~~~~~~~~~
[00:09:54] -rusti- application terminated with error code 101
[00:09:57] <kimundi> rusti: let s = ~"foo"; println!("{}", &s); println!("{}", &s);
[00:10:00] -rusti- pastebinned 10 lines of output: http://ix.io/7NA
[00:10:11] *** Quits: jdsanders (Adium@moz-84CB7548.hlrn.qwest.net) (Quit: Leaving.)
[00:10:20] <jeaye> rusti: let s = ~"foo"; println!("{}", &*s); println!("{}", &*s);
[00:10:24] -rusti- pastebinned 28 lines of output: http://ix.io/7NB
[00:10:26] <kimundi> rusti: let s = ~"foo"; println!("{:?}", &s); println!("{:?}", &s);
[00:10:27] -rusti- &~"foo"
[00:10:27] -rusti- &~"foo"
[00:10:27] -rusti- ()
[00:10:38] <kimundi> rusti: let s = ~"foo"; println!("{:s}", &s); println!("{:s}", &s);
[00:10:41] -rusti- pastebinned 10 lines of output: http://ix.io/7ND
[00:11:23] <kimundi> rusti: let s = ~"foo"; let r = s.as_slice(); println!("{:s}", r); println!("{:s}", r);
[00:11:24] -rusti- foo
[00:11:24] -rusti- foo
[00:11:24] -rusti- ()
[00:11:42] <kimundi> It seems only workaround for strings is to pass a slice
[00:11:53] <jeaye> :|
[00:12:27] <jeaye> I think I'll stick with fmt! for now. This doesn't seem very usable in my specific case. 
[00:12:40] <jeaye> Thanks for the help kimundi and benh.
[00:12:42] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[00:12:50] <kimundi> Anyway, re 'ref': It's a pattern modifier that creates a borrowed to something
[00:13:17] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[00:13:55] <jeaye> match foo { Some(ref bar) => yes, None => no } ?
[00:14:12] <kimundi> rusti: let x = Some(45u8); let Some(ref y) = x; println!("{:?}", y);
[00:14:14] -rusti- <anon>:5:33: 5:44 error: refutable pattern in local binding
[00:14:14] -rusti- <anon>:5          let x = Some(45u8); let Some(ref y) = x; println!("{:?}", y);
[00:14:14] -rusti-                                           ^~~~~~~~~~~
[00:14:14] -rusti- error: aborting due to previous error
[00:14:14] -rusti- application terminated with error code 101
[00:14:19] <benh> :D
[00:14:39] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[00:14:50] <kimundi> rusti: let x = Some(45u8); match x{ Some(ref y) => println!("{:?}", y), _=>()}
[00:14:51] -rusti- &45u8
[00:14:51] -rusti- ()
[00:15:00] *** Quits: squiddy (squiddy@moz-4236ED38.adsl.alicedsl.de) (Input/output error)
[00:15:06] <benh> rusti: let ref x = 42; format!("{:?}", x)
[00:15:06] *** Quits: tjc (tjc@D3A278CC.854F919D.8B824544.IP) (Ping timeout)
[00:15:06] -rusti- ~"&42"
[00:15:09] <kimundi> jeaye: So yes :)
[00:15:16] <jeaye> :)
[00:16:08] <kimundi> rusti: let a = &45_u64; let &ref x = a; format!("{:?}", x)
[00:16:09] -rusti- ~"&45u64"
[00:16:41] *** Quits: jgilbert (jgilbert@moz-4C088FCE.hsd1.ca.comcast.net) (Ping timeout)
[00:16:49] <kimundi> "How to pointlessly remove and add a layer of '&' "
[00:19:01] *** Joins: tikue_ (tkuehn@moz-FEADCD38.hsd1.pa.comcast.net)
[00:20:00] <eevee> wait, does `ref` do anything useful outside a pattern
[00:20:08] <kimundi> no
[00:20:23] *** Joins: tjc (tjc@5FEEDD2E.870F2FA5.2370DFC3.IP)
[00:20:24] *** ChanServ sets mode: +o tjc
[00:20:31] <cmr> but patterns are pretty useful
[00:20:37] <kimundi> indeed
[00:21:45] <tikue_> lol
[00:22:08] <tikue_> i'd be sad if rust never gained the ability to parse vec.map() or `for el in v`
[00:22:38] <kimundi> tikue_: Well don't worry then, those two parse just fine :)
[00:22:49] <tikue_> kimundi: what do you mean?
[00:23:09] <kimundi> Well they are valid syntax... ergo they parse
[00:23:19] <kimundi> (They just won't do what you want yet)
[00:23:28] <tikue_> :O) s/parse/compile
[00:23:31] *** Joins: ChemicalHarm (Mibbit@moz-A9F37238.hsd1.md.comcast.net)
[00:23:40] <benh> I'll be sad if rust keeps parsing and typechecking &5i + 5i ;)
[00:23:52] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[00:23:52] <cmr> benh: autoderef is useful
[00:23:53] *** Joins: maxli (maxli@moz-6EADA619.cpe.net.cable.rogers.com)
[00:24:10] <benh> cmr: I don't know what the rules for autoderef are
[00:24:17] <cmr> benh: neither do I!
[00:24:23] <cmr> butit works 95% of the time
[00:24:23] <tikue_> rusti: &5i + 5i
[00:24:24] -rusti- 10
[00:24:29] <tikue_> rusti: 5i + 5i
[00:24:30] -rusti- 10
[00:24:30] <cmr> thye other 5% is the rhs of a ==
[00:24:35] <tikue_> rusti: 5i + &5i
[00:24:35] -rusti- <anon>:5:14: 5:17 error: mismatched types: expected `int` but found `&int` (expected int but found &-ptr)
[00:24:36] -rusti- <anon>:5          5i + &5i
[00:24:36] -rusti-                        ^~~
[00:24:36] -rusti- error: aborting due to previous error
[00:24:36] -rusti- application terminated with error code 101
[00:24:37] <mark_edward> i still don't like autoderef
[00:24:42] <mark_edward> i want -> back
[00:24:51] <cmr> rust never had ->
[00:24:59] <mark_edward> back from the future
[00:25:06] <cmr> heh
[00:25:06] <tikue_> lol
[00:25:08] <benh> I ctrl-f'd the manual for autoderef but it only came up for, like, . field access and []
[00:25:14] <benh> alas
[00:25:15] <tikue_> mark_edward: why do you want -> instead of autoderef?
[00:25:24] <cmr> I 100% despise ->
[00:25:27] <cmr> Ugly, unnecessary.
[00:25:32] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[00:25:34] <kimundi> rusti: let vec = ~[1,2,3]; let y = vec.map(|&x| x + 10); let z = y.iter(); for &e in z { println(e.to_str()); }
[00:25:38] <benh> I 100% despise that binary operators aren't more symmetric >:[
[00:25:41] -rusti- pastebinned 35 lines of output: http://ix.io/7NF
[00:25:44] <benh> rusti: &5i + 5i
[00:25:45] -rusti- 10
[00:25:47] <benh> rusti: 5i + &5i
[00:25:48] -rusti- <anon>:5:14: 5:17 error: mismatched types: expected `int` but found `&int` (expected int but found &-ptr)
[00:25:49] -rusti- <anon>:5          5i + &5i
[00:25:49] -rusti-                        ^~~
[00:25:49] -rusti- error: aborting due to previous error
[00:25:49] -rusti- application terminated with error code 101
[00:25:58] <mark_edward> tikue_: autoderef is confusing, and it doesn't make clear what is what exactly. and it interacts badly with trait resolution
[00:26:13] <kimundi> rusti: let vec = ~[1_u16,2,3]; let y = vec.map(|&x| x + 10); let z = y.iter(); for &e in z { println(e.to_str()); }
[00:26:14] -rusti- <anon>:5:91: 5:92 error: cannot borrow immutable local variable as mutable
[00:26:14] -rusti- <anon>:5          let vec = ~[1_u16,2,3]; let y = vec.map(|&x| x + 10); let z = y.iter(); for &e in z { println(e.to_str()); }
[00:26:14] -rusti-                                                                                                     ^
[00:26:14] -rusti- error: aborting due to previous error
[00:26:15] -rusti- application terminated with error code 101
[00:26:26] <kimundi> rusti: let vec = ~[1_u16,2,3]; let y = vec.map(|&x| x + 10); let mut z = y.iter(); for &e in z { println(e.to_str()); }
[00:26:28] -rusti- 11
[00:26:28] -rusti- 12
[00:26:28] -rusti- 13
[00:26:28] -rusti- ()
[00:26:47] <mark_edward> tikue_: like if T: ToStr and x: &T i can say x.to_str(), but i can't pass x to foo<T: ToStr>(t: T)
[00:26:48] <kimundi> THERE! HAPPY NOW RUSTI, HMMMM??
[00:26:55] * kimundi should go to bed :P
[00:27:40] <tikue_> mark_edward: because to_str takes a borrowed pointer
[00:27:47] <tikue_> mark_edward: that's not an autoderef issue
[00:28:25] <benh> imo autoderef (and autoborrowing to the extent it exists i don't even know) just make everything more confusing :(
[00:28:34] <cmr> it is confusing
[00:28:36] <mark_edward> it is related, because if x: T i can also call x.to_str() but only now can i pass it to foo<T: ToStr>(t: T)
[00:28:44] <tikue_> mark_edward: that's autoborrow
[00:29:08] <tikue_> (which i understand less than autoderef)
[00:29:14] <kimundi> to_str is defined on &self, so yeah in tjsi case it'S autoborrow :P
[00:29:15] <benh> also, again, petition for the variable-length-for-variable-level-of-deref ----> operator ;)
[00:29:15] <cmr> autoborrow issimple.
[00:29:20] *** Joins: frewsxcv (Mibbit@moz-8BB75244.lightspeed.sntcca.sbcglobal.net)
[00:29:31] <tikue_> benh: hahah
[00:29:33] <cmr> If you try to call a method and it's not a &T, itwill make it a &T
[00:29:48] <frewsxcv> My girlfriend was glancing at the website, and pointed out that the negative space in the rust logo looks like cars
[00:29:49] <tikue_> cmr: it's not just method calls
[00:30:10] <kimundi> benh: I allways found that arrow confusing... why not make it variable length dot operator? xD x.....fooo()
[00:30:25] <tikue_> rusti: let v = [1, 2, 3]; fn foo(v: &[int]) { printfln!(v); } foo(v)
[00:30:27] -rusti- &[1, 2, 3]
[00:30:27] -rusti- ()
[00:30:28] *** Quits: bytewise (bytewise@moz-4A801D04.unitymediagroup.de) (Quit: Leaving)
[00:30:39] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[00:30:45] <cmr> frewsxcv: http://www.rust-lang.org/logos/rust-logo-128x128-blk.png does?
[00:30:51] <mark_edward> tikue_: if  T: Trait, and trait has method foo(&self) -> V, then x: T can call x.foo(), x: &T, can call x.foo(), x: ~T can call x.foo(), but only x:T can be passed to fn bar<T:Trait>(t: T)
[00:31:08] <kimundi> frewsxcv: Cars aftern an horrible accident it seems
[00:31:16] <benh> frewsxcv: how unfortunate, the logo is supposed to evoke that bit of the bicycle that i can't recall the english word for, iirc
[00:31:27] <tikue_> rusti: struct Foo(Bar); struct Bar(Baz); impl Baz { fn baz() { println("baz!"); } } Foo(Bar(Baz)).baz()
[00:31:28] -rusti- <anon>:5:94: 5:97 error: unresolved name `Baz`.
[00:31:28] -rusti- <anon>:5          struct Foo(Bar); struct Bar(Baz); impl Baz { fn baz() { println("baz!"); } } Foo(Bar(Baz)).baz()
[00:31:28] -rusti-                                                                                                        ^~~
[00:31:28] -rusti- error: aborting due to previous error
[00:31:29] -rusti- application terminated with error code 101
[00:31:32] <SiegeLord> frewsxcv: I can see a truck at the bottom, I guess
[00:31:34] <cmr> I don't even know what part of a bicycle that would be
[00:31:39] <tikue_> rusti: struct Foo(Bar); struct Bar(Baz); impl Baz { fn baz(&self) { println("baz!"); } } Foo(Bar(Baz)).baz()
[00:31:40] -rusti- <anon>:5:99: 5:102 error: unresolved name `Baz`.
[00:31:40] -rusti- <anon>:5          struct Foo(Bar); struct Bar(Baz); impl Baz { fn baz(&self) { println("baz!"); } } Foo(Bar(Baz)).baz()
[00:31:40] -rusti-                                                                                                             ^~~
[00:31:40] -rusti- error: aborting due to previous error
[00:31:41] <aatch> benh, cog? sprocket?
[00:31:41] -rusti- application terminated with error code 101
[00:31:44] <benh> the one the chain goes on!
[00:31:48] <mark_edward> cmr: a gear...
[00:31:51] <strcat> rusti: struct Foo(int, int); Foo(5, 2)
[00:31:52] -rusti- main::Foo(5, 2)
[00:31:55] <tikue_> rusti: struct Foo(Bar); struct Bar(Baz); struct Baz; impl Baz { fn baz(&self) { println("baz!"); } } Foo(Bar(Baz)).baz()
[00:31:56] -rusti- baz!
[00:31:56] -rusti- ()
[00:31:58] <kimundi> cmr: The part that first rusts away?
[00:32:04] <strcat> no more __field__
[00:32:08] * strcat hated that
[00:32:13] <benh> yay
[00:32:14] <kimundi> yay!
[00:32:20] <aatch> Hay!
[00:32:21] <mark_edward> tikue_: you understand what i mean?
[00:32:26] <tikue_> mark_edward: yes but that's not autoderef, that's autoborrow
[00:32:28] <tikue_> as i see it
[00:32:31] <strcat> oh and
[00:32:34] <Aetherspawn_BNC> anyone know how to run stuff from DllMain on windows?
[00:32:35] <strcat> rusti: ~5 as ~ToStr
[00:32:36] -rusti- ~std::to_str::ToStr:Send
[00:32:49] <kimundi> niiice
[00:32:53] *** Quits: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net) (Quit: dave1629)
[00:32:53] <tikue_> wow
[00:33:09] <mark_edward> tikue_: i still think it's inconsistent, how can you call all of the trait methods if you don't implement the trait?
[00:33:13] <strcat> just needs to learn how to print function types, which is easy peasy
[00:33:25] <strcat> and also print enums as paths + handle variants with named fields
[00:33:27] <benh> I mean I guess I see how autoderef and autoborrow make everything look neater but to me it also conveys "oh don't worry about levels of indirection, it'll probably work out somehow"
[00:33:47] <benh> I'm a bad programmer and I get sloppy if I don't have to be aware of levels of indirection to get the syntax right :(
[00:33:47] <kimundi> strcat: You r+-ed the last one, mind doing this one too? https://github.com/mozilla/rust/pull/8939
[00:34:21] *** Quits: frewsxcv (Mibbit@moz-8BB75244.lightspeed.sntcca.sbcglobal.net) (Quit: http://www.mibbit.com ajax IRC Client)
[00:34:25] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[00:34:42] *** Quits: santiago (santiago@moz-8ADE82B4.socal.res.rr.com) (Connection reset by peer)
[00:34:44] <kimundi> benh: Well, with all the llvm optimizations "don't worry, it will work" is kinda what we're building on often... ;)
[00:34:53] *** Joins: santiago (santiago@moz-8ADE82B4.socal.res.rr.com)
[00:35:07] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: Textual IRC Client: www.textualapp.com)
[00:35:31] <tikue_> benh: but the thing is, the only things that autoderef are things that wouldn't make it ambiguous
[00:35:52] <ChemicalHarm> Does anyone here know how rust programs intend to handle OS signals?  I see an issue on github (#22) that's been closed for 2 years...is there now (or is there intended to be) a way to install handlers for them?
[00:36:19] <tikue_> rusti: struct Foo(Bar); struct Bar(Baz); impl Bar { fn baz(&self) { println!("bar!"); } } struct Baz; impl Baz { fn baz(&self) { println("baz!"); } } Foo(Bar(Baz)).baz()
[00:36:20] -rusti- bar!
[00:36:20] -rusti- ()
[00:36:54] <mark_edward> if just feel that the following statement should be true if a type can call all of the trait methods if, and only if, the type implements the trait
[00:37:30] *** Joins: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net)
[00:37:33] <cmr> For <T: Trait>, &T does not implement Trait.
[00:38:35] <mark_edward> so why can x: &T call all of the trait methods
[00:38:43] <cmr> because of autoderef, afaik
[00:38:50] <benh> see, it's confusing
[00:38:56] <cmr> I agree it's confusing.
[00:39:14] <mark_edward> right, but at the same time, x: &T can't be passed to functions needs T: Trait
[00:39:21] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Ping timeout)
[00:39:53] <cmr> I don't really see a problem with the current situation besides that it's poorly documented.
[00:39:54] <tikue_> i'm under the impression that borrowed pointers are newtype structs of a sort
[00:40:05] <mark_edward> i think combined with type inference, this can get really messy because you often don't know what level of indirection you're at
[00:40:06] <tikue_> autoderef works consistently
[00:40:18] *** Joins: jdsanders (Adium@moz-84CB7548.hlrn.qwest.net)
[00:40:22] <cmr> mark_edward: & isn't indirection though
[00:40:27] <cmr> LLVM can inline and do other magic.
[00:40:32] <cmr> What makes it not-indirection.
[00:40:35] <Aetherspawn_BNC> anyone know how to run stuff from DllMain on windows?
[00:40:44] <mark_edward> rbrb brownies
[00:41:59] *** Quits: jdsanders (Adium@moz-84CB7548.hlrn.qwest.net) (Ping timeout)
[00:43:04] *** Quits: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net) (Connection reset by peer)
[00:44:50] *** Quits: tjc (tjc@5FEEDD2E.870F2FA5.2370DFC3.IP) (Connection reset by peer)
[00:45:16] *** Joins: tjc (tjc@5FEEDD2E.870F2FA5.2370DFC3.IP)
[00:45:16] *** ChanServ sets mode: +o tjc
[00:47:08] *** flaper87 is now known as flaper87|afk
[00:47:21] <cmr> acrichto: ping
[00:47:38] *** Quits: ChemicalHarm (Mibbit@moz-A9F37238.hsd1.md.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[00:48:10] <cmr> Luqman: oh, I meant to ping you
[00:50:29] *** Quits: heftig (heftig@moz-80B7FC6E.dip0.t-ipconnect.de) (Ping timeout)
[00:52:37] *** Joins: frewsxcv (Mibbit@moz-8BB75244.lightspeed.sntcca.sbcglobal.net)
[00:52:49] <tikue_> so does TCO have any champions in the rust community? i'd love to see `be` get implemented
[00:52:58] <bjz_> tikue_: https://mail.mozilla.org/pipermail/rust-dev/2013-April/003557.html
[00:53:18] <bjz_> you mean tail call optimization right?
[00:53:28] <strcat> LLVM can't do TCO on every platform, and it doesn't work cross-library
[00:53:29] <tikue_> hyup
[00:53:42] <tikue_> strcat: cross-library?
[00:53:48] *** Joins: heftig (heftig@moz-76E8421A.dip0.t-ipconnect.de)
[00:53:48] <strcat> cross-crate
[00:53:52] <tikue_> oh, yeah
[00:53:53] <tikue_> that's ok
[00:53:56] <tikue_> i mean
[00:54:01] <tikue_> i'd prefer a limited tco than none :)
[00:54:22] <strcat> but it doesn't work on all the platforms rust runs on
[00:54:28] <tikue_> yeah, that's unfortunate
[00:54:46] <strcat> the only thing LLVM can guarantee everywhere is sibling call optimization
[00:54:58] <strcat> all the mutually recursive functions have to have the same signature
[00:55:04] <tikue_> strcat: recursive calls are sibling as well right?
[00:55:13] <strcat> tikue_: meaning they have the same signature
[00:55:19] <tikue_> right
[00:55:27] <tikue_> well, i don't know. wouldn't that be better than nothing?
[00:56:09] <strcat> we already have it
[00:56:18] <strcat> it's a default LLVM pass
[00:56:24] <tikue_> no way
[00:56:26] <tikue_> i did not know that
[00:56:32] <bjz_> yeah, it's as much as it does for C
[00:56:51] <strcat> tikue_: the tailcallelim pass is default and does sibling call optimization
[00:57:10] <strcat> it's just that without setting -tailcallopt, it can't optimize non-matching signatures
[00:57:18] <strcat> you can pass tailcallopt yourself
[00:57:26] <strcat> but it will make every fn call slower
[00:57:45] <tikue_> rusti: fn add_fac(n: uint, total: uint) { if n == 0 { total } else { add_fac(n - 1, total + n) } } add_fac(100000u, 0u)
[00:57:47] -rusti- <anon>:5:44: 5:98 error: if and else have incompatible types: expected `uint` but found `()` (expected uint but found ())
[00:57:47] -rusti- <anon>:5          fn add_fac(n: uint, total: uint) { if n == 0 { total } else { add_fac(n - 1, total + n) } } add_fac(100000u, 0u)
[00:57:48] -rusti-                                                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[00:57:48] -rusti- error: aborting due to previous error
[00:57:49] -rusti- application terminated with error code 101
[00:57:57] <tikue_> rusti: fn add_fac(n: uint, total: uint) -> uint { if n == 0 { total } else { add_fac(n - 1, total + n) } } add_fac(100000u, 0u)
[00:57:59] -rusti- application terminated abnormally with signal 11 (Segmentation fault)
[00:58:00] <strcat> I don't think rusti optimizes
[00:58:03] <tikue_> oh
[00:58:03] <tikue_> ok
[00:58:08] <tikue_> what do i have to do to optimize?
[00:58:13] <cmr> rustc -O
[00:58:22] <tikue_> ok let me try that
[00:58:23] <cmr> --opt-level={1,2,3}
[00:58:24] <tikue_> thx :)
[00:58:32] <tikue_> both or one?
[00:58:35] <strcat> either
[00:58:37] <tikue_> kk
[00:58:41] <strcat> -O is --opt-level=2
[00:59:12] <frewsxcv> On a similar note, would https://github.com/frewsxcv/project-euler/blob/master/problems/1/run.rs be faster than just doing an iterative approach? (like while loop + counter)
[00:59:50] <strcat> recursion is never going to be faster, at best TCO kicks in and it becomes the same speed
[01:00:07] <strcat>       y if is_multiple(y) => y + sum_multiples(x-1),
[01:00:12] <strcat> this isn't tail recursive
[01:00:33] <strcat> although LLVM could rewrite it to something that *is*, but it's not starting out that way
[01:00:53] <tikue_> strcat: it will do that optimization?
[01:01:02] *** Quits: tjc (tjc@5FEEDD2E.870F2FA5.2370DFC3.IP) (Ping timeout)
[01:01:06] <strcat> tikue_: what optimization?
[01:01:25] <tikue_> strcat: changing a return from `foo + recursive_call()`
[01:01:30] <tikue_> to something TCO
[01:01:42] <strcat> well it's going to inline that call for sure
[01:01:44] <tikue_> helper_recursive(foo, running_total)
[01:01:45] <strcat> and reorganize everything
[01:01:51] <tikue_> ah cool
[01:01:52] <strcat> tikue_: it's obviously not a guarantee
[01:01:54] <tikue_> right
[01:02:18] <strcat> the code you write doesn't restrict what actually gets output to a certain pattern
[01:02:46] <tikue_> mhm
[01:02:53] <strcat> you can develop an intuitive for how things compile but in the end you always have to look at the IR for a view partway through, and the assembly for the full picture
[01:03:17] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[01:03:25] <strcat> it won't do algorithmic/structural changes from IR -> asm
[01:03:43] <strcat> but it will still reorder stuff in many ways
[01:04:16] <strcat> so if you look at the post-optimization IR you can get a good idea of what the compiled code is doing
[01:04:25] <strcat> you can't tell very much from the actual rust code
[01:04:40] <strcat> consider that every single struct will be split into scalars if possible
[01:04:46] <strcat> every small call will be inlined
[01:04:57] <strcat> *before* it really gets to work
[01:05:53] <tikue_> yeah it doesn't seem like it tail call optimizes my merge function
[01:05:56] <tikue_> maybe if i change it around...
[01:06:43] <strcat> tikue_: it does here
[01:06:45] <strcat> for that factorial fn
[01:06:59] <strcat> http://ix.io/7NH
[01:07:46] <strcat> -S --emit-llvm --opt-level=3 is the easiest way to see
[01:08:09] *** Quits: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net) (Quit: dave1629)
[01:08:36] <pnkfelix> tikue: As I recall, your merge wasn't tail-cailing.  Remember, it was doing e..g  [hd1.clone()] + merge(tl1, l2)
[01:08:42] *** Quits: roboguy (roboguy@moz-266CFD9E.cm.sunflower.com) (Input/output error)
[01:09:17] <pnkfelix> tikue_: so its going to have to leave the stack frame in place, to do the append after the recursive call to merge returns.
[01:09:37] <tikue_> pnkfelix: yeah, but llvm can still optimize it sometimes
[01:09:42] <tikue_> in this case it doesn't want to, so i'm rearranging it 
[01:09:46] <strcat> not if there's allocation
[01:09:46] <tikue_> to make it explicitly tail call
[01:09:50] <strcat> allocation is opaque to it
[01:09:56] <strcat> because we wrap malloc opaquely
[01:10:01] *** kimundi is now known as zz_kimundi
[01:10:05] <tikue_> ah
[01:10:16] <strcat> it doesn't know what exchange_malloc does
[01:10:24] <strcat> could have side effects, could return a pointer aliasing the other ptrs
[01:11:05] <strcat> I plan on marking ~ ret values noalias and converting exchange_malloc to returning ~ instead of *, but LLVM will still think it may have side effects
[01:11:57] *** Quits: miloshadzic (miloshadzi@F8195CC5.425C93D4.449B8A48.IP) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[01:12:10] <tikue_> strcat: do you think you could look at a code snippet? even with -O it's not TCO 
[01:12:18] <strcat> sure
[01:12:34] <tikue_> thank you -- https://gist.github.com/tikue/8bf1ccb9aadde0ff3bc5
[01:12:40] <strcat> tikue_: there are no optimization passes run without -O btw, so no point in looking at the code it makes
[01:12:59] <tikue_> strcat: ok, that's good to know
[01:13:01] <strcat> tikue_: it's still not tail recursive
[01:13:06] <strcat> there's a destructor call
[01:13:09] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Client exited)
[01:13:10] <strcat> from 'merged'
[01:13:13] *** Quits: KindOne (KindOne@moz-749DF21A.dynamic.ip.windstream.net) (Ping timeout)
[01:13:26] <tikue_> ah, what if i use &[T]
[01:13:35] *** Joins: jdsanders (Adium@moz-84CB7548.hlrn.qwest.net)
[01:13:39] <strcat> or move into the 2nd call maybe
[01:13:39] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[01:13:48] <tikue_> what do you mean?
[01:14:00] <strcat> you're doing a bunch of copies
[01:14:09] <strcat> rather than appending to the existing array + moving it
[01:14:17] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[01:14:19] <strcat> merged + l1 <- this is bad
[01:14:48] <strcat> it could append l1 to merged, and return merged by-value
[01:15:13] <strcat> that's why I don't like these convenience methods/operators making allocations look nicer than the right way
[01:15:21] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[01:15:29] * strcat shrugs
[01:15:53] *** Quits: frewsxcv (Mibbit@moz-8BB75244.lightspeed.sntcca.sbcglobal.net) (Quit: http://www.mibbit.com ajax IRC Client)
[01:16:05] *** Quits: jdsanders (Adium@moz-84CB7548.hlrn.qwest.net) (Ping timeout)
[01:17:05] <tikue_> so like this?
[01:17:20] <tikue_> https://gist.github.com/tikue/8bf1ccb9aadde0ff3bc5
[01:17:26] *** Joins: KindOne (KindOne@moz-85EB3CA9.dynamic.ip.windstream.net)
[01:17:29] *** Joins: sonwow (sonwow@5AB4884B.FCC4549.14D5B978.IP)
[01:18:02] <strcat> you need to do the two merged + l1/l2 too
[01:18:12] <strcat> and then it's actually tail recursive afaict
[01:18:15] <tikue_> ah ok
[01:18:22] <strcat> if LLVM can see it
[01:20:17] <tikue_> there's an append method for vectors right?
[01:20:39] <engla> it's called .push()
[01:20:50] <tikue_> engla: append would take a slice
[01:20:53] <strcat> or push_all/push_all_move
[01:21:40] <tikue_> append returns the vector
[01:21:49] <tikue_> takes vector by value
[01:21:53] *** Joins: tjc (tjc@5FEEDD2E.870F2FA5.2370DFC3.IP)
[01:21:53] *** ChanServ sets mode: +o tjc
[01:21:54] <tikue_> fn append<T: Clone>(lhs: ~[T], rhs: &[T]) -> ~[T]
[01:22:43] *** Quits: maxli (maxli@moz-6EADA619.cpe.net.cable.rogers.com) (Quit: Leaving.)
[01:23:04] <tikue_> nvm it's not a method, just a free function in std::vec
[01:23:21] <tikue_> still doesn't work though
[01:23:22] <tikue_> :(
[01:23:53] <tikue_> bus error: 10
[01:23:59] <tikue_> at a little over 10,000 elements
[01:24:16] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[01:25:49] <engla> use .push_all*
[01:25:56] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[01:25:57] <tikue_> engla: what's wrong with append?
[01:26:40] <engla> most free functions have been removed
[01:26:50] <pnkfelix> tikue_: have you looked at the source for vec::append?  This conversation is just seeming silly to me.
[01:26:51] *** Quits: KindOne (KindOne@moz-85EB3CA9.dynamic.ip.windstream.net) (Ping timeout)
[01:26:52] <engla> I don't know why this one is here, it's just calling .push_all()
[01:27:13] <strcat> tikue_: it's still likely not tail recursive
[01:27:16] <tikue_> lol really
[01:27:28] <strcat> a function call to another library could fail and unwind
[01:27:33] <strcat> so it's going to be inserting landing pads
[01:27:35] <tikue_> push_all doesn't return a value though
[01:27:38] <tikue_> so it's not the same pnkfelix 
[01:27:48] <pnkfelix> (don't get me wrong, I *like* free standing functions that return values.)
[01:28:25] <strcat> it's going to think push_all or push can fail
[01:28:33] <strcat> and it's going to have to insert a landing pad to destroy merged
[01:28:39] <tikue_> strcat: so how do you get around that?
[01:29:00] <strcat> don't allocate?
[01:29:09] <tikue_> where?
[01:29:15] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[01:29:18] <strcat> push and push_all are allocating
[01:29:25] <tikue_> but i need to push the element
[01:29:40] <strcat> you can do all the necessarily allocation up-front for a merge
[01:29:54] <strcat> you know it's going to be the size of xs + the size of ys
[01:30:09] <tikue_> sure, but then what?
[01:30:23] <strcat> well it can't see any opaque function calls
[01:30:29] <strcat> or it's not tail recursive
[01:30:41] <strcat> unless there is nothing with a destructor in scope
[01:30:43] <tikue_> ok
[01:30:48] <tikue_> isn't clone() opaque?
[01:30:55] <strcat> not for most types
[01:31:00] <tikue_> for a generic type?
[01:31:06] <strcat> depends on the type
[01:31:07] <tikue_> ok
[01:31:16] <strcat> rust doesn't use type erasure for generics
[01:31:25] <tikue_> so
[01:31:30] *** Quits: mark_edward (quassel@moz-97E995A.hsd1.in.comcast.net) (Ping timeout)
[01:31:37] *** Joins: KindOne (KindOne@moz-888F6E6B.dynamic.ip.windstream.net)
[01:31:40] <strcat> the exact types are known to LLVM, a generic function has no overhead over a non-generic one
[01:31:47] <tikue_> are you suggesting passing around indices to know where to index into the array?
[01:32:06] <strcat> &mut slices?
[01:32:10] *** Joins: mark_edward (quassel@moz-97E995A.hsd1.in.comcast.net)
[01:32:13] *** Joins: recrack (Mibbit@B4104EBB.3CC170B1.1E14B209.IP)
[01:32:24] <strcat> or just write it without recursion ;p
[01:32:29] <tikue_> lol
[01:32:44] <tikue_> my qsort seems to TCO just fine...
[01:33:02] <pnkfelix> qsort is usually in-place, no allocation
[01:33:13] <strcat> the merge part of a merge sort isn't supposed to recurse
[01:33:13] <tikue_> pnkfelix: usually
[01:33:24] <tikue_> strcat: it's prettier when it recurses
[01:33:29] <tikue_> pnkfelix: https://gist.github.com/tikue/8bf1ccb9aadde0ff3bc5#file-qsort-rs
[01:33:32] <tikue_> recursive qsort
[01:33:32] <strcat> and 1000x slower?
[01:33:44] <tikue_> strcat: if it's tail call optimized shouldn't it be comparably fast
[01:33:45] <strcat> unless you very carefully write it without the needless allocation you have now
[01:33:50] <strcat> it's not tail recursive
[01:33:53] <strcat> it can't be TCO'ed
[01:33:57] <tikue_> i know
[01:34:02] <tikue_> but if it could be
[01:34:17] <strcat> it could be, but it's likely still going to be slower than writing out the optimal algorithm
[01:34:23] <tikue_> strcat: and they're not needless allocations
[01:34:35] <strcat> an optimal merge sort only allocates 1/2 the size of the array
[01:34:36] <tikue_> strcat: you can't make it look nice without the allocations :)
[01:34:46] <tikue_> i've written optimal merge
[01:34:55] <tikue_> but when i'm writing toy code i'd prefer to make it look nice
[01:35:17] <tikue_> https://gist.github.com/tikue/798fb3b07e81cd603828#file-merge-rs
[01:35:20] <tikue_> that's the best i could do iteratively
[01:35:33] <pnkfelix> nonetheless, Rust is not Scheme, there's no TCO-guarantee here
[01:35:44] <strcat> tikue_: that's still not going to be very efficient
[01:35:58] <strcat> pnkfelix: well, sibling call optimization is guaranteed with -O if it's actually a tail recursive sibling call
[01:36:04] <tikue_> strcat: why?
[01:36:27] <strcat> tikue_: it's allocating many times, not once, and it's allocating 2x as much as necessary
[01:36:32] <pnkfelix> strcat: <sigh>.  I'm not talking about what LLVM happens to optimize.
[01:36:49] <tikue_> strcat: sorry that wasn't up to date
[01:37:14] <tikue_> https://gist.github.com/tikue/798fb3b07e81cd603828#file-merge-rs
[01:37:16] <tikue_> better?
[01:37:28] <strcat> tikue_: it's still twice as much ;p
[01:37:33] <tikue_> strcat: how so?
[01:37:58] <tikue_> because of the iterators?
[01:38:02] <strcat> if you take &mut [T] you only need to allocate max(len(a), len(b))
[01:38:23] <tikue_> um
[01:38:24] *** Joins: dew1 (Instantbir@moz-D2FA52B6.static.stls.mo.charter.com)
[01:38:32] <tikue_> you need to return a vector of length len(a) + len(b)
[01:38:33] <MrByte> Well it isn't pretty, but I've got rudimentary COM interface support working with DirectX.  Now to write a code generator for all of it.
[01:38:37] <tikue_> ohh
[01:38:41] <tikue_> if you take &mut [T]
[01:39:02] *** Joins: roboguy (roboguy@moz-266CFD9E.cm.sunflower.com)
[01:39:05] *** Quits: dew (Instantbir@moz-D2FA52B6.static.stls.mo.charter.com) (Ping timeout)
[01:39:06] *** Quits: tjc (tjc@5FEEDD2E.870F2FA5.2370DFC3.IP) (Quit: zzzzzzzzzz)
[01:39:30] <tikue_> strcat: not even libextra's merge sort does that
[01:39:34] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Client exited)
[01:39:37] <strcat> libextra's sorts are incredibly slow
[01:39:42] <tikue_> well that's silly
[01:39:45] <tikue_> >_>
[01:39:55] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[01:40:03] <strcat> ~5x slower than libc++ iirc
[01:40:20] <strcat> but the merge sorts are especially slow
[01:40:47] <tikue_> why not rewrite them ?
[01:40:50] <strcat> and a nicely done merge sort allocating 1/2 the size + using insertion sort on small runs is faster than the libc++/libstdc++ sorts
[01:41:09] <strcat> well... I think doing it as fast as C++ means using unsafe code
[01:41:20] <pnkfelix>  tikue_: probably for the same reason you're trying to write your code using recursion
[01:41:20] <tikue_> well that sucks :)
[01:41:35] <pnkfelix> tikue_: i.e., because someone thought these were optimizing for readability
[01:41:39] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[01:41:46] <tikue_> pnkfelix: i'm not optimizing for readability
[01:41:48] <strcat> pnkfelix: I think they were probably written before most of rust worked properly
[01:41:58] <tikue_> i'm just writing toy code that i think looks nice lol
[01:42:07] <tikue_> working well would be a nice perk
[01:42:14] <pnkfelix> tikue_: I must have misunderstood what you mean by: "when i'm writing toy code i'd prefer to make it look nice"
[01:42:25] <strcat> the merge sort is slower than using the not yet optimized priority queue to do a heap sort
[01:42:39] <tikue_> pnkfelix: i was specifically interested in doing some nice pattern matching
[01:43:40] <tikue_> like ([hd1, ..tl1], [hd2, ..tl2]) => { .. }
[01:43:49] <tikue_> tickles me
[01:44:34] <tikue_> it's only a little bit disappointing that it can't TCO … optimal code is rarely pretty, in any language
[01:45:07] <strcat> you can write it so that it would
[01:45:19] <tikue_> strcat: would it still look nice, though?
[01:45:23] <strcat> sure
[01:45:31] <strcat> object in scope with a destructor + calling opaque fns -> not going to get TCO
[01:45:37] <strcat> because it's not tail recursive
[01:45:40] <tikue_> sure
[01:45:50] <tikue_> but i want to maintain the structure of the code
[01:46:01] <tikue_> i don't care about the specific function calls
[01:46:04] <tikue_> just the pattern matching
[01:48:15] *** Joins: spyhunter99 (alex@moz-E7424731.bltmmd.fios.verizon.net)
[01:51:18] <jmgrosen> any mozilla guys happen to know if the internships allow high schoolers? :)
[01:51:37] <tikue_> jmgrosen: they sometimes make exceptions yes
[01:52:05] <jmgrosen> tikue_: that would just be awesome :3 better get working on contributing a lot to rustc… :P
[01:52:21] <tikue_> :) hang out in #interns too
[01:53:06] *** Joins: sp3d (a@moz-6F12212B.fidnet.com)
[01:53:30] <jmgrosen> ah, that reminds me, what's a good way to get introduced to rustc's architecture?
[01:54:05] <pnkfelix> jmgrosen: there's a README.txt in src/librustc
[01:55:02] <jmgrosen> pnkfelix: anything more in-depth than that, yet not as in-depth as actually quite reading all of the code?
[01:55:38] * strcat doubts it
[01:55:58] <jmgrosen> alright, guess i'll grok the code in my spare time then :P
[01:56:23] *** Joins: pepper_chico (pepper_chi@14AC4DFD.704EE6B0.E4090502.IP)
[01:58:20] *** Joins: carleastlund (cce@moz-C8071335.c3-0.smr-ubr1.sbo-smr.ma.cable.rcn.com)
[01:58:28] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[02:01:23] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[02:01:34] *** Quits: fyolnish (fyolnish@moz-41D2D424.uqwimax.jp) (Client exited)
[02:01:47] <Luqman> cmr: pong
[02:03:18] *** Joins: tjc (tjc@62E115A3.E5AD9C7C.70288106.IP)
[02:03:18] *** ChanServ sets mode: +o tjc
[02:03:27] <tikue_> oh wow
[02:03:32] <tikue_> i'm getting an ICE because of an option.unwrap()
[02:03:36] <tikue_> in rustc
[02:04:11] <jmgrosen> ouch
[02:05:48] <tikue_> strcat: would mut_slice_from() be an opaque function call as well?
[02:06:37] <strcat> no, it's a simple function marked #[inline]
[02:06:43] <tikue_> cool
[02:06:50] <strcat> although mut_slice contains asserts
[02:07:05] <strcat> so if it can't prove that they never happen, then those are possible failures
[02:07:17] <jmgrosen> what's the preferred way to fix tiny bugs like https://github.com/mozilla/rust/issues/8881 ?
[02:07:40] <jmgrosen> it seems like one PR for that little thing would bog down bors
[02:08:00] <strcat> there's nothing in the bors queue
[02:09:01] <jmgrosen> so just make that one change and make a PR?
[02:09:04] <engla> it's labord day in bors land
[02:09:09] <engla> -d
[02:10:05] <cmr> Luqman: I figured it out
[02:10:16] <cmr> Luqman: I wanted to turn off EnableSegmentedStacks
[02:10:21] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[02:10:26] <cmr> It's a boolo passed to one of the LLVMRust functions
[02:11:32] <lkuper> jmgrosen: there are various long-form docs in some of the compiler's subsystems.  for instance, for the type inference engine there's https://github.com/mozilla/rust/blob/master/src/librustc/middle/typeck/infer/doc.rs
[02:11:37] <strcat> cmr: why?
[02:11:52] <jmgrosen> lkuper: thanks!
[02:13:37] <tikue_> ok, i always forget the process for debugging ice's
[02:15:04] *** Quits: Earnestly (earnest@moz-F387F877.dyn.plus.net) (Ping timeout)
[02:15:46] <tikue_> what do i do :|
[02:16:30] <sully> get a backtrace
[02:16:39] <sully> figure out where it is
[02:16:45] <sully> turn on debugging output in those modules
[02:16:46] <sully> read code
[02:16:48] <tikue_> sully: how do i get a backtrace? breaking on upcall_fail didn't work
[02:16:55] <sully> it is rust_start_unwind now
[02:16:58] <tikue_> ah
[02:16:59] <Luqman> strcat: cmr is writing a kernel and doesn't want the hit to tls in function prologues for segmented stacks
[02:17:12] <Luqman> sully: i thought it was rust_begin_unwind
[02:17:19] <sully> er, that could be right
[02:17:44] <tikue_> sully: how do you turn on debugging output? and how do you know which modules?
[02:17:55] <sully> based on the backtrace and thought
[02:18:13] <sully> turn on debugging output with invocations like RUST_LOG=rustc=1,rustc::middle::typeck::check::method ...
[02:18:21] <sully> oh, and we disable it by default in the build (argh!)
[02:18:27] <sully> so you have to configure with --enable-debug
[02:19:32] <tikue_> does a failure at  middle::check_match::is_useful_specialized ring any bells?
[02:19:58] *** Parts: spyhunter99 (alex@moz-E7424731.bltmmd.fios.verizon.net) (Leaving)
[02:22:54] <cmr> strcat: what Luqman said.
[02:23:06] <cmr> Part of my work with runtimeless/profiles.
[02:23:26] <cmr> Assuming there's a certain structure at a certain offset from the fs segment... yech.
[02:23:44] <acrichto> mark_edward: (re format!) yes :)
[02:23:46] <acrichto> cmr: pong
[02:24:02] <cmr> acrichto: see above; it's resolved.
[02:24:24] <acrichto> ah ok
[02:24:28] <cmr> Although I might need your guys' help some more, next on the plate is removing the libraries rustc thinks it needs to link to.
[02:24:38] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[02:25:04] <cmr> I want to remove the pattern of "compile to llvm, use llc, assemble+link" and have rustc be able to be more configurable.
[02:25:18] <strcat> you can use clang instead of llc
[02:25:42] <strcat> and you can use -c
[02:26:18] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[02:26:29] <cmr> just pointing out the existing pattern that dueboot and armboot use
[02:27:01] <acrichto> don't they do some manual editing of the files as well?
[02:27:07] <acrichto> (I'm not actually sure how they build)
[02:27:09] <cmr> yeah, it's pretty janky.
[02:27:14] <cmr> https://github.com/jensnockert/dueboot/blob/master/Makefile#L53
[02:27:47] <acrichto> huh that's interesting
[02:28:02] <tikue_> strcat: do you think this would do the trick? https://gist.github.com/tikue/8bf1ccb9aadde0ff3bc5#file-tco-rs
[02:28:13] <acrichto> wonder why s/arm-unknown-linux-gnueabihf/arm-none-eabi/g is needed
[02:28:29] <cmr> Not sure, but it's definitely not targeting linux
[02:28:34] <strcat> tikue_: if T has no destructor, maybe
[02:28:43] <strcat> but mut_slice_from calls mut_slice and that uses assert
[02:28:53] <cmr> I want rustc to have an $arch-elf target like clang and gcc have (i386-elf, x86_64-elf, etc)
[02:29:32] <Luqman> acrichto: because before rustc would just always pass arm-unknown-linux-gnueabihf as the target if you were building for arm/linux
[02:29:58] <acrichto> Luqman: oh dear, I think I saw something awhile back that fixed that?
[02:30:08] <Luqman> acrichto: also, 3 of those seds are no longer needed 
[02:30:14] <acrichto> the core_loop/core_setup should be fixed now yeah
[02:30:18] <tikue_> strcat: unfortunately that code ICE's so i can't test it lol
[02:30:22] <acrichto> fixedstacksegment is interesting
[02:30:35] *** Quits: paulproteus (quassel@rose.makesad.us) (Ping timeout)
[02:30:49] *** Joins: paulproteus (quassel@moz-E86A3B42.makesad.us)
[02:33:33] *** Quits: inf-groupoid (user@580120F5.8ED93E28.1C8C8CE9.IP) (Quit: brb)
[02:35:23] *** Quits: tjc (tjc@62E115A3.E5AD9C7C.70288106.IP) (Quit: zzzzzzzzzz)
[02:35:53] *** Joins: inf-groupoid (user@580120F5.8ED93E28.1C8C8CE9.IP)
[02:36:19] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[02:36:35] *** Quits: sp3d (a@moz-6F12212B.fidnet.com) (Ping timeout)
[02:39:49] *** Joins: fyolnish (fyolnish@moz-BE2BAE5B.miinet.jp)
[02:41:21] *** Quits: zz_kimundi (kimundi@moz-1527D01.dip0.t-ipconnect.de) (Ping timeout)
[02:42:00] *** Quits: tikue_ (tkuehn@moz-FEADCD38.hsd1.pa.comcast.net) (Quit: tikue_)
[02:42:22] *** Quits: KindOne (KindOne@moz-888F6E6B.dynamic.ip.windstream.net) (Ping timeout)
[02:44:33] *** Joins: zz_kimundi (kimundi@moz-57175039.dip0.t-ipconnect.de)
[02:45:01] *** zz_kimundi is now known as kimundi
[02:45:19] <mark_edward> acrichto: how do i format a struct that implements ToSTr?
[02:45:43] <acrichto> rusti: format!("{}", 1.to_str())
[02:45:53] <acrichto> well, like that
[02:45:54] -rusti- pastebinned 57 lines of output: http://ix.io/7NL
[02:46:07] <acrichto> rusti: format!("{}", 1u.to_str())
[02:46:09] -rusti- ~"1"
[02:46:41] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[02:47:04] *** Joins: KindOne (KindOne@moz-A03C5F46.dynamic.ip.windstream.net)
[02:47:05] <mark_edward> acrichto: the python syntax has a {0!s/r:} syntax for types implemening __str__ and __repr__. is anything similiar planned for rust?
[02:47:55] <acrichto> mark_edward: not currently, but not for any particular reason
[02:48:06] <strcat> ToStr should likely be removed
[02:48:08] <strcat> as a trait
[02:48:21] <mark_edward> strcat: what will be it's replacement?
[02:48:31] <SiegeLord> rusti: format!("{:s}", 1i32)
[02:48:33] <strcat> just the default formatting one, once it's taught about size hints
[02:48:34] -rusti- pastebinned 6 lines of output: http://ix.io/7NM
[02:48:54] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Quit: Gone to save the world!)
[02:49:15] <acrichto> mark_edward: it should arguably format into some sort of io::Writer instead of into a string which is *then* moved into a writer
[02:49:20] <mark_edward> strcat: so std::fmt::Default? implementing seems a bit more difficult than implementing ToStr?
[02:49:22] *** Joins: tjc (tjc@62E115A3.E5AD9C7C.70288106.IP)
[02:49:22] *** ChanServ sets mode: +o tjc
[02:49:37] <mark_edward> acrichto: that makes sense! will we have string writers?
[02:50:12] <acrichto> mark_edward: brson knows more about that. He was mentioning that there's reasons that they're not currently implemented on top of generic io::Writer instances, but I forget the specific reasons
[02:50:25] <acrichto> mark_edward: although you can certainly define std::fmt::Default for your type to format it with {}
[02:50:44] <acrichto> I'm not really sure what it would do, but we could even have a deriving thing for types
[02:50:54] <acrichto> but for debugging it's just better to use {:?}
[02:52:05] <strcat> acrichto: do format specifiers have to be 1 char?
[02:52:05] <mark_edward> acrichto: keeping the {0!s/r} seems useful. `r` could be like old fmt!("%?") and `s` could use the std::fmt::Default implementation, if available
[02:52:23] <strcat> > is like %?
[02:52:25] <strcat> er
[02:52:27] <acrichto> strcat: no, they're just required to be an identifier
[02:52:27] <strcat> ? is like %? *
[02:52:30] <strcat> they are the same thing
[02:52:42] <acrichto> huh?
[02:52:49] <strcat> acrichto: responding to mark_edward 
[02:52:53] <acrichto> mark_edward: is the way that works that you type {!s} ?
[02:52:56] <acrichto> oh
[02:53:13] <strcat> acrichto: I am going to add a way to fetch type names, not sure if it's common enough to deserve a format specifier
[02:53:34] <acrichto> bblum reserved `typeof` recently
[02:53:38] <acrichto> although I'm not entirely sure why
[02:53:52] <cmr> let x: typeof y = foo;
[02:54:03] <acrichto> ah yes
[02:54:11] <cmr> Surely you've seen some of the huge honking iterator types? :)
[02:54:41] <cmr> I think the core devs agreed that reserving more keywords that go unused is better than wanting them but needing to break backwards compat.
[02:54:50] <mark_edward> strcat: but that's not in the Python syntax isn't it? i think we should try and stick to it, format syntaxes are big and hard to learn...
[02:54:50] <acrichto> mark_edward: if the syntax is {!s} or {!r} then {!r} == {:?} and I think that it's a fine replacement and I'd rather be explicit in requiring a string for {:s} because that way you know what's going in and what it's expecting
[02:54:53] *** Quits: tjc (tjc@62E115A3.E5AD9C7C.70288106.IP) (Quit: zzzzzzzzzz)
[02:55:10] <strcat> mark_edward: python doesn't have an equivalent to rust's repr
[02:55:16] <strcat> they aren't the same at all
[02:55:17] <SiegeLord> I'm confused what's different about {:s} and {!s}
[02:55:19] <acrichto> mark_edward: it's true though that we don't want to deviate too much, if you want to write up an issue that would be a good place to have discussion from others as well :)
[02:55:38] <mark_edward> strcat: how are they different?
[02:55:52] <strcat> because python's uses a magic method name
[02:55:55] <cmr> Python's is overridable, for one.
[02:56:00] <strcat> rust's cannot be overridden by a type
[02:56:08] <strcat> and it will never, ever be a stable thing
[02:56:13] <strcat> it's *just* for debugging
[02:56:37] <strcat> it may end up being tagged as `unsafe` too
[02:56:56] <acrichto> you will fight for ? to be unsafe to the death
[02:57:18] <mark_edward> why would it be unsafe?
[02:57:21] <strcat> well if it's not unsafe we can just remove privacy because it doesn't do anything ;p
[02:57:51] <cmr> I agree that violating the visibility rules should require unsafe.
[02:57:58] <acrichto> mark_edward: it reads off private fields, and you could have a type which unsafely exposes things through a private field which if read would cause trouble
[02:57:59] <strcat> mark_edward: it's unsafe because we currently do not require that types store valid types in all of their fields
[02:58:05] <cmr> It's not bad, just unsafe.
[02:58:13] <strcat> there are library types doing stuff like storing null in ~
[02:58:14] <cmr> Unsafe seems to be getting a really bad rap
[02:58:16] <strcat> %? makes that unsafe
[02:58:32] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Ping timeout)
[02:58:43] <mark_edward> i see
[02:59:36] <acrichto> rusti: struct A<'self> { a: &'self int } let a: A = unsafe { std::cast::transmute(0) }; a
[02:59:36] -rusti- application terminated abnormally with signal 11 (Segmentation fault)
[02:59:41] <acrichto> mark_edward: ^
[02:59:49] *** Joins: jdsanders (Adium@moz-84CB7548.hlrn.qwest.net)
[03:00:01] <acrichto> or well rather what if `a` is priv
[03:00:05] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[03:02:35] <mark_edward> rusti:  mod foo { pub struct X { priv m: ~int, } impl X { pub fn new(m: int) -> X { X { m: ~m} } } } let x = foo::X::new(1); x
[03:02:36] -rusti- main::foo::X{m: ~1}
[03:02:41] *** Quits: zalzane (zalzane@moz-AF4054A5.socal.res.rr.com) (Ping timeout)
[03:02:52] <mark_edward> acrichto: i see
[03:04:03] <cmr> strcat: great work with repr btw
[03:04:17] <strcat> thanks ;]
[03:04:28] <strcat> now if only I could figure out where exactly I should emit the type name slices
[03:04:30] <strcat> :s
[03:04:48] <acrichto> strcat: would it be possible to print out the underlying type of a trait object?
[03:04:55] <strcat> acrichto: yes
[03:04:59] <strcat> acrichto: they have a tydesc
[03:04:59] <cmr> that'd be pretty useful
[03:05:07] <strcat> I plan on adding the type name to the tydesc
[03:05:08] <acrichto> for debugging purely that may be pretty nice
[03:05:20] <acrichto> where's the tydesc?
[03:05:22] <cmr> Who needs gdb when we have printf and strcat!
[03:05:26] <acrichto> it it part of the vtable?
[03:05:28] <cmr> (no offense to mw :p)
[03:05:33] <strcat> acrichto: yes
[03:05:37] <acrichto> aha
[03:05:40] <strcat> there is the object ptr and the trait ptr
[03:05:47] <bblum> acrichto: i imagine $? could be capable of printing it; if it doesn't today, it should
[03:05:48] <Luqman> cmr: what does the strcat macro do?
[03:05:49] <strcat> the trait ptr has a tydesc, and one or more function ptrs
[03:06:06] <cmr> Luqman: fixes all the annoying bugs.
[03:06:16] <strcat> bblum: well I made %? print the trait type
[03:06:17] <acrichto> bblum: yeah if we could see (&mut rt::io::mem::MemWriter as &mut io::Writer) that'd be awesome
[03:06:30] <strcat> rusti: ~5 as ~ToStr
[03:06:31] -rusti- ~std::to_str::ToStr:Send
[03:06:41] <acrichto> :Send is sad :(
[03:06:45] <strcat> why? it is
[03:06:46] <acrichto> rusti: ~5 as ~ToStr:
[03:06:47] -rusti- ~std::to_str::ToStr<no-bounds>
[03:06:47] <strcat> ;p
[03:07:01] <bblum> the pretty printing for trait bounds is nonoptimal
[03:07:12] <acrichto> rusti: @5 as @ToStr
[03:07:13] -rusti- @std::to_str::ToStr:'static
[03:07:16] <acrichto> rusti: @5 as @ToStr:
[03:07:17] -rusti- @std::to_str::ToStr<no-bounds>
[03:07:18] <bblum> especially the part where "<no-bounds>" fails the pretty print tests
[03:07:23] <bblum> i didn't really do a good job on that
[03:07:29] <strcat> I think the pretty print tests must be mostly xfailed
[03:07:32] <strcat> because it doesn't work
[03:07:33] <bblum> yes
[03:07:34] <strcat> :s
[03:07:43] <bblum> what should happen is it should reapply the defaults
[03:07:47] *** Joins: Shaladdle (Shaladdle@moz-424BC304.hsd1.pa.comcast.net)
[03:07:49] *** Joins: zalzane (zalzane@moz-38310FA7.socal.res.rr.com)
[03:07:49] <bblum> so ":Send" appears as ""
[03:08:06] <bblum> but, if the user  typed ":Send", it would also appeear as ""
[03:08:12] <cmr> for the love of god please make a comment indicating the shared knowledge if you add that.
[03:08:12] <bblum> because the defaults are applied during astconv
[03:08:24] <bblum> ?
[03:08:40] <aatch> I don't really mind it printing out the default bounds in the type name.
[03:08:40] *** Joins: sindork (sindork@ABFA98AB.DD47BB48.F7A44A1B.IP)
[03:08:45] <cmr> bblum: the pretty printer knowing the defaults astconv does.
[03:08:51] <bblum> cmr: oh yeah
[03:08:53] <cmr> same knowledge, duplicated.
[03:08:58] <bblum> that would need a big comment yeah
[03:09:00] <cmr> can get out of sync easily without a comment
[03:09:05] <aatch> I can see it helping debugging.
[03:09:08] <cmr> and/or tests, but pft :p
[03:09:28] <aatch> though I agree <no-bounds> isn't ideal
[03:11:01] <engla> the important place these pretty prints appear in are compiler error messages right? So it's best to design for usability not for debugging
[03:11:26] <cmr> Also eventually it'd be nice if rustdoc could use the pretty printer.
[03:11:27] *** Joins: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP)
[03:11:27] *** ChanServ sets mode: +o jdm
[03:11:47] <aatch> Well there's two places, aren't there? The pretty-printer that the compiler uses and the printer that %? uses.
[03:11:47] <cmr> Right now it's not really usable as it isn't structured in a way amenable to consumption by tools without just reparsing.
[03:12:17] <strcat> bblum: you know what was fun? if you named all your fields __field__ it would count as a tuple struct
[03:12:19] <strcat> :s
[03:12:27] <cmr> hahah
[03:12:30] * strcat changed the magic string to <unnamed_field> since it can't appear in a field name
[03:12:34] <bblum> strcat: :S indeed
[03:12:39] <cmr> rustc would accept it as a tuple struct, or just print that way?
[03:12:49] <strcat> cmr: well, half a tuple struct
[03:12:55] <strcat> it wouldn't make a constructor fn for it
[03:13:00] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[03:13:04] <strcat> it would be constructed as a named struct
[03:13:25] <strcat> but it would appear as a tuple struct in debug info, repr, and I think it broke some other things
[03:13:31] <cmr> yikes
[03:14:03] <strcat> you can thank token.rs for this
[03:14:18] <strcat> it has a magic interned string table, *some* of which correspond to keywords or special things like field names
[03:14:29] <strcat> so this string is a magic interned string
[03:14:30] <cmr> yeah I've seen that table
[03:14:31] <cmr> it's yucky.
[03:14:37] <strcat> and then it manually specifies a bunch of indices
[03:15:35] <strcat> cmr: lang items are the same way ;[
[03:15:54] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[03:15:54] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/7Oswsw
[03:15:54] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[03:15:57] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[03:15:57] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/ku3lyg
[03:15:57] <ghrust> 13rust/06auto 14af3cde2 15Felix S. Klock II: Long awaited test case for #2355.
[03:15:57] <ghrust> 13rust/06auto 144f151b3 15bors: auto merge of #8936 : pnkfelix/rust/fsk-issue-2355-testcase, r=alexcrichton...
[03:15:57] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[03:17:34] <strcat> cmr: https://github.com/mozilla/rust/issues?direction=desc&labels=A-reflect&sort=created&state=open only issues left that I know about
[03:17:47] <strcat> other than minor things like it not being valid rust code - but I don't know if that's desired
[03:18:02] <cmr> I don't even know if it's possible, especially for cyclic @ or private fields.
[03:18:07] <strcat> yeah
[03:23:14] *** Quits: zeuxcg (zeuxcg@moz-80D1F912.hsd1.ca.comcast.net) (Quit: Leaving)
[03:24:40] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[03:24:41] <strcat> acrichto: repr actually didn't print the type names at all before ;p
[03:25:03] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[03:25:03] <strcat> it just printed {} for a unit struct, {__field__: 5} for a tuple struct and {x: 5, y: 10} for a normal one, no name
[03:25:13] <strcat> still need to qualify the enum paths
[03:26:43] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[03:29:23] <sfackler> does anyone have any ideas on the right way to do this? So right now I have a setup essentially like this: https://gist.github.com/sfackler/dd7493dd0374b2fc6d51 . I'd like to make a convenience Connection.query function to avoid forcing people to do let stmt = conn.prepare(); let result = stmt.query();
[03:29:45] <sfackler> it seems like it'd need to package the statement and result together, but i'm not sure if that's possible
[03:31:34] <strcat> as in
[03:31:57] <strcat> struct Query<'self> { stmt: Statement<'self>, rslt: Result<'self> } ?
[03:32:29] <sfackler> right, but that doesn't work since result borrows a reference to the statement so the query can't be moved when returning it
[03:33:16] <sfackler> actually, I don't even think Query can be constructed since it'd require moving the statement after making the result
[03:33:50] <sfackler> the other hairy issue is that both Statement and Result have destructors and the Result's destructor has to run before the Statement's
[03:34:06] *** Joins: tikue_ (tkuehn@moz-FEADCD38.hsd1.pa.comcast.net)
[03:35:08] *** Joins: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net)
[03:40:48] <sfackler> though really, once https://github.com/mozilla/rust/issues/3511 gets fixed, doing conn.prepare().query() should be possible which may be close enough
[03:44:37] *** Quits: roboguy (roboguy@moz-266CFD9E.cm.sunflower.com) (Input/output error)
[03:46:57] *** Joins: roboguy (roboguy@moz-266CFD9E.cm.sunflower.com)
[03:47:20] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[03:49:07] *** Quits: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net) (Input/output error)
[03:50:16] *** Quits: jdsanders (Adium@moz-84CB7548.hlrn.qwest.net) (Quit: Leaving.)
[03:53:13] *** Quits: recrack (Mibbit@B4104EBB.3CC170B1.1E14B209.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[03:54:31] <jmgrosen> I'm trying to `make check`, but keep getting these types of errors:
[03:54:31] <jmgrosen> task <unnamed> failed at 'called `Result::unwrap()` on `Err` value: error opening x86_64-apple-darwin/test/run-pass/enum-discrim-range-overflow.out: No such file or directory', /Users/john/Projects/rust/src/libstd/result.rs:120
[03:54:32] <jmgrosen> test [run-pass] run-pass/enum-discrim-range-overflow.rs ... FAILED
[03:54:44] *** Quits: eatkinson (eatkinson@moz-261EDE03.hsd1.ca.comcast.net) (Quit: eatkinson)
[03:54:53] <jmgrosen> anyone know why?
[03:55:45] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[03:57:24] *** Joins: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net)
[03:57:52] <strcat> acrichto: you should do what python does for escaping {}
[03:58:16] <strcat> >>> "{} {}".format(2, 3)
[03:58:17] <strcat> '2 3'
[03:58:19] <strcat> >>> "{} {{}} {}".format(2, 3)
[03:58:21] <strcat> '2 {} 3'
[03:58:23] <strcat> no need for \
[03:58:29] <strcat> just double {{ or double }}
[03:58:50] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[03:58:54] *** Quits: RMF (RMF@moz-9A206CFB.dsl.telepac.pt) (Ping timeout)
[03:59:12] <engla> strcat: }} already appears in the syntax though
[03:59:23] <strcat> hm, when?
[03:59:30] <engla> the select and plural rules
[04:00:02] <engla> https://github.com/mozilla/rust/blob/master/src/libstd/fmt/mod.rs#L167
[04:01:47] <engla> format!("{0, plural, one{apple} other{apples}}", 2)
[04:01:50] <engla> rusti: format!("{0, plural, one{apple} other{apples}}", 2)
[04:01:50] -rusti- ~"apples"
[04:03:26] <engla> rusti: format!("{0, plural, one{{0} apple} other{{0} apples}}", 1)
[04:03:27] -rusti- ~"1 apple"
[04:03:45] *** Joins: RMF (RMF@moz-5FC5A0D8.dsl.telepac.pt)
[04:04:31] <engla> the plural thing has five cases  zero, one, few, many, other; other must always be present
[04:04:54] <engla> the others are used for languages that need them; in english the two cases are only one and other
[04:05:31] <carleastlund> Huh, what languages have separate cases for few and many?
[04:06:00] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[04:06:24] <engla> apparently polish has a funky thing it uses  different plural for numbers ending in 1-4 and 5-9
[04:06:47] <engla> except the 10-20s
[04:08:17] *** Quits: boredomist (user@moz-63CF9F31.res-cmts.sesp.ptd.net) (Ping timeout)
[04:08:42] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[04:11:49] <engla> arabic apparently has 6 plural forms, but since three of them are just for 0,1,2 it can still be supported
[04:12:39] <engla> rusti: format!("{0, plural, =3{{0} guns} one{{0} apple} other{{0} apples}}", 3)
[04:12:40] -rusti- ~"3 guns"
[04:13:18] <tiffany> whoa
[04:14:08] *** Joins: eatkinson (eatkinson@moz-261EDE03.hsd1.ca.comcast.net)
[04:14:36] <cmr> rusti: format!("{0, plural, =3{{0} guns} one{{0} apple} other{{0} apples}}", 2)
[04:14:37] -rusti- ~"2 apples"
[04:14:42] <cmr> huh
[04:14:44] <cmr> pcool
[04:15:03] <engla> it doesn't support localization at the moment
[04:16:12] <jeaye> rusti: fmt!("%i32", 4i32)
[04:16:17] -rusti- pastebinned 7 lines of output: http://ix.io/7NR
[04:16:49] <acrichto> strcat: yeah unfortunately python doesn't support nested methods or things like that so they don't have to worry about {{, but we do :(
[04:17:07] <acrichto> or maybe not {{ but }} definitely, although I do *far* prefer that syntax to \\\\{
[04:17:08] <jeaye> What's the fmt! specifier for i32?
[04:17:20] <acrichto> jeaye: sadly one doesn't exist, it's only defined for int
[04:17:23] <acrichto> if you use format! though...
[04:17:29] <acrichto> rusti: format!("{}", 4i32)
[04:17:30] -rusti- ~"4"
[04:17:36] <jeaye> No, I can't use format, really. :(
[04:17:39] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[04:17:40] <acrichto> fmt! will eventually be phased out for format!
[04:17:46] <acrichto> in the meantime 'as int' is required
[04:17:54] <jeaye> Ok, I'll cast for now. Thanks.
[04:19:50] *** Quits: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net) (Ping timeout)
[04:20:57] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[04:20:57] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/ku3lyg
[04:20:57] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[04:22:30] *** Quits: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net) (Ping timeout)
[04:22:58] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[04:25:36] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[04:25:53] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[04:25:54] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/dBKthQ
[04:25:54] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[04:25:56] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[04:25:56] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/LpMV6w
[04:25:56] <ghrust> 13rust/06auto 1470f3cab 15Alex Crichton: Fix the std::fmt doc-block to show up in pandoc
[04:25:56] <ghrust> 13rust/06auto 143105fac 15bors: auto merge of #8941 : alexcrichton/rust/fix-comment, r=thestinger
[04:25:57] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[04:26:00] <engla> carleastlund: this table is interesting.. http://www.unicode.org/cldr/charts/supplemental/language_plural_rules.html#comparison
[04:27:16] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[04:29:33] <carleastlund> Huh.  Welsh has special rules for 0, 1, 2, 3, and 6.
[04:37:38] *** Quits: samx (sami@moz-D9DA5773.dyn.optonline.net) (Quit: This computer has gone to sleep)
[04:38:13] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[04:40:10] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[04:47:10] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[04:48:51] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.1)
[04:53:03] *** Joins: Uther (Instantbir@moz-1B244B05.hfc.dyn.abo.bbox.fr)
[04:53:50] *** Joins: jdsanders (Adium@moz-84CB7548.hlrn.qwest.net)
[04:55:06] *** Joins: sp3d (a@moz-6F12212B.fidnet.com)
[05:00:19] *** Joins: robarnold (rob@BD56354E.DB510C09.6E370BFC.IP)
[05:03:37] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[05:04:44] *** Joins: nsf (nsf@moz-EEF3238A.convex.ru)
[05:04:56] *** Quits: inf-groupoid (user@580120F5.8ED93E28.1C8C8CE9.IP) (Quit: ERC Version 5.3 (IRC client for Emacs))
[05:05:25] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[05:10:59] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[05:10:59] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 143105fac to 144f151b3: 02http://git.io/N3iJvQ
[05:10:59] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[05:11:00] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[05:11:01] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/nL1nIw
[05:11:01] <ghrust> 13rust/06auto 1470f3cab 15Alex Crichton: Fix the std::fmt doc-block to show up in pandoc
[05:11:01] <ghrust> 13rust/06auto 1458decdd 15bors: auto merge of #8941 : alexcrichton/rust/fix-comment, r=thestinger
[05:11:01] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[05:20:31] *** Quits: kini (kini@moz-92AA953A.members.linode.com) (Ping timeout)
[05:22:12] *** Joins: kini (kini@moz-92AA953A.members.linode.com)
[05:22:40] *** Quits: tikue_ (tkuehn@moz-FEADCD38.hsd1.pa.comcast.net) (Quit: tikue_)
[05:22:58] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[05:24:01] *** Quits: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca) (Connection reset by peer)
[05:25:57] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[05:26:56] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[05:27:37] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[05:28:42] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[05:29:43] *** Quits: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP) (Ping timeout)
[05:29:52] *** Quits: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Ping timeout)
[05:38:25] *** Quits: tautologico (lymph@8ABDEDA.34CAB63A.7B974E06.IP) (Quit: tautologico)
[05:40:41] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[05:42:17] *** Quits: aatch (aatch@moz-B437F499.pocketrent.com) (Ping timeout)
[05:42:40] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[05:43:28] *** Joins: aatch (aatch@moz-B437F499.pocketrent.com)
[05:46:50] *** Joins: valenting (Thunderbir@32FF7B83.F5D5DDE0.7A932F41.IP)
[05:48:14] *** Joins: sigma (sigma@moz-B8E78D5.range86-136.btcentralplus.com)
[05:58:01] *** Joins: jaen (jaen@FB01674D.56B727FE.4B52F012.IP)
[06:09:45] *** Quits: valenting (Thunderbir@32FF7B83.F5D5DDE0.7A932F41.IP) (Ping timeout)
[06:10:53] *** Joins: valenting (Thunderbir@32FF7B83.F5D5DDE0.7A932F41.IP)
[06:11:36] *** Quits: tikue (quassel@moz-FEADCD38.hsd1.pa.comcast.net) (Connection reset by peer)
[06:11:37] *** Joins: tikue (quassel@moz-FEADCD38.hsd1.pa.comcast.net)
[06:11:51] *** Quits: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP) (Ping timeout)
[06:15:03] *** Quits: valenting (Thunderbir@32FF7B83.F5D5DDE0.7A932F41.IP) (Ping timeout)
[06:15:25] *** Quits: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net) (Ping timeout)
[06:15:43] *** Quits: jdsanders (Adium@moz-84CB7548.hlrn.qwest.net) (Quit: Leaving.)
[06:15:58] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[06:15:58] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/nL1nIw
[06:15:58] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[06:16:19] *** Joins: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net)
[06:17:32] *** Joins: tjc (tjc@2C194632.3778D849.1D6E592A.IP)
[06:17:33] *** ChanServ sets mode: +o tjc
[06:18:13] *** Quits: tjc (tjc@2C194632.3778D849.1D6E592A.IP) (Quit: zzzzzzzzzz)
[06:22:09] *** Quits: roboguy (roboguy@moz-266CFD9E.cm.sunflower.com) (Input/output error)
[06:22:47] *** Joins: roboguy (roboguy@moz-266CFD9E.cm.sunflower.com)
[06:24:33] *** Quits: sp3d (a@moz-6F12212B.fidnet.com) (Ping timeout)
[06:25:23] *** Joins: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP)
[06:25:23] *** ChanServ sets mode: +o jdm
[06:25:46] *** Joins: valenting (Thunderbir@D448D4D7.408459D6.D608C900.IP)
[06:26:24] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[06:27:33] *** Joins: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com)
[06:28:05] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[06:28:38] *** Joins: Ms2ger (Ms2ger@B7B2FF50.C60A97A6.F9FB0584.IP)
[06:29:12] <kaeso> acrichto: (wrt. to #4259) I told the guy (sylvestre) that you are the submodule owner and to get in touch with you for any clarifications
[06:29:45] <acrichto> kaeso: thanks!
[06:29:48] *** Joins: tjc (tjc@9CD1AD84.3778D849.1D6E592A.IP)
[06:29:48] *** ChanServ sets mode: +o tjc
[06:30:09] <acrichto> I shall post a vigil on my inbox
[06:30:49] *** Joins: zalzane|alt (zalzane@moz-38310FA7.socal.res.rr.com)
[06:30:59] *** Quits: tjc (tjc@9CD1AD84.3778D849.1D6E592A.IP) (Quit: zzzzzzzzzz)
[06:31:27] <kaeso> acrichto: he's in UTC+2 though and not here, but I don't think he will get to the patch queue before this weekend
[06:31:49] <acrichto> certainly no rush on that
[06:32:03] *** Quits: zalzane (zalzane@moz-38310FA7.socal.res.rr.com) (Ping timeout)
[06:33:41] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[06:34:17] *** Quits: dumitru (dgherman@moz-7C253BEB.getcadre.com) (Ping timeout)
[06:34:18] *** Joins: tjc (tjc@5320A7E.3778D849.1D6E592A.IP)
[06:34:18] *** ChanServ sets mode: +o tjc
[06:35:16] *** Joins: dumitru (dgherman@moz-7C253BEB.getcadre.com)
[06:36:30] *** Quits: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net) (Input/output error)
[06:37:02] *** Quits: tjc (tjc@5320A7E.3778D849.1D6E592A.IP) (Ping timeout)
[06:38:28] *** Quits: roboguy (roboguy@moz-266CFD9E.cm.sunflower.com) (Input/output error)
[06:42:41] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[06:45:54] *** Joins: tjc (tjc@47E9D3A2.3778D849.1D6E592A.IP)
[06:45:54] *** ChanServ sets mode: +o tjc
[06:50:56] *** flaper87|afk is now known as flaper87
[06:52:36] *** Quits: dumitru (dgherman@moz-7C253BEB.getcadre.com) (Ping timeout)
[06:53:25] *** Quits: tjc (tjc@47E9D3A2.3778D849.1D6E592A.IP) (Ping timeout)
[06:54:44] *** Joins: dumitru (dgherman@moz-7C253BEB.getcadre.com)
[06:56:18] *** Quits: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP) (Quit: Lost terminal)
[06:56:58] *** Joins: victorporof (victorporo@9D964D4D.36D485C.2B3D3D4.IP)
[06:58:15] *** Joins: tjc (tjc@moz-964B6DA.tmodns.net)
[06:58:15] *** ChanServ sets mode: +o tjc
[07:02:13] *** Quits: eatkinson (eatkinson@moz-261EDE03.hsd1.ca.comcast.net) (Quit: eatkinson)
[07:02:59] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Client exited)
[07:03:33] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[07:05:13] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[07:09:59] *** Quits: tjc (tjc@moz-964B6DA.tmodns.net) (Ping timeout)
[07:11:02] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[07:13:43] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[07:16:03] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[07:16:04] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/zGYG9g
[07:16:04] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[07:16:05] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[07:16:05] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/NSyhAw
[07:16:05] <ghrust> 13rust/06auto 147e70247 15Alex Crichton: Don't have format! move out of local variables
[07:16:05] <ghrust> 13rust/06auto 1439060e2 15bors: auto merge of #8945 : alexcrichton/rust/ifmt-dont-move, r=thestinger
[07:16:05] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[07:19:17] *** Joins: sebcrozet (sebcrozet@moz-6DA639AF.w80-13.abo.wanadoo.fr)
[07:19:48] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[07:20:04] *** Quits: jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Quit: Don't tell them I was here...)
[07:21:36] *** Quits: valenting (Thunderbir@D448D4D7.408459D6.D608C900.IP) (Ping timeout)
[07:21:48] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[07:22:23] *** Quits: ski (md9slj@moz-4BB5E0FF.studat.chalmers.se) (Client exited)
[07:26:46] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[07:27:19] *** Quits: dumitru (dgherman@moz-7C253BEB.getcadre.com) (Ping timeout)
[07:28:26] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[07:28:32] *** Quits: pepper_chico (pepper_chi@14AC4DFD.704EE6B0.E4090502.IP) (Quit: Textual IRC Client: www.textualapp.com)
[07:30:08] *** Joins: tjc (tjc@moz-964B6DA.tmodns.net)
[07:30:09] *** ChanServ sets mode: +o tjc
[07:31:10] *** Joins: threecreepio (jdp@moz-1A9F0A3C.cust.bredband2.com)
[07:37:47] *** Joins: dumitru (dgherman@moz-7C253BEB.getcadre.com)
[07:42:42] *** Quits: tjc (tjc@moz-964B6DA.tmodns.net) (Quit: zzzzzzzzzz)
[07:47:14] <strcat> acrichto: well that was easy ;p
[07:47:51] <glyc> Question about how heavy is   do task::try {}   <- is this just a function call, or does it start a new thread, or otherwise make kernel calls?
[07:48:32] <Ms2ger> I believe there's a thread pool
[07:48:35] <strcat> tasks are multiplexed on OS threads by the scheduler
[07:49:07] <strcat> you can choose the strategy used to schedule some set of tasks (1:1, N:M, a fixed # of threads, 1 thread), although it's not necessary all implemented in the shiny new runtime yet
[07:49:42] <glyc> what should I use for lighterweight error recovery, say I don't want the overhead of threads at all...
[07:50:16] <strcat> a sum type
[07:50:27] <glyc> strcat: a sum type?
[07:50:31] <olsonjeffery> strcat: actually right now scheds are 1:1 w/ os threads
[07:50:40] <olsonjeffery> oldrt had multiple strategies, but hey were never used
[07:51:01] *** Joins: Palmik (palmik@moz-CC484FDD.tmcz.cz)
[07:51:06] <olsonjeffery> tasks:sched = n:1 , sched:thread = 1:1
[07:51:31] <strcat> olsonjeffery: well, that makes sense, you essentially still have the ability to do 1:1 or any form of N:M
[07:52:07] <glyc> is there a seperate fiber or coroutine?
[07:52:18] *** Quits: carleastlund (cce@moz-C8071335.c3-0.smr-ubr1.sbo-smr.ma.cable.rcn.com) (Quit: carleastlund)
[07:52:19] <olsonjeffery> glyc: multiple tasks running on the same scheduler will never run simultaneously.. other schedulers can take work pending on other schedulers via the "work stealing" system (that is still pretty young), unless the task is going to do IO
[07:52:46] <olsonjeffery> in which, because of impl details of the scheduler eventloop (libuv), the task has to be "sent home" to the scheduler its IO handlers were created on
[07:53:12] <glyc> olsonjeffery: ok. I'd like a cooperative coroutine, without any scheduling at all. available?
[07:53:19] *** Joins: fabiand (fabiand@85E7B51A.3A27401E.16E13E53.IP)
[07:56:02] <glyc> let me ask from another angle--> is there any other way to suspend a call or unwind its stack, other than fail! ?
[07:56:19] * olsonjeffery shakes head.
[07:56:25] <glyc> mmm
[07:56:27] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[07:56:31] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[07:56:48] <glyc> no way to emulate try/catch then
[07:56:49] <olsonjeffery> a "coroutine" is a component of a task (plus its task-local stack/heap, iirc)
[07:57:25] <olsonjeffery> really, brson would be the one to quiz on this. he's the mastermind of newrt and would be able to provide more satisfactory answers, i think.
[07:58:00] <strcat> glyc: failure isn't for handling errors, it's for unrecoverable/unhandled ones
[07:58:17] <strcat> sum types and conditions are used to handle errors
[07:58:47] <glyc> olsonjeffery: ok, brson.  are coroutines:task  N:1 ?
[07:58:58] <strcat> enum Error { NotFound, Exploded } fn foo(...) -> Result<int, Error> { }
[07:59:25] <olsonjeffery> glyc: i think "coroutine" is a misnomer in this case.. its just a closure value
[07:59:34] <glyc> strcat: ah, got it.
[07:59:48] <olsonjeffery> glyc: really, based on your line of inquiry.. i get the feeling you're really interested in high-perf corner-cutting (not meaning that in a negative way)
[07:59:49] <strcat> where Result is 'enum Result<R, E> { Ok(R), Err(E) }' and provides some convenience methods
[08:00:45] <olsonjeffery> but you have to understand that we (as a community) as *really* interested in safety as a paramount concern. i think a lot of the project is structured in a "have your cake and eat it too" sort of way w/ the work the compiler does
[08:00:51] <olsonjeffery> obviously the runtime is a bit different.
[08:01:08] <glyc> olsonjeffery: yeah, I have this erlang model of many lightweight "processes" each running their own event-loop in my head. trying to see how/if that would map to rust
[08:01:13] *** Joins: SingingBoyo (brandon@4DF3381A.51F4D838.4F048BDC.IP)
[08:01:13] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[08:01:28] <olsonjeffery> glyc: we aspire to that.
[08:01:31] <glyc> strcat: nice. I'll look at Result more
[08:01:37] <olsonjeffery> but: rust isn't a vm, at runtime.
[08:01:41] *** Joins: pyrac (pyrac@3907364F.73C89388.AD05C589.IP)
[08:01:44] <olsonjeffery> also: we didn't roll our own event loop
[08:01:51] <strcat> glyc: http://static.rust-lang.org/doc/tutorial-conditions.html
[08:04:28] <glyc> olsonjeffery: that's good, I'm wondering if I just keep a list of closures, and dispatch to each in turn
[08:04:41] <glyc> strcat: thanks, reading that now
[08:05:35] *** Quits: SingingBoyo (brandon@4DF3381A.51F4D838.4F048BDC.IP) (Ping timeout)
[08:07:20] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[08:10:01] <dbaupp> mark_edward: pong
[08:10:33] <strcat> dbaupp: got the type name thing working
[08:10:37] <strcat> it took a minute, I'm serious
[08:10:42] <strcat>  6 files changed, 20 insertions(+), 5 deletions(-)
[08:10:46] <strcat> need to add a test
[08:12:34] <dbaupp> strcat: you mean in the tydesc?
[08:12:37] <strcat> yeah
[08:12:46] <dbaupp> awesome! even for enums?
[08:12:51] <strcat> hm?
[08:13:02] <strcat> well it will do whatever ty_to_str does
[08:13:08] <strcat> ppaux
[08:13:25] <dbaupp> Oh, I though there were problems with enums not print the path or something?
[08:13:35] <dbaupp> rusti: None::<int>
[08:13:37] *** Quits: sk (sk@61A494B3.BA40E8A.AAC02D62.IP) (Quit: Leaving)
[08:13:41] -rusti- timeout triggered!
[08:13:48] <strcat> no this is a separate thing
[08:13:54] <dbaupp> rusti: None::<int>
[08:13:57] -rusti- None
[08:14:04] <dbaupp> oh ok
[08:15:10] *** Quits: gazoombo (uid6629@moz-E77DEB21.irccloud.com) (Ping timeout)
[08:16:34] *** Joins: CarpNet (ac@moz-FD24B77.sohonet.co.uk)
[08:16:45] *** Joins: gazoombo (uid6629@moz-E77DEB21.irccloud.com)
[08:17:41] <strcat> I'm not sure if there's really a point in putting it in the tydesc yet
[08:17:42] <strcat> :s
[08:19:13] <dbaupp> you might as well, since you've got the code, right?
[08:23:40] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[08:26:29] *** Joins: diverse (Mibbit@moz-ED94B8D.oc.oc.cox.net)
[08:27:15] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[08:27:17] <strcat> rusti: 0 as *int
[08:27:20] -rusti- (0x0 as *())
[08:27:25] <strcat> should it print a fn as
[08:27:29] <strcat> fn(int, int) -> bool
[08:27:31] <strcat> or
[08:27:35] <strcat> (fn(int, int) -> bool)
[08:27:41] <strcat> lets say
[08:27:49] <strcat> (1, 2, f, 4)
[08:27:58] <strcat> (1, 2, fn(int, int) -> bool, 4)
[08:28:00] <strcat> or
[08:28:03] <strcat> (1, 2, (fn(int, int) -> bool), 4)
[08:28:12] <strcat> dbaupp: 
[08:28:55] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[08:29:15] <diverse> I don't understand this error: http://pastebin.com/S5qLCfKp
[08:30:11] <strcat> diverse: a generic type is assumed to have a destructor, and moves ownership
[08:30:17] *** Quits: _1126 (1126@moz-83D60E55.lileth.net) (Ping timeout)
[08:30:21] <strcat> only types without destructors are implicitly copyable
[08:30:30] <strcat> and you can't move out of a value you don't own
[08:31:46] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[08:32:00] *** Joins: [squiddy] (squiddy@moz-C1B7C6B.adsl.alicedsl.de)
[08:32:01] <dbaupp> strcat: i'd almost say `<fn(int, int) -> bool at 0xADDRESS>` or something like that
[08:32:15] <dbaupp> i.e. like python
[08:32:26] <diverse> strcat: do you got any suggestions to get around this?
[08:32:47] <dbaupp> diverse: use `.pop()`
[08:32:49] *** Joins: tjc (tjc@moz-6EB4E533.dsl.tsoft.com)
[08:32:49] *** ChanServ sets mode: +o tjc
[08:32:58] <dbaupp> self.tokens.pop()
[08:33:51] *** Quits: tjc (tjc@moz-6EB4E533.dsl.tsoft.com) (Quit: zzzzzzzzzz)
[08:34:44] <diverse> dbaupp: are you saying there is a builtin pop method for vectors?
[08:34:50] <strcat> yes they have push and pop
[08:34:56] <strcat> ~[T] is a dynamically sized array
[08:35:03] <diverse> cool
[08:35:03] <strcat> it implements O(1) append/pop
[08:35:30] *** Joins: _1126 (1126@moz-83D60E55.lileth.net)
[08:36:03] <strcat> there are also fixed-size vectors, but that's not what ~[T] is
[08:36:26] <strcat> dbaupp: meh I don't really want to print an address :s
[08:36:36] <strcat> we don't print them for ~T and @T
[08:36:46] <strcat> addresses of functions aren't significant since we merge them
[08:37:42] <diverse> yeah, earlier I wanted to figure out a way to make n fixed sized array, but was told to use ~[T] instead
[08:39:28] <strcat> dbaupp: it's not going to print generics properly ;s
[08:39:46] <strcat> well
[08:39:51] <strcat> how would it print them anyway
[08:40:45] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[08:46:34] *** Joins: miloshadzic (miloshadzi@moz-4197F996.dynamic.isp.telekom.rs)
[08:48:02] <strcat> dbaupp: you know... it should really just be passed a name of the fn
[08:48:03] <strcat> :s
[08:49:17] *** Joins: SingingBoyo (brandon@4DF3381A.51F4D838.4F048BDC.IP)
[08:50:38] <strcat> dbaupp: https://github.com/mozilla/rust/pull/8947 r?
[08:51:46] <strcat> (my comment in the PR itself is about the 2nd commit - type name in the tydesc is useful for other reasons)
[08:52:54] <strcat> dbaupp: actually don't r+ it yet
[08:52:56] <strcat> need to think
[08:54:21] <strcat> dbaupp: ok nvm it's fine ;p
[08:55:14] <diverse> grr... http://pastebin.com/6xbnHM8J
[08:56:44] *** Quits: SingingBoyo (brandon@4DF3381A.51F4D838.4F048BDC.IP) (Ping timeout)
[08:57:03] <strcat> diverse: you're ignoring the return value of pop with ;
[08:58:18] <diverse> strcat: thanks, I'm so used to ending stuff with ;
[09:01:03] *** Joins: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk)
[09:01:39] <glyc> Does Rust have any RPC at the moment?
[09:01:58] <glyc> (remote proceedure call or network interfaces)
[09:02:33] <diverse> strcat: if I were to impl<T: Clone> would that make accept only those types that implicitly copyable?
[09:02:51] <strcat> no, Clone is unrelated to whether types are implicitly copyable
[09:03:25] <strcat> ~[T] vectors act as a dynamically sized stack and work for non-copyable types
[09:04:36] <strcat> rusti: use std::util::NonCopyable; let mut xs = ~[]; xs.push(NonCopyable::new()); xs
[09:04:38] <dbaupp> glyc: it does have networking (i.e. ip/tcp/udp interfaces) in std::rt::io::net, but there's very few libraries layered on top of that
[09:04:42] -rusti- ~[std::util::NonCopyable]
[09:04:42] -rusti- timeout triggered!
[09:04:46] <strcat> rusti: use std::util::NonCopyable; let mut xs = ~[]; xs.push(NonCopyable::new()); xs
[09:04:51] -rusti- ~[std::util::NonCopyable]
[09:04:52] -rusti- timeout triggered!
[09:05:02] <strcat> huh.
[09:05:09] <dbaupp> strcat: re functions and addresses, it's just because there's no other way to distinuish them
[09:05:20] <strcat> dbaupp: the address doesn't distinguish them
[09:05:24] <strcat> they can be merged
[09:05:43] <dbaupp> strcat: true
[09:05:56] <strcat> rusti: use std::util::NonCopyable; let mut xs = ~[]; xs.push(NonCopyable::new()); xs.pop()
[09:05:57] -rusti- std::util::NonCopyable
[09:06:03] * strcat isn't sure why it was timing out
[09:06:08] <strcat> rusti: use std::util::NonCopyable; let mut xs = ~[]; xs.push(NonCopyable::new()); xs
[09:06:13] -rusti- ~[std::util::NonCopyable]
[09:06:13] -rusti- timeout triggered!
[09:06:14] <strcat> seems like a bug
[09:06:29] <strcat> rusti: use std::util::NonCopyable; let mut xs = ~[]; xs.push(NonCopyable::new()); xs.len()
[09:06:34] -rusti- timeout triggered!
[09:06:37] <strcat> wat?
[09:06:41] <glyc> dbaupp: thanks, I'll check out std::rt::io::net
[09:06:45] <strcat> rusti: let mut xs = [1, 2, 3]; xs.len()
[09:06:46] -rusti- <anon>:5:17: 5:19 warning: variable does not need to be mutable [-W unused-mut (default)]
[09:06:46] -rusti- <anon>:5          let mut xs = [1, 2, 3]; xs.len()
[09:06:46] -rusti-                           ^~
[09:06:46] -rusti- 3u
[09:06:51] <strcat> rusti: let mut xs = [1, 2, 3]; xs.push(4); xs.len()
[09:06:52] -rusti- <anon>:5:33: 5:44 error: type `[<VI2>, .. 3]` does not implement any method in scope named `push`
[09:06:52] -rusti- <anon>:5          let mut xs = [1, 2, 3]; xs.push(4); xs.len()
[09:06:52] -rusti-                                           ^~~~~~~~~~~
[09:06:53] -rusti- error: aborting due to previous error
[09:06:53] -rusti- application terminated with error code 101
[09:06:59] <strcat> rusti: let mut xs = ~[1, 2, 3]; xs.push(4); xs.len()
[09:07:00] -rusti- 4u
[09:07:05] <strcat> it's just not happy about NonCopyable
[09:07:23] <strcat> rusti: struct Foo; let xs = ~[Foo]; xs
[09:07:23] -rusti- ~[main::Foo]
[09:07:27] <sammykim> Hm.. can anyone explain what those files are different between astconv.rs and resolve.rs?
[09:07:45] <strcat> rusti: mod bar { pub struct Foo; } let xs = ~[bar::Foo]; xs
[09:07:46] -rusti- ~[main::bar::Foo]
[09:08:01] <strcat> rusti: mod bar { pub struct Foo; impl Drop for Foo { fn drop(&self) {} } } let xs = ~[bar::Foo]; xs
[09:08:02] -rusti- ~[main::bar::Foo]
[09:08:12] <strcat> rusti: mod bar { #[unsafe_no_drop_flag] pub struct Foo; impl Drop for Foo { fn drop(&self) {} } } let xs = ~[bar::Foo]; xs
[09:08:17] -rusti- ~[main::bar::Foo]
[09:08:18] -rusti- timeout triggered!
[09:09:08] <strcat> rusti: #[unsafe_no_drop_flag] pub struct Foo; impl Drop for Foo { fn drop(&self) {} } let xs = ~[Foo]; xs
[09:09:14] -rusti- ~[main::Foo]
[09:09:14] -rusti- timeout triggered!
[09:09:21] <strcat> rusti: #[unsafe_no_drop_flag] pub struct Foo; impl Drop for Foo { fn drop(&self) {} } Foo
[09:09:22] -rusti- main::Foo
[09:09:27] <strcat> rusti: #[unsafe_no_drop_flag] pub struct Foo; impl Drop for Foo { fn drop(&self) {} } [Foo]
[09:09:32] -rusti- [main::Foo]
[09:09:32] -rusti- timeout triggered!
[09:09:39] <dbaupp> strcat: do closures print any differently to extern fns?
[09:09:44] <strcat> dbaupp: no
[09:09:48] <dbaupp> ok
[09:10:27] <strcat> dbaupp: it doesn't print bounds or anything
[09:10:37] <strcat> that's why I said it's probably better to just pass the tydesc to enter_fn
[09:10:42] <strcat> fn_enter
[09:10:58] <strcat> anyway that visit glue stuff is all a hack
[09:11:00] <strcat> existing only for repr
[09:11:07] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[09:11:07] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1439060e2 to 1458decdd: 02http://git.io/N3iJvQ
[09:11:07] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[09:11:08] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[09:11:08] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/cDxq3w
[09:11:08] <ghrust> 13rust/06auto 1409ad0cd 15Daniel Micay: add type name to the tydesc...
[09:11:08] <ghrust> 13rust/06auto 14a6a993e 15Daniel Micay: repr: add very basic support for functions...
[09:11:08] <ghrust> 13rust/06auto 14ccd68d4 15bors: auto merge of #8947 : thestinger/rust/name, r=huonw...
[09:11:10] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[09:12:12] <strcat> dbaupp: I'm not really sure this is the right way to do it
[09:12:24] <strcat> the alternative is adding more name: &str params to the visit methods
[09:12:34] <strcat> hrm
[09:12:55] <dbaupp> having the name in the tydesc seems like it's the correct solution?
[09:13:10] *** Quits: Uther (Instantbir@moz-1B244B05.hfc.dyn.abo.bbox.fr) (Ping timeout)
[09:13:20] <dbaupp> i.e. the name is metadata about the type, and so fits in the tydesc
[09:13:46] <strcat> but the name is only used by the visit glue
[09:13:55] <strcat> and the visit glue is already generated per-type
[09:14:14] <dbaupp> presumably that's the part that is wrong, then.
[09:14:20] <strcat> what do you mean?
[09:14:27] <strcat> the visit glue has to be generated per type
[09:14:49] <dbaupp> does it? only a rust level representation of the type has to be generated
[09:14:59] <strcat> don't know what you mean
[09:15:03] <strcat> lets say you have
[09:15:10] <strcat> struct Foo(int, Bar, Baz)
[09:15:16] <strcat> it has to generate visit glue to visit that type
[09:15:21] <strcat> how else would it do it?
[09:15:37] <strcat> there's an infinite number of possibilities for how types can be laid out
[09:15:41] <strcat> they can be recursive
[09:15:46] <strcat> they can have N fields
[09:15:50] <strcat> N variants
[09:15:58] <dbaupp> That would be `Struct(&'static Int, &'static Struct(Bar), &'static Struct(Baz))`
[09:16:00] <diverse> visit glue?
[09:16:12] <dbaupp> all of them stored in static data in the binary.
[09:16:23] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Client exited)
[09:16:28] <dbaupp> hm
[09:16:29] <strcat> dbaupp: so all rust programs will include a parser?
[09:16:36] <dbaupp> &'static [...] on the inside
[09:16:38] <dbaupp> a parser?
[09:16:43] <dbaupp> no
[09:16:48] <dbaupp> that's not a string
[09:17:49] <dbaupp> that's a rust enum, i.e. `enum TyDesc { Int(size, signed), Float(size), ..., Struct(&'static [&'static TyDesc]), Enum(&'static [Variants]) }`
[09:17:55] <strcat> you want the visit glue to dynamically read in runtime representations of types and walk them
[09:18:04] <strcat> it's not realistic
[09:18:09] *** Quits: Siyo (Siyo@A89938F4.87DAA49F.F113998C.IP) (Ping timeout)
[09:18:24] *** Quits: Seldaek (seld@moz-5DEA7688.ch) (Ping timeout)
[09:18:27] <dbaupp> what do we use the ty visitor for other than %? ?
[09:18:29] <strcat> you are going to end up with half of trans in every program
[09:18:31] *** Quits: k4nar (quassel@moz-F5EFF779.kimsufi.com) (Ping timeout)
[09:18:32] <strcat> dbaupp: nothing
[09:18:46] *** Quits: darkf (darkf@moz-F9058B8A.net) (Ping timeout)
[09:18:49] *** Quits: jez0990 (quassel@moz-3BA8545E.kimsufi.com) (Ping timeout)
[09:18:52] *** Quits: yosemite (sam@moz-8CEAB1B0.dasbistro.com) (Ping timeout)
[09:18:53] *** Quits: diverse (Mibbit@moz-ED94B8D.oc.oc.cox.net) (Quit: http://www.mibbit.com ajax IRC Client)
[09:18:55] *** Quits: Tad (Tom@moz-2036EE54.kimsufi.com) (Ping timeout)
[09:18:59] <dbaupp> I don't understand why trans will end up there?
[09:18:59] *** Quits: glandium (glandium@moz-A09032B1.kimsufi.com) (Ping timeout)
[09:19:00] *** Quits: bbouvier (bnjbouv@moz-63AFAFBF.gagahome.fr) (Ping timeout)
[09:19:12] <strcat> dbaupp: how is it going to know how those fields are aligned?
[09:19:12] *** Quits: kaeso (kaeso@moz-F21FF626.unstable.it) (Ping timeout)
[09:19:16] <strcat> it needs to know the memory representation
[09:19:19] *** Quits: toddaaro (toddaaro@moz-98F46974.us) (Ping timeout)
[09:19:23] <dbaupp> ah
[09:19:27] <dbaupp> all these little details
[09:19:28] <strcat> so you are going to need to make it target aware in a way that even librustc isn't
[09:19:31] *** Quits: jack (jack@moz-DF5A9AA3.members.linode.com) (Ping timeout)
[09:19:33] <strcat> it relies on llvm a lot
[09:19:36] <dbaupp> yeah
[09:19:41] *** Quits: mythmon (mythmon@moz-AD308AD7.members.linode.com) (Ping timeout)
[09:19:41] *** Quits: toshok (toshok@moz-67C55A1F.com) (Ping timeout)
[09:19:42] <dbaupp> I agree
[09:19:45] <strcat> and this is code in *every rust program*
[09:19:49] *** Quits: snerd (motk@moz-E535583C.nonstopcrunchy.net) (Ping timeout)
[09:19:55] <dbaupp> yup
[09:20:13] <strcat> that's why I think the name thing is the wrong approach
[09:20:18] <strcat> it's only used inside the visit glue
[09:20:22] <strcat> there's already a field for the visit glue
[09:20:33] <strcat> but anyway
[09:20:40] <strcat> it would be nicer to throw out visit glue and the reflect stuff as a whole
[09:20:46] <strcat> and just generate repr glue
[09:21:11] <dbaupp> that'd be pretty annoying though; writing the "AST" required in trans?
[09:21:41] <strcat> it can't be more annoying than what it is now
[09:22:01] <dbaupp> your next project?
[09:22:08] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[09:22:19] <strcat> well I just think I've taken the wrong approach here...
[09:22:47] <dbaupp> eh, it needs to get redone anyway.
[09:24:03] *** Joins: Seldaek (seld@moz-5DEA7688.ch)
[09:24:08] *** Joins: jez0990 (quassel@moz-3BA8545E.kimsufi.com)
[09:24:12] *** Joins: k4nar (quassel@moz-F5EFF779.kimsufi.com)
[09:24:14] *** Joins: snerd (motk@moz-E535583C.nonstopcrunchy.net)
[09:24:17] *** Joins: toshok (toshok@moz-67C55A1F.com)
[09:24:25] *** Joins: darkf (darkf@moz-F9058B8A.net)
[09:24:36] *** Joins: glandium (glandium@moz-A09032B1.kimsufi.com)
[09:24:57] *** Joins: Siyo (Siyo@A89938F4.87DAA49F.F113998C.IP)
[09:25:00] *** Joins: mythmon (mythmon@moz-AD308AD7.members.linode.com)
[09:25:01] *** Joins: kaeso (kaeso@moz-F21FF626.unstable.it)
[09:25:02] *** Joins: Tad (Tom@moz-C8B2B6F7.navalrp.co.uk)
[09:25:37] *** Quits: [squiddy] (squiddy@moz-C1B7C6B.adsl.alicedsl.de) (Input/output error)
[09:26:16] *** Joins: jack (jack@moz-DF5A9AA3.members.linode.com)
[09:26:16] *** ChanServ sets mode: +o jack
[09:27:17] *** Quits: pyrac (pyrac@3907364F.73C89388.AD05C589.IP) (Quit: pyrac)
[09:27:45] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[09:28:26] *** Joins: bbouvier (bnjbouv@moz-63AFAFBF.gagahome.fr)
[09:29:26] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[09:29:30] <strcat> dbaupp: I don't really feel like touching repr or visit glue anymore ;p
[09:29:39] * strcat is starting to think it doesn't make sense to have it
[09:29:52] *** Joins: toddaaro (toddaaro@moz-98F46974.us)
[09:30:02] <strcat> seems like we could just use debug info somehow
[09:30:25] *** Joins: yosemite (sam@moz-8CEAB1B0.dasbistro.com)
[09:30:37] <dbaupp> yeah, they cover very similar ground
[09:30:40] <dbaupp> acrichto: ping
[09:33:01] <dbaupp> strcat: in any case, it's much much nicer with your recent changes :)
[09:33:04] *** Joins: squiddy (squiddy@moz-C1B7C6B.adsl.alicedsl.de)
[09:33:47] <strcat> dbaupp: https://github.com/mozilla/rust/issues/8948
[09:36:13] *** Joins: upstream (TheDust@moz-8C2076C2.upc-d.chello.nl)
[09:36:50] *** Joins: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net)
[09:36:51] <dbaupp> strcat: cool
[09:37:01] * strcat really isn't sure if it makes sense
[09:37:24] <dbaupp> (I tagged it as A-an-interesting-project too)
[09:37:48] <strcat> dbaupp: when you mentioned serializing the representations like that... it just became clear that it is identical to debug info
[09:37:53] * strcat shrugs
[09:38:16] <strcat> but the debug info might be too lossy
[09:38:30] *** Quits: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net) (Ping timeout)
[09:38:57] <dbaupp> heh
[09:39:09] * dbaupp 's silliness isn't entirely useless :)
[09:39:32] <dbaupp> strcat: do you reckon https://github.com/mozilla/rust/issues/6050 can be closed?
[09:41:09] <strcat> closed
[09:41:23] <strcat> we could add a separate set of tests but it seems kind of pointless
[09:42:09] <dbaupp> yeah
[09:42:42] *** Quits: fhahn (fhahn@moz-7924DB5C.vie.surfer.at) (Ping timeout)
[09:45:15] *** Joins: bytewise (bytewise@moz-4A801D04.unitymediagroup.de)
[09:46:42] *** Quits: miloshadzic (miloshadzi@moz-4197F996.dynamic.isp.telekom.rs) (Ping timeout)
[09:48:03] * strcat tries to think of another visit glue use case...
[09:48:17] *** Quits: robn (robn@moz-76B0302C.static.internode.on.net) (Quit: Coyote finally caught me)
[09:48:21] *** Joins: robn (robn@moz-76B0302C.static.internode.on.net)
[09:48:40] *** Quits: Houm (Houm@moz-25669AA8.fbx.proxad.net) (Ping timeout)
[09:49:39] <dbaupp> Dynamic?
[09:49:47] *** Joins: sk (sk@76BFB31C.71F9CB99.78DD174B.IP)
[09:49:54] <strcat> visit glue just walks the type though
[09:50:00] <strcat> you don't need that
[09:50:10] *** Joins: fhahn (fhahn@moz-7924DB5C.vie.surfer.at)
[09:50:10] <dbaupp> (ala Haskell's Dynamic and/or downcasting trait objects)
[09:50:13] <dbaupp> oh ok
[09:51:56] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[09:53:44] <dbaupp> load average: 16.51, 7.71, 3.68
[09:53:58] <dbaupp> compiletest how I love thee
[09:54:14] *** Joins: mindcat (mindcat@51E8D533.C6D6E0F5.857BDFA9.IP)
[09:54:15] *** Joins: ski (md9slj@moz-862B1C66.studat.chalmers.se)
[09:54:40] *** Joins: nmatsakis (nmatsakis@moz-DB4A9C19.scl3.mozilla.com)
[09:54:40] *** ChanServ sets mode: +ao nmatsakis nmatsakis
[09:54:47] *** Quits: jaen (jaen@FB01674D.56B727FE.4B52F012.IP) (Ping timeout)
[09:56:05] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[09:56:05] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14ccd68d4 to 1458decdd: 02http://git.io/N3iJvQ
[09:56:05] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[09:56:06] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[09:56:06] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/xrFFXQ
[09:56:06] <ghrust> 13rust/06auto 144fa28a2 15Felix S. Klock II: Allow _ param name in trait default method for #8468.
[09:56:06] <ghrust> 13rust/06auto 14ba1f44d 15Felix S. Klock II: Regression test for #8468.
[09:56:06] <ghrust> 13rust/06auto 141b3cd96 15Felix S. Klock II: Incorporate review feedback.  Fix #8468.
[09:56:08] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[09:56:21] <strcat> dbaupp: Go's reflect module is definitely more useful, but that's quite possibly a bad thing
[09:56:40] <mindcat> I don't know why, then I disconnect I got something wrong. log is here: http://paste.ubuntu.com/6058346/
[09:57:17] <dbaupp> strcat: they have ducktyping though, so it's kinda has to be built into the language anyway, right?
[09:58:03] <strcat> dbaupp: it is not really duck typing
[09:58:06] *** Quits: sigma (sigma@moz-B8E78D5.range86-136.btcentralplus.com) (Quit: Leaving.)
[09:58:27] <strcat> go's interfaces are similar to rust's trait objects, except it just uses structural typing
[09:58:32] *** Joins: sigma (sigma@moz-B8E78D5.range86-136.btcentralplus.com)
[09:58:59] <strcat> if a type implements methods with the same structure (name, types), it implements that interface
[09:59:11] <dbaupp> I mean, you can query interfaces (at runtime?), so it has to has some measure of reflection that actually works
[09:59:31] <strcat> well that's not really part of them being an interface
[09:59:33] <dbaupp> mindcat: it looks a lot like you're recieving bytes that aren't ascii
[09:59:34] <strcat> that's separate
[09:59:51] <strcat> go has reflection and they use it a lot to work around limitations we don't have
[09:59:59] <strcat> but their interfaces don't *need* reflection
[10:00:02] <dbaupp> strcat: ok, I've never touched go, so I'll stop trying to sound like I know what I'm talking about. :)
[10:00:27] <mindcat>  dbaupp: well, I think found I want.
[10:00:28] <strcat> dbaupp: well, think about rust without generics
[10:00:30] <strcat> just trait objects
[10:00:38] <strcat> and methods are associated with types, never traits
[10:00:46] <strcat> traits are implicitly impl'ed if the signatures of the methods match
[10:00:52] <strcat> that's go's interface system
[10:01:14] <dbaupp> hm, a little peculiar
[10:01:15] <strcat> + then they work around limitations of that system by (ab)using reflection
[10:01:32] <dbaupp> (I guess it's no worse than python/javascript/anything dynamic)
[10:02:15] <strcat> that style of reflection is really ugly
[10:02:36] <strcat> it means you have no idea what a function actually does from the signature, if it takes a trait object or is generic
[10:02:45] <strcat> repr already exposes this
[10:02:52] <strcat> fn foo<T>(x: T) { ... }
[10:03:07] <strcat> without repr, you only have a size + alignment
[10:03:20] <strcat> with repr, you have the whole structure of the type - with no bounds
[10:04:05] <dbaupp> yeah, break parametric polymorphism
[10:04:08] <dbaupp> *breaks
[10:04:15] <strcat> and privacy
[10:04:43] <dbaupp> strcat: feel like looking at https://github.com/mozilla/rust/pull/8932 ?
[10:05:10] * dbaupp could probably just r it himself since it's adding some tests
[10:05:33] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[10:05:56] * strcat is going to go to sleep and will just fret about the evils of reflection in his sleep
[10:06:00] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.1)
[10:09:36] *** Joins: jaen (jaen@moz-882DC6A0.neoplus.adsl.tpnet.pl)
[10:14:18] *** Joins: Earnestly (earnest@moz-F387F877.dyn.plus.net)
[10:17:48] *** Joins: z0w0 (zack@moz-30F36A45.qld.bigpond.net.au)
[10:20:00] *** Quits: fabiand (fabiand@85E7B51A.3A27401E.16E13E53.IP) (Quit: Verlassend)
[10:21:34] *** Quits: StarLight (StarLight@moz-41A99168.dynamic.avangarddsl.ru) (Ping timeout)
[10:25:52] *** Joins: StarLight (StarLight@moz-BFE8DFC0.dynamic.avangarddsl.ru)
[10:27:35] *** Joins: jdsanders (Adium@moz-84CB7548.hlrn.qwest.net)
[10:28:06] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[10:29:15] *** Quits: jdsanders (Adium@moz-84CB7548.hlrn.qwest.net) (Ping timeout)
[10:29:46] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[10:30:30] *** Joins: miloshadzic (miloshadzi@F8195CC5.425C93D4.449B8A48.IP)
[10:31:38] *** Quits: bytewise (bytewise@moz-4A801D04.unitymediagroup.de) (Connection reset by peer)
[10:32:33] *** Joins: fyolnish_ (fyolnish@moz-BE2BAE5B.miinet.jp)
[10:33:09] *** Quits: fyolnish (fyolnish@moz-BE2BAE5B.miinet.jp) (Ping timeout)
[10:34:13] *** Quits: fyolnish_ (fyolnish@moz-BE2BAE5B.miinet.jp) (Ping timeout)
[10:38:39] *** Quits: Infiltrator (Infiltrato@4669028E.25A9890C.4B4F1E7A.IP) (Ping timeout)
[10:39:21] *** Joins: Infiltrator (Infiltrato@4669028E.25A9890C.4B4F1E7A.IP)
[10:40:19] *** Joins: five (five@911E195F.4210A027.4DD432BA.IP)
[10:41:09] *** Quits: five (five@911E195F.4210A027.4DD432BA.IP) (Connection reset by peer)
[10:42:43] *** Joins: nmatsaki1 (nmatsakis@moz-DB4A9C19.scl3.mozilla.com)
[10:42:43] *** Quits: nmatsaki1 (nmatsakis@moz-DB4A9C19.scl3.mozilla.com) (Quit: nmatsaki1)
[10:43:16] *** Joins: bytewise (bytewise@moz-4A801D04.unitymediagroup.de)
[10:47:28] *** Joins: six600110 (six600110@moz-2FA48202.neo.res.rr.com)
[10:49:51] *** Quits: six600110 (six600110@moz-2FA48202.neo.res.rr.com) (Client exited)
[10:52:23] *** Joins: six600110 (six600110@moz-2FA48202.neo.res.rr.com)
[10:53:41] *** Quits: six600110 (six600110@moz-2FA48202.neo.res.rr.com) (Client exited)
[10:54:42] *** Joins: Houm (Houm@moz-25669AA8.fbx.proxad.net)
[10:54:43] *** Joins: six600110 (six600110@moz-2FA48202.neo.res.rr.com)
[10:58:55] *** Joins: fyolnish (fyolnish@moz-1C9C8043.uqwimax.jp)
[11:01:09] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[11:01:09] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/xrFFXQ
[11:01:09] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[11:01:47] <dbaupp> kimundi: ping
[11:04:34] *** Quits: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP) (Ping timeout)
[11:04:37] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[11:06:04] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[11:06:04] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/8H0wMA
[11:06:04] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[11:06:05] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[11:06:05] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/VTIxAg
[11:06:05] <ghrust> 13rust/06auto 14364beaa 15Huon Wilson: Un-xfail/move/delete some tests.
[11:06:05] <ghrust> 13rust/06auto 1412099ce 15Huon Wilson: Tests for fixed issues....
[11:06:05] <ghrust> 13rust/06auto 14b0d069b 15bors: auto merge of #8932 : huonw/rust/closed-issues, r=thestinger
[11:06:06] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[11:06:27] <Palmik> Hi. Lets say I have root crate named foo and I have foo::bar foo::bar, when I (inside foo::bar) do 'use super::baz', it works, but 'use foo::baz' does not (since use paths are relative to the current crate).
[11:07:06] <Palmik> I think it might be nice to have something like 'root::foo::baz' where 'root' would mean the top-most crate root.
[11:08:06] <dbaupp> Palmik: `::foo::baz` works
[11:08:27] <dbaupp> (they're called global paths, in rust terminology, btw.)
[11:08:44] <dbaupp> hm, maybe I misunderstand
[11:09:24] <Palmik> I get 'expected ident, found `::`'
[11:09:37] <dbaupp> is your crate called foo, and it has submodules bar and baz (i.e. `#[link(name="foo")] mod bar; mod baz;`?)
[11:10:21] <Palmik> I actually named the crate differently, but I
[11:10:26] <Palmik> still get the parser error
[11:10:53] <dbaupp> I think you may be using "crate" more generally than conventional: the crate is the whole collection of modules that get compiled when you call rustc on one of them
[11:11:05] <dbaupp> i.e. it's the compiled  library /binary
[11:11:21] <dbaupp> each `mod` statement introduces a new module, not a new crate
[11:12:05] <dbaupp> so `use foo::bar` is actually exactly what you want: it is relative to the file on which you call rustc
[11:12:09] <dbaupp> (that is, the top of the crate)
[11:12:36] <Palmik> Hmm, for some reason it does not work for me. Let me see if I can produce minimal example.
[11:13:02] <dbaupp> (the ::foo::bar syntax is just when you're writing normal code and wish to have the same semantics as `use` does by default, so irrelevant to this context; sorry for the confusion.)
[11:13:43] *** Quits: sebcrozet (sebcrozet@moz-6DA639AF.w80-13.abo.wanadoo.fr) (Quit: Gone)
[11:16:23] <kimundi> dbaupp: pong
[11:16:44] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[11:16:56] <dbaupp> kimundi: are you planning to continue https://github.com/mozilla/rust/pull/8939 ?
[11:17:17] <kimundi> define continue
[11:17:22] <dbaupp> (if so, is it going to be ready soon? might as well land as much as possible before the americans start waking up from their day off.)
[11:17:34] *** flaper87 is now known as flaper87|afk
[11:17:37] <dbaupp> as in, there's still some syntax::ast type that are old
[11:17:43] <Palmik> https://gist.github.com/Palmik/572ac754cadb2c45885e replace '_' in file names by '/'
[11:18:00] <kimundi> I'm probably going to open more PR along those lines, but I'm not planning on changing something to this one any more
[11:18:24] <dbaupp> kimundi: well, if you were to add more commit to that PR I'd still r+ it :P
[11:18:41] <dbaupp> Palmik: `use bar::BazType`
[11:19:24] <dbaupp> Palmik: internally crates don't know what their name is, it's all just based of the file you run rustc on
[11:19:34] <Palmik> Yes, well, in this case that would work, but in my actual case, bar and baz are further nested, so I have to use high amount of 'super::'s
[11:19:37] <kimundi> dbaupp: I'd r+ it now. Probably not going to add more changes soon.
[11:19:52] <dbaupp> kimundi: don't tell me what to do :P
[11:19:55] * dbaupp r+'s
[11:19:59] <kimundi> ;)
[11:20:10] *** Quits: Axord (xord@moz-1B228827.lsanca.dsl-w.verizon.net) (Quit: I'm sure it's perfectly safe)
[11:20:18] <dbaupp> Palmik: no way around it
[11:20:54] <dbaupp> Palmik: I don't see how your original question would solve this?
[11:21:43] <Palmik> Questions usually do not slve anything. :P I just suggested that we could have something like 'root::...' or '::...' that would refer to thecrate root.
[11:22:02] <kimundi> Palmik: No need for that, that'S the default
[11:22:12] *** Joins: pyrac (pyrac@3907364F.73C89388.AD05C589.IP)
[11:22:22] <kimundi> use foo::bar; will allways look at foo in the crate root
[11:22:33] <Palmik> So, I probably 
[11:22:36] <kimundi> In an expression, ::foo::bar will allways look in the crate root
[11:22:53] <dbaupp> kimundi: in this case the crate is called `foo`, so that's probably a confusing example
[11:23:02] <kimundi> yeah
[11:23:16] <kimundi> the name of the crate is irrelvant though
[11:23:29] <dbaupp> correct, that's why it's confusing
[11:23:35] <kimundi> it's all relative to the _body_ of the crate root
[11:23:42] <Palmik> kimundi: well, I either do not know what is meant by crate root or I did something else wrong, since the posted example does not work.
[11:24:42] <kimundi> Palmik: Could you repost the example?
[11:24:59] <dbaupp> Palmik: foo.rs is the crate root
[11:25:13] <dbaupp> Palmik: and foo/bar.rs should contain `use baz::BazType`
[11:25:17] <Palmik> https://gist.github.com/Palmik/572ac754cadb2c45885e
[11:25:50] <dbaupp> that will make rustc go up to foo.rs (i.e. the top of the crate) and look for the module called `baz`
[11:25:52] <Palmik> Yes... I figured that when I actually want is to have 'mod foo { ... }' in the foo.rs
[11:25:59] <sigma> Hmm, since rust doesn't yet have a yield keyword I assume some sort of trampoline is going to be the tidy way to implement a python like generator?
[11:26:06] <Palmik> Probably.
[11:26:47] <dbaupp> Palmik: that'd be kinda weird (having mod foo inside #[link(name="foo")]), it'd result in people importing it like `extern mod foo; use foo::foo::bar;`
[11:26:48] <kimundi> Palmik: mod foo {} would result in one child module of your crate containing all the other stuff
[11:27:36] <kimundi> Palmik: why are your rerouting the paths of those submodule to the folder 'foo' ?
[11:27:58] *** flaper87|afk is now known as flaper87
[11:28:32] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[11:29:49] <kimundi> The way rust looks for source file per default measn that you'd either have foo.rs, bar.rs and baz.rs right next to each other, or you have foor.rs, bar/mod.rs and baz/mod.rs
[11:30:12] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[11:30:15] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[11:30:19] <Palmik> kimundi: because that is where the files are. I am just used to the Haskell way of things where the module dotted name presents the path.
[11:30:24] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[11:30:56] <Palmik> Here foo.rs is 'foo::' (for those that extern mod it), foo/bar.rs is foo::bar, etc.
[11:31:27] <kimundi> If you want to group the files of a crate together, better just put all the source in it's own folder, rather than only everything below the source file of your crate root
[11:32:00] <kimundi> Sure, it's not how the convention works per default though :)
[11:32:28] <Palmik> I have rust-foo/[src/]/...
[11:33:31] <Seldaek> is there a rust equivalent to http://golang.org/pkg/sort/#Sort i.e. a sort that accepts something implementing less/swap so you can sort a few vecs together (i.e. sort one based on another by swapping both at once)?
[11:33:33] <sigma> reading down https://github.com/mozilla/rust/issues/7746 it seems I want to do the most painful thing possible, yay. Does anyone know of any code where a recursive traversal has been implemented as an external iterator?
[11:34:03] <kimundi> I think you want something like: rust-foo[/src]/lib.rs, rust-foo[/src]/bar.rs, rust-foo[/src]/baz.rs
[11:34:27] <kimundi> Or: rust-foo[/src]/lib.rs, rust-foo[/src]/bar/mod.rs, rust-foo[/src]/baz/mod.rs
[11:34:50] <kimundi> with lib.rs containing the body of your crate root
[11:34:53] <dbaupp> sigma: extra::treemap, iirc
[11:35:00] <Palmik> OK, I will probably go for the second approach (since using #[path will probably be frowned upon).
[11:35:05] <sigma> dbaupp: ty
[11:35:08] *** Quits: Ms2ger (Ms2ger@B7B2FF50.C60A97A6.F9FB0584.IP) (Ping timeout)
[11:35:39] <dbaupp> sigma: in fact, I think all the trees in std and extra have one
[11:35:55] *** Joins: Axord (xord@moz-1B228827.lsanca.dsl-w.verizon.net)
[11:36:06] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[11:36:07] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14b0d069b to 148183c74: 02http://git.io/N3iJvQ
[11:36:07] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[11:36:09] <sigma> huh, seld.be is top google result for rust manual searchs :)
[11:36:23] <dbaupp> Seldaek: you're winning ;D
[11:36:32] <Seldaek> yeah we gotta finish this stuff and get it on the real site :p
[11:36:57] <Seldaek> then I'll HTTP 302 all pages 
[11:37:15] <Seldaek> eh 301*, whatever
[11:37:24] <sigma> why oh why did I choose an xml parser as my learning rust project
[11:37:54] *** Joins: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[11:39:06] <dbaupp> sigma: because you're appropriately mad?
[11:40:18] *** Joins: fabiand (fabiand@moz-E2579CED.adsl.alicedsl.de)
[11:40:26] <sigma> I've got 4 reference implementations in 5 languages open in tabs, None of them seem to have implemented all the good ideas the other ones have had
[11:40:29] <dbaupp> Seldaek: can't wait, and it'll have a fancy new search too :D
[11:40:48] <dbaupp> sigma: so the rust one will be the best
[11:40:58] *** flaper87 is now known as flaper87|afk
[11:41:07] *** Joins: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net)
[11:41:07] <sigma> nah, the rust one will be something I wrote as a learning project :P
[11:41:20] <sigma> the 3rd or 4th rust one might be best :)
[11:46:48] *** Quits: z0w0 (zack@moz-30F36A45.qld.bigpond.net.au) (Ping timeout)
[11:51:33] <bjz_> sigma: and xml parser would be great :)
[11:52:01] <bjz_> sigma: I currently use this for my gl loader generator: https://github.com/bjz/sax-rs
[11:52:45] <bjz_> sigma: leaves a little to be desired
[11:53:58] *** Joins: Ms2ger (Ms2ger@B7B2FF50.C60A97A6.F9FB0584.IP)
[11:55:53] *** Joins: five (five@1AAB1A1C.EC1FF11B.12750D2E.IP)
[11:55:57] *** Joins: ChemicalHarm (Mibbit@moz-A9F37238.hsd1.md.comcast.net)
[11:56:10] *** Quits: ChemicalHarm (Mibbit@moz-A9F37238.hsd1.md.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[11:56:33] *** flaper87|afk is now known as flaper87
[11:57:56] *** Joins: spider-mario (spidermari@moz-2F72F6FF.dsl.quantic-telecom.net)
[11:59:18] *** Quits: five (five@1AAB1A1C.EC1FF11B.12750D2E.IP) (Connection reset by peer)
[12:00:23] <sigma> bjz_: I'm still at the lexer stage :) thought I've restarted about 4 times 
[12:00:26] <sigma> though*
[12:00:54] <bjz_> hah, I don't envy you :)
[12:01:48] *** Quits: Liothen (liothen@moz-80EF0CD7.spkn.qwest.net) (Quit: Textual IRC Client: www.textualapp.com)
[12:02:07] <sigma> it's actually fairly interesting, I keep having flashbacks to second year in uni
[12:02:26] <Seldaek> sigma: are you doing insane-xml support or just xml? i.e. namespaces, entity definitions and other stuff that can be abused?
[12:03:01] <sigma> at the minute I'm planning on supporting what Jabber requires
[12:03:11] <sigma> which does include namespaces, but doesn't include a lot of other stuff
[12:03:30] <Seldaek> alright
[12:04:09] *** Quits: pyrac (pyrac@3907364F.73C89388.AD05C589.IP) (Quit: pyrac)
[12:04:14] <Seldaek> the rest should never have existed anyway so it's probably best :p
[12:08:13] <sigma> I might end up adding it if I decide to pad my CV
[12:08:44] <sigma> "implemented a fully compliant XML parser" seems like a non-trivial thing to have on there
[12:09:13] <Ms2ger> Also a pretty useless thing ;)
[12:09:47] <sigma> yup
[12:11:49] *** flaper87 is now known as flaper87|afk
[12:13:48] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[12:15:03] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[12:15:59] *** Quits: reyre|away (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Client exited)
[12:16:25] *** Joins: reyre|away (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[12:17:10] *** Joins: sp3d (a@moz-6F12212B.fidnet.com)
[12:18:11] *** Quits: reyre|away (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Ping timeout)
[12:24:03] *** Joins: pnkfelix|rcirc (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[12:26:21] *** Quits: sp3d (a@moz-6F12212B.fidnet.com) (Ping timeout)
[12:28:55] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[12:30:35] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[12:31:46] *** Joins: sw17ch (sw17ch@moz-62998E95.hfc.comcastbusiness.net)
[12:37:03] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[12:37:08] *** Joins: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net)
[12:37:37] *** Quits: sw17ch (sw17ch@moz-62998E95.hfc.comcastbusiness.net) (Ping timeout)
[12:40:42] <bjz_> rusti: trait Intersect<Result> {} struct Plane<S>; struct Ray<S>; struct Point<S>; impl<S> Intersect<Option<Point<S>>> for (Ray<S>, Ray<S>); impl<S> Intersect<Option<Point<S>>> for (Plane<S>, Ray<S>); impl<S> Intersect<Option<Ray<S>>> for (Plane<S>, Plane<S>); impl<S> Intersect<Option<Point<S>>> for (Plane<S>, Plane<S>, Plane<S>);
[12:40:43] -rusti- ()
[12:41:03] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[12:41:03] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/l0nD0w
[12:41:03] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[12:41:51] <dbaupp> bjz_: woah
[12:42:42] <dbaupp> bjz_: that's pretty neat
[12:42:45] <kimundi> That looks... Interesting :)
[12:43:00] <dbaupp> (though you should just include the point/line at infinity, and then all lines & planes intersect)
[12:43:02] <dbaupp> :P
[12:43:04] <kimundi> (And my PR passed, yay)
[12:46:01] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[12:46:02] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/A2gvTw
[12:46:02] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[12:46:02] <bjz_> rusti: trait Intersect<Result> { fn intersect(&self) { println("hi") } } struct Plane<S>; struct Ray<S>; struct Point<S>; impl<S> Intersect<Option<Point<S>>> for (Ray<S>, Ray<S>); impl<S> Intersect<Option<Point<S>>> for (Plane<S>, Ray<S>); impl<S> Intersect<Option<Ray<S>>> for (Plane<S>, Plane<S>); impl<S> Intersect<Option<Point<S>>> for (Plane<S>, Plane<S>, Plane<S>); (Plane::<int>, Plane::<int>, Plane::<int>).intersect()
[12:46:03] -rusti- hi
[12:46:03] -rusti- ()
[12:46:04] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[12:46:04] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/HZc80g
[12:46:04] <ghrust> 13rust/06auto 14364beaa 15Huon Wilson: Un-xfail/move/delete some tests.
[12:46:04] <ghrust> 13rust/06auto 1412099ce 15Huon Wilson: Tests for fixed issues....
[12:46:04] <ghrust> 13rust/06auto 14490c0c7 15Huon Wilson: Re-xfail extern-pass-TwoU{8,16}.rs (still doesn't work on 32-bit platforms).
[12:46:05] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[12:46:17] <bjz_> rusti: trait Intersect<Result> { fn intersect(&self) { println("hi") } } struct Plane<S>; struct Ray<S>; struct Point<S>; impl<S> Intersect<Option<Point<S>>> for (Ray<S>, Ray<S>); impl<S> Intersect<Option<Point<S>>> for (Plane<S>, Ray<S>); impl<S> Intersect<Option<Ray<S>>> for (Plane<S>, Plane<S>); impl<S> Intersect<Option<Point<S>>> for (Plane<S>, Plane<S>, Plane<S>); (Plane::<int>, Ray::<int>).intersect()
[12:46:18] -rusti- hi
[12:46:18] -rusti- ()
[12:46:45] *** Joins: Blub\w (wry@moz-3ADAE0B1.wireless.dyn.drei.com)
[12:47:10] * dbaupp hopes it passes this time
[12:48:29] <mindcat> http://paste.ubuntu.com/6058767/ if I disconnect, then I got something wrong. why?
[12:48:50] *** Quits: upstream (TheDust@moz-8C2076C2.upc-d.chello.nl) (Quit: )
[12:49:13] <dbaupp> mindcat: firstly, you probably don't need the `.to_owned()` call if you're just calling fmt straight away
[12:49:41] <dbaupp> mindcat: you should print out the value of `buf` without converting it to a string and see what it looks like
[12:49:59] <dbaupp> I'd guess it includes some 255u8's in it, or something like that.
[12:50:45] <dbaupp> mindcat: also, `let != None { len.unwrap() ... }` would be nicer as `match len { Some(len) => ..., None => {} }`
[12:52:27] <bjz_> dbaupp: yeah I was just checking it wouldn't give an ambiguous error message
[12:53:01] <dbaupp> bjz_: and it didn't, so you win :)
[12:53:20] * bjz_ fistpumps air
[12:53:24] <bjz_> YEAH!
[12:53:45] <mindcat> dbaupp: http://paste.ubuntu.com/6058782/
[12:54:00] <bjz_> dbaupp: shame it isn't really extensible if you want to use it outside the crate
[12:55:06] *** Quits: fabiand (fabiand@moz-E2579CED.adsl.alicedsl.de) (Quit: Verlassend)
[12:55:13] <Seldaek> is there a way to swap two values in a vector in one line like a[0],a[1] = a[1],a[0] ?
[12:55:19] <dbaupp> bjz_: hm?
[12:55:29] <dbaupp> Seldaek: there's .swap(i, j) iirc
[12:55:42] <Seldaek> oh ok, I was thinking too far :p
[12:55:48] <bjz_> dbaupp: like say I had a lib, cgcollide, and wanted to intersect with an AABB
[12:55:57] <dbaupp> mindcat: strange
[12:56:08] <bjz_> dbaupp: ie. intersect a ray with an AABB
[12:56:13] *** Joins: fabiand (fabiand@moz-E2579CED.adsl.alicedsl.de)
[12:56:34] <dbaupp> bjz_: doesn't Intersect<Ray> for (AABB, Ray) work?
[12:56:43] <mindcat> dbaupp: I am writing a echo server
[12:56:59] <dbaupp> bjz_: (well, Intersect<Interval>, I guess.)
[12:57:17] <bjz_> dbaupp: well it wouldn't because Interesect is in a different crate, and you're trying to impl it on a tuple
[12:57:49] <dbaupp> bjz_: ah!
[12:57:54] <bjz_> :)
[12:58:04] <dbaupp> bjz_: struct MyTuple<T,U>(T,U)
[12:58:14] <bjz_> yeah :(
[12:58:19] <bjz_> not as pretty
[12:58:25] <dbaupp> mindcat: how are you disconnecting?
[12:59:30] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[12:59:45] <dbaupp> mindcat: and how are you sending the messages that do work?
[13:00:03] <mindcat> dbaupp: I am using telnet connect it
[13:01:40] <mindcat> dbaupp: should I don't use telnet?
[13:02:12] <dbaupp> mindcat: I don't know
[13:03:23] *** Joins: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP)
[13:03:23] *** ChanServ sets mode: +o jdm
[13:05:23] *** Joins: tgummerer (tgummerer@moz-BCEA97E9.kthopen.kth.se)
[13:07:25] <mindcat> http://paste.ubuntu.com/6058830/
[13:07:52] <mindcat> this does not work too
[13:08:21] *** flaper87|afk is now known as flaper87
[13:08:24] <dbaupp> it looks like `255, 244, 255, 253, 6` is being read on exit somehow
[13:08:58] <dbaupp> (your original code is better; don't use @mut unless you absolutely have to.)
[13:08:59] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[13:10:00] <mindcat> dbaupp: actually, I don't know @mut how to work
[13:10:15] <dbaupp> the order of "niceness" is basically: no allocations (e.g. using lifetimes, and &), ~ allocations (e.g. ~str & to_owned), @ allocations, and the *worse* is @mut
[13:10:28] <dbaupp> *worst
[13:11:05] <mindcat> dbaupp: I mean, I don't know this...
[13:11:37] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[13:12:08] *** Quits: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net) (Quit: dave1629)
[13:12:12] <mindcat> dbaupp: I keep mind for this
[13:12:18] <dbaupp> engla: is https://github.com/mozilla/rust/pull/8884 ready, do you think?
[13:13:16] <achin> (netcat is almost always a better alternative to telnet for testing network stuffs)
[13:13:54] *** Quits: six600110 (six600110@moz-2FA48202.neo.res.rr.com) (Quit: Ex-Chat)
[13:16:49] <engla> dbaupp: yes
[13:17:41] *** Joins: six600110 (six600110@moz-2FA48202.neo.res.rr.com)
[13:18:21] *** Joins: pyrac (pyrac@3907364F.73C89388.AD05C589.IP)
[13:19:40] <dbaupp> engla: for https://github.com/mozilla/rust/pull/8884/files#L4R2363, i think fn f(&(_x, y): &(int, char)) -> bool { y == 'b' } would work too
[13:19:43] <dbaupp> (not that it matters)
[13:20:42] <engla> right. I didn't actually write that, just moved it from std::vec
[13:20:53] *** Quits: austincheney (quassel@8276C73B.985A737F.603BFF2.IP) (Ping timeout)
[13:21:03] <dbaupp> ah, cool
[13:21:37] <dbaupp> engla: r+
[13:21:51] <engla> thanks
[13:22:51] <dbaupp> engla: no, thank *you* :)
[13:29:02] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[13:29:57] *** Joins: eagen (eagen@8737942B.7A99C13A.B7961A98.IP)
[13:30:42] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[13:32:28] *** Joins: jdsanders (Adium@moz-84CB7548.hlrn.qwest.net)
[13:33:07] *** Joins: hellmage (luyun@BA3CF7DC.D8C06A0F.75B241AF.IP)
[13:33:40] *** Joins: Dallas62 (Mibbit@moz-516B01A9.fbx.proxad.net)
[13:33:41] <LRN> what is the idiomatic Rust - static method dispatch (fn foobar<T1: Foo> (a: T1) { a.bar () }) or dynamic method dispatch (fn foobar (a: Foo) { a.bar() })?
[13:34:02] <dbaupp> LRN: static
[13:34:14] <LRN> dbaupp, does it work across crates?
[13:34:17] <cmr> LRN: yes
[13:34:19] <dbaupp> yes
[13:34:23] <LRN> does it work across shared libraries?
[13:34:24] <cmr> Also, it's a: ~Foo
[13:34:27] <cmr> Yes.
[13:34:32] <kimundi> a crate is also a shared library
[13:34:34] <cmr> (or any of the other pointer types)
[13:34:34] <LRN> yeah, ~Foo
[13:35:15] <dbaupp> the "only" time dynamic dispatch should be used is when you need smaller code, or need to store things of many different types (and an enum doesn't work) and can take the perf hit of vtables.
[13:35:23] <kimundi> It even inlines across crates/shared libraries if you set the #[inline] hint
[13:35:26] <dbaupp> (smaller object code, that is.)
[13:35:37] <LRN> Is there an easy explanation of _how_ does it work for shared libs? I mean, does the compiler construct some kind of method table and give it to the function?
[13:36:02] <dbaupp> cmr: do you happen to know how to go from an expr_method_call -> the actual method that resolve has decided was called?
[13:36:14] <dbaupp> doomlord, doomlord_: ^
[13:36:27] <LRN> because it obviously can't make a new version of function that takes a particular type
[13:36:28] <cmr> LRN: it just mangles the name.
[13:36:35] <doomlord> hi
[13:36:36] <kimundi> LRN: It can
[13:36:38] <cmr> LRN: the AST is emitted into the object file as part of the metadata.
[13:36:47] <dbaupp> LRN: there's a rust_metadata section of the shared lib, which is read by rustc when compiling
[13:36:51] <cmr> So yes, it *does* instantiate a new version that takes the particular type :)
[13:36:57] <LRN> ah
[13:36:58] <dbaupp> doomlord: the question I asked cmr, just above pinging you
[13:37:19] <dbaupp> doomlord: i.e. I need to get the def (or something like that)
[13:37:21] *** Quits: jfbk (textual@moz-EEA9CFB3.nyc.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[13:37:32] <cmr> dbaupp: it looks like the NodeId might be the method it's calling?
[13:37:37] <cmr> Try looking it up in the def_map
[13:37:43] <dbaupp> and it appears that ty::ctxt.def_map doesn't hold it
[13:37:45] <dbaupp> yeah
[13:37:50] <cmr> I haven't really worked with that half of the ast
[13:38:04] <dbaupp> only the items stuff , right?
[13:38:08] <cmr> yup
[13:38:25] <doomlord> ok thanks, 
[13:38:43] <dbaupp> I guess:
[13:38:44] <dbaupp>     // Maps from a method to the method "descriptor"
[13:38:44] <dbaupp>     methods: @mut HashMap<DefId, @Method>,
[13:38:59] <dbaupp> is a very suggestive field on ty::ctxt
[13:39:11] <doomlord> i did have the defs etc extracted
[13:39:21] <doomlord> but i code makes me want throw up:)
[13:39:27] <doomlord> i'm sure i did it along way round
[13:39:30] *** Joins: lmandel (lmandel@13F2CEC5.7672369.D8E68FF6.IP)
[13:39:38] <cmr> heh
[13:39:45] <doomlord> i'm not sure i could tell you how to extract this
[13:39:57] <dbaupp> I think I've got it; I'm rebuilding now
[13:40:10] <cmr> dbaupp: I think the crate id will always be the local crate if you're walking an expression.
[13:40:42] <dbaupp> hm, wait, .methods isn't actually useful.
[13:40:46] <doomlord> "local crates"... to do jump to def between crates, i wrote out extra data that i read back in
[13:40:46] * dbaupp sighs
[13:41:06] <doomlord> i seem to remember having to back up in the AST to get methods
[13:41:35] *** Joins: dave1629 (dave@D15D3E03.357F2972.DDE5D3F6.IP)
[13:41:35] *** Quits: Dallas62 (Mibbit@moz-516B01A9.fbx.proxad.net) (Quit: http://www.mibbit.com ajax IRC Client)
[13:41:52] <doomlord> i did recently go back over my code to modularize it which had me whining about the module system yesterdaybut its ok now
[13:41:53] <cmr> I mean there has to be *some* way to do it, since trans works.
[13:42:59] <dbaupp> it appears that no methods end up in the defmap, unfortunately
[13:43:02] <doomlord> https://github.com/dobkeratops/rustfind/blob/master/jumptodefmap.rs
[13:43:38] <doomlord> its possible my extra datastructure replicates information already in librustc that i simply didn't find
[13:43:46] *** Quits: six600110 (six600110@moz-2FA48202.neo.res.rr.com) (Ping timeout)
[13:44:44] <doomlord> lines30 - 53
[13:44:53] *** Joins: six600110 (six600110@moz-2FA48202.neo.res.rr.com)
[13:45:32] <dbaupp> doomlord: thanks
[13:45:44] *** Joins: reyre|away (reyre@86C3727C.33EE9F8A.1139E686.IP)
[13:45:48] <dbaupp> where's the maps field defined?
[13:46:12] *** reyre|away is now known as reyre_
[13:46:33] <doomlord> da.ca.maps.method_map.find(&e.id) ?  
[13:46:37] <doomlord> ca is cratemap
[13:46:43] <doomlord> dc.ca.maps sorry
[13:47:10] <doomlord> or is it.. let me check..
[13:47:38] <doomlord> driver::CrateAnalysis
[13:47:41] <dbaupp> ah
[13:47:48] <dbaupp> in librustc itself
[13:48:00] *** Quits: reyre_ (reyre@86C3727C.33EE9F8A.1139E686.IP) (Quit: )
[13:48:02] *** Joins: logicchains (Mibbit@10F8E3A.623B366D.7565C1AC.IP)
[13:48:18] <dbaupp> this is going to make this code very hairy :(
[13:48:21] *** Joins: saml (sam@moz-14C16814.cst.lightpath.net)
[13:49:09] <doomlord> the explanation  i was given is, "the ast just works" ..of course its not explicitely designed as ageneral purpose api for wiring tools...
[13:49:27] <dbaupp> ... especially since I don't actually have access to that map in lint. :(
[13:49:47] <doomlord> https://github.com/dobkeratops/rustfind/blob/master/rfindctx.rs<<<  originally cloned from rustdoc code, its called "dc" because it used to be "DocContext"lol
[13:50:36] <doomlord> RFindCtx:  ast::Crate,   middle::ty::ctxt, driver::session::Session,  driver::driver::CrateAnalysis  .. those get passed around...
[13:51:05] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[13:51:05] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/HZc80g
[13:51:05] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[13:51:15] * LRN still tries to compare Rust to other languages.
[13:51:27] <LRN> At the moment Rust feels like C++, but you can't shoot yourself in the foot with it.
[13:51:29] <doomlord> .. i thinki pretty much made a copy of the whole ast to get spans->nodeids->actual node defiitions, "FNodeInfo"/"FNodeInfoMap" in my code.. its quite possible this was overkill
[13:51:41] <doomlord> hah C++ with a safety catch
[13:52:10] <dbaupp> doomlord: yeah, the problem is rustc::middle::lint only gives me the ty::ctxt, which apparently doesn't have anyway to get access to the method_map from typeck :/
[13:52:11] <sigma> I keep writing haskell like code. then going back over it and turning it into C++ like code, it's strange
[13:52:36] <dbaupp> doomlord: thanks so much for your help anyway, I now know what I'm meant to be looking at
[13:53:47] <tiffany> lrn: sounds like you don't appreciate its more FP-like features
[13:54:01] <logicchains> Hey, I hope I'm not interrupting, but I've got some threaded code that is exhibiting undefined behaviour, and I'd be really grateful if somebody could take a look. It should start four threads almost instantly, but instead it will start a random number of threads, wait for their task to complete, then start the rest.
[13:54:11] *** Quits: fyolnish (fyolnish@moz-1C9C8043.uqwimax.jp) (Client exited)
[13:54:29] <LRN> tiffany, it "feels" like C++ (complexity, sometimes arcane syntax)
[13:54:32] *** Joins: fyolnish (fyolnish@moz-1C9C8043.uqwimax.jp)
[13:54:59] <logicchains> It used to work on an older version of Rust, so I'm not sure if it's a scheduler issue or just something that needs to be done in the newer Rust that I'm not aware of.
[13:55:40] <dbaupp> logicchains: link to the code?
[13:55:48] <logicchains> https://gist.github.com/logicchains/6424159
[13:56:00] <dbaupp> logicchains: (and you're definitely not interrupting. :) )
[13:56:07] *** Joins: fyolnish_ (fyolnish@moz-1C9C8043.uqwimax.jp)
[13:56:09] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[13:56:09] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/n9cRzQ
[13:56:09] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[13:56:11] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[13:56:13] *** Quits: fyolnish (fyolnish@moz-1C9C8043.uqwimax.jp) (Ping timeout)
[13:56:25] <logicchains> Cool :) Run it a few times and see how the threading behaves
[13:58:13] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[13:58:37] <dbaupp> I think you may need to insert a task::yield or something
[13:58:48] <dbaupp> (I can't remember the name of the function)
[13:59:08] <dbaupp> ah, task::deschedule()
[13:59:36] <logicchains> Thanks, I'll try it.
[13:59:56] <dbaupp> there's currently no preemption, so a task will occupy a whole scheduler in a tight loop, which is what's happening here
[14:00:10] *** Joins: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net)
[14:00:23] <dbaupp> (I'm not quite sure what the difference to the old scheduler is.)
[14:00:40] <logicchains> Oh, right. So it's something that will go away once the new scheduler is developed more?
[14:00:54] *** Joins: mib_a4m01s (Mibbit@moz-BDC78F2.dsl.tropolys.de)
[14:01:31] <dbaupp> the need for it will be reduced when work stealing gets implemented properly, but I don't think it will ever go away fully
[14:01:31] <sigma> woo, my first ICE
[14:01:59] *** Quits: LRN (LRN@moz-50DF30B.nationalcablenetworks.ru) (Ping timeout)
[14:02:20] <dbaupp> (i.e. a tight loop with no IO or allocations will always eat a scheduler, because the userspace rust scheduler doesn't have access to the OS level powers needed for efficient preemption)
[14:02:30] *** Quits: jdsanders (Adium@moz-84CB7548.hlrn.qwest.net) (Quit: Leaving.)
[14:02:41] <Palmik> Guys, how do you usually define string newtype wrappers? Do you use struct Foo<'self>(&'self str)?
[14:03:06] <logicchains> Then is there a more idiomatic way to write such a loop that won't stress the scheduler?
[14:03:11] <dbaupp> logicchains: ok, yeah, adding task::deschedule to the top of the closure in mk_TypeAs makes it start 4 threads reliably
[14:03:17] <dbaupp> nope
[14:03:58] <dbaupp> I think the problem is currently it's not distributing across the schedulers that the rt starts up (one for each core) properly
[14:04:30] <dbaupp> (i.e. each core gets an OS level thread that's running a rust scheduler, each of which is running a pile of rust tasks)
[14:05:06] <dbaupp> and in this case, without the deschedule call, a pile == 4 for one of the schedulers and 0 for the rest (I think)
[14:06:18] *** Quits: mib_a4m01s (Mibbit@moz-BDC78F2.dsl.tropolys.de) (Quit: http://www.mibbit.com ajax IRC Client)
[14:06:21] <logicchains> Okay, that makes sense. Thanks for your help! I imagine something like this would be useful in the documentation on tasks.
[14:07:14] *** Joins: jdsanders (Adium@moz-84CB7548.hlrn.qwest.net)
[14:07:50] <dbaupp> Probably; although I think the situation is still fluid (e.g. the work stealing, which makes the schedulers balance their workload out) has still got a pile of improvement to happen
[14:08:11] * dbaupp should learn how to put parens in the right places
[14:08:40] <dbaupp> in any case, I see real    0m2.248s user    0m4.908s with deschedule and real    0m3.145s user    0m3.612s without, so it seems to help
[14:09:43] <bjz_> Palmik: what do you mean?
[14:09:44] <dbaupp> (although the exact numbers change... and they spend 1.2s in the kernel each o_O .. should probably try to reduce the number of allocations if possible)
[14:09:59] <bjz_> Palmik: what are you using it for? It looks ok...?
[14:10:17] *** Joins: aeqwa (aeqwa@moz-BDC78F2.dsl.tropolys.de)
[14:10:25] *** Quits: jaen (jaen@moz-882DC6A0.neoplus.adsl.tpnet.pl) (Ping timeout)
[14:10:36] <kimundi> Isn't there the option to start each task on a new thread?
[14:10:56] <bjz_> Palmik: do you mean whether to make it a slice or owned?
[14:11:11] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[14:11:23] <kimundi> Palmik: Depends on whether the wrapper is supposed to reference an existing string, or own it.
[14:11:45] <logicchains> It definitely helps. Comparing now my Rust benchmark with a new build, to one with the old scheduler, the new one is around 87% the speed of the old one.
[14:11:54] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[14:12:03] <kimundi> struct Foo<'self>(&'self str); and struct Foo(~str); - both work
[14:14:02] <dbaupp> logicchains: yup, that's not unexpected: the new one was rushed to a minimal working state, with optimisation happening later (i.e. now)
[14:15:26] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[14:16:10] <logicchains> Right. Is work on the scheduler a priority for 0.8, or will we be waiting for 0.9/1.0 for that?
[14:16:57] <dbaupp> not sure; I think it's all happening incrementally.
[14:17:05] <logicchains> (Also, I noticed the new build seems to require copying of the vector passed in the Port<~[SomeType]>; SomeType must derive Clone. Is there a way to avoid this?)
[14:17:23] <logicchains> Ah, okay. Then I look forward to watching as it grow.
[14:17:27] <logicchains> grows*
[14:17:41] <Palmik> kimundi: the problem I had with the second version is that you canno have (?) static values of it, right?
[14:18:08] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[14:18:50] <dbaupp> logicchains: it's the vec::append call, try `ls.push_all_move(port.recv())`
[14:19:42] <dbaupp> heh, that takes 0.7s off the time for me
[14:26:07] <logicchains> Nice, that does speed it up a bit for me. Is the current behaviour of append what's ultimately intended, or will it move rather than copy where possible?
[14:27:03] <engla> the programmer has the choice when using that method or another
[14:29:28] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[14:29:42] <logicchains> Interesting, seems more flexible than C++ vectors in that regard.
[14:29:55] *** Quits: dave1629 (dave@D15D3E03.357F2972.DDE5D3F6.IP) (Quit: dave1629)
[14:30:49] <logicchains> *Is far to eager to find an excuse to use 'unsafe fn push_fast' *
[14:31:08] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[14:31:27] <dbaupp> logicchains: don't
[14:31:36] <logicchains> Sorry
[14:31:42] <dbaupp> it's gonna disappear
[14:31:42] <dbaupp> https://github.com/mozilla/rust/issues/8769
[14:33:41] <logicchains> Probably a good thing. Otherwise you'd get people (myself possible included) using it instead of push for fear that push was slower than it could be, haha
[14:33:44] *** Quits: pyrac (pyrac@3907364F.73C89388.AD05C589.IP) (Quit: pyrac)
[14:34:16] *** Joins: pyrac (pyrac@3907364F.73C89388.AD05C589.IP)
[14:34:35] <dbaupp> I imagine that's the motivation for the issue :)
[14:34:49] * dbaupp -> bed
[14:35:29] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[14:36:06] *** Quits: tgummerer (tgummerer@moz-BCEA97E9.kthopen.kth.se) (Ping timeout)
[14:37:41] *** Quits: hellmage (luyun@BA3CF7DC.D8C06A0F.75B241AF.IP) (Connection reset by peer)
[14:40:59] *** Quits: logicchains (Mibbit@10F8E3A.623B366D.7565C1AC.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[14:45:47] <kimundi> Palmik: right
[14:47:33] *** Joins: lbergstrom (Adium@moz-5D8E4B14.lightspeed.cicril.sbcglobal.net)
[14:50:04] *** Quits: threecreepio (jdp@moz-1A9F0A3C.cust.bredband2.com) (Quit: threecreepio)
[14:54:17] *** Joins: jorendorff (jorendorff@moz-1747FB68.hsd1.tn.comcast.net)
[14:54:21] *** Quits: jorendorff (jorendorff@moz-1747FB68.hsd1.tn.comcast.net) (Input/output error)
[14:58:18] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[14:59:17] *** Joins: jmgrosen (jmgrosen@moz-A3814C08.sd.sd.cox.net)
[15:00:27] *** Quits: jmgrosen (jmgrosen@moz-A3814C08.sd.sd.cox.net) (Quit: jmgrosen)
[15:01:18] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[15:01:18] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/a_vALQ
[15:01:18] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[15:05:08] *** Quits: mindcat (mindcat@51E8D533.C6D6E0F5.857BDFA9.IP) (Ping timeout)
[15:06:07] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[15:06:07] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/tvyRLQ
[15:06:07] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[15:06:07] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[15:06:07] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/VAbINw
[15:06:07] <ghrust> 13rust/06auto 1409ad0cd 15Daniel Micay: add type name to the tydesc...
[15:06:07] <ghrust> 13rust/06auto 14a6a993e 15Daniel Micay: repr: add very basic support for functions...
[15:06:08] <ghrust> 13rust/06auto 14c14daba 15bors: auto merge of #8947 : thestinger/rust/name, r=huonw...
[15:06:09] *** Joins: jorendorff (jorendorff@moz-1747FB68.hsd1.tn.comcast.net)
[15:06:10] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[15:08:25] <aeqwa> Hello! I'm new to Rust and it looks like a very interesting language. But I running into one problem as working throu
[15:08:42] <aeqwa> hg the 0.7 tutorial
[15:09:36] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Ping timeout)
[15:10:33] *** Quits: Ralith (ralith@114DA04D.CD83ED0A.BCDF04A6.IP) (Ping timeout)
[15:10:36] <kimundi> aeqwa: Just ask :)
[15:10:50] <aeqwa> In one of there code showed in 4.3 Loops they used int::to_str(). But if i use it in my code i get this errors http://pastebin.com/JdmCNk6G
[15:10:58] *** Joins: bent (chatzilla@C36F5748.8CE62E0F.A36C57B9.IP)
[15:11:39] *** Quits: nsf (nsf@moz-EEF3238A.convex.ru) (Quit: WeeChat 0.4.1)
[15:11:41] <engla> the module should be std::int  unless you import int by itself: use std::int;
[15:11:51] <engla> if that function actually exists in 0.7 I'm not sure
[15:12:05] <engla> you probably want to replace it with x.to_str()
[15:15:19] *** Joins: jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net)
[15:17:01] <aeqwa> engla: Thanks use std::int works for me.
[15:18:10] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[15:20:56] *** Joins: ozten (ozten@moz-DD3B00B4.hsd1.wa.comcast.net)
[15:23:24] *** Joins: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net)
[15:23:50] *** Joins: eholk (eholk@moz-4227E445.hfc.comcastbusiness.net)
[15:25:13] *** Quits: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net) (Ping timeout)
[15:30:35] <jdsanders> Is this a decent way to generate a random number between 1 and 100? `abs(rand::rng().gen::<int>() % 100) + 1`
[15:31:40] *** Joins: tautologico (lymph@8ABDEDA.34CAB63A.7B974E06.IP)
[15:32:20] <jdsanders> I suppose I could at least get rid of the `abs` part by just asking for a uint…
[15:33:03] *** Joins: boredomist (user@moz-63CF9F31.res-cmts.sesp.ptd.net)
[15:34:41] *** Joins: echristo (echristo@60A74940.D6CCE4AE.77834EAA.IP)
[15:35:44] <jdsanders> ah, doy, just found gen_uint_range(x, y)
[15:36:08] <doy> hmmm?
[15:36:37] * Ms2ger suspects 'joy' was meant
[15:40:30] <jdsanders> ha, whoops, sorry to bug you doy, Ms2ger is right
[15:41:46] <sigma> hmm, there is no way for a function to return a function with the same signature as itself is there?
[15:43:04] <jdm> sigma: as in, it returns a function that returns a function that...
[15:43:16] <sigma> yeh :)
[15:43:20] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[15:44:04] <engla> maybe with a type inbetween
[15:44:20] <sigma> I'll have a play around
[15:45:24] <engla> sigma: here's a hole with stack closures that had to be closed http://smallcultfollowing.com/babysteps/blog/2013/04/30/the-case-of-the-recurring-closure/
[15:45:34] <engla> hole in soundness
[15:45:50] <engla> now I guess it's not the same thing
[15:46:18] <sigma> yeh, I was reading that, I'm not concerned about passing state around with it
[15:50:09] *** Joins: justinfront (chatzilla@moz-5B826A1D.saqnet.co.uk)
[15:50:49] <sigma> rusti: type Recfn<'self> = &'self fn() -> Recfn<'self>;
[15:51:22] -rusti- <anon>:5:29: 5:56 error: illegal recursive type; insert an enum in the cycle, if this is desired
[15:51:22] -rusti- <anon>:5          type Recfn<'self> = &'self fn() -> Recfn<'self>;
[15:51:22] -rusti-                                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[15:51:22] -rusti- application terminated with error code 101
[15:51:34] <sigma> ahh, theres an idea
[15:51:39] <sigma> good compiler
[15:51:51] <justinfront> Hi I would like to complie a more recent firefox on my leopard i386 mac, I presume first I need to try to get assistance building rust on leopard, I got quite far last time I tried but failed before the end?  Anyone game to help?
[15:53:00] *** Joins: miza (miza@moz-4DD51325.home.otenet.gr)
[15:53:55] <kimundi> justinfront: rust and firefox have no connection at the moment
[15:54:29] <kimundi> So, yeah, better ask in #firefox or so
[15:54:33] <Ms2ger> #introduction 
[15:55:02] <kimundi> Or there, don't really know about the channels apart from #rust :P
[15:55:15] <justinfront> ok thanks
[15:55:46] *** Joins: threecreepio (jdp@moz-71E164C9.cust.bredbandsbolaget.se)
[15:58:05] *** Quits: heftig (heftig@moz-76E8421A.dip0.t-ipconnect.de) (Quit: Quitting)
[15:58:37] *** Joins: tjc (tjc@moz-6EB4E533.dsl.tsoft.com)
[15:58:37] *** ChanServ sets mode: +o tjc
[16:00:13] *** Joins: jmgrosen (jmgrosen@moz-A3814C08.sd.sd.cox.net)
[16:00:35] *** Joins: heftig (heftig@moz-76E8421A.dip0.t-ipconnect.de)
[16:01:04] <tjc> nmatsakis: are we in CYA?
[16:01:20] <pnkfelix> tjc: mtg was moved to 10 am Pacific
[16:01:31] <tjc> pnkfelix: d'oh, I should have remembered that
[16:01:43] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[16:02:07] <nmatsakis> tjc: what pnkfelix said
[16:02:19] <nmatsakis> though I don't recall if wemoved rooms
[16:02:54] *** Quits: jmgrosen (jmgrosen@moz-A3814C08.sd.sd.cox.net) (Quit: jmgrosen)
[16:04:06] <pnkfelix> nmatsakis: oh that's right.  I think azita said something about the room needing to change
[16:04:26] *** Parts: justinfront (chatzilla@moz-5B826A1D.saqnet.co.uk) ()
[16:07:04] <nmatsakis> tjc: pnkfelix: GIGO
[16:07:13] <tjc> nmatsakis: thanks
[16:08:16] *** Joins: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net)
[16:10:59] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[16:10:59] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/VAbINw
[16:10:59] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[16:11:23] *** Joins: Kruppe (user@moz-4DDA8AB8.uwaterloo.ca)
[16:11:35] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[16:12:43] *** Quits: lbergstrom (Adium@moz-5D8E4B14.lightspeed.cicril.sbcglobal.net) (Quit: Leaving.)
[16:13:27] *** Quits: pyrac (pyrac@3907364F.73C89388.AD05C589.IP) (Ping timeout)
[16:13:52] *** Joins: lbergstrom (Adium@moz-5D8E4B14.lightspeed.cicril.sbcglobal.net)
[16:14:36] *** Quits: Kruppe (user@moz-4DDA8AB8.uwaterloo.ca) (Connection reset by peer)
[16:14:49] *** Joins: Kruppe (user@moz-4DDA8AB8.uwaterloo.ca)
[16:16:34] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[16:22:03] <pnkfelix> tjc, nmatsakis: hmm, mtg cancelled.
[16:22:24] <tjc> pnkfelix: Ah ok
[16:23:03] *** Joins: lenstr (lenstr@E0E80B8D.ED45D46B.DFEAE789.IP)
[16:23:40] *** Quits: tjc (tjc@moz-6EB4E533.dsl.tsoft.com) (Quit: zzzzzzzzzz)
[16:24:06] *** Quits: Kruppe (user@moz-4DDA8AB8.uwaterloo.ca) (Ping timeout)
[16:28:29] *** Joins: zwol (zack@moz-B5C129C.ece.cmu.edu)
[16:29:13] *** Joins: dave1629 (dave@F1886EC7.A9DA0237.DDE5D3F6.IP)
[16:30:22] *** Quits: Houm (Houm@moz-25669AA8.fbx.proxad.net) (Ping timeout)
[16:32:41] <SimonSapin> How do I copy from &T to get a T? .clone() seems to return a &T
[16:33:46] *** Quits: threecreepio (jdp@moz-71E164C9.cust.bredbandsbolaget.se) (Quit: threecreepio)
[16:33:55] <kimundi> SimonSapin: if clone() gives you a &T, then try dereferencing one layer before making the clone call: (*foo).clone()
[16:34:20] <kmc> pnkfelix: hm, do you know why?
[16:34:22] <SimonSapin> kimundi: I what cases can I dereference a &T?
[16:34:33] *** Quits: six600110 (six600110@moz-2FA48202.neo.res.rr.com) (Ping timeout)
[16:34:51] <SimonSapin> and not get "cannot move out of dereference of & pointer"
[16:34:56] <kimundi> Hmmm..
[16:34:58] *** Joins: Houm (Houm@moz-25669AA8.fbx.proxad.net)
[16:35:07] <kimundi> Could you gist the code?
[16:35:33] <SimonSapin> your suggestion seems to work, but this was a more general question
[16:35:56] <engla> .clone() is this way because it's implemented on generic &T as well
[16:36:01] <kimundi> ah
[16:37:12] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[16:37:29] *** Quits: lenstr (lenstr@E0E80B8D.ED45D46B.DFEAE789.IP) (Client exited)
[16:37:50] <pnkfelix> kmc: pcwalton and dherman are out of office
[16:37:55] <kimundi> clone() works with &self, the problem is that method calls autoderef and autoderef to get to that.
[16:38:14] <pnkfelix> kmc: so I think the plan is to wait until they are available for mtg
[16:38:16] <kimundi> so, if you have a T or a &T .clone() give you a copy of T
[16:38:16] <kmc> ok
[16:38:35] <kimundi> To get a copy of the borrowed pointer you need to have a & &T
[16:38:53] *** Joins: threecreepio (jdp@moz-71E164C9.cust.bredbandsbolaget.se)
[16:39:06] <kimundi> conversely, if you have a & &T, you need to "deref" the outer pointer to call clone() on a &T
[16:39:33] <erickt> aatch: ping
[16:39:40] <kimundi> That will work because borrowed pointers are implicit copyable, so a deref of the outer one will just give you a temporary copy
[16:39:58] <SimonSapin> In this case I want deref then copy. But now I need to add a bunch of #[deriving(Clone)]. Is that the right syntax?
[16:40:35] *** Joins: Ralith (ralith@A8995AA9.62B6AF6A.922221DB.IP)
[16:40:36] <kimundi> derving Clone is if you want to maek your type copyable, yeah.
[16:41:43] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[16:41:49] <acrichto> dbaupp: pong
[16:42:01] *** Joins: five (five@FC8B9D7D.C4AAC3ED.10BB00EE.IP)
[16:44:39] *** Quits: five (five@FC8B9D7D.C4AAC3ED.10BB00EE.IP) (Connection reset by peer)
[16:45:35] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[16:45:36] *** ChanServ sets mode: +o tjc
[16:46:03] *** Joins: Kruppe (user@moz-4DDA8AB8.uwaterloo.ca)
[16:46:27] <cmr> rusti: 1 & 3 as bool
[16:46:27] -rusti- <anon>:5:13: 5:22 error: mismatched types: expected `<VI0>` but found `bool` (expected integral variable but found bool)
[16:46:28] -rusti- <anon>:5          1 & 3 as bool
[16:46:28] -rusti-                       ^~~~~~~~~
[16:46:28] -rusti- error: aborting due to previous error
[16:46:28] -rusti- application terminated with error code 101
[16:46:36] <cmr> rusti: (1 & 3 )as bool
[16:46:37] -rusti- true
[16:46:52] <nmatsakis> ah the dreaded "what is the precedence of `as` again"?
[16:47:10] *** Joins: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net)
[16:50:04] *** Quits: spider-mario (spidermari@moz-2F72F6FF.dsl.quantic-telecom.net) (Input/output error)
[16:51:02] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[16:51:02] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/JtGTlw
[16:51:02] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[16:51:03] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[16:51:04] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/F_8lgQ
[16:51:04] <ghrust> 13rust/06auto 147e70247 15Alex Crichton: Don't have format! move out of local variables
[16:51:04] <ghrust> 13rust/06auto 14dee9d7f 15bors: auto merge of #8945 : alexcrichton/rust/ifmt-dont-move, r=thestinger
[16:51:04] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[16:51:12] *** Joins: six600110 (six600110@moz-2FA48202.neo.res.rr.com)
[16:51:29] *** Joins: pepper_chico (pepper_chi@14AC4DFD.704EE6B0.E4090502.IP)
[16:52:23] *** Joins: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com)
[16:53:49] <cmr> Ok that is obnoxious
[16:53:58] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[16:54:44] <cmr> The rust parser rejects trailing commas in function calls.
[16:54:47] <cmr> https://gist.github.com/cmr/35f4b979b1b707e71e12#file-gistfile1-txt-L14
[16:55:06] <cmr> Considering trailing commas are allowed elsewhere, I find it odd as well as annoying.
[16:55:20] <pnkfelix> cmr:we might have recently decided during  a triage session to change that
[16:55:43] <pnkfelix> cmr: i dont have issue number handy to check if it was about comams in function calls, or somewhere else
[16:55:50] *** Quits: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net) (Ping timeout)
[16:57:00] <erickt> cmr: trailing commas also isn't supported in pattern matching, if I recall correctly
[16:57:18] *** Quits: mark_edward (quassel@moz-97E995A.hsd1.in.comcast.net) (Ping timeout)
[16:57:28] *** Joins: mark_edward (quassel@moz-97E995A.hsd1.in.comcast.net)
[16:58:21] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[16:58:21] *** ChanServ sets mode: +ao brson brson
[16:58:23] <erickt> does anyone know if we're ever intending on auto-coercing an impl to a trait pointer?
[16:58:28] *** Quits: jdsanders (Adium@moz-84CB7548.hlrn.qwest.net) (Quit: Leaving.)
[16:58:59] <sfackler> I hope so
[16:59:03] <sfackler> auto borrow would be nice too
[16:59:18] <erickt> sfackler: I think dbaupp just landed auto borrowing
[16:59:46] <sfackler> auto borrow into trait object?
[17:00:02] <acrichto> erickt: pcwalton had a pull pull request a long time ago named "monomorphic trait coercion" which I believe did that, but it was never merged
[17:00:44] <ecr> hm, bors still hasn't noticed that r+ you have me 2 days ago cmr.
[17:00:49] <ecr> *gave
[17:00:56] <pnkfelix> erickt: the coercion from impl to trait pointer … I cannot remember, does that allocate a vtable?  (I think there's been a philosophy of trying to ensure allocations are reflected by explicit operations in the source code)
[17:01:21] <pnkfelix> erickt: but… on reflection, I think I'm mistaken about this.
[17:02:05] <pnkfelix> erickt: (I need to go learn about how that's handled.  I think nmatsakis previously explained to me that it doesn't allocate a whole vtable duirng that step, just a couple words.)
[17:02:11] *** Joins: jorendorff_away (jorendorff@moz-C5535E6C.compute-1.amazonaws.com)
[17:02:30] <sfackler> I can see an argument for wanting it to be more explicit, but the current situation isn't super usable: [&1i32 as &ToSql, & &"biz" as &ToSql]
[17:02:33] *** Quits: jorendorff (jorendorff@moz-1747FB68.hsd1.tn.comcast.net) (Quit: Textual IRC Client: www.textualapp.com)
[17:03:02] *** jorendorff_away is now known as jorendorff
[17:03:14] <ecr> it'd be better if you could do something like [&1i32, &"biz"] as [&ToSql] instead
[17:03:31] *** Joins: jfbk (textual@moz-EEA9CFB3.nyc.res.rr.com)
[17:03:32] <ecr> rather than on every element
[17:03:57] <ecr> we could probably make that a macro actually.
[17:04:03] <sfackler> I'd honestly prefer [1i32, "biz"] and have it auto borrow and auto cast, but that might be a bit too magical for people
[17:04:15] <pnkfelix> ecr: bleah.  I don't like that; the pseudo-subexpression "[&1i32, &"biz"]" is not coherent
[17:04:43] <ecr> pnkfelix: I had the same thought as I typed it out
[17:04:51] <engla> what about trying to coerce to the type of the first element of the vector?  ~[1u, 2, 3] is ~[uint]
[17:05:12] <nmatsakis> plan of record is to make the `as` so it does not have to be written explicitly (in mayn cases)
[17:05:23] <nmatsakis> but I'm not sure about that particular case
[17:05:24] <engla> [&1i32 as &ToSql, & &"biz"]  yet more asymmetry
[17:06:26] <ecr> as_object!(&ToSql, [&1i32, &"biz"]) ?
[17:06:28] <nmatsakis> erickt: we are planning on auto-coercing to an object, I've been wiating for pcwalton to rebase his PR, though I'm thinking about doing it myself...
[17:06:29] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[17:06:40] *** Joins: riley (riley@8BA43816.9AA11D69.65DDFA89.IP)
[17:06:41] <nmatsakis> erickt: if I finish up current patches anyway
[17:07:28] <kimundi> nmatsakis: Ah, autocoercing trait objects is still on the table?
[17:08:31] <bjz_> tjc: I have a directory glfw/src/examples/  with subdirectories containing <subdir>/main.rs
[17:09:09] *** Joins: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP)
[17:09:16] <bjz_> tjc: when I do rustpkg build examples, I see it building all the crates, but it doesn't seem to output anywhere
[17:09:23] <tjc> bjz_: Hmm
[17:09:29] <nmatsakis> kimundi: yes. afaik it's been agreed to.
[17:09:48] *** Joins: jmgrosen (jmgrosen@moz-A3814C08.sd.sd.cox.net)
[17:10:02] <tjc> bjz_: can you see if there's a build directory under glfw/ or glfw/.rust ?
[17:10:04] *** Quits: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP) (Client exited)
[17:10:08] *** Quits: sk (sk@76BFB31C.71F9CB99.78DD174B.IP) (Quit: Leaving)
[17:10:49] <SimonSapin> what’t the bug nubmer for <for T>? (type hint on associated functions on traits)
[17:11:19] <bjz_> tjc: there is - it contains an examples directory
[17:11:45] <tjc> bjz_: and are the executables under build/examples/[various subdirectories]?
[17:11:45] <bjz_> tjc: with an examples bin
[17:11:56] <bjz_> tjc: no subdirs
[17:12:10] <tjc> bjz_: Hmm, can you find . -print or something and gist the results?
[17:13:39] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[17:14:41] *** Joins: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP)
[17:15:12] <bjz_> tjc: https://gist.github.com/bjz/8aac0e5338f50b88e31c
[17:15:57] *** Joins: nsf (nsf@moz-EEF3238A.convex.ru)
[17:16:54] <tjc> bjz_: Ok, looks like rustpkg is doing something wrong there. I'll open an issue
[17:18:02] *** Quits: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk) (Client exited)
[17:18:32] <tjc> bjz_: https://github.com/mozilla/rust/issues/8952
[17:18:41] *** Quits: aeqwa (aeqwa@moz-BDC78F2.dsl.tropolys.de) (Quit: Lost terminal)
[17:18:56] *** Joins: aeqwa (aeqwa@moz-BDC78F2.dsl.tropolys.de)
[17:19:57] *** Quits: jmgrosen (jmgrosen@moz-A3814C08.sd.sd.cox.net) (Quit: jmgrosen)
[17:21:35] <bjz_> tjc: cheers!
[17:21:46] <bjz_> tjc: <3 rustpkg
[17:21:52] <tjc> bjz_: Thanks!
[17:22:09] <bjz_> tjc: soooo much better than makefiles :)
[17:22:12] *** Joins: josh (josh@moz-606D1C72.mpls.qwest.net)
[17:22:22] <tjc> bjz_: Heh, well, it doesn't quite do everything that Makefiles do yet :-)
[17:22:41] <bjz_> tjc: oh well, it's on its way anyway
[17:22:49] <bjz_> tjc: how decoupled is it from git?
[17:23:12] <tjc> bjz_: well, so far git is the only VCS it supports, but not much of it is tightly coupled to any VCS
[17:23:19] <bjz_> coolies
[17:23:21] <tjc> so far it uses it to fetch from URLs, and get versions
[17:23:35] <tjc> wouldn't be hard to abstract that out and make it less dependent on a particular VCS
[17:24:14] <bjz_> yeah, that's all I was wondering. not that I'm using anything else though
[17:24:16] *** Joins: five (five@8142522D.4A25D2B6.6D9B563.IP)
[17:24:24] *** Joins: ofeldt (ofeldt@moz-432725D0.dip0.t-ipconnect.de)
[17:24:25] <tjc> Yeah, I'm not sure how many people use something other than git anymore :-)
[17:24:49] <bjz_> but there could be something else in the future!
[17:24:55] <bjz_> :)
[17:24:55] <tjc> yep
[17:25:04] *** Quits: ofeldt- (ofeldt@moz-B08F1AF8.dip0.t-ipconnect.de) (Ping timeout)
[17:25:36] <bjz_> rustyvcs
[17:25:44] <tjc> maybe someday!
[17:25:47] <bjz_> :P
[17:25:50] <Ms2ger> rcs?
[17:25:54] <bjz_> yah!
[17:26:13] <sigma> if you wanted you could use git-svn er whatever to pull from non-git repos as a stopgap :)
[17:26:19] <sigma> or*
[17:26:48] <Ms2ger> I, for one, don't like git ;)
[17:27:02] <bjz_> Ms2ger: it's abit weird
[17:27:31] <bjz_> Ms2ger: great ideas, but the UI is rather obtuse
[17:27:32] <Ms2ger> We can use "a bit", if you like that :)
[17:27:38] <sigma> it seems to have become the c equivalent for vcs's, everything has a git export/import
[17:28:46] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[17:28:46] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[17:30:01] *** Quits: five (five@8142522D.4A25D2B6.6D9B563.IP) (Connection reset by peer)
[17:33:33] *** Joins: five (five@8142522D.4A25D2B6.6D9B563.IP)
[17:33:40] <olsonjeffery> did the weekly meeting happen?
[17:33:48] <olsonjeffery> or are notes just not being taken..?
[17:33:54] <tjc> olsonjeffery: cancelled this week, various people on vacation or out of office
[17:33:56] <ecr> no meeting this week
[17:35:12] <olsonjeffery> tjc: what's your github commit access policy pitch, if i may ask?
[17:35:12] *** Quits: five (five@8142522D.4A25D2B6.6D9B563.IP) (Connection reset by peer)
[17:35:34] <tjc> olsonjeffery: I didn't have a pitch; I just figured we needed to come up with a plan other than "Graydon decides" :-)
[17:35:39] * olsonjeffery nods
[17:35:46] <ecr> hm, is there a way to pass a 'return' function to a higher order function? (I'd like to use map_move on an Option<IoError> and just return if an error occurred).
[17:35:53] <olsonjeffery> i requestesd access so i could push to try
[17:35:58] <olsonjeffery> also: PRESTIGE, heh
[17:36:15] <tjc> olsonjeffery: Yeah, one of the things I wanted to figure out is whether there's a way to give people more fine-grained access
[17:36:25] <tjc> like, I'd love to let almost anybody push to try if it didn't come with "push to everything"
[17:36:33] * olsonjeffery nods
[17:37:10] <jensnockert> tjc: Couldn't we have a separate repo that syncs up with Github when it passes tests?
[17:37:23] <tjc> jensnockert: Hmm, I don't know if anyone's considered that before
[17:37:31] <ecr> could we make a 'rust-try' github repo, give people access to that, and have bors pull from there when necessary?
[17:37:38] <tjc> ecr: Also an interesting idea
[17:37:52] <tjc> although I don't think bors would need to have to pull from it directly
[17:38:09] <tjc> the way we use try now is that the person pushing commits always submits a pull request anyway, afterward, if try succeeds
[17:38:59] <tjc> well, obviously bors would need to pull from it to run tests
[17:39:05] <tjc> I just mean it would never merge from rust-try into master
[17:39:21] <ecr> I wonder why my PR hasn't been recognized by bors when cmr r+'ed it 2 days ago...
[17:39:29] <tjc> ecr: link?
[17:39:36] <ecr> https://github.com/mozilla/rust/pull/8868
[17:39:49] *** Quits: eholk (eholk@moz-4227E445.hfc.comcastbusiness.net) (Quit: eholk)
[17:40:18] *** Quits: josh (josh@moz-606D1C72.mpls.qwest.net) (Ping timeout)
[17:40:24] *** Joins: josh (josh@moz-5CEF2838.mpls.qwest.net)
[17:40:40] <tjc> ecr: hmm, weird
[17:41:00] <ecr> I wondered if he'd r+'ed the PR instead of the commit, but that doesn't seem to be the issue.
[17:41:07] <tjc> ecr: I guess you could always close it and make a new pull request? I hate to suggest that, but bors seems to be stuck considering your PR "discussing"
[17:41:47] <ecr> It's worth a shot.
[17:41:59] <tjc> if you open a new one, I'll r+ it
[17:44:10] *** Joins: lkuper (lkuper@moz-D862222C.dhcp-bl.indiana.edu)
[17:44:39] *** Joins: sk (sk@61A494B3.BA40E8A.AAC02D62.IP)
[17:45:49] <ecr> tjc: https://github.com/mozilla/rust/pull/8954 althought cmr's r+ is still on the commit
[17:46:13] *** Quits: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP) (Quit: leaving)
[17:46:21] *** Joins: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP)
[17:46:30] <ecr> ah! maybe that's the issue. cmr's r+ is on the first commit, not the second.
[17:46:45] <tjc> ecr: ah, sometimes that happens when you rebase
[17:47:05] <tjc> ecr: well, I r+'ed the first commit too :-)
[17:47:13] <tjc> ping me if it doesn't show up in the bors queue in 5 minutes or so
[17:47:27] *** Joins: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP)
[17:47:35] <ecr> tjc: thanks. hopefully it's all resolved now
[17:47:41] *** Joins: jmgrosen (jmgrosen@moz-A3814C08.sd.sd.cox.net)
[17:48:17] *** Quits: jmgrosen (jmgrosen@moz-A3814C08.sd.sd.cox.net) (Quit: jmgrosen)
[17:49:19] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[17:50:35] *** Quits: dave1629 (dave@F1886EC7.A9DA0237.DDE5D3F6.IP) (Quit: dave1629)
[17:51:20] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Ping timeout)
[17:52:29] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[17:55:09] *** Joins: jmgrosen (jmgrosen@moz-A3814C08.sd.sd.cox.net)
[17:55:21] *** Joins: jclements (jclements@moz-6636E151.wireless.calpoly.edu)
[17:55:55] <engla> ecr: github doesn't show the commit list in git's order..
[17:56:10] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[17:56:10] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/F_8lgQ
[17:56:10] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[17:56:21] <ecr> tjc: it's in the queue now :)
[17:56:28] <tjc> ecr: great!
[17:57:02] *** Quits: josh (josh@moz-5CEF2838.mpls.qwest.net) (Ping timeout)
[17:57:05] <ecr> engla: Doesn't it just show commits in chronological order?
[17:57:18] <ecr> In which case, rebase will likely mess that all up.
[17:58:08] *** Joins: josh (josh@moz-60CFC9FE.mpls.qwest.net)
[17:58:21] *** Quits: pepper_chico (pepper_chi@14AC4DFD.704EE6B0.E4090502.IP) (Quit: Textual IRC Client: www.textualapp.com)
[17:58:30] <ecr> hm, "~std::iterator::Iterator<u8>:Send does not implement any method in scope named `take`" (note: I already have `use std::iterator::Iterator`). ideas?
[17:59:38] <glyc> Hello All, I'm having iterating over a mutable tree. Could someone assist me in avoiding the double mutable borrow check?  http://mibpaste.com/yhvTqX 
[17:59:55] <glyc> *having trouble* iterating over a mutable tree
[18:01:20] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[18:01:21] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/U3SpPw
[18:01:21] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[18:01:21] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[18:01:21] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/eMI7qg
[18:01:21] <ghrust> 13rust/06auto 14319b883 15Steven Fackler: Implement BufReader
[18:01:21] <ghrust> 13rust/06auto 147ee90a0 15bors: auto merge of #8934 : sfackler/rust/bufreader, r=brson
[18:01:21] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[18:02:04] <glyc> I'm just mystified about how one is supposed to iterate over a mutable collection in Rust.
[18:02:39] <glyc> Perhaps the collection isn't allowed to own at all?
[18:02:40] *** Quits: echristo (echristo@60A74940.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[18:02:53] <engla> ecr: right.. it should show them in parent-child order so that the tip of the branch is the most recent. date is just metadata
[18:02:59] <glyc> so the collection must contain a set of mutable borrowed pointers?
[18:03:13] <nmatsakis> glyc: you can't have multiple pointers to the same data, so you're not permitted to give away self while you're iterating over its contents
[18:03:23] <engla> ecr: ~Iterator does not implement the Iterator trait
[18:03:31] <nmatsakis> glyc: best fix is to separate out the data you want to give away from the data you are iterating over
[18:03:32] <engla> ecr: oh wait, that's not it
[18:03:49] <nmatsakis> glyc: e.g., separate out the fields you want to update in the callback so you can do (s.func)(&mut self.data, ...)
[18:04:07] <engla> ecr: you can't call the adaptors that take 'self' by value, when you have ~Iterator  trait object. You can do that if you wrap ~Iterator in a newtype though.. not sure how to best resolve it
[18:04:25] <glyc> nmatsakis: hmm, how would this separation work?
[18:04:29] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[18:04:32] <ecr> engla: hm. I guess I'll just make it a type param then
[18:05:24] <nmatsakis> glyc: well, in your example code, you might change the callback from &fn(mut Tree, ...) to &fn(&mut int, ...)
[18:05:38] <nmatsakis> glyc: and then call it "(s.func)(&mut self.last, ...)"
[18:05:45] *** Joins: doomlord__ (doomlod@moz-13E69BC8.range86-180.btcentralplus.com)
[18:05:50] *** Quits: doomlord__ (doomlod@moz-13E69BC8.range86-180.btcentralplus.com) (Client exited)
[18:06:55] <glyc> nmatsakis: okay, I'll experiment with that. Thank you.
[18:07:57] *** Quits: jfbk (textual@moz-EEA9CFB3.nyc.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[18:08:30] <ecr> gah, I need a lazy chunking iterator
[18:09:59] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[18:12:18] *** Quits: jmgrosen (jmgrosen@moz-A3814C08.sd.sd.cox.net) (Quit: jmgrosen)
[18:13:29] *** Quits: pnkfelix|rcirc (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: rcirc on GNU Emacs 24.2.1)
[18:14:06] <ecr> I'm really not a fan of iterator adaptors taking self by value.
[18:14:37] *** Joins: lenstr (lenstr@E0E80B8D.ED45D46B.DFEAE789.IP)
[18:15:01] <kimundi> ecr: What's the problem wit that?
[18:15:53] <engla> Ok. I think it's possible to make this iterator adaptor:  ByRef<I> { iter: &mut I }  impl Iterator for ByRef {}   trait Iterator { fn by_ref(&mut self) -> ByRef<Self> { ByRef{iter: self }} }
[18:15:53] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[18:16:10] <engla> oh and a 'self
[18:16:19] <ecr> It makes it very difficult to do something like 1) take 10 things from the iterator and put them in a vector, 2) do something with the vector, 3) take 10 more things from the iterator, etc. Since .take() will consume the iterator, you can't take more from it later
[18:16:32] *** Joins: dave1629 (dave@F1886EC7.A9DA0237.DDE5D3F6.IP)
[18:16:49] <engla> ecr: if adaptors took the iterator by reference, then you can't return that package
[18:17:30] <ecr> Why can't you just give a lifetime guarantee that the wrapped iterator outlives the wrapper?
[18:17:40] <sigma> say I have an enum {a,b,c,d,e,f}, is there a way to match against anything except f?
[18:17:47] *** Quits: victorporof (victorporo@9D964D4D.36D485C.2B3D3D4.IP) (Quit: victorporof)
[18:18:04] <Ms2ger> match (x) { f => {}, _ => {} }
[18:19:26] <sigma> hmm, I do want to match against the others later, I just need to handle an edge case first
[18:19:56] <ecr> You can just match twice in that case
[18:20:16] <ecr> match (x) { f => { handle edge case }, _ => {} /* do nothing otherwise */
[18:20:19] <ecr> other stuff
[18:20:36] <ecr> match (x) { f => {} /* already done */, other matches }
[18:20:40] <kimundi> ecr: the problem with taking a reference is that you could no longer transfer ownership to the adapters.
[18:20:53] <ecr> kimundi: yes, that's the point
[18:21:07] <ecr> the adaptors don't need ownership. they just need control while they exist.
[18:21:07] <engla> taking by value should be more generic
[18:21:23] <engla> since you can take a wrapped reference
[18:21:46] <engla> this is something I wonder about when it comes to Reader/Writer too
[18:21:51] <glyc> I'm curious why one cannot make more than one mutable borrow?
[18:22:06] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[18:22:12] <ecr> engla: actually, that's what I'm working on right now. Trying to make an iterator based IO system
[18:22:14] <kimundi> ecr: but you couldn't "take 10 things from the iterator" because for taking you need ownership
[18:22:35] <engla> nice ecr. I've tested some things around that
[18:22:54] <nmatsakis> glyc: for memory safety, we need to preserve the idea that when you are reading from a pointer, you can be sure others aren't changing it under your feet
[18:23:03] <nmatsakis> glyc: if you had more than one mutable pointer to the same memory, you would not know that
[18:23:05] <ecr> kimundi: only because the current take method uses self by value. you only need &mut for take though because it's just a loop around next()
[18:23:19] <engla> kimundi: no. You only need ownership to make the "take 10" iterator an independent value
[18:23:33] <nmatsakis> glyc: note that you can use garbage-collected pointers (@T) to make a lot of these challenges go away, if that's convenient
[18:23:36] *** Joins: victorporof (victorporo@9D964D4D.36D485C.2B3D3D4.IP)
[18:23:45] <engla> ecr: Readers are the same way. You can give a Reader to an iterator, or you can give it a &mut Reader
[18:24:10] <ecr> engla: in the current interface?
[18:24:12] <engla> ecr: did you write the encodings crate?
[18:24:15] <glyc> nmatsakis: it just seems like iterating over a list and changing each element in the list is very common
[18:24:30] <engla> ecr: there is no current interface for iterators for reader
[18:24:39] <ecr> engla: no, I wrote std::rt::io::{tcp, udp} and std::rt::uv::uvio
[18:24:48] <engla> aha
[18:24:52] <glyc> nmatsakis: so the iterator is one borrow, and the mutator is the second borrw, 
[18:25:00] <glyc> so how does the work ever get done?
[18:25:05] <engla> ecr: here is an iterator that just wraps reader.read_bytes()   https://github.com/mozilla/rust/pull/8935
[18:25:06] *** Quits: lenstr (lenstr@E0E80B8D.ED45D46B.DFEAE789.IP) (Client exited)
[18:25:12] <engla> it's the simplest possible start
[18:25:42] <nmatsakis> glyc: iterating over a list and changing the element you are iterating over is very easy;
[18:26:00] <nmatsakis> glyc: otherwise, if it's a vector, you can iterate using indices, in which case you are not creating pointers into the list;
[18:26:18] <nmatsakis> glyc: otherwise, there are more involved solutions if it comes to that, but it rarely does :)
[18:26:38] <engla> glyc: a .mut_iter() maybe?
[18:26:56] <glyc> engla: double borrow compile fail
[18:26:59] <ecr> engla: the idea I'm playing with is for the Reader trait to provide a method reader<'r>(&'r mut self, buf_size: uint) -> ReaderIterator<'r>, which prevents the socket from being used by others while the iterator exists. ReaderIterator then impl's Iterator<u8>
[18:27:29] <nmatsakis> glyc: were you unable to refactor as I suggested? usually the memory you are iterating over, and the memory you are mutating during iteration, are not the same
[18:27:37] <nmatsakis> glyc: or else you've got a very complex iteration pattern
[18:27:40] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Connection reset by peer)
[18:27:53] <engla> ecr: maybe that's the better model for Reader
[18:28:00] <ecr> Writer would provide writer(&mut self, buf_size: uint, input: Iterator<u8>), which will consume an iterator and write all it's contents to the socket
[18:28:01] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[18:28:01] *** ChanServ sets mode: +o tjc
[18:28:33] <glyc> nmatsakis: no, it wasn't clear to me how to refactor Tree, because last will also need to be updated
[18:28:38] <engla> ecr: well you should definitely not use ~Iterator for this since the virtual calls will cost a lot for a byte iterator
[18:28:51] <glyc> even though (last) is not passed into the callback
[18:28:52] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[18:29:31] <ecr> engla: that's what I was thinking. I have it as a type param on Writer now (so it's actually Writer<I: Iterator<u8>>).
[18:30:18] *** Quits: dave1629 (dave@F1886EC7.A9DA0237.DDE5D3F6.IP) (Quit: dave1629)
[18:30:23] <ecr> engla: I was also thinking about another trait that allows reading and writing to the same socket (since that's forbidden otherwise).
[18:31:15] <ecr> And there's a Listener trait which consumes itself to start the listener and provides an Acceptor, which gives you an iterator over incoming connections.
[18:31:17] <engla> true
[18:31:35] <nmatsakis> glyc: how representative is that snippet you sent of your actual problem?
[18:31:35] <engla> so it is actually a pretty big remodeling of the API?
[18:31:56] <cmr> We are out of Z flags.
[18:31:59] <engla> ecr: I guess the Iterator type param can be directly on the writer method. it's a bit unwieldy otherwise
[18:32:11] <ecr> From there, you can make iterator variants which provide a SocketControl (or FileControl) handle to the for loop.
[18:32:20] <glyc> nmatsakis: that is the actual problem
[18:32:23] *** Joins: dave1629 (dave@F1886EC7.A9DA0237.DDE5D3F6.IP)
[18:32:25] <ecr> engla: good point.
[18:32:52] <erickt> SimonSapin: are you referring to https://github.com/mozilla/rust/issues/8888?
[18:32:55] <ecr> yeah, it'd be a pretty significant overhaul of the API. I'm trying to get a coherent design together for people to mull over before I try to actually implement it.
[18:33:05] <cmr> r? https://github.com/mozilla/rust/pull/8955
[18:33:13] <glyc> nmatsakis: you are given a tree structure, and state updates flow both up and down the tree
[18:33:21] <engla> sounds good, should I cancel the mini PR I linked you ecr?
[18:33:28] <engla> that one adds the byte iterator
[18:33:29] <nmatsakis> glyc: well anyway here is a version that compiles https://gist.github.com/nikomatsakis/6427775
[18:33:36] *** Quits: fabiand (fabiand@moz-E2579CED.adsl.alicedsl.de) (Quit: Verlassend)
[18:33:39] <brson> ecr: can a writer based on an iterator possibly be fast? the underlying model is to blast an entire buffer at a time
[18:33:42] <ecr> nah, go ahead and keep it for now. I have no idea when this will be done.
[18:33:58] <SimonSapin> erickt: yes, thanks
[18:34:01] <nmatsakis> glyc: if you don't need additional fields beyond `last`, you wouldn't necessarily need the TreeData struct
[18:34:03] <glyc> nmatsakis: thank you, I will need a moment to study that.
[18:34:37] <ecr> brson: writer takes a buf_size and consumes an iterator which it uses to fill a buffer of buf_size, blast it out over the socket, and repeats until the iterator is exhausted.
[18:35:05] <ecr> so you can tune performance by the buf_size parameter
[18:35:23] *** Joins: aeqwa_ (aeqwa@moz-717CB772.dsl.tropolys.de)
[18:35:30] *** Joins: jfbk (textual@moz-EEA9CFB3.nyc.res.rr.com)
[18:35:54] <brson> ecr: but it does have to iterate buf_size times
[18:36:14] <engla> iterators can compile to perfect code in some instances (perfect is memcpy)
[18:36:30] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[18:36:47] *** Quits: aeqwa (aeqwa@moz-BDC78F2.dsl.tropolys.de) (Ping timeout)
[18:36:49] <bblum> 'perfect code' is something of an oxymoron
[18:37:01] <bjz_> :)
[18:37:04] <ecr> brson: that's true.
[18:37:22] <ecr> brson: but you'd need to do that to fill the buffer anyway
[18:37:39] <ecr> the only difference is you'd do it outside the write call
[18:38:41] *** Joins: echristo (echristo@DCF57675.D6CCE4AE.77834EAA.IP)
[18:39:25] <ecr> we could make a variant that takes a ChunkIter as well (and no buf_size param) so only one next() call per write() call
[18:39:54] <glyc> nmatsakis: thank you very much. I'm still foggy on why making TreeData avoided the double borrow... isn't there still a mutable borrow to a Tree, and a mutable borrow to a sub-componet of that Tree?
[18:39:57] <ecr> and we can always keep around the only buffer style write for people who think they can beat the optimizer
[18:40:05] *** Joins: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP)
[18:40:20] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[18:41:45] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[18:42:41] *** Quits: jfbk (textual@moz-EEA9CFB3.nyc.res.rr.com) (Quit: )
[18:42:42] *** Quits: threecreepio (jdp@moz-71E164C9.cust.bredbandsbolaget.se) (Quit: threecreepio)
[18:42:45] *** Joins: jfbk (jfbk@moz-EEA9CFB3.nyc.res.rr.com)
[18:43:00] <ecr> as for error handling, I'd like to make a .trapping() iterator adaptor that wraps the next() calls in a trap for a condition. otherwise you need to keep restarting the for loop
[18:43:31] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[18:43:40] <nmatsakis> glyc: this way, there is a pointer to self.children, and a pointer to self.data,
[18:43:48] <nmatsakis> glyc: but those are two non-overlapping paths
[18:43:57] <nmatsakis> glyc: the other way, there was a pointer to self.children, and a pointer to self,
[18:44:00] <nmatsakis> glyc: which are overlapping
[18:44:09] *** Quits: dave1629 (dave@F1886EC7.A9DA0237.DDE5D3F6.IP) (Quit: dave1629)
[18:44:21] <nmatsakis> glyc: in other words, from the second pointer, you could reach the first pointer
[18:44:54] <ecr> also, a lazy chunking iterator would be nice. (take an iterator and chunk them into n-sized vectors) that would avoid the problem I'm having with take using self by value
[18:45:40] <engla> ecr: eridius wrote one but it didn't merge
[18:46:10] <ecr> engla: the lazy chunking or the condition trapping?
[18:46:31] <engla> lazy chunking
[18:46:45] <ecr> hm. maybe I'll give it a shot then.
[18:47:00] <engla> is condition trapping adaptor the right thing? Maybe just have a variant of condition resolution that injects an element or skips an element?
[18:47:06] <glyc> nmatsakis: okay, that makes a ton of sense. The test is for overlapping _paths_.  Got it.
[18:47:53] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[18:48:01] <glyc> nmatsakis: Thank you!
[18:48:32] <ecr> engla: as an adaptor you have the option of stopping the iterator (return None) or providing a different value instead. you can pair it with a filter to skip elements with errors by using a flag value, Either, or Option<Option<X>>
[18:49:26] <engla> the iterator could refine the underlying condition instead
[18:50:22] <ecr> engla: the handler can reraise the condition, or raise another, which could either be handled by a trap farther down the line of the iterator, by a trap wrapping the for loop, or fail the task
[18:51:04] <ecr> I think an adaptor gives you maximum flexibility, but I'm open to other ideas.
[18:52:09] <engla> ok what I mean is that in this example, the condition handling is all up to .read_bytes()   https://github.com/mozilla/rust/pull/8935/files#L0R357
[18:52:29] <engla> but since that interacts with the iteration protocol, maybe the iterator should be responsible to refine the condition
[18:52:33] *** Joins: austincheney (quassel@8276C73B.985A737F.603BFF2.IP)
[18:53:24] <ecr> how so?
[18:53:54] <engla> with a .trapping() adaptor you have the premise that the iterator is just a wrapper for an underlying function
[18:54:08] <engla> and the user of the iterator has to basically know its implementation
[18:54:30] *** Joins: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca)
[18:54:50] <ecr> well, it only has to know the conditions the underlying iterator could raise
[18:55:03] <ecr> and the kind of values it could return
[18:55:09] <ecr> which are both public
[18:55:12] *** Joins: threecreepio (jdp@moz-71E164C9.cust.bredbandsbolaget.se)
[18:55:51] <ecr> it's equivalent to using loop {} to imitate a for loop, but wrapping each .next() in a trap()
[18:56:09] <ecr> which is what you would need to do without an adaptor
[18:56:21] <ecr> if you wanted to handle a condition on each read attempt
[18:56:55] <ecr> and that's going to prevent you from using further iterator adaptors
[18:57:04] <engla> maybe it's better to not refine and introduce more condition types
[18:57:37] <engla> but it seems more consistent to use    byte_iter_err::cond.trap(|_| Continue).inside {
[18:57:51] <engla> writer(...    reader.bytes())  }
[18:58:16] <engla> or reader.bytes().trapping(|_| ...)
[18:58:44] <ecr> reader.bytes().trapping(|_| ..) is what I want
[18:59:00] <ecr> the first requires you to restart the loop when something goes wrong
[18:59:08] <engla> no it doesn't
[18:59:26] <engla> because it handles the byte iterator's refined condition which provides a resolution Continue
[18:59:55] <ecr> ok, but how will it differentiate between the IoError raised by read and the IoError raised by write?
[19:00:31] <engla> I think that's easily done inside .next()
[19:01:01] <engla> the condition refining things in .next() sound like they won't exactly increase performance though
[19:01:54] <ecr> that's going to require having two variants of read and write correct? one that refines conditions and one that ignores them?
[19:02:44] <engla> I don't see why that would be
[19:03:06] <ecr> maybe I'm confused about which .next() you're doing this in then
[19:03:19] <engla> ByteIterator
[19:04:45] <ecr> ah, well if you don't care about conditions and just want to fail the task when something goes wrong, you won't want to pay for the condition refining, right? so you'll need two variants that impl ByteIterator
[19:05:14] <engla> now I understand
[19:06:23] <cmr> Why is the signature of the entry point the way it is?
[19:06:27] *** Joins: Uther (Instantbir@moz-1B244B05.hfc.dyn.abo.bbox.fr)
[19:06:53] <cmr> Seems a bit weird to *require* the entry point to have a specific signature.
[19:07:16] <ecr> cmr: you mean main()?
[19:07:16] *** Quits: igl (igl@moz-8182AB55.adsl.alicedsl.de) (Connection reset by peer)
[19:07:51] <cmr> ecr: No, #[start] or #[lang="start"]
[19:08:01] <ecr> oh. no idea then.
[19:08:02] <engla> ecr: performance-wise I have no idea. In general I think the iterator needs to provide the appropriate conditions to continue
[19:08:20] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[19:08:20] <engla> ecr: but if the implementation is so slow it can't be used then that's not an option
[19:08:40] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[19:08:40] *** ChanServ sets mode: +o tjc
[19:08:43] <kimundi> Reading the mailing list right now... Why exactly are z-flags stored in an uint?
[19:09:01] <cmr> kimundi: probably old code, easy to do.
[19:09:24] *** Joins: igl (igl@moz-54314CA5.adsl.alicedsl.de)
[19:09:40] <ecr> engla: yep, it's a design trade off. I'm aiming mostly for performance and orthogonality, which will allow people to build what they want rather than be stuck with what some intern chose years ago.
[19:10:40] *** Joins: maik (maik@moz-BD9DE65B.dip0.t-ipconnect.de)
[19:11:39] <engla> sounds good
[19:11:46] *** mihneadb is now known as mihneadb|lunch
[19:12:05] <engla> refining conditions is definitely adding more coupling
[19:12:18] <engla> but not doing it is a leaking abstraction
[19:14:04] <ecr> Well it's the same condition handling you would use to wrap a read call, so I would say it's not adding any leaks that weren't already there.
[19:14:47] <ecr> But I could be missing something I guess
[19:15:20] <engla> almost all iterators return None ifinitely after the first None
[19:15:35] <engla> but conditions can turn these into start-stop-start-stop iterators
[19:15:43] *** Joins: dave1629 (dave@F1886EC7.A9DA0237.DDE5D3F6.IP)
[19:16:06] <engla> now.. the docs now say there is no guarantee that the former holds so it's ok
[19:16:33] *** Quits: dave1629 (dave@F1886EC7.A9DA0237.DDE5D3F6.IP) (Quit: dave1629)
[19:17:00] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[19:17:00] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/eMI7qg
[19:17:00] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[19:19:06] <ecr> well the condition handler will still have to provide Some for the iterator to continue, no?
[19:20:24] *** Joins: jmgrosen (jmgrosen@moz-A3814C08.sd.sd.cox.net)
[19:21:13] <engla> some value you mean?
[19:21:19] <ecr> right
[19:21:45] <ecr> it could generate None to signal the iterator should stop I guess
[19:22:18] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[19:22:18] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/7oFH5w
[19:22:18] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[19:22:19] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[19:22:19] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/oXJiAQ
[19:22:19] <ghrust> 13rust/06auto 14506f69a 15Huon Wilson: Implement support for indicating the stability of items....
[19:22:19] <ghrust> 13rust/06auto 14b4ff0bc 15bors: auto merge of #8921 : huonw/rust/stability, r=brson...
[19:22:19] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[19:22:20] <ecr> (or some other values which will impact the behavior of read and are documented accordingly)
[19:23:01] <engla> yeah. read() just returns None on handled conditions atm
[19:23:50] <engla> acrichto: PR 8942, why do the docs say you need to use `"\\\\{"` to escape, but the test uses "\\{"?
[19:24:36] <acrichto> engla: yeah I commented saying that I thought it needed to change
[19:25:55] *** Parts: maik (maik@moz-BD9DE65B.dip0.t-ipconnect.de) ()
[19:26:07] <engla> I don't see that comment
[19:26:13] <engla> maybe I should comment on my own
[19:26:38] <engla> I see it now
[19:26:48] <engla> excuse me.. . . bye
[19:26:52] * engla hides
[19:28:25] *** Quits: miza (miza@moz-4DD51325.home.otenet.gr) (Input/output error)
[19:29:05] *** Joins: dave1629 (dave@F1886EC7.A9DA0237.DDE5D3F6.IP)
[19:29:10] <ecr> huh. .collect() is going to use everything in an iterator, but it only takes a reference.
[19:29:27] <ecr> if anything should take iterators by value, it's that in my mind
[19:29:36] <acrichto> engla: although you're right, looks like I need to re-comment again, feel free to though b/c it'll be till tonight before I can get to it
[19:31:32] <engla> ecr: the methods that only consume but don't make a new iterator take by &mut self. For example .fold()
[19:32:13] <ecr> engla: that seems backwards to me.
[19:33:53] <engla> `&mut self` can be used in more situations than `self`
[19:34:03] <engla> but it needs explicit &mut on rvalues
[19:34:29] <engla> rusti: let mut v = ~[]; v.extend(&mut range(0i, 10)); v
[19:34:30] -rusti- ~[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[19:35:21] *** ozten is now known as ozten|afk
[19:36:49] <kmc> is there a way to have a function called after annihilate() for a particular task runs?  or a function called at the very end of program exit, after everything Rust-y is cleaned up?
[19:37:31] <jdm> kmc: libc::atexit?
[19:37:40] * jdm has no idea if that works
[19:38:08] <kmc> heh, could work
[19:40:11] <kimundi> 'libc' and 'task' doesn't sound like it mixes well :P
[19:40:30] <brson> kmc: tasks do have an on_exit event, but it's not exposed in the public API. if you construct a task manually you can use it. there are probably examples in rt/mod.rs. what are you trying to do?
[19:40:38] <ecr> it screams "Abandon all hope, ye who enter here"
[19:41:57] <kmc> brson: I need to shut down GLFW only after all DrawTargets (which are in managed data) have been destroyed
[19:42:06] <kmc> maybe I can shove the cleanup at the end of start()...
[19:43:18] *** Joins: five (five@9500BE4B.C4AAC3ED.10BB00EE.IP)
[19:44:08] *** Quits: five (five@9500BE4B.C4AAC3ED.10BB00EE.IP) (Connection reset by peer)
[19:45:23] *** Quits: jmgrosen (jmgrosen@moz-A3814C08.sd.sd.cox.net) (Quit: jmgrosen)
[19:50:05] *** Joins: jmgrosen (jmgrosen@moz-A3814C08.sd.sd.cox.net)
[19:51:06] <brson> kmc: DrawTargets could also hold a reference count to know when to call shutdown, or we could add a gc() function that runs the gc, or DrawTargets could not by cyclic and/or use the Rc type
[19:52:05] <kmc> yeah
[19:52:09] <kmc> these are bigger changes though
[19:52:28] <kmc> but I agree, it would be much better if we refcount everything that depends on OpenGL being initialized
[19:52:28] *** Quits: victorporof (victorporo@9D964D4D.36D485C.2B3D3D4.IP) (Quit: victorporof)
[19:53:12] <brson> it's a goal to not use the GC in the compositor anyway
[19:55:12] *** Joins: five (five@B112EA23.C4AAC3ED.10BB00EE.IP)
[19:55:20] <lbergstrom> kmc: maybe a dumb question, but if we're not planning to call glfwInit() again, can't you just skip glfwTerminate() since the process is being torn down anyway?
[19:56:24] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[19:56:25] *** Joins: jgilbert (jgilbert@moz-7B0110AD.mv.mozilla.com)
[19:57:19] *** Quits: josh (josh@moz-60CFC9FE.mpls.qwest.net) (Quit: josh)
[19:57:56] <kmc> yeah possibly
[19:58:07] <kmc> I don't know what kind of trouble that might cause, though
[19:59:20] *** Quits: five (five@B112EA23.C4AAC3ED.10BB00EE.IP) (Ping timeout)
[20:00:11] *** Quits: fyolnish_ (fyolnish@moz-1C9C8043.uqwimax.jp) (Client exited)
[20:00:17] *** Quits: nsf (nsf@moz-EEF3238A.convex.ru) (Quit: WeeChat 0.4.1)
[20:04:00] *** Quits: jfbk (jfbk@moz-EEA9CFB3.nyc.res.rr.com) (Quit: )
[20:04:04] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[20:05:10] *** mihneadb|lunch is now known as mihneadb
[20:07:22] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: zzzzzzzzzz)
[20:12:52] *** Joins: mihneadb_ (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net)
[20:12:53] *** Quits: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net) (Connection reset by peer)
[20:13:29] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[20:13:42] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[20:14:35] *** Joins: five (five@B112EA23.C4AAC3ED.10BB00EE.IP)
[20:15:03] *** mihneadb_ is now known as mihneadb
[20:16:02] *** Quits: Kruppe (user@moz-4DDA8AB8.uwaterloo.ca) (Ping timeout)
[20:16:05] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[20:16:10] *** Joins: Chef (Chef@moz-4C317041.dsl.teksavvy.com)
[20:18:52] *** Quits: five (five@B112EA23.C4AAC3ED.10BB00EE.IP) (Connection reset by peer)
[20:20:18] *** Joins: sebcrozet (sebcrozet@moz-6DA639AF.w80-13.abo.wanadoo.fr)
[20:20:25] *** Joins: eatkinson (eatkinson@moz-2AAF848C.airbears.berkeley.edu)
[20:21:16] *** Joins: five (five@B112EA23.C4AAC3ED.10BB00EE.IP)
[20:21:41] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[20:21:45] *** Joins: TheDust (TheDust@moz-8C2076C2.upc-d.chello.nl)
[20:22:06] *** Joins: _Y_ (Mibbit@moz-C68B11C3.dynamic.isp.telekom.rs)
[20:22:14] <_Y_> hi, rusters :D
[20:22:58] *** Quits: five (five@B112EA23.C4AAC3ED.10BB00EE.IP) (Connection reset by peer)
[20:23:16] *** Quits: Chef (Chef@moz-4C317041.dsl.teksavvy.com) (Quit: WeeChat 0.4.0)
[20:23:29] <_Y_> I have a question about Str
[20:25:22] *** Quits: threecreepio (jdp@moz-71E164C9.cust.bredbandsbolaget.se) (Quit: threecreepio)
[20:25:26] <Ms2ger> We'll only able to answer if you ask it
[20:26:10] <_Y_> whoops, ok, is there a way to cast Str as Reader Util
[20:26:23] <_Y_> and use it's method to read char?
[20:26:47] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[20:26:47] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/oXJiAQ
[20:26:47] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[20:27:44] *** Joins: jviereck (Adium@moz-58A87BA7.dip0.t-ipconnect.de)
[20:28:17] <_Y_> to be honest it's not the read char, as so much as being able to treat them uniformily
[20:31:53] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[20:31:54] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/UZor4A
[20:31:54] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[20:31:54] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[20:31:54] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/sc3F1g
[20:31:54] <ghrust> 13rust/06auto 14aeb2f88 15Alex Crichton: Raise the file descriptor limits when running compiletest...
[20:31:54] <ghrust> 13rust/06auto 142b1d61f 15bors: auto merge of #8943 : alexcrichton/rust/issue-8904, r=brson...
[20:31:55] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[20:33:30] *** Joins: sp3d (a@moz-6F12212B.fidnet.com)
[20:33:46] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[20:33:53] *** Quits: jmgrosen (jmgrosen@moz-A3814C08.sd.sd.cox.net) (Quit: jmgrosen)
[20:34:49] <strcat> rusti: use std::cell::Cell; let x = @mut Cell::new(5); x
[20:34:50] -rusti- @mut std::cell::Cell<int>{value: Some(5)}
[20:34:52] <kimundi> _Y_: Hm. Str is a trait that the types &str, @str and ~str implement. You want a way to get some kind of StrReader from that?
[20:35:03] <strcat> rusti: use std::cell::Cell; let x = @mut Cell::new(5); do x.take {}
[20:35:03] -rusti- <anon>:5:57: 5:69 error: this function takes 0 parameters but 1 parameter was supplied (including the closure passed by the `do` keyword)
[20:35:04] -rusti- <anon>:5          use std::cell::Cell; let x = @mut Cell::new(5); do x.take {}
[20:35:04] -rusti-                                                                   ^~~~~~~~~~~~
[20:35:04] -rusti- error: aborting due to previous error
[20:35:05] -rusti- application terminated with error code 101
[20:36:28] <_Y_> essentially yes, I want to be able to 'cast' a str into a ReaderUtil like interface
[20:38:13] <kimundi> Hm, if I could just find where Reader and ReaderUtile are defined...
[20:38:42] <_Y_> io
[20:39:11] <_Y_> it's standard crate, io module, iirc
[20:39:26] <_Y_> pardon std crate
[20:39:28] *** Quits: jviereck (Adium@moz-58A87BA7.dip0.t-ipconnect.de) (Quit: Leaving.)
[20:39:52] *** Quits: Blub\w (wry@moz-3ADAE0B1.wireless.dyn.drei.com) (Quit: bbad)
[20:40:42] <kimundi> Btw, you want some kind of adapter for strings that implements 'Reader'. ReaderUtil is just an extension trait for Reader
[20:41:40] <engla> in new IO you can use MemReader
[20:42:18] <sfackler> in old IO there's a MemReader in libextra iirc
[20:42:24] <_Y_> MemReader?
[20:42:30] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[20:42:37] <engla> there's a BytesReader in std::io
[20:42:40] <sfackler> it reads out of a ~[u8]
[20:42:54] <engla> _Y_: A Reader impl backed by a byte buffer
[20:43:55] *** Joins: jmgrosen (jmgrosen@moz-A3814C08.sd.sd.cox.net)
[20:44:01] *** Joins: threecreepio (jdp@moz-71E164C9.cust.bredbandsbolaget.se)
[20:44:50] <_Y_> crate extra?
[20:44:56] <_Y_> has MemReader?
[20:45:47] <sfackler> _Y_: http://static.rust-lang.org/doc/extra/io_util.html
[20:45:53] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Quit: Gone to save the world!)
[20:46:47] *** Quits: robarnold (rob@BD56354E.DB510C09.6E370BFC.IP) (Ping timeout)
[20:47:12] <engla> _Y_: there is an old io module (std::io) and the next IO which is WIP  (std::rt:io)
[20:47:22] <engla> they each have their version of this
[20:47:29] *** Quits: jmgrosen (jmgrosen@moz-A3814C08.sd.sd.cox.net) (Quit: jmgrosen)
[20:47:39] <engla> for the first one it has std::io::with_str_reader
[20:47:45] <engla> which is a wrapper for BytesReader
[20:48:30] <engla> rusti: do std::io::with_str_reader("hi there") |r| { println(r.read_line()) }
[20:48:30] -rusti- hi there
[20:48:31] -rusti- ()
[20:48:40] *** Quits: TheDust (TheDust@moz-8C2076C2.upc-d.chello.nl) (Quit: )
[20:50:00] *** Joins: carllerche (carllerche@moz-CDE5367B.dsl.static.sonic.net)
[20:50:02] <_Y_> so i take str slice and turn it into a byteReader, which I turn into ReaderUtil?
[20:50:46] *** Quits: dave1629 (dave@F1886EC7.A9DA0237.DDE5D3F6.IP) (Quit: dave1629)
[20:50:59] <_Y_> what is StrSlice? How do I get it, from a string?
[20:51:20] <engla> ReaderUtil and StrSlice are traits, not concrete types
[20:51:46] <engla> StrSlice has all the methods for &str and the only type to impl it is &str
[20:51:57] *** Joins: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net)
[20:52:16] <engla> and ReaderUtil is just more methods for everything that impl Reader
[20:52:26] <engla> so they are extension methods
[20:54:40] *** Joins: azakai (alon@moz-BBE3ABD.mv.mozilla.com)
[20:54:54] *** Joins: robarnold (rob@BD56354E.DB510C09.6E370BFC.IP)
[20:56:12] <_Y_> i see
[20:56:19] <_Y_> but a question puzzles me
[20:57:06] <_Y_> the fn of with_str_reader takes a function that returns T, what is the T in your former example (the "hi there")
[20:58:03] <sfackler> it's whatever println returns (probably () )
[20:58:20] *** Quits: sigma (sigma@moz-B8E78D5.range86-136.btcentralplus.com) (Ping timeout)
[21:00:12] <_Y_> ty guys :)
[21:01:05] *** Joins: jstevans (Instantbir@7436E564.3C990DFD.DDE5D3F6.IP)
[21:02:18] <jstevans> I'm trying to build rust on Ubuntu Server 13, and it's hanging during make on "compile_and_link: x86_64-unknown-linux-gnu/stage0/lib/rustc/x86_64-unknown-linux-gnu/lib/librustc.so"
[21:02:23] <jstevans> Is that usual?
[21:02:42] *** Quits: Ms2ger (Ms2ger@B7B2FF50.C60A97A6.F9FB0584.IP) (Quit: nn)
[21:03:02] <mm> jstevans: is it actually hanging? that compilation step takes a while
[21:03:30] <jstevans> mm: Sorry, by "hanging" I simply meant it's been on it for >15 minutes. So this isn't abnormal?
[21:04:06] <mm> 15 minutes is a little long, but depending on how fast your computer is, it could still be working
[21:04:06] <jstevans> I'm an undergrad whose professor thought it would be cool to use Rust in the first OS course he's ever taught...
[21:04:07] <lkuper> jstevans: How much memory do you have on that machine?
[21:04:12] <sfackler> if it's swapping to disk, no. How much RAM do you have?
[21:04:19] <mm> jstevans: ah you're one of them ;)
[21:04:21] <jstevans> lkuper: It's an Azure Small instance, so 1.75GB
[21:04:31] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[21:04:31] *** ChanServ sets mode: +o tjc
[21:04:38] <benh> the readme suggests you want 1.8G to avoid swapping, iirc
[21:04:40] <sfackler> isn't that class using 0.7? There are precompiled versions on rust-lang.org
[21:04:56] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: Places to go, people to annoy)
[21:04:59] <lkuper> jstevans: You're probably going to be swapping, then.
[21:05:00] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[21:05:00] *** ChanServ sets mode: +o tjc
[21:05:09] <jstevans> benh + lkuper: getting started suggested 1.6GiB
[21:05:26] <jstevans> Regardless, what is swapping and is this an awful thing?
[21:05:44] <mm> jstevans: swapping to disk when you run out of RAM.  Given you're in an OS course, you'll surely learn what that is soon ;)
[21:05:46] <jstevans> mm: haha, yes. He linked all of us to the email exchange on rust-dev in class today
[21:06:01] <lkuper> jstevans: I think 1.75 cuts it close.  Swapping is when you can't have everything you need in main memory at once so you have to swap out to disk.
[21:06:16] <tjc> jstevans: it's an awful thing because it makes your computer awfully slow :-)
[21:06:27] <lkuper> jstevans: and if you have anything else running simultaneously, that won't help matters
[21:07:00] *** Joins: sigma (sigma@moz-B8E78D5.range86-136.btcentralplus.com)
[21:07:04] <jstevans> Ahhh, understood. I just spun up this instance for this class, so it shouldn't be running anything else
[21:07:25] <lkuper> jstevans: in any case, it will build eventually, it'll just take a while.  I've heard of people building Rust on a netbook with 1GB RAM and letting it run overnight.
[21:07:52] <jstevans> Oh, shoot. Should I expect multiple hours, then?
[21:08:05] <jstevans> I sped through everything up to this point in the past 45ish minutes, I think.
[21:08:08] <mm> jstevans: You should probably just use a precompiled version if you can
[21:08:15] <sfackler> jstevans: isn't the class using version 0.7? You should just be able to pull a binary off of rust-lang.org
[21:08:15] *** Quits: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP) (Quit: Lost terminal)
[21:08:41] <jstevans> Oh, huh. We were directed straight to the getting-started. I'll do that instead!
[21:08:49] <lkuper> I actually didn't know we had precompiled binaries
[21:09:05] <jstevans> Just to be clear: are the denizens of #rust going to get upset if OS students start showing up and asking dumb questions?
[21:09:10] <tjc> lkuper: Yeah, just for releases right now
[21:09:28] <tjc> jstevans: Rust is a new language, so it's still exciting to us to have anybody interested in what we're doing :-)
[21:09:43] <tjc> and every "dumb question" is a chance for us to improve our documentation
[21:10:20] <lkuper> jstevans: some people are going to complain that you're not running the latest git version, but simply tell them that you're using 0.7 for a class and they'll be sympathetic.  for the most part, people here are excited about the class existing
[21:10:22] *** Quits: Shaladdle (Shaladdle@moz-424BC304.hsd1.pa.comcast.net) (Connection reset by peer)
[21:10:28] *** Quits: azakai (alon@moz-BBE3ABD.mv.mozilla.com) (Quit: Ex-Chat)
[21:10:32] *** Joins: azakai (alon@moz-BBE3ABD.mv.mozilla.com)
[21:11:04] *** Joins: vodik (simon@moz-CBE4BB13.cable.teksavvy.com)
[21:11:54] <jstevans> That's awesome! Everyone I know in the class is just excited for a class that's finally NOT in C++ or Java, haha
[21:12:00] <lkuper> jstevans: :D
[21:12:18] *** ozten|afk is now known as ozten
[21:12:53] <tjc> jstevans: Heh. At one of the schools I attended, undergrads were complaining to the faculty that the intro course was taught in Scheme and when were they going to learn a language they could get a job using :-)
[21:13:00] <tjc> I prefer your classmates' attitude, though
[21:13:21] <lkuper> also, if anyone ever actually *is* upset at you in the channel to the point of violating the code of conduct (linked above in the topic), then alert the mods to it
[21:15:15] <mm> tjc: heh, Waterloo offered the choice between Scheme and Java -- pretty clearly segregated people from day 1 into the "get a job using" crowd and everyone else
[21:15:26] *** Joins: pepper_chico (pepper_chi@14AC4DFD.704EE6B0.E4090502.IP)
[21:15:56] *** Joins: SingingBoyo (Brandon@4DF3381A.51F4D838.4F048BDC.IP)
[21:15:57] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[21:16:47] *** Quits: eatkinson (eatkinson@moz-2AAF848C.airbears.berkeley.edu) (Quit: eatkinson)
[21:16:52] <jstevans> Sorry, I'm having trouble finding the snapshot on rust-lang.org
[21:19:13] *** Quits: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Ping timeout)
[21:19:19] <tjc> jstevans: http://static.rust-lang.org/dist/rust-0.7.tar.gz should work
[21:19:39] <tjc> mm: Heh, I can see that segregation as having potential good as well as bad aspects
[21:20:18] *** Joins: skoizza (Mibbit@moz-C3630477.hsd1.va.comcast.net)
[21:20:24] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[21:20:53] <mm> tjc: led to much trouble in 2nd year.  Half the class fell asleep in the "Look guys, recursion!".  The other half fell asleep in the "Look guys, objects!" sections
[21:21:21] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[21:21:21] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 142b1d61f to 14b4ff0bc: 02http://git.io/N3iJvQ
[21:21:21] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[21:21:24] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[21:21:25] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/NzZwsQ
[21:21:25] <ghrust> 13rust/06auto 14877e7f3 15Seo Sanghyeon: Correctly determine OS to xfail in cross build
[21:21:25] <ghrust> 13rust/06auto 14e8399dd 15bors: auto merge of #8950 : sanxiyn/rust/cross-xfail, r=brson
[21:21:25] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[21:21:25] <tjc> mm: Heh, yeah, if the two paths join up later, then I can see that either one group or the other would likely not be prepared
[21:21:30] <tjc> (or both)
[21:22:53] <mm> the Java versions have since been eliminated
[21:23:02] *** Quits: lmandel (lmandel@13F2CEC5.7672369.D8E68FF6.IP) (Quit: lmandel)
[21:24:12] <mm> So an M1.small EC2 instance is 1.7GiB of ram, that's too tight for Rust I guess?
[21:24:25] <tjc> mm: that's a little bit tight, yeah
[21:24:32] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[21:24:47] <mm> T1 Micro has no hope? :P 613 mb ram.
[21:25:01] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[21:25:06] <tjc> I remember at some point someone was able to build on a very old PC with maybe… 512 MB of RAM? not sure exactly
[21:25:11] <tjc> but that might have been an older version of Rust
[21:25:12] <mm> I'm going to publish a "Rust 0.7" AMI to the AWS marketplace
[21:29:04] <cmr> strcat: re: my comment on #8955, is there any way to configure the prolog before __morestack is called at all, or would that require an LLVM patch?
[21:29:15] <jstevans> Out of curiosity, there's no way to get around the Windows TCP problem in 0.7, right?
[21:29:33] <cmr> I don't see any good way to store the stack size somewhere *without* TLS
[21:30:00] <acrichto> cmr: btw I have comments about that, but I won't be able to write them up until tonight. I agree with strcat though that this should probably be implemented in a different manner
[21:30:54] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[21:31:20] <cmr> acrichto: what's the gist of it?
[21:31:20] <Luqman> acrichto: cmr the stuff in the prolog is very platform dependent and changing it requires rebuilding llvm each time
[21:31:47] <cmr> Luqman: surely it'd just be a platform the cross compiler would target?
[21:32:19] <acrichto> cmr: it's incredibly dangerous to turn of segmented stacks and you have to *really* know what you're doing. It's also not clear how this code would interact with libraries not compiled with the same flag etc
[21:32:37] <acrichto> Luqman: this wouldn't involve many LLVM changes right now
[21:32:40] <cmr> acrichto: Yes, but that's true of *all* code compiled under a specific runtime platform.
[21:32:51] <cmr> s/platform/profile/
[21:33:03] <acrichto> cmr: yeah and right now we only have 1 so it's not too bad
[21:33:13] <cmr> acrichto: Well I'm working on the others :)
[21:33:18] <acrichto> I'll try to articulte myself better soon
[21:33:22] <Luqman> acrichto: changes regarding what exactly?
[21:33:24] <acrichto> I really do want something like this though
[21:33:26] * cmr is patient
[21:33:36] <acrichto> Luqman: prologues to functions
[21:33:39] <acrichto> if at all
[21:34:11] <benh> oh hey, acrichto, you're in charge of the new format! etc, right?
[21:34:13] <Luqman> acrichto: sure, for instance you can already skip the segmented stack stuff with an attribute
[21:34:23] <acrichto> benh: I guess so yeah :)
[21:34:30] <acrichto> Luqman: indeed
[21:34:34] <acrichto> Luqman: I added that :)
[21:34:46] *** Quits: pepper_chico (pepper_chi@14AC4DFD.704EE6B0.E4090502.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[21:34:51] <Luqman> ah right :P
[21:35:06] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[21:35:16] <benh> acrichto: Is it by design that backslashes need to be escaped as \\\\?
[21:35:33] *** Quits: six600110 (six600110@moz-2FA48202.neo.res.rr.com) (Connection timed out)
[21:35:48] <acrichto> benh: yes and no, it is by design that \\ becomes a literal \, it is not by design that because the argument is a rust string literal then it then expands to four of them
[21:35:58] <acrichto> benh: basically it's working as is, but I didn't forsee how ugly that is
[21:36:02] <acrichto> and inconvenient
[21:36:59] <benh> Would it work to just pick another escaping mechanism, like double braces to get a literal brace?
[21:37:04] *** Quits: Palmik (palmik@moz-CC484FDD.tmcz.cz) (Quit: Lost terminal)
[21:37:12] <benh> Or are you set on \?
[21:37:19] <acrichto> I'd be more than willing to switch to another one
[21:37:21] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[21:37:24] *** Joins: six600110 (six600110@moz-2FA48202.neo.res.rr.com)
[21:37:34] <acrichto> {{ => { has problems though because with nested format functions you can legitimately have }} when you actually want two
[21:37:55] <acrichto> rusti: format!("{0, select, other{{0}}", "test")
[21:37:56] -rusti- <anon>:5:17: 5:41 error: cannot have an empty selector
[21:37:56] -rusti- <anon>:5          format!("{0, select, other{{0}}", "test")
[21:37:56] -rusti-                           ^~~~~~~~~~~~~~~~~~~~~~~~
[21:37:56] -rusti- error: aborting due to previous error
[21:37:56] -rusti- application terminated with error code 101
[21:38:08] <benh> I haven't entirely grokked the mechanism :)
[21:38:12] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: zzzzzzzzzz)
[21:38:26] <acrichto> rusti: format!("{0, select, other{{0}}}", "test")
[21:38:27] -rusti- ~"test"
[21:38:42] <myname> what
[21:39:10] <myname> what dies that actually do
[21:39:22] <myname> *does
[21:39:25] <acrichto> {0, select, ...} == perform the select function over the 0th argument
[21:39:33] <acrichto> other{...} means that if nothing else matches, execute this
[21:39:40] <acrichto> {0} says to just insert the 0th argument
[21:39:53] <acrichto> select is like a switch over strings
[21:40:16] <acrichto> rusti: format!("{0, select, a{you typed a} b{you typed b} other{you didn't type a or b}}", "a")
[21:40:16] -rusti- ~"you typed a"
[21:40:20] <acrichto> rusti: format!("{0, select, a{you typed a} b{you typed b} other{you didn't type a or b}}", "c")
[21:40:21] -rusti- ~"you didn\'t type a or b"
[21:40:26] <ecr> jstevans: what's the Windows TCP problem you're referring to?
[21:40:28] <SiegeLord> It's too ugly to mandate a space between the braces in the above usage cases?
[21:40:29] *** Joins: jdm (jdm@CAB30FBD.8F96AEA7.2D179A7D.IP)
[21:40:30] *** ChanServ sets mode: +o jdm
[21:40:55] <acrichto> SiegeLord: I would indeed consider it ugly, not sure if it's uglier than four backslashes though
[21:41:00] <jmgrosen> how should I handle a macro change that breaks stage0?
[21:41:11] <benh> I'm tempted to just suggest % as an escape character, since, hey, it was good enough for printf
[21:41:15] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[21:41:24] <acrichto> jmgrosen: with format! I've added debug2/error2/info2/fail2/etc b/c I couldn't think of a etter way
[21:41:26] <jstevans> ecr: https://github.com/mozilla/rust/issues/5892
[21:41:35] <sfackler> jmgrosen: duplicate everything that uses the macro with a #[cfg(stage0)] version
[21:41:37] <acrichto> benh: how so?
[21:41:44] <jmgrosen> thanks
[21:41:50] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[21:41:54] <sfackler> unless it's used _everywhere_
[21:41:57] <benh> %% for a literal % in printf, so why not %{ for a literal {, etc
[21:42:28] <acrichto> benh: not a bad idea... I'd be afraid of people getting confused though b/c % isn't used for formatting at all
[21:42:28] <jstevans> ecr: I have a similar problem to that in Win7 and 8 using Rust 0.7
[21:42:29] <sfackler> jmgrosen: https://github.com/mozilla/rust/pull/8556
[21:43:04] <ecr> jstevans: ah, I think this was resolved in the new runtime, but I don't think that's in 0.7. Hm...
[21:43:40] <jstevans> ecr: Darn. Ah, well -- SSHing into an Azure instance is more fun, anyway :)
[21:44:37] <benh> (Do we actually know for certain whether that class ended up going with 0.7 or the tip of master?)
[21:44:58] <ecr> jstevans: Yeah, you guys are missing out since you're stuck back in 0.7. Although to be honest, I'm not sure how stable the new I/O is on Windows either.
[21:45:13] <sfackler> running a class on master would be a disaster though
[21:45:33] *** Quits: carllerche (carllerche@moz-CDE5367B.dsl.static.sonic.net) (Quit: carllerche)
[21:45:34] <sfackler> i had some friends taking anderson's distibuted systems class using pre-1.0 Go and it was apparently a mess
[21:45:40] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[21:45:40] *** ChanServ sets mode: +o tjc
[21:45:48] <jstevans> sfackler: Some of us kind of think it would be more fun as a class if it turns out to be a disaster anyway ;)
[21:45:57] <ecr> Not if you just froze your fork of master. Well, it wouldn't be clean, but it wouldn't be utter chaos either.
[21:46:26] <sfackler> I dunno, "OH GOD MY CODE DOESN'T COMPILE ANYMORE" at 11:59 is not my idea of fun :P
[21:47:23] <sfackler> working off a fork seems reasonable though
[21:48:28] *** Joins: jdsanders (Adium@moz-84CB7548.hlrn.qwest.net)
[21:48:28] *** Joins: jmgrosen (jmgrosen@moz-65111F7B.tmodns.net)
[21:48:45] <jmgrosen> error: attrs on macros are not yet supported :(
[21:49:09] <jmgrosen> It's a non-breaking change, though, so I can leave it how it was before and clean it up later when the base is updated
[21:49:16] *** Joins: lex (chatzilla@F7B9D3C.B9AD9095.DDE5D3F6.IP)
[21:49:29] <acrichto> jmgrosen: to hack around that you can #[cfg(stage0)] a mod with the #[macro_escape] listed
[21:49:55] <ecr> jmgrosen: you can look at how nmatsakis handled externfn!
[21:49:59] <jmgrosen> acrichto: I can't decide if this one tiny change is worth that ugliness, though
[21:50:15] <ecr> that's a macros that's still breaking stage0-std-test
[21:50:23] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[21:50:24] *** Joins: msingle (Thunderbir@moz-20675462.nrflva.fios.verizon.net)
[21:50:33] <ecr> it's only temporary until the next snapshot
[21:50:40] <ecr> once that happens you can remove it
[21:51:00] <jmgrosen> acrichto, ecr: I'm making it so that condition! has a `use super::*;` in it, and I was removing the super:: in front of some types in libstd
[21:51:39] <jmgrosen> so should I leave them with the super::TypeName or do the #[cfg(stage0)] mod?
[21:51:42] <acrichto> jmgrosen: oh yeah it's probably just best to clean up later, you could add NOTE comments if you want as well
[21:51:53] *** Joins: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net)
[21:51:57] *** Quits: _Y_ (Mibbit@moz-C68B11C3.dynamic.isp.telekom.rs) (Quit: http://www.mibbit.com ajax IRC Client)
[21:52:00] <jmgrosen> ok, great
[21:52:14] *** Quits: vodik (simon@moz-CBE4BB13.cable.teksavvy.com) (Ping timeout)
[21:53:29] <jmgrosen> should I refer to the snapshot just as snapshot?
[21:53:44] <jmgrosen> i.e. "Change this next time the snapshot is updated" ?
[21:53:57] <kmc> why can't you implement Drop for enums?
[21:54:00] <ecr> that should be fine
[21:54:26] <jmgrosen> great
[21:54:43] <ecr> kmc: no idea. it may just not be implemented yet.
[21:54:48] *** Quits: jmgrosen (jmgrosen@moz-65111F7B.tmodns.net) (Quit: jmgrosen)
[21:54:54] *** Quits: squiddy (squiddy@moz-C1B7C6B.adsl.alicedsl.de) (Quit: Leaving)
[21:55:49] <acrichto> kmc: https://github.com/mozilla/rust/issues/6250
[21:56:24] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[21:56:24] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14e8399dd to 14b4ff0bc: 02http://git.io/N3iJvQ
[21:56:24] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[21:56:25] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[21:56:26] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/WL_oTg
[21:56:26] <ghrust> 13rust/06auto 14efb8924 15Eric Reed: Add a variant of home_for_io that consumes the handle. Refactor out common parts of the home_for_io variants.
[21:56:26] <ghrust> 13rust/06auto 1458b2ff9 15Eric Reed: Split out starting a listener from accepting incoming connections....
[21:56:26] <ghrust> 13rust/06auto 143c4e943 15bors: auto merge of #8954 : anasazi/rust/tcp-acceptor, r=catamorphism...
[21:56:28] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[21:58:30] <kmc> ok
[21:58:55] <kmc> it's weird to me that structs and enums are distinct at all, but it's definitely weird that language features have to be implemented separately for each
[21:59:13] *** Quits: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net) (Quit: dave1629)
[22:00:26] *** Joins: fyolnish (fyolnish@moz-FCF65CEE.uqwimax.jp)
[22:00:29] <tikue> kmc: but they act differently, how could they not be distinct?
[22:00:50] <kmc> how do they act differently?
[22:00:56] <tjc> tikue: enums could have named fields; we've considered adding that
[22:01:05] <tjc> and then a struct would just be a univariant enum with named fields
[22:01:05] <benh> don't enums already have named fields?
[22:01:06] <tikue> tjc: they already can i thought
[22:01:18] <acrichto> rusti: enum A { B { name: int } }
[22:01:18] <tjc> tikue: oh, maybe I thought they weren't added because nobody uses them :-)
[22:01:19] -rusti- ()
[22:01:23] <tikue> rusti: enum Foo { Bar { baz: uint } }
[22:01:24] -rusti- ()
[22:01:29] <tikue> tjc: i've used them
[22:01:39] <kmc> structs and enums have different syntax, but you can use either syntax with either kind of type
[22:01:56] *** Joins: dherman (dherman@moz-BE33DA21.fw1.sfo1.mozilla.net)
[22:01:56] *** ChanServ sets mode: +ao dherman dherman
[22:01:58] <kmc> structs guarantee C ABI, but that guarantee could extend to one-ctor enums, or (better imo) involve a #[c_abi] attribute
[22:02:03] <tikue> kmc: you can't access fields of an enum without matching
[22:02:07] *** Quits: fyolnish (fyolnish@moz-FCF65CEE.uqwimax.jp) (Ping timeout)
[22:02:32] <kmc> you could allow it when there's only one ctor
[22:02:38] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[22:02:41] <tikue> rusti: enum Foo { Bar { baz: uint } } Bar { baz: 0u }.baz
[22:02:41] -rusti- <anon>:5:40: 5:59 error: attempted access of field `baz` on type `main::Foo`, but no field with that name was found
[22:02:41] -rusti- <anon>:5          enum Foo { Bar { baz: uint } } Bar { baz: 0u }.baz
[22:02:41] -rusti-                                                  ^~~~~~~~~~~~~~~~~~~
[22:02:42] -rusti- error: aborting due to previous error
[22:02:42] -rusti- application terminated with error code 101
[22:02:42] <ecr> I'd be perfectly ok with unifying structs and enums. since we know the type, we'd always be able to tell when a match is required
[22:02:51] <strcat> rusti: range(0, 3).map(|x| x * 2)
[22:02:51] -rusti- std::iterator::Map<,int,int,std::iterator::Range<int>>{iter: std::iterator::Range<int>{state: 0, stop: 3, one: 1}, f: fn(int) -> int}
[22:02:55] <tikue> ecr:  that'd actually be really nice
[22:02:58] <tikue> ok, i'm sold :P
[22:03:15] <tikue> what would they be called though
[22:03:17] <tikue> enum or struct
[22:03:19] <ecr> data
[22:03:33] <acrichto> strcat: nice repr changes
[22:03:33] <tjc> structenum
[22:03:35] <sfackler> thing
[22:03:37] * tjc should never name anything
[22:03:38] <Luqman> for trans at least enums and structs are both handled by rustc::middle::trans::adt.
[22:03:42] <tikue> sfackler++
[22:03:49] <strcat> acrichto: lifetimes still don't print ;[
[22:03:50] <ecr> new keyword: 'stuff'
[22:03:51] <Luqman> structs are Univariant
[22:03:57] <strcat> and enum variants are done wrong
[22:04:03] <ecr> also rename 'type' to 'thingamabob'
[22:04:08] <benh> we could call them 'class'
[22:04:18] *** Quits: jgilbert (jgilbert@moz-7B0110AD.mv.mozilla.com) (Quit: Leaving)
[22:04:19] <ecr> no 'class' >:[
[22:04:23] <benh> just to keep everybody confused
[22:04:33] <tjc> Rust: A Confusion-Oriented Programming Language
[22:04:37] <tikue> lol
[22:04:40] <tikue> i wouldn't be opposed to class
[22:04:41] <ecr> oh, if that's the goal, then go for it
[22:04:47] <kmc> I'm not sure it's worth the disruption of unifying struct/enum at this point
[22:04:57] <tikue> kmc: you were the one that proposed it :P
[22:05:03] <tikue> or brought it up rather
[22:05:08] <kmc> i didn't propose the change exactly
[22:05:12] <ecr> or: keep struct and enum, and add 'data' and 'class' and just make them all synonyms.
[22:05:23] <tikue> we haven't hit 1.0 yet, anything goes imo :P
[22:05:27] <kmc> it's just an ugly wart coming from languages which treat algebraic data uniformly
[22:05:32] <kmc> but maybe I'm just complaining ;P
[22:05:36] <tikue> kmc: so let's fix the wart!
[22:06:05] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[22:06:15] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[22:06:15] *** ChanServ sets mode: +o pnkfelix
[22:06:51] <tikue> rusti: struct UnivariantEnum(StructEnum) enum StructEnum { Foo { enume: ~UnivariantEnum } }
[22:06:51] -rusti- <anon>:5:43: 5:47 error: expected `;` but found `enum`
[22:06:51] -rusti- <anon>:5          struct UnivariantEnum(StructEnum) enum StructEnum { Foo { enume: ~UnivariantEnum } }
[22:06:51] -rusti-                                                     ^~~~
[22:06:52] -rusti- application terminated with error code 101
[22:07:04] <tikue> rusti: struct UnivariantEnum(StructEnum); enum StructEnum { Foo { enume: ~UnivariantEnum } }
[22:07:10] *** Quits: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP) (Ping timeout)
[22:07:11] *** Joins: jgilbert (jgilbert@moz-7B0110AD.mv.mozilla.com)
[22:07:21] *** Joins: pnkfelix|rcirc (pnkfelix@moz-43495417.fbx.proxad.net)
[22:07:24] -rusti- pastebinned 8 lines of output: http://ix.io/7P5
[22:07:35] *** Joins: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP)
[22:07:35] <skoizza> Quick question! Brand new to Rust. I have "let args: ~[~str] = os::args();" and I am trying to do something like "for args.each |n| {" but rust says ~[~str] doesnt have each and I am at a loss
[22:07:53] <tjc> skoizza: Are you using Rust 0.7?
[22:07:54] <tikue> rusti: struct UnivariantEnum(StructEnum); enum StructEnum { Foo { enume: ~UnivariantEnum }, Bar }
[22:07:55] -rusti- ()
[22:08:02] <kmc> what version of Rust are you using? these days that's "for n in args.iter() { ... "
[22:08:10] <skoizza> im using .7
[22:08:21] <skoizza> do you have to use an iter? or is that just recommended
[22:08:36] <tikue> skoizza: it's the new idiom post 0.7
[22:08:37] <tjc> skoizza: Yeah, then it's: for args.advance |n| { … }
[22:08:38] *** Quits: Houm (Houm@moz-25669AA8.fbx.proxad.net) (Ping timeout)
[22:08:43] *** Quits: lex (chatzilla@F7B9D3C.B9AD9095.DDE5D3F6.IP) (Quit: ChatZilla 0.9.90.1 [Firefox 23.0/20130803193131])
[22:08:45] <tjc> that's specific to 0.7
[22:08:47] <strcat> well, iter().advance
[22:08:56] <tjc> yes, what strcat said
[22:09:17] <skoizza> great, thanks guys
[22:09:19] <dbaupp> acrichto: (my ping is now irrelevant)
[22:10:36] *** Joins: pepper_chico (pepper_chi@14AC4DFD.704EE6B0.E4090502.IP)
[22:11:43] *** Joins: ktt3ja (Mibbit@moz-6B6EE8C0.hsd1.va.comcast.net)
[22:12:58] *** Joins: Houm (Houm@moz-25669AA8.fbx.proxad.net)
[22:13:43] <tikue> skoizza: also, type inference would take care of the : ~[~str] for you
[22:13:54] <tikue> you could just write let args = os::args() unless you prefer being explicit
[22:15:42] <skoizza> it would? okay. Also i know you can cast a float/int as a str but can you do it the other way around?
[22:16:10] *** Quits: sigma (sigma@moz-B8E78D5.range86-136.btcentralplus.com) (Ping timeout)
[22:16:15] <tikue> skoizza: not by casting
[22:16:25] <ecr> skoizza: I think what you want is FromStr::from_str
[22:16:25] <tikue> rusti: let two: uint = FromStr::from_str("2"); two
[22:16:28] -rusti- pastebinned 7 lines of output: http://ix.io/7Hv
[22:16:41] <tikue> rusti: let two: uint = FromStr::from_str("2").unwrap(); two
[22:16:41] -rusti- 2u
[22:16:58] *** Joins: sigma (sigma@moz-B8E78D5.range86-136.btcentralplus.com)
[22:17:56] <tikue> ^ so it'd be nice if "from_str" could just be in the prelude
[22:17:59] <tikue> would that be possible
[22:18:04] <strcat> not right now
[22:18:08] <tikue> i know
[22:18:09] <tikue> but i mean
[22:18:12] <strcat> yes then
[22:18:13] <tikue> is it something that could be done
[22:19:14] <tikue> strcat: what needs to change to enable that?
[22:19:27] <strcat> being able to import from traits again
[22:19:54] <dbaupp> tikue: there could be a free function `fn from_str<F: FromStr>(s: &str) -> F { FromStr::from_str(s) }` in the prelude; but that's pretty ugly
[22:20:24] <tikue> dbaupp: why is it ugly?
[22:20:42] <ecr> unnecessary code duplication
[22:20:47] <tikue> i mean, i suppose it'd be a lot nicer if you could just have ```pub use FromStr::from_str```
[22:21:06] <tikue> why was importing from traits disallowed?
[22:21:07] <strcat> duplicating code to work around a fixable language issue is very wrong
[22:21:09] <dbaupp> yeah, that's what I mean
[22:22:46] <strcat> dbaupp: https://github.com/mozilla/rust/pull/8956 r?
[22:24:45] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[22:24:57] <ktt3ja> if s is a string, is it possible to do something like "let s2: &str = s.split_iter(' ').collect()[1]" in a single line?
[22:25:00] <dbaupp> strcat: do we want this in the language? I thought you decided it was incorrect?
[22:25:05] <ktt3ja> I got "error: the type of this value must be known in this context"
[22:25:20] <dbaupp> ktt3ja: s.split_iter(' ').nth(1)
[22:25:37] <strcat> dbaupp: it exists and it's useful, so it needs a test whether it's the correct way to do it or not
[22:25:59] <strcat> it could be changed to an intrinsic instead, doesn't matter
[22:26:12] <ChrisMorgan> cmr: http://huonw.github.io/isrustfastyet/mem/ still isn't getting data :-(
[22:26:13] <dbaupp> strcat: yup; r+
[22:26:23] <cmr> ChrisMorgan: the benchmarker hasn't been running.
[22:26:25] *** Quits: jclements (jclements@moz-6636E151.wireless.calpoly.edu) (Quit: jclements)
[22:26:31] <cmr> haven't had time to make it up proper.
[22:27:34] <strcat> anyway done with touching reflection for now
[22:27:49] <tikue> rusti: "abc"[0]
[22:27:49] -rusti- 97u8
[22:27:53] <pnkfelix|rcirc> cmr: FYI, if you add my commit to 8540 (and double-check that it builds the rustdoc lib), you can r+ it from me
[22:27:58] <strcat> repr isn't absolutely horrible now, just horrible
[22:28:12] <cmr> pnkfelix|rcirc: ok, double-checking
[22:28:47] <tikue> how do you convert from a u8 to char?
[22:29:05] <kimundi> rusti: "hello".iter().nth(0).to_ascii().to_byte()
[22:29:05] -rusti- <anon>:5:9: 5:42 error: type `std::option::Option<char>` does not implement any method in scope named `to_ascii`
[22:29:06] -rusti- <anon>:5          "hello".iter().nth(0).to_ascii().to_byte()
[22:29:06] -rusti-                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[22:29:06] -rusti- error: aborting due to previous error
[22:29:06] -rusti- application terminated with error code 101
[22:29:27] <kimundi> rusti: "hello".iter().nth(0).unwrap().to_ascii().to_byte()
[22:29:28] -rusti- 104u8
[22:29:45] <tikue> how do you go back to char?
[22:29:47] <ecr> to_ascii is the current best thing
[22:30:03] <tikue> rusti: "hello"[0].to_ascii()
[22:30:04] -rusti- std::ascii::Ascii{chr: 104u8}
[22:30:07] <SiegeLord> Why can't you hold multiple mutable references?
[22:30:18] <dbaupp> SiegeLord: it's unsafe
[22:30:22] <kimundi> tikue: well a single u8 can only be an ascii code point to become a valid char
[22:30:24] <SiegeLord> Yes, but why?
[22:30:33] <kimundi> 45u8.to_ascii().to_char()
[22:30:36] <ChrisMorgan> rusti: "hello".iter().nth(0).unwrap() as char
[22:30:37] -rusti- 'h'
[22:30:40] <tikue> kimundi: oh  great, thanks
[22:30:46] <kimundi> rusti: 45u8.to_ascii().to_char()
[22:30:47] -rusti- '-'
[22:30:50] <tikue> rusti: "hello"[0].to_ascii().to_char()
[22:30:51] -rusti- 'h'
[22:30:52] <kimundi> rusti: 127u8.to_ascii().to_char()
[22:30:53] -rusti- '\x7f'
[22:30:57] <kimundi> rusti: 128u8.to_ascii().to_char()
[22:30:58] -rusti- task <unnamed> failed at 'assertion failed: self.is_ascii()', /build/rust-git/src/rust/src/libstd/str/ascii.rs:120
[22:30:58] <ChrisMorgan> rusti: 45u8 as char
[22:30:58] -rusti- application terminated with error code 101
[22:30:58] -rusti- '-'
[22:31:05] <dbaupp> SiegeLord: if you have to references to a ~[], a .push from one can cause it to be reallocated, so the other one is now pointing into nowhere (for example)
[22:31:13] <tikue> rusti: "hello"[0].to_ascii().to_str()
[22:31:14] -rusti- ~"\'h\'"
[22:31:36] <tikue> println("hello"[0].to_ascii().to_str())
[22:31:39] <ChrisMorgan> rusti: 128u8 as char  // This is, of course,the danger of such a direct cast...
[22:31:39] -rusti- '\x80'
[22:31:41] *** Quits: skoizza (Mibbit@moz-C3630477.hsd1.va.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[22:31:48] <tikue> rusti: println("hello"[0].to_ascii().to_str())
[22:31:49] -rusti- 'h'
[22:31:49] -rusti- ()
[22:31:51] <SiegeLord> dbaupp: Is it unsafe in the general case? Or it it just a conservative restriction to make it practical to implement?
[22:31:59] <strcat> ChrisMorgan: casts to char will be removed
[22:31:59] <kimundi> stray poll: should 'x'.to_str() print 'x' or x
[22:32:00] <SiegeLord> *practical to enforce
[22:32:09] <ChrisMorgan> strcat: :-(
[22:32:09] <tikue> kimundi: x
[22:32:12] <sfackler> x
[22:32:12] <strcat> ChrisMorgan: they are unsound
[22:32:16] <tjc> kimundi: I also vote for x
[22:32:25] <strcat> casts *from* char are okay
[22:32:35] <kimundi> Then someone should a) impl to_str for char and b) change ascii ;)
[22:32:46] <strcat> ToStr is going to go away
[22:32:49] <kimundi> hmm... It's a 5min change
[22:32:50] <dbaupp> SiegeLord: yes, it is unsafe: as soon as you relax the rules you start drifting towards "C++ is safe if you follow x, y, z and don't forget to a, b and c."
[22:32:53] <kimundi> will jsut do it
[22:33:03] <ecr> strcat: wat. what's replacing ToStr then?
[22:33:04] <tikue> kimundi: maybe print('x'.repr()) would print 'x'
[22:33:14] <strcat> ecr: the default formatting trait
[22:33:17] <ChrisMorgan> Could to-char casting be permitted in an unsafe block?
[22:33:33] <strcat> ChrisMorgan: transmute
[22:33:47] <ChrisMorgan> How large is char?
[22:33:48] <SiegeLord> dbaupp: In my case I'm relaxing the rules a bit in an opaque type, I just want to know what a,b,c and x,y and z are ;)
[22:34:00] <kimundi> rusti: 'x'.to_str()
[22:34:00] -rusti- <anon>:5:9: 6:5 error: type `char` does not implement any method in scope named `to_str`
[22:34:00] -rusti- <anon>:5          'x'.to_str()
[22:34:01] -rusti- <anon>:6     };
[22:34:01] -rusti- error: aborting due to previous error
[22:34:01] -rusti- application terminated with error code 101
[22:34:01] <strcat> ChrisMorgan: 4 bytes
[22:34:07] <strcat> stored that way
[22:34:11] <strcat> it's really 21-bit
[22:34:12] <ChrisMorgan> Transmute is only for things that are the same size, isn't it? So u8 -> char would then not work?
[22:34:21] <dbaupp> SiegeLord: so you're using unsafe code?
[22:34:33] <strcat> ChrisMorgan: u8 -> char would not work, you would go u8 -> u32 -> char
[22:34:34] <SiegeLord> dbaupp: Yes, but I want a safe interface to it
[22:35:04] <SiegeLord> Just because it's not expressible within the Rust's type system doesn't make it unsafe
[22:35:15] <dbaupp> SiegeLord: ah, ok: well the most basic rule is &mut should never overlap (so it should never be possible to touch the same piece of memory from two different &mut's)
[22:35:26] <dbaupp> and similarly for & and &mut
[22:35:51] <ChrisMorgan> strcat: I guess that makes sense. And if you have cause to do it a lot you could write an inline function easily enough.
[22:35:52] <strcat> you can take N &mut references to a value, and rustc will let you
[22:35:55] <strcat> as long as they don't overlap
[22:36:09] <strcat> ChrisMorgan: well it seems like a weird thing to do often
[22:36:19] <strcat> there will be a conversion via Option
[22:36:19] <dbaupp> SiegeLord: this is guaranteed automatically if you have something like impl MyType { fn x<'a>(&'a mut self) -> &'a mut int { ... } }
[22:36:33] <strcat> ChrisMorgan: how do you know the value you're converting from is a valid char?
[22:36:34] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Ping timeout)
[22:36:46] <kimundi> rusti: ::std::str::from_char('f')
[22:36:47] -rusti- ~"f"
[22:36:55] <strcat> you have to check that it's not over 21-bit, and not a surrogate character
[22:36:58] <dbaupp> SiegeLord: i.e. it automatically propagates the &mut borrow of self to the int
[22:37:07] *** Joins: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net)
[22:37:48] <dbaupp> SiegeLord: (guaranteed to the user of `x`, assuming that the internals are implemented correctly.)
[22:37:56] <strcat> rusti: '\x00'
[22:37:57] -rusti- '\x00'
[22:38:08] <strcat> maybe I'll try removing that right now
[22:38:48] <acrichto> strcat: is 0x80 a valid unicode character?
[22:39:02] <acrichto> or rather are all values < 21 bits valid unicode characters?
[22:39:12] <strcat> acrichto: no
[22:39:13] <ChrisMorgan> strcat: one may have already checked that it's in a valid range.
[22:39:32] <acrichto> strcat: I was thinking it'd be nice in the effect checker to just ensure that `as char` has an `unsafe` block somewhere
[22:39:36] <strcat> ChrisMorgan: well there's going to be a function to convert to Option<char>, safely
[22:39:38] *** Quits: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net) (Quit: dave1629)
[22:39:46] <acrichto> strcat: it could even have a special message talking about unicode
[22:39:49] <strcat> acrichto: we shouldn't have it at all
[22:39:59] <acrichto> it is convenient though
[22:40:04] <strcat> no, it's not convenient
[22:40:08] <strcat> it's wrong in almost every case
[22:40:09] <ChrisMorgan> Hang on, U+0080 is a valid Unicode character. Just not a valid UTF-8 character.
[22:40:24] <strcat> char is not related to utf-8
[22:40:27] <dbaupp> ChrisMorgan: it's a codepoint: the byte representation is different
[22:40:40] <acrichto> but then shouldn't 0x80 as char be valid?
[22:40:48] <ChrisMorgan> Seems to me it should be.
[22:40:51] <dbaupp> no, it's 2 btes
[22:40:51] <strcat> acrichto: it's not going to use 'as'
[22:40:58] <strcat> acrichto: 'as' doesn't return Option
[22:41:02] <strcat> there are already char literals
[22:41:03] *** Parts: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) ()
[22:41:14] <acrichto> I'd be ok with that
[22:41:21] <strcat> don't need 'as char' to write a character constant as a number
[22:41:56] <strcat> 'as' only exists for use in constant exprs and converting to a char from an integer can't be done in a constant expr
[22:41:59] <acrichto> strcat: along the same lines though, we'd have to remove all `char as X` unless X >= 32 bits
[22:42:10] <strcat> acrichto: no
[22:42:12] <strcat> that's not unsafe
[22:42:23] <strcat> creating invalid chars is not memory safe
[22:42:28] <dbaupp> rusti: let mut buf = [0, .. 4]; printfln!(buf.slice_to((0x80 as char).encode_utf8(buf)))
[22:42:28] <acrichto> yeah I suppose so
[22:42:30] -rusti- pastebinned 16 lines of output: http://ix.io/7Pb
[22:42:36] <ChrisMorgan> But (0x80 as char) is *not* an invalid char.
[22:42:41] <acrichto> b/c as u8 safely truncates anyway
[22:42:43] <strcat> ChrisMorgan: not saying it is
[22:43:03] <strcat> rusti: '\x80'
[22:43:03] -rusti- '\x80'
[22:43:04] <dbaupp> rusti: let mut buf = [0, .. 4]; let len = (0x80 as char).encode_utf8(buf); printfln!(buf.slice_to(len))
[22:43:04] -rusti- &[194u8, 128u8]
[22:43:04] -rusti- ()
[22:43:10] <ChrisMorgan> You're meaning things like 2 ** 25, which aren't assigned?
[22:43:14] <dbaupp> ChrisMorgan: it's not a byte cast
[22:43:28] <strcat> ChrisMorgan: surrogate characters and anything over 21-bit are defined as invalid
[22:43:37] *** Quits: Houm (Houm@moz-25669AA8.fbx.proxad.net) (Ping timeout)
[22:43:43] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Ping timeout)
[22:43:53] <strcat> it is not memory safe to store them in char, because char is assumed to be valid
[22:44:01] *** Quits: pnkfelix|rcirc (pnkfelix@moz-43495417.fbx.proxad.net) (Ping timeout)
[22:44:04] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[22:44:04] *** ChanServ sets mode: +o pnkfelix
[22:44:20] <strcat> the str module is very memory unsafe right now
[22:44:40] <ChrisMorgan> I understand now.
[22:44:57] <strcat> also, things like assigning to str bytes :(
[22:45:14] *** Joins: pnkfelix|rcirc (pnkfelix@moz-43495417.fbx.proxad.net)
[22:46:04] *** Joins: Houm (Houm@moz-25669AA8.fbx.proxad.net)
[22:46:17] <kimundi> rusti: let mut x = ~"foo"; x[1] = 0; x
[22:46:17] -rusti- ~"f\x00o"
[22:46:22] <kimundi> rusti: let mut x = ~"foo"; x[1] = 255; x
[22:46:23] -rusti- task <unnamed> failed at 'assertion failed: (w != 0)', /build/rust-git/src/rust/src/libstd/str.rs:1938
[22:46:23] -rusti- application terminated with error code 101
[22:46:30] <kimundi> good one
[22:46:54] <dbaupp> engla: you definitely could've put a better error message for that assert ;)
[22:47:07] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[22:47:49] *** Quits: sigma (sigma@moz-B8E78D5.range86-136.btcentralplus.com) (Ping timeout)
[22:48:03] *** Joins: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net)
[22:48:32] <strcat> dbaupp: well it should be impossible to hit it :(
[22:48:44] <strcat> should be able to be a debug assert
[22:48:51] *** Quits: threecreepio (jdp@moz-71E164C9.cust.bredbandsbolaget.se) (Quit: threecreepio)
[22:49:34] <dbaupp> strcat: yes, but doesn't cost much to have assert(w != 0, "invalid utf8 string") or something like that.
[22:49:43] <strcat> it does cost a lot
[22:49:55] <kimundi> compared to not having the assert
[22:50:00] <strcat> it means LLVM can't optimize anything about it, because fail! is pretty much entirely opaque
[22:50:03] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[22:50:14] <strcat> anywhere you insert fail! is now opaque to LLVM except in rare cases where it can prove it never happens
[22:50:22] <strcat> (it has no idea what failure does)
[22:50:25] <kimundi> but assert!() vs assert!(, "nice error message") shouldn't be much different, no?
[22:50:36] <strcat> not much different
[22:50:47] <strcat> dbaupp: I'm just saying it's wrong for it to exist at all
[22:51:03] <strcat> lets fix char
[22:51:11] <brson> ChrisMorgan: i sent you a rust-http pr
[22:51:32] <ChrisMorgan> brson: thanks :-) I was actually just about to ask what you were doing with your wips.
[22:51:58] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[22:53:10] * strcat forgets where the binop/unary typeck stuff is... no doubt in typeck :)
[22:53:18] <ChrisMorgan> brson: the os::args().len() == 0 case is actually genuine. One can apparently contrive to run an application with no arguments... most collapse.
[22:54:02] <ChrisMorgan> I knew ETag and Content-Type were broken, thanks for fixing them up.
[22:54:20] * ChrisMorgan has been working more on making it testable
[22:54:46] * ChrisMorgan is also sadly busy at present and hasn't committed for five days :-(
[22:55:09] <brson> ChrisMorgan: I believe the 0-args case is just folded into the fallthrough case. Is that wrong?
[22:55:21] <ChrisMorgan> Well, args[0] would then fail.
[22:55:41] <brson> i see
[22:55:42] <ChrisMorgan> It doesn't really matter. Anyone who's knowingly running things in that way probably expects things to break.
[22:55:49] <brson> ok, I'll fix that
[22:55:56] * ChrisMorgan is now away for half an hour
[22:55:59] <kimundi> strcat: Hm I did the char and ascii to_str() change, I could also add debug_assert! while I'm add it
[22:56:10] <kimundi> should I?
[22:56:29] <strcat> I don't know, but I think we should be working on removing ToStr and replacing it with a default method on acrichto's formatting traits
[22:56:42] <kimundi> well, yeah
[22:57:29] <dbaupp> ChrisMorgan: isn't this an internal build-the-rust-http application anyway?
[22:57:46] <strcat> so... we don't have a ty_char at all
[22:57:49] <strcat> :s
[22:57:51] <kimundi> A ToStr trait with method that forces you to use a writer, but that has the current to_str() as an default method would be nice, maybe?
[22:58:01] <strcat> it's entirely an AST thing
[22:58:19] <strcat> kimundi: it exists, it just needs a default method
[22:58:37] *** Quits: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net) (Quit: dave1629)
[22:58:43] <strcat> to_owned_str can be a default method from it
[22:58:56] <strcat> or to_unique_str, I don't know which name we decided on
[22:59:00] <strcat> I guess we didn't decide yet
[22:59:42] <dbaupp> strcat: it's part of ty_int right
[23:00:00] <strcat> yeah
[23:00:20] <strcat> I'll add another ty for it and try dealing with the fallout
[23:00:32] <strcat> it should have +, -, /, etc.
[23:00:53] *** Joins: fyolnish (fyolnish@moz-E0C8C621.uqwimax.jp)
[23:00:57] <strcat> shouldn't have*
[23:01:01] <strcat> ugh, typos
[23:01:19] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[23:01:19] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/WL_oTg
[23:01:19] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[23:01:39] <pnkfelix|rcirc> strcat: phew.  I was very confused.
[23:02:17] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[23:02:28] <dbaupp> rusti: '\u2522' / 'a'
[23:02:29] -rusti- 'b'
[23:02:34] *** Quits: fyolnish (fyolnish@moz-E0C8C621.uqwimax.jp) (Ping timeout)
[23:02:35] * strcat has a feeling he has to update 200 match exprs now
[23:02:40] <strcat> dbaupp: ;[
[23:02:48] <strcat> char makes me sad
[23:03:11] <strcat> bools do too
[23:03:22] <bjz_> jeaye sebcrozet: don't need to call .poll_events() on windows any more!
[23:03:25] <strcat> but at least bool is a ty already so it's mostly just a trans issue
[23:03:34] <mm> computers would be easier if we deprecated humans using them
[23:03:35] <jeaye> Oh?
[23:03:37] <bjz_> jeaye sebcrozet: thank lbergstrom
[23:03:39] <bjz_> :)
[23:03:46] <jeaye> What instead?
[23:03:46] <mm> ASCII or bust.
[23:03:59] <bjz_> jeaye: only glfw::poll_events()
[23:04:17] <bjz_> https://github.com/bjz/glfw-rs/pull/32
[23:04:42] <jeaye> bjz_: I only ever called than anyway... o.O
[23:04:48] <jeaye> https://github.com/jeaye/q3/blob/master/src/main.rs#L171
[23:05:16] <kmc> rusti: '\n' * '\n'
[23:05:17] -rusti- 'd'
[23:05:29] <bjz_> jeaye: how old is your glfw?
[23:05:44] *** Joins: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP)
[23:05:51] <jeaye> bjz_: glfw or glfw-rs?
[23:06:14] <jeaye> bjz_: https://github.com/jeaye/q3/tree/master/lib
[23:06:19] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[23:06:19] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/IlK-Qg
[23:06:19] <ghrust> 13rust/06auto 141671013 15Daniel Micay: add test for tydesc name
[23:06:19] <ghrust> 13rust/06auto 1401dd460 15bors: auto merge of #8956 : thestinger/rust/test, r=huonw
[23:06:19] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[23:06:21] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[23:06:21] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/DwXx1g
[23:06:21] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[23:06:53] <jeaye> Looks like I pulled 9 days ago.
[23:06:56] <strcat> yay, only 14 non-exhaustive matches
[23:06:59] <strcat> \o/
[23:07:11] <engla> rusti: '1' / '0'
[23:07:11] -rusti- '\x01'
[23:07:31] <ecr> yay! my tcp change got through bors.
[23:07:31] <bjz_> jeaye: glfw-rs
[23:08:07] <jeaye> bjz_: I'm on https://github.com/jeaye/glfw-rs/commit/f516591fa439c31f50246ac4af3e37afd88fcd01
[23:08:12] *** Quits: jstevans (Instantbir@7436E564.3C990DFD.DDE5D3F6.IP) (Connection reset by peer)
[23:08:13] *** Joins: jstevans (Instantbir@7436E564.3C990DFD.DDE5D3F6.IP)
[23:08:16] <engla> dbaupp: I didn't write that assert message, I promise
[23:08:25] *** Quits: pepper_chico (pepper_chi@14AC4DFD.704EE6B0.E4090502.IP) (Quit: Textual IRC Client: www.textualapp.com)
[23:08:26] <kimundi> strcat: r? https://github.com/mozilla/rust/pull/8960
[23:08:37] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[23:08:38] <strcat> hm
[23:08:43] <strcat> I thought we already had debug_assert
[23:08:46] <bjz_> jeaye: oh yeah, well lbergstrom has been doing some awesome stuff behind the scense
[23:08:51] <bjz_> *scenes
[23:08:51] <strcat> kimundi: debug_assert shouldn't use assert inside
[23:08:56] <strcat> it shouldn't use failure
[23:09:12] * strcat thought dbaupp had a PR open about this
[23:09:24] <strcat> did that... never land?
[23:09:28] <bjz_> jeaye: you should probably subscribe to updates on glfw-rs
[23:09:30] <kimundi> strcat: Hm? I thought debug_assert should just be an assert that can be excluded from compilation?
[23:09:32] <brson> strcat: why should debug_assert not use failure?
[23:09:43] <strcat> brson: because failures can be caught at task boundaries, so you can accidentally ignore it
[23:09:44] <bjz_> jeaye: so you get emailed
[23:10:10] <kimundi> strcat: well, the same is true for normal asserts, no? ...
[23:10:11] <pnkfelix|rcirc> strcat: PR 7869 ?
[23:10:14] <strcat> brson: and it should only be used for things that should truly never happen, so it probably makes sense to exit
[23:10:14] *** Joins: jstevans1 (Instantbir@moz-478CBACE.bootp.virginia.edu)
[23:10:28] <strcat> kimundi: sure, but normal asserts are to uphold invariants
[23:10:45] <kimundi> Anyway, I did not, in fact, check if debug_assert exists. It doesn't in the expand string where regular assert lives at least
[23:10:55] <engla> dbaupp: str iteration could be much faster if the valid UTF-8 property was used to the point where you elide boundary checks because you expect continuation bytes
[23:11:05] *** Quits: jstevans (Instantbir@7436E564.3C990DFD.DDE5D3F6.IP) (Connection reset by peer)
[23:11:18] <engla> dbaupp: but I think it makes sense to have asserts there for rust's current state
[23:11:26] <strcat> brson: just really don't want us to have assertions that are important, but then turned off for speed
[23:11:34] * strcat shrugs
[23:11:48] *** Joins: jstevans2 (Instantbir@moz-478CBACE.bootp.virginia.edu)
[23:11:54] *** Quits: jstevans1 (Instantbir@moz-478CBACE.bootp.virginia.edu) (Ping timeout)
[23:12:13] <brson> strcat: that is what debug_assert is. not sure if there's any such thing as an assertion that is unimportant
[23:12:20] <kimundi> strcat: I get what you're saying, but do we have a way to impl a non-fail fail right now?
[23:13:18] <dbaupp> engla: yeah
[23:13:23] *** Joins: jstevans (Instantbir@C4AF381C.AA9008B0.DDE5D3F6.IP)
[23:13:27] <brson> i don't think i'm comfortable making debug_assert abort. failure in rust is supposed to be recoverable
[23:13:51] *** Quits: bytewise (bytewise@moz-4A801D04.unitymediagroup.de) (Quit: Leaving)
[23:13:53] <kimundi> Or, asked otherwise: Do know of an other implementation I can do in 5min? Cause else I'm going to bed now :P
[23:14:01] <dbaupp> strcat: didn't land, converting it use abort required essentially duplicating the functionality of fail!()
[23:14:11] <ecr> yeah, abort is supposed to be for really horrific things, like the scheduler not being where it should be.
[23:14:25] <dbaupp> engla: (apologies for the false accusation)
[23:14:25] <strcat> a debug_assert! failing is a horrible thing
[23:14:33] *** Joins: jstevans1 (Instantbir@6AB7F38C.A9DA0237.DDE5D3F6.IP)
[23:14:42] *** Quits: jstevans2 (Instantbir@moz-478CBACE.bootp.virginia.edu) (Ping timeout)
[23:14:46] *** Quits: SingingBoyo (Brandon@4DF3381A.51F4D838.4F048BDC.IP) (Ping timeout)
[23:14:46] <ecr> more than a regular assert! ?
[23:14:49] <kimundi> (better have an debug_assert that works 80% as it should than not having one I say, but...)
[23:14:51] <dbaupp> and it fail!ing would be even worse
[23:14:57] <strcat> ecr: an assert just enforces a condition and fails
[23:15:06] <strcat> failure is recoverable
[23:15:08] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[23:15:20] <strcat> you put an assert when it's something that is not proven to never happen
[23:15:22] *** Quits: lbergstrom (Adium@moz-5D8E4B14.lightspeed.cicril.sbcglobal.net) (Quit: Leaving.)
[23:15:25] <strcat> it's a runtime invariant
[23:15:29] <ecr> I know
[23:15:49] <dbaupp> ecr: yes, because the debug_asserts disappear in a release build, so if you're relying on it for safety, you've got a hole
[23:15:53] <jmgrosen> hey, my second PR! https://github.com/mozilla/rust/pull/8963
[23:16:03] *** Quits: jstevans (Instantbir@C4AF381C.AA9008B0.DDE5D3F6.IP) (Ping timeout)
[23:16:06] <dbaupp> ecr: (since normal fail! can be caught at task boundaries)
[23:16:18] <dbaupp> (and normal fail! will pass a should_fail test.)
[23:16:44] <erickt> tjc: ping
[23:16:52] <tjc> erickt: pong
[23:17:05] <kimundi> So, debug_assert is for things that shouldn't ever happen, and so should not be runtime ignorable in any way, okay. But still, that can be plugged into this debug_assert! at a later time anyway, no?
[23:17:17] *** Joins: jstevans (Instantbir@C58969A2.387BC77F.DDE5D3F6.IP)
[23:17:24] *** Quits: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP) (Ping timeout)
[23:17:26] <strcat> kimundi: well then it requires a whole RFC to change something
[23:17:27] *** Quits: jstevans1 (Instantbir@6AB7F38C.A9DA0237.DDE5D3F6.IP) (Connection reset by peer)
[23:17:27] *** Joins: jstevans1 (Instantbir@6AB7F38C.A9DA0237.DDE5D3F6.IP)
[23:17:34] <kimundi> why?
[23:17:41] <kimundi> api's the same
[23:17:47] <strcat> no, it's not the same
[23:17:54] <pnkfelix|rcirc> I think its a mistake to be using the names debug_assert / assert for these two concepts that seem to be quite different, at least to strcat's and others' POV
[23:18:02] <ecr> if you just want to abort the program, then why have debug_assert when we have rtassert?
[23:18:06] <strcat> pnkfelix|rcirc: I think fail_unless! was a better name
[23:18:12] *** Quits: jstevans (Instantbir@C58969A2.387BC77F.DDE5D3F6.IP) (Connection reset by peer)
[23:18:15] <dbaupp> kimundi: debug_assert is also for very expensive checks that only need to be double checked.
[23:18:18] <strcat> ecr: rtassert is just for the runtime
[23:18:27] <ecr> strcat: but it's doing the same thing
[23:18:37] *** Joins: jstevans (Instantbir@C58969A2.387BC77F.DDE5D3F6.IP)
[23:18:41] <strcat> ecr: so a more general one would remove the need for rtassert
[23:18:48] <kimundi> okay, aynway
[23:18:52] <pnkfelix|rcirc> so how about debug_abort_unless!
[23:18:55] <kimundi> removing then and rebasing
[23:18:58] <ecr> strcat: or just use rtassert
[23:19:00] <pnkfelix|rcirc> (too long ...)
[23:19:01] <erickt> tjc: good afternoon tjc! I started playing around with rustpkg over the weekend, but I wasn't able to figure out how to make `rustpkg build` run essentially `rustc --linker c++ --link-args $(llvm-config --ldflags --libs all) llvm.rs`. Have you thought about how to do something like that?
[23:19:07] *** Quits: jstevans1 (Instantbir@6AB7F38C.A9DA0237.DDE5D3F6.IP) (Ping timeout)
[23:19:07] <strcat> ecr: rtassert doesn't make sense as a name outside of the runtime
[23:19:26] <tjc> erickt: right now the way to do it would be to use a custom build script :-)
[23:19:36] <strcat> the runtime isn't the only place where you want to insert checks to verify that you wrote something correctly, but that should not be compiled into the release build
[23:19:48] <jmgrosen> which parts of the c++ runtime are still used?
[23:19:48] <erickt> tjc: that's what I figured, but setting flags wasn't yet exposed by librustpkg/api
[23:19:55] <brson> strcat: rtassert is specifically for cases where the entire runtime is corrupted and cannot continue
[23:19:57] <pnkfelix|rcirc> strcat: or, sorry, were you suggesting that assert! should have been called fail_unless! ?
[23:19:58] <brson> other cases use assert
[23:20:14] <strcat> well lets not have debug_assert then
[23:20:16] <tjc> erickt: Yes, absolutely -- adding a way to set flags via api.rs is a to-do
[23:20:20] *** Quits: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com) (Ping timeout)
[23:20:23] <tjc> I'm checking if there's an issue open on that
[23:20:24] <strcat> pnkfelix|rcirc: yes
[23:20:31] <strcat> it's not a traditional assert
[23:20:45] <dbaupp> jmgrosen: aiui, anything currently in src/rt is used at least little
[23:20:56] <kimundi> So, all  traces of debug_assert! gone, can I get a r+ now? :P https://github.com/mozilla/rust/pull/8960
[23:21:00] <dbaupp> jmgrosen: there are bugs open about migrating this and that to C++
[23:21:04] <jmgrosen> dbaupp: ah, ok
[23:21:27] <dbaupp> *migrating to RUst
[23:22:08] * strcat came up with a clever way to do memory corruption with repr
[23:22:12] <tjc> erickt: Opened it: https://github.com/mozilla/rust/issues/8964
[23:22:18] <erickt> tjc: and second, I was wondering if you had given any thought to supporting configuration. I got that working in fbuild, but I did a lot of python metaclass magic to get it working which probably wouldn't port over well to rust
[23:22:22] <erickt> woot
[23:22:35] <strcat> although I guess it's not really "corruption" since it doesn't write
[23:22:42] <tjc> erickt: Not a lot of thought yet -- see https://github.com/mozilla/rust/issues/6403
[23:22:44] *** Quits: Uther (Instantbir@moz-1B244B05.hfc.dyn.abo.bbox.fr) (Ping timeout)
[23:22:51] <strcat> at worst you get a segfault or bus error
[23:23:18] <SiegeLord> Oh wow... rust-bindgen actually handles C unions somewhat :o
[23:23:30] <erickt> tjc: neat!
[23:23:38] *** Quits: tav (tav@moz-C302A43C.range86-149.btcentralplus.com) (Quit: tav)
[23:23:46] <Ralith> SiegeLord: how?
[23:24:38] <SiegeLord> Creates a struct with [c_uchar, ..size_of_union] and an impl whigh casts it to the various types
[23:24:58] <erickt> tjc: there is a third way to building C libraries, but that may be a bit much for rustpkg: add c/c++ compiler discovery and auto-configuration
[23:25:13] <strcat> rusti: let c: char = 5;
[23:25:14] -rusti- <anon>:5:23: 5:24 error: mismatched types: expected `char` but found `<VI0>` (expected an integral type but found char)
[23:25:14] -rusti- <anon>:5          let c: char = 5;
[23:25:14] -rusti-                                 ^
[23:25:14] -rusti- error: aborting due to previous error
[23:25:14] -rusti- application terminated with error code 101
[23:25:16] <strcat> good
[23:25:19] <strcat> saves me a lot of effort
[23:25:29] *** Joins: hexx (kvirc@D70E1914.6461B98.FFDF157.IP)
[23:25:35] <tjc> erickt: yeah, true!
[23:26:08] *** Joins: SingingBoyo (Brandon@4DF3381A.51F4D838.4F048BDC.IP)
[23:26:09] <SiegeLord> Ralith: http://pastebin.ca/2443188
[23:26:14] *** Joins: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net)
[23:26:49] <Ralith> neat
[23:27:00] *** Quits: auREAX (au@B360F4FB.2F0455A2.78618DFA.IP) (Input/output error)
[23:27:04] <SiegeLord> Made from this: http://pastebin.ca/2443190
[23:27:23] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[23:27:39] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[23:27:41] <dbaupp> strcat: repr-hole demo?
[23:28:39] *** hexx is now known as hex
[23:29:20] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[23:29:26] <erickt> tjc: beyond workcache, has any of the other ideas I had in fbuild make it into rustpkg? It'd probably be pretty difficult without exportable macros or syntax extensions. I really need to dive into your code some day :)
[23:30:09] <tjc> erickt: graydon is more familiar with fbuild than I am; what else do you think could be reusable in rustpkg, with or without macros/syntax extensions?
[23:31:46] <ChrisMorgan> brson: thanks for the PR :-)
[23:32:00] * erickt skims over rustpkg...
[23:32:46] *** jorendorff is now known as jorendorff_away
[23:32:46] <ChrisMorgan> Concerning your following commit, not in the PR, I don't understand this VPATH part. Why is VPATH necessary? Does make not guarantee working directory?
[23:33:43] <erickt> tjc: hrm, not much now that I look through the code.
[23:35:03] *** Quits: lkuper (lkuper@moz-D862222C.dhcp-bl.indiana.edu) (Ping timeout)
[23:37:02] *** kimundi is now known as zz_kimundi
[23:38:16] <brson> ChrisMorgan: I'm mostly just cargo-culting off of servo's other makefiles (which I *also* mostly wrote many months ago). servo does out of tree builds an the VPATH variables here keep the source pointing back in-tree. I know makefiles have some magic around this but I don't remember how it works
[23:38:37] *** Quits: jdm (jdm@CAB30FBD.8F96AEA7.2D179A7D.IP) (Ping timeout)
[23:38:48] <brson> it's really unfortunate that I've written so much of our makefile gunk when I don't know what the heck i'm doing
[23:38:57] <brson> i will never be able to appologize enough
[23:39:28] <strcat> dbaupp: well, past libsyntax.... unless I messed something up there ;p
[23:39:33] <strcat> had to add LIT_CHAR/lit_char
[23:39:39] *** Quits: jdsanders (Adium@moz-84CB7548.hlrn.qwest.net) (Quit: Leaving.)
[23:39:41] <erickt> tjc: maybe there will be more crossover as you build out the api library. It looks like you've been focusing on all the other stuff rustpkg needs to do beyond compiling code :)
[23:39:47] <dbaupp> strcat: cool
[23:40:22] <dbaupp> strcat: would it every make sense to store chars as u24?
[23:40:52] *** Joins: jdsanders (Adium@moz-84CB7548.hlrn.qwest.net)
[23:40:53] <strcat> dbaupp: no, that would involve splitting them into 3 sets of i8
[23:41:05] <strcat> it makes sense to store them as i32 and use i21 after a load
[23:41:13] *** Joins: richard|s (mindginati@moz-9C555AF3.spmconsultants.co.nz)
[23:41:18] <strcat> like what clang does with bools (store as i8, load as i1)
[23:41:55] *** Joins: a_m0d|home (a_m0d@moz-322CEC3.acanac.net)
[23:41:55] *** Joins: jdm (jdm@CAB30FBD.8F96AEA7.2D179A7D.IP)
[23:41:55] *** ChanServ sets mode: +o jdm
[23:41:57] *** Quits: pnkfelix|rcirc (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: rcirc on GNU Emacs 24.2.1)
[23:42:33] *** a_m0d|home is now known as a_m0d
[23:43:59] <strcat> dbaupp: oh right I forgot windows breaks repr
[23:44:04] *** Quits: jdsanders (Adium@moz-84CB7548.hlrn.qwest.net) (Quit: Leaving.)
[23:44:50] <tjc> erickt: Heh, that's more or less accurate
[23:45:11] <tjc> And, you know, patches welcome :-)
[23:46:07] <erickt> tjc: Haha :) I really should. I feel kind of bad convincing graydon that the workcache is the right way to do things, then never actually helping out with the idea. Would you be interesting in having a full stack of builders? Here's what I have for fbuild: https://github.com/felix-lang/fbuild/tree/master/lib/fbuild/builders
[23:46:37] <strcat> check-fast is really evil :(
[23:47:01] <erickt> tjc: it feels a little too general purpose for rust. Maybe as an extension library?
[23:47:03] <tjc> erickt: Hmm, some of that could be useful!
[23:48:25] <erickt> tjc: cool!
[23:48:34] *** Quits: echristo (echristo@DCF57675.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[23:48:57] <tjc> erickt: I'm not sure that we need to be able to invoke every other compiler (at least not to start with), but some of the utility functions there like find_program would definitely be good to have in the API
[23:49:06] *** Quits: jdm (jdm@CAB30FBD.8F96AEA7.2D179A7D.IP) (Quit: Lost terminal)
[23:51:14] <brson> ChrisMorgan: I'm going to look into DNS resolution next
[23:51:15] <erickt> tjc: I probably should just start a librbuild project that some could use with rustpkg to build a complicated project
[23:51:19] <ChrisMorgan> Good :-)
[23:51:41] <tjc> erickt: Sure! rustpkg certainly won't and shouldn't be all things to all people, so modularity is good
[23:52:19] <erickt> tjc: now if only I could export macros... :)
[23:52:31] *** Joins: vodik (simon@moz-CBE4BB13.cable.teksavvy.com)
[23:52:46] <tjc> erickt: you'll have to locate a macrologist for that one :-)
[23:53:23] * erickt eyes sully
[23:54:12] *** Joins: lbergstrom (Adium@moz-5D8E4B14.lightspeed.cicril.sbcglobal.net)
[23:54:57] <sully> what did I do
[23:55:19] <erickt> sully: it's what you didn't do: implement exportable macros :)
[23:55:36] <tjc> to be fair, nobody asked sully to do this AFAIK :-)
[23:55:52] <erickt> technicalities
[23:57:16] <strcat> /home/strcat/projects/rust/src/librustc/middle/typeck/coherence.rs:84:36: 84:43 error: variable `ty_char` from pattern #4 is not bound in pattern #1
[23:57:19] <strcat> um
[23:57:27] <strcat> oh I guess it's not in scope
[23:57:39] <tjc> yeah, those errors are fun
[23:58:10] *** Quits: Aszarsha (Aszarsha@moz-16BFBC53.rev.numericable.fr) (Connection reset by peer)
[23:58:37] <strcat> this is becoming a lot more of a pain than I thought

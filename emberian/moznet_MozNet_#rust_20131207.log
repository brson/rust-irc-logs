[00:00:08] <strcat> you want to see what the code looks like when you write a loop and it inlines next (as it will)
[00:00:46] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[00:00:49] <ezyang> ...hang on, I think I may have messed it up 
[00:00:52] *** Quits: tautologico (iorek@E0D804D3.CFE755C8.C27E1635.IP) (Quit: zzz)
[00:02:23] *** Joins: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz)
[00:02:34] *** Quits: alan (alan@moz-FE02DD30.sat6.rackspace.com) (Ping timeout)
[00:02:39] <ezyang> nope, alternate writing style still has the problem 
[00:03:18] <strcat> ezyang: I'm not sure exactly what you're doing, but for a meaningful output you need a loop using the iterator
[00:03:41] <acrichto> agrif: sure! I'll comment with my own thoughts as well
[00:03:45] <ezyang> So, I don't believe that; this should be something that holds locally 
[00:03:55] <strcat> the code you would get for the iterator body itself isn't relevant because iterators are used in loops, and the compiler won't output the iterator body as a function
[00:04:06] <strcat> ezyang: what's the code?
[00:04:25] <ezyang> http://lpaste.net/96663 
[00:04:33] <agrif> acrichto: the main rust repo then? or the repo for the llvm submodule?
[00:04:37] <ezyang> See the line "//  XXX unfortunately, this has runtime consequence" 
[00:04:57] <acrichto> agrif: definitely the main rust repo, it's a rust problem, not really an llvm problem
[00:05:50] <ezyang> but let me code up a quick function using the iterator 
[00:06:02] *** Quits: jmgrosen (jmgrosen@moz-A3814C08.sd.sd.cox.net) (Quit: jmgrosen)
[00:06:12] <strcat> ezyang: there are a lot of pointers here and LLVM is going to be quite restricted in what it can do by pointer aliasing
[00:06:35] <ezyang> That's understandable 
[00:06:44] <ezyang> it's just unfortunate that Rust can't give a helping hand here 
[00:06:55] <strcat> it could give a helping hand
[00:07:01] <strcat> it doesn't output aliasing info
[00:07:10] <ezyang> s/can't/doesn't/ 
[00:07:37] <strcat> the existing body of often incorrect rust code (technically unsound unsafe code) is the main barrier to that
[00:07:47] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[00:07:55] <ezyang> :( 
[00:08:00] <strcat> maybe I'll submit a PR with some of the stuff I wrote behind a -Z flag
[00:08:14] <strcat> it's not sound with libstd/libsyntax
[00:08:38] <strcat> (they making aliasing &mut ptrs, they cast & to &mut and mutate through it, and so on)
[00:09:12] <ezyang> That reminds me (cc dbaupp) should I submit a PR changing dlist to use replace instead of transmute? 
[00:09:16] *** Joins: Skif_ (emschwar@moz-CA025D57.ip.mcleodusa.net)
[00:09:25] <ezyang> As we have discovered here, it will be less efficient 
[00:09:33] *** Joins: patrickkim (Mibbit@B4104EBB.3CC170B1.1E14B209.IP)
[00:10:31] *** Quits: Skif (emschwar@moz-CA025D57.ip.mcleodusa.net) (Ping timeout)
[00:10:41] <ezyang> cmr: I was thinking about your delete code, and I realized that they way that you are doing it is non-idiomatic 
[00:10:50] <cmr> ezyang: quite possibly.
[00:10:52] <ezyang> Idiomatic C would do this by maintaining both a current and a prev pointer 
[00:10:55] *** Parts: patrickkim (Mibbit@B4104EBB.3CC170B1.1E14B209.IP) ()
[00:11:01] *** Quits: Skif_ (emschwar@moz-CA025D57.ip.mcleodusa.net) (Ping timeout)
[00:11:11] <ezyang> So now I was thinking about how to do this under Rust's ownership rules (forget about iterators for a moment) 
[00:11:21] <ezyang> and... I don't know how to do it, without mutating the link in prev 
[00:11:35] <ezyang> (unconditionally mutating, I should say) 
[00:11:39] <strcat> there's no point in including data structures in the stdlib if they're not fast
[00:11:40] <ezyang> because otherwise the pointers will alias 
[00:11:47] *** Joins: tcr (tcr@moz-6FEAEFBC.hfc.comcastbusiness.net)
[00:12:04] <ezyang> "there's no point in including data structures in the stdlib if they're not correct" 
[00:12:08] *** Quits: smodo (ford_p@moz-6398EFDF.dclient.hispeed.ch) (Client exited)
[00:12:11] <strcat> it's not correct?
[00:12:16] <strcat> unsafe block != incorrect
[00:12:17] *** Joins: jmgrosen (jmgrosen@moz-A3814C08.sd.sd.cox.net)
[00:12:57] <ezyang> yeah, but the burden of proof is higher :) 
[00:13:05] <strcat> ezyang: not really
[00:13:06] *** Quits: AvianFlu (AvianFlu@moz-723527FF.nycmny.fios.verizon.net) (Ping timeout)
[00:13:08] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[00:13:10] <agrif> acrichto: https://github.com/mozilla/rust/issues/10842
[00:13:16] <strcat> ezyang: a bug is a bug
[00:13:26] *** Quits: jdm (jdm@CAB30FBD.8F96AEA7.2D179A7D.IP) (Quit: Lost terminal)
[00:13:37] <strcat> ezyang: lets say vector reserve has a bug, although not a bug causing memory corruption
[00:13:43] <strcat> the bug involves it not reserving enough
[00:14:03] <strcat> it doesn't matter that reserve isn't corrupting memory itself - a bug is a bug
[00:14:03] <ezyang> The point of the type system is to reduce the class of possible bugs 
[00:14:07] <strcat> unsafe code is going to use reserve
[00:14:14] <strcat> any code used by unsafe code needs to be correct too
[00:14:20] <ezyang> If you step all over the type system, your class of possible bugs is bigger too 
[00:14:23] <strcat> code being safe doesn't really reduce the burden of correctness
[00:14:27] <strcat> unless no unsafe code uses it
[00:14:49] *** Quits: lenstr (lenstr@6CD9B9BF.9636F313.7A27613B.IP) (Ping timeout)
[00:15:00] <strcat> if avoiding unsafe makes it easier to write, then great
[00:15:02] <ezyang> well-typed code cannot be blamed! 
[00:15:07] <strcat> ezyang: yes it can
[00:15:12] <strcat> a bug is a bug
[00:15:20] <ezyang> Sorry, I'm just reciting a tagline here :) 
[00:15:21] *** Joins: Sgeo (quassel@moz-D0F30617.dyn.optonline.net)
[00:15:23] *** jorendorff_away is now known as jorendorff
[00:15:28] <strcat> ezyang: in order for unsafe code to be correct, the safe code it calls must be correct
[00:15:37] <strcat> it has to make assumptions about that safe code
[00:15:37] <acrichto> agrif: thanks!
[00:16:01] <strcat> I don't think unsafe is the panacea many people paint it as
[00:16:46] <strcat> it's useful, but safe code still has the burden of being correct to maintain memory safety
[00:17:01] <strcat> because unsafe code is going to end up using it
[00:17:15] *** Joins: mib_9re2uv (Mibbit@moz-EE117ADE.protectedgroup.com)
[00:17:23] *** Quits: mib_9re2uv (Mibbit@moz-EE117ADE.protectedgroup.com) (User has been banned from Mozilla (no spamming here))
[00:17:25] <ezyang> OK, sorry, I'm going to argue with you some more 
[00:17:29] *** Joins: caryhaynie (Mibbit@7BAAD356.9A4BE3FD.5A42B74E.IP)
[00:17:36] <wycats_> binary operation + cannot be applied to type `&mut u32`
[00:17:38] <wycats_> WAT
[00:17:38] <ezyang> Unsafe code is under the obligation to vet the safe code it relies on 
[00:17:44] <wycats_> do I need to dereference?
[00:17:48] <strcat> ezyang: so if I write an unsafe block, I have to vet the stdlib?
[00:17:51] <wycats_> *v + 1?
[00:17:52] <erickt> wycats_: yep
[00:17:57] <ezyang> When you write unsafe code, you are increasing the size of the TCB. 
[00:18:07] <wycats_> what a TCB is?
[00:18:08] *** Joins: lenstr (lenstr@6CD9B9BF.9636F313.7A27613B.IP)
[00:18:10] <ezyang> Any code you rely on also gets imported into the TCB 
[00:18:16] <ezyang> trusted computing base 
[00:18:29] <strcat> ezyang: and the stdlib is basically all trusted
[00:18:35] <ezyang> You don't have an obligation to vet the stdlib. You do have an obligation (IMO) to vet the parts of it you use. 
[00:18:36] <strcat> because it's used in unsafe blocks all over the place
[00:18:48] <strcat> the stdlib has a high burden of being correct
[00:18:48] <wycats_> oh man fn insert_or_update_with is a weird function?
[00:19:03] <strcat> if something is too complex to maintain with a high level of correctness, it doesn't belong in the stdlib
[00:19:10] <wycats_> you should absolutely not have to vet the stdlib
[00:19:15] <strcat> I feel that way about async I/O and M:N threading
[00:19:16] <wycats_> the stdlib should be assumed to be exporting a safe interface
[00:19:32] <strcat> rust's I/O, scheduler and tasks are a *huge* level of complexity
[00:19:46] <strcat> good luck making it correct, let alone having a high level of proof that it's correct ;p
[00:19:56] <strcat> and all code is basically using it
[00:19:57] <wycats_> if I have a &mut u32, how do I replace its value?
[00:19:58] *** Quits: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com) (Ping timeout)
[00:20:01] <wycats_> :boggle:
[00:20:04] <sfackler> *foo = 10;
[00:20:08] * strcat shrugs
[00:20:23] <wycats_> got it
[00:20:25] <wycats_> weird API
[00:20:33] <ezyang> Perhaps the ship has already sailed on this one, but I would prefer my stdlib to use as few unsafe blocks as possible. 
[00:20:37] <strcat> ezyang: there's unsafe code using hash maps, vectors, all kinds of concurrent/atomic stuff
[00:20:39] *** Joins: ofeldt- (ofeldt@moz-A9DE3D98.dip0.t-ipconnect.de)
[00:20:39] <sfackler> wycats_: why?
[00:20:47] <cmr> wycats_: it's not weird, it's a pointer!
[00:20:50] <brson> strcat: your enthusiasm for our work fills me with joy
[00:20:54] <strcat> ezyang: well you see the stdlib differently then
[00:20:57] <tiffany> rusti: let foo = &mut 4u; *foo = 5; foo
[00:20:58] -rusti- pastebinned 16 lines of output: http://sprunge.us/MZQT
[00:21:08] <strcat> ezyang: I think the job is the stdlib is to write 90% of the unsafe code you're going to need
[00:21:14] <wycats_> cmr: the weird thing is not that it's a pointer
[00:21:23] <cmr> wycats_: &mut is certainly a pointer?
[00:21:23] <wycats_> it's that insert_or_update_with expects you to mutate it
[00:21:27] *** Quits: ofeldt (ofeldt@moz-B9131D79.dip0.t-ipconnect.de) (Ping timeout)
[00:21:42] <wycats_> and weird only by my existing brain
[00:21:45] <wycats_> not by reality
[00:21:50] <ezyang> strcat: I'd think of it another way. If writing the hash table in the stdlib requires unsafe code, then why do I have any expectation that I'd be able to write something similar without unsaef code? 
[00:22:00] <ezyang> It is an indictment of the type system/borrow system 
[00:22:03] *** Quits: dherman (dherman@moz-DFAA4E15.p2p.sfo1.mozilla.com) (Quit: dherman)
[00:22:05] <strcat> the hash table in the stdlib doesn't require unsafe code
[00:22:07] <strcat> vectors do
[00:22:10] <ezyang> ok yay :) 
[00:22:12] <strcat> and there's unsafe code using hash tables
[00:22:20] <strcat> so hash tables are 'unsafe code' in the sense that they're assumed to be correct
[00:22:41] <ezyang> Well, to go back to the particular instance here, why do I need to use unsafe code to write fast linked list traversals? 
[00:22:52] <strcat> I don't think you do
[00:22:55] <wycats_> ezyang: I think there's an assumption that the low-level abstractions in your system will be written using unsafe code (at least at the moment?)
[00:23:04] *** Quits: cantsin (cantsin@moz-F99612CC.members.linode.com) (Ping timeout)
[00:23:04] *** Quits: tedh (tedh@moz-F3B34318.hsd1.il.comcast.net) (Ping timeout)
[00:23:09] <wycats_> and that it's on you to keep that interface those abstractions support safe
[00:23:14] <wycats_> am I wrong?
[00:23:30] <strcat> a linked list traversal is probably not going to be sped up much by micro-optimizing instructions though
[00:23:32] <kimundi> wycats_: No that's pretty much right
[00:23:36] <benh> You need unsafe code to write mutable linked-list transversal that fits the constrains of the iterator api
[00:23:36] <ezyang> Is provably memory safe too much to ask :? 
[00:23:41] <strcat> it's slow because it pays for a cache miss on nearly every node traversal
[00:23:47] <benh> because the iterator api is limited by the type system afaiui
[00:23:53] <strcat> ezyang: are you going to prove everything memory safe bottom-up then?
[00:23:56] *** Joins: cantsin (cantsin@moz-F99612CC.members.linode.com)
[00:23:59] <strcat> is the linux kernel memory safe? not completely
[00:24:09] <strcat> is libc? (pthreads, etc.) not completely
[00:24:19] <ezyang> I'm happy to trust some amount of TCB. But I expect simple things to work out to be memory safe by construction 
[00:24:20] <strcat> is libuv memory safe? it's new enough and brittle enough that I'd say definitely no
[00:25:05] *** Quits: icebattle (icebattle@8A14A542.EBE2EE2B.C7CEC4ED.IP) (Quit: Leaving)
[00:25:08] <ezyang> I am actually not too worried about the iteration. I am a bit worried about element removal. 
[00:25:57] <wycats_> if I have a struct with an element that's HashMap<T, U>, do I always need to duplicate the T, U in my `new`?
[00:26:03] <wycats_> or is there a way to get it to be inferred?
[00:26:20] *** Joins: tedh (tedh@moz-F3B34318.hsd1.il.comcast.net)
[00:27:10] <kimundi> wycats_: Unless I misunderstand, inference should allow you to leave of either declaration
[00:27:17] <strcat> ezyang: I don't think you can expect to be able to write code at a C level of performance without unsafe {}
[00:27:29] <kimundi> ezyang: What kind of removal?
[00:27:42] *** Quits: Sharp (Sharp@1710C26.8381A41.8725677B.IP) (Quit: Sharp)
[00:27:43] <strcat> I don't think it's a reasonable expectation
[00:27:55] <strcat> there are a lot of cost-free abstractions you can build
[00:27:57] <wycats_> kimundi: you are correct
[00:27:59] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Ping timeout)
[00:28:10] <strcat> but if you truly want to micro-optimize something, you're usually going to end up using unsafe {}
[00:28:13] <ezyang> kimundi: I'm iterating through list, I get to some node, and decide I want to remove it. 
[00:28:45] <ezyang> strcat: I mean, surely avoiding the spurious mutation of all the pointers in a list is not a micro-optimization? 
[00:29:03] <strcat> a list traversal is slow because of a cache miss for every element
[00:29:10] <ezyang> It's pretty telling that dlist does not have a back_mut 
[00:29:23] <ezyang> That does not have to be true, especially if you allocated them linearly 
[00:29:35] <kimundi> ezyang: If you have a iterator that holds a immutable reference to that list, then the type system prevents any modification of an element
[00:29:40] <strcat> ezyang: you can't allocate them linearly
[00:29:40] <sfackler> ezyang: I don't know if it's telling, of if it just hasn't been written. I don't think dlist is used very heavily
[00:29:50] <strcat> the stdlib doesn't have allocators
[00:30:02] <ezyang> kimundi: Not using an iterator, of course 
[00:30:16] <strcat> and allocators are really annoying atm anyway
[00:30:29] <strcat> they add far more complexity to everyday code than they're worth without default type parameters
[00:30:41] <ezyang> strcat: Sure? 
[00:31:37] <ezyang> It sounds like linked lists are not used very frequently in Rust-land 
[00:31:46] <strcat> they aren't used much in C++ or Rust
[00:31:55] <strcat> non-intrusive lists aren't very useful
[00:32:02] <tiffany> I very rarely use linked lists in C
[00:32:32] *** Joins: eddyb (eddy@moz-68E0B7D0.residential.rdsnet.ro)
[00:32:34] <strcat> they're commonly used in C because there aren't data structures in the stdlib and a linked list is easy to write
[00:33:52] <tiffany> I found it a lot easier and maintainable to implement appendable, buffered vectors in preprocessor
[00:34:05] <strcat> I don't really see a way to write intrusive data structures in rust without Gc<RefCell<T>> or raw ptrs
[00:34:08] <tiffany> there was a time when I used a lot of linked lists but they were very error prone and had segfaults a lot
[00:34:50] *** Quits: skeet70 (skeet70@moz-2578911E.bzm-mt.client.bresnan.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[00:35:55] <strcat> in highly optimized data structures I don't think unsafe can be avoided
[00:36:28] <strcat> you're going to end up having at least a few unnecessary swaps in any linked data structure
[00:36:50] <ezyang> WEll, I don't mind O(1) unnecessary swaps 
[00:36:55] <ezyang> O(n) will get on my nerves though... 
[00:37:12] <tiffany> there's a lot of things that are implemented on unsafe though
[00:37:14] <tiffany> so it's pretty fair
[00:37:22] <ezyang> tiffany: Well, the promise of Rust ought to be, you can use linked lists, *and* not have segfaults! 
[00:37:48] <strcat> you can write data structures with safe code
[00:38:01] <strcat> you can write micro-optimized data structures exposing a safe interface
[00:38:09] <strcat> I don't think there's a problem
[00:38:15] *** Quits: eddyb (eddy@moz-68E0B7D0.residential.rdsnet.ro) (Ping timeout)
[00:38:55] <tiffany> I'm not sure it would be possible, and if it is, worth the effort, to add the complexity required to efficiently express low level data structures like linked lists safely
[00:39:12] <tiffany> are vectors implemented in terms of safe code?
[00:39:22] <strcat> tiffany: the whole compiler is an unsafe block
[00:39:30] <strcat> it doesn't matter if you put the code in the compiler or the stdlib
[00:39:34] <strcat> it's trusted either way
[00:39:37] <tiffany> exactly
[00:39:40] <strcat> except in the compiler it's usually harder to get right
[00:39:55] <strcat> it's only worth including as a language feature if it's a highly reusable concept
[00:40:15] *** Quits: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[00:40:38] <strcat> when you compile rust, you're trusting the whole LLVM stack, the linker, the rust compiler, the kernel, libc, etc. in addition to any unsafe blocks in the stdlib
[00:41:03] <strcat> I don't think a few unsafe blocks building reusable concepts are a big issue
[00:41:31] <tiffany> me either
[00:43:16] <strcat> if there's a huge level of complexity that has to be trusted then I think that's a problem
[00:43:20] <strcat> like if you write a whole red-black tree
[00:43:22] <strcat> and you use unsafe code
[00:43:23] *** Quits: tgummerer (tgummerer@moz-582025B2.members.linode.com) (Ping timeout)
[00:43:25] <strcat> that's too much.
[00:43:27] <strcat> or a B-tree
[00:43:45] <strcat> you really need small, reusable building blocks for writing that without unsafe code
[00:43:55] <strcat> and we don't currently have a good answer for that
[00:44:19] <strcat> TreeMap is a simplified version of an rbtree so it's not very complex
[00:44:28] <strcat> but it's made a lot more complex by all the type system workarounds you have to do
[00:44:41] <strcat> I don't think it'd be much worse to write it with *simpler* unsafe code
[00:45:00] <strcat> but if it was a B-tree or a full rbtree... that's a lot of code
[00:45:18] <ezyang> Ah! And to that I would say 
[00:45:29] <strcat> unwinding adds a lot of burden to unsafe code too
[00:45:30] <ezyang> What ever mechanism you add to make this work out, it will surely work for linked lists. 
[00:45:30] <dbaupp> strcat: has TreeMap it been updated to remove the contortions you(?) had to do to get around the old borrowck?
[00:45:45] <strcat> dbaupp: there are a lot of contortions it would still have to make today
[00:45:47] <ezyang> So linked lists are the litmus test, by which you can judge whether the more complicated thing might possible work 
[00:45:52] <strcat> I'm not sure that it can be simplified
[00:46:38] <strcat> ezyang: I don't think there will necessarily be an answer to writing provably memory safe trees without a performance compromise
[00:46:48] <ezyang> I agree. 
[00:46:49] *** Joins: synackse (synackse__@7DAC4ACE.77F880E0.D9401097.IP)
[00:47:06] <strcat> I don't really expect rust to change in a way that would allow TreeMap to be as fast as the unsafe version I wrote at the same time
[00:47:07] <ezyang> And, I *expect* to have to write them differently in order to show memory safety 
[00:47:57] <strcat> when everything is in CPU cache, TreeMap is 2x slower at inserts/deletions than the unsafe code
[00:48:01] <strcat> searches are the same speed
[00:48:32] <strcat> when stuff doesn't happen to have a lot of data locality then it's not significantly slower
[00:48:39] *** jorendorff is now known as jorendorff_away
[00:48:47] *** Quits: tjc (tjc@moz-6EB4E533.dsl.tsoft.com) (Quit: Textual IRC Client: www.textualapp.com)
[00:49:05] <strcat> it looks bad in microbenchmarks though
[00:49:08] *** Quits: jmgrosen (jmgrosen@moz-A3814C08.sd.sd.cox.net) (Quit: jmgrosen)
[00:49:48] *** Joins: tgummerer (tgummerer@moz-582025B2.members.linode.com)
[00:49:56] <strcat> rust's hash tables look extraordinarily bad in a naive microbenchmark due to SipHash, too - I don't know a good solution to that and it seems more important than lists/trees to me
[00:50:07] *** Quits: donri (donri@moz-9BB61102.tbcn.telia.com) (Client exited)
[00:50:08] <strcat> (and hash tables are also slow in a real world example)
[00:50:38] <wycats_> strcat: it depends on what you're using the hashes for
[00:50:54] <wycats_> someone write TurboButtonHash
[00:50:58] <wycats_> :P
[00:51:00] <strcat> SipHash is reasonably fast for medium to long strings
[00:51:08] <strcat> it's ridiculously slow for fixed-size integers
[00:51:16] <strcat> I think we desperately need a solution to that
[00:51:21] <Luqman> i wonder if fnv would an ok choice
[00:51:32] <wycats_> aren't hashes basically a data structure that works reasonably well for most cases but you need to fine-tune for best speed for particular applications?
[00:51:35] <wycats_> just, in general?
[00:51:35] <strcat> Luqman: well that's not really going to work for integers either afaik
[00:52:37] <strcat> wycats_: rust's hash tables put the guarantee of reasonable performance in the face of pathological inputs first
[00:52:47] <strcat> wycats_: they don't really perform well
[00:52:52] <wycats_> strcat: aren't there integer-friendly hashes?
[00:53:35] <strcat> wycats_: SipHash is the only fast hash function with this guarantee AFAIK
[00:53:59] <strcat> it has a lot of setup work
[00:54:04] <strcat> so it's no good for fixed-size integers
[00:54:07] *** Joins: skeet70 (skeet70@moz-2578911E.bzm-mt.client.bresnan.net)
[00:54:15] <wycats_> strcat: I meant a small integer-friendly HashMap in Rust
[00:54:15] <strcat> as in the cycles per byte for a long string is okay
[00:54:22] <wycats_> there's TreeMap
[00:54:23] <strcat> but the cycles per byte for a short input is *HUGE*
[00:54:46] <strcat> wycats_: we can't provide a fast hash map without using a hash function without this guarantee
[00:55:02] <strcat> unless someone recruits a few cryptographers and sets them to work designing a PRF for fixed-size integers
[00:55:50] <wycats_> strcat: so what do you suggest?
[00:56:11] <strcat> I don't really have a suggestion
[00:56:19] <strcat> just stating that slow hash tables is a big issue
[00:56:25] <strcat> it's a big part of why rustc is slow
[00:56:39] <strcat> I don't think rustc needs the pathological input guarantee at all
[00:56:52] <ezyang> "you know, hash tables have linked lists in them too" 
[00:56:59] <strcat> ours don't
[00:57:07] <ezyang> oh, what do you use for collisions? 
[00:57:12] <strcat> open addressing
[00:57:13] <ezyang> linear probing? 
[00:57:17] <strcat> yes
[00:57:52] <wycats_> strcat: I don't see why HashMapWithSmallIntKeys isn't your suggestion then
[00:57:59] <wycats_> and I thought acrichto said that existed
[00:58:00] <ezyang> Just linear probing, or something more sophisticated? 
[00:58:08] <strcat> ezyang: yes just linear probing
[00:58:10] <strcat> ezyang: SipHash is designed as a PRF, meaning it's indistinguishable of a completely random assignment of each key to a bucket
[00:58:22] <strcat> so since we're already paying a huge price for it, we don't need expensive collision handling
[00:58:50] <wycats_> acrichto: ^^
[00:58:58] <strcat> there are no known patterns in the SipHash distribution of keys
[00:59:03] *** Quits: caryhaynie (Mibbit@7BAAD356.9A4BE3FD.5A42B74E.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[00:59:11] <strcat> the hash tables get a unique 128-bit seed used to key the hash
[00:59:17] <acrichto> wycats_: extra::smallintmap
[00:59:30] <wycats_> strcat: ^^
[00:59:40] <wycats_> why doesn't that solve your problem?
[00:59:40] <strcat> wycats_: that's just an array
[00:59:49] <sfackler> wycats_: it's hash function is x => x
[00:59:51] <sfackler> *its
[01:00:06] <strcat> wycats_: put 10000000 in it, you now have a 10000000 long array
[01:00:12] <cmr> and it's not sparse.
[01:00:13] <wycats_> so verysmallinthash
[01:00:16] *** Quits: tedh (tedh@moz-F3B34318.hsd1.il.comcast.net) (Ping timeout)
[01:00:30] <strcat> wycats_: the issue isn't the hash table
[01:00:32] <strcat> it's the hash function
[01:00:36] <wycats_> strcat: so your complaint is that we're doing extra work that SipHash renders somewhat moot?
[01:00:45] <strcat> no
[01:00:50] <wycats_> or that SipHash is a bad hash function?
[01:00:55] <strcat> not that either
[01:00:58] <wycats_> tellme
[01:01:05] <wycats_> s/bad/unnecessarily expensive/
[01:01:22] <strcat> SipHash is an unacceptably expensive hash function for fixed-size integers
[01:01:39] <wycats_> strcat: as opposed to something stupid simple like %?
[01:01:49] <strcat> % is expensive
[01:01:52] <strcat> ;p
[01:01:57] <wycats_> strcat: cheaper than SipHash?
[01:01:57] <wycats_> :P
[01:02:01] <strcat> wycats_: sure
[01:02:03] <strcat> division is too expensive for an integer hash function though
[01:02:13] <wycats_> strcat: what's the right one?
[01:02:27] <strcat> python, libstdc++ and libc++ use the identity function
[01:02:37] *** Parts: thewonderidiot (mstewart@moz-E41129BA.ipnetworksinc.net) ()
[01:03:52] <strcat> wycats_: a common way to do it is to multiply by the inverse of the golden ratio
[01:04:05] <strcat> it perfectly spreads out an ascending/descending sequence that way
[01:04:10] *** Joins: tedh (tedh@moz-F3B34318.hsd1.il.comcast.net)
[01:04:14] <strcat> and is Good Enough in almost any other case
[01:04:27] <wycats_> hm Ruby seems to use sip_hash24
[01:04:30] <strcat> it also spreads out a sequence in a way that's still fairly data local
[01:04:42] <strcat> wycats_: what ruby/python do doesn't really matter
[01:04:43] *** Quits: peterdn (chatzilla@moz-5EB9CC81.as13285.net) (Ping timeout)
[01:04:45] <strcat> their hash function is C
[01:04:46] <wycats_> strcat: I know
[01:04:49] <wycats_> I was just investigating
[01:04:57] <wycats_> since you said python used identity
[01:05:00] <wycats_> I was curious :)
[01:05:03] <strcat> wycats_: for integers ;p
[01:05:09] <strcat> ruby might not use siphash for integers
[01:05:11] <wycats_> strcat: this is for numerics
[01:05:12] <wycats_> it does
[01:05:15] * strcat shrugs
[01:05:18] <wycats_> I think
[01:05:24] <strcat> python uses a ridiculous hash for strings
[01:05:30] <Luqman> bjz: oh btw, i got your gist that was causing an llvm assert working in my branch
[01:05:33] <strcat> it's slower than SipHash without the strong guarantee
[01:05:39] *** Quits: skeet70 (skeet70@moz-2578911E.bzm-mt.client.bresnan.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[01:05:39] <strcat> they're just using it because they're stubborn
[01:05:44] *** Joins: gandalf (zbraniecki@moz-DFAA4E15.p2p.sfo1.mozilla.com)
[01:05:46] <wycats_> hm no that's for floats
[01:06:04] <strcat> wycats_: sec
[01:06:57] <strcat> wycats_: http://ix.io/9ht those are some ballpark numbers, using C++
[01:07:37] *** Quits: bjz (bjz@moz-C1B1AF2A.lnse2.cha.bigpond.net.au) (Ping timeout)
[01:07:38] <strcat> inserting, searching for and removing 1000000 keys
[01:07:46] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[01:07:57] <strcat> doing it for random keys would be useful too
[01:08:43] <strcat> anyway SipHash won't really have any advantages over fibonacci hashing on any real world inputs for integers
[01:09:07] <wycats_> Ruby uses st_hash_* for integers
[01:09:18] <wycats_> strcat: sounds like you have a proposal
[01:09:21] <wycats_> what is it?
[01:09:27] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[01:09:28] <strcat> wycats_: I don't have a proposal ;p
[01:09:42] <wycats_> "the current situation is bad, I have no idea how to improve it" c/d
[01:10:05] <strcat> I know how to swap out the problem for another (not having a strong O(1) guarantee)
[01:10:15] <wycats_> strcat: the solution is to have another class no?
[01:10:26] <wycats_> HashMapForSomeSubsetOfCasesButWhichIsFaster
[01:11:51] <benh> if only we had template specialization~
[01:11:57] <wycats_> if only
[01:12:13] <cmr> it uses the Hash implementation for the type.
[01:12:15] * strcat wants a cryptographer to make him a PRF for fixed-size ints
[01:13:25] <benh> Just ask on StackOverflow for one~
[01:13:30] <wycats_> strcat: I bet the NSA is listening
[01:13:33] <strcat> hash(bytes, 128 bit key) -> 64-bit integer is what SipHash does
[01:13:34] <wycats_> just ask them
[01:13:42] <benh> cryptographers need karma too, right?
[01:13:55] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[01:13:56] <strcat> hash(32-bit integer, 128 bit key) -> 64-bit integer is a much easier task
[01:14:00] <strcat> although I have no idea have to do it ;p
[01:14:34] <strcat> it removes the 'compression function' part of the issue
[01:14:48] <strcat> you don't have to compress some arbitrarily sized input, you know how big the input is
[01:14:59] <strcat> just have to mix in the key somehow
[01:15:07] <strcat> maybe there's an existing primitive we can use
[01:15:11] * strcat doesn't know
[01:15:29] <strcat> all I know is that it's not as simple as XOR ;p
[01:15:32] <wycats_> strcat: pdf
[01:15:35] <wycats_> pdi*
[01:15:37] <wycats_> please do investigate
[01:16:09] <strcat> since if you have 0000 and 0001, and some key xxxx, the keys are still very related after you XOR them against the key
[01:16:10] <strcat> doesn't help
[01:16:30] <strcat> need that magical waterfall stuff
[01:17:03] *** Quits: Ralith (ralith@A8995AA9.62B6AF6A.922221DB.IP) (Ping timeout)
[01:18:04] *** Quits: markwash (mwashenber@moz-60E5DD0C.staticcust.wsteleport.net) (Quit: markwash)
[01:18:39] *** Quits: lenstr (lenstr@6CD9B9BF.9636F313.7A27613B.IP) (Ping timeout)
[01:19:50] <strcat> well
[01:20:04] <strcat> I guess rather than a hash function I should be looking for a fast block cipher
[01:20:21] <strcat> are there 16/32/64-bit block ciphers? ;p
[01:20:55] <strcat> we just need a modern DES
[01:21:57] *** Quits: ricepuddin (graham@moz-7D68765A.cable.virginm.net) (Ping timeout)
[01:22:15] <cmr> 7DES
[01:22:20] <cmr> clearly just stacking more on top makes it more modern
[01:22:39] <strcat> AES-NI can do AES in 3.5 cycles per byte
[01:23:02] <strcat> I don't think there's significant setup
[01:23:20] *** Joins: fournm (Aria@moz-ABB60BA0.austin.res.rr.com)
[01:23:20] <strcat> but anyway going to be way too slow without it ;\
[01:23:39] <strcat> slower than SipHash? maybe not. SipHash has to do a lot of compression-specific setup
[01:28:07] <dbaupp> Do we need to guarantee consistent hashing (for hashmaps specifically) cross-platform?
[01:29:01] *** Quits: tcr (tcr@moz-6FEAEFBC.hfc.comcastbusiness.net) (Client exited)
[01:29:22] *** Joins: tcr (tcr@moz-6FEAEFBC.hfc.comcastbusiness.net)
[01:29:25] *** Joins: markwash (mwashenber@moz-60E5DD0C.staticcust.wsteleport.net)
[01:29:53] *** jorendorff_away is now known as jorendorff
[01:30:10] *** Quits: tcr (tcr@moz-6FEAEFBC.hfc.comcastbusiness.net) (Connection reset by peer)
[01:30:25] <strcat> dbaupp: no, because it can be made into an internal detail of the map
[01:30:36] *** Joins: tcr (tcr@moz-6FEAEFBC.hfc.comcastbusiness.net)
[01:30:38] <strcat> (we might want a consistent hash, but we don't have to use it consistently)
[01:30:56] <dbaupp> strcat: should we therefore defer to hardware on platforms which support it?
[01:31:19] <strcat> we still have to pick a way to implement it ;p
[01:32:30] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[01:33:37] <agrif> is there a function all(&[bool]) -> bool that acts like all() in python?
[01:33:42] <agrif> I can't seem to find anything
[01:33:42] <tikue> i think so
[01:34:04] <agrif> for whatever reason the docs search doesn't work when I search for 'all'
[01:34:12] <tikue> agrif: it's on iterators
[01:34:18] <agrif> ok
[01:34:19] <cmr> search requires > 3 characters
[01:34:23] <cmr> but yes, iterators have it.
[01:34:30] <strcat> agrif: http://static.rust-lang.org/doc/master/std/iter/trait.Iterator.html
[01:34:36] <agrif> strangely, the search works for 'a'
[01:34:51] <tikue> agrif: if you have some vector, you can do vec.iter().all(|el| condition(el))
[01:35:03] <agrif> got it, thanks
[01:35:13] <SiegeLord> Can you print a floating number with an exponent?
[01:37:51] <mark_edward> i wish we had a dictionary type that just need Dict<T: Eq>
[01:38:09] <mark_edward> i mean Dict>K: Eq, V>
[01:38:22] <mark_edward> i mean Dict<K: Eq, V>
[01:38:32] <cmr> that would be so incredibly slow
[01:38:33] <sfackler> wouldn't that just be a ~[(K, V)]?
[01:38:43] <dbaupp> mark_edward: i.e. ~[(K,V)] with wrapper methods?
[01:38:56] <mark_edward> dbaupp, maybe. isn't that how python dicts are?
[01:39:00] <cmr> no
[01:39:00] <o11c> no
[01:39:00] <strcat> no
[01:39:02] <cmr> not at all
[01:39:04] <cmr> they're hash maps
[01:39:15] <o11c> every dict requires either hash+eq or less
[01:39:18] <mark_edward> what do i have to do to impl Hash for a type?
[01:39:26] <o11c> (except some that are specialized for ints)
[01:39:34] <strcat> mark_edward: implement IterBytes
[01:39:35] *** Joins: Sharp (Sharp@1710C26.8381A41.8725677B.IP)
[01:39:37] <o11c> (but you can hash or less ints anyway)
[01:40:16] <strcat> mark_edward: or implement Ord and use TreeMap
[01:40:34] <strcat> can use deriving
[01:41:29] <mark_edward> strcat, TreeMap needs TotalOrd, doesn't it?
[01:42:05] <strcat> in the stdlib ;p
[01:42:19] *** Joins: ricepuddin (graham@moz-7D68765A.cable.virginm.net)
[01:42:35] <mark_edward> strcat, what do you mean?
[01:42:49] *** Quits: tcr (tcr@moz-6FEAEFBC.hfc.comcastbusiness.net) (Ping timeout)
[01:42:50] *** Joins: tcr (tcr@moz-6FEAEFBC.hfc.comcastbusiness.net)
[01:42:51] <SiegeLord> Looks like you can't... that seems like a big omission
[01:43:19] <strcat> I mean I don't think TotalEq/TotalOrd need to exist, floats just shouldn't implement Eq/Ord because they don't meet the requirements we should have for them
[01:43:56] <strcat> having both is too complex
[01:44:04] *** Quits: markwash (mwashenber@moz-60E5DD0C.staticcust.wsteleport.net) (Quit: markwash)
[01:44:08] <strcat> and functions like min/max implemented with Ord don't do the right thing for floats
[01:45:28] *** Quits: tcr (tcr@moz-6FEAEFBC.hfc.comcastbusiness.net) (Ping timeout)
[01:45:45] *** Joins: Ralith (ralith@moz-132F2FD4.sea.wa.customer.broadstripe.net)
[01:48:12] <SiegeLord> acrichto: When you made the new formatting system, was the omission of scientific format (i.e. %e in C's printf) a design decision? Or is it just unimplemented?
[01:48:59] <acrichto> SiegeLord: unimplemented
[01:49:41] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Client exited)
[01:50:01] *** Joins: tcr (tcr@moz-6FEAEFBC.hfc.comcastbusiness.net)
[01:50:33] *** Quits: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net) (Client exited)
[01:50:54] *** Joins: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net)
[01:52:41] *** Quits: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net) (Ping timeout)
[01:52:41] *** Quits: tcr (tcr@moz-6FEAEFBC.hfc.comcastbusiness.net) (Ping timeout)
[01:52:54] <ChrisMorgan> Is `const` valid anywhere in Rust any more, or is it always "obsolete syntax"?
[01:53:07] <ssbr_> strcat: That's a really neat idea (having float not implement Eq/Ord and give Eq/Ord stronger requirements as a result)
[01:53:19] <cmr> ChrisMorgan: obsolete afaik
[01:53:28] *** Joins: lpy (lpy@7360AA58.F09091A8.1348A864.IP)
[01:53:37] * ChrisMorgan is highlighting reserved keywords as Error in Vim.
[01:54:12] <strcat> ssbr_: I have an issue open about it https://github.com/mozilla/rust/issues/10320
[01:54:22] <ssbr_> Are keywords like const valid inside a macro definition/usage?
[01:54:31] <strcat> ssbr_: https://github.com/thestinger/rust-core/blob/master/core/cmp.rs significantly simpler that way.
[01:55:00] <strcat> ssbr_: yes you can use any valid tokens inside macro!(foo const - for)
[01:55:02] *** jorendorff is now known as jorendorff_away
[01:55:12] *** Joins: tcr (tcr@moz-6FEAEFBC.hfc.comcastbusiness.net)
[01:55:22] <ssbr_> oh, is the only syntax it recognizes parens and braces and [] then?
[01:55:29] <cmr> anibg itgssbr_: 
[01:55:33] <cmr> well that died
[01:55:35] <strcat> wat?
[01:55:38] <cmr> among other things
[01:55:57] <strcat> ssbr_: afaik the only special thing in macros is $
[01:56:00] <ssbr_> or, ugh, nevermind, my thoughts are jumbled
[01:56:07] <strcat> and that's why $ can't be used elsewhere
[01:56:10] <ssbr_> strcat: I thought it checked your parens were balanced, but that isn't relevant
[01:56:12] <strcat> evil macros stealing all the money
[01:56:15] <cmr> rusti: stringify!( $ foo $ )
[01:56:16] -rusti- "$ foo $"
[01:56:41] <cmr> stringify!((%$@@@! )
[01:56:46] <cmr> rusti: stringify!((%$@@@! )
[01:56:47] -rusti- <anon>:10:4: 10:5 error: incorrect close delimiter: `}`
[01:56:48] -rusti- <anon>:10     };
[01:56:48] -rusti-               ^
[01:56:48] -rusti- application terminated with error code 101
[01:56:49] <cmr> rusti: stringify!((%$@@@! ))
[01:56:50] -rusti- "( % $ @ @ @ ! )"
[01:57:10] *** Quits: lpy (lpy@7360AA58.F09091A8.1348A864.IP) (Ping timeout)
[01:57:13] <cmr> ssbr_: afaik the only hard restriction on the tokens you give it is "balanced delimiters"
[01:58:00] *** Joins: lpy (lpy@7360AA58.F09091A8.1348A864.IP)
[01:58:27] *** Joins: willingc (willingc@moz-B4760708.san.res.rr.com)
[02:02:10] *** Joins: thewonderidiot (mike@moz-5506A033.hsd1.ca.comcast.net)
[02:03:44] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Quit: leaving)
[02:08:56] *** Joins: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com)
[02:09:14] <SiegeLord> rusti: format!("{:f}", 1.0)
[02:09:15] -rusti- ~"1"
[02:09:22] <SiegeLord> Should that be that or 1.000000 ?
[02:09:35] <SiegeLord> It's 1.000000 in C
[02:10:19] <strcat> it doesn't have to print like C
[02:10:27] <kimundi> SiegeLord: Imo it should be the shortest correct string :P
[02:10:33] <cmr> But what is correct?
[02:10:35] * ChrisMorgan agrees with kimundi
[02:10:37] <SiegeLord> What's correct?
[02:10:42] <cmr> "Results in the same float after from_str"?
[02:10:43] *** Joins: noy (user@moz-44A5916A.a146.priv.bahnhof.se)
[02:10:46] <cmr> "Most precise"?
[02:10:49] <cmr> floats are hard
[02:10:50] <SiegeLord> That's not what it does today
[02:10:57] <ChrisMorgan> I can see an argument for making it 1.0 rather than 1, still.
[02:11:01] * cmr recommends staying away from floats and strings.
[02:11:02] <kimundi> cmr: There are a few interesting papers about that
[02:11:04] <dbaupp> SiegeLord: https://github.com/mozilla/rust/issues/1375
[02:11:08] <strcat> cmr: you can represent every float as a decimal string precisely afaik
[02:11:10] *** Quits: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz) (Quit: Busying myself...)
[02:11:13] <strcat> 2 is a factor of 10
[02:11:16] <cmr> strcat: yes, you can.
[02:11:27] <SiegeLord> rusti: format!("{:f}", 1.2345678")
[02:11:27] -rusti- <anon>:11:16: 11:17 error: unknown start of token: ?
[02:11:27] -rusti- <anon>:11     println!("{:?}", r)
[02:11:27] -rusti-                           ^
[02:11:28] -rusti- application terminated with error code 101
[02:11:33] <cmr> But sometimes it can be represented as multiple strings iirc.
[02:11:36] <SiegeLord> rusti: format!("{:f}", 1.2345678)
[02:11:37] -rusti- ~"1.234568"
[02:11:40] <cmr> And the naive algorithm won't do it right
[02:12:06] <strcat> so what is rust printing by default?
[02:12:11] *** Quits: Sharp (Sharp@1710C26.8381A41.8725677B.IP) (Quit: Sharp)
[02:12:12] <ChrisMorgan> Whoa, "One of [GitHub's] mostly harmless robots seems to think [I am] not a human."
[02:12:16] <dbaupp> cmr: if you mean `0.09999999999999999999999999...` vs `0.1`, yes; otherwise, no there's a unique finite string for every float.
[02:12:32] <SiegeLord> Rust prints up to 6 digits
[02:12:45] <dbaupp> cmr: possibly very long, though.
[02:12:52] <cmr> mm
[02:13:07] <dbaupp> cmr: (and possibly requiring bigints to generate.)
[02:13:09] *** Joins: maxiepoo_ (Max@moz-6F50ADE.hsd1.il.comcast.net)
[02:13:10] *** Joins: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz)
[02:13:16] * dbaupp isn't 100% sure
[02:13:20] <dbaupp> ChrisMorgan: ?
[02:14:07] <ChrisMorgan> dbaupp: I just got this on the header on GitHub: "One of our mostly harmless robots seems to think you are not a human. Because of that, it's hidden your profile from the public. If you really are human, please contact support to have your profile reinstated. We promise we won't require DNA proof of your humanity."
[02:14:34] <cmr> ChrisMorgan: what have you been doing O_o
[02:14:36] <dbaupp> ChrisMorgan: https://github.com/chris-morgan/ you're dead! :O
[02:14:42] <ChrisMorgan> So until I do that, I more or less don't exist on GitHub.
[02:14:50] <SiegeLord> rusti: format!("{}", 1e0)
[02:14:52] -rusti- ~"1"
[02:14:56] <dbaupp> as is rust-http :O
[02:14:59] <strcat> ChrisMorgan: don't you like being a ghost?
[02:15:04] <strcat> anyway that's weird
[02:15:13] <ChrisMorgan> Oooooooooooooooooooooo...
[02:15:13] <kimundi> ChrisMorgan: Heh, the same happend to me too a few months back. Except I didn't see no header.
[02:15:26] <strcat> kimundi: well they decided you were a spammer, not just a robot
[02:15:32] <strcat> and hid all of your comments
[02:15:35] *** Quits: tikue (tkuehn@DB2ADAE8.E6CB677E.689607DE.IP) (Quit: tikue)
[02:15:35] <strcat> but your user page was there
[02:15:36] <mletterle> ChrisMorgan: WTF?
[02:15:38] <ChrisMorgan> What is bors?
[02:15:47] <cmr> ChrisMorgan: our integration bot
[02:15:49] <kimundi> ChrisMorgan: It was a fun day trying to find out why other people only saw 404 at the gist links I send them :P
[02:16:02] <strcat> ChrisMorgan: bors is a human, what are you talking about! ;p
[02:16:04] <ChrisMorgan> cmr: I mean, a robot? An approved robot? &c.
[02:16:14] <strcat> totally a human
[02:16:24] *** Quits: maxiepoo_ (Max@moz-6F50ADE.hsd1.il.comcast.net) (Quit: maxiepoo_)
[02:16:33] <dbaupp> a very mechanical human
[02:16:49] <cmr> by bot I mean "slave locked up in bstrie's basement"
[02:16:57] <mletterle> bors has achived awareness... obviously
[02:16:58] <dbaupp> doesn't have much imagination for writing comments on commits.
[02:17:24] <strcat> ChrisMorgan: http://osrc.dfm.io/bors
[02:18:14] <dbaupp> " All of bors's activity seems to be associated with repositories in Rust. Maybe it's time to branch out a bit. " heh
[02:18:50] <mletterle> "branch out a BIT" ha. Maybe a whole word or two...
[02:20:04] <strcat> if bors had commit access to itself, it could be a python programmer too
[02:20:25] <dbaupp> and overlord of the universe
[02:20:27] <ChrisMorgan> strcat: except it would immediately rewrite itself in Rust. Using rust-http, of course.
[02:20:32] <mletterle> that site is... spooky 
[02:20:50] <ChrisMorgan> And then it'd rewrite the compiler, because cmr never did do that...
[02:21:12] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[02:23:02] *** Quits: ianj (ianjneu@moz-7BA002E.hsd1.ma.comcast.net) (Quit: leaving)
[02:24:10] *** Quits: willingc (willingc@moz-B4760708.san.res.rr.com) (Quit: Leaving...)
[02:24:10] *** Joins: Sharp (Sharp@1710C26.8381A41.8725677B.IP)
[02:24:12] *** Quits: ricepuddin (graham@moz-7D68765A.cable.virginm.net) (Ping timeout)
[02:24:35] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[02:25:00] <ChrisMorgan> Well, I sent a support request and decided to trade the guaranteed gold star for a request of less than 140 characters for a swag request as compensation for mental anguish undergone in identity crisis. Let's see what happens about that. Could be fun…
[02:25:23] *** Joins: tikue (tkuehn@DB2ADAE8.E6CB677E.689607DE.IP)
[02:25:27] <cmr> Heh
[02:26:40] *** Quits: nkoep (nik@moz-F2EA2FDB.pool.mediaways.net) (Client exited)
[02:27:15] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[02:34:33] *** Joins: markwash (mwashenber@moz-E830FEBB.hsd1.ca.comcast.net)
[02:35:47] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[02:36:00] *** Quits: steffenomak (steffenoma@moz-FB0A4BEB.student.uu.se) (Ping timeout)
[02:38:38] *** kimundi is now known as zz_kimundi
[02:44:01] *** Quits: tikue (tkuehn@DB2ADAE8.E6CB677E.689607DE.IP) (Quit: tikue)
[02:45:34] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[02:48:12] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[02:48:36] *** Quits: Jesin (Jesin@moz-C1EBF9B4.dept.lehigh.edu) (Quit: Leaving)
[02:48:57] *** Quits: canhtak (canhtak@moz-A53E1151.wl.t.ulaval.ca) (Quit: canhtak)
[02:50:02] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[02:52:07] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[02:53:57] * ChrisMorgan exists once more
[02:53:59] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[02:54:32] * ChrisMorgan wonders what could have been flagged about his activities
[02:55:12] *** Joins: vodik (simon@moz-FD4ADBC6.cable.teksavvy.com)
[02:56:25] *** Quits: vodik_ (simon@moz-FD4ADBC6.cable.teksavvy.com) (Ping timeout)
[02:57:04] *** Quits: vodik (simon@moz-FD4ADBC6.cable.teksavvy.com) (Quit: WeeChat 0.4.3-dev)
[02:57:05] <mletterle> all that crazy rust pushing
[02:57:07] *** Joins: vodik (simon@moz-FD4ADBC6.cable.teksavvy.com)
[02:57:51] *** Joins: canhtak (canhtak@moz-A53E1151.wl.t.ulaval.ca)
[02:58:38] *** Quits: zslayton (Mibbit@81EB2473.5F4BC84E.66C78B76.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[03:00:38] *** Quits: Sharp (Sharp@1710C26.8381A41.8725677B.IP) (Quit: Sharp)
[03:01:29] *** Quits: KindOne (KindOne@moz-8392C1C0.dynamic.ip.windstream.net) (Ping timeout)
[03:04:48] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Ping timeout)
[03:05:32] *** Joins: KindOne (KindOne@moz-8392C1C0.dynamic.ip.windstream.net)
[03:10:21] *** Joins: rustyPipe (Mibbit@moz-2198B477.dllstx.fios.verizon.net)
[03:11:18] *** Quits: zz_kimundi (kimundi@moz-4C7B3B00.dip0.t-ipconnect.de) (Ping timeout)
[03:11:55] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.2)
[03:12:03] *** Quits: fhahn (fhahn@moz-7924DB5C.vie.surfer.at) (Ping timeout)
[03:14:12] *** Joins: zz_kimundi (kimundi@moz-D2DB1FE8.dip0.t-ipconnect.de)
[03:14:42] *** zz_kimundi is now known as kimundi
[03:19:49] *** Joins: fhahn (fhahn@moz-7924DB5C.vie.surfer.at)
[03:21:01] *** Quits: Krymise (Nietzsche@moz-CA789EF5.nwrknj.fios.verizon.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[03:23:47] <agrif> hey, I've found an internal compiler error https://gist.github.com/agrif/7836892
[03:24:08] <agrif> switching the List match and Blank match makes it go away
[03:25:13] *** Joins: tikue (tkuehn@DB2ADAE8.E6CB677E.689607DE.IP)
[03:26:46] <cmr> agrif: open an issue
[03:26:56] <agrif> I'm trying to see if there's one open already
[03:27:49] <agrif> this looks promising: https://github.com/mozilla/rust/issues/7990
[03:28:05] <tikue> is there a way to write this: `let a = 1; let f = |b| |c| a + b + c;`
[03:29:42] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[03:30:44] *** Quits: nsf (nsf@moz-EEF3238A.convex.ru) (Quit: WeeChat 0.4.2)
[03:33:24] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Ping timeout)
[03:33:25] <rossm> tikue you can write this: let a = 1; let f = |b:int, c:int| a + b + c; f(2,3)
[03:33:32] <rossm> rusti: let a = 1; let f = |b:int, c:int| a + b + c; f(2,3)
[03:33:33] -rusti- 6
[03:34:43] <tikue> yes, though i'm wondering if there's a way to get what i wrote to work
[03:35:00] *** Quits: gandalf (zbraniecki@moz-DFAA4E15.p2p.sfo1.mozilla.com) (Quit: My lid went down)
[03:35:22] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[03:35:39] <agrif> (to follow up in case anybody reads my gist and has an epiphany, issue is at https://github.com/mozilla/rust/issues/10845 )
[03:36:21] <tikue> rossm: `let a = 1; let f = |b| |c| a + b + c` is a minimal example exhibiting the problem I'm encountering
[03:36:39] <tikue> my actual problem could not easily be recomposed in that way
[03:40:16] *** Quits: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com) (Ping timeout)
[03:40:59] *** Joins: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com)
[03:42:16] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Connection reset by peer)
[03:42:31] <SiegeLord> Darn, my closures have finally crashed the compiler
[03:42:31] *** lpy is now known as lpy|lunch
[03:42:40] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[03:43:09] *** Joins: Jesin (Jesin@moz-63C897DA.res.lehigh.edu)
[03:46:52] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Client exited)
[03:48:26] *** Quits: markwash (mwashenber@moz-E830FEBB.hsd1.ca.comcast.net) (Ping timeout)
[03:50:53] *** Quits: osa1_ (omer@moz-8FDAB45C.hsd1.il.comcast.net) (Ping timeout)
[03:50:56] *** Joins: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au)
[03:52:58] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[03:54:39] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[03:54:39] *** Quits: tikue (tkuehn@DB2ADAE8.E6CB677E.689607DE.IP) (Ping timeout)
[03:54:53] *** Joins: earlzlap (earlz@moz-483E1E31.neo.res.rr.com)
[03:55:10] *** Joins: osa1_ (omer@moz-8FDAB45C.hsd1.il.comcast.net)
[03:55:22] *** Joins: tikue (tkuehn@DB2ADAE8.E6CB677E.689607DE.IP)
[03:58:02] *** Quits: osa1_ (omer@moz-8FDAB45C.hsd1.il.comcast.net) (Ping timeout)
[03:58:35] *** Joins: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net)
[04:00:08] *** Joins: zippity (Mibbit@moz-AFF378E0.rivrw10.nsw.optusnet.com.au)
[04:00:18] <zippity> hello
[04:00:40] <zippity> how can I re-run a single test in the rust code base, without it rebuilding the world
[04:01:21] <zippity> make check-stage1 NO_REBUILD=1 still seems to rebuild a good deal of the world
[04:01:57] *** Quits: tikue (tkuehn@DB2ADAE8.E6CB677E.689607DE.IP) (Quit: tikue)
[04:02:20] *** Quits: themgt (themgt@moz-83F07CDA.cm.vtr.net) (Quit: themgt)
[04:04:40] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[04:06:28] *** Joins: themgt (themgt@moz-83F07CDA.cm.vtr.net)
[04:07:23] *** Quits: themgt (themgt@moz-83F07CDA.cm.vtr.net) (Client exited)
[04:08:07] *** Joins: fyolnish (fyolnish@moz-EE392A77.uqwimax.jp)
[04:08:37] *** Quits: fyolnish (fyolnish@moz-EE392A77.uqwimax.jp) (Quit: Bye)
[04:10:05] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[04:11:16] <zippity> so the only way to build and test rust is seriously slow?
[04:11:31] <cmr> make check-stage1 NO_REBUILD=1 TESTNAME=foo
[04:11:43] <cmr> it will rebuild a lot, depending on what you have changed.
[04:11:49] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[04:12:13] <zippity> is there a way to get it to just rebuild my test binary?
[04:12:34] <cmr> sure, build it yourself.
[04:12:43] <cmr> the build system won't help you, not really.
[04:12:58] <sfackler> zippity: what test are you trying to run? there are also targets like check-stage1-std and check-stage1-cfail
[04:13:25] *** Joins: maxiepoo_ (Max@moz-6F50ADE.hsd1.il.comcast.net)
[04:13:57] <zippity> yeah, check-stage1-std failed
[04:14:17] <zippity> yeah, check-stage1 works, but builds a lot more than I need
[04:14:45] <zippity> so what command do I need to manually build just the test binary?
[04:15:03] <cmr> which binary is it?
[04:15:27] <cmr> if it's stdtest it's just path/to/stage1/.../bin/rustc --test std.rs
[04:16:19] <zippity> ./x86_64-apple-darwin/stage0/bin/rustc ?
[04:16:39] *** Quits: synackse (synackse__@7DAC4ACE.77F880E0.D9401097.IP) (Ping timeout)
[04:17:27] <zippity> so I'm working on a file under std/io
[04:17:50] <zippity> so I guess I'd want: ./x86_64-apple-darwin/stage0/bin/rustc --test src/libstd/io/mod.rs 
[04:17:52] <sfackler> zippity: what do you mean by failed?
[04:18:52] <cmr> zippity: no, that's not how it works
[04:18:57] <zippity> and I get a world of "error: glob import statements are experimental and possibly buggy"
[04:19:02] <cmr> std is a single crate, you can't compile individual pieces separately.
[04:19:10] <zippity> ah
[04:19:30] *** Quits: jstevans (Instantbir@98B9A5BB.474E6E0A.DDE5D3F6.IP) (Ping timeout)
[04:20:01] <sfackler> globs are enabled inside of libstd, not sure why you would be getting that error for tests in that crate
[04:20:06] <zippity> right, so crates are the atomic unit of compilation
[04:20:07] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[04:20:22] <cmr> sfackler: no, he's trying to build io/mod.rs
[04:20:28] <cmr> as a crate
[04:22:13] <sfackler> oh, that'd do it
[04:22:32] *** Joins: GeneralMaximus (ankur@B4DF73F6.7D84F5AD.260B031E.IP)
[04:23:32] <zippity> so this is the guy I want then? src/libstd/lib.rs
[04:23:42] <cmr> yes
[04:23:54] <cmr> (sorryabout the std.rs; old name)
[04:25:56] *** Quits: maxiepoo_ (Max@moz-6F50ADE.hsd1.il.comcast.net) (Quit: maxiepoo_)
[04:27:27] <zippity> thanks, that did it
[04:27:57] <zippity> much quicker than using make
[04:28:07] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Quit: Gone to save the world!)
[04:28:35] *** Quits: thesnowdog (doug@4D17280F.9D0B7490.6F17036B.IP) (Connection reset by peer)
[04:28:37] *** Quits: huhlig-home (huhlig@moz-C8339267.hfc.comcastbusiness.net) (Connection reset by peer)
[04:28:52] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[04:30:55] *** Quits: zippity (Mibbit@moz-AFF378E0.rivrw10.nsw.optusnet.com.au) (Quit: http://www.mibbit.com ajax IRC Client)
[04:32:43] *** Joins: thesnowdog (doug@4D17280F.9D0B7490.6F17036B.IP)
[04:36:15] *** Joins: mib_udqkhe (Mibbit@moz-C8176950.bstnma.fios.verizon.net)
[04:36:41] *** Quits: mib_udqkhe (Mibbit@moz-C8176950.bstnma.fios.verizon.net) (Quit: http://www.mibbit.com ajax IRC Client)
[04:41:32] *** Quits: wolfwood (wolfwood@moz-A19F104D.pitbpa.fios.verizon.net) (Ping timeout)
[04:41:32] *** Quits: wilkie (wilkie@moz-A19F104D.pitbpa.fios.verizon.net) (Ping timeout)
[04:42:32] *** Quits: tcr (tcr@moz-6FEAEFBC.hfc.comcastbusiness.net) (Client exited)
[04:42:53] *** Joins: tcr (tcr@moz-6FEAEFBC.hfc.comcastbusiness.net)
[04:44:35] *** Quits: tcr (tcr@moz-6FEAEFBC.hfc.comcastbusiness.net) (Ping timeout)
[04:44:53] *** Quits: thesnowdog (doug@4D17280F.9D0B7490.6F17036B.IP) (Connection reset by peer)
[04:45:34] *** Joins: jvns (bork@moz-DE62990.nyc.res.rr.com)
[04:47:03] *** Quits: dreamer_ (Patryk@90E8C08F.8480A87C.DDAA0084.IP) (Ping timeout)
[04:48:10] *** Joins: maxiepoo_ (Max@moz-6F50ADE.hsd1.il.comcast.net)
[04:48:59] *** Joins: tcr (tcr@moz-6FEAEFBC.hfc.comcastbusiness.net)
[04:49:15] *** Quits: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP) (Ping timeout)
[04:50:57] <hoverbear> Hrm, looks like the CoreOS people screwed up their SDK and can't update their builds with new drivers.
[04:54:46] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[04:55:10] *** Quits: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au) (Quit: gavinb)
[04:57:26] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[04:57:30] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[04:59:09] *** Quits: tcr (tcr@moz-6FEAEFBC.hfc.comcastbusiness.net) (Client exited)
[04:59:30] *** Joins: tcr (tcr@moz-6FEAEFBC.hfc.comcastbusiness.net)
[05:01:08] *** Joins: adu (ajr@moz-9C3760D5.washdc.fios.verizon.net)
[05:01:11] *** Quits: tcr (tcr@moz-6FEAEFBC.hfc.comcastbusiness.net) (Ping timeout)
[05:01:36] *** Joins: jstevans (Instantbir@moz-7D26D7CF.bootp.virginia.edu)
[05:01:58] <mark_edward> rusti: struct Point {x: int, y: int} let p = Point { x: 1, y: 2 }; let p2 = p; (p, p2)
[05:01:59] -rusti- (main::Point{x: 1, y: 2}, main::Point{x: 1, y: 2})
[05:04:18] *** lpy|lunch is now known as lpy
[05:05:45] *** Joins: tikue (tkuehn@DB2ADAE8.E6CB677E.689607DE.IP)
[05:12:39] *** Joins: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net)
[05:13:16] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[05:16:14] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[05:19:03] *** Quits: Shaladdle (shaladdle@moz-FDE833F3.wv.cc.cmu.edu) (Ping timeout)
[05:19:14] *** Quits: earlzlap (earlz@moz-483E1E31.neo.res.rr.com) (Ping timeout)
[05:19:16] <mark_edward> is there any convenient way to make enums easily convertible from ints?
[05:21:27] <mark_edward> can closures be stored?
[05:21:48] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[05:22:15] <ChrisMorgan> mark_edward: ToPrimitive can be derived for enums
[05:22:23] <mark_edward> cooL!
[05:22:24] <ChrisMorgan> (And FromPrimitive)
[05:22:29] <strcat> are unbounded concurrent queues a bad idea? how do applications usually avoid resource exhaustion?
[05:22:42] <strcat> I'm wondering if Go's choice to only included bounded queues is the right choice
[05:22:47] <ChrisMorgan> Sure, closures can be stored. You've just got to get the lifetimes right.
[05:23:09] * strcat is leaning far towards thinking they're a bad idea
[05:23:11] *** jorendorff_away is now known as jorendorff
[05:23:24] *** Joins: osa1_ (omer@moz-8FDAB45C.hsd1.il.comcast.net)
[05:24:20] *** Quits: nattofriends (tsutsumi@moz-A9E340E1.fuqu.jp) (Ping timeout)
[05:24:27] <ChrisMorgan> strcat: I don't think they're necessarily a bad idea. Things are safer with bounds, but then you've got to design things to suddenly cope with the possibility that something may block indefinitely—and that can cause problems itself. I think it's similar to memory exhaustion—is it a problem? Yes. Can it be catered for? Yes. Do most programs cater for it? No.
[05:24:42] *** Joins: erickt (etryzelaar@49C4075F.3AC15C18.2321E71E.IP)
[05:25:17] <strcat> but how do you prevent resource exhaustion?
[05:26:00] <strcat> it seems that usually you're going to have producing agents and consuming agents, but you're going to have close to no control over how fast stuff is produced/consumed
[05:26:14] <strcat> so not making the queue bounded is asking for memory exhaustion
[05:26:49] <strcat> I noticed that TBB also only has a bounded blocking queue
[05:26:55] <strcat> they removed the unbounded blocking queue
[05:26:57] *** Joins: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au)
[05:27:29] <strcat> and the non-blocking queue is for writing higher level abstraction AFAIK - I'm not sure how you'd use that directly without working out some sort of scheduling
[05:28:00] <strcat> ChrisMorgan: can turn a bounded queue into an unbounded queue by giving uint::MAX if you really want
[05:28:32] <strcat> the overhead is a branch in send/push and a condition var in the allocation (40 bytes on linux? something like that - not going to matter)
[05:28:42] * strcat is pretty close to convinced ;p
[05:28:47] *** Quits: maxli (maxli@moz-4D28BA20.student.cs.uwaterloo.ca) (Quit: Leaving.)
[05:30:23] <mark_edward> does the ffi provide a way to get a type from a C library? 
[05:30:37] <ktt3ja> if I have `fn foo(a: ~int) {}` and do `let a = ~1; foo(a);` then `a` is no longer usable after the function call, right?
[05:31:04] *** Joins: nattofriends (tsutsumi@moz-A9E340E1.fuqu.jp)
[05:31:13] <sfackler> mark_edward: what do you mean by "get a type"?
[05:31:23] <strcat> ktt3ja: right, ~T has value semantics and a dtor so it moves ownership there
[05:31:49] <strcat> (well I guess you could say everything has value semantics but some values like to pretend they're references)
[05:31:57] <ChrisMorgan> strcat: my objection is largely to something that is expected to be instant suddenly blocking indefinitely. If the API can be done in such a way that either (a) the send will be rejected with an appropriate indication (probably not a good plan, as the user will probably still want it to go on and might then busy wait), or (b) the fact that it may block is rendered obvious (don't ask me how); then I would probably have no further objections.
[05:32:14] <strcat> ChrisMorgan: you can expose try_push
[05:32:14] <mark_edward> like C a ctype has defined one of their 100 aliases for an int type. instead of peering at the source to figure out what it is, can't i say simply declare the library provides this type, sort of like how functions work?
[05:32:23] <ktt3ja> strcat: hmm, I don't quite understand your explanation (what's value semantic?)
[05:32:27] <ssbr> Oh, did Rust already move to requiring &*x instead of implicitly borrowing?
[05:33:23] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[05:33:24] <strcat> I wish rust just used Uniq<T> and didn't have sugar for ~, it causes confusion and encourages allocation ;[
[05:33:27] <ssbr> ktt3ja: I'm not sure it matters. a ~-pointer is moved when you give it to someone, not copied.
[05:33:43] <ChrisMorgan> strcat: that might make it more obvious, but still there *will* be people who write code that assumes push to be instant, and timing bugs *will* occur in consequence.
[05:33:54] <ktt3ja> ssbr: ok
[05:33:57] <mark_edward> strcat, really? ~ isn't really needed that often outside of ~str and ~[]
[05:34:00] <sfackler> mark_edward: types aren't retained at runtime in C. you have to specify it just like you have to specify the signature of a function you're linking against
[05:34:07] <ssbr> ktt3ja: since it's moved, you can't use the thing it was moved from -- it's no longer there.
[05:34:15] <strcat> mark_edward: that's the point, it's not really needed often so why does it have sugar?
[05:34:21] *** Quits: Kingsley (kingsley@9B172CBE.BEA5C56D.DF4B730F.IP) (Ping timeout)
[05:34:25] <sfackler> if it's always referenced via a pointer you can just do a "pub type Foo = c_void" or whatever
[05:34:31] <strcat> it makes people think it has special semantics when it really just acts like any old type with a dtor
[05:34:48] <mark_edward> strcat, cause you use ~ a lot with ~str and ~[] which do have special semantics
[05:35:03] *** Joins: Kingsley (kingsley@9B172CBE.BEA5C56D.DF4B730F.IP)
[05:35:03] <strcat> ~str and ~[] aren't unique pointers, I'm not talking about those
[05:35:04] <ssbr> strcat: I use it every time I define a recursive ADT. Which is pretty much every time I write an ADT apparently.
[05:35:15] *** Joins: siavashserver (siavash@128F2F94.7BA3B280.82A25C10.IP)
[05:35:28] <strcat> ssbr: that's true, how common do you think that is though?
[05:35:33] *** Quits: nattofriends (tsutsumi@moz-A9E340E1.fuqu.jp) (Ping timeout)
[05:35:52] <ssbr> strcat: depends on the code you're writing, I guess.
[05:36:09] <mark_edward> C programmers really don't like types. the library i'm looking at has about a dozen anonymous enums. and when used in functions they're just ints
[05:36:20] *** Joins: nattofriends (tsutsumi@moz-A9E340E1.fuqu.jp)
[05:36:28] <ssbr> mark_edward: if C programmers didn't hate types, they wouldn't be using C
[05:36:35] <strcat> enums don't really work like you'd expect in C
[05:36:57] <mark_edward> i mean, if all they want is constants, there's #define
[05:37:09] <strcat> no, that's 'static const int = ...;' ;p
[05:37:10] <mark_edward> the enum is pointless if it doesn't even have a name
[05:37:14] *** Quits: tikue (tkuehn@DB2ADAE8.E6CB677E.689607DE.IP) (Quit: tikue)
[05:37:20] <strcat> mark_edward: it's not pointless
[05:37:32] <mark_edward> yeah i guess it gives you the auto incrementing values
[05:37:45] <mark_edward> like Go's iota!
[05:38:57] *** Quits: maxiepoo_ (Max@moz-6F50ADE.hsd1.il.comcast.net) (Quit: maxiepoo_)
[05:39:11] <mark_edward> strcat, besides that, what else does it do?
[05:40:37] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Client exited)
[05:41:25] *** Quits: erickt (etryzelaar@49C4075F.3AC15C18.2321E71E.IP) (Ping timeout)
[05:41:46] *** Joins: tikue (tkuehn@DB2ADAE8.E6CB677E.689607DE.IP)
[05:44:52] <mark_edward> is there a recommended way to go from a c_int to a bool?
[05:45:12] *** Quits: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net) (Ping timeout)
[05:45:27] <SiegeLord> It depends whether you want 0 to be false or not
[05:45:38] *** Quits: siavashserver (siavash@128F2F94.7BA3B280.82A25C10.IP) (Quit: Konversation terminated!)
[05:45:40] <mark_edward> yes i want that. C interop
[05:46:01] *** Joins: erickt (etryzelaar@49C4075F.3AC15C18.2321E71E.IP)
[05:46:27] <SiegeLord> I'd do != 0
[05:50:59] *** Joins: bjz (bjz@moz-C1B1AF2A.lnse2.cha.bigpond.net.au)
[05:51:25] *** Quits: erickt (etryzelaar@49C4075F.3AC15C18.2321E71E.IP) (Ping timeout)
[05:52:10] <ssbr> SiegeLord: Ha!
[05:52:14] <strcat> ChrisMorgan: my point is just that the non-blocking behaviour is an illusion fulfilled by the ability to go OOM
[05:52:32] <strcat> a smaller bound will be more deadlock prone but there's not a bound
[05:52:37] *** Quits: japaric (japaric@FFB1354E.A75B951F.A936879B.IP) (Ping timeout)
[05:52:38] <strcat> there's never not a bound*
[05:53:05] <ChrisMorgan> strcat: finite memory is a basic assumption of the Von Neumann architecture.
[05:53:43] <strcat> dunno why that's relevant
[05:53:56] <ssbr> strcat: If there's spikes of load but you have more than enough capacity for the average amount of data pushed through the queue, it's not unreasonable to let the size grow as big as fits in memory during those spikes
[05:54:12] <strcat> ssbr: you don't know what fits in memory
[05:54:32] <strcat> unless it's bare metal and you have direct control over the machine
[05:54:36] <ssbr> strcat: if I don't know, then I definitely can't set an explicit bound, can I?
[05:54:45] <ssbr> strcat: I meant virtual memory.
[05:54:47] <ChrisMorgan> strcat: I mean that any data structure which can have growable datatypes must inevitably be able to run into memory limits.
[05:54:48] <strcat> ssbr: you can set an explicit bound
[05:55:00] <ssbr> strcat: sure, but you're saying that I can't know what number to set the bound at.
[05:55:12] <strcat> ssbr: sure you can
[05:55:19] <strcat> you set it as high as necessary for good performance
[05:55:20] <ChrisMorgan> With unbounded concurrent queues, that may well be the only reasonable limit—sometimes.
[05:55:25] <strcat> that depends on how fast you produce
[05:55:37] <ssbr> strcat: in this situation, it's not about "good performance", it's about "don't ever kill the task ever"
[05:55:46] <strcat> ssbr: I think you're missing the point
[05:55:48] <strcat> a bound of 1000 is fine
[05:55:51] <ssbr> because the speed of production only outpaces the speed of consumption temporarily
[05:55:54] <ChrisMorgan> Excessively fast production is certainly a danger with it—but that's something that will need to be dealt with anyway.
[05:55:59] <ssbr> strcat: not if more than 1000 elements get pushed
[05:56:05] <strcat> ssbr: yes it is
[05:56:15] <ssbr> (and you don't want them to block)
[05:56:31] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[05:56:36] <strcat> ssbr: it's fine if they block as long as they're able to start producing again before the queue is drained a lot
[05:56:37] <ssbr> strcat: I don't see how a bound of 1000 is better than no bound at all here.
[05:56:49] *** Quits: tiffany (kawaii@moz-FC0DB29D.dhcp.embarqhsd.net) (Input/output error)
[05:56:55] <strcat> because if the producers outpace the consumers, you will consume more and more memory
[05:57:00] <strcat> until you exhaust the memory
[05:57:12] <ssbr> strcat: if I estimate that I won't exhaust memory, then that's not an issue
[05:57:18] <strcat> ssbr: how do you 'estimate' that?
[05:57:23] <strcat> you have no control over the scheduling
[05:57:40] <ChrisMorgan> strcat: if the producers are outpacing the consumers, you have a more fundamental problem.
[05:57:41] <ssbr> strcat: historical trends, unless there's some other point you're making
[05:57:47] <strcat> ChrisMorgan: it's not a fundamental problem
[05:57:58] <strcat> the producers may outpace the consumers for a while, then fall behind
[05:57:59] <strcat> that's life
[05:58:10] *** Quits: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au) (Quit: gavinb)
[05:58:16] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[05:58:17] <ChrisMorgan> (Sorry, I should say you *may* have a more fundamental problem. For certain designs that might be optimal.)
[05:58:29] <strcat> ssbr: you really can't assume anything about the rate
[05:58:38] <strcat> especially if you're being so careless about memory and may have lots of swapping
[05:58:57] *** Quits: bellows (Mibbit@moz-A86A7504.infotecs.ru) (Quit: http://www.mibbit.com ajax IRC Client)
[05:59:00] *** Quits: maxiepoo (mnew@moz-6F50ADE.hsd1.il.comcast.net) (Ping timeout)
[05:59:14] <ssbr> strcat: if the system could start thrashing that would be bad yes
[05:59:20] <strcat> robust software can't make that assumption - having the process killed or aborting, or bringing down other processes would not be good
[05:59:28] <strcat> you need reasonable soft bounds on memory consumption
[05:59:29] <mark_edward> i think bools should implement FromPrimitive
[05:59:42] <ChrisMorgan> strcat: the most probable case is that producers are consistently outpacing consumers. If that be so, you'll then be getting arbitrary data points being lost (e.g. bounded queue and time-based data which is then irrevocably lost), or lag tending to infinite duration (any other situation).
[05:59:53] <ssbr> strcat: it's not unreasonable to set memory limits separately and kill processes when they exceed them
[05:59:55] <ChrisMorgan> mark_edward: should true be 0 or 1?
[05:59:55] *** jorendorff is now known as jorendorff_away
[05:59:57] <ssbr> that's different though
[06:00:03] <strcat> ChrisMorgan: blocking != data lost
[06:00:07] <mark_edward> ChrisMorgan, non-zero, just like C
[06:00:10] <ssbr> not correct for a queue that's within a single process
[06:00:13] <strcat> if you're using a blocking queue it's not a real-time system in the first place
[06:00:20] *** Joins: tcr (tcr@moz-6FEAEFBC.hfc.comcastbusiness.net)
[06:00:23] <mark_edward> ChrisMorgan, i mean that's my usecase for it
[06:00:39] <ssbr> ChrisMorgan: is that really the most probable case? That'll happen once and then it gets fixed.
[06:00:42] <ChrisMorgan> strcat: I agree, it does not necessarily mean data lost, but it may well do, which may well break assumptions elsewhere.
[06:00:47] <ssbr> ChrisMorgan: but very often the outpacing will only be temporary
[06:00:53] <strcat> ChrisMorgan: if your queue is unbounded it's *the same thing*
[06:00:56] <ssbr> it'll never even be noticed probably
[06:00:57] * ChrisMorgan doesn't know what the real life situation is like
[06:01:38] <strcat> ChrisMorgan: the consumers don't really ever see a difference between unbounded and bounded with a reasonable capacity
[06:01:41] <strcat> it matters for the producers
[06:02:00] <strcat> do they block, or do they keep pushing and pushing without a cap on the memory consumption
[06:02:04] *** Quits: tcr (tcr@moz-6FEAEFBC.hfc.comcastbusiness.net) (Ping timeout)
[06:02:11] <ChrisMorgan> mark_edward: but also in C you get functions that return negative numbers for errors and 0 for success.
[06:02:13] <strcat> you can make the bound 2GiB
[06:02:25] <ssbr> ChrisMorgan: sure, but bools in C are still 0 for false and nonzero for true
[06:02:35] <mark_edward> ChrisMorgan, yeah but that's a different use case
[06:02:42] <ssbr> if something returns a negative number for error, it's not returning a boolean
[06:02:48] *** Quits: Kingsley (kingsley@9B172CBE.BEA5C56D.DF4B730F.IP) (Ping timeout)
[06:02:52] <strcat> if your consumers can clear 2GiB of data before the producers can start churning it out again, I think the rate is fast enough that even a minor scheduling latency could cause OOM
[06:02:58] <ssbr> (unless, as is common, "true" means "error")
[06:03:03] <ChrisMorgan> ssbr: in the edition of C I choose to constrain my knowledge to for the purpose of this line, there *is* no bool/true/false. :P
[06:03:29] *** Joins: Kingsley (kingsley@9B172CBE.BEA5C56D.DF4B730F.IP)
[06:03:32] <strcat> C has bool/true/false, they're macros defined as _Bool, 1 and 0 though
[06:03:33] <ssbr> ChrisMorgan: even if you say there's no such thing as bools, there is such a thing as "things that make the first clause of an if statement evaluate"
[06:03:37] <ssbr> ChrisMorgan: and I call those things bools.
[06:03:43] <strcat> ssbr: well in C that's an int ;p
[06:03:49] <strcat> 'c' is an int in C too, not a char
[06:03:54] <strcat> if you mean C++... then sure, those are bools
[06:03:55] <ChrisMorgan> strcat: not in C89
[06:03:57] <ssbr> strcat: that's why I said 0 is false and nonzero is true
[06:03:58] *** jorendorff_away is now known as jorendorff
[06:04:04] <strcat> ChrisMorgan: and c89 is a retracted standard so it's not C ;p
[06:04:20] <strcat> it's like saying rust has structural records
[06:04:57] <ssbr> C89 is commonly implemented and commonly used by software projects, retracted standard or not, isn't that so?
[06:04:59] *** Joins: japaric (japaric@7C76557C.60901FDF.95AE23EB.IP)
[06:05:06] <ChrisMorgan> strcat: if you just run `gcc x.c`, you don't get bool/true/false.
[06:05:32] <strcat> ChrisMorgan: and?
[06:05:40] *** jorendorff is now known as jorendorff_away
[06:05:58] <mark_edward> strcat, what's a structural recor?
[06:05:59] <strcat> and actually you do
[06:06:02] <strcat> I just checked
[06:06:05] <ChrisMorgan> And that's modern gcc. Whereas no Rust standard or release has structural records.
[06:06:19] <ChrisMorgan> strcat: gcc 4.8.1 doesn't on my machine
[06:06:32] <strcat> ChrisMorgan: _Bool x = 0;
[06:06:33] <strcat> compiles
[06:06:40] <strcat> #include <stdbool.h> bool x = false
[06:06:41] <strcat> also compiles
[06:06:50] <mark_edward> im starting to think we should start building machines for specific languages
[06:06:57] <mark_edward> i'd list a haskell machine
[06:07:02] <ChrisMorgan> Oh yes, I forgot you still needed to include stdbool.h. *sigh*
[06:07:03] <mark_edward> s/list/like/
[06:07:07] <ssbr> mark_edward: why? :(
[06:07:17] <strcat> ChrisMorgan: I didn't expect it to compile because I thought it defaulted to gnu89
[06:07:23] <strcat> but maybe gnu89 allows c99 stuff
[06:07:55] <strcat> gcc just doesn't care at all by default, apparently
[06:08:12] <ChrisMorgan> On the other topic: really, both bounded and unbounded queues have their problems. Either will cause bugs with people that don't understand them properly. In the end, what is worse? Well, actually allowing a process to run out of memory is probably going to be a more significant problem on most deployment machines. But then again, having people specifying backlogs that are too small may be a big problem too.
[06:08:13] <strcat> -std=c89 -pedantic -Wall -Wextra
[06:08:17] <strcat> no warning for using _Bool
[06:08:30] <strcat> thanks for nothing gcc
[06:08:48] <mark_edward> ssbr, should we try to express ourselves for machines, or should machines be made to understand us?
[06:09:00] <bjz> Luqman: yeah?
[06:09:20] <ssbr> mark_edward: machines are made to understand us, that's what compilers do
[06:10:06] *** Joins: lenstr (lenstr@39B5AC2A.9636F313.7A27613B.IP)
[06:11:18] *** Quits: ssbr_ (~ssbr@46FE74EC.C60FE7DC.4065847B.IP) (Ping timeout)
[06:12:31] <mark_edward> ssbr, i feeling designing every new computer and architecture to have ISA that we compile C to is limiting the horizons of the industry
[06:13:08] *** Joins: Sgeo_ (quassel@moz-D0F30617.dyn.optonline.net)
[06:13:10] <strcat> C doesn't require much
[06:13:36] *** Quits: Sgeo (quassel@moz-D0F30617.dyn.optonline.net) (Ping timeout)
[06:13:45] <strcat> almost everything is implementation defined ;p
[06:13:49] *** Joins: tcr (tcr@moz-6FEAEFBC.hfc.comcastbusiness.net)
[06:14:02] <mark_edward> it enforces a way of thinking, pointers, memory, integers, floats. these seem integral to what programming is because it's how we've been raised, but it doesn't have to be so
[06:14:14] <strcat> it doesn't enforce much about that
[06:14:30] <strcat> you can't do pointer arithmetic outside of the bounds of an object
[06:14:34] <mark_edward> we should standardize mathematical notation internationally and write machines that interpret formulas
[06:14:37] <mark_edward> i say
[06:14:44] <strcat> NULL isn't necessarily represented as zero
[06:14:58] *** Quits: Sgeo_ (quassel@moz-D0F30617.dyn.optonline.net) (Ping timeout)
[06:15:02] <strcat> floats don't have many requirements at all
[06:15:03] *** Quits: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net) (Quit: Sharp)
[06:15:06] <ssbr> mark_edward: if you want to experiment, you can do this without even building anything
[06:15:10] <strcat> they don't have to be binary floats a tall
[06:15:12] <strcat> at all*
[06:15:15] <mark_edward> ssbr, what do you mean?
[06:15:27] <strcat> you can make a conformant C11 implementation where 'float' is an 18-digit decimal float
[06:15:38] <strcat> and 'double' is also 18-digit (it just has to be as large as float iirc)
[06:15:40] <ssbr> mark_edward: I mean if you want to implement a new kind of computer, you can write it in software.
[06:15:40] *** Quits: tcr (tcr@moz-6FEAEFBC.hfc.comcastbusiness.net) (Ping timeout)
[06:16:00] *** Joins: Sgeo (quassel@moz-D0F30617.dyn.optonline.net)
[06:16:05] <ssbr> our CPUs can execute interpreters after all
[06:16:29] <strcat> there's FLT_RADIX and C99 even added functions for dealing with non-binary FLT_RADIX
[06:16:35] <mark_edward> i dunno, i feel like programming is almost like fighting the computer, whipping it and twisting it and bending it to get it to do what you want. and then it does so like an evil genie, looking for any way to disobey you
[06:16:44] <mark_edward> why won't the computer work with me :'-(
[06:16:45] *** Quits: vodik (simon@moz-FD4ADBC6.cable.teksavvy.com) (Connection reset by peer)
[06:19:04] <ssbr> mark_edward: that's math you're fighting, not computers
[06:19:34] <ssbr> humans don't understand the consequences of what they think. Any formal system will run away and do unintended things with our ideas. :(
[06:20:44] <mark_edward> humans manage to understand a lot of data highly reliable despite highly irregular input.  language is a prime example
[06:21:06] *** Quits: lenstr (lenstr@39B5AC2A.9636F313.7A27613B.IP) (Ping timeout)
[06:21:57] *** Quits: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[06:22:15] *** Joins: ssbr_ (~ssbr@46FE74EC.C60FE7DC.4065847B.IP)
[06:22:15] *** Joins: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net)
[06:23:30] <strcat> acrichto: do we only open urandom once now?
[06:23:45] <SiegeLord> mark_edward: Languages is incredibly regular
[06:24:02] <acrichto> strcat: no, only the rng is cached, new rngs will reopen urandom
[06:24:15] <strcat> acrichto: so it caches per scheduler?
[06:24:23] <acrichto> schedulers cache an xor rng
[06:24:39] <strcat> is the task local RNG still a fd per-task, is what I mean
[06:25:01] <acrichto> the task-local rng doesn't cache the urandom rng I think
[06:25:06] <acrichto> after I seeding I think it's trashed
[06:25:16] <mark_edward> SiegeLord, human language?
[06:25:38] <strcat> read/write are thread-safe so we could just open urandom once
[06:26:02] *** Quits: tikue (tkuehn@DB2ADAE8.E6CB677E.689607DE.IP) (Quit: tikue)
[06:26:06] <acrichto> strcat: looks like we reopen urandom each time we reseed the task rng as well
[06:26:20] *** Joins: tikue (tkuehn@DB2ADAE8.E6CB677E.689607DE.IP)
[06:26:24] *** Quits: cubic (cubic@moz-80241A3A.mc.videotron.ca) (Quit: Leaving)
[06:26:31] <strcat> we should have a global urandom fd
[06:26:49] <acrichto> I'd be ok with that
[06:26:57] <acrichto> rt::init() sets it up, rt::cleanup() closes it
[06:27:12] <acrichto> along with a fallback
[06:27:16] <acrichto> well, maybe
[06:28:34] <strcat> well if it's global, buffering it will require a lock
[06:29:01] *** Quits: jeaye (Jeaye@moz-34FEF2BB.hsd1.ca.comcast.net) (Quit: zzz)
[06:29:05] <acrichto> we don't need to buffer it
[06:29:10] <acrichto> reads are always oneshot
[06:29:20] <acrichto> we can just use native::file::FileDesc
[06:29:44] <ktt3ja> can I not define something like `struct Foo { a: ~mut ~[int] }`?
[06:30:03] <strcat> acrichto: buffering it avoids doing as many syscalls though
[06:30:13] <SiegeLord> mark_edward: Yes
[06:30:27] <strcat> otherwise I expect using urandom directly will be too slow
[06:30:36] <strcat> guess it's worth testing
[06:30:46] <acrichto> strcat: if this gets complicated, then it's not really worth it
[06:30:47] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[06:30:58] <strcat> acrichto: it's worth not opening an fd per task
[06:31:06] <acrichto> it's not a long-lived fd, it's instantaneous
[06:31:21] <acrichto> spawning a task shouldn't require opening and fd
[06:31:35] <acrichto> as in you shouldn't have an extra syscall per spawn
[06:31:45] <acrichto> but that solution may not be "use a global urandom"
[06:32:40] <ssbr> is there a reason you can't have a buffer per-task?
[06:32:47] <strcat> well it could be thread-local but then you still have an extra fd per OS thread
[06:33:03] <ssbr> oh, per thread, yes
[06:34:34] <strcat> I'm sad about not having initialization code and dtors for statics ;[
[06:34:50] *** Quits: docbrown (docbrown@5CE9D448.F0B9EFB2.7F8758CE.IP) (Client exited)
[06:35:54] *** Quits: jvns (bork@moz-DE62990.nyc.res.rr.com) (Ping timeout)
[06:36:12] *** Joins: jvns (bork@moz-DE62990.nyc.res.rr.com)
[06:36:20] *** Quits: Savago (Savago@D8B9C081.E820043D.D4C04133.IP) (Quit: Savago)
[06:36:35] <strcat> although I want dtors most
[06:36:52] <strcat> haven't actually needed init code yet, it just would be convenient
[06:36:59] <strcat> to avoid a branch everywhere checking
[06:37:06] <ssbr> if we had initialization code for statics, could we do static foo : bar = baz(); ?
[06:37:14] <strcat> in C++ you can
[06:37:28] *** Joins: SingingBoyo (SingingBoy@DA28FB90.A5D0D593.4F048BDC.IP)
[06:37:32] <strcat> it runs them in an unspecified order before main
[06:37:34] <ssbr> or do you mean something else?
[06:37:46] <strcat> ssbr: I mean that
[06:37:54] <strcat> we do have non-constant statics
[06:38:09] <strcat> just define a foreign static ;]
[06:38:18] <ssbr> strcat: it's bothersome for things like regexps that you only want to initialize once
[06:38:31] <strcat> well static regexp would be better
[06:38:36] <ssbr> in python you often see something like `FOO_REGEXP = re.compile(r"foo.*bar")`
[06:38:55] <strcat> for example lets say you want your own thread-local rng
[06:38:56] *** sam113101 is now known as sam113101_afk
[06:39:07] <strcat> all the rng methods are going to have to check that it's initialized
[06:39:10] <ssbr> strcat: "static regexp"?
[06:39:35] <strcat> ssbr: you can have a static compiler for regexp like D
[06:39:42] <strcat> then it can be optimized with the code
[06:39:50] <ssbr> strcat: I'm not really a fan of that answer. Will you take every conceivable case of things where you only want to do them once, and say that they should be added to the compiler?
[06:40:04] <strcat> you should be able to implement static regexp in a library
[06:40:07] <strcat> via a syntax ext
[06:40:15] <ssbr> strcat: OK, that's reasonable.
[06:40:29] <acrichto> ssbr: we very much want dynamically loadable syntax extensions, but it is also a very difficult problem
[06:40:42] <acrichto> ssbr: all of std::fmt should be a syntax extension not baked into the compiler
[06:40:46] <acrichto> among others
[06:40:56] <ssbr> I'd imagine pretty much every case of static foo : bar = baz(); should be safe to do at compile-time
[06:40:58] <acrichto> thread_local might be able to be another syntax extension
[06:41:11] <strcat> acrichto: as in safe thread-local data?
[06:41:12] *** Quits: victorporof (victorporo@4235A1D2.22FD687A.2B3D3D4.IP) (Quit: victorporof)
[06:41:16] <ssbr> except maybe you need to pull some things out to a separate crate to make it work at compile-time, but hopefully that shouldn't be a problem
[06:41:21] <strcat> acrichto: you can do it with macros
[06:41:36] <strcat> it's a hack but ... ;p
[06:41:41] <acrichto> strcat: kinda, I want std::local_data to be just as fast as #[thread_local]
[06:41:48] <acrichto> it would require compiler support though
[06:41:56] <strcat> acrichto: well in dynamically linked binaries it can't be
[06:41:57] <acrichto> std::local_data is the "safe" interface
[06:42:13] <acrichto> strcat: it certainly can be, it would not be the exact same
[06:42:29] <acrichto> crate maps could easily contain metadata about thread local things in the crate
[06:42:32] *** Quits: KindOne (KindOne@moz-8392C1C0.dynamic.ip.windstream.net) (Ping timeout)
[06:42:49] <acrichto> although it wouldn't actually be thread local but rather task local
[06:43:02] * strcat shrugs
[06:43:19] <acrichto> task local == TLS lookup of task + offset into task's tls map 
[06:43:27] <acrichto> so there'd be one extra dereference over #[thread_local]
[06:43:44] <acrichto> (in theory), I have not given this much thought other than that general framework idea
[06:44:02] <strcat> but what happens when you dlopen a crate and you get a bunch more of them?
[06:44:29] <acrichto> if you don't link to a rust crate through rustc, you're basically not using it at all
[06:44:42] <acrichto> I don't think it's that relevant of a use case to add hooks to the dynamic linker
[06:44:42] <strcat> so we won't have dynamic loading?
[06:44:55] <acrichto> what do you mean by dynamic loading?
[06:44:59] <strcat> dynamic code loading/unloading
[06:45:09] <strcat> dlopen/dlclose equivalent for crates
[06:45:12] <acrichto> can you link a rust .so into another c library? of course
[06:45:29] *** Joins: thesnowdog (doug@E312D2E2.11882795.6F17036B.IP)
[06:45:59] <acrichto> rust is not C++, I don't think we should strive to do literally every thing possible to do in C++
[06:46:22] <acrichto> if there's a good use case, then we should definitely give it thought, but we shouldn't just do things to do things
[06:46:23] *** Joins: KindOne (KindOne@moz-5EA682F6.dynamic.ip.windstream.net)
[06:47:17] <strcat> dynamic loading is the usual way to do plugin systems for native code
[06:47:27] <strcat> where installing a plugin doesn't mean rebuilding everything
[06:47:47] <acrichto> that doesn't that we must support magically running code on dlopen, why is an init function not sufficient?
[06:48:06] <strcat> because rust code can have #[task_local] statics
[06:48:39] <acrichto> I still don't understand why an init function is not sufficient in that case?
[06:49:03] <acrichto> the crate  knows about its crate map, and therefore knows about its task local things
[06:49:15] <strcat> it has to add the task local data to the tasks
[06:49:22] <strcat> and remove it on unload
[06:49:54] <acrichto> the are problems to think about, not fundamental limitations
[06:49:57] <acrichto> these*
[06:50:15] <strcat> but they are solved problems
[06:50:46] <acrichto> yes, and we must think about them
[06:51:49] <strcat> I guess I can do dtors via pthread_cleanup_push
[06:52:09] <strcat> without init code for statics they aren't actually very useful
[06:53:29] *** sam113101_afk is now known as sam113101
[06:55:52] *** Quits: tikue (tkuehn@DB2ADAE8.E6CB677E.689607DE.IP) (Ping timeout)
[06:56:28] *** Joins: tikue (tkuehn@DB2ADAE8.E6CB677E.689607DE.IP)
[06:57:10] *** Quits: jvns (bork@moz-DE62990.nyc.res.rr.com) (Ping timeout)
[06:58:44] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[07:00:29] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[07:02:57] *** sam113101 is now known as sam113101_afk
[07:03:25] *** Joins: jvns (bork@moz-DE62990.nyc.res.rr.com)
[07:05:24] *** Quits: lpy (lpy@7360AA58.F09091A8.1348A864.IP) (Ping timeout)
[07:07:27] *** sam113101_afk is now known as sam113101
[07:08:16] *** sam113101 is now known as sam113101_afk
[07:09:42] <SiegeLord> fn test<T: Iterator<int>>(o: Option<T>) how would I pass None to a function like that?
[07:10:03] *** Joins: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net)
[07:10:05] <strcat> test(None::<T>)
[07:10:08] <strcat> or
[07:10:13] <strcat> test::<T>(None)
[07:10:27] <SiegeLord> What's T?
[07:10:38] *** sam113101_afk is now known as sam113101
[07:10:40] <strcat> the type you want that T type parameter to be
[07:10:50] <SiegeLord> So I need to make up a random iterator...
[07:11:13] <strcat> why is a parameter an Option?
[07:11:21] *** Joins: lpy (lpy@ECF79DC7.F09091A8.1348A864.IP)
[07:11:42] <SiegeLord> Because None is different from an empty Iterator in this case
[07:12:20] <strcat> it seems like it would be easier to just write two functions and do a branch when you care about the difference if the parameter is generic
[07:12:36] *** Quits: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net) (Quit: Sharp)
[07:12:37] <strcat> they can ofc share whatever part of the implementation is shared
[07:12:54] *** Joins: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net)
[07:14:34] *** Parts: thewonderidiot (mike@moz-5506A033.hsd1.ca.comcast.net) ()
[07:15:13] <SiegeLord> Hmm... very tempted to just take a closure
[07:16:03] *** Quits: jvns (bork@moz-DE62990.nyc.res.rr.com) (Ping timeout)
[07:16:27] *** Quits: tikue (tkuehn@DB2ADAE8.E6CB677E.689607DE.IP) (Ping timeout)
[07:16:32] <strcat> SiegeLord: not really any different than taking ~Iterator
[07:16:40] *** Joins: tikue (tkuehn@DB2ADAE8.E6CB677E.689607DE.IP)
[07:16:44] <strcat> or &Iterator
[07:16:48] <SiegeLord> Or that, I suppose
[07:17:35] <strcat> either way you lose the adaptors though
[07:17:44] <strcat> although for loops will still work
[07:18:49] *** Quits: hoverbear (hoverbear@moz-86FCBF4B.gv.shawcable.net) (Quit: Hibernating, be back soon.)
[07:20:25] <SiegeLord> Until they are fixed, heh
[07:20:53] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[07:20:58] <SiegeLord> I guess default trait bounds would help here... as the library author I can provide some dummy default
[07:22:03] *** Joins: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net)
[07:24:36] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Client exited)
[07:26:20] *** Quits: lpy (lpy@ECF79DC7.F09091A8.1348A864.IP) (Ping timeout)
[07:27:06] *** Joins: lpy (lpy@12172131.F09091A8.1348A864.IP)
[07:27:20] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[07:27:21] *** Quits: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net) (Quit: Sharp)
[07:28:07] *** Joins: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net)
[07:28:20] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[07:28:50] *** Joins: nsf (nsf@moz-EEF3238A.convex.ru)
[07:29:38] *** Quits: Kingsley (kingsley@9B172CBE.BEA5C56D.DF4B730F.IP) (Ping timeout)
[07:30:40] *** Joins: Kingsley (kingsley@9B172CBE.BEA5C56D.DF4B730F.IP)
[07:34:31] *** Quits: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net) (Quit: Sharp)
[07:34:47] *** Joins: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net)
[07:36:33] *** Quits: KindOne (KindOne@moz-5EA682F6.dynamic.ip.windstream.net) (Ping timeout)
[07:38:17] *** Quits: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net) (Quit: Sharp)
[07:38:47] *** Joins: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net)
[07:39:59] *** Joins: KindOne (KindOne@moz-5EA682F6.dynamic.ip.windstream.net)
[07:43:20] *** Quits: canhtak (canhtak@moz-A53E1151.wl.t.ulaval.ca) (Quit: canhtak)
[07:47:27] *** Quits: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net) (Quit: Sharp)
[07:47:40] *** Joins: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net)
[07:53:28] *** Quits: jstevans (Instantbir@moz-7D26D7CF.bootp.virginia.edu) (Ping timeout)
[07:54:28] *** Quits: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net) (Quit: Sharp)
[07:54:48] *** Joins: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net)
[07:56:30] *** Quits: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net) (Quit: Sharp)
[07:56:35] *** Quits: adu (ajr@moz-9C3760D5.washdc.fios.verizon.net) (Ping timeout)
[07:56:46] *** Joins: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net)
[07:57:38] *** Joins: hjr3 (hradtke@moz-842BF853.hsd1.ca.comcast.net)
[07:58:10] *** Joins: adu (ajr@moz-94B34CD8.washdc.fios.verizon.net)
[07:58:10] *** Quits: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net) (Quit: Sharp)
[07:58:27] *** Joins: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net)
[07:59:47] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[08:00:47] *** Quits: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net) (Quit: Sharp)
[08:01:15] *** Joins: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net)
[08:01:34] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[08:02:59] *** Quits: adu (ajr@moz-94B34CD8.washdc.fios.verizon.net) (Quit: adu)
[08:04:19] *** Quits: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net) (Quit: Sharp)
[08:04:50] *** Joins: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net)
[08:05:57] *** Quits: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net) (Quit: Sharp)
[08:06:27] *** Joins: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net)
[08:07:45] *** Quits: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net) (Quit: Sharp)
[08:10:04] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[08:10:52] *** Quits: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com) (Ping timeout)
[08:11:25] *** Quits: jlong (jlong@moz-6DFDE846.socal.res.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[08:11:49] *** Joins: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com)
[08:11:57] *** Quits: tikue (tkuehn@DB2ADAE8.E6CB677E.689607DE.IP) (Ping timeout)
[08:16:01] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Ping timeout)
[08:16:47] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[08:17:32] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[08:17:42] *** Joins: peterdn (chatzilla@moz-5EB9CC81.as13285.net)
[08:19:53] *** Quits: hjr3 (hradtke@moz-842BF853.hsd1.ca.comcast.net) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[08:20:32] *** Joins: w3lcome (Mibbit@EAD96774.6B9C41FA.6316A47C.IP)
[08:21:23] *** Joins: siavashserver (siavash@5C538F84.AC532F77.82A25C10.IP)
[08:23:21] *** Quits: ktt3ja (Mibbit@moz-D69B60E4.hsd1.va.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[08:23:22] *** Quits: santiago (santiago@moz-8ADE82B4.socal.res.rr.com) (Quit: Computer has gone to sleep.)
[08:23:34] *** Joins: santiago (santiago@moz-8ADE82B4.socal.res.rr.com)
[08:23:39] *** Quits: santiago (santiago@moz-8ADE82B4.socal.res.rr.com) (Client exited)
[08:25:15] *** Quits: nsf (nsf@moz-EEF3238A.convex.ru) (Quit: WeeChat 0.4.2)
[08:28:17] *** Joins: santiago (santiago@moz-8ADE82B4.socal.res.rr.com)
[08:28:52] <agrif> hey, is there a reasonable replacement for managed closures now that @ is gone?
[08:29:41] <agrif> I know about proc, but those can only be run once
[08:29:59] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[08:30:15] <agrif> and it seems like |arg| style closures can't be returned
[08:31:45] *** Quits: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net) (Ping timeout)
[08:37:51] *** Joins: smodo (ford_p@moz-6398EFDF.dclient.hispeed.ch)
[08:38:26] <strcat> agrif: trait objects
[08:38:30] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.2)
[08:38:30] *** Joins: jackneill (jackneill@moz-6C59E71E.pool.digikabel.hu)
[08:38:43] *** Quits: KindOne (KindOne@moz-5EA682F6.dynamic.ip.windstream.net) (Ping timeout)
[08:41:14] *** Joins: jstevans (Instantbir@553F89F7.FA95BF59.B7830B68.IP)
[08:41:25] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Ping timeout)
[08:42:06] *** Quits: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz) (Quit: Busying myself...)
[08:42:46] *** Joins: KindOne (KindOne@moz-4731289C.dynamic.ip.windstream.net)
[08:45:00] *** Quits: siavashserver (siavash@5C538F84.AC532F77.82A25C10.IP) (Quit: Konversation terminated!)
[08:54:34] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Connection reset by peer)
[08:54:59] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[08:55:56] *** Joins: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz)
[08:57:54] *** Quits: Jesin (Jesin@moz-63C897DA.res.lehigh.edu) (Quit: Leaving)
[09:00:40] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[09:00:40] *** Joins: sebcrozet (sebcrozet@moz-A855F6C0.w82-127.abo.wanadoo.fr)
[09:02:33] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[09:11:16] *** Quits: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com) (Quit: csherratt)
[09:14:37] *** Quits: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz) (Quit: Busying myself...)
[09:16:00] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Input/output error)
[09:24:31] <mark_edward> when since is @ gone?
[09:26:08] <celeron55> how can i disable the "missing crate link meta" warnings?
[09:27:32] <celeron55> rustc's "-A --allow OPT      Set lint allowed" looks like such, but is there a list of those options somewhere
[09:28:34] *** Quits: tedh (tedh@moz-F3B34318.hsd1.il.comcast.net) (Ping timeout)
[09:29:21] *** Joins: refold (gman@moz-42D68426.a258.priv.bahnhof.se)
[09:29:36] <celeron55> oh, -W help
[09:30:06] *** Joins: mib_gy674p (Mibbit@4D1540EE.A1B59304.A6A3E353.IP)
[09:30:29] <celeron55> well looks like there's nothing for that
[09:31:04] <celeron55> warning: missing crate link meta `package_id`, using `foo` as default
[09:31:38] <celeron55> ^ these are very annoying; i can't bother to write some unnecessary tags in my in-project crates that will just get outdated some day and produce even more useless warnings again
[09:34:25] *** Quits: Kxepal (Miranda@moz-E41D9856.pppoe.mtu-net.ru) (Ping timeout)
[09:35:00] <celeron55> (my makefile takes care of filenames and the building of dependencies; i don't need rustc to do that, and these crates are useless without the other parts of this thing (they're just used as compile units))
[09:35:11] *** Quits: mib_gy674p (Mibbit@4D1540EE.A1B59304.A6A3E353.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[09:37:18] <SingingBoyo> celeron55: chances of package_id being removed are very small AFAIK. Also, while they're the best thing for now, makefiles are probably not going to be the best way to build rust programs in the future.
[09:37:31] *** Joins: Kxepal (Miranda@moz-55D1CED9.pppoe.mtu-net.ru)
[09:38:25] <celeron55> SingingBoyo: but i'm compiling these things right now, not in the future
[09:39:48] <SingingBoyo> celeron55: yeah, I'm just not convinced by your argument that it's 'unnecessary'.  I just include the package_id, even if nothing I do needs it.
[09:40:55] <SingingBoyo> celeron55: also, why are you using crates as smaller compile units that are useless on their own?  Is it really that much slower to do one bigger crate?
[09:42:19] <celeron55> SingingBoyo: i'm fed up with projects' compile times getting too large when they grow
[09:42:32] <celeron55> (incremental compile times)
[09:43:02] *** Joins: rca (rcatolino@moz-D9D6A93B.adsl.proxad.net)
[09:43:52] <FreeFull> mark_edward: @ is getting replaced
[09:44:03] <SingingBoyo> celeron55: I think that's just a hazard of using rust right now. There's definitely been talk about how to avoid recompiling things when it's not needed though
[09:44:05] <celeron55> maybe i'll write a custom filter to filter out these unnecessary warnings so that i can focus on what matters
[09:44:08] <mark_edward> i know that, but when is it gone?
[09:44:25] <FreeFull> I don't know, is it gone yet?
[09:45:00] <SingingBoyo> mark_edward: possibly when Gc<T> gets implemented.
[09:45:19] <mark_edward> Gc<T> exists already i think
[09:45:33] <mark_edward> http://static.rust-lang.org/doc/master/std/gc/struct.Gc.html
[09:46:52] <SingingBoyo> mark_edward: oh right. whoops.
[09:47:28] <mark_edward> think it's waiting on implementation of placement new syntax `box (place) expr`
[09:47:55] <SingingBoyo> mark_edward: now that I think about it, IIRC the compiler itself has a lot of @-ptrs, so it can't really be removed until it's out of the compiler.
[09:48:02] <mark_edward> yup
[09:48:07] <celeron55> SingingBoyo: it's not a hazard of using rust right now when using crates like this; i don't understand why people don't care about making it painless when it's just a matter of allowing the hiding of certain types of warnings (which is needed in the future anyway as a generic feature)
[09:48:08] <mark_edward> that's gonna be a fun PR
[09:49:41] <SingingBoyo> mark_edward: pretty sure box or whatever it ends up being is more a change from having ~(x+y) allocate space to having box (x+y) allocate space (or put things into the right space)
[09:49:43] *** Quits: fournm (Aria@moz-ABB60BA0.austin.res.rr.com) (Quit: Leaving)
[09:50:08] *** Quits: Kingsley (kingsley@9B172CBE.BEA5C56D.DF4B730F.IP) (Ping timeout)
[09:50:11] <SingingBoyo> mark_edward: don't really think it's relevant to @, but I could definitely be wrong about that
[09:50:36] *** Joins: eddyb (eddy@BC47B8BA.9065A63B.FCAAE698.IP)
[09:50:50] *** Joins: Kingsley (kingsley@9B172CBE.BEA5C56D.DF4B730F.IP)
[09:51:00] *** Joins: _eddyb_ (eddy@moz-68E0B7D0.residential.rdsnet.ro)
[09:51:34] *** Joins: tedh (tedh@moz-F3B34318.hsd1.il.comcast.net)
[09:51:49] <mark_edward> true
[09:52:34] *** Quits: eddyb (eddy@BC47B8BA.9065A63B.FCAAE698.IP) (Ping timeout)
[09:52:47] <celeron55> is there a way to make rustc output colored text while piping it's stderr somewhere?
[09:53:07] <celeron55> like ls --color=always
[09:56:24] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Ping timeout)
[09:56:25] <FreeFull> I don't think you can control rustc's colouring at all right now
[09:56:49] *** Quits: overfl0w (overfl0w@moz-14327773.range217-42.btcentralplus.com) (Ping timeout)
[09:56:58] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[09:58:06] <celeron55> for comparison, in clang that seems to be -fcolor-diagnostics
[10:00:40] *** Joins: overfl0w (overfl0w@moz-B65B2C7F.range217-42.btcentralplus.com)
[10:01:52] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[10:03:30] *** Joins: glennsl (textual@moz-5D7B804F.getinternet.no)
[10:03:33] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[10:12:25] *** Quits: KindOne (KindOne@moz-4731289C.dynamic.ip.windstream.net) (Ping timeout)
[10:15:25] *** Quits: TimAbraldes (quassel@moz-7FD19BDC.hsd1.or.comcast.net) (Connection reset by peer)
[10:16:18] *** Joins: KindOne (KindOne@moz-2443848B.dynamic.ip.windstream.net)
[10:22:09] *** Quits: Yurumechan (23f9939a@B2F514.E4420F21.EEF52F3A.IP) (Ping timeout)
[10:23:23] *** Joins: Yurumechan (23f9939a@B2F514.E4420F21.EEF52F3A.IP)
[10:25:52] *** Quits: voxpopuli (fanservice@moz-FE161659.wv.cc.cmu.edu) (Ping timeout)
[10:32:23] *** Quits: overfl0w (overfl0w@moz-B65B2C7F.range217-42.btcentralplus.com) (Ping timeout)
[10:39:22] *** Quits: glennsl (textual@moz-5D7B804F.getinternet.no) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[10:42:42] *** Joins: nkoep (nik@moz-BDA9A1D1.pool.mediaways.net)
[10:46:18] *** Joins: TisButMe (Mibbit@moz-40463609.w80-9.abo.wanadoo.fr)
[10:49:17] *** Joins: Sorella (quildreen@9D963F5D.DF5D8AE7.54BCAB54.IP)
[10:51:33] <ezyang> In http://smallcultfollowing.com/babysteps/blog/2013/10/24/iterators-yielding-mutable-references/ there is a proposed mutable iterator interface, which is unsound. But, IIUC, I have some iterator code which has just this interface? 
[10:51:41] <ezyang> Did something change? 
[10:54:44] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[10:57:20] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[11:00:08] *** Joins: glennsl (textual@moz-5D7B804F.getinternet.no)
[11:02:18] *** Quits: SingingBoyo (SingingBoy@DA28FB90.A5D0D593.4F048BDC.IP) (Ping timeout)
[11:03:05] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[11:04:53] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[11:05:41] *** Quits: sarclops (sarclops@moz-7322FD00.tbcn.telia.com) (Quit: sarclops)
[11:06:39] *** Joins: _Vi (vi@527C345F.497AA854.B16B3BE6.IP)
[11:08:55] <_Vi> Are there plans to make Safe Rust (like Safe Haskell)? This means the API is restricted at compile time (no unsafe and only explicitly allowed imports), so untrusted source code can be compiled and loaded with only concerns about DoS.
[11:09:08] *** Quits: Kxepal (Miranda@moz-55D1CED9.pppoe.mtu-net.ru) (Quit: Kxepal)
[11:09:28] *** Joins: Kxepal (Miranda@moz-55D1CED9.pppoe.mtu-net.ru)
[11:11:24] *** Quits: telotortium (rmi1@moz-C8F8CE6.hsd1.ca.comcast.net) (Ping timeout)
[11:12:24] *** Quits: Kingsley (kingsley@9B172CBE.BEA5C56D.DF4B730F.IP) (Ping timeout)
[11:13:28] *** Joins: Kingsley (kingsley@9B172CBE.BEA5C56D.DF4B730F.IP)
[11:14:17] <ezyang> Oh, I see, it's specific to vectors 
[11:19:45] *** _eddyb_ is now known as eddyb
[11:21:08] *** Joins: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net)
[11:24:24] <ChrisMorgan> _Vi: I haven't heard any plans for such a thing. Sandboxing system calls is the main direction I've heard being followed.
[11:24:33] *** Joins: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net)
[11:25:01] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[11:27:50] <_Vi> Looks like unportable solution (contrary to API-based one). Are there essential problems in implementing security in that way? I.e. what is the worst thing the code without "unsafe" (and not calling any libs with "unsafe") can do? The first step can be a compiler option to forbid all "unsafe" in a compilation unit.
[11:27:54] <eddyb> Rust + PNaCl could work very nicely
[11:28:02] <ssbr> That would trust the compiler a bit much more than is necessary
[11:28:43] <eddyb> _Vi: well, it's a bit funny that sometimes a grep for "unsafe" is enough to guarantee some safety
[11:29:21] <ssbr> _Vi: running untrusted code in the same process as trusted code is very difficult if the language wasn't designed with that in mind, FWIW. If you want to run code insecurely, you're best off running it in a sandboxed process.
[11:29:36] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Ping timeout)
[11:29:42] <ssbr> (multiple layers of sandbox, obviously)
[11:29:44] <_Vi> eddyb, Can some tricky macro combine "u", "n" and "safe" into "unsafe" without explicitly containing the word "unsafe"?
[11:30:01] <ssbr> eek
[11:30:04] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[11:30:05] <ssbr> if you want to run insecure code*
[11:30:13] <eddyb> _Vi: I don't think you can create a keyword with a macro
[11:30:14] <ssbr> whole-process sandboxes let you layer security better as well.
[11:30:22] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Ping timeout)
[11:30:23] <eddyb> I mean, a keyword is not an ident AFAIK
[11:30:44] *** Quits: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net) (Ping timeout)
[11:30:49] *** Joins: ricepuddin (graham@moz-7D68765A.cable.virginm.net)
[11:31:49] <_Vi> Imagine a use case: Game with user-contributable levels (that can be malware). Levels can contain math-intensive scripts that need to be executed fast. Exhausting memory or infinite loop is acceptable rick. But starting other processes, messing with files is not.
[11:32:38] <ssbr> _Vi: Sure. But trying to embed a huge programming language that was not created for secure execution is not a good move.
[11:33:07] <ssbr> Trying to blacklist any features that might introduce security will lead to you accidentally missing this thing, and that other thing, and that thing that combines in a weird way with that foobarbaz.
[11:33:32] <ssbr> if you want this kind of thing, you want a language designed from the ground up for it, like E.
[11:33:48] <_Vi> ssbr, With Safe Haskell, for example, the game can compile levels with only some API securely exposed. Are there essential reasons the similar scheme can't be applied to Rust?
[11:34:18] <ssbr> _Vi: not that I am aware of, but you won't know until you progressively build an audited whitelist that contains nearly everything.
[11:34:52] <ssbr> such a whitelist would be obsolete in a few weeks, which is a good reason not to bother right now I guess.
[11:35:26] <eddyb> I meant to say "creating an exploitable Rust program without using the keyword `unsafe` is a serious challenge"
[11:35:29] <ezyang> ssbr: Well, the Safe Haskell approach is quite clever 
[11:35:29] <_Vi> ssbr, Why everything? Math functions + some restricted game API (creating/removing game objects, declaring game over, showing messages). The game itself runs outside sandbox, only levels are sandboxed.
[11:35:47] <ezyang> They key is that it doesn't make any judgment about what a safe sandbox is 
[11:35:49] <dbaupp> _Vi: for unsafe {} blocks, there is `#[forbid(unsafe_block)];`, which one can put at the crate root and will disallow any explicit `unsafe {}` blocks (including ones generated by macros; but not ones that are generated by built-in macros, or used in external crates).
[11:35:50] <ssbr> _Vi: then audit and whitelist those things that you need, sure.
[11:36:03] <ezyang> Instead, you have users define a custom monad, which enforces the sandbox. So it's entirely up to the user to define the TCB 
[11:36:03] <ssbr> _Vi: or, better yet, use a language that already did this, like js or E or such
[11:36:08] <ssbr> or Safe Haskell :(
[11:36:29] <ezyang> "Clearly, Rust should have monads!" 
[11:36:35] <_Vi> As far as I know, it's easier to embed Rust compiler into application than Haskell compiler...
[11:36:52] <ssbr> ezyang: well, it should have the do notation
[11:37:03] <ssbr> _Vi: I doubt it. For one thing, GHC is stable.
[11:37:11] <_Vi> Is E compiled (or at least allows fast math)?
[11:37:12] <ssbr> that immediately makes it significantly easier to embed than Rust
[11:37:17] <ezyang> _Vi: embedding Haskell is actually pretty easy 
[11:37:32] <ssbr> also, GHC has an explicitly supported API for embedding haskell code, which is great
[11:37:50] <ssbr> embedding Rust is, last I checked, horrible. And you lose the runtime.
[11:38:25] <ssbr> _Vi: I think it's more like Python.
[11:38:41] <ssbr> soooo, slow.
[11:39:23] <_Vi> Will Safe Haskell's approach be available in Rust in future? I.e. are you going to avoid any changes that make unsafe-less code that depends only on cleared libraries able to execute arbitrary code?
[11:40:00] <_Vi> Python (even with PyPy) is verified to be too slow for my use case.
[11:40:04] <dbaupp> ssbr: you don't actually lose the runtime; you can start it explicitly yourself
[11:40:04] <geomyidae> where are the docs stored?
[11:40:17] <ssbr> dbaupp: Well, that's new to me.
[11:40:18] <dbaupp> ssbr: (e.g. wycats_ is doing so *in production*!)
[11:40:32] <dbaupp> ssbr: yeah, it's only become possible/usable recently
[11:40:45] <ssbr> Oh, that's new to everyone then. Great! New features! love 'em.
[11:40:59] <ssbr> Is there a reason to worry about making code runtime-less compatible then?
[11:41:21] <geomyidae> oh it is in the source, it's just that the [src] link is wrong: http://static.rust-lang.org/doc/master/extra/getopts/index.html
[11:41:27] <ezyang> " It is not necessary to use the pattern matching let assignment to break apart the current node into its three fields... The borrow checker is smart enough to handle paths like this as long as they are contained within a single function." --> hm, this is not true in my experience 
[11:41:35] <geomyidae> shouldn't that link to getopts.rs instead of libs.rs for [src]?
[11:42:10] <dbaupp> ssbr: the runtime is big and expensive, and it's nicer to be able to run without it? (e.g. for a tiny 1microsecond call from C into Rust, one doesn't necessarily want to start up the whole runtime.)
[11:42:28] <ssbr> dbaupp: ah yes, if I'm writing C libraries.
[11:42:37] <ssbr> or libraries used by C libraries. Or whatever.
[11:43:04] <ssbr> dbaupp: I was playing around with ideas of using rust tasks for parallelism (they do CPU-parallelism, right?) but wasn't sure if it'd be idiomatic to do that silently behind the scenes
[11:43:26] <ssbr> I suspect maybe there should be either a compile-time switch to turn that off, or else an alternate API that doesn't do that, I guess.
[11:43:42] *** Joins: alonlevy (alon@1AB0B7F8.31F49B3D.AB64B967.IP)
[11:43:43] *** Joins: Blub\1 (wry@620605B3.71150E1A.237AE2BA.IP)
[11:44:00] *** Quits: Blub\0 (wry@620605B3.71150E1A.237AE2BA.IP) (Ping timeout)
[11:44:09] <dbaupp> ssbr: "behind the scenes" as in an FFI call into the Rust lib would run up a pile of tasks for some parallelism?
[11:44:43] <ssbr> dbaupp: behind the scenes as in a function spins off some tasks and waits for them to complete and then returns the aggregated result.
[11:44:45] *** Quits: glennsl (textual@moz-5D7B804F.getinternet.no) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[11:45:06] <dbaupp> that sounds perfectly reasonable
[11:45:14] <ssbr> But it wouldn't work with RT-less rust
[11:45:20] <dbaupp> it almost does
[11:45:27] <ssbr> Oh?
[11:45:47] <dbaupp> apparently a goal is to have the std::task backend agnostic
[11:46:04] <ssbr> so it could work even with a 1:1 threading model, which would be used in RT-less rust?
[11:46:15] <dbaupp> so that if there's no libuv runtime, it will automatically fall back to using OS threads.
[11:46:16] <dbaupp> yeah
[11:46:39] <dbaupp> (e.g. printing/IO currently does that, falling back to native calls.)
[11:48:12] <ssbr> well then.
[11:48:40] *** Quits: ssbr_ (~ssbr@46FE74EC.C60FE7DC.4065847B.IP) (Ping timeout)
[11:49:02] <dbaupp> ssbr: acrichto is the person to talk to about the details
[11:49:27] <ssbr> haha, they're not relevant yet. I just had a lot of time to think about a bunch of interesting but not currently useful things :(
[11:49:41] * ssbr had to walk through the rain today, no book to read or nothin'
[11:50:54] <aph> ssbr: aww.
[11:53:49] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Ping timeout)
[11:53:57] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[11:54:23] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[11:54:41] <geomyidae> :/ So I figured I'd want serialize::Encoder for encoding a HashMap to bytes to put through a Udp{Socket|Stream} but the only impls are for json/ebml, is that correct?
[11:54:48] <geomyidae> Is there a more obvious way?
[11:55:26] *** Quits: GeneralMaximus (ankur@B4DF73F6.7D84F5AD.260B031E.IP) (Quit: Computer has gone to sleep.)
[11:57:18] <mark_edward> geomyidae, no, and such a plan is unsound. how do you know the other machine has the same endianess, what if the objects contains pointers, etc.
[11:58:14] <dbaupp> geomyidae: what do you mean?
[11:58:17] <mark_edward> generaly just taking an in memory representation of an object is unsafe. 
[11:58:56] <dbaupp> geomyidae: does serialising to json (or ebml) through the Socket/Stream work?
[11:58:56] *** Quits: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[11:59:01] <ssbr> rusti: let i = Some(1); *i
[11:59:02] -rusti- <anon>:9:26: 9:28 error: can only dereference enums with a single variant which has a single argument
[11:59:02] -rusti- <anon>:9          let i = Some(1); *i
[11:59:02] -rusti-                                    ^~
[11:59:02] -rusti- error: aborting due to previous error
[11:59:02] -rusti- application terminated with error code 101
[11:59:11] <ssbr> Ah well, was worth a shot.
[11:59:25] <geomyidae> I guess my inner assumption would've been that I'd be encoding to a "common" byte format that would be decoable with the equivalent rust on the other side, similar to if I used json.
[11:59:50] <geomyidae> dbaupp: I've not tried yet, going to give it a go maybe, unless I'm just completely on the wrong track
[12:00:13] <dbaupp> geomyidae: let mut encoder = json::Encoder::new(&mut udp_stream); map.encode(&mut encoder) should work (using BufferedWriter around the udp_stream would likely be a good idea.)
[12:03:47] *** Joins: ssbr_ (~ssbr@46FE74EC.C60FE7DC.4065847B.IP)
[12:04:43] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[12:06:24] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[12:06:57] *** Joins: beifeng (Mibbit@598FF6D.7A85645C.C7DB8B78.IP)
[12:07:05] *** Joins: donri (donri@moz-9BB61102.tbcn.telia.com)
[12:12:21] *** Quits: noy (user@moz-44A5916A.a146.priv.bahnhof.se) (Client exited)
[12:16:23] *** Joins: Ferreus (ferreus@moz-53AC130.pools.arcor-ip.net)
[12:16:27] *** Quits: jstevans (Instantbir@553F89F7.FA95BF59.B7830B68.IP) (Ping timeout)
[12:17:45] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Connection reset by peer)
[12:18:43] *** Joins: jviereck (Adium@moz-8F6BA636.dip0.t-ipconnect.de)
[12:22:26] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[12:24:18] *** Joins: q66_ (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[12:25:20] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Ping timeout)
[12:25:29] *** Joins: glennsl (textual@moz-5D7B804F.getinternet.no)
[12:25:31] *** Joins: kud1ing (Mibbit@moz-D145406E.pools.arcor-ip.net)
[12:28:21] *** Quits: kud1ing (Mibbit@moz-D145406E.pools.arcor-ip.net) (Quit: http://www.mibbit.com ajax IRC Client)
[12:29:02] *** Joins: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net)
[12:35:52] *** Quits: beifeng (Mibbit@598FF6D.7A85645C.C7DB8B78.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[12:35:56] *** Joins: steffenomak (steffenoma@moz-FB0A4BEB.student.uu.se)
[12:36:39] *** Joins: moostik (Icedove@6181009C.10715965.BCDF592F.IP)
[12:38:43] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[12:44:32] *** Quits: moostik (Icedove@6181009C.10715965.BCDF592F.IP) (Ping timeout)
[12:48:26] *** Joins: moostik (Icedove@6181009C.10715965.BCDF592F.IP)
[12:48:37] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[12:49:10] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[12:50:23] *** Quits: Kingsley (kingsley@9B172CBE.BEA5C56D.DF4B730F.IP) (Ping timeout)
[12:50:49] *** Joins: Kingsley (kingsley@9B172CBE.BEA5C56D.DF4B730F.IP)
[12:50:50] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[12:51:25] *** Joins: dd (chatzilla@F63B62E8.8AE8A320.7C0F3359.IP)
[12:54:34] *** Joins: oberstet (quassel@moz-8F7537B0.dynamic.mnet-online.de)
[13:01:00] *** Joins: overfl0w (overfl0w@moz-B408CB9E.range109-158.btcentralplus.com)
[13:02:47] *** Quits: dd (chatzilla@F63B62E8.8AE8A320.7C0F3359.IP) (Ping timeout)
[13:03:39] *** Joins: dd (chatzilla@8CA41291.DAD92AC8.D216A595.IP)
[13:05:47] *** Joins: skade (skade@30BBD5E6.505237C9.CAE22B62.IP)
[13:06:07] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[13:07:58] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[13:08:40] *** Joins: novabyte (novabyte@68860272.ABC206C9.398E636E.IP)
[13:14:54] *** Quits: eddyb (eddy@moz-68E0B7D0.residential.rdsnet.ro) (Ping timeout)
[13:15:52] *** Joins: wilkie (wilkie@moz-A19F104D.pitbpa.fios.verizon.net)
[13:15:52] *** Joins: wolfwood (wolfwood@moz-A19F104D.pitbpa.fios.verizon.net)
[13:16:00] *** Joins: eddyb (eddy@92C54820.41422C5E.2E5184B1.IP)
[13:17:15] *** Joins: _eddyb_ (eddy@moz-68E0B7D0.residential.rdsnet.ro)
[13:18:48] *** Quits: eddyb (eddy@92C54820.41422C5E.2E5184B1.IP) (Ping timeout)
[13:18:59] *** _eddyb_ is now known as eddyb
[13:19:55] *** jorendorff_away is now known as jorendorff
[13:22:24] *** Quits: alonlevy (alon@1AB0B7F8.31F49B3D.AB64B967.IP) (Ping timeout)
[13:27:24] *** Quits: jviereck (Adium@moz-8F6BA636.dip0.t-ipconnect.de) (Quit: Leaving.)
[13:32:24] *** Quits: ssbr_ (~ssbr@46FE74EC.C60FE7DC.4065847B.IP) (Ping timeout)
[13:36:01] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[13:38:46] *** Quits: Kingsley (kingsley@9B172CBE.BEA5C56D.DF4B730F.IP) (Ping timeout)
[13:39:03] *** Quits: eddyb (eddy@moz-68E0B7D0.residential.rdsnet.ro) (Ping timeout)
[13:39:31] *** Joins: eddyb (eddy@92C54820.41422C5E.2E5184B1.IP)
[13:39:51] *** Joins: Kingsley (kingsley@9B172CBE.BEA5C56D.DF4B730F.IP)
[13:41:40] *** Joins: jlong (jlong@moz-6DFDE846.socal.res.rr.com)
[13:43:07] *** Quits: jlong (jlong@moz-6DFDE846.socal.res.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[13:43:23] *** Joins: moostik1 (Icedove@6181009C.10715965.BCDF592F.IP)
[13:43:37] *** Joins: _eddyb_ (eddy@moz-68E0B7D0.residential.rdsnet.ro)
[13:44:13] *** Quits: moostik (Icedove@6181009C.10715965.BCDF592F.IP) (Ping timeout)
[13:44:24] *** Quits: eddyb (eddy@92C54820.41422C5E.2E5184B1.IP) (Ping timeout)
[13:47:23] *** Joins: ssbr_ (~ssbr@46FE74EC.C60FE7DC.4065847B.IP)
[13:48:32] *** jorendorff is now known as jorendorff_away
[13:52:13] *** kimundi is now known as zz_kimundi
[13:52:15] *** Joins: canhtak (canhtak@moz-A53E1151.wl.t.ulaval.ca)
[13:52:35] *** Joins: jstevans (Instantbir@moz-B25CC421.bootp.virginia.edu)
[13:54:16] *** Quits: jstevans (Instantbir@moz-B25CC421.bootp.virginia.edu) (Ping timeout)
[14:03:22] *** Joins: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net)
[14:05:42] *** Quits: dd (chatzilla@8CA41291.DAD92AC8.D216A595.IP) (Quit: ChatZilla 0.9.90.1 [Firefox 25.0.1/20131115110315])
[14:07:36] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[14:07:42] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[14:08:02] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[14:08:06] *** Joins: jlong (jlong@moz-6DFDE846.socal.res.rr.com)
[14:09:21] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[14:11:17] *** Quits: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net) (Ping timeout)
[14:13:27] *** Joins: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net)
[14:13:39] *** Quits: sebcrozet (sebcrozet@moz-A855F6C0.w82-127.abo.wanadoo.fr) (Ping timeout)
[14:21:25] *** Joins: cubic (cubic@moz-80241A3A.mc.videotron.ca)
[14:26:06] *** Joins: dreamer_ (Patryk@90E8C08F.8480A87C.DDAA0084.IP)
[14:29:22] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[14:31:35] *** Joins: maxli (maxli@moz-4D28BA20.student.cs.uwaterloo.ca)
[14:36:40] *** Joins: siavashserver (siavash@9AA2663C.C058D00.82A25C10.IP)
[14:38:37] *** Joins: mikezaby (mikezaby@moz-4BF6308B.home.otenet.gr)
[14:38:43] *** Parts: mikezaby (mikezaby@moz-4BF6308B.home.otenet.gr) ()
[14:42:36] *** Quits: siavashserver (siavash@9AA2663C.C058D00.82A25C10.IP) (Quit: Konversation terminated!)
[14:44:23] *** Quits: moostik1 (Icedove@6181009C.10715965.BCDF592F.IP) (Ping timeout)
[14:44:32] *** Quits: skade (skade@30BBD5E6.505237C9.CAE22B62.IP) (Quit: Textual IRC Client: www.textualapp.com)
[14:45:36] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Quit: Gone to save the world!)
[14:46:41] *** Quits: Amanieu (amanieu@10FEE2FD.ECEF57A4.2CFD4520.IP) (Ping timeout)
[14:47:46] *** Joins: moostik (Icedove@6181009C.10715965.BCDF592F.IP)
[14:49:29] *** Joins: Amanieu (amanieu@10FEE2FD.ECEF57A4.2CFD4520.IP)
[14:52:05] *** Quits: nkoep (nik@moz-BDA9A1D1.pool.mediaways.net) (Ping timeout)
[14:53:13] *** Quits: smodo (ford_p@moz-6398EFDF.dclient.hispeed.ch) (Client exited)
[14:54:57] *** Quits: JanC (janc@moz-92DADE21.dsl.scarlet.be) (Ping timeout)
[15:00:11] *** Joins: tcr (tcr@moz-6FEAEFBC.hfc.comcastbusiness.net)
[15:01:52] *** Joins: tav (tav@moz-9D761D7C.range31-52.btcentralplus.com)
[15:07:42] *** jorendorff_away is now known as jorendorff
[15:07:44] *** Joins: nkoep (nik@moz-12C93D86.vpn.rwth-aachen.de)
[15:09:38] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[15:09:39] *** Joins: JanC (janc@moz-6323E888.dsl.scarlet.be)
[15:11:25] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[15:13:12] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[15:13:12] *** ChanServ sets mode: +ao dherman dherman
[15:13:16] *** Joins: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net)
[15:13:24] *** jorendorff is now known as jorendorff_away
[15:14:30] *** Quits: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net) (Quit: Sharp)
[15:17:03] *** Quits: lpy (lpy@12172131.F09091A8.1348A864.IP) (Client exited)
[15:19:59] *** Quits: alex-abreu (alex@moz-7421D6C9.mc.videotron.ca) (Client exited)
[15:21:55] *** Joins: jvns (bork@moz-DE62990.nyc.res.rr.com)
[15:23:20] *** _eddyb_ is now known as eddyb
[15:25:07] *** Joins: mihneadb (mihneadb@moz-40CB49E4.residential.rdsnet.ro)
[15:25:24] *** Joins: sebcrozet (sebcrozet@moz-87D51607.w80-13.abo.wanadoo.fr)
[15:26:01] *** Joins: Ms2ger (Ms2ger@moz-7C292AC.adsl-dyn.isp.belgacom.be)
[15:32:11] *** Joins: kud1ing (Mibbit@moz-D145406E.pools.arcor-ip.net)
[15:35:05] * kud1ing can't find the documentation for the println macro
[15:35:12] *** Quits: refold (gman@moz-42D68426.a258.priv.bahnhof.se) (Quit: leaving)
[15:35:27] <kud1ing> is it possible to print a C string?
[15:35:48] *** zz_kimundi is now known as kimundi
[15:36:42] *** Quits: rustyPipe (Mibbit@moz-2198B477.dllstx.fios.verizon.net) (Quit: http://www.mibbit.com ajax IRC Client)
[15:36:49] <kimundi> kud1ing: You could turn the C string into a rust string, and print that?
[15:37:16] <bodie> Hello all.  Does anyone know whether it's possible to auto (OS-) thread Rust across all cores?
[15:37:36] <kud1ing> kimundi: it is passed down to a C-function and i want to inspect length (appended Null)
[15:37:42] <kimundi> bodie: It's possible, and it is also what rust does per default
[15:37:42] <bodie> I'm really intrigued by the green threading, but I'm not confident that it scales to cores (while I know that Clojure for example does)
[15:37:43] <kud1ing> because it crashes
[15:37:46] *** Joins: alex-abreu (alex@moz-7421D6C9.mc.videotron.ca)
[15:37:52] <bodie> Really?  I was told it defaults to a single OS thread
[15:38:20] <bodie> Where can I find more info about this?
[15:38:47] <kimundi> bodie: Maybe it does that now, but in either case the system is designed to use as many OS cores as schedulers for green threads as you want.
[15:39:28] <kimundi> kud1ing: What crashes?
[15:39:45] <bodie> Ok.  Hmm.  Do you know if there's a way to verify or control that behavior?  I'd like to know for sure.  :)
[15:39:46] <kud1ing> sqlite3_finalize
[15:40:38] <kimundi> bodie: Not sure, and the defaults and the general API about that is still in flux
[15:40:56] * bodie has a sad
[15:41:20] <bodie> Do you happen to know if there's a roadmap for a 1.0 release?
[15:41:27] *** Joins: ksh8281 (Mibbit@93E02D7B.BACDE851.97B9B372.IP)
[15:41:37] *** Parts: ksh8281 (Mibbit@93E02D7B.BACDE851.97B9B372.IP) ()
[15:42:35] <bodie> Also interested in whether anyone has suggestions for a particularly awesome and more importantly, fresh Rust OSS project for me to go snoop around in to learn more.  :D
[15:43:03] *** Quits: tcr (tcr@moz-6FEAEFBC.hfc.comcastbusiness.net) (Client exited)
[15:43:07] *** Joins: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net)
[15:43:33] <kud1ing> kimundi: https://github.com/linuxfood/rustsqlite/issues/59
[15:43:33] *** Joins: tcr (tcr@moz-6FEAEFBC.hfc.comcastbusiness.net)
[15:43:54] <kud1ing> kimundi: the call looks correct, i don't know what's the problem
[15:44:04] *** Quits: moostik (Icedove@6181009C.10715965.BCDF592F.IP) (Ping timeout)
[15:44:13] <kud1ing> kimundi: also sqlite copies the string so the should not be a lifetime issue
[15:44:20] *** kimundi is now known as zz_kimundi
[15:44:45] <bjz> kud1ing: you can get some more info on println! in std::fmt
[15:44:56] <bjz> ie. token specifiers
[15:45:17] <kud1ing> bzg: thanks
[15:45:17] <dwrensha> bodie: I think https://github.com/dwrensha/capnproto-rust is pretty awesome. But I may be biased.
[15:45:24] *** Quits: tcr (tcr@moz-6FEAEFBC.hfc.comcastbusiness.net) (Ping timeout)
[15:45:28] <bjz> but yeah, macros and syntax extensions really need docstrings
[15:45:36] <bjz> and be exportable
[15:46:26] <kud1ing> bjz: i agree: https://github.com/mozilla/rust/issues/6444
[15:47:10] <bodie> I like biased opinions ;)
[15:47:25] <bodie> All opinions are biased, therefore biased opinions are honest ones!
[15:47:50] *** Quits: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net) (Quit: Sharp)
[15:47:53] *** Joins: moostik (Icedove@6181009C.10715965.BCDF592F.IP)
[15:48:02] <bodie> "Think JSON, except binary."  I have been, for years!
[15:48:12] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[15:48:26] * bjz is immediately suspicious when anybody prefaces a comment with 'in my opinion....'
[15:48:39] *** Joins: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net)
[15:49:56] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[15:50:37] <bjz> dwrensha: what kind of things is the capnproto format good for?
[15:51:37] *** Joins: tcr (tcr@moz-6FEAEFBC.hfc.comcastbusiness.net)
[15:51:45] *** Quits: kud1ing (Mibbit@moz-D145406E.pools.arcor-ip.net) (Quit: http://www.mibbit.com ajax IRC Client)
[15:51:55] <bjz> dwrensha: could it be decent for serializing game state?
[15:52:12] <dwrensha> bjz: any time you need data to live longer than your process
[15:52:36] <dwrensha> bjz: yes
[15:53:55] *** Quits: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[15:54:48] <dwrensha> bjz: Cap'n Proto gives you fast encoding/decoding, evolvability, and a type system that matches extremely well with Rust's
[15:55:05] <bjz> dwrensha: so do you use the .capnp format directly, or do you compile that?
[15:55:09] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[15:55:15] <bodie> yeah, that lib looks badass.
[15:55:40] *** Joins: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com)
[15:55:42] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[15:55:58] <dwrensha> bjz: .capnp files define schemas. That's where you declare the type of your data.
[15:56:23] <dwrensha> capnproto-rust generates Rust code from those schemas
[15:56:32] *** Quits: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com) (Quit: csherratt)
[15:56:36] *** Joins: lfox (lfox@moz-B8648F0F.nycmny.fios.verizon.net)
[15:56:55] <bjz> ohh
[15:57:14] <bjz> interesting!
[15:57:29] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[15:57:29] *** Quits: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net) (Quit: Sharp)
[15:57:44] *** Joins: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net)
[15:57:49] *** Joins: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com)
[15:58:00] <bjz> sorry, was just skimming - didn't realise it was a schema
[15:58:17] <bjz> (looking at your repo in conjunction with http://kentonv.github.io/capnproto/)
[15:58:29] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[15:59:55] *** Quits: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net) (Quit: Sharp)
[16:01:12] *** zz_kimundi is now known as kimundi
[16:02:53] *** Joins: StarLight (StarLight@moz-6761B40.dynamic.avangarddsl.ru)
[16:09:25] *** Joins: lpy (lpy@12172131.F09091A8.1348A864.IP)
[16:10:41] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[16:11:45] *** Quits: canhtak (canhtak@moz-A53E1151.wl.t.ulaval.ca) (Quit: canhtak)
[16:12:30] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[16:15:26] *** Joins: AvianFlu (AvianFlu@974D245D.130DDD13.67CD788C.IP)
[16:15:59] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[16:15:59] *** ChanServ sets mode: +ao dherman dherman
[16:17:08] *** Joins: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net)
[16:18:12] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[16:18:37] *** Joins: beifeng (Mibbit@598FF6D.7A85645C.C7DB8B78.IP)
[16:25:43] *** Joins: victorporof (victorporo@5877FE87.8F63DEBC.9B1E38F4.IP)
[16:26:58] *** Joins: tiffany (kawaii@moz-FC0DB29D.dhcp.embarqhsd.net)
[16:30:02] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[16:30:29] *** Joins: telotortium (rmi1@moz-C8F8CE6.hsd1.ca.comcast.net)
[16:32:02] *** Joins: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net)
[16:33:08] *** Quits: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net) (Quit: Sharp)
[16:34:42] *** Quits: overfl0w (overfl0w@moz-B408CB9E.range109-158.btcentralplus.com) (Ping timeout)
[16:35:19] *** Joins: overfl0w (overfl0w@moz-635F0D19.range217-42.btcentralplus.com)
[16:37:44] *** Quits: jvns (bork@moz-DE62990.nyc.res.rr.com) (Ping timeout)
[16:38:14] *** Joins: canhtak (canhtak@moz-A53E1151.wl.t.ulaval.ca)
[16:39:29] *** Joins: kobsu (Mibbit@moz-C62ECF41.pp.htv.fi)
[16:40:10] *** Joins: sellout (sellout@moz-AE26682A.hlrn.qwest.net)
[16:40:21] *** sellout is now known as sellout-
[16:41:56] *** Joins: thewonderidiot (mike@moz-5506A033.hsd1.ca.comcast.net)
[16:42:35] *** Joins: nsf (nsf@moz-EEF3238A.convex.ru)
[16:43:42] *** Quits: moostik (Icedove@6181009C.10715965.BCDF592F.IP) (Ping timeout)
[16:45:02] *** Quits: Sgeo (quassel@moz-D0F30617.dyn.optonline.net) (Connection reset by peer)
[16:47:52] *** Quits: canhtak (canhtak@moz-A53E1151.wl.t.ulaval.ca) (Quit: canhtak)
[16:48:00] *** Joins: jviereck (Adium@moz-8F6BA636.dip0.t-ipconnect.de)
[16:50:56] *** Quits: sellout- (sellout@moz-AE26682A.hlrn.qwest.net) (Quit: Leaving.)
[16:52:53] *** Joins: Hildar (Mibbit@E5F1B7C9.E01BAB3.51C6DE68.IP)
[16:53:28] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[16:54:51] *** Joins: Sgeo (quassel@moz-D0F30617.dyn.optonline.net)
[16:54:54] *** Quits: tcr (tcr@moz-6FEAEFBC.hfc.comcastbusiness.net) (Client exited)
[16:55:15] *** Joins: tcr (tcr@moz-6FEAEFBC.hfc.comcastbusiness.net)
[16:57:03] *** Quits: tcr (tcr@moz-6FEAEFBC.hfc.comcastbusiness.net) (Ping timeout)
[16:58:07] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[16:58:32] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[16:59:14] *** Quits: kobsu (Mibbit@moz-C62ECF41.pp.htv.fi) (Quit: http://www.mibbit.com ajax IRC Client)
[16:59:48] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[17:02:03] *** Quits: KindOne (KindOne@moz-2443848B.dynamic.ip.windstream.net) (Ping timeout)
[17:02:22] *** Joins: fenster (Mibbit@moz-980DDEA5.columbus.res.rr.com)
[17:02:37] *** Quits: fenster (Mibbit@moz-980DDEA5.columbus.res.rr.com) (Quit: http://www.mibbit.com ajax IRC Client)
[17:06:00] *** Joins: KindOne (KindOne@1EC442FB.7E8839F4.34F73994.IP)
[17:06:09] *** Joins: hoverbear (hoverbear@moz-86FCBF4B.gv.shawcable.net)
[17:06:24] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Ping timeout)
[17:07:24] <Hildar> Is there any way to make an equivalent of this http://pastebin.com/tTDnUuaY in rust? Make a base-class (trait) with a non-overridable function? Or just accept that the user can override it if they really want to.
[17:08:00] *** Joins: canhtak (canhtak@moz-A53E1151.wl.t.ulaval.ca)
[17:08:12] *** Quits: paulproteus (quassel@199.199.210.158) (Ping timeout)
[17:08:34] *** Joins: paulproteus (quassel@458FE134.3EC36C88.CBDCF1DC.IP)
[17:10:55] *** Quits: eddyb (eddy@moz-68E0B7D0.residential.rdsnet.ro) (Ping timeout)
[17:11:16] <cmr> Hildar: no such thing as non-overridable function. Keep in mind that traits are nothing like classes, nor do they try to be.
[17:11:52] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[17:11:56] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[17:12:21] <Hildar> Yeah, I understand. Thank you.
[17:13:14] <cmr> that translates into https://gist.github.com/cmr/722cb21975c9b261f6f3 though
[17:13:37] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[17:14:29] *** Joins: sgnr (sgnr@moz-2B79DC5D.cpe.distributel.net)
[17:14:43] <phil_> i had a dream last night that someone added a LineIterator to BufferedReader
[17:14:47] *** Joins: eddyb (eddy@moz-68E0B7D0.residential.rdsnet.ro)
[17:14:52] <phil_> someone please tell me my dream was real
[17:15:00] *** Quits: dxza (reisen@moz-BAE4CA9C.cable.virginm.net) (Ping timeout)
[17:15:36] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[17:15:37] <cmr> phil_: sorry!
[17:15:44] <phil_> :(
[17:15:48] <cmr> that'd be fairly simple to add, though, you should do it! :)
[17:15:57] <phil_> ive tried
[17:16:07] <phil_> but im a failure
[17:16:08] <hoverbear> I blame cmr.
[17:16:11] <phil_> cant make it work
[17:16:23] <phil_> i mean it seems simple
[17:16:37] <phil_> impl iterator for lineiterator
[17:16:53] <phil_> and define fn next = readline()
[17:17:05] <hoverbear> Last night I had a dream the CoreOS folks fixed their SDK and I got to play with my SSD finally instead of having to dork around with UEFI crap with Arch for hours.
[17:17:06] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[17:17:06] *** ChanServ sets mode: +ao dherman dherman
[17:17:20] <phil_> but i run into all these errors about sucg and such not being traits
[17:17:32] <phil_> haha hoverbear 
[17:17:39] *** Joins: IRCMonkey27114 (sellout-@moz-AE26682A.hlrn.qwest.net)
[17:18:15] *** Joins: tcr (tcr@moz-6FEAEFBC.hfc.comcastbusiness.net)
[17:18:37] *** Parts: IRCMonkey27114 (sellout-@moz-AE26682A.hlrn.qwest.net) ()
[17:18:43] <hoverbear> phil_: Don't get me wrong, I love Arch, but their setup process of UEFISTUB booting is basically trial and error.
[17:18:48] <klutzy> phil_: http://pastebin.com/DsbR9ReF
[17:19:20] *** Joins: dxza (reisen@moz-BAE4CA9C.cable.virginm.net)
[17:19:36] *** Quits: eddyb (eddy@moz-68E0B7D0.residential.rdsnet.ro) (Ping timeout)
[17:19:38] *** Joins: _eddyb_ (eddy@moz-68E0B7D0.residential.rdsnet.ro)
[17:19:42] <klutzy> (made by me and chris morgan some days ago)
[17:19:57] <phil_> man klutzy that is really similar to what i was doing
[17:20:07] *** Quits: tcr (tcr@moz-6FEAEFBC.hfc.comcastbusiness.net) (Ping timeout)
[17:20:07] *** Joins: adridu59 (Mibbit@moz-E1FF077C.rev.numericable.fr)
[17:20:09] <hoverbear> phil_: Turns out you're a seer and it actually happened... Can you dream about mine tomorrow?
[17:20:32] <phil_> i missed that trait LineReader part though
[17:20:34] <phil_> shit
[17:20:53] <phil_> klutzy: you gonna try to get that committed to rust?
[17:21:08] <phil_> sure hoverbear ill give it a shot
[17:21:09] *** Quits: adridu59 (Mibbit@moz-E1FF077C.rev.numericable.fr) (Quit: http://www.mibbit.com ajax IRC Client)
[17:21:19] <hoverbear> phil_: Ok. Thanks!
[17:21:32] <klutzy> phil_: not... yet. I used it in some project which I've deleted hours ago
[17:22:14] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[17:22:36] <phil_> let me go find my code real quick brb
[17:23:08] <klutzy> so I've completely forgot the code until now :p
[17:23:32] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[17:23:39] *** Joins: vodik (simon@moz-B1E1AAD5.dsl.bell.ca)
[17:25:13] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[17:25:14] *** ChanServ sets mode: +ao dherman dherman
[17:25:30] *** _eddyb_ is now known as eddyb
[17:25:50] *** Joins: jvns (bork@83F78700.7DA677FD.1A8F2396.IP)
[17:26:47] *** Joins: tcr (tcr@moz-6FEAEFBC.hfc.comcastbusiness.net)
[17:27:57] *** Joins: synackse (synackse__@7DAC4ACE.77F880E0.D9401097.IP)
[17:28:13] <phil_> klutzy: http://pastebin.com/HBLx6mCV
[17:28:31] <phil_> thats my code
[17:28:33] <phil_> which didnt compile
[17:28:59] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Ping timeout)
[17:29:30] <cmr> why
[17:29:52] <klutzy> because of buffered_reader?
[17:30:00] <phil_> it kept saying that AnyLineIterator wasnt a trait
[17:30:10] <phil_> oh
[17:30:16] <phil_> that was an incomplete change
[17:30:19] <cmr> AnyLineIterator isn't a trait.
[17:30:31] <phil_> line 2 used to say prive buffered_reader
[17:30:33] <phil_> yeah cmr
[17:30:36] <cmr> :p
[17:30:39] <phil_> now i see that
[17:30:40] *** Joins: siavashserver (siavash@84A6A2D0.C446F709.82A25C10.IP)
[17:30:44] <cmr> It's telling you the truth, you should read more closely!
[17:30:46] <phil_> i thought impl defined it as one
[17:30:52] <cmr> no, `trait` defines it as one.
[17:31:03] <phil_> im clearly not a good programmer :D
[17:31:47] *** Quits: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[17:31:49] *** Quits: lpy (lpy@12172131.F09091A8.1348A864.IP) (Quit: Leaving...)
[17:33:24] <phil_> i actually copied my code from the definition of ByteReader
[17:37:49] *** Joins: smodo (ford_p@moz-CCE57F2F.eblcom.ch)
[17:39:52] *** Quits: AvianFlu (AvianFlu@974D245D.130DDD13.67CD788C.IP) (Input/output error)
[17:41:10] *** Quits: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com) (Quit: csherratt)
[17:42:40] *** Quits: smodo (ford_p@moz-CCE57F2F.eblcom.ch) (Ping timeout)
[17:42:51] *** Joins: smodo (ford_p@moz-CCE57F2F.eblcom.ch)
[17:42:55] *** Quits: Hildar (Mibbit@E5F1B7C9.E01BAB3.51C6DE68.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[17:43:52] *** Quits: jviereck (Adium@moz-8F6BA636.dip0.t-ipconnect.de) (Quit: Leaving.)
[17:44:20] *** Joins: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net)
[17:44:37] *** Quits: siavashserver (siavash@84A6A2D0.C446F709.82A25C10.IP) (Quit: Konversation terminated!)
[17:45:04] *** Joins: pepper_chico (pepper_chi@6D1D0FAA.4F150827.E4090502.IP)
[17:45:40] *** kimundi is now known as zz_kimundi
[17:46:36] *** Quits: sgnr (sgnr@moz-2B79DC5D.cpe.distributel.net) (Quit: sgnr)
[17:48:03] *** Joins: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz)
[17:49:27] *** Quits: beifeng (Mibbit@598FF6D.7A85645C.C7DB8B78.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[17:50:00] <wycats_> ssbr: it's a lot less horrible with all of acrichto's latest work
[17:50:39] <wycats_> His very latest lets you spin up a task and communicate with from non-task code
[17:50:49] *** Quits: mihneadb (mihneadb@moz-40CB49E4.residential.rdsnet.ro) (Quit: Computer gone to sleep - Zzzz...)
[17:51:01] *** Joins: SingingBoyo (SingingBoy@DA28FB90.A5D0D593.4F048BDC.IP)
[17:51:06] *** Joins: jstevans (Instantbir@8DA2B352.17A0D1EC.B7830B68.IP)
[17:51:09] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[17:51:39] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[17:52:06] *** Quits: smodo (ford_p@moz-CCE57F2F.eblcom.ch) (Ping timeout)
[17:53:26] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[17:55:30] *** Joins: mikezaby (mikezaby@moz-4BF6308B.home.otenet.gr)
[17:55:44] *** Parts: mikezaby (mikezaby@moz-4BF6308B.home.otenet.gr) ()
[17:58:34] *** Quits: Blub\1 (wry@620605B3.71150E1A.237AE2BA.IP) (Ping timeout)
[17:59:13] *** Joins: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com)
[17:59:33] *** Joins: Blub\1 (wry@620605B3.71150E1A.237AE2BA.IP)
[18:05:31] *** Joins: skeet70 (skeet70@moz-2578911E.bzm-mt.client.bresnan.net)
[18:05:44] *** Quits: vodik (simon@moz-B1E1AAD5.dsl.bell.ca) (Quit: work)
[18:06:37] *** Joins: smodo (ford_p@moz-6398EFDF.dclient.hispeed.ch)
[18:12:09] *** Quits: skeet70 (skeet70@moz-2578911E.bzm-mt.client.bresnan.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[18:13:09] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[18:14:04] *** Joins: jdm (jdm@moz-78156D60.dsl.teksavvy.com)
[18:14:04] *** ChanServ sets mode: +o jdm
[18:14:17] *** Joins: askalski (akuda@moz-C8C3B20C.neoplus.adsl.tpnet.pl)
[18:14:56] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[18:16:30] *** Quits: pepper_chico (pepper_chi@6D1D0FAA.4F150827.E4090502.IP) (Quit: Ex-Chat)
[18:16:54] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[18:17:15] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[18:17:15] *** ChanServ sets mode: +ao dherman dherman
[18:17:30] *** Quits: askalski (akuda@moz-C8C3B20C.neoplus.adsl.tpnet.pl) (Quit: Wychodzi)
[18:21:47] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[18:24:09] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[18:24:22] *** Joins: jviereck (Adium@moz-8F6BA636.dip0.t-ipconnect.de)
[18:25:17] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[18:25:33] *** Joins: refold (gman@moz-42D68426.a258.priv.bahnhof.se)
[18:27:10] *** Joins: morphevs (Adium@moz-2486EF49.dclient.hispeed.ch)
[18:28:45] *** Quits: ssbr_ (~ssbr@46FE74EC.C60FE7DC.4065847B.IP) (Ping timeout)
[18:31:46] <hoverbear> I guess there isn't Rust QT bindings huh?
[18:32:00] <FreeFull> QT is a big beast
[18:32:09] <hoverbear> I know right?
[18:32:13] *** Quits: telotortium (rmi1@moz-C8F8CE6.hsd1.ca.comcast.net) (Client exited)
[18:36:18] <hoverbear> FreeFull: All the toolkits are huge, ugly beasts.
[18:36:30] *** Quits: ricepuddin (graham@moz-7D68765A.cable.virginm.net) (Ping timeout)
[18:36:42] *** Joins: telotortium (rmi1@moz-C8F8CE6.hsd1.ca.comcast.net)
[18:36:52] <phil_> klutzy: i put your line iterator into buffered.rs and its compiling properly
[18:38:39] *** Quits: jviereck (Adium@moz-8F6BA636.dip0.t-ipconnect.de) (Quit: Leaving.)
[18:39:04] <cmr> hoverbear: yes, but Qt is worse than most in that it uses a nice C++ interface
[18:39:23] <cmr> very hard to wrap. SMOKE, which *does* enable bindings, is slow.
[18:39:53] <hoverbear> cmr: I'm not complaining, it would be a huge effort and I don't see the point as web interfaces are usually nicer anyways these days.
[18:40:02] <cmr> sure
[18:40:14] <sfackler> I think someone was working on GTK bindings at some point
[18:40:22] <cmr> there's glib introspection stuff
[18:40:24] <cmr> grust
[18:40:27] <cmr> but it's old
[18:41:30] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[18:41:35] *** Joins: wry (wry@620605B3.71150E1A.237AE2BA.IP)
[18:41:58] *** Quits: Blub\1 (wry@620605B3.71150E1A.237AE2BA.IP) (Ping timeout)
[18:43:04] *** Quits: tedh (tedh@moz-F3B34318.hsd1.il.comcast.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[18:43:48] *** Joins: ssbr_ (~ssbr@46FE74EC.C60FE7DC.4065847B.IP)
[18:44:06] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[18:44:53] *** Quits: oberstet (quassel@moz-8F7537B0.dynamic.mnet-online.de) (Client exited)
[18:47:57] *** Quits: victorporof (victorporo@5877FE87.8F63DEBC.9B1E38F4.IP) (Quit: victorporof)
[18:50:17] <sfackler> phil_: is that an iterator that pulls lines of text out of a reader? if so, it should probably be based off of std::io::Buffer as opposed to BufferedReader
[18:50:54] *** Joins: victorporof (victorporo@5877FE87.8F63DEBC.9B1E38F4.IP)
[18:51:02] <phil_> the one klutzy did is
[18:51:21] <phil_> and thats the one im using
[18:51:42] *** Joins: tikue (tikue@moz-FEADCD38.hsd1.pa.comcast.net)
[18:52:45] *** Joins: jviereck (Adium@moz-8F6BA636.dip0.t-ipconnect.de)
[18:53:34] <phil_> i was basing one off of bufferedreader because i dont know what im doing
[18:53:45] *** Joins: AvianFlu (AvianFlu@moz-C1C884AB.nyc.res.rr.com)
[18:54:34] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[18:54:41] <sfackler> cool :) Buffer is a trait that readers that are buffered can implement, and it defines some nice methods like read_until that should make a line iterator easier
[18:55:27] <phil_> yeah you pretty much just use read_line() as next()
[18:58:13] *** Joins: ricepuddin (graham@moz-7D68765A.cable.virginm.net)
[19:00:54] *** Quits: dreamer_ (Patryk@90E8C08F.8480A87C.DDAA0084.IP) (Connection reset by peer)
[19:01:05] *** Joins: dreamer_ (Patryk@90E8C08F.8480A87C.DDAA0084.IP)
[19:01:26] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[19:02:37] *** Joins: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net)
[19:03:12] *** Joins: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net)
[19:04:36] *** Quits: wry (wry@620605B3.71150E1A.237AE2BA.IP) (Ping timeout)
[19:04:51] *** Quits: heftig (heftig@moz-C9B14E4.dip0.t-ipconnect.de) (Ping timeout)
[19:04:51] *** Joins: wry (wry@620605B3.71150E1A.237AE2BA.IP)
[19:05:04] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[19:12:11] *** Joins: heftig (heftig@moz-C96B5FF5.dip0.t-ipconnect.de)
[19:14:20] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[19:14:28] *** Quits: jviereck (Adium@moz-8F6BA636.dip0.t-ipconnect.de) (Quit: Leaving.)
[19:16:02] *** Quits: AvianFlu (AvianFlu@moz-C1C884AB.nyc.res.rr.com) (Connection reset by peer)
[19:16:03] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[19:17:13] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Quit: Gone to save the world!)
[19:19:37] *** Quits: novabyte (novabyte@68860272.ABC206C9.398E636E.IP) (Quit: Leaving.)
[19:24:21] *** Quits: jvns (bork@83F78700.7DA677FD.1A8F2396.IP) (Client exited)
[19:24:38] *** Joins: alonlevy (alon@moz-EB7C9CF3.telavivmakers.org)
[19:28:22] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[19:29:44] *** Quits: w3lcome (Mibbit@EAD96774.6B9C41FA.6316A47C.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[19:31:02] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[19:31:32] *** zz_kimundi is now known as kimundi
[19:32:12] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Quit: Leaving...)
[19:32:32] *** Joins: earlzlap (earlz@moz-483E1E31.neo.res.rr.com)
[19:32:34] *** Joins: jviereck (Adium@moz-8F6BA636.dip0.t-ipconnect.de)
[19:36:59] *** Quits: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz) (Quit: Busying myself...)
[19:38:12] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[19:38:49] *** Quits: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net) (Ping timeout)
[19:41:28] *** Joins: jeaye (Jeaye@moz-34FEF2BB.hsd1.ca.comcast.net)
[19:42:03] *** Quits: earlzlap (earlz@moz-483E1E31.neo.res.rr.com) (Ping timeout)
[19:42:39] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[19:42:44] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Client exited)
[19:42:46] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[19:43:11] *** Quits: jviereck (Adium@moz-8F6BA636.dip0.t-ipconnect.de) (Quit: Leaving.)
[19:46:48] <enix> Is there anywhere that explains the difference between "trait Foo<'a> { fn bar() }" and "trait Foo {fn bar<'a>() }" and why you would want to use one over the other?
[19:47:48] *** kimundi is now known as zz_kimundi
[19:48:04] *** Joins: AvianFlu (AvianFlu@moz-C1C884AB.nyc.res.rr.com)
[19:48:50] *** Joins: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP)
[19:49:48] *** Quits: canhtak (canhtak@moz-A53E1151.wl.t.ulaval.ca) (Quit: canhtak)
[19:50:09] *** Quits: AvianFlu (AvianFlu@moz-C1C884AB.nyc.res.rr.com) (Input/output error)
[19:50:48] <dwrensha> enix: prefer the second usage. The first may run into some bugs, e.g. https://github.com/mozilla/rust/pull/10813
[19:50:49] *** Joins: docbrown (docbrown@5CE9D448.F0B9EFB2.7F8758CE.IP)
[19:51:22] *** Joins: AvianFlu (AvianFlu@moz-C1C884AB.nyc.res.rr.com)
[19:51:32] *** Joins: Hildar (Mibbit@moz-7F4621B6.cable.virginm.net)
[19:52:47] *** Joins: kriben (kristian@moz-A0399E63.tmi.telenormobil.no)
[19:53:05] *** Joins: tedh (tedh@moz-F3B34318.hsd1.il.comcast.net)
[19:54:26] <dwrensha> lifetime parameters on traits are becoming more usable, but there are still a few issues
[19:54:40] <enix> ok, cool
[19:55:02] <enix> is there anything that they can do that lifetime parameters on the function itself can't? or, is it just shorthand?
[19:56:08] *** Joins: Guest93701 (pascettas@moz-BAA9FE31.cust.dsl.teletu.it)
[19:56:11] <Guest93701> ciao 
[19:56:14] <Guest93701> !list
[19:56:25] *** Parts: Guest93701 (pascettas@moz-BAA9FE31.cust.dsl.teletu.it) ()
[19:56:32] <dwrensha> You need them if you want a trait like `trait FromBuf<'a> { fn from_buf(buf : &'a [u8]) -> Self } `
[19:57:10] *** Quits: Jesse (jruderman@moz-5973C6FA.oc.oc.cox.net) (Quit: Jesse)
[19:57:14] *** Quits: anri (solancile@moz-E49E7C4B.hsd1.wa.comcast.net) (Quit: anri)
[19:58:12] <enix> ah, ok, i hadn't thought of that. thanks
[19:58:41] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Connection reset by peer)
[19:59:12] *** Quits: kriben (kristian@moz-A0399E63.tmi.telenormobil.no) (Quit: Lost terminal)
[20:01:16] <FreeFull> dwrensha: What if the trait has multiple functions, all polymorphic over the type?
[20:01:37] <dwrensha> example?
[20:02:16] *** Joins: kriben (kristian@moz-A0399E63.tmi.telenormobil.no)
[20:02:34] <dwrensha> Each function can bind different type variables.
[20:04:25] *** Joins: ktt3ja (Mibbit@moz-D69B60E4.hsd1.va.comcast.net)
[20:05:42] <kriben> Hi! I am trying to learn rust by writing an irc client. Is it okay to ask for help here?
[20:05:52] <FreeFull> I mean, you want each function to use the same type
[20:06:03] *** Quits: jlong (jlong@moz-6DFDE846.socal.res.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[20:06:06] <myname> kriben: that's what the channel is for
[20:06:23] *** Joins: anri (koz@moz-E49E7C4B.hsd1.wa.comcast.net)
[20:07:00] <kriben> myname: Cool! :-)
[20:09:08] <dwrensha> FreeFull: "trait Foo<'a, T> { fn bar(); fn baz()}" is *not* shorthand for "trait Foo {fn bar<'a, T>(); fn baz<'a,T>()}", if that's what you're asking
[20:09:37] <kriben> I am trying to read input from stdin, and found this example on stackoverflow: http://stackoverflow.com/a/17546731/3608
[20:10:37] <Hildar> Hmm, should traits also get exported by globbed use statements, or is it a bug?
[20:11:47] <dwrensha> Hildar: traits should be imported like anything else, I think
[20:11:52] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[20:12:13] <kriben> The code works when I compile it in small test case (test.rs), but not as part of my other code..
[20:12:50] <cmr> kriben: stack overflow is basically garbage for rust.
[20:13:03] <kriben> cmr: Tell me about it.. ;-)
[20:13:11] <Hildar> Ah, it's only getting exported if I declare the trait as 'pub'. Yet I thought that traits were implicitly pub (I can certainly use them as if it were implicit!)
[20:13:21] <kriben> I am using 0.8 by the way..
[20:13:21] <cmr> changes too much, answers get out of date withing weeks
[20:13:26] <cmr> oh, 0.8
[20:13:34] <cmr> you shouldn't do that, everything has changed on master
[20:14:11] <cmr> (for the better, of course)
[20:14:34] <kriben> cmr: obviously.. 
[20:15:28] <cmr> It's not always obvious ;)
[20:17:00] <kriben> cmr: True.. But you recommend that I start tracking master?
[20:18:25] *** Joins: beifeng (Mibbit@598FF6D.7A85645C.C7DB8B78.IP)
[20:18:53] *** Quits: Mowah (Mowah@moz-436C35C5.cust.bredbandsbolaget.se) (Ping timeout)
[20:19:25] <kriben> My problem is this: let lines = io::read_lines();
[20:19:29] <Hildar> So should I be using pub on all the traits my library needs to export, or should my 'pub use module::traitname' statement not cause a "trait is private" compile error?
[20:20:04] <kriben> which does not resolve: error: unresolved name `io::read_lines`.
[20:20:42] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Client exited)
[20:20:50] <dwrensha> kriben: looks like you need to "use std::io;"
[20:20:56] <cmr> kriben: definitely
[20:21:31] <kriben> But when I "use std::io":  use of undeclared type name `io::net::tcp::TcpStream`
[20:21:58] <cmr> Hildar: Nothing is pub by default except struct fields and enum variants (ie, the contents of datastructures)
[20:22:12] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[20:22:17] <cmr> kriben: is this still 0.8?
[20:22:20] <FreeFull> kriben: Note it doesn't start with std::
[20:22:44] <FreeFull> Ah, wait
[20:22:51] <FreeFull> nevermind
[20:22:51] <Hildar> cmr: Thanks. Looks like my info was out of date I  guess. Feels odd that I can use it from another crate without the pub though.
[20:23:07] <cmr> Hildar: if you can it's a bug. can you gist your code?
[20:25:20] <kriben> FreeFull: cmr: Still 0.8 (at my cabin with limited bandwidth: will have to wait until tomorrow to upgrade)..
[20:25:35] <cmr> kriben: in 0.8 it is std::rt::io::net
[20:26:19] <cmr> https://github.com/cmr/rust-examples/blob/master/echo_server.rs and echo_client.rs has 0.8 examples
[20:26:26] *** Joins: earlzlap (earlz@moz-483E1E31.neo.res.rr.com)
[20:27:06] *** Joins: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net)
[20:27:54] *** Joins: bytewise (bytewise@moz-4A801D04.unitymediagroup.de)
[20:29:47] <Hildar> cmr https://gist.github.com/xv8m4g3r/519d0b4c3038126815e4 (test.rs is a different crate to the rest of the files). I'll try and make a minimal example if you want.
[20:30:33] <cmr> hm!
[20:30:40] <cmr> acrichto: How is trait visibility supposed to work?
[20:31:10] *** Quits: AvianFlu (AvianFlu@moz-C1C884AB.nyc.res.rr.com) (Connection reset by peer)
[20:31:26] *** Joins: lenstr (lenstr@95535B34.9636F313.7A27613B.IP)
[20:31:36] *** Joins: AvianFlu (AvianFlu@moz-C1C884AB.nyc.res.rr.com)
[20:38:36] *** Quits: earlzlap (earlz@moz-483E1E31.neo.res.rr.com) (Ping timeout)
[20:38:36] *** Quits: lenstr (lenstr@95535B34.9636F313.7A27613B.IP) (Ping timeout)
[20:42:32] *** Joins: lenstr (lenstr@95535B34.9636F313.7A27613B.IP)
[20:46:11] *** Quits: AvianFlu (AvianFlu@moz-C1C884AB.nyc.res.rr.com) (Connection reset by peer)
[20:46:35] *** Joins: earlzlap (earlz@moz-483E1E31.neo.res.rr.com)
[20:47:19] <agrif> re: using traits as a replacement for managed closures (from strcat, but he's gone now I guess)
[20:47:27] <agrif> that's a heck of a lot more akward
[20:48:30] <cmr> agrif: but it's way more flexible and doesn't pollute the type system
[20:48:50] <SiegeLord> And yet C++ added closures eventually :P
[20:49:03] <agrif> C++ isn't the best reference for a good type system
[20:49:03] <cmr> SiegeLord: we still have closures.
[20:49:10] <cmr> managed closures were @fn
[20:49:16] <SiegeLord> Those are statck closures
[20:49:22] <SiegeLord> Not "true" closures
[20:49:25] <cmr> @fn ?
[20:49:30] <agrif> I just happen to think managed closures are pretty dang useful
[20:49:31] <SiegeLord> What we have now
[20:49:37] *** Quits: lenstr (lenstr@95535B34.9636F313.7A27613B.IP) (Ping timeout)
[20:49:37] <cmr> ok, sure.
[20:49:46] <SiegeLord> C++ has true closures
[20:50:23] *** Joins: lenstr (lenstr@95535B34.9636F313.7A27613B.IP)
[20:50:34] <agrif> though, I'd be able to make do with owned closures you can call many times
[20:51:07] <agrif> since I'm pretty much making parameterized function generators
[20:51:10] <cmr> post-1.0 the plan is to make closures sugar for trait objects, which might mean reintroduction of ~fn
[20:51:31] <agrif> then I'll look forward to that
[20:51:33] *** Joins: AvianFlu (AvianFlu@moz-C1C884AB.nyc.res.rr.com)
[20:51:54] <Amaranth> cmr: Like Java then?
[20:52:00] <cmr> Amaranth: not really
[20:52:22] <cmr> it would be something like a Fn<Args.., Ret> trait.
[20:52:46] <cmr> with HKT one can have unboxed closures and also our current closures with &Fn/~Fn
[20:52:50] <agrif> at the moment, writing parser combinators is kind of akward
[20:52:50] <hoverbear> cmr: I'm thinking I'll do Hamming code next.
[20:53:09] <Amaranth> We have variadic generics?
[20:53:25] <agrif> partly also because managed trait boxes aren't in yet either
[20:53:44] <cmr> Amaranth: it's planned.
[20:54:00] <cmr> eddyb is working on implementing.
[20:54:25] *** Quits: earlzlap (earlz@moz-483E1E31.neo.res.rr.com) (Ping timeout)
[20:54:27] <cmr> agrif: https://github.com/jesse99/rparse
[20:54:31] <Hildar> https://gist.github.com/xv8m4g3r/d7a21a6f0b568746bd3f I wrote a cleaner example of the trait visibility weirdness I was experiencing.
[20:54:32] <cmr> "aren't in"? @Trait exists.
[20:54:42] <cmr> agrif: also you know @ is being *removed*, not added, right?
[20:54:44] <agrif> but @ is going away
[20:54:47] <agrif> yeah
[20:54:56] <cmr> ok, just checking :)
[20:54:56] *** Quits: docbrown (docbrown@5CE9D448.F0B9EFB2.7F8758CE.IP) (Ping timeout)
[20:54:59] <agrif> and rparse uses managed closures :P
[20:55:04] <eddyb> cmr: I just realized that Fn<..Args, Ret> is possible. until now I've only thought of Fn<Ret, ..Args> :P
[20:55:12] <agrif> which drastically simplifies the amount of boilerplate
[20:55:40] <cmr> agrif: sorry, meant to give more context to that link: making sure you knew that it in the past existed.
[20:55:59] <agrif> yeah. I was sort of bummed I couldn't use it
[20:56:04] <agrif> not directly, at least
[20:56:19] <cmr> I tried updating it to 0.6
[20:56:25] <cmr> The language simply changed too much.
[20:56:29] <agrif> I basically decided that parser combinators are simple enough, and rust had changed enough, that I should just write my own
[20:56:53] *** Joins: jviereck (Adium@moz-8F6BA636.dip0.t-ipconnect.de)
[20:57:02] *** Joins: docbrown (docbrown@5CE9D448.F0B9EFB2.7F8758CE.IP)
[20:57:17] <agrif> they also make me pine for monad syntax sugar :P
[20:57:54] <cmr> I'm sure a macro could do it, though we can't have a Monad type yet.
[20:58:15] <agrif> it'd be a pretty intense macro
[20:58:29] <agrif> you can hack something up in python using yield
[20:58:41] <cmr> eholk wrote a lambda calculus interpreter using macro_rules! :)
[20:59:02] <agrif> I don't doubt it's possible, but I might doubt it'd look good
[20:59:55] <agrif> and the python yield thing fails anyway because generator objects aren't copyable, so you can't do things like continuations
[21:00:34] *** Quits: docbrown (docbrown@5CE9D448.F0B9EFB2.7F8758CE.IP) (Ping timeout)
[21:02:41] *** Joins: rca_ (rcatolino@D9432C32.20117C61.520D6FA6.IP)
[21:02:52] *** Joins: brson (brson@981AA104.E81F12CD.76F66111.IP)
[21:02:52] *** ChanServ sets mode: +ao brson brson
[21:03:05] *** Quits: Ms2ger (Ms2ger@moz-7C292AC.adsl-dyn.isp.belgacom.be) (Quit: nn)
[21:03:57] *** Quits: kriben (kristian@moz-A0399E63.tmi.telenormobil.no) (Quit: leaving)
[21:04:10] *** Quits: rca (rcatolino@moz-D9D6A93B.adsl.proxad.net) (Ping timeout)
[21:04:19] <geomyidae> how does one use different annotations for different platforms? aka, -lpcap vs -lwpcap for linux/windows.
[21:04:38] <cmr> geomyidae: #[cfg(windows)]
[21:04:42] *** Joins: sarclops (sarclops@moz-D1AB8760.bredband.tre.se)
[21:05:28] *** Joins: brson_ (brson@moz-BBE3ABD.mv.mozilla.com)
[21:05:43] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[21:06:05] *** Quits: brson (brson@981AA104.E81F12CD.76F66111.IP) (Ping timeout)
[21:06:31] *** Joins: canhtak (canhtak@moz-A53E1151.wl.t.ulaval.ca)
[21:09:11] *** Quits: jviereck (Adium@moz-8F6BA636.dip0.t-ipconnect.de) (Quit: Leaving.)
[21:09:27] *** Joins: mib_ba0m6f (Mibbit@moz-619C6B78.dsl.xmission.com)
[21:09:46] *** Joins: docbrown (docbrown@5CE9D448.F0B9EFB2.7F8758CE.IP)
[21:10:35] *** Parts: mib_ba0m6f (Mibbit@moz-619C6B78.dsl.xmission.com) ()
[21:12:01] *** Quits: lenstr (lenstr@95535B34.9636F313.7A27613B.IP) (Ping timeout)
[21:12:12] *** Joins: lenstr (lenstr@2BF5A23.9636F313.7A27613B.IP)
[21:13:21] *** Quits: AvianFlu (AvianFlu@moz-C1C884AB.nyc.res.rr.com) (Input/output error)
[21:16:03] *** Joins: jviereck (Adium@moz-8F6BA636.dip0.t-ipconnect.de)
[21:17:21] *** Joins: AvianFlu (AvianFlu@moz-C1C884AB.nyc.res.rr.com)
[21:20:07] *** Quits: lenstr (lenstr@2BF5A23.9636F313.7A27613B.IP) (Ping timeout)
[21:25:16] *** Quits: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[21:26:05] <achin> has info about proc() made it into the documentation yet?  if so, where?
[21:26:13] <cmr> no, I don't think so.
[21:26:37] <geomyidae> Its rather impossible to google for also :(
[21:26:49] <geomyidae> I even ctrl+fd the mailing list thread names
[21:27:09] <cmr> the only information is in niko's blog posts, really.
[21:28:41] *** Quits: jviereck (Adium@moz-8F6BA636.dip0.t-ipconnect.de) (Quit: Leaving.)
[21:28:53] *** Quits: jdm (jdm@moz-78156D60.dsl.teksavvy.com) (Quit: Lost terminal)
[21:31:02] *** Joins: jnicholls (uid19542@moz-A42E5B7B.irccloud.com)
[21:31:18] *** Quits: AvianFlu (AvianFlu@moz-C1C884AB.nyc.res.rr.com) (Connection reset by peer)
[21:32:40] *** Joins: skeet70 (skeet70@moz-2578911E.bzm-mt.client.bresnan.net)
[21:34:37] <achin> for the record: http://smallcultfollowing.com/babysteps/blog/2013/10/10/fn-types-in-rust/
[21:34:46] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[21:35:12] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[21:36:38] *** Joins: prooftechnique (prooftechn@moz-1C9C6B71.hsd1.vt.comcast.net)
[21:39:04] *** Quits: tcr (tcr@moz-6FEAEFBC.hfc.comcastbusiness.net) (Client exited)
[21:39:25] *** Joins: tcr (tcr@moz-6FEAEFBC.hfc.comcastbusiness.net)
[21:40:41] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[21:41:10] *** Quits: tcr (tcr@moz-6FEAEFBC.hfc.comcastbusiness.net) (Ping timeout)
[21:42:16] <jnicholls> great read @achin I missed this one
[21:44:00] *** Quits: smodo (ford_p@moz-6398EFDF.dclient.hispeed.ch) (Ping timeout)
[21:46:01] *** Joins: jlong (jlong@moz-6DFDE846.socal.res.rr.com)
[21:47:05] *** Joins: Jesin (Jesin@moz-63C897DA.res.lehigh.edu)
[21:47:09] *** Joins: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com)
[21:48:17] *** Joins: jviereck (Adium@moz-8F6BA636.dip0.t-ipconnect.de)
[21:50:07] *** Joins: AvianFlu (AvianFlu@moz-C1C884AB.nyc.res.rr.com)
[21:51:16] *** Quits: beifeng (Mibbit@598FF6D.7A85645C.C7DB8B78.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[21:52:33] *** Quits: jlong (jlong@moz-6DFDE846.socal.res.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[21:53:41] *** Joins: TimAbraldes (quassel@moz-7FD19BDC.hsd1.or.comcast.net)
[21:53:56] <SiegeLord> I'm being confused by mutability... why can I do this:
[21:54:00] <SiegeLord> rusti: fn test1<T: Iterator<int>, U: Iterator<int>>(t: T, u: U) { for _ in t.zip(u) {} }
[21:54:04] -rusti- ()
[21:54:06] <SiegeLord> But not this:
[21:54:10] <SiegeLord> rusti: fn test2<T: Iterator<int>, U: Iterator<int>>(t: T, u: U) { for _ in t {} }
[21:54:11] -rusti- <anon>:9:68: 9:83 error: cannot borrow immutable argument as mutable
[21:54:11] -rusti- <anon>:9          fn test2<T: Iterator<int>, U: Iterator<int>>(t: T, u: U) { for _ in t {} }
[21:54:12] -rusti-                                                                              ^~~~~~~~~~~~~~~
[21:54:12] -rusti- error: aborting due to previous error
[21:54:12] -rusti- application terminated with error code 101
[21:54:30] <Luqman> rusti: fn test2<T: Iterator<int>, U: Iterator<int>>(mut t: T, u: U) { for _ in t {} }
[21:54:31] -rusti- <anon>:9:64: 9:65 warning: unused variable: `u` [-W unused-variable (default)]
[21:54:32] -rusti- <anon>:9          fn test2<T: Iterator<int>, U: Iterator<int>>(mut t: T, u: U) { for _ in t {} }
[21:54:32] -rusti-                                                                          ^
[21:54:32] -rusti- ()
[21:55:01] <cmr> Hm
[21:55:37] <cmr> SiegeLord: because it expands to let mut it = expr; loop { match it.next() { Some(pat) => { ... }, None => break }
[21:55:50] <cmr> constructing the ziperator doesn't require mutability.
[21:55:50] <bascule> rusti: ()
[21:55:51] -rusti- ()
[21:55:54] <bascule> heh
[21:55:56] <cmr> although, I feel like that shouldn't work...
[21:55:59] <bascule> that's the "unit type"?
[21:56:00] *** Joins: Kruppe (user@moz-12CF8A25.dsl.teksavvy.com)
[21:56:09] * bascule tring to figure out wtf
[21:56:10] <cmr> bascule: value, of the unit type.
[21:56:16] <bascule> yeah, sure
[21:56:24] <bascule> rusti: (1)
[21:56:25] -rusti- 1
[21:56:26] <bascule> heh
[21:56:29] <cmr> rusti: (1,)
[21:56:30] -rusti- (1,)
[21:56:36] <bascule> lol python (and Reia) syntax
[21:56:40] *** Quits: Kruppe (user@moz-12CF8A25.dsl.teksavvy.com) (Client exited)
[21:56:47] <bascule> rusti: (1,2)
[21:56:48] -rusti- (1, 2)
[21:56:54] <bascule> I see...
[21:56:55] <cmr> can't unambiguously create a tuple and have parens for grouping exprs.
[21:56:58] <o11c> rusti: (1, 2,)
[21:56:59] -rusti- (1, 2)
[21:57:10] <bascule> it's such an ugly hack ;)
[21:57:14] <o11c> cmr: meh, I like the trailing comma always
[21:57:29] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Client exited)
[21:57:42] <SiegeLord> rusi: use std::iter::Repeat; fn test2<T: Iterator<int>, U: Iterator<int>>(t: T, u: U) { for _ in t.zip(Repeat::new(0)) {} }
[21:57:49] <SiegeLord> rusti: use std::iter::Repeat; fn test2<T: Iterator<int>, U: Iterator<int>>(t: T, u: U) { for _ in t.zip(Repeat::new(0)) {} }
[21:57:50] -rusti- <anon>:9:83: 9:84 warning: unused variable: `u` [-W unused-variable (default)]
[21:57:50] -rusti- <anon>:9          use std::iter::Repeat; fn test2<T: Iterator<int>, U: Iterator<int>>(t: T, u: U) { for _ in t.zip(Repeat::new(0)) {} }
[21:57:50] -rusti-                                                                                             ^
[21:57:50] -rusti- ()
[21:58:00] <SiegeLord> I feel like I'm breaking laws here
[21:58:08] <bascule> rusti: :foo
[21:58:09] -rusti- <anon>:9:9: 9:10 error: unexpected token: `:`
[21:58:09] -rusti- <anon>:9          :foo
[21:58:09] -rusti-                   ^
[21:58:09] <o11c> among other things, it makes diffs nicer if they're across multiple lines
[21:58:09] -rusti- application terminated with error code 101
[21:58:11] <bascule> lol
[21:58:30] <cmr> SiegeLord: so do I, I think it's a bug.
[21:59:31] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Ping timeout)
[21:59:38] <cmr> SiegeLord: oh, it's not a bug because .zip consumes self.
[22:00:16] <SiegeLord> rusti: fn test2<T: Iterator<int>, U: Iterator<int>>(t: T, u: U) { let mut t = t; for _ in t {} }
[22:00:17] -rusti- <anon>:9:60: 9:61 warning: unused variable: `u` [-W unused-variable (default)]
[22:00:17] -rusti- <anon>:9          fn test2<T: Iterator<int>, U: Iterator<int>>(t: T, u: U) { let mut t = t; for _ in t {} }
[22:00:17] -rusti-                                                                      ^
[22:00:17] -rusti- ()
[22:00:27] <SiegeLord> I guess I'll do that
[22:00:40] <jnicholls> seems odd to me
[22:00:42] <cmr> you can do (mut t: T)
[22:01:01] <jnicholls> yeah do what @Luqman did above
[22:01:06] <jnicholls> rusti: fn test2<T: Iterator<int>, U: Iterator<int>>(mut t: T, u: U) { for _ in t {} }
[22:01:07] -rusti- <anon>:9:64: 9:65 warning: unused variable: `u` [-W unused-variable (default)]
[22:01:07] -rusti- <anon>:9          fn test2<T: Iterator<int>, U: Iterator<int>>(mut t: T, u: U) { for _ in t {} }
[22:01:07] -rusti-                                                                          ^
[22:01:07] -rusti- ()
[22:01:19] <SiegeLord> Well, it's odd to make one mut and one not, despite both being actually mutated :P
[22:01:29] <jnicholls> seems like a bug
[22:01:34] <cmr> one uses `&mut self`, one uses `self`
[22:03:18] <SiegeLord> Can you concatenate two iterators together?
[22:03:24] <cmr> chain
[22:04:35] *** Quits: nsf (nsf@moz-EEF3238A.convex.ru) (Quit: WeeChat 0.4.2)
[22:04:37] <hoverbear> Iterators are so cool
[22:05:32] *** Quits: alonlevy (alon@moz-EB7C9CF3.telavivmakers.org) (Ping timeout)
[22:06:47] *** Quits: skeet70 (skeet70@moz-2578911E.bzm-mt.client.bresnan.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[22:06:56] *** Quits: rca_ (rcatolino@D9432C32.20117C61.520D6FA6.IP) (Ping timeout)
[22:09:22] *** Quits: alex-abreu (alex@moz-7421D6C9.mc.videotron.ca) (Client exited)
[22:09:32] <SiegeLord> rusti: use std::iter::range_step; range_step(0.0f32, 1.0f32, 4.0f32)
[22:09:32] -rusti- <anon>:9:36: 9:46 error: failed to find an implementation of trait std::num::CheckedAdd for f32
[22:09:33] -rusti- <anon>:9          use std::iter::range_step; range_step(0.0f32, 1.0f32, 4.0f32)
[22:09:33] -rusti-                                              ^~~~~~~~~~
[22:09:33] -rusti- application terminated with error code 101
[22:09:37] <SiegeLord> Hmm
[22:09:43] <SiegeLord> That's unfortunate
[22:11:17] *** Quits: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net) (Ping timeout)
[22:11:32] <FreeFull> I don't know if ranges necessarily make sense for floats
[22:11:51] <SiegeLord> Why wouldn't they?
[22:11:53] <cmr> with a step they do
[22:12:05] <cmr> CheckedAdd doesn't fully make sense, though.
[22:12:15] <cmr> do you stop when it loses too much precision, or when it overflows?
[22:14:11] *** Quits: mcarberry (mcarberry@moz-BE1C9F3F.lightspeed.frokca.sbcglobal.net) (Ping timeout)
[22:14:36] <dbaupp> I'd stop when it overflows and if a + b == a, fwiw.
[22:14:47] <dbaupp> (well, s/and/or/)
[22:15:17] <o11c> range with step will still only randomly include or exclude the end
[22:16:23] *** Joins: carter (carter@moz-F3C2A2D8.nycmny.fios.verizon.net)
[22:17:09] <FreeFull> It'd make a lot more sense for something like fixed point
[22:17:39] <o11c> yeah ...
[22:17:53] <o11c> when I make my language, I'll support rationals natively, but not floats
[22:18:06] <o11c> so 0.1 + 0.1 + 0.1 will really == 0.3
[22:19:30] <SiegeLord> Every math library/language has a way to make floating point ranges... you can't just say it doesn't make sense
[22:19:51] <dbaupp> o11c: so, you're supporting being slow natively too? :P
[22:20:03] *** Quits: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net) (Input/output error)
[22:20:34] *** Quits: jackneill (jackneill@moz-6C59E71E.pool.digikabel.hu) (Quit: WeeChat 0.4.1)
[22:20:55] <cmr> We have/had a rational type in extra
[22:20:58] <dbaupp> SiegeLord: accurate float ranges don't work with the current generic design of range, fwiw.
[22:21:54] <SiegeLord> I forget, is it impossible to specialize on specific types?
[22:22:07] <o11c> dbaupp: I do support using bigint/bigrational as the default int/rational, yes
[22:22:30] <cmr> SiegeLord: no, but it is not possible if you also have a generic implementation.
[22:22:36] <cmr> it's a limitation pcwalton wants to lift.
[22:22:41] * cmr high fives o11c
[22:22:43] <hoverbear> So, coreOS looks for a disk labelled STATE on boot? Can I have multiple STATEs?
[22:22:51] <hoverbear> Shoot, wrong channel.
[22:22:53] <cmr> hoverbear: definitely the wrong channel :p
[22:23:03] <cmr> TWiR tomorrow, if I forgot to mention it.
[22:23:12] <hoverbear> cmr: Exciting!
[22:23:17] <cmr> but I already made the PR cutoff.
[22:24:26] *** Quits: jviereck (Adium@moz-8F6BA636.dip0.t-ipconnect.de) (Quit: Leaving.)
[22:24:34] <hoverbear> Would anyone in the community be interested in a plug-and-play docker container for Rust Development?
[22:24:46] <cmr> hoverbear: deffers!
[22:24:48] <dbaupp> SiegeLord: "specialisation" is only possible via traits, so C++ style is impossible, yes.
[22:25:16] <SiegeLord> Oh well... I guess it'll be frange or something
[22:25:21] <hoverbear> cmr: Cool! With 0.7 docker out and them not needing AUFS kernels anymore it's much more accessible.
[22:26:51] *** Joins: jviereck (Adium@moz-8F6BA636.dip0.t-ipconnect.de)
[22:28:32] *** Joins: tcr (tcr@moz-6FEAEFBC.hfc.comcastbusiness.net)
[22:28:37] *** Joins: mcarberry (mcarberry@moz-BE1C9F3F.lightspeed.frokca.sbcglobal.net)
[22:28:39] <SiegeLord> What would be the shortest way to make an iterator with only one element?
[22:29:41] <dbaupp> Some(..)
[22:29:58] <dbaupp> well, Some(..).iter() or .move_iter()
[22:30:10] <dbaupp> hm, wait, there might only be the former now
[22:30:14] *** Joins: Meistarin (uid19523@moz-A42E5B7B.irccloud.com)
[22:30:15] <TeXitoi> rusti: let val = Some(1); for i in val.iter {print!("{} ", i);}
[22:30:17] -rusti- pastebinned 13 lines of output: http://sprunge.us/UFBj
[22:30:26] <TeXitoi> rusti: let val = Some(1); for i in val.iter() {print!("{} ", i);}
[22:30:27] -rusti- pastebinned 10 lines of output: http://sprunge.us/WLBB
[22:30:47] <TeXitoi> rusti: let val = Some(1); for i in val.iter() {print!("{} ", *i);}
[22:30:48] -rusti- 1 ()
[22:31:38] <SiegeLord> move_iter worked
[22:33:21] *** Quits: synackse (synackse__@7DAC4ACE.77F880E0.D9401097.IP) (Ping timeout)
[22:34:31] *** Quits: a__ (a__@moz-56DB9895.nycmny.fios.verizon.net) (Client exited)
[22:35:38] *** Joins: a__ (a__@moz-56DB9895.nycmny.fios.verizon.net)
[22:36:59] *** Joins: synackse (synackse__@7DAC4ACE.77F880E0.D9401097.IP)
[22:37:38] *** Quits: a__ (a__@moz-56DB9895.nycmny.fios.verizon.net) (Ping timeout)
[22:39:19] <agrif> hey, so, if I'm trying to bind a c library that exports a function pointer variable...
[22:39:45] <agrif> I put this in my extern block: static free_func: *fn (*mut Void);
[22:39:59] <o11c> shouldn't it be extern "C" 
[22:40:19] <agrif> http://static.rust-lang.org/doc/master/tutorial-ffi.html says just extern
[22:40:37] <SiegeLord> I think that might be better as static mut
[22:41:12] <agrif> ok sure, but the main problem is, when I call it with (*free_func)(...), it segfaults, and I have no idea why
[22:41:16] <SiegeLord> There's a bug, iirc, where rustc interprets all static's as compile time constants
[22:41:34] <agrif> the segfault doesn't go away when I use mut
[22:42:05] <SiegeLord> Well, is free_func NULL?
[22:42:06] <agrif> the library in question is pcre, and it says that free_func should be filled from the beginning
[22:42:11] <agrif> lemme double check
[22:42:17] <cmr> agrif: *fn is a closure.
[22:42:25] <cmr> you just want `extern fn`
[22:42:28] <cmr> it's already a function pointer.
[22:42:34] *** Joins: a__ (a__@moz-56DB9895.nycmny.fios.verizon.net)
[22:42:40] <agrif> that also segfaults
[22:42:46] <cmr> hm
[22:42:49] <agrif> also why would *fn be a closure?
[22:43:04] *** Quits: a__ (a__@moz-56DB9895.nycmny.fios.verizon.net) (Client exited)
[22:43:11] <agrif> so free_func is definitely not null
[22:43:30] <dbaupp> `fn` is equivalent to extern "Rust" fn on master
[22:43:44] <dbaupp> so the abi is incorrect
[22:44:00] <o11c> agrif: it's possible to have an extern "C" pointer to an extern "Rust" function
[22:44:10] <dbaupp> `static free_fn: extern "C" fn (*mut Void);` should work
[22:44:13] <o11c> and I'm guessing that's what you did
[22:44:15] <cmr> dbaupp: what are the rules for that? in a type, "Rust" is the default, but in a declaration, "C" is the default?
[22:44:18] *** Joins: a__ (a__@moz-56DB9895.nycmny.fios.verizon.net)
[22:44:23] <bjz> an incorrect ABI would give you a segfault
[22:44:29] <dbaupp> (or without the "C", but that can be inconsistent)
[22:44:45] <dbaupp> cmr: "that" = `fn`, or `extern fn`?
[22:44:56] <hoverbear> cmr: What's the best supported linux distro for Rust? I'll see if they have a container.
[22:44:57] <cmr> dbaupp: they're the same now aren't they?
[22:45:03] <cmr> hoverbear: arch has nightlies.
[22:45:05] *** Quits: sebcrozet (sebcrozet@moz-87D51607.w80-13.abo.wanadoo.fr) (Quit: Gone)
[22:45:06] <cmr> (rust nightlies)
[22:45:15] <cmr> ubuntu does too
[22:45:19] <dbaupp> cmr: no
[22:45:20] <hoverbear> Screw ubuntu
[22:45:28] <bjz> oi
[22:45:42] <dbaupp> cmr: well, extern fn lets you specify the ABI, while fn is always "Rust"
[22:45:45] <hoverbear> The arch builds are good though, I'll plan those.
[22:46:00] <agrif> dbaupp, it doesn't work, but it fails in a less serious way
[22:46:07] <agrif> now, at least, it's calling the glibc free
[22:46:11] <agrif> which it should be
[22:46:25] <agrif> but the arguments get mangled on the way there
[22:46:26] <cmr> dbaupp: right, but if the default is "Rust", I would imagine `extern fn` is still `extern "Rust" fn` aka `fn`
[22:46:44] <eddyb> cmr: no, extern fn is "C" by default
[22:46:49] <cmr> always?
[22:46:53] <eddyb> mhmm
[22:47:15] <cmr> rusti: fn foo() { }; let x: () = foo;
[22:47:16] -rusti- <anon>:9:35: 9:38 error: mismatched types: expected `()` but found `extern "Rust" fn()` (expected () but found extern fn)
[22:47:17] -rusti- <anon>:9          fn foo() { }; let x: () = foo;
[22:47:17] -rusti-                                             ^~~
[22:47:17] -rusti- error: aborting due to previous error
[22:47:17] -rusti- application terminated with error code 101
[22:47:20] <hoverbear> bjz: No offense to ubuntu users, I don't like the corporate backers
[22:47:24] <cmr> rusti: extern fn foo() { }; let x: () = foo;
[22:47:26] -rusti- <anon>:9:42: 9:45 error: mismatched types: expected `()` but found `extern "C" extern fn()` (expected () but found extern fn)
[22:47:26] -rusti- <anon>:9          extern fn foo() { }; let x: () = foo;
[22:47:26] -rusti-                                                    ^~~
[22:47:26] -rusti- error: aborting due to previous error
[22:47:26] -rusti- application terminated with error code 101
[22:47:31] <bjz> hoverbear: keep it civil is all
[22:47:34] <benh> would be nice if we had separate keywords for specifying API or whether the function is going to be left undefined
[22:47:39] <hoverbear> bjz: Sorry. ;)
[22:47:49] <cmr> rusti: fn foo(x: extern fn()) { }; foo(println);
[22:47:50] -rusti- <anon>:9:41: 9:48 error: mismatched types: expected `extern "Rust" fn()` but found `extern "Rust" fn(&str)` (incorrect number of function parameters)
[22:47:50] -rusti- <anon>:9          fn foo(x: extern fn()) { }; foo(println);
[22:47:50] -rusti-                                                   ^~~~~~~
[22:47:50] -rusti- error: aborting due to previous error
[22:47:50] -rusti- application terminated with error code 101
[22:47:55] <bjz> hoverbear: np
[22:47:59] <cmr> eddyb: dbaupp: hah!
[22:47:59] <o11c> I should check if the Ubuntu nightlies work on Debian
[22:48:08] <eddyb> cmr: o_O
[22:48:09] <cmr> It *is* extern "Rust" fn in types.
[22:48:12] <cmr> That's what I thought
[22:48:17] <cmr> (and tha'ts hwat I was asking about)
[22:48:23] <SiegeLord> There's plenty of Ubuntu derived stuff that's not Ubuntu, and where that PPA works
[22:48:45] <eddyb> cmr: that is... bad... can you confirm on master?
[22:48:48] <dbaupp> cmr: ah, right, that's what you're talking about :P
[22:48:49] <eddyb> maybe there's a bug tracking it
[22:49:01] <eddyb> s/bug/issue
[22:49:31] <agrif> uh
[22:49:31] <cmr> eddyb: I'm pretty sure it's intended.
[22:49:45] <cmr> and it's this way on master too.
[22:49:45] <agrif> so, FWIW, ptr != ptr.as_mut_void_ptr()
[22:49:49] <agrif> address-wise
[22:49:53] <agrif> is that usual?
[22:49:56] <cmr> agrif: ptr to what?
[22:50:04] <agrif> this libpcre object
[22:50:10] *** Quits: a__ (a__@moz-56DB9895.nycmny.fios.verizon.net) (Client exited)
[22:50:12] <cmr> what type do you specifically have.
[22:50:14] <agrif> *OpaqueType
[22:50:19] <agrif> which is a bare struct
[22:50:22] <cmr> hm
[22:50:27] <cmr> it *should* be...
[22:50:41] <eddyb> cmr: how is that intended?
[22:50:44] <hoverbear> So is there a need for things like mutexes and semaphores in rust? Or do language constructs mostly handle those?
[22:50:57] <bjz> hoverbear: we use message passing
[22:51:21] <agrif> so I don't actually need the extern "C" bit, because the real problem is my pointer's getting mutated for some reason
[22:51:23] <eddyb> cmr: is it a relic of pre-closure-reform fn types?
[22:51:34] <hoverbear> bjz: Half-duplex too, right?
[22:51:36] <bjz> hoverbear: we make it very difficult to modify mutable state across tasks, so they are not necessary afaik
[22:51:57] <hoverbear> Awesome, avoiding system calls is great.
[22:51:59] <bjz> hoverbear: I think there are some in extra::sync though
[22:51:59] <cmr> RWArc uses one.
[22:52:04] <cmr> yeah
[22:52:07] <cmr> they *do* exist.
[22:52:17] <cmr> but not what you should be using most of the time.
[22:52:40] <bjz> hoverbear: if possible, use ports/chans
[22:52:44] *** Quits: jviereck (Adium@moz-8F6BA636.dip0.t-ipconnect.de) (Quit: Leaving.)
[22:53:02] *** Joins: a__ (a__@moz-56DB9895.nycmny.fios.verizon.net)
[22:53:04] <hoverbear> Definitely. Just like in Javascript yeah?
[22:53:11] <agrif> so what type should I be using to represent C opaque pointers, if not a bare struct?
[22:53:25] <eddyb> enum Void {}
[22:53:27] <cmr> hoverbear: similar to webworker yes.
[22:53:27] <eddyb> and *Void
[22:53:37] <cmr> agrif: std::libc::c_void also exists.
[22:53:50] <agrif> I'll try that
[22:53:51] <eddyb> that enum is not represented as a (), AFAIK
[22:53:55] <dbaupp> or just *()
[22:54:04] <dbaupp> if you're feeling lazy
[22:54:10] <eddyb> dbaupp: the point is to not use a pointer to an zero-sized type
[22:54:10] <agrif> it's still curious to me that as_void_ptr() would actually change the pointer
[22:54:10] <cmr> eddyb: it is, they're both 0-sized.
[22:54:15] <eddyb> cmr: o_O
[22:54:15] <cmr> agrif: it shouldn't, yes.
[22:54:20] <bjz> hoverbear: closer to CML or Erlang
[22:54:27] <dbaupp> (fwiw, there's std::util::Void which does what eddyb says)
[22:54:34] <eddyb> cmr: ok, so why enums are preferred over unit structs?
[22:54:42] <agrif> I used it in my function type for free
[22:54:53] <cmr> eddyb: since then are they?
[22:54:55] <hoverbear> bjz: I haven't tried those. :)
[22:55:02] <agrif> I was just hoping to maybe use seperate types for the opaque structures
[22:55:03] <cmr> I've never seen it before you just said it.
[22:55:17] <dbaupp> rusti: std::sys::size_of::<std::util::Void>()
[22:55:17] -rusti- 0u
[22:55:24] <benh> Void is uninhabited
[22:55:25] <cmr> agrif: you certainly should be able to.
[22:55:34] <benh> I guess that's intellectually more pleasing?
[22:55:37] <bjz> agrif: empty enums are non-constructable
[22:55:47] <eddyb> aaaah, that's the reason
[22:55:51] <bjz> via safe means
[22:55:56] <agrif> using type OpaqueStruct = Void; also makes the pointer change
[22:56:14] <cmr> agrif: can you gist your code, though preferably a minimal testcase?
[22:56:26] <benh> rusti: (std::sys::size_of::<()>(), std::sys::size_of::<[(), ..5]>())
[22:56:27] -rusti- (0u, 0u)
[22:56:31] <agrif> yeah, one second
[22:57:23] <bjz> rusti: enum A {} struct B; (std::sys::size_of::<A>(), std::sys::size_of::<B>())
[22:57:24] -rusti- (0u, 0u)
[22:58:01] <TeXitoi> bjz: A is the same as Void
[22:58:10] <bjz> yes, I know
[22:58:20] <eddyb> but a different type
[22:58:26] <benh> rusti: struct B; std::sys::size_of::<B>()
[22:58:26] <bjz> yes ^
[22:58:26] -rusti- 0u
[22:58:32] <benh> rusti: struct B; [std::sys::size_of::<B>(), .. 5]
[22:58:33] -rusti- [0u, 0u, 0u, 0u, 0u]
[22:58:34] <benh> huh
[22:58:36] <benh> durr
[22:58:40] <benh> im good at rust.
[22:58:48] <cmr> heh
[22:58:56] <o11c> Ubuntu nightly works on Debian too
[22:58:57] <cmr> I think strcat fixed pretty printing for 0 sized types.
[22:59:01] *** Quits: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com) (Quit: csherratt)
[22:59:15] <benh> I just wondered if the instantiable struct B also has zero size in an array
[22:59:36] <o11c> hoverbear: ^
[22:59:58] <cmr> rusti: struct B; [B, ..5]
[22:59:58] <o11c> I know the only way to have a struct of size 0 in C++ is by using an array ...
[22:59:59] -rusti- [main::B, main::B, main::B, main::B, main::B]
[23:00:09] *** Joins: semisight (alex@moz-16944F18.socal.res.rr.com)
[23:00:33] <cmr> rusti: struct B; let bs = [B, ..5]; b[3]
[23:00:34] -rusti- <anon>:9:38: 9:39 error: unresolved name `b`. Did you mean `bs`?
[23:00:34] -rusti- <anon>:9          struct B; let bs = [B, ..5]; b[3]
[23:00:34] -rusti-                                                ^
[23:00:34] -rusti- error: aborting due to previous error
[23:00:34] -rusti- application terminated with error code 101
[23:00:38] <cmr> rusti: struct B; let bs = [B, ..5]; bs[3]
[23:00:38] -rusti- main::B
[23:01:10] <agrif> cmr: https://gist.github.com/7850921
[23:01:11] <eddyb> rusti: struct B; std::sys::size_of::<[B, 1000000000000000]>()
[23:01:12] -rusti- <anon>:9:41: 9:42 error: expected `]` but found `,`
[23:01:12] -rusti- <anon>:9          struct B; std::sys::size_of::<[B, 1000000000000000]>()
[23:01:12] -rusti-                                                   ^
[23:01:12] -rusti- application terminated with error code 101
[23:01:20] <eddyb> rusti: struct B; std::sys::size_of::<[B, ..1000000000000000]>()
[23:01:21] -rusti- 0u
[23:01:27] <agrif> this one with null pointers, since I had no others handy for a minimal example
[23:01:38] <eddyb> more elements than bits of RAM!
[23:01:44] <eddyb> so sparse
[23:01:55] <agrif> but, uh, ptr::null().as_void_ptr() should probably also be null
[23:01:57] * eddyb should go to sleep
[23:02:37] <eddyb> rusti: std::sys::size_of::<Option<&uint>>()
[23:02:38] -rusti- 8u
[23:02:38] <cmr> Hrm.
[23:02:43] <cmr> as_void_ptr is just self as *T as *Void
[23:02:54] <benh> rusti: struct S; for s in [S, ..5] { print!("{:?} ", s); }
[23:02:55] -rusti- <anon>:9:19: 10:5 error: type `&mut [main::S, .. 5]` does not implement any method in scope named `next`
[23:02:55] -rusti- <anon>:9          struct S; for s in [S, ..5] { print!("{:?} ", s); }
[23:02:55] -rusti- <anon>:10     };
[23:02:55] -rusti- error: aborting due to previous error
[23:02:55] -rusti- application terminated with error code 101
[23:03:02] <benh> rusti: struct S; for s in [S, ..5].iter() { print!("{:?} ", s); }
[23:03:03] -rusti- pastebinned 11 lines of output: http://sprunge.us/PSVd
[23:03:06] <benh> aw
[23:03:15] <cmr> stash it in a local
[23:03:38] <benh> I would but I feel bad correcting my rusti code in the channel more than once
[23:04:03] <eddyb> can't we have some sort of lifetime lengthening?
[23:04:15] <benh> Yeah but it's not obvious what the right lifetime is
[23:04:21] <benh> sometimes you expect prompt cleanup idk
[23:04:22] <cmr> eddyb: nmatsakis has wrote and thought about this at length.
[23:04:30] <eddyb> :/
[23:04:50] <benh> cmr: you could shut down most discussion with that line!
[23:05:12] <eddyb> benh: it should work better for types without Drop
[23:05:30] <eddyb> I mean, all you have to do is pick the shortest lifetime that makes the code valid
[23:05:40] *** Quits: tcr (tcr@moz-6FEAEFBC.hfc.comcastbusiness.net) (Client exited)
[23:05:46] * eddyb is being naive. second strike. bed calls
[23:06:00] *** Joins: tcr (tcr@moz-6FEAEFBC.hfc.comcastbusiness.net)
[23:06:01] <cmr> benh: I just mean that it's not as simple as it seems.
[23:06:16] <benh> yeah you're right of course
[23:06:37] <agrif> cmr, should I open a bug for this?
[23:06:49] <agrif> bug #3 in 2 days
[23:07:01] <benh> It's okay, there's not a quota :)
[23:07:08] <agrif> hehe
[23:07:18] <agrif> I just wanna work on my program! that's all!
[23:07:41] *** Quits: tcr (tcr@moz-6FEAEFBC.hfc.comcastbusiness.net) (Ping timeout)
[23:07:47] <cmr> agrif: please do
[23:07:53] *** Quits: TimAbraldes (quassel@moz-7FD19BDC.hsd1.or.comcast.net) (Connection reset by peer)
[23:08:15] *** Joins: TimAbraldes (quassel@moz-7FD19BDC.hsd1.or.comcast.net)
[23:08:16] <cmr> cc @kimundi @thestinger @alexcrichton :)
[23:08:19] *** Quits: TimAbraldes (quassel@moz-7FD19BDC.hsd1.or.comcast.net) (Input/output error)
[23:08:23] *** Quits: refold (gman@moz-42D68426.a258.priv.bahnhof.se) (Quit: leaving)
[23:08:30] <benh> Where does as_void_ptr live?
[23:08:34] *** Joins: TimAbraldes (quassel@moz-7FD19BDC.hsd1.or.comcast.net)
[23:08:42] <cmr> benh: any.rs
[23:08:49] <benh> huh
[23:09:18] <eddyb> Any Who?
[23:09:18] <benh> Isn't that returning the pointer to the pointer?
[23:09:22] <benh> Not casting?
[23:10:24] <cmr> Ohhhh
[23:10:29] <cmr> agrif: benh is right!
[23:10:37] <agrif> derp
[23:10:39] <agrif> ok
[23:10:50] <agrif> that should probably be documented more ;P
[23:11:00] <cmr> Well... it *does* say "get a pointer to `self`"
[23:11:09] <bascule> I am just a pointer to a pointer to a pointer
[23:11:22] *** Quits: eddyb (eddy@moz-68E0B7D0.residential.rdsnet.ro) (Ping timeout)
[23:11:29] <cmr> And `self` here is *Foo
[23:11:31] <agrif> ok. this makes a lot more sense now, thanks
[23:11:40] * bascule returns to trying to trying to do elementary shit in Rust :|
[23:11:49] <bascule> if I build master, can I get a working REPL?
[23:11:52] <bascule> that'd help immensely
[23:11:55] * agrif stops trying to file issues
[23:12:07] <benh> No, we do not have a REPL
[23:12:28] <bascule> :|
[23:12:48] <bascule> guess I'll just keep using rusti then, lol
[23:12:55] <bascule> rusti: range('a','z')
[23:12:57] -rusti- <anon>:9:9: 9:14 error: failed to find an implementation of trait std::ops::Add<char,char> for char
[23:12:57] -rusti- <anon>:9          range('a','z')
[23:12:57] -rusti-                   ^~~~~
[23:12:57] -rusti- application terminated with error code 101
[23:13:01] <bascule> heh
[23:13:05] <benh> I think as_void_ptr is a bad name, it should be addr_as_void_ptr or something :(
[23:13:05] <semisight> hey I'm having a problem with bindgen
[23:13:09] <semisight> it builds
[23:13:10] *** Joins: Meistarin_ (Meistarin@4B25E5E0.5C6367D2.9F770D5C.IP)
[23:13:15] <dbaupp> bascule: http://sprunge.us/ahKj works as a "local" "rusti"
[23:13:21] <semisight> then when running gives me "dyld: Library not loaded: @executable_path/../lib/libLLVM-3.3.dylib"
[23:13:28] <bascule> dbaupp: cool, thanks
[23:13:29] <semisight> anyone have any experience with this?
[23:13:39] *** Quits: Meistarin_ (Meistarin@4B25E5E0.5C6367D2.9F770D5C.IP) (Client exited)
[23:13:59] <hoverbear> o11c: That's good to know!
[23:14:18] <dbaupp> semisight: you may not have the right version of libclang?
[23:14:32] <semisight> dbaupp: 3.3 should work as from readme
[23:14:34] <cmr> bascule: you can query rusti too
[23:15:10] <cmr> semisight: you do not have 3.3 though, not anywhere the linker is finding.
[23:15:15] <agrif> in hindsight this should have been obvious when my *mut Type variable needed to be mutable itself to use as_mut_void_ptr
[23:15:15] *** Joins: tcr (tcr@moz-6FEAEFBC.hfc.comcastbusiness.net)
[23:16:08] <semisight> cmr: huh, when building I linked against a recent llvm build
[23:18:30] <semisight> cmr: nvm, got it
[23:18:32] <semisight> thanks for the help
[23:19:44] *** Joins: nsf (nsf@moz-EEF3238A.convex.ru)
[23:19:52] *** Quits: jstevans (Instantbir@8DA2B352.17A0D1EC.B7830B68.IP) (Ping timeout)
[23:21:35] <ssbr> grrrrr
[23:21:59] <ssbr> duplication of work is so sucky
[23:24:13] *** Quits: tcr (tcr@moz-6FEAEFBC.hfc.comcastbusiness.net) (Client exited)
[23:24:44] *** Joins: tcr (tcr@moz-6FEAEFBC.hfc.comcastbusiness.net)
[23:26:29] *** Quits: tcr (tcr@moz-6FEAEFBC.hfc.comcastbusiness.net) (Ping timeout)
[23:27:07] *** Joins: alan_andrade (alan_andra@moz-F038A26E.hfc.comcastbusiness.net)
[23:27:27] *** Joins: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net)
[23:27:37] <alan_andrade> hi
[23:28:27] <alan_andrade> I want to write hostname for this repo: https://github.com/uutils/coreutils
[23:29:01] <alan_andrade> I downloaded the unix hostname sourcecode, but I need some pointers.
[23:29:08] *** Joins: hjr3 (hradtke@moz-842BF853.hsd1.ca.comcast.net)
[23:29:10] <Earnestly> See systemd's hostnamectl
[23:29:30] <Earnestly> (which sort of replaces the old hostname, as an example)
[23:31:05] <alan_andrade> hmm, is that under rust's repo ?
[23:33:07] *** Joins: jstevans (Instantbir@moz-4AAFD56B.bootp.virginia.edu)
[23:33:43] <alan_andrade> I can't find it
[23:34:05] <cmr> uh, no?
[23:34:09] <cmr> why would it be
[23:34:51] <alan_andrade> I don't know. I'm asking because I have no idea what 'systemd's hostnamctl' really means :\
[23:35:10] <cmr> systemd is a program, which comes with a collection of utilities, one of which is hostnamectl.
[23:35:34] <alan_andrade> ohh ok.
[23:35:34] <dbaupp> alan_andrade: https://github.com/systemd/systemd/blob/master/src/hostname/hostnamectl.c
[23:35:48] <cmr> dang, beat me to it :p
[23:36:12] <alan_andrade> bam! got it!
[23:36:29] <alan_andrade> thanks :D
[23:36:35] *** Quits: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net) (Ping timeout)
[23:39:16] <cmr> alan_andrade: important to note, though, that the old hostname uses uname, hostnamectl communiates over dbus...
[23:39:46] *** Joins: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au)
[23:40:06] <alan_andrade> those are the pointer I need. I really want to exercise my rustacean ability by writing this utils
[23:40:19] <alan_andrade> but I have almost no idea how they work
[23:40:27] <cmr> it's not going to be easy, but not because of Rust, because it's interacting with the OS :)
[23:40:42] <alan_andrade> Right
[23:41:00] <alan_andrade> I enjoy hard challenges
[23:45:32] *** Quits: doomlord_ (servitor@moz-D40D68D6.range86-184.btcentralplus.com) (Ping timeout)
[23:46:46] *** Quits: pcdummy (pcdummy@moz-CF4CA865.page4me.ch) (Ping timeout)
[23:47:29] *** Joins: pcdummy (pcdummy@moz-CF4CA865.page4me.ch)
[23:49:49] *** Joins: doomlord_ (servitor@moz-D40D68D6.range86-184.btcentralplus.com)
[23:50:31] *** jorendorff_away is now known as jorendorff
[23:51:19] *** Quits: Ferreus (ferreus@moz-53AC130.pools.arcor-ip.net) (Ping timeout)
[23:52:17] *** Quits: donri (donri@moz-9BB61102.tbcn.telia.com) (Client exited)
[23:55:46] *** Quits: TisButMe (Mibbit@moz-40463609.w80-9.abo.wanadoo.fr) (Quit: http://www.mibbit.com ajax IRC Client)
[23:56:32] *** Quits: aph (ash@15DEC023.DFC68827.9C33A531.IP) (Ping timeout)
[23:57:13] *** Quits: bytewise (bytewise@moz-4A801D04.unitymediagroup.de) (Ping timeout)
[23:58:14] *** Joins: ash_ (ash@15DEC023.DFC68827.9C33A531.IP)
[23:59:14] *** jorendorff is now known as jorendorff_away

[00:00:36] *** Quits: Skif (emschwar@moz-4C5BB5A8.beyondbb.com) (Client exited)
[00:00:38] <jmgrosen> and what does FnCtxt::write_ty do?
[00:00:45] <jmgrosen> the code in it isn't very self-explanatory
[00:00:52] *** Quits: hdevalence (quassel@moz-D125A39F.home3.cgocable.net) (Client exited)
[00:00:57] <LinearInterpol> So!
[00:01:05] <LinearInterpol> I'm back on the fun track on rust.
[00:01:07] *** Joins: Skif (emschwar@moz-4C5BB5A8.beyondbb.com)
[00:01:34] *** Quits: tjc (tjc@moz-6EB4E533.dsl.tsoft.com) (Quit: Textual IRC Client: www.textualapp.com)
[00:01:48] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[00:01:52] *** Joins: samx (sami@moz-77A1C177.pp.htv.fi)
[00:02:09] *** Quits: Mordecai (psquid@moz-9DE65B9D.threembb.co.uk) (Ping timeout)
[00:02:11] <LinearInterpol> Why do I get an "Empty not covered" error when I specified an explicit case? http://pastebin.com/epjWLU3f
[00:02:23] *** Joins: lucian (lucian@moz-8408FDFA.cable.virginm.net)
[00:02:43] <LinearInterpol> Says "empty" not covered..
[00:02:44] <dbaupp> LinearInterpol: the ~Node(_, ~Empty) case isn't covered
[00:02:49] <mcpherrin> LinearInterpol: You don't cover ~Node(_, ~Empty)
[00:02:51] *** Quits: Skif (emschwar@moz-4C5BB5A8.beyondbb.com) (Ping timeout)
[00:02:52] <LinearInterpol> Oh. That's required?
[00:03:02] *** Quits: bheylin_ (brianheyli@moz-8255E94E.adsl.online.nl) (Quit: bheylin_)
[00:03:07] <mcpherrin> Well neither of your cases cover it
[00:03:10] <mcpherrin> and it has to be exhaustive
[00:03:14] <mcpherrin> so yes :)
[00:03:29] <LinearInterpol> Huh, wild. How does it know that I have to cover ~Node(_, ~Empty)?
[00:03:31] <vmx> is the something like "unborrowing" a pointer? something like: let a = &b as &Any; ... /* i don't need a anymore, hence i unborrow it */ ... /* do something with b */
[00:04:11] <dbaupp> vmx: `{ let a = &b; ... } /* use b again */`
[00:04:40] <aatch> LinearInterpol, exhaustiveness checking.
[00:04:43] <vmx> dbaupp: that's smart, obvious once you know it and really nice
[00:04:57] *** Joins: tjc (tjc@moz-6EB4E533.dsl.tsoft.com)
[00:04:57] *** ChanServ sets mode: +o tjc
[00:05:01] *** Quits: tjc (tjc@moz-6EB4E533.dsl.tsoft.com) (Quit: tjc)
[00:05:13] *** Joins: espindol_ (espindola@8EC99D26.4B7A7726.A2E931B1.IP)
[00:05:26] <LinearInterpol> Weird.. why is that considered exauhstive? Shouldn't ~Node(_, ~Node(_, ~Empty)) be a part of the case as well?
[00:05:50] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[00:05:53] <mcpherrin> LinearInterpol: No, that's covered by your first case
[00:05:53] *** Parts: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) ()
[00:06:02] <LinearInterpol> It is?
[00:06:13] <aatch> Yes, you ignore the second parameter and bind the first.
[00:06:14] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[00:06:17] *** Quits: espindola (espindola@563D60BB.4B7A7726.A2E931B1.IP) (Ping timeout)
[00:06:27] <LinearInterpol> But how is that valid for ~Empty?
[00:06:38] <LinearInterpol> (Sorry, I'm an extreme noob. Just trying to get ahold of pattern matching.)
[00:06:58] <mcpherrin>  ~Node(_, ~Node(_, _))  is equivalent to ~Node(_, ~Node(_, _)) (replaced x with _ and ~Empty with _)
[00:07:08] *** Quits: canhtak (canhtak@moz-4B5B3414.wl.t.ulaval.ca) (Quit: canhtak)
[00:07:36] *** Joins: canhtak (canhtak@moz-4B5B3414.wl.t.ulaval.ca)
[00:07:38] <LinearInterpol> Wait... whut?
[00:07:51] <mcpherrin> _ ignores the value
[00:07:55] <aatch> LinearInterpol, ok, in your match, the first one matches the Node variant, ignores the first parameter and then matches the second variant against another Node variant
[00:07:57] *** Quits: samx (sami@moz-77A1C177.pp.htv.fi) (Quit: This computer has gone to sleep)
[00:08:09] <LinearInterpol> Alright..
[00:08:32] <LinearInterpol> So effectively.
[00:08:55] <LinearInterpol> ~Node(_, ~Node(_, _)) == ~Node(_, ~Empty)) ?
[00:09:00] <mcpherrin> No.
[00:09:02] <aatch> LinearInterpol, no
[00:09:02] *** Quits: Matthias247 (Miranda@moz-BDD35EC0.hsi5.kabel-badenwuerttemberg.de) (Connection reset by peer)
[00:09:04] *** Joins: bmats (bmats@moz-87F0A991.hfc.comcastbusiness.net)
[00:09:06] <LinearInterpol> Sorry.
[00:09:09] <aatch> Because Node and Empty are different variants
[00:09:13] <LinearInterpol> Alright.
[00:09:16] <mcpherrin> ~Node(_, _) and ~Empty are different
[00:09:23] <mcpherrin> but _ can match an ~Empty or a ~Node
[00:09:33] <LinearInterpol> Alright.. sorry, I should say that you're explaining this to a rather raw C programmer. :)
[00:09:45] <LinearInterpol> So, it takes me a bit to get a handle on it. Thanks in advance. :)
[00:09:49] <aatch> LinearInterpol, do you know about tagged unions?
[00:09:56] <LinearInterpol> I haven't used the pattern much.
[00:10:06] <LinearInterpol> So I know very little about them.
[00:10:07] <aatch> LinearInterpol, you know the general idea though, right?
[00:10:18] <LinearInterpol> I think I do.
[00:10:37] * LinearInterpol isn't up to snuff on his terminology..
[00:10:40] *** Quits: dherman (dherman@moz-BBE3ABD.mv.mozilla.com) (Quit: dherman)
[00:10:42] <aatch> Well you can thing of Rust's enums as being language-level tagged unions.
[00:11:17] <mcpherrin> so in C, I'd have struct{ enum type tag; union { struct empty {}, struct Node { int data; } } };
[00:11:45] <aatch> So the pattern match matches against the "tag", then does stuff with the contents.
[00:12:03] <LinearInterpol> Okay, now you have me.
[00:12:07] <aatch> that "stuff" can be more pattern matching.
[00:12:16] <aatch> or it can be binding to a variable.
[00:12:24] <LinearInterpol> Alright.
[00:12:27] <aatch> Rust uses '_' as a special "ignore me" variable.
[00:12:30] <LinearInterpol> Right.
[00:12:33] <LinearInterpol> I knew that.
[00:12:54] <LinearInterpol> And the match has to look like the original expression that constructed the type.
[00:13:02] <aatch> LinearInterpol, more-or-less yes.
[00:13:23] *** Quits: echristo (echristo@E55635C9.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[00:13:27] <LinearInterpol> So effectively.. alright.
[00:13:36] <LinearInterpol> So with those three cases.
[00:13:45] <LinearInterpol> I've covered Node where the second parameter is another node.
[00:14:00] <LinearInterpol> I've covered Node where the second parameter is Empty.
[00:14:01] *** Quits: gwty (gwtypc@77D2A3.3F98A9B1.CF29F6CE.IP) (Ping timeout)
[00:14:04] <LinearInterpol> And I've covered empty.
[00:14:07] <LinearInterpol> That makes more sense.
[00:14:08] <dwrensha> new post! http://dwrensha.github.io/capnproto-rust/2014/01/15/benchmark-update.html
[00:14:11] <kimundi> LinearInterpol: yup
[00:14:20] *** Joins: gwty (gwtypc@77D2A3.3F98A9B1.CF29F6CE.IP)
[00:14:20] <LinearInterpol> Just tryin' to wrap my head around this, thanks guys. :)
[00:14:23] <dbaupp> dwrensha: cool!
[00:14:29] <aatch> LinearInterpol, no problem.
[00:14:35] <hansjorg> I've deployed a new version of rust-ci.org now. Anyone want to give it a spin before I send an email?
[00:14:37] <LinearInterpol> dwrensha: suh-weeeeet. :D
[00:14:39] *** sam113101_afk is now known as sam113101
[00:14:41] <dbaupp> dwrensha: you could try just transmuting bytes to strings to see if that helps?
[00:14:41] *** Joins: espindola (espindola@563D60BB.4B7A7726.A2E931B1.IP)
[00:14:55] <dwrensha> oh sure, it's be easy to bypass the check
[00:14:59] <dwrensha> *it'd
[00:15:13] <LinearInterpol> I absolutely love that Rust is beating C++.
[00:15:16] <aatch> LinearInterpol, for further reference, you can pattern match against pretty much anything.
[00:15:32] <dwrensha> LinearInterpol: it's not
[00:15:33] <LinearInterpol> What can't I pattern match against?
[00:15:33] *** Quits: Jemaclus (Mibbit@4EEAB704.5843BA5A.D4E4C7A5.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[00:15:35] <hansjorg> Possible to upload built documentation now. Also a new projects by category view: http://www.rust-ci.org/projects/
[00:15:36] *** Quits: espindol_ (espindola@8EC99D26.4B7A7726.A2E931B1.IP) (Ping timeout)
[00:15:38] <LinearInterpol> oh, sorry.
[00:15:42] * LinearInterpol looked at it again.
[00:15:42] <dwrensha> are my plots misleading?
[00:15:47] <dbaupp> hansjorg: categories!
[00:16:07] <aatch> LinearInterpol, not sure, I just don't like being absolute, every time I am somebody corrects me :/
[00:16:14] *** Joins: AvianFlu (AvianFlu@moz-51534E77.c3-0.43d-ubr2.qens-43d.ny.cable.rcn.com)
[00:16:24] <LinearInterpol> Ah.
[00:16:28] <LinearInterpol> I can't correct you. :P
[00:16:29] <mcpherrin> http://pastebin.com/Pqr1qjFP
[00:16:34] *** Joins: cptroot (Mibbit@moz-4F146589.caltech.edu)
[00:16:39] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[00:16:39] <mcpherrin> LinearInterpol: ^
[00:16:47] <mcpherrin> Though it seems you've figured it out already :)
[00:16:56] <LinearInterpol> Hehe, I really appreciate that though. :)
[00:17:06] <cptroot> Quick question. What do people here use to write rust code?
[00:17:12] <LinearInterpol> The more C-like stuff I see related to rust, the easier it is.
[00:17:23] <mcpherrin> cptroot: Emacs and Vim seem most popular. People use other stuff too.
[00:17:27] <LinearInterpol> cptroot: I use Notepad++ with a Rust language pack.
[00:17:32] <LinearInterpol> It's godlike.
[00:17:38] <kimundi> LinearInterpol: One example where pattern matching is not allowed is with raw pointers
[00:17:42] <cptroot> K, thanks
[00:17:44] <LinearInterpol> Raw pointers?
[00:17:46] *** Quits: cptroot (Mibbit@moz-4F146589.caltech.edu) (Quit: http://www.mibbit.com ajax IRC Client)
[00:17:46] <dbaupp> hansjorg: how does the doc upload work?  just uploads ./doc directly?
[00:17:58] <LinearInterpol> kimundi: teach me, oh great one.
[00:17:59] * LinearInterpol bows.
[00:18:04] <mcpherrin> hansjorg: awesome :-)
[00:18:05] <hansjorg> dbaupp: uploads doc and looks for doc/*/index.html for creating links
[00:18:13] <kimundi> LinearInterpol: *T, basically just like Cs pointers - no safety guarantees, and hence unsafe to dereference
[00:18:18] <dbaupp> hansjorg: ok, I'll try
[00:18:19] <LinearInterpol> Ahhhh.
[00:18:23] <aatch> LinearInterpol, anyway, `let` actually is a pattern binding: `let (a,b) = my_tuple;` will bind the two things in a 2-tuple to `a` and `b`.
[00:18:24] <LinearInterpol> Alrighty.
[00:18:32] *** Quits: Scriptor (anonymous@moz-E06F46F0.corp.bitshelter.com) (Quit: Scriptor)
[00:18:42] <LinearInterpol> aatch: Yeah, I did that at first when I dealt with a tuple struct.
[00:18:50] <LinearInterpol> Was useful, felt like Python. :)
[00:18:53] <aatch> But only works for patterns that are known at compile time.
[00:19:07] <LinearInterpol> What patterns can't be known at compile time?
[00:19:14] <LinearInterpol> Vectors and stuff?
[00:19:14] <aatch> So you can't do something like `let Some(v) = foo` (which I occasionally write)
[00:19:24] <aatch> LinearInterpol, enum variants. Like ^^
[00:19:34] <LinearInterpol> Oh damn.. but, wait.
[00:19:35] <kimundi> rusti: let (a, b) = (1, 2); a + b
[00:19:36] -rusti- 3
[00:19:57] <LinearInterpol> Why isn't that known at compile time?
[00:19:57] <mcpherrin> let Some(v) = foo; doesn't work because what if foo is None?
[00:20:04] <aatch> Because `foo` might not be that variant.
[00:20:25] <mcpherrin> so gotta match it out
[00:20:27] <LinearInterpol> Oh. Wait.. how will that work?
[00:20:39] <LinearInterpol> That means I can do shit like..
[00:20:44] <LinearInterpol> let Some(v) = 300; ?
[00:20:49] <aatch> LinearInterpol, it doesn't, it's a compile time error.
[00:20:53] <aatch> That's my point.
[00:20:56] <LinearInterpol> Oh.
[00:20:58] <LinearInterpol> Sorry. ehe.
[00:21:09] <bstrie> LinearInterpol: I explained all this this morning!
[00:21:17] <bstrie> weren't you even LISTENING to my lecture on irrefutable patterns?!??
[00:21:22] <LinearInterpol> No. :(
[00:21:27] * LinearInterpol hides his head.
[00:21:36] <aatch> bstrie, I was just about to mention refutable vs irrefutable.
[00:21:40] <aatch> :D
[00:21:48] * mcpherrin wants refutable patterns
[00:21:49] <LinearInterpol> Don't shoot, I'm dumb! :P
[00:21:57] <hansjorg> dbaupp: great! it needs some testing
[00:22:15] <mcpherrin> not that much though.  Probably not worth the complexity.
[00:22:54] <aatch> mcpherrin, I think you mean refutable *let* patterns, we have refutable patterns already.
[00:23:12] <dbaupp> hansjorg: are the categories limited to those in the drop down list?
[00:23:14] <LinearInterpol> So, what's an irrefutable/refutable pattern?
[00:23:31] <mcpherrin> aatch: I do.
[00:24:14] *** Joins: hoverbear (hoverbear@moz-FC7C7381.wireless.uvic.ca)
[00:24:15] <aatch> LinearInterpol, so if I have something like `struct Foo(int, int)` then the pattern `Foo(a,b)` will always match it.
[00:24:19] *** Quits: hoverbear (hoverbear@moz-FC7C7381.wireless.uvic.ca) (Quit: hoverbear)
[00:24:19] <dbaupp> hansjorg: also, would it be possible to make the drop down list larger? because it seems there are a lot, but it's hard to browse to find ones that are relevant to a project? :)
[00:24:20] <aatch> No matter what.
[00:24:29] <LinearInterpol> ooooo.
[00:24:31] <LinearInterpol> Cool.
[00:24:34] <cmr> everyone say hi to Sentor :)
[00:24:40] <Sentor> nooo
[00:24:40] <LinearInterpol> Hi Sentor :)
[00:24:43] <Sentor> my cover has been blown!
[00:24:45] <Sentor> hello all
[00:24:46] <cmr> (he said he was intimidated)
[00:25:00] * dbaupp waves to Sentor
[00:25:04] <Sentor> i am a CS student with little more than C# to guide me
[00:25:07] <mcpherrin> Hello Sentor!
[00:25:11] <Sentor> so the next logical step is to leap headfirst into rust
[00:25:11] <dbaupp> cmr: you're such a bully
[00:25:26] <aatch> So it's "irrefutable" because the fact it matches cannot be "refuted".
[00:25:38] <aatch> Sentor, obviously.
[00:25:44] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[00:25:57] <LinearInterpol> aatch: That means only that pattern will match it?
[00:26:10] <LinearInterpol> And nothing else?
[00:26:11] <steveklabnik> Sentor: i ask _really basic_ questions here all the time, the channel is very helpful
[00:26:23] <Sentor> good to know!
[00:26:26] <LinearInterpol> the channel is amazing, if I could I'd give you all money.
[00:26:32] <aatch> LinearInterpol, not quite, it means that the pattern will *always* match it.
[00:26:38] <mcpherrin> _really basic_ questions are great because more people can answer!
[00:26:38] <mcpherrin> yay!
[00:26:54] <LinearInterpol> aatch: Alright.
[00:26:59] <LinearInterpol> What's a refutable pattern?
[00:27:12] <aatch> LinearInterpol, well matching against enum variants is one.
[00:27:21] <LinearInterpol> Like Node()?
[00:27:24] <aatch> But a pattern like `Foo(1, b)` is also refutable.
[00:27:35] <LinearInterpol> Because things might not match it.
[00:27:37] <aatch> Since the first parameter might not be '1'
[00:27:40] <LinearInterpol> Because you've effectively- yeah.
[00:27:41] <cmr> aatch: match foo { x if x < 2 => { ... }, _ => { ... } }
[00:27:43] <cmr> erm
[00:27:46] <cmr> @LinearInterpol 
[00:27:49] <LinearInterpol> You effectively sliced part of your results off.
[00:27:52] <cmr> yup
[00:28:04] <LinearInterpol> So, anything that includes effectively anything that restricts your results.
[00:28:09] <aatch> LinearInterpol, well, that's match guards, so the 'x' still matches anything.
[00:28:10] <ChrisMorgan> Matching against enum variants *can* be irrefutable, provided there is only one variant; given `enum X { Y(Z) }`, `Y(z)` is an irrefutable pattern.
[00:28:13] <aatch> Sort of.
[00:28:36] <LinearInterpol> That means ~Node(_, ~Node(x, _)) is a refutable pattern?
[00:28:50] *** Joins: claudiu (claudiu@moz-D5BFAAB5.hsd1.ca.comcast.net)
[00:29:01] <aatch> LinearInterpol, yes, because the second thing in the `Node` variant might not be a `~Node`
[00:29:06] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[00:29:09] <aatch> it can be `~Empty`
[00:29:11] <LinearInterpol> That's absolutely wonderful.
[00:29:13] <LinearInterpol> I love it.
[00:29:23] *** Quits: bjustin (bjustin@moz-8FC28563.sierrabravo.net) (Quit: Textual IRC Client: www.textualapp.com)
[00:29:26] <hansjorg> dbaupp: yep, no user facing interface for adding categories yet. I'll try expanding the dropdown a bit. (there's completion which helps a bit though)
[00:29:29] <aatch> Also, the value you are matching against also might not be a ~Node.
[00:29:38] *** Quits: claudiu_ (claudiu@CB447DD5.6B10AC3.E2F59BBC.IP) (Ping timeout)
[00:29:50] <LinearInterpol> So enum variants in general are refutable because they have multiple states.
[00:29:57] <dbaupp> hansjorg: yeah, it is very nice, just a little small :)
[00:30:04] <LinearInterpol> Effectively.
[00:30:10] <LinearInterpol> Unless you limit them to one.
[00:30:16] *** Quits: willingc (willingc@moz-B4760708.san.res.rr.com) (Client exited)
[00:30:47] <dbaupp> :( travis is being slow...
[00:30:55] <aatch> LinearInterpol, yep. 
[00:31:02] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[00:31:04] <LinearInterpol> Yaaaay!
[00:31:05] *** Joins: Sgeo (quassel@moz-4E71E7BB.dyn.optonline.net)
[00:31:06] * LinearInterpol got it!
[00:31:21] *** Joins: Skif (emschwar@moz-4C5BB5A8.beyondbb.com)
[00:31:23] <LinearInterpol> I love this language just because of all of this. It's immensely powerful.
[00:31:24] *** Quits: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com) (Quit: Jesse)
[00:31:56] <aatch> Rust is quite easy once you understand it, it's getting the understanding that's the hard part.
[00:32:59] *** Joins: Skif_ (emschwar@moz-4C5BB5A8.beyondbb.com)
[00:33:04] *** Quits: Skif (emschwar@moz-4C5BB5A8.beyondbb.com) (Ping timeout)
[00:34:13] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[00:34:44] *** Quits: Skif_ (emschwar@moz-4C5BB5A8.beyondbb.com) (Ping timeout)
[00:35:51] <LinearInterpol> My understanding is slowly coming.
[00:36:02] <LinearInterpol> I'm drifting away from my C cage.
[00:36:18] <mcpherrin> How much C experience do you have?
[00:36:40] <LinearInterpol> Too much.
[00:36:54] <LinearInterpol> Things that usually end up with me using the void pointer.
[00:37:00] <LinearInterpol> Wayy too many times.
[00:37:24] *** Quits: KindOne (KindOne@moz-C1511E4F.dynamic.ip.windstream.net) (Ping timeout)
[00:37:32] *** Joins: Denommus (AndChat420@moz-77CFEF2B.user.veloxzone.com.br)
[00:37:48] <mcpherrin> void***
[00:37:56] <SingingBoyo> LinearInterpol: As someone taking a class on NullPointerExceptions, I feel your pain.
[00:38:10] <SingingBoyo> well, it's different, but similar
[00:38:11] <LinearInterpol> Here, let me grab you a snippet from one of my projects.
[00:38:18] <bstrie> SingingBoyo: ...a whole class on them?
[00:38:24] <SingingBoyo> bstrie: sure feels like it
[00:38:42] <mcpherrin> pointer to a pointer to a function that takes a pointer to a pointer to a void pointer and returns a pointer to a void pointer
[00:38:48] <mcpherrin> the only type you need in C :-)
[00:38:49] *** Joins: tiffany (kawaii@moz-FC0DB29D.dhcp.embarqhsd.net)
[00:38:57] *** Joins: omegaga_ (omegaga_@B77BB5D5.F09091A8.1348A864.IP)
[00:39:15] <mcpherrin> (n.b. I have used that before but I am not figuring out how to write it :P)
[00:39:32] <Denommus> I am Andrew Ryan, and I'm here to ask you a question: is a man not entitled to how he wants a variable captured in a closure? 
[00:40:26] <dbaupp> Denommus: as in capture clauses ala C++?
[00:40:26] <mcpherrin> Denommus: No, because we demand safety.  You don't own us. Reopen the bathyspheres to the surface!
[00:40:41] *** Quits: omegaga_ (omegaga_@B77BB5D5.F09091A8.1348A864.IP) (Connection reset by peer)
[00:40:50] *** Quits: carllerche (carllerche@moz-2B516F15.hsd1.or.comcast.net) (Quit: carllerche)
[00:41:01] <Denommus> Yup, like capture clauses. 
[00:41:05] *** Joins: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP)
[00:41:10] <LinearInterpol> ((Module*)core->Modules->Entries[iterator].Data)->Init(core, ((Module*)core->Modules->Entries[iterator].Data));
[00:41:14] <LinearInterpol> ^ That's one line.
[00:41:21] <LinearInterpol> 		if(((Object*)core->Objects->Entries[iterator].Data) != null) {
[00:41:22] <LinearInterpol> 			((Object*)core->Objects->Entries[iterator].Data)->Init(((Object*)core->Objects->Entries[iterator].Data));
[00:41:22] <LinearInterpol> 		}
[00:41:24] <LinearInterpol> ^ And that's 3.
[00:41:37] <Denommus> Having options of capturing by reference, moving or value 
[00:41:38] *** Joins: KindOne (KindOne@moz-C1511E4F.dynamic.ip.windstream.net)
[00:41:38] <dbaupp> LinearInterpol: looks good
[00:41:45] <LinearInterpol> horrible. I want to shoot it.
[00:41:49] *** Quits: int3_ (int3_@B9C75F30.B8DE573D.EC6C369A.IP) (Ping timeout)
[00:42:05] <dbaupp> Denommus: well, moving and value are the same ;P
[00:42:15] <dbaupp> but yeah, it would be nice
[00:42:28] <Denommus> dbaupp: I meant by copy, not value 
[00:42:33] <dbaupp> although with our current closures set up there's not much point
[00:42:42] <dbaupp> capturing by copy would just be capturing a .clone()
[00:42:53] <aatch> `**(void *)(void **)` I *think*
[00:43:00] <aatch> mcpherrin, ^^
[00:43:03] <Denommus> This could be implemented to be safe, and it would allow more flexibility 
[00:43:08] <dbaupp> Rust doesn't have a "copy" built into the language (other than for primitive types)
[00:43:14] *** Quits: nkoep (nik@moz-C88D09B8.pool.mediaways.net) (Quit: Leaving)
[00:43:15] <mcpherrin> aatch: I don't think that looks quite right
[00:43:23] <dbaupp> Denommus: yes, but it wouldn't make our current closures more flexible
[00:43:33] <dbaupp> proc() *has* to capture by value
[00:43:46] <Denommus> dbaupp: which is good. Having to call clone directly would actually be great 
[00:43:55] <dbaupp> || doesn't matter if it captures by ref or by value, since it isn't allowed to move out of it's captures
[00:43:58] <Denommus> dbaupp: elaborate 
[00:44:05] <mcpherrin> aatch: but I don't caaaare ;)
[00:44:08] <dbaupp> Denommus: elaborate on proc()?
[00:44:14] <dbaupp> *its captures
[00:44:20] <Denommus> dbaupp: hm
[00:44:33] <dbaupp> Denommus: proc() is Sendable, and references are never sendable
[00:44:51] <dbaupp> so you can't capture something by reference in a proc()
[00:45:16] <Denommus> dbaupp: right, I get it 
[00:45:21] <aatch> Denommus, basically, we don't have capture clauses because they'd end up being redundant.
[00:45:22] *** Joins: carllerche (carllerche@moz-2B516F15.hsd1.or.comcast.net)
[00:45:41] <dbaupp> Denommus: with unboxed closures, it would make more sense to have capture clauses
[00:45:58] <dbaupp> (in fact, they probably wouldn't be usable without some form of capture-control.)
[00:46:26] *** Quits: jadbaires (jadrian@moz-E16F2010.dsl.telepac.pt) (Quit: Konversation terminated!)
[00:46:28] <aatch> What *are* unboxed closures, by the way?
[00:46:32] *** Joins: jadbaires (jadrian@7A056CD5.AF63E717.6119BA41.IP)
[00:46:40] <dbaupp> the raw environement struct
[00:46:57] *** Quits: omnus (omnus@moz-2E009EE2.stny.res.rr.com) (Client exited)
[00:47:08] <aatch> So just `Closure` instead of `&Closure` or `~Closure`?
[00:47:10] <dbaupp> a closure is basically struct Env { capture_1 : &T, capture_2: &S, ... } with &Env as &Fn<A, B, Ret>
[00:47:22] <dbaupp> (for a hypotehtical fn trait)
[00:47:23] <dbaupp> yeah
[00:47:32] *** Quits: jadbaires (jadrian@7A056CD5.AF63E717.6119BA41.IP) (Quit: Konversation terminated!)
[00:47:38] *** Joins: jadbaires (jadrian@7A056CD5.AF63E717.6119BA41.IP)
[00:48:27] <aatch> Hmm... would that actually work? Doesn't that make Closure a variable-sized type?
[00:48:57] <Denommus> I think a comparison to C++'s closures would be useful in the docs. I didn't get all of this at first, you had to explain to me :-) 
[00:49:17] <dbaupp> aatch: not quite
[00:49:29] <dbaupp> aatch: each closure gets a unique type
[00:49:35] <Denommus> aatch: this would be resolved at compile time, not runtime 
[00:49:52] <dbaupp> (i.e. a magical compiler generated struct with a fixed size and everything)
[00:50:18] <dbaupp> unfortunately this makes writing the closure in type sigatures kinda difficult
[00:50:19] <aatch> dbaupp, ah, like C++
[00:50:32] <aatch> Thats what I was thinking.
[00:50:57] <dbaupp> I don't know if that's the approach Rust will take (if we get unboxed closures), but doing anything else seems silly.
[00:51:26] <dbaupp> or, at least, I can't think of any other way to do it that avoids dynamic dispatch
[00:52:13] <kimundi> Denommus: Basically, C++ closures are unboxed closures - every one generates a new type that is inlineable etc, and because of that can capture things by copy, move or reference, as its just a struct
[00:52:57] <SiegeLord> Who was that person with the nice work towards making slice sugar? Is that still going well?
[00:53:07] <kimundi> Denommus: Rusts current closure types are |..A| -> B and proc(..A) -> B, the first one being a stack closure, the second one a heap closure
[00:53:10] <dbaupp> SiegeLord: jmgrosen, iirc
[00:53:40] <Denommus> kimundi: and would unboxed closures be weird for some reason? 
[00:53:45] <jmgrosen> SiegeLord: I'm getting there :P
[00:53:51] <jmgrosen> my first compiler stuff, so it's going slowly
[00:53:54] <SiegeLord> I'm excited for that... going to start on a matrix library I think after I'm done with exponent printing
[00:54:04] <dbaupp> Denommus: require more language support
[00:54:04] <Denommus> kimundi: in Rust, I mean 
[00:54:13] <dbaupp> including (limited) return type inference to make them useful
[00:54:21] <kimundi> Denommus: We just don't have them yet - they are planned
[00:54:25] <dbaupp> (and also capture clauses to make the more useful.)
[00:54:33] <Denommus> Ah, great 
[00:54:50] <kimundi> Denommus: right now, proc() and || do virtual calls
[00:55:42] *** Joins: Jesse (jruderman@moz-9754CB0.hsd1.ca.comcast.net)
[00:56:01] <Denommus> Ok, now I get it :-) 
[00:56:07] <Denommus> Thanks for the explanation 
[00:56:22] <kimundi> Both have limitations because proc implies a heap allocation and moving all captures, while || requires all captures to be references - however they encapsuilate the common cases
[00:56:22] <dbaupp> hansjorg: ping
[00:56:24] <LinearInterpol> I have a small, rather ignorant question.
[00:56:30] <LinearInterpol> When are we expecting 1.0?
[00:56:35] <dbaupp> LinearInterpol: I have a small rather ignorant answer
[00:56:40] <LinearInterpol> Hehe.
[00:56:42] <dbaupp> planned for the end of 2014
[00:56:43] <kimundi> LinearInterpol: SOmewhere before 2015, maybe
[00:56:46] *** Quits: elux (peter@B6F21F4B.1F20BC31.2170E5F.IP) (Quit: Bye!)
[00:56:47] <LinearInterpol> Sexy.
[00:56:51] <dbaupp> *before the end of
[00:56:59] <LinearInterpol> I don't care if this language goes belly-up, I'm sticking with it.
[00:57:34] <kimundi> LinearInterpol: Heh, to be fair we are not the only language with pattern matching - try haskell for example :P
[00:57:40] <Denommus> So am I. Rust is the more exciting language since... Common Lisp, maybe 
[00:57:45] <LinearInterpol> You're the only one that makes the most sense to me.
[00:57:47] * kimundi laughs diabolically as he recommends haskell to a C coder
[00:57:57] <LinearInterpol> Because you effectively combined Haskell and C.
[00:58:06] <dbaupp> kimundi: ... you recommended a language other than Rust to someone?
[00:58:11] * dbaupp kicks kimundi
[00:58:27] <kimundi> ouch!
[00:58:32] *** Joins: kralyk (kralyk@34F30349.B098D5D.311B5718.IP)
[00:58:33] <LinearInterpol> I have seriously never had as much fun learning a language.
[00:58:44] <LinearInterpol> Than I've had learning Rust.
[00:58:48] <kvark> dbaupp: it's just a slightly more complex way to lead them to Rust: from C to Haskel and back
[00:59:04] <LinearInterpol> After Rust, I might go to Haskell.
[00:59:09] <kralyk> Hi guys! Rust newbie here.
[00:59:10] <LinearInterpol> I'm making the transition.
[00:59:19] <LinearInterpol> kralyk: woot! Join the club! :D
[00:59:28] <Denommus> LinearInterpol: the thing is that Rust uses familiar terms to alias unfamiliar ones. Enums are algebraic data types, case is compared to pattern matching, etc 
[00:59:33] <dbaupp> LinearInterpol: after Rust? there is only "continuing to use Rust"
[00:59:41] <kimundi> LinearInterpol: I know that feeling - Rust just feels so right to me - even though it changed a lot since I first saw it :P
[00:59:44] <kralyk> LinearInterpol: thanks;-)
[00:59:54] *** Joins: RagingDave (RagingDave@moz-8964F469.pools.arcor-ip.net)
[01:00:02] <kralyk> I have a question. What's Cons?
[01:00:05] <LinearInterpol> It's so beautiful..
[01:00:13] <dbaupp> kvark: heh
[01:00:29] *** Joins: samx (sami@moz-D9F3E0AE.pp.htv.fi)
[01:00:58] <Denommus> kralyk: cons cells are basically pairs 
[01:01:00] <kimundi> kralyk: Nothing specific to the Rust language - which means you've probably seen example code  for a Linked List consisting of the two variants Empty and Cons somewhere?
[01:01:09] <kralyk> kimundi: exactly
[01:01:48] <kralyk> Ahhhhh https://en.wikipedia.org/wiki/Cons
[01:01:50] <kralyk> I get it now
[01:01:55] <kvark> dbaupp: that's a simplified version of how I ended up here, at least (C -> C++ -> ... -> Boo/Python -> Haskell/Dart -> Rust)
[01:01:56] *** Joins: espindol_ (espindola@8EC99D26.4B7A7726.A2E931B1.IP)
[01:02:00] <Denommus> kralyk: you can use them to have linked lists easily by making the second element of a cons another cons and keep doing that recursively 
[01:02:05] <kralyk> LISP jargon... no wonder it was alien to me :D
[01:02:12] <kimundi> rusti: enum List<T> { Empty, Cons(T, ~List<T>) } Cons(5, ~Cons(2, ~Empty))
[01:02:14] -rusti- Cons(5, ~Cons(2, ~Empty))
[01:02:23] <kralyk> Denommus: yup, I'm looking into that.
[01:02:35] <kralyk> can I match it?
[01:02:40] <kimundi> sure!
[01:02:47] *** Quits: espindola (espindola@563D60BB.4B7A7726.A2E931B1.IP) (Ping timeout)
[01:02:56] <dbaupp> rusti: <3, never leave us again
[01:02:58] -rusti- pastebinned 6 lines of output: http://ix.io/9T6
[01:03:11] * kimundi is amused at seeing the third person iterating through linked list pattern matching in Rust this evening
[01:03:22] <LinearInterpol> It's just so AWESOME.
[01:03:24] <dbaupp> kimundi: well, it is in the tutorial
[01:03:28] <kralyk> lol
[01:03:32] * LinearInterpol hasn't read the full tutorial yet.
[01:03:35] <LinearInterpol> The fact that you reduced like
[01:03:44] <LinearInterpol> 100-200 lines of safe C code to 1 line and some rules.
[01:03:46] <dbaupp> kimundi: (it probably indicates that the tutorial needs more focus on the pattern matching)
[01:03:51] <kimundi> Well, then its obviously not extensive enough if the people end up here asking questions about it!
[01:03:53] <LinearInterpol> Lets me know I've found nirvana.
[01:04:12] <LinearInterpol> Hell, at this point, idgaf about speed.
[01:04:16] <kralyk> The reason I'm dooing linked list is I saw a C-newbie on a site I frequent doing linked list for education, so I thought "Could I do it in Rust?"
[01:04:22] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[01:04:29] *** Quits: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com) (Ping timeout)
[01:04:33] <LinearInterpol> kralyk: just wait until you start doing k-ary trees.
[01:04:35] <LinearInterpol> and graphs.
[01:04:48] <kralyk> Right, one thing at a time ;-)
[01:04:57] <Denommus> Well, destructuring lists is something that exists since ever in Lisp 
[01:05:01] *** Quits: samx (sami@moz-D9F3E0AE.pp.htv.fi) (Ping timeout)
[01:05:16] <dbaupp> ... don't try a doubly linked list
[01:05:22] <LinearInterpol> ...
[01:05:27] <kralyk> I still can't match it it says type mismatch
[01:05:29] <LinearInterpol> that seems like it'd end up horribly.
[01:05:31] <dbaupp> (well, only try it if you use std::rc::Rc)
[01:05:32] <kimundi> LinearInterpol: Hehe, the moment you start wrting cyclic data structures in RUst is the moment where you realizes that not everything in Rust is beautiful :P
[01:05:34] <LinearInterpol> kralyk: paste yer code!
[01:05:39] <kralyk> right hang on
[01:05:43] <LinearInterpol> kimundi: Cyclic data structures?
[01:05:54] * LinearInterpol is now afraid again.
[01:05:54] <kimundi> LinearInterpol: Trivial example: double linked list
[01:06:00] <LinearInterpol> Oh jesus.
[01:06:03] <Denommus> dbaupp: graphs also requires cycles 
[01:06:06] <LinearInterpol> So... out of.. morbid curiosity.
[01:06:13] <kralyk> Is there a paster with Rust support? Ideone shamefully doesn't support Rust.
[01:06:22] <LinearInterpol> How would, um.
[01:06:25] <LinearInterpol> You do that.
[01:06:26] *** Joins: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com)
[01:06:27] <LinearInterpol> in one line?
[01:06:37] <kimundi> LinearInterpol: "cyclic" - there are pointers that form cycles through the value
[01:06:52] <kimundi> LinearInterpol: What, double linked lists?
[01:06:53] <Denommus> LinearInterpol: to do that, you need either unsafety or reference count 
[01:06:56] <dbaupp> Denommus: they don't *require* ownership cycles, which means you can write it
[01:07:03] <LinearInterpol> Oh jesus, what, why?
[01:07:16] <Denommus> dbaupp: indeed 
[01:07:21] <dbaupp> Denommus: e.g. put all the nodes in a vector/tree and store indices rather than pointers
[01:07:43] <mcpherrin> When I wrote graph code I .. did what dbaupp just said
[01:07:44] <dbaupp> kralyk: gist.github.com supports Rust
[01:08:19] <kralyk> thanks;-)
[01:08:21] <Denommus> LinearInterpol: because of how it handles ownership. A node needs to be owned by the next node and the previous 
[01:08:29] <mcpherrin> which wasn't super horrible really.  But still sad.
[01:08:43] <kimundi> LinearInterpol: Basically, all Rust values usually form a kind of ownership tree: In "let x = ~5;" for example, the x owns a ~ which owns a int
[01:08:44] <mcpherrin> Using indexes in a graph is nice because you could switch to, eg, an adjacency matrix 
[01:08:51] *** Joins: espindola (espindola@563D60BB.4B7A7726.A2E931B1.IP)
[01:08:58] <LinearInterpol> Yet.. doubly linked lists require dual ownership.
[01:08:59] <LinearInterpol> Jesus.
[01:09:07] *** Quits: vmx (vmx@moz-8895A01C.pools.arcor-ip.net) (Quit: Leaving)
[01:09:20] <Denommus> LinearInterpol: you got it fast 
[01:09:34] <kimundi> LinearInterpol: However, if you introduce some kind of cycle, that "tree" model of ownership breaks down - stuff ends up owning itself in cycles
[01:09:38] <mcpherrin> It's only really horrible when you want nodes to have different lifetimes
[01:09:38] *** Quits: espindol_ (espindola@8EC99D26.4B7A7726.A2E931B1.IP) (Ping timeout)
[01:09:50] <mcpherrin> or if you want to split your tree up and stuff
[01:09:54] <mcpherrin> (which you often do :P)
[01:10:05] <Denommus> LinearInterpol: anyway, Rust does have a safe DList implementation. I don't remember if it is in std or extra 
[01:10:19] <mcpherrin> It's all @mutey isn't it?
[01:10:27] <kralyk> Ok here's my lame attempt at matching Cons: https://gist.github.com/vojtechkral/b8ccfcf2b1ccf4b9110f
[01:10:49] <LinearInterpol> Yikes..
[01:10:54] <Denommus> I'm going to change to the computer 
[01:10:57] <kimundi> LinearInterpol: So, in Rust you either need types that explcictly allow "shared" ownership (example: Gc<T> for garbage colleced T and Rc<T> for reference counted), or you just use a minimal amount of unsafe pointers that are encapsulated behind safe interfaces
[01:10:58] <LinearInterpol> kralyk: not at you.
[01:10:59] *** Quits: Denommus (AndChat420@moz-77CFEF2B.user.veloxzone.com.br) (Quit: Bye)
[01:11:12] <LinearInterpol> How do I construct an unsafe pointer?
[01:11:14] *** Joins: int3_ (int3_@B9C75F30.B8DE573D.EC6C369A.IP)
[01:11:27] <steveklabnik> .... which is how those 'shared' types work
[01:11:36] <kimundi> LinearInterpol: by casting a safe reference to it
[01:11:54] <kimundi> rusti: let x = &5 as *int; x
[01:11:55] -rusti- (0x7f4622864d18 as *())
[01:12:14] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[01:12:24] <LinearInterpol> Ooooh.
[01:12:37] <LinearInterpol> Alright.. so.
[01:12:43] <kvark> New question: is it a good idea to make the repository to match rustpkg workspace? I've been seeing a lot of projects which just slap source in the root folder, designed to be checked out into src/ of the current workspace
[01:12:57] *** Joins: hoverbear (hoverbear@moz-FC7C7381.wireless.uvic.ca)
[01:13:00] <LinearInterpol> You assign the address of 5 to x as an int pointer.
[01:13:55] <kimundi> LinearInterpol: Hm, actually that example is perhaps a bit confusing, as it uses a few shortforms
[01:13:57] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[01:14:17] <kimundi> rusti: let tmp = 5; let x = &5; let y = x as *int; y
[01:14:18] -rusti- <anon>:10:13: 10:16 warning: unused variable: `tmp`, #[warn(unused_variable)] on by default
[01:14:18] -rusti- <anon>:10         let tmp = 5; let x = &5; let y = x as *int; y
[01:14:18] -rusti-                       ^~~
[01:14:18] -rusti- (0x7fd0f2531d10 as *())
[01:14:29] <kimundi> rusti: let tmp = 5; let x = &tmp; let y = x as *int; y
[01:14:30] -rusti- (0x7f0d24a5cd20 as *())
[01:14:40] <kimundi> There, that does the same, but more explicit
[01:15:08] <LinearInterpol> I see. Alright.
[01:15:12] <dbaupp> rusti: &5 as *int // less explicit ;P
[01:15:13] -rusti- (0x7f71510a5d20 as *())
[01:15:13] <kimundi> But yeah, you end up with a raw int pointer
[01:15:52] <LinearInterpol> Lovely. So you can do unsafe things with it.
[01:16:08] <kimundi> rusti: 5.as_void_ptr()
[01:16:09] -rusti- (0x7f914718fd20 as *())
[01:16:19] <kimundi> / obscure, but less casty :P
[01:16:42] <LinearInterpol> I have.. another interesting question.
[01:16:50] <LinearInterpol> What can I do with #[no_std];?
[01:17:05] <dbaupp> the same as you can do without it
[01:17:09] <dbaupp> it just takes more work
[01:17:26] <dbaupp> (e.g. libstd is #[no_std]; and builds up everything itself.)
[01:17:41] <LinearInterpol> So, what does it remove, or what does it add?
[01:17:48] <kimundi> LinearInterpol: Well, if you put that into your crate, rustc will not link to the standart library - which emans you can write very low level Rust code, without worrying about the Rust runtime
[01:17:53] <dbaupp> it removes the automatic insetion of the std crate
[01:18:03] <LinearInterpol> Oooo.
[01:18:04] <dbaupp> that's all
[01:18:15] <LinearInterpol> So, in that little code example with linked lists..
[01:18:19] <LinearInterpol> Can I still do that?
[01:18:20] * pcwalton mistyped "bors" as "bros"
[01:18:22] <dbaupp> (it has the consequence that you have to define of things yourself, thoguh.)
[01:18:24] <kralyk> Ok here's my lame attempt at matching Cons: https://gist.github.com/vojtechkral/b8ccfcf2b1ccf4b9110f
[01:18:24] <kimundi> LinearInterpol: For example, people writing theri own kernels in Rust need to use no_std
[01:18:24] <LinearInterpol> With #[no_std];?
[01:18:32] <kralyk> ignore that wrong shell
[01:18:34] <dbaupp> pcwalton: r=fist-bump
[01:18:36] <LinearInterpol> Yeah, just like not including any standard lib.
[01:18:37] <LinearInterpol> In C.
[01:18:43] * LinearInterpol works in embedded.
[01:18:49] *** Joins: samx (sami@moz-D9F3E0AE.pp.htv.fi)
[01:19:04] *** Joins: omegaga_ (omegaga_@B77BB5D5.F09091A8.1348A864.IP)
[01:19:07] <kimundi> LinearInterpol: Well, you can write it, but you'll need to define a few lang items - at least the allocator one ~ uses afaik
[01:20:12] *** Joins: jfbk (jfbk@moz-EEA9CFB3.nyc.res.rr.com)
[01:20:30] <LinearInterpol> I feel like a kid again.
[01:20:30] <kralyk> Ok here's my code http://kral.hk/rnz   assigns on lines 10 and 14 fail, because mutability is not compatible. How can I fix that?
[01:20:37] <kvark> Anyone with medium/rich rustpkg experience here?...
[01:20:44] *** Joins: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[01:21:27] <kvark> kralyk: let mut tail = ...
[01:22:07] <LinearInterpol> How fast is Rust?
[01:22:10] <kralyk> kvark: nothing changed :-/
[01:22:32] *** Quits: samx (sami@moz-D9F3E0AE.pp.htv.fi) (Ping timeout)
[01:22:40] <dbaupp> LinearInterpol: as fast as C
[01:22:48] <kralyk> the tail is already mutable, trouble is the ~next is not...
[01:22:51] <LinearInterpol> ...seriously?!
[01:22:53] *** Joins: a_m0d2 (a_m0d@moz-322A4DE4.acanac.net)
[01:22:58] <dbaupp> yes, it's a low level language
[01:23:04] * LinearInterpol praises the Rust gods.
[01:23:09] <LinearInterpol> Please never let this language die.
[01:23:16] <aatch> LinearInterpol, mostly. We also have inline assembly if you need to get your hands dirty.
[01:23:32] <aatch> (though it's not particularly easy to use)
[01:23:41] <LinearInterpol> It's like you all answered my prayers.
[01:23:49] <dbaupp> in theory we have more information to pass to the optimiser, so we can possibly be faster (e.g. for pointer heavy code we have aliasing guarantees that C doesn't)
[01:23:50] *** Quits: hays (quassel@moz-44FAC495.washdc.east.verizon.net) (Ping timeout)
[01:23:50] *** Joins: hays_ (quassel@moz-CD956DC5.washdc.east.verizon.net)
[01:23:55] <Earnestly> Well rust will attempt to be as fast as C/C++ ;p
[01:23:58] *** Parts: a_m0d1 (dschoof@moz-A861BB8.coyotecorp.com) ()
[01:24:01] <LinearInterpol> Something better yet equivalent in power to C.
[01:24:08] *** sam113101 is now known as sam113101_afk
[01:24:30] *** Parts: a_m0d2 (a_m0d@moz-322A4DE4.acanac.net) ()
[01:24:31] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[01:24:56] <aatch> We currently don't do TBAA (which we really, really should) and a number of other smaller optimisations that C/C++ does.
[01:25:07] *** Joins: a_m0d2 (a_m0d@moz-322A4DE4.acanac.net)
[01:25:15] <aatch> But that's more a matter of effort than any technical reason.
[01:25:36] <LinearInterpol> God, what can't this language do.
[01:25:38] <kimundi> And a few cases will always be a bit slower for safety reasons - like bound checks on array indexing
[01:25:49] <LinearInterpol> That. I am willing to forgoe.
[01:25:57] <LinearInterpol> *forgo.
[01:26:07] <kimundi> But even that can be mostly optimized away with higher level constructs like iterators
[01:26:10] <aatch> We do have unsafe_get and unsafe_set that *don't* do bounds checks though.
[01:26:19] <kimundi> true
[01:26:22] <LinearInterpol> Can I donate?
[01:26:26] <LinearInterpol> I want to fund you people.
[01:26:40] *** Quits: lucian (lucian@moz-8408FDFA.cable.virginm.net) (Input/output error)
[01:26:49] <dbaupp> LinearInterpol: talk to brson
[01:26:59] <LinearInterpol> Like, every time I try to find something bad about it.
[01:27:00] <aatch> LinearInterpol, I won't say "no", but Rust is backed by Mozilla.
[01:27:01] *** Joins: lucian (lucian@moz-8408FDFA.cable.virginm.net)
[01:27:10] <LinearInterpol> A new, more awesome thing pops up.
[01:27:23] <aatch> The core team *is* paid to work on it.
[01:27:33] <LinearInterpol> Sorry if I sound way too excited, it's just that I've been living in a programming hole the past like 6 years.
[01:27:47] <LinearInterpol> That has traumatized me. o_e
[01:27:52] <dbaupp> LinearInterpol: you can also donate your time, by hacking on the code :)
[01:27:59] <kvark> what about the bitcoins that are paid for rust commits? are they taken from some donation pool, or also from Mozilla?
[01:28:01] <dbaupp> <3 contributors
[01:28:10] <LinearInterpol> I would love to, if I could even comprehend it.
[01:28:13] <LinearInterpol> Is it all written in rust?
[01:28:13] <dbaupp> kvark: third-party donation services
[01:28:18] <dbaupp> almost all, yes
[01:28:21] <aatch> LinearInterpol, mostly.
[01:28:22] <kvark> LinearInterpol:^
[01:28:31] <LinearInterpol> When I learn rust.
[01:28:34] <dbaupp> (other than some thin OS wrappers, and the LLVM optimiser)
[01:28:36] <LinearInterpol> (mostly all of it, I suppose)
[01:28:42] *** Quits: lucian (lucian@moz-8408FDFA.cable.virginm.net) (Ping timeout)
[01:28:43] <LinearInterpol> I will contribute the hell out of what I can.
[01:28:48] <kvark> dbaupp: really no advice on rustpkg?..
[01:28:51] <aatch> We use LLVM and libuv and some other small bits of C/C++ code.
[01:29:03] <dbaupp> kvark: nope, dunno how to use it
[01:29:12] <dbaupp> (oh, yeah, libuv...)
[01:29:28] <aatch> LinearInterpol, do what I did, learn Rust *by* hacking on something.
[01:29:30] *** a_m0d2 is now known as a_m0d
[01:29:45] <LinearInterpol> There's a lot of crazy things about Rust that still scare me.
[01:29:52] <aatch> Doesn't have to be the compiler, the libraries always need more love.
[01:29:56] <dbaupp> LinearInterpol: boo!
[01:29:59] <LinearInterpol> lol.
[01:30:04] *** Joins: copumpkin (copumpkin@moz-FC353116.dyn.optonline.net)
[01:30:22] *** Quits: canhtak (canhtak@moz-4B5B3414.wl.t.ulaval.ca) (Quit: canhtak)
[01:30:36] *** Joins: samx (sami@moz-77A1C177.pp.htv.fi)
[01:31:35] *** Quits: bmats (bmats@moz-87F0A991.hfc.comcastbusiness.net) (Ping timeout)
[01:31:57] <kralyk> Wow I didn't expect to get stuck this early. Guys, how do I traverse through the linked list without recursion?
[01:32:05] *** Quits: gwty (gwtypc@77D2A3.3F98A9B1.CF29F6CE.IP) (Ping timeout)
[01:32:12] <kimundi> LinearInterpol: Reading the source of libstd is a good way to get more familiar with the language
[01:32:24] *** Quits: Sentor (kvirc@7C215BE5.7848DBDF.DBB01AA2.IP) (Quit: Sentorian Intelligent Chat Bot, version 4.0.4 Insomnia.)
[01:32:26] <steveklabnik> LinearInterpol: i learned a lot by trying to write documentation for things that didn't have any
[01:32:33] <steveklabnik> "how do I even _call_ this thing?"
[01:33:20] <kimundi> kralyk: hm, good question actually - I guess you could start with the beginning and then in a loop get a reference to each next node
[01:33:21] <LinearInterpol> Hah!
[01:33:25] <Ke> would be awesome to have even type level documentation for everything
[01:33:32] <LinearInterpol> I'll hack on things when I know enough.
[01:33:42] <LinearInterpol> When I'm comfortable enough, too. I'm in a rapid transitional period from C.
[01:33:52] *** Joins: Skif (emschwar@moz-4C5BB5A8.beyondbb.com)
[01:34:12] <danikar> can rust be ran on windows without msys/mingw?
[01:34:20] <kralyk> kimundi: I tried that, but I guess I don't understand how the references work yet... kral.hk/rnz
[01:34:22] <kimundi> danikar: Not at the moment
[01:34:38] <LinearInterpol> When's the decoupling from MinGW expected?
[01:34:52] *** jorendorff is now known as jorendorff_away
[01:34:52] <LinearInterpol> (by the way, I love that you guys are using MinGW instead of friggin' vstools)
[01:35:01] <LinearInterpol> Open source toolchains for the win.
[01:35:20] <SiegeLord> Glad somebody likes it ;)
[01:35:20] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Connection reset by peer)
[01:35:23] <dbaupp> LinearInterpol: when LLVM's toolchain works well enough
[01:35:32] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[01:35:41] *** Quits: vgeddes (vincent.ge@moz-4C6314FC.dsl.mweb.co.za) (Ping timeout)
[01:35:41] *** Quits: Skif (emschwar@moz-4C5BB5A8.beyondbb.com) (Ping timeout)
[01:36:09] <LinearInterpol> LLVM's toolchain still doesn't work well enough
[01:36:10] <LinearInterpol> ?
[01:36:17] *** Joins: espindol_ (espindola@8EC99D26.4B7A7726.A2E931B1.IP)
[01:36:19] <dbaupp> apparently
[01:36:26] <steveklabnik> Ke: it should have at least type level docs on everything
[01:36:28] <LinearInterpol> The hell's wrong with it? :P
[01:36:44] *** Quits: omegaga_ (omegaga_@B77BB5D5.F09091A8.1348A864.IP) (Client exited)
[01:36:45] <kimundi> kralyk: Oh, for appending to the end... Thats actually kinda hard todo without unsafe code,  because you need to modify the end _and_ rember the beginning
[01:37:10] *** Quits: espindola (espindola@563D60BB.4B7A7726.A2E931B1.IP) (Ping timeout)
[01:37:16] *** Quits: franckverrot (Franck_Ver@C3033BF6.B86F1645.C91367C6.IP) (Ping timeout)
[01:37:16] <kralyk> oh...
[01:37:38] *** Joins: espindola (espindola@563D60BB.4B7A7726.A2E931B1.IP)
[01:38:14] <kimundi> kralyk: Wait, I just though of something that might work... But its also almost 3 AM here, so I can't really think clear anymore :P
[01:38:44] *** Quits: samx (sami@moz-77A1C177.pp.htv.fi) (Ping timeout)
[01:38:47] <kimundi> Nah, that wouldn't work either... hm...
[01:38:48] <kralyk> Im in the same timezone lol ;-)
[01:38:51] <trinary> ok, complete newbie here, trying to play with DuplexStream. I have an enum, Command. I want to send Command values across a DuplexStream.
[01:38:54] *** Quits: espindol_ (espindola@8EC99D26.4B7A7726.A2E931B1.IP) (Ping timeout)
[01:39:16] *** sam113101_afk is now known as sam113101
[01:39:19] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[01:39:21] *** Quits: Mowah (Mowah@moz-E62A9639.cust.bredbandsbolaget.se) (Ping timeout)
[01:39:24] *** Joins: Mowah (Mowah@moz-8548F376.cust.bredbandsbolaget.se)
[01:39:35] *** Quits: blank_name (blank_name@A6C6321C.964BADD.93A5C78C.IP) (Ping timeout)
[01:39:38] *** Joins: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net)
[01:39:45] <kralyk> It must be somehow possible to append to linked list using standard code, or not?
[01:39:49] <trinary> let (from, to) = DuplexStream<Command, Command>::new()  // ?
[01:40:38] *** Joins: samx (sami@moz-77A1C177.pp.htv.fi)
[01:40:41] <kimundi> kralyk: From the beginning its easy
[01:40:41] *** Joins: geoffhill (geoffhill@moz-738DC0DB.org)
[01:41:16] <kralyk> kimundi: you mean insert in front?
[01:41:20] <kimundi> yes
[01:41:28] *** Quits: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net) (Ping timeout)
[01:41:45] *** Joins: echristo (echristo@60A74940.D6CCE4AE.77834EAA.IP)
[01:42:06] <kralyk> okay then, if I use recursion, will stack overflow be a possibility or is it gonna me tail-call-optimized?
[01:42:09] <kimundi> And appending might work too, but I don't know wether it does of the top of my head
[01:42:12] *** Joins: earlzlap (earlz@moz-483E1E31.neo.res.rr.com)
[01:42:23] <kimundi> kralyk: No idea
[01:42:33] <kralyk> ok, don't worry ;-)
[01:42:36] <dbaupp> trinary: the type annotation has to be DuplexStream::<Command, Command>::new() (with the :: before the <)
[01:42:38] *** Quits: espindola (espindola@563D60BB.4B7A7726.A2E931B1.IP) (Connection reset by peer)
[01:42:39] <kimundi> kralyk: We certainly don'T guarantee such optimizations
[01:42:49] *** Joins: espindola (espindola@563D60BB.4B7A7726.A2E931B1.IP)
[01:42:58] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Client exited)
[01:43:08] <trinary> dbaupp: arrrgghhh that's it, thank you. :)
[01:43:14] *** Quits: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net) (Client exited)
[01:43:21] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[01:43:35] *** Joins: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net)
[01:43:45] <dbaupp> trinary: often, you can just leave the annotation off and write DuplexStream::new() and let type inference handle it
[01:43:52] <dbaupp> (sometimes this doesn't work, of course.)
[01:44:05] <a_m0d> Is there a way to force `rustdoc` to generate documentation for private items?
[01:44:11] <kralyk> Is the Cons thingy defined somewhere?
[01:44:14] <geomyidae> Was there a verdict regarding unsafe arc and libgreen?
[01:44:22] <dbaupp> a_m0d: yes
[01:44:29] <geomyidae> I guess I should look and see if tcp/udp in libuv is threadsafe or not
[01:44:39] <trinary> Will try that, and it could be because of how I'm using it elsewhere, but it seemed to think it was <&str, &str> if I did that
[01:44:55] <dbaupp> a_m0d: you use the --passes argument and avoid passing --strip-private
[01:45:03] <dbaupp> a_m0d: (see --passes list for the full list.)
[01:45:12] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[01:45:14] <a_m0d> dbaupp: Thanks.  Is there a way to pass that to `make docs`?
[01:45:18] *** Quits: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net) (Ping timeout)
[01:45:20] <dbaupp> no idea
[01:45:27] *** Quits: jdm (jdm@CAB30FBD.8F96AEA7.2D179A7D.IP) (Ping timeout)
[01:45:28] <dbaupp> edit the make files
[01:45:31] <a_m0d> ok, I'll investigate
[01:45:32] <a_m0d> thanks
[01:45:44] <dbaupp> theres mk/docs.mk
[01:45:51] <kimundi> kralyk: No, its just a simple example: enum List<T> { Empty, Cons(T, ~List<T>) }
[01:45:58] *** Joins: jdm (jdm@CAB30FBD.8F96AEA7.2D179A7D.IP)
[01:45:58] *** ChanServ sets mode: +o jdm
[01:45:59] *** Joins: franckverrot (Franck_Ver@C3033BF6.B86F1645.C91367C6.IP)
[01:46:22] <kimundi> rusti: enum List<T> { Empty, Cons(T, ~List<T>) }; Cons(5, ~Cons(2, ~Empty))
[01:46:23] -rusti- Cons(5, ~Cons(2, ~Empty))
[01:47:41] *** Quits: hoverbear (hoverbear@moz-FC7C7381.wireless.uvic.ca) (Quit: Taking a nap.)
[01:47:42] *** Joins: ptc (Adium@moz-8F01578B.z72-46-65.customer.algx.net)
[01:47:50] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Quit: leaving)
[01:48:05] <kralyk> kimundi: Oh, so it's just a name?
[01:48:10] <kimundi> yup
[01:48:11] <kralyk> oh I see...
[01:48:13] *** Joins: brson (brson@981AA104.E81F12CD.76F66111.IP)
[01:48:13] *** ChanServ sets mode: +ao brson brson
[01:48:33] *** Parts: ptc (Adium@moz-8F01578B.z72-46-65.customer.algx.net) ()
[01:48:51] *** Quits: fabiand_ (fabiand@moz-2083A0D0.adsl.alicedsl.de) (Quit: Verlassend)
[01:48:56] <kralyk> I was confused cause my editor highlits it
[01:48:57] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[01:48:59] <kralyk> I have no idea why
[01:49:12] *** Quits: geoffhill (geoffhill@moz-738DC0DB.org) (Quit: )
[01:49:13] *** Quits: ssbr (~ssbr@3246441A.D6CCE4AE.77834EAA.IP) (Ping timeout)
[01:49:34] <kimundi> Ah, some of the highlining files have more than just keywords listed, no idea why :P
[01:49:52] *** Joins: canhtak (canhtak@moz-4B5B3414.wl.t.ulaval.ca)
[01:49:57] <kralyk> lol, way to confuse folks
[01:51:03] *** Joins: Sharp (Sharp@moz-EEC85237.hsd1.ca.comcast.net)
[01:51:38] *** Quits: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP) (Ping timeout)
[01:51:40] <SiegeLord> It's a bit tricky... you do want to highlight built in types
[01:51:45] <SiegeLord> But those are not keywords so...
[01:51:46] *** Quits: earlzlap (earlz@moz-483E1E31.neo.res.rr.com) (Ping timeout)
[01:52:13] <SiegeLord> And building a full parser for syntax highlighting is a bit much :P
[01:52:40] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Ping timeout)
[01:52:43] *** Quits: trinary (Adium@moz-D78CD0D5.hsd1.co.comcast.net) (Quit: Leaving.)
[01:52:47] *** Joins: ptc (Adium@moz-8F01578B.z72-46-65.customer.algx.net)
[01:52:58] <kralyk> Well 'Cons' is not a built-in type... it's not really anything as it turns out...
[01:53:23] <SiegeLord> Yeah, I didn't include prelude stuff in the highlight file I made
[01:53:23] *** sam113101 is now known as sam113101_afk
[01:53:39] <SiegeLord> But it does highlight stuff like use std::num::f64;
[01:53:45] <SiegeLord> Which is jarring... but w/e
[01:54:29] *** Quits: ptc (Adium@moz-8F01578B.z72-46-65.customer.algx.net) (Ping timeout)
[01:55:22] *** sam113101_afk is now known as sam113101
[01:56:04] *** Quits: igork (Adium@9C577557.7893D71C.6E0EE79F.IP) (Quit: Leaving.)
[01:57:40] *** Joins: Denommus (user@moz-77CFEF2B.user.veloxzone.com.br)
[01:57:43] *** Quits: jadbaires (jadrian@7A056CD5.AF63E717.6119BA41.IP) (Quit: Konversation terminated!)
[01:58:04] <Denommus> guys
[01:58:13] <steveklabnik> (and girls)
[01:58:21] <Denommus> tell me the truth: you sold your soul to the devil, didn't you?
[01:58:30] <mcpherrin> Denommus: I *am* the devil
[01:58:47] <Denommus> it's impossible to have designed such a perfect language without the involvement of the devil himself
[01:58:49] <kimundi> Denommus: Darn it, you got us
[01:58:53] <steveklabnik> hahahaha
[01:58:56] <steveklabnik> <3
[01:58:58] <kimundi> Pack upeveryone, the jig is up!
[01:59:30] *** Joins: espindol_ (espindola@8EC99D26.4B7A7726.A2E931B1.IP)
[02:00:16] *** Quits: carllerche (carllerche@moz-2B516F15.hsd1.or.comcast.net) (Quit: carllerche)
[02:00:48] *** Quits: espindola (espindola@563D60BB.4B7A7726.A2E931B1.IP) (Ping timeout)
[02:02:22] *** Quits: tikue (tkuehn@268C2DFE.FAD414BA.D74CC41D.IP) (Quit: tikue)
[02:03:06] <LinearInterpol> I wouldn't blame you if you sold your souls.
[02:03:09] *** Quits: int3_ (int3_@B9C75F30.B8DE573D.EC6C369A.IP) (Ping timeout)
[02:03:12] <LinearInterpol> This is perfection in the highest order, even if it's not complete.
[02:06:18] *** Quits: jdm (jdm@CAB30FBD.8F96AEA7.2D179A7D.IP) (Quit: Lost terminal)
[02:06:34] *** Quits: Denommus (user@moz-77CFEF2B.user.veloxzone.com.br) (Ping timeout)
[02:07:11] *** Quits: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com) (Ping timeout)
[02:07:13] <dbaupp> dwrensha: ping
[02:07:21] <dwrensha> dbaupp: hi
[02:07:41] <dbaupp> dwrensha: just wondering if you were going to test avoiding the UTF8 checks yourself?
[02:07:51] <dbaupp> (I'll have a go at it if you don't)
[02:08:59] *** Quits: espindol_ (espindola@8EC99D26.4B7A7726.A2E931B1.IP) (Ping timeout)
[02:09:23] *** Joins: espindola (espindola@8EC99D26.4B7A7726.A2E931B1.IP)
[02:09:30] <dwrensha> I was planning on leaving it be
[02:09:53] <dbaupp> ok, I'll have a poke tonight
[02:10:07] *** Joins: jmgrosen (jmgrosen@moz-8C649C07.cs.ucsb.edu)
[02:10:18] <dwrensha> it'd be trivial to just cast the bytes to a str without a check
[02:10:26] <dwrensha> but it's unclear that that's the right thing to do
[02:10:28] <dbaupp> (but yeah, removing it for production code would be bad: violating the UTF-8 invariant of str's makes rust non-memory safe.)
[02:10:41] *** Joins: espindol_ (espindola@moz-9F530B29.com)
[02:10:58] *** Joins: TylerE (Tyler@moz-33F22668.gvllcmtc01.gnvlnc.ab.dh.suddenlink.net)
[02:11:05] <dwrensha> if the performance in this case were really super important to us...
[02:11:25] <dwrensha> I think the way to go would be to have a capnproto-rust string type
[02:11:34] <TylerE> Is there any way to specify which gcc to use? I have mingw64 and cygwin installed and it's trying (and failing) to compile with the cygwin toolchain
[02:11:34] <dwrensha> that could be converted to a str on demand
[02:11:46] <dwrensha> basically just a &[u8]
[02:12:05] *** Quits: espindola (espindola@8EC99D26.4B7A7726.A2E931B1.IP) (Ping timeout)
[02:12:25] <dbaupp> dwrensha: ah, that's a good idea
[02:12:28] <dwrensha> That would be similar to the approach that capnproto-c++ takes
[02:12:45] <dwrensha> but it's somewhat nicer there, because of implicit conversions to/from std::string
[02:12:55] *** Quits: Ralith (ralith@A8995AA9.62B6AF6A.922221DB.IP) (Ping timeout)
[02:13:10] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[02:14:14] *** Joins: omegaga_ (omegaga_@1A5BA262.25165A39.3F03179E.IP)
[02:14:51] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[02:15:13] *** Joins: chunyang (Thunderbir@89013021.7EB6399.C8ED823E.IP)
[02:16:45] *** Quits: espindol_ (espindola@moz-9F530B29.com) (Ping timeout)
[02:16:52] *** Quits: sehugg (sehugg@moz-42540923.res.bhn.net) (Client exited)
[02:16:58] <strcat> TylerE: it uses whatever is in your %PATH%
[02:17:12] *** Joins: new_one (new_one@moz-D538194E.rice.edu)
[02:17:38] <TylerE> strcat: that's unfortunate
[02:17:42] <kralyk> what's ~ref ?
[02:17:53] <TylerE> as I, *in general* want the cygwin toolchain to be used
[02:17:55] <TylerE> but not for rust
[02:18:09] <strcat> TylerE: you can set a %PATH% just for rust, I guess
[02:18:32] <klutzy> TylerE: for mingw/msys, type `sh /postinstall/pi.sh`
[02:18:49] *** Joins: milesrout (user@moz-7A0A3412.cable.telstraclear.net)
[02:18:53] <klutzy> it will add /mingw entry to your /etc/fstab
[02:19:02] <klutzy> (or you can directly edit fstab)
[02:19:08] *** Parts: milesrout (user@moz-7A0A3412.cable.telstraclear.net) (ERC Version 5.3 (IRC client for Emacs))
[02:19:18] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Connection reset by peer)
[02:19:45] *** Joins: milesrout (user@moz-7A0A3412.cable.telstraclear.net)
[02:19:52] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[02:20:09] <milesrout> I'm sure you get this all the time, and that I should read some sticky on some forum somewhere or something, but is there any general roadmap for progressing to 1.0?
[02:21:09] <kimundi> kralyk: A combination of two differnt parts of a apttern
[02:21:14] <kimundi> pattern
[02:21:16] *** Quits: Siyo (Siyo@A89938F4.87DAA49F.F113998C.IP) (Ping timeout)
[02:21:16] *** Joins: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP)
[02:21:30] <milesrout> Is it "when it's ready"? Because that would be 100% understandable
[02:21:33] <mcpherrin> milesrout: There's talk of writing up an actual roadmap
[02:21:50] <mcpherrin> milesrout: I think people are hoping to have it out within a year
[02:22:15] *** Joins: ssbr (~ssbr@2ABF3B40.D6CCE4AE.77834EAA.IP)
[02:22:35] <mcpherrin> the best information on this sort of stuff is probably in the reddit/hacker news 0.9 release threads actually :-P
[02:22:37] <kimundi> kralyk: let a = 5; let ~a = ~5; let b = &5; let ref b = 5; let ~ref c = ~5;
[02:23:02] <kimundi> kralyk: The two lets with "a" do the same, the two with "b" do the same, "c" combines both
[02:23:21] *** Quits: RagingDave (RagingDave@moz-8964F469.pools.arcor-ip.net) (Quit: Ex-Chat)
[02:23:39] <kimundi> basically, it first matches away the outer ~, then it binds a reference to the value inside it to a name
[02:23:52] *** Quits: z0w0 (zack@moz-87AABEA0.lnse1.woo.bigpond.net.au) (Connection reset by peer)
[02:24:31] <kimundi> "let ~(ref (foo)) = ~5;" if explicit paranthese where legal there :P
[02:24:50] <milesrout> And how much do you expect it to change backwards compatibility-wise? I know that there are absolutely no guarantees during 0.x (hence it being called 0.x), but if it's meant to be 1.0 within a year, that presumably means that it's unlikely it will change TOO MUCH, right?
[02:25:08] <milesrout> I just don't want to start writing something then find that in six months I have to go through all my code and rewrite it.
[02:25:45] <LinearInterpol> milesrout: I doubt you'll have to rewrite all of it. A lot of the core language from what I can see is already implemented really nicely.
[02:25:59] <kimundi> milesrout: syntactically there won't be an major changes, just detail improvements and generalisations in corners of the language semantic - mostly the libraries will continue to change
[02:26:09] <mcpherrin> milesrout: The expecation for 1.0 is that the basic language features will be stable.  Some non-stable features will be feature-gated (you have to do #[feature(foo)] to use them)
[02:26:17] <kralyk> kimundi: ok thanks for explanation, I'm not sure I understand yet, I'll have to read that a couple times ;-)
[02:26:18] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[02:26:30] <mcpherrin> milesrout: New features should be backwards compatible and not break 1.0 code
[02:26:33] <LinearInterpol> Rust is mature enough for me to start using it as my main language.
[02:26:36] <milesrout> Thanks, good to know. Sounds like I should start writing sooner rather than later! :)
[02:27:01] <mcpherrin> Library organization and stability hasn't been entirely worked out yet
[02:27:01] *** Joins: z0w0 (zack@moz-87AABEA0.lnse1.woo.bigpond.net.au)
[02:27:04] <Yurume> milesrout: I've maintained a certain mid-sized code starting from 0.5. :)
[02:27:13] <mcpherrin> but there will be some basic set of code that should be roughly compatible
[02:27:28] <kimundi> kralyk: "ref" is a pattern binding modifier - "let foo = 5;" binds foo to the value 5, while "let ref foo = 5;" binds foo to the value &5
[02:27:32] *** Joins: lucian (lucian@moz-8408FDFA.cable.virginm.net)
[02:27:42] <mcpherrin> I'm hoping we have a "rustfix" tool that can help with library changes too
[02:27:45] <Yurume> I don't have a working version for 0.9 yet (I cannot concentrate easily recently) but there is one for pre-0.9
[02:28:00] <milesrout> mcpherrin: sort of like python's 2to3?
[02:28:00] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[02:28:02] <Yurume> personally it was a fairly mechanical task to convert
[02:28:09] <mcpherrin> milesrout: Yeah.
[02:28:27] <mcpherrin> milesrout: though nobody has written it yet, so I won't guarantee it springs into life :)
[02:28:49] <Yurume> mcpherrin: I think pretty printer still does not work on occasion? :)
[02:29:01] *** Joins: Skif (emschwar@moz-4C5BB5A8.beyondbb.com)
[02:29:11] <mcpherrin> Yurume: :-)
[02:29:16] *** Quits: lucian (lucian@moz-8408FDFA.cable.virginm.net) (Ping timeout)
[02:30:31] <mcpherrin> unfortunately I have a job and I can only handle a few codebases at a time ;)
[02:30:44] *** Quits: Skif (emschwar@moz-4C5BB5A8.beyondbb.com) (Ping timeout)
[02:30:52] *** Joins: Siyo (Siyo@A89938F4.87DAA49F.F113998C.IP)
[02:31:53] *** Quits: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP) (Quit: My MacBook has gone to sleep. ZZZzzz)
[02:32:40] *** Quits: thewonderidiot (mstewart@moz-E41129BA.ipnetworksinc.net) (Quit: Leaving.)
[02:33:20] *** Joins: ptc (Adium@moz-192425C4.nyc.res.rr.com)
[02:33:30] *** Joins: doomlord_ (servitor@moz-CA917A47.range86-184.btcentralplus.com)
[02:37:16] *** Quits: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[02:38:49] *** Quits: hacker_sam (hacker_sam@C0FE520A.661C02A7.B0CE379A.IP) (Connection reset by peer)
[02:38:55] *** Quits: pcwalton (pcwalton@moz-C07D5168.p2p.sfo1.mozilla.com) (Quit: pcwalton)
[02:39:00] *** Joins: hacker_sam (hacker_sam@C0FE520A.661C02A7.B0CE379A.IP)
[02:39:09] <milesrout> "Managed boxes (@) are now behind a feature gate in preperation for future removal. Use the standard library's `Gc` or `Rc` types instead." Why is this?
[02:39:25] <cmr> milesrout: to make the language simpler and more powerful.
[02:39:34] <SiegeLord> People complained hard about the sigils
[02:39:45] *** kimundi is now known as zz_kimundi
[02:40:00] <milesrout> BUT THE SIGILS ARE AMAZING.
[02:40:16] <SiegeLord> We're in the minority :(
[02:40:23] *** Joins: espindola (espindola@8EC99D26.4B7A7726.A2E931B1.IP)
[02:40:25] <strcat> not because of the sigils
[02:40:58] *** Joins: psquid (psquid@moz-66C8375C.threembb.co.uk)
[02:40:58] <milesrout> cmr: fair enough, moving the gc stuff outside of the language into the library makes some level of sense.
[02:40:58] <strcat> milesrout: implicit dynamic borrow checking as required for @mut was viewed as a problem, because it hides a dynamic failure that's hard to reason about
[02:41:23] <strcat> milesrout: and placing garbage collected pointers above other smart pointers was viewed as a problem
[02:41:39] <bjz> dbaupp: https://github.com/bjz/num-rs/blob/master/src/lib.rs
[02:42:10] *** Quits: espindola (espindola@8EC99D26.4B7A7726.A2E931B1.IP) (Ping timeout)
[02:42:18] <dbaupp> bjz: anything in particular that you're pointing out?
[02:42:20] <strcat> milesrout: there's no garbage collector yet anyway so... using @ is problematic since it doesn't offer a way to break reference cycles and does excessive refcounts
[02:42:40] <dbaupp> bjz: it certainly seems to express the various laws
[02:43:03] <bjz> dbaupp: just my new way of doing things - the algebraic traits are auto-derived if they meet the requitements
[02:43:09] *** Joins: espindola (espindola@8EC99D26.4B7A7726.A2E931B1.IP)
[02:43:12] *** Joins: vodik (simon@moz-FD4ADBC6.cable.teksavvy.com)
[02:43:20] <bjz> dbaupp: https://github.com/bjz/num-rs/blob/master/src/lib.rs#L295
[02:43:33] <milesrout> also "The `Either` type has been removed." why? Is it just effectively a specialisation of something else like a Variant type or something?
[02:43:36] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[02:43:46] <dbaupp> bjz: neat
[02:43:52] <strcat> milesrout: it was just a library-defined enum
[02:43:55] <cmr> milesrout: replaced with Result
[02:43:55] <strcat> like Option and Result
[02:43:59] <SiegeLord> Will people have to take number theory to be able to use these traits? :P
[02:44:00] <dbaupp> milesrout: because Result is identical but is clearer as an error handler
[02:44:04] <bjz> dbaupp: I'd need to document it better though
[02:44:19] <dbaupp> SiegeLord: no
[02:44:24] <bjz> milesrout: Eiather is mainly used in Haskell for error handling
[02:44:31] <SiegeLord> I've never heard of magma referring to anything in math
[02:44:34] <dbaupp> SiegeLord: they'll need to take an abstract algebra course :P
[02:44:39] <milesrout> Wow 5 answers for one question. I like this channel.
[02:44:40] <SiegeLord> Great :P
[02:44:47] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[02:44:49] <SiegeLord> Or Monoid
[02:44:52] *** Quits: espindola (espindola@8EC99D26.4B7A7726.A2E931B1.IP) (Ping timeout)
[02:44:52] <dbaupp> </pendant>
[02:44:56] <Yurume> dbaupp: add a quickcheck template for checking invariants? :)
[02:44:56] <bjz> SiegeLord: I'll document it better
[02:45:02] <cmr> SiegeLord: but that's what num-rs is *for*. A real math library.
[02:45:02] <dbaupp> SiegeLord: monoids are cool
[02:45:09] <dbaupp> Yurume: (it's bjz's library)
[02:45:12] <cmr> monoids are cool
[02:45:12] <Yurume> oops
[02:45:19] <Yurume> bjz: (ditto)
[02:45:26] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[02:45:35] <SiegeLord> cmr: https://github.com/bjz/num-rs/blob/master/README.md
[02:45:35] <dbaupp> but yeah, having some sort of built-in invariant checker would be pretty cool
[02:45:52] *** Joins: hoverbear (hoverbear@moz-FC7C7381.wireless.uvic.ca)
[02:45:55] <Yurume> a bit joking, but I actually think something like Invariant template would be useful
[02:45:57] <milesrout> "All crypto functions have been removed and Rust now has a policy of
[02:45:57] <milesrout>         not reimplementing crypto in the standard library." good! Crypto is fun to play with but it's the sort of thing that should be implemented once.
[02:45:57] <bjz> Yurume: yeah, I'me going to have helper functions for unit testing
[02:46:06] <Yurume> s/template/trait/
[02:46:08] *** Quits: hoverbear (hoverbear@moz-FC7C7381.wireless.uvic.ca) (Quit: Taking a nap.)
[02:46:09] <SiegeLord> Those names would be useful for maybe 0.1% of Rust user base :P
[02:46:10] <bjz> Yurume: pub fn assert_mul_is_associative<T: AssociativeMul>(vals: &[((T, T), T)])
[02:46:19] <cmr> SiegeLord: that's why they're not in libstd
[02:46:29] <bjz> SiegeLord: they won't be in the std
[02:46:30] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[02:46:33] <Yurume> trait Invariant { fn invariant(&self) -> bool; }
[02:46:44] <SiegeLord> bjz: Where will they be then? And what does that readme mean then?
[02:46:46] *** Quits: ssbr (~ssbr@2ABF3B40.D6CCE4AE.77834EAA.IP) (Ping timeout)
[02:46:47] <bjz> SiegeLord: std::num is being simplified
[02:47:21] <bjz> SiegeLord: yeah, I should improve the readme to make that clearer
[02:47:28] *** Quits: azakai (alon@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[02:47:33] <bjz> https://github.com/mozilla/rust/issues/10387
[02:47:50] *** Joins: csherratt (csherratt@moz-8D848271.cpe.teksavvy.com)
[02:48:06] <SiegeLord> I better still be able to write fn foo<T: Real>(a: T) -> T { a.sin() } without needing non-std libraries
[02:48:10] <mindcat> I am interest, why bools are not bitarray/bitset
[02:48:11] *** Joins: Ralith (ralith@moz-67D4EB93.customer.broadstripe.net)
[02:48:22] *** Quits: mhoye (mhoye@moz-C14EAE67.vs.heavycomputing.ca) (Ping timeout)
[02:48:26] <dbaupp> mindcat: i.e. inside ~[bool]?
[02:48:39] <bjz> SiegeLord: this kind of stuff is useful for numeric libs, but it is a more for behind-the-scenes machinery to allow them to be composable with each other
[02:49:20] <dbaupp> mindcat: they way C++ does it is considered bad: http://en.wikipedia.org/wiki/Sequence_container_%28C%2B%2B%29#Specialization_for_bool
[02:49:50] <dbaupp> *the way
[02:49:56] <milesrout> dbaupp: not that not just by outsiders, it's considered a terrible mistake by those that introduced the idea in the first place.
[02:50:16] *** Joins: mhoye (mhoye@moz-C14EAE67.vs.heavycomputing.ca)
[02:50:17] <bjz> SiegeLord: the end user would only need to know the very bottom of the numeric tower: Real, Floating, Integer, etc 
[02:50:22] <Yurume> std::vector<bool> specialization hurts everyone
[02:50:37] <dbaupp> milesrout: yes, I believe that section of the page says that :)
[02:50:42] <SiegeLord> bjz: As long as I don't have to learn when I need some magma in my code, I'll be happy
[02:50:44] <mcpherrin> it is unfortunate that we don't have bit-pointers
[02:50:53] <strcat> Yurume: well, it's useful, but should be another type
[02:50:54] <mcpherrin> that would remove the silliness :)
[02:50:55] <bjz> SiegeLord: rustdoc could be improved to show all inherited methods
[02:51:02] <bjz> like the scala docs do
[02:51:14] <strcat> Yurume: not the worst thing in C++ by far ;p
[02:51:20] <Yurume> strcat: lol
[02:51:34] <bjz> SiegeLord: yeah, we definietly don't want that :)
[02:51:35] <strcat> can just use vector<uint8_t> which ends up being 'unsigned char' so you do have the pain of them printing oddly
[02:51:45] <Yurume> I was seriously f*cked up by C++ locales years ago
[02:51:53] <mindcat> dbaupp: I mean, a bit == a bool
[02:51:57] <milesrout> strcat: it arguably is the worst thing in C++ by far, if you ignore the things that have been replaced by better things.
[02:52:07] *** Quits: mhoye (mhoye@moz-C14EAE67.vs.heavycomputing.ca) (Ping timeout)
[02:52:35] <mindcat> dbaupp: why bool size is much big, 8 bits now?
[02:52:52] <strcat> padding
[02:52:54] <mindcat> or 4bits
[02:53:01] <Yurume> mindcat: it is the minimal addressible unit
[02:53:01] <dbaupp> mindcat: because the smallest addressable data type is a byte
[02:53:03] <milesrout> mindcat: because that's the smallest addressible unit of memory on most modern computers.
[02:53:17] *** Quits: omegaga_ (omegaga_@1A5BA262.25165A39.3F03179E.IP) (Client exited)
[02:53:21] <strcat> Yurume: well, x86 can address bits but using i1 everywhere doesn't really work
[02:53:23] <Yurume> mindcat: you cannot take a pointer for bools in ~[bool] if bool only takes a bit
[02:53:31] *** Joins: blank_name (blank_name@A6C6321C.964BADD.93A5C78C.IP)
[02:53:31] <Yurume> and that was actually a case for std::vector<bool>
[02:53:40] <dbaupp> strcat: you can address bits?
[02:53:46] *** Joins: omegaga_ (omegaga_@1A5BA262.25165A39.3F03179E.IP)
[02:53:47] <Yurume> which generates some headaches
[02:54:03] <strcat> dbaupp: x86 is weird
[02:54:20] *** Quits: LinearInterpol (RJones@moz-E6F82C3A.maine.res.rr.com) (Ping timeout)
[02:54:25] <dbaupp> strcat: https://github.com/mozilla/rust/pull/11567 btw
[02:54:34] *** Joins: Tobba (Tobba@moz-462B7F7F.ias.bredband.telia.com)
[02:54:48] *** Quits: Sorella (queen@9D963F5D.DF5D8AE7.54BCAB54.IP) (Quit: It is tiem!)
[02:55:12] *** Quits: jfbk (jfbk@moz-EEA9CFB3.nyc.res.rr.com) (Quit: )
[02:55:27] *** Quits: omegaga_ (omegaga_@1A5BA262.25165A39.3F03179E.IP) (Ping timeout)
[02:55:28] *** Joins: mhoye (mhoye@moz-C14EAE67.vs.heavycomputing.ca)
[02:55:35] <milesrout> actually I take that back, this is the worst thing in C++ http://i.imgur.com/Q09bhpe.png
[02:56:12] *** Quits: samx (sami@moz-77A1C177.pp.htv.fi) (Quit: This computer has gone to sleep)
[02:56:13] <Yurume> I think there is a filter for that
[02:56:39] <Yurume> milesrout: off-topic: http://tgceec.tumblr.com/ :)
[02:56:41] <milesrout> I just erased what I thought (correctly, it turns out) was the problem code and re-wrote it.
[02:58:51] *** Quits: Earnestly (earnest@moz-E86D50FA.dyn.plus.net) (Ping timeout)
[02:59:19] <strcat> rusti: extern { fn getpid() -> u32; } unsafe { getpid() }
[02:59:20] -rusti- 1u32
[03:00:20] <milesrout> Yurume: oh man I have to try to win this.
[03:00:23] <mindcat> I think I just do my stuff now. memory waste, CPU, it is hard for me :(
[03:00:27] <milesrout> Not with that code, with new code of course.
[03:01:07] *** Joins: gwty (gwtypc@77D2A3.3F98A9B1.CF29F6CE.IP)
[03:02:18] *** Joins: lpy (lpy@7360AA58.F09091A8.1348A864.IP)
[03:02:39] *** Joins: lucian (lucian@moz-8408FDFA.cable.virginm.net)
[03:02:39] *** Joins: hoverbear (hoverbear@moz-FC7C7381.wireless.uvic.ca)
[03:03:13] *** Quits: kralyk (kralyk@34F30349.B098D5D.311B5718.IP) (Quit: WeeChat 0.4.2)
[03:04:23] *** Quits: lucian (lucian@moz-8408FDFA.cable.virginm.net) (Ping timeout)
[03:04:52] *** Quits: hoverbear (hoverbear@moz-FC7C7381.wireless.uvic.ca) (Quit: Taking a nap.)
[03:06:06] *** Joins: thewonderidiot (mike@moz-5506A033.hsd1.ca.comcast.net)
[03:07:20] *** Quits: echristo (echristo@60A74940.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[03:07:44] <Yurume> milesrout: I have some entry (not yet submitted) with a ratio exceeding 100 million (I think) and then I'm bored XD
[03:08:12] <Yurume> maybe I just had submitted that much earlier...
[03:08:24] <milesrout> a ratio?
[03:08:54] <Yurume> milesrout: the score is measured by a ratio between the source code and the error message size
[03:08:58] <milesrout> of errors/source size
[03:08:59] <milesrout> ofc.
[03:09:01] <strcat> you can get far with simple stuff
[03:09:06] <milesrout> I bet you can. 
[03:09:18] <strcat> sadly gcc likes to go out-of-memory after printing the error in some cases
[03:09:41] *** Quits: ziad (ziad@B20586FB.BDB3D91.6E370BFC.IP) (Quit: ziad)
[03:09:46] <Yurume> yeah, that was 102,965,937 to be exact (I've run my entry again)
[03:12:56] *** Joins: sehugg (sehugg@moz-42540923.res.bhn.net)
[03:13:55] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[03:14:04] *** Quits: zz_kimundi (kimundi@moz-FAACE8A8.dip0.t-ipconnect.de) (Ping timeout)
[03:14:04] *** Quits: sbalmos (quassel@CA5677B6.576D0C1.ED2EFC1B.IP) (Client exited)
[03:14:53] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Client exited)
[03:15:14] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[03:15:51] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[03:16:56] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Ping timeout)
[03:17:20] *** Joins: zz_kimundi (kimundi@moz-A0A35D8B.dip0.t-ipconnect.de)
[03:17:50] *** zz_kimundi is now known as kimundi
[03:19:19] *** Joins: jdm (jdm@moz-12626D4B.static.videotron.ca)
[03:19:19] *** ChanServ sets mode: +o jdm
[03:19:44] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[03:21:12] *** Joins: vince (vince@87549D5D.A97DAB6F.A7E3DA15.IP)
[03:21:53] <vince> Hello, how do I (dynamically) create a vector of n elements?  The [0, ..n] syntax only works with n as a constant.
[03:23:18] <Yurume> rusti: std::vec::from_elem(~"hi!", 5)
[03:23:21] -rusti- pastebinned 7 lines of output: http://ix.io/9Tg
[03:23:33] <Yurume> rusti: std::vec::from_elem(5, ~"hi! ")
[03:23:35] -rusti- ~[~"hi! ", ~"hi! ", ~"hi! ", ~"hi! ", ~"hi! "]
[03:23:39] <Yurume> sorry, I swapped the arguments ;)
[03:24:03] <Yurume> if it is not `Clone`able, you can use `std::vec::from_fn` instead (with a closure that constructs the value).
[03:24:22] <Yurume> vince: did it help?
[03:24:53] *** Quits: gwty (gwtypc@77D2A3.3F98A9B1.CF29F6CE.IP) (Ping timeout)
[03:26:31] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[03:26:49] <mcpherrin> rusti: std::iter::range(0, 10).collect()
[03:26:52] -rusti- pastebinned 6 lines of output: http://ix.io/9Th
[03:27:03] <mcpherrin> rusti: std::iter::range(0u8, 10).collect()
[03:27:05] -rusti- pastebinned 6 lines of output: http://ix.io/9Ti
[03:27:31] <mcpherrin> rusti: let v: ~[u8] = std::iter::range(0u8, 10).collect(); v
[03:27:32] -rusti- ~[0u8, 1u8, 2u8, 3u8, 4u8, 5u8, 6u8, 7u8, 8u8, 9u8]
[03:27:40] <_achin> oh neat, rusti is back!
[03:27:55] <mcpherrin> rusti: let v: ~[u8] = std::iter::range(0u8, 10).map(|x| 3u8).collect(); v
[03:27:57] -rusti- <anon>:10:55: 10:56 warning: unused variable: `x`, #[warn(unused_variable)] on by default
[03:27:57] -rusti- <anon>:10         let v: ~[u8] = std::iter::range(0u8, 10).map(|x| 3u8).collect(); v
[03:27:57] -rusti-                                                                 ^
[03:27:57] -rusti- ~[3u8, 3u8, 3u8, 3u8, 3u8, 3u8, 3u8, 3u8, 3u8, 3u8]
[03:29:26] *** Joins: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net)
[03:29:46] *** Joins: Skif (emschwar@moz-4C5BB5A8.beyondbb.com)
[03:31:32] *** Quits: Skif (emschwar@moz-4C5BB5A8.beyondbb.com) (Ping timeout)
[03:31:47] *** Joins: int3_ (int3_@B9C75F30.B8DE573D.EC6C369A.IP)
[03:33:36] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[03:35:01] *** Joins: tikue (tkuehn@moz-879E86A9.hsd1.ca.comcast.net)
[03:35:31] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: userns!)
[03:35:37] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[03:36:19] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[03:36:26] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[03:36:30] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[03:37:08] <rdn> How do i install the 'rust' binary?  After compiling and make install, rustc, rustdoc and rustpkg were installed but not 'rust'
[03:37:39] <strcat> there's no such thing anymore
[03:37:43] <strcat> was removed
[03:38:06] <rdn> Is the functionality of 'rust run' available elsewhere
[03:38:35] <milesrout> Yurume: just segfaulted g++ trying to do that competition. 
[03:39:14] <strcat> rdn: rustc foo.rs && ./foo, could make an alias
[03:39:21] *** Quits: jmgrosen (jmgrosen@moz-8C649C07.cs.ucsb.edu) (Quit: jmgrosen)
[03:39:22] <rdn> yea just did, thanks
[03:39:27] <ChrisMorgan> rdn: `rust run x.rs` was just about exactly equivalent to `rustc x.rs -O x~ && ./x~`
[03:39:35] <ChrisMorgan> s/-O/-o/
[03:40:22] *** Quits: logicalparadox (logicalpar@7726D6BC.E47643E6.AF265B38.IP) (Client exited)
[03:41:40] *** Joins: omegaga_ (omegaga_@1A5BA262.25165A39.3F03179E.IP)
[03:42:16] *** Joins: jmgrosen (jmgrosen@moz-8C649C07.cs.ucsb.edu)
[03:42:25] *** Quits: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net) (Ping timeout)
[03:42:26] <SiegeLord> There will need to be a replacement made at some point, but there's already an issue for it
[03:42:47] *** Joins: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net)
[03:43:49] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[03:45:38] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[03:48:00] <danikar> Can a borrowed pointer every change the original data?
[03:48:00] *** sam113101 is now known as sam113101_afk
[03:48:05] <danikar> ever*
[03:49:21] <strcat> danikar: & is guaranteed to point at immutable data, can't change it through the reference or externally
[03:49:23] <strcat> &mut certainly can
[03:50:12] <strcat> and types that aren't Freeze can use unsafe code to break the rules (but nearly everything is Freeze)
[03:50:15] <danikar> ah there we go, i just got learned.
[03:54:09] *** Quits: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net) (Ping timeout)
[03:54:10] *** Quits: a_m0d (a_m0d@moz-322A4DE4.acanac.net) (Quit: Leaving.)
[03:54:36] *** Joins: frogaincia (Mibbit@moz-93A5CBFD.hawaii.res.rr.com)
[03:55:35] *** Joins: syatchmenoff (samy@moz-AB5B740D.hsd1.or.comcast.net)
[03:56:34] *** Joins: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net)
[03:57:41] <egghead> do other languages have an explicit notion of 'lifetimes' or 'ownership' like rust has?
[03:58:47] <dbaupp> egghead: I think Cyclone (a research language) has/had something similar to lifetimes
[03:59:12] *** Quits: syatchmenoff (samy@moz-AB5B740D.hsd1.or.comcast.net) (Quit: syatchmenoff)
[04:00:18] *** Joins: syatchmenoff (samy@moz-AB5B740D.hsd1.or.comcast.net)
[04:01:35] *** Quits: rattboi (bkanyid@moz-9A5A7AF8.org) (Ping timeout)
[04:01:36] <bjz> egghead: MLkit was one of the first I think
[04:01:51] <bjz> also DDC I believe
[04:02:16] <egghead> i'm still learning rust, but it's definitely my largest hang-up since I have no frame of reference in any other language i've used
[04:02:23] <bjz> yeah
[04:03:15] <bjz> once you wrap your head around it it's pretty simple - but learning a new concept is always tricky at first
[04:03:26] <aatch> As far as I know, Rust is the first industry language with a proper region system.
[04:03:28] <egghead> it's kind of frustrating because the idea is so simple, but so much of what I write seems to be too ambiguous for the compiler :p
[04:03:30] *** Joins: lucian (lucian@moz-8408FDFA.cable.virginm.net)
[04:03:39] *** Joins: rattboi (bkanyid@moz-9A5A7AF8.org)
[04:03:42] <egghead> and the fact that it's ambiguous makes me think that my understanding still needs work :)
[04:03:43] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Client exited)
[04:03:59] <aatch> egghead, how much C/C++ do you know?
[04:04:02] *** Joins: watt (bzlandfill@moz-87236390.nycmny.east.verizon.net)
[04:04:04] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[04:04:04] <strcat> egghead: in C or C++ you do have to think about it
[04:04:11] <strcat> the compiler just doesn't verify your assumptions at all
[04:04:50] <aatch> Though modern C/C++ compilers will warn in simple cases (like returning a pointer to a local variable)
[04:04:54] <egghead> small amounts of c, nothing non-trivial but small programs and some use of valgrind :p
[04:05:13] *** Quits: lucian (lucian@moz-8408FDFA.cable.virginm.net) (Ping timeout)
[04:05:22] <strcat> the tricky part being that valgrind will only catch a subset of problems ;p
[04:05:36] *** Quits: syatchmenoff (samy@moz-AB5B740D.hsd1.or.comcast.net) (Quit: syatchmenoff)
[04:05:39] <egghead> I actually have a particular case I haven't been able to solve, I was working with the linked list from the tutorial, and I wanted to implement 'tail' in a way that didn't move ownership of the input
[04:05:41] <strcat> the compiler optimizes based on the assumption that there's no undef behavior too
[04:05:52] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Ping timeout)
[04:06:05] <egghead> I implemented it here: https://gist.github.com/eggsby/8428866 with a type signature I don't like :p
[04:06:07] <watt> hi, is it possible to execute bash shell command in rust?
[04:06:23] <egghead> lines 19-24... how would I implement that without moving ownership?
[04:06:25] <dbaupp> watt: yes, std::run
[04:06:38] <dbaupp> watt: http://static.rust-lang.org/doc/master/std/run/index.html
[04:07:12] <watt> so i guess i can run it in try catch block and catch the error as well?
[04:07:21] <egghead> I imagine the type signature would be something like: fn cdr<T>(xs: &List<T>) -> &List<T> 
[04:07:39] <aatch> egghead, `fn cdr<'r,T>(cs: &'r List<T>) -> &'r List<T>`
[04:07:53] <aatch> The `'r` is a lifetime
[04:08:02] *** Quits: omegaga_ (omegaga_@1A5BA262.25165A39.3F03179E.IP) (Client exited)
[04:08:12] <aatch> like type parameters, the name isn't meaningful (just the single-quote)
[04:08:32] <egghead> thanks aatch I will go read up more on lifetimes in that sense, I didn't know they were entities
[04:08:33] *** Joins: omegaga_ (omegaga_@1A5BA262.25165A39.3F03179E.IP)
[04:08:38] <egghead> I thought it was just a notion in the compiler
[04:08:44] <dbaupp> watt: what error?
[04:09:17] <watt> if i need to capture the error that might come from runing bash commands.
[04:09:30] <watt> and retry etc.
[04:09:32] <dbaupp> ah, that's the return value of the functions for running it
[04:09:37] *** Joins: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP)
[04:09:46] <dbaupp> no exceptions in Rust
[04:09:48] <aatch> What it does there, is say "if you give me a reference to a list that lasts for `'r`, I'll give you a reference to a list that lasts for the same amount of time"
[04:10:16] *** Quits: omegaga_ (omegaga_@1A5BA262.25165A39.3F03179E.IP) (Ping timeout)
[04:10:19] <watt> dbaupp no exceptions in rust?
[04:10:21] <tikue> and usually it's a reference to the same list but not necessarily :P
[04:10:47] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[04:11:31] <dbaupp> watt: yes
[04:11:34] <dbaupp> no exceptions
[04:11:47] <dbaupp> there is unwinding, but they are only catchable at task/thread boundaries
[04:12:06] *** Quits: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net) (Ping timeout)
[04:12:12] <aatch> No worrying about exception safety!
[04:12:17] <dbaupp> i.e. there's not a direct equivalent to `try { foo() } catch(Blah a) { bar(a) }`
[04:12:35] <strcat> aatch: well to some extent you do have to
[04:12:51] <strcat> in unsafe code
[04:12:53] <aatch> strcat, not to nearly the same level though.
[04:12:55] *** Joins: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net)
[04:13:11] <dbaupp> strcat: you have to worry about everything in unsafe code ;P
[04:13:32] *** Joins: omegaga_ (omegaga_@1A5BA262.25165A39.3F03179E.IP)
[04:13:50] <watt> is there an example where i can follow how to execute the run?
[04:14:25] *** Joins: jared (jared@moz-6F2FB2EE.ceng.calpoly.edu)
[04:14:40] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[04:14:52] <watt> i extern mode std and have std:run("ls");  but i got unresolved name `std::run`.
[04:15:02] <dbaupp> rusti: std::run::process_output("echo", &[~"hi"])
[04:15:07] -rusti- timeout triggered!
[04:15:12] <jared> I just built Rust on a mac remotely and want to copy it to my local machine, what files do I need to keep around? The binaries in stage2, the rt or rustllvm folders maybe?
[04:15:13] <dbaupp> watt: the function isn't std::run, that's just the module
[04:15:28] <dbaupp> watt: see the documentation I linked you for the functions inside std::run that you can use :)
[04:15:38] <dbaupp> rusti: std::run::process_output("echo", &[~"hi"])
[04:15:38] *** Joins: exobit (foo@moz-90D1B547.nycmny.fios.verizon.net)
[04:15:43] -rusti- timeout triggered!
[04:15:53] <dbaupp> rusti: std::run::process_output("ls", &[])
[04:15:59] -rusti- timeout triggered!
[04:16:02] <watt> this is what i got: mismatched types: expected `()` but found `std::option::Option<std::run::ProcessOutput>` (expected () but found enum std::option::Option)
[04:16:15] <watt> from mismatched types: expected `()` but found `std::option::Option<std::run::ProcessOutput>` (expected () but found enum std::option::Option)
[04:16:23] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[04:16:28] <dbaupp> watt: http://static.rust-lang.org/doc/master/std/run/fn.process_output.html
[04:16:42] *** Quits: mleise (marco@moz-850E56A9.pools.arcor-ip.net) (Quit: Leaving.)
[04:16:47] *** Quits: paulproteus (quassel@rose.makesad.us) (Ping timeout)
[04:16:52] *** Joins: paulproteus (quassel@moz-E86A3B42.makesad.us)
[04:16:56] <dbaupp> it has a return value based on what the process spawning does
[04:18:57] <danikar> how would you do equiv of "struct node { node *par, node *left, node *right, int value }" in rust? I tried using Option<~Node> but I dont think thats right since a node would be owned by its parent and both children. Do I have to use @Node?
[04:19:32] *** Quits: int3_ (int3_@B9C75F30.B8DE573D.EC6C369A.IP) (Client exited)
[04:19:50] <watt> got to look at spawning then.
[04:21:00] <nightpool> daniker, use a ~ for the child node, and a & for the parent?
[04:21:57] <danikar> nightpool, I thought that there could only be one & for each ~? Wouldn't there be 2 in this case?
[04:22:17] <nightpool> No, you can have any number of references to an object
[04:22:19] <dbaupp> watt: https://gist.github.com/huonw/a24caf20caaeb0b1467e
[04:22:32] <dbaupp> (I haven't actually compiled that...)
[04:23:14] <nightpool> ~ means owned, and that's exactly what it sounds like. This object owns and manages the one its pointing to. & is a reference, which is more like a traditional pointer, in that it can point to any other object. 
[04:23:25] <nightpool> But is non-nullable
[04:23:29] <nightpool> and immutable by default.
[04:23:33] *** Quits: jmgrosen (jmgrosen@moz-8C649C07.cs.ucsb.edu) (Quit: jmgrosen)
[04:23:53] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Connection reset by peer)
[04:24:05] <dbaupp> nightpool: can't use & for parent pointers
[04:24:16] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzz)
[04:24:33] <dbaupp> taking a & will freeze the parent (and anything it owns, like the children), so you can't actually put the & into the child
[04:24:34] <watt> thanks dbaupp
[04:24:34] <nightpool> Why?
[04:24:47] <dbaupp> (or, depending when you take the reference, you can't put the child into the parent)
[04:24:57] *** Joins: gverilla__ (gverilla@moz-B5078950.versanet.de)
[04:24:58] *** Quits: dmac (Adium@moz-99EF2EE6.hfc.comcastbusiness.net) (Quit: Leaving.)
[04:25:15] *** sam113101_afk is now known as sam113101
[04:25:29] *** Joins: dmac (Adium@moz-99EF2EE6.hfc.comcastbusiness.net)
[04:25:41] <dbaupp> the canonical way to do parent pointers is via std::rc using Rc for the "main" links and Weak pointers for the parent ones
[04:25:52] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[04:25:56] *** Quits: gverilla_ (gverilla@moz-BE02EED5.versanet.de) (Ping timeout)
[04:26:05] <dbaupp> or to use raw pointers (requires more care than just Rc + Weak)
[04:26:15] *** Quits: jared (jared@moz-6F2FB2EE.ceng.calpoly.edu) (Quit: WeeChat 0.4.2)
[04:26:34] <dbaupp> danikar: ^
[04:27:03] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[04:27:12] <nightpool> Fair enough. I'm pretty new at this myself. 
[04:28:20] <danikar> Is @ the same thing as rc?
[04:28:37] <dbaupp> kinda, but not really
[04:28:42] *** Quits: watt (bzlandfill@moz-87236390.nycmny.east.verizon.net) (Quit: CGI:IRC)
[04:28:48] <dbaupp> @ is the deprecated form of std::gc::Gc
[04:28:52] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[04:28:54] <danikar> ah
[04:28:55] <dbaupp> i.e. it's mean to be garbage collected
[04:29:15] <dbaupp> however, the current implementation is just reference counting, with cycles being cleaned-up on task death
[04:29:45] <danikar> To do raw pointers you have to do the "unsafe" thing, right?
[04:29:58] <dbaupp> (std::gc::Gc is actually just a wrapper around @ for now, but will be properly GC'd in future)
[04:30:00] <dbaupp> yes
[04:30:26] *** Joins: Skif (emschwar@moz-4C5BB5A8.beyondbb.com)
[04:30:40] <danikar> I assume you have to manually deallocate stuff too if you do that?
[04:30:46] <TheHydroImpulse> dbaupp is the GC still being worked on? 
[04:30:49] <dbaupp> depends how you do it
[04:31:02] <dbaupp> TheHydroImpulse: https://github.com/mozilla/rust/pull/11399
[04:31:04] <FliPPeh> Wouldn't Rc be closer to @ than Gc is?
[04:31:21] <Tobba> currently @ just reference counts
[04:31:24] <Tobba> I think
[04:31:44] <aatch> danikar, you can implement the `Drop` trait for destructors.
[04:31:45] <dbaupp> FliPPeh: current implementation details, yes, @ is Rc; theorical goal, @ is Gc.
[04:32:08] *** Quits: Skif (emschwar@moz-4C5BB5A8.beyondbb.com) (Ping timeout)
[04:32:10] <dbaupp> danikar: the unsafe pointers would just be "references" that the compiler doesn't try to free
[04:32:13] <dbaupp> *freeze
[04:32:14] *** Joins: gwty (gwtypc@77D2A3.3F98A9B1.CF29F6CE.IP)
[04:32:16] <dbaupp> :/
[04:32:28] <aatch> Meaning you can free memory there, if you know it's safe to do so.
[04:32:34] <tikue> is there a canonical example of a doubly linked list implemented with raw pointers?
[04:32:36] <Tobba> if I have structures that cross reference eachother, whats the appropriate way to set up lifetimes?
[04:32:43] <strcat> tikue: in the stdlib
[04:32:46] <dbaupp> danikar: so you'd allocate the tree with ~ as normal, and then take a reference to the parent, cast to *, and put that in the child
[04:32:50] <tikue> strcat: ooh, great thank you
[04:32:56] <strcat> tikue: can also write one with safe code, using Rc/Weak
[04:32:59] *** Joins: alisdair (textual@28441AAB.AC6E1995.F0AE27BD.IP)
[04:33:13] <tikue> strcat: right, I'm just thinking of the most performant way to do it
[04:33:22] <dbaupp> danikar: (however, you have to make sure the parent doesn't move in memory so that the * parent pointer is always valid. You can achieve this by making every node ~ allocated, even the root one.)
[04:33:27] <strcat> tikue: well... most performant
[04:33:32] <strcat> would be an intrusive doubly-linked list
[04:33:36] <strcat> no allocation as part of the container
[04:33:37] <danikar> dbaupp, thanks. im going to  have to read more about how all this works.
[04:33:48] <tikue> strcat: what is intrusive?
[04:34:10] <strcat> tikue: http://www.boost.org/doc/libs/1_55_0/doc/html/intrusive.html lots of docs there
[04:34:19] <tikue> strcat: cool, thanks
[04:34:32] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Quit: Leaving...)
[04:34:50] <strcat> tikue: intrusive data structures get threaded through existing values
[04:34:57] <strcat> so you can thread multiple containers through one value
[04:35:08] <strcat> and you can separate container logic from allocation
[04:35:41] <strcat> i.e. you have 10000 objects, and you can now thread as many lists, sets, maps, etc. through them as you want
[04:35:46] <strcat> no additional allocation required.
[04:35:49] <tikue> so why doesn't rust's doubly-linked list do something like that
[04:36:01] <strcat> afaik, you can't expose a safe API for this in rust
[04:36:05] <tikue> ah
[04:36:18] <strcat> it's very important though
[04:36:27] <strcat> the linux kernel uses it *heavily* and lots of video games do too
[04:36:42] <tikue> is it something that rust could support? (i still don't understand the concept at all :)
[04:36:44] *** sam113101 is now known as sam113101_afk
[04:36:56] <strcat> tikue: well afaik rust can't have a safe API for it.... so not really
[04:37:01] <strcat> you'd have pervasive unsafe code everywhere
[04:37:06] <tikue> that's unfortunate
[04:37:38] <dbaupp> is it even possible to have a safety scheme in which (arbitrary) intrusive data structures are safe?
[04:37:45] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[04:38:00] <strcat> dbaupp: well you can certainly write safe code easily in their presence
[04:38:18] <strcat> they don't really make life harder compared to a non-intrusive container, in C
[04:38:21] *** Quits: sehugg (sehugg@moz-42540923.res.bhn.net) (Client exited)
[04:38:26] <strcat> they give you more rope to hang yourself with
[04:38:32] <dbaupp> strcat: yes, expose a safe API, but actually implementing the details of the intrusive structure seems compulsarily unsafe
[04:38:41] <strcat> dbaupp: no I don't think you can expose a safe API
[04:38:48] <strcat> as in rust memory safe
[04:38:58] <strcat> by 'safe' in that sentence I meant correct, memory-safe code
[04:39:01] <strcat> not enforced by the compiler
[04:39:47] <dbaupp> right, but you *can* write memory-safe code in C++ too, so saying it's possible doesn't mean much :P
[04:40:49] <strcat> I'm just saying that AFAIK, rust's safety model will not work anymore when you want to use intrusive data structures
[04:41:06] *** Quits: maxli (maxli@moz-EE42E0E.student.cs.uwaterloo.ca) (Quit: Leaving.)
[04:41:19] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[04:41:31] *** Quits: dmac (Adium@moz-99EF2EE6.hfc.comcastbusiness.net) (Quit: Leaving.)
[04:41:53] <strcat> so if you have objects you want to put in multiple containers, C/C++ will work much better than rust - unless you make nearly the whole program unsafe
[04:41:53] <tikue> that's interesting because it's basically the first i'm hearing of a performance cost to safety
[04:42:03] <strcat> in rust you'd need multiple containers doing allocation *and* the objects need to be refcounted
[04:42:06] <strcat> or gc'ed
[04:42:26] *** Joins: int3_ (int3_@B9C75F30.B8DE573D.EC6C369A.IP)
[04:42:31] <strcat> where in C the objects can be anywhere (on the stack, in a vector, whatever) and the containers don't need to allocate
[04:42:39] <strcat> tikue: there are other costs like this
[04:42:42] <tiffany> I've been using C++ lately, it makes me appreciate rust's safety features
[04:42:46] *** Quits: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net) (Ping timeout)
[04:42:48] <strcat> I mean a simple one is bounds checking
[04:42:59] <tikue> true
[04:43:04] <nightpool> It seems its about as inherently unsafe as a doubly-linked list, right? As far as I understand, the major difference is that it just puts the list pointers in the struct itself, right?
[04:43:06] <strcat> and the aliasing rules for pointers and moves prevent a lot of stuff
[04:43:14] *** Joins: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net)
[04:43:27] <strcat> nightpool: you can expose a safe API for a doubly-linked list that's not intrusive
[04:43:34] <strcat> AFAIK, you can't expose a safe API for one that's intrusive
[04:43:46] <strcat> nightpool: that's a very major difference
[04:43:55] *** Quits: ptc (Adium@moz-192425C4.nyc.res.rr.com) (Quit: Leaving.)
[04:43:59] <strcat> it means one object can add the hooks necessary to be in a dozen containers
[04:44:04] <strcat> and those containers require no allocation
[04:44:09] <strcat> the objects manage the containers
[04:44:12] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[04:44:38] *** Quits: omegaga_ (omegaga_@1A5BA262.25165A39.3F03179E.IP) (Client exited)
[04:45:05] *** Joins: omegaga_ (omegaga_@1A5BA262.25165A39.3F03179E.IP)
[04:45:32] <strcat> tikue: it's just that most of the time, your unsafe code can be isolated to the inner loop
[04:45:41] <strcat> but when you're talking about something like how you do containers across the entire program
[04:45:46] <strcat> that's not going to work
[04:45:48] <tikue> true
[04:46:01] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[04:46:02] <nightpool> Well, I'm still reading about them. What's the problem with having a base class that implements it, once struct inheritance works?
[04:46:19] *** Joins: espindola (espindola@3AA6F601.53AE8582.A535BD55.IP)
[04:46:27] <strcat> nightpool: because how do you put your struct in multiple containers?
[04:46:50] <strcat> multiple inheritance and phantom type parameters? we won't be getting multiple inheritance ;p
[04:46:53] *** Quits: omegaga_ (omegaga_@1A5BA262.25165A39.3F03179E.IP) (Ping timeout)
[04:47:10] *** Quits: csherratt (csherratt@moz-8D848271.cpe.teksavvy.com) (Ping timeout)
[04:48:05] *** Joins: csherratt (csherratt@moz-8D848271.cpe.teksavvy.com)
[04:49:33] *** Parts: milesrout (user@moz-7A0A3412.cable.telstraclear.net) (ERC Version 5.3 (IRC client for Emacs))
[04:49:52] <nightpool> Hmm.. with an intrusive container, how do you put your object in multiple containers anyway? I can see like a list and a map, but how do you manage multiple lists?
[04:50:01] *** Joins: Cevn (sameer@moz-F316C21E.hr.hr.cox.net)
[04:50:18] <strcat> nightpool: you put an object in a container by adding a field with the data it needs
[04:50:26] <strcat> you put it in multiple containers by adding more than one field
[04:50:35] <strcat> that's most of the point of an intrusive container
[04:50:50] <nightpool> Just list_fields_1, list_fields_2 kinda thing?
[04:50:52] <strcat> the other half of the picture is that now the container no longer needs to allocate
[04:50:55] <strcat> nightpool: yes
[04:50:59] <nightpool> That's what I was asking
[04:51:03] <strcat> nightpool: look at Boost.Intrusive
[04:51:09] <nightpool> I am
[04:51:33] <nightpool> So, ahead of time, you need to decide how many lists your struct is going to be in?
[04:51:36] *** Joins: willingc (willingc@moz-B4760708.san.res.rr.com)
[04:51:42] <strcat> nightpool: yes
[04:51:48] <strcat> the objects manage the containers
[04:51:59] <strcat> it's a performance-centric way of designing
[04:52:03] <nightpool> right, right. 
[04:52:24] <strcat> your object ends up aware of all the containers it's in and then the object removes itself from the containers when you want to get rid of it
[04:52:34] *** Quits: canhtak (canhtak@moz-4B5B3414.wl.t.ulaval.ca) (Quit: canhtak)
[04:52:49] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[04:52:53] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[04:53:07] <strcat> and a linked container is entirely implemented within the objects in it - no extra allocations necessary, for a list, rbtree, etc.
[04:53:25] *** Joins: hoverbear (hoverbear@moz-86FCBF4B.gv.shawcable.net)
[04:54:28] <nightpool> Okay, I think I get it now. 
[04:54:30] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[04:54:58] <nightpool> You design your object around the data structures its going to be used in, rather then the other way around.
[04:55:41] <strcat> yeah, because otherwise your object ends up needing to be refcounted, with all the containers holding refs
[04:55:47] <strcat> and the containers also have to allocate their nodes
[04:56:12] *** Joins: aravindavk (aravinda@CD70857E.C436E7A2.D2D1FAF0.IP)
[04:57:14] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[04:59:39] *** Joins: omegaga_ (omegaga_@1A5BA262.25165A39.3F03179E.IP)
[05:00:50] *** Quits: Jesin (Jesin@moz-C1EBF9B4.dept.lehigh.edu) (Quit: Leaving)
[05:02:54] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[05:03:02] *** Joins: ssbr (~ssbr@3FB4C2BC.2E4FD3DD.225F4543.IP)
[05:03:39] <jmgrosen> stupid question, but how do I build rustc in debug mode?
[05:03:49] <jmgrosen> i.e. with all the debug! things turned on
[05:04:06] *** Joins: lucian (lucian@moz-8408FDFA.cable.virginm.net)
[05:04:41] *** Quits: int3_ (int3_@B9C75F30.B8DE573D.EC6C369A.IP) (Client exited)
[05:05:47] *** Quits: lucian (lucian@moz-8408FDFA.cable.virginm.net) (Ping timeout)
[05:06:15] <sfackler> jmgrosen: ./configure --enable-debug
[05:06:26] <jmgrosen> sfackler: thanks
[05:07:35] *** Joins: eddyb (eddy@EDE07015.D51DAF03.FB866788.IP)
[05:07:39] *** Joins: jnsk (Mibbit@moz-D5D4385D.hsd1.ca.comcast.net)
[05:07:51] *** Quits: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net) (Ping timeout)
[05:07:53] *** Joins: hdevalence (quassel@moz-D125A39F.home3.cgocable.net)
[05:09:04] *** Joins: int3_ (int3_@B9C75F30.B8DE573D.EC6C369A.IP)
[05:09:43] *** Joins: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net)
[05:10:08] *** Joins: maxli (maxli@moz-B19F68ED.student.cs.uwaterloo.ca)
[05:11:07] *** Quits: int3_ (int3_@B9C75F30.B8DE573D.EC6C369A.IP) (Client exited)
[05:11:11] *** Quits: kvark (Mibbit@9A8A5739.49975FB2.AE2D72A6.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[05:11:45] *** Quits: omegaga_ (omegaga_@1A5BA262.25165A39.3F03179E.IP) (Client exited)
[05:11:47] *** Joins: int3_ (int3_@B9C75F30.B8DE573D.EC6C369A.IP)
[05:12:14] *** Joins: omegaga_ (omegaga_@1A5BA262.25165A39.3F03179E.IP)
[05:12:30] *** Quits: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net) (Ping timeout)
[05:12:53] *** Joins: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net)
[05:13:55] *** Quits: omegaga_ (omegaga_@1A5BA262.25165A39.3F03179E.IP) (Ping timeout)
[05:14:17] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[05:14:32] *** Quits: frogaincia (Mibbit@moz-93A5CBFD.hawaii.res.rr.com) (Quit: http://www.mibbit.com ajax IRC Client)
[05:15:25] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[05:17:08] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[05:19:55] *** sam113101_afk is now known as sam113101
[05:21:13] *** Quits: int3_ (int3_@B9C75F30.B8DE573D.EC6C369A.IP) (Client exited)
[05:21:34] *** Joins: int3_ (int3_@B9C75F30.B8DE573D.EC6C369A.IP)
[05:23:30] *** Quits: int3_ (int3_@B9C75F30.B8DE573D.EC6C369A.IP) (Ping timeout)
[05:23:39] <Tobba> I'm trying to do something like let vas: &mut VAS = ~VAS::new(); kernel_vas = Some(vas);
[05:23:46] <Tobba> (kernel_vas is a static)
[05:24:02] <Tobba> it complains that vas doesent live long enough though, shouldent moving sort that out?
[05:25:22] *** Joins: Jesin (Jesin@moz-A43618DF.res.lehigh.edu)
[05:25:38] <tikue> Tobba: try &'static mut VAS maybe
[05:25:55] <tikue> not sure if that'll work
[05:26:08] <Tobba> it didnt
[05:26:34] <tikue> what is the type of kernel_vas
[05:26:39] *** Quits: hdevalence (quassel@moz-D125A39F.home3.cgocable.net) (Ping timeout)
[05:26:47] <Tobba> static mut kernel_vas: Option<&'static mut VAS<'static>> = None;
[05:27:06] *** Quits: brson (brson@981AA104.E81F12CD.76F66111.IP) (Ping timeout)
[05:27:24] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[05:27:54] <tikue> and you tried let vas = &'static mut VAS::new(); kernel_vas = Some(vas); ?
[05:28:08] <Tobba> nope
[05:28:12] <Tobba> I realized a problem with that anyways
[05:28:23] <Tobba> I have to move back to my old method, ugh
[05:28:26] <tikue> ah
[05:29:07] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[05:29:11] *** Joins: ricepuddin (graham@moz-7D68765A.cable.virginm.net)
[05:30:19] <Tobba> there we go, think I fixed it
[05:30:29] <darkf> hrm is there a replacement for &str's iter()?
[05:31:16] *** Joins: Skif (emschwar@1D51076D.3C9CEEF4.5A098C94.IP)
[05:32:28] *** Quits: ssbr (~ssbr@3FB4C2BC.2E4FD3DD.225F4543.IP) (Ping timeout)
[05:33:01] *** Quits: Skif (emschwar@1D51076D.3C9CEEF4.5A098C94.IP) (Ping timeout)
[05:34:44] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Quit: TheHydroImpulse)
[05:36:07] <darkf> ah, chars() seems to exist
[05:36:44] *** Quits: exobit (foo@moz-90D1B547.nycmny.fios.verizon.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz)
[05:37:06] *** Quits: ktt3ja (ktt3ja@moz-515C1363.hsd1.va.comcast.net) (Quit: Leaving)
[05:42:01] *** Joins: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[05:42:07] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[05:42:28] *** Quits: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net) (Ping timeout)
[05:42:29] *** Quits: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net) (Quit: Leaving.)
[05:42:51] *** Joins: int3_ (int3_@B9C75F30.B8DE573D.EC6C369A.IP)
[05:42:54] *** Joins: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net)
[05:43:32] *** Quits: jdm (jdm@moz-12626D4B.static.videotron.ca) (Quit: Lost terminal)
[05:44:29] *** Joins: ptc (Adium@moz-192425C4.nyc.res.rr.com)
[05:44:36] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[05:46:14] *** Quits: ptc (Adium@moz-192425C4.nyc.res.rr.com) (Ping timeout)
[05:46:26] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[05:46:38] *** Joins: syatchmenoff (samy@moz-AB5B740D.hsd1.or.comcast.net)
[05:48:15] <darkf> is there no mutable Rc<T>
[05:49:12] <eddyb> darkf: Rc<RefCell<T>>
[05:49:23] <eddyb> or Rc<Cell<T>> for T: Pod
[05:51:23] <bascule> http://dwrensha.github.io/capnproto-rust/2014/01/15/benchmark-update.html
[05:51:25] <bascule> :O :O :O
[05:51:29] <bascule> :D :D :D
[05:51:33] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[05:52:02] *** Joins: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[05:52:03] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[05:52:12] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[05:55:18] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[05:55:25] *** Quits: AvianFlu (AvianFlu@moz-51534E77.c3-0.43d-ubr2.qens-43d.ny.cable.rcn.com) (Input/output error)
[05:55:30] <Tobba> pretty cool
[05:56:04] <Tobba> guessing part of the slowdown for rust is also because llvms optimizer is more tuned towards clangs output
[05:56:32] <strcat> doubt it
[05:56:53] <strcat> if you write the same code in rust and C, in my experience the performance is the same
[05:57:01] <strcat> except in *rare* cases where TBAA metadata helps C
[05:57:26] <strcat> if you're using different code (different library, different stdlib types, etc.) in each, then that's no longer a language perf benchmark
[05:57:59] <jmgrosen> another stupid question... once I've compiled with --enable-debug, how do I actually make it show the debug statements? :P
[05:58:58] <Tobba> rustc supports debug info?
[05:59:15] <strcat> Tobba: -Z extra-debug-info, sure
[05:59:27] <Tobba> strcat: wait, what does that do?
[05:59:37] <strcat> outputs debug info
[05:59:50] <strcat> and then gdb will work well
[06:00:00] <Tobba> excellent
[06:00:11] *** Quits: fmtq (fmt@moz-5769BD38.static.tpgi.com.au) (Ping timeout)
[06:00:19] *** Quits: johnsoft (johnsoft@moz-7E09A266.neo.res.rr.com) (Ping timeout)
[06:00:21] *** Joins: johnsoft (johnsoft@moz-7E09A266.neo.res.rr.com)
[06:00:26] *** Quits: willingc (willingc@moz-B4760708.san.res.rr.com) (Client exited)
[06:00:45] <jmgrosen> sfackler: how to actually make it print the debug statements now?
[06:02:45] *** Joins: benjamin__ (benjamin@moz-29766E26.dip0.t-ipconnect.de)
[06:02:48] *** Joins: hdevalence (quassel@moz-D125A39F.home3.cgocable.net)
[06:03:40] *** Joins: m_kato (m_kato@moz-C286AD9A.bitcat.net)
[06:04:06] *** Joins: willingc (willingc@moz-B4760708.san.res.rr.com)
[06:04:51] *** Joins: lucian (lucian@moz-8408FDFA.cable.virginm.net)
[06:05:20] *** Quits: willingc (willingc@moz-B4760708.san.res.rr.com) (Client exited)
[06:05:59] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[06:06:35] *** Quits: lucian (lucian@moz-8408FDFA.cable.virginm.net) (Ping timeout)
[06:06:37] *** Joins: lucian (lucian@moz-8408FDFA.cable.virginm.net)
[06:07:55] *** Joins: carllerche (carllerche@moz-CA3FF5F1.hsd1.or.comcast.net)
[06:08:18] *** Quits: carllerche (carllerche@moz-CA3FF5F1.hsd1.or.comcast.net) (Quit: carllerche)
[06:08:20] *** Quits: lucian (lucian@moz-8408FDFA.cable.virginm.net) (Ping timeout)
[06:08:27] <darkf> hrm, how exactly do you get at the value of Rc<RefCell<T>> then?
[06:08:35] <darkf> rusti: std::rc::Rc::new(std::cell::RefCell::new(1u)).borrow().unwrap()
[06:08:38] -rusti- pastebinned 7 lines of output: http://ix.io/9Tp
[06:08:52] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[06:09:46] *** Joins: earlzlap (earlz@moz-483E1E31.neo.res.rr.com)
[06:12:23] *** Quits: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net) (Ping timeout)
[06:12:45] *** Joins: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net)
[06:13:05] *** Joins: twi (Adium@moz-512229A7.lns9.lon.bigpond.net.au)
[06:13:11] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[06:13:13] <sfackler> jmgrosen: RUST_LOG=some_path rustc foo.rs
[06:13:41] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[06:13:42] <sfackler> e.g. RUST_LOG=rustc::middle::privacy=debug rustc foo.rs
[06:13:59] *** Joins: fmtq (fmt@moz-5769BD38.static.tpgi.com.au)
[06:14:07] *** Quits: heftig (heftig@moz-3958C10A.dip0.t-ipconnect.de) (Ping timeout)
[06:14:21] *** Joins: milesrout (user@moz-7A0A3412.cable.telstraclear.net)
[06:15:13] *** Quits: Cevn (sameer@moz-F316C21E.hr.hr.cox.net) (Ping timeout)
[06:15:15] <milesrout> I don't even know how to google for information about what #[start] does, because I don't know what to call it. Is it a macro? Do #[these] #[things] have a name?
[06:15:34] <eddyb> milesrout: attributes
[06:15:54] <milesrout> thanks
[06:15:58] <eddyb> darkf: you can't do it on one line - and I think it's .get() not .unwrap()
[06:17:06] <eddyb> google won't help much with rust fwiw
[06:17:07] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[06:17:07] <milesrout> googling "rust start attribute" got me exactly what I needed actually, :)
[06:17:07] <eddyb> oh, okay, nvm then
[06:17:07] *** Joins: yutongzhao (yutongzhao@moz-325F8282.hsd1.ca.comcast.net)
[06:17:26] <jnsk> hello! i'm following the tutorial here: http://static.rust-lang.org/doc/master/tutorial.html#data-structures
[06:17:36] <jnsk> and I'm wondering what the difference is between that first enum example
[06:17:47] <jnsk> with the Circle and Rectangle
[06:17:54] <jnsk> and having structs in place of those... things
[06:17:56] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[06:18:02] *** Joins: heftig (heftig@moz-6E893B28.dip0.t-ipconnect.de)
[06:18:15] <jnsk> also what are those called (Circle and Rectangle)? a type?
[06:18:40] <eddyb> jnsk: variants
[06:19:01] <jnsk> okay variants thanks
[06:19:04] <eddyb> jnsk: there's one type and two possible variants for it
[06:19:13] <eddyb> a Shape can be either a Circle or Rectangle
[06:19:23] <milesrout> any ideas on the best rust-mode for emacs?
[06:19:36] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzz)
[06:19:54] *** Quits: kini (kini@moz-92AA953A.members.linode.com) (Quit: No Ping reply in 180 seconds.)
[06:19:54] <eddyb> Circle or Rectangle, when called like functions, are actually functions, "constructors" for their specific enum variants
[06:20:08] <jnsk> so what is the purpose of having these variants
[06:20:08] <jnsk> but also having the option of putting a struct as variants?
[06:20:08] <jnsk> don't they serve the same purpose? 
[06:20:09] *** Quits: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[06:20:10] <eddyb> jnsk: struct as a variant?
[06:20:24] *** Quits: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net) (Quit: Leaving.)
[06:20:27] <jnsk> hm I'll try to be more specific
[06:21:31] <jnsk> so we can have an enum like so:
[06:21:31] <eddyb> I think people are confused, enum Foo {A, B} doesn't have anything to do with structs, it's a C enum
[06:21:31] <jnsk> or wait
[06:21:31] <jnsk> I'll pastebin
[06:21:31] <milesrout> oh wow there's one that comes with rust.
[06:21:31] <eddyb> anyways, Circle(center, radius) returns a Shape value which can be later matched to see that it's a Circle and not a Rectangle
[06:21:31] <eddyb> and it contains those two values embedded
[06:21:51] *** Quits: oal (oal@26029749.1D466084.2CFD4520.IP) (Ping timeout)
[06:21:51] *** Quits: qmx (qmx@moz-B6DBCD05.qmx.me) (Ping timeout)
[06:21:51] *** Quits: dbussink (dbussink@moz-E0A5568C.bussink.me) (Ping timeout)
[06:21:51] *** Quits: eagleflo (aku@moz-14928E87.fi) (Ping timeout)
[06:21:51] *** Quits: ash_ (ash@15DEC023.DFC68827.9C33A531.IP) (Ping timeout)
[06:22:20] *** Quits: Amanieu (amanieu@10FEE2FD.ECEF57A4.2CFD4520.IP) (Client exited)
[06:22:20] <jnsk> yes, i understand that part I'm pretty sure
[06:22:20] <jnsk> but I don't know why we need to have struct variants as well
[06:22:20] <jnsk> http://mibpaste.com/7elIy2
[06:22:52] *** Quits: katis (katis@40C8AF65.EFDC2270.EE6E63A5.IP) (Ping timeout)
[06:22:53] *** Quits: busylizzy (lisa@270089DC.4EF5D73F.4E00FFE9.IP) (Ping timeout)
[06:22:53] *** Joins: kini (kini@moz-92AA953A.members.linode.com)
[06:22:53] <strcat> jnsk: enum { A, B(int), C(int, int), D { x: int } }
[06:22:53] <eddyb> stupid mibpaste, load already
[06:22:53] <strcat> corresponds to
[06:22:53] <strcat> struct A
[06:22:53] <strcat> struct B(int)
[06:22:53] <strcat> struct C(int, int)
[06:22:53] <strcat> struct D { x: int }
[06:22:55] <strcat> yeah this mibpaste page doesn't load for me
[06:22:55] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[06:23:01] * geomyidae nods
[06:23:03] <jnsk> grr
[06:23:09] <eddyb> jnsk: use a real pastebin like https://gist.github.ocm
[06:23:27] *** Quits: jpf (jan@moz-A8C26A15.org) (Ping timeout)
[06:23:29] <eddyb> err, that's com at the end
[06:23:29] *** Quits: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net) (Ping timeout)
[06:23:39] <jnsk> okay one sec
[06:23:40] <eddyb> people should stop ping timeouting, it lags my client every join/part and I didn't bother to fix it :P
[06:23:48] <eddyb> (lag as in one second of unresponsiveness)
[06:24:00] <milesrout> strcat: all that then enum { A, B, C, D } you mean?
[06:24:02] <milesrout> or not?
[06:24:17] <eddyb> jnsk: if it's struct A {...}; struct B {...}; enum Foo{A, B}, see my comment above
[06:24:41] <jnsk> https://gist.github.com/anonymous/8450629
[06:24:45] <geomyidae> I don't think it's a syntactical question ;)
[06:24:48] <eddyb> there's no reason why you can't provide an example in less than 20 chars
[06:25:20] <eddyb> jnsk: ah, that. the latter is feature-gated
[06:25:23] <jnsk> I believe those are both valid enums, but I don't see why we need both of them
[06:25:25] *** Joins: Amanieu (amanieu@10FEE2FD.ECEF57A4.2CFD4520.IP)
[06:25:36] <eddyb> jnsk: because one may want to name their fields?
[06:25:47] *** Joins: qmx (qmx@moz-B6DBCD05.qmx.me)
[06:25:49] *** Joins: oal (oal@26029749.1D466084.2CFD4520.IP)
[06:25:50] *** Joins: dbussink (dbussink@moz-E0A5568C.bussink.me)
[06:25:55] *** Joins: ash_ (ash@15DEC023.DFC68827.9C33A531.IP)
[06:25:57] *** Joins: katis (katis@40C8AF65.EFDC2270.EE6E63A5.IP)
[06:25:57] <milesrout> jnsk: for the same reason that Python has named tuples presumably?
[06:25:57] *** Joins: busylizzy (lisa@270089DC.4EF5D73F.4E00FFE9.IP)
[06:26:23] *** Joins: eagleflo (aku@moz-14928E87.fi)
[06:26:26] <jnsk> hmm
[06:26:26] <jnsk> so would that be the only difference?
[06:26:26] <eddyb> mozirc, stop dropping people :(
[06:26:26] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[06:26:26] <geomyidae> oh well, no one is asking the question I'll now ask, when do I use which? maybe it's a similar question
[06:26:28] <jnsk> aside from how they are matched and stoof
[06:26:34] <eddyb> dbaupp made a good point yesterday, that it's sometimes better to use an embedded struct in such cases, since that one you can pass around
[06:26:35] *** Joins: jpf (jan@moz-A8C26A15.org)
[06:26:57] <eddyb> jnsk: even internally, they're just names for those fields. also see what strcat said
[06:27:01] <geomyidae> is there a big storage difference between the two?
[06:27:07] <eddyb> geomyidae: 0
[06:27:11] <geomyidae> ok
[06:27:35] <jnsk> so they're essentially identical, except when we want named fields?
[06:27:45] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[06:27:49] *** Joins: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[06:27:53] <eddyb> jnsk: yeah. keep in mind they're feature gated :/
[06:28:11] <strcat> jnsk: yes it's the same as struct(int, int) vs. struct { x: int, y: int }
[06:28:26] <jnsk> ahaaa I see
[06:28:33] *** Quits: gwty (gwtypc@77D2A3.3F98A9B1.CF29F6CE.IP) (Ping timeout)
[06:28:34] <jnsk> thank you very much :D
[06:28:42] <jnsk> what exactly does feature gated mean?
[06:29:06] <strcat> jnsk: have to enable it via a #[feature(foo)] attribute
[06:29:15] <strcat> struct variant enums are a bit broken atm
[06:29:25] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[06:29:33] <strcat> named struct variant*
[06:29:47] <jnsk> ooh I see
[06:29:56] <jnsk> so they're feature gated because  they're not completely ready for use?
[06:30:03] <strcat> yeah
[06:30:31] <eddyb> the other reason things are feature gated is prepping for removal
[06:30:45] <eddyb> (death to @T)
[06:31:00] <jnsk> haha I don't understand the reference because I'm just starting out, but thanks for the info
[06:31:04] <jnsk> much appreciated
[06:31:28] <eddyb> strcat: oh wow I just looked at the diff stats https://github.com/mozilla/rust/pull/11595/files
[06:31:30] *** Joins: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net)
[06:31:34] <jnsk> I hope it's okay to post random questions like that here
[06:31:48] <eddyb> jnsk: don't worry
[06:31:51] *** Joins: Skif (emschwar@moz-4C5BB5A8.beyondbb.com)
[06:32:33] *** Joins: jviereck (Adium@moz-56DDD13.dip0.t-ipconnect.de)
[06:33:16] <geomyidae> is there a reason for having both?
[06:33:34] *** Quits: Skif (emschwar@moz-4C5BB5A8.beyondbb.com) (Ping timeout)
[06:33:42] <lkuper> eddyb: that's a nice diffstat
[06:34:07] <eddyb> I may have cheated by removing useless newlines
[06:34:54] <strcat> geomyidae: both?
[06:35:26] *** Parts: zq (p@moz-4C4640FD.com) ()
[06:36:34] *** Quits: psquid (psquid@moz-66C8375C.threembb.co.uk) (Ping timeout)
[06:38:08] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[06:38:34] <eddyb> lkuper: so I change a function, I grep for it, find out it's not used outside of that file, remove the "pub" from it, then all arguments fit on one line now, BAM 5 points
[06:38:49] *** Joins: psquid (psquid@moz-A6E6069.threembb.co.uk)
[06:39:27] *** Quits: Tobba (Tobba@moz-462B7F7F.ias.bredband.telia.com) (Ping timeout)
[06:39:35] *** Quits: hoverbear (hoverbear@moz-86FCBF4B.gv.shawcable.net) (Quit: Taking a nap.)
[06:39:47] <lkuper> eddyb: ooh, we should have a lint for needless 'pub'
[06:40:25] <lkuper> although you don't know the programmer's intent; maybe they mean to make use of it elsewhere and just haven't gotten to it yet
[06:40:29] <geomyidae> how could you lint for that?
[06:40:40] <eddyb> lkuper: the problem is that librustc is a... library
[06:42:04] *** Quits: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net) (Ping timeout)
[06:42:09] <eddyb> and any inner pub, wherever it is, is going to be visible to the outside
[06:42:20] *** Joins: canhtak (canhtak@moz-4B5B3414.wl.t.ulaval.ca)
[06:42:47] *** Joins: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net)
[06:43:02] *** Quits: jviereck (Adium@moz-56DDD13.dip0.t-ipconnect.de) (Quit: Leaving.)
[06:43:21] *** Quits: Sharp (Sharp@moz-EEC85237.hsd1.ca.comcast.net) (Ping timeout)
[06:43:48] <eddyb> maybe we should make things like typeck hidden from outside of librustc or something
[06:44:48] <lkuper> maybe, but otoh it'd be cool if there were hooks into various compiler passes
[06:44:49] *** Joins: ptc (Adium@moz-192425C4.nyc.res.rr.com)
[06:45:05] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[06:45:24] <mcpherrin> tmykl/cb
[06:45:26] <mcpherrin> oops
[06:46:06] <lkuper> geomyidae: it seems doable.  we have a lint for dead code.
[06:46:14] *** Quits: santiago (santiago@moz-8ADE82B4.socal.res.rr.com) (Ping timeout)
[06:46:20] *** Joins: Sharp (Sharp@moz-EEC85237.hsd1.ca.comcast.net)
[06:46:37] *** Quits: ptc (Adium@moz-192425C4.nyc.res.rr.com) (Ping timeout)
[06:46:59] *** Quits: yutongzhao (yutongzhao@moz-325F8282.hsd1.ca.comcast.net) (Quit: yutongzhao)
[06:48:47] <jnsk> another question: when would we have to manually write a custom destructor?
[06:48:57] <milesrout> It seems that the optimiser will optimise out dead code, which is odd because I'm writing a library.
[06:49:00] *** Joins: mib_ee8uji (Mibbit@moz-4014DDC7.ga.at.cox.net)
[06:49:00] <Eridius> jnsk: when you need to run code when the value is destructed
[06:49:21] <Eridius> milesrout: externally-visible functions in a library shouldn't be dead code
[06:49:29] <mcpherrin> jnsk: Maybe the thing being destructed is a wrapper around a temporary file that needs deletion, a network socket that needs to be closed, etc
[06:49:38] <Eridius> jnsk: the classic example is a File struct that needs to close() the fd
[06:49:42] <milesrout> Eridius: maybe I'm missing a pub
[06:49:43] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[06:49:51] <strcat> the path has to be fully public
[06:50:32] <strcat> jnsk: if you have a function foo() where someone has to always call a function bar() after, then RAII is a good idiom to use
[06:50:34] <mib_ee8uji> In https://air.mozilla.org/rust-typeclasses/ around 7:00 she says that the example is an inefficient implementation of "not euals," why?
[06:50:39] <strcat> jnsk: for example, locks
[06:50:43] <mib_ee8uji> equals*
[06:50:45] *** Quits: jeaye (jeaye@moz-34FEF2BB.hsd1.ca.comcast.net) (Quit: zzz)
[06:50:50] <strcat> mutex.lock(); foo(); mutex.unlock()
[06:50:53] <strcat> is a bad API
[06:51:04] <mcpherrin> oh boy I love RAII locks
[06:51:05] <strcat> you can forget unlock in a branch, and what if foo unwinds?
[06:51:07] <milesrout> also how come pub unsafe fn works, but unsafe pub fn gives expected 'fn', found 'pub'?
[06:51:10] <strcat> instead
[06:51:16] <strcat> let _guard = mutex.lock(); foo()
[06:51:22] <eddyb> milesrout: pub item;
[06:51:28] <strcat> but you can enforce a lot of invariants that way
[06:51:33] <eddyb> milesrout: item can be a fn or something else. unsafe is part of the item
[06:51:59] <eddyb> this is not C where you can do int long const static x = 0;
[06:52:04] <milesrout> that'll take some getting used to.
[06:52:19] <milesrout> s/not C/not basically every curly brace language and most of the rest/
[06:52:20] <milesrout> :P
[06:52:42] <milesrout> then again enforcing consistency of code is really nice.
[06:52:54] <eddyb> it's much easier to parse visibility and then an item
[06:52:54] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Connection reset by peer)
[06:53:05] <eddyb> rather than parsing visibility in the middle of a function declaration
[06:53:12] *** Quits: syatchmenoff (samy@moz-AB5B740D.hsd1.or.comcast.net) (Quit: syatchmenoff)
[06:53:34] *** Quits: dcrewi (david@moz-AB8667CE.gyrae.net) (Ping timeout)
[06:53:42] <jnsk> oohhhh
[06:53:49] <jnsk> I see so when it leaves the scope the destructor must always be called
[06:53:58] *** Quits: heftig (heftig@moz-6E893B28.dip0.t-ipconnect.de) (Quit: Quitting)
[06:54:13] <jnsk> so bar() is always called after foo()
[06:54:15] *** Joins: syatchmenoff (samy@moz-AB5B740D.hsd1.or.comcast.net)
[06:54:21] <jnsk> since bar() is part of the destructor?
[06:54:30] <eddyb> jnsk: even ~Trait calls the right destructor when it's freed
[06:54:55] <mcpherrin> jnsk: right.  It's a really useful idiom from c++ especially
[06:55:00] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[06:55:08] *** Quits: tikue (tkuehn@moz-879E86A9.hsd1.ca.comcast.net) (Quit: tikue)
[06:55:22] <eddyb> milesrout: (pub|priv)? (unsafe|extern ("ABI")?) fn name // it's simple grammar :)
[06:55:24] *** Joins: mouse (mouse@moz-45757DCA.dhcp.yndx.net)
[06:55:29] <milesrout> Yeah, modern C++11 is practically built around raii.
[06:55:35] <jnsk> I see. eddyb, I have yet to get to traits so I'm not sure what those are :x
[06:55:40] <jnsk> thanks once again
[06:55:49] <milesrout> eddyb: from experience writing compilers and such, simple grammar is indeed nice to have.
[06:56:17] <eddyb> milesrout: that C snippet above - I think I lost a few neurons handling all possibilities in my cparse
[06:56:19] <mcpherrin> eugh yeah the last compiler I wrote had a bunch of bugs from letting the thingies like that be in any order :P
[06:56:38] <eddyb> but hey, it's ES6, I was basically doing monads
[06:57:10] <eddyb> or whatever they were. I was chaining "filter" functions to create a complete type (which is closer to LLVM or Rust types)
[06:57:47] <eddyb> I dread writing that in any other language (maybe Haskell can handle such monstruosity)
[06:57:50] *** Joins: vfetwnuncszu (david@moz-AB8667CE.gyrae.net)
[06:58:02] *** Quits: mouse (mouse@moz-45757DCA.dhcp.yndx.net) (Ping timeout)
[06:58:06] *** vfetwnuncszu is now known as dcrewi
[06:58:21] <milesrout> That's rather.. interesting.
[06:58:26] <milesrout> Haskell can handle anything! :P
[06:58:37] <eddyb> but then you can't read your own code
[06:58:49] <milesrout> You can if you know Haskell.
[06:58:58] *** Quits: espindola (espindola@3AA6F601.53AE8582.A535BD55.IP) (Input/output error)
[06:59:02] <eddyb> and if you have certain memorized patterns
[07:00:09] <eddyb> but really, the "dirty" functional style, like in ES6, much easier to understand from scratch
[07:00:27] *** Quits: Sharp (Sharp@moz-EEC85237.hsd1.ca.comcast.net) (Ping timeout)
[07:00:31] *** Joins: espindola (espindola@3AA6F601.53AE8582.A535BD55.IP)
[07:00:32] *** Quits: maxli (maxli@moz-B19F68ED.student.cs.uwaterloo.ca) (Quit: Leaving.)
[07:00:49] <eddyb> with unboxed closures, Rust gets pretty close to the functional manuevreability of ES6, heck, it can beat it :D
[07:00:58] <eddyb> jnsk: an unique pointer that "forgot" its original type and only exposes an "interface" (a trait's methods) through a vtable. though ~T and traits might be both ahead of you
[07:01:03] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[07:01:11] <milesrout> Yeah but the whole point of Haskell is that it's pure.
[07:01:31] <eddyb> pure makes some things easier to reason about
[07:01:38] <jnsk> yea haha I'm still not very far
[07:01:50] <jnsk> I may have found something in the tutorial though
[07:02:03] <milesrout> xmonad is a tiling wm written in Haskell. I personally use dwm instead, but if I was capable of understanding Haskell instead of just-barely-capable-of-reading-it-with-constant-references-to-tutorials-a-reference-and-irc, I'd probably use xmonad. :P
[07:02:05] <eddyb> and others become exponentially large hanoi towers to play with in your brain
[07:02:21] <jnsk> In the ownership section, it talks about a "Send" trait, and when I looked it up online, I found this: https://github.com/mozilla/rust/issues/3542
[07:02:40] <jnsk> From the page, it looks like the send trait is no longer around. Is that correct?
[07:02:47] <strcat> it's still around
[07:02:50] <eddyb> jnsk: master std docs are the best thing to search
[07:02:56] <mcpherrin> haha, I implemented a portion of a haskellish interpreter (lazy, hindley milnder, algabraic types)
[07:02:59] <eddyb> google doesn't do much for rust
[07:03:01] <mcpherrin> but I still can't program in haskell :P
[07:03:14] <eddyb> I read a haskell book out of boredom
[07:03:48] <eddyb> and I understand its strong points. but I really can't deal with the complexity crapstorm
[07:04:18] <milesrout> offtopic: oh jesus I have no idea how to use ld
[07:04:29] *** Joins: maxli (maxli@moz-B19F68ED.student.cs.uwaterloo.ca)
[07:04:38] <eddyb> milesrout: why do you need to touch the linker?
[07:05:00] *** Quits: maxli (maxli@moz-B19F68ED.student.cs.uwaterloo.ca) (Quit: Leaving.)
[07:05:04] <milesrout> eddyb: because I'm cross-compiling to bare metal. 
[07:05:15] <eddyb> gcc and clang can link object files, assemble .S (and .ll/.bc, clang-only) etc.
[07:05:23] <eddyb> milesrout: oh you need a linker script?
[07:05:40] <milesrout> Yeah, I'm currently trying to fathom how linker scripts work haha
[07:05:44] <eddyb> milesrout: check out some #rust-osdev projects, you can steal some of the magic from there
[07:05:59] <mcpherrin> milesrout: haha I think the first time I wrote a linker script, it took me days to make it work
[07:06:02] <jnsk> I'm just going to skip over the Send trait part and continue, because it doesn't seem important to the ownership topic haha
[07:06:36] <eddyb> jnsk: it represents types that can be safely sent across tasks
[07:06:46] <eddyb> or threads, or any concurrency primitive you'd like
[07:07:06] *** Quits: mib_ee8uji (Mibbit@moz-4014DDC7.ga.at.cox.net) (Quit: http://www.mibbit.com ajax IRC Client)
[07:07:12] <milesrout> eddyb: I will definitely do that. Thanks. mcpherrin: I'm beginning to appreciate that feeling.
[07:07:22] *** Joins: lucian (lucian@moz-8408FDFA.cable.virginm.net)
[07:07:35] <eddyb> - about that Haskell thing - maybe our children will learn Idris from age 12, but I barely can handle librustc - imagine if it were written in Haskell
[07:07:38] <mcpherrin> milesrout: I've got some experience with linker scripts so feel free to ping here or in -osdev with questions
[07:07:57] <milesrout> mcpherrin: thanks, I will do when I work out what exactly I want to do with it haha
[07:08:17] *** Joins: bheylin_ (brianheyli@moz-8255E94E.adsl.online.nl)
[07:08:30] <eddyb> jnsk: ~T is Send because you lose ownership when you send it. Rc<T> can have multiple "handles" pointing at the same ref-counted box, but it's not designed to be owned by multiple tasks, so it's not Send
[07:09:07] *** Quits: lucian (lucian@moz-8408FDFA.cable.virginm.net) (Ping timeout)
[07:09:26] <jnsk> I uhh think I see
[07:09:29] <eddyb> jnsk: Arc, however, is atomic, thus safe to have handles to the same Arc ref-counted box even in multiple physical cores so it's Send
[07:10:06] <jnsk> I actually have yet to get to boxes and traits
[07:10:26] <jnsk> I'll come back once I've read ahead a little
[07:10:48] <eddyb> it's a kind so it bubbles up and you can constrain a trait object to only wrap certain kinds - like ~Trait is not Send, ~Trait:Send is Send - and it's mostly used by channels and stuff to enforce safety
[07:10:51] <mcpherrin> milesrout: what platform are you trying to run code on?
[07:10:58] <milesrout> Oh wow, rust-core and zero.rs look fantasticly useful.
[07:11:06] <mcpherrin> zero.rs isn't useful anymore
[07:11:08] <eddyb> milesrout: zero.rs was obsolete half an year ago
[07:11:30] <milesrout> oh. I see. Can you just use #[no_std] or whatever now?
[07:11:39] <mcpherrin> yeah.
[07:11:40] *** Joins: tikue (tkuehn@moz-879E86A9.hsd1.ca.comcast.net)
[07:11:57] <milesrout> I thought it seemed weird to need that as well.
[07:12:09] *** Quits: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net) (Ping timeout)
[07:12:11] * milesrout unstars zero.rs on github
[07:12:28] *** Joins: mouse (mouse@moz-373942D2.dhcp.yndx.net)
[07:12:56] <eddyb> jnsk: all kinds bubble up, actually. Freeze means "obeys the rules of immutability" (we have library types that don't, but they're still safe because they enfore similar rules, at runtime) and Pod is "plain old data" (it copies, no code to run when it goes out of scope, etc.)
[07:13:01] <strcat> milesrout: you could just use #[no_std] before, but before you had to define lang items you didn't use
[07:13:14] *** Joins: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net)
[07:13:18] *** Quits: canhtak (canhtak@moz-4B5B3414.wl.t.ulaval.ca) (Quit: canhtak)
[07:13:18] <milesrout> I see
[07:13:33] <strcat> unlike zero.rs, rust-core actually provides a useful stdlib rather than just lang items
[07:14:44] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Client exited)
[07:15:06] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[07:16:20] *** Quits: int3_ (int3_@B9C75F30.B8DE573D.EC6C369A.IP) (Quit: Leaving...)
[07:16:55] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[07:17:01] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[07:17:26] *** Quits: bheylin_ (brianheyli@moz-8255E94E.adsl.online.nl) (Quit: bheylin_)
[07:18:47] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[07:20:00] *** Joins: mleise (marco@moz-850E56A9.pools.arcor-ip.net)
[07:20:44] *** Quits: mleise (marco@moz-850E56A9.pools.arcor-ip.net) (Quit: Leaving.)
[07:22:11] *** Joins: willingc (willingc@moz-B4760708.san.res.rr.com)
[07:22:30] <milesrout> strcat: so it does, so it does.
[07:24:23] *** Joins: pzol (pzol@322A273C.DEB41A6D.AADC76B.IP)
[07:25:34] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[07:26:32] *** Quits: FreeFull (freefull@moz-4C3B39E9.as13285.net) (Quit: )
[07:27:09] *** Quits: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Quit: lkuper)
[07:27:10] *** Quits: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net) (Ping timeout)
[07:27:54] <jnsk> are boxes about equivalent to pointers? If I understand correctly, ~5 allocates memory on the heap for an int, then gives back that "box?"
[07:27:57] *** Quits: syatchmenoff (samy@moz-AB5B740D.hsd1.or.comcast.net) (Quit: syatchmenoff)
[07:27:58] *** Joins: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net)
[07:28:51] <strcat> jnsk: the 'box' is the allocated memory
[07:29:04] <strcat> jnsk: you have a unique pointer owning a unique box
[07:29:21] <strcat> there's a significant semantic difference with types like Rc
[07:29:26] <strcat> where many pointers share ownership of one box
[07:29:45] <jnsk> oh okay. so a unique pointer means it is the only pointer that can reference that box
[07:29:57] <strcat> jnsk: well, the only owner
[07:30:17] <strcat> you can have references into that memory
[07:30:22] *** Quits: psquid (psquid@moz-A6E6069.threembb.co.uk) (Ping timeout)
[07:30:34] <strcat> jnsk: https://github.com/mozilla/rust/blob/master/src/libstd/rc.rs if you look at the Rc implementation you'll see there's even a private Box type
[07:30:37] <milesrout> So how can I compile rust to i586-elf i.e. generic 32-bit machine code in an elf container? At the moment it's compiling to elf64-x86-64 according to objdump -d. With C, I can use my cross-compiler, do I have to recompile rust to do this? Or can I use this --emit-llvm switch and then somehow convince llvm to turn its bytecode into an x86 elf?
[07:30:41] <jnsk> so the ownership is unique, not the pointer
[07:31:09] <mcpherrin> milesrout: --emit-llvm is one approach
[07:31:49] *** Joins: psquid (psquid@moz-8628D63C.threembb.co.uk)
[07:32:16] <jnsk> what is a private box?
[07:32:19] <eddyb> jnsk: myeah, you can have ~T and a few &T or one &mut T, pointing to the same box. but you can't have multiple ~T pointing to the same box (you need Rc<T> for that)
[07:32:26] <eddyb> jnsk: private as in not exported
[07:32:30] *** Parts: thewonderidiot (mike@moz-5506A033.hsd1.ca.comcast.net) ()
[07:32:36] *** Joins: Skif (emschwar@moz-4C5BB5A8.beyondbb.com)
[07:32:36] <jnsk> oh okay
[07:32:46] *** Joins: syatchmenoff (samy@moz-AB5B740D.hsd1.or.comcast.net)
[07:33:01] *** Joins: pyon (user@A16F2BE6.A9B419CB.1C8C8CE9.IP)
[07:33:07] <jnsk> ohhh so the difference between ~ and & is that the ~ signifies ownership?
[07:33:13] <strcat> mcpherrin: IR isn't platform independent
[07:33:15] <strcat> it's platform specific
[07:33:27] <strcat> jnsk: well, pretty much
[07:33:35] <mcpherrin> strcat: It's not OS-specific is it?
[07:33:38] <strcat> ~ owns some memory it allocated, and has a dtor
[07:33:47] <strcat> mcpherrin: it's OS-specific too
[07:33:49] <strcat> it's specific to a target
[07:33:59] <mcpherrin> strcat: oh, well that's a little more unfortunate
[07:34:03] <strcat> mcpherrin: rust has plenty of platform-specific code too
[07:34:10] <strcat> mcpherrin: IR isn't meant to be platform independent
[07:34:16] <strcat> it's the internal representation (IR) of the compiler
[07:34:22] *** Quits: Skif (emschwar@moz-4C5BB5A8.beyondbb.com) (Ping timeout)
[07:34:23] <strcat> it's just not what it's for
[07:34:30] <eddyb> jnsk: yes. & is borrowed from the stack, ~T, Rc<T> or a lot of other things (like a field of a structure etc.). that's why it's called "borrowed pointer"
[07:34:32] <strcat> the rust code is platform independent (at least ideally)
[07:34:36] <strcat> and you won't get better than that
[07:34:36] <mcpherrin> strcat: I was mostly thinking in terms of having more control of how the generated code gets linked and rammed into an elf file
[07:34:44] <mcpherrin> strcat: I don't know how to do those bits with rustc :)
[07:34:45] *** Quits: hacker_sam (hacker_sam@C0FE520A.661C02A7.B0CE379A.IP) (Client exited)
[07:34:50] *** Joins: amro (quassel@D9E34ACF.8AAAF769.FAAB0799.IP)
[07:34:51] <strcat> mcpherrin: well, you do have control
[07:34:59] <strcat> you can set any target triple rust supports with rustc
[07:35:05] *** Joins: hacker_sam (hacker_sam@C0FE520A.661C02A7.B0CE379A.IP)
[07:35:09] <eddyb> jnsk: &mut T kinda owns memory - as in, nothing else can access that memory while you have a mutable borrowed pointer to it
[07:35:16] <strcat> you can output IR or an object file if you want to do something with clang
[07:35:27] <jnsk> so what's happening when i say  { let x = 5; let y = ~x; }
[07:35:27] *** Joins: akhosrav (akhosrav@moz-3F7067A0.tukw.qwest.net)
[07:35:28] <strcat> but in the end, there's no way you could target a platform rust didn't support anyway
[07:35:45] <strcat> jnsk: you know C well right?
[07:35:53] <jnsk> yea I know C pretty well
[07:35:54] <eddyb> jnsk: x is on the stack, y is on the heap (and it's created with the same value as x)
[07:35:57] *** flaper87|afk is now known as flaper87
[07:36:18] <eddyb> jnsk: about &mut - unlike C/C++, fn foo(x: &mut int, y: &int) {*x = *y;} can *never* alias
[07:36:33] <strcat> jnsk: ssize_t x = 5; ssize_t *y = malloc(sizeof(ssize_t)); if (!y) { abort() } *y = x; free(y);
[07:36:39] <pyon> Is it a bad idea to use channels/ports in the middle of a lambda passed to RWArc::{read, write} ?
[07:36:58] <strcat> pyon: no
[07:37:02] <eddyb> pyon: you might be blocking other accesses, otherwise no
[07:37:17] <strcat> jnsk: rust always does the same thing as C when you assign/pass/return
[07:37:25] <strcat> jnsk: there are no hidden deep copies or heap allocations
[07:37:34] <strcat> it's always a shallow copy (memcpy)
[07:37:42] <pyon> strcat: eddyb: Ah, nice! If I use green threads, the runtime might even preempt a task, even in the middle of an atomic operation, right?
[07:37:54] <strcat> jnsk: if a type has a dtor, it has an owner, so a shallow copy moves the owner to the destination
[07:37:59] <eddyb> pyon: hmm, not sure about that
[07:38:04] <strcat> pyon: hm?
[07:38:14] <strcat> pyon: green threads run on OS threads (schedulers)
[07:38:18] <strcat> pyon: anyway I don't know what you mean
[07:38:23] <eddyb> jnsk: so here's a trick: fn foo(x: &mut HugeStruct, y: &HugeStruct) {*x = *y;} does it use memcpy or memmove?
[07:38:43] <strcat> pyon: obtaining a lock doesn't prevent context-switching from that thread
[07:39:02] <eddyb> jnsk: wait, that's a stupid question. gaah I need a better aliasing example >_>
[07:39:03] *** Quits: johnsoft (johnsoft@moz-7E09A266.neo.res.rr.com) (Ping timeout)
[07:39:07] <strcat> the stuff inside the lock scope isn't an atomic operation
[07:39:10] <pyon> strcat: Ah! Nice!
[07:39:10] <mcpherrin> pyon: by definition aren't atomic operations ... atomic?
[07:39:27] <strcat> lock scope != atomic
[07:39:46] <jnsk> haha I'm going to poke around the source a bit
[07:39:51] *** Joins: johnsoft (johnsoft@moz-7E09A266.neo.res.rr.com)
[07:40:00] <strcat> mutex == mutual exclusion, all it does is keep more than one thing from having access at the same time (and a rwlock relaxes that to allow multiple readers)
[07:40:05] <eddyb> strcat: I was going to say "you can't enfore atomicity" - but then ||:Atomic :P
[07:40:10] <jnsk> thanks for all your help, but I have to be going
[07:40:19] <jnsk> hasta luegooo
[07:40:26] <milesrout> strcat: so basically what you're saying is that I have two choices: maintain a patch of rust to support my own calling conventions etc., or suck it up and use the i386-intel-linux target?
[07:40:39] <pyon> mcpherrin: I need some operations to be atomic in the sense that other tasks cannot alter the same object concurrently, but I do not want to prevent preemption, e.g., if I am waiting at the middle of an atomic task, then preemption/context-switching is fine.
[07:40:50] *** Joins: bheylin_ (brianheyli@C709828D.E7BADBF1.B0C2132F.IP)
[07:40:55] <eddyb> strcat: how do I mark a pointer as "only-aliasable-as-read-only" in LLVM?
[07:40:57] <strcat> milesrout: yes
[07:41:02] <strcat> eddyb: hm?
[07:41:10] <eddyb> strcat: the semantics of &T:Frozen
[07:41:13] <milesrout> strcat: that simplifies things greatly.
[07:41:13] <strcat> eddyb: alias != pointers are equal, in LLVM terms
[07:41:19] <strcat> eddyb: alias == memory dependency
[07:41:27] <eddyb> well, yeah
[07:41:30] <strcat> eddyb: let x = 5; let y = &x; let z = &x;
[07:41:34] <strcat> y and z are NoAlias
[07:41:35] *** Quits: hdevalence (quassel@moz-D125A39F.home3.cgocable.net) (Ping timeout)
[07:41:37] <strcat> they're not aliases, in LLVM terms
[07:41:41] *** Joins: ecl3ctic (Mibbit@moz-E1FAD64C.wzfv1.vic.bigpond.net.au)
[07:41:43] <eddyb> hmpf
[07:41:52] <strcat> they're also MustAlias
[07:41:57] <strcat> eddyb: read the LLVM alias analysis docs ;p
[07:42:00] <eddyb> bleah
[07:42:19] <strcat> tbaa can mark types read-only too..
[07:42:27] *** Quits: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net) (Ping timeout)
[07:42:31] <eddyb> strcat: but is it possible outside TBAA?
[07:42:44] *** Quits: bheylin_ (brianheyli@C709828D.E7BADBF1.B0C2132F.IP) (Ping timeout)
[07:43:09] *** Joins: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net)
[07:43:21] <strcat> eddyb: outside of TBAA metadata? there's no way to mark stuff as anything
[07:43:36] <strcat> you can use llvm.invariant to mark something as being immutable in some scope
[07:43:37] <eddyb> strcat: there's noalias for arguments and return
[07:43:42] <strcat> eddyb: that's no a general thing
[07:43:46] <strcat> eddyb: it's a shortcut for arguments
[07:43:54] <strcat> TBAA metadata is the only general way of adding alias metadata
[07:44:04] <eddyb> yes, I just want to expand it to &T and &mut T
[07:44:14] <strcat> if a function with a noalias parameter is inlined... the info is lost
[07:44:21] <eddyb> pfffft
[07:44:21] <strcat> it's a shortcut, that's all.
[07:44:30] <strcat> it's mostly for marking external functions
[07:44:54] *** Quits: FliPPeh (lukas@moz-DE237B6E.dip0.t-ipconnect.de) (Ping timeout)
[07:44:56] <strcat> there's really no point in worrying a lot about noalias
[07:45:11] *** Joins: ptc (Adium@moz-192425C4.nyc.res.rr.com)
[07:45:14] <eddyb> strcat: how hard is TBAA, on a scale from function attributes to rewriting trans::debuginfo?
[07:45:19] *** Quits: jnsk (Mibbit@moz-D5D4385D.hsd1.ca.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[07:45:27] *** Parts: akhosrav (akhosrav@moz-3F7067A0.tukw.qwest.net) (WeeChat 0.4.2)
[07:45:48] <strcat> eddyb: it's not hard
[07:46:02] <whitequark> isn't there also a problem with TBAA in LLVM in that it's quite tailored to C/C++?
[07:46:02] <strcat> what's hard is that libstd is full of junk code breaking any rules you might decide to communicate to LLVM
[07:46:04] * strcat shrugs
[07:46:10] <whitequark> not metadata itself but how it's used
[07:46:17] <strcat> whitequark: dunno
[07:46:20] <eddyb> strcat: libstd will break and we'll fix it
[07:46:34] <strcat> eddyb: no
[07:46:36] <whitequark> strcat: I recall several discussions on llvm-dev about that
[07:46:37] <strcat> eddyb: you can't expect it to break
[07:46:40] <whitequark> even mentioning rust explicitly
[07:46:48] <eddyb> strcat: llvm-lint?
[07:46:49] <strcat> eddyb: you can incorrectly add noalias to a bunch of parameters
[07:46:51] <milesrout> strcat: mcpherrin: thanks guys, you've been a lot of help.
[07:46:51] <strcat> it's unlikely to break anything
[07:46:55] *** Quits: ptc (Adium@moz-192425C4.nyc.res.rr.com) (Ping timeout)
[07:47:05] <strcat> eddyb: lint doesn't catch it, lint is just to catch a rare few things that can be caught statically
[07:47:14] <strcat> you can't rely on verification/lint *or* tests to do stuff like TBAA
[07:47:30] <strcat> it doesn't commonly result in optimizations
[07:47:35] *** Quits: earlzlap (earlz@moz-483E1E31.neo.res.rr.com) (Ping timeout)
[07:47:36] <strcat> it's not going to drastically change the code
[07:47:50] *** Joins: FliPPeh (lukas@moz-5A449869.dip0.t-ipconnect.de)
[07:48:08] *** Joins: Cevn (sameer@moz-F316C21E.hr.hr.cox.net)
[07:48:13] <strcat> if you add a bunch of it, it might help a lot, but you really can't count on stuff breaking
[07:48:21] <eddyb> http://llvm.org/docs/LangRef.html#tbaa-metadata hmm, okay
[07:48:34] <strcat> whitequark: well I asked about it before and wondered how we would represent stuff
[07:48:45] <strcat> I am still not really clear on what a good way is to represent it
[07:49:02] <strcat> afaik the tbaa metadata they have is enough, just a PITA to use
[07:49:14] *** Joins: akhosrav (akhosrav@moz-3F7067A0.tukw.qwest.net)
[07:49:18] <eddyb> maybe not if you wrap it in a nice Rust API
[07:49:33] <strcat> eddyb: you need to figure out what rules you can communicate
[07:49:38] <strcat> long before worrying about the implementation
[07:49:45] <strcat> what rules do you think rust has that we can communicate? I am not sure
[07:49:49] <syatchmenoff> is it possible to model doubly linked lists using only owned and borrowed references? and if so, how do you do it?
[07:49:56] *** Quits: Cevn (sameer@moz-F316C21E.hr.hr.cox.net) (Ping timeout)
[07:50:09] <strcat> syatchmenoff: no, you can't
[07:50:21] <syatchmenoff> ok
[07:50:21] <strcat> you can use Rc/Weak or owned/raw pointers
[07:50:29] <eddyb> strcat: it does look like it might be capable of communicating structural information to debuggers (I remember the cool outputs from lldb) but DWARF might do that
[07:50:44] *** Joins: lenstr (lenstr@6737B9B0.9636F313.7A27613B.IP)
[07:50:49] <mcpherrin> syatchmenoff: this is a sticking point in rust, unfortunately.  The only real way is to have both links in your list be references, and all your nodes come out of an owned pool
[07:50:53] <strcat> eddyb: it doesn't stay around and wouldn't actually map to rust types
[07:50:55] <whitequark> eddyb: debuggers read DWARF, not TBAA
[07:51:11] <strcat> if you want to say type T does not alias anything (including other type T)
[07:51:17] <strcat> each instance of type T needs a unique TBAA metadata type
[07:51:26] <strcat> it has nothing to do with rust's type system really
[07:51:31] *** Joins: olem (olem@moz-D8B40BE5.fbx.proxad.net)
[07:51:40] <strcat> anyway I really suggest not worrying about the implementation
[07:51:45] <strcat> come up with a rule you can enforce
[07:51:47] <syatchmenoff> mcpherrin: ah, that makes sense
[07:51:51] <strcat> and find out what the problems are going to be with that
[07:52:06] <strcat> you're going to need to audit/fix the stdlib or make it somehow get disabled if you use the stdlib
[07:52:20] <strcat> the stdlib violates the mutability rules *excessively*
[07:52:30] <strcat> the low-level extern functions are not marked with *mut correctly, so it passes &T to them
[07:52:34] <strcat> from immutable locals/fields
[07:52:42] <strcat> I found hundreds of occurances
[07:52:45] <strcat> gave up
[07:52:46] <eddyb> whitequark: of course, I was hoping DWARF output could be generated from TBAA metadata
[07:52:48] <mcpherrin> sorry, what's TBAA?
[07:52:54] <milesrout> DWARF as in ELF?
[07:52:57] <strcat> type-based alias analysis
[07:53:00] <mcpherrin> type based aliasing some?
[07:53:01] <mcpherrin> okay
[07:53:01] <syatchmenoff> what's the trend for creating structures like scene graphs? is there a particular solution that people are finding is the best option?
[07:53:09] <strcat> syatchmenoff: Rc/Weak
[07:53:14] <whitequark> eddyb: they're really not comparable, DWARF is much more rich
[07:53:20] <eddyb> oh, interesting
[07:53:21] <syatchmenoff> strcat: thanks, I'll give that a shot
[07:53:34] <strcat> syatchmenoff: if you want safe code, that's how you do it - you represent owners with Rc and non-owning cyclic refs with Weak
[07:53:53] <milesrout> say that 10 times really fast. alias analysis, alias analysis, alias analysis...
[07:53:57] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[07:54:10] <mcpherrin> strcat: You can borrow from an Rc without refcount modification, right?
[07:54:17] <strcat> mcpherrin: ofc
[07:54:24] <strcat> mcpherrin: you can also pass it to a function by-value without one
[07:54:27] <eddyb> milesrout: developers developers developers
[07:54:33] <strcat> mcpherrin: refcounts are explicit clone calls
[07:54:39] <strcat> struct Node { children: ~[Rc<RefCell<T>>], parent: Weak<RefCell<T> }
[07:54:41] <strcat> syatchmenoff: like that
[07:55:03] <strcat> technically Rc could support copy-on-write too
[07:55:38] <eddyb> strcat: and my maybe-in-place-mutation?
[07:55:48] <strcat> hm?
[07:56:20] <milesrout> rc<refcell<T> weak<refcell<T> would be so much easier to read, at least in this font.
[07:56:35] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Ping timeout)
[07:56:38] <eddyb> strcat: if refcount == 1 and weak == 0, allocating a new Rc with a different value can become a mutation
[07:56:42] <strcat> easier to read with camelcase for me...
[07:57:05] * strcat suggests using a font that's not awful ;p
[07:57:19] <eddyb> oh, oh, I forgot... I thought about boolean... iterators
[07:57:19] <milesrout> strcat: it'll be the excessive use of C++. I don't even know what font I'm using actually.
[07:57:50] <strcat> C++ uses _ instead of CamelCase for types
[07:57:55] <strcat> so it's be ref_cell
[07:58:05] <eddyb> kinda like an Option<>, so you can go from a false/true value to None/Some(f())
[07:58:10] <milesrout> strcat: mhm, it would be. 
[07:58:20] <eddyb> strcat: you mean snake_case?
[07:58:30] *** Joins: jensnockert (jensnocker@moz-C4B24C3.customers.ownit.se)
[07:58:38] <strcat> yes, isn't that what I said? ;p
[07:58:40] <eddyb> but that's std types, a ton of projects use UpperCamelCase
[07:58:49] <eddyb> strcat: you didn't say "snake"
[07:59:32] <strcat> the stdlib and boost use snake_case *exclusively* for types, functions and methods
[07:59:41] <strcat> they use FOO_BAR for macros
[07:59:42] <milesrout> eddyb: boost uses proper C++ style. Boost + standard library, who needs any other library?
[07:59:56] *** Joins: Ms2ger (Ms2ger@AA55AE55.592AEF45.F15B0BB3.IP)
[08:00:01] <Yurume> milesrout: graphics.
[08:00:05] <milesrout> strcat: I hope everyone uses FOO_BAR for macros (unless they're like the linux kernel macros that try to look like functions)
[08:00:15] <strcat> macros trying to look like functions are bad
[08:00:20] <strcat> ;p
[08:00:43] <Yurume> (though C++ committee is evidently gearing towards the inclusion of C++-converted Cairo library?)
[08:00:48] <milesrout> strcat: depends. When it doesn't matter whether it's a function or a macro then it's not so bad.
[08:01:04] <milesrout> Yurume: wait what when did this happen?
[08:01:05] <mcpherrin> c++24 is going to include all of python ;)
[08:01:08] <strcat> Yurume: C style is also variable_name, function_name, type_name, MACRO_NAME
[08:01:23] *** Quits: lenstr (lenstr@6737B9B0.9636F313.7A27613B.IP) (Client exited)
[08:01:30] <strcat> the stdlib is the authoritative source for style ;p
[08:01:30] <Yurume> strcat: C style wildly varies among libraries
[08:01:44] <strcat> Yurume: the official style per the standard is that
[08:01:45] *** Joins: lenstr (lenstr@6737B9B0.9636F313.7A27613B.IP)
[08:01:51] <akhosrav> mcpherrin: all of python 2.7
[08:01:54] <strcat> you can have a consistent codebase by following it, or an inconsistent one
[08:01:59] * strcat shrugs
[08:02:00] <Yurume> and even the `_t` suffix is inconsistent within the stdlib
[08:02:00] <milesrout> strcat: C style is vrblnm fnnm name_t MACRO_NAME
[08:02:15] <strcat> milesrout: sure ;p
[08:02:17] <eddyb> haha
[08:02:22] <Yurume> milesrout: http://lists.cairographics.org/archives/cairo/2013-December/024858.html
[08:02:29] <strcat> http://en.cppreference.com/w/cpp/thread vs http://en.cppreference.com/w/c/thread
[08:02:30] <milesrout> mbsrtowcs
[08:02:30] <milesrout>  
[08:02:30] <milesrout>  
[08:02:31] <strcat> is a good example
[08:02:42] <Yurume> and struct noun.
[08:02:44] *** Joins: mib_rmhp4y (Mibbit@moz-4014DDC7.ga.at.cox.net)
[08:02:46] <strcat> C++ interface there is higher-level, yet offers more functionality
[08:02:55] <mib_rmhp4y> How does this compile? https://gist.github.com/anonymous/8451338
[08:02:59] <strcat> the C interface is a cut down version with fewer guarantees, fewer features and fewer vowels
[08:03:01] <strcat> ;p
[08:03:15] <milesrout> strcat: looks basically equivalent to me. 
[08:03:22] <Yurume> milesrout: <T: Hi, Low> defines two parameters :)
[08:03:25] <Yurume> oops
[08:03:31] <mib_rmhp4y> vowels and continents
[08:03:33] <Yurume> mib_rmhp4y: <T: Hi, Low> does... so.
[08:03:33] *** Quits: syatchmenoff (samy@moz-AB5B740D.hsd1.or.comcast.net) (Quit: syatchmenoff)
[08:03:33] <milesrout> C++ one looks like it has a few extra things that can be built out of some of the other things.
[08:03:36] *** Quits: lenstr (lenstr@6737B9B0.9636F313.7A27613B.IP) (Ping timeout)
[08:03:42] <Yurume> mib_rmhp4y: should have used <T: Hi+Low>
[08:03:58] <mib_rmhp4y> Yurume: Oh, Hi, Low means Hi or Low?
[08:03:59] <strcat> milesrout: nope
[08:04:18] <Yurume> mib_rmhp4y: no, it defines two generic parameters where the latter is unused
[08:04:38] <strcat> milesrout: http://en.cppreference.com/w/c/thread/cnd_timedwait
[08:04:39] <Yurume> it is basically equivalent to fn hio<T:Hi>(x:T)
[08:04:53] <mib_rmhp4y> Yurume: What is the point of being able to do that?
[08:04:54] <Yurume> (behaviorally, to be exact)
[08:05:00] <strcat> milesrout: unlike POSIX, it doesn't provide pthread_condattr_setclock
[08:05:14] <eddyb> mib_rmhp4y: it's ike <T: Hi, U> but instead of U it's named Low
[08:05:26] <mib_rmhp4y> eddyb: OHHHH
[08:05:29] <strcat> milesrout: so... want to wait for 100ms? you can't
[08:05:30] <Yurume> mib_rmhp4y: if you are using `.clone()` (provided by `Clone` trait) and `.foo()` (provided by, say, `Hi`) then you will need to say <T:Hi+Clone>.
[08:05:33] <mib_rmhp4y> eddyb: I'm an idit
[08:05:36] <Yurume> yeah
[08:05:38] <strcat> milesrout: you can calculate 100ms in the future and then NTP changes the time
[08:05:53] <eddyb> mib_rmhp4y: now you're less so :)
[08:05:59] <pzol> what's the difference between .clone() and .to_owned() ?
[08:06:00] <mib_rmhp4y> :)
[08:06:02] <Yurume> eddyb: will the users benefit from an unused generic parameter lint?
[08:06:04] <milesrout> Yurume: well holy shit that's actually pretty significant. It's also pretty weird to be honest, no idea why they'd do that. It's very specific.
[08:06:15] <eddyb> Yurume: doubt it a bit
[08:06:18] <Yurume> milesrout: Cairo things?
[08:06:25] <strcat> milesrout: there are a lot more examples though ;p
[08:06:56] <diverse> wait, why "Hi" and not "High"?
[08:07:11] <Yurume> High-Fi ;)
[08:07:23] <diverse> o/
[08:07:44] <milesrout> Then again they're coming out with networking and filesystem libraries soon, so the idea of having a standard library that supports the basic algorithms, data structures and now threading/atomic constructs you need to build functionality is being replaced by "HEY GUYS WE'VE GOT A KITCHEN SINK WE NEED TO FILL OVER HERE".
[08:08:06] *** Joins: lucian (lucian@moz-8408FDFA.cable.virginm.net)
[08:08:14] <strcat> networking and fs seem like pretty darn basic things
[08:08:20] <milesrout> I'd much rather have std::directed_graph or something than cairo.
[08:08:21] <mcpherrin> yeah what kind of crap standard library comes with a kitchen sink but no dirty dishes?!
[08:08:23] <Yurume> milesrout: haha, I was surprised of that move too. maybe we'll see Boost.Python standardized in 2030?
[08:08:39] <strcat> milesrout: a generic graph library is a pretty contentious thing
[08:08:41] <Yurume> (and in turn that will standardize Python and...)
[08:08:46] <mcpherrin> eugh I'd love to see a sane socket library :p
[08:08:54] <mcpherrin> (fucking berkley sockets.)
[08:08:54] <mib_rmhp4y> mcpherrin: One without a garbage disposer
[08:08:55] <strcat> the only way to make it generic enough to satisfy most use cases is making it harder to use than manually writing the code
[08:08:59] <strcat> like boost graph...
[08:09:01] * eddyb takes out a shovel
[08:09:09] <strcat> far easier to just write A* than use boost graph
[08:09:09] <eddyb> oi, what is this crap you're talking about?
[08:09:35] <diverse> look out, he's got a shovel!
[08:09:47] <olem> Greetings. Could someone point me to a way to use syslog (outputing to) with Rust? I did had a look at std::logging but it's for the compilation time. Where can I find infos to interact with syslog?
[08:09:49] *** Quits: lucian (lucian@moz-8408FDFA.cable.virginm.net) (Ping timeout)
[08:09:59] <strcat> olem: you can use any C functions you want
[08:10:04] <eddyb> diverse: it's for shoveling manure out of this channel
[08:10:15] <milesrout> eddyb: sorry
[08:10:16] <strcat> so in general, that's the answer - do it as you would in C, unless there's already a high-level API created
[08:10:23] *** Quits: chunyang (Thunderbir@89013021.7EB6399.C8ED823E.IP) (Ping timeout)
[08:10:29] <strcat> (which there isn't for syslog)
[08:10:34] <eddyb> diverse: librustc needs a bulldozer
[08:10:36] <Ms2ger> eddyb, hope you've got a lot of time :)
[08:10:45] <Yurume> strcat: except that syslog(3) accepts variadic arguments. (is that a non-issue now?)
[08:10:58] <strcat> Yurume: that's supporting
[08:11:00] <strcat> er
[08:11:02] <strcat> supported*
[08:11:07] <Yurume> oh great
[08:11:15] <Yurume> with an ellipsis?
[08:11:19] <strcat> rusti: extern { printf(x: *u8, ...); }
[08:11:19] <eddyb> Ms2ger: "coincidentally", I have
[08:11:21] -rusti- pastebinned 6 lines of output: http://ix.io/9Tr
[08:11:27] <olem> strcat: ok. thx for the confirmation (isn't for syslog for now) and pointer (call C lib).
[08:11:29] <diverse> eddyb: you already used a wrecking ball on a lot of places
[08:11:29] <strcat> rusti: extern { fn printf(x: *u8, ...); }
[08:11:30] -rusti- <anon>:10:18: 10:41 warning: code is never used: `printf`, #[warn(dead_code)] on by default
[08:11:30] -rusti- <anon>:10         extern { fn printf(x: *u8, ...); }
[08:11:30] -rusti-                            ^~~~~~~~~~~~~~~~~~~~~~~
[08:11:30] -rusti- ()
[08:11:33] <Yurume> great
[08:11:53] <Yurume> and we have another way to wreck the program in the unsafe environment
[08:12:17] <strcat> rusti: extern { fn printf(x: *u8, ...); } unsafe { printf(&"%d %d\n"[0], 2 as std::libc::c_int, 3 as std::libc::c_int) }
[08:12:18] -rusti- ()
[08:12:18] -rusti- 2 3
[08:12:23] <mib_rmhp4y> How do I describe the method I want to call when a name derives from more than one bound?
[08:12:30] *** Quits: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net) (Ping timeout)
[08:12:34] <eddyb> strcat: hmm, we should mark that "variadicity" to sound like "this is C only stuff only meant for extern etc."
[08:12:45] <eddyb> strcat: internally it's "variadic" which doesn't say much
[08:12:48] <milesrout> also WTF is with them removing std::optional and std::dynarray. Why do they *always* remove the best parts of C++ standards?
[08:12:54] <Yurume> mib_rmhp4y: one "bound"?
[08:12:56] <milesrout> concepts, then this. 
[08:13:02] <Yurume> what do you mean by bounds? trait bounds?
[08:13:06] <diverse> eddyb: perhaps explosives would do the trick for librustc?
[08:13:08] <strcat> milesrout: because they were really flawed
[08:13:15] *** Joins: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net)
[08:13:15] <strcat> milesrout: dynarray was totally broken
[08:13:29] <eddyb> I think using ..args for Rust magic and ... for extern C imports is sane
[08:13:31] <milesrout> how so?
[08:13:35] <strcat> didn't specify where the allocation was and didn't actually offer implementations a way to allocate on the stack
[08:13:41] <strcat> clang implemented all of the C++14 draft
[08:13:43] <Yurume> eddyb: makes sense
[08:13:46] <strcat> they discovered flaws in those parts
[08:13:48] <strcat> they were dropped
[08:13:54] *** Joins: chunyang (Thunderbir@F6611C67.221262A5.C8ED823E.IP)
[08:13:59] <strcat> dynarray would have been as useful as std::valarray
[08:14:05] <milesrout> strcat: except there ARE ways to allocate on the stack, namely variable length arrays which were added.
[08:14:10] <strcat> it'd have always been allocated on the heap...
[08:14:12] <strcat> milesrout: not the problem
[08:14:13] <Yurume> or reuse `...` as a yadda-yadda-yadda operator? (a la Perl 6 ;-)
[08:14:28] <strcat> milesrout: std::dynarray had requirements making it impossible to actually conform to the standard and allocate on the stack
[08:14:32] <eddyb> Yurume: what would that do?
[08:14:39] <strcat> milesrout: and didn't offer programmers a way to know
[08:14:53] <Yurume> eddyb: fail!()
[08:14:54] <milesrout> strcat: like?
[08:15:07] <strcat> milesrout: go read the defect reports
[08:15:08] <diverse> Yurume: oh no, anything but that!
[08:15:09] <Yurume> yes, that's a real operator in Perl 6.
[08:15:10] <eddyb> Yurume: hahah what?
[08:15:11] <Yurume> lol
[08:15:18] <strcat> milesrout: and for std::optional too
[08:15:21] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[08:15:22] <mib_rmhp4y> Yurume: In a generic function. A candidate method exists from more than one type bound. How do I tell Rust which one I want to call?
[08:15:25] <strcat> they were dropped due to being broken
[08:15:26] <Yurume> and there are `!!!` and `???`.
[08:15:36] <eddyb> Yurume: _ => ... ALL OVER THE PLACE
[08:15:42] <eddyb> that's what you're asking for
[08:15:53] * Yurume feels adventurous when thinking of Perl 6 operators
[08:16:25] * diverse feels a disturbance in the source
[08:16:39] *** Joins: avsej (avsej@D9A610B8.4841F515.FB33447D.IP)
[08:17:03] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[08:17:25] <strcat> milesrout: if there had been a std::optional proposed without breaking issues, it'd be in C++14 ;p
[08:17:45] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[08:17:54] <Yurume> mib_rmhp4y: I think there is no simple disambiguation possible (I can be tremendously wrong in this point)
[08:17:56] <milesrout> strcat: I can't find these phantom defect reports you speak of.
[08:18:05] <eddyb> diverse: did you see my latest anthropomorphic disaster? https://github.com/mozilla/rust/pull/11595
[08:18:08] <Yurume> though you can *limit* the trait with a helper function
[08:18:45] <Yurume> i.e. fn f<T:Hi+Lo>(x:T){ fn hi_foo<T:Hi>(x:&T) { hi.foo(); } fn lo_foo<T:Lo>(x:&T) { lo.foo(); } let v = hi_foo(&x) + lo_foo(&x); ... }
[08:19:15] <Yurume> I don't know if it's the only way to disambiguate it
[08:19:27] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[08:20:12] *** Joins: Zr40 (zr40@EE4BB9F5.926C319A.BE2F4011.IP)
[08:21:05] <milesrout> strcat: ?
[08:21:25] *** Joins: lenstr (lenstr@6737B9B0.9636F313.7A27613B.IP)
[08:21:48] <strcat> milesrout: I'm not google, I gave you all the information you need to find the wg documentation about it
[08:22:08] <milesrout> strcat: right, I'll take that as "They don't exist and I'm just making it up."
[08:22:22] <milesrout> Extensive googling gives no results. You've got the burden of proof.
[08:22:51] <strcat> yeah, they removed std::optional from C++14 (which was accepted already) without a reason or any discussion
[08:22:56] <diverse> eddyb: yep, it's a total source massacre. Great work! ;)
[08:23:19] <bascule> trolololol
[08:23:21] <milesrout> strcat: Not necessarily, just perhaps for other reasons.
[08:23:22] *** Joins: autra (augustin@A14DAE84.7F753DD1.EE2CA32B.IP)
[08:23:25] <eddyb> diverse: thanks. "friend of a the tree" might have been a bad idea
[08:23:32] <milesrout> time pressure perhaps.
[08:23:33] <eddyb> diverse: when I'm doing deforestation
[08:23:40] <strcat> milesrout: was already standardized + accepted
[08:23:51] <strcat> as in "in the draft"
[08:24:06] <milesrout> Look, I'm not saying you're not telling the truth. I'm saying that it's up to you to show evidence that your particular reason for removal is correct.
[08:24:34] <strcat> if you want to dig through the massive working group documents, that's on you
[08:24:37] <strcat> if you don't believe me, that's fine
[08:24:44] <strcat> there's not a 'burden of proof'
[08:24:46] <strcat> this isn't a debate
[08:24:57] <strcat> you asked me something, I told you the answer, if you don't like the answer you can look elsewhere
[08:27:21] *** Joins: c-a (c-a@moz-57C82A9.a163.priv.bahnhof.se)
[08:28:22] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[08:29:00] *** Joins: int3_ (int3_@moz-F4FB75FE.omega83.maxonline.com.sg)
[08:29:02] *** Joins: Ferreus (ferreus@moz-3013048A.dip0.t-ipconnect.de)
[08:29:11] *** Quits: int3_ (int3_@moz-F4FB75FE.omega83.maxonline.com.sg) (Client exited)
[08:29:12] *** Joins: syatchmenoff (samy@moz-AB5B740D.hsd1.or.comcast.net)
[08:29:18] *** Joins: int3_ (int3_@moz-F4FB75FE.omega83.maxonline.com.sg)
[08:30:02] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[08:30:42] <milesrout> anyway, what I was saying originally I still stand by: more basic data structures, more algorithms, better unicode support, etc - things useful in every or nearly every program - are what should be in the standard library. What tiny percentage of programs use uses 2d graphics?
[08:30:46] <diverse> eddyb: perhaps you are worthy of the title: Ed the Finisher
[08:31:07] *** Quits: int3_ (int3_@moz-F4FB75FE.omega83.maxonline.com.sg) (Ping timeout)
[08:31:15] *** Joins: int3_ (int3_@B9C75F30.B8DE573D.EC6C369A.IP)
[08:32:32] <Yurume> milesrout: C++11 finally has an officially sanctioned UTF-8 support though
[08:32:43] <strcat> Yurume: not guaranteed to be Unicode
[08:32:48] <strcat> and it's really not much
[08:32:56] <Yurume> heh
[08:33:21] *** Joins: Skif (emschwar@moz-4C5BB5A8.beyondbb.com)
[08:33:24] <Yurume> strcat: I thought u8"aaaa" literal *is* guaranteed to be in UTF-8
[08:33:45] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[08:33:51] <eddyb> std::string isn't 
[08:33:52] <milesrout> It has some level of support for it which is good, but it's not brilliant (and IMO is a pretty crummy API)
[08:33:56] <Yurume> got it
[08:34:46] *** Quits: pyon (user@A16F2BE6.A9B419CB.1C8C8CE9.IP) (Quit: restart)
[08:34:48] <strcat> Yurume: mbrtoc16, c16rtomb, mbrtoc32,  c32rtomb
[08:34:50] <eddyb> strcat: replacing the opaque box pointer with Type::i8p() - if only to make the LLVM IR more readable
[08:34:53] <strcat> pretty sure that's what you get
[08:34:59] <Yurume> strcat: :(
[08:35:01] <diverse> do we still use 'char' as a type?
[08:35:01] <strcat> __STDC_UTF_16__
[08:35:03] <strcat>  indicates that UTF-16 encoding is used by mbrtoc16 and c16rtomb 
[08:35:07] <strcat> __STDC_UTF_32__
[08:35:07] *** Quits: Skif (emschwar@moz-4C5BB5A8.beyondbb.com) (Ping timeout)
[08:35:08] <strcat>  indicates that UTF-32 encoding is used by mbrtoc32 and c32rtomb 
[08:35:24] <strcat> Yurume: and they're really slow, as implemented by glibc at least
[08:35:34] <Yurume> wait, so if they are not defined then char16_t and char32_t can use some other encodings, right?
[08:35:39] *** Joins: heftig (heftig@moz-D746319F.unitymedia.biz)
[08:35:45] <Yurume> something like... TRON? :S
[08:35:56] <strcat> Yurume: well, char16_t/char32_t are just distinct types with the same size as uint16_fast_t/uint32_fast_t
[08:36:03] <strcat> no encoding stuff enforced
[08:36:09] <Ms2ger> if mutbl { McDeclared } else { McImmutable },
[08:36:10] <Yurume> bad, pretty bad.
[08:36:13] *** Joins: pyon (user@A16F2BE6.A9B419CB.1C8C8CE9.IP)
[08:36:13] <Ms2ger> No McFlurry?
[08:36:20] <strcat> if those macros are defined, then those 4 functions use unicode
[08:36:28] <strcat> but they are really sad functions
[08:36:28] <eddyb> Ms2ger: what's doing in mem_categorization
[08:36:30] <diverse> I'll take that as a 'no'
[08:36:34] <strcat> UTF-8 <-> UTF-16
[08:36:35] <eddyb> Ms2ger: *what'ya doing
[08:36:37] <milesrout> strcat: mbrtoc16 isn't C++.
[08:36:42] <Yurume> that said the use of IEEE 754 is also optional, AFAIK, but anyway.
[08:36:42] <Ms2ger> eddyb, looking at your code :)
[08:36:43] <milesrout> codecvt facets are.
[08:36:57] <milesrout> mbrtoc16 looks more like something you'd see in C11.
[08:37:09] *** Joins: jackneill (jackneill@moz-E9D68037.pool.digikabel.hu)
[08:37:16] <Yurume> I always think that C needs to be separated into two different languages with differing goals
[08:37:27] <strcat> milesrout: these are the low-level cuchar ones
[08:37:27] <Yurume> like what Scheme folks have been done
[08:37:27] <diverse> Ms2ger: eddyb finishes the job by finishing off whatever
[08:37:47] *** Quits: tikue (tkuehn@moz-879E86A9.hsd1.ca.comcast.net) (Quit: tikue)
[08:37:58] * eddyb sharpens his paper cutting knife
[08:38:01] <strcat> milesrout: not talking of facets because C++ locales are really weird anyway ;p
[08:38:08] <diverse> eddyb: :)
[08:38:14] *** Quits: twi (Adium@moz-512229A7.lns9.lon.bigpond.net.au) (Quit: Leaving.)
[08:38:26] <Yurume> strcat: facets, I heartily hate them
[08:38:45] <strcat> it's really easy to just write  UTF-8 decoder/encoder and not worry about it
[08:38:52] <eddyb> strcat: mongodb was crashing when I was running /etc/init.d/mongodb start via SSH with LANG != C
[08:39:01] <milesrout> Yurume: you mean like a "basic C" which is basically structs, unions, pointers, functions, integers, arrays, enums and the preprocessor, and all that extra weirdness in C11 (and to a certain extent C99) that extends the language to being a wannabe C++? They've already got that, it's called library vs. language.
[08:39:34] <strcat> eddyb: python disables unicode support in filesystem APIs if the locale is C - isn't that great? and build sandboxes usually use C
[08:39:45] <strcat> eddyb: *shrug*
[08:39:49] <Ms2ger> I see a lot of HACKing
[08:39:53] <eddyb> strcat: but that's because debian didn't have lang packages installed
[08:40:00] *** Joins: benjamin_ (benjamin@moz-F3225091.dip0.t-ipconnect.de)
[08:40:05] *** Joins: leslie (Adium@moz-454B76DB.members.linode.com)
[08:40:09] *** Parts: leslie (Adium@moz-454B76DB.members.linode.com) ()
[08:40:19] *** Joins: leslie (Adium@moz-454B76DB.members.linode.com)
[08:40:23] <eddyb> Ms2ger: that's my preferred way of marking imperfect solutions. some of those were worse before my "HACK"
[08:40:25] <strcat> eddyb: no it's not to do with available locales
[08:40:29] <Yurume> milesrout: well, the C stdlib is *already* reaching that level. the problem here is that some parts of the stdlib are optional (with a good intention, you know).
[08:40:33] *** Quits: benjamin__ (benjamin@moz-29766E26.dip0.t-ipconnect.de) (Ping timeout)
[08:40:41] <eddyb> strcat: it was in my case. the problem was that it was just crashing
[08:40:48] <strcat> eddyb: I'm talking about python ;p
[08:40:50] <milesrout> strcat: hence why I said "better unicode support". Support that either doesn't involve facets, or involves a heavily overhaul of them into a standard library that PROPERLY understands unicode at the grapheme level.
[08:41:00] <eddyb> strcat: sure, I was talking about C++
[08:41:22] <strcat> eddyb: ah
[08:41:26] <strcat> I just mean C locales
[08:41:32] <strcat> C++ locales are insanely useless/weird stuff
[08:41:35] <Yurume> FYI, R7RS defines two different languages with the only difference between both is the standard library. (Scheme is particularly an easy language to do so, but I don't think that's impossible for C)
[08:41:44] <strcat> the C stdlib support itself isn't useful
[08:41:52] <strcat> beyond the actual locale
[08:42:03] <eddyb> strcat: lol, &Trait and ~Trait contain a i8*, but it was casted to that opaque box nonsense just to fit the env param
[08:42:07] <strcat> they define stuff like lower -> upper on code points
[08:42:09] <strcat> which is wrong
[08:42:17] <Yurume> strcat: or strxfrm...
[08:42:18] <eddyb> now there should be even less casting
[08:42:18] <strcat> well 'code point' ("wide character" that's UCS2 on windows)
[08:42:31] *** Quits: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net) (Ping timeout)
[08:42:42] <strcat> you can give 1 code point to to_lower and 2 back
[08:42:44] <Yurume> and strcoll. well, enough said.
[08:42:49] <strcat> so char -> char doesn't really work very well
[08:42:53] *** Joins: Cevn (sameer@moz-F316C21E.hr.hr.cox.net)
[08:43:07] *** Joins: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net)
[08:43:08] <strcat> Yurume: well, have you seen ICU APIs? it's terrible too
[08:43:24] <Yurume> strcat: but at least that works.
[08:43:32] <Ms2ger> -                   lhs: &ast::Expr,
[08:43:32] <Ms2ger> +                   lhs: @ast::Expr,
[08:43:36] <Ms2ger> eddyb, oh dear ;)
[08:43:41] <eddyb> Yurume: collation sounds... dirty
[08:43:47] <eddyb> Ms2ger: it was me who did the reverse
[08:44:21] <eddyb> Ms2ger: turns out both lhs and rhs need to be @Expr if self is just another argument
[08:44:30] <Ms2ger> Apparently :)
[08:44:41] <diverse> I thought @ was removed completely
[08:44:43] *** Quits: Cevn (sameer@moz-F316C21E.hr.hr.cox.net) (Ping timeout)
[08:44:54] <milesrout> strcat: Windows uses UTF-16, not UCS-2.
[08:44:55] *** Quits: mib_rmhp4y (Mibbit@moz-4014DDC7.ga.at.cox.net) (Quit: http://www.mibbit.com ajax IRC Client)
[08:45:09] <eddyb> diverse: not yet
[08:45:10] <Ms2ger> diverse, only @mut at this point
[08:45:17] <strcat> milesrout: in many places it uses UTF-16
[08:45:25] <eddyb> that would be P<Expr> in the future, which looks acceptable
[08:45:33] *** Joins: ptc (Adium@moz-192425C4.nyc.res.rr.com)
[08:45:36] <strcat> NTFS is UCS2, and wchar_t is a UCS2 code point, and the entire wchar_t API is UCS2
[08:45:55] <strcat> windows had unicode support before utf-16 was a thing
[08:46:22] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[08:46:26] <strcat> and the existing support didn't become utf-16
[08:46:39] *** Joins: dmacvicar (dmacvicar@moz-663A7346.nue.novell.com)
[08:46:52] <strcat> since utf-16 forbids stuff that's valid ucs2
[08:47:05] <diverse> eddyb: I will count on you to finish off @, don't even leave ashes behind.
[08:47:20] *** Quits: ptc (Adium@moz-192425C4.nyc.res.rr.com) (Ping timeout)
[08:47:37] <strcat> Eridius implemented rust's Path there
[08:47:41] <strcat> and probably knows more
[08:48:00] <eddyb> diverse: the day of P shall soon come
[08:48:21] <eddyb> and no one will mourn the death of @
[08:48:38] <dmacvicar> Hi!. I am trying to use bindgen. If I run it as it is I get "/usr/include/sys/types.h:146:10: fatal error: 'stddef.h' file not found", but if I addd -I/usr/include/linux I start to get other errors... like error: unknown type name 'size_t'. Anyone has used it successfully?
[08:48:51] *** Quits: lenstr (lenstr@6737B9B0.9636F313.7A27613B.IP) (Client exited)
[08:48:52] *** Parts: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (WeeChat 0.4.2)
[08:48:58] <Yurume> strcat: NTFS is not necessarily UCS2, you can do some stupid things with a different $UpCase table...
[08:49:20] <Ms2ger> eddyb, Servo is still mourning @mut ;)
[08:49:36] <Yurume> (exists for different locales, but well)
[08:51:11] *** Joins: gkostyanikov (gkostyanik@2663E5AE.3E410295.CA6E2165.IP)
[08:52:25] <sigma> huh, when did bors move channels?
[08:52:34] <eddyb> a long time ago
[08:52:39] <eddyb> can we get rust-buildbot out of here?
[08:52:48] <eddyb> it's annoying when you r<TAB> for rusti
[08:52:50] <eddyb> please?
[08:53:11] <sigma> I've been lurking in this channel for too long... hadn't even noticed he disappeared
[08:53:18] <sigma> sh
[08:53:20] <sigma> she*
[08:53:22] <sigma> it*
[08:54:30] *** Joins: noel (noel@moz-A96C42F7.as13285.net)
[08:56:43] *** Joins: Cevn (sameer@moz-F316C21E.hr.hr.cox.net)
[08:57:22] *** Joins: newbie (kvirc@moz-DD021B44.dip0.t-ipconnect.de)
[08:57:29] *** Quits: syatchmenoff (samy@moz-AB5B740D.hsd1.or.comcast.net) (Quit: syatchmenoff)
[08:58:15] <milesrout> And windows of course prioritises support of programs from eons ago over correctness, so instead of deprecating UCS-2 support and replacing it with UTF-16 (or fucking UTF-8 like someone sane), we're stuck with a hodgepodge of UCS-2 and UTF-16.
[08:58:17] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[08:58:20] *** Parts: milesrout (user@moz-7A0A3412.cable.telstraclear.net) (ERC Version 5.3 (IRC client for Emacs))
[08:58:26] *** Quits: Cevn (sameer@moz-F316C21E.hr.hr.cox.net) (Ping timeout)
[08:59:15] <Ms2ger> Backwards compat is annoying, of course
[08:59:40] <newbie> but very useful as well
[08:59:49] <newbie> for non-source distributed software
[09:00:44] <eddyb> binary compatibility != backwards compatibility
[09:01:32] *** Quits: flounder (Mibbit@moz-A06909E4.glbb.ne.jp) (Quit: http://www.mibbit.com ajax IRC Client)
[09:01:35] <eddyb> I kinda love how Rust goes for "package all you need, right versions, don't depend on much at runtime"
[09:01:45] *** Joins: flounder (Mibbit@moz-A06909E4.glbb.ne.jp)
[09:01:59] <eddyb> node.js/npm do that too, but that's a different story anyway
[09:02:39] *** Quits: chunyang (Thunderbir@F6611C67.221262A5.C8ED823E.IP) (Ping timeout)
[09:03:13] *** Quits: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net) (Ping timeout)
[09:04:14] *** Joins: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net)
[09:04:16] <diverse> eddyb: that's what makes it a good systems language, right?
[09:04:22] <leslie> There are so many "pointers" in Rust, where should I get started? 
[09:05:27] <eddyb> many as in... two?
[09:05:41] <diverse> leslie: focus on & and ~ for now. @ is going to be replaced with Rc in the lib
[09:05:51] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[09:06:01] <diverse> or I should say, "is replacing"
[09:06:14] *** Quits: yuriks (yuriks@50BCCB4D.6C9AD9C4.8E0C6B01.IP) (Ping timeout)
[09:06:15] *** Joins: bjz (bjz@moz-38D46E1C.perm.iinet.net.au)
[09:06:20] <leslie> Thanks, diverse  
[09:08:26] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Quit: TheHydroImpulse)
[09:08:52] *** Joins: lucian (lucian@moz-8408FDFA.cable.virginm.net)
[09:10:26] *** Quits: willingc (willingc@moz-B4760708.san.res.rr.com) (Client exited)
[09:10:35] *** Quits: lucian (lucian@moz-8408FDFA.cable.virginm.net) (Ping timeout)
[09:10:36] *** Quits: alisdair (textual@28441AAB.AC6E1995.F0AE27BD.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz)
[09:10:53] <diverse> leslie: check out this periodic table of Rust pointers, just to gives yourself a visual idea of what they do and how to use them: http://cosmic.mearie.org/2014/01/periodic-table-of-rust-types/
[09:11:06] <diverse> *give
[09:11:33] <FliPPeh> That table confused me more than it cleared things up :(
[09:11:37] *** Joins: rca (rcatolino@moz-FBA8CEE6.adsl.proxad.net)
[09:11:39] <Yurume> sorry for that :S
[09:12:02] *** Quits: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net) (Ping timeout)
[09:12:24] <FliPPeh> The C/C++ pointer model is wayyy to hardwired into my brain now
[09:13:00] *** Joins: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net)
[09:13:36] <diverse> yeah it's a new way of thinking, it just means you going to have to beat it in your head, one way or another.
[09:13:41] <FliPPeh> Well, the function rows are highly confusing to me for some reason
[09:13:48] <Yurume> FliPPeh: &/&mut/~/* is all the refinement of C/C++'s catch-all pointer types, *.
[09:14:10] <sigma> I dunno, since learning some rust I've been looking through our c++ code at work thinking "that's a mutable owned pointer" etc
[09:14:28] <Yurume> you are already have several pointer types in C/C++, you just don't distinguish it in the code explicitly.
[09:14:37] <Yurume> Rust makes them explicit.
[09:15:06] <Yurume> for the function rows, I agree that will make sense only to those familiar to Rust already
[09:15:19] <FliPPeh> Does ~T imply mutability of T for its owner?
[09:15:21] <Yurume> that wasn't designed for the absolute beginners anyway ;)
[09:15:36] <FliPPeh> Because I don't see "~mut T" :(
[09:15:44] <Yurume> FliPPeh: ~T does not have its inherent mutability, its mutability comes from the slot that stores it
[09:15:47] <sigma> I look at it as C/C++ encoding it's pointer types in patterns of use, Rust does it in the language
[09:16:09] <Yurume> if the variable is mutable and it contains ~T, then that ~T would be mutable. and so on for immutable ones.
[09:17:32] <FliPPeh> So... "let mut x: ~int = ~4;" for a mutable, owner integer?
[09:17:54] <Yurume> owned*, otherwise yes.
[09:18:14] <FliPPeh> Indeed, my hands are still coping with sleep deprivation
[09:18:22] <Yurume> FliPPeh: you can "freeze" or "thaw" the owned pointer by assigning (and in turn, moving) it to the mutable or immutable variable
[09:18:31] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[09:19:22] *** Joins: jadbaires (jadrian@moz-E16F2010.dsl.telepac.pt)
[09:19:24] <diverse> Yurume: or freeze it in a scope by borrowing
[09:19:31] <Yurume> right.
[09:19:35] <FliPPeh> What precisely is the difference between a vector and a slice? Is it like I think it is, namely the vector being itself and the slice being a view on a part of it?
[09:19:44] <Yurume> right
[09:19:51] <Yurume> it is a sort of views
[09:20:00] <newbie> does rust have slices?
[09:20:07] <diverse> newbie: yes
[09:20:07] <Yurume> yes
[09:20:17] <Yurume> which type is &[T] or &mut [T]
[09:20:20] <Yurume> (and for strings, &str)
[09:20:20] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[09:20:25] <newbie> do they work like go's slices?
[09:20:34] <newbie> *similar to
[09:21:17] *** Joins: kngl (Adium@moz-18BD1C.ipv4.evonet.be)
[09:21:45] *** Joins: lucian (lucian@moz-8408FDFA.cable.virginm.net)
[09:21:50] *** Joins: gwty (gwtypc@77D2A3.3F98A9B1.CF29F6CE.IP)
[09:21:52] <Yurume> newbie: I don't know they are comparable to each other
[09:22:16] <Yurume> rust's slice has different semantics and syntaxes from go's
[09:22:39] <newbie> I guess taking a slice of an array is a constant-time operation?
[09:22:51] <Yurume> yes.
[09:23:08] *** Quits: jaeholee (uid4856@moz-31ABA2C0.irccloud.com) (Quit: )
[09:23:09] *** Quits: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz) (Quit: Busying myself...)
[09:23:11] <Yurume> but not for the exactly same reason
[09:23:32] *** Quits: lucian (lucian@moz-8408FDFA.cable.virginm.net) (Ping timeout)
[09:23:57] <Yurume> newbie: Rust's slice is a view to the owned vector, and not garbage-collected.
[09:24:16] *** Joins: frogzilla (Mibbit@moz-93A5CBFD.hawaii.res.rr.com)
[09:24:17] <Yurume> therefore you cannot keep the slice longer than the corresponding owned vector.
[09:24:22] <newbie> yea
[09:25:04] <newbie> so it's kind of like when you give a pointer and a length to a function in C
[09:25:11] <Yurume> right
[09:25:25] <Yurume> but safer
[09:25:45] <Yurume> you can construct a slice directly from a pointer and length, in the unsafe context.
[09:25:59] <Yurume> a raw pointer*
[09:26:58] <FliPPeh> safer but much less fun :(
[09:27:27] <diverse> FliPPeh: yes the compiler is whiny, but it's whiny for a reason.
[09:28:34] <newbie> what type does a string literal have?
[09:29:05] <Yurume> FliPPeh: guaranteed, C can do funnier things like IOCCC but that makes the typical program much more unsafe :)
[09:29:27] <diverse> Yurume: IOCCC?
[09:29:31] <eddyb> (from a different channel)> we need a LLVM + Rust mascot. a dragon covered in rusty armor?
[09:29:38] <newbie> international obfuscated c contest
[09:29:40] <Yurume> newbie: &'static str. (i.e. a slice of the string which is live through the lifetime of the program)
[09:29:41] <FliPPeh> diverse: C turned into perl
[09:29:49] <eddyb> bstrie: ^^ I... am... FIRE. I... am... DEATH
[09:29:51] <Yurume> or Perl turned into C?
[09:29:58] <FliPPeh> Both
[09:30:05] <eddyb> come on, people, with your serious discussions, ruining my drama
[09:30:13] <diverse> eddyb: let me guess, "#rust-branding"?
[09:30:14] <FliPPeh> Talk about 'static
[09:30:15] <newbie> Yurume: so string is a native type?
[09:30:21] <FliPPeh> Named lifetypes are freaking confusing
[09:30:25] <eddyb> newbie: str is
[09:30:26] <newbie> *str
[09:30:32] <eddyb> FliPPeh: *lifetimes
[09:30:32] <Yurume> newbie: yes. it has to be since it is much used and it should be encoded in UTF-8.
[09:30:46] <FliPPeh> Who thought "&'a T" was a good idea? :(
[09:30:56] <Yurume> (i.e. only the unsafe codes can construct a string with invalid UTF-8)
[09:30:58] <eddyb> FliPPeh: why isn't it?
[09:31:14] <eddyb> FliPPeh: how could you name the lifetime in a more concise manner?
[09:31:15] <FliPPeh> I don't know, because it's really hard to understand why you need them
[09:31:23] <eddyb> FliPPeh: to link things together
[09:31:24] *** Joins: ferminter (Mibbit@moz-4014DDC7.ga.at.cox.net)
[09:31:25] *** Quits: pyon (user@A16F2BE6.A9B419CB.1C8C8CE9.IP) (Ping timeout)
[09:31:34] <FliPPeh> The documentation on those things is not exactly clear
[09:31:43] <diverse> FliPPeh: we need to show you that video about nmatsakis' presentation about the pointers and lifetimes
[09:31:47] <eddyb> that's a documentation issue
[09:31:57] <FliPPeh> Mix in that the seemingly magic 'static and things get very confusing
[09:32:05] <FliPPeh> I saw that video
[09:32:15] <newbie> Yurume: is str a truly native type or is it implemented by the stdlib?
[09:32:29] <Yurume> newbie: `str` is a truly native type but its methods are implemented by the stdlib.
[09:32:36] <ferminter> How do I distinguish statically between a method defined on both A and B in this case? `fn foo<T: A + B>(x: T) -> () { x.bar }`
[09:32:36] <frogzilla> Sometimes you're dealing with multiple lifetimes in a single methods.  You may borrow references with different lifetimes and you need a way to differentiate them
[09:32:44] <Yurume> in fact you can add methods to the existing type in Rust!
[09:32:44] <frogzilla> *single method
[09:32:50] <Yurume> safely!
[09:32:57] <newbie> yea, that's kind of like in go
[09:33:12] <diverse> Yurume: yay for Traits?
[09:33:21] <Yurume> that's like Go's interfaces but a stronger guarantee
[09:33:36] <Yurume> ferminter: you mean x.bar()?
[09:33:41] <newbie> in go you can define functions on arbitrary structs too
[09:33:44] <eddyb> FliPPeh: 'static means "lives forever"
[09:33:46] <Yurume> (fields are not visible through generic types)
[09:33:50] <newbie> Yurume: I am a little confused of why str needs to be native, but I guess that's my C background
[09:33:54] <frogzilla> I think he does
[09:33:54] <FliPPeh> So far I think I understand that "fun foo<T, 'a>(tr: &'a T) -> &'a T" takes some reference with some lifetype and returns that same thing again
[09:34:03] <FliPPeh> But I'm really have no clue otherwise
[09:34:10] <newbie> Yurume: I thought a struct with a length and a pointer would have suffices
[09:34:11] *** Joins: Skif (emschwar@moz-4C5BB5A8.beyondbb.com)
[09:34:13] <newbie> *sufficed
[09:34:15] <eddyb> FliPPeh: it returns something that lives *as long*
[09:34:44] <eddyb> FliPPeh: you can return a pointer to a field of a borrowed structure that you get *if* and *only* if you explicitly annotate with lifetimes
[09:34:51] <eddyb> that's not sane and maybe not even safe in C
[09:34:58] <eddyb> it's sane, safe and *checked* in Rust
[09:35:04] <Yurume> newbie: I don't remember the specifics, but there are compiler-recognized "language items" which can be replaced when absolutely required.
[09:35:18] <Yurume> some low-level stuffs use them.
[09:35:47] <eddyb> newbie: it maybe could be moved into the library, after DST, but what type would "foobar" have?
[09:35:47] <FliPPeh> eddyb: So basically it's just a type annotation to help the compiler figure out where it comes from and how long it's allowed to life?
[09:35:52] <ferminter> Yurume: Yes, that is what I mean, sorry.
[09:35:54] <Yurume> there are ongoing efforts to move the built-in semantics into language items
[09:35:57] *** Quits: Skif (emschwar@moz-4C5BB5A8.beyondbb.com) (Ping timeout)
[09:36:15] <eddyb> FliPPeh: not "help figure out". the compiler doesn't do API-level inference
[09:36:16] <newbie> eddyb: maybe that could be defined by the library as well.
[09:36:39] <eddyb> newbie: maybe. it would have to be a lang item struct with one field of the type [u8]
[09:36:41] <Yurume> ferminter: if only one of A and B has `bar`, it will be used. otherwise I think there is no direct disambiguation possible (no such thing like `x.A::bar()`) though you can limit the trait to work around.
[09:36:48] *** Joins: CarpNet (ac@moz-FD24B77.sohonet.co.uk)
[09:37:02] <eddyb> newbie: actually, that's not a bad idea. still needs DST
[09:37:11] <newbie> eddyb: sorry, what's DST?
[09:37:16] <newbie> except for daylight savings? :)
[09:37:21] <eddyb> Dinamically Sized Types
[09:37:28] <Yurume> ferminter: fn foo<T:A+B>(x:T) { fn A_bar<T:A>(x:&T) { x.bar(); } fn B_bar<T:B>(x:&T) { x.bar(); } A_bar(&x); B_bar(&x); }
[09:37:34] <eddyb> newbie: look for DST5 or DSTv5 on reddit
[09:37:41] <ferminter> Yurume: There is no way? Why not?
[09:37:47] <eddyb> should be nmatsakis' blog post around there somewhere
[09:38:06] <eddyb> ferminter: *not yet*
[09:38:13] *** Joins: Cevn (sameer@moz-F316C21E.hr.hr.cox.net)
[09:38:23] <FliPPeh> Okay, I guess I'll get to really grasping named lifetimes once I get a nontrivial project going.
[09:38:23] <Yurume> ferminter: I don't know why, though such disambiguation is not a typical case and can be worked around, which may be a reason I guess.
[09:38:44] <Yurume> if it became evident that it should be solved, it will be solved in the future
[09:39:04] <Yurume> or you can argue about that as a form of RFCs... :)
[09:39:07] <ferminter> Yurume: But the way you present is dynamic resolution correct?
[09:39:10] <eddyb> ferminter: I have done the low-level changes to allow calling methods as static method with an extra first parameter (self), now it's a matter of allowing it
[09:39:11] <Yurume> (with a good argument, of course)
[09:39:26] <Yurume> ferminter: no, everything I've presented is statically resolved.
[09:39:27] <eddyb> ferminter: with that, you could do B::bar(x);
[09:39:42] <FliPPeh> So, can Rust guarantee perfect memory safety in safe code at this point already? If not, will it, or can it?
[09:39:47] <Yurume> eddyb: ah, right. that will solve this particular case.
[09:40:05] *** Quits: Cevn (sameer@moz-F316C21E.hr.hr.cox.net) (Ping timeout)
[09:40:10] *** Quits: sk (sk@61A494B3.BA40E8A.AAC02D62.IP) (Quit: Leaving)
[09:40:11] <Yurume> FliPPeh: anything causing unsafe memory access etc. in the safe context is a bug and will be fixed.
[09:40:15] <eddyb> FliPPeh: pretty sure it can, modulo borrowck bugs that we don't know about
[09:40:15] <ferminter> eddyb: I like that :D
[09:40:36] <FliPPeh> That's really quite amazing for a low level language
[09:40:53] <diverse> FliPPeh: that's why they develop it
[09:41:06] <Yurume> ferminter: there is a dynamic resolution available (fn A_bar(x:&A) etc.) but you can choose what would be used ;)
[09:41:53] <newbie> eddyb: borrowck?
[09:42:04] <Yurume> newbie: short for "borrow checker", a built-in static analysis phase in the compiler.
[09:42:15] <newbie> k
[09:42:16] <FliPPeh> I was fairly certain that Rust can prevent most memory bugs and leaks, I just wasn't expecting it to offer complete memory safety :)
[09:42:32] *** Quits: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net) (Ping timeout)
[09:42:36] <frogzilla> I have a question about reading & writing to a TcpStream I wrote up on StackOverflow if any of you feel like taking a look: http://stackoverflow.com/questions/21157789/idiomatic-way-to-handle-writes-to-a-tcpstream-while-waiting-on-read
[09:42:43] <Yurume> FliPPeh: you know, it cannot offer the complete eradication of logical leaks ;)
[09:42:46] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[09:43:14] *** Joins: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net)
[09:43:24] <Yurume> but it will make most logical leaks obvious to spot 
[09:43:44] <FliPPeh> Yurume: Something like the programmer forgetting a shared pointer somewhere?
[09:43:53] <FliPPeh> Would be fairly astounding if Rust could find *that*
[09:43:54] <newbie> Yurume: if I write println!("{} {}", "str", 5);, will it infer the types during compile time, will it produce code specifically for a string and an int or will it need to parse the fmt string during runtime?
[09:44:11] <Yurume> FliPPeh: keeping shared pointers alive while they are unused
[09:44:19] <eddyb> newbie: the format string is parsed at compile time
[09:44:19] <Ms2ger> FliPPeh, or refcounted cycles, for example
[09:44:35] <Yurume> newbie: println!() is a syntactic extension (note the !).
[09:44:48] <FliPPeh> I guess we'll have to wait a few more years for the mind reading compiler
[09:44:51] <Yurume> syntax extension*
[09:45:19] <Yurume> FliPPeh: beware, reading mind is not equivalent to writing a code from it ;)
[09:45:32] <diverse> FliPPeh: rustc will bitch at you plently, don't worry.
[09:45:37] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[09:45:41] <diverse> *plenty
[09:45:46] <Yurume> if I think "Computer, solve the halting problem." then how would the compiler solve that? XD
[09:45:49] *** Joins: ptc (Adium@moz-192425C4.nyc.res.rr.com)
[09:46:05] <FliPPeh> diverse: I'm doing quite a bit of Haskell on the side, I very much expect my compiler to yell at me as often as it can
[09:46:18] <sigma> Yurume: You just need a sufficiently smart compiler
[09:46:34] <newbie> eddyb: I mean, will it generate code like print("str" + " " + str_to_int(5)); or will it generate code like print("{string} {int}", "str", 5);
[09:46:40] <FliPPeh> There is nothing better than compiler errors, since every runtime bug turned into a compiler error is one less runtime bug
[09:46:46] <Yurume> sigma: a sufficiently smart compiler is not a substitute for a compiler for hypercomputers though
[09:46:59] <sigma> it is if it's sufficiently smart :)
[09:47:10] <eddyb> newbie: more like the former, but with a different runtime implementation
[09:47:16] <Yurume> eddyb: the former, though it does not concatenate strings :)
[09:47:22] <Yurume> oops
[09:47:23] <FliPPeh> Maybe I'm just overcompensating after having to maintain a somewhat bigger python project
[09:47:28] <Yurume> newbie: (ditto)
[09:47:29] <eddyb> newbie: it actually doesn't change {} to {:s}
[09:47:32] <FliPPeh> But bless yelling compilers
[09:47:33] *** Quits: ptc (Adium@moz-192425C4.nyc.res.rr.com) (Ping timeout)
[09:47:38] <Yurume> FliPPeh: bless yelling compilers!
[09:47:53] *** Quits: leslie (Adium@moz-454B76DB.members.linode.com) (Ping timeout)
[09:47:56] <diverse> all hail for yelling compiler!
[09:47:59] <newbie> eddyb: ok, nitpick here, if it does not concatenate strings, it will result in three syscalls?
[09:48:00] <nrc> assume I have |trait t { fn m(x: &Self) -> u32;}| and |struct s {...}| and |impl t for s { fn m(x: ???) -> u32 {...} }|, what type should x have in the impl and does that m override the trait m?
[09:48:04] <FliPPeh> I'm still finding typos in that python code in rarely used code paths
[09:48:20] <eddyb> newbie: {} is implemented by std::fmt::Default, while {:s} is std::fmt::String
[09:48:20] <ferminter> Yurume: How is your code `fn foo<T:A+B>(x:T) { fn A_bar<T:A>(x:&T) { x.bar(); } fn B_bar<T:B>(x:&T) { x.bar(); } A_bar(&x); B_bar(&x); }` calling a method candidate statically?
[09:48:26] <newbie> FliPPeh: yea, that's awful :<
[09:48:26] <ferminter> It seems dynamic to me
[09:48:36] <Yurume> ferminter: it works like C++'s templates.
[09:48:53] *** Quits: jadbaires (jadrian@moz-E16F2010.dsl.telepac.pt) (Quit: Konversation terminated!)
[09:48:53] <Yurume> the codes for `foo`, `A_bar` and `B_bar` are duplicated per the type.
[09:48:55] <ferminter> Yurume: Okay, I guess you're right. The resolution is static. But there is the extra overhead of a function
[09:48:59] *** Joins: jadbaires (jadrian@moz-E16F2010.dsl.telepac.pt)
[09:49:00] <FliPPeh> newbie: Even worse is locating all the missing imports after splitting up a bigger module into smaller modules :(
[09:49:03] *** Joins: leslie (Adium@802083C6.67DB9176.67D29DD9.IP)
[09:49:05] <eddyb> newbie: it doesn't allocate memory directly, but I think it goes to a LineBufferedWriter by default, so calling print!("foo"); print!("bar") println!("baz") is one syscall
[09:49:06] <Yurume> it is small enough that it will be inlined
[09:49:19] <Ms2ger> FliPPeh, pyflakes?
[09:49:29] <Yurume> if you want to *force* inlining, you can use #[inline(always)] annotation before `fn` (called "attributes").
[09:49:37] <FliPPeh> Ms2ger: Could be a solution, but I didn't know about pyflakes until recently
[09:49:41] <Yurume> though I think it is fine to keep it as is
[09:49:44] <ferminter> Yurume: Thanks!
[09:49:51] <newbie> FliPPeh: yea, that's the time when I want to go back to a compiler.
[09:49:58] <diverse> Yurume: or put a semicolon at the end to make it global?
[09:49:58] <eddyb> you only need inlining annotations if the function is called from outside the crate
[09:50:04] <Yurume> ferminter: #[inline] is there for ensuring a reasonable performance even with -O0 ;)
[09:50:11] <Yurume> (a primary use case is an array iteration...)
[09:50:13] <eddyb> Yurume: nope
[09:50:28] *** Quits: jadbaires (jadrian@moz-E16F2010.dsl.telepac.pt) (Quit: Konversation terminated!)
[09:50:34] *** Joins: jadbaires (jadrian@moz-E16F2010.dsl.telepac.pt)
[09:50:37] <eddyb> Yurume: #[inline] is in the libstd to give you cross-crate inlining without LTO
[09:50:54] <eddyb> without #[inline], --opt-level=3 doesn't inline it, even if it's a noop
[09:50:56] <Yurume> was it solved by a static linkage... hmm
[09:51:02] <eddyb> you need -Z lto
[09:51:06] <Yurume> ah
[09:51:09] <Yurume> got it
[09:51:22] <eddyb> which takes a lot of time and memory
[09:51:40] <newbie> can I somehow write a C-api using rust?
[09:51:40] <ferminter> In the Rust documentation, why are constructors considered "methods"?
[09:51:44] <eddyb> fn main(){format!("foobar")} takes a few seconds *and* it doesn't become a noop :(
[09:51:56] <eddyb> ferminter: you mean static methods?
[09:51:57] <Yurume> well, generic functions are inlined in the caller crate anyway, but I misunderstood that a bit ;)
[09:52:06] <eddyb> Yurume: only generics
[09:52:19] <ferminter> eddyb: Okay, I didn't know they were referred to as methods, even though they do not take a self argument
[09:52:23] <eddyb> ferminter: Foo::new() is a static method
[09:52:26] <diverse> Foo::new() <- static method
[09:52:39] <diverse> eddyb: hey, you beat me
[09:52:47] *** Quits: jt (quassel@moz-B994FA9E.cs.st-andrews.ac.uk) (Client exited)
[09:52:50] <Yurume> newbie: #[no_mangle] extern "C" fn foo()?
[09:53:07] <ferminter> Who are you calling newbi?
[09:53:11] <ferminter> newbie*
[09:53:22] <ChrisMorgan> ferminter: the user called newbie.
[09:53:25] <newbie> :)
[09:53:26] <Yurume> there is a person here with a nick `newbie`
[09:53:33] <ferminter> oh wow
[09:53:46] <newbie> that was the default from my IRC client
[09:53:47] <newbie> :)
[09:53:48] <ferminter> Sorry I thought you were very rude
[09:53:50] <diverse> hey newbie, stop being such a newb!
[09:54:01] <FliPPeh> newbie isn't rude!
[09:54:04] <sigma> newbie isn't rude!
[09:54:07] <sigma> what he said
[09:54:08] <FliPPeh> ^
[09:55:20] *** Joins: andre (andre@CA528A4A.45A4338E.8EE27E6.IP)
[09:56:05] *** Joins: igork (Adium@9C577557.7893D71C.6E0EE79F.IP)
[09:56:15] <diverse> newbie: make your name backwards
[09:56:25] *** newbie is now known as eibwen
[09:56:30] <diverse> perfect!
[09:56:49] <Yurume> wait that's much like kibwen
[09:56:52] <Yurume> lol
[09:57:25] <Yurume> ferminter: everyone here was a beginner at some point (no exception for me) so feel free to ask things :)
[09:57:38] <eibwen> Yurume: is there something like a continued tutorial for this language?
[09:57:56] * ChrisMorgan wonders if the name kibwen was in fact derived from the word newbie
[09:58:03] <Yurume> a series of tutorials? I don't think so.
[09:58:23] <Yurume> there are much needs for proper documentations though
[09:59:12] <nrc> what are the rules for static method selection? in particular when would we select an implementation of T::M which is not in T?
[09:59:19] *** Quits: danikar (danikar@moz-447DB2D6.pv.reshsg.uci.edu) (Quit: )
[09:59:42] <FliPPeh> Looking at the periodic table of types, is it just shorthand notation or are variadic template arguments already in Rust?
[09:59:44] *** Joins: lucian (lucian@303F9692.4304AE1E.CE5E78F6.IP)
[09:59:52] <Yurume> FliPPeh: they are proposed notations.
[09:59:57] <FliPPeh> Sweet
[10:00:22] <Yurume> trait notations are proposed, || and proc() exists today and will be desugared into the traits on the proposal.
[10:00:37] <FliPPeh> Variadic templates and some stdlib bugs are pretty much the only thing left to make Rust my possible favourite language there is
[10:00:53] <Yurume> there are some concerns with the instability and/or problem with those notations listed in the Periodic Table though
[10:01:11] *** Joins: lucian_ (lucian@303F9692.4304AE1E.CE5E78F6.IP)
[10:01:12] <Yurume> so I was seriously thinking of removing them altogether and adding a separate note for that
[10:01:22] *** Quits: lucian (lucian@303F9692.4304AE1E.CE5E78F6.IP) (No route to host)
[10:01:57] <FliPPeh> The whole proc() vs || vs fun... thing is a bit daunting to be honest
[10:02:17] <Yurume> glaebhoerl in the Reddit raised very important points, and said he/she is willing to make more complete table
[10:02:21] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[10:02:30] <Yurume> evolutionary process :)
[10:02:36] <eibwen> can you (re)define operators for new types?
[10:02:54] *** Quits: lucian_ (lucian@303F9692.4304AE1E.CE5E78F6.IP) (Ping timeout)
[10:02:55] <FliPPeh> Wouldn't it be possible to use fn(...) for everything?
[10:03:03] *** Quits: evilpie (sid7877@moz-E77DEB21.irccloud.com) (Ping timeout)
[10:03:03] *** Quits: patrikstenmark (sid16326@moz-A42E5B7B.irccloud.com) (Ping timeout)
[10:03:22] *** Quits: etrepum (sid763@moz-5F4AA75A.irccloud.com) (Ping timeout)
[10:03:22] *** Quits: locks (sid130@moz-5F4AA75A.irccloud.com) (Ping timeout)
[10:03:22] *** Quits: GameGamer43 (sid5533@moz-E77DEB21.irccloud.com) (Ping timeout)
[10:03:22] *** Quits: ggherdov_ (sid11402@moz-E77DEB21.irccloud.com) (Ping timeout)
[10:03:22] *** Quits: dcolish (dcolish@1DB472A5.BE69FB10.416A0103.IP) (Ping timeout)
[10:03:22] *** Quits: zil (sid23500@moz-31ABA2C0.irccloud.com) (Ping timeout)
[10:03:22] *** Quits: cojennin (uid23526@moz-E77DEB21.irccloud.com) (Ping timeout)
[10:03:22] *** Quits: jack (sid19593@moz-A42E5B7B.irccloud.com) (Ping timeout)
[10:03:22] *** Quits: LQDH (uid17894@moz-31ABA2C0.irccloud.com) (Ping timeout)
[10:03:22] *** Quits: mhenretty (sid11899@moz-5F4AA75A.irccloud.com) (Ping timeout)
[10:03:22] *** Quits: v01px3 (sid18631@moz-5F4AA75A.irccloud.com) (Ping timeout)
[10:03:22] *** Quits: whitglint (uid15486@moz-31ABA2C0.irccloud.com) (Ping timeout)
[10:03:22] *** Quits: balpert_ (sid15886@moz-A42E5B7B.irccloud.com) (Ping timeout)
[10:03:22] *** Quits: Afuna (sid21127@moz-31ABA2C0.irccloud.com) (Ping timeout)
[10:03:22] *** Quits: wycats_ (sid79@moz-5F4AA75A.irccloud.com) (Ping timeout)
[10:03:23] *** Quits: Amaranth (travis@moz-F81BB56A.cpe.cableone.net) (Ping timeout)
[10:03:23] *** Quits: tautologico (uid22285@moz-A42E5B7B.irccloud.com) (Ping timeout)
[10:03:23] *** Quits: wilfred (sid159@moz-5F4AA75A.irccloud.com) (Ping timeout)
[10:03:23] *** Quits: tomdale (sid5518@moz-31ABA2C0.irccloud.com) (Ping timeout)
[10:03:23] *** Quits: lexs (uid12437@moz-5F4AA75A.irccloud.com) (Ping timeout)
[10:03:23] *** Quits: huhlig (sid17687@moz-A42E5B7B.irccloud.com) (Ping timeout)
[10:03:23] *** Quits: steveklabnik (uid17044@moz-A42E5B7B.irccloud.com) (Ping timeout)
[10:03:23] *** Quits: alan_andrade_ (uid23020@moz-31ABA2C0.irccloud.com) (Ping timeout)
[10:03:23] *** Quits: jzelinskie (sid17772@moz-A42E5B7B.irccloud.com) (Ping timeout)
[10:03:23] *** Quits: geomyidae_ (uid214@moz-E77DEB21.irccloud.com) (Ping timeout)
[10:03:23] *** Quits: davidillsley (sid18481@moz-5F4AA75A.irccloud.com) (Ping timeout)
[10:03:23] *** Quits: fixplz (uid18459@moz-A42E5B7B.irccloud.com) (Ping timeout)
[10:03:23] *** Quits: marc_ (uid5324@moz-31ABA2C0.irccloud.com) (Ping timeout)
[10:03:23] *** Quits: mje113 (uid16557@moz-A42E5B7B.irccloud.com) (Ping timeout)
[10:03:23] *** Quits: int3_ (int3_@B9C75F30.B8DE573D.EC6C369A.IP) (Ping timeout)
[10:03:23] *** Quits: abinader (sid21713@moz-A42E5B7B.irccloud.com) (Ping timeout)
[10:03:23] *** Quits: cmeiklejohn (sid1900@moz-31ABA2C0.irccloud.com) (Ping timeout)
[10:03:23] *** Quits: antifuchs (sid10828@moz-31ABA2C0.irccloud.com) (Ping timeout)
[10:03:23] *** Quits: escalant3 (uid14896@moz-31ABA2C0.irccloud.com) (Ping timeout)
[10:03:23] *** Quits: dbaupp (Thunderbir@moz-F3F7375F.lns20.syd6.internode.on.net) (Ping timeout)
[10:03:24] *** Joins: lucian (lucian@303F9692.4304AE1E.CE5E78F6.IP)
[10:03:32] <eibwen> what happened? :o
[10:03:36] *** Joins: Amaranth (travis@moz-F81BB56A.cpe.cableone.net)
[10:03:46] <Yurume> rusti: struct P(uint); impl Add<P,P> for P { fn add(&self, x:&P) -> P { let P(lhs) = *self; let P(rhs) = *x; P(lhs * rhs) } } P(3) + P(4)
[10:03:47] -rusti- main::P(12u)
[10:03:50] *** Quits: luisbg (luisbg@moz-C54443AD.baconseed.org) (Ping timeout)
[10:03:52] <Yurume> eibwen: you can do
[10:03:53] <Yurume> that
[10:03:55] *** Joins: luisbg (luisbg@moz-C54443AD.baconseed.org)
[10:03:58] *** Quits: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP) (Ping timeout)
[10:04:03] <Yurume> though this example does not make much sense...
[10:04:06] <ChrisMorgan> FliPPeh: it's actually not that hard; it just takes a little getting used to, then it's fairly natural.
[10:04:12] *** Quits: HansiHE (HansiHE@moz-7DF634EA.com) (Ping timeout)
[10:04:12] *** Quits: Siyo (Siyo@A89938F4.87DAA49F.F113998C.IP) (Ping timeout)
[10:04:12] *** Quits: pepijndevos (pepijndevo@9EACEF43.E50A3180.BCE47D84.IP) (Ping timeout)
[10:04:12] *** Quits: suzak (suzak@moz-FEBD2936.sakura.ne.jp) (Ping timeout)
[10:04:12] *** Quits: Leo` (Leo@moz-83832FE2.placeholder.fr) (Max SendQ exceeded)
[10:04:15] *** Quits: TobiasFar (tm@moz-A929D162.flosoft-servers.net) (Ping timeout)
[10:04:24] <eibwen> why is everyone timing out?
[10:04:24] *** Joins: Leo` (Leo@moz-83832FE2.placeholder.fr)
[10:04:25] *** Quits: aravindavk (aravinda@CD70857E.C436E7A2.D2D1FAF0.IP) (Ping timeout)
[10:04:27] *** Joins: pepijndevos (pepijndevo@9EACEF43.E50A3180.BCE47D84.IP)
[10:04:27] <Yurume> eibwen: you cannot redefine the existing operators
[10:04:28] <FliPPeh> fn foo(call_me: fn(int, int) -> int) { call_me(42, 42); }; foo(fn(a: int, b: int) { a*b });"
[10:04:30] *** Quits: leslie (Adium@802083C6.67DB9176.67D29DD9.IP) (Connection reset by peer)
[10:04:35] <eibwen> Yurume: not even for new types?
[10:04:35] *** Quits: mindcat (mindcat@CFA3850B.9B7EF212.2BCF2E43.IP) (Ping timeout)
[10:04:39] <FliPPeh> Type notation and anonymous function
[10:04:41] <diverse> eibwen: because eddyb finished them off ;)
[10:04:41] *** Joins: evilpie (sid7877@moz-E77DEB21.irccloud.com)
[10:04:42] <FliPPeh> With one syntax
[10:04:53] *** Joins: etrepum (sid763@moz-5F4AA75A.irccloud.com)
[10:04:53] *** Joins: locks (sid130@moz-5F4AA75A.irccloud.com)
[10:04:53] *** Joins: suzak (suzak@moz-FEBD2936.sakura.ne.jp)
[10:04:54] *** Joins: mindcat (mindcat@CFA3850B.9B7EF212.2BCF2E43.IP)
[10:04:56] *** Joins: mhenretty (sid11899@moz-5F4AA75A.irccloud.com)
[10:04:56] *** Joins: v01px3 (sid18631@moz-5F4AA75A.irccloud.com)
[10:04:59] *** Joins: wycats_ (sid79@moz-5F4AA75A.irccloud.com)
[10:05:00] *** Joins: wilfred (sid159@moz-5F4AA75A.irccloud.com)
[10:05:00] *** concrete.mozilla.org sets mode: +R 
[10:05:07] <Yurume> eibwen: as presented above,  you can add operators to any types as long as there is no existing operator implementation
[10:05:07] *** Joins: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP)
[10:05:17] <Yurume> so you cannot redefine uint + uint, but you can define P + P
[10:05:28] <eddyb> FliPPeh: we already have fn types like that
[10:05:34] <eibwen> ok, so I could make my own complex + complex for my newly defined complex struct
[10:05:39] *** Joins: dbaupp (Thunderbir@moz-F3F7375F.lns20.syd6.internode.on.net)
[10:05:43] <Yurume> eibwen: or use extra::complex?
[10:05:43] *** Joins: patrikstenmark (sid16326@moz-A42E5B7B.irccloud.com)
[10:05:52] <eddyb> FliPPeh: but closures are cooler
[10:06:06] <Yurume> no discouragement, I wanted to point out that there is an existing type
[10:06:09] <FliPPeh> eddyb: Why not make anonymous functions closures automatically if they refer to an outside variable?
[10:06:10] *** Quits: jadbaires (jadrian@moz-E16F2010.dsl.telepac.pt) (Quit: Konversation terminated!)
[10:06:18] *** Joins: skade (skade@541D1605.505237C9.CAE22B62.IP)
[10:06:21] <eibwen> Yurume: my question was just about the concept
[10:06:26] <eibwen> of defining operators
[10:06:28] <Yurume> yeah
[10:06:31] <eddyb> FliPPeh: because we already have closures
[10:06:36] <Yurume> you can always add operators to your own types
[10:06:39] <FliPPeh> But now I see 5 function types: fn(...), |...|, proc(...), Fn<...>, OnceFn<...>
[10:06:41] <FliPPeh> It's madness
[10:06:48] <eibwen> and you say I could even define new operators? how is precedence handled?
[10:06:59] <Yurume> FliPPeh: Fn/OnceFn is a proposed replacement for |...|/proc(...).
[10:07:03] <eddyb> FliPPeh: only the first three exist right now and you don't need to deal with the first one
[10:07:08] <Yurume> eibwen: ah wawit. sorry,
[10:07:18] <Yurume> you *cannot* define new operators.
[10:07:22] <ChrisMorgan> Yurume: well, for the *types*.
[10:07:38] <Yurume> you *can* define a semantics of existing operators for your own types.
[10:07:41] <eibwen> ok
[10:07:42] <eddyb> FliPPeh, Yurume: not replacement, but foundation
[10:07:48] <eibwen> so this is like in C++
[10:07:50] *** Quits: bjz (bjz@moz-38D46E1C.perm.iinet.net.au) (Connection reset by peer)
[10:07:57] *** Joins: jack (sid19593@moz-A42E5B7B.irccloud.com)
[10:07:57] *** ChanServ sets mode: +o jack
[10:07:58] *** Joins: zil (sid23500@moz-31ABA2C0.irccloud.com)
[10:07:59] <Yurume> you *cannot* (re)define a semantics of existing operators for existing types (in order to avoid confusion).
[10:08:09] <eibwen> yes
[10:08:10] <eddyb> ||/proc are compiler magic right now and we don't really like that
[10:08:25] <eibwen> so you cannot define =,== and != for any type?
[10:08:38] <Yurume> eddyb: in some sense the proposal replaces those magical types
[10:08:39] <diverse> eddyb: what's the plan for || and proc?
[10:08:42] <ChrisMorgan> eibwen: e.g. you can implement std::ops::Add<RHS, Result> for a type of your own and that's lhs + rhs  result
[10:08:45] *** Quits: frogzilla (Mibbit@moz-93A5CBFD.hawaii.res.rr.com) (Quit: http://www.mibbit.com ajax IRC Client)
[10:08:57] <ChrisMorgan> eibwen: == and != can be specified (Eq), but not =
[10:09:03] <eddyb> = is not overloadable, ==/!= are, but require the same type
[10:09:09] *** Quits: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net) (Quit: Leaving.)
[10:09:17] <FliPPeh> My point is not the necessarity of the types, but rather why isn't there a unified syntax so you don't have to remember 3 different types for 3 similar use cases?
[10:09:27] <ferminter> What kind of IDEs are available/are going to be available for Rust?
[10:09:31] <FliPPeh> Because now the notations could *not* be more different
[10:09:38] <ChrisMorgan> ferminter: Vim! Yay! Woo! 
[10:09:42] <FliPPeh> It's really hard to grasp it if you're new in Rust
[10:09:48] *** Quits: thesnowdog (doug@2DF7F7AE.8E46834.6F17036B.IP) (Ping timeout)
[10:09:48] <eibwen> ChrisMorgan: so it's some compiler magic? because std::ops::Add doesn't seem very much related to +
[10:09:56] <Yurume> FliPPeh: there are two major kinds of functions (bare functions are for no environments and FFIs)
[10:09:58] <diverse> ferminter: when someone does the hard work of making one
[10:10:01] *** concrete.mozilla.org sets mode: -R 
[10:10:03] <ChrisMorgan> FliPPeh:  oh yeah? I reckon they could easily be more different
[10:10:05] <eddyb> ChrisMorgan: an idea I had: trait Add<'lhs, 'rhs, Rhs, Ret> {fn add(&'lhs self, &'rhs Rhs) -> Ret;} and allow both impl Add<X, X> for X; and impl<'a> Add<'a, 'a, X, X> for X;
[10:10:05] *** Joins: HansiHE (HansiHE@moz-7DF634EA.com)
[10:10:08] <Yurume> which can be called multiple times or called once.
[10:10:09] *** Joins: bjz (bjz@moz-38D46E1C.perm.iinet.net.au)
[10:10:10] *** Joins: Siyo (Siyo@A89938F4.87DAA49F.F113998C.IP)
[10:10:14] *** Joins: thesnowdog (doug@2DF7F7AE.8E46834.6F17036B.IP)
[10:10:17] *** Joins: TobiasFar (tm@moz-A929D162.flosoft-servers.net)
[10:10:25] <diverse> eddyb: what's replacing proc and ||?
[10:10:30] *** Joins: dcolish (dcolish@1DB472A5.BE69FB10.416A0103.IP)
[10:10:47] <eddyb> my IRC client is unusable
[10:10:48] <Yurume> FliPPeh: this distinction between call-many functions and call-once functions is important due to the static analysis
[10:10:49] <ChrisMorgan> eibwen: std::ops contains the traits for all of the operators. + is Add, - is Sub, & is BitAnd, ^ is BitXor, &c.
[10:10:51] <eddyb> pls fix your IRC servers :(
[10:11:12] <eddyb> diverse: not replacing, but enforcing as a base. not sure if that makes sense. variadic traits
[10:11:16] <Yurume> for example, call-once functions can move the owned variable from its surrounding environment.
[10:11:31] <Yurume> but call-many functions can't since the owned variable is gone at the second invocation.
[10:11:43] <eddyb> FliPPeh: forget about bare functions, really. we hope to reuse the ||/proc syntax for Fn/OnceFn traits sugar
[10:12:22] *** Quits: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net) (Ping timeout)
[10:12:36] <diverse> eddyb: variadic traits huh?
[10:12:47] <eddyb> diverse: Fn<..Args, Ret>
[10:12:59] *** Joins: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net)
[10:13:04] <diverse> how interesting
[10:13:08] <Yurume> eddyb: aww, I'll fix the Periodic Table to hide the trait definitions by default...
[10:13:31] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[10:13:34] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[10:13:43] <eddyb> if we can make it so you don't have to see Fn for simple usecases, we will make it so
[10:13:44] <FliPPeh> http://smallcultfollowing.com/babysteps/blog/2013/10/10/fn-types-in-rust/
[10:13:45] <Yurume> beginners are amused or shunned of those :S
[10:13:53] <FliPPeh> Is that fairly up to date to current proposals?
[10:13:54] <Yurume> amazed? anyway.
[10:14:02] <eddyb> FliPPeh: look at the date
[10:14:12] <Yurume> FliPPeh: not much
[10:14:22] *** Quits: photex (photex@399640B9.24E301D6.9510F13D.IP) (Ping timeout)
[10:14:24] *** Joins: notrusti (notrusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[10:14:31] <FliPPeh> eddyb: I don't have too much insight at the current state of things, I only looked into rust a few days ago :)
[10:14:31] *** Quits: StarLight (StarLight@moz-926759F6.dynamic.avangarddsl.ru) (Ping timeout)
[10:14:43] <eddyb> it's before my variadic generics RFC, but I wrote that mess just to speed the process up. which it didn't :(
[10:14:52] *** Quits: mindcat (mindcat@CFA3850B.9B7EF212.2BCF2E43.IP) (Ping timeout)
[10:14:52] *** Quits: sfackler (sfackler@moz-AEECCEBA.com) (Ping timeout)
[10:14:58] <eddyb> nmatsakis and I still have lots to talk before I can move further with an implementation
[10:15:06] <diverse> FliPPeh: read cmr's "This week in Rust" to give you the current status
[10:15:07] <Yurume> FliPPeh: the rule of thumb: the half-life of various tutorials and codes unaltered is about 3 months.
[10:15:08] *** Quits: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP) (Ping timeout)
[10:15:08] *** Quits: phil (phil@684D2576.37BA1B1C.20F09BA6.IP) (Ping timeout)
[10:15:24] <FliPPeh> Yurume: got it!
[10:15:27] <Yurume> especially, proposals decay fairly quickly
[10:15:33] <Yurume> (since they are proposals!)
[10:15:35] *** Quits: Torwegia (ubuntu@moz-193FD65D.us-west-2.compute.amazonaws.com) (Ping timeout)
[10:15:35] *** Quits: sam113101 (sam113101@moz-83612DFD.us-west-2.compute.amazonaws.com) (Ping timeout)
[10:15:44] *** Quits: Gracenotes (person@EBE65A41.2EC0B472.9510F13D.IP) (Ping timeout)
[10:15:44] *** Quits: egghead (egghead@7851DE85.C82F6435.20F09BA6.IP) (Ping timeout)
[10:15:46] *** Quits: jensnockert (jensnocker@moz-C4B24C3.customers.ownit.se) (Input/output error)
[10:15:57] <diverse> damn, so much timeouts
[10:16:01] <Yurume> it would make a good read if you are interested in the evolutionary design process of Rust ;)
[10:16:03] *** Joins: jensnockert (jensnocker@moz-C4B24C3.customers.ownit.se)
[10:16:49] *** Quits: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP) (Ping timeout)
[10:17:01] *** Quits: Siyo (Siyo@A89938F4.87DAA49F.F113998C.IP) (Ping timeout)
[10:17:10] *** Quits: Leo` (Leo@moz-83832FE2.placeholder.fr) (Ping timeout)
[10:17:10] *** Quits: Matrixiumn (zack@26FCB504.DEC5C34C.42D1BD3B.IP) (Ping timeout)
[10:17:10] *** Quits: kaeso (kaeso@moz-F21FF626.unstable.it) (Ping timeout)
[10:17:10] *** Quits: TobiasFar (tm@moz-A929D162.flosoft-servers.net) (Ping timeout)
[10:17:13] *** Quits: Fill (Fill@moz-1107002D.kimsufi.com) (Ping timeout)
[10:17:13] *** Quits: andor (andor@moz-708868D.neferty.me) (Ping timeout)
[10:17:20] *** Quits: darnuria (darnuria@moz-AB6EB255.ip-91-121-133.eu) (Ping timeout)
[10:17:20] *** Quits: nathan7 (nathan@moz-60FC7746.nathan7.eu) (Ping timeout)
[10:17:23] <Yurume> what happened on moznet? :o
[10:17:23] *** Quits: k4nar (quassel@moz-EE8DAF45.ip-91-121-75.eu) (Ping timeout)
[10:17:23] *** Quits: GrecKo (GrecKo@moz-A7AA1BB6.fr) (Ping timeout)
[10:17:31] *** Quits: Seldaek (seld@moz-5DEA7688.ch) (Ping timeout)
[10:17:40] <diverse> note to self: set up join/leave filtering in weechat
[10:17:42] <FliPPeh> Someone stole all the pongs
[10:17:43] *** Quits: luisbg (luisbg@moz-C54443AD.baconseed.org) (Ping timeout)
[10:17:50] <Yurume> it seems that concrete.mozilla.org suffers a network problem
[10:17:51] *** Quits: darkf (darkf@moz-F9058B8A.net) (Ping timeout)
[10:17:53] *** Quits: glandium (glandium@moz-A09032B1.kimsufi.com) (Ping timeout)
[10:17:58] <Yurume> (judging from /whowas output)
[10:18:04] *** Quits: KokaKiwi (kokakiwi@moz-D674DAC6.kokakiwi.net) (Ping timeout)
[10:18:26] *** Joins: GameGamer43 (sid5533@moz-E77DEB21.irccloud.com)
[10:18:29] *** Quits: jcmoyer (deadbeef@moz-40035C19.sta.embarqhsd.net) (Connection reset by peer)
[10:18:39] *** Quits: vadimcn (chatzilla@FB06B64.76F9E272.DA40C4B3.IP) (Connection reset by peer)
[10:18:41] *** Quits: pnathan (Adium@moz-A8921E45.tukw.qwest.net) (Ping timeout)
[10:18:41] <FliPPeh> Which is bad, because I am on concrete
[10:18:49] * FliPPeh braces for ping timeout
[10:18:49] *** Joins: jcmoyer (deadbeef@moz-40035C19.sta.embarqhsd.net)
[10:18:55] *** Joins: StarLight (StarLight@moz-CFB6D340.pppoe.avangarddsl.ru)
[10:18:57] *** Joins: pnathan (Adium@moz-A8921E45.tukw.qwest.net)
[10:18:57] <diverse> FliPPeh: we all are
[10:19:00] *** Joins: mindcat (mindcat@CFA3850B.9B7EF212.2BCF2E43.IP)
[10:19:02] *** Joins: GrecKo (GrecKo@379B34AE.73787715.DE014C27.IP)
[10:19:04] *** Joins: k4nar (quassel@CED7C19A.49BC2FC5.DE014C27.IP)
[10:19:05] *** Joins: vadimcn (chatzilla@FB06B64.76F9E272.DA40C4B3.IP)
[10:19:10] *** Joins: Leo` (Leo@moz-83832FE2.placeholder.fr)
[10:19:13] *** Joins: glandium (glandium@DEB153B8.D2E4ABCD.A00B1FE4.IP)
[10:19:13] *** Joins: kaeso (kaeso@B42A452A.36A75777.A2798B07.IP)
[10:19:17] <FliPPeh> what a plot twist
[10:19:21] *** Joins: darnuria (darnuria@E402D079.91BBE29F.DE014C27.IP)
[10:19:22] *** Joins: Seldaek (seld@E733C546.5464C2F1.F113998C.IP)
[10:19:33] <Yurume> lol
[10:19:44] *** Joins: Gracenotes (person@EBE65A41.2EC0B472.9510F13D.IP)
[10:19:53] *** Joins: Fill (Fill@moz-1107002D.kimsufi.com)
[10:20:02] *** Joins: andor (andor@moz-708868D.neferty.me)
[10:20:03] *** Joins: nathan7 (nathan@moz-60FC7746.nathan7.eu)
[10:20:12] *** Joins: photex (photex@399640B9.24E301D6.9510F13D.IP)
[10:20:26] *** Joins: egghead (egghead@7851DE85.C82F6435.20F09BA6.IP)
[10:20:29] <eibwen> how is error handling done in Rust?
[10:20:41] *** Joins: Siyo (Siyo@A89938F4.87DAA49F.F113998C.IP)
[10:20:42] <Yurume> primarily via Option<T> and Result<T,E> types.
[10:20:48] *** Joins: TobiasFar (tm@moz-A929D162.flosoft-servers.net)
[10:20:55] *** Joins: Matrixiumn (zack@moz-1B22AAE2.net)
[10:20:56] <ferminter> Can anyone demonstrate a simple cycle/memory leak with std::rc?
[10:20:57] <FliPPeh> The haskell programmer in me likes that a lot
[10:20:58] *** Joins: KokaKiwi (kokakiwi@moz-D674DAC6.kokakiwi.net)
[10:21:01] <olem> In case it may helps spreading rust, I'v made an OSX (10.9 for now) install package for rust 0.9 -> https://github.com/olemaire/rust-osx
[10:21:07] <Yurume> you can also fail!() the current task
[10:21:24] *** Joins: luisbg (luisbg@moz-C54443AD.baconseed.org)
[10:21:31] <eibwen> Yurume: I don't know these types, are they defined like enum { T, Error }?
[10:21:31] <Yurume> olem: great! though you'll need to make the nightly snapshots periodically
[10:21:32] <diverse> FliPPeh: I think that's where rust got the idea from
[10:21:48] <Yurume> eibwen: Option<T> is either None or Some(T), Result<T,E> is either Ok(T) or Err(E).
[10:21:52] *** Joins: phil (phil@684D2576.37BA1B1C.20F09BA6.IP)
[10:21:58] *** Joins: sfackler (sfackler@moz-AEECCEBA.com)
[10:22:04] *** Joins: sam113101 (sam113101@moz-83612DFD.us-west-2.compute.amazonaws.com)
[10:22:05] <eibwen> rust has something like templates apparantly
[10:22:06] <Yurume> rusti: let v: int = from_str("42"); v
[10:22:10] -rusti- pastebinned 9 lines of output: http://ix.io/9Tx
[10:22:17] <Yurume> oops
[10:22:19] <diverse> Option or Result + pattern matching
[10:22:21] <Yurume> rusti: let v: Option<int> = from_str("42"); v
[10:22:23] -rusti- Some(42)
[10:22:26] <Yurume> rusti: let v: Option<int> = from_str("not a number"); v
[10:22:27] -rusti- None
[10:22:29] <Yurume> like this.
[10:22:33] <FliPPeh> diverse: Which is why Rust has the potential to be my favourite language ever since it combines the best from C/C++/Haskell in one well designed package
[10:22:41] * Yurume thanks strcat for resurrecting rusti
[10:22:54] <lucian> eibwen: they're more properly called generics, they lack many of the crazy parts in templates
[10:23:08] <lucian> FliPPeh: and a bit of ML for good measure :)
[10:23:17] <olem> Yurume: good idea. but personnally, will not have time to make it seriously on the long term. I can stick to releases (0.9, 10, ..) as I need it anyway.
[10:23:23] <Yurume> olem: yeah, that would be a problem.
[10:23:24] <eibwen> rusti: from_str("huh")
[10:23:29] *** Joins: LQDH (uid17894@moz-31ABA2C0.irccloud.com)
[10:23:31] *** Joins: whitglint (uid15486@moz-31ABA2C0.irccloud.com)
[10:23:32] -rusti- pastebinned 6 lines of output: http://ix.io/9Ty
[10:23:33] *** Joins: ggherdov_ (sid11402@moz-E77DEB21.irccloud.com)
[10:23:51] <diverse> FliPPeh: and the cool thing is, you can implement your own error handling scheme, if wanted to.
[10:23:55] <olem> Yurume: at least, I hope it will help/serve somes (like me...)
[10:24:16] <eibwen> Yurume: what was wrong with my line?
[10:24:30] <FliPPeh> rusti: from_str::<int>("huh")
[10:24:31] -rusti- None
[10:24:34] <FliPPeh> rusti: from_str::<int>("42")
[10:24:35] -rusti- Some(42)
[10:24:45] <Yurume> olem: there are some helpful people working on nightly builds for Windows and Linux (Ubuntu and Arch to be specific)
[10:24:55] *** Joins: Torwegia (ubuntu@moz-193FD65D.us-west-2.compute.amazonaws.com)
[10:24:55] <eibwen> rust can determine which function to call based on the *return value*?
[10:25:01] <diverse> rusti: from_str::<int>("42").unwrap()
[10:25:02] *** Joins: fabiand (fabiand@moz-D2F071D6.adsl.alicedsl.de)
[10:25:02] -rusti- 42
[10:25:08] <Yurume> while it is not officially endorsed, having nightly builds is definitely good for beginngers
[10:25:16] <eibwen> from_str::<int>("huh").unwrap()
[10:25:21] <eibwen> rusti: from_str::<int>("huh").unwrap()
[10:25:21] -rusti- task '<main>' failed at 'called `Option::unwrap()` on a `None` value', /home/strcat/projects/rust/src/libstd/option.rs:133
[10:25:22] -rusti- application terminated with error code 101
[10:25:26] <eibwen> cool
[10:25:29] <eibwen> :)
[10:25:39] *** Joins: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP)
[10:25:41] <Yurume> eibwen: yes. in this case rusti does not expect a particular type for the purpose of printing, hence the error.
[10:25:44] <FliPPeh> Rust has some nice type deduction
[10:26:05] <diverse> rusti: from_str("42").unwrap()
[10:26:06] <FliPPeh> But if you don't save the from_str result into an Option<T>, Rust does not know which type you want to convert to
[10:26:08] -rusti- pastebinned 6 lines of output: http://ix.io/9Tz
[10:26:15] <diverse> ehh
[10:26:16] <FliPPeh> So you have to explicitely pass the generic parameter
[10:27:27] <FliPPeh> rusti: from_str::<int8>("257")
[10:27:29] -rusti- pastebinned 10 lines of output: http://ix.io/9TA
[10:27:36] <Yurume> rusti: from_str("42").unwrap() + 54
[10:27:39] -rusti- pastebinned 9 lines of output: http://ix.io/9TB
[10:27:43] <FliPPeh> :(
[10:27:47] <FliPPeh> rusti: from_str::<i8>("257")
[10:27:48] <Yurume> ah
[10:27:48] -rusti- None
[10:27:51] <FliPPeh> Nice
[10:27:52] <Yurume> rusti: from_str("42").unwrap() + 54u32
[10:27:57] -rusti- pastebinned 9 lines of output: http://ix.io/9TC
[10:27:58] <diverse> FliPPeh: rusti is a bit old, I think the modern rustc can infer the type without having to explicit
[10:28:02] <diverse> *to be
[10:28:21] <eibwen> diverse: how would that work?
[10:28:23] <FliPPeh> diverse: But how could it? If you give it no information whatsoever, how could it possibly infer the type?
[10:28:25] <Yurume> hmm, okay. I forgot that the method resolution is asymmetric
[10:28:30] *** Joins: Afuna (sid21127@moz-31ABA2C0.irccloud.com)
[10:28:31] <Yurume> rusti: 54u + from_str("42").unwrap()
[10:28:31] *** Joins: cojennin (uid23526@moz-E77DEB21.irccloud.com)
[10:28:32] -rusti- 96u
[10:28:35] <Yurume> I'm pretty sure that this will work
[10:28:46] <diverse> Yurume: oh you got it working
[10:28:55] <pzol> how do I define a higher order function, a function returning a function/closure? I'd expect sthg like fn ho() -> fn {} - which doens't work 
[10:29:08] <Yurume> diverse: a bit strange, and normally I'll type-annotate things to make it obvious
[10:29:22] <FliPPeh> Unrelated: why is "int" spelled out, but i8, i16, ... are not?
[10:29:26] <FliPPeh> :(
[10:29:48] *** Quits: jensnockert (jensnocker@moz-C4B24C3.customers.ownit.se) (Input/output error)
[10:29:48] <eibwen> because i is reserved for for loops
[10:29:50] <eibwen> :)
[10:29:54] <whitequark> rusti: fn foo() -> fn(int) -> int {}
[10:29:55] <eibwen> and int32 is too long I guess
[10:29:56] <Yurume> 54u + from_str("42").unwrap() works because it is actually 54u.add(&from_str("42").unwrap()), and it's clear that add() requires uint and thus the generic parameter of `from_str` should be also uint.
[10:29:56] -rusti- pastebinned 7 lines of output: http://ix.io/9TE
[10:30:17] <FliPPeh> eibwen: Don't try C with int_least32_t then :>
[10:30:19] <whitequark> pzol: ^ see syntax above
[10:30:25] <Yurume> from_str("42").unwrap() + 54u does not work because there is no information about Option<T>
[10:30:31] <diverse> eibwen & FliPPeh: actually it infers the type based which the call is from, like inferring from a function's type parameter for example.
[10:30:48] <pzol> whitequark am blind!? where? 
[10:30:50] <diverse> *parameter type
[10:30:56] <Yurume> what if, for example, there is an impl of ~str for Add<uint,uint>? :)
[10:30:56] <eibwen> FliPPeh: for my for loops, I even consider int32_t to be too long
[10:31:01] *** Joins: kris (kris@moz-6D20263F.fullrate.dk)
[10:31:12] <FliPPeh> Meh
[10:31:18] <FliPPeh> I prefer consistency over shortness
[10:31:22] <whitequark> pzol: "fn foo() -> fn(int) -> int {}"
[10:31:28] <FliPPeh> And int, int8, int16 isn't so bad really
[10:31:34] <whitequark> that's for a function
[10:31:35] <FliPPeh> Way better than int, i8, i16, ...
[10:31:40] <eibwen> maybe
[10:31:45] <dmacvicar> Hi!. I am trying to use bindgen. If I run it as it is I get "/usr/include/sys/types.h:146:10: fatal error: 'stddef.h' file not found", but if I addd -I/usr/include/linux I start to get other errors... like error: unknown type name 'size_t'. Anyone has an idea how to make it work?
[10:31:50] <whitequark> replace fn with proc for heap-allocated closure
[10:32:00] *** Joins: bkircher (bkircher@moz-AF44BDFE.dip0.t-ipconnect.de)
[10:32:12] <whitequark> and stack-allocated closures have yet again different syntax, |int| -> int, although I'm not sure you can return one
[10:32:25] <ChrisMorgan> dmacvicar: Ubuntu?
[10:32:31] <rootnode> quick question: http://privatepaste.com/3bde339538
[10:32:31] <dmacvicar> openSUSE
[10:32:43] <rootnode> this doesn't compile. without the clone it does. why?
[10:32:47] <Yurume> rusti: fn f(x:int)->int { x+1 } fn foo() -> 'static |int| -> int { f } (foo())(5)
[10:32:49] -rusti- pastebinned 7 lines of output: http://ix.io/9TG
[10:32:53] <pzol> whitequark whitequark  thx 
[10:33:02] <Yurume> it does not work... but why?
[10:33:26] <whitequark> Yurume: closures and functions are distinct
[10:33:27] <ChrisMorgan> dmacvicar: OK, could be the same issue or could be different. When a stddef.h not found error appears in Ubuntu 13.10 the solution is to upgrade Clang/LLVM packages to the latest (but not default) version. 3.4, I think that was.
[10:33:31] *** Joins: balpert_ (sid15886@moz-A42E5B7B.irccloud.com)
[10:33:32] *** Joins: tomdale (sid5518@moz-31ABA2C0.irccloud.com)
[10:33:35] <diverse> rusti: fn returnint(t: int) -> int { t } returnint(from_str("42")) 
[10:33:37] -rusti- pastebinned 9 lines of output: http://ix.io/9TH
[10:33:44] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[10:33:52] <eibwen> .clone is defined for all types?
[10:34:03] <Yurume> whitequark: I know that, but sometimes bare functions can be coerced into closures AFAIK
[10:34:18] <rootnode> aah, got it
[10:34:18] <whitequark> Yurume: I'd think the coercion would be explicit
[10:34:19] <Yurume> rusti: fn f(x:int)->int { x+1 } let g: |int|->int = f; g(4)
[10:34:20] -rusti- 5
[10:34:21] <rootnode> A is missing clone
[10:34:24] <Yurume> like this.
[10:34:24] <whitequark> hmm
[10:34:27] <whitequark> not sure
[10:34:28] <rootnode> I feel stupid
[10:34:42] <whitequark> rootnode: #[deriving(Clone)] struct A ...
[10:34:53] *** Joins: glaebhoerl_ (glaebhoerl@moz-B5B88D72.catv.broadband.hu)
[10:34:56] *** Joins: Skif (emschwar@moz-4C5BB5A8.beyondbb.com)
[10:35:10] <diverse> rusti: fn f(x:int)->int { x+1 } let g: |int|->int = f; g(from_str("4"))
[10:35:12] -rusti- pastebinned 9 lines of output: http://ix.io/9TI
[10:35:13] <rootnode> whitequark:  yeah, got it. thanks. didn't think about that implicit dependency
[10:35:17] <diverse> oh whatever
[10:35:20] <Yurume> eibwen: no. you need to add an impl of Clone for that type, or more conveniently (but does not work always) using #[deriving(Clone)].
[10:35:28] <rootnode> error message could be improved though
[10:35:32] <dmacvicar> ChrisMorgan: I will try that...
[10:35:45] <Zr40> how do I get the length of a vector?
[10:36:04] <Yurume> error messages are one of the area where we are still far behind from the perfect :)
[10:36:24] *** Quits: ferminter (Mibbit@moz-4014DDC7.ga.at.cox.net) (Quit: http://www.mibbit.com ajax IRC Client)
[10:36:25] <Yurume> Zr40: .len().
[10:36:29] <diverse> better than gcc's at least
[10:36:33] *** Joins: int3_ (int3_@B9C75F30.B8DE573D.EC6C369A.IP)
[10:36:39] *** Quits: Skif (emschwar@moz-4C5BB5A8.beyondbb.com) (Ping timeout)
[10:36:39] <rootnode> will try to find where that is and maybe make my first pull request
[10:36:41] *** Joins: lexs (uid12437@moz-5F4AA75A.irccloud.com)
[10:36:51] <Zr40> Yurume: thanks
[10:37:09] <FliPPeh> At least Rustc doesn't generate 3 full terminal heights for a template error
[10:37:13] <eibwen> is there something like (compile-time) reflection in rust? like, can I iterate over the fields in a struct?
[10:37:13] <Yurume> rootnode: I've made my first commit in that way, good luck to you
[10:37:21] <Yurume> (and I seriously break the rustdoc in turn... lol)
[10:38:01] <eibwen> rusti: 2+2
[10:38:02] -rusti- 4
[10:38:09] <Yurume> eibwen: there is something like C++'s typeinfo called `TypeId`. it is used for implementing, for example, format!("{:?}", ...).
[10:38:11] <FliPPeh> rusti: 2/0
[10:38:12] -rusti- task '<main>' failed at 'attempted to divide by zero', <anon>:10
[10:38:12] -rusti- application terminated with error code 101
[10:38:17] <diverse> rusti: 2.times()
[10:38:20] -rusti- pastebinned 7 lines of output: http://ix.io/9TK
[10:38:23] <whitequark> eibwen: it's not compile-time though
[10:38:24] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Ping timeout)
[10:38:28] <whitequark> it's more like Go's reflection
[10:38:37] <FliPPeh> I'd like D's reflection in Rust
[10:38:38] <Yurume> oh wait, it may be std::reflect instead.
[10:38:58] <Yurume> reflection is a bit fluffy stuff so you need to consult the actual source code, I think.
[10:39:25] <FliPPeh> __traits(allMembers, sillyStruct) is quite powerful
[10:39:50] <lucian> i think for iterating over a struct, you would actually need reflection, since you're treating potentially different types the same way
[10:39:50] <Yurume> Rust won't get something like C++'s type_traits however.
[10:40:01] <pzol> how do I define the lifetime for this: fn higher_order_closure(i: int) -> || -> int {|| -> int { i + 1 } }
[10:40:29] <Yurume> pzol: you can't. `i` lives in the stack frame of `higher_order_closure` which is discarded on return.
[10:41:08] <Yurume> it should be an owned closure, except that there isn't an exact replacement at this time. the closest alternative is returning proc() -> int.
[10:41:24] <FliPPeh> Closures are bound to the stack and are invalid after the scope is terminated
[10:41:32] <FliPPeh> Which is another problem
[10:42:31] *** Quits: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net) (Ping timeout)
[10:42:33] <dmacvicar> ChrisMorgan: did not produce different results :-( what did you mean with latest but not default? do the fix means a patch against their clang packages?
[10:42:37] <olem> Yurume: do you know how I can join these people (working on nightly builds for Win and Lnx)?
[10:42:59] *** Joins: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net)
[10:42:59] <pzol> thanks :)
[10:43:33] *** Joins: tautologico (uid22285@moz-A42E5B7B.irccloud.com)
[10:43:37] *** Joins: alan_andrade_ (uid23020@moz-31ABA2C0.irccloud.com)
[10:43:40] <diverse> Yurume: are owned closures coming back?
[10:43:57] <eibwen> how does #derives(Clone) work without reflection?
[10:44:07] <FliPPeh> eibwen: compiler magic I presume
[10:44:17] <eibwen> oh, #derives is compiler magic?
[10:44:30] <eibwen> or even #derives and Clone?
[10:44:42] <diverse> eibwen: you mean #[derives(Clone)]?
[10:44:42] <FliPPeh> I'm fairly sure you can't define your own "derivationables"
[10:44:57] <FliPPeh> So it's at least somewhat magical
[10:45:00] <eibwen> ok
[10:45:13] <Yurume> olem: I think there is no central authority to make nightlies (they are unofficial anyway), but you can consult hansjorg (Ubuntu) or Heather (Windows) for that matter.
[10:45:24] <FliPPeh> But maybe I'm basing that on outdated documentation
[10:45:36] <Yurume> diverse: likely if variadic generics proposal is complete and deployed.
[10:45:42] <Yurume> but as always, not sure.
[10:46:03] *** Quits: kngl (Adium@moz-18BD1C.ipv4.evonet.be) (Quit: Leaving.)
[10:46:10] *** Joins: ptc (Adium@moz-192425C4.nyc.res.rr.com)
[10:46:28] <olem> Yurume: ok, thx!
[10:46:44] *** Joins: nulldata (chatzilla@EAC27067.BFAF942F.E5879046.IP)
[10:46:48] <nulldata> Hello
[10:46:51] <Yurume> hi!
[10:47:02] *** Joins: b1nd (b1nd@E3D8A436.45A6FC61.475248F5.IP)
[10:47:27] *** Quits: Yurumechan (23f9939a@B2F514.E4420F21.EEF52F3A.IP) (Ping timeout)
[10:47:52] *** Quits: ptc (Adium@moz-192425C4.nyc.res.rr.com) (Ping timeout)
[10:47:55] <pzol> can I clone a proc??
[10:48:17] <whitequark> no
[10:48:34] *** Joins: huhlig (sid17687@moz-A42E5B7B.irccloud.com)
[10:48:37] <ChrisMorgan> dmacvicar: I think it was that the clang/llvm packages in Ubuntu 13.10 are 3.2 but there were clang-3.4/&c. packages available which if installed worked while the others had not. On openSUSE the situation will not be parallel, but such information *might* be helpful for you.
[10:48:38] *** Joins: marc_ (uid5324@moz-31ABA2C0.irccloud.com)
[10:49:08] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[10:49:10] *** Quits: skade (skade@541D1605.505237C9.CAE22B62.IP) (Connection reset by peer)
[10:49:21] *** Joins: skade (skade@541D1605.505237C9.CAE22B62.IP)
[10:49:41] <dmacvicar> ChrisMorgan: thanks...
[10:49:57] *** Joins: Yurumechan (23f9939a@B2F514.E4420F21.EEF52F3A.IP)
[10:50:02] <nulldata> I have a weird problem, I use "std::io::net::tcp::{ TcpStream, TcpListener, TcpAcceptor }" but when I try to call .listen() on an TcpListener object I get: "type `std::io::net::tcp::TcpListener` does not implement any method in scope named `listen`", I'm not quite sure what I'm missing here.
[10:50:06] <nulldata> I am using 0.9 btw.
[10:50:23] <Yurume> nulldata: how about adding `use std::io::Listener;`?
[10:50:46] <lucian> i've been bitten by that too, but it makes sense that you must import the trait to
[10:50:46] <Yurume> `listen` comes from that trait but not exposed by default.
[10:51:00] <lucian> since that lets you solve the expression problem
[10:51:12] <nulldata> Okay, makes sense
[10:51:26] <nulldata> Thanks.
[10:51:30] <Yurume> lucian: and then we have `Add`, `Clone` etc. imported by default :)
[10:51:47] <lucian> Yurume: yeah, that just confuses the matter
[10:51:51] <nulldata> Yeah they're in std::prelude
[10:52:12] <lucian> but i suppose they're quite essential
[10:52:17] <Yurume> that does makes sense since you cannot implement `+` without importing `Add` for example, but I think that should be clear about why.
[10:52:46] *** Joins: kngl (Adium@moz-18BD1C.ipv4.evonet.be)
[10:53:03] *** Quits: z0w0 (zack@moz-87AABEA0.lnse1.woo.bigpond.net.au) (Ping timeout)
[10:53:20] <Yurume> (well, actually I'm not sure if `#[no_implicit_prelude]` will disable `+`... or not?)
[10:53:37] *** Joins: steveklabnik (uid17044@moz-A42E5B7B.irccloud.com)
[10:53:39] *** Joins: cmeiklejohn (sid1900@moz-31ABA2C0.irccloud.com)
[10:53:41] *** Joins: antifuchs (sid10828@moz-31ABA2C0.irccloud.com)
[10:53:42] <eibwen> like, not allowing 1+1?
[10:53:46] <lucian> i think it should be possible for the compiler to suggest a missing trait if the type has an impl in the same module with the method that isn't being found
[10:54:00] <Yurume> rusti: mod what { #[no_implicit_prelude]; pub fn foo() -> uint { 3 + 4 } } what::foo()
[10:54:01] -rusti- 7u
[10:54:02] <eibwen> rusti: #[no_implicit_prelude] 1+1
[10:54:04] -rusti- pastebinned 7 lines of output: http://ix.io/9TM
[10:54:24] <Yurume> rusti: mod what { #[no_implicit_prelude]; pub fn foo() -> uint { 3 + 4.clone() } } what::foo()
[10:54:26] -rusti- pastebinned 7 lines of output: http://ix.io/9TN
[10:54:34] <Yurume> ..is invalid since `Clone` is a prelude trait.
[10:54:41] <Yurume> (uint is special though)
[10:55:15] <Yurume> it seems that `+` definition actually uses a globally available lang item no matter it is visible or not.
[10:55:29] <Yurume> (a trait marked as #[lang="Add"] I think)
[10:55:50] <dmacvicar> ChrisMorgan: if I add -I/usr/bin/../lib64/clang/3.4/include to bindgen works. The strange thing is that clang on the command line has this by default
[10:56:05] *** Quits: Siyo (Siyo@A89938F4.87DAA49F.F113998C.IP) (Quit: Leaving)
[10:56:10] <ChrisMorgan> dmacvicar: I'm glad you found a solution of sorts
[10:57:43] *** Joins: Siyo (Siyo@A89938F4.87DAA49F.F113998C.IP)
[10:58:38] *** Joins: jzelinskie (sid17772@moz-A42E5B7B.irccloud.com)
[10:58:42] *** Joins: escalant3 (uid14896@moz-31ABA2C0.irccloud.com)
[10:58:55] *** Quits: johnsoft (johnsoft@moz-7E09A266.neo.res.rr.com) (Ping timeout)
[10:59:07] *** flaper87 is now known as flaper87|afk
[10:59:36] *** Joins: johnsoft (johnsoft@moz-7E09A266.neo.res.rr.com)
[11:00:22] *** Quits: gwty (gwtypc@77D2A3.3F98A9B1.CF29F6CE.IP) (Ping timeout)
[11:01:51] <pzol> is there a way to curry a closure/fn/proc?
[11:02:02] *** Joins: gwty (gwtypc@A3F4FE97.CFB6D583.BD94A9D5.IP)
[11:02:09] *** Joins: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[11:02:22] *** Quits: int3_ (int3_@B9C75F30.B8DE573D.EC6C369A.IP) (Quit: Leaving...)
[11:03:09] *** Joins: alonlevy (alon@moz-EB7C9CF3.telavivmakers.org)
[11:03:47] <pzol> sthg like |i: let add= |x: int, y: int| -> int  { x + y }; let add_one = add.curry(1); add_one(3);
[11:05:37] *** Quits: kngl (Adium@moz-18BD1C.ipv4.evonet.be) (Quit: Leaving.)
[11:06:13] <kimundi> pzol: Not automatically - you could certainly do something like let f = |x||y||z| x + y + z;, but that would not be callable as f(1,2,3)
[11:06:32] <pzol> kimundi ok, thanks
[11:07:07] *** Quits: vince (vince@87549D5D.A97DAB6F.A7E3DA15.IP) (Ping timeout)
[11:07:20] *** Joins: vince (vince@87549D5D.A97DAB6F.A7E3DA15.IP)
[11:07:29] <kimundi> Hm, that .curry() example might work in the future, with unboxed closures
[11:07:54] <lucian> it should be possible to make a curry!(add, 1) macro, right?
[11:08:07] *** Quits: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net) (Ping timeout)
[11:08:11] <kimundi> lucian: well, what would it expand to?
[11:08:34] <lucian> a closure with 1 in its env that calls add with it
[11:08:54] <kimundi> curry!(add, 1) => || add(1) ?
[11:08:56] *** Quits: gwty (gwtypc@A3F4FE97.CFB6D583.BD94A9D5.IP) (Ping timeout)
[11:09:05] <lucian> something like that, yes
[11:09:26] <ecl3ctic> question: how is stack growth handled at the moment? I've noticed that the task spawned when you call native::start doesn't have any overflow checking, but any subsequent tasks you spawn do
[11:09:32] <kimundi> in that case the macro becomes longer and more verbose than just writing it :P
[11:10:00] <kimundi> ecl3ctic: stacks don't grow anymore - if you run out of stack, the process aborts
[11:10:07] <lucian> kimundi: perhaps. the advantage is that you wouldn't need knowledege of the argument later
[11:10:41] <kimundi> lucian: Hm? How is there any difference between both?
[11:10:48] <ecl3ctic> kimundi: oh ok, I'd read stuff about segmented stacks but I didn't know what was actually implemented
[11:11:05] <ecl3ctic> kimundi: is that way it works now the way it will be staying?
[11:11:11] <kimundi> let f = || add(1) f(); vs let f = curry!(add, 1); f();
[11:11:29] <lucian> kimundi: oh, right
[11:11:47] <kimundi> ecl3ctic: yeah, growable stacks where to much of a pain with FFI - and modern OSes allocate the stack lazyly anyway
[11:12:02] *** Joins: pyon (user@A16F2BE6.A9B419CB.1C8C8CE9.IP)
[11:12:21] *** Quits: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net) (Ping timeout)
[11:12:40] *** Joins: kngl (Adium@moz-18BD1C.ipv4.evonet.be)
[11:12:56] *** Joins: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net)
[11:13:13] <ecl3ctic> kimundi: ok cool. I suppose I should *not use* the native::start task since it doesn't have any overflow checking. I'll just throw it away by calling spawn from main
[11:13:16] *** Quits: amro (quassel@D9E34ACF.8AAAF769.FAAB0799.IP) (Client exited)
[11:14:02] *** Joins: amro (quassel@D9E34ACF.8AAAF769.FAAB0799.IP)
[11:14:44] <kimundi> ecl3ctic: No idea actually about the current best way to handle that - its something that is in flux atm
[11:16:05] <Yurumechan> kimundi : actually, I think that once eddyb's variadic generics proposal is accepted it will allow for a function-like object with multiple function signatures
[11:16:40] <Yurumechan> thus allowing something like curry1, curry2 etc
[11:16:54] *** Joins: LinearInterpol (RJones@moz-E6F82C3A.maine.res.rr.com)
[11:16:57] <eddyb> oh yeah, that's a cool trick
[11:17:44] <Zr40> why does path.dir_path().display() fail with 'borrowed value does not live long enough', but let a = path.dir_path(); a.display() doesn't?
[11:18:32] <Ms2ger> I think the former makes path.dir_path() only live until the end of the display() call
[11:18:54] <kimundi> Yurumechan: Yeah, with variadtcs it could work
[11:19:09] <kimundi> Variadics would also allow to write a .append() method for tuples
[11:19:28] <eddyb> Yurumechan, kimundi, lucian: technically you should be able to even do impl<..Args, T, Ret, Base: Fn<..Args, T, Ret>> Fn<..Args, Curry<..Args, T, Ret, Base>> for Base
[11:19:28] <kimundi> fn append(tup: (..T), val: U) -> (..T, U)
[11:19:47] <eddyb> kimundi: that is the same as (..tup, val)
[11:20:19] <kimundi> eddyb: heh, I guess
[11:21:06] <eddyb> (the wrapper above allows you to call a function with one less argument, and it gives you a wrapper to add the last argument later. maybe it could work for any number of omitted arguments)
[11:21:31] <kimundi> but let mut t = tuple(); t.append(45); is nicer than let mut t = tuple(); t = (..t, 45); imo... or at least less 'special'
[11:22:05] <kimundi> wait, that wouldn'T even work
[11:22:12] <kimundi> the type changes
[11:22:16] <kimundi> I'm silly :P
[11:22:26] <lucian> it would have to return a new tuple, if anything
[11:23:02] <eddyb> kimundi: (..t.drop_last(), 45)
[11:23:06] <kimundi> yeah - and then let t2 = (..t, val); becomes less verbose than let t2 = t1.append(val)+
[11:23:15] <LinearInterpol> I'm getting excited about vectors and closures now. How far am I venturing into functional programming?
[11:23:19] *** Joins: dew (Instantbir@moz-9D36B7B6.static.stls.mo.charter.com)
[11:23:56] <kimundi> LinearInterpol: Not even that far - we are to low level for _nice_ functional code ;)
[11:24:13] <LinearInterpol> That's fine, I never got the paradigm that much in the first place.
[11:24:20] <LinearInterpol> But I'm wanting to learn. :)
[11:24:53] <kimundi> Well, the most relevant paradigmns are stuff like highe order functions (functions taking functions)
[11:25:11] <kimundi> like mapping
[11:25:23] *** Joins: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp)
[11:25:45] <kimundi> rusti: [1,2,3].iter().map(|x| (*x) + 100).to_owned_vec()
[11:25:48] -rusti- pastebinned 13 lines of output: http://ix.io/9TR
[11:26:07] *** Joins: jensnockert (jensnocker@moz-C4B24C3.customers.ownit.se)
[11:26:08] <kimundi> rusti: let v = [1,2,3]; v.iter().map(|x| (*x) + 100).to_owned_vec()
[11:26:09] -rusti- ~[101, 102, 103]
[11:26:25] *** Joins: Cevn (sameer@moz-F316C21E.hr.hr.cox.net)
[11:26:26] <Yurumechan> impl<'r,T1,T2,..T,U,F:Fn<'r,T1,T2,..T>> Fn<T1,T2,Curry2<'r,T1,T2,..T>> for F {...} impl<'r,T1,T2,..T,U,F:Fn<'r,T1,T2,..T,U>> Fn<'r,..T,U> for Curry2<'r,T1,T2,..T,U> {...}
[11:26:29] <LinearInterpol> Oh god, dude, you are blowing my mind. o_o
[11:26:36] <Yurumechan> eddyb kimundi : would work
[11:26:48] <kimundi> Yurumechan: ... are you _trying_ to break my brain? :P
[11:26:53] <Yurumechan> ha, its hard to type in the mobile device
[11:26:55] <Yurumechan> aaaaaaa
[11:26:58] <LinearInterpol> friggin' wat.
[11:27:06] <eddyb> Yurumechan: Curry2 is a sign of bad design
[11:27:08] * kimundi tilts out with to much stuff at once
[11:27:10] <Yurumechan> sorry for that lol
[11:27:20] *** Quits: bkircher (bkircher@moz-AF44BDFE.dip0.t-ipconnect.de) (Connection reset by peer)
[11:27:28] <Yurumechan> eddyb : yeah, just a bikeshedding.
[11:27:32] <eddyb> Yurumechan: the Curry wrapper should be variadic by itself
[11:27:51] *** Joins: bkircher (bkircher@moz-AF44BDFE.dip0.t-ipconnect.de)
[11:27:56] <eddyb> I think I know how to do it, not sure if it works just with the bare RFC
[11:27:59] <Yurumechan> will  it work?
[11:28:14] <Yurumechan> there would be two ellipses in the params
[11:28:18] *** Quits: Cevn (sameer@moz-F316C21E.hr.hr.cox.net) (Ping timeout)
[11:28:40] *** Joins: fixplz (uid18459@moz-A42E5B7B.irccloud.com)
[11:28:40] *** Joins: mje113 (uid16557@moz-A42E5B7B.irccloud.com)
[11:28:41] <Yurumechan> and reasoning about it requires... a variadic inference.
[11:28:52] <eddyb> yupp
[11:28:58] <eddyb> we'll have that, shouldn't be too hard
[11:29:05] <kimundi> LinearInterpol: As I experienced it, function programming experiences usually amount to thinking differently about working with data - specificially, higher level building blocks for expressing algorithms and data structures and stuff
[11:29:07] *** Quits: bkircher (bkircher@moz-AF44BDFE.dip0.t-ipconnect.de) (Connection reset by peer)
[11:29:09] <Yurumechan> hmm ok
[11:29:12] <eddyb> it should be possible to call f(a, b, c), f(a, b)(c), f(a)(b)(c), f(a)(a, b) with just one Curry implementation, btw
[11:29:35] *** Joins: bkircher (bkircher@moz-AF44BDFE.dip0.t-ipconnect.de)
[11:29:37] <LinearInterpol> kimundi: That's the kind of thought that I want to have. It's confusing at first, but I want to work with it.
[11:29:39] *** Joins: vmx (vmx@moz-8F56BC14.pools.arcor-ip.net)
[11:29:41] <Yurumechan> yea that would be possible if we have a variadic inference
[11:29:51] <LinearInterpol> Purely functional programming has interested me for.. longer than I can remember.
[11:30:30] <kimundi> LinearInterpol: For example, instead of "loop over every elemnt of this array, and add 100 to it", functional thinking would be more "map the function |x| x + 100 over the array"
[11:30:57] <kimundi> where map is defined as applying the function to each element to it
[11:31:16] <eddyb> <3 Rust code using let, loops, and whatnot and still mapping to functional paradigms
[11:31:21] <Yurumechan> lol
[11:31:22] *** Quits: benjamin_ (benjamin@moz-F3225091.dip0.t-ipconnect.de) (Ping timeout)
[11:31:30] <kimundi> (Not sure if there are C libraries out there that abstract to that level)
[11:31:43] <LinearInterpol> ..There aren't.
[11:31:48] <Yurumechan> *that* is a multiparadigm lang
[11:31:50] <eddyb> as long as you don't use "mut", it might even be machine-translateable to purely functional code
[11:31:51] <LinearInterpol> And, wow.
[11:31:59] <lucian> there is some weird stuff there, like libcello
[11:32:08] <LinearInterpol> I have to get my head around the concept of immutable data.
[11:32:12] <LinearInterpol> Just as a whole.
[11:32:31] <kimundi> eddyb: yeah - using each paradigmn is a pain in the ass sometimes, but at least all are possible ;D
[11:32:44] <LinearInterpol> Working with it is difficult for me because I need to visualize transformations without explicitly defining them.
[11:32:48] <eddyb> LinearInterpol: it's easier if you don't have to think of functions
[11:34:27] <ecl3ctic> kimundi: if I'm using the 'native' module then is spawn already implicitly native::task::spawn?
[11:34:31] <kimundi> LinearInterpol: Eh, immutability often just means you're not changing the original if you make a change, but rather create a new copy - RUst defaulting to immutable local variables mostly catches the kinds of bugs where you accidentially mutate the wrong variable in a loop or so
[11:34:46] <kimundi> ecl3ctic: I think yes, but I really have no experience with that
[11:35:12] * kimundi should take a week of and just _use_ the 50% of Rust he only ever talked about :P
[11:35:19] *** Quits: ofeldt (ofeldt@moz-E24EE8AB.dip0.t-ipconnect.de) (Ping timeout)
[11:35:40] *** Joins: Skif (emschwar@moz-4C5BB5A8.beyondbb.com)
[11:35:50] <ecl3ctic> kimundi: ok, thanks :P , I'll confirm that through other means
[11:36:01] <LinearInterpol> kimundi: But how different is using Haskell than using Rust for functional programming?
[11:36:04] <eddyb> ecl3ctic: std goes through the loaded Task interface - which is either libgreen or libnative - or nothing, if you're in start, before entering normal main or setting up native (did we get a working #[boot] yet?)
[11:36:14] *** Quits: nulldata (chatzilla@EAC27067.BFAF942F.E5879046.IP) (Quit: ChatZilla 0.9.90.1 [Firefox 26.0/20131206152142])
[11:36:17] <eddyb> LinearInterpol: Rust gives you better control over the memory
[11:36:20] <eddyb> and less headaches
[11:36:27] <eddyb> I think that's a win-win
[11:36:30] <lucian> LinearInterpol: they're not particularly similar. ML is closer, if anything
[11:36:32] <LinearInterpol> It is.
[11:37:12] <LinearInterpol> As well as using Rust as my main language (already sold there), I'm wanting to use it to learn functional paradigms. It's something I've really ignored.
[11:37:19] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[11:37:21] <lucian> eddyb: arguably control over memory is a headache in itself, but of course use cases differ
[11:37:26] *** Quits: Skif (emschwar@moz-4C5BB5A8.beyondbb.com) (Ping timeout)
[11:37:32] <LinearInterpol> So, hopefully, I'll break it in and work with it. :)
[11:37:35] <sigma> Haskell is non-strict and has higher kinded types, rust is strict and doesn't so you do a lot of things differently
[11:37:52] <eddyb> one underestimated functional language is ES
[11:37:54] *** Joins: ofeldt (ofeldt@moz-92294A54.dip0.t-ipconnect.de)
[11:37:58] <kimundi> LinearInterpol: Okay, so haskell is different because there _everything_ is immutable - there is no mutable data. There is also no function call stack like in languages like C or Rust - main is just a function that gets recursivly evaluated by the compiler, in the same way as you would solve a math problem on paper
[11:38:07] <eddyb> who needs pure functional when you have pure cool?
[11:38:15] <ecl3ctic> eddyb: awesome, thanks for that
[11:38:31] * ChrisMorgan nominates eddyb's last line to cmr
[11:39:08] <kimundi> Also, Haskells type system is way more powerful, and everything is a function - unlike RUst where some things can be one of ~5 different function types ;)
[11:39:28] <eddyb> 3, not 5
[11:39:42] <eddyb> though Rust has cooler syntax/semantics... maybe if someone ports that Rust-to-JS-syntax converter to traceur-compiler's parser, then my life would be complete
[11:40:25] <kimundi> eddyb: Eh, depends on how you count mutability, different ABIs and future extensability I guess.
[11:41:06] <eddyb> kimundi: JS objects are @mut HashMap's to Rust code :P
[11:41:08] <lucian> kimundi: one thing you missed in Haskell is explicit side-effects, which affects the language quite strongly
[11:41:31] <kimundi> oh, right
[11:41:47] <eddyb> type Object = @mut HashMap<@str, Object>;
[11:41:55] <lucian> eddyb: when it comes to syntax, you'll find tastes differ strongly. i much prefer haskell syntax to rust's, but it's the price to pay for popularity i guess
[11:42:11] <eddyb> lucian: Haskell doesn't have... syntax
[11:42:17] *** Quits: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net) (Ping timeout)
[11:42:21] <eddyb> it has tokens and spaces, much like LISP
[11:42:26] <eddyb> Rust has syntax ;)
[11:42:37] <lucian> it has much more syntax than lisps, there's if, case, lambdas, etc
[11:42:51] <lucian> but indeed many more things are functions than in rust, which i think is great
[11:42:55] <kimundi> Heh, I had to write haskel for an assignment yesterday, without remembering much of the syntax - I must say its a bit to "free" for my taste
[11:43:04] <lucian> sadly, rust must appeal to poor abused C++ programmers :(
[11:43:07] <eddyb> were was I... numbers are either @f64 or i32
[11:43:13] *** Joins: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net)
[11:43:20] <lucian> f64 in JS
[11:43:41] <kimundi> My brain parses better if different kinds of parameters are grouped in different kinds of delimiters :P
[11:44:12] <lucian> i can't say i agree, except for data literals. as i said, tastes differ when it comes to this
[11:44:15] <eddyb> lucian: one actual implementation is @f64 *or* i32 (with a missing bit, which makes it an integer)
[11:44:29] <eddyb> oh, about literals :D
[11:44:44] <lucian> haskell sucks at literals, totally. but then again, so does rust
[11:44:50] <lucian> i think clojure hits a nice middle ground
[11:44:52] <eddyb> check this out: HashSet::new[a, b, c, d]
[11:45:02] <sigma> There was a big email discussion thread at work recently after one of the teams watched some of bob martin's videos. Lots of people reimplementing the same code using different patterns and arguing about the various merits
[11:45:22] <eddyb> I don't know how to do HashMap literals, I need some silly operator
[11:45:25] <eibwen> rusti: 1.0/0.0
[11:45:26] <sigma> I chipped in with the haskell versions, they were all about 1/10th the size
[11:45:27] -rusti- inff64
[11:45:28] <sigma> was funny
[11:45:46] <lucian> eddyb: array of tuples isn't too bad, i think
[11:45:58] <eddyb> lucian: thing is, that above isn't an array
[11:46:08] <eddyb> lucian: it's a variadic Index trait
[11:46:19] *** Joins: tq (tq@moz-9FE9CCF4.a251.priv.bahnhof.se)
[11:46:20] <lucian> oh. that's evil
[11:46:24] <eddyb> originally intended for m[i, j]
[11:46:28] *** Joins: ptc (Adium@moz-192425C4.nyc.res.rr.com)
[11:46:42] * kimundi wouldn't be suprised to see Rusts vector initialization expression syntax transform into generic initializer lists sometime
[11:46:52] <eddyb> I don't like initializer lists per say
[11:47:06] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[11:47:10] <lucian> kimundi: took it forever to get this https://ghc.haskell.org/trac/ghc/wiki/OverloadedLists
[11:47:11] <kimundi> let m: HashMap<_> = [(1, 2), (2, 3), (4, 5)];
[11:47:22] <eddyb> kimundi: that would be a coercion
[11:47:36] <LinearInterpol> Does rust do tail-call optimization?
[11:47:42] *** Joins: nkoep (nik@moz-1DE6E833.pool.mediaways.net)
[11:47:45] <eddyb> LinearInterpol: as much as C/C++ under clang
[11:47:53] <LinearInterpol> Ah.
[11:48:00] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[11:48:08] <LinearInterpol> So next to none? :)
[11:48:10] <eddyb> keep in mind that exception handling and/or RTTI break it really easy
[11:48:11] * LinearInterpol never used clang.
[11:48:15] <eddyb> LinearInterpol: ...
[11:48:19] *** Quits: ptc (Adium@moz-192425C4.nyc.res.rr.com) (Ping timeout)
[11:48:39] <kimundi> eddyb: Not neccessarly - today it would coerce, because that would be a fixed sized vector literal - but theoretically a [expr..] expression could just be a generic initilaization think
[11:48:56] <eddyb> kimundi: why? it's technically a vector
[11:49:02] *** Joins: kris_ (kris@moz-4A0BC68A.dk.customer.tdc.net)
[11:49:15] <eddyb> kimundi: you can have a HashMap type, module *and static*
[11:49:38] <eddyb> let m = HashMap[(1, 2), (2, 3), (4, 5)];
[11:49:41] *** Quits: kris (kris@moz-6D20263F.fullrate.dk) (Ping timeout)
[11:49:41] <diverse> eddyb: is that `::new[a, b, c, d]` the variadic trait you were talking about earlier?
[11:49:57] <eddyb> diverse: no
[11:50:02] <kimundi> eddyb: sORRY, i DON't KNOW WHE
[11:50:06] <kimundi> woha
[11:50:14] *** Quits: bkircher (bkircher@moz-AF44BDFE.dip0.t-ipconnect.de) (Quit: Leaving...)
[11:50:16] <kimundi> Sorry, I don't know what we'Re talking about anymore :P
[11:50:31] <eddyb> diverse: Fn was the variadic trait I was mentioning. the RFC is about variadic generics
[11:50:44] <kimundi> You have the tendency to introduce even more hypotetical syntax than I in these discussions :)
[11:50:49] <eddyb> that's a variadic Index on a static
[11:51:05] <eddyb> which I argue we should have to not screw over matrices
[11:51:43] *** Quits: KindOne (KindOne@moz-C1511E4F.dynamic.ip.windstream.net) (Ping timeout)
[11:51:53] <eddyb> if mat2[i, j] works, then so does let map = HashMap[(1, 2), (2, 3), (4, 5)];
[11:53:16] <eddyb> kimundi: here's a compromise... [a, b, c] becomes ListLiteral[a, b, c]
[11:53:20] *** Quits: LinearInterpol (RJones@moz-E6F82C3A.maine.res.rr.com) (Ping timeout)
[11:53:30] <eddyb> then you impl - nevermind that won't work
[11:53:36] <kimundi> lucian: Something like that haskell link seems likely to me, yeah.
[11:54:18] <eddyb> kimundi: anyways, [a, b, c] can be make_literal(a, b, c) which goes through a variadic trait you can implement (like the hypothetical Box one or FromStr)
[11:54:21] *** Quits: moostik (Icedove@moz-53E05E9C.w92-151.abo.wanadoo.fr) (Ping timeout)
[11:54:23] <lucian> eddyb: aren't the two different cases, though? with mat2[i, j] i and j could potentially be different types. with the Set/HashMap examples, all elements should be the same type
[11:54:27] <eddyb> if you want inference
[11:54:51] *** Quits: ecl3ctic (Mibbit@moz-E1FAD64C.wzfv1.vic.bigpond.net.au) (Quit: http://www.mibbit.com ajax IRC Client)
[11:54:55] <kimundi> eddyb: Abusing variadic indexing for HashMap constructors sounds like a horrible hack that I wouldn't want to have in a library :P
[11:55:06] <eddyb> why?
[11:55:27] <eddyb> it's not horrible, it's... well, it's CTFE for one
[11:55:43] <eibwen> rusti: let i = 1i8; println!("{}", i);
[11:55:44] -rusti- 1
[11:55:44] -rusti- ()
[11:55:46] *** Joins: KindOne (KindOne@moz-C1511E4F.dynamic.ip.windstream.net)
[11:55:49] <lucian> it seems to me like a lang item + a trait would be nicer, and closer to other syntax
[11:55:54] <kimundi> How does CTFE follow from that?
[11:55:55] *** Quits: notrusti (notrusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[11:55:58] <eibwen> rusti: let i = 1i8; format!("{}", i);
[11:55:59] -rusti- ()
[11:56:05] <eddyb> kimundi: nevermind, just a random thought
[11:56:12] <eibwen> rusti: let i = 1i8; format!("{}", i)
[11:56:12] <eddyb> eibwen: you're ignoring the result of format
[11:56:13] -rusti- ~"1"
[11:56:58] <kimundi> eddyb: I just think they are differnent things, and making 'HashMap' a value for example violates naming conventions - we already explcitly transitioned away from such things in the past
[11:57:07] *** Joins: sk (sk@9E6B574B.EB2AA036.2CAF0D3B.IP)
[11:57:46] <eddyb> lucian: maybe, but if you make it too specific you risk blocking future expansions
[11:58:10] <lucian> eddyb: well, future expansion could just always involve an extra trait, right?
[11:58:12] <kimundi> rusti: fn Foo(a: int, b: int) -> Foo { Foo { a: a, b: b} } struct Foo { a: int, b: int } Foo(1, 2) // We used to have this convention, and it was confusing
[11:58:13] -rusti- main::Foo{a: 1, b: 2}
[11:58:18] <lucian> that's the point of them anyway
[11:58:25] <eddyb> no, that's not the point :)
[11:58:40] *** Quits: bjz (bjz@moz-38D46E1C.perm.iinet.net.au) (Ping timeout)
[11:58:41] *** Joins: abinader (sid21713@moz-A42E5B7B.irccloud.com)
[11:58:43] <eddyb> someone said something like MutFn on the reddit - we don't want complications like that
[11:58:45] *** Joins: geomyidae_ (uid214@moz-E77DEB21.irccloud.com)
[11:58:59] <eddyb> Fn and OnceFn is already two traits too many :P
[11:59:18] <lucian> the points of traits is so solve the expression problem (independent expansion of both types and fns on those types)
[11:59:20] <kimundi> WHat would MutFn even be?
[11:59:29] *** Quits: igork (Adium@9C577557.7893D71C.6E0EE79F.IP) (Quit: Leaving.)
[11:59:51] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[12:00:20] *** Joins: Cevn (sameer@moz-80C90058.v4.wm.edu)
[12:01:46] *** Joins: binsh (binsh@moz-54F7FD49.cpe.net.cable.rogers.com)
[12:02:13] <eddyb> kimundi: I don't know, it was related to || being &mut in a way
[12:02:54] <eddyb> lucian: yes, but it's better to have one generic trait than two contrained ones
[12:03:39] *** Joins: a_m0d (a_m0d@moz-322A4DE4.acanac.net)
[12:04:06] <lucian> eddyb: as long as those traits represent the same thing
[12:04:31] <lucian> it seems to me that a variadic with the same type appearing several times isn't really a variadic at all
[12:05:04] <eddyb> I did consider implementing (..[T, N])
[12:05:12] *** Joins: Earnestly (earnest@moz-E86D50FA.dyn.plus.net)
[12:05:32] <lucian> that's dependent type territory :)
[12:05:40] <eddyb> err, ..N
[12:05:44] <eddyb> lucian: not in Rust
[12:06:29] <lucian> in fact, i'd almost say that having two traits *is* better than one in most cases
[12:06:44] <lucian> it separates concerns, so you could implement one, but not necessarily the other
[12:06:57] *** Joins: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[12:07:22] <eddyb> &[T] is pretty limiting
[12:07:24] <marc_> Is there a way of defining default values for a struct without losing the benefits of keywords?
[12:07:44] *** Quits: Ferreus (ferreus@moz-3013048A.dip0.t-ipconnect.de) (Ping timeout)
[12:07:50] <eddyb> lucian: Json[0, "foo", false]
[12:07:54] *** Quits: binsh (binsh@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[12:07:55] <marc_> Foo{a: 1} is better than Foo::new(1), but the former doesn't let you define defaults (I think?)
[12:08:25] <eddyb> marc_: how would you define defaults?
[12:08:31] <kimundi> eddyb: Btw, I'd rather see variadics actually land first, and _then_ think about what to do with with - discussion about what would or what wouldn't be the best course of action using a feature that is not yet in the language is always horrible confusing to me, and seems to be a bit premature :P
[12:08:39] *** Quits: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net) (Ping timeout)
[12:09:05] <eddyb> kimundi: what is premature is delaying a feature as important as variadic generics, and I'm sorry I haven't pushed harder
[12:09:12] <lucian> eddyb: that can be done without variadics i think. you'd get [JSONValue], where you implement ToJSONValue on ints, strings and bools
[12:09:21] <kimundi> Oh! I doidn't mean it as that, sorry!
[12:09:27] <lucian> kimundi: :)
[12:09:35] <eddyb> lucian: except... we don't have such conversions
[12:10:03] <eddyb> I did think of them, at one point (in the context of generic literals, actually)
[12:10:31] <lucian> eddyb: right, but they're orthogonal to variadic generics i think. for example this http://hackage.haskell.org/package/aeson-0.6.1.0/docs/Data-Aeson.html should be doable with just a lang item for Read (in addition to Show)
[12:10:53] <eddyb> T could coerce to Option<T> (Some(T))
[12:11:36] <eddyb> lucian: Read sounds like Decodable
[12:11:37] <marc_> eddyb: fn new(a: int) -> Foo { Foo{a: a, b: 0}; }
[12:11:52] <marc_> That's the way I've done it at the moment
[12:12:00] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Input/output error)
[12:12:00] <eddyb> and what's your question?
[12:12:00] <marc_> I'm asking if there is a way of doing something like this:
[12:12:07] *** Quits: kris_ (kris@moz-4A0BC68A.dk.customer.tdc.net) (Ping timeout)
[12:12:15] <marc_> struct Foo { a: int, b: int = 0; }
[12:12:31] *** Joins: moostik (Icedove@moz-53E05E9C.w92-151.abo.wanadoo.fr)
[12:12:43] <eddyb> marc_: aah. there's Foo{a: a, ..struct_to_take_other_fields_from}
[12:12:50] *** Quits: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net) (Ping timeout)
[12:13:00] *** Joins: binsh (binsh@moz-54F7FD49.cpe.net.cable.rogers.com)
[12:13:14] *** Joins: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net)
[12:13:24] <eddyb> I should make a proposal for Foo {a: a, ..} to be equivalent to Foo {a: a, ..Default::default()}
[12:13:25] <marc_> But the caller is still broken, right?
[12:13:50] <marc_> Whereas with the method version they're not broken (but lose keywords)
[12:13:52] <eddyb> marc_: s/broken/visibly does something to get defaults into the structure/
[12:14:02] <eddyb> oooh, that's what you mean by keywords
[12:14:07] <eddyb> marc_: those are field names, heh
[12:14:13] * eddyb was confused there
[12:14:37] *** Quits: b1nd (b1nd@E3D8A436.45A6FC61.475248F5.IP) (Client exited)
[12:14:41] <marc_> Usually hiding things behind methods is a good idea
[12:14:50] <marc_> But sometimes it's nice just having the raw types
[12:14:58] <eddyb> it would be cool if you could do Foo {a} and get Foo {a: a, ..Default::default()}
[12:15:02] *** Joins: kris (kris@moz-147EE6DF.diku.dk)
[12:15:05] <marc_> Yeah exactly
[12:15:11] <eddyb> or field-specific defaults, but that might be trickier to implement
[12:15:17] <marc_> So if I add fields to Foo and I have 10_000 callers
[12:15:22] <marc_> I don't have to go change them all
[12:15:28] <eddyb> marc_: it's nice because JS/JSON
[12:15:37] <eddyb> or should I say JS/ON :D?
[12:16:34] <marc_> I'd be happy with kwargs in methods too (then I'd just always use methods)
[12:16:35] <eddyb> hmm, is there anything wrong with renaming Option to Maybe?
[12:16:46] <eddyb> Maybe/Some/None doesn't sound that bad of a combination
[12:16:49] <Ms2ger> Yes, churn
[12:16:54] <lucian> eddyb: Nothing is longer than None, that's what :)
[12:17:02] *** Joins: mib_hxjbhu (Mibbit@6BBA85E0.E57335F3.73513262.IP)
[12:17:07] <eddyb> lucian: see the trio I mentioned
[12:17:30] <eddyb> marc_: that's not realistic, unless you want to get a HashMap<&'static str, ~Any>
[12:17:55] <marc_> Hmm?
[12:18:09] <marc_> Surely the compiler could just do it?
[12:18:11] <eddyb> python isn't statically typed
[12:18:30] <lucian> eddyb: hmm. that would be a mashup of the ML and Haskell names. i'm not sure what would be gained, it could just confuse people familiar with either
[12:18:39] *** Quits: mib_hxjbhu (Mibbit@6BBA85E0.E57335F3.73513262.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[12:19:05] <eddyb> lucian: type Maybe<T> = Option<T>;
[12:19:17] <eddyb> it's like... one character less :))
[12:19:24] <marc_> fn foo(a: int, b: int); foo(b = 1, a = 2) // rewritten as foo(1, 2) at compile time
[12:19:34] <eddyb> marc_: oooh, that
[12:19:43] *** Quits: sigma (sigma@moz-9EAC972C.range86-184.btcentralplus.com) (Ping timeout)
[12:19:45] <lucian> eddyb: heh. at the cost of folks writing Just and Nothing and being surprised at the error messages :)
[12:19:48] <eddyb> pretty sure that's not kwargs, but named arguments
[12:20:18] <eddyb> marc_: except b = 1 is a valid Rust expression
[12:20:41] <eddyb> (it gives you () so you can't shoot yourself with it, but it's still an expression)
[12:20:46] <marc_> I think you get the point :-)
[12:21:16] <eddyb> marc_: foo(b: 1, a: 2) might work - search the issue list for "named parameters" or "named arguments"
[12:21:58] *** Joins: Ferreus (ferreus@moz-C5752C75.dip0.t-ipconnect.de)
[12:23:15] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[12:24:51] *** Joins: adridu59 (Mibbit@moz-E7A273CD.ac-paris.fr)
[12:25:09] <adridu59> is there a type that's u32 on 32-bit and u64 in 64-bit?
[12:25:20] <kimundi> uint and int
[12:25:23] *** Joins: Kynes (Kynes@moz-3DC6C6E7.mit.edu)
[12:25:43] *** Quits: binsh (binsh@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[12:25:52] <kimundi> uint and int in Rust are defined as pointer sized
[12:26:17] *** Joins: binsh (binsh@moz-54F7FD49.cpe.net.cable.rogers.com)
[12:26:39] *** Quits: vince (vince@87549D5D.A97DAB6F.A7E3DA15.IP) (Ping timeout)
[12:26:46] <adridu59> float was like that too... why was it removed? was there like rounding problems with an ambivalent repr?
[12:27:09] <kimundi> float was always f64
[12:27:22] <adridu59> oh ok
[12:27:31] <kimundi> ALso, unlike for integers, the destinction bettwen f32 and f64 was not as useful for diferent systems
[12:28:09] <kimundi> because depending on platform they could be equally fast, both slow, etc
[12:28:31] <strcat> well int/uint are only useful because they're pointer-size, so they're useful for indexing, etc.
[12:28:49] *** Joins: wry (wry@620605B3.71150E1A.237AE2BA.IP)
[12:28:57] *** Quits: Blub\1 (wry@620605B3.71150E1A.237AE2BA.IP) (Ping timeout)
[12:29:02] <kimundi> ANd floating point math breaks easier if a type if is f32 on one platform and f64 on another, because of precision differences
[12:30:23] <adridu59> yea that's I thought
[12:30:27] <adridu59> thanks for the explanations
[12:30:36] *** Quits: adridu59 (Mibbit@moz-E7A273CD.ac-paris.fr) (Quit: http://www.mibbit.com ajax IRC Client)
[12:30:46] *** Quits: kris (kris@moz-147EE6DF.diku.dk) (Ping timeout)
[12:30:47] *** Joins: kris (kris@moz-5A7B69C7.math.ku.dk)
[12:31:44] *** Joins: sigma (sigma@moz-1C81041B.range86-184.btcentralplus.com)
[12:34:54] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[12:35:33] *** Quits: olem (olem@moz-D8B40BE5.fbx.proxad.net) (Client exited)
[12:35:54] *** Joins: olem (olem@moz-D8B40BE5.fbx.proxad.net)
[12:36:17] <tq> Suppose I have an enum X {a,b} -- is it possible to have another enum Y {b,c} that shares values with X? Like enum class in C++11?
[12:36:22] *** Joins: Skif (emschwar@moz-4C5BB5A8.beyondbb.com)
[12:36:30] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[12:36:41] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[12:37:19] <pyon> If all the fields of a struct either implement Clone or do not implement Drop, does the struct itself automatically implement Clone?
[12:37:42] *** Quits: olem (olem@moz-D8B40BE5.fbx.proxad.net) (Ping timeout)
[12:37:51] <eddyb> pyon: no, you need #[deriving(Clone)]
[12:38:03] *** Quits: Skif (emschwar@moz-4C5BB5A8.beyondbb.com) (Ping timeout)
[12:38:11] <pyon> Ah!
[12:38:37] <eddyb> if you make that "or" an "and", it might be something worth having
[12:38:56] <eddyb> tq: with the same name? not really
[12:39:10] <eddyb> tq: if it's a C-like enum, you can share the numeric value, but not the name
[12:40:24] <tq> eddyb, hm. I see.
[12:40:57] <tq> I guess namespaces can help
[12:41:50] *** Joins: gwty (gwtypc@A3F4FE97.CFB6D583.BD94A9D5.IP)
[12:42:42] *** Quits: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net) (Ping timeout)
[12:43:07] *** Joins: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net)
[12:44:47] *** Quits: a_m0d (a_m0d@moz-322A4DE4.acanac.net) (Quit: Leaving.)
[12:45:11] *** Quits: kvanb (kvanb@moz-2C33D4E6.lnse3.lon.bigpond.net.au) (Quit: kvanb)
[12:45:28] *** Joins: spider-mario (spidermari@moz-2F72F6FF.dsl.quantic-telecom.net)
[12:45:30] <eibwen> are the structs laid out in memory exactly as C structs?
[12:45:38] *** Joins: ray (bernhard@moz-FF531B82.vie.surfer.at)
[12:45:39] <FliPPeh> As far as I know, yes
[12:45:45] <ray> hi what build system do you use?
[12:45:54] <ray> cmake?
[12:46:03] <FliPPeh> you = rust project or you = me?
[12:46:11] <ray> you = me
[12:46:18] <FliPPeh> GNU Make for great justice
[12:46:47] *** Joins: ptc (Adium@moz-192425C4.nyc.res.rr.com)
[12:47:11] *** Joins: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net)
[12:47:31] * lucian uses rustpkg
[12:47:35] *** Quits: wry (wry@620605B3.71150E1A.237AE2BA.IP) (Ping timeout)
[12:47:41] *** Joins: wry (wry@620605B3.71150E1A.237AE2BA.IP)
[12:48:29] *** Quits: ptc (Adium@moz-192425C4.nyc.res.rr.com) (Ping timeout)
[12:49:58] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[12:50:32] * Zr40 uses rustpkg from a Makefile
[12:51:28] <ray> thanks :)
[12:51:46] <ray> did you try to build an http server btw? shouldnt be that hard i think
[12:52:16] <ray> as a first example application to get into the language
[12:52:16] *** Quits: lucian (lucian@303F9692.4304AE1E.CE5E78F6.IP) (Ping timeout)
[12:52:31] <FliPPeh> I'd start with Hello World :>
[12:53:33] *** Joins: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[12:54:05] <eibwen> what to do after that? :)
[12:54:18] *** Quits: _Vi (vi@D7277DB6.6FF508C1.10C239DF.IP) (Ping timeout)
[12:55:10] *** Quits: kngl (Adium@moz-18BD1C.ipv4.evonet.be) (Quit: Leaving.)
[12:55:16] <FliPPeh> A HTTP server or a kernel, whatever you fancy
[12:55:41] *** Quits: m_kato (m_kato@moz-C286AD9A.bitcat.net) (Quit: Leaving...)
[12:58:59] <ray> is libuv already in btw?
[12:59:29] <ray> also is there support for async/yield keywords or do you use promises?
[12:59:45] *** Joins: nano (nano@moz-ED77243C.superkabel.de)
[13:00:07] <strcat> atm there is just blocking I/O, in M:N mode it's built on top of libuv's async I/O API
[13:00:25] <ray> M:N mode?
[13:00:26] <lucian> so for most practical purposes, the advantages of both
[13:00:33] <strcat> well not really
[13:00:47] <strcat> both act as blocking I/O
[13:01:06] <lucian> right, but that's not often an issue with tasks + channels
[13:01:08] <strcat> i.e. you need a task per thing you want to do concurrently
[13:01:11] <lucian> (Go has that model)
[13:01:24] <strcat> lucian: rust's M:N tasks aren't lighter than threads
[13:01:32] *** Quits: alonlevy (alon@moz-EB7C9CF3.telavivmakers.org) (Ping timeout)
[13:01:39] *** Joins: leslie1 (Adium@FB08E5F4.28296B3F.1795BCC4.IP)
[13:01:41] <lucian> oh, the stack changes :(
[13:02:06] <strcat> sync I/O + threads do work fine on 64-bit
[13:02:28] <strcat> does use more resources than multiplexing connections in one thread
[13:02:33] <strcat> well
[13:02:36] <strcat> on one stack*
[13:03:00] <lucian> i guess with lazily allocated stacks + 64 bit address space it shouldn't be that different?
[13:03:20] <lucian> ray: it can support a model similar to Go's, but the tasks aren't quite as cheap as goroutines
[13:03:34] <strcat> lucian: with overcommit, not much different
[13:03:54] <strcat> if you allocate 8MiB and touch 1 byte, it will consume 4K of real memory
[13:04:17] <strcat> but there's still overhead for allocating a lot of virtual memory afaik
[13:04:34] <lucian> i guess that depends on kernel
[13:04:47] <lucian> at least on linux it shouldn't matter
[13:05:00] <strcat> linux will happily let you allocate 128TiB of memory in a process
[13:05:28] <strcat> x86_64 has a 48-bit usable address space and then linux steals one bit
[13:05:32] <lucian> what i meant is that there's no overhead for it doing that, really
[13:05:58] *** Joins: ptc (Adium@moz-192425C4.nyc.res.rr.com)
[13:05:58] *** Quits: leslie1 (Adium@FB08E5F4.28296B3F.1795BCC4.IP) (Quit: Leaving.)
[13:06:21] <strcat> lucian: afaik it causes TLB misses and so on
[13:06:35] *** Parts: ptc (Adium@moz-192425C4.nyc.res.rr.com) ()
[13:06:37] *** Joins: omegaga_ (omegaga_@5AE3FDE2.4614C6DC.1348A864.IP)
[13:06:49] *** flaper87|afk is now known as flaper87
[13:07:14] *** Joins: leslie1 (Adium@FB08E5F4.28296B3F.1795BCC4.IP)
[13:07:16] *** Joins: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[13:08:17] *** Joins: LinearInterpol (RJones@moz-8A6454A9.ellsworth-hs.ellsworth.k12.me.us)
[13:08:49] *** Joins: kris_ (kris@moz-147EE6DF.diku.dk)
[13:08:53] *** Quits: kris (kris@moz-5A7B69C7.math.ku.dk) (Ping timeout)
[13:08:56] *** Quits: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net) (Ping timeout)
[13:09:16] <bjz> carter: beep
[13:09:30] <LinearInterpol> b00p.
[13:10:20] *** Joins: benjamin_ (benjamin@moz-F3225091.dip0.t-ipconnect.de)
[13:12:21] *** Quits: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net) (Ping timeout)
[13:12:42] *** Joins: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net)
[13:12:52] <pyon> I have a relative path to the working directory. How do I transform it into an absolute path?
[13:13:42] <kimundi> pyon: Get a absolute path to the cwd, and concatenate them?
[13:14:12] *** Joins: sanxiyn (tinuviel@B4104EBB.3CC170B1.1E14B209.IP)
[13:15:22] <pyon> Is there any way to get an absolute path to the cwd, without dropping down to POSIX' getcwd() ?
[13:15:40] *** Joins: sluggo (Mibbit@moz-AD302F08.dip0.t-ipconnect.de)
[13:15:50] <strcat> rusti: std::os::getcwd()
[13:15:51] -rusti- std::path::posix::Path{repr: ~[47u8, 104u8, 111u8, 109u8, 101u8, 47u8, 114u8, 117u8, 115u8, 116u8], sepidx: Some(5u)}
[13:16:07] <strcat> rusti: std::os::getcwd().display()
[13:16:09] -rusti- pastebinned 17 lines of output: http://ix.io/9U0
[13:16:26] <pyon> strcat: ty
[13:16:28] <strcat> rusti: let x = std::os::getcwd(); x.display()
[13:16:30] -rusti- pastebinned 18 lines of output: http://ix.io/9U1
[13:16:32] *** Quits: Sgeo (quassel@moz-4E71E7BB.dyn.optonline.net) (Connection reset by peer)
[13:16:38] *** Quits: sluggo (Mibbit@moz-AD302F08.dip0.t-ipconnect.de) (Quit: http://www.mibbit.com ajax IRC Client)
[13:16:45] <strcat> oh that's what it's complaining about
[13:16:47] <pyon> Oh, dumb me was searching extra.
[13:16:53] <LinearInterpol> woah.
[13:17:00] <LinearInterpol> let r = { }
[13:17:02] <LinearInterpol> You can do that?
[13:17:07] <strcat> LinearInterpol: yes
[13:17:12] <LinearInterpol> Wat.
[13:17:13] <strcat> { statements } // is an expression
[13:17:23] <LinearInterpol> But how do you do a let inside of that? Wat?!
[13:17:31] <tiffany> rusti: let r = { }; r
[13:17:31] -rusti- ()
[13:17:34] <strcat> LinearInterpol: let pattern = expr;
[13:17:36] <strcat> is the grammar
[13:17:44] <LinearInterpol> Wow.
[13:17:45] <strcat> { let x = 5; x } is an expression
[13:17:49] <LinearInterpol> That's so friggin' cool.
[13:17:54] <strcat> rusti: let y = { let x = 5; x }; y
[13:17:54] -rusti- 5
[13:17:57] <LinearInterpol> (Sorry, just admiring it.)
[13:17:57] <kimundi> rusti: let a = { let b = { let c = { 5}; c}; b}; a
[13:17:58] -rusti- 5
[13:18:15] <tiffany> { } is an expression whose result is (), let r = takes that expression and evaluates it, resulting in r being ()
[13:18:25] <LinearInterpol> awesooome.
[13:18:31] <LinearInterpol> Also, I have a question about that.. ().
[13:18:36] <LinearInterpol> Can I do....
[13:18:37] <sanxiyn> rusti: std::os::getcwd().display().to_str()
[13:18:39] <LinearInterpol> let a = () ?
[13:18:39] -rusti- pastebinned 13 lines of output: http://ix.io/9U2
[13:18:45] <strcat> LinearInterpol: sure
[13:18:46] <kimundi> LinearInterpol: https://gist.github.com/huonw/8435502
[13:18:50] <tiffany> rusti: let a = (); a
[13:18:51] -rusti- ()
[13:18:54] <LinearInterpol> Wild.
[13:18:54] <strcat> () is an (the only) instance of the type ()
[13:19:05] <LinearInterpol> I like your bot rusti.
[13:19:06] <kimundi> rusti: util::size_of::<()>()
[13:19:07] <strcat> can think of it as the empty tuple if you want ;p
[13:19:08] -rusti- pastebinned 13 lines of output: http://ix.io/9U3
[13:19:19] <LinearInterpol> That's what I'm kinda thinkin' of it as. I like that approach.
[13:19:21] <kimundi> rusti: ::std::util::size_of::<()>()
[13:19:23] -rusti- pastebinned 7 lines of output: http://ix.io/9U4
[13:19:27] <strcat> rusti: ()
[13:19:28] -rusti- ()
[13:19:29] <strcat> rusti: (5,)
[13:19:30] -rusti- (5,)
[13:19:31] <strcat> rusti: (5, 2)
[13:19:37] -rusti- timeout triggered!
[13:19:39] <strcat> rusti: (5, 2)
[13:19:39] <LinearInterpol> Do you have the source for println!() somewhere?
[13:19:40] -rusti- (5, 2)
[13:19:49] <kimundi> LinearInterpol: gimme aminute
[13:19:55] <LinearInterpol> I'm wondering how you can retrieve the type.
[13:19:59] <LinearInterpol> From something like that.
[13:20:25] <strcat> LinearInterpol: well println! has {:?} which is scary/slow reflection-based printing
[13:20:28] <strcat> using std::repr
[13:20:46] <LinearInterpol> Any better way?
[13:20:54] <strcat> you just want a type name? as a string?
[13:20:58] <LinearInterpol> Yeah.
[13:21:06] <kimundi> LinearInterpol: Right now, all std macros are injected by the compiler, and defined here: https://github.com/mozilla/rust/blob/master/src/libsyntax/ext/expand.rs#L671
[13:21:20] <Zr40> strcat: str::os::getcwd().display() and let x = std::os::getcwd(); x.display() seem equivalent to me, yet the first one isn't valid. How come? (I hit this a few hours ago)
[13:21:46] <kimundi> Zr40: language issue with the temporary lifetime of the return value of getcwd()
[13:21:49] <strcat> rusti: fn name<T>(x: &T) -> &'static str { unsafe { (*std::unstable::intrinsics::get_tydesc::<T>()).name } } name(&5)
[13:21:50] -rusti- <anon>:10:20: 10:21 warning: unused variable: `x`, #[warn(unused_variable)] on by default
[13:21:50] -rusti- <anon>:10         fn name<T>(x: &T) -> &'static str { unsafe { (*std::unstable::intrinsics::get_tydesc::<T>()).name } } name(&5)
[13:21:50] -rusti-                              ^
[13:21:50] -rusti- "int"
[13:21:57] <strcat> rusti: fn name<T>(_: &T) -> &'static str { unsafe { (*std::unstable::intrinsics::get_tydesc::<T>()).name } } name(&5)
[13:21:58] -rusti- "int"
[13:22:04] <strcat> rusti: fn name<T>(_: &T) -> &'static str { unsafe { (*std::unstable::intrinsics::get_tydesc::<T>()).name } } name(&Some(5))
[13:22:04] -rusti- "std::option::Option<int>"
[13:22:06] <LinearInterpol> o_o
[13:22:07] <kimundi> Zr40: will hopefully finally be fixed during the next week
[13:22:21] <strcat> LinearInterpol: well you wanted to know ;p
[13:22:31] <LinearInterpol> ..I'llll get back to you on that, hehe.
[13:22:33] <Zr40> kimundi: ah, good to hear :)
[13:22:58] <strcat> Zr40: just because of temporary lifetimes atm
[13:23:25] <strcat> if foo() returns T, and .bar() takes &'a T and returns &'a U
[13:23:30] <strcat> like...
[13:24:03] *** Joins: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[13:24:44] *** Joins: canhtak (canhtak@moz-4B5B3414.wl.t.ulaval.ca)
[13:24:46] <strcat> rusti: fn foo() -> ~int { ~5 } fn bar<'a>(x: &'a ~int) -> &'a ~int { x } let x = foo(); *bar(&x)
[13:24:48] -rusti- pastebinned 7 lines of output: http://ix.io/9U5
[13:25:01] <strcat> rusti: fn foo() -> ~int { ~5 } fn bar<'a>(x: &'a ~int) -> &'a ~int { x } let x = foo(); **bar(&x)
[13:25:02] -rusti- 5
[13:25:13] <strcat> rusti: fn foo() -> ~int { ~5 } fn bar<'a>(x: &'a ~int) -> &'a ~int { x } **bar(foo())
[13:25:22] -rusti- failed to pastebin 7 lines of output
[13:25:28] <strcat> stupid pastebin sites
[13:25:31] <strcat> rusti: fn foo() -> ~int { ~5 } fn bar<'a>(x: &'a ~int) -> &'a ~int { x } **bar(foo())
[13:25:33] -rusti- pastebinned 7 lines of output: http://ix.io/9U6
[13:25:44] <strcat> rusti: fn foo() -> ~int { ~5 } fn bar<'a>(x: &'a ~int) -> &'a ~int { x } **bar(&foo())
[13:25:46] -rusti- pastebinned 13 lines of output: http://ix.io/9U7
[13:25:54] *** Joins: dmz (Mibbit@moz-F30E0473.cpe.net.cable.rogers.com)
[13:26:01] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[13:26:07] *** Joins: kngl (Adium@moz-18BD1C.ipv4.evonet.be)
[13:26:08] <strcat> Zr40: anyway it just doesn't know how to make the return value of foo() live long enough
[13:26:16] <strcat> the method call is implicitly doing a borrow via &self
[13:26:49] <LinearInterpol> how long until the macros aren't injected by the compiler?
[13:27:16] *** Quits: binsh (binsh@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[13:27:55] <kimundi> LinearInterpol: Incidentially, that too might be resolvable starting somewhere next week :P - we have a patch for loadable syntax extions in the queue, which would ultimatly allow defining those macros in libstd
[13:28:15] *** Joins: Sorella (queen@9D963F5D.DF5D8AE7.54BCAB54.IP)
[13:28:16] <LinearInterpol> That's unbelievably awesome.
[13:28:25] *** Quits: new_one (new_one@moz-D538194E.rice.edu) (Ping timeout)
[13:28:38] <LinearInterpol> What about "for" loops?
[13:28:41] <LinearInterpol> That still a hack?
[13:28:45] <strcat> yes
[13:28:54] <LinearInterpol> Any plans to change?
[13:28:55] <kimundi> To elaborate: right now we can neither import nor export macros from/to a crate
[13:29:03] <LinearInterpol> Oh, yikes.
[13:29:50] <kimundi> Because they only exits in a compiler phase that runs before the phases that know about stuff like modules and external crates :P
[13:30:13] <LinearInterpol> If that's fixed this week, I'm gonna set up a buildbot.
[13:30:22] <LinearInterpol> Get me some o' that master branch.
[13:30:29] <kimundi> LinearInterpol: Which os are you using?
[13:30:39] <LinearInterpol> Windows. Unfortunately. I might use my Arch VM for this.
[13:30:50] <kimundi> Arch has nightlys
[13:30:53] <LinearInterpol> Sexy.
[13:31:05] <kimundi> courtesy of strcat here :)
[13:32:20] *** Joins: _Vi (vi@D7277DB6.6FF508C1.10C239DF.IP)
[13:32:22] * kimundi should try installing Rust on windows himself on of these days
[13:32:30] <LinearInterpol> It works well!
[13:32:40] <LinearInterpol> Though "rust" has been gone. I miss "rust run <file>"
[13:33:42] * sanxiyn looks forward to rvalue lifetime change landing
[13:34:29] *** Quits: leslie1 (Adium@FB08E5F4.28296B3F.1795BCC4.IP) (Quit: Leaving.)
[13:34:38] *** Joins: leslie1 (Adium@moz-454B76DB.members.linode.com)
[13:35:44] <kimundi> Me too, especially for examples it will be nice to have things like "for x in [1,2,3].iter() {}" actually work :P
[13:37:10] *** Joins: Skif (emschwar@moz-4C5BB5A8.beyondbb.com)
[13:37:18] *** Quits: leslie1 (Adium@moz-454B76DB.members.linode.com) (Ping timeout)
[13:37:40] <Zr40> is there a github issue about that?
[13:38:42] <kimundi> Zr40: What, the temporary lifetimes issue?
[13:38:52] *** Quits: Skif (emschwar@moz-4C5BB5A8.beyondbb.com) (Ping timeout)
[13:38:54] *** Quits: kngl (Adium@moz-18BD1C.ipv4.evonet.be) (Quit: Leaving.)
[13:38:58] <Zr40> kimundi: yes
[13:39:34] <kimundi> Yes, there has been one for months, and nmatsakis is almost ready to land the patch that will fix it
[13:40:01] <Ms2ger> !
[13:40:07] <Zr40> that's #3511, right?
[13:40:12] <sanxiyn> Zr40: Yes
[13:40:22] <sanxiyn> Zr40: You also want to look at #11585
[13:40:26] <kimundi> https://github.com/mozilla/rust/pull/11585
[13:40:44] <sanxiyn> And these:
[13:40:46] <sanxiyn> http://smallcultfollowing.com/babysteps/blog/2012/09/15/rvalue-lifetimes/
[13:40:48] <sanxiyn> http://smallcultfollowing.com/babysteps/blog/2014/01/09/rvalue-lifetimes-in-rust/
[13:40:51] <sanxiyn> (Note years!)
[13:41:02] <Zr40> baby steps indeed ;)
[13:43:32] *** Joins: zakora (NC@moz-28181BF.fbx.proxad.net)
[13:43:33] *** Quits: zakora (NC@moz-28181BF.fbx.proxad.net) (Max SendQ exceeded)
[13:43:43] *** Joins: leslie1 (Adium@FB08E5F4.28296B3F.1795BCC4.IP)
[13:43:58] *** Joins: zakora (NC@moz-28181BF.fbx.proxad.net)
[13:43:59] *** Quits: zakora (NC@moz-28181BF.fbx.proxad.net) (Max SendQ exceeded)
[13:44:24] *** Joins: zakora (NC@moz-28181BF.fbx.proxad.net)
[13:44:25] *** Quits: zakora (NC@moz-28181BF.fbx.proxad.net) (Max SendQ exceeded)
[13:44:54] *** Joins: zakora (NC@moz-28181BF.fbx.proxad.net)
[13:44:55] *** Quits: zakora (NC@moz-28181BF.fbx.proxad.net) (Max SendQ exceeded)
[13:44:59] *** Quits: Ms2ger (Ms2ger@AA55AE55.592AEF45.F15B0BB3.IP) (Ping timeout)
[13:45:23] <Cevn> What's the best way to iterate through [Path]?
[13:45:27] *** Joins: olem (olem@moz-4512FDE8.rev.sfr.net)
[13:45:31] *** Joins: AvianFlu (AvianFlu@moz-51534E77.c3-0.43d-ubr2.qens-43d.ny.cable.rcn.com)
[13:45:35] *** Joins: zakora (NC@moz-28181BF.fbx.proxad.net)
[13:45:36] *** Quits: zakora (NC@moz-28181BF.fbx.proxad.net) (Max SendQ exceeded)
[13:45:58] <Cevn> i'm getting a message like "src/ls.rs:10:3: 14:10 error: type `&mut ~[std::path::posix::Path]` does not implement any method in scope named `next`
[13:46:14] *** Joins: zakora (NC@moz-28181BF.fbx.proxad.net)
[13:46:15] *** Quits: zakora (NC@moz-28181BF.fbx.proxad.net) (Max SendQ exceeded)
[13:46:19] *** Quits: johnsoft (johnsoft@moz-7E09A266.neo.res.rr.com) (Connection reset by peer)
[13:46:30] <Zr40> .iter()
[13:46:39] <kimundi> Cevn: need to get an iterator explcitly with a call to .iter()
[13:46:44] <Cevn> Ah i see, thanks 
[13:46:44] *** Quits: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Quit: lkuper)
[13:46:50] *** Joins: zakora (NC@moz-28181BF.fbx.proxad.net)
[13:46:51] *** Quits: zakora (NC@moz-28181BF.fbx.proxad.net) (Max SendQ exceeded)
[13:47:16] *** Joins: zakora (NC@moz-28181BF.fbx.proxad.net)
[13:47:17] *** Quits: zakora (NC@moz-28181BF.fbx.proxad.net) (Max SendQ exceeded)
[13:47:50] *** Joins: zakora (NC@moz-28181BF.fbx.proxad.net)
[13:47:51] *** Quits: zakora (NC@moz-28181BF.fbx.proxad.net) (Max SendQ exceeded)
[13:48:09] *** Parts: Fill (Fill@moz-1107002D.kimsufi.com) (Leaving)
[13:48:16] *** Joins: zakora (NC@moz-28181BF.fbx.proxad.net)
[13:48:17] *** Quits: zakora (NC@moz-28181BF.fbx.proxad.net) (Max SendQ exceeded)
[13:48:19] *** Quits: dmz (Mibbit@moz-F30E0473.cpe.net.cable.rogers.com) (Quit: http://www.mibbit.com ajax IRC Client)
[13:48:43] *** Joins: zakora (NC@moz-28181BF.fbx.proxad.net)
[13:52:09] *** Joins: chunyang (Thunderbir@23059940.87A827F.C8ED823E.IP)
[13:52:29] <sanxiyn> r? https://github.com/mozilla/rust/pull/11599
[13:52:34] *** Quits: gwty (gwtypc@A3F4FE97.CFB6D583.BD94A9D5.IP) (Ping timeout)
[13:53:57] *** Quits: chunyang (Thunderbir@23059940.87A827F.C8ED823E.IP) (Quit: chunyang)
[13:54:09] *** Joins: kngl (Adium@moz-18BD1C.ipv4.evonet.be)
[13:54:29] *** Joins: johnsoft (johnsoft@moz-7E09A266.neo.res.rr.com)
[13:55:57] *** Joins: jfbk (jfbk@moz-EEA9CFB3.nyc.res.rr.com)
[13:58:01] *** Quits: copumpkin (copumpkin@moz-FC353116.dyn.optonline.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz)
[13:59:56] *** Joins: Ms2ger (Ms2ger@B085914A.CFB9C8ED.F15B0BB3.IP)
[14:01:35] *** Joins: Denommus (user@3DB4BE1F.52AB7E0B.B9657DD5.IP)
[14:01:49] <leslie1> I have a  problem about vim, when opening .rs file, my vim always treats it as hercules file
[14:02:00] <leslie1> how to fix it?
[14:03:43] <olem> leslie1: you could have a look at http://beerpla.net/2008/04/02/how-to-add-a-vim-file-extension-to-syntax-highlighting/ 
[14:04:02] <olem> leslie1: that will help you indicate to vim which file association you'd prefer for .rs files.
[14:04:28] <olem> leslie1: and use your .vimrc to persist your prefered association when found.
[14:04:34] <olem> leslie1: hope this
[14:04:44] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.2)
[14:04:46] <olem> leslie1: will helps.
[14:05:09] *** Quits: kngl (Adium@moz-18BD1C.ipv4.evonet.be) (Quit: Leaving.)
[14:05:10] *** Joins: vadimg (vadimg@BCFFDE00.DF0A212.39C00A7A.IP)
[14:05:28] <Zr40> leslie1: I've copied rust's src/etc/vim/** to ~/.vim/
[14:05:40] <Zr40> leslie1: that should help
[14:06:02] <leslie1> I will give it a try
[14:06:19] *** Joins: alonlevy (alon@moz-61A0AD83.red.bezeqint.net)
[14:06:25] <leslie1> I am using vundle managing plugins
[14:07:34] *** Joins: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[14:08:36] <olem> Zr40: mthx, works fine that way!
[14:09:13] *** Quits: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net) (Ping timeout)
[14:09:23] *** Quits: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net) (Ping timeout)
[14:10:15] *** Quits: canhtak (canhtak@moz-4B5B3414.wl.t.ulaval.ca) (Quit: canhtak)
[14:12:44] <leslie1> I know the problem now
[14:12:47] <leslie1> Note: Vundle will not automatically detect Rust files properly if filetype on is executed before Vundle. Please check the https://github.com/gmarik/vundle#quick-start for more details.
[14:13:25] <leslie1> thks guys
[14:14:19] *** Quits: pzol (pzol@322A273C.DEB41A6D.AADC76B.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz)
[14:14:42] <Denommus> hi
[14:15:15] <Denommus> does the module system support more than one crate in the same project, or do I need a Makefile for that?
[14:16:44] *** jorendorff_away is now known as jorendorff
[14:16:58] <ray> btw, when will libuv be in?
[14:17:48] <olem> Denommus: as a crate is the unit the compilator deal with, I guess it can handle only one crate at a time - so you'd need a rustc call per crate. I guess.
[14:18:05] <olem> Denommus: on the other hand, a module can be called/used by more than one crate.
[14:18:11] <sanxiyn> ray: ?
[14:18:21] <olem> Denommus: just a guess - I'm not a rust guru, just discovering it.
[14:18:22] <ray> sanxiyn: the async lib
[14:18:24] <ray> iirc
[14:18:31] <sanxiyn> ray: I don't understand your question
[14:18:35] <olsonjeffery> ray: it's very much "in"
[14:18:44] <olsonjeffery> the default runtime runs atop it
[14:18:49] <ray> in as in built into the runtime
[14:18:56] <olsonjeffery> the rust mappings are in-tree, right now, in librustuv
[14:19:07] <ray> ok, so you can already do async io?
[14:19:08] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[14:19:11] <sanxiyn> ray: No
[14:19:15] <olsonjeffery> the latest stable release is on it
[14:19:16] <sanxiyn> No async IO API
[14:19:28] <sanxiyn> Low priority
[14:19:35] <olsonjeffery> ray: rust's IO api has synchronous semantics
[14:19:42] <sanxiyn> olsonjeffery: Well, runtime provides synchronous IO API on top of async library
[14:19:44] *** Quits: leslie1 (Adium@FB08E5F4.28296B3F.1795BCC4.IP) (Ping timeout)
[14:19:46] <olsonjeffery> but libuv behaves in the usual fashion below the hood
[14:20:03] *** Joins: olem_ (olem@moz-D8B40BE5.fbx.proxad.net)
[14:20:12] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[14:20:16] <ray> i see thanks :)
[14:20:17] <sanxiyn> ray: As far as I know no one is actively working on exposing asynchronous IO API. If you want to do the work, great!
[14:20:21] <olsonjeffery> ray: this is a good place for you to get started: http://static.rust-lang.org/doc/master/guide-runtime.html
[14:21:03] *** Quits: olem (olem@moz-4512FDE8.rev.sfr.net) (Ping timeout)
[14:21:10] <sanxiyn> Personally I find async *API* hard to use, so I am not interested
[14:21:20] <sanxiyn> (async functionality is great. API is not)
[14:21:29] *** Joins: kngl (Adium@moz-18BD1C.ipv4.evonet.be)
[14:21:31] <olsonjeffery> you can get async semantics with multiple tasks in the same schedpool + msg'ing, but it has quite a bit of API over how raw libuv works or something more low-level like, say, nginx
[14:21:47] <olsonjeffery> API/perf overhead, i mean
[14:21:51] <Denommus> olem_: that's also what I'm thinking
[14:21:58] <olsonjeffery> over how raw libuv works
[14:22:43] *** Joins: mib_q4xp9p (Mibbit@A44F0DA2.4F59504F.AE450E80.IP)
[14:23:03] *** Joins: leslie1 (Adium@FB08E5F4.28296B3F.1795BCC4.IP)
[14:23:48] *** Quits: mib_q4xp9p (Mibbit@A44F0DA2.4F59504F.AE450E80.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[14:23:52] <olsonjeffery> and, yes. short of some kind of serious codegen smoke and mirrors (eg async/await in c# 5.0 or some kind of FRP extension) a "true" async API is going to be pretty terrible in rust
[14:24:05] <olsonjeffery> <-- wrote the first few revisions of what became "the runtime".
[14:24:24] <olsonjeffery> suffice to say, it was so terrible that it pretty much drove brson to envision what became the current approach
[14:24:27] *** Quits: moostik (Icedove@moz-53E05E9C.w92-151.abo.wanadoo.fr) (Ping timeout)
[14:24:50] *** Quits: zakora (NC@moz-28181BF.fbx.proxad.net) (Quit: Computer has gone to sleep.)
[14:24:58] <olsonjeffery> </tangent>
[14:25:59] <nmatsakis> Zr40 sanxiyn kimundi : regarding #3511, I need to write a follow up with the actual rules that I implemented described in English...
[14:26:07] <nmatsakis> does anyone have any experience using bugpoint?
[14:26:30] <sanxiyn> nmatsakis: I got the impression you implemented 2C?
[14:26:57] <sanxiyn> nmatsakis: I've used bugpoint
[14:27:02] <nmatsakis> sanxiyn: actually a variation thereof
[14:27:12] *** Joins: canhtak (canhtak@moz-4B5B3414.wl.t.ulaval.ca)
[14:27:13] <nmatsakis> 2D I guess ;)
[14:27:44] <nmatsakis> sanxiyn: I am getting a crash in LLVM's optimization routines,
[14:27:50] <nmatsakis> but when I run bugpoint,
[14:27:58] <nmatsakis> it tells me something about not being able to find a suitable interpreter etc
[14:28:09] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[14:28:16] <nmatsakis> I don't really understand what it's doing
[14:28:51] <nmatsakis> must be I'm doing *something* wrong
[14:29:13] <sanxiyn> nmatsakis: How did you run it?
[14:29:21] <nmatsakis> bugpoint foo.bc --args llc -O3
[14:29:30] *** Quits: victorporof (victorporo@416E2802.271BFD43.9B1E38F4.IP) (Quit: victorporof)
[14:29:35] <nmatsakis> actually the -O3 isn't needed, just llc foo.bc will crash
[14:29:38] *** Joins: victorporof (victorporo@416E2802.271BFD43.9B1E38F4.IP)
[14:29:44] *** Joins: zakora (NC@moz-28181BF.fbx.proxad.net)
[14:29:45] *** Quits: zakora (NC@moz-28181BF.fbx.proxad.net) (Max SendQ exceeded)
[14:29:53] *** Joins: new_one (new_one@moz-D538194E.rice.edu)
[14:29:58] *** Parts: leslie1 (Adium@FB08E5F4.28296B3F.1795BCC4.IP) ()
[14:30:10] *** Joins: zakora (NC@moz-28181BF.fbx.proxad.net)
[14:30:11] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[14:30:11] *** Quits: zakora (NC@moz-28181BF.fbx.proxad.net) (Max SendQ exceeded)
[14:30:36] *** Joins: zakora (NC@moz-28181BF.fbx.proxad.net)
[14:30:37] *** Quits: zakora (NC@moz-28181BF.fbx.proxad.net) (Max SendQ exceeded)
[14:30:39] *** Quits: LinearInterpol (RJones@moz-8A6454A9.ellsworth-hs.ellsworth.k12.me.us) (Ping timeout)
[14:30:53] *** Joins: kvark (Mibbit@9A8A5739.49975FB2.AE2D72A6.IP)
[14:31:02] *** Joins: zakora (NC@moz-28181BF.fbx.proxad.net)
[14:31:03] *** Quits: zakora (NC@moz-28181BF.fbx.proxad.net) (Max SendQ exceeded)
[14:31:16] <nmatsakis> whatever, I do, it keeps saying this: Sorry, I can't automatically select a safe interpreter!
[14:31:41] *** Quits: andre (andre@CA528A4A.45A4338E.8EE27E6.IP) (Ping timeout)
[14:31:42] <Ms2ger> "None of my interpreters are written in rust"
[14:31:44] *** Joins: zakora (NC@moz-28181BF.fbx.proxad.net)
[14:31:45] *** Quits: zakora (NC@moz-28181BF.fbx.proxad.net) (Max SendQ exceeded)
[14:31:47] *** Quits: rca (rcatolino@moz-FBA8CEE6.adsl.proxad.net) (Ping timeout)
[14:31:52] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[14:32:09] <sanxiyn> nmatsakis: As I understand, you shouldn't need --args at all for crash bugs...
[14:32:17] <sanxiyn> nmatsakis: Try bugpoint -run-llc foo.bc
[14:32:19] *** Joins: pepper_chico (pepper_chi@moz-13107F6.dsl.telesp.net.br)
[14:32:29] *** Joins: zakora (NC@moz-28181BF.fbx.proxad.net)
[14:32:38] <sanxiyn> --args is for miscompilation
[14:32:49] <nmatsakis> sanxiyn: ok. I tried that too already though
[14:32:50] *** Joins: andre (andre@CA528A4A.45A4338E.8EE27E6.IP)
[14:32:53] <nmatsakis> I was just reading the bugpoint source,
[14:33:02] <nmatsakis> as far as I can tell --run-llc or -run-llc (whichever it is) ought to work
[14:33:10] <rdn> Is @ deprecated?
[14:33:36] <nmatsakis> yes.
[14:33:48] <Ms2ger> nmatsakis, want to rid servo of it? :)
[14:33:56] <sanxiyn> nmatsakis: Can you post .bc somewhere?
[14:34:06] *** Quits: jensnockert (jensnocker@moz-C4B24C3.customers.ownit.se) (Ping timeout)
[14:34:36] <nmatsakis> Ms2ger: not until pnkfelix gets GC<T> working ;)
[14:35:00] *** Quits: canhtak (canhtak@moz-4B5B3414.wl.t.ulaval.ca) (Quit: canhtak)
[14:35:02] <nmatsakis> sanxiyn: http://smallcultfollowing.com/deriving-to-str.bc
[14:35:21] <sanxiyn> Crash reproduced
[14:36:05] <nmatsakis> sanxiyn: ah, --llc-safe seems to work
[14:36:14] <nmatsakis> whatever THAT means
[14:36:21] *** Quits: omegaga_ (omegaga_@5AE3FDE2.4614C6DC.1348A864.IP) (Quit: Leaving...)
[14:36:23] <sanxiyn> That's very bizarre
[14:36:48] <nmatsakis> now the question is: what do I make of this reduced output :)
[14:36:59] <pepper_chico> guys, I'm getting some difficult to bent my mind around what is a enum variation, coming from c and c++ background, enums are simple labels to constants, now these enum variations, look like a function prototype to store data, my difficult is in not seeing them matching anything in the type system, they are not struct, nor function call, they are just a thing in itself? just a "enum variation" that can store values through a function 
[14:36:59] <pepper_chico> call syntax and are of the given enum type?
[14:37:03] <nmatsakis> hopefully it will lead me to understand why my patch is causing a crash...and if I can workaround it.
[14:37:26] <nmatsakis> pepper_chico: you can think of an enum in Rust as the combination of an enum + union in C, where the union has one entry for each kind
[14:37:39] <nmatsakis> *for each variant
[14:37:51] <pepper_chico> hmm, ok, but
[14:37:57] *** Quits: kngl (Adium@moz-18BD1C.ipv4.evonet.be) (Quit: Leaving.)
[14:38:16] <pepper_chico> it's like the union used a function prototype syntax to store data
[14:38:26] <pepper_chico> which is kind of different
[14:38:54] <nmatsakis> yes, the fields are anonymous
[14:39:12] *** Quits: jfbk (jfbk@moz-EEA9CFB3.nyc.res.rr.com) (Quit: )
[14:39:17] <nmatsakis> usually you don't have very many; if you do, you're better off making a struct type to store the fields
[14:39:27] <sanxiyn> pepper_chico: Given enum Value { Int(i32), Float(f32) }
[14:39:31] <sanxiyn> Value is a variant type
[14:39:41] <sanxiyn> Int and Float are constructors that return Value
[14:39:54] <sanxiyn> Int and Float are not types
[14:40:08] <pepper_chico> hmmm
[14:40:14] <pepper_chico> good pov
[14:40:30] <pepper_chico> like constructors, which can be matched
[14:41:05] <kimundi> pepper_chico: The Foo(...) syntax is just how named tuples look like in rust: we also have "struct Foo(Bar);"
[14:41:25] <ray> iirc that if things go out of scope theyre freed right? what about returning a newly created type from a function?
[14:41:51] *** Quits: csherratt (csherratt@moz-8D848271.cpe.teksavvy.com) (Ping timeout)
[14:41:55] <kimundi> ray: Then that type goes not out of scope, but transfers ownership to the caller
[14:41:55] <pepper_chico> kimundi, I've seen about named tuples, but enum variations are not that I think
[14:42:01] *** Quits: vadimg (vadimg@BCFFDE00.DF0A212.39C00A7A.IP) (Ping timeout)
[14:42:15] <ray> i see thanks :)
[14:42:23] <ray> does it matter if its a pointer or a value?
[14:42:35] <sanxiyn> ray: No
[14:42:49] <kimundi> pepper_chico: enum _variants_ are just differnt in that they are differntly named constructors for the same type, while for a struct Foo(Bar);, the type and constructr name is identical
[14:43:09] *** Joins: rca (rcatolino@moz-FBA8CEE6.adsl.proxad.net)
[14:43:16] *** Joins: csherratt (csherratt@moz-8D848271.cpe.teksavvy.com)
[14:43:17] <pepper_chico> kimundi, by the way, I've not seen something like struct Foo(Bar) yet I think, can you provide a short sample?
[14:43:41] <pepper_chico> ah ok
[14:43:47] <kimundi> rusti: struct Ascii(u8); let a = Ascii(127); a
[14:43:52] -rusti- main::Ascii(127u8)
[14:44:49] <kimundi> rusti: struct Point(f32, f32); let a = Point(0.5, 3); a
[14:44:52] -rusti- pastebinned 7 lines of output: http://ix.io/9U9
[14:45:01] <kimundi> rusti: struct Point(f32, f32); let a = Point(0.5f, 3f); a
[14:45:04] -rusti- pastebinned 6 lines of output: http://ix.io/9Ua
[14:45:21] <SiegeLord> Hmm... it's interesting that it adds a main:: there
[14:45:35] <SiegeLord> Can you actually refer to Ascii outside of main?
[14:45:35] <Yurume> an artifact of TypeId I think
[14:45:44] <kimundi> SiegeLord: Its in a mian function, which means its in a main module
[14:45:46] <sanxiyn> rusti: struct Point(f32, f32); let a = Point(0.5, 3.0); a
[14:45:47] -rusti- main::Point(0.5f32, 3f32)
[14:45:49] <ray> how do i free memory?
[14:45:51] *** Joins: jensnockert (jensnocker@moz-C4B24C3.customers.ownit.se)
[14:45:56] <kimundi> rusti: struct Point(f32, f32); let a = Point(0.5f32, 3f32); a
[14:45:57] -rusti- main::Point(0.5f32, 3f32)
[14:46:07] <sanxiyn> kimundi: Inference works fine (as you can see)
[14:46:07] <kimundi> ray: You don't manually in safe Rust code
[14:46:13] <Yurume> ray, you can use `drop` function: let x = ~42; drop(x); /* x is explicitly freed at this point */
[14:46:13] <pepper_chico> kimundi, can it be used in the sense of a c++ constructor? since struct can have members like, struct Foo { x: int, y: int }, can I mix both what you're saying with this common usage for struct?
[14:46:15] <sanxiyn> kimundi: The problem was "3" was int
[14:46:28] <kimundi> ooh
[14:46:32] <Yurume> kimundi, I didn't know, but there is std::prelude::drop (!)
[14:46:50] <ray> i see, whats the recommended way to do it in safe code? for instance consider a loop with input that is appended to a list
[14:46:52] <Yurume> ray, but you normally don't have to do so
[14:46:53] <SiegeLord> If so, it'd be easy to resolve returning local types issue... you'd write fn test() -> test::Struct or something
[14:47:14] <sanxiyn> ray: You don't
[14:47:37] <kimundi> the drop function is nothing special - it doesn't free memory, it just transfers ownership of a value into it, which _then_ results in the value being freed, following normal Rust semantics
[14:48:13] <sanxiyn> pepper_chico: Rust has no analogue of C++ constructor
[14:48:15] <ray> or if i have a list and i make operations on it and delete the stuff in the list that i just used
[14:48:21] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Client exited)
[14:48:24] <ray> map reduce?
[14:48:29] <Yurume> ray, okay, forget about `drop`, you don't have to do so unless you are *really* running out of memory since the compiler always frees ~T when it is no longer accessible.
[14:48:33] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[14:48:50] <sanxiyn> ray: I don't understand. Why would you need to explicitly free in that situation?
[14:48:55] *** Joins: LinearInterpol (RJones@moz-8A6454A9.ellsworth-hs.ellsworth.k12.me.us)
[14:49:07] <ray> i mean i dont need that particular data anymore
[14:49:21] <pepper_chico> sanxiyn, just wanted to know how to mix both usages of struct as I said, so I get a better understanding of this Foo(...) syntax for things...
[14:49:24] <sanxiyn> ray: I don't understand
[14:49:31] <sanxiyn> ray: Being more specific with examples would help, I think
[14:49:36] <kimundi> pepper_chico: what do you mean iwth mix?
[14:49:40] <sanxiyn> Like, pseudocode posted somewhere
[14:49:43] <ray> one sec
[14:50:03] <Yurume> ray, let me use a concrete example, for example, is the vector of the type ~[~str]? (i.e. a vector of strings)
[14:50:05] <sanxiyn> pepper_chico: For struct S(int, int), etc., S is a struct that has no field names
[14:50:19] <sanxiyn> pepper_chico: It is different from struct S { x: int, y: int }
[14:50:21] <Cevn> Sorry to butt in on the big boy conversation but how do I append two strings? 
[14:50:22] <Cevn> src/ls.rs:8   let mut cwd_str = cwd.dirname_str().unwrap().clone().append("/*"); 
[14:50:24] <Cevn> doesn't seem to work
[14:50:39] <ray> Yurume: yeah, for instance you want to count the letters of each string in the vector
[14:50:55] <ray> and after the letters are counted you dont need the word anymore
[14:50:58] <pepper_chico> sanxiyn, so, there can't be a usage of both at the same type
[14:51:09] <Yurume> ray, you normally use .move_iter() in that case.
[14:51:13] *** Quits: psquid (psquid@moz-8628D63C.threembb.co.uk) (Quit: work)
[14:51:30] <sanxiyn> pepper_chico: Well, one has field names, the other doesn't
[14:51:35] *** Joins: Blub\w (wry@620605B3.71150E1A.237AE2BA.IP)
[14:51:37] <pepper_chico> kimundi, I meant mix by that ^
[14:51:37] <Yurume> move_iter() means that you want the vector is "consumed" while iterating and you won't use the vector after the loop.
[14:51:47] *** Quits: wry (wry@620605B3.71150E1A.237AE2BA.IP) (Ping timeout)
[14:51:57] <ray> i see, so basically it frees the part if it moves to the next one
[14:52:01] <Yurume> ray, no
[14:52:04] <kimundi> ray: you'd use move_iter to get a iterator over the vector, which would give you each element by value, which would then drop automatically at the end of each loop iteration
[14:52:12] <Yurume> move_iter() only concerns about freeing the vector itself
[14:52:28] <Yurume> and then in the loop body you will own the string itself (~str)
[14:52:33] <ray> ok, what if i have a queue?
[14:52:47] <ray> fifo
[14:52:51] <bjz> Cevn: let mut cwd_str = format!("{}/*", cwd.dirname_str().unwrap()); ?
[14:52:57] <Yurume> if you don't do something fancy within the loop, the string will be inaccessible and then automatically freed.
[14:53:04] <kimundi> rusti: let v = ~[~"a", ~"b", ~"c"]; for s in v.move_iter() { /* s drops at the end of this block */ }
[14:53:05] -rusti- <anon>:10:42: 10:43 warning: unused variable: `s`, #[warn(unused_variable)] on by default
[14:53:05] -rusti- <anon>:10         let v = ~[~"a", ~"b", ~"c"]; for s in v.move_iter() { /* s drops at the end of this block */ }
[14:53:05] -rusti-                                                    ^
[14:53:05] -rusti- ()
[14:53:08] *** Joins: kngl (Adium@moz-18BD1C.ipv4.evonet.be)
[14:53:42] <kimundi> rusti: let v = ~[~"a", ~"b", ~"c"]; for s in v.move_iter() { println!("{}", s.chars().count()); /* s drops at the end of this block */ }
[14:53:45] -rusti- pastebinned 11 lines of output: http://ix.io/9Ub
[14:53:55] <ray> so basically i have a queue of strings that i get from some input, some threads work on that queue
[14:54:00] <Yurume> kimundi, char_len()?
[14:54:30] <ray> if i dont free the stuff that went in at some point it will run out of memory right?
[14:54:31] <kimundi> rusti: let v = ~[~"a", ~"b", ~"c"]; for s in v.move_iter() { println!("{}", s.char_len()); /* s drops at the end of this block */ }
[14:54:32] -rusti- 1
[14:54:32] -rusti- 1
[14:54:32] -rusti- 1
[14:54:32] -rusti- ()
[14:54:54] <ray> when it never gets out of the loop where i fill/empty the queue
[14:55:03] <Yurume> ray, if you *keep* the string in some storage then it will run out of memory.
[14:55:06] *** Quits: sellout (Adium@moz-76D71F1A.hlrn.qwest.net) (Quit: Leaving.)
[14:55:21] <Yurume> the point is that if you don't keep the string then it will automatically be freed
[14:55:23] <pyon> I have a RWArc to a given object.. Is it possible to determine whether this is the only RWArc referencing that object?
[14:55:28] <Cevn> bjz: that seems to work, although a bit unintuitive 
[14:55:29] <Cevn> thanks 
[14:55:29] <kimundi> rusti: let v = ~[~"a", ~"b", ~"c"]; for s in v.move_iter() { print!("{}", s.char_len()); println!("the current 's' drops here"); }
[14:55:30] -rusti- 1the current 's' drops here
[14:55:30] -rusti- 1the current 's' drops here
[14:55:31] -rusti- 1the current 's' drops here
[14:55:31] -rusti- ()
[14:55:33] <Yurume> even though Rust is not a garbage-collected language
[14:55:55] <sanxiyn> ray: If you need items from the queue after you process it once, well you need to keep it anyway
[14:56:25] <sanxiyn> ray: If you don't, you pop item from the queue, then ownership is transferred from the queue to your local variable, and that item is freed when local variable goes out of scope
[14:56:34] <ray> aah ok
[14:56:35] <ray> i see
[14:56:46] <kimundi> ray: See that last code snippet I ran in rusti
[14:57:12] <Yurume> the whole concept of ownership is what you should know in Rust, almost every safe construct relies on it
[14:57:40] <Yurume> even the safe communication among tasks relies on that (brilliantly)
[14:58:31] *** Quits: AvianFlu (AvianFlu@moz-51534E77.c3-0.43d-ubr2.qens-43d.ny.cable.rcn.com) (Input/output error)
[14:58:37] <ray> ty :)
[14:59:22] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[15:00:01] <sanxiyn> ray: In case of the vector, when you pop, memory for the vector is still there
[15:00:25] <sanxiyn> Let's say, vector had room for 10 elements, you pop all elements, vector still has room for 10 elements
[15:02:35] *** Joins: bjustin (bjustin@moz-8FC28563.sierrabravo.net)
[15:03:30] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Client exited)
[15:03:37] *** Quits: olem_ (olem@moz-D8B40BE5.fbx.proxad.net) (Ping timeout)
[15:03:51] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[15:05:17] *** Joins: yuriks (yuriks@50BCCB4D.6C9AD9C4.8E0C6B01.IP)
[15:05:39] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Ping timeout)
[15:05:44] *** Joins: ljrmorgan (Mibbit@10DE4E3D.84C11B46.A3649FCA.IP)
[15:05:46] *** Joins: saml (sam@moz-14C16814.cst.lightpath.net)
[15:05:46] *** Quits: Maato (maato@moz-8E1B3F2F.adsl-surfen.hetnet.nl) (Quit: Leaving)
[15:07:17] *** Quits: dmacvicar (dmacvicar@moz-663A7346.nue.novell.com) (Ping timeout)
[15:07:54] *** Joins: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[15:08:38] *** Joins: olem (olem@moz-D8B40BE5.fbx.proxad.net)
[15:09:39] *** Quits: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net) (Ping timeout)
[15:10:42] *** Quits: pepper_chico (pepper_chi@moz-13107F6.dsl.telesp.net.br) (Quit: Ex-Chat)
[15:11:55] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[15:11:56] *** ChanServ sets mode: +ao dherman dherman
[15:12:00] *** Joins: lkuper (lkuper@B6422202.A0D37E9B.51B6877.IP)
[15:14:28] *** Quits: eibwen (kvirc@moz-DD021B44.dip0.t-ipconnect.de) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[15:14:43] *** Joins: Tobba (Tobba@moz-462B7F7F.ias.bredband.telia.com)
[15:15:34] *** Quits: lpy (lpy@7360AA58.F09091A8.1348A864.IP) (Ping timeout)
[15:15:38] *** Joins: eibwen (kvirc@moz-DD021B44.dip0.t-ipconnect.de)
[15:15:38] *** Joins: igork (Adium@9C577557.7893D71C.6E0EE79F.IP)
[15:16:49] *** Quits: gkostyanikov (gkostyanik@2663E5AE.3E410295.CA6E2165.IP) (Ping timeout)
[15:17:04] *** Joins: Skif (emschwar@moz-CA025D57.ip.mcleodusa.net)
[15:17:19] *** Joins: gkostyanikov (gkostyanik@2663E5AE.3E410295.CA6E2165.IP)
[15:17:44] *** Joins: eholk (eholk@moz-BA312F07.crest.iu.edu)
[15:18:20] *** Quits: gkostyanikov (gkostyanik@2663E5AE.3E410295.CA6E2165.IP) (Quit: My iMac has gone to sleep. ZZZzzz)
[15:19:55] *** Joins: jyeo (Adium@moz-6F715C5D.singnet.com.sg)
[15:19:59] *** Joins: sko (Mibbit@C8400151.471081A5.DDE5D3F6.IP)
[15:20:49] <ray> with that definition of ownership, is it possible to get memory leaks?
[15:21:25] <sanxiyn> ray: We are hoping that it's not possible (we hope to prove it)
[15:21:29] <sanxiyn> nmatsakis: Still there?
[15:21:59] <kimundi> ray: _leaks_ yes, but only under specific circiumstance: if you make a cycle with reference counted smartpointers for example
[15:23:01] <sanxiyn> I reduced LLVM crash to this:
[15:23:01] <ray> could the compiler detect that?
[15:23:08] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[15:23:09] <sanxiyn> %a = type { %b }
[15:23:09] <sanxiyn> %b = type {}
[15:23:10] <sanxiyn> define void @main() {
[15:23:10] <sanxiyn>   %c = insertvalue %a undef, %b undef, 0
[15:23:10] <sanxiyn>   ret void
[15:23:10] <sanxiyn> }
[15:23:14] <kimundi> ray: Not without uselessly limiting them
[15:23:24] <sanxiyn> (Crash the same way, as far as I can tell)
[15:23:27] *** Joins: RageOfThou (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[15:23:37] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[15:24:07] *** Quits: glaebhoerl_ (glaebhoerl@moz-B5B88D72.catv.broadband.hu) (Quit: )
[15:24:13] *** Joins: canhtak (canhtak@moz-4B5B3414.wl.t.ulaval.ca)
[15:24:53] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[15:25:02] <kimundi> ray: But that is literally the only of two ways I know about to make a leak in Rust code - and its not memory unsafe
[15:26:21] *** Quits: kngl (Adium@moz-18BD1C.ipv4.evonet.be) (Quit: Leaving.)
[15:26:30] <kimundi> (The other is putting a channel into itself, and that also amounts to a reference counted cycle under the hood)
[15:27:07] <ray> or maybe spit out a warning that you have to silence manually
[15:27:15] <ray> like in java with the annotation
[15:28:16] *** Quits: espindola (espindola@3AA6F601.53AE8582.A535BD55.IP) (Input/output error)
[15:28:33] <Denommus> any developer that may resolve my question without a doubt?
[15:28:43] *** Joins: espindola (espindola@3AA6F601.53AE8582.A535BD55.IP)
[15:28:47] <sanxiyn> Denommus: What was the question?
[15:29:16] <nmatsakis> sanxiyn: back now
[15:29:21] <kimundi> ray: It would to always have spit out the warning if you use reference counting or message passing then :P
[15:29:28] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[15:29:54] <nmatsakis> sanxiyn: oh, I see backscroll
[15:30:24] <nmatsakis> sanxiyn: that's helpful, I had zeroed in on the insertvalue as a likely culprit too, not sure what's the story yet
[15:30:29] *** Quits: espindola (espindola@3AA6F601.53AE8582.A535BD55.IP) (Ping timeout)
[15:30:33] <pnkfelix> Denommus: from the point-of-view of rustc, the crate is the unit of compilation.  If you want more than one crate in your project, then you need a tool beyond rustc.  (`make` is one such tool.)
[15:30:44] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[15:31:06] *** Joins: ptc (Adium@moz-8F01578B.z72-46-65.customer.algx.net)
[15:31:13] *** Joins: sw17ch (sw17ch@moz-62998E95.hfc.comcastbusiness.net)
[15:31:23] *** Quits: ptc (Adium@moz-8F01578B.z72-46-65.customer.algx.net) (Connection reset by peer)
[15:31:44] <sw17ch> Would some one mind working through a bit more of the IO.split() issue with me for a second? I don't know if the `select` option here would work: https://github.com/mozilla/rust/issues/11165
[15:31:46] *** Joins: ptc (Adium@moz-8F01578B.z72-46-65.customer.algx.net)
[15:31:54] <sw17ch> I know i ate a ton of channel time a few days ago on this, but it continues to bug me.
[15:32:08] *** Parts: ptc (Adium@moz-8F01578B.z72-46-65.customer.algx.net) ()
[15:32:33] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[15:32:52] *** Joins: Scriptor (anonymous@moz-E06F46F0.corp.bitshelter.com)
[15:32:54] *** Quits: rca (rcatolino@moz-FBA8CEE6.adsl.proxad.net) (Ping timeout)
[15:33:02] *** Joins: kngl (Adium@moz-18BD1C.ipv4.evonet.be)
[15:33:35] *** Joins: rca (rcatolino@moz-FBA8CEE6.adsl.proxad.net)
[15:34:11] *** Joins: sellout (Adium@moz-F0804961.mycingular.net)
[15:35:20] <nmatsakis> sanxiyn: seems like the problem is introduced by ee114b6cb15049a6be77c70c24c42db23e675e54
[15:35:44] * nmatsakis verifies that
[15:35:48] <nmatsakis> I'm guessing, anyway
[15:36:25] <sanxiyn> nmatsakis: How can it be Rust's problem?
[15:37:00] *** Quits: canhtak (canhtak@moz-4B5B3414.wl.t.ulaval.ca) (Quit: canhtak)
[15:37:01] <nmatsakis> sanxiyn: well, if it crashes, it's out problem, isn't it ;)
[15:37:08] <nmatsakis> sanxiyn: it's presumably an LLVM bug too
[15:37:20] <sanxiyn> Yeah I guess
[15:37:30] <nmatsakis> sanxiyn: once, I verify what is causing it, I'll discuss with llvm devs, but in the meantime I have to workaround it
[15:37:48] <sanxiyn> We probably should not deliberately trigger LLVM bug... The question is what is the condition.
[15:38:23] <Denommus> pnkfelix: ok, thanks. At least a Rust Makefile will be a lot simpler than a C++'s
[15:38:27] <nmatsakis> mainly I want to land my PR, and it seems to step onto this bug, though honestly I have no idea why my code does and other doesn't
[15:38:32] <nmatsakis> might be worth digging into that a bit more
[15:39:34] *** Quits: pyon (user@A16F2BE6.A9B419CB.1C8C8CE9.IP) (Client exited)
[15:40:13] *** Quits: heftig (heftig@moz-D746319F.unitymedia.biz) (Ping timeout)
[15:40:23] *** Joins: sellout1 (Adium@moz-1D225F38.hsd1.co.comcast.net)
[15:40:27] *** Quits: sellout (Adium@moz-F0804961.mycingular.net) (Connection reset by peer)
[15:40:34] <nmatsakis> sanxiyn: I was wrong anyway, reverting that doesn't seem to fix it.
[15:40:54] *** Joins: canhtak (canhtak@moz-4B5B3414.wl.t.ulaval.ca)
[15:41:12] *** Quits: canhtak (canhtak@moz-4B5B3414.wl.t.ulaval.ca) (Quit: canhtak)
[15:41:40] *** Quits: LinearInterpol (RJones@moz-8A6454A9.ellsworth-hs.ellsworth.k12.me.us) (Connection reset by peer)
[15:42:06] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[15:42:10] *** Quits: sko (Mibbit@C8400151.471081A5.DDE5D3F6.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[15:42:44] *** Quits: Ferreus (ferreus@moz-C5752C75.dip0.t-ipconnect.de) (Ping timeout)
[15:42:46] <ray> btw, i just read @ for managed pointers is deprecated
[15:42:46] *** Joins: maxli (maxli@moz-F47DD19B.student.cs.uwaterloo.ca)
[15:42:51] <ray> is there an alternative?
[15:42:52] *** Joins: pyon (user@A16F2BE6.A9B419CB.1C8C8CE9.IP)
[15:42:56] <ray> special type?
[15:43:32] <pnkfelix> Denommus: well it would be nice if we had a better way to quickly extract the depencies of a crate's lib.rs automatically, rather than make people write that manually.
[15:44:19] <SiegeLord> Isn't that what --dep-info is?
[15:44:28] <pnkfelix> SiegeLord: oh do we have that now?  :)
[15:44:40] <SiegeLord> It generates a Makefile compatible dep file
[15:44:52] <SiegeLord> Have to parse it if you're not using Makefiles though
[15:44:52] <pnkfelix> SiegeLord: okay then never mind me thne.
[15:44:56] <kimundi> ray: Gc<T>
[15:45:13] <ray> oh cool :)
[15:45:14] <ray> thanks
[15:45:42] <ray> thats an awesome idea btw
[15:45:46] <pnkfelix> kimundi: does using Gc<T> still require that one opt in via the feature-gate system?  Or does that bypass the feature gate check?
[15:46:07] <SiegeLord> I kind of with --dep-info didn't generate a file (rather wrote stuff to stdout) but it's not a big deal
[15:46:11] <SiegeLord> *wish
[15:46:25] <kimundi> pnkfelix: Afaik it bypassed it, but now is feature gated itself because there are still issues
[15:46:36] <pnkfelix> kimundi: okay.
[15:46:52] <pnkfelix> kimundi: just double-checking. I don't want people building in assumptions about the Gc API
[15:46:59] <ray> was rust released after go? because go seems so much popular
[15:47:14] <kimundi> ray: Rust is not yet released, so :P
[15:47:18] <SiegeLord> Go has already been released :P
[15:47:24] *** Joins: Blub\0 (wry@620605B3.71150E1A.237AE2BA.IP)
[15:47:35] <kimundi> They are very differnent languages, no real uses comparing them
[15:47:48] <ray> yeah, i was always looking for something to get rid of c++
[15:47:50] <SiegeLord> Our logo is cooler
[15:47:55] *** Quits: Blub\w (wry@620605B3.71150E1A.237AE2BA.IP) (Ping timeout)
[15:47:58] <sanxiyn> nmatsakis: Where are we generating insertvalue anyway?!
[15:48:06] *** Joins: yutongzhao (yutongzhao@moz-325F8282.hsd1.ca.comcast.net)
[15:48:13] <sanxiyn> (As far as I can tell that insertvalue came from LLVM optimizer, not what we generated)
[15:48:14] <ray> go however doesnt seem to be designed to do that
[15:48:56] <nmatsakis> sanxiyn: yes, it does.
[15:49:04] <nmatsakis> sanxiyn: I'm trying to trace it around
[15:49:14] <sanxiyn> nmatsakis: I believe this bug is specific to zero-sized type (again)
[15:49:36] <nmatsakis> sanxiyn: seems like a likely culprit
[15:49:41] <sw17ch> If any one is interested and has a few moments to comment, I'd appreciate some clarification: https://github.com/mozilla/rust/issues/11165#issuecomment-32480677
[15:50:41] <sanxiyn> nmatsakis: I think introducing local LLVM patch may be the simplest way to fix this
[15:51:12] <nmatsakis> sanxiyn: I'd like to understand why it occurs only on my branch
[15:51:54] <sanxiyn> nmatsakis: Who knows... Does it compile fine if you disable optimization?
[15:52:17] <sanxiyn> I feel like tracing through optimizer is a lost cause...
[15:53:26] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[15:53:50] <nmatsakis> sanxiyn: it works if I disable opt, yes.
[15:57:34] *** Joins: barosl (barosl@3DE683B6.E551553C.7544CABF.IP)
[15:57:56] <kvark> Is it a good idea to make the repository a rustpkg workspace?
[15:58:28] <sanxiyn> nmatsakis: If you look at visitExtractValue just below visitInsertValue
[15:58:36] <sanxiyn> // Ignore a extractvalue that produces an empty object
[15:58:41] *** Joins: AvianFlu (AvianFlu@moz-723527FF.nycmny.fios.verizon.net)
[15:58:42] <sanxiyn> Basically same code needs to be copied
[15:58:49] *** Quits: RageOfThou (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[15:58:59] <eholk> kvark: that's what i typically do
[15:59:08] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[15:59:10] <kvark> eholk: can I look at some of yours?
[15:59:57] <ray> btw, what is #[] ? something like an annotation
[16:00:01] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[16:00:03] <eholk> kvark: sure, here are a few repos: https://github.com/eholk/rust-opencl https://github.com/eholk/SciRust https://github.com/eholk/rust-papi
[16:00:17] <kvark> thanks!
[16:00:20] <sanxiyn> nmatsakis: After a little SVN blame... bah
[16:00:21] <sanxiyn> http://llvm.org/bugs/show_bug.cgi?id=9900
[16:00:23] <eholk> kvark: rustpkg is pretty new, so I don't know how well it'll work for you
[16:00:38] <sanxiyn> This is another case of LLVM bug 9900 and you guess who filed LLVM bug 9900? Rust team.
[16:00:51] <eholk> kvark: in particular, I've never gotten things like `extern mod OpenCL = "github.com/eholk/rust-opencl" to work
[16:01:20] <kvark> eholk: well... I just want to at least figure out the folder layout. Planning the move from google code to github, and want the layout to be fixed more or less...
[16:01:40] *** Quits: Zr40 (zr40@EE4BB9F5.926C319A.BE2F4011.IP) (Quit: leaving)
[16:01:47] <kvark> eholk: and extern mod=... is very new, I suppose
[16:01:50] <eholk> kvark: sounds good. I think `rustpkg init` sets things up kind of the way it expects
[16:02:19] <ray> also when do i want a named lifetime?
[16:03:02] <eholk> ray: #[] is an annotation
[16:03:20] <eholk> ray: I usually add named lifetimes when I can't make them compile otherwise...
[16:03:28] <nmatsakis> sanxiyn: thanks, I'll take a look at that -- mostly I want to know (a) am I doing something illegal that is leading to this (seems like prob not) and (b) how can I workaround it :)
[16:03:29] *** Joins: cschneid (cschneid@moz-CA025D57.ip.mcleodusa.net)
[16:03:32] <ray> i see
[16:04:23] <sanxiyn> nmatsakis: (a) probably bad luck triggering latent bug (b) simplest workaround is to apply local patch for #9900 copying from extractvalue to insertvalue
[16:04:38] *** Joins: cds (uid23856@moz-E77DEB21.irccloud.com)
[16:05:14] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[16:05:40] *** Joins: espindola (espindola@8EC99D26.4B7A7726.A2E931B1.IP)
[16:05:44] *** Quits: espindola (espindola@8EC99D26.4B7A7726.A2E931B1.IP) (Input/output error)
[16:06:13] *** Joins: espindola (espindola@563D60BB.4B7A7726.A2E931B1.IP)
[16:07:14] <kimundi> ray: You need named lifetimes in situations where you want to link the lifetime of one reference with another
[16:07:24] *** Quits: maxli (maxli@moz-F47DD19B.student.cs.uwaterloo.ca) (Quit: Leaving.)
[16:07:35] <kimundi> ray: Example: fn foo<'a>(a: &'a A) -> &'a B
[16:08:15] *** Joins: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[16:08:18] <sanxiyn> It seems that what happened is, #9900 fixed insertvalue T1 T2 when T2 is empty, but did not fix when T1 is empty...
[16:08:37] <kimundi> But if a function only uses a reference, then its not neccessary: fn foo(a: &A) { ... }
[16:08:42] <sanxiyn> (If T1 is empty, T2 is necessarily empty)
[16:09:07] *** Joins: maxli (maxli@moz-F47DD19B.student.cs.uwaterloo.ca)
[16:09:30] *** Quits: zakora (NC@moz-28181BF.fbx.proxad.net) (Quit: Textual IRC Client: www.textualapp.com)
[16:09:40] <kimundi> In general, named lifetimes are like generic parameters: FOr generic structs for example you need to declare them just like you would declare the generic param: struct Foo<'a, T> { r: &'A T }
[16:09:59] *** Quits: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net) (Ping timeout)
[16:10:00] <kimundi> make that a 'a there :P
[16:11:30] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[16:11:56] *** Quits: sanxiyn (tinuviel@B4104EBB.3CC170B1.1E14B209.IP) (Quit: Leaving)
[16:12:01] <ray> kimundi: when do i want to link them together? cant think of an example
[16:12:36] <kimundi> ray: For example if you pass in a reference to a struct, and want to return a reference to a field in it
[16:12:44] *** Joins: Ferreus (ferreus@moz-9DCAE088.customers.d1-online.com)
[16:12:53] <ray> ok, so the struct would go out of scope?
[16:12:58] <ray> and delete the field also?
[16:13:04] <kimundi> ray: Or pass in a reference to a vector, and return a reference to one of its elements
[16:13:42] <kimundi> ray: No, if you work with references the struct does not transfer ownership into the function
[16:14:26] <ray> i see so it does not free stuff twice
[16:14:31] *** Quits: Ferreus (ferreus@moz-9DCAE088.customers.d1-online.com) (Connection reset by peer)
[16:15:14] <kimundi> rusti: let v = ~[1, 2, 3]; fn foo<'a>(v: &'a[int]) -> &'a int { &v[0] }; let e = foo(v); println!("{}", e);
[16:15:17] -rusti- pastebinned 10 lines of output: http://ix.io/9Uf
[16:15:35] <kimundi> rusti: let v = ~[1, 2, 3]; fn foo<'a>(v: &'a[int]) -> &'a int { &v[0] }; let e = foo(v); println!("{:?}", e);
[16:15:36] -rusti- &1
[16:15:36] -rusti- ()
[16:15:52] *** Quits: tq (tq@moz-9FE9CCF4.a251.priv.bahnhof.se) (Quit: tq)
[16:15:54] <kimundi> so, in this case, v remains owned by the local variable v
[16:16:20] *** Quits: sellout1 (Adium@moz-1D225F38.hsd1.co.comcast.net) (Ping timeout)
[16:16:27] *** Joins: sellout (Adium@moz-1D225F38.hsd1.co.comcast.net)
[16:16:46] <kimundi> in the foo() call, the ~[T] gets borrowed to a &[T] reference to the vector - which allows temporary access to its values, but does not imply ownership
[16:17:00] *** Quits: yota (sdouche@moz-7D878FB8.securactive.net) (Quit: Ex-Chat)
[16:17:19] *** Joins: sehugg (sehugg@moz-42540923.res.bhn.net)
[16:17:21] *** Joins: moostik (Icedove@moz-1FF02BE5.w92-151.abo.wanadoo.fr)
[16:18:25] *** Quits: pyon (user@A16F2BE6.A9B419CB.1C8C8CE9.IP) (Client exited)
[16:18:40] *** Joins: pyon (user@A16F2BE6.A9B419CB.1C8C8CE9.IP)
[16:19:01] <kimundi> foo() then returns a reference to the first value in v, and that gets printed out
[16:19:33] <kimundi> note that, if I change the code so that the reference would live longer than the local variable v, it would refuse to compile:
[16:19:47] *** Quits: diverse (diverse@moz-ED94B8D.oc.oc.cox.net) (Ping timeout)
[16:19:55] *** Quits: yutongzhao (yutongzhao@moz-325F8282.hsd1.ca.comcast.net) (Quit: yutongzhao)
[16:20:46] <kimundi> rusti: let lives_longer_than_v = { let v = ~[1, 2, 3]; fn foo<'a>(v: &'a[int]) -> &'a int { &v[0] }; let e = foo(v); e };
[16:20:49] -rusti- pastebinned 14 lines of output: http://ix.io/9Ug
[16:20:58] *** Quits: lkuper (lkuper@B6422202.A0D37E9B.51B6877.IP) (Quit: lkuper)
[16:21:04] *** Quits: pyon (user@A16F2BE6.A9B419CB.1C8C8CE9.IP) (Client exited)
[16:21:13] <kimundi> ^ This error shows that nicely
[16:21:30] *** Joins: LinearInterpol (RJones@moz-8A6454A9.ellsworth-hs.ellsworth.k12.me.us)
[16:21:59] *** Joins: maxiepoo (Max@moz-BF85AD57.nuwlan.northwestern.edu)
[16:23:04] *** Joins: pyon (user@A16F2BE6.A9B419CB.1C8C8CE9.IP)
[16:23:42] *** Joins: lkuper (lkuper@moz-6881CCA2.dhcp-bl.indiana.edu)
[16:25:24] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[16:26:38] *** Quits: maxli (maxli@moz-F47DD19B.student.cs.uwaterloo.ca) (Quit: Leaving.)
[16:26:50] *** Joins: jnsk (Mibbit@moz-829EE15C.dsl.static.sonic.net)
[16:27:05] *** Joins: yota (sdouche@moz-7D878FB8.securactive.net)
[16:28:03] <pyon> What happens when the control of flow for a parent task reaches the end of the function, while there are still children tasks running?
[16:28:54] <pyon> Can child tasks become "orphans", or does parent task stay alive (no stack unwinding) until all children die?
[16:29:09] *** Joins: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com)
[16:32:03] *** Quits: Kxepal (Miranda@moz-EEB2B0E3.pppoe.mtu-net.ru) (Ping timeout)
[16:32:49] <ray> are there default parameters?
[16:33:09] <pyon> ray: afaik no
[16:33:58] *** Joins: Ferreus (ferreus@moz-933E4A88.pools.arcor-ip.net)
[16:35:27] *** Joins: Kxepal (Miranda@moz-D2BE416E.pppoe.mtu-net.ru)
[16:35:56] *** Joins: thewonderidiot (mstewart@moz-E41129BA.ipnetworksinc.net)
[16:36:34] <ray> as for OOP, you define a struct and then do the implementation for it right? what about private parameters?
[16:36:35] *** Quits: csherratt (csherratt@moz-8D848271.cpe.teksavvy.com) (Ping timeout)
[16:36:41] <ray> just prefix with _?
[16:37:05] <tiffany> there's a 'priv' keyword
[16:37:25] <ray> and i put it into the struct?
[16:37:32] *** Quits: eholk (eholk@moz-BA312F07.crest.iu.edu) (Quit: eholk)
[16:37:51] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[16:37:51] *** ChanServ sets mode: +ao brson brson
[16:38:12] *** Joins: csherratt (csherratt@moz-8D848271.cpe.teksavvy.com)
[16:38:18] <ray> also what about getters and setters? is there a shortcut or do you simply do it like in java?
[16:38:22] *** Quits: new_one (new_one@moz-D538194E.rice.edu) (Client exited)
[16:38:37] <kimundi> ray: like java
[16:38:45] <ray> ty
[16:39:22] *** Joins: carllerche (carllerche@moz-CA3FF5F1.hsd1.or.comcast.net)
[16:39:29] <erickt> ray: there's no getter/setter helpers
[16:39:56] <lucian> and it's likely they won't ever exist, i guess
[16:40:11] *** Quits: TimAbraldes (quassel@moz-7FD19BDC.hsd1.or.comcast.net) (Ping timeout)
[16:40:24] *** Quits: jensnockert (jensnocker@moz-C4B24C3.customers.ownit.se) (Input/output error)
[16:40:52] *** Joins: jensnockert (jensnocker@moz-C4B24C3.customers.ownit.se)
[16:41:11] *** Quits: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com) (Ping timeout)
[16:41:34] *** Joins: awidegreen (awidegreen@moz-9FADBE94.a357.priv.bahnhof.se)
[16:42:45] *** Quits: jensnockert (jensnocker@moz-C4B24C3.customers.ownit.se) (Ping timeout)
[16:42:48] <jnsk> hello, I'm currerntly going through this section of the tutorial: http://static.rust-lang.org/doc/master/tutorial.html#implementing-a-linked-list
[16:43:00] <jnsk> and I have a quick question about the "references" section
[16:43:08] <jnsk> specifically the "ref" keywords in the pattern matching 
[16:43:08] *** Joins: canhtak (canhtak@moz-4B5B3414.wl.t.ulaval.ca)
[16:43:15] *** Joins: hoverbear (hoverbear@EBFA78B5.F19E5E7B.E74D50F2.IP)
[16:43:17] <jnsk> what does the "ref" do?
[16:43:27] *** Quits: canhtak (canhtak@moz-4B5B3414.wl.t.ulaval.ca) (Quit: canhtak)
[16:44:24] <Ms2ger> It gives you a pointer to the contents rather than moving them out
[16:44:25] *** Quits: vmx (vmx@moz-8F56BC14.pools.arcor-ip.net) (Quit: Leaving)
[16:45:23] *** Joins: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com)
[16:45:35] <jnsk> so it's akin to borrowing? whereas if the "ref"s weren't present, it'd be like moving ownership?
[16:45:47] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Ping timeout)
[16:45:52] *** Joins: gwty (gwtypc@A3F4FE97.CFB6D583.BD94A9D5.IP)
[16:46:41] *** Quits: paulproteus (quassel@rose.makesad.us) (Ping timeout)
[16:46:51] *** Joins: paulproteus (quassel@moz-E86A3B42.makesad.us)
[16:47:01] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[16:47:17] <kvark> the tutorial mentions managed boxes, which are deprecated
[16:47:29] <lucian> jnsk: exactly, it is borrowing
[16:47:29] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[16:47:48] <Ms2ger> kvark, feel free to fix it :)
[16:47:56] <jnsk> okay. thanks for the help!
[16:48:09] *** Quits: andre (andre@CA528A4A.45A4338E.8EE27E6.IP) (Quit: leaving)
[16:48:50] *** Quits: maxiepoo (Max@moz-BF85AD57.nuwlan.northwestern.edu) (Ping timeout)
[16:48:55] <kvark> oh god, that's a lot of @
[16:49:42] *** Joins: maxiepoo (Max@moz-BF85AD57.nuwlan.northwestern.edu)
[16:49:49] *** Joins: sedman (sedman@E4D2F0A.47298EC7.57E8EAD3.IP)
[16:50:03] <kvark> for _ in ::std::iter::range(0, 10) {}
[16:50:13] <kvark> ugh, why is there a :: before std?
[16:50:18] *** Quits: noel (noel@moz-A96C42F7.as13285.net) (Quit: noel)
[16:50:25] <kimundi> kvark: to make it a global path
[16:50:41] *** Quits: maxiepoo (Max@moz-BF85AD57.nuwlan.northwestern.edu) (Quit: maxiepoo)
[16:50:41] <kimundi> kvark: if you leave of the ::, it will not work inm submodules :P
[16:51:18] <kvark> kimundi: err, submodules have their own imports, don't they?
[16:52:14] <ray> modules are not namespaces right?
[16:52:24] *** Joins: TimAbraldes (quassel@moz-7FD19BDC.hsd1.or.comcast.net)
[16:52:37] *** Joins: andre (andre@CA528A4A.45A4338E.8EE27E6.IP)
[16:52:48] <ray> i mean do i need to prefix my classes with a mod full::path {
[16:52:50] <kimundi> well,w e don't have namespaces, so modules are all there is
[16:53:27] <SiegeLord> The function pretty similarly to C++ modules in some ways
[16:53:31] <SiegeLord> *C++ namespaces
[16:53:52] *** Quits: mouse (mouse@moz-373942D2.dhcp.yndx.net) (Ping timeout)
[16:54:06] <SiegeLord> I don't thick C++ namespaces are a complete subset of Rust modules though
[16:54:23] *** Joins: Matthias247 (Miranda@moz-BDD35EC0.hsi5.kabel-badenwuerttemberg.de)
[16:54:39] <ray> lets say i have a Main.rs file and i want to use a class in http/server.rs
[16:54:42] <ray> how do i do that
[16:54:55] <ray> use http::server; doesnt work
[16:54:56] <SiegeLord> You can always use a 'use' statement to create a local alias to any type
[16:55:00] <kimundi> use a language that has classes ;)
[16:55:14] <ray> or do i need use http::server::HttpServer;
[16:55:18] <SiegeLord> The alias name is the last component of the path
[16:55:32] <SiegeLord> So use http::server; creates a 'server' alias
[16:55:42] *** Joins: jeaye (jeaye@moz-34FEF2BB.hsd1.ca.comcast.net)
[16:55:45] <SiegeLord> And HttpServer alias in the second example
[16:55:48] *** Quits: kngl (Adium@moz-18BD1C.ipv4.evonet.be) (Quit: Leaving.)
[16:56:00] *** Quits: Kxepal (Miranda@moz-D2BE416E.pppoe.mtu-net.ru) (Ping timeout)
[16:56:05] <SiegeLord> So if you just did the first example, you'd have to do server::HttpServer
[16:56:17] <ray> i see
[16:56:42] <ray> inside the server.rs do i need to use a mod http::server {
[16:57:11] <ray> feels a bit like python btw, do you also use one file for more types/classes?
[16:57:18] <SiegeLord> I think C++ 'using' statements work basically the same, not 100% sure
[16:57:35] *** Quits: espindola (espindola@563D60BB.4B7A7726.A2E931B1.IP) (Input/output error)
[16:58:03] *** Joins: maxiepoo (Max@moz-DEDB4821.nuwlan.northwestern.edu)
[16:58:37] <SiegeLord> ray: Inside use statements, paths are absolute, everywhere else they are relative
[16:58:40] *** Joins: yoopo_ (6sun@842E0E4B.B14B69D6.4467248D.IP)
[16:59:03] <jnsk> quick question, what's the difference between ref and ~ref?
[16:59:34] <kimundi> jnsk: one is a pattern bind that gives you a reference, the other gives you a reference inside a ~ pointer
[17:00:08] <jnsk> so ~ref only matches ~pointers, while ref matches either?
[17:00:16] <SiegeLord> ray: (except when a non-use path starts with ::, then it's also absolute)
[17:00:28] <kimundi> well, ref matches nothing - its a binding modifier for the variable name
[17:00:56] <jnsk> er yea
[17:01:14] <ray> ok so i got this https://dpaste.de/9TTa
[17:01:27] <jnsk> so if I have a Cons(u32, ~List) as a variant in an enum
[17:01:44] <ray> which fails to compile
[17:01:52] <jnsk> what's the difference between matching it with Cons(x, ~ref next) and Cons(x, ref next)?
[17:01:58] *** Joins: vince (vince@moz-D9DA273.wireless.mcgill.ca)
[17:02:20] <ray> main.rs:1:5: 1:9 error: unresolved import. maybe a missing `extern mod http`?
[17:02:20] <ray> main.rs:1 use http::server::HttpServer;
[17:02:31] *** Quits: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net) (Quit: echristo)
[17:02:55] <SiegeLord> ray: You need to have a mod http { pub mod server; } in main.rs
[17:03:03] <SiegeLord> And lose the mode inside server.rs
[17:03:05] <SiegeLord> *mod
[17:04:16] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[17:04:52] *** Joins: samx (sami@moz-77A1C177.pp.htv.fi)
[17:05:11] <ray> like: mod http { pub mod server; }
[17:05:11] <ray> fn main() {
[17:05:12] <ray> ?
[17:05:20] <SiegeLord> Yep
[17:05:27] <ray> HttpServer is not resolved then
[17:05:33] <SiegeLord> Keep the use
[17:05:40] <SiegeLord> Oh, and make HttpServer pub
[17:06:01] <SiegeLord> Then you got to fix a whole bunch of other things, but eventually I got your code to compile ;)
[17:06:12] <ray> xD yeah
[17:06:21] <ray> pub for just the struct?
[17:06:35] <SiegeLord> Keep the other ones and add it to the struct, yes
[17:06:41] *** Quits: skade (skade@541D1605.505237C9.CAE22B62.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz)
[17:06:41] *** Quits: maxiepoo (Max@moz-DEDB4821.nuwlan.northwestern.edu) (Quit: maxiepoo)
[17:07:16] <SingingBoyo> is there a list of existing conventions somewhere?  cleaning up evict's codebase, figure I might as well follow conventions.
[17:07:30] *** Joins: Cevn_ (sameer@moz-57F2D062.v4.wm.edu)
[17:07:52] <ray> SiegeLord: use mod?
[17:07:56] <ray> because that fails
[17:08:03] <ray> or do i need a new line?
[17:08:10] <SiegeLord> ?
[17:08:23] <ray> mod http { pub mod server; }
[17:08:23] <ray> use http::server::HttpServer;
[17:08:24] <ray> `
[17:08:25] <ray> ?
[17:08:38] *** Quits: tiffany (kawaii@moz-FC0DB29D.dhcp.embarqhsd.net) (Input/output error)
[17:08:38] *** Joins: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[17:08:39] <ray> inside main.rs
[17:08:42] <SiegeLord> use comes before mod
[17:08:47] <SiegeLord> Switch those two lines
[17:09:00] <ray> oh great :) thanks
[17:09:12] <ray> why do i need the mod http { pub mod server; } line?
[17:09:22] *** Joins: awhit (Mibbit@moz-6A565CEE.ee.ic.ac.uk)
[17:09:31] <ray> also why pub? isnt that clear from the file?
[17:09:35] <SiegeLord> Err... did you read the tutorial?
[17:09:42] *** Quits: carllerche (carllerche@moz-CA3FF5F1.hsd1.or.comcast.net) (Quit: carllerche)
[17:09:54] <SiegeLord> I was assuming you did...
[17:10:08] <SiegeLord> The big point is that files are not important, mod statements are
[17:10:12] *** Joins: skade (skade@541D1605.505237C9.CAE22B62.IP)
[17:10:19] *** Quits: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net) (Ping timeout)
[17:10:38] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[17:10:48] <ray> oh, i was in the manual section
[17:10:59] <awhit> Hi, I have a question - I'm trying to fix a bug in bitv in libextra, can someone explain to me how to get build the tests for just that module?
[17:11:20] <SiegeLord> ray: Read over this a bit, maybe it'll clarify things a bit: http://static.rust-lang.org/doc/master/tutorial.html#crates-and-the-module-system
[17:11:39] *** Joins: Kxepal (Miranda@moz-4F25DFCF.pppoe.mtu-net.ru)
[17:11:40] <sfackler> awhit: you can try "make check-stage1-extra NO_REBUILD=1 TESTNAME=bitv"
[17:11:54] *** Quits: skade (skade@541D1605.505237C9.CAE22B62.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz)
[17:12:11] <sfackler> actually, I think "rustc --test src/libextra/bitv.rs" should work as well
[17:12:17] *** Joins: jensnockert (jensnocker@moz-C4B24C3.customers.ownit.se)
[17:14:15] <ray> oh i see
[17:14:19] <ray> use is just for aliasing
[17:14:20] *** Joins: notmatt (notmatt@CC62CF7E.1E7FDFDB.A82DBDDB.IP)
[17:14:34] <ray> and mod http { mod server; } is just fine
[17:14:38] <ray> pub is not needed
[17:14:50] <SiegeLord> It won't compile ;)
[17:14:59] *** Joins: maxiepoo (Max@moz-DEDB4821.nuwlan.northwestern.edu)
[17:15:03] <ray> yeah some type problems xD
[17:15:07] <SiegeLord> A module can't access the privates of its children
[17:15:25] <SiegeLord> Well, let me find the actual spot where its defined
[17:16:00] <ray> also isnt there a more convenient way for importing? nesting in { seems a bit excessive if you only need one file
[17:16:03] *** Quits: sellout (Adium@moz-1D225F38.hsd1.co.comcast.net) (Ping timeout)
[17:16:07] <ray> something like mod http::server maybe?
[17:16:51] <SiegeLord> You could do #[path="http/server.rs] mod server; If the http module is superflous
[17:17:14] <SiegeLord> But otherwise... I'd say its rare for there to be just a single module
[17:17:22] <ray> hm ok, thanks so far :)
[17:17:25] <ray> gtg
[17:17:26] <SiegeLord> Why have the intervening module then, you know?
[17:17:35] *** Joins: sellout (Adium@moz-1D225F38.hsd1.co.comcast.net)
[17:17:56] <SiegeLord> Actually there is a case when you might want to have one... but its relatively rare
[17:18:20] *** Quits: jensnockert (jensnocker@moz-C4B24C3.customers.ownit.se) (Input/output error)
[17:19:42] *** Quits: franckverrot (Franck_Ver@C3033BF6.B86F1645.C91367C6.IP) (Ping timeout)
[17:19:54] *** Joins: franckverrot (Franck_Ver@C3033BF6.B86F1645.C91367C6.IP)
[17:21:48] *** Quits: ray (bernhard@moz-FF531B82.vie.surfer.at) (Ping timeout)
[17:22:38] *** Quits: vince (vince@moz-D9DA273.wireless.mcgill.ca) (Ping timeout)
[17:23:28] <awhit> sfacker: thanks - the first command throws up errors in the comm and sync modules
[17:23:53] <awhit> the second fails to resolve imports bitv
[17:24:00] <awhit> hmm
[17:26:16] *** Joins: curmet (Mibbit@29369FA4.3EAE7AC0.6DC151A0.IP)
[17:26:23] *** Joins: heftig (heftig@C0A4613F.608A649E.172227A7.IP)
[17:26:32] *** Joins: kngl (Adium@moz-18BD1C.ipv4.evonet.be)
[17:26:44] *** Quits: alonlevy (alon@moz-61A0AD83.red.bezeqint.net) (Ping timeout)
[17:27:54] <curmet> hello, let a = [1,2,3] ;  let b = a.iter();  let d = b.next();       where d have to be mut to make it work ??? 
[17:28:28] *** Quits: LinearInterpol (RJones@moz-8A6454A9.ellsworth-hs.ellsworth.k12.me.us) (Ping timeout)
[17:29:01] <kimundi> curmet: because b is a iterator over the vector - next() mutates the vector so that for the next next() call, it can give you the next value
[17:30:00] *** Joins: echristo (echristo@4241698A.2E4FD3DD.225F4543.IP)
[17:30:18] <kimundi> err, next() muattes the _vector iterator_, not the vector itself
[17:30:41] <kimundi> the vectors remains unchanged and immutable during the iteration
[17:30:53] *** Joins: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz)
[17:30:56] *** Quits: sw17ch (sw17ch@moz-62998E95.hfc.comcastbusiness.net) (Quit: sw17ch)
[17:31:02] <kimundi> vector*
[17:31:27] <curmet> ok, thanks...
[17:32:11] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[17:32:11] *** Joins: tq (tq@moz-9FE9CCF4.a251.priv.bahnhof.se)
[17:32:26] *** Quits: samx (sami@moz-77A1C177.pp.htv.fi) (Quit: This computer has gone to sleep)
[17:33:27] *** Quits: curmet (Mibbit@29369FA4.3EAE7AC0.6DC151A0.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[17:33:33] *** Quits: rattboi (bkanyid@moz-9A5A7AF8.org) (Quit: WeeChat 0.4.2)
[17:34:01] *** Joins: canhtak (canhtak@moz-4B5B3414.wl.t.ulaval.ca)
[17:34:23] *** Joins: sw17ch (sw17ch@moz-62998E95.hfc.comcastbusiness.net)
[17:34:34] *** Joins: willingc (willingc@moz-B4760708.san.res.rr.com)
[17:35:34] *** Quits: franckverrot (Franck_Ver@C3033BF6.B86F1645.C91367C6.IP) (Ping timeout)
[17:35:46] *** Joins: franckverrot (Franck_Ver@C3033BF6.B86F1645.C91367C6.IP)
[17:35:48] *** Quits: canhtak (canhtak@moz-4B5B3414.wl.t.ulaval.ca) (Quit: canhtak)
[17:37:15] *** Quits: kngl (Adium@moz-18BD1C.ipv4.evonet.be) (Quit: Leaving.)
[17:38:30] *** Joins: kngl (Adium@moz-18BD1C.ipv4.evonet.be)
[17:40:58] *** Quits: sk (sk@9E6B574B.EB2AA036.2CAF0D3B.IP) (Quit: Leaving)
[17:41:30] *** Quits: sellout (Adium@moz-1D225F38.hsd1.co.comcast.net) (Quit: Leaving.)
[17:41:38] *** Quits: pyon (user@A16F2BE6.A9B419CB.1C8C8CE9.IP) (Client exited)
[17:41:44] *** Joins: pyon (user@A16F2BE6.A9B419CB.1C8C8CE9.IP)
[17:42:04] *** Joins: maxli (maxli@moz-F47DD19B.student.cs.uwaterloo.ca)
[17:42:22] *** Quits: hoverbear (hoverbear@EBFA78B5.F19E5E7B.E74D50F2.IP) (Quit: Taking a nap.)
[17:43:22] *** Joins: short (Mibbit@moz-3D556E4B.amazon.com)
[17:43:48] <short> does anyone know how you can express u8 literals in source code?
[17:43:49] *** Joins: hoverbear (hoverbear@EBFA78B5.F19E5E7B.E74D50F2.IP)
[17:44:10] <rca> short: let a = 1u8;
[17:44:30] <short> something like match letter { u8'o' => "the letter o", u8'x' => "the letter x" };
[17:44:33] <rca> same thing for the other ones. 1u32, 1i64, etc.
[17:44:48] <short> oh!
[17:44:50] *** Quits: sw17ch (sw17ch@moz-62998E95.hfc.comcastbusiness.net) (Quit: sw17ch)
[17:44:54] <rca> ah, 'o' as u8 would be my gest
[17:45:00] <rca> guess*
[17:45:19] *** Joins: adridu59 (Mibbit@moz-E1FF077C.rev.numericable.fr)
[17:45:28] *** Joins: sellout (Adium@2917A62E.8B65BA63.1D2A2C57.IP)
[17:45:31] *** Quits: maxiepoo (Max@moz-DEDB4821.nuwlan.northwestern.edu) (Quit: maxiepoo)
[17:45:40] *** Joins: FreeFull (freefull@moz-4C3B39E9.as13285.net)
[17:45:42] <adridu59> it would be really cool to hide stderr of tests marked should_fail
[17:45:58] *** Quits: Cevn_ (sameer@moz-57F2D062.v4.wm.edu) (Ping timeout)
[17:46:03] *** Joins: sw17ch (sw17ch@moz-62998E95.hfc.comcastbusiness.net)
[17:46:25] <short> Hmm, doesn't work. also { 'o' as u8' } => ...
[17:46:26] <short> doesn't work
[17:47:57] *** Joins: Cevn_ (sameer@moz-57F2D062.v4.wm.edu)
[17:48:53] <rca> i didn't saw it was in a match... what are you matching on ? a u8?
[17:49:15] <rca> in this case you should cast the thing you're matching on to a char.
[17:49:20] <rca> short^
[17:50:52] *** Joins: alonlevy (alon@moz-61A0AD83.red.bezeqint.net)
[17:51:12] *** Quits: itdaniher (it@moz-7FAAAB8D.bstnma.fios.verizon.net) (Ping timeout)
[17:52:27] *** Quits: olem (olem@moz-D8B40BE5.fbx.proxad.net) (Ping timeout)
[17:52:44] *** Quits: dew (Instantbir@moz-9D36B7B6.static.stls.mo.charter.com) (Ping timeout)
[17:53:03] *** Quits: Kynes (Kynes@moz-3DC6C6E7.mit.edu) (Quit: Leaving)
[17:53:06] *** Joins: olem (olem@moz-D8B40BE5.fbx.proxad.net)
[17:55:52] *** Quits: jnsk (Mibbit@moz-829EE15C.dsl.static.sonic.net) (Quit: http://www.mibbit.com ajax IRC Client)
[17:56:34] *** Quits: awidegreen (awidegreen@moz-9FADBE94.a357.priv.bahnhof.se) (Ping timeout)
[17:56:53] *** Quits: Ralith (ralith@moz-67D4EB93.customer.broadstripe.net) (Ping timeout)
[17:57:12] <short> yeah, thanks rca. That's what I ended up doing.
[17:57:29] <short> I was kind of hoping to do the cast in the match, but it makes more sense to do the cast above.
[17:58:20] <short> https://github.com/ShortStomp/ConwayGameOfLife-RUST/blob/master/grid_builder.rs#L30
[17:58:27] <short> instead of inside the pattern match
[18:00:13] *** Joins: Ralith (ralith@moz-67D4EB93.customer.broadstripe.net)
[18:00:17] *** Joins: mouse (mouse@moz-32DFB3CF.broadband.corbina.ru)
[18:00:25] *** Quits: autra (augustin@A14DAE84.7F753DD1.EE2CA32B.IP) (Quit: by!)
[18:01:33] *** Quits: heftig (heftig@C0A4613F.608A649E.172227A7.IP) (Ping timeout)
[18:01:51] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[18:02:19] *** Quits: benjamin_ (benjamin@moz-F3225091.dip0.t-ipconnect.de) (Ping timeout)
[18:03:08] *** Joins: dew (Instantbir@moz-9D36B7B6.static.stls.mo.charter.com)
[18:03:31] *** Quits: ljrmorgan (Mibbit@10DE4E3D.84C11B46.A3649FCA.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[18:03:31] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[18:03:57] *** Quits: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp) (Client exited)
[18:04:44] <bstrie> bjz: ugh, don't go promoting rust in go-nuts :P
[18:05:15] <bjz> bstrie: not promoting, clarifying
[18:05:22] <bjz> :P
[18:05:49] <bstrie> there's no point in reasoning with people who try to associate "having multiple pointer types" with "beating your wife"
[18:05:55] <Ms2ger> Wat
[18:06:10] <Ms2ger> Having multiple pointer types is obviously much worse
[18:06:20] *** Quits: short (Mibbit@moz-3D556E4B.amazon.com) (Quit: http://www.mibbit.com ajax IRC Client)
[18:13:31] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[18:13:44] *** Quits: adridu59 (Mibbit@moz-E1FF077C.rev.numericable.fr) (Quit: http://www.mibbit.com ajax IRC Client)
[18:14:38] *** Quits: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net) (Quit: ziad)
[18:16:53] *** Quits: sedman (sedman@E4D2F0A.47298EC7.57E8EAD3.IP) (Ping timeout)
[18:17:08] *** Quits: ofeldt (ofeldt@moz-92294A54.dip0.t-ipconnect.de) (Ping timeout)
[18:17:14] *** Joins: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net)
[18:17:33] *** Joins: pilf (pilf@moz-E8842E0A.dsl.bell.ca)
[18:18:24] <pilf> hello, was just starting playing around with Rust on a Debian box.  It seems to produce quite large exectuables (~3mb).
[18:18:27] <pilf> Is this normal?
[18:18:42] <pilf> and is there a way to make smaller?
[18:19:10] <Ms2ger> Yeah, static linking
[18:20:09] <pilf> so is there a way to dynamic linking?
[18:20:27] <Ms2ger> I believe so, but I don't know how
[18:20:29] <Ms2ger> bstrie?
[18:21:14] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[18:21:39] <Matthias247> sw17ch: I wrote you a quite excessive answer about my thoughts :)
[18:22:35] *** Quits: tq (tq@moz-9FE9CCF4.a251.priv.bahnhof.se) (Quit: tq)
[18:23:29] <bstrie> pilf: there is a way to use dynamic linking instead, but I forget what the compiler flag is...
[18:23:58] <pilf> ok, well now I know what I'm searching for so that's useful
[18:24:02] <pilf> thanks chaps
[18:24:18] *** Quits: CarpNet (ac@moz-FD24B77.sohonet.co.uk) (Quit: Leaving)
[18:24:25] *** Quits: FreeFull (freefull@moz-4C3B39E9.as13285.net) (Ping timeout)
[18:24:55] <SiegeLord> You do -Z prefer-dynamic
[18:25:09] <SiegeLord> Or, just build one of your dependencies with a --lib ;)
[18:25:12] <bstrie> pilf: ^
[18:25:48] <pilf> ah ha, great thanks
[18:25:51] <pilf> I shall try :)
[18:26:00] <bstrie> pilf: on my machine, prefer-dynamic takes hello world from 2MB to 7kb
[18:26:44] <pilf> that's really good.
[18:27:09] <SiegeLord> I do think static size is somewhat of a problem, but I haven't heard a clear answer as to why it happens
[18:28:08] <pilf> I guess static linking is what you'd want most of the time
[18:28:42] <SiegeLord> Rust doesn't make preserving ABI compatibility, so shared libraries lose many of their advantages
[18:28:53] <SiegeLord> *doesn't make it easy to preserver
[18:29:03] <SiegeLord> Good lord, I'm so typy today
[18:29:09] *** Joins: bmats (bmats@moz-87F0A991.hfc.comcastbusiness.net)
[18:30:47] *** Joins: ziad (ziad@B20586FB.BDB3D91.6E370BFC.IP)
[18:31:17] <geal> could someone tell me where I did something wrong? https://gist.github.com/Geal/8460511
[18:31:30] <geal> I'm sure there is a mut I have to write somewhere, but I cannot figure out where
[18:34:14] *** Quits: echristo (echristo@4241698A.2E4FD3DD.225F4543.IP) (Quit: echristo)
[18:34:23] *** Joins: glaebhoerl_ (glaebhoerl@moz-B5B88D72.catv.broadband.hu)
[18:35:07] <SiegeLord> geal: In the definition of the struct A
[18:35:07] <sw17ch> Matthias247: ah, thank you
[18:35:56] *** Quits: alonlevy (alon@moz-61A0AD83.red.bezeqint.net) (Ping timeout)
[18:36:16] *** Joins: hjr3 (hradtke@moz-4CC6BC5F.public.wayport.net)
[18:37:41] *** Parts: pilf (pilf@moz-E8842E0A.dsl.bell.ca) ()
[18:38:15] <Matthias247> sw17ch: you are free to comment if that makes sense for you or not :-)
[18:38:16] *** Joins: pilf (pilf@moz-E8842E0A.dsl.bell.ca)
[18:38:23] *** Joins: dmac (dmac@moz-E7EA111C.clients.kiwiirc.com)
[18:38:41] *** Quits: dmac (dmac@moz-E7EA111C.clients.kiwiirc.com) (Quit: http://www.kiwiirc.com/ - A hand crafted IRC client)
[18:38:43] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[18:38:52] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[18:38:59] *** Joins: trinary (Adium@moz-D78CD0D5.hsd1.co.comcast.net)
[18:39:05] *** Joins: dmac (Adium@moz-99EF2EE6.hfc.comcastbusiness.net)
[18:40:13] *** Joins: echristo (echristo@E55635C9.D6CCE4AE.77834EAA.IP)
[18:41:13] *** Joins: canhtak (canhtak@moz-4B5B3414.wl.t.ulaval.ca)
[18:41:44] *** Quits: Denommus (user@3DB4BE1F.52AB7E0B.B9657DD5.IP) (Quit: ERC Version 5.3 (IRC client for Emacs))
[18:41:55] *** Joins: vgeddes (vincent.ge@moz-4C6314FC.dsl.mweb.co.za)
[18:42:20] *** Joins: hdevalence (quassel@moz-D125A39F.home3.cgocable.net)
[18:43:23] *** Quits: lkuper (lkuper@moz-6881CCA2.dhcp-bl.indiana.edu) (Ping timeout)
[18:43:28] *** Joins: lkuper (lkuper@moz-6881CCA2.dhcp-bl.indiana.edu)
[18:43:44] *** Joins: mib_cf1ftr (Mibbit@610E11D8.C908B41C.B7830B68.IP)
[18:43:47] *** Quits: Cevn_ (sameer@moz-57F2D062.v4.wm.edu) (Ping timeout)
[18:43:52] *** Quits: canhtak (canhtak@moz-4B5B3414.wl.t.ulaval.ca) (Quit: canhtak)
[18:44:05] *** Quits: mib_cf1ftr (Mibbit@610E11D8.C908B41C.B7830B68.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[18:45:24] *** Joins: canhtak (canhtak@moz-4B5B3414.wl.t.ulaval.ca)
[18:46:44] *** Quits: canhtak (canhtak@moz-4B5B3414.wl.t.ulaval.ca) (Quit: canhtak)
[18:47:54] *** Quits: fairfieldt (fairfieldt@moz-D8998E1C.xen.prgmr.com) (Ping timeout)
[18:48:15] *** Quits: btipling (btipling@moz-D51E0AEB.xen.prgmr.com) (Ping timeout)
[18:48:20] *** Joins: jhasse (jhass_000@moz-8F722ED4.ewe-ip-backbone.de)
[18:48:22] <geal> SiegeLord: I thought mut declarations in struct did not work anymore?
[18:48:51] *** Quits: nyux (nyux@moz-1CEE0DD2.aiiane.com) (Ping timeout)
[18:48:54] *** Quits: hdevalence (quassel@moz-D125A39F.home3.cgocable.net) (Connection reset by peer)
[18:48:59] *** Quits: xoebus (xoebus@moz-A192BC54.xen.prgmr.com) (Ping timeout)
[18:49:10] *** Joins: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP)
[18:49:16] *** Quits: ldunn (username@moz-94CB0FA.cyberius.net) (Ping timeout)
[18:49:23] <SiegeLord> geal: &mut still does
[18:49:52] <geal> so I write "reader: &'a mut r" ?
[18:49:53] *** Joins: sko (Mibbit@A8177190.9E5415FF.DDE5D3F6.IP)
[18:50:32] <SiegeLord> Yep
[18:50:54] *** Joins: Cevn_ (sameer@moz-57F2D062.v4.wm.edu)
[18:51:20] *** Joins: btipling (btipling@moz-D51E0AEB.xen.prgmr.com)
[18:51:58] <egghead> how can I used named lifetypes inside of a match statement?
[18:52:13] *** Joins: fairfieldt (fairfieldt@moz-D8998E1C.xen.prgmr.com)
[18:52:17] <geal> suzak: alright, thanks!
[18:52:22] *** Joins: xoebus (xoebus@moz-A192BC54.xen.prgmr.com)
[18:52:44] *** Joins: ldunn (username@moz-94CB0FA.cyberius.net)
[18:53:09] *** Joins: jensnock_ (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[18:53:30] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[18:54:01] *** Joins: canhtak (canhtak@moz-4B5B3414.wl.t.ulaval.ca)
[18:54:26] *** Quits: jyeo (Adium@moz-6F715C5D.singnet.com.sg) (Quit: Leaving.)
[18:54:50] <awhit> I have made a bugfix for one of the files in libextra, what is the protocol to get it comitted?
[18:55:04] *** Joins: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp)
[18:55:32] *** Quits: noy` (user@moz-44A5916A.a146.priv.bahnhof.se) (Client exited)
[18:55:36] <SiegeLord> awhit: Add tests, run them and then make a pull request, 
[18:57:15] *** Quits: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp) (Ping timeout)
[18:57:48] *** Joins: dylukes (dylukes@moz-B5418F79.hsd1.pa.comcast.net)
[18:58:14] *** Joins: zelda (Mibbit@moz-4014DDC7.ga.at.cox.net)
[18:59:08] <steveklabnik> awhit: SiegeLord is correct, ther'es a full guide here: https://github.com/mozilla/rust/wiki/Note-guide-for-new-contributors
[18:59:53] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[19:00:30] *** Joins: sk (sk@61A494B3.BA40E8A.AAC02D62.IP)
[19:01:05] *** Joins: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp)
[19:01:41] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[19:01:41] *** Quits: kngl (Adium@moz-18BD1C.ipv4.evonet.be) (Ping timeout)
[19:01:58] *** Quits: Cevn_ (sameer@moz-57F2D062.v4.wm.edu) (Ping timeout)
[19:02:07] *** Joins: carllerche (carllerche@moz-2B516F15.hsd1.or.comcast.net)
[19:02:10] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[19:02:50] <Tobba> hm
[19:02:55] *** Joins: tetsuhar_ (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp)
[19:03:00] <Tobba> I think I can make a macro for inline function definitions
[19:03:05] <zelda> Why is Go faster than Rust in the http response benchmark? Doesn't Go use m:n threading as well? http://cmr.github.io/blog/2014/01/12/the-state-of-rust-0-dot-9/
[19:03:18] *** Quits: jensnock_ (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[19:03:20] *** Quits: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp) (Ping timeout)
[19:03:31] <Tobba> iirc rust network APIs are a bit lacking
[19:03:48] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[19:03:53] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[19:03:57] <steveklabnik> zelda: rust has had very little optimization work done on it
[19:04:06] <awhit> so, I forked the main repo, cloned in onto my machine, made the change, added a test, pushed back to my own repo, now I create a pull request?
[19:04:07] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Broken pipe)
[19:04:22] <steveklabnik> often, benchmarks come out, and someone profiles, and sees "oh, this one function that's getting called zillions of times is written in the simplest way possible and is really slow"
[19:04:24] <steveklabnik> awhit: exactly!
[19:04:26] *** Joins: chromatic (chromatic@moz-28CBC7F4.hsd1.or.comcast.net)
[19:04:38] *** Quits: tetsuhar_ (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp) (Ping timeout)
[19:05:40] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[19:05:46] *** Joins: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[19:06:13] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[19:06:18] *** Quits: pyon (user@A16F2BE6.A9B419CB.1C8C8CE9.IP) (Client exited)
[19:06:56] *** Joins: pyon (user@A16F2BE6.A9B419CB.1C8C8CE9.IP)
[19:08:09] <cmr> zelda: yes, but they're not going through libuv etc.
[19:09:04] <Matthias247> afaik Go does simply perform the IO and the active thread
[19:09:22] <Matthias247> which means when you have a lot of blocking reads the number of threads in Go explodes
[19:09:58] *** Joins: alonlevy (alon@moz-EB7C9CF3.telavivmakers.org)
[19:11:20] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[19:11:40] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Ping timeout)
[19:11:40] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[19:12:11] *** Quits: andre (andre@CA528A4A.45A4338E.8EE27E6.IP) (Quit: leaving)
[19:12:19] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[19:12:19] *** ChanServ sets mode: +ao brson brson
[19:13:30] *** Joins: FreeFull (freefull@moz-B97513EF.as13285.net)
[19:16:32] *** Quits: FreeFull (freefull@moz-B97513EF.as13285.net) (Ping timeout)
[19:17:54] <lucian> Matthias247: yeah, all IO and FFI calls invoke the scheduler, which schedules all other goroutines away from the current thread
[19:18:09] *** Quits: olem (olem@moz-D8B40BE5.fbx.proxad.net) (Quit: Leaving...)
[19:18:21] *** Quits: Jesin (Jesin@moz-A43618DF.res.lehigh.edu) (Quit: Leaving)
[19:19:25] *** Quits: claudiu (claudiu@moz-D5BFAAB5.hsd1.ca.comcast.net) (Input/output error)
[19:19:45] *** Joins: claudiu (claudiu@moz-D5BFAAB5.hsd1.ca.comcast.net)
[19:19:46] *** Joins: itdaniher (it@moz-7FAAAB8D.bstnma.fios.verizon.net)
[19:20:00] <zelda> I am trying to play around with reference-counted cycles. Why doesn't this compile? https://gist.github.com/anonymous/8461522
[19:20:33] <kimundi> egghead: What do you need a named lifetime for in the match?
[19:20:42] <mcpherrin> zelda: It would be helpful if you included the error message in your gist :-)
[19:21:02] *** Quits: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP) (Ping timeout)
[19:21:04] <zelda> mcpherrin: I don't know how to copy text from the Windows terminal :(
[19:21:13] <Matthias247> because you built an infinite large struct :)
[19:21:25] <mcpherrin> zelda: uh, right click on the title bar and choose edit-> select? Something like that.
[19:21:27] *** Quits: claudiu (claudiu@moz-D5BFAAB5.hsd1.ca.comcast.net) (Ping timeout)
[19:21:32] <kimundi> Tobba: What do you mean with "making a macro for inline function definitions"? :)
[19:21:34] <zelda> mcpherrin: Thanks :D
[19:21:38] <steveklabnik> zelda: yup, Matthias247 is right
[19:21:46] <steveklabnik> well
[19:21:48] <steveklabnik> hmmmmmm
[19:21:55] <mcpherrin> or maybe it's labelled "mark".  I don't like the windows terminal :-P
[19:22:06] <Tobba> kimundi: I was thinking of doing something that would expand to { fn _temp() { <code> } _temp }
[19:22:11] <Tobba> that should work, I think
[19:22:34] <o11c> IIRC on windows you have to choose "mark", select your area, then choose "copy"
[19:22:46] <kimundi> Tobba: For returning a raw function pointer, you mean? Sounds useful, yeah :)
[19:22:56] *** Joins: io2 (io2@moz-871549F5.home.otenet.gr)
[19:23:00] <Tobba> also in my case IRQ handlers
[19:23:04] <egghead> kimundi: I was confusing myself, I eventually finally able to implement 'tail' over a linked list in rust
[19:23:05] <Tobba> so I dont need functions all over
[19:23:08] <egghead> feels like a big milestone :p
[19:23:14] <Tobba> though I think fn() { } syntax was planned
[19:23:17] <kimundi> Ah, so makeshift raw function pointer lambdas xD
[19:23:30] <Tobba> pretty much yeah
[19:23:31] <egghead> aatch helped me with the type signature yesterday
[19:23:40] <zelda> mcpherrin: Here is the code that does not compile and the error message. https://gist.github.com/anonymous/8461594
[19:23:48] <kimundi> egghead: \o/
[19:24:13] <egghead> :)
[19:24:17] <egghead> https://gist.github.com/eggsby/8428866
[19:24:29] <egghead> probably should return an option instead of failing
[19:24:45] <egghead> but hooray using named lifetimes
[19:25:03] *** Quits: canhtak (canhtak@moz-4B5B3414.wl.t.ulaval.ca) (Quit: canhtak)
[19:25:05] <mcpherrin> zelda: ah, so your first problem is the temporaries-don't-live-long-enough bug
[19:25:17] <kimundi> Tobba: I don't think such syntax is _planned_ - if anything, regular closure literals might become generic and coerce - though if we'd have a seperate literal, it would likely look like that, yeah
[19:25:35] <Tobba> I think eddyb liked the idea
[19:25:36] <Tobba> but I dunno
[19:25:46] *** Joins: FreeFull (freefull@moz-9BE2FC61.as13285.net)
[19:25:48] <zelda> mcpherrin: So I ran into a bug?
[19:25:52] <mcpherrin> zelda: See the comments I just posted on https://gist.github.com/anonymous/8461522
[19:26:07] *** Joins: heftig (heftig@moz-6E893B28.dip0.t-ipconnect.de)
[19:26:09] <kimundi> egghead: Looks good :)
[19:26:09] <mcpherrin> zelda: well, your code still won't work once that's sorted :P
[19:26:51] <eddyb> Tobba: which idea?
[19:26:53] <zelda> mcpherrin: Why? See comments?
[19:27:02] <Tobba> eddyb: fn() { } blocks
[19:27:08] <eddyb> nope, I dislike it
[19:27:11] <Tobba> crap
[19:27:20] <eddyb> Tobba: the fact that 'static || is not Pod+Send+Freeze is a bug
[19:27:34] <Tobba> ah, right
[19:27:41] <kimundi> Btw, Yurume updated his Rust type periodic table today - if anyone wants to take a look at the new version: http://cosmic.mearie.org/2014/01/periodic-table-of-rust-types/
[19:27:56] *** Joins: azakai (alon@moz-BBE3ABD.mv.mozilla.com)
[19:28:13] <mcpherrin> zelda: I think you need to implement Clone for Foo and then put a .clone() in there somewhere.
[19:28:20] <eddyb> Tobba: I ran into it when I disabled bare fn -> closure coercion for non-statically-resolved functions
[19:30:21] *** Joins: Cevn_ (sameer@moz-57F2D062.v4.wm.edu)
[19:31:02] <zelda> mcpherrin: Why is b.y moved?
[19:32:22] *** Quits: Cevn_ (sameer@moz-57F2D062.v4.wm.edu) (Ping timeout)
[19:32:33] <mcpherrin> zelda: because you "move" it into the variable f
[19:32:43] <mcpherrin> zelda: instead, you want to clone it
[19:34:16] *** Quits: pyon (user@A16F2BE6.A9B419CB.1C8C8CE9.IP) (Ping timeout)
[19:34:22] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[19:36:11] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[19:36:16] <zelda> mcpherrin: But in my example I did not assign it to a variable... so why was it moved?
[19:36:43] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[19:37:58] <cmr> rusti: (42).clone()
[19:38:03] -rusti- pastebinned 37 lines of output: http://ix.io/9Ur
[19:38:09] <cmr> heh
[19:38:10] <cmr> good enough
[19:38:25] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[19:38:41] *** Joins: jviereck (Adium@moz-56DDD13.dip0.t-ipconnect.de)
[19:39:19] *** Quits: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP) (Ping timeout)
[19:39:55] *** Quits: FreeFull (freefull@moz-9BE2FC61.as13285.net) (Ping timeout)
[19:40:02] <zelda> The whole std::cell module is so confusing to me
[19:40:31] *** Quits: alonlevy (alon@moz-EB7C9CF3.telavivmakers.org) (Ping timeout)
[19:40:53] *** Joins: dymk (dymk@E897BA2D.23BAEFA7.3FBA778E.IP)
[19:41:04] <dymk> :< so, building is still broken on OSX 10.9? 
[19:41:09] *** Joins: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP)
[19:42:18] <dymk> it seems like https://github.com/mozilla/rust/issues/11162 is the cause of it
[19:42:30] <trinary> linking librustc.dylib has been failing for me, just been doing ./configure && make
[19:42:42] *** Joins: elux (peter@B6F21F4B.1F20BC31.2170E5F.IP)
[19:42:43] *** Quits: elux (peter@B6F21F4B.1F20BC31.2170E5F.IP) (Quit: elux)
[19:42:45] *** Quits: willingc (willingc@moz-B4760708.san.res.rr.com) (Client exited)
[19:42:53] <dymk> libstd.rlib is failing for me
[19:43:09] <cmr> acrichto: ^
[19:43:26] <acrichto> dymk: do you have a pastebin log?
[19:43:31] <dymk> I do, one sec
[19:43:35] <acrichto> trinary: same, do you have a pastebin log?
[19:44:14] <dymk> acrichto, http://pastebin.mozilla.org/4030628
[19:44:25] <acrichto> dymk: yeah that's #11162
[19:44:49] <trinary> yep, lots of stuff snipped from the top: http://pastebin.com/ieDsYxrT
[19:44:51] *** Joins: tq (tq@moz-9FE9CCF4.a251.priv.bahnhof.se)
[19:44:53] *** Joins: trevor_ (trevor@moz-F6C93216.hsd1.mn.comcast.net)
[19:45:21] *** Joins: willingc (willingc@moz-B4760708.san.res.rr.com)
[19:45:21] <cmr> acrichto: do you know what the problem is with the system llvm?
[19:45:40] <acrichto> trinary: looks like you need to clean out the old llvm build tree
[19:45:50] *** Quits: willingc (willingc@moz-B4760708.san.res.rr.com) (Client exited)
[19:46:02] <acrichto> cmr: dunno, my guess its that it's barfing on our archives because the archives contain non-object files
[19:46:06] *** Joins: vadimg (vadimg@BCFFDE00.DF0A212.39C00A7A.IP)
[19:46:07] <cmr> :(
[19:46:07] <acrichto> as to why it does that, I'm not sure
[19:46:26] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[19:46:42] <johnsoft> how do you convert a string to a utf-8 byte vector?
[19:46:49] <cmr> johnsoft: .as_bytes()
[19:46:50] <johnsoft> (opposite of str::from_utf8)
[19:47:01] <johnsoft> thanks
[19:47:25] <trinary> make clean and blew away ./x86_64-apple*, let's see...
[19:47:42] <acrichto> trinary: that should do it yeah
[19:47:52] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[19:47:52] *** ChanServ sets mode: +ao brson brson
[19:48:19] *** Joins: pzol (pzol@moz-553BEE64.dynamic.chello.pl)
[19:52:25] *** Joins: lucian (lucian@moz-8408FDFA.cable.virginm.net)
[19:54:06] *** Quits: hoverbear (hoverbear@EBFA78B5.F19E5E7B.E74D50F2.IP) (Quit: Taking a nap.)
[19:55:33] *** Quits: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com) (Ping timeout)
[19:56:12] *** Quits: zelda (Mibbit@moz-4014DDC7.ga.at.cox.net) (Quit: http://www.mibbit.com ajax IRC Client)
[19:56:25] *** Quits: _Vi (vi@D7277DB6.6FF508C1.10C239DF.IP) (Ping timeout)
[19:56:44] *** Joins: canhtak (canhtak@moz-4B5B3414.wl.t.ulaval.ca)
[19:58:33] *** Quits: io2 (io2@moz-871549F5.home.otenet.gr) (Ping timeout)
[19:59:14] *** Joins: Jemaclus (Mibbit@4EEAB704.5843BA5A.D4E4C7A5.IP)
[19:59:45] *** Joins: alonlevy (alon@moz-EB7C9CF3.telavivmakers.org)
[19:59:47] *** Joins: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com)
[20:00:07] *** Joins: voxpopuli (fanservice@moz-FE161659.wv.cc.cmu.edu)
[20:00:20] *** Joins: ljrmorgan (Mibbit@54CD300B.4315EAB6.F2A80E0C.IP)
[20:00:56] <Matthias247> acrichto: what I meant is using the pipe/eventfd only for wakeup/signaling. The actual data would be further copied directly into the receivers address space.
[20:01:30] *** Quits: lucian (lucian@moz-8408FDFA.cable.virginm.net) (Input/output error)
[20:01:48] <acrichto> Matthias247: so with windows, can you cancel callbacks?
[20:01:51] *** Joins: lucian (lucian@moz-8408FDFA.cable.virginm.net)
[20:02:07] *** Joins: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp)
[20:02:50] *** Quits: hjr3 (hradtke@moz-4CC6BC5F.public.wayport.net) (Quit: My MacBook has gone to sleep. ZZZzzz)
[20:03:31] *** Quits: lucian (lucian@moz-8408FDFA.cable.virginm.net) (Ping timeout)
[20:04:22] *** Quits: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp) (Ping timeout)
[20:04:36] <Matthias247> acrichto: the one to the OS? Don't know. Propably not, because you won't know when they are executed
[20:05:03] <Matthias247> but at least you can cancel them drop them when they are back in your process
[20:05:11] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[20:05:18] <acrichto> I'm still finding it difficult to wrap my head around any API, I'd have to see it concretely I think
[20:05:30] <acrichto> the worry about selecting over a BufferedReader I think is legitimate as well
[20:05:37] <acrichto> but we don't necessarily have to require it
[20:05:48] <Matthias247> same for me. That's why I started implementing to see how it comes out
[20:06:13] <Matthias247> I think a BufferedReader would work only good with synchronous blocking IO
[20:06:45] *** Joins: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net)
[20:06:45] *** ChanServ sets mode: +o tjc
[20:07:10] *** Joins: ramitos (ramitos@moz-60679625.socal.res.rr.com)
[20:07:13] *** Quits: canhtak (canhtak@moz-4B5B3414.wl.t.ulaval.ca) (Quit: canhtak)
[20:07:18] *** Quits: amro (quassel@D9E34ACF.8AAAF769.FAAB0799.IP) (Client exited)
[20:07:41] *** Joins: hjr3 (hradtke@moz-4CC6BC5F.public.wayport.net)
[20:08:32] *** Joins: kngl (Adium@E5907D90.770DEA4D.7C797F8E.IP)
[20:09:54] *** Quits: awhit (Mibbit@moz-6A565CEE.ee.ic.ac.uk) (Quit: http://www.mibbit.com ajax IRC Client)
[20:13:21] *** Quits: KindOne (KindOne@moz-C1511E4F.dynamic.ip.windstream.net) (Ping timeout)
[20:14:15] *** Quits: Jemaclus (Mibbit@4EEAB704.5843BA5A.D4E4C7A5.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[20:14:37] *** Joins: claudiu (claudiu@moz-6F0C4397.thefacebook.com)
[20:14:46] *** Joins: erdos (erdos@moz-2E04CCAB.static.ziggozakelijk.nl)
[20:17:45] *** Joins: KindOne (KindOne@moz-DCBC5EC4.dynamic.ip.windstream.net)
[20:18:05] *** Quits: erdos (erdos@moz-2E04CCAB.static.ziggozakelijk.nl) (Quit: leaving)
[20:18:11] *** Quits: Amaranth (travis@moz-F81BB56A.cpe.cableone.net) (Ping timeout)
[20:18:17] *** Quits: dymk (dymk@E897BA2D.23BAEFA7.3FBA778E.IP) (Quit: This computer has gone to sleep)
[20:18:25] <eddyb> talking to a long time friend: she: "the big bodyguard happens to own my heart" me: "does that mean someone else can borrow your heart?" "but your heart can't be moved?"
[20:19:02] *** Quits: vadimg (vadimg@BCFFDE00.DF0A212.39C00A7A.IP) (Ping timeout)
[20:19:41] <eddyb> it's not even that specific rust lingo. boxes, crates, traits, kinds, Freeze. hmm, I need to make to make a cheatsheet of subtle Rust references
[20:19:48] *** Quits: sko (Mibbit@A8177190.9E5415FF.DDE5D3F6.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[20:20:03] *** Joins: vadimg (vadimg@BCFFDE00.DF0A212.39C00A7A.IP)
[20:20:43] *** Joins: new_one (new_one@7FA65EC.DA451F1E.B3C0173E.IP)
[20:20:56] *** Joins: io2 (io2@moz-871549F5.home.otenet.gr)
[20:21:27] *** Joins: Amaranth (travis@moz-F81BB56A.cpe.cableone.net)
[20:21:43] *** Quits: io2 (io2@moz-871549F5.home.otenet.gr) (Quit: )
[20:21:59] *** Joins: io2 (io2@moz-871549F5.home.otenet.gr)
[20:22:43] *** Quits: victorporof (victorporo@416E2802.271BFD43.9B1E38F4.IP) (Quit: victorporof)
[20:25:19] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[20:25:19] *** ChanServ sets mode: +ao dherman dherman
[20:25:29] *** Joins: joebobjoe (Dale@moz-4014DDC7.ga.at.cox.net)
[20:26:16] *** Joins: LinearInterpol (RJones@moz-E6F82C3A.maine.res.rr.com)
[20:26:27] <joebobjoe> What happens if a value's methods deletes all std::rc::Rc references to the value? Is the value destructed while the method is still executing?
[20:26:30] *** Quits: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Quit: msingle)
[20:28:18] *** Quits: fabiand (fabiand@moz-D2F071D6.adsl.alicedsl.de) (Ping timeout)
[20:28:38] <bvssvni> joebobjoe: The way reference counting is usually implemented, is destructing the value when the counter reaches zero.
[20:28:38] *** Quits: bmats (bmats@moz-87F0A991.hfc.comcastbusiness.net) (Client exited)
[20:29:14] <Tari> I'd expect self holds a reference
[20:29:25] <Tari> so the refcount cannot drop below 1 while the method is executing
[20:30:08] <joebobjoe> Tari: But the method is defined on the type Rc contains, not Rc itself...
[20:30:52] *** Joins: fabiand (fabiand@moz-A4160399.adsl.alicedsl.de)
[20:30:52] <Matthias247> but if the method is called on an instance of the object, it would at last live up to the point the method has finished
[20:30:53] <Tari> then ownership of the contained value is moved or borrowed as necessary
[20:31:04] <Matthias247> because the instance that called it is still outside
[20:31:13] <Tari> the Rc may be dropped, but the value remains
[20:31:25] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[20:33:04] <LQDH> how do people usually deal with high order functions and lifetimes?
[20:33:45] <LQDH> like i want to get references out of a function bieng used inside a high order function
[20:34:54] <trinary> acrichto: build failed in the same spot, am I missing some piece of cleanup?
[20:35:00] <bvssvni> might it happen that inline functions calls the destructor before the end of function, if LLVM swaps instructions?
[20:35:21] <joebobjoe> Are there any tools/compiler args that will show the lifetimes for all variables in a Rust program?
[20:35:48] <joebobjoe> I.e., is there a way to get meaningful info for learning about Rust out of the compiler?
[20:36:44] *** Quits: Ralith (ralith@moz-67D4EB93.customer.broadstripe.net) (Ping timeout)
[20:37:54] <kimundi> joebobjoe: Not like that, no.
[20:38:00] *** Joins: ray (bernhard@moz-FF531B82.vie.surfer.at)
[20:39:00] <kimundi> joebobjoe: Re the earlier question: If you have a reference to something in Rust, then the compiler made sure that the thing the ref points at will not get deallocated during the time you hold the ref
[20:39:04] *** Joins: canhtak (canhtak@moz-4B5B3414.wl.t.ulaval.ca)
[20:39:15] *** Joins: tcsc (tcsc@moz-ADC0ED45.hsd1.ct.comcast.net)
[20:39:24] *** Joins: _Vi (vi@D7277DB6.6FF508C1.10C239DF.IP)
[20:40:02] <kimundi> LQDH: What exatly are you trying to do?
[20:40:27] <LQDH> ill write up a quick example one sec, i suck at explaining :P
[20:41:19] <joebobjoe> kimundi: Oh... I didn't realize you explicitly borrow the value from Rc, which you would have to do to call methods on it.
[20:41:31] *** Joins: hoverbear (hoverbear@moz-2FA237A6.wireless.uvic.ca)
[20:42:04] *** Quits: fabiand (fabiand@moz-A4160399.adsl.alicedsl.de) (Quit: Verlassend)
[20:42:20] <brson> somebody on hn referred to rust as having a pr machine. i took that as mostly a good sign
[20:43:35] *** Quits: FliPPeh (lukas@moz-5A449869.dip0.t-ipconnect.de) (Quit: Lost terminal)
[20:44:59] <acrichto> trinary: oh hm I think I've also seen that happen when you build llvm with gcc and rust with clang, do you have true gcc installed somewhere?
[20:45:44] <joebobjoe> Are explicit calls to destructors allowed in Rust?
[20:46:14] *** Quits: glaebhoerl_ (glaebhoerl@moz-B5B88D72.catv.broadband.hu) (Quit: )
[20:46:24] <LQDH> kimundi: http://pastebin.com/nmG9bg5A
[20:46:35] <LQDH> i might have the lifetimes wrong, i dunno
[20:46:38] <trinary> acrichto: Don't think so, gcc/g++ are from xcode command line toolslemme see if there's another compiler install lying around.
[20:46:50] <brson> cmr: maybe we can start counting 1.0 issues on twir
[20:46:51] *** Joins: samx (sami@moz-D9F3E0AE.pp.htv.fi)
[20:46:56] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[20:47:17] *** Joins: skade (skade@moz-B73EE4D5.pools.arcor-ip.net)
[20:47:18] <acrichto> guilt us into doing more work
[20:47:24] <brson> cmr: in general i'd like to start working harder to incentivize people to start burning them down
[20:47:30] <LQDH> and obvioustly i could reqrite it not to use a high order function, or return the value from the high order function, but its just an example
[20:47:39] <brson> i think there are a number on there now that only require a bit of compiler knowledge
[20:48:05] <brson> i may put together a list of ones that are approachable and post to the ml
[20:48:22] <acrichto> brson: there are a bunch which we postponed saying "we need to make a decision on this for 1.0, but we don't know what to do"
[20:48:39] <acrichto> brson: i.e. we should probably start focusing the weekly meeing on deciding what to do about 1.0 issues that have to clear path forward
[20:48:45] <brson> acrichto: good idea
[20:49:13] *** Joins: nyux (nyux@moz-1CEE0DD2.aiiane.com)
[20:49:21] <ray> looking at Option<T> on http://www.rustforrubyists.com/book/chapter-11.html why do i need to use a match?
[20:49:34] <brson> there are also a number of nice-to-have open-ended activities that everybody can contrtibute to. just need to get them organized
[20:49:35] <ray> isnt the reason to use an option to not care about the type and execute it?
[20:49:48] <ray> like the maybe monad
[20:50:03] <chromatic> Is there some sort of mentoring for "only require a bit of compiler knowledge" tasks? Like kernel janitors?
[20:50:06] *** Quits: hjr3 (hradtke@moz-4CC6BC5F.public.wayport.net) (Quit: My MacBook has gone to sleep. ZZZzzz)
[20:50:33] <brson> chromatic: not quite. we have an 'E-mentor' tag that we're trying to use more, but we're not very good at it
[20:50:40] <brson> would be really great to have more mentor bugs though
[20:50:41] *** Quits: skade (skade@moz-B73EE4D5.pools.arcor-ip.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz)
[20:50:51] *** Joins: skade (skade@moz-B73EE4D5.pools.arcor-ip.net)
[20:50:51] <SiegeLord> Is unreachable() not a thing anymore?
[20:51:01] *** Quits: skade (skade@moz-B73EE4D5.pools.arcor-ip.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz)
[20:51:11] <o11c> the counterintuitive things is: you have to *not* fix the easy bugs
[20:51:15] <acrichto> SiegeLord: it's a macro now
[20:51:26] <bvssvni> ray: .unwrap()
[20:51:37] <SiegeLord> I wonder why I couldn't find it in the documentation
[20:51:40] <chromatic> brson, I saw that. One thing I've seen that worked well is using a wiki page with a high level outline of how to fix the bug or add the feature.
[20:51:58] *** Quits: samx (sami@moz-D9F3E0AE.pp.htv.fi) (Quit: This computer has gone to sleep)
[20:52:12] <chromatic> What o11c said. It can be frustrating but it can also help encourage small contributions if you don't take it too far.
[20:52:17] <ray> bvssvni: is that the recommended way because ive only seen the match construct yet
[20:52:29] <brson> chromatic: yep. we've talked about writing better bug reports for easy/mentor bugs. takes discipline sadly
[20:52:30] <chromatic> (I've also seen core developers write suboptimal code in the hope that drive-by contributors would make it better. Didn't work that way.)
[20:52:49] <bvssvni> ray: .unwrap() will return the value or fail if it's None.
[20:53:03] <ray> fail as in do nothing right?
[20:53:13] <bvssvni> ray: equivalent to calling the fail! macro
[20:54:20] *** Joins: victorporof (victorporo@416E2802.271BFD43.9B1E38F4.IP)
[20:55:03] *** Joins: tbogdala (tbogdala@moz-C5E39CCE.wi.res.rr.com)
[20:55:05] <joebobjoe> Is there any kind of quiz or test to test whether or not you really understand Rust's core features?
[20:55:34] <LQDH> yeah i did get the lifetimes wrong, heres a better example i think: http://pastebin.com/mYmsL67P
[20:56:30] *** Joins: Jemaclus (Mibbit@4EEAB704.5843BA5A.D4E4C7A5.IP)
[20:57:14] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[20:57:25] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[20:57:40] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[20:57:40] *** ChanServ sets mode: +ao brson brson
[20:57:53] <Jemaclus> if I wanted to do a matrix type thing (like x[2][1]),... what type would I use? A vector of vectors?
[20:58:08] <joebobjoe> Jemaclus: How many dimensions will you need?
[20:58:23] <Jemaclus> two, for now
[20:58:59] <kimundi> LQDH: Sorry, was gone for a bit
[20:59:09] <bvssvni> Jemaclus: you can use x+y*w
[20:59:14] <ray> how do i make a mutable field in a struct=
[20:59:26] <ray> does it have to be a pointer?
[20:59:30] <joebobjoe> Jemaclus: Vector of vectors is a fine choice. For any higher dimensionality consider using a n-dim matrix lib
[20:59:41] *** Quits: nielsle (nielsle@moz-C46DA772.boa.fiberby.dk) (Ping timeout)
[20:59:45] <bvssvni> ray: mutability is inherited
[20:59:45] <kimundi> ray: We don't have explicit monadic sugar right now, or even Monads, but there are methods defined on Option for most use cases
[21:00:11] <joebobjoe> Will Rust have streams?
[21:00:17] <strcat> Jemaclus: if you don't need to change the sizes after creation, then making a thin wrapper without double indirection is easy
[21:00:20] <strcat> joebobjoe: what do you mean by streams?
[21:00:22] <bvssvni> ray: let mut a = MyStrict {}, makes every member of the struct mutable
[21:00:32] <kimundi> LQDH: Okay, so
[21:00:38] <joebobjoe> strcat: Lazy sequences?
[21:00:44] <strcat> joebobjoe: we have iterators
[21:00:58] <ray> i see, how do i do that in a constructor?
[21:01:14] <joebobjoe> strcat: Are they a PITA to implement like C++'s iterators?
[21:01:16] <strcat> rusti: use std::iter::count; count(0, 2).take(10).fold(0, |a, b| a + b)
[21:01:17] -rusti- 90
[21:01:21] <ray> pub fn new() -> Str {   mut Str { }    }
[21:01:23] <ray> does not work
[21:01:25] <strcat> joebobjoe: no
[21:01:33] <joebobjoe> strcat: Thank for lord.
[21:01:36] <joebobjoe> Cool thanks
[21:01:47] <strcat> joebobjoe: trait Iterator<T> { fn next(&mut self) -> Option<T>; }
[21:01:49] <bstrie> dbaupp: ping
[21:01:50] <strcat> is what you have to implement
[21:01:52] <Jemaclus> thanks
[21:01:54] <kimundi> LQDH: In line 25, you write "Yes(&'a mut self.lst[i].unwrap());" - the problem is that that means "get the return value of unwrap(), put it in a new temporary local variable, then create a reference to it and store it as the value in the Yes variant"
[21:01:55] <joebobjoe> strcat: WOW :D
[21:02:04] <strcat> joebobjoe: http://static.rust-lang.org/doc/master/std/iter/trait.Iterator.html that's what you get for free
[21:02:06] *** Joins: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp)
[21:02:07] <strcat> lazy map, filter, etc.
[21:02:19] <LQDH> ah yeah, I should be using get_mut_ref right?
[21:02:30] <joebobjoe> strcat: The power of default methods, eh?
[21:02:46] <kimundi> In other words, it'S equivalent to "Yes({ let mut tmp = self.lst[i].unwrap(); let r = &'a mut tmp; r });"
[21:02:47] <strcat> rusti: range(0, 4).cycle().take(15).collect::<~[int]>()
[21:02:48] -rusti- ~[0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2]
[21:03:08] <strcat> rusti: let xs = [8, 9]; range(0, 4).chain(xs.iter()).cycle().take(15).collect::<~[int]>()
[21:03:12] -rusti- pastebinned 52 lines of output: http://ix.io/9Uy
[21:03:17] <joebobjoe> Does Rust have lenses?
[21:03:18] <kvark> LQDH: why even access self.lst[i] inside the "match self.lst[i]" block?
[21:03:22] <strcat> rusti: let xs = [8, 9]; range(0, 4).chain(xs.iter().map(|&x| x)).cycle().take(15).collect::<~[int]>()
[21:03:22] <bvssvni> ray: mutability is checked by the compiler statically, you don't have to return a "mutable struct".
[21:03:31] -rusti- failed to pastebin 6 lines of output
[21:03:45] * strcat wonders if chain is missing clone
[21:03:53] *** Quits: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp) (Ping timeout)
[21:04:10] <kvark> LQDH: can't you just do Yes(v)?
[21:04:15] <kimundi> LQDH: If you want a mutable reference to the content of a Option, then .as_mut() gives you it - it will return a Option<&mut T> though, so you need tu unwrap _that
[21:04:33] <joebobjoe> Does Rust collapse successive maps? E.g., [1,2,3].map().map()
[21:04:34] <ray> so: let mut obj = Class::new();  is enough?
[21:04:51] <strcat> joebobjoe: well LLVM will remove the overhead from adaptors
[21:05:00] <strcat> joebobjoe: map doesn't traverse the whole list, they're list
[21:05:01] <strcat> er
[21:05:01] <kimundi> joebobjoe: Not explicitly, but llvm will do magic for optimized builds
[21:05:03] <strcat> they're lazy*
[21:05:13] <strcat> joebobjoe: ignore the map method on vectors though
[21:05:16] <strcat> deprecated
[21:05:22] <joebobjoe> strcat: In favor of?
[21:05:28] <strcat> joebobjoe: map on iterators
[21:05:30] *** Quits: maxli (maxli@moz-F47DD19B.student.cs.uwaterloo.ca) (Ping timeout)
[21:05:40] <joebobjoe> kimundi: When would someone ever want to compile without optimization
[21:05:50] <joebobjoe> strcat: Ah, ok
[21:05:53] <joebobjoe> strcat: Excellent
[21:05:56] <LQDH> its just an example, in the actual code the high order function is way longer and the enum is too and there are multiple branches in the match
[21:06:01] <strcat> joebobjoe: for example the vector iterator is 2 ptrs internally, start and end
[21:06:09] <strcat> joebobjoe: next() is an increment and a comparison
[21:06:14] <strcat> gets inlined
[21:06:14] *** Quits: nano (nano@moz-ED77243C.superkabel.de) (Connection reset by peer)
[21:06:15] <kimundi> joebobjoe: For a faster result? The default rustc does is unoptimized
[21:06:21] <joebobjoe> strcat: And map returns an iterator? That's excellent
[21:06:28] <strcat> joebobjoe: yes, wraps the vector one inside
[21:06:28] <bvssvni> ray: do you get it?
[21:06:39] <joebobjoe> kimundi: ?
[21:06:42] <strcat> joebobjoe: and LLVM will inline all of the next() methods and eliminate the structs, trivially
[21:06:45] <LQDH> the unwrap was mostly me just bieng dumb, if I use get_mut_ref (is that right?) it still gives me a lifetime problem
[21:06:50] <joebobjoe> kimundi: You mean faster compile times?
[21:06:55] <kimundi> yes
[21:07:12] <joebobjoe> kimundi: Does optimization really add latency to compile times?
[21:07:18] <strcat> joebobjoe: it can almost always do the same optimizations it would do with a hand-rolled loop in C after that point
[21:07:25] <strcat> joebobjoe: yes optimizations are like 90% of the compile-time ;p
[21:07:26] <strcat> when they're on
[21:07:27] <LQDH> same if I do just Yes(v)
[21:07:34] <joebobjoe> strcat: Oh wow
[21:07:36] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[21:07:37] <joebobjoe> Didn't know that
[21:07:55] <joebobjoe> strcat: Does LLVM reorder loops?
[21:07:59] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[21:08:06] <joebobjoe> For branch prediction and or caching
[21:08:18] <LQDH> but they are are different errors, i think the Yes(v) error is caused because i derefrence it on the above line
[21:08:20] <strcat> joebobjoe: well it will reorder blocks, yes
[21:08:35] <strcat> joebobjoe: basic chained iterators form a single loop though
[21:08:36] <kimundi> joebobjoe: Look at http://huonw.github.io/isrustfastyet/mem/ and click on "passes" on the right side. Then look at the lower chart how long "llvm module passes" takes in comparison to everything else
[21:08:50] <strcat> joebobjoe: with a bunch of branches it needs to collapse into one branch (usually trivial to do)
[21:09:20] <joebobjoe> kimundi: Thanks man
[21:09:22] <strcat> there are some like skip that need a loop internally and may or may not optimize away completely
[21:09:25] <joebobjoe> Or woman (sorry)
[21:09:36] <o11c> joebobjoe: on large codebases, -O1 is sometimes faster than -O0, but -O2 always takes at least twice as long as -O0 and -O3 even slower
[21:09:41] *** Joins: hdevalence (quassel@moz-D125A39F.home3.cgocable.net)
[21:09:43] *** Joins: maxli (maxli@moz-EE42E0E.student.cs.uwaterloo.ca)
[21:09:47] *** Quits: voxpopuli (fanservice@moz-FE161659.wv.cc.cmu.edu) (Ping timeout)
[21:09:54] <tq> How do I cast a pointer to u64?   let a = ~3; let b: u64 = a;
[21:09:54] <strcat> in LLVM, -O3 isn't much different than -O2 atm
[21:10:07] <o11c> most of my data *is* from gcc ...
[21:10:17] <kimundi> tq: you wouldn'T in safe rust code - but if neccessary, it would be:
[21:10:18] <joebobjoe> There seems to be an LLVM port for Windows. Does that mean Rust can drop MinGW shenanigans soon?
[21:10:24] <strcat> it enables slp-vectorize (vectorize non-loops), arg-promotion (promote by-ref args to by-value) and raises the inlining threshold - that's *all* ;p
[21:10:27] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[21:10:42] <strcat> slp-vectorize will probably be enabled at -O2 and maybe even other levels soon...
[21:10:45] <kimundi> rusti: let p = ~5; let r: &int = p; r as *int as uint
[21:10:46] -rusti- 140562736877168u
[21:10:56] <strcat> joebobjoe: rust uses LLVM on windows
[21:11:02] <strcat> it's the only backend
[21:11:14] <joebobjoe> strcat: Why do we need MinGW?
[21:11:17] <joebobjoe> Why not VS?
[21:11:20] <strcat> it needs mingw for a linker, C99 runtime, etc.
[21:11:33] <strcat> joebobjoe: VS is just as hard to get as mingw-w64 and not free software
[21:11:38] <joebobjoe> MinGW takes up like 100 MB on my computer :(
[21:11:54] <strcat> we need c99 floating point stuff for one example
[21:11:56] <kimundi> joebobjoe: So does VS :P
[21:12:02] *** Quits: moostik (Icedove@moz-1FF02BE5.w92-151.abo.wanadoo.fr) (Ping timeout)
[21:12:05] <SiegeLord> Damn, from_str_common is really inaccurate
[21:12:10] <joebobjoe> kimundi: Yea but most Windows devs have VS
[21:12:16] <SiegeLord> I was going to use it for tests, but it's unusable
[21:12:27] <Tobba> I kinda want to implement a pure rust C99 lib with FP stuff
[21:12:33] <Tobba> I dont have any need atm though
[21:12:33] <joebobjoe> How hard would it be to switch from MinGW to VS
[21:12:41] <joebobjoe> strcat: Windows is not free software :P
[21:12:44] <kimundi> SiegeLord: Yeah... I wrote it, in a dark time where I though it would be an easy thing to do :P
[21:12:46] <Tobba> + cross compiling the std lib for me will be hell due to how much platform specific stuff there is
[21:12:48] <strcat> joebobjoe: doesn't matter
[21:12:48] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[21:12:49] *** Joins: koomi (koomi@moz-41AD638A.uberspace.de)
[21:12:57] *** Joins: lucian (lucian@moz-8408FDFA.cable.virginm.net)
[21:12:58] <strcat> joebobjoe: mingw bugs can be fixed, VS bugs blocking us cannot be fixed
[21:12:58] <SiegeLord> assert_eq!(1.23-6f64, from_str_common::<f64>("1.23e-6", 10, true, true, true, ExpDec, false, false).unwrap());
[21:13:12] <SiegeLord> That fails... it's not even a particularly pathological float >_<
[21:13:13] <joebobjoe> strcat: Where are these bugs? Mailing list or issues?
[21:13:17] <mcpherrin> I'd like to see support for both mingw and VS but I don't think we (currently) have enough windows contributers
[21:13:26] *** Quits: yuriks (yuriks@50BCCB4D.6C9AD9C4.8E0C6B01.IP) (Ping timeout)
[21:13:30] <strcat> joebobjoe: hm?
[21:13:32] <SiegeLord> kimundi: well, I'm adding even more inaccurate bits on top of yours... ;)
[21:13:33] <Tobba> problem with windows is the stdlib, linking
[21:13:36] <Tobba> and that the build system will be hell
[21:13:42] <joebobjoe> strcat: Where can I find info about the bugs in which you speak
[21:13:49] <strcat> I'm speaking about bugs in general
[21:13:50] *** Joins: yuriks (yuriks@50BCCB4D.6C9AD9C4.8E0C6B01.IP)
[21:14:00] <Tobba> also it relies on gcc for stack unwrapping, no idea how you would handle that on windows
[21:14:05] <Tobba> unwinding*
[21:14:06] *** Joins: Finde (Mibbit@moz-30766381.princeton.edu)
[21:14:07] <kimundi> SiegeLord: Intersting that it fails, insofar as the float literal on the left side of it is being parsed by the same function :P
[21:14:08] *** Joins: dymk (dymk@C94BAFB1.AA444DA9.3FBA778E.IP)
[21:14:09] <LQDH> here is a version that has the error that I think is the problem i'm trying to figure out: http://pastebin.com/0qenupb1
[21:14:20] <strcat> joebobjoe: eventually we won't need mingw for a linker
[21:14:22] <LQDH> sorry for spamming this irc with my stupidity
[21:14:24] <SiegeLord> kimundi: lol, that does make no sense
[21:14:25] <strcat> we'll be using LLD
[21:14:32] <joebobjoe> Windows does have stupid bugs which they refuse to fix. I.e., UTF-8 code tables
[21:14:40] <joebobjoe> strcat: Why not?
[21:14:44] <strcat> because LLVM has a linker
[21:15:00] <joebobjoe> strcat: What about DLLs?
[21:15:13] <kimundi> SiegeLord: Well, it does. The from_str and to_str float implementations are used by the compiler - It's a complicated act even being able to test them for that reason
[21:15:13] <strcat> we can use compiler-rt for the functions LLVM generates
[21:15:26] *** Quits: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com) (Ping timeout)
[21:15:29] <strcat> joebobjoe: we'll still need mingw-w64 for c99, etc.
[21:15:40] <strcat> the runtime
[21:15:52] <kimundi> SiegeLord: "How do you test something on correctness if you can only compare it to itself?" is the issue :P
[21:15:58] <tq> kimundi,  thanks.
[21:16:10] <joebobjoe> Can Rust currently compile to DLLs?
[21:16:18] <SiegeLord> kimundi: Binary representation ;)
[21:16:24] <strcat> joebobjoe: sure
[21:16:27] <kimundi> LQDH: It's alright, the IRC is just busy atm. :)
[21:16:38] <Tobba> basicaly, windows port is possible but you're in for a ride
[21:16:46] <joebobjoe> Isn't VS tooling better than MinGW tooling?
[21:16:51] <Tobba> its MUCH better
[21:16:56] <kimundi> SiegeLord: Well, if we had hex float literals that would indeed be easy :P
[21:17:04] <strcat> joebobjoe: doubt it would work for rust
[21:17:13] <Tobba> rust doesnt have many C++ sections anyways
[21:17:15] <strcat> which part of the tooling are you talking about?
[21:17:18] *** Joins: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp)
[21:17:19] <SiegeLord> kimundi: How would you test the hex float parsing then :P
[21:17:33] <strcat> Tobba: rust doesn't have C++ sections
[21:17:34] *** Quits: veddan (viktor@moz-C79BC80B.csbnet.se) (Client exited)
[21:17:37] <strcat> the compiler uses LLVM which is C++
[21:17:43] *** Quits: mcpherrin (mcpherrin@BB4DB59D.2876C283.70845BE5.IP) (Ping timeout)
[21:17:43] <joebobjoe> strcat: idk
[21:17:43] <Tobba> + the wrapper
[21:17:45] <SiegeLord> It's parsers all the way down
[21:17:46] <Tobba> which you need to build
[21:17:51] <joebobjoe> Will Rust have a vectorization lib before 1.0?
[21:17:58] <kimundi> SiegeLord: That's easy: Hex floats are simply power-of-two notations - they are trivially to construct without rounding errors
[21:18:02] <Tobba> LLVM builds fine on windows (with modifications to their shitty cmake file)
[21:18:02] *** Joins: twi (Adium@moz-512229A7.lns9.lon.bigpond.net.au)
[21:18:07] <strcat> joebobjoe: it has crappy simd vectors already if that's what you mean
[21:18:21] <strcat> Tobba: we can build LLVM by shipping clang in the snapshot
[21:18:26] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[21:18:28] <Tobba> that also works
[21:18:32] <strcat> rust doesn't need to make you install mingw-w64 or VS manually
[21:18:33] <Tobba> clang is massive but oh well
[21:18:34] <strcat> that's unacceptable
[21:18:40] <strcat> Tobba: we need libclang anyway
[21:18:44] <Tobba> yeah fair enough
[21:18:52] <strcat> Tobba: because we need to be able to parse C headers with rustc while compiling
[21:19:03] *** Quits: Ms2ger (Ms2ger@B085914A.CFB9C8ED.F15B0BB3.IP) (Quit: nn)
[21:19:03] <strcat> instead of hardcoding platform-specific information from headers behind 1000 cfg flags
[21:19:05] <strcat> like std::libc
[21:19:06] <strcat> it's a mess
[21:19:06] <kimundi> SiegeLord: In other words, you could write dowen the "correct" values from somewehere else, let them parse by a simple hex-float only function, and then compare to the output of the full implementation for base ten
[21:19:16] *** Joins: FreeFull (freefull@moz-518A6043.as13285.net)
[21:19:24] <Tobba> strcat: oh yeah those
[21:19:25] <Tobba> yep
[21:19:25] <strcat> Tobba: and when you have libclang, shipping the frontend isn't a lot
[21:19:29] *** Quits: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp) (Ping timeout)
[21:19:45] <Tobba> windows has stack unwinding built into the kernel iirc
[21:19:46] <strcat> we could also use libclang as our linker driver
[21:19:50] <Tobba> its all about the linker I think
[21:19:54] <strcat> it'd save work in a bunch of places
[21:19:58] <strcat> can probably use it to do ABIs
[21:20:04] <strcat> instead of doing it wrong ourselves
[21:20:08] *** Joins: samx (sami@moz-D9F3E0AE.pp.htv.fi)
[21:21:09] *** Quits: mouse (mouse@moz-32DFB3CF.broadband.corbina.ru) (Ping timeout)
[21:21:37] *** Joins: jzcz (nick@moz-BF346884.dyn.centurytel.net)
[21:21:40] <Tobba> sounds reasonably sane
[21:21:53] *** Joins: z0w0 (zack@moz-87AABEA0.lnse1.woo.bigpond.net.au)
[21:21:57] *** Quits: jviereck (Adium@moz-56DDD13.dip0.t-ipconnect.de) (Quit: Leaving.)
[21:21:59] <kimundi> LQDH: Hm, thats an interesting error - I can'T tell if you're doing something invalid there or if its just a compiler bug
[21:22:58] <LQDH> kimundi: heh, well I'm glad it's at least not obvious :P
[21:23:11] *** Joins: ofeldt (ofeldt@moz-60ACD2E8.dip0.t-ipconnect.de)
[21:23:14] *** Quits: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com) (Ping timeout)
[21:23:39] *** Joins: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com)
[21:23:47] <Tobba> I'd love to also have the std lib split into platform independant parts and platform dependant
[21:23:48] <joebobjoe> What is a sentence that describes the exact rule on when you can move a value?
[21:24:04] *** Joins: mcpherrin (mcpherrin@BB4DB59D.2876C283.70845BE5.IP)
[21:24:24] *** Quits: mcpherrin (mcpherrin@BB4DB59D.2876C283.70845BE5.IP) (Quit: Reconnecting)
[21:24:24] *** Joins: mcpherrin (mcpherrin@BB4DB59D.2876C283.70845BE5.IP)
[21:24:31] *** Joins: awidegreen (awidegreen@moz-9FADBE94.a357.priv.bahnhof.se)
[21:24:35] <kimundi> LQDH: In any case, it looks very convoluted - would it be possible to rewrite that to not use external iterators, internal iterators, and direct vector indexing all at the same time? :P
[21:25:21] <LQDH> kimundi: haha yeah
[21:25:57] <bvssvni> joebobjoe: you can move a value when it is no longer needed somewhere else
[21:26:03] <Tobba> I like how the stage0 includes libstdc++ now on MinGW after it got too rediclous
[21:26:06] *** Joins: bmats (bmats@moz-87F0A991.hfc.comcastbusiness.net)
[21:26:19] *** Quits: Finde (Mibbit@moz-30766381.princeton.edu) (Quit: http://www.mibbit.com ajax IRC Client)
[21:26:37] <joebobjoe> People always say that you can't move something if it is borrowed. But technically shouldn't it be that you cannot move something if anything in its *ownership tree* is borrowed?
[21:26:59] <kimundi> joebobjoe: Yeah, that would be more correct
[21:27:09] *** Quits: pilf (pilf@moz-E8842E0A.dsl.bell.ca) (Quit: pilf)
[21:27:30] <LQDH> kimundi: the problem is also that i get about 20 different errors depending on what I change, and I don't know which is the one that would actually matter. I'm pretty sure that error is different to the one I had earlier today because it still fails even if you replace the high order function with a loop/remove the loop all together
[21:27:49] *** Joins: Lovot (root@AE31FB56.8153C3BF.F3C9A2D9.IP)
[21:27:55] <kimundi> joebobjoe: However, the simpler form is also correct, as borrowing something in the ownership can be seen as bubbling up the borrow to the whole owner to begin with
[21:28:32] <joebobjoe> kimundi: Okay, but I think that should be explicitly mentioned somewhere in the tutorial. Because as a noob, it would help me understand explicit lifetimes and why we need them.
[21:29:07] *** Quits: tbogdala (tbogdala@moz-C5E39CCE.wi.res.rr.com) (Client exited)
[21:29:13] <kimundi> LQDH: Hm, okay, on tip in general: If the error talks about an expression not living long enough, try putting it in a temporary variable first - right now we have a few issues with to short lifetimes for a few of such cases
[21:29:39] *** Quits: jzcz (nick@moz-BF346884.dyn.centurytel.net) (Quit: Konversation terminated!)
[21:29:45] *** Joins: jzcz (nick@moz-BF346884.dyn.centurytel.net)
[21:29:55] <joebobjoe> kimundi: Actually maybe it does mention it
[21:30:18] *** Quits: samx (sami@moz-D9F3E0AE.pp.htv.fi) (Quit: This computer has gone to sleep)
[21:30:21] *** Joins: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com)
[21:30:38] <kimundi> joebobjoe: Actually, I think you have to start with a borrow of the whole ownership tree anyway, before you can step further down to get a borrow to some of its internal values
[21:31:31] *** Joins: dherman (dherman@moz-B31C6965.dsl.pltn13.sbcglobal.net)
[21:31:31] *** ChanServ sets mode: +ao dherman dherman
[21:31:31] <mcpherrin> kimundi: Maybe we should put that as a suggestion in the error message...
[21:31:34] *** Joins: GreyKnight (GK@moz-1DFE40B6.range86-181.btcentralplus.com)
[21:31:40] <SiegeLord> So, how do we want our exponents printed?
[21:31:48] <SiegeLord> 1.0e-5 or 1.0e-05?
[21:31:57] <SiegeLord> The latter is the C way
[21:32:04] <kimundi> mcpherrin: The temporary lifetime issue? That will hopefully be fixed during the next week, nmatsakis has a patch ready
[21:32:15] <mcpherrin> kimundi: Okay, I wasn't sure what niko's timeline was
[21:32:25] *** Quits: GreyKnight (GK@moz-1DFE40B6.range86-181.btcentralplus.com) (Connection reset by peer)
[21:32:33] <joebobjoe> I've asked this before, but why does Rust's livliness system need explicit lifetimes, anyway? I don't understand why it can't just infer everything...
[21:32:58] <kimundi> SiegeLord: I would say the shortest correct one, so the first. libc probably not a correct-ish implementation anyway :P
[21:33:15] *** Joins: GreyKnight (GK@moz-1DFE40B6.range86-181.btcentralplus.com)
[21:33:21] <kimundi> joebobjoe: It needs it for cases where there are multible options
[21:33:29] *** Quits: kris_ (kris@moz-147EE6DF.diku.dk) (Ping timeout)
[21:33:36] *** Quits: pzol (pzol@moz-553BEE64.dynamic.chello.pl) (Quit: My MacBook Pro has gone to sleep. ZZZzzz)
[21:33:36] <SiegeLord> There are different definitions of correct, and libc fulfills one of them
[21:33:52] *** Joins: Cevn_ (sameer@moz-F316C21E.hr.hr.cox.net)
[21:33:52] <GreyKnight> I have a question about this code sample: http://pastebin.com/aTPxbP80
[21:34:04] <kimundi> fn foo(&'a A, &'b B) -> &'a C vs fn foo(&'a A, &'b B) -> &'b C vs fn foo(&'a A, &'a B) -> &'a C 
[21:34:09] <kimundi> joebobjoe: ^
[21:34:13] <joebobjoe> kimundi: But it is still mandatory for cases where there are not
[21:34:43] <GreyKnight> I can use D as a match option with no issues; but if I try to use C then it seems to be treating it as a symbol (therefore the _ match is regarded as unreachable)
[21:34:48] <kimundi> joebobjoe: That is for consistency. We used to have weird ruels that defaulted to something, but it was harder to explain than just making it explcicit
[21:35:28] <kimundi> joebobjoe: The common cases, where a function just takes references, doesn't need them: fn foo(&A, &B)
[21:35:30] <GreyKnight> so now I has a sad :<
[21:35:41] *** Joins: mentero (mentero@moz-D61C6F02.proxnet.pl)
[21:35:47] <kimundi> Ina ll other cases, they are treated like type parameters
[21:36:33] *** Quits: carllerche (carllerche@moz-2B516F15.hsd1.or.comcast.net) (Quit: carllerche)
[21:36:47] <joebobjoe> Is the end goal for Rust to provide the facilities to support all the different variations of concurrency? E.g., channels, STM, etc?
[21:38:17] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[21:38:20] <kimundi> GreyKnight: Thats a subtle issue, but working as intended: For convenience, rust allows you to specify a _compiletime constant_ in a pattern to match against. But the same does not work for local variables, which means "C => " is not treaded as "is the value == to C", but as "bind the value of C to the value, and make it aviable for that arm" - which in turn makes _ unreachable, because everything gets matched by C already
[21:39:22] *** Joins: pepper_chico (pepper_chi@moz-13107F6.dsl.telesp.net.br)
[21:39:57] <pepper_chico> a short form of printing an array without ranging it with a loop?
[21:40:07] *** Joins: kris (kris@moz-557F3860.dk.customer.tdc.net)
[21:40:15] <GreyKnight> I figured that was what was happening, I was hoping it was something that could be changed though :-)
[21:40:17] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[21:40:26] <joebobjoe> Is there a guide for std::cell anywhere out there? I don't understand the difference among the different types.
[21:41:05] <kimundi> joebobjoe: The goal is to be a language that is good at thing C/C++ is good at, and not having memory unsafety - that results in a semantic that makes it also possible to write concurrency primitives in a fast, safe way. The std library will at least contain message passing and safe shared memory primitves, and will likely contain some kind of fork-and-join library in the future. And apart from that, you can of course write your own librar
[21:41:05] <kimundi> y. :)
[21:41:26] *** Joins: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP)
[21:41:27] *** Quits: jhasse (jhass_000@moz-8F722ED4.ewe-ip-backbone.de) (Connection reset by peer)
[21:41:28] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[21:41:32] *** Quits: awidegreen (awidegreen@moz-9FADBE94.a357.priv.bahnhof.se) (Ping timeout)
[21:41:35] *** Joins: samx (sami@moz-D9F3E0AE.pp.htv.fi)
[21:41:46] <kimundi> pepper_chico: .to_str()
[21:41:48] <GreyKnight> kimundi: hm actually shouldn't it complain about changing the value of (non-mut) C?
[21:42:00] <GreyKnight> or is it just creating a new scope of C inside the match
[21:42:04] <SiegeLord> What do you expect this to mean: 0.11111e1 given that I say it's base 2
[21:42:08] <joebobjoe> kimundi: Safe shared memory includes mutable shared memory or no?
[21:42:15] <kimundi> GreyKnight: No, the C in the match arm is a new local variable that shaddows the outer C
[21:42:21] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[21:42:26] <SiegeLord> Well, let's try 1e1 base 2... is it 10 or 2 base 10?
[21:42:55] <pepper_chico> kimundi, thanks... can you point me where I find the traits that native types like arrays and tuples have?
[21:43:07] <kimundi> SiegeLord: Last time I recherged it, 'e' was just always base 10, and 'p' always base 2 - anything else is to confusing
[21:43:28] <SiegeLord> So you would prefer mantissa to have an arbitrary base, but the exponent to be 10 or 2?
[21:43:42] * pepper_chico would like vim completion but... I think everyone is waiting for that
[21:44:03] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[21:44:16] *** Quits: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP) (Ping timeout)
[21:44:23] <kimundi> SiegeLord: Of the float literal, yes. If its about parsing a float value in general, then I'm not sure... certainly using 'e' would not work for hex floats :P
[21:44:24] <SiegeLord> Rather, exponent will be in base 10, and the base being 2 or 10
[21:45:17] *** Quits: Amaranth (travis@moz-F81BB56A.cpe.cableone.net) (Ping timeout)
[21:45:18] <SiegeLord> So 15p8 base 8 is 13 * 2^8
[21:45:34] *** Quits: jzcz (nick@moz-BF346884.dyn.centurytel.net) (Ping timeout)
[21:45:41] *** Joins: FliPPeh (lukas@moz-5A449869.dip0.t-ipconnect.de)
[21:46:01] <SiegeLord> Printing floating point in arbitrary bases is sort of a pointless excersize anyway... but the code does that today :P
[21:46:56] <pepper_chico> is there a place I can check for example what traits a native array implements?
[21:47:10] <pepper_chico> I mean, a reference or something
[21:47:14] *** Joins: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp)
[21:47:35] <kimundi> SiegeLord: Yeah, but thats just because I liked the idea of supporting arbitary bases at that time :P - Only supporting base 2, 10 and 16 might be easier
[21:48:01] *** Joins: Sharp (Sharp@moz-EEC85237.hsd1.ca.comcast.net)
[21:48:30] <kimundi> pepper_chico: http://static.rust-lang.org/doc/master/std/vec/index.html
[21:49:22] <pepper_chico> ok
[21:49:23] *** Quits: csherratt (csherratt@moz-8D848271.cpe.teksavvy.com) (Quit: csherratt)
[21:49:25] <SiegeLord> Looks like mpfr does it like I just said... I guess that's what I will emulate
[21:49:29] *** Joins: AvianFlu_ (AvianFlu@moz-723527FF.nycmny.fios.verizon.net)
[21:49:33] *** Joins: jzcz (nick@moz-BF346884.dyn.centurytel.net)
[21:50:13] *** Quits: AvianFlu (AvianFlu@moz-723527FF.nycmny.fios.verizon.net) (Ping timeout)
[21:50:45] *** Joins: Jesin (Jesin@moz-C1EBF9B4.dept.lehigh.edu)
[21:51:46] *** Joins: willingc (willingc@moz-B4760708.san.res.rr.com)
[21:52:08] *** Quits: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp) (Quit: )
[21:54:50] *** Quits: new_one (new_one@7FA65EC.DA451F1E.B3C0173E.IP) (Client exited)
[21:55:56] *** Quits: twi (Adium@moz-512229A7.lns9.lon.bigpond.net.au) (Quit: Leaving.)
[21:56:34] *** Quits: petantik (oz@moz-20EC2160.net) (Input/output error)
[21:56:42] *** Quits: Ferreus (ferreus@moz-933E4A88.pools.arcor-ip.net) (Quit: WeeChat 0.4.3-dev)
[21:57:32] *** Joins: ecl3ctic (Mibbit@moz-E1FAD64C.wzfv1.vic.bigpond.net.au)
[21:57:33] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[21:57:48] *** Joins: oz (oz@moz-20EC2160.net)
[21:57:50] *** Quits: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com) (Ping timeout)
[21:58:02] <dmac> Say I want to call a function that returns a borrowed reference and immediately pass that as an argument to another function is there a way to do that without creating an intermediate variable? https://gist.github.com/dmac/8464066 
[21:58:18] *** Quits: kris (kris@moz-557F3860.dk.customer.tdc.net) (Ping timeout)
[21:58:25] *** Joins: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com)
[21:58:30] *** Quits: dylukes (dylukes@moz-B5418F79.hsd1.pa.comcast.net) (Quit: Textual IRC Client: www.textualapp.com)
[21:58:36] *** Quits: echristo (echristo@E55635C9.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[21:58:40] *** Quits: samx (sami@moz-D9F3E0AE.pp.htv.fi) (Quit: This computer has gone to sleep)
[21:59:16] *** Joins: sebcrozet (sebcrozet@moz-A855F6C0.w82-127.abo.wanadoo.fr)
[21:59:57] <kimundi> dmac: At the moment no, but that is a limitation of the current rules of temporary lifetimes, which might get restricted somewhat in the next weeks to allow stuff like this
[22:00:31] *** Quits: pepper_chico (pepper_chi@moz-13107F6.dsl.telesp.net.br) (Quit: Ex-Chat)
[22:00:47] *** Joins: kris (kris@moz-6D20263F.fullrate.dk)
[22:01:05] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[22:01:08] <dmac> Ok, thanks.
[22:01:28] <FliPPeh> How well does Rusts IO library work? From reading the documentation it appears to be pretty incomplete and not fully designed yet, but that could have been outdated already. Is network programming in Rust feasible at this point?
[22:01:51] *** Joins: josh (josh@moz-C350AC70.hsd1.mn.comcast.net)
[22:01:53] <FliPPeh> Or would I run into nasty surprises? :I
[22:02:05] *** Joins: mpiechotka (mpiechotka@moz-28F0BC7B.dynamic.mnet-online.de)
[22:02:21] *** Joins: echristo (echristo@E55635C9.D6CCE4AE.77834EAA.IP)
[22:03:07] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[22:03:15] <mpiechotka> Hi. I've tried to post on rust-dev via gmane but all I got was the e-mail asking me to subscribe even though I'm subscribed. Does anyone have an idea what's wrong?
[22:03:49] <mpiechotka> Oh. Ok. Sorry - I haven't read it fully
[22:03:55] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Quit: TheHydroImpulse)
[22:03:58] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[22:04:12] *** Joins: Ralith (ralith@A8995AA9.62B6AF6A.922221DB.IP)
[22:06:07] *** Quits: lkuper (lkuper@moz-6881CCA2.dhcp-bl.indiana.edu) (Ping timeout)
[22:06:22] *** Quits: notmatt (notmatt@CC62CF7E.1E7FDFDB.A82DBDDB.IP) (Client exited)
[22:08:11] <Jemaclus> let foo = ~"bar";
[22:08:33] <Jemaclus> how would I iterate over the letters in the string? doesn't seem like I can do something like:  foo[2]
[22:09:24] *** Joins: jdm (jdm@47D9A12A.80DA567B.66C78069.IP)
[22:09:24] *** ChanServ sets mode: +o jdm
[22:09:37] <kimundi> Jemaclus: .chars() gives you a iterator over all codepoints in it
[22:09:40] *** Quits: TylerE (Tyler@moz-33F22668.gvllcmtc01.gnvlnc.ab.dh.suddenlink.net) (Quit: Leaving)
[22:09:47] *** Joins: TylerE (Tyler@moz-33F22668.gvllcmtc01.gnvlnc.ab.dh.suddenlink.net)
[22:10:02] <SiegeLord> Ok, seems like my exp printer works... not to plug it into the std::fmt
[22:10:07] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[22:10:07] *** Joins: new_one (new_one@moz-32449151.rice.edu)
[22:10:09] <Jemaclus> i see.
[22:10:09] <Jemaclus> hmm
[22:10:12] <Jemaclus> thanks.
[22:10:14] <SiegeLord> It's actually is accurate of maybe 10 decimal places
[22:10:23] <SiegeLord> *to maybe
[22:10:32] *** Joins: awidegreen (awidegreen@moz-9FADBE94.a357.priv.bahnhof.se)
[22:11:03] <ecl3ctic> Can anyone enlighten me about the differences between Rc<RefCell<T>> and extra::arc::RWArc<T> ? They both seem to achieve similar things, if I'm not mistaken
[22:12:42] *** Joins: omnus (omnus@moz-2E009EE2.stny.res.rr.com)
[22:13:35] *** Quits: sebcrozet (sebcrozet@moz-A855F6C0.w82-127.abo.wanadoo.fr) (Quit: Gone)
[22:13:58] *** Quits: kngl (Adium@E5907D90.770DEA4D.7C797F8E.IP) (Connection reset by peer)
[22:13:59] *** Joins: kngl1 (Adium@E5907D90.770DEA4D.7C797F8E.IP)
[22:14:49] *** Quits: spider-mario (spidermari@moz-2F72F6FF.dsl.quantic-telecom.net) (Input/output error)
[22:15:30] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[22:16:58] <Matthias247> ecl3ctic: they are quite different. One is not thread safe, the other is
[22:17:25] *** Quits: willingc (willingc@moz-B4760708.san.res.rr.com) (Client exited)
[22:17:44] <aatch> ecl3ctic, RWArc can be sent between tasks and is quite slow compared to Rc due to the use of atomics and similar for reference counting.
[22:19:02] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[22:19:06] <joebobjoe> What is Pod?
[22:19:07] *** Joins: Kjelle (karl@moz-58495553.static.spa.siw.siwnet.net)
[22:19:13] <ecl3ctic> Matthias247, aatch: oh, right. I missed the sendability difference... thanks guys
[22:19:17] *** Quits: ljrmorgan (Mibbit@54CD300B.4315EAB6.F2A80E0C.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[22:19:19] <joebobjoe> I.e., std::cell::Cell can only contain Pod?
[22:19:27] <trinary> acrichto: FYI I fixed my build issues, I think, it seems to be bootstrapped and rustc-ing itself. Turns out I had a /usr/local/bin/clang[++] managed by a homebrew llvm recipe that configure was finding. Unlinking that seems to have fixed it.
[22:19:47] *** Joins: moostik (Icedove@6181009C.10715965.BCDF592F.IP)
[22:20:02] <acrichto> trinary: nice! I'll try to remember that for next time :)
[22:20:25] *** Quits: AvianFlu_ (AvianFlu@moz-723527FF.nycmny.fios.verizon.net) (Input/output error)
[22:20:27] <GreyKnight> I think I'm using vectors wrong here, what should I be doing instead?  http://pastebin.com/S4BVBF1d
[22:20:32] *** Joins: lkuper (lkuper@7405A0B9.654CD82F.51B6877.IP)
[22:20:34] <FliPPeh> What's this Derefer trait I keep seeing? Some trait that all pointer types will implement to get a unified dereferencing method?
[22:20:58] <GreyKnight> I guess I could have add() take a Foo and return a new Foo with its vector extended...
[22:21:18] <aatch> joebobjoe, Pod is "plain old data"
[22:21:40] *** Joins: willingc (willingc@moz-B4760708.san.res.rr.com)
[22:22:41] *** Quits: jdm (jdm@47D9A12A.80DA567B.66C78069.IP) (Ping timeout)
[22:22:44] <LQDH> kimundi: that error I posted before was just a lifetime error because I put &mut self instead of &'a mut self. I think i have this figured out now, thanks for the help
[22:23:12] <joebobjoe> aatch: Which is in Rust?
[22:23:19] <aatch> joebobjoe, basically, it's any data that can be trivially copied
[22:23:27] <aatch> i.e., by memcpy.
[22:23:47] *** Quits: jackneill (jackneill@moz-E9D68037.pool.digikabel.hu) (Quit: WeeChat 0.4.1)
[22:24:01] <aatch> Things that stop it from being Pod is anything with a destructor (including `~`) and `&mut`
[22:24:17] <joebobjoe> aatch: Can Pod contain a ~?
[22:24:21] *** Joins: jdm (jdm@47D9A12A.80DA567B.66C78069.IP)
[22:24:21] *** ChanServ sets mode: +o jdm
[22:24:23] <aatch> No
[22:25:06] *** Quits: lkuper (lkuper@7405A0B9.654CD82F.51B6877.IP) (Quit: lkuper)
[22:25:10] *** Quits: jdm (jdm@47D9A12A.80DA567B.66C78069.IP) (Quit: Lost terminal)
[22:25:38] *** Quits: mpiechotka (mpiechotka@moz-28F0BC7B.dynamic.mnet-online.de) (Ping timeout)
[22:25:48] *** Quits: lucian (lucian@moz-8408FDFA.cable.virginm.net) (Input/output error)
[22:26:09] *** Joins: lucian (lucian@moz-8408FDFA.cable.virginm.net)
[22:26:46] <Jemaclus> kimundi: I think I miscommunicated what I want. I want to be able to access the third letter of the foo string... let foo = ~"bar"; foo[2] == "r";
[22:27:06] *** Quits: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com) (Ping timeout)
[22:27:16] *** Joins: lkuper (lkuper@moz-6881CCA2.dhcp-bl.indiana.edu)
[22:27:43] <mcpherrin> Jemaclus: third letter or third byte?
[22:27:48] <aatch> Jemaclus, so, the third character?
[22:27:51] *** Quits: lucian (lucian@moz-8408FDFA.cable.virginm.net) (Ping timeout)
[22:27:55] <Jemaclus> third character, yeah
[22:28:02] <Jemaclus> or Nth character, as the case may be
[22:28:19] *** Joins: espindola (espindola@8EC99D26.4B7A7726.A2E931B1.IP)
[22:28:41] <joebobjoe> What does this error mean? "error: mismatched types: expected `<V10>` but found an &-pointer pattern"
[22:29:06] *** Joins: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com)
[22:29:12] <mcpherrin> joebobjoe: types like <V10> are inferred types that haven't been resolved yet
[22:29:28] *** Quits: mentero (mentero@moz-D61C6F02.proxnet.pl) (Ping timeout)
[22:29:35] <joebobjoe> mcpherrin: How can it expect an inferred type that has not been resolved yet?
[22:29:58] *** Quits: omnus (omnus@moz-2E009EE2.stny.res.rr.com) (Client exited)
[22:30:01] <GreyKnight> I guess it already knows <V10> can't be a &pointer?
[22:30:10] <aatch> joebobjoe, it's for integer types
[22:30:10] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Connection reset by peer)
[22:30:26] <joebobjoe> aatch: Interger types do not default to int?
[22:30:40] <mcpherrin> rusti: "abc".chars().take(3)
[22:30:46] -rusti- timeout triggered!
[22:30:52] <aatch> joebobjoe, if they can't be resolved, yes.
[22:30:53] <GreyKnight> joebobjoe: what kind of int? :-3
[22:31:19] <aatch> However, not matter what int it picks, it's not going to match an &-pointer
[22:31:22] <joebobjoe> aatch: What do you mean? Does a literal `3` not have necessarily an int type?
[22:31:47] <GreyKnight> joebobjoe: it might be a u32, an i16, a u8, etc
[22:31:49] <aatch> joebobjoe, well, it'll be *an* int type, but it could be i8, u8, u64, i32... etc, etc
[22:32:04] *** Quits: saml (sam@moz-14C16814.cst.lightpath.net) (Quit: Leaving)
[22:32:19] <joebobjoe> aatch: Ah.
[22:32:20] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[22:32:33] <aatch> it falls back to just 'int' (which is machine-dependent) if it can't find something concrete.
[22:32:37] <aatch> rusti: 2+3
[22:32:39] -rusti- 5
[22:32:52] <joebobjoe> aatch GreyKnight: Any way we can get a better name for a `V10`?
[22:32:58] <joebobjoe> Or get it documented somewhere?
[22:33:06] *** Quits: flounder (Mibbit@moz-A06909E4.glbb.ne.jp) (Quit: http://www.mibbit.com ajax IRC Client)
[22:33:19] <aatch> joebobjoe, probably, but it's just because of the way the type system is implemented.
[22:33:31] <GreyKnight> certainly it could be documented, you could even be the one to write that documentation :-)
[22:33:56] <aatch> Anyway, your error means you that you have a pattern like `&foo` and are trying to match against some integer.
[22:34:05] *** bstrie is now known as bstrie_disappeared
[22:34:19] <joebobjoe> aatch: Why cannot you do that?
[22:34:31] <ecl3ctic> joebobjoe: it's already changed in master
[22:34:32] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[22:34:35] <joebobjoe> GreyKnight: Haha. Do not entrust a noob with writing docs.
[22:34:47] <ecl3ctic> joebobjoe: I mentioned it to dpaupp and he fixed it
[22:34:47] <aatch> eg, `let a = 1; match a { &1 => { ... }}`
[22:34:53] <joebobjoe> ecl3ctic: Excellent.
[22:34:59] <ecl3ctic> dbaupp*
[22:34:59] <GreyKnight> joebobjoe: why not?  Writing documents might be a good way to learn :-D
[22:35:02] <Tobba> I wonder how hard it would be to split the macro processing so its not order dependant
[22:35:07] <Tobba> probably really difficult sadly
[22:35:22] <aatch> Tobba, macro expansion is done twice anyway.
[22:35:22] <joebobjoe> Has Rust always used Hindley-Milner for type inference in local scope?
[22:35:24] <Jemaclus> think I found it. thanks.
[22:35:24] <pauls> Tobba: dependent on the order of what?
[22:35:26] <aatch> joebobjoe, yes
[22:35:35] <Tobba> it currently depends on the order of the mod lines
[22:35:38] <Tobba> which is kinda annoying in bigger projects
[22:35:43] <Tobba> or well
[22:35:49] <Tobba> it depends on the inclusion order of each module
[22:36:34] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[22:36:42] <Tobba> I havent had any cross referencing needs crop up yet but it seems like it could easily go sphagetti
[22:36:49] <aatch> Tobba, hmm, weird. It shouldn't matter, since macro expansion is done after parsing.
[22:36:51] <pauls> Tobba: as in, what happens when names shadow each other?
[22:36:58] <Tobba> nope
[22:37:06] <joebobjoe> aatch: I do not think Hindley-Milner is mentioned anywhere in the tutorial.
[22:37:11] <aatch> joebobjoe, so?
[22:37:23] <Tobba> if I have say
[22:37:26] *** Joins: Amaranth (travis@moz-F81BB56A.cpe.cableone.net)
[22:37:27] <Tobba> #[macro_escape] pub mod panic;
[22:37:28] *** Joins: AvianFlu (AvianFlu@moz-723527FF.nycmny.fios.verizon.net)
[22:37:29] <Tobba> in my crate file
[22:37:33] <GreyKnight> joebobjoe: it would probably scare people off :-3
[22:37:36] <Tobba> if I move that to the bottom the panic! macro dissapears
[22:37:36] <joebobjoe> aatch: I think it should be. 
[22:37:55] <joebobjoe> GreyKnight: But most people are going to assume type inference is left-to-right.
[22:38:13] * GreyKnight didn't even know type inference had a direction
[22:38:14] <aatch> joebobjoe, many developers aren't going to know what Hindley-Milner is.
[22:38:17] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[22:38:39] <aatch> joebobjoe, it's enough to say "types are inferred from usage in a function or method"
[22:39:15] <joebobjoe> aatch: Awright.
[22:39:26] <joebobjoe> Local Hinldey-Milner is real nice. It seems like an excellent comprimise.
[22:39:46] <pauls> Tobba: It might not be possible to make that order-independent.
[22:39:57] <pauls> For one thing, you can write macro-defining macros...
[22:40:17] <aatch> steveklabnik, our resident documentation hawk, complains at the amount of technical detail in our tutorial(s) as it is.
[22:40:20] <Tobba> it should be possible to lex it all then go through the macros
[22:40:23] <aatch> joebobjoe, ^^
[22:41:13] <pauls> Tobba: you don't necessarily even know whether a particular item will define a macro.
[22:41:24] <Tobba> not necessary
[22:41:26] <Tobba> I think
[22:41:34] <Tobba> it should be possible to just do an iterative expansion method
[22:41:44] *** Quits: sellout (Adium@2917A62E.8B65BA63.1D2A2C57.IP) (Quit: Leaving.)
[22:42:16] <GreyKnight> so in my paste earlier; what should I be doing for add()?  Pure function that takes a Foo and constructs a modified Foo?  http://pastebin.com/S4BVBF1d
[22:42:18] *** Quits: sw17ch (sw17ch@moz-62998E95.hfc.comcastbusiness.net) (Quit: sw17ch)
[22:42:35] <GreyKnight> or is there a way to make it a mutator method?
[22:42:43] <pauls> You could extract all the items that don't contain macro invocations and move them first... 
[22:43:06] <pauls> ...but that would make using a macro have unacceptable weird semantic consequences.
[22:43:28] <joebobjoe> aatch: I think you have to be a big boy/girl to learn Rust, anyway. 
[22:43:44] <aatch> GreyKnight, currently can't be a mutator method.
[22:43:51] <joebobjoe> The typeclassish stuff did confuse me when I first read the tutorial, because I had never been exposed to it before.
[22:44:25] <aatch> operator overloading is bit... uh... crap. At the moment.
[22:44:37] <joebobjoe> Why are lifetimes specified like generics are? Are they generics?
[22:44:49] <aatch> joebobjoe, essentially yes.
[22:45:00] <pauls> And the circularity problem isn't something that has a defined solution.
[22:45:02] <joebobjoe> aatch: How so?
[22:45:12] <joebobjoe> aatch: It is not like the compiler generates different code...
[22:45:32] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Input/output error)
[22:45:40] <aatch> In the way the type parameters don't control the actual type of the variable, lifetime parameters don't control the lifetime of the data.
[22:45:47] <aatch> They just expose it as an annotation.
[22:46:05] <aatch> Also, lifetimes are part of the type system.
[22:46:13] <aatch> They form a subtyping relationship.
[22:46:30] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[22:46:30] *** ChanServ sets mode: +ao brson brson
[22:46:41] *** Quits: rca (rcatolino@moz-FBA8CEE6.adsl.proxad.net) (Ping timeout)
[22:46:46] *** Quits: echristo (echristo@E55635C9.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[22:46:52] <GreyKnight> aatch: okay, thanks.  Does that "currently" mean it's being thought about, or just a general qualifier?
[22:47:48] *** Quits: dymk (dymk@C94BAFB1.AA444DA9.3FBA778E.IP) (Quit: This computer has gone to sleep)
[22:48:07] <aatch> GreyKnight, it's on the table to be improved.
[22:48:13] *** Joins: hjr3 (hradtke@moz-4CC6BC5F.public.wayport.net)
[22:48:28] <GreyKnight> cool
[22:48:38] <GreyKnight> maybe I should join the mailing list and try to help :-)
[22:48:48] *** Joins: vince (vince@87549D5D.A97DAB6F.A7E3DA15.IP)
[22:49:03] *** Quits: moostik (Icedove@6181009C.10715965.BCDF592F.IP) (Ping timeout)
[22:49:14] <GreyKnight> anyway I better sleep now, goodnight all
[22:49:20] <aatch> It's just difficult to come up with a good way of doing it. It gets very complex, very fast when you account for rust's memory model
[22:49:26] *** Quits: GreyKnight (GK@moz-1DFE40B6.range86-181.btcentralplus.com) (Quit: )
[22:49:30] *** Quits: awidegreen (awidegreen@moz-9FADBE94.a357.priv.bahnhof.se) (Ping timeout)
[22:51:28] <joebobjoe> aatch: I still do not understand why we need explicit lifetimes. If we have multiple lifetimes associated with different parameters, why can we not rely on the type system to infer the best lifetime to bind to the return value?
[22:51:45] *** Quits: willingc (willingc@moz-B4760708.san.res.rr.com) (Client exited)
[22:52:02] <aatch> joebobjoe, because it would require non-local reasoning.
[22:52:08] *** Quits: Amaranth (travis@moz-F81BB56A.cpe.cableone.net) (Ping timeout)
[22:52:10] *** Quits: egghead (egghead@7851DE85.C82F6435.20F09BA6.IP) (Quit: WeeChat 0.3.7)
[22:52:27] <aatch> The idea is that all the relevant call information should be in the declaration.
[22:52:38] *** Joins: moostik (Icedove@6181009C.10715965.BCDF592F.IP)
[22:53:44] *** Quits: hjr3 (hradtke@moz-4CC6BC5F.public.wayport.net) (Ping timeout)
[22:54:23] *** Joins: ptc (Adium@moz-8F01578B.z72-46-65.customer.algx.net)
[22:54:39] <joebobjoe> aatch: But can't the compiler just decide that, "Hey! You borrowed this value from *this* parameter's ownership tree, therefore, I have decided to associate the lifetime with *this* parameter?"
[22:55:16] <aatch> What about declarations without bodies?
[22:55:20] <aatch> Like trait methods?
[22:56:00] *** Joins: Amaranth (travis@moz-F81BB56A.cpe.cableone.net)
[22:56:27] <joebobjoe> aatch: I don't understand.
[22:56:38] <aatch> if I have `trait Foo { fn foo(&self) -> &str; }` then how can I possibly know what lifetimes to assign to what?
[22:57:35] <aatch> That &str might be a &'static str, it might be related to a different lifetime than the one on the `&self`
[22:57:42] <joebobjoe> aatch: Can't it just look at the impl?
[22:57:47] <aatch> joebobjoe, which impl?
[22:58:49] <aatch> We have trait objects, meaning virtual calls
[22:59:01] *** Joins: skade (skade@moz-B73EE4D5.pools.arcor-ip.net)
[22:59:06] *** Quits: gwty (gwtypc@A3F4FE97.CFB6D583.BD94A9D5.IP) (Ping timeout)
[22:59:12] *** Joins: pilf (pilf@moz-E8842E0A.dsl.bell.ca)
[22:59:20] <aatch> meaning sometimes we can't know which function is called until runtime.
[22:59:33] *** Quits: bmats (bmats@moz-87F0A991.hfc.comcastbusiness.net) (Ping timeout)
[22:59:51] *** Joins: hjr3 (hradtke@moz-4CC6BC5F.public.wayport.net)
[23:00:00] <joebobjoe> aatch: Oh, I see.
[23:00:15] *** Quits: new_one (new_one@moz-32449151.rice.edu) (Client exited)
[23:00:18] *** Quits: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com) (Ping timeout)
[23:00:37] <joebobjoe> aatch: So, lifetimes cannot be inferred even for the case where we have only one paramter.
[23:00:52] <aatch> joebobjoe, exactly.
[23:01:49] <aatch> like I said, lifetimes are like types, they can't be controlled directly, In fact, lifetime parameters are more like type bounds than types themselves.
[23:02:31] *** Joins: sinma (sinma@moz-6A11C47C.fbx.proxad.net)
[23:02:51] <joebobjoe> aatch: Lifetimes could be inferred locally for stand-alone functions... but that would not be consistent?
[23:03:25] <sinma> Hi, I try to do Some(x) if x != ~"/" in a match but it says error: cannot bind by-move into a pattern guard. How should I fix that?
[23:03:25] *** Joins: voxpopuli (fanservice@moz-FE161659.wv.cc.cmu.edu)
[23:03:37] <aatch> joebobjoe, pretty much. Having some functions need them and others not would be more confusing than just learning the region system to start with.
[23:04:10] <aatch> sinma, try `Some(ref x) if x.as_slice() ~= "/"`
[23:04:20] <aatch> s/~=/!=/
[23:04:28] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[23:04:37] *** Joins: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com)
[23:05:04] <sinma> Some(ref x) if x != &~"/" works
[23:05:12] <sinma> But &~ is a but ugly.
[23:05:12] <aatch> sinma, that too.
[23:05:26] <aatch> sinma, unfortunately there's not much you can do about it.
[23:05:28] <flaper87> dbaupp: thanks for the patience :)
[23:05:47] <aatch> I suggest my way because it doesn't allocate a string for the comparison (which ~"/" will)
[23:06:09] <joebobjoe> aatch: If Rust did not have objects, could it locally infer lifetimes? Or, are there still other constraints?
[23:06:39] <o11c> speaking of lifetimes ... I just noticed some of my C++ code has some kind of convoluted lifetimes
[23:06:48] <aatch> joebobjoe, I don't know sorry. There are probably more constraints, but you'd have to ask someone else. Probably nmatsakis 
[23:06:58] <o11c> there are two objects taht refer to each other, but neither owns the other.
[23:08:10] <o11c> One is a timer object, owned by the timer queue; the other is the timer's associated "cancel" object, which may not exist, but is owned by the associated object if it does exist.
[23:08:38] *** Quits: kngl1 (Adium@E5907D90.770DEA4D.7C797F8E.IP) (Quit: Leaving.)
[23:08:50] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[23:09:10] *** Joins: earlzlap (earlz@moz-483E1E31.neo.res.rr.com)
[23:10:20] <dbaupp> flaper87: thanks for *your* patience... since I'm basically reviewing one line at a time rather than finding all the problems in one go, sorry :(
[23:11:04] <flaper87> dbaupp: no worries, we sorted it out after all :)
[23:11:19] *** Quits: josh (josh@moz-C350AC70.hsd1.mn.comcast.net) (Quit: josh)
[23:11:36] <dbaupp> joebobjoe: the <VI0> thing is now printed as `<generic integer #0>`, fwiw
[23:11:41] <dbaupp> aatch: ^
[23:11:49] <dbaupp> (on master, that is.)
[23:12:04] <dbaupp> rusti: 1.doesnt_exist()
[23:12:07] *** Joins: carllerche (carllerche@moz-2B516F15.hsd1.or.comcast.net)
[23:12:12] -rusti- pastebinned 7 lines of output: http://ix.io/9UI
[23:12:28] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[23:12:32] <aatch> Ah, I didn't hit it too often before so I probably just haven't hit it since the change.
[23:12:40] <joebobjoe> dbaupp: What is the "#0"?
[23:12:48] <dbaupp> it was only a few days ago, fwiw
[23:12:57] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[23:13:02] <dbaupp> joebobjoe: the 0th unsuffixed literal in the program I think
[23:13:16] *** Joins: kvanb (kvanb@moz-2C33D4E6.lnse3.lon.bigpond.net.au)
[23:13:21] <dbaupp> (I wasn't sure if anyone was using it for debugging, etc., so I didn't want to remove that from the output.)
[23:13:48] <dbaupp> rusti: 0; 1; 2; 3.doesnt_exist()
[23:13:50] -rusti- pastebinned 7 lines of output: http://ix.io/9UJ
[23:14:24] <joebobjoe> dbaupp: The 0th in local scope or in the entire program?
[23:14:37] <dbaupp> don't know
[23:14:42] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[23:14:53] <dbaupp> rusti: fn f() { 0; 1; 2; } 3.doesnt_exist()
[23:14:55] -rusti- pastebinned 7 lines of output: http://ix.io/9UK
[23:15:03] <dbaupp> in scope
[23:16:00] *** Quits: earlzlap (earlz@moz-483E1E31.neo.res.rr.com) (Ping timeout)
[23:16:22] *** Quits: bjustin (bjustin@moz-8FC28563.sierrabravo.net) (Quit: Textual IRC Client: www.textualapp.com)
[23:16:32] *** Joins: Sentor (kvirc@E52BBD42.AF30C8B3.DBB01AA2.IP)
[23:16:38] *** Parts: ray (bernhard@moz-FF531B82.vie.surfer.at) ()
[23:17:18] *** Joins: echristo (echristo@E55635C9.D6CCE4AE.77834EAA.IP)
[23:17:21] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[23:18:10] *** Quits: Jesse (jruderman@moz-9754CB0.hsd1.ca.comcast.net) (Quit: Jesse)
[23:18:44] <joebobjoe> What does the term "manage pointers" mean under the documentation for `Clone`? http://static.rust-lang.org/doc/master/std/cell/struct.RefCell.html
[23:18:59] <dbaupp> bstrie_disappeared: pong
[23:19:11] * dbaupp hopes bstrie is lying
[23:19:56] <dbaupp> A managed pointer is a GC'd pointer
[23:20:05] <dbaupp> (garbage collected)
[23:20:20] <dbaupp> previously written as @, but now it's std::gc::Gc
[23:21:14] <joebobjoe> dbaupp: Okay, but what about nested `RefCell`s? Are they deep cloned?
[23:21:18] *** flaper87 is now known as flaper87|afk
[23:21:25] <dbaupp> Yes
[23:21:36] <dbaupp> I think that doc comment is actually a "generic" one from the definition of clone
[23:21:44] <dbaupp> not directly linked to RefCell specifically
[23:22:18] <dbaupp> in any case, the mention of those two pointers is just confusing
[23:22:39] <joebobjoe> dbaupp: If `@` is no longer part of the language, why mention it in the trait definition?
[23:22:57] <dbaupp> @ isn't, but we still have std::gc::Gc which is a managed pointer
[23:23:11] <dbaupp> and as I said, the mention of those two pointers specifically is just confusing
[23:23:39] <dbaupp> the statement could be clearer by talking about more general values.
[23:23:47] *** Quits: Tobba (Tobba@moz-462B7F7F.ias.bredband.telia.com) (Ping timeout)
[23:23:51] <joebobjoe> dbaupp: Yea, but shouldn't `Clone` not be concerned with library code?
[23:24:13] <dbaupp> hm? Clone is library code?
[23:24:20] <joebobjoe> `Clone` is not dependent on `std::gc::Gc`
[23:24:26] *** Joins: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP)
[23:24:42] *** Joins: kngl (Adium@E5907D90.770DEA4D.7C797F8E.IP)
[23:24:47] <joebobjoe> dbaupp: Shouldn't it be restricted to describing language semantics, not library semantics?
[23:24:57] <dbaupp> Clone is not part of the language
[23:25:05] <joebobjoe> Oh
[23:25:05] <dbaupp> it's entirely defined in libstd
[23:26:24] *** Quits: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP) (Ping timeout)
[23:26:28] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[23:26:30] *** Quits: sinma (sinma@moz-6A11C47C.fbx.proxad.net) (Quit: Konversation terminated!)
[23:26:42] *** Joins: lucian (lucian@moz-8408FDFA.cable.virginm.net)
[23:27:26] <joebobjoe> When you borrow a mutable value to an immutable slot, you freeze it globally. Is there any way to borrow a mutable value but only freeze is locally? Just curious.
[23:28:25] *** Quits: lucian (lucian@moz-8408FDFA.cable.virginm.net) (Ping timeout)
[23:28:25] *** Quits: alonlevy (alon@moz-EB7C9CF3.telavivmakers.org) (Ping timeout)
[23:30:38] *** Quits: cschneid (cschneid@moz-CA025D57.ip.mcleodusa.net) (Ping timeout)
[23:31:27] <dbaupp> Restrict the borrow to a scope `let mut y = 1; { let x = &y; ... } /* allowed to mutate y */`
[23:31:30] <igork> is there a way to do pointer conversion from &mut to ~?
[23:32:15] <igork> probably stupid question, nevermind :)
[23:32:56] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[23:33:23] <Jemaclus> woo, wrote my first real rust program that isn't a hello world thing :)
[23:33:26] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[23:33:27] <Jemaclus> and it works
[23:33:28] <Jemaclus> huzzah
[23:33:54] *** Joins: Fatalnix (bhodgins@moz-20A07419.ptldme.east.myfairpoint.net)
[23:33:57] <Jemaclus> probably implemented pretty crappily, but it works. i'll take it.
[23:34:18] <Fatalnix> So I guess this isn't probably really a rust language thing.. but I constructed a program, fn main () { loop { } }
[23:34:29] <Fatalnix> best program ever right? well...
[23:35:12] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[23:35:50] <Fatalnix> I noticed, unlike any dynamic language I've ever used my cpu usage goes to 100% when I do this. Is there a way I can rearrange my approach so that I can instead yield to other processes if there is nothing to do? It just seems this is really inefficient for my code to do such. Maybe I am overreacting :)
[23:36:07] *** Joins: ktt3ja (ktt3ja@moz-515C1363.hsd1.va.comcast.net)
[23:36:15] <strcat> what language doesn't use 100% of a CPU in a busy-wait?
[23:36:20] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[23:36:28] <strcat> Fatalnix: you don't want to busy-wait for anything, that's the solution
[23:36:56] <Matthias247> strcat: each that is single threaded when you have a multicore cpu ;)
[23:37:26] <Jemaclus> behold, my crappy levenshtein implementation: http://pastebin.com/SzWyrPjG
[23:37:32] <Jemaclus> heh
[23:37:49] <strcat> Matthias247: 100% means 1 core used, what is this windows? ;p
[23:37:52] *** Quits: ricepuddin (graham@moz-7D68765A.cable.virginm.net) (Ping timeout)
[23:38:22] <Matthias247> strcat: yeah, windows tells me 1core = 25% used ;)
[23:39:17] *** Joins: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net)
[23:39:23] <mcpherrin> yeah I want my busy loops to use 3200% cpu :-)
[23:40:13] *** Joins: veddan (viktor@moz-C79BC80B.csbnet.se)
[23:41:10] *** Joins: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com)
[23:41:48] *** Quits: vadimg (vadimg@BCFFDE00.DF0A212.39C00A7A.IP) (Ping timeout)
[23:42:14] *** Joins: new_one (new_one@F8CB5EE5.6D46D672.B3C0173E.IP)
[23:43:12] *** Joins: psquid (psquid@moz-396AA76.threembb.co.uk)
[23:43:12] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Connection reset by peer)
[23:43:31] *** Quits: doomlord_ (servitor@moz-CA917A47.range86-184.btcentralplus.com) (Quit: Leaving)
[23:44:29] <joebobjoe> How does this compile? `fn main() {let x = 3; let mut y = &x;}`
[23:44:29] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[23:44:37] *** Quits: ecl3ctic (Mibbit@moz-E1FAD64C.wzfv1.vic.bigpond.net.au) (Quit: http://www.mibbit.com ajax IRC Client)
[23:44:54] <sfackler> why wouldn't it?
[23:45:04] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[23:45:05] <sfackler> note that the variable y is mutable, not the data pointed to by it
[23:45:16] *** Joins: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net)
[23:45:17] <sfackler> let mut y = &x; is not the same as let y = &mut x;
[23:45:30] <joebobjoe> sfackler: I thought mutability was inherited?
[23:45:34] *** Joins: lucian (lucian@moz-8408FDFA.cable.virginm.net)
[23:45:43] *** Quits: Scriptor (anonymous@moz-E06F46F0.corp.bitshelter.com) (Quit: Scriptor)
[23:45:48] *** Quits: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net) (Quit: Linkinus - http://linkinus.com)
[23:45:55] <sfackler> it's inhereted from an ownership root
[23:46:09] <sfackler> but stuff like Rc, @, and & introduce a new ownership root
[23:46:23] <strcat> well & is non-owning
[23:46:34] <strcat> joebobjoe: mutability is inherited from the owner
[23:46:39] <strcat> & doesn't express ownership
[23:46:43] <strcat> you own the pointer, not what it points at
[23:46:43] *** Quits: skade (skade@moz-B73EE4D5.pools.arcor-ip.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz)
[23:46:55] <strcat> so if the variable is mutable you can mutate the pointer, but not what it's pointing at
[23:47:22] <joebobjoe> strcat: k
[23:48:48] *** Quits: moostik (Icedove@6181009C.10715965.BCDF592F.IP) (Ping timeout)
[23:49:42] *** Joins: danikar (Mibbit@moz-A975888.mobile.uci.edu)
[23:49:48] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Client exited)
[23:50:09] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[23:50:57] <danikar> If I have an owned pointer "let mut x = ~5;", why can I do "let y: &int = &(*x);", but "let y: &mut int = &mut(*x);" tells me I am borrowing twice?
[23:51:10] *** Quits: toshok (toshok@moz-43741342.cat) (Ping timeout)
[23:51:15] <brson> has anybody read the build system ml thread? was there any consensus? (don't think i want to dig into that)
[23:51:51] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Ping timeout)
[23:51:59] *** Quits: kris (kris@moz-6D20263F.fullrate.dk) (Ping timeout)
[23:52:06] <hoverbear> Fatalnix: Don't busy way. :)
[23:52:22] <mcpherrin> brson: haha, I almost replied with something about the build system mailing list thread we're having at work.  Wrong IRC channel!
[23:52:36] *** Joins: moostik (Icedove@6181009C.10715965.BCDF592F.IP)
[23:52:45] <hoverbear> mcpherrin: It's ok, all build systems are the same anyways.
[23:53:04] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[23:53:16] <mcpherrin> so are the flamewars about them!
[23:54:10] <joebobjoe> danikar: I don't get the same error as you
[23:54:20] *** Quits: trevor_ (trevor@moz-F6C93216.hsd1.mn.comcast.net) (Ping timeout)
[23:54:47] *** Quits: Sentor (kvirc@E52BBD42.AF30C8B3.DBB01AA2.IP) (Ping timeout)
[23:54:51] <Fatalnix> back! sorry, family dinner was called.
[23:55:20] *** Quits: eddyb (eddy@EDE07015.D51DAF03.FB866788.IP) (Ping timeout)
[23:55:22] <LinearInterpol> Fatalnix!
[23:55:22] <LinearInterpol> o/
[23:55:24] <igork> Jemaclus: i think min3 can be written as std::num::min(x, std::num::min(y, z)); :)
[23:57:10] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[23:57:34] *** Joins: toshok (toshok@moz-43741342.cat)
[23:57:36] <Jemaclus> yeah, I was just thinking "why don't I just do this twice?"
[23:57:42] <Jemaclus> i'm a moron. :)
[23:57:42] <Jemaclus> thanks
[23:58:27] <Fatalnix> hey LinearInterpol 
[23:58:48] <Fatalnix> LinearInterpol: Trying to think of a better approach to my thingie.
[23:59:05] <Fatalnix> LinearInterpol: you're not in bangor are you ?> :P
[23:59:06] <LinearInterpol> Fatalnix: 'cuz you're switching paradigms. :)
[23:59:08] <LinearInterpol> No
[23:59:13] <LinearInterpol> I won't be in bangor for months.
[23:59:30] <Fatalnix> LinearInterpol: well, they dont want me to busy wait my loopers
[23:59:44] <LinearInterpol> I can't imagine why..

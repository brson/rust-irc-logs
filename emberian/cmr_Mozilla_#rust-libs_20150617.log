[00:49:16] *** Joins: aatch (james@moz-c6etfk.fosn.r6an.e000.2406.IP)
[01:09:40] *** Quits: Eridius (kevin@moz-6opvqs.us) (Quit: BBIAB, upgrading my Linode to KVM)
[01:20:06] *** Joins: Eridius (kevin@moz-6opvqs.us)
[02:47:18] *** Quits: zz_kimundi (kimundi@moz-0a7524.dip0.t-ipconnect.de) (Ping timeout: 121 seconds)
[02:50:14] *** Joins: zz_kimundi (kimundi@moz-357luu.dip0.t-ipconnect.de)
[02:50:15] *** zz_kimundi is now known as kimundi
[03:00:57] *** Quits: frewsxcv (sid86219@moz-dneii9.brockwell.irccloud.com) (Quit: )
[03:02:49] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Quit: Leaving)
[03:02:56] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[03:22:20] *** Quits: Eridius (kevin@moz-6opvqs.us) (Quit: leaving)
[03:22:23] *** Joins: Eridius (kevin@moz-6opvqs.us)
[04:22:39] *** aatch is now known as help
[04:22:44] *** help is now known as aatch
[04:50:23] *** Quits: bluss (bluss@moz-ec5o68.cust.bredbandsbolaget.se) (Ping timeout: 121 seconds)
[04:59:15] *** Quits: acrichto (acrichto@moz-u3dg2t.sfo1.mozilla.com) (Quit: leaving)
[04:59:52] *** Joins: acrichto (acrichto@moz-u3dg2t.sfo1.mozilla.com)
[04:59:52] *** ChanServ sets mode: +qo acrichto acrichto
[05:12:39] *** Quits: Rym (uid91135@moz-n2i7qm.charlton.irccloud.com) (Quit: Connection closed for inactivity)
[05:45:33] *** Joins: canhtak (jeremy@moz-kcs.u0t.149.5.IP)
[06:03:24] *** Quits: aatch (james@moz-c6etfk.fosn.r6an.e000.2406.IP) (Connection closed)
[07:04:18] *** Quits: canhtak (jeremy@moz-kcs.u0t.149.5.IP) (Client exited)
[07:13:52] *** Joins: aatch (james@moz-is4j4r.cable.telstraclear.net)
[08:25:17] *** Joins: simukis (nagisa@moz-8t068g.static.zebra.lt)
[08:33:26] *** Joins: erikj (erikj@moz-1bq7nj.com)
[09:11:57] *** Joins: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua)
[09:22:33] *** Quits: tekacs (tekacs@moz-q64vt8.com) (Quit: Disappearing... *poof*)
[09:28:31] *** Quits: ChrisMorgan (ChrisMorgan@moz-g6osuq.tpgi.com.au) (Ping timeout: 121 seconds)
[09:28:42] *** Joins: tekacs (tekacs@moz-q64vt8.com)
[09:51:21] <SimonSapin> Is this safe? https://github.com/SimonSapin/rust-movecell/blob/4539879d94/lib.rs#L19-L23
[10:17:04] *** Joins: bluss (bluss@moz-ec5o68.cust.bredbandsbolaget.se)
[10:30:53] <Dabo> SimonSapin, afaik that's exactly what Cell would do - it's the accessing the data that can't be done particularly safely without Copy
[10:31:26] <Dabo> not sure though
[10:31:33] <Dabo> oh
[10:31:52] <SimonSapin> Dabo: my understanding is that Copy is only needed for Cell::get. Without Copy, you couldn’t move out of the cell without leaving something behind. So MoveCell takes a parameter of what to leave behind
[10:32:54] <Dabo> that sounds sane enough
[12:25:24] *** Quits: simukis (nagisa@moz-8t068g.static.zebra.lt) (Quit: Leaving.)
[12:26:10] *** Joins: simukis (nagisa@moz-8t068g.static.zebra.lt)
[12:43:20] *** Joins: ChrisMorgan (ChrisMorgan@moz-g6osuq.tpgi.com.au)
[14:01:01] *** Quits: aatch (james@moz-is4j4r.cable.telstraclear.net) (Ping timeout: 121 seconds)
[15:48:13] *** Joins: globin (globin@moz-isrgf8.de)
[16:09:31] <SimonSapin> Here is a write up: https://www.reddit.com/r/rust/comments/3a6bv7/movecell_take_two/
[16:09:44] <SimonSapin> A cell for non-Copy types and without the memory overhead of RefCell
[16:15:44] <bluss> nice. You could use it with Vec, too
[16:17:04] <SimonSapin> bluss: Vec<MoveCell<T>> ?
[16:18:37] <bluss> MoveCell<Vec<T>> and substitute with Vec::new()
[16:19:48] <eternaleye> SimonSapin: I was thinking about that recently; for types that can be atomically swapped the same pattern could make a really nice spinlock
[16:19:55] <eternaleye> SimonSapin: Option<Box<_>> could be especially nice there
[16:19:57] <eternaleye> SimonSapin: In that stuff could race to swap the Some with a None, and if they got a None, spin on swapping. If they got a Some, work with it, and then swap it back (using CAS, presuming a None is in there)
[16:20:00] <eternaleye> SimonSapin: (Sure, it's the dead-simple spinlock that's awful for cache coherency protocols, but still)
[16:20:55] <SimonSapin> eternaleye: Are you thinking of multi-threaded things? MoveCell as it is now is !Sync
[16:21:57] <SimonSapin> I use it with MoveCell<Option<Rc<_>>> and MoveCell<Option<Weak<_>>>
[16:23:06] <SimonSapin> which hopufully both have the same size_of() as usize
[16:26:16] <eternaleye> SimonSapin: I think it'd be best supported by a separate type (akin to Rc vs Arc) due to overhead; was more commenting about the pattern
[16:26:36] <SimonSapin> eternaleye: what it are you refering to?
[16:26:49] <bluss> SimonSapin: isn't this very similar to the old Cell<T> that used Option<T> internally? (and panicked if you tried to get its value and it was None)
[16:26:54] <eternaleye> SimonSapin: the use case of multi-threaded MoveCell (spinlock)
[16:27:23] <SimonSapin> eternaleye: right, that’s probably a different type
[16:28:22] <SimonSapin> bluss: It doesn’t use Option internally, but some methods are only available with types (such as Option) that implement Default
[16:28:22] <eternaleye> bluss: SimonSapin: However, the API I came up with for the spinlock thing was more closure-based, and that might help avoid the panic-on-None bit
[16:28:39] <SimonSapin> (And some more methods are available for MoveCell<Option<_>> specifically)
[16:28:44] <eternaleye> By ensuring the value is always returned to the MoveCell
[16:28:50] <SimonSapin> I see
[16:29:06] <SimonSapin> eternaleye: yes, similar ideas can probably apply in other contexts
[16:31:09] <eternaleye> Actually, for MoveCell<Option<_>>, I wonder how MoveCell::map<F: FnOnce>(f: F) would compare to the current API
[16:31:35] <eternaleye> In terms of where it'd be used
[16:32:19] <eternaleye> ...actually, that API might be sound even for non-Option, though it'd need unsafe in the implementation
[16:34:21] <SimonSapin> MoveCell::map as I wrote it is based on Option::map. How would it work for other types?
[16:34:48] <SimonSapin> regarless of implementation, what would the semantics be?
[16:43:36] <SimonSapin> acrichto: Can an #[unstable] public field in a #[stable] struct (UnsafeCell::value) be made private backward-compatibly?
[16:43:47] <acrichto> SimonSapin: yes
[16:43:53] <SimonSapin> cool
[16:53:08] *** Joins: brson (brson@moz-cfhap5.mtv2.mozilla.com)
[16:53:09] *** ChanServ sets mode: +qo brson brson
[17:08:48] <eternaleye> SimonSapin: It'd (unsafely) pull the value out of the MoveCell, and reinsert it
[17:09:08] <eternaleye> SimonSapin: It being !Sync means that is safe to do, IIUC
[17:09:30] <SimonSapin> eternaleye: that’s unsafe in the precense of reference cycles
[17:10:16] <eternaleye> SimonSapin: Hm? Only if the value in the MoveCell is non-movable due to being referenced, I would think?
[17:10:56] <SimonSapin> Rc can have cycles
[17:12:37] <eternaleye> SimonSapin: I'm not sure that actually applies here
[17:12:37] <SimonSapin> In https://github.com/SimonSapin/kuchiki/blob/a32baa8ea2/src/tree.rs#L54-L61 you can do e.g. node.next_sibling().unwrap().previous_sibling().unwrap()
[17:13:18] <eternaleye> SimonSapin: Since you'd be moving the value out of the MoveCell just as you normally would; just not _replacing_ it until the closure returns
[17:13:33] <eternaleye> SimonSapin: But because it's non-Sync, there can be nothing that would observe that
[17:16:25] <SimonSapin> I’m not sure we’re talking about the same thing, I’d have to look at some code example
[17:23:23] <eternaleye> impl<T> MoveCell<T> { fn map<F: FnOnce( T ) -> T> ( &self, f: F ) { pseudocode::replace( f( pseudocode::replace( self.value, mem::uninitialized() ) ) ); }
[17:24:14] <eternaleye> er,  the outer pseudocode::replace needs a self.value first param
[17:26:07] <eternaleye> SimonSapin: ^^
[17:34:40] <eternaleye> SimonSapin: It's still not great if T is _large_, but it does avoid the case where T::default allocates out-of-line
[17:36:17] <SimonSapin> I’m not convinced that’s safe. Trying to find an example
[17:46:51] *** Quits: aturon (sid379@moz-hhfc8n.0j4i.jtu0.0101.2620.IP) (Connection closed)
[17:50:12] <SimonSapin> eternaleye: You don’t even need a cycle: http://is.gd/LZyqFe
[17:50:40] <SimonSapin> I used ptr::read and ptr::write instead of mem::replace+mem::uninitialized, but I believe it does what you intended
[18:03:14] *** Joins: aturon_ (sid379@moz-hhfc8n.0j4i.jtu0.0101.2620.IP)
[18:03:17] *** Quits: aturon_ (sid379@moz-hhfc8n.0j4i.jtu0.0101.2620.IP) (Quit: )
[18:03:34] *** Joins: aturon_ (sid379@moz-hhfc8n.0j4i.jtu0.0101.2620.IP)
[18:03:38] *** aturon_ is now known as aturon
[18:03:49] *** ChanServ sets mode: +o aturon
[18:07:37] <eternaleye> SimonSapin: Your map and my map do very different things
[18:07:58] <eternaleye> SimonSapin: My map doesn't return anything to map's caller *at all*
[18:08:16] <eternaleye> SimonSapin: It's purely a transformation of the value *within* the MoveCell
[18:09:57] <SimonSapin> eternaleye: Sorry, I misread. Like this? http://is.gd/5m1l7B
[18:10:06] <eternaleye> SimonSapin: Because of that, it's T -> T - it can't change the type of the MoveCell, but it's operating on values. 'map' may not be the best name with that, and perhaps &mut T -> () is better
[18:12:09] <SimonSapin> eternaleye: the problem is that the cell is still accessible from within the map closure
[18:13:04] <eternaleye> Hm, I'm not sure ptr::read and pter::write really do mean the same thing...
[18:13:29] <eternaleye> Oh, no, I see
[18:13:42] <eternaleye> Dropping an unitialized box is what does it
[18:13:49] <eternaleye> Wait, no
[18:14:08] <eternaleye> Yeah, the important thing about replace/uninitialized is that the data *in the refcell* can't alias the real data
[18:14:19] <eternaleye> er, in the unsafecell
[18:14:28] <eternaleye> Lemme see...
[18:15:10] <eternaleye> mm
[18:16:03] <eternaleye> Yeah, I see what you mean now
[18:17:33] <eternaleye> SimonSapin: You're right
[18:20:28] <SimonSapin> If instead of ptr::read you replace with zeroes or garbage, then another access will segfault when trying to deref that
[18:20:43] <eternaleye> Yeah, I tested that
[18:34:01] *** Joins: frewsxcv (sid86219@moz-dneii9.brockwell.irccloud.com)
[19:23:28] *** Quits: globin (globin@moz-isrgf8.de) (Connection closed)
[21:09:43] *** Quits: simukis (nagisa@moz-8t068g.static.zebra.lt) (Ping timeout: 121 seconds)
[23:00:31] *** kimundi is now known as zz_kimundi
[23:00:35] *** zz_kimundi is now known as kimundi
[23:20:38] *** Quits: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua) (Ping timeout: 121 seconds)
[23:21:37] *** Joins: aatch (james@moz-i1k1ks.tlms.2o1v.e006.2406.IP)
[23:30:36] *** Quits: barosl (barosl@moz-tmp.qma.67.220.IP) (Connection closed)
[23:52:02] *** kimundi is now known as zz_kimundi
[23:53:56] *** Joins: barosl (barosl@moz-tmp.qma.67.220.IP)
[23:56:33] *** zz_kimundi is now known as kimundi

[00:29:18] *** Quits: annodomini (lambda@moz-qgii5v.ma.comcast.net) (Client exited)
[02:34:03] *** Quits: kimundi (kimundi@moz-7l900c.dip0.t-ipconnect.de) (Ping timeout: 121 seconds)
[02:36:14] *** Joins: kimundi (kimundi@moz-9b6hhf.dip0.t-ipconnect.de)
[02:44:23] *** Joins: annodomini (lambda@moz-qgii5v.ma.comcast.net)
[02:48:17] *** Joins: annodomini_ (lambda@moz-qgii5v.ma.comcast.net)
[02:48:54] *** Quits: annodomini (lambda@moz-qgii5v.ma.comcast.net) (Connection closed)
[02:48:55] *** annodomini_ is now known as annodomini
[03:53:56] *** Quits: stl (stl@moz-511.ict.15.176.IP) (Connection closed)
[03:55:19] *** Joins: stl (stl@moz-511.ict.15.176.IP)
[04:20:19] *** SimonSapin is now known as SimonSapin_
[04:23:51] *** Joins: SimonSapin (simon@moz-lb0n4e.rev.poneytelecom.eu)
[04:24:41] *** Quits: SimonSapin (simon@moz-lb0n4e.rev.poneytelecom.eu) (Quit: WeeChat 1.0.1)
[04:28:55] *** Joins: SimonSapin (simon@moz-lb0n4e.rev.poneytelecom.eu)
[04:30:29] *** Quits: SimonSapin (simon@moz-lb0n4e.rev.poneytelecom.eu) (Quit: WeeChat 1.0.1)
[04:30:50] *** Joins: SimonSapin (simon@moz-lb0n4e.rev.poneytelecom.eu)
[04:34:23] *** Quits: SimonSapin_ (simon@moz-ju2imn.exyr.org) (Quit: Bye)
[04:59:59] *** Quits: annodomini (lambda@moz-qgii5v.ma.comcast.net) (Client exited)
[05:34:52] *** Quits: aatch (james@moz-i1k1ks.tlms.2o1v.e006.2406.IP) (Connection closed)
[06:22:07] *** Joins: aatch (james@moz-is4j4r.cable.telstraclear.net)
[07:31:44] *** Joins: bluss (bluss@moz-ec5o68.cust.bredbandsbolaget.se)
[07:48:12] *** Joins: nagisa (nagisa@moz-8t068g.static.zebra.lt)
[10:54:50] *** Joins: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua)
[11:41:31] *** Quits: aatch (james@moz-is4j4r.cable.telstraclear.net) (Ping timeout: 121 seconds)
[12:29:24] *** Joins: annodomini (lambda@moz-qgii5v.ma.comcast.net)
[12:33:42] *** Quits: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua) (Ping timeout: 121 seconds)
[12:42:26] *** Quits: annodomini (lambda@moz-qgii5v.ma.comcast.net) (Client exited)
[12:50:18] *** Joins: annodomini (lambda@moz-qgii5v.ma.comcast.net)
[13:06:16] *** Quits: annodomini (lambda@moz-qgii5v.ma.comcast.net) (Client exited)
[14:19:26] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[14:57:42] *** Joins: annodomini (lambda@moz-hceqmj.hfc.comcastbusiness.net)
[14:58:39] *** Quits: ryanhiebert (ryanhiebert@moz-nsd5kl.ks.cox.net) (Connection closed)
[15:59:37] *** Quits: annodomini (lambda@moz-hceqmj.hfc.comcastbusiness.net) (Client exited)
[16:02:30] *** Joins: annodomini (lambda@moz-hceqmj.hfc.comcastbusiness.net)
[16:16:46] *** Joins: ryanhiebert (ryanhiebert@moz-nsd5kl.ks.cox.net)
[16:33:44] *** Quits: annodomini (lambda@moz-hceqmj.hfc.comcastbusiness.net) (Client exited)
[16:34:06] *** Joins: annodomini (lambda@moz-hceqmj.hfc.comcastbusiness.net)
[16:41:38] *** Quits: annodomini (lambda@moz-hceqmj.hfc.comcastbusiness.net) (Client exited)
[16:58:15] *** Quits: ryanhiebert (ryanhiebert@moz-nsd5kl.ks.cox.net) (Connection closed)
[17:39:54] *** Quits: nagisa (nagisa@moz-8t068g.static.zebra.lt) (Connection closed)
[17:59:38] *** Joins: ryanhiebert (ryanhiebert@moz-te1.9a2.160.12.IP)
[18:06:01] *** Joins: nagisa (nagisa@moz-8t068g.static.zebra.lt)
[18:09:01] *** Quits: ryanhiebert (ryanhiebert@moz-te1.9a2.160.12.IP) (Quit: Leaving...)
[18:12:54] *** Joins: annodomini (lambda@moz-hceqmj.hfc.comcastbusiness.net)
[19:08:00] <bluss> aturon: r? https://github.com/rust-lang/rust/pull/26327
[20:44:27] *** Joins: sigma (sigma@moz-l8bauc.range217-44.btcentralplus.com)
[21:05:54] *** Joins: arielb1 (Ariel@moz-1sjtp8.red.bezeqint.net)
[21:06:04] <arielb1> that's the second time I want an O(n^2) dedup on Vec
[21:06:09] <arielb1> why don't we have it
[21:06:22] <Elaine> .sort() .dedup() ?
[21:06:27] <arielb1> requires Ord
[21:07:51] <bluss> and you don't want Hash + Eq either?
[21:07:58] <arielb1> how do you do it with Hash?
[21:08:04] <arielb1> would be nice too
[21:08:12] <bluss> keeping an hashset
[21:09:02] <eternaleye> arielb1: Hasher::finish gives a u64, which you can sort by
[21:09:24] <arielb1> eternaleye: nice. now I will have hard collisions at the worst moment
[21:09:46] <bluss> you can keep a hashset and use retain actually for an O(n) scan
[21:09:52] <bluss> wait, no
[21:10:10] <bluss> hm I want to insert references to the accepted elements into the set
[21:10:21] <eternaleye> arielb1: Hm? if you sort the vec by hash, then a collision means you just do slightly-worse than optimal on dedup() time
[21:10:30] <arielb1> eternaleye: no
[21:10:31] <eternaleye> arielb1: Collisions wouldn't lose data...
[21:11:00] <arielb1> e.g. if sort is stable and everything hashes to the same
[21:11:05] <eternaleye> Mm
[21:11:22] <eternaleye> Still not worse than the O(n^2) dedup
[21:11:30] <huon> a schwartzian transform should work fine
[21:11:30] <eternaleye> Or rather, not hugely worse
[21:11:48] <arielb1> eternaleye, huon: I am *fine* *with* *O(n^2)* *dedup*
[21:11:59] <huon> so.. just write it yourself?
[21:12:05] <eternaleye> huon: See, while I know the origin of that (as a native Perler), I *still* immediately thought "Spaceballs" :P
[21:12:15] <huon> in any case, eternaleye and I are just exploring the problem space
[21:12:19] <huon> please don't get upset with that
[21:13:18] <eternaleye> Hm, I wonder...
[21:13:48] <eternaleye> I think an efficient-ish form of it could be done using an iterator adaptor based on a bloom filter 
[21:14:26] <eternaleye> You use Hash to build a bloom filter of unique items seen so far, and if something matches the filter you try to find it in an actual list of unique items seen so far
[21:14:36] <eternaleye> If it's truly unique, then output it and add it to the list
[21:14:44] <eternaleye> Else, next and repeat
[21:15:30] <huon> interesting
[21:15:34] <bluss> there's .unique() using a simple hashset in itertools
[21:15:35] <eternaleye> Might require Clone though, or only be by-&
[21:15:38] <bluss> a bloom filter would be smart
[21:16:08] <eternaleye> Bloom filters are probably one of my favorite data structures
[21:16:25] <eternaleye> Because they're simple, elegant, and completely non-intuitive until you've been told about them
[21:18:02] <eternaleye> Actually, a bloom filter might be a neat optimization to HashSet in general
[21:18:37] <eternaleye> Especially for either add-only, or if one of the removal-supporting bloom filter variants is used
[21:19:02] <arielb1> eternaleye: only if you have lots of false queries
[21:19:16] <eternaleye> arielb1: True enough
[21:20:14] <bluss> I think dedup with a bloom filter and fallback to O(nÂ²) method sounds cool
[21:21:50] <eternaleye> Actually, I wonder how well .collect<HashSet<_>>().drain() would work...
[21:26:16] <reem> you probably want .into_iter() there not .drain()
[21:27:00] <eternaleye> Mm
[21:28:25] <eternaleye> arielb1: If you don't need stable ordering, that seems to work: https://play.rust-lang.org/?gist=bd3fa599c7e6e5aa8b50&version=stable
[21:28:47] <arielb1> I ended up creating an HashSet further up
[21:30:40] *** Quits: sigma (sigma@moz-l8bauc.range217-44.btcentralplus.com) (Connection closed)
[21:31:30] <bluss> itertools has a .unique() that uses an hashset, without collecting, just streaming past its containment check
[21:32:25] <eternaleye> Mm
[21:32:26] <bluss> eternaleye: rust should have a nonallocating bloom filter, that would be cool
[21:35:04] <eternaleye> bluss: What do you think the interface should be? Bloom<T:Hash> { fn contains(&self, &T) -> bool; fn add(&mut self, &T); } or Bloom { fn contains(&self, &Hash) -> bool; fn add(&mut self, &Hash); } ? 
[21:36:04] <eternaleye> Hm, actually, might want to use "absent" rather then "contains"
[21:36:13] <bluss> not sure. Bloom<T> covers the second case actually
[21:36:15] <eternaleye> Since the filter can say "definitely absent" or "maybe contains"
[21:36:39] <eternaleye> bluss: No, because some might want to use it on, say, AnyMap-type stuff
[21:36:50] <eternaleye> bluss: One bloom filter, many types
[21:36:54] <Elaine> T = Hash?
[21:36:56] <bluss> the second case is Bloom<Hash> if T allows T: ?Sized
[21:37:00] <eternaleye> Mm
[21:37:03] <eternaleye> Fair enough
[21:37:03] <Elaine> having a Bloom<T> seems like it'd just be monomorphism waste anyway
[21:37:26] <bluss> I love monomorphisation
[21:37:32] <eternaleye> Elaine: Type safety if desired
[21:37:57] <eternaleye> Elaine: If someone wants to enforce type safety, the former _can_, the latter cannot
[21:38:02] <Elaine> Good point
[21:38:14] <eternaleye> Elaine: And with ?Sized the first one _is_ a superset of functionality
[21:38:25] <bluss> since the former is a superset of the latter, it seems to be the right choice
[21:38:27] <eternaleye> since T = Hash monomorphizes exactly as the second
[21:39:10] <eternaleye> bluss: Should it actually be <T: Hash, H: Hasher> ?
[21:39:22] <eternaleye> bluss: In case someone wants to use blake2b or something?
[21:40:06] <Elaine> I don't think there's consensus on how to deal with Hashers yet, as default type parameters or otherwise.
[21:40:10] <bluss> not sure how the hashing API even works
[21:40:20] <eternaleye> https://doc.rust-lang.org/std/hash/trait.Hash.html https://doc.rust-lang.org/std/hash/trait.Hasher.html
[21:40:27] <Elaine> Feh, Hash isn't even object safe.
[21:40:29] <bluss> you can add it as a default type param later
[21:40:41] <eternaleye> and it's stable, so there better be consensus!
[21:40:43] <bluss> sad
[21:40:51] <Elaine> eternaleye: nothing using it is, though.
[21:40:55] <Elaine> like HashMap doesn't expose it
[21:41:54] <eternaleye> Man, that really would benefit from associated types
[21:42:07] <eternaleye> Specifically, Hasher::Output
[21:42:19] <eternaleye> Ugh
[21:52:12] *** Joins: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua)
[22:30:33] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[22:32:01] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[22:57:33] *** Quits: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua) (Ping timeout: 121 seconds)
[23:16:06] *** Joins: aatch (james@moz-i1k1ks.tlms.2o1v.e006.2406.IP)
[23:26:07] *** Quits: rustbot (havvy@moz-epv20b.wa.comcast.net) (Ping timeout: 121 seconds)
[23:58:07] *** Quits: nagisa (nagisa@moz-8t068g.static.zebra.lt) (Ping timeout: 121 seconds)

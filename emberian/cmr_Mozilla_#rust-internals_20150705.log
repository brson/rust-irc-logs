[00:04:33] <huon> aatch: ( https://donsbot.wordpress.com/2010/03/01/evolving-faster-haskell-programs-now-with-llvm/ )
[00:04:36] *** Joins: bombless (_@moz-j3l.99o.23.14.IP)
[00:09:13] *** Quits: ytain (ytain@moz-upqesl.dsl.teksavvy.com) (Quit: Textual IRC Client: www.textualapp.com)
[00:13:02] <WindowsBunny> I hate jemalloc sometimes https://github.com/rust-lang/rust/issues/26647
[00:13:03] <WindowsBunny> :D
[00:13:12] <WindowsBunny> And other times I merely dislike it
[00:26:46] *** Quits: johnsoft (johnsoft@moz-69mrig.res.rr.com) (Ping timeout: 121 seconds)
[00:26:51] *** Joins: johnsoft (johnsoft@moz-69mrig.res.rr.com)
[00:37:23] *** Joins: ipetkov (ipetkov@moz-2v9vq9.oc.cox.net)
[00:37:59] *** Quits: rkruppe (chatzilla@moz-5i0kmu.diu2.0rth.0908.2a02.IP) (Quit: ChatZilla 0.9.91.1 [Firefox 39.0/20150630154324])
[00:40:06] *** Joins: summerlight__ (summerlight@moz-lb3.6do.193.175.IP)
[00:41:48] *** Quits: elif (chatzilla@moz-ev8m1p.res.rr.com) (Quit: ChatZilla 0.9.90.1-rdmsoft [XULRunner 29.0/20140421221237])
[00:43:25] *** Quits: ipetkov (ipetkov@moz-2v9vq9.oc.cox.net) (Ping timeout: 121 seconds)
[00:54:47] *** Joins: ipetkov (ipetkov@moz-2v9vq9.oc.cox.net)
[00:55:37] *** Quits: ipetkov (ipetkov@moz-2v9vq9.oc.cox.net) (Client exited)
[00:57:02] *** Joins: ipetkov (ipetkov@moz-2v9vq9.oc.cox.net)
[01:07:41] *** Joins: RC9 (RCIX@moz-tri.dfa.8.198.IP)
[01:20:07] <eddyb> I fell asleep, sorry :o3
[01:20:47] <eddyb> huon: have you seen https://github.com/rust-lang/rust/pull/26694#issuecomment-118499616?
[01:21:16] <huon> eddyb: why not add tests?
[01:22:12] <eddyb> because I have no idea what it enables
[01:22:23] <eddyb> operators seems to be one thing
[01:22:57] *** Joins: bjz (bjz@moz-an7dlk.tpgi.com.au)
[01:25:21] <bluss> huon: interesting link. Inputting the simplest possible loop and then "just wait four hours" is a bit mind boggling
[01:25:30] *** Quits: X67r (user@moz-manmml.mullvad.net) (Quit: leaving)
[01:26:32] *** Quits: iu (iu@moz-6263qv.cc.cmu.edu) (Connection closed)
[01:32:36] *** skeuomor1 is now known as skeuomorf
[01:36:17] *** Quits: bombless (_@moz-j3l.99o.23.14.IP) (Quit: Leaving)
[01:36:47] *** Joins: bombless (_@moz-j3l.99o.23.14.IP)
[01:37:43] *** Quits: cods (fred@moz-g6qd4k.net) (Ping timeout: 121 seconds)
[01:37:59] <huon> bluss: the magic of combinatorial explosions ;P
[01:40:17] *** Quits: bluss (bluss@moz-ec5o68.cust.bredbandsbolaget.se) (Ping timeout: 121 seconds)
[01:42:14] *** Joins: Kingsquee (kingsley@moz-8hi.thq.180.108.IP)
[01:53:07] *** Quits: Kingsquee (kingsley@moz-8hi.thq.180.108.IP) (Ping timeout: 121 seconds)
[01:54:42] *** Joins: Kingsquee (kingsley@moz-33q6f3.bchsia.telus.net)
[01:56:15] *** Quits: bjz (bjz@moz-an7dlk.tpgi.com.au) (Quit: My Mac has gone to sleep. ZZZzzz…)
[02:00:27] *** Joins: bjz (bjz@moz-an7dlk.tpgi.com.au)
[02:01:08] *** Quits: bjz (bjz@moz-an7dlk.tpgi.com.au) (Quit: My Mac has gone to sleep. ZZZzzz…)
[02:04:00] <aatch> You need a fairly large population size to get any meaningful results.
[02:05:13] <aatch> So while it's "only" 20 generations, the population sizes are likely quite large, and compiling + benchmarking the loop is going to be fairly slow in that regard.
[02:06:54] <aatch> Even if it only takes 250ms for the entire process, 4 hours is only 57600 cases.
[02:09:44] *** Quits: ipetkov (ipetkov@moz-2v9vq9.oc.cox.net) (Client exited)
[02:14:16] *** Quits: summerlight__ (summerlight@moz-lb3.6do.193.175.IP) (Ping timeout: 121 seconds)
[02:24:15] *** Quits: bombless (_@moz-j3l.99o.23.14.IP) (Ping timeout: 121 seconds)
[02:42:45] *** Quits: Rym (uid91135@moz-n2i7qm.charlton.irccloud.com) (Quit: Connection closed for inactivity)
[02:46:20] *** Quits: p1start (p1start@moz-nftjhe.org) (Ping timeout: 121 seconds)
[02:47:12] *** Quits: skeuomorf (skeuomorf@moz-j60.sa8.32.197.IP) (Ping timeout: 121 seconds)
[02:51:45] *** Quits: kimundi (kimundi@moz-lav8m7.nhp5.i6et.57bc.2002.IP) (Ping timeout: 121 seconds)
[02:57:32] *** Joins: kimundi (kimundi@moz-6j1fee.ufnp.bi9d.4fe2.2002.IP)
[02:57:50] *** Joins: TimeTime (TimeTime@moz-s3u.r8n.199.128.IP)
[02:58:25] <TimeTime> DO YOU KNOW WHAT YOUR DOMAIN NAME IS WORTH??? -> VALUE YOUR DOMAIN @ >>> WWW.VALBOT.COM <<< OR GOOGLE >>> VALBOT.COM <<<
[03:00:08] <TimeTime> DO YOU KNOW WHAT YOUR DOMAIN NAME IS WORTH??? -> VALUE YOUR DOMAIN @ >>> WWW.VALBOT.COM <<< OR GOOGLE >>> VALBOT.COM <<<
[03:00:13] *** Quits: TimeTime (TimeTime@moz-s3u.r8n.199.128.IP) (Quit: )
[03:14:33] *** Quits: Skyler (Skyler@moz-dgl2bi.fios.verizon.net) (Client exited)
[03:14:54] *** Quits: johnsoft (johnsoft@moz-69mrig.res.rr.com) (Connection closed)
[03:16:39] *** Joins: semarie (semarie@moz-7cbdfl.bpv6.bg1u.41d0.2001.IP)
[03:22:59] <eddyb> nmatsakis, jroesch: we have (at least) 3 enums in the compiler that are Impl(DefId) | Trait(DefId) (ty::ItemOrTraitImplContainer, check::method::CandidateSource, def::MethodProvenance)
[03:27:45] <eddyb> hah, and I can remove def::MethodProvenance because of the container
[03:32:38] *** Joins: johnsoft (johnsoft@moz-69mrig.res.rr.com)
[03:41:58] *** Joins: Feyn (aram@moz-5vj.68e.115.42.IP)
[04:02:08] *** Joins: mib_42uqty (Mibbit@moz-hu6.nja.252.72.IP)
[04:05:48] *** Joins: summerlight__ (summerlight@moz-lb3.6do.193.175.IP)
[04:13:13] *** Joins: Quxxy (chatzilla@moz-0nv.jkp.167.59.IP)
[04:13:53] *** Joins: waffles (Wafflespean@moz-aeh.673.193.113.IP)
[04:14:34] <jroesch> eddyb: awesome, been gone for fourth of the July all day cc me when you cut a PR
[04:15:04] <eddyb> I was going to do something else but then I noticed the old stuff in Def
[04:18:24] *** Joins: p1start (p1start@moz-nftjhe.org)
[04:33:26] <Peach> <jroesch> all day cc me when you cut a PR  <  Can someone explain the 2 abbreviations used here? :P
[04:34:48] <Elaine> carbon copy, Pull Request. https://en.wikipedia.org/wiki/Carbon_copy#Email
[04:35:07] <Peach> WOW
[04:36:46] <eddyb> "cc X" became synonymous with "notify X"
[04:37:08] <eddyb> though github does send mails so you could still use the original meaning
[04:37:11] *** Quits: waffles (Wafflespean@moz-aeh.673.193.113.IP) (Quit: C'yall later :))
[04:37:15] <Peach> Thanks Elaine
[04:37:21] <Peach> Oh here's a tech question - How much of Rust's syntax tree and type checking is independent of LLVM? I see a lot of the compiler is implemented in Rust, but most of what I see are just standard Rust libraries
[04:37:27] <Elaine> 100% of it.
[04:38:00] <Elaine> you want to be looking at libsyntax and librustc_* in https://github.com/rust-lang/rust/tree/master/src
[04:38:11] <Peach> Where is the "meat" if the compiler that does the static analysis  Elaine ?
[04:38:27] <eddyb> librustc, librustc_typeck and librustc_borrowck
[04:38:30] <Peach> (not sure if rust does static analysis exactly, but I know it has smart compiler features)
[04:38:48] <eddyb> Peach: they are analysis passes, yes
[04:39:02] <eddyb> not really called "static analysis" just "analysis
[04:39:23] <Peach> The compiler is HUGE wow
[04:39:36] <Peach> So many subfolders
[04:40:10] <eddyb> 300kLoC
[04:40:12] <Elaine> only 152k loc
[04:40:14] *** Joins: waffles (wafflespean@moz-aeh.673.193.113.IP)
[04:40:17] <Elaine> for librustc*
[04:40:17] <eddyb> Elaine: oh, right
[04:40:35] <eddyb> I forgot I checked it with src/lib* last time
[04:40:48] <Elaine> 345k loc ;)
[04:41:22] <eddyb> I was going to say I'm bad at remembering precise numbers but 345 is kinda magical
[04:42:25] <Peach> 345 IS magical XD
[04:42:39] <Peach> Oh, does Rust have a defined ABI?
[04:42:43] <Elaine> no.
[04:42:48] <eddyb> Peach: only the C FFI
[04:42:55] <Peach> I checked the github and I just see people saying "should we"? etc.
[04:43:05] <eddyb> we shouldn't :P
[04:43:14] <Peach> Is it impossible to use the C abi for non ffi
[04:43:18] <Elaine> No
[04:43:27] <eddyb> well, defining the ABI is fine, stabilizing it is problematic
[04:43:28] <Peach> also why no standard ABI eddyb ?
[04:43:39] <eddyb> Peach: what standard?
[04:43:45] <Peach> problematic because the language is still changing?
[04:44:01] <eddyb> even if the language didn't change, the implementation could be improved
[04:44:16] <Peach> Oh, and yeah I mean a defined ABI - possibly one that is C compatible,
[04:44:26] <Amaranth> C++ sort of has a defined ABI everyone uses but iirc optimization passes can change it still, I think we'd be in the same boat?
[04:44:43] <Elaine> Amaranth: who is "everyone"? :)
[04:44:44] <Amaranth> But if you want a C compatible ABI that exists and you can use it
[04:44:46] <eddyb> Amaranth: yeah, except we don't specify it
[04:44:55] <eddyb> Amaranth: and we do optimizations here and there
[04:44:56] <Amaranth> You just can't use Rust features with it because they don't exist in C
[04:45:06] <Amaranth> Elaine: gcc, clang, msvc
[04:45:08] <Peach> it would be really nice to be able to compile with all those smart compiler checks and be compatible with most libraries
[04:45:19] <eddyb> Peach: that's what FFI is for
[04:45:26] <Elaine> Amaranth: that's just not true.
[04:45:29] <eddyb> Amaranth: doener made a neat change recently to pass fat pointers as two arguments
[04:45:47] <Elaine> gcc has its ABI that clang can be compatible with, and MSVC has its ABI that clang can be compatible with, but they aren't the same.
[04:45:51] <Elaine> even on windows.
[04:45:52] <eddyb> so if a C function takes char*, size_t, you can call it with &[u8]
[04:45:56] <eddyb> (but really, don't do it :P)
[04:45:56] <Amaranth> Elaine: I'm talking about https://mentorembedded.github.io/cxx-abi/abi.html btw
[04:46:07] <Amaranth> I thought they'd all more or less drifted toward that
[04:46:22] <WindowsBunny> eddyb: Please don't rely on the calling convention for fat pointers
[04:46:27] <Elaine> Not really. http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4028.pdf
[04:46:36] <eddyb> WindowsBunny: tell that to everyone reading what I said, not me
[04:46:44] <WindowsBunny> eddyb: We need a lint that warns if fat pointers are used in any extern functions that are not "Rust"
[04:46:51] <eddyb> WindowsBunny: already done AFAIK
[04:46:59] <eddyb> playbot: extern { fn foo(&[u8]); }
[04:47:00] -playbot- <anon>:9:30: 9:31 error: expected `:`, found `)`
[04:47:00] -playbot- <anon>:9         extern { fn foo(&[u8]); }
[04:47:00] -playbot- output truncated; full output at: http://bit.ly/1Cih1Mk
[04:47:08] <eddyb> playbot: extern { fn foo(_: &[u8]); }
[04:47:09] -playbot- ()
[04:47:12] <eddyb> welp
[04:47:18] <eddyb> playbot: extern { fn foo(_: &[u8]); } foo(&[])
[04:47:19] -playbot- <anon>:9:38: 9:46 error: call to unsafe function requires unsafe function or block [E0133]
[04:47:19] -playbot- <anon>:9         extern { fn foo(_: &[u8]); } foo(&[])
[04:47:19] -playbot- output truncated; full output at: http://bit.ly/1TdckYm
[04:47:22] <WindowsBunny> Amaranth: For C++, msvc and mingw have _entirely_ different ABIs
[04:47:23] <eddyb> playbot: extern { fn foo(_: &[u8]); } unsafe { foo(&[]) }
[04:47:24] -playbot- Stored value type does not match pointer operand type!
[04:47:24] -playbot-   store { i8*, i64 }* %arg, [0 x i8]** %__arg, align 8
[04:47:24] -playbot- output truncated; full output at: http://bit.ly/1Cih2jj
[04:47:28] <WindowsBunny> Amaranth: They only have compatible C ABIs
[04:47:36] <aatch> Bahahaha!
[04:47:37] * eddyb shrugs
[04:47:38] <WindowsBunny> Amaranth: For C++ it is a complete and utter crapshoot
[04:47:40] <Amaranth> I know they aren't identical, I'm saying they've all adopted similar approaches
[04:47:52] <eddyb> aatch: look at our FFI safety checks!
[04:47:57] <eddyb> glorious LLVM asserts
[04:47:57] <Amaranth> That was the impression I got anyway but maybe that was only for exception handling?
[04:47:58] <WindowsBunny> The C++ ABI for msvc also changes with each new version of VS
[04:48:04] <Amaranth> Sure, which was my point
[04:48:41] <Peach> Wouldn't it be possible to make a language with a bunch of C++ features (Rust), but with a stable ABI (C ABI)?
[04:48:47] <Amaranth> C++ has existed for 20 or so years and even though they've settled some things they all have different ABIs that also change between compiler versions
[04:48:53] <eddyb> Peach: there's no point
[04:48:53] <Elaine> Peach: Yes, it's possible.
[04:49:06] <eddyb> Peach: interfacing Rust with C++ is not an ABI problem
[04:49:09] <WindowsBunny> Amaranth: And at one point the C++ committee was trying to reinforce that different C++ implementations that are not perfectly compatible should actually try to make the ABIs significantly different such that people don't accidentally try to combine them and then get mysterious errors
[04:49:15] <Peach> eddyb Cause C++ ABI is a MAJOR pain because of its cross platform abi
[04:49:22] <Peach> *non cross platform
[04:49:34] <Peach> or er... consistent ABI
[04:49:36] <eddyb> Peach: yeah but that's not the problem here
[04:50:46] <WindowsBunny> (12:45:10 AM) Peach: it would be really nice to be able to compile with all those smart compiler checks and be compatible with most libraries
[04:50:53] <eddyb> integrating C++'s duck-turing-type-system with Rust's ML/Haskell heritage is hell
[04:50:59] <WindowsBunny> Peach: If you merely want a library that is ABI compatible with other C libraries, just use extern "C"
[04:51:01] <WindowsBunny> bam
[04:51:44] <Peach> but but WindowsBunny, then you get issues with versions of the Rust compiler being incompatible with different versions
[04:51:52] <Amaranth> Peach: Nope
[04:51:56] <Peach> really?
[04:51:58] <Amaranth> The C ABI is the C ABI
[04:52:00] <eddyb> Peach: extern "C" doesn't change
[04:52:03] <eddyb> that's the point
[04:52:06] <Amaranth> But you lose all the Rust features at the interface point
[04:52:16] <Peach> Oh no, I mean Rust ABI with Rust only libs,
[04:52:23] <Peach> won't the ABI change over time?
[04:52:29] <WindowsBunny> Peach: the ABI will change
[04:52:38] <Amaranth> So your Rust library exposes an unsafe C API and your Rust program consumes an unsafe C API and you have to build the abstractions up again on the program side
[04:52:40] <WindowsBunny> all rust code that is linked together must use the same version of Rust
[04:52:42] <eddyb> yes, you cannot link together libraries built with different versions of the compiler
[04:52:52] <WindowsBunny> Peach: The same issue exists with msvc
[04:52:54] <aatch> Peach, yep, and that's an issue we'll have to live with. C++ seems to have managed though.
[04:53:02] <WindowsBunny> All C/C++ code needs to be built with the same version of msvc
[04:53:05] <eddyb> WindowsBunny: does it suck less with Rust?
[04:53:16] <kmc> there should be   extern "stable Rust" fn...
[04:53:25] <eddyb> I would hope Cargo makes most usecases painless
[04:53:25] <kmc> which would support a subset of Rust types, but more than C
[04:53:30] <Peach> But but wouldn't you want to get RID of that issue C++ has since Rust is a new language
[04:53:30] <Amaranth> Although to be fair if gcc changed its ABI as often as msvc does distros would riot
[04:53:40] <eddyb> kmc: extern "Rust/1.0" fn could work but then you need to support past versions of the ABI
[04:53:55] <eddyb> and that makes anyone who has ever worked on trans sad
[04:54:04] <WindowsBunny> Amaranth: msvc can get away with it due to most programs bundling all their DLLs and shit
[04:54:22] <eddyb> Peach: it's the other way around
[04:54:33] *** Quits: p1start (p1start@moz-nftjhe.org) (Ping timeout: 121 seconds)
[04:54:33] <eddyb> Peach: ABI compatibility is a security issue
[04:54:39] <Amaranth> Yeah, the only external dependencies Windows apps have are win32 C DLLs or the C++ stdlib
[04:54:58] <eddyb> being able to patch libraries to fix security vulnerabilities *is* a worse security issue waiting to happen
[04:55:15] <WindowsBunny> Amaranth: And the CRT has unique names for each version, so there's no ABI concerns there
[04:55:34] <eddyb> dynamic linking is quite problematic and I'm happy Rust and NixOS both throw it out (except for code reuse and dynamic loading)
[04:55:38] <Amaranth> Oh they do that too? I thought only glibc did versioned symbols
[04:55:46] <WindowsBunny> msvcrt120.dll
[04:55:49] <WindowsBunny> msvcrt140d.dll
[04:56:05] <WindowsBunny> msvcrt100.dll
[04:56:16] <eddyb> recompile-the-world and live happily ever after
[04:56:19] <Elaine> Amaranth: the symbols aren't versioned.
[04:56:25] <Amaranth> Oh, that. Everything in the *nix world does that. :P /usr/lib/libc.6.so
[04:56:46] <eddyb> Amaranth: except 6 has been around for a lot longer
[04:56:47] <WindowsBunny> Amaranth: Also, you can link to a DLL that uses a C ABI, and as long as you don't pass CRT objects across the interface it's totally fine
[04:57:16] <WindowsBunny> Amaranth: Really, the only issue is passing CRT objects between CRTs
[04:58:02] <WindowsBunny> The symbols are not versioned, if you link two versions of the CRT in the same binary, then the linker will mix and match symbols from both CRTs and you'll have CRT mixing hell and shit will randomly crash
[04:58:23] <WindowsBunny> As me and eddyb had a fun time investigating with cargo being built with msvc
[04:58:59] <eddyb> you can use multiple versions of the same crate in Rust
[04:59:11] <eddyb> if they conflict somehow, you'll get type errors <3
[04:59:27] <Amaranth> As some point it might make sense to do what C++ appears to be trying to do and have an extern "stdabi" but I think we'd see a Rust 2.0 before that
[05:17:45] *** Joins: geofft (geofft@moz-vhak2k.ip-198-27-64.net)
[05:22:49] <Elaine> I don't get it. https://gist.github.com/cmr/c8ad24356dc1053c22cf
[05:23:13] <Elaine> Actually I think I get it now.
[05:24:35] <Elaine> I get it now.
[05:24:45] <Elaine> I'm amazed that ever worked, it should have been clobbering the hell out of the Device.
[05:25:25] <Elaine> as *mut _ ruins the day yet again
[05:30:57] *** Quits: summerlight__ (summerlight@moz-lb3.6do.193.175.IP) (Ping timeout: 121 seconds)
[05:38:44] *** Joins: p1start (p1start@moz-nftjhe.org)
[05:44:44] <Peach> So hey, does Rust at least have no undefined behavior?
[05:45:22] <eddyb> Peach: only outside of unsafe blocks
[05:45:43] <eddyb> inside them you're allowed to dereference raw pointers which can trivially cause UB
[05:45:51] <eddyb> and then there's various unsafe functions you can call
[05:45:58] <Peach> For example, C and C++, the order of evaluation of function arguments is underfined
[05:46:17] <eddyb> Rust has defined evaluation order throughout
[05:46:36] <Peach> Good, cause in C and C++,   print(x,y,z(),a());  can evaluate in any order
[05:47:03] <eddyb> in Rust, they're evaluated in the order: x, y, z, z(), a, a(), print, print(x, y, z(), a())
[05:47:04] <Peach> so if z() and a() had side effects like printing something else
[05:47:09] <eddyb> wait, no, I'm dumb
[05:47:15] <eddyb> print is evaluated first not after the arguments
[05:47:27] <Peach> Oh?
[05:47:28] <eddyb> print, x, y, z, z(), a, a(), print(x, y, z(), a())
[05:47:36] <eddyb> Peach: pretty much in AST order
[05:48:18] <eddyb> left to right, inner before outer (as outer needs the result from evaluting inner), basic rules like that
[05:48:57] <eddyb> huon: just passed, 6 -> 14 cases for unconditional_recursion, all 8 were previously undetected (that's why I wanted to take my time :P)
[05:50:23] <eddyb> just passed tests I mean. I didn't pass out
[05:51:42] <Mutabah> How is lang_start called? Is it connected somehow to crt0's calling of main, or via some other codepath?
[05:51:53] <eddyb> Mutabah: we generate a C main
[05:52:03] <Mutabah> eddyb: rustc does?
[05:52:06] <eddyb> that calls lang_start or #[start] (the latter takes precedence)
[05:52:07] <eddyb> Mutabah: yeah
[05:54:46] <Mutabah> interesting
[05:55:32] <eddyb> jroesch: here's the PR, I assigned huon to it for the lint stuff, and I removed just def::MethodProvenance, if you care about it https://github.com/rust-lang/rust/pull/26783
[05:56:08] <Mutabah> eddyb: That is a little bit more complexity than I expected from rustc
[05:58:02] <Mutabah> (just reached userland handling in my rust-based OS
[05:58:32] <Mutabah> I assume that main just passes argc/argv straight through, with no attempt at parsing?
[05:58:50] <Elaine> nope.
[05:58:58] <eddyb> lang_start can do whatever it wants with argc/argv
[05:59:06] <eddyb> libstd's stores it in global state
[05:59:08] <Mutabah> Yeah, that's what I figured
[05:59:18] <eddyb> for std::env
[05:59:59] <Mutabah> This could be interesting if I ever try and use the real libstd, as argv for me is a slice of slices, and there's no space for nul-termination in the source
[06:04:08] <eddyb> Mutabah: you could totally have it just &[&str]
[06:04:42] <eddyb> Mutabah: that happens to be passed right now as a pointer and an usize. I guess you'll need to split it yourself into *const &str and i32 or whatever argc is
[06:05:07] <eddyb> (so ignore the thing about slices being passed as two arguments because it won't help you)
[06:05:32] <eddyb> Mutabah: and src/libstd/sys/yourOS would contain logic to decode it
[06:13:04] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[06:13:37] *** Joins: avikpal (avikpal@moz-qc1.uhm.194.117.IP)
[06:16:54] *** Quits: bdero (bran@moz-g8fbau.lhkq.vq5r.018d.2601.IP) (Ping timeout: 121 seconds)
[06:20:00] <Mutabah> eddyb: yep, that's what I'm doing
[06:20:28] <Mutabah> Except atm just passing argc=0, and pushing the &[&OsStr] using a separate function
[06:23:16] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[06:31:18] *** Joins: Skyler (Skyler@moz-7ds39s.sd.cox.net)
[06:32:23] *** Quits: waffles (wafflespean@moz-aeh.673.193.113.IP) (Ping timeout: 121 seconds)
[06:35:00] *** Joins: waffles (wafflespean@moz-aeh.673.193.113.IP)
[06:40:00] *** Quits: mib_42uqty (Mibbit@moz-hu6.nja.252.72.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[06:41:07] *** Joins: Pierre_M (Pierre_M@moz-2vs15r.slkc.qwest.net)
[06:41:33] *** Joins: Pierre_M_ (Pierre_M@moz-2vs15r.slkc.qwest.net)
[06:41:37] *** Quits: Pierre_M (Pierre_M@moz-2vs15r.slkc.qwest.net) (Quit: Leaving)
[06:41:39] *** Quits: Pierre_M_ (Pierre_M@moz-2vs15r.slkc.qwest.net) (Connection closed)
[06:41:42] *** Joins: Pierre_M (Pierre_M@moz-2vs15r.slkc.qwest.net)
[06:42:17] *** Joins: Pierre_M_ (Pierre_M@moz-2vs15r.slkc.qwest.net)
[06:42:55] *** Quits: Pierre_M_ (Pierre_M@moz-2vs15r.slkc.qwest.net) (Quit: Leaving)
[06:55:38] <eddyb> Ericson2314: you just pinged some person named eddyb
[06:55:43] <eddyb> Ericson2314: eddy I mean
[06:56:00] <eddyb> (too used to writing my own nick)
[06:57:27] *** Quits: ELD (textual@moz-tbcsac.co.comcast.net) (Quit: My Mac has gone to sleep. ZZZzzz…)
[06:58:46] *** Joins: eljay (eljay@moz-fmte10.skybroadband.com)
[06:59:33] <eddyb> playbot: enum Foo { A, B } impl Drop for Foo { fn drop(&mut self) {} }
[06:59:34] -playbot- ()
[07:02:01] <Ericson2314> I edited it, but I guess the damage is done...
[07:02:43] <eddyb> start whistling and walk the other way :P
[07:03:06] <eddyb> s/walk/walking
[07:05:38] <Ericson2314> hehe
[07:06:01] <Ericson2314> mm I don't get the part about my changes leaving a role for Drop
[07:06:04] <Ericson2314> I want to deprecate it too
[07:07:53] <eddyb> Ericson2314: if there's nothing to move out of self, you'd have to use Drop in your proposal
[07:08:49] <Ericson2314> I guess if you just want some random effect
[07:08:58] <Ericson2314> you can do that, and then partial move some arbitrary value
[07:09:11] <Ericson2314> though granted the partial move is extra kludge
[07:10:09] *** Joins: RCIX (RCIX@moz-vnmep7.ph.cox.net)
[07:10:17] <eddyb> Ericson2314: or use mem::forge
[07:10:20] <eddyb> *mem::forget
[07:10:41] <Ericson2314> only of the field is not itself drop
[07:10:44] <eddyb> but I really don't want Rust users to casually use mem::forget unless they're doing legit ownership transfer in unsafe code
[07:11:07] <Ericson2314> and can partially move if the field isn't drop as long as it isn't copy
[07:11:11] <eddyb> Ericson2314: yeah, but that's a type property that may be non-obvious and then you use lints to enforce the correct behavior
[07:11:20] <Ericson2314> true
[07:11:36] <eddyb> you can also trigger the "peeling" of the destructor by accident
[07:11:42] <Ericson2314> true to
[07:11:53] <Ericson2314> I get that using lints may *seem* better than a special magic type, but really isn't
[07:12:22] <Ericson2314> some degree of magic either way, and it is generally better to have the type system be in charge
[07:12:35] *** Quits: RC9 (RCIX@moz-tri.dfa.8.198.IP) (Ping timeout: 121 seconds)
[07:12:42] <Ericson2314> and your arguments have made me warm to Interior<T>
[07:13:14] <Ericson2314> certainly both are far better than the status quo
[07:14:48] <eddyb> if there was an easy way, it would've been used a long time ago. the only exception is mem::forget, which wasn't safe until recently
[07:15:22] *** Joins: ptalbot (ptalbot@moz-c4k8ug.dyn.as47377.net)
[07:16:49] <Ericson2314> On a completely different note, does Rust have a notion of a lifetime of a location (not part of the type of the thing that the location holds)?
[07:17:06] <Ericson2314> I was doing an Agda model of a language with lifetimes and I found myself introducing that
[07:17:13] <eddyb> Ericson2314: I believe cyclone's regions were like that, too
[07:17:30] <eddyb> Ericson2314: and lifetimes are not "part of a type" outside of parametrism
[07:17:55] <eddyb> in Rust, lifetimes are tied to a "root" on the stack
[07:18:09] <eddyb> which can get passed down through lifetime-generic types and functions
[07:18:34] <Ericson2314> mm the lifetime bound on an object is kind of "of the type"
[07:19:14] <Ericson2314> Though that is different that cyclone and it's `regionof` even a concrete type.
[07:19:53] <eddyb> Ericson2314: lifetimes on trait objects still come from parameters, all the way up to a root
[07:20:19] <eddyb> those roots are rvalue and lvalue scopes. and, well, 'static, which outlives everything else
[07:20:36] <eddyb> Cyclone also has some kind of a heap lifetime, but I have no idea how it works
[07:20:56] <Ericson2314> yeah i never understood that
[07:21:39] <eddyb> I also don't know how much of borrowck it has
[07:22:22] <Ericson2314> I don't know either. In fairness I am not quite sure what the borrow check means theory-wise.
[07:23:40] <eddyb> Ericson2314: static rw-locks for variables, based on region typing
[07:24:08] <eddyb> Ericson2314: dox https://github.com/rust-lang/rust/tree/master/src/librustc_borrowck/borrowck
[07:24:43] <Ericson2314> Well like I mean a formal semantics
[07:25:07] *** Quits: SiegeLord (sl@moz-9jtaei.ca.comcast.net) (Quit: It's a joke, it's all a joke.)
[07:25:19] <eddyb> not sure if patina has them. that document looks semi-formal
[07:25:29] <Ericson2314> I'd guess it goes back to affinity.
[07:25:57] <Ericson2314> ahh so borrows seem to really be about affinity
[07:26:27] <Ericson2314> I'd consider moves as the identifier is really no longer in the environment, but that violates people's notions of lexical scope
[07:26:45] <Ericson2314> So i realize why rustc doesn't present it that way
[07:26:51] <eddyb> mutable borrows are affine (but can be sub-loaned to avoid having to move them away)
[07:27:07] <eddyb> Ericson2314: that works fine for variables
[07:27:10] <Peach> Is it possible for rust to return an arbitrary struct? Like suppose I was parsing a JSon file and wanted to return a fast native data structure .......
[07:27:14] <eddyb> Ericson2314: but Rust allows moving out of fields
[07:27:38] <eddyb> Ericson2314: and you can't do it at resolution time because you don't have the types
[07:27:56] <eddyb> Peach: you can return a generic type bounded by a trait which has a method to construct that type
[07:28:02] <eddyb> Peach: look at serde for JSON
[07:28:14] *** Joins: yjv (yjv@moz-ll38tk.pa.comcast.net)
[07:28:50] <eddyb> and its #[derive(Serialize, Deserialize)] annotations (via a compiler plugin) https://github.com/erickt/serde
[07:30:35] <Ericson2314> ah yeah i meant mutable borrows the entire time
[07:31:41] <eddyb> those also allow sub-borrows
[07:31:49] <eddyb> (of fields)
[07:32:04] <Ericson2314> and yeah good point here and before on field borrows
[07:33:25] *** Joins: cods (fred@moz-g6qd4k.net)
[07:33:28] <Peach> Oh eddyb  wow
[07:34:39] <Peach> HOW did you find that sooooo fast eddyb  0_0
[07:34:47] <eddyb> I knew about it
[07:41:27] *** Quits: Peach (Peach@moz-05nvva.fios.verizon.net) (Client exited)
[07:47:49] *** Joins: avikpal_ (avikpal@moz-cjc.4vt.238.117.IP)
[07:48:08] *** Quits: yjv (yjv@moz-ll38tk.pa.comcast.net) (Connection closed)
[07:48:28] *** Joins: yjv (yjv@moz-ll38tk.pa.comcast.net)
[07:48:43] *** Quits: waffles (wafflespean@moz-aeh.673.193.113.IP) (Ping timeout: 121 seconds)
[07:50:32] *** Quits: avikpal (avikpal@moz-qc1.uhm.194.117.IP) (Ping timeout: 121 seconds)
[07:50:56] *** Joins: waffles (wafflespean@moz-aeh.673.193.113.IP)
[07:51:59] *** Joins: avikpal (avikpal@moz-qc1.uhm.194.117.IP)
[07:54:46] *** Quits: avikpal_ (avikpal@moz-cjc.4vt.238.117.IP) (Ping timeout: 121 seconds)
[08:00:01] *** Quits: waffles (wafflespean@moz-aeh.673.193.113.IP) (Ping timeout: 121 seconds)
[08:01:39] *** Joins: waffles (wafflespean@moz-aeh.673.193.113.IP)
[08:05:15] *** Joins: chronode (chronode@moz-oddj4e.ga.comcast.net)
[08:05:52] *** Joins: bluss (bluss@moz-ec5o68.cust.bredbandsbolaget.se)
[08:06:20] *** Joins: yjv_ (yjv@moz-ll38tk.pa.comcast.net)
[08:27:03] *** Joins: munksgaard (munksgaard@moz-urnkl5.u.parknet.dk)
[08:29:58] *** Quits: ptalbot (ptalbot@moz-c4k8ug.dyn.as47377.net) (Ping timeout: 121 seconds)
[08:40:18] *** Joins: summerlight__ (summerlight@moz-lb3.6do.193.175.IP)
[08:42:09] *** Quits: yjv_ (yjv@moz-ll38tk.pa.comcast.net) (Connection closed)
[08:51:01] <kimundi> Hm, how do I access the Codemap in a syntax extension?
[08:54:43] <kimundi> I found cx.parse_sess.span_diagnostic.cm, but that seems convoluted :P
[08:59:16] <Skyler> kimundi: how about cx.codemap()?
[08:59:27] <kimundi> ...
[08:59:30] <kimundi> well thats easier
[08:59:34] <Skyler> :)
[08:59:39] <kimundi> :D
[08:59:51] *** Quits: avikpal (avikpal@moz-qc1.uhm.194.117.IP) (Ping timeout: 121 seconds)
[09:07:22] *** Joins: avikpal (avikpal@moz-u54.uhm.194.117.IP)
[09:16:46] *** Joins: arielb1 (Mibbit@moz-cmi.jfj.114.192.IP)
[09:29:51] *** Joins: laumann (thomas@moz-n9e72h.0.fullrate.dk)
[09:30:48] <zwarich> Ericson2314: the way to model a move from a variable is to treat it like it's undefined, just like it was initially
[09:31:43] <zwarich> I think this is what borrowck used to do, then they switched to the new scheme where they track each potential move separately so you can get better error messages
[09:34:57] *** Joins: bjz (bjz@moz-puppgq.tpgi.com.au)
[09:41:33] *** Joins: nagisa (nagisa@moz-8t068g.static.zebra.lt)
[09:46:06] <eddyb> https://turingtester.wordpress.com/2015/07/05/object-theft-etiquette-in-c-methods-with-a-side-of/
[09:46:11] <eddyb> speaking of the devil
[09:46:33] <arielb1> zwarich: a move is essentially a borrow to infinity
[09:46:36] <arielb1> in the current scheme
[09:50:21] *** Joins: X67r (user@moz-grp.h0g.138.193.IP)
[09:53:44] *** Quits: chronode (chronode@moz-oddj4e.ga.comcast.net) (Quit: Textual IRC Client: www.textualapp.com)
[09:58:25] *** Joins: yjv_ (yjv@moz-ll38tk.pa.comcast.net)
[09:58:53] *** Quits: laumann (thomas@moz-n9e72h.0.fullrate.dk) (Ping timeout: 121 seconds)
[10:02:25] *** Quits: yjv (yjv@moz-ll38tk.pa.comcast.net) (Connection closed)
[10:02:44] *** Quits: yjv_ (yjv@moz-ll38tk.pa.comcast.net) (Ping timeout: 121 seconds)
[10:05:01] *** Joins: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua)
[10:08:31] *** Joins: skeuomorf (skeuomorf@moz-j60.sa8.32.197.IP)
[10:10:51] *** Joins: rkruppe (chatzilla@moz-qii2pm.diu2.0rth.0908.2a02.IP)
[10:17:42] <zwarich> arielb1: well, not really, since you can reassign a moved value
[10:17:53] <zwarich> moved location rather
[10:20:38] *** Joins: harrisonclarke (harrisoncla@moz-uur7pt.eastlink.ca)
[10:21:51] *** Quits: bluss (bluss@moz-ec5o68.cust.bredbandsbolaget.se) (Quit: Lost terminal)
[10:22:34] <arielb1> zwarich: you can reassign a borrowed value
[10:22:42] <arielb1> if it is an &mut
[10:23:20] <zwarich> but you can't reassign it via the original access path
[10:23:29] <zwarich> so if the borrow is like the move then I don't see the analogy
[10:24:15] <arielb1> zwarich: of course you can
[10:25:08] <arielb1> rusti: let (mut v1, mut v2) = (1, 2); let mut y = &mut v1; let s = y; y = &mut v2; (*y, *s)
[10:25:09] -playbot- (2, 1)
[10:25:31] *** Quits: harrisonclarke (harrisoncla@moz-uur7pt.eastlink.ca) (Connection closed)
[10:27:00] <zwarich> arielb1: you cant reassign v1 and v2 after being borrowed
[10:27:19] *** Joins: harrisonclarke (harrisoncla@moz-uur7pt.eastlink.ca)
[10:27:35] *** Quits: RCIX (RCIX@moz-vnmep7.ph.cox.net) (Ping timeout: 121 seconds)
[10:27:39] <arielb1> actually that's a move
[10:27:46] <arielb1> I was sure s = y was a reborrow
[10:28:19] *** Quits: harrisonclarke (harrisoncla@moz-uur7pt.eastlink.ca) (Connection closed)
[10:28:58] <arielb1> let s = &mut *y doesn't work
[10:29:53] <Mutabah> Is it possible to include a file in the link only when building an executable?
[10:31:48] <Mutabah> I currently include the lowest level of my runtime as a file in the linker args, but that means that it gets linked with dynamic libraries (which I don't want, as it's not PIC)
[10:37:35] *** Quits: arielb1 (Mibbit@moz-cmi.jfj.114.192.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[10:40:54] *** Joins: avikpal_ (avikpal@moz-mn3.p8t.194.117.IP)
[10:41:19] *** Quits: avikpal (avikpal@moz-u54.uhm.194.117.IP) (Ping timeout: 121 seconds)
[10:43:44] <eddyb> Mutabah: crt0?
[10:44:12] <Mutabah> pretty much, some experimenting shows that pre_link_objs worked
[10:44:29] <eddyb> I'm not sure how ld is configured to pick up crt0 and friends
[10:44:40] <eddyb> but I know it's possible
[10:45:42] <eddyb> Mutabah: hmm, so there's https://github.com/miselin/pedigree/blob/develop/src/subsys/posix/crt0.c
[10:46:09] <Mutabah> Oh, I know all that
[10:46:18] <Mutabah> I've written one before
[10:46:41] <Mutabah> https://github.com/thepowersgang/acess2/blob/master/Usermode/Libraries/crt0.o_src/crt0.c
[10:47:13] <eddyb> https://github.com/miselin/pedigree/blob/develop/src/user/SConscript#L242
[10:47:27] <eddyb> I'm trying to find where it's actually passed
[10:48:56] <Mutabah> I think I may have solved it... not 100% sure
[10:50:42] *** Joins: avikpal (avikpal@moz-v9n.986.233.117.IP)
[10:51:13] <eddyb> Mutabah: ahh https://github.com/miselin/pedigree/blob/develop/compilers/pedigree-gcc.patch
[10:51:37] <eddyb> well, actually, I'm not sure
[10:52:27] <eddyb> there's stuff like https://github.com/miselin/pedigree/blob/develop/compilers/pedigree-gcc.patch#L143
[10:53:46] *** Quits: avikpal_ (avikpal@moz-mn3.p8t.194.117.IP) (Ping timeout: 121 seconds)
[10:54:11] <Mutabah> Yeah... gcc does some trickery
[10:55:27] <Mutabah> well, actually, gcc has complex-ish selection for what crt0 file to use
[10:55:40] *** Quits: avikpal (avikpal@moz-v9n.986.233.117.IP) (Ping timeout: 121 seconds)
[10:56:11] *** Quits: kimundi (kimundi@moz-6j1fee.ufnp.bi9d.4fe2.2002.IP) (Ping timeout: 121 seconds)
[10:56:12] *** Joins: kimundi (kimundi@moz-53kd7g.j382.7dkg.4fe2.2002.IP)
[10:57:57] *** Quits: aatch (james@moz-is4j4r.cable.telstraclear.net) (Ping timeout: 121 seconds)
[10:59:20] *** Quits: mitaa (mitaa@moz-7q99b5.dyn.drei.com) (Ping timeout: 121 seconds)
[11:00:49] *** Quits: waffles (wafflespean@moz-aeh.673.193.113.IP) (Ping timeout: 121 seconds)
[11:03:13] *** Joins: avikpal (avikpal@moz-mn3.p8t.194.117.IP)
[11:05:25] *** Joins: eibwen (eibwen@moz-v86e9g.dip0.t-ipconnect.de)
[11:05:44] <WindowsBunny> Mutabah: I'm glad that msvc doesn't need that crt0 business
[11:06:14] *** Joins: waffles (wafflespean@moz-aeh.673.193.113.IP)
[11:10:21] *** Quits: benh (ben@moz-ie00gt.org) (Ping timeout: 121 seconds)
[11:10:47] *** Quits: eddyb (eddyb@moz-h7s.q07.26.188.IP) (Connection closed)
[11:11:38] *** Joins: avikpal_ (avikpal@moz-ard.saf.227.117.IP)
[11:14:10] *** Quits: avikpal (avikpal@moz-mn3.p8t.194.117.IP) (Ping timeout: 121 seconds)
[11:14:44] *** Joins: eddyb (eddyb@moz-h7s.q07.26.188.IP)
[11:17:54] *** Quits: munksgaard (munksgaard@moz-urnkl5.u.parknet.dk) (Ping timeout: 121 seconds)
[11:21:15] *** Joins: avikpal (avikpal@moz-mn3.p8t.194.117.IP)
[11:24:27] *** Quits: avikpal_ (avikpal@moz-ard.saf.227.117.IP) (Ping timeout: 121 seconds)
[11:25:41] *** Joins: avikpal_ (avikpal@moz-hta.6lo.194.117.IP)
[11:26:12] *** Quits: avikpal (avikpal@moz-mn3.p8t.194.117.IP) (Ping timeout: 121 seconds)
[11:26:48] *** Quits: Kingsquee (kingsley@moz-33q6f3.bchsia.telus.net) (Quit: Konversation terminated!)
[11:27:42] *** Joins: filsmick (filsmick@moz-8qcdgt.abo.wanadoo.fr)
[11:31:50] *** Joins: avikpal (avikpal@moz-gi6.uhm.194.117.IP)
[11:32:33] *** Quits: avikpal_ (avikpal@moz-hta.6lo.194.117.IP) (Ping timeout: 121 seconds)
[11:35:11] *** Quits: nagisa (nagisa@moz-8t068g.static.zebra.lt) (Ping timeout: 121 seconds)
[11:37:14] *** Joins: avikpal_ (avikpal@moz-tbd.igl.194.117.IP)
[11:37:52] *** Quits: avikpal (avikpal@moz-gi6.uhm.194.117.IP) (Ping timeout: 121 seconds)
[11:44:14] *** Quits: avikpal_ (avikpal@moz-tbd.igl.194.117.IP) (Ping timeout: 121 seconds)
[11:46:32] *** Joins: avikpal (avikpal@moz-rth.onn.194.117.IP)
[11:46:53] *** Joins: yjv (yjv@moz-ll38tk.pa.comcast.net)
[11:51:05] *** Quits: yjv (yjv@moz-ll38tk.pa.comcast.net) (Ping timeout: 121 seconds)
[11:54:35] *** Joins: nagisa (nagisa@moz-8t068g.static.zebra.lt)
[11:56:15] *** Quits: bjz (bjz@moz-puppgq.tpgi.com.au) (Quit: My Mac has gone to sleep. ZZZzzz…)
[11:58:25] *** Quits: avikpal (avikpal@moz-rth.onn.194.117.IP) (Ping timeout: 121 seconds)
[11:58:43] *** Joins: avikpal (avikpal@moz-bmk.mpm.194.117.IP)
[12:05:23] *** Joins: bjz (bjz@moz-puppgq.tpgi.com.au)
[12:05:47] *** Quits: bjz (bjz@moz-puppgq.tpgi.com.au) (Quit: My Mac has gone to sleep. ZZZzzz…)
[12:08:14] *** Joins: bjz (bjz@moz-puppgq.tpgi.com.au)
[12:09:20] *** Quits: filsmick (filsmick@moz-8qcdgt.abo.wanadoo.fr) (Connection closed)
[12:09:41] *** Joins: filsmick (filsmick@moz-8qcdgt.abo.wanadoo.fr)
[12:12:46] *** Quits: p1start (p1start@moz-nftjhe.org) (Ping timeout: 121 seconds)
[12:15:11] *** Joins: avikpal_ (avikpal@moz-7ao.9fs.194.117.IP)
[12:15:22] *** Joins: munksgaard (munksgaard@moz-urnkl5.u.parknet.dk)
[12:15:43] *** Quits: avikpal (avikpal@moz-bmk.mpm.194.117.IP) (Ping timeout: 121 seconds)
[12:19:15] *** Quits: avikpal_ (avikpal@moz-7ao.9fs.194.117.IP) (Ping timeout: 121 seconds)
[12:21:49] *** Joins: avikpal (avikpal@moz-krq.nmc.194.117.IP)
[12:22:00] *** Quits: kimundi (kimundi@moz-53kd7g.j382.7dkg.4fe2.2002.IP) (Ping timeout: 121 seconds)
[12:22:03] *** Quits: filsmick (filsmick@moz-8qcdgt.abo.wanadoo.fr) (Connection closed)
[12:22:04] *** Joins: filsmick (filsmick@moz-8qcdgt.abo.wanadoo.fr)
[12:22:31] *** Joins: ytain (ytain@moz-upqesl.dsl.teksavvy.com)
[12:27:02] *** Joins: kimundi (kimundi@moz-22fjhj.o533.1q3j.4fe2.2002.IP)
[12:27:58] *** Joins: avikpal_ (avikpal@moz-bsk.4af.194.117.IP)
[12:28:49] *** Quits: avikpal (avikpal@moz-krq.nmc.194.117.IP) (Ping timeout: 121 seconds)
[12:36:38] *** Joins: avikpal (avikpal@moz-pam.6lo.194.117.IP)
[12:36:50] *** Quits: avikpal_ (avikpal@moz-bsk.4af.194.117.IP) (Ping timeout: 121 seconds)
[12:39:50] *** Quits: munksgaard (munksgaard@moz-urnkl5.u.parknet.dk) (Ping timeout: 121 seconds)
[12:42:30] *** Quits: avikpal (avikpal@moz-pam.6lo.194.117.IP) (Ping timeout: 121 seconds)
[12:43:36] *** Joins: avikpal (avikpal@moz-k7r.ds3.194.117.IP)
[12:48:17] *** Quits: avikpal (avikpal@moz-k7r.ds3.194.117.IP) (Ping timeout: 121 seconds)
[12:50:19] *** Joins: X67r_ (user@moz-pfjhmu.mullvad.net)
[12:52:48] *** Quits: X67r (user@moz-grp.h0g.138.193.IP) (Connection closed)
[12:55:59] *** Joins: mib_f0r0y1 (Mibbit@moz-elqf7r.highway.telekom.at)
[12:55:59] *** Quits: mib_f0r0y1 (Mibbit@moz-elqf7r.highway.telekom.at) (Quit: http://www.mibbit.com ajax IRC Client)
[12:59:25] *** Quits: filsmick (filsmick@moz-8qcdgt.abo.wanadoo.fr) (Connection closed)
[12:59:52] *** Joins: filsmick (filsmick@moz-8qcdgt.abo.wanadoo.fr)
[12:59:52] *** Quits: filsmick (filsmick@moz-8qcdgt.abo.wanadoo.fr) (Connection closed)
[12:59:53] *** Joins: filsmick (filsmick@moz-8qcdgt.abo.wanadoo.fr)
[13:07:01] *** Quits: waffles (wafflespean@moz-aeh.673.193.113.IP) (Ping timeout: 121 seconds)
[13:12:52] *** Quits: johnsoft (johnsoft@moz-69mrig.res.rr.com) (Quit: Leaving)
[13:13:00] *** Joins: johnsoft (johnsoft@moz-69mrig.res.rr.com)
[13:13:30] *** Joins: waffles (wafflespean@moz-1d5.673.193.113.IP)
[13:15:39] *** Quits: eibwen (eibwen@moz-v86e9g.dip0.t-ipconnect.de) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[13:16:43] *** Joins: benh (ben@moz-ie00gt.org)
[13:18:10] *** Quits: johnsoft (johnsoft@moz-69mrig.res.rr.com) (Quit: Leaving)
[13:18:14] *** Joins: johnsoft (johnsoft@moz-69mrig.res.rr.com)
[13:33:18] <nox> Is there some documentation about the various Rust tokens? Things like describing why there is no specific token for keywords.
[13:33:33] <Mutabah> nox: The reference?
[13:33:52] <nox> Mutabah: The reference shows that there is no specific token for keywords, it doesn't tell why.
[13:34:01] <nox> Err, I thought you meant the API reference.
[13:34:23] <nox> Mutabah: I'm talking about the Token type in libsyntax.
[13:34:28] <Mutabah> Ah
[13:35:12] *** Joins: yjv (yjv@moz-ll38tk.pa.comcast.net)
[13:36:54] <Mutabah> nox: ... I don't know why actually, it seems that they're treated as idents
[13:39:34] *** Quits: yjv (yjv@moz-ll38tk.pa.comcast.net) (Ping timeout: 121 seconds)
[13:46:53] *** Quits: doener (doener@moz-fnh.n4j.147.5.IP) (Quit: leaving)
[13:51:50] <mrmonday> nox: there's no need for keywords to be specific tokens - tokens on their own mean nothing as far as the syntax is concerned
[13:52:03] <mrmonday> so whilst you could have separate tokens for keywords and identifiers there's no need
[13:52:14] <mrmonday> since they are both just strings of characters
[13:52:35] <mrmonday> I've seen it done both ways
[13:53:17] <nox> mrmonday: True that.
[13:53:43] <nox> mrmonday: Oh now that I think a bit more about it, can't you not avoid doing this if you want macros like the ones in Rust?
[13:54:20] *** Quits: filsmick (filsmick@moz-8qcdgt.abo.wanadoo.fr) (Connection closed)
[13:55:01] *** Joins: filsmick (filsmick@moz-8qcdgt.abo.wanadoo.fr)
[13:55:11] *** Joins: eibwen (eibwen@moz-v86e9g.dip0.t-ipconnect.de)
[13:55:31] <mrmonday> I don't know how macros are implemented, but the way tokens are implemented shouldn't make a difference
[13:56:29] *** Quits: phynx (chatzilla@moz-liep7t.dsl.scarlet.be) (Ping timeout: 121 seconds)
[13:56:44] *** Quits: filsmick (filsmick@moz-8qcdgt.abo.wanadoo.fr) (Connection closed)
[13:56:45] *** Joins: filsmick (filsmick@moz-8qcdgt.abo.wanadoo.fr)
[13:58:07] <mrmonday> nox: for reference, clang uses separate tokens for keywords, as does dmd (D compiler)
[13:58:28] <mrmonday> not sure what gcc does, I'd need to look it up
[13:59:17] <mrmonday> clang: https://github.com/llvm-mirror/clang/blob/master/include/clang/Basic/TokenKinds.def
[13:59:26] <mrmonday> dmd: https://github.com/D-Programming-Language/dmd/blob/master/src/tokens.h
[14:09:09] <mrmonday> it looks like gcc uses a single token like rustc does, but I haven't actually managed to work my way through the source yet, it's far harder to navigate than most other compilers I've been through :L
[14:12:22] <mrmonday> https://github.com/gcc-mirror/gcc/blob/master/libcpp/include/cpplib.h <= looks like it does it the rustc way, but I'm not 100%
[14:17:43] *** Quits: rkruppe (chatzilla@moz-qii2pm.diu2.0rth.0908.2a02.IP) (Ping timeout: 121 seconds)
[14:20:22] *** Quits: blank_name (blank_name@moz-p4egrb.mi.frontiernet.net) (Ping timeout: 121 seconds)
[14:20:32] *** Joins: blank_name (blank_name@moz-kdq.fli.183.192.IP)
[14:41:46] *** Quits: Feyn (aram@moz-5vj.68e.115.42.IP) (Quit: Leaving)
[14:45:42] *** Joins: amyers (amyers@moz-osiar4.md.comcast.net)
[14:49:59] *** Quits: amyers (amyers@moz-osiar4.md.comcast.net) (Ping timeout: 121 seconds)
[15:11:07] *** Joins: harrisonclarke (harrisoncla@moz-uur7pt.eastlink.ca)
[15:15:04] *** Joins: bdero (bran@moz-0e2lk5.sns9.e6pb.0197.2601.IP)
[15:23:29] *** Joins: yjv (yjv@moz-ll38tk.pa.comcast.net)
[15:27:49] *** Quits: yjv (yjv@moz-ll38tk.pa.comcast.net) (Ping timeout: 121 seconds)
[15:32:28] *** Joins: ptalbot (ptalbot@moz-c4k8ug.dyn.as47377.net)
[15:34:12] *** Joins: munksgaard (munksgaard@moz-urnkl5.u.parknet.dk)
[15:35:01] *** Joins: rovar_ (rovar@moz-96effg.dyn.optonline.net)
[15:35:11] *** Quits: rovar (rovar@moz-6iq.47m.88.38.IP) (NickServ (RECOVER command used by rovar_))
[15:35:11] *** rovar_ is now known as rovar
[15:35:27] *** Joins: rovar_ (rovar@moz-6iq.47m.88.38.IP)
[15:43:53] *** Joins: apcully (user@moz-mao2lt.fl.comcast.net)
[15:45:50] *** Quits: ptalbot (ptalbot@moz-c4k8ug.dyn.as47377.net) (Ping timeout: 121 seconds)
[15:47:43] *** Quits: harrisonclarke (harrisoncla@moz-uur7pt.eastlink.ca) (Connection closed)
[15:47:58] *** Joins: ELD (textual@moz-tbcsac.co.comcast.net)
[15:54:00] *** Joins: phynx (chatzilla@moz-utc3tj.dsl.scarlet.be)
[15:57:53] *** Joins: arielb1 (Ariel@moz-v76b5j.red.bezeqint.net)
[16:16:57] *** Quits: munksgaard (munksgaard@moz-urnkl5.u.parknet.dk) (Connection closed)
[16:26:19] *** Quits: petercommand (peter@moz-geqcp0.com) (Ping timeout: 121 seconds)
[16:34:52] *** Joins: petercommand (peter@moz-geqcp0.com)
[16:49:42] *** Joins: harrisonclarke (harrisoncla@moz-uur7pt.eastlink.ca)
[17:07:06] *** Joins: ptalbot (ptalbot@moz-8smn96.dyn.as47377.net)
[17:09:51] <nagisa> steveklabnik: ping
[17:10:00] <steveklabnik> pong
[17:10:21] <nagisa> http://doc.rust-lang.org/stable/core/primitive.i8.html#method.swap_bytes do you think documentation examples shouldn’t involve u64 here as well?
[17:10:45] <steveklabnik> so, it's hard
[17:10:50] <steveklabnik> all of these methods are generated by macros
[17:10:52] <nagisa> (sadly, this is a bit hard to do without duplication, because it is generated by macro, yes)
[17:10:53] <steveklabnik> for all integer types
[17:10:55] <steveklabnik> yeah
[17:11:05] <steveklabnik> so, it's not ideal, but i am not sure what the right thing to do is
[17:11:58] *** Joins: yjv (yjv@moz-ll38tk.pa.comcast.net)
[17:13:03] <nagisa> well `let m : $type = 0x0123456789ABCDEF % $type::MAX; let n : $type = 0xEFCDAB8967452301 % $type::MAX;` could work for this specific case, I think.
[17:16:22] *** Quits: yjv (yjv@moz-ll38tk.pa.comcast.net) (Ping timeout: 121 seconds)
[17:21:08] *** Joins: rkruppe (chatzilla@moz-atcorr.diu2.0rth.0908.2a02.IP)
[17:21:30] <eddyb> type ascription could work. could :P
[17:22:55] <eddyb> acrichto: I completely forgot about the metadata stuff, TBQH
[17:23:46] *** Joins: SiegeLord (sl@moz-9jtaei.ca.comcast.net)
[17:24:50] <nagisa> eddyb: wouldn’t it, you know, make overflowing literals lint complain?
[17:25:23] <eddyb> nagisa: % is actually wrong
[17:25:29] <eddyb> nagisa: you want &
[17:25:39] <eddyb> at least for unsigned types
[17:25:58] <nagisa> Affirmative.
[17:33:05] <eddyb> nagisa: but if that literal infers to a small type (like u8), you'll still have an issue, just the lint
[17:33:18] <eddyb> *just the lint won't trigger because it's not written properly
[17:33:56] <eddyb> either that or it's intentionally crippled, I'm not sure, I've seen conflicting opinions on it
[17:34:05] <nagisa> me remember that’s not even lint, its somewhere in the middle
[17:34:28] <nagisa> last time I was looking at it
[17:35:20] * nagisa has a bunch ideas what could be fixed, but zero motivation to actually do anything, lately
[17:39:10] <eddyb> nagisa: my motivation for doing anything at all in the past few weeks has been "have exams. don't want to think about them"
[17:42:05] <kimundi> Now its "had exams, don't want to do anything", right? ;)
[17:44:03] *** Quits: harrisonclarke (harrisoncla@moz-uur7pt.eastlink.ca) (Connection closed)
[17:44:10] <nagisa> mine have been wrapped up a few weeks ago
[17:45:43] <eddyb> kimundi: life has no meaning
[17:46:47] <kimundi> heh
[17:47:51] <eddyb> kimundi: if only this was "literature" https://tools.ietf.org/rfc/rfc6716.txt
[17:48:15] <kimundi> haha
[17:48:17] <eddyb> better love story than - ahh that's so old now
[17:48:24] <kimundi> That would be way more interesting indeed ;)
[17:54:54] *** Joins: goyox86 (textual@moz-rvv.00r.255.109.IP)
[17:55:12] <Gankro> aturon: ping
[17:56:25] *** Joins: harrisonclarke (harrisoncla@moz-uur7pt.eastlink.ca)
[17:57:25] *** Joins: laumann (thomas@moz-n9e72h.0.fullrate.dk)
[17:59:23] *** Quits: waffles (wafflespean@moz-1d5.673.193.113.IP) (Quit: C'yall soon...)
[17:59:34] *** Quits: harrisonclarke (harrisoncla@moz-uur7pt.eastlink.ca) (Connection closed)
[18:09:57] *** Quits: Quxxy (chatzilla@moz-0nv.jkp.167.59.IP) (Ping timeout: 121 seconds)
[18:15:59] *** Quits: rkruppe (chatzilla@moz-atcorr.diu2.0rth.0908.2a02.IP) (Ping timeout: 121 seconds)
[18:17:08] *** Quits: ptalbot (ptalbot@moz-8smn96.dyn.as47377.net) (Ping timeout: 121 seconds)
[18:20:23] *** Quits: blank_name (blank_name@moz-kdq.fli.183.192.IP) (Ping timeout: 121 seconds)
[18:34:31] *** Joins: bluss (bluss@moz-ec5o68.cust.bredbandsbolaget.se)
[18:34:40] *** Joins: rkruppe (chatzilla@moz-j5geu3.diu2.0rth.0908.2a02.IP)
[18:38:52] *** Joins: laumann_ (thomas@moz-n9e72h.0.fullrate.dk)
[18:41:12] *** Joins: yjv (yjv@moz-ll38tk.pa.comcast.net)
[18:41:22] *** Quits: eljay (eljay@moz-fmte10.skybroadband.com) (Quit: Leaving)
[18:44:58] *** Joins: ptalbot (ptalbot@moz-8smn96.dyn.as47377.net)
[18:46:27] *** Joins: cedra (cedra@moz-li2.c4s.100.82.IP)
[18:51:26] *** Joins: harrisonclarke (harrisoncla@moz-uur7pt.eastlink.ca)
[18:52:32] *** Parts: cedra (cedra@moz-li2.c4s.100.82.IP) ("left")
[18:58:53] *** Quits: laumann_ (thomas@moz-n9e72h.0.fullrate.dk) (Quit: leaving)
[19:07:50] *** Quits: SiegeLord (sl@moz-9jtaei.ca.comcast.net) (Quit: It's a joke, it's all a joke.)
[19:18:14] *** Quits: filsmick (filsmick@moz-8qcdgt.abo.wanadoo.fr) (Connection closed)
[19:18:56] *** Joins: filsmick (filsmick@moz-8qcdgt.abo.wanadoo.fr)
[19:21:16] *** Joins: kxlzz (kxlzz@moz-a3bguo.vc.shawcable.net)
[19:24:03] <nagisa> playbot: concat!(1, 2)
[19:24:03] -playbot- "12"
[19:24:27] <nagisa> I really want to make that be 12 instead
[19:24:40] <Elaine> The integer literal 12?
[19:24:58] <Elaine> Can't do that with macros.
[19:25:07] <bluss> concat is for strings
[19:25:26] <nagisa> You can if I’d submitted an RFC to change behaviour of concat! and implemented it :)
[19:26:16] <nagisa> s/can/could/
[19:28:25] <eddyb> that would be a breaking change
[19:28:32] <eddyb> you could add an "eval" macro...
[19:28:52] <Elaine> nagisa: what's the usecase?
[19:29:02] <nagisa> yeah, alternatively we could add concat_that_actually_makes_some_sense!()
[19:29:08] <Elaine> What
[19:29:11] <eddyb> huh
[19:29:16] <eddyb> nagisa: this is string concatenation
[19:29:18] <Elaine> Since when does concattenating numbers *ever* make sense?
[19:29:21] <eddyb> which results in... strings
[19:29:38] <eddyb> the fact that it stringifies its inputs first is a convenience
[19:29:53] <Elaine> Numbers are the completely wrong algebraic structure to try and get concatenation to work on...
[19:30:33] <nagisa> hmm, thinking now you might be right since there’s no sane way to handle all bases properly
[19:30:36] <Ericson2314> monoid!(1, 1) => 1
[19:31:23] <Ericson2314> monoid!(1, 0) => panic!()
[19:31:26] * Ericson2314 justifies typo
[19:32:50] <nagisa> haha
[19:36:37] *** Quits: untitaker (untitaker@moz-atabag.highway.telekom.at) (Ping timeout: 121 seconds)
[19:37:56] *** Joins: untitaker (untitaker@moz-8kcbnd.highway.telekom.at)
[19:42:45] *** Quits: rkruppe (chatzilla@moz-j5geu3.diu2.0rth.0908.2a02.IP) (Quit: ChatZilla 0.9.91.1 [Firefox 39.0/20150630154324])
[19:50:32] *** Quits: apoelstra (username@moz-pvbasl.net) (Ping timeout: 121 seconds)
[19:52:11] *** Joins: RCIX (RCIX@moz-vnmep7.ph.cox.net)
[19:53:58] <eddyb> huon: can you think of more cases where it previously wasn't finding a specific impl but now it can? https://github.com/rust-lang/rust/pull/26783
[19:56:55] *** Quits: RCIX (RCIX@moz-vnmep7.ph.cox.net) (Ping timeout: 121 seconds)
[19:59:16] *** Joins: James (quassel@moz-dkk1ha.range86-163.btcentralplus.com)
[20:01:59] *** Joins: RCIX (RCIX@moz-vnmep7.ph.cox.net)
[20:03:41] *** Quits: semarie (semarie@moz-7cbdfl.bpv6.bg1u.41d0.2001.IP) (Ping timeout: 121 seconds)
[20:07:26] *** Quits: filsmick (filsmick@moz-8qcdgt.abo.wanadoo.fr) (Connection closed)
[20:07:28] *** Joins: filsmick (filsmick@moz-8qcdgt.abo.wanadoo.fr)
[20:07:57] *** Quits: filsmick (filsmick@moz-8qcdgt.abo.wanadoo.fr) (Quit: )
[20:09:43] *** Quits: harrisonclarke (harrisoncla@moz-uur7pt.eastlink.ca) (Connection closed)
[20:09:46] *** Quits: X67r_ (user@moz-pfjhmu.mullvad.net) (Ping timeout: 121 seconds)
[20:11:58] *** Joins: swgillespie (swgillespie@moz-43kn80.ip.windstream.net)
[20:12:55] *** Joins: harrisonclarke (harrisoncla@moz-uur7pt.eastlink.ca)
[20:14:27] *** Joins: annodomini (lambda@moz-qgii5v.ma.comcast.net)
[20:14:44] *** Joins: genbattle (genbattle@moz-4v0.gkd.16.182.IP)
[20:16:23] *** Joins: X67r (user@moz-6a2pbf.mullvad.net)
[20:17:28] *** Joins: X67r_ (user@moz-6a2pbf.mullvad.net)
[20:18:00] *** Quits: X67r (user@moz-6a2pbf.mullvad.net) (Quit: leaving)
[20:18:01] *** Quits: X67r_ (user@moz-6a2pbf.mullvad.net) (Quit: leaving)
[20:18:22] *** Joins: X67r (user@moz-6a2pbf.mullvad.net)
[20:21:18] *** Joins: munksgaard (munksgaard@moz-urnkl5.u.parknet.dk)
[20:22:22] <Ericson2314> Does the token stream get converted to the token forest in an addition step between lexing and parsing?
[20:24:48] *** Quits: swgillespie (swgillespie@moz-43kn80.ip.windstream.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[20:25:35] * nagisa giggles at token forest
[20:26:04] <Ericson2314> yeah i know...
[20:30:15] *** Quits: summerlight__ (summerlight@moz-lb3.6do.193.175.IP) (Ping timeout: 121 seconds)
[20:45:38] *** Quits: harrisonclarke (harrisoncla@moz-uur7pt.eastlink.ca) (Connection closed)
[20:46:22] *** Quits: eibwen (eibwen@moz-v86e9g.dip0.t-ipconnect.de) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[20:47:54] *** Joins: apoelstra (username@moz-pvbasl.net)
[20:50:45] *** Joins: blank_name (blank_name@moz-crs.fli.183.192.IP)
[20:52:12] *** Joins: harrisonclarke (harrisoncla@moz-uur7pt.eastlink.ca)
[20:52:21] <eddyb> Ericson2314: it technically doesn't need to be in tree form
[20:52:36] <eddyb> Ericson2314: but the delimiters are parsed to determine the end of the token stream
[20:52:55] <eddyb> (the substream used by a macro invocation, I mean)
[20:53:14] <Ericson2314> so the token-trees bussiness is just used for macros
[20:53:28] <eddyb> yeah
[20:53:59] *** Quits: harrisonclarke (harrisoncla@moz-uur7pt.eastlink.ca) (Connection closed)
[20:55:52] *** Quits: Pierre_M (Pierre_M@moz-2vs15r.slkc.qwest.net) (Ping timeout: 121 seconds)
[20:56:12] <Ericson2314> I PHD student at my school has a paper/project on new foundation for syntax manipulation where identifers point to their binding site and syntax tree nodes have sort of an "in-scope" and "out-scope"
[20:58:00] <Ericson2314> there is a haskell library which does something like for rank2 st trick to ensure you don't move syntax subtree away from binding site
[20:58:48] <Ericson2314> Such a thing could impose binding structure on token trees
[20:58:58] <Ericson2314> if they really were a thing
[21:00:53] *** Joins: ptalbot_ (ptalbot@moz-6oebfn.dyn.as47377.net)
[21:01:03] *** Quits: ptalbot (ptalbot@moz-8smn96.dyn.as47377.net) (Ping timeout: 121 seconds)
[21:04:02] <Ericson2314> and give us hygien before parsing.
[21:08:01] <eddyb> Ericson2314: does it require definitions-before-uses?
[21:08:06] <eddyb> Ericson2314: because our current hygiene does
[21:09:01] *** Quits: apoelstra (username@moz-pvbasl.net) (Connection closed)
[21:09:22] *** Joins: apoelstra (username@moz-pvbasl.net)
[21:10:28] *** Quits: ptalbot_ (ptalbot@moz-6oebfn.dyn.as47377.net) (Ping timeout: 121 seconds)
[21:11:24] *** Quits: laumann (thomas@moz-n9e72h.0.fullrate.dk) (Quit: leaving)
[21:12:52] <Ericson2314> well for example if you have (lambda args body)
[21:13:34] <Ericson2314> you can have a rule where the "out scope" of args is added to the "in scope" of lambda, and fed to body
[21:14:18] *** Quits: arielb1 (Ariel@moz-v76b5j.red.bezeqint.net) (Quit: Ex-Chat)
[21:14:49] <Ericson2314> the out scopes getting interesting when args is a deep pattern
[21:15:34] <eddyb> Ericson2314: that's definition-before-use
[21:15:49] <eddyb> Ericson2314: which is only true for locals in Rust
[21:17:39] <Ericson2314> oh I see
[21:17:56] <Ericson2314> it supports fixpoints on the environment constraints
[21:18:06] <Ericson2314> for letrec or top-level
[21:18:28] *** Quits: johnsoft (johnsoft@moz-69mrig.res.rr.com) (Ping timeout: 121 seconds)
[21:18:53] *** Joins: johnsoft (johnsoft@moz-69mrig.res.rr.com)
[21:19:24] <eddyb> Ericson2314: yeah, that sounds like what we'd need for item hygiene
[21:20:18] <eddyb> Ericson2314: all identifiers already track a context which might encompass both the in and out scopes you are talking about, but I really don't know much about how it works
[21:20:29] <bluss> kimundi: anything remaining in gh22477 ?
[21:20:29] <[o__o]> Tracking issue for Add a generic string pattern matching API (RFC 528): https://github.com/rust-lang/rust/issues/22477
[21:20:44] <Ericson2314> my guess is just the in-scope
[21:20:49] <Ericson2314> out-scope is really weird
[21:20:56] <Ericson2314> $!(...) can be a token-tree unquote, $@!(....) token-tree unquote-splicing
[21:21:13] <eddyb> Ericson2314: why splicing?
[21:21:35] <Ericson2314> the pre-rfc just had unquote-splicing-esque but that is probably not the right one if just one is availible
[21:21:46] <eddyb> Ericson2314: what's the difference?
[21:22:35] <Ericson2314> you can do things like "struct Foo (usize $@!(close-paren!())" potentially
[21:23:31] <Ericson2314> or if not that evil
[21:23:40] <kimundi> bluss: Hm... Nothing in the "missing" category, though a bit in the "predicated on a accepted RFC issue, change it" category. Namely match_indices() change to (usize, &str), and stuff like extending replace to use the pattern API
[21:23:58] <Ericson2314> "[1, 2, $@!(three-four-five!()), 6, 7]"
[21:24:14] <kimundi> bluss: And of course experiments to generalize the Pattern API to OsStr and [T] somehow
[21:24:20] *** Joins: yjv_ (yjv@moz-v5s4ts.fios.verizon.net)
[21:25:13] <eddyb> Ericson2314: you can't do the close paren thing
[21:25:17] <kimundi> bluss: In about a month I'll be actually able to take more time to think about this stuff myself again :)
[21:25:26] *** Quits: Murarth (Murarth@moz-jpotpi.phnx.qwest.net) (Quit: Mani Mani is always Mani Mani at Mani Mani with all Mani Mani Mani)
[21:25:26] <eddyb> Ericson2314: () [] {} are not tokens in Rust, they are token-tree delimiters
[21:25:40] <Ericson2314> yeah you are right
[21:25:52] <eddyb> also, "3, 4, 5" is not evil
[21:25:55] *** Joins: Murarth (Murarth@moz-ap5.hnl.166.46.IP)
[21:26:07] <eddyb> that's exactly the intended usecase
[21:26:17] <Ericson2314> normal unquote you'd always evaluate into a subtree
[21:26:19] <eddyb> most other things with without $!
[21:26:29] <eddyb> *work without
[21:26:37] <Ericson2314> but here you peel of the tree root, and splice in children
[21:27:02] <eddyb> the intention is eager evaluation and splicing
[21:27:11] <Ericson2314> otherwise you get [1, 2, (3, 4, 5), 6] or something
[21:27:24] <eddyb> Ericson2314: well, no, not really
[21:27:48] <eddyb> if foo!() would produce (3, 4, 5), so would $!(foo!())
[21:28:16] <eddyb> we're talking multiple consecutive token-trees here
[21:28:28] <eddyb> there's no "root"
[21:29:14] <Ericson2314> unquote-splicing = unquote . tree-to-forest
[21:29:25] <Ericson2314> sort of
[21:29:33] <eddyb> the output is already a forest
[21:29:38] <kimundi> bluss: I updated my comment there with checkboxes, but will be gone for the day now :)
[21:29:46] <bluss> kimundi: ok great
[21:29:50] <eddyb> (the current implementation might need a redesign to switch macros to output token streams rather than a few blessed pre-parsed nodes)
[21:29:57] <bluss> kimundi: it sounds like the rfc is done, but future work remains though
[21:30:02] <kimundi> yeah
[21:30:16] <Ericson2314> I suppose it works to always output a forest and always splice it
[21:30:38] <Ericson2314> but I feel like that's like shell variable expansion, and you find yourself doing "$X" all the time
[21:31:26] <Ericson2314> "x * $!(one-plus-one!())" for example
[21:31:53] <eddyb> Ericson2314: the intended usecase is where it wouldn't parse without $!
[21:32:53] <Ericson2314> Sure, but there are probably other such precedence issues
[21:33:15] *** Joins: brson (brson@moz-cfhap5.mtv2.mozilla.com)
[21:33:16] *** ChanServ sets mode: +o brson
[21:33:21] <eddyb> $* could be a clearer syntax
[21:34:16] <eddyb> $*concat_idents!(foo, bar)
[21:34:47] <Ericson2314> "struct Name $*foo!()" where foo!() ==> "( usize ) ; struct Unit() ;"
[21:34:50] <Ericson2314> should that work?
[21:35:24] <eddyb> I believe there isn't any usecase that cannot be reduced to $! around individual macro invocations, hence the $* form
[21:35:30] <eddyb> Ericson2314: inside a macro, yes
[21:38:56] <Ericson2314> you see how that is related to the one-plus-one problem, right?
[21:39:40] <Ericson2314> I can't think of a non-expression situation where different tree structure leads to different valid meanings, but I doubt it doesn't exist
[21:40:01] <Ericson2314> if it doesn't now, seems like an unnessisary burden to enforce that
[21:40:44] <eddyb> Ericson2314: I know, but I don't believe it is a problem
[21:40:58] <eddyb> there are cases in which you need to generate arbitrary sequences of tokens
[21:41:09] *** Joins: tamird (textual@moz-ie2.6pc.167.190.IP)
[21:41:13] *** Quits: tamird (textual@moz-ie2.6pc.167.190.IP) (Quit: Textual IRC Client: www.textualapp.com)
[21:41:30] <Ericson2314> sure, and thats why I say have $*-splicing and $*-non-splicing
[21:41:53] <eddyb> is there an usecase for $*-non-splicing?
[21:41:58] *** Quits: yjv_ (yjv@moz-v5s4ts.fios.verizon.net) (Connection closed)
[21:42:17] *** Joins: Nashenas88 (Nashenas88@moz-of81j9.miamfl.sbcglobal.net)
[21:42:44] <Ericson2314> well most of the time you don't need splicing
[21:42:55] <Ericson2314> maybe with patterns they would actually prevent problems
[21:43:04] <eddyb> you mean you're limited to one token?
[21:43:15] <Ericson2314> no, one token tree, not a forest
[21:43:50] <eddyb> sure, but 1 + 1 is a forest
[21:44:31] <Ericson2314> so by default the macro would implicity package top level into a tree
[21:44:33] <eddyb> you'd have to put parens around it if you were expanding it with $* instead of an expression
[21:44:33] <Ericson2314> see http://docs.racket-lang.org/reference/quasiquote.html#%28form._%28%28quote._~23~25kernel%29._unquote-splicing%29%29
[21:44:48] <eddyb> Ericson2314: there is no such thing in Rust
[21:44:51] *** Joins: yjv_ (yjv@moz-cea.153.153.50.IP)
[21:45:02] <Ericson2314> I know, I am saying there should be
[21:45:17] <Ericson2314> (the splicing vs non-splicing part, not full quasi quoting)
[21:45:25] <eddyb> could you nest it?
[21:45:48] <eddyb> because now you have a tree of magical undelimited sequences of tokens
[21:46:05] <eddyb> s/now/after that
[21:46:32] *** Joins: yjv__ (yjv@moz-cea.153.153.50.IP)
[21:47:00] <Ericson2314> http://is.gd/oI1pFy parsing it as one expr, and not some sort of list of exprs, is analogous to non-splicing
[21:47:20] <Ericson2314> eddyb did you say ( [ { aren't actually tokens
[21:47:29] <Ericson2314> they just create different types of nodes in the token tree?
[21:48:03] <eddyb> Ericson2314: the lexer emits them but they're matched directly, and used in building token-trees
[21:48:16] <eddyb> Ericson2314: yeah, there's 3 kinds of sequence token-trees
[21:48:17] <Ericson2314> so like "data TT = Paren [TT] | Brace [TT] | Bracket [TT]"
[21:48:23] *** Joins: eljay (eljay@moz-fmte10.skybroadband.com)
[21:49:07] *** Quits: yjv_ (yjv@moz-cea.153.153.50.IP) (Ping timeout: 121 seconds)
[21:49:11] <eddyb> more like data TT = Single Token | Seq (Paren | Brace | Bracket) [TT]
[21:49:22] <Ericson2314> ok yeah that is nicer
[21:49:52] *** Joins: yjv_ (yjv@moz-v5s4ts.fios.verizon.net)
[21:49:56] <eddyb> Ericson2314: so in your example, what you have there is three tokens, parsed as one expression
[21:50:26] <Ericson2314> so, for token-tree macros, I would parse it as a Seq ?
[21:50:36] <eddyb> what?
[21:50:45] <eddyb> there's no sequence there
[21:50:53] <eddyb> it's a token stream
[21:51:14] <eddyb> Lit(1), BinOp(Plus), Lit(1) or something like that
[21:51:25] <Ericson2314> http://is.gd/wOGx2r
[21:51:27] *** Quits: yjv__ (yjv@moz-cea.153.153.50.IP) (Ping timeout: 121 seconds)
[21:51:39] <eddyb> Ericson2314: no, the braces are part of macro_rules
[21:51:57] <eddyb> you can use any delimiters there
[21:52:13] <eddyb> they're completely ignored and the contents are expanded into a stream
[21:52:13] <Ericson2314> sure today, but that is how I would interpret it in new macro system
[21:52:58] <eddyb> Ericson2314: so if you would use it as expression it would generate a block?
[21:53:41] <Ericson2314> yeah
[21:53:53] <Ericson2314> if you want, there can be a fourth kind of Seq
[21:53:59] <eddyb> undelimited?
[21:54:04] <eddyb> I'm sorry, that's too magical
[21:54:19] <Ericson2314> well that can be used for macro rules, and for top level
[21:54:31] <Ericson2314> so file is not a token forest
[21:55:12] <eddyb> also, how do you expand to a single expression?
[21:55:26] <eddyb> () => 1 + 1
[21:55:28] <eddyb> like that?
[21:55:51] <eddyb> what if ; is part of your expansion?
[21:55:51] <Ericson2314> like how does the TT get parsed into an expression?
[21:56:22] <eddyb> Ericson2314: the macro you have there produces 3 tokens, Lit(1), BinOp(Plus) and Lit(1)
[21:56:24] <eddyb> nothing more
[21:56:30] <Ericson2314> this would be for token-tree macros only, so parsing happens after macro expansion
[21:56:47] <Ericson2314> if you have a token tree with ';' in the middle, it will not parse to a single expression
[21:57:15] <eddyb> Ericson2314: ; delimits the cases of a macro_rules macro
[21:57:34] <eddyb> (the parser produces an ExprBinOp(Plus, ExprLit(1), ExprLit(1)), more or less, out of those 3 tokens)
[21:58:15] <eddyb> Ericson2314: http://is.gd/NpXqMZ
[21:58:28] <Ericson2314> yeah (Seq Default ['1', '+', '1']) parses to that
[21:58:29] *** Joins: p1start (p1start@moz-nftjhe.org)
[21:59:11] <eddyb> Ericson2314: but the top-level is not a sequence, it's a stream :/
[21:59:41] <eddyb> the parser also never sees sequences
[21:59:52] <Ericson2314> well if you have 'Seq Default', top level can be single tree
[21:59:55] <Ericson2314> without that
[22:00:04] <Ericson2314> [TT] => [Decls]
[22:00:34] <eddyb> tokenization is lazy, other than for macro invocations
[22:00:49] <eddyb> so you can't just use your Seq Default in most cases
[22:01:07] <eddyb> it's more or less a peekable Iterator<Item = (Token, Span)>
[22:01:48] <eddyb> though the Parser has its own peeking logic so just an Iterator could work
[22:02:05] <Ericson2314> on a different note, cannot fully respect token tree as we have f(arg), not (f arg)
[22:03:19] <Ericson2314> having token-tree building after tokenization as it's own phases neccessarily removes some laziness
[22:04:24] <eddyb> you could run the lexer in a delimiter-matching mode and only record the span
[22:04:40] <eddyb> you'd have to measure the impact on memory and time
[22:04:53] *** Joins: harrisonclarke (harrisoncla@moz-uur7pt.eastlink.ca)
[22:06:01] <Ericson2314> is crazy tree-node-granularity caching for rustc in the works? if so I'd use that as an excuse to temporary regress on performance
[22:06:13] <eddyb> caching?!
[22:06:23] <eddyb> of what?
[22:07:10] <Ericson2314> passes on IR maybe? I read about this somewhere as a semi-pipe-dream
[22:07:20] <eddyb> I expect not storing token trees to be more efficient in some regards, though you'd still need to store hygiene marking operations to be performed after parsing (or during parsing)
[22:07:37] <eddyb> Ericson2314: how does that relate to macro expansion, or the AST at all
[22:08:20] <Ericson2314> it doesn't. Just saying performance gains in one area compensate for regression in another
[22:09:00] *** Quits: eljay (eljay@moz-fmte10.skybroadband.com) (Quit: Leaving)
[22:09:08] <Ericson2314> anyways, so parser for Foo (i.e. expr, or decl, or whatever) can be TT -> [Foo]
[22:09:31] <Ericson2314> that will allow for C's fun(arg) stuff
[22:11:14] <Ericson2314> The convention is Seq Default doesn't endow meaning (unlike blocks turning lvalues into rvalues), but constrains parsing
[22:11:54] <eddyb> but why
[22:12:14] <Ericson2314> to prevent those precedence problems
[22:13:01] <eddyb> Ericson2314: but those are problems in contexts where you wouldn't usually want splicing
[22:13:07] <Ericson2314> patterns
[22:13:08] <eddyb> or unquoting, rather
[22:13:14] <eddyb> Ericson2314: can you exemplify?
[22:13:19] <Ericson2314> (Foo (Bar, Baz))
[22:13:29] <Ericson2314> (Foo Bar, Baz)
[22:13:49] <Ericson2314> if asdf!() = Bar, Baz
[22:14:12] *** Quits: munksgaard (munksgaard@moz-urnkl5.u.parknet.dk) (Ping timeout: 121 seconds)
[22:14:26] <Ericson2314> and you do (Foo $*asdf!())
[22:14:45] <Ericson2314> hmm, haskell syntax getting me down
[22:14:46] <eddyb> most of that doesn't look like valid syntax
[22:14:54] <Ericson2314> asdf!() = (Bar), Baz
[22:15:13] <Ericson2314> you want (Foo ((Bar), Baz))
[22:15:27] <Ericson2314> not (Foo (Bar), Baz)
[22:15:55] <Elaine> r? https://github.com/rust-lang/rust/pull/26809
[22:16:02] <Ericson2314> I forget if (Bar) == (Bar,), but regardless there is a problem
[22:16:13] <eddyb> Ericson2314: they aren't equal
[22:16:39] *** Joins: amphibulus (Mibbit@moz-hu6.nja.252.72.IP)
[22:16:46] <eddyb> Ericson2314: oh, you mean asdf!() => (Bar), Baz
[22:16:55] <Ericson2314> yes
[22:17:03] <eddyb> and used as (Foo $*asdf!())
[22:17:18] <eddyb> that could ever produce (Foo ((Bar), Baz)) in Rust
[22:17:25] <eddyb> it's not a sane choice
[22:17:35] <eddyb> you're adding parantheses out of thin air
[22:17:49] <eddyb> *never
[22:18:28] <Ericson2314> well this part is opinion, but it strikes me as the *only* sane choice
[22:18:37] <eddyb> it's magic
[22:18:44] <Ericson2314> and the unquote form is used where you need to opt out of the sanity
[22:19:06] *** Quits: yjv_ (yjv@moz-v5s4ts.fios.verizon.net) (Connection closed)
[22:19:06] <Ericson2314> it's not magic, because that is what Seq Default is there for
[22:19:11] <eddyb> yes it is
[22:19:18] <eddyb> you're making Seq Paren from Seq Default
[22:19:25] *** Quits: amphibulus (Mibbit@moz-hu6.nja.252.72.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[22:19:47] <eddyb> Ericson2314: in pattern-parsing, this wouldn't work at all
[22:20:25] <Ericson2314> parser will see (Seq Default (Token 'Bar', some-TT))
[22:20:43] <eddyb> as you're not parsing the Seq Default as a single node
[22:21:20] <eddyb> worst case, you bail if there's more than a single token
[22:21:49] <Ericson2314> why not force parcing Seq Default as single node?
[22:21:54] <eddyb> there's no node
[22:22:18] <eddyb> in a Foo(a, b) pattern, the only nodes are a, b and Foo(a, b)
[22:22:26] <eddyb> Foo is not a node and (a, b) is not a node
[22:22:29] *** Quits: annodomini (lambda@moz-qgii5v.ma.comcast.net) (Client exited)
[22:23:04] <Ericson2314> isn't it (tuple-struct-pattern Foo [a, b]) ?
[22:23:08] <eddyb> no
[22:23:18] <eddyb> Ericson2314: well, depends what you mean
[22:23:49] <eddyb> Ericson2314: but you previously assunmed $*asdf!() would correspond to a node
[22:24:00] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[22:24:00] *** ChanServ sets mode: +ao erickt erickt
[22:24:02] <eddyb> although it was expanding to a portion of a node
[22:24:06] <eddyb> playbot: macro_rules! good { () => (let _ = 0) } good!();
[22:24:07] -playbot- ()
[22:24:21] <eddyb> playbot: macro_rules! bad { () => (let _ = 0; 0;) } bad!();
[22:24:22] -playbot- ()
[22:24:29] <eddyb> actually, yeah, we support multiple statements
[22:24:36] <eddyb> playbot: macro_rules! bad { () => (let _ = 0; 0;) } bad!()
[22:24:37] -playbot- <anon>:9:35: 9:38 error: expected identifier, found keyword `let`
[22:24:37] -playbot- <anon>:9         macro_rules! bad { () => (let _ = 0; 0;) } bad!()
[22:24:37] -playbot- output truncated; full output at: http://bit.ly/1H1guej
[22:24:46] <eddyb> playbot: macro_rules! bad { () => (if false {} 0;) } bad!()
[22:24:47] -playbot- <anon>:9:47: 9:48 error: macro expansion ignores token `0` and any following
[22:24:48] -playbot- <anon>:9         macro_rules! bad { () => (if false {} 0;) } bad!()
[22:24:48] -playbot- output truncated; full output at: http://bit.ly/1HG1b0c
[22:24:52] <eddyb> Ericson2314: ^^
[22:25:14] <eddyb> that's a sane solution for non-splicing
[22:25:25] <eddyb> if you want the extra error-checking
[22:25:37] <eddyb> but it wouldn't have different semantics
[22:25:46] <Ericson2314> still reading that
[22:25:49] <Ericson2314> but to refine my example
[22:26:11] <Ericson2314> it should parse as Foo((a, b))
[22:26:14] <eddyb> (it's parsing an expression and the expression is just if false {}, everything afterwards cannot be used)
[22:26:44] <eddyb> Ericson2314: for that you would need two ( and two ) in the source
[22:26:56] <eddyb> creating them out of thin air is unfaithful to the source
[22:27:29] <eddyb> (I guess multiple macro expansions could generate them, but still, you would need each of them to come from literal ( and ) in the source
[22:27:30] <eddyb> )
[22:27:58] <eddyb> Ericson2314: keep in mind (a, b) and [a, b] are both valid patterns
[22:28:02] <eddyb> which one do you choose?
[22:28:04] <Elaine> Eugh, bitflags is now causing a ton of dead code lints to trigger in its `dummy` module and I can't figure out how to shut them up. #[allow(dead_code)] doesn't do it.
[22:28:13] <Elaine> is macro expansion lint level tracking broken?
[22:28:23] <eddyb> Elaine: can you gist it?
[22:28:36] <eddyb> or even better, put it on playpen (the two are not mutually exclusive nowadays :D)
[22:28:36] <Elaine> the bitflags macro?
[22:28:38] <eddyb> yeah
[22:28:45] <eddyb> hopefully it's still all in one file
[22:29:25] <Ericson2314> err wait
[22:29:42] <Ericson2314> I make a bad argument keeping on changing my mind....
[22:29:59] *** Quits: johnsoft (johnsoft@moz-69mrig.res.rr.com) (Ping timeout: 121 seconds)
[22:30:23] <eddyb> oh look https://github.com/rust-lang/rfcs/pull/1190
[22:30:31] <eddyb> finally a chance to bikeshed where clause style
[22:31:52] <Ericson2314> (Foo(Bar, Baz), Foo(Bar, Baz))
[22:32:36] *** Quits: bjz (bjz@moz-puppgq.tpgi.com.au) (Quit: My Mac has gone to sleep. ZZZzzz…)
[22:32:39] <Ericson2314> lexTT=> Seq Paren [Foo, Seq Paren [Bar, Baz], Foo, Seq Paren [Bar, Baz]]
[22:34:22] *** Joins: A205B064 (A205B064@moz-9s9nhk.nap.wideopenwest.com)
[22:34:33] <Ericson2314> parse=> Tuple-Pat [Struct-Pat Foo [Bar, Baz], Struct-Pat Foo [Bar, Baz]]
[22:36:19] *** Joins: johnsoft (johnsoft@moz-69mrig.res.rr.com)
[22:36:24] <Elaine> eddyb: it only triggers x-crate
[22:36:38] <Elaine> but the current state is https://play.rust-lang.org/?gist=5278e362c190dae5d967&version=stable
[22:37:12] <eddyb> Ericson2314: lexing is lazy
[22:37:25] <eddyb> I guess lexTT is lex . parseTT
[22:37:29] <Ericson2314> yeah
[22:37:58] <eddyb> so that output looks reasonable
[22:38:13] <Ericson2314> so parseTT can combine multiple TTs into one parse node
[22:38:21] <Ericson2314> but it cannot split a parse node
[22:40:08] <Ericson2314> *split a TT
[22:40:44] <Ericson2314> what's confusing is paren is used both as ambiguity resolver, and indicator of Struct-Pat
[22:41:04] <Ericson2314> Seq Default can only be used as ambiguity resolver
[22:41:05] *** Quits: harrisonclarke (harrisoncla@moz-uur7pt.eastlink.ca) (Connection closed)
[22:41:46] <Ericson2314> I suppose Seq Paren makes Tuple-Pat two, so it is used in three ways, yikes
[22:42:39] <Ericson2314> so Seq Default [Foo, ',', Bar] // I forgot commas before
[22:42:44] <Ericson2314> just won't parse
[22:43:26] <WindowsBunny> eddyb: I am opposed to all the styles mentioned there
[22:43:29] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[22:43:30] <WindowsBunny> I prefer my own style
[22:43:36] <eddyb> I just commented
[22:43:38] <Elaine> WindowsBunny: so ignore the style guidelines.
[22:43:50] <eddyb> I really don't like { on its own line
[22:43:51] <WindowsBunny> Elaine: But what if I want to contribute to Rust itself D:
[22:43:52] <Ericson2314> unless we want to say ',' really creates the tuple, and the paren is just for ambiguity
[22:43:56] <Elaine> Then get over yourself?
[22:44:10] <WindowsBunny> Elaine: meanie
[22:44:29] <eddyb> Ericson2314: , is there for ambiguity!
[22:44:32] <eddyb> well, trailing ,
[22:44:38] <eddyb> (a,) is a 1-tuple
[22:47:43] <Ericson2314> well, can't one view that as ',' makes tuples, and final ',' is sometimes but not always safe to drop?
[22:47:55] <eddyb> () is a tuple
[22:47:58] *** Quits: brson (brson@moz-cfhap5.mtv2.mozilla.com) (Quit: leaving)
[22:48:01] <Ericson2314> shit :)
[22:48:07] <eddyb> 100% parens, 0% commas
[22:48:39] *** Joins: njn (chatzilla@moz-270n86.iinet.net.au)
[22:50:19] <Ericson2314> so then I can't think of a single case in patterns where () is just used for ambiguity
[22:50:54] *** Joins: yjv_ (yjv@moz-ll38tk.pa.comcast.net)
[22:50:58] *** Quits: yjv_ (yjv@moz-ll38tk.pa.comcast.net) (Connection closed)
[22:51:10] <Ericson2314> so if foo!() => Seq Default [A, ',', B]
[22:51:28] *** Joins: yjv_ (yjv@moz-ll38tk.pa.comcast.net)
[22:51:30] <Ericson2314> [x, y, $*foo!()] is an error
[22:51:53] <Ericson2314> because no parens for tuple, nor implicit splice
[22:52:14] <Ericson2314> [x, y, $@*foo!()] => [x, y, A, B]
[22:52:28] <eddyb> Ericson2314: I would be fine with having it an error for now
[22:52:41] *** Joins: rkruppe (chatzilla@moz-lk3vdu.diu2.0rth.0908.2a02.IP)
[22:52:41] <eddyb> and lifting the limitation later if necessary
[22:52:53] <Ericson2314> [x, y, ($*foo!())] => also an error
[22:52:57] <Ericson2314> cool
[22:53:15] <eddyb> (we can do that by requiring foo in $*foo!() expands to exactly a single token)
[22:53:19] <eddyb> actually
[22:53:25] <eddyb> Ericson2314: that makes the implementation easier
[22:53:32] <Ericson2314> [x, y, ($@*foo!())] => [x, y, (A, B)]
[22:53:48] <Ericson2314> does that work for all of those?
[22:54:08] <eddyb> does what work?
[22:54:17] <Ericson2314> exapanding to a "single token"
[22:54:28] <Ericson2314> what is a single token?
[22:54:40] <eddyb> a token-tree leaf
[22:55:13] <eddyb> which can embed most AST nodes (for $x in macros)
[22:55:41] <Ericson2314> oh weird, tokens can contain TTs?
[22:55:56] <eddyb> (doing splicing of more than one token requires the same machinery as $($multi_tt)*, which currently only works in a macro invocation, so you have that expr!(...) workaround)
[22:56:19] <eddyb> Ericson2314: yes, but they aren't expanded directly, only when used inside another macro invocation
[22:56:42] <Ericson2314> ah, so token / token tree is basically Seq Default
[22:56:48] <eddyb> it's a current limitation of the transcribe implementation
[22:56:54] <eddyb> Ericson2314: no, because it's a single node
[22:57:02] <eddyb> single token-tree node, I mean
[22:57:10] <eddyb> it's not like a forest
[22:57:23] <Ericson2314> (Seq Default [...]) is a node too
[22:57:32] <eddyb> except Default isn't a thing right now
[22:57:52] <eddyb> playbot: macro_rules! give_me { ($x:tt) => ($x) } give_me!(5)
[22:57:53] -playbot- <anon>:9:44: 9:46 error: unexpected token: `5`
[22:57:53] -playbot- <anon>:9         macro_rules! give_me { ($x:tt) => ($x) } give_me!(5)
[22:57:53] -playbot- output truncated; full output at: http://bit.ly/1CUIput
[22:58:33] <eddyb> playbot: macro_rules! expr { ($x:expr) => ($x) } macro_rules! give_me { ($x:tt) => (expr!($x)) } give_me!(5)
[22:58:34] -playbot- 5
[22:58:37] <Ericson2314> I think it's isomorphic
[22:59:08] <Ericson2314> TT<BaseToken> + Seq Default [TT] =ISO= TT<BaseToken + TT>
[22:59:39] <eddyb> the tokens wrapping "non-terminals" are intended to be used as soon as what's inside them is needed
[23:00:47] <Ericson2314> also should be TT<BaseToken + [TT]> right?
[23:00:59] <eddyb> no idea what <> is in your case
[23:01:16] <eddyb> if applying a type param, how are you using unapplied TT in other places?
[23:01:16] <Ericson2314> rose tree paramterized with token type
[23:01:18] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[23:01:18] *** ChanServ sets mode: +ao erickt erickt
[23:01:23] <eddyb> Ericson2314: ouch
[23:01:32] <Ericson2314> sorry for change of notation
[23:01:56] <eddyb> I didn't expect it to be something fancy, but you were using Haskell notation already
[23:02:06] <eddyb> Haskell with LISPy names?
[23:02:37] <Ericson2314> ok true, that was way more evil than I intended
[23:03:30] <Ericson2314> I was going to do TT with explicit subst for Token with Token ++ [TT], so as to not redefine TT, but I figured THAT would be the evilist
[23:03:59] <Ericson2314> but anways (I should get going soon), the token tree token contains a forest, right?
[23:04:03] <eddyb> Ericson2314: nope
[23:04:07] <eddyb> a single token-tree
[23:04:58] <Ericson2314> ok, so then it is not quite isomorphic
[23:04:59] <eddyb> in the $($multi_tt)* example above, the definition would be something like $($multi_tt:tt)*, i.e. a repetition
[23:05:09] <eddyb> Ericson2314: no, it's just packing
[23:05:25] *** Joins: harrisonclarke (harrisoncla@moz-uur7pt.eastlink.ca)
[23:05:52] <Ericson2314> the dirty thing you can do with Seq Default, is Seq Default [A, ',', B]
[23:06:23] *** Joins: smkz (a@moz-gdd4un.fs1g.619c.a880.2604.IP)
[23:06:24] <Ericson2314> can be turned into struct pattern Foo(A, B), or tuple-pat (A,B), or Array-pat [A, B]
[23:06:58] <Ericson2314> (with appropriate splicing)
[23:07:47] <Ericson2314> wait, but can still splice-away concrete delimitor and do the same thing, never mind :)
[23:08:42] <eddyb> you mean Foo(a $*comma!() b)?
[23:09:49] *** Joins: Pierre_M (Pierre_M@moz-2vs15r.slkc.qwest.net)
[23:09:51] <eddyb> hmm, I didn't consider the case where foo!() produces (a, b) in &*foo!(). it's not a single terminal (leaf) token, it's a token-tree
[23:10:12] <eddyb> single-token-tree expansion could probably be enforced
[23:11:43] <eddyb> Ericson2314: but I treat this as error-checking, not separate functionality
[23:12:17] *** Quits: Pierre_M (Pierre_M@moz-2vs15r.slkc.qwest.net) (Connection closed)
[23:12:37] <Ericson2314> in your error checking model,
[23:12:58] <Ericson2314> you need to wrap multiple tokens in a delimiter of your choice
[23:15:03] <eddyb> and you're denied splicing
[23:15:37] <eddyb> in the pattern case, Foo $*tuple!(a, b) would work if tuple!(a, b) produces (a, b)
[23:15:39] <Ericson2314> well, there should be a seperate $*@ for splicing, right?
[23:15:44] <eddyb> but only because it's a delimited sequence
[23:16:05] <eddyb> Ericson2314: I am hoping that either splicing is unnecessary or error-checking is unnecessary
[23:16:15] <eddyb> I really don't want $*@
[23:16:34] *** Joins: Kingsquee (kingsley@moz-k72lip.bchsia.telus.net)
[23:16:44] <Ericson2314> well [1, 2, $*three-four!(), 5] still has it's uses
[23:16:46] <eddyb> it's no my decision, but $* already feels *slightly* too verbose
[23:16:56] <eddyb> *not my
[23:17:04] *** Joins: Rym (uid91135@moz-n2i7qm.charlton.irccloud.com)
[23:17:37] <Ericson2314> $macro! $macro@ ?
[23:18:17] *** Quits: harrisonclarke (harrisoncla@moz-uur7pt.eastlink.ca) (Connection closed)
[23:20:19] <Rym> I've got code which compiles fine on 1.0, stable(1.1), and nightly(1.3), but fails to compile on beta(1.2). Is this a known issue which has already been fixed for 1.3? code: http://is.gd/cQJ1Xk 
[23:23:04] *** Joins: Pierre_M (Pierre_M@moz-2vs15r.slkc.qwest.net)
[23:24:15] <Ericson2314> also eddyb, if we make make an Iterator-like thing where the item borrows the iterator
[23:24:37] <Ericson2314> we can lazily parse token trees:
[23:25:09] *** Quits: rovar (rovar@moz-96effg.dyn.optonline.net) (Ping timeout: 121 seconds)
[23:25:31] <Ericson2314> when ( [ { is reached, a new quasi-iterator is yielded
[23:25:43] <Ericson2314> and it must be consumed before you get the old one back
[23:26:05] <nagisa> Rym: given it works on 1.3, it must be fixed by now
[23:26:24] <nagisa> not sure which PR did fix it, but if you find it, you should request it to be backported
[23:29:32] <Rym> nagisa: yeah, that's what I thought, I had a glance through PRs merged in the last 3-4 weeks last night and couldn't find anything obvious. Kinda just hoping someone else knows, if not I guess I should file it to bring some awareness? 
[23:30:09] <nagisa> Rym: I would ask around again after once monday sun rises over at the americas
[23:30:14] <nagisa> err
[23:30:23] <nagisa> s/after//
[23:31:26] <nagisa> also, yes, fill a bug
[23:31:32] <nagisa> that’d be the best I guess
[23:32:01] *** Joins: harrisonclarke (harrisoncla@moz-uur7pt.eastlink.ca)
[23:32:38] <Rym> nagisa: Yeah I think that's easier, was just checking the waters so I wasn't going to file a well known issue. Thanks :)
[23:37:51] *** Joins: rovar (rovar@moz-96effg.dyn.optonline.net)
[23:37:56] *** Quits: ELD (textual@moz-tbcsac.co.comcast.net) (Quit: Textual IRC Client: www.textualapp.com)
[23:41:20] *** Quits: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua) (Ping timeout: 121 seconds)
[23:43:33] *** Quits: rkruppe (chatzilla@moz-lk3vdu.diu2.0rth.0908.2a02.IP) (Ping timeout: 121 seconds)
[23:45:18] *** Quits: harrisonclarke (harrisoncla@moz-uur7pt.eastlink.ca) (Connection closed)
[23:51:39] *** Quits: blank_name (blank_name@moz-crs.fli.183.192.IP) (Ping timeout: 121 seconds)
[23:51:58] *** Quits: smkz (a@moz-gdd4un.fs1g.619c.a880.2604.IP) (Quit: x)
[23:52:04] *** Joins: smkz (a@moz-gdd4un.fs1g.619c.a880.2604.IP)
[23:58:01] *** Joins: blank_name (blank_name@moz-r8p.iv2.183.192.IP)

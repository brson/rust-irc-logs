[00:05:23] <cmr> Seldaek: Well, updates json is in http://octayn.net/benches/
[00:12:32] <cmr> You tell /me/ if it's super ugly
[00:12:34] <cmr> I think it is..
[00:12:37] <cmr> especially attributes
[00:12:55] <cmr> [EnumVariantNameAsAString, [EnumFields]]
[01:04:11] <Seldaek> cmr: will take a quick look
[01:05:21] <Seldaek> had a quick chat and ended up booking a flight to amsterdam in 3 weeks.. from zero to flight booked in 30min is a first :|
[01:05:28] <cmr> wow
[01:06:09] <Seldaek> you put them in the same file names as before right?
[01:06:11] <cmr> yes
[01:06:30] <Seldaek> gee 36mb of json after formatting :p
[01:06:45] <cmr> it's only 3.7MB un-pretty-printed
[01:06:50] <cmr> "only"
[01:07:06] <cmr> 388K compressed, which is nice
[01:07:09] <Seldaek> yeah there's 90% whitespace
[01:07:23] <Seldaek> with the 20 level indents:p
[01:07:52] <Seldaek> well
[01:08:11] <Seldaek> I'm not generally so difficult with json structures because it's easy to remodel them in both js and php
[01:08:18] <Seldaek> but I gotta admin, there is some nasty shit there :)
[01:08:38] <Seldaek> [ "something", { ... } ] is particularly messed up
[01:08:44] <cmr> yeah
[01:08:46] <cmr> it really is
[01:08:53] <Seldaek> s/admin/admit
[01:09:15] <cmr> OTOH
[01:09:25] <cmr> Every item is now of a single "shape"
[01:09:36] <Seldaek> yes..
[01:10:10] <cmr> if it weren't for attributes and items having a wonky structure, it'd be fine
[01:10:43] <Seldaek> I  do wonder though, is "inner" always this str + obj structure?
[01:11:00] <cmr> yep
[01:11:04] <cmr> it's an enum in rust
[01:11:13] <cmr> ModuleItem(Module), or StructItem(Struct), for example
[01:11:19] <Seldaek> because if it is, having it as: "inner": { "type": "EnumItem", "def": {} } would be a bit nicer
[01:11:24] <cmr> Yes definitely
[01:11:26] <Seldaek> just less freakish
[01:11:28] <cmr> but there's nothing I can do about it :p
[01:11:49] <Seldaek> dare I say this sounds like a pretty awful language failure ? :)
[01:12:08] <cmr> it's not the language's fault, just a really meh library
[01:12:26] <Seldaek> I realize fiddling with json isn't easy in statically typed languages
[01:12:36] <Seldaek> but yeah, surely this is fixable with decent lib support
[01:12:36] <cmr> it was fine when I was doing my own serialization
[01:12:40] <cmr> this is just auto-derived stuff
[01:13:06] <Seldaek> can't we change the enum deriving? :p
[01:13:17] <cmr> not generically no
[01:13:20] <Seldaek> I mean does this thing ever make sense as an array? it's pretty weird
[01:13:37] <cmr> EnumVariant(foo, bar, baz)
[01:13:49] <cmr> I just always have one-item variants.
[01:14:13] <Seldaek> so that'd produec ["EnumItem", {}, "EnumItem", {}, ..] ?
[01:14:39] <cmr> No, ["EnumVariant", {}, {}, {}]
[01:14:46] <Seldaek> ok
[01:15:16] <Seldaek> still, changing it to {"type": "EnumVariant", "definitions": [ {}, {}, ...]} would be better
[01:15:21] <Seldaek> and still generically flexible
[01:15:32] <cmr> I guess
[01:15:34] <cmr> send a PR :p
[01:15:38] <Seldaek> having an array of different types is really borked
[01:15:46] <Seldaek> and messes with JS JIT
[01:16:08] <Seldaek> where is that code? :)
[01:16:22] <cmr> src/libextra/json.rs
[01:16:33] <cmr> The emit_enum_variant method of Encoder, I believe
[01:16:59] <Seldaek> oh that doesn't look too bad :)
[01:17:27] <Seldaek> well, for a definition of not bad where string-concatenating json is ok :p
[01:17:30] <cmr> it took me a bit to wrap my head around it, and then figure out the Decoder interface didn't support what I wanted to do :\
[01:18:26] <Seldaek> what would be good names for type and definition in {"type": "EnumVariant", "definitions": [ {}, {}, ...]}
[01:18:32] <Seldaek> I guess type= variant 
[01:18:41] <cmr> "variant": "", "fields": []
[01:18:46] <Seldaek> ok
[01:18:56] <Seldaek> I didn't get this was only for enums at first..
[01:19:05] <cmr> And... for struct-like variants, fields can be an object I think
[01:20:41] <Seldaek> I kinda think it's bad that every second .rs file in libstd/libextra is thousands of lines long
[01:20:50] <Seldaek> don't know if it's just me
[01:20:51] <cmr> they're all really old
[01:20:53] <cmr> grown by accretion
[01:21:04] <cmr> well, except iterator.rs
[01:24:12] <Seldaek> well anyway yes this weekend I can PR that enum variant wreck:p
[01:24:17] <Seldaek> if you don't do it until then
[01:24:29] <Seldaek> and if I feel like wasting hours compiling:)
[01:24:36] <cmr> Sure, I can do it
[01:24:55] <Seldaek> IMO having an object would make it more readable and less "awkward"
[01:25:17] <Seldaek> it's a small change but if this ends up being the standard way of serializing rust stuff, it's worth fixing I think
[01:25:36] <cmr> I hope it doesn't end up being the standard
[01:25:42] <Seldaek> hah
[01:26:08] <Seldaek> is the format that bad or just the lib API is not good?
[01:26:58] <cmr> API is not good for serializing to json
[01:27:19] <Seldaek> the attrs are the same enum issue?
[01:27:25] <cmr> yes
[01:27:29] <Seldaek> ok
[01:27:44] <cmr> for the attrs thing I want to encode it directly into a real JSON object
[01:27:58] <cmr> it's just a hashmap, really, with strings as keys and strings or lists of strings as values
[01:28:19] <Seldaek> yes there is hashmap support already in rust iirc
[01:28:38] <cmr> right, but you can't have a hashmap where the value can be two different types
[01:28:42] <Seldaek> if that serializes to json in a sane way, it should be good
[01:28:45] <cmr> at least, not without it encoding really weirdly :p
[01:28:58] <Seldaek> I see
[01:29:07] <cmr> you'd have to use Either
[01:29:16] <cmr> which is enum Either<T, U> { Left(T), Right(U) }
[01:29:21] <Seldaek> ouch
[01:29:28] <Seldaek> I don't want to know how that looks in json yeah
[01:29:46] <Seldaek> and if you chain them to have more than two types.. :)
[01:29:54] <cmr> yeah
[01:30:43] <Seldaek> anyway, I don't know, do what you can and the rest we'll work with it for now it's not so bad as long as it's generalized enough that changing it won't be a pain
[01:30:54] <Seldaek> I have to sleep 
[01:30:57] <cmr> sleep well
[01:31:06] <Seldaek> thanks, cya!
[01:31:10] <cmr> (we go to sleep at more or less the same time and we are ~7 hours apart, that's not right)
[01:31:17] <Seldaek> yeah
[01:31:22] <Seldaek> six I think
[01:31:32] <Seldaek> but I wake up at 10.. :p
[05:56:18] <dbaupp> cmr: pong
[14:54:04] <cmr> dbaupp: ping
[15:02:58] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[16:15:02] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[17:06:03] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[17:43:21] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[18:41:26] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[19:49:43] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Quit: Lost terminal)
[19:50:10] <Seldaek> setting up new router, faster IRC !!11
[22:12:40] <dbaupp> cmr: pong
[22:13:10] <cmr> dbaupp: hi! so, is it possible to customly implement Encodable/Decodable for Attribute to get the old {attrname: attrvalue} output?
[22:13:26] <cmr> Afaict you can't, since you can't "speculatively read" from a Decoder
[22:13:36] <dbaupp> maybe?
[22:13:38] <cmr> whichg you would need to do, to see which variant to decode
[22:13:48] <dbaupp> I've never used it my hand
[22:13:51] <dbaupp> *by hand
[22:13:54] <cmr> it'd be possible if it gave you JSON, but it's a too generic interface
[22:14:47] <dbaupp> could you change it to be slightly different, e.g. {"name": foo, "value": attrvalue}
[22:15:00] <dbaupp> (almost as nice, but probably possible?)
[22:15:08] <cmr> maybe

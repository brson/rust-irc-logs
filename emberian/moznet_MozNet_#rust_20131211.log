[00:00:22] <rossm> but you've just moved the responsibility from knowing this usage of 'cute' to knowing the usage of 'clever'
[00:00:27] <rossm> and neither are their literal meanings
[00:00:37] *** Quits: ricepuddin (graham@moz-7D68765A.cable.virginm.net) (Ping timeout)
[00:00:47] <strcat> rossm: http://en.wiktionary.org/wiki/cute
[00:00:49] <strcat> sure it is
[00:01:01] <zenon> In this reddit post larsberg refers to himself as being cute when writing the notes: http://www.reddit.com/r/rust/comments/1skkdl/x/cdyjzbn
[00:01:08] *** Joins: notmatt (notmatt@CC62CF7E.1E7FDFDB.A82DBDDB.IP)
[00:01:09] <zenon> what other word could be used there?
[00:01:18] <strcat> clever
[00:01:21] <rossm> impractical
[00:01:22] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[00:02:02] <strcat> zenon: cute has an association with something helpless/useless (babies, small creatures, obfuscated C)
[00:02:27] <hoverbear> strcat: Obfuscated js!
[00:02:49] <strcat> zenon: the 3rd definition there is his usage
[00:03:19] <strcat> english is weird I guess
[00:03:32] <pepper_chico> "oh this code is so cute, I need to take care of it"
[00:03:41] *** Quits: AvianFlu_ (AvianFlu@moz-723527FF.nycmny.fios.verizon.net) (Ping timeout)
[00:03:48] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Quit: yichoi)
[00:04:00] <hoverbear> pepper_chico: I hope you pinch it's cheeks after talking to it like that.
[00:04:02] <o11c> "it followed me home, can we keep it?" 
[00:04:09] <pepper_chico> haha
[00:04:37] <o11c> speaking of which, exuberant ctags is dead :(
[00:04:54] <strcat> o11c: use youcompleteme ;p
[00:05:09] *** Joins: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[00:05:15] <pepper_chico> I use ycm, never used exuberant ctags yet, but, dead?
[00:05:16] *** Quits: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Connection reset by peer)
[00:05:24] *** Joins: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[00:05:24] <pepper_chico> no support anymore?
[00:05:35] <o11c> I submitted a patch for feedback quite a while ago, not reply
[00:05:42] <pepper_chico> hmm
[00:05:52] <o11c> and I just want a tag file for jumping, not a completion engine
[00:05:55] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[00:06:04] <o11c> last release was in 2009
[00:06:09] <strcat> o11c: libclang can do that too
[00:06:24] <pepper_chico> maybe the supporters died
[00:06:26] <strcat> youcompleteme hasn't exposed it but there are other plugins with it afaik
[00:06:27] *** Joins: fyolnish (fyolnish@moz-9B00F25.uqwimax.jp)
[00:06:38] <strcat> and libclang can fetch doxygen docs
[00:06:57] <strcat> certainly better than cscope ;p
[00:06:59] <o11c> anyway, for now I just use my own patched version of exu-ctags
[00:07:38] <pepper_chico> ycm must implement some  stuff in that sense, I've opened an issue about argument completion to be somewhat like clang_complete
[00:07:50] <pepper_chico> but still, it's open
[00:07:57] <pepper_chico> for improvement
[00:08:11] *** Quits: fyolnish (fyolnish@moz-9B00F25.uqwimax.jp) (Ping timeout)
[00:08:16] <rossm> zenon often times in the context of programming (or perhaps problem-solving in general), "cute" can mean a focus on aesthetics at the cost of practicality. and "clever" can mean unnecessarily complicated, not straightforward.
[00:08:40] <strcat> they can mean that elsewhere too
[00:08:45] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[00:08:51] <rossm> zenon however they're also used in a way that rejects nuance. they're used dismissively when the person doesn't care to understand the details of the situation
[00:08:55] <pepper_chico> that stuff recalls me of c++
[00:09:02] *** Quits: ptc (Adium@moz-8F01578B.z72-46-65.customer.algx.net) (Quit: Leaving.)
[00:09:08] *** Joins: ptc (Adium@moz-8F01578B.z72-46-65.customer.algx.net)
[00:09:34] <rossm> usually if you see somebody referring to "clever" code, they're avoiding taking a hard look at the problem and rejecting it at a glance
[00:09:44] *** Joins: alan_andrade (Mibbit@moz-5AA4E9ED.hfc.comcastbusiness.net)
[00:09:47] <rossm> they're lazy words, in my opinion
[00:10:02] <alan_andrade> Hello
[00:10:29] <alan_andrade> I have this problem :  mismatched types: expected `~str` but found `&str` 
[00:10:42] <zenon> I'm not convinced. I would have said that "clever code" is good but "too clever code" is bad.
[00:10:50] <alan_andrade> This is fn that should return a string.
[00:10:51] <ChrisMorgan> alan_andrade: you can get a &str from a ~str with str.as_slice()
[00:10:52] *** Quits: ptc (Adium@moz-8F01578B.z72-46-65.customer.algx.net) (Ping timeout)
[00:10:56] <hoverbear> alan_andrade: Can you please https://gist.github.com/ the code?
[00:11:08] <hoverbear> nvm :S
[00:11:13] <alan_andrade> Mr @ChrisMorgan ! day and night
[00:11:19] <aatch> ChrisMorgan, wrong way round
[00:11:41] <ChrisMorgan> aatch: ?
[00:11:41] <strcat> zenon: clever has implications of being crafty/cunning
[00:11:44] *** Quits: pepper_chico (pepper_chi@6D1D0FAA.4F150827.E4090502.IP) (Quit: Ex-Chat)
[00:11:55] <aatch> expected '~str', found '&str'
[00:12:03] <alan_andrade> So @ChrisMorgan would you bare with me two seconds while I try to explain what I understand from what you just said ?
[00:12:03] <ChrisMorgan> Oops, yes.
[00:12:18] <zenon> strcat: not necessarily bad, is it?
[00:12:20] <ChrisMorgan> alan_andrade: sorry, where you've got a string slice and want an owned string, use `str.to_owned()`
[00:12:30] *** Quits: Hildar (Mibbit@moz-7F4621B6.cable.virginm.net) (Quit: http://www.mibbit.com ajax IRC Client)
[00:12:32] <strcat> zenon: not necessarily bad
[00:12:37] <ChrisMorgan> That will make a complete copy of the string.
[00:12:41] <sfackler> re-r anyone? was just missing a pub in the rpass test https://github.com/mozilla/rust/pull/10833
[00:12:42] <strcat> but saying something is 'too clever' is a common idiom
[00:12:42] *** Joins: Skif_ (emschwar@moz-CA025D57.ip.mcleodusa.net)
[00:12:46] <strcat> not just in programming
[00:12:51] <alan_andrade> ok, that worked :)
[00:13:12] <alan_andrade> but I still don't understand why I couldn't figured it out
[00:13:30] <strcat> you could say writing is too clever, if it's overly fancy/elaborate
[00:13:33] *** Quits: zxcdw (r-a@ACF33729.B543C4DE.3933CC16.IP) (Ping timeout)
[00:13:36] <alan_andrade> Do you have any analogy for pointers, ownerships ?
[00:13:48] <aatch> alan_andrade, some of it is in the tutorial.
[00:13:51] <alan_andrade> I always confuse &, *, ~, @
[00:13:54] *** Quits: Skif (emschwar@moz-CA025D57.ip.mcleodusa.net) (Ping timeout)
[00:14:03] <aatch> It's kind of difficult to succintly explain it though.
[00:14:07] <alan_andrade> @aatch yeah, I've read that over and over, I still don't get it.
[00:14:10] *** Joins: zxcdw (r-a@ACF33729.B543C4DE.3933CC16.IP)
[00:14:15] *** Joins: whidgle (Mibbit@moz-68235C3E.customer.broadstripe.net)
[00:14:24] *** Quits: Skif_ (emschwar@moz-CA025D57.ip.mcleodusa.net) (Ping timeout)
[00:14:31] <aatch> It's probably easier to just ask specific questions.
[00:14:34] <alan_andrade> and also I come from Ruby and JS, so this is really new for me. I feel ashamed for not knowing this.
[00:14:38] <alan_andrade> True.
[00:14:43] <alan_andrade> Let me see.
[00:14:53] <hoverbear> alan_andrade: I've been having the same issues, coming form JS
[00:15:02] <alan_andrade> let a = "abc"
[00:15:11] <alan_andrade> first of all. Is that possible ?
[00:15:13] <hoverbear> alan_andrade: You can have rusti run one liner code
[00:15:14] <alan_andrade> I don't see why not.
[00:15:18] <strcat> alan_andrade: yes
[00:15:18] <hoverbear> rusti: let a = "abc"
[00:15:20] -rusti- <anon>:10:4: 10:5 error: expected `;` but found `}`
[00:15:20] -rusti- <anon>:10     };
[00:15:20] <aatch> alan_andrade, it's fine. Coming from a dynamic language to Rust is going to be a big step because of how much is exposed.
[00:15:20] -rusti-               ^
[00:15:20] -rusti- application terminated with error code 101
[00:15:21] <dbaupp> rusti: let a = "abc"; a
[00:15:23] -rusti- "abc"
[00:15:30] *** Quits: Addle (quassel@93529591.BA907378.971E19F6.IP) (Ping timeout)
[00:15:30] <alan_andrade> there you go
[00:15:38] <strcat> alan_andrade: "foo" is a &str, which is a slice (ptr and length) - it's a view
[00:15:38] <alan_andrade> ok, then what the value of a ?
[00:15:50] <hoverbear> let a = "This is the value of a!"; a
[00:15:52] <alan_andrade> is it a pointer ? is the string
[00:15:54] <hoverbear> rusti: let a = "This is the value of a!"; a
[00:15:55] -rusti- "This is the value of a!"
[00:15:58] *** Quits: TimAbraldes (quassel@125EF623.B2666F0E.66399531.IP) (Input/output error)
[00:16:02] <strcat> alan_andrade: it's a slice (a pointer and a length)
[00:16:04] <aatch> alan_andrade, not really, it's a slice.
[00:16:11] <strcat> rusti: std::mem::size_of::<&int>()
[00:16:12] -rusti- pastebinned 11 lines of output: http://sprunge.us/QXOM
[00:16:23] <alan_andrade> @strcat wow wow, know I get what a slice is
[00:16:24] <strcat> rusti: std::sys::size_of::<&int>()
[00:16:26] -rusti- 8u
[00:16:28] <alan_andrade> s/know/now
[00:16:28] <strcat> rusti: std::sys::size_of::<&str>()
[00:16:29] -rusti- 16u
[00:16:48] *** Joins: Addle (quassel@93529591.BA907378.971E19F6.IP)
[00:17:06] <aatch> alan_andrade, by the way, I suggest ignoring '@' and '*' for now.
[00:17:17] <strcat> alan_andrade: &int is a view of an integer, &[T] is a view of a block of memory containing T elements
[00:17:22] <aatch> (that drops the sigils down to two)
[00:17:23] <zenon> can rust print the type of an expression?
[00:17:24] <hoverbear> rusti: let a = (1,2,3); a.max_by(|x| x)
[00:17:25] -rusti- <anon>:9:25: 10:5 error: type `(<VI0>,<VI1>,<VI2>)` does not implement any method in scope named `max_by`
[00:17:25] <strcat> &[T] isn't a regular &T
[00:17:25] -rusti- <anon>:9         let a = (1,2,3); a.max_by(|x| x)
[00:17:25] -rusti- <anon>:10     };
[00:17:25] -rusti- error: aborting due to previous error
[00:17:25] -rusti- application terminated with error code 101
[00:17:37] <hoverbear> rusti: let a = (1,2,3); a.iter().max_by(|x| x)
[00:17:38] -rusti- <anon>:9:25: 9:34 error: type `(<VI0>,<VI1>,<VI2>)` does not implement any method in scope named `iter`
[00:17:38] -rusti- <anon>:9         let a = (1,2,3); a.iter().max_by(|x| x)
[00:17:38] -rusti-                                   ^~~~~~~~~
[00:17:38] -rusti- error: aborting due to previous error
[00:17:38] -rusti- application terminated with error code 101
[00:17:40] <strcat> alan_andrade: and &str is just like &[u8] but with the guarantee that it points to a valid UTF-8 string
[00:18:05] <dbaupp> hoverbear: no iter on tuples
[00:18:10] <aatch> hoverbear, tuples don't implement much
[00:18:31] <hoverbear> How do tuple -> iter?
[00:18:37] <aatch> hoverbear, you don't
[00:18:38] <strcat> hoverbear: you can't - it doesn't make sense
[00:18:51] <strcat> hoverbear: a tuple is an aggregate of different types like a struct
[00:18:56] <hoverbear> Ah, ok.
[00:18:59] <hoverbear> That makes sense.
[00:19:02] <strcat> it's a struct without field names or a name-based type
[00:19:04] <aatch> Since you can have a tuple that is (int, ~str, ())
[00:19:19] <alan_andrade> @strcat when you say "is a view of an integer" what do you mean with "view" ?
[00:19:31] <strcat> alan_andrade: it doesn't own it
[00:19:32] <alan_andrade> Like... a representation ?
[00:19:35] <aatch> alan_andrade, so in rust, you either own some data, or you don't.
[00:19:38] <strcat> it points at memory stored *somewhere* else
[00:19:42] <hoverbear> let a = range(0,5); a.max_by(|x| x)
[00:19:49] <hoverbear> rusti: let a = range(0,5); a.max_by(|x| x)
[00:19:51] -rusti- pastebinned 8 lines of output: http://sprunge.us/gjOe
[00:20:22] <aatch> rusti: let a = range(0,5); a.max_by(|&x| x)
[00:20:23] -rusti- <anon>:9:28: 9:29 error: cannot borrow immutable local variable as mutable
[00:20:23] -rusti- <anon>:9         let a = range(0,5); a.max_by(|&x| x)
[00:20:24] -rusti-                                      ^
[00:20:24] -rusti- error: aborting due to previous error
[00:20:24] -rusti- application terminated with error code 101
[00:20:34] <aatch> rusti: let mut a = range(0,5); a.max_by(|&x| x)
[00:20:35] -rusti- Some(4)
[00:20:41] *** Joins: ofeldt- (ofeldt@moz-DB0CBEF.dip0.t-ipconnect.de)
[00:20:49] <alan_andrade> what would be the opposite of "view" ? 
[00:20:56] <hoverbear> aatch: I don't really want it mutable
[00:21:02] <aatch> hoverbear, no choice.
[00:21:03] *** Quits: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com) (Ping timeout)
[00:21:07] <strcat> alan_andrade: I wouldn't really say there is an opposite
[00:21:10] <strcat> let x = 5;
[00:21:14] <aatch> iterators mutate
[00:21:16] <strcat> `x` is as big as the int
[00:21:27] <strcat> alan_andrade: have you read the tutorial coverage of writing a linked list?
[00:21:31] <aatch> Because they have internal state.
[00:21:38] <strcat> alan_andrade: http://static.rust-lang.org/doc/master/tutorial.html#implementing-a-linked-list I think it does a good job explaining this
[00:21:46] <dbaupp> aatch, hoverbear: "iterator *consumers* mutate"
[00:21:52] *** Quits: ofeldt (ofeldt@moz-52873563.dip0.t-ipconnect.de) (Ping timeout)
[00:22:17] <dbaupp> iterator methods like, foo.enumerate() move foo, rather than mutating it
[00:22:22] <alan_andrade> @strcat I have, but notation most of the time I don't really get it. Also terms I haven't heard before, so it's kinda hard. but yeah, I'm putting some practice there
[00:22:25] <strcat> hoverbear: to move an iterator forwards, you mutate it, it doesn't mean the iterator can mutate the thing it's giving you references over
[00:23:20] <aatch> alan_andrade, it might be worthwhile studying up on pointers in general and getting a better feel for how systems-level programming works in general.
[00:23:36] <hoverbear> rusti: let a = (2,5,3,6); a.filter(|x| x > 3)
[00:23:38] -rusti- pastebinned 8 lines of output: http://sprunge.us/AbaX
[00:23:49] <aatch> hoverbear, stop using tuples!
[00:23:58] *** Quits: Addle (quassel@93529591.BA907378.971E19F6.IP) (Ping timeout)
[00:23:59] *** Joins: lpy (lpy@7360AA58.F09091A8.1348A864.IP)
[00:24:03] <ChrisMorgan> Ooh, I like it: bors will get all the tips at http://tip4commit.com/projects/149
[00:24:04] <hoverbear> aatch: Ok. :(
[00:24:05] <alan_andrade> @aatch gotcha
[00:24:07] *** Joins: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net)
[00:24:07] *** ChanServ sets mode: +o tjc
[00:24:37] *** Joins: Addle (quassel@moz-67A92E8A.cable.teksavvy.com)
[00:24:38] <aatch> hoverbear, they aren't very useful beyond multiple return values.
[00:24:39] <zenon> aatch: How are iterators implemented that they cannot be mutable if the variable isn't mutable?
[00:24:45] <strcat> hoverbear: tuples are heterogenous aggregates, they don't provide iteration because they aren't used for maintaining collections of things
[00:25:02] <strcat> zenon: that's just how mutability works in rust
[00:25:10] <strcat> zenon: a struct is mutable if it's placed somewhere mutable
[00:25:26] <strcat> a struct inside the field of another struct that's a variant of an enum placed in an immutable variable is immutable all the way down
[00:25:31] <strcat> in a mutable variable, it's mutable all the way down
[00:25:38] <aatch> Or constructing them for a match expression
[00:25:40] <strcat> mutability is inherited from the owner
[00:25:52] *** Joins: ricepuddin (graham@moz-7D68765A.cable.virginm.net)
[00:26:08] <alan_andrade> @strcat from the tutorial:
[00:26:09] <strcat> & and &mut only have mutability as part of the type because they *observe* immutability/mutability, they don't own anything
[00:26:10] <alan_andrade> `size_of::<Foo>()`
[00:26:18] <alan_andrade> Give the size
[00:26:31] <alan_andrade> of a struct Foo
[00:26:35] <alan_andrade> but why the parens ?
[00:26:40] <strcat> it's a function call
[00:26:45] <strcat> size_of is a function
[00:26:45] <hoverbear> strcat: So say I want a typed aggregate of values? I want .map, .filter, .reduce?
[00:26:57] <strcat> hoverbear: a container of some sort, like an array
[00:27:06] <aatch> (I did an equality impl for an enum where if one side or the other is a particular value, it's always true, so I have `match (*self, *other) { (Wild, _) | (_, Wild) => true, ...}`
[00:27:09] <aatch> )
[00:27:10] <hoverbear> rusti: let a = [1,2,3]; a
[00:27:11] -rusti- [1, 2, 3]
[00:27:13] <strcat> hoverbear: yes
[00:27:14] *** Joins: vky (chatzilla@moz-4F2E17BF.dsl.dynamic.sonic.net)
[00:27:19] <hoverbear> strcat: I didn't realize rust had arrays.
[00:27:21] <strcat> rusti: let xs = [1, 2, 3]; xs.iter().fold(0, |a, &b| a + b)
[00:27:23] -rusti- 6
[00:27:24] <zenon> stupid me. I was assuming that .max_by was a method of a slice that internally creates an iterator (which could then be mutable). But max_by is a method of the iterator itself. It makes sense now.
[00:27:26] <alan_andrade> So I assume there is something like size_of::Struct something ?
[00:27:48] <Luqman> alan_andrade: sizeof::<SomeType>()
[00:27:50] <strcat> alan_andrade: size_of is a generic function
[00:27:54] <aatch> hoverbear, you didn't... but arrays are... :/
[00:28:16] <alan_andrade> When you specialize a function for a type == Trait ?
[00:28:29] <strcat> hoverbear: and various kinds of maps/sets and other types throughout the stdlib (ring buffers, etc.)
[00:28:41] <hoverbear> strcat: Graphs?
[00:28:46] <strcat> no
[00:28:48] <aatch> alan_andrade, Rust don't have specialisation.
[00:28:52] <strcat> you can represent a graph with a map
[00:28:56] <hoverbear> The one thing I actually wanted haha.
[00:29:02] <hoverbear> Alright. :)
[00:29:09] <aatch> generic graphs tend not to be very useful.
[00:29:12] <hoverbear> I'll check out the beastary after finals.
[00:29:24] <aatch> bestiary*
[00:29:33] <alan_andrade> @aatch Meaning there is no "inheritance" ?
[00:29:38] <alan_andrade> of some sort ?
[00:29:47] <aatch> alan_andrade, there is via traits.
[00:29:55] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[00:30:00] <alan_andrade> correct. Ok
[00:30:01] <hoverbear> rusti: let a = [1,2,3,5]; a.max_by(|x| x)
[00:30:01] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[00:30:02] -rusti- <anon>:9:27: 10:5 error: type `[<VI3>, .. 4]` does not implement any method in scope named `max_by`
[00:30:02] -rusti- <anon>:9         let a = [1,2,3,5]; a.max_by(|x| x)
[00:30:02] -rusti- <anon>:10     };
[00:30:02] -rusti- error: aborting due to previous error
[00:30:02] -rusti- application terminated with error code 101
[00:30:04] <strcat> alan_andrade: traits are a property of a type
[00:30:08] <strcat> a generic function has type parameters
[00:30:14] <hoverbear> rusti: let a = [1,2,3,5]; a.iter().max_by(|x| x)
[00:30:17] -rusti- pastebinned 8 lines of output: http://sprunge.us/gZAC
[00:30:18] <aatch> `trait Foo { ...} trait Bar : Foo { ... }` Bar "inherits" from Foo.
[00:30:22] <strcat> if it needs those types to have certain properties, it can bound them by various traits
[00:30:30] <hoverbear> rusti: let a = [1,2,3,5]; a.iter().max_by(|&x| x)
[00:30:32] -rusti- pastebinned 16 lines of output: http://sprunge.us/SMUB
[00:30:42] <strcat> rusti: fn identity<A>(x: A) -> A { x } identity(5)
[00:30:43] -rusti- 5
[00:30:43] <aatch> hoverbear, you've hit a bug there.
[00:30:52] <hoverbear> aatch: ??
[00:31:01] <strcat> aatch: it's not a bug
[00:31:07] <hoverbear> rusti: let mut a = [1,2,3,5]; a.iter().max_by(|&x| x)
[00:31:14] -rusti- pastebinned 16 lines of output: http://sprunge.us/hPJg
[00:31:18] <strcat> it's because of how rusti lays out code
[00:31:19] <strcat> max_by is returning Option<&int> there
[00:31:25] <aatch> Oh wait, I was thinking of a different bug.
[00:31:31] <strcat> the lifetime of the &int is tied to the array
[00:31:31] <strcat> and it goes out of scope
[00:31:37] <aatch> strcat, you sure?
[00:31:39] <hoverbear> rusti: let mut a = [1,2,3,5]; a.iter().max_by(|&x| x).unwrap()
[00:31:40] <strcat> yes
[00:31:40] <zenon> What's the best way to have `options` in rust? Something like a global struct that is initialized at program start and then readonly.
[00:31:40] -rusti- pastebinned 16 lines of output: http://sprunge.us/SYRM
[00:31:44] <strcat> aatch: rusti runs code like this
[00:31:47] <strcat> let result = { code };
[00:31:54] *** Joins: TimAbraldes (quassel@125EF623.B2666F0E.66399531.IP)
[00:31:55] <strcat> println!("{:?}", result)
[00:32:04] <strcat> so the array lives only as long as that block
[00:32:06] <aatch> rusti: let mut a = [1,2,3,5]; println!("{:?}", a.iter().max_by(|&x| x));
[00:32:07] -rusti- <anon>:9:16: 9:17 warning: variable does not need to be mutable [-W unused-mut (default)]
[00:32:08] -rusti- <anon>:9         let mut a = [1,2,3,5]; println!("{:?}", a.iter().max_by(|&x| x));
[00:32:08] -rusti-                          ^
[00:32:08] -rusti- Some(&5)
[00:32:08] -rusti- ()
[00:32:08] <strcat> and max_by returns a ref to it
[00:32:22] <strcat> it's just because of how rusti works
[00:32:29] <hoverbear> rusti: let mut a = [1,2,3,5]; a.iter().max_by(|&x| x).unwrap().clone()
[00:32:30] -rusti- pastebinned 35 lines of output: http://sprunge.us/ISPE
[00:32:33] <aatch> Huh, didn't think that it would return an Option<&int>
[00:32:39] <strcat> https://github.com/thestinger/rust-playpen/blob/master/bin/irc.sh
[00:32:43] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[00:32:43] <aatch> (that's what I meant by "are you sure")
[00:32:54] <strcat> aatch: none of the iterator stuff fails
[00:33:02] <strcat> or allocates
[00:33:07] <hoverbear> strcat: So that would work in real code/
[00:33:14] <hoverbear> let  a = [1,2,3,5]; a.iter().max_by(|&x| x).unwrap().clone()
[00:33:22] <hoverbear> Not the clone, though
[00:33:32] <strcat> rusti is 'real code'
[00:33:43] <strcat> hoverbear: https://github.com/thestinger/rust-playpen/blob/master/bin/irc.sh that's how it runs it
[00:33:59] <aatch> rusti: let mut a = [1,2,3,5]; "{:?}", a.iter().map(|&x| x).max_by(|&x| x);
[00:33:59] -rusti- <anon>:9:37: 9:38 error: expected one of `; }` but found `,`
[00:33:59] <strcat> you're declaring an array (`a`) and trying to return a reference beyond where it lives
[00:33:59] -rusti- <anon>:9         let mut a = [1,2,3,5]; "{:?}", a.iter().map(|&x| x).max_by(|&x| x);
[00:33:59] -rusti-                                               ^
[00:34:00] -rusti- application terminated with error code 101
[00:34:10] <strcat> since it does 'let r = { code }'
[00:34:19] <strcat> anything in the block goes out of scope when the block ends - it's dead
[00:34:23] <aatch> rusti: let mut a = [1,2,3,5]; a.iter().map(|&x| x).max_by(|x| x);
[00:34:24] -rusti- pastebinned 8 lines of output: http://sprunge.us/KcYd
[00:34:55] <aatch> bah, whatever.
[00:35:19] <strcat> rusti: let mut a = [1,2,3,5]; a.iter().map(|&x| x).max_by(|&x| x)
[00:35:20] -rusti- <anon>:9:16: 9:17 warning: variable does not need to be mutable [-W unused-mut (default)]
[00:35:20] -rusti- <anon>:9         let mut a = [1,2,3,5]; a.iter().map(|&x| x).max_by(|&x| x)
[00:35:20] -rusti-                          ^
[00:35:21] -rusti- Some(5)
[00:35:36] <strcat> rusti: let a = [1,2,3,5]; a.iter().map(|&x| x).max_by(|&x| x)
[00:35:37] -rusti- Some(5)
[00:35:47] <strcat> rusti: let a = [1,2,3,5]; a.iter().max_by(|&x| x).map(|&x| x)
[00:35:49] -rusti- pastebinned 16 lines of output: http://sprunge.us/WQdD
[00:35:50] <yichoi> acrichto: ping
[00:36:01] <strcat> rusti: let a = [1,2,3,5]; a.iter().max_by(|&x| *x).map(|&x| x)
[00:36:02] -rusti- pastebinned 16 lines of output: http://sprunge.us/GfcV
[00:36:15] <strcat> oh
[00:36:18] <strcat> 0.8
[00:36:19] * strcat sighs
[00:36:29] *** Quits: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net) (Quit: Textual IRC Client: www.textualapp.com)
[00:36:39] <aatch> strcat, any closer to it working on 0.9-pre?
[00:36:39] <zenon> strcat: that looks like a dangerous script for a public irc channel :P
[00:36:46] *** Quits: smodo (tadnr@moz-6398EFDF.dclient.hispeed.ch) (Input/output error)
[00:36:52] <strcat> zenon: it runs in a sandbox
[00:36:55] <strcat> look at the rest of the code
[00:37:03] <strcat> zenon: https://github.com/thestinger/rust-playpen/blob/master/web.py
[00:37:10] <strcat> which uses https://github.com/thestinger/playpen
[00:37:17] <aatch> zenon, the amount of safety it why rusti is still on 0.8
[00:37:19] <strcat> (although this isn't the web frontend)
[00:37:20] <aatch> rusti: version
[00:37:21] -rusti- "rustc 0.8"
[00:37:30] <strcat> aatch: well it's because rustc uses libuv-based I/O now
[00:37:36] <strcat> and it's fairly broken with pipes
[00:37:49] <strcat> it deadlocks
[00:38:10] <strcat> I can disable the sandboxing (no namespaces, no syscall whitelisting, etc.) and it still deadlocks
[00:38:10] <aatch> strcat, ouch.
[00:38:13] <dbaupp> strcat: you could try putting #[no_uv] on the rustc crate?
[00:38:21] <strcat> maybe
[00:38:40] <strcat> it could be races in rust rather than libuv doing something wrong, who knows
[00:38:53] <strcat> although libuv *is* doing a invalid stuff ;p
[00:38:55] <strcat> can see it in strace
[00:39:45] <strcat> I'm pretty sure it relies on something like tcgetattr/tcsetattr to make stdin non-blocking
[00:40:16] *** Quits: alan_andrade (Mibbit@moz-5AA4E9ED.hfc.comcastbusiness.net) (Quit: http://www.mibbit.com ajax IRC Client)
[00:40:42] * o11c cringes
[00:42:10] *** Quits: TimAbraldes (quassel@125EF623.B2666F0E.66399531.IP) (Input/output error)
[00:42:57] <zenon> rusti: println("test")
[00:42:58] -rusti- test
[00:42:58] -rusti- ()
[00:43:08] *** Joins: Jesin (Jesin@moz-63C897DA.res.lehigh.edu)
[00:43:35] <zenon> can rust print the type of an expression?
[00:43:42] <strcat> yes
[00:44:06] <zenon> how?
[00:44:12] <hoverbear> Oh my god
[00:44:24] <hoverbear> My build has been failing because I typed --no-confirm instead of --noconfirm
[00:44:47] <strcat> rusti: fn type_of<T>(_: &T) -> &'static str { unsafe { (*std::unstable::intrinsics::get_tydesc::<T>()).name } } enum Foo { Bar, Baz } let x = Bar; type_of(&x)
[00:44:47] <zenon> rusti: println!("{:?}", typeof("test"))
[00:44:48] -rusti- "main::Foo"
[00:44:48] -rusti- <anon>:9:25: 9:31 error: `typeof` is a reserved keyword
[00:44:49] -rusti- <anon>:9         println!("{:?}", typeof("test"))
[00:44:49] -rusti-                                   ^~~~~~
[00:44:49] -rusti- application terminated with error code 101
[00:44:58] <strcat> you have to write type_of yourself ;p
[00:45:11] <zenon> rusti: println!("{:?}", type_of("test"))
[00:45:12] -rusti- pastebinned 11 lines of output: http://sprunge.us/GBDP
[00:45:24] <zenon> argh
[00:45:29] <strcat> rusti: fn type_of<T>(_: &T) -> &'static str { unsafe { (*std::unstable::intrinsics::get_tydesc::<T>()).name } } enum Foo { Bar, Baz } let x = "foo"; type_of(&x)
[00:45:30] -rusti- "&'static str"
[00:45:57] <zenon> Isn't there something fancy at compile time?
[00:46:19] <dbaupp> rusti: let () = "foo";
[00:46:19] -rusti- <anon>:9:12: 9:14 error: mismatched types: expected `&'static str` but found `()` (expected &'static str but found ())
[00:46:19] -rusti- <anon>:9         let () = "foo";
[00:46:19] -rusti-                      ^~
[00:46:20] -rusti- error: aborting due to previous error
[00:46:20] -rusti- application terminated with error code 101
[00:46:30] <dbaupp> zenon: yup ;P
[00:46:45] *** Quits: jvns (bork@87D98E32.4046EB22.428F94DD.IP) (Ping timeout)
[00:46:47] <zenon> something that creates a "static str" :)
[00:46:50] *** Joins: alan_andrade (Mibbit@moz-5AA4E9ED.hfc.comcastbusiness.net)
[00:47:02] <strcat> zenon: that's what the type_of I wrote above does
[00:47:10] <strcat> it will compile down to just being that string
[00:47:17] <dbaupp> zenon: ^ that error message, if you just want to see what the compiler things the type is
[00:47:55] <zenon> strcat: that's pretty amazing
[00:48:25] <strcat> not really ;p
[00:49:01] *** Quits: jlong (jlong@moz-6DFDE846.socal.res.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[00:49:34] <strcat> basic optimizations like inlining and dead code/value elimination are relied on pretty heavily
[00:50:29] <strcat> LLVM will inline functions below a cost threshold and bubble that up iteratively, until there are 0 left below the threshold
[00:50:31] <strcat> can depend on it 
[00:51:02] <zenon> The magic is happening inside get_tydesc, I guess.
[00:51:18] <strcat> get_tydesc outputs a type descriptor struct
[00:51:32] <strcat> with some fields describing the size, alignment, name, destructor ptr, etc.
[00:52:08] <strcat> it's mostly an anti-pattern... traits and closures don't really need it
[00:52:19] *** jdm|away is now known as jdm
[00:52:57] <zenon> Having used mostly C, C#, and Go, this compile time magic is a black box for me...
[00:54:24] <zenon> zero-cost abstraction, that is
[00:54:29] <dbaupp> C# and Go surely have similar compile-time magic? although it's presumably significantly more polished, so doesn't feel as completely magical.
[00:54:42] <strcat> Go doesn't have generics
[00:54:45] <Diamond> C# await
[00:54:52] <strcat> await is a good example
[00:55:03] <strcat> or yield
[00:55:31] <strcat> zenon: C++ (and Rust) are all about building zero-cost abstractions
[00:55:34] <strcat> for example, iterators
[00:55:46] <strcat> the vector iterator is defined as a struct containing 2 ptrs
[00:55:52] <vadimcn> Just read today's meeting notes...  So what's the deal with clang, libstdc++ and unwinding?    Is the goal to get rid of the libstdc++ dynamic lib, or something more?
[00:55:57] <strcat> it defines the next method for the Iterator trait
[00:56:11] *** Quits: jeaye (Jeaye@moz-34FEF2BB.hsd1.ca.comcast.net) (Quit: movie)
[00:56:14] <strcat> the Iterator trait supplies a dozen or so functions like map, fold, etc.
[00:56:40] <strcat> LLVM happily inlines those functions (they're tiny), inlines next into them, so you have a single simple loop
[00:57:00] <strcat> and it'll just split the iterator into the two pointers (not that it really matters) and then happily unroll or vectorize a loop
[00:57:21] *** Joins: jlong (jlong@moz-6DFDE846.socal.res.rr.com)
[00:57:32] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[00:58:06] *** Quits: gdey (gdey@moz-CD850554.static-ip.telepacific.net) (Quit: Leaving...)
[00:58:10] *** Joins: gdey (gdey@moz-CD850554.static-ip.telepacific.net)
[00:58:18] <strcat> fn foo(xs: &mut [f64]) { for x in xs.mut_iter() { *x += 5.0; } } will compile down to SSE/AVX ops in an unrolled loop body
[00:58:27] <strcat> more impressive when you chain a bunch of adaptors and it does it
[00:58:55] <strcat> range(0, 10000).take_while(|&x| x < 100).map(|x| x * 2).fold(0, |a, b| a + b) is constant folded, without help from the frontend
[00:58:57] * strcat shrugs
[00:59:29] *** Joins: ptc (Adium@moz-192425C4.nyc.res.rr.com)
[00:59:50] *** Quits: gdey (gdey@moz-CD850554.static-ip.telepacific.net) (Ping timeout)
[00:59:54] <strcat> if only we output TBAA info and nicer IR in general ;\
[01:00:13] <vadimcn> Anyone?
[01:00:29] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[01:00:32] <strcat> vadimcn: I think the goal is to remove the dependency on a C++ runtime
[01:00:53] <vadimcn> strcat: why is it considered a bad thing?
[01:01:15] <strcat> pretty large dependency just for the stdlib to be able to provide unwinding
[01:01:38] <o11c> hm, I guess that would be the one good reason to not have task failure
[01:01:39] <vadimcn> strcat: would linking it statically be acceptable? 
[01:01:47] <strcat> vadimcn: I don't think so
[01:01:51] <o11c> or is there some other way to do task failure?
[01:01:59] <strcat> you don't need a whole C++ stdlib for unwinding
[01:02:06] <vadimcn> What about libgcc dependency?  
[01:02:15] <strcat> vadimcn: on some platforms
[01:02:17] <o11c> everything depends on libgcc, that's not going away
[01:02:18] <cmr> libgcc dep isn't as big a deal since it's small and ubiquitous
[01:02:23] <strcat> o11c: it can go away
[01:02:26] <cmr> o11c: that's not necessarily true
[01:02:32] <cmr> we can ship compiler-rt
[01:02:37] <strcat> o11c: LLVM has compiler-rt, it's meant to be a libgcc replacement
[01:02:44] <cmr> we're going to have to, since libgcc is broken :|
[01:02:46] <strcat> libc++abi provides the C++ exception ABI
[01:02:51] <vadimcn> the actual unwinding code lives in libgcc, so we could call it directly...
[01:02:52] <strcat> and it has an optional built-in unwind library
[01:02:59] <strcat> vadimcn: or use libc++abi's unwind lib
[01:03:04] *** Quits: ptc (Adium@moz-192425C4.nyc.res.rr.com) (Connection reset by peer)
[01:03:11] *** Joins: ptc (Adium@6C906E9F.9ECAA4DB.BCDD830B.IP)
[01:03:18] <strcat> don't need any GNU libs to build C++11 on windows
[01:03:32] <strcat> so why do we need it for rust?
[01:03:33] <vadimcn> we've been over this before :)   libc++abi still needs platform unwind library, such as libgcc or libunwind
[01:03:42] <strcat> vadimcn: no, it has a built-in unwind lib now
[01:03:56] <cmr> (this is a recent development)
[01:04:06] <strcat> vadimcn: http://llvm.org/svn/llvm-project/libcxxabi/trunk/src/Unwind/
[01:04:07] <vadimcn> it does?  hmm, ok I'll check it out
[01:04:15] <Luqman> vadimcn: http://blog.llvm.org/2013/10/new-libunwind-implementation-in-libcabi.html
[01:04:46] <strcat> there was progress since then afaik
[01:05:07] *** jorendorff is now known as jorendorff_away
[01:05:12] <vadimcn> it it known to work on Windows?
[01:05:32] <strcat> it's intended to
[01:05:40] *** Quits: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP) (Ping timeout)
[01:05:41] <strcat> may not work yet
[01:05:53] <strcat> they are working hard on MSVC++ ABI compatibility in clang
[01:06:05] *** Joins: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP)
[01:06:07] <strcat> compatible name mangling, etc. - and exceptions are part of that
[01:06:07] <vadimcn> and assuming it works, would using libc++abi for unwinding be preferrable to using libgcc?
[01:06:26] <strcat> well we need compiler-rt anyway for stuff not in libgcc_s
[01:06:35] *** Joins: fyolnish (fyolnish@moz-FA8E1C6C.uqwimax.jp)
[01:06:41] <strcat> and libc++abi is pretty tiny, and permissively licensed
[01:06:46] <vadimcn> Rust doesn't need MSVC C++ exception compatibility though...
[01:07:14] <vadimcn> Is the goal to get rig of (L)GPL dependencies alltogether?
[01:07:29] <cmr> vadimcn: it's more of a selff-containedness thing
[01:07:37] <strcat> I think the goal is to get rid of non-LLVM deps entirely
[01:08:11] <strcat> and reduce deps overall
[01:08:17] <vadimcn> Self-contained-ness at runtime I presume?   It'd be still ok to use gcc to build, right?
[01:08:18] *** Quits: fyolnish (fyolnish@moz-FA8E1C6C.uqwimax.jp) (Ping timeout)
[01:08:29] <vadimcn> to build Rust compiler I mean
[01:08:29] <strcat> compiler-rt is necessary for stuff like 64-bit checked multiplication already
[01:08:38] <strcat> vadimcn: the rust compiler is rust
[01:08:55] <strcat> gcc/clang is used to build llvm/libuv and a tiny bit of leftover C++ we should get rid of soon
[01:08:57] <vadimcn> But rustrt is not.   (Yet?)
[01:09:02] *** Quits: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net) (Ping timeout)
[01:09:15] <strcat> vadimcn: it's not much code anymore
[01:09:43] * vadimcn confused :)
[01:09:56] <strcat> rustrt is just some leftover C and C++ that's not ported to rust yet
[01:10:09] <strcat> and sundown is linked into there for rustdoc
[01:10:56] <strcat> vadimcn: look in src/rt - there's not a lot there
[01:11:08] <strcat> also a zlib implementation
[01:11:29] <cmr> Which eddyb is apparently rewriting anyway.
[01:11:30] <vadimcn> Is the goal to port all of rt to Rust?
[01:11:50] <Luqman> a lot of the stuff in rustrt that's called directly from libstd are just helpers to deal with platform dependent structs
[01:11:55] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[01:11:57] <strcat> vadimcn: yes, but it's basically done
[01:12:09] <strcat> we lack libclang-based header parsing so some stuff is really a pain in rust
[01:12:12] <Luqman> i imagine if we get integration with libclang we can get rid of those entirely
[01:13:14] <achin> how does that help?  can you get libclang to parse headers to generate the necessary rust structs?
[01:13:26] *** Parts: vodik (simon@moz-FD4ADBC6.cable.teksavvy.com) (later gator)
[01:13:29] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[01:13:31] <strcat> achin: you can use libclang to parse headers and resolve stuff in those headers as if it was rust
[01:13:33] *** Quits: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net) (Quit: Leaving...)
[01:13:33] <vadimcn> ok, so IMO, are two ways of doing unwinding without libstdc++:   1) directly call unwinding code in libgcc  and 2) use directly call into LLVM's libc++abi
[01:13:47] <vadimcn> the first one is more mature, I'd expect
[01:14:08] <strcat> vadimcn: mingw doesn't have solid table-based unwinding on 32-bit, it has never worked properly
[01:14:11] <achin> strcat: cool
[01:14:21] <dbaupp> cmr: I thought eddyb was just using zlib to write a png decoder?
[01:14:21] <strcat> mingw-w64 has working SEH, but so does LLVM afaik
[01:14:35] <strcat> and we're already tied to LLVM for the rust side of it
[01:14:38] <vadimcn> what's "table-based"?   DWARF?
[01:14:47] <strcat> vadimcn: yes, rust can only use table-based unwinding atm
[01:14:53] <cmr> dbaupp: he is, but he wants to have rust gzip support too
[01:15:10] <strcat> vadimcn: using sjlj would require different rust codegen for failure handling
[01:15:26] <vadimcn> Why table based is bad?
[01:15:31] <strcat> it's not bad
[01:15:33] <dbaupp> cmr: ah I see (well obviously, everyone wants rust everything support :P )
[01:15:42] <vadimcn> stdcat: so why not use it?
[01:15:43] <cmr> dbaupp: well he's actually crazy enough to do it!
[01:15:47] <strcat> vadimcn: mingw's DWARF implementation is just buggy
[01:16:00] <dbaupp> cmr: gzip isn't *that* complicated, aiui
[01:16:03] <klutzy> cmr: does rewriting mean new interface of minizip or new rustgzip?
[01:16:15] *** Joins: blank_name (blank_name@A1428C52.6FF80FE1.6D228269.IP)
[01:16:17] <cmr> klutzy: pure-rust port.
[01:16:21] <Luqman> there's dwarf for windows 32bit but downside is none of the system libs use it.
[01:16:25] <ezyang> is the rustdoc docblock syntax documented anywhere? 
[01:16:37] <Luqman> and 32bit seh is patented so noone implemented it
[01:16:45] <klutzy> wow. I'll be exicted to see it :D
[01:16:47] <ezyang> https://github.com/mozilla/rust/wiki/Doc-using-rustdoc 
[01:16:47] <cmr> ezyang: it's plain markdown, it's run through sundown.
[01:16:54] *** Quits: Diamond (dick@moz-80556682.ks.ks.cox.net) (Quit: Leaving.)
[01:17:00] <cmr> whoa that's an ancient wiki page
[01:17:01] <vadimcn> strcat: ???  AFAIK, mingw has nothing to do with DWARF, other than porting libgcc, which implements DWARF-based unwinding.   or is that what you meant?
[01:17:03] <cmr> I wish I knew it existed.
[01:17:19] <cmr> ezyang: http://static.rust-lang.org/doc/master/rustdoc.html
[01:17:24] *** Joins: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net)
[01:17:36] <vadimcn> Luqman: but Windows system libs don't use exceptions *at all*
[01:17:48] <vadimcn> it's all return code based
[01:17:57] <strcat> vadimcn: the mingw-w64 recommendation is to use sjlj on 32-bit and SEH on 64-bit
[01:18:06] <strcat> they say DWARF is buggy and I believe them
[01:18:17] <strcat> there are bugs for all 3 in the tracker, not that it means anything
[01:18:36] <ezyang> cmr: OK, I added an out-of-date message on the wikipage 
[01:18:53] <FreeFull> I don't think Linux uses exceptions either
[01:19:00] <FreeFull> Not that C has them
[01:19:07] <vadimcn> strcat: that might be an argument in favor of using LLVM's (clang's) unwinder
[01:19:26] <vadimcn> strcat: but I'd like to see it for myself, got links to the bugs?
[01:19:32] <ezyang> What kind of Markdown does rustdoc use? 
[01:19:39] <alan_andrade> @strcat This is why I've been bugging the forum lately. https://github.com/uutils/coreutils/pull/31
[01:19:46] <cmr> ezyang: we use the Sundown library
[01:19:55] *** Quits: notmatt (notmatt@CC62CF7E.1E7FDFDB.A82DBDDB.IP) (Client exited)
[01:19:57] <ezyang> oh right, you just said that. Maybe the doc should mention it? 
[01:20:03] <alan_andrade> Please comment if you see bullshit lol
[01:20:04] *** kimundi is now known as zz_kimundi
[01:20:06] <cmr> yeah I'm adding it now :)
[01:20:15] <ezyang> coolio 
[01:20:45] <strcat> vadimcn: they make that claim here http://mingw-w64.sourceforge.net/download.php#automated-builds
[01:20:50] <ezyang> well, the wikipage is a bit more detailed than the manual page :) 
[01:20:53] <strcat> their bug tracker is really terrible sourceforge crap though ;p
[01:21:02] * strcat doesn't feel like dealing with it atm
[01:21:19] *** Quits: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[01:21:26] <cmr> ezyang: yes, it is. I didn't know the wiki page existed when I wrote the manual. but, now that we actually have a manual, it can be improved.
[01:21:30] <cmr> doc/rustdoc.md :)
[01:21:43] <ezyang> https://github.com/vmg/sundown/commit/37728fb2d7137ff7c37d0a474cb827a8d6d846d8 :-( 
[01:21:52] *** Joins: montezuma (Mibbit@2AACB6E1.A033706C.284344F5.IP)
[01:22:00] <cmr> ezyang: it's still what everyone uses and there's no replacement.
[01:22:05] <ezyang> So, what I'm mostly curious about, is how inter-identifier reference get resolved 
[01:22:10] <cmr> they don't
[01:22:12] <bstrie> dbaupp: it's lower-case up at the top of the page as well, you just can't tell because the font is in smallcaps
[01:22:17] <ezyang> aw :( 
[01:22:25] *** Joins: nomadic (nomadic@moz-E01D5C49.hsd1.ga.comcast.net)
[01:22:46] <bstrie> dbaupp: and I don't have the power to change the capitalization of "rust", all I can do is tack on "the" and "programming language"
[01:22:57] <vadimcn> strcat: umm, very non-specific.   "has known limitations and bugs" could refer to incompatibility with SEH-exceptions... or to something else
[01:23:09] *** Quits: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com) (Input/output error)
[01:23:17] <dbaupp> bstrie: oh
[01:23:18] <vadimcn> strcat: but so far DWARF worked just fine
[01:23:40] <strcat> vadimcn: doesn't really mean much if it's appeared to work fine
[01:23:45] <strcat> most codegen bugs are like that
[01:23:59] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[01:24:22] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Quit: Leaving...)
[01:24:23] <bstrie> "-moz-animation is not a valid CSS property" hey reddit go to hellllllllll with your crappy CSS validator
[01:24:36] <bstrie> all I wanna do is make links shake uncontrollably when you hover over them
[01:24:38] <bstrie> is that so much to ask
[01:24:45] <Luqman> vadimcn: so everything works fine as long as any exception doesn't go through non-dwarf aware frames
[01:24:47] <dbaupp> bstrie: https://developer.mozilla.org/en-US/docs/Web/CSS/text-transform 'capitalize' apparently :P
[01:25:27] <bstrie> dbaupp: brilliant
[01:25:37] <ChrisMorgan> bstrie: yes, it is a little too much to ask.
[01:25:38] *** Quits: montezuma (Mibbit@2AACB6E1.A033706C.284344F5.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[01:25:48] * ChrisMorgan is concerned bstrie is becoming a Styling Despot.
[01:26:07] <ChrisMorgan> (Stylish Despot might be OK, but Styling Despot is probably not.)
[01:26:26] <strcat> bstrie is the minister of CSS abuse
[01:26:56] *** Joins: lfox (lfox@12E8CF24.F74F95CB.ECED8BE3.IP)
[01:27:08] <bstrie> ChrisMorgan: it was this power that gave you your CSS-powered username decoration!! dare not defy me!
[01:27:22] * ChrisMorgan retreats hurriedly
[01:28:38] <strcat> bstrie: make me Uniq<strncat> ;]
[01:28:44] *** Joins: mitsuhiko (mitsuhiko-@moz-BC29B73E.srv.pocoo.org)
[01:29:19] <vadimcn> strcat: to me that's a more reliable data point than a vague statement about bugs.   I'll try to find out what they meant by that "has known limitations and bugs"...  if you have any links. please send my way
[01:29:25] <SiegeLord> Can you replace the 'new' tab by 'box'?
[01:30:22] <vadimcn> Luqman: what about non-SEH aware frames?   The sad truth is, cross-language exception handling does not work.   At least on Windows.
[01:30:33] <bstrie> SiegeLord: brilliant
[01:30:49] <vadimcn> Luqman: I think the goal should be to have it working within Rust code
[01:31:03] *** Joins: Sgeo (quassel@moz-4E71E7BB.dyn.optonline.net)
[01:32:46] <klutzy> vadimcn: http://sourceforge.net/mailarchive/forum.php?thread_name=87hadebenk.fsf%40wanadoo.es&forum_name=mingw-w64-public
[01:32:58] *** Quits: Sgeo (quassel@moz-4E71E7BB.dyn.optonline.net) (Ping timeout)
[01:32:59] <klutzy> though it doesn't contain full explanation :-/
[01:33:34] <bstrie> strcat: done
[01:33:52] <klutzy> I feel mingw-w64 people basically want to warn users who doesn't know limitations of dw2
[01:34:39] *** Joins: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com)
[01:35:01] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[01:35:08] *** Joins: Sgeo (quassel@moz-4E71E7BB.dyn.optonline.net)
[01:35:21] *** Quits: zenon (Mibbit@moz-2E43177.dynamic.qsc.de) (Quit: http://www.mibbit.com ajax IRC Client)
[01:37:12] <vadimcn> Okay, but SJLJ is not an option because of slow-down...
[01:37:23] *** Quits: nsf (nsf@moz-EEF3238A.convex.ru) (Connection reset by peer)
[01:37:43] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Quit: yichoi)
[01:38:07] <vadimcn> and LLVM does not implement SEH because of patent issue (which is a bit musguided, IMO, when talking about code running on Windows, but whatever...)
[01:38:31] <strcat> vadimcn: I don't think it's a microsoft patent
[01:38:34] <vadimcn> and BTW, SEH would be similar to SJLJ in terms of performance
[01:38:38] <strcat> it's a borland patent
[01:39:02] <strcat> and MS probably has a patent licensing agreement with them
[01:39:09] <vadimcn> strcat: but Windows EH is based on SEH, so Microsoft licensed it from Borland for use by Windows apps
[01:39:33] <Luqman> the patent expires in 2014 i think
[01:39:37] <vadimcn> You could not use Windows system EH mechanism without infringing on this patent 
[01:40:08] <vadimcn> so code intended to run on Windows would be ok
[01:40:20] <vadimcn> But anyhow, it's not implemented by LLVM and that's that...
[01:40:57] <vadimcn> that leaves DWARF
[01:41:25] <vadimcn> and LLVM's libc++abi uses DWARF too, does it not?
[01:41:42] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Quit: Lost terminal)
[01:42:47] <vadimcn> so, again, Rust could use libgcc DWARF unwinder, or it could use libc++abi's   (or disable unwinding at all, but that's not being discussed seriously, right?)
[01:42:56] <cmr> it is being discussed actually
[01:43:26] <vadimcn> cmr: for all platforms or just for Windows?
[01:43:30] <cmr> all platforms
[01:43:48] <cmr> vadimcn: did you read the meeting notes?
[01:43:51] <bstrie> SiegeLord: I don't think it's possible :(
[01:43:58] <acrichto> we ended up concluding today that now is not the right time, but that was also precedented on libcxxabi not building on windows
[01:44:07] <SiegeLord> :(
[01:44:09] <acrichto> vadimcn, are you able to get libcxxabi to build on windows?
[01:44:28] <vadimcn> cmr: I did read them, but I feel like I am missing a lot of context, which did not get transcribed
[01:44:54] *** Joins: samx (sami@moz-D9DA5773.dyn.optonline.net)
[01:45:56] *** Quits: dbaupp (Thunderbir@1D1B1F7A.D5A1DCF.37681C44.IP) (Ping timeout)
[01:46:14] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[01:46:14] *** ChanServ sets mode: +ao brson brson
[01:46:28] <vadimcn> I would like to help to make Rust toolchain work on Windows.   But I need to understand what are the actual goals and what are just temporary workarounds and what is not serious talk.
[01:46:51] <vadimcn> Removal of unwinding on all platforms felt like the latter.
[01:46:56] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[01:47:12] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[01:47:15] <acrichto> vadimcn: the discussion today diverged from what it was originally saying, but our long term goal is to rid ourselves of the dependency to mingw
[01:47:15] <cmr> yeah, following the meeting notes isn't always easy :(
[01:47:32] <acrichto> vadimcn: one of the big questions for us is how we're going to unwind on windows if we're not using libstdc++
[01:47:49] <acrichto> even if libcxxabi builds we still need something to perform the actual unwinding
[01:48:05] <vadimcn> acrictho: the original mingw, or you dislike mingw-w64 too?
[01:48:15] <cmr> What does msvc emit calls to, or can we not use it?
[01:48:26] <strcat> it uses SEH
[01:48:31] <strcat> LLVM doesn't implement it on 32-bit
[01:48:42] <acrichto> vadimcn: with mingw-w64 we'd like to move to it, but we need to make sure that unwinding still works and we need to ensure that there's a road away from it entirely
[01:49:03] <acrichto> the answer to this may just be "wait for LLVM to get the necessary support"
[01:49:15] <acrichto> they seem to be focusing more on windows nowadays, which is good news for us
[01:49:17] <cmr> I think "road away from mingw" is a tiny bit ambitious atm, since LLVM is just starting to really put attention on window
[01:49:19] <cmr> yeah
[01:49:26] <vadimcn> acrichto: move to what?   Pure LLVM & it's libs?
[01:49:39] <acrichto> perhaps, whatever is easiest
[01:49:48] <acrichto> the installation process for rust should be cliking a button and that's it
[01:50:01] <acrichto> right now you have to first go through the mingw installation process I believe
[01:50:14] <vadimcn> You can build 32-bit Rust with mingw-w64 already
[01:50:24] <brson> we can make rust itself not depend on mingw before moving the entire rust build away from mingw
[01:50:39] <strcat> switching to mingw-w64 would be a nice step
[01:50:42] <brson> right now rustc requires a c compiler to link with
[01:50:50] <acrichto> vadimcn: from what I understand switching to mingw-w64 requires mostly automation on our end
[01:50:54] <strcat> would make lots of stuff magically start work on windows (thread_local, floating point libs, etc.)
[01:50:55] <brson> but if that weren't the case we could install rustc and users could use it without mingw
[01:50:58] <SiegeLord> Is this "move away from mingw and replace it with msvc" or "move away from mingw and accept any C++ compiler"?
[01:51:19] *** Quits: kirneh (kirneh@moz-FA14E0C7.cpe.webspeed.dk) (Quit: Lost terminal)
[01:51:30] <brson> or bootstrap off our own clang snapshot
[01:51:33] <vadimcn> strcat: ... and kill pthread performance, unfortuinately
[01:51:54] <achin> make on OSX says "Undefined symbols for architecture x86_64: "_LLVMRustLinkInExternalBitcode", referenced from: back::lto::run::anon::expr_fn::ay in rustc.o" (plus 1 other).  i already did a make clean-llvm.  do i need to do a full make-clean?
[01:51:55] <strcat> vadimcn: are we actually using pthreads? I thought we would be using win32 apis on windows
[01:52:09] <bstrie> SiegeLord: just kidding. it was possible! but only when you're actually on the "New" tab
[01:52:23] <SiegeLord> Woohoo!
[01:52:26] <strcat> we support win7 and later according to the README, so we can even use cond vars
[01:52:27] <acrichto> achin: I'd recommend a full clean yes
[01:52:58] *** Joins: nsf (nsf@moz-EEF3238A.convex.ru)
[01:53:15] <vadimcn> strcat: well, it's actually more about mutexes than threads.   I described it here https://github.com/mozilla/rust/issues/8996#issuecomment-24292739
[01:53:52] <vadimcn> strcat: if rustrt doesn't use pthread's mutexes, this might not be a problem
[01:53:58] *** Joins: anewnick (Mibbit@2AACB6E1.A033706C.284344F5.IP)
[01:54:06] <acrichto> we should not be using pthread mutexes on windows
[01:54:14] <acrichto> llvm and libuv may be using them, but rust is not using them
[01:54:32] <strcat> vadimcn: we should be using windows critical sections and condition variables
[01:54:46] <strcat> and LLVM/libuv should be too...
[01:55:27] <klutzy> llvm uses pthreads on mingw now; I think disabling it would make no problem
[01:55:39] <klutzy> (we disables pthreads on mingw-w64)
[01:55:43] <vadimcn> strcat: so does Rust need pthreads at all?
[01:55:58] *** Quits: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net) (Quit: echristo)
[01:56:15] <strcat> dunno, but if it does need them on windows it's a bug
[01:56:19] <acrichto> rust's stdlib does not need pthreads, some of our dependencies may be pulling it in
[01:56:38] <klutzy> don't know about libuv, but I guess they don't use pthreads since they even use win32 low-level apis :p
[01:56:55] <acrichto> right now pthread is linked in for libuv
[01:57:10] <acrichto> that probably shouldn't be linking in pthread of libuv though
[01:57:32] <vadimcn> acrichto: regarding "what are we moving to", we could statically link libgcc into...  well, libstd I guess, and the user would never know anything about libgcc
[01:57:44] *** Quits: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[01:57:50] <acrichto> vadimcn: that would be nice, but can we actually do that?
[01:57:59] <acrichto> I've been unable to find static builds of libgcc lying around
[01:58:47] <vadimcn> acrichto: mingw has one in MinGW\mingw32\lib\gcc\mingw32\4.8.1\libgcc_s.a 
[01:59:00] <strcat> isn't it LGPL?
[01:59:11] <vadimcn> itLGPL
[01:59:12] <acrichto> vadimcn: does that library define the _Unwind_Resume symbol?
[01:59:32] <strcat> doesn't that mean statically linking it makes you responsible for making the source of libgcc_s available to users?
[01:59:36] <vadimcn> acrichto: yes, that's where it's defined I believe
[01:59:38] <strcat> or something like that
[01:59:54] <cmr> strcat: yeah, it means anything using it needs to be relinkable to substitute in a libgcc_s replacement
[01:59:57] <acrichto> vadimcn: interesting! That would mean that we wouldn't need to build libunwind, but we would still need to build libcxxabi
[02:00:01] <cmr> We can't statically link lgpl stuff.
[02:00:08] <acrichto> strcat has valid points about licensing though (which I know nothing about)
[02:00:26] <vadimcn> strcat: it's GPL with exception, not LGPL
[02:00:31] <strcat> oh
[02:00:56] *** Joins: dbaupp (Thunderbir@1D1B1F7A.D5A1DCF.37681C44.IP)
[02:01:23] <vadimcn> https://www.gnu.org/licenses/gcc-exception-3.1-faq.html
[02:01:52] <hoverbear> Bahaha, it builds!
[02:02:27] *** Quits: alan (alan@32702EE8.939109B2.FB082A98.IP) (Quit: alan)
[02:02:35] *** Quits: ptc (Adium@6C906E9F.9ECAA4DB.BCDD830B.IP) (Ping timeout)
[02:02:35] *** Joins: kzzch (kzzch@moz-E771901A.pools.spcsdns.net)
[02:02:52] <kzzch> woot, sup everyone?
[02:02:55] *** Quits: refold (gman@moz-42D68426.a258.priv.bahnhof.se) (Quit: leaving)
[02:02:57] *** Joins: ptc (Adium@moz-192425C4.nyc.res.rr.com)
[02:02:57] <strcat> \o
[02:03:47] <vadimcn> acrichto: dunno about libc++abi, I think with some glue code Rust could use unwinder without going through C++ layer
[02:03:49] <kzzch> i rewrote my bot using master and it's way better now! definitely improved my experience.
[02:04:04] <kzzch> just wanted to say you guys are awesome
[02:04:13] <dbaupp> kzzch: \o/
[02:04:21] <acrichto> vadimcn: we need libcxxabi in order to do the exception handling stuff
[02:04:31] <acrichto> vadimcn: that's essentially how our unwinding works
[02:04:50] <vadimcn> acrichto: i'm proposing to try to go directly to lower level
[02:05:00] <vadimcn> acrichto: I haven't looked in detail into what this entails though
[02:05:14] <acrichto> vadimcn: that's the problem, short-circuiting libcxxabi would mean that we would need to implement libcxxabi
[02:05:24] <acrichto> that's what reads all the dwarf information I believe
[02:05:42] <acrichto> the unwinder (libgcc) just knows how to walk stack frames
[02:05:47] <dbaupp> cmr: idea: have the rustdoc docs have the actual example with html docs, so you can link to it.
[02:05:47] <acrichto> it doesn't know how to run the code on the stack frames
[02:06:17] <cmr> dbaupp: what, libstd and libextra aren't example enough? :p
[02:06:33] *** Joins: fyolnish (fyolnish@moz-ACF4CCAB.uqwimax.jp)
[02:06:47] <dbaupp> cmr: well, they don't exactly show what source corresponds to what
[02:06:52] * dbaupp shrugs
[02:06:53] <cmr> yeah
[02:06:57] <cmr> no, it's a good idea
[02:06:59] <cmr> but... makefile :(
[02:07:17] <dbaupp> hm, yeah; that might not be so easy
[02:08:06] <vadimcn> acrichto: I believe that running destructors on stack frames is part of the unwinder
[02:08:27] *** Quits: fyolnish (fyolnish@moz-ACF4CCAB.uqwimax.jp) (Ping timeout)
[02:08:31] *** Quits: Earnestly (earnest@88884C6.A3735F9C.39C00A7A.IP) (Ping timeout)
[02:09:14] <vadimcn> acrichto: Rust could define it's own "language personality" routine, instead of piggy-backing off C++'s
[02:10:14] <aatch> This is not a bad idea, given how (deliberately) limited our "exceptions" are.
[02:11:39] <aatch> We actually do have our own personality function, we just forward to the C++ version
[02:11:42] *** Joins: kzzch_ (kzzch@moz-E771901A.pools.spcsdns.net)
[02:12:21] *** Quits: kzzch (kzzch@moz-E771901A.pools.spcsdns.net) (Ping timeout)
[02:12:33] <strcat> whoa, my rust nightly got a lot bigger
[02:12:43] <strcat> 53MiB bigger ;\
[02:12:45] <cmr> strcat: static linking! isn't it wonderful?
[02:12:46] *** Quits: kzzch_ (kzzch@moz-E771901A.pools.spcsdns.net) (Quit: spoon!)
[02:12:55] <strcat> oh we ship those now?
[02:12:56] <cmr> LTO landed now though
[02:12:58] <cmr> yes
[02:13:10] <acrichto> vadimcn: if the unwinder runs destructors, then we may indeed be able to drop libcxxabi entirely
[02:13:39] <acrichto> vadimcn: my understanding of the division of labor between libcxxabi and libunwind is not ideal, I could very well be wrong in who does hwat
[02:13:57] <strcat> acrichto: libcxxabi has an unwind implementation now
[02:13:58] <acrichto> strcat: make sure you're not including the syntax/rustc rlib
[02:14:10] <acrichto> strcat: bundled inside, and I've only gotten it to build on darwin
[02:14:21] <acrichto> it's that thing that was contributed by apple
[02:14:30] <acrichto> I couldn't get it to build on linux
[02:14:36] <acrichto> and I didn't try too hard on windows either
[02:16:01] <vadimcn> Okay, so the question is: do we want to stay with mingw (or it's derivatives, like mingw-w64), or do we want to go completely LLVM&co? 
[02:16:28] <vadimcn> first would mean using unwinder from libgcc, the second - from libc++abi (or libunwind)
[02:16:55] <acrichto> hm, I must be missing things, isn't the state of windows today that we're using libstdc++ + libgcc ?
[02:17:12] *** Quits: ptc (Adium@moz-192425C4.nyc.res.rr.com) (Quit: Leaving.)
[02:17:32] *** Joins: fyolnish (fyolnish@moz-ACF4CCAB.uqwimax.jp)
[02:19:20] *** Quits: fyolnish (fyolnish@moz-ACF4CCAB.uqwimax.jp) (Ping timeout)
[02:20:27] *** Quits: alan_andrade (Mibbit@moz-5AA4E9ED.hfc.comcastbusiness.net) (Quit: http://www.mibbit.com ajax IRC Client)
[02:21:19] <vadimcn> acrichto: yes, but we could get rid of libstdc++ and statically link lingcc
[02:22:21] <vadimcn> acrichto: but if the ultimate goal is to use LLVM toolchain, this would be wasted work and we should look into using LLVM's libc++abi unwinder to begin with
[02:23:53] <acrichto> vadimcn: we don't want to depend on mingw forever. If we need to depend on it for awhile (with a clear path forward with LLVM), then that is ok
[02:23:59] <acrichto> vadimcn: can you even build libcxxabi on windows though?
[02:24:38] <vadimcn> acrichto: I dunno, but we could work towards this goal :)
[02:24:57] *** Joins: mr_sticky (Mibbit@moz-D26F0273.protectedgroup.com)
[02:25:04] *** Quits: mr_sticky (Mibbit@moz-D26F0273.protectedgroup.com) (User has been banned from Mozilla (no spamming here))
[02:25:10] <acrichto> vadimcn: I also remember reading that libunwind does not work on windows at all
[02:25:25] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[02:25:31] <acrichto> so right now our only static option there is libgcc, and there is no path forward with that (as far as I know)
[02:26:01] <brson> we can implement return based unwinding for just windows
[02:26:09] <vadimcn> acrichto: re: libunwind that's true, though I've seen somebody's windows port of it
[02:27:11] <acrichto> returned based unwinding would be a 0-dep solution
[02:27:59] <vadimcn> returned based unwinding would need to be implemented in Rust backend though, right?
[02:28:13] <vadimcn> and it would be just as slow as SJLJ
[02:28:20] <vadimcn> if not more
[02:28:55] <acrichto> yes, it would require codegen changes
[02:29:00] <acrichto> it is not clear that it would actually be slower
[02:29:02] *** Quits: glennsl (textual@moz-5D7B804F.getinternet.no) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[02:29:16] <SiegeLord> Is a rust file with embedded NULL a legal source file?
[02:29:22] <acrichto> it may appear like it is, but remember that we have code running at the beginning of every function call and I've never heard anyone complain about that being slow
[02:29:22] <cmr> SiegeLord: yes
[02:29:29] <cmr> SiegeLord: (since it's valid utf8)
[02:29:34] <SiegeLord> Many things treat such files as binary...
[02:29:37] <SiegeLord> Like 'file'
[02:29:39] <cmr> what rustc will actually /do/ with that embedded null, I don't know.
[02:29:56] <vadimcn> acrichto: you'd need to insert compare/jump after each function call, that's got to be slower than no code at all
[02:30:25] <acrichto> vadimcn: I don't want to say that it's slow based on conjecture, I want to say that it's slow based on profiling results
[02:30:40] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[02:30:42] <acrichto> but yes, every function call would have a compare/jump (all function calls currently have one)
[02:30:43] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Quit: yichoi)
[02:30:51] <cmr> ezyang: is there anything else besides the questions you asked you'd like added to the rustdoc manual, before I send my PR?
[02:32:05] <dbaupp> acrichto: I thought people have complained about the function prelude?
[02:32:07] *** Quits: Siyo (Siyo@A89938F4.87DAA49F.F113998C.IP) (Ping timeout)
[02:32:13] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[02:33:00] <vadimcn> acrichto: there's been numerous blog posts over the years where people benchmarked return codes vs exceptions (especially table-based exceptions)
[02:34:15] <aatch> God dammit, it's really hard to find whether running cleanups is handled by the unwinder or not.
[02:34:38] <aatch> It seems to be "yes", but it's really not clear.
[02:35:45] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Ping timeout)
[02:36:00] <cmr> aatch: yes, in concert with the personality, according to http://refspecs.linuxfoundation.org/abi-eh-1.22.html#layout
[02:36:11] <cmr> ctrl-f cleanup
[02:36:43] <vadimcn> aatch: look at $gcc\libgcc\unwind-dw2.c file
[02:36:50] <aatch> cmr, hmm, I'll see if libunwind does that.
[02:37:09] <aatch> (it should)
[02:37:09] <vadimcn> aatch: search for "personality"
[02:37:15] *** Quits: Sorella (quildreen@9D963F5D.DF5D8AE7.54BCAB54.IP) (Client exited)
[02:37:16] *** Joins: fyolnish (fyolnish@moz-BE2BAE5B.miinet.jp)
[02:37:28] <aatch> because that's the most important thing we need for our unwinding.
[02:38:14] *** Joins: Siyo (Siyo@A89938F4.87DAA49F.F113998C.IP)
[02:38:39] *** Joins: telotortium (rmi1@moz-C8F8CE6.hsd1.ca.comcast.net)
[02:38:48] *** Joins: alan_andrade (alan_andra@moz-7559582E.hsd1.ca.comcast.net)
[02:39:57] <vadimcn> acrichto: on the other hand, return code-based unwinding may have it's uses.  I'd expect driver writers to prefer it to table-based.
[02:40:26] <vadimcn> acrichto: not sure if that's enough reason to use it by default though...
[02:40:46] *** Quits: nkoep (nik@moz-5C99E1ED.vpn.rwth-aachen.de) (Client exited)
[02:40:54] *** Quits: nomadic (nomadic@moz-E01D5C49.hsd1.ga.comcast.net) (Quit: Leaving)
[02:40:55] <aatch> I think creating a generic "unwinding method" system in rustc would be good.
[02:41:03] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[02:41:40] *** Joins: p_adams (p_adams@moz-6E953D23.dhcp.stls.mo.charter.com)
[02:41:46] *** Quits: samx (sami@moz-D9DA5773.dyn.optonline.net) (Quit: This computer has gone to sleep)
[02:41:57] <aatch> So you can pick between them (though I'm not sure how well that would play with dynamic linking) and we default to the best option for that platform.
[02:42:45] *** Joins: colinsurprenant (colin@3656EB2A.F932EE3F.C0D2562E.IP)
[02:46:39] *** Quits: dbaupp (Thunderbir@1D1B1F7A.D5A1DCF.37681C44.IP) (Quit: dbaupp)
[02:46:43] *** Joins: dbaupp (Thunderbir@1D1B1F7A.D5A1DCF.37681C44.IP)
[02:46:49] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[02:49:09] *** Quits: dbaupp (Thunderbir@1D1B1F7A.D5A1DCF.37681C44.IP) (Quit: dbaupp)
[02:49:11] *** Joins: dbaupp (Thunderbir@1D1B1F7A.D5A1DCF.37681C44.IP)
[02:49:15] <acrichto> dbaupp: for this use case of drop, we deemed it ok, but we may be wrong as well. brson also had concerns
[02:49:25] <acrichto> the problem is where do you put drop/swap/replace?
[02:49:37] <dbaupp> acrichto: drop?
[02:49:47] <strcat> acrichto: mem
[02:49:49] <acrichto> dbaupp: oh whoops, wrong function prelude
[02:52:58] *** Joins: sk (sk@61A494B3.BA40E8A.AAC02D62.IP)
[02:52:59] *** Quits: anewnick (Mibbit@2AACB6E1.A033706C.284344F5.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[02:53:14] <vadimcn> hmm, so did we reach any conclusion here?
[02:53:42] *** Quits: p_adams (p_adams@moz-6E953D23.dhcp.stls.mo.charter.com) (Quit: WeeChat 0.4.2)
[02:53:51] <acrichto> vadimcn: the conclusion that I am at is that I know of no way to unwind other than libstdc++ and libgcc from mingw on windows
[02:54:07] <acrichto> vadimcn: if we can discover other options, then we should weigh them
[02:54:33] *** Joins: p_adams (p_adams@moz-6E953D23.dhcp.stls.mo.charter.com)
[02:54:33] *** Joins: canhtak (canhtak@moz-1D882009.wl.t.ulaval.ca)
[02:54:40] *** Joins: gdey (gdey@moz-E4449B64.sd.sd.cox.net)
[02:55:10] <vadimcn> acrichto: I can look into getting LLVM's unwinder to work on Windows, if's that's where Rust team wants to go
[02:55:43] *** Quits: Ralith (ralith@A8995AA9.62B6AF6A.922221DB.IP) (Ping timeout)
[02:55:51] <vadimcn> acrichto: ... or into skipping libstdc++and using libgcc directly
[02:56:15] <acrichto> vadimcn: I can't say for certain whether we would actually do that or not, the problem on osx/linux is that we need a very recent version of clang so we'd have to start building clang which is a large build overhead dependency
[02:56:24] <acrichto> vadimcn: but if you can drop libstdc++ entirely then that would be awesome
[02:56:51] <acrichto> vadimcn: I would accept that in a heartbeat no matter what (depending on the complexity)
[02:56:57] <acrichto> I don't think that's a windows-specific problem
[02:57:06] <vadimcn> vadimcn: what depends on clang exactly?
[02:57:09] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[02:57:20] <acrichto> building libcxxabi and the bundled libunwind for darwin
[02:57:36] <acrichto> we would build an external libunwind for linux, and I guess use libgcc on windows
[02:57:43] <acrichto> or we just wouldn't worry about statically linking libunwind right now
[02:57:48] <acrichto> and we would just drop the C++ dep
[02:57:53] <vadimcn> can't they be built with gcc?
[02:57:59] *** Joins: samx (sami@moz-D9DA5773.dyn.optonline.net)
[02:58:18] <acrichto> it could work, we don't need to do it
[02:58:26] <acrichto> that's just for statically linking "the libgcc equivalent" into libstd
[02:59:28] <vadimcn> can you please clarify?
[03:00:43] <acrichto> so right now we use {libstdc++, libgcc} everywhere, we can substitute libstdc++ for libcxxabi and libgcc for libunwind. I can get libunwind to build on darwin (with a very recent clang) and libunwind to build on linux (by bundling the repo), I cannot get libunwind to build on windows. If you could drop the libstdc++/libcxxabi half of things by calling the {libunwind/libgcc} dependency directly then that would be amazing
[03:00:56] *** Joins: m_kato (m_kato@moz-C286AD9A.bitcat.net)
[03:01:00] *** Quits: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com) (Quit: pcwalton)
[03:01:53] <vadimcn> I believe that libstdc++!=  libcxxabi
[03:01:55] <acrichto> the only reason to start building libunwind ourselves is to statically link this to libstd
[03:02:02] *** Joins: jvns (bork@moz-DE62990.nyc.res.rr.com)
[03:02:10] <acrichto> libcxxabi is the subset of libstdc++ that we require
[03:02:55] <acrichto> libstdc++ defines the entire c++ standard library, libcxxabi is only the exception handling bits (plus some other random things I think)
[03:04:25] <strcat> libsupc++ is the GNU equivalent to libc++abi
[03:04:47] <acrichto> ah yeah, and when I say libcxxabi I'm using it as a synonym for libc++abi
[03:05:53] *** Quits: zz_kimundi (kimundi@moz-19623CE3.dip0.t-ipconnect.de) (Ping timeout)
[03:07:02] <vadimcn> Rust could pick just the unwinding routines out of libcxxabi, by statically linking to it...    I'm saying this because libcxxabi being part of LLVM, there's higher chance it'll be maintained.
[03:07:31] <acrichto> vadimcn: yes, that is one possibility, that would drop the libstdc++ dep, but it would not drop the libgcc/libunwind dep
[03:07:44] *** Joins: prooftechnique (prooftechn@moz-1C9C6B71.hsd1.vt.comcast.net)
[03:07:55] <acrichto> vadimcn: also building libcxxabi is a pain, it requires a "very new" clang, which requires that we build clang as part of the build process
[03:07:57] <vadimcn> there are 3 unwinder implementations in the running:  libcxxabi, libgcc and libunwind
[03:08:29] <acrichto> oh ok slow down
[03:08:41] <acrichto> that may be the problem, libcxxabi is not an unwinding implementation
[03:08:52] <acrichto> libcxxabi requires something else to provide the unwinding
[03:08:55] <o11c> but libsupc++ might be easier to use than libcxxabi ...
[03:09:34] *** Joins: zz_kimundi (kimundi@moz-3DA1FAC3.dip0.t-ipconnect.de)
[03:10:03] *** zz_kimundi is now known as kimundi
[03:10:13] <vadimcn> acrichto: hmm, according to strcat, it does have unwinder implementation.  did I misunderstand that?
[03:10:39] <strcat> it's really immature
[03:10:47] <acrichto> vadimcn: it has an unwinder implementation in the source tree, but that is not built as part of libcxxabi, and it is a port of libunwind, and as far as I know it only works on darwin
[03:11:08] <acrichto> they are expected to get built separately, sadly libcxxabi is not this "magical thing" that will fix everything
[03:11:12] <ezyang> cmr: Nothing obvious, I think 
[03:11:17] <acrichto> I wanted it to be, but upon investigation it appeared to not be
[03:11:19] <cmr> ezyang: https://github.com/mozilla/rust/pull/10913
[03:11:40] *** Quits: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Quit: lkuper)
[03:12:02] <ezyang> sweet 
[03:12:03] *** Joins: ross (ross@moz-5EA04060.br.br.cox.net)
[03:12:06] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[03:12:59] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[03:14:48] *** Joins: SingingBoyo (SingingBoy@DA28FB90.A5D0D593.4F048BDC.IP)
[03:14:55] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[03:16:20] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Ping timeout)
[03:16:32] <vadimcn> acrichto: okay, I'll need to dig into this some more.
[03:16:42] *** Quits: telotortium (rmi1@moz-C8F8CE6.hsd1.ca.comcast.net) (Connection reset by peer)
[03:17:33] <vadimcn> ...but the sense I am getting, is that, all things being equal (which they aren't at the moment, of course), you guys would prefer to use LLVM's implementation rather than gcc's.
[03:17:40] <acrichto> vadimcn: awesome! If you have any questions, feel free to ping me. This is all stuff that I have uncovered so it could very well be mistaken in some spots
[03:17:45] <acrichto> that is correct
[03:17:51] <acrichto> although building all of clang is a sad thing to do
[03:21:10] *** Quits: ianj (ianjneu@moz-7BA002E.hsd1.ma.comcast.net) (Quit: leaving)
[03:22:48] <brson> i put in an order for another linux desktop to use as an android slave. i don't want to convert my minis to android slaves
[03:23:00] <brson> i hate build automation
[03:24:47] *** Quits: xitology (xi@85437D54.5AFA3E4.CEDFC552.IP) (Quit: Ex-Chat)
[03:26:58] <acrichto> zomg libnative builds so fast
[03:27:09] <acrichto> it spits out the warnings in like 10ms
[03:27:20] <cmr> what is libnative/libgreen?
[03:27:50] <acrichto> my extraction of 1:1 and M:N to libraries
[03:27:55] <acrichto> the scheduler is leaving libstd
[03:28:00] <cmr> neat
[03:28:10] <acrichto> basically anythin to do with tasks
[03:28:15] <acrichto> task spawning, task descheduling, etc
[03:28:28] <acrichto> the high level apis are still all in libstd, but their implementations will all be found elsewhere
[03:28:40] <dbaupp> the magic of traits & trait objects?
[03:28:52] <acrichto> yes :)
[03:29:04] <acrichto> plus some magic I have yet to figure out what it is and invent
[03:29:14] <acrichto> rightnow the start lang items are moving into libgreen/libnative
[03:29:22] <acrichto> but it should ideally remain in libstd (I think)
[03:29:37] *** Joins: Ralith (ralith@moz-132F2FD4.sea.wa.customer.broadstripe.net)
[03:29:55] *** Quits: fyolnish (fyolnish@moz-BE2BAE5B.miinet.jp) (Client exited)
[03:30:11] *** Joins: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP)
[03:31:13] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Quit: leaving)
[03:31:58] *** Quits: Addle (quassel@moz-67A92E8A.cable.teksavvy.com) (Ping timeout)
[03:32:56] *** Joins: Addle (quassel@moz-67A92E8A.cable.teksavvy.com)
[03:33:33] *** Joins: xitology (xi@85437D54.5AFA3E4.CEDFC552.IP)
[03:35:40] *** Quits: nsf (nsf@moz-EEF3238A.convex.ru) (Quit: WeeChat 0.4.2)
[03:36:39] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.2)
[03:38:59] *** Joins: Diamond (dick@moz-80556682.ks.ks.cox.net)
[03:40:06] *** Quits: lfox (lfox@12E8CF24.F74F95CB.ECED8BE3.IP) (Quit: )
[03:42:43] *** Quits: maxli (maxli@moz-4D28BA20.student.cs.uwaterloo.ca) (Quit: Leaving.)
[03:44:10] *** Joins: jeaye (Jeaye@moz-34FEF2BB.hsd1.ca.comcast.net)
[03:45:07] *** Joins: mib_iogvbd (Mibbit@727894BC.3BD0D21.65B957D6.IP)
[03:45:35] *** Joins: AvianFlu (AvianFlu@974D245D.130DDD13.67CD788C.IP)
[03:47:10] *** Joins: thewonderidiot1 (mike@moz-5506A033.hsd1.ca.comcast.net)
[03:49:30] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[03:51:56] *** Joins: huhlig-home (huhlig@moz-C8339267.hfc.comcastbusiness.net)
[03:53:51] *** Quits: huhlig-home (huhlig@moz-C8339267.hfc.comcastbusiness.net) (Ping timeout)
[03:54:14] *** Quits: p_adams (p_adams@moz-6E953D23.dhcp.stls.mo.charter.com) (Quit: WeeChat 0.4.2)
[03:54:23] *** Joins: jfbk (jfbk@moz-EEA9CFB3.nyc.res.rr.com)
[03:55:26] *** Joins: huhlig-home (huhlig@moz-C8339267.hfc.comcastbusiness.net)
[03:56:07] *** Quits: mib_iogvbd (Mibbit@727894BC.3BD0D21.65B957D6.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[03:56:08] *** Quits: AvianFlu (AvianFlu@974D245D.130DDD13.67CD788C.IP) (Connection reset by peer)
[03:56:28] *** Quits: jfbk (jfbk@moz-EEA9CFB3.nyc.res.rr.com) (Quit: )
[03:56:37] <aatch> rusti: let a = "Test"; a.slice_to(0)
[03:56:41] -rusti- ""
[04:02:33] *** Joins: jfbk (jfbk@moz-EEA9CFB3.nyc.res.rr.com)
[04:03:12] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Connection reset by peer)
[04:03:28] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[04:05:48] *** Joins: AvianFlu (AvianFlu@974D245D.130DDD13.67CD788C.IP)
[04:05:59] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[04:09:10] *** Quits: samx (sami@moz-D9DA5773.dyn.optonline.net) (Quit: This computer has gone to sleep)
[04:10:10] *** Quits: AvianFlu (AvianFlu@974D245D.130DDD13.67CD788C.IP) (Connection reset by peer)
[04:11:12] *** Joins: AvianFlu (AvianFlu@974D245D.130DDD13.67CD788C.IP)
[04:12:04] *** Quits: AvianFlu (AvianFlu@974D245D.130DDD13.67CD788C.IP) (Connection reset by peer)
[04:14:26] *** Joins: fyolnish (fyolnish@moz-BE2BAE5B.miinet.jp)
[04:15:00] *** Quits: ricepuddin (graham@moz-7D68765A.cable.virginm.net) (Ping timeout)
[04:15:46] *** Joins: AvianFlu (AvianFlu@974D245D.130DDD13.67CD788C.IP)
[04:16:08] *** Quits: fyolnish (fyolnish@moz-BE2BAE5B.miinet.jp) (Ping timeout)
[04:21:02] *** Quits: AvianFlu (AvianFlu@974D245D.130DDD13.67CD788C.IP) (Connection reset by peer)
[04:24:19] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[04:30:03] *** Joins: AvianFlu (AvianFlu@974D245D.130DDD13.67CD788C.IP)
[04:34:42] *** Joins: earlzlap (earlz@moz-483E1E31.neo.res.rr.com)
[04:34:59] *** Quits: jlong (jlong@moz-6DFDE846.socal.res.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[04:35:20] *** Quits: colinsurprenant (colin@3656EB2A.F932EE3F.C0D2562E.IP) (Quit: colinsurprenant)
[04:36:09] *** Quits: AvianFlu (AvianFlu@974D245D.130DDD13.67CD788C.IP) (Connection reset by peer)
[04:36:21] *** Joins: z0w0 (zack@moz-14B3BB9C.lns5.woo.bigpond.net.au)
[04:39:18] *** Joins: AvianFlu (AvianFlu@974D245D.130DDD13.67CD788C.IP)
[04:39:41] <apoelstra> is there a builtin way to randomly permute a vector?
[04:40:08] *** Quits: AvianFlu (AvianFlu@974D245D.130DDD13.67CD788C.IP) (Connection reset by peer)
[04:41:19] <sfackler> apoelstra: shuffle and shuffle_mut: http://static.rust-lang.org/doc/master/std/rand/trait.Rng.html#method.shuffle
[04:41:57] *** Joins: AvianFlu (AvianFlu@974D245D.130DDD13.67CD788C.IP)
[04:43:27] *** Quits: maxiepoo (mnew@moz-6F50ADE.hsd1.il.comcast.net) (Ping timeout)
[04:46:24] <dbaupp> rusti: std::rand::task_rng().shuffle(~[1,2,3])
[04:46:25] -rusti- <anon>:9:8: 10:5 error: type `@mut std::rand::IsaacRng` does not implement any method in scope named `shuffle`
[04:46:25] -rusti- <anon>:9         std::rand::task_rng().shuffle(~[1,2,3])
[04:46:25] -rusti- <anon>:10     };
[04:46:25] -rusti- error: aborting due to previous error
[04:46:25] -rusti- application terminated with error code 101
[04:46:41] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Quit: yichoi)
[04:46:42] <dbaupp> rusti: use std::rand::{RngUtil}; std::rand::task_rng().shuffle(~[1,2,3])
[04:46:43] -rusti- pastebinned 8 lines of output: http://sprunge.us/HQUW
[04:46:55] <dbaupp> rusti: use std::rand::{Rng}; std::rand::task_rng().shuffle(~[1,2,3])
[04:46:57] -rusti- ~[2, 1, 3]
[04:47:01] *** Quits: jfbk (jfbk@moz-EEA9CFB3.nyc.res.rr.com) (Quit: )
[04:47:20] *** Joins: fyolnish (fyolnish@moz-BE2BAE5B.miinet.jp)
[04:48:09] <apoelstra> thanks much guys :)
[04:48:16] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[04:48:39] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Quit: yichoi)
[04:51:29] *** Quits: AvianFlu (AvianFlu@974D245D.130DDD13.67CD788C.IP) (Connection reset by peer)
[04:52:31] *** Joins: AvianFlu (AvianFlu@974D245D.130DDD13.67CD788C.IP)
[04:57:06] *** Quits: Addle (quassel@moz-67A92E8A.cable.teksavvy.com) (Ping timeout)
[05:00:13] *** Quits: AvianFlu (AvianFlu@974D245D.130DDD13.67CD788C.IP) (Connection reset by peer)
[05:00:15] *** Joins: AvianFlu_ (AvianFlu@974D245D.130DDD13.67CD788C.IP)
[05:00:46] *** Joins: Addle (quassel@moz-67A92E8A.cable.teksavvy.com)
[05:00:46] *** Quits: AvianFlu_ (AvianFlu@974D245D.130DDD13.67CD788C.IP) (Connection reset by peer)
[05:02:31] *** Joins: AvianFlu (AvianFlu@974D245D.130DDD13.67CD788C.IP)
[05:03:36] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[05:07:53] *** Quits: canhtak (canhtak@moz-1D882009.wl.t.ulaval.ca) (Quit: canhtak)
[05:10:15] *** Quits: AvianFlu (AvianFlu@974D245D.130DDD13.67CD788C.IP) (Connection reset by peer)
[05:11:17] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[05:11:36] *** Joins: AvianFlu (AvianFlu@974D245D.130DDD13.67CD788C.IP)
[05:13:18] *** Quits: AvianFlu (AvianFlu@974D245D.130DDD13.67CD788C.IP) (Connection reset by peer)
[05:13:19] *** Joins: nsf (nsf@moz-EEF3238A.convex.ru)
[05:13:32] *** Joins: june0cho (june0.cho@5AB4884B.FCC4549.14D5B978.IP)
[05:14:04] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[05:14:13] *** Joins: AvianFlu (AvianFlu@974D245D.130DDD13.67CD788C.IP)
[05:14:13] *** Joins: pradeep (pradeep@5AB4884B.FCC4549.14D5B978.IP)
[05:15:09] *** Quits: tiffany (kawaii@moz-FC0DB29D.dhcp.embarqhsd.net) (Input/output error)
[05:15:56] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[05:17:28] *** Quits: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net) (Ping timeout)
[05:20:47] <june0cho> hello! I have one question. When I try to re-build rust using make after some modification, is there any method to build only submodule(e.g. std library)?
[05:26:24] *** Quits: AvianFlu (AvianFlu@974D245D.130DDD13.67CD788C.IP) (Connection reset by peer)
[05:26:34] *** Joins: beifeng (Mibbit@284C36E7.3062CEC3.670EEFD.IP)
[05:27:00] *** Joins: AvianFlu (AvianFlu@974D245D.130DDD13.67CD788C.IP)
[05:28:02] *** Quits: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[05:30:17] *** Joins: AvianFlu_ (AvianFlu@974D245D.130DDD13.67CD788C.IP)
[05:30:17] *** Quits: AvianFlu (AvianFlu@974D245D.130DDD13.67CD788C.IP) (Connection reset by peer)
[05:32:55] <jdm> june0cho: if you're just building rust, yes
[05:33:01] <jdm> if you're building it as part of servo, no
[05:33:18] *** Quits: jeaye (Jeaye@moz-34FEF2BB.hsd1.ca.comcast.net) (Quit: zzz)
[05:34:26] <jdm> https://github.com/mozilla/rust/wiki/Note-build-system
[05:34:52] <jdm> I'm not sure that that lists the fastest way to build libstd
[05:34:57] <jdm> cmr: do you recall?
[05:35:21] <jdm> aha!
[05:35:25] <jdm> Build and test std without re-bootstrapping: make check-stage1-std NO_REBUILD=1 - This makes the build/test cycle much faster.
[05:35:28] <jdm> from https://github.com/mozilla/rust/wiki/Note-testsuite
[05:36:33] <mark_edward> how do i declate a struct with a member that is an extern "C" function?
[05:37:37] <sfackler> Foo { f: extern "C" fn(arg1, arg2) -> ret }
[05:39:29] <mark_edward> sfackler, thanks!
[05:39:46] *** Quits: earlzlap (earlz@moz-483E1E31.neo.res.rr.com) (Ping timeout)
[05:40:06] <june0cho> jdm: I meant rust. Thanks! :)
[05:40:36] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Ping timeout)
[05:41:00] *** Quits: z0w0 (zack@moz-14B3BB9C.lns5.woo.bigpond.net.au) (Quit: z0w0)
[05:42:02] *** Joins: eddyb (eddy@moz-68E0B7D0.residential.rdsnet.ro)
[05:44:18] *** Quits: alisdair (textual@28441AAB.AC6E1995.F0AE27BD.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[05:45:49] *** Joins: ptc (Adium@moz-192425C4.nyc.res.rr.com)
[05:47:22] *** Quits: dxza (reisen@moz-BAE4CA9C.cable.virginm.net) (Quit: leaving)
[05:51:35] *** Quits: dbaupp (Thunderbir@1D1B1F7A.D5A1DCF.37681C44.IP) (Ping timeout)
[05:53:28] *** Quits: engla_ (engla@moz-F64E1B0F.cust.bredbandsbolaget.se) (Ping timeout)
[05:54:12] *** sam113101 is now known as sam113101_afk
[05:54:53] *** sam113101_afk is now known as sam113101
[05:55:26] *** Joins: sankha93 (Instantbir@D5222D53.35354309.EFB84E89.IP)
[05:55:32] *** Joins: ksev (DrunkenPan@moz-65085A9A.bredband.skanova.com)
[05:56:15] *** Joins: alisdair (textual@28441AAB.AC6E1995.F0AE27BD.IP)
[05:56:23] *** Parts: thewonderidiot1 (mike@moz-5506A033.hsd1.ca.comcast.net) ()
[05:57:06] *** Quits: sankha93 (Instantbir@D5222D53.35354309.EFB84E89.IP) (Ping timeout)
[05:59:39] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Ping timeout)
[06:00:18] *** Joins: AvianFlu (AvianFlu@974D245D.130DDD13.67CD788C.IP)
[06:00:18] *** Quits: AvianFlu_ (AvianFlu@974D245D.130DDD13.67CD788C.IP) (Connection reset by peer)
[06:03:10] *** Quits: KindOne (KindOne@ED707493.99EE53D4.34F73994.IP) (Ping timeout)
[06:04:50] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[06:07:25] *** Quits: AvianFlu (AvianFlu@974D245D.130DDD13.67CD788C.IP) (Input/output error)
[06:07:34] *** Joins: KindOne (KindOne@moz-FDF55302.dynamic.ip.windstream.net)
[06:07:56] *** Quits: jvns (bork@moz-DE62990.nyc.res.rr.com) (Ping timeout)
[06:08:16] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[06:08:30] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[06:10:59] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[06:11:02] *** Joins: mib_szeohi (Mibbit@6B6F4036.AB331A3B.FAED9FFC.IP)
[06:12:57] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Client exited)
[06:16:39] *** Quits: mib_szeohi (Mibbit@6B6F4036.AB331A3B.FAED9FFC.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[06:16:46] *** Joins: sprocket (Mibbit@6B6F4036.AB331A3B.FAED9FFC.IP)
[06:17:45] *** Quits: sprocket (Mibbit@6B6F4036.AB331A3B.FAED9FFC.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[06:20:59] *** Quits: osa1__ (omer@moz-8FDAB45C.hsd1.il.comcast.net) (Ping timeout)
[06:21:38] *** Joins: osa1__ (omer@moz-8FDAB45C.hsd1.il.comcast.net)
[06:22:09] *** Quits: sk (sk@61A494B3.BA40E8A.AAC02D62.IP) (Input/output error)
[06:29:36] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[06:30:32] *** Quits: hoverbear (hoverbear@moz-86FCBF4B.gv.shawcable.net) (Quit: Hibernating, be back soon.)
[06:39:15] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[06:40:07] *** Quits: cubic (cubic@moz-80241A3A.mc.videotron.ca) (Quit: Leaving)
[06:40:38] *** Joins: nano (nano@moz-ED77243C.superkabel.de)
[06:48:54] *** Quits: lpy (lpy@7360AA58.F09091A8.1348A864.IP) (Quit: Leaving...)
[06:49:00] *** Joins: lpy (lpy@7360AA58.F09091A8.1348A864.IP)
[06:49:40] *** Quits: ptc (Adium@moz-192425C4.nyc.res.rr.com) (Quit: Leaving.)
[06:49:52] *** Quits: lpy (lpy@7360AA58.F09091A8.1348A864.IP) (Quit: Leaving...)
[06:52:41] *** Quits: alan_andrade (alan_andra@moz-7559582E.hsd1.ca.comcast.net) (Input/output error)
[06:55:05] *** Quits: voxpopuli (fanservice@moz-FE161659.wv.cc.cmu.edu) (Ping timeout)
[06:56:09] <gdey> Hello all, this my be a silly question, but I'm learning rust. I am not sure why this line of rust code does not compile: println(format!("It is true that 3 _ 5 < 5 - 7? {:s}", if 3 + 2 < 5 - 7 { "yes" } else { "no" }));
[06:56:34] <gdey> I'm assuming that since is an expression it should be valid anywhere an expression is valid.
[06:56:58] <gdey> The error I get is : format argument must be a string literal.
[06:57:13] <gdey> Is my understanding of 'if' wrong?
[06:57:21] *** Quits: devbug (quassel@23AC5F12.9D950176.3655BBF5.IP) (Ping timeout)
[06:59:13] <klutzy> gdey: it seems to work on master. what error did you get?
[06:59:50] <gdey> Press ENTER or type command to continue
[06:59:50] <gdey> ex3.rs:15:12: 15:63 error: format argument must be a string literal.
[06:59:50] <gdey> ex3.rs:15    println!(format!( "Is it true that 3 + 2 < 5 - 7? {:s}",ans));
[06:59:50] <gdey>                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[06:59:50] <gdey> libc++abi.dylib: terminating with uncaught exception of type unsigned long
[06:59:50] <gdey> Command terminated
[06:59:58] <gdey> sorry.
[07:00:07] *** Joins: pepper_chico (pepper_chi@6D1D0FAA.4F150827.E4090502.IP)
[07:00:11] *** Quits: nano (nano@moz-ED77243C.superkabel.de) (Connection reset by peer)
[07:01:58] <klutzy> gdey: println!(...) (ending with !) accepts string literals e.g. "{:s}", while println(...) (no !) accepts ordinay string.
[07:02:18] <klutzy> gdey: and format!(...) makes an allocated string (~str), not a literal
[07:02:30] <klutzy> so s/println!/println/ will work
[07:02:48] <gdey> k, I'll try that, thanks!
[07:03:11] <gdey> here is the gist of the files I'm working with. https://gist.github.com/gdey/7906135
[07:03:45] <gdey> can you explain to me why  println(format!("Now I will count the eggs: {:d}",
[07:03:45] <gdey>         3 + 4 + 1 - 5 + 4 % 4 -1 /4 + 6 ));
[07:03:55] <gdey> compiles without issue then?
[07:05:54] <gdey> I change the println to println! and am still getting the same error. (I'm using rust 0.8; BTW)
[07:06:04] <gdey> used homebrew on my mac to install it.
[07:10:52] *** Quits: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net) (Quit: Sharp)
[07:10:56] <eddyb> gdey: println is a function. println! is a macro
[07:11:09] <klutzy> gdey: format! and println! require format argument at first, which is string constant literal ("asdf", not ~"asdf" nor &"asdf")
[07:11:17] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[07:11:18] *** Joins: dbaupp (Thunderbir@moz-EB2EFE6F.lns20.syd6.internode.on.net)
[07:11:20] <cmr> and especially not format!(...)
[07:11:24] *** Quits: pepper_chico (pepper_chi@6D1D0FAA.4F150827.E4090502.IP) (Quit: Ex-Chat)
[07:11:38] <eddyb> dbaupp: upboat for yak shaving logo :3
[07:11:49] <dbaupp> heh
[07:12:00] <eddyb> though it's missing teh rusty shears
[07:12:20] *** Joins: victorporof (victorporo@C8C495F5.E3195F0D.9B1E38F4.IP)
[07:13:37] <dbaupp> gdey: fwiw, println!(....) is exactly equivalent to println(format!(...)) (note teh lack of !), except the former is more efficient, as it doesm't allocate the intermediate string from the format.
[07:13:50] <cmr> (on master)\
[07:14:17] <dbaupp> cmr: did 0.8 do println(format!()) for println!()?
[07:14:27] <cmr> dbaupp: pretty sure it did!
[07:14:44] <cmr> but it definitely doesn't on master :)
[07:14:47] <eddyb> yupp, complained about that when I saw it in rusti
[07:15:11] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[07:15:48] <eddyb> print!(..args) should just be write!(::std::io::stdio(), ..args) or something like that
[07:15:59] <dbaupp> eddyb: it basically is
[07:16:04] <dbaupp> (now)
[07:16:20] <dbaupp> https://github.com/mozilla/rust/blob/master/src/libsyntax/ext/expand.rs#L900
[07:16:54] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[07:17:01] <eddyb> I guess that might be slightly faster than the Writer interface :/
[07:20:19] <gdey> Okay, I'm confused, as to whay I was doing wrong now.
[07:20:52] <eddyb> gdey: format! and println! are macros which need a constant string literal *to work*
[07:20:58] <gdey> It's all working now. So, then the following 6 lines are equ:
[07:21:23] <eddyb> (don't paste a lot of lines, if that's what you're planning to do)
[07:21:25] *** Joins: pepper_chico (pepper_chi@6D1D0FAA.4F150827.E4090502.IP)
[07:21:36] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[07:21:51] <gdey> https://gist.github.com/gdey/7906260
[07:22:05] *** Joins: fabiand (fabiand@moz-E98E5E08.adsl.alicedsl.de)
[07:22:17] <gdey> Sorry, took me some time to prep the gist.
[07:23:02] <dbaupp> gdey: yes
[07:23:08] <eddyb> fmt is deprecated
[07:23:14] *** Quits: whidgle (Mibbit@moz-68235C3E.customer.broadstripe.net) (Quit: http://www.mibbit.com ajax IRC Client)
[07:23:23] <eddyb> but apart from that, it looks ok
[07:23:31] <dbaupp>  the best one to use is the `println!` :)
[07:23:34] *** Joins: alan_and_ (alan_andra@moz-7559582E.hsd1.ca.comcast.net)
[07:23:48] <eddyb> gdey: I don't think you need allocation for if x { ~"yes" } else { ~"no" }
[07:24:03] <eddyb> rusti: if true { "yes" } else { "no" }
[07:24:03] -rusti- "yes"
[07:24:18] <gdey> okay.
[07:24:49] <gdey> I'm still trying to get the rules strait for when to use ~"str" v.s. static str.
[07:25:12] <eddyb> use ~ as least as possible
[07:25:17] <SiegeLord> Never use ~"str"
[07:25:37] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Client exited)
[07:25:43] <eddyb> SiegeLord: except Err(~str) :(
[07:25:54] <SiegeLord> Yes, except when you are actually asked it
[07:25:57] <eddyb> we need SendStr
[07:26:10] <eddyb> &'static str | ~str
[07:27:04] <SiegeLord> I guess you want ~str for when you're building a string too... but that shouldn't be too common
[07:27:05] <dbaupp> eddyb: we have SendStr
[07:27:11] <dbaupp> std::send_str
[07:27:20] <eddyb> nvm then
[07:27:50] * eddyb wonders if it's possible to make a SmallStr support both &'static str and ~str in the long case
[07:27:53] <SiegeLord> Hmm... I should use SendStr in my API... maybe
[07:28:07] <SiegeLord> Too bad the constructors will make it super ugly
[07:28:53] *** Quits: alan_and_ (alan_andra@moz-7559582E.hsd1.ca.comcast.net) (Ping timeout)
[07:29:07] <dbaupp> SiegeLord: there's a .into_send_str() method, iirc
[07:29:36] * dbaupp reckons having properly overloaded number, string and vector literals would be nice
[07:30:06] <SiegeLord> That's barely shorter...
[07:30:16] <gdey> Thanks for the help!
[07:30:35] <SiegeLord> Oh well, not a performance critical API
[07:30:42] <SiegeLord> Setting labels for plot axis ticks
[07:30:51] <dbaupp> SiegeLord: it might be nicer than importing the constructors everywhere, since, IIRC, the trait providing that method is in the prelude
[07:31:05] <SiegeLord> Ah
[07:31:11] *** Quits: Leo` (Leo@moz-83832FE2.placeholder.fr) (Max SendQ exceeded)
[07:31:27] *** Joins: Leo` (Leo@moz-83832FE2.placeholder.fr)
[07:32:59] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Connection reset by peer)
[07:34:17] <eddyb> you can always take another bit from the length of a SmallStr. I mean, who needs a string longer than 1.88GB on 32-bit systems? why would you even use a SmallStr in that case?
[07:35:15] <eddyb> and there's always the Pascal/Dephi weirdness, where the least significant bit of a string selects between static and dynamic (and, at least in the dynamic case, the length is just before the start of the string)
[07:36:40] *** Joins: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net)
[07:38:40] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[07:39:16] *** Joins: alex-abreu (alex@moz-4B4D75AD.rev.sfr.net)
[07:39:52] <xitology> from the tutorial: "Custom destructors can only be implemented directly on types that are Send, <...>. Example of types which are not Send are Gc<T> and Rc<T>, <...>."  But Rc<T> does have a destructor, doesn't it?
[07:40:45] <cmr> Oh hm
[07:41:15] <cmr> rusti: use std::rc::Rc; struct Foo { x: Rc<int> } impl Drop for Foo { fn drop(&self) { println("drop"); } }
[07:41:17] -rusti- pastebinned 8 lines of output: http://sprunge.us/HcAC
[07:41:54] <cmr> rusti: use extra::rc::Rc; struct Foo { x: Rc<int> } impl Drop for Foo { fn drop(&self) { println("drop"); } }
[07:41:55] -rusti- <anon>:9:73: 9:108 error: method `drop` has an incompatible type: values differ in mutability
[07:41:55] -rusti- <anon>:9         use extra::rc::Rc; struct Foo { x: Rc<int> } impl Drop for Foo { fn drop(&self) { println("drop"); } }
[07:41:55] -rusti-                                                                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[07:41:55] -rusti- error: aborting due to previous error
[07:41:58] -rusti- application terminated with error code 101
[07:42:00] <cmr> rusti: use extra::rc::Rc; struct Foo { x: Rc<int> } impl Drop for Foo { fn drop(&mut self) { println("drop"); } }
[07:42:01] -rusti- pastebinned 8 lines of output: http://sprunge.us/bDDb
[07:42:07] <cmr> There, finally.
[07:42:09] <cmr> xitology: Oh, yes.
[07:42:32] <dbaupp> rusti: use extra::rc::Rc; struct Foo { x: Rc<int> } #[unsafe_destructor] impl Drop for Foo { fn drop(&mut self) { println("drop"); } }
[07:42:33] -rusti- ()
[07:42:42] <cmr> xitology: The reason Rc implement drop even though it's non-Send is that it uses #[unsafe_destructor]
[07:42:47] <cmr> yeah, what dbaupp did.
[07:43:19] <eddyb> so why Send?
[07:43:32] <xitology> i see... so you can't do it, but if you really want, you can
[07:43:34] <cmr> eddyb: non-Send can have cycles.
[07:43:40] <cmr> xitology: it's not safe to do.
[07:43:50] <eddyb> cmr: aaah, dtor recursion?
[07:44:09] <eddyb> that sounds like fun
[07:44:34] <eddyb> rust needs a FrequentlyAskedWhy's list
[07:44:40] <cmr> start one.
[07:45:59] <dbaupp> eddyb: not just dtor recursion; there's not even a well-defined place to start calling the dtors in a cycle
[07:46:17] <dbaupp> since you'll be invalidating an object that is referred to be some other live one
[07:46:45] <ssbr> eddyb: ooh, yes please
[07:47:06] <cmr> ssbr: you still working on regexp?
[07:47:09] *** Quits: nathan7 (nathan@moz-60FC7746.nathan7.eu) (Ping timeout)
[07:47:15] <ssbr> I keep forgetting which of ~Option<T> and Option<~T> get represented as a nullable pointer
[07:47:20] <cmr> Option<~T>
[07:47:26] <cmr> ~T is a non-nullable pointer.
[07:47:36] <cmr> ~Option<T> is too
[07:47:58] <ssbr> oh right, you need to be able to dereference ~T
[07:48:05] <ssbr> cmr: I haven't touched the codebase in a few days, does that count as still working on it
[07:48:22] <ssbr> there is a discussion on the bug tracker where some people that are more active than me at this want to do stuff
[07:48:34] <ssbr> I like that idea, we can pool resources and stuff. Always better than going it alone.
[07:48:48] <cmr> Well "regexp support!" was a popular request in my "ask cmr to do things" thread
[07:49:04] *** Quits: andor (andor@moz-708868D.neferty.me) (Ping timeout)
[07:49:09] <cmr> I don't particularly /want/ to add regexp support, and certainly not to the extent which you and others have thought about it
[07:49:17] <cmr> But I can add something simple like lua patterns.
[07:49:22] <ssbr> cmr: then you can tell them "that's OK, <XYZ> are on the case"
[07:49:27] <dbaupp> ssbr: is your code online?
[07:49:39] <cmr> (it would take me forever to do proper regex, not in my current area of knowledge)
[07:49:46] <ssbr> dbaupp: no, and it's miniscule anyway
[07:49:51] *** Joins: nathan7 (nathan@moz-60FC7746.nathan7.eu)
[07:50:11] <ssbr> I have a parser, a crappy compiler/VM, and a test suite, and the test suite doesn't work yet because difficulties
[07:50:24] <dbaupp> parsers are good
[07:50:28] <ssbr> parsers are horrible
[07:50:40] <dbaupp> well, having a prewritten one is good :P
[07:50:41] <ssbr> I didn't realize it'd be the bulk of the work, but it was. Writing a VM is easy in comparison. :(
[07:50:48] <ssbr> the parser isn't even finished
[07:50:52] <ssbr> I don't even like writing parsers
[07:50:56] * ssbr whines more
[07:51:04] <dbaupp> write one using regexps
[07:51:12] *** Quits: sigma (sigma@moz-A17EB325.range86-184.btcentralplus.com) (Client exited)
[07:51:12] <dbaupp> bootstrap a regex engine \o/
[07:51:13] *** Joins: morphevs (Adium@moz-5C485CFA.ethz.ch)
[07:51:19] <ssbr> I thought about making it self-hosting, and then I remembered I hate self-hosting compilers
[07:51:33] <ssbr> anyway that doesn't help much, since I abandoned the idea of doing separate lexing/parsing steps
[07:52:10] <ssbr> it's just a naive recursive descent parser that happens to be pretty efficient because the regexp grammar has almost no backtracking
[07:52:13] *** Quits: Leo` (Leo@moz-83832FE2.placeholder.fr) (Max SendQ exceeded)
[07:52:27] *** Joins: sk (sk@9E6B574B.EB2AA036.2CAF0D3B.IP)
[07:52:33] <ssbr> I don't like it even then, you can make very efficient parsers by avoiding creating an intermediate AST. RE2 does that. I lack the skill.
[07:52:34] *** Joins: Leo` (Leo@moz-83832FE2.placeholder.fr)
[07:52:52] *** Quits: TobiasFar (tm@moz-A929D162.flosoft-servers.net) (Ping timeout)
[07:53:05] * o11c is currently writing code to parse flex files
[07:53:10] <ssbr> anyway, there's some people that wrote stuff for regexps in rust
[07:53:45] <dbaupp> ssbr: presumably the most common regexps are compile-time constants, so having the compilation be slow, but running at compile time would be ok (and awesome!)
[07:53:49] <ssbr> hopefully we can all agree on stuff
[07:54:04] *** Joins: sigma (sigma@moz-A17EB325.range86-184.btcentralplus.com)
[07:54:51] *** Joins: z0w0 (zack@moz-14B3BB9C.lns5.woo.bigpond.net.au)
[07:55:07] <dbaupp> ssbr: agreement when there is an opportunity for bikeshedding? what sort of fantasy world are you living in? :P
[07:55:13] <ssbr> dbaupp: Even at runtime, slower compilation is preferred. But unnecessarily slow compilation is still unnecessarily slow.
[07:55:37] *** Joins: Ferreus (ferreus@moz-DC788BAF.dip0.t-ipconnect.de)
[07:55:37] <ssbr> dbaupp: the degree of bikeshedding possible is enormous, it's true
[07:56:52] <ssbr> on the plus side, I totally colored the shed blue a long time ago and nobody disagreed with it, so maybe everyone just goes with the flow?
[07:57:04] *** Joins: TobiasFar (tm@moz-A929D162.flosoft-servers.net)
[07:57:21] <ssbr> dbaupp: anyway yeah, I keep meaning to upload the code, but I keep meaning on having a runnable test suite first
[07:57:30] <ssbr> I have to send the code to my employer to review before I can upload it, also.
[07:57:40] <ssbr> because ~software companies~
[07:57:45] * ssbr spits
[07:58:05] <dbaupp> oh, yet another reason you shouldn't've done that "get a job" thing :P
[07:58:22] <ssbr> yeah, it's been absolutely terrible for my productivity writing rust code
[07:58:33] <dbaupp> is it likely they'll complain about/veto the code?
[07:58:38] <ssbr> I mean, instead of writing rust, I'm either working, or watching dr who on that PS3 I bought with that money I now have
[07:58:50] <ssbr> dbaupp: there is exactly a 0% chance they would block it. :)
[07:59:12] <dbaupp> oh, that's not so bad then :)
[07:59:21] *** Quits: ross (ross@moz-5EA04060.br.br.cox.net) (Quit: )
[07:59:27] <ssbr> they would have to manually approve the first half-dozen patches though, IIUC
[07:59:35] <eddyb> ssbr: get Rust working on PS3
[07:59:37] <eddyb> then it's useful for something
[08:00:07] <ssbr> eddyb: useful for making games last year, yeah
[08:00:26] <ssbr> I got the PS3 like a week after the PS4 came out. Good time to buy.
[08:00:48] <eddyb> at this point, you can probably get cheap second hands that still work
[08:01:09] <ssbr> most definitely
[08:01:47] <eddyb> I still need to get 4GB of RAM for my laptop so I can have 20 browser tabs open *and* compile rustc at the same time
[08:01:50] <ssbr> anyway, idk, if I were to port Rust to anything, I'd want to write some kind of Rust -> OpenCL thing.
[08:02:04] <eddyb> maybe even compile two different clones of rustc at the same time
[08:02:10] <ssbr> the mapping from Rust to OpenCL C isn't difficult in principle, but I guess the details are annoying.
[08:02:17] <ssbr> And GPGPU is great fun.
[08:02:20] *** Quits: fhahn (fhahn@moz-7924DB5C.vie.surfer.at) (Ping timeout)
[08:02:21] <ssbr> Safe GPGPU would be awesome.
[08:02:37] <eddyb> ssbr: I think most OpenCL implementations use LLVM, so maybe high-level conversion is the wrong place to start
[08:02:55] <ssbr> eddyb: sure, probably, but then most OpenCL implementations are closed source, so it might be all you have.,
[08:03:03] <eddyb> erm
[08:03:14] <ssbr> a problem is that Rust is completely awful for the way GPGPU works
[08:03:27] <eddyb> there has to be info somewhere, but I doubt most of them are monolithic
[08:03:32] <ssbr> there's no way to mutably borrow distinct vector members in rust even if you can convince the compiler they're distinct
[08:03:53] <ssbr> If I remember right, anyway. And that's basically the entire basis of OpenCL programming. Pow, gone. In today's Rust.
[08:03:58] <eddyb> ssbr: because there's no real concept of compile-time constants
[08:04:03] <dbaupp> ssbr: you can have a safe interface to unsfae code
[08:04:15] <dbaupp> ssbr: also, did you see http://www.cs.indiana.edu/~eholk/papers/hips2013.pdf ?
[08:04:36] <ssbr> dbaupp: I saw a reference to it once but never dug in
[08:05:03] <ssbr> dbaupp: I guess it's true that you could specify how to split up the array in a way that typechecks and doesn't look like mutable borrows of array elements
[08:06:34] <ssbr> I was going to write an "X instead of Y", but the problem with Rust is deeper than I thought, nevermind. Totally can't express "take an array as a parameter and borrow the ith element". Can't be done.
[08:06:43] <ssbr> Rust would need indexed types for that to make sense maybe.
[08:07:21] <ssbr> cmr: you should implement indexed types to let us avoid superfluous bounds checks at runtime, yes yes
[08:08:14] <ssbr> dbaupp: egh, that isn't a safe interface :(
[08:08:17] *** Quits: Leo` (Leo@moz-83832FE2.placeholder.fr) (Max SendQ exceeded)
[08:08:38] <ssbr> dbaupp: they do fn foo(x: ~[uint]) { x[get_global_id(0)] += 1}
[08:08:47] *** Joins: Leo` (Leo@moz-83832FE2.placeholder.fr)
[08:08:51] <ssbr> you get a race condition if you do x[0] += 1 instead
[08:10:41] <dbaupp> ah
[08:11:09] *** pmoore|away is now known as pmoore
[08:11:11] *** Joins: napoleon (Mibbit@moz-E1FF077C.rev.numericable.fr)
[08:11:19] <dbaupp> might need something like `foo(x: &mut uint) { ... }` where that's already extracted the appropriate element
[08:11:21] <eddyb> you don't want a plain vector for that
[08:11:34] <dbaupp> but that's infleixble if you need more than just one
[08:11:37] <eddyb> but rather a PartitionedVector
[08:11:38] <ssbr> dbaupp: sure, but then how do you tell opencl how to pull the uint from the uint vector?
[08:11:47] <dbaupp> ssbr: dunno
[08:12:06] <dbaupp> ssbr: I believe that paper covers some of this stuff
[08:12:10] <vky> Hey, make tidy is throwing "make: *** [tidy] Error 123", any way to get more information out of it?
[08:12:14] <dbaupp> but I haven't read it in much detail
[08:12:17] <ssbr> e.g. maybe you want to do x[get_global_id(0) * get_size(1) + get_global_id(1)] -- or maybe x[get_global_id(1) * get_size(0) + get_global_id(0)]
[08:12:33] <eddyb> ssbr: see what I just said :P
[08:12:35] <dbaupp> vky: there is probably a line above that saying something like "trailing whitespace" or "line too long" hidden amongst the NOTEs
[08:12:36] <ssbr> egh, get_global_size
[08:12:44] <ssbr> eddyb: is a PartitionedVector already a type?
[08:12:49] <eddyb> the safe way to do this is without calling those get functions yourself
[08:12:56] <eddyb> ssbr: no, it would be something OpenCL-specific
[08:13:02] <ssbr> eddyb: Sure, but how do you specify it to OpenCL?
[08:13:29] *** flaper87|afk is now known as flaper87
[08:13:29] <eddyb> using those helper functions
[08:13:34] <ssbr> or rather, to the compiler that translates rust to opencl
[08:13:40] <ssbr> eddyb: what helper functions? :(
[08:13:48] <eddyb> get_global_id and whatnot
[08:14:01] <vky> dbaupp: ah, so there are. one's an incorrect license and the rest are all "NOTE: remove after the next snapshot". Can I ignore those?
[08:14:12] *** Joins: d3xter (sinz@moz-904AC055.atmpu0028.highway.a1.net)
[08:14:13] <ssbr> eddyb: Oh, sure. But then that's not a safe interface.
[08:14:21] <eddyb> you need a number of concurrent cores, or something like that
[08:14:41] <ssbr> unless Rust somehow checks that the usages don't overlap
[08:14:55] <eddyb> ssbr: erm, it's an abstraction
[08:14:56] <dbaupp> vky: yes, the NOTEs are not relevant
[08:15:04] <d3xter> hey guys
[08:15:09] <ssbr> eddyb: What's the abstraction?
[08:15:13] <eddyb> ssbr: a safe interface implemented with unsafe code. the entire std is like this
[08:15:15] <vky> dbaupp: cool, thanks.
[08:15:16] *** Quits: k4nar (quassel@moz-F5EFF779.kimsufi.com) (Quit: No Ping reply in 180 seconds.)
[08:15:24] <ssbr> eddyb: Yes, I've been asking how you're supposed to express this safely
[08:15:29] *** Joins: k4nar (quassel@moz-F5EFF779.kimsufi.com)
[08:15:33] <dbaupp> eddyb: although that's not necessary safe :P
[08:15:43] <dbaupp> ssbr: read that paper, if you haven't done so already :)
[08:15:44] <ssbr> eddyb: I interpreted your answer as "replace vectors with PartitionedVector and do the same thing as before"
[08:15:54] *** Quits: ab (alex@BC9D99CC.37C1012D.FE617B51.IP) (Ping timeout)
[08:16:01] <d3xter> i'm trying to compile a new program, but rust complains about "main is not UTF-8 encoded", but "file -bi" says "charset=utf-8". any hints?
[08:16:03] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[08:16:04] <eddyb> ssbr: partitioned_vec[i] would be actual_vec[i * num_of_cores + core_id]
[08:16:45] <ssbr> well, not num_of_cores
[08:16:58] <ssbr> eddyb: that's a bit too high level to be useful :(
[08:17:05] <eddyb> ssbr: why?
[08:18:26] <ssbr> eddyb: GPUs don't have cores in the same sense, and that's a strictly one-dimensional mapping.
[08:18:26] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Input/output error)
[08:18:52] <ssbr> eddyb: it also doesn't allow for stuff to be allocated according to local_id
[08:18:55] <eddyb> ssbr: you'd use multi-dimensional versions
[08:19:07] *** Quits: nathan7 (nathan@moz-60FC7746.nathan7.eu) (Ping timeout)
[08:19:12] <ssbr> plus you often want to change how data is accessed rather than how its laid out
[08:19:14] <ssbr> AIUI
[08:19:38] <eddyb> IIRC, CUDA does something fancy in C++ with static function "templating" over a parallel "shape"
[08:19:52] *** Quits: d3xter (sinz@moz-904AC055.atmpu0028.highway.a1.net) (Ping timeout)
[08:20:08] <ssbr> eddyb: my understanding from talking to people that have done GPGPU more than I have is that you actually tend to experiment a lot with the way work groups are structured to optimize the code, and a single catch-all organization is bad
[08:20:16] <ssbr> but these people are crazypants, so maybe it's all nonsense
[08:20:56] *** Joins: ab (alex@BC9D99CC.37C1012D.FE617B51.IP)
[08:21:29] *** Joins: mib_2sgwps (Mibbit@moz-68235C3E.customer.broadstripe.net)
[08:22:24] *** Joins: nathan7 (nathan@moz-60FC7746.nathan7.eu)
[08:22:52] <napoleon> hi guys, rustdoc-ng doesn't exist anymore right?
[08:23:20] <napoleon> merged back as rustdoc?
[08:23:31] *** Quits: pepper_chico (pepper_chi@6D1D0FAA.4F150827.E4090502.IP) (Quit: Ex-Chat)
[08:23:51] <cmr> napoleon: correct.
[08:24:42] *** Joins: sinz (sinz@moz-904AC055.atmpu0028.highway.a1.net)
[08:24:46] *** sinz is now known as d3xter
[08:24:52] <d3xter> i'm trying to compile a new program, but rust complains about "main is not UTF-8 encoded", but "file -bi" says "charset=utf-8". any hints?
[08:24:52] <ssbr> dbaupp: it is an interesting read! Thanks for the link. Aaaand it's bedtime. :)
[08:25:43] <FreeFull> d3xter: Is this with the newest Rust master?
[08:26:06] <d3xter> FreeFull: nightly from yesterday
[08:26:09] <cmr> d3xter: can you put the file up somewhere?
[08:26:42] *** Joins: mib_d251c4 (Mibbit@91FE7F89.5A1F061.49B25F74.IP)
[08:27:00] <d3xter> cmr: gimme a second. upgrading to latest nightly now and then i'll try it again
[08:27:02] <dbaupp> d3xter: are you running `rustc main` or `rustc main.rs`
[08:27:03] <dbaupp> ?
[08:27:09] <mib_d251c4> when will Rust release 0.9?
[08:27:36] <mib_d251c4> cannot wait
[08:27:38] <d3xter> dbaupp: rustc main.rs
[08:27:47] <dbaupp> d3xter: weird
[08:27:56] <d3xter> dbaupp: oh oh, damit
[08:28:00] <d3xter> its "main" -.-
[08:28:05] <d3xter> dbaupp: thx :)
[08:28:13] <dbaupp> mib_d251c4: it's due 3 months after 0.8, which was about 2.5 months ago
[08:28:14] <cmr> mib_d251c4: early january
[08:28:37] *** Quits: beifeng (Mibbit@284C36E7.3062CEC3.670EEFD.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[08:29:12] <mib_d251c4> before 1.0, there will be only 0.9 & 0.10?
[08:30:02] <mib_d251c4> Therefore, march 2014 will be 1.0?
[08:30:03] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[08:30:33] <cmr> no
[08:30:37] <cmr> that's not how it works.
[08:30:42] <cmr> after 0.10 comes 0.11
[08:30:51] <dbaupp> maybe
[08:30:56] <dbaupp> we might have 1.0 by then
[08:31:00] *** Quits: napoleon (Mibbit@moz-E1FF077C.rev.numericable.fr) (Quit: http://www.mibbit.com ajax IRC Client)
[08:31:01] <cmr> well, maybe.
[08:31:01] <dbaupp> we might not
[08:31:08] <cmr> but it's not guaranteed to happen after 0.10
[08:31:09] <FreeFull> d3xter: Ah, it was reading the executable from before
[08:31:09] <dbaupp> (at a guess, we won't)
[08:31:22] <FreeFull> Maybe it should have a different warning about that
[08:31:22] <d3xter> FreeFull: yeah :)
[08:31:42] <ChrisMorgan> mib_d251c4: expect at the very least a 0.10 and very likely a 0.11. Possibly higher numbers too.
[08:33:09] *** Joins: smodo (tadnr@moz-6398EFDF.dclient.hispeed.ch)
[08:33:39] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Input/output error)
[08:34:46] <FreeFull> 0.999
[08:34:52] <TeXitoi> how can I compile with debug symbols ?
[08:35:06] <cmr> TeXitoi: -Z extra-debug-info
[08:35:12] <TeXitoi> cmr: thanks
[08:35:24] <dbaupp> TeXitoi: it apparently doesn't work on OSX
[08:35:42] <mib_d251c4> Thanks all
[08:35:43] <mib_d251c4> !
[08:35:54] <TeXitoi> linux here
[08:36:04] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[08:36:43] *** Quits: xitology (xi@85437D54.5AFA3E4.CEDFC552.IP) (Ping timeout)
[08:37:27] *** Quits: mib_d251c4 (Mibbit@91FE7F89.5A1F061.49B25F74.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[08:37:39] <d3xter> has the importing-crates stuff changed? i've got a "cmd.rs" which contains a crate. within main.rs i try to import it with "use cmd::Command; mod cmd;" but rust complains about not finding the crate
[08:37:53] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Ping timeout)
[08:37:56] <d3xter> s/crate/trait/
[08:38:15] <d3xter> setting #[path] doesnt help either
[08:38:45] *** Joins: ricepuddin (graham@moz-7D68765A.cable.virginm.net)
[08:38:54] <dbaupp> d3xter: is the error with the `use` or with the `mod`?
[08:39:26] <d3xter> dbaupp: use: "unresoled import. maybe missing extern mod crate"
[08:40:06] <dbaupp> d3xter: so, this is inside `cmd.rs`?
[08:40:56] <d3xter> d3xter: inside cmd.rs is only a "pub trait Command"
[08:41:44] <dbaupp> d3xter: so, what's called `crate`?
[08:42:10] *** Joins: moostik (Icedove@moz-6D4FE356.w86-212.abo.wanadoo.fr)
[08:42:28] <d3xter> dbaupp: oh well, its `extern mod cmd`
[08:43:30] <d3xter> dbaupp: and `extern mod cmd` says "can't find crate for `cmd`"
[08:43:44] <d3xter> oh and all .rs files are in the same directory
[08:43:54] <dbaupp> have you compiled cmd as a crate?
[08:44:02] <dbaupp> i.e. rustc --lib cmd.rs
[08:44:12] <d3xter> no
[08:44:24] <dbaupp> also, are you meaning for cmd to be an entirely separate crate, or just a submodule?
[08:44:37] <d3xter> dbaupp: just a submodule inside the binary
[08:45:00] <dbaupp> d3xter: ah, just `mod cmd;` rather than `extern mod cmd;`
[08:45:29] *** Quits: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP) (Ping timeout)
[08:49:36] *** Quits: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz) (Quit: Busying myself...)
[08:55:19] <d3xter> dbaupp: doesnt work either
[08:55:43] <dbaupp> d3xter: what's the error?
[08:56:00] <d3xter> error: unresolved import. maybe a missing `extern mod cmd`?
[08:56:00] <d3xter> error: unresolved import. maybe a missing `extern mod cmd`?
[08:56:06] *** Joins: oberstet (quassel@moz-2273E6F.dynamic.mnet-online.de)
[08:56:38] <dbaupp> d3xter: https://gist.github.com/huonw/cc94d69bb4a56391664c should work?
[08:59:31] <d3xter> dbaupp: strangely in another project it works, but not in this one: http://pastebin.com/tFGsS9yR
[08:59:50] <d3xter> the error happens at ssh.rs:1:4
[08:59:53] <dbaupp> d3xter: you might need `use self::cmd::...`
[08:59:56] <dbaupp> (I gtg.)
[09:00:01] *** Joins: wilma (Mibbit@moz-7CD2F96E.informatik.tu-muenchen.de)
[09:00:22] <d3xter> dbaupp: that did it!
[09:00:25] <d3xter> thx
[09:01:15] *** Joins: xitology (xi@85437D54.5AFA3E4.CEDFC552.IP)
[09:02:50] *** Quits: ssbr (devin@moz-8EC4F450.lightspeed.sntcca.sbcglobal.net) (Ping timeout)
[09:03:08] *** Joins: rca (rcatolino@7F54AB21.28091F66.520D6FA6.IP)
[09:08:27] *** Quits: mib_2sgwps (Mibbit@moz-68235C3E.customer.broadstripe.net) (Quit: http://www.mibbit.com ajax IRC Client)
[09:09:12] *** Joins: ssbr (devin@moz-8EC4F450.lightspeed.sntcca.sbcglobal.net)
[09:09:17] *** Joins: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net)
[09:09:42] *** Quits: xitology (xi@85437D54.5AFA3E4.CEDFC552.IP) (Ping timeout)
[09:10:50] *** Joins: amro (quassel@D9E34ACF.8AAAF769.FAAB0799.IP)
[09:10:51] *** Quits: pradeep (pradeep@5AB4884B.FCC4549.14D5B978.IP) (Connection reset by peer)
[09:11:05] *** Quits: FreeFull (freefull@moz-EF0F03F3.as13285.net) (Quit: )
[09:11:07] *** Joins: pradeep (pradeep@5AB4884B.FCC4549.14D5B978.IP)
[09:14:17] *** Quits: morphevs (Adium@moz-5C485CFA.ethz.ch) (Quit: Leaving.)
[09:15:05] *** Joins: xitology (xi@85437D54.5AFA3E4.CEDFC552.IP)
[09:15:55] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[09:17:18] *** Quits: pradeep (pradeep@5AB4884B.FCC4549.14D5B978.IP) (Connection reset by peer)
[09:17:18] *** Quits: june0cho (june0.cho@5AB4884B.FCC4549.14D5B978.IP) (Connection reset by peer)
[09:17:31] *** Joins: pradeep (pradeep@5AB4884B.FCC4549.14D5B978.IP)
[09:17:42] *** Joins: june0cho_ (june0.cho@5AB4884B.FCC4549.14D5B978.IP)
[09:17:47] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[09:18:40] <d3xter> and now rust cant find the run method of SSHCmd :/
[09:20:03] *** Quits: houzi (houzi@moz-4F6A1E26.getinternet.no) (Ping timeout)
[09:23:34] <Boreeas> What's the difference between self and Self?
[09:23:54] <cmr> Self is a type parameter, self is the name for the object the method is called on.
[09:24:00] <cmr> ie, Self is the type the trait is being implemented for.
[09:24:27] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[09:25:18] *** Joins: Earnestly (earnest@88884C6.A3735F9C.39C00A7A.IP)
[09:25:53] *** Quits: eddyb (eddy@moz-68E0B7D0.residential.rdsnet.ro) (Ping timeout)
[09:27:06] <Boreeas> ah, alright. thanks
[09:28:53] *** Joins: alan_andrade (alan_andra@moz-7559582E.hsd1.ca.comcast.net)
[09:30:38] *** Quits: alan_andrade (alan_andra@moz-7559582E.hsd1.ca.comcast.net) (Ping timeout)
[09:30:48] <d3xter> cmr: can you take a quick look at my code and find out why rust can't find any implementation of "run" for SSHCmd in main.rs?
[09:31:08] <cmr> d3xter: link?
[09:31:21] <d3xter> cmr: http://pastebin.com/tFGsS9yR
[09:33:57] <d3xter> cmr: i've added the &self to the Command trait already
[09:35:08] *** Quits: Kxepal (Miranda@moz-84D27387.pppoe.mtu-net.ru) (Ping timeout)
[09:36:23] *** Joins: peterdn (chatzilla@moz-3DA3F15F.as13285.net)
[09:37:06] *** Quits: ricepuddin (graham@moz-7D68765A.cable.virginm.net) (Ping timeout)
[09:37:40] <cmr> d3xter: in main, the trait isn't in scope.
[09:38:12] <cmr> d3xter: http://pastebin.com/Tbht9M2q
[09:38:16] *** Joins: Kxepal (Miranda@moz-EDD846B4.pppoe.mtu-net.ru)
[09:39:47] *** Quits: pradeep (pradeep@5AB4884B.FCC4549.14D5B978.IP) (Connection reset by peer)
[09:39:47] *** Quits: june0cho_ (june0.cho@5AB4884B.FCC4549.14D5B978.IP) (Connection reset by peer)
[09:40:09] *** Joins: pradeep (pradeep@5AB4884B.FCC4549.14D5B978.IP)
[09:40:18] *** Joins: june0cho_ (june0.cho@5AB4884B.FCC4549.14D5B978.IP)
[09:41:11] *** Quits: g3xzh (g3xzh@moz-19E10D7.red.bezeqint.net) (Ping timeout)
[09:42:42] *** Quits: vky (chatzilla@moz-4F2E17BF.dsl.dynamic.sonic.net) (Quit: ChatZilla 0.9.90.1 [Firefox 26.0/20131202182626])
[09:45:10] *** Quits: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net) (Ping timeout)
[09:45:44] <d3xter> cmr: updated the source code: http://pastebin.com/ZJFAvEjC <- still get "type `ssh::SSHCmd` does not implement any method in scope named `run`"
[09:46:12] <cmr> d3xter: line 24 is wrong, remove it.
[09:47:29] <d3xter> cmr: "error: unresolved import: could not find `cmd` in `ssh`."
[09:47:33] *** Joins: nkoep (nik@moz-31E42C4C.pool.mediaways.net)
[09:48:28] <cmr> d3xter: it shouldn't be self::cmd
[09:48:33] <cmr> The paste I pasted should work.
[09:48:38] <cmr> though I didn't test it; busy.
[09:49:17] *** Joins: andor (andor@moz-708868D.neferty.me)
[09:49:18] *** Quits: jdm (jdm@moz-AC9499B2.cable.teksavvy.com) (Quit: Lost terminal)
[09:50:49] <d3xter> cmr: yeah, it works now. strange thing is, 2 hours ago it complained about not finding cmd::Command so i had to use self::cmd::Command ^^ this seems to be related to the "mod cmd;" inside main.rs
[09:51:11] *** Quits: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[09:51:22] <cmr> yes, that's what happens when you put your modules in weird places :)
[09:51:27] <dbaupp> d3xter: use is an absolute path by default
[09:51:40] <dbaupp> that is, it starts at the top of the crate (i.e. the file on which you run rustc)
[09:52:07] <dbaupp> so if you have `mod cmd;` in a submodule, then `use cmd:...` won't be looking in the correct place
[09:52:54] <dbaupp> you can override the absoluteness using `self::foo` (equivalent to ./foo for a filesystem), or `super::foo` (../foo)
[09:53:12] <d3xter> dbaupp: oh ok, thanks
[09:53:34] <dbaupp> (which is why I suggested self::cmd to you as I dashed out before.)
[09:53:45] <dbaupp> (sorry for the lack of explanation then.)
[09:53:46] <d3xter> maybe someday i'll get the hang out of it :D
[09:55:43] <d3xter> when i have "mod cmd" inside main.rs AND ssh.rs, rustc doesnt say anything. shouldn't there be a warning for importing the same crate twice?
[09:55:54] *** Quits: nsf (nsf@moz-EEF3238A.convex.ru) (Quit: WeeChat 0.4.2)
[09:55:57] <cmr> there probably should be, at this point.
[09:56:27] <cmr> It's not *wrong*, but it's often unintentional.
[09:56:52] <d3xter> cmr: does rust remove the second appearance by itself?
[09:56:59] <d3xter> when compiling
[09:57:06] <cmr> no
[09:57:14] <cmr> it creates two duplicate modules with the same contents.
[09:57:19] <cmr> but the types aren't the same etc.
[09:57:28] <cmr> structurally the same, different names.
[09:57:56] <d3xter> right, on one hand there is "cmd::Command" and on the other hand "self::cmd::Command"
[09:58:00] *** Quits: zmthy (tim@moz-C2881CC3.ecs.vuw.ac.nz) (Quit: leaving)
[09:58:58] <dbaupp> https://github.com/mozilla/rust/issues/5765
[09:59:51] *** Joins: eddyb (eddy@moz-68E0B7D0.residential.rdsnet.ro)
[10:00:02] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[10:00:17] *** Quits: pradeep (pradeep@5AB4884B.FCC4549.14D5B978.IP) (Connection reset by peer)
[10:00:17] *** Quits: june0cho_ (june0.cho@5AB4884B.FCC4549.14D5B978.IP) (Connection reset by peer)
[10:00:27] *** Joins: june0cho (june0.cho@5AB4884B.FCC4549.14D5B978.IP)
[10:00:32] *** Joins: calatalee (Mibbit@C759AA18.78D8039A.8395810B.IP)
[10:00:47] *** Joins: pradeep (pradeep@5AB4884B.FCC4549.14D5B978.IP)
[10:01:20] *** Joins: ricepuddin (graham@moz-7D68765A.cable.virginm.net)
[10:01:37] *** Quits: nkoep (nik@moz-31E42C4C.pool.mediaways.net) (Ping timeout)
[10:02:39] *** Quits: june0cho (june0.cho@5AB4884B.FCC4549.14D5B978.IP) (Connection reset by peer)
[10:02:39] *** Quits: pradeep (pradeep@5AB4884B.FCC4549.14D5B978.IP) (Connection reset by peer)
[10:03:50] <calatalee> Hi,gays.How can i transition char like \u5e15 to å¸•
[10:04:29] <calatalee> code like :use std::num::from_str_radix; 	 let x: Option<int> = from_str_radix("5e15", 16); 	 let y= x.unwrap(); 	 let z:Option<char> =std::char::from_u32(y as u32); 	 println!("{:?}",z)
[10:04:32] <calatalee> not work
[10:04:42] <dbaupp> rusti: println("\u5e15")
[10:04:46] *** Quits: gdey (gdey@moz-E4449B64.sd.sd.cox.net) (Connection reset by peer)
[10:04:50] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[10:05:28] *** Joins: june0cho (june0.cho@5AB4884B.FCC4549.14D5B978.IP)
[10:05:46] *** Joins: pradeep (pradeep@5AB4884B.FCC4549.14D5B978.IP)
[10:06:24] *** Quits: alisdair (textual@28441AAB.AC6E1995.F0AE27BD.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[10:06:42] <dbaupp> calatalee: just like that ^
[10:07:40] <calatalee> I see
[10:08:05] <calatalee> If a json string like this : let json_str=&r#"{"a":"\u5e15\u8428\u7279","b":"\u5e15\u8428\u7279"}"#;
[10:08:07] *** Joins: fyolnish_ (fyolnish@moz-BE2BAE5B.miinet.jp)
[10:08:27] <calatalee> and i decode ,get the value of key a
[10:08:29] *** Quits: jyasskin_w (jyasskin@DAF66858.C60FE7DC.4065847B.IP) (Ping timeout)
[10:08:43] *** Quits: ssbr_ (~ssbr@46FE74EC.C60FE7DC.4065847B.IP) (Ping timeout)
[10:08:46] <calatalee> it can't transition to chinese
[10:09:19] *** Quits: fyolnish (fyolnish@moz-BE2BAE5B.miinet.jp) (Ping timeout)
[10:09:53] *** Quits: fyolnish_ (fyolnish@moz-BE2BAE5B.miinet.jp) (Ping timeout)
[10:09:54] <dbaupp> how are you printing it?
[10:10:14] *** Joins: Blei (philipp@moz-B2F9E4BD.cust.bluewin.ch)
[10:11:17] *** Quits: pradeep (pradeep@5AB4884B.FCC4549.14D5B978.IP) (Quit: Lost terminal)
[10:12:05] <calatalee> let value=map.find(&~"a").unwrap();  println!("{:?}",value)
[10:12:30] <andor> is there an ETA on 0.9?
[10:12:36] *** Quits: d3xter (sinz@moz-904AC055.atmpu0028.highway.a1.net) (Ping timeout)
[10:12:47] <calatalee> yes
[10:12:57] <cmr> andor: early january.
[10:12:59] <cmr> 3 months after 0.8
[10:13:02] <dbaupp> calatalee: don't use {:?}
[10:13:15] <dbaupp> that's printing a representation of the string, not the string itself
[10:13:19] <dbaupp> println(value)
[10:13:21] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[10:13:26] <dbaupp> or println!("{}", value)
[10:13:34] <calatalee> I see
[10:13:41] <calatalee>  println!("{:s}",*value);
[10:13:42] <dbaupp> (or, if you really want, println!("{:s}", value).)
[10:13:46] <calatalee> yes
[10:13:49] <calatalee> ths
[10:14:15] *** Quits: june0cho (june0.cho@5AB4884B.FCC4549.14D5B978.IP) (Connection reset by peer)
[10:14:18] *** Joins: june0cho (june0.cho@5AB4884B.FCC4549.14D5B978.IP)
[10:15:41] *** Joins: dredozubov (dredozubov@2F14E2C1.F70E5FA9.F63E14E8.IP)
[10:17:03] *** Joins: nkoep (nik@moz-B106D44A.vpn.rwth-aachen.de)
[10:17:09] *** Quits: calatalee (Mibbit@C759AA18.78D8039A.8395810B.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[10:19:13] <andor> slightly different question, does sodiumoxide compile on 0.8?
[10:19:47] <dbaupp> andor: unlikely
[10:21:11] *** Joins: Ms2ger (Ms2ger@moz-2BA54FF.ugent.be)
[10:23:45] *** Joins: ssbr_ (~ssbr@98D3BE03.C60FE7DC.4065847B.IP)
[10:23:50] *** Joins: jyasskin_w (jyasskin@5CA6DC39.C60FE7DC.4065847B.IP)
[10:25:39] *** Joins: sanxiyn (tinuviel@B4104EBB.3CC170B1.1E14B209.IP)
[10:25:48] <sanxiyn> Found: https://github.com/notmatt/rust/commits/smartos
[10:26:48] <ksev> has anyone else managed to build rustc on OSX Mavericks, the system linker segfaults on libextra when compiling with stage0 
[10:27:30] <dbaupp> ksev: segfaults?
[10:27:41] <dbaupp> ksev: what version of rustc?
[10:27:49] <sanxiyn> ksev: I vaguely heard success by using different linker
[10:28:02] <ksev> yeah http://pastebin.com/WxRTbPap
[10:28:15] <ksev> i pulled master just now
[10:28:20] *** Joins: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net)
[10:28:56] <dbaupp> sanxiyn: neat
[10:29:04] <ksev> so download a different version clang and use that?
[10:29:09] <sanxiyn> dbaupp: Yeah apparently someone is trying to port Rust to Solaris
[10:29:15] <sanxiyn> ksev: No idea
[10:29:23] *** Joins: alan_andrade (alan_andra@moz-7559582E.hsd1.ca.comcast.net)
[10:31:15] *** Quits: alan_andrade (alan_andra@moz-7559582E.hsd1.ca.comcast.net) (Ping timeout)
[10:31:38] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[10:32:28] <sanxiyn> ksev: It says "use -v to see invocation"
[10:32:42] <sanxiyn> Could be helpful to get that
[10:33:42] *** Joins: gdey (gdey@moz-E4449B64.sd.sd.cox.net)
[10:34:28] <ksev> it adds an extra 3 lines to the output :) http://pastebin.com/nZRtkCTJ
[10:36:36] <ksev> the libextra rlib file is there so compiling works
[10:36:43] *** Joins: sinz (sinz@moz-904AC055.atmpu0028.highway.a1.net)
[10:36:44] *** sinz is now known as d3xter
[10:37:18] <dbaupp> bstrie: do you reckon you could hook up an eval bot to /r/rust?
[10:37:43] <dbaupp> bstrie: I believe CSS3 is turing complete, so it shouldn't be too hard to just port rustc to CSS and have it run all in browser.
[10:38:32] <sanxiyn> dbaupp: We'd get JS port earlier
[10:38:36] <eddyb> hah
[10:39:05] *** Joins: zenon (Mibbit@moz-2E43177.dynamic.qsc.de)
[10:39:39] <zenon> Is it possible to write a generic function that can only be used with a certain set of classes?
[10:40:05] <eddyb> you can already run a compiler + emscripten in the browser
[10:40:22] <sanxiyn> eddyb: You can?
[10:40:26] <cmr> zenon: we don't have classes, so what exactly do you mean by that?
[10:40:35] <cmr> sanxiyn: yep, there was a demo on reddit.
[10:40:36] <dbaupp> sanxiyn: :P
[10:40:39] <zenon> cmr: Sorry. I meant structs
[10:40:48] <eddyb> I saw a demo with llvm-as (compiled with emscripen) + emscripten + evaluation
[10:40:52] <cmr> No, of course not, that'd be silly.
[10:41:00] <dbaupp> cmr: that's Rust compiler is not running with emscripten?
[10:41:25] <eddyb> now, getting clang or rustc compiled with emscripten is harder. but only because they're so huge
[10:41:35] <TobiasFar> the configure script outputs "configure: error: unsupported target triples "i386-apple-darwin" found"? what am i missing?
[10:41:54] <eddyb> erm, were there ever x86_32 macs?
[10:41:59] <dbaupp> eddyb: yes
[10:42:04] <dbaupp> eddyb: we run tests on them
[10:42:10] <eddyb> I thought they switched from ppc to x64
[10:42:20] <cmr> eddyb: nope.
[10:42:26] <cmr> dbaupp: can you rephrase that?
[10:42:35] <eddyb> or is it just a recent thing with official support?
[10:42:39] <dbaupp> eddyb: http://buildbot.rust-lang.org/builders/auto-mac-32-opt
[10:42:59] <eddyb> rustc has nasty runtime dependencies from libstd. no_uv would help with that, I guess
[10:43:08] <dbaupp> cmr: you said "there was a demo on reddit", which I assumed you meant was referring to http://www.compileonline.com/compile_rust_online.php
[10:43:09] <sanxiyn> TobiasFar: It's not i686-apple-darwin?
[10:43:14] <eddyb> oh, tasks. good luck getting those working in the browser
[10:43:27] <eddyb> I mean, WebWorkers, but... no, they would actually work
[10:43:27] <TobiasFar> sanxiyn: one sec, i'll try if it accepts that
[10:43:49] <dbaupp> eddyb: need an Arc equivalent
[10:44:05] <TobiasFar> sanxiyn: that seems to work...thanks :)
[10:44:18] <eddyb> hah, that is awesome, the rust task memory model kinda fits (modulo [RW]Arc) with the sendable memory chunks in workers
[10:44:24] <eddyb> dbaupp: yeah, I realized that >_>
[10:44:49] <zenon> cmr: I want to implement the following function fn register_event_handler<T>(callback: |e: &T|) { /* put e in some hashmap */ }. Obviously T has to be restricted. Is there a way to do this?
[10:44:55] <eddyb> you can copy the memory for Arc, since it's immutable anyway
[10:45:10] <eddyb> zenon: with a trait
[10:45:13] <sanxiyn> TobiasFar: You shouldn't need to specify target manually
[10:45:33] <dbaupp> eddyb: MutexArc then :P
[10:45:45] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[10:45:57] <eddyb> zenon: and you have to move all operations you want to perform on T to that trait
[10:46:06] <TobiasFar> sanxiyn: i need to if i'm on mavericks and want 32bit static libs that i can link to other existing 32bit object files
[10:46:25] <dbaupp> zenon: yes, traits
[10:46:33] <sanxiyn> TobiasFar: Ah you want to build for 32bit on 64bit?
[10:46:36] <sanxiyn> Yeah then you need it
[10:46:38] *** Joins: g3xzh (g3xzh@moz-19E10D7.red.bezeqint.net)
[10:46:39] <TobiasFar> sanxiyn: right
[10:46:40] *** Joins: beifeng (Mibbit@284C36E7.3062CEC3.670EEFD.IP)
[10:46:42] <eddyb> dbaupp: erm. hmm. why would there be an immutable locked structure?
[10:46:53] <dbaupp> eddyb: what?
[10:46:55] <eddyb> dbaupp: is it for abstracting mutable state?
[10:47:00] <dbaupp> eddyb: MutexArc isn't immutable
[10:47:04] <eddyb> oh nvm then
[10:47:08] <dbaupp> zenon: you specify that T has to implement certain traits `<T: Hash>`
[10:47:11] <eddyb> so what's the difference between that and RWArc?
[10:47:15] <ezyang> r? https://github.com/mozilla/rust/pull/10892#issuecomment-30240475 
[10:47:15] <dbaupp> (or Hashable)
[10:47:16] <sanxiyn> TobiasFar: We probably should document that somewhere...
[10:47:39] <dbaupp> eddyb: RWArc allows for multiple readers at once, MutexArc only allows one thing to interact with it at any one time
[10:48:07] <dbaupp> ezyang: is it a fix for 10890?
[10:48:28] *** Quits: g3xzh (g3xzh@moz-19E10D7.red.bezeqint.net) (Ping timeout)
[10:48:34] <eddyb> oh, so MutexArc<T> is a thread-safe Rc<RefCell<T>> equivalent?
[10:48:45] <dbaupp> eddyb: yes, and so is RWArc
[10:49:13] <eddyb> RefCell can't have multiple readers
[10:49:22] <eddyb> or writers. oh nvm
[10:49:22] <TobiasFar> in the end i want to evaluate if rust is suitable to write programs on sensor nodes (32bit ARM7, 98KiB RAM, 512KiB ROM)...this is just one smaller step on the way to that...unless this isn't doable at all
[10:49:30] <eddyb> dbaupp: I shouldn't try to think too hard :P
[10:49:49] <TobiasFar> sanxiyn: yeah..would be nice if that'd documented somewhere
[10:50:05] <dbaupp> eddyb: maybe you should, as practice
[10:50:19] <sanxiyn> TobiasFar: Is https://github.com/neykov/armboot something similar?
[10:50:26] <sanxiyn> "Rust language sample project for STM32F4xx ARM microcontrollers"
[10:50:33] <ezyang> dbaupp: No, I have not fixed that yet 
[10:50:44] <eddyb> dbaupp: I have to check if workers can wait for a message, that would be useful
[10:50:51] <ezyang> That change was pending on a ++ from someone 
[10:51:11] <dbaupp> ezyang: oh; I should read the issue in more detail
[10:51:43] <eddyb> can rustc run threadless?
[10:52:00] <sanxiyn> eddyb: Not at the moment, but we could have that option
[10:52:07] <zenon> eddyb: dbaupp: I don't think that works in my case. This code has to work: register_event_handler(|e: MouseEvent| { ... }); register_event_handler(|e: KeyEvent| { ... } ); and my code has to create these events (MouseEvent, KeyEvent) from native events. I don't see how I can dispatch them to the correct event handler with T only restricted by a trait.
[10:52:08] *** Quits: d3xter (sinz@moz-904AC055.atmpu0028.highway.a1.net) (Quit: WeeChat 0.4.2)
[10:52:14] <eddyb> I mean, does it need concurrency for anything?
[10:52:21] <TobiasFar> sanxiyn: ahh...cool...yeah..that's pretty similar, and also supported by the dev environment i'm using...hoped i could use rust for some development, since i found it interesting and so
[10:52:24] <sanxiyn> eddyb: It does use tasks
[10:52:38] <eddyb> sanxiyn: but for anything other than failure boundaries?
[10:52:53] <sanxiyn> eddyb: No, I don't think so. Only for failure isolation.
[10:53:04] <eddyb> zenon: the handler has to be a trait
[10:53:41] <dbaupp> zenon: why doens't a trait work for that?
[10:53:46] <eddyb> zenon: and you can store a type T: Trait as ~Trait in a map
[10:53:47] <zenon> eddyb: That's anoying. Can't I do some fancy compile time reflection to get the correct data out of the function itself?
[10:54:01] <eddyb> zenon: do you have separate handler lists?
[10:54:12] *** Joins: Sorella (quildreen@2392D500.600E39D3.1ED99692.IP)
[10:54:21] <sanxiyn> zenon: You want runtime type info?
[10:54:37] <zenon> eddyb: No separate lists if that's possible.
[10:54:47] <zenon> sanxiyn: Compile time if possible
[10:54:48] <eddyb> zenon: it requires trait pointers (virtualization)
[10:55:07] <sanxiyn> zenon: How does compile time reflection work in that scenario at all?
[10:55:25] <eddyb> zenon: with separate lists, you just need a trait method to give you an enum value that indicates which list to use
[10:55:35] <sanxiyn> (There is type_id if you want runtime type info)
[10:55:37] <eddyb> zenon: oh, I know :D
[10:55:52] <zenon> sanxiyn: Do a match typeof(T) { special_case_1, special_case_2, ..., _ fail! }
[10:55:57] <eddyb> zenon: even nicer, have a method in the trait to return an enum variant, packing the closure
[10:56:29] <dbaupp> zenon: why not enum Event { MouseEvent(...), KeyEvent(...) ... }?
[10:56:31] <sanxiyn> zenon: That's not really compile time
[10:56:41] <sanxiyn> zenon: You can do that manually, but no compiler support
[10:56:49] <zenon> dbaupp: That sounds good.
[10:56:54] <eddyb> zenon: so you map T -> Handler which is enum Handler { MouseEventHandler(...), KeyEventHandler(..), ..}
[10:57:08] <eddyb> zenon: but dbaupp's solution might work better, depending on what you have
[10:57:15] <zenon> sanxiyn: I hope that LLVM resolves this at compile time.
[10:57:19] <eddyb> zenon: you still can't use a closure like that
[10:57:34] <eddyb> you can only pass it down, not store it
[10:57:45] <sanxiyn> zenon: LLVM tries, but in general GCC does better devirtualization than LLVM
[10:57:58] <eddyb> (unless it's 'static |...| which means it can't capture anything)
[10:58:02] <sanxiyn> (GCC had some devirtualization for its Java implementation)
[10:58:50] <eddyb> zenon: if you want to pack some possible state in the handler, you need an EventHandler trait which has a method to handle an event
[10:59:05] *** Joins: g3xzh (g3xzh@moz-19E10D7.red.bezeqint.net)
[10:59:10] <zenon> I'll write some pseudo code.
[10:59:49] <eddyb> zenon: if you use a trait, you can impl EventHandler for 'static |Event| {fn handle(&self, e: Event) {self(e);}}
[11:00:47] <eddyb> so users can pass bare functions, closures which don't capture stack variables or traits pointers (which can hide internal state)
[11:01:58] <eddyb> in the future, you'd use Fn<(), Event> (or Fn<Event, ()>, since both <Ret, ..Args> and <..Args, Ret> are valid, the choice will be made then)
[11:02:39] <eddyb> or just |Event|, and Fn-implementing types would be cast to the closure repr
[11:03:03] *** Quits: g3xzh (g3xzh@moz-19E10D7.red.bezeqint.net) (Ping timeout)
[11:03:26] *** Quits: SingingBoyo (SingingBoy@DA28FB90.A5D0D593.4F048BDC.IP) (Ping timeout)
[11:03:57] <ezyang> IS there a way to download the stdlib docs for offline viewing? 
[11:05:00] <dbaupp> you have them already if you've run `make`
[11:05:10] <dbaupp> in doc/std of the build directory
[11:05:14] <dbaupp> iirc
[11:05:19] <sanxiyn> ezyang: You can build one, not sure about downloading prebuilt version
[11:05:33] <sanxiyn> As dbaupp said, `make` builds docs.
[11:05:37] <ezyang> oh, I guess I should make rust then 
[11:05:53] <dbaupp> oh, are you using a package?
[11:05:58] *** Quits: TobiasFar (tm@moz-A929D162.flosoft-servers.net) (Ping timeout)
[11:06:02] <ezyang> yeah, I'm using the Ubuntu PPA 
[11:06:17] <ezyang> oops, I don't have enough RAM 
[11:06:18] *** Joins: TobiasFar (tm@moz-A929D162.flosoft-servers.net)
[11:06:22] <dbaupp> hm, I guess you get wget --mirror (or whatever)
[11:06:48] <dbaupp> more efficient than an LLVM build + bootstrap
[11:07:21] <ezyang> I've always found wget --mirror to be quite irritating 
[11:07:24] <ezyang> but let's give it a try 
[11:07:59] <sanxiyn> ezyang: Don't have 1.5 GiB free?
[11:08:15] <ezyang> memory, no. My laptop's five years old 
[11:08:32] <sanxiyn> Oh
[11:08:57] <sanxiyn> (By the way, my laptop is also 5 years old, but free memory is *just enough* to build rustc now)
[11:08:58] <dbaupp> "/home/huon/rust/build/x86_64-unknown-linux-gnu/stage1/lib/rustc/x86_64-unknown-linux-gnu/lib/librustc-5b94a16f-0.9-pre.so: undefined reference to `LLVMRustLinkInExternalBitcode'"
[11:09:19] <dbaupp> hm, I guess that's a make clean thing...
[11:09:21] * dbaupp tries
[11:09:36] <ezyang> hey, wget --mirror was surprisingly painless 
[11:09:53] <dbaupp> does the search work?
[11:10:16] <ezyang> Well, I should turn off net and check 
[11:10:43] <ezyang> oh snap, yes it does 
[11:10:49] <dbaupp> cool
[11:10:57] <sanxiyn> Nice
[11:11:02] *** Joins: samnardoni (samnardoni@F889EF52.38924046.A86B7D63.IP)
[11:13:29] *** Joins: lpy (lpy@7360AA58.F09091A8.1348A864.IP)
[11:13:37] <ezyang> so, is there some giant JSON thing that it searches? 
[11:13:39] <ezyang> would make sense 
[11:14:11] <sanxiyn> ezyang: Yup
[11:14:34] <sanxiyn> Search index JSON is dumped to $BUILD/doc/std/search-index.js, etc.
[11:15:05] <sanxiyn> (~500 KB at the moment)
[11:15:28] *** Quits: lpy (lpy@7360AA58.F09091A8.1348A864.IP) (Connection reset by peer)
[11:15:54] *** Joins: lpy (lpy@7360AA58.F09091A8.1348A864.IP)
[11:16:41] <Yurume> what size of that JSON file would be acceptable for normal uses? 100 KB?
[11:16:41] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[11:17:31] <sanxiyn> I think 500 KB is fine
[11:18:01] <Yurume> FYI, it would be under 90 KB when gzip -9'd, but it seems that S3 does not do any compression on the fly (obviously).
[11:18:36] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[11:18:45] <dbaupp> does it get loaded unconditionally? (and does it get cached in browser?)
[11:18:58] <sanxiyn> As I understand it *is* possible to serve compressed files off S3
[11:19:25] <dbaupp> http://developers.google.com/speed/pagespeed/insights/?url=http%3A%2F%2Fstatic.rust-lang.org%2Fdoc%2Fmaster%2Fstd%2Findex.html
[11:20:19] *** Quits: lpy (lpy@7360AA58.F09091A8.1348A864.IP) (Ping timeout)
[11:20:21] <Yurume> dbaupp: AFAIK yes, it has <script src="../std/search-index.js"></script> down to the content
[11:20:47] <sanxiyn> Yup, it loads index unconditionally, and index is served uncompressed
[11:20:56] <TobiasFar> what's missing here to link? some rust standard lib or so? http://nopaste2.doomsong.co.uk/1386760809.php 
[11:21:40] *** Quits: huhlig-home (huhlig@moz-C8339267.hfc.comcastbusiness.net) (Connection reset by peer)
[11:21:51] <sanxiyn> TobiasFar: Oh that is interesting...
[11:21:59] <sanxiyn> It is possible 64-to-32 cross on Mac is broken
[11:22:10] <sanxiyn> I don't think it is tested configuration
[11:23:23] *** Joins: samnardo_ (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP)
[11:24:04] <TobiasFar> sanxiyn: hmm...ok..any way to report or fix this?
[11:24:33] <sanxiyn> TobiasFar: Feel free to report to GitHub
[11:24:34] <TobiasFar> sanxiyn: would it help to build rust as 32bit, so it wouldn't need to cross-compile anymore
[11:24:59] <sanxiyn> TobiasFar: No idea
[11:25:15] <sanxiyn> I'd report by listing steps you did, so that other people can reproduce the issue
[11:26:54] <eddyb> TobiasFar: it's tricky, because the compiler needs libraries with the same architecture as itself (like syntax, std, extra, etc.), but to produce binaries of a different architecture, it needs libraries for that architecture. if the build system doesn't build both, it won't work
[11:28:23] <sanxiyn> eddyb: I think build system does build both already...
[11:28:28] <sanxiyn> (That's how Android cross works)
[11:28:39] <TobiasFar> okay...i'll try to create a smaller test case and will report then
[11:29:53] *** Joins: alan_andrade (alan_andra@moz-7559582E.hsd1.ca.comcast.net)
[11:30:08] *** Quits: m_kato (m_kato@moz-C286AD9A.bitcat.net) (Quit: Leaving...)
[11:30:21] <eddyb> TobiasFar: hmm, your last link points to a support library
[11:31:04] <eddyb> especially things like __cxa_throw, that's C++ support for sure
[11:31:34] *** Quits: alan_andrade (alan_andra@moz-7559582E.hsd1.ca.comcast.net) (Ping timeout)
[11:31:41] <eddyb> TobiasFar: you might be missing system/llvm-built-by-rust i386 support libraries
[11:32:44] <eddyb> TobiasFar: on linux, if the problem is system libs, you can usually install a -32bit package. no idea what to do in your case
[11:33:12] <eddyb> if the problem is with the LLVM built by the rust build system, it's a bug there
[11:34:19] <eddyb> e.g. I have libstdc++6-32bit installed
[11:34:21] *** Joins: engla (engla@moz-F64E1B0F.cust.bredbandsbolaget.se)
[11:35:55] <eddyb> TobiasFar: it doesn't look like rust builds any support libs from LLVM. oh, silly me, clang has the support libs, not LLVM. so you need a system libstdc++-32bit
[11:36:04] <eddyb> or something equivalent
[11:37:50] <eddyb> TobiasFar: try: echo -e '#include <iostream>\nint main(){std::cout<<"foobar";}' | clang -x c++ -m32 -o /dev/null -
[11:38:56] <eddyb> hah, I can't do that either
[11:39:21] *** Quits: wilma (Mibbit@moz-7CD2F96E.informatik.tu-muenchen.de) (Quit: http://www.mibbit.com ajax IRC Client)
[11:40:21] <eddyb> TobiasFar: ah, try with clang++. the problem right now is a missing -lstdc++
[11:40:37] *** Quits: Ms2ger (Ms2ger@moz-2BA54FF.ugent.be) (Quit: bbl)
[11:41:15] <eddyb> TobiasFar: which is similar to what you're experiencing, I think
[11:41:20] <eddyb> but you're afk
[11:41:36] <eddyb> I was missing libstdc++48-devel-32bit, it seems
[11:42:52] *** Quits: samnardo_ (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP) (Client exited)
[11:42:57] <eddyb> now clang++ can't find a proper crt*.o, while g++ works
[11:44:26] *** Joins: lpy (lpy@12172131.F09091A8.1348A864.IP)
[11:44:57] <sanxiyn> eddyb: Try clang++ -v
[11:45:06] <sanxiyn> Does it print "Selected GCC installation"?
[11:45:08] *** Joins: skade (skade@moz-3DC698FE.pools.arcor-ip.net)
[11:48:45] *** Quits: sanxiyn (tinuviel@B4104EBB.3CC170B1.1E14B209.IP) (Quit: Leaving)
[11:49:37] <eddyb> Selected GCC installation: /usr/bin/../lib64/gcc/x86_64-suse-linux/4.8
[11:50:00] <eddyb> Found candidate GCC installation: /usr/bin/../lib/gcc/i586-suse-linux/4.8
[11:50:20] <eddyb> aha, it's using the wrong instead of choosing based on triplet
[11:53:22] *** Joins: w3lcome (Mibbit@moz-33A75FFD.home.otenet.gr)
[11:54:05] *** Quits: sigma (sigma@moz-A17EB325.range86-184.btcentralplus.com) (Ping timeout)
[11:55:07] *** Joins: fyolnish (fyolnish@moz-8D7496A5.uqwimax.jp)
[11:55:31] *** Joins: sigma (sigma@moz-A17EB325.range86-184.btcentralplus.com)
[11:55:47] *** Joins: adridu59 (Mibbit@moz-E7A273CD.ac-paris.fr)
[11:57:27] *** Quits: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[11:58:09] *** Quits: sigma (sigma@moz-A17EB325.range86-184.btcentralplus.com) (Ping timeout)
[11:58:26] *** Quits: moostik (Icedove@moz-6D4FE356.w86-212.abo.wanadoo.fr) (Ping timeout)
[11:58:27] *** Joins: sigma (sigma@moz-A17EB325.range86-184.btcentralplus.com)
[12:05:55] *** kimundi is now known as zz_kimundi
[12:06:02] *** zz_kimundi is now known as kimundi
[12:10:47] *** Joins: refold (gman@moz-42D68426.a258.priv.bahnhof.se)
[12:13:53] *** Joins: samnardo_ (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP)
[12:15:39] <dbaupp> does anyone know the issue (or a test case) for why rusti is broken on master?
[12:15:40] <dbaupp> cmr: ^
[12:16:56] <cmr> uhh there is an issue, but I don't remember where it is.
[12:17:09] <cmr> the testcase rust-playpen :p
[12:17:43] <dbaupp> did strcat open it?
[12:18:14] *** Quits: smodo (tadnr@moz-6398EFDF.dclient.hispeed.ch) (Input/output error)
[12:18:43] *** Joins: moostik (Icedove@moz-6D4FE356.w86-212.abo.wanadoo.fr)
[12:19:11] *** Quits: samnardo_ (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP) (Client exited)
[12:19:12] <cmr> pretty sure.
[12:19:19] <adridu59> hey cmr if you want to amend your PR you could remove that rustdoc_ng linky thing
[12:19:25] *** Quits: adridu59 (Mibbit@moz-E7A273CD.ac-paris.fr) (Quit: http://www.mibbit.com ajax IRC Client)
[12:20:25] <dbaupp> hm, well, running irc.sh works fine on master
[12:20:38] <dbaupp> (and `version` gets hit by the dead_code lint, heh.)
[12:20:57] <cmr> dbaupp: it's interaction with the container, not the script itself.
[12:21:03] <cmr> Addle: which PR?
[12:21:06] <cmr> ugh
[12:22:26] <dbaupp> cmr: oh, I can't test #[no_uv]-ing everything then :(
[12:23:03] <dbaupp> cmr: btw, there are 4 references to `rustdoc_ng` in the codebase still
[12:23:09] <dbaupp> (not counting the realease notes)
[12:25:21] *** Joins: cizzy (poipoi@moz-3019D5D7.retail.telecomitalia.it)
[12:25:56] *** Parts: cizzy (poipoi@moz-3019D5D7.retail.telecomitalia.it) ()
[12:25:58] <dbaupp> meh, can't find the issue. :(
[12:26:48] <cmr> chris-morgan/rust/macroize-(or-should-that-be-macroify)-syntax--parse--token-so-that-we-don't-make-mistakes-and-to-reduce-the-maintenance-burden
[12:27:03] <cmr> ChrisMorgan: you are crazy
[12:28:12] <ChrisMorgan> cmr: thanks! :-)
[12:28:48] *** Joins: g3xzh (g3xzh@moz-19E10D7.red.bezeqint.net)
[12:29:01] <ChrisMorgan> I wanted a question mark and some colons (pamaayim nekudotayim) in there, but Git wouldn't let me. Very wise of it.
[12:30:25] *** Joins: Ms2ger (Ms2ger@moz-B6861E63.ibbt.be)
[12:30:53] *** Joins: alan_andrade (alan_andra@moz-7559582E.hsd1.ca.comcast.net)
[12:32:17] <ChrisMorgan> cmr: I like trying to break things; really long branch names with unusual characters was one way to try that. Result: no functionality problems in Git or GitHub, but GitHub doesn't do very well with the styling.
[12:32:32] <cmr> neither did bors
[12:32:36] *** Quits: alan_andrade (alan_andra@moz-7559582E.hsd1.ca.comcast.net) (Ping timeout)
[12:33:47] <ChrisMorgan> Nah, bors is OK.
[12:34:06] <cmr> eh
[12:34:35] <ChrisMorgan> For GitHub it's things like fixed height elements overflowing onto multiple lines, outside the neat blue background allocated for it and entering into places where it shouldn't be. For bors.html it's just a multi-line table cell, quite reasonable.
[12:35:25] * eddyb is now curious what uses vec::from_elem a lot
[12:35:33] <eddyb> or .finally, for that matter
[12:39:12] <dbaupp> the compiler has a pile of from_elem's
[12:39:29] <dbaupp> src/librustc/middle/liveness.rs:603:        users: @mut vec::from_elem(ir.num_live_nodes * ir.num_vars
[12:39:39] *** Joins: donri (donri@moz-9BB61102.tbcn.telia.com)
[12:39:43] <eddyb> oh, liveness, my fat friend
[12:39:48] <dbaupp> eddyb: ^that's your favourite one, right?
[12:39:49] <dbaupp> heh
[12:40:06] *** Quits: jyasskin_w (jyasskin@5CA6DC39.C60FE7DC.4065847B.IP) (Ping timeout)
[12:40:18] *** Quits: ssbr_ (~ssbr@98D3BE03.C60FE7DC.4065847B.IP) (Ping timeout)
[12:40:19] *** Joins: jyasskin_w (jyasskin@DAF66858.C60FE7DC.4065847B.IP)
[12:40:21] *** Joins: canhtak (canhtak@moz-1D882009.wl.t.ulaval.ca)
[12:40:30] <eddyb> filling those 700GB will be 20 times faster now!
[12:41:33] *** Joins: ssbr_ (~ssbr@46FE74EC.C60FE7DC.4065847B.IP)
[12:42:24] *** Joins: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net)
[12:44:24] *** Quits: canhtak (canhtak@moz-1D882009.wl.t.ulaval.ca) (Quit: canhtak)
[12:44:28] *** Joins: dreugeworst (Mibbit@moz-ACD5F5F6.dcs.shef.ac.uk)
[12:45:10] <dbaupp> \o/
[12:52:23] *** Quits: z0w0 (zack@moz-14B3BB9C.lns5.woo.bigpond.net.au) (Ping timeout)
[12:52:30] <samnardoni> Are conditions going to be removed from IO eventually?
[12:52:56] *** Joins: smodo (tadnr@moz-6398EFDF.dclient.hispeed.ch)
[12:52:59] *** Quits: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[12:53:58] <ChrisMorgan> samnardoni: I'll give a probability > 0.8
[12:54:39] <samnardoni> ChrisMorgan: Glad to hear it
[12:55:29] <ChrisMorgan> (I've heard agreement from brson that they should be removed, but I haven't seen anyone going and doing it.)
[12:59:52] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[13:00:03] *** Joins: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net)
[13:00:16] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[13:00:18] <eddyb> strcat: https://github.com/mozilla/rust/pull/10918
[13:00:34] <eddyb> these things are silly
[13:02:46] *** Quits: paulproteus (quassel@199.199.210.158) (Ping timeout)
[13:02:54] *** Joins: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net)
[13:03:27] *** Quits: _Vi (vi@527C345F.497AA854.B16B3BE6.IP) (Ping timeout)
[13:04:07] *** Joins: paulproteus (quassel@458FE134.3EC36C88.CBDCF1DC.IP)
[13:04:20] <eddyb> can I do something fancy with mut_iter and zip?
[13:04:32] <eddyb> no, I can't, I forgot :(
[13:04:52] *** Quits: moostik (Icedove@moz-6D4FE356.w86-212.abo.wanadoo.fr) (Ping timeout)
[13:04:57] <eddyb> there's only one case which can really use this
[13:06:02] *** Quits: zenon (Mibbit@moz-2E43177.dynamic.qsc.de) (Quit: http://www.mibbit.com ajax IRC Client)
[13:06:56] *** Quits: Sgeo (quassel@moz-4E71E7BB.dyn.optonline.net) (Connection reset by peer)
[13:09:27] <eddyb> http://static.rust-lang.org/doc/master/std/vec/trait.MutableCloneableVector.html
[13:09:34] <eddyb> how can't I use copy_from?
[13:10:05] <eddyb> error: type `&mut [u8]` does not implement any method in scope named `copy_from`
[13:15:21] <bstrie> dbaupp: I'm not sure how useful a /r/rust eval bot would be... if it's anything like rusti, anyone attempting to use it would rack up a chain of 20 comments before managing to evaluate anything useful :P
[13:16:24] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[13:16:43] *** Joins: canhtak (canhtak@moz-1D882009.wl.t.ulaval.ca)
[13:17:38] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[13:17:43] <eddyb> bstrie: it could track the comments for edits :P
[13:18:30] <bstrie> eddyb: you might as well just run the code locally and post it yourself, then :P
[13:18:38] <bstrie> or better yet, run the code on rusti first
[13:18:40] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[13:18:43] <bstrie> then post the finished code to reddit
[13:19:26] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[13:24:04] *** Quits: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[13:24:27] <eddyb> callq  vec::MutableVector$__extensions__::mut_slice::h48307b92c550ad3ae3d8ef5e8eb37425b924184099f03c278c8590947968cf5eIEau::v0.0
[13:24:34] <eddyb> you've got to be kidding me
[13:24:50] <eddyb> why is that not inlined?
[13:25:58] *** Joins: jvns (bork@moz-DE62990.nyc.res.rr.com)
[13:26:20] <bstrie> does it have the inline annotation?
[13:27:17] *** Joins: moostik (Icedove@DEF0989.ED71B4E7.BCDF592F.IP)
[13:28:39] <eddyb> bstrie: probably not. but it's not a hot spot, either :/
[13:28:59] <eddyb> I should #[inline(never)] my main decode function and run callgrind
[13:29:40] *** Joins: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net)
[13:31:23] *** Joins: alan_andrade (alan_andra@moz-7559582E.hsd1.ca.comcast.net)
[13:32:21] *** Quits: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[13:33:14] *** Quits: alan_andrade (alan_andra@moz-7559582E.hsd1.ca.comcast.net) (Ping timeout)
[13:33:32] *** Quits: moostik (Icedove@DEF0989.ED71B4E7.BCDF592F.IP) (Ping timeout)
[13:35:57] *** Joins: mib_dhtmz4 (Mibbit@7F54501E.F77D7529.77AE2233.IP)
[13:42:10] *** Joins: _Vi (vi@527C345F.497AA854.B16B3BE6.IP)
[13:44:36] *** Quits: mib_dhtmz4 (Mibbit@7F54501E.F77D7529.77AE2233.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[13:46:10] *** Joins: shell0dh (Mibbit@4AD253D3.55FC4D4.1C0CE1FB.IP)
[13:46:57] *** Quits: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net) (Ping timeout)
[13:47:23] *** Quits: ksev (DrunkenPan@moz-65085A9A.bredband.skanova.com) (Quit: Lost terminal)
[13:51:18] *** Quits: beifeng (Mibbit@284C36E7.3062CEC3.670EEFD.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[13:51:25] *** Quits: dredozubov (dredozubov@2F14E2C1.F70E5FA9.F63E14E8.IP) (Input/output error)
[13:51:29] *** Joins: dredozubov (dredozubov@2F14E2C1.F70E5FA9.F63E14E8.IP)
[13:52:54] <mletterle> What's rusting today?
[13:53:38] *** Quits: _Vi (vi@527C345F.497AA854.B16B3BE6.IP) (Ping timeout)
[13:55:11] *** kimundi is now known as zz_kimundi
[13:57:03] *** Joins: AvianFlu (AvianFlu@974D245D.130DDD13.67CD788C.IP)
[13:59:58] *** Joins: ptc (Adium@moz-192425C4.nyc.res.rr.com)
[14:00:06] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[14:02:35] *** Quits: ptc (Adium@moz-192425C4.nyc.res.rr.com) (Connection reset by peer)
[14:02:40] *** Joins: ptc (Adium@6C906E9F.9ECAA4DB.BCDD830B.IP)
[14:02:50] *** Joins: _Vi (vi@527C345F.497AA854.B16B3BE6.IP)
[14:04:51] *** Quits: AvianFlu (AvianFlu@974D245D.130DDD13.67CD788C.IP) (Input/output error)
[14:04:52] *** Joins: maxli (maxli@moz-4D28BA20.student.cs.uwaterloo.ca)
[14:05:41] *** Joins: sw17ch (sw17ch@moz-62998E95.hfc.comcastbusiness.net)
[14:05:42] *** Joins: ptc1 (Adium@moz-192425C4.nyc.res.rr.com)
[14:06:28] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[14:07:14] *** Quits: ptc (Adium@6C906E9F.9ECAA4DB.BCDD830B.IP) (Ping timeout)
[14:07:23] *** Quits: ptc1 (Adium@moz-192425C4.nyc.res.rr.com) (Ping timeout)
[14:09:01] *** jorendorff_away is now known as jorendorff
[14:10:16] *** jorendorff is now known as jorendorff_away
[14:11:27] *** Joins: polyfractal (polyfracta@moz-4C5426D6.hsd1.sc.comcast.net)
[14:12:42] *** Joins: Axord (xord@moz-C0D5F15A.lsanca.dsl-w.verizon.net)
[14:16:33] *** Quits: Axord (xord@moz-C0D5F15A.lsanca.dsl-w.verizon.net) (Ping timeout)
[14:20:09] *** Joins: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net)
[14:23:42] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[14:23:48] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[14:24:09] *** Joins: victorporof_ (victorporo@C8C495F5.E3195F0D.9B1E38F4.IP)
[14:24:54] *** Quits: victorporof (victorporo@C8C495F5.E3195F0D.9B1E38F4.IP) (Ping timeout)
[14:25:57] *** Quits: lpy (lpy@12172131.F09091A8.1348A864.IP) (Quit: Leaving...)
[14:26:24] *** Quits: victorporof_ (victorporo@C8C495F5.E3195F0D.9B1E38F4.IP) (Ping timeout)
[14:28:03] *** Joins: victorporof (victorporo@C8C495F5.E3195F0D.9B1E38F4.IP)
[14:28:31] *** Joins: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net)
[14:28:47] *** Quits: jvns (bork@moz-DE62990.nyc.res.rr.com) (Ping timeout)
[14:29:50] *** Joins: victorporof_ (victorporo@C8C495F5.E3195F0D.9B1E38F4.IP)
[14:30:08] *** Quits: victorporof (victorporo@C8C495F5.E3195F0D.9B1E38F4.IP) (Ping timeout)
[14:30:51] *** Joins: colinsurprenant (colin@F692E1FE.8D7057CF.30F15291.IP)
[14:30:53] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[14:31:11] *** Joins: victorporof (victorporo@C8C495F5.E3195F0D.9B1E38F4.IP)
[14:32:16] *** Quits: victorporof_ (victorporo@C8C495F5.E3195F0D.9B1E38F4.IP) (Ping timeout)
[14:32:36] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[14:32:38] *** Joins: victorporof_ (victorporo@C8C495F5.E3195F0D.9B1E38F4.IP)
[14:33:27] *** Quits: victorporof (victorporo@C8C495F5.E3195F0D.9B1E38F4.IP) (Ping timeout)
[14:33:28] *** Joins: lfox (lfox@moz-89EEE1BF.nyc.res.rr.com)
[14:34:50] *** Quits: shell0dh (Mibbit@4AD253D3.55FC4D4.1C0CE1FB.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[14:39:41] *** jorendorff_away is now known as jorendorff
[14:41:19] *** Quits: dredozubov (dredozubov@2F14E2C1.F70E5FA9.F63E14E8.IP) (Connection reset by peer)
[14:41:20] *** Joins: dredozub_ (dredozubov@2F14E2C1.F70E5FA9.F63E14E8.IP)
[14:41:28] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[14:47:33] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[14:48:49] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[14:49:57] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[14:51:11] *** jorendorff is now known as jorendorff_away
[14:55:32] *** Joins: samnardo_ (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP)
[14:57:15] *** Joins: FreeFull (freefull@moz-EFEF3DB5.as13285.net)
[15:00:45] *** Quits: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[15:02:43] *** Joins: ptc (Adium@moz-192425C4.nyc.res.rr.com)
[15:02:45] *** Quits: samnardo_ (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP) (Client exited)
[15:04:09] *** Quits: ptc (Adium@moz-192425C4.nyc.res.rr.com) (Quit: Leaving.)
[15:04:09] *** Joins: ptc (Adium@moz-192425C4.nyc.res.rr.com)
[15:04:40] *** Joins: ptc1 (Adium@moz-192425C4.nyc.res.rr.com)
[15:04:40] *** Quits: ptc (Adium@moz-192425C4.nyc.res.rr.com) (Connection reset by peer)
[15:07:17] *** Quits: ptc1 (Adium@moz-192425C4.nyc.res.rr.com) (Connection reset by peer)
[15:07:22] *** Joins: ptc (Adium@6C906E9F.9ECAA4DB.BCDD830B.IP)
[15:08:02] *** Joins: zerno (Mibbit@moz-2E43177.dynamic.qsc.de)
[15:08:39] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[15:09:17] *** Joins: lenstr (lenstr@66C0DC19.121853A2.28B5BA55.IP)
[15:10:48] *** Quits: lenstr (lenstr@66C0DC19.121853A2.28B5BA55.IP) (Quit: Leaving...)
[15:14:59] <cmr> ChrisMorgan: acrichto had/has a branch removing them
[15:18:34] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[15:18:58] *** Joins: ianj (ianjneu@moz-7140CF01.ccs.neu.edu)
[15:20:27] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[15:20:46] *** Quits: fyolnish (fyolnish@moz-8D7496A5.uqwimax.jp) (Client exited)
[15:21:02] *** jorendorff_away is now known as jorendorff
[15:21:13] *** Joins: lpy (lpy@12172131.F09091A8.1348A864.IP)
[15:21:55] *** Quits: ptc (Adium@6C906E9F.9ECAA4DB.BCDD830B.IP) (Connection reset by peer)
[15:23:01] *** Quits: canhtak (canhtak@moz-1D882009.wl.t.ulaval.ca) (Connection reset by peer)
[15:23:05] *** Joins: canhtak (canhtak@moz-1D882009.wl.t.ulaval.ca)
[15:23:12] *** Joins: ptc (Adium@moz-192425C4.nyc.res.rr.com)
[15:25:49] *** Quits: smodo (tadnr@moz-6398EFDF.dclient.hispeed.ch) (Ping timeout)
[15:26:25] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[15:26:50] *** Joins: Scriptor (anonymous@moz-E06F46F0.corp.bitshelter.com)
[15:32:41] *** Joins: alan_andrade (alan_andra@moz-7559582E.hsd1.ca.comcast.net)
[15:33:01] *** Quits: zerno (Mibbit@moz-2E43177.dynamic.qsc.de) (Quit: http://www.mibbit.com ajax IRC Client)
[15:33:02] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[15:33:45] *** Quits: ptc (Adium@moz-192425C4.nyc.res.rr.com) (Connection reset by peer)
[15:33:51] *** Joins: ptc (Adium@6C906E9F.9ECAA4DB.BCDD830B.IP)
[15:34:09] *** Joins: samx (sami@3EB32A7C.10A53EE3.77834EAA.IP)
[15:34:24] *** Quits: alan_andrade (alan_andra@moz-7559582E.hsd1.ca.comcast.net) (Ping timeout)
[15:34:39] *** Joins: moostik (Icedove@moz-6D4FE356.w86-212.abo.wanadoo.fr)
[15:35:12] *** Joins: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net)
[15:39:32] *** Joins: Skif (emschwar@moz-CA025D57.ip.mcleodusa.net)
[15:40:18] *** Quits: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net) (Ping timeout)
[15:40:20] *** Joins: smodo (tadnr@moz-6398EFDF.dclient.hispeed.ch)
[15:40:39] *** Joins: jvns (bork@87D98E32.4046EB22.428F94DD.IP)
[15:42:26] *** Joins: tav (tav@moz-12977B11.range86-150.btcentralplus.com)
[15:43:50] *** Quits: eternaleye (eternaleye@moz-5668AFCB.hsd1.wa.comcast.net) (Connection reset by peer)
[15:43:51] *** Quits: Skif (emschwar@moz-CA025D57.ip.mcleodusa.net) (Ping timeout)
[15:44:27] *** Joins: sixbrx (Mibbit@moz-7A900440.fda.gov)
[15:45:35] *** Joins: alan_andrade (alan_andra@moz-7559582E.hsd1.ca.comcast.net)
[15:45:47] *** sam113101 is now known as sam113101_afk
[15:45:54] *** Joins: Skif (emschwar@moz-CA025D57.ip.mcleodusa.net)
[15:47:17] *** Quits: alan_andrade (alan_andra@moz-7559582E.hsd1.ca.comcast.net) (Ping timeout)
[15:47:29] *** Joins: eternaleye (eternaleye@moz-5668AFCB.hsd1.wa.comcast.net)
[15:48:02] <sixbrx> Q for anyone: Trying to do Rc::new(my_struct), but got error that it's not "Freeze".  Do I need to Rc around an owned ref to the struct instead?
[15:48:41] <cmr> sixbrx: no, you either need to figure out why your struct isn't Freeze and make it Freeze, or use the from_send constructor.
[15:49:22] <sixbrx> Couldn't find what Freeze is exactly, except that people disagreed on the name :)
[15:49:35] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[15:50:41] <cmr> sixbrx: containing RefCell, @mut, or any other type which is not Freeze, recursively, makes your type ineligible for Freeze
[15:51:08] <cmr> Including &mut afaik...
[15:51:39] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[15:52:10] <sixbrx> cmr: ok it gives me some direction, thx
[15:52:21] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[15:53:33] *** Joins: bynaryshef (bynaryshef@moz-B4E38B6F.mem.bellsouth.net)
[15:53:38] *** Joins: AvianFlu (AvianFlu@moz-723527FF.nycmny.fios.verizon.net)
[15:53:57] *** Quits: AvianFlu (AvianFlu@moz-723527FF.nycmny.fios.verizon.net) (Quit: Leaving...)
[15:55:07] *** Quits: skade (skade@moz-3DC698FE.pools.arcor-ip.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[15:55:57] *** Joins: AvianFlu (AvianFlu@moz-723527FF.nycmny.fios.verizon.net)
[15:56:37] *** Joins: alan (alan@moz-FE02DD30.sat6.rackspace.com)
[15:58:52] *** Quits: sixbrx (Mibbit@moz-7A900440.fda.gov) (Quit: http://www.mibbit.com ajax IRC Client)
[15:59:36] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[15:59:59] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[16:00:17] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[16:02:36] *** Quits: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net) (Quit: Sharp)
[16:04:01] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[16:04:18] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[16:04:25] *** Quits: StarLight (StarLight@11677ED8.2BF90289.F1EF1E39.IP) (Ping timeout)
[16:05:08] *** Quits: nkoep (nik@moz-B106D44A.vpn.rwth-aachen.de) (Ping timeout)
[16:07:29] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[16:07:40] <TobiasFar> eddyb: thanks...i'll try that out in a moment
[16:07:55] <eddyb> welcome back :P
[16:07:57] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[16:08:00] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[16:08:19] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[16:08:24] *** Quits: bynaryshef (bynaryshef@moz-B4E38B6F.mem.bellsouth.net) (Quit: Leaving)
[16:08:51] *** Joins: StarLight (StarLight@moz-394A896.dynamic.avangarddsl.ru)
[16:09:42] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Ping timeout)
[16:10:07] *** Joins: jvshahid (jvshahid@BE83DFD.50866E69.CA2DF2C0.IP)
[16:10:42] *** Joins: hoverbear (hoverbear@moz-86FCBF4B.gv.shawcable.net)
[16:10:53] *** Quits: smodo (tadnr@moz-6398EFDF.dclient.hispeed.ch) (Ping timeout)
[16:12:07] *** Quits: ptc (Adium@6C906E9F.9ECAA4DB.BCDD830B.IP) (Quit: Leaving.)
[16:12:29] *** zz_kimundi is now known as kimundi
[16:14:10] *** Quits: Ms2ger (Ms2ger@moz-B6861E63.ibbt.be) (Quit: bbl)
[16:14:26] *** sam113101_afk is now known as sam113101
[16:16:08] *** Joins: lkuper (lkuper@moz-D862222C.dhcp-bl.indiana.edu)
[16:18:34] <olsonjeffery> anyone know the format!() syntax to display a &uint ?
[16:18:49] <olsonjeffery> doesn't work w/ {:u} and i can't deref the &uint :/
[16:19:03] *** Joins: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net)
[16:19:23] *** Joins: Skif_ (emschwar@moz-CA025D57.ip.mcleodusa.net)
[16:19:45] <eddyb> olsonjeffery: {:?} will work. why can't you deref it?
[16:19:46] *** Quits: Skif_ (emschwar@moz-CA025D57.ip.mcleodusa.net) (Connection reset by peer)
[16:20:00] *** Quits: Skif (emschwar@moz-CA025D57.ip.mcleodusa.net) (Ping timeout)
[16:20:06] *** Joins: Skif (emschwar@moz-CA025D57.ip.mcleodusa.net)
[16:20:29] *** Quits: Skif (emschwar@moz-CA025D57.ip.mcleodusa.net) (Client exited)
[16:20:31] *** Joins: Skif (emschwar@moz-CA025D57.ip.mcleodusa.net)
[16:20:57] *** Joins: lenstr (lenstr@66C0DC19.121853A2.28B5BA55.IP)
[16:21:03] *** Quits: lenstr (lenstr@66C0DC19.121853A2.28B5BA55.IP) (Quit: lenstr)
[16:21:26] *** Joins: fyolnish (fyolnish@moz-D762284E.uqwimax.jp)
[16:21:59] *** Joins: Skif_ (emschwar@moz-CA025D57.ip.mcleodusa.net)
[16:22:06] *** Quits: Skif (emschwar@moz-CA025D57.ip.mcleodusa.net) (Connection reset by peer)
[16:22:07] *** Joins: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com)
[16:22:49] *** Joins: jeaye (Jeaye@moz-34FEF2BB.hsd1.ca.comcast.net)
[16:23:08] *** Quits: fyolnish (fyolnish@moz-D762284E.uqwimax.jp) (Ping timeout)
[16:23:17] *** Quits: oberstet (quassel@moz-2273E6F.dynamic.mnet-online.de) (Client exited)
[16:23:45] *** Joins: nkoep (nik@moz-31E42C4C.pool.mediaways.net)
[16:24:23] *** Joins: cubic (cubic@moz-80241A3A.mc.videotron.ca)
[16:24:28] *** Joins: voxpopuli (fanservice@moz-FE161659.wv.cc.cmu.edu)
[16:24:30] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[16:25:23] *** Joins: smodo (tadnr@moz-6398EFDF.dclient.hispeed.ch)
[16:25:56] *** Quits: samnardoni (samnardoni@F889EF52.38924046.A86B7D63.IP) (Ping timeout)
[16:26:13] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[16:26:58] *** Joins: mib_euvwof (Mibbit@moz-2E43177.dynamic.qsc.de)
[16:27:30] <mib_euvwof>     pub struct Window { screen: &Screen }          missing lifetime specifier
[16:27:33] <mib_euvwof> how do I fix this?
[16:27:43] <cmr> pub struct Window<'a> { screen: &'a Screen }
[16:28:44] <eddyb> http://static.rust-lang.org/doc/master/std/vec/trait.MutableVector.html why is there no mut_windows?
[16:28:45] <mib_euvwof>  error: wrong number of lifetime parameters: expected 1 but found 0
[16:29:11] <eddyb> from the description here, it seems it could very well be mutable http://static.rust-lang.org/doc/master/std/vec/trait.ImmutableVector.html#tymethod.windows
[16:29:30] <eddyb> mib_euvwof: you have to add <'something> everywhere you use Window
[16:29:35] *** Quits: Skif_ (emschwar@moz-CA025D57.ip.mcleodusa.net) (Connection reset by peer)
[16:29:36] *** Joins: jlong (jlong@moz-6DFDE846.socal.res.rr.com)
[16:29:49] *** Joins: Skif (emschwar@moz-CA025D57.ip.mcleodusa.net)
[16:30:04] <eddyb> mib_euvwof: keep in mind that &Screen is only useful if you always create Window *below* Screen
[16:30:57] <eddyb> like "let screen = Screen::new(...); let window = Window { screen: &screen };"
[16:31:12] *** Joins: nano (nano@moz-ED77243C.superkabel.de)
[16:31:17] <eddyb> and window can't escape the block/function screen is defined in
[16:31:47] <cmr> eddyb: hm, does mut_chunks do it?
[16:31:57] <cmr> wait no
[16:31:59] <eddyb> nope, I need overlapping windows
[16:32:03] <cmr> yeah
[16:32:05] *** Quits: sk (sk@9E6B574B.EB2AA036.2CAF0D3B.IP) (Quit: Leaving)
[16:32:23] *** Quits: samx (sami@3EB32A7C.10A53EE3.77834EAA.IP) (Quit: This computer has gone to sleep)
[16:33:51] <eddyb> I can use chunks/mut_chunks when decoding bytes to pixels, but not when applying the filter. there, some filter methods require me to access the byte at current_index - some_constant
[16:33:53] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[16:35:46] <eddyb> I already use a secondary small circular buffer, in the case where I need the values of a few previous bytes *before* writing them
[16:35:55] *** Quits: smodo (tadnr@moz-6398EFDF.dclient.hispeed.ch) (Ping timeout)
[16:36:09] <mib_euvwof> pub struct Window<'a> { screen: &'a Screen<'a> }      this type cannot be instantiated without an instance of itself
[16:36:28] <eddyb> mib_euvwof: does Screen contain Window?
[16:37:01] <mib_euvwof> not necessarily
[16:37:09] <eddyb> what does that even mean?
[16:37:26] <mib_euvwof> Screen is a computer display. Window is one window on this display.
[16:37:27] <eddyb> I've already shown you how to instantiate it. if that doesn't work, you can't use borrowed references
[16:37:34] <eddyb> and Screen has a list of Windows?
[16:37:52] <mib_euvwof> yeh
[16:37:55] <mib_euvwof> *yes
[16:38:20] <eddyb> you can't use ~, only @ (which I really advise against, it's deprecated) or Rc
[16:38:34] <eddyb> but you have a cycle. so you need StrongRef and WeakRef
[16:38:51] *** Joins: lenstr (lenstr@66C0DC19.121853A2.28B5BA55.IP)
[16:39:04] *** Quits: lenstr (lenstr@66C0DC19.121853A2.28B5BA55.IP) (Quit: Leaving...)
[16:39:42] <eddyb> this is the same problem that a doubly linked list and a tree with parent pointers in nodes have
[16:43:51] <strcat> https://github.com/thestinger/rust-core/blob/master/core/weak.rs
[16:44:00] <strcat> the stdlib needs a NonManaged kind to write this properly
[16:44:31] <eddyb> mib_euvwof: for back-references you can use unsafe pointers (which is safe *only* in some cases) or WeakRef (with StrongRef for the screen -> window reference. or the other way around, I'm not sure)
[16:45:01] <eddyb> strcat: std::rc is broken for non-NonManaged, too
[16:45:07] <mib_euvwof> eddyb: So should I use Option<...> at one end?
[16:45:08] <eddyb> as in, segfault
[16:45:13] <eddyb> mib_euvwof: no, that's not enough
[16:45:44] <eddyb> strcat: std doesn't have Strong/WeakRef Rc?
[16:45:48] <strcat> eddyb: no
[16:45:54] <strcat> can't be properly written
[16:45:56] <strcat> in std
[16:46:09] <strcat> anyway I don't feel like dealing with @
[16:46:31] <eddyb> strcat: but it already has Rc and that can't be properly written either. or maybe it can, but it's hard
[16:46:38] <strcat> eddyb: it can be written properly
[16:46:41] <strcat> maybe it's not
[16:46:59] <eddyb> by taking a reference and then forgetting the original?
[16:47:02] <strcat> ~[T] has broken methods in the stdlib when it contains @ too
[16:47:45] <eddyb> I had to make the original immortal in my case, to get the silly ast::P(...) with P<T> = &'static T working
[16:48:08] <eddyb> nmatsakis was talking about expressing more things with types, so NonManaged might not be far off
[16:48:23] <eddyb> strcat: any idea why I have mut_slice calls in my compiled code?
[16:48:30] <eddyb> it's marked as #[inline]
[16:48:46] <strcat> no, dunno
[16:49:23] *** Joins: tiffany (kawaii@moz-FC0DB29D.dhcp.embarqhsd.net)
[16:50:30] *** Joins: smodo (tadnr@moz-6398EFDF.dclient.hispeed.ch)
[16:51:43] *** Quits: mib_euvwof (Mibbit@moz-2E43177.dynamic.qsc.de) (Quit: http://www.mibbit.com ajax IRC Client)
[16:56:52] <eddyb> strcat: any ideas on why LLVM generates this awful code? mov    -0x80(%rbp),%rdx; lea    0x1(%rdx),%rdi; mov    %rdi,-0x80(%rbp)
[16:56:56] *** Quits: nkoep (nik@moz-31E42C4C.pool.mediaways.net) (Client exited)
[16:57:07] <strcat> no
[16:57:16] *** Joins: michaelgreene (michael@DA820AA2.17CD9887.F12515B4.IP)
[16:57:27] <strcat> self is not passed properly
[16:57:33] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[16:57:37] <eddyb> the first instruction (loading the counter from the stack) is almost 40% of the main function
[16:57:46] <eddyb> it's just a i += 1;
[16:58:36] <eddyb> and the same instruction, inlined in some other place is another 13%
[16:59:16] <eddyb> I mean, more than half the samples in my PNG decoder are loading a value from stack just to increment it
[16:59:21] <hoverbear> This is the only irc channel I've ever been on where someone tosses out Assembly code.
[16:59:39] <eddyb> and consider I'm less than 1.5 times slower than libpng
[17:00:19] <eddyb> once all these silly things have been ironed out, idiomatic rust can surely compete with micro optimized C code
[17:00:21] <cmr> hoverbear: you need to find more fun irc channels ;)
[17:00:24] <strcat> eddyb: does this involve `self`?
[17:00:30] <hoverbear> cmr: Apparently.
[17:00:31] <eddyb> strcat: no, it's i += 1;
[17:00:35] <strcat> we generate bad IR in general
[17:00:49] <strcat> in many cases LLVM can't fix it
[17:01:40] *** Quits: g3xzh (g3xzh@moz-19E10D7.red.bezeqint.net) (Client exited)
[17:01:59] *** Joins: TimAbraldes (quassel@125EF623.B2666F0E.66399531.IP)
[17:03:26] <TobiasFar> eddyb: otool -L lists libbench.a(r-std-r-rustrt-rust_cxx_glue.o) as component of my rust static library. is this for C++ interoperability? can it be excluded, i.e. if i only want to call rust from C code?
[17:04:09] <eddyb> TobiasFar: nope, it reuses C++ support
[17:04:19] <eddyb> TobiasFar: like, exception handling
[17:04:36] <TobiasFar> hhmm...ok
[17:04:37] <eddyb> you should get a 32bit libstdc++ library
[17:04:42] *** Joins: themgt (themgt@moz-83F07CDA.cm.vtr.net)
[17:05:41] *** Joins: devbug (quassel@2D4E172D.4C8B6099.9B57EA59.IP)
[17:07:23] *** Quits: Ferreus (ferreus@moz-DC788BAF.dip0.t-ipconnect.de) (Ping timeout)
[17:07:25] <eddyb> strcat: call sym._ZN3vec30ImmutableVector__extensions__5slice69he09374fa5525ba02b41cde481216f5577 - but it's not in a loop
[17:07:29] <eddyb> so I'm not sure what to make of it
[17:08:13] <strcat> until `self` parameters are fixed I'm not surprised about methods not working right
[17:08:31] <eddyb> #[inline] seems to work in *some* places
[17:08:33] <strcat> it passes all `self` parameters as a TyDesc basically
[17:08:37] <eddyb> (on methods, that is)
[17:08:55] <strcat> by-value self always passes by-wrong-pointer-type
[17:08:58] *** Joins: spider-mario (spidermari@moz-2F72F6FF.dsl.quantic-telecom.net)
[17:09:03] <eddyb> strcat: haha, I remember seeing TyDesc in some LLVM code earlier and being confused about it...
[17:09:08] <eddyb> why on earth does it do that?
[17:09:13] <cmr> ease
[17:09:27] <strcat> eddyb: I don't think we should have the env ptr at all
[17:09:47] <eddyb> ah, that? kill it with fire
[17:09:51] *** Quits: doomlord_ (servitor@moz-D40D68D6.range86-184.btcentralplus.com) (Connection reset by peer)
[17:09:58] <strcat> rusti: struct Foo { x: int } impl Foo { fn foo(self) { } } let x = Foo { x: 5 }; x.foo()
[17:10:00] -rusti- ()
[17:10:57] *** Quits: smodo (tadnr@moz-6398EFDF.dclient.hispeed.ch) (Ping timeout)
[17:11:05] <eddyb> let me guess. compiling that with #[no_std] will show "TyDesc" somewhere in the output of --emit-llvm
[17:11:12] *** Quits: Earnestly (earnest@88884C6.A3735F9C.39C00A7A.IP) (Ping timeout)
[17:11:36] *** Joins: jackneill (jackneill@moz-91DAEB3F.pool.digikabel.hu)
[17:13:32] *** Quits: gdey (gdey@moz-E4449B64.sd.sd.cox.net) (Quit: Leaving...)
[17:14:08] * eddyb is sick of this unreadable assembly
[17:14:46] *** Quits: lpy (lpy@12172131.F09091A8.1348A864.IP) (Quit: Leaving...)
[17:14:58] <strcat> need to fix self
[17:15:02] <hoverbear> eddyb: :(
[17:15:19] <eddyb> strcat: is that the main problem here?
[17:16:01] <strcat> eddyb: well it's a problem in all code using methods
[17:16:03] <strcat> and look at this
[17:16:12] <strcat> rusti: struct Foo { x: int } impl Foo { fn foo(mut self) { self.x = 5; } } let x = Foo { x: 10 }; x.foo(); x
[17:16:13] -rusti- pastebinned 7 lines of output: http://sprunge.us/QcQL
[17:16:23] <strcat> ugh, 0.8
[17:16:25] <strcat> run that on master
[17:16:27] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[17:17:07] <strcat> lol
[17:17:08] *** Joins: beifeng (Mibbit@7989804A.FA7FF645.C7DB8B78.IP)
[17:17:15] <strcat>     struct Foo { x: int } impl Foo { fn foo(mut self) { self.x = 5; } } let x = Foo { x: 10 }; x.foo();
[17:17:17] <strcat>     println!("{:?}", x)
[17:17:19] <strcat> % ./foo
[17:17:21] <strcat> main::Foo{x: 5}
[17:17:23] * strcat sighs
[17:17:28] <strcat> anyway, need to fix that
[17:17:37] <strcat> I'd just remove the env ptr parameter from methods for now
[17:17:38] *** Joins: sk (sk@61A494B3.BA40E8A.AAC02D62.IP)
[17:17:46] <strcat> and give it the type of self instead
[17:17:47] <eddyb> echo -e '#!/bin/bash\nxclip -selection clipboard $*' > ~/bin/clip; chmod +x ~/bin/clip # should've done that a long time ago
[17:18:13] <o11c> eddyb: for shame!
[17:18:14] *** Joins: glennsl (textual@moz-5D7B804F.getinternet.no)
[17:18:20] <o11c> "$@"
[17:18:26] <erickt> strcat: I tried that a couple months ago, and it was like staring into a sea of madness, and I failed :)
[17:18:44] <erickt> strcat: it might be easier now (I hope). I heard some trans cleanup has been happening
[17:19:29] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[17:19:48] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Ping timeout)
[17:19:55] <eddyb> strcat: oooh, methods use env for self >_>
[17:19:57] <erickt> strcat: Luqman added a cheat to get `fn foo(self)` to work. I believe `self` is actually getting passed by pointer
[17:20:11] <eddyb> yeah, that's what he's been saying :P
[17:20:30] *** Joins: lpy (lpy@12172131.F09091A8.1348A864.IP)
[17:20:33] <strcat> erickt: yeah, it's always passed as the wrong ptr type
[17:20:39] <strcat> it's not good for codegen
[17:20:46] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[17:20:52] <eddyb> oh come on, my little script doesn't work :/
[17:20:52] *** Joins: shmoo (Mibbit@moz-2E43177.dynamic.qsc.de)
[17:21:01] <eddyb> nvm I forgot to -o /dev/stdout >_>
[17:21:08] *** Quits: lpy (lpy@12172131.F09091A8.1348A864.IP) (Quit: Leaving...)
[17:21:27] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[17:21:36] <shmoo> I'm the one who was asking about back references before. Are those discouraged in general?
[17:21:42] * erickt wishes he had a winter vacation to work on things like cmr is getting
[17:21:55] *** Joins: fyolnish (fyolnish@moz-3D3274F2.uqwimax.jp)
[17:21:57] *** Joins: Earnestly (earnest@88884C6.A3735F9C.39C00A7A.IP)
[17:22:00] <eddyb> shmoo: we just don't have a good mechanisms for them, right now
[17:22:09] <eddyb> https://gist.github.com/eddyb/87883963f913e55326b5 it's that big :(
[17:22:39] <erickt> shmoo: what do you mean by back references?
[17:22:44] <eddyb> the function I want to speed up starts at https://gist.github.com/eddyb/87883963f913e55326b5#file-png-ll-L1877
[17:23:15] *** Quits: noam (noam@F6B530A7.720527A7.416762B.IP) (Ping timeout)
[17:23:32] <shmoo> erickt: A has a ~[B], each B has a &A
[17:23:41] *** Quits: fyolnish (fyolnish@moz-3D3274F2.uqwimax.jp) (Ping timeout)
[17:25:22] <erickt> shmoo: ah. yeah, I've run into some internal compiler errors with those. nmatsakis has been recently working on some bugs in that code. #5121 is one off the top of my head
[17:25:32] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[17:25:34] *** Joins: smodo (tadnr@moz-6398EFDF.dclient.hispeed.ch)
[17:25:58] <eddyb> erickt: you can't even construct that
[17:26:25] <eddyb> I compared it to doubly-linked lists and trees with parent pointers in nodes, already :P
[17:27:17] <strcat> Strong/Weak works fine for that
[17:27:27] <shmoo> If this isn't sorted out yet: Should I use raw pointers for now? That's kind of awkward.
[17:27:58] <erickt> eddyb: you kind of can with enums. For example: https://gist.github.com/erickt/7914749
[17:28:24] <erickt> eddyb: ooh that compiles now!
[17:28:42] <strcat> I don't think that's what he wants
[17:29:04] <eddyb> erickt: you can't borrow A as mutable to set the parent field of a B *while* having an immutable borrow to A to put in that parent field
[17:29:17] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[17:29:25] <eddyb> and I hanged chrome. great
[17:29:29] <strcat> https://github.com/thestinger/rust-core/blob/master/core/weak.rs
[17:29:39] <strcat> the backreferences just need to be Weak<T>
[17:31:38] <eddyb> do I have to start kwrite just to remove the parts I don't need from this output? silly browsers
[17:31:48] <erickt> strcat / shmoo: something more like this? https://gist.github.com/erickt/7914804
[17:31:55] <eddyb> strcat: holy fudge, 20k lines
[17:32:00] <eddyb> of LLVM output
[17:32:09] <strcat> erickt: you won't actually be able to put one inside the vector with a reference
[17:32:12] *** Joins: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP)
[17:32:15] <strcat> defining the types isn't the part you can't do
[17:32:28] <shmoo> erickt: yes, something like this
[17:32:48] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[17:32:53] <strcat> it wouldn't be safe for the compiler to allow you to construct stuff like that in general
[17:33:09] <strcat> if you could store a ref inside a child to the parent, you could then store a ref to another child
[17:33:13] <strcat> and remove that child in the parent
[17:33:22] *** Joins: huddler (Mibbit@moz-83C619A8.dynamic.qsc.de)
[17:33:28] *** Quits: beifeng (Mibbit@7989804A.FA7FF645.C7DB8B78.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[17:33:51] *** huddler is now known as shmoo2
[17:35:00] <eddyb> oh you've got to be kidding me. "Go" is translated as "go!" (i.e. telling someone to go) into Romanian in kde4
[17:35:12] <hoverbear> http://i.imgur.com/YZUZrPN.gif
[17:36:13] <eddyb> strcat: so much type visitor glue, sticky!
[17:36:19] <shmoo2> can I use "strong" and "weak" right now? I can't find it in the docs.
[17:36:55] *** Joins: beifeng (Mibbit@7989804A.FA7FF645.C7DB8B78.IP)
[17:37:36] *** Quits: shmoo (Mibbit@moz-2E43177.dynamic.qsc.de) (Quit: http://www.mibbit.com ajax IRC Client)
[17:37:49] <eddyb> shmoo2: nope, not yet implemented
[17:38:02] *** Joins: frogzilla (Mibbit@moz-980DDEA5.columbus.res.rr.com)
[17:38:15] <erickt> strcat: I'm guessing this isn't want shmoo wants, you can at least write this: https://gist.github.com/erickt/7914804
[17:38:18] *** Quits: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP) (Client exited)
[17:39:20] <strcat> if you put the main one in a Strong<T> you can store Weak<T> references inside of it
[17:39:28] <eddyb> { i64, %tydesc*, i8*, i8*, i8 }*, i64, i64
[17:39:36] <eddyb> that is not cool
[17:39:47] <erickt> strcat: the types are right, but there's no back reference, that'd be unsafe without your weak references
[17:40:02] <strcat> erickt: no it wouldn't be unsafe
[17:40:05] <strcat> oh
[17:40:06] <strcat> sorry
[17:40:08] <strcat> misread
[17:40:18] * strcat read 'unsafe with your'...
[17:40:44] <strcat> anyway they can't support @
[17:40:47] <erickt> eddyb: are you talking about the environment being passed in for the first argument? yeah it makes fns really hard to read
[17:40:48] *** Quits: frogzilla (Mibbit@moz-980DDEA5.columbus.res.rr.com) (Quit: http://www.mibbit.com ajax IRC Client)
[17:40:54] <strcat> because they can't just use ~ and use the ~ dtor
[17:41:02] <strcat> they need a free call separate from destroying the inner part
[17:41:06] <eddyb> ok, this is readable (as in, highlighted) https://gist.github.com/eddyb/87883963f913e55326b5
[17:41:37] *** Quits: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com) (Ping timeout)
[17:41:37] *** Quits: prooftechnique (prooftechn@moz-1C9C6B71.hsd1.vt.comcast.net) (Quit: )
[17:41:49] <eddyb> this is one of those hoops it goes through https://gist.github.com/eddyb/87883963f913e55326b5#file-png-ll-L633-L635
[17:42:14] <eddyb> even better, ctrl+f %i
[17:42:17] *** Quits: w3lcome (Mibbit@moz-33A75FFD.home.otenet.gr) (Quit: http://www.mibbit.com ajax IRC Client)
[17:42:43] *** Quits: rca (rcatolino@7F54AB21.28091F66.520D6FA6.IP) (Ping timeout)
[17:42:45] *** Joins: rca (rcatolino@7F54AB21.28091F66.520D6FA6.IP)
[17:43:12] <eddyb> %__closure3 = alloca { i64, %tydesc*, i8*, i8*, { %struct.PartialImage**, i64*, i64* } }, align 8
[17:43:12] <mark_edward> strcat, ping
[17:43:36] <eddyb> it allocates that big stuff and then %i can't stay close to its uses
[17:43:45] <strcat> mark_edward: pong
[17:43:54] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[17:44:46] <mark_edward> strcat, i'm using C FFI. what is your advice using unsafe pointers, with regards to mutability? for ex if a C struct has a *void member, should the Rust struct have a *mut void member?
[17:44:54] <strcat> yes
[17:45:13] <eddyb> const * => *; * => *mut
[17:45:55] *** Joins: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com)
[17:45:59] <eddyb> nsions__5slice69hb747ac2a9c9b61e2f2de0913c02f2101b41ff931eb0f32c6f9768058af890ed6ukaX4v0.0E"({ i8*, i64 }* sret %data, { i64, %tydesc*, i8*, i8*, i8 }* %20, i64 %1, i64 %2)
[17:46:01] <mark_edward> thanks for the advice guys!
[17:46:14] <eddyb> err, partial copy. anyway, that's .slice(..)
[17:46:35] <eddyb> strcat: so you were right, that's causing it to not be inlined (I think)
[17:47:16] <strcat> oh, sret
[17:47:23] <eddyb> another trailer for this weird thing https://www.youtube.com/watch?v=bEys7eVGm94
[17:47:47] <eddyb> to be on topic, I suggest using rust to write that operating system
[17:48:10] *** pmoore is now known as pmoore|away
[17:48:15] <eddyb> then it can have safe emotions :3
[17:48:37] <eddyb> bstrie: for some reason I feel like pinging you when I say silly things
[17:48:57] <mark_edward> what is a C `unsigned char` in `std::libc::`?
[17:49:05] <eddyb> uchar
[17:49:10] <mark_edward> thank you!
[17:49:17] <eddyb> (well, c_uchar)
[17:49:20] <strcat> just use u8, imo
[17:49:25] <mark_edward> the docs for std::libc are very... intricate
[17:49:32] <eddyb> strcat: it's linted against
[17:49:39] <strcat> so use allow(ctypes), it's stupid
[17:49:47] *** Joins: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net)
[17:49:59] <strcat> unsigned char is always u8, uintptr_t is always uint, etc. - it's how the rust/C types are defined
[17:50:04] <strcat> might as well switch to rust types ASAP
[17:50:09] <eddyb> it's not when using "int" by mistake can cause problems
[17:50:35] <eddyb> C++ at least has the type in the symbol name. C will just behave weirdly
[17:50:59] *** Joins: gdey (gdey@moz-CD850554.static-ip.telepacific.net)
[17:51:02] <eddyb> strcat: so what's with sret?
[17:51:04] *** Quits: gdey (gdey@moz-CD850554.static-ip.telepacific.net) (Client exited)
[17:51:06] *** Joins: gdey (gdey@moz-CD850554.static-ip.telepacific.net)
[17:51:09] <strcat> eddyb: nvm
[17:51:58] <strcat> anyway I think the ctypes lint is pointless
[17:52:15] <eddyb> oh wow what? https://gist.github.com/eddyb/87883963f913e55326b5#file-png-ll-L95-L101
[17:52:21] <eddyb> what is going on in there?
[17:52:33] <eddyb> is it an array of closures?
[17:53:08] <strcat> closures are not represented in a great way
[17:53:21] <eddyb> LLVM output needs more debug-info comments
[17:53:23] <strcat> anyway you can't really be surprised that you're getting bad codegen from rust
[17:53:29] <strcat> the pre-optimized IR is far from good
[17:53:38] <eddyb> so much cruft :(
[17:53:39] *** Joins: jdm (jdm@moz-AC9499B2.cable.teksavvy.com)
[17:53:40] *** ChanServ sets mode: +o jdm
[17:53:42] <strcat> eddyb: clang can annotate it
[17:54:04] <eddyb> strcat: do you happen to know how?
[17:54:19] <strcat> well you can't annotate with rustc
[17:54:26] <strcat> just pointing out that LLVM supports comments in IR
[17:54:35] <eddyb> :(
[17:54:39] *** Quits: Ralith (ralith@moz-132F2FD4.sea.wa.customer.broadstripe.net) (Ping timeout)
[17:54:45] <shmoo2> how about this: https://gist.github.com/anonymous/7915236
[17:55:22] <strcat> shmoo2: if you're going to be fine with having tricky unsafe code everywhere
[17:55:32] <strcat> and you understand the borrowing rules you need to enforce
[17:55:33] * strcat shrugs
[17:55:37] <eddyb> shmoo2: that would be &'a self -> &'a A
[17:55:40] <strcat> I would just use that Strong/Weak type I linked to
[17:56:01] <strcat> needs minor adjustments to work with the stdlib
[17:56:02] <eddyb> rusti: cast::transmute
[17:56:03] -rusti- pastebinned 11 lines of output: http://sprunge.us/XVDM
[17:56:15] <strcat> and up to you to not put managed data in it
[17:56:46] <eddyb> rusti: Some::<&'static int>(::std::cast::transmute(0u as *int))
[17:56:47] -rusti- <anon>:9:29: 9:64 error: call to unsafe function requires unsafe function or block
[17:56:47] -rusti- <anon>:9         Some::<&'static int>(::std::cast::transmute(0u as *int))
[17:56:47] -rusti-                                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[17:56:47] -rusti- error: aborting due to previous error
[17:56:47] -rusti- application terminated with error code 101
[17:56:49] <eddyb> err
[17:56:56] <eddyb> rusti: Some::<&'static int>(unsafe{::std::cast::transmute(0u as *int)})
[17:56:58] -rusti- None
[17:57:02] <eddyb> yes! :D
[17:57:02] <shmoo2> strcat: Maybe when it's in the stdlib
[17:57:35] <strcat> it can't go in the stdlib
[17:57:38] <strcat> it wouldn't be sound
[17:57:39] *** Quits: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[17:57:54] <o11c> strcat: it can be made sound by not using ~A
[17:57:58] <strcat> anyway if you'd rather use unsafe code than a reusable pointer type, you can do that
[17:58:02] <strcat> o11c: no it can't
[17:58:07] <strcat> o11c: if you put @ in it, it won't work
[17:58:21] <o11c> well screw @
[17:58:30] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[17:58:38] <eddyb> o11c: you can't yet restrict against it
[17:58:49] <strcat> o11c: sure, rust-core isn't going to support gc, so it doesn't need to worry about this stuff
[17:58:54] <eddyb> rusti: use extra::rc::Rc;
[17:58:56] -rusti- <anon>:9:12: 9:25 warning: unused import [-W unused-imports (default)]
[17:58:56] -rusti- <anon>:9         use extra::rc::Rc;
[17:58:56] -rusti-                      ^~~~~~~~~~~~~
[17:58:56] -rusti- ()
[17:58:57] <strcat> it can have a fast vector type today and strong/weak pointers today
[17:59:01] <strcat> (and does)
[17:59:07] <eddyb> rusti: use extra::rc::Rc; Rc::new(@0)
[17:59:07] -rusti- <anon>:9:27: 9:34 error: unresolved name `Rc::new`.
[17:59:08] -rusti- <anon>:9         use extra::rc::Rc; Rc::new(@0)
[17:59:08] -rusti-                                     ^~~~~~~
[17:59:08] -rusti- error: aborting due to previous error
[17:59:08] -rusti- application terminated with error code 101
[17:59:20] <strcat> it's in std
[17:59:22] <eddyb> yay for 0.8 :(
[17:59:27] <strcat> oh, right
[17:59:29] *** Quits: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com) (Ping timeout)
[17:59:34] <strcat> eddyb: from_send?
[17:59:34] <eddyb> strcat: it's your bot!
[17:59:47] <eddyb> rusti: use extra::rc::Rc; Rc::from_send(@0)
[17:59:47] <strcat> it's not my fault rust has broken I/O.
[17:59:48] -rusti- <anon>:9:27: 9:40 error: instantiating a type parameter with an incompatible type `@int`, which does not fulfill `Send`
[17:59:48] -rusti- <anon>:9         use extra::rc::Rc; Rc::from_send(@0)
[17:59:48] -rusti-                                     ^~~~~~~~~~~~~
[17:59:48] -rusti- error: aborting due to previous error
[17:59:49] -rusti- application terminated with error code 101
[17:59:58] <eddyb> hmpf, I've managed to do this before
[18:00:00] <strcat> eddyb: from_freeze
[18:00:05] <strcat> that's what became new
[18:00:07] <eddyb> rusti: use extra::rc::Rc; Rc::from_freeze(@0)
[18:00:09] -rusti- extra::rc::Rc<@int>{ptr: (0x7f55e44200f0 as *mut ())}
[18:00:09] -rusti- out: /build/rust/src/rust-0.8/src/rt/boxed_region.cpp:70: void boxed_region::free(rust_opaque_box*): Assertion `box->td != __null' failed.
[18:00:09] -rusti- application terminated abnormally with signal 11 (Segmentation fault)
[18:00:11] <strcat> there
[18:00:12] *** Joins: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP)
[18:00:21] *** Joins: gdey_ (gdey@moz-CD850554.static-ip.telepacific.net)
[18:00:40] <strcat> eddyb: now try shrink_to_fit on ~[T]
[18:00:43] <strcat> or some other methods
[18:00:45] <strcat> with @ inside
[18:00:47] <strcat> broken too
[18:01:11] <eddyb> rusti: let v = ~[@0]; v.push(@1); v
[18:01:12] -rusti- <anon>:9:23: 9:24 error: cannot borrow immutable local variable as mutable
[18:01:12] -rusti- <anon>:9         let v = ~[@0]; v.push(@1); v
[18:01:12] -rusti-                                 ^
[18:01:12] -rusti- error: aborting due to previous error
[18:01:12] -rusti- application terminated with error code 101
[18:01:18] <eddyb> rusti: let mut v = ~[@0]; v.push(@1); v
[18:01:19] -rusti- ~[@0, @1]
[18:01:29] <eddyb> hang on, how does push work?
[18:01:32] <strcat> rusti: let mut v = ~[@0]; v.push(@1); v.shrink_to_fit(); v
[18:01:33] -rusti- ~[]
[18:01:33] *** Quits: gdey (gdey@moz-CD850554.static-ip.telepacific.net) (Ping timeout)
[18:01:34] -rusti- application terminated abnormally with signal 11 (Segmentation fault)
[18:01:38] <strcat> eddyb: a branch on contains_managed
[18:01:43] <eddyb> oh
[18:02:05] *** Joins: brendan (brendaneic@777B9EEC.C030CAFC.1EF54B18.IP)
[18:02:23] <eddyb> strcat: any idea what the closure setup code I linked does?
[18:02:46] <eddyb> I think it sets pointers to the captured arguments & locals
[18:02:47] <strcat> closures are represented the same way as @ boxes
[18:02:49] <strcat> with a TyDesc
[18:02:53] <mark_edward> how would you write this C struct member in Rust? ` unsigned char* unknown_chunks_data[3];`?
[18:02:56] *** Quits: gdey_ (gdey@moz-CD850554.static-ip.telepacific.net) (Client exited)
[18:02:56] <strcat> the TyDesc describes the captures
[18:02:58] *** Joins: gdey (gdey@moz-CD850554.static-ip.telepacific.net)
[18:03:04] <strcat> it's all unnecessary, it's just that way to support @
[18:03:09] <eddyb> mark_edward: [*c_uchar, ..3]
[18:03:09] <strcat> otherwise you'd just have a ptr to the dtor
[18:03:11] <strcat> for proc
[18:03:32] <mark_edward> eddyb, thank you. this will work correctly if said struct was passed to a C function?
[18:03:36] *** Joins: sanxiyn (tinuviel@5572118A.71F82290.4BEB41DB.IP)
[18:03:40] <strcat> or just [*u8, ..3]... avoiding unnecessary copies is nice
[18:03:45] <strcat> well
[18:03:53] <strcat> [*mut u8, ..3]
[18:03:59] <eddyb> copies?
[18:04:41] <strcat> rust will consider the arrays to have different types
[18:05:33] <strcat> guess it doesn't really matter, passing for FFI calls adds a wrapper function doing an indirect copy for each parameter anyway
[18:06:05] <eddyb> strcat: hmm, what if just int/uint are linted against in extern "C" fns?
[18:06:22] <eddyb> because you can't really go wrong with the sized ones
[18:06:25] *** Joins: wilmoore (wilmoore@moz-1248C037.mystrotv.com)
[18:06:27] <strcat> I still won't use the lint, uint matches size_t/uintptr_t
[18:06:30] <sfackler> I'd be okay with that
[18:07:07] <sfackler> strcat: the only time I've ever used int in a ffi binding is when I should have been using c_int
[18:07:30] <strcat> I've made dozens of FFI bindings for functions taking size_t
[18:07:31] <eddyb> the temptation is too high
[18:07:32] <strcat> via uint
[18:07:50] *** sam113101 is now known as sam113101_afk
[18:10:17] *** Joins: pepper_chico (pepper_chi@6D1D0FAA.4F150827.E4090502.IP)
[18:11:10] <shmoo2> I don't understand lifetimes. The document (lifetimes explained) doesn't really help either because it only handles one case and one solution and makes it sound like it's the obvious one. If so and if there are no other solutions, then why can't the compiler infer the lifetimes?
[18:11:16] *** Joins: doomlord_ (servitor@moz-D40D68D6.range86-184.btcentralplus.com)
[18:11:27] <eddyb> strcat: I don't understand why that closure setup code is there. I don't see the closure being used at all
[18:11:51] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Client exited)
[18:11:53] <eddyb> strcat: nvm, I'm an idiot
[18:11:53] <strcat> shmoo2: inference is local to functions
[18:12:10] <strcat> it would be incomprehensible if it inferred everywhere, there'd be no understanding APIs or errors
[18:12:20] <bstrie> shmoo2: the compiler does infer lifetimes. the only time when it doesn't is when you return a borrowed reference, in which case you need to tell the compiler which of the input parameters has the same lifetime as the output parameter
[18:12:43] <strcat> a function signature describes everything externally relevant about the function in the type systenm
[18:12:52] <eddyb> strcat: I missed the obvious cast from the closure stack local to something obscure
[18:12:55] <strcat> rust won't give an error based on something inside the function when you're calling it
[18:13:07] <eddyb> strcat: "errors" - reminds me of C++
[18:13:11] <strcat> shmoo2: if you use Strong/Weak you won't have to write unsafe code
[18:13:38] <shmoo2> strcat: So why doesn't the compiler look at the function, infer the lifetimes itself, and extends the signature?
[18:13:53] <eddyb> shmoo2: because you end up with dependencies
[18:14:02] <eddyb> and infinitely more work
[18:14:08] <sanxiyn> shmoo2: Can't, really
[18:14:09] <eddyb> that infinite is literal
[18:14:28] <strcat> shmoo2: so you want the compiler to do type checking and write to the file?
[18:14:35] <strcat> it doesn't know exactly what you want in the signature
[18:14:55] <strcat> lifetimes are part of types
[18:14:59] <strcat> it's no different than having to write function signatures as types
[18:15:01] <strcat> it's part of the same thing.
[18:15:10] *** Joins: noam (noam@F6B530A7.720527A7.416762B.IP)
[18:15:26] <strcat> the compiler doesn't know the exact signature you want
[18:15:29] <eddyb> strcat: yay I found the closure https://gist.github.com/eddyb/87883963f913e55326b5#file-png-ll-L937
[18:15:37] <eddyb> strcat: which isn't inlined >:(
[18:15:43] <strcat> and anyway, even if it did for safe code, it couldn't possibly know it for unsafe code
[18:15:52] <shmoo2> strcat: No, I want it to extend the type signature in its internal representation and in the object files
[18:16:29] *** Quits: bjustin (bjustin@moz-8FC28563.sierrabravo.net) (Ping timeout)
[18:16:30] <strcat> shmoo2: the compiler can't infer the precise signature even for safe code
[18:16:42] <strcat> shmoo2: and it's against rust's philosophy to have non-local type inference
[18:16:49] <strcat> the errors would *not* be comprehensible
[18:17:08] <strcat> it would be a lot harder to debug than it is now
[18:17:09] *** Quits: Jesin (Jesin@moz-63C897DA.res.lehigh.edu) (Quit: Leaving)
[18:17:14] <strcat> errors would be a lot less clear
[18:17:29] <strcat> I don't think it's too much to ask to write the type signatures of functions without inference
[18:18:00] <strcat> it helps you reason about the code
[18:18:08] *** Joins: samx (sami@3EB32A7C.10A53EE3.77834EAA.IP)
[18:18:16] <strcat> even local type inference can make it hard to reason about in long functions
[18:18:29] <eddyb> erm, strcat, you should mention that infinite thing >_>
[18:18:46] <eddyb> non-local inference of any kind is a massive workload
[18:19:09] <shmoo2> What's an example of complicated lifetimes?
[18:19:39] <strcat> I don't think there are any existing complicated uses of lifetimes, it's mostly pretty simple
[18:19:56] <strcat> we don't have multiple lifetime parameters yet so you can't really do anything complicated
[18:20:05] <eddyb> with a file smaller than the entire rustc codebase, I've managed to make liveness attempt allocating 700GB at once
[18:20:26] <sanxiyn> eddyb: Huh
[18:20:37] <bstrie> eddyb: did it work? :)
[18:20:47] <eddyb> it's possible borrowck wanted even more, but it was allocating in steps, so we will never now
[18:20:57] <sanxiyn> know
[18:21:05] <eddyb> err, yes, missed a key
[18:21:26] <eddyb> bstrie: I ended up moving every match case into its own function. that is, every line for ~2k lines
[18:21:28] *** Joins: prooftechnique (prooftechn@moz-1C9C6B71.hsd1.vt.comcast.net)
[18:21:29] <bstrie> eddyb: that's no excuse, the whole reason we have 64-bit arches is so that we can address terabytes of ram! go buy some more sticks and try again
[18:21:51] <eddyb> bstrie: if mozilla pays for that RAM, sure :P
[18:22:00] <strcat> shmoo2: rust makes you specify all the types, and for generic functions it makes you specify all of the trait bounds
[18:22:04] *** Joins: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net)
[18:22:23] <shmoo2> How about lifetimes in structs? Shouldn't every field just live at least as long as the struct?
[18:22:25] <eddyb> now imagine if rust did inference outside of those functions
[18:22:26] <strcat> a function with borrowed ptrs in the signature is basically generic, in a different kind of way (only relevant to type-checking)
[18:22:35] <strcat> shmoo2: no
[18:22:40] <strcat> shmoo2: for example an iterator
[18:22:59] <strcat> you can have an iterator yielding references into a container
[18:22:59] <eddyb> my work to bypass that immense workload would be nullified
[18:23:01] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[18:23:01] *** ChanServ sets mode: +ao brson brson
[18:23:02] <bstrie> shmoo2: we've attempted more pervasive lifetime inference in the past. it didn't work out well. trust us when we say that the current rules were arrived at through experience :)
[18:23:12] <eddyb> imagine what would happen with rustc
[18:23:20] <strcat> shmoo2: so the references it yields live as long as the container
[18:23:21] <eddyb> it uses buttloads of RAM already
[18:23:31] <strcat> you can keep them after mutating the iterator, or having the iterator go out of scope
[18:23:36] <strcat> nothing ties them to the iterator struct
[18:23:40] <sanxiyn> shmoo2: No field can outlive struct
[18:24:02] <strcat> if you zip this iterator with another iterator yielding refs, you now have an iterator yielding refs with two different lifetimes
[18:24:05] *** Quits: indirect (indirect@moz-3589B90B.c.ircrelay.com) (Ping timeout)
[18:24:05] *** Quits: carter (carter@moz-3589B90B.c.ircrelay.com) (Ping timeout)
[18:24:05] *** Quits: indutny (indutny@moz-3589B90B.c.ircrelay.com) (Ping timeout)
[18:24:21] <strcat> basically it yields (&'a T, &'b U)
[18:24:33] <strcat> where you have a container<T> with lifetime 'a and a container<U> with lifetime 'b
[18:24:44] *** Quits: brendan (brendaneic@777B9EEC.C030CAFC.1EF54B18.IP) (Quit: brendan)
[18:25:03] <strcat> you can't actually write a signature that complex without generic code atm, since we don't have multiple lifetime parameters
[18:25:11] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[18:25:31] <strcat> and I dunno if it will be as flexible as it should be atm, but it would be forwards compatible with future improvements
[18:25:49] *** Quits: Sorella (quildreen@2392D500.600E39D3.1ED99692.IP) (Ping timeout)
[18:25:54] *** Quits: dredozub_ (dredozubov@2F14E2C1.F70E5FA9.F63E14E8.IP) (Input/output error)
[18:26:11] *** Joins: Sorella (quildreen@2392D500.600E39D3.1ED99692.IP)
[18:26:43] <sanxiyn> I think currently it's like Zip<A, B> where A is Iterator<&'a T> and B is Iterator<&'b U>, right?
[18:27:09] <strcat> yes but I don't know if it's actually as flexible as 'a and 'b
[18:27:23] <strcat> it will become that flexible if it isn't today
[18:27:51] <strcat> sanxiyn: we don't have multiple lifetime parameters yet and I don't know if that's just a syntax level limitation or also a typechecking one
[18:27:53] <shmoo2> I don't think I understand yet. When I define a struct that contains borrowed pointers, then there seems to be only one way to make it compile: Put 'a everywhere.
[18:27:55] <bstrie> what's the bug # for multiple lifetime parameters
[18:28:08] <strcat> shmoo2: because we don't have multiple lifetime parameters yet
[18:28:16] <strcat> you will be able to give them different lifetimes
[18:28:56] <mark_edward> are C enums always ints?
[18:28:58] <sanxiyn> shmoo2: Actually we did use to infer lifetime in struct fields
[18:29:10] <sanxiyn> shmoo2: It didn't work better
[18:29:20] <strcat> well it worked but people got confused by it
[18:29:27] <strcat> now it's very clear when a struct is bounded by a lifetime
[18:29:37] <bstrie> mark_edward: you mean rust's C-style enums, or actual C enums?
[18:29:47] <strcat> and it will be very clear that you have the choice to associate the lifetimes of the ptrs together or no
[18:29:52] <mark_edward> bstrie, actual C enums
[18:30:09] <strcat> struct Foo<'a, 'b> { x: &'a int, y: &'b int } will compile eventually
[18:30:26] <bstrie> mark_edward: even if it is, I don't think the width of a C int is universally specified...
[18:30:35] <sanxiyn> shmoo2: http://smallcultfollowing.com/babysteps/blog/2012/12/30/lifetime-notation/ is how Rust used to infer lifetime
[18:30:54] <sanxiyn> (Note that StringReader has & field without parameter)
[18:31:07] <mark_edward> bstrie, i know, i mean if C enums are always C ints insize?
[18:31:09] <sanxiyn> See the post for inferred result
[18:31:10] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[18:31:19] <strcat> mark_edward: no, they aren't
[18:31:28] <eddyb> mark_edward: #[repr(C)]" on Rust enums will make them compatible
[18:31:32] *** Joins: Ralith (ralith@A8995AA9.62B6AF6A.922221DB.IP)
[18:31:35] <eddyb> mark_edward: if that's what you need
[18:31:37] <strcat> there is no guarantee about enum size across platforms - on some they are as small as necessary, on some they start as c_int and expand as necessary
[18:31:40] <mark_edward> eddyb, thank you
[18:31:49] <strcat> #[repr(C)] enums don't entirely work
[18:31:56] <eddyb> s/"//
[18:32:10] <strcat> although maybe jld fixed that
[18:32:17] <strcat> they didn't get returned properly or something like that
[18:32:23] <mark_edward> wait so then what do i do if a C function needs a C enum as a param? what type should i say the arg is?
[18:32:29] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[18:32:39] <strcat> mark_edward: a repr(C) enum
[18:32:43] <eddyb> mark_edward: the enum
[18:32:47] *** Quits: CarpNet (ac@moz-FD24B77.sohonet.co.uk) (Quit: Leaving)
[18:32:50] *** Joins: brendan (brendaneic@777B9EEC.C030CAFC.1EF54B18.IP)
[18:32:51] <shmoo2> mark_edward: C enums are always ints
[18:32:54] <strcat> shmoo2: no
[18:33:03] <sanxiyn> mark_edward: Even C enums in C are not always C int sized
[18:33:14] <strcat> they are always int on x86_64 linux with gcc without -fshort-enums, yes
[18:33:15] <sanxiyn> mark_edward: If you pass -fshort-enums to GCC
[18:33:17] <strcat> elsewhere, they are not
[18:33:23] <strcat> sanxiyn: and that's the default on some ABIs
[18:33:29] <strcat> ARM eabi maybe?
[18:33:30] <sanxiyn> I see
[18:33:34] <sanxiyn> No idea
[18:33:47] *** Quits: pepper_chico (pepper_chi@6D1D0FAA.4F150827.E4090502.IP) (Quit: Ex-Chat)
[18:33:58] *** Joins: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP)
[18:33:59] <strcat> and also a C enum will expand to 64-bit if you have values that big
[18:34:08] <eddyb> was going to mention that
[18:34:13] <strcat> http://www.rtems.org/wiki/index.php/ARM-EABI yeah
[18:34:21] <eddyb> just like literals
[18:34:22] <strcat>  Short enums. The standard ARM EABI configuration in GCC uses short enums by default. See also ARM Architecture Procedure Call Standard (AAPCS) section 7.1.3 "Enumerated Types". This may lead to portability problems since many architectures use int as the base type for enums. The XDR library is one problem candidate. 
[18:35:05] <eddyb> 0x100000000 > (0x10000000 << 16)
[18:35:11] <shmoo2> strcat: enum A { B }   . sizeof(B) == sizeof(int). sizeof(A) might be smaller.
[18:35:19] <sanxiyn> Heh I did read AAPCS carefully... must have missed that
[18:35:58] <strcat> shmoo2: B isn't the enum type, it's not relevant to the sizes the ABI requires
[18:36:17] <strcat> 'c' is an int too in C
[18:37:00] *** Quits: wilmoore (wilmoore@moz-1248C037.mystrotv.com) (Ping timeout)
[18:37:00] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.2)
[18:37:38] <jld> strcat: Fixed that a little while ago.
[18:38:00] <jld> #10592 can probably be closed now, speaking of which.
[18:38:34] *** Joins: nsf (nsf@moz-EEF3238A.convex.ru)
[18:39:08] *** Joins: pcwalton (pcwalton@moz-DFAA4E15.p2p.sfo1.mozilla.com)
[18:39:09] *** ChanServ sets mode: +ao pcwalton pcwalton
[18:39:39] *** Joins: bynaryshef (bynaryshef@moz-B4E38B6F.mem.bellsouth.net)
[18:40:47] *** Joins: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com)
[18:41:39] *** Joins: carter (carter@moz-3589B90B.c.ircrelay.com)
[18:41:42] <sanxiyn> jld: Closed
[18:42:15] *** Joins: indirect (indirect@moz-3589B90B.c.ircrelay.com)
[18:42:22] *** Joins: notmatt (notmatt@CFB1216.DD50E21A.47C41102.IP)
[18:42:24] *** Joins: indutny (indutny@moz-3589B90B.c.ircrelay.com)
[18:43:14] *** Joins: sellout (sellout-@moz-AE26682A.hlrn.qwest.net)
[18:44:09] *** Quits: amro (quassel@D9E34ACF.8AAAF769.FAAB0799.IP) (Client exited)
[18:46:55] *** Joins: bjustin (bjustin@moz-8FC28563.sierrabravo.net)
[18:47:49] *** Joins: w3lcome (Mibbit@moz-E9ABA59E.home.otenet.gr)
[18:48:36] *** Quits: tav (tav@moz-12977B11.range86-150.btcentralplus.com) (Quit: tav)
[18:48:58] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[18:50:04] *** Quits: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com) (Ping timeout)
[18:50:32] *** Quits: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net) (Quit: Sharp)
[18:50:49] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[18:52:52] <mark_edward> if a C library has a static variable that i exports, is there anyway to get at that in Rust?
[18:54:12] *** Quits: gdey (gdey@moz-CD850554.static-ip.telepacific.net) (Quit: Leaving...)
[18:54:15] <pcwalton> someone name a good movie
[18:54:18] <eddyb> option 1: write a C function which returns that variable
[18:54:31] <pcwalton> mark_edward: you can put statics inside extern { â€¦ }
[18:54:46] <eddyb> pcwalton: erm. let me switch mindset from trying to read --emit-llvm -S output
[18:54:54] <pcwalton> too late
[18:55:00] <eddyb> pcwalton: Fast&Furious series
[18:55:07] <pcwalton> not as cool as labyrinth sorry
[18:55:16] <Eridius> mark_edward: static _and_ exported? Pick one or the other
[18:55:21] <eddyb> well, new movie for me too
[18:55:30] <eddyb> Eridius: global exported variable :P
[18:55:43] <Eridius> mark_edward: `extern { pub static Foo: libc::c_uint; }` should work, no?
[18:55:46] *** Quits: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP) (Client exited)
[18:56:01] *** Quits: osa1__ (omer@moz-8FDAB45C.hsd1.il.comcast.net) (Quit: Konversation terminated!)
[18:56:09] <eddyb> pcwalton: '86?
[18:56:18] <mark_edward> thanks guys
[18:56:28] <sanxiyn> pcwalton: Rabbit-proof fence
[18:57:09] <mark_edward> Eridius, it's declared as an `extern const ...`
[18:57:21] <eddyb> reminds of that Don Something movie with the giant rabbit. great mindfuck
[18:57:21] <mark_edward> Eridius, and is in a header file
[18:58:11] <Eridius> mark_edward: rust-curses uses `extern { pub static foo: c_int; }` for variables imported from ncurses and it works
[18:58:14] <Eridius> https://github.com/kballard/rust-curses/blob/master/ncurses.rs#L24
[18:58:29] <mark_edward> Eridius, a thank you for the link to an example!
[18:58:35] <mark_edward> eddyb, Donnie Darko
[19:00:56] <eddyb> mark_edward: thank you
[19:00:57] *** Quits: samx (sami@3EB32A7C.10A53EE3.77834EAA.IP) (Quit: This computer has gone to sleep)
[19:01:04] <eddyb> I now have someone to blame for potential nightmares
[19:02:00] *** Quits: lfox (lfox@moz-89EEE1BF.nyc.res.rr.com) (Quit: ZZZzzzâ€¦)
[19:03:46] *** Quits: beifeng (Mibbit@7989804A.FA7FF645.C7DB8B78.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[19:05:06] *** Quits: heftig (heftig@moz-AA7C3444.dip0.t-ipconnect.de) (Ping timeout)
[19:07:52] *** Joins: mib_mr41hb (Mibbit@F8DB984B.516669EE.10775B1A.IP)
[19:08:11] *** Joins: heftig (heftig@moz-F1093399.dip0.t-ipconnect.de)
[19:08:30] *** Parts: mib_mr41hb (Mibbit@F8DB984B.516669EE.10775B1A.IP) ()
[19:08:46] *** Joins: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP)
[19:08:50] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[19:12:02] *** Quits: ricepuddin (graham@moz-7D68765A.cable.virginm.net) (Ping timeout)
[19:12:29] *** Joins: Ms2ger (Ms2ger@57ACE628.C60A97A6.F9FB0584.IP)
[19:14:34] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[19:15:00] *** Quits: bynaryshef (bynaryshef@moz-B4E38B6F.mem.bellsouth.net) (Quit: Leaving)
[19:16:09] *** Quits: sanxiyn (tinuviel@5572118A.71F82290.4BEB41DB.IP) (Quit: Bye)
[19:16:17] *** Joins: mib_y3hpjw (Mibbit@2AACB6E1.A033706C.284344F5.IP)
[19:18:13] <eddyb> strcat left :(?
[19:20:12] *** Quits: colinsurprenant (colin@F692E1FE.8D7057CF.30F15291.IP) (Quit: colinsurprenant)
[19:20:22] *** Joins: colinsurprenant (colin@F692E1FE.8D7057CF.30F15291.IP)
[19:20:46] *** Quits: mib_y3hpjw (Mibbit@2AACB6E1.A033706C.284344F5.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[19:21:42] *** Joins: lfox (lfox@moz-89EEE1BF.nyc.res.rr.com)
[19:22:02] <boredomist> r? https://github.com/mozilla/rust/pull/10897
[19:22:28] <boredomist> hate to keep spamming the link, but it's such a broad change that i have to rebase basically every time a new commit lands on master
[19:22:57] *** jdm is now known as jdm|away
[19:22:59] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[19:23:08] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Ping timeout)
[19:23:29] <brson> boredomist: has somebody else already r+ed?
[19:23:37] *** Joins: fyolnish (fyolnish@moz-2B4E79B2.uqwimax.jp)
[19:24:03] <Eridius> brson: the new #[pkgid]-based naming is causing serious issues: https://github.com/mozilla/rust/issues/10922
[19:24:09] *** Joins: Sharp (Sharp@1710C26.8381A41.8725677B.IP)
[19:24:10] <boredomist> brson: nope
[19:24:35] <boredomist> a couple of people looked at it, but no one's approved yet
[19:25:08] <brson> boredomist: which file does the check?
[19:25:18] *** Quits: fyolnish (fyolnish@moz-2B4E79B2.uqwimax.jp) (Ping timeout)
[19:25:34] <brson> oh nvm it's in your comment
[19:27:10] *** Quits: brendan (brendaneic@777B9EEC.C030CAFC.1EF54B18.IP) (Quit: brendan)
[19:27:19] <brson> boredomist: thanks! that's a huge patch!
[19:28:24] <boredomist> thanks for approving :)
[19:29:03] <brson> Eridius: i see
[19:29:04] *** Joins: brendan (brendaneic@777B9EEC.C030CAFC.1EF54B18.IP)
[19:30:50] *** Joins: lenstr (lenstr@2AFEF082.9636F313.7A27613B.IP)
[19:32:01] <shmoo2> can I write a multiline macro? I always get    macro expansion ignores bla bla bla    after the first ;
[19:32:23] <sfackler> shmoo2: are you on 0.8?
[19:32:26] <shmoo2> master
[19:32:41] <sfackler> what are you trying to do in the macro?
[19:32:52] <shmoo2> define a temporary variable
[19:32:57] <shmoo2> but it doesn't matter
[19:33:05] <shmoo2> if I put println in the first line it aborts after that
[19:33:20] <sfackler> so you may be able to put the body of the macro in a block
[19:33:25] *** Quits: KindOne (KindOne@moz-FDF55302.dynamic.ip.windstream.net) (Ping timeout)
[19:33:39] <shmoo2> works, thanks
[19:33:43] <sfackler> i.e. macro_rules! foo( () => ({expr_1; expr_2; expr_3}))
[19:34:09] <sfackler> known issue, btw: https://github.com/mozilla/rust/issues/10681
[19:34:11] <shmoo2>  internal compiler error: typeof is reserved but unimplemented This message reflects a bug in the Rust compiler.
[19:34:13] <shmoo2> oho
[19:34:54] <shmoo2> can I get the type of an argument in a macro?
[19:35:50] <sfackler> you can add an extra argument to the macro with the type $t:ty
[19:36:08] <sfackler> I don't think you can extract it from an expression or anything though
[19:36:29] <shmoo2> hm, that's not nice
[19:37:18] *** Quits: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net) (Connection reset by peer)
[19:37:22] *** Quits: nano (nano@moz-ED77243C.superkabel.de) (Connection reset by peer)
[19:37:39] *** Joins: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net)
[19:37:44] *** Joins: KindOne (KindOne@moz-ADEEC3B9.dynamic.ip.windstream.net)
[19:38:43] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[19:38:58] *** Joins: lastdev (lastdev@moz-5A47DD8E.dyn.user.ono.com)
[19:39:03] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[19:39:24] <shmoo2> I'm trying to do this: ret.a.b.set(&*ret as *A)     which doesn't work
[19:39:33] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[19:39:38] <shmoo2> this works:   let tmp = &*ret as *A;         ret.a.b.set(tmp)
[19:39:46] <shmoo2> so i want to put those two lines in a macro
[19:40:26] <bstrie> shmoo2: macros are scary :O
[19:41:05] <shmoo2> it's more scary that the first snippet doesn't work but the second one does
[19:41:14] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[19:41:32] <bstrie> shmoo2: sounds like this bug: https://github.com/mozilla/rust/issues/3511
[19:41:44] <shmoo2> I guess
[19:42:23] <shmoo2> but the output for the first snippet is   "can't borrow twice" or something like that
[19:42:53] <bstrie> oh right
[19:43:04] <shmoo2>         backref_set!(ret.b.a <- ret !! A);            that looks pretty fancy
[19:43:33] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[19:43:39] *** Parts: sindork (sindork@ABFA98AB.DD47BB48.F7A44A1B.IP) (http://quassel-irc.org - Chat comfortably. Anywhere.)
[19:43:41] *** Quits: hoverbear (hoverbear@moz-86FCBF4B.gv.shawcable.net) (Quit: Hibernating, be back soon.)
[19:43:45] <bstrie> macrooos
[19:46:40] <shmoo2> can I have fail! print a backtrace or something?
[19:47:04] <bstrie> shmoo2: I think people usually use gdb for that
[19:47:30] *** Joins: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz)
[19:48:36] *** jorendorff is now known as jorendorff_away
[19:48:40] <sfackler> there used to be a backtrace thing builtin, but IIRC it died when we switched to the new runtime
[19:48:46] <sfackler> it should probably get added back some time
[19:49:23] <lastdev> Hello channel, I'm just starting to learn Rust coming from a C++ background. I was reading the section on 'implementing a linked list' on the tutorial and stumbled upon the quote "If a struct contains four u32 fields, it will be four times as large as a single u32". That makes me wonder, is the compiler free to add padding between struct members for alignment reasons just as in C++? Is there any language support for controlling s
[19:49:23] <lastdev> truct member alignment?
[19:49:30] <sfackler> shmoo2: but for now you can "catch throw" in gdb
[19:49:35] *** Quits: jlong (jlong@moz-6DFDE846.socal.res.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[19:50:31] <doomlord_> rust structs are compatable in layout with C structs, i think
[19:50:49] <doomlord_> which would mean they would do exactly the same padding as a C compiler
[19:51:08] <josh> How come extra::base64 trunk to_base64 requires a config struct but the struct is empty? I used to specify char_set, pad, and line_length, but they are private now
[19:51:10] *** Quits: sellout (sellout-@moz-AE26682A.hlrn.qwest.net) (Quit: Leaving.)
[19:51:21] <sfackler> that's probably an accident
[19:51:21] *** Quits: _Vi (vi@527C345F.497AA854.B16B3BE6.IP) (Ping timeout)
[19:51:29] <shmoo2> how do I call a macro in a module?
[19:51:31] <sfackler> they should be public
[19:51:43] <sfackler> josh: there are some presets defined in extra::base64
[19:51:50] <sfackler> STANDARD, MIME and URL_SAFE iirc
[19:52:07] <bstrie> josh: a while ago we had a lot of public things that should have been private, so we went through and made everything private with the expectation that people would report where we got it wrong :P
[19:52:16] <sfackler> shmoo2: you may have to add the #[macro_escape] attribute for your macros to be visible outside of the module they were defined in
[19:52:52] *** Quits: notmatt (notmatt@CFB1216.DD50E21A.47C41102.IP) (Client exited)
[19:52:53] <josh> sfackler, bstrie: I don't know what you intend here, but I'd suggest looking into this. Do you want me to file a bug?
[19:52:58] <lastdev> doomlord_: I see
[19:53:10] <bstrie> josh: please do, if it seems like a bug in the API
[19:53:11] <shmoo2> error: expected macro name without module separators
[19:53:20] <shmoo2>  backref::set!
[19:53:22] <sfackler> oh, there is no namespacing for macros
[19:53:23] <eddyb> kdiff3 for LLVM time!
[19:53:31] *** Parts: zokier` (zokier@moz-C4357EA7.kapsi.fi) ()
[19:53:55] <eddyb> oh wow it works so good
[19:54:07] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[19:54:19] <eddyb> all the variable numebers that changed don't affect the diff
[19:54:44] <shmoo2>     #[macro_escape]     macro_rules! backref_set(            ....          backref_set!      ...  error: macro undefined: 'backref_set'
[19:54:45] <shmoo2> :(
[19:56:25] <bstrie> shmoo2: I told you, macros are scary!
[19:56:48] <sfackler> shmoo2: iirc you want it like this "mod whatever { #[macro_escape]; macro_rules! foo(...) } ... foo!()"
[19:56:49] *** Quits: Sorella (quildreen@2392D500.600E39D3.1ED99692.IP) (Quit: Ex-Chat)
[19:56:51] <sfackler> note the ;
[19:57:01] <sfackler> or "#[macro_escape] mod whatever {...}" would work
[19:57:21] <shmoo2> yep it works
[19:57:34] <shmoo2> why do I have to "use std; " in modules?
[19:57:54] *** Joins: mib_4z5202 (Mibbit@moz-CBD76C21.bb.online.no)
[19:58:20] <sfackler> if you want to do something like "std::vec::with_capacity" you mean?
[19:58:36] <sfackler> it's a weird inconsistency between relative and absolute namespace lookup iirc
[19:58:47] <sfackler> ::std::vec::with_capacity will work without a use std;
[19:59:09] <shmoo2>  unresolved name     std::ptr::null()
[19:59:20] *** Quits: glennsl (textual@moz-5D7B804F.getinternet.no) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[19:59:50] *** Joins: glennsl (textual@moz-5D7B804F.getinternet.no)
[20:00:01] *** Quits: six600110 (six600110@moz-C663577C.hsd1.il.comcast.net) (Client exited)
[20:01:46] *** Quits: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net) (Client exited)
[20:01:47] <shmoo2>         let b = ~B { a: backref::null() };         let a = ~A { b: b, msg: ~"huhu" };         backref_set!(a.b.a <- a !! A);         a
[20:01:48] <shmoo2> scary
[20:02:07] *** Joins: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net)
[20:02:17] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[20:02:41] *** Joins: g3xzh (g3xzh@moz-A4DE8FAB.red.bezeqint.net)
[20:02:59] *** Quits: Jesse (jruderman@moz-9754CB0.hsd1.ca.comcast.net) (Quit: Jesse)
[20:03:32] <g3xzh> does rust have "pair"
[20:03:36] <g3xzh> ?
[20:03:53] *** Quits: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net) (Ping timeout)
[20:03:55] <g3xzh> nevermind
[20:03:57] <bstrie> g3xzh: not that I know of! what is it?
[20:04:06] *** Joins: skade (skade@moz-3DC698FE.pools.arcor-ip.net)
[20:04:11] <g3xzh> i see there is tuple
[20:04:13] <g3xzh> which is fine
[20:04:13] *** Quits: jvns (bork@87D98E32.4046EB22.428F94DD.IP) (Connection reset by peer)
[20:04:14] *** Joins: jvns (bork@87D98E32.4046EB22.428F94DD.IP)
[20:04:40] *** Joins: rca_ (rcatolino@moz-E0992404.adsl.proxad.net)
[20:05:22] <wycats_> so question
[20:05:31] <wycats_> how are you supposed to build a graph structure in Rust
[20:05:48] <wycats_> if you can't have multiple pointers to a single node?
[20:05:49] *** Joins: pepper_chico (pepper_chi@6D1D0FAA.4F150827.E4090502.IP)
[20:06:00] *** Quits: rca (rcatolino@7F54AB21.28091F66.520D6FA6.IP) (Ping timeout)
[20:06:04] <Sharp> wycats_: Use unsafe or a hash structure.
[20:06:19] <wycats_> how does a hash structure work?
[20:06:25] <wycats_> doesn't seem to work at all
[20:06:30] <wycats_> unless you mean hash -> index
[20:06:42] <Sharp> That is what I mean, sorry if I wasn't clear :)
[20:06:47] <wycats_> and then a separate graph of indeces
[20:06:55] <Sharp> Yep.
[20:07:02] <wycats_> so there is no safe way to build a graph straight-forwardly in Rust?
[20:07:05] <Sharp> Nope.
[20:07:08] *** Joins: jviereck (Adium@moz-2B1FEA28.dip0.t-ipconnect.de)
[20:07:55] <bstrie> wycats_: aren't Rc pointers supposed to be used if you want cyclical references?
[20:07:56] <wycats_> maybe there should be a Graph in the stdlib?
[20:08:21] <Sharp> Oh yeah, you could use GC'd pointers I suppose
[20:08:44] <Sharp> I thought Rc as implemented at present didn't work properly for cyclic references.
[20:08:45] *** Quits: jviereck (Adium@moz-2B1FEA28.dip0.t-ipconnect.de) (Quit: Leaving.)
[20:09:07] <bstrie> well it probably leaks cycles, as RC is wont to do, but it's safe :P
[20:09:14] <wycats_> in general Rc GC leaks cycles
[20:09:27] *** Quits: peterdn (chatzilla@moz-3DA3F15F.as13285.net) (Quit: ChatZilla 0.9.90.1-rdmsoft [XULRunner 22.0/20130619132145])
[20:09:30] <Sharp> Well, if you're using it explicitly for cyclic references, that would seem to defeat the purpose :P
[20:09:35] <Sharp> Unless you just don't care about leaks.
[20:09:40] <bstrie> graphs don't necessarily *have* cycles :)
[20:09:42] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[20:09:52] <bstrie> a tree is a graph!
[20:10:02] <Sharp> Yeah, or just generically a DAG
[20:10:12] <bstrie> yeah, that's what the G in DAG is :P
[20:10:44] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[20:10:46] <wycats_> it kind of seems like you might want a way to pin all of the nodes' lifetimes to some parent object
[20:10:54] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[20:10:54] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Connection reset by peer)
[20:11:04] <strcat> you can use reference counting for cyclic references
[20:11:07] <strcat> just not cyclic ownership
[20:11:09] <wycats_> and only allow pointing to them from objects that share that same lifetime
[20:11:10] <bstrie> Sharp: also I don't think trees are necessarily directed?
[20:11:12] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[20:11:18] <strcat> Rc doesn't support cyclic references
[20:11:19] <Sharp> bstrie: I think they necessarily are.
[20:11:22] <strcat> https://github.com/thestinger/rust-core/blob/master/core/weak.rs
[20:11:25] <strcat> but it doesn't mean you can't
[20:11:28] <Sharp> But maybe that's just my interpretation of trees.
[20:11:57] <bstrie> maybe I need to go look up what it means to be directed
[20:11:59] <strcat> trees can have parent pointers
[20:12:10] <wycats_> am I making sense?
[20:12:16] <Sharp> strcat: Sure, but they're explicitly parent pointers.
[20:12:19] *** Joins: peterdn (chatzilla@moz-3DA3F15F.as13285.net)
[20:12:21] <strcat> wycats_: look at that Strong/Weak type 
[20:12:35] <strcat> parent pointers can be weak references
[20:12:39] <strcat> reference counting supports that
[20:12:43] <strcat> no unsafe code or gc necessary
[20:12:46] <bstrie> strcat: what is Strong/Weak
[20:12:52] <bstrie> you mean like weakptr from c++?
[20:12:56] <strcat> bstrie: look at the link, yes
[20:13:02] <bstrie> ah, a link
[20:13:16] <strcat> need a NonManaged bound to put that in the stdlib
[20:13:24] *** Quits: lenstr (lenstr@2AFEF082.9636F313.7A27613B.IP) (Quit: Leaving...)
[20:13:25] <wycats_> basically having a way to say "I have this object which has some lifetime, and it stores the same pointer in multiple slots that themselves share that lifetime"
[20:13:49] <strcat> wycats_: it's not going to be memory safe
[20:14:10] <strcat> if you let a child have a reference into the parent, and the parent is modified to drop one of the children, that child can now have dangling refs
[20:14:13] <strcat> doesn't work
[20:14:23] <wycats_> strcat: that doesn't seem obvious
[20:14:27] <strcat> you either need unsafe code for raw pointers, or you need Strong/Weak reference counting references
[20:14:32] <strcat> wycats_: it seems obvious to me
[20:14:37] <wycats_> ok
[20:14:42] <strcat> wycats_: if you take an & reference, it needs to freeze it
[20:14:48] <strcat> you can take & refs deeper into an & ref
[20:14:55] *** Quits: brendan (brendaneic@777B9EEC.C030CAFC.1EF54B18.IP) (Quit: brendan)
[20:14:56] *** Quits: eddyb (eddy@moz-68E0B7D0.residential.rdsnet.ro) (Ping timeout)
[20:14:56] *** Joins: jviereck (Adium@moz-2B1FEA28.dip0.t-ipconnect.de)
[20:15:11] <strcat> wycats_: unless you're going to say that after construction, you're unable to modify that node ever again
[20:15:15] <wycats_> strcat: does it also seem obvious to you that you can't have a safe graph conventionally written?
[20:15:33] <strcat> wycats_: convention == association list
[20:15:34] <strcat> imo
[20:15:42] <strcat> as in use a map
[20:15:53] <strcat> wycats_: you can use either Gc<T> or strong/weak reference counted references
[20:15:57] <strcat> wycats_: https://github.com/thestinger/rust-core/blob/master/core/weak.rs
[20:16:06] <strcat> cyclic references are *fine* with reference counting
[20:16:12] <strcat> you just can't have cyclic ownership
[20:16:55] <strcat> as long as the graph has directed, acyclic ownership, you can use refcounting
[20:16:57] <Sharp> It should be noted that I said our implementation didn't support it, not that it wasn't possible :P
[20:17:44] <strcat> if it actually has ownership cycles you need some kind of cycle collection, and gc is the simplest way to do that in safe code
[20:17:45] *** Joins: jlong (jlong@moz-6DFDE846.socal.res.rr.com)
[20:17:48] <strcat> you could use maps and do it yourself
[20:18:09] *** Quits: jviereck (Adium@moz-2B1FEA28.dip0.t-ipconnect.de) (Quit: Leaving.)
[20:19:08] <strcat> weak refs are harder to support for Arc but you still can
[20:19:17] *** Quits: skade (skade@moz-3DC698FE.pools.arcor-ip.net) (Quit: Textual IRC Client: www.textualapp.com)
[20:19:24] *** Joins: jmgrosen (jmgrosen@moz-A3814C08.sd.sd.cox.net)
[20:19:33] <shmoo2> How do you feel about this code to keep the unsafe parts in a single place: https://gist.github.com/anonymous/7917696
[20:20:33] <strcat> shmoo2: unless it's super performance critical and you've identified refcounting as an issue, I would use safe refcounted code
[20:20:52] <strcat> you won't actually be refcounting
[20:20:57] <strcat> the counts will be 1
[20:21:21] <strcat> the weak count will be the # of children, so you'll do a bit there
[20:22:05] *** Quits: Ms2ger (Ms2ger@57ACE628.C60A97A6.F9FB0584.IP) (Ping timeout)
[20:23:53] <wycats_> strcat: are you basically saying that the correct idiomatic way to have an object with multiple pointers to the same place is to use an association list (or just a vector?) and reference by index?
[20:24:13] <strcat> wycats_: no
[20:24:37] <strcat> I am saying that for a graph where nodes have keys, a map is the idiomatic way to represent it most of the time
[20:24:38] <wycats_> ok I am lost
[20:25:06] <strcat> if the graph has directed, acyclic ownership, then reference counting works even if you need cyclical references - that's what weak pointers are for
[20:25:23] <wycats_> btw: I am in a lot of pain so sorry if I sound cranky
[20:25:41] <strcat> if you need ownership cycles, then you need cycle collection, so you're either going to be using a garbage collector or using maps based on node keys and doing cycle collection yourself
[20:26:17] <wycats_> should the stdlib perhaps have DAGs?
[20:26:21] <wycats_> that implement these cases?
[20:26:34] <strcat> it should have a refcounted ptr with weak ptrs
[20:26:43] <strcat> I don't think it needs graph stuff, it's easy enough to use a map when you have node keys
[20:26:58] <wycats_> I've been using vector with integer pointers
[20:27:04] <wycats_> to represent a tree
[20:27:09] <wycats_> not a DA
[20:27:11] <wycats_> DAG
[20:27:14] <wycats_> so simpler case
[20:27:16] <strcat> wycats_: does it have parent pointers?
[20:27:27] <wycats_> strcat: I keep two lists
[20:27:31] <wycats_> two vectors
[20:27:36] <wycats_> one for the nodes
[20:27:39] <strcat> no pointer parents -> unique pointers work fine, has parent pointers -> Strong/Weak references work fine
[20:27:40] <wycats_> and one for the parents
[20:27:52] <strcat> wycats_: https://github.com/thestinger/rust-core/blob/master/core/weak.rs just look at this, it probably does exactly what you want
[20:27:53] *** Quits: moostik (Icedove@moz-6D4FE356.w86-212.abo.wanadoo.fr) (Quit: moostik)
[20:28:07] <strcat> wycats_: the parents are placed inside Strong<T> (like Rc<T>), the children have Weak<T> refs to the parents
[20:28:27] <wycats_> [<node 1>, <node 2>, <node 3>] and [None, 0, 0] represents the tree <node 1> with children 2 and 3
[20:28:27] <strcat> when the child wants to do something with the parent, it upgrades the Weak<T> to a Strong<T> as long as necessary (but it doesn't store it)
[20:28:31] * strcat shrugs
[20:28:45] <strcat> no one seems to care what I say today ;p
[20:28:50] <wycats_> strcat: 
[20:28:52] <shmoo2> strcat: The question is: Why would I use Strong/Weak which seem much more complicated to use if I can just use the simple code I posted above. Is my code unsafe?
[20:29:12] <bstrie> strcat: you need cuter names for your pointer types in rust-core. might I suggest Iced<T> and Sweet<T>?
[20:29:18] <wycats_> I stepped through my second floor ceiling two days ago and am currently in a hospital room on a lot of pain medication
[20:29:19] *** Joins: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com)
[20:29:25] <wycats_> sorry if it seems like 
[20:29:31] <wycats_> I'm ignoring you
[20:29:39] <strcat> shmoo2: if you're not following the borrowck rules, then chances are it's not externally safe if you didn't think hard about it
[20:29:50] <strcat> shmoo2: if you can mutate a node you can have an &mut ptr to, it's not safe
[20:29:59] <strcat> well
[20:30:13] <strcat> shmoo2: if you can obtain an & ptr to a node, and mutate that node, it's not safe
[20:30:50] <shmoo2> arg
[20:30:52] <bstrie> wycats_: in some ways I'm sad that you're using rust in production, now I feel slightly less good when contemplating backwards-incompatible changes :)
[20:30:57] <shmoo2> just put it in stdlib already
[20:31:03] <strcat> shmoo2: it can't be
[20:31:08] <strcat> no NonManaged bound
[20:31:16] *** Quits: rossm (rossm@moz-EE3BB1DC.br.br.cox.net) (Quit: )
[20:31:20] <wycats_> bstrie: what kind of changes :)
[20:31:20] <strcat> unless the stdlib decides to drop stupid gc support ;p
[20:31:36] <bstrie> so do we have NoFreeze, NonSend, and NonManaged now? maybe we just need a ! operator on trait bounds
[20:31:45] <wycats_> bstrie: I am ok with backwards incompatible changes with an ok upgrade path that make Rust better
[20:31:53] <strcat> bstrie: NonManaged would be a kind like Send/Freeze
[20:32:08] <wycats_> making Rust better should be your highest priority right now
[20:32:33] <achin> when has that not been a priority? :)
[20:32:39] <strcat> bstrie: we don't have NoFreeze/NonSend types atm and they wouldn't be kinds if we did
[20:32:44] *** Joins: moostik (Icedove@moz-6D4FE356.w86-212.abo.wanadoo.fr)
[20:32:52] <bstrie> strcat: what does NonManaged imply that Send doesn't?
[20:33:10] <strcat> bstrie: NonManaged means no gc'ed pointers
[20:33:19] <bstrie> to my mind you're either managed or you're unique, and unique things should be sendable
[20:33:27] <strcat> if you put a Send bound on it... you can't put Rc or Strong/Weak in it
[20:33:27] <bstrie> doesn't Send imply the same thing
[20:33:37] <strcat> bstrie: it means no gc but it prevents plenty of other stuff too
[20:33:45] <strcat> which defeats the whole purpose of Strong/Weak
[20:34:06] <strcat> rust-core doesn't have gc
[20:34:11] <strcat> it still has non-Send things
[20:34:19] <strcat> anything that's mutable + refcounted without a lock
[20:34:26] <strcat> or anything that's refcounted without atomic counting
[20:34:52] <strcat> lots of libs have stuff bound to a thread too
[20:35:17] <strcat> Send doesn't mean 'no gc', it means 'no non-send things, including gc'
[20:36:53] *** Joins: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net)
[20:37:10] *** Quits: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net) (Client exited)
[20:37:12] *** Joins: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net)
[20:37:56] *** Quits: glennsl (textual@moz-5D7B804F.getinternet.no) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[20:38:33] *** Joins: hacker_sam (Mibbit@moz-5218E46E.public.wayport.net)
[20:38:37] *** Quits: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net) (Client exited)
[20:38:48] *** Joins: yegor (primate@moz-4F3BA196.red-dhcp.yndx.net)
[20:39:03] *** Quits: hacker_sam (Mibbit@moz-5218E46E.public.wayport.net) (Quit: http://www.mibbit.com ajax IRC Client)
[20:39:07] *** Joins: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net)
[20:39:17] *** Joins: brendan (brendaneic@777B9EEC.C030CAFC.1EF54B18.IP)
[20:39:23] *** Quits: lastdev (lastdev@moz-5A47DD8E.dyn.user.ono.com) (Quit: )
[20:39:24] <Blei> hmm, has anyone else noticed that the output filenames of libraries and binaries have changed? they used to be computed from the #[link(name=..)] attribute
[20:39:25] *** Quits: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net) (Client exited)
[20:39:46] <Blei> is this a bug or have i missed something?
[20:39:52] *** Joins: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net)
[20:40:03] *** Quits: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net) (Client exited)
[20:40:03] *** Joins: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net)
[20:40:36] <achin> i think there were some commits in the past 1 or 2 days that changes this
[20:40:57] *** Joins: _Vi (vi@527C345F.497AA854.B16B3BE6.IP)
[20:41:03] *** Joins: hacker_sam (hacker_sam@moz-5218E46E.public.wayport.net)
[20:41:29] *** Joins: rossm (rossm@moz-EE3BB1DC.br.br.cox.net)
[20:41:43] <Blei> ah, found it
[20:41:46] <pcwalton> nmatsakis: r? https://github.com/mozilla/rust/pull/10924
[20:41:47] <Blei> achin: thanks!
[20:42:02] *** Joins: glennsl (textual@moz-5D7B804F.getinternet.no)
[20:42:39] <g3xzh> how do i loop over a vector of tuples?
[20:42:54] *** Quits: sprang (sprang@moz-824FD61F.hsd1.ca.comcast.net) (Quit: sprang)
[20:43:25] <strcat> g3xzh: via an iterator, like other vectors
[20:43:26] *** Joins: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP)
[20:43:29] <Blei> rusti: for &(a, b) in [(1, 2), (3, 4)].iter() { println!("{}, {}", a, b);}
[20:43:31] -rusti- pastebinned 11 lines of output: http://sprunge.us/DVXj
[20:43:31] *** Joins: pheleas_frog (Mibbit@15E64609.6A8A1F30.A34EC3BB.IP)
[20:43:35] *** Parts: pheleas_frog (Mibbit@15E64609.6A8A1F30.A34EC3BB.IP) ()
[20:43:43] <Blei> bah
[20:43:54] <g3xzh> problem...
[20:44:04] <strcat> rusti: let xs = [(1, 2), (2, 3)]; for &(a, b) in xs.iter() { println!("{}, {}", a, b) }
[20:44:05] <Blei> rusti: let a = [(1, 2), (3, 4)]; for &(a, b) in a.iter() { println!("{}, {}", a, b);}
[20:44:05] -rusti- 1, 2
[20:44:05] -rusti- 2, 3
[20:44:05] -rusti- ()
[20:44:06] -rusti- 1, 2
[20:44:06] -rusti- 3, 4
[20:44:07] -rusti- ()
[20:44:09] <Blei> XD
[20:44:34] <strcat> rusti: let xs = [(1, 2), (2, 3)]; for t in xs.iter() { println!("{:?}, {}", t) }
[20:44:35] -rusti- <anon>:9:65: 9:75 error: invalid reference to argument `1` (there are 1 arguments)
[20:44:35] -rusti- <anon>:9         let xs = [(1, 2), (2, 3)]; for t in xs.iter() { println!("{:?}, {}", t) }
[20:44:35] -rusti-                                                                           ^~~~~~~~~~
[20:44:35] -rusti- error: aborting due to previous error
[20:44:36] -rusti- application terminated with error code 101
[20:44:38] <g3xzh> what if you did ~[(1,2), (3,4)]?
[20:44:39] <strcat> rusti: let xs = [(1, 2), (2, 3)]; for t in xs.iter() { println!("{:?}", t) }
[20:44:40] -rusti- &(1, 2)
[20:44:40] -rusti- &(2, 3)
[20:44:41] -rusti- ()
[20:44:41] <g3xzh> hoo
[20:44:52] *** Quits: jmgrosen (jmgrosen@moz-A3814C08.sd.sd.cox.net) (Quit: jmgrosen)
[20:44:57] <g3xzh> thanks
[20:45:02] <strcat> g3xzh: still the same as other vectors, beyond having the ability to move out of it via an iterator too
[20:45:12] <strcat> iter is implemented on &[T]
[20:45:18] <strcat> any vector can coerce to &[T]
[20:45:28] <g3xzh> alright, 10x strcat and Blei.
[20:45:43] *** Joins: Blub\1 (wry@620605B3.71150E1A.237AE2BA.IP)
[20:46:00] *** Quits: pepper_chico (pepper_chi@6D1D0FAA.4F150827.E4090502.IP) (Quit: Ex-Chat)
[20:46:01] *** Quits: Blub\0 (wry@620605B3.71150E1A.237AE2BA.IP) (Ping timeout)
[20:49:00] <yegor> Hi
[20:49:10] *** Quits: nsf (nsf@moz-EEF3238A.convex.ru) (Quit: WeeChat 0.4.2)
[20:49:10] <yegor> Please looke at the https://gist.github.com/yegor-alexeyev/7918149
[20:49:11] *** Joins: jmgrosen (jmgrosen@moz-A3814C08.sd.sd.cox.net)
[20:49:27] <bstrie> haha, I didn't know that `and` and `or` were valid boolean operators in C++
[20:49:30] *** jorendorff_away is now known as jorendorff
[20:49:37] <yegor> It's about lifetimes, I can't understand what's going on here
[20:49:46] <strcat> bstrie: all of the operators have text versions
[20:50:23] <mib_4z5202> how do I refer to int max_value?
[20:50:31] <bstrie> strcat: sounds like cobol heaven... `int foo equals 2 plus 2 semicolon`
[20:50:42] <erickt> lkuper: I'm really enjoyed your ricon west LVars talk. Is that something we could implement in rust? For everyone else who wants to see it: http://www.youtube.com/watch?v=8dFO5Ir0xqY
[20:51:05] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[20:51:14] <bstrie> rusti: !0i
[20:51:15] -rusti- -1
[20:51:34] *** Quits: moostik (Icedove@moz-6D4FE356.w86-212.abo.wanadoo.fr) (Ping timeout)
[20:52:05] <lkuper> erickt: thanks!  yes, in principle you could do it in Rust
[20:52:22] <lkuper> erickt: there's kind of a question here of what it means to implement LVars, though
[20:52:32] <strcat> bstrie: http://en.cppreference.com/w/cpp/language/operator_alternative ah not *all*
[20:52:41] <lkuper> erickt: if you just mean monotonically growing data structures with threshold reads, then sure
[20:52:57] <o11c> bstrie: the onle ones I use are 'and', 'or', and 'not' ... and that mostly because I have to keep switching to python
[20:52:58] <bstrie> lkuper: you need to change your last name to "vars" so that your username can be "lvars"
[20:52:58] <lkuper> if you mean a scheduler that knows how to take advantage of the fact that you have LVars, then that's another thing
[20:53:02] *** Joins: SiegeLordEx (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[20:53:20] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[20:53:32] *** Quits: brendan (brendaneic@777B9EEC.C030CAFC.1EF54B18.IP) (Quit: brendan)
[20:53:36] <lkuper> but I guess you could do that in Rust too
[20:53:48] *** Quits: SiegeLordEx (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[20:54:03] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: Leaving)
[20:54:08] <lkuper> I've just never tried to do anything like that in Rust.  it'd have a lot of unsafe code
[20:54:12] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[20:54:40] *** Joins: brendan (brendaneic@777B9EEC.C030CAFC.1EF54B18.IP)
[20:54:49] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[20:54:54] <erickt> lkuper: I don't quite grok them yet, but they seem like they could fit in nicely within the spectrum of unique pointers on one side and task specific RC pointers on the other
[20:55:44] <lkuper> erickt: have to run right now, but maybe we can talk about it later!
[20:55:53] <erickt> perhaps they could be the foundation of some concurrent data structures
[20:55:58] <erickt> lkuper: sure! later
[20:56:05] <Blei> yegor: the A value you are constructing on line 21 has a borrowed pointer to the stack allocated B in line 20, but when the function returns, that b is not around any longer, so the created A contains a dangling pointer
[20:56:05] <strcat> we have Arc/MutexArc
[20:56:23] <Blei> and rust disallows that
[20:56:33] <strcat> concurrent data structures need to be built on Arc just to allow sharing them
[20:56:52] <strcat> and then they can do their own locking, or atomics
[20:57:30] <shmoo2> Blei: "Lifetime of A depends on a lifetime of B, so this code should not compile. But it does. "
[20:57:53] <Blei> oh, sorry
[20:58:00] <Blei> i completely misread tha
[20:58:02] <Blei> t
[20:58:04] *** Joins: jviereck (Adium@moz-2B1FEA28.dip0.t-ipconnect.de)
[20:58:12] <Blei> and, it doesn't compile here
[20:58:39] *** Quits: kmapped2 (kmapped2@A35331CF.60E9685E.20F09BA6.IP) (Quit: leaving)
[20:59:39] <erickt> strcat: yeah, I was trying to figure out where the line would be between an Arc and an LVar. If I understood lkuper's presentation, I think MVars are equivalent to Arcs, where there isn't deterministic order between multiple threads writing to the data structure at the same time
[20:59:41] <Blei> and now i've seen the second file, which does compile, so, i have nothing to say in effect
[20:59:50] <Blei> yegor: please file a bug :)
[21:00:01] *** Quits: jviereck (Adium@moz-2B1FEA28.dip0.t-ipconnect.de) (Quit: Leaving.)
[21:00:14] <strcat> erickt: arcs aren't mutable
[21:00:16] *** Quits: jmgrosen (jmgrosen@moz-A3814C08.sd.sd.cox.net) (Quit: jmgrosen)
[21:00:46] <erickt> strcat: oh, right
[21:00:49] <strcat> MutexArc uses a mutex, so if there's contention it's queued 
[21:01:10] *** Quits: pcwalton (pcwalton@moz-DFAA4E15.p2p.sfo1.mozilla.com) (Quit: pcwalton)
[21:02:16] <strcat> with only 4, 8, 16 cores - there can't be very much contention on a properly used mutex where you only do a few dozen cycles of stuff inside
[21:02:25] *** Joins: pcwalton (pcwalton@moz-C07D5168.p2p.sfo1.mozilla.com)
[21:02:25] *** ChanServ sets mode: +ao pcwalton pcwalton
[21:02:30] <strcat> there will probably just be a bit of spinning
[21:03:51] <strcat> if you have *many* cores, then that's where lock-free stuff starts to get better (but intel has lock elision and hardware transactional memory in haswell, so lock-free data structures might never actually be that useful on consumer hardware ;p)
[21:04:46] *** jdm|away is now known as jdm
[21:04:54] <jensnockert> Is there any smarter way to have different versions of something for 64 vs. 32 bit than cfg(target_arch = "x86_64") / not(cfg(target_arch = "x86_64")) ?
[21:05:00] <jensnockert> Is there a 64-bit attribute?
[21:05:17] <jensnockert> Doh, target_word_size
[21:05:21] <jensnockert> Never mind me.
[21:08:04] *** Quits: pcwalton (pcwalton@moz-C07D5168.p2p.sfo1.mozilla.com) (Ping timeout)
[21:08:44] <erickt> strcat: I *think* lvars are at a higher level than mutexes. They're more about being able to provide provably deterministic parallel writes to a data structure
[21:09:08] *** Joins: pcwalton (pcwalton@moz-DFAA4E15.p2p.sfo1.mozilla.com)
[21:09:08] *** ChanServ sets mode: +ao pcwalton pcwalton
[21:09:37] <erickt> strcat: don't ask me to explain why that property is handy though. I'm not quite sure what the difference would be between a deterministic parallel set and a concurrent set :)
[21:09:38] *** Joins: hoverbear (hoverbear@moz-4B831497.wireless.uvic.ca)
[21:09:58] *** Quits: hoverbear (hoverbear@moz-4B831497.wireless.uvic.ca) (Quit: Hibernating, be back soon.)
[21:10:19] <strcat> erickt: a mutex around a data structure gives you mutual exclusion
[21:10:24] <strcat> so without lock elision, it serializes
[21:10:33] <strcat> with lock elision (glibc + haswell), it's not serialized
[21:10:55] <strcat> intel essentially has (really limited) parallel speculative execution now
[21:11:03] <apoelstra> how can i link in C .o files now that link_args is deprecated?
[21:11:09] <erickt> strcat: thats pretty neat
[21:11:26] <Blei> apoelstra: #[link(name="foo")]; == #[link_args="-lfoo"];
[21:11:29] <strcat> if it ends up having a conflict (using caches coherency to determine them) it can back it out
[21:11:36] <strcat> so that's how their hardware transaction memory works too
[21:11:49] <apoelstra> Blei: understood, what is equivalent to #[link_args="foo.o"] ?
[21:12:03] *** Joins: GameGamer43 (sid5533@moz-E77DEB21.irccloud.com)
[21:12:07] <Blei> ah, i see. i don't think that exists :/
[21:12:27] <SiegeLord> Could always plop that .o into a static library
[21:12:40] <Blei> sorry, my brain is apparently not fully working tonight, i answer all the questions that are not actually posed
[21:12:57] <apoelstra> i'll try adding a --link-args to the Makefile
[21:13:07] <apoelstra> i'd rather the .o be referenced in the makefile anyway
[21:14:03] *** Joins: hoverbear (hoverbear@moz-4B831497.wireless.uvic.ca)
[21:14:58] <bstrie> Note that trigraphs (but not digraphs) are parsed before comments and string literals are recognized, so a comment such as // Will the next line be executed?????/ will effectively comment out the following line, and the string literal such as "What's going on??!" is parsed as "What's going on|".
[21:15:03] <bstrie> ^horrifying
[21:15:33] *** Joins: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net)
[21:15:54] *** Joins: jmgrosen (jmgrosen@moz-A3814C08.sd.sd.cox.net)
[21:16:05] *** Joins: eddyb (eddy@moz-68E0B7D0.residential.rdsnet.ro)
[21:16:59] <eddyb> I've had an awesome idea for a tool, I just remembered it, and I woke my laptop from sleep so I can make sure I never forget it again
[21:17:02] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[21:17:06] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[21:17:06] *** ChanServ sets mode: +ao brson brson
[21:17:10] <bstrie> I just realized, if we switched from `&&` to `and`, we wouldn't need that really dumb special case around `& &foo` anymore
[21:17:24] <eddyb> eeeh
[21:17:45] *** Quits: canhtak (canhtak@moz-1D882009.wl.t.ulaval.ca) (Quit: canhtak)
[21:17:47] <eddyb> so, track all allocations done by the program
[21:17:50] <bstrie> eddyb: C++ has `and`, so this change is perfectly natural to our target audience :P
[21:18:00] <jensnockert> Hmâ€¦ I can autogenerate bindings for all OpenCL structs \o/
[21:18:03] <jensnockert> Worst code ever!
[21:18:09] <eddyb> and every single load/store from/to memory
[21:18:16] *** Quits: jmgrosen (jmgrosen@moz-A3814C08.sd.sd.cox.net) (Quit: jmgrosen)
[21:18:25] <bstrie> eddyb: are you just describing valgrind
[21:18:29] <eddyb> if memory is written to, but never read again, you consider that a leak
[21:18:37] <eddyb> bstrie: I just wasn't sure if it was doing exactly that
[21:18:39] <eddyb> >_>
[21:18:51] <bstrie> well I've never used valgrind so I'm not sure either :P
[21:18:53] <eddyb> bstrie: if it is, I should start using it for more than callgrind
[21:19:22] <eddyb> strcat: you know, though, right? :D
[21:19:34] <strcat> eddyb: valgrind's leak checking only tracks stuff malloc/free
[21:19:49] <strcat> and the uninitialized memory checking, etc. doesn't check the stack
[21:19:50] <strcat> only the heap
[21:19:56] <eddyb> strcat: knew it!
[21:20:11] *** Quits: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP) (Quit: buildmaster reconfigured: bot disconnecting)
[21:20:11] *** Joins: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP)
[21:20:15] <bstrie> so what you're saying is that eddyb's idea would be even slower than valgrind :P
[21:20:15] <eddyb> so... should I start writing a new valgrind tool?
[21:20:18] <strcat> eddyb: you could set up valgrind to track other alloc functions
[21:20:21] <strcat> don't need another tool
[21:20:35] <Luqman> jensnockert: does rust-opencl not cover what you need to do?
[21:20:39] <eddyb> strcat: well, do you mean it doesn't track what I said (bytes written but never read again)?
[21:20:54] <eddyb> or just that it doesn't track all allocated RAM
[21:20:59] <strcat> eddyb: that's not how it does leak detection
[21:21:04] <jensnockert> Luqman: I'm just running it on OpenCL because it happened to be around, and not have any ObjC in it to confuse my bindings generator.
[21:21:11] <strcat> it doesn't magically figure out where you are allocating and where you aren't
[21:21:17] <strcat> you tell it about allocators
[21:21:42] <jensnockert> Luqman: It should in theory be able to generate bindings for OS X frameworks in general when done.
[21:22:04] <Luqman> jensnockert: is this bindgen++ ?
[21:22:07] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.2)
[21:22:12] *** Joins: moostik (Icedove@5A22E6A1.10715965.BCDF592F.IP)
[21:22:14] <jensnockert> Luqman: No, uses BridgeSupport.
[21:22:16] <eddyb> strcat: I know about never-freed-pointers (or those that you just throw away). I'm asking is there is a tool which does the slow-and-painful thing I mentioned
[21:22:25] <bstrie> jensnockert: wait, you're using something other than bindgen?
[21:22:30] <jensnockert> Yes!
[21:22:32] <jensnockert> ObjC!
[21:22:40] <jensnockert> Or does bindgen support ObjC?
[21:22:46] <jensnockert> In that case, I am fails.
[21:22:48] <bstrie> you're using objective C to generate rust bindings to openCL??
[21:23:13] <jensnockert> I'm using a ruby program to generate bindings for random OS X frameworks for Rust.
[21:23:18] *** Quits: AbigailBuccaneer (jetbeard@moz-401B3EBC.cable.virginm.net) (Ping timeout)
[21:23:34] <jensnockert> Except it is buggy as hell, and I haven't tried to actually compile any of the bindings produced.
[21:23:42] <jensnockert> And wellâ€¦ ObjC is totally not implemented yet.
[21:23:48] <eddyb> oh ffs, strcat left
[21:23:52] <shmoo2> strftime function in rust?
[21:24:15] <sfackler> shmoo2: extra::time
[21:24:49] <shmoo2> thanks
[21:25:01] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[21:25:12] <shmoo2> maybe it should be possible to search extra and std at once
[21:25:17] *** Joins: zmthy (zmthy@moz-C2881CC3.ecs.vuw.ac.nz)
[21:25:54] *** Quits: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz) (Ping timeout)
[21:26:10] <sfackler> it'd be nice
[21:26:12] <eddyb> bstrie: what I mentioned should be useful to find algorithmic issues (compared to logic/memory management issued found by traditional leak detection)
[21:26:31] <eddyb> because you can't always tell what's going on by looking at the code
[21:26:53] <bstrie> eddyb: well in rust we already warn when you declare a local variable as mutable and then never mutate it... and we also warn when you declare a variable and never use it
[21:26:58] <FreeFull> "Seems you are trying to sort using bubblesort. Would you like to use quicksort instead?"
[21:26:58] <eddyb> and well placed checks could remove the need to do work that's not used later
[21:27:02] <bstrie> eddyb: so what would your tool do beyond that?
[21:27:08] <SiegeLord> Hah... upgraded my CPU and rust build time went down from 42m to 29m
[21:27:20] <eddyb> bstrie: track low level instructions, like valgrind does
[21:27:43] <eddyb> bstrie: so, uhm, you allocate a big vector, fill it with values, and then you use 3 bytes from it
[21:28:00] <eddyb> that is wasted RAM and CPU right there
[21:28:25] *** Joins: IRCMonkey9391 (sellout-@moz-9C064DFC.hsd1.co.comcast.net)
[21:28:33] <bstrie> eddyb: does llvm already optimize out the store if it's possible to determine that most of the data is neve read?
[21:29:00] <sfackler> I think yes, pcwalton was playing around with that for a Cell usable by POD types
[21:29:03] *** IRCMonkey9391 is now known as sellout
[21:29:11] <pcwalton> working on it atm.
[21:29:17] <bstrie> SiegeLord: that's still a long time :P
[21:29:24] <bstrie> SiegeLord: upgraded your CPU to what?
[21:29:38] <SiegeLord> AMD FX 3850
[21:29:45] <eddyb> bstrie: that's not the case here, we're talking vector indexing and other crazy things that are not immediately optimizable by design
[21:29:57] <eddyb> pcwalton: did you see my perf-related comments in #servo?
[21:30:19] <pcwalton> eddyb: about colorspace conv?
[21:30:20] <pcwalton> yeah
[21:30:23] <SiegeLord> Maybe when the magical parallel llvm comes it'll really go down :P
[21:30:33] <pcwalton> i didn't even know that we had that mut_chunks method.
[21:30:41] <bstrie> pcwalton: how much fur remains on this `box` yak
[21:30:44] *** Quits: Sharp (Sharp@1710C26.8381A41.8725677B.IP) (Quit: Sharp)
[21:30:55] <bstrie> like, is old Cell gone?
[21:31:01] <pcwalton> old cell is gone
[21:31:01] <eddyb> pcwalton: remember that [] is bad, mkay :P?
[21:31:03] <pcwalton> working on new one.
[21:31:04] <bstrie> huzzah!
[21:31:05] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[21:31:09] <pcwalton> yes, I know.
[21:31:25] <eddyb> random comment: RefCell uses uint for one bit. meh
[21:31:39] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[21:31:54] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[21:32:10] <eddyb> I'd use an enum that could possible take the place of one unused bit, in the future
[21:32:37] <o11c> reusing bits like that is not as easy as you might think
[21:32:42] <eddyb> it's still 8 times smaller than a bloody *uint*
[21:33:09] <o11c> I tried to do it when I implemented a variant in C++, and it turns out the *only* case that you can reuse anything
[21:33:20] <sfackler> eddyb: it initially used an enum, but the enum was 16 bytes vs 8
[21:33:21] <o11c> is union { int i; short s[3]; };
[21:33:54] <sfackler> enum BorrowState { Unborrowed, MutablyBorrowed, ImmutablyBorrowed(uint) }
[21:34:00] <eddyb> o11c: padding reuse is easier than bit reuse, and rustc should totally doable
[21:34:12] *** Quits: Blei (philipp@moz-B2F9E4BD.cust.bluewin.ch) (Quit: WeeChat 0.4.2)
[21:34:14] *** Joins: Sharp (Sharp@1710C26.8381A41.8725677B.IP)
[21:34:21] <eddyb> sfackler: oh, I didn't realize it needed that extra value
[21:34:25] <eddyb> /facepalm
[21:34:26] <sfackler> there's really no way that rustc can shrink that from 16 bytes unless you add #[packed]
[21:34:40] <sfackler> yeah, you need to track the number of immutable borrows
[21:34:52] <eddyb> sfackler: I thought I read the code right, turns out I didn't >_>
[21:35:05] <eddyb> it's fine, then
[21:35:21] <o11c> particularly, you *cannot* reuse: union { int i; struct { int i; short s; } s; }
[21:35:43] <eddyb> o11c: sure
[21:35:52] <eddyb> anyways, I should be sleeping, good night
[21:36:20] <o11c> because sizeof(s) == 8, even though some of it is padding - you don't always know that it's a member of the union
[21:36:48] *** Quits: hoverbear (hoverbear@moz-4B831497.wireless.uvic.ca) (Quit: Hibernating, be back soon.)
[21:36:58] <heftig> eddyb: hm? it uses a unit for one bit?
[21:37:00] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Input/output error)
[21:37:12] <heftig> er, uint
[21:37:48] <eddyb> if anyone can implement valgrind --tool=track-written-but-never-read-bytes-i.e.-information-entropy-something-something until tomorrow, I'd be happy
[21:38:04] <eddyb> heftig: nevermind me, see sfackler's explanation
[21:38:35] *** Quits: zmthy (zmthy@moz-C2881CC3.ecs.vuw.ac.nz) (Quit: leaving)
[21:38:42] <eddyb> o11c: there's a lot of wasted space in syntax/rustc where the contents of an enums are always padded with the worst possible padding
[21:39:23] *** Joins: AbigailBuccaneer (jetbeard@moz-401B3EBC.cable.virginm.net)
[21:39:34] <eddyb> so enum {A(u32), B(u16, u32)} is 12 bytes instead of 8
[21:39:37] *** Joins: jmgrosen (jmgrosen@moz-A3814C08.sd.sd.cox.net)
[21:39:39] *** Joins: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz)
[21:39:55] <eddyb> it should compute the ammount of padding per variant, everything else is taken care by pattern matching
[21:40:09] <eddyb> on that note, night
[21:40:32] <o11c> eddyb: that's the exact case that does NOT work, and cannot ever
[21:40:37] *** Quits: jackneill (jackneill@moz-91DAEB3F.pool.digikabel.hu) (Ping timeout)
[21:40:53] <o11c> unless you are willing to give up alignment of B
[21:41:24] *** Joins: vodik (simon@moz-FD4ADBC6.cable.teksavvy.com)
[21:41:54] *** Quits: eddyb (eddy@moz-68E0B7D0.residential.rdsnet.ro) (Ping timeout)
[21:42:00] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[21:42:23] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[21:42:24] *** Joins: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com)
[21:43:17] *** Quits: dbaupp (Thunderbir@moz-EB2EFE6F.lns20.syd6.internode.on.net) (Ping timeout)
[21:43:45] *** Quits: dew1 (Instantbir@moz-E4452B8F.static.stls.mo.charter.com) (Ping timeout)
[21:46:12] *** Quits: jmgrosen (jmgrosen@moz-A3814C08.sd.sd.cox.net) (Quit: jmgrosen)
[21:46:16] *** Quits: spider-mario (spidermari@moz-2F72F6FF.dsl.quantic-telecom.net) (Input/output error)
[21:51:01] *** Joins: zmthy (zmthy@moz-C2881CC3.ecs.vuw.ac.nz)
[21:52:02] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[21:53:21] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[21:55:36] *** Quits: brendan (brendaneic@777B9EEC.C030CAFC.1EF54B18.IP) (Quit: brendan)
[21:56:53] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[21:57:17] *** Joins: canhtak (canhtak@moz-1D882009.wl.t.ulaval.ca)
[21:58:40] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[21:58:40] *** ChanServ sets mode: +ao brson brson
[21:58:42] *** Quits: jlong (jlong@moz-6DFDE846.socal.res.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[22:00:10] *** Joins: brendan (brendaneic@777B9EEC.C030CAFC.1EF54B18.IP)
[22:00:46] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[22:01:04] *** Joins: andreypopp (andreypopp@moz-7261DC60.net)
[22:01:51] <andreypopp> Hi, I'm trying to link C program with a rust lib and gets Undefined symbols for architecture x86_64: "___morestack", referenced from
[22:02:02] <andreypopp> rust 0.8
[22:02:16] <andreypopp> I guess I also should link against rust runtime somehow?
[22:02:41] <bstrie> andreypopp: I recommend you use master rather than 0.8
[22:03:00] <bstrie> literally nobody remembers how we used to do things that long ago :P
[22:03:06] <andreypopp> bstrie: :-)
[22:03:10] <andreypopp> bstrie: ok, thanks
[22:03:32] <Diamond> too bad llvm doesn't have 'instructions' for saving register states.
[22:03:46] <andreypopp> just checking out rust and wanted to try to write CPython extensions in Rust
[22:03:52] *** Joins: nkoep (nik@moz-31E42C4C.pool.mediaways.net)
[22:04:10] <bstrie> andreypopp: that sounds really interesting
[22:04:14] <bstrie> andreypopp: good luck :)
[22:04:22] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[22:05:14] *** Quits: sw17ch (sw17ch@moz-62998E95.hfc.comcastbusiness.net) (Quit: sw17ch)
[22:05:22] *** Quits: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[22:05:26] <Scriptor> hmm
[22:05:41] <Scriptor> I wonder if writing PHP extensions in Rust would be doable
[22:05:55] <ezyang> Scriptor: Yes, PHP is just a bolus of C 
[22:06:02] <Scriptor> heh
[22:06:10] <ezyang> It might even be pleasant. 
[22:06:42] *** Quits: paulproteus (quassel@199.199.210.158) (Ping timeout)
[22:06:56] <Scriptor> how would it work, would you need some sort of C adapter function that's called by PHP?
[22:06:59] *** Quits: xitology (xi@85437D54.5AFA3E4.CEDFC552.IP) (Ping timeout)
[22:07:36] *** Joins: paulproteus (quassel@458FE134.3EC36C88.CBDCF1DC.IP)
[22:07:48] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[22:07:58] <ezyang> Yes. 
[22:08:13] <ezyang> Hmm, the hardest part would probably be calling into Rust from PHP 
[22:08:49] <Scriptor> right, but I figure that's what the adapter would do
[22:09:07] <Scriptor> some sort of thin C wrapper that calls the actual rust code
[22:09:09] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[22:09:11] *** Joins: jlong (jlong@moz-6DFDE846.socal.res.rr.com)
[22:09:16] <strcat> you can expose C ABI functions from rust
[22:09:16] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Connection reset by peer)
[22:09:22] <strcat> I don't see why you'd need any C
[22:09:24] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[22:09:36] <sfackler> pub extern "C" fn my_thing(..) -> .. {}
[22:09:39] <Scriptor> ah, cool
[22:09:39] <ezyang> PHP has some macros for registering functions with the Zend runtime 
[22:09:42] *** Joins: dherman (dherman@moz-DFAA4E15.p2p.sfo1.mozilla.com)
[22:09:42] *** ChanServ sets mode: +ao dherman dherman
[22:09:48] <ezyang> so you'll still need some glue in C-land 
[22:10:16] <strcat> ezyang: anything in headers is currently duplicated in rust, that's just how bindings are done for now
[22:10:30] <strcat> duplicating macros isn't much different than the same for a bunch of types
[22:11:05] <strcat> you can't write rust that's portable across architectures/platforms or ABI-altering configurations of a library without hardcoding each one for now
[22:11:05] <aatch> But... writing PHP extensions is a massive pain...
[22:11:25] <aatch> (at least for Zend PHP)
[22:11:43] *** Joins: Jesin (Jesin@moz-C1EBF9B4.dept.lehigh.edu)
[22:12:01] *** Joins: xitology (xi@85437D54.5AFA3E4.CEDFC552.IP)
[22:12:14] *** Quits: moostik (Icedove@5A22E6A1.10715965.BCDF592F.IP) (Ping timeout)
[22:12:46] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[22:13:14] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[22:14:01] *** Quits: Sharp (Sharp@1710C26.8381A41.8725677B.IP) (Quit: Sharp)
[22:14:58] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[22:15:18] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[22:16:35] <g3xzh> if my "if" statements has only one line, do i have to wrap it with { and } braces? for instance, "if x > 10 println('muhahaha');"
[22:16:52] <g3xzh> or i have to "if x > 10 { println('muhahahahaha'); }"
[22:16:56] <strcat> yes
[22:17:07] <strcat> C requires parentheses around the condition instead of requiring braces
[22:17:14] <strcat> can't do both
[22:17:23] *** Joins: moostik (Icedove@5A22E6A1.10715965.BCDF592F.IP)
[22:17:23] <g3xzh> i have to wrap it... ok. good to know
[22:18:08] <FreeFull> Some people find the option C took confusing sometimes
[22:18:13] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[22:18:53] *** Quits: Zor (zor@moz-180BED6.rfw.name) (Ping timeout)
[22:19:24] *** Quits: vodik (simon@moz-FD4ADBC6.cable.teksavvy.com) (Ping timeout)
[22:19:37] *** Joins: vodik (simon@moz-FD4ADBC6.cable.teksavvy.com)
[22:20:01] *** Joins: Sharp (Sharp@1710C26.8381A41.8725677B.IP)
[22:20:13] <g3xzh> FreeFull: I guess I am too used to C syntax that it makes sense to me.
[22:20:16] <g3xzh> :)
[22:20:17] *** Joins: Zor (zor@moz-180BED6.rfw.name)
[22:20:26] <g3xzh> I do hate C++, though.
[22:20:31] *** Joins: sprang (sprang@218EECCF.15473528.2321E71E.IP)
[22:20:32] *** Quits: alex-abreu (alex@moz-4B4D75AD.rev.sfr.net) (Ping timeout)
[22:21:39] *** Quits: Sharp (Sharp@1710C26.8381A41.8725677B.IP) (Quit: Sharp)
[22:21:47] <lkuper> erickt: back now.  So, don't get too distracted by the MVar stuff at the start of the talk.  It didn't have to be an MVar, I just wanted to show an example of a race condition and that happened to be the most expedient way to do it in haskell
[22:22:24] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[22:23:17] *** Quits: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP) (Client exited)
[22:23:42] <mib_4z5202> is there an updated tutorial on how to write unit tests?
[22:23:52] <FreeFull> g3xzh: I know I like Rust much better than C++
[22:24:29] <strcat> there are quite a few ways rust is more like C than C++
[22:24:48] <strcat> like not having copy constructors (implicit heap allocations and so on)
[22:25:12] <g3xzh> mib_4z5202: yes there is
[22:25:14] <strcat> and type-checking being able to verify a function from the definition, rather than instantiations (without losing generics)
[22:25:15] *** Joins: fyolnish (fyolnish@moz-399FE158.uqwimax.jp)
[22:25:29] <FreeFull> Rust isn't OO
[22:25:38] <strcat> how so?
[22:25:47] <g3xzh> strcat: good
[22:25:53] <FreeFull> Well, not in the same way C++ is
[22:25:56] <strcat> single inheritance is planned
[22:26:02] <erickt> lkuper: :) so how would you compare a LVar-driven set to something like a concurrent set? Was that your example of the graph traversal in your talk?
[22:26:28] <g3xzh> mib_4z5202: https://github.com/mozilla/rust/wiki/Doc-unit-testing
[22:26:30] <g3xzh> there you go
[22:26:42] <mib_4z5202> g3xzh: thanks
[22:26:57] *** Quits: fyolnish (fyolnish@moz-399FE158.uqwimax.jp) (Ping timeout)
[22:27:27] <g3xzh> mib_4z5202: if you need help writing benchmark tests, let me know. i have done it so i may help you.
[22:28:04] <g3xzh> strcat: C++ generic idiom is painful
[22:28:06] <lkuper> Re: the difference between a "deterministic parallel set" and a "concurrent set": how do you define a concurrent set?  just one that can be accessed by multiple threads?  are there any safety properties implicit in that name?
[22:28:32] <strcat> g3xzh: rust still does it the same way, but you have to specify all of the requirements via trait bounds
[22:28:45] <lkuper> I don't know what "deterministic parallel set" means either.  But we define a "monotonic data structure" to be one where (1) the contents are always growing wrt some partial order, and (2) the order of updates cannot be observed
[22:29:12] <lkuper> so (2) says something about the API.  there are probably lots of ways to enforce (2), but we enforce it with threshold reads
[22:29:27] *** Quits: colinsurprenant (colin@F692E1FE.8D7057CF.30F15291.IP) (Quit: colinsurprenant)
[22:30:09] <lkuper> and then we show that a parallel language where all inter-thread communication takes place through monotonic data structures is a deterministic parallel language
[22:30:27] <lkuper> so to me, deterministic parallelism is a property of a language, not of a data structure
[22:30:50] <g3xzh> strcat:  uh huh. i have no idea whether it's good or bad.
[22:31:23] <erickt> lkuper: heh. i think i was reaching for monotonic data structure
[22:31:37] <strcat> g3xzh: unlike C++, it type-checks the definition and knows it's valid
[22:31:46] *** Joins: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net)
[22:31:50] <strcat> C++ has to type-check each instantiation (a set of type parameters) and it can go wrong anywhere inside it
[22:32:02] <strcat> and you get huge stack traces of incomprehensible implementation detail errors
[22:32:05] <strcat> ;p
[22:32:13] *** Joins: mib_i7vfx2 (Mibbit@15E64609.6A8A1F30.A34EC3BB.IP)
[22:32:15] *** Parts: mib_i7vfx2 (Mibbit@15E64609.6A8A1F30.A34EC3BB.IP) ()
[22:32:19] <g3xzh> then it is super-duper awesome!!!
[22:32:37] <strcat> rusti: fn foo<T>(x: T) -> T { x } foo(5)
[22:32:38] -rusti- 5
[22:32:45] <erickt> lkuper: yeah, I meant a concurrent set as one that can be accessed by multiple threads
[22:32:50] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[22:32:54] <strcat> rusti: fn foo<T: Ord>(x: T, y: T) -> bool { x < y } foo(5, 2)
[22:32:54] *** Quits: canhtak (canhtak@moz-1D882009.wl.t.ulaval.ca) (Quit: canhtak)
[22:32:55] -rusti- false
[22:33:09] <g3xzh> lol!!!
[22:33:23] <g3xzh> i am amazed how simple it looks like
[22:33:23] <strcat> rusti: trait Foo {} impl Foo for int {} fn foo<T: Foo>(x: T) { x.foo() } foo(5)
[22:33:24] -rusti- <anon>:9:64: 9:73 error: type `T` does not implement any method in scope named `foo`
[22:33:24] -rusti- <anon>:9         trait Foo {} impl Foo for int {} fn foo<T: Foo>(x: T) { x.foo() } foo(5)
[22:33:24] -rusti-                                                                          ^~~~~~~~~
[22:33:24] -rusti- error: aborting due to previous error
[22:33:24] <aatch> g3xzh, A good example is actually when it fails:
[22:33:25] -rusti- application terminated with error code 101
[22:33:33] <strcat> whoops
[22:33:40] *** Joins: canhtak (canhtak@moz-1D882009.wl.t.ulaval.ca)
[22:33:42] <aatch> rusti: fn foo<T>(x: T, y: T) -> bool { x < y } foo(5, 2)
[22:33:42] -rusti- <anon>:9:40: 9:45 error: binary operation < cannot be applied to type `T`
[22:33:42] -rusti- <anon>:9         fn foo<T>(x: T, y: T) -> bool { x < y } foo(5, 2)
[22:33:43] -rusti-                                                  ^~~~~
[22:33:43] -rusti- error: aborting due to previous error
[22:33:43] -rusti- application terminated with error code 101
[22:33:55] <strcat> rusti: trait Bar { fn bar(&self) {} } impl Bar for int {} fn foo<T: Bar>(x: T) { x.bar() } foo(5)
[22:33:56] -rusti- ()
[22:34:07] <g3xzh> aatch: +1
[22:34:09] <strcat> g3xzh: anyway it is pretty neat. a trait is just a property of a type
[22:34:15] <g3xzh> this is easy to debug 
[22:34:22] <strcat> and traits can supply default implementations of methods
[22:34:24] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Ping timeout)
[22:34:38] <strcat> or inherit from other traits (meaning a type implementing that trait has to implement all the traits it inherits from too)
[22:34:41] * strcat loves traits ;p
[22:34:49] <erickt> lkuper: so I guess if you are using a mutex-protected set like java's ConcurrentSkipListSet and you want to do deterministic reads on it, you need to block until all the threads have finished writing to the set before you read
[22:34:52] <g3xzh> :P awesome
[22:35:11] <nmatsakis> bstrie: #define and && ?
[22:35:16] <aatch> People sometimes get annoyed with it, but ultimately it allows each function to be type-checked independently and be proven to work with all valid inputs.
[22:35:28] *** Quits: smodo (tadnr@moz-6398EFDF.dclient.hispeed.ch) (Ping timeout)
[22:35:41] * nmatsakis realizes he was reading some really old backscroll
[22:35:42] <nmatsakis> bstrie: nm
[22:35:44] <bstrie> nmatsakis: http://en.cppreference.com/w/cpp/language/operator_alternative
[22:36:01] <erickt> lkuper: but with LVars you may be able to do a deterministic read earlier than that mutex-protected set?
[22:36:02] <g3xzh> aatch: compile-time failure is better than run-time failure.
[22:36:07] <strcat> C++ templates let the implementation not worry about what the requirements actually are... which is a bad thing
[22:36:08] <lkuper> erickt: yeah, so that differs from LVars in that with an LVar you'd just go ahead and do the read whenever, but the semantics of reading are that it'd block until its threshold is reached
[22:36:10] <nmatsakis> bstrie: ah, it's only in C that they are #defines :)
[22:36:18] <g3xzh> so i guess i have no idea why people don't like it
[22:36:27] <strcat> g3xzh: well with templates you still get a compile-time failure, but it's often unclear why
[22:36:28] <nmatsakis> bstrie: I have never once seen those used
[22:36:37] *** Joins: smodo (tadnr@moz-6398EFDF.dclient.hispeed.ch)
[22:36:44] <bstrie> nmatsakis: allegedly someone in here uses them to ease the transition to and from python
[22:36:46] <lkuper> erickt: there's also no notion of mutual exclusion with LVars.  In one sentence, the philosophy is "let data races happen, but make it so that they don't matter"
[22:36:48] <bstrie> forget who said so
[22:36:49] <strcat> g3xzh: since the requirements are entirely implicit from how it was implemented, and it has to just try expanding it for each type
[22:36:59] *** Joins: Sharp (Sharp@1710C26.8381A41.8725677B.IP)
[22:37:16] <bstrie> nmatsakis: but they're part of the C++ spec! any self-respecting C++ dev *must* know about them :)
[22:37:21] <strcat> and you might have a call stack 20 functions deep into generic functions... and you'll get a massive stack trace all the way up, showing you some weird implementation detail
[22:37:37] <nmatsakis> bstrie: indeed! ( I didn't know about them :P )
[22:37:37] *** Joins: SingingBoyo (SingingBoy@DA28FB90.A5D0D593.4F048BDC.IP)
[22:37:42] <strcat> although C++ templates are more flexible/powerful for the same reason
[22:37:55] <strcat> but the defined API/requirements are unclear
[22:38:25] <strcat> nmatsakis: yeah in C they come in a weird header
[22:38:37] <g3xzh> strcat: i guess if that happens, then you have implemented something wrong
[22:39:40] <erickt> lkuper: would it be fair to compare LVars to futures? It almost seems like LVars are like a future that's over multiple items
[22:39:50] <strcat> C++ templates are a turing complete meta-language so... you can do lots of neat stuff (type safe unit dimensions), but it slows compiles and gives awful errors
[22:40:13] <strcat> I like rust's traits a *lot* better, except when I can't express something I could in c++ ;p
[22:40:32] <g3xzh> Hehehe :D
[22:40:36] <aatch> I do like the type-safe unit dimensions. I implemented it in D as well
[22:40:58] <strcat> although since rust has built-in tagged unions and so on, that's one big thing people hack together with C++ templates covered
[22:41:55] <aatch> But type-generics are the primary thing C++ templates are used for, and Rust has that covered well. I'd say that allowing constants as generic arguments would be nice though...
[22:42:37] <g3xzh> constants as generic arguments? eh?!
[22:42:49] <g3xzh> i mean - why would anyone do that?
[22:42:51] <lkuper> erickt: hm, so, my understand of with futures is just what you get with `par` and `pseq` in haskell -- it's purely functional, with no shared state.  LVars are shared between threads.  I don't know what a "future over multiple items" is.
[22:42:55] <aatch> g3xzh, it's not possible in Rust, but it is in C++
[22:43:13] <aatch> You can have a constant as an argument to a template in C++
[22:43:22] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[22:43:25] <sfackler> g3xzh: something like FixedArray<uint N, T> { .. }
[22:43:26] <strcat> g3xzh: well in the units example, you can use them to meta-program unit dimensions into the type system
[22:43:27] <g3xzh> aatch: can you bring an example?
[22:43:31] <g3xzh> hooo
[22:43:46] <g3xzh> uh huh... i see
[22:44:10] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[22:44:30] <strcat> C++ makes the errors you get from that kind of system *completely awful*, so it's really painful to actually use
[22:44:41] *** Quits: w3lcome (Mibbit@moz-E9ABA59E.home.otenet.gr) (Quit: http://www.mibbit.com ajax IRC Client)
[22:44:47] <strcat> g3xzh: well... one good example is that C++ doesn't have tagged unions in the language like rust
[22:45:04] <strcat> but you can write something like variant<int, bool, double, std::string>
[22:45:14] <strcat> so... one of the things you need to deal with is allocating the memory
[22:45:27] <strcat> it needs to be as large as the largest type, and have the alignment of the type with the highest alignment
[22:45:30] <g3xzh> :D
[22:45:30] <aatch> I wouldn't be upset if Rust never gets it, but I would like it in atleast a limited form.
[22:45:54] <strcat> g3xzh: anyway... what you have to do is write recursive templates to calculate the sum of sizes/alignments ;p
[22:46:09] <erickt> lkuper: I'm unfamiliar with haskell, so I can't speak to it. I see futures as being in rust `let f = future(|| sleep(5); 5); <stuff> let x = f.force()`. If <stuff> took longer than 5 seconds, `.force()` would be a no-op, otherwise it'd block
[22:46:14] <strcat> C++11 templates have a first-class list type ;\
[22:46:41] * aatch remembers the recursive variadic template in HHVM that caused n^4 instantiations
[22:46:43] <strcat> g3xzh: http://ix.io/9kR like that ;p
[22:47:01] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[22:47:11] <aatch> Andrei ended up writing a hack to fix it.
[22:47:15] <g3xzh> strcat: thanks.
[22:47:22] <lkuper> erickt: do those futures allow sharing of state between tasks?
[22:47:30] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[22:47:49] *** Quits: canhtak (canhtak@moz-1D882009.wl.t.ulaval.ca) (Quit: canhtak)
[22:48:04] <g3xzh> :)
[22:48:44] <lkuper> erickt: I mean, I think the answer is no
[22:48:57] <lkuper> erickt: I guess I see the analogy you're trying to make wrt blocking, though
[22:48:58] <erickt> lkuper: sharing state is not really a part of futures. if you are in java, sure you could share state. Rust doesn't though. LVars sounds more like a more general form of futures
[22:49:39] <lkuper> erickt: well, so...with LVars you can actually get interesting information out of an LVar other than "ok, this task is done"
[22:51:03] <erickt> lkuper: yeah, they seem really neat :)
[22:52:01] <erickt> lkuper: thanks for putting up with my slow understanding of your technique
[22:52:08] <lkuper> I dunno about the futures analogy, I'd have to think about it more.  I haven't actually done much parallel programming aside from with LVars!
[22:52:30] *** Quits: Jesin (Jesin@moz-C1EBF9B4.dept.lehigh.edu) (Quit: Leaving)
[22:52:52] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[22:53:00] <aatch> erickt, oh, I saw your paper on GPU programming on Rust. I'll admit I just skimmed through it, but it looked really cool!
[22:53:02] <bstrie> can someone explain the implicitly copyable rules again
[22:53:12] <bstrie> or, can someone just write the damn rules down somewhere :)
[22:53:12] <lkuper> aatch: I think you mean eholk's paper :)
[22:53:14] <erickt> aatch: that wasn't me :)
[22:53:18] <aatch> erickt, my bad.
[22:53:22] <strcat> lkuper: futures are basically a wrapper around a thread/actor/async thing with join (block until it's done, return result), try_join, and timed_wait (until an absolute time or for a period of time)
[22:53:34] <aatch> eholk, erickt close enough
[22:53:39] <strcat> in rust I think Future would probably be a trait
[22:53:39] *** Joins: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP)
[22:53:49] <strcat> not a concrete type
[22:54:04] <strcat> so for example.... a joinable Task or Thread object could implement it
[22:54:32] <mib_4z5202> why do I get an unresolved 'int' in a unit test?
[22:54:42] <FreeFull> Any useable Rust STM yet?
[22:54:43] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[22:54:49] <erickt> lkuper: have you ever seen the book Concepts, Techniques, and Models of Computer Programming? It works through the creation of the Oz language, which does all sorts of interesting things with futures: http://www.info.ucl.ac.be/~pvr/book.html
[22:54:52] <strcat> FreeFull: no
[22:54:54] <lkuper> strcat: wow, that's kinda different from the haskell futures API (which is the only one I'm familiar with)
[22:55:02] <pcwalton> nmatsakis: r? https://github.com/mozilla/rust/pull/10924
[22:55:10] <strcat> lkuper: http://en.cppreference.com/w/cpp/thread/future for example (java's is similar)
[22:55:14] <lkuper> erickt: I've had that book out of the library for ages with the intent to read it
[22:55:35] <lkuper> erickt: I do think it's super awesome that the *very first* interesting language feature they introduce is, basically, IVars
[22:55:45] *** Quits: pcwalton (pcwalton@moz-DFAA4E15.p2p.sfo1.mozilla.com) (Quit: pcwalton)
[22:56:15] <strcat> hardware lock elision and hardware transactional memory exist now anyway ;p
[22:56:32] <erickt> lkuper: yeah it's a neat book. I still need to finish going through it. It's been, oh, 4 years since I last opened it :)
[22:56:36] <FreeFull> That's only good if you've got the hardware and the software knows how to use it =P
[22:56:40] <strcat> if you make a simple data structure guarded by a mutex on haswell, it can do speculative execution in the threads
[22:57:09] <Amanieu> I wrote a futures API in C++11, if you're interested: https://github.com/Amanieu/asyncplusplus
[22:57:15] <FreeFull> I don't own any machines with haswell in them
[22:57:17] <strcat> FreeFull: any data structures with mutexes can support HTM, you just don't get to write your own rollback code
[22:57:22] *** Joins: pcwalton (pcwalton@moz-C07D5168.p2p.sfo1.mozilla.com)
[22:57:22] *** ChanServ sets mode: +ao pcwalton pcwalton
[22:57:32] <strcat> it will work "as if" it obtained an exclusive lock
[22:57:40] <strcat> transparently
[22:58:33] <bjz> erickt: +1 to CTMCP (horrible name for a book though)
[22:58:34] <strcat> so even if two threads write, as long as they don't need to write to the same memory it won't have to stall one
[22:58:55] <strcat> it is pretty neat.
[22:59:18] <FreeFull> As I said, it's only possible if the hardware actually has HTM support
[22:59:41] *** Quits: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP) (Ping timeout)
[22:59:49] <strcat> FreeFull: the HTM as implemented by intel is closer in API to a mutex than STM though
[22:59:54] *** Quits: devbug (quassel@2D4E172D.4C8B6099.9B57EA59.IP) (Ping timeout)
[23:00:09] *** Quits: dherman (dherman@moz-DFAA4E15.p2p.sfo1.mozilla.com) (Ping timeout)
[23:00:10] <strcat> although, you can specify rollback code, but it's very limited
[23:00:15] <strcat> you couldn't just transition haskell STM to it
[23:00:19] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[23:00:19] *** ChanServ sets mode: +ao brson brson
[23:00:34] <bjz> erickt: her has some videos he's trialing for an upcoming mooc: http://www.youtube.com/user/PeterVanRoy/videos
[23:00:36] *** Joins: dherman (dherman@moz-DFAA4E15.p2p.sfo1.mozilla.com)
[23:00:36] *** ChanServ sets mode: +ao dherman dherman
[23:00:42] *** Quits: brendan (brendaneic@777B9EEC.C030CAFC.1EF54B18.IP) (Quit: brendan)
[23:00:48] *** Quits: sellout (sellout-@moz-9C064DFC.hsd1.co.comcast.net) (Quit: Leaving.)
[23:01:03] <erickt> bjz: neat
[23:01:17] <bjz> erickt: the chapter 12 stuff is really nice
[23:01:17] *** jorendorff is now known as jorendorff_away
[23:01:46] <mib_4z5202> is it recommended to write unit tests in the same module?
[23:02:03] <bjz> how adding little things to a language can completely change the way you program with it, or the possibilities
[23:02:08] *** Joins: dbaupp (Thunderbir@4F13D67D.D5A1DCF.37681C44.IP)
[23:02:20] <lkuper> bjz, erickt: good stuff
[23:02:21] <bjz> and also how leaving some things out is not always a bad thing
[23:02:44] <dbaupp> bstrie: (my request for an eval bot was mainly so I could suggest porting rustc to CSS. :P )
[23:02:49] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Client exited)
[23:02:53] <bjz> mib_4z5202: depends on whether you are testing the internal or external API
[23:03:10] <mib_4z5202> bjz: I am testing internal
[23:03:16] <bstrie> dbaupp: keep in mind that CSS is only turing-complete if you manually pump the compiler via constantly resizing the window
[23:03:26] <bjz> mib_4z5202: at the moment rustpkg makes it difficult to write external test suites
[23:03:42] <mib_4z5202> bjz: I have problems with unresolved 'int' and I wonder what is happening
[23:03:49] <bjz> mib_4z5202: it's usually easier to include them in the same module
[23:03:52] <bjz> hmm
[23:04:03] <bjz> error and source?
[23:04:22] *** Quits: donri (donri@moz-9BB61102.tbcn.telia.com) (Client exited)
[23:05:31] <dbaupp> bstrie: that's fine
[23:05:47] <mib_4z5202> sorry, I am not customized to vim yet
[23:06:08] <dbaupp> bstrie: gotta make the community work for their rust output.
[23:06:24] <bstrie> dbaupp: self-hosting will be quite tedious, though
[23:06:30] <dbaupp> strcat: btw, we do support multiple lifetime paramaters right now.
[23:06:31] <bjz> mib_4z5202: you mean, 'accustomed'?
[23:06:36] <strcat> dbaupp: no
[23:06:51] <dbaupp> strcat: `struct Foo<'a, 'b> { x: &'a int, y: &'b int }` work perfectly for me
[23:07:03] <strcat> oh
[23:07:04] * strcat shrugs
[23:07:12] <strcat> I guess nmatsakis implemented it ;p
[23:07:14] <dbaupp> yup
[23:07:30] *** Joins: ktt3ja (ktt3ja@moz-D69B60E4.hsd1.va.comcast.net)
[23:07:34] <dbaupp> bstrie: xdotool should make it nicer
[23:07:55] <aatch> https://github.com/mozilla/rust/pull/10153
[23:08:02] <aatch> strcat, ^^
[23:08:42] *** Quits: lkuper (lkuper@moz-D862222C.dhcp-bl.indiana.edu) (Ping timeout)
[23:09:21] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Quit: yichoi)
[23:09:22] *** Joins: brendan (brendaneic@777B9EEC.C030CAFC.1EF54B18.IP)
[23:10:21] *** Joins: nejucomo (Adium@moz-B62B9944.public.monkeybrains.net)
[23:11:52] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[23:12:10] <aatch> hmm, cool, we're getting a POD kind
[23:12:38] *** Quits: prooftechnique (prooftechn@moz-1C9C6B71.hsd1.vt.comcast.net) (Quit: )
[23:13:39] *** Joins: nsf (nsf@moz-EEF3238A.convex.ru)
[23:13:42] <mib_4z5202> http://pastebin.com/Bi8rkd3z
[23:13:51] *** Quits: peterdn (chatzilla@moz-3DA3F15F.as13285.net) (Ping timeout)
[23:15:14] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[23:15:25] <aatch> mib_4z5202, there's not value named 'int'
[23:15:49] <aatch> You're using the wrong syntax. it's `let a : ~[int] = ...`
[23:16:11] <mib_4z5202> AH
[23:16:18] <aatch> rusti: let int = 1; int
[23:16:20] -rusti- 1
[23:16:27] <aatch> hmm, should that be allowed ^^
[23:16:39] <aatch> I guess 'int' isn't a keyword though...
[23:17:07] *** flaper87 is now known as flaper87|afk
[23:25:39] <bjz> aatch: we have separate value/type namespaces (not sure if that's the right name)
[23:25:50] *** Joins: fyolnish (fyolnish@moz-6D331BDF.uqwimax.jp)
[23:25:53] <aatch> bjz, it's correct.
[23:26:28] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[23:26:42] <aatch> I'm surprised that it's allowed, just musing as to whether we want to keep it that way.
[23:27:10] <bjz> rusti: enum Reply<T> { Reply(T), Stop } fn ping<T>(x: T) -> Reply<T> { Reply(T) } ping(1)
[23:27:10] -rusti- <anon>:9:78: 9:79 error: unresolved name `T`. Did you mean `x`?
[23:27:10] -rusti- <anon>:9         enum Reply<T> { Reply(T), Stop } fn ping<T>(x: T) -> Reply<T> { Reply(T) } ping(1)
[23:27:10] -rusti-                                                                                        ^
[23:27:10] -rusti- error: aborting due to previous error
[23:27:11] -rusti- application terminated with error code 101
[23:27:18] *** Quits: AvianFlu (AvianFlu@moz-723527FF.nycmny.fios.verizon.net) (Ping timeout)
[23:27:18] <bjz> rusti: enum Reply<T> { Reply(T), Stop } fn ping<T>(x: T) -> Reply<T> { Reply(x) } ping(1)
[23:27:19] -rusti- Reply(1)
[23:27:33] *** Quits: fyolnish (fyolnish@moz-6D331BDF.uqwimax.jp) (Ping timeout)
[23:27:42] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Input/output error)
[23:27:51] <bjz> aatch: I dunno. not sure it matters
[23:28:12] <aatch> bjz, it doesn't really, and it's only for those primitive types to start with.
[23:28:17] *** Joins: arityfn (arity@4B7A98.5E6FAFF2.7C05EB22.IP)
[23:30:17] <bjz> is struct Foo(T, ..); sugar for enum Foo<T, ..> { Foo(T, ..) }, likewise struct Foo { t: T, .. }; => enum Foo<T, ..> { Foo { t: T, .. } } and struct Foo; => enum Foo { Foo } ?
[23:30:40] *** Quits: Scriptor (anonymous@moz-E06F46F0.corp.bitshelter.com) (Quit: Scriptor)
[23:31:04] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[23:31:49] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Max SendQ exceeded)
[23:32:03] <aatch> bjz, I guess potentially? But I think that even 1-variant enums get a discriminant, so probably yes, semantically, but no in terms of implementation.
[23:32:29] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[23:32:32] <bjz> aatch: would it be worth documenting this stuff?
[23:32:37] <dbaupp> bjz: they aren't actually implemented as sugar
[23:32:48] <dbaupp> aatch: I don't think 1 variant enums get a discriminant
[23:32:58] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Max SendQ exceeded)
[23:33:04] *** Joins: ricepuddin (graham@moz-7D68765A.cable.virginm.net)
[23:33:06] <dbaupp> rusti: enum Foo { Foo(u16) } std::sys::size_of::<Foo>()
[23:33:08] -rusti- 2u
[23:33:08] <aatch> dbaupp, you are correct.
[23:33:32] <aatch> (I just looked it up)
[23:33:45] <bjz> rusti: struct Foo(u16); std::sys::size_of::<Foo>()
[23:33:46] -rusti- 2u
[23:34:00] <aatch> bjz, well it's not sugar, but it appears that yes, they are equivalent.
[23:34:08] <strcat> just keep in mind that rusti is going to have different answers for some
[23:34:09] <bjz> dbaupp: yeah, that would be important for error messages
[23:34:12] <strcat> because it's old
[23:34:28] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[23:34:50] <aatch> We only have 1 thing implemented as a desugaring (for loops), and that's planned to be implemented "properly" at some point.
[23:34:54] <bjz> I'm just wondering if it would be good to have unit tests for these equivalences
[23:35:10] <aatch> bjz, probably not worth it.
[23:35:13] *** Quits: ianj (ianjneu@moz-7140CF01.ccs.neu.edu) (Input/output error)
[23:35:36] <aatch> enums explicitly don't have a defined representation.
[23:36:01] <bjz> aatch: true, but structs do.
[23:36:11] <bjz> (as in, I agree)
[23:36:13] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Ping timeout)
[23:36:28] <aatch> bjz, well yes, but what equivalency are you looking to test in that case?
[23:36:34] *** Quits: jvns (bork@87D98E32.4046EB22.428F94DD.IP) (Ping timeout)
[23:36:46] <aatch> (if not against currently-equivalent enums)
[23:37:34] *** Quits: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net) (Ping timeout)
[23:37:48] <bjz> aamainly the fact that you can actually construct these things and use them in the same locations. I'm just thinking of how to reduce the core language
[23:38:13] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[23:38:27] <bjz> `struct` is a syntactic thing, not a semantic thing
[23:38:41] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[23:39:26] <bjz> but I guess you could argue the representation is possibly semantics
[23:39:33] <bjz> I dunno
[23:39:45] <jdm> strcat: your weak pointer implementation doesn't actually free the memory for the original object until all weak pointers are gone, right?
[23:40:03] <strcat> jdm: right, but destroying the object will kill any weak pointers that are cyclic refs
[23:40:14] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[23:40:21] <strcat> it might hold onto the actual allocation longer than necessary
[23:40:23] <strcat> it's a tradeoff
[23:41:05] <o11c> you can choose to have one allocation for weak + shared&object, or two allocations for weak and shared&object
[23:41:05] <strcat> the alternative is each weak pointer resulting in an allocation, and having them form an intrusive list
[23:41:16] <strcat> o11c: well this is neither
[23:41:28] <o11c> eh? Not sure why you'd need one allocation per weak in any case
[23:41:41] <strcat> oh sorry this is the first one
[23:42:03] <strcat> o11c: the intrusive list way is to make shared_ptr easier afaik
[23:42:15] <strcat> because it's atomatically refcounted, so weak ptrs are a bit tricky
[23:42:22] <o11c> one allocation and screw the minor memory waste is good,  ... it's the dtor that's important
[23:43:29] *** Quits: andreypopp (andreypopp@moz-7261DC60.net) (Quit: andreypopp)
[23:43:42] *** Quits: fabiand (fabiand@moz-E98E5E08.adsl.alicedsl.de) (Quit: Verlassend)
[23:44:09] <strcat> well this is speedier and uses a bit less memory, but potentially holds onto more memory longer for a large object
[23:44:15] <jdm> I guess I'm used to Gecko's implementation, where there's a proxy object that all weak references go through
[23:44:29] *** Joins: g3xzh_ (g3xzh@moz-8971AFD0.red.bezeqint.net)
[23:44:40] *** Quits: g3xzh (g3xzh@moz-A4DE8FAB.red.bezeqint.net) (Ping timeout)
[23:44:58] *** Quits: sprang (sprang@218EECCF.15473528.2321E71E.IP) (Quit: sprang)
[23:45:22] *** Quits: jvshahid (jvshahid@BE83DFD.50866E69.CA2DF2C0.IP) (Ping timeout)
[23:46:12] *** Quits: ricepuddin (graham@moz-7D68765A.cable.virginm.net) (Ping timeout)
[23:46:51] <strcat> jdm: http://en.cppreference.com/w/cpp/memory/shared_ptr the implementation notes at the bottom there are the way libc++/libstdc++ do it
[23:47:23] <strcat> I'm not really sure *why* make_shared makes it able to allocate 1 instead of 2
[23:49:15] <o11c> because the normal constructor gets passed a poiner
[23:49:47] <o11c> obviously you can't put arbitrary more data in a pointer-to-T that they didn't know was going to be used for a shared pointer
[23:49:49] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Quit: yichoi)
[23:50:36] <strcat> o11c: why doesn't it just forward the ctor to placement new then?
[23:50:42] * strcat doesn't get it
[23:51:16] <o11c> strcat: shared_ptr<T>(T *) takes an existing allocated object
[23:51:21] <strcat> oh!
[23:51:23] <o11c> remember that C++ does not have trivial moves
[23:51:30] <o11c> Rust can avoid that
[23:54:03] *** Joins: Skif_ (emschwar@moz-CA025D57.ip.mcleodusa.net)
[23:54:42] *** Joins: Jarrett (me@moz-8211AC00.dhcp.nrwl.ca.charter.com)
[23:54:59] *** Quits: hacker_sam (hacker_sam@moz-5218E46E.public.wayport.net) (Client exited)
[23:55:09] *** Quits: Skif (emschwar@moz-CA025D57.ip.mcleodusa.net) (Ping timeout)
[23:55:20] *** Joins: hacker_sam (hacker_sam@moz-5218E46E.public.wayport.net)
[23:55:39] *** Joins: g3xzh__ (g3xzh@moz-F05C9A20.red.bezeqint.net)
[23:55:47] *** Quits: Skif_ (emschwar@moz-CA025D57.ip.mcleodusa.net) (Ping timeout)
[23:56:08] *** Quits: g3xzh_ (g3xzh@moz-8971AFD0.red.bezeqint.net) (Ping timeout)
[23:56:15] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[23:57:00] *** Joins: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net)
[23:58:20] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[23:58:20] *** Joins: barosl (barosl@3DE683B6.E551553C.7544CABF.IP)
[23:58:34] *** Joins: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP)

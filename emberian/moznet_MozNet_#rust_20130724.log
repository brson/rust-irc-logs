[00:03:02] <ChrisMorgan> Tut tut... unused variable at src/librustc/middle/trans/_match.rs:1283     let dm = tcx.def_map;
[00:05:59] <strcat> it's there for moral support
[00:06:08] <strcat> the other variables were lonely :(
[00:06:15] <bblum> haha strcat
[00:08:38] *** Quits: LU324 (stuff@moz-A17E9A7B.dyn.embarqhsd.net) (Input/output error)
[00:10:53] <erickt> ChrisMorgan: I got a fix for that folded into #7996
[00:11:27] <ChrisMorgan> erickt: I figured the probability of its already being remedied was very high. Glad I was right!
[00:11:33] *** Quits: vodik (simon@moz-CBE4BB13.cable.teksavvy.com) (Ping timeout)
[00:12:14] <erickt> ChrisMorgan: It's also a part of #7967, but I think that one may take a couple iterations to land
[00:13:31] <sully> I fix the unused variable in the PR I just submitted, too
[00:14:53] <eatkinson> rusti: trait MyTrait { fn foo(&self); } trait MyInhTrait : MyTrait { fn bar(); } struct MyStruct { x: uint; } impl MyInhTrait for MyStruct { fn bar () { let y = x; self.foo() }
[00:14:53] -rusti- <anon>:10:0: 10:1 error: file ended with unbalanced delimiters
[00:14:53] -rusti- <anon>:10 }
[00:14:53] * sully just submitted a PR that fixes basically everything I know that is still wrong about default methods
[00:14:53] -rusti-           ^
[00:14:54] -rusti- application terminated with error code 101
[00:15:12] <eatkinson> rusti: trait MyTrait { fn foo(&self); } trait MyInhTrait : MyTrait { fn bar(); } struct MyStruct { x: uint; } impl MyInhTrait for MyStruct { fn bar () { let y = x; self.foo() }}
[00:15:14] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/cZhO
[00:15:40] <eatkinson> rusti: trait MyTrait { fn foo(&self); } trait MyInhTrait : MyTrait { fn bar(); } struct MyStruct { x: uint } impl MyInhTrait for MyStruct { fn bar () { let y = x; self.foo() }}
[00:15:41] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/dgVT
[00:15:50] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[00:16:46] <eatkinson> rusti: trait MyTrait { fn foo(&self); } trait MyInhTrait : MyTrait { fn bar(&self); } struct MyStruct { x: uint } impl MyInhTrait for MyStruct { fn bar (&self) { let y = self.x; self.foo() }}
[00:16:48] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/iefD
[00:18:28] <engla> sully: awesome
[00:18:51] <strcat> sully: I know of one more bug so we'll see if that fixes it :)
[00:19:02] *** Joins: snerd (Mibbit@F2E7AF9A.53E3CB78.DF793B8F.IP)
[00:19:12] <snerd> morning
[00:19:24] <strcat> \o
[00:20:10] <snerd> hrm, let'
[00:20:20] <snerd> s try irssi, mibbit gives me the irrits
[00:21:06] *** Joins: LU324 (stuff@moz-A17E9A7B.dyn.embarqhsd.net)
[00:21:48] *** Quits: brendan (brendaneic@35E90EE3.B8B12C49.396B22AD.IP) (Ping timeout)
[00:21:56] *** Quits: mschifer (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[00:22:55] *** Joins: snerd_ (motk@moz-E535583C.nonstopcrunchy.net)
[00:23:09] *** Quits: snerd (Mibbit@F2E7AF9A.53E3CB78.DF793B8F.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[00:23:28] <doomlord> rest from trying to work with the ast api.. done a bit more on my  limited cpp2rust binding generator. 
[00:23:34] *** Quits: snerd_ (motk@moz-E535583C.nonstopcrunchy.net) (Quit: leaving)
[00:24:07] *** Joins: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net)
[00:24:09] *** Joins: snerd (motk@moz-E535583C.nonstopcrunchy.net)
[00:24:52] *** Quits: yonran (yonran@moz-962F33EB.acuitus.com) (Ping timeout)
[00:25:29] <eatkinson> rusti: trait MyTrait { fn foo(&self); } trait MyInhTrait : MyTrait { fn bar(&self); } struct MyStruct { x: uint } impl MyInhTrait for MyStruct { fn bar (&self) { let y = self.x; self.foo() }} impl MyTrait for MyStruct { fn foo(&self) { self.x; }}
[00:25:30] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/ZORf
[00:25:43] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[00:25:53] <snerd> that's better :)
[00:26:13] <snerd> so I'm just compiling rust on my fedora box, first time I've dived into a new language properly in years
[00:26:16] <snerd> WML
[00:27:35] *** Joins: MaikKlein2 (maik@moz-FD97565C.dip0.t-ipconnect.de)
[00:28:04] *** Joins: Uther (Instantbir@moz-1B244B05.hfc.dyn.abo.bbox.fr)
[00:33:04] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[00:34:47] *** Quits: int3_ (int3_@moz-7B0110AD.mv.mozilla.com) (Client exited)
[00:36:59] <graydon> oh gosh
[00:37:43] *** Joins: jfbk (textual@moz-EEA9CFB3.nyc.res.rr.com)
[00:37:48] <graydon> we are still passing self in the environment slot, and translating self-taking functions as taking environments
[00:37:58] <graydon> and casting on every call
[00:38:03] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[00:38:10] <graydon> sully: I don't suppose you cleaned that up in the big change you're doing?
[00:39:06] *** Quits: dherman (dherman@A4E26FA6.5E7911EA.DA40C4B3.IP) (Quit: dherman)
[00:39:24] *** Quits: bnicholson (bnicholson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[00:40:24] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[00:41:40] <sully> graydon: no
[00:41:56] <sully> graydon: although I did get rid of the cast on every reference to self, a while back
[00:42:02] <sully> graydon: so now we just cast once per method
[00:42:05] <sully> strcat: what's your bug?
[00:42:07] <graydon> charming
[00:42:30] <graydon> sully: did I show you the codegen tests? I'm just filling in more of them to pass the time / give myself some targets to aim for
[00:43:04] <sully> I have no looked at them, no
[00:43:24] <graydon> sully: are you doing much in codegen-quality-improvement? or mostly focusing on correctness?
[00:43:51] <sully> I have mostly been doing correctness stuff
[00:44:19] <sully> I did the getting rid of the cast on every reference
[00:44:39] <sully> because the reason we were doing that was because of problems involving default methods
[00:44:43] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[00:44:44] <sully> and I did a lot of default method cleanup
[00:44:58] <graydon> ok. well, if you happen to be interested: test/codegen/foo.{rs,cc} pairs are codegen tests
[00:45:09] <graydon> if you drop 2 files in there with the same name, both defining a non-manged function "test"
[00:45:18] <graydon> they both get compiled (one rustc, one clang)
[00:45:24] <graydon> and extracted as .ll files
[00:45:27] <graydon> and the sizes compared
[00:45:36] <graydon> the ratio is a ratchet test that won't be allowed to regress
[00:45:45] <graydon> but it's also informative for diagnosing an idiom
[00:46:03] <graydon> just write down "code in rust" and "code that does the same thing" in C++ and you can see what clang is doing that's better than us
[00:46:45] <graydon> the .ll files wind up in <builddir>/<target>/test/codegen/foo-extract.ll and foo-clang-extract.ll
[00:46:46] <sully> oh, cool
[00:46:54] <graydon> it's quite handy for eyeballing weird codegen
[00:46:56] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[00:46:56] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/PyIY8Q
[00:46:56] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[00:49:55] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[00:49:56] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/pxsLeg
[00:49:56] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[00:49:57] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[00:49:57] <ghrust> 01[13rust01] 15bors pushed 10 new commits to 06auto: 02http://git.io/g_zt3g
[00:49:58] <ghrust> 13rust/06auto 1448dd728 15Graydon Hoare: extra: use deriving more in workcache, switch to treemaps.
[00:49:58] <ghrust> 13rust/06auto 14d5803e6 15Graydon Hoare: extra: access workcache db via RWARC.
[00:49:58] <ghrust> 13rust/06auto 149a093ab 15Graydon Hoare: extra: change workcache::Work::unwrap to move out of self.
[00:50:00] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[00:51:37] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[00:52:04] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[00:52:05] *** Quits: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP) (Ping timeout)
[00:53:46] <strcat> sully: it's a weird one, code was getting generated wrong or something like that
[00:54:02] <strcat> I'll try again when your fixes land and report it if it's still an issue
[00:54:12] <strcat> just involves trying to make Container::is_empty a default method
[00:54:18] <strcat> and deleting the existing impls
[00:54:59] <dbaupp> graydon: just wondering if you saw https://github.com/mozilla/rust/issues/7995 ?
[00:55:56] *** Joins: vodik (simon@moz-CBE4BB13.cable.teksavvy.com)
[00:56:07] <graydon> dbaupp: yeah, I did. not supposed to happen! grr
[00:56:13] <graydon> dbaupp: did you see we're harvesting metrics now?
[00:56:45] <dbaupp> graydon: I saw some failures in it before I went to sleep, but I haven't checked this morning... I'll have a look now.
[00:56:57] <graydon> I fixed the failures
[00:57:00] <graydon> it's harvesting now, they're up
[00:57:28] <dbaupp> awesome!
[00:57:53] *** Quits: qmx (qmx@moz-D6C3C2E6.qmx.me) (Ping timeout)
[00:58:14] <graydon> http://static.rust-lang.org/build-metrics/995440943839ecbdd1b5876244b3b8f390c97dfa/auto-linux-all-opt/linux2/check-stage2-T-x86_64-unknown-linux-gnu-H-x86_64-unknown-linux-gnu-extra-metrics.json
[00:58:16] <graydon> for example
[00:58:20] *** Quits: mye (mye@moz-60013FCF.dip0.t-ipconnect.de) (Quit: mye)
[00:59:02] <dbaupp> haha, I'd literally just typed that one out
[00:59:10] *** Quits: tchoma (tchoma@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: Textual IRC Client: www.textualapp.com)
[00:59:25] <graydon> currently I think there's only signal in extra-metrics and codegen-metrics on some of the builders (those with clang)
[00:59:25] <dbaupp> looks good! ("noise" is the +- standard deviation, right?)
[00:59:28] <graydon> yes
[00:59:46] <graydon> well, it's .. in that case actually the max-min range
[00:59:59] <graydon> though we do use median absolute deviation to calculate when to stop
[01:00:19] <graydon> I found when I used it to decide whether something is regressing, it too often was out-of-MAD-range
[01:00:32] <graydon> like computers are just too noisy or my stats brains are just not good enough, I don't know
[01:00:48] <dbaupp> what does criterion do?
[01:01:03] <graydon> an enormously complicated thing that gets it no closer to making definitive answers
[01:01:04] <erickt> graydon: I made your suggest change to https://github.com/mozilla/rust/pull/7996. Was there anything else you saw?
[01:01:10] <graydon> just plotting better graphs :(
[01:01:15] <dbaupp> haha, I see
[01:01:36] *** Joins: qmx (qmx@moz-D6C3C2E6.qmx.me)
[01:01:54] *** Joins: bnicholson (bnicholson@moz-E98974C1.hsd1.ca.comcast.net)
[01:02:16] <graydon> erick: ok. I .. can either rubber-stamp it (it looks vaguely good) or go over it in finer detail later, gotta go before I have time to look closely
[01:02:33] <graydon> up to you. or of course someone else with time / patience can look!
[01:02:50] <erickt> graydon: no problem, I'm just about to take off too :)
[01:02:55] <graydon> I feel like library design is kinda out of my league these days. everyone's doing a much nicer job than I can.
[01:03:05] *** Joins: int3_ (int3_@moz-7B0110AD.mv.mozilla.com)
[01:04:50] <erickt> graydon: I feel the same way sometimes. I've got a huge amount of jealousy for how much better a lot of these newcomers are than me nowadays
[01:05:05] <graydon> haha join the club. I am the worst rust-author!
[01:05:16] <erickt> first and the worst :)
[01:05:30] <graydon> barely know how to write it anymore. but it sure looks pretty when I see others writing it. so .. reasonably content to let that be :)
[01:05:49] <graydon> also increasing amounts of it seem to work. that's gratifying.
[01:06:48] <erickt> :)
[01:08:27] *** Quits: qmx (qmx@moz-D6C3C2E6.qmx.me) (Ping timeout)
[01:09:10] *** Joins: qmx (qmx@moz-D6C3C2E6.qmx.me)
[01:09:46] <graydon> god, encoding. what a mess. def_to_str? sigh
[01:11:01] *** Quits: vodik (simon@moz-CBE4BB13.cable.teksavvy.com) (Ping timeout)
[01:11:06] *** Quits: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net) (Quit: carllerche)
[01:12:33] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[01:14:06] <ChrisMorgan> strcat: I believe my make + make install yesterday took around 40 minutes (started at 12:41am, PREFIX/bin/rust had the timestamp 1:21am). This new one, started some nine hours after the previous one, just finished, taking 80 minutes.
[01:14:24] *** Quits: jclements (jclements@moz-98A7BA64.ngn.east.myfairpoint.net) (Quit: jclements)
[01:16:41] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[01:16:55] <nmatsakis> erickt: ping
[01:17:15] <dbaupp> ChrisMorgan, strcat: I'm pretty sure the regression is between http://huonw.github.io/isrustfastyet/buildbot/#098709a,8c08265
[01:17:48] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[01:17:56] <dbaupp> (they are both on the same buildslave, for linux at least, the ones between them are on a different (faster?) buildslave.)
[01:18:01] *** Quits: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: Leaving)
[01:18:41] <dbaupp> actually, no, I lied. :/
[01:19:49] <mark_edward> what's with the new printf! and printfln! macros?
[01:20:16] <ChrisMorgan> mark_edward: do you not prefer printf!(...) to print(fmt!(...))?
[01:20:17] <dbaupp> the de-copy changes landed between http://huonw.github.io/isrustfastyet/buildbot/#30ef79c,8c08265
[01:21:26] <mark_edward> ChrisMorgan: i guess... but what's the difference? is fmt! derecated?
[01:21:28] <ChrisMorgan> I don't know quite when my previous build was from. Just after decopy, I think.
[01:22:08] *** Joins: jclements (jclements@moz-98A7BA64.ngn.east.myfairpoint.net)
[01:22:13] <ChrisMorgan> mark_edward: certainly not; fmt! is still useful in various other places, but print was one common usage where a little sugar improves it a lot.
[01:22:40] <mark_edward> i see. is the implementation any deprecated?
[01:22:47] <mark_edward> *different
[01:22:54] * mark_edward has deprecation on the brain
[01:24:05] *** Quits: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP) (Quit: My MacBook has gone to sleep. ZZZzzz‚Ä¶)
[01:24:07] <dbaupp> mark_edward: https://github.com/mozilla/rust/blob/master/src/libsyntax/ext/expand.rs#L671
[01:24:09] <dbaupp> no
[01:24:12] <ChrisMorgan> printf!(...) == print(fmt!(...)), printfln!(...) == println(fmt!(...))
[01:24:44] <mark_edward> ah cool! it is a nice shortcut. 
[01:25:23] <mark_edward> dbaupp: higher up in the convo i saw stuff saying that fmt! was unsafe cause it visited all mebers inluding priv ones, or something like that?
[01:25:26] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[01:25:32] <mark_edward> could you expound on that!
[01:25:41] <dbaupp> fmt!("%?") prints everything
[01:26:21] <dbaupp> including private ones... I wasn't the one who said it was unsafe. (I don't think it's memory-unsafe, but I don't know.)
[01:26:59] *** Quits: azakai (alon@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[01:27:05] <engla> well it dereferences things that wouldn't be otherwise
[01:27:46] <dbaupp> it doesn't dererence * though (i.e. it won't cause segfaults)
[01:27:58] <dbaupp> but it might/does make an infinite loop with @
[01:28:33] *** Quits: MaikKlein2 (maik@moz-FD97565C.dip0.t-ipconnect.de) (Ping timeout)
[01:28:39] *** Quits: eholk (eholk@moz-192536EB.uconnect.utah.edu) (Quit: eholk)
[01:28:44] <dbaupp> rusti: let x = @mut None; let y = @x; *x = Some(y); x
[01:28:45] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/RRFB
[01:29:01] <dbaupp> rusti: let x = @mut None; let y = @x; *x = Some(@y); x
[01:29:03] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/ESKG
[01:29:48] <dbaupp> rusti: struct Foo { x: Option<@mut Foo> } let foo = @mut Foo { x: None }; foo.x = Some(foo); foo
[01:29:49] -rusti- application terminated abnormally with signal 9 (Killed)
[01:29:52] *** sam113101 is now known as sam113101_afk
[01:30:11] <engla> success
[01:30:18] <strcat> [ 9844.771560] Task in /playpen/5951 killed as a result of limit of /playpen/5951
[01:30:20] <strcat> [ 9844.771561] memory: usage 131072kB, limit 131072kB, failcnt 56
[01:30:28] *** sam113101_afk is now known as sam113101
[01:30:57] *** Quits: heftig (heftig@6835D69C.6FC4DE2F.FEC4A986.IP) (Ping timeout)
[01:31:52] <aatch> strcat, heh.
[01:32:10] <doomlord_> heh. using #define fn auto in c++ and trailing return types, some grep/sed can generate prototypes :) i'm sure it'll run into some corner cases though
[01:32:33] <ChrisMorgan> dbaupp: so, you reckon the regression I'm experiencing came in somewhere in that time; any idea if I can help to identify it, or will it already be being identified?
[01:33:08] <dbaupp> ChrisMorgan: yup, git-bisect to find the pull request(s) that caused it.
[01:33:18] * dbaupp wishes we had a bench server
[01:33:42] <ChrisMorgan> That will take rather a long time :-(
[01:34:09] <Eridius> what's the default visibility right now for items that don't specify?
[01:34:27] <dbaupp> ChrisMorgan: :(
[01:34:30] <strcat> Eridius: priv for almost everything
[01:34:31] <ChrisMorgan> I don't know how the snapshot system works; is it possible to download snapshots and use them to compile it and check perf?
[01:34:39] <strcat> Eridius: public structs have public fields by default
[01:34:42] <Eridius> strcat: ok, that's what I thought
[01:34:53] <dbaupp> ChrisMorgan: snapshots only happen every few weeks, so they aren't regular enough
[01:35:07] <dbaupp> ChrisMorgan: strcat's nightly builds are the best we've got
[01:35:16] <ChrisMorgan> I'd pictured them being made more frequently than that.
[01:35:18] <Jesse> strcat: should stringify be changed to avoid blowing up on cyclic objects?
[01:35:26] <strcat> stringify?
[01:35:33] <ChrisMorgan> strcat: what platform/s do your nightly builds get made for?
[01:35:36] <dbaupp> ChrisMorgan: oh, and http://thread.gmane.org/gmane.comp.lang.rust.devel/4829
[01:35:38] <Eridius> strcat: are statics also priv?
[01:35:45] <dbaupp> Eridius: yes
[01:35:49] *** Quits: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net) (Ping timeout)
[01:35:52] <strcat> ChrisMorgan: arch linux, although they might run anywhere with an up-to-date glibc+libstdc++
[01:36:07] <dbaupp> Jesse: stringify is a macro that prints a token tree... do you mean fmt!?
[01:36:26] <Jesse> yeah i mean fmt!
[01:36:28] <strcat> ChrisMorgan: http://pkgbuild.com/~thestinger/repo/x86_64/ that's the latest
[01:36:32] <aatch> (There's a bug open about it traversing cycles)
[01:36:35] *** Joins: xLII (xLII@A6038EAF.BEC20239.F5CC85D7.IP)
[01:36:36] *** Quits: qmx (qmx@moz-D6C3C2E6.qmx.me) (Ping timeout)
[01:36:52] *** Joins: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net)
[01:36:57] <strcat> pkgbuild.com doesn't have enough space for me to keep a long history of them there though (don't know what my home dir's quota actually is)
[01:37:21] *** Joins: qmx (qmx@moz-D6C3C2E6.qmx.me)
[01:38:01] <aatch> https://github.com/mozilla/rust/issues/3768
[01:38:03] <strcat> Jesse: fmt! should be able to keep track of that
[01:38:16] <aatch> ^^ That's the bug, btw
[01:39:02] <strcat> it's non-trivial in the presence of a moving gc though ;p
[01:40:14] *** Quits: xLII (xLII@A6038EAF.BEC20239.F5CC85D7.IP) (Connection reset by peer)
[01:40:55] <Jesse> in JS land the answer would be WeakMap. does Rust have something like WeakMap?
[01:41:02] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[01:41:05] <dbaupp> strcat: presumably fmt! could just borrow @[mut], which would keep it still, right?
[01:41:30] <strcat> yeah I guess so, anyway not something we have to worry about yet
[01:42:01] *** Joins: xLII (xLII@A6038EAF.BEC20239.F5CC85D7.IP)
[01:42:02] *** Quits: xLII (xLII@A6038EAF.BEC20239.F5CC85D7.IP) (Connection reset by peer)
[01:44:21] *** Quits: jclements (jclements@moz-98A7BA64.ngn.east.myfairpoint.net) (Quit: jclements)
[01:45:48] *** Joins: ross (ross@moz-8A84103E.br.br.cox.net)
[01:45:54] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: Places to go, people to annoy)
[01:46:11] <ChrisMorgan> strcat: tried using your build, "bin/rustc: error while loading shared libraries: libstd-6c65cf4b443341b1-0.8-pre.so: cannot open shared object file: No such file or directory" - any idea how I can tell it "look in lib, it's there!"
[01:47:11] *** Joins: jclements (jclements@moz-98A7BA64.ngn.east.myfairpoint.net)
[01:47:12] <strcat> ChrisMorgan: well it's meant to be installed globally so it expects them to be in the library path
[01:47:19] <strcat> you could just set LD_LIBRARY_PATH temporarily
[01:47:43] <ChrisMorgan> Ah, that's it. Thanks.
[01:47:54] * ChrisMorgan isn't familiar with such things
[01:48:08] <strcat> the linker has hardcoded paths and then there's /etc/ld.so.conf and /etc/ld.so.conf.d/
[01:48:10] *** tikue is now known as tikue_dinner
[01:48:19] *** Quits: tikue_dinner (tkuehn@moz-BBE3ABD.mv.mozilla.com) (Quit: tikue_dinner)
[01:48:27] <strcat> and 'ldconfig' looks through the dirs and makes a cache (/etc/ld.so.cache)
[01:48:50] <strcat> package managers will just drop files in /usr/lib and run ldconfig at the end
[01:48:55] *** Quits: jclements (jclements@moz-98A7BA64.ngn.east.myfairpoint.net) (Quit: jclements)
[01:49:28] *** Joins: Guest__ (textual@moz-E64A54F3.nyc.res.rr.com)
[01:51:29] *** Quits: Guest__ (textual@moz-E64A54F3.nyc.res.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzz‚Ä¶)
[01:52:03] <ChrisMorgan> strcat: your rust-git-0.7.780.g8990f8b-1-x86_64.pkg.tar.xz gets similar perf characteristics to my rust build.
[01:52:24] <strcat> heh it actually works :)
[01:52:36] <strcat> I guess libstdc++ does have a stable abi
[01:52:42] * strcat didn't consider that
[01:52:56] <Jesse> rusti: struct T { a: Option<@T>, b: Option<@T> } let mut x = @T {a: None, b: None}; for 5.times { x = @T {a: Some(x), b: Some(x) }; } x
[01:52:58] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/REHG
[01:53:04] <ChrisMorgan> How do I apply the delta (in reverse, I guess) to go backwards?
[01:53:17] <Jesse> strcat: should fmt! protect against exponential blowup or only infinite blowup?
[01:53:33] <strcat> ChrisMorgan: dunno ;], pacman does it for me
[01:53:38] <strcat> ChrisMorgan: there are only 3 days of those though
[01:54:01] <ChrisMorgan> strcat: and that *may* be enough.
[01:54:01] <strcat> Jesse: it shouldn't traverse things it has already visited
[01:54:16] <strcat> ChrisMorgan: they're from xdelta3 though
[01:54:55] <strcat> ChrisMorgan: I could just upload others for you
[01:55:02] <strcat> I have them locally
[01:55:14] <ChrisMorgan> I can easily enough install xdelta3
[01:55:22] *** Quits: jasom (aidenn@moz-5F6FC7B3.sb.sd.cox.net) (Ping timeout)
[01:55:33] <strcat> july 3rd through july 23rd is what I
[01:55:36] <strcat> I've kept*
[01:55:44] <strcat> every day since 0.7 was released
[01:56:03] *** Quits: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net) (Ping timeout)
[01:56:12] <ChrisMorgan> And I think my last build was from 18th/19th, just after decopy.
[01:57:07] *** Joins: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net)
[01:59:27] <ChrisMorgan> Hmm... seems like xdelta3 doesn't actually support reversing a delta. :-(
[01:59:47] <strcat> ChrisMorgan: https://paste.xinu.at/AjsGj/ there's from the 10th
[02:00:20] <strcat> anyway arch's pkg format is nice and simple ;p, just a directory tree + .PKGINFO and .INSTALL
[02:00:34] <strcat> oh and the weird mtree thing for comparing mtime/hashes
[02:01:07] *** Joins: jclements (jclements@moz-98A7BA64.ngn.east.myfairpoint.net)
[02:01:21] <strcat> ChrisMorgan: yeah I don't really know how pacman applies them
[02:01:38] <strcat> but they're only applied in the forwards direction
[02:01:45] <ChrisMorgan> It works forwards, but not backwards.
[02:01:50] <strcat> ah
[02:01:57] <strcat> didn't realize it actually wasn't reversible
[02:02:13] <strcat> it's really terrible anyway
[02:02:22] <strcat> they are barely better than the whole pkg
[02:02:54] <strcat> they're better on things that aren't rust ;p, rustc adds a lot of randomization
[02:02:56] <strcat> from hash tables
[02:04:20] <sp3d> Chrome's delta compression scheme for updates to their binaries is very cool
[02:06:09] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[02:06:51] <ChrisMorgan> strcat: that build from the 10th is only showing the <10% perf win, not the everything-is-three-times-as-fast-again :-(
[02:07:16] *** Joins: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net)
[02:07:27] <strcat> ChrisMorgan: could it be some system change?
[02:07:30] *** Quits: Houm (Houm@moz-25669AA8.fbx.proxad.net) (Ping timeout)
[02:07:34] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[02:07:51] <strcat> ChrisMorgan: it seems weird that I'd be getting ~5k/s and you're getting ~700
[02:08:03] * strcat just has a recent dual core cpu in this laptop
[02:08:15] *** Joins: Houm (Houm@moz-25669AA8.fbx.proxad.net)
[02:08:18] <ChrisMorgan> strcat: this laptop _is_ over 7 years old
[02:08:27] <strcat> heh
[02:08:32] <ChrisMorgan> strcat: the system has been rebooted, but I don't believe there was anything which changed in that.
[02:08:42] *** Quits: echristo (echristo@DCF57675.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[02:09:13] <ChrisMorgan> Had to be rebooted or at least the session restarted as that died...
[02:09:44] * ChrisMorgan likes being able to still access a terminal in such cases, to trigger a clean reboot
[02:11:16] <ChrisMorgan> It's still running the same kernel as it was before, at least.
[02:11:19] <strcat> ChrisMorgan: you can actually do that with the sysrq key combination too if you have it enabled
[02:11:50] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz‚Ä¶)
[02:11:50] <ChrisMorgan> strcat: that ain't a proper reboot, that's just a make-it-safe-before-killing-it-at-system-level reboot
[02:12:14] <strcat> it's not that bad though
[02:12:16] * ChrisMorgan has used the Alt+SysRq+REISUB sequence a few times
[02:12:21] <strcat> SIGTERM + sync + unmount
[02:12:36] <strcat> clean enough! that's essentially what the init system will do
[02:12:56] <strcat> stop services, SIGTERM everything else, SIGKILL on timeout (rarely happens), umount
[02:14:17] *** Joins: brson (brson@moz-F35A8539.hsd1.or.comcast.net)
[02:14:18] *** ChanServ sets mode: +o brson
[02:14:49] <bblum> brson: how's the wizard of os con?
[02:15:35] <bblum> brson: select is ready but i haven't figured out the assertion business yet. sharedport continues to look fine to me.
[02:17:01] <ChrisMorgan> strcat: can't see any upgrades that have been done which should have any effect on performance.
[02:17:17] <kemurphy> graydon: you around?
[02:20:49] *** Joins: scroy (roy@moz-F152D5C3.washdc.fios.verizon.net)
[02:21:07] <scroy> what is the point of a vec::same_length function?
[02:21:44] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[02:21:59] <strcat> scroy: not much
[02:22:10] <strcat> it's just xs.len() == ys.len()
[02:22:39] <scroy> yeah, i'm looking at it and wondering
[02:22:47] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[02:22:49] <dbaupp> it looks like it may be from pre-2012
[02:23:05] <scroy> maybe some workaround for an old problem?
[02:23:05] <kimundi> damn, that'o ancient
[02:23:07] <strcat> so... typestate?
[02:23:28] <dbaupp> https://github.com/mozilla/rust/commit/fa9ad984fb2f013baebdbe01a42baa3b9101dd84#L98R55
[02:24:05] *** Joins: xLII (xarch@A6038EAF.BEC20239.F5CC85D7.IP)
[02:24:26] *** Quits: Earnestly (earnest@2AB30F53.FB5005.2BCC804A.IP) (Ping timeout)
[02:26:49] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[02:27:12] *** Quits: dsirenko (mitra@8E712A0.54C21BA0.9F317420.IP) (Ping timeout)
[02:27:33] *** Joins: dsirenko (mitra@8E712A0.54C21BA0.9F317420.IP)
[02:28:46] <dbaupp> fwiw, https://github.com/mozilla/rust/commit/268533a92055200a1b6a8bdbd916d620fa8306eb#L1R259 (almost 2 years ago now)
[02:31:42] <scroy> are there still constraints like that?
[02:31:56] <scroy> is that still part of the language?
[02:32:59] <dbaupp> no, typestate was removed
[02:33:11] * dbaupp wasn't around then so doesn't know why
[02:34:54] <doy> from what i understand from reading blog posts, having to manually annotate everything like that was just too unworkable - every time you came up with a new predicate, you had to go back through and reannotate everything or else that predicate wouldn't really be worthwhile
[02:35:11] *** Joins: dew (Instantbir@moz-2C6F2E2.dhcp.stls.mo.charter.com)
[02:35:13] <scroy> makes sense
[02:36:10] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[02:40:18] *** Quits: aatch (aatch@moz-B437F499.pocketrent.com) (Ping timeout)
[02:40:49] <scroy> what is this syntax? size_of::<T>() the scope followed by type param's
[02:41:22] *** Quits: qmx (qmx@moz-D6C3C2E6.qmx.me) (Ping timeout)
[02:41:29] <scroy> s/param's/params
[02:41:34] *** Joins: aatch (aatch@moz-B437F499.pocketrent.com)
[02:41:49] <kemurphy> scroy: generic method that doesn't infer type from params or return value
[02:42:34] <scroy> ah. why is it explicit?
[02:43:01] <scroy> shouldn't the compiler be able to deduce those cases?
[02:43:04] <strcat> because size_of can't infer from anything, it doesn't have params
[02:43:16] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[02:44:29] *** Quits: jfbk (textual@moz-EEA9CFB3.nyc.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzz‚Ä¶)
[02:44:32] <scroy> but if it can't be inferred, then not providing the type would be an error anyway
[02:44:38] <scroy> ..right?
[02:45:08] <dbaupp> scroy: yeah... but and so how would one specify the type without ::<T>()?
[02:45:17] <dbaupp> s/but //
[02:45:41] <scroy> dbaupp: that's not what i mean. it has to be provided, but i don't see why the special syntax is needed
[02:46:10] <sp3d> if you didn't have the trailing ::, it would be a lookup of a non-callable thing in that namespace and then compare it with less-than
[02:46:28] <dbaupp> scroy: oh, so you're saying `size_of<T>()`?
[02:46:40] <scroy> dbaupp: right
[02:47:10] <kemurphy> i'm guessing to keep the parser from being context-sensitive
[02:47:15] <dbaupp> scroy: yeah, it's grammar concerns: any time you want to annotate a value with a type, the `::<` tells Rust that what follows is a type
[02:47:16] <scroy> sp3d: i see.. so type params are always inferred
[02:47:23] <kemurphy> LL(1) is a goal, i think?
[02:47:38] <scroy> man... why on earth does Rust use angle brackets?
[02:47:49] <dbaupp> if it was `foo<T>(a)`, then that could be parsed as either a type annotation or `(foo < T) > a`
[02:48:23] <kemurphy> scroy: .... what else would it use?
[02:48:36] <scroy> didn't everyone agree it was a bad idea after C++ (where templates admittedly make it much more complicated)
[02:49:14] *** Joins: qmx (qmx@moz-D6C3C2E6.qmx.me)
[02:49:17] <scroy> kemurphy: scala and D came up with better solutions
[02:50:23] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[02:50:46] <kemurphy> scroy: "better" is subjective, i think
[02:50:47] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[02:50:50] <kemurphy> i'm not a fan of D's approach
[02:51:30] <kemurphy> i mean, it works, but it isn't always clear what is happening because they share the foo!(T) syntax with macros
[02:51:43] <kemurphy> (this also leads to a context sensitive parser, which rust doesn't want)
[02:51:48] <SiegeLord> D uses !() and Rust uses ::<>... they seem pretty identical as far as needing an extra token
[02:51:52] *** Quits: jclements (jclements@moz-98A7BA64.ngn.east.myfairpoint.net) (Quit: jclements)
[02:52:00] <scroy> kemurphy: D has a context free grammar
[02:52:05] <doy> scala's only really works because they use () for indexing
[02:52:15] <scroy> doy: i really like that solution actually
[02:52:34] <SiegeLord> The only issue is how to deal with >>, and I'm not 100% sure how Rust handles it
[02:52:37] <scroy> doy: why not, after all vectors are analogous to function application
[02:52:38] <doy> scroy: yeah, it is nice in its own way, but that's getting a bit far from what people are used to
[02:52:40] <kemurphy> scroy: maybe with a few token lookahead, sure
[02:52:52] <dbaupp> SiegeLord: what's the problem?
[02:53:28] <SiegeLord> dbaupp: In C++ blah<blah<blah>> wasn't legal for the longest time because >> was parsed as a right shift
[02:53:41] <scroy> SiegeLord: i don't think rust has that problem
[02:53:42] <SiegeLord> Somehow it was solved in C++11, I bet it's ugly :P
[02:53:54] *** Quits: Houm (Houm@moz-25669AA8.fbx.proxad.net) (Ping timeout)
[02:53:54] <kemurphy> scroy: you can't know whether foo!( is about to lead to a macro invocation or a template instantiation until you parse the thing after it and figure out if it's a value or a type name
[02:54:11] <SiegeLord> scroy: I wouldn't be so sure about that, I've seen discussions about it quite recently
[02:54:13] <dbaupp> SiegeLord: oh! yeah, I don't think that's at all a problem, because the type grammar is distinct to the expression grammar, and the `::<` indicates when to switch
[02:54:20] <dbaupp> (I think.)
[02:54:34] <strcat> dbaupp: well.. the solution is likely really ugly
[02:54:43] <strcat> fyi C++ can't be tokenized and parsing requires type checking :)
[02:54:46] <kemurphy> scroy: i can confirm the opposite, rust suffers from the >> problem
[02:54:47] <scroy> kemurphy: what do you mean by macro?
[02:54:48] <dbaupp> strcat: for Rust?
[02:54:52] <strcat> dbaupp: for C++
[02:54:58] <strcat> dbaupp: it type checks in order to parse
[02:55:04] <dbaupp> strcat: I know that
[02:55:10] <strcat> so afaik they took advantage of that to solve the >> thing
[02:55:11] <dbaupp> strcat: I was talking only about Rust.
[02:55:13] <strcat> ah
[02:55:30] <kemurphy> scroy: printfln!( for example
[02:55:40] <strcat> alright bors needs help
[02:55:51] <dbaupp> kemurphy: example of the >> problem in Rust?
[02:55:54] <scroy> kemurphy: that is a template in D (writefln actually)
[02:56:07] <kemurphy> er, yeah, writefln
[02:56:19] <kemurphy> well, a different kind of template
[02:56:19] *** Joins: kimundi_ (kimundi@moz-1DB2C6D0.dip0.t-ipconnect.de)
[02:56:26] *** Quits: kimundi (kimundi@moz-5EAC7DE2.dip0.t-ipconnect.de) (Ping timeout)
[02:56:26] *** kimundi_ is now known as kimundi
[02:56:31] <scroy> kemurphy: or no.. actually it's just a function in D
[02:56:34] <scroy> but i see what you mean
[02:56:36] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[02:56:58] <SiegeLord> It is in fact a (variadic) template in D :P
[02:57:01] <scroy> i'm 90% sure D's grammar is CF
[02:57:21] <kemurphy> D calls it something it isn't though, i think :P
[02:57:49] <scroy> kemurphy: D actually doesn't have a macro system yet. just mixins
[02:57:55] <kemurphy> D has some serious compile-time magic at it's disposal
[02:58:01] <kemurphy> ah! template mixin was the phrase i was looking for
[02:58:07] <SiegeLord> It's not that
[02:58:11] <kemurphy> oh, isn't it?
[02:58:13] <SiegeLord> writefln is a variadic template
[02:58:26] <kemurphy> but... it doesn't take typenames, it takes values
[02:58:34] <scroy> kemurphy: both
[02:58:46] *** Joins: vodik (simon@moz-CBE4BB13.cable.teksavvy.com)
[02:58:47] <kemurphy> which makes it hard to call it a template (even though they do)
[02:58:53] <kemurphy> i just don't like D's terminology i guess
[02:58:55] <SiegeLord> So does C++ :P
[02:59:03] <SiegeLord> Which also has variadic templates these days
[02:59:18] <scroy> D's basically just expand on C++'s
[02:59:32] <kemurphy> *shrug*
[02:59:45] <strcat> well C++ has enable_if, variadic templates, static_assert and a more limited form of constexpr now
[02:59:47] *** Quits: brson (brson@moz-F35A8539.hsd1.or.comcast.net) (Ping timeout)
[02:59:52] <strcat> although with C++14 it becomes a lot less limited
[03:00:03] <kemurphy> dbaupp: one sec, lemme write up an example
[03:00:05] <SiegeLord> In D it basically considers the arguments to be a tuple, and the type of that template is the type of the tuple
[03:00:06] <scroy> anyway, i think the <> syntax is the most unappealing thing about rust for me so far
[03:00:33] <scroy> i was praying it would be changed but i guess its stuck now
[03:00:49] <doy> what's bad about it?
[03:01:06] <sp3d> "::<" looks ugly
[03:01:15] <SiegeLord> I kind of like it, having used D... you get lost in parentheses in D
[03:01:20] <scroy> doy: for one thing, emacs won't treat as a s-expresion without some serious hacks
[03:01:40] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[03:01:49] <doy> treat what as a s-expression?
[03:01:49] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[03:01:58] <dbaupp> doy < >
[03:01:58] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[03:01:59] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/g_zt3g
[03:01:59] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[03:02:08] <dbaupp> strcat: bors seems to be going fine?
[03:02:13] <scroy> c++-mode has said hack, now rust-mode needs it
[03:02:15] <strcat> dbaupp: I mean a rollup PR
[03:02:29] <dbaupp> strcat: oic
[03:02:41] <erickt> nmatsakis: did I miss you?
[03:02:48] <scroy> same goes for the stupid ruby | ... |
[03:03:00] <scroy> except that's even worse in a way...
[03:03:08] <vodik> so why not get emacs fixed then?
[03:03:25] <SiegeLord> Doesn't rust have | | in the same place ruby does?
[03:03:27] <dbaupp> scroy: Rust has || too... ;P
[03:03:44] <scroy> dbaupp: yeah.. don't remind me
[03:04:05] <scroy> vodik: ah, a vim user appears.
[03:04:25] <scroy> vodik: at least, i know you're on Arch, so i assume as much
[03:04:33] <kemurphy> dbaupp: woah, looks like >> has actually been fixed
[03:04:52] <dbaupp> kemurphy: awesome! :)
[03:04:55] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[03:04:55] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/HPL0pA
[03:04:55] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[03:04:56] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[03:04:56] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/KZcoaw
[03:04:56] <ghrust> 13rust/06auto 1464ff30a 15Kevin Murphy: Add link_section attribute for static and fn items...
[03:04:56] <ghrust> 13rust/06auto 14c6c1472 15Kevin Murphy: Add simple link_section test to exercise it
[03:04:57] <ghrust> 13rust/06auto 14af78e23 15bors: auto merge of #7958 : kemurphy/rust/link-section, r=alexcrichton...
[03:04:59] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[03:05:06] <vodik> wow, first line in #rust and i have a repulation that proceeds me
[03:05:08] <kemurphy> \o/
[03:05:13] <scroy> sigh. ok enough ranting from me
[03:05:21] <SiegeLord> I thought the issue was that it made the grammar complicated
[03:05:29] <SiegeLord> Not that it wasn't fixable per se
[03:05:40] <dbaupp> kemurphy: did you end-up talking with graydon about it yet?
[03:05:58] <dbaupp> (it being `#[link_section=..]`)
[03:06:14] <SiegeLord> Another thing like that is &&... I'm still not sure why that's always boolean and :P
[03:06:33] <scroy> walk tall, vodik
[03:06:53] <kemurphy> dbaupp: no, i have sent ping and am waiting on pong
[03:06:58] <vodik> scroy: heh, thanks
[03:07:25] <dbaupp> SiegeLord: because bugs, I guess
[03:07:38] <xLII> could someone tell me how to cast a c string (*uint) into &str ?
[03:07:38] <SiegeLord> dbaupp: You never know with these things
[03:07:50] *** Joins: erickt2 (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[03:08:01] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[03:08:04] <dbaupp> SiegeLord: https://github.com/mozilla/rust/issues/7837
[03:08:11] <strcat> xLII: a null-terminated byte array? (I guess you mean *i8 or *u8?)
[03:08:28] <strcat> a slice is just (ptr, length)
[03:08:30] <SiegeLord> dbaupp: Ah, lol... fair enough. Recent too, hehe
[03:08:44] <strcat> so it would be easy to make one if you want to avoid a copy
[03:09:08] <dbaupp> xLII: there's from_buf, I think.
[03:09:29] <xLII> a byte array with \0 at the end
[03:09:30] *** Quits: erickt2 (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[03:09:45] <dbaupp> xLII: yeah, str::raw::from_buf
[03:09:46] <strcat> dbaupp: probably copies though
[03:09:51] <strcat> depends on what you want
[03:09:55] <xLII> dbaupp:let me have a try
[03:09:58] <dbaupp> strcat: right, it does :/
[03:10:03] <strcat> if you don't want to copy you can just use strlen and convert to &str
[03:10:07] * dbaupp dislikes str::raw
[03:10:10] <strcat> (ptr, strlen(ptr))
[03:10:16] <strcat> transmute to &str
[03:10:43] <kemurphy> is bors confused at the moment?
[03:10:55] <xLII> yes,it works!
[03:10:57] <xLII> thanks
[03:11:05] <xLII> :-)
[03:11:11] <kemurphy> https://github.com/mozilla/rust/pull/8000 got r+ 11 hours ago and bors hasn't seen it yet
[03:11:43] <acrichto_> kemurphy: it's unmergeable (needs a rebase)
[03:11:43] <engla> kemurphy: the queue is here http://buildbot.rust-lang.org/bors/bors.html
[03:11:56] <dbaupp> kemurphy: you got 8000!
[03:12:17] <kemurphy> acrichto_: ah, i see. where would i look to figure that out in the future?
[03:12:20] <kemurphy> engla: cool, thanks
[03:12:23] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[03:12:33] <strcat> graydon: still around? is mac4 supposed to be down?
[03:12:41] <strcat> graydon: seems there aren't enough mac builders atm
[03:12:42] <kemurphy> dbaupp: yeah, lucky me i guess
[03:12:44] <dbaupp> strcat: I turned it off because of bugs
[03:12:46] <strcat> dbaupp: ah
[03:12:50] <strcat> which?
[03:13:00] <acrichto_> kemurphy: on the buildbot status page the PR is yellow instead of blue/gree/white
[03:13:01] <dbaupp> strcat: https://github.com/mozilla/rust/issues/7995
[03:13:11] <dbaupp> strcat: same one as a last time
[03:13:12] <acrichto_> kemurphy: unfortunately github doesn't appear to tell you automatically...
[03:13:28] <dbaupp> kemurphy: (it only tells people who have commit access to the repo, it seems.)
[03:13:42] <acrichto_> kemurphy: and by buildbot status page I mean bors status page
[03:14:31] <dbaupp> kemurphy: does #8000 allow u8 discriminants?
[03:17:02] *** Quits: LU324 (stuff@moz-A17E9A7B.dyn.embarqhsd.net) (Ping timeout)
[03:17:29] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[03:20:01] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[03:20:52] *** Quits: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP) (Client exited)
[03:20:57] <mark_edward> does Rust have atomics
[03:21:05] <scroy> ok i've got it. behold: sys::size_of„ÄåT„Äç
[03:21:26] *** Quits: Jesin (Jessin_@moz-1B1307FF.eecs.lehigh.edu) (Quit: Leaving)
[03:22:07] <dbaupp> mark_edward: yes
[03:22:12] <erickt> graydon: ping
[03:22:32] <dbaupp> scroy: the `::` path separator is pretty ugly too
[03:22:33] <mark_edward> dbaupp: where are they an how do you use them?? why would you use them if every taaask is isolated?
[03:22:46] <scroy> that is: unicode 0x300c and 0x300d, LEFT CORNER BRACKET and RIGHT CORNER BRACKET
[03:22:56] <strcat> mark_edward: because you can still use unsafe code to implement low-level building blocks
[03:23:04] <kemurphy> dbaupp: it should, though they will still be 64-wide :(
[03:23:05] <dbaupp> mark_edward: `unsafe mut` would be a reasonable place to use them
[03:23:11] <mark_edward> strcat: ah, i see
[03:23:13] <kemurphy> dbaupp: (working on changing that as we speak though)
[03:23:17] <mark_edward> dbaupp: ah, i see again
[03:23:26] <strcat> rusti: static mut x: int = 5; unsafe { x }
[03:23:27] -rusti- 5
[03:23:28] <dbaupp> mark_edward: I tihink it's std::unstable somewhere
[03:23:35] <dbaupp> *think
[03:23:37] <scroy> unambiguous, real parenthetical-type characters, and a great way to bring Rust into the international programming world of the 21st century!
[03:23:38] <mark_edward> thanks for the info!
[03:23:51] <scroy> who's with me?
[03:23:56] <scroy> dbaupp: working on it!
[03:24:10] <dbaupp> scroy: totally reasonable! (you're shipping the unicode keyboard I ordered, soon, right?)
[03:24:25] <SiegeLord> scroy: I like ¬´ and ¬ª more, easier to type with the compose key
[03:24:47] <scroy> dbaupp: as soon as i finish putting on the last 5,000 chinese characters
[03:24:53] <scroy> by hand
[03:25:39] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[03:25:42] <scroy> SiegeLord: good point. even closer to <> is the brackets used in IPA transcriptions, forget what they're called...
[03:26:02] <kimundi> what we really need is backwards c-like trigrams
[03:26:14] <dbaupp> scroy: am I getting the BMP version or the full BMP/SMP/SIP one?
[03:26:22] <strcat> scroy: the french angle quotes?
[03:26:34] <kimundi> foo::<> as the long form of foo¬´T¬ª or so
[03:27:00] <dbaupp> kimundi: editor support gives you that
[03:27:01] <kemurphy> acrichto_: okay, i've rebased locally. git push -f?
[03:27:05] *** Joins: Jesin (Jessin_@moz-1B1307FF.eecs.lehigh.edu)
[03:27:10] <dbaupp> kemurphy: yes
[03:27:25] <mark_edward> where is the main function for rustc located?
[03:27:32] <acrichto_> kemurphy: yeah
[03:27:34] <dbaupp> mark_edward: rustc.rs
[03:28:09] <kemurphy> acrichto_: oops, forgot to add -1 test, don't r+ that yet
[03:28:16] <scroy> strcat: i believe so
[03:28:22] <kimundi> Or how about miving it up a bit? size_ofŒîuint‚àá()
[03:28:28] <dbaupp> mark_edward: (although it's not really the main function. stc/driver/driver.rs imports each lib separately and calls the main function to create the actual binaries.)
[03:28:45] <dbaupp> *src
[03:28:46] <mark_edward> i see...
[03:28:49] <acrichto_> dbaupp: use std::unstable::raw::RawRepr; seems like it has one too many 'raw's
[03:28:58] *** Joins: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net)
[03:29:06] <acrichto_> dbaupp: but I like the idea of having 'Repr' somewhere in it
[03:29:08] <mark_edward> dbaupp: is librustc available to use as a lib in rust code?
[03:29:09] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[03:29:11] <dbaupp> acrichto_: how often will that happen?
[03:29:16] <dbaupp> mark_edward: yeah
[03:29:22] <mark_edward> cool
[03:29:24] <acrichto_> dbaupp: if you ever want to use the method you have to have that
[03:29:29] <scroy> dbaupp: i'll just give you a gigantic keyboard sphere with space for all (googling...) 109,384 code points
[03:29:42] <dbaupp> mark_edward: https://github.com/cmr/rustdoc_ng/blob/master/main.rs#L62
[03:30:00] <dbaupp> acrichto_: yeah, I mean, how often will one actually want to call that method?
[03:30:07] *** Quits: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[03:30:30] <dbaupp> acrichto_: it seems like something that will only happen in str/vec and user code that's pushing for the utmost performance
[03:30:49] <acrichto_> dbaupp: well it should be *the* method for converting to a raw representation, which shouldn't happend that often 
[03:31:30] <strcat> acrichto_: btw it would be nice to make clear that VecRepr is only for @[] and managed-unique
[03:31:44] <strcat> unique is UnboxedVecRepr
[03:31:46] <dbaupp> acrichto_: yeah, I'm happy with whatever, but I think `Equivalent` is pretty bad, and anything not mentioning something along the lines of `Raw` and `Repr` isn't great.
[03:31:52] *** Quits: int3_ (int3_@moz-7B0110AD.mv.mozilla.com) (Client exited)
[03:32:06] <acrichto_> strcat: VecRepr went away, now it's explicitly Box<Vec<T>> or Vec<T> for the two cases
[03:32:11] <strcat> acrichto_: ah
[03:32:20] <acrichto_> dbaupp: yeah I agree
[03:32:40] <acrichto_> strcat: are headers slated for removal on managed-unique vectors?
[03:32:47] <strcat> acrichto_: not really
[03:32:58] <acrichto_> aww
[03:32:58] <strcat> gc would need to land before removing @ and managed-unique headers
[03:33:07] <strcat> and @mut headers would stay, at least a byte
[03:33:28] <acrichto_> why does ~[@T] need headers on the vector?
[03:33:39] <strcat> acrichto_: ~[@T] is managed
[03:33:44] <acrichto_> but why?
[03:33:49] <acrichto_> it's treated as an owned value in the compiler?
[03:33:50] <mark_edward> dbaupp: can rustc compile to stdout?
[03:33:51] <strcat> acrichto_: because it roots the @T
[03:34:02] <strcat> acrichto_: it's not really treated as owned
[03:34:11] <acrichto_> it's not implicitly copyable though?
[03:34:15] <dbaupp> mark_edward: compile to stdout? i.e. print a binary 
[03:34:24] <strcat> acrichto_: semantically it acts like ~[]
[03:34:26] <mark_edward> dbaupp: yeah
[03:34:28] <strcat> deterministic destruction
[03:34:29] <tcsc> if i have a mut [T, .. N], is there any way for me to pass it to a function expecting a &mut [T]?
[03:34:32] <strcat> move semantics
[03:34:34] <dbaupp> mark_edward: `rustc -o /dev/stdout ... ` probably works
[03:34:40] <dbaupp> tcsc: it should just work
[03:34:59] <acrichto_> strcat: yeah, but then why does it need headers? wouldn't the destructor just decrement the reference count of all objects?
[03:35:06] <strcat> acrichto_: not about the refcount
[03:35:10] <dbaupp> rusti: fn foo(_: &mut [int]) {} let mut x = [0, .. 5]; foo(x) // tcsc
[03:35:10] <strcat> acrichto_: the header has 4 parts
[03:35:11] -rusti- ()
[03:35:21] <strcat> acrichto_: refcount, tydesc, next/prev ptrs for cleaning cycles
[03:35:22] <tcsc> dbaupp: it tells me expected `&mut [u8]` but found `&mut [u8, .. 100]` (expected vector but found &-ptr)
[03:35:32] <strcat> acrichto_: managed-unique needs 3 of those directly
[03:35:41] <strcat> acrichto_: + it needs the ref_count field to *distinguish* it from @
[03:35:41] <dbaupp> rusti: fn foo(x: &mut [int]) { x[0] = 1; } let mut x = [0, .. 5]; foo(x); x
[03:35:42] -rusti- [1, 0, 0, 0, 0]
[03:35:52] *** Joins: int3_ (int3_@moz-7B0110AD.mv.mozilla.com)
[03:36:00] <acrichto_> strcat: but ~[@T] has a deterministic destruction location so it can't be in the middle of cycles
[03:36:02] <dbaupp> tcsc: ^, it gets coerced automatically, so you don't need the &mut
[03:36:02] <strcat> acrichto_: keep in mind when types are added to the cleanup list, their type has to be recorded somewhere (the tydesc)
[03:36:16] <tcsc> dbaupp: ah, yeah. thanks
[03:36:27] <strcat> acrichto_: it can be inside @ though.
[03:36:35] <mark_edward> dbaupp: error: Could not write output: Error opening output file '/dev/stdout.o'
[03:36:39] <strcat> acrichto_: if it is inside @ and contains @, there can be cycles
[03:36:40] <acrichto_> strcat: well so can ~T
[03:36:48] <strcat> acrichto_: ~T can't have cycles if it's not managed
[03:36:50] <dbaupp> mark_edward: haha, I don't know.
[03:36:54] <strcat> acrichto_: cycles determine the order it has to free stuff
[03:37:02] <strcat> libstd/cleanup.rs
[03:37:09] <dbaupp> mark_edward: (why on earth are you printing a binary though?)
[03:37:15] <acrichto_> strcat: but ~@T doesn't have headers on the ~ pointer?
[03:37:22] <strcat> acrichto_: it has headers
[03:37:31] <strcat> managed-unique (vectors or pointers) have 4-word headers
[03:37:43] <strcat> non-managed unique are free of headers, unique strings are never managed
[03:37:50] <mark_edward> just out of curiousity. i wonder if you could make rustc compile, capture the output, then dynamically load it as a library, in a rust program
[03:38:01] <strcat> acrichto_: when there *is* a gc, the gc will have this metadata externally
[03:38:06] <strcat> so the headers will be redundant and can be removed
[03:38:12] <strcat> the space overhead will still be there, in fact more than before
[03:38:16] <strcat> significantly more
[03:38:26] <strcat> acrichto_: anything rooting @ ptrs will be managed by the gc
[03:38:29] <dbaupp> mark_edward: well, you can compile to memory (I believe that's what normal-rusti does), (right acrichto_?)
[03:38:54] <strcat> acrichto_: if you have any @, a precise gc has to deal with roots on the stack or in registers, and roots anywhere in the heap
[03:38:56] <acrichto_> dbaupp: the jit is very different from normal compilation
[03:39:03] <tcsc> mark_edward: people have been doing that for years with c code, so probably.
[03:39:11] <strcat> an @ in ~[] makes the ~[] a root
[03:39:17] <strcat> so it has to be managed on the local heap
[03:39:53] *** Quits: RMF (RMF@moz-348663EF.dsl.telepac.pt) (Ping timeout)
[03:39:53] <acrichto_> strcat: but right now there's only refcounting with no cycle collection, so these are *only* needed during annihilation/cleanup at the end of a task?
[03:40:01] <strcat> acrichto_: yes
[03:40:23] <strcat> acrichto_: the next/prev fields form the doubly-linked list for cleanup
[03:40:28] <strcat> tydesc is for getting the drop glue
[03:40:39] <strcat> ref_count for seeing if it is managed-unique or managed
[03:40:53] <strcat> managed-unique has a -2 ref_count
[03:40:54] <acrichto_> strcat: yeah now I'm seeing how cycles make it such that this is probably needed...
[03:41:05] <strcat> previously, unique had -1 and a few things read all unique ptr headers
[03:41:57] <dbaupp> strcat: fwiw, doesn't the unique box/vec always get destroyed before the annihilator runs? (unless it is in an @ itself)
[03:42:06] <cmr> aatch: are/were you able to get a bencher up and going?
[03:42:06] <strcat> dbaupp: yes
[03:42:14] <strcat> dbaupp: but it doesn't know if they're in @
[03:42:22] <strcat> dbaupp: and with a gc, it does matter that they're a root to scan from
[03:42:37] <aatch> cmr, haven't had time.
[03:42:37] <acrichto_> r? https://github.com/mozilla/rust/pull/7924 just the last commit
[03:42:48] <cmr> graydon: is there anything legalwise I need to worry about with rustdoc_ng?
[03:43:37] * dbaupp thinks we're going to run out of -Z flags on 32-bit soon
[03:43:50] <strcat> dbaupp: hm? are they bits?
[03:43:54] <strcat> in uint
[03:44:00] <dbaupp> strcat: yup, in a uint
[03:44:07] <acrichto_> well they could be a u64
[03:44:07] <cmr> strcat: yeah, disgusting, isn't it? :(
[03:44:35] <dbaupp> strcat: I guess changing this to a u64, a bitv or an "EnumSet" should just work 
[03:44:40] <cmr> dbaupp: I'm going to setup my spare box as a bencher right now then. I'll be scping results to octayn.net/benches
[03:44:43] *** Joins: RMF (RMF@5C293616.B791E6A9.8D19547B.IP)
[03:45:16] <dbaupp> strcat: (I see your point about about the gc thing, although with the current non-scanning RC, we don't actually need it, do we?)
[03:45:25] <dbaupp> cmr: same format as before?
[03:45:35] <cmr> dbaupp: yup
[03:45:37] <dbaupp> cmr: wih history.txt and commitinfo.txt etc?
[03:45:39] <cmr> yup
[03:45:47] <cmr> same exact setup, different (slower) hardware
[03:45:47] <strcat> dbaupp: well we do still need the prev/next/tydesc/ref_count fields for cleanup.rs
[03:46:12] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[03:46:24] <cmr> my ssh keys are downstairs though, so the results.. won't be there until tomorrow :p
[03:46:35] <strcat> dbaupp: if we *really* cared, we could treat managed-unique differently than managed-unique-definitely-not-containing-a-cycle
[03:46:44] <strcat> but it's not worth it
[03:46:55] <strcat> if there are provably no cycles, use Rc ;p
[03:47:20] <dbaupp> strcat: right, reading it cleanup.rs now
[03:47:26] <dbaupp> s/it //
[03:47:29] <strcat> Rc has a 1-word header for the count and doesn't make ~ containing it become managed
[03:47:38] <strcat> and it moves, so you can avoid most refcounts
[03:47:42] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[03:47:49] <dbaupp> yeah, all we need is the pointer sugar and it'll be nice
[03:48:11] <dbaupp> cmr: tomorrow = a few hours right?
[03:48:21] <cmr> ~8-9
[03:48:24] * dbaupp can't cope with timezone computations right now
[03:48:33] <dbaupp> ok
[03:49:17] <strcat> one of the few times UGT isn't enough
[03:49:49] *** Quits: xLII (xarch@A6038EAF.BEC20239.F5CC85D7.IP) (Quit: Konversation terminated!)
[03:53:36] <kemurphy> acrichto_: r? on 8000 with the negative discr test?
[03:53:41] <engla> strcat: could it be made possible to put &'a T inside RcMut?
[03:55:13] <engla> hm maybe it already is
[03:56:29] <dbaupp> rusti: let x = 1; let y = extra::rc::rc_mut_from_const(&x); fmt!("%?", y)
[03:56:34] -rusti- ~"{ptr: (0x7f54b8200900 as *())}"
[03:57:01] <strcat> Rc needs to be taught to allocate with ~ now
[03:57:41] *** Quits: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net) (Quit: gavinb)
[03:57:46] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[03:58:22] *** Quits: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net) (Ping timeout)
[03:58:44] <dbaupp> strcat: also the fixme's about `rc_from_*` being a static method are fixed (I think)
[03:59:05] *** Joins: lmandel (lmandel@moz-76CE9D51.cable.teksavvy.com)
[04:00:04] <strcat> dbaupp: https://github.com/mozilla/rust/pull/7982 what I meant by helping bors ;p
[04:00:16] *** Joins: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net)
[04:00:23] <strcat> can add a few more
[04:00:34] <strcat> just want to be careful to not add anything I can't trivially fix
[04:01:56] *** Joins: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com)
[04:02:01] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Ping timeout)
[04:02:06] <dbaupp> strcat: https://github.com/mozilla/rust/pull/7992 maybe, but that seems liable to fail
[04:02:25] *** Joins: sankha94 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[04:04:19] <strcat> dbaupp: you have to make it not run on windows afaik
[04:04:23] <strcat> xfail-fast
[04:04:29] <strcat> since it has fail
[04:05:45] <cmr> dbaupp: it'd be nice to be able to use mutliple benchers, for example my desktopcould be doing benchmarks when I'm not using it
[04:05:48] *** Quits: Nefzaoui (chatzilla@27107E87.E8FCA58B.2ED19BAB.IP) (Ping timeout)
[04:06:00] <dbaupp> strcat: https://github.com/mozilla/rust/blob/master/src/test/run-fail/explicit-fail.rs doesn't
[04:06:00] <cmr> is there any stat magicyou can do to normalize multiple data sources?
[04:06:09] <strcat> dbaupp: oh, hm
[04:06:11] <strcat> dunno then
[04:06:20] *** Quits: Jesin (Jessin_@moz-1B1307FF.eecs.lehigh.edu) (Ping timeout)
[04:06:28] <strcat> dbaupp: that's run-fail though
[04:06:31] <strcat> I think windows will abort()
[04:06:32] <dbaupp> cmr: yeah, maybe, probably... at the very least they can be plotted separately
[04:06:39] <strcat> ah they're both run-fail
[04:06:41] <strcat> maybe it'd work.
[04:08:46] *** Joins: erickt2 (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[04:09:15] *** Joins: Nefzaoui (chatzilla@8EF6409B.7A1D5DD4.D9343D67.IP)
[04:09:31] *** Quits: vodik (simon@moz-CBE4BB13.cable.teksavvy.com) (Ping timeout)
[04:10:24] *** Quits: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net) (Ping timeout)
[04:10:26] *** Quits: erickt2 (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[04:10:56] *** Joins: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net)
[04:10:59] *** Joins: Jesin (Jessin_@moz-1B1307FF.eecs.lehigh.edu)
[04:12:56] <strcat> dbaupp: 8 now ;p
[04:14:38] *** sankha94 is now known as sankha93
[04:15:13] <strcat> acrichto_: I really want to remove headers from stack closures.
[04:15:18] <strcat> that makes me sad
[04:15:29] <acrichto_> strcat: those definitely seem unfortunate...
[04:15:34] <acrichto_> is it mostly a codegen road block?
[04:15:44] <strcat> acrichto_: yeah but I don't think it'd be very hard
[04:15:53] <strcat> not as hard as doing unique ptrs/vecs was
[04:16:07] <strcat> since I had to split a dozen code paths even after making them unused
[04:16:08] <acrichto_> was that mostly just tracking down all the locations in codegen?
[04:16:11] <strcat> acrichto_: yeah
[04:16:25] <strcat> acrichto_: first I had to track actual users, and remove those
[04:16:36] <strcat> then figure out the 20 places in trans needing to be changed
[04:16:38] <strcat> fun! ;p
[04:16:43] <acrichto_> sounds like it :)
[04:16:48] <strcat> through trial and error mostly
[04:17:03] <strcat> LLVM asserts are the worst
[04:17:10] <strcat> since you have to start from a traceback
[04:17:24] <acrichto_> it'd be a lot nicer if LLVM didn't assert and then gave you errors during IR passes
[04:17:28] <strcat> once I was through those... got a lot easier, despite not having a traceback through trans
[04:17:42] <acrichto_> at least compiling rustc has gotten faster recently
[04:17:46] <strcat> because I could just make samples and diff the IR with the old compiler
[04:17:49] <strcat> yay vimdiff
[04:17:55] *** Quits: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com) (Quit: Jesse)
[04:17:55] <acrichto_> convenient
[04:18:09] <strcat> just fixed feature by feature, last broken thing was fmt!'s %?
[04:18:26] <strcat> LLVM asserts are a huge pain though
[04:18:40] <strcat> I really wish they printed out more info
[04:19:01] <strcat> assert -> traceback -> add a bunch of debug printing -> same thing, debug printing wasn't enough -> add more -> yay, usable data
[04:19:03] <strcat> ;p
[04:19:19] <strcat> they should at least print out the 2 types on errors like "expected Ptr to Val type"
[04:19:23] <acrichto_> I wonder if Release+NoAsserts would segfault or give nicer errors later down the line
[04:19:34] <strcat> acrichto_: no I think it's just undef behaviour
[04:19:38] <strcat> like LLVM itself will be broken
[04:19:43] <strcat> not just the code
[04:19:45] <strcat> rustc could crash
[04:20:00] <acrichto_> oh that's unfortunate
[04:20:10] *** Quits: int3_ (int3_@moz-7B0110AD.mv.mozilla.com) (Client exited)
[04:20:34] <strcat> I think we'd have to be really sure of rustc's stability to use Release without +Asserts
[04:20:38] <strcat> sadly
[04:20:45] <strcat> since they make LLVM 20% bigger
[04:21:02] <acrichto_> definitely not happening any time soon with all the trans changes
[04:21:56] <strcat> if only types like ~[T] were actually defined in libstd
[04:22:01] <strcat> + a lang item for the syntax
[04:22:01] *** Quits: qmx (qmx@moz-D6C3C2E6.qmx.me) (Ping timeout)
[04:22:16] <strcat> would be so nice to not have trans/tvec.rs and much simpler glue
[04:22:30] <dbaupp> strcat: try doing that?
[04:22:37] <strcat> maybe
[04:22:52] <dbaupp> how would literals like ~[1,2,3] work?
[04:23:01] <strcat> would use a lang item
[04:23:09] <strcat> rust is easier to read than LLVM calls ;p
[04:23:15] <strcat> all rust does is translate that to a loop
[04:23:17] <acrichto_> how much glue is there for ~T and ~[T]? shouldn't it just be calling a generated function?
[04:23:21] <acrichto_> for freeing
[04:23:35] <strcat> acrichto_: it's basically all glue, the only lang items are exchange_{free,malloc}
[04:23:40] <strcat> acrichto_: like
[04:23:50] <strcat> for destruction, it adds a null check in trans
[04:23:54] <strcat> then branches
[04:23:59] <acrichto_> for ~T?
[04:24:00] <strcat> iterates over all the elements
[04:24:03] <strcat> for ~[T]
[04:24:12] <acrichto_> this is in a generated function, right? not inline?
[04:24:26] <strcat> acrichto_: well it's a glue_drop function
[04:24:33] <strcat> or glue_free
[04:24:39] <strcat> I always forget which is which
[04:24:54] <acrichto_> well that makes sense
[04:25:07] <acrichto_> something in a library would do the same thing but just with tydescs instead
[04:25:14] <strcat> acrichto_: we have no more take glue for ~T, ~[T] and ~fn at least
[04:25:16] <strcat> thanks to clone
[04:25:19] <acrichto_> yay!
[04:25:27] <acrichto_> that sounds like it makes sense
[04:25:53] <strcat> the ~fn take glue was scary
[04:25:59] <strcat> scariest code in rustc imo
[04:26:07] *** Joins: qmx (qmx@moz-D6C3C2E6.qmx.me)
[04:26:19] *** Quits: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net) (Quit: tikue)
[04:26:23] <acrichto_> that's saying a lot
[04:26:25] *** Joins: Khmar (user@B41D7B17.FBFEAA2F.FA4E5DC4.IP)
[04:26:41] <strcat> acrichto_: https://github.com/mozilla/rust/commit/0cdb0a21891b88ce8ef14edae1b3863fcf3983ab#L0L515
[04:26:45] <strcat> yeah...
[04:26:47] <strcat> but it's scary
[04:26:59] <strcat> it allocates the wrong amount of memory
[04:27:07] <strcat> 4 extra words
[04:27:15] <acrichto_> oh dear
[04:27:53] <strcat> because exchange_malloc (which became closure_exchange_malloc) always added those implicitly
[04:28:10] <dbaupp> acrichto_: std::repr defines a Repr trait too, btw
[04:28:32] <acrichto_> dbaupp: ah, then Repr is bad
[04:28:48] <strcat> acrichto_: anyway quite a scary fn.
[04:28:53] * dbaupp dislikes naming things
[04:28:55] <strcat> you've got everything in there
[04:29:10] <strcat> tydesc galore, take glue calls for the contained data
[04:29:12] <acrichto_> strcat: yeah you're not kidding
[04:29:18] <engla> there are namespaces
[04:29:48] <strcat> traits have to be in scope to use the methods though
[04:30:06] <strcat> and it's annoying to keep only 1 in scope by splitting up code
[04:30:09] <engla> yeah that's annoying. In worst case you'll have to rename the trait when importing it
[04:30:32] <engla> as in use Repr2 = std::repr::Repr;
[04:30:34] <strcat> I guess that's true, only really hurts if the method names are the same and the same types impl them
[04:30:56] <acrichto_> strcat: I think that's a compiler error
[04:30:57] <dbaupp> engla: there's no method namespace though.
[04:31:12] *** Joins: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net)
[04:31:17] <dbaupp> engla: (but std::Repr::Repr has write_repr, not repr, so it doesn't actually matter.)
[04:31:20] <strcat> acrichto_: only if you try to call an ambiguous method when both are in scope
[04:31:48] <strcat> and then if you didn't control them, you'd have to keep only 1 in scope at a time
[04:32:10] <strcat> luckily you can import into a fn scope...
[04:32:30] <dbaupp> acrichto_: I'm still thinking the ugly std::unstable::raw::RawRepr.raw_repr is the most descriptive solution, even though it wears out the 'r' 'a' 'w' keys.
[04:32:40] <strcat> anyway just a minor tradeoff of methods instead of free functions
[04:32:53] *** Quits: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net) (Ping timeout)
[04:33:09] <acrichto_> dbaupp: if the trait is RawRepr the method could probably be repr()
[04:33:31] <dbaupp> it would be nice to be able to specify which trait's method you want.
[04:33:40] <dbaupp> acrichto_: fine by me
[04:35:15] <strcat> it seems like we could have a struct with a uniq_str lang item and remove them from the compiler
[04:35:18] <ozten> Howdy! Anyone got a moment to help me with trying to share a DuplexStream across task/modules?
[04:35:28] <strcat> all it needs to do is allocate them
[04:35:31] <ozten> compile error: http://www.pastebin.mozilla.org/2697835
[04:35:36] <ozten> here is main.rs line 21
[04:35:37] <ozten> https://github.com/ozten/learning_rust/blob/master/main.rs#L21
[04:35:42] <ozten> I'm trying to pass a DuplexStream into another function here
[04:35:42] <ozten> https://github.com/ozten/learning_rust/blob/master/repository_metadata_slurp.rs#L93
[04:35:43] <strcat> (I mean from trans, they'd stay elsewhere)
[04:40:42] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[04:40:54] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[04:41:38] *** Quits: lmandel (lmandel@moz-76CE9D51.cable.teksavvy.com) (Quit: lmandel)
[04:41:54] <kemurphy> so, what's RawRepr? /me lost in scrollback
[04:42:47] <acrichto_> kemurphy: it's a trait for converting a rust value to a struct of its actual representation
[04:42:55] <acrichto_> kemurphy: https://github.com/mozilla/rust/pull/7986
[04:43:05] <scroy> where is the cond! macro defined>
[04:43:26] <acrichto_> scroy: src/libsyntax/ext/expand.rs
[04:43:26] <kemurphy> acrichto_: ooh, nifty!
[04:43:42] <scroy> ty acrichto_
[04:43:56] <dbaupp> scroy: https://github.com/mozilla/rust/blob/master/src/libsyntax/ext/expand.rs#L635-L669
[04:44:15] <acrichto_> oh wow I never knew you could highlight ranges on github
[04:44:49] <dbaupp> acrichto_: click on one line, shift-click on the second
[04:45:05] <acrichto_> convenient
[04:45:07] *** Quits: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net) (Quit: I'm sure it's perfectly safe)
[04:53:28] *** Joins: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net)
[04:54:29] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[05:03:32] <kemurphy> is there a way to create a new ast::Ty from a string
[05:04:03] *** Joins: eagen (eagen@moz-92A457CB.hsd1.mn.comcast.net)
[05:04:50] *** Quits: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net) (Ping timeout)
[05:05:05] *** Joins: dherman (dherman@8A703D98.AE3E6FBC.FEA76598.IP)
[05:05:05] *** ChanServ sets mode: +o dherman
[05:05:23] *** Joins: lkuper (lkuper@DC3FAA1C.A402E718.C082B7DC.IP)
[05:05:40] <dbaupp> kemurphy: yeah, with some parsing stuff.
[05:07:05] <dbaupp> kemurphy: something like syntax::parse::parse_from_str(|p| p.parse_ty(false), ...), maybe.
[05:07:07] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Client exited)
[05:07:30] <dbaupp> (the false is "Useless second parameter for compatibility with quasiquote macros.")
[05:07:58] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[05:07:59] <kemurphy> dbaupp: yuck, ok i guess that works
[05:08:02] <kemurphy> thanks
[05:08:24] <dbaupp> acrichto_: the commit message still says 'unwrap' for https://github.com/mozilla/rust/pull/7986 btw.
[05:08:34] <dbaupp> kemurphy: (there may be a nicer way I don't know.)
[05:08:45] <acrichto_> dbaupp: you are correct
[05:08:57] *** Quits: Nefzaoui (chatzilla@8EF6409B.7A1D5DD4.D9343D67.IP) (Ping timeout)
[05:09:13] *** Joins: erickt2 (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[05:10:53] *** Quits: erickt2 (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[05:11:51] *** Quits: lkuper (lkuper@DC3FAA1C.A402E718.C082B7DC.IP) (Ping timeout)
[05:11:57] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[05:13:09] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[05:13:12] <kemurphy> man, i really don't like having to track an Option<ast::Ty> on an ast::enum_def
[05:14:35] <strcat> dbaupp: a few broken things anyway ;p
[05:14:45] <strcat> oh well
[05:14:49] <strcat> https://github.com/thestinger/rust/commit/f93157b6e7652f58ba7337f63bea5eb3290be4c4
[05:16:41] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[05:16:41] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/KZcoaw
[05:16:41] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[05:17:15] <dbaupp> kemurphy: yay!
[05:17:24] <dbaupp> (it landed)
[05:17:27] <dbaupp> strcat: only a few!
[05:19:40] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[05:19:40] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/xskV3g
[05:19:40] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[05:19:41] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[05:19:41] <ghrust> 01[13rust01] 15bors pushed 12 new commits to 06auto: 02http://git.io/h4K5MA
[05:19:41] <ghrust> 13rust/06auto 140488553 15Daniel Micay: add a RandomAccessIterator trait
[05:19:41] <ghrust> 13rust/06auto 140e94040 15Daniel Micay: expand on double-ended iterators in the tutorial
[05:19:42] <ghrust> 13rust/06auto 1469f4ae6 15Daniel Micay: document random-access iterators
[05:19:42] *** Quits: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net) (Quit: tikue)
[05:19:44] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[05:20:08] <kemurphy> dbaupp: woo! \o/
[05:20:38] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[05:24:25] *** Quits: geomyidae (cole@DD6F7E3A.21468E9A.30200F38.IP) (Client exited)
[05:26:00] *** Joins: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net)
[05:26:04] *** Joins: geomyidae (cole@DD6F7E3A.21468E9A.30200F38.IP)
[05:28:40] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[05:28:41] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14d224507 to 14af78e23: 02http://git.io/N3iJvQ
[05:28:41] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[05:28:42] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[05:28:42] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/vGP1DA
[05:28:43] <ghrust> 13rust/06auto 14c062510 15Alex Crichton: Allow linking against crates with #[no_std]...
[05:28:43] <ghrust> 13rust/06auto 149d7c72a 15Alex Crichton: Add the ability to not link against rustrt
[05:28:43] <ghrust> 13rust/06auto 14e3010b5 15bors: auto merge of #7924 : alexcrichton/rust/opt-lang-xcrate2, r=huonw...
[05:28:45] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[05:32:42] <kemurphy> okay, how do i go from an ast::Ty to an sty?
[05:34:36] <jensnockert> kemurphy: ast_ty_to_ty in astconv.rs
[05:34:56] <jensnockert> And then get(ty).sty in ty.rs
[05:35:09] <kemurphy> oh, right, i thought i saw that somewhere
[05:35:11] <kemurphy> thanks jensnockert 
[05:35:22] <jensnockert> <3
[05:36:35] <sfackler> rusti: trait Foo<'self, B: Bar<'self>> { fn foo(&self) -> ~B; } trait Bar<'self, R, I: Iterator<&'self R>> { fn iter(&self) -> I; }
[05:36:37] -rusti- error: internal compiler error: unexpected failure
[05:36:37] -rusti- note: the compiler hit an unexpected failure path. this is a bug
[05:36:37] -rusti- note: try running with RUST_LOG=rustc=1,::rt::backtrace to get further details and report the results to github.com/mozilla/rust/issues
[05:36:37] -rusti- application terminated with error code 101
[05:36:41] <sfackler> is this a known issue?
[05:37:18] *** Quits: eagen (eagen@moz-92A457CB.hsd1.mn.comcast.net) (Quit: Leaving)
[05:37:19] <dbaupp> sfackler: hard to say without the output of ::rt::backtrace
[05:37:50] <sfackler> how do I build rustc with debug info?
[05:38:52] <dbaupp> ./configure --enable-debug
[05:38:57] <sfackler> thanks
[05:39:20] <dbaupp> sfackler: (you shouldn't need to do that to get RUST_LOG=::rt::backtrace to work...)
[05:40:12] <ChrisMorgan> Hang on, --enable-debug *doesn't* do -Z debug-info
[05:40:30] <dbaupp> nope
[05:40:40] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[05:40:40] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14e3010b5 to 14af78e23: 02http://git.io/N3iJvQ
[05:40:40] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[05:40:49] <dbaupp> presumably because it was historically totally broken, and is currently slightly borken
[05:40:57] *** Joins: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[05:41:09] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[05:42:20] <ChrisMorgan> See https://github.com/mozilla/rust/issues/7603 (failure to compile Rust with -Z debug-info) and https://github.com/mozilla/rust/issues/7712 (a minimal test case of the problem, now fixed).
[05:42:32] <sfackler> dbaupp: https://gist.github.com/sfackler/991dee0b309a6ea17f11
[05:42:38] <ChrisMorgan> I'll try building it with -Z debug-info and see what happens.
[05:43:43] *** Joins: bh (brendan@moz-9A034376.hfc.comcastbusiness.net)
[05:44:02] <dbaupp> sfackler: https://github.com/mozilla/rust/issues/6551 and https://github.com/mozilla/rust/issues/7905
[05:44:10] <sfackler> yeah, just saw those
[05:44:21] <sfackler> :/
[05:44:24] *** Quits: Khmar (user@B41D7B17.FBFEAA2F.FA4E5DC4.IP) (Ping timeout)
[05:44:46] <dbaupp> ... file another bug and link to them, since this one seems different?
[05:45:05] <dbaupp> (at least, it isn't obviously the same.)
[05:45:41] <strcat> noo
[05:46:03] <dbaupp> sfackler: you realise that Bar needs more parameters when used in `Foo`, right?
[05:46:12] <dbaupp> strcat: it failed :(
[05:46:20] <strcat> yep 
[05:46:22] <dbaupp> cfg'd stuff?
[05:46:34] <strcat> no, a mod
[05:46:40] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[05:46:40] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 143b36861 to 14af78e23: 02http://git.io/N3iJvQ
[05:46:40] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[05:46:41] <strcat> but yeah it's cfg'd
[05:46:43] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[05:46:43] <ghrust> 01[13rust01] 15bors pushed 10 new commits to 06auto: 02http://git.io/8mt65w
[05:46:43] <ghrust> 13rust/06auto 14bc2b78c 15Graydon Hoare: rt: Fix child-iteration bug in crate map.
[05:46:43] <ghrust> 13rust/06auto 14786318f 15Graydon Hoare: std: add #[cfg(test)] reference to extra so we can benchmark libstd.
[05:46:44] <ghrust> 13rust/06auto 14e5cbede 15Graydon Hoare: std: add preliminary str benchmark.
[05:46:44] <strcat> that's why I didn't catch it
[05:46:45] *** Quits: geomyidae (cole@DD6F7E3A.21468E9A.30200F38.IP) (Ping timeout)
[05:46:46] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[05:47:05] <strcat> #[cfg(target_os = "macos")]
[05:47:06] <dbaupp> mod's a stuff too :P but yeah, that's always annoying :/
[05:47:06] <strcat> #[cfg(target_os = "win32")]
[05:47:14] <dbaupp> *are stuff
[05:47:17] <strcat> dbaupp: yeah I misunderstood what you meant
[05:47:25] <strcat> thought you meant stage0/stage1
[05:47:25] <dbaupp> haha :)
[05:47:55] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Quit: Gone to save the world!)
[05:48:36] <sfackler> dbaupp: is Foo<'self, R, I, Bar<'self, R, I>> what I want?
[05:49:08] <dbaupp> sfackler: I guess so? I don't really know
[05:49:20] <dbaupp> :( for ugliness.
[05:49:20] *** Joins: geomyidae (cole@DD6F7E3A.21468E9A.30200F38.IP)
[05:49:26] <sfackler> yep :(
[05:50:09] *** Quits: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net) (Ping timeout)
[05:54:37] *** Joins: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net)
[05:57:34] *** Quits: rntz (rntz@moz-C76A8D96.sp.cs.cmu.edu) (Ping timeout)
[05:57:46] *** Quits: rpearl (rpearl@moz-2B41ACB5.andrew.cmu.edu) (Ping timeout)
[05:57:58] *** Quits: bblum (bblum@moz-2B41ACB5.andrew.cmu.edu) (Ping timeout)
[05:58:00] *** Quits: mjrosenb (mjrosenb@moz-B3592BDA.club.cc.cmu.edu) (Ping timeout)
[05:58:04] *** Quits: acrichto_ (acrichto@moz-B63D64BD.res.cmu.edu) (Ping timeout)
[05:59:43] <gavinb> I'm trying to put doc comments on members of an enum. If I use "///" I get a weird "expected ident, found }" error. If I use "//!" I get the rather obtuse error "expected outer comment". WIth "//" it runs just fine. So - what is the proper way to document enum members??
[06:00:45] <strcat> gavinb: /// goes above an item
[06:00:48] <strcat> before it
[06:01:30] <gavinb> strcat: oh so I can't put the docstring to the right of an item?
[06:01:43] <strcat> gavinb: well that will actually belong to the next item
[06:01:53] <strcat> it's just not special-cased at all
[06:02:04] <aatch> gavinb, unfortunately no. doc-comments are just sugar for #[doc="..."]
[06:02:09] <gavinb> oh :( Not like doxygen or any of those
[06:02:18] <strcat> gavinb: http://ix.io/6Qj needs to be like that atm
[06:02:35] <gavinb> strcat: ok, thanks - will update
[06:02:56] <klutzy> sometimes i comment large blob then get syntax error since // becomes ////
[06:03:03] *** Joins: acrichto (acrichto@moz-B63D64BD.res.cmu.edu)
[06:03:07] *** Joins: rpearl (rpearl@moz-2B41ACB5.andrew.cmu.edu)
[06:03:11] *** Joins: rntz (rntz@moz-C76A8D96.sp.cs.cmu.edu)
[06:03:15] *** Joins: bblum (bblum@moz-2B41ACB5.andrew.cmu.edu)
[06:03:29] *** Joins: mjrosenb (mjrosenb@moz-B3592BDA.club.cc.cmu.edu)
[06:03:52] <aatch> Specifically, `/** .. */` and `///` are for `#[doc="..."]`, `/*! */` and `///` are for `#[doc="..."];`
[06:04:19] *** Quits: bh (brendan@moz-9A034376.hfc.comcastbusiness.net) (Quit: leaving)
[06:04:42] <gavinb> aatch: oh, with and without ';' to apply to the following entity, or globally?
[06:04:48] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[06:05:00] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[06:05:07] <aatch> gavinb, no quite, the trailing `;` is the "enclosing item"
[06:05:18] <aatch> not*
[06:05:24] <gavinb> like a module?
[06:05:29] <klutzy> gavinb: #[doc="fn1."] fn fn1(){}   fn fn2() { #[doc="fn2."]; }
[06:05:31] <aatch> gavinb, correct.
[06:05:42] <gavinb> aatch: aha! I think it's starting to sink in! :)
[06:05:57] <aatch> since there's no syntax object to attach to inside a module-file
[06:06:11] <dbaupp> strcat: you can rage about the various glue-badnesses some more https://github.com/mozilla/rust/issues/8018 :P
[06:06:19] <gavinb> Isn't a file implicitly a module?
[06:06:48] <aatch> gavinb, yes, that's the point.
[06:06:52] <gavinb> ah ok
[06:07:10] <aatch> gavinb, what syntax object do you attach the doc comment in that case?
[06:07:53] *** Joins: kertap (kertap@moz-5AE34C97.b-ras3.mvw.galway.eircom.net)
[06:08:02] <gavinb> aatch: No idea; I'm only looking at library stuff, haven't looked at the compiler internals...
[06:08:15] *** Quits: tcsc (tcsc@moz-7246F5CD.hsd1.ma.comcast.net) (Quit: bye!)
[06:08:17] <dbaupp> it can go on the `mod` statement, whereever that is in some other file
[06:08:33] <dbaupp> (the inner syntax is really only *necessary* for documentation on crates.)
[06:08:48] <aatch> gavinb, that's fine, just explaining why the two different things exist.
[06:09:06] <dbaupp> but obviously having the docs in the file itself is much nicer.
[06:09:41] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[06:11:26] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[06:14:39] *** Quits: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Ping timeout)
[06:15:32] *** Joins: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net)
[06:17:00] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[06:22:11] *** Joins: brson (brson@C0559334.C30B3942.8DDCAE07.IP)
[06:22:11] *** ChanServ sets mode: +o brson
[06:22:27] *** Quits: rpearl (rpearl@moz-2B41ACB5.andrew.cmu.edu) (Ping timeout)
[06:22:34] *** Quits: bblum (bblum@moz-2B41ACB5.andrew.cmu.edu) (Ping timeout)
[06:22:54] *** Quits: pauls (pauls@moz-BFEF1F22.ccs.neu.edu) (Ping timeout)
[06:23:02] *** Quits: mjrosenb (mjrosenb@moz-B3592BDA.club.cc.cmu.edu) (Ping timeout)
[06:23:05] *** Quits: rntz (rntz@moz-C76A8D96.sp.cs.cmu.edu) (Ping timeout)
[06:23:08] *** Quits: acrichto (acrichto@moz-B63D64BD.res.cmu.edu) (Ping timeout)
[06:24:09] *** Joins: pauls (pauls@moz-BFEF1F22.ccs.neu.edu)
[06:24:13] *** Joins: thpickert (thpickert@moz-24816453.tng.de)
[06:25:36] *** Quits: Jesin (Jessin_@moz-1B1307FF.eecs.lehigh.edu) (Quit: Leaving)
[06:25:56] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: sleep)
[06:26:34] *** Quits: igl (igl@moz-3FC23ABD.adsl.alicedsl.de) (Connection reset by peer)
[06:27:48] *** Joins: rpearl (rpearl@moz-2B41ACB5.andrew.cmu.edu)
[06:27:52] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz‚Ä¶)
[06:27:56] *** Joins: bblum (bblum@moz-2B41ACB5.andrew.cmu.edu)
[06:28:08] *** Joins: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net)
[06:28:26] *** Joins: rntz (rntz@moz-C76A8D96.sp.cs.cmu.edu)
[06:28:30] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[06:28:31] *** Joins: mjrosenb (mjrosenb@moz-B3592BDA.club.cc.cmu.edu)
[06:28:39] *** Joins: acrichto_ (acrichto@moz-B63D64BD.res.cmu.edu)
[06:29:42] *** Quits: scroy (roy@moz-F152D5C3.washdc.fios.verizon.net) (Ping timeout)
[06:30:24] *** Quits: brson (brson@C0559334.C30B3942.8DDCAE07.IP) (Quit: leaving)
[06:30:45] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[06:30:45] <ghrust> 01[13rust01] 15brson merged 06master into 06snap-stage3: 02http://git.io/v4M8nA
[06:30:45] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[06:31:40] *** Quits: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca) (Quit: Leaving)
[06:31:48] <kemurphy> ... network trouble at cmu? :P
[06:33:06] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[06:35:08] *** Quits: dherman (dherman@8A703D98.AE3E6FBC.FEA76598.IP) (Ping timeout)
[06:36:17] *** Quits: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net) (Ping timeout)
[06:39:47] *** Quits: ozten (ozten@moz-DD3B00B4.hsd1.wa.comcast.net) (Quit: ozten)
[06:40:24] <ChrisMorgan> -O is equivalent to --opt-level=2, but --opt-level says it's in the range 0-3. What extra does --opt-level=3 do? What less does --opt-level=1 do? (The former question is far more important.)
[06:41:14] <aatch> ChrisMorgan, not much, a little vectorisation and some more aggressive internal-function optimizations
[06:41:24] <aatch> (like arg promotion, which actually changes the ABI)
[06:42:02] <ChrisMorgan> But if it does that only to internal members, that's fine, right?
[06:42:12] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[06:42:17] <aatch> ChrisMorgan, yes
[06:42:23] <ChrisMorgan> So then, why not have -O equivalent to --opt-level=3?
[06:43:36] <ChrisMorgan> Compiling rust with -Z debug-info has got past stage 1 successfully :-)
[06:48:00] <thpickert> Hey, I'm getting a segmentation fault that I can't explain. Could someone help me to determine if I'm doing something silly?
[06:48:03] <thpickert> https://gist.github.com/anonymous/6068516
[06:48:27] <aatch> thpickert, what version Rust?
[06:48:30] <thpickert> (v0.7, OS X)
[06:48:43] <thpickert> aatch: ^
[06:49:25] <klutzy> thpickert: looks like closure problem
[06:50:20] <klutzy> thpickert: currently there are bugs around closure e.g. borrowing does not work for some cases
[06:50:31] <thpickert> klutzy: Oh!
[06:50:32] <klutzy> so double borrowing occurs then segfaults at runtime
[06:50:52] <thpickert> klutzy: Ok, I wasn't aware that there were problems in that area.
[06:51:00] <klutzy> thpickert: https://github.com/mozilla/rust/issues/6653
[06:51:31] *** Joins: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net)
[06:52:27] <thpickert> klutzy: Alright, thanks.
[06:53:47] *** Joins: jaen (jaen@moz-15FBDBCB.neoplus.adsl.tpnet.pl)
[06:54:20] *** Quits: jaen (jaen@moz-15FBDBCB.neoplus.adsl.tpnet.pl) (Quit: WeeChat 0.4.1)
[06:57:16] <thpickert> klutzy: Right, if I make a copy for the second closure, it prevents the segfault. https://gist.github.com/ende76/6068545
[06:57:39] <thpickert> klutzy: Thanks for the insight!
[07:01:11] * ChrisMorgan has just realised there is clearly some significant change in his laptop since last boot: its fan is not going above its minimum speed at all, even with high load like compiling Rust.
[07:04:19] <dbaupp> ChrisMorgan: explains the server regression?
[07:04:29] <ChrisMorgan> dbaupp: that's what I'm wondering.
[07:04:51] <ChrisMorgan> I don't know what it is that's changed‚Äîsame kernel and such‚Äîbut clearly *something* significant has changed.
[07:05:40] <dbaupp> ubuntu, right? you can get a upgrade-log can't you?
[07:06:38] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[07:06:56] <ChrisMorgan> dbaupp: I've looked at it (/var/log/dpkg.log)
[07:07:10] <dbaupp> oh, and nothing of interest?
[07:10:08] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[07:11:55] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[07:12:39] <ChrisMorgan> dbaupp: not that would suggest anything at all‚Äîunless linux-tools-common would do it, which would seem remarkably strange.
[07:13:05] *** Joins: Ms2ger (Ms2ger@E699BE68.4A4AF98A.F15B0BB3.IP)
[07:17:23] <kemurphy> can someone tell me what trans_constant is responsible for (in middle/trans/base.rs)
[07:19:16] <jensnockert> kemurphy: It creates constants?
[07:19:22] <dbaupp> kemurphy: it looks like it's for transing enum variants
[07:20:36] <jensnockert> Yeah, actually looking at it, it seems to be generating enum discriminators.
[07:21:08] <Jeaye> rusti: path::Path("f:\\foo\\bar.jbn").normalize().filename()
[07:21:11] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/bOGQ
[07:21:26] <kemurphy> dbaupp: okay, cool, i'm in the right spot then :)
[07:21:28] <Jeaye> rusti: Path("f:\\foo\\bar.jbn").normalize().filename()
[07:21:29] -rusti- Some(~"f:\\foo\\bar.jbn")
[07:21:38] <Jeaye> Why is this the case?
[07:21:42] <kemurphy> dbaupp: if i were to change the width there, what else would i need to worry about?
[07:21:47] <Jeaye> Shouldn't filename() return "bar.jbn"?
[07:22:05] <dbaupp> kemurphy: I dunno why you're asking me :P
[07:22:37] <kemurphy> dbaupp: fair enough :P
[07:22:48] <dbaupp> kemurphy: I guess try it, and see what blows up when you actually try to use a different width
[07:22:58] <dbaupp> kemurphy: (at least, that's what I would do)
[07:23:02] <kemurphy> oh boy, that won't be fun
[07:23:04] <kemurphy> here goes nothing
[07:23:04] <ChrisMorgan> Ooh! Got a bad dead-assignment warning.
[07:23:22] <Jeaye> rusti: Path("f:\foo\bar.jbn").filesystem()
[07:23:22] -rusti- <anon>:7:13: 7:14 error: unknown string escape: 102
[07:23:23] -rusti- <anon>:7          Path("f:\foo\bar.jbn").filesystem()
[07:23:23] -rusti-                       ^
[07:23:23] -rusti- application terminated with error code 101
[07:23:32] <Jeaye> rusti: Path("f:\\foo\\bar.jbn").filesystem()
[07:23:33] -rusti- <anon>:7:9: 8:5 error: type `std::path::PosixPath` does not implement any method in scope named `filesystem`
[07:23:33] -rusti- <anon>:7          Path("f:\\foo\\bar.jbn").filesystem()
[07:23:33] -rusti- <anon>:8     };
[07:23:33] -rusti- error: aborting due to previous error
[07:23:34] -rusti- application terminated with error code 101
[07:23:36] <Jeaye> bah
[07:23:49] <ChrisMorgan> Or perhaps it isn't quite spurious... tell me, what do you think of https://github.com/logicchains/levgen-benchmarks/blob/master/R.rs#L122
[07:23:59] <Jeaye> filestem, it is. >.<
[07:24:01] <dbaupp> rusti: std::path::WindowsPath("f:\\foo\\bar.jbn").normalize().filename()
[07:24:01] -rusti- Some(~"bar.jbn")
[07:24:10] <dbaupp> Jeaye: ^
[07:24:14] <Jeaye> dbaupp: grrr
[07:24:23] <kemurphy> also, what's all this business with structs and ctors?
[07:24:27] <Jeaye> dbaupp: What if I don't know if it's a Windows or POSIX path?
[07:24:28] <ChrisMorgan> rustc says value assigned to 'yi' is never read. True enough. Would you then just drop that line and use let on line 124?
[07:24:41] <dbaupp> Jeaye: well, you're screwed... :S
[07:24:49] <Jeaye> gar
[07:24:50] * dbaupp doesn't know
[07:24:51] <kemurphy> (looking in get_item_val)
[07:25:00] <Jeaye> I'll just parse it myself.
[07:25:13] <kemurphy> for ast_map::node_variant
[07:25:15] <dbaupp> Jeaye: are you going to be encountering Windows paths on non-Windows platforms?
[07:25:28] <Jeaye> dbaupp: Yup, and vice versa.
[07:25:38] <kemurphy> like, why does that arm call register_fn
[07:25:47] <jensnockert> Jeaye: Pattern match for / vs \ ?
[07:26:01] <dbaupp> Jeaye: oh, well you can handle WindowsPath and UnixPath directly?
[07:26:20] <dbaupp> Jeaye: (using a `GenericPath` trait object if you need to handle them uniformly.)
[07:26:23] <Jeaye> jensnockert: At that point I might as well truncate to the laste \ or /
[07:26:30] * jensnockert uses / on both kinds of systems, but I am br0ken.
[07:26:47] <Jeaye> jensnockert: I do too. It's the _right_ way. >.<
[07:26:50] *** Joins: heftig (heftig@327C8F30.EBDCAFC6.FEC4A986.IP)
[07:26:51] <dbaupp> kemurphy: an enum/tuple-struct constructor is actually a "normal" function
[07:27:00] <dbaupp> kemurphy: i.e. Some(x) is a function call.
[07:27:17] <jensnockert> Jeaye: And most importantly, doesn't show up as ¬• and other sillies‚Ä¶
[07:27:30] <dbaupp> ChrisMorgan: yes
[07:28:19] <dbaupp> ChrisMorgan: wow, that Rust code is non-idiomatic! that's from http://togototo.wordpress.com/2013/07/23/benchmarking-level-generation-go-rust-haskell-and-d/ right?
[07:28:38] <ChrisMorgan> dbaupp: yep, sure is. I'm just rewriting it now. Some things can be cut down rather a lot.
[07:28:48] <dbaupp> ChrisMorgan: iterators!
[07:28:58] * dbaupp has a go at rewriting it too
[07:29:02] <ChrisMorgan> CheckColl, for example, can use do rooms.iter().any |r| { ... }
[07:29:49] <ChrisMorgan> And FindMostRooms should be levels.iter().max_by(|level| level.rooms.len()) (returns Option<&'a Level> rather than the index‚Äîbetter still)
[07:30:54] <ChrisMorgan> int::to_str(l.tiles[i].t.to_int()) :-/
[07:31:20] <ChrisMorgan> Where l.tiles[i].t is a uint. What a way to turn a uint into a str!
[07:32:15] <kemurphy> dbaupp: ah, makes sense
[07:32:37] <kemurphy> dbaupp: why doesn't that apply to struct-like variants and non-tuple-structs?
[07:33:08] <dbaupp> kemurphy: because they're Foo { x: int, y: uint } and that doesn't look like a function call?
[07:33:11] * dbaupp doesn't know
[07:33:31] <ChrisMorgan> I like this line: `i % TILE_DIM == 49 && i != 0`, where TILE_DIM=50. Just as well the `i != 0` is in there.
[07:33:42] <ChrisMorgan> rusti: 0 % 50 == 49
[07:33:43] -rusti- false
[07:38:03] *** Quits: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net) (Ping timeout)
[07:38:27] <kemurphy> dbaupp: i'm just surprised they don't share an implementation; a tuple is essentially a struct with anonymouse fields.
[07:38:47] <kemurphy> reading code i didn't write is fun, etc
[07:39:09] <dbaupp> kemurphy: I've got literally no idea... what you say seems very reasonable.
[07:39:16] *** Joins: xraycat (Adium@moz-AAD824D1.pool.mediaways.net)
[07:41:56] <ChrisMorgan> What are the performance characteristics of `for uint::range(m, n) { ... }` compared to `let mut i = m; while i < n { ...; i += 1; }`.
[07:42:31] <dbaupp> ChrisMorgan: identical
[07:42:36] <ChrisMorgan> :-)
[07:42:41] <dbaupp> ChrisMorgan: (in theory)
[07:42:57] <ChrisMorgan> In theory only, or in practice with -O?
[07:43:31] * ChrisMorgan missed a `|i|` in his `for` example
[07:45:33] <ChrisMorgan> And all that "let x = r.x;" etc.! I presume the optimiser would do that for you.
[07:46:43] <dbaupp> ChrisMorgan: it should happen without -O
[07:46:59] <dbaupp> I've got it down to .49 from .7... but also breaking it :/
[07:47:25] <ChrisMorgan> What? isn't that an optimisation?
[07:47:42] <Jesse> does #[inline(always)] apply to both 'range' and the closure called by 'range'?
[07:49:11] <dbaupp> ChrisMorgan: it's marked inline(always), which always happens
[07:49:39] <dbaupp> Jesse: it means that range is essentially substituted at the call site, which can lead to the closure being "inlined"
[07:49:58] <dbaupp> i.e. it's just placed directly where it's called, without the overhead of the call.
[07:50:22] <ChrisMorgan> dbaupp: it was the closure inlining bit that I meant; I see the #[inline] on the range functions themselves.
[07:50:50] <dbaupp> ChrisMorgan: oh, well, I think that happens automagically with the range inlining
[07:50:55] * dbaupp doesn't really know
[07:51:53] *** Quits: txdv (quassel@966F3542.3BA477DA.14C26596.IP) (Ping timeout)
[07:53:45] <dbaupp> okaaay... for all my idiomatisation & iteratorisation... it's not faster :(
[07:54:44] * jensnockert hugs dbaupp
[07:56:30] *** Joins: eatkinson (eatkinson@moz-AD233F1B.dia.static.qwest.net)
[07:57:58] * dbaupp hugs jensnockert back
[08:00:25] *** Joins: mellum (falk@moz-C8220309.dip0.t-ipconnect.de)
[08:01:04] *** Quits: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Quit: zzz)
[08:01:41] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[08:01:41] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/8mt65w
[08:01:41] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[08:02:18] <ChrisMorgan> With --opt-level=3, before adding #[inline] to all the functions but main: 48384 bytes; after: 48578 bytes. Each such function is called once. Now why would there be a 194 byte increase there?
[08:03:00] <kemurphy> hm, so as an extension of the enum Foo: u16 { ... } idea to specify width
[08:03:41] <dbaupp> ChrisMorgan: the biggest performance issue is using a cryptographically secure random number generator
[08:03:44] *** Joins: doener (bs@moz-AA189A5A.unitymedia.biz)
[08:03:55] <ChrisMorgan> Pro tip: benchmarking while building Rust in the background is a waste of time.
[08:03:58] <kemurphy> what would people think of something like enum Foo: (u16, u16) { ... } where the tuple is (discr, size_of_variant)
[08:04:09] <dbaupp> ChrisMorgan: using XorShiftRng rather than IsaacRng takes the time to .4 from .7
[08:04:26] <jensnockert> dbaupp: Replace it with a shit one? #[inline(always)] fn random() { 6 } ?
[08:04:35] *** Quits: cade (cadecairos@moz-DB3BF95F.members.linode.com) (Ping timeout)
[08:04:38] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[08:04:38] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/UK1xvg
[08:04:38] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[08:04:39] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[08:04:39] <ghrust> 01[13rust01] 15bors pushed 13 new commits to 06auto: 02http://git.io/HUyfMw
[08:04:39] <ghrust> 13rust/06auto 140488553 15Daniel Micay: add a RandomAccessIterator trait
[08:04:39] <ghrust> 13rust/06auto 140e94040 15Daniel Micay: expand on double-ended iterators in the tutorial
[08:04:39] <ghrust> 13rust/06auto 1469f4ae6 15Daniel Micay: document random-access iterators
[08:04:41] *** Quits: ivan (ivan@moz-531C3EC9.members.linode.com) (Ping timeout)
[08:04:41] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[08:04:46] *** Quits: hoelzro (hoelzro@moz-937642A5.ro) (Ping timeout)
[08:04:48] *** Quits: bstrie (ben@moz-D5A1D0F5.members.linode.com) (Ping timeout)
[08:04:50] *** Quits: Caseus (bacon@moz-9F046088.members.linode.com) (Ping timeout)
[08:04:51] *** Quits: petantik (oz@moz-20EC2160.net) (Ping timeout)
[08:04:56] *** Quits: reed (reed@tech.monkey) (Ping timeout)
[08:05:08] *** Quits: friggle (friggle@moz-A607EAFA.members.linode.com) (Ping timeout)
[08:05:12] <kemurphy> and the presence of the 2-tuple tells rust to include the size everywhere one of Foo's variants is used
[08:05:16] *** Quits: dumitru (dgherman@moz-7C253BEB.getcadre.com) (Ping timeout)
[08:05:18] *** Quits: jroll (jroll@moz-5989BB9E.members.linode.com) (Ping timeout)
[08:05:48] <ChrisMorgan> Anyway, his R.rs is 143 lines; mine is 110.
[08:06:18] <ChrisMorgan> Whoops, forgot to cut out those few lines...
[08:06:31] <kemurphy> size would be determined by the actual size of the variant rounded up to the highest alignment of all variants in Foo
[08:07:02] <kemurphy> (or specified by attr or somesuch)
[08:08:54] <ChrisMorgan> The seed generation technique is... enlightening.
[08:10:15] <ChrisMorgan> And you're right, using a crypto rand makes it an utterly uneven comparison.
[08:10:25] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[08:10:35] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[08:11:04] <pnkfelix> dbaupp: ping
[08:11:16] <dbaupp> pnkfelix: pong
[08:11:47] <pnkfelix> dbaupp: for Issue 7898, is there a fix you are implicitly suggesting?
[08:12:22] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[08:12:24] * pnkfelix uses ‚Äîenable-debug exclusively and only now thought to look at the issue list to see about this failure
[08:12:55] <dbaupp> pnkfelix: sort of... I'd want the test runner to *not* pass --cfg debug unless the test explicitly asks for it
[08:13:33] <dbaupp> even for ./configure --enable-debug: use `info!` to get printing in tests.
[08:13:59] <pnkfelix> dbaupp: okay, I understand what you suggesting, I think
[08:21:15] *** Joins: hoelzro (hoelzro@moz-937642A5.ro)
[08:21:20] *** Joins: bstrie (ben@moz-D5A1D0F5.members.linode.com)
[08:21:40] *** Joins: cade (cade@moz-DB3BF95F.members.linode.com)
[08:21:44] *** Joins: gunther (Mibbit@FAE2263D.A8718D67.FD98B230.IP)
[08:21:45] *** Joins: jroll (jroll@moz-5989BB9E.members.linode.com)
[08:21:53] *** Quits: gunther (Mibbit@FAE2263D.A8718D67.FD98B230.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[08:22:08] *** Joins: identifer (Mibbit@FAE2263D.A8718D67.FD98B230.IP)
[08:22:10] *** Joins: ivan (ivan@moz-531C3EC9.members.linode.com)
[08:22:38] *** Joins: reed (reed@tech.monkey)
[08:22:57] *** Joins: friggle (friggle@moz-A607EAFA.members.linode.com)
[08:23:39] *** Joins: Houm (Houm@moz-25669AA8.fbx.proxad.net)
[08:26:06] *** Joins: dumitru (dgherman@moz-7C253BEB.getcadre.com)
[08:26:36] *** Quits: identifer (Mibbit@FAE2263D.A8718D67.FD98B230.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[08:28:48] *** Joins: Caseus (bacon@moz-9F046088.members.linode.com)
[08:28:50] *** Joins: petantik (oz@moz-20EC2160.net)
[08:30:19] *** Quits: Houm (Houm@moz-25669AA8.fbx.proxad.net) (Ping timeout)
[08:30:23] *** Joins: Blub\w (wry@moz-81ABD137.dip0.t-ipconnect.de)
[08:33:35] <dbaupp> ChrisMorgan: https://github.com/huonw/levgen-benchmarks/blob/master/R.rs
[08:34:14] *** Joins: CarpNet (ac@moz-FD24B77.sohonet.co.uk)
[08:34:40] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[08:34:40] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 146c8982a to 147f96eb5: 02http://git.io/N3iJvQ
[08:34:40] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[08:34:41] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[08:34:41] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/0EoWWg
[08:34:41] <ghrust> 13rust/06auto 145c60691 15Alex Crichton: Add a test for #5844 (a closed issue now)
[08:34:41] <ghrust> 13rust/06auto 14b5799e1 15bors: auto merge of #7987 : alexcrichton/rust/tests-for-closed-issues, r=huonw...
[08:34:41] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[08:40:37] *** Quits: mellum (falk@moz-C8220309.dip0.t-ipconnect.de) (Quit: mellum)
[08:41:44] *** Joins: Houm (Houm@moz-25669AA8.fbx.proxad.net)
[08:46:10] <doener> what's up with this? http://buildbot.rust-lang.org/builders/auto-win-32-nopt/builds/567/steps/test/logs/stdio
[08:46:37] <doener> dbaupp: how much faster did you get it?
[08:46:56] <dbaupp> doener: to be equal with GCC
[08:47:06] <dbaupp> doener: (faster than clang too)
[08:47:19] <dbaupp> doener: https://news.ycombinator.com/item?id=6095043
[08:47:28] <doener> nice
[08:47:53] <doener> dbaupp: it's broken though
[08:47:59] <dbaupp> doener: broken?
[08:48:13] <doener> I get different results than with the C version
[08:48:23] <jensnockert> http://download-software.intel.com/sites/default/files/319433-015.pdf / Chapter 9.3 would be interesting for Rust bounds checking.
[08:48:41] <dbaupp> doener: yeah, it gives different results anyway, because different RNGs
[08:48:46] <doener> ah
[08:48:46] <dbaupp> doener: also, https://github.com/mozilla/rust/issues/6330 re that failure
[08:51:08] *** Quits: flowsnake (flowsnake@moz-1918C33E.aztw.cable.virginmedia.com) (Ping timeout)
[08:51:35] <doener> dbaupp: so I add a "use std::cast::transmute" and call just "transmute"?
[08:52:26] <dbaupp> doener: that'd work, yeah.
[08:55:34] *** Joins: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[08:58:44] <ChrisMorgan> dbaupp: your code still isn't idiomatic in its naming and operator-whitespace conventions. But apart from that, it ends up just about identical to mine, except that you switched the Rng, used a generic Rng, and got rid of the room to tile conversion, thus making it more efficient; the last one I had been going to look at, but got interrupted for a meal.
[08:59:16] <dbaupp> ChrisMorgan: yeah, I didn't bother with the naming stuff so much.
[08:59:53] <dbaupp> ChrisMorgan: but yay for converging to a similar thing! \o/ it probably means we're both doing something right :)
[08:59:53] <ChrisMorgan> I consider it important to get that sort of thing right when helping someone with their code; otherwise bad style is perpetuated even more than otherwise.
[09:01:04] <ChrisMorgan> Actually, I hadn't used get_or_default either; I presumed that there was such a thing, though, and was going to look. You saved me that trouble :-)
[09:01:30] <dbaupp> I'll correct it now
[09:01:53] <ChrisMorgan> Then too, you use let `Room { X, Y, W, H, _ } = *r;` whereas I decided to let the optimiser do that, going with just r.x, &c.
[09:02:31] <ChrisMorgan> (And you changed CheckColl into the negative NotCrash, using all(), while I kept it as check_collision with any().)
[09:02:40] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[09:04:07] <doener> dbaupp: maybe also set range for the random numbers to (1, TileDim) and drop the check for 0
[09:04:19] *** Joins: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk)
[09:04:30] *** Parts: xlq (ekselkiu@moz-DF73151C.net) ()
[09:07:17] *** Joins: z0w0 (zack@moz-E12708D5.lns6.woo.bigpond.net.au)
[09:07:21] <Thiez> anyone read http://togototo.wordpress.com/2013/07/23/benchmarking-level-generation-go-rust-haskell-and-d/ yet? I suspect our random numbers are too awesome :D
[09:07:35] <doener> see above
[09:07:52] <doener> Thiez: dbaupp already made it more awesome
[09:08:33] <ChrisMorgan> Good, rust now compiles successfully with -Z debug-info. Time to make a patch to that effect.
[09:08:41] <Thiez> niiice
[09:08:48] <Thiez> go dbaupp :)
[09:09:04] <dbaupp> doener: that 0 check seems like an obvious optimisation :/
[09:09:29] <dbaupp> anyways... meal time for me now.
[09:09:40] <dbaupp> ChrisMorgan: (updated the naming, etc.)
[09:11:01] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[09:11:54] <quasisphere> is there anything in the library for getting the smallest positive remainder of two numbers? (i.e. (-3) mod 5 == 2)
[09:12:21] <quasisphere> *non-negative
[09:12:51] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[09:14:13] <doener> dbaupp: interesting... it's slower with the range starting at 1
[09:15:37] <Thiez> rusti: fn spr(a: int, b: int)->int{let mut r = a%b; if r < 0 { r += b } r} spr(-3, 5)
[09:15:39] -rusti- 2
[09:16:25] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[09:16:29] <Thiez> of course this won't save you if b is negative :p
[09:17:25] <Ms2ger> b: uint ;)
[09:17:42] <quasisphere> Thiez: yep :) I already coded something similar (was just making sure I'm not doing something that already existed), but thanks
[09:19:04] <Thiez> Ms2ger: that's cheating
[09:21:07] <Ms2ger> :)
[09:21:43] <dbaupp> rusti: (-3).mod_floor(5)
[09:21:44] *** Quits: Blub\w (wry@moz-81ABD137.dip0.t-ipconnect.de) (Quit: bbl)
[09:21:45] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/HLRi
[09:21:55] <dbaupp> rusti: (-3i).mod_floor(5)
[09:21:55] -rusti- <anon>:7:25: 7:26 error: mismatched types: expected `&int` but found `<VI0>` (expected &-ptr but found integral variable)
[09:21:56] -rusti- <anon>:7          (-3i).mod_floor(5)
[09:21:56] -rusti-                                   ^
[09:21:56] -rusti- error: aborting due to previous error
[09:21:56] -rusti- application terminated with error code 101
[09:22:04] <dbaupp> rusti: (-3i).mod_floor(&5)
[09:22:05] -rusti- 2
[09:22:08] <dbaupp> quasisphere: ^
[09:22:50] <dbaupp> doener: I guess it's because get_uint_range gets inlined, and so starting at 0 saves a subtraction, etc.
[09:26:10] <quasisphere> dbaupp: ah, nice :)
[09:26:11] <doener> dbaupp: tiny micro-opt: switch the loops in Room2Tiles
[09:26:43] <doener> dbaupp: i.e. iterate in memory order, don't stripe
[09:29:37] <dbaupp> doener: doesn't appear to help much at all :(
[09:30:12] <doener> dbaupp: was about 0,5% here, as I said, tiny
[09:32:08] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Ping timeout)
[09:34:23] *** Joins: Earnestly (earnest@2AB30F53.FB5005.2BCC804A.IP)
[09:35:29] <Thiez> perhaps you could make a multithreaded version (it can't really compete in the benchmark since it's a change of algorithm but it would be fun)
[09:37:45] <dbaupp> the poster said that they were going to bench a multithreaded one sometime, so I'll leave that until then ;P ... someone else can do it though.
[09:38:34] <Thiez> multithreading this one would be easy, I'd grab the multithreading stuff from rustray
[09:38:36] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[09:38:59] <pnkfelix> dbaupp: r? https://github.com/mozilla/rust/pull/8020
[09:39:21] <pnkfelix> dbaupp: (feel free to delegate if you'd prefer e.g. for graydon to review)
[09:40:19] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[09:42:04] <dbaupp> pnkfelix: looks good to me, I guess your suggestion can happen if/when we get more complicated --cfg flags.
[09:42:24] <doener> dbaupp: hm, what am I going to do about that PR? It's closed because strcat pulled it into his rollup...
[09:43:03] <dbaupp> doener: which one? the one that failed on windows?
[09:43:25] <doener> yeah
[09:44:05] <dbaupp> just comment on the rollup with a commit to cherry pick, I guess?
[09:44:50] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[09:46:46] *** Quits: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net) (Quit: tikue)
[09:47:55] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[09:48:07] *** Quits: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com) (Ping timeout)
[09:48:08] *** Joins: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com)
[09:50:44] *** Quits: jgilbert (jgilbert@moz-4C088FCE.hsd1.ca.comcast.net) (Ping timeout)
[09:51:49] *** Quits: thpickert (thpickert@moz-24816453.tng.de) (Ping timeout)
[09:55:34] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[09:58:38] <dbaupp> doener: merging https://github.com/huonw/levgen-benchmarks/blob/master/R.rs#L78-L82 into one conditional got a few extra percent (~.34 rather than ~.36)
[09:59:24] <dbaupp> so it's officially faster than C! :D
[09:59:35] <dbaupp> *"officially"
[09:59:40] <doener> dbaupp: it's not seedable anymore though. You always get the same level
[10:00:07] <dbaupp> doener: I fixed that at the posters request
[10:00:10] <doener> dbaupp: that was "if ... { loop } if ..." before, right?
[10:00:16] <dbaupp> right
[10:00:26] <dbaupp> https://github.com/huonw/levgen-benchmarks/blob/master/R.rs#L18-L25
[10:02:25] <doener> dbaupp: the wikipedia article on the xorshift rng made me wary of that way of seeding. http://en.wikipedia.org/wiki/Xorshift -- last sentence of the first paragraph. I'm just too clueless about rngs to dare it ;-)
[10:03:00] <dbaupp> doener: yes, it's horrible seeding
[10:03:03] *** Quits: eatkinson (eatkinson@moz-AD233F1B.dia.static.qwest.net) (Quit: eatkinson)
[10:03:10] * dbaupp was convieniently ignoring that
[10:03:48] <dbaupp> and, it's mostly ok for this benchmark, because (1) the random number generation still takes the same amount of time, and (2) only the low bits are relevant anyway
[10:05:00] <dbaupp> (that is, only a "small" amount of randomness is necessary; and anyway, poor randomness will cause more overlaps, which will make the benchmark slower.)
[10:07:07] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[10:08:42] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[10:09:36] *** Quits: Earnestly (earnest@2AB30F53.FB5005.2BCC804A.IP) (Quit: WeeChat 0.4.2-dev)
[10:09:48] *** Joins: Earnestly (earnest@2AB30F53.FB5005.2BCC804A.IP)
[10:11:29] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[10:13:15] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[10:16:46] *** Quits: KindOne (KindOne@66CC4AA4.5D2364C3.EC6A1518.IP) (Ping timeout)
[10:18:02] *** Quits: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net) (Ping timeout)
[10:18:12] *** Joins: flowsnake (flowsnake@moz-1918C33E.aztw.cable.virginmedia.com)
[10:18:31] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Quit: ["Textual IRC Client: www.textualapp.com"])
[10:19:15] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[10:21:01] *** Joins: KindOne (KindOne@moz-CAC1AF11.dynamic.ip.windstream.net)
[10:22:41] <smvv> hi. I get the failure "Couldn't find field in struct type" and I would like to debug it further. The interesting part is that if I build the crate as an executable it works fine. However, if I build the crate as a DSO, the failure occurs. https://gist.github.com/smvv/6069389
[10:23:43] <smvv> therefor, i would assume that 1) the struct is not properly exported / visible in the DSO, or 2) importing the struct and its members has a bug in its current implementation
[10:32:44] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[10:33:36] *** Joins: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net)
[10:35:16] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[10:46:22] *** Joins: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[10:48:11] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Quit: ChatZilla 0.9.90.1 [Firefox 23.0/20130722172257])
[10:57:45] *** Joins: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca)
[11:00:42] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[11:04:53] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[11:06:27] *** Quits: qmx (qmx@moz-D6C3C2E6.qmx.me) (Ping timeout)
[11:07:05] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[11:07:52] *** Joins: qmx (qmx@moz-D6C3C2E6.qmx.me)
[11:10:17] *** Quits: qmx (qmx@moz-D6C3C2E6.qmx.me) (Ping timeout)
[11:12:00] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[11:13:50] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[11:19:39] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[11:19:40] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/0EoWWg
[11:19:40] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[11:22:37] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[11:22:37] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/dz4O6g
[11:22:37] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[11:22:38] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[11:22:38] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/CPER5Q
[11:22:38] <ghrust> 13rust/06auto 14de2b5c5 15Huon Wilson: test/run-fail: Un-xfail a test, make some other xfailed ones compile (they still don't work).
[11:22:38] <ghrust> 13rust/06auto 143ee4238 15bors: auto merge of #7992 : huonw/rust/un-xfail, r=z0w0...
[11:22:39] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[11:28:40] *** Parts: z0w0 (zack@moz-E12708D5.lns6.woo.bigpond.net.au) ()
[11:29:40] *** Joins: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au)
[11:31:42] <dbaupp> smvv: looks like a new bug, you should file it :)
[11:38:48] <engla> so in Rc<T>, what causes the restriction of only using T: Send or T: Freeze ?  Would allocating these using ~T  loosen the restrictions?
[11:39:25] *** Joins: judder (maradukewa@3226AE5F.7C541960.78E362FE.IP)
[11:42:27] <dbaupp> engla: I think it's to statically avoid cycles
[11:43:27] <dbaupp> (Incidentally, now that ~ has no headers, strcat was hoping to make it `~` allocated, rather than behind a raw pointer.)
[11:43:35] <engla> right
[11:43:48] <engla> of course I'm experimenting with that since it sounded like a simple change
[11:44:02] <engla> but since I don't know the underlying things well enough :) I can't tell
[11:44:22] <dbaupp> haha, just submit a pull request and see if strcat says no :)
[11:44:27] <engla> can't tell if it's safe
[11:53:12] *** Quits: huhlig-work (huhlig@moz-62A47D90.aoltw.net) (Connection reset by peer)
[11:53:23] *** Joins: huhlig-work (huhlig@moz-62A47D90.aoltw.net)
[11:56:38] <smvv> dbaupp: it is true that llvm ir is saved in `metadata' for DSOs ? because without --lib the IR is readable when I pass --emit-llvm and -S to rustc, but with --lib there's just one big encoded blob called `metadata'
[11:59:24] <dbaupp> smvv: there should be normal IR below that; that metadata is actually things like the Rust AST of functions marked with #[inline] and #[inline(always)] to make inlining work cross-crate
[12:00:23] *** Quits: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au) (Quit: gavinb)
[12:00:36] *** Joins: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net)
[12:05:55] *** Joins: LU324 (stuff@moz-A17E9A7B.dyn.embarqhsd.net)
[12:07:02] *** Joins: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au)
[12:09:31] *** Joins: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP)
[12:10:11] *** Quits: LU324 (stuff@moz-A17E9A7B.dyn.embarqhsd.net) (Ping timeout)
[12:10:36] *** Joins: Blub\w (wry@moz-88573004.vps.tuwien.ac.at)
[12:10:43] *** Joins: LU324 (stuff@moz-A17E9A7B.dyn.embarqhsd.net)
[12:12:27] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[12:14:17] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[12:14:50] *** Joins: MaikKlein2 (maik@moz-FD97565C.dip0.t-ipconnect.de)
[12:17:55] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[12:18:46] *** Quits: Blub\w (wry@moz-88573004.vps.tuwien.ac.at) (Ping timeout)
[12:19:31] <engla> isn't the same AST always present for generic methods?
[12:21:41] * dbaupp doesn't know
[12:22:34] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[12:23:35] <smvv> is it possible to dump the content of the metadata in a readable form?
[12:24:19] *** Quits: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu) (Ping timeout)
[12:25:02] <smvv> i would like to know if the field is stored in the metadata (which implies that the metadata decoder has a bug), or if the exporter has a bug 
[12:25:07] *** Joins: Blub\w (wry@moz-81ABD137.dip0.t-ipconnect.de)
[12:26:13] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[12:27:14] * smvv tries metadata::decoder::list_crate_metadata
[12:28:09] *** Joins: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu)
[12:28:28] *** Quits: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net) (Ping timeout)
[12:30:11] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[12:30:52] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[12:33:57] <gavinb> I've got a problem with transmute_copy() as shown here: http://pastebin.com/3vr9zMMD
[12:34:49] <gavinb> Essentially I'm trying to copy from a ~[u8] to [u8, ..16]. I've done a very similar thing successfully elsewhere. But in this instance, the results just don't match.
[12:35:40] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[12:36:42] *** Quits: reyre (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Ping timeout)
[12:37:18] <engla> I think you pass the wrong thing
[12:37:24] <engla> at least double check it
[12:37:37] <engla> because you pass a &~[u8] to transmute_copy
[12:38:13] <engla> and that ends with transmuting a ~[] (pointer) to a fixed size vec
[12:38:55] <bstrie> I'm wondering how I'd grep for unsafe pointers
[12:39:08] <gavinb> well I just want to copy from the variable vec to the fixed vec...
[12:39:23] <gavinb> maybe there's a better way?
[12:39:23] <bstrie> also wondering whether it would be possible to rename unsafe pointers from *foo to RawPtr<foo> :)
[12:39:27] <engla> gavinb: there must be a safe way to do it
[12:39:44] <gavinb> engla: agreed; just worried that this doesn't give a warning or anything
[12:39:47] <engla> gavinb: using safe code will also let the compiler guide you right.. transmute_copy can't even check that the sizes match
[12:40:04] <smvv> vec::raw::copy_memory ?
[12:40:06] <gavinb> engla: good point - will go digging
[12:40:54] <engla> I'm a bit surprised there is no eltcopy in vec.rs
[12:41:01] *** Quits: Blub\w (wry@moz-81ABD137.dip0.t-ipconnect.de) (Ping timeout)
[12:41:09] <engla> or move in this case
[12:41:12] <gavinb> smvv: thanks! trying now
[12:41:55] <bstrie> dbaupp: really good job jumping on that rust benchmark post so fast
[12:42:03] <engla> gavinb, I'd see if coding it with safe code is fast enough
[12:42:06] <dbaupp> bstrie: :)
[12:42:42] <gavinb> smvv: that did the trick! :)
[12:42:52] <dbaupp> bstrie: I can't quite believe that I got it faster than C on my computer... but that's presumably because there's room for improvement in the C.
[12:43:43] <dbaupp> bstrie: even so, I didn't have to do *any* contortions at all, just make it "proper" Rust & swap the RNG, and it was automagically super fast.
[12:43:46] <dbaupp> <3 Rust
[12:44:09] <bstrie> pshaw, I'm sure once we're using aliasing data we'll be so fast that our code will travel backwards in time
[12:46:06] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[12:47:38] <bstrie> some of our code will travel back to 1972 and in its transit will burn itself into a roll of dot-matrix paper
[12:48:22] <bstrie> dennis ritchie will find this and think to himself, oh hm this looks like an interesting language, but only if it didn't have seven pointers...
[12:48:33] <bstrie> and thus C was born
[12:48:50] <dbaupp> hahaha
[12:48:53] *** Joins: Blub\w (wry@moz-81ABD137.dip0.t-ipconnect.de)
[12:49:01] <bstrie> (seriously, people are saying we have SEVEN pointers now?!?)
[12:49:12] <bstrie> we really need to get rid of @
[12:49:14] <dbaupp> ~mut was listed as a pointer there... so :/
[12:49:21] <bstrie> I'm fully behind not even having sugar there for it
[12:49:32] <bstrie> force people to write GC<T>
[12:49:45] <engla> if you count library pointers, Rc<T> is one pointer and RcMut<T> is another
[12:49:56] <dbaupp> in fact, that pointer statement was wrong in 3 ways...
[12:49:58] <bstrie> dbaupp: also I'm wondering if we can get rid of *foo and have Unsafe<Foo> or something
[12:50:10] <bstrie> also UnsafeConst<Foo> and UnsafeMut<Foo>
[12:50:25] <bstrie> engla: at least it's easy for people to believe that those aren't pointers
[12:50:29] <dbaupp> no ~mut, but there is *mut and &mut.
[12:50:47] <engla> if shared_ptr<T> is a pointer it seems to be the same thing
[12:51:05] <bstrie> nobody says that C++ has five pointers even though they have shared_ptr and friends
[12:51:12] <engla> some say
[12:51:16] <dbaupp> bstrie: I'm less interested in the @ sugar for GC specifically too, and that... wouldn't be disagreeable.
[12:51:31] *** Joins: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP)
[12:51:33] <dbaupp> (also, that person missed *const and &const, so really we have 9.)
[12:51:35] <engla> I don't think counting pointers is constructive.. 
[12:51:39] <Ms2ger> Pff, Gecko has six pointers, and that's excluding stl
[12:51:59] <bstrie> engla: first impressions matter, we have to nip hearsay in the bud
[12:52:08] <bstrie> "OMG RUST IS SOOO COMPLEX IT HAS 22 POINTER TYPES"
[12:52:20] <bstrie> #go-nuts already loves to say that we're more complex than c++
[12:52:23] <Ms2ger> bstrie, but no for loop! ;)
[12:52:23] <engla> ok I understand. I'm not friends with reality
[12:52:35] <engla> but the reality might need some counterpropaganda
[12:52:39] <bstrie> indeed
[12:52:43] <bstrie> I am all about propaganda
[12:53:42] <bstrie> I'll pitch the idea of removing *foo to pcwalton
[12:54:03] <engla> I think it sounds reasonable to want to grep for unsafe pointers
[12:54:05] <bstrie> he's the one who's most up-in-arms over the defamation of rust vis-a-vis 650 pointer types
[12:54:22] <engla> but at the same time, raw pointers aren't unsafe, dereferencing them is unsafe
[12:54:33] <dbaupp> bstrie: 650? I heard it was 4351.
[12:54:43] <bstrie> dbaupp: it's multiplying at a geometric rate!!
[12:55:10] <bstrie> I'm forming ideas for the propaganda campaign
[12:55:14] <bstrie> everyone gather round
[12:55:31] <bstrie> next time you see someone say that rust has 83,711 pointer types
[12:55:32] * dbaupp gathers
[12:55:45] <bstrie> tell them that we actually have infinite pointer types, because we give you all the tools to make your own pointers
[12:56:08] <bstrie> we'll use their own hyperbole against them
[12:57:46] *** Joins: jfbk (textual@moz-EEA9CFB3.nyc.res.rr.com)
[12:59:22] <dbaupp> that's sort of reasonable. but a bit smart-ass too. ;P
[12:59:58] <bstrie> instead of smart-pointers, we'll call them smart-ass-pointers
[13:00:36] <bstrie> dbaupp: I honestly didn't even know we shipped an RNG other than isaac
[13:00:39] <Thiez> I think grepping for ':[ ]\*' will get you most of the unsafe pointers
[13:00:51] <Thiez> eh, ':[ ]*\*'
[13:01:41] <dbaupp> bstrie: yeah, at some point in the (near) future we'll possibly ship with mersenne twister and a variety of other ones. (to match C++11.)
[13:01:50] <engla> Thiez: that gets you  use std::*; too
[13:02:02] <bstrie> Thiez: ':[ ]*\*[^;]' to not also get glob-imports
[13:02:03] <Thiez> I don't really understand this trend of making working with pointers more verbose just for the sake of being able to say that we have fewer pointer types though :(
[13:02:21] * dbaupp doesn't know if people will approve of a huge number of randomness related code being dumped into std
[13:02:22] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[13:02:30] <dbaupp> *amount
[13:02:40] <Thiez> especially since the pointers are still there, but now they're in a library and have less syntactic sugar
[13:02:42] <Blub\w> verbose pointers? :|
[13:02:46] <bstrie> Thiez: it's not for that, it's because 1. people are using @ and @mut waaaay to much, and 2. people shouldn't be using * at all if they can help it and the symbol is already hugely overloaded
[13:02:54] <Blub\w> is rust going c++ with .get() and .release() now? :P
[13:03:29] <dbaupp> Blub\w: there'll be sugar for pointer borrowing: implement some traits and things will Just Work.
[13:03:40] * dbaupp hopes that's the case anyway.
[13:03:43] <Thiez> I quite like the short syntax
[13:04:24] <Thiez> I don't mind losing the short @ if we get multiple types of garbage collected pointers
[13:04:31] <Thiez> but * is nice for when you need it
[13:04:49] <engla> do you need more than one kind of GC pointer?
[13:05:14] <Ms2ger> (Clearly we should throw everything out of std)
[13:05:23] <Thiez> engla: I hear they want to use the javascript-engine for garbage collection in servo, or something along those lines
[13:05:34] <engla> hm ok
[13:06:02] <Thiez> that does sort-of make sense
[13:06:06] <monk> I think the idea was there are lots of ref counting/gc systems in C code bases to integrate with
[13:06:16] <Thiez> and some people want refcounting instead of 'proper' GC
[13:06:25] <monk> e.g. GObject?
[13:06:30] <Blub\w> refcounting is useful
[13:06:33] <doomlord> what can you really do about that. "rust has 20 pointer types!".  Its only because it DOES that i'm interested
[13:06:48] <Blub\w> I have more code benefitting from refcounting than from a "proper" gc
[13:06:49] <Ms2ger> The more, the merrier?
[13:06:53] <doomlord> if i want to make my own verbose pointers i already have c++
[13:07:17] <doomlord> if i wanted simplicity i could learn a gc-oriiented language
[13:07:19] <monk> does @ have any meaning other than gc'd pointer at the moment?
[13:07:31] <madmoose> doomlord: My argument is that C has just as many pointer types. In Rust you write them down, in C you have to keep them in your head.
[13:07:55] <engla> C has countably infinite pointer types, there is a pointer-to for every type. Recursively, too
[13:08:03] <doomlord> right - rust exists to help you manage existing complexity in a way no other language does
[13:08:12] <engla> now it's only one kind of pointer. or maybe three if you use const and volatile
[13:08:35] *** Quits: jfbk (textual@moz-EEA9CFB3.nyc.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzz‚Ä¶)
[13:08:42] <engla> restrict..
[13:08:53] <kimundi> "Rust has 3 pointer types you should care about: &, &mut and ~. It also has a lot of library smartpointers and the tools to write something custom."
[13:08:58] * dbaupp hits engla over the head for monomorphising inappropriately :P
[13:09:02] <doomlord> the go people talk about escape analysis, but if that could do everything, c++ wouldn''t exist any more
[13:09:25] <Thiez> so perhaps we should market it as 'rust has several pointer specializations that are much easier and safer to work with that C-pointers' rather than aiming to eliminate pointers
[13:09:57] <dbaupp> monk: no
[13:10:09] <doomlord> i like the fact rust has both extreme with convinient syntax. you could write a program with the 'convinience' of 100% @ use , or the unsafety/speed/control of * everywhere. or anything in between
[13:10:24] <dbaupp> monk: (in fact, @ is actually currently a reference-counted poinetr.)
[13:10:27] <dbaupp> *pointer
[13:10:33] <kimundi> monk, dbaupp: Actually.... It's also a pattern
[13:10:39] <doomlord> i think this is a good thing, considering that there are mixed language projects eg underlying C engine with Python embedded
[13:10:42] <monk> yeah I wondered if it was used in patterns
[13:10:44] <bstrie> doomlord: the problem is that `@` isn't convenient at all, it plays poorly with basically every other important system
[13:10:47] <dbaupp> kimundi: true
[13:11:11] <doomlord> wouldn''t it just be better if you had Rust, with * for the clike parts and @ for the python/java/c# whatever like parts
[13:11:14] <kimundi> As in, apart from being the pattern for unwraping a @ptr
[13:11:31] <Thiez> dbaupp: not entirely true taht @ is only one think
[13:11:33] <Thiez> rusti: match Some(3) { x @ Some(_) => x, _ => Some(0) }
[13:11:34] -rusti- Some(3)
[13:11:37] <doomlord> bstrie, but isn't that just when you try to mix them wrongly
[13:11:37] <monk> is it used for binding a name in a pattern like in haskell? eg. x@Some(2) // x is bound to the whole of Some(2) ?
[13:11:42] <monk> right yep
[13:11:45] <Thiez> monk: yes.
[13:11:57] <dbaupp> Thiez: (kimundi was just saying this ;P )
[13:12:15] <Thiez> I didn't notice as I was trying to get the syntax right in a query with rusti ;)
[13:12:27] <monk> okay, was just wondering if * could be replaced with @ for removing the usual * ambiguity :P
[13:12:28] <dbaupp> doomlord: but mixing them "rightly" is hard. especially with @mut
[13:12:29] <bstrie> doomlord: there's no way to inherit mutability through a @. if your ~ contains a @, it isn't sendable. if you want to mutate something that's @mut you run the risk of dynamic failures
[13:12:34] <kimundi> dbaupp: But Thiez actually knew the syntax, so... xD
[13:12:35] <doomlord> or are you saying that the  idea of one languae handling both extremes is too ambitious
[13:12:54] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[13:12:54] <dbaupp> kimundi, Thiez: yay for teamwork! :D
[13:12:57] <monk> apparently I knew the syntax without ever seeing it in rust. rust++
[13:13:08] <Thiez> kimundi: I just guessed correctly
[13:13:15] <Thiez> never used it before
[13:13:58] <kimundi> with for ... in... , we could propapbly replace that with the 'in' keyword though?
[13:14:10] <doomlord> are there just combinations you can restrict... like ban ~'s from containing @s.. and disallow borrowing @mut 
[13:14:43] <Thiez> doomlord: no, there is no reason why ~ can't contain @, but it just won't be Send
[13:14:45] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[13:14:45] <bstrie> doomlord: basically the problem is that @ is a pile of special cases such that it's an entirely different dialect of rust, and the *big* problem is that the *only* reason that you *should* use @ is when you want to make cycles. full stop
[13:14:50] <bstrie> @ isn't for convenience
[13:14:53] <bstrie> it's for cycles
[13:14:57] <kimundi> match Some(3) { x in Some(_) => x, _ => Some(0) } // Does that look  bad?
[13:15:03] <doomlord> maybe you'd basically have 2 standard libraries (stuff for @ and stuff for &+~) but thats still better than a mixed language project
[13:15:13] <Thiez> * is for cycles :p
[13:15:30] <doomlord> you could layer the libraries... rust zero -> rust ~& -> rust @
[13:15:46] <engla> bstrie: not just for cycles? shared data too
[13:15:55] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[13:16:34] <doomlord> is there anything wrong with @ for an exploratory phase of coding when you don't quite know what you'll end up with
[13:16:54] <bstrie> engla: I suppose. I still don't want to encourage it, we have a very big problem where all our early documentation seemed to assume that new users should be using @ everywhere, and then it would be trivial to rewrite it to be more idiomatic later. but it's actually quite hard to remove @ once they've snuck in
[13:17:24] <dbaupp> bstrie: @ without mut is *really* hard to make into a cycle
[13:17:35] <doomlord> ... and @ to avoid needing to embed a dsl (use interpretted rust as its own extention language :) )
[13:17:47] <doomlord> ^embed a scripting language..
[13:17:55] <bstrie> doomlord: we have rusp for that :P
[13:18:12] * bstrie actually unsure what rusp is supposed to be
[13:18:23] *** Joins: bent (chatzilla@moz-2CD73AA6.triad.res.rr.com)
[13:20:26] <doomlord> it would be a shame if you lost @ IMO
[13:20:39] <dbaupp> bstrie: dead and dying :P
[13:21:04] <bstrie> doomlord: we wouldn't be removing managed pointers from the language, we'd just be moving them out of the compiler and into a library and possibly removing the @ sugar for them
[13:22:05] <bstrie> doomlord: part of this work would also be adding code to make it so that users can implement first-class pointers, with autoderef and autoborrowing
[13:22:08] <doomlord> moving into a library so one could make it refcounting -  :) .. removing @sugar ... :(
[13:22:49] <bstrie> we might make it so that users can use the @ on whatever library pointer type they want
[13:22:56] <bstrie> rather than just on Gc<T>
[13:22:57] * kimundi still has thet @Gc, @Rc, ... Proposal flying around...
[13:23:14] <bstrie> but I'd prefer if there was not type that uses @ by default
[13:23:18] <bstrie> make people opt-in to it
[13:23:57] <kimundi> Rust seems to be all about being customizable and not hardcodod to many concepts these days
[13:24:00] <bstrie> and even still I'd really just prefer to remove it :P
[13:24:24] <bstrie> kimundi: implementing a browser engine requires a lot more flexibility than anyone thought!
[13:24:37] *** Quits: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au) (Quit: gavinb)
[13:24:56] <bstrie> it's almost like we're beginning to understand why C++ is so unfathomably vast :)
[13:25:23] <Ms2ger> Ha
[13:25:28] <doomlord> does it help anything to dissalow cycles in library code using @ - and leave Gc to later
[13:26:00] <kimundi> I think we're at the point now where you can write a standalon rust program in under 100 lines that doesn't use ANYTHING else
[13:26:26] <bstrie> doomlord: our library code will already try to minimize usage of @ as much as possible, because otherwise you wouldn't be able to send a lot of things
[13:26:34] <bstrie> also because @ has more time and space overhead
[13:26:38] <kimundi> we can opt-out the prelude, opt-out std, define own lang items, lang items are optional if you don'tu se tdhem, etc
[13:27:04] <bstrie> a ~ that contains a @ takes up more space that a usual ~
[13:27:05] <mitsuhiko> what's the current state on @ anyways?
[13:27:20] <bstrie> mitsuhiko: what was the last thing you heard? :)
[13:27:44] <mitsuhiko> syntactic sugar for piping allocations through helper impls
[13:27:49] <mitsuhiko> as far as moving code into closures
[13:27:59] <mitsuhiko> that was from a few weeks ago
[13:28:02] <bstrie> mitsuhiko: the plan appears to be to go ahead with moving managed pointers out into a Gc<T> type in the stdlib, and with that would be traits that any user could implement to get the expected pointer behavior (autoderef, autoborrowing)
[13:28:36] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[13:29:08] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[13:29:30] <bstrie> mitsuhiko: as to the fate of the @ sigil, still undecided
[13:29:40] <kimundi> The Gc<T> -> @Gc proposal would just be a syntactic addon on top of the semantic change anyway
[13:29:55] <kimundi> So, in a way unrelated really
[13:30:01] <mitsuhiko> bstrie: if the utilization of that sucks as much as ARC then meh
[13:30:23] <bstrie> mitsuhiko: utilization?
[13:30:29] <mitsuhiko> i like the idea of using the @ sigil to free up for code restructuring behind the scenes to give ARCs and other things a nicer api
[13:30:42] <mitsuhiko> bstrie: i mean the fun of using a Gc<T>
[13:30:55] <mitsuhiko> ARCs feel very, very foreign
[13:31:15] <bstrie> mitsuhiko: we're just following the python philosophy of making ugly operations ugly :) managed pointers cause a lot of pain once you decide to use them
[13:31:39] <mitsuhiko> oh, i'm all for removing managed pointers as much as possible
[13:31:41] <doomlord> i would use refcounting more than GC, so if @ was kept as RefCounting it would be a step forward
[13:31:51] <mitsuhiko> doomlord: meh
[13:31:55] <bstrie> doomlord: without CC, you mean?
[13:32:06] <doomlord> refcounting, without cycles.
[13:32:09] <mitsuhiko> I liked the idea of @ being annotated to refer to a special memory management abstraction
[13:32:26] <mitsuhiko> @RC etc.
[13:32:41] <dbaupp> mitsuhiko: in theory the pointer-traits would allow ARC to be automatically borrowed to &, to avoid the call to .get(), etc.
[13:33:11] <mitsuhiko> dbaupp: the main problem is that you still need closures for those things to work with the borrow checker as far as i understand
[13:33:16] <doomlord> if i want to type that much i might aswell stick with C++ where i can do Rc<T> :)
[13:33:26] <mitsuhiko> but the last proposal i saw moved code automatically into closures
[13:33:34] <mitsuhiko> so quite evolved syntactic sugar
[13:33:42] <bstrie> doomlord: you can make it shorter by aliasing to just R<T> :P
[13:33:42] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[13:33:54] <dbaupp> mitsuhiko: are you talking about the mutable ARCs?
[13:34:19] <mitsuhiko> dbaupp: i am mostly talking about Gc<T>
[13:34:27] <mitsuhiko> but mutable arcs have the same problem
[13:34:38] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Ping timeout)
[13:34:38] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[13:34:38] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/CPER5Q
[13:34:38] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[13:34:46] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[13:34:48] <kimundi> As far as I know, a expression like 'let x = @Gc foo()' would have to be sugar for 'let x = Gc::new(|| foo())'
[13:35:04] <dbaupp> mitsuhiko: right. the price of memory safety.
[13:35:09] <kimundi> because it would allow in-place writing of the expression
[13:35:11] <doomlord> U<T>  ... T<X,Y,Z> for tuples.. R<T> .  quite a bit of the appeal of rust is fresh syntax compared to what i can hack in with templates in c++
[13:36:32] <mitsuhiko> kimundi: yeah, but that's the simple one
[13:37:08] <kimundi> There is also the unsolved problem about how to generalize over unsized types
[13:37:11] <mitsuhiko> arcs use closures much more :)
[13:37:14] <engla> doesn't rust already support in-place writing of returned values?
[13:37:19] <engla> in general
[13:37:26] <Thiez> how would one pattern match on Rc<T>? it would have the refcount as a private member, I would assume?
[13:37:38] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[13:37:38] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/YrMTxA
[13:37:38] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[13:37:39] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[13:37:39] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/P01IYA
[13:37:39] <ghrust> 13rust/06auto 141ce1411 15G√°bor Horv√°th: Added missing memory orderings for atomic types.
[13:37:39] <ghrust> 13rust/06auto 145102853 15bors: auto merge of #7993 : Xazax-hun/rust/master, r=bblum...
[13:37:39] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[13:37:40] <mitsuhiko> engla: yes, but there is some optimization that can be done if it goes through the closure indirection
[13:37:47] <engla> oh ok
[13:37:47] <mitsuhiko> but don't ask me which one :)
[13:38:22] <mitsuhiko> Thiez: i would assume an Rc<T> is a struct and not an enum
[13:38:33] <mitsuhiko> for a start because the refcount neeeds to be mutable
[13:38:41] <mitsuhiko> so you would not pattern match on it
[13:38:57] <engla> Rc<T> is a struct around a pointer to the inner representation of Rc
[13:38:58] <dbaupp> mitsuhiko: I believe engla is talking about the return value optimsation that happens for closures
[13:39:19] <mitsuhiko> ignore me then
[13:40:04] <bstrie> are there separate RVOs for closures vs everything else?
[13:40:04] <mitsuhiko> ah. you get me confused. i was replying to Thiez
[13:40:11] <engla> Rc<T> is very simple and will be simpler if this refactor to just alloc using ~T is working
[13:40:16] <dbaupp> bstrie: don't think so
[13:40:27] <mitsuhiko> i really want to find that proposal now but i can't find it
[13:40:30] <dbaupp> bstrie: but I don't know.
[13:40:30] <mitsuhiko> i believe it was a gist of sorts
[13:40:39] <dbaupp> mitsuhiko: https://gist.github.com/Kimundi/5744578 ?
[13:40:56] <kimundi> The optimisation is basically that 'let alloc: *mut T = (|| foo() )()' can be optimized to 'let alloc: *mut T; (|ptr| ptr = foo() )(alloc)'
[13:40:58] <mitsuhiko> dbaupp: that looks familiar
[13:41:30] <doomlord> well if you do generalize it..  i hope you can still make @ default to being either gc or rc .. whichever of those more people woudl find useful
[13:41:45] *** Joins: reyre (reyre@86C3727C.33EE9F8A.1139E686.IP)
[13:42:44] <mitsuhiko> dbaupp: yeah. that gist is what i saw last
[13:43:21] <dbaupp> wow, LDC is crazy fast. It's now at .41s vs. 62s for Rust, doing essentially the same thing.
[13:43:24] <kimundi> doomlord: I think in either way tho goal is to NOT have something that's is harcodod to one thing. And being able to chinge the meaning of the sigil itself on the fly is horrible.
[13:44:05] <doomlord> wouldn't it be simimlar to just having the ability to overload ::new and ::delete in c++
[13:44:19] <bstrie> dbaupp: are they using libc?
[13:44:25] <bstrie> for their rng
[13:44:28] <doomlord> or similar to any other operator overloading
[13:44:30] <dbaupp> bstrie: nah, using Xorshift too
[13:44:47] <bstrie> dbaupp: examine the assembly! :)
[13:45:03] <dbaupp> bstrie: (they were between clang and gcc but xorshift made it jump faaar ahead.)
[13:45:04] <kimundi> doomlord: Well, if it's just about the initialisation expression and not the type name, than that would be fine I think
[13:45:09] <SiegeLord> LDC can dump LLVM ir too, if that's easier to read
[13:45:15] <dbaupp> bstrie: this is the articles numbers...
[13:46:45] <kimundi> 'let managed: Gc<_> = @foo(); let counted: Rc<_> = @bar()' as sugar for a trait call: 'let managed: Gc<_> = Smartpointer::new(|| foo()); let counted: Rc<_> = Smartpointer::new(|| bar())'
[13:46:48] <bstrie> dbaupp: we need to optimize some more then :)
[13:48:15] <kimundi> Quick! Someone push a 'fix' that harcodes that benchmark to optimized assembler!
[13:48:23] <kimundi> ;)
[13:48:34] * dbaupp did an assignment like that once
[13:48:49] <bstrie> dbaupp: what parameters were they using for this program?
[13:49:03] <dbaupp> (well, compiler-optimised assembler.. who does a benchmark competition without compiler optimisations??)
[13:49:07] <dbaupp> bstrie: in what sense?
[13:49:35] <bstrie> dbaupp: I compiled the program, now I want to run it. wondering what parameters the article used
[13:49:45] <dbaupp> bstrie: oh, no idea.
[13:49:53] <bstrie> well what were you using :P
[13:50:10] <kimundi> "The clipboard"
[13:50:13] <dbaupp> just whatever... ran a few different ones and took the mininum
[13:50:25] <dbaupp> *minimum
[13:50:46] <doomlord> >>"And being able to chinge the meaning of the sigil itself on the fly is horrible." ...i'm just suggesting you pick Rc or Gc semantics to be permanent as the meaning of @ on its own .. whichever one pleases most people. to me it seems either one is sufficiently useful to deserve a single symbol, decluttering code significantly compared to C++. if you start having to write things like @Gc .. IMO you lose a lot of the languages' 
[13:50:46] <doomlord> appeal as being 'cleaned up'
[13:51:08] <dbaupp> gah, seriously? bool doesn't implement Zero.
[13:51:19] <cmr> doomlord: the problem with the current @ is that it's slow and leaks cycles
[13:51:25] <doomlord> its like there you have to learn @ as a  different syntax for templates.. 
[13:51:25] <cmr> refcounting is slow
[13:51:43] *** Joins: timm (timm@moz-37B954AF.superkabel.de)
[13:52:06] <doomlord> or could you make it @Rc @Gc until version 0.999 and take a call on whicih one is the best default for plain @ on empirical evidence
[13:52:53] <SiegeLord> Damn, my ldc2 can't compile that code >_<
[13:52:57] <bstrie> dbaupp: I'm concerned about that print statement in a loop, it's probably very inefficient given our current io state
[13:52:59] <SiegeLord> Let's see if upgrading helps
[13:53:00] *** Joins: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net)
[13:53:07] <kimundi> doomlord: Disclaimer: I have zero real world exprience. But I think rust tries very hard to converge towards "Use the stack if possible. If that doesn't work use ~. If that still doesn't work pick the library smartpointer best suited for your use case"
[13:53:18] <dbaupp> bstrie: it's miniscule: removing it entirely had no effect for me
[13:53:40] *** Quits: reyre (reyre@86C3727C.33EE9F8A.1139E686.IP) (Client exited)
[13:53:54] <kimundi> That is, neither Rc nor Gc have any advantages to each other tham makes one better, so neither should be hardcoded in the language
[13:53:56] <doomlord> its true but what i'm saying is a big part of rusts appeal - or potential niche it seems to me - is the cases where people feel they had to move to a mixed language project.
[13:54:02] <bstrie> dbaupp: maybe we should add this to the new benchmark tests :)
[13:54:37] <dbaupp> bstrie: yeah... not sure what exactly it's testing?
[13:54:42] <doomlord> a C++ program includes GC through python.. and there's people working in C# but calling underlying C++.  with rust having @, you could do both jobs 
[13:55:32] <doomlord> changing pointer types seems easier than "writing in C# and moving to C for optimized code"
[13:56:19] <SiegeLord> I don't think people use other languages for their GC per se...
[13:56:27] <cmr> kimundi: what does "on the fly" mean, exactly?
[13:56:28] <doomlord> " That is, neither Rc nor Gc have any advantages to each other tham makes one better, so neither should be hardcoded in the language" <<< on the contrary, i would argue they do
[13:56:49] <kimundi> cmr: where?
[13:56:49] <doomlord> ^i would argue they moved to other lanugages mainly for the GC
[13:57:18] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[13:57:19] <cmr> "And being able to chinge the meaning of the sigil itself on the fly is horrible."
[13:57:19] <SiegeLord> It seems to me they move away from C's manual memory management... and other languages solve that with a GC
[13:57:32] <SiegeLord> Rust solves manual memory management using a different way
[13:57:35] <bstrie> dbaupp: yeah, getting rid of the print only took me from 0.627 to 0.594
[13:57:49] <dbaupp> bstrie: wow, that's much bigger than i remember seeing...
[13:57:52] * dbaupp tests again.
[13:58:07] <bstrie> dbaupp: originally I forgot to turn on optimization so I was getting 7sec runtimes, thought my machine was just really really slow :P
[13:58:19] <bstrie> dbaupp: I just commented out the call to print_lev in main
[13:58:27] <kimundi> cmr: Ah, I thought doomlord was proposing somethink like a #[@=Rc]; module attribute or even somethink like with_ptr! Rc { ... @foo() ...}
[13:58:41] <bstrie> might be more accurate to comment out the calls to print directly, but expect llvm would eliminate those loops
[13:59:05] <bstrie> btw, unopt rust code? dear god so bad
[13:59:16] <engla> kimundi: is there a real reason for that? Seems crazy
[13:59:23] <doomlord> i'd be happy with @T being either @gc T or @rc T permanently, and both explicit options existing too
[13:59:36] <dbaupp> bstrie: ok, yeah, that takes it to 0.32/0.33 for me. (rather than 0.34/0.35.)
[13:59:48] <bstrie> dbaupp: your machine is faster :P
[13:59:49] <kimundi> cmr: hence the "horrible" :P 
[14:00:15] <doomlord> as for which it should be i dont know :)
[14:00:23] <engla> use Ptr = extra::rc::Rc;
[14:00:24] * dbaupp dances at his comprehensive defeat of bstrie
[14:00:24] <bstrie> dbaupp: but it looks like my machine is basically equal to the article
[14:00:35] <dbaupp> bstrie: *bow to me*
[14:00:40] <bstrie> 0.627 vs 0.620
[14:00:46] * bstrie prostrates himself
[14:00:47] <dbaupp> bstrie: errr... yeah. it does. do you have ldc?
[14:00:57] <bstrie> no
[14:01:20] <bstrie> and by "machine" I mean this vps that's running like centos 6
[14:01:57] <dbaupp> haha
[14:02:00] <bstrie> so I'm not even sure if ldc is supported, and if I had to compile it it would take quite a while
[14:02:13] <bstrie> takes like 90mins to compile rust+llvm
[14:02:24] <dbaupp> it seems I can't install ldc from debians package manager. :(
[14:02:35] * dbaupp hits the broken dependencies harder
[14:02:46] <SiegeLord> Damn, my LDC can't even compile that benchmark XD
[14:02:48] <doomlord> tangentially, is generalizing pointer types the sort of thing that would benefit from a  template-as-template parameter.. suppposedly something haskell can do, something i've heard people look down on c++ for not having
[14:03:05] <bstrie> dbaupp: btw my methodology is "perf stat -r 5 ./foo"
[14:03:25] <dbaupp> bstrie: I'm just running with `time`
[14:03:29] * dbaupp tries stat
[14:03:34] <doomlord> (eg doSomething<P,T>( x:P<T>  )..  that sort  of thing..)
[14:03:47] <bstrie> bjz_: we need your D skills!
[14:03:52] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[14:03:58] <doener> hm, what's up with deprecating closures?
[14:04:16] <monk> doomlord: hmm, possibly you're thinking of higher-rank polymorphism?
[14:04:37] <engla> doener: something similar to this http://smallcultfollowing.com/babysteps/blog/2013/05/30/removing-procs/
[14:04:37] <doomlord> yeah sorry  i dont know the jargon
[14:04:50] <bjz_> bstrie: haahwah?
[14:05:21] <monk> doomlord: I think so if I understood you correctly - basically pass a polymorphic function as an argument but not lose the polymorphicness
[14:05:25] *** Joins: dherman (dherman@8A703D98.AE3E6FBC.FEA76598.IP)
[14:05:25] *** ChanServ sets mode: +o dherman
[14:05:52] <monk> though I thought you could do that sort of thing in C++ for some reason, hmm
[14:05:53] <bstrie> bjz_: there's a post making the rounds where we're getting trounced by D, but nobody here has figured out how to install ldc!
[14:05:55] <dbaupp> bstrie: ok, with the more accurate timing .36 -> .34 (for removing printing) (GCC is .37 and clang is .44 with the same method.)
[14:06:14] <dbaupp> (i.e. using stat to measure, not removing printing.)
[14:06:50] <bstrie> bjz_: https://togototo.wordpress.com/2013/07/23/benchmarking-level-generation-go-rust-haskell-and-d/
[14:06:55] <bjz_> bstrie: I never could figure out how to install it
[14:06:58] <bstrie> haha
[14:07:01] <bstrie> then all is lost :)
[14:07:08] <dbaupp> ooh! removing printing takes clang to .35, but gcc doesn't change.
[14:07:13] <bjz_> bstrie: I don't think it works on osx :/
[14:07:23] <SiegeLord> I had a working copy, but it was too old... and now I broke it while upgrading it >_<
[14:07:29] <bjz_> bstrie: try asking on #d
[14:07:38] <SiegeLord> Maybe I should upgrade LLVM, but that'll take even more time
[14:07:50] <bjz_> :)
[14:08:05] <bstrie> bjz_: question is, do we tell them that our intent is to look at their emitted bytecode so that we can figure out how to beat them? :P
[14:08:29] <bjz_> 'hey folks, we want to beat you. how do we install ldc?'
[14:08:42] <doomlord> could c++ function overloading theoretically  be emulated with a shim function that just stuffs ALL the parameters into a tuple. (i could generatee such a thing)
[14:08:51] <bstrie> dbaupp: also I think that they're now compiling with D's "no bounds checks" compiler flag, are we doing bounds checks still or do iterators take those out?
[14:09:05] <dbaupp> bstrie: iterators remove them
[14:09:15] <sigma> arch has a package for ldc that seems to work :)
[14:09:26] <bjz_> meh, the entirety of #rust should connect to #d and give them a 200% boost
[14:09:30] <bjz_> :)
[14:09:42] <cmr> 'pacman -S ldc'
[14:09:47] <cmr> *cough*
[14:09:57] <dbaupp> bstrie: (that is, the vec iterator uses raw pointers so it doesn't have bounds checks.)
[14:09:58] <engla> chasing benchmarks is clearly a race to the bottom ;-)
[14:09:58] <cmr> So what am I compiling?
[14:09:59] <bstrie> dammit arch, you're so modern!
[14:10:12] <bstrie> cmr: https://togototo.wordpress.com/2013/07/23/benchmarking-level-generation-go-rust-haskell-and-d/
[14:10:15] * dbaupp has a good excuse http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=%23664876
[14:10:17] <cmr> oh sigma beat me too it
[14:10:48] <cmr> I am not fond of people using rust in the wild
[14:10:57] <cmr> it's so immature :(
[14:11:00] <bjz_> cmr: aye
[14:11:02] <bjz_> :(
[14:11:10] <dbaupp> cmr: (this code was originally pretty wild too. :/ )
[14:11:17] *** Joins: Guest (textual@BBE7C46A.B4F11D08.8612FA94.IP)
[14:11:27] <bjz_> dbaupp: your code was great
[14:11:28] <sigma> yeh, they don't mention the word "alpha" anywhere in that article
[14:11:36] <cmr> pre-alpha!
[14:11:40] <dbaupp> bjz_: thanks :)
[14:12:03] <bjz_> seen this? http://forum.dlang.org/thread/mwgpybjozghhwhfgulis@forum.dlang.org
[14:12:05] <cmr> dbaupp: you want llvm from D-XorShift.d ?
[14:12:11] <bstrie> sigma: they do say "0.8-pre"
[14:12:22] *** Joins: mib_ebqt1b (Mibbit@moz-D3D15A0C.vie.surfer.at)
[14:12:25] <dbaupp> cmr: timing to begin with
[14:12:33] <dbaupp> cmr: (compared to Rust.)
[14:12:42] <dbaupp> cmr: the R.rs, not the stack-vectors one.
[14:12:49] * sigma just did /alpha and /pre-release
[14:12:51] <Ms2ger> What's pre-alpha? Omega?
[14:12:52] <cmr> Is https://github.com/logicchains/levgen-benchmarks up-to-date?
[14:13:06] <cmr> Ms2ger: Nil
[14:13:07] <dbaupp> cmr: for Rust, yes
[14:13:12] <cmr> ok
[14:13:23] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[14:13:54] <dbaupp> Ms2ger: Œ∞
[14:14:06] <dbaupp> "GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND TONOS" apparently
[14:14:19] <bstrie> haha
[14:14:51] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[14:15:02] <dbaupp> "Rust is lowercase-upsilon-with-some-diacritics people, you shouldn't be using it"
[14:15:03] *** Joins: reyre (reyre@86C3727C.33EE9F8A.1139E686.IP)
[14:15:08] <Ms2ger> Nicely done, sir
[14:15:11] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[14:15:35] <cmr> rust: task failed at 'index out of bounds: the len is 1 but the index is 1', R.rs:10
[14:15:40] <cmr> dbaupp: up to date, eh?
[14:15:43] <cmr> :p
[14:15:54] <dbaupp> cmr: oh, you need to pass an arg
[14:15:58] <bjz_> dbaupp: what do you think of: "to pass a heap-allocated vector by reference I need to use myFunc(& mut myVector) (even though it‚Äôs already a mutable vector), and the function receiving it needs myAlias:&mut~[myVector] in its type signature, like fn myFunc(myAlias:&mut ~[myVector]) {..}. "
[14:16:05] <Ms2ger> cmr, he didn't say "correct" ;)
[14:16:08] <cmr> dbaupp: which wouldyou like me to use?
[14:16:13] <cmr> Ms2ger: touche
[14:16:19] <dbaupp> cmr: (the C ones just segfault.)
[14:16:28] <dbaupp> cmr: your favourite number
[14:16:33] <dbaupp> cmr: doesn't really matter
[14:16:35] <cmr> 421
[14:16:37] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[14:16:39] <cmr> *42!
[14:16:52] <Ms2ger> 42 factorial?
[14:17:00] <cmr> 42 exclamation point
[14:17:24] <dbaupp> bjz_: it's true, if he wants to .push
[14:17:26] <cmr> dbaupp: 1.560s
[14:17:37] <dbaupp> cmr: with -O?
[14:17:42] *** Joins: pyrac (pyrac@moz-873BFA0.w90-5.abo.wanadoo.fr)
[14:17:43] <cmr> yes
[14:17:45] <cmr> netbook
[14:18:10] <dbaupp> bjz_: which makes me look at the code: he doesn't ever need to push like that.
[14:18:20] * dbaupp missed a spot
[14:18:32] <bjz_> dbaupp: yay. can you fix it?
[14:19:00] <dbaupp> bjz_: but yeah, &[thing] and &mut [thing] are entirely fine for that code (he was writing &mut ~[x] for read only things originally.)
[14:19:13] *** Joins: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP)
[14:19:29] <bjz_> yeah I thought it was &mut [T]
[14:20:17] <dbaupp> well, maybe that.
[14:20:29] <cmr> D-XorShift.d: Error: module D-XorShift has non-identifier characters in filename, use module declaration instead
[14:21:17] <SiegeLord> Rename the file to something without the -
[14:21:28] <SiegeLord> I've no idea how the person managed to leave it like that :P
[14:21:32] <cmr> yeah
[14:21:35] <doomlord> on the subject of smartpointers could one theoretically sugar handles aswell @h maybe ... i supopse you'd have to match on those for access...
[14:22:12] <doomlord> i think of the win32 api with HWND everywhere and gl with its resource handles too
[14:22:20] <cmr> "ldc2 -O3 DX" has been sitting there for 2 minutes
[14:22:28] <cmr> Is it really that slow / did I invoke it wrong?
[14:22:49] <SiegeLord> Hah, that's what's been happening to me too
[14:23:06] <dbaupp> yay, rustc isn't the slowest compiler around \o/
[14:23:17] <kimundi> doomlord: What would handle be of a type?
[14:23:19] <SiegeLord> It hung almost certainly
[14:23:27] <SiegeLord> LDC is slow, but not *that* slow :P
[14:23:51] <doomlord> @h Window  .. @h Texture..
[14:24:02] <dbaupp> SiegeLord: this is #rust, we don't want to hear such things :P
[14:24:04] <bjz_> doomlord: sugaring gl handles?
[14:24:08] <doomlord> match (x:@h Window) { Some(Window) => ......  }
[14:24:23] <cmr> I'm using the latest official LDC, 0.11.0,so perhaps that's too old..
[14:24:44] * cmr goes to his desktop to compile a newer one
[14:24:46] <SiegeLord> I got the latest master, still shows the same behavior
[14:24:58] <SiegeLord> My LLVM was 3.2svn though... so I'm upgrading LLVM atm
[14:25:07] <sigma> "yaourt -Ss ldc-git"
[14:25:25] <doomlord> i guess it wouldnt really be a match, more a function that resolves the handle to extract an Option<T> from @h T
[14:26:53] * ChrisMorgan is really getting into ~, & and &mut now and actually understands what they're doing pretty well, even with lifetimes! But not @.
[14:27:23] <bstrie> dbaupp: damn damn damn, this makes no sense. do you see the part where v gets turned from a string to an int, then immediately from an int to a string? why does *removing* that make use *slower*????
[14:27:46] <dbaupp> bstrie: seriously??
[14:28:08] <bstrie> dbaupp: takes us from 0.59 to 0.62
[14:28:21] <bstrie> dbaupp: and this is literally just parsing the argument
[14:28:29] <bstrie> it's not even in a loop
[14:28:34] <bstrie> this makes no sense
[14:28:38] <doomlord> if you were to completely generalize ptrs might you just be sugaring the template syntax i.e. reducing the amount of brace nesting.  @Foo B == Foo<B> @Foo@Bar@Baz T = Foo<Bar<Baz<T>>>
[14:28:53] <dbaupp> bstrie: that is pretty strange. :/
[14:29:40] <SiegeLord> Hmm... I just built LLVM in 10 minutes... why does it take so much longer with Rust's LLVM
[14:30:09] <dbaupp> bstrie: 0.351 with the parsing (20 runs)
[14:30:20] <Earnestly> SiegeLord: tests?
[14:30:36] <dbaupp> bstrie: 0.357 without it
[14:30:46] <SiegeLord> Earnestly: LLVM has tests that Rust's system runs?
[14:30:46] *** Joins: novabyte (Instantbir@moz-D52819E1.mullvad.net)
[14:30:47] * dbaupp hits head against wall repeatedly
[14:30:55] <bjz_> doomlord: looks like function composition :P
[14:31:05] <dbaupp> SiegeLord: do you have ccache?
[14:31:13] <SiegeLord> Not sure
[14:31:39] <dbaupp> SiegeLord: (and/or you may've been building without asserts... which rust doesn't do.)
[14:31:54] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Quit: Leaving.)
[14:32:50] <SiegeLord> dbaupp: Looks like I build less targets
[14:33:05] <bjz_> rusti: fn hd<T:Clone, V:Index<T,uint>>(v: V) -> T { v[0] } hd([1, 2, 3])
[14:33:06] -rusti- <anon>:7:61: 7:63 error: failed to find an implementation of trait std::ops::Index<<V4>,uint> for [int, .. 3]
[14:33:06] -rusti- <anon>:7          fn hd<T:Clone, V:Index<T,uint>>(v: V) -> T { v[0] } hd([1, 2, 3])
[14:33:06] -rusti-                                                                       ^~
[14:33:06] -rusti- application terminated with error code 101
[14:33:11] <SiegeLord> I only build X86 and X86_64, while Rust also builds MIPS and ARM
[14:33:18] <bjz_> >:[
[14:33:20] <SiegeLord> I build with assertions and enable-optimized
[14:33:26] <dbaupp> bjz_: you have the args backwards
[14:33:33] <dbaupp> *args to Index
[14:33:43] <bjz_> rusti: fn hd<T:Clone, V:Index<uint,T>>(v: V) -> T { v[0] } hd([1, 2, 3])
[14:33:44] -rusti- <anon>:7:61: 7:63 error: failed to find an implementation of trait std::ops::Index<uint,<V4>> for [int, .. 3]
[14:33:44] -rusti- <anon>:7          fn hd<T:Clone, V:Index<uint,T>>(v: V) -> T { v[0] } hd([1, 2, 3])
[14:33:44] -rusti-                                                                       ^~
[14:33:44] -rusti- application terminated with error code 101
[14:34:00] <engla> isn't the Index trait "out of order" at the moment?
[14:34:19] <dbaupp> bjz_: oh, yeah, [,..] entirely sucks at traits.
[14:34:21] <engla> closed for renovations
[14:34:25] <Ms2ger> That's a nice way to put it
[14:34:34] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[14:34:42] <bjz_> dbaupp: we need an issue for it not impling index
[14:34:43] <dbaupp> rusti: fn hd<T:Clone, V:Index<uint,T>>(v: V) -> T { v[0] } hd(~[1, 2, 3])
[14:34:43] -rusti- <anon>:7:61: 7:63 error: failed to find an implementation of trait std::ops::Index<uint,<V4>> for ~[int]
[14:34:44] -rusti- <anon>:7          fn hd<T:Clone, V:Index<uint,T>>(v: V) -> T { v[0] } hd(~[1, 2, 3])
[14:34:44] -rusti-                                                                       ^~
[14:34:44] -rusti- application terminated with error code 101
[14:35:00] <dbaupp> bjz_: ^ nothing does, it seems.
[14:35:10] <bjz_> that is a huge oversight
[14:35:15] <dbaupp> bjz_: (as engla said, Index is closed for renovations.)
[14:35:28] <bjz_> is there a get function for vectors?
[14:35:47] <dbaupp> which returns?
[14:35:55] <bjz_> rusti: [1, 2, 3].get(0)
[14:35:56] -rusti- <anon>:7:9: 8:5 error: type `[<VI2>, .. 3]` does not implement any method in scope named `get`
[14:35:56] -rusti- <anon>:7          [1, 2, 3].get(0)
[14:35:56] -rusti- <anon>:8     };
[14:35:57] -rusti- error: aborting due to previous error
[14:35:57] -rusti- application terminated with error code 101
[14:36:11] <dbaupp> T or Option<T> or something?
[14:36:14] <bjz_> something like that?
[14:36:26] <dbaupp> don't think so :(
[14:36:43] <bjz_> (&self, uint) -> T
[14:36:52] <bjz_> lame
[14:37:13] <bjz_> curse you [T,..n]!
[14:37:14] <engla> swap_remove is like that
[14:37:28] <engla> fn swap_remove(&mut self, index: uint) -> T
[14:37:33] *** Quits: StarLight (StarLight@moz-391B9C89.dynamic.avangarddsl.ru) (Ping timeout)
[14:37:45] <bjz_> I don't want to remove it :(
[14:37:53] <engla> you'll only get by-value if you remove it
[14:37:57] * sp3d can't wait for new rustdoc to make a roogle easier to write
[14:38:00] <engla> or if you get a ref and .clone()
[14:38:09] <bjz_> I want a ref
[14:38:28] <dbaupp> wooo, I have an ldc!
[14:38:44] <engla> bjz_: use vec indexing for now I guess
[14:38:56] <bjz_> engla: I'm using generics
[14:39:14] <engla> well there is no trait for accessing the nth element of a sequence
[14:39:24] <bjz_> engla: yup
[14:39:28] <engla> you'll have to add that
[14:39:42] <bjz_> dbaupp: is that addable?
[14:40:01] <engla> it's going to be part of the random access iterator at least
[14:40:03] <bjz_> <'a>(&'a self, uint) -> &'a T
[14:40:13] *** Quits: pyrac (pyrac@moz-873BFA0.w90-5.abo.wanadoo.fr) (Ping timeout)
[14:40:19] <engla> so in one way it's being added
[14:40:39] <dbaupp> bjz_: yeah, theres a bug about making Index superpowered, including that.
[14:41:03] <dbaupp> bjz_: https://github.com/mozilla/rust/issues/6515
[14:41:11] <engla> bjz_: the beauty of the trait system is that it's pretty easy to add new traits you need
[14:41:25] <engla> I need to unify this thing for a couple of types.. add a trait in your code
[14:41:35] <engla> traits can be very simple
[14:41:36] <bjz_> engla: that's an idea
[14:41:48] <bjz_> could just make a temporary one
[14:41:49] *** Joins: pyrac (pyrac@moz-873BFA0.w90-5.abo.wanadoo.fr)
[14:41:53] <engla> and they let you both merge and split interfaces easily
[14:41:59] *** Joins: StarLight (StarLight@moz-39D57FA9.dynamic.avangarddsl.ru)
[14:42:07] <engla> say, one trait should really be two orthogonal ones
[14:42:48] * dbaupp has to work out what flags are being passed to ldc
[14:42:53] <kimundi> rusti: let x = [1,2,3]; let mut it = x.iter(); it.nth(1)
[14:42:57] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/YWPa
[14:42:57] <SiegeLord> :O LDC finished compiling the benchmark.... it took like 5 minutes
[14:43:23] <bstrie> wow
[14:43:27] <kimundi> rusti: let x = [1,2,3]; let mut it = x.iter(); printfln!("%?", it.nth(1));
[14:43:30] -rusti- Some(&2)
[14:43:30] -rusti- ()
[14:43:37] <SiegeLord> 0m0.351s vs 0m0.497s for me
[14:43:45] <engla> but .nth() is O(N) at the moment
[14:43:51] <bstrie> maybe the secret is just running every single llvm pass
[14:43:53] <kimundi> true
[14:44:19] *** Quits: pyrac (pyrac@moz-873BFA0.w90-5.abo.wanadoo.fr) (Ping timeout)
[14:44:20] <kimundi> well
[14:44:21] <bstrie> maybe we need --opt-level=11
[14:44:28] <bstrie> strictly for benchmarks
[14:44:30] <bjz_> rusti: trait GetN<T> { fn get_n<'a>(&'a self, i: uint) -> &'a T; } impl<T> GetN<T> for &'self [T] { fn get_n<'a>(&'a self, i: uint) -> &'a T { self[i] } } fn hd<T:Clone, V:GetN<T>>(v: V) -> T { v[0] } hd([1, 2, 3])
[14:44:32] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/jfbJ
[14:44:38] <engla> kimundi: maybe llvm can optimize it to O(1)
[14:44:56] <bjz_> rusti: trait GetN<T> { fn get_n<'a>(&'a self, i: uint) -> &'a T; } impl<'self, T> GetN<T> for &'self [T] { fn get_n<'a>(&'a self, i: uint) -> &'a T { self[i] } } fn hd<T:Clone, V:GetN<T>>(v: V) -> T { v[0] } hd([1, 2, 3])
[14:44:58] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/dWdH
[14:45:15] <kimundi> with default methods it could be O(1) on a VectorIterator as long as you dony't chain more adapters from it
[14:45:23] <bjz_> blast
[14:46:02] <engla> you'll need to convince it to pass it as &[T]
[14:46:27] <kimundi> rusti: trait GetN<T> { fn get_n<'a>(&'a self, i: uint) -> &'a T; } impl<'self, T> GetN<T> for &'self [T] { fn get_n<'a>(&'a self, i: uint) -> &'a T { self[i] } } fn hd<T:Clone, V:GetN<T>>(v: V) -> T { v[0] } hd(&[1, 2, 3])
[14:46:30] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/TFLM
[14:47:05] <dbaupp> kimundi, bjz_: the random access iterator actually does exactly that https://github.com/mozilla/rust/pull/7982
[14:47:15] *** Joins: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP)
[14:47:32] <bjz_> dbaupp: what is the name?
[14:47:35] <dbaupp> SiegeLord: .351 is D, right?
[14:47:38] <doomlord_> maybe 'higher kinded polymorphism' could express lifetimes, if you did have generalize pointers..    dosomething<Ptr1, Ptr2, A,B>(a: Ptr1<A>,b:Ptr2<B>, c:Ptr2<C>)-> Ptr1<A> /* semantics of Ptr1 vs  Ptr2 encode lifetime information */
[14:47:43] <dbaupp> bjz_: not landed yet.
[14:47:48] <SiegeLord> dbaupp: Yes
[14:48:06] <bjz_> dbaupp: bugger
[14:48:16] <bstrie> dbaupp: so, re: insanity of string parsing, the last time I got into a heated benchmark battle I had a very similar situation happen to me, where changing methods from implicit self to explicit self caused an inexplicable slowdown :P
[14:48:22] *** Joins: erickt (Adium@8C9ECD8F.3A598286.F12515B4.IP)
[14:48:27] <bjz_> dbaupp: oh well, life on the bleeding edge :)
[14:48:38] <SiegeLord> How do I dump rustc's LLVM IR?
[14:48:45] <bstrie> rustc --emit-llvm
[14:48:46] <bstrie> I think
[14:48:51] <cmr> rustc -S --emit-llvm
[14:49:02] <SiegeLord> That gives me the bytecode
[14:49:04] <dbaupp> bstrie: right. methods pass self in the environment slot and do various casting badness
[14:49:14] <dbaupp> :(
[14:49:22] <bjz_> doomlord_: maybe you should write this down
[14:49:44] <bstrie> dbaupp: I filed a bug for that and eventually it was fixed (it was a double indirection somewhere), but it just goes to show how careful benchmarking will reveal all sorts of nastiness that sidetracks you
[14:49:49] <bjz_> doomlord_: seems to be being lost in the discussion
[14:50:03] <erickt> nmatsakis: rereping :)
[14:50:16] <dbaupp> bstrie: I think it's still in the env slot, rather than being in the first register.
[14:50:20] * dbaupp doesn't really know
[14:50:27] <dbaupp> (maybe the env slot is the first register?)
[14:50:38] *** Quits: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP) (Ping timeout)
[14:51:06] *** Quits: novabyte (Instantbir@moz-D52819E1.mullvad.net) (Ping timeout)
[14:51:29] <dbaupp> anyways, I get ldc = .267, rustc = .368 (just in case we needed more confirmation)
[14:51:43] <erickt> MaikKlein2: no worries about your pull request :)
[14:51:56] <SiegeLord> LDC produces a very large LLVM IR file, heh
[14:52:00] *** Quits: mib_ebqt1b (Mibbit@moz-D3D15A0C.vie.surfer.at) (Quit: http://www.mibbit.com ajax IRC Client)
[14:52:48] *** Joins: novabyte (Instantbir@moz-D52819E1.mullvad.net)
[14:52:59] <nmatsakis> erickt: pong
[14:53:06] <erickt> hey nmatsakis!
[14:53:13] *** Joins: pyrac (pyrac@moz-873BFA0.w90-5.abo.wanadoo.fr)
[14:53:49] <nmatsakis> erickt: hey! So I ... think I was planning on asking you about your PR
[14:53:51] <erickt> I was just wondering if you got any feedback about my unsafe pointers + regions PR from the meeting 
[14:53:56] <nmatsakis> ah, ok, same from you.
[14:54:00] <erickt> :)
[14:54:06] <nmatsakis> Unfortunately, I did not bring it up at the meeting,
[14:54:20] <nmatsakis> I hadn't fully grokked what you had done until after
[14:54:39] <SiegeLord> That's probably why it takes so long to generate it too
[14:54:52] <erickt> nmatsakis: no problem
[14:55:15] <SiegeLord> LDC produces a 1.6 MB executable (vs 44KB for Rust)
[14:55:16] <dbaupp> bstrie/everyone: it looks like LDC is just doing hours of optimisations (it takes 87s for me), compared to our measly 1.2s
[14:55:26] <SiegeLord> I think it's a bug
[14:55:27] <dbaupp> SiegeLord: o_O
[14:55:52] <erickt> dbaupp: !
[14:55:53] <SiegeLord> If you look at the IR, there's tens of thousands of instructions for initializing a very large literal
[14:56:05] <bstrie> dbaupp: I think this parsing issue is actually somehow caused by %? being faster at printing ints than %s is at printing strings
[14:56:08] <SiegeLord> So it's not just rust that has codegen troubles ;)
[14:56:21] <dbaupp> erickt: that's compile speed, not run speed
[14:56:23] <SiegeLord> *very large array literal
[14:56:30] *** Joins: tchoma (tchoma@moz-E58E29CC.dsl.static.sonic.net)
[14:56:31] <nmatsakis> erickt: I haven't read it over in detail, but it seems relevant to our discussion of whether to include * vs *mut
[14:56:44] <dbaupp> SiegeLord: rustc fixed that bug aaaages ago ;P
[14:56:50] <nmatsakis> in particular, the question is how hard we should try to lint and catch errors for *T pointers
[14:57:05] <dbaupp> bstrie: errr, yuck?
[14:57:12] <erickt> dbaupp: understood. I'm guessing this is the rust vs go vs D vs haskell roguelike map generation post?
[14:57:27] <bstrie> dbaupp: yuck indeed
[14:57:29] <dbaupp> erickt: yup
[14:57:36] <doener> bstrie: %s does some pointless extra copies IIRC, I have a branch somewhere that special cases %s to do just do the str::push and nothing else
[14:58:00] <bstrie> doener: that would be awesome
[14:58:00] <doener> bstrie: didn't bother to submit that when I learned that fmt! is going to be rewritten anyway
[14:58:05] <bstrie> doener: right
[14:58:11] <bstrie> doener: fmt! is bad
[14:58:50] *** Joins: lmandel (lmandel@F2D29657.F60B0462.67AC9B1.IP)
[14:59:27] <erickt> nmatsakis: I believe it does. Interacting with C is dangerous, but in my opinion having to deal with `*mut T` or `*'a T` makes rust->C safer.
[15:00:07] <erickt> nmatsakis: sure you can cast::transmute around it, but I'd like to minimize the use of that fn as much as possible
[15:00:16] *** Quits: Blub\w (wry@moz-81ABD137.dip0.t-ipconnect.de) (Quit: WeeChat 0.4.1)
[15:00:38] <kimundi> bstrie, doener: fmt!() needs to be fixed to only allocate the target ~str, and printf!() and prinfln!() shuol be made proper syntax extensions that don't allocate at all.
[15:00:57] <cmr> fmt!() needs to be fixed to output to a stream
[15:01:09] <engla> just like ToStr
[15:01:10] <cmr> one of which can be a string builder
[15:01:20] *** Quits: lmandel (lmandel@F2D29657.F60B0462.67AC9B1.IP) (Ping timeout)
[15:01:24] <kimundi> Ideally, the format string should turn into a pipeline of writers for all involved values to write themselfs into
[15:01:30] <dbaupp> heh... looking through the ldc issue tracker... it looks remarkably similar to rust's.
[15:01:44] <dbaupp> kimundi, cmr, engla: that's the plan.
[15:02:20] <engla> I had a look myself at what fmt! generates and how to make it use a writer
[15:02:33] <engla> I think moving it by small incremental changes could be possible
[15:03:03] <dbaupp> SiegeLord: https://github.com/ldc-developers/ldc/issues/119 maybe?
[15:03:20] <engla> bootstrapping sure is a hurdle though
[15:03:24] <SiegeLord> dbaupp: Possibly
[15:03:28] *** Joins: orshem (orshem@C5E06B1E.A5B6B765.E3D28531.IP)
[15:03:49] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[15:04:26] <engla> dbaupp, doener, "it's going to be rewritten" but no continuing progress on that .. what can we do w.r.t small changes to get closer to it being done
[15:04:55] <doener> IIRC aatch revived his branch
[15:05:03] <engla> ok so it is now alive?
[15:05:05] <dbaupp> engla: just do whatever takes your fancy. aatch may be working on it now so talki to him maybe?
[15:05:19] <engla> rt::io::mem has an in memory writer at least
[15:05:41] <engla> ok
[15:07:22] <strcat> \o
[15:07:39] *** Quits: novabyte (Instantbir@moz-D52819E1.mullvad.net) (Quit: bye bye)
[15:11:32] *** Quits: erickt (Adium@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[15:13:53] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[15:14:15] *** Joins: vodik (simon@moz-CBE4BB13.cable.teksavvy.com)
[15:14:35] *** Joins: ozten (ozten@moz-DD3B00B4.hsd1.wa.comcast.net)
[15:15:12] *** Quits: yong (chatzilla@89F941DF.4E87ADC2.263D9828.IP) (Ping timeout)
[15:15:40] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[15:16:16] <bstrie> strcat: hello
[15:16:37] <bstrie> strcat: we're all in a tizzy because there's a benchmark making the rounds where d's llvm compiler is beating us
[15:16:46] <strcat> ;p
[15:16:59] <strcat> probably just using a slower algorithm than they are
[15:17:01] <bstrie> strcat: though we think they might be cheating because ldc takes 5 minutes to compile a benchmark that we compile in 1.2 seconds
[15:17:17] <strcat> as in CTFE?
[15:17:18] <bstrie> and their binary is 1.5mb and ours is 44k
[15:17:21] <bstrie> no idea
[15:17:26] <bstrie> haven't looked at the code myself
[15:17:45] <bstrie> strcat: https://togototo.wordpress.com/2013/07/23/benchmarking-level-generation-go-rust-haskell-and-d/
[15:18:07] <bstrie> strcat: in any case arch has an ldc package, and I know how much you love reading bytecode :P
[15:18:32] <strcat> well if they're compiling the D code with noboundscheck, that's like using unsafe {} and unchecked indexing in rust
[15:18:59] *** Joins: yong (chatzilla@89F941DF.4E87ADC2.263D9828.IP)
[15:19:06] <bstrie> dbaupp already modified our version to use iterators in a lot of places, which should help with bounds checks yeah?
[15:19:50] <bstrie> also I don't know if ldc has dmd's noboundscheck flag, is it just baked into -O3?
[15:20:11] <dbaupp> bstrie, strcat: ldc seems to have the problem rustc used to have of initialising array literals not using a loop, which makes compiles really slow.
[15:20:20] <SiegeLord> I did this: ldmd2 -O -release -inline -noboundscheck
[15:20:25] * dbaupp is trying to gain some ground for rustc
[15:20:29] <SiegeLord> As per the comment in the D source
[15:20:42] <bstrie> io is still a perf hazard for us, as usual
[15:20:46] *** Joins: yonran (yonran@moz-962F33EB.acuitus.com)
[15:20:52] <SiegeLord> ldmd2 is a shim over LDC (it shuffles the command-line args)
[15:20:53] <strcat> dbaupp: #[fixed_stack_segment] on main?
[15:21:02] <dbaupp> strcat: nope
[15:21:04] * dbaupp tries
[15:21:13] <strcat> although it defaults to big stacks now
[15:21:36] <strcat> anyway, unlike D we have the pain of segmented stacks + there are bounds checks for safety, and those are being disabled in D
[15:21:41] <dbaupp> strcat: doesn't help. not much function calling happening at all.
[15:21:51] * strcat shrugs
[15:22:13] <dbaupp> strcat: the version being tested has no [] indexing: all iterators.
[15:22:25] <bstrie> dbaupp: I think there's at least one index somewhere
[15:22:47] <bstrie> dbaupp: room_to_tiles
[15:22:49] <dbaupp> bstrie: oh, right. yes.
[15:23:45] <bstrie> that does look like a pretty hot loop
[15:24:06] <bstrie> 100 * number of rooms * room width * room height
[15:24:06] <dbaupp> changing it to .unsafe_mut_ref doesn't seem to help.
[15:26:10] <dbaupp> changing it to use .mut_slice and iterators for the inner loop helps a tiny bit.
[15:27:42] <bstrie> dbaupp: perhaps gen_uint_range could use some more optimization as well, it's the biggest thing that jumps out at me in that for 50000.times loop
[15:27:55] <dbaupp> ... maybe we should be emphasising that the Rust code is essentially 100% safe; no need to disable bounds checks or anything like that.
[15:27:59] <dbaupp> bstrie: yeah, probably.
[15:28:22] <dbaupp> bstrie: although it's essentially the naive algorithm at the moment
[15:28:26] * dbaupp needs to change that
[15:28:46] <dbaupp> bstrie: i.e. `random() % (hi - lo) + lo` .. not sure you can get much faster than that.
[15:29:20] <dbaupp> ... although it does have an assert in it.
[15:30:45] <bstrie> dbaupp: I note that it's not marked wtih #[inline]
[15:30:59] <strcat> dbaupp: asserts are slow, considering that they generate code using fmt!
[15:31:19] <strcat> anyway ask perf what's slow
[15:31:29] <doener> not_crash
[15:31:47] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[15:32:04] <dbaupp> strcat: in theory it's just the cost of a cmp and a predicted branch
[15:32:19] <dbaupp> strcat: (since the assert never fails.)
[15:32:30] <strcat> dbaupp: it probably wastes L1 space
[15:32:55] <dbaupp> writing it in the same file with #[inline(always)] without the assert didn't seem to help
[15:32:58] <dbaupp> bstrie: ^
[15:33:02] <bstrie> ok
[15:33:27] <Thiez> strcat: would it help to put the assertion fail path in a separete #[inline(never)] function?
[15:33:35] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[15:33:46] *** Quits: kertap (kertap@moz-5AE34C97.b-ras3.mvw.galway.eircom.net) (Quit: kertap)
[15:33:46] <strcat> Thiez: likely
[15:33:51] <strcat> if that's actually an issue
[15:34:04] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[15:34:17] *** bent is now known as bent|lunch
[15:35:04] <smvv> strcat: can you give me some points about where to start with the issue about tbaa. cmr mentioned earlier that the tbaa pass should be implemented in Rust, with a shim in llvm
[15:35:12] <smvv> pointers*
[15:35:34] <strcat> the place to start is fixing all the misuse of mutability/pointers in the codebase
[15:35:47] <strcat> we can't have TBAA based on the invariants until unsafe {} blocks aren't breaking them
[15:36:50] *** Joins: jdm (jdm@F2D29657.F60B0462.67AC9B1.IP)
[15:37:57] <smvv> that makes sense, but that's a bit unfortunate. My idea was to finish the tbaa pass this summer -- which could be done if there are no misuses -- but this basically means that this is not done at the end of the summer
[15:38:00] *** Joins: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net)
[15:39:23] <strcat> but basically it means going through trans and attaching tbaa metadata to every place it outputs loads/stores of pointers
[15:39:48] <strcat> and then making a little pass in C++ to read that and just respond based on it 
[15:40:02] <strcat> &mut doesn't alias & or &mut, etc.
[15:42:31] <Crnobog> Googling tbaa does nothing :(
[15:42:34] <smvv> and what if i implement it using a compiler flag? so tbaa is disabled by default
[15:42:50] <smvv> Crnobog: type based alias analysis
[15:42:53] <cmr> Crnobog: https://en.wikipedia.org/wiki/Alias_analysis#Type-based_alias_analysis
[15:43:25] <dbaupp> smvv: that would be a very good idea
[15:43:37] <dbaupp> `rustc -Z tbaa foo.rs`
[15:43:44] <cmr> I think it's a bad idea
[15:43:48] <cmr> if it's behind -Z it's going to rot
[15:44:00] <Crnobog> smvv, cmr: thanks
[15:44:11] <dbaupp> cmr: not really, it still gets compiled into the rustc executable.
[15:44:51] <cmr> dbaupp: just because it compiles doesn't mean it's correct or functioning
[15:44:55] <dbaupp> smvv: the other option is to have it enabled by --passes "tbaa" since that architecture is already set up
[15:44:57] <cmr> see: -Z debug-info
[15:45:04] <dbaupp> cmr: tests! ;P
[15:45:05] <cmr> see: pretty printer
[15:45:24] <dbaupp> cmr: tests can set the the flags.
[15:45:45] <smvv> cmr: the problem is that if i cannot finish it in a month, i've to pick another issue. I'm about to finish my bsc and this is a small project that will give me the remaining 6 study points
[15:45:47] <dbaupp> cmr: in any case, tbaa for Rust is in theory fairly simple, because of the semantics of the various pointers.
[15:46:05] *** Joins: alex-abreu (alex@moz-7421D6C9.mc.videotron.ca)
[15:46:08] <dbaupp> (and what LLVM considers to be aliasing.)
[15:46:11] <cmr> smvv: how many hours per week do you plan on putting into it? I can't see it taking *that* long
[15:46:27] <smvv> no but i've to write a report as well
[15:46:39] <smvv> and the background of alias analysis. why in rust, etc.
[15:47:03] <SiegeLord> You know... I think the difference between the two benchmarks might be that LDC does everything on stack
[15:47:04] <smvv> the implementation can take one or two weeks at most
[15:47:40] <strcat> dbaupp: but anyway, yay iterators ;p
[15:47:41] <smvv> otherwise it does not count as 'research'
[15:48:02] <SiegeLord> If I change the D program to do a one time allocation it slows down to be slower than Rust (it halves the compilation time though)
[15:48:20] <bstrie> SiegeLord: I see there's a stack version of the rust program in that repo
[15:48:26] <bstrie> good observation
[15:48:32] <dbaupp> SiegeLord: ah! do you want to try modernising R-stack-vector.rs?
[15:48:39] * dbaupp is going to be
[15:48:41] <dbaupp> d
[15:48:57] <dbaupp> strcat: they're pretty awesome.
[15:49:40] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[15:49:40] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/P01IYA
[15:49:40] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[15:51:39] <strcat> dbaupp: anyway I find that post a bit silly
[15:51:46] <smvv> strcat: so the idea is to use LLVMSetMetadata to set tbaa info (must/may/no) on load and store instructions, right? llvm comes with a tbaa pass itself. perhaps it is interesting to use that prior to writing our own tbaa pass? the idea is that classes that subclass AliasAnalysis can reuse information from its parent
[15:52:08] <strcat> does every permutation of restrict, volatile, const, etc. in C count as a 'pointer type'? along with the memory allocator used, etc.
[15:52:22] <Ms2ger> Are we still counting pointers?
[15:52:26] <strcat> smvv: we need to make our own pass
[15:52:38] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[15:52:38] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/fSE3bQ
[15:52:38] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[15:52:40] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[15:52:40] <ghrust> 01[13rust01] 15bors pushed 14 new commits to 06auto: 02http://git.io/WmiX5A
[15:52:40] <ghrust> 13rust/06auto 14626bb5a 15Daniel Micay: add a RandomAccessIterator trait
[15:52:40] <ghrust> 13rust/06auto 148c02272 15Daniel Micay: expand on double-ended iterators in the tutorial
[15:52:40] <ghrust> 13rust/06auto 14af5a17b 15Daniel Micay: document random-access iterators
[15:52:42] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[15:52:44] <strcat> smvv: the tbaa pass that's already there is for the tbaa used to optimize C
[15:52:53] <strcat> and the tbaa optimizations used for C are unsafe
[15:53:06] <strcat> rust doesn't necessarily provide the guarantees it uses in a safe way
[15:53:09] *** Quits: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net) (Ping timeout)
[15:53:32] <strcat> the interesting optimizations based on rust's aliasing information need a new pass
[15:58:17] *** Joins: tcsc (tcsc@moz-7246F5CD.hsd1.ma.comcast.net)
[15:58:40] *** Quits: dherman (dherman@8A703D98.AE3E6FBC.FEA76598.IP) (Quit: dherman)
[16:01:14] *** Joins: ecr (Thunderbir@moz-19C7F72B.uoregon.edu)
[16:02:36] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[16:02:39] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[16:03:08] <joelteon> what does tbaa stand for
[16:03:44] <tcsc> type based alias analysis
[16:03:51] <tcsc> in the context of llvm
[16:04:18] <strcat> smvv: but really any TBAA is going to require auditing existing unsafe blocks
[16:04:28] <strcat> and making the requirements placed on unsafe code clear
[16:06:15] <kimundi> I wonder how much unsafe badness can be statically detected
[16:06:48] <kimundi> As in: Giving a warning along the lines of "Are you sure you want to do this?"
[16:07:06] <smvv> i agree. first i'll try implementing it without the auditing of unsafe blocks.
[16:07:07] <kimundi> probably a bad idea
[16:07:59] <bstrie> kimundi: I think we already warn by default when an unsafe block doesn't actually call any unsafe functions
[16:08:00] <smvv> kimundi: it should be possible to mark pointers used in unsafe blocks as `may' alias?
[16:08:08] <strcat> kimundi: it can be detected by not using unsafe
[16:08:12] <strcat> smvv: no, that won't work
[16:08:22] <strcat> unsafe blocks are nested deep in other code
[16:08:32] <strcat> you would have to remove all the TBAA info all the way up
[16:08:34] <strcat> so, no TBAA
[16:09:17] <strcat> if a function takes &T with T: Freeze and mutates it with an unsafe block, it's wrong all the way up
[16:09:45] <strcat> and functions do that for sure - consider that destructors all take &self atm
[16:09:56] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[16:09:59] <strcat> until it's fixed we can't really be doing TBAA
[16:10:39] <strcat> it's really not a simple thing to implement
[16:10:52] *** Quits: tchoma (tchoma@moz-E58E29CC.dsl.static.sonic.net) (Quit: My MacBook has gone to sleep. ZZZzzz‚Ä¶)
[16:10:53] <strcat> because any guarantee you tell LLVM about has to be true
[16:10:58] <strcat> *always*
[16:10:59] *** Joins: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net)
[16:11:26] <strcat> and you're unlikely to get any test failures from mistakes, rust isn't a big enough sample of code
[16:11:48] <strcat> for example marking all &mut parameters as noalias didn't generate any failures, even though they alias @mut and &const
[16:13:37] <erickt> strcat / bstrie: I got a pull request that's adding regions to unsafe pointers: https://github.com/mozilla/rust/pull/7967. Would the ability to know that a pointer isn't escaping a scope help with TBAA? Assuming of course no one is using cast::transmute, or the FFI is making an alias under rust's nose
[16:14:32] <strcat> erickt: it doesn't help unless you know it's never violated
[16:14:35] <strcat> ever
[16:15:00] <strcat> there can't be a single unsafe block breaking a rule you add to a TBAA pass
[16:15:54] <strcat> what matters most is mutability
[16:15:58] <strcat> when it comes to alias analysis
[16:16:04] <strcat> because aliasing is about memory dependencies
[16:16:26] <strcat> and our mutability guarantees are violated in thousands of places all over the codebase.
[16:16:29] <erickt> strcat: how does this rule work when passing a &T pointer to a function that may or may not be using cast::transmute?
[16:16:47] <strcat> erickt: there won't be TBAA for raw pointers
[16:16:58] <strcat> erickt: if it's using transmute in a way that breaks a guarantee we decide on, it's wrong
[16:17:00] <smvv> ok. let's say i implement it as a by-default compiler flag (e.g. --passes tbaa). that way it could be used in a benchmark to show what the gain could be. At first it's just experimental and once there's a better understanding about what to do with unsafe blocks, it is possible to improve tbaa
[16:17:08] <smvv> by default disabled*
[16:17:10] <strcat> writing unsafe blocks means you're aware of all the TBAA rules we decide on
[16:17:32] <strcat> smvv: any guarantee we make really has to be thought out well though
[16:17:55] <strcat> for example if we say &T where T is Freeze *must* be immutable, that means a big project to update all the code breaking that rule
[16:18:14] <strcat> I don't think we should hide anything like that behind a -Z flag
[16:18:24] <strcat> it's only useful if we're willing to fix the existing code
[16:18:44] <strcat> I mean you could mark almost anything as NoAlias but it doesn't matter if it's not true...
[16:19:22] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: brb)
[16:20:24] <SiegeLord> Could there be an attribute to mark an unsafe block as audited?
[16:20:43] *** Joins: alex_abreu (alex@moz-7421D6C9.mc.videotron.ca)
[16:20:56] <cmr> kinda_unsafe { ... }
[16:21:20] <SiegeLord> I'm just thinking of practicalities of doing the audit in a gradual fashion
[16:21:39] *** Quits: alex-abreu (alex@moz-7421D6C9.mc.videotron.ca) (Ping timeout)
[16:21:50] <SiegeLord> It really does seem that some functions are safer than others
[16:22:15] *** Quits: vodik (simon@moz-CBE4BB13.cable.teksavvy.com) (Ping timeout)
[16:22:20] <SiegeLord> Maybe it'd be nice if there was an attribute for "safe all the way down"
[16:22:33] *** Joins: vodik (simon@moz-CBE4BB13.cable.teksavvy.com)
[16:23:30] <SiegeLord> And then the unsafe blocks could be audited with a hash or something
[16:24:43] <erickt> Can we do this bottom up, where we mark certain unsafe functions as noalias, and a pass that decides whether or not it's safe to use TBAA?
[16:25:23] <engla> SiegeLord: isn't it better to allow unsafe { }  blocks and then allowing using more specific unsafe-tag { } blocks? so it can be annotated in the code
[16:25:43] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[16:25:49] <cmr> SiegeLord: I don't think that is workable.
[16:26:07] <SiegeLord> I don't think you should ever have unsafe blocks that are actually unsafe
[16:26:19] <cmr> unsafe code can only be "safe" insofar as its assumptions are never invalid and it covers every possible case.
[16:26:43] *** Quits: jdm (jdm@F2D29657.F60B0462.67AC9B1.IP) (Ping timeout)
[16:26:46] <cmr> Both of those are near impossible to track or prove for any non-trivial code
[16:26:57] <cmr> So automating it with a separate "kind" of unsafe isn't useful
[16:27:04] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[16:27:38] <engla> it depends on what kind of patters we have inside unsafe blocks and what we can do to factor them out into specific unsafe-tag blocks or functions
[16:27:45] <SiegeLord> Well, the solution is auditing unsafe blocks... what I proposed just makes the assumption that once an unsafe block is audited to not violate things, it'll keep being "safe"
[16:28:02] <engla> (sounds like creating a much bigger unsafe sublanguage though)
[16:28:13] <cmr> BUt that's not true
[16:28:16] <SiegeLord> Until you change it, which would violate the auditing hash
[16:28:17] <cmr> in any large codebase, things change
[16:28:46] <cmr> if your unsafe block depends on the layout of ~T to have a header and that header disappears, the unsafe code hasn't changed but its assumptions are invalidated
[16:28:48] <SiegeLord> I.e. you're saying the hash will have to include excessively large portions of code?
[16:28:56] *** Joins: vosen (vosen@moz-266BA656.icpnet.pl)
[16:29:30] <cmr> Yes
[16:29:39] <engla> cmr: that one has a nice resolution (mostly) in the PR to put all knowledge of raw representations in the same place
[16:29:50] <cmr> You will need to expliclty list everything your unsafe code depends on being true
[16:29:53] <cmr> which is unwieldy
[16:30:02] <cmr> engla: just an easy example
[16:30:07] <SiegeLord> Well, in practice you'll have to... in comments
[16:30:18] <SiegeLord> Otherwise you're really playing with fire
[16:31:02] <cmr> Sure
[16:31:13] <cmr> Some sort of attribute-based system for auditing unsafe would be neat.
[16:31:20] <cmr> go prototype one :p
[16:32:11] <SiegeLord> I don't think it's useful without an automated mechanism to invalidate it
[16:32:38] <SiegeLord> To be perfectly safe you'd have to re-audit with every new commit
[16:33:20] <SiegeLord> Well anyway, it's all silly... in practice I think unsafe code that's audited will tend to remain safe for a bit
[16:33:34] <SiegeLord> We don't change layout of ~T too often, right?
[16:34:08] <SiegeLord> Can't really statically enforce good programming practices :P
[16:34:17] <cmr> I don't think the proper solution is technical. One just needs careful documentation of their unsafe code, and to reduce the scope of unsafe as much as possible.
[16:34:33] *** Quits: tcsc (tcsc@moz-7246F5CD.hsd1.ma.comcast.net) (Quit: computer sleeping)
[16:34:50] <SiegeLord> It'd be nice if there was a way to test some of these esoteric things like aliasing
[16:35:18] <SiegeLord> Maybe some sort of fuzz testing framework
[16:35:35] *** Joins: eatkinson (eatkinson@moz-AD233F1B.dia.static.qwest.net)
[16:40:44] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[16:41:50] *** Joins: jorendorff (jorendorff@moz-1747FB68.hsd1.tn.comcast.net)
[16:45:51] *** Joins: pnathan_ (pnathan@moz-ABA29727.pools.spcsdns.net)
[16:49:13] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[16:58:01] *** Quits: timm (timm@moz-37B954AF.superkabel.de) (Input/output error)
[16:58:11] *** Quits: doener (bs@moz-AA189A5A.unitymedia.biz) (Quit: leaving)
[16:58:28] *** Joins: timm (timm@moz-37B954AF.superkabel.de)
[17:00:08] *** Quits: timm (timm@moz-37B954AF.superkabel.de) (Ping timeout)
[17:00:10] *** Joins: tchoma (tchoma@moz-E58E29CC.dsl.static.sonic.net)
[17:02:16] *** Joins: timm (timm@moz-37B954AF.superkabel.de)
[17:02:48] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[17:03:40] *** Joins: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net)
[17:05:42] *** Joins: giselher (Mibbit@moz-E66D5DEB.raab-heim.uni-linz.ac.at)
[17:05:47] <kmc> http://embed.cs.utah.edu/csmith/ is a neat fuzz tester for C compilers
[17:06:54] <cmr> we used to have an ast fuzzer but it rotted
[17:07:15] <cmr> And I think it was just for finding and fixing ICEs
[17:09:25] <eatkinson> rusti: struct ViewA; struct ViewB; struct MyStruct<View> { x: int } impl<V> MyStruct<V> { fn foo(&self) -> int { 42 } } impl MyStruct<ViewA> { fn bar(&self) -> int { self.foo() + self.x } }
[17:09:25] -rusti- ()
[17:09:44] *** Quits: xraycat (Adium@moz-AAD824D1.pool.mediaways.net) (Quit: Leaving.)
[17:10:40] *** Quits: CarpNet (ac@moz-FD24B77.sohonet.co.uk) (Quit: Leaving)
[17:14:14] *** Quits: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net) (Quit: Leaving)
[17:19:48] *** Quits: joelteon (joel@moz-317E8D0C.io) (Quit: bye)
[17:19:58] *** Quits: Mowah (Mowah@moz-436C35C5.cust.bredbandsbolaget.se) (Ping timeout)
[17:22:53] *** Quits: orshem (orshem@C5E06B1E.A5B6B765.E3D28531.IP) (Quit: Leaving)
[17:23:33] *** Joins: joelteon (joel@moz-317E8D0C.io)
[17:24:59] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Connection reset by peer)
[17:25:24] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[17:25:29] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[17:26:32] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[17:27:05] *** Joins: mschifer (Adium@moz-BBE3ABD.mv.mozilla.com)
[17:27:07] *** Quits: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP) (Ping timeout)
[17:32:53] *** Joins: jdm (jdm@F2D29657.F60B0462.67AC9B1.IP)
[17:32:57] *** Joins: tcsc (tcsc@moz-7246F5CD.hsd1.ma.comcast.net)
[17:33:40] *** Joins: igl (igl@moz-8F1B8F16.adsl.alicedsl.de)
[17:36:26] *** Quits: ecr (Thunderbir@moz-19C7F72B.uoregon.edu) (Quit: ecr)
[17:38:54] *** Quits: pnathan_ (pnathan@moz-ABA29727.pools.spcsdns.net) (Ping timeout)
[17:41:15] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[17:41:15] *** ChanServ sets mode: +o tjc
[17:42:18] *** bent|lunch is now known as bent
[17:42:50] *** Quits: eatkinson (eatkinson@moz-AD233F1B.dia.static.qwest.net) (Quit: eatkinson)
[17:42:51] *** Joins: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net)
[17:43:16] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[17:43:34] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[17:43:42] *** Joins: lkuper (lkuper@5188CCE.A402E718.C082B7DC.IP)
[17:45:22] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[17:45:39] *** Joins: eatkinson (eatkinson@moz-AD233F1B.dia.static.qwest.net)
[17:46:28] *** Joins: rlbaker (rlbaker@moz-C8EE266C.hfc.comcastbusiness.net)
[17:46:35] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Quit: Leaving.)
[17:48:34] *** Quits: Guest (textual@BBE7C46A.B4F11D08.8612FA94.IP) (Quit: Textual IRC Client: www.textualapp.com)
[17:50:26] *** Joins: Jesse_ (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[17:50:36] *** Quits: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net) (Ping timeout)
[17:51:25] <MaikKlein2> https://github.com/mozilla/rust/pull/7969
[17:51:36] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[17:52:01] *** Joins: Altazimuth (Max@50582DF4.892388C2.9C6A40AF.IP)
[17:52:57] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.1)
[17:53:05] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[17:54:32] <cmr> MaikKlein2: you still re-add extra::net
[17:54:37] <cmr> MaikKlein2: want me to clean it up for you?
[17:54:56] *** Joins: seth (seth@moz-BE33DA21.fw1.sfo1.mozilla.net)
[17:55:17] *** Joins: qmx (qmx@moz-D6C3C2E6.qmx.me)
[17:56:45] *** Quits: vodik (simon@moz-CBE4BB13.cable.teksavvy.com) (Quit: civ5 time)
[17:56:54] <engla> MaikKlein2: commit #2 is mostly empty, it seems to be an error
[17:57:07] <engla> also don't worry, you'll get used to git
[17:57:43] <engla> rebasing and juggling changes between committs isn't really easy anyway though.
[17:58:01] <engla> *commits
[17:58:19] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[17:58:41] *** Quits: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP) (Input/output error)
[17:58:41] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Quit: Leaving.)
[17:59:00] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[17:59:22] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Max SendQ exceeded)
[18:00:36] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[18:01:36] <MaikKlein2> I just thought it would be straight forward to use, but I messed it up :( reading the gitbook atm
[18:01:42] <MaikKlein2> cmr, this would be nice
[18:01:51] <cmr> it's straightforward: once you know what you're doing
[18:02:14] <MaikKlein2> :D
[18:02:19] <MaikKlein2> hopefully
[18:02:39] <Crnobog> I thought I would understand git having used hg
[18:02:42] <Crnobog> I was wrong.
[18:02:58] <cmr> git and hg are quite similar in everything except UI
[18:04:05] <MaikKlein2> cmr, do I need to add you as a collaborator in my rust fork?
[18:04:15] <Crnobog> A few things are reversed which is a little confusing
[18:04:16] <cmr> MaikKlein2: no, I'll just open a new PR
[18:04:23] <MaikKlein2> cmr, okay thanks
[18:04:31] <Crnobog> And branches and remotes are a bit more first-class in git which means you have to learn how they interact
[18:04:41] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[18:04:42] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/WmiX5A
[18:04:42] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[18:05:29] <cmr> I think git as a system is really quite simple
[18:05:40] <cmr> it's just the cli tools that are... problematic
[18:06:44] <Crnobog> Yeah I always know what I want to do in terms of a commit graph
[18:06:59] <Crnobog> But achieving it on the command like or any of the frontends I've tried is more of a challenge
[18:07:41] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[18:07:41] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/pPWt5A
[18:07:41] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[18:07:45] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[18:07:45] <ghrust> 01[13rust01] 15bors pushed 17 new commits to 06auto: 02http://git.io/NjcisA
[18:07:45] <ghrust> 13rust/06auto 147434080 15Erick Tryzelaar: rustc: remove some dead functions
[18:07:45] <ghrust> 13rust/06auto 149ad815e 15Erick Tryzelaar: std: rename str.as_bytes_with_null_consume to str.to_bytes_with_null
[18:07:45] <ghrust> 13rust/06auto 14cfd89c4 15Erick Tryzelaar: std: remove os::as_c_charp
[18:07:47] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[18:09:24] <MaikKlein2> btw does this look okay to you https://github.com/MaikKlein/rust/commit/9593c14227ca163166232c9fbfc97051206e5b48#L2L45 ?
[18:09:26] *** Quits: ozten (ozten@moz-DD3B00B4.hsd1.wa.comcast.net) (Quit: ozten)
[18:09:53] <cmr> MaikKlein2: I'm not sure it's useful as a trait.
[18:10:18] <MaikKlein2> cmr, can I do more then one imp block?
[18:10:19] <cmr> regardless of that, needs docs :)
[18:10:23] <cmr> MaikKlein2: yes
[18:10:26] <MaikKlein2> oh
[18:10:27] <MaikKlein2> :X
[18:10:59] *** Quits: Altazimuth (Max@50582DF4.892388C2.9C6A40AF.IP) (Quit: Leaving)
[18:11:46] <MaikKlein2> ok then it should be impl <T: Clone, U: Clone> Result<U,T> { 
[18:12:29] <cmr> It could also just be consuming (fn to_either(self))
[18:12:37] <cmr> And have the user clone when they want to.
[18:13:30] <MaikKlein2> hm like res.clone().to_either()?
[18:13:34] <cmr> Yes
[18:13:51] *** Joins: jc-denton (nils@moz-C5E8B5EA.ethz.ch)
[18:13:54] <jc-denton> Hi
[18:13:59] <jc-denton> Is garbage collection now out of rust?
[18:14:21] <cmr> jc-denton: we don't have a GC yet
[18:14:22] <MaikKlein2> what is the convention with consume?
[18:14:27] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[18:14:36] <cmr> jc-denton: but it is planned to be moved to a library still
[18:14:46] <cmr> (ie, http://pcwalton.github.io/blog/2013/06/02/removing-garbage-collection-from-the-rust-language/)
[18:14:48] <MaikKlein2> do name methods to_either_consume?
[18:14:56] <cmr> MaikKlein2: as_either
[18:15:02] <cmr> I believe
[18:15:06] <MaikKlein2> ok
[18:15:33] <MaikKlein2> so maybe I add to_either and as_either
[18:15:35] <jc-denton> yeah that is a pretty long article
[18:15:36] <jc-denton> :)
[18:15:38] <kimundi> jc-denton: @ and @mut ar still ref counted and a tracing gc is ready but not mergable because of 32bit memory problems
[18:15:53] <engla> MaikKlein2: use to_ if it's consuming the value
[18:15:56] <cmr> Also we're considering not using graydon's bespoke GC and using MPS instead.
[18:15:57] <jc-denton> ah so @ is basically sd::shared_ptr still?
[18:16:09] <jc-denton> What about cycles?
[18:16:17] <MaikKlein2> engla, and as_ if it doesn't consume?
[18:16:20] <kimundi> the reoving in that article talks about removing the extra @ sigil, making @ and @mut just regular types Gc<> and GcMut<>
[18:16:22] <cmr> Cycles are collected at task annihilation.
[18:16:35] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[18:16:35] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 146d65521 to 14f132401: 02http://git.io/N3iJvQ
[18:16:35] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[18:16:38] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[18:16:38] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/0SlQfA
[18:16:38] <ghrust> 13rust/06auto 147a6ebb3 15OGINO Masanori: Remove unused variables in `compile_submatch`....
[18:16:38] <ghrust> 13rust/06auto 14766eb95 15bors: auto merge of #7997 : omasanori/rust/cleanup, r=cmr...
[18:16:39] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[18:16:46] <MaikKlein2> engla, or is there no as_ :)?
[18:17:30] <jc-denton> sounds pretty cool
[18:17:34] <engla> MaikKlein2: vec and str use as_ when they return a slice (still referencing the original object)
[18:18:46] <engla> MaikKlein2: so as_ would be a temporary thing, not a conversion
[18:19:00] <cmr> ok so I had it backwards
[18:19:17] *** Quits: eatkinson (eatkinson@moz-AD233F1B.dia.static.qwest.net) (Quit: eatkinson)
[18:19:32] *** Joins: MaikKlein1 (maik@moz-2B0E2234.dip0.t-ipconnect.de)
[18:19:40] <MaikKlein1> damn you dc's
[18:19:43] <MaikKlein1> engla, so I probably just implement to_either which consumes
[18:19:50] <MaikKlein1> and no as_either?
[18:20:12] <cmr> as_either doesn't really make sense
[18:20:23] <MaikKlein1> okay
[18:20:30] *** Quits: MaikKlein2 (maik@moz-FD97565C.dip0.t-ipconnect.de) (Ping timeout)
[18:20:44] <MaikKlein1> then I'll change it so that it consumes
[18:23:50] <tcsc> why is garbage collection in rust such a hard problem?
[18:24:28] <tcsc> it's task-local right?
[18:24:30] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[18:24:31] <cmr> tcsc: it isn't, really, it's just a matter of keeping the complexity down and not limiting flexibility, while not impacting the efficiency of everything else
[18:24:42] <cmr> which are language problems, not GC problems
[18:25:15] <tjc> graydon: ^ (perhaps you have something to add)
[18:25:44] <cmr> although interior pointers do increase GC complexity quite a bit
[18:26:15] <tcsc> yes, i forgot rust would have to deal with that
[18:26:47] *** Joins: rusti (rusti@moz-61B073BC.cpe.net.cable.rogers.com)
[18:26:53] *** Joins: ozten (ozten@moz-DD3B00B4.hsd1.wa.comcast.net)
[18:26:55] <cmr> borrowing is a problem but not too hard, just another thing the GC needs to handle.
[18:28:08] *** Joins: Frunz (YesHello@56795E1D.D402F0D8.985B58.IP)
[18:29:04] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[18:29:14] <tcsc> is reference counting used so that destruction of @types is more deterministic or because of implementation simplicity?
[18:29:22] <cmr> implementation simplicity.
[18:29:30] <cmr> it isn't intended to be permanent
[18:29:39] <cmr> (it's not even correct, we do no cycle collection)
[18:30:09] <jc-denton> So rust is written in rust itself, like a C compiler is written in C..
[18:30:24] <jc-denton> typing make how do I get a rust comiler in the first place?
[18:30:29] *** Joins: dherman (dherman@96DF99F7.5E7911EA.DA40C4B3.IP)
[18:30:29] *** ChanServ sets mode: +o dherman
[18:30:33] <Ms2ger> Download one
[18:30:34] <cmr> jc-denton: downloads a snapshot
[18:30:34] *** Quits: RMF (RMF@5C293616.B791E6A9.8D19547B.IP) (Ping timeout)
[18:30:48] <Ms2ger> The first one was a disgrace written in ocaml, aiui
[18:31:29] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[18:31:33] <tcsc> cmr: i had wondered where the all the gc code was. is there anything missing in the runtime to support tracing?
[18:31:59] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Connection reset by peer)
[18:31:59] <cmr> tcsc: you'd have to ask graydon, he implemented the GC (which hasn't landed yet)
[18:32:23] <cmr> tcsc: http://www.ravenbrook.com/project/mps/ is going to try to be integrated
[18:32:29] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[18:32:36] <Frunz> rust is already self built?
[18:32:39] <Frunz> impressive
[18:32:51] <cmr> Frunz: self hosting, and it has been for... over a year?
[18:32:54] <Ralith> cmr: oh, that went ahead? Where was the discussion?
[18:33:24] <cmr> Ralith: this week's meeting notes
[18:33:30] <Frunz> I decided to finally get off my butt and get involved with Mozilla. They pointed me here
[18:33:39] <Frunz> So I'm just gonna lurk for a while and learn how rust works
[18:33:49] <cmr> Frunz: cool :)
[18:34:02] <Ralith> cmr: where would I find those?
[18:34:04] <cmr> I have a bunch of tasks in mind if you need help getting started
[18:34:14] <cmr> Ralith: big list at https://github.com/mozilla/rust/wiki/Meetings, recent are on the bottom
[18:34:17] <Ralith> thanks
[18:34:19] <mark_edward> cmr: that memory pool system, is it what graydon made?
[18:34:26] <cmr> https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-07-23#mps
[18:34:28] <cmr> mark_edward: nooo
[18:34:43] <mark_edward> cmr: is it what he wants to make?
[18:34:54] <cmr> mark_edward: MPS already exists.
[18:35:11] <mark_edward> cmr: rigt, but im talking about for the Rust GC
[18:35:28] <cmr> Well it is a library, it would be integrated into the compiler
[18:35:53] <Ralith> into the RTS, specifically
[18:37:30] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Quit: Leaving.)
[18:38:47] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[18:39:09] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[18:41:24] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Connection reset by peer)
[18:41:46] <tcsc> why would rust use a mostly-copying collector over a fully copying collector?
[18:41:46] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[18:42:07] <cmr> tcsc: interior pointers
[18:42:25] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[18:44:24] *** Quits: giselher (Mibbit@moz-E66D5DEB.raab-heim.uni-linz.ac.at) (Quit: http://www.mibbit.com ajax IRC Client)
[18:45:28] <tcsc> not sure i follow, but i've worked on a gc that had to deal with interior pointers
[18:46:44] <tcsc> you wouldn't have type info for borrowed pointers, and so something reachable only from a borrowed pointer can't be copied?
[18:47:00] <jc-denton> maaan but it takes long to compile
[18:47:01] <cmr> aiui references into a GC'd object can't be updated.
[18:47:04] <jc-denton> for such a young language
[18:47:12] <cmr> jc-denton: it's llvm
[18:47:30] <cmr> first build takes ~1hr, most of which is llvm
[18:47:41] <cmr> building all 3 stages of rust itself only takes ~15 minutes
[18:47:57] *** Joins: jgilbert (jgilbert@moz-3622627C.smartcity.com)
[18:49:50] <jc-denton> meh
[18:50:04] <jc-denton> I have a Macbook Air and I said make -j3
[18:51:00] *** Joins: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net)
[18:51:01] *** Joins: echristo (echristo@DCF57675.D6CCE4AE.77834EAA.IP)
[18:51:02] <jc-denton> So.. I can also see the llvm code that is generated?
[18:51:09] <cmr> yes
[18:51:10] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[18:51:39] *** Quits: victorporof (victorporo@7EA800E4.67625325.D111398B.IP) (Quit: victorporof)
[18:51:52] <jc-denton> ah
[18:51:54] <jc-denton> done already!
[18:51:56] <jc-denton> yeah
[18:52:49] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[18:53:19] <jc-denton> is there a thing such as rustfmt?
[18:53:22] <jc-denton> like gofmt?
[18:53:28] <cmr> yes but it's broken
[18:53:30] *** Quits: paulproteus (quassel@rose.makesad.us) (Ping timeout)
[18:53:40] <tjc> jc-denton: https://github.com/mozilla/rust/issues/3195
[18:53:44] <cmr> https://github.com/mozilla/rust/issues/3195#issuecomment-21503405
[18:54:13] *** Joins: paulproteus (quassel@moz-E86A3B42.makesad.us)
[18:54:17] <jc-denton> ah and my simple fibnoacci program no longer works..
[18:55:44] <kmc> regarding MPS licensing issues, if you take a look at http://www.ravenbrook.com/project/mps/master/license?format=rst you'll see that the special license for Open Dylan (which may be similar to what we could get) has a caveat "provided that the Dylan program is not providing memory management services"
[18:55:48] <tcsc> cmr: yeah, i see the problem. you'd need to change the value of all the borrowed pointers and tracking them would cause overhead in normal code
[18:55:59] <kmc> which to me is the kind of scary vague language that has a chilling effect on use of your software
[18:56:23] <tcsc> from what i've heard ravenbrook are nice guys
[18:56:25] <jc-denton> ohh come on http://codepad.org/OQklA2i4
[18:56:38] <kmc> if I implement a toy scheme interpreter in Open Dylan, am I "providing memory management services" by virtue of the fact that old cons cells get collected
[18:56:50] <tcsc> otoh mps is old and a lot of old gc's choke on modern multi-gigabyte heaps
[18:57:09] <kmc> tcsc: I've heard nothing to the contrary, my concern is less about intent and more about making sure all the legal language is ironclad
[18:57:26] <kmc> because even if Mozilla and Ravenbrook are in perfect harmony, some vague language in the license may scare off third party Rust users
[18:57:43] <kmc> e.g. many companies refuse to touch anything GPL, even in cases where they could easily comply with the terms
[18:57:44] <jc-denton> So there is just this tool right now: https://github.com/dbp/rustfmt
[18:57:50] <jc-denton> but last commit ~10 months ago
[18:58:01] <tcsc> kmc: i don't think that would be a problem because the cons cells are internal to your program
[18:58:04] <cmr> jc-denton: the pretty printer is built-in
[18:58:09] <kmc> their lawyers think in terms of risk and exposure rather than the intent of the language
[18:58:10] <cmr> jc-denton: rustc --pretty normal
[18:58:16] <kmc> which is what they're paid to do, of course
[18:58:19] <tcsc> you're using mps to manage your own internal memory
[18:59:47] <kmc> the fact that it sounds fine to you and me is not really relevant to the point I'm making
[18:59:55] <tcsc> yeah i know
[19:00:02] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[19:00:09] *** Quits: tchoma (tchoma@moz-E58E29CC.dsl.static.sonic.net) (Quit: Textual IRC Client: www.textualapp.com)
[19:00:14] <cmr> it's not like mozilla doesn't have a legal team which can work it out
[19:00:14] <kmc> kust a
[19:00:16] <kmc> whoops
[19:00:17] <kmc> yeah
[19:00:20] <jc-denton> but rust will still allow different formattings, unlike go?
[19:01:30] <cmr> I'm unfamiliar with what go does in this regard
[19:01:36] <cmr> Does its compiler reject misformated source?
[19:01:37] <bstrie> jc-denton: rust has no restriction against putting braces whereever you want
[19:01:56] <bstrie> cmr: go's automatic semicolon insertion also dictates a single brace style
[19:02:21] <bstrie> jc-denton: however, rustfmt will probably be the "canonical" form that people are encouraged to use
[19:03:30] *** Quits: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net) (Quit: tikue)
[19:03:48] <jc-denton> Well having absurd formatting discussions at work, I would vote for just one allowed formatting.
[19:04:05] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Ping timeout)
[19:04:12] <cmr> it's not the job of a language to enforce style IMO
[19:04:12] *** Joins: mye (mye@moz-6C96FE1E.dip0.t-ipconnect.de)
[19:04:16] <jc-denton> Fib.rs:12:32: 12:33 error: obsolete syntax: declaration of multiple locals at once
[19:04:19] <jc-denton> why?
[19:04:30] <cmr> jc-denton: let (a, b) = (1, 2) replaces it
[19:04:36] <kimundi> jc-denton: Ambiguity of intend
[19:04:39] <jc-denton> ah
[19:04:48] <benh> Got confusing whether let mut a, b declares one or two mutable variables
[19:04:53] <kimundi> let mut a, b = ... // is a and b mut, or just a ?
[19:05:08] <kimundi> mut will become a patter modifier
[19:05:11] <engla> not allowed anymore
[19:05:37] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Quit: Gone to save the world!)
[19:05:38] <engla> ignore me
[19:05:45] <kimundi> let (a, mut b, c) = ... // per binding mutablity modifier
[19:05:45] * engla ignores /me
[19:06:02] <Ms2ger> cmr, it saves a lot of time arguing about style :)
[19:06:23] <benh> Do I get to say let mut ref mut x = y?
[19:06:25] <jc-denton> but still error: obsolete syntax: `mut` with multiple bindings
[19:06:30] <SiegeLord> Can't think of any language with a compiler that enforces a complete style
[19:06:34] <cmr> jc-denton: you can't do that
[19:06:35] <kimundi> benh: I think yes
[19:06:39] <cmr> you need multiple 'let mut'
[19:06:41] <cmr> (for now)
[19:06:43] <jc-denton> ah I have to write 3 times mut
[19:06:44] <jc-denton> nah
[19:06:49] <jc-denton> :(
[19:06:52] <cmr> it will eventually be 'let (mut a, mut b, mut c) = ...'
[19:07:17] <kimundi> jc-denton: one 'let', one pattern
[19:07:18] <cmr> I'd be quite comfortable with `let mut (a, b, c) = ...`, much more obviously distributive.
[19:07:40] <bstrie> SiegeLord: column-oriented programming languages :)
[19:07:55] <bstrie> e.g. old fortran, old rpg
[19:08:03] <jc-denton> ah and go has of course gofix
[19:08:16] <jc-denton> but this does not make sense unless the language is a bit mature
[19:08:17] <MaikKlein1> rusti: let (a,b,c) = (1,2,3); let mut a = a; a+=5; a
[19:08:17] <cmr> jc-denton: all gofix really does is semicolons aiui
[19:08:21] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/iSaP
[19:09:29] *** Quits: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net) (Quit: carllerche)
[19:09:47] <jc-denton> Well I never tried it, just read about it.
[19:09:59] <jc-denton> What about debugging rust programs?
[19:10:04] <cmr> what about it?
[19:10:11] <jc-denton> -g does not work
[19:10:25] <cmr> -g isn't used for debugging
[19:10:45] <cmr> -Z debug-info and -Z extra-debug-info, for gdb-compatible debuginfo
[19:10:58] <cmr> `--cfg debug` to enable debug! logging
[19:11:05] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[19:11:09] *** Joins: sebcrozet (Thunderbir@moz-6DA639AF.w80-13.abo.wanadoo.fr)
[19:11:25] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Ping timeout)
[19:12:20] *** Joins: wikkit (Mibbit@moz-A855F6C0.w82-127.abo.wanadoo.fr)
[19:12:35] *** Quits: wikkit (Mibbit@moz-A855F6C0.w82-127.abo.wanadoo.fr) (Quit: http://www.mibbit.com ajax IRC Client)
[19:13:21] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[19:15:04] *** Joins: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP)
[19:15:08] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[19:16:01] *** Quits: jgilbert (jgilbert@moz-3622627C.smartcity.com) (Ping timeout)
[19:16:12] <jc-denton> info locals does not show me any locals with -Z debug-info
[19:16:27] <cmr> you need extra-debug-info, and I don't think it's implemented yet.
[19:18:00] <jc-denton> ok ic
[19:18:51] *** Joins: stampy (Mibbit@moz-D08E0368.hsd1.pa.comcast.net)
[19:19:26] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[19:19:46] *** Joins: joebobjoe (joebobjoe@55F2E07A.7F841963.2213276E.IP)
[19:21:34] <nmatsakis> graydon: ping
[19:23:35] *** Joins: victorporof (victorporo@7EA800E4.67625325.D111398B.IP)
[19:25:16] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[19:25:48] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[19:25:51] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[19:26:35] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[19:27:05] <jmgrosen> is there a way i can find out what commit my rustc was compiled from?
[19:27:17] <cmr> jmgrosen: rustc --version
[19:27:18] <kimundi> __version?
[19:27:20] <Ralith> kmc: my hope is that, if MPS looks suitable, Mozilla and Ravenbrook will work out something a bit more formal and specific than the existing OpenDylan clause; I've spoken with the Ravenbrook people on this subject before, and they seem very accommodating.
[19:27:34] <jmgrosen> cmr: that only gives me 0.8-pre
[19:27:45] *** Quits: bent (chatzilla@moz-2CD73AA6.triad.res.rr.com) (Connection reset by peer)
[19:27:56] <cmr> I get:
[19:27:57] <cmr> rustc 0.8-pre (69a237e 2013-07-23 04:46:41 -0700)
[19:27:59] <cmr> host: x86_64-unknown-linux-gnu
[19:28:02] <kmc> Ralith: excellent
[19:28:27] <Ralith> I suspect the OpenDylan language is vague not because they demanded it be that way, but because nobody had lawyer-time to hammer out something more precise.
[19:28:34] <jc-denton> I need some sleep
[19:28:35] <jc-denton> cu
[19:28:36] <jmgrosen> cmr: hm, weird
[19:28:59] *** Quits: dherman (dherman@96DF99F7.5E7911EA.DA40C4B3.IP) (Quit: dherman)
[19:29:27] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[19:30:14] *** Quits: Uther (Instantbir@moz-1B244B05.hfc.dyn.abo.bbox.fr) (Ping timeout)
[19:33:29] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[19:33:32] *** Quits: pyrac (pyrac@moz-873BFA0.w90-5.abo.wanadoo.fr) (Ping timeout)
[19:34:41] *** Joins: pyrac (pyrac@moz-873BFA0.w90-5.abo.wanadoo.fr)
[19:36:43] *** Joins: bent (chatzilla@moz-2CD73AA6.triad.res.rr.com)
[19:38:04] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[19:39:02] *** Quits: Ms2ger (Ms2ger@E699BE68.4A4AF98A.F15B0BB3.IP) (Quit: nn)
[19:40:52] <erickt> bblum: ping re https://github.com/mozilla/rust/issues/7887. I'm also torn between references and moving. I found most of uses of .map() that just drop the reference to the option/result/vec after the call, so it'd be more efficient for .map() to consume the input
[19:41:03] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[19:41:30] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[19:41:56] <erickt> bblum: but I could see using iterators expect you want to use references
[19:42:00] <doomlord> http://www.gamesindustry.biz/articles/2013-07-24-xbox-one-to-allow-indie-self-publishing-report   <<< i hope i't'll be easy enough to get rust compiling on the xb1 eventually :)
[19:42:01] <erickt> most of the time
[19:43:14] <cmr> doomlord: it seems the next-gen consoles are very very PC-like, should be easy to get LLVM tooling for them...
[19:43:36] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[19:43:59] *** Quits: lkuper (lkuper@5188CCE.A402E718.C082B7DC.IP) (Quit: lkuper)
[19:45:38] <MaikKlein1> cmr, aren't they all x86?
[19:46:18] <saati> nintendo isn't
[19:46:26] <MaikKlein1> i only know that the ps4 has some custom opengl stuff
[19:46:26] *** Quits: joelteon (joel@moz-317E8D0C.io) (Quit: bye)
[19:46:35] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Quit: Computer has gone to sleep.)
[19:46:47] <jensnockert> Nintendo has a PPC processor, so it should be easy to bring LLVM to that too.
[19:46:59] *** Joins: RMF (RMF@5C293616.B791E6A9.8D19547B.IP)
[19:47:13] <saati> yeah but not like any of them are homebrew friendly
[19:47:30] <jensnockert> The Playstation 4 could be, the PS2 was.
[19:48:03] *** Joins: joelteon (joel@moz-317E8D0C.io)
[19:48:11] <jensnockert> And the Xbox 360 had XNA.
[19:48:31] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[19:48:45] *** Joins: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net)
[19:49:55] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[19:50:02] *** Joins: bct (bct@moz-D3BEA05.ed.shawcable.net)
[19:50:45] <cmr> oh it's OSCON
[19:51:24] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[19:51:26] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[19:53:17] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[19:54:42] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[19:54:56] *** Joins: Kruppe (user@moz-4DDA8AB8.uwaterloo.ca)
[19:57:21] *** Quits: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com) (Ping timeout)
[19:57:43] *** Quits: joebobjoe (joebobjoe@55F2E07A.7F841963.2213276E.IP) (Quit: Textual IRC Client: www.textualapp.com)
[19:58:16] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[19:59:34] *** Joins: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com)
[19:59:56] *** Quits: Frunz (YesHello@56795E1D.D402F0D8.985B58.IP) (Ping timeout)
[20:01:26] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: zzzzzzzzzz)
[20:04:47] <kmc> I think CPU architecture is rarely the main obstacle when porting to a new platform (especially when you already have LLVM)
[20:05:08] *** Parts: sebcrozet (Thunderbir@moz-6DA639AF.w80-13.abo.wanadoo.fr) ()
[20:07:42] *** Joins: sebcrozet (sebcrozet@moz-C27D92D8.w193-252.abo.wanadoo.fr)
[20:08:48] *** Joins: graydon1 (graydon@moz-1C52C8D0.cable.teksavvy.com)
[20:08:59] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Connection reset by peer)
[20:09:32] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[20:11:32] *** Quits: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com) (Ping timeout)
[20:12:17] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[20:12:54] <jensnockert> kmc: Depends a lot on how exotic your CPU is, http://llvm.org/docs/CodeGenerator.html#target-feature-matrix
[20:13:10] <jensnockert> Even ARM is missing a lot of boxes ;)
[20:14:22] <kmc> fair enough
[20:14:59] <kmc> my angle is not so much "CPU architecture is easy" as "other platform differences are a lot harder"
[20:15:16] *** Joins: tchoma (tchoma@moz-E58E29CC.dsl.static.sonic.net)
[20:15:28] <kmc> when I worked on making GHC target Android everyone was like "GHC already supports ARM, what's the big deal" and, well, it turns out that Android is not much like vanilla GNU/Linux...
[20:15:51] <jensnockert> Yeah, Android is silly.
[20:15:57] <jensnockert> Also, fragmentation.
[20:17:05] <jensnockert> (For example, I have a tablet with a mipsel processor)
[20:17:41] <kmc> fun
[20:18:07] *** Quits: joelteon (joel@moz-317E8D0C.io) (Quit: bye)
[20:18:21] <jensnockert> Not really, if you're a developer.
[20:18:41] <jensnockert> Or user tbh, most common applications are blocked.
[20:19:40] *** Joins: joelteon (joel@moz-317E8D0C.io)
[20:20:29] *** Joins: mvalzelli (mvalzelli@moz-36091CB9.ip217.fastwebnet.it)
[20:20:40] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Connection reset by peer)
[20:21:08] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[20:21:08] *** ChanServ sets mode: +o tjc
[20:22:39] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[20:22:39] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/0SlQfA
[20:22:40] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[20:23:30] *** Joins: Uther (Instantbir@moz-1B244B05.hfc.dyn.abo.bbox.fr)
[20:25:01] <james4k> is there a mailing list or something i can follow?
[20:25:17] <cmr> james4k: https://mail.mozilla.org/pipermail/rust-dev/
[20:25:37] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[20:25:37] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/MiNyDg
[20:25:37] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[20:25:38] <james4k> thanks cmr
[20:25:40] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[20:25:40] <ghrust> 01[13rust01] 15bors pushed 18 new commits to 06auto: 02http://git.io/HWVpCQ
[20:25:40] <ghrust> 13rust/06auto 147434080 15Erick Tryzelaar: rustc: remove some dead functions
[20:25:40] <ghrust> 13rust/06auto 149ad815e 15Erick Tryzelaar: std: rename str.as_bytes_with_null_consume to str.to_bytes_with_null
[20:25:40] <ghrust> 13rust/06auto 14cfd89c4 15Erick Tryzelaar: std: remove os::as_c_charp
[20:25:42] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[20:26:33] <james4k> oh..it is actually on the website isn't it; sorry for the blindness
[20:26:41] <cmr> it's ok :p
[20:26:52] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[20:28:06] *** Quits: tchoma (tchoma@moz-E58E29CC.dsl.static.sonic.net) (Quit: My MacBook has gone to sleep. ZZZzzz‚Ä¶)
[20:28:10] *** Quits: echristo (echristo@DCF57675.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[20:29:06] *** Joins: mellum (falk@moz-C8220309.dip0.t-ipconnect.de)
[20:30:10] *** Joins: echristo (echristo@DCF57675.D6CCE4AE.77834EAA.IP)
[20:30:26] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[20:30:38] *** Quits: pyrac (pyrac@moz-873BFA0.w90-5.abo.wanadoo.fr) (Ping timeout)
[20:31:31] <kmc> the scope of unsafe { ... } is purely static and lexical, correct?  if I call a safe function inside unsafe { ... } it doesn't get any new powers?
[20:31:47] <jdm> kmc: correct
[20:32:38] <kmc> good :)
[20:32:53] *** Joins: dherman (dherman@96DF99F7.5E7911EA.DA40C4B3.IP)
[20:32:53] *** ChanServ sets mode: +o dherman
[20:34:07] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[20:34:21] *** Joins: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com)
[20:38:47] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Quit: My MacBook has gone to sleep. ZZZzzz‚Ä¶)
[20:38:47] <MaikKlein1> we have some weird testing file names like issue_4016
[20:38:57] <cmr> MaikKlein1: it's not wierd
[20:39:04] <cmr> it's when you're too lazy to come up with a good name for the testcase
[20:39:09] <cmr> so you just fill in the issue number instead :p
[20:39:22] <MaikKlein1> ah :p
[20:39:32] <tjc> I don't find test caes names to be useful, generally, but an issue number is useful because you can look it up in the issue tracker for more info
[20:39:39] <bstrie> I actually really like test cases to have issue names
[20:39:40] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[20:39:45] <erickt> me too
[20:39:45] <cmr> I agree
[20:39:50] <tjc> I can grep for an issue number, can't find anything else by grepping
[20:40:16] *** Quits: timm (timm@moz-37B954AF.superkabel.de) (Input/output error)
[20:40:46] *** Joins: tchoma (tchoma@moz-E58E29CC.dsl.static.sonic.net)
[20:40:59] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[20:41:13] <erickt> tjc: aren't you supposed to be off presenting at OSCON?
[20:41:21] <tjc> erickt: nope, I'm not presenting at OSCON
[20:41:28] <cmr> dherman was I thought
[20:41:58] *** Joins: pyrac (pyrac@moz-873BFA0.w90-5.abo.wanadoo.fr)
[20:42:00] <erickt> ah ok. tjc, where did you do your presentation then?
[20:42:06] <tjc> erickt: Open Source Bridge
[20:42:14] <MaikKlein1> has he already held the presentation? 
[20:42:22] <MaikKlein1> -> dherman
[20:42:23] <cmr> true_droid: thanks for the closure blog post
[20:42:31] <cmr> true_droid: it really illuminated my understanding :)
[20:42:37] <tjc> it's tomorrow
[20:42:38] <tjc> http://www.oscon.com/oscon2013/public/schedule/detail/28741
[20:43:16] <true_droid> cmr: no problem, I wrote it to understand closures better myself :)
[20:44:50] *** Quits: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com) (Ping timeout)
[20:45:03] *** Quits: reyre (reyre@86C3727C.33EE9F8A.1139E686.IP) (Client exited)
[20:46:33] <MaikKlein1> is someone working on https://github.com/mozilla/rust/issues/3573 ?
[20:47:05] <cmr> MaikKlein1: you are :p
[20:47:09] <MaikKlein1> :p
[20:47:13] <tjc> MaikKlein1: some of the interns might be, I'm not sure
[20:48:48] <dherman> MaikKlein1: I'm presenting tomorrow afternoon
[20:48:53] <dherman> oh tjc already answered
[20:48:56] <dherman> what tjc said
[20:49:03] <MaikKlein1> dherman, :)
[20:49:06] *** Quits: alex_abreu (alex@moz-7421D6C9.mc.videotron.ca) (Client exited)
[20:49:10] <dherman> I'm not even at oscon yet
[20:49:21] <dherman> at an ECMA TC39 meeting in seattle
[20:49:29] <dherman> 'scuse me it's now Ecma, not ECMA ;-P
[20:49:50] <cmr> Now it sounds even *more* like a skin condition
[20:50:07] <MaikKlein1> dherman, when will the slides be available online? (can't wait :p)
[20:52:00] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Ping timeout)
[20:52:05] <MaikKlein1> oh cmon rust I am fixing stuff and everytime I do a make check it throws new errors at me. :(
[20:52:31] *** Joins: alex-abreu (alex@moz-7421D6C9.mc.videotron.ca)
[20:52:51] <dherman> MaikKlein1: I'll post them right after I give the talk
[20:53:04] <dherman> not sure how exciting they'll be
[20:53:05] <dherman> to someone who already knows rust
[20:53:11] <MaikKlein1> dherman, nice 
[20:53:27] <MaikKlein1> dherman, I am always excited if I see something about Rust
[20:55:01] *** Quits: Jesse_ (jruderman@moz-537BCF9.hsd1.ca.comcast.net) (Quit: Jesse_)
[20:55:33] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[20:58:11] *** Joins: Nefzaoui (chatzilla@D61C2EA.93D3D8DB.360EF119.IP)
[20:58:37] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[20:58:41] *** Quits: mvalzelli (mvalzelli@moz-36091CB9.ip217.fastwebnet.it) (Quit: Computer has gone to sleep.)
[20:59:45] *** Joins: Nisstyre (wes@moz-FD86289.netflash.net)
[21:01:51] *** Joins: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP)
[21:06:12] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[21:06:34] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[21:07:09] *** Joins: brendan (brendaneic@995B2EEE.5E7911EA.DA40C4B3.IP)
[21:07:22] *** Joins: reyre (reyre@4011B3D9.D5A563EE.47C41102.IP)
[21:08:20] <nmatsakis> sully: r? https://github.com/mozilla/rust/pull/8027
[21:09:30] <jensnockert> saati: On the topic of homebrew friendly, http://www.ign.com/articles/2013/07/24/independent-developers-will-self-publish-games-on-xbox-one
[21:09:42] <cmr> jensnockert: that is literally what started the conversation
[21:09:48] <jensnockert> Oh‚Ä¶
[21:09:57] <cmr> "[
[21:09:59] <cmr> *:p
[21:09:59] * jensnockert hugs and asks for forgiveness.
[21:10:23] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[21:11:19] <cmr> nmatsakis: "If there are both lifetime and type parameters, lifetime parameters must 
[21:11:21] <cmr> appear first.
[21:11:23] <cmr> "
[21:11:27] <cmr> That is going to interact very poorly with paths.
[21:11:39] <cmr> foo::bar<'a, 'b, 'c, T, U>
[21:12:01] <cmr> for something like foo<'a, 'b, T>::bar<'c, U>
[21:12:39] *** Quits: jdm (jdm@F2D29657.F60B0462.67AC9B1.IP) (Quit: Lost terminal)
[21:12:41] *** Joins: RageOfThou (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[21:12:42] *** Quits: tchoma (tchoma@moz-E58E29CC.dsl.static.sonic.net) (Quit: My MacBook has gone to sleep. ZZZzzz‚Ä¶)
[21:12:43] *** Quits: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Quit: msingle)
[21:12:48] <cmr> the path parametization syntax is already problematic, this will just throw fuel into the flames
[21:13:20] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[21:13:20] <engla> aren't lifetime parameters optional too?
[21:13:26] <cmr> engla: only sometimes.
[21:13:35] <engla> hm ok
[21:13:37] <cmr> they aren't allowed to be infered in some contexts.
[21:13:56] <cmr> trait bounds is one place I think?
[21:14:05] <jedestep> sometimes the compiler can fudge the anonymous lifetime to match the declared one but not always
[21:14:50] *** Joins: eatkinson (eatkinson@moz-AD233F1B.dia.static.qwest.net)
[21:16:15] *** Quits: eatkinson (eatkinson@moz-AD233F1B.dia.static.qwest.net) (Quit: eatkinson)
[21:16:39] <bstrie> how do you iterate on fixed-length vectors?
[21:16:41] <bstrie> just make a slice?
[21:16:45] <cmr> bstrie: yeah
[21:17:07] <nmatsakis> cmr: I think the plan is to move all parameters onto the loc in the path where they were declared
[21:17:14] <nmatsakis> cmr: rather than this bizarro flattening we do now
[21:17:30] <cmr> nmatsakis: is that going to make parsing difficult?
[21:17:37] *** Joins: tchoma (tchoma@moz-E58E29CC.dsl.static.sonic.net)
[21:17:55] <cmr> or, at least, more difficult
[21:17:58] <cmr> ie, let x = foo<bar>
[21:18:02] <cmr> maybe not?
[21:18:04] <nmatsakis> cmr: I don't think so, in some contexts it will be required to do foo::<...>::bar::<...> 
[21:18:15] <nmatsakis> that is, any place where ::<> is required today
[21:18:15] <cmr> nmatsakis: oh ok, so it'd be keeping the extra :: around
[21:18:21] <cmr> "extra"
[21:18:24] <cmr> that seems fine to me
[21:18:30] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[21:18:33] <cmr> although bstrie has a stronger opinion on it than I do
[21:18:39] <nmatsakis> i'm not a big fan of ::<>
[21:18:53] <nmatsakis> but the only alternative is arbitrary lookahead...
[21:19:08] * bstrie begins spurting blood from his neck
[21:19:12] <bstrie> :P
[21:19:13] <nmatsakis> ...not that I even care that much about that :) but I'm outvoted.
[21:19:15] <jedestep> that escalated quickly
[21:19:49] <nmatsakis> anyway that's quite separate
[21:20:05] <engla> nmatsakis: type parameters that are not declared anywhere in the path, where do they go?  hm where was my example.. when there is a parameter in an inolved type that somehow does not appear in the path
[21:20:25] <nmatsakis> engla: was it perhaps having to do w/ traits?
[21:20:31] <engla> yes
[21:20:41] <nmatsakis> engla: we have a plan for that too, let me see if I can pull up the ref for you explaining it
[21:21:14] <nmatsakis> engla: pnkfelix has a quite thorough explanation here http://blog.pnkfx.org/blog/2013/04/22/designing-syntax-for-associated-items-in-rust/ :)
[21:21:39] <nmatsakis> engla: but I guess the heart of it is http://blog.pnkfx.org/blog/2013/04/22/designing-syntax-for-associated-items-in-rust/#proposal
[21:21:44] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[21:22:00] *** Quits: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net) (Input/output error)
[21:22:06] <engla> I don't think this was what I was thinking about
[21:22:35] <nmatsakis> I don't know of any other case where that can occur
[21:22:53] <nmatsakis> except when referencing an associated item  of a trait, in which case the "self" type of the trait is not part of the path
[21:23:03] <engla> hm ok
[21:25:51] *** Joins: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com)
[21:29:44] *** Quits: MaikKlein1 (maik@moz-2B0E2234.dip0.t-ipconnect.de) (Ping timeout)
[21:32:10] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[21:33:19] *** Joins: jdm (jdm@CAB30FBD.8F96AEA7.2D179A7D.IP)
[21:35:08] *** Quits: reyre (reyre@4011B3D9.D5A563EE.47C41102.IP) (Ping timeout)
[21:38:44] *** sam113101 is now known as sam113101_afk
[21:39:21] *** sam113101_afk is now known as sam113101
[21:44:59] *** Joins: strcat (strcat@moz-61B073BC.cpe.net.cable.rogers.com)
[21:46:35] *** Quits: Kruppe (user@moz-4DDA8AB8.uwaterloo.ca) (Ping timeout)
[21:47:07] *** Quits: tchoma (tchoma@moz-E58E29CC.dsl.static.sonic.net) (Quit: My MacBook has gone to sleep. ZZZzzz‚Ä¶)
[21:48:01] *** bnicholson is now known as bnicholson|afk
[21:50:07] *** Joins: reyre (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[21:50:47] *** Joins: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[21:51:14] *** Quits: dew (Instantbir@moz-2C6F2E2.dhcp.stls.mo.charter.com) (Ping timeout)
[21:51:48] *** Quits: reyre (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Ping timeout)
[21:52:10] *** Quits: brendan (brendaneic@995B2EEE.5E7911EA.DA40C4B3.IP) (Quit: brendan)
[21:52:19] *** Quits: vosen (vosen@moz-266BA656.icpnet.pl) (Quit: Leaving)
[21:52:24] *** reyre_ is now known as reyre
[21:55:18] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Quit: WeeChat 0.4.1)
[21:55:25] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[22:02:27] *** Joins: dew (Instantbir@moz-2C6F2E2.dhcp.stls.mo.charter.com)
[22:03:33] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[22:04:06] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[22:06:33] *** Quits: LU324 (stuff@moz-A17E9A7B.dyn.embarqhsd.net) (Ping timeout)
[22:07:13] *** Joins: LU324 (stuff@moz-A17E9A7B.dyn.embarqhsd.net)
[22:07:30] *** jyeo is now known as jyeo_afk
[22:08:06] *** Quits: LU324 (stuff@moz-A17E9A7B.dyn.embarqhsd.net) (Connection reset by peer)
[22:08:10] *** Quits: mellum (falk@moz-C8220309.dip0.t-ipconnect.de) (Quit: mellum)
[22:09:27] *** Joins: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com)
[22:09:33] *** Joins: LU324 (stuff@moz-A17E9A7B.dyn.embarqhsd.net)
[22:10:33] *** Joins: tchoma (tchoma@moz-E58E29CC.dsl.static.sonic.net)
[22:10:46] *** Quits: LU324 (stuff@moz-A17E9A7B.dyn.embarqhsd.net) (Connection reset by peer)
[22:15:00] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[22:20:09] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Ping timeout)
[22:22:29] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[22:23:20] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[22:25:27] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[22:25:48] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[22:26:17] *** Quits: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP) (Client exited)
[22:28:22] *** Joins: timm (timm@moz-37B954AF.superkabel.de)
[22:28:43] <doomlord> match (a,b) {....}  - it seems it can''t deal with a,b being the same struct with named fields - destructurring of a struct requires you use the field names?
[22:29:07] <doomlord> .. so is it best to stick to enums with purely unnamed fields?
[22:29:50] *** Quits: tcsc (tcsc@moz-7246F5CD.hsd1.ma.comcast.net) (Quit: bye!)
[22:30:03] *** Quits: timm (timm@moz-37B954AF.superkabel.de) (Ping timeout)
[22:30:44] <engla> you can destructure a struct like you can an enum
[22:30:48] <kimundi> doomlord: What are you trying to do?
[22:31:34] <doomlord> i was just experimenting with using an enum with name fields instead of tuple-structs; what i was trying to write is entirely possible with the tuple-structs
[22:31:50] *** Joins: jfbk (textual@moz-EEA9CFB3.nyc.res.rr.com)
[22:31:54] <doomlord> the example was double-dispatch collision 
[22:32:02] *** Joins: brendan (brendaneic@995B2EEE.5E7911EA.DA40C4B3.IP)
[22:32:43] <doomlord> classic example used on wikipedia to demonstrate duoble dispatch..asteroids ..  collide(spaceshp, asteroid) etc
[22:33:26] <doomlord> maybe there's something else you can do that i'm missing
[22:33:27] *** Joins: lkuper (lkuper@5188CCE.A402E718.C082B7DC.IP)
[22:34:04] *** Quits: jorendorff (jorendorff@moz-1747FB68.hsd1.tn.comcast.net) (Quit: jorendorff)
[22:34:23] *** Joins: jorendorff (jorendorff@moz-1747FB68.hsd1.tn.comcast.net)
[22:34:33] <doomlord> match (a,b)  {    (Spaceship{pos,heading,vel}, Spaceship(pos,heading,vel}) =>.../* doesn't like that because they're the same.. */
[22:34:37] <shachaf> Hmm, who's Corey Richardson?
[22:34:40] <cmr> hello
[22:34:42] <cmr> that is me
[22:34:58] *** Quits: jorendorff (jorendorff@moz-1747FB68.hsd1.tn.comcast.net) (Quit: jorendorff)
[22:35:01] <shachaf> Aha.
[22:35:06] <cmr> what's up?
[22:35:22] <shachaf> I just saw your email about the struct thing and wondered which nick it mapped to.
[22:35:25] <shachaf> Nothing in particular.
[22:35:27] <cmr> ah, ok
[22:35:54] <saati> jensnockert: oh, that's nice
[22:36:06] <shachaf> Hmm, I wonder whether enum and struct syntax overlaps at all right now.
[22:36:14] <cmr> shachaf: it does a bit
[22:36:23] <cmr> enum Foo { Bar { field: type, ... } }
[22:36:27] <nmatsakis> bjz_: I may have solved the extern C bug...
[22:36:29] <shachaf> E.g. is something like "enum Foo(int, char);" or "enum Foo { x: int, y: char }" ever valid?
[22:36:43] <shachaf> cmr: That's not valid with "struct", though, is it?
[22:36:45] <kmc> doomlord: you'd have to do Spaceship{pos = pos1, heading = heading1 ... } I think
[22:36:45] <cmr> shachaf: not like that though
[22:36:48] <cmr> shachaf: no, it isn't
[22:36:57] <cmr> shachaf: they don't overlap in that regard
[22:37:02] <shachaf> The question is whether there's ever any code that would be valid with enum switched for struct or vice versa.
[22:37:32] <shachaf> Maybe that'd be the an way to combine them syntactically -- just use enum with the current struct syntax. Then again that's kind of hacky.
[22:37:35] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[22:37:35] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/HWVpCQ
[22:37:35] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[22:37:36] <kmc> er pos: pos1, heading: heading1?
[22:38:01] <shachaf> kmc: I've made that mistake too many times already.
[22:38:04] *** Joins: sigma (sigma@moz-BE11A887.range109-151.btcentralplus.com)
[22:40:39] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[22:40:40] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/CaQwpA
[22:40:40] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[22:41:37] <doomlord> kmc .. thanks that works. ok i see the syntax is like the revers of initialization, since its matching in a pattern
[22:41:43] <kmc> yeah
[22:41:50] <kmc> T { x } is sugar for T { x: x }
[22:41:58] <doomlord> thats what i was "missing". i'd seen the sugar only
[22:41:59] <kmc> GHC Haskell calls this "named field puns"
[22:42:18] <doomlord> i had Ship{pos,vel} ..
[22:42:20] <shachaf> It probably makes more sense than in Haskell, though, because there's no shadowing.
[22:42:39] *** Joins: dreamer__ (dreamer_@90E8C08F.8480A87C.DDAA0084.IP)
[22:42:42] <kmc> in fact in GHC you could do T { .. } and that will automatically put x and y and whatever in scope, without mentioning them
[22:42:45] <kmc> which is a little weird
[22:42:51] <kmc> implicit binders make me sad
[22:43:07] <kmc> but it can be very useful, especially when using records as a kind of poor man's first-class modules
[22:43:22] <doomlord> i dont seem to be able to get s1:Ship or anything like that, it seems you *must* destructuure, but thats ok
[22:43:35] <kmc> doomlord: you mean you want to ignore some fields?
[22:43:44] <doomlord> i know you can _
[22:44:02] <kmc> you can do Point { x, _ }
[22:44:11] *** Quits: jfbk (textual@moz-EEA9CFB3.nyc.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzz‚Ä¶)
[22:44:31] *** Joins: pcwalton (pcwalton@33605CA4.9F929CFD.F9E1BAE1.IP)
[22:44:31] *** ChanServ sets mode: +o pcwalton
[22:44:41] <doomlord> my C/C++ brain has only had the option of named fields relative to an object so thinking destructure is both fresh/exccitting ..but also slightly alien :)
[22:44:52] *** Joins: jfbk (textual@moz-EEA9CFB3.nyc.res.rr.com)
[22:46:11] <dreamer__> hi, everyone - I have stupid question about using core::rand in rust 0.7
[22:46:14] <dreamer__> this code:
[22:46:23] <dreamer__> use core::rand::RngUtil;
[22:46:23] <dreamer__> fn myrand(r: int) -> int {
[22:46:23] <dreamer__>     let mut rng = rand::rng();
[22:46:23] <dreamer__>     rng.gen_int_range(0, r)
[22:46:23] <dreamer__> }
[22:46:27] <cmr> dreamer__: there is no `core` in 0.7
[22:46:32] <cmr> It was renamed to `std`
[22:46:33] <dreamer__> main.rs:6:18: 6:27 error: unresolved name: `rand::rng`.
[22:46:33] <dreamer__> main.rs:6     let mut rng = rand::rng();
[22:46:33] <dreamer__>                             ^~~~~~~~~
[22:47:04] <dreamer__> eh, then doc for 0.7 are out of date?
[22:47:13] <cmr> yes, unfortunately
[22:47:32] <engla> oops
[22:47:40] <dreamer__> main.rs:3 use std::rand::RngUtil;
[22:47:41] <dreamer__>               ^~~~~~~~~~~~~~~~~~~
[22:47:42] <cmr> that doc bug is fixed on master
[22:47:43] <engla> http://static.rust-lang.org/doc/0.7/std/rand.html  at least it says std rand in the URL
[22:47:59] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[22:48:00] <dreamer__> failed to resolve import
[22:48:03] <cmr> dreamer__: see the example on http://static.rust-lang.org/doc/std/rand.html
[22:48:27] <cmr> you can't use printfln!() though
[22:48:28] <dreamer__> ok, I'll try again ;)
[22:49:37] <doomlord> ok it seems _ means 'dont match any unmentioned fields' thats fine (eg one can have 10 fields and just name 2 that you need, and pput one _  )
[22:49:46] <cmr> doomlord: that's a bug though
[22:49:50] <cmr> it should be * for that
[22:49:52] <cmr> and _ for a single field
[22:50:05] <cmr> (like in enums)
[22:50:09] <engla> * is only for the whole content?
[22:50:30] <doomlord> i tried .. aswell
[22:50:58] <cmr> rusti: enum Foo { foo(int, int, int, int) }; let x = foo(1, 2, 3, 4); match x { foo(a, *) => printfln!("%?", a) }
[22:50:59] -rusti- <anon>:7:89: 7:90 error: unexpected token: `*`
[22:50:59] -rusti- <anon>:7          enum Foo { foo(int, int, int, int) }; let x = foo(1, 2, 3, 4); match x { foo(a, *) => printfln!("%?", a) }
[22:50:59] -rusti-                                                                                                   ^
[22:50:59] -rusti- application terminated with error code 101
[22:51:06] <cmr> rusti: enum Foo { foo(int, int, int, int) }; let x = foo(1, 2, 3, 4); match x { foo(a, _) => printfln!("%?", a) }
[22:51:07] -rusti- <anon>:7:82: 7:91 error: this pattern has 2 fields, but the corresponding variant has 4 fields
[22:51:07] -rusti- <anon>:7          enum Foo { foo(int, int, int, int) }; let x = foo(1, 2, 3, 4); match x { foo(a, _) => printfln!("%?", a) }
[22:51:07] -rusti-                                                                                            ^~~~~~~~~
[22:51:08] -rusti- error: aborting due to previous error
[22:51:08] <engla> cmr: I hope printf! etc will be revisited when io changes again.. it's not a good idea to have so many similar identifiers in the prelude, I mean  print, println, printf!, printfln!
[22:51:09] <cmr> hm
[22:51:10] -rusti- application terminated with error code 101
[22:51:12] <cmr> I suppose so
[22:51:22] <cmr> I thought it worked for "rest" too though
[22:51:54] <dreamer__> use std::rand;
[22:51:54] <dreamer__> use std::rand::RngUtil;
[22:51:54] <dreamer__> fn main() {
[22:51:54] <dreamer__>     let mut rng = rand::rng();
[22:51:54] <dreamer__>     if rng.gen() { // bool
[22:51:54] <dreamer__> 	println(fmt!("%?", rng.gen()));
[22:51:56] <dreamer__>     }
[22:51:58] <dreamer__> }
[22:52:04] <dreamer__> does not compile due to import errors
[22:52:15] <dreamer__> maybe I should switch to 0.8?
[22:52:18] <doomlord> people might just end up making those as helpers .. many copies of the same ones
[22:52:21] <engla> what's the error?
[22:52:26] <engla> dreamer__: compile from git if you can
[22:52:28] <dreamer__> example.rs:1:4: 1:14 error: unresolved name
[22:52:28] <dreamer__> example.rs:1 use std::rand;
[22:52:28] <dreamer__>                  ^~~~~~~~~~
[22:52:28] <dreamer__> example.rs:1:4: 1:14 error: failed to resolve import: std::rand
[22:52:28] <dreamer__> example.rs:1 use std::rand;
[22:52:29] <dreamer__>                  ^~~~~~~~~~
[22:52:31] <dreamer__> example.rs:2:4: 2:23 error: unresolved name
[22:52:35] <dreamer__> example.rs:2 use std::rand::RngUtil;
[22:52:37] <dreamer__>                  ^~~~~~~~~~~~~~~~~~~
[22:52:39] <dreamer__> example.rs:2:4: 2:23 error: failed to resolve import: std::rand::RngUtil
[22:52:41] <dreamer__> example.rs:2 use std::rand::RngUtil;
[22:52:43] <dreamer__>                  ^~~~~~~~~~~~~~~~~~~
[22:52:45] <cmr> dreamer__: what does `rustc --version` say?
[22:52:45] <dreamer__> error: failed to resolve imports
[22:52:47] <dreamer__> error: aborting due to 5 previous errors
[22:53:48] <dreamer__> 0.6, but I am 100% sure, that I compiled tarball 0.7 from main page
[22:54:01] <engla> maybe you didn't install it
[22:54:02] <dreamer__> perhaps tarball is named wrong?
[22:54:03] <cmr> did you install, though?
[22:54:17] <dreamer__> compiled, created rpm from it and installed ;)
[22:54:30] <cmr> you did *something* wrong then
[22:57:06] <cmr> acrichto_: ping
[22:57:17] <acrichto_> cmr: pong
[22:57:59] <cmr> acrichto_: any update on https://github.com/mozilla/rust/pull/7115 ? still broken on windows?
[22:58:13] *** Quits: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com) (Input/output error)
[22:59:08] <acrichto_> cmr: yes and no, the best that I came up with is stack clobbering somewhere, although it's unclear where. It may be a codegen issue with LLVM? Right now the problem definitely manifests itself on windows, but if you tweak fast_ffi labeled functions (which changes stack placement somewhat I think) I can also get it to fail on i686 linux predictably
[22:59:20] <acrichto_> cmr: I tried give another stab at it a few days ago but I didn't make it very far :(
[23:01:14] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[23:01:17] <cmr> acrichto_: does not reproduce on x64?
[23:01:39] <acrichto_> cmr: not from what I could tell, and I could never get it to happen on osx regardless
[23:01:52] <acrichto_> although you can build i686 linux from x86_64 linux hosts
[23:01:55] <cmr> acrichto_: do you have a minimal testcase?
[23:01:57] <cmr> right
[23:02:04] *** Quits: tavoe (Mibbit@moz-F85B6108.student.rit.edu) (Quit: http://www.mibbit.com ajax IRC Client)
[23:02:11] <acrichto_> cmr: the compiler never gets built
[23:02:24] <acrichto_> it fails on stage2 libstd
[23:02:37] <cmr> you still have the stage1 compiler though right?
[23:02:51] *** Quits: lkuper (lkuper@5188CCE.A402E718.C082B7DC.IP) (Quit: lkuper)
[23:03:22] <acrichto_> yes, oh good point! (make check-stage1)
[23:03:29] <acrichto_> I'll try running that tonight on an i686 host
[23:03:34] *** Joins: MaikKlein1 (maik@moz-2B0E2234.dip0.t-ipconnect.de)
[23:03:35] <acrichto_> hopefully that'll find a small test case
[23:03:39] <cmr> well I can take a stab at it too
[23:04:00] <acrichto_> yeah feel free
[23:04:07] <cmr> more eyeballs are good, especially for nasty codegen problems
[23:04:38] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[23:04:38] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 143049212 to 14330378d: 02http://git.io/N3iJvQ
[23:04:38] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[23:04:41] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[23:04:41] <ghrust> 01[13rust01] 15bors pushed 13 new commits to 06auto: 02http://git.io/HOhzxQ
[23:04:41] <ghrust> 13rust/06auto 14172ea83 15Michael Sullivan: Get rid of an unused variable warning.
[23:04:41] <ghrust> 13rust/06auto 1489c4af0 15Michael Sullivan: Fix a default method polymorphism bug.
[23:04:42] <ghrust> 13rust/06auto 144b9759e 15Michael Sullivan: Add a to_owned_vec method to IteratorUtil.
[23:04:42] <jdm> given enough bugs, all eyeballs are shallow
[23:04:44] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[23:04:57] <acrichto_> I'm not sure if there's more LLVM changes we want, but it's probably a good idea to ride releases now except for the few patches that haven't made it into LLVM proper yet
[23:05:16] <cmr> Can I pull from `alexcrichton:llvm-upgrades` and get a working rust tree with the llvm upgrade?
[23:05:24] * cmr not really sure how this works
[23:05:30] <cmr> "working"
[23:05:34] <acrichto_> cmr: yes
[23:05:36] <cmr> ok
[23:05:36] *** Quits: echristo (echristo@DCF57675.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[23:05:39] <acrichto_> you'll want to re-run configure
[23:05:43] <acrichto_> with i686 options
[23:06:00] <acrichto_> and then wait forever for a new llvm to build
[23:07:06] <cmr>  --build-triple=i686-unknown-linux-gnu ?
[23:07:18] <cmr> or, --target-triples ?
[23:07:34] <acrichto_> cmr: check the i686 configure logs on buildbot
[23:07:38] <acrichto_> that's where I get the cfg flags from
[23:07:39] <cmr> good idea
[23:08:52] <MaikKlein1> bjz_, seems like we get our external function pointer very soon :)
[23:09:01] <cmr> MaikKlein1: 6661?
[23:09:08] <MaikKlein1> cmr, y
[23:09:13] <cmr> exciting! who is working on it?
[23:09:33] <MaikKlein1> cmr, at leat nmatsakis found the windows error
[23:09:40] <cmr> "
[23:09:41] <cmr> ok, I found the windows problem, which was embarassingly simple: I wasn't calling CallWithConv but rather just Call.
[23:09:43] *** Joins: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com)
[23:09:43] <cmr> nmatsakis: <333
[23:09:49] <MaikKlein1> really <3333333333
[23:10:28] * cmr can't wait to start playing with gl-rs
[23:10:33] <MaikKlein1> m2
[23:11:41] <cmr> although I'm probably going to end up writing my thing in C or maybe C++ anyway, rust still isn't all there
[23:11:44] <strcat> acrichto_: are we actually at 3.3 now?
[23:11:56] <acrichto_> strcat: yes, 3.3 + some of our own commits
[23:11:58] *** Quits: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com) (Input/output error)
[23:12:05] <acrichto_> at least to the best of my knowledge we're on 3.3
[23:12:26] *** Joins: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com)
[23:12:28] <MaikKlein1> cmr, what are you trying to create?
[23:12:38] <strcat> they don't actually do stable releases with backported fixes so it might not make sense to track the stables, I don't know
[23:13:18] <cmr> I think tracking svn until we can actually use a system llvm is best
[23:13:31] *** Joins: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net)
[23:14:01] <acrichto_> I was rebasing off chaupni/llvm
[23:14:20] <acrichto_> currently it's rebased on chaupni/llvm/release_33
[23:14:43] <MaikKlein1> llvm is just a toolkit to write a compiler, right?
[23:14:54] <cmr> MaikKlein1: It's a large project
[23:15:19] <erickt> strcat: hey there. chatting here is probably more efficient than through https://github.com/mozilla/rust/issues/7887#issuecomment-21464323
[23:15:30] <graydon1> any emacs users want to test a new rust mode?
[23:16:47] <dreamer__> ok, so it was my fault; I had installed 0.6 back in April to /usr/local and forgot about it (thanks, cmr)
[23:16:47] <mark_edward> cmr: there's opengl rust?
[23:17:11] <MaikKlein1> mark_edward, yes but only a temporary solution
[23:17:13] <cmr> mark_edward: there are working opengles bindings right now, and https://github.com/bjz/gl-rs which is waiting for #6661 to be resolved
[23:17:25] <dreamer__> but now I have different problem - in 0.6 this code compiled, but now fails with error, that I don't really understand:
[23:17:27] <MaikKlein1> mark_edward, yeah ^
[23:17:29] <mark_edward> what is #6661
[23:17:34] <dreamer__> fn quicksort<T:Eq+Ord+Copy>(xs: &[T]) -> ~[T] {
[23:17:35] <dreamer__>     match xs {
[23:17:35] <dreamer__>         []  => return ~[],
[23:17:35] <dreamer__>         [x] => return ~[x],
[23:17:35] <dreamer__>         _   => {
[23:17:35] <cmr> https://github.com/mozilla/rust/pull/6661
[23:17:35] <dreamer__>             let (left, equals, right) = partition(xs, xs[0]);
[23:17:39] <dreamer__>             return quicksort(left) + equals + quicksort(right)
[23:17:41] <dreamer__>         }
[23:17:43] <dreamer__>     }
[23:17:45] <dreamer__> }
[23:17:48] <dreamer__> main.rs:44:8: 44:11 error: cannot move out of dereference of & pointer
[23:17:49] <dreamer__> main.rs:44         [x] => return ~[x],
[23:18:18] <cmr> dreamer__: right, since you're matching on a &[], you need to use [ref x], I think
[23:18:36] <erickt> strcat: If I understand your argument, if we stick to an internal iterator for tree.map() it'll only be O(n) instead of O(n log n) to build up a new tree. Is that right? If so, I don't think we can rely on that because the .map() closure could change the keys, which could change the ordering of the tree
[23:18:39] <graydon1> tjc: ping
[23:18:46] <tjc> graydon1: pong
[23:18:58] <graydon1> tjc: feel like giving a new rust-mode a spin in emacs?
[23:19:01] <tjc> graydon1: sure
[23:19:03] <MaikKlein1> dreamer__, try *xs
[23:19:10] <graydon1> tjc: https://gist.github.com/graydon/040f7ca7be61c5aca6e8
[23:19:16] <MaikKlein1> dreamer__, in match
[23:19:17] <strcat> erickt: that's true, I was only thing about mutating the values (although not with an internal one)
[23:19:30] *** Quits: bent (chatzilla@moz-2CD73AA6.triad.res.rr.com) (Ping timeout)
[23:20:06] <graydon1> I chatted with marijn about the existing mode and, while I figured out what was wrong with its font locking (it was fighting with font-lock-mode for control of the faces) he also suggested just rewriting it like a more normal mode. so I did.
[23:20:28] <graydon1> (i.e. not using a stateful emulator for codemirror incremental parsing, but trying to get emacs to do most of the lifting)
[23:20:30] <dreamer__> I cannot use *xs in match - unexpected token
[23:20:34] <tjc> graydon1: ooh, looks good
[23:20:40] <dreamer__> and cannot return xs, since I return owned pointer
[23:20:59] <graydon1> result is about 60% the size and much simpler
[23:21:00] <MaikKlein1> dreamer__,  match *xs {
[23:21:12] <tjc> graydon1: it renders &'self foo things correctly, that's the maint hing I'm looking at
[23:21:15] <dreamer__> ah, ok
[23:21:20] <graydon1> tjc: yeah
[23:21:43] <dreamer__> main.rs:42:10: 42:13 error: type &[T] cannot be dereferenced
[23:21:43] <graydon1> tjc: er, well, not _quite_
[23:21:43] <dreamer__> main.rs:42     match *xs {
[23:21:48] <graydon1> it doesn't render 'a as an ident
[23:21:50] <dreamer__> do I need to add another trait?
[23:21:50] <tjc> graydon1: better, anyway!
[23:21:53] *** Quits: jdm (jdm@CAB30FBD.8F96AEA7.2D179A7D.IP) (Ping timeout)
[23:21:55] <graydon1> but yeah, less miserable
[23:21:55] <graydon1> ok
[23:22:02] <graydon1> I will queue it up for landing and work on 'a and such
[23:22:12] *** Joins: LU324 (stuff@moz-A17E9A7B.dyn.embarqhsd.net)
[23:22:45] <MaikKlein1> rusti: let a = &[1,2,3]; *a
[23:22:49] -rusti- <anon>:7:27: 7:29 error: type &[<VI2>] cannot be dereferenced
[23:22:49] -rusti- <anon>:7          let a = &[1,2,3]; *a
[23:22:49] -rusti-                                     ^~
[23:22:49] -rusti- error: aborting due to previous error
[23:22:49] -rusti- application terminated with error code 101
[23:22:57] *** Joins: sprocket (Mibbit@moz-F85B6108.student.rit.edu)
[23:23:28] <MaikKlein1> we can't deference &[]?
[23:23:35] <cmr> MaikKlein1: no, it's an unsized type.
[23:23:44] <cmr> [T] doesn't exist
[23:23:58] <Thiez> rusti: let a = &([1,2,3]); *a // let's cheat a little
[23:23:59] -rusti- [1, 2, 3]
[23:24:08] <MaikKlein1> dreamer__, you probably want to use ~[T]
[23:24:19] <cmr> dreamer__: what you want is, in the match arm, [ref x] => ~[x.clone()]
[23:24:20] <dreamer__> as input vector?
[23:24:22] <cmr> essentially
[23:24:39] *** Joins: Jesin (Jessin_@moz-1B1307FF.eecs.lehigh.edu)
[23:24:53] <cmr> and replace the 'Copy' bound with 'Clone'
[23:24:57] <Thiez> MaikKlein1: you can't deref ~[T] either
[23:25:01] <dreamer__> cmr, weird; in 0.6 it looked so much cleaner :/ I'll try with such arm
[23:25:19] <cmr> dreamer__: in 0.6 it was incorrect.
[23:25:43] <strcat> and there aren't implicit copies of generic parameters anymore
[23:25:53] <strcat> although it's probably pretty unlikely you want copies in a sort
[23:26:00] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[23:27:02] <MaikKlein1> rusti: let a = &~[1,2,3]; *a
[23:27:03] -rusti- <anon>:7:28: 7:30 error: cannot move out of dereference of & pointer
[23:27:04] -rusti- <anon>:7          let a = &~[1,2,3]; *a
[23:27:04] -rusti-                                      ^~
[23:27:04] -rusti- error: aborting due to previous error
[23:27:04] -rusti- application terminated with error code 101
[23:27:16] <MaikKlein1> ah ok that makes sense
[23:27:41] <cmr> You don't own the value the reference references, you can't move it.
[23:29:22] <dreamer__> ok, it works, but I need to rewrite partition function since I need both Copy+Clone atm :/
[23:29:23] <cmr> Here's something that'd be cool: a URL or some other reference in error messages explaining why the error happens
[23:29:37] <dreamer__> what is difference between Clone and Copy?
[23:30:01] <MaikKlein1> copy is deprecated
[23:30:08] <dreamer__> ah :)
[23:30:15] <MaikKlein1> and clone is shallow copy
[23:30:20] <cmr> dreamer__: Copy is the old kind automatically inserted by the compiler for the `copy` keyword, Clone is newer and user-overridable, because it's a normal trait.
[23:30:53] <strcat> Copy is removed in master now
[23:30:54] <cmr> Copy has been removed entirely in 0.8
[23:31:20] *** Quits: tchoma (tchoma@moz-E58E29CC.dsl.static.sonic.net) (Quit: My MacBook has gone to sleep. ZZZzzz‚Ä¶)
[23:32:15] *** Joins: tchoma (tchoma@moz-E58E29CC.dsl.static.sonic.net)
[23:32:20] <dreamer__> ok, so I replaced Copy with Clone and now clojures in partition function stopped compiling (when I put Clone+Copy they still work)
[23:32:29] <dreamer__> fn partition<T:Eq+Ord+Clone>(xs: &[T], pivot: T) -> (~[T], ~[T], ~[T]) {
[23:32:29] <dreamer__>     return (xs.filtered(|&x| x <  pivot),
[23:32:29] <dreamer__>             xs.filtered(|&x| x == pivot),
[23:32:29] <dreamer__>             xs.filtered(|&x| x >  pivot))
[23:32:29] <dreamer__> }
[23:33:17] <strcat> filtered was removed since 0.7 too
[23:33:34] <dbaupp> before 0.7, IIRC.
[23:34:05] <dreamer__> hmm, in 0.7 still works if I put Copy+Clone, so it's deprecated, I guess
[23:34:20] <dreamer__> and is still used in std, since I found it in code and not in documentation ;)
[23:34:24] *** Joins: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net)
[23:34:51] <dreamer__> ok, I'll play with rewriting this - thanks everyone :)
[23:35:26] *** Quits: Uther (Instantbir@moz-1B244B05.hfc.dyn.abo.bbox.fr) (Ping timeout)
[23:35:43] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Quit: Leaving.)
[23:36:12] <tjc> graydon1: hmm, the new rust mode seems to highlight some words in doc comments randonly
[23:36:14] <dreamer__> and back to my question about rand - documentation is generated from code, so if I fix example, then github pull request should be enough?
[23:36:22] <graydon1> tjc: which words?
[23:36:24] <tjc> graydon1: oh, it highlights capitalized words, heh
[23:36:33] <tjc> I guess it thinks they are types
[23:36:40] <graydon1> which doc comments?
[23:37:03] <MaikKlein1> rusti: std::time::Timespec::new(1234567890, 54321)
[23:37:07] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/MTRM
[23:37:09] <dreamer__> format! in first example from std::rand
[23:37:10] <mark_edward> cmr: does rust have a sorting algorithm? i think we should have a module somewhat similar to the C++11 <algorithm> header using our iterators maybe
[23:37:11] *** kimundi is now known as zz_kimundi
[23:37:15] <cmr> dreamer__: the rand doc has already been fixed
[23:37:22] <graydon1> tjc: point to an example? I'd like to debug
[23:37:23] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[23:37:25] <cmr> mark_edward: extra::sort, but they are not very good
[23:37:46] <tjc> graydon1: for example, in syntax::parse::Parser, look at the definition of `pub struct Parser`
[23:37:47] <dreamer__> eh, then I will need to find and fix something else then :)
[23:37:51] <MaikKlein1> rusti: std::time::Timespec::new(1234567890, 54321)
[23:37:52] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/ILDh
[23:38:01] *** Joins: deepdog (deepdog@moz-BE31AF27.hr.hr.cox.net)
[23:38:02] <MaikKlein1> rusti: extra::time::Timespec::new(1234567890, 54321)
[23:38:03] -rusti- {sec: 1234567890, nsec: 54321}
[23:38:09] <engla> mark_edward: random access iterators merged today, so strcat said it's possible from now on in that style
[23:38:17] <strcat> engla: not yet though
[23:38:18] *** Quits: deepdog (deepdog@moz-BE31AF27.hr.hr.cox.net) (Quit: Leaving)
[23:38:18] <engla> mark_edward: well, need the mutation counterparts too
[23:38:23] <graydon1> tjc: my workspace has no docs on that
[23:38:24] <strcat> they aren't mutable random-access iterators with swap
[23:38:33] <strcat> well
[23:38:38] <strcat> you could grab &mut and swap yourself
[23:38:48] * strcat doesn't think it would work
[23:38:54] <strcat> loans would conflict
[23:38:57] <strcat> need swap(idx, idx)
[23:38:57] <engla> you'd swap with a temporary
[23:39:08] <engla> yeah an efficient swap needs a trait
[23:39:21] <tjc> graydon1: the docs for the obsolete_set and mod_path_stack fields
[23:39:46] <strcat> engla: yeah same reason you can't write a generic in-place reverse on double-ended iterators
[23:39:52] <graydon1> tjc: not highlighting those here
[23:39:59] <graydon1> tjc: possibly exit-and-reload emacs?
[23:40:13] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Quit: WeeChat 0.4.1)
[23:40:50] *** Quits: pcwalton (pcwalton@33605CA4.9F929CFD.F9E1BAE1.IP) (Ping timeout)
[23:41:24] <tjc> graydon1: yeah, exiting and reloading fixed it
[23:41:48] <graydon1> ok
[23:43:09] <strcat> the universal solution
[23:43:53] *** Quits: pyrac (pyrac@moz-873BFA0.w90-5.abo.wanadoo.fr) (Quit: pyrac)
[23:45:02] <cmr> acrichto_: all check-stage1 tests seem to pass except the `rust` ones (rust the tool), it can't find the rustdoc crate
[23:45:22] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[23:46:40] <cmr> Do we even have FFI tests?
[23:46:54] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[23:49:38] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[23:49:38] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14599013c to 14330378d: 02http://git.io/N3iJvQ
[23:49:38] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[23:50:17] *** Joins: eatkinson (eatkinson@moz-AD233F1B.dia.static.qwest.net)
[23:50:20] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[23:50:26] <dbaupp> bstrie: fwiw, I worked out a few of the problems with the Rust code in the shower this morning
[23:50:58] <strcat> dbaupp: the haskell impl of that silly benchmark is now fastest ;p, it's an RNG benchmark
[23:51:00] *** Quits: eatkinson (eatkinson@moz-AD233F1B.dia.static.qwest.net) (Quit: eatkinson)
[23:51:00] <strcat> just make it return 4
[23:51:04] <cmr> heh
[23:51:07] <dbaupp> bstrie: our uint's are double the size of everyone elses, so XorShift is doing double the amount of work, the caches are getting filled, etc etc.
[23:51:25] <cmr> it's really not a very useful benchmark
[23:51:29] <dbaupp> strcat: seriously? I saw C .1s faster than every one else.
[23:51:37] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[23:51:59] * dbaupp is revisiting because we didn't know why ldc and rustc were so different, even when using the same RNG
[23:52:01] <strcat> dbaupp: http://togototo.wordpress.com/2013/07/23/benchmarking-level-generation-go-rust-haskell-and-d/
[23:52:03] <strcat> ghc
[23:52:16] <cmr> Now compare implementations of a given RNG and it'd be better
[23:52:18] <strcat> oh
[23:52:21] <strcat> it changed again
[23:52:27] <strcat> nvm ;p
[23:52:41] <dbaupp> cmr: yeah, they're all using XorShift now
[23:52:45] <cmr> ahh
[23:52:49] <strcat> the fact that they all got 3x faster shows how useless it is though
[23:53:02] <dbaupp> (well, except for  Haskell.)
[23:53:13] <MaikKlein1> what is ghc?
[23:53:17] <MaikKlein1> haskell?
[23:53:20] <cmr> MaikKlein1: glasglow haskell compiler
[23:53:28] <MaikKlein1> cmr, thanks
[23:53:30] <cmr> *glasgow
[23:53:32] <cmr> but yes
[23:53:42] <strcat> 'D was the fastest non-C language tested by far. The designers of the LDC compiler deserve serious congratulations on their work! I will be excited to run these benchmarks again in a year‚Äôs time and see how Clang, LLVM D and LLVM Rust compare then.'
[23:53:50] <strcat> as if the compilers have anything to do with it ;p
[23:53:56] <dbaupp> in any case, the problems with uints being so big means that we've been leap-frogged by go.
[23:54:29] <engla> strcat: it seems mostly to be a nice day of language communities doing something together
[23:54:46] <MaikKlein1> "D was the fastest non-C language tested by far." but rust is a non c language too, or am I wrong?
[23:54:58] <cmr> MaikKlein1: rust was slower than LDC
[23:55:11] <dbaupp> cmr: the glasglow haskell compiler is much better: imparts a nice shine to the compiled program. :P
[23:55:12] <strcat> dbaupp: use u32 then, and explain why
[23:55:13] <cmr> probably best to ignore the content of the post, it seems to be very out of date
[23:55:16] <MaikKlein1> cmr, oh I only knew DMD
[23:56:06] <dbaupp> strcat: but then I have to actually write some code again :'(
[23:56:13] <strcat> or just use sed
[23:57:12] *** Quits: ozten (ozten@moz-DD3B00B4.hsd1.wa.comcast.net) (Quit: ozten)
[23:57:21] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[23:57:27] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Connection reset by peer)
[23:58:22] *** Quits: mye (mye@moz-6C96FE1E.dip0.t-ipconnect.de) (Ping timeout)
[23:58:54] *** Joins: eagen (eagen@moz-92A457CB.hsd1.mn.comcast.net)
[23:59:45] <dbaupp> ok, that gives me ~15% speedup.

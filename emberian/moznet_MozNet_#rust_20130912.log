[00:00:20] *** kimundi is now known as zz_kimundi
[00:00:28] *** zz_kimundi is now known as kimundi
[00:01:18] *** Joins: fyolnish_ (fyolnish@moz-75A43B1A.uqwimax.jp)
[00:01:33] *** Quits: fyolnish (fyolnish@moz-75A43B1A.uqwimax.jp) (Ping timeout)
[00:01:57] *** Quits: Larry (larryfox@26EE99DC.88C61CC9.ECED8BE3.IP) (Quit: Textual IRC Client: www.textualapp.com)
[00:03:47] *** Joins: snadon (chatzilla@1323AFDF.98A48E9F.47C41102.IP)
[00:04:06] *** Quits: nkoep (nik@moz-2C4BD527.pool.mediaways.net) (Client exited)
[00:06:04] *** Quits: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net) (Quit: ChatZilla 0.9.90.1 [Firefox 23.0.1/20130814063812])
[00:07:54] *** Quits: snadon (chatzilla@1323AFDF.98A48E9F.47C41102.IP) (Quit: ChatZilla 0.9.90.1 [Firefox 24.0/20130909203154])
[00:08:16] *** Quits: etw (john@moz-D871A25B.nyc.res.rr.com) (Quit: etw)
[00:11:41] *** Quits: tikue_ (tkuehn@FE643D5D.E2CAEE6E.689607DE.IP) (Quit: tikue_)
[00:11:56] <bjz_> pcwalton: hey I was just wondering about that awesome Foo::<T>::blah() pull? Still held up?
[00:12:05] *** Joins: Jesin (Jessin_@moz-679F0D97.cc.lehigh.edu)
[00:12:07] <pcwalton> it's merged
[00:12:26] <pcwalton> was part of something bigger
[00:12:29] <bjz_> orly!
[00:12:29] *** Joins: tikue_ (tkuehn@FE643D5D.E2CAEE6E.689607DE.IP)
[00:12:31] <bjz_> wow
[00:12:53] <bjz_> pcwalton: did you fix ApproxEq back?
[00:13:04] <pcwalton> I forget?
[00:13:12] <bjz_> oh ok
[00:13:16] <bjz_> I will look
[00:14:03] <bjz_> pcwalton: yeah you had to change it because ApproxEq::approx_epsilon::<T>() was impossible to call in the transition :P
[00:14:12] <pcwalton> oh, you still can't do that
[00:14:21] <pcwalton> needs Foo::<for T>::blah()
[00:14:23] *** Quits: emerson (Icedove@6F3CD6F5.77F4443F.66AE2FF3.IP) (Ping timeout)
[00:14:25] <pcwalton> which does not yet have consensus
[00:14:36] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[00:14:36] <benh> oh no :(
[00:14:47] <bjz_> pcwalton: Ohh
[00:15:27] <bjz_> pcwalton: ok np
[00:16:16] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[00:18:19] *** Joins: emerson (Icedove@6F3CD6F5.77F4443F.66AE2FF3.IP)
[00:18:23] *** Joins: samx (sami@moz-D9DA5773.dyn.optonline.net)
[00:22:37] *** Joins: buptor (Mibbit@F7E2F3F.17A0D1EC.B7830B68.IP)
[00:23:39] <buptor> Hi all, could anyone tell me if I can run a program in the background without calling glibc::fork() in Rust?
[00:26:46] *** Parts: ChrisOei (c@moz-2B20A8E8.partechvc.com) ()
[00:26:47] *** Quits: vodik (simon@moz-CBE4BB13.cable.teksavvy.com) (Ping timeout)
[00:28:14] <tikue_> buptor: in the background of the program or the shell?
[00:28:34] *** Quits: mihneadb (Mihnea@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: Leaving)
[00:28:37] *** Quits: RMF (RMF@moz-67EE71FF.dsl.telepac.pt) (Quit: Textual IRC Client: www.textualapp.com)
[00:31:55] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[00:35:07] <buptor> actually I'm writing a simple shell, I would like to launch a program in the background of the shell.
[00:35:22] *** Joins: vadimcn (chatzilla@A2267643.76F9E272.DA40C4B3.IP)
[00:35:44] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[00:35:55] <dbaupp> buptor: you can spawn a new task and run it in the foreground of that task (but in the background of the main task)
[00:35:59] *** Joins: jstevans (Instantbir@A3D0EAB3.D41652FF.DDE5D3F6.IP)
[00:36:50] <dbaupp> buptor: you'll need to use std::task::spawn_sched(SingleThreaded) because std::run currently blocks the OS-level thread (not just the task), so it'll interfere with everything on the scheduler you're spawning on; hence, spawn a whole new scheduler
[00:37:39] *** Quits: emerson (Icedove@6F3CD6F5.77F4443F.66AE2FF3.IP) (Ping timeout)
[00:37:39] *** Quits: jstevans (Instantbir@A3D0EAB3.D41652FF.DDE5D3F6.IP) (Ping timeout)
[00:39:09] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[00:39:12] <buptor> oh, that makes sense. thank you. I've just tried, and it worked for me. Great!
[00:40:05] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[00:40:32] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[00:40:57] *** Joins: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP)
[00:42:12] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[00:44:13] *** Joins: mrordinaire (Mibbit@1A659656.A607747.FD383126.IP)
[00:45:23] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[00:46:10] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[00:47:13] *** jorendorff is now known as jorendorff_away
[00:47:49] *** Quits: mrordinaire (Mibbit@1A659656.A607747.FD383126.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[00:50:44] *** Quits: heftig (heftig@moz-C3CA52B7.dip0.t-ipconnect.de) (Ping timeout)
[00:52:24] <nmatsakis> cmr: pong
[00:52:45] *** Quits: fyolnish_ (fyolnish@moz-75A43B1A.uqwimax.jp) (Ping timeout)
[00:53:14] *** Joins: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP)
[00:53:52] *** Joins: fyolnish (fyolnish@moz-75A43B1A.uqwimax.jp)
[00:54:57] <benh> what does use mod; do again?
[00:55:16] *** Quits: lucian (lucian@moz-22A14C6A.cable.virginmedia.com) (Input/output error)
[00:55:33] *** Quits: cdidd (cdidd@moz-812EAB3.broadband.corbina.ru) (Input/output error)
[00:56:00] *** Joins: heftig (heftig@moz-843B77E4.dip0.t-ipconnect.de)
[00:57:15] <dbaupp> benh: as in `use <some_name>;`, not just `use mod;` with a literal mod?
[00:57:50] <benh> use some_mod; (but not use some_mod::some_name;)
[00:58:14] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[00:58:23] *** Quits: jdm (jdm@moz-7B0110AD.mv.mozilla.com) (Quit: Lost terminal)
[00:58:36] *** Quits: dherman (dherman@moz-BBE3ABD.mv.mozilla.com) (Quit: dherman)
[00:58:43] <dbaupp> it will allow you to write `some_mod::some_name()` in the body of the code, rather than `::some_mod::some_name()`
[00:58:54] <dbaupp> i.e. it brings `some_mod` into scope from the crate root
[00:59:00] *** Quits: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com) (Quit: pcwalton)
[00:59:12] <dbaupp> (as in, `some_mod` in the crate root is then in scope in the current mod)
[00:59:12] <benh> and in the crate root it's a no-op?
[00:59:19] <dbaupp> right
[00:59:47] <benh> i see. thanks :)
[00:59:51] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[00:59:56] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Quit: leaving)
[01:00:28] *** Quits: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net) (Client exited)
[01:00:51] *** Joins: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net)
[01:01:09] *** Joins: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[01:02:24] <bjz_> jack: ping
[01:02:31] *** Quits: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net) (Ping timeout)
[01:02:43] *** Quits: KindOne (KindOne@moz-4A7B61AE.dynamic.ip.windstream.net) (Ping timeout)
[01:02:56] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[01:03:17] *** Joins: lmandel (lmandel@moz-76CE9D51.cable.teksavvy.com)
[01:03:21] *** Quits: ozten (ozten@moz-DD3B00B4.hsd1.wa.comcast.net) (Quit: ozten)
[01:05:06] *** Quits: lbergstrom (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[01:06:13] *** Joins: KindOne (KindOne@moz-4A7B61AE.dynamic.ip.windstream.net)
[01:07:31] <cmr> nmatsakis: I updated bindgen given the node id renumbering; does https://github.com/cmr/rust-bindgen/commit/2d83e2302b14307c5250a2c4f99c3a3309abf19f look correct?
[01:11:25] *** Quits: fyolnish (fyolnish@moz-75A43B1A.uqwimax.jp) (Ping timeout)
[01:11:35] *** Quits: KindOne (KindOne@moz-4A7B61AE.dynamic.ip.windstream.net) (Ping timeout)
[01:12:31] <dbaupp> cmr: looks correct to me, assuming that's all of them
[01:13:41] <JesseH> Are there any irc channels for rust game dev?
[01:14:23] <cmr> JesseH: besides this one, no.
[01:14:30] <JesseH> Oh okay, just checking.
[01:14:53] <cmr> Do you think a gamedev specific channel would be useful?
[01:14:56] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[01:15:12] *** Joins: KindOne (KindOne@moz-4A7B61AE.dynamic.ip.windstream.net)
[01:15:59] <JesseH> Yes, for knowing who is into it, and who isnt. And for conversations more geared towards game development. I'm not saying that this isnt a fine channel for it, but having that organization with a central "hub" so to speak just seems logical.
[01:16:17] <nmatsakis> cmr: yes prob
[01:16:36] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[01:16:39] *** Joins: cdidd (cdidd@moz-6B57E0D9.broadband.corbina.ru)
[01:16:49] <cmr> nmatsakis: ok, didn't know if anything else was more involved.
[01:16:52] <nmatsakis> cmr: that is, it looks right, not sure if you ever need to run the number assigning pass,
[01:16:57] <nmatsakis> cmr: prob not if it just runs pretty printer
[01:17:17] <JesseH> But I'm sure channels will form around game dev related projects soon
[01:17:22] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[01:17:30] <cmr> JesseH: there's #q3 on irc.freenode.net for the q3 project.
[01:17:51] <bjz_> cmr: yes, I think so
[01:18:00] <JesseH> Thank you for the tip, cmr 
[01:18:01] <cmr> bjz_: you think so what?
[01:18:02] <dbaupp> cmr: from that diff; it looks like bindgen would benefit from using syntax::ext::build::AstBuilder... does it really hand-built the entire ast?
[01:18:08] <bjz_> cmr: maybe ##rust-gamedev?
[01:18:14] <cmr> Oh
[01:18:19] <cmr> Well this isn't freenode
[01:18:26] <cmr> #rust-gamedev now exists.
[01:18:29] <bjz_> cmr: I know
[01:18:32] <dbaupp> https://github.com/mozilla/rust/issues/8668
[01:18:34] <bjz_> cmr: orly?
[01:18:36] <JesseH> Having the channel on mozilla network makes more sense :P
[01:18:43] <bjz_> yeah
[01:18:45] <bjz_> maybe
[01:18:53] <bjz_> that would be cool
[01:19:04] <JesseH> #rust-gamedev
[01:19:10] *** Parts: benh (ben@moz-4A0366D2.org) ()
[01:19:16] *** Joins: benh (ben@moz-4A0366D2.org)
[01:19:40] <benh> heh, our #[attr("blah")]; syntax makes for valid channel names
[01:19:43] * cmr watches the entirety of the active members of #rust trickle in.
[01:20:00] *** Quits: riley (riley@8BA43816.9AA11D69.65DDFA89.IP) (Client exited)
[01:20:59] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[01:20:59] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/bmuCbA
[01:20:59] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[01:25:20] *** Quits: cstrahan (cstrahan@DB1CB554.80B5DDE4.2D737EA7.IP) (Ping timeout)
[01:25:59] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[01:25:59] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/6Qj9Xg
[01:25:59] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[01:26:00] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[01:26:00] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/-qMMUQ
[01:26:00] <ghrust> 13rust/06auto 1420f1584 15Tim Kuehn: Rendezvous stream for synchronous channel messaging
[01:26:00] <ghrust> 13rust/06auto 147efc2cc 15Tim Kuehn: replace all references to sync_stream with rendezvous
[01:26:00] <ghrust> 13rust/06auto 1410d7d73 15bors: auto merge of #8908 : tikue/rust/master, r=anasazi...
[01:26:02] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[01:26:28] *** Joins: tjc (tjc@moz-41215903.tmodns.net)
[01:26:28] *** ChanServ sets mode: +o tjc
[01:27:02] *** Quits: igl1 (igl@moz-1CD79C0B.adsl.alicedsl.de) (Connection reset by peer)
[01:28:09] *** Quits: azakai (alon@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[01:30:37] *** Joins: deio (chris@moz-B7BAB130.dynamic.tstt.net.tt)
[01:31:08] *** Joins: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[01:31:54] <h3r3tic> hey, is there any way to make this work? https://gist.github.com/h3r2tic/6532150  it's okay if the array is @[int], but with ~[int], rustc complains :S
[01:32:56] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[01:33:12] <engla> write  A { ref x  } =>
[01:33:42] <h3r3tic> found `ref` in ident position
[01:33:55] <engla> oh right. A { x: ref x } => 
[01:34:06] <engla> the naked x is a shorthand for x: x
[01:34:08] <h3r3tic> :o
[01:34:12] <h3r3tic> what is this voodoo!
[01:34:16] <h3r3tic> but hey, it works :D
[01:34:21] <tikue_> engla: why doesn't the shorthand work
[01:34:26] <h3r3tic> thanks :)
[01:34:56] <tikue_> h3r3tic: any time you bind to a variable in a pattern, you can do it by reference with `ref foo` :)
[01:34:56] <engla> tikue_: I guess it's not implemented / can't fit easily into the grammar?
[01:35:16] <tikue_> engla: ah
[01:35:39] <h3r3tic> mmm, that sounds reasonable :) the grammar looks a bit weird, though
[01:35:46] <tikue_> h3r3tic: by "by reference" i mean that you bind to a borrowed pointer. you can also bind to an &mut pointer with `ref mut foo`
[01:36:09] <tikue_> h3r3tic: how would you write it :P
[01:36:18] <dbaupp> https://github.com/mozilla/rust/issues/6137
[01:36:25] <dbaupp> (btw)
[01:36:54] <tikue_> dbaupp++
[01:37:36] <tikue_> h3r3tic: you can also do `match f.x { ref x => x.len() }`
[01:37:42] <h3r3tic> tikue_: whta's weird is that the name of the field has to be there twice. it would be fine in my head if you could rename it via that syntax, e.g. say { new_name : ref x }
[01:37:48] *** Joins: adu (alt@moz-BF2B1AE4.washdc.fios.verizon.net)
[01:38:00] <SiegeLord> I think it's x: ref new_name
[01:38:01] <tikue_> h3r3tic: it doesn't have to be there twice you can name it w.e you want
[01:38:02] <h3r3tic> oh, that's quite neat
[01:38:23] <tikue_> :O)
[01:38:27] <h3r3tic> ahhh nevermind, my bad
[01:38:45] <h3r3tic> I tried renaming it, and the compiler errored out. didn't read the error, which was in the usage of the renamed field, of course :)
[01:38:50] <h3r3tic> works as SiegeLord said
[01:38:53] <h3r3tic> great, thanks guys :D
[01:40:16] *** Joins: emerson (Icedove@6F3CD6F5.77F4443F.66AE2FF3.IP)
[01:40:23] *** Quits: adu (alt@moz-BF2B1AE4.washdc.fios.verizon.net) (Quit: adu)
[01:40:24] <tikue_> no prob!
[01:40:30] <engla> h3r3tic: no ordering is enforced, so a name is needed because the grammar is  name: pattern
[01:40:44] *** Joins: adu (alt@moz-BF2B1AE4.washdc.fios.verizon.net)
[01:41:09] <h3r3tic> oh, the grammar makes perfect sense with the renaming :)
[01:41:41] <engla> and destructuring etc
[01:41:56] <h3r3tic> mm yus
[01:42:16] *** Quits: maxli (maxli@moz-A607CA26.student.cs.uwaterloo.ca) (Quit: Leaving.)
[01:42:16] <h3r3tic> btw, I'd like to have an array where each item can be one of several types. is an enum for the item type generally the way to do it? I tried using a trait pointer as the contained type, and then inserting struct instances implementing that trait. the compiler wasn't very happy about the last one, complaining that the instance may contain borrowed pointers
[01:42:34] *** Joins: maxli (maxli@moz-A607CA26.student.cs.uwaterloo.ca)
[01:42:51] <h3r3tic> ( it's not quite like using a variant/any type, since I know beforehand which types I might want to store in the array )
[01:44:04] <engla> use an enum
[01:44:14] <SiegeLord> I think the usual suggestion is to use an enum when you know all the types beforehand
[01:44:21] <h3r3tic> cool
[01:44:57] <h3r3tic> thanks :)
[01:45:08] *** Quits: bytewise (bytewise@moz-4A801D04.unitymediagroup.de) (Quit: Leaving)
[01:45:13] *** Joins: ChrisMorgan (chris@moz-3ECEFC27.its.monash.edu.au)
[01:45:15] *** Quits: dsirenko (mitra@8E712A0.54C21BA0.9F317420.IP) (Ping timeout)
[01:45:36] *** Quits: Siyo (Siyo@A89938F4.87DAA49F.F113998C.IP) (Ping timeout)
[01:46:47] <tikue_> SiegeLord: I would've thought the way to do it would be ~[~Trait]
[01:47:06] <tjc> jack: r? https://github.com/mozilla/rust/pull/9132
[01:47:45] <tikue_> or ~[@Trait] if it isn't T:Send
[01:48:42] <h3r3tic> tikue_: that's how I had it. given ~T, where T implements Trait, and having an instance 't' of it, I had to say 't as ~Trait'  when pushing into the vector. then the compiler would say that the item may contain borrowed pointers, and suggested using 'static
[01:49:13] <tikue_> h3r3tic: yeah you can't put anything with a borrowed pointer in a ~-box
[01:49:43] <engla> you can change the bounds on the ~Trait object
[01:49:45] <h3r3tic> yeah, but I wasn't even trying to do that :P
[01:49:46] *** Joins: Siyo (Siyo@A89938F4.87DAA49F.F113998C.IP)
[01:49:51] <tikue_> engla: good point
[01:49:57] <engla> but from experience, now you're into buggier territory :)
[01:49:57] <SiegeLord> tikue, strcat said that the overhead of a match is less than the overhead of a vtable
[01:50:07] <SiegeLord> It seems to make sense to me
[01:50:13] <tikue_> SiegeLord: i don't care! it's nicer looking :P
[01:50:17] <h3r3tic> xD
[01:50:22] <engla> enum is simpler
[01:50:32] <SiegeLord> I'd use &Trait anyway :P
[01:50:38] <engla> but I guess implement both and learn about it
[01:50:38] <tikue_> SiegeLord: how do you use those?
[01:50:48] *** Joins: vodik (simon@moz-CBE4BB13.cable.teksavvy.com)
[01:51:32] *** Quits: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com) (Quit: Jesse)
[01:51:34] <SiegeLord> Like all the usual trait objects, I imagine
[01:52:20] <h3r3tic> so you mentioned that one would "change bounds on the ~Trait object". is there any manual that I could RTFM on that? :D
[01:52:36] <tikue_> h3r3tic: this works for me https://gist.github.com/tikue/9c67c12a6364dc5f7b0c
[01:53:23] <tikue_> h3r3tic: and the answer is most likely a resounding "no." :P but I think you do it by saying for instance let foo: ~Foo() = ...
[01:53:56] <engla> h3r3tic: ~1 as ~Any:   vs ~1 as ~Any:Send    the latter is the default
[01:54:29] *** Quits: voxpopuli (fanservice@moz-FE161659.wv.cc.cmu.edu) (Ping timeout)
[01:54:46] <h3r3tic> :o
[01:58:35] *** Quits: adu (alt@moz-BF2B1AE4.washdc.fios.verizon.net) (Quit: adu)
[01:58:42] *** Parts: emerson (Icedove@6F3CD6F5.77F4443F.66AE2FF3.IP) ()
[02:01:13] *** Joins: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[02:01:25] <h3r3tic> drat, I've roughly retraced the steps I wanted to take with the trait, and now it isn't complaining about borrowed pointers
[02:01:44] <h3r3tic> I probably did something terribly wrong and now fixed it with the newly acquired knowledge :)
[02:01:48] <h3r3tic> anyway, thanks for help again :D
[02:03:06] <tikue_> does bors test commits individually? :\
[02:03:19] <tikue_> i added a commit to fix a previous commit, and I didn't rebase
[02:04:00] <dbaupp> tikue_: it tests the merge commits
[02:04:01] *** Quits: echristo (echristo@60A74940.D6CCE4AE.77834EAA.IP) (Ping timeout)
[02:04:39] *** Quits: tjc (tjc@moz-41215903.tmodns.net) (Quit: zzzzzzzzzz)
[02:04:43] <tikue_> dbaupp: oh good
[02:04:44] <tikue_> thanks
[02:04:50] *** Joins: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net)
[02:04:50] *** Quits: SiegeLord (sl@moz-1DF56822.twcny.res.rr.com) (Quit: Leaving)
[02:05:42] *** Joins: adu (alt@moz-BF2B1AE4.washdc.fios.verizon.net)
[02:05:45] <tikue_> wait maybe i misunderstand
[02:06:05] <tikue_> dbaupp: for example 2 commits were merged (creating a 3rd commit, the "merge"). do all 3 get tested or just the last?
[02:06:44] <dbaupp> tikue_: um; bors merges each PR with master into the auto branch, and just tests the head of that
[02:06:50] <tikue_> ah ok
[02:06:52] <tikue_> thank you
[02:07:05] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[02:08:24] *** Quits: dbaupp (Thunderbir@moz-EAA09AEF.lns20.syd7.internode.on.net) (Ping timeout)
[02:08:30] *** Quits: doomlord_ (servitor@moz-13E69BC8.range86-180.btcentralplus.com) (Ping timeout)
[02:08:34] *** Joins: doomlord_ (servitor@moz-DEFFB365.range81-147.btcentralplus.com)
[02:09:22] *** Quits: Earnestly (earnest@moz-BE290A2B.dyn.plus.net) (Ping timeout)
[02:09:23] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[02:10:51] *** Joins: mark_edward (quassel@moz-97E995A.hsd1.in.comcast.net)
[02:11:19] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[02:11:46] <tikue_> a bors test failed unrelated to the pr being tested.
[02:11:52] <tikue_> do you  just retry when that happens?
[02:12:39] *** Quits: adu (alt@moz-BF2B1AE4.washdc.fios.verizon.net) (Quit: adu)
[02:12:58] <tikue_> and what about "exceptions"
[02:12:59] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[02:14:04] *** Quits: mark_edward (quassel@moz-97E995A.hsd1.in.comcast.net) (Ping timeout)
[02:14:16] *** Joins: msingle (Thunderbir@moz-20675462.nrflva.fios.verizon.net)
[02:14:52] <engla> the reviewer will have to tag it with @retry
[02:15:17] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[02:15:33] <tikue_> engla: should there be a note of the test that failed? that doesn't seem like something that should be happening
[02:16:01] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[02:16:01] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1410d7d73 to 1491ab8a3: 02http://git.io/N3iJvQ
[02:16:01] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[02:16:02] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[02:16:02] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/WCz9-Q
[02:16:02] <ghrust> 13rust/06auto 147173b9d 15Jakub: Fix pretty-printing of empty impl items
[02:16:02] <ghrust> 13rust/06auto 14de79972 15Jakub: Fix the empty-impl tests...
[02:16:02] <ghrust> 13rust/06auto 146216661 15bors: auto merge of #9061 : jakub-/rust/pretty-print-empty-impl, r=huonw
[02:16:03] <engla> don't know
[02:16:04] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[02:16:16] <engla> there are various issues depending on the platforms of the buildbots
[02:16:40] *** Quits: msingle (Thunderbir@moz-20675462.nrflva.fios.verizon.net) (Quit: msingle)
[02:16:57] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[02:17:09] *** Joins: mark_edward (quassel@moz-97E995A.hsd1.in.comcast.net)
[02:18:47] *** Joins: optimusbrine (optimusbri@moz-CF697891.tampfl.fios.verizon.net)
[02:19:21] <tikue_> engla: and do you know what happens on buildbots which end with "exception" (neither fail nor pass)? does that prevent merging as well?
[02:20:04] <engla> that's when they were stopped because another bot failed
[02:20:23] <engla> all the builds need to pass
[02:20:34] *** Joins: jgilbert (jgilbert@E3D90E00.12EE5EA8.C0D9FBB9.IP)
[02:20:49] <engla> that's 15 different configurations or so
[02:21:05] *** Quits: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net) (Quit: echristo)
[02:22:00] <tikue_> ah, ok, understood
[02:22:08] <klutzy> yay, github issues go status 500
[02:22:52] <cmr> fold.rs:3:4: 3:29 error: unresolved import: could not find `iterator` in `std`.
[02:22:53] <cmr> fold.rs:3 use std::iterator::Extendable;
[02:22:55] <cmr>               ^~~~~~~~~~~~~~~~~~~~~~~~~
[02:23:04] <engla> renamed to std::iter   
[02:23:18] <cmr> Well that's slightly annoying
[02:23:21] <cmr> I liked the longer name
[02:23:44] <engla> I didn't mind it
[02:23:46] <tikue_> when did that happen 
[02:23:51] <benh> All the names in std::iter are already really long compared to, like, your average rust identifier (or keyword!) a while ago
[02:24:15] <engla> we shortened the name of the adaptors
[02:24:24] <engla> for them it's only Map, Filter, Zip now
[02:24:27] <engla> etc
[02:24:29] <cmr> Maperator, Filterator, Ziperator
[02:24:41] <engla> use Maperator = std::iter::Map;
[02:24:43] <cmr> heh
[02:24:51] <benh> nice
[02:25:12] *** Quits: maxli (maxli@moz-A607CA26.student.cs.uwaterloo.ca) (Quit: Leaving.)
[02:25:16] <tikue_> benh: which names?
[02:25:28] <tikue_> ok, MutableDoubleEndedIterator stands out :P
[02:25:57] <engla> hehe but it's in the prelude so you don't really have to know about it at all
[02:26:00] <benh> BlahIterator in general
[02:26:22] <tikue_> benh: there aren't too many *Iterator structs anymore
[02:26:24] <engla> well the struct names with Iterator got cut down at least. so that part is fixed
[02:26:32] <engla> there are in other modules though
[02:27:04] *** Joins: adu (alt@moz-BF2B1AE4.washdc.fios.verizon.net)
[02:27:09] <tikue_> if/when we get a `yield` implementation presumably all those structs could go away?
[02:27:34] <engla> not all of them
[02:28:03] <tikue_> engla: which ones would need to stay?
[02:28:03] <engla> I don't know what yield will look like, but we have a lot of Double ended iterators
[02:28:29] <engla> Map, Filter, Zip, FilterMap, FlatMap are all double ended, Enumerate too
[02:28:34] <tikue_> ah true
[02:28:45] <engla> size_hint is important too
[02:28:59] <engla> (the method)
[02:29:07] <tikue_> ah
[02:29:23] <benh> Why is DoubleEndedIterator::invert not called reverse?
[02:29:42] <engla> I guess reverse isn't 100% the right name
[02:29:57] <engla> what invert does is that it relabels the front as the back and vice versa
[02:30:09] <tikue_> engla: why can Zip be double ended? wouldn't that require knowing the number of elements in each iterator?
[02:30:26] <engla> tikue_: it does, I added a crutch called ExactSize for this
[02:30:35] <tikue_> engla: oh! interesting
[02:30:43] <engla> it's mainly to support .enumerate() in reverse
[02:30:59] <tikue_> nice
[02:31:10] <engla> rusti isn't here to play with..
[02:31:15] <tikue_> i know :(
[02:31:21] *** Quits: kimundi (kimundi@moz-4EC963E4.dip0.t-ipconnect.de) (Ping timeout)
[02:31:22] <cmr> engla: is zip only double ended over an iterator which implements ExactSize
[02:31:23] <cmr> ?
[02:31:28] <tikue_> rust playpen is down too
[02:32:22] * tikue_ thinks std::vec's methods should return iterators
[02:32:34] <tikue_> i'm looking at you, vec.map
[02:32:47] <engla> cmr: hm I don't know if it implements it itself.. it uses it at least
[02:32:58] *** Joins: sruggier (sruggier@moz-F1ED47A9.cpe.teksavvy.com)
[02:33:05] <engla> cmr: there is a gang of them that implements ExactSize if their wrapped iterator(s) implement it
[02:33:07] <sfackler> how do I make a ~ closure? ~|foo| {stuff} doesn't seem to do it
[02:33:43] <engla> yeah Zip implements ExactSize
[02:34:15] <engla> if, both T,U in Zip<T, U>  do
[02:34:39] <engla> sfackler: it will coerce
[02:34:43] <Luqman> sfackler: let x: ~fn(int) -> int = |x| x+1;
[02:34:47] *** Joins: kimundi (kimundi@moz-49A81A98.dip0.t-ipconnect.de)
[02:34:50] <mark_edward> is it true that because of the lifetime system's no tree-like structure can have parent pointers?
[02:35:05] <Luqman> er, maybe i shouldn't have used x twice
[02:35:08] <sruggier> they can with @managed boxes
[02:35:11] <cmr> mark_edward: not borrowed pointers to the parent, no.
[02:35:21] <cmr> & and ~ can't form cycles.
[02:35:23] <mark_edward> cmr: can you explain why?
[02:35:36] <benh> It already breaks down for doubly linked lists
[02:35:49] *** Joins: zeuxcg (zeuxcg@moz-80D1F912.hsd1.ca.comcast.net)
[02:36:11] <sfackler> Luqman: maybe it's a type inference issue. I have a Cell<~fn:(Foo)> field in a struct, but if I try to set the field to Cell::new(|foo| {stuff}) it complains that it expected ~ closure, found & closure
[02:36:24] <cmr> sfackler: there's an open bug for that.
[02:36:35] <cmr> mark_edward: the problem with ~ is obvious, ownership can never have cycles.
[02:36:40] <cmr> mark_edward: I don't know about & though
[02:36:41] <sfackler> ah
[02:36:53] <mark_edward> cmr: & is what i meant
[02:37:14] <sruggier> by definition, an owned pointer can only have a single reference, and can only be lent out once
[02:37:24] <cmr> sruggier: you can have multiple borrows.
[02:37:37] <sruggier> oh, if they're not mutable?
[02:37:39] <cmr> yes
[02:37:41] <engla> mark_edward: a value can't own a borrowed reference to itself. A parent owns the child, so the child can't own a borrow to the parent
[02:38:05] <mark_edward> i see
[02:38:09] <bjz_> how does one build the tests via rustpkg atm?
[02:38:14] <hoverbear> Nooooâ€¦ Finally build rust from homebrew and the build is borked (Known issue: https://github.com/mozilla/rust/issues/7617) need to recompile. :(
[02:38:27] <sfackler> woah, an old bug too
[02:38:35] <mark_edward> so how are you supposed t implement double-linked list and such in safe Rust? it seems like something you should be able to do without GC
[02:38:57] <cmr> mark_edward: you need to use @ in safe rust.
[02:38:58] <hoverbear> sfackler: Yeah I was surprised.
[02:39:01] <sruggier> to be fair, the GC uses ref counting last I heard?
[02:39:04] <cmr> hoverbear: Why do you need to rebuild?
[02:39:07] <cmr> sruggier: atm yes
[02:39:11] *** kimundi is now known as zz_kimundi
[02:39:13] <cmr> hoverbear: just don't use the `rust` tool.
[02:39:28] <hoverbear> cmr: It's a bug with the compiler version used by brew.
[02:39:29] <sruggier> so it's not like you have a heap of 2-3 times the size of your mem usage, plus having to deal with the overhead of GCin
[02:39:30] <sruggier> g
[02:40:08] <cmr> ok
[02:41:04] <buptor> Sorry to bother you. But does anyone know ThreadPerTask scheduler mode in std::tasks? I would like to create tasks in corresponding threads, but Rust 0.7 told me: task failed at 'ThreadPerTask scheduling mode unimplemented',
[02:41:37] <Luqman> hoverbear: huh, that should be fixed
[02:41:53] <hoverbear> Luqman: It is if you tell brew to pull from head
[02:42:03] <Luqman> ah, right
[02:42:10] <hoverbear> I just felt bad enough subjecting my poor macbook to another rust compile
[02:42:25] <sruggier> buptor: it's gone, at least for now: https://mail.mozilla.org/pipermail/rust-dev/2013-August/005158.html
[02:42:33] <sruggier> I don't know how permanent the disruption is
[02:42:52] *** Joins: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net)
[02:43:36] <Luqman> also, i'm pretty sure that issue can be closed since i remember fixing the static slices thing
[02:44:03] <engla> found a "new" segfault. never fixed overflow for vectors with managed content. let mut v = ~[@1]; v.reserve(-1); v.push(@2);
[02:44:05] <buptor> really? but how can I implement dbaupp's suggestion? He said: buptor: you'll need to use std::task::spawn_sched(SingleThreaded) because std::run currently blocks the OS-level thread (not just the task), so it'll interfere with everything on the scheduler you're spawning on; hence, spawn a whole new scheduler
[02:44:50] <sruggier> according to that post, SingleThreaded is still in
[02:45:03] <sruggier> but ThreadPerTask is gone
[02:45:47] *** Joins: cstrahan (cstrahan@moz-71FAC30.hsd1.va.comcast.net)
[02:46:47] *** zz_kimundi is now known as kimundi
[02:47:13] <tikue_> you can update git repos with homebrew? 
[02:47:24] <tikue_> clearly i'm not doing it right
[02:47:52] <buptor> sruggier: Oh, sorry. But I think I have to use ThreadPerTask rather than ThreadPerTask, because I would like to run multiple background programs at the same time, while std::run() blocks the OS-level thread.
[02:48:36] <sruggier> I don't know enough off-hand to help you with that
[02:48:42] <sruggier> (new here :) )
[02:49:07] *** Joins: SingingBoyo (brandon@DAC9C672.CE76D40F.4F048BDC.IP)
[02:49:14] <sruggier> question: for a hypothetical object that needs to clean up after itself, an object in C++ might store a reference in a pointer, and then nullify the pointer if the caller decides to clean up early. What's the idiomatic equivalent of that kind of usage pattern in safe Rust? The Cell type? 
[02:49:29] <buptor> sruggier: thank you all the same :0
[02:50:04] <engla> sruggier: store an Option<T> for the resource T?
[02:50:17] <engla> then you can clear it early
[02:51:16] <sruggier> where T is a borrowed pointer?
[02:51:23] <buptor> dbaupp: Hi dbaupp, I would like to use std::task::spawn() to run multiple programs in the background at the same time, so I shouldn't use SingleThreaded scheduler, right?
[02:51:48] <sruggier> picture a use case similar to an iterator, except that the object needs to always ensure that something is done before it goes out of scope
[02:52:26] <engla> it sounds like the caller should just drop the object when it wants the cleanup
[02:53:46] <sruggier> yeah, that would work, but I want to see how readable it is in practice, and I'd like to give the caller the option of doing it early, for the sake of comparison
[02:54:09] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[02:55:26] *** Joins: maxli (maxli@moz-A607CA26.student.cs.uwaterloo.ca)
[02:56:41] *** Quits: maxli (maxli@moz-A607CA26.student.cs.uwaterloo.ca) (Quit: Leaving.)
[02:56:57] *** Joins: maxli (maxli@moz-A607CA26.student.cs.uwaterloo.ca)
[02:58:58] <sruggier> so I guess an Option containing a borrowed pointer would be what I want
[02:59:47] <sruggier> I hope it doesn't seem like a silly question, I just needed a bit of reminding/confirmation
[02:59:54] <engla> maybe someone else has input on that? I'm not sure
[03:00:19] *** Quits: samx (sami@moz-D9DA5773.dyn.optonline.net) (Quit: This computer has gone to sleep)
[03:00:59] <cmr> Has anyone seen an ICE like this?
[03:01:01] <cmr> task <unnamed> failed at 'not allowed to compare these idents: &ast::Ident{name: 748u, ctxt: 506u}, &ast::Ident{name: 748u, ctxt: 525u}', /build/rust-git/src/rust/src/libsyntax/ast.rs:50
[03:01:09] *** Quits: deio (chris@moz-B7BAB130.dynamic.tstt.net.tt) (Quit: Ex-Chat)
[03:01:10] *** Quits: maxli (maxli@moz-A607CA26.student.cs.uwaterloo.ca) (Ping timeout)
[03:01:28] <sruggier>             // IF YOU SEE ONE OF THESE FAILS: it means that you're comparing
[03:01:28] <sruggier>             // idents that have different contexts. You can't fix this without
[03:01:28] <sruggier>             // knowing whether the comparison should be hygienic or non-hygienic.
[03:01:28] <sruggier>             // if it should be non-hygienic (most things are), just compare the
[03:01:29] <sruggier>             // 'name' fields of the idents. Or, even better, replace the idents
[03:01:29] <sruggier>             // with Name's.
[03:01:36] <cmr> Oh there's a 
[03:01:38] *** Joins: dr_bibble (Mibbit@moz-2A04434C.hsd1.ma.comcast.net)
[03:01:40] <cmr> yeah just got to that :p
[03:02:00] <sruggier> I was curious :)
[03:02:03] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[03:02:04] <engla> I've gotten sucked into std::at_vec, life is miserable :)
[03:02:13] *** Quits: dr_bibble (Mibbit@moz-2A04434C.hsd1.ma.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[03:03:14] <cmr> I have no idea where that error could be coming from.
[03:03:21] <cmr> Use of a macro?
[03:03:25] <cmr> Buggy rustc code?
[03:03:47] <sruggier> yeah, speaking of this, is there some way to print a stack trace in situations like this?
[03:03:55] <sruggier> speaking of ICEs*
[03:04:00] <cmr> sruggier: gdb is the only way
[03:04:24] <sruggier> but I was also told that rustc can't be run in gdb yet?
[03:05:03] <cmr> https://gist.github.com/cmr/c0e24227164018e60639
[03:05:05] <cmr> sruggier: it can be
[03:05:09] <cmr> you can't build it with debuginfo yet.
[03:05:19] <cmr> so, getting a callstack is about all you can do :P
[03:05:27] <sruggier> better than nothing
[03:05:56] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[03:06:02] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[03:06:13] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[03:06:30] *** Quits: Siyo (Siyo@A89938F4.87DAA49F.F113998C.IP) (Ping timeout)
[03:06:32] <sruggier> it sounds like Cell is meant to be the equivalent of C++'s mutable keyword, but in safe Rust
[03:06:49] *** Joins: Siyo (Siyo@A89938F4.87DAA49F.F113998C.IP)
[03:06:51] <cmr> I didn't even know C++ *had* a mutable keyword
[03:07:01] <tikue_> is making your own homebrew formula for a git repo "okay" ?
[03:07:17] *** Joins: rusti (rusti@moz-61B073BC.cpe.net.cable.rogers.com)
[03:07:28] <cmr> sruggier: Cell is for breaking the borrow check rules.
[03:07:28] *** Joins: strcat (strcat@moz-61B073BC.cpe.net.cable.rogers.com)
[03:07:31] <engla> Cell is to sneak in mutation behind an immut facade
[03:07:39] <sruggier> a "mutable" field on a C++ object can be modified from const functions
[03:07:41] *** Quits: rusti (rusti@moz-61B073BC.cpe.net.cable.rogers.com) (Client exited)
[03:07:52] <sruggier> and Cell is.. what engla said
[03:07:52] <SingingBoyo> speaking of callstacks, what do I break on to stop when a fail! runs?
[03:08:05] <cmr> SingingBoyo: the symbol is rust_upcall_fail
[03:08:07] <tikue_> i don't like cell :(
[03:08:12] *** Joins: rusti (rusti@moz-61B073BC.cpe.net.cable.rogers.com)
[03:08:14] <tikue_> i'd prefer a keyword
[03:08:18] <tikue_> like unsafe
[03:08:24] *** Quits: rusti (rusti@moz-61B073BC.cpe.net.cable.rogers.com) (Client exited)
[03:08:24] <cmr> modes!
[03:08:26] <cmr> :p
[03:08:27] *** Joins: rusti (rusti@moz-61B073BC.cpe.net.cable.rogers.com)
[03:08:48] <cmr> can unsafe code break the mutability rules?
[03:08:56] <strcat> tikue_: it's an anti-pattern you should avoid, it shouldn't have a language feature
[03:08:57] <sruggier> yes
[03:08:59] <cmr> I think there's a transmute to strip mutability.
[03:09:05] <strcat> cmr: unsound to do that
[03:09:06] <sruggier> it's what Cell uses
[03:09:12] <sruggier> (the transmute_mut)
[03:09:30] <strcat> Cell is has to mark itself as non-Freeze
[03:09:32] <tikue_> strcat: unless once closures become better supported cells are both an anti-pattern and an idiom
[03:09:34] <strcat> -is
[03:09:37] <SingingBoyo> oh wait it's not even a fail! that's failing anymore
[03:09:50] <cmr> rusti: 5
[03:09:51] -rusti- 5
[03:10:03] <cmr> Hah, upgrading to a newer rustc fixed it
[03:10:12] <cmr> strcat: <3 your repo
[03:10:18] <strcat> what was wrong?
[03:10:26] <engla> oh hi strcat, but mainly yay rusti!
[03:10:27] <cmr> https://gist.github.com/cmr/c0e24227164018e60639
[03:10:28] *** Joins: maik (maik@moz-EEB9CEBB.dip0.t-ipconnect.de)
[03:10:28] <SingingBoyo> so... what symbol should I break on to stop at a task failure?
[03:10:29] <sruggier> if you never care about performance, Cell is probably unnecessary
[03:10:33] <cmr> task <unnamed> failed at 'not allowed to compare these idents: &ast::Ident{name: 748u, ctxt: 506u}, &ast::Ident{name: 748u, ctxt: 525u}', /build/rust-git/src/rust/src/libsyntax/ast.rs:50
[03:10:36] <tikue_> sruggier: not true
[03:10:49] <cmr> SingingBoyo: rust_begin_unwind
[03:10:51] <strcat> sruggier: what does it have to do with performance?
[03:11:03] <maik> rusti: ~"h h h".split_iter(' ').to_owned()
[03:11:04] -rusti- <anon>:5:10: 6:5 error: type `std::str::CharSplitIterator<,char>` does not implement any method in scope named `to_owned`
[03:11:04] -rusti- <anon>:5          ~"h h h".split_iter(' ').to_owned()
[03:11:04] -rusti- <anon>:6     };
[03:11:04] -rusti- error: aborting due to previous error
[03:11:04] -rusti- application terminated with error code 101
[03:11:11] <strcat> Cell is pretty much just a workaround for not having once closures you can move stuff out of
[03:11:15] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[03:11:21] <sruggier> if you're implementing an "immutable" object that does e.g. lazy initialization, you need a mutable field to store the result
[03:11:24] <strcat> and only because closures don't let you capture mutable things atm
[03:11:37] <tikue_> sruggier: you don't need cells for that
[03:11:45] <sruggier> explain
[03:11:52] <tikue_> sec
[03:12:30] <strcat> sruggier: your type isn't immutable if it contains Cell
[03:12:37] <strcat> it's non-Freeze
[03:12:39] <cmr> Cool, rustdoc segfaults now.
[03:12:41] <tikue_> sruggier: 
[03:12:42] <tikue_> : Foo { bar: Option<uint> } let mut lazy_foo = Foo { bar: None }; /* sometime laterâ€¦ */ lazy_foo.bar = Some(1); let foo = lazy_foo; /* now immutable */
[03:12:44] <cmr> Not a single unsafe block, either!
[03:12:55] <cmr> Oh wait
[03:12:57] <cmr> plugins
[03:12:59] <cmr> right
[03:13:17] <sruggier> you used a mutable reference there though
[03:13:18] *** Quits: Jesin (Jessin_@moz-679F0D97.cc.lehigh.edu) (Input/output error)
[03:13:26] <tikue_> sruggier: after updating it, it's immutable
[03:13:28] <tikue_> i didn't reference
[03:13:29] <tikue_> i moved it
[03:13:44] <tikue_> lazy_foo no longer exists and foo is immutable
[03:13:49] <sruggier> yes, but the caller (your example code) is forced to change the mutability and stuff
[03:13:58] <strcat> sruggier: it's always exposed to the caller via Freeze
[03:13:58] <maik> CharSplitIterator has no to_owned?
[03:13:59] <tikue_> sure, but why is that worse than using cell?
[03:14:13] <strcat> sruggier: there are things with Freeze bounds, one example will be data parallelism
[03:14:15] <sruggier> using a Cell allows you to abstract what you just did away behind an interface, so that the caller doesn't have to do it
[03:14:16] <engla> maik: it's a normal iterator, so you can collect()  it.
[03:14:41] <tikue_> sruggier: behind what interface? they have to know about the cell
[03:15:23] <maik> rusti: ~"h h h".split_iter(' ').collect()
[03:15:24] <sruggier> the implementation has to know about the cell, but can provide an interface to the caller that looks simple, but performs the lazy init in the background
[03:15:25] -rusti- <anon>:5:10: 6:5 error: cannot determine a type for this bounded type parameter: unconstrained type
[03:15:26] -rusti- <anon>:5          ~"h h h".split_iter(' ').collect()
[03:15:26] -rusti- <anon>:6     };
[03:15:26] -rusti- application terminated with error code 101
[03:15:29] <SingingBoyo> wow I'm really breaking extra::json trying to get it to support maps with non-string keys
[03:15:32] <tikue_> you could also do a functional update of the struct
[03:15:36] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[03:15:45] <cmr> SingingBoyo: yeah, extra::json is a super mess.
[03:15:47] <cmr> good luck
[03:15:56] <strcat> aren't json keys always strings?
[03:15:56] <cmr> wait
[03:16:00] <cmr> json doesn't support non-string keys
[03:16:03] <cmr> yeah
[03:16:05] <strcat> neither does js
[03:16:06] <SingingBoyo> but Encodable does
[03:16:10] <Eridius> what's gyp?
[03:16:15] <SingingBoyo> and json has an implementation of Encoder
[03:16:16] <strcat> Eridius: weird build system used by llvm
[03:16:19] <strcat> er
[03:16:20] <cmr> Eridius: node uses it in its build system
[03:16:21] <strcat> libuv*
[03:16:25] <cmr> it's a google thing
[03:16:26] <Eridius> hmm
[03:16:27] <SingingBoyo> which by extension should support non-string keys
[03:16:37] <SingingBoyo> I commented on an issue somewhere
[03:16:41] <tikue_> struct Foo { bar: uint, baz: Option<uint> } let foo = Foo { bar: 1, baz: None }; /* later on */ let foo = Foo { baz: Some(1), ..foo };
[03:16:43] <cmr> SingingBoyo: I don't think so, I think it should fail the task on non-string keys.
[03:16:49] <strcat> SingingBoyo: json shouldn't ever have non-string keys
[03:16:49] <cmr> Producing invalid js isn't really a nice thing to do :\
[03:16:52] *** Joins: lazyden (lazyden@47A36AC9.35CBBBD0.F246D1AF.IP)
[03:16:52] <Eridius> `make -j4` just errored out with a spurious error. I think we have dependency problems again. (for what it's worth I haven't built in 1.5 weeks, since I was on vacation)
[03:16:53] <tikue_> sruggier: ^
[03:16:54] <cmr> *json
[03:17:00] <strcat> cmr: well js shouldn't either :)
[03:17:16] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[03:17:31] <strcat> js> var a = {}
[03:17:35] <strcat> js> a[2] = "foo"
[03:17:37] <strcat> "foo"
[03:17:39] <strcat> js> a[[] + [2]] = 5
[03:17:41] <strcat> 5
[03:17:43] <strcat> js> a[2]
[03:17:45] <strcat> 5
[03:17:46] <tikue_> unless your object is in an @mut box, no one else could have had a borrowed pointer before performing initialization, so you can just update the struct itself with lazy values
[03:17:47] <strcat> yay js
[03:17:50] <strcat> anyway, json is the same way ;p
[03:18:25] <sruggier> tikue_: again, this is stuff that the caller can do, but if you want to do it behind a function that takes an immutable self reference and then initializes the field the first time it's called, I don't think that's going to fly
[03:18:33] <strcat> Cell is useful, just wanted to point out that it remains transparent that the type is always mutable due to Freeze being gone
[03:18:45] *** Joins: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net)
[03:18:46] <strcat> and it will have performance implications in addition to restricting the APIs you can use with it
[03:18:52] <engla> strcat: there are two ways to encode json in extra::json :(
[03:19:11] <tikue_> sruggier: that really doesn't seem like the right way to do it though
[03:19:15] *** Quits: SingingBoyo (brandon@DAC9C672.CE76D40F.4F048BDC.IP) (Ping timeout)
[03:19:20] <strcat> engla: it also produces invalid strings in some corner cases
[03:19:24] <strcat> luckily it's not in libstd
[03:19:31] <sruggier> strcat: that's fair - you don't want to use lazy init on a concurrently shared piece of data anyway
[03:19:34] <tikue_> sruggier: why not just have the initialization take the object by value and return a new object
[03:19:42] <strcat> sruggier: that's true
[03:19:50] <tikue_> or rather, the same object after it did some mutation
[03:20:25] <sruggier> because it's better if the lazy init is transparent, and callers don't have to worry that it's happening
[03:20:41] <tikue_> transparent meaning?
[03:20:54] *** Joins: SingingBoyo (brandon@DAC9C672.CE76D40F.4F048BDC.IP)
[03:21:02] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[03:21:02] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/WCz9-Q
[03:21:02] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[03:21:07] <sruggier> transparent meaning that the caller can't tell the difference (other than the freeze trait being gone)
[03:21:28] <tikue_> sruggier: it doesn't make sense though. 
[03:21:31] <sruggier> the motivation is to shield the caller from implementation details
[03:21:46] <strcat> well it makes as much sense as @mut
[03:21:55] <strcat> Cell pushes mutability failures to runtime
[03:22:02] <tikue_> strcat: why would @mut be required in this case?
[03:22:20] <strcat> we could rewrite Cell to be more flexible
[03:22:30] <strcat> once closures no longer need it
[03:22:31] <SingingBoyo> cmr, strcat: the json extra::json produces shouldn't have non-string keys.  But there are implementations of Encodable for maps with any type of key as long as that key is Encodable
[03:22:56] <SingingBoyo>  so in theory any implementation of encoder should support writing any kind of map as long as the keys and values are Encodable
[03:23:17] <cmr> So what are you going to do?
[03:23:32] <cmr> base64 the key?
[03:23:39] <strcat> wouldn't be reversible
[03:23:39] <tikue_> sruggier: If you're passing a borrowed pointer to a function and expecting it to perform initialization, the fact that the pointer is &mut and not & doesn't seem like a good reason to use Cell instead
[03:24:12] <SingingBoyo> cmr:  "key0":<actual key json>, "val0":<actual value json>  etc.
[03:24:15] <sruggier> the whole point is to use this in situations where the caller does not expect initialization to be performed
[03:24:16] <cmr> ok
[03:24:22] <cmr> makes sorta-sense
[03:24:29] <mark_edward> how could i implement the index type, if there is no index_mut?
[03:24:34] <mark_edward> *index trait
[03:24:36] <sruggier> and you want to implement a performance optimization without changing the interface you present to callers
[03:24:37] <tikue_> sruggier: iterators expose their mutability instead of putting their state in Cells, 
[03:24:38] <cmr> mark_edward: don't implement Index
[03:24:43] <cmr> It's a bad trait that will be replaced.
[03:24:51] <mark_edward> cmr: what's bad about it?
[03:25:05] <cmr> mark_edward: can't assign separately, types are inflexible
[03:25:17] <strcat> it doesn't let you actually implement what vectors have
[03:25:22] <strcat> and it should
[03:25:25] <SingingBoyo> unfortunately the implementation of encodable for json then needs to do some odd things when writing out json Objects
[03:25:29] *** Quits: adu (alt@moz-BF2B1AE4.washdc.fios.verizon.net) (Ping timeout)
[03:25:42] <mark_edward> strcat: yeah, that's what i was worried about
[03:25:42] <strcat> SingingBoyo: how would you reverse it?
[03:26:00] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[03:26:00] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/q0o5gQ
[03:26:00] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[03:26:02] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[03:26:02] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/m60JOw
[03:26:02] <ghrust> 13rust/06auto 14a835995 15Tim Kuehn: Rendezvous stream for synchronous channel messaging
[03:26:02] <ghrust> 13rust/06auto 14511cd05 15bors: auto merge of #8908 : tikue/rust/master, r=anasazi...
[03:26:02] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[03:26:02] *** Joins: adu (alt@moz-BF2B1AE4.washdc.fios.verizon.net)
[03:26:03] <sruggier> tikue_: here's an example: let's say you have an object that represents the result of some kind of expensive computation, and you want the computation to happen lazily, instead of before returning the result
[03:26:12] <cmr> SingingBoyo: while you're in there mind taking a shot at https://github.com/mozilla/rust/pull/8437 ? :P
[03:26:23] <tikue_> sruggier: like iterator's methods for instance?
[03:26:28] <tikue_> filter map etc
[03:26:32] *** Quits: lmandel (lmandel@moz-76CE9D51.cable.teksavvy.com) (Quit: lmandel)
[03:26:50] <sruggier> let's keep it simpler and just imagine that some math is being performed or something
[03:27:08] <sruggier> the caller should not need a mutable reference just to see the result of that computation
[03:27:47] <sruggier> your API could return an immutable reference to the result, and the caller shouldn't have to care about whether the result is being computed lazily or not
[03:28:04] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[03:28:14] <sruggier> for some styles of API, the laziness may be an implementation detail
[03:28:19] <SingingBoyo> cmr: one thing at a time!  I'll give it a look once I get this working.
[03:28:20] <tikue_> sruggier: rust currently doesn't have a way to represent this, but prefers explicit mut to implicit Cell. look at rust-lang.org for an example where this is the case
[03:28:30] <cmr> SingingBoyo: you are awesome!
[03:28:40] <tikue_> `let mut evens = nums.iter().filter(|&x| x % 2 == 0);`
[03:28:49] <tikue_> the only reason it's mutable is because of the laziness
[03:28:51] <tikue_> of that computation
[03:29:01] <tikue_> but it's better than using a cell to store iterators' internal states
[03:30:07] <SingingBoyo> cmr: I'm also probably in way over my head :|   But we shall see.
[03:30:34] <sruggier> which one is better may be subjective, or I might argue that using a Cell would be better
[03:30:39] <cmr> Those familiar with metadata: is there any def_map equivalent? Take a DefId and get a Def?
[03:30:53] <strcat> sruggier: well that case isn't really subjective
[03:31:02] <strcat> iterators would be an order of magnitude slower if they used Cell
[03:31:03] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[03:31:03] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14511cd05 to 146216661: 02http://git.io/N3iJvQ
[03:31:03] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[03:31:05] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[03:31:05] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/fqFBlA
[03:31:05] <ghrust> 13rust/06auto 14a835995 15Tim Kuehn: Rendezvous stream for synchronous channel messaging
[03:31:05] <ghrust> 13rust/06auto 1497384e8 15bors: auto merge of #8908 : tikue/rust/master, r=anasazi...
[03:31:06] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[03:31:16] *** Quits: cstrahan (cstrahan@moz-71FAC30.hsd1.va.comcast.net) (Ping timeout)
[03:31:17] <strcat> their function bodies become the inner loop
[03:31:43] <sruggier> the optimizer wouldn't do the right thing in that situation?
[03:31:49] *** Joins: pudgetta (Mibbit@moz-98DDA60.border.net.adelaide.edu.au)
[03:32:02] *** Quits: vadimcn (chatzilla@A2267643.76F9E272.DA40C4B3.IP) (Quit: ChatZilla 0.9.90.1 [Firefox 23.0.1/20130814063812])
[03:32:02] <strcat> it can't really optimize out Cell used as interior mutability
[03:32:32] <tikue_> the idea of "interior mutability" is an interesting one though
[03:32:46] <tikue_> and i agree it's slightly a shame that it requires an explicit `mut` right now
[03:32:57] <strcat> Cell is a wrapper around Option
[03:33:03] *** Quits: ChrisMorgan (chris@moz-3ECEFC27.its.monash.edu.au) (Ping timeout)
[03:33:16] <tikue_> so in that regard we're in agreement sruggier -- i just don't think cell is the right way to solve that
[03:33:41] *** Joins: ChrisMorgan (chris@moz-3ECEFC27.its.monash.edu.au)
[03:33:45] <strcat> when you do with_mut_ref, it branches on whether is it None, and fails if it is
[03:33:52] <strcat> then swaps in None (to get the value out)
[03:34:03] <strcat> that's another branch, but they should get merged
[03:34:37] *** Quits: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net) (Ping timeout)
[03:34:50] <strcat> then modifies it through &mut, then moves it back in - but it has to handle failure in the function
[03:34:57] <tikue_> did interior mutability ever exist? e.g. struct Foo { priv mut internals: Bar }
[03:34:59] <strcat> so it has a whole landing pad destructor thing.
[03:35:08] <strcat> tikue_: yes it was removed
[03:35:22] <tikue_> strcat: to what end?
[03:35:30] *** Joins: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net)
[03:35:36] <strcat> types with interior mutability are not usable
[03:35:41] <strcat> you essentially can't use &
[03:36:04] <strcat> Cell has dynamic runtime failures
[03:36:17] <sruggier> if all that stuff is getting inlined, I would guess that the optimizer could tell that the Option's never going to be None, and remove all of the fail related stuff?
[03:36:31] <strcat> sruggier: it can't
[03:36:39] <strcat> you can try it
[03:36:54] <strcat> the Option *will* be None when you've taken the value out
[03:37:40] <sruggier> yes, but it won't be None at the start of the next loop iteration
[03:38:04] <strcat> it can't prove that
[03:38:24] <tikue_> it couldn't use inductive reasoning? :O)
[03:38:33] <hoverbear> Can I generate a range in rust? Eg let x = [1..10 by 2]?
[03:38:41] <tikue_> hoverbear: yep
[03:38:51] *** Joins: fyolnish (fyolnish@moz-BE2BAE5B.miinet.jp)
[03:38:56] <strcat> rusti: for x in range(0, 3) { print!("{ ") }
[03:38:56] -rusti- <anon>:5:39: 5:43 error: unterminated format string
[03:38:56] -rusti- <anon>:5          for x in range(0, 3) { print!("{ ") }
[03:38:56] -rusti-                                                 ^~~~
[03:38:57] -rusti- error: aborting due to previous error
[03:38:57] -rusti- application terminated with error code 101
[03:38:57] *** Quits: optimusbrine (optimusbri@moz-CF697891.tampfl.fios.verizon.net) (Ping timeout)
[03:39:00] <strcat> rusti: for x in range(0, 3) { print!("{} ", x) }
[03:39:01] -rusti- 0 1 2 ()
[03:39:03] <hoverbear> Hawt thanks
[03:39:03] <sruggier> it may not be able to prove it now, but it seems like the sort of thing that an optimizer could hypothetically deal with eventually
[03:39:05] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[03:39:05] *** ChanServ sets mode: +ao brson brson
[03:39:24] <strcat> sruggier: it can't though, it doesn't know the semantics of Cell
[03:39:45] <strcat> and when it sees failures + landing pads it's all over
[03:39:58] <tikue_> rusti: use std::iter::count; let x: ~[uint] = count(1, 2).take_while(|i| i <= 10).collect(); x
[03:40:03] -rusti- pastebinned 11 lines of output: http://ix.io/7Zh
[03:40:09] *** Joins: Ralith (ralith@114DA04D.CD83ED0A.BCDF04A6.IP)
[03:40:18] <tikue_> rusti: use std::iter::count; let x: ~[uint] = count(1, 2).take_while(|&i| i <= 10).collect(); x
[03:40:24] -rusti- pastebinned 8 lines of output: http://ix.io/7Zi
[03:40:25] <tikue_> come onnnn
[03:40:29] <hoverbear> strcat: What about the "by 2" bit in what I had?
[03:40:31] <sruggier> but if you have all of this stuff happening within a loop inside the iterator, I'd assume the optimizer could inline it all and then figure that sort of thing out
[03:40:49] <tikue_> rusti: use std::iter::count; let x: ~[int] = count(1, 2).take_while(|&i| i <= 10).collect(); x
[03:40:50] -rusti- ~[1, 3, 5, 7, 9]
[03:40:51] <strcat> hoverbear: there's not a convenience iterator for range_step yet
[03:40:53] <tikue_> hoverbear: that's what ^ is
[03:41:01] <tikue_> lol
[03:41:08] <strcat> sruggier: the compiler isn't that clever
[03:41:12] <strcat> it can inline all the next() calls
[03:41:19] <hoverbear> strcat: Ok, I meant in general but I'll just do a filter I guess.
[03:41:31] <strcat> and then it has a nice clean loop, right now
[03:41:37] *** Joins: aeqwa (aeqwa@moz-88A8BC36.dsl.tropolys.de)
[03:41:37] <strcat> it's not actually clever enough to even vectorize them
[03:41:38] <tikue_> hoverbear: look at what i just posted
[03:41:45] <strcat> because the only iterator pattern it understands is the C++ one
[03:42:01] <strcat> where your iterator has undefined behaviour if you keep iterating at the end
[03:42:06] <strcat> it wants the condition in a different order
[03:42:12] <tikue_> hoverbear: a bit verbose, i'll admit :O)
[03:42:13] <strcat> anyway, the optimizations are not as clever as you'd think
[03:42:20] *** Joins: optimusbrine (optimusbri@moz-CF697891.tampfl.fios.verizon.net)
[03:42:21] <hoverbear> Is there filter/map/reduce on Vectors? (Sorry, first time with Rust, I'm digging in the docs atm)
[03:42:30] <strcat> hoverbear: they are on iterators
[03:42:31] <tikue_> hoverbear: they're deprecated in favor of iterator methods
[03:42:54] <hoverbear> Ok. Where could I find information on those?
[03:42:57] <strcat> hoverbear: http://static.rust-lang.org/doc/tutorial-container.html#iterators http://seld.be/rustdoc/master/std/iterator/trait.Iterator.html
[03:42:59] <tikue_> hoverbear: (though I'd like vec to get them eventually, whenever the iterable trait becomes more than an idea i guess)
[03:43:16] <hoverbear> strcat: You are a hero, thanks.
[03:43:27] <tikue_> yes he is lol
[03:43:32] *** Joins: wil (wil@moz-FDE1AC97.bootp.virginia.edu)
[03:43:43] *** Quits: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net) (Quit: Leaving)
[03:43:54] <sruggier> I'm not necessarily assuming that the optimizers are that smart now, I just like to assume they will catch up eventually
[03:44:08] <hoverbear> Man I'm so used to Coffeescript :S
[03:44:45] <strcat> sruggier: it can really only do transformations like that if everything is pure and there's no unwinding
[03:44:55] <strcat> it's not provably correct otherwise
[03:45:03] <strcat> it doesn't know about rust's invariants to provide safety
[03:45:23] <strcat> (although unwinding + lack of purity are separate)
[03:45:45] <SingingBoyo> oooh I think it's actually compiling.  maybe I'm finally done jumping through borrowed ptr hoops.
[03:45:50] * SingingBoyo crosses fingers
[03:46:20] *** Quits: StarLight (StarLight@moz-E5D48285.dynamic.avangarddsl.ru) (Ping timeout)
[03:46:42] <strcat> sruggier: type-based alias analysis can communicate a lot of the information
[03:46:42] *** Joins: lbergstrom (Adium@moz-7D905691.avante-wifi.mozilla.hq)
[03:46:48] <mark_edward> how do you use RUST_LOG again?
[03:46:51] <strcat> but a key point there is that if the type isn't Freeze, there's no information to communicate
[03:47:30] <strcat> truly immutable pointers allow it to ignore aliasing issues, and &mut doesn't alias &mut or &
[03:47:30] <acrichto> mark_edward: RUST_LOG=path::to::module=level,other::module=3
[03:47:40] <mark_edward> thanks
[03:48:09] <sruggier> if the unwinding will only happen under certain conditions, and those conditions are provably false for a given loop, though, it sounds like these are practical limitations you're describing, not theoretical
[03:48:30] <strcat> sruggier: &T where T is not Freeze aliases any &U
[03:48:46] <strcat> so any time LLVM sees a store, it has to assume it wrote to almost every single pointer
[03:48:49] <mark_edward> acrichto: how can i get a stacktrace? should really get them by default on fail!() i think
[03:49:08] <wil> When using std::libc::alarm(), is there a way to set a handler for SIGALRM?
[03:49:16] <cmr> mark_edward: break on rust_begin_unwind in gdb.
[03:49:28] <acrichto> mark_edward: rust won't print out stack traces any more, cmr's suggestion is the way to go
[03:49:41] <mark_edward> acrichto: is that on purpose?
[03:49:44] <strcat> sruggier: it can only do clever transformations when everything is by-value or there is aliasing information
[03:50:03] <acrichto> mark_edward: perhaps? I'm not sure how it was ever done in the first place
[03:50:12] <cmr> it was fragile and only worked on linux.
[03:50:16] <cmr> we could use libunwind.
[03:50:20] <sruggier> hypothetically, would the front-end be able to provide that information later on?
[03:50:35] <strcat> sruggier: yes, but the information is from the static mutability system
[03:50:45] *** Joins: StarLight (StarLight@moz-BDEDADC1.dynamic.avangarddsl.ru)
[03:51:08] <strcat> &Cell<T> aliases every &U
[03:51:12] <strcat> by definition
[03:51:31] <strcat> because it's not immutable, so there are write dependencies
[03:51:36] <strcat> no information to communicate to LLVM
[03:51:50] <sruggier> what if it wasn't a borrowed pointer to a Cell though?
[03:52:21] <sruggier> or do you mean to say that a borrowed pointer to a struct containing a cell would have the same issues?
[03:52:30] <strcat> that would have the same issues
[03:52:45] *** Quits: SingingBoyo (brandon@DAC9C672.CE76D40F.4F048BDC.IP) (Ping timeout)
[03:52:53] <sruggier> and when you say &U, do you mean &mut?
[03:52:56] <strcat> no
[03:53:01] <sruggier> right, I see now
[03:53:07] <strcat> I mean any &
[03:53:17] <strcat> like
[03:53:30] <sruggier> yeah, because the Cell is writing to an immutable pointer
[03:53:32] <strcat> lets say x is &T, and y is &U (T can be the same as U, but doesn't have to be)
[03:53:40] *** Joins: cstrahan (cstrahan@moz-71FAC30.hsd1.va.comcast.net)
[03:53:55] <strcat> if both types are Freeze, we know that they point to immutable memory
[03:54:04] <strcat> well, even if one is Freeze
[03:54:11] *** Joins: SingingBoyo (brandon@DAC9C672.CE76D40F.4F048BDC.IP)
[03:54:16] <strcat> and immutable memory -> does not alias, in LLVM terms
[03:54:40] <strcat> rust has special enforcement of uniqueness of &mut, so it doesn't alias with other &mut or &
[03:54:42] <sruggier> so essentially it won't alias with everything, just other pointers to non-freeze types
[03:54:52] <strcat> sruggier: it will alias with ~ and @
[03:54:59] *** Joins: jdm (jdm@moz-2C5514D1.lightspeed.sntcca.sbcglobal.net)
[03:54:59] *** ChanServ sets mode: +o jdm
[03:55:08] <strcat> or raw pointers
[03:55:13] <sruggier> yeah
[03:56:49] <sruggier> I haven't hacked on compiler back-ends enough to really apply the aliasing discussion to the issue of optimizing dead branches away, so it's probably better if we have this conversation later, when I have more experience :)
[03:57:14] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[03:57:54] <strcat> rust's static mutability system provides a guarantee of not having dynamic failures like iterator invalidation and also provides those optimization opportunities
[03:58:02] <strcat> and if you use @mut/Cell, you're not getting that
[03:58:16] *** Joins: eholk (eholk@moz-F70D5031.hsd1.in.comcast.net)
[03:58:46] *** Quits: lbergstrom (Adium@moz-7D905691.avante-wifi.mozilla.hq) (Quit: Leaving.)
[03:59:09] *** Quits: tikue_ (tkuehn@FE643D5D.E2CAEE6E.689607DE.IP) (Ping timeout)
[03:59:39] <wil> Hi, can I ask a question about the libc bindings?
[03:59:51] *** Joins: lmandel (lmandel@moz-76CE9D51.cable.teksavvy.com)
[04:00:23] <wil> When using std::libc::alarm(), is there a way to set a handler for SIGALRM?
[04:00:28] <cmr> wil: you'll need to use the functions from std::os to set signal handlers. if they don't exist, you'll need to add them.
[04:00:46] <sruggier> I'll make a mental note that if I ever feel the need to use them, I should test the performance implications and see if it still makes sense in context
[04:00:51] <strcat> signal handlers aren't going to work without turning off the runtime
[04:01:00] <cmr> https://github.com/mozilla/rust/issues/8987
[04:01:22] <wil> Oh, ok. Thank you!
[04:01:35] <sruggier> thankfully, I don't need to use Cell for anything at the moment
[04:01:49] <strcat> sruggier: well it's not as bad as allocating or something ;p
[04:01:56] <strcat> but it's not very appropriate for an innermost loop
[04:01:59] <strcat> like Iterator
[04:02:47] *** Joins: tikue_ (tkuehn@FE643D5D.E2CAEE6E.689607DE.IP)
[04:03:29] <maik> rusti: let s = ~"h h h h h"; let src_vec: ~[~str] = s.line_iter().fold(~[], |_,item: &str| item.to_owned()); src_vec
[04:03:29] -rusti- <anon>:5:93: 5:109 error: mismatched types: expected `~[<V102>]` but found `~str` (expected vector but found ~str)
[04:03:29] -rusti- <anon>:5          let s = ~"h h h h h"; let src_vec: ~[~str] = s.line_iter().fold(~[], |_,item: &str| item.to_owned()); src_vec
[04:03:29] -rusti-                                                                                                       ^~~~~~~~~~~~~~~~
[04:03:29] -rusti- error: aborting due to previous error
[04:03:31] -rusti- application terminated with error code 101
[04:03:55] *** Quits: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net) (Ping timeout)
[04:03:56] <maik> ^does anyone understand the error message?
[04:04:06] <tikue_> maik: yes
[04:04:12] <cmr> maik: you're folding into a vector, you're returning a string.
[04:04:27] *** Joins: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net)
[04:05:13] <maik> rusti: let s = ~"h h h h h"; let src_vec: ~[~str] = s.line_iter().fold(~[], |a,item: &str| a.push(item.to_owned());); src_vec
[04:05:13] -rusti- <anon>:5:116: 5:117 error: expected `,` but found `;`
[04:05:13] -rusti- <anon>:5          let s = ~"h h h h h"; let src_vec: ~[~str] = s.line_iter().fold(~[], |a,item: &str| a.push(item.to_owned());); src_vec
[04:05:14] -rusti-                                                                                                                              ^
[04:05:14] -rusti- application terminated with error code 101
[04:05:18] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[04:05:25] <Amaranth> Hrm I must be doing something wrong
[04:05:31] *** Quits: lmandel (lmandel@moz-76CE9D51.cable.teksavvy.com) (Quit: lmandel)
[04:05:39] <Amaranth> I'm stuck in a situation where the solution appears to be using @ which can't be right
[04:05:44] <SingingBoyo> let s = ~"h h h h h"; let src_vec: ~[~str] = s.line_iter().fold(~[], |v,item: &str| vec::append(v,item.to_owned())); src_vec
[04:05:50] <cmr> Amaranth: it does happen; @ exists for a reason you know :p
[04:05:51] <maik> rusti: let s = ~"h h h h h"; let src_vec: ~[~str] = s.line_iter().fold(~[], |a,item: &str| {a.push(item.to_owned());}); src_vec
[04:05:52] -rusti- <anon>:5:93: 5:119 error: mismatched types: expected `~[~str]` but found `()` (expected vector but found ())
[04:05:52] -rusti- <anon>:5          let s = ~"h h h h h"; let src_vec: ~[~str] = s.line_iter().fold(~[], |a,item: &str| {a.push(item.to_owned());}); src_vec
[04:05:53] -rusti-                                                                                                       ^~~~~~~~~~~~~~~~~~~~~~~~~~
[04:05:53] -rusti- error: aborting due to previous error
[04:05:53] <strcat> Amaranth: what's the situation?
[04:05:54] -rusti- application terminated with error code 101
[04:06:10] <SingingBoyo> rusti: let s = ~"h h h h h"; let src_vec: ~[~str] = s.line_iter().fold(~[], |v,item: &str| vec::append(v,item.to_owned())); src_vec
[04:06:21] -rusti- pastebinned 11 lines of output: http://ix.io/7Zj
[04:06:28] <tikue_> rusti: use std::vec::append_one; let s = ~"h h h h h"; let src_vec: ~[~str] = s.line_iter().fold(~[], |v, item: &str| append_one(v, item.to_owned())); src_vec
[04:06:29] <cmr> maik: you can query rusti you know
[04:06:31] -rusti- ~[~"h h h h h"]
[04:06:31] <tikue_> that's what you want
[04:06:36] <Amaranth> I've got an sdl2::video::Window that I want to put in my events
[04:06:39] *** Quits: cstrahan (cstrahan@moz-71FAC30.hsd1.va.comcast.net) (Ping timeout)
[04:06:42] <tikue_> maik: ^
[04:06:44] <Amaranth> It has to exist otherwise I wouldn't be getting events for it
[04:06:55] <SingingBoyo> rusti: let s = ~"h h h h h"; let src_vec: ~[~str] = s.line_iter().fold(~[], |v,item: &str| std::vec::append_one(v,item.to_owned())); src_vec
[04:06:56] -rusti- ~[~"h h h h h"]
[04:07:08] <Amaranth> &video::Window seemed obvious but this is a tagged union and they aren't allowed
[04:07:09] <tikue_> beat you to it SingingBoyo ;)
[04:07:26] <maik> tikue_, thanks!
[04:07:27] <SingingBoyo> tikue_: still not sure we got that right
[04:07:35] <tikue_> haha what do you mean
[04:07:37] <strcat> Amaranth: borrowed pointers are allowed in an enum, if that's what you mean
[04:07:54] <Amaranth> Not according to this compiler output
[04:07:57] <cmr> Amaranth: they're allowed, just not with anonymous lifetimes.
[04:08:04] <SingingBoyo> tikue_: well, what's the point of putting a string into a vector of one element?
[04:08:11] <tikue_> SingingBoyo: dunno, ask maik :P
[04:08:12] <Amaranth> Apparently 'self isn't a valid lifetime either
[04:08:16] <tikue_> the line_iter iterates by line
[04:08:17] <SingingBoyo> tikue_: unless the output is just formatting oddly
[04:08:19] <strcat> rusti: enum Foo<'self> { A(&'self int) }
[04:08:19] -rusti- ()
[04:08:21] <cmr> enum Foo<'self>
[04:08:26] <tikue_> there's also split_iter i believe
[04:08:37] <strcat> rusti: enum Foo<'self> { A(&'self int) } static X: int = 5; A(&X)
[04:08:37] -rusti- A(&5)
[04:08:38] <Amaranth> Oh right I need to do it up there too
[04:08:53] <SingingBoyo> ah yeah split_iter would make more sense there and I think maik was using it earlier
[04:09:28] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[04:09:29] * strcat stares at VecIterator and wonders if the comparison can be re-ordered...
[04:09:30] <maik> SingingBoyo, yeah I was just too lazy to write \n all the time :D 
[04:09:37] <tikue_> rusti: use std::vec::append_one; let s = ~"h h h h h"; let src_vec: ~[~str] = s.split_iter(' ').fold(~[], |v, item: &str| append_one(v, item.to_owned())); src_vec
[04:09:38] -rusti- ~[~"h", ~"h", ~"h", ~"h", ~"h"]
[04:10:38] <strcat> do you just want to split and build up a vector?
[04:10:45] <SingingBoyo> rusti: let s = ~"h\nh\nh\nh\nh";; let line_vec:~[~str] = s.line_iter().collect(); line_vec
[04:10:48] -rusti- pastebinned 8 lines of output: http://ix.io/7Zm
[04:10:52] <Amaranth> Alright I definitely don't understand lifetimes
[04:10:58] * Amaranth goes back to the spec
[04:11:31] *** Quits: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca) (Quit: Leaving)
[04:11:42] *** Joins: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP)
[04:11:43] <SingingBoyo> rusti: let s = ~"h\nh\nh\nh\nh";; let line_vec:~[~str] = s.line_iter().map(|x| x.to_owned()).collect(); line_vec
[04:11:44] -rusti- ~[~"h", ~"h", ~"h", ~"h", ~"h"]
[04:11:50] <tikue_> yeah maik actually fold is unnecessary if you just want to build up a vec
[04:11:54] *** Quits: Sorella (queen@9D963F5D.DF5D8AE7.54BCAB54.IP) (Quit: G'night everynyan~!)
[04:11:58] <SingingBoyo> maik: ^ does that do what you want too?
[04:12:25] <ww> does rust have ternary operator like  (cond-test ? result-of-true : result-of-false) ?
[04:12:38] <cmr> ww: no, but if is an expression.
[04:12:47] <cmr> rusti: if true { 42 } else { 3 }
[04:12:48] -rusti- 42
[04:12:50] <strcat> it used to have the ternary operator but it was removed in favour of `if`
[04:13:00] <ww> ok thx
[04:13:32] <Amaranth> If I'm using enum Foo<'self> how do I do the impl side?
[04:13:46] <cmr> Amaranth: impl<'self> Foo<'self>, I believe.
[04:13:48] <maik> SingingBoyo, oh that looks nicer
[04:13:57] <Amaranth> Missed a 'self again
[04:14:00] <tikue_> haha
[04:14:03] <maik> SingingBoyo, thanks
[04:14:17] <Amaranth> Perfect, thanks
[04:14:23] *** Parts: sruggier (sruggier@moz-F1ED47A9.cpe.teksavvy.com) ()
[04:15:19] *** Quits: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net) (Ping timeout)
[04:15:57] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[04:16:33] <hoverbear> Hmmmâ€¦. println on a vector doesn't workâ€¦ trying to cast this vector as a string, bad idea?
[04:16:35] *** Joins: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net)
[04:16:42] <tikue_> hoverbear: printfln! still exists
[04:16:52] <SingingBoyo> ooh I fixed it.
[04:16:52] <SingingBoyo> where do I add regression tests for specific issues?
[04:16:56] <tikue_> rusti: printfln!([1, .. 10]);
[04:16:58] <cmr> hoverbear: "cast" as a string? doesn't even make sense. Convert, you mean? Or stringify?
[04:16:58] -rusti- [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[04:16:58] -rusti- ()
[04:17:05] <strcat> unlikely you want to use repr to print a vector
[04:17:10] <cmr> SingingBoyo: src/test/{compile-fail,run-pass,run-fail}, as the case may be.
[04:17:13] <strcat> the way it prints out could change tommorow :s
[04:17:22] <hoverbear> cmr: Sorry, I want to convert a list to a string.
[04:17:26] <hoverbear> tikue_: Ok, interesting.
[04:17:33] <tikue_> strcat: why does that matter :P
[04:17:37] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[04:17:52] <tikue_> hoverbear: i wouldn't use it though :\ best to use println!
[04:17:56] <strcat> does it matter that it generates a kilobyte of code and is slow? ;p
[04:18:03] <tikue_> rusti: println!("{:?}", [1, ..10]);
[04:18:04] -rusti- [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[04:18:04] -rusti- ()
[04:18:19] <tikue_> strcat: not when a kilobyte of code compiles faster than the difference in writing ^ and ^^
[04:18:21] <tikue_> :P
[04:18:43] <cmr> rusti: let x = ~[1, 2, 3]; x.to_str()
[04:18:43] <hoverbear> strcat: So there's no built in way to just convert a list to a string?
[04:18:43] -rusti- ~"[1, 2, 3]"
[04:18:49] <hoverbear> ooo
[04:18:59] <tikue_> rusti: stringify!([1, 2, 3, 4, 5]);
[04:18:59] -rusti- ()
[04:19:02] <tikue_> rusti: stringify!([1, 2, 3, 4, 5])
[04:19:03] -rusti- "[ 1 , 2 , 3 , 4 , 5 ]"
[04:19:12] <tikue_> lol those spaces are silly
[04:19:18] <tikue_> what does stringify even do
[04:19:26] <cmr> token tree -> string
[04:19:29] <ww> rusti: 1 + 2
[04:19:31] -rusti- 3
[04:19:40] <ww> neat
[04:19:42] <tikue_> rusti: [1, 2, 3].to_str()
[04:19:43] -rusti- ~"[1, 2, 3]"
[04:19:53] <engla> rusti: format!("you have {} too", "format")
[04:19:54] -rusti- ~"you have format too"
[04:19:59] <ww> what's the format designator for u32 in fmt!?
[04:20:09] <benh> rusti: stringify!(what does stringify even do!)
[04:20:09] -rusti- "what does stringify even do !"
[04:20:11] <strcat> ww: use format!, and {}
[04:20:12] <tikue_> the number of ways to print things is too damn high!
[04:20:17] <strcat> fmt! is going away soon
[04:20:23] <tikue_> benh: lol!
[04:20:23] <strcat> at least, the old syntax
[04:20:28] <cmr> as soon as we have a snapshot right?
[04:20:31] <strcat> cmr: yeah
[04:20:44] <Eridius> rusti: stringify!(stringify!(stringify!()))
[04:20:45] -rusti- "stringify ! ( stringify ! ( ) )"
[04:20:50] <tikue_> wat
[04:20:58] <tikue_> : ()
[04:20:59] <ww> rusti: fmt!("abc %s int %d", "xyz", 5)
[04:21:00] -rusti- ~"abc xyz int 5"
[04:21:02] <Eridius> when was the last snapshot?
[04:21:10] <cmr> *shrug* ask git log
[04:21:39] <ww> rusti: fmt!("abc %s int %{u32}", "xyz", 5u32)
[04:21:40] -rusti- <anon>:5:14: 5:33 error: unknown type in conversion: {
[04:21:40] -rusti- <anon>:5          fmt!("abc %s int %{u32}", "xyz", 5u32)
[04:21:40] -rusti-                        ^~~~~~~~~~~~~~~~~~~
[04:21:41] -rusti- application terminated with error code 101
[04:21:45] <strcat> aha
[04:21:56] <strcat> ptr module uses conversion to integers to compare equality
[04:22:01] <strcat> that's a problem.
[04:22:16] <strcat> oh boy all my problems are solved (maybe)
[04:22:24] <cmr> strcat: what problems?
[04:22:32] <acrichto> rusti: format!("abc {} int {}", "xyz", 5u32)
[04:22:33] -rusti- ~"abc xyz int 5"
[04:22:36] <acrichto> ww: ^
[04:22:36] <strcat> loop vectorization not working
[04:22:39] <cmr> ah
[04:22:43] <engla> strcat: nice find!
[04:22:44] <cmr> really? it could come down to that?
[04:22:45] <hoverbear> rusti: println(int::range(0,2))
[04:22:49] <ww> did i crash the bot?
[04:22:50] -rusti- pastebinned 11 lines of output: http://ix.io/7Zn
[04:23:04] <hoverbear> Hrm.
[04:23:13] <cmr> hoverbear: println prints strings, nothing else.
[04:23:14] <ww> acrichto: thx
[04:23:20] <cmr> also int isn't in scope ever
[04:23:20] <tikue_> this is the second time this has occured while testing my PR: http://buildbot.rust-lang.org/builders/auto-bsd-64-opt/builds/1195/steps/test/logs/stdio
[04:23:21] <tikue_> :(
[04:23:27] <hoverbear> cmr: :(
[04:23:28] <cmr> you need to import it.
[04:23:36] <hoverbear> cmr: Ok.
[04:23:43] <strcat> it's funny how stupid compilers seem sometimes
[04:23:44] <tikue_> hoverbear: printfln! prints anything, but is being removed
[04:23:45] <cmr> tikue_: bsd is grumpy.
[04:23:54] <hoverbear> tikue_: Why?
[04:23:56] <tikue_> cmr: it's not me though is it?
[04:24:04] <cmr> tikue_: no
[04:24:05] <strcat> LLVM sees a pointer <-> int conversion and just gives up
[04:24:06] <tikue_> hoverbear: so that toowtdi presumably
[04:24:25] <hoverbear> Wat.
[04:24:46] *** Quits: wil (wil@moz-FDE1AC97.bootp.virginia.edu) (Ping timeout)
[04:24:47] <tikue_> cmr: wanna give me a @bors retry :3
[04:24:48] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[04:24:48] *** ChanServ sets mode: +ao dherman dherman
[04:25:00] <acrichto> tikue_: just did, sorry about that
[04:25:06] <strcat> tikue_: because repr is only for debugging
[04:25:10] <acrichto> there's a generic runtime segfault running around
[04:25:16] <strcat> it will never, ever be stable
[04:25:18] <strcat> even 5 years from now
[04:25:40] <acrichto> strcat: how do you compare pointers in llvm?
[04:25:57] <tikue_> acrichto: thanks :( is it just bad luck that i was hit twice in a row, then?
[04:26:02] <strcat> acrichto: I'm just going to add raw pointers to the binop table and hope it magically works
[04:26:05] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[04:26:05] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/tLrR0g
[04:26:05] <ghrust> 13rust/06auto 14a835995 15Tim Kuehn: Rendezvous stream for synchronous channel messaging
[04:26:05] <ghrust> 13rust/06auto 14a824a57 15bors: auto merge of #8908 : tikue/rust/master, r=anasazi...
[04:26:06] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[04:26:12] <acrichto> tikue_: yeah, sadly, it seems to be happening frequently-ish now though
[04:26:20] <cmr> we're not valgrind-clean right now
[04:26:21] <tikue_> yuck!
[04:26:23] <cmr> I imagine it's related.
[04:26:38] <strcat> acrichto: http://llvm.org/docs/LangRef.html#icmp-instruction same instruction
[04:26:43] <tikue_> my poor little patch, it's trying it's dardest
[04:26:45] <tikue_> its*
[04:26:49] <strcat> so anyway, let me add a tycat_raw_ptr and it should magically work
[04:26:51] * strcat crosses fingers
[04:26:57] <acrichto> strcat: ah cool
[04:27:21] <strcat> int<->ptr conversions are one of our biggest performance issues
[04:27:31] <benh> huh
[04:27:42] <strcat> bigger issue than that return value thing I'm busy trying to land :P
[04:27:50] <tikue_> strcat: ?
[04:28:17] *** Quits: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net) (Ping timeout)
[04:28:27] <acrichto> strcat: I just checked out your function branch, I'll see if I can poke at an executable to see what's happening
[04:28:27] <strcat> LLVM's alias analysis will just give and return MayAlias as soon as anything converts to/from an int
[04:28:42] <strcat> acrichto: only on 32-bit where there's an issue btw
[04:28:54] *** Joins: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net)
[04:29:09] <strcat> acrichto: I think what we're going to need to do is poke at test cases in runtimeless rust until we find the issue :(
[04:29:17] <strcat> I really think it's a foreign.rs bug
[04:29:23] <strcat> in how it converts to/from the rust ABI
[04:30:01] <hoverbear> :S Now I can't get range to work, feel like an idiot heh.
[04:30:25] <cmr> rusti: range(0, 1)
[04:30:26] -rusti- std::iter::Range<int>{state: 0, stop: 1, one: 1}
[04:30:29] <cmr> rusti: range(0, 5)
[04:30:31] -rusti- std::iter::Range<int>{state: 0, stop: 5, one: 1}
[04:30:44] <Luqman> r? https://github.com/mozilla/rust/pull/9134
[04:31:08] <cmr> is there any iterator adaptor that just does while i.next().is_some() { } ?
[04:31:21] <strcat> cmr: hm?
[04:31:29] <hoverbear> cmr: http://fpaste.org/38918/89602711/
[04:31:31] <tikue_> cmr: like it.exhaust() or something? 
[04:31:35] <cmr> tikue_: yeah
[04:31:44] <cmr> when you care about the side effects of the pipeline, but not the result.
[04:31:45] <strcat> cmr: well that's basically a for loop ;p
[04:32:10] <cmr> hoverbear: what version of rust are you using?
[04:32:10] <engla> cmr: advance(|_| true) will do that
[04:32:16] <hoverbear> cmr: I also tried int::range, but it said that takes 3 args.
[04:32:18] <tikue_> cmr: how about takewhile(|| true)
[04:32:19] <hoverbear> cmr: 7.1
[04:32:23] <tikue_> take_while*
[04:32:26] *** Quits: eholk (eholk@moz-F70D5031.hsd1.in.comcast.net) (Quit: eholk)
[04:32:30] <cmr> hoverbear: er, what?
[04:32:34] <tikue_> or rather takewhile(|_| true) as engla put it
[04:32:36] <engla> cmr: it's not an adaptor though :)
[04:32:44] <strcat> hoverbear: 0.7 you mean? range() didn't exist then as an iterator
[04:32:47] <cmr> engla: yeah, it wouldn't be, now that I think about it.
[04:33:00] <strcat> in 0.7 it took a closure
[04:33:05] <hoverbear> cmr: Arch's version is 7.1
[04:33:12] <hoverbear> I'll build from git.
[04:33:19] <strcat> it's 0.7-1 where -1 is the pkgrel
[04:33:20] <cmr> hoverbear: use strcat's nightly package.
[04:33:25] <tikue_> engla: it could be!
[04:33:30] <strcat> hoverbear: yeah I have a nightly repo for arch
[04:33:41] <strcat> hoverbear: the -foo at the end of arch versions is arch-specific
[04:33:46] <strcat> it's just bumped when something is rebuilt
[04:33:47] *** Quits: adu (alt@moz-BF2B1AE4.washdc.fios.verizon.net) (Quit: adu)
[04:33:50] <strcat> usually because a dep was updated
[04:33:57] <hoverbear> strcat: In the AUR?
[04:34:14] <strcat> hoverbear: http://ix.io/5qm a repo on arch's build server
[04:34:29] <strcat> as in pre-built
[04:34:34] <strcat> daily
[04:34:42] <hoverbear> strcat: I'll add it.
[04:35:10] <strcat> acrichto: seems... to work
[04:35:26] <acrichto> strcat: magically adding pointers to binops?
[04:35:31] <strcat> yes
[04:35:33] <acrichto> nice
[04:35:36] <strcat> waiting for it to explode
[04:35:44] <acrichto> do you have a before/after IR?
[04:36:32] <strcat> acrichto: I will soon ;p
[04:36:48] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[04:36:48] <strcat> acrichto: problem is that I didn't update Eq
[04:36:49] <tikue_> wat. "test tests::install_check_duplicates ... FAILED" whatâ€¦IS that? (wasn't your r+ acrichto, just another unlucky one from earlier)
[04:37:09] <strcat> should raw pointers have Ord too?
[04:37:14] <strcat> I won't add it for now
[04:37:19] <cmr> probably
[04:37:29] <strcat> well they do have Ord
[04:37:40] <strcat> but I'm not sure if I should enshrine it in the compiler
[04:37:42] <strcat> ;p
[04:37:45] * strcat will just do it
[04:37:54] <acrichto> strcat: if we already have Ord and it's faster in the compiler,seems to make sense in the compiler
[04:38:28] <acrichto> tikue_: where are the logs for that?
[04:38:55] <tikue_> acrichto: http://buildbot.rust-lang.org/builders/auto-mac-64-opt/builds/1409/steps/test/logs/stdio
[04:39:13] <ww> is BitSet supported in rust or in the stdlib?
[04:39:32] <sfackler> ww: extra::bitv
[04:39:41] <acrichto> tikue_: that's unfortunate :(
[04:39:42] <ww> oh ok
[04:40:26] <strcat> acrichto: it's pretty ridiculously bad atm
[04:40:41] <tikue_> does anyone know how to make a brew formula for rust HEAD:master
[04:40:43] <strcat> acrichto: iterators optimize incredibly well - just not the vector one ;[
[04:40:50] <strcat> acrichto: http://ix.io/7Zp sample rust
[04:41:22] <acrichto> strcat: there are multiple builders on the same physical machine, right?
[04:41:27] *** Quits: jeaye (Jeaye@moz-34FEF2BB.hsd1.ca.comcast.net) (Quit: brb)
[04:41:31] <strcat> acrichto: yes
[04:41:35] *** Joins: jeaye (Jeaye@moz-34FEF2BB.hsd1.ca.comcast.net)
[04:41:37] <strcat> acrichto: http://ix.io/7Zq the IR :(
[04:41:47] <acrichto> strcat: hmm, I wonder if everyon'e slamming /tmp and contending on it...
[04:41:59] <strcat> acrichto: the builders should really run in chroots ;[
[04:42:01] <acrichto> strcat: noooo inttoptr
[04:42:06] <strcat> acrichto: this is the old IR :)
[04:42:19] <acrichto> ooooh
[04:42:25] * acrichto sits eagerly
[04:42:51] <strcat> also 2 non-inbounds GEP...
[04:43:00] <strcat> it seems like it regressed
[04:43:05] <acrichto> where do we even generate those?
[04:43:15] <strcat> let me look at the unopt IR
[04:43:46] <strcat> acrichto: I suspect it raised inttoptr to them
[04:43:51] <acrichto> ah, ok
[04:44:15] * strcat isn't sure
[04:44:18] <benh> the old IR, so vec iterators are ''fast'' now too?
[04:44:36] <benh> or the old IR, before you started working on a change that isn't merged yet?
[04:44:47] <strcat> well vec iterators are fast, in that they do 1 ptr increment and 1 comparison per iteration
[04:45:05] <strcat> but they have very poor communication about aliasing, etc. so they don't vectorize
[04:46:01] <hoverbear> Sweeet, Euler problem 1 done in Rust \o/
[04:46:47] <zeuxcg> there's str.with_c_str and vec.as_imm_buf, is there a reason why the prefixes are different?
[04:46:56] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[04:47:31] <engla> zeuxcg: the as_* method is just a cheap conversion, much like .as_bytes
[04:48:35] <acrichto> strcat: apparently if you specify --host-triples as 32-bit you also need to specify --build-triples
[04:48:39] <strcat> acrichto: ah
[04:48:47] <engla> zeuxcg: while with_c_str does allocate to store the C string
[04:48:47] <acrichto> strcat: http://buildbot.rust-lang.org/builders/auto-mac-32-opt/builds/1389/steps/configure/logs/stdio
[04:48:59] <SingingBoyo> zuexcq: in general, as_xxx = no copies, to_xxx and with_xxx involve copying/allocating
[04:49:02] <zeuxcg> engla: I see. is there a reason why str is not null-terminated?
[04:49:05] <hoverbear> That went well: https://github.com/Hoverbear/Euler/blob/master/1.rs
[04:49:40] <strcat> zeuxcg: \0 is valid anywhere inside a unicode string
[04:49:44] <engla> zeuxcg: I guess it's simpler not to have an extra zero byte. It creates an asymmetry between ~str and string slices too
[04:49:53] <strcat> rusti: "\0\0\0"
[04:49:54] -rusti- <anon>:4:12: 4:13 error: unknown string escape: 48
[04:49:54] -rusti- <anon>:4     let r = {
[04:49:54] -rusti-                      ^
[04:49:54] -rusti- application terminated with error code 101
[04:50:00] <strcat> rusti: "\x00\x00\x00"
[04:50:01] -rusti- "\x00\x00\x00"
[04:50:07] <zeuxcg> strcat: that does not mean that the string can't be null terminated
[04:50:17] <strcat> zeuxcg: so, foo.slice(1, 2)
[04:50:23] <zeuxcg> strcat: i.e. C++ std::string generally uses a null-terminated storage
[04:50:33] <zeuxcg> but it can contain null characters
[04:50:53] <strcat> rusti: "foo\x00".slice(0, 3)
[04:50:54] -rusti- "foo"
[04:51:03] <strcat> rusti: "foo\x00".slice(0, 1)
[04:51:03] -rusti- "f"
[04:51:21] <strcat> it's a view into the string, it won't be nul-terminated
[04:51:21] <zeuxcg> engla: ah, I see.
[04:51:42] <strcat> and it means strings are no longer regular vectors, so there's a cost for that
[04:52:07] <benh> if only we used utf-16, then most of our strings would be nul-terminated after every single character!
[04:52:20] <engla> or before
[04:52:22] <cmr> heh
[04:52:31] <strcat> zeuxcg: generally the only place nul-termination is correct is for paths anyway
[04:52:32] *** Quits: aeqwa (aeqwa@moz-88A8BC36.dsl.tropolys.de) (Ping timeout)
[04:52:42] <strcat> and str isn't appropriate for paths on *nix
[04:52:53] <cmr> Or any OS I know of.
[04:53:00] <cmr> windows they're ucs2
[04:53:08] <strcat> yeah
[04:53:09] <cmr> although they might actually enforce utf16
[04:53:12] <cmr> I don't remember
[04:53:14] <strcat> cmr: they don't
[04:53:30] <cmr> I hate strings so much :(
[04:53:53] <zeuxcg> strcat: well, it's "correct" for any C interop that takes null-terminated strings :)
[04:53:59] <zeuxcg> that probably means 99% of C interops.
[04:54:11] <strcat> zeuxcg: it doesn't mean 99%
[04:54:17] <zeuxcg> but I guess I don't care that much, was just curious
[04:54:22] <benh> not if the nul-terminated string is expected to contain latin1-encoded non-ascii chars?
[04:54:22] <engla> zeuxcg: .with_c_str will helpfully assert if you have any internal zero bytes in the string
[04:54:27] <strcat> C strings can't represent all unicode strings, so it generally doesn't make sense to mix rust's str with them
[04:54:33] <strcat> you probably want ~[u8]
[04:54:39] <cmr> benh: isn't latin1 an 8-bit encoding?
[04:54:47] <strcat> (or, c_str)
[04:54:53] <benh> cmr: yeah, it is
[04:54:57] *** Quits: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Ping timeout)
[04:55:04] <strcat> acrichto: meh
[04:55:09] <strcat> acrichto: can't figure out why it makes this mess
[04:55:11] <zeuxcg> C strings can represent all unicode strings if they contain utf-8
[04:55:17] <strcat> zeuxcg: nope
[04:55:29] <zeuxcg> wait, zero is a valid codepoint?
[04:55:32] <strcat> zeuxcg: yes
[04:55:34] <zeuxcg> ugh
[04:55:35] <strcat> and \0 is the utf-8 encoding of it
[04:55:50] <strcat> there was a security breach related to this recently
[04:55:54] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[04:56:05] <strcat> due to string comparisons terminating early, in some parts of the code
[04:56:09] <engla> Unicode doesn't tell you what the codepoints mean. You are free to use it as terminator if you want to, it just can't represent anything else.
[04:56:17] <benh> foo.jpg\0.exe
[04:56:21] <benh> :(
[04:56:34] <SingingBoyo> benh: eww
[04:56:39] <strcat> well that's not a valid file path ;p
[04:56:49] <strcat> it's a valid unicode string though
[04:57:03] <benh> hm, then maybe the other way around
[04:57:42] *** Quits: tikue_ (tkuehn@FE643D5D.E2CAEE6E.689607DE.IP) (Ping timeout)
[04:57:56] *** Joins: tikue_ (tkuehn@FE643D5D.E2CAEE6E.689607DE.IP)
[04:57:56] <benh> "open blah.blah.blah.exe\0blah.blah.blah.jpg?"
[05:00:40] *** Quits: maik (maik@moz-EEB9CEBB.dip0.t-ipconnect.de) (Ping timeout)
[05:01:20] <strcat> acrichto: I forgot to actually classify ptrs as tycat_raw_pointer
[05:01:23] <strcat> heh
[05:01:24] * strcat sighs
[05:01:35] <acrichto> strcat: :(
[05:02:38] <erickt1> good evening all. Now that we got the Default trait, does anyone think we should keep Zero impls for the non-integral/float types of tuple/option/vec/bool/char/etc
[05:02:41] <erickt1> ?
[05:03:00] <strcat> well we need to define what Zero means
[05:03:06] <strcat> perhaps we shouldn't have it as a standalone trait
[05:03:21] <engla> Default was supposed to replace Zero for non-numerical types
[05:03:34] <strcat> but what makes a type numeric?
[05:03:37] <strcat> is bool/char numeric? ;p
[05:03:45] <erickt1> strcat: not anymore :)
[05:03:53] <hoverbear> What's this Some(foo_int) thing in iterators?
[05:03:53] *** Quits: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net) (Ping timeout)
[05:04:29] <strcat> hoverbear: there's an enum defined as 'enum Option<T> { None, Some(T) }'
[05:04:49] *** Quits: tikue_ (tkuehn@FE643D5D.E2CAEE6E.689607DE.IP) (Ping timeout)
[05:04:51] <strcat> the iterator just returns Some(x) until it reaches the end
[05:04:54] *** Joins: tikue_ (tkuehn@FE643D5D.E2CAEE6E.689607DE.IP)
[05:05:05] <tikue_> hoverbear: where?
[05:05:06] <engla> strcat: ok, good question. bool has an addition || operator and false is the zero.   char has no operations, but it has a codepoint called zero.
[05:05:08] <hoverbear> strcat: Ok. So how do I deal with it?
[05:05:17] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[05:05:34] <strcat> hoverbear: well at a primitive level, `match`
[05:05:36] <engla> when in doubt, it doesn't have Zero
[05:05:45] <strcat> hoverbear: or the methods defined on the Option type
[05:05:57] <strcat> but with an Iterator implementation, you likely want to use the Iterator extension methods 90% of the time
[05:06:22] <tikue_> the iterators are my favorite thing ever
[05:06:24] <tikue_> just sayin
[05:06:59] <hoverbear> http://fpaste.org/38921/62318137/
[05:07:18] <hoverbear> I'm trying to make an iterator that returns fibonnaci
[05:07:31] <engla> the iterator api is so simple, that's the cool thingi
[05:07:35] <hoverbear> It works, but it prints out Some(3)
[05:07:40] <jdm> rusti: let mut a = 0; if (a = 5) != 0 { println("hi"); }
[05:07:41] -rusti- <anon>:5:38: 5:39 error: mismatched types: expected `()` but found `<VI2>` (expected () but found integral variable)
[05:07:41] -rusti- <anon>:5          let mut a = 0; if (a = 5) != 0 { println("hi"); }
[05:07:41] -rusti-                                                ^
[05:07:42] -rusti- error: aborting due to previous error
[05:07:42] -rusti- application terminated with error code 101
[05:07:51] <jdm> rusti: let mut a = 0; if ((a = 5) != 0) { println("hi"); }
[05:07:51] -rusti- <anon>:5:39: 5:40 error: mismatched types: expected `()` but found `<VI2>` (expected () but found integral variable)
[05:07:52] -rusti- <anon>:5          let mut a = 0; if ((a = 5) != 0) { println("hi"); }
[05:07:52] -rusti-                                                 ^
[05:07:52] -rusti- error: aborting due to previous error
[05:07:52] -rusti- application terminated with error code 101
[05:08:16] <strcat> hoverbear: Iterator defines a bunch of useful default methods for you
[05:08:36] <hoverbear> strcat: Yeah, there's some really cool stuff in the docs
[05:08:37] <tikue_> hoverbear: that looks pretty good to me
[05:08:39] <strcat> for x in it.take(20) { print!("{}", x) }
[05:08:55] <hoverbear> tikue_: Right, but I want to see "3" not "Some(3)"
[05:09:14] <tikue_> hoverbear: then use x.nth(0)
[05:09:20] <tikue_> hoverbear: instead of next
[05:09:29] *** Joins: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net)
[05:09:30] <tikue_> oh wait that's option as well
[05:09:32] <erickt1> strcat / engla: I'm okay with bool/char having a zero
[05:09:36] <tikue_> hoverbear: use next().unwrap()
[05:09:45] <hoverbear> tikue_: Oooo ok unwrap sounds like what I want.
[05:09:54] <engla> erickt1: when in doubt, it shouldn't have Zero. It can have default
[05:09:55] <hoverbear> Awesome
[05:09:57] <erickt1> strcat / engla: does it make sense for bool/char to implement Default?
[05:10:01] <hoverbear> tikue_:  cmr: Thanks!
[05:10:05] <strcat> erickt1: no
[05:10:07] *** Joins: nano (nano@moz-74CAD1CA.superkabel.de)
[05:10:11] <strcat> not imo at least
[05:10:19] <strcat> I am not sure Default is really a good idea...
[05:10:36] <engla> IMO they should have Default. The idea was to replace Zero for initialization
[05:10:41] <erickt1> strcat: well, if Option's default is None, that is roughly equivalent to false
[05:11:02] <erickt1> but does it make sense for a char \0 to be the default?
[05:11:05] * strcat doesn't really find that to make sense :(
[05:11:05] <engla> Defaults don't have to make sense 100% of the time, it's some kind of "POD initalization"
[05:11:25] <strcat> so why not true, and a unicode snowman?
[05:11:33] <strcat> :s
[05:11:45] <erickt1> oh man, it'd be great if char's default was the snowman
[05:12:00] <tikue_> why does range_inclusive() have its own struct rather than just using Range
[05:12:10] <strcat> tikue_: because Range can't do that
[05:12:26] <tikue_> strcat: why?
[05:12:35] <erickt1> I wonder what c++/java/etc do for a default char
[05:12:36] <strcat> rusti: range(250u8, 254).to_owned_vec()
[05:12:37] -rusti- ~[250u8, 251u8, 252u8, 253u8]
[05:12:40] <strcat> rusti: range(250u8, 255).to_owned_vec()
[05:12:40] -rusti- ~[250u8, 251u8, 252u8, 253u8, 254u8]
[05:12:46] <strcat> rusti: range(250u8, 256).to_owned_vec()
[05:12:47] -rusti- ~[]
[05:12:47] *** Joins: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net)
[05:12:55] <strcat> rusti: std::iter::range_inclusive(250u8, 256).to_owned_vec()
[05:12:57] -rusti- ~[0u8]
[05:13:04] <strcat> rusti: std::iter::range_inclusive(250u8, 255).to_owned_vec()
[05:13:05] -rusti- ~[250u8, 251u8, 252u8, 253u8, 254u8, 255u8]
[05:13:05] <acrichto> oh bsd is dying b/c of a fail in a drop in dynamic_lib
[05:13:09] *** Quits: nano (nano@moz-74CAD1CA.superkabel.de) (Quit: nano)
[05:13:24] *** Joins: nano (nano@moz-74CAD1CA.superkabel.de)
[05:13:31] <strcat> tikue_: if you want [x, .. max_value]
[05:13:40] <myname> strcat: what is the difference between these two lines?
[05:13:51] <myname> ah
[05:13:52] <erickt1> zeuxcg: my long term hope is to rename as_ fns that take a closure to with_ 
[05:13:55] <myname> nevermind
[05:14:01] <tikue_> strcat: didn't even think about that edge case
[05:14:04] <strcat> myname: I messed up and did a bunch of intermediate stuff ;p
[05:14:12] <myname> you did
[05:14:45] <strcat> acrichto: so, it worked
[05:14:51] <strcat> but I am not sure this is in any way useful
[05:15:00] <strcat> it's a tiny patch though and consistent with the other primitives...
[05:15:23] <tikue_> so the only time to use range_inclusive is when you need max value
[05:15:34] <tikue_> so why not just make it called range_max
[05:15:38] <tikue_> :P
[05:15:40] <tikue_> with one argument
[05:15:46] <acrichto> strcat: the optimizations didn't kick in?
[05:15:54] <strcat> tikue_: because you have to do it when you want an inclusive range, and don't know what the end value is
[05:15:57] <myname> tikue_: you may not know if iit is max value
[05:16:04] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[05:16:04] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14a824a57 to 146216661: 02http://git.io/N3iJvQ
[05:16:04] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[05:16:05] <strcat> range(0, x + 1) is wrong when x is the max value
[05:16:06] <tikue_> good point O_O
[05:16:06] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[05:16:06] <ghrust> 01[13rust01] 15bors pushed 5 new commits to 06auto: 02http://git.io/vV4Ffg
[05:16:06] <ghrust> 13rust/06auto 1421ce41d 15Huon Wilson: extra: use a mutex to wrap linenoise calls and make them threadsafe....
[05:16:06] <ghrust> 13rust/06auto 14fe03d82 15Huon Wilson: extra: stop rl from leaking each line that is read.
[05:16:06] <ghrust> 13rust/06auto 144ed5fcb 15Huon Wilson: extra: improvements & bug fixes to rl....
[05:16:08] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[05:16:16] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[05:16:19] <strcat> it's just supposed to make you write more fixnum friendly code
[05:16:24] <engla> rusti: 0_0
[05:16:25] -rusti- 0
[05:16:28] *** Joins: jaen (jaen@moz-3203F617.play-internet.pl)
[05:16:36] <strcat> rusti: 
[05:16:36] -rusti- ()
[05:16:50] <myname> huh?
[05:16:56] <strcat> rust allows _ in numbers
[05:16:58] <myname> what's with that _0?
[05:17:00] <strcat> rusti: 1_000_000
[05:17:01] -rusti- 1000000
[05:17:02] <tikue_> acrichto: it failed again. could this really be such a coincidence?
[05:17:05] <myname> oh
[05:17:14] <engla> no, rustc understands emoticons
[05:17:30] <myname> rusti: :)
[05:17:31] -rusti- <anon>:5:10: 5:11 error: incorrect close delimiter: `)`
[05:17:31] -rusti- <anon>:5          :)
[05:17:31] -rusti-                    ^
[05:17:31] -rusti- application terminated with error code 101
[05:17:35] <myname> engla: liar
[05:17:35] <strcat> acrichto: yes it sucks just as much
[05:17:51] <strcat> myname: your emoticon is just a bit wrong
[05:17:56] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[05:17:56] <acrichto> tikue_: yeah sadly I think that it is :(, although it looks like it may have pinpointed the test in question
[05:17:59] <myname> :(
[05:18:01] <acrichto> strcat: what? how? :(
[05:18:09] <strcat> acrichto: no idea
[05:18:23] * strcat tries with monomorphic collapse off
[05:18:33] <acrichto> strcat: does the unoptimized IR look better than before? (no ptrtoint)
[05:18:40] <strcat> acrichto: yes
[05:18:43] <tikue_> acrichto: try again? orâ€¦ i dunno
[05:18:54] *** Quits: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net) (Ping timeout)
[05:18:55] <myname> so one may write 1_0000_0000_0000 to completely confuse readers of code?
[05:18:57] <acrichto> tikue_: yeah I'll kick it
[05:19:00] <strcat> myname: yes
[05:19:07] <myname> great feature
[05:19:08] <tikue_> acrichto: thanks, i appreciate it
[05:19:08] <strcat> myname: you could also use 'x' as your only variable name
[05:19:14] <jdm> rusti: let a: *int = 0 as *int; a.is_not_null() as int
[05:19:15] -rusti- 0
[05:19:19] <tikue_> strcat: what if you need two variables
[05:19:20] <myname> strcat: huh?
[05:19:27] <strcat> tikue_: that's fine
[05:19:33] <engla> myname: some languages like to divide by 10,000nds
[05:19:46] <eevee> tikue_: that's what tuples are for
[05:19:48] <strcat> rusti: let x = 5; { let x = 2; print!("{}", x) } print!("{}", x)
[05:19:49] -rusti- 25()
[05:19:55] <strcat> rusti: let x = 5; { let x = 2; println!("{}", x) } println!("{}", x)
[05:19:56] -rusti- 2
[05:19:56] -rusti- 5
[05:19:56] -rusti- ()
[05:20:08] <strcat> eevee: pfft, tuples
[05:20:09] *** Quits: jaen (jaen@moz-3203F617.play-internet.pl) (Ping timeout)
[05:20:19] <strcat> rusti: let x = (0, 5); let (x, x) = x; x + x
[05:20:20] -rusti- <anon>:5:30: 5:31 warning: unused variable: `x` [-W unused-variable (default)]
[05:20:20] -rusti- <anon>:5          let x = (0, 5); let (x, x) = x; x + x
[05:20:21] -rusti-                                        ^
[05:20:21] -rusti- 10
[05:20:21] <hoverbear> Can I have loop break's in a match?
[05:20:22] <tikue_> eevee: tuple with all your variables?
[05:20:24] *** Joins: jaen (jaen@moz-3203F617.play-internet.pl)
[05:20:28] <myname> strcat: and now do multiplication
[05:20:34] <tikue_> strcat: what
[05:20:52] <tikue_> why is that allowed!
[05:20:53] <strcat> rusti: let x = [1, 2, 3]; let x = x.iter(); for x in x { print!("{}", x) }
[05:21:00] *** Joins: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net)
[05:21:07] <strcat> ugh ix.io
[05:21:13] -rusti- pastebinned 8 lines of output: http://ix.io/7Zr
[05:21:15] * strcat should switch back to sprunge
[05:21:17] <strcat> rusti: let x = [1, 2, 3]; let mut x = x.iter(); for x in x { print!("{}", x) }
[05:21:20] -rusti- pastebinned 8 lines of output: http://ix.io/7Zs
[05:21:20] <myname> tiffany: {} is a new scope
[05:21:25] <myname> damn
[05:21:29] <hoverbear> http://dpaste.com/1376420/ <--- Can I do that on line 20?
[05:21:31] <tikue_> rusti: let x = [1, 2, 3]; let x = x.iter(); for &x in x { print!("{}", x) }
[05:21:32] -rusti- <anon>:5:46: 6:5 error: cannot borrow immutable local variable as mutable
[05:21:32] -rusti- <anon>:5          let x = [1, 2, 3]; let x = x.iter(); for &x in x { print!("{}", x) }
[05:21:32] -rusti- <anon>:6     };
[05:21:32] -rusti- error: aborting due to previous error
[05:21:33] -rusti- application terminated with error code 101
[05:21:34] <myname> tikue_: {} is a new scope
[05:21:35] <strcat> rusti: let x = [1, 2, 3]; let mut x = x.iter(); for x in x { print!("{}", *x) }
[05:21:36] -rusti- 123()
[05:21:40] <strcat> rusti: let x = [1, 2, 3]; let mut x = x.iter(); for x in x { println!("{}", *x) }
[05:21:41] -rusti- 1
[05:21:41] -rusti- 2
[05:21:41] -rusti- 3
[05:21:41] -rusti- ()
[05:21:44] <strcat> ^ beautiful code
[05:21:52] *** Joins: clements (clements@moz-BEE8D50A.dsl.snlo01.pacbell.net)
[05:22:01] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[05:22:06] <myname> i disagree
[05:22:12] <strcat> if you need a 2nd variablre
[05:22:21] <strcat> rusti: let x = 5; let x = ("foo", x); x
[05:22:21] -rusti- ("foo", 5)
[05:22:26] <clements> erickt: got time for another small pull request review?
[05:22:55] <erickt1> clements: unfortunately I'm just about to go to bed
[05:23:06] <clements> erickt: np, thanks. Me too :)
[05:23:30] <myname> rusti: let x = [1,2,3]; let mut x = x.iter(); for x in x { x = x * *x; print!("{}"m*x) }
[05:23:31] -rusti- <std-macros>:267:43: 267:61 error: expected token: `,`
[05:23:31] -rusti- <std-macros>:267         ($($arg:tt)+) => (::std::io::print(format!($($arg)+)))
[05:23:31] -rusti-                                                             ^~~~~~~~~~~~~~~~~~
[05:23:31] -rusti- error: aborting due to previous error
[05:23:32] -rusti- application terminated with error code 101
[05:23:43] <myname> rusti: let x = [1,2,3]; let mut x = x.iter(); for x in x { x = x * *x; print!("{}",*x) }
[05:23:45] -rusti- pastebinned 38 lines of output: http://ix.io/7Zt
[05:23:49] <myname> :(
[05:23:54] *** Quits: pudgetta (Mibbit@moz-98DDA60.border.net.adelaide.edu.au) (Quit: http://www.mibbit.com ajax IRC Client)
[05:24:22] <erickt1> kimundi: r? https://github.com/mozilla/rust/pull/9115
[05:24:50] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[05:24:52] <erickt1> clements: r+ed anyway
[05:24:53] <erickt1> :)
[05:25:02] <clements> erickt: wow! thanks!
[05:25:06] *** Quits: jaen (jaen@moz-3203F617.play-internet.pl) (Ping timeout)
[05:25:08] <erickt1> it was short :)
[05:25:15] <clements> erickt: yes, it was.
[05:26:05] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[05:26:05] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14c3a3dbd to 146216661: 02http://git.io/N3iJvQ
[05:26:05] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[05:26:06] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[05:26:06] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/coXSxw
[05:26:06] <ghrust> 13rust/06auto 14a835995 15Tim Kuehn: Rendezvous stream for synchronous channel messaging
[05:26:06] <ghrust> 13rust/06auto 1409bf1c6 15bors: auto merge of #8908 : tikue/rust/master, r=anasazi...
[05:26:07] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[05:26:37] <strcat> acrichto: oh well sending a little PR anyway
[05:26:37] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[05:26:44] *** Quits: mark_edward (quassel@moz-97E995A.hsd1.in.comcast.net) (Ping timeout)
[05:26:47] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[05:27:14] *** Joins: mark_edward (quassel@moz-97E995A.hsd1.in.comcast.net)
[05:29:48] *** Quits: nano (nano@moz-74CAD1CA.superkabel.de) (Connection reset by peer)
[05:30:08] <myname> rusti: let x = 5; let x = ("foo", x); let (x, _) = x; x
[05:30:08] -rusti- "foo"
[05:30:12] <myname> hahaha
[05:30:36] <myname> but you'll need at least a second var to save that tuple
[05:31:01] <strcat> myname: you can just use scopes
[05:31:03] <strcat> ;p
[05:31:07] <myname> ah!
[05:31:11] <strcat> only unpack in a scope
[05:31:14] <tikue_> rusti: let x = 5; let x = ("foo", x); x.first()
[05:31:14] -rusti- "foo"
[05:31:18] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[05:31:30] *** Quits: buptor (Mibbit@F7E2F3F.17A0D1EC.B7830B68.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[05:31:34] <strcat> first is written without this convention though, it's cheating ;p
[05:31:44] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[05:31:46] <strcat> (ofc you could write it this way...)
[05:32:04] <hoverbear> tikue_: Yup, I'm a fan of iterators: https://github.com/Hoverbear/Euler/blob/master/2.rs
[05:32:05] <tikue_> strcat: what is the convention i broke
[05:32:07] <myname> rusti: let x = 5; let x = ("foo", x); { let (x, _) = x; print!("{}",x); } { let(_, x) = x; print!("{}",x); }
[05:32:07] *** Quits: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[05:32:07] -rusti- foo5()
[05:32:59] *** Quits: ChrisMorgan (chris@moz-3ECEFC27.its.monash.edu.au) (Ping timeout)
[05:33:33] <strcat> acrichto: heh it actually hit an issue this time.
[05:33:59] <strcat> oh right
[05:34:02] <strcat> infinite recursion
[05:34:11] <myname> rusti: let x = (1, 2, 3); let (x, _) = x; x
[05:34:19] -rusti- pastebinned 5 lines of output: http://ix.io/7Zu
[05:34:50] <strcat> in those stage0 Eq/Ord impls
[05:35:13] <strcat> acrichto: https://github.com/mozilla/rust/pull/9136 r? fairly pointless but still a minor improvement ;p
[05:35:25] <tikue_> hoverbear: there's a trait called AdditiveIterator
[05:35:28] * strcat investigates the real issue more
[05:35:29] <tikue_> you might find it useful
[05:36:16] <tikue_> hoverbear: also you could make FibStream an infinite iterator and then use take_while to get the ones up to 4_000_000
[05:36:17] <acrichto> strcat: this doesn't remove the impl of Eq in std::ptr?
[05:36:22] <hoverbear> tikue_: Ooo interesting. I still need to figure out traits. I was reading about Rust today and wanted to take a quick dive. It seems to be what I want. I'll keep playing, very impressed with it over C.
[05:36:32] <tikue_> hoverbear: yes, I love rust :')
[05:36:37] <strcat> acrichto: no, it still needs the impl of Eq - after a snapshot it can stop using casts in it
[05:36:37] <tikue_> and rust loves me
[05:36:52] <hoverbear> tikue_: I'm currently debating between it, Go, and Nimrod. :-P
[05:36:56] *** Quits: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net) (Ping timeout)
[05:37:16] <strcat> hoverbear: you could use filter + sum
[05:37:36] <tikue_> strcat: you have to implement additiveiterator for sum right
[05:37:42] <strcat> no
[05:37:48] <hoverbear> strcat: You know, I'm realizing now that you said filter/reduce didn't work in vectors, not iterators.
[05:37:49] <strcat> it's a generic impl
[05:37:56] <acrichto> strcat: could you #[cfg(stage0)] that? Also wouldn't that account for why a speedup wasn't seen?
[05:38:12] <acrichto> strcat: also, does this actuallye arn us better IR?
[05:38:31] <strcat> acrichto: yes, it will generate icmp instead of a fn call to Eq
[05:38:51] <strcat> only nopt IR...
[05:38:54] <acrichto> strcat: and it still doesn't do loop vectorization?
[05:39:00] <strcat> acrichto: it's not really an optimization, just a consistency improvement
[05:39:09] <myname> is rust actually self hosted?
[05:39:16] *** Quits: tikue_ (tkuehn@FE643D5D.E2CAEE6E.689607DE.IP) (Ping timeout)
[05:39:17] <jdm> myname: yep
[05:39:34] *** Joins: tikue_ (tkuehn@FE643D5D.E2CAEE6E.689607DE.IP)
[05:39:42] <strcat> hoverbear: http://seld.be/rustdoc/master/std/iterator/trait.Iterator.html all of those methods are implemented for you on the iterator you made
[05:39:44] <myname> interesting considering you are still changing the syntax here and there
[05:39:49] <strcat> rusti: range(0, 10).to_owned_vec()
[05:39:50] -rusti- ~[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[05:39:55] <strcat> rusti: range(0, 10).sum()
[05:39:55] -rusti- <anon>:5:9: 6:5 error: type `std::iter::Range<int>` does not implement any method in scope named `sum`
[05:39:55] -rusti- <anon>:5          range(0, 10).sum()
[05:39:55] -rusti- <anon>:6     };
[05:39:55] -rusti- error: aborting due to previous error
[05:39:56] -rusti- application terminated with error code 101
[05:39:57] <acrichto> strcat: hmm, I'm curious why it doesn't improve, but I'd r+ with stage0 gates
[05:40:07] <hoverbear> strcat: So cool.
[05:40:17] <strcat> rusti: use std::iter::AdditiveIterator; range(0, 10).sum()
[05:40:18] -rusti- 45
[05:40:35] <strcat> rusti: use std::iter::AdditiveIterator; range(0, 10).filter(|x| x & 1 == 0).sum()
[05:40:36] -rusti- 20
[05:41:23] *** Quits: tikue_ (tkuehn@FE643D5D.E2CAEE6E.689607DE.IP) (Ping timeout)
[05:41:26] <strcat> acrichto: sec
[05:41:39] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[05:41:53] <strcat> acrichto: it's kind of pointless to actually change Eq but I guess I might as well
[05:42:02] <strcat> because it will only be inlined with -O
[05:42:22] *** Joins: tikue_ (tkuehn@FE643D5D.E2CAEE6E.689607DE.IP)
[05:42:33] <tikue_> strcat: could AdditiveIterator's sum fn have a default method
[05:42:42] <strcat> tikue_: no, it's a generic impl
[05:43:29] <strcat> sum() is implemented on any Iterator<A> with A: Add<A, A> + Zero
[05:43:48] <myname> rusti: let y = (3,4); let (x,_) = x; x = x + 1; x
[05:43:49] -rusti- <anon>:5:36: 5:37 error: unresolved name `x`. Did you mean `y`?
[05:43:49] -rusti- <anon>:5          let y = (3,4); let (x,_) = x; x = x + 1; x
[05:43:49] -rusti-                                              ^
[05:43:49] -rusti- error: aborting due to previous error
[05:43:49] -rusti- application terminated with error code 101
[05:43:54] <strcat> default methods only work when you're adding methods only depending on the other methods in the trait, or traits it inherits from
[05:44:03] <myname> rusti: let y = (3,4); let (x,_) = y; x = x + 1; x
[05:44:07] -rusti- pastebinned 8 lines of output: http://ix.io/7Zv
[05:44:14] <myname> hmm
[05:44:36] <tikue_> hoverbear: my take on your fib: https://gist.github.com/tikue/f2fb2119b39ff824093d
[05:45:56] <hoverbear> tikue_: I like it. Those are lambdas ya?
[05:45:58] <acrichto> strcat: hm, I found the instruction that segfaults with your sret patch
[05:46:03] <cmr> error: internal compiler error: encode_symbol: id not found 15440
[05:46:07] <tikue_> hoverbear: yep
[05:46:08] <cmr> How do I manage to break everything I touch :(
[05:46:17] <strcat> acrichto: a function ptr deref, right?
[05:46:26] <strcat> well, what happens before it
[05:46:42] <acrichto> strcat: well I'm not sure it'll help much
[05:46:43] <hoverbear> tikue_: Why don't you need the mutable on x?
[05:46:53] <acrichto> it's when returning from local::Local for Task::borrow
[05:46:55] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Client exited)
[05:47:12] <tikue_> hoverbear: because the methods take self by value
[05:47:21] <tikue_> hoverbear: take_while moves the iterator into the method call
[05:47:25] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[05:47:31] <hoverbear> Ok.
[05:47:36] <tikue_> hoverbear: at which point mutability is determined by the method instead of the caller
[05:47:54] <tikue_> it allows for easy chaining of iterator methods
[05:47:55] *** Joins: bheylin_ (brianheyli@moz-8255E94E.adsl.online.nl)
[05:48:26] *** Joins: ross (ross@moz-5EA04060.br.br.cox.net)
[05:49:05] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[05:50:42] <hoverbear> tikue_: Ok. And why do you use &4_000_000 instead of 4_000_000 ? Why would you want the pointer?
[05:51:18] <tikue_> hoverbear: check the gist again, i changed that
[05:51:22] <tikue_> short answer is you wouldn
[05:51:24] <tikue_> wouldn't
[05:51:42] <strcat> acrichto: I can't figure out where it goes wrong though
[05:52:11] <strcat> it seems like right after it spawns the thread and jumps into the function ptr - right?
[05:52:20] <acrichto> strcat: it gets pretty far after spawning
[05:52:24] <acrichto> makes it all the way to annihilation
[05:52:28] <hoverbear> tikue_: Interesting. I'm getting something about Filter not implementing any methods named `sum`
[05:52:28] <strcat> ah
[05:52:37] <acrichto> strcat: this is for "fn main() {}"
[05:52:41] <tikue_> hoverbear: take_while's closure takes a borrowed pointer to the value, so the compiler didn't want me comparing &uint against uint. but you can pattern match away the & by either doing |&i| i < 40000000 or |i| *i < 400000
[05:52:49] <tikue_> hoverbear: you need to import AdditiveIterator
[05:52:57] <tikue_> `use std::iter::AdditiveIterator;`
[05:52:59] <hoverbear> Oh  see
[05:53:04] <hoverbear> tikue_: Cool, thanks!
[05:53:26] <strcat> trait methods are available if the trait is in scope
[05:53:32] <strcat> there are just a lot of traits in scope by default
[05:53:35] <tikue_> no prob! the reason it needs to be imported is because sum() is implemented for the trait AdditiveIterator, so it's not in scope unless the trait is in scope
[05:53:47] <tikue_> and strcat beat me to the punch line
[05:54:04] *** Quits: bheylin_ (brianheyli@moz-8255E94E.adsl.online.nl) (Quit: bheylin_)
[05:54:21] <hoverbear> I need to learn about that stuff still. :) Ideally I want to use this to do some socket stuff. Is there a module for that?
[05:54:26] <strcat> cats are quick, especially when they live dangerously and do no bounds checking
[05:54:36] <tikue_> lol
[05:54:39] <hoverbear> Hah
[05:55:35] <tikue_> hoverbear: i'll have to refer you to someone else for socket stuff. I haven't used rust with sockets yet -- though i've done tcp stuff, which is pretty well supported at this point
[05:55:51] <hoverbear> tikue_: TCP would be totally fine.
[05:56:00] <hoverbear> Coming from JS/Coffee-script it's super weird using something like Rust heh.
[05:56:13] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Quit: leaving)
[05:56:18] <tikue_> hoverbear: a friend of mine wrote an echo server you could check out
[05:56:30] <tikue_> aptly titled "learnrust" lol
[05:56:30] <hoverbear> tikue_: I'd love to see it
[05:56:54] <tikue_> https://github.com/shaladdle/learnrust
[05:56:56] <tikue_> hoverbear: ^
[05:57:04] <hoverbear> tikue_: I'm taking a Networking class (and an OS class) and I'd love to be able to tell my Proffs that I want to do my assignments in rust haha
[05:57:11] *** Joins: valenting (Thunderbir@7658A01E.84D5EFD5.FB866788.IP)
[05:57:11] <acrichto> strcat: yeah I dunno :(
[05:57:16] <myname> great, i'll have a look at it later
[05:57:22] <hoverbear> tikue_: Thanks! I'm looking now :)
[05:57:39] *** Joins: leaper (Mibbit@338DE5BC.4166765B.485A6DF.IP)
[05:57:50] *** Quits: leaper (Mibbit@338DE5BC.4166765B.485A6DF.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[05:58:13] *** Joins: kseo (kseo@338DE5BC.4166765B.485A6DF.IP)
[05:58:19] <tikue_> hoverbear: ooh awesome! you could check out the OS class being taught in rust right now at UVA. there's a piazza page with some rust discussion as well
[05:58:36] <tikue_> hoverbear: https://piazza.com/class/hiuvlqlyk4925d
[05:59:04] <tikue_> and http://www.cs.virginia.edu/~evans/cs4414/
[05:59:12] <strcat> acrichto: https://github.com/mozilla/rust/pull/9136 r?
[05:59:14] <myname> how comes people actually do that
[05:59:18] <hoverbear> tikue_: Super cool
[05:59:25] <strcat> acrichto: also put the reasoning in the commit msg ;p
[06:01:19] <sfackler> strcat: any idea why binary operations are defined on bottom?
[06:01:48] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[06:01:50] <strcat> sfackler: not really.
[06:01:53] <strcat> it's fine though
[06:01:57] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[06:02:07] <strcat> rusti: fn bar() { fail!() + fail!() }
[06:02:07] -rusti- <anon>:5:28: 5:29 error: unexpected token: `+`
[06:02:07] -rusti- <anon>:5          fn bar() { fail!() + fail!() }
[06:02:08] -rusti-                                      ^
[06:02:08] -rusti- application terminated with error code 101
[06:02:15] <strcat> er
[06:02:34] <strcat> rusti: fn foo() -> ! { fail!() } fn bar() { foo() + foo() }
[06:02:35] -rusti- ()
[06:02:42] <strcat> I don't know why.
[06:02:44] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[06:02:46] <sfackler> i guess you'll never actually end up evaluating the op, but it still seems kind of bizzare
[06:02:55] <strcat> yeah it's a no-op
[06:02:59] <strcat> since you can't get to it
[06:03:17] <tikue_> hmmm, it seems that cs4414 isn't aware of the upcoming rustdocs overhaul
[06:03:26] <acrichto> hmm, apparently bsd is calling dlopen on /dev/null and not returning error
[06:03:34] <tikue_> someone should inform them before one of the go getters decides to do it themselves
[06:03:47] <strcat> tikue_: they use 0.7 though
[06:03:56] <tikue_> strcat: but it wouldn't be worth writing documentation for that anyway :P
[06:04:33] <hoverbear> tikue_: A lot of people complaining about Rust on the cs.virginia.edu page haha
[06:04:50] <cmr> hoverbear: I don't blame them!
[06:05:04] <hoverbear> cmr: Nor do I.
[06:05:16] <tikue_> hoverbear: it's a hard language to learn, and I can imagine it is frustrating to have to grapple that with OS concepts concurrently
[06:05:25] <hoverbear> Yeah totally.
[06:05:30] <tikue_> i think working on 0.7 would be no fun as well
[06:05:40] <cmr> Plus the reference implementation isn't all that great yet.
[06:05:42] <hoverbear> I find C really really dirty and a pita to work with
[06:05:50] <tikue_> it took me about a week working full-time on servo to grock the basics of rust.
[06:06:11] <hoverbear> tikue_: :)
[06:06:42] <tikue_> three and a half months later and I'd say I rarely encounter issues I don't know how to fix
[06:06:45] <tikue_> but speaking of which...
[06:07:00] <tikue_> anyone wanna take a look at this? https://gist.github.com/tikue/acbb7ac6578c244c3cac
[06:07:08] <tikue_> no idea what causes the ICE 
[06:07:12] <hoverbear> tikue_: Has Rust taught you anything about new Paradigms and strategies about programming?
[06:07:46] <tikue_> hoverbear: i definitely think very differently about problems than i used to. the safety provided by the compiler has been incredibly eye-opening
[06:08:11] <acrichto> bblum: ping
[06:08:15] <tikue_> hoverbear: multi-threading in most languages is very different from rust's actor model, the preferred parallel idiom
[06:08:21] <cmr> tikue_: what message is the task failing with?
[06:08:50] <cmr> Oh that's not the error.
[06:09:02] <tikue_> cmr: it ICE's
[06:09:14] <hoverbear> tikue_: These are all things I'm really interested in using. in JS we get one async thread (plus workings, but you don't always get them) and the worst type system evar with a unhelpful compiler.
[06:09:21] <hoverbear> Wait no, interpreter
[06:10:26] <strcat> tikue_: but yeah, someone should metion seld.be to them
[06:10:26] *** Quits: valenting (Thunderbir@7658A01E.84D5EFD5.FB866788.IP) (Ping timeout)
[06:10:29] <strcat> mention*
[06:10:42] <cmr> I'm working as fast as I can to upstream rustdoc_ng
[06:10:43] <tikue_> strcat: agree
[06:10:44] *** Quits: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net) (Ping timeout)
[06:10:59] <cmr> but I'm encountering extremely frustrating metadata bugs
[06:11:02] <strcat> cmr: you'll need a time travel machine to fix this problem though
[06:11:05] <strcat> so don't worry
[06:11:08] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[06:11:09] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1409bf1c6 to 146216661: 02http://git.io/N3iJvQ
[06:11:09] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[06:11:09] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[06:11:09] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/796ALA
[06:11:09] <ghrust> 13rust/06auto 14412ab49 15Steven Fackler: Don't fail in TcpStream.flush
[06:11:09] <ghrust> 13rust/06auto 1403ca1be 15bors: auto merge of #9114 : sfackler/rust/flush-fix, r=brson
[06:11:09] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[06:11:29] <cmr> well, yes.
[06:11:34] *** Joins: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net)
[06:11:34] <cmr> but I'd like it to be in for 0.8
[06:12:47] <hoverbear> Night all, thanks for the fun hacking!
[06:13:29] *** Quits: hoverbear (andrew@moz-86FCBF4B.gv.shawcable.net) (Quit: hoverbear)
[06:15:49] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[06:16:26] *** Quits: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP) (Ping timeout)
[06:16:36] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[06:16:41] <tikue_> argh acrichto it failed again :( maybe I should just wait til this problem is fixed?
[06:16:57] <tikue_> i'm losing hope lol
[06:17:04] <acrichto> tikue_: I've got a "fix" for the bsd issue, afterward I'm going to investigate fileinput issues
[06:17:10] <acrichto> in the meantime I'll just retry again
[06:17:29] <tikue_> acrichto: heh why is fix in quotes
[06:18:10] <acrichto> tikue_: https://github.com/mozilla/rust/issues/9137
[06:18:16] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[06:18:25] <acrichto> I'm fairly certain that this is the problem, but not 100% sure
[06:18:29] <acrichto> but the "fix" is just disabling the tests
[06:18:39] *** Joins: beatgammit (Mibbit@moz-683D0BC4.slkc.qwest.net)
[06:18:39] <acrichto> strcat: r? https://github.com/mozilla/rust/pull/9138
[06:18:49] <tikue_> oh i see
[06:18:51] <acrichto> preferably with a p=N b/c bouncing is bad
[06:24:36] <sfackler> is the bsd bot the only one that runs those tests? it's weird that it'd be the only one breaking
[06:25:07] <acrichto> sfackler: it may just be the only one with that unfortunate interleaving
[06:25:35] <acrichto> maybe bsd does some predictable kernel scheduling when you call dlopen
[06:25:38] <acrichto> dunno...
[06:25:59] <acrichto> what is wrong with these fileinput tests...
[06:26:24] <acrichto> I really wish rust could capture a test's stdout and print it at the end
[06:26:27] <acrichto> that would be *so* much nicer
[06:28:18] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[06:29:42] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[06:29:55] <SingingBoyo> acrichto:  not familiar with the test running framework, but why isn't that possible?  or is it just unimplemented?
[06:30:23] <acrichto> SingingBoyo: rust basically doesn't have a way to manipulate stdio on a per-task level
[06:30:28] <acrichto> at least not right now...
[06:30:33] <acrichto> mostly unimplemented
[06:31:38] *** Joins: victorporof (victorporo@FBDAE982.F9BD9D78.9B1E38F4.IP)
[06:33:19] *** flaper87|afk is now known as flaper87
[06:37:05] *** Joins: pyrac (pyrac@3907364F.73C89388.AD05C589.IP)
[06:37:15] <beatgammit> I'm getting "unresolved name, vec::remove()", but it seems to be documented online. I'm running rust 0.7. Is this unimplemented in 0.7?
[06:38:50] <bjz_> jld: ping
[06:39:17] <beatgammit> I'm compiling HEAD now to check
[06:40:20] <bjz_> beatgammit: use git master
[06:40:35] <bjz_> beatgammit: 0.7 is way way way out of date
[06:41:01] <bjz_> beatgammit: rust moves swiftly so you always want the latest
[06:41:32] <beatgammit> alright, will do
[06:41:43] <klutzy> beatgammit: there seems no vec::remove on either 0.7 or master
[06:41:47] <bjz_> beatgammit: are you new to Rust?
[06:41:52] <beatgammit> yes, pretty new
[06:42:04] <klutzy> beatgammit: maybe you want method
[06:42:06] <beatgammit> this is what I'm looking at: http://static.rust-lang.org/doc/core/vec.html#function-pop
[06:42:17] <bjz_> the is OwnedVector::remove
[06:42:18] <klutzy> ah, core!
[06:42:22] <bjz_> oh ok
[06:42:25] <klutzy> core is pre-0.7
[06:42:37] <klutzy> we haven't swapped the old docs :(
[06:42:37] <beatgammit> hmm.... ok, where are up-to-date docs?
[06:42:38] <engla> get the documentation links from http://www.rust-lang.org/ on the left
[06:42:51] <bjz_> rusti: let mut v = ~[1, 2, 3]; v.pop(); v
[06:42:52] -rusti- ~[1, 2]
[06:43:01] <bjz_> beatgammit: ^
[06:43:15] <klutzy> I think we should remove them. it also confused me before
[06:43:21] <bjz_> rusti: let mut v = ~[1, 2, 3]; (v.pop(), v)
[06:43:22] -rusti- (3, ~[1, 2])
[06:43:26] <klutzy> since google suggested it
[06:43:32] <beatgammit> awesome. I thought something was wrong
[06:43:50] <bjz_> klutzy: remove is at position i
[06:44:07] <bjz_> rusti: let mut v = ~[1, 2, 3]; (v.remove(1), v)
[06:44:08] -rusti- (2, ~[1, 3])
[06:44:15] *** Joins: sk (sk@61A494B3.BA40E8A.AAC02D62.IP)
[06:44:21] <bjz_> klutzy: ohhh, you mean remove the old docs
[06:44:23] <klutzy> bjz_: I meant we have to rm www_root/doc/core/*
[06:44:25] <klutzy> yep :)
[06:44:28] <bjz_> heh
[06:44:36] <beatgammit> I was wondering why remove et al were functions instead of methods...
[06:44:40] <klutzy> I don't know who is webmaster though :p
[06:45:14] <bjz_> beatgammit: yeah, vec and str were cleaned up tons during this cycle
[06:45:15] <klutzy> beatgammit: a lot of functions were moved to methods, even after 0.7
[06:45:27] *** Joins: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net)
[06:45:47] *** Quits: jgilbert (jgilbert@E3D90E00.12EE5EA8.C0D9FBB9.IP) (Ping timeout)
[06:45:58] <bjz_> beatgammit: it was a massive effort - hats off to strcat and dbaupp for it (there may have been others too)
[06:46:32] *** Quits: tikue_ (tkuehn@FE643D5D.E2CAEE6E.689607DE.IP) (Ping timeout)
[06:46:43] * beatgammit tips hat
[06:47:32] <acrichto> strcat: ping
[06:47:36] <strcat> pong
[06:47:47] <acrichto> so the sret means that the return pointer can't alias any of the arguments, right?
[06:48:31] <acrichto> strcat: because doesn't https://gist.github.com/alexcrichton/6533752 have the environment alias the return pointer?
[06:49:56] <strcat> acrichto: no, it doesn't alias
[06:50:03] <acrichto> strcat: actually reload it
[06:50:10] <acrichto> it definitely aliases there
[06:50:24] *** Joins: dbaupp (Thunderbir@moz-EAA09AEF.lns20.syd7.internode.on.net)
[06:50:44] <strcat> hm
[06:50:44] <acrichto> or hm maybe not, looking at the IR
[06:50:49] <strcat> I don't think it should
[06:51:11] <strcat> it has to allocate a temporary for the ret value in that case
[06:51:18] <strcat> because you are writing out to the ret value
[06:51:22] <strcat> so it would be unsound
[06:51:31] <acrichto> strcat: yeah that's what it looks like it's doing, but I was basically thinking that closures may be throwing a wrench into this
[06:51:40] <acrichto> I may just not be thinking it completely through though
[06:51:49] <strcat> acrichto: rustc has to generate a temporary to hold the ret value
[06:51:52] <strcat> and then assign it
[06:52:11] <acrichto> hm well if the retptr is always a temp then nothing can alias that...
[06:52:17] <strcat> yeah that's the point ;p
[06:52:26] <strcat> clang does the noalias + sret too
[06:52:33] <strcat> acrichto: I am 99% sure it's sret causing it
[06:52:35] <strcat> not noalias
[06:52:42] <strcat> I didn't verify because I'm so sure ;p
[06:52:51] <strcat> because noalias isn't going to do anything with optimizations off
[06:52:55] <strcat> and it failed on 32-bit nopt
[06:53:35] <acrichto> have you pushed to try without sret?
[06:53:43] <strcat> acrichto: nope, does try have a 32-bit bot?
[06:53:53] <acrichto> dunno
[06:55:31] <dbaupp> windows is 32bit?
[06:55:43] <klutzy> yes
[06:55:56] *** Joins: eatkinson (eatkinson@moz-261EDE03.hsd1.ca.comcast.net)
[06:56:11] <strcat> dbaupp: yeah but it might not fail
[06:56:13] <strcat> I'll try
[06:56:21] *** Quits: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net) (Ping timeout)
[06:56:33] <strcat> acrichto: I also have a chroot to try in now ;p
[06:56:34] <strcat> could just do that
[06:58:41] *** Quits: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net) (Input/output error)
[06:59:18] <acrichto> a test can only fail if fail!() is called, right?
[06:59:24] <acrichto> of if it's should_fail and doesn't
[06:59:47] <dbaupp> acrichto: I think so
[07:00:05] <acrichto> these fileinput tests are failing and I can't attribute any fail! output to them :(
[07:00:41] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[07:01:13] <dbaupp> locally, or on the buildbots?
[07:01:25] <acrichto> buildbots
[07:01:30] <acrichto> http://buildbot.rust-lang.org/builders/auto-win-32-nopt-t/builds/505/steps/test/logs/stdio
[07:01:31] <dbaupp> yeah, I had trouble finding the output too, but it'sthere
[07:01:34] <acrichto> http://buildbot.rust-lang.org/builders/auto-win-32-nopt-t/builds/520/steps/test/logs/stdio
[07:01:39] <acrichto> etc..
[07:01:47] *** Joins: tikue_ (tkuehn@FE643D5D.E2CAEE6E.689607DE.IP)
[07:01:49] <acrichto> there's also flaky rustpkg tests right now as well
[07:01:54] <dbaupp> acrichto: it's below
[07:02:00] <dbaupp> task <unnamed> failed at 'called `Result::unwrap()` on `Err` value: error opening tmp\lib-fileinput-test-next-file-1.tmp', C:\bot\slave\auto-win-32-nopt-t\build\src\libstd\result.rs:120
[07:02:24] <acrichto> oh weird
[07:02:49] <dbaupp> yeah, very weird
[07:03:03] <acrichto> these tests make files, but never close the files
[07:03:05] <acrichto> which confuses me
[07:04:32] * dbaupp is sorry for bad tests
[07:04:46] *** Quits: beatgammit (Mibbit@moz-683D0BC4.slkc.qwest.net) (Quit: http://www.mibbit.com ajax IRC Client)
[07:04:51] <acrichto> not even sure if that's the problem though
[07:04:54] <acrichto> I can't reproduce locally :(
[07:05:10] <acrichto> they're all on win32-nopt-t
[07:05:23] <dbaupp> are the test runners sharing the tmp/... directory?
[07:05:35] <acrichto> that was my first guess
[07:05:41] <acrichto> but they're going into the workspace's local tmp dir
[07:05:47] *** flaper87 is now known as flaper87|afk
[07:05:49] *** Quits: jeaye (Jeaye@moz-34FEF2BB.hsd1.ca.comcast.net) (Quit: zzz)
[07:06:03] <acrichto> so I don't think that they're tromping one another
[07:07:11] <acrichto> if I run two in parallel though I'm getting lots of similar failures
[07:07:17] <strcat> acrichto: does it bind to a port or something
[07:07:22] <acrichto> wait no I'm not
[07:07:23] <dbaupp> strcat: no
[07:07:36] <dbaupp> strcat: it's just opening some files
[07:07:49] <dbaupp> does windows have a file-descriptor limit of some sort?
[07:07:51] <acrichto> yeah so these failures are all becaues the files don't exist
[07:08:02] <strcat> acrichto: yeah it works fine without sret
[07:08:05] <strcat> noalias isn't the issue
[07:08:10] <acrichto> strcat: interesting
[07:08:26] <acrichto> strcat: looking in the langref, how does sret even cause problems
[07:08:39] <strcat> acrichto: so, the 2 things I suspect it could be are 1) foreign.rs is buggy (likely) or 2) I'm missing an sret annotation somewhere
[07:08:42] <strcat> acrichto: sret changes the ABI
[07:08:51] <acrichto> really?
[07:08:53] <acrichto> how so?
[07:09:07] <strcat> I think it always puts it in EAX on x86 or something
[07:09:22] <acrichto> but it can only be applied to a function parameter
[07:09:30] <strcat> yes
[07:09:33] <acrichto> so wouldn't it already be a normal parameter?
[07:09:36] <strcat> it changes the ABI signature
[07:09:39] <strcat> acrichto: hm?
[07:09:47] <strcat> it can only be applied to the 1st parameter
[07:09:52] <strcat> when it's a pointer
[07:09:56] <acrichto> but then it gets promoted to a "special parameter"
[07:09:58] <acrichto> w?
[07:10:07] <strcat> acrichto: you're only allowed sret on the 1st param
[07:10:28] <acrichto> yeah, but LLVM then changes the ABI so it's no longer "just the first parameter" ?
[07:10:29] *** Joins: m_kato (m_kato@moz-C286AD9A.bitcat.net)
[07:10:40] <strcat> acrichto: well, how it passes parameters depends on ABI details
[07:10:45] <dbaupp> This is the correct/required thing to do when adding functions to src/rt isn't it? https://github.com/huonw/rust/commit/a9184975da62769dfccbca73fb9bd554298a4d36
[07:11:05] <acrichto> dbaupp: that should be it
[07:11:07] *** Quits: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net) (Quit: gavinb)
[07:11:20] <strcat> acrichto: if we used fastcc as our calling convention it likely wouldn't change the ABI
[07:11:22] <acrichto> strcat: yeah but I'm not seeing hwo the ABI would change
[07:11:24] <strcat> but anyway it's a real problem we should fix
[07:11:29] <dbaupp> acrichto: thanks
[07:11:39] <strcat> acrichto: by using different registers to pass params
[07:12:01] <acrichto> strcat: yeah but flagging a parameter as a special type of pointer doesn't seem like it'd change teh ABI completely
[07:12:17] <strcat> acrichto: it does though, not completely, but it does
[07:12:25] <acrichto> huh
[07:12:37] <strcat> acrichto: calling conventions specify how to return structs in C
[07:12:45] <strcat> it's different than a regular param
[07:12:52] <acrichto> but we're not returning structs, we're passing a pointer that should be filled in
[07:13:07] *** flaper87|afk is now known as flaper87
[07:13:07] *** Quits: ww (Mibbit@moz-DFAED48A.lightspeed.sntcca.sbcglobal.net) (Quit: http://www.mibbit.com ajax IRC Client)
[07:13:22] <strcat> acrichto: sret == tagging a parameter as an out pointer (structure return)
[07:13:30] <acrichto> yeah
[07:13:41] <acrichto> but the function's purpose doesn't change at all, it's still filling in a pointer for the caller
[07:13:53] <strcat> acrichto: yes, but sret changes the ABI
[07:14:03] <SingingBoyo> is there a way to just run the libextra tests?
[07:14:10] <acrichto> SingingBoyo: make check-stageN-extra
[07:14:13] <strcat> the function is now returning a struct via an out pointer, according to the required calling conventions
[07:14:20] <strcat> fastcc wouldn't care
[07:14:51] <strcat> a cdecl function returning a struct via an out parameter has a different ABI than one just taking a struct parameter and writing a struct to it
[07:14:56] <strcat> that's why the ABI changes
[07:15:09] <strcat> and essentially why sret exists - because C/C++ *have* to use it
[07:15:18] <strcat> we don't have to use it, but it's useful
[07:15:55] <strcat> it tells LLVM that the ptr is valid for that type
[07:16:00] <acrichto> dbaupp: did you write the fileinput tests?
[07:16:04] <strcat> as in, it is a valid block of memory properly aligned for it 
[07:16:13] *** Quits: tikue_ (tkuehn@FE643D5D.E2CAEE6E.689607DE.IP) (Ping timeout)
[07:16:30] <strcat> so it knows writing directly to it will be equivalent to storing chunks or doing a memcpy
[07:16:42] <strcat> without sret, it won't convert from stores -> memcpy/direct
[07:16:53] <dbaupp> acrichto: I wrote fileinput & its tests, yes
[07:16:56] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[07:17:04] <strcat> acrichto: anyway one of those two things is happening
[07:17:06] <dbaupp> (that was my first major contribution to Rust, heh.)
[07:17:07] <acrichto> dbaupp: I'm thinking I'm just gonna rewrite with rt::io instead of std::io
[07:17:13] <dbaupp> acrichto: yes
[07:17:23] <acrichto> strcat: hmm... ok
[07:17:24] <dbaupp> acrichto: there's a fixme in there about something like that too
[07:17:25] <strcat> foreign.rs is broken because I changed the ABI, or sret is tagged somewhere it shouldn't be
[07:17:28] *** Joins: tikue_ (tkuehn@FE643D5D.E2CAEE6E.689607DE.IP)
[07:17:33] * strcat shrugs
[07:17:34] <dbaupp> acrichto: I can do it, if you want?
[07:17:40] <strcat> *maybe* something else
[07:17:42] <strcat> but I doubt it
[07:17:44] <strcat> anyway going to sleep
[07:17:46] <strcat> \o
[07:17:47] *** Quits: strcat (strcat@moz-61B073BC.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.1)
[07:18:12] <acrichto> dbaupp: nah it's ok, I'm already knee-deep
[07:18:18] <dbaupp> acrichto: awesome
[07:18:26] <acrichto> dbaupp: you could take a look at https://github.com/mozilla/rust/pull/9012 though :P
[07:18:30] <dbaupp> you could also rename `pathify` to something nicer
[07:18:36] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[07:18:49] <klutzy> acrichto: is rt::io tested? I failed to open file on win32 but don't remember it was my fault or not
[07:19:04] <flaper87> pathify is quite funny
[07:19:06] * flaper87 waves
[07:19:13] <dbaupp> klutzy: there are tests in the files, not sure if they're enabled on windows though
[07:19:17] *** Quits: tikue_ (tkuehn@FE643D5D.E2CAEE6E.689607DE.IP) (Ping timeout)
[07:19:17] <acrichto> klutzy: :( I'll let bors find out though :P
[07:19:45] <acrichto> pathify?
[07:20:13] *** Joins: tikue_ (tkuehn@FE643D5D.E2CAEE6E.689607DE.IP)
[07:20:19] *** Quits: m_kato (m_kato@moz-C286AD9A.bitcat.net) (Ping timeout)
[07:20:37] *** Joins: nsf (nsf@moz-EEF3238A.convex.ru)
[07:20:47] *** Joins: m_kato (m_kato@moz-C286AD9A.bitcat.net)
[07:21:00] *** Quits: eatkinson (eatkinson@moz-261EDE03.hsd1.ca.comcast.net) (Quit: eatkinson)
[07:21:07] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[07:21:07] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/796ALA
[07:21:07] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[07:21:14] <dbaupp> acrichto: yeah, there's a function that converts &[~str] -> ~[Path] to make it easier to use
[07:21:23] <klutzy> hmm, in rt/io/file.rs all tests are disabled. https://github.com/mozilla/rust/issues/8810
[07:21:25] <dbaupp> (it == fileinput)
[07:21:35] <dbaupp> klutzy: :(
[07:21:50] <acrichto> nooooo
[07:21:59] <dbaupp> acrichto: (looking at 9012 now btw)
[07:22:06] <klutzy> but there is no 'simple' tests e.g. simply opening or reading files
[07:22:12] <klutzy> so I have to investigate it later
[07:22:25] *** Quits: tikue (quassel@moz-FEADCD38.hsd1.pa.comcast.net) (Connection reset by peer)
[07:22:26] *** tikue_ is now known as tikue
[07:23:34] <klutzy> I'm not sure because some weeks ago I got permission error while trying to open a file, but the issue says only "unknown error"
[07:23:53] <engla> rt::io is unfinished
[07:24:33] *** Quits: six600110 (six600110@moz-2FA48202.neo.res.rr.com) (Connection timed out)
[07:25:19] *** Joins: six600110 (six600110@moz-2FA48202.neo.res.rr.com)
[07:26:20] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[07:26:20] <ghrust> 01[13rust01] 15bors pushed 6 new commits to 06auto: 02http://git.io/ORzm4w
[07:26:20] <ghrust> 13rust/06auto 1421ce41d 15Huon Wilson: extra: use a mutex to wrap linenoise calls and make them threadsafe....
[07:26:20] <ghrust> 13rust/06auto 14fe03d82 15Huon Wilson: extra: stop rl from leaking each line that is read.
[07:26:21] <ghrust> 13rust/06auto 144ed5fcb 15Huon Wilson: extra: improvements & bug fixes to rl....
[07:26:23] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[07:27:50] <nathan7> https://gist.github.com/nathan7/6533992 I'm seeing this breaking the compiler
[07:27:57] <nathan7> (most minimal case I've come up with so far)
[07:28:16] <acrichto> nathan7: how so?
[07:28:22] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Client exited)
[07:28:33] <nathan7> task <unnamed> failed at 'called `Option::unwrap()` on a `None` value', /root/rust-git/src/rust/src/libstd/option.rs:301
[07:28:33] <nathan7> error: internal compiler error: unexpected failure
[07:28:39] <nathan7> note: the compiler hit an unexpected failure path. this is a bug
[07:28:40] *** Quits: Shaladdle (Shaladdle@moz-424BC304.hsd1.pa.comcast.net) (Ping timeout)
[07:28:42] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[07:28:59] <acrichto> nathan7: that's unfortunate :(, feel free to open an issue though
[07:29:15] <nathan7> I'mma compile latest git master and see if it's still there
[07:29:42] <nathan7> My kernel hacking is a tad blocked on this
[07:29:43] <Seldaek> tikue, cmr: so did anyone contact the cs4414 author about docs? or should I shoot an email real quick?
[07:29:57] <dbaupp> nathan7: it doesn't appear to be a bug in master
[07:30:06] <tikue> Seldaek: I haven't, no. Go ahead!
[07:30:07] <nathan7> dbaupp: okay, sweet, I'm just behind the times then
[07:30:09] <nathan7> dbaupp: <3
[07:30:15] *** Joins: bent (chatzilla@FC9FC902.ED95B50E.EDDC15BA.IP)
[07:30:15] <dbaupp> nathan7: are you on 0.7?
[07:30:23] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[07:30:52] <nathan7> dbaupp: no, master I compiled recently
[07:30:56] <dbaupp> acrichto: sorry for the pedantic review :)
[07:31:00] <nathan7> where recently is last weekish
[07:31:05] <nathan7> or, no, this week
[07:31:15] <acrichto> dbaupp: oh no, I'm much more a fan of pendantic reviews than not
[07:31:18] <nathan7> probably monday
[07:31:23] <acrichto> dbaupp: especially b/c you're right on all accounts :P
[07:31:25] <Seldaek> tikue: ok
[07:31:44] <jld> bjz_: pong?
[07:32:04] <bjz_> jld: great PR with the C-like enums
[07:32:11] <dbaupp> acrichto: heh, that's a first
[07:32:25] <bjz_> jld: will we be able to use type aliases in the attribute?
[07:32:30] *** Joins: ww (Mibbit@moz-DFAED48A.lightspeed.sntcca.sbcglobal.net)
[07:32:35] <bjz_> jld: like c_int?
[07:32:44] <SingingBoyo> nathan7: lifetimes are still pretty buggy, especially 'self.  there's a bug with them blocking my rewrite of json to rt::io, too.
[07:33:06] <SingingBoyo> should clarify that: lifetimes as parameters to a type are buggy
[07:33:06] *** Quits: santiago (santiago@moz-8ADE82B4.socal.res.rr.com) (Quit: Textual IRC Client: http://www.textualapp.com/)
[07:33:07] <nathan7> SingingBoyo: that line is actually from libstd
[07:33:18] <dbaupp> nathan7: ah, mine is a similar age. what's the output of rustc -v? (mine's `rustc 0.8-pre (d09f569 2013-09-09 00:26:07 -0700)`)
[07:33:20] <acrichto> klutzy: do you have a windows build of rust on-hand ?
[07:33:24] <jld> bjz_: My patch just recognizes the built-in ones.  I don't know how hard it'd be to do type resolution.
[07:33:33] <nathan7> SingingBoyo: I'm in kernelmode so no std for me, but I'm taking shit along from std as I need it
[07:33:35] <nathan7> rustc 0.8-pre (eae3270 2013-09-08 22:16:07 -0700)
[07:33:53] <dbaupp> heh 2 hours
[07:33:57] *** Joins: santiago (santiago@moz-8ADE82B4.socal.res.rr.com)
[07:34:09] <dbaupp> (I'm possibly just not reproducing it correctly... how'd you compile it?)
[07:34:25] <nathan7> rust build --lib blah.rs
[07:34:36] <flaper87> I think examples of lifetime usage in rust-for-real should get some priority
[07:34:44] <nathan7> rustc works too
[07:35:52] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[07:36:33] <bjz_> jld: sure thing
[07:36:35] *** Joins: nkoep (nik@moz-790570D8.pool.mediaways.net)
[07:36:43] <SingingBoyo> broken for me too, though my rustc is something like 3 days older than yours
[07:36:47] <bjz_> jld: something to think about though
[07:37:21] <bjz_> rusti: std::sys::size_of::<c_int>()
[07:37:26] -rusti- pastebinned 8 lines of output: http://ix.io/7ZC
[07:37:31] <acrichto> can we force a drop of @T?
[07:37:47] <bjz_> rusti: std::sys::size_of::<std::libc::c_int>()
[07:37:48] -rusti- 4u
[07:37:53] <klutzy> acrichto: yep, on d41b558 (1~2 days ago)
[07:38:04] *** Quits: alex_abreu (alex@moz-7421D6C9.mc.videotron.ca) (Ping timeout)
[07:39:23] <dbaupp> nathan7, SingingBoyo: ah I see it too
[07:39:24] <acrichto> klutzy: can you run https://gist.github.com/alexcrichton/6534080
[07:39:36] <nathan7> dbaupp: aw
[07:39:41] <dbaupp> nathan7: probably an issue with metadata and missing lang items
[07:39:50] <bjz_> rusti: enum A { A0 = 0, A1 = 1 } static AA: A = A1; let a = A0; match a { A0 => "hi", AA => "yo" }
[07:39:51] -rusti- error: internal compiler error: unexpected failure
[07:39:51] -rusti- note: the compiler hit an unexpected failure path. this is a bug
[07:39:51] -rusti- note: try running with RUST_LOG=rustc=1 to get further details and report the results to github.com/mozilla/rust/issues
[07:39:51] -rusti- application terminated with error code 101
[07:39:53] * dbaupp investigates
[07:39:55] <bjz_> :(
[07:39:59] <bjz_> still broked
[07:40:18] <bjz_> rusti: enum A { A0, A1 } static AA: A = A1; let a = A0; match a { A0 => "hi", AA => "yo" }
[07:40:18] -rusti- <anon>:5:42: 5:44 error: Non-constant path in constant expr
[07:40:18] -rusti- <anon>:5          enum A { A0, A1 } static AA: A = A1; let a = A0; match a { A0 => "hi", AA => "yo" }
[07:40:18] -rusti-                                                    ^~
[07:40:19] -rusti- application terminated with error code 101
[07:40:35] <bjz_> :/
[07:40:46] <klutzy> acrichto: task <unnamed> failed at 'Unhandled condition: io_error: rt::io::IoError{kind: OtherIoError, desc: "unknown error", detail: None}', C:\home\stone\rust\src\libstd\condition.rs:43
[07:40:51] <klutzy> :'(
[07:41:09] <dbaupp> nathan7: `trait Container {} impl Container for uint {}` fails too
[07:41:19] <nathan7> dbaupp: brilliant
[07:41:28] *** Joins: alex_abreu (alex@moz-7421D6C9.mc.videotron.ca)
[07:41:45] <nathan7> I think I've finally figured out why people cut their wrists!
[07:41:45] <SingingBoyo> dbaupp: that... that doesn't look good.
[07:42:21] <SingingBoyo> nathan7: indeed, I'm beginning to question my ambitions to spend my next summer working on rust
[07:42:28] * dbaupp suggests nathan7 distract himself from self harm by fixing the bug
[07:42:31] <nathan7> SingingBoyo: Work on rustc q=
[07:42:45] <acrichto> klutzy: :(, and I guess you have to totally recompile to get rtdebug! output, oh well thanks anyway
[07:42:45] <nathan7> dbaupp: I really know way too little about compilers and rust internals
[07:42:59] <nathan7> dbaupp: but I might be able to trace this one
[07:43:08] * SingingBoyo might take a look later but extra::json is still being a PITA
[07:43:23] <SingingBoyo> and I don't know much about the compiler either
[07:43:24] <dbaupp> nathan7: you can break on rust_begin_unwind in gdb to get a backtrace
[07:43:32] <klutzy> acrichto: ah, right. I recently forgot the flag
[07:43:35] *** Quits: jdm (jdm@moz-2C5514D1.lightspeed.sntcca.sbcglobal.net) (Input/output error)
[07:43:42] <nathan7> dbaupp: oh, fun
[07:43:45] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[07:43:45] *** ChanServ sets mode: +o pnkfelix
[07:43:51] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Client exited)
[07:43:51] <acrichto> klutzy: rtdebug is different from debug as well, it's incredibly massive
[07:43:55] <dbaupp> nathan7: (and, when I started on rustc, I didn't know much either :P )
[07:44:01] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[07:44:01] *** ChanServ sets mode: +o pnkfelix
[07:44:02] <nathan7> I spent the other day in gdb trying to figure out why my rust kernel kept aborting
[07:44:08] *** Joins: jdm (jdm@moz-2C5514D1.lightspeed.sntcca.sbcglobal.net)
[07:44:08] *** ChanServ sets mode: +o jdm
[07:44:13] *** Quits: paulproteus (quassel@rose.makesad.us) (Ping timeout)
[07:44:15] <nathan7> luckily we have a lot of rainy days in .nl now
[07:44:44] *** Joins: paulproteus (quassel@moz-E86A3B42.makesad.us)
[07:45:04] <klutzy> acrichto: I'd set it locally during win64 work, but I stashed it and maybe dropped by mistake
[07:45:21] <klutzy> and I usually don't remember what I stashed :p
[07:45:38] *** Joins: sankha93 (Instantbir@CAF6D3FF.9C875DCD.9105FBCF.IP)
[07:46:57] *** flaper87 is now known as flaper87|afk
[07:46:59] <SingingBoyo> is there a way to just run tidy.py to get my whitespace checked? 
[07:47:05] <dbaupp> make tidy
[07:47:12] <SingingBoyo> ah.  well duh
[07:47:23] *** Quits: sankha93 (Instantbir@CAF6D3FF.9C875DCD.9105FBCF.IP) (Ping timeout)
[07:47:46] <acrichto> dbaupp: are you ok if I #[ignore] fileinput tests due to 8810 for now?
[07:47:48] *** Joins: sankha93 (Instantbir@CAF6D3FF.9C875DCD.9105FBCF.IP)
[07:48:13] <dbaupp> acrichto: it won't upset me, if that's what you're asking?
[07:48:21] <acrichto> mk
[07:48:38] <dbaupp> (i'm not really the maintainer of it; I'm just the code monkey who wrote it the first time. :P )
[07:51:20] *** Quits: sankha93 (Instantbir@CAF6D3FF.9C875DCD.9105FBCF.IP) (Ping timeout)
[07:51:49] *** Joins: sankha93 (Instantbir@CAF6D3FF.9C875DCD.9105FBCF.IP)
[07:52:08] <dbaupp> acrichto: did I read this correctly: you replaced extrasp by just reading the span of the extra Expr?
[07:53:09] *** Quits: sankha93 (Instantbir@CAF6D3FF.9C875DCD.9105FBCF.IP) (Ping timeout)
[07:53:47] *** flaper87|afk is now known as flaper87
[07:54:23] * nathan7 maxing out 8 cores compilin'
[07:54:28] <SingingBoyo> you know you're in trouble when you're sticking printfln! into the library tests.
[07:54:54] <nathan7> well, better get hacking on rustc tonight then
[07:55:02] <nathan7> if this doesn't fix it
[07:55:04] <dbaupp> nathan7: every night! \o/
[07:55:05] <dbaupp> :P
[07:55:21] *** Quits: ww (Mibbit@moz-DFAED48A.lightspeed.sntcca.sbcglobal.net) (Quit: http://www.mibbit.com ajax IRC Client)
[07:55:33] <acrichto> what in the world is XID
[07:55:43] <SingingBoyo> dbaupp:  if you pass that attitude on to me I'll fail second-year university :/
[07:56:16] <dbaupp> acrichto: X = not a proper standard, ID = ident, I think
[07:56:31] *** Quits: tikue (tkuehn@FE643D5D.E2CAEE6E.689607DE.IP) (Ping timeout)
[07:56:40] <acrichto> oh huh
[07:56:41] <dbaupp> acrichto: (i.e. it's a recommendation by the unicode people for good things to start/continue identifiers) 
[07:56:53] <acrichto> start = start of an identifier, continue = everything afterwards?
[07:56:55] *** Quits: zeuxcg (zeuxcg@moz-80D1F912.hsd1.ca.comcast.net) (Ping timeout)
[07:56:56] <dbaupp> yeah
[07:57:01] <dbaupp> so start doesn't include numbers
[07:57:02] <acrichto> cool, I shall use that
[07:57:02] *** Joins: tikue (tkuehn@FE643D5D.E2CAEE6E.689607DE.IP)
[07:57:06] <dbaupp> but continue does
[07:57:09] <dbaupp> SingingBoyo: \o/
[07:57:21] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[07:57:39] <nathan7> dbaupp: You people are *terrible* for my.. life in general.
[07:59:04] <SingingBoyo> dbaupp: don't celebrate making me fail a comp sci degree.  That's not nice!
[07:59:07] <flaper87> nathan7: lol
[07:59:36] <flaper87> SingingBoyo: printfln! in tests is nice
[07:59:40] * flaper87 runs away
[07:59:43] <flaper87> really really fast
[07:59:44] <flaper87> :D
[07:59:53] *** Joins: sankha93 (Instantbir@CAF6D3FF.9C875DCD.9105FBCF.IP)
[08:00:13] <dbaupp> nathan7, SingingBoyo: \o/
[08:00:32] <SingingBoyo> flaper87: it doesn't even print anything as far as I can tell...
[08:01:45] <SingingBoyo> whoops.  guess I gotta remember the commas in my json...
[08:01:51] * SingingBoyo hopes that fixes it
[08:02:02] *** Quits: sankha93 (Instantbir@CAF6D3FF.9C875DCD.9105FBCF.IP) (Connection reset by peer)
[08:02:30] *** Joins: sankha93 (Instantbir@CAF6D3FF.9C875DCD.9105FBCF.IP)
[08:04:40] *** Quits: sankha93 (Instantbir@CAF6D3FF.9C875DCD.9105FBCF.IP) (Client exited)
[08:05:26] *** Joins: sankha93 (Instantbir@CAF6D3FF.9C875DCD.9105FBCF.IP)
[08:05:50] <dbaupp> acrichto: std::fmt and syntax::ext::ifmt need to be renamed btw :P
[08:05:58] *** Joins: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP)
[08:06:05] <acrichto> dbaupp: I was thinking I'd leave std::fmt as-is
[08:06:15] <acrichto> ifmt was kinda a nice relic, but should probably get moved
[08:06:31] <acrichto> if fmt! doesn't exist it can't be confused with std::fmt
[08:06:40] <dbaupp> acrichto: ok
[08:06:56] <dbaupp> yeah, after removing fmt then names will be more sensible
[08:07:17] *** Joins: squiddy (squiddy@moz-AF1F09D5.adsl.alicedsl.de)
[08:07:18] * dbaupp wishes we still had core and staticants :'(
[08:07:33] <SingingBoyo> fmt being replaced with something?   or what should be used now?
[08:07:39] <acrichto> SingingBoyo: format!
[08:07:48] <dbaupp> rusti: format!("format{}", '!')
[08:07:49] -rusti- ~"format!"
[08:08:14] <dbaupp> SingingBoyo: http://static.rust-lang.org/doc/std/fmt.html
[08:08:39] <SingingBoyo> aww more goin through my mini-project and updating things.  Ah well
[08:08:50] <dbaupp> acrichto: write! and println! etc should probably be mentioned in those docs too
[08:08:55] <SingingBoyo> Yay the tests pass
[08:09:07] <dbaupp> SingingBoyo: \o/
[08:09:10] * SingingBoyo just removed the one that was failing since it's covered by a new one
[08:09:18] <acrichto> dbaupp: oh I keep meaning to do that at some point
[08:09:21] * acrichto makes a note
[08:09:26] <dbaupp> SingingBoyo: (am I allowed to celebrate that? :P )
[08:09:38] <SingingBoyo> dbaupp: I really don't know
[08:09:53] <SingingBoyo> but I think extra::json works with maps where the keys aren't strings now :D
[08:12:27] <Eridius> rusti: macro_rules! foo(($($x:ident)) => ( print$($x)("test") )) foo!(ln)
[08:12:27] -rusti- <anon>:5:40: 5:42 error: expected `*` or `+`
[08:12:27] -rusti- <anon>:5          macro_rules! foo(($($x:ident)) => ( print$($x)("test") )) foo!(ln)
[08:12:27] -rusti-                                                  ^~
[08:12:27] -rusti- application terminated with error code 101
[08:12:39] <Eridius> rusti: macro_rules! foo(($($x:ident)+) => ( print$($x)+("test") )) foo!(ln)
[08:12:40] -rusti- fn(&str)
[08:12:53] <Eridius> o_O
[08:13:05] <pnkfelix> Are there #[deriving(FmtDefault)] or some such for getting auto support for "{}" template?
[08:13:07] <pnkfelix> e.g.
[08:13:19] <pnkfelix> rusti: enum K { Ak, Bk, Ck }; fmt!("%?", Ck )
[08:13:20] -rusti- ~"Ck"
[08:13:21] <acrichto> pnkfelix: no, and I haven't planned on adding them soon
[08:13:39] <pnkfelix> acrichto: then please do not remove fmt! until it can do that.
[08:13:52] <acrichto> pnkfelix: isn't that what {:?} is for though?
[08:14:01] <acrichto> that's what deriving(FmtDefault) would be anyway
[08:14:18] <acrichto> rusti: enum K { Ak, Bk, Ck }; format!("{:?}", Ck )
[08:14:19] -rusti- ~"Ck"
[08:14:27] <pnkfelix> acrichto: ah I did not understand that was what "Poly" meant
[08:14:48] <pnkfelix> acrichto: nm then
[08:14:52] <acrichto> cool :)
[08:15:08] <acrichto> rusti: format!("{:x}", -1u16)
[08:15:09] -rusti- ~"ffff"
[08:15:14] <acrichto> that always makes me happy
[08:15:24] <acrichto> rusti: format!("{:x}", -1)
[08:15:25] -rusti- ~"ffffffffffffffff"
[08:16:11] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[08:16:11] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 144d54ec9 to 1403ca1be: 02http://git.io/N3iJvQ
[08:16:11] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[08:16:12] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[08:16:12] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/eX2zgw
[08:16:12] <ghrust> 13rust/06auto 14645b83d 15Alex Crichton: Flag the dynamic_lib tests as ignored...
[08:16:12] <ghrust> 13rust/06auto 146812535 15bors: auto merge of #9138 : alexcrichton/rust/dynamic-lib-not-threadsafe, r=thestinger...
[08:16:13] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[08:17:15] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[08:18:55] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[08:20:31] *** Quits: tikue (tkuehn@FE643D5D.E2CAEE6E.689607DE.IP) (Quit: tikue)
[08:21:18] <dbaupp> acrichto: it's slighty different to :?
[08:21:22] <dbaupp> *it'd be
[08:21:30] *** Quits: KindOne (KindOne@moz-4A7B61AE.dynamic.ip.windstream.net) (Ping timeout)
[08:21:39] <dbaupp> acrichto: like how ToStr is different to :?, it'd call {} on each field
[08:23:07] <dbaupp> Eridius: that's really weird
[08:23:20] <dbaupp> rusti: macro_rules! foo(($($x:ident)+) => ( (print$($x)+("test")) )) foo!(ln)
[08:23:20] -rusti- <anon>:5:55: 5:56 error: expected one of `, )` but found `ln`
[08:23:20] -rusti- <anon>:5          macro_rules! foo(($($x:ident)+) => ( (print$($x)+("test")) )) foo!(ln)
[08:23:20] -rusti-                                                                 ^
[08:23:20] -rusti- application terminated with error code 101
[08:23:33] <dbaupp> rusti: macro_rules! foo(($($x:ident)+) => ( print )) foo!(ln)
[08:23:34] -rusti- fn(&str)
[08:23:45] <dbaupp> Eridius: wait; it's just https://github.com/mozilla/rust/issues/8012
[08:23:55] <dbaupp> it's expanding to `print` and ignoring everything after
[08:24:17] <Eridius> how is `print` the first item?
[08:24:27] <Eridius> rusti: macro_rules! foo(($($x:ident)+) => ({ print$($x)+("test") ) }) foo!(ln)
[08:24:28] -rusti- <anon>:5:67: 5:68 error: incorrect close delimiter: `)`
[08:24:28] -rusti- <anon>:5          macro_rules! foo(($($x:ident)+) => ({ print$($x)+("test") ) }) foo!(ln)
[08:24:28] -rusti-                                                                             ^
[08:24:28] -rusti- application terminated with error code 101
[08:24:33] <Eridius> rusti: macro_rules! foo(($($x:ident)+) => ({ print$($x)+("test") })) foo!(ln)
[08:24:33] -rusti- <anon>:5:55: 5:56 error: expected one of `; }` but found `ln`
[08:24:34] -rusti- <anon>:5          macro_rules! foo(($($x:ident)+) => ({ print$($x)+("test") })) foo!(ln)
[08:24:34] -rusti-                                                                 ^
[08:24:34] -rusti- application terminated with error code 101
[08:24:36] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[08:24:45] <Eridius> bah
[08:25:06] <Eridius> ok w/e. I wish I could concatenate an identifier with a string, but I can't
[08:25:07] *** Quits: nkoep (nik@moz-790570D8.pool.mediaways.net) (Ping timeout)
[08:25:15] <dbaupp> concat_idents! ?
[08:25:15] *** Quits: SingingBoyo (brandon@DAC9C672.CE76D40F.4F048BDC.IP) (Ping timeout)
[08:25:20] *** Joins: KindOne (KindOne@moz-4A7B61AE.dynamic.ip.windstream.net)
[08:25:27] <dbaupp> (it doesn't really work, but it might for your usecase?)
[08:25:37] <Eridius> my use-case is a method call. so foo.concat_idents!(a, b) ain't gonna cut it
[08:25:58] <dbaupp> yeah
[08:26:22] *** Joins: SingingBoyo (brandon@DAC9C672.CE76D40F.4F048BDC.IP)
[08:26:35] <dbaupp> rusti: macro_rules! foo(($($x:ident)+) => ({ 1.concat_idents!($($x)+)() })) foo!(to_, str)
[08:26:35] -rusti- <anon>:5:86: 5:87 error: expected ident, found ,
[08:26:35] -rusti- <anon>:5          macro_rules! foo(($($x:ident)+) => ({ 1.concat_idents!($($x)+)() })) foo!(to_, str)
[08:26:35] -rusti-                                                                                                ^
[08:26:36] -rusti- application terminated with error code 101
[08:26:42] <dbaupp> rusti: macro_rules! foo(($($x:ident),+) => ({ 1.concat_idents!($($x)+)() })) foo!(to_, str)
[08:26:42] -rusti- <anon>:5:63: 5:64 error: expected one of `; }` but found `!`
[08:26:42] -rusti- <anon>:5          macro_rules! foo(($($x:ident),+) => ({ 1.concat_idents!($($x)+)() })) foo!(to_, str)
[08:26:42] -rusti-                                                                         ^
[08:26:43] -rusti- application terminated with error code 101
[08:26:55] <dbaupp> ok, doesn't even work with an extra layer of macros
[08:27:05] * dbaupp thought more indirection solved everything
[08:27:08] <Eridius> heh
[08:27:24] <Eridius> maybe we should just allow something like $[] to concatenate identifiers
[08:27:40] <Eridius> so you could say 1.$[$($x),+] in that case
[08:29:02] *** Quits: KindOne (KindOne@moz-4A7B61AE.dynamic.ip.windstream.net) (Ping timeout)
[08:29:02] *** Quits: six600110 (six600110@moz-2FA48202.neo.res.rr.com) (Connection timed out)
[08:29:25] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[08:30:10] *** Joins: six600110 (six600110@moz-2FA48202.neo.res.rr.com)
[08:32:46] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[08:33:33] *** Joins: KindOne (KindOne@moz-8521132.dynamic.ip.windstream.net)
[08:34:17] *** Joins: kumel (kumel@BD9B35B2.60E2620B.EBFADDB2.IP)
[08:35:12] *** Parts: kumel (kumel@BD9B35B2.60E2620B.EBFADDB2.IP) ()
[08:39:41] *** Joins: nkoep (nik@moz-8BF7DFF0.vpn.rwth-aachen.de)
[08:41:42] *** Joins: fabiand (fabiand@moz-EDBC5F57.adsl.alicedsl.de)
[08:49:39] *** Quits: [o__o] (~o__o@moz-24EBFAC7.me) (Ping timeout)
[08:50:00] *** Quits: halorgium (z@moz-7A333983.spork.in) (Ping timeout)
[08:50:00] *** Quits: fzzzy (fzzzy@A5CBE5CF.A81CC6E.44FA8ED.IP) (Ping timeout)
[08:51:01] *** Quits: telotortium (rmi1@moz-90BFA359.dhcp.mdsn.wi.charter.com) (Ping timeout)
[08:51:31] *** Joins: tikue (tkuehn@moz-FEADCD38.hsd1.pa.comcast.net)
[08:52:43] *** Joins: Houm_ (Houm@moz-25669AA8.fbx.proxad.net)
[08:52:59] *** Quits: Houm (Houm@moz-25669AA8.fbx.proxad.net) (Ping timeout)
[08:55:28] *** Joins: [o__o] (~o__o@moz-24EBFAC7.me)
[08:55:34] *** Joins: halorgium (z@moz-7A333983.spork.in)
[08:55:36] *** Quits: KindOne (KindOne@moz-8521132.dynamic.ip.windstream.net) (Ping timeout)
[08:55:44] *** Joins: ceninan (ceninan@moz-6BD43586.a370.priv.bahnhof.se)
[08:55:48] *** Joins: fzzzy (fzzzy@A5CBE5CF.A81CC6E.44FA8ED.IP)
[08:57:27] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[08:57:59] *** Joins: pjantrania (Mibbit@ACDE803A.9EA65473.DDE5D3F6.IP)
[08:58:50] <pjantrania> Could anyone tell me how to get a file descriptor from a filename?  I sincerely appreciate the help.
[08:59:58] *** Joins: KindOne (KindOne@9BA6A283.EA06E3F.34F73994.IP)
[09:00:11] *** Joins: dsirenko (mitra@8E712A0.54C21BA0.9F317420.IP)
[09:00:30] *** Joins: telotortium (rmi1@moz-90BFA359.dhcp.mdsn.wi.charter.com)
[09:00:32] *** Houm_ is now known as Houm
[09:00:34] <pjantrania> or, at least, how to use as_c_str to create a c string from a str?
[09:02:42] <dbaupp> pjantrania: are you using 0.7?
[09:03:35] <pjantrania> Yes, I am
[09:04:46] <dbaupp> ah, ok, well, `my_string.as_c_str(|c_str| use c_str )` or `do my_string.as_c_str |c_str| { ... }`
[09:05:03] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[09:05:14] <dbaupp> i.e. it takes a closure that gets passed a *c_char (the pointer to the null terminated string)
[09:05:46] <dbaupp> are you trying to get a file descriptor explicitly? or just an open file?
[09:06:33] *** Quits: tikue (tkuehn@moz-FEADCD38.hsd1.pa.comcast.net) (Quit: tikue)
[09:06:55] <pjantrania> I am trying to get a file descriptor, in order to use as the input or output to a process in Process::new
[09:07:38] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[09:09:52] <dbaupp> hm, it looks like the only way to get a *FILE is via libc::fopen, so yeah, you'll need as_c_str
[09:09:54] <dbaupp> :)
[09:10:41] <pjantrania> yes, I appreciate it.  Does the as_c_str(|c_str| use c_str) example you mentioned return the c string?
[09:10:44] <dbaupp> `fname.as_c_str(|s| "modes".as_c_str(|modes| libc::fopen(s, modes)))`
[09:10:54] <pjantrania> Oooh
[09:10:57] <pjantrania> thanks a lot
[09:12:12] <dbaupp> If you put it in an std::io::FILERes (via `FILERes::new(file_pointer)`) then it'll be automatically closed by the destructor on FILERes (i.e. when that object goes out of scope)
[09:13:07] <dbaupp> so something like `{ let file = fname.as_c_str( ... ); let res = std::io::FILERes::new(file); /* use res.f were appropriate */  }` will automatically call `libc::fclose` at the end of that scope.
[09:14:21] <pjantrania> I see
[09:17:31] <SingingBoyo> yay json works with stringkey-less maps! \o/
[09:17:35] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[09:18:03] <SingingBoyo> or well, assuming my PR passes code review it will
[09:19:15] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[09:21:20] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[09:26:11] *** Joins: doomlord (doomlod@moz-DEFFB365.range81-147.btcentralplus.com)
[09:26:13] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[09:26:13] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/eX2zgw
[09:26:13] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[09:27:26] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[09:30:47] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[09:31:13] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[09:31:13] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/tS5TDw
[09:31:13] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[09:31:14] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[09:31:14] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/Q6gClA
[09:31:14] <ghrust> 13rust/06auto 14a835995 15Tim Kuehn: Rendezvous stream for synchronous channel messaging
[09:31:14] <ghrust> 13rust/06auto 1444baf74 15bors: auto merge of #8908 : tikue/rust/master, r=anasazi...
[09:31:14] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[09:32:34] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[09:32:38] *** Joins: huseby (huseby@moz-633A76FB.static.cust.telenor.com)
[09:34:19] *** Joins: Jimi (ubuntu@moz-C69D33B5.compute-1.amazonaws.com)
[09:35:54] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[09:38:04] *** Quits: optimusbrine (optimusbri@moz-CF697891.tampfl.fios.verizon.net) (Quit: )
[09:40:59] *** Joins: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP)
[09:42:50] <nathan7> I have an external symbol that I just want the address of as a *u8, can I do that statically?
[09:45:09] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[09:45:56] <nathan7> http://sprunge.us/DYhF I have this now, but I'd like to able to skip the runtime check
[09:49:48] *** Joins: Florob (Florob@moz-39532932.de)
[09:49:57] <dbaupp> does static mut watermark: *u8 = &endkernal as *u8; not work?
[09:50:14] <dbaupp> hm,I guess not
[09:50:36] <SingingBoyo> static expressions are sadly limited in my experience
[09:51:08] <nathan7> actually
[09:51:18] <nathan7> ah, yeah, that was a compiler error
[09:51:21] *** Quits: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP) (Ping timeout)
[09:51:28] <dbaupp> ICE? or a normal error?
[09:51:31] <nathan7> task <unnamed> failed at 'const not bound to an item', /root/rust-git/src/rust/src/librustc/middle/check_const.rs:267
[09:51:31] <nathan7> error: internal compiler error: unexpected failure
[09:51:36] <dbaupp> heh
[09:51:40] <dbaupp> file a bug :)
[09:51:46] <nathan7> I have a knack for breaking software
[09:52:05] <dbaupp> rustc is particularly easy to break :P
[09:52:10] <nathan7> the other day a friend was trying to recharge his public transport card, and the machine crashed
[09:52:27] <nathan7> when I was 10m away it magically worked
[09:53:01] <dbaupp> you're actually typing with a very long stick, right?
[09:53:07] <nathan7> nope
[09:53:13] <dbaupp> heh :P
[09:53:26] <nathan7> it's an excellent way of ensuring all your software is robust
[09:53:33] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[09:53:41] <nathan7> should probably do it as consulting service
[09:54:20] <dbaupp> in any case; I imagine just using `let ek: *u8 = &endkernel;` is the most efficient way to do this; the cost of the branch is probably larger than just re-address-of-ing it.
[09:55:03] <bblum> acrichto: pong
[09:55:13] <nathan7> dbaupp: the watermark moves, the symbol doesn't
[09:55:18] <nathan7> dbaupp: it's static mut, not just static
[09:57:17] <dbaupp> nathan7: oh, I thought it was just static mut so that you could set it to &endkernel
[09:57:33] <dbaupp> in that case I imagine there's not a better way to do it
[09:57:35] <nathan7> dbaupp: ah, sorry, context I didn't pass
[09:57:56] <nathan7> I'm also curious how static variables are initialised
[09:58:15] <dbaupp> non-mut ones?
[09:58:24] <nathan7> either
[09:58:36] <dbaupp> in both cases, they're just a bit pattern in the object file
[09:58:46] <dbaupp> i.e. entirely static data
[10:02:22] *** Quits: Houm (Houm@moz-25669AA8.fbx.proxad.net) (Ping timeout)
[10:05:47] <nathan7>  ah
[10:06:08] <nathan7> .data in the case it's intialised with a nonzero value, .bss if it's initialised with a zero value
[10:06:35] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[10:08:48] *** Quits: pjantrania (Mibbit@ACDE803A.9EA65473.DDE5D3F6.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[10:12:39] * nathan7 needs to learn more about how linking works
[10:15:01] *** Quits: m_kato (m_kato@moz-C286AD9A.bitcat.net) (Quit: Leaving...)
[10:17:23] *** Joins: Earnestly (earnest@moz-BE290A2B.dyn.plus.net)
[10:17:55] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[10:18:18] *** Joins: Palmik (palmik@moz-CC484FDD.tmcz.cz)
[10:19:35] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[10:21:11] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[10:21:11] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1444baf74 to 146812535: 02http://git.io/N3iJvQ
[10:21:11] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[10:21:11] *** Quits: Voomer (Voomer@moz-CC05FF5E.hsd1.wa.comcast.net) (Connection reset by peer)
[10:21:12] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[10:21:12] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/N7oMBQ
[10:21:12] <ghrust> 13rust/06auto 149a5f95a 15Alex Crichton: Implement a format_args!() macro...
[10:21:12] <ghrust> 13rust/06auto 144825db4 15bors: auto merge of #9012 : alexcrichton/rust/format-args, r=huonw...
[10:21:13] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[10:24:44] *** Quits: KindOne (KindOne@9BA6A283.EA06E3F.34F73994.IP) (Ping timeout)
[10:25:59] *** Joins: KindOne (KindOne@9BA6A283.EA06E3F.34F73994.IP)
[10:26:11] *** Quits: sankha93 (Instantbir@CAF6D3FF.9C875DCD.9105FBCF.IP) (Quit: Gone to save the world!)
[10:26:48] *** Quits: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP) (Quit: bbl)
[10:28:29] *** Quits: victorporof (victorporo@FBDAE982.F9BD9D78.9B1E38F4.IP) (Quit: victorporof)
[10:29:47] *** Joins: victorporof (victorporo@FBDAE982.F9BD9D78.9B1E38F4.IP)
[10:35:38] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[10:35:41] *** Quits: kseo (kseo@338DE5BC.4166765B.485A6DF.IP) (Client exited)
[10:39:48] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[10:40:56] *** Joins: donri (donri@moz-9BB61102.tbcn.telia.com)
[10:41:02] *** Quits: huseby (huseby@moz-633A76FB.static.cust.telenor.com) (Ping timeout)
[10:43:15] *** Joins: eevee_ (eevee@moz-D25DD324.evrt.wa.frontiernet.net)
[10:43:50] *** Quits: eevee (eevee@moz-2CC451BF.evrt.wa.frontiernet.net) (Ping timeout)
[10:49:42] <nathan7> cmr: What does your makefile look like?
[10:49:54] <nathan7> cmr: I currently have a %.o: %.rs rule
[10:50:11] *** Joins: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[10:50:15] <nathan7> cmr: but it's a tad problematic with crates
[10:56:54] *** bent is now known as bent|lunch
[11:01:32] *** Quits: six600110 (six600110@moz-2FA48202.neo.res.rr.com) (Client exited)
[11:01:45] *** Quits: dew (Instantbir@moz-D2FA52B6.static.stls.mo.charter.com) (Ping timeout)
[11:02:04] *** Joins: dew (Instantbir@moz-D2FA52B6.static.stls.mo.charter.com)
[11:03:01] <kimundi> nathan7: What's problematic?
[11:03:14] *** Quits: SingingBoyo (brandon@DAC9C672.CE76D40F.4F048BDC.IP) (Quit: Leaving)
[11:03:21] *** Joins: SingingBoyo (brandon@DAC9C672.CE76D40F.4F048BDC.IP)
[11:03:28] <nathan7> kimundi: extern mod b; from a.rs doesn't quite work if the artifact from b.rs is called b.o
[11:04:35] *** Joins: six600110 (six600110@moz-2FA48202.neo.res.rr.com)
[11:04:35] <mindcat> q
[11:04:35] <kimundi> that's true. But also not surprising, seeing how we don't really support that ;)
[11:04:54] * mindcat quiting client..
[11:05:00] <mindcat> ;q
[11:05:07] <kimundi> haha
[11:05:12] *** Quits: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Ping timeout)
[11:05:19] *** Quits: mindcat (mindcat@CFA3850B.9B7EF212.2BCF2E43.IP) (Quit: leaving)
[11:05:19] <kimundi>  /q maybe? :P
[11:05:21] <nathan7> kimundi: How should I be building my shit?
[11:05:31] *** Quits: SingingBoyo (brandon@DAC9C672.CE76D40F.4F048BDC.IP) (Quit: Leaving)
[11:05:36] *** Joins: SingingBoyo (brandon@DAC9C672.CE76D40F.4F048BDC.IP)
[11:05:38] *** Joins: mindcat (mindcat@5C1E3272.FBBDCC14.1A8D6442.IP)
[11:05:51] *** Joins: huseby (huseby@moz-633A76FB.static.cust.telenor.com)
[11:06:41] <mindcat> I am using my computer to login here now :]
[11:06:56] <kimundi> nathan7: In Rust, there is only one unit of compilation: One crate at a time. So, either you build everything as one crate, or you separate out common functionality as libraries and compile them as separate crates first.
[11:07:13] <nathan7> kimundi: mhm
[11:07:37] <nathan7> kimundi: so I pretty much give up on makefile-style conditional compilation?
[11:07:57] <nathan7> kimundi: right now I'm building individual files and linking them at the end (I need to do my linking myself anyway, because linker script)
[11:08:29] <kimundi> nathan7: I didn't even know that would work.
[11:08:39] *** Joins: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[11:08:55] <nathan7> kimundi: There's a duplicate rust_abi_version symbol, other than that it works okay
[11:09:03] <nathan7> kimundi: but they're not yet interfacing at the rust level
[11:09:13] <kimundi> What's the use case for compiling stuff separately here?
[11:09:52] <nathan7> none yet, just coming from C as the previous compiled language I used seriously
[11:10:19] <nathan7> Should be able to be entirely self-contained as a crate
[11:10:30] <kimundi> Ah, okay. Then just stop doing that, that's not how it works in rust. ;)
[11:10:40] <nathan7> I do need to do the linking step myself though
[11:11:02] <nathan7> I need to link my assembly preamble in and relocate it to the right place
[11:11:16] <kimundi> Okay, I have no idea about that, but I think you still need to compile whole crate as an singular object first then.
[11:11:40] *** Joins: CanhtTak (CanhTak@moz-E9D07AD7.wl.t.ulaval.ca)
[11:12:18] <kimundi> You just pass the source file of your crate root to rustc, it pulls in all other files acording to how you've written it down in the source.
[11:12:27] <nathan7> mhm
[11:12:59] <kimundi> No need for any 'extern mod' unless you explicitly want to use a separately compiled library
[11:13:25] *** Quits: fyolnish (fyolnish@moz-BE2BAE5B.miinet.jp) (Ping timeout)
[11:13:25] <nathan7> Doesn't seem I like I can teach make that .rs.o is a phony target
[11:13:26] <SingingBoyo> nathan7: you might want %.so:%.rc if you insist on makefiles, though the checksum or whatever it is that gets included in lib names might cause problems.
[11:13:53] <nathan7> -o works here
[11:14:07] <nathan7> kimundi: if it's not external, then I just do mod b; right?
[11:14:27] <nathan7> Or do I just use it?
[11:14:40] <kimundi> Right, but there are a lot of details to keep in mind to not be confused ;)
[11:14:47] <kimundi> I again recommend reading http://static.rust-lang.org/doc/tutorial.html#crates-and-the-module-system
[11:16:01] <nathan7> mhm
[11:16:29] <kimundi> nathan7: TL;DR - source files are irrelevant, what's important that you've defined the logical structure of your crate correctly. You may then optionally put the body of modules in their own source files for better organisation.
[11:16:56] <nathan7> kimundi: mhm
[11:17:49] <kimundi> also: "mod foo;" = "mod foo { /* insert content of foo.rs or foo/mod.rs here */ }"
[11:18:08] <nathan7> Well, there we go
[11:18:15] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[11:18:29] <nathan7> got rid of my repeated runtime check in malloc
[11:18:43] <kimundi> (Though the actual path it looks in for foo.rs and foo/mod.rs is a bit more complicated determined, there is an example for that in the tutorial)
[11:18:45] *** Quits: SingingBoyo (brandon@DAC9C672.CE76D40F.4F048BDC.IP) (Ping timeout)
[11:18:52] <nathan7> kernel core should pretty much be one crate, so this makes sense
[11:19:22] *** Joins: cstrahan (cstrahan@moz-71FAC30.hsd1.va.comcast.net)
[11:19:29] <nathan7> memory allocation services and some rust runtime provisions
[11:19:53] <nathan7> this is all gonna be a lot of fun when I start multitasking
[11:19:55] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[11:20:20] <kimundi> Are you doing something more low level?
[11:20:40] <nathan7> kernelmode-Z debug-info -O --target x86_64-intel-linux --lib -o $@ -c $<
[11:21:01] * flaper87 is curious to know what nathan7 is working on
[11:21:10] <kimundi> I have no idea what that means :O
[11:22:07] <nathan7> kernelness
[11:24:56] <kimundi> Now I can imagine a bit more what it means, but am still not completely sure. ;) Do you want to write an OS in Rust?
[11:25:05] <kimundi> Or, OS-kernel at least?
[11:25:10] <nathan7> kimundi: I decided to write a kernel, and because that's not quite insane enough by itself, I'm doing it in Rust
[11:25:20] <kimundi> Ah, okay
[11:25:43] *** Quits: pyrac (pyrac@3907364F.73C89388.AD05C589.IP) (Quit: pyrac)
[11:26:25] <flaper87> nathan7: lol at "insane enough by itself"
[11:26:36] <pnkfelix> nathan7: are you aware of this OS course: http://www.cs.virginia.edu/~evans/cs4414-fall2013/class-2-getting-started-with-rust.html
[11:26:51] *** Quits: huseby (huseby@moz-633A76FB.static.cust.telenor.com) (Ping timeout)
[11:27:19] <nathan7> pnkfelix: no, though cmr did mention an OS course
[11:27:20] <pnkfelix> nathan7: (though I do not know if they are planning to do a *kernel* as part of their Rust assignments)
[11:28:54] <pnkfelix> I just discovered that the prof for CS 4414 has posted the feedback from his students on Prob. Set 1 online
[11:29:00] <pnkfelix> lots of complaints
[11:29:11] <pnkfelix> (about rust and its poor documentation.  Not surprising.)
[11:29:20] <kimundi> pnkfelix: If it's anything like the OS course I had, then... no hell no hahaha.
[11:30:12] <nathan7> I think Rust is pretty well-suited for kernel development
[11:30:27] <nathan7> I think it's silly that we're using something as stone-age as C for the most critical component of an OS
[11:30:38] <kimundi> My OS course was basically "learn and use C to call old apis for low level stuff like semaphores an IPC"
[11:31:11] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[11:31:11] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/N7oMBQ
[11:31:11] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[11:31:36] <kimundi> nathan7: Agree with that, but Rust is still a few years to young for that to be something you can convince other of ;)
[11:31:44] <nathan7> kimundi: Sure
[11:31:52] <nathan7> kimundi: I did note the insanity of it
[11:32:16] <nathan7> part of the reason I'm doing this is that nobody else will do something this crazy
[11:32:21] <kimundi> haha
[11:32:24] <nathan7> and I think it's an interesting direction to take OSes in
[11:32:39] <flaper87> nathan7: do you have a repo for it ?
[11:32:40] <kimundi> It's certainly good for providing the devs with feedback for such things
[11:32:42] <nathan7> the task system is very well-suited to having safe multiprocessing
[11:32:51] <nathan7> flaper87: yes, not yet public
[11:33:01] <nathan7> flaper87: so far I have the x86-64 equivalent of rustboot
[11:33:03] <flaper87> nathan7: kk, I'm looking forward to it
[11:33:27] <flaper87> nathan7: I'm curious to see how you structured it and perhaps contribute
[11:33:52] * kimundi can't wait till we get fork-and-join operations
[11:33:59] <flaper87> kimundi: +1
[11:34:17] <flaper87> I do think channels could be improved a bit, in terms of memory usage
[11:34:29] <flaper87> there's a bug for that that brson pointed me to yesterday
[11:34:50] <nathan7> flaper87: Structure is.. lacking.
[11:34:59] <flaper87> nathan7: :D
[11:35:02] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[11:35:14] *** Quits: squiddy (squiddy@moz-AF1F09D5.adsl.alicedsl.de) (Ping timeout)
[11:36:06] <nathan7> I wanted to use vectors for the allocator, but I can't really have a stack-allocated vector there, it needs to be long-lived
[11:36:08] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[11:36:08] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/YFq00Q
[11:36:08] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[11:36:09] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[11:36:09] <ghrust> 01[13rust01] 15bors pushed 6 new commits to 06auto: 02http://git.io/DtZBZw
[11:36:09] <ghrust> 13rust/06auto 1421ce41d 15Huon Wilson: extra: use a mutex to wrap linenoise calls and make them threadsafe....
[11:36:09] <ghrust> 13rust/06auto 14fe03d82 15Huon Wilson: extra: stop rl from leaking each line that is read.
[11:36:10] <ghrust> 13rust/06auto 144ed5fcb 15Huon Wilson: extra: improvements & bug fixes to rl....
[11:36:12] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[11:36:45] *** Joins: [squiddy] (squiddy@moz-AF1F09D5.adsl.alicedsl.de)
[11:37:05] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[11:37:14] <dbaupp> flaper87: they allocate a box for each message :( (I guess that's the bug brson pointed you at?)
[11:37:22] <flaper87> dbaupp: correc
[11:37:24] <flaper87> dbaupp: correct
[11:37:27] <nathan7> dbaupp: What, why?!
[11:37:28] <flaper87> you commented on that
[11:37:33] * dbaupp did
[11:37:37] <flaper87> dbaupp: I'll read the pdf today
[11:37:42] <dbaupp> nathan7: because it's the easiest to implement
[11:37:47] <flaper87> I'd love to contribute changing the way that works
[11:38:20] <flaper87> plus, kinda sounds the right moment to move rt:comm under std/
[11:38:36] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[11:38:37] <flaper87> since std::comm is a wrapper around std::rt::comm
[11:38:40] <dbaupp> yeah
[11:38:47] <flaper87> which is confusing, btw
[11:38:49] <flaper87> :D
[11:39:01] <nathan7> dbaupp: I'm not certain what the primitive underlying this is (and I'll have to find out, whoo!), but it seems like boxing isn't that necessary
[11:39:24] <dbaupp> nathan7: an atomic queue is much easier as a linked list than as a vector backed one
[11:39:40] *** Joins: jaen (jaen@moz-E95588F0.neoplus.adsl.tpnet.pl)
[11:39:58] *** Joins: fyolnish (fyolnish@moz-A14E74F9.uqwimax.jp)
[11:40:27] <dbaupp> *much* easier, I could find literally one paper about a vector backed one (the link here https://github.com/mozilla/rust/issues/8568)
[11:40:33] *** Quits: [squiddy] (squiddy@moz-AF1F09D5.adsl.alicedsl.de) (Quit: Leaving)
[11:41:45] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[11:41:50] <nathan7> dbaupp: mhm
[11:42:03] <nathan7> dbaupp: yeah, I can see how now
[11:42:22] <nathan7> allocate a box and do a single atomic set
[11:42:46] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[11:42:59] <dbaupp> yeah
[11:43:44] <nathan7> beautifully simple and a tad ineficient
[11:44:14] <nathan7> I'm not even sure how to do allocation in the face of parallelism
[11:44:45] <nathan7> I could do some kind of global lock for now (yay more concurrency primitives to implement)
[11:44:45] <pnkfelix> dbaupp: that paper's insight about fetch-&-add is interesting.
[11:45:05] * flaper87 hasn't read that paper yet
[11:45:13] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[11:45:18] <dbaupp> nathan7: atomic instructions \o/
[11:45:28] <Amaranth> Oh sure if you only care about x86 such a thing gets easier
[11:45:47] <dbaupp> pnkfelix: which insight?
[11:45:47] <Amaranth> x86 and nearly sequentially consistent without doing any extra work
[11:45:55] *** Quits: jdm (jdm@moz-2C5514D1.lightspeed.sntcca.sbcglobal.net) (Input/output error)
[11:45:56] <Amaranth> s/and/is/
[11:46:30] <dbaupp> yeah
[11:46:50] *** Quits: vodik (simon@moz-CBE4BB13.cable.teksavvy.com) (Ping timeout)
[11:46:53] <pnkfelix> dbaupp: that fetch-&-add, despite being theoretically weaker than CAS (presumably because F&A has a finite consensus number?), has the advantage that it never fails.
[11:49:44] * dbaupp is reading http://www.cs.brown.edu/~mph/Herlihy91/p124-herlihy.pdf about consensus numbers
[11:49:54] <dbaupp> (you'll have to excuse my inexperience :) )
[11:51:54] <Thiez> we should get a hazard-pointer implementation in the runtime
[11:53:19] *** Joins: pyrac (pyrac@3907364F.73C89388.AD05C589.IP)
[11:54:39] <Thiez> they solve the ABA-problem and node retirement and do not require DCAS :)
[12:10:44] *** Joins: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au)
[12:12:16] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[12:13:46] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[12:15:48] <Thiez> but I think at this point fixing the lack of inlining would be the biggest improvement
[12:16:30] <pnkfelix> Thiez: ?  I'm ignorant, is #[inline] broken?
[12:18:35] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[12:20:15] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[12:20:18] *** bent|lunch is now known as bent
[12:20:41] *** Quits: KindOne (KindOne@9BA6A283.EA06E3F.34F73994.IP) (Ping timeout)
[12:20:49] <Thiez> pnkfelix: transmute is showing up when you profile rust code
[12:21:58] <pnkfelix> Thiez: hmm.  Okay I'll have to explore.
[12:22:04] <Thiez> strcat knows more
[12:22:19] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[12:22:23] <Thiez> it has something to do with an LLVM pass that is disabled because rustc generates invalid IR
[12:22:27] <Thiez> or something along those lines
[12:22:50] <pnkfelix> Thiez: so even changing cast.rs to use #[inline(always)] instead of #[inline] would not fix this case?
[12:23:00] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[12:23:00] <dbaupp> it can be fixed by -Z no-monomophic-collapse (or whatever it is)
[12:23:04] <pnkfelix> Thiez: (generating truly invalid IR sounds bad, of course)
[12:23:10] *** flaper87 is now known as flaper87|afk
[12:23:31] <Thiez> pnkfelix: I have no idea, but that isn't the "Right (tm)" way to do it :p
[12:23:40] <dbaupp> it's rustc generating undefined behaviour by merging the monomorphised version of functions that "do the same thing"
[12:24:04] <dbaupp> i.e. the specialisations of foo<T> for int and uint might happen to act the same, so they can be collapse
[12:24:30] <pnkfelix> dbaupp: And then LLVM refuses to inline the result?
[12:24:30] <dbaupp> but the way we do it is bad for LLVM, so it stops LLVM from doing many optimisations
[12:25:00] <dbaupp> pnkfelix: it just generally interferes with optimisations, I think (including inlining)
[12:25:05] * dbaupp looks for the bug
[12:26:06] <pnkfelix> dbaupp: Interesting.  (Also, apparently generating debug-info implies -Z no-monomorphic-collapse.)
[12:26:29] <Thiez> naturally
[12:26:48] <Thiez> or the debug-info couldn't distinguish between Foo<int> and Foo<uint>
[12:26:50] <dbaupp> https://github.com/mozilla/rust/issues/8651 is kinda related
[12:27:01] <dbaupp> (type-use is the rustc pass that is breaking things.)
[12:28:40] <dbaupp> I don't remember if that is the relevant bug: I vaguely remember one that's more specific, but I can't find it.
[12:29:15] <Seldaek> my main gripe with rust lately is that the name isn't a good fit for my bad accent. people always think I talk of REST when they are not familiar with rust.
[12:29:33] *** Joins: KindOne (KindOne@moz-272920E9.dynamic.ip.windstream.net)
[12:30:18] <Palmik> Hmm, interesting... when I use match { (/* some pattern */) => { /* code */ } } everything is fine. But as soon as I do '(/* some pattern */) if /* cond */ => ' I get 'cannot bind by-move into a pattern guard'
[12:30:30] <Palmik> (regarding some of the matches in /* some pattern */)
[12:31:33] *** flaper87|afk is now known as flaper87
[12:31:40] <dbaupp> pnkfelix, Thiez: ok, can't find any bug that's more relevant: if it exists, it's not tagged as I-slow or A-codegen.
[12:31:47] <Amaranth> Alright I think I have all of the window management, keyboard, and mouse events implemented correctly for rust-sdl2
[12:31:55] <Amaranth> Now for the joystick, controller, and touch events
[12:32:03] <dbaupp> Palmik: it would be unsafe
[12:32:26] <nathan7> Palmik: {} indicate a new scope, bit of a weird case here afaics
[12:32:48] <dbaupp> Palmik: because the guard could fail, and so it would have to move on to check the next pattern; but the matchee has been moved from (i.e. is now invalid) so matching on it is illegal
[12:33:18] <nathan7> ah
[12:33:19] <dbaupp> (could fail == cond is false, not `fail!`.)
[12:33:30] <Palmik> dbaupp: but why is not that the case even without the if?
[12:33:35] *** Quits: bent (chatzilla@FC9FC902.ED95B50E.EDDC15BA.IP) (Quit: ChatZilla 0.9.90.1-rdmsoft [XULRunner 22.0/20130619132145])
[12:33:56] <pnkfelix> dbaupp: maybe this: https://github.com/mozilla/rust/issues/8720 ?
[12:33:58] <Palmik> the guard could fail while matching just as well
[12:34:09] *** Joins: bent (chatzilla@moz-6F843AD8.static.cust.telenor.com)
[12:34:16] <pnkfelix> dbaupp: no wait, that is closed
[12:34:25] <dbaupp> Palmik: because `match foo { Foo(move) => { ... } Bar(alsomove) => { ... }` only "matches" once, where as the guard falls through to match again.
[12:34:44] <dbaupp> pnkfelix: yeah, I found that one, but it is, as you say, closed. 
[12:35:26] <Palmik> Hmm, weird. 
[12:35:38] <Palmik> Thanks though.
[12:37:26] <dbaupp> Palmik: basically; each arm is a like calling a function, i.e. ownership of `foo` gets transfer into it, and it can't be un-transfered.
[12:37:34] <dbaupp> oh, better example:
[12:38:33] <Amaranth> So I was sort of asking this yesterday but is there a safe way to do https://github.com/amaranth/rust-sdl2/blob/master/src/event.rs#L791 that isn't doing a match for ~250 entries?
[12:38:33] <dbaupp> `match foo { Foo(move) if move.deallocate() == Succeeded => { ... } Foo(move) => { /* what? */ } }` (deallocate would take self by-val.)
[12:38:43] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[12:39:20] <dbaupp> Amaranth: `assert!(low <= key < high)` at least
[12:39:36] <Amaranth> Yeah I suppose but the enum has holes
[12:39:42] <Palmik> I see, thanks.
[12:40:06] <dbaupp> Amaranth: ah
[12:40:19] <Amaranth> And goes from 0 to 1073742106 in 250 entries so they use holes freely
[12:40:26] <Amaranth> Presumably so they can add more stuff later
[12:40:34] <dbaupp> Amaranth: make the enum shorter so you're only matching on 240 entries? :P
[12:40:48] <dbaupp> (I think code-genning/macro-ing a match is the only safe way.)
[12:40:51] <Amaranth> I need some compiler code generation to do that for me
[12:41:22] <Palmik> BTW, what is the 'Rust way' to handle 'errors', say I have functions foo1, foo2, foo3 and bar. All return an Option of some type. The bar calls the foos, trying to 'unwrap' all the foos' results (if any of them is None, bar also returns None... much like the Maybe monad works in Haskell).
[12:41:36] <dbaupp> Amaranth: even just a python script/an external rust script (rust-http uses the latter)
[12:41:43] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[12:41:49] <pnkfelix> Palmik: http://static.rust-lang.org/doc/tutorial-conditions.html
[12:42:10] <pnkfelix> Palmik: (don't let the url fool you: its about Options+Results+Fail+Conditions)
[12:42:27] *** Joins: enomado (nomad@DB5C5EEB.5ED34291.AB610CFE.IP)
[12:42:40] <dbaupp> Palmik: `foo1().chain(|x| foo2().chain(|y| foo3()))` (chain == (>>=))
[12:42:59] <dbaupp> you can use some `do` sugar to make it less nested-closures too
[12:43:31] <pnkfelix> dbaupp: Good point.  The tutorial should probably mention that pattern for Option
[12:44:22] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[12:44:31] <dbaupp> (it's quite very ugly, unfortunately :( and not being able to shortcircuit with return in a closure makes it unworkable in some situations)
[12:45:53] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[12:46:08] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[12:46:08] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/DtZBZw
[12:46:08] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[12:46:46] *** Joins: aeqwa (aeqwa@moz-27C91E48.dsl.tropolys.de)
[12:47:02] <Palmik> If shortcircuiting is not a requirement, I think match (foo1(), foo2(), foo3()) { .. } is not that bad either
[12:47:15] <Palmik> I will take a look at the tutorial pnkfelix, thanks.
[12:47:25] *** Quits: mindcat (mindcat@5C1E3272.FBBDCC14.1A8D6442.IP) (Quit: Lost terminal)
[12:47:27] *** Joins: eholk (eholk@moz-F70D5031.hsd1.in.comcast.net)
[12:48:06] *** Quits: reyre (reyre@moz-89E9865B.com) (Quit: ZNC - http://znc.in)
[12:49:07] *** Joins: reyre (reyre@moz-89E9865B.com)
[12:51:05] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[12:51:06] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/lpRf3g
[12:51:06] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[12:51:07] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[12:51:07] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/3d2KuA
[12:51:07] <ghrust> 13rust/06auto 14d06595c 15Alex Crichton: Backport an LLVM fix to close #9117
[12:51:07] <ghrust> 13rust/06auto 14765e126 15bors: auto merge of #9118 : alexcrichton/rust/llvm-fix, r=sanxiyn...
[12:51:08] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[12:51:34] <Amaranth> Just realized I should probably allow getting scancodes too so yeah, time to turn to code generation
[12:52:28] *** Quits: barosl (barosl@3DE683B6.E551553C.7544CABF.IP) (Quit: ëžœë¤ì€ ì‡ í‡´í–ˆìŠµë‹ˆë‹¤.)
[12:53:18] *** Quits: ceninan (ceninan@moz-6BD43586.a370.priv.bahnhof.se) (Ping timeout)
[12:53:40] *** Quits: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au) (Quit: gavinb)
[12:58:48] *** Joins: SiegeLord (sl@moz-1DF56822.twcny.res.rr.com)
[13:01:22] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[13:04:14] *** Joins: maik (maik@moz-EEB9CEBB.dip0.t-ipconnect.de)
[13:04:39] <kimundi> dbaupp, Palmik: There could be/is/was an macro for Option chaining though.
[13:05:07] <kimundi> And note that it's probably going to be renamed to 'and_then' soon.
[13:06:06] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[13:06:06] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14765e126 to 140a2d3c5: 02http://git.io/N3iJvQ
[13:06:06] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[13:06:08] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[13:06:08] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/pYP4bg
[13:06:08] <ghrust> 13rust/06auto 14ef08b23 15Gareth Smith: Support character range patterns (e.g. [0-9], [a-z]), like other globs do.
[13:06:08] <ghrust> 13rust/06auto 143c17903 15bors: auto merge of #9131 : Dretch/rust/glob-range-patterns, r=alexcrichton...
[13:06:08] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[13:06:30] <dbaupp> eurgh, why are we calling it and_then?
[13:06:41] * dbaupp likes `bind` or >>= the most
[13:06:58] <nathan7> isn't this like, map?
[13:07:05] <kimundi> dbaupp: Result of merging the concepts of 'chain' and 'and_then' 
[13:07:28] <nathan7> (well, fmap)
[13:07:33] <kimundi> Sec, I'm looking up the PR
[13:08:06] <kimundi> https://github.com/mozilla/rust/pull/9115
[13:08:45] <nathan7> what exactly is the Default trait?
[13:08:55] <dbaupp> nathan7: no, it's monadic bind (`Option<T>.chain(&fn(T) -> Option<U>) -> Option<U>`)
[13:09:03] <nathan7> 8ah
[13:09:07] <kimundi> dbaupp: Basically, Option currently has the function 'or', that get's used like this: opt1.or(opt2). It picks the leftmost Some value
[13:09:08] <nathan7> *ah
[13:09:10] <dbaupp> (fmap is just Option<T>.fmap(&fn(T) -> U) -> Option<U>)
[13:09:26] <nathan7> dbaupp: ah - flatMap
[13:09:36] <kimundi> erickt first added a 'or_else' which takes an closure to call in case the first one is None
[13:09:37] <dbaupp> kimundi: "renamed Option::chain* and Result::chain* to and_then and or_else to avoid the eventual collision with Iterator.chain." ah!
[13:09:42] <nathan7> sorry, forgot it was spelled bind / >>= in haskell-land
[13:09:49] <kimundi> dbaupp: Well, that too ;9
[13:09:50] <dbaupp> nathan7: yup
[13:10:14] <kimundi> And once we had 'or' and 'or_else' It made sense to have 'and' and 'and_then'
[13:10:16] *** Joins: mrordinaire (Mibbit@1143DEE0.A607747.FD383126.IP)
[13:10:52] <kimundi> At this point 'and_then' was close enough to chain that keeping them seperate made no difference any more
[13:11:51] <dbaupp> kimundi: yeah, makes sense
[13:12:07] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[13:12:13] <kimundi> op1().and_then(|op1_res| op2(op1_res)).and_then(|op2_res| op3(op2_res)).or_else(|op3_err| cleanup(op3_err))
[13:12:41] <pnkfelix> i feel like it is unfortunate that some of these back-story details are left out (or at least hard-to-derive) from the Pull Request alone
[13:12:55] <Palmik> Would it be possible to have a macro that would take an Option and either evaluate to the unwrapped value or return (from the function where the macro is used) None?
[13:13:00] <nathan7> pnkfelix++
[13:13:04] <pnkfelix> but maybe it is self-evident after sufficient staring...
[13:13:10] <kimundi> Ha, or even shorter: op1().and_then(op2).and_then(op3).or_else(cleanup)
[13:13:30] <nathan7> Palmik: so and_then without the closure?
[13:13:40] *** Quits: jfbk (jfbk@moz-EEA9CFB3.nyc.res.rr.com) (Quit: )
[13:13:52] <doomlord> that looks clearer than 'bind'. in C++, there's a "bind" that does something like partial function application
[13:13:56] <dbaupp> Palmik: `macro_rules! run_opt( ($e:expr) => { match $e { Some(e) => e, None => return None } } )`
[13:14:07] <kimundi> pnkfelix: It's hard to condense a spares IRC discussion carried out over several days into useful notes ;)
[13:14:31] <dbaupp> rusti: macro_rules! run_opt( ($e:expr) => { match $e { Some(e) => e, None => return None } } ) fn foo(x: Option<uint>) -> Option<uint> { Some(run_opt!(x) + 1) }
[13:14:35] -rusti- ()
[13:14:37] <pnkfelix> kimundi: maybe, but if its hard now, its going to be impossible a month from now.  :(
[13:14:44] <kimundi> True
[13:14:46] <dbaupp> rusti: macro_rules! run_opt( ($e:expr) => { match $e { Some(e) => e, None => return None } } ) fn foo(x: Option<uint>) -> Option<uint> { Some(run_opt!(x) + 1) } (foo(Some(1)), foo(None))
[13:14:49] -rusti- (Some(2u), None)
[13:14:52] <nathan7> doomlord: like JS's bind :D
[13:14:54] *** Quits: maik (maik@moz-EEB9CEBB.dip0.t-ipconnect.de) (Ping timeout)
[13:15:02] <dbaupp> Palmik: rusti's output^
[13:15:27] <doomlord> "bind" parameters to a function..)
[13:15:43] <kimundi> Palmik, dbaupp: Is it necessarry to have a return inside the chain? Can't you just handle the case where the cain evaluates to None? Or is it about returning information from inside the closure
[13:16:33] <dbaupp> kimundi: I believe it's about flattening a .chain tower into linear code by short-circuiting straight out of the enclosing function on None
[13:16:35] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[13:16:35] <Palmik> dbaupp: Thanks! That seems more natural in Rust than the closures to me.
[13:16:42] <Palmik> It's like do notation.
[13:17:10] <kimundi> dbaupp: But what does that buy you other than skipping a small number of None-propagations?
[13:17:16] <dbaupp> kimundi: i.e. `let foo = run_opt!(bar()); let qux = run_opt!(baz(foo))`
[13:17:30] <dbaupp> rather than `bar().chain(|foo| baz(foo))`
[13:17:34] <Palmik> Yes, exactly.
[13:17:38] *** Joins: ceninan (ceninan@moz-6BD43586.a370.priv.bahnhof.se)
[13:17:39] <kimundi> Ah, a macro like haskells do? That I'm all for
[13:17:47] <dbaupp> kimundi: not really
[13:17:58] <Palmik> This run_opt! is much like "<-" in do notation.
[13:18:07] <dbaupp> yeah, but not quite as general
[13:18:14] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Ping timeout)
[13:18:32] <dbaupp> (i.e. it doesn't work in an arbitrary expression, because it returns out of the entire function)
[13:18:56] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[13:18:57] * dbaupp did actually write a do-notation syntax extension that desugared to .chain calls a while ago
[13:19:44] <kimundi> ah, so run_opt!() == unwrap_or_return!() ?
[13:19:49] *** Joins: Larry (larryfox@moz-343B6F0C.nyc.biz.rr.com)
[13:20:05] *** Quits: rusti (rusti@moz-61B073BC.cpe.net.cable.rogers.com) (Ping timeout)
[13:20:18] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[13:20:26] *** Joins: rusti (rusti@moz-61B073BC.cpe.net.cable.rogers.com)
[13:20:36] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[13:20:44] <Palmik> Yes.
[13:21:02] *** Joins: maik (maik@moz-EEB9CEBB.dip0.t-ipconnect.de)
[13:22:12] <kimundi> Okay, I see how that could be useful
[13:24:45] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[13:25:41] *** Quits: Infiltrator (Infiltrato@4669028E.25A9890C.4B4F1E7A.IP) (Ping timeout)
[13:26:03] *** Joins: Infiltrator (Infiltrato@4669028E.25A9890C.4B4F1E7A.IP)
[13:26:58] *** Quits: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Ping timeout)
[13:26:59] <bjz_> Infiltrator: how's the infiltration going?
[13:27:14] <mrordinaire> dbaupp: could you please suggest any tools to debug rusti segfaulting?
[13:27:39] *** Joins: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[13:27:40] <dbaupp> mrordinaire: gdb
[13:28:26] <mrordinaire> dbaupp: any tool to detect memory overrun?
[13:28:34] *** Joins: msingle1 (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[13:28:57] <dbaupp> valgrind? but I don't think valgrind likes rust applications much at the moment
[13:29:34] *** Joins: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[13:30:09] *** Quits: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Ping timeout)
[13:30:16] *** Quits: bent (chatzilla@moz-6F843AD8.static.cust.telenor.com) (Quit: ChatZilla 0.9.90.1-rdmsoft [XULRunner 22.0/20130619132145])
[13:30:45] <dbaupp> mrordinaire: https://gist.github.com/huonw/9c94475dff985cebd5de is the tail end of the valgrind output of `valgrind rusti` (and then typing `1` at the rusti prompt)
[13:30:56] <Thiez> rusti: 0 as *5 // <- Perhaps a better error message here (of course it's a silly mistake to make)?
[13:30:57] -rusti- <anon>:5:15: 5:16 error: expected type, found token LIT_INT_UNSUFFIXED(5i64)
[13:30:57] -rusti- <anon>:5          0 as *5 // <- Perhaps a better error message here (of course it's a silly mistake to make)?
[13:30:57] -rusti-                         ^
[13:30:57] -rusti- application terminated with error code 101
[13:31:03] *** Quits: msingle1 (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Quit: msingle1)
[13:31:07] *** Joins: bent (chatzilla@FC9FC902.ED95B50E.EDDC15BA.IP)
[13:31:50] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Ping timeout)
[13:32:16] <mrordinaire> dbaupp: it's different on mine. rusti on mine fails from a call in dlopen()
[13:32:28] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[13:33:32] <dbaupp> mrordinaire: platform?
[13:33:40] <dbaupp> mrordinaire: (I'm x86-64 linux)
[13:33:58] <mrordinaire> dbaupp: x86_64 linux (ArchLinux)
[13:34:06] <mrordinaire> dbaupp: http://mibpaste.com/DElSXQ any clue on this?
[13:34:29] <dbaupp> gdb backtrace for me https://gist.github.com/huonw/e4e2f108be6a007ce2ff
[13:34:39] *** Joins: Sorella (queen@9D963F5D.DF5D8AE7.54BCAB54.IP)
[13:34:48] <dbaupp> mrordinaire: no clue at all!
[13:35:00] <mrordinaire> dbaupp: yes, same thing
[13:35:07] <dbaupp> mrordinaire: in any case, it's my bed time. good luck. :)
[13:35:08] <mrordinaire> dbaupp: :(
[13:35:38] <pnkfelix> Thiez: You want a better error from the parser, right?
[13:36:30] <Thiez> not so much 'I want' as 'I think it might be nice'
[13:36:35] <pnkfelix> Thiez: (IMO the error there is not that bad â€¦ its telling you it expected a type, not an integer literal.  but maybe the presentation is a bit too obscure?)
[13:36:58] *** Joins: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP)
[13:37:04] <Thiez> it's obvious what you did wrong, but the message isn't very nice
[13:37:08] <pnkfelix> Thiez: (the "5" part of it admittedly gets a little obscured behind  all the "LIT_INT_UNSUFFIXED(5i64)")
[13:37:37] <pnkfelix> Thiez: would you have understood: "error: expected type, found token 5" ?
[13:37:56] <Thiez> I understand either, but I think that would be better
[13:38:10] <pnkfelix> Thiez: (or "error: expected type, found 5" ?  But then as you remove more context, you risk making it error less understandable in some casesâ€¦)
[13:38:29] <Thiez> do we have a assert_eq! that instead tests for inequality?
[13:38:31] <pnkfelix> Thiez: right, sorry, did not mean to imply you did not understand the original message
[13:38:44] <Thiez> :p
[13:38:45] <pnkfelix> Thiez: Just trying to better understand what would be easier to understand.
[13:38:45] <mrordinaire> dbaupp: which distro are you using?
[13:39:07] <Thiez> well it doesn't matter that much
[13:39:28] <Thiez> any person that can understand ~/@/& pointers will probably understand that error message.
[13:41:37] <kimundi> "expected type, for generic integer literal 5"
[13:41:52] <kimundi> found*
[13:42:00] *** Quits: fabiand (fabiand@moz-EDBC5F57.adsl.alicedsl.de) (Quit: Verlassend)
[13:43:33] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[13:43:36] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[13:44:26] *** Quits: maik (maik@moz-EEB9CEBB.dip0.t-ipconnect.de) (Ping timeout)
[13:44:51] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[13:44:56] <erickt1> kimundi / dbaupp: thanks for the reviews so far. I'll update 9115 in a sec. I got an extra question though. Do either of you like the names `Option.and_then(fn() -> T)` and `Option.or_else(fn() -> T)`? Or would it be better to stick with `and_with` and `or_with`? We tend to use `with_` or `_with` to signify a fn takes a closure 
[13:45:48] <kimundi> erickt1: Oh, are you planning to change it from using the then and else suffix?
[13:45:57] <erickt1> yeah
[13:46:02] <pnkfelix> kimundi: okay, I'll see how hard something like that would be to put into parser.rs.  We might want a "human_readable() -> ~str" method on ast nodes.  :)
[13:46:35] <erickt1> kimundi: I'm torn. .and_then() feels better to me, but .and_with() seems more consistent
[13:46:40] <pnkfelix> (lexical tokens I mean, not ast nodes)
[13:46:55] <kimundi> erickt1: Well, then I would keep only and_with and or_with (and of course pass the values as parameter to the closure where possible)
[13:47:14] <kimundi> yeah, else and then seem to be nice
[13:47:18] <kimundi> nicer*
[13:47:38] <erickt1> kimundi: are you suggesting dropping `Option.and(T)`?
[13:47:42] <kimundi> No
[13:47:44] *** Joins: fabiand (fabiand@moz-EDBC5F57.adsl.alicedsl.de)
[13:48:18] <kimundi> Sounded like you wanted and_then(fn() -> T) and and_with(fn(T) -> U) for a moment there
[13:48:31] *** Quits: naq (naq@D5C2D2DF.E4265FCD.E481B5B.IP) (Ping timeout)
[13:48:42] <pnkfelix> erick: I see some examples of `with_*` for things that take closures, but I have not yet found a `*_with` case via skimming. . . do you have an example on hand?
[13:48:49] <pnkfelix> erickt1: ^
[13:49:01] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[13:49:33] <pnkfelix> erickt1: (that is implicitly saying that I would be fine with leaving the API as it, no change to `_with()`)
[13:49:33] <erickt1> kimundi: oh, no, just one or the other :)
[13:50:07] <kimundi> One could make the argument that the 'with' names imply the closure allways being part of the function call, while 'else' and 'then' get the fact that the closure is only called conditionally across
[13:50:59] <erickt1> pnkfelix: hrm, you're right
[13:51:54] <kimundi> else and then certainly reads nice: op1().and_then(op2).and_then(op3).or_else(cleanup)
[13:52:01] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Ping timeout)
[13:52:05] <erickt1> it seems only "with_" prefixes are used to imply a closure
[13:52:26] * pnkfelix had inferred that the .with_* was a tip of the hat to the various call-with- functions from Scheme.  call-with-current-continuation, call-with-input-file, etc
[13:53:05] <kimundi> erickt1: Would keep it at 'else' and 'then', then.
[13:53:14] *** Joins: Jesin (Jessin_@moz-14FD08AF.cc.lehigh.edu)
[13:53:22] <erickt1> okay, you two convinced me. thanks! 
[13:53:30] <erickt1> I'll leave it and_then and or_else
[13:53:36] <kimundi> :)
[13:53:44] <Palmik> Or perhaps .otherwise instead of .or_else
[13:53:59] <pnkfelix> Palmik: that loses the paralllel with .and_then
[13:54:23] <kimundi> And the parallel to 'or'
[13:54:35] <pnkfelix> kimundi: good point.  :)
[13:54:50] <pnkfelix> kimundi: a more important point, even.  :)
[13:54:55] *** Quits: pyrac (pyrac@3907364F.73C89388.AD05C589.IP) (Quit: pyrac)
[13:55:38] <erickt1> r? https://github.com/mozilla/rust/pull/9115
[13:56:25] <kimundi> Three nice axis: or/and work with the Self type, unwrap_ prefix works with contained value, _else/_then suffix implies lazy evaluation/control flow
[13:57:38] *** Joins: pyrac (pyrac@3907364F.73C89388.AD05C589.IP)
[13:57:49] * kimundi has sadly no review power - And shouldn't have any, seeing how often he has to fixup a PR he made himself
[13:57:55] <erickt1> heh
[13:58:23] *** Joins: lkuper (lkuper@moz-D862222C.dhcp-bl.indiana.edu)
[13:58:37] <pnkfelix> erickt1: no more chain_ref ?
[13:59:11] *** Quits: lazyden (lazyden@47A36AC9.35CBBBD0.F246D1AF.IP) (Quit: lazyden)
[13:59:36] <erickt1> pnkfelix: no chains in general :)
[13:59:42] <kimundi> Ah, right. chain_ref and chain_mut_ref seem to have died? Kinda makes sense, as I don't see them fit in the new naming scheme...
[14:00:11] <pnkfelix> erickt1: let me rephrase: Some people may not be thrilled by replacing one liners by K>1-liners
[14:00:25] <kimundi> Isn't chan_ref ==  map? Or was there something the one could do but not the other?
[14:00:32] *** Joins: hoverbear (andrew@moz-86FCBF4B.gv.shawcable.net)
[14:01:12] <erickt1> Oh I know. I didn't want to make `and_then` take a closure because almost no one uses that pattern. I suppose I could add a `and_then_ref` and `and_then_mut_ref`
[14:01:19] *** Joins: lmandel (lmandel@13F2CEC5.7672369.D8E68FF6.IP)
[14:01:53] <kimundi> Probably better to keep the old semantics around for that case, yeah
[14:01:56] <pnkfelix> kimundi: map takes a T -> U, not a T -> Option<U>
[14:02:05] <kimundi> ah, right
[14:02:14] <pnkfelix> kimundi: (well, I left out the &'s, but you get it)
[14:03:30] <erickt1> pnkfelix: for what it's worth, we only had two calls each for `chain_ref` and `chain_mut_ref`
[14:03:41] <pnkfelix> erickt1: I should have put my note on the PR itself; I couldn't resist asking in IRC, but doing so exacerbates the problem I noted earlier (about failing to keep good records of decisions in PR's)
[14:04:01] <kimundi> hm, with iterators and Iterable map would look like this: Some(5).map(|x| Some(x + 10)).next()
[14:04:12] <pnkfelix> erickt1: (i'll switch to throwing my note on the PR itself)
[14:04:28] <kimundi> wait that's wrong... Ah whatever
[14:04:32] <erickt1> pnkfelix: ok
[14:06:03] <kimundi> erickt1: "Oh I know. I didn't want to make `and_then` take a closure because almost no one uses that pattern" - I assume you meant 'borrowed pointer' instead of 'closure' there?
[14:06:50] *** Quits: pyrac (pyrac@3907364F.73C89388.AD05C589.IP) (Ping timeout)
[14:06:51] *** Quits: noam_ (noam@F6B530A7.720527A7.416762B.IP) (Connection reset by peer)
[14:08:30] <erickt1> kimundi: I mean that almost all calls of .chain, which moved the wrapped value into the closure, and only a few used .chain_ref, which passes in a reference to the closure
[14:09:52] *** Quits: Mindless` (mindless@moz-9C38D3B4.net) (Ping timeout)
[14:09:53] <kimundi> Okay, thought so.
[14:10:13] <kimundi> carry on then :)
[14:10:50] <erickt1> pnkfelix: I see 2 users of .chain_ref also in servo, but most are .chain
[14:11:53] *** Joins: Mindless` (mindless@moz-9C38D3B4.net)
[14:13:35] *** Joins: noam (noam@F6B530A7.720527A7.416762B.IP)
[14:13:56] *** Quits: Florob (Florob@moz-39532932.de) (Client exited)
[14:14:17] *** Joins: Lovot (root@AE31FB56.8153C3BF.F3C9A2D9.IP)
[14:14:47] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[14:17:16] *** Joins: eagen (eagen@8737942B.7A99C13A.B7961A98.IP)
[14:17:17] *** jorendorff_away is now known as jorendorff
[14:18:24] *** Joins: jgilbert (jgilbert@40BD3B76.2AD327F9.973C8D27.IP)
[14:19:15] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[14:20:56] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[14:21:07] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[14:21:07] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/pYP4bg
[14:21:07] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[14:21:15] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[14:22:06] *** Quits: eholk (eholk@moz-F70D5031.hsd1.in.comcast.net) (Quit: eholk)
[14:25:24] *** Quits: untothebreach (paul@15A17709.47300931.30F15291.IP) (Quit: leaving)
[14:26:06] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[14:26:06] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/bfCxwg
[14:26:06] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[14:26:08] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[14:26:08] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/wavbVw
[14:26:08] <ghrust> 13rust/06auto 14a835995 15Tim Kuehn: Rendezvous stream for synchronous channel messaging
[14:26:08] <ghrust> 13rust/06auto 14137b31e 15bors: auto merge of #8908 : tikue/rust/master, r=anasazi...
[14:26:09] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[14:26:26] *** Joins: eholk (eric@moz-F70D5031.hsd1.in.comcast.net)
[14:31:11] *** Quits: fyolnish (fyolnish@moz-A14E74F9.uqwimax.jp) (Client exited)
[14:34:01] <erickt1> pnkfelix: replied to your comment
[14:38:16] *** Quits: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net) (Quit: echristo)
[14:38:24] *** Quits: Jesin (Jessin_@moz-14FD08AF.cc.lehigh.edu) (Ping timeout)
[14:40:38] *** Joins: Skif (emschwar@moz-CA025D57.ip.mcleodusa.net)
[14:41:43] <kimundi> He, I just had an idea about the as_/to_/into_ naming scheme: You usually want 'move' or 'reference', with 'reference to make a copy' being the one you should use less.
[14:42:29] <kimundi> How about: 'as_' per reference, 'to_' moves, 'asto_' references and copies? No one said we're not allowd to invent words :P
[14:43:06] <erickt1> heh
[14:43:25] <kimundi> (&[1, 2, 3]).asto_owned() - certainly needs to get used to, though :P
[14:43:50] <erickt1> the counter argument to that is .to_str(), which is super common but needs to make a copy from a reference
[14:44:13] <kimundi> erickt1: strcat's counter-counter argument would be that to_str needs to dies anyway
[14:44:20] <erickt1> that's true :)
[14:44:31] <kimundi> And be replaced with something writer based
[14:44:49] <erickt1> maybe once to_str goes away we could swap the meaning of `to_` to move, and use `into_` for a reference-copy
[14:45:21] <kimundi> hm, into seems thr wrong word for that though
[14:45:50] <kimundi> copy_to seems better
[14:46:33] <kimundi> [1, 2, 3].as_str(), (~[1, 2, 3]).to_str(), [1, 2, 3].copy_to_str()
[14:47:04] <erickt1> maybe. but I guess to_str() is not really copying, it's more allocating
[14:47:13] <kimundi> then again, is it a copy if the function reads all data and constructs something new based on that, without actually being the same?
[14:47:22] <erickt1> copy_to_str seems like it's copying `self`
[14:47:44] <erickt1> kimundi: yeah
[14:47:54] <kimundi> refto_str() ?
[14:48:04] <kimundi> actually, that sounds nice
[14:48:11] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[14:48:14] <kimundi> "foo".refto_str()
[14:48:26] <erickt1> this is a case where from_foo makes sense. You'd do `let x: ~str = from_vec(~[1,2,3])` or something
[14:48:56] <kimundi> Except that that's ugly :P 
[14:49:38] <erickt1> kimundi: refto_str, or from_vec?
[14:49:52] <kimundi> from_vec
[14:50:11] <kimundi> I mean, for starters it really would have to be
[14:50:25] <kimundi> Str::from(foo)
[14:50:42] *** Quits: jaen (jaen@moz-E95588F0.neoplus.adsl.tpnet.pl) (Ping timeout)
[14:50:59] <kimundi> That is, associated function for a string trait 
[14:51:14] *** Joins: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca)
[14:51:45] <erickt1> or a `StrFrom.str_from` trait/method.
[14:52:05] <kimundi> And deep nesting of function calls get confusing and unreadable... I get that method chaining is not the best solution either, but it seems to be better for such cases
[14:52:20] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[14:52:22] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[14:54:51] *** Quits: hoverbear (andrew@moz-86FCBF4B.gv.shawcable.net) (Quit: hoverbear)
[14:56:18] *** Joins: tgummerer (tgummerer@51D3B54.FEF996EA.EA6FEF3D.IP)
[14:56:32] <erickt1> kimundi: I got to run, but I can continue chatting about this in an hour
[14:56:40] <kimundi> Sure
[14:56:48] <kimundi> For reference: https://github.com/mozilla/rust/issues/7151
[14:57:07] <kimundi> But I think there is also an other issue about that... 
[14:58:02] *** Quits: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[14:58:03] *** Joins: wil (wil@55887F69.EBD92228.DDE5D3F6.IP)
[15:05:14] *** Joins: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP)
[15:05:23] *** Joins: Scriptor (historium@moz-E06F46F0.corp.bitshelter.com)
[15:05:31] <erickt1> kimundi: back for a sec :) What about `.make_str()`?
[15:06:01] <erickt1> It's short and `make` sounds like something is being constructed
[15:07:02] *** Quits: Ralith (ralith@114DA04D.CD83ED0A.BCDF04A6.IP) (Ping timeout)
[15:09:58] *** Joins: jstevans (Instantbir@52B65EC3.599F34EC.DDE5D3F6.IP)
[15:10:01] <kimundi> hm... Doesn't really fit with the other thogh. to_str, as_str, into_str all make a str in a sense
[15:11:44] *** Quits: aeqwa (aeqwa@moz-27C91E48.dsl.tropolys.de) (Ping timeout)
[15:12:50] <erickt1> well, yes, technically. I do like .make_str() better than .refto_str() though
[15:14:02] <kimundi> D:
[15:14:02] *** Quits: mrordinaire (Mibbit@1143DEE0.A607747.FD383126.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[15:14:22] <kimundi> Someone closed an issue right under my feed as I was commenting! ;)
[15:14:42] <erickt1> kimundi: btw, I just stumbled upon https://github.com/mozilla/rust/issues/7151. Was that what you were commenting on?
[15:14:42] <kimundi> (Thanks for linking to the better one, would have forgotten to look for it)
[15:14:45] <erickt1> :)
[15:15:06] <erickt1> kimundi: actually yours was first. I should have looked for yours before making mine :)
[15:15:16] *** Quits: eholk (eric@moz-F70D5031.hsd1.in.comcast.net) (Quit: Konversation terminated!)
[15:17:24] *** Quits: SiegeLord (sl@moz-1DF56822.twcny.res.rr.com) (Quit: Leaving)
[15:17:49] <kimundi> mine is 7151, yours 7087. I think you where first
[15:18:01] <erickt1> you're right :)
[15:19:05] *** Joins: jeaye (Jeaye@moz-34FEF2BB.hsd1.ca.comcast.net)
[15:19:58] *** Quits: wil (wil@55887F69.EBD92228.DDE5D3F6.IP) (Quit: Lost terminal)
[15:20:44] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[15:21:11] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[15:22:51] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Ping timeout)
[15:22:59] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[15:23:42] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[15:25:17] <kimundi> erickt1: Commented there
[15:25:44] *** Joins: kij (Mibbit@moz-5E180F75.mobile.3.dk)
[15:25:47] <erickt1> kimundi: cool :) Now I'm really off. later :)
[15:25:58] <kimundi> bye! :)
[15:26:43] *** Joins: pyrac (pyrac@moz-22054CAF.w83-205.abo.wanadoo.fr)
[15:29:36] *** Quits: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[15:30:02] *** Quits: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk) (Client exited)
[15:31:27] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[15:32:15] <kij> o/  what would i be looking for, to spawn the function runme()  if  i have the string "runme"  ?
[15:32:32] <cmr> kij: you want to call a function given its name as a string?
[15:32:39] <kimundi> define "spawn" is this context
[15:33:25] <kimundi> match s { "runme" => runme(), "callme" => callme(), "invokeme" => invokeme() }
[15:34:07] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[15:34:25] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[15:34:57] <kimundi> Function names are statically used at compile time, and unimportant at runtime. The only way to make that dynamic is to stuff a HashMap full of string keys and closures/function pointers
[15:35:05] *** Joins: osa1 (uid13910@moz-5F4AA75A.irccloud.com)
[15:35:08] <cmr> yeah, that's the only real way to do it, without std::unstable::dynamic_lib
[15:36:05] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[15:36:05] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/wavbVw
[15:36:05] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[15:36:07] * kimundi soo wants to start playing around with dynamic_lib, and see if he can make it load rust crates. But he doesn't have time for that till next month...
[15:36:12] *** Joins: miza (miza@moz-4DD51325.home.otenet.gr)
[15:36:58] *** Joins: AutomatedTester (David@moz-DB4A9C19.scl3.mozilla.com)
[15:37:22] <kij> Ok, thank you very much. I'll make the hashmap. Dont think i am smart enough for the dl stuff.  
[15:37:35] <osa1> I already have latest LLVM built and installed in my system, why does Rust Makefile download and compile it again?
[15:37:38] *** Joins: five (five@C7B63E75.F23D0472.4DD432BA.IP)
[15:37:53] <kimundi> Don't worry, the dl stuff itself is not ready anyway :)
[15:39:04] <Amaranth> osa1: It's a patched one
[15:39:06] <kimundi> osa1: Because rust uses it's own patches on top of that. The longterm goal is to make it possible to use the official llvm, but upstreaming the patches takes time, and we still make changes, so it's not really something that can reliably be done before the language is stable
[15:40:00] <kimundi> The good news is that you only need to rebuild llvm if we changed something in it - you can update the normal rust sources all you want and it won't rebuild llvm all the time
[15:40:00] *** Quits: five (five@C7B63E75.F23D0472.4DD432BA.IP) (Connection reset by peer)
[15:41:06] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[15:41:06] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/nVYx7w
[15:41:06] <ghrust> 13rust/06auto 14cbe79bb 15Luqman Aden: librust: Remove unnecessary workaround. Closes #7617
[15:41:06] <ghrust> 13rust/06auto 145f97dbe 15bors: auto merge of #9134 : luqmana/rust/i7617, r=alexcrichton
[15:41:06] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[15:41:50] *** Joins: ozten (ozten@moz-DD3B00B4.hsd1.wa.comcast.net)
[15:47:11] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[15:50:49] <osa1> okay, thanks
[15:51:23] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[15:53:39] *** jorendorff is now known as jorendorff_away
[15:54:43] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[15:56:40] *** jorendorff_away is now known as jorendorff
[15:56:46] *** Quits: clements (clements@moz-BEE8D50A.dsl.snlo01.pacbell.net) (Ping timeout)
[15:57:21] *** Joins: echristo (echristo@DCF57675.D6CCE4AE.77834EAA.IP)
[15:58:09] *** Joins: valenting (Thunderbir@7658A01E.84D5EFD5.FB866788.IP)
[15:58:57] *** Joins: maik (maik@moz-EEB9CEBB.dip0.t-ipconnect.de)
[15:59:45] *** Joins: nano (nano@moz-74CAD1CA.superkabel.de)
[16:01:19] *** Joins: clements (clements@moz-BEE8D50A.dsl.snlo01.pacbell.net)
[16:01:22] *** Quits: Peng (mnordhoff@moz-D5175E95.mattnordhoff.net) (Ping timeout)
[16:02:57] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[16:02:58] *** ChanServ sets mode: +o tjc
[16:03:54] *** Joins: hoverbear (andrew@EBFA78B5.F19E5E7B.E74D50F2.IP)
[16:05:35] *** Quits: maik (maik@moz-EEB9CEBB.dip0.t-ipconnect.de) (Ping timeout)
[16:06:56] *** Joins: jstevans1 (Instantbir@52B65EC3.599F34EC.DDE5D3F6.IP)
[16:06:56] *** Quits: jstevans (Instantbir@52B65EC3.599F34EC.DDE5D3F6.IP) (Connection reset by peer)
[16:06:59] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[16:06:59] *** ChanServ sets mode: +ao brson brson
[16:08:58] *** Quits: CanhtTak (CanhTak@moz-E9D07AD7.wl.t.ulaval.ca) (Quit: CanhtTak)
[16:09:10] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Ping timeout)
[16:09:47] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[16:10:11] *** Joins: jstevans (Instantbir@2EEF27C6.B9AD9095.DDE5D3F6.IP)
[16:11:05] *** Joins: lbergstrom (Adium@moz-BBE3ABD.mv.mozilla.com)
[16:11:26] *** Joins: ww (Mibbit@moz-DFAED48A.lightspeed.sntcca.sbcglobal.net)
[16:11:28] *** Quits: jstevans1 (Instantbir@52B65EC3.599F34EC.DDE5D3F6.IP) (Ping timeout)
[16:11:33] *** Joins: jstevans1 (Instantbir@331A6A23.96F115D7.DDE5D3F6.IP)
[16:11:46] *** Quits: jstevans (Instantbir@2EEF27C6.B9AD9095.DDE5D3F6.IP) (Connection reset by peer)
[16:12:08] *** Joins: jstevans (Instantbir@2EEF27C6.B9AD9095.DDE5D3F6.IP)
[16:12:29] <ww> rusti: bytes!("abc")
[16:12:29] -rusti- &[97u8, 98u8, 99u8]
[16:12:55] *** Joins: Kruppe (user@moz-4DDA8AB8.uwaterloo.ca)
[16:13:10] <kimundi> rusti: bytes!("foo\x00")
[16:13:10] -rusti- &[102u8, 111u8, 111u8, 0u8]
[16:13:13] *** Quits: jstevans1 (Instantbir@331A6A23.96F115D7.DDE5D3F6.IP) (Ping timeout)
[16:13:18] <kimundi> rusti: bytes!("foo", 0)
[16:13:19] -rusti- &[102u8, 111u8, 111u8, 0u8]
[16:13:44] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[16:13:51] *** Joins: jstevans1 (Instantbir@FCA484B3.117F92C2.B7830B68.IP)
[16:14:39] *** Quits: jstevans (Instantbir@2EEF27C6.B9AD9095.DDE5D3F6.IP) (Ping timeout)
[16:15:21] *** Joins: jstevans (Instantbir@5F05243E.9E5415FF.DDE5D3F6.IP)
[16:15:54] *** Joins: jstevans2 (Instantbir@8E2664B3.9875BCA6.DDE5D3F6.IP)
[16:16:20] *** cade is now known as cade_away
[16:16:21] *** Quits: jstevans1 (Instantbir@FCA484B3.117F92C2.B7830B68.IP) (Ping timeout)
[16:16:37] *** Quits: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Bye!)
[16:16:55] *** Quits: bent (chatzilla@FC9FC902.ED95B50E.EDDC15BA.IP) (Quit: ChatZilla 0.9.90.1-rdmsoft [XULRunner 22.0/20130619132145])
[16:17:01] *** Quits: jstevans (Instantbir@5F05243E.9E5415FF.DDE5D3F6.IP) (Ping timeout)
[16:17:17] *** Joins: strcat (strcat@moz-61B073BC.cpe.net.cable.rogers.com)
[16:17:37] *** Joins: Florob (Florob@moz-39532932.de)
[16:17:43] <strcat> acrichto: any luck with that sret thing?
[16:17:50] *** Joins: Peng (mnordhoff@moz-D5175E95.mattnordhoff.net)
[16:17:58] <acrichto> strcat: didn't get a chance to investigate further :(
[16:18:04] *** cade_away is now known as cade
[16:18:39] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[16:18:56] <strcat> acrichto: where exactly did you pinpoint it as dying?
[16:19:08] <acrichto> right after annihilation
[16:19:20] <acrichto> it was in Local::borrow for Task
[16:19:22] *** Quits: clements (clements@moz-BEE8D50A.dsl.snlo01.pacbell.net) (Ping timeout)
[16:20:09] *** Joins: maik (maik@moz-3F2CDB33.dip0.t-ipconnect.de)
[16:20:10] <acrichto> cleanup::annihilate => each_live_alloc => local_heap::live_allocs => Local::borrow => death
[16:21:14] *** Quits: Kruppe (user@moz-4DDA8AB8.uwaterloo.ca) (Ping timeout)
[16:21:38] <strcat>     let region = do Local::borrow |task: &mut Task| {
[16:21:40] <strcat>         task.heap.boxed_region
[16:21:42] <strcat>     };
[16:21:44] <acrichto> yeah there
[16:21:44] <strcat> hm
[16:22:24] <strcat> ugh this is annoying
[16:22:26] <strcat> ;p
[16:23:07] *** cade is now known as cade-zombie
[16:24:52] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[16:26:12] <osa1> rusti> 1 + 2;
[16:26:12] <osa1> [1]    5879 segmentation fault  ./rusti
[16:26:12] <osa1> oh wow
[16:26:18] <osa1> this is my first encounter with rust
[16:26:37] <nathan7> 1 + 2; is (), btw
[16:26:40] <nathan7> 1 + 2 is 3 however
[16:26:42] <acrichto> osa1: sadly rusti isn't quite stable now :(
[16:27:33] <kimundi> osa1: However, the rusti here is actually rustc in disuise, and also takes private messages :)
[16:27:50] <osa1> yeah I think I can understand that ... though I'm still having trouble to understand why we have rusti if it can't even eval an arithmetic expression
[16:27:57] <kimundi> rusti: 1 + 2; 
[16:27:57] -rusti- ()
[16:28:00] <kimundi> rusti: 1 + 2
[16:28:01] -rusti- 3
[16:28:13] <tjc> osa1: what version of Rust are you using?
[16:28:30] <osa1> âžœ  bin git:(master) ./rustc --version
[16:28:30] <osa1> ./rustc 0.8-pre (3c17903 2013-09-12 06:06:04 -0700)
[16:28:38] <osa1> just compiled the head
[16:28:39] <strcat> osa1: well that's why rusti prints that header
[16:28:40] <tjc> hmm
[16:28:45] <tjc> that's surprising, then
[16:28:55] <strcat> tjc: it's known to be broken on linux again
[16:29:14] <tjc> strcat: ah ok
[16:29:24] <kimundi> osa1: It's not that avaluating an arithmetic expession is hard, it's that just in time compiling of arbitrary input source code is hard, combining it with previous input, all while using unfinished or unsafe apis is hard to get right. :)
[16:29:40] *** Joins: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[16:29:57] <osa1> kimundi: yeah I can understand that. I guess other compiled languages (ocaml, haskell, maybe go?) have some kind of bytecode for that purposes, right?
[16:30:16] <osa1> ocaml has a bytecode format for sure, I think haskell has one too
[16:30:33] <kimundi> depends. I only ever used the haskell interpreter, and I don't know how that one is implemented
[16:31:09] *** cade-zombie is now known as cade
[16:32:21] <strcat> acrichto: does it die dereferencing that ptr or something?
[16:32:31] <kimundi> The problem in general is that rust works with very low level things - writing an interpreter for it has similar challenges as writing one for C/C++.
[16:33:13] <acrichto> strcat: it dies on a `ret` instruction :(
[16:33:21] <acrichto> at the end of Local::borrow
[16:33:57] *** Quits: lkuper (lkuper@moz-D862222C.dhcp-bl.indiana.edu) (Ping timeout)
[16:34:06] <nathan7> kimundi: and it wraps them beautifully [=
[16:34:07] *** Quits: Larry (larryfox@moz-343B6F0C.nyc.biz.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[16:34:53] <strcat> acrichto: I don't really see how any of this stuff is actually to blame for it ;[
[16:35:42] <acrichto> strcat: yeah, although if you're right about the ABI changing, then that's probably the issue, I still don't understand how that's changing though
[16:35:43] <erickt> brson: ping
[16:36:15] <strcat> acrichto: a struct return is just a different ABI than a ptr parameter
[16:36:35] <strcat> LLVM has to output it with the platform's ABI
[16:37:00] *** Joins: riley (riley@8BA43816.9AA11D69.65DDFA89.IP)
[16:37:08] <acrichto> strcat: I still don't understand it though b/c we're not creating an llvm function that's "struct a foo()", we're actually translating a function that says "void foo(struct a*)"
[16:37:33] <strcat> acrichto: no, we're writing 'void foo(struct a* sret)'
[16:37:38] <strcat> which is not the same
[16:37:51] <acrichto> so how is that different?
[16:37:56] <acrichto> ABI-wise
[16:38:07] <strcat> because it is a struct return and that's supposed to use a specific calling convention
[16:38:20] <acrichto> see that makes sense to me if it's "struct a foo()"
[16:38:39] <acrichto> not if we're translating the function as "void foo(struct a* sret)"
[16:38:55] *** Quits: fabiand (fabiand@moz-EDBC5F57.adsl.alicedsl.de) (Quit: Verlassend)
[16:38:55] <acrichto> in the first case, the abi dictates how you even do ssuch a thing
[16:39:03] <strcat> it does in the 2nd case too
[16:39:10] <acrichto> in the second case it looks like it's ABI-wise just passing a parameter
[16:39:33] *** Joins: fabiand (fabiand@moz-EDBC5F57.adsl.alicedsl.de)
[16:39:47] <acrichto> so if we write "void foo(struct a* sret)" llvm interprets that as "struct a foo(), but put the return in the first pointer?"
[16:40:34] *** Quits: zwol (zack@moz-B5C129C.ece.cmu.edu) (Quit: Leaving)
[16:41:03] *** Quits: kij (Mibbit@moz-5E180F75.mobile.3.dk) (Quit: http://www.mibbit.com ajax IRC Client)
[16:41:10] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[16:42:22] <strcat> acrichto: there's an ABI difference
[16:42:32] <strcat> you can return structs of variable length via sret, not via a regular return
[16:42:36] <strcat> they are different ABIs
[16:42:37] *** Quits: ross (ross@moz-5EA04060.br.br.cox.net) (Quit: )
[16:43:02] *** Joins: jclements (jclements@moz-644F0E77.wireless.calpoly.edu)
[16:43:54] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[16:43:58] *** Joins: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net)
[16:44:06] <acrichto> hmm, so this should only matter if it's llvm => external fuction calls, llvm => llvm function calls should be taken care of?
[16:44:14] *** Joins: tav (tav@moz-D9FB4717.range86-160.btcentralplus.com)
[16:44:51] <strcat> acrichto: not necessarily the problem
[16:44:55] *** Joins: mihneadb (Mihnea@moz-BE33DA21.fw1.sfo1.mozilla.net)
[16:45:11] <strcat> it would be a problem if sret was on an external fn declaration but not on the true definition
[16:45:13] <strcat> or vice versa
[16:45:22] <strcat> or if foreign.rs does something subtly wrong when sret is used
[16:45:32] *** Joins: Ralith (ralith@A8995AA9.62B6AF6A.922221DB.IP)
[16:45:39] *** Quits: maik (maik@moz-3F2CDB33.dip0.t-ipconnect.de) (Ping timeout)
[16:45:45] <acrichto> I would agree with that assessment
[16:46:07] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[16:46:08] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/nVYx7w
[16:46:08] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[16:46:11] <acrichto> but then again isn't the ABI for returning structs different from all of this?
[16:46:54] *** Joins: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net)
[16:47:21] <strcat> acrichto: it totally depends on the architecture
[16:47:23] <strcat> their backend
[16:47:34] <strcat> x86 is different from x86_64, and they are different than ARM
[16:48:01] <acrichto> but so this would be a serious problem if we passed a function from rust to C as a callback, and the rust function had sret which C wasn't expecting
[16:48:16] <acrichto> also if the declaration of an extern fn from C was sret when it wasn't compiled that way
[16:48:25] <strcat> yes
[16:48:53] <strcat> acrichto: http://lists.cs.uiuc.edu/pipermail/llvmdev/2010-March/029824.html if you want to know why it is that way
[16:49:00] <strcat> C complex numbers.
[16:49:23] <strcat> ideally we wouldn't have an out parameter at all
[16:49:29] <strcat> we would just *always* use the return value
[16:49:33] <strcat> and LLVM would deal with it all
[16:49:39] <strcat> it's totally possible that we could already be doing that
[16:49:51] <acrichto> I wonder if that's just less efficient?
[16:49:57] <acrichto> doesn't seem like it should be
[16:50:09] <strcat> LLVM backends should be able to compile it to efficient code
[16:50:13] <strcat> but they don't necessarily do
[16:50:22] <strcat> according to this thread, only x86 could handle it in 2010
[16:51:04] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[16:51:04] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/aTO17Q
[16:51:04] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[16:51:05] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[16:51:05] <ghrust> 01[13rust01] 15bors pushed 5 new commits to 06auto: 02http://git.io/bcIi7w
[16:51:05] <ghrust> 13rust/06auto 14b9a8b37 15John Clements: more helpful error message for ident comparison failure
[16:51:05] <ghrust> 13rust/06auto 14f576ed0 15John Clements: fix for bug #9110
[16:51:05] <ghrust> 13rust/06auto 14e9832d4 15John Clements: ident->name cleanup
[16:51:06] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[16:52:42] <strcat> acrichto: it's possible that there's a way to get the optimizations we get from sret without sret
[16:53:11] <acrichto> the optimization is that the final copy from a local to the outptr isn't removed, right?
[16:53:23] <strcat> well atm
[16:53:28] <strcat> it allocates a local variable
[16:53:30] <strcat> writes to it
[16:53:32] <strcat> and then copies to the outptr
[16:53:39] <strcat> with sret, it just writes to the out ptr
[16:53:51] <acrichto> well we won't emit that, but llvm will optimize to that?
[16:54:05] <strcat> acrichto: with noalias+sret, yes
[16:54:08] <strcat> we could also just generate better IR but this was easier
[16:54:27] <acrichto> yeah makes sense, and if we can have it we should 
[16:54:33] <acrichto> in theory it could enable other optimizations
[16:55:06] *** Joins: Larry (larryfox@moz-343B6F0C.nyc.biz.rr.com)
[16:55:38] <strcat> anyway going to land it without sret
[16:55:42] <strcat> and deal with this later
[16:55:51] <strcat> noalias has no ABI implications
[16:56:07] *** Joins: eholk (eholk@moz-BA312F07.crest.iu.edu)
[16:56:52] *** Joins: vodik (simon@C5A2C672.9963B395.D02BABA9.IP)
[16:57:23] *** Joins: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net)
[16:57:29] <Thiez> how expensive is task local storage?
[16:57:39] <strcat> Thiez: a hash table lookup
[16:57:45] <Thiez> excellent.
[16:57:47] <strcat> at least it should be
[16:57:57] <acrichto> no, it's a linear look up in an array right now
[16:57:58] <acrichto> sadly :(
[16:58:01] <Thiez> :(
[16:58:11] <strcat> I thought that's why we made a constructor for hashmap without using the RNG :s
[16:58:15] <acrichto> TLS isn't actually massive though
[16:58:19] <acrichto> so it's frequently faster
[16:58:28] <acrichto> unless you're storing a million things in TLS
[16:58:40] <acrichto> tls has other costs though like making sure you're not taking out conflicting loans
[16:59:01] <Thiez> I was hoping to store some concurrency related stuff in tls
[16:59:08] <Thiez> can one store raw pointers there?
[16:59:28] <acrichto> if you want it to be properly deallocated if the task dies, they should have destructors
[16:59:31] *** Quits: vodik (simon@C5A2C672.9963B395.D02BABA9.IP) (Ping timeout)
[16:59:33] <acrichto> TLS destructors are run when the task exits
[16:59:45] *** ozten is now known as ozten|meeting
[16:59:45] <acrichto> right now it's a bit undefined what happens if the tls destructors access tls...
[17:00:00] <strcat> acrichto: yeah it's definitely sret allowing it to optimize
[17:00:02] <strcat> ;[
[17:00:03] <Thiez> that should be no problem, I don't think they have to be deallocated on task death.
[17:00:09] <acrichto> strcat: :(
[17:00:21] <acrichto> Thiez: then certainly, you can store any type of object in tls
[17:00:23] <acrichto> (yay!)
[17:00:31] <acrichto> it used to only be @T
[17:00:40] <Yurume> is there any way (including workarounds) for selecting ports with a timeout?
[17:00:44] *** Joins: kij (Mibbit@moz-5E180F75.mobile.3.dk)
[17:00:45] <Yurume> (in 0.7)
[17:01:08] <Yurume> I know 0.8 will be out within weeks, but for now I have to keep 0.7
[17:02:48] *** Joins: jviereck (Adium@moz-58A87BA7.dip0.t-ipconnect.de)
[17:02:51] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[17:03:18] <Thiez> if you can select ports, then you can include a port that is connected to a task that will send a timeout event after some interval
[17:03:51] <brson> erickt: sorry, in a meeting atm
[17:04:01] <erickt> brson: np
[17:04:09] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[17:04:28] *** Quits: ceninan (ceninan@moz-6BD43586.a370.priv.bahnhof.se) (Ping timeout)
[17:04:34] *** Joins: jdm (jdm@moz-BBE3ABD.mv.mozilla.com)
[17:04:34] *** ChanServ sets mode: +o jdm
[17:05:24] <Amaranth> Cloning a ~str gives me a &str? Wha?
[17:05:35] <strcat> nope
[17:05:37] <strcat> :\
[17:05:48] <strcat> rusti: (~"foo").clone()
[17:05:49] -rusti- ~"foo"
[17:05:56] <Amaranth> Oh wait it's starting as &str, oops
[17:06:26] <Amaranth> Actually, I still don't know how to get out of that. I'm guessing cloning a &str just copies the pointer?
[17:06:43] <strcat> yes, Clone returns the same type
[17:07:01] <strcat> it clones as shallowly as possible from a reference to the type
[17:07:08] *** Joins: deio (chris@moz-B7BAB130.dynamic.tstt.net.tt)
[17:07:18] <strcat> the only way to copy &T is to copy the ptr
[17:07:23] *** Quits: valenting (Thunderbir@7658A01E.84D5EFD5.FB866788.IP) (Ping timeout)
[17:07:26] <strcat> or it wouldn't be the same type (same lifetime)
[17:08:42] <strcat> acrichto: so yes, it looks like there is sret demotion
[17:08:50] <Amaranth> Is there a straightforward way to construct a new ~str from the contents of a &str?
[17:08:54] <acrichto> strcat: demotion?
[17:08:55] <strcat> to_owned()
[17:09:10] <acrichto> rusti: "test".to_owned()
[17:09:11] <strcat> acrichto: if you just return a big struct, it looks like it will transform it to sret
[17:09:11] -rusti- ~"test"
[17:09:19] <strcat> I haven't tested
[17:09:26] <Amaranth> Phew, that's much nicer than the dump it in a vector and make that into a str method I was thinking of
[17:09:29] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[17:09:29] *** ChanServ sets mode: +ao dherman dherman
[17:09:54] <acrichto> strcat: so "struct a foo()" if a is ~4KB means that llvm will optimize it to "void foo(struct a* sret)"
[17:09:56] <Yurume> Thiez, I also tried that and it turned out that 0.7 has no working sleep function in win32
[17:10:05] <strcat> acrichto: it looks that way. I'm not sure though
[17:10:21] <strcat> acrichto: and it doesn't look like it's an optimization
[17:10:22] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[17:10:24] <strcat> it's just part of codegen
[17:10:29] <strcat> keep in mind that it has to be consistent
[17:10:35] <strcat> with/without optimizations the ABI is the same
[17:10:35] <kimundi> Didn't someone want to add a lint warning for passing large structs by value?
[17:10:48] <Thiez> Yurume: that's paintful, in that case I don't know
[17:11:04] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[17:11:18] <strcat> acrichto: so really we should probably not do this RVO stuff ourself
[17:11:21] <strcat> and just let LLVM do it
[17:11:29] <strcat> I'll investigate that later though, it's a big change
[17:11:33] <Yurume> Thiez, maybe I should just let 0.7 go and switch to master :S
[17:11:37] <acrichto> strcat: if it doesn't slow us down, I'd be game for that
[17:11:49] <strcat> acrichto: well that's the idea, it would be a performance improvement afaict
[17:12:16] <acrichto> wooo
[17:12:25] <strcat> anyway would have to investigate
[17:12:29] <strcat> it depends on the target too
[17:12:40] *** jorendorff is now known as jorendorff_away
[17:14:00] <Yurume> is there any remaining breaking changes between master and 0.8 release?
[17:14:05] <Yurume> are there*
[17:14:31] <kimundi> 0.8 release didn't happen yet?
[17:14:36] *** jorendorff_away is now known as jorendorff
[17:14:44] <strcat> Yurume: the release tags don't determine anything about development
[17:15:01] *** Joins: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com)
[17:15:03] <kimundi> it's just a release all 3 months
[17:15:08] <strcat> they are just tagged on master on a time schedule + release notes made + the tarballs are made
[17:15:30] <strcat> and they don't receive any support after they are tagged
[17:15:32] <Yurume> strcat, okay, how about the outstanding PR for breaking changes that may be merged within three weeks?
[17:16:49] <strcat> don't know
[17:16:57] <strcat> PRs are usually merged in a few days
[17:19:43] <erickt> Yurume: I got a PR in review that's changing some function names
[17:19:57] <Yurume> heh
[17:20:55] *** Quits: nkoep (nik@moz-8BF7DFF0.vpn.rwth-aachen.de) (Ping timeout)
[17:23:34] <strcat> acrichto: I can't actually find any ABI differents from sret on x86
[17:23:38] <strcat> just x86_64 and win32
[17:23:39] <strcat> ;[
[17:23:40] *** Quits: nathan7 (nathan@86F860FE.3CD03790.F113998C.IP) (Connection reset by peer)
[17:24:07] <strcat> and it failed on nopt where optimizations are off
[17:24:09] <strcat> so..... ;[
[17:24:21] <acrichto> I hadn't thought of that
[17:24:30] <acrichto> it is kinda weird that this breaks things only some of the time
[17:25:01] <strcat> acrichto: http://ix.io/805 grepping for hasStructRet
[17:25:06] *** Joins: SiegeLord (sl@moz-1DF56822.twcny.res.rr.com)
[17:25:16] *** Joins: tikue (tkuehn@F9491E76.EB08480C.689607DE.IP)
[17:25:16] <strcat> so
[17:25:19] <strcat> the 4 x86 ones...
[17:25:28] *** Joins: ofeldt (ofeldt@moz-AFA78C7E.dip0.t-ipconnect.de)
[17:25:32] <strcat>   // The x86-64 ABI for returning structs by value requires that we copy
[17:25:32] *** Quits: tikue (tkuehn@F9491E76.EB08480C.689607DE.IP) (Quit: tikue)
[17:25:34] <strcat>   // the sret argument into %rax for the return. We saved the argument into
[17:25:36] <strcat>   // a virtual register in the entry block, so now we copy the value out
[17:25:38] <strcat>   // and into %rax. We also do the same with %eax for Win32.
[17:25:52] <strcat> so, not that
[17:25:54] <strcat>   if (F.hasStructRetAttr() &&
[17:25:56] <strcat>       (Subtarget->is64Bit() || Subtarget->isTargetWindows())) {
[17:26:07] *** Quits: ofeldt- (ofeldt@moz-91B9AD7D.dip0.t-ipconnect.de) (Ping timeout)
[17:26:10] <acrichto> plus that kinda makes sense
[17:26:12] <acrichto> and shouldn't break things
[17:26:21] <strcat> yeah and it doesn't
[17:26:23] <acrichto> %rax is caller saved anyway (if it's not used for returning things)
[17:26:24] <strcat> x86_64 is fine
[17:26:41] <strcat>   if (DAG.getMachineFunction().getFunction()->hasStructRetAttr() &&
[17:26:43] <strcat>       (Subtarget->is64Bit() || Subtarget->isTargetWindows())) {
[17:26:45] <strcat> another
[17:27:22] <strcat>   if (MF.getFunction()->hasStructRetAttr() &&
[17:27:24] <strcat>       (Subtarget->is64Bit() || Subtarget->isTargetWindows())) {
[17:27:26] <strcat> another
[17:27:30] <strcat> and the last one is related to tail calls
[17:27:30] *** Joins: nathan7 (nathan@86F860FE.3CD03790.F113998C.IP)
[17:27:32] <acrichto> :( :(
[17:28:35] <dolphinling> Hi, I'm trying to write bindings for a C library, and I can't figure out how to bind to a function that takes a function pointer argument. Is there any documentation or examples on this?
[17:28:45] *** Joins: azakai (alon@moz-BBE3ABD.mv.mozilla.com)
[17:28:55] <strcat> dolphinling: extern "C" fn
[17:28:59] <strcat> is the type
[17:29:10] *** Quits: KindOne (KindOne@moz-272920E9.dynamic.ip.windstream.net) (Ping timeout)
[17:29:17] <strcat> extern "C" fn(c_int, c_int) -> c_int, or whatever the case is
[17:29:38] *** Joins: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP)
[17:29:49] <dolphinling> strcat: thanks, do you know of anywhere that uses it so I can see it in context?
[17:30:05] <strcat> no, I don't
[17:30:13] <dolphinling> All right, I'll look around, thanks :)
[17:31:45] <SiegeLord> dolphinling, Here's an example from my binding: https://github.com/SiegeLord/RustAllegro/blob/master/src/ffi/base.rs#L14
[17:32:04] <ecr> dolphinling: std::rt::uv::uvll.rs
[17:32:31] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[17:32:35] *** Quits: nano (nano@moz-74CAD1CA.superkabel.de) (Connection reset by peer)
[17:33:14] <bstrie> http://blog.sucuri.net/2013/09/ask-sucuri-non-alphanumeric-backdoors.html has the most amazing instance of coercion I've ever seen from a programming language... PHP interprets `@!+_` as `true`
[17:33:24] * bstrie hugs rust and its newfound lack of boolean coercion
[17:34:08] *** Joins: KindOne (KindOne@moz-B2A9793.dynamic.ip.windstream.net)
[17:34:26] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Ping timeout)
[17:34:30] <ecr> bstrie: I refuse to accept someone considered that reasonable and then implemented it
[17:35:17] <bstrie> ecr: it all falls out of the typical rules... any symbol that php doesn't know is taken to be a string (that's the underscore), then it gets added with `+` so it turns into an int, then `!` is applied and it turns into a bool
[17:35:42] <bstrie> the first rule is also why, hilariously, `System.out.println("hello");` is valid PHP
[17:36:02] <strcat> acrichto: oh okay I found an ABI implication
[17:36:16] * ecr plugs his ears
[17:36:25] <ecr> bstrie: LA LA LA CAN'T HEAR YOU
[17:36:33] <strcat> on 32-bit, if it has a struct return, no bytes are popped by the callee
[17:36:43] <strcat> otherwise, it pops 4 bytes
[17:37:07] <bstrie> ecr: ignoring PHP's frankly absurd coercion rules won't save you from its insanity!!
[17:37:32] <acrichto> strcat: whoa, what are those 4 bytes in question?
[17:37:35] <strcat>     // If this is an sret function, the return should pop the hidden pointer.
[17:37:37] <strcat> hm
[17:37:41] <bstrie> but if you want more elaboration, you'd have to ask eevee_ :P
[17:37:44] <dolphinling> SiegeLord, ecr: Thanks for the links, I found an example in rust-mozjs/glue.rs which was actually even closer to what I needed (function pointers inside a struct)
[17:37:48] <strcat> acrichto: not sure I am confused now
[17:38:13] <acrichto> strcat: hmm... well the ret instruction was returning to an address on the stack if I remember correctly
[17:38:29] <strcat> acrichto: well this would be the issue
[17:38:40] <strcat> acrichto: caller/callee mismatch
[17:38:46] <strcat> one is likely sret and the other is not
[17:38:49] <strcat> (or ofc, foreign.rs is wrong!)
[17:38:54] <acrichto> strcat: let me verify that real quick
[17:38:55] <strcat> but at least this seems to narrow it down
[17:39:30] *** Joins: nkoep (nik@moz-790570D8.pool.mediaways.net)
[17:40:04] <acrichto> hmm I seem to have clobbered by workspace
[17:40:21] <acrichto> so I can't test right now :(
[17:40:49] *** Quits: paulproteus (quassel@rose.makesad.us) (Ping timeout)
[17:40:49] <Palmik> Do we have something like partial type application (for generic types) in rust?
[17:40:59] *** Quits: cdidd (cdidd@moz-6B57E0D9.broadband.corbina.ru) (Ping timeout)
[17:41:04] *** Quits: Aetherspawn_BNC (uid6924@moz-31ABA2C0.irccloud.com) (Ping timeout)
[17:41:29] *** Joins: paulproteus (quassel@moz-E86A3B42.makesad.us)
[17:42:41] *** Joins: Aetherspawn_BNC (uid6924@moz-31ABA2C0.irccloud.com)
[17:43:36] *** Joins: cdidd (cdidd@moz-3C61A716.broadband.corbina.ru)
[17:43:45] *** Joins: valenting (Thunderbir@7658A01E.84D5EFD5.FB866788.IP)
[17:43:49] <jclements> tjc: ping
[17:44:14] <ecr> Palmik: no
[17:44:21] <tjc> jclements: give me a few minutes, in a meeting
[17:44:29] *** Quits: jviereck (Adium@moz-58A87BA7.dip0.t-ipconnect.de) (Quit: Leaving.)
[17:44:30] <jclements> tjc: np, I'll try again at 11
[17:44:48] *** Joins: jviereck (Adium@moz-58A87BA7.dip0.t-ipconnect.de)
[17:45:21] <strcat> acrichto: I'm going to ask about this on #llvm though, seems there should be a way to tag this property in general without sret
[17:45:24] *** Quits: sully (sully@moz-45967CBE.emarhavil.com) (Ping timeout)
[17:45:47] *** Joins: jstevans (Instantbir@8E2664B3.9875BCA6.DDE5D3F6.IP)
[17:45:48] *** Quits: jstevans2 (Instantbir@8E2664B3.9875BCA6.DDE5D3F6.IP) (Connection reset by peer)
[17:47:58] *** Joins: bheylin_ (brianheyli@moz-8255E94E.adsl.online.nl)
[17:49:11] *** Joins: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com)
[17:49:11] *** ChanServ sets mode: +ao pcwalton pcwalton
[17:49:24] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[17:50:03] *** Joins: jstevans1 (Instantbir@BDC0CC7A.A7636379.B7830B68.IP)
[17:50:06] *** Quits: fabiand (fabiand@moz-EDBC5F57.adsl.alicedsl.de) (Quit: Verlassend)
[17:50:39] *** Joins: sully (sully@moz-45967CBE.emarhavil.com)
[17:50:56] <tjc> jclements: I'm free now -- what's up?
[17:51:05] *** jorendorff is now known as jorendorff_away
[17:51:07] *** Quits: jstevans (Instantbir@8E2664B3.9875BCA6.DDE5D3F6.IP) (Ping timeout)
[17:51:12] *** Joins: five (five@DA3A9F95.1CAF0E4A.12750D2E.IP)
[17:51:16] *** Joins: jstevans (Instantbir@3D830770.3C990DFD.DDE5D3F6.IP)
[17:51:41] <jclements> tjc: I saw a comment on issue #8224 about macros not being in scope for 1.0... does that mean what I think it means? 
[17:51:43] *** Quits: jstevans1 (Instantbir@BDC0CC7A.A7636379.B7830B68.IP) (Ping timeout)
[17:51:54] <tjc> jclements: ask brson =)
[17:52:04] <jclements> tjc: gotcha.
[17:52:06] <jclements> brson: ping
[17:52:07] *** Joins: five1 (five@DA3A9F95.1CAF0E4A.12750D2E.IP)
[17:52:09] *** Joins: jstevans1 (Instantbir@moz-8F061A9E.bootp.virginia.edu)
[17:52:12] *** Quits: five (five@DA3A9F95.1CAF0E4A.12750D2E.IP) (Connection reset by peer)
[17:52:56] *** Quits: jstevans (Instantbir@3D830770.3C990DFD.DDE5D3F6.IP) (Ping timeout)
[17:52:57] *** Joins: kelvin (kelvin@4C416360.3C990DFD.DDE5D3F6.IP)
[17:53:21] <pauls> We're not going to be able to refer to macros? Any time someone mentions "macro" on the channel, we'll have to respond "I'm sorry, that word is undefined".
[17:54:01] *** Joins: jstevans (Instantbir@moz-C86BEE20.bootp.virginia.edu)
[17:54:25] *** Joins: jstevans2 (Instantbir@26E43217.E8B6FA7D.DDE5D3F6.IP)
[17:54:46] *** Quits: jstevans1 (Instantbir@moz-8F061A9E.bootp.virginia.edu) (Ping timeout)
[17:55:41] *** Quits: jstevans (Instantbir@moz-C86BEE20.bootp.virginia.edu) (Ping timeout)
[17:55:45] <erickt> oh boy this is the best rust website ever: http://quotes.burntelectrons.org/search?query=tag%3A%23rust
[17:55:54] *** Quits: nsf (nsf@moz-EEF3238A.convex.ru) (Quit: WeeChat 0.4.1)
[17:56:07] *** jorendorff_away is now known as jorendorff
[17:56:17] <kelvin> Is it acceptable to ask a newbie question here? I can't seem to find the information anywhere online
[17:56:25] <cmr>  kelvin yes, definitely.
[17:56:40] <tjc> erickt: more people should add #rust quotes!
[17:57:00] <ecr> kelvin: IRC is pretty much the Rust documentation at the moment, so feel free :)
[17:57:16] <brson> jclements: ping
[17:57:20] <brson> -ong
[17:57:22] <brson> erickt: pong
[17:57:42] <jclements> brson: hey! I saw a couple of comments about macros not being in scope for 1.0... can you elaborate on that at all?
[17:57:46] <cmr> Who did the recent visistor work? I'm getting a mysterious ICE I cannot pin down: https://gist.github.com/anonymous/ac7ca6576903d90bd742
[17:58:10] <tjc> cmr: I think it was pcwalton 
[17:58:41] <cmr> pcwalton: ping
[17:58:43] <pcwalton> hmm
[17:58:47] <brson> jclements: we're currently planning to put macro_rules! behind a -Z flag or attribute
[17:58:54] <brson> jclements: it will be 'unstable'
[17:59:06] <pcwalton> I don't know off the top of my head
[17:59:06] <cmr> The ICE message is `error: internal compiler error: encode_symbol: id not found 15440`
[17:59:09] <cmr> nmatsakis: ping
[17:59:13] <bstrie> brson: because of the inability to import them?
[17:59:15] <cmr> might be the nodeid renumbering stuff?
[17:59:16] *** ozten|meeting is now known as ozten
[17:59:20] <pcwalton> yeah
[17:59:23] *** mjrosenb|ARM is now known as mjrosenb
[17:59:27] <jclements> brson: sad face... can you share the reasons for that? Or... if it was part of a discussion on rust-dev that I missed?
[17:59:28] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[17:59:28] <pauls> ) :
[17:59:29] <ww> what's the preferred way to build a string dynamically, with append?
[17:59:43] <ww> anything like StringBuilder in java?
[17:59:53] <cmr> ww: We don't need something like it.
[18:00:00] *** Quits: dcrewi (david@moz-AB8667CE.gyrae.net) (Ping timeout)
[18:00:01] <cmr> use push_str
[18:00:05] <strcat> strings are mutable so pushing a bunch of times is generally fine
[18:00:10] *** Quits: hoverbear (andrew@EBFA78B5.F19E5E7B.E74D50F2.IP) (Ping timeout)
[18:00:17] <ww> ok, thx
[18:00:18] <kelvin> okay newbie question incoming
[18:00:19] <kelvin>  in a function declaration I was wondering what the difference between the following is: fn attack(mut player: Player) and fn attack(player: &mut Player) , where Player is a struct defined elsewhere
[18:00:20] <cmr> If you can, use with_capacity to preallocate.
[18:00:22] <strcat> if you really want, you can calculate the total needed capacity and call reserve
[18:00:29] <cmr> or reserve, yeah
[18:00:32] <strcat> I think the collect stuff already does it
[18:00:35] <nmatsakis> cmr: pong (phone)
[18:00:37] <pcwalton> off the top of my head: (a) import/export doesn't work; (b) macros are in a global namespace; (c) hygiene isn't done for all types of identifiers
[18:00:44] <tjc> kelvin: the first one says that you want to pass `player` by-value to attack, and attack can mutate it but the mutations aren't observable to anybody else
[18:01:04] <tjc> kelvin; the second one says to pass `player` by reference to attack, and attack can mutate it, and changes will be visible to attack's caller after attack returns
[18:01:06] <brson> i think we also have a general unease since 
[18:01:07] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[18:01:07] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/bcIi7w
[18:01:07] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[18:01:11] <brson> -er
[18:01:23] *** Joins: hoverbear (andrew@EBFA78B5.F19E5E7B.E74D50F2.IP)
[18:01:27] <brson> not many people understand it. there seem to be a lot of corner case bugs
[18:01:28] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[18:01:38] <kelvin> Ohhhhhh, okay, that's what I was observing, but I wasn't quite sure what was happening. Thanks!
[18:01:38] <brson> jclements: but what pcwalton said^
[18:01:41] *** Joins: chubby (Mibbit@moz-20CEEF38.hsd1.ca.comcast.net)
[18:01:46] <pcwalton> I think -Z is probably a blunt hammer
[18:01:52] <pcwalton> we should have an experimental language features thing like GHC does
[18:02:04] <brson> it should definitely be accessible through a crate attr
[18:02:18] <pcwalton> I don't want to discourage people from using it
[18:02:22] <pcwalton> just make it obvious that it can change
[18:02:40] <pcwalton> obv. macros are an important part of the language and I don't want to throw them under the bus
[18:03:01] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[18:03:03] <jclements> pcwalton: a) unfortunate, yes, but not awful. b) is that actually true? I'm not sure what you mean by that. c) true, but largely invisible for most users. Sorry, that's kind of large for an IRC msg.....
[18:03:05] <pcwalton> but at the same time I think it's clear that we don't want to freeze them in their current state
[18:03:22] *** Quits: enomado (nomad@DB5C5EEB.5ED34291.AB610CFE.IP) (Input/output error)
[18:03:23] <SiegeLord> I like the crate attribute idea
[18:03:24] <pcwalton> jclements: for (b) I mean that they don't live in packages
[18:03:28] <pcwalton> in modules, rather
[18:03:35] <ecr> kelvin: if you're familiar with C, the first is what happens if you have a bare struct as an argument (it's copied), and the second is passing a pointer instead. The one difference there is that sometimes pass-by-value in Rust will move rather than copy.
[18:03:36] <pcwalton> so they kind of go into one global namespace
[18:03:37] <cmr> nmatsakis: see above ICE, possibly related to AST renumbering?
[18:03:42] *** Quits: eagen (eagen@8737942B.7A99C13A.B7961A98.IP) (Client exited)
[18:03:47] <chubby> Q: is there a single-threaded version of the runtime?; i.e. I want all spawned tasks to happen on one thread; I don't want thread switching overhead, and just want to use manual yields to switch tasks.
[18:03:56] <pcwalton> if we had import/export but nothing else then crate A can define macro foo! and crate B can define macro foo!
[18:04:04] <ecr> kelvin: and that &mut lets you do less than a raw C *
[18:04:19] <pcwalton> and if you had a module that needed to use crate A's foo! and crate B's foo! it'd need some way to disambiguate
[18:04:20] <nmatsakis> cmr: quite possibly, can't look now
[18:04:26] <pcwalton> which is possibly just one part of import/export
[18:04:29] <pcwalton> but we need to decide
[18:04:55] *** Quits: tav (tav@moz-D9FB4717.range86-160.btcentralplus.com) (Quit: tav)
[18:05:01] <kelvin> ecr: Thanks for the help!
[18:05:45] <Amaranth> How does IntConvertable work? I've implemented the trait and tried KeyCode::from_int(some_int) and some_int as KeyCode
[18:05:45] *** Quits: five1 (five@DA3A9F95.1CAF0E4A.12750D2E.IP) (Connection reset by peer)
[18:05:49] <ecr> I'd be in favor of a GHC-like experimental language feature thing. Ideally at the module level rather than the crate level.
[18:05:52] <ecr> kelvin: sure :)
[18:06:03] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[18:06:03] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/V2nU-w
[18:06:03] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[18:06:04] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[18:06:04] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/aaYoRg
[18:06:04] <ghrust> 13rust/06auto 14b7435cf 15Daniel Micay: implement raw pointer comparisons in librustc...
[18:06:04] <ghrust> 13rust/06auto 144e3d499 15bors: auto merge of #9136 : thestinger/rust/ptr, r=alexcrichton...
[18:06:04] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[18:06:14] <chubby> Q: is there a single-threaded version of the runtime?; i.e. I want all spawned tasks to happen on one thread; I don't want thread switching overhead, and just want to use manual yields to switch tasks.
[18:06:15] <SiegeLord> Was the default method attribute crate level or module level?
[18:06:18] *** Joins: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[18:07:04] *** Joins: aeqwa (aeqwa@moz-E420D1B4.dsl.tropolys.de)
[18:07:15] *** Joins: a_m0d (dschoof@moz-670D1285.commercial.cgocable.net)
[18:07:22] <Amaranth> chubby: I think that'd just be running with RUST_THREADS=1
[18:07:23] <jclements> pcwalton: wait... here's a gist https://gist.github.com/jbclements/6541556 with an example of a macro defined inside a function, that can't be used outside.  So... I'm still confused by your "global scope" comment. Which one of us is mistaken?
[18:07:37] <pcwalton> I just mean that there are no namespaces
[18:07:46] <chubby> Amaranth: cool. how do I yield?
[18:07:52] <pcwalton> foo::bar::baz!(...) doesn't work
[18:08:03] <pcwalton> I don't mean that scoping is broken
[18:08:12] <Amaranth> chubby: That I don't know
[18:08:32] <ecr> chubby: std::task::deschedule()
[18:08:40] <chubby> scr: great, thanks!
[18:08:41] <jclements> pcwalton: IIUC, this is something that only affects import/export, right?
[18:08:44] <pcwalton> right
[18:08:48] <pcwalton> so you can view it as part of that
[18:08:49] <pcwalton> bu
[18:08:51] *** Quits: aeqwa (aeqwa@moz-E420D1B4.dsl.tropolys.de) (Ping timeout)
[18:09:05] <jclements> pcwalton: btw, I still owe you lunch :)
[18:09:06] <pcwalton> but there's a question (in my mind anyway) as to whether our existing macros should migrate to some kind of well-known namespace
[18:09:09] <kimundi> chubby: For the record, rust task only yield automatically on io, so calling yield manually in tight loops is what you'd do anyway in regular uses.
[18:09:20] <ecr> chubby: I think the number of threads is controlled by an environment variable like Amaranth said. I'm not sure if it's still RUST_THREADS or not
[18:09:22] <pcwalton> e.g. maybe fmt!() should become std::fmt!() ?
[18:10:20] <chubby> kimundi: nice
[18:10:37] <kimundi> What exactly is the problem with macro importing anyway? The fact that macros don'T live _in_ the AST, but rather are declarations for _modifiying_ the AST?
[18:10:38] <chubby> ecr: where do I look to control thread count?
[18:10:50] <ecr> chubby: TL;DR on yielding - doing IO yields the task. send/recv on channels yields the task. tasks are NOT preempted, so if you make an infinite or long running loop that doesn't do a yielding operation, then it'll run for a very long time.
[18:11:05] <ecr> chubby: I'm not entirely sure. Let me grep around a little
[18:11:13] <chubby> ecr: thanks
[18:11:30] *** Joins: snadon (chatzilla@moz-F86CA4D4.mc.videotron.ca)
[18:11:34] *** Joins: five (five@480C2A86.92C5ED7E.4DD432BA.IP)
[18:11:39] <erickt> brson: hey there! I was wondering if I could get a BDFL call on https://github.com/mozilla/rust/pull/9115. In it, I rename Option.chain_move to Option.and_then to avoid a future conflict with Iterator.chain. I also remove .chain_ref as it had barely any use. Do you think I should add .chain_ref (renamed to .and_then_ref) back and possibly remove it in a future PR? This PR is starting to get long and I'd like to avoid it bitrotting
[18:11:53] <kimundi> The function for yoieling used to be task::yield() btw, but it got recently renamed to I think... task:unschedule() ?
[18:12:08] <ecr> kimundi: it's deschedule
[18:12:12] *** Quits: six600110 (six600110@moz-2FA48202.neo.res.rr.com) (Connection timed out)
[18:12:35] <chubby> kimundi: deschedule stays entirely in userspace, yes? no futex, no kernel overhead I hope
[18:12:40] <pcwalton> is yoieling like yodeling
[18:12:46] <chubby> lol
[18:12:47] <jclements> kimundi: exporting them from crates would require designing a new kind of export, and putting it in the shared library. exporting them from modules (that is, within a crate) is possibly simpler. Both of them require thinking about what it means to export a macro that refers to non-exported identifiers.
[18:12:48] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: zzzzzzzzzz)
[18:12:55] *** Joins: six600110 (six600110@moz-2FA48202.neo.res.rr.com)
[18:12:55] <ecr> chubby: correct. scheduling is all in userspace
[18:13:02] <chubby> ecr: I like
[18:13:17] <cmr> Another question: Is there something like a def_map in metadata? I have a DefId of an external crate and I want the Def from it. Previously I used each_path, but each_path is gone.
[18:13:17] <ww> to allocate a byte buffer ~[u8], is vec.with_capacity(my_len) the way to go?
[18:13:39] <cmr> ww: vec::with_capacity, yes. Or just ~[] to construct an empty one of the minimum size.
[18:13:45] <cmr> (which is, I think, 4 elements)
[18:13:46] <ecr> chubby: it looks like RUST_THREADS=1 should restrict to you one thread/scheduler
[18:13:52] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[18:13:52] *** ChanServ sets mode: +o tjc
[18:14:10] <ww> i want a fixed-size byte buffer to pass in to stream.read
[18:14:16] *** Quits: five (five@480C2A86.92C5ED7E.4DD432BA.IP) (Connection reset by peer)
[18:14:50] <ecr> pcwalton: don't tell anyone, it's a secret, but the scheduler actually works via a network of very tiny yodeling gnomes.
[18:14:54] <kmc> ecr: most of the time.  in Servo we still get two threads because we use std::rt::start_on_main_thread for GLFW
[18:15:00] *** Quits: jviereck (Adium@moz-58A87BA7.dip0.t-ipconnect.de) (Quit: Leaving.)
[18:15:23] <kmc> I think... or maybe one of those OS threads is a libuv worker and not a Rust thread at all
[18:15:27] *** Joins: dcrewi (david@moz-AB8667CE.gyrae.net)
[18:15:29] *** Joins: tikue (quassel@moz-FEADCD38.hsd1.pa.comcast.net)
[18:15:33] <ecr> kmc: true. I was just looking at the default runtime setup
[18:15:54] <ecr> kmc: I think you have a Rust scheduler thread and a plain OS thread
[18:16:08] <cmr> pcwalton: see above metadata question
[18:16:33] <ecr> ww: with_capacity is what you want.
[18:17:00] <Luqman> ww: do you know the size at compile time?
[18:17:09] <chubby> ecr: thanks
[18:17:11] <pcwalton> cmr: you can look up the item family and from there go from def id to def I think
[18:17:12] <chubby> kmc: thanks
[18:17:36] <ww> thx ecr.  luqman, no.  i don't.  i got it at runtime
[18:17:39] *** Quits: strcat (strcat@moz-61B073BC.cpe.net.cable.rogers.com) (Connection reset by peer)
[18:17:40] *** Quits: rusti (rusti@moz-61B073BC.cpe.net.cable.rogers.com) (Connection reset by peer)
[18:17:48] <cmr> pcwalton: item family being? The farthest I got was lookup_item and then the tag_def_id, but that only gives me a string with a nodeid and cratenumber, but that's what I start with.
[18:17:57] <pcwalton> item_family
[18:18:00] <pcwalton> if you have the doc
[18:18:08] <pcwalton> then you can get the item family and then go to the def
[18:18:41] *** Joins: rusti (rusti@moz-61B073BC.cpe.net.cable.rogers.com)
[18:18:47] <chubby> ecr: yodeling gnomes. lol. that will be the name the scheduler discpline that runs all on one thread. perfect.
[18:18:56] *** Joins: strcat (strcat@moz-61B073BC.cpe.net.cable.rogers.com)
[18:19:23] <kimundi> jclements: Hm... I mean I have obviously no idea about the complexities involved but couldn't you a) Introduce a new 'macro item' that would work like any struct/enum/fn declaration but doesn't actually define anything new. Use those macro items to 'store' a macro in a place in the module hierachy, make them emitt metadata etc so that they are cross crate accessible like other declarations. c) Have a macro-resolve pass that runs before AST
[18:19:23] <kimundi>  folding and handles those imports that import macros? Feel free top point out all the flaws in this thinking. :)
[18:19:29] <cmr> pcwalton: ah, would those be the variants + characters in decoder::Family?
[18:19:35] <pcwalton> yeah
[18:19:40] <cmr> thanks!
[18:19:55] <strcat> pcwalton: btw I have a fairly good idea why that sret thing is breaking.... so I think I'll have a fix for it soon
[18:20:00] <pcwalton> ok, cool
[18:20:02] <strcat> it slightly changes the ABI on x86
[18:20:11] <strcat> and I think foreign.rs breaks
[18:20:33] <strcat> sadly it doesn't break *often* ;p
[18:21:40] *** Quits: snadon (chatzilla@moz-F86CA4D4.mc.videotron.ca) (Quit: ChatZilla 0.9.90.1 [Firefox 24.0/20130909203154])
[18:22:00] <jclements> kimundi: yes, I think the crate export piece would look like that. I think the trickier part is in figuring out how to deal with macros that embed references to variables/fns/etc that aren't public, or in the case of vars, aren't even defined. You're right, though, these problems are all solvable; it's just a question of getting a good design in place.
[18:22:09] <brson> erickt: I'm not totally up to speed on which convention from #7887 you're refering to when you suggest you want to break the naming convention for and_then_ref. there's a lot of discussion there and the conclusions aren't clear
[18:22:24] <brson> erickt: I'm glad you're pushing this container naming effort forward though
[18:22:45] <erickt> brson: sorry. In #7887, I was under the impression that we're doing away with the '_ref' suffix
[18:23:31] <erickt> brson: so we were renaming fns like `map_ref(fn(&T) -> U) -> U` to `.map(...)` and `map_consume(fn(T) -> U) -> U` to `.map_move(...)`
[18:23:52] <ecr> chubby: out of curiosity, why do you want to restrict to one thread anyway?
[18:25:02] <erickt> brson: for the .map* fns, this was fine because we have a pretty even use of the map-by-ref and map-by-move, but in the case of the .chain fns, chain-by-move completely dominates the .chain-by-ref users
[18:25:08] <kimundi> jclements: Of course, actually designing and implementing it is another problem. 
[18:25:17] <jclements> kimundi: yep
[18:25:24] <brson> erickt: so I think the answer to your question is yeah, just add the and_then_ref back and make further decisions later
[18:25:37] <erickt> brson: ok will do :)
[18:25:40] <erickt> thanks
[18:26:29] <brson> erickt: so whether any given family of methods is by-ref by default or by-move by default is probably going to be case dependent?
[18:27:47] <Seldaek> strcat, cmr, tikue: I hear students have been updated, pretty good feedback loop under a day from irc to class room ;) check slide 24 of today's class http://www.cs.virginia.edu/~evans/cs4414-fall2013/class5.html
[18:27:54] <erickt> brson: yeah. I think it makes sense that the iterator-like fns are by-ref by default, but I don't think all shortnamed fns should be by-ref by default
[18:28:05] <erickt> brson: back in a minute
[18:28:44] *** Joins: jviereck (Adium@moz-58A87BA7.dip0.t-ipconnect.de)
[18:29:19] <cmr> Seldaek: Awesome!
[18:29:22] <strcat> brson: another issue is that if we do have a default iterator via iterable, you need to pick between move, & and &mut for that
[18:29:27] <cmr> Seldaek: I'm working on getting rustdoc upstreamed right now.
[18:29:29] <josh> If I have a variable of type ~[u8], and I want to operate on that buffer as a string (iterate over words, in this case), how would I do so without copying?
[18:29:35] <cmr> I'm very close to it working on newest master.
[18:29:48] <cmr> Seldaek: I can't continue maintaining the extra::json variant encoding patch though :\
[18:29:48] <strcat> josh: slice into it
[18:29:51] <tikue> Seldaek: wow awesome
[18:29:55] <strcat> josh: slices are views into arrays
[18:30:14] <tikue> you done good 
[18:30:16] <cmr> Seldaek: How much of a PITA would it be for you to handle it? I can add a postproc pass that just massages the enum variants into a better form if it'd be annoying.
[18:30:16] <tikue> :)
[18:30:32] <strcat> josh: there are some methods returning iterators of slices already, for some common things like splitting - so you may not need to manually do .slice(start, end)
[18:30:45] <Seldaek> cmr: ok cool, sorry I'm not around much lately.. have some personal shit to deal with but I hope I find a minute to merge new search and all that soonish
[18:30:50] <kimundi> jclements: Hm, I'm imagining that an importable macro would be able to refer to private items in the module it's defined, and that any identifiers it 'captures' would be visisble as part of the public 'api' - something like being able to see what it captures in the documentation, or even needing to explicitly list those identifiers in the source if you want to mark it public
[18:30:57] <ww> is it possible to reference a previously initialized struct member at a later initialization?  e.g.  struct1 {  field1: 123, field2: field1 + 10 }
[18:31:14] <cmr> Seldaek: np, I've been super busy too.
[18:31:19] <Seldaek> cmr: not sure what that means anymore but I guess we can live with it.. can't it be merged?
[18:31:25] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[18:31:31] *** Joins: five (five@7BC474E8.1A836B9F.A1E43171.IP)
[18:31:36] <cmr> Seldaek: I never got it to pass tests, and couldn't figure out extra::json
[18:31:57] <strcat> rusti: let xs = [1, 1, 2, 1, 1, 2, 1, 1]; xs.split_iter(2).fold(0, |a, &b| a + b)
[18:32:01] <cmr> it's the ["VariantName", ...] as opposed to {"variant": "foo", "contents": ....}
[18:32:02] -rusti- pastebinned 8 lines of output: http://ix.io/80b
[18:32:03] <strcat> er
[18:32:19] *** Quits: hoverbear (andrew@EBFA78B5.F19E5E7B.E74D50F2.IP) (Quit: hoverbear)
[18:32:31] <strcat> that was a silly attempt at an example ;p
[18:32:38] <Seldaek> cmr: yeah I see.. well it'll just make the code look uglier and will probably waste me a few hours of debugging, but it's nothing we can't live with
[18:32:53] *** Quits: Infiltrator (Infiltrato@4669028E.25A9890C.4B4F1E7A.IP) (Ping timeout)
[18:33:04] <SiegeLord> What trait would I use to describe a type that can be converted to a float?
[18:33:10] <strcat> rusti: let xs = [1, 3, 2, 4, 5, 2, 8, 1]; print!("{:?}", xs.split_iter(2).to_owned_vec())
[18:33:12] -rusti- pastebinned 9 lines of output: http://ix.io/80c
[18:33:16] *** Joins: Infiltrator (Infiltrato@4669028E.25A9890C.4B4F1E7A.IP)
[18:33:22] <strcat> rusti: let xs = [1, 3, 2, 4, 5, 2, 8, 1]; print!("{:?}", xs.split_iter(|x| *x == 2).to_owned_vec())
[18:33:24] -rusti- ~[&[1, 3], &[4, 5], &[8, 1]]()
[18:33:29] <strcat> josh: ^
[18:33:29] <cmr> Seldaek: I'll just do stuff on my end, then, it's easier.
[18:33:44] *** Joins: hoverbear (andrew@EBFA78B5.F19E5E7B.E74D50F2.IP)
[18:33:49] <josh> strcat: thanks, I'm trying to understand what you mean
[18:33:55] <jclements> kimundi: yep, that sounds plausible. It's not as nice as what you get in, say, Racket, where you can guarantee that the "induced exports" are not actually public. Also, procedural macros open up another can of worms; then you start getting into the "tower of execution times" problems. Finally, what happens when a macro captures a reference to a local var? That could just be illegal, maybe, if it's exported. Or just allowed to be an unbo
[18:33:56] <jclements> ref.
[18:34:01] <tikue> http://www.dorina.org/pubs/strings.html lol!
[18:34:03] <Seldaek> cmr: if you can it'd be great I'm not gonna lie ;)
[18:34:05] <cmr> pcwalton: the family doesn't seem to have enough information to reconstruct the Def; specifically DefPrimTy
[18:34:17] <strcat> josh: so, a &[] is represented as a pointer + length and just points into the original array
[18:34:22] <pcwalton> hmm I thought it did
[18:34:26] <pcwalton> isn't that what each_path did?
[18:34:36] <Seldaek> tikue: yeah I saw that, this guy has some unorthodox teaching style but it seems fun :p
[18:35:25] <tikue> Seldaek: every prof I've had with children likes to brag about them heh
[18:35:32] <cmr> "no documentation"
[18:35:34] <cmr> Harsh
[18:35:41] <cmr> pcwalton: Let me look
[18:35:48] *** Quits: five (five@7BC474E8.1A836B9F.A1E43171.IP) (Ping timeout)
[18:36:16] *** Quits: chubby (Mibbit@moz-20CEEF38.hsd1.ca.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[18:36:32] <cmr> pcwalton: oi, how did you snag mimiga.net! That's awesome!
[18:36:37] <ecr> ww: I have no idea, but I suspect the answer is no. I think you'd have to abstract it out as a function that takes in the non-dependent arguments and then initialize the struct from them and the computed dependent arguments
[18:37:17] <Seldaek> cmr: well anyways I have to go, but let me know if you have a new build I should test with later, and good luck :/
[18:37:33] <cmr> Seldaek: ok, thanks.
[18:38:04] <ecr> cmr: I know! We have TONS of documentation. It's just all written in Rust right now.
[18:38:14] *** Joins: five (five@7BC474E8.1A836B9F.A1E43171.IP)
[18:39:04] *** Quits: five (five@7BC474E8.1A836B9F.A1E43171.IP) (Connection reset by peer)
[18:39:51] <cmr> ecr: They clearly need to come into IRC than trying to work everything out on their own
[18:39:56] *** Quits: kelvin (kelvin@4C416360.3C990DFD.DDE5D3F6.IP) (Client exited)
[18:41:59] <ecr> cmr: I've seen a one or two around, but that's it really.
[18:42:05] <ww> rusti: str.connect(&["abc", "123"], "-")
[18:42:06] -rusti- <anon>:5:9: 5:12 error: unresolved name `str`.
[18:42:06] -rusti- <anon>:5          str.connect(&["abc", "123"], "-")
[18:42:06] -rusti-                   ^~~
[18:42:06] -rusti- error: aborting due to previous error
[18:42:06] -rusti- application terminated with error code 101
[18:42:18] <ww> rusti: str::connect(&["abc", "123"], "-")
[18:42:20] -rusti- pastebinned 11 lines of output: http://ix.io/80e
[18:42:27] <brson> strcat: what are our prospects for Iterable right now? Can we do it?
[18:42:42] <ww> rusti: std::str::connect(&["abc", "123"], "-")
[18:42:42] -rusti- <anon>:5:9: 5:26 error: unresolved name `std::str::connect`.
[18:42:43] -rusti- <anon>:5          std::str::connect(&["abc", "123"], "-")
[18:42:43] -rusti-                   ^~~~~~~~~~~~~~~~~
[18:42:43] -rusti- error: aborting due to previous error
[18:42:43] -rusti- application terminated with error code 101
[18:43:06] <strcat> brson: I think we can write it with the current language, but niko might have to fix some more 'self bugs first ;p
[18:43:26] <strcat> it would be something like
[18:43:27] *** Quits: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[18:43:48] <strcat> trait Iterable<A, T: Iterator<A>> { fn iter(self) -> T }
[18:44:01] <strcat> and then you'd implement it for `&'self Container`
[18:44:13] <strcat> and A would be &'self A
[18:44:23] <cmr> strcat: and would need language support to do `for x in iterable`, right?
[18:44:32] <ww> rusti: StrVector::connect(["aa", "bb"], "-")
[18:44:33] -rusti- <anon>:5:9: 5:27 error: unresolved name `StrVector::connect`.
[18:44:33] -rusti- <anon>:5          StrVector::connect(["aa", "bb"], "-")
[18:44:33] -rusti-                   ^~~~~~~~~~~~~~~~~~
[18:44:33] -rusti- error: aborting due to previous error
[18:44:33] -rusti- application terminated with error code 101
[18:44:35] <strcat> cmr: yeah but that's separate from just defining the trait
[18:44:58] *** Quits: Peng (mnordhoff@moz-D5175E95.mattnordhoff.net) (Ping timeout)
[18:45:24] <kimundi> cmr: Basically, the for syntax needs to evolve from suagr to something that actually knwos if it's called with an Iterator, or an Iterable
[18:45:27] <ecr> strcat: what's the purpose of Iterable?
[18:45:46] <kimundi> ecr: Allowing the Iterator adapter to call .iter() themself
[18:45:50] <strcat> ecr: allows you to define fold, map, filter, etc. as default methods on containers using their iterators
[18:45:55] <strcat> so
[18:45:58] <strcat> xs.iter().fold()
[18:46:00] <strcat> would become xs.fold()
[18:46:04] <strcat> with no extra effort from the container
[18:46:22] <strcat> and for loops could also be taught to use either an Iterator lang item or Iterable
[18:46:33] <strcat> they need to be impl'ed in librustc instead of the compiler first
[18:46:40] *** eevee_ is now known as eevee
[18:47:56] <brson> strcat: the 'for' loop support is the tricky part though, right?
[18:48:22] <strcat> brson: well, the tricky part is implementing it in librustc which we already need to do
[18:48:22] *** Joins: kelvin (kelvin@4C416360.3C990DFD.DDE5D3F6.IP)
[18:48:30] <strcat> adding Iterable support wouldn't be hard, once you had that
[18:48:43] <strcat> brson: so, atm
[18:48:49] <strcat> for pat in iterator {}
[18:48:51] <strcat> turns into
[18:48:57] <bstrie> in other words, would need to longer just be a lexer hack
[18:49:18] <cmr> pcwalton: Ah, I was looking for item_to_def_like!
[18:49:20] <bstrie> *parser hack
[18:49:24] <strcat> let it = &mut iterator; loop { match it.next() { Some(pat) => { /* block */ } None => break } }
[18:49:31] <cmr> pcwalton: which also doesn't handle prim_ty
[18:49:38] <kmc> I wonder if there is a way to extend pattern matching to handle things like Option::take
[18:49:46] <strcat> brson: the parser version has to use &mut, because your iterator might be a temporary rvalue
[18:50:01] <kmc> in general pattern-matching seems less awesome with value/move semantics, and I'm wondering how to bridge that gap
[18:50:01] <strcat> but that's annoying, because if your iterator is an lvalue, you don't *need* to borrow it
[18:50:04] <strcat> you should be able to write
[18:50:16] <erickt> brson: back if you had anything else
[18:50:28] <strcat> let mut it = ...; for x in it { if cond { it.next() /* skip one */ } ... }
[18:50:36] <strcat> but atm you can't because it freezes it with that &mut borrow
[18:50:48] <strcat> so there are other advantages to doing it in librustc
[18:50:54] <strcat> can be more precise about borrows, and give saner errors
[18:51:23] *** Quits: hoverbear (andrew@EBFA78B5.F19E5E7B.E74D50F2.IP) (Quit: hoverbear)
[18:51:30] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[18:52:18] *** Joins: eagen (eagen@8737942B.7A99C13A.B7961A98.IP)
[18:53:40] <ecr> kmc: ref helps a little bit, but I know what you mean
[18:53:54] <ecr> I don't have a good answer for it though
[18:54:22] *** Joins: Peng (mnordhoff@moz-7D361D8B.compute-1.amazonaws.com)
[18:54:23] <kelvin> I'm confused about the use of apostrophe's. What do the represent? For example: type Pair<'self> = (int,&'self str);
[18:54:30] <kmc> that's a lifetime parameter
[18:54:46] <strcat> kelvin: a simpler example without type parameters would be:
[18:55:11] <strcat> fn foo<'r>(a: &'r int, b: &'r int) -> &'r int { ... }
[18:55:15] <kmc> http://static.rust-lang.org/doc/tutorial-borrowed-ptr.html#named-lifetimes
[18:55:35] <kmc> er actually start at http://static.rust-lang.org/doc/tutorial-borrowed-ptr.html#returning-borrowed-pointers
[18:55:40] <strcat> where foo returns a pointer which cannot outlive the `a` or `b` parameters
[18:55:45] <cmr> Well, rustdoc_ng builds again, but still segfaults.
[18:55:58] <Amaranth> Whoa, there is more than one tutorial page?
[18:56:01] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[18:56:01] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 144e3d499 to 14248765a: 02http://git.io/N3iJvQ
[18:56:01] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[18:56:03] <Amaranth> Apparently I missed those links
[18:56:05] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[18:56:05] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/NNLmkg
[18:56:05] <ghrust> 13rust/06auto 14a018a5c 15Alex Crichton: Parse underscores in identifiers for format!...
[18:56:05] <ghrust> 13rust/06auto 14a6be8d3 15bors: auto merge of #9140 : alexcrichton/rust/issue-9119, r=huonw...
[18:56:05] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[18:56:13] <strcat> Amaranth: yeah, there's an iterator tutorial, an ffi one, a task one, a conditions one, ;p
[18:56:29] <strcat> the web pages are not laid out well at all
[18:56:45] <Amaranth> This borrowed pointer one would have been the main help so far, a good chunk of yesterday was spent trying to understand them
[18:56:54] <ecr> Amaranth: they're linked from the bottom of the tutorial
[18:56:58] <Amaranth> Turned out I wasn't thinking clearly and didn't need them at all but yeah
[18:57:03] <kelvin> kmc ,strcat: thanks!
[18:57:03] <ecr> in the 'What Next?' section
[18:57:11] <strcat> we should likely have all of them in the index
[18:58:02] *** Joins: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP)
[18:59:23] <luisbg> lines_for_loop.rs:4:15: 4:17 error: expected `{` but found `in`
[18:59:23] <luisbg> lines_for_loop.rs:4     for friend in friends.iter() {
[18:59:41] <cmr> luisbg: Are you using 0.7?
[18:59:48] <luisbg> when friends is a vector... let friends = ["a", "b", "c"]
[18:59:51] <luisbg> cmr, latest, so yes
[19:00:04] <cmr> luisbg: 0.7 isn't the latest, git is the latest.
[19:00:10] <cmr> That syntax didn't exist in 0.7
[19:00:12] <cmr> You should upgrade.
[19:00:13] <luisbg> cmr, that is true
[19:00:16] <luisbg> I should switch to git
[19:00:47] <ruediger> rusti is broken for me in git (or at least the ubuntu nightlies)
[19:00:51] <luisbg> btw... rust-lang.com does not point to www.rust-lang.com
[19:00:57] <mcpherrin> ruediger: typical :P
[19:01:12] *** Joins: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[19:01:30] <strcat> ruediger: rusti isn't really expected to work yet
[19:01:31] <luisbg> cmr, Thanks
[19:01:56] *** Joins: hoverbear (andrew@EBFA78B5.F19E5E7B.E74D50F2.IP)
[19:02:14] <cmr> So I'm getting a segfault in serialize::Encodable$Option::encode::anon::expr_fn::_95aman
[19:02:25] <ecr> strcat's rusti is literally the only version I've been able to make work
[19:02:38] <strcat> my rusti isn't rusti ;]
[19:02:40] <cmr> Which appears to be https://github.com/mozilla/rust/blob/master/src/libextra/serialize.rs#L496
[19:02:41] <ecr> I have no idea what black magic you did strcat
[19:02:46] <strcat> it's rustc
[19:02:46] <ecr> but keep doing it
[19:02:48] <cmr> Which is very worrying.
[19:03:05] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[19:03:07] <ruediger> strcat: it seems to work in 0.7
[19:03:23] <bstrie> ecr: years ago I had a rusti written in python that worked perfectly well :P
[19:03:26] <strcat> yeah but at some point after 0.7 we turned the tests off for rusti and broke it
[19:03:29] *** Quits: jstevans2 (Instantbir@26E43217.E8B6FA7D.DDE5D3F6.IP) (Ping timeout)
[19:03:40] <myname> lol
[19:03:41] *** Quits: hoverbear (andrew@EBFA78B5.F19E5E7B.E74D50F2.IP) (Quit: hoverbear)
[19:03:48] *** Joins: Peng_ (mnordhoff@moz-D5175E95.mattnordhoff.net)
[19:03:50] <strcat> bstrie: well perfectly well would be keeping state but not bailing out on 1 error
[19:03:53] <strcat> ;p
[19:03:55] <strcat> cling manages, for C++
[19:04:21] <strcat> afaik it gets the AST from libclang and handles assignments itself
[19:04:23] <bstrie> strcat: mine didn't bail out on errors! any runtime or compilation failure didn't preserve the command that caused it
[19:05:01] <strcat> bstrie: ah that makes sense
[19:05:11] <bstrie> good ol' save-every-line-and-recompile-the-whole-damn-thing-every-time-you-hit-enter school of repls
[19:05:34] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[19:06:01] <bstrie> granted, it expected you to use the magic print function to print things, unless you really really wanted to print that string after every command...
[19:06:06] * kimundi wants to give that OS course professor an imaginary internet point somewhere
[19:06:27] <bstrie> kimundi: yes, after reading his slides he seems like quite the character
[19:06:45] *** Joins: squiddy (squiddy@moz-AF1F09D5.adsl.alicedsl.de)
[19:06:52] *** Quits: cstrahan (cstrahan@moz-71FAC30.hsd1.va.comcast.net) (Ping timeout)
[19:07:12] <myname> can you get the slides if you are not at piazza?
[19:07:23] *** Quits: rossm (rossm@moz-EE3BB1DC.br.br.cox.net) (Quit: )
[19:07:26] *** Joins: cstrahan (cstrahan@moz-71FAC30.hsd1.va.comcast.net)
[19:07:30] <cmr> ughhhhhhhhhhhhhhh
[19:07:32] <bstrie> myname: http://www.cs.virginia.edu/~evans/cs4414-fall2013/class5.html
[19:07:35] <cmr> I accidentally all of my changes.
[19:07:40] <cmr> with git reset --hard :(
[19:07:43] <strcat> cmr: reflog?
[19:07:48] <bstrie> cmr: :(((
[19:07:52] <kimundi> cmr: ouch
[19:07:55] <cmr> strcat: unstaged :(
[19:07:56] <strcat> cmr: vim undo trees?
[19:07:58] <bstrie> does the reflog save things you never committed?
[19:08:01] <cmr> oh!
[19:08:17] <strcat> cmr: as long as you still have those files open in vim
[19:08:20] <strcat> from before
[19:08:28] <strcat> maybe you don't
[19:08:28] <cmr> I... don't
[19:08:36] *** Joins: maik (maik@moz-3F2CDB33.dip0.t-ipconnect.de)
[19:08:38] <strcat> ;[
[19:08:56] <cmr> Ah well
[19:09:00] <cmr> Making the changes wasn't the hard part.
[19:09:04] <cmr> Figuring out wtf to do was
[19:09:10] <kimundi> life goes on, etc
[19:09:17] <bstrie> cmr: you can make vim persist your undo history, even after closing the files
[19:09:25] <bstrie> I love it
[19:09:31] <strcat> bstrie: yeah but if the files are externally modified it loses the ability to recover
[19:09:40] <bstrie> really? didn't know that
[19:09:40] <tjc> the five stages of accidentally making git nuke your work
[19:09:40] <cmr> bstrie: I do
[19:09:59] <strcat> I make a commit when I edit a line or two
[19:10:01] <bstrie> I guess that makes sense
[19:10:02] <strcat> and amend frequently ;p
[19:10:09] <strcat> so I end up with a bunch of reflog entries
[19:10:09] <cmr> yes, that seems to be a good idea
[19:10:11] * strcat is a bit paranoid
[19:10:15] <cmr> git can't help if I don't help it help me.
[19:10:19] *** jdm is now known as jdm|f00ding
[19:10:29] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[19:10:37] * cmr rebinds :w
[19:11:00] <strcat> seriously though if it takes 10 compiles to get it working, I probably did 10 amends
[19:11:03] <strcat> ;p
[19:11:17] * strcat has a *looooong* reflog
[19:11:44] *** Quits: Peng (mnordhoff@moz-7D361D8B.compute-1.amazonaws.com) (Quit: Peng timeout)
[19:13:31] <strcat> cmr: https://github.com/airblade/vim-gitgutter this makes you feel bad about not amending
[19:13:45] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[19:14:12] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[19:14:13] *** Joins: rossm (rossm@moz-EE3BB1DC.br.br.cox.net)
[19:14:45] <cmr> strcat: I imagine you use fugitive?
[19:14:57] <strcat> yes, but I don't really *use* it much
[19:15:01] <strcat> except for blame
[19:16:28] <eevee> i love gitgutter.  never used fugitive though; use tig for blaming
[19:18:11] <bstrie> rusti: let foo = 2; foo ^= 10; foo
[19:18:14] -rusti- pastebinned 8 lines of output: http://ix.io/80g
[19:19:54] <bstrie> ha, I just realized that != is incongrous with all the *=, ^= etc operators
[19:19:57] <bstrie> in like, every language
[19:20:14] <bstrie> hm, maybe not
[19:20:16] <bstrie> unary operator
[19:20:19] <bstrie> blast!
[19:20:39] <bstrie> thought I had stumbled on some great conspiracy
[19:20:54] <cmr> it's a comparison operator, though
[19:20:58] <cmr> so it's still different.
[19:20:59] <bstrie> like how all languages conspire to use the inexplicable name "string" for a data type
[19:21:13] <cmr> bstrie: or the illusory `static`
[19:21:28] *** Joins: Jesin (Jessin_@moz-679F0D97.cc.lehigh.edu)
[19:22:36] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: zzzzzzzzzz)
[19:22:56] <ecr> and 'variable', which is pretty different from math variables, except for 'immutable variables' which are exactly like math variables, but confuses all the programers because of the apparent contradiction
[19:23:40] <strcat> you could call them symbols but then you have confusion with ELF symbols
[19:23:56] <ecr> there's also 'unsigned integer' rather than 'natural'
[19:24:10] <cmr> ecr: well, the naturals aren't bounded.
[19:24:19] <strcat> they can be
[19:24:23] <ecr> cmr: and yet we use integer...
[19:24:29] <cmr> good point.
[19:25:53] <bstrie> I guess "signed twos-complement 32-bit number" doesn't roll off the tongue
[19:26:02] <bstrie> STC32BN
[19:26:36] <strcat> it's a stretch to call two's complement ints a number ;p
[19:27:09] <strcat> at least unsigned ones obey the rules of math modulo N
[19:28:49] <ecr> and don't even start with floats
[19:29:02] <ecr> those are just abombinations
[19:29:11] <strcat> I dunno
[19:29:21] <strcat> rusti: std::num::abs(2)
[19:29:22] -rusti- 2
[19:29:25] <strcat> rusti: std::num::abs(-128i8)
[19:29:26] -rusti- -128i8
[19:29:26] <ecr> non-associative addition
[19:30:11] <strcat> signed zeroes, weak ordering
[19:30:20] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[19:30:24] <strcat> a < b && !(b < a) does not imply a == b
[19:30:26] <strcat> yay
[19:30:42] <ecr> and the NaN pit of madness
[19:30:59] <ecr> a == b =/=> a != b
[19:31:01] *** mihneadb is now known as mihneadb|lunch
[19:31:06] <ecr> err
[19:31:07] * strcat doesn't know much about NaNs and the denormal stuff
[19:31:08] <kimundi> rusti: (NaN == NaN, NaN != NaN)
[19:31:12] -rusti- pastebinned 14 lines of output: http://ix.io/80i
[19:31:17] <ecr> I meant !(a == b) =/=> a != b
[19:31:23] <ecr> err gah
[19:31:30] <ecr> hold on
[19:31:38] <kimundi> rusti: nan
[19:31:39] <strcat> ecr: for == I think the regular rules hold
[19:31:39] -rusti- <anon>:5:9: 5:12 error: unresolved name `nan`.
[19:31:39] -rusti- <anon>:5          nan
[19:31:39] -rusti-                   ^~~
[19:31:40] -rusti- error: aborting due to previous error
[19:31:40] -rusti- application terminated with error code 101
[19:31:41] *** Joins: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[19:31:41] <strcat> it's for Ord that they don't
[19:31:56] <bstrie> rusti: 1/0
[19:31:57] -rusti- task <unnamed> failed at 'attempted to divide by zero', <anon>:5
[19:31:57] -rusti- application terminated with error code 101
[19:32:02] <ecr> I'm pretty sure NaN == NaN ==> false and NaN != NaN ==> false
[19:32:04] <kimundi> rusti: let NaN = 1.0 / 0.0; (NaN == NaN, NaN != NaN)
[19:32:05] -rusti- (true, false)
[19:32:13] <bstrie> rusti: 1.0/0.0
[19:32:14] -rusti- inf
[19:32:18] <kimundi> do'h
[19:32:19] <strcat> ecr: I think NaN != NaN is true
[19:32:22] <strcat> could be wrong
[19:32:23] <ecr> rusti: 0.0/0.0
[19:32:23] <kimundi> rusti: let NaN = 0.0 / 0.0; (NaN == NaN, NaN != NaN)
[19:32:23] -rusti- NaN
[19:32:24] -rusti- (false, true)
[19:32:37] <kimundi> wait, what?
[19:32:37] <bstrie> haha
[19:32:42] <strcat> ecr: rust could be wrong there
[19:32:47] <strcat> but I don't think it is
[19:32:48] <bstrie> I like how the first is (false, true), and the second is the opposite
[19:32:55] <luisbg> is there any place where I can see a list of projects in Rust? has somebody gathered this?
[19:32:56] <bstrie> or, whatever
[19:33:00] <bstrie> I'm off today
[19:33:02] <kimundi> NaN: confusing if correctly implemented, even more confusing if not
[19:33:10] <erickt> kimundi: NaNs don't equal anything, even themselves
[19:33:14] <ecr> I think rust is correct here
[19:33:19] <luisbg> want to read some Rust code, or not re-develop something that might be there already
[19:33:44] <bstrie> rusti: -1.0/0.0
[19:33:45] -rusti- -inf
[19:33:49] <kimundi> erickt: ... Oh right, it's working correctly
[19:33:55] <cmr> luisbg: https://github.com/trending?l=rust
[19:34:04] <bstrie> rusti: (-1.0/0.0) + (-1.0/0.0)
[19:34:05] -rusti- -inf
[19:34:06] <luisbg> cmr, that is a smart answer :)
[19:34:28] <kimundi> I thought for a moment that NaN!=NaN  ==  NaN==NaN, which is... wrong
[19:34:28] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[19:34:47] <cmr> luisbg: there's not really that much.
[19:34:56] <kimundi> rusti: let NaN = 0.0 / 0.0; (NaN < NaN, NaN == NaN, NaN > NaN)
[19:34:57] -rusti- (false, false, false)
[19:35:00] <strcat> ecr: the equality issue is that they since they don't equal themselves, it allows a DoS of containers
[19:35:11] <ecr> strcat: right
[19:35:21] *** Joins: sinma (sinma@moz-6A11C47C.fbx.proxad.net)
[19:35:38] <strcat> ecr: the ordering issue is because every ordering operator (<, >, <=, >=) returns false so... regular ordering semantics don't hold
[19:35:41] <luisbg> cmr, but a good way to find new stuff when it pops up in github
[19:35:45] <sinma> Hello, how do I use declarations found in others files? with the use statement?
[19:35:47] <luisbg> cmr, https://github.com/jeaye/q3 <- that one is impressive
[19:36:06] <jeaye> :D
[19:36:13] <ecr> strcat: basically, because of NaN, == is not an equivalence relation, and <= is not a partial ordering (or even a pre-ordering I think)
[19:36:18] <ecr> which breaks everything
[19:36:30] <strcat> ecr: yeah
[19:36:40] <luisbg> jeaye, oooh. hello :)
[19:36:44] <jeaye> o/
[19:36:46] <luisbg> jeaye, didn't saw you there
[19:36:47] <luisbg>  \o
[19:36:54] <bstrie> sinma: if you want to import from a file named foo.rs, I think it's `mod foo;`
[19:37:07] <ecr> strcat: throw in + not being what you'd expect (non-associative), and floating point is just madness upon madness
[19:37:10] <bstrie> sinma: if you want to import from a compiled crate, I think it's `extern mod foo;`
[19:37:14] <bstrie> but I'm still uncertain
[19:37:21] <olsonjeffery> so. im finally an OSX user. which version of emacs to use?
[19:37:28] <olsonjeffery> i was previously using it from the terminal in linux.
[19:37:46] <bstrie> olsonjeffery: you're on OSX, which means that if you use emacs then rms will put you on his hit list
[19:38:26] <bstrie> granted, he also does this if you use emacs on ubuntu
[19:38:39] <bstrie> and probably debian
[19:38:49] <Jimi> time to buy a yeelong...
[19:38:51] <olsonjeffery> to be fair, he does that for any linux distribution that keeps closed source binary blobs in their repos
[19:39:20] <olsonjeffery> you only escape his wrath if you use GNU Hurd and open spec hardware
[19:39:26] *** Jimi is now known as jzelinskie
[19:39:42] <sinma> bstrie: I dunno why it breaks my code
[19:39:49] <cmr> luisbg: rust-http and grease-bench are also some newer, notable projects.
[19:39:52] *** Quits: azakai (alon@moz-BBE3ABD.mv.mozilla.com) (Quit: Ex-Chat)
[19:40:16] <sinma> bstrie: I donâ€™t find a method implâ€™ed on a struct in the same file
[19:40:24] <luisbg> cmr, is rust-http an http server?
[19:40:25] <olsonjeffery> anyways. seriously though. best emacs distro.
[19:40:52] <cmr> luisbg: http library.
[19:40:58] <cmr> but yes,
[19:41:03] <jzelinskie> last time i asked in #emcas, they told me to just use normal emacs
[19:41:08] <jzelinskie> #emacs*
[19:41:21] <luisbg> cmr, cool!
[19:41:22] *** Joins: carllerche (carllerche@1E2EB9E3.186539A3.965084DF.IP)
[19:41:26] <olsonjeffery> yeah. i might just build from src.
[19:41:32] <sinma> olsonjeffery: you can use totally free distributions
[19:41:32] <jzelinskie> one of the professors at my school made aquamacs, but people i had issues with it and people on IRC laughed at me for even trying to use it
[19:41:49] *** Joins: sebcrozet (sebcrozet@moz-2517AE39.w80-13.abo.wanadoo.fr)
[19:41:54] <sinma> olsonferry: like Trisquel or Parabola GNU/Linux :p
[19:42:06] *** Joins: adridu59 (Mibbit@moz-6C393FDD.rev.numericable.fr)
[19:42:17] <jzelinskie> but i had*
[19:42:21] <adridu59> the do x.times syntax is deprecated on master right?
[19:42:46] <kimundi> bstrie, sinma: http://static.rust-lang.org/doc/tutorial.html#crates-and-the-module-system
[19:42:56] <strcat> adridu59: removing it is an open RFC
[19:43:14] <bstrie> adridu59: I don't want to remove it :)
[19:43:32] <sinma> But itâ€™s mandatory to use mod?
[19:43:35] <adridu59> bstrie: why? duplicate with range
[19:43:59] * kimundi feels strange for linking the tutorial all the time just because he rewrote it...
[19:44:06] <Scriptor> doesn't aquamacs change a bunch of the key commands?
[19:44:11] <adridu59> well semantically it would be range_inclusive(1,x)
[19:44:15] <Scriptor> makes reading docs on emacs online a pain
[19:44:18] <sinma> kimundi, bstrie: there are another way to use what is in another file no?
[19:44:24] *** jorendorff is now known as jorendorff_away
[19:44:50] <bstrie> adridu59: https://github.com/mozilla/rust/pull/8371#issuecomment-22271547
[19:45:02] <strcat> adridu59: no it's range(0, x)
[19:45:08] <strcat> range_inclusive is never empty
[19:45:33] <strcat> maybe it should be empty if the start is above the end
[19:45:46] *** Quits: jgilbert (jgilbert@40BD3B76.2AD327F9.973C8D27.IP) (Ping timeout)
[19:46:04] <ww> rusti: vec::with_capacity(5).len()
[19:46:06] -rusti- pastebinned 11 lines of output: http://ix.io/80k
[19:46:32] <ww> rusti: std::vec::with_capacity(5).len()
[19:46:32] -rusti- <anon>:5:9: 6:5 error: cannot determine a type for this expression: unconstrained type
[19:46:33] -rusti- <anon>:5          std::vec::with_capacity(5).len()
[19:46:33] -rusti- <anon>:6     };
[19:46:33] -rusti- error: aborting due to previous error
[19:46:33] -rusti- application terminated with error code 101
[19:47:01] <strcat> ww: length/capacity are separate
[19:47:02] <adridu59> bstrie: so because it's simpler? no really simpler. strcat: well it's the same anyway; no one's gonna do a do 0.times
[19:47:22] <strcat> well if you do x.times, x could be 0
[19:47:25] <kimundi> sinma: First, files are irrelevant for the module system in rust. Storing your code in different files is just an optional thing to do. 
[19:47:30] <strcat> so range(0, x) is the right translation
[19:47:33] <ww> strcat: how do i make a vec with N length, not just capacity
[19:47:48] <ww> fill it with 0?
[19:47:55] <bstrie> adridu59: sigh, because it's Good Marketing. it's a toy that also happens to be useful
[19:47:59] <strcat> ww: well whatever values you want to initialize it with
[19:48:02] <strcat> what type of vector is it?
[19:48:05] <sfackler> ww: vec::from_elem(n, 0)
[19:48:06] <ww> [u8]
[19:48:07] *** Joins: jgilbert (jgilbert@E3D90E00.12EE5EA8.C0D9FBB9.IP)
[19:48:15] <ww> ic
[19:48:17] <ww> thx
[19:48:39] <bstrie> a lot of people don't expect that it's possible for users to implement methods on built-in types. .times() is intended as a demonstration of this (among other things)
[19:48:45] <adridu59> bstrie: meh, I agree with thestinger on that oen
[19:48:48] <adridu59> one*
[19:49:00] <bstrie> adridu59: well I disagree with your agreement :)
[19:49:07] <kimundi> sinma: A *rs file always contains the body of a module of a crate. Usually you want them all to belong the the same crate. ;) 
[19:49:21] *** Quits: jeaye (Jeaye@moz-34FEF2BB.hsd1.ca.comcast.net) (Ping timeout)
[19:49:25] <strcat> range(0, x) could be 0.upto(x), if I had done it as a method ;p
[19:49:35] <bstrie> strcat: I proposed that, a long time ago :P
[19:49:44] <bstrie> in the end it was too cute even for me
[19:49:52] <strcat> I don't like the idea of a weird method being added to your type without you asking for it
[19:50:10] <strcat> it'd get added as soon as you had whatever range needs (Add, One)
[19:50:14] <kimundi> (0 `upto` 10).map(...) // !!
[19:50:29] * bstrie defenestrates kimundi
[19:51:02] <adridu59> bstrie: someone also suggested to only have a small method on uints which would be lightweight... but still represent 2 ways of writing the same thing, which I think should be done generally unless each serve their own purpose. Marketing is not a purpose a programming language should have
[19:51:11] <adridu59> should not*
[19:51:12] * kimundi notices he is now living on the second floor
[19:51:18] * kimundi sadfaces
[19:51:22] *** Joins: jeaye (Jeaye@moz-34FEF2BB.hsd1.ca.comcast.net)
[19:51:56] <bstrie> adridu59: you neglect public relations at your own peril.
[19:52:01] <adridu59> bstrie: also, "The Times trait is missing implementations for u8, u16, u32 and u64 which is why it doesn't require the integer suffix. There's also no implementation for big unsigned integers."
[19:52:17] <adridu59> bstrie: also "It's not possible to break from `times` and it results in the restrictions coming from closures."
[19:53:04] <kimundi> Would implementing 'for' in rustc allow it to ommit empty ppaterns again?
[19:53:11] <kimundi> for 5.times() { ... }
[19:53:16] <adridu59> bstrie: between do 100.times() and for _ in range(0, 100u), honestly it's pretty much the same, through for is much more modular
[19:53:22] <strcat> kimundi: no
[19:53:23] <kimundi> rather than for _ in 5.times() {}
[19:53:25] <cmr> So I accidentally seemed to have included a submodule change in one of my rustdoc commits
[19:53:30] <strcat> ambiguous due to the pattern coming before the iterator
[19:53:31] <bstrie> adridu59: 1) the intent of .times() is to be used directly on numeric literals, 2) I've been a question-answerer on several rust communities for two years and have never ever heard anyone get confused out of the inability to break from within .times(). that's a silly argument
[19:53:34] <cmr> How do I go through and revert that?
[19:53:42] <cmr> Submodules confuse the bejesus out of me :(
[19:53:44] <maik> can collect generate the type []?
[19:53:47] <strcat> bstrie: you used to be able to break from times
[19:53:52] *** Quits: jeaye (Jeaye@moz-34FEF2BB.hsd1.ca.comcast.net) (Ping timeout)
[19:53:52] <maik> or only owned vectors?
[19:54:04] <strcat> bstrie: it implemented the old `for` protocol
[19:54:09] *** Joins: aeqwa (aeqwa@moz-E420D1B4.dsl.tropolys.de)
[19:54:16] <ecr> bstrite: I'm with kimundi. `upto` looks awesome
[19:54:18] <sinma> kimundi: I didnâ€™t understand the system of crate because I donâ€™t read this part of the tutorialâ€¦
[19:54:21] <bstrie> strcat: and yet after the change, nobody has come asking to do so, leading me to believe that it's a non-issue
[19:54:32] <strcat> bstrie: because Times is redundant
[19:54:46] <bstrie> strcat: times is used in 100+ places in the compiler
[19:54:58] <strcat> bstrie: yeah, it's a real performance issue
[19:54:59] <bstrie> or at least it was, perhaps you removed the uses in favor of range
[19:55:03] <strcat> not yet
[19:55:09] <bstrie> I'm fine with removing the uses
[19:55:11] <ww> what's the difference between uint and u32?  
[19:55:12] <bstrie> not the interface
[19:55:15] *** Joins: jeaye (Jeaye@moz-34FEF2BB.hsd1.ca.comcast.net)
[19:55:25] <strcat> ww: uint is not always 32-bit
[19:55:31] <strcat> it is pointer-size
[19:55:42] <adridu59> bstrie: my 2) is not a silly argument, I'm just pointing a limitation, for is almost the same, 6-7 characters more and tons of modularity gained. for the semantics except for someone who hasn't done programming ever it will feel intuitive. And making people think a language is dead-simple when it's not (just looking at the different pointer types, I mean c'mo
[19:55:43] <ww> it is system dependent?
[19:55:49] *** Joins: hoverbear (andrew@EBFA78B5.F19E5E7B.E74D50F2.IP)
[19:55:55] <strcat> ww: arch dependent, yes
[19:55:58] <adridu59> n it's meant to replace C++!) is not what people would expect and would look for
[19:55:59] <ww> ok thx
[19:56:03] <bstrie> adridu59: you can't break at all from HOF in rust. .times is intended to show off HOF in rust.
[19:56:13] <strcat> it's 32-bit on x86 and x32, and 64-bit on x86_64 - for example
[19:56:23] <adridu59> bstrie: what's HOF?
[19:56:30] <ecr> higher order functions
[19:56:35] <kimundi> sinma: Was that a question?
[19:56:38] <ecr> functions that take or return other functions
[19:56:46] <maik> how do we call [] again? static vector?
[19:56:47] <bstrie> adridu59: I've written about 100 lines of C++ in my life. I'm a python and javascript programmer. but by all means, continue to tell me why I'm not welcome here :P
[19:56:57] <strcat> maik: fixed-size vector
[19:57:13] <maik> strcat, ah thanks
[19:57:23] <kimundi> maik: [T, ..N] is a fixed sized one, ~[T] an owned, @[T] an manged one, and &[T] a slice
[19:57:31] <maik> can .collect generate a fixed size vector?
[19:57:42] <kimundi> maik: Nothing can currently
[19:57:49] <ecr> I don't think we can impl stuff on fixed sized vectors right now
[19:57:49] <maik> kimundi, :(
[19:57:52] <adridu59> bstrie: lol I'm not, it's just that Rust isn't a keep-it-simple language (well it simplifies stuff that was previously unnecessarily complicated by it's still a C++-like language)
[19:57:57] <kimundi> maik: Because that would mean writing generic code the works for any length N
[19:57:59] *** Quits: aeqwa (aeqwa@moz-E420D1B4.dsl.tropolys.de) (Ping timeout)
[19:58:03] <kimundi> maik: And we can't do that yet
[19:58:07] <ecr> fixed sized vector is some weird pseudo type at the moment
[19:58:18] <sinma> kimundi: no, juste to notify you that Iâ€™ve read your message and that Iâ€™ll read the doc later
[19:58:27] <adridu59> anyways, I've gotta go. good night everyone
[19:58:31] <bstrie> adridu59: yes, I agree about keeping it simple. I'm against TIMTOWTDI in general. but .times() serves a purpose, even if the purity-minded folks don't want to believe it
[19:58:33] *** Quits: adridu59 (Mibbit@moz-6C393FDD.rev.numericable.fr) (Quit: http://www.mibbit.com ajax IRC Client)
[19:58:44] *** Joins: mermi (Mibbit@moz-6C393FDD.rev.numericable.fr)
[19:58:51] *** Quits: mermi (Mibbit@moz-6C393FDD.rev.numericable.fr) (Quit: mermi)
[19:58:54] <kimundi> maik: Additionally, I don't think collecting to a fixed sized one in general would work, the count of the iterator elements is not known at compile time
[19:59:08] *** Joins: Ferio (Mibbit@moz-23CDE542.fullrate.dk)
[19:59:08] <kimundi> sinma: Sure, no problem :)
[19:59:40] <kimundi> sinma: And if you don't understand the docs, feel free to ask again, just wanted to point them out. :)
[20:00:19] <ecr> i wonder if we could add just enough dependentness to types to make all vectors encode their sizes, but still remain decidable
[20:00:52] <luisbg> https://github.com/mozilla/rust/wiki/Libs
[20:00:56] <luisbg> edited 4 months ago
[20:00:59] <luisbg> is that page up to date?
[20:01:05] <strcat> no
[20:01:30] <strcat> formatting was implemented, for one thing
[20:01:33] <kimundi> ecr: I think someone said the same a week ago, with the answer being 'nope'
[20:01:42] <kimundi> (as in: still undecidable)
[20:01:46] <luisbg> strcat, and I/O as well, right?
[20:02:11] <luisbg> std::io
[20:02:18] <strcat> that's obsolete
[20:02:20] <kimundi> PA: Never trust a rust wiki page, they are even older than the manual
[20:02:41] <luisbg> strcat, the wiki page?
[20:02:47] * kimundi thinks we should just migrate all wiki pages to tested documentation in-tree
[20:02:47] <strcat> luisbg: no, std::io
[20:02:51] <luisbg> kimundi, was that meant to me :P
[20:02:52] <strcat> and std::rt::io isn't fully sketched out yet (and definitely not fully implemented)
[20:02:52] <luisbg> ?
[20:03:12] <luisbg> strcat, has there been any work done on the datetime module?
[20:03:15] <brendanc> lock hwres
[20:03:26] <strcat> luisbg: don't know
[20:03:27] <brendanc> oops, wrong window
[20:03:35] <kimundi> luisbg: Not specifically you ;)
[20:03:35] <ecr> kimundi: hm. I seem to recall decidable type systems that encode vector length. I'm really not sure
[20:03:42] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[20:03:45] *** sam113101 is now known as sam113101_afk
[20:03:48] <luisbg> kimundi, ooooh PA as in Public Announcement
[20:03:50] <kimundi> ecr: I might rember wrong
[20:04:22] <kimundi> luisbg: Ah, is that what the abbreviation stands for?
[20:04:36] <luisbg> kimundi, :)
[20:04:43] * kimundi has sometimes the problem of knowing phrases just from context
[20:04:57] *** sam113101_afk is now known as sam113101
[20:05:23] <strcat> brson: btw for this 'things we should consider unsafe' documentation - these are things even unsafe {} blocks shouldn't do, right?
[20:05:24] <sinma> kimundi: itâ€™s what I do everytime :p
[20:05:52] <Ferio> bstrie: if you're a python programmer you should want to remove .times => PEP20 ;)
[20:05:53] <kimundi> sinma: haha, all right :)
[20:05:59] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[20:05:59] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/NNLmkg
[20:05:59] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[20:06:14] <strcat> brson: since there's obviously a lot of safe stuff you can do, but need unsafe {} blocks for since it can't be proven safe
[20:06:27] * kimundi prepares seat for watching a Ferio defenestration.
[20:07:55] <ecr> sigh
[20:08:03] *** Joins: SingingBoyo (brandon@moz-19828C59.eng.wind.ca)
[20:08:11] <ecr> more deadlocks
[20:08:43] <kimundi> ecr: Better than undeadlocks
[20:08:52] *** Joins: jeaye_ (jeaye@moz-A4DD04C2.blinkenshell.org)
[20:09:35] <ecr> kimundi: true. I must of messed up refactoring somewhere
[20:09:50] *** Joins: ceninan (ceninan@moz-6BD43586.a370.priv.bahnhof.se)
[20:11:01] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[20:11:01] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/mk5yOg
[20:11:01] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[20:11:02] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[20:11:02] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/aRCPqw
[20:11:02] <ghrust> 13rust/06auto 14b7435cf 15Daniel Micay: implement raw pointer comparisons in librustc...
[20:11:02] <ghrust> 13rust/06auto 14cabba6b 15bors: auto merge of #9136 : thestinger/rust/ptr, r=alexcrichton...
[20:11:02] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[20:11:04] *** Quits: Florob (Florob@moz-39532932.de) (Client exited)
[20:11:25] <ecr> I guess I can try doing it again
[20:11:30] *** Quits: jeaye (Jeaye@moz-34FEF2BB.hsd1.ca.comcast.net) (Quit: Don't tell them I was here...)
[20:11:34] *** Joins: jeaye (Jeaye@moz-34FEF2BB.hsd1.ca.comcast.net)
[20:11:50] <strcat> https://github.com/mozilla/rust/wiki/Unsafety-draft anything missing?
[20:12:01] *** Quits: jeaye_ (jeaye@moz-A4DD04C2.blinkenshell.org) (Quit: WeeChat 0.4.1)
[20:12:37] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[20:12:37] *** ChanServ sets mode: +o tjc
[20:13:34] *** Quits: kij (Mibbit@moz-5E180F75.mobile.3.dk) (Quit: http://www.mibbit.com ajax IRC Client)
[20:14:18] <kimundi> Btw, I'm seeing a lot of pixel-arty avatars on github lately. Whre are they comming from?
[20:14:55] <strcat> kimundi: if you don't have an avatar, it auto-generates one
[20:14:59] <strcat> I think from hashing your name
[20:15:03] <mark_edward> kimundi: i think it's autogeneratubg them
[20:15:05] <kimundi> ah, I see
[20:15:06] <mark_edward> i never made one
[20:15:07] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[20:15:07] *** ChanServ sets mode: +ao dherman dherman
[20:15:09] <kimundi> That's nice
[20:15:25] <mark_edward> what's new in Rust?
[20:15:28] <strcat> if you do have an avatar you can still look at the auto-generated one
[20:15:39] <kimundi> better than the previous "everything had the same octocat one"
[20:15:44] <mark_edward> i've been working a lot and haven't kept up for a few weeks
[20:15:45] *** Quits: jgilbert (jgilbert@E3D90E00.12EE5EA8.C0D9FBB9.IP) (Ping timeout)
[20:15:48] <SingingBoyo> erickt: ping
[20:15:57] <mark_edward> anyone have the link for the latest TWIR?
[20:16:10] <kimundi> mark_edward: I suggest reading "This week in rust" on the mailing list :P
[20:16:15] <kimundi> Ah, okay
[20:16:48] <kimundi> mark_edward: http://cmr.github.io/
[20:16:49] *** Quits: sinma (sinma@moz-6A11C47C.fbx.proxad.net) (Quit: Konversation terminated!)
[20:17:00] <mark_edward> kimundi: much appreciated!
[20:17:26] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[20:18:37] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[20:19:44] * kimundi should really fix his computer clock. Living 2 hours in the future is nice and all, but also a bit confusing.
[20:20:25] <bstrie> Ferio: au contraire, I see 6 lines in there that reinforce the existence of .times() :P
[20:20:28] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[20:21:49] *** Quits: maik (maik@moz-3F2CDB33.dip0.t-ipconnect.de) (Ping timeout)
[20:22:04] <bstrie> strcat: I could have sworn that your github avatar was just the default one, upside-down...
[20:22:24] <strcat> bstrie: it used to be
[20:22:37] <strcat> but those evil github people gave everyone a non-default avatar
[20:22:41] <brson> strcat: I think that deadlocks are not unsafe, and that arc considers deadlocks unsafe is a bug
[20:22:45] <bstrie> strcat: you should have taken the identicon it gave you and flipped it upside-down, out of spite
[20:22:56] <strcat> brson: agreed
[20:23:15] <kimundi> brson, strcat: what about reference counted circles? unsafe memory leak or not?
[20:23:30] <doomlord> (lol, i search for 'dobkeratops icon' on google images  hoping to get a precropped icon to replace my github avatar, and i get the github placeholder)
[20:23:36] <strcat> kimundi: you can turn that into unsafe code
[20:23:41] <strcat> by making @ outlive a task, etc.
[20:23:49] <brson> kimundi: cycle leaks are not unsafe
[20:24:07] <strcat> resource leaks are okay if they don't make task things outlive the task
[20:24:12] <strcat> like how @ safely leaks cycles
[20:24:25] <brson> strcat: even atomic ref count leaks we don't consider unsafe
[20:24:48] <bstrie> it should always be safe to assume that any GC is leaking everything
[20:24:52] <bstrie> infinite memory, and all that
[20:24:54] <kimundi> strcat: how is that unsafe? The thing outlives the task, but nothing could ever access it again, so it just kinda degrades into nothingness.
[20:24:55] <strcat> bstrie: but the gc is task-local
[20:25:05] *** Joins: azakai (alon@moz-BBE3ABD.mv.mozilla.com)
[20:25:15] <strcat> kimundi: the task expects to be able to annihilate every @ at the end
[20:25:44] <strcat> I am pretty sure I could use an Rc without the cycle prevention to break it
[20:26:04] <kimundi> strcat: Sure, but those that leaked don't cause any bad behavior if nothing has any way to reach them anymore
[20:26:15] <strcat> I mean making the annihilator do something really bad
[20:26:23] <strcat> it can still find the @
[20:26:24] *** Quits: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP) (Ping timeout)
[20:26:42] <kimundi> If you mean that they leaked, but the annilator can steal reach them - That I understand
[20:26:51] <strcat> ok so lets say you have
[20:26:55] <strcat> Rc -> @ -> Rc
[20:27:02] <strcat> the annihilator comes along to free the @
[20:27:15] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[20:27:21] <strcat> that's not safe, afaict
[20:27:28] * kimundi still things there should be an additional set of 'StrongRc' and 'WeakRc' to give as answer to people who want to maker circles without garbage collection
[20:28:17] <kimundi> strcat: Sure, but in that situation the @ is still reachable
[20:28:24] <strcat> it's not about it being reachable or not
[20:28:51] <strcat> I think it will do a double-destruction of non-@ types
[20:28:57] <kimundi> It's kinda my point that I don't see how it's a problem if they are no longer reachable by anything...
[20:29:07] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[20:29:13] *** Joins: jgilbert (jgilbert@40BD3B76.2AD327F9.973C8D27.IP)
[20:29:31] * SingingBoyo did some funky things to encode non-string keys in json and now no one believes him.
[20:29:36] *** jdm|f00ding is now known as jdm
[20:29:39] * SingingBoyo may need more comments in his code
[20:29:40] <strcat> SingingBoyo: but you can't decode them
[20:29:58] <strcat> they are valid strings, so the decoder won't know if they're a string key or not
[20:30:57] <SingingBoyo> strcat: I should clarify: the keys in the map being encoded are non-string, the json keys aren't
[20:31:09] <tikue> rusti: struct Foo<T> { bar: T } Foo { bar: 1u } as Foo<int>
[20:31:09] -rusti- <anon>:5:34: 5:61 error: non-scalar cast: `main::Foo<uint>` as `main::Foo<int>`
[20:31:09] -rusti- <anon>:5          struct Foo<T> { bar: T } Foo { bar: 1u } as Foo<int>
[20:31:09] -rusti-                                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[20:31:10] -rusti- error: aborting due to previous error
[20:31:10] -rusti- application terminated with error code 101
[20:31:22] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[20:31:41] <tikue> Foo<T> as Foo<U> could be safe if T can be cast to U, no?
[20:31:50] <SingingBoyo> strcat: it certainly works for encoding a TreeMap<Animal, ~str> in the json tests, though I suppose a test for TreeMap<~str, Animal> might be good to have
[20:31:59] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Quit: Gone to save the world!)
[20:32:04] <strcat> tikue: not in general
[20:32:11] <kimundi> tikue: casting with as ONLY works for intgers, floats and trait objects
[20:32:23] <tikue> could there not be exceptions?
[20:32:33] <strcat> tikue: `as` only exists to work in const exprs
[20:32:46] <tikue> for example Foo<T: Bar> ==> Foo<U: Bar>
[20:32:59] <kimundi> tikue: More likely 'as' will get removed if we find a way to do that in constexpr.
[20:33:07] <tikue> ah 
[20:33:13] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[20:33:46] <strcat> SingingBoyo: so this does still leave Object as being TreeMap<~str, Json> - it's just the encoding/decoding you changed?
[20:34:09] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[20:34:36] <SingingBoyo> strcat: yeah.  all that got changed was the implementation of Encoder/Decoder and Encodable for Json.
[20:34:54] <olsonjeffery> w 2
[20:35:15] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[20:35:55] <strcat> brson: iirc we had to forbid destructors of things with managed data - that's the cycle issue I'm talking about
[20:36:00] <SingingBoyo> strcat: so you can now do, say, let map:TreeMap<Encodable1, Encodable2>  = something; let encoder = json::Encoder(writer); map.encode(encoder);
[20:36:05] <strcat> that Rc/RcMut have to worry about
[20:36:12] <SingingBoyo> strcat: and you'll get valid and decodable json
[20:36:14] <strcat> not ever @
[20:36:28] <strcat> destructors on things with managed data*
[20:36:47] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[20:36:54] *** mihneadb|lunch is now known as mihneadn
[20:36:56] *** mihneadn is now known as mihneadb
[20:37:16] <brson> strcat: i'm not clear on the issues around dtors but I thought the restrictions on dtors around managed data were to prevent resurrecting zombies
[20:37:17] *** Joins: nsf (nsf@moz-EEF3238A.convex.ru)
[20:38:07] <strcat> like if you had Rc<T> pointing to itself - it'd try to destroy itself and do a double-free, afaict
[20:38:41] *** Quits: sully (sully@moz-45967CBE.emarhavil.com) (Quit: leaving)
[20:38:49] *** Joins: sully (sully@moz-388398CC.leptoquark.net)
[20:39:20] <strcat> rusti: use extra::rc::Rc; Rc::from_send(5)
[20:39:21] -rusti- extra::rc::Rc<int>{ptr: (0x7f883c414060 as *mut ())}
[20:39:53] <strcat> hm
[20:41:04] <strcat> because Drop will destroy the inner object, then free the box.... so maybe it will just recurse until OOM
[20:41:28] <Luqman> s/redraw
[20:42:00] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[20:42:39] *** Quits: sully (sully@moz-388398CC.leptoquark.net) (Quit: leaving)
[20:44:55] *** Quits: bheylin_ (brianheyli@moz-8255E94E.adsl.online.nl) (Quit: bheylin_)
[20:44:56] *** Quits: pyrac (pyrac@moz-22054CAF.w83-205.abo.wanadoo.fr) (Quit: pyrac)
[20:47:20] *** Quits: tikue (quassel@moz-FEADCD38.hsd1.pa.comcast.net) (Connection reset by peer)
[20:47:39] *** Joins: sully (sully@moz-388398CC.leptoquark.net)
[20:48:06] <erickt> SingingBoyo: pong
[20:48:17] *** Quits: sully (sully@moz-388398CC.leptoquark.net) (Quit: leaving)
[20:48:41] * kimundi spends the evening entertaining himself with the OS course slides
[20:48:51] *** Joins: sully (sully@moz-388398CC.leptoquark.net)
[20:49:49] *** Joins: dherman (dherman@moz-B31C6965.dsl.pltn13.sbcglobal.net)
[20:49:49] *** ChanServ sets mode: +ao dherman dherman
[20:49:51] <SingingBoyo> erickt: with regards to https://github.com/mozilla/rust/pull/9142, am I understanding your concerns correctly?  Or is there something else I'm missing in there?
[20:50:09] * erickt looks
[20:50:45] *** Joins: bheylin_ (brianheyli@moz-8255E94E.adsl.online.nl)
[20:53:07] * SingingBoyo just realized he has a lab and will check back and read IRC logs once he's there.
[20:54:46] <erickt> SingingBoyo: k
[20:55:14] *** Quits: SingingBoyo (brandon@moz-19828C59.eng.wind.ca) (Ping timeout)
[20:55:54] *** Quits: Ferio (Mibbit@moz-23CDE542.fullrate.dk) (Quit: http://www.mibbit.com ajax IRC Client)
[20:57:25] <strcat> brson: I think what we need is some attribute you can put on a function to warn when it's used unless you silence that category
[20:57:39] <strcat> like '#[warn("leak")] fn foo() {}'
[20:57:54] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[20:57:54] <strcat> and you could just '#[silence("leak")]' in some function/module/crate
[20:58:00] *** Quits: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net) (Input/output error)
[20:58:03] *** jorendorff_away is now known as jorendorff
[20:58:05] <strcat> because we abuse `unsafe` to essentially do that
[20:58:48] <strcat> it's nice to enforce things in an API not strictly related to safety
[20:58:57] <strcat> maybe effects would deal with that
[20:59:39] *** Quits: doomlord (doomlod@moz-DEFFB365.range81-147.btcentralplus.com) (Connection reset by peer)
[21:00:18] <tjc> jld: are you still working on https://github.com/mozilla/rust/pull/9006 ?
[21:00:21] <tjc> just trying to empty the queue a bit
[21:00:26] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[21:00:28] *** Joins: SingingBoyo (Brandon@moz-1BE4C895.ubcsecure.wireless.ubc.ca)
[21:00:32] *** Quits: dherman (dherman@moz-B31C6965.dsl.pltn13.sbcglobal.net) (Quit: dherman)
[21:00:48] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[21:01:15] *** Joins: maik (maik@moz-3F2CDB33.dip0.t-ipconnect.de)
[21:02:22] *** Joins: RMF (RMF@A266342E.BFB8FC8E.8A1C7242.IP)
[21:02:34] <SingingBoyo> erickt: I'm back if you've got any input for me
[21:02:43] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Ping timeout)
[21:06:42] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[21:06:56] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[21:06:56] *** ChanServ sets mode: +ao dherman dherman
[21:08:22] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Ping timeout)
[21:11:58] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[21:11:58] <tjc> brson: r? https://github.com/mozilla/rust/pull/9146
[21:13:27] *** Quits: SiegeLord (sl@moz-1DF56822.twcny.res.rr.com) (Quit: Leaving)
[21:15:03] *** Quits: squiddy (squiddy@moz-AF1F09D5.adsl.alicedsl.de) (Quit: Leaving)
[21:16:01] <mark_edward> are borrowed pointers implicitly copyable?
[21:17:09] *** Quits: azakai (alon@moz-BBE3ABD.mv.mozilla.com) (Quit: Ex-Chat)
[21:17:14] *** Joins: azakai (alon@moz-BBE3ABD.mv.mozilla.com)
[21:17:35] *** Joins: tikue (tkuehn@E5ACE5E7.28336FB0.689607DE.IP)
[21:18:23] <mark_edward> anyone know?
[21:19:07] *** Joins: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP)
[21:19:23] <bblum> mark_edward: you can write a small test program to figure this out
[21:19:26] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[21:19:31] <kmc> rusti: let x = 3; let y: &int = &x; let z = y; fmt!("%? %?", y, z);
[21:19:32] -rusti- ()
[21:19:55] <cmr> kimundi: Hm, did I actually send TWiR to the mailing list this week?
[21:19:58] * cmr doesn't remember
[21:20:07] <flaper87> cmr: no, AFAIK
[21:20:10] <mark_edward> bblum: right! 
[21:20:29] <flaper87> cmr: I remember you pasting it here
[21:20:30] * cmr does that
[21:20:49] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[21:20:49] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/aRCPqw
[21:20:49] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[21:21:05] *** Joins: doomlord (doomlod@moz-DEFFB365.range81-147.btcentralplus.com)
[21:21:55] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[21:22:09] *** Joins: voxpopuli (fanservice@moz-FE161659.wv.cc.cmu.edu)
[21:23:30] *** Quits: bheylin_ (brianheyli@moz-8255E94E.adsl.online.nl) (Quit: bheylin_)
[21:24:33] *** Joins: gareth0 (gareth0@7C428FA9.3FD5F917.1A294DCF.IP)
[21:25:49] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[21:25:49] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/orFFBQ
[21:25:49] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[21:25:50] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[21:25:50] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/RcmfFw
[21:25:50] <ghrust> 13rust/06auto 14b0e13e0 15Florian Hahn: Add HashSet::with_capacity_and_keys() function...
[21:25:50] <ghrust> 13rust/06auto 142bf93e1 15Florian Hahn: Convert rust_crate_map.cpp to Rust...
[21:25:50] <ghrust> 13rust/06auto 1433a5bc2 15bors: auto merge of #9087 : fhahn/rust/rust_crate_map, r=alexcrichton...
[21:25:52] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[21:25:52] <mark_edward> arg, im trying to implement an rbtree in rust and i just can't match all the pointer hijinks and mutability. the algorithm as presented seems to explicitly require several mutable references to the same thing
[21:26:19] *** Quits: valenting (Thunderbir@7658A01E.84D5EFD5.FB866788.IP) (Input/output error)
[21:26:36] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[21:27:45] *** Quits: SingingBoyo (Brandon@moz-1BE4C895.ubcsecure.wireless.ubc.ca) (Quit: Leaving)
[21:28:21] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[21:28:29] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[21:29:02] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[21:29:22] <tikue> under what situations will implicitly copyable things be implicitly copied?
[21:29:27] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[21:29:32] <cmr> tikue: whenever they'd otherwise be moved.
[21:29:36] <tikue> like, `let a = 1; let b = a; let c = a + b;` would that do it?
[21:29:47] <ecr> tikue: yes
[21:29:53] <tikue> rusti: let a = 1; let b = a; a + b
[21:29:53] -rusti- 2
[21:29:57] <tikue> ecr: ok, thank you
[21:30:18] <ecr> rusti: let a = ~1; let b = a; *a + *b
[21:30:21] -rusti- pastebinned 8 lines of output: http://ix.io/80p
[21:31:25] *** Joins: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[21:32:27] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Ping timeout)
[21:32:30] *** Joins: valenting (Thunderbir@7658A01E.84D5EFD5.FB866788.IP)
[21:33:13] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[21:33:44] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[21:34:20] *** Quits: Palmik (palmik@moz-CC484FDD.tmcz.cz) (Quit: Lost terminal)
[21:34:36] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[21:36:21] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[21:36:35] *** Quits: deio (chris@moz-B7BAB130.dynamic.tstt.net.tt) (Quit: Ex-Chat)
[21:42:08] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[21:43:20] <ecr> rusti: let a = ~1; let b = ~2; a + b
[21:43:21] -rusti- <anon>:5:33: 5:38 error: binary operation + cannot be applied to type `~<VI0>`
[21:43:21] -rusti- <anon>:5          let a = ~1; let b = ~2; a + b
[21:43:21] -rusti-                                           ^~~~~
[21:43:21] -rusti- error: aborting due to previous error
[21:43:21] -rusti- application terminated with error code 101
[21:43:46] <ecr> let a = ~1i; let b = ~2i; a + b
[21:44:20] *** Quits: telotortium (rmi1@moz-90BFA359.dhcp.mdsn.wi.charter.com) (Client exited)
[21:44:31] <ecr> aw. I think I broke rusti
[21:45:19] <strcat> rusti: 2
[21:45:19] -rusti- 2
[21:47:14] <brson> does anybody have an opinion about whether `RUST_THREADS=` should be an error or just silently ignored?
[21:47:38] <cmr> I have a weak opinion that it should be an error.
[21:47:40] <strcat> brson: I think it should be an error, can do 'env -u RUST_THREADS= foo'
[21:47:43] <strcat> er
[21:47:47] <strcat> env -u RUST_THREADS foo
[21:47:49] <cmr> Because setting an env var wrongly is hard to debug
[21:47:58] <brson> ok, me too
[21:48:52] <brson> well, there are other options besides 'silently ignored'. could also be ignored with logging
[21:48:59] <brson> but I think error is fine
[21:49:27] *** Quits: JesseH (JesseH@moz-2E766C3E.mc.at.cox.net) (Quit: github.com/jessehorne)
[21:49:38] *** Joins: JesseH (JesseH@moz-2E766C3E.mc.at.cox.net)
[21:50:48] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[21:50:48] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1433a5bc2 to 14cabba6b: 02http://git.io/N3iJvQ
[21:50:48] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[21:50:48] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[21:50:48] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/_pKN6w
[21:50:48] <ghrust> 13rust/06auto 143226a80 15Tim Chevalier: rustpkg: Support sub-package-IDs...
[21:50:48] <ghrust> 13rust/06auto 14761ae00 15bors: auto merge of #9146 : catamorphism/rust/rustpkg-sub-package-ids, r=brson,catamorphism...
[21:50:49] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[21:51:02] <tikue> brson: i kind of liked the idea of a "non-implicitly copyable" kind
[21:51:26] <jld> tjc: Still working on it.  I've been at the Firefox OS work week this week, so I haven't had time to go through and deal with the comments I got.
[21:52:08] <tikue> it's usually nbd when something moves instead of copies; you just get a compile error if it's a problem. but the inverse is problematic
[21:52:13] <tjc> jld: Ok -- in the meantime I went ahead and closed it (trying to keep the queue size down), but feel free to either reopen it or submit a new patch when you get a chance to deal with the comments :-)
[21:52:35] <cmr> Speaking of, my firefox os phone came over the weekend.
[21:52:38] <cmr> I like it a lot.
[21:53:36] <mark_edward> cmr: bust does it run Rust?
[21:53:53] <mark_edward> s/bust/but
[21:54:01] <cmr> mark_edward: dunno
[21:54:03] <Luqman> mark_edward: yes
[21:54:20] <Luqman> well, last i tried a few months ago
[21:54:46] <mark_edward> isn't it supposed to be all HTML5 though?
[21:55:14] <strcat> the applications are
[21:55:49] <Luqman> it has an android-ish base
[21:56:16] <strcat> which is kind of sad, because the only reason it does afaik is to take advantage of binary blob drivers :(
[21:56:29] *** Quits: osa1 (uid13910@moz-5F4AA75A.irccloud.com) (Quit: )
[21:57:11] *** Quits: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[21:58:58] *** Quits: tgummerer (tgummerer@51D3B54.FEF996EA.EA6FEF3D.IP) (Ping timeout)
[21:59:35] <sp3d> welcome to the future of phones, unless something big changes
[21:59:40] <brson> strcat: is our signed overflow using defined llvm behavior?
[21:59:48] <maik> can I convert a ~[] to a []?
[21:59:52] <maik> ah nvm :X
[21:59:54] *** Quits: Larry (larryfox@moz-343B6F0C.nyc.biz.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[21:59:56] <strcat> brson: yes
[22:00:05] <strcat> brson: llvm makes you opt-in to undefined signed/unsigned overflow
[22:00:13] <brson> thanks
[22:00:16] <strcat> you mark the ops as nsw (no-signed-wrap) or nuw (no-unsigned-wrap) for undef
[22:00:17] <strcat> and we don't
[22:00:50] *** Joins: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP)
[22:01:20] <strcat> brson: I'm unsure if we're doing bit shifts correctly though
[22:01:49] <strcat> an over-wide shift is not *undefined behaviour* but the result is *undefined*
[22:02:00] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[22:02:05] <strcat> which may mean it could be anything.... or it may mean LLVM considers it `undef` which would be bad
[22:02:32] <strcat> I don't think they've actually clearly defined what it means, so at least it's not going to cause any bugs yet
[22:03:12] <strcat> if you have
[22:03:50] <strcat> a = undef; if a == 0 { /* fail */ } else { b / a }
[22:04:14] <strcat> it's allowed to load an unspecified value for a == 0 (may be non-zero) and a *different* value for b / a (may be zero -> undefined behaviour)
[22:04:26] <strcat> because undef means "not actually alive
[22:04:38] <strcat> so when you do load it, you get the contents of some arbitrary register.
[22:05:05] <maik> rusti: let s = ~"1\1\1"; for n in s.split_iter('\\'){println(n);}
[22:05:05] -rusti- <anon>:5:17: 5:18 error: unknown string escape: 49
[22:05:05] -rusti- <anon>:5          let s = ~"1\1\1"; for n in s.split_iter('\\'){println(n);}
[22:05:05] -rusti-                           ^
[22:05:06] -rusti- application terminated with error code 101
[22:05:43] <strcat> anyway LLVM could be taught to treat it as an unspecified result instead of `undef` so I wouldn't really consider it a rust issue
[22:05:51] <strcat> it should provide the choice anyway.
[22:08:15] *** Quits: eholk (eholk@moz-BA312F07.crest.iu.edu) (Quit: eholk)
[22:08:23] *** Joins: eholk (eholk@moz-BA312F07.crest.iu.edu)
[22:08:23] <strcat> brson: added int overflow to the not-actually-unsafe part of the unsafe page
[22:08:25] *** Quits: eholk (eholk@moz-BA312F07.crest.iu.edu) (Quit: eholk)
[22:08:48] *** Quits: hoverbear (andrew@EBFA78B5.F19E5E7B.E74D50F2.IP) (Quit: hoverbear)
[22:09:48] <strcat> brson: the only difference between int and uint is actually just whether truncating/extending them treats the highest bit as the sign
[22:10:00] <strcat> (x as int + y as int) as uint
[22:10:02] <strcat> and
[22:10:07] <strcat> (x as uint + y as uint) as int
[22:10:13] <strcat> are identical
[22:10:25] <jld> tjc: Oh, right.  I'd forgotten about the thing where bors polls all open PRs.  Thanks for pinging me about it.
[22:10:33] <tjc> jld: No prob
[22:10:34] <strcat> same LLVM i8 `add` operation for u8/i8
[22:18:11] *** Joins: jstevans (Instantbir@moz-735D8260.washdc.fios.verizon.net)
[22:19:58] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Quit: WeeChat 0.4.1)
[22:21:52] *** Joins: vosen (vosen@moz-266BA656.icpnet.pl)
[22:22:33] <brson> I'm going to delete cargo-central
[22:23:55] <strcat> brson: btw, have you seen https://github.com/mozilla/rust/issues/7476 ?
[22:24:07] <strcat> the doc builder just uploads new files, so we still have all the old ones
[22:24:08] *** Joins: jstevans1 (Instantbir@moz-735D8260.washdc.fios.verizon.net)
[22:24:14] *** Quits: jstevans (Instantbir@moz-735D8260.washdc.fios.verizon.net) (Connection reset by peer)
[22:24:46] * strcat got graydon to delete some before but that wasn't a sustainable solution
[22:25:57] <brson> strcat: I'll try to update the scripts as we do the 0.8 release. remind me
[22:26:21] <tikue> debug! should use format! now
[22:26:36] <cmr> tikue: should as in you want it to, or should as in something just landed?
[22:26:55] <cmr> brson: would it be possible to delete everything and just reupload new docs?
[22:27:01] <tikue> cmr: as in i want it to :}
[22:27:11] <cmr> tikue: Ah, yes, me too!
[22:27:24] <cmr> nmatsakis: Speaking of, I was able to track down my ICE and fix it, but not reproduce it at all.
[22:27:27] <sfackler> there is debug2! which uses format
[22:27:29] <brson> cmr: i think so
[22:27:33] <cmr> nmatsakis: It had to do with a debug!(format!(...)) chain.
[22:28:02] *** flaper87 is now known as flaper87|afk
[22:28:32] *** Quits: Scriptor (historium@moz-E06F46F0.corp.bitshelter.com) (Quit: Scriptor)
[22:28:41] *** Joins: hoverbear (andrew@EBFA78B5.F19E5E7B.E74D50F2.IP)
[22:28:48] <nmatsakis> cmr: oh?
[22:29:12] <cmr> nmatsakis: I unfortunately accidentally did a git reset --hard so I don't have the code the reproduced it :(
[22:29:15] * tikue did not know about debug2!
[22:30:00] <cmr> nmatsakis: by fix, I mean "make my code no longer fail to compile"
[22:30:03] <cmr> not solve the bug
[22:30:25] <sfackler> there needs to be a new snapshot before all of the log macros can switch over to format
[22:31:05] *** Joins: askalski (akuda@2BA4E5A7.CC7751E8.6712E96B.IP)
[22:31:12] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[22:32:34] *** Quits: cstrahan (cstrahan@moz-71FAC30.hsd1.va.comcast.net) (Ping timeout)
[22:33:21] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[22:33:27] <nmatsakis> cmr: :( ok
[22:35:53] <cmr> I accidentally commited a libuv change. I'm rebasing and at a point where I can undo it with git commit --amend, I think, but how do I actually do that?
[22:36:11] <cmr> Can I force the submodule to a given commit (the old one)?
[22:37:00] *** Quits: Peng_ (mnordhoff@moz-D5175E95.mattnordhoff.net) (Quit: Peng timeout)
[22:37:03] <tjc> cmr: I usually do git reset --soft to the last commit before my commits, then git reset HEAD *, then git submodule sync / git submodule update, then re-commit everything
[22:37:08] <tjc> that's if I only made one commit myself
[22:37:09] <sfackler> did you update .gitmodule?
[22:37:24] <strcat> cmr: you can use git checkout
[22:37:30] <cmr> strcat: in the submodule?
[22:37:38] <strcat> git checkout is always the answer
[22:37:41] <strcat> cmr: yes
[22:37:44] <cmr> ok
[22:37:51] <strcat> cmr: you checkout the old gitmodules, and then git submodule sync && git submodule update
[22:37:52] <tjc> that's never worked for me, but try it and see :-)
[22:38:51] <cmr> strcat: that works for me; thanks!
[22:39:11] <strcat> I don't really understand submodules so I just do that dance when anything goes wrong
[22:39:17] <cmr> neither do I
[22:40:15] *** Joins: Peng (mnordhoff@moz-D5175E95.mattnordhoff.net)
[22:40:32] *** Quits: jviereck (Adium@moz-58A87BA7.dip0.t-ipconnect.de) (Quit: Leaving.)
[22:40:52] *** Joins: jstevans (Instantbir@moz-735D8260.washdc.fios.verizon.net)
[22:41:34] *** Quits: jstevans1 (Instantbir@moz-735D8260.washdc.fios.verizon.net) (Ping timeout)
[22:42:35] *** Joins: five (five@C89469A4.60AE38FD.6D9B563.IP)
[22:42:41] *** Quits: donri (donri@moz-9BB61102.tbcn.telia.com) (Client exited)
[22:45:01] *** Quits: five (five@C89469A4.60AE38FD.6D9B563.IP) (Connection reset by peer)
[22:47:43] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[22:48:18] *** Quits: askalski (akuda@2BA4E5A7.CC7751E8.6712E96B.IP) (Quit: Wychodzi)
[22:48:34] *** Joins: askalski (akuda@2BA4E5A7.CC7751E8.6712E96B.IP)
[22:49:01] <cmr> r? https://github.com/mozilla/rust/pull/8540
[22:49:16] *** Quits: askalski (akuda@2BA4E5A7.CC7751E8.6712E96B.IP) (Quit: Wychodzi)
[22:52:18] <jack> jclements: how do you write unhygienic macros now?
[22:53:16] <jclements> jack: currently, there's a mechanism in place for making syntax extensions capturing (a.k.a. non-hygienic, ish). Are you looking at a syntax extension or a macro_rules! ?
[22:53:27] <jack> macro_rules!
[22:53:37] <jclements> jack: can you show me the code?
[22:53:55] <jack> rust-http used capturing. i am debating how to fix it.
[22:54:35] <jack> jclements: https://github.com/chris-morgan/rust-http/blob/master/src/libhttp/codegen/branchify.rs#L90-L95
[22:54:42] *** Quits: Skif (emschwar@moz-CA025D57.ip.mcleodusa.net) (Client exited)
[22:56:57] <jclements> jack: why does this need to be a macro at all? Couldn't each wf! call just be my_write(fmt!(...)) ?
[22:57:12] *** Quits: victorporof (victorporo@FBDAE982.F9BD9D78.9B1E38F4.IP) (Quit: victorporof)
[22:57:44] <jclements> jack: or, if the fn were called wf, it would just be wf(fmt!(...)) .
[22:57:50] *** Joins: SingingBoyo (Brandon@moz-1B139F19.ubcsecure.wireless.ubc.ca)
[22:58:15] <jclements> jack: wait, hang on.. I'm missing something bigger, here.
[22:59:06] *** Joins: busylizzy (lisa@85228838.12D0DC84.211374C4.IP)
[22:59:12] <jclements> jack: is the issue the reference to "writer" ?
[22:59:34] <jack> the reference to identstr
[22:59:58] <jack> afaict, the whoel poitn of this macro is to save typing identstr, etc. so adding it in explicitly sort of undoes that
[22:59:58] <tikue> call the function w, alias format! to f!, then do w(f!( and it's only one character more 
[22:59:58] <jclements> jack: looks like both, actually....
[23:00:23] *** Quits: hoverbear (andrew@EBFA78B5.F19E5E7B.E74D50F2.IP) (Ping timeout)
[23:00:26] <jclements> tikue: jack's right, you'd have to pass in two extra vars, writer and identstr.
[23:00:36] <tikue> jclements: not if w is a closure
[23:00:42] <ecr> is it possible to expose a newtype struct without allowing someone to dereference it? similar to making a Haskell newtype and exporting the type, but not the constructor.
[23:00:46] <jack> tikue: then i'd have to make it in every function
[23:00:46] *** Quits: busylizzy (lisa@85228838.12D0DC84.211374C4.IP) (Ping timeout)
[23:00:51] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[23:00:51] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/_pKN6w
[23:00:51] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[23:00:55] <tikue> jack: good point
[23:01:02] <jack> oh wait. only one function.
[23:01:06] <jack> I'll see if that works.
[23:01:08] <jclements> jack: are there a bunch more places where this macro is used, or is it just here?
[23:01:16] *** Joins: eatkinson (eatkinson@moz-611579A0.airbears2.berkeley.edu)
[23:01:43] <jack> oh wait. it takes var args.
[23:01:56] <tikue> jack: only because of fmt
[23:02:08] <jack> but i can't pass var args to a closure.
[23:02:18] <acrichto> dbaupp: format!/write!/print! defined in terms of format_args! works really well, but I'm not sure of a good way to define println! (the newline is tough to append)...
[23:02:18] <jclements> jack: short story: you could do a bunch of things, including just duplicating the macro. If we had macro-generating-macros, that would be one nice fix. As it is, it's almost certainly easier to stay inside hygiene.
[23:02:21] <jack> jclements: just this file
[23:02:21] <tikue> jack: you can do w(f!( .. ))
[23:02:38] <jclements> jack: what tikue said: do the fmt before calling w.
[23:02:47] <tikue> jclements: can you alias macros
[23:02:48] *** Joins: hoverbear (andrew@EBFA78B5.F19E5E7B.E74D50F2.IP)
[23:03:02] <acrichto> dbaupp: oh wait, nvmd
[23:03:06] <pnkfelix> jclements: we don't have macro-generating macro?
[23:03:21] <pnkfelix> jclements:  â€¦ i could have sworn I made one recently.  but maybe not since you landed your let changes
[23:03:40] <jclements> pnkfelix: there's a bug open. It affects macros that generate macros where the inner one takes args.
[23:03:47] <jclements> pnkfelix: it's been open a long time.
[23:03:53] <jclements> pnkfelix: the issue is...
[23:04:14] <pnkfelix> jclements: hmm.  I better go test that macro some more...
[23:04:36] <jclements> pnkfelix: that the *binding* locations on the inner macro are assumed to be *uses* of pattern variables of the outer one. You would definitely get a compile-time error on this.
[23:04:41] <mark_edward> is there anyway to forcibly end a borrow? i thought `let _ = ref` would do it
[23:05:23] <pnkfelix> jclements: nm, i'm just wrong, I abandoned the attempt to make a macro-generating macro in this case
[23:05:38] <jclements> pnkfelix: it's #6994. If you care :)
[23:05:48] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[23:05:48] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/ont_9w
[23:05:48] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[23:05:51] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[23:05:52] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/KHunVg
[23:05:52] <ghrust> 13rust/06auto 140c89183 15Brian Anderson: rustc: Fix cstack lint for default methods. Closes #8753
[23:05:52] <ghrust> 13rust/06auto 14c0e92b6 15bors: auto merge of #8796 : brson/rust/cstack, r=pnkfelix
[23:05:52] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[23:06:00] *** Quits: gareth0 (gareth0@7C428FA9.3FD5F917.1A294DCF.IP) (Input/output error)
[23:06:59] <jclements> jack: by the way, this code-generating-code looks ... ummm, really sketchy.
[23:07:25] *** Quits: ceninan (ceninan@moz-6BD43586.a370.priv.bahnhof.se) (Ping timeout)
[23:08:47] <jclements> jack: my opinion: your "path of least resistance" here is just to add two args to the macro (for identstr and writer), and then just search & replace.
[23:09:19] <ww> is there any plan to add support for accessing enum's value directly, without going through unwrap() or matching?
[23:09:29] <jclements> jack: lemme know if you want me to edit the code :)
[23:09:37] <cmr> pnkfelix: r? https://github.com/mozilla/rust/pull/8540
[23:09:42] <tjc> ww: not to my knowledge. in that situation, you want to use a struct instead
[23:09:45] *** Quits: eatkinson (eatkinson@moz-611579A0.airbears2.berkeley.edu) (Quit: eatkinson)
[23:09:58] <jack> jclements: i got it. thanks for the help
[23:10:10] <ww> but Option is everywhere
[23:10:13] <tikue> tjc: i thought there were proposals flying around
[23:10:20] <tikue> tjc: for like subsets of enums
[23:10:22] <ww> has to deal it with unwrap() is tiresome
[23:10:23] <jclements> jack: np. See you at Strange Loop maybe.
[23:10:25] <tikue> s/enums/enum variants
[23:10:31] <cmr> ww: you can't access members of an enum without knowing what variant it is.
[23:10:37] <cmr> it's impossible to generalize.
[23:10:40] <tjc> tikue: Yeah, probably not till after 1.0, though
[23:11:05] *** Quits: miza (miza@moz-4DD51325.home.otenet.gr) (Input/output error)
[23:11:07] <pnkfelix> cmr: just to confirm: this is still just to stave off bit-rot; it gets built but is not used otherwise, right?  (I know this is what it says in the PR, but the PR descriptions seem to go stale, especially after a month)
[23:11:12] <tikue> tjc: yeah i didn't think it was anytime soon, but not necessarily off the table
[23:11:15] <cmr> pnkfelix: correct.
[23:11:49] <tjc> tikue: Well, adopting one of the proposals would make it easier to implement dereferencing enum fields directly, but it doesn't require implementing that
[23:11:49] *** jorendorff is now known as jorendorff_away
[23:11:51] <ww> may be bring back the enum.get().  unwrap() sounds not right
[23:12:01] <cmr> pnkfelix: it currently doesn't even run, it segfaults in extra::serialize :|
[23:12:06] <mark_edward> cmr: is there any way to forcibly end a borrow earlier than the pointer going out of scop?
[23:12:10] <cmr> mark_edward: no idea
[23:12:12] <cmr> I don't think so
[23:12:16] <tikue> tjc: ah, ok that makes sense, thank you
[23:12:33] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[23:12:36] <mark_edward> cmr: i thought `let _ = x` destroyed x or something like that
[23:12:44] <tikue> mark_edward: what if x is implicitly copyable
[23:13:10] <cmr> mark_edward: it makes it leave scope, but I'm pretty sure that's a special case in borrowck
[23:13:16] <mark_edward> tikue: i don't know what you mean. and in my case im dealing with &mut?
[23:13:22] <cmr> or for move checking
[23:13:59] <strcat> let _ = x; doesn't actually act differently than let _y = x; atm (except that you can't access it as a var)
[23:14:08] <strcat> doesn't destroy early, doesn't make the borrow end
[23:14:09] <mark_edward> so if x: &mut T, and i go `let _ = x;` there is still a mutable borrow?
[23:14:12] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[23:14:18] <jack> src/libhttp/headers/request.rs:58:11: 58:16 error: failed to find an implementation of trait std::clone::Clone for extra::time::Tm
[23:14:20] <jack> wat?
[23:14:24] <mark_edward> strcat: is there anyway to end the borrow early?
[23:14:35] <strcat> add a scope, I guess
[23:15:05] <ww> rusti: std::str::from_bytes(bytes!("abc"))
[23:15:05] -rusti- <anon>:5:9: 5:29 error: unresolved name `std::str::from_bytes`.
[23:15:06] -rusti- <anon>:5          std::str::from_bytes(bytes!("abc"))
[23:15:06] -rusti-                   ^~~~~~~~~~~~~~~~~~~~
[23:15:06] -rusti- error: aborting due to previous error
[23:15:06] -rusti- application terminated with error code 101
[23:15:14] <ww> rusti: str::from_bytes(bytes!("abc"))
[23:15:18] -rusti- pastebinned 11 lines of output: http://ix.io/80v
[23:15:42] <pnkfelix> ww: FYI rusti takes private messages, so you can perfect an example before showing it to the channel
[23:15:46] <tjc> jack: r? https://github.com/mozilla/rust/pull/9147
[23:15:47] <mark_edward> strcat: context is i match on an option member of a struct with Some(ref mut mem), but in the scope, i need to mutate a different member of the struct, and never have to deal with mem again.
[23:15:55] <ww> thx
[23:16:17] *** jorendorff_away is now known as jorendorff
[23:16:28] <tikue> mark_edward: you can destructure the struct first
[23:16:39] <tikue> to get both references at the same time
[23:16:50] <ww> question: how do i convert bytes back to str?  str::from_bytes() seems missing in 0.8-pre
[23:16:59] *** Quits: RMF (RMF@A266342E.BFB8FC8E.8A1C7242.IP) (Quit: Textual IRC Client: www.textualapp.com)
[23:16:59] <mark_edward> tikue: can you explain what you mean?
[23:17:11] *** Quits: jgilbert (jgilbert@40BD3B76.2AD327F9.973C8D27.IP) (Ping timeout)
[23:17:11] <strcat> ww: from_utf8
[23:17:22] <tikue> mark_edward: can you gist the code in question?
[23:17:27] <mark_edward> sure
[23:17:32] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[23:17:53] <ww> ah, excellent.  thx
[23:18:52] *** Joins: RMF (RMF@moz-7ED3CBC0.dsl.telepac.pt)
[23:21:01] *** Quits: SingingBoyo (Brandon@moz-1B139F19.ubcsecure.wireless.ubc.ca) (Ping timeout)
[23:21:58] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[23:23:03] <mark_edward> tikue: the highlighted section is the problem code. struct and some function def s are included for context https://gist.github.com/MarkJr94/6545136#file-rbtreestuff-rs-L67-L77
[23:23:38] <tikue> mark_edward: ok
[23:24:26] *** Quits: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[23:26:54] <tikue> mark_edward: trying to compile but it's saying rot_left and double_left are unresolved
[23:27:03] <tikue> do you have the source for those
[23:28:25] <mark_edward> tikue: just edited it in
[23:28:59] *** Joins: Thad (chatzilla@moz-C35F90AE.tx.res.rr.com)
[23:30:17] <mark_edward> tikue: new link https://gist.github.com/MarkJr94/6545136#file-rbtreestuff-rs-L111-L121
[23:30:22] <cmr> pnkfelix: the only thing that changed since your previous r+ is the replacement of each_path with direct lookup.
[23:30:51] <pnkfelix> cmr: sure, I just wanted to double check
[23:31:17] <pnkfelix> cmr: oh, sorry, I started skimming over the commit and then I got distracted
[23:32:40] <cmr> And the addition of a segfault.
[23:32:48] <cmr> But I'm 90% certain that's a rustc bug.
[23:35:42] <tikue> mark_edward: ok, are you going to do something on the None => arm?
[23:36:21] <mark_edward> tikue: yeah eventually
[23:36:27] <tikue> kk one sec
[23:37:33] *** Joins: lazyden (lazyden@47A36AC9.35CBBBD0.F246D1AF.IP)
[23:37:46] <pnkfelix> cmr: am I wrong in finding some irony that rustdoc does not have terribly many documentation comments?
[23:37:51] *** Quits: hoverbear (andrew@EBFA78B5.F19E5E7B.E74D50F2.IP) (Ping timeout)
[23:38:43] *** Joins: eatkinson (eatkinson@moz-DC7CD72F.airbears2.berkeley.edu)
[23:39:16] <mark_edward> pnkfelix: you're wrong. the documentation generator is obviously self-documenting
[23:39:18] *** Joins: busylizzy (lisa@85228838.12D0DC84.211374C4.IP)
[23:39:30] <pnkfelix> cmr: I guess that's unfair, there are a fair number in some places
[23:39:32] <tikue> mark_edward: the short answer is I don't know the best way to solve your problem. The long answer is I could get it to compile but it wouldn't be pretty. might want someone else to take a crack at it
[23:39:53] *** Quits: eatkinson (eatkinson@moz-DC7CD72F.airbears2.berkeley.edu) (Quit: eatkinson)
[23:39:59] <mark_edward> tikue: okay, thanks for the help tk
[23:40:09] <cmr> pnkfelix: Would you like me to add some?
[23:40:17] <pnkfelix> cmr: Lets land it first
[23:40:27] *** Joins: hoverbear (andrew@EBFA78B5.F19E5E7B.E74D50F2.IP)
[23:40:38] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: zzzzzzzzzz)
[23:41:00] <pnkfelix> cmr: like I said, there are some.  I just at some point noticed there weren't any in the portion I was looking at
[23:41:00] *** Quits: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[23:41:02] *** Joins: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com)
[23:41:27] <cmr> If you were in clean, it's because clean is really boring and straightforward, except where it isn't.
[23:41:41] <cmr> resolve_type needs more comments.
[23:41:44] *** Quits: busylizzy (lisa@85228838.12D0DC84.211374C4.IP) (Ping timeout)
[23:41:52] <tikue> mark_edward: no problem, sorry :\
[23:44:11] *** jorendorff is now known as jorendorff_away
[23:45:46] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[23:45:46] *** ChanServ sets mode: +o tjc
[23:45:57] *** Joins: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net)
[23:46:37] <cmr> strcat: "binary operation + cannot be applied to type `**i8`" offset method should be used instead?
[23:47:14] <strcat> I don't really think so
[23:47:22] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[23:48:15] *** Quits: nkoep (nik@moz-790570D8.pool.mediaways.net) (Client exited)
[23:48:18] <strcat> it's more complicated than that
[23:48:27] <strcat> you really have to know what you're doing if you use raw ptrs
[23:48:30] <cmr> The context is sax-rs, doing from_c_str on a **xmlChar returned by the library.
[23:48:57] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[23:48:57] *** ChanServ sets mode: +ao brson brson
[23:49:34] <strcat> acrichto: I think I found the issue
[23:49:38] <strcat> or at least, an issue
[23:49:57] <strcat> enum constructors aren't tagged as sret
[23:50:12] <strcat> I doubt it's the cause of the issue
[23:50:37] <Thad> Hey guys!  Trying out the build with gcc 4.8.1 and mingw-get upgrade ... looks like there is fallout for libuv and mswsock.h .. http://pastebin.mozilla.org/3038909
[23:50:38] <cmr> strcat: What are the subtlties surrounding raw pointers?
[23:50:50] <strcat> cmr: you need to understand the LLVM aliasing rules, etc.
[23:51:24] <strcat> they are a subset of the C aliasing and pointer arithmetic rules but unlike C you actually have to make sure it's right for all inputs
[23:51:58] <cmr> Is this all explained in http://llvm.org/docs/GetElementPtr.html ?
[23:52:25] *** Joins: ceninan (ceninan@moz-6BD43586.a370.priv.bahnhof.se)
[23:52:48] <strcat> cmr: no that just explains pointer arithmetic
[23:52:59] <strcat> cmr: http://llvm.org/docs/LangRef.html#pointeraliasing is relevant too
[23:53:11] *** Quits: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com) (Quit: ecr)
[23:54:39] *** Quits: kelvin (kelvin@4C416360.3C990DFD.DDE5D3F6.IP) (Ping timeout)
[23:54:46] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[23:55:10] <cmr> Hm, I'm pretty sure using offset obeys these rules here.
[23:55:28] <cmr> I'm given an array of (*xmlChar, *xmlChar), essentially.
[23:55:36] <cmr> As soon as it finds a NULL in the array, it stops.
[23:55:49] <cmr> So the pointer should always be in a range not managed by llvm.
[23:55:56] <cmr> (the last rule in the first list)
[23:56:07] <tikue> mark_edward: i think what you're trying to do is straight-up hard in rust with owned pointers. you could use @mut to make those things trivial, but that's not much of a solution
[23:59:32] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)

[00:00:03] <sfackler> pcwalton: should things like Cell::with_ref be converted as well? It'll take an extra call to get the actual reference which seems like a bit of a bummer
[00:00:24] <pcwalton> sfackler: yes. I think we can address that with the "overloadable deref" proposal
[00:00:32] <pcwalton> and in any case I think an extra call is preferable to rightward drift
[00:00:43] <pcwalton> extra calls scale to any number of outstanding references, rightward drift doesn't
[00:00:50] <pcwalton> rightward drift doesn't scale past the end of your buffer :)
[00:00:55] <engla> sfackler: we discussed that yesterday actually
[00:00:58] <sfackler> works for me :)
[00:01:08] *** Joins: Larry (larryfox@moz-B8648F0F.nycmny.fios.verizon.net)
[00:02:31] *** Joins: samx (sami@moz-D9DA5773.dyn.optonline.net)
[00:03:58] *** Quits: mark_edward (AndChat414@moz-97E995A.hsd1.in.comcast.net) (Ping timeout)
[00:04:09] *** Joins: mark_edward (AndChat414@moz-97E995A.hsd1.in.comcast.net)
[00:04:38] *** Quits: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[00:04:53] <sfackler> is fn borrow<'a>(&'a self) -> BorrowedCell<'a, T> a reasonable method and struct name?
[00:05:27] <engla> sfackler: we talked about a prototype Mut<T> yesterday that could replace both Cell and the inner of RcMut<T>
[00:06:11] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[00:06:11] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/j7rZ-g
[00:06:11] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[00:06:19] <engla> well.. not sure what's going to happen with that. but it was this: https://gist.github.com/anonymous/f007d9b907509c03c17f
[00:07:00] *** Quits: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com) (Client exited)
[00:07:24] *** Joins: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com)
[00:07:29] <doomlord__> trait Copy non-existant .. just remove it from legacy source ? is there sometign that replaces it (Clone vs Copy?)
[00:07:39] <cmr> doomlord__: Copy has been fully removed.
[00:08:59] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[00:09:00] <brson> restarting buildbot to limit which slaves are allowed to run dist snaps. our aws bots are using valgrind 3.7 and we need 3.8 now
[00:09:04] *** Quits: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com) (Ping timeout)
[00:09:05] *** Quits: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP) (Quit: buildmaster reconfigured: bot disconnecting)
[00:09:52] <brson> i killed buildbot :-(
[00:10:10] <acrichto> bors, noooooooo!
[00:10:29] *** Joins: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP)
[00:11:05] <doomlord__> is there a decent way to get a *c_char from :&str  ... my legacy code used  "as_c_str(rustStr,|x| x)"
[00:11:06] <brson> ok, it's back. crossing my fingers are the slaves come back online
[00:11:11] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[00:11:11] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/KO8EPg
[00:11:11] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[00:11:12] <brson> restarting buildbot is terrifying
[00:11:13] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[00:11:13] <ghrust> 01[13rust01] 15bors pushed 19 new commits to 06auto: 02http://git.io/O7z5uA
[00:11:13] <ghrust> 13rust/06auto 14f364683 15Patrick Walton: librustc: Change fold to use traits instead of `@fn`.
[00:11:13] <ghrust> 13rust/06auto 14788fb39 15Patrick Walton: librustc: Remove garbage collected functions from front/{config,test} and metadata/{tydecode,tyencode}
[00:11:13] <ghrust> 13rust/06auto 14574c3e9 15Patrick Walton: librutsc: Port the pretty printer annotation infrastructure to use traits instead of garbage collected functions.
[00:11:15] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[00:11:23] <cmr> rusti: let x = "foo"; x.to_c_str()
[00:11:24] -rusti- std::c_str::CString{buf: (0x7fa90ec23058 as *()), owns_buffer_: true}
[00:11:32] <cmr> doomlord__: that buf is what you want.
[00:11:38] <doomlord__> ok great
[00:11:51] <cmr> The std::c_str module *should* do everything you want.
[00:12:34] <amatus> looks like main and _ZN4main18h24c3e6e66f15a74af4v0.0E are compiled using the correct instruction set, but other functions are not (_start, _init, etc)
[00:12:55] *** Joins: heftig (heftig@moz-F0FBD069.dip0.t-ipconnect.de)
[00:12:57] <cmr> amatus: _start and _init come from crt0 don't they?
[00:13:59] <amatus> so it might be the step where we use gcc to link that's introducing the wrong code
[00:14:34] <Luqman> amatus: you can try passing various flags directly to gcc and seeing if that helps with --link-args
[00:14:56] <amatus> wonderful
[00:15:42] <cmr> amatus: thanks for looking at this :)
[00:15:49] <pnkfelix> amatus: another thought I had: You could use â€”save-temps to keep the intermediate LLVM bitcode file, and then run llc directly on that.  (not sure if someone else already suggested that)
[00:16:01] *** Quits: Jesin (Jessin_@moz-C8BB4444.cc.lehigh.edu) (Ping timeout)
[00:16:16] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.1)
[00:16:19] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[00:17:11] <amatus> i've been really excited to try rust, and i've finally found a suitable project, a small one where i would normally use C, it happens that my target is the rpi
[00:17:41] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[00:17:54] <amatus> i almost gave up when the tutorial said that only x86 was supported, but decided to ask in the channel first :)
[00:18:28] <strcat> should update that
[00:19:15] <strcat> oh, well that's just about snapshots
[00:19:18] <kmc> I asked about Rust on rpi and Luqman told me they built a cross compiler with ./configure --target-triples=arm-unknown-linux-gnueabihf && make` then `rustc --target arm-unknown-linux-gnueabihf --linker arm-unkn
[00:19:22] <kmc> own-linux-gnueabihf-gcc
[00:19:31] <kmc> sorry for mangling that a bit
[00:19:40] <kmc> I failed to build rustc on the RPi itself, presumably due to lack of a snapshot
[00:19:50] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[00:19:50] <kmc> (snapshot is a binary of the compiler, needed to bootstrap because rustc is written in Rust)
[00:19:54] <amatus> that's pretty much what i did, the arm toolchain i'm using is from emdebian
[00:20:03] <cmr> There's a SPARC box here, I might attempt to get rust going on that.
[00:20:04] <kmc> . o O ( clearly it should grab the x86 snapshot and run it in QEmu )
[00:20:12] <tiffany> what was the function I can break on in gdb to see the backtrace before it unwinds the stack?
[00:20:15] <Luqman> i haven't actually run anything on the rpi but i have on different arm devuces
[00:20:19] <kmc> cmr: I thought we already agreed in the meeting that the next Rust platform will be Mac OS 9!
[00:20:21] <Luqman> tiffany: rust_begin_unwind
[00:20:33] <kmc> ;)
[00:20:51] <Eridius> kmc: OSType ftw
[00:21:13] <pnkfelix> tiffany: Also, in gdb, can do: catch throw 
[00:21:13] <amatus> Luqman: well it looks like the binary that's produced is not quite right for rpi
[00:21:24] <tiffany> hm
[00:21:46] <tiffany> slice_to seems to explode when it encounters unicode
[00:21:50] <Luqman> strcat: i'm a bit too happy that the redundant rust_main is gone :P
[00:21:52] *** Quits: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP) (Ping timeout)
[00:22:00] <Eridius> tiffany: only if you're slicing a char in half
[00:22:02] <Luqman> amatus: :(
[00:22:20] *** Joins: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP)
[00:22:21] <strcat> Luqman: I'll be happy when we mark everything but the entry point in an executable as internal
[00:22:24] <strcat> so it optimizes properly
[00:22:33] *** Quits: jdm (jdm@13F2CEC5.7672369.D8E68FF6.IP) (Quit: Lost terminal)
[00:22:42] <cmr> We can't do that on windows.
[00:22:49] <tiffany> is there a way to get rust to emit debug information?
[00:22:50] <cmr> You can link to exported symbols of an exe.
[00:22:52] <engla> tiffany: all &str methods with one exception, take byte indices and assert if a slice would cut inside a multibyte encoded character
[00:22:55] <Luqman> and crate_map will soon be hidden away
[00:22:55] <cmr> tiffany: -Z debug-info
[00:23:03] <amatus> indeed, the .o file that's produced is all good, the problem is in linking the final binary
[00:23:08] <amatus> ... maybe i should just link on the target!
[00:23:25] <Luqman> amatus: you can try what pnkfelix said and use llc.
[00:23:43] <amatus> link the .o using llc?
[00:24:04] <pnkfelix> amatus: Link from the .bc using llc
[00:24:06] <strcat> Luqman: you can compile .ll files with clang too
[00:24:09] <strcat> (or .bc)
[00:24:11] <strcat> using llc is a pain ;p
[00:24:14] <sfackler> engla: is there an issue to talk about Mut?
[00:24:20] <tiffany> emitting debug info doesn't seem to work very well
[00:24:25] <engla> sfackler: don't think so
[00:24:31] <tiffany> it doesn't show me the parameters to functions or many of the line numbers
[00:24:34] <pnkfelix> amatus: but really, if you have a .o file, I agree, go ahead and try to link it on the target
[00:24:37] <engla> strcat: are you working on Mut<T>?
[00:24:44] <engla> Mutable<T> maybe
[00:27:56] <tiffany> is there a better way to express text.slice_chars(0, n).len()?
[00:28:34] <Eridius> tiffany: depends on what you're trying to do. That expression counts the number of bytes used by the first n chars
[00:28:45] <slack1256> Anybody know haskell here?, are .rc files (crate files) analogous to .cabal files on haskell?
[00:28:49] <tiffany> that's what I'm trying to do
[00:28:52] <Eridius> slack1256: .rc is dead
[00:29:04] <slack1256> but the documentation...
[00:29:13] <engla> tiffany: that, or using char_offset_iter are the best ways I think
[00:29:14] <cmr> slack1256: no, it's nothing like it.
[00:29:14] <slack1256> then what are we using now?
[00:29:17] <cmr> .rs
[00:29:31] <tiffany> I still name my main file .rc for libraries, is that bad?
[00:29:36] <cmr> tiffany: it's discouraged.
[00:29:37] <slack1256> oh, the extension is dead, not crate files
[00:29:46] <cmr> Crate files as a concept don't exist either, not anymore.
[00:29:55] <cmr> "Crate files" are normal rust files, they're just the crate root.
[00:29:58] * slack1256 scratch head furiously
[00:30:30] *** Joins: Jesin (Jessin_@moz-CDB412A.cc.lehigh.edu)
[00:30:54] <slack1256> then what exposes the meta-information of the project? (version, dependencies, etc)
[00:31:10] <tiffany> slack: #[] derectives in the root file
[00:31:11] <cmr> Normal attributes
[00:31:25] <cmr> Dependencies are automatically detected by rustpkg
[00:31:31] <cmr> It looks at the `extern mod foo;`
[00:31:35] <amatus> arg, now the bad code is in lib/librustrt.so
[00:31:57] <slack1256> oh, right
[00:32:02] <amatus> i'm going to monkey with platform.mk and rebuild
[00:32:04] <slack1256> that settles it then.
[00:32:49] <aatch> Argh, stupid C++ static initialisation not playing nice with linkers.
[00:32:58] *** Quits: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP) (Quit: buildmaster reconfigured: bot disconnecting)
[00:33:07] *** Joins: msingle (Thunderbir@moz-20675462.nrflva.fios.verizon.net)
[00:33:56] *** Joins: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP)
[00:34:11] <jeaye> aatch: mm?
[00:34:18] <amatus> >.< i was hitting the bad code in lib/librustrt.so all along, i just wasn't reading gdb output closely enough
[00:34:23] * jeaye hear C++ and awoke
[00:34:29] <jeaye> heard
[00:34:40] * amatus runs some errands
[00:34:44] <dcrewi> how does one get a @[T] from a &[T]?
[00:34:53] <jeaye> to_managed?
[00:35:21] <jeaye> rusti: let x = &[1]; x.to_managed()
[00:35:22] -rusti- <anon>:7:23: 8:5 error: type `&[<VI0>]` does not implement any method in scope named `to_managed`
[00:35:22] -rusti- <anon>:7          let x = &[1]; x.to_managed()
[00:35:22] -rusti- <anon>:8     };
[00:35:22] -rusti- error: aborting due to previous error
[00:35:22] -rusti- application terminated with error code 101
[00:35:26] <jeaye> Nope
[00:35:29] <aatch> jeaye, hiphop code. Registering functions from a method in a static class. But nothing makes the linker pull in the object file.
[00:35:45] <aatch> So I don't get any errors during compilation, it just doesn't work...
[00:35:59] *** Quits: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP) (Quit: buildmaster reconfigured: bot disconnecting)
[00:36:10] <jeaye> Is the code online?
[00:36:24] <dcrewi> looks like the answer is std::at_vec::to_managed(x)
[00:36:35] <aatch> jeaye, I don't think so. I've fixed it though. Just venting while I wait for it to compile.
[00:36:48] <jeaye> aatch: mmk
[00:36:54] <cmr> dcrewi: why are you using @[T]?
[00:37:12] <jeaye> [Enter @ police]
[00:37:14] <dcrewi> cmr: to write a test
[00:37:24] <cmr> That's a valid reason
[00:37:38] <jeaye> Yeah, more valid that I was expecting. :|
[00:37:38] <myname> lol
[00:37:41] <tikue_> lol
[00:37:57] <engla> (is the police going to exit so that I can exhale?)
[00:38:01] *** Joins: lazyden (lazyden@47A36AC9.35CBBBD0.F246D1AF.IP)
[00:38:13] <aatch> Theres a linker option -whole-archive that makes it pull in all the object files from a static archive instead of just the ones to resolve symbols
[00:38:17] <jeaye> [@ Police exit]
[00:38:23] <engla> whew
[00:38:27] <jeaye> engla: Sorry
[00:38:41] *** Quits: lazyden (lazyden@47A36AC9.35CBBBD0.F246D1AF.IP) (Quit: lazyden)
[00:39:07] <aatch> Also, @str and @[] aren't so bad compared to using @T
[00:39:17] *** Joins: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP)
[00:39:19] <cmr> aatch: no?
[00:39:22] <tikue_> aatch: wouldn't you just use &'static str?
[00:39:24] <cmr> What are some usecases for @[] ?
[00:39:31] *** Quits: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP) (Quit: buildmaster reconfigured: bot disconnecting)
[00:39:37] <cmr> tikue_: not if you're constructing it at runtime.
[00:39:45] <tikue_> cmr: good point
[00:39:53] <aatch> Actually, even @T isn't so bad. It's pretty much just @mut T that's evil.
[00:39:54] <tikue_> so then the same goes for @[]
[00:40:04] <cmr> I think @T is fine, I just don't really see a usecase for @[]
[00:40:08] <mcpherrin> When do you want @[] over @~[]?
[00:40:08] *** Quits: jgilbert (jgilbert@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[00:40:11] *** Joins: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP)
[00:40:17] <mcpherrin> I don't know.
[00:40:23] <aatch> mcpherrin, when you want to reduce redundancy?
[00:40:33] <tikue_> aatch: how do you write a transfer<R: Reader, W: Writer>(reader: R, writer: W) {} function without @mut
[00:40:37] <tikue_> if you want to be able to echo
[00:40:39] <jeaye> Being the one that (at least feels like he) uses @ and @mut the most, I have never really needed @[].
[00:40:47] *** Quits: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP) (Input/output error)
[00:40:59] <jeaye> Just @T and @mut T
[00:41:03] *** Joins: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP)
[00:41:11] <cmr> @mut T is also fine, it's just annoying if you use it wrongly.
[00:41:12] *** Joins: Sorella (queen@9D963F5D.DF5D8AE7.54BCAB54.IP)
[00:41:17] <jeaye> Aye
[00:41:24] <aatch> tikue_, I'm not saying they're useless, just it's the one that causes the most problems.
[00:41:24] <jeaye> Very annoying.
[00:41:38] <tikue_> aatch: i know, i'm actually curious if you know a way :3
[00:41:41] <jeaye> cmr: Seen squiddy around at all?
[00:41:43] <tiffany> uhh..
[00:41:49] <tiffany> I'm having issues switching to rustpkg
[00:42:16] <tiffany> http://paste.strictfp.com/39252
[00:42:35] <aatch> tikue_, why couldn't you use &mut?
[00:42:55] <tikue_> aatch: can't borrow twice mutably
[00:43:11] <aatch> tikue_, so the reader and the writer are the same object?
[00:43:17] <tikue_> aatch: you don't want to disallow it
[00:43:19] *** Quits: Sorella (queen@9D963F5D.DF5D8AE7.54BCAB54.IP) (Quit: G'night everynyan~!)
[00:43:22] <tikue_> or else you can't echo
[00:43:45] <tikue_> which is a pretty canonical case. "let's write an echo server!"
[00:44:12] *** Quits: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP) (Quit: buildmaster reconfigured: bot disconnecting)
[00:44:18] <engla> it sounds like the wrong step is to implement reader and writer on the same object then tikue_ 
[00:44:27] <aatch> tikue_, well then you don't really have a choice in the matter if they're the same object. Though I would probably prefer duplicating the object
[00:44:38] <tikue_> aatch: can you duplicate a TcpStream?
[00:44:44] <aatch> tikue_, no idea.
[00:44:49] <tikue_> engla: do you know ^ ?
[00:44:54] *** Joins: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP)
[00:45:24] <doomlord__> #[fixed_stack_segment] ... this makes functions without growable stack ... more like C ABI ? i've just encountered this while updating some legacy code for the latest compiler.
[00:46:07] <engla> tikue_: no
[00:46:11] <engla> tikue_: (I don't)
[00:46:34] <sfackler> doomlord__: yeah, it tells the compiler that that function needs a large chunk of stack
[00:47:17] <doomlord__> ah- so its more  like pre-allocating a load, knowing that its calling C functions
[00:47:20] <Eridius> huh, does vec have no equivalent to str's .find() (i.e. a method that takes a function that's called for each element)?
[00:47:33] <engla> Eridius: it's on iterators
[00:47:44] <doomlord__> (perhaps, i should read up ..)
[00:47:50] *** Quits: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP) (Quit: buildmaster reconfigured: bot disconnecting)
[00:47:57] <sfackler> the ffi tutorial talks about fixed_stack_segment now
[00:48:06] *** Joins: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP)
[00:48:06] <brson> trying to fix a problem on buildbot
[00:48:07] <Eridius> engla: oh I suppose I could combine .iter().any()
[00:48:34] <engla> Eridius: find is  iter().find()  and then there is .iter().{position, rposition}()
[00:49:08] <Eridius> engla: fair enough. I only need .any() behavior anyway
[00:49:31] <tikue_> any() is great
[00:50:11] <tiffany> tikue_: brson suggested splitting TcpStream into reader/writer to get around the problem of using it in different places
[00:50:36] <tikue_> tiffany: oh yes, I remember hearing that proposal. Seems like a reasonable approach
[00:50:53] *** Quits: KindOne (KindOne@moz-AA6338CF.dynamic.ip.windstream.net) (Ping timeout)
[00:50:58] <tiffany> I'd be happy with any solution really
[00:51:07] <tiffany> I just want async read/write
[00:52:01] <tikue_> tiffany: a workaround would be to have a stream task that receives read and write messages and acts appropriately
[00:55:18] *** Joins: KindOne (KindOne@61F68286.206EFA7F.34F73994.IP)
[00:56:27] <tiffany> can anyone help me with rustpkg?
[00:56:41] <tiffany> I can't get it to work
[00:58:31] <cmr> tiffany: what's the error you're getting and how is your workspace setup?
[00:58:54] <tiffany> I have src/{frscript,frsi} and frscript builds fine but I get this when I try to build frsi: http://paste.strictfp.com/39252
[00:59:29] <tiffany> I have a lib/ and bin/ directory and I tried rustpkg build frscript but it didn't seem to do anything
[00:59:36] <tiffany> rustpkg install*
[00:59:57] *** Quits: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net) (Input/output error)
[01:00:17] <cmr> Dunno :S
[01:00:26] <cmr> Might send an email to the list and CC tjc
[01:01:52] *** Joins: hoverbear (andrew@moz-86FCBF4B.gv.shawcable.net)
[01:02:09] *** Quits: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net) (Client exited)
[01:02:30] *** Joins: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net)
[01:03:15] *** Joins: DAddYE_ (DAddYE@moz-61EB081B.hfc.comcastbusiness.net)
[01:03:15] *** Quits: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net) (Connection reset by peer)
[01:04:23] *** Quits: riley (riley@8BA43816.9AA11D69.65DDFA89.IP) (Client exited)
[01:06:33] <acrichto> sfackler: you said you were interesting in removing rightward-drift with blocks?
[01:07:06] <acrichto> sfackler: local_data seriously needs that...
[01:07:25] *** Quits: DAddYE_ (DAddYE@moz-61EB081B.hfc.comcastbusiness.net) (Ping timeout)
[01:07:47] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[01:07:50] *** Quits: Aetherspawn_BNC (uid6924@moz-31ABA2C0.irccloud.com) (Ping timeout)
[01:09:00] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[01:09:49] *** Quits: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP) (Quit: buildmaster reconfigured: bot disconnecting)
[01:10:41] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Ping timeout)
[01:12:45] <strcat> engla: no, not working on it
[01:15:21] *** Quits: samx (sami@moz-D9DA5773.dyn.optonline.net) (Quit: This computer has gone to sleep)
[01:16:20] <engla> strcat: ok! but it seems to be the way forward, to replace Cell with Mut<Option<T>> or similar, and then add deref sugar later?
[01:16:36] *** Quits: ozten (ozten@moz-DD3B00B4.hsd1.wa.comcast.net) (Connection reset by peer)
[01:16:37] <engla> we need an issue for this
[01:17:33] *** Quits: mark_edward (AndChat414@moz-97E995A.hsd1.in.comcast.net) (Ping timeout)
[01:17:46] <slack1256> I am kind of confused, at some point the keyword "for" changed for "do" and now is intended for higher order functions and closures right?
[01:18:11] <cmr> slack1256: no
[01:18:18] <engla> slack1256: no, the do keyword was there the whole time. `for` changed meaning, but the old meaning could be simulated with do
[01:18:30] <cmr> `for` was previously `do` with an implicitly assumed type
[01:18:35] *** Joins: mark_edward (AndChat414@moz-97E995A.hsd1.in.comcast.net)
[01:18:48] <cmr> `for` is now syntactic sugar for a loop with a match.
[01:18:54] <cmr> Look at rustc --pretty=expanded
[01:19:27] *** Joins: sruggier (sruggier@7319AA3D.D4245AC4.971E19F6.IP)
[01:19:35] <Luqman> r? https://github.com/mozilla/rust/pull/9301
[01:19:39] * slack1256 checking `rustc --pretty` out
[01:20:52] <aatch> We should probably add something so rustc --pretty actually prints out for loops.
[01:21:33] <aatch> Possibly some sort of desugared AST node that has the "real" ast and the desugared form.
[01:21:49] *** Joins: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP)
[01:22:00] *** Quits: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP) (Quit: buildmaster reconfigured: bot disconnecting)
[01:22:18] *** Quits: KindOne (KindOne@61F68286.206EFA7F.34F73994.IP) (Connection reset by peer)
[01:22:19] <Luqman> aatch: that might become moot if for is implemented in librustc
[01:22:48] <aatch> Luqman, well yeah, but then it's not desugaring anymore.
[01:23:42] <brson> i think the buildmaster's database got a little corrupted
[01:24:55] *** Joins: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP)
[01:25:14] <Eridius> `for` should be implemented in librustc anyway so it stops borrowing the iterator
[01:26:29] <sruggier> I just tried to use the RAII pattern on a struct to enforce a constraint on users of the struct, only to find that destructors cannot use mutable self references
[01:26:53] <Luqman> sruggier: they were just recently changed to take &mut self
[01:26:59] <sruggier> oh, really?
[01:27:02] <cmr> yes
[01:27:06] *** Quits: tefter (tefter@B5D119DC.B856A0A1.73804765.IP) (Ping timeout)
[01:27:10] <sruggier> I was about to ask if I was supposed to use a closure instead
[01:27:18] *** Joins: tefter (tefter@B5D119DC.B856A0A1.73804765.IP)
[01:27:41] <engla> sfackler: registered the issue https://github.com/mozilla/rust/issues/9351
[01:28:27] *** Joins: KindOne (KindOne@61F68286.206EFA7F.34F73994.IP)
[01:28:49] <brson> strcat: dl.rust-lang.org should redirect to static.rust-lang.org now
[01:28:56] *** Joins: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net)
[01:29:12] <sruggier> still, I guess it would be both more efficient and more rustic to just use a closure?
[01:29:23] <cmr> sruggier: no, idiomatic rust uses raii
[01:29:25] <strcat> brson: yep :)
[01:29:29] <strcat> thanks
[01:29:59] <cmr> sruggier: either update your rustc or transmute to a &mut self (I think that's what code did before they took &mut self)
[01:30:00] <strcat> sruggier: Drop uses '&mut self' now but the long-term plan is to make it use 'self' by-value
[01:30:14] *** Joins: voxpopuli (fanservice@moz-FE161659.wv.cc.cmu.edu)
[01:30:20] <cmr> strcat: it'd be nice if we could actually call .drop() too
[01:30:24] <sruggier> that wouldn't help me unless by value includes borrowed pointers
[01:30:36] *** Joins: Yeri (jasonjasmi@41C91A8A.CE609BA5.E39FBF79.IP)
[01:30:47] <strcat> sruggier: by-value is strictly more useful than &mut self inside the fn call
[01:30:56] <strcat> you can take an &mut reference to a value you own
[01:31:03] <strcat> (since you can put it in a mutable slot)
[01:31:31] <sruggier> using Mutable<T>?
[01:31:48] <cmr> no. `let mut x = foo;`
[01:32:31] <sruggier> including if foo is a borrowed pointer?
[01:32:44] <strcat> an & pointer?
[01:32:48] <sruggier> yeah
[01:32:59] <strcat> you can't ever modify through &
[01:33:17] <strcat> & stored somewhere mutable just means you can make it point at something else
[01:33:29] <sruggier> ok,but then I meant &mut
[01:33:42] <sruggier> which is why I needed mutable self
[01:33:55] <strcat> sruggier: https://github.com/mozilla/rust/blob/master/src/libstd/ops.rs#L15 that's how it's defined now
[01:34:02] <strcat> self by-value would be more powerful
[01:34:05] <kmc> it may be true that idiomatic rust uses RAII in some theoretical sense, but I don't think the current stdlib has many RAII APIs, and it has a lot of do with_foo |x| { ... } APIs
[01:34:34] <strcat> kmc: Drop only recently became usable in safe code
[01:34:47] <strcat> and it still really needs by-value to make it less painful
[01:35:09] <strcat> (it's not actually defined by the language yet - sadly)
[01:35:15] <strcat> we don't typeck lang items
[01:35:23] <engla> and the issue with generic drop
[01:35:31] <engla> any way we can solve that?
[01:35:46] <sruggier> my question is how would self by value be able to reach out and mutate other objects by reference, the way that &mut self can?
[01:36:02] <strcat> sruggier: because self by-value is strictly more powerful than &mut self
[01:36:06] <strcat> if you have T, you can take &mut T
[01:36:28] <strcat> you own it, you determine if it's mutable
[01:37:04] <strcat> we don't currently allow the sugar of putting 'mut' on the self parameter but you can do 'let mut mut_self = self'
[01:37:47] <strcat> (on other parameters, 'mut' can be put on them to save a line of code)
[01:39:05] *** Quits: eatkinson (eatkinson@moz-E57448EF.airbears2.berkeley.edu) (Quit: eatkinson)
[01:39:10] <kmc> but if I have  struct Foo { bar: Bar }, then I can modify part of a Foo by taking an &mut Bar, but never by taking a Bar by move
[01:39:24] <sruggier> can T be a borrowed mutable pointer to something else, though? I don't want to mutate the pointer in my destructor, I want to mutate the something else, whose lifetime extends past the death of my droppable object
[01:39:42] <kmc> however maybe this doesn't matter for dtors, because the Foo won't be usable after the bar field is dropped
[01:40:26] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[01:41:13] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[01:41:13] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1447fd6cd to 14570431f: 02http://git.io/N3iJvQ
[01:41:13] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[01:41:15] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[01:41:15] <ghrust> 01[13rust01] 15bors pushed 19 new commits to 06auto: 02http://git.io/BTIokQ
[01:41:15] <ghrust> 13rust/06auto 14f364683 15Patrick Walton: librustc: Change fold to use traits instead of `@fn`.
[01:41:15] <ghrust> 13rust/06auto 14788fb39 15Patrick Walton: librustc: Remove garbage collected functions from front/{config,test} and metadata/{tydecode,tyencode}
[01:41:15] <ghrust> 13rust/06auto 14574c3e9 15Patrick Walton: librutsc: Port the pretty printer annotation infrastructure to use traits instead of garbage collected functions.
[01:41:17] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[01:41:37] <cmr> <quote expansion>:3:47: 3:70 error: failed to find an implementation of trait extra::serialize::Encodable<__E> for extra::glob::GlobIterator
[01:41:38] <cmr> <quote expansion>:3     _e.emit_struct_field("to_move", 1u, |_e| { __self_0_1.encode(_e) });
[01:41:40] <cmr> That's a new sort of error.
[01:41:47] <cmr> benh: is that your doing?
[01:42:12] *** Joins: Shaladdle (anonymous@400E34DE.F3E8A984.689607DE.IP)
[01:42:13] <strcat> sruggier: a destructor can only mutate something in the object, since that's what it's passed
[01:42:23] *** Quits: Larry (larryfox@moz-B8648F0F.nycmny.fios.verizon.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[01:42:32] <strcat> if the object has an &mut T, it can mutate through it
[01:46:20] <sruggier> strcat: it seems like those are mutually contradictory statements
[01:46:30] <sruggier> so I don't think I'm understanding you correctly
[01:46:44] <sruggier> but I'm not sure which statement I'm misunderstanding
[01:46:50] <strcat> if the object contains &mut T, the destructor can mutate through it
[01:46:59] <strcat> assuming you're using master
[01:47:03] <sruggier> and reach out and mutate something else by reference
[01:47:09] <strcat> if you're not using master, you can't mutate *anything* in the destructor
[01:47:16] <sruggier> right
[01:47:31] <sruggier> and I just pulled, because that sounds like something I'd be interested right about now
[01:47:36] <strcat> because if you have & &mut int, it won't allow you to mutate it (well, at least I think that bug is fixed)
[01:47:41] <strcat> with &mut &mut int you can
[01:47:55] <sruggier> uh.. ok
[01:48:04] <sruggier> that's ok, I just want to call a mutable method on another type
[01:48:17] <sruggier> but you were saying the &mut self thing is only temporary?
[01:48:28] <strcat> sruggier: yeah, the plan is to switch it to by-value instead
[01:48:37] <strcat> I just switched it to &mut self so it would be less bad
[01:50:09] <sruggier> I just want to confirm that "by value" includes copying mutable pointers, and letting you modify outside objects by reference as a result
[01:50:16] <strcat> yes
[01:50:18] *** Joins: Larry (larryfox@moz-B8648F0F.nycmny.fios.verizon.net)
[01:50:44] <strcat> sruggier: if you're passing Foo, you can always take &mut Foo - so it won't forbid anything you can do now
[01:50:49] <strcat> er
[01:50:49] <sruggier> alright, then it's business as usual for me once I finish building
[01:50:51] <strcat> if you're passed*
[01:51:46] <sruggier> ok, you've confused me again, lol
[01:52:12] <sruggier> if you pass Foo by value, and then take an &mut reference to it, you're not getting a reference to the original value
[01:52:20] <sruggier> you're getting a reference to the copy
[01:52:40] <strcat> there's no semantic difference
[01:52:42] <strcat> rust doesn't have deep copies in the language
[01:53:09] <strcat> that's entirely an explicit library thing
[01:53:10] *** Joins: eatkinson (eatkinson@moz-E57448EF.airbears2.berkeley.edu)
[01:53:14] <sruggier> in this situation, though, a deep copy is the opposite of what I'd want
[01:53:57] *** Quits: Kelet (Kelet@C253143A.824EB7CA.8245F614.IP) (Ping timeout)
[01:54:16] <sruggier> supposed you have a type A, and a type B that contains a borrowed pointer to A, implements Drop, and then mutates A within the destructor
[01:54:29] <sruggier> that's all I'm trying to confirm will be possible in the long term
[01:54:37] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[01:54:40] <strcat> nothing possible now with Drop will become impossible
[01:54:52] <strcat> it will become strictly more powerful if it switches from &mut self to self
[01:55:23] <sruggier> alright, as long as that's the primary intent going forward, then that works for me
[01:55:31] <sruggier> and if it's not, I can implement roughly the same behaviour with a function that takes a closure
[01:56:58] <sruggier> thanks for clearing that up, though
[02:01:44] *** Joins: thewonderidiot (mstewart@moz-FD1FD938.hsd1.al.comcast.net)
[02:03:01] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[02:03:56] *** Joins: MarkC (Mibbit@7B3BAE64.1D53A164.B7830B68.IP)
[02:05:10] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[02:07:12] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[02:08:15] *** Quits: brendan (brendaneic@45A3491F.A5FB4ABA.FE58E87C.IP) (Quit: brendan)
[02:09:15] *** Quits: gandalf (zbraniecki@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: My lid went down)
[02:11:07] *** Quits: Larry (larryfox@moz-B8648F0F.nycmny.fios.verizon.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[02:12:38] *** Quits: eatkinson (eatkinson@moz-E57448EF.airbears2.berkeley.edu) (Quit: eatkinson)
[02:12:41] *** Joins: maik (maik@moz-F4777195.dip0.t-ipconnect.de)
[02:13:12] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[02:14:22] *** Quits: maxli (maxli@moz-A607CA26.student.cs.uwaterloo.ca) (Quit: Leaving.)
[02:14:23] <Eridius> rusti: "foo".char_at(0)
[02:14:23] -rusti- 'f'
[02:14:39] <joelteon> rusti: "Ã¼".char_at(0)
[02:14:39] -rusti- '\xfc'
[02:14:43] <joelteon> hmm
[02:14:46] <Eridius> rusti: "Ã¼f".char_at(1)
[02:14:47] -rusti- task <unnamed> failed at 'assertion failed: (w != 0)', /build/rust-git/src/rust/src/libstd/str.rs:1930
[02:14:47] -rusti- application terminated with error code 101
[02:14:51] <joelteon> rusti: "Ã¸".char_at(0)
[02:14:51] -rusti- '\xf8'
[02:14:53] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[02:14:54] <Eridius> ok so that's a byte index?
[02:14:58] <joelteon> rusti: "Â©".char_at(0)
[02:14:59] -rusti- '\xa9'
[02:15:01] <joelteon> huh.
[02:15:03] <joelteon> apparently
[02:15:07] <joelteon> would rather it was called byte_at
[02:15:17] <Eridius> joelteon: except it returns a char
[02:15:23] <Eridius> your hypothetical byte_at is just [] indexing
[02:15:23] <joelteon> but it probably shouldn't
[02:15:26] *** Quits: nejucomo (Adium@moz-434492BB.dsl.static.sonic.net) (Quit: Leaving.)
[02:15:27] <Eridius> rusti: "Ã¼"[0]
[02:15:28] -rusti- 195u8
[02:15:31] <joelteon> oh
[02:15:42] <joelteon> why doesn't char_at return a unicode character
[02:15:59] *** Joins: nejucomo (Adium@moz-434492BB.dsl.static.sonic.net)
[02:16:00] <myname> rusti: "Ã¼f"[1]
[02:16:00] <strcat> it does return a unicode code point
[02:16:00] -rusti- 188u8
[02:16:20] <Eridius> joelteon: it's returning a char, it just prints non-ascii using escapes
[02:16:30] <strcat> rusti: "Ã¼f".char_at(0)
[02:16:30] -rusti- '\xfc'
[02:16:40] <joelteon> okay, but the first character of "Â©" isn't 0xa9, it's 'Â©'
[02:16:41] <Eridius> rusti: str::from_char("Ã¼f".char_at(0))
[02:16:41] <strcat> rusti: '\xfc'
[02:16:42] -rusti- pastebinned 11 lines of output: http://sprunge.us/JaVc
[02:16:42] -rusti- '\xfc'
[02:16:55] <joelteon> or is it
[02:16:56] <Eridius> rusti: std::str::from_char("Ã¼f".char_at(0))
[02:16:57] -rusti- ~"\xfc"
[02:17:00] <Eridius> dammit
[02:17:05] <strcat> joelteon: the \x corresponds to a unicode code point
[02:17:09] <Eridius> rusti: printfln!("%s", std::str::from_char("Ã¼f".char_at(0)))
[02:17:09] <joelteon> maybe it is
[02:17:09] -rusti- Ã¼
[02:17:09] -rusti- ()
[02:17:10] <strcat> not a byte
[02:17:11] <Eridius> there we go
[02:17:12] *** Quits: nejucomo (Adium@moz-434492BB.dsl.static.sonic.net) (Quit: Leaving.)
[02:17:16] <joelteon> "Ë™".char_at(0)
[02:17:18] <joelteon> rusti: "Ë™".char_at(0)
[02:17:19] -rusti- '\u02d9'
[02:17:22] <joelteon> my mistake :X
[02:17:23] <Eridius> joelteon: any character in ISO-8859-1 has a codepoint <256
[02:17:28] <joelteon> i know, heh
[02:17:34] <joelteon> i thought Â© was outside the latin-1 range
[02:18:10] <strcat> there's an issue open about changing \x to mean byte
[02:18:13] <strcat> rather than code point
[02:18:24] *** Quits: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net) (Quit: dave1629)
[02:18:35] <strcat> rusti: "\U5"
[02:18:36] <Eridius> strcat: that would be sensible for strings. Wouldn't make much sense for chars, so I guess that would remove \x entirely from chars?
[02:18:36] -rusti- <anon>:6:12: 6:13 error: illegal numeric character escape: 34
[02:18:36] -rusti- <anon>:6     let r = {
[02:18:37] -rusti-                      ^
[02:18:37] -rusti- application terminated with error code 101
[02:18:49] <Eridius> so you'd have to say '\u00fc' instead
[02:18:49] <strcat> Eridius: probably, I'm not sure
[02:18:54] <strcat> Eridius: yeah
[02:19:00] <Eridius> I mean you could I guess leave it as-is for chars, but then that would be confusing
[02:19:05] <strcat> Eridius: it's just not a good idea because other languages use \x differently
[02:19:07] <Eridius> because right now every char escape means the same thing in a str
[02:19:29] <Eridius> ok I think it's dinnertime
[02:19:40] * Eridius is starting to loathe windows paths
[02:19:42] * strcat doesn't have a strong opinion on it and would be fine with removing it altogether
[02:19:44] <Eridius> sooo much more complicated than posix paths
[02:19:51] <engla> python uses \x too in unicode strings
[02:19:51] <Eridius> even just my normalization function is getting bloated
[02:20:07] * Eridius was hoping to have this finished up a while ago :/
[02:20:12] <strcat> engla: true
[02:20:15] *** Quits: valenting (Thunderbir@F8AEB5FE.ECBF5C84.FB866788.IP) (Ping timeout)
[02:20:19] * strcat shrugs
[02:24:06] * zxcdw shrugs back
[02:24:16] *** Joins: valenting (Thunderbir@C6866972.77435D89.FB866788.IP)
[02:25:04] *** Joins: chris2006 (Mibbit@782B96EC.1A99F5FD.DDE5D3F6.IP)
[02:25:08] *** Joins: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net)
[02:26:11] <chris2006> Hi all, I am creating a process and want to include an option so that the output is redirected to a writer
[02:26:30] *** Joins: Larry (larryfox@moz-55BA57EA.cable.mindspring.com)
[02:26:40] <chris2006> could someone please explain to me how setting options work?
[02:27:08] <strcat> chris2006: by option do you mean Option?
[02:27:23] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[02:27:43] <chris2006> strcat: yes. when creating a Process you can pass it ProcessOptions, but I do not know how to set them.
[02:28:12] *** Quits: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com) (Quit: pcwalton)
[02:28:17] <strcat> chris2006: Option is defined as 'enum Option<T> { None, Some(T) }', so None/Some(T) are the data constructors
[02:28:20] <strcat> so, 
[02:28:29] <strcat> x.foo = None, or x.foo = Some(value)
[02:28:42] <strcat> where value is the T type in Option<T>
[02:30:30] <chris2006> strcat: That's where I'm at. I don't want to bother you but looking at ProcessOptions I want to set in_fd
[02:30:40] <chris2006> which takes in Som(file-descriptor)
[02:30:40] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[02:31:07] *** Quits: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net) (Quit: dave1629)
[02:31:14] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[02:31:15] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14a2731b7 to 14570431f: 02http://git.io/N3iJvQ
[02:31:15] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[02:31:16] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[02:31:16] <ghrust> 01[13rust01] 15bors pushed 5 new commits to 06auto: 02http://git.io/dYlaRA
[02:31:16] <ghrust> 13rust/06auto 142df5a13 15Steven Fackler: Removed future's destructor...
[02:31:16] <ghrust> 13rust/06auto 14ff85389 15Steven Fackler: Modernize extra::future API
[02:31:17] <ghrust> 13rust/06auto 1448d5b4b 15Steven Fackler: Add Future::spawn_with
[02:31:18] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[02:31:18] <chris2006> so I try setting it to a file writer but the compiler says it expects an i32
[02:31:39] <sruggier> I think it wants a C-style fd
[02:31:56] <strcat> chris2006: you'd need to get an actual file descriptor - it's not a very high-level/good API
[02:33:36] *** Joins: MrOrdinaire (Mibbit@1A659656.A607747.FD383126.IP)
[02:33:47] *** Joins: mihneadb (mihneadb@moz-CFFC9266.residential.rdsnet.ro)
[02:34:04] <MrOrdinaire> hi, how do I turn on rtdebug!() printing?
[02:34:35] <aatch> MrOrdinaire, compile-time option I think
[02:34:42] *** Quits: sk (sk@BC280AA6.273A3D3C.78DD174B.IP) (Quit: Leaving)
[02:34:48] <chris2006> hmm ok. thank you! I guess on a related note, do you know how I would make writing to a file asynchronous? so that it doesn't block other tasks
[02:35:13] <strcat> acrichto: meh, that libtinfo problem is why rusti didn't update today >.<
[02:35:30] <strcat> I was wondering
[02:35:31] *** Quits: mihneadb (mihneadb@moz-CFFC9266.residential.rdsnet.ro) (Ping timeout)
[02:35:54] <acrichto> :(
[02:36:09] <acrichto> I'm still not entirely sure where it's coming from
[02:36:12] <strcat> I like the good old mainframe concept of mail
[02:36:32] <MrOrdinaire> aatch: I did `configure --enable-debug`, is that enough?
[02:36:39] <aatch> MrOrdinaire, I don't think so.
[02:36:50] <aatch> you'll have to check the source code.
[02:36:50] <strcat> "You have new mail." (as in, please read /var/spool/mail/thestinger ;P)
[02:37:23] <strcat> the only usage of atime that I know of
[02:37:48] <tikue_> how do i get rustc to be verbose when compiling?
[02:37:53] <MrOrdinaire> aatch: could you point me to where I should start reading?
[02:38:02] <aatch> MrOrdinaire, std::rt
[02:39:23] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Quit: Gone to save the world!)
[02:39:49] <klutzy> you need to pass `--cfg rtdebug` when rustc builds std
[02:40:20] <MrOrdinaire> klutzy: thanks
[02:40:45] *** jorendorff is now known as jorendorff_away
[02:41:25] *** Quits: Larry (larryfox@moz-55BA57EA.cable.mindspring.com) (Ping timeout)
[02:41:26] *** Quits: MarkC (Mibbit@7B3BAE64.1D53A164.B7830B68.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[02:41:36] <strcat> acrichto: are the snapshots still being built on the same OS they were before?
[02:41:58] <acrichto> yeah, I think that llvm pulled in a new dep
[02:42:01] <acrichto> implicitly
[02:42:11] *** Quits: zz_kimundi (kimundi@moz-2B3B2A0D.dip0.t-ipconnect.de) (Ping timeout)
[02:42:15] <klutzy> MrOrdinaire: I think I did it by `make SOME_VAR="--cfg rtdebug"` but don't remember what var was
[02:43:00] *** Quits: canhtak (jeremy@moz-44AEB22E.wl.t.ulaval.ca) (Ping timeout)
[02:43:25] *** Quits: chris2006 (Mibbit@782B96EC.1A99F5FD.DDE5D3F6.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[02:43:38] <jesseray> If I use Rust to create an executable and then put that executable on another computer (same operating system and cpu architecture), would that computer be able to run that executable without additional files?
[02:44:30] *** Joins: maxli (maxli@moz-A607CA26.student.cs.uwaterloo.ca)
[02:44:32] <strcat> jesseray: not if you use the defaults
[02:44:40] <strcat> it will dynamically link against librustrt/libstd
[02:44:41] <sp3d> jesseray: if the files listed by "ldd myprogram" are present on that computer
[02:45:03] <sruggier> _tikue: are you asking how to recompile rustc with more stuff available via RUST_LOG?
[02:45:05] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[02:45:11] <sruggier> err, I meant tikue_
[02:45:13] <MrOrdinaire> klutzy: thanks. will try to find out.
[02:45:37] *** Joins: zz_kimundi (kimundi@moz-C673AE05.dip0.t-ipconnect.de)
[02:45:50] *** Joins: Aetherspawn_BNC (uid6924@moz-31ABA2C0.irccloud.com)
[02:46:04] *** zz_kimundi is now known as kimundi
[02:46:10] <jesseray> What compiler flags (or whatever) would I need to use to make the executable usable on another computer without additional files?
[02:46:13] <tikue_> sruggier: i kind of just want rustc to tell me every single thing it's doing lol
[02:46:20] <aatch> Man, I miss type inference. C++ just makes things... hard.
[02:46:41] <jesseray> C++ just makes things ugly, lol
[02:47:02] <mark_edward_> how do import all the variants of an enum without glob imports? i thought importing hte enum type would do that
[02:47:05] <sruggier> are you trying to debug something? I think the best you can hope for is to pass --enable-debug to configure, then rebuild rustc, and then use your newly debugified rustc along with RUST_LOG
[02:47:34] <aatch> mark_edward_, either individually or you do actually have to use a glob
[02:47:43] <aatch> I think there may be an issue around about it.
[02:47:52] <sruggier> tikue_: when I did this, I used RUST_LOG=rust=4 rustc to invoke it after the rebuild
[02:48:03] <mark_edward_> aatch: :-( will that be changed? i hate glob imports... can't tell where anything came from
[02:48:04] <tikue_> sruggier: cool, thank you :)
[02:48:07] <sruggier> you'll know the rebuild worked because it will print out lots of stuff
[02:48:11] <mark_edward_> aatch: also congrats on the new job!
[02:48:22] <aatch> mark_edward_, what new job?
[02:48:27] <sruggier> tikue_: see also the output of RUST_LOG=::help rustc
[02:48:31] <aatch> mark_edward_, I think you mean acrichto?
[02:48:37] <tikue_> sruggier: ah perfect!
[02:48:45] <mark_edward_> aatch: oops, you're right! how embarassing...
[02:49:18] <tikue_> :P
[02:50:25] *** Quits: maxli (maxli@moz-A607CA26.student.cs.uwaterloo.ca) (Ping timeout)
[02:51:38] <sruggier> tikue_: it took me a while to re-find my original source for that stuff:
[02:51:38] <sruggier> http://static.rust-lang.org/doc/master/rust.html#logging-system
[02:53:32] <acrichto> mark_edward_: thanks anyway :)
[02:53:43] *** Quits: slack1256 (slack@moz-542CA772.baf.movistar.cl) (Quit: Konversation terminated!)
[02:54:59] *** Quits: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP) (Ping timeout)
[02:55:08] *** Joins: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP)
[02:55:36] <jesseray> If my code has no use statements, extern statements, etc., such that the code is in one self-sufficient file called 'example.rs', how would I need to compile that file to create an executable that I can use on another computer with the same operating system and CPU architecture but without anything Rust-related installed?
[02:55:55] <sruggier> tikue_: did you get my link to the logging section of the manual?
[02:56:09] <tikue_> sruggier: yeah, thank you :)
[02:56:31] <sruggier> welcome :)
[02:56:34] <mark_edward_> jesseray: im not sure you can. rust doesn't have static binaries yet i  think... needs dynamic stuff for the runtime and suc i think...
[02:56:46] <sruggier> I wanted to make sure you didn't leave and come back at the same time I sent it
[02:57:26] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[02:58:25] <jesseray> That's unfortunate :(
[02:58:53] <aatch> jesseray, it is possible, but difficult.
[02:58:59] <mark_edward_> acrichto: am i right that we can't make static binaries yet?
[02:59:23] <aatch> mark_edward_, the major issue is that there's no static binary for libstd
[02:59:48] <mark_edward_> aatch: why is that? are there problems making one?
[03:00:13] <aatch> mark_edward_, dunno. Haven't tried.
[03:00:25] *** Joins: julienbordellier (julienbord@A750CF4B.4E5E648E.21BDDF43.IP)
[03:00:30] <aatch> The only think I can think of is reading the metadata
[03:00:33] *** julienbordellier is now known as jstoja
[03:01:03] <aatch> since .a files are just the object files bundled together.
[03:01:34] <aatch> but static libraries are hard to get right at the best of times.
[03:02:08] *** Quits: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP) (Ping timeout)
[03:02:39] *** Joins: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP)
[03:03:50] <mark_edward_> aatch: i see. it was a major drawing point for Go. it'd be cool if rust provided the ability could do that out of the box
[03:03:59] <acrichto> mark_edward_: correct as far as I know
[03:04:10] <jstoja> guys, I might miss something but I have an error at compilation time with the master branch : https://pastee.org/snkjt
[03:04:29] <jstoja> If somebody knows what is happening there
[03:04:36] <aatch> mark_edward_, yeah, but Go also has almost 0 external dependencies
[03:05:05] <aatch> they even implemented their own linker
[03:05:23] *** Quits: heftig (heftig@moz-F0FBD069.dip0.t-ipconnect.de) (Ping timeout)
[03:06:10] *** Joins: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[03:06:18] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[03:06:29] <acrichto> jstoja: interesting... what platform are you on?
[03:07:58] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[03:08:33] <jstoja> OSX mountain lion 10.8.4
[03:09:06] <MrOrdinaire> hi, is there any way to re-export an enum in rust?
[03:09:11] <jstoja> I tried to find the dylib and move it where it should be but it fails later to...
[03:09:38] *** Quits: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Leaving...)
[03:09:44] <acrichto> jstoja: sry yeah I dunno :(
[03:09:54] <acrichto> MrOrdinaire: pub use will do most of the re-exporting you'd want
[03:10:51] <Luqman> jstoja: just do `otool -L foo`  replacing foo with your binary and it'll tell you all the dynamic libs foo links to
[03:10:55] <mark_edward_> i'm getting a lot of weird erros about glob imports.. did it change recently?
[03:11:12] <acrichto> mark_edward_: not that I know of
[03:11:41] <strcat> aatch: I've successfully made a librustrt.a and libstd.a before, but it was a while ago
[03:12:13] <strcat> I just had rustc output bytecode for std.rs
[03:12:19] <strcat> (well, core.rc ;p)
[03:12:45] <aatch> strcat, yeah, I know it's possible but the process is tricky
[03:14:10] *** Quits: maik (maik@moz-F4777195.dip0.t-ipconnect.de) (Ping timeout)
[03:14:15] <MrOrdinaire> acrichto: Thanks. So the problem was that the values of the enum is not re-exported when I `pub use module::Enum`
[03:14:50] *** Joins: maik (maik@moz-F4777195.dip0.t-ipconnect.de)
[03:14:51] *** Joins: commodorelxiv (commodorel@EAFA5719.8FDF5FB5.D5459328.IP)
[03:15:12] *** Quits: geomyidae (quassel@DD6F7E3A.21468E9A.30200F38.IP) (Client exited)
[03:15:16] *** Quits: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP) (Ping timeout)
[03:15:28] *** Joins: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP)
[03:16:16] <jstoja> Luqman: It's the makefile that don't know where the files are, before it tries to compile with it
[03:17:11] *** Joins: ww (Mibbit@moz-DFAED48A.lightspeed.sntcca.sbcglobal.net)
[03:17:34] <commodorelxiv> Hello - Is there a way in Rust to access C-style system calls like socket() connect() listen() accept() etc.
[03:18:11] <ww> rust has network support.  check out std::rt::io::net::tcp mod
[03:18:17] <commodorelxiv> thanks
[03:18:39] *** Quits: maik (maik@moz-F4777195.dip0.t-ipconnect.de) (Ping timeout)
[03:18:52] *** Quits: commodorelxiv (commodorel@EAFA5719.8FDF5FB5.D5459328.IP) (Quit: Leaving)
[03:18:55] <ww> the master branch 0.8-pre has lots of change on the std::rt::io::net.  things are still being added
[03:21:14] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[03:24:21] *** Quits: Aetherspawn_BNC (uid6924@moz-31ABA2C0.irccloud.com) (Ping timeout)
[03:24:52] *** Joins: maik (maik@moz-F4777195.dip0.t-ipconnect.de)
[03:25:45] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[03:27:50] <jstoja> acrichto: found... just that I had the CXX env variable defined...
[03:28:07] *** Quits: maik (maik@moz-F4777195.dip0.t-ipconnect.de) (Ping timeout)
[03:28:27] <acrichto> jstoja: ah I guess that would do it 
[03:28:39] <jstoja> haha
[03:28:42] <acrichto> jstoja: oh yeah I should have mentioned `make VERBOSE=1` will print what's getting run
[03:28:51] <acrichto> and you probably would have figured that out a bit quicker :P
[03:29:13] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[03:29:29] <jstoja> My bad that I do not knew VERBOSE=1 before :)
[03:30:02] <acrichto> our documentation is a bit... lacking
[03:30:35] *** Quits: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net) (Ping timeout)
[03:30:42] *** Joins: heftig (heftig@moz-F0FBD069.dip0.t-ipconnect.de)
[03:30:59] *** Joins: geomyidae (quassel@DD6F7E3A.21468E9A.30200F38.IP)
[03:35:06] *** Joins: Liothen (liothen@moz-788EBAD0.spkn.qwest.net)
[03:37:42] *** Joins: ecr (Thunderbir@moz-E3E8EE8F.cinci.res.rr.com)
[03:37:58] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[03:38:05] <ecr> brson: ping
[03:38:26] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[03:39:51] <dbaupp> cmr: no, changing it to be a glob will be fine, but it'll only keep the file called '*' :P (unless you mean changing the code too.)
[03:39:57] *** Quits: ecr (Thunderbir@moz-E3E8EE8F.cinci.res.rr.com) (Quit: ecr)
[03:40:36] *** Quits: MrOrdinaire (Mibbit@1A659656.A607747.FD383126.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[03:41:20] *** Quits: Jesin (Jessin_@moz-CDB412A.cc.lehigh.edu) (Ping timeout)
[03:41:54] *** Joins: Jesin (Jessin_@moz-CDB412A.cc.lehigh.edu)
[03:42:58] *** Quits: jstoja (julienbord@A750CF4B.4E5E648E.21BDDF43.IP) (Ping timeout)
[03:44:05] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.1)
[03:45:05] *** Quits: lerc (quassel@B2E8CAD3.A8D14E52.788638A4.IP) (Ping timeout)
[03:47:01] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[03:47:13] *** Joins: lerc (quassel@B2E8CAD3.A8D14E52.788638A4.IP)
[03:47:48] <Luqman> brson: r? again https://github.com/mozilla/rust/pull/9301
[03:47:59] *** Joins: moot (Mibbit@moz-5256162B.hsd1.ca.comcast.net)
[03:49:05] *** Joins: jclements (jclements@moz-3CA4E1EA.static.stls.mo.charter.com)
[03:49:33] *** Quits: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP) (Ping timeout)
[03:50:01] *** Joins: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP)
[03:50:39] <dbaupp> bors is off?
[03:51:43] <acrichto> brson was messing around with him earlier, not sure if bors got turned back on
[03:52:34] <brson> bors should be on
[03:53:17] <brson> he's waiting for the future build to finish
[03:53:29] <acrichto> blasted interrupted system calls, bors hasn't made a lot of progress in the last day or so :(
[03:53:46] <acrichto> aren't we all waiting for a future build to finish?
[03:53:57] *** Quits: Voomer (Voomer@moz-CC05FF5E.hsd1.wa.comcast.net) (Connection reset by peer)
[03:54:09] <brson> acrichto: did disabling the process tests not fix the syscall problem?
[03:54:54] <acrichto> brson: not much testing data yet, pcwalton's pull died in rustdoc (not a problem), and I haven't seen anything else succeed or fail, I was referencing the past 48-ish hours that bors has just been failing everything (involving a lot of retries...)
[03:55:04] *** Quits: valenting (Thunderbir@C6866972.77435D89.FB866788.IP) (Ping timeout)
[03:55:41] <tikue_> bors is getting grumpy in his old age
[03:56:57] *** Quits: jclements (jclements@moz-3CA4E1EA.static.stls.mo.charter.com) (Quit: jclements)
[03:57:38] <cmr> dbaupp: yeah, I mean changing the code
[03:57:49] *** Quits: RMF (RMF@78B6AE45.A4D51E9D.6119BA41.IP) (Ping timeout)
[03:58:38] <dbaupp> cmr: fine by me
[03:59:40] <Eridius> tests for WindowsPath are approach 50% of the lines in this file :/
[04:00:46] *** Joins: maik (maik@moz-F4777195.dip0.t-ipconnect.de)
[04:01:57] *** Joins: nejucomo (Adium@moz-434492BB.dsl.static.sonic.net)
[04:02:10] *** Quits: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP) (Ping timeout)
[04:02:16] *** Joins: RMF (RMF@43899495.D5A48DF4.11F731AB.IP)
[04:02:42] *** Joins: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP)
[04:03:51] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[04:04:19] *** Joins: nsf (nsf@moz-EEF3238A.convex.ru)
[04:04:28] *** Quits: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP) (Ping timeout)
[04:06:16] *** Quits: eevee (eevee@moz-D25DD324.evrt.wa.frontiernet.net) (Ping timeout)
[04:07:43] *** Joins: lkuper_ (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[04:07:57] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[04:11:31] *** Joins: jstoja (julienbord@A750CF4B.4E5E648E.21BDDF43.IP)
[04:12:32] <engla> sfackler: (I'm blake2-ppc) you're trying to make your example as complicated as possible! ;-)
[04:12:44] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[04:12:44] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/dYlaRA
[04:12:44] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[04:12:48] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[04:13:18] <engla> sfackler: it's not that hard. also.. how exactly to adapt or remove Cell is not really the most important point
[04:13:33] *** Joins: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP)
[04:14:08] *** Joins: vodik (simon@moz-CBE4BB13.cable.teksavvy.com)
[04:14:53] *** Joins: dandy (Dandy@moz-84CC8377.hsd1.co.comcast.net)
[04:16:02] <sfackler> yep :)
[04:16:18] <sfackler> it's also really cool that impl<T> Foo<Option<T>> works
[04:17:08] <engla> Is it an odd thing to do?
[04:17:23] <engla> it's sort of just the generic version of  impl Foo<int> 
[04:17:55] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[04:17:55] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/44VwMg
[04:17:55] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[04:17:57] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[04:17:57] <ghrust> 01[13rust01] 15bors pushed 5 new commits to 06auto: 02http://git.io/VHkHvw
[04:17:57] <ghrust> 13rust/06auto 149621156 15Luqman Aden: librustc/libstd: No longer pass crate_map to start.
[04:17:57] <ghrust> 13rust/06auto 14133200a 15Luqman Aden: libstd/librustc: Make the crate_map a weak symbol that libstd links against.
[04:17:58] <ghrust> 13rust/06auto 14d3309eb 15Luqman Aden: tests: Remove crate_map from start.
[04:17:59] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[04:18:00] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[04:18:21] <sfackler> I didn't even know rust could do impl Foo<int> until now!
[04:18:35] <sfackler> the only specialization i was familiar with was impl<T: Thing> Foo<T>
[04:19:37] *** Quits: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP) (Ping timeout)
[04:20:42] *** Joins: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP)
[04:22:43] *** Quits: maik (maik@moz-F4777195.dip0.t-ipconnect.de) (Ping timeout)
[04:23:16] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[04:25:24] *** Quits: Shaladdle (anonymous@400E34DE.F3E8A984.689607DE.IP) (Quit: Shaladdle)
[04:26:11] *** Quits: aatch (James@moz-B437F499.pocketrent.com) (Client exited)
[04:27:04] *** Quits: Yeri (jasonjasmi@41C91A8A.CE609BA5.E39FBF79.IP) (Quit: Yeri)
[04:30:47] <sfackler> acrichto: looking at local_data.rs: // there is no need to be upset! D:
[04:31:03] <acrichto> that may have been me...
[04:31:42] <sfackler> git blame says it was :D
[04:31:58] <sfackler> anything specific I should watch out for raii-ifying get and co?
[04:32:27] <acrichto> not particularly, but cc me on the pull
[04:32:37] <sfackler> will do
[04:32:50] <acrichto> the only thing is basically knowing when something goes out of scope and then re-looking it up to go fix it
[04:33:35] <sfackler> unsafe { libc::abort() } failure uses TLS?
[04:34:09] <acrichto> ?
[04:34:23] <acrichto> those all could/should be unreachable!()
[04:35:03] <sfackler> will terrible things happen if unreachable() is reached?
[04:35:18] <sfackler> inside of tls stuff?
[04:35:30] <Eridius> util::unreachable() just called fail!(). I don't know if unreachable!() is any different
[04:35:37] <dbaupp> it's not
[04:35:53] <Eridius> ah yeah, it just calls fail!()
[04:36:08] <dandy> Reading the tutorial: 17.4 Files and modules, does it mean that when I compile with rustc I can have the code in whatever files I want, in whatever order I want, so long as the whole crate works out in the end?
[04:36:10] <dbaupp>  macro_rules! unreachable (() => (        fail!(\"internal error: entered unreachable code\");    ))
[04:36:15] <acrichto> sfackler: I don't think that the fail path reaches into tls
[04:36:18] <acrichto> I could be wrong though...
[04:36:37] *** Quits: cdidd (cdidd@moz-C221DD30.broadband.corbina.ru) (Ping timeout)
[04:36:52] *** Joins: Shaladdle (anonymous@363D4CBA.AE5E2FB1.689607DE.IP)
[04:38:33] *** Quits: Shaladdle (anonymous@363D4CBA.AE5E2FB1.689607DE.IP) (Ping timeout)
[04:42:08] *** Joins: cdidd (cdidd@moz-86706526.broadband.corbina.ru)
[04:42:21] *** Quits: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP) (Ping timeout)
[04:44:07] <engla> dandy: mostly. files will be modules, so you will think a bit about how to separate things
[04:44:29] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[04:45:05] <Eridius> yay, WindowsPath tests all pass. Time to add some more
[04:45:19] <engla> nice Eridius 
[04:45:20] <dandy> still trying to map my C# thoughts to this
[04:45:39] <dandy> if I had two classes, Vector and Point I would put them in two files, because I can
[04:45:57] <dandy> but it seems like they need to be in a single file together to be in the same module
[04:46:05] *** Parts: thewonderidiot (mstewart@moz-FD1FD938.hsd1.al.comcast.net) ()
[04:46:20] <engla> probably not, unless they need to acess each other's privates
[04:46:25] <engla> access
[04:46:32] <Eridius> dandy: if you truly want to use multiple files, you can use the include!() syntax extension to pull in extra files. But I would advise against it
[04:46:34] <mark_edward_> what does this error even mean? error: unresolved import (maybe you meant `iou=ioutil;::*`?)
[04:46:39] <mark_edward_> isn't tat incorrect?
[04:46:46] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[04:46:46] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14017c0f0 to 14407d179: 02http://git.io/N3iJvQ
[04:46:46] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[04:46:48] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[04:46:48] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/zTma5w
[04:46:48] <ghrust> 13rust/06auto 141019177 15Benjamin Herr: lexer: show correct span on lexical errors...
[04:46:48] <ghrust> 13rust/06auto 148009c97 15Benjamin Herr: lexer: report problematic chars verbatim or as escape sequence...
[04:46:49] <ghrust> 13rust/06auto 14567c567 15Benjamin Herr: lexer: further slight improvements to lexer errors
[04:46:51] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[04:46:54] <dandy> Eridius, they can get pretty long
[04:46:56] <Eridius> mark_edward_: did it literally say `iou=ioutil;::*`? If so, it's a bit off its rocker
[04:47:00] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[04:47:34] <mark_edward_> Eridius: yes it did, it's given me several things like that. also
[04:47:36] <mark_edward_> error: unresolved import (maybe you meant `FNodeInfoMap::*`?)
[04:47:37] <mark_edward_> find_ast_node.rs:19 use visitor::{Finder, FncsThing, FNodeInfoMap};
[04:47:59] <Eridius> mark_edward_: looks like the rror message simply says (maybe you meant `%s::*`?) where %s is the bad import
[04:48:07] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[04:48:20] <strcat> dandy: you can divide things into a bunch of files and then re-export them in one module
[04:48:30] <Eridius> mark_edward_: you should file an issue. That error message is obviously not very helpful in its current state
[04:48:31] <mark_edward_> hm, well it doesn't make any sense.. and this project used to compile fine...
[04:48:32] *** Joins: Shaladdle (Shaladdle@moz-424BC304.hsd1.pa.comcast.net)
[04:48:47] *** Quits: Shaladdle (Shaladdle@moz-424BC304.hsd1.pa.comcast.net) (Quit: Leaving)
[04:48:55] <mark_edward_> ok
[04:49:33] <dandy> strcat, using include!() or something else?
[04:49:40] <strcat> dandy: using 'pub use'
[04:49:43] <strcat> to re-export
[04:49:44] <Eridius> dandy: don't actually use include!(). I shouldn't have brought it up
[04:49:49] <engla> dandy: pub[lic] and priv[ate] are always in relation to the module boundary. so everything that needs to access the same non-pub things must be in the same module, that's all
[04:50:19] <dandy> I get that, but how does rustc know about point.rs if it is within the core module
[04:50:39] <dandy> it know to clook for a core.rs
[04:50:44] <dandy> to look*
[04:50:47] *** Quits: Jesin (Jessin_@moz-CDB412A.cc.lehigh.edu) (Ping timeout)
[04:50:48] *** Joins: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP)
[04:50:55] *** Quits: voxpopuli (fanservice@moz-FE161659.wv.cc.cmu.edu) (Ping timeout)
[04:51:02] <strcat> lets say you have a directory with 'main.rs' and 'point.rs'
[04:51:09] <strcat> and you compile with 'rustc main.rs'
[04:51:32] <strcat> the 'main.rs' file will use 'mod point;' (or 'pub mod point;')
[04:52:00] <strcat> you can then optionally re-export stuff, say 'pub use point::Point;'
[04:52:23] <dandy> oh :( so everything has to be point::Point or vector::Vector?
[04:52:33] *** Quits: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP) (Ping timeout)
[04:52:54] *** Quits: Earnestly (earnest@moz-BE290A2B.dyn.plus.net) (Ping timeout)
[04:52:59] <Eridius> dandy: if you use separate files, yes
[04:53:03] <Eridius> hence the re-exporting
[04:53:32] *** Joins: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP)
[04:53:41] <dandy> oh so in the root I would do "pub use point::Point" and it would be exported as simply "Point"?
[04:53:57] *** Quits: cdidd (cdidd@moz-86706526.broadband.corbina.ru) (Input/output error)
[04:54:10] *** Joins: jaen (jaen@moz-C9E58763.play-internet.pl)
[04:54:42] <Eridius> dandy: well it would be accessible from whatever module you re-exported it from
[04:54:58] <Eridius> so you could have a types.rs that merely consists of things like 'pub use point::Point; pub use vector::Vector;'
[04:55:02] <Eridius> and now you'd have types::Point and types::Vector
[04:55:08] <dandy> yeah!
[04:56:06] <dandy> to somebody use it I just want them to do something like "extern mod myLib" "use myLib::{Point, Vector}"
[04:56:25] <dandy> for somebody to use it* (time for a new keyboard)
[04:56:37] <Eridius> sure yeah, you can do that by re-exporting from the root
[04:56:46] *** Quits: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP) (Ping timeout)
[04:57:16] *** Joins: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP)
[04:57:54] *** Joins: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP)
[04:57:54] *** ChanServ sets mode: +o jdm
[04:58:16] <dandy> Neat, I think I will start porting this over soon (https://github.com/aarondandy/vertesaur) as it doesen't do anything too crazy
[04:58:26] <dandy> I am hoping it will be immune to the language changing too much
[04:59:31] *** Quits: lkuper_ (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Quit: lkuper_)
[04:59:43] <olsonjeffery> dandy: there's a few big changes coming, still
[04:59:52] <dandy> is + being redefined?
[05:00:02] <Luqman> damn it windows :(
[05:00:45] <dandy> damn.exe - Application Error
[05:01:08] <dbaupp> dandy: nothing is immune!
[05:01:17] <dandy> thats fine, I will adapt
[05:01:23] <dandy> I am only porting that though
[05:01:30] <dandy> I figure it will help me learn
[05:02:15] <dandy> Thanks for the crate/mod clarifications
[05:02:31] <ww> hi all.  i've just released my first rust project, a memcached client in rust.  https://github.com/williamw520/rustymem
[05:02:41] *** Quits: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP) (Ping timeout)
[05:03:09] <Eridius> ww: nice
[05:03:13] *** Joins: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP)
[05:03:16] <ww> i started the project as a way to learn rust.  thanks all for your very helpful answers to my seemingly stupid questions from time to time
[05:03:22] <dandy> old news, was on reddit first :)
[05:03:24] *** Joins: aeqwa (aeqwa@moz-ABA21D72.dsl.tropolys.de)
[05:03:29] <ww> you guys are great
[05:04:06] <ww> dandy: old news?  ha.  just posted it to reddit.
[05:04:43] <dandy> I know it feel funny, but because of the new github explore changes please DO star your own projects
[05:04:58] <Eridius> dandy: ?
[05:04:58] *** Quits: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP) (Ping timeout)
[05:05:02] <ww> ok, thanks.  will do
[05:05:09] <dandy> ill get you a link...
[05:05:39] <dandy> I do this on my phone when I poo: https://github.com/search?l=rust&q=stars%3A%3E1&s=updated&type=Repositories
[05:05:54] <dandy> I like to see whats up, but it only seems to filter based on stars
[05:05:56] *** Joins: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP)
[05:05:59] <Eridius> hah, first 2 results are rust and servo
[05:06:11] <dandy> and I tried changing it to 0, and aparently it thinks I really wanted 1
[05:06:17] <dbaupp> ww: btw, you very rarely need to allocate ~ boxes; e.g. connect "should" return `RustyMem` rather than `~RustyMem`.
[05:06:18] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[05:06:35] <dandy> so obviously -1 won't do much good
[05:07:23] <ww> dbaupp: but then would that ends up on the stack?
[05:07:34] <dandy> so pretty please star your stuff
[05:08:08] <dbaupp> ww: yeah, why is that particularly bad?
[05:08:27] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[05:08:32] *** Quits: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP) (Ping timeout)
[05:08:38] <strcat> ww: the caller can always choose to put the return value somewhere else
[05:08:46] <ww> what if the caller wants to share it
[05:08:54] <strcat> ww: doesn't need to be in ~ to send it
[05:09:26] <dandy> OH never mind, it works with >=, never thought to try that
[05:09:30] <strcat> the only difference between Foo and ~Foo is that ~Foo is always going to be pointer-size, and always has a destructor to clean up the allocation
[05:09:39] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[05:09:48] <strcat> if you return Foo, the caller can always put it in ~ if they want
[05:10:02] <ww> memory movement and ownership is one thing i don't quite understand since the exchange heap idea is gone and the doc is kind of out dated.
[05:10:23] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[05:10:29] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[05:10:29] <strcat> the 'exchange heap' was always an incorrect attempt to explain it
[05:10:35] <strcat> the tutorial is up-to-date
[05:10:39] <strcat> the boxes section
[05:10:43] <ww> if a struct is on stack, when the user moves it, would it got copied?
[05:10:52] <Eridius> ww: it would get moved
[05:10:56] *** Joins: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP)
[05:11:05] <ww> ok
[05:11:09] <Eridius> so yeah the bytes that make up the "top level" of the struct, so to speak, would be copied, and then the old value would be thrown away
[05:11:17] <strcat> ww: only time you need ~T is when you have a recursive data structure and you need to prevent it from being infinite size
[05:11:22] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Ping timeout)
[05:11:31] <strcat> using it anywhere else is questionable - unless you've benchmarked and the indirection is actually helpful
[05:11:32] <ww> but if the user returns from its function, the stack version would get destroyed, right?
[05:11:40] <Eridius> strcat: or if your type is actually huge, because it's a [int, ..1_000_000] or something
[05:11:47] <Eridius> but that should be rare
[05:11:50] <dbaupp> ww: yes, but so would the ~ version.
[05:11:53] <strcat> ww: there is no semantic reason to use ~Foo instead of Foo
[05:12:00] <Eridius> ww: both stack values and ~ values have a single owner
[05:12:02] <strcat> unless it's a recursive data structure
[05:12:26] <strcat> all ~T does is add a destructor + make it pointer-size
[05:12:28] <ww> ~ version is on the heap, right?  so it won't get destroyed when return from a function
[05:12:36] <Eridius> ww: well it will, because the function owns it
[05:12:49] <Eridius> unless the function returns it, or stuffs it somewhere accessible (e.g. TLS)
[05:12:51] <strcat> ww: ~T and T have the same value semantics
[05:12:58] <strcat> they have a single owner
[05:12:59] <Eridius> but the function could also return or move a stack value somewhere
[05:13:04] <strcat> when they go out of scope, the destructor is called
[05:13:13] <strcat> the *only* difference is really that ~T is pointer-size + adds a destructor
[05:13:23] <ww> i see.  
[05:13:23] *** Quits: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP) (Ping timeout)
[05:13:25] <strcat> if you don't gain anything from it being pointer-size, you don't want it
[05:13:27] <Eridius> in my own code, the main reason I bother with ~ is for ~str and ~[T]
[05:13:34] *** Joins: Jesin (Jessin_@moz-CDB412A.cc.lehigh.edu)
[05:13:34] <strcat> (which aren't really unique pointers)
[05:13:42] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[05:13:51] <strcat> calling them Str and Vec would arguably be a lot clearer to people
[05:14:00] *** Joins: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP)
[05:14:03] <ww> ok, that makes sense
[05:14:28] <ww> i feel like there were too many ~ in the code reading wise and seems like code smell
[05:14:44] *** Joins: Voomer (Voomer@moz-CC05FF5E.hsd1.wa.comcast.net)
[05:14:48] <ww> but thought it would avoid copying and movement
[05:14:54] <ww> anyway good to get it cleared up
[05:15:20] <strcat> you want to be using plain old values unless you have a good reason for allocation
[05:15:21] <Eridius> ww: movement is typically fine. Copying will only happen implicitly on primitive values; for anything non-primitive, if there's no .clone() there's noc opy
[05:15:24] <Eridius> *no copy
[05:15:34] <Eridius> usually moving a struct around is going to be cheaper than allocating heap memory
[05:15:39] <strcat> that's not true
[05:15:44] <Eridius> no?
[05:16:00] <dandy> very huge things
[05:16:01] <dbaupp> ww: using ~ *does* make moves cheaper, since it only has to copy around a single pointer; but this often isn't particularly important.
[05:16:04] <strcat> no, I don't mean that
[05:16:04] *** Quits: Amaranth (travis@moz-F81BB56A.cpe.cableone.net) (Ping timeout)
[05:16:05] <sfackler> bblum: is local_data::modify just a convenience or are there limitations to pop/set?
[05:16:15] <strcat> 'Copying will only happen implicitly on primitive values' this part isn't true
[05:16:16] *** Joins: Jessin (Jessin_@moz-CDB412A.cc.lehigh.edu)
[05:16:16] <bblum> just a convenience iirc
[05:16:25] <Eridius> strcat: what non-primitive will get implicitly copied?
[05:16:26] <strcat> and you should be clearer about the semantics
[05:16:35] <strcat> ok, here are the semantics
[05:16:56] <strcat> rust has 1 form of assign/passing/returning in the language: by-shallow-copy, if the type has a destructor, &fn or &mut it will move ownership
[05:16:57] <strcat> there's nothing else.
[05:17:07] *** Quits: Jesin (Jessin_@moz-CDB412A.cc.lehigh.edu) (Ping timeout)
[05:17:13] *** Quits: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP) (Ping timeout)
[05:17:19] <dandy> what is the difference between moving and copying? do you mean moving ownership?
[05:17:22] <engla> Even if you call like let x = ~f(), the caller should malloc and pass that as return address to the function `f`, so it should be efficient
[05:17:46] <strcat> dandy: a move is a shallow copy stealing ownership from the source
[05:17:55] *** Joins: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP)
[05:18:01] <strcat> the only form of assign/passing/returning at a language level is by-shallow-copy
[05:18:04] <Eridius> strcat: hmm, you're right, a trivial struct does copy. For some reason I thought it didn't
[05:18:04] <strcat> there are no alternatives
[05:18:08] <dandy> can a clone is a deep copy?
[05:18:15] <dandy> and a clone* FFS
[05:18:25] <strcat> dandy: there are Clone/DeepClone traits in the library
[05:18:31] <strcat> they both take &self
[05:18:38] <strcat> so they have to create a type independent from the old one
[05:18:39] *** Joins: Amaranth (travis@moz-F81BB56A.cpe.cableone.net)
[05:18:47] *** Quits: jaen (jaen@moz-C9E58763.play-internet.pl) (Ping timeout)
[05:18:49] <strcat> Clone will do as little as possible, DeepClone will go as deep as possible
[05:19:03] <dandy> that was a bit of a fuckup in .NET with IClonable
[05:19:09] <dandy> thats good its defined both ways
[05:19:14] <Eridius> DeepClone will copy @-boxes
[05:19:16] <strcat> so Clone will copy anything that's owned, and stop at Rc/@ boundaries
[05:19:32] <strcat> DeepClone does more work than necessary just to get a new value, since it makes an independent one
[05:19:54] <strcat> (the only language-level form of this is by-shallow-copy, and a move just means the source can't be used anymore)
[05:20:54] <myname> sow move is copy and destroy?
[05:21:00] <strcat> no
[05:21:24] *** Quits: geomyidae (quassel@DD6F7E3A.21468E9A.30200F38.IP) (Client exited)
[05:21:28] *** Quits: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP) (Ping timeout)
[05:21:32] <strcat> it's a shallow copy, and you can't use the source anymore
[05:21:37] *** Joins: eevee (eevee@moz-8B105F97.evrt.wa.frontiernet.net)
[05:21:43] <jdm> what's the cleanest way to deal with inserting a new element into a hashmap that contains owned vector values?
[05:21:59] <jdm> specifically, I always want to append a new element
[05:22:14] *** Joins: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP)
[05:22:14] <strcat> jdm: how do you want to handle no match for the key?
[05:22:16] *** Joins: geomyidae (quassel@DD6F7E3A.21468E9A.30200F38.IP)
[05:22:28] <strcat> no-op? or insert
[05:22:32] <jdm> strcat: insert
[05:22:40] <jdm> create a new vector containing the element to append
[05:22:46] <Eridius> jdm: so you have a HashMap<Key,~[Val]> and you want to add a new Val?
[05:22:50] <Eridius> jdm: perhaps the .mangle() function
[05:23:09] *** Quits: geomyidae (quassel@DD6F7E3A.21468E9A.30200F38.IP) (Client exited)
[05:23:13] <strcat> jdm: find_or_insert, and modify the return value would work
[05:23:34] <Eridius> map.mangle(key, val, |k,x| ~[x], |k,v,x| v.push(x))
[05:23:56] <Eridius> strcat: find_or_insert will allocate a new ~[] on every insert even when not needed
[05:23:56] <strcat> that's the low-level way
[05:24:06] <Eridius> since you'd have to say map.find_or_insert(key,~[]).push(val)
[05:24:20] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[05:24:28] *** Joins: geomyidae (quassel@DD6F7E3A.21468E9A.30200F38.IP)
[05:24:28] <Eridius> I suppose .find_or_insert_with() might work
[05:24:30] <strcat> true
[05:24:39] <Eridius> map.find_or_insert_with(key, |_| ~[]).push(val)
[05:24:46] <strcat> although an empty ~[] shouldn't allocate, I consider it an implementation mistake
[05:25:06] <sfackler> hmm, would it be a good idea to pull that family of functions onto MutableMap?
[05:25:13] <strcat> sfackler: no, too much of a mess
[05:25:19] <strcat> need a better way of doing it
[05:25:40] <strcat> hashmap turned into a bit of a mutant lab experiment
[05:25:44] <strcat> way too complex
[05:25:49] <myname> lol
[05:26:20] <strcat> closures have a very real performance cost when you use them like that
[05:26:20] *** Joins: maik (maik@moz-F4777195.dip0.t-ipconnect.de)
[05:26:39] *** Quits: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP) (Ping timeout)
[05:26:49] <strcat> hashmaps need to be fast, and ours aren't
[05:26:56] * strcat shrugs
[05:27:26] <strcat> it's kind of sad that the incredibly naive std::trie full of workarounds for the old borrowck is as fast
[05:27:30] *** Joins: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP)
[05:27:51] *** Joins: Aetherspawn_BNC (uid6924@moz-31ABA2C0.irccloud.com)
[05:27:57] <dcrewi> are Maps used in librustc/librustsyntax much?
[05:28:03] <strcat> yes.
[05:28:07] <sfackler> some of the need for mangle and co. might go away when https://github.com/mozilla/rust/issues/6393 is fixed
[05:28:32] <dcrewi> so changing that trait would be a big headache
[05:28:41] <sfackler> since matching on find won't freeze the map in the None branch
[05:28:41] <strcat> dcrewi: not really
[05:28:50] <dcrewi> but on the other hand using Map<~str,T> is also pretty annoying
[05:29:08] <strcat> they don't actually use the trait directly
[05:29:09] <dcrewi> and that is something I expect a lot of applications would want to use
[05:29:15] *** Quits: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP) (Ping timeout)
[05:29:25] *** Joins: ross (ross@moz-5EA04060.br.br.cox.net)
[05:29:38] <strcat> dcrewi: there's no general solution for that you can put in the trait
[05:29:56] <strcat> use send_str
[05:29:58] *** Quits: dandy (Dandy@moz-84CC8377.hsd1.co.comcast.net) (Quit: Leaving)
[05:30:32] * strcat shrugs
[05:30:40] *** Joins: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP)
[05:30:49] <strcat> Equiv only works as a drop-in replacement for equality
[05:31:00] <strcat> so it's close to hashmap-specific
[05:31:16] <dcrewi> when the keys are str, I expect to be able to lookup and insert using a borrowed reference
[05:31:33] <dcrewi> instead of having to copy all over the place
[05:31:46] <strcat> lookups are done with &K
[05:32:06] <strcat> if you use ~str as K, you're choosing to do lookups with &~K in general
[05:32:16] <strcat> you can use SendStr as the key, or specifically use a hashmap for find_equiv
[05:32:27] <strcat> &str isn't a borrowed ptr
[05:33:15] *** Quits: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP) (Ping timeout)
[05:33:20] <strcat> there's really no general solution to Map trait can use, other languages like C++ experience this same issue
[05:34:20] *** Joins: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP)
[05:34:21] *** Joins: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net)
[05:34:32] <engla> separate the key and lookup type, and somehow specialize so that HashMap<~str, T> uses lookup type &str
[05:34:39] <engla> somehow(?)
[05:35:01] *** Quits: lbergstrom (Adium@moz-5D8E4B14.lightspeed.cicril.sbcglobal.net) (Ping timeout)
[05:35:13] <strcat> engla: won't work for the Map trait
[05:35:33] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[05:35:50] <strcat> there is a required relation between the key type and lookup type
[05:35:53] <strcat> and it varies per container
[05:35:58] <strcat> for TreeMap, it's TotalOrd
[05:36:14] <strcat> for HashMap, it's Eq (soon TotalEq) - Equiv is a version of that with a type parameter
[05:36:28] <strcat> and Equiv relies on the *assumption* that the hashes are going to be the same too, for hashmaps
[05:36:56] *** Quits: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP) (Ping timeout)
[05:37:08] *** Joins: lbergstrom (Adium@moz-5D8E4B14.lightspeed.cicril.sbcglobal.net)
[05:37:48] *** Joins: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP)
[05:38:15] <engla> oh good points
[05:39:00] <strcat> it's an inherently unsolvable problem space, you can just make it less painful for special cases
[05:39:05] <strcat> C++14 has 2 proposals related to this
[05:40:20] <dcrewi> if there is no general solution for Map, maybe that means a specialized trait for maps with vector keys should exist?
[05:40:36] *** Quits: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP) (Ping timeout)
[05:40:51] *** Quits: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net) (Ping timeout)
[05:41:07] *** Joins: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP)
[05:41:14] <strcat> dcrewi: which kind of vector key? ~[T] won't be the only one
[05:42:04] <engla> do you mean a specialization for string keys?
[05:42:21] <engla> strcat: are those proposals going to be implemented?
[05:42:28] <dcrewi> engla: yes, I was treating str as a special kind of vector
[05:42:36] <strcat> engla: I think so, they may have already been accepted
[05:42:43] <dcrewi> or I guess not so special, really
[05:42:54] <strcat> engla: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3573.html for their hashmaps
[05:43:01] <strcat> engla: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3657.htm for their treemaps
[05:43:07] <dcrewi> strcat: and I feel there is some aspect to your question that I'm not getting
[05:43:23] <strcat> dcrewi: so you have ropes, SmallVec, ~[T], @[T]
[05:43:34] <strcat> and other types of sequences
[05:43:39] <olsonjeffery> strcat: quick PL question, if you know the answer: how does monomorphization differ from specialization? or does it even matter?
[05:43:44] <strcat> and in general, sequences of the same element type can be compared
[05:45:03] <strcat> olsonjeffery: monomorphization means implementing polymorphic functions by generating specialized monomorphic code
[05:45:43] <strcat> specialization isn't a great word because it'll get interpreted as meaning what it does in C++
[05:45:56] <strcat> where you have a generic function, and you also specialize it for some types
[05:46:11] *** Quits: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP) (Ping timeout)
[05:46:31] <strcat> (default methods are a similar concept)
[05:46:38] *** Joins: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP)
[05:46:40] *** Quits: maik (maik@moz-F4777195.dip0.t-ipconnect.de) (Ping timeout)
[05:48:08] <olsonjeffery> strcat: so is "what it does in C++" also monomorphization?
[05:48:41] <strcat> olsonjeffery: 'specialization' in C++ is something totally different than a strategy for compiling generic fns
[05:48:43] <strcat> it's a language feature
[05:49:24] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Quit: leaving)
[05:50:02] <strcat> olsonjeffery: for example,
[05:50:13] <strcat> C++ has std::vector<T>
[05:50:28] <strcat> but they also defined a specialization for std::vector<bool> (now regarded as a mistake)
[05:50:58] <strcat> std::vector<bool> compresses them to bits, and isn't a "container" - it can't return references to bool
[05:51:09] <strcat> that's what specialization means in C++
[05:51:23] <strcat> that's why monomorphization is a good word - really, really clear you don't mean that ;p
[05:51:36] <olsonjeffery> gotcha. thanks.
[05:51:45] <olsonjeffery> you gonna be around tomorrow night?
[05:51:52] <strcat> probably
[05:51:56] <olsonjeffery> i might do a dry run of my rust talk next saturday
[05:52:01] <olsonjeffery> i need someone to tear me down
[05:52:16] <olsonjeffery> well, whoever's around. but especially who can tell me how wrong i am :P
[05:52:22] *** Quits: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP) (Ping timeout)
[05:52:27] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[05:52:38] <olsonjeffery> well. doing the dry run tomorrow. for the talk on the 28th.
[05:52:47] <olsonjeffery> depending on if i can get my slides/notes in order..
[05:53:05] <dbaupp> olsonjeffery: extra::sort is good for that
[05:53:29] <olsonjeffery> i see what you did, there.
[05:54:42] *** Joins: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP)
[05:55:13] <strcat> maybe I feel like doing a paradigm shift in std::option now ;P
[05:55:29] <tikue_> strcat: what do you mean?
[05:55:41] <kimundi> strcat: to_Ref etc?
[05:55:46] <strcat> yeah
[05:55:54] <kimundi> sounds good
[05:56:02] *** Joins: Shaladdle (anonymous@moz-424BC304.hsd1.pa.comcast.net)
[05:56:03] <strcat> well, I keep hearing people repeat that it will never be as neat as haskell because rust has by-value, by-ref, by-mut-ref
[05:56:05] <strcat> but it's not true!
[05:56:20] <tikue_> wot
[05:56:29] <strcat> you just write generics using some generic parameter A, where A can be anything
[05:56:34] <strcat> &/&mut aren't special
[05:56:40] <strcat> they're values :)
[05:56:43] <strcat> so anyway
[05:56:54] *** Quits: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net) (Quit: Jesse)
[05:56:54] <dbaupp> strcat: but Rust's generics aren't as neat as Haskell's!
[05:57:01] <engla> sounds good. OptionIterator is implemented right then
[05:57:14] <strcat> you write all the Option combinators by-value, and then have fns for 'Option<T> -> Option<&mut T>' and 'Option<T> -> Option<&T>'
[05:57:14] *** Joins: fabiand (fabiand@moz-4459CD86.adsl.alicedsl.de)
[05:57:19] <engla> don't forget to impl laziness too
[05:57:19] <strcat> so get_ref, get_mut_ref
[05:57:28] <strcat> you just have 'get', doing what unwrap does
[05:57:32] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[05:57:45] *** Quits: Shaladdle (anonymous@moz-424BC304.hsd1.pa.comcast.net) (Ping timeout)
[05:57:46] <strcat> and to_imm/to_mut or whatever they get called
[05:57:53] <strcat> + remove map by ref, chain by ref, etc.
[05:58:10] <strcat> (essentially what std::iter does, but spread across the stdlib :P)
[05:59:27] *** Quits: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP) (Ping timeout)
[06:00:08] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[06:01:56] <ww> ok, i've cleaned up the usage of ~.  The only uses of it are ~[] and ~str.  It still looks busy, especially on nested [] and str, like ~[~[~str]]
[06:02:35] <dbaupp> nice!
[06:02:36] <ww> if the language can be modified to remove the need for ~ for [] and str, it would clean up the language greatly.  [] and str are probably the most used feature
[06:02:49] <strcat> ww: might be able to migrate from nested unique vectors too
[06:03:01] <dbaupp> strcat: to?
[06:03:21] <strcat> iterators, slices, matrices for 2D grids
[06:03:31] <ww> flattening nested vec?  what's the trick?
[06:03:41] *** Joins: ercxx__ (ercan@moz-7CFF3469.dyn.optonline.net)
[06:03:47] <strcat> where are you using it? can you make an iterator yielding stuff instead?
[06:03:50] <strcat> or receive an iteratotr
[06:04:24] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[06:04:43] <ww> i'm using it on getting a list of list of structs
[06:04:50] *** Joins: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP)
[06:05:24] <ww> e.g. i query the stats of N servers.  each server returns a list of stats.  the result of all servers is ~[~[Stat]]
[06:05:49] <strcat> ww: you can make an iterator yielding stats over N servers
[06:05:57] <strcat> removing the need for the outermost one
[06:06:21] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[06:06:21] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/zTma5w
[06:06:21] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[06:06:22] <strcat> not that this is a great use case for it since you probably won't stop early and the I/O is the expensive part, but it's a good example ;p
[06:06:31] <ww> i see
[06:06:36] *** Joins: bheylin_ (brianheyli@moz-8255E94E.adsl.online.nl)
[06:06:56] <ww> i might do it async and in parallel later on.
[06:07:25] <ww> i'll think about how to simplify the structure list
[06:11:20] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[06:11:20] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/whUieQ
[06:11:20] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[06:11:21] *** Quits: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP) (Ping timeout)
[06:11:21] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[06:11:21] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/u-RLog
[06:11:21] <ghrust> 13rust/06auto 14d12e030 15Daniel Micay: clarify vector stub in the container tutorial...
[06:11:21] <ghrust> 13rust/06auto 14bf0e2a6 15blake2-ppc: doc: Update container tutorial with new names of methods and macros...
[06:11:22] <ghrust> 13rust/06auto 14f0630fd 15blake2-ppc: doc: Fix the tutorial's link to rustpkg docs
[06:11:24] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[06:11:51] <acrichto> olsonjeffery: ping
[06:12:00] <olsonjeffery> acrichto: sup
[06:12:03] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Client exited)
[06:12:06] <acrichto> http://www.contrib.andrew.cmu.edu/~acrichto/doc/std/rt/io/file/index.html
[06:12:14] <acrichto> there seem to be some stray functions
[06:12:25] <acrichto> that should be test functions but aren't flagged as such
[06:12:27] *** Joins: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP)
[06:12:41] <olsonjeffery> yeah :/
[06:12:54] <olsonjeffery> it's how i dev, usually
[06:13:08] <olsonjeffery> i got really sick of builds failing in the test-bin build phase
[06:13:14] <acrichto> oh ok, just wanted to make sure you were aware of it :)
[06:13:14] <olsonjeffery> so i forgot to fix those.
[06:13:17] <acrichto> lol
[06:13:20] <acrichto> yeah it is kinda unfortunate...
[06:13:27] <acrichto> I've started writing tests in separate files
[06:13:33] <acrichto> and using the stage1 compiler to compile them
[06:13:37] <acrichto> then merge afterwards
[06:13:55] <acrichto> http://www.contrib.andrew.cmu.edu/~acrichto/doc/std/rt/io/file/fn.open.html
[06:13:56] <Luqman> olsonjeffery: you probably want to mark those #[cfg(test)] if you only use them in a test
[06:14:02] <bjz> acrichto: hoy hoy
[06:14:03] <acrichto> olsonjeffery: now those are some good looking docs
[06:14:12] <acrichto> Seldaek cmr: nice jobs!
[06:14:37] * strcat really doesn't like conditions for stuff like that ;[
[06:15:01] * dbaupp wonders if it's worth splitting out the mod tests into test.rs files and having non-check targets not depend on them
[06:15:23] <olsonjeffery> Luqman: yeah. i mentioned that i forgot to clean them up. i know what i did wrong ;P
[06:15:24] <acrichto> dbaupp: we could trip tests in a later phase, but it's just more stuff to compile :(
[06:15:46] <bjz> acrichto: was wondering how I would implement the fmt traits for this: https://github.com/bjz/cgmath-rs/blob/master/src/cgmath/vector.rs#L297
[06:15:56] <Luqman> olsonjeffery: oops, reading is hard :P
[06:16:17] <strcat> need really short names for imm/mut refs
[06:16:17] <bjz> acrichto: like fmt::Float and fmt::Int
[06:16:23] <olsonjeffery> it's just a pain point in the code->build->test cycle
[06:16:28] <strcat> to_imm/to_mut are okay but... not clear that they mean refs ;[
[06:16:32] <acrichto> bjz: you just need to implement the traits, and write to fmt.buf
[06:16:33] <dbaupp> bjz: write!(w, "[{}, {}, {}, {}]", self.x, ... ) where `w` is the Writer that the method recieves
[06:16:44] <bjz> ahh
[06:16:46] <dbaupp> (err, w == fmt.buf)
[06:17:04] <olsonjeffery> hm
[06:17:07] <bjz> dbaupp: how do I transfer the precision to it, like with the Float trait
[06:17:12] <acrichto> all the rustdoc_ng html formatting code *heavily* uses the new formatting systems
[06:17:13] <olsonjeffery> acrichto: FileInfo looks jacked-up :/
[06:17:29] <olsonjeffery> i was following the bulleted-examples stlye as it appears in std::rt::io
[06:17:34] <olsonjeffery> guess it doesn't work..
[06:17:56] <dbaupp> bjz: the optimal technique is asking acrichto. :P
[06:17:56] <acrichto> olsonjeffery: huh
[06:18:11] <bjz> acrichto: howwww? :3
[06:18:13] <olsonjeffery> also it's weird how headers in function docs kind of look more like section seperators than the actual separators (the function sigs)
[06:18:14] <acrichto> bjz: I also recomment http://www.contrib.andrew.cmu.edu/~acrichto/doc/std/fmt/ :)
[06:18:15] <olsonjeffery> i noticed that before
[06:18:26] <olsonjeffery> more of a styling issue for cmr and Seldaek to sort..
[06:18:42] <acrichto> olsonjeffery: I've found "~~~{.rust}\n code ... \n ~~~" to be the most reliable method of documenting code blocks
[06:18:52] * olsonjeffery nods
[06:19:26] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[06:19:39] <bjz> acrichto: how do I transfer the precision?
[06:19:39] <Luqman> now, to figure out why windows fails. at least i've got a build system set up somewhere
[06:19:48] <olsonjeffery> std::rt::io's docs need work
[06:19:51] <acrichto> bjz: it's in the Formatter struct
[06:19:57] <olsonjeffery> it's basically all just the theoretical pitch document
[06:20:01] <bjz> acrichto: like into write!(w, "[{}, {}, {}, {}]", self.x, ... )
[06:20:05] <strcat> https://github.com/mozilla/rust/issues/9355
[06:20:08] <acrichto> bjz: http://www.contrib.andrew.cmu.edu/~acrichto/doc/std/fmt/struct.Formatter.html
[06:20:11] <strcat> anyway going to do it, and make a PR
[06:20:15] <strcat> will see what people think ;p
[06:20:22] <acrichto> bjz: oh format!("{:precision}")
[06:20:23] * strcat feels pretty strongly about this stuff though
[06:20:29] *** nrc is now known as nrc|afk
[06:20:36] <strcat> composition >>>>>> large APIs
[06:21:33] <bjz> acrichto: would I do fn fmt(f: &Vec4<S>, fmt: &mut Formatter) { write!(w, "[{f:precision}, {f:precision}, {f:precision}, {f:precision}]", self.x, ... ) }
[06:21:35] <engla>  yeah but, Option is used all over the place. it needs some sugar
[06:21:40] <strcat> engla: it is sugary
[06:21:47] <strcat> foo.unwrap() becomes foo.get()
[06:21:55] <strcat> foo.get_mut_ref() becomes foo.to_mut().get()
[06:21:56] <bjz> acrichto: oh wait
[06:22:05] <strcat> (although you mostly use by-value)
[06:22:08] <acrichto> bjz: if you want to transfer precision you'd probably want to call Float::fmt directly
[06:22:23] <strcat> engla: map_move becomes map
[06:22:29] *** Quits: bheylin_ (brianheyli@moz-8255E94E.adsl.online.nl) (Quit: bheylin_)
[06:22:30] <strcat> map becomes to_ref().map()
[06:22:36] <strcat> etc.
[06:22:43] <engla> strcat: doesn't sound so bad
[06:22:49] <strcat> complete API gets more than 3x smaller
[06:22:50] <dbaupp> (to_ref/to_mut would be as_ref/as_mut)
[06:22:55] *** Joins: bheylin_ (brianheyli@moz-8255E94E.adsl.online.nl)
[06:22:59] <engla> strcat: take_unwrap() becomes .take().unwrap()?
[06:23:02] <strcat> dbaupp: or as_imm
[06:23:02] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[06:23:04] <olsonjeffery> i like strcat's idea because it feels like an actual, non-contrived and novel use of lifetimes
[06:23:30] <dbaupp> strcat: yeah, something like that (the key point is 'as'. :) )
[06:23:31] <strcat> engla: well, take().get()
[06:23:37] *** Joins: MrOrdinaire (Mibbit@1A659656.A607747.FD383126.IP)
[06:23:42] *** Quits: bheylin_ (brianheyli@moz-8255E94E.adsl.online.nl) (Quit: bheylin_)
[06:23:42] <engla> right.. readings skills
[06:23:50] *** Quits: myname (myname@F6BC1CBC.2C5F047.A0197E77.IP) (Ping timeout)
[06:23:56] <bjz> acrichto: would I do fn fmt(f: &Vec4<S>, fmt: &mut Formatter) { write!(w, "["); Float::fmt(&self.x, fmt); write!(w, ", "); Float::fmt(&self.y, fmt); ... } ?
[06:23:56] <engla> it reads well, I'll still complain about typing ()
[06:24:09] <bjz> acrichto: where would w come from?
[06:24:22] <strcat> engla: yeah but small, composable APIs are really nie
[06:24:23] <strcat> nice*
[06:24:37] <acrichto> bjz: w == fmt.buf
[06:24:40] <strcat> and we'll never have to hear that rust's pointer types make it impossible to write code as generic as it could be
[06:24:44] <acrichto> bjz: otherwise yes
[06:24:50] <strcat> pointers == values, generics can all be defined on values ;p
[06:25:01] <olsonjeffery> strcat: BUT BUT HASKELL IS BETTERRRRRRRRRRRRRRRRR
[06:25:16] <bjz> acrichto: fn fmt(f: &Vec4<S>, fmt: &mut Formatter) { write!(fmt.buf, "["); Float::fmt(&self.x, fmt); write!(fmt.buf, ", "); Float::fmt(&self.y, fmt); ... }
[06:25:22] <bjz> acrichto: sorry
[06:25:38] <acrichto> bjz: yeah that should work
[06:25:45] <bjz> acrichto: would be nice to have a more complex example like that
[06:25:50] <dbaupp> bjz/acrichto: won't that move fmt?
[06:25:58] <acrichto> bjz: you mean in the docs/
[06:25:59] <acrichto> ?
[06:26:04] <bjz> acrichto: yep
[06:26:07] <acrichto> dbaupp: nah it's &mut
[06:26:24] <dbaupp> acrichto: yeah... or does it get reborrowed more easily now?
[06:26:26] <olsonjeffery> strcat: think you could take that to its logical conclusion and forbid ptr types in generic parameters? maybe have a magical compiler trait as the only place you can impl to_ref, to_mut_ref, etc ?
[06:26:32] <acrichto> dbaupp: thankfully yes :)
[06:26:32] * dbaupp thought &mut moved by default.
[06:26:36] <dbaupp> acrichto: cool
[06:26:36] *** Joins: sglez (Mibbit@E19C1D7A.4B605195.A208C5.IP)
[06:26:37] <strcat> olsonjeffery: they're still useful, sometimes
[06:27:11] <bjz> acrichto: I looked at the impls of things in the std::fmt::mod, but they were for the built-in types.
[06:27:14] *** Joins: myname (myname@F6BC1CBC.2C5F047.A0197E77.IP)
[06:27:22] <bjz> acrichto: but yeah awesome work anyway
[06:27:37] <acrichto> bjz: thanks :) perhaps this rustdoc_ng stuff will help a lot
[06:27:43] <strcat> olsonjeffery: my point is mostly that references aren't special - they're values, and you can treat them that way
[06:27:47] <strcat> sometimes you semantically need a reference
[06:28:43] <strcat> this will be a huge patch :p
[06:29:45] *** Quits: jeaye (Jeaye@moz-34FEF2BB.hsd1.ca.comcast.net) (Quit: zzz)
[06:30:49] * engla realized as I complained about () that I wrote them with a near-instant smattering of fingers
[06:31:00] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[06:32:57] *** kimundi is now known as zz_kimundi
[06:34:34] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[06:35:04] <olsonjeffery> is ~mut allowed?
[06:35:07] <strcat> no
[06:35:13] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[06:35:19] <olsonjeffery> wouldn't it be needed to move @ out of the compiler and into a library?
[06:35:33] *** Quits: hoverbear (andrew@moz-86FCBF4B.gv.shawcable.net) (Quit: hoverbear)
[06:35:39] <strcat> olsonjeffery: no, there's RcMut already
[06:35:46] <bjz> acrichto: do you think to_str will go away?
[06:35:56] <strcat> olsonjeffery: but RcMut and GcMut can really just be Rc<Mut<T>> and Gc<Mut<T>>
[06:36:03] <strcat> you can factor out the concept of dynamic borrowck
[06:36:18] <strcat> and encourage making it per-field rather than the whole box
[06:36:22] <acrichto> bjz: it's not clear to me that it will
[06:36:41] *** Quits: aeqwa (aeqwa@moz-ABA21D72.dsl.tropolys.de) (Ping timeout)
[06:36:42] <strcat> (depends on the use case, but on the whole box is very coarse)
[06:36:43] <dbaupp> with Mut, ~Mut<T> would be valid, but would be very very similar to Mut<~T> or just plain Mut<T>.
[06:36:44] * bjz wishes we had trait specialisation
[06:36:56] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[06:37:29] *** Joins: NiccosSystem (NiccosSyst@AB1AFDE.FC7B0C35.A7597CB6.IP)
[06:38:09] <dbaupp> acrichto: I think we should replace ToStr with Default, and have a to_str default method that calls just calls `write!(memory writer, "{}", *self)`
[06:38:49] <bjz> dbaupp: I wish we could to that by default, then specialise it if necessary
[06:39:05] <strcat> oh well libstd compiles
[06:39:07] <strcat> now for tests
[06:39:16] * strcat will do the rest of the stdlib after finishing the API
[06:39:24] <strcat> and evil librustc ;p
[06:39:30] <dbaupp> bjz: default methods \o/
[06:39:38] *** Joins: GeneralMaximus (ankur@26BD2F6D.6DB2D147.BE90E62C.IP)
[06:39:41] <Eridius> strcat: what are you doing?
[06:39:45] <strcat> Eridius: https://github.com/mozilla/rust/issues/9355
[06:39:49] *** Quits: nejucomo (Adium@moz-434492BB.dsl.static.sonic.net) (Quit: Leaving.)
[06:39:57] *** zz_kimundi is now known as kimundi
[06:39:58] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[06:40:00] *** Joins: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[06:40:14] *** Quits: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca) (Connection reset by peer)
[06:40:18] <Eridius> strcat: was there any consensus on that issue about standardizing naming?
[06:40:20] *** Quits: tikue_ (tkuehn@787D2D52.F3E8A984.689607DE.IP) (Quit: tikue_)
[06:40:27] <strcat> Eridius: not really. 
[06:40:35] <strcat> I'm removing 2/3 of them, saving us from having to name them ;p
[06:40:50] <Eridius> yeah.. but I'm a bit leery about you renaming unwrap() to get() without consensus
[06:41:00] <strcat> Eridius: it doesn't move
[06:41:06] <Eridius> ?
[06:41:07] <bjz_> dbaupp: but impl _ for T kills everything
[06:41:19] <strcat> Eridius: it's called get_ref and get_mut_ref
[06:41:28] <strcat> and those names weren't going to change
[06:41:31] <dbaupp> bjz_: hm?
[06:41:48] <Eridius> strcat: yeah, but from what I recall in the naming issue some people thought .get() should be the name of .get_ref()
[06:41:55] <strcat> Eridius: there will be no get_ref
[06:41:55] <Eridius> i.e. that .get() wouldn't move
[06:42:00] <strcat> get doesn't move
[06:42:02] <strcat> by-value != move
[06:42:04] <bjz_> dbaupp: you can't specialise after impl for T
[06:42:18] <Eridius> strcat: I'm confused. .unwrap() right now consumes the option and returns the underlying value
[06:42:19] <dbaupp> bjz_: this would be mod fmt { trait Default { fn fmt(&self, ...); fn to_str(&self) -> ~str { format!("{}", *self) } }
[06:42:21] <Eridius> how is that not moving?
[06:42:23] <engla> strcat: how is it not a move?
[06:42:24] <strcat> Eridius: no, it doesn't consume
[06:42:37] <strcat> rusti: let x = Some(5); let y = x.unwrap(); (x, y)
[06:42:38] -rusti- (Some(5), 5)
[06:42:39] <Eridius> rusti: let x = Some(3); let y = x.unwrap(); x
[06:42:40] <strcat> where's the move?
[06:42:40] -rusti- <anon>:7:30: 7:31 warning: unused variable: `y` [-W unused-variable (default)]
[06:42:40] -rusti- <anon>:7          let x = Some(3); let y = x.unwrap(); x
[06:42:40] -rusti-                                        ^
[06:42:40] -rusti- Some(3)
[06:42:54] <engla> implicit copy gets in the way
[06:42:57] <strcat> by-value only steals ownership if it has a destructor
[06:43:00] <Eridius> rusti: let x = Some(~3); let _ = x.unwrap(); x
[06:43:02] -rusti- pastebinned 8 lines of output: http://sprunge.us/ffeR
[06:43:07] <Eridius> there we go, a move
[06:43:10] <bjz_> dbaupp: you get a conflict, even if the impled type is more specific
[06:43:18] <strcat> Eridius: unwrap != moving though
[06:43:19] <strcat> it's by-value
[06:43:22] <dbaupp> bjz_: huh?
[06:43:30] <Eridius> strcat: you seem to have a weird definition of "moving", if .unwrap() doesn't move
[06:43:35] <strcat> Eridius: it's by-value
[06:43:42] <strcat> by-value moves ownership in a subset of cases
[06:43:48] <strcat> certainly is never going to move for &T
[06:43:48] <dbaupp> bjz_: Default isn't a generically implemented trait
[06:43:53] <Eridius> right. it consumes its receiver. It moves. The error in the above rusti specifically says "moved value", which means the compiler certainly thinks it was moved
[06:44:04] <Eridius> it only doesn't destroy its receiver if its receiver is implicitly copyable
[06:44:05] <engla> I prefer the naming of unwrap, since it can fail "get" is too generic.
[06:44:05] <strcat> rusti: let x = Some(5); let y = x.unwrap(); (x, y)
[06:44:05] -rusti- (Some(5), 5)
[06:44:09] <bjz_> dbaupp: we're talking about ToStr though
[06:44:16] <Eridius> engla: I agree with that point very much
[06:44:19] <dbaupp> bjz_: I'm talking about merging ToStr and Default
[06:44:25] <Eridius> strcat: yes you said that, but the option is being implicitly copied there
[06:44:29] <dbaupp> bjz_: so taht to_str is a default method on Default
[06:44:29] <bjz_> oh
[06:44:33] <strcat> Eridius: which is how by-value works
[06:44:36] <Eridius> if a method takes self instead of &self, it consumes
[06:44:37] <strcat> it is a shallow copy
[06:44:40] <Eridius> that's what "consumes" means
[06:44:45] <strcat> Eridius: no... it does not 'consume'
[06:44:53] <strcat> "implicit copy" is *not* an exception
[06:45:01] <olsonjeffery> consume would mean subsequent access fails...
[06:45:04] <Eridius> strcat: ok, demonstrate what _does_ consume then
[06:45:10] <Eridius> olsonjeffery: it does, if the type isn't implicitly copyable
[06:45:23] <strcat> Eridius: rust doesn't have std::move, there is no explicit consuming
[06:45:35] <strcat> Eridius: yes and implicit copyable types are *not the exception*
[06:45:37] <engla> std::util::ignore consumes too
[06:45:38] <Eridius> strcat: in common parlance, "consumes" means that the method takes its receiver (or an argument) by-value
[06:45:51] <strcat> Eridius: rust doesn't have "by-reference"
[06:45:54] <Eridius> similarly that's what people mean when they say the method moves
[06:45:57] <strcat> taking an &int parameter is taking an &int by-value
[06:46:02] <strcat> rust has no special by-reference
[06:46:17] <strcat> thinking we have by-reference is why this API is 3x larger than it has to be
[06:46:20] <Eridius> strcat: I don't know why you keep arguing against people saying "moves" or "consumes" for a by-value receiver/argument. You know damn well what they're saying, and by arguing against it you just confuse people
[06:46:31] <strcat> you're going to confuse people by calling by-value a move
[06:46:36] <strcat> borrowed pointers are plain old values
[06:46:41] <strcat> they don't become special in function parameters
[06:46:50] <strcat> &int can be used as a by-value T parameter
[06:46:55] <Eridius> strcat: feel free to suggest the terminology "by-value". Just stop saying "it doesn't move/consume", since that's not what you're actually trying to tell people
[06:47:04] <strcat> it is what I'm trying to tell people
[06:47:08] <Eridius> when you say "it doesn't consume" people _think_ you're saying it doesn't take the receiver by-value
[06:47:16] <strcat> I'm saying it takes it by-value
[06:47:22] <strcat> that's not consuming
[06:47:28] <strcat> rust passes all types by-value
[06:47:30] <Eridius> basically, you're arguing against terminology and people think you're arguing against their conceptual understanding (which is already correct)
[06:47:38] <engla> but rust also can move all values
[06:48:06] <Eridius> strcat: I am all for your crusade to clarify terminology. I'm just confused every time you say "it doesn't consume/move"
[06:48:09] <strcat> let x = 5; let y = x; isn't a move
[06:48:19] <strcat> a move means ownership was moved
[06:48:21] <strcat> ownership was not moved
[06:49:20] <strcat> ownership is only moved when there's a destructor, &fn or &mut
[06:49:25] <strcat> by-value is the accurate term
[06:49:49] <Eridius> strcat: yes, that's fine. I'm just saying you need to watch what you say when you try and correct people
[06:50:04] <Eridius> because you're not making it clear that you're making a terminology argument instead of a conceptual/behavioral argument
[06:50:11] <strcat> it's not a terminology argument
[06:50:20] <strcat> let x = Some(5); x.unwrap() is not doing a move anywhere
[06:50:23] <strcat> ownership is not being moved
[06:50:36] <strcat> x still owns the value it owned before, and is still usable
[06:50:49] <Eridius> strcat: surely you understand what people mean when they say a method moves/consumes? They mean it takes its receiver by-value
[06:50:56] <Eridius> and you're not arguing that it doesn't take its receiver by-value
[06:51:17] <strcat> when they say it consumes, I assume they mean it takes a non-implicitly-copyable type by-value
[06:51:32] <strcat> unwrap doesn't - it's just by-value, and whether it consumes depends on the type
[06:52:00] <strcat> much like all the iterator adaptors
[06:52:37] <Eridius> engla: what's your name on GH?
[06:52:44] <engla> blake2-ppc
[06:54:08] *** Joins: anshin (anshin@CD85F10D.F21429E2.354459FA.IP)
[06:54:46] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[06:55:18] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[06:56:55] *** Quits: msingle (Thunderbir@moz-20675462.nrflva.fios.verizon.net) (Ping timeout)
[06:56:56] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[06:57:17] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[06:58:05] *** Quits: lahwran (lahwran@lahwran.net) (Input/output error)
[06:58:38] <engla> strcat: you'll be happy to see I suggested ".map_value" as the name for current Option::map_move in that option/container method naming issue :P
[06:58:52] *** Joins: Shaladdle (anonymous@moz-424BC304.hsd1.pa.comcast.net)
[06:59:07] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[06:59:07] <ghrust> 01[13rust01] 15huonw pushed 1 new commit to 06try: 02http://git.io/RIoNHA
[06:59:07] <ghrust> 13rust/06try 1457297a3 15Huon Wilson: Uncomment a test.
[06:59:07] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[06:59:18] <strcat> I've wanted to use naming like that for the iterator methods
[06:59:23] <strcat> values(), refs(), mut_refs()
[06:59:25] * strcat shrugs
[06:59:26] <dbaupp> acrichto, strcat: do I have to do anything to get try to build other than push?
[06:59:30] <strcat> I don't like debating naming
[06:59:35] *** Joins: lahwran (lahwran@lahwran.net)
[06:59:41] <strcat> dbaupp: not anymore
[06:59:44] <strcat> should just build
[06:59:52] *** Quits: lahwran (lahwran@lahwran.net) (Quit: ZNC - http://znc.in)
[07:00:00] <dbaupp> ok
[07:00:09] * dbaupp wills bsd to avoid an ICE.
[07:01:42] <olsonjeffery> ive had issues with llvm failing on try-win .. the build had to be poked, which i couldn't do
[07:05:03] *** Joins: jaen (jaen@moz-5144DFA7.neoplus.adsl.tpnet.pl)
[07:05:17] *** Quits: NiccosSystem (NiccosSyst@AB1AFDE.FC7B0C35.A7597CB6.IP) (Ping timeout)
[07:06:44] *** kimundi is now known as zz_kimundi
[07:07:14] <dbaupp> olsonjeffery: looks like try-mac is the unhappy one this time
[07:07:32] *** Quits: sglez (Mibbit@E19C1D7A.4B605195.A208C5.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[07:07:57] *** zz_kimundi is now known as kimundi
[07:09:44] <strcat> could be called 'from' too
[07:09:47] <strcat> doesn't really matter to me
[07:09:55] <strcat> from or from_some
[07:10:46] * strcat just wants it to be 3-4 letters so people don't complain about get_ref becoming too long this way
[07:12:25] *** Quits: geomyidae (quassel@DD6F7E3A.21468E9A.30200F38.IP) (Connection reset by peer)
[07:13:44] *** Joins: geomyidae (quassel@DD6F7E3A.21468E9A.30200F38.IP)
[07:13:46] *** Quits: geomyidae (quassel@DD6F7E3A.21468E9A.30200F38.IP) (Client exited)
[07:14:50] *** Joins: barosl (barosl@3DE683B6.E551553C.7544CABF.IP)
[07:15:32] *** Joins: tikue_ (tkuehn@moz-FEADCD38.hsd1.pa.comcast.net)
[07:15:38] <tikue_> strcat: i think this is a really great idea
[07:15:58] <strcat> it's sort of the same thing as std::iter
[07:16:29] <strcat> (which separates the algorithms from the iterator implementations)
[07:16:32] <tikue_> yes, i see that. you only choose once how it's used, when you call iter(), mut_iter() or move_iter()
[07:16:43] <tikue_> though, it's incongruous. since the basic case with iters is ref_iter()
[07:16:55] <strcat> well, for container iterators it's &T
[07:17:05] <strcat> but for I/O, range/count-family ones, etc. it's by-value
[07:17:16] <tikue_> ah, i did not know there was that distinction
[07:17:27] <strcat> tikue_: well there's not really a distinction
[07:17:51] <strcat> any iterator is just Iterator<A> as far as std::iter is concerned, except for the in-place reverse method
[07:17:56] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[07:17:59] <strcat> it requires Iterator<&mut A>
[07:18:34] <tikue_> i really hope your proposal gets support
[07:18:55] <tikue_> it'll be a very big change, but imo it's a good one
[07:19:36] *** Quits: anshin (anshin@CD85F10D.F21429E2.354459FA.IP) (Connection reset by peer)
[07:20:07] <jstoja> I'm so surprised by the amount of work behind Rust *__*
[07:20:16] <jstoja> It looks so crazy
[07:20:31] <tikue_> jstoja: what looks crazy? heh
[07:20:34] <engla> Yes it looks good, but I'm sincere with .unwrap()
[07:20:39] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Client exited)
[07:20:57] <jstoja> tikue_: the amount of tests for example !
[07:21:06] <strcat> I'm leaving it as unwrap for now
[07:21:10] <strcat> I don't want to bikeshed naming
[07:21:15] <strcat> I want to make the API smaller
[07:25:17] <bjz_> jstoja: it's been going since 2009
[07:25:52] <bjz_> jstoja: it's pretty incredible to see the evolution of the language
[07:27:28] <bjz_> jstoja: the biggest challenge it to pull it into something coherent, rather than a confused bundle of features, but they seem to have really done a great job f that over the last year or so
[07:27:53] <engla> why does the rust community love to say bikeshed so much /me doesn't get it
[07:28:24] <moot> avoidance of unnecessary argument in preference of rapid progress :)
[07:28:39] <strcat> engla: to differentiate semantics/features from naming/syntax/organization
[07:28:48] <bjz_> engla: http://en.wikipedia.org/wiki/Parkinson%27s_law_of_triviality
[07:28:53] <strcat> because the latter are what people like to argue about
[07:29:04] <bjz_> "Parkinson's law of triviality, also known as bikeshedding or the bicycle-shed example, is C. Northcote Parkinson's 1957 argument that organizations give disproportionate weight to trivial issues. Parkinson demonstrated this by contrasting the triviality of the cost of building a bike shed to an atomic reactor. The law has been applied to software development[1] and other activities."
[07:29:10] <strcat> really, no one seemed to mind as I came along with external iterators and destroyed the old paradigm
[07:29:13] <bjz_> :P
[07:29:15] <strcat> the only arguments were about for loop syntax
[07:29:15] <engla> I only argue about things that I consider important
[07:30:21] <olsonjeffery> pretty sure everyone does the same
[07:30:26] <Eridius> I think the problem is bad syntax for a good concept ends up being death by a thousand cuts when you actually try to use it
[07:30:37] * strcat happened to like 'for x in iterator {}' but stayed *completely* out of that decision
[07:30:47] <strcat> because I probably just like it as a python user.
[07:30:49] <bjz_> I do think syntax is important in terms of user interface design, but it is the final 20% of polish. Coherent semantics should be at the top of the list
[07:31:12] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[07:31:12] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/u-RLog
[07:31:12] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[07:31:28] <bjz_> strcat: I was opposed, but I've got used to it now. And I am convinced too - don't want to confuse it with closures.
[07:31:35] <dbaupp> strcat: it helped that the external iterators were very much better than internal ones
[07:31:43] <engla> right
[07:31:55] <strcat> dbaupp: well, when I talked about it at first people weren't very into it
[07:31:56] <bjz_> strcat: internal/vs external is an issue of semantics
[07:32:06] <strcat> so I just slipped it in... and showed it was clearly better
[07:32:14] <engla> you can stir it up to go nowhere if you lay it out for that, create a committee and off you go
[07:32:16] <bjz_> strcat: yep, you convinced me
[07:32:55] <moot> impl Writer for @Writer { <- from io.rs.  what exactly does this mean?  the impl for write() calls self.write - I don't quite follow.
[07:32:55] <bjz_> strcat: probably taught a great deal of the community about iterators in the process too
[07:32:56] <Eridius> bjz_: the problem with trying to do syntax separate from semantics is that doubles the amount of breaking changes
[07:32:59] <Eridius> better to get the syntax right the first time
[07:33:03] <dbaupp> strcat: proof is in the pudding, etc.
[07:33:09] <bjz_> Eridius: yeah, agreed
[07:33:09] <strcat> yeah
[07:33:41] <strcat> luckily most 'map' uses are already map_move
[07:33:41] <bjz_> Eridius: that's the advantage of using s-expressions as a base ;)
[07:33:49] <bjz_> Eridius: but I will stop there
[07:33:54] <strcat> and most ones actually using references are of 'Option<&T>' already...
[07:33:59] <strcat> so they get &&T
[07:34:38] <Eridius> bjz_: well you still have naming issues there
[07:34:56] *** flaper87|afk is now known as flaper87
[07:34:59] <bjz_> Eridius: that is true
[07:35:07] <olsonjeffery> flaper87: hey you were looking for me the other day?
[07:36:12] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[07:36:12] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/JCABqw
[07:36:12] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[07:36:15] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[07:36:15] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/FbR3bQ
[07:36:15] <ghrust> 13rust/06auto 14e2807a4 15Chris Morgan: Replace unreachable() calls with unreachable!()....
[07:36:15] <ghrust> 13rust/06auto 14e5fdc7d 15bors: auto merge of #9320 : chris-morgan/rust/unreachable-macro-part-two-of-two-containing-the-destruction-of-the-unreachable-function, r=alexcrichton...
[07:36:16] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[07:36:57] <moot> anyone familiar with impl Writer for @Writer from io.rs?
[07:37:09] <bjz_> Eridius: would be neat if you could have an s-expr language builder that allowed you to update the codebase automatically when you made invasive changes. dunno if Racket can do that. Then you could eventually create an efficient standalone compiler once the language was prototyped.
[07:37:26] * bjz_ is out of his depth though
[07:37:56] *** Quits: Shaladdle (anonymous@moz-424BC304.hsd1.pa.comcast.net) (Quit: Shaladdle)
[07:38:40] <dbaupp> moot: in what way?
[07:38:49] <bjz_> Eridius: just to be clear, s-exprs as a base, with a 'conventional' syntax overlayed
[07:39:34] <moot> dbaupp: why do you need such an impl?
[07:39:51] <Eridius> bjz_: could be interesting
[07:41:03] <strcat> oh and map_default
[07:41:08] <strcat> another 2 to kill
[07:41:13] <dbaupp> moot: because a trait object (i.e. @Writer) doesn't automatically implement it's own trait (i.e. Writer), and so it's needed to allow one to write foo<W: Writer>(w: W) and call it with @Writer
[07:42:04] <dbaupp> moot: however, this is a little moot (heh) since no-one ever uses std::io like that (always just @Writer), and the new io (std::rt::io) is much saner and uses generics more.
[07:42:47] <bjz_> Eridius: that was actually John McCarthy's original intent :P
[07:42:54] *** kimundi is now known as zz_kimundi
[07:43:22] <bjz_> Eridius: so I believe
[07:43:24] <strcat> engla: could also drop iter/move_iter/mut_iter and just have iter
[07:43:33] <strcat> although when there are iterable traits, they'd come back I guess
[07:43:43] <strcat> it's a good argument for not having iterable :s
[07:43:57] <engla> strcat: on option? yeah that sounds good
[07:44:52] <dbaupp> strcat: https://github.com/ktkaushik/rust/commit/2714e64d0c04a59c0df4aff6a9ae011f06ebe2e0#commitcomment-4139549
[07:45:03] <strcat> dbaupp: er
[07:45:05] <strcat> sorry
[07:45:09] * strcat hit it by accident
[07:45:22] <strcat> middle click paste I mean
[07:45:41] <strcat> and then I realized there are like 3 PRs to fix this
[07:45:42] <strcat> so...
[07:45:47] <dbaupp> don't think so
[07:45:53] <dbaupp> there's one that's wrong
[07:45:57] <dbaupp> and 3 to fix another link
[07:46:02] <strcat> :s
[07:46:08] <dbaupp> (one of which has landed, and the other 2 are closed)
[07:46:11] * strcat will leave it to dbaupp to solve
[07:46:15] <dbaupp> haha
[07:46:29] <dbaupp> (the one that landed was your PR with engla's patch :P )
[07:46:41] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[07:46:54] <strcat> yeah that's why I am so confused
[07:47:19] <engla> we won
[07:47:24] <engla> yess
[07:47:49] <dbaupp> strcat: wait... you reopened https://github.com/mozilla/rust/pull/9326
[07:47:53] * dbaupp is now confused too
[07:48:04] <strcat> dbaupp: because I saw they discussed it and decided it was okay
[07:48:04] <dbaupp> which links are meant to point where? :(
[07:48:11] <strcat> and got too confused and decided to let someone else deal with it
[07:48:21] <strcat> dbaupp: I think they should point at master atm
[07:48:37] <strcat> in theory they should point at the 0.8 docs inside the 0.8 release
[07:48:45] <dbaupp> right
[07:48:46] <strcat> when we have real releases, they'll be branched
[07:48:52] <strcat> in trunk it should always point at master
[07:49:01] <dbaupp> but the windows one should point at 0.7, since the installer is 0.7?
[07:49:07] <strcat> meh
[07:49:16] <strcat> should have a nightly installer, that's the real bug
[07:49:24] <strcat> ;p
[07:49:26] <dbaupp> yeah
[07:49:33] <strcat> these map_default ones are not very fun...
[07:49:41] <dbaupp> hm
[07:49:52] <dbaupp> why are we promoting the 0.7 tarball at all?
[07:50:18] <strcat> don't know
[07:50:18] <dbaupp> surely, since it requires building anyway, we should just point at trunk
[07:50:32] <strcat> right, I think you should close these 2 and make a new one
[07:50:39] <strcat> removing references to 0.7 and fixing the two links
[07:50:50] <strcat> (and any other broken ones ;p)
[07:50:57] <jesseray> I usually install Rust by doing ./configure && make && make install. However, I want to run the tests this time (because I added some). How would I do that?
[07:51:05] * dbaupp feels bad about stealing first contributions
[07:51:24] * flaper87 is back from the afk world
[07:51:25] <Eridius> jesseray: the full test suite is `make check`
[07:51:32] <jesseray> thanks =)
[07:51:35] <Eridius> jesseray: depending on what you changed, you might be able to get away with running smaller sets
[07:51:36] <dbaupp> is it possible to push to rust.wiki or do i need special permissions for that?
[07:51:58] <flaper87> olsonjeffery: yeah, sorry, I was traveling and didn't get a chance to ping you back
[07:52:24] <strcat> dbaupp: don't know
[07:52:26] <jesseray> I added std::char::is_control(): function, method, and tests.
[07:52:32] <dbaupp> strcat: it is
[07:52:41] <strcat> jesseray: btw can you make it a method?
[07:52:46] <strcat> rather than a free fn 
[07:52:50] *** Joins: tgummerer (tgummerer@moz-DEADF0AF.kthopen.kth.se)
[07:52:53] <dbaupp> (the reason I was getting rejected was because I don't know how to type my password, apparently. :S )
[07:52:55] <strcat> the existing ones are free functions due to legacy reasons
[07:53:02] <Eridius> jesseray: did you just add it in isolation, or are you using it anywhere?
[07:53:10] <strcat> (there was a time rust had no methods! :D)
[07:53:11] <Eridius> jesseray: if you just added it in isolation, `make check-stage1-std` is probably sufficient
[07:53:30] <Eridius> or maybe even `make check-stage1-std NO_REBUILD=1 NO_BENCH=1`
[07:53:52] <strcat> [option a2572fb] option: rewrite the API to use composition
[07:53:53] <strcat>  28 files changed, 134 insertions(+), 218 deletions(-)
[07:53:56] <strcat> so far...
[07:54:01] <dbaupp> strcat: no so bad
[07:54:03] <dbaupp> *not so bad
[07:54:09] <dbaupp> (and yay, deletions! \o/ )
[07:54:10] <strcat> well I'm just doing libstd atm
[07:54:49] <strcat> + tests
[07:54:51] <jesseray> I'm not sure what you mean by isolation.
[07:54:54] <jesseray> https://github.com/jesseray/rust/commits/master
[07:55:02] <jesseray> look at the last three commits there. Those are the changes I made.
[07:56:54] *** Quits: Ralith (ralith@moz-36466B9F.customer.broadstripe.net) (Ping timeout)
[07:58:48] *** Joins: Ralith (ralith@moz-36466B9F.customer.broadstripe.net)
[08:00:36] *** Quits: Ralith (ralith@moz-36466B9F.customer.broadstripe.net) (Ping timeout)
[08:00:52] <strcat> um
[08:01:09] <strcat> hrm
[08:01:27] *** Joins: victorporof (victorporo@D5C23157.DA9DCE7D.79933D60.IP)
[08:04:01] <jesseray> ?
[08:04:32] <strcat> jesseray: oh, not about that
[08:05:00] *** Joins: Ralith (ralith@moz-36466B9F.customer.broadstripe.net)
[08:05:01] <jesseray> ah
[08:05:11] <jesseray> (non-verbal communication FTW =P)
[08:05:57] <strcat> I manage to confuse people with verbal communication too, it's a talent
[08:06:35] * Eridius nods
[08:07:36] *** Quits: ross (ross@moz-5EA04060.br.br.cox.net) (Quit: )
[08:11:00] <strcat> dbaupp: https://github.com/thestinger/rust/commit/a173709fd419690654a9b1f3b38bb7ef6054aaff so far.
[08:15:00] <dbaupp> strcat: cool
[08:16:26] *** zz_kimundi is now known as kimundi
[08:17:25] *** Joins: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP)
[08:18:57] *** Quits: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP) (Quit: Lost terminal)
[08:20:33] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[08:24:59] <mark_edward_> is everyone here australian or just night owls
[08:25:07] *** Joins: CarpNet (ac@moz-FD24B77.sohonet.co.uk)
[08:26:18] *** Quits: Ralith (ralith@moz-36466B9F.customer.broadstripe.net) (Quit: leaving)
[08:26:20] *** Joins: Ralith (ralith@moz-36466B9F.customer.broadstripe.net)
[08:26:28] <Eridius> night owl here
[08:26:35] <dbaupp> mark_edward_: there's some NZers and koreans too.
[08:26:41] <kimundi> strcat: Hm, could map_default get renamed to map_or? Would fit in more with recent renamings, and 'default' can be confused with the Default trait
[08:27:00] <dbaupp> kimundi: later changes?
[08:27:02] <strcat> kimundi: it could
[08:27:06] <strcat> but yeah
[08:27:08] <strcat> later
[08:27:12] <mark_edward_> dbaupp: ah i see. it's cool that Rust is international. can we get support for full unicode identifiers?
[08:27:21] <strcat> we have unicode identifiers
[08:27:26] <dbaupp> rusti: let Ã¤Ã¶Ã¥ = 1; Ã¤Ã¶Ã¥
[08:27:27] -rusti- 1
[08:27:36] <Eridius> mark_edward_: identifiers use the XID classes
[08:27:36] <dbaupp> mark_edward_: yes
[08:27:41] <strcat> XID_Start + *XID_Continue
[08:27:56] <kimundi> dbaupp, strcat: Sure no rush, I just saw a it being moved around in the diff, so I mentioned it now :)
[08:28:18] <mark_edward_> oh cool. so like ppl in korea can have korean variable names! that's good. i always feel bad for non-english speaking programmers
[08:28:59] <mark_edward_> can we get question marks for function names? i miss that from racket
[08:29:04] <mark_edward_> hyphens too
[08:29:14] <dbaupp> unicode hyphens?
[08:29:18] <Eridius> hyphen is the subtraction operator
[08:29:20] <dbaupp> or ascii dashes
[08:29:21] <dbaupp> ?
[08:29:26] <Eridius> foo-bar() == foo - bar()
[08:29:29] <mark_edward_> i don't know
[08:29:37] <Eridius> I think a unicode hyphen might be too confusing with dash
[08:29:48] <mark_edward_> but in lisps you can ahve function names be hyphenated
[08:29:48] <strcat> I think we should just stick to XID classes
[08:30:02] * kimundi needs to find out how to make his x keyboard layout switchable under i3...
[08:30:03] <dbaupp> strcat++
[08:30:10] <Eridius> mark_edward_: lisps doesn't have operators
[08:30:23] <mark_edward_> justthink, instead of is_some() some?()!!! so semantics!
[08:30:32] <mark_edward_> Eridius: what do you mean
[08:30:51] <Eridius> mark_edward_: (foo-bar baz) is distinct from (foo - bar baz) in a lisp
[08:30:58] <Eridius> but it's not in a language like rust that has normal infix operators
[08:31:06] <mark_edward_> oh right
[08:32:11] * kimundi is in favour for accepting any invalid character sequence as 'Alien Tokens', only processable by macros.
[08:32:25] <dbaupp> kimundi++
[08:32:35] <Eridius> karma!(kimundi++)
[08:32:39] <tikue_> ? would be cool
[08:32:44] *** Quits: MrOrdinaire (Mibbit@1A659656.A607747.FD383126.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[08:32:44] <tikue_> its' not used for anything is it
[08:32:46] <dbaupp> c!(x ? foo : bar)
[08:33:10] <Eridius> adopting ? for function names precludes ever using it for an operator in the future
[08:33:27] <mark_edward_> what on earth would a ? operator do?
[08:33:37] <Eridius> besides ternary? Not sure
[08:33:54] <tikue_> ternary would be redundant with if exprs
[08:34:00] <Eridius> yeah
[08:34:04] <strcat> rust used to have the ternary operator
[08:34:05] <strcat> was removed
[08:34:11] <tikue_> rust is a smart guy
[08:34:48] <strcat> dbaupp: yay, rvalue bug
[08:34:51] <strcat> "bug"
[08:34:53] <strcat> ;p
[08:35:03] <mark_edward_> ? should be unary, and return the type of a thing
[08:35:32] <mark_edward_> let x: int = 5; let y:x? = 1;
[08:36:12] <Eridius> clearly ? should be a postfix operator that prints the value's repr to stdout
[08:36:18] <Eridius> let x: int = 5; x?
[08:36:21] <strcat> mark_edward_: reflection won't be in the language like that
[08:36:38] <mark_edward_> not reflection, it'd be compile time
[08:36:49] <mark_edward_> like C++ decltype(0
[08:36:50] <mark_edward_> )
[08:36:50] <tikue_> i think ? should reverse the order of arguments
[08:36:58] <tikue_> |x| x + 1 ? spawn
[08:37:28] <strcat> mark_edward_: what about for an expr like 1 + 1 then?
[08:37:33] <strcat> ?(1 + 1) :\
[08:37:48] <mark_edward_> well doesn't that have type int ?
[08:37:54] <strcat> I mean the syntax
[08:38:05] <mark_edward_> oh i see
[08:38:33] <mark_edward_> maybe two ?s! ? {expr} ? gives the type of the contained expr!
[08:39:11] <mark_edward_> i dunno, i just like question marks
[08:39:29] <Eridius> if you type a ?, clippy shows up and asks if you need help writing your program
[08:39:42] *** Joins: brendan (brendaneic@45A3491F.A5FB4ABA.FE58E87C.IP)
[08:39:46] <mark_edward_> i always like it when i raise my hand in class and teachers say "Question, Mark"?
[08:39:51] *** Joins: [squiddy] (squiddy@moz-65EF4614.adsl.alicedsl.de)
[08:39:52] <kimundi> The horror, THE HORROR!
[08:39:55] <mark_edward_> good times
[08:40:14] <tikue_> mark_edward: clearly you have an agenda
[08:40:14] <kimundi> mark_edward_: he
[08:40:45] <mark_edward_> tikue_: yes it's true, i'm horribly biased
[08:41:58] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[08:43:43] <tikue_> rusti: let ? = "?"; ?
[08:43:44] -rusti- <anon>:7:13: 7:14 error: unknown start of token: ?
[08:43:44] -rusti- <anon>:7          let ? = "?"; ?
[08:43:44] -rusti-                       ^
[08:43:44] -rusti- application terminated with error code 101
[08:44:19] *** Joins: MrOrdinaire (Mibbit@5C68C0A1.6BCC7DAD.FD383126.IP)
[08:44:41] <mark_edward_> rusti: let # = "#"; #
[08:44:42] -rusti- <anon>:7:13: 7:14 error: unexpected token: `#`
[08:44:42] -rusti- <anon>:7          let # = "#"; #
[08:44:42] -rusti-                       ^
[08:44:42] -rusti- application terminated with error code 101
[08:45:23] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[08:45:46] <mark_edward_> is there a way to stringify code? like get `let x:Foo = Foo::new()` as  astring?
[08:46:01] <strcat> stringify!
[08:46:47] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: sleep)
[08:46:49] <mark_edward_> oh, well duh! are macros controllable through pub/priv and suc?
[08:46:57] <kimundi> mark_edward_: Not yet
[08:47:16] <mark_edward_> but they're supposed to be eventually? will they show up in rustdoc?
[08:47:44] <kimundi> mark_edward_: The compiler currently handles macros a few phases before he looks at stuff like import/exports
[08:48:07] <kimundi> mark_edward_: It's certainly the longterm goal, but it might not make it into 1.0
[08:48:16] <mark_edward_> ah, ok
[08:48:17] <Eridius> kimundi: that would be sad
[08:48:29] *** Quits: [squiddy] (squiddy@moz-65EF4614.adsl.alicedsl.de) (Ping timeout)
[08:48:35] <mark_edward_> what's that paper that rust based it's macros on?
[08:48:39] <kimundi> Eridius: Indeed it would, but there are only so many people who can work on this
[08:48:46] *** Joins: nkoep (nik@moz-77021FC6.pool.mediaways.net)
[08:48:56] <mark_edward_> Macros that Work Together or something?
[08:49:43] *** Quits: tikue_ (tkuehn@moz-FEADCD38.hsd1.pa.comcast.net) (Quit: tikue_)
[08:50:13] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[08:50:19] *** Quits: brendan (brendaneic@45A3491F.A5FB4ABA.FE58E87C.IP) (Quit: brendan)
[08:56:12] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[08:56:12] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/FbR3bQ
[08:56:12] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[08:56:46] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[09:00:38] *** Joins: lahwran (lahwran@lahwran.net)
[09:01:13] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[09:01:14] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/wiEmOA
[09:01:14] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[09:01:14] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[09:01:15] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/ce5czQ
[09:01:15] <ghrust> 13rust/06auto 14d9874c0 15Chris Morgan: Rename the NaN and is_NaN methods to lowercase....
[09:01:15] <ghrust> 13rust/06auto 14ccb80ab 15bors: auto merge of #9321 : chris-morgan/rust/lowercase-nan-methods, r=brson...
[09:01:15] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[09:02:51] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[09:04:39] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[09:04:52] *** Joins: [squiddy] (squiddy@moz-CE21F9D6.adsl.alicedsl.de)
[09:04:57] *** Joins: z0w0 (zack@64F0E14B.3C29B4A9.2CE63F58.IP)
[09:06:15] <Luqman> welp, wasted all time building on the wrong branch
[09:07:24] <ww> does rust have zip file support?
[09:07:57] <kimundi> ww probably not in std or extra right no
[09:08:51] <ww> ok, when i got the chance, i can write one for it
[09:09:05] <ww> how regex support?
[09:09:16] <ww> how about^
[09:09:41] <kimundi> nope also not yet. However, regex we might actualy want to become a part of the stdlib/extra
[09:10:11] <ww> ok
[09:33:32] <afrey71> Can I return a borrowed pointer within a code block *before* it ends?
[09:33:54] <afrey71> I.e. return an immutable one so as to get a mutable one?
[09:34:30] <kimundi> afrey71: You mean, no longer use it so that you can rebowwor the source as mutable?
[09:34:46] <afrey71> kimundi: exactly
[09:35:21] <kimundi> afrey71: You can certainly force that by introducing additional scopes with {} blocks
[09:35:52] <kimundi> let x = foo; { let imm = &x; ... } let mutbl = &mut x;
[09:35:55] <afrey71> Well, that doesn't work for a loop in loop (i.e. iterating over a vec twice, for O(n**2) algos).
[09:36:20] <afrey71> Hm.. maybe I can rewrite it to use iterators...
[09:36:22] <kimundi> afrey71: Could you post an exampkle of what doesn't work?
[09:36:52] <kimundi> If you can express it with iterators, you can also express it as a bare loop
[09:38:06] <afrey71> Essentially, I'm trying somethink like: http://pastebin.com/XSspVdEd
[09:38:36] <kimundi> okay THAT you can't do either way
[09:38:47] <kimundi> Iterator invalidation etc
[09:38:59] <afrey71> iterator invalidation?
[09:39:06] <kimundi> can't mutate v while immutable borrowing v
[09:39:19] <afrey71> Right, that's exactly what bothers me.
[09:39:36] <afrey71> Turning the outer loop into a mut_iter() doesn't help, either, because you cannot borrow mutable, twice.
[09:39:42] <kimundi> afrey71: if the inner loop would modify the vector, it would make the reference from the outer loop invalid
[09:40:30] *** Quits: jstoja (julienbord@A750CF4B.4E5E648E.21BDDF43.IP) (Ping timeout)
[09:40:38] <kimundi> afrey71: Let's take a step back. What algorithm do you want to coder here in general? For every elemnt of the vector, mutate all elements of the vector?
[09:41:13] <afrey71> Hm.. it's not like I add or remove elements from the vector. Why does a modification to a single element invalidate an iterator on the vector?
[09:41:34] *** Quits: mark_edward (AndChat414@moz-97E995A.hsd1.in.comcast.net) (Quit: Bye)
[09:41:37] <kimundi> afrey71: Okay, if you don'T add/remove it wouldn't invalidate the iterator
[09:42:04] <kimundi> afrey71: but it would invalidate the & reference you get from the other iteration
[09:42:27] <afrey71> For every element of the vector, mutate all elements of the vector based on all other elements of the vector describes pretty well what I want to do, yes.
[09:42:38] <kimundi> afrey71: because you could mutate the elemnt the outer iteration currently has an & to
[09:43:09] <afrey71> Right. That's why I'd like to "release" the & reference before calling the inner loop.
[09:43:26] *** Quits: six600110 (six600110@moz-2FA48202.neo.res.rr.com) (Connection timed out)
[09:43:29] <afrey71> (Which implies I took a clone and modify based on the clone).
[09:43:48] *** Joins: six600110 (six600110@moz-2FA48202.neo.res.rr.com)
[09:43:53] <afrey71> I guess I could clone the entire vector and then let the outer loop go over the clone, then...
[09:44:10] <kimundi> afrey71: The problem is that it's not the x that's blocking you
[09:44:48] <kimundi> afrey71: the iterator object you get from .iter() freeze the vector, so you can't modify it at all while the outer iteration is happening
[09:45:15] <kimundi> working with a copy of the vector seems to be the only option, yeah
[09:45:45] <kimundi> maybe instead of mutating the vector, generate new values to collect into a new vector?
[09:46:02] <afrey71> That sounds like another good option, yes.
[09:46:31] <afrey71> Here's a solution with clone before the loops: http://pastebin.com/9UM8Y0EE
[09:46:40] <kimundi> v.iter().map(|i|{ for y in v.iter() { ... } ).to_owned_vec()
[09:46:58] *** Joins: sigma (sigma@moz-AAED89D5.range86-160.btcentralplus.com)
[09:47:07] <afrey71> Heck, I like that iterator stuff!
[09:47:09] <afrey71> kimundi: nice!
[09:47:10] <kimundi> afrey71: Of course, this changes the semantic
[09:47:12] <afrey71> thx
[09:47:53] *** Joins: lenstr (lenstr@E0E80B8D.ED45D46B.DFEAE789.IP)
[09:50:03] *** Joins: cdidd (cdidd@moz-891D929.broadband.corbina.ru)
[09:50:51] *** Joins: donri (donri@moz-9BB61102.tbcn.telia.com)
[09:51:46] <Luqman> haha! excuse found to use asm! :P
[09:55:29] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[10:00:24] *** Quits: tgummerer (tgummerer@moz-DEADF0AF.kthopen.kth.se) (Ping timeout)
[10:04:43] *** Joins: NiccosSystem (NiccosSyst@AB1AFDE.FC7B0C35.A7597CB6.IP)
[10:07:23] *** Quits: NiccosSystem (NiccosSyst@AB1AFDE.FC7B0C35.A7597CB6.IP) (Ping timeout)
[10:07:32] *** Quits: lenstr (lenstr@E0E80B8D.ED45D46B.DFEAE789.IP) (Client exited)
[10:09:07] *** Quits: vodik (simon@moz-CBE4BB13.cable.teksavvy.com) (Ping timeout)
[10:10:13] *** Quits: six600110 (six600110@moz-2FA48202.neo.res.rr.com) (Ping timeout)
[10:12:02] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[10:12:12] *** Quits: nsf (nsf@moz-EEF3238A.convex.ru) (Quit: WeeChat 0.4.1)
[10:15:28] *** Joins: skade (skade@30BBD5E6.505237C9.CAE22B62.IP)
[10:15:45] <afrey71> Next question: I'm using a #[deriving(Eq, TotalEq)], but see equalities turn out false when I expect true.
[10:16:24] *** Joins: six600110 (six600110@moz-2FA48202.neo.res.rr.com)
[10:16:30] <afrey71> Structs in question are nested, i.e. contain an owned vec of pointers back to the same structure.
[10:17:09] <afrey71> Stuff like this: http://pastebin.com/gkg80pk6 all works fine.
[10:17:33] <bjz_> cmr: bing
[10:17:35] *** Quits: MrOrdinaire (Mibbit@5C68C0A1.6BCC7DAD.FD383126.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[10:17:55] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[10:17:57] <afrey71> Or rephrasing the question: something to be aware of when using derived Eq and TotalEq impls?
[10:19:33] <kimundi> afrey71: Well they recursively call eq and equals for the content of your type. Maybe contained type behaves in a wayy you didn't expect?
[10:19:48] <nmatsakis> pnkfelix: saw your PR, see my comments, let me know what you think
[10:19:55] <pnkfelix> nmatsakis: k
[10:20:47] <msch> I saw that there's a PR for the rust 0.8 release notes. so 0.8 is coming very very soon now?
[10:21:09] <pnkfelix> nmatsakis: I explored trying to do it the way you suggest
[10:21:12] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[10:21:12] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/ce5czQ
[10:21:12] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[10:21:37] <kimundi> msch: all three months there is a time-based release. The next one will happen very soon, yes :)
[10:21:43] <pnkfelix> nmatsakis: but I never figured out exactly how best to represent the generation of multiple moves for all fields that are to be consumed
[10:22:01] <msch> kimundi cool! thanks for the info!
[10:22:04] <afrey71> kimundi: hm.. I use derived Eq, exclusively. And owned vectors.
[10:22:28] <kimundi> afrey71: Does the paste you linked to behave different than what you expect?
[10:23:09] <afrey71> No, it passes all assertions. So far I'm failing to reproduce the unexpected behaviour in a small test case. :-(
[10:23:15] <afrey71> I keep investigating...
[10:23:17] <kimundi> hm
[10:23:23] <kimundi> what types are all in play?
[10:23:50] <pnkfelix> nmatsakis: I suspect all the ways I considered doing it (extending the UseMode enum; or creating artificial ExprField nodes, â€¦) were not what you were considering.
[10:24:12] <afrey71> kimundi: structs, enums, int, bool and owned vectors
[10:25:11] <nmatsakis> pnkfelix: that is true.
[10:26:11] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[10:26:11] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/0QlcJA
[10:26:11] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[10:26:13] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[10:26:13] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/nkbsbw
[10:26:13] <ghrust> 13rust/06auto 14d84a22a 15Tim Chevalier: rustpkg: Register correct dependencies for built and installed files...
[10:26:13] <ghrust> 13rust/06auto 14176051c 15bors: auto merge of #9322 : catamorphism/rust/rustpkg-discovered-outputs, r=brson...
[10:26:13] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[10:26:22] <pnkfelix> nmatsakis: e.g. in an one earlier variant I extended the UseMode enum with a new variant that carries along the fields that should not be copied.  So the place where you see my current patch was building up that new UseMode variant.  But then at some point I said, "Wait, why don't I just signal the error right here?"  And that's how I got this patch.
[10:26:23] <afrey71> rust doesn't ever compare pointers (i.e. memory locations rather than content), right?
[10:26:32] <kimundi> afrey71: does any of the structs or enums implement Eq or TotalEq manually?
[10:26:50] <kimundi> afrey71: Not per default, no
[10:26:56] *** Quits: z0w0 (zack@64F0E14B.3C29B4A9.2CE63F58.IP) (Ping timeout)
[10:26:59] *** Quits: nrc|afk (nrc@7BE24E90.A5032A01.3CFC199D.IP) (Ping timeout)
[10:27:06] <afrey71> kimundi: nope, all derived stuff.
[10:27:13] <kimundi> afrey71: hm...
[10:27:22] <kimundi> afrey71: Then it _should_ work7
[10:27:44] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[10:28:02] <pnkfelix> nmatsakis: anyway, if you can give me a little more of a pointer about how you wanted the information to flow from moves.rs over to gather_moves.rs (since right now gather_moves.rs does not see the whole `{ id: a, ..s0 }`; it only sees the s0.  (At least that's my fuzzy memory)
[10:28:08] <kimundi> afrey71: Do you maybe have a type or so that makes you think you're comparing two identical/different values that are actually diffferent/identical?
[10:28:12] <nmatsakis> pnkfelix: I figured gather_moves would just recompute the information
[10:28:18] <nmatsakis> pnkfelix: possibly using a helper defined in moves.rs
[10:28:31] <pnkfelix> nmatsakis: Can I go from a child node to its parent in the ast ?
[10:28:48] <afrey71> kimundi: maybe... will re-check...
[10:28:49] <nmatsakis> pnkfelix: no, I'd compute it in the FSU node -- basically add a new case, "compute_moves_for FSU" or something
[10:29:32] <kimundi> afrey71: typo* , but you know what I mean :P
[10:29:58] <pnkfelix> nmatsakis: unfortunately there's no much debug! instrumentation in gather_moves.rs, so its not trivial for me to validate my assertion that it doesn't get called with enough context...
[10:30:25] <pnkfelix> nmatsakis: Slight Tangent: Do you think we need a #rustc channel, to separate discussion of rustc internals from discussion of Rust the language ?
[10:30:47] <nmatsakis> pnkfelix: not a bad idea. this channel often gets quite busy, probably coming on time to split it 
[10:30:58] <nmatsakis> pnkfelix: regarding the patch, i'm tempted to just r+ it, since it's small and reasonable,
[10:31:16] <nmatsakis> pnkfelix: and I have some plans to renovate a bit as part of the effort to fix moves in trans not to null things out,
[10:31:32] <pnkfelix> nmatsakis: Yes, I understand your desire to make it more unified
[10:31:34] <nmatsakis> pnkfelix: so maybe I could fix it then (or not fix it, if it proves that there are more obstacles)
[10:32:02] <pnkfelix> nmatsakis: but I couldn't come up with something that didn't seem like it was just shuffling code around, without actually unifying anything...
[10:32:37] <pnkfelix> nmatsakis: Regarding the channel, is #rustc sufficiently distinct from #rust?  Should it be #rustimpl or something?
[10:32:58] <nmatsakis> pnkfelix: is there an existing convention from other languages? maybe rust-dev?
[10:33:08] <pnkfelix> nmatsakis: let me look
[10:37:07] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[10:37:54] *** Joins: brendan (brendaneic@9E9221B0.60D98710.CE12DF22.IP)
[10:37:58] <pnkfelix> nmatsakis: (I think rust-dev is ambiguous: Is it development of Rust impl, or development using Rustâ€¦ Note there is already #rust-gamedev as precendent for the latter interpretation) 
[10:38:35] <nmatsakis> pnkfelix: indeed. I'm fine with rustc
[10:38:55] <nmatsakis> pnkfelix: it excludes library development perhaps? not sure that's a bad thing tho! maybe rustlibs
[10:39:11] <pnkfelix> nmatsakis: yeah I guess that will do.  And yes, filtering out library dev discussion seems like a good thing
[10:41:10] *** Quits: nathan7 (nathan@86F860FE.3CD03790.F113998C.IP) (Ping timeout)
[10:42:05] <pnkfelix> nmatsakis: Oh, this reminds me: Does trans do anything to reuse the memory when doing a moving FSU ?
[10:42:16] *** Quits: nkoep (nik@moz-77021FC6.pool.mediaways.net) (Ping timeout)
[10:43:19] <pnkfelix> nmatsakis: â€¦ I guess it must not currently (at least not soundly), since this bug was present.
[10:43:24] <nmatsakis> pnkfelix: I remember having some concern about how trans handles it
[10:44:20] <pnkfelix> brson mentioned something about how we might flag FSU off by default for 1.0; were you aware of that?
[10:45:25] <pnkfelix> (I might be misremembering; it could just have been a question of not liking the `..s` syntax for this and for fixed-length vecs, and wanting to change it.  Or having the option to change it.)
[10:45:49] <nmatsakis> pnkfelix: I was not aware of that
[10:45:56] <nmatsakis> pnkfelix: I do remember that he doesn't like that syntax
[10:47:33] <pnkfelix> nmatsakis: I found it odd for the fixed-length vec thing when I first encountered it.  At this point I've come to accept it, but I guess I'll wait to see what brson and pcwalton are thinking.
[10:49:50] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[10:49:59] *** Quits: ercxx__ (ercan@moz-7CFF3469.dyn.optonline.net) (Quit: WeeChat 0.4.1)
[10:53:32] *** Quits: moot (Mibbit@moz-5256162B.hsd1.ca.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[10:54:19] *** Joins: lenstr (lenstr@E0E80B8D.ED45D46B.DFEAE789.IP)
[10:57:29] *** Joins: nkoep (nik@moz-70FC3896.vpn.rwth-aachen.de)
[10:59:14] *** Joins: nano (nano@moz-74CAD1CA.superkabel.de)
[10:59:31] *** Joins: moot (Mibbit@moz-5256162B.hsd1.ca.comcast.net)
[11:03:01] *** Quits: dew (Instantbir@moz-D2FA52B6.static.stls.mo.charter.com) (Ping timeout)
[11:03:02] *** Joins: dew1 (Instantbir@moz-D2FA52B6.static.stls.mo.charter.com)
[11:05:44] *** Quits: lenstr (lenstr@E0E80B8D.ED45D46B.DFEAE789.IP) (Client exited)
[11:06:30] *** Quits: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net) (Ping timeout)
[11:13:30] *** Joins: nathan7 (nathan@86F860FE.3CD03790.F113998C.IP)
[11:14:08] *** Quits: ww (Mibbit@moz-DFAED48A.lightspeed.sntcca.sbcglobal.net) (Quit: http://www.mibbit.com ajax IRC Client)
[11:18:06] *** Joins: jensnockert (jensnocker@moz-CB012ADC.wireless.lu.se)
[11:18:19] *** Joins: msingle (Thunderbir@moz-20675462.nrflva.fios.verizon.net)
[11:19:27] *** Quits: jensnockert (jensnocker@moz-CB012ADC.wireless.lu.se) (Input/output error)
[11:22:41] *** Quits: moot (Mibbit@moz-5256162B.hsd1.ca.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[11:26:26] *** Quits: brendan (brendaneic@9E9221B0.60D98710.CE12DF22.IP) (Quit: brendan)
[11:27:32] *** Quits: msingle (Thunderbir@moz-20675462.nrflva.fios.verizon.net) (Ping timeout)
[11:32:24] *** Joins: brendan (brendaneic@9E9221B0.60D98710.CE12DF22.IP)
[11:33:26] *** Joins: jfbk (jfbk@moz-EEA9CFB3.nyc.res.rr.com)
[11:33:33] *** Quits: Lovot (root@AE31FB56.8153C3BF.F3C9A2D9.IP) (Ping timeout)
[11:35:27] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Ping timeout)
[11:44:33] *** Joins: NiccosSystem (NiccosSyst@AB1AFDE.FC7B0C35.A7597CB6.IP)
[11:47:10] *** Quits: brendan (brendaneic@9E9221B0.60D98710.CE12DF22.IP) (Quit: brendan)
[11:51:10] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[11:51:10] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/nkbsbw
[11:51:10] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[11:52:19] <dbaupp> https://github.com/mozilla/rust/pull/9360/files r?
[11:54:24] *** Joins: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[11:54:25] *** Quits: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Client exited)
[11:54:31] *** Joins: Earnestly (earnest@moz-BE290A2B.dyn.plus.net)
[11:54:32] *** Joins: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[11:56:10] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[11:56:10] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/yXb-ew
[11:56:10] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[11:56:11] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[11:56:11] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/Ezd7FA
[11:56:11] <ghrust> 13rust/06auto 145708b91 15NiccosSystem: Fix broken tutorial link
[11:56:11] <ghrust> 13rust/06auto 1444997a1 15bors: auto merge of #9326 : NiccosSystem/rust/master, r=bstrie
[11:56:11] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[11:56:26] <NiccosSystem> woo
[12:02:06] *** Joins: samx (sami@moz-D9DA5773.dyn.optonline.net)
[12:03:30] *** Quits: samx (sami@moz-D9DA5773.dyn.optonline.net) (Quit: This computer has gone to sleep)
[12:04:51] *** Joins: rust-noob (Mibbit@moz-3112320B.graz.surfer.at)
[12:14:31] *** Joins: MrOrdinaire (Mibbit@3749AFFF.391F484.FD383126.IP)
[12:17:46] *** Joins: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net)
[12:17:55] *** Quits: nkoep (nik@moz-70FC3896.vpn.rwth-aachen.de) (Ping timeout)
[12:18:00] *** Joins: canhtak (jeremy@moz-44AEB22E.wl.t.ulaval.ca)
[12:19:24] *** Quits: jfbk (jfbk@moz-EEA9CFB3.nyc.res.rr.com) (Quit: )
[12:19:36] *** Joins: bheylin_ (brianheyli@moz-3D24C757.static.chello.nl)
[12:22:14] *** Quits: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net) (Quit: Leaving)
[12:23:28] *** Quits: bheylin_ (brianheyli@moz-3D24C757.static.chello.nl) (Quit: bheylin_)
[12:23:57] <bstrie> oh hey, so more containers can be `collect`ed now? can anyone give an example?
[12:24:58] <rust-noob> hey! where do I find the prelude in the code? ;)
[12:25:57] <Yoric> On hoogle? :)
[12:26:05] <bstrie> rust-noob: I think it's in std::prelude?
[12:26:29] <bstrie> rust-noob: https://github.com/mozilla/rust/blob/master/src/libstd/prelude.rs
[12:29:40] *** jorendorff_away is now known as jorendorff
[12:29:45] *** Joins: sebcrozet (sebcrozet@moz-C27D92D8.w193-252.abo.wanadoo.fr)
[12:30:08] *** Quits: rust-noob (Mibbit@moz-3112320B.graz.surfer.at) (Quit: http://www.mibbit.com ajax IRC Client)
[12:34:33] *** Joins: jensnockert (jensnocker@moz-CB012ADC.wireless.lu.se)
[12:34:42] <benh> Hmm
[12:35:11] <benh> There isn't really a way to write a method fn f(&self) -> &T { self.t } where t has a @-ptr type, is there
[12:35:24] <benh> even with lots of lifetime annotations and explicit conversions and...
[12:36:09] *** Joins: nkoep (nik@moz-7EFF3F81.vpn.rwth-aachen.de)
[12:37:56] *** Joins: mihneadb (mihneadb@moz-CFFC9266.residential.rdsnet.ro)
[12:39:54] <pnkfelix> benh: Sort of makes sense â€¦ you can only return &T with an explicit lifetime, which implies the extent of the referenced T must be statically known, and @T is pretty much the definition of non-statically known extent, right?
[12:40:31] <dbaupp> bstrie: basically every container in std/extra is a collectable
[12:40:52] <benh> I'm aware it's iffy, but I was hoping because there is a @T in the self object, the borrow checker could consider self frozen for the lifetime of the returned pointer, which might keep the @T alive :)
[12:41:09] <pnkfelix> benh: Plus, otherwise the compiler/runtime would have to actually track the pointer that you got back in the &T, in order to reclaim the storage
[12:41:22] <pnkfelix> benh: Ah I see.
[12:41:38] <benh> My plan fails if there is a moving GC, at least
[12:41:55] <benh> unless the compiler gets really clever, yeah
[12:42:06] <bstrie> won't ever be a moving GC, cause of interior pointers
[12:42:22] <bstrie> actually
[12:42:23] *** Quits: jensnockert (jensnocker@moz-CB012ADC.wireless.lu.se) (Input/output error)
[12:42:24] <pnkfelix> bstrie: â€¦ I'm not sure if that's true ...
[12:42:30] <bstrie> I guess we now forbid & in @?
[12:42:37] <benh> We do
[12:42:40] <bstrie> from reading the release notes
[12:42:40] <benh> apparently!
[12:42:42] <pnkfelix> bstrie: we've been talking for a while about a mostly-copying gc
[12:42:53] <bstrie> I haven't been following
[12:43:02] <pnkfelix> bstrie: (I didn't mean in the chat room)
[12:43:06] <benh> I thought a moving GC was fine because interior & pointers would pin the object for their lifetime
[12:43:27] <benh> (I mean &-pointers pointing to an interior object of a managed object, not sure if I'm using the right words)
[12:43:45] *** Joins: jfbk (jfbk@moz-EEA9CFB3.nyc.res.rr.com)
[12:43:50] <bstrie> maybe I'm just really bad at GC terminology :P
[12:43:54] <dbaupp> https://github.com/mozilla/rust/pull/9360 r? (just uncommenting a test)
[12:44:50] <benh> I'm idly looking at removing some of the @'s I saw in the lexer, but it's tricky :)
[12:46:36] *** Quits: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Ping timeout)
[12:47:10] *** Joins: nsf (nsf@moz-EEF3238A.convex.ru)
[12:48:26] *** Joins: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[12:49:06] *** Parts: sruggier (sruggier@7319AA3D.D4245AC4.971E19F6.IP) ()
[12:51:38] *** Quits: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Quit: msingle)
[12:53:10] <dbaupp> Does anyone have a comment/opinion? https://github.com/mozilla/rust/pull/9361
[12:54:14] *** Joins: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net)
[12:56:05] <bstrie> dbaupp: seems redundant with println!()
[12:56:16] <bstrie> rusti: println!(1);
[12:56:17] -rusti- <anon>:7:18: 7:19 error: format argument must be a string literal.
[12:56:17] -rusti- <anon>:7          println!(1);
[12:56:17] -rusti-                            ^
[12:56:17] -rusti- application terminated with error code 101
[12:56:21] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[12:56:24] <bstrie> ?
[12:56:29] <bstrie> I thought you didn't need a format string there
[12:56:33] <bstrie> rusti: printfln!(1);
[12:56:34] -rusti- 1
[12:56:34] -rusti- ()
[12:56:47] <benh> What's printfln? The one that uses fmt!?
[12:56:49] *** Joins: MauricioC (mauricioc@moz-2CFCD404.impa.br)
[12:56:56] <bstrie> can we give println the same behavior as printfln there?
[12:56:59] <bstrie> benh: I think so
[12:57:08] <bstrie> rusti: printfln!(1, 2);
[12:57:08] -rusti- <anon>:7:19: 7:20 error: first argument to fmt! must be a string literal.
[12:57:08] -rusti- <anon>:7          printfln!(1, 2);
[12:57:08] -rusti-                             ^
[12:57:09] -rusti- application terminated with error code 101
[12:57:21] <NiccosSystem> rusti: loop { printfln!(1); break; }
[12:57:22] -rusti- 1
[12:57:22] -rusti- ()
[12:57:35] <NiccosSystem> most efficient code ever made
[12:58:32] <bstrie> NiccosSystem: actually, pritnfln uses the fmt macro, which is highly inefficient. a more efficient implementation would use println! instead.
[12:58:40] <bstrie> :|
[12:59:31] <NiccosSystem> lol
[13:00:59] <dbaupp> rusti: error2!(2)
[13:00:59] -rusti- <anon>:7:17: 7:18 error: format argument must be a string literal.
[13:00:59] -rusti- <anon>:7          error2!(2)
[13:00:59] -rusti-                           ^
[13:00:59] -rusti- application terminated with error code 101
[13:01:09] <dbaupp> :( sad to lose that.
[13:02:45] *** Quits: Jessin (Jessin_@moz-CDB412A.cc.lehigh.edu) (Ping timeout)
[13:05:54] *** Joins: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca)
[13:06:08] *** Joins: sk (sk@BC280AA6.273A3D3C.78DD174B.IP)
[13:06:20] *** Joins: sw17ch (sw17ch@moz-62998E95.hfc.comcastbusiness.net)
[13:08:41] *** Joins: jensnockert (jensnocker@moz-56980B81.wireless.lu.se)
[13:09:13] *** Quits: lbergstrom (Adium@moz-5D8E4B14.lightspeed.cicril.sbcglobal.net) (Quit: Leaving.)
[13:09:18] *** Joins: lbergstrom (Adium@moz-5D8E4B14.lightspeed.cicril.sbcglobal.net)
[13:12:04] *** Joins: io2 (io2@moz-A6202C16.home.otenet.gr)
[13:13:16] *** Quits: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net) (Quit: dave1629)
[13:13:35] *** Joins: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net)
[13:16:13] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[13:16:13] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/Ezd7FA
[13:16:13] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[13:17:55] <kimundi> dbaupp: No reason the new one couldn'T support that too
[13:18:21] <sw17ch> I've found the Data Parallelism in Rust blog post by Matsakis but I'm left with some question (either because I failed to read close enough, or my Rust-foo is weak.)
[13:19:09] <kimundi> sw17ch: I can't claim to know about that stuff there much, but I might help with questions about weak rust foo
[13:19:13] <sw17ch> In particular, I wanted to play with some parallel problems where there's multiple readers in static data that write into a different set of data. A double-buffered problem.
[13:19:17] <sw17ch> http://smallcultfollowing.com/babysteps/blog/2013/06/11/data-parallelism-in-rust/
[13:19:23] <sw17ch> kimundi: :)
[13:19:40] <sw17ch> kimundi: is there any way to share immutable data from, say, an array?
[13:19:43] <sw17ch> across multiple tasks?
[13:19:50] <bstrie> sw17ch: you can ask nmatsakis yourself, he's in the channel! not sure if he's at his compy right now tho
[13:20:01] *** jorendorff is now known as jorendorff_away
[13:20:09] <sw17ch> oh excellent, i'll check back throughout the day.
[13:20:47] *** Joins: Jessin (Jessin_@moz-C8BB4444.cc.lehigh.edu)
[13:21:13] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[13:21:13] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/lLbXLw
[13:21:13] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[13:21:15] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[13:21:15] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/P5PMIA
[13:21:15] <ghrust> 13rust/06auto 149051a35 15Lars Bergstrom: Clarify that snapshots are automatically retrieved.
[13:21:15] <ghrust> 13rust/06auto 14d82cb97 15bors: auto merge of #9327 : larsbergstrom/rust/tutorial_installation_tweak, r=catamorphism...
[13:21:15] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[13:21:21] <sw17ch> I'd like, for educational reasons, to write a forest-fire simulation where each cell in an array represents a 'tree'. Each tree has a probability to be set on fire for some number of rounds based on the number of trees around it that are on fire.
[13:21:21] <kimundi> sw17ch: You have right now the ability to schare immutable data between tasks
[13:21:30] <Seldaek> sw17ch: if you like this sort of problem, I sure could use help parallelizing https://github.com/Seldaek/deris further (right now it's a RWArc which is really not ideal) - in case you're bored :)
[13:21:33] <sw17ch> Through borrowed pointers, no?
[13:21:57] <sw17ch> (My true goal is to use Rust on an STM32F4 in place of FreeRTOS.)
[13:22:12] <sw17ch> (but i need to learn rust, llvm, clang, and friends more gooder first)
[13:22:17] <kimundi> sw17ch: You can use Arc for an immutable reference counted smartpointer that can be shared across tasks, and RWArc for one that uses locking to allow mutating across tasks
[13:23:08] <kimundi> sw17ch: That block post talks about introducing trait bounds which would allow to define an safe api for sharing borrowed pointers across tasks. But that is not implemented yet
[13:23:14] *** Quits: jfbk (jfbk@moz-EEA9CFB3.nyc.res.rr.com) (Quit: )
[13:23:24] <sw17ch> kimundi: that was the impression i got from the post as well
[13:23:24] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[13:23:36] *** Quits: MrOrdinaire (Mibbit@3749AFFF.391F484.FD383126.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[13:23:46] <sw17ch> i'd really like to be able to divide up an array into a set of references that can safely be interacted with from multiple tasks without locks.
[13:23:58] <sw17ch> though, i expect this is Hardâ„¢
[13:24:00] <kimundi> yeah, that would be cool to have.
[13:24:20] <sw17ch> My space is embedded software and Rust has, so far, proven itself to be a language rather well suited for the job.
[13:24:39] <sw17ch> I'm actually very excited by the language.
[13:24:46] *** Quits: NiccosSystem (NiccosSyst@AB1AFDE.FC7B0C35.A7597CB6.IP) (Quit: Leaving)
[13:25:25] <kimundi> sw17ch: Actually, I don't think it's that hard to do. If you're willing to use unsafe code you could write something like that quite quickly right now. YOu just won't be able to define an safe generic api
[13:25:31] <benh> rusti: let r = &"blah"; do std::task::try { println!("{}", r); }
[13:25:35] -rusti- pastebinned 20 lines of output: http://sprunge.us/DTTf
[13:25:45] <dbaupp> kimundi: you can, just it's not as general as it could be (I believe)
[13:26:00] <benh> clearly what i just wrote is safe, isn't it
[13:26:08] <kimundi> benh: nope
[13:26:24] <kimundi> benh: well, maybe because it's a 'static str
[13:26:26] <dbaupp> kimundi: you just need to make sure that the main task that owns the borrowed pointers is blocked, and so never has a chance to deallocate
[13:26:34] *** Quits: jensnockert (jensnocker@moz-56980B81.wireless.lu.se) (Input/output error)
[13:26:43] <benh> I thought it might be safe because try blocks for the entirety of the new tasks lifetime
[13:26:59] <kimundi> dbaupp: right, that's my point. but I also just realized that try would cause that blocking, so my bad
[13:27:03] <dbaupp> rusti: let r = &'static "blah"; do std::task::try { println!("{}", r); }
[13:27:12] <sw17ch> I don't recall coming across 'static in the documentation yet: what does it mean?
[13:27:12] -rusti- pastebinned 20 lines of output: http://sprunge.us/NYFa
[13:27:18] <kimundi> benh: So, yes, that would be safe indeed in theory I think
[13:27:29] <dbaupp> rusti: let r: &'static str = &'static "blah"; do std::task::try { println!("{}", r); }
[13:27:30] <kimundi> sw17ch: I mean't &'static str
[13:27:31] -rusti- blah
[13:27:31] -rusti- Ok(())
[13:27:50] <kimundi> sw17ch: 'static is the only special lifetime. It means "lives as long as the process"
[13:28:00] <kimundi> sw17ch: All string constants are &'static str
[13:28:07] <sw17ch> kimundi: ah, so it's analogous to static-local-variables in C functions.
[13:28:13] <dbaupp> it almost all cases, it means data that's actually hardcoded into the binary, yeah.
[13:28:33] <sw17ch> *or* data in the read-only linker sections
[13:28:37] <kimundi> sw17ch: Err, not sure? Isn't a static in a function in C a global variable scoped to that function?
[13:28:43] <sw17ch> yes
[13:28:55] <sw17ch> which is why i'm trying to differentiate -- it still has a lifetime of forever
[13:29:06] <kimundi> The only thing in common would be the 'global' part then :P
[13:29:28] <sw17ch> so 'static's are immutable?
[13:29:41] <sw17ch> or, is it just that it's not necessarily function-scoped
[13:30:00] <kimundi> anyway, a &'static thing can be shared and send across task without an restrictions in theory, because it can never go away or get mutated
[13:30:24] <kimundi> sw17ch: function scope has noting to do with it
[13:30:26] <sw17ch> ah, that's what i wanted
[13:30:31] <kimundi> sw17ch: And a & ptr is immutable
[13:30:33] <sw17ch> immutable and lives forever
[13:30:42] <benh> a & pointee ;)
[13:32:07] <sw17ch> Okay, so then the guarantee one would have to make for the situation I want is that the object will at least outlive all the tasks reading from it -- the part i'm still not clear on is what prevents multiple tasks from reading the data simultaneously as long as there's a guarantee that all tasks will complete before the parent context de-allocates the object.
[13:32:26] *** Joins: wakandan (Mibbit@5B9B91CA.8FF05F7.4605F140.IP)
[13:32:27] <sw17ch> Is this just a limitation in Rust's semantics right now?
[13:32:35] *** Joins: aeqwa (aeqwa@moz-E5EC4149.dsl.tropolys.de)
[13:32:48] <sw17ch> or does it have to do with how the types are handled and the difficulty in resolving the 'do all the tasks stop first' problem?
[13:33:25] <kimundi> sw17ch: What's the problem with multiple tasks reading at the same time?
[13:33:45] *** jorendorff_away is now known as jorendorff
[13:34:22] <sw17ch> kimundi: it seems there isn't one with Arc's, but i'm still interested in the lock-free variant you can get when you know no one can modify the data.
[13:34:30] <kimundi> sw17ch: Or are you asking why it doesn't work currently? The answer to that would be what you said last - threading that "task outlives pointer" guarantee throgh the type system
[13:34:30] <sw17ch> well, *could* get.
[13:34:40] <sw17ch> kimundi: ah, thanks
[13:34:54] <kimundi> sw17ch: Arc is lockfree I think.
[13:35:00] <sw17ch> that was what i expected the answer was when i first ran across it in code -- "huh, this is immutable, why does it care about the borrowing semantics?"
[13:35:02] <kimundi> sw17ch: Just atomically reference counted
[13:37:21] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[13:40:21] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[13:41:10] *** Joins: Ferreus (daniel@moz-E450C4F9.dyn.telefonica.de)
[13:41:36] <sw17ch> Seldaek: looking over that repository
[13:41:43] <sw17ch> what does this line represent? `static DOLLAR: u8 = '$' as u8;`
[13:41:52] <sw17ch> a variable DOLLAR of type u8
[13:41:56] <sw17ch> is set to be '$'
[13:42:02] <sw17ch> but i'm not familiar with the 'as u8' portion yet
[13:42:17] *** Quits: halorgium (z@moz-7A333983.spork.in) (Ping timeout)
[13:42:24] <sw17ch> https://github.com/Seldaek/deris/blob/master/deris.rs#L79
[13:42:28] <benh> '$' is type char
[13:42:30] <dbaupp> rusti: '$' as u8
[13:42:31] -rusti- 36u8
[13:43:00] <benh> basically getting the numeric codepoint of '$', i guess
[13:43:02] <dbaupp> it converts the $ character into a u8 that holds the unicode codepoint number of it.
[13:43:03] <kimundi> sw17ch: it's a cast
[13:43:05] <pnkfelix> sw17ch: 'as u8' is a cast to byte
[13:43:07] <benh> rusti: 'ÃŸ' as u8
[13:43:08] -rusti- 223u8
[13:43:12] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[13:43:16] <benh> rusti: 'â—' as u8
[13:43:16] -rusti- 207u8
[13:43:19] <bstrie> rusti: '' as u8
[13:43:19] -rusti- <anon>:6:12: 6:13 error: unterminated character constant
[13:43:19] -rusti- <anon>:6     let r = {
[13:43:20] -rusti-                      ^
[13:43:20] -rusti- application terminated with error code 101
[13:43:22] <benh> it's a bit dodgy
[13:43:34] <sw17ch> oh, so the 'as' binds more tightly than the left hand side
[13:43:38] <bstrie> rusti: ''' as u8
[13:43:39] -rusti- 39u8
[13:43:52] <kimundi> sw17ch: Well... In that case there is not left side to bind
[13:43:58] *** Joins: halorgium (z@moz-7A333983.spork.in)
[13:44:21] <benh> 'as' is just an expression thing, it's not part of the whole constant declaration syntax
[13:44:23] <kimundi> sw17ch: "'$' as u8" is the whole expression
[13:44:37] <sw17ch> i suppose that's what i meant to say.
[13:44:59] <benh> rusti: println("{}", '$' as u8 + '!' as u8)
[13:44:59] -rusti- <anon>:7:9: 8:5 error: this function takes 1 parameter but 2 parameters were supplied
[13:44:59] -rusti- <anon>:7          println("{}", '$' as u8 + '!' as u8)
[13:45:00] -rusti- <anon>:8     };
[13:45:01] -rusti- error: aborting due to previous error
[13:45:03] -rusti- application terminated with error code 101
[13:45:05] <kimundi> static IDENT: TYPE = EXPR;
[13:45:08] <benh> boo, i meant println!
[13:45:22] <benh> do we have static mut yet btw?
[13:45:26] <kimundi> benh: yes
[13:45:37] <sw17ch> wow wait hold on. static mut?
[13:45:38] <kimundi> benh: requires unsafe to access though
[13:46:08] <kimundi> sw17ch: Just an feature neccessary for ffi. It's inherently unsafe.
[13:46:10] <benh> Unsafe global variables, I think the idea is pretty much to be able to bind global variables exposed by C libraries.
[13:46:17] <kimundi> sw17ch: A global variable basically
[13:46:41] <kimundi> sw17ch: Should never be used in normal rust code
[13:46:59] <sw17ch> Of course.
[13:47:12] <bstrie> sw17ch: if you use it, we'll know. :|
[13:47:19] <sw17ch> hah!
[13:47:25] <bstrie> we know everything.
[13:47:41] <dbaupp> every unsafe block gets reported back to rust hq, and noted.
[13:48:04] <sw17ch> rust hq has a shame wally then
[13:48:07] <sw17ch> my word
[13:48:09] <sw17ch> autocorrect
[13:48:15] <sw17ch> but i'm leaving it: shame wally 
[13:48:22] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[13:48:26] <bstrie> how does autocorrect turn wall -> wally
[13:48:48] <bstrie> "wall" is a word
[13:48:51] <sw17ch> i'm not sure, but that y is nowhere near wall. i'm without an explanation.
[13:48:58] <bstrie> go home autocorrect, you are drunk
[13:49:03] <dbaupp> bstrie: I don't believe you; do you have proof of that?
[13:49:05] <sw17ch> ah
[13:49:08] <sw17ch> shame "wallt" 
[13:49:11] <sw17ch> i missed the space
[13:49:20] * dbaupp wants some peer-reviewed testimonies
[13:49:24] <bstrie> dbaupp: let me write it up in coq real quick
[13:49:24] <sw17ch> and the t *is* next to the y
[13:49:36] * sw17ch senses other Haskell developers
[13:50:08] <bstrie> NOPE javascript developer here
[13:50:12] <bstrie> what is a pointer even
[13:51:04] <sw17ch> bstrie: it's a word, of course
[13:51:18] <bstrie> what is a word
[13:51:21] <bstrie> is it an object?
[13:51:31] <kimundi> Is it like json?
[13:51:40] <bstrie> definitely not like a json
[13:51:49] <bstrie> a json is just a string
[13:51:50] <dbaupp> I thought it was like the bottom of the __proto__ stack?
[13:51:52] <kimundi> Ah, so a yaml then
[13:51:53] <bstrie> which is an object
[13:52:31] <sw17ch> yes, a pointer is a yaml that holds a json
[13:52:46] <sw17ch> or, sometimes, when you json a json, it's a double pointer
[13:52:58] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[13:53:21] <Seldaek> I hear when you have to wrap for loop contents in closures to avoid the "i" containing the end value of the loop in all your callbacks, it's pointers trying to kill your program
[13:53:28] <sw17ch> { "more_json": "{ \"the_actual_json\": \"oh_wow_could_it_be_more_json\" }"}
[13:53:47] <Seldaek> they're called pointers because they've pointy teeth and ears and are really mean
[13:54:29] <bstrie> pointers are those pointy things that instakill you in mega man
[13:54:30] <kimundi> And like to point at people and laugh
[13:54:31] *** Joins: huseby (huseby@moz-4E8C421A.husebyhome.com)
[13:54:54] <kimundi> Guys, I figured it out! Nelson is a pointer!
[13:54:56] * dbaupp used a pointer to repair his clothes once
[13:55:43] <Seldaek> we should use all this creativity to  write children books about programming, not waste time on a new language fad :p
[13:56:15] <kimundi> Children would hate rust
[13:56:21] <dbaupp> Robots too
[13:56:25] <sw17ch> typedef (void *) Nealson;
[13:56:28] <sw17ch> erm
[13:56:29] <sw17ch> Nelson;
[13:56:32] <kimundi> Everytime they do something fun, the compiler just yells NO!
[13:56:58] <bstrie> learn this one neat trick to avoid segfaults! children hate it
[13:57:19] * dbaupp alias negative_nelly="rustc"
[13:57:47] <kimundi> "Can I borrow your Nelson? Don't act as if you own that Nelson! Guys, let us all just be friends and share this Nelson!"
[13:58:17] <kimundi> "I've lost count of my Nelsons, and now they're leaking all over the place"
[13:58:17] <bstrie> kimundi: do they even have the simpsons in germany??
[13:58:27] <kimundi> bstrie: Sure we do
[13:58:45] <bstrie> so weird to me
[13:59:02] <kimundi> bstrie: Our "Do'h!" is "Nein!" (No!)
[13:59:06] <bstrie> hahaha
[13:59:11] <bstrie> do they dub nelson's laugh?
[13:59:17] <kimundi> No idea
[13:59:26] *** Quits: lmandel (lmandel@moz-76CE9D51.cable.teksavvy.com) (Quit: lmandel)
[13:59:31] <bstrie> hm, how do you spell "haha" in german?
[13:59:38] <bstrie> what is the onomatopoeia there
[13:59:40] <kimundi> http://www.youtube.com/watch?v=hozc3QP-kLw
[14:00:26] <kimundi> haha is pretty much the same here
[14:00:40] <kimundi> The German voice is just lower pitched
[14:02:23] <sw17ch> I'm now going to be unable to extract visions of Nelson laughing at me whenever things go wrong in an unsafe block.
[14:02:25] <bstrie> kimundi: btw your english is too good, you need to start "accidentally" inserting random umlauts into your typing so that people are aware of your multilingual ability
[14:02:53] <dbaupp> bstrie: why shÃ¶uld he dÃ¶ thÃ¤t?
[14:02:54] <kimundi> Pfff, why woÃ¼ld I dÃ¶ thÃ¤t?
[14:02:57] <dbaupp> haha
[14:02:58] <bstrie> hahaha
[14:03:15] <bstrie> I mean, hÃ¤hÃ¤hÃ¤
[14:03:19] <sw17ch> brÃ¤vÃ¶.
[14:03:39] <sw17ch> fn fÃ¶Ã¶() {}
[14:03:48] <kimundi> bstrie: That's actually a valid laughing onomatopoeia here
[14:03:52] <kimundi> hÃ¤hÃ¤
[14:04:02] <sw17ch> https://gist.github.com/sw17ch/5768912
[14:04:04] <dbaupp> Ä§Ã¥Ä§Ã¤
[14:04:06] <kimundi> basically the same as hehe, just a bit meaner
[14:04:08] <sw17ch> when i first discovered rust supports unicode
[14:04:27] <sw17ch> without the markup: https://gist.github.com/sw17ch/5768912/raw/3c8feb516330ae6820742469f395a19a32744401/ohnoes.rs
[14:04:41] <dbaupp> rusti: fn rÌ„Í¬Ì‡Í¦Ì“uÍ—Í—Ì…ÌsÌ”ÌˆÌÍ¯Ì„Ì“Í­Í‹tÍ£Í¯Í¦Ì‚ÌƒÌ†Ì“_ÌÍŒÌ‰ÌƒlÌ†aÍÌ¾Ì¿Ì‹ÌˆÌnÌ‰Í¬Í¥ÌÍªÌŠgÍ­Í›Ì¾_ÌcÍªÍ¬Í‘Í‚ÌˆoÍ­Í¨ÌŠÌ‹Ì“Í§mÌŒÌ¿ÌÌ¿Í¤Ì†ÍeÌ”Ì“Ì†Í­Í¨Ì¾Ìšs() {println("iÌ†Ì’ÌštÍ§Ì‚Í†Í«Ì„ ÌƒÍ¬Í—ÌÌ‚cÌˆÍ’ÌŠoÌƒÍ‘Ì“Í©Í¦Í’mÌŠÍ—ÌÌ’esÍ©Í›!Í¨Ì€Í©Ì€Í†Ì„Ìš iÌ†Ì¿ÌˆÌÌ€Í®Í‘tÍ¦Í‚Ì‰Ì’Ì”Ì‡ Ì“coÍ›ÌÌ¾Í¤Ì„Ì‰ÍŒmÍ‚Í†Ì€Í«eÍ›Í¨ÍŒÌ‡Í†Í£Í¥sÍ‚!Ì‡ÌŒÌŽÌ†");} rÌ„Í¬Ì‡Í¦Ì“uÍ—Í—Ì…ÌsÌ”ÌˆÌÍ¯Ì„Ì“Í­Í‹tÍ£Í¯Í¦Ì‚ÌƒÌ†Ì“_ÌÍŒÌ‰ÌƒlÌ†aÍÌ¾Ì¿Ì‹ÌˆÌnÌ‰Í¬Í¥ÌÍªÌ
[14:04:41] -rusti- error: internal compiler error: unexpected failure
[14:04:41] -rusti- note: the compiler hit an unexpected failure path. this is a bug
[14:04:41] -rusti- note: try running with RUST_LOG=rustc=1 to get further details and report the results to github.com/mozilla/rust/issues
[14:04:41] -rusti- application terminated with error code 101
[14:04:42] <kimundi> *maniacal cackle* <- hÃ¤hÃ¤hÃ¤hÃ¤!
[14:04:46] <bstrie> I'm not sure how to paste that into vim
[14:04:50] <bstrie> I think putty will choke on it
[14:04:56] <sw17ch> lol
[14:04:59] * dbaupp has a feeling that got mangled by IRC
[14:05:11] <sw17ch> curl https://gist.github.com/sw17ch/5768912/raw/3c8feb516330ae6820742469f395a19a32744401/ohnoes.rs > ohnoes.rs && rust run ohnoes.rs
[14:05:13] <bstrie> no.... it actually worked
[14:05:18] <bstrie> amusing
[14:05:34] <dbaupp> rusti: fn rÌ„Í¬Ì‡Í¦Ì“uÍ—Í—Ì…ÌsÌ”ÌˆÌÍ¯Ì„Ì“Í­Í‹tÍ£Í¯Í¦Ì‚ÌƒÌ†Ì“() {println("iÌ†Ì’ÌštÍ§Ì‚Í†Í«Ì„ ÌƒÍ¬Í—ÌÌ‚cÌˆÍ’ÌŠoÌƒÍ‘Ì“Í©Í¦Í’mÌŠÍ—ÌÌ’esÍ©Í›!Í¨Ì€Í©Ì€Í†Ì„Ìš");} rÌ„Í¬Ì‡Í¦Ì“uÍ—Í—Ì…ÌsÌ”ÌˆÌÍ¯Ì„Ì“Í­Í‹tÍ£Í¯Í¦Ì‚ÌƒÌ†()
[14:05:35] -rusti- pastebinned 5 lines of output: http://sprunge.us/UbOM
[14:05:37] <kimundi> xD
[14:06:14] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[14:06:14] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14d82cb97 to 1444997a1: 02http://git.io/N3iJvQ
[14:06:14] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[14:06:15] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[14:06:15] <ghrust> 01[13rust01] 15bors pushed 5 new commits to 06auto: 02http://git.io/zyEoCw
[14:06:15] <ghrust> 13rust/06auto 142927ab1 15U-NOV2010\eugals: optimized trans_to_datum::auto_borrow_obj code generation in case some trivial cases where simple copying can be applied
[14:06:15] <ghrust> 13rust/06auto 14dfa3f5f 15U-NOV2010\eugals: minor Type::opaque_trait code cleanup
[14:06:17] <ghrust> 13rust/06auto 140c3b6ad 15U-NOV2010\eugals: will not copy trait_callee on stack if it's source expr is a plain borrowed ref
[14:06:19] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[14:06:26] <dbaupp> rusti: fn rÌ„Í¬Ì‡Í¦Ì“uÍ—Í—Ì…ÌsÌ”ÌˆÌÍ¯Ì„Ì“Í­Í‹tÍ£Í¯Í¦Ì‚ÌƒÌ†Ì“() {println("iÌ†Ì’ÌštÍ§Ì‚Í†Í«Ì„ ÌƒÍ¬Í—ÌÌ‚cÌˆÍ’ÌŠoÌƒÍ‘Ì“Í©Í¦Í’mÌŠÍ—ÌÌ’esÍ©Í›!Í¨Ì€Í©Ì€Í†Ì„Ìš");} rÌ„Í¬Ì‡Í¦Ì“uÍ—Í—Ì…ÌsÌ”ÌˆÌÍ¯Ì„Ì“Í­Í‹tÍ£Í¯Í¦Ì‚ÌƒÌ†Ì“
[14:06:27] -rusti- fn()
[14:06:36] <kimundi> rusti: let ãƒ˜ãƒ˜ = "hehe"; ãƒ˜ãƒ˜
[14:06:37] -rusti- "hehe"
[14:06:41] <sw17ch> :D
[14:07:04] <klutzy> https://github.com/klutzy/aheui-llvm/blob/master/aheui.rs#L10
[14:07:05] <klutzy> :)
[14:07:09] *** Joins: lenstr (lenstr@E0E80B8D.ED45D46B.DFEAE789.IP)
[14:07:36] <bstrie> klutzy: what are these for?
[14:08:15] <dbaupp> klutzy: it's said that github highlights the korean weirdly :(
[14:08:17] <dbaupp> *sad
[14:08:23] <kimundi> hm, my font doesn't like what klutzy pasted :P
[14:08:48] * kimundi thought he had installed all asian fonts
[14:08:52] <klutzy> bstrie: aheui is befunge-like esolang http://esolangs.org/wiki/Aheui
[14:09:09] <nmatsakis> sw17ch: I'm around now
[14:10:42] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Quit: Gone to save the world!)
[14:10:53] * kimundi things someone should build Trefunge into some VR game as a scripting language
[14:11:15] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[14:11:18] <sw17ch> nmatsakis: oh wonderful. i'm hoping to write a program that, in C, would be a 2-dimensional array divided into a grid. each grid would then be assigned to a thread. each thread would then be responsible for checking on the next state of each individual cell in it's component of the grid and recording that new value into a buffer that will be used for the next round.
[14:11:50] <sw17ch> nmatsakis: i think your Data Parallelism post touched on some ideas that would be used here, but in particular, i didn't notice it talking about Arrays (though, i may just have missed it)
[14:12:03] <sw17ch> Is that something that has an obvious approach in Rust?
[14:12:42] <nmatsakis> sw17ch: I think that would work just fine, except that the stuff I talked about in the data par post has not yet been fully implemented
[14:13:01] <sw17ch> nmatsakis: i've gathered. :)
[14:13:05] <nmatsakis> sw17ch: I didn't talk much about arrays, it's true, but they do fit in
[14:13:39] <sw17ch> I thought they would, but my rust-foo is weak enough that I didn't see the obvious way it would apply.
[14:15:08] <nmatsakis> sw17ch: do you plan to use a double-buffering scenario?
[14:15:13] *** Quits: mihneadb (mihneadb@moz-CFFC9266.residential.rdsnet.ro) (Input/output error)
[14:15:17] <nmatsakis> sw17ch: i.e., one input buffer, one output buffer, then change roles?
[14:15:24] <sw17ch> nmatsakis: yes.
[14:15:26] *** Quits: n00b6502 (kwr5y54@moz-2BA2D1DA.range86-184.btcentralplus.com) (Ping timeout)
[14:15:32] *** Quits: doomlord__ (servitor@moz-2BA2D1DA.range86-184.btcentralplus.com) (Ping timeout)
[14:15:33] <sw17ch> unless there's another route.
[14:15:36] *** Joins: ceninan (ceninan@moz-6BD43586.a370.priv.bahnhof.se)
[14:15:54] *** Joins: d3xter (Mibbit@moz-8A32107B.nat.uclv.net)
[14:15:58] <sw17ch> I work primarily in C, Haskell, and Ruby at the moment and the approach I'd take in C seems most applicable to this scenario.
[14:16:07] <sw17ch> And it seems to be something Rust would be able to deal with.
[14:18:20] *** Quits: lenstr (lenstr@E0E80B8D.ED45D46B.DFEAE789.IP) (Client exited)
[14:18:25] <nmatsakis> sw17ch: so I think I discussed how we can have a method that carves up the output buffer and hands out parts of it
[14:18:33] <nmatsakis> sw17ch: I was thinking precisely of examples like this
[14:18:41] <nmatsakis> sw17ch: I wanted to make a sequential prototype, got partway through,
[14:18:48] <nmatsakis> sw17ch: that would let you write the program and see how it would look,
[14:18:54] <nmatsakis> sw17ch: even though it would not execute in parallel
[14:19:02] <nmatsakis> sw17ch: one caveat is that some of the support type system work isn't done,
[14:19:09] <nmatsakis> sw17ch: so some things would type check that prob ought not to,
[14:19:21] <nmatsakis> sw17ch: maybe later today if I find a bit of time I'll show you what I mean :)
[14:19:30] <sw17ch> nmatsakis: earlier we discussed how resolving the lifetime in the type system would be hard with multiple tasks.
[14:19:38] <sw17ch> nmatsakis: i'd like that.
[14:21:43] <sw17ch> Is it correct to say Rust uses a linear type system?
[14:21:55] <sw17ch> (my type theory is poor)
[14:25:21] *** Quits: d3xter (Mibbit@moz-8A32107B.nat.uclv.net) (Quit: http://www.mibbit.com ajax IRC Client)
[14:25:45] *** Joins: steveh (Mibbit@moz-7A900440.fda.gov)
[14:26:04] <bstrie> sw17ch: we always say so, yeah. technically we're affine rather than linear, and borrowed pointers kinda throw a wrench in there, but we don't really care about being pedantic
[14:26:04] <nmatsakis> sw17ch: rust incorporates a linear type system yes
[14:26:11] <nmatsakis> wel, yes, affine
[14:26:45] <nmatsakis> sw17ch: I don't know what "resolving the lifetime in the type system" means
[14:26:53] <nmatsakis> sw17ch: so I'm not sure why it should be hard
[14:27:03] <nmatsakis> sw17ch: but I think this example would work fine, I can at least mock up how it would look in a gist in a bit
[14:27:26] *** Joins: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP)
[14:27:59] *** Quits: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net) (Quit: Jesse)
[14:28:09] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[14:28:28] <sw17ch> nmatsakis: my understanding was that many objects have various aspects of their lifetime proven by the type system such that it can demonstrate borrowed pointers are being used safely and they won't be in danger of accessing things that are no longer valid.
[14:28:39] <nmatsakis> sw17ch: right
[14:28:55] *** Quits: huseby (huseby@moz-4E8C421A.husebyhome.com) (Ping timeout)
[14:28:56] <sw17ch> and if multiple tasks are figuratively borrowing from the same set -- even if the set is immutable -- resolving how long the set must live in the type system may be difficult.
[14:29:07] <sw17ch> (or maybe it's not?)
[14:32:14] <pauls> mark_edward_: Rust's macros aren't based on any one particular paper.
[14:32:37] <bstrie> pauls: sounds like someone needs to write a paper, then
[14:33:13] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[14:33:27] <pauls> The hygiene is roughly the algorithm from Syntactic Abstraction in Scheme, I believ3e
[14:33:45] <pauls> And the plural pattern matching comes from Macro By Example.
[14:34:27] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[14:34:34] *** Joins: Larry (larryfox@moz-343B6F0C.nyc.biz.rr.com)
[14:34:37] <pauls> bstrie: but yes, I believe a paper will likely happen
[14:34:40] <sw17ch> nmatsakis: ^^
[14:35:07] *** Joins: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[14:36:03] *** Joins: Skif (emschwar@moz-CA025D57.ip.mcleodusa.net)
[14:38:35] <nmatsakis> sw17ch: it would be for general tasks
[14:38:50] <nmatsakis> sw17ch: you'll note that the API I descirbed never mentioned tasks
[14:38:58] <sw17ch> oh, good point.
[14:38:59] <nmatsakis> sw17ch: that is, the tasks are under the hood
[14:39:05] <nmatsakis> sw17ch: that is precisely for this reason
[14:39:11] <nmatsakis> and for others besides
[14:40:11] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Ping timeout)
[14:41:37] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[14:43:22] *** Quits: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[14:43:25] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[14:44:16] *** Joins: maik (maik@moz-F4777195.dip0.t-ipconnect.de)
[14:44:41] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[14:44:56] *** Quits: fabiand (fabiand@moz-4459CD86.adsl.alicedsl.de) (Quit: Verlassend)
[14:46:19] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[14:47:11] *** Joins: ozten (ozten@27551158.9B2351E6.D10F2B03.IP)
[14:47:17] <wakandan> hi there 
[14:47:29] <wakandan> in format.rs I want to remove usages of Either<uint, @str>
[14:47:52] <wakandan> I was introducing an enum in rt.rs to do that 
[14:47:53] <bstrie> wakandan: is that the code for the new format!() macro?
[14:47:54] <wakandan> pub enum PluralSelector{     Keyword(parse::PluralKeyword),     LiteralNumber(uint) }
[14:48:08] <wakandan> I am not really sure 
[14:48:11] <wakandan> i'm pretty new 
[14:48:43] <wakandan> how do I verify that?
[14:49:46] <bstrie> hm, from the commit messages I'm pretty sure it is. just wanted to make sure you weren't trying to improve the old, soon-to-be-removed formatter :)
[14:49:48] <cmr> wakandan: format.rs where?
[14:50:02] <bstrie> cmr: src/libsyntax/ext/format.rs
[14:50:23] <bstrie> wakandan: acrichto is the one behind that code, perhaps he can guide you better
[14:50:58] <wakandan> bstrie: yeah he was helping me on my commit 
[14:51:03] <wakandan> bstrie: but he's offline now :(
[14:51:22] <cmr> he should be sleeping
[14:51:29] <bstrie> 2:51 AM in new zealand
[14:51:37] <wakandan> oh my god :(
[14:51:47] <wakandan> it's 22:51 in singapore here
[14:51:48] <dbaupp> bstrie: (acrichto is in the US?)
[14:51:51] <wakandan> no wonder
[14:52:03] <dbaupp> cmr: I'll be away over the weekend, but feel free to hack on/push to multibuilder
[14:52:03] <bstrie> dbaupp: ...are you sure
[14:52:08] <dbaupp> bstrie: no
[14:52:13] <cmr> dbaupp: I'm workin' on it now
[14:52:29] <wakandan> is there any good tutorial on rust?
[14:52:30] <bstrie> haha
[14:52:30] <olsonjeffery> i was under the impression that acrichto was in the bay area
[14:52:35] <olsonjeffery> was/is
[14:52:40] <bstrie> dbaupp: you're right, he's not one of the new zealanders
[14:52:49] <bstrie> according to his github profile he's in pittsburgh
[14:52:49] <wakandan> something like "dive into python" for python may be 
[14:52:58] <bstrie> my bad
[14:53:04] *** Quits: jaen (jaen@moz-5144DFA7.neoplus.adsl.tpnet.pl) (Ping timeout)
[14:53:12] <cmr> wakandan: not particularly, no
[14:53:16] <wakandan> i read through rust tutorial but at the end I feel like I don't know anything
[14:53:18] <wakandan> :((
[14:53:31] <cmr> http://www.rustforrubyists.com/ might help, but it's a bit out of date.
[14:53:37] <bstrie> wakandan: awesome, so you're exactly as wise as socrates :)
[14:53:46] <wakandan> the concepts are mostly new to me 
[14:53:56] <bstrie> we're glad that the rust tutorial has helped you achieve enlightenment
[14:53:59] <wakandan> so you mean the socrates are wise but don't know anything?
[14:54:05] *** Quits: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net) (Ping timeout)
[14:54:05] <wakandan> omg : ))
[14:54:13] <wakandan> I never said that lol
[14:54:28] <bstrie> wakandan: https://en.wikipedia.org/wiki/I_know_that_I_know_nothing
[14:54:38] <olsonjeffery> announcement for anyone who will be around tonight in the 9-12 PDT timeframe: im gonna do a dry run of my talk that im doing on the 28th.. very rough. would appreciate anyone who's available and willing to drop in and roast me
[14:54:48] <olsonjeffery> will do a hangout or maybe a webrtc screenshare via talky.io
[14:55:06] <olsonjeffery> 9pm-to-midnight PDT, i should say
[14:55:34] <cmr> olsonjeffery: I'll be around
[14:55:41] <olsonjeffery> ill probably do another one next friday, as well
[14:55:45] <cmr> Well, I'll make sure I'm around, rather :P
[14:55:46] <olsonjeffery> after ive had some time to lick my wounds
[14:56:05] <wakandan> bstrie: I don't think I should be happy about that
[14:56:17] <bstrie> wakandan: you're now the wisest person in greece!!
[14:56:32] <bstrie> except maybe for nmatsakis
[14:57:00] *** Joins: vodik (simon@moz-CBE4BB13.cable.teksavvy.com)
[14:57:29] <bstrie> olsonjeffery: that's like midnight EST, right? I should be around by then
[14:57:40] <wakandan> olsonjeffery: "tonight" is 20th?
[14:57:46] <olsonjeffery> midnight to 3AM, yes
[14:57:56] <wakandan> damn it I can't get used to all the timezones :|
[14:57:59] <olsonjeffery> wakandan: it's currently ~8AM PDT.. so in 13 hours
[14:58:07] <wakandan> ah ok 
[14:58:18] *** Quits: ozten (ozten@27551158.9B2351E6.D10F2B03.IP) (Quit: ozten)
[14:58:21] <wakandan> olsonjeffery: so it should be 12:00 pm in my time zone
[14:58:24] <bstrie> olsonjeffery: is your talk really scheduled to be three hours long?
[14:58:25] <wakandan> that would be great!
[14:58:29] <olsonjeffery> no, heh.
[14:58:51] <wakandan> olsonjeffery: but w8 what are you going to talk about?
[14:58:55] *** Joins: infynyxx_ (infynyxx@moz-E95B370B.nyc.res.rr.com)
[14:59:08] <olsonjeffery> probably in the 30-45 minute timeframe.. it's really rough. i want to mostly know what i said that was/is wrong, what i could add (within reason) and as a new(er) rust user, what you may have actually learned
[14:59:21] <wakandan> bstrie: so serious, how should I approach rust?
[14:59:22] <olsonjeffery> wakandan: im giving an intro-to-rust talk on the 28th to a bunch of heathens
[14:59:32] <bstrie> wakandan: what languages have you used in the past?
[14:59:33] <olsonjeffery> so this is preparation
[14:59:44] <wakandan> bstrie: there doesn't seem to be a lot of rust codes around
[14:59:57] <wakandan> olsonjeffery: oh nice, may be exactly what I need!
[15:00:08] <bstrie> olsonjeffery: what sort of heathens
[15:00:37] <olsonjeffery> bstrie: it's in redmond, wa.. so a heavy .net developer population.. but it's an open-minded event and there's lots of non-.net stuff..
[15:00:37] *** Quits: infynyxx_ (infynyxx@moz-E95B370B.nyc.res.rr.com) (Ping timeout)
[15:00:41] <wakandan> bstrie: c, mostly python, java in school, js at work 
[15:00:44] * flaper87 will try to be there
[15:00:51] *** Joins: wilmoore (wilmoore@moz-1248C037.mystrotv.com)
[15:00:51] <olsonjeffery> definitely more businessy-application types
[15:00:53] <olsonjeffery> maybe a actual plumbers, who knows..
[15:01:11] <wakandan> olsonjeffery: how can I see your talk?
[15:01:29] <olsonjeffery> wakandan: tonight? im going to do some kind of screenshare.. either a google hangout or webrtc via talky.io
[15:01:31] <kimundi> wakandan: It definitly possible to learn rust by just lurking reading code and reading/asking questions in this channel until you get a general feel for it :)
[15:01:42] <olsonjeffery> which allows screensharing if you're on chrome :/
[15:01:50] <flaper87> olsonjeffery: what about recording the hangout?
[15:01:53] <wakandan> bstrie: for python I think the way "dive into python" was the best
[15:02:06] <flaper87> you can share it in the list and delete it next week
[15:02:23] <sw17ch> Do Arcs run into problems with cycles?
[15:02:33] <olsonjeffery> flaper87: ill record the actual talk
[15:02:37] <wakandan> olsonjeffery: i'm on chrome but in ubuntu 
[15:02:40] <olsonjeffery> this is a pre-dress rehersal
[15:02:42] <wakandan> olsonjeffery: something might not work 
[15:02:43] <olsonjeffery> but really if everyone loves it
[15:02:50] <olsonjeffery> ill do a subsequent solo screencast and record it
[15:03:04] <olsonjeffery> im focused on preparing for this talk, though
[15:03:08] <olsonjeffery> which i need to survive
[15:03:21] <flaper87> olsonjeffery: yeah, I was just thinking about people not being able to attend the dry-run, if you record it, they can watch it off-line and provide feedback.
[15:03:25] <flaper87> I'll try to be there anyway
[15:03:27] <flaper87> :D
[15:03:30] <kimundi> olsonjeffery: Hm, I'm not sure I want to be awake at 6 am local time to hear your talk. :P
[15:03:34] <bstrie> olsonjeffery: as someone who's been furious at google hangouts lately, talky.io looks pretty interesting
[15:03:37] <wakandan> kimundi: most of the concepts are pretty similar to C, except some of them are brand new to me
[15:03:37] <flaper87> olsonjeffery: thanks for that
[15:03:58] <wakandan> kimundi: probably they are from haskell? or some other functional languages may be?
[15:04:13] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[15:04:16] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[15:04:23] <kimundi> wakandan: Then you even have an advantage against some other rust newcomers ;)
[15:04:48] <wakandan> kimundi: not really T_T
[15:04:52] *** Joins: bent (chatzilla@moz-932324BF.hsd1.ca.comcast.net)
[15:04:54] <kimundi> wakandan: Eh, you can see that as you want. Mostly it's the type system that's similar to haskell.
[15:05:09] <wakandan> kimundi: take for example, the ownership model and boxing 
[15:05:23] <wakandan> kimundi: oh no that what I afraid of T_T
[15:05:56] *** Quits: MauricioC (mauricioc@moz-2CFCD404.impa.br) (Ping timeout)
[15:06:18] <wakandan> kimundi: the only functional language I learned was scala and it helped a bit with pattern matching 
[15:06:36] <kimundi> wakandan: There's traits, and knowing that we don't have null in the language, the few specific syntactic constructs like pattern matching, the fact that you have to explicitly handle ownership instead of implicit like you'd do in C...
[15:07:51] *** Joins: eugals (Miranda@4EAF0513.DB0130CE.2613BDDB.IP)
[15:07:56] <wakandan> kimundi: yeah the idea of ownership is explain quite well in the tutorial, but I just can't frame it into some concrete use cases...
[15:08:06] <wakandan> kimundi: I guess it's for concurrent nature of rust perhaps?
[15:08:27] <sp3d> it's for memory safety without GC
[15:08:35] <kimundi> wakandan: Really, the easiest would be to just ask every time you don't understand a thing, and the tutorials/manuals didn't help
[15:08:57] <sp3d> it formalizes the notion of "you should free this return value" or "the function will free this argument" in C
[15:09:40] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[15:09:47] <kimundi> wakandan: See it like this: In C you can get busg, memory leaks, crashes etc if you mess up with pointers. These mess ups are ususally of the form "I used something in a way I shouldn't" or "I used something that doesn't exist anymore"
[15:09:49] <wakandan> if there's more explanation on the cases where these concepts are applicable that would be easier to understand I guess
[15:10:19] <wakandan> kimundi: uhm...that's right
[15:10:29] <kimundi> wakandan: Rusts approach to prevent those bugs is simply to encode _what_ you are allowed to do with in such situations
[15:10:49] <steveh> Anybody - having trouble separating tests from my main module into separate file, probably bc I don't understand modules/crates well.  A few Q's embedded in this gist https://gist.github.com/scharris/6638905.  See test_A.rs
[15:11:27] <kimundi> wakandan: So ownership, borrowing, freezing, sendability etc... Are all just things you already needed to know about for writing correct C. We just encode them explicitly in the type system
[15:11:30] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[15:12:01] <steveh> Oops remove dot at end of url
[15:12:05] <kimundi> ownership == "the one responsible for calling free"
[15:12:22] <kimundi> borrowing == "have a pointer to something while it lives"
[15:12:44] <kimundi> freezing == "make sure nothing modifies it"
[15:13:08] <kimundi> sendability == "make sure this can be used by concurrent code without introducing race condition"
[15:13:22] <sw17ch> wakandan: one use for ownership that would be nice in C is the concept of returning something that's initialized in a lower call frame
[15:13:36] <engla> kimundi: an important outcome to add to that list is silent corruption, since there is no guaratee in C that there will be some form of fatal consequence of incorrect code
[15:13:40] <sw17ch> normally, in C, we'll pass a pointer to the memory/object to be initialized to a lower call frame and expect that the callee has done its job.
[15:14:12] <sw17ch> in Rust, the callee can return a ~ pointer so that the caller doesn't have to allocate the memory ahead of time. yet the semantics are nearly identical to if the caller had allocated that memory on its own stack.
[15:14:15] <sw17ch> wakandan: ^^
[15:14:34] <sw17ch> (some one else correct me if i'm wrong)
[15:14:41] <wakandan> kimundi: that's easier to understand, I think I will do a re-read on rust tutorial but this time with a lot more questions
[15:14:42] <bstrie> steveh: hm, I'm pretty bad at modules myself, but let me see :)
[15:15:09] <kimundi> wakandan: That's a good way to learn rust :)
[15:15:13] <wakandan> sw17ch: can you explain to me the " lower call frame "..?
[15:15:26] <sw17ch> struct foo; init_a_foo(&foo);
[15:15:32] <sw17ch> init_a_foo is the lower call frame
[15:16:21] <sw17ch> in C, you could have create_a_foo() that dynamically allocates *and* frees the foo, but you don't have any guarantees about where else that memory will go.
[15:16:24] <bstrie> bah, I'm awful at this
[15:16:29] <sw17ch> Rust gives you a promise that the newly allocated memory only has one name.
[15:16:44] <bstrie> can anyone who knows anything about modules help answer steveh's question?
[15:16:54] <sw17ch> And, more importantly, since it only has one name, when the stack-frame that owns that pointer goes out of scope, we can safely traverse the ownership tree and free everything else.
[15:17:07] <sw17ch> wakandan: ^^
[15:17:30] <wakandan> sw17ch: @_@
[15:17:34] <sw17ch> I've said a lot of words that may be nonsense to a newcomer. I'm sorry.
[15:17:42] <wakandan> sw17ch: that's a lot of things to digest for me
[15:17:45] <sw17ch> (i'm new to rust myself, but i'm well versed in C and Haskell)
[15:17:51] <benh> steveh: I think you shoud say mod test_A; in A.rs and not have any mod lines in test_A.rs
[15:17:58] <benh> but I'm not a pro with modules either
[15:17:58] *** Quits: sk (sk@BC280AA6.273A3D3C.78DD174B.IP) (Quit: Leaving)
[15:17:59] <steveh> bstrie: thx anyway.  I've been limping along by what seems to me as "overdeclaring" modules - mentioning B's own dependencies when pulling in B from A, but when B has a native calls, I'm getting linker error.
[15:18:18] <wakandan> sw17ch: normally in C, we don't care about "where else that memory will go." right?
[15:18:26] <benh> so then you'll only have the A crate 
[15:18:32] <sw17ch> Oh, but we do.
[15:18:32] <engla> sw17ch: in Rust, a function should normally return a value, and doesn't need to use ~. The caller can decide to put the return value into a ~ pointer
[15:18:39] <benh> instead of having one code-only crate and a tests-only crate that weirdly overlap
[15:18:44] <wakandan> sw17ch: or at least that's what I remember, we always use malloc() and stuff...
[15:18:47] <engla> sw17ch: let obj = ~Foo::create()  and so on
[15:19:08] <sw17ch> wakandan: malloc happens all the time, yes, but how do you determine who's responsible for freeing the malloced memory?
[15:19:33] <sw17ch> if a function just returns a freshly allocated object, that pointer escapes elsewhere into the program and other functions may not be aware of who's responsible for managing that resource.
[15:19:47] <sw17ch> engla: ah, thanks. i'm still new to the semantics.
[15:19:48] <steveh> benh: So its best to just put the code and tests in the same file?  Only problem with that for me is there are a lot of tests, I want to get them out of there
[15:19:59] <benh> In the same crate, not the same file
[15:20:08] <wakandan> sw17ch: yeah right, it relies on the caller to free the memory he used
[15:20:27] <steveh> benh: OK I'm just lacking knowledge how to do that.
[15:20:28] <engla> sw17ch: in  let obj = ~Foo::create(), the memory will be allocated before the function call, and the pointer passed to Foo::create for it to write the return value into. It's neat
[15:20:31] <sw17ch> wakandan: correct. that's a tremendous burden on the caller. especially if that caller is going to repackage the pointer and give it to some one else.
[15:20:35] <benh> see for example rust/src/librustpkg/
[15:20:57] <benh> there is rustpkg.rs which (I figure) is the main file in the crate, it declares all the other modules, including 'tests' which includes all the tests
[15:21:00] <sw17ch> engla: and that's just absolutely glorious because it entirely frees the user from having to manage how that happens.
[15:21:03] <benh> and is physically in tests.rs
[15:21:04] <wakandan> sw17ch: then he has to make sure that "someone else" doesn't tamper with the memory allocation as well!
[15:21:13] <sw17ch> wakandan: yes, it's an awful mess :)
[15:21:21] <sw17ch> i generally avoid malloc in my c programs whenever possible
[15:21:31] <sw17ch> or i ensure that memory is only ever allocated and freed by the same function
[15:22:01] <steveh> benh: Thanks I'll study that.  With that approach, is it possible to run tests with "rust test ..."?
[15:22:14] <benh> steveh: basically you only ever want to pass one source filename in your crate to rustc, so you'd run the tests by pointing at A.rs, which says "mod test_A;", and it'll hopefully find the tests in test_A.rs
[15:22:15] <sw17ch> void foo(void) { void * x = malloc(â€¦); do_something_with_p(x) free(x); }
[15:22:19] <sw17ch> wakandan: ^^
[15:22:31] <benh> that or rustc --test A.rs, i think
[15:22:32] <sw17ch> wakandan: this pattern is, of course, a burden in many cases.
[15:22:42] <sw17ch> wakandan: but Rust neatly sidesteps this problem with ownership.
[15:22:51] *** Joins: anshin (anshin@CD85F10D.F21429E2.354459FA.IP)
[15:23:04] <steveh> benh: that looks like what I need then, thanks
[15:23:19] <sw17ch> (again, some one else slap my hands if i got this wrong)
[15:23:19] <benh> I hope I got this right, I'm not 100% certain
[15:23:36] <wakandan> sw17ch: so in rust if a variable owns an mem allocation, if the variable goes out of scope then the memory will be cleaned up as well. Is that correct?
[15:23:40] *** Joins: jeaye (Jeaye@moz-34FEF2BB.hsd1.ca.comcast.net)
[15:23:45] <steveh> benh: no formal support contract here, understood :)
[15:23:53] *** Joins: adridu59 (Mibbit@moz-6C393FDD.rev.numericable.fr)
[15:24:02] <adridu59> hey guys; how can I do a pause in Rust?
[15:24:06] <adridu59> like press a key to continue
[15:24:07] <sw17ch> wakandan: yes, i'm pretty sure that's the case. since memory can only have one name, any other names that it owns are guaranteed to only also exist by that name.
[15:24:32] <sw17ch> so, when a name is deallocated, all names it references can also safely be deallocated.
[15:24:38] <bstrie> adridu59: on the command line, you mean?
[15:24:59] <adridu59> yup
[15:25:07] <bstrie> good question :)
[15:25:11] <bstrie> <-- not helpful today
[15:26:11] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[15:26:11] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/zyEoCw
[15:26:11] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[15:26:12] <benh> use std::io::ReaderUtil; std::io::stdin().read_line() might get you close enough
[15:26:26] *** Joins: penguin_dan (dan_johnsi@6902762D.11B071D.FB9A45AF.IP)
[15:26:27] *** Quits: maik (maik@moz-F4777195.dip0.t-ipconnect.de) (Ping timeout)
[15:26:30] <adridu59> yea good one
[15:26:44] <dbaupp> rusti: std::io::stdin().read_line()
[15:26:49] -rusti- timeout triggered!
[15:26:56] <dbaupp> (it seems to work ok)
[15:26:59] <wakandan> sw17ch: thank you so much, it's much more clear now
[15:27:01] <adridu59> haha
[15:27:02] *** Joins: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net)
[15:27:13] <wakandan> in the docs
[15:27:15] <benh> caveat that it's not "press a key" but "press return", i guess
[15:27:30] <sw17ch> wakandan: happy to help. i work in C all day on embedded microprocessors. Rust is a tremendous relief from the mental effort I spend trying to keep things safe and maintainable.
[15:27:35] <wakandan> struct Foo { child: Option<Foo> }  --> The following struct won't compile, because the lack of indirection would mean it has an infinite size:
[15:27:56] <sw17ch> wakandan: this is the same in C. struct foo { struct foo; };
[15:28:02] <dbaupp> https://github.com/mozilla/rust/pull/9362 r?/comments (more cleanup & then additions to come later)
[15:28:07] <wakandan> sw17ch: if only what you said is mentioned in rust's docs
[15:28:21] <sw17ch> can you link to the location in the docs?
[15:28:23] <wakandan> sw17ch: since I don't have much exp with C, it's hard to appreciate something like that
[15:29:04] <wakandan> sw17ch: http://static.rust-lang.org/doc/0.7/tutorial.html#boxes, in 9.1 Own Box
[15:29:06] *** Quits: sebcrozet (sebcrozet@moz-C27D92D8.w193-252.abo.wanadoo.fr) (Ping timeout)
[15:29:07] <wakandan> Owned*
[15:29:12] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[15:30:13] <wakandan> sw17ch: I was guessing, because rust variable are "literal" mem allocation by itself (excuse my choice of words)
[15:30:20] <adridu59> how do I parse command line switches?
[15:30:34] <bstrie> adridu59: I think there's an optparse module somewhere
[15:30:34] <adridu59> I know about args but I want to parse a switch
[15:30:37] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[15:30:47] <wakandan> sw17ch: declaring something like that means you can have infinite levels of mem blocks at the same location
[15:30:53] *** Joins: NewGuy (Mibbit@moz-E759CEF9.resnet.usf.edu)
[15:31:01] <NewGuy> rusti: println("iÌ†Ì’ÌštÍ§Ì‚Í†Í«Ì„ ÌƒÍ¬Í—ÌÌ‚cÌˆÍ’ÌŠoÌƒÍ‘Ì“Í©Í¦Í’mÌŠÍ—ÌÌ’esÍ©Í›!Í¨Ì€Í©Ì€Í†Ì„Ìš iÌ†Ì¿ÌˆÌÌ€Í®Í‘tÍ¦Í‚Ì‰Ì’Ì”Ì‡ Ì“coÍ›ÌÌ¾Í¤Ì„Ì‰ÍŒmÍ‚Í†Ì€Í«eÍ›Í¨ÍŒÌ‡Í†Í£Í¥sÍ‚!Ì‡ÌŒÌŽÌ†");
[15:31:03] -rusti- pastebinned 2 lines of output: http://sprunge.us/GUBg
[15:31:03] <dbaupp> adridu59: extra::getargs
[15:31:14] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[15:31:14] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/2OkLEQ
[15:31:14] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[15:31:15] <wakandan> sw17ch: which is hard for allocation?
[15:31:16] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[15:31:16] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/vfmVfQ
[15:31:16] <ghrust> 13rust/06auto 14806105f 15Steve Klabnik: Fix usage for rustpkg init...
[15:31:16] <ghrust> 13rust/06auto 14f447972 15bors: auto merge of #9337 : steveklabnik/rust/rustpkg_usage, r=catamorphism...
[15:31:16] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[15:31:22] *** Quits: NewGuy (Mibbit@moz-E759CEF9.resnet.usf.edu) (Quit: http://www.mibbit.com ajax IRC Client)
[15:31:26] <dbaupp> adridu59: sorry, extra::getopts
[15:31:39] <sw17ch> wakandan: it's like a book that holds itself. to do that, the book would be of infinite size.
[15:31:56] <sw17ch> wakandan: it's impossible :)
[15:32:06] <sw17ch> it's a thing that is without a calculable size.
[15:32:10] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[15:32:24] <sw17ch> struct foo { int x; struct foo y; };
[15:32:53] <olsonjeffery> no plan survives first contact with the enemy
[15:32:53] *** Joins: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[15:32:53] <sw17ch> struct foo f; f.x = 1; f.y.x = 2; f.y.y.x = 3; f.y.y.y.x = 4; ...
[15:33:03] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[15:33:29] <wakandan> sw17ch: so how does rust help solving that with ~?
[15:33:49] *** Quits: StarLight (StarLight@moz-7FA5607.dynamic.avangarddsl.ru) (Ping timeout)
[15:33:56] <sw17ch> struct foo { int x; struct foo * next; };
[15:34:00] *** Joins: nejucomo (Adium@moz-A94CACD5.dsl.pltn13.sbcglobal.net)
[15:34:02] <sw17ch> struct foo f; struct foo g;
[15:34:11] <wakandan> sw17ch: ah
[15:34:12] <sw17ch> f.x = 1; f.next = &g;
[15:34:15] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[15:34:32] <sw17ch> except that rust can guarantee to us that we don't have the dangling invalid pointer.
[15:34:49] *** Quits: vodik (simon@moz-CBE4BB13.cable.teksavvy.com) (Ping timeout)
[15:35:27] <wakandan> sw17ch: so each foo will be created separately instead of chunking altogether at one place, is that correct?
[15:36:15] <wakandan> sw17ch: "we don't have the dangling invalid pointer." --> is that because of the ownership thing? there must be something more than that I guess?
[15:36:45] <sw17ch> wakandan: there is. we could setup the same situation with malloc in c by using recursion or a carefully executed loop.
[15:36:51] *** Joins: pnkfelix1 (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[15:36:57] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Connection reset by peer)
[15:37:03] <sw17ch> but we'd *ALSO* need a union type to perform this
[15:37:48] <sw17ch> In essence, what we're building in this case is a linked list. In Haskell (and probably scala?) we encode Linked Lists as a (Cell v) and some (Nil) or (Tail)
[15:37:58] <sw17ch> which is a hint that there's no more pointers.
[15:38:03] <sw17ch> this is a little confusing i'm sure
[15:38:15] *** Joins: StarLight (StarLight@moz-4AA9DA20.dynamic.avangarddsl.ru)
[15:38:19] <wakandan> sw17ch: yeah correct, it's the case in scala :)
[15:38:40] <wakandan> sw17ch: i'm interested in this point "but we'd *ALSO* need a union type to perform this"
[15:39:09] <wakandan> sw17ch: is that to make sure that the list terminate just like you said?
[15:39:48] <wakandan> sw17ch: I imagine the union type will have either nil or foo as their members?
[15:39:56] <sw17ch> Right. So, either you need some extra bit of data to indicate that the trailing pointer isn't valid, or one has to check if the pointer is NULL.
[15:40:21] <nmatsakis> in fact, `struct Foo { f: ~Foo }` is illegal -- you need `struct Foo { f: Option<~Foo> }`
[15:40:26] <sw17ch> I only point out the union type because it's another way to handle a circumstance similar to what i'd talked about. think about the option types.
[15:40:45] <sw17ch> nmatsakis: oh good point. that's still infinite allocation. :)
[15:40:48] <nmatsakis> rusti: struct Foo { f: ~Foo }
[15:40:48] -rusti- <anon>:7:9: 7:31 error: this type cannot be instantiated without an instance of itself; consider using `Option<main::Foo>`
[15:40:48] -rusti- <anon>:7          struct Foo { f: ~Foo }
[15:40:48] -rusti-                   ^~~~~~~~~~~~~~~~~~~~~~
[15:40:48] -rusti- error: aborting due to previous error
[15:40:49] -rusti- application terminated with error code 101
[15:41:05] <sw17ch> since Rust guarantees that f won't be null
[15:41:07] <sw17ch> right?
[15:41:09] <nmatsakis> yes
[15:41:13] <sw17ch> ah, learning is fun
[15:41:22] <nmatsakis> rusti: struct Foo { f: Option<~Foo> }
[15:41:23] -rusti- ()
[15:41:41] *** Quits: anshin (anshin@CD85F10D.F21429E2.354459FA.IP) (Client exited)
[15:41:43] <wakandan> so how does rust represent an empty list of example? (using option...)
[15:42:13] <wakandan> nmatsakis: how do you do that???? that's cool
[15:42:23] <wakandan> "rusti"???
[15:42:32] <bstrie> wakandan: rusti is a robot that runs rust code
[15:42:41] <bstrie> rusti: "hello, wakandan"
[15:42:42] -rusti- "hello, wakandan"
[15:42:46] <wakandan> bstrie: wow, i'm really impressed now lol 
[15:42:59] <wakandan> rusti: "this is cool!"
[15:43:00] -rusti- "this is cool!"
[15:43:02] <nmatsakis> wakandan: a list of `Foo` would (typically) be the type `~[Foo]`
[15:43:05] <wakandan> doesn't work?
[15:43:17] <wakandan> oh yeah it works 
[15:43:18] <SimonSapin> wakandan: a linked list that can be empty would be enum List { Empty, Node(value, ~List) }
[15:43:19] <wakandan> lol 
[15:43:22] <bstrie> rusti: print("I can run functions too");
[15:43:23] -rusti- I can run functions too()
[15:43:36] <bstrie> rusti: print("I can run functions too, and then I return whatever the last value is"); 4
[15:43:37] -rusti- I can run functions too, and then I return whatever the last value is4
[15:43:37] <sw17ch> rusti: strut SomeList<T> { d: T, next: Option<~SomeList>}
[15:43:38] -rusti- <anon>:7:15: 7:23 error: expected one of `; }` but found `SomeList`
[15:43:38] -rusti- <anon>:7          strut SomeList<T> { d: T, next: Option<~SomeList>}
[15:43:38] -rusti-                         ^~~~~~~~
[15:43:38] -rusti- application terminated with error code 101
[15:43:52] <sw17ch> oops
[15:43:55] <bstrie> wakandan: but if you want to play with rusi extensively, please take it to private message :)
[15:44:03] <sw17ch> rusti: strut SomeList<T> { d: T; next: Option<~SomeList>}
[15:44:04] -rusti- <anon>:7:15: 7:23 error: expected one of `; }` but found `SomeList`
[15:44:04] -rusti- <anon>:7          strut SomeList<T> { d: T; next: Option<~SomeList>}
[15:44:04] -rusti-                         ^~~~~~~~
[15:44:04] -rusti- application terminated with error code 101
[15:44:04] *** Quits: canhtak (jeremy@moz-44AEB22E.wl.t.ulaval.ca) (Quit: canhtak)
[15:44:06] <wakandan> bstrie: haha yeah I will
[15:44:12] <bstrie> sw17ch: same for you!!
[15:44:13] <sw17ch> rusti: struct SomeList<T> { d: T; next: Option<~SomeList>}
[15:44:13] -rusti- pastebinned 6 lines of output: http://sprunge.us/SYVM
[15:44:19] <sw17ch> bstrie: 
[15:44:21] <sw17ch> oops, sorry
[15:44:23] <bstrie> :P
[15:44:28] <pnkfelix1> rusti: enum L { Cons(int, ~L), Nil }; Cons(3, ~Cons(2, ~Cons(1, ~Nil)))
[15:44:29] -rusti- Cons(3, ~Cons(2, ~Cons(1, ~Nil)))
[15:44:40] *** pnkfelix1 is now known as pnkfelix
[15:44:58] <wakandan> SimonSapin: hmm I don't quite understand List { Empty, Node(value, ~List) }
[15:45:16] <pnkfelix> wakandan: its analogous to the one I just sent to rusti
[15:45:25] *** Joins: maik (maik@moz-F4777195.dip0.t-ipconnect.de)
[15:45:27] <SimonSapin> better, enum List<T> { Empty, Node(T, ~List) }
[15:45:29] <nmatsakis> easier than that would just be `struct List { value: ..., next: Option<~List> }`
[15:45:34] <nmatsakis> though they are pretty much equivalent
[15:45:38] <wakandan> what exactly does struct Foo { f: Option<~Foo> } represent then?
[15:45:39] <sw17ch> wakandan: --> struct SomeList<T> { d: T, next: Option<~SomeList<T>>}
[15:45:49] <wakandan> sw17ch: @_@
[15:45:49] <sw17ch> That's mine.
[15:45:54] <SimonSapin> nmatsakis: but that you have to use Option<List> everywhere if you want to support empty lists
[15:45:55] <wakandan> now it's getting out of control lol
[15:46:11] *** Quits: adridu59 (Mibbit@moz-6C393FDD.rev.numericable.fr) (Quit: http://www.mibbit.com ajax IRC Client)
[15:46:14] <kimundi> wakandan: A few clarifications about local variables: We never have hidden indirection. If a local variable has some type T, then it always allocated on the stack. A ~T behaves almost the same as a T on the stack, but allows you to a) explicitly introduce indirection, like for making an infinite type not-infinite and b) move the ~ pointer around the stack frames.
[15:46:47] <kimundi> that is, the T in a ~T is allocated on the heap
[15:46:54] *** Quits: cdidd (cdidd@moz-891D929.broadband.corbina.ru) (Input/output error)
[15:47:10] <kimundi> And the ~T has an destructor that frees the memory if T once the ~T goes out of scope
[15:47:27] <kimundi> of T*
[15:47:34] <wakandan> kimundi: ah, right
[15:47:37] <nmatsakis> SimonSapin: that is true. Perhaps "type List<T> = Option<ListItem<T>>; struct ListItem<T> { value: T, next: List<T> }" is ideal :)
[15:48:00] <wakandan> kimundi: what about @T?
[15:48:09] <wakandan> kimundi: it was very confusing to me
[15:48:11] <kimundi> wakandan: An Option<T> is a generic type in the std library. It is an enum that can have one of two possible values: None or Some(T)
[15:48:59] <SimonSapin> nmatsakis: yeah, thatâ€™s basically the same
[15:49:06] <kimundi> So, you either have No value, or a value T embedded in the Option
[15:49:25] <kimundi> which allows you to explicitly construct a "nullable" pointer in a way
[15:50:04] <wakandan> kimundi: so struct Foo { child: Option<~Foo> } looks like a list of pointers with no data?
[15:50:15] <nmatsakis> SimonSapin: mildly more efficient space-wise I think, since you represent an empty list as null ptr
[15:50:29] <kimundi> wakandan: A @T is a manged pointer. Basically, unlike ~ which has deterministic memory cleanup, a @T represents an garbage collected value
[15:51:12] <kimundi> wakandan: It's a struct whose field child can either be 'None' or 'Some(~Foo)'
[15:51:46] <kimundi> wakandan: The last element of a list would contain a None to signal that there is no next node
[15:52:15] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[15:52:26] <wakandan> kimundi: can I say that @T is generally gc managed?
[15:52:37] <kimundi> wakandan: Ah, no I understood the question - yes it would be a list of pointers without actual data per node
[15:52:40] <kimundi> now*
[15:52:57] <wakandan> kimundi: something like, if it's no longer in use gc will clean it up?
[15:53:27] <wakandan> kimundi: ah right :) I suspected that much but that "~" caught me
[15:53:40] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[15:53:54] <kimundi> wakandan: The semantic of @T is that it is a task local garbage collected heap allocation. Multiple places can hold a @T that points to the same T, unlike ~T.
[15:54:10] *** Quits: eugals (Miranda@4EAF0513.DB0130CE.2613BDDB.IP) (Ping timeout)
[15:54:18] <sw17ch> kimundi: @T's can be traded across tasks either, correct?
[15:54:18] <wakandan> sw17ch: now that you mentioned it, it's true actually in C we have to have that * thingy to declare it properly 
[15:54:24] <wakandan> sw17ch: how could I forget that 
[15:54:31] <sw17ch> wakandan: it's not obvious immediately. :)
[15:54:52] <kimundi> wakandan: right, no longer in use - cleanup. Currently its implemented as reference counting under the hood, but we will have a tracing garbage collector
[15:55:16] <wakandan> kimundi: why make this distinction? it feels to me nowayday everyone is using @T in there language, correct?
[15:55:46] <engla> dbaupp: sent one incorrect comment for your gen_integer_range, but I removed it again :)
[15:55:50] <wakandan> kimundi: what's 
[15:55:55] <wakandan> kimundi: what's "right, no longer in use - cleanup"*
[15:55:56] <sw17ch> wakandan: some of us (me in particular) have substantial issues with garbage collection. explicit control of the lifetime of an object is very important to my work.
[15:56:25] <engla> dbaupp: well it wasn't incorrect, it just didn't mention that your code accounted correctly for that case
[15:56:43] <kimundi> wakandan: He, yeah. But a lot of people use C/C++ because that means you're not forced to be dependant on an garbage collector that randomly stalls your program and eats a lot of unneccessary memory
[15:57:02] <sw17ch> kimundi: yes. exactly this.
[15:57:09] <wakandan> sw17ch: yeah right, I kept forgetting that. I'm also doing some low level coding before but school never goes this deeply
[15:57:27] <sw17ch> wakandan: i'm working on an STM8 processor right now. 8 bits, virtually no RAM. :)
[15:57:31] <wakandan> kimundi: sw17ch understands this best :)
[15:57:32] <sw17ch> memory is precious as is timing.
[15:57:43] <dbaupp> engla: thanks for the comments; I'll fix up tomorrow/later :)
[15:58:04] <kimundi> wakandan: A @T that no one points at will be freed() "sometime afterwards" - no stronger guarantee possible. ~T and extra::Rc will be freed() exactly in the moment where all references go out of scope.
[15:58:05] <wakandan> sw17ch: the worst I worked on in uni was an h8 microcontroller
[15:58:22] <wakandan> sw17ch: but that's nothing compare to your s I guess T_T
[15:58:51] <sw17ch> kimundi: the semantics around memory management in Rust were what hooked me.
[15:59:11] <wakandan> kimundi: now it starts to bug me, why "sometime afterwards" 
[15:59:28] <wakandan> kimundi: I mean, in what use cases is this distinction is important?
[15:59:31] <kimundi> wakandan: The cool thing about a ~T is that it's destruction is completely deterministic. It doesn't need any reference counts or so: The compiler knows exactly where to insert the malloc() and free()
[15:59:56] <wakandan> kimundi: yeah, that "~" seems clearer to me now
[16:00:00] <benh> Is @ actually GC-backed right now or is it still counting references?
[16:00:03] <kimundi> wakandan: There are different scenarios where garbage collection performs better than other schemes
[16:00:06] <wakandan> kimundi: 
[16:00:11] *** Joins: canhtak (jeremy@moz-44AEB22E.wl.t.ulaval.ca)
[16:00:25] <wakandan> kimundi: "~" is good and because it's isolated, it can be shared. is that correct?
[16:00:30] <wakandan> kimundi: ah!
[16:00:47] <wakandan> kimundi: memory is such a complicated matter
[16:01:30] *** Quits: maik (maik@moz-F4777195.dip0.t-ipconnect.de) (Ping timeout)
[16:01:30] *** Quits: nano (nano@moz-74CAD1CA.superkabel.de) (Connection reset by peer)
[16:01:37] <wakandan> honestly rust syntax made me sweat
[16:01:44] <kimundi> wakandan: right. because only there only ever exist one ~T that points at the same T, it can be put wherever you want. In data structures, into other threads, etc
[16:01:52] <wakandan> but now you explained all of them, I can't think of any better way of doing that
[16:03:46] <kimundi> wakandan: Our syntax seems more complicated at first glance, but that mostly just a combination of 1) foreign constructs like match 2) necessaries to encode more information like in the case of lifetimes. 3) Sugar: ~T is what C++ calls an uniqe_ptr<T>
[16:03:51] <wakandan> ~ has ownership is that correct?
[16:04:35] <kimundi> wakandan: An ~ ptr owns what is contained in it, and can itself be owned.
[16:04:54] <wakandan> kimundi: I love pattern matching from scala
[16:05:13] <wakandan> kimundi: but @ doesn't have ownership..?
[16:05:16] <sw17ch> I've found match in rust to do everything I need.
[16:05:46] <wakandan> sw17ch: now I started to get why you love rust
[16:05:54] <kimundi> 'owners' are: local variables, and types that own other types
[16:05:57] *** Quits: canhtak (jeremy@moz-44AEB22E.wl.t.ulaval.ca) (Ping timeout)
[16:06:15] <sw17ch> it makes my job easier. that's why i like Rust. (well, i hope it eventually makes my job easier.)
[16:06:37] <kimundi> wakandan: A @T owns the T inside it, and multiple places can own a @T to it. You could also see it as "the garbage collector owns the memory"
[16:07:10] <kimundi> wakandan: That is, all existing @T that point at the same T collectivly own the same value T
[16:07:24] <kimundi> shared ownership in a sense
[16:07:29] *** Joins: huseby (huseby@moz-4E8C421A.husebyhome.com)
[16:08:49] <wakandan> looks like something to be shared among tasks...?
[16:08:50] <kimundi> Again, you can see ownership as "who has the right to call free" - once all @T are gone, and the garbage collector notices it, it can call free()
[16:09:34] <kimundi> wakandan: It would be possible to implement an garbage collected pointer type that works across tasks, but @T is per-task only
[16:10:23] <kimundi> wakandan: It simplifies a lot of things: You don'T need an concurrent garbage collector that can "stop the world" to garbagecollect. Every task can decide to do that on their own
[16:11:01] <kimundi> However, we have a type in the extra libraries that allows sharing of data across tasks: Arc<T>
[16:11:04] *** Quits: skade (skade@30BBD5E6.505237C9.CAE22B62.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[16:11:36] <kimundi> It's a smartpointer that is atomically reference counted. So, you can share immutable data with it across tasks
[16:12:35] *** Joins: ozten (ozten@moz-DD3B00B4.hsd1.wa.comcast.net)
[16:12:43] <kimundi> There are plans to move @T out of the language and into it's own Gc<T> type precisily because of that: There are N ways how you might want to manage your memory, making any of them special by building them in is unneccessary
[16:13:34] <kimundi> (~T will most certainly stay though, as it is the most basic safe building block around malloc() and free())
[16:15:44] <wakandan> kimundi: thank you for a very detailed explanation 
[16:15:57] <wakandan> kimundi: it's clear to me now
[16:16:18] *** Joins: maik (maik@moz-A79D08D1.dip0.t-ipconnect.de)
[16:16:23] *** Quits: steveh (Mibbit@moz-7A900440.fda.gov) (Quit: http://www.mibbit.com ajax IRC Client)
[16:16:23] <wakandan> looking forward to olsonjeffery talk tmr to see what I've been missing
[16:19:05] <wakandan> btw can the tutorial/docs can be contributed?
[16:19:31] <wakandan> it would be very valuable to include what you have explained to me for new comers
[16:20:56] *** Joins: hoverbear (andrew@moz-D5078CE5.wireless.uvic.ca)
[16:21:35] *** Quits: maik (maik@moz-A79D08D1.dip0.t-ipconnect.de) (Ping timeout)
[16:21:56] *** Quits: Ralith (ralith@moz-36466B9F.customer.broadstripe.net) (Ping timeout)
[16:22:03] *** Joins: zeuxcg (zeuxcg@moz-CC994E88.mycingular.net)
[16:22:08] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[16:22:09] <kimundi> wakandan: Sure, they in the git repo
[16:22:38] <kimundi> wakandan: We'd jsut like to keep them language agnostic - Not base them on comparisons with other languages etc
[16:23:10] <kimundi> wakandan: Also, what I've explained might be wrong in subtle way that shouldn't be written down as is :)
[16:23:39] *** Joins: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net)
[16:23:48] <kimundi> But the tutorial/manual definitly needs improvements/ rewrites all over the place
[16:24:04] *** Joins: miza (miza@moz-908EA8DE.home.otenet.gr)
[16:24:32] <wakandan> kimundi: I feel that having some level of comparison is necessary though, it's just the way people learn new stuff
[16:25:08] <wakandan> kimundi: they reference new info with what they have already know to find analogy and association, make it easier to remember and understand...
[16:25:15] *** Quits: zeuxcg (zeuxcg@moz-CC994E88.mycingular.net) (Ping timeout)
[16:25:29] <bjz> wakandan: there is a Rust for C++ programmers wiki page
[16:25:42] <wakandan> kimundi: and also, some feature of rust is hard to appreciate at first glance - like what I said to sw17ch ealier...
[16:26:04] <bjz> wakandan: I think language specific pages would be better, but they are hard to keep up to date atm
[16:26:13] <wakandan> bjz: ah!, I forgot that C++ is similar to C, what was I thinking :(
[16:26:22] <wakandan> uhm 
[16:26:39] <kimundi> wakandan: Definitely, but that should be secondary literature. At it'S core, the language stands on it's own and has independent reasons for design decisions.
[16:26:51] *** Joins: Lovot (root@AE31FB56.8153C3BF.F3C9A2D9.IP)
[16:26:51] <bjz> kimundi ++
[16:27:41] <kimundi> wakandan: Of course, "You can do the same stuff like in C++, but safe!" has a lot of pull behind it ;)
[16:27:42] <wakandan> I would be interested to learn more about usecases that led to those decision
[16:27:50] <wakandan> kimundi: haha true
[16:27:54] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Ping timeout)
[16:28:11] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[16:28:18] <wakandan> kimundi: may be it's just me, but I find it very easy to understand a concept if there's some usecase/reason behind it
[16:28:29] <kimundi> wakandan: Well, the main usecase behind rust right now is to act as a language to write servo, the experimental browser engine of mozilla with
[16:29:02] <kimundi> "pointer bugs are a safety problem" -> "Let's use a language where pointers are safe"
[16:29:39] <wakandan> kimundi: that's nice, but it's 10000 feets above the ground T_T
[16:30:34] <kimundi> "performance needs to on C++ levels, but C++ is unsafe" -> "Let's use a language that has the same performance characteristics, but is safe"
[16:31:02] <cmr> wakandan: http://cmr.github.io/blog/2013/08/13/rust-by-concept/
[16:31:14] <kimundi> wakandan: Sorry, what do you mean with "10000 feets above the ground" ? Unfamiliar with that idiom. :)
[16:31:25] <sp3d> "it's a very broad view of the situation"
[16:31:34] <kimundi> True
[16:31:42] *** Joins: canhtak (jeremy@moz-44AEB22E.wl.t.ulaval.ca)
[16:31:46] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[16:32:49] *** Joins: NiccosSystem (NiccosSyst@AB1AFDE.FC7B0C35.A7597CB6.IP)
[16:33:09] <kimundi> wakandan: The goal of rust is to be completely memory safe, even in multitasking scenarios, without needing to resort to general tricks like "everything is garbage collected"
[16:34:21] *** Joins: spider-mario (spidermari@moz-2F72F6FF.dsl.quantic-telecom.net)
[16:35:02] *** Joins: doomlord_ (servitor@moz-2BA2D1DA.range86-184.btcentralplus.com)
[16:35:13] <nejucomo> The video on https://air.mozilla.org/2013-intern-todd/ freezes for me about every 3-4 minutes.  It's pretty frustrating.
[16:35:34] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[16:35:45] *** Joins: jxv (jxv@moz-8FB92450.lightspeed.irvnca.sbcglobal.net)
[16:35:47] <nejucomo> This happens even when the grey line extends past the play head marker, which I thought meant local cached...
[16:35:59] <wakandan> kimundi: nice
[16:36:12] <cmr> nejucomo: I download the videos locally then watch with vlc.
[16:36:13] <cmr> It's easier.
[16:36:25] <nejucomo> Good idea.
[16:36:39] <cmr> In firefox you can right click on the video element and copy video location
[16:36:49] <cmr> (it's https://vid.ly/7u9h9k?content=video&format=webm)
[16:37:13] <nejucomo> I used to download videos religiously, then I got lazy a year or two ago...
[16:37:21] <nejucomo> Thanks.
[16:37:26] *** Joins: alp (alp@moz-D1CEC204.com)
[16:38:26] <wakandan> nejucomo: that guy is an intern?
[16:38:30] <cmr> wakandan: was
[16:38:39] <cmr> it's toddaaro
[16:38:57] <wakandan> where's he now?
[16:39:05] <wakandan> may be I should watch it tmr
[16:40:45] *** Quits: alp (alp@moz-D1CEC204.com) (Quit: FLAG_FIN)
[16:40:52] <nejucomo> Interesting.  When I try to jump to the time at which the video froze, the VLC rendering window disappears and only the playlist remains.
[16:41:01] <cmr> ...huh
[16:41:06] <cmr> I wonder if the video got corrupt?
[16:41:10] * nejucomo wonders if vlc and firefox share a video rendering library.
[16:41:26] <nejucomo> Ah well, I should focus on day job anyway.
[16:41:36] *** Joins: alp (alp@moz-D1CEC204.com)
[16:46:23] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[16:47:11] *** Quits: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net) (Quit: dave1629)
[16:47:59] *** Quits: Jessin (Jessin_@moz-C8BB4444.cc.lehigh.edu) (Ping timeout)
[16:48:14] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[16:48:14] *** Joins: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net)
[16:49:35] *** Joins: radarsat1 (uid2860@moz-31ABA2C0.irccloud.com)
[16:51:09] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[16:51:09] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/vfmVfQ
[16:51:09] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[16:51:39] *** Joins: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP)
[16:51:39] *** ChanServ sets mode: +o jdm
[16:52:11] *** Joins: lenstr (lenstr@E0E80B8D.ED45D46B.DFEAE789.IP)
[16:52:23] *** Joins: Jessin (Jessin_@moz-C8BB4444.cc.lehigh.edu)
[16:53:34] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[16:53:34] *** Quits: lenstr (lenstr@E0E80B8D.ED45D46B.DFEAE789.IP) (Client exited)
[16:54:52] *** Quits: sigma (sigma@moz-AAED89D5.range86-160.btcentralplus.com) (Ping timeout)
[16:56:10] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[16:56:10] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/NzQIhg
[16:56:10] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[16:56:12] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[16:56:12] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/Qm5QSw
[16:56:12] <ghrust> 13rust/06auto 149051a35 15Lars Bergstrom: Clarify that snapshots are automatically retrieved.
[16:56:12] <ghrust> 13rust/06auto 14b7bbc2e 15bors: auto merge of #9327 : larsbergstrom/rust/tutorial_installation_tweak, r=catamorphism...
[16:56:13] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[16:56:24] *** Joins: echristo (echristo@DCF57675.D6CCE4AE.77834EAA.IP)
[16:56:32] *** Quits: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net) (Ping timeout)
[16:57:27] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[16:57:33] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[16:57:46] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[16:58:33] *** Quits: Larry (larryfox@moz-343B6F0C.nyc.biz.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[16:58:47] *** Joins: maik (maik@moz-A79D08D1.dip0.t-ipconnect.de)
[16:59:42] *** Joins: Ralith (ralith@A8995AA9.62B6AF6A.922221DB.IP)
[17:00:15] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[17:01:14] *** Joins: cdidd (cdidd@D1BF43F9.5CFBC045.62D8163C.IP)
[17:01:22] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[17:01:24] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[17:02:17] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Ping timeout)
[17:02:29] *** Joins: lmandel (lmandel@moz-76CE9D51.cable.teksavvy.com)
[17:03:07] *** Joins: andrew-__ (andrew-d_w@moz-5A92CAFF.dsl.static.sonic.net)
[17:03:47] *** Quits: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net) (Ping timeout)
[17:05:46] *** Joins: Kruppe (user@moz-253119B0.esg.uwaterloo.ca)
[17:08:29] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[17:11:36] *** Quits: wakandan (Mibbit@5B9B91CA.8FF05F7.4605F140.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[17:12:44] *** Joins: montezuma (Mibbit@moz-7A900440.fda.gov)
[17:13:36] *** Joins: dherman (dherman@E3D7CBA.E815F8FA.2326E556.IP)
[17:13:36] *** ChanServ sets mode: +ao dherman dherman
[17:14:29] *** Quits: KindOne (KindOne@61F68286.206EFA7F.34F73994.IP) (Ping timeout)
[17:14:38] *** Quits: maik (maik@moz-A79D08D1.dip0.t-ipconnect.de) (Ping timeout)
[17:14:59] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[17:15:34] *** Quits: msch (msch@moz-DA0E34D4.clients.your-server.de) (Ping timeout)
[17:15:47] *** Quits: dherman (dherman@E3D7CBA.E815F8FA.2326E556.IP) (Quit: dherman)
[17:16:04] *** Joins: lenstr (lenstr@E0E80B8D.ED45D46B.DFEAE789.IP)
[17:16:38] <montezuma> Q: can I make a struct in Rust (not a "newtype") that makes it act like a "value type" (copied) by default?  I've got such a struct that I get "cannot move out of &" warnings unless I do ".clone()" on it.  Is there some trait I can have value semantics by default? 
[17:17:01] *** Joins: bernard (Mibbit@moz-5256162B.hsd1.ca.comcast.net)
[17:17:07] <kimundi> montezuma: All structs have value semantic per default
[17:17:23] <montezuma> kimundi: Hmm I must be doing something wrong then.
[17:18:01] *** Quits: lenstr (lenstr@E0E80B8D.ED45D46B.DFEAE789.IP) (Client exited)
[17:18:15] <engla> montezuma: value semantics would allow you to move. All structs also have implict copy, unless they have a destructor, or contains something that does; or, they contain &fn or &mut 
[17:18:19] *** Joins: KindOne (KindOne@moz-8C42EF22.dynamic.ip.windstream.net)
[17:18:46] *** Quits: andrew-__ (andrew-d_w@moz-5A92CAFF.dsl.static.sonic.net) (Input/output error)
[17:18:47] <kimundi> montezuma: If the struct contains &mut, implements Drop, or contains types that implement Drop, it becomes something that can no longer be implicit copied, but rather moved.
[17:19:06] *** Joins: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net)
[17:19:40] <kimundi> A move would mean transferring ownership, which you are not allowed to do through an & ptr
[17:19:51] <montezuma> kimundi, engla: OK I don't have any of those.  Just a fixed length array member.  Accessed through a trait though. 
[17:20:04] <kimundi> However, in both cases what happens at a low level is an shallow copy of the struct data
[17:20:29] <kimundi> montezuma: Any ~ ?
[17:20:43] <engla> montezuma: oh, so you have a generic type like   [T, ..8] ?
[17:20:48] <nmatsakis> jeaye: btw I'm cloning q3 -- hopefully I can get to the bottom of that bug...
[17:21:14] *** Quits: hoverbear (andrew@moz-D5078CE5.wireless.uvic.ca) (Quit: hoverbear)
[17:21:25] <engla> montezuma: there is no trait for implicit copy, you have to use Clone in generic context if you want to copy values
[17:21:28] <montezuma> kimundi: No ~'s or other pointers, simple [u8,...n].  Shallow copy is what I want, I just am not sure if the clone() should really be necessary to escape "attempt to move out of deref" errors.
[17:22:09] <kimundi> montezuma: Hm, okay
[17:22:23] <kimundi> rusti: let x = [1,2,3]; let y = x; y
[17:22:23] -rusti- [1, 2, 3]
[17:22:28] <kimundi> rusti: let x = [1,2,3]; let y = x; (x, y)
[17:22:28] -rusti- ([1, 2, 3], [1, 2, 3])
[17:22:30] *** Quits: eevee (eevee@moz-8B105F97.evrt.wa.frontiernet.net) (Connection reset by peer)
[17:22:45] <kimundi> okay, a [u8, ...N] is definitly implicit copyable
[17:22:46] <montezuma> THose errors happen when using the type as part of a larger structure passed by borrowed pointer.  No problem for ints e.g. (no clone() necessary), I just want same treatment for my type if possible.
[17:22:48] *** Joins: eevee (eevee@moz-8B105F97.evrt.wa.frontiernet.net)
[17:23:10] <engla> montezuma: pastebin your code please?
[17:23:26] <benh> trying to make syntax::parse::parser::Parser's methods "const-correct" without relying on internal mutability of the various Parser fields seems pretty tricky :(
[17:23:40] <jeaye> nmatsakis: Wow, that's great. :D Are you checking out the commit I specified (of Rust), or just master? If it's master, I can do a bit of work to get everything else in place so only the ICE is left (namely drop taking &mut). The build that introduced it for me was rust-git-0.7.2649.gb81743e-1-x86_64
[17:23:40] <kimundi> montezuma: Does the larger structure contain any ~, &mut, or typesd with destructors?
[17:24:05] <montezuma> Here's the structure definition (trait, followed by the four structs which impl it) http://mibpaste.com/6vsvqu 
[17:24:36] <montezuma> Deg is just a newtype arround u8
[17:24:36] <cmr> montezuma: what's Deg?
[17:24:41] <montezuma> :)
[17:25:27] *** Joins: dave1629 (dave@166C5FBA.B99481B3.DDE5D3F6.IP)
[17:25:29] <montezuma> I don't have an example handy of usage, but I was iterating a vector of these monomials, and it then always wants a clone().
[17:26:54] <montezuma>  Else would get "attempt to move out of & deref" error, if no clone() was applied.
[17:26:55] <nmatsakis> jeaye: I was just using master
[17:26:55] <kimundi> montezuma: Just based on the code you posted, you shouldn't have such a problem then. But to actually tell what's going on we'D need an code example that actually shows the error.
[17:27:20] *** Joins: skade (skade@moz-4865967C.pools.arcor-ip.net)
[17:27:37] <montezuma> OK good to know, I'll try to create a test case then.  I figured everybody was having to put up with this :)
[17:28:00] *** Joins: valenting (Thunderbir@C6866972.77435D89.FB866788.IP)
[17:28:32] *** Joins: hoverbear (andrew@moz-D5078CE5.wireless.uvic.ca)
[17:29:02] <jeaye> nmatsakis: Ok. I've just made an `ice` branch on q3and updated it for master.
[17:30:48] <nmatsakis> jeaye: great thanks
[17:31:24] *** Quits: dave1629 (dave@166C5FBA.B99481B3.DDE5D3F6.IP) (Quit: dave1629)
[17:31:49] *** Quits: wilmoore (wilmoore@moz-1248C037.mystrotv.com) (Client exited)
[17:32:12] *** Quits: NiccosSystem (NiccosSyst@AB1AFDE.FC7B0C35.A7597CB6.IP) (Ping timeout)
[17:32:15] *** Joins: wilmoore (wilmoore@moz-1248C037.mystrotv.com)
[17:33:55] *** Quits: wilmoore (wilmoore@moz-1248C037.mystrotv.com) (Ping timeout)
[17:34:38] *** Quits: CarpNet (ac@moz-FD24B77.sohonet.co.uk) (Quit: Leaving)
[17:35:09] <cmr> Guh
[17:35:16] *** Joins: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com)
[17:35:18] <cmr> doomlord_: if you want to work on another tool.
[17:35:23] <cmr> "What is this type!??" would be nice :p
[17:35:27] <doomlord_> hi
[17:35:42] <cmr> ...but the program doesn't typecheck, so taht'd be pretty hard
[17:35:51] <kimundi> cmr: He
[17:36:04] <kimundi> cmr: If it runs, we have that already ;)
[17:36:26] <doomlord_> i would eventually like to add that to rustfind output... some sort of popup type information ..
[17:37:09] <doomlord_> yeah i dont think its exactly trivial.
[17:37:12] *** Joins: riley (riley@8BA43816.9AA11D69.65DDFA89.IP)
[17:39:12] *** Joins: dave1629 (dave@166C5FBA.B99481B3.DDE5D3F6.IP)
[17:39:39] <doomlord_> a call-graph or dependancy graph visualizer is something else i want to add (maybe spit out dotfiles) , unless that already exists..
[17:39:58] <doomlord_> thats probably lower hanging fruit
[17:40:08] <cmr> I don't think that exists
[17:40:27] *** Joins: tgummerer (tgummerer@51D3B54.FEF996EA.EA6FEF3D.IP)
[17:40:28] <jeaye> nmatsakis: I think I may've just found the problem.
[17:40:40] *** Quits: hoverbear (andrew@moz-D5078CE5.wireless.uvic.ca) (Quit: hoverbear)
[17:40:56] * jeaye needs a few more minutes.
[17:41:23] <doomlord_> a graph of  traits would be great too...
[17:41:53] <kimundi> doomlord_: A complete graph of a crate in general would be nice
[17:42:05] <sp3d> I'd think llvm could spit out a callgraph without too much trouble
[17:42:30] *** Joins: andrew-__ (andrew-d_w@moz-5A92CAFF.dsl.static.sonic.net)
[17:42:34] <nmatsakis> jeaye: ok. I got as far as "can't find a crate for opengles"
[17:42:34] *** Quits: andrew-__ (andrew-d_w@moz-5A92CAFF.dsl.static.sonic.net) (Input/output error)
[17:42:35] <kimundi> module tree, all definitions, every line of code can be queried for the types used...
[17:42:54] *** Joins: andrew-__ (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net)
[17:42:56] <nmatsakis> jeaye: ah, I see my problem... anyway, lemme know what you find
[17:43:19] *** Quits: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net) (Ping timeout)
[17:44:05] <doomlord_> can a dotfile express a heirahcal containment of nodes? i suppose you could represent a module as a node that simply links to its contents, but it would be nice to show those as nested areas
[17:44:28] *** Parts: miza (miza@moz-908EA8DE.home.otenet.gr) ()
[17:45:16] <SiegeLord> Speaking of moves... are they related in Rust to the moves enabled by rvalue references from C++ ?
[17:45:38] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[17:46:56] *** Quits: skade (skade@moz-4865967C.pools.arcor-ip.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[17:47:44] *** Joins: bheylin_ (brianheyli@moz-F60922D4.adsl.xs4all.nl)
[17:49:27] *** Joins: maik (maik@moz-A79D08D1.dip0.t-ipconnect.de)
[17:50:16] *** Quits: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net) (Quit: Jesse)
[17:50:21] *** Quits: Skif (emschwar@moz-CA025D57.ip.mcleodusa.net) (Client exited)
[17:51:34] *** Quits: canhtak (jeremy@moz-44AEB22E.wl.t.ulaval.ca) (Quit: canhtak)
[17:51:35] <SiegeLord> Also... what's up with this: https://github.com/mozilla/rust/issues/9305 Am I missing some blog post/meeting notes?
[17:52:21] *** Quits: maik (maik@moz-A79D08D1.dip0.t-ipconnect.de) (Ping timeout)
[17:52:52] *** Joins: canhtak (jeremy@moz-44AEB22E.wl.t.ulaval.ca)
[17:52:58] *** Joins: msch (msch@moz-DA0E34D4.clients.your-server.de)
[17:54:42] <jeaye> nmatsakis: I updated the ticket with a comment.
[17:55:03] <cmr> SiegeLord: the context is that the team decided to mark some features as experimental if they're not fully-baked yet, so as to faster reach backwards-compat.
[17:55:04] <jeaye> nmatsakis: Apologies for the loop around.
[17:55:26] *** Joins: hoverbear (andrew@moz-D5078CE5.wireless.uvic.ca)
[17:55:31] <SiegeLord> cmr: What's not fully baked though?
[17:56:14] <SiegeLord> macro_rules had a lengthy post by pcwalton outlining a large list of outstanding issues with them
[17:56:26] *** Joins: kvark (Mibbit@9A8A5739.49975FB2.AE2D72A6.IP)
[17:57:47] *** Joins: sebcrozet (sebcrozet@moz-F96421F3.w80-13.abo.wanadoo.fr)
[17:58:07] <nmatsakis> jeaye: no worries!
[17:58:22] <nmatsakis> jeaye: I was tempted to ask ... "are you SURE it's a clean build?" ;)
[17:58:33] <engla> Import globs are also suggested to be behind a feature flag, but we have those in every module with std::prelude::*, so I'm not sure if that will work
[17:59:23] <montezuma> kimundi: if you're still around or anyone else: mystery of the struct not treated as value without clone(): https://gist.github.com/scharris/6641292
[17:59:34] <jeaye> heh
[17:59:53] <bernard> failed to find an implementation of trait std::rt::io::Writer for &std::rt::io::Writer<no-bounds> <- what does no-bounds mean here?
[17:59:57] *** Joins: voxpopuli (fanservice@moz-FE161659.wv.cc.cmu.edu)
[18:00:11] <montezuma> In the example, I'm wondering why the lines with clone()'s need the clones.  I want to treat that struct as a value always, like say an int.
[18:00:23] <engla> montezuma: ah, we covered this, implict copy does not exist for generic types
[18:00:24] *** Joins: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[18:00:33] <SiegeLord> Maybe there could be a Copy kind?
[18:00:46] <engla> SiegeLord: hehe it's gone now
[18:00:54] <SiegeLord> Was it a kind or a trait?
[18:01:11] <engla> kind
[18:01:17] <SiegeLord> I see... oh well
[18:01:33] <montezuma> engla: OK so the clone is necessary.  Thanks!
[18:02:02] <engla> montezuma: yes it is. Your structs are not involved, you only have  <M: Monomial>
[18:02:14] <montezuma> engla: Yep OK got it.
[18:02:49] *** Quits: nsf (nsf@moz-EEF3238A.convex.ru) (Quit: WeeChat 0.4.1)
[18:03:35] *** Parts: radarsat1 (uid2860@moz-31ABA2C0.irccloud.com) ()
[18:03:36] *** Quits: msch (msch@moz-DA0E34D4.clients.your-server.de) (Input/output error)
[18:03:37] *** Joins: msch (msch@moz-DA0E34D4.clients.your-server.de)
[18:04:49] *** Quits: msch (msch@moz-DA0E34D4.clients.your-server.de) (Quit: Coyote finally caught me)
[18:04:51] *** Quits: montezuma (Mibbit@moz-7A900440.fda.gov) (Quit: http://www.mibbit.com ajax IRC Client)
[18:04:52] <kvark> Hello! I'm trying to get Rust to compile things on windows... Currently, it somehow produces only "*.o" files. When I run "ld" on these I get many of: undefined reference to `__morestack'
[18:05:53] <kvark> I can see libmorestack.a in the Rust/i686-pc-mingw32/bin, should I link against that? I was under impression that ".a" is only used for *nix
[18:07:52] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[18:08:11] *** Quits: bheylin_ (brianheyli@moz-F60922D4.adsl.xs4all.nl) (Quit: bheylin_)
[18:09:06] *** Joins: msch (msch@moz-DA0E34D4.clients.your-server.de)
[18:09:28] <jesseray> Lately, I have been seeing functions like this: fn example() { || do_something(); }. Why is a lambda being used here? Does it create a thunk or something?
[18:09:58] <kmc> the term "thunk" is sometimes used to mean "zero-argument function" so in that case yes
[18:10:05] <kmc> but what did you mean by it?
[18:10:27] <jesseray> I mean an unevaluated chunk of code
[18:10:28] *** Quits: a_m0d (dschoof@moz-670D1285.commercial.cgocable.net) (Ping timeout)
[18:10:43] *** Quits: msch (msch@moz-DA0E34D4.clients.your-server.de) (Quit: Coyote finally caught me)
[18:10:52] *** Joins: Skif (emschwar@moz-CA025D57.ip.mcleodusa.net)
[18:10:59] <kmc> I think it's hard to say why one would have code like that, without any more context
[18:11:06] *** Joins: slack1256 (slack@moz-542CA772.baf.movistar.cl)
[18:11:12] *** Joins: a_m0d (dschoof@moz-670D1285.commercial.cgocable.net)
[18:11:19] <kmc> could be that some external code expects to call a function and get another function, for whatever reason
[18:12:33] <jesseray> Ah, it's not returning the result of the lambda, but the lambda itself so it can be evaluated later, perhaps in a map() or something. Neat.
[18:12:33] <kmc> do the actual use cases involve 'example' taking arguments and the lambda closing over them?
[18:12:44] *** Quits: hoverbear (andrew@moz-D5078CE5.wireless.uvic.ca) (Quit: hoverbear)
[18:13:11] <kmc> "lambda" is just a syntactic construct; the result of evaluating a lambda expression *is* a function
[18:13:27] <engla> jesseray: your example code, taken literally, does nothing, since there is a semicolon (and corresponding a nil return type)
[18:14:10] <kmc> if you wanted to build a function using lambda and then evaluate it immediately you would have to write  ( || do_something(); )()
[18:14:26] <jesseray> True. I have not gotten accustomed to Rust's use of semicolons just yet.
[18:14:34] <kmc> engla: it depends on whether the semicolon is part of the lambda body or the outer function body, right? and I don't know offhand which way it parses
[18:14:45] <engla> the latter kmc 
[18:14:50] <kmc> interesting
[18:14:59] <engla> you would need  || { do_something(); }   otherwise
[18:15:12] *** Quits: Jessin (Jessin_@moz-C8BB4444.cc.lehigh.edu) (Quit: Leaving)
[18:15:16] <jesseray> On https://github.com/mozilla/rust/issues/2992, I see the code fn enclose<A: Clone>(a: A) -> @fn() -> A {   || a.clone() } fn main() {}
[18:15:28] <jesseray> That is what prompted my question.
[18:16:09] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[18:16:09] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/Qm5QSw
[18:16:09] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[18:16:18] <kmc> yeah that one is closing over the variable 'a'
[18:16:41] <kimundi> kmc: A lambda is allways |ARGS*| EXPR
[18:17:21] <kmc> jesseray: so it's really more like a data structure; it just stores a value of type A and returns it (by copy) when called
[18:17:27] <kimundi> EXPR; is not an EXPR, but a block like { ... } is, so || { ... ; } works
[18:17:36] <kmc> I think it's not very useful, just an example to hit this compiler bug
[18:18:49] <kmc> jesseray: as it turns out, you can build essentially any datastructure using only lambdas: http://en.wikipedia.org/wiki/Church_encoding http://en.wikipedia.org/wiki/Mogensen%E2%80%93Scott_encoding
[18:18:54] *** Joins: msch (msch@moz-DA0E34D4.clients.your-server.de)
[18:19:01] *** Quits: dave1629 (dave@166C5FBA.B99481B3.DDE5D3F6.IP) (Quit: dave1629)
[18:19:26] <jesseray> "can" is a relative term. I can't =P
[18:19:59] *** Quits: nkoep (nik@moz-7EFF3F81.vpn.rwth-aachen.de) (Ping timeout)
[18:20:26] <jesseray> I just recently learned about Rust's idea of blocks { ... }. I like the idea of being able to create my own scopes without adding functions and what-not. Very cool =)
[18:21:04] <kimundi> jesseray: he, I don't think rust invented that though ;)
[18:21:04] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[18:21:07] *** Joins: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com)
[18:21:08] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[18:21:08] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/9rEAdQ
[18:21:08] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[18:21:10] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[18:21:10] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/O3-evA
[18:21:10] <ghrust> 13rust/06auto 14ad5f619 15Steve Klabnik: Update rustpkg manpage to add init....
[18:21:10] <ghrust> 13rust/06auto 14ff0aaaf 15bors: auto merge of #9338 : steveklabnik/rust/rustpkg_update_manpage, r=catamorphism...
[18:21:10] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[18:21:13] <kmc> yeah that's a big thing in C++ as well
[18:21:32] <doomlord_> rusts have return values though , right ? :)
[18:21:42] <kmc> yeah
[18:21:44] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[18:21:55] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[18:21:58] *** Joins: nrc|afk (nrc@7BE24E90.A5032A01.3CFC199D.IP)
[18:22:19] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[18:22:55] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[18:23:06] <engla> Rust blocks are expressions
[18:23:08] <kmc> it's kind of weird (but also cool) how Rust has C-looking syntax but actually everything is an expression
[18:23:17] <kmc> you can write  2 + 3*(return 5)
[18:23:21] <kimundi> let simple = { let complicated = foo(); let (x, y) = complicated.do_strange_things(); let z = x.modify(); y.combine(z); z}; // :P
[18:23:32] <engla> kmc: the return thing is particularly confusing.. but useful
[18:23:35] <kmc> which will cause the function to return 5; the multiplication and addition never happens
[18:23:50] <engla> let length = match self.len() { 0 => return None, x => x }
[18:23:59] <kimundi> yeah, return early out is useful
[18:24:01] <kmc> it makes me happy because it reminds me of continuations, even though they aren't first class here
[18:24:07] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[18:24:15] <kmc> kimundi: yeah I use it in 'match' a lot
[18:24:18] <kmc> can be confusing though
[18:24:44] <kmc> engla: see if we had first class continuations that could be expressed as a higher order function on Option! so much better! ;)
[18:24:45] <doomlord_> i  really like the mix of c-like syntax and expressions
[18:24:58] *** Quits: canhtak (jeremy@moz-44AEB22E.wl.t.ulaval.ca) (Quit: canhtak)
[18:25:28] <bernard> hmm
[18:25:34] <kmc> I don't love C-like syntax but Rust at least eliminates some of the worst parts
[18:25:34] *** Quits: kvark (Mibbit@9A8A5739.49975FB2.AE2D72A6.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[18:25:44] <kmc> and definitely vastly better than C++ syntax
[18:25:51] *** Joins: dave1629 (dave@166C5FBA.B99481B3.DDE5D3F6.IP)
[18:26:23] <engla> I don't know anything better. Match syntax is great
[18:27:31] <bernard> anyone successfully implemented std::rt::io::Reader?
[18:27:49] <bernard> http://nopaste.info/cb2bd691ee.html <- I'm having issues - I'm pretty new to Rust in general
[18:27:50] *** Joins: pcwalton (pcwalton@moz-BE33DA21.fw1.sfo1.mozilla.net)
[18:27:50] *** ChanServ sets mode: +ao pcwalton pcwalton
[18:28:06] <kmc> engla: match syntax is one of the least "C-like" parts of Rust syntax, though
[18:28:19] <kmc> and plenty of languages have pattern matching without being syntactically C-like at all
[18:28:29] * engla looks around and raises hand
[18:28:35] <engla> I guess
[18:29:07] <kmc> I'm not trying to complain about Rust syntax though; it's fine, and I don't care about concrete syntax that much
[18:29:23] <bernard> engla: see any glaring issues with what I wrote there?
[18:29:24] <jesseray> match n { ... } was one of my favorite features in Haskell, so it was nice to see it in a systems language =)
[18:29:31] <engla> bernard: you need to pass f as   test(&mut f)
[18:29:41] <kmc> yep!  we even have or-patterns, which Haskell doesn't :/
[18:30:23] <kmc> one arm can specify multiple patterns, as long as they bind the same variables at the same types
[18:30:54] <bernard> engla: everything else look idiomatic-ish?
[18:31:33] <myname> kmc: isn't that "either"?
[18:31:43] <kmc> myname: ?
[18:31:49] <engla> bernard: I think so. Not many lines there to judge :)   you should learn and use the println!() macro and the new formatting, because printfln! is on the way out
[18:31:55] <myname> what do you mean by or-patterns?
[18:31:57] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[18:32:17] <engla> and ranges
[18:32:20] <kmc> rusti: match None { None | Some(_) => ~"hallo" }
[18:32:21] -rusti- <anon>:7:15: 7:19 error: cannot determine a type for this expression: unconstrained type
[18:32:21] -rusti- <anon>:7          match None { None | Some(_) => ~"hallo" }
[18:32:21] -rusti-                         ^~~~
[18:32:21] -rusti- error: aborting due to previous error
[18:32:21] -rusti- application terminated with error code 101
[18:32:26] <kimundi> match { Foo(a) | Bar(_, _, a) | Baz(_, a) =>  }
[18:32:27] <myname> ah
[18:32:29] <kmc> rusti: match Some(0u8) { None | Some(_) => ~"hallo" }
[18:32:30] -rusti- ~"hallo"
[18:32:37] <kmc> that's a useless example of course
[18:32:49] <kmc> but it can be very handy when you have a big enum with lots of constructors, and you need to break them into a few cases
[18:32:56] <jesseray> match n { 1 | 2 => ~"buckle my shoe", 3 | 4 => ~"..." } =P
[18:33:00] <kmc> haha
[18:33:20] *** Quits: spider-mario (spidermari@moz-2F72F6FF.dsl.quantic-telecom.net) (Quit: No Ping reply in 180 seconds.)
[18:34:02] *** Quits: dave1629 (dave@166C5FBA.B99481B3.DDE5D3F6.IP) (Quit: dave1629)
[18:35:22] *** Quits: jxv (jxv@moz-8FB92450.lightspeed.irvnca.sbcglobal.net) (Ping timeout)
[18:35:25] <jesseray> fn is_control(c: char) -> bool { match c { '\u0000' .. '\u001f' => true, '\u007f' .. '\u009f' => true, _ => false } }
[18:35:46] *** Joins: hoverbear (andrew@moz-D5078CE5.wireless.uvic.ca)
[18:36:13] <bernard> is ref mut only used in match expressions (as opposed to &mut)?
[18:36:23] <kimundi> match n { 1 | 2 => ~"buckle my shoe", 3 | 4 => ~"owned strings no more!", 5 | 6 => ~"I urge you to fix" }
[18:36:29] <engla> bernard: in patterns in general
[18:36:33] <benh> ref mut is kinda the other way around from &mut in a pattern
[18:36:33] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[18:36:34] *** ChanServ sets mode: +ao brson brson
[18:36:35] <kmc> bernard: 'ref' in general is only used in patterns
[18:36:59] <bernard> oh I see
[18:37:03] <kmc> matching against &p dereferences a borrowed pointer and matches the result against p
[18:37:08] <kimundi> bernard: In patterns a &foo would _remove_ one layer of & ptrs. 'ref' is used to instead _add_ an layer of & ptr
[18:37:19] *** Joins: Larry (larryfox@moz-343B6F0C.nyc.biz.rr.com)
[18:37:34] <kmc> I kind of wish we called them "references" rather than "borrowed pointers" consistently
[18:37:50] *** Joins: miza (miza@moz-908EA8DE.home.otenet.gr)
[18:37:50] <myname> pointers everywhere
[18:37:54] <kimundi> let Some(x) = foo; // x == T; let Some(ref x) = foo(); // x == &T
[18:38:05] <kimundi> kmc: Yeah
[18:38:23] <engla> rusti: let ref mut y = 1; *y = 7; *y    // `let` uses a pattern
[18:38:23] -rusti- 7
[18:38:33] *** Joins: nkoep (nik@moz-77021FC6.pool.mediaways.net)
[18:38:45] <jesseray> ~(~(~(~(~(~(~(~(~(~(~(~(~"the horror!"))))))))))))
[18:38:46] <kmc> weird, hadn't thought about doing that :)
[18:39:14] *** Joins: gandalf (zbraniecki@moz-BE33DA21.fw1.sfo1.mozilla.net)
[18:39:27] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[18:40:00] <kmc> so that's equivalent to Â«let y = &mut 1;Â» which is equivalent to Â«let mut temp = 1; let y = &mut tmp;Â» ?
[18:40:14] <kmc> modulo me spelling "tmp" two different ways in one line :)
[18:40:19] <kimundi> yeah
[18:40:40] *** Quits: afrey71 (Mibbit@moz-9D412872.mss.so) (Z:lined (Your IP, 199.15.112.86, is listed in the EFnet RBL. For further information, visit http://rbl.efnetrbl.org/?i=199.15.112.86))
[18:40:54] <kimundi> It'll be fun if 'mut' becomes an pattern modifier
[18:41:10] <kmc> in 'ref x', x has to be a variable, not a general pattern, right?
[18:41:11] <kimundi> let mut ref mut x = 1;
[18:41:22] <kmc> rusti: let ref (x,y) = (2,3);
[18:41:23] -rusti- <anon>:7:13: 7:16 error: expected identifier, found path
[18:41:23] -rusti- <anon>:7          let ref (x,y) = (2,3);
[18:41:23] -rusti-                       ^~~
[18:41:23] -rusti- application terminated with error code 101
[18:41:26] <kimundi> kmc: A binding, so a variable yeah
[18:41:30] *** Quits: msch (msch@moz-DA0E34D4.clients.your-server.de) (Quit: Coyote finally caught me)
[18:41:35] <kmc> are there other bindings besides variables?
[18:41:38] <kmc> rusti: let ref _ = 1;
[18:41:39] -rusti- <anon>:7:13: 7:16 error: expected identifier, found path
[18:41:39] -rusti- <anon>:7          let ref _ = 1;
[18:41:39] -rusti-                       ^~~
[18:41:39] -rusti- application terminated with error code 101
[18:42:02] *** Joins: canhtak (jeremy@moz-44AEB22E.wl.t.ulaval.ca)
[18:42:13] * kmc -> lunch
[18:47:07] <bernard> what is the difference between using a vec directly, and using vec.as_slice()?
[18:47:18] <kimundi> bernard: depends
[18:47:33] <kimundi> we don't have a bare 'vec'
[18:48:32] <jesseray> let x = ~"whatever"; let mut i = 0; while i < x.len() { ... i += 1; }. Would this execute x.len() one time or many times?
[18:48:33] <kimundi> We have these kinds of allocatable vectors: ~[T], @[T], [T, ..N], and they can be sliced as an &[T] and &mut[T]
[18:48:46] <kimundi> jesseray: many times
[18:49:24] <engla> so by-slice is the general way to read/access the elements of a vector of any allocation
[18:49:25] <cmr> jesseray: kimundi: I don't think that's true
[18:49:33] <kimundi> .asl_slice merely explicitly request an &[T] from either of the three
[18:49:35] <cmr> x is immutable.
[18:49:38] <jesseray> If X is immutable, then the compiler should be able to optimize it out.
[18:49:41] <cmr> it could easily cache the computation.
[18:49:47] <jesseray> I don't know if it does or not, though.
[18:49:53] <cmr> I think llvm can do it
[18:50:12] <engla> x.len() is not necessarily compiled to a function call
[18:50:14] <kimundi> cmr: okay, but that'S an optimisation
[18:50:25] <cmr> I don't know if we emit the proper information to let it do it though
[18:50:34] <kimundi> the language is defined as while evaluating the expression on each loop
[18:51:24] <cmr> Yes
[18:51:31] *** Joins: jxv (jxv@moz-8FB92450.lightspeed.irvnca.sbcglobal.net)
[18:51:42] <kimundi> rusti: let mut x = 0u; let f = ||{ println("foo"); if x < 3 { x += 1; true } else {false}  }; while f() {}
[18:51:43] -rusti- foo
[18:51:43] -rusti- foo
[18:51:43] -rusti- foo
[18:51:44] -rusti- foo
[18:51:44] -rusti- ()
[18:53:07] <kimundi> if llvm figures out it doesn't have to call it everytime then that's good, but as a user of the language there is no difference.
[18:53:37] <jesseray> So, for best performance, move the evaluation outside of the while?
[18:54:15] <jesseray> I was hoping for code which is more compact than that requires, but no biggie.
[18:54:16] <engla> cmr: it looks like it doesn't do that optimization
[18:54:22] <engla> jesseray: always use iterators anyway
[18:54:26] <kimundi> jesseray: If you're sure it won't change the result then you may do that. But there'es usually no need for it.
[18:54:31] <engla> jesseray: a while loop like that is not rustic
[18:54:36] *** Joins: Palmik (palmik@moz-11EA685D.pks.muni.cz)
[18:54:51] <kimundi> right, what engla says too :P
[18:55:31] <jesseray> I don't know how to use iterators yet. I'm just hacking together simple stuff to get my bearings on the language =)
[18:56:08] <kimundi> rusti: let v = [1,2,3]; for e in v.iter() { printf!(e); }
[18:56:08] -rusti- &1&2&3()
[18:56:23] <kimundi> relativlyy straight forward :P
[18:56:38] <jesseray> Given ~"whatever", how would one iterate over that, one character at a time?
[18:56:58] *** Quits: miza (miza@moz-908EA8DE.home.otenet.gr) (Input/output error)
[18:56:58] <brson> hey, we made a successful dist snap last night!
[18:57:00] <kimundi> rusti: let v = ~"whatever"; for e in v.iter() { printf!(e); }
[18:57:01] -rusti- 'w''h''a''t''e''v''e''r'()
[18:57:03] <brson> i'm so happy
[18:57:11] <kimundi> brson: woho \o/
[18:57:11] <acrichto> brson: \o/
[18:57:21] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Connection reset by peer)
[18:57:30] <jesseray> That is much cleaner. Thanks =)
[18:58:11] <Jesse> will "for e in v.iter()" become "for e in v" ?
[18:58:31] <kimundi> jesseray: Also, based on the context I gathered you did it like this before ? while i < v.len() { v[i] ... i += 1; ... }
[18:58:36] <engla> jesseray: iterators are also much more efficient
[18:58:44] <jesseray> Yeah, that's what I did.
[18:59:09] <kimundi> jesseray: Then note that that did not iterate over characters :)
[18:59:33] <cmr> Jesse: Eventually, if it can.
[18:59:44] <cmr> Jesse: it requires more language changes.
[19:00:00] <kimundi> jesseray: indexing a string gives you the byte at that byte offset in the utf8 encoded string. .iter() will give you the actual unicode codepoints, which is what our 'char' is
[19:00:21] <Jesse> rusti: let v = ~"Ã¡bcdÃªfg"; for e in v.iter() { printf!(e); }
[19:00:21] *** Quits: andrew-__ (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net) (Input/output error)
[19:00:22] -rusti- '\xe1''b''c''d''\xea''f''g'()
[19:00:40] <kimundi> Our char is a u32, because unicode codepoints take up ti 21 bits
[19:00:59] <jesseray> I am writing a CSS minifier. I needed a function to strip control characters and the only way I knew how to go through characters one at a time was by using a while loop. The iter() method will prove very useful =)
[19:01:05] <kimundi> that is, 'char' is the same size as 'u32', their not literally the same
[19:01:37] <kimundi> jesseray: Iterators are awesome
[19:01:53] <jesseray> Yeah, I need to use iterators to make my Unicode-friendly CSS minifier :D
[19:02:12] <Jesse> rusti: let v = ~"â˜ƒâ˜ºðŸ‡ºðŸ‡¸"; for e in v.iter() { printf!(e); } /////////
[19:02:13] -rusti- '\u2603''\u263a''\U0001f1fa''\U0001f1f8'()
[19:02:29] <acrichto> unicode scares me sometimes
[19:02:36] <kimundi> rusti: "Really, really, awesome".word_iter().map(|s| s.char_at(0)).collect::<~str>()
[19:02:37] -rusti- ~"Rra"
[19:02:43] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[19:03:03] <Jesse> rusti: "Really, really, awesome".word_iter().map(|s| s.char_at(0)).collect()
[19:03:04] -rusti- <anon>:7:9: 8:5 error: cannot determine a type for this bounded type parameter: unconstrained type
[19:03:04] -rusti- <anon>:7          "Really, really, awesome".word_iter().map(|s| s.char_at(0)).collect()
[19:03:04] -rusti- <anon>:8     };
[19:03:04] -rusti- application terminated with error code 101
[19:04:00] <kimundi> Jesse: It needs a typehint to know into what kind of container to collect
[19:04:08] <kimundi> rusti: "Really, really, awesome".word_iter().map(|s| s.char_at(0)).collect::<~[char]>()
[19:04:09] -rusti- ~['R', 'r', 'a']
[19:04:27] <Jesse> i see
[19:04:34] <Jesse> what method does it call on the container to add items?
[19:04:38] *** Quits: nejucomo (Adium@moz-A94CACD5.dsl.pltn13.sbcglobal.net) (Quit: Leaving.)
[19:04:39] *** Quits: six600110 (six600110@moz-2FA48202.neo.res.rr.com) (Ping timeout)
[19:04:50] <kimundi> Could be anything: a vector, a hashset, a string, a file etc
[19:05:05] <Jesse> rusti: "".word_iter().map(|s| s.char_at(0)).collect::<~[char]>()
[19:05:06] -rusti- ~[]
[19:05:15] <engla> rusti: "Really unique stuff tycho".word_iter().map(|w| w.char_at(0)).collect::<extra::ringbuf::RingBuf<char>>()
[19:05:15] -rusti- extra::ringbuf::RingBuf<char>{nelts: 4u, lo: 0u, elts: ~[Some('R'), Some('u'), Some('s'), Some('t')]}
[19:05:16] <kimundi> trait FromIter::from_iter() I think
[19:05:24] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Ping timeout)
[19:05:36] <Jesse> oh, nice
[19:06:12] *** Joins: Azdle (Azdle@moz-B334B496.hfc.comcastbusiness.net)
[19:06:22] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[19:07:11] <engla> the word iterator isn't proper yet
[19:07:18] <engla> it's just a whitespace split iterator
[19:07:24] <kimundi> right, needs a rename
[19:07:32] <kimundi> or, removal even
[19:07:43] <engla> or a big FIXME
[19:07:49] <brson> acrichto: did your --cfg ndebug change land?
[19:07:58] <engla> or.. that would be revolutionary.. someone to actually fix it
[19:08:01] <kimundi> .split_iter(whitespace) where whitespace is a function that recognizes whitespace would do as well
[19:08:12] <acrichto> brson: not yet https://github.com/mozilla/rust/pull/9278
[19:08:26] <brson> will debug! be on by default again? does the compiler include debug! by default?
[19:08:28] <Jesse> what does a "proper word iterator" do? is it language-dependent?
[19:08:35] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[19:08:40] <brson> acrichto: --cfg debug is mentioned in the relnotes, so that will need to change
[19:08:53] <kimundi> Jesse: Yeah. Different languages have different rules about what sequence of characters are seperate words
[19:08:54] <engla> Jesse: it does this http://www.unicode.org/reports/tr29/#Word_Boundaries
[19:08:59] <myname> Jesse: i'd say stuff like , shound not be in a word
[19:09:00] <acrichto> brson: ah, yes, I'll update the relnotes in that pull
[19:09:34] <engla> you have to mind stuff like the U+055A ( Õš ) ARMENIAN APOSTROPHE
[19:09:38] <engla> :-)
[19:10:08] <acrichto> brson: updated the pull
[19:10:56] <Jesse> what happens if you accidentally use an ARMENIAN APOSTROPHE in english?
[19:11:04] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[19:11:07] *** Quits: a_m0d (dschoof@moz-670D1285.commercial.cgocable.net) (Ping timeout)
[19:11:10] <kimundi> So, instead of cfg enabling debug, we now have to cfg disable debug?
[19:11:34] <luisbg> Jesse, :?
[19:11:37] <engla> Jesse: I think you will be fine, unless you are azerbadjani
[19:11:43] <acrichto> kimundi: yes
[19:11:51] <kimundi> acrichto: Sounds good :)
[19:11:58] <acrichto> kimundi: --cfg debug will no longer have a meaning defined by the compiler, --cfg ndebug will, however
[19:12:12] <kimundi> Less "Why does debug! never print anything?" questions
[19:12:47] <bernard> what can I do to include std::rt::io::BufferedReader in a project?  I can't seem to find what I should "use" / how I should declare it anywhere
[19:12:53] <kimundi> is it implemented as #[cfg(debug)] or #[cfg(not(ndebug))] ?
[19:13:10] <brson> acrichto: doesn't --enable-debug also turn on -Z debug-info?
[19:13:27] *** Quits: hoverbear (andrew@moz-D5078CE5.wireless.uvic.ca) (Quit: hoverbear)
[19:13:27] *** Joins: nejucomo (Adium@moz-434492BB.dsl.static.sonic.net)
[19:13:42] *** Joins: a_m0d (dschoof@moz-670D1285.commercial.cgocable.net)
[19:14:05] <brson> the anwser is 'no'
[19:14:09] <acrichto> brson: huh, it appears not yeah
[19:14:09] * brson should just read the patch
[19:14:12] <acrichto> I figured it would
[19:15:10] <brson> we probably shouldn't yet. i understand debug-info is still flakey
[19:15:36] <acrichto> sadly :(
[19:17:34] <acrichto> whomever suggested named arguments for format!, you're awesome
[19:17:48] <cmr> yes, I fully agree
[19:18:13] <acrichto> https://github.com/alexcrichton/rust/blob/rustdoc-web/src/rustdoc_ng/html/layout.rs#L20
[19:18:20] <sam113101> when will the current version turn to 0.8?
[19:18:21] <acrichto> that would be terrifying without named arguments
[19:18:27] <cmr> sam113101: next week or so
[19:18:30] <acrichto> sam113101: soon!
[19:18:35] <sam113101> cool
[19:18:38] <engla> whoever implemented format! is awesome ^^
[19:18:50] *** Joins: vodik (simon@moz-2D668626.cpe.net.cable.rogers.com)
[19:18:54] <sam113101> waiting for 1.0 to start learning rust
[19:18:57] <olsonjeffery> acrichto: what's the markdown formatter you use for rust code?
[19:19:02] <acrichto> olsonjeffery: pandoc
[19:19:04] <acrichto> the process
[19:19:08] <cmr> acrichto: yeah. old-fmt would have been miserable to do anything serious, but new-format is okish for serious text formatting.
[19:19:08] <olsonjeffery> i mean
[19:19:16] <olsonjeffery> ~~{.rust} ... ~~~ ?
[19:19:19] <olsonjeffery> what that it..
[19:19:23] *** Joins: spider-mario (spidermari@moz-2F72F6FF.dsl.quantic-telecom.net)
[19:19:27] <acrichto> olsonjeffery: ~~~{.rust}\n<code>\n~~~
[19:19:29] <cmr> olsonjeffery: that's pandoc
[19:19:42] <cmr> pandoc's markdown is a lot better than other markdowns.
[19:19:49] <acrichto> olsonjeffery: https://github.com/alexcrichton/rust/blob/rustdoc-web/src/libstd/fmt/mod.rs#L35
[19:19:53] <jesseray> Pandoc is awesome.
[19:20:01] <acrichto> I just with pandoc had a C api :(
[19:20:10] <acrichto> we're forking ~1billion times in rustdoc
[19:20:28] <acrichto> or if pandoc had a long-running process to act as a server-ish...
[19:21:21] <kimundi> sam113101: why wait? It's more fun to see it grow!
[19:21:41] <jesseray> ~~~{.rust}\n code code code \n~~~ is to get appropriate syntax highlighting for Rust code.
[19:21:49] *** Joins: dave1629 (dave@440B6A48.1CA5FEA3.DDE5D3F6.IP)
[19:22:16] *** Joins: six600110 (six600110@moz-2FA48202.neo.res.rr.com)
[19:22:28] *** Quits: dave1629 (dave@440B6A48.1CA5FEA3.DDE5D3F6.IP) (Quit: dave1629)
[19:22:52] <StarLight> sam113101: you can start learning it now, just read changelogs sometimes :P
[19:22:53] <jesseray> Is there a way to use iter() on a string such that you can refer to two characters at a time (the current char and the previous?) without using a mutable variable to hold the previous char?
[19:23:01] *** Joins: dave1629 (dave@440B6A48.1CA5FEA3.DDE5D3F6.IP)
[19:23:17] <kimundi> jesseray: well you could zip two iterators
[19:23:21] <sam113101> I'm learning D right now, rust is the next on my list, IÂ want it to be stable before IÂ start learning itâ€¦ so IÂ don't get confused by changes, etc.
[19:23:35] <jesseray> zip?
[19:24:12] *** Joins: maik (maik@moz-A79D08D1.dip0.t-ipconnect.de)
[19:24:18] <kimundi> rusti: let s = "abcdef"; let i1 = s.iter(); let i2 = s.iter().skip(1); for x in i1.zip(i2) { printfln!(x); }
[19:24:18] *** Quits: bernard (Mibbit@moz-5256162B.hsd1.ca.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[19:24:21] -rusti- pastebinned 6 lines of output: http://sprunge.us/OihX
[19:24:25] <sam113101> one of you should start writing a book on rust, I'd gladly buy it
[19:24:33] <cmr> sam113101: I've actually seriously considered it.
[19:24:52] <cmr> http://www.rustforrubyists.com/ exists.
[19:25:08] <kimundi> rusti: let s = "abcde"; let i1 = s.iter(); let i2 = s.iter().skip(1); for x in i1.zip(i2) { printfln!(x); }
[19:25:09] -rusti- ('a', 'b')
[19:25:09] -rusti- ('b', 'c')
[19:25:09] -rusti- ('c', 'd')
[19:25:10] -rusti- ('d', 'e')
[19:25:10] -rusti- ()
[19:25:19] <cmr> dbaupp: globs worked the first try \o/
[19:25:39] <jesseray> That's awesome =D
[19:25:42] <jxv> in haskell there's fst and snd for getting values out of tuples, is there an equivalent for rust? Or would tuples need to be pattern-matched?
[19:26:04] <kimundi> rusti: (1,2,3).second()
[19:26:05] -rusti- <anon>:7:9: 8:5 error: type `(<VI0>,<VI1>,<VI2>)` does not implement any method in scope named `second`
[19:26:05] -rusti- <anon>:7          (1,2,3).second()
[19:26:05] -rusti- <anon>:8     };
[19:26:05] -rusti- error: aborting due to previous error
[19:26:05] -rusti- application terminated with error code 101
[19:26:13] *** Joins: hoverbear (andrew@moz-D5078CE5.wireless.uvic.ca)
[19:26:16] <kimundi> rusti: (1,2,3).n1()
[19:26:16] -rusti- 2
[19:26:40] <engla> jxv: yes, first and second as methods do exist. or the generic n0, n1, n2,, etc
[19:26:44] <Jesse> rusti: (1,2,3)[1]
[19:26:44] -rusti- <anon>:7:9: 7:18 error: cannot index a value of type `(<VI0>,<VI1>,<VI2>)`
[19:26:44] -rusti- <anon>:7          (1,2,3)[1]
[19:26:44] -rusti-                   ^~~~~~~~~
[19:26:45] -rusti- error: aborting due to previous error
[19:26:45] -rusti- application terminated with error code 101
[19:26:46] <kimundi> rusti: let (a,b,c) = (1,2,3); a + b + c
[19:26:46] -rusti- 6
[19:26:49] <jxv> oh cool
[19:26:50] <engla> rusti: (1,2).first()
[19:26:51] <jesseray> I just rewrote my strip_control_characters() function to use iters, now I have a way to do the same for my strip_comments() function ^_^
[19:26:51] -rusti- 1
[19:27:00] *** Quits: Kruppe (user@moz-253119B0.esg.uwaterloo.ca) (Client exited)
[19:27:18] <myname> jesseray: that sounds like a job for map
[19:27:26] <myname> oh, no
[19:27:36] *** Joins: Kruppe (user@moz-253119B0.esg.uwaterloo.ca)
[19:27:42] * myname thinks
[19:27:59] *** Joins: maxli (maxli@moz-A607CA26.student.cs.uwaterloo.ca)
[19:28:18] <cmr> filter?
[19:28:26] <cmr> filter_map ?
[19:28:44] <myname> but it has to memorize something like "oh, here started a comment"
[19:29:07] <sam113101> I'll definitely check it out when it will be updated to rust 1.0 (will probably take some time). But it's great to be able to choose between multiple books.
[19:29:21] <doomlord_> fold
[19:29:25] <myname> btw: anyone can recommend a pentadactyl.xpi that is compatible with fx 24 and can actually scroll without driving me nuts?
[19:29:33] <sam113101> so it would still be great to write your own IMO
[19:29:39] <doomlord_> fold -> filter ?
[19:30:16] <jesseray> myname, that's right. I am currently using let mut inside_comment = true; and I toggle that boolean as I loop through the string.
[19:30:43] *** Joins: msch (msch@moz-DA0E34D4.clients.your-server.de)
[19:30:52] *** Joins: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net)
[19:31:23] <Luqman> jeaye: so i assume can https://github.com/mozilla/rust/issues/9189 be closed?
[19:31:49] <jesseray> here is the current state of the code (pardon the ugliness, I'm still getting my bearings on the language): http://mibpaste.com/uXVEn6 
[19:32:16] <jeaye> Luqman: Yeah, I think so. I didn't want to close it prematurely, but I think we're pretty resolved now. I've closed it.
[19:32:32] <jeaye> Thanks for the reminder.
[19:33:23] *** Quits: hoverbear (andrew@moz-D5078CE5.wireless.uvic.ca) (Quit: hoverbear)
[19:35:25] *** Quits: cdidd (cdidd@D1BF43F9.5CFBC045.62D8163C.IP) (Input/output error)
[19:37:39] <kimundi> jesseray: hm, would you mind pasting your code somewhere monospace font using and indentation preserving in the future? It's a bit hard to read :)
[19:37:49] <brson> not compressing metadata is so much faster. i wish we could turn it on
[19:37:54] <jesseray> sure, one sec.
[19:38:43] <engla> what compression algorithm was tested?
[19:40:14] <acrichto> argh I was so close, 2k lines of rust without an ICE and then I finally got one :(
[19:40:17] <engla> lz4hc should be the best option for compress-once and decompress-often
[19:41:04] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[19:41:04] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/O3-evA
[19:41:04] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[19:41:29] <acrichto> brson: btw looks like bors has been making lots of progress so I think that we found the source of the interrupted system calls
[19:41:43] *** Joins: hoverbear (andrew@moz-D5078CE5.wireless.uvic.ca)
[19:42:42] <jesseray> https://github.com/jesseray/rusticss/blob/master/main.rs
[19:43:44] <acrichto> brson: what was the problem last time of turning off compression?
[19:43:50] <brson> engla: we're using flate at the moment
[19:43:58] *** Joins: skade (skade@moz-4865967C.pools.arcor-ip.net)
[19:43:58] *** Quits: hoverbear (andrew@moz-D5078CE5.wireless.uvic.ca) (Quit: hoverbear)
[19:44:14] <brson> acrichto: it crashed the dynamic linker at runtime, presumably because of huge sections
[19:44:43] <acrichto> that's unfortunate :(
[19:44:49] *** Quits: skade (skade@moz-4865967C.pools.arcor-ip.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[19:46:05] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[19:46:05] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/33Bgzg
[19:46:05] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[19:46:06] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[19:46:06] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/mYJVLg
[19:46:06] <ghrust> 13rust/06auto 14833a64d 15Alex Crichton: Invert --cfg debug to --cfg ndebug...
[19:46:06] <ghrust> 13rust/06auto 142fd3c07 15bors: auto merge of #9278 : alexcrichton/rust/ndebug, r=brson...
[19:46:07] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[19:46:33] *** Quits: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[19:50:53] *** Quits: heftig (heftig@moz-F0FBD069.dip0.t-ipconnect.de) (Ping timeout)
[19:51:16] <acrichto> brson: I'm curious, if we started storing metadata in files alongside libraries instead of inside them, that should "fix" the problem, right?
[19:51:33] *** Joins: hoverbear (andrew@moz-D5078CE5.wireless.uvic.ca)
[19:53:18] *** Quits: maik (maik@moz-A79D08D1.dip0.t-ipconnect.de) (Ping timeout)
[19:53:40] <kimundi> jesseray: He, I think I can compress that quite bit with iterators :D. Gimme a few more minutes
[19:54:09] <jesseray> I'm trying the same thing. We'll compare solutions :P
[19:54:23] <brson> acrichto: yes
[19:55:28] *** Joins: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com)
[19:56:00] *** Joins: tdc (santegoeds@moz-ADD1F5DF.range86-135.btcentralplus.com)
[19:57:00] *** Quits: KindOne (KindOne@moz-8C42EF22.dynamic.ip.windstream.net) (Connection reset by peer)
[19:57:08] *** Joins: fabiand (fabiand@moz-4459CD86.adsl.alicedsl.de)
[19:57:43] *** Quits: dave1629 (dave@440B6A48.1CA5FEA3.DDE5D3F6.IP) (Quit: dave1629)
[20:00:15] *** Quits: hoverbear (andrew@moz-D5078CE5.wireless.uvic.ca) (Quit: hoverbear)
[20:01:29] *** Joins: riley_ (riley@8BA43816.9AA11D69.65DDFA89.IP)
[20:01:51] <acrichto> rusti: fn f<'self, T: Iterator<&'self int>>() {}
[20:01:52] -rusti- error: internal compiler error: unexpected failure
[20:01:52] -rusti- note: the compiler hit an unexpected failure path. this is a bug
[20:01:52] -rusti- note: try running with RUST_LOG=rustc=1 to get further details and report the results to github.com/mozilla/rust/issues
[20:01:52] -rusti- application terminated with error code 101
[20:01:58] <acrichto> does anyone know how to do that?
[20:02:03] <sw17ch> jesseray: `assert!(strip_comments(~"a") == ~"");` <-- is this correct?
[20:02:28] *** Quits: riley (riley@8BA43816.9AA11D69.65DDFA89.IP) (Ping timeout)
[20:03:00] <Eridius> acrichto: what do you mean, how to do that? I'm surprised that ICE's, but what's the issue otherwise?
[20:03:10] <jesseray> I wasn't sure what to do with CSS strings that were too small to contain valid CSS, so I just return an empty string.
[20:03:31] <acrichto> Eridius: I believe that there's an issue open already, but I'm curious if anyone knows a workaround
[20:03:58] <jesseray> At least an empty string would be valid, you know? :P
[20:04:08] <brson> what's blake2-ppc's irc nick?
[20:04:22] <Eridius> brson: engla
[20:04:33] *** Joins: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[20:04:34] <brson> lol
[20:04:36] <Eridius> acrichto: what causes the ICE? My first guess is the use of a lifetime parameter that doesn't actually show up anywhere else
[20:05:08] <brson> engla: how do you want your name and email to show up on the release announcement?
[20:05:11] <acrichto> Eridius: I think it has to do with it being called 'self, but I'm not sure :(
[20:05:15] <brson> engla: right now you're just blake2-ppc
[20:05:20] <Eridius> acrichto: ah, that could be it
[20:05:21] *** Parts: a_m0d (dschoof@moz-670D1285.commercial.cgocable.net) ()
[20:05:21] *** Quits: msch (msch@moz-DA0E34D4.clients.your-server.de) (Input/output error)
[20:05:22] *** Joins: KindOne (KindOne@moz-C94C4780.dynamic.ip.windstream.net)
[20:05:24] <engla> brson: I think that's fine
[20:05:25] *** Joins: msch (msch@moz-DA0E34D4.clients.your-server.de)
[20:05:27] <Eridius> brson: when is the release?
[20:05:37] <brson> Eridius: next week hopefully
[20:06:01] <Eridius> eek. I was hoping to get the path rewrite in, but I don't know if that's enough time :/
[20:06:19] * Eridius needs to finish adding tests to WindowsPath, then start porting all uses of path over
[20:06:29] <engla> brson: hm, I should probably have my email there after all
[20:07:21] <brson> klutzy: what about your name and email? at the moment i seem to have you as klutzy
[20:07:28] <brson> klutzytheklutzy
[20:07:33] <brson> i guess i have your email
[20:08:16] <pcwalton> is the lack of cross crate inlining of constants fixed?
[20:08:18] <pcwalton> I'm hitting that
[20:08:42] <acrichto> pcwalton: it should be
[20:08:51] <brson> is continuing to put everybody's name in the release announcement a good idea? i like giving everybody credit
[20:08:54] <acrichto> pcwalton: unless your constant is a slice or has an address of something
[20:08:58] <pcwalton> oj
[20:08:59] <pcwalton> ok
[20:09:04] <acrichto> brson: I like doing it as well
[20:09:06] <pcwalton> I'd have to upgrade servo's rust
[20:09:19] <acrichto> brson: I was really happy the first time I saw my name :)
[20:09:24] *** Joins: hoverbear (andrew@moz-D5078CE5.wireless.uvic.ca)
[20:09:26] <cmr> brson: you saw the git incantation in the issue about the credits, right?
[20:09:26] <brson> acrichto: me too :)
[20:09:32] <brson> cmr: no
[20:09:53] <cmr> guh
[20:09:55] <brson> sp3d: what about you? name and email for release announcement? right now you're sp3d
[20:10:29] *** Quits: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net) (Input/output error)
[20:11:36] <brson> engla: what email do you want listed?
[20:11:37] <cmr> brson: https://github.com/mozilla/rust/issues/5037
[20:13:40] *** Joins: radarsat1 (uid2860@moz-31ABA2C0.irccloud.com)
[20:13:55] <radarsat1> hello, what's the right way to initialize a vector of floats?  so far i'm trying "fn main() { let mut buffer: ~[float, ..1024] = ~[0.0f, ..1024]; }" but it doesn't work
[20:14:04] <radarsat1> haven't been able to find an example anywhere, sorry
[20:14:10] <Luqman> cmr: that does results in some duplicates though, since i've committed with i think 3 different email addresses :P
[20:14:16] <brson> cmr: oh, I'm doing exactly that
[20:14:22] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[20:14:23] *** Joins: SingingBoyo (singingboy@moz-15629474.ubcsecure.wireless.ubc.ca)
[20:14:57] <kimundi> jesseray: He, wrote a strip_comment that is halfway between iterative and functional xD
[20:15:01] <kimundi> jesseray: https://gist.github.com/Kimundi/6643193
[20:15:24] <cmr> Luqman: that's what the mailmap is for.
[20:15:34] * kimundi is not sure if that code is easier to understand...
[20:16:16] <Luqman> cmr: oh! i didn't know about .mailmap
[20:17:27] <sw17ch> how long until the release?
[20:17:36] <kimundi> radarsat1: You're almost correct there. Only problem is that ~[float, ..N] is not a valid vector type
[20:18:02] <benh> radarsat1: minimal change to compile that is ~([0.0f, ..1024])
[20:18:03] <cmr> sw17ch: a week or so
[20:18:19] <kimundi> radarsat1: you want jsut ~[float] there. You can also leave of the type and it will infer: let mut buffer = ~[0.0f, ..1024];
[20:18:45] <kimundi> benh: That gives him an fixed sized vector though, which I'm not sure is better here
[20:18:57] <brson> 0.8 contributors https://gist.github.com/brson/6643240
[20:19:00] <benh> yeah
[20:19:16] <kimundi> I mean, he already has a ~ ptr, no need to use the more annoying vector variant
[20:19:29] <radarsat1> ah, thanks
[20:19:38] <radarsat1> i don't fully understand why the () brackets are needed?
[20:19:42] <benh> But maybe a fixed size vector is appropriate here so we might be better off dropping the ~!
[20:19:47] <brson> 0.8 had 19 more contributors than 0.7
[20:19:52] <radarsat1> yes, i did want a fixed-size vector
[20:20:04] <kimundi> radarsat1: You don't want the version with the brackets I think
[20:20:10] <acrichto> 119 contributors is impressive
[20:20:11] <kimundi> radarsat1: ... or you do okay
[20:20:14] <benh> radarsat1: There's, like, ~[T] which is a dynamically sized vector
[20:20:30] <acrichto> brson: bors is missing from the list :(
[20:20:38] <acrichto> he did so much work
[20:20:39] <benh> and ~[T, .. N] which is a statically N-sized vector in a box
[20:20:42] <cmr> brson: it this all contributors ever or just people who have a commit in 0.7..0.8
[20:20:46] <kimundi> radarsat1: the brackets are needed because ~[0.0f, ..1024]; is being parsed as constructor for a ~[float]
[20:20:54] <Luqman> brson: typo for Michael Woerister's email
[20:20:54] <benh> but ~[t, .. N] as an expression seems to construct a dynamically sized vector instead
[20:20:56] *** Quits: hoverbear (andrew@moz-D5078CE5.wireless.uvic.ca) (Quit: hoverbear)
[20:20:59] *** Joins: andrew-d_w (andrew-d_w@moz-5A92CAFF.dsl.static.sonic.net)
[20:21:00] *** Quits: andrew-d_w (andrew-d_w@moz-5A92CAFF.dsl.static.sonic.net) (Input/output error)
[20:21:05] <benh> the ( ) breaks it up into a statically sized vector that is then put into a box
[20:21:09] <brson> acrichto: yeah, i didn't include bors in 0.7 either
[20:21:11] <radarsat1> ah i see, without the type annotation it compiles without brackets thanks
[20:21:12] <myname> one: cut a hole in a box... two: put your vec in that box...
[20:21:12] <brson> cmr: just 0.8
[20:21:14] <acrichto> :(
[20:21:21] *** Joins: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net)
[20:21:26] <cmr> Luqman: not a typo, it's what mw has set as his email in commits.
[20:21:32] <acrichto> maybe that's why bors has been failing all our requests lately
[20:21:41] <brson> Luqman: I'm guessing he did that on purpose?
[20:21:42] <kimundi> radarsat1: A [0.0f, ..1024] alone is a constructor for a fixed size vector. To construct such one behind a owned ptr, you there fore need to seperate them by wrapping the altter in ()
[20:21:48] <radarsat1> myname: lol
[20:22:06] <radarsat1> kimundi: ok thanks
[20:22:25] <kimundi> radarsat1: hm, so do you want an fixed sized vector or not?
[20:22:26] <radarsat1> is a fixed-size vector allocated on the stack by default?
[20:22:27] * benh ctrl-f's the contributor list for .de> to find rustic compatriots
[20:22:33] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[20:22:53] *** Joins: tjc (tjc@moz-61292EE3.static.cruzio.com)
[20:22:53] *** ChanServ sets mode: +o tjc
[20:23:04] <radarsat1> kimundi: what i want is a fixed-sized vector that i can pass to a task
[20:23:08] <radarsat1> (by reference)
[20:23:36] <benh> moving it?
[20:23:49] <jesseray> kimundi: cool looking code. I'm having trouble even writing an iterator version that works, lol.
[20:23:53] <radarsat1> yes i want the task to fill out its contents then return it
[20:23:56] <benh> Maybe then putting it ino a ~-box is the right approach after all
[20:24:15] <radarsat1> actually not return it but pass it through a channel
[20:24:26] <radarsat1> so i want move semantics
[20:24:43] <radarsat1> anyways, that helps so far, thanks, i'll keep working on it
[20:24:56] <benh> ~-boxes do that, so let blah = ~([0.0f, ..1024]); might be right after all
[20:24:56] *** Joins: redBuggie (Mibbit@2CDD6BC3.387BC77F.DDE5D3F6.IP)
[20:25:25] <redBuggie> what is the rust equivalent of a C function exit?
[20:25:27] <radarsat1> benh: ok thanks
[20:26:01] <joelteon> redBuggie: you can't
[20:26:03] <cmr> redBuggie: std::libc::exit. well-behaved rust programs don't call exit, they just return from main.
[20:26:11] <joelteon> oh
[20:26:16] <redBuggie> thak you'
[20:26:20] <redBuggie> thank you
[20:26:36] *** Quits: fabiand (fabiand@moz-4459CD86.adsl.alicedsl.de) (Quit: Verlassend)
[20:27:06] *** Quits: spider-mario (spidermari@moz-2F72F6FF.dsl.quantic-telecom.net) (Input/output error)
[20:27:26] <kimundi> radarsat1: Usually you don'T want an fixed sized vector in a owned box thogh, but directly an owned vector
[20:27:50] *** Quits: nejucomo (Adium@moz-434492BB.dsl.static.sonic.net) (Quit: Leaving.)
[20:28:34] *** Quits: bent (chatzilla@moz-932324BF.hsd1.ca.comcast.net) (Quit: ChatZilla 0.9.90.1-rdmsoft [XULRunner 22.0/20130619132145])
[20:31:23] <brson> i'm not optimistic about our chances of upgrading mingw before 0.8. seems pretty risky
[20:31:58] *** Quits: redBuggie (Mibbit@2CDD6BC3.387BC77F.DDE5D3F6.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[20:32:03] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[20:32:30] *** Quits: slack1256 (slack@moz-542CA772.baf.movistar.cl) (Ping timeout)
[20:32:40] *** Joins: tcsc (tcsc@moz-ADC0ED45.hsd1.ct.comcast.net)
[20:32:56] <mcpherrin> Is there any possiblity of using MSVC instead of mingw?  I seem to recall seeing a bug open about that
[20:33:22] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[20:33:37] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[20:33:43] *** Quits: [squiddy] (squiddy@moz-CE21F9D6.adsl.alicedsl.de) (Quit: Leaving)
[20:34:13] <mcpherrin> (I ask out of idle curiosity, mostly, but if it's not enormous I need an excuse to learn microsoft tooling better)
[20:34:40] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[20:35:33] <cmr> mcpherrin: not really, since their linker isn't redistributable.
[20:35:36] <cmr> And we need a linker
[20:35:42] <cmr> I mean... we could
[20:35:46] *** Joins: slack1256 (slack@moz-7BE825C.baf.movistar.cl)
[20:35:47] <cmr> But it seems like it'd be a net loss.
[20:36:10] *** Quits: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net) (Input/output error)
[20:36:59] *** Joins: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net)
[20:37:00] <strcat> we can start using lld on windows soon enough
[20:38:32] <mcpherrin> I suppose we could require anyone who wants to use rust to have link.exe around
[20:38:43] <brson> msvc compatibility is desirable
[20:38:44] *** Joins: jgilbert (jgilbert@moz-BBE3ABD.mv.mozilla.com)
[20:39:14] * brson lunch
[20:39:36] *** Joins: cdidd (cdidd@moz-D72A2CD5.broadband.corbina.ru)
[20:40:03] <strcat> mcpherrin: LLVM has their own linker
[20:40:06] <strcat> and it works on windows
[20:40:12] <strcat> and is compatible with MSVC
[20:40:34] <strcat> we can also drop gcc-libs by static linking in compiler-rt
[20:41:14] <mcpherrin> Does lld actually work yet?
[20:41:16] <strcat> yes
[20:41:32] <strcat> mcpherrin: http://blog.llvm.org/2013/09/a-path-forward-for-llvm-toolchain-on.html
[20:42:08] <strcat> seems to me that the path forward is to not use mingw or MSVC, but just LLVM's toolchain
[20:42:42] <acrichto> I wonder if we'd still need to bootstrap llvm
[20:42:47] <vadimcn> acrichto: Hi.  So where do we stand with migration to mingw4.0 ?
[20:42:55] <acrichto> although that would be llvm's problem to figure out how to compile itself I suppose
[20:43:14] <strcat> acrichto: it can compile itself on windows, we'd need to ship clang with our snapshots
[20:43:26] <strcat> and drop the mingw dep completely
[20:43:26] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[20:43:30] <acrichto> vadimcn: I've been swamped in getting rustdoc_ng + rustdoc_web up and running, so it looks like it won't make it for 0.8, but I think that we can get it afterwards
[20:44:06] <kimundi> acrichto: No new docs for 0.8? :(
[20:44:20] <acrichto> kimundi: oh that "it" was referring to mingw4
[20:44:27] <acrichto> kimundi: I'm firing all cylinders to get these in for 0.8 :)
[20:44:43] <kimundi> ah, good :)
[20:45:26] <vadimcn> pity, 0.8 will be nigh unusable on windows :(
[20:45:44] <kimundi> jesseray: If you need any guidance in using iterators, just ask :)
[20:45:51] <benh> http://ix.io/8aY i feel like the borrow checker ought to allow this but i can't put into words why, help :(
[20:46:07] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[20:46:50] <olsonjeffery> acrichto: when you use ~~~{.rust} do you have to indent code, still?
[20:46:56] <vadimcn> the other options is to bundle runtime libs with it, of course...
[20:47:09] <strcat> benh: what error do you get?
[20:47:20] <acrichto> olsonjeffery: normally no
[20:47:29] <benh> strcat: the closure tries to immutably borrow s while the call to drop_until mutably borrows it
[20:47:32] <acrichto> olsonjeffery: but I prefer the actual source to look good over good-looking documentation
[20:47:33] <GregorR> The build engineer in me asks: Does rust have or have planned any facilities for conditional compilation based on the presence or absence of given modules/functions/types? (If this existed in C, autoconf wouldn't exist at all, and "we plan on being correct from the beginning" is a nonsolution...)
[20:47:41] <kimundi> benh: drop_until makes s inaccessible for anything else become it borrows as &mut. Therefore the inner check() that tries to borrow as & fails
[20:47:43] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[20:47:47] *** Quits: Larry (larryfox@moz-343B6F0C.nyc.biz.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[20:47:58] <strcat> benh: ah yeah, what you should do is pass the state you need from the function to the closure
[20:47:59] <acrichto> GregorR: we have the #[cfg] attribute which allows you to conditionally compile functions (it's used in libstd a lot for various platforms)
[20:48:02] <cmr> GregorR: Hm, that's an interesting idea, I haven't thought of it before.
[20:48:06] <kimundi> s/become/because/
[20:48:12] <benh> I feel that it's fine because I can't come up with anything that an immutable closure can do with just s itself to cause a problem
[20:48:17] <cmr> acrichto: yeah but that's no better than ifdefs with autoconf
[20:48:22] <strcat> benh: what you have now wouldn't be memory safe - drop_until could clear the whole vector
[20:48:38] <benh> strcat: but that would be ok, wouldn't it?
[20:48:40] <acrichto> cmr: hm, I suppose yeah
[20:49:01] <GregorR> cmr: Spending years of your life doing build engineering tends to make one's desire in language features slightly unusual ;)
[20:49:05] <strcat> benh: borrowck is function-local, so as far as it's concerned it's not okay
[20:49:12] <strcat> benh: check() could take a reference until the array
[20:49:14] <radarsat1> excellent, i got my code working -- an audio coroutine unit generator.. https://github.com/radarsat1/rustaudio/blob/master/plucking_task_vector.rs
[20:49:32] <cmr> GregorR: How do you see this working?
[20:49:40] <cmr> In your ideal language/solution.
[20:49:45] <strcat> benh: er, into the array
[20:49:54] <benh> strcat: I can see how it is a problem when the closure borrows an element of the vector, yeah
[20:50:07] <benh> but it feels like a vaguely distinct case :(
[20:50:15] <strcat> benh: you can still write it
[20:50:17] <strcat> just not like that
[20:50:17] <engla> benh: calling shift each time is very expensive anyway.. you'd be much better off to just find the cutoff index first and then do the mutation
[20:50:31] <kimundi> GregorR: In theory, once we get custom loadable syntax extensions that can hook into attributes, you could write some kind of conditional compilation that works like that I guess. Might be complicated though because there is a circular dependence between resolving item and conditionally prevent them to be resolved based on other items
[20:50:32] <strcat> that's true too ;p
[20:50:33] <benh> yeah yeah, it's just the first mutating example I could think of
[20:50:45] <strcat> benh: pass the state to the closure from the fn
[20:51:03] <benh> yeah that's what i did at first in the actual real that this tries to reproduce
[20:51:21] <GregorR> cmr: It's more about compatibility with multiple and evolving implementations than anything else. Stuff like "if we have the transaction module available, do this transactionally, else use this different technique". Or even "if we have cstrlen available, just use the builtin one, otherwise we're on an earlier version of rust so I'll provide my own".
[20:51:21] <benh> but aaaah, come on, just borrowing s itself is clearly safe! it's not going anywhere!
[20:51:35] <strcat> vadimcn: hm, why will 0.8 be more unusable than 0.7?
[20:51:48] <vadimcn> strcat: 
[20:52:17] <strcat> benh: it doesn't see that
[20:52:22] <Eridius> GregorR: I wonder if it would suffice to be able to query rustpkg for the availability of modules?
[20:52:24] <strcat> check() could do anything ;p
[20:52:25] <vadimcn> strcat: 'cause 90% of users won't be able to hunt down the right versions of those dlls
[20:52:47] <GregorR> kimundi: Hmm... I'm trying to figure out if there's a very simple, small enhancement that (1) could and would be supported by all hypothetical implementations of rust and (2) would not require dragging extra stuff along with any package that uses it.
[20:52:48] <strcat> vadimcn: I could drop the dependency on mingw dlls pretty easily...
[20:52:56] <strcat> afaik it mostly means statically linking compiler-rt
[20:53:00] <benh> strcat: but check() doing anything is okay, isn't it? it's an immutable borrow, it can't really break anything that a regular call to check outside of the closure wouldn't also break?
[20:53:09] <vadimcn> strcat: how?
[20:53:19] <strcat> well gcc-libs is the easy one to remove
[20:53:20] <benh> I can't come up with something evil that check or the closure could do with *just* a borrow to s, which is why i'm confused
[20:53:37] <strcat> we could use libc++ instead of libstdc++, and ship it with our LLVM too
[20:53:39] <benh> It's obvious if it borrows s.contents[3] or something :/
[20:53:39] <GregorR> Eridius: Modules aren't sufficient. When I worry about build issues, it usually has to do with differing implementations of things. Obviously there's only one rust for now, but I don't trust any language with only one implementation, and it would be better to bake in features that make multiple implementations less hellish before they start springing up :3
[20:53:48] <strcat> although it'd be easier to just make the tiny bit of runtime code not C++
[20:53:52] <GregorR> Eridius: (Although that would be a nice step)
[20:54:03] <Eridius> GregorR: If multiple implementations of rust have observable behavioral differences, that's kind of a problem, no?
[20:54:06] <strcat> I don't know what mingw does about libc
[20:54:15] *** Quits: sw17ch (sw17ch@moz-62998E95.hfc.comcastbusiness.net) (Quit: sw17ch)
[20:54:18] <GregorR> Eridius: Of course it is. It's also inevitable.
[20:54:57] <Eridius> GregorR: one would hope that any secondary implementations of rust would be able to pass the complete "primary" rust test suite
[20:55:01] <vadimcn> strcat: what would you use in place of libgcc ?
[20:55:07] *** Joins: skade (skade@moz-4865967C.pools.arcor-ip.net)
[20:55:09] <strcat> vadimcn: compiler-rt
[20:55:20] <strcat> we need to already not be using libgcc because it's missing functions LLVM expects
[20:55:26] <vadimcn> strcat: AFAIK it does not contain stack unwinding code
[20:55:41] <vadimcn> strcat: that lives in libgcc
[20:55:41] <strcat> vadimcn: that's what libc++/libc++abi have
[20:55:44] <strcat> no
[20:55:51] <strcat> stack unwinding is in libsupc++
[20:56:25] <strcat> LLVM has C/C++ working independently of MSVC/mingw on windows
[20:56:29] <GregorR> Eridius: There are so many separately evolving systems, and never one complete language, that it's impossible to imagine that they're all /the same/. Even C has new standards, and the only way to test for their support is one big __STDC_VERSION__ macro which is literally always a lie.
[20:56:42] <Eridius> GregorR: C also has large swathes of implementation-defined behavior
[20:56:59] <GregorR> I'm not saying that rust isn't starting out on a much firmer foundation than C ;)
[20:57:06] <olsonjeffery> acrichto: r? https://github.com/mozilla/rust/pull/9366
[20:57:24] <Eridius> although I do see your point about multiple versions of rust. I suppose you could use the version of libstd as a placeholder for that though, in this hypothetical query-rustpkg-for-module-info system
[20:57:34] <GregorR> Eridius: That's very coarse.
[20:58:11] <kimundi> GregorR: Coarse enough imo. If the libraries don't offer the same functionality, they're not identical.
[20:58:36] <Eridius> GregorR: I would hope that when writing projects that have to be compatible with multiple versions of rust, you wouldn't have to worry about rust master, and if everyone's on stable versions of rust then a version number suffices
[20:59:07] <Eridius> and I mean the rust master right now is 0.8-pre so you could detect that if you wanted
[20:59:13] <acrichto> olsonjeffery: thanks!
[20:59:40] <GregorR> kimundi: If I'm a user of an /API/, not a library, then I don't care if they're identical.
[20:59:41] <vadimcn> strcat: maybe I'm missing something, but I think low-level dwarf stack unwinding stuff lives in libgcc.   Stuff like _Unwind_RaiseException
[21:00:25] <vadimcn> strcat: I'd love to be proven wrong, but the only other lib I could find that implements dwarf unwinding was libunwind...
[21:00:45] <strcat> vadimcn: it lives in libsupc++
[21:01:05] <strcat> maybe it's linked into your gcc-libd
[21:01:10] <benh> ( strcat: the real code that this tries to emulate is the look_ahead function in the parser, which i tried to ease towards having methods on &mut when they mutate the parser state, but that turned out to be a lot less trivial than i hoped :( )
[21:01:22] *** Parts: radarsat1 (uid2860@moz-31ABA2C0.irccloud.com) ()
[21:01:34] <strcat> vadimcn: libc++abi (libc++) and libsupc++ (libstdc++) define an exception ABI
[21:01:44] <strcat> libc++ can use either ABI
[21:01:48] <GregorR> Eridius: I'm kinda put off by any talk of a language that assumes it will always and forever have a single implementation. I basically don't trust any language without multiple implementations. (Of course I don't expect magic for new languages, I was just wondering if anyone was thinking about the implications on the language itself in that direction)
[21:02:04] <strcat> but is only a complete C++11 implementation with libc++abi, since the gcc devs aren't done implementing the required parts
[21:02:20] <Eridius> GregorR: I don't think anyone is saying there will never be another implementation. I'm just saying that another implementation would have to be able to pass the "primary" rust test suite, or else it's not correct
[21:02:21] <kimundi> GregorR: Okay, I understand what you're saying, I'm just not sure how and where such an API query system would fit into the broad design of rust as-is
[21:03:08] <kimundi> GregorR: And if it passes the testsuite, it can also compile our std lib
[21:03:14] <vadimcn> strcat: ok, I'm out of my depth here I guess.   But migration away from gcc libs is not in the cards for 0.8 either, is it?
[21:03:19] <GregorR> Eridius: Right, but passing the primary rust test suite is not equal to being the same language. Imagine for example that the other rust is GNU rust so it adds a bunch of random crap that nobody wanted anyway. Now you have to be able to test that, and test what rust version, AND test what GNU rust version.
[21:03:28] <cmr> vadimcn: given that 0.8 is in the next week or so, probably not
[21:03:44] <strcat> vadimcn: I don't think it would be that hard
[21:03:48] *** Quits: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Quit: msingle)
[21:03:52] <GregorR> kimundi: I'm merely rocking the boat. I have only thoughts, not suggestions :)
[21:03:53] <strcat> it would mean building more stuff with our LLVM
[21:03:57] <strcat> and making a new snapshot
[21:04:01] <strcat> making sure that it all works
[21:04:04] <Eridius> GregorR: I would certainly hope that such a hypothetical GNU-crap-ified rust variant would keep the GNU crap in a separate library than libstd
[21:04:10] <Eridius> i.e. gnu::crap::foo()
[21:04:19] <benh> no polemics!
[21:04:29] <cmr> benh++
[21:04:36] <vadimcn> strcat: I'd argue that moving build bots to mingw4 would be easier.
[21:04:43] <GregorR> Eridius: Hmmm, that's certainly fair. So I suppose it would come down to simple rustpkg querying again.
[21:04:46] <GregorR> *strokes chin thoughtfully*
[21:04:53] * mcpherrin makes McRust, now with more dollar menu value
[21:04:53] <strcat> vadimcn: I guess
[21:05:07] <strcat> we already need to make a new snapshot because it's broken on linux if your distro doesn't have libtinfo so we can fix the windows issues at the same time
[21:05:17] <Eridius> GregorR: that's my hope, anyway
[21:05:26] <vadimcn> strcat: ... or bundling old libs with release
[21:05:45] <Eridius> GregorR: it's always possible for someone to do something stupid and just silently add stuff to libstd, but then again, someone could also make a rust that simply doesn't pass tests either. Both wouldn't be very smart
[21:06:08] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[21:06:08] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/mYJVLg
[21:06:08] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[21:06:14] <GregorR> *nod*
[21:06:42] <kimundi> GregorR: I guess what we're arguing about here is that "how to handle a rust variant in rust that is not correct rust" is a bit of a slippery slope
[21:06:53] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[21:07:11] <sebcrozet> Hi, what do I have to do to have my doc formated like http://seld.be/rustdoc/master/index.html (or is this not part of the rust doc generator?) ?
[21:07:17] <mcpherrin> I think this sort of thing only really becomes relevant when there is another rust imlementation :P
[21:07:18] <kimundi> Why adding support for easily diverging the language spec etc
[21:08:26] <Eridius> sebcrozet: that's rustdoc_ng
[21:08:48] <strcat> btw about Cell, I don't think it's going to be needed
[21:08:59] <strcat> we just need to be able to move a mutable Option into a closure
[21:09:00] <cmr> sebcrozet: acrichto is very close to a pure-rust version of it to be integrated into mainline for 0.8
[21:09:03] <strcat> and Cell will become obsolete
[21:09:06] <cmr> Like, http://www.contrib.andrew.cmu.edu/~acrichto/doc/std/index.html close
[21:09:23] <GregorR> kimundi: It neither makes it easier nor more difficult to "do rust wrong", it only makes it easier to cope.
[21:09:57] <Eridius> GregorR: random thought: if someone else makes a rust that "does it wrong", who's to say they'll implement whatever facility you want to be able to query for this sort of thing?
[21:10:00] <benh> http://www.contrib.andrew.cmu.edu/~acrichto/doc/std/option/index.html doesn't seem very complete :'(
[21:10:05] * strcat wishes good luck to anyone who wants to make another implementation, because unsafe rust exposes LLVM semantics directly
[21:10:10] <GregorR> Eridius: THAT'S the slippery slope :)
[21:10:12] <Eridius> benh: click on the enum or trait
[21:10:32] <sebcrozet> cmr: ah, great. Iâ€™ll wait then.
[21:10:46] <benh> hmm
[21:10:49] <strcat> although I guess the LLVM semantics are close to C's
[21:10:55] <strcat> not quite
[21:10:57] <sebcrozet> cmr: great work on rustdoc_ng by the way!
[21:11:01] <acrichto> benh: hmm, Seldaek has some improvements to those pages which I haven't ported just yet
[21:11:08] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[21:11:09] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/ZUpnVw
[21:11:09] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[21:11:10] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[21:11:10] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/AdasPQ
[21:11:10] <ghrust> 13rust/06auto 1488bc11e 15Alex Crichton: Document a few undocumented modules in libstd...
[21:11:10] <ghrust> 13rust/06auto 14a95604f 15bors: auto merge of #9276 : alexcrichton/rust/dox, r=brson...
[21:11:11] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[21:11:22] * benh hopes the first independent implementation of rust compiles to haskell or something weird
[21:11:34] <kimundi> GregorR: That said, I think it would still be relatively easy to hack such an conditional query system into the compiler. Of course it would only help for a different implementation of the stdlib, so...
[21:11:43] *** Quits: ceninan (ceninan@moz-6BD43586.a370.priv.bahnhof.se) (Ping timeout)
[21:11:54] <Eridius> benh: that would be kind of awesome
[21:12:14] <kimundi> GregorR: Not that useful if the thing you can detect is also the thing that's most easily replaceable
[21:13:11] <kimundi> GregorR: Like, you can just put a #[no_std] into your crate and ship your own clone of the stdlib, which would do the same for any rust compiler
[21:13:25] <luisbg> how do you make a value inside a struct mutable?
[21:13:36] <Eridius> a hypothetical rustpkg query system could check the attributes on librustc. Looks like librustc already has a url attribute
[21:13:41] <kimundi> luisbg: by putting the struct itself into a mutable location
[21:13:50] <Eridius> that would be an easy way to test what compile you're using (as long as replacements also provide url)
[21:13:56] <kmc> benh: I was vaguely thinking of writing a toy compiler from a Rust subset to C
[21:14:12] <Eridius> luisbg: typically you don't. A struct field is mutable if the struct itself is mutable (i.e. if it lives in a mutable location)
[21:14:17] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[21:14:23] <kmc> mostly as a learning exercise to understand the borrow checker etc. better
[21:14:27] <Eridius> luisbg: & and @ are the two barriers to mutability, where you have to say &mut or @mut if you need that
[21:14:41] <luisbg> Eridius, what about ~str ?
[21:14:48] <benh> kmc: ah, but then you can't just run your tasks on the ghc runtime :)
[21:14:52] <kmc> yeah
[21:14:54] <kmc> GHC runtime is badass
[21:14:56] <Eridius> luisbg: mutability of ~ is inherited
[21:15:00] <strcat> luisbg: just a regular owned value
[21:15:02] <kmc> I always thought somebody should target another language to it
[21:15:18] *** Joins: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP)
[21:15:46] <kmc> luisbg: mutability is set by the root of the ownership tree, which is either an @/@mut box or a local variable (from "let" or an arg or a match etc)
[21:16:42] *** Quits: vodik (simon@moz-2D668626.cpe.net.cable.rogers.com) (Ping timeout)
[21:16:42] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[21:16:46] <kmc> rusti: let mut x: ~str = ~"hello"; x.push_str(", world"); x
[21:16:47] -rusti- ~"hello, world"
[21:16:57] <luisbg> kmc, I get that :)
[21:17:08] <luisbg> just a bit trickier when the ~str is a value inside a struct
[21:17:24] <kmc> well it will come down to whether the struct is stored in a "let" or a "let mut" or an @ or an @mut etc
[21:17:30] <luisbg> since when you intialiaze a new struct you need to give a value to it
[21:17:55] <kimundi> GregorR: Anyway, your input is valuable, at this point it's just too early I think to really know what would be the best course of action for handling such an situation.
[21:17:56] <Eridius> luisbg: what does that haev to do with mutability?
[21:18:08] <benh> I'm distraught how widespread putting everything into new ownership trees intead of threading mutability through all the code is. In C++ putting mutable everywhere would be cheating :(
[21:18:12] <kmc> &/&mut describe mutability too, but it's just reflecting what's already set up by the ownership trees
[21:18:16] <luisbg> Eridius, I'm basing this in some related code for an other platform, which is why I'm wondering the same
[21:18:25] <luisbg> the other code doesn't seam to handle mutability
[21:18:47] <kmc> benh: you mean putting in an @mut box for the sake of easy mutability only?
[21:19:14] <benh> I'm sure there's also other things that it makes easier, but yeah, a lot of things seem to be in @mut boxes in immutable objects
[21:19:20] <kmc> that's too bad yeah
[21:19:21] <benh> (or in more @mut boxes)
[21:19:43] <benh> I think it's mostly because @-boxes were there before all the other bits
[21:19:48] <luisbg> anybody has a minute to check my code?
[21:19:55] <kmc> on the other hand, many C++ projects ignore const correctness entirely...
[21:19:59] <luisbg> two small blocks I can pastebin
[21:20:03] <kmc> luisbg: sure
[21:20:23] *** Quits: saml (sam@moz-14C16814.cst.lightpath.net) (Quit: Leaving)
[21:20:38] <benh> somehow that feels less wrong to me, maybe because mutability is just the default in C++
[21:21:51] <kmc> or because C++ doesn't claim to provide safety the way Rust does
[21:22:00] <luisbg> kmc, http://pastie.org/8342746 <- this is existing code in Servo, it is for mac os
[21:22:00] <strcat> benh: it's not only the default but it doesn't provide immutable references at all
[21:22:06] <strcat> const& doesn't mean immutable
[21:22:15] <luisbg> kmc, and I am trying to write the following: http://pastie.org/8342748
[21:22:18] <strcat> it means it cannot be written to through *this* reference
[21:22:31] <luisbg> kmc, but the compiler complains about self.url being immutable
[21:22:38] <strcat> and std::shared_ptr is mutable in C++, unless the object inside is const, afaik.
[21:22:49] <benh> Yeah, I just mean, in C++ it feels okay to have a huge pile of wrongly non-const stuff and you can always const the bits you care about being const
[21:22:49] <kmc> luisbg: should be fn run(&mut self) then
[21:23:06] <strcat> benh: it should feel wrong to use @mut
[21:23:16] <benh> but with rust having every object immutable by default, routinely breaking wrong that with @mut makes me uncomfortable
[21:23:26] <strcat> benh: good
[21:23:28] <luisbg> kmc, oooh! like they do in fn add_prompt() since that is where the value is mutated
[21:23:29] <benh> ok :)
[21:23:44] <kmc> well the object is still immutable in a sense, even if it contains an @mut
[21:23:48] <strcat> benh: using @mut/RcMut (or a potential Mut<T>) should feel like a hack
[21:24:00] <strcat> you are opting out of fast, statically checked mutability for dynamic checking
[21:24:07] <strcat> you are turning compile-time errors into runtime errors
[21:24:10] <strcat> it should feel awful. ;p
[21:24:11] <benh> strcat: but that doesn't make me feel very good about the bits of the compiler I've looked at so far :(
[21:24:14] <luisbg> kmc, in a sense?
[21:24:17] *** Joins: tikue_ (tkuehn@E004E0C5.B9B3942C.689607DE.IP)
[21:24:23] <strcat> benh: it shouldn't, rustc isn't written in modern rust
[21:24:26] <strcat> it evolved to what it is today
[21:24:27] <kmc> luisbg: sorry that was for benh 
[21:24:42] <strcat> benh: the compiler isn't a good rust codebase
[21:24:45] <strcat> parts of it are.
[21:24:55] <luisbg> kmc, no problem :)
[21:24:56] <benh> mhm
[21:24:56] <kmc> strcat: I'm not prepared to say that any time you're solving a problem involving cyclic data structures, you're solving the wrong problem
[21:24:57] <benh> Which parts? :)
[21:24:58] <luisbg> kmc, thanks for the help!
[21:25:02] <strcat> the stdlib is of much higher quality than librustc/libsyntax
[21:25:04] <kmc> that kind of rhetoric kinda drove me out of the Haskell community
[21:25:14] <benh> Also is there a consensus whether things like streams/files/chans/ports ought to be "mut"?
[21:25:23] <kmc> (among many other things)
[21:25:38] <strcat> kmc: so why not just store the graph in a map?
[21:25:50] <kmc> and garbage collect the keys yourself?
[21:26:04] <kmc> and introduce a ton of boilerplate to use it?
[21:26:09] <amatus> kmc: let us know how you really feel
[21:26:11] <tikue_> kmc: can you use @mut? that's what i did with the frame trees
[21:26:14] <strcat> kmc: graph libraries don't require 'a ton of boilerplate' to use
[21:26:14] *** Quits: Kruppe (user@moz-253119B0.esg.uwaterloo.ca) (Client exited)
[21:26:56] <kmc> look, reference counting and garbage collection are massively successful ideas in computer science; surely they have a valid place in Rust even if we prefer other solutions when available
[21:26:59] <kimundi> In anycase, we support cyclic datastructures and will continue to in the future
[21:27:00] <strcat> tikue_: sure, but @mut gives up all of rust's static guarantees
[21:27:04] <kmc> you shouldn't "feel awful" for using the right tool for the job
[21:27:10] <strcat> kmc: @/Rc are totally fine
[21:27:13] *** Quits: tdc (santegoeds@moz-ADD1F5DF.range86-135.btcentralplus.com) (Ping timeout)
[21:27:22] <strcat> it's when you introduce mutability that you're getting nothing from rust's semantics
[21:27:28] <strcat> it's just a more painful version of other languages
[21:27:34] <kmc> yeah
[21:27:36] <kmc> that's fine though
[21:27:44] <kmc> I mean it's better than using other languages for the whole project ;P
[21:27:50] <tikue_> kmc++
[21:27:53] <strcat> kmc: maybe... depends on how pervasive @mut is
[21:27:58] <benh> gee
[21:28:02] <kmc> and Rust is nicer than C++ in many ways that have nothing to do with those static guarantees
[21:28:09] <strcat> I think rust with heavy usage of @mut is a lot worse than ocaml/c#
[21:28:11] <luisbg> kmc, http://pastie.org/8342759 <- it doesn't like the return of my prompt_value()
[21:28:17] <luisbg> it says it can't dereference it
[21:28:32] <doomlord_> what is it that makes @mut worse than the behaviour in c#
[21:28:56] <kmc> for the record I agree that @mut has problems and will be happy to see it replaced with RcMut<T>
[21:29:07] <kmc> or some other better thing
[21:29:11] <strcat> kmc: well, Rc<Mut<T>> or Rc<T> with a Mut field or two is what I currently want ;p
[21:29:21] <kmc> is Mut a synonym for Cell there? or Cell without the nullability?
[21:29:21] <tikue_> strcat++ for composition
[21:29:26] <kmc> yeah
[21:29:27] <strcat> kmc: not Cell
[21:29:32] <engla> kmc: https://github.com/mozilla/rust/issues/9351
[21:29:35] <strcat> kmc: Cell is really coarse
[21:29:37] <benh> I guess I'd feel better about @mut for the cyclic data use case if it wasn't internally mutable when in an immutable slot
[21:29:48] *** Quits: barosl (barosl@3DE683B6.E551553C.7544CABF.IP) (Quit: ëžœë¤ì€ ì‡ í‡´í–ˆìŠµë‹ˆë‹¤.)
[21:29:50] <strcat> kmc: and you get weird issues where it's null, instead of an error
[21:30:09] <strcat> kmc: but basically, RcMut manually rolls the dynamic borrowck @mut uses
[21:30:15] <strcat> you could split it out into a Mut type
[21:30:27] <strcat> any # of & borrows allows, &mut borrow can't overlap with any other borrows
[21:30:33] <strcat> s/allows/allowed/
[21:30:49] <kmc> luisbg: if you want to copy the string, self.url.clone()
[21:30:53] <engla> not sure about the remove Cell part, Cell is simple enough for the pattern it's used with everywhere.. let cell = Cell:new(obj)  do spawn {  cell.take() ...
[21:30:54] <benh> (I'm still amazed the dynamic borrowcheck doesn't constantly blow up in people's faces)
[21:30:58] <strcat> and likely use RAII instead of rightward closure drift
[21:30:58] <benh> (are we sure it's... turned on?)
[21:31:00] <strcat> benh: it does
[21:31:04] *** Joins: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net)
[21:31:07] <kmc> if you want to return a reference into it, it'll have to be fn prompt_value<'t>(&'t self) -> &'t str
[21:31:10] <strcat> it blows up whenever I do a mass refactor across librustc
[21:31:13] <benh> :D
[21:31:19] <strcat> I hit 2-3 borrowed errors from doing this Option stuff
[21:31:19] <kmc> telling the compiler the returned reference is as valid as long as the argument is
[21:31:41] <acrichto> strcat: does lld compile with llvm as of today?
[21:31:48] <tikue_> strcat: question
[21:31:51] <benh> does anyone else feel like putting <'self> after struct names aaaaall the time is a bit too verbose :(
[21:31:56] <strcat> acrichto: afaik yes but lets not try to do that for 0.8 ;p
[21:32:04] <strcat> we could get compiler-rt working for 0.8, etc.
[21:32:06] <tikue_> strcat: do we have RcMut in libstd right now? cuz i could use that greatly
[21:32:21] <kimundi> benh: Should really become <'a> already :P
[21:32:21] <strcat> tikue_: it's in extra::rc but the interface is not going to stay that way
[21:32:25] <acrichto> strcat: yeah, but I'm wondering if all this mingw missing dll stuff would be better fixed now or closed in favor of using llvm's lld
[21:32:32] <tikue_> strcat: ok, but is it usable as it stands?
[21:32:35] <luisbg> kmc, oooh yeah, I need a copy. forgot :S
[21:32:36] <strcat> acrichto: I opened an issue about it
[21:32:39] <luisbg> kmc, thank you very much :)
[21:32:40] <strcat> and closed the MSVC one
[21:32:40] <tikue_> there's some stuff in servo i'd love to transition away from @mut
[21:32:43] <benh> clearly we need associated lifetimes so they don't need to be in every <>
[21:32:44] <strcat> acrichto: https://github.com/mozilla/rust/issues/9367
[21:32:46] <kimundi> tikue_: You can'tt makie cycles with it
[21:32:50] <engla> strcat: fwiw, Cell refitted with a Mutable<T> core compiles and passes.. of course. Now just to experiment and see what really to do with Cell
[21:32:50] <tikue_> kimundi: don't need cycles
[21:32:53] <acrichto> strcat: yeah, there's a lot of mingw things lying around though (issues)
[21:32:58] <tikue_> kimundi: which is why i want to transition from @mut --> rc mut
[21:33:01] <kimundi> tikue_: Then you should be fine
[21:33:05] <tikue_> kimundi: great thanks
[21:33:09] <kmc> luisbg: no problem :)
[21:33:18] <engla> strcat: as I said, Cell has a simple mission already, it's just its .with_mut_ref methods that are ugly
[21:33:25] <kimundi> rusti: extra::rc:RcMut::new(5u)
[21:33:25] -rusti- <anon>:7:18: 7:19 error: expected one of `; }` but found `:`
[21:33:25] -rusti- <anon>:7          extra::rc:RcMut::new(5u)
[21:33:26] -rusti-                            ^
[21:33:26] -rusti- application terminated with error code 101
[21:33:37] <strcat> acrichto: https://github.com/mozilla/rust/issues/8449 this makes me sad, for example
[21:33:39] <luisbg> kmc, I'm glad the code made sense to you :P
[21:33:39] <benh> rusti: â—
[21:33:40] <kimundi> rusti: ::extra::rc::RcMut::new(5u)
[21:33:41] -rusti- pastebinned 7 lines of output: http://sprunge.us/hiUX
[21:33:41] -rusti- pastebinned 8 lines of output: http://sprunge.us/AHOU
[21:33:48] *** Joins: nejucomo (Adium@moz-A1B9243C.static-ip.telepacific.net)
[21:33:54] <kmc> engla: I talked with pcwalton about getting rid of with_mut_ref
[21:34:06] <pcwalton> I've got WIP patches in servo that do it
[21:34:11] <strcat> kmc: yeah, engla has an RAII-using Mut implementation
[21:34:11] <pcwalton> they aren't quite safe
[21:34:15] <pcwalton> needs a dynamic check
[21:34:18] <kmc> by instead returning a smart pointer with a dtor that drops the dynamic borrow flag
[21:34:21] <kimundi> rusti: ::extra::rc::RcMut::from_freeze(5u)
[21:34:22] -rusti- extra::rc::RcMut<uint>{ptr: (0x7f0e0dc1e060 as *mut ())}
[21:34:27] <engla> kmc: that's what I did too
[21:34:29] <pcwalton> but I think that dynamic check will be cheap and should be constant folded away
[21:35:13] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[21:35:17] *** Quits: qmx (qmx@moz-B6DBCD05.qmx.me) (Ping timeout)
[21:35:20] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[21:35:37] *** Quits: katis (katis@40C8AF65.EFDC2270.EE6E63A5.IP) (Ping timeout)
[21:35:38] *** Quits: SingingBoyo (singingboy@moz-15629474.ubcsecure.wireless.ubc.ca) (Ping timeout)
[21:35:41] <strcat> pcwalton: we'd really need TBAA to eliminate most of them afaik
[21:35:49] <engla> pcwalton: Mutable<T> works fine as a mutable slot for T, and Cell "is"  Mutable<Option<T>>  now.. it's convenient to have Cell remain as it is (or stripped down), as Cell:new(); cell.take() is so common
[21:35:57] <acrichto> strcat: yeah if we could use llvm for linking that would be *awesome*
[21:35:57] <strcat> it thinks the stores to the borrow state could alias anything (or stores to other things could change the borrow state)
[21:36:02] <pcwalton> strcat: no, this is just a check against sizeof<T> versus a known constant address
[21:36:05] <strcat> pcwalton: ah
[21:36:06] <kmc> if we had once fn they would be less common :<
[21:36:07] <pcwalton> constant + constant
[21:36:19] <pcwalton> I would like to eliminate the need for once fn
[21:36:20] <kmc> or the trait-based closures which take self by value
[21:36:35] <strcat> pcwalton: can we just allow moving mutable things into closures?
[21:36:37] <engla> kmc: right, a once-callable trait object
[21:36:41] <kimundi> engla: You can still have a cell.take() with cell: Mut<Option<T>>
[21:36:42] <strcat> that's why Cell has to exist atm
[21:36:50] <pcwalton> strcat: I don't see how that helps
[21:36:53] <pcwalton> the problem is not moving in
[21:36:54] <pcwalton> it's moving out
[21:37:02] <pcwalton> oh, do you mean you want to do option dances?
[21:37:03] <engla> kimundi: well, but is that confusing?
[21:37:18] <pcwalton> option dances, to me, are worse than Cell (I understand that many disagree with me on this)
[21:37:22] <strcat> pcwalton: I just mean 'let mut x = Some(5);' and x.take()
[21:37:25] <pcwalton> yes
[21:37:27] <pcwalton> an option dance
[21:37:36] <pcwalton> but regardless I think we can all agree that option dances and Cell are both terrible
[21:37:38] <engla> how can it be worse? Cell is just an option dance inside a mutable slot
[21:37:41] <strcat> pcwalton: yes
[21:37:57] <strcat> I just think not requiring the dynamic mutability hack is a lot less bad ;p
[21:38:54] *** Joins: qmx (qmx@moz-B6DBCD05.qmx.me)
[21:39:12] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[21:39:19] *** Joins: pudgetta (Mibbit@359B34A6.695DE54A.1951548C.IP)
[21:41:47] *** Joins: aeqwa_ (aeqwa@moz-D8E84D16.dsl.tropolys.de)
[21:42:11] *** Quits: skade (skade@moz-4865967C.pools.arcor-ip.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[21:42:19] <olsonjeffery> are thunks a general solution to the option dance?
[21:42:24] *** Quits: aeqwa (aeqwa@moz-E5EC4149.dsl.tropolys.de) (Ping timeout)
[21:42:30] <olsonjeffery> as far as moving into deeply nested closures is concerned..
[21:43:53] <kimundi> well, they're an solution for replacing owned closures in a way that will make those errors go away :P
[21:44:36] *** flaper87 is now known as flaper87|afk
[21:44:48] *** Joins: Larry (larryfox@26EE99DC.88C61CC9.ECED8BE3.IP)
[21:44:58] *** Quits: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com) (Quit: Jesse)
[21:45:18] *** Quits: sp3d (a@6361F3B1.19CD1E54.8354FB35.IP) (Ping timeout)
[21:45:42] <engla> yes olsonjeffery if     do create_thunk(value) |upvar, xyz| {   // use upvar }    creates a trait object with   fn call(~self, xyz: Arg) -> Ret    then you can only call it once, and the closure will be able to move out of or mutate its upvar
[21:46:06] <engla> or something like that
[21:46:48] *** Quits: tikue_ (tkuehn@E004E0C5.B9B3942C.689607DE.IP) (Quit: tikue_)
[21:47:06] *** Quits: Larry (larryfox@26EE99DC.88C61CC9.ECED8BE3.IP) (Quit: Textual IRC Client: www.textualapp.com)
[21:47:15] <strcat> need more input on https://github.com/mozilla/rust/issues/9355
[21:47:20] <strcat> maybe I'll post it to the mailing list
[21:48:17] *** Quits: qmx (qmx@moz-B6DBCD05.qmx.me) (Ping timeout)
[21:49:05] *** Joins: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com)
[21:49:30] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[21:49:39] *** Quits: Amanieu (amanieu@10FEE2FD.ECEF57A4.2CFD4520.IP) (Client exited)
[21:49:49] *** Joins: Amanieu (amanieu@10FEE2FD.ECEF57A4.2CFD4520.IP)
[21:49:51] <benh> as_mut() is &mut Option<T> -> Option<&mut T>?
[21:50:45] *** Joins: tikue_ (tkuehn@E004E0C5.B9B3942C.689607DE.IP)
[21:50:49] <strcat> benh: yes
[21:51:42] <strcat> benh: https://github.com/thestinger/rust/blob/f2ce42334d4081977aca4249cfb52fe4a0e98b70/src/libstd/option.rs
[21:52:12] <luisbg> Rust uses the / character for escape characters, correct?
[21:52:18] <strcat> although almost every usage of the old by-ref ones was easily replaced by by-value without as_mut/as_imm
[21:52:23] *** Joins: joshua_ (joshua@moz-45967CBE.emarhavil.com)
[21:52:23] *** Quits: joshua_ (joshua@moz-45967CBE.emarhavil.com) (Quit: joshua_)
[21:52:25] *** Joins: joshua_ (joshua@moz-45967CBE.emarhavil.com)
[21:52:25] *** Joins: qmx (qmx@moz-B6DBCD05.qmx.me)
[21:52:33] <strcat> luisbg: \
[21:52:55] <luisbg> strcat, I am trying to get a URL from stdin()::read_line()
[21:53:03] <luisbg> but it truncates the second / from the URL
[21:53:14] <benh> huh
[21:53:18] <benh> that shouldn't really be an issue
[21:53:24] <luisbg> so if I type http://www.mozilla.com, it gets http:/www.mozilla.com
[21:54:01] <Eridius> luisbg: user input isn't subject to the compiler's idea of a string escape anyway
[21:54:36] *** Quits: Palmik (palmik@moz-11EA685D.pks.muni.cz) (Quit: Lost terminal)
[21:54:42] <tikue_> how do you instantiate RcMut<Foo> ? RcMut::new is private (and unsafe)
[21:55:03] <tikue_> oh, from_send and from_freeze?
[21:55:07] <engla> yes
[21:55:21] <tikue_> engla: when do you use which? O.o
[21:55:27] <engla> whichever fits
[21:55:43] <tikue_> engla: what if both fit
[21:55:48] <strcat> either
[21:55:56] <strcat> it's only done that way to make you not accidentally make a cycle
[21:55:59] <tikue_> ah
[21:56:02] <strcat> you have to opt-in to having cycles
[21:56:02] <tikue_> what is Freeze again?
[21:56:10] <strcat> inherited mutability or immutable
[21:56:13] <strcat> i.e. respects the mutability rules
[21:56:23] <tikue_> ah thanks
[21:56:28] <engla> Freeze is everything that doesn't do the mutability hacks just discussed
[21:56:33] <tikue_> ok
[21:57:08] <strcat> it's not technically 'unsafe' but I don't have another way to mark it as being bad
[21:57:27] <engla> it could be non-pub
[21:57:29] <tikue_> meh, i'm still confused
[21:57:36] <tikue_> i just want to have multiple mutable references at once
[21:57:37] <tikue_> i don't need cycles
[21:57:44] <tikue_> so do i use from_freeze or from_send :\
[21:57:47] <strcat> tikue_: so use from_send/from_freeze
[21:57:50] <strcat> yes
[21:57:52] <tikue_> lol
[21:57:52] <engla> tikue_: it doesn't matter which
[21:57:52] <tikue_> ok
[21:57:56] <tikue_> gah, alright :)
[21:57:57] <tikue_> thanks guys
[21:58:02] <GregorR> <kimundi> GregorR: Anyway, your input is valuable, at this point it's just too early I think to really know what would be the best course of action for handling such an situation.  // Absolutely. I'm just trying to make sure that somebody is raising the banner of code (d)evolution so that it's thought about. If it's only thought about after multiple implementations (whether of rust itself or of other APIs provided to rust) exist, then it's already too late 
[21:58:02] <GregorR> :)
[21:58:12] <strcat> you're guaranteed to never have a memory leak from a cycle if you don't use the constructor marked unsafe (despite that not being what 'unsafe' means)
[21:58:16] *** Joins: heftig (heftig@moz-13C434C4.dip0.t-ipconnect.de)
[21:58:21] <tikue_> strcat: heh, fair enough, thanks
[21:59:03] *** Quits: gandalf (zbraniecki@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: I feel so disconnected now	)
[21:59:05] <strcat> tikue_: unlike @/@mut, they have move semantics, so you know exactly where you're doing refcounts to split ownership
[21:59:08] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[21:59:12] <strcat> fairly easy to keep track of where it will actually be freed
[22:00:07] <strcat> Rc's overhead is a uint in the allocation, + refcounts where you choose to clone
[22:00:21] <strcat> RcMut has the dynamic borrowck overhead too, though, it's not really cheap like Rc
[22:00:43] <tikue_> strcat: yeah, but it's still better than @mut right?
[22:00:53] <strcat> tikue_: well, it's faster ;p
[22:01:02] <strcat> it has the same dynamic failure cases
[22:01:06] <tikue_> strcat: the only reason i need RcMut is because i want to use an iterator with a tree structure
[22:01:24] <tikue_> never to actually mutate other nodes other than the current one being yielded
[22:01:28] <strcat> tikue_: hm, why does that necessitate RcMut?
[22:01:30] <tikue_> just because the iterator interface is nice
[22:02:00] <strcat> you could yield & refs to all but the field holding the children
[22:02:02] <tikue_> strcat: because the iterator's stack stores the next node to be yielded, but the current yielded node has a reference to the children
[22:02:40] *** Quits: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Ping timeout)
[22:02:46] <strcat> tikue_: you can use let to pattern match out by-mut-ref, and return all but the children ptr (which you store to traverse further)
[22:02:46] <tikue_> strcat: the node needs to reference children, just not mutate them
[22:03:00] <strcat> tikue_: ah
[22:03:12] <strcat> makes sense
[22:03:13] <tikue_> unfortunately i think you just have to obey the contract in this case
[22:03:21] <tikue_> rather than getting a compilation guarantee
[22:05:39] *** Joins: maik (maik@moz-A79D08D1.dip0.t-ipconnect.de)
[22:06:12] <tikue_> strcat: can you use methods with RcMut the same way you can with @mut
[22:06:21] <tikue_> strcat: e.g. iter(RcMut<self>)
[22:06:34] <strcat> no
[22:06:42] <strcat> with Rc, you will be able to
[22:06:49] <tikue_> strcat: how?
[22:06:54] <tikue_> oh wait
[22:06:56] <tikue_> you mean not yet, but soon?
[22:07:06] <strcat> Rc is going to use a Pointer trait to overload * and &*
[22:07:10] <tikue_> awesome
[22:07:43] <strcat> RcMut will likely go away.... you could overload Pointer for a Mut type's pointer wrapper too
[22:07:51] <strcat> it's a bit too confusing to mix the two concepts imo
[22:08:05] *** Quits: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP) (Quit: nn)
[22:08:32] *** Joins: vodik (simon@moz-CBE4BB13.cable.teksavvy.com)
[22:08:44] <strcat> let x = mut_slot.get(); *x /* destructor of `x` removes the borrow state "lock" */
[22:09:00] <strcat> so Rc<Mut<T>> would be...
[22:09:03] *** Joins: sp3d (a@6361F3B1.19CD1E54.8354FB35.IP)
[22:09:31] <strcat> let x = some_rc_box.get(); *x
[22:09:37] <strcat> because auto-deref would work
[22:10:00] <strcat> with just Rc (not Mut), you'd just do 'let foo = Rc::from_send(5); let y = &*foo;'
[22:10:40] <tikue_> is there a way to do ```impl RcMut<Foo> { }```
[22:10:43] <engla> here's a WIP for that strcat   https://github.com/blake2-ppc/rust/commit/da2ca46a89f02ec47b9cfcb3f74afe7cce5b4036
[22:10:53] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[22:11:25] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Quit: ChatZilla 0.9.90.1 [Firefox 25.0/20130917123208])
[22:12:34] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[22:14:08] <Eridius> tikue_: no. you can define a trait and impl it for RcMut<Foo> though
[22:14:19] <tikue_> Eridius: good idea, thank you
[22:15:11] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[22:15:45] <tikue_> yep that works well. thanks!
[22:16:31] *** Quits: Azdle (Azdle@moz-B334B496.hfc.comcastbusiness.net) (Ping timeout)
[22:16:33] *** Quits: tgummerer (tgummerer@51D3B54.FEF996EA.EA6FEF3D.IP) (Ping timeout)
[22:17:13] *** Quits: maik (maik@moz-A79D08D1.dip0.t-ipconnect.de) (Ping timeout)
[22:18:42] <engla> heh, converting code from using Cell and with_mut_ref reduces the number of closures needed and thus further reduces the Cell::take needed hehe
[22:19:53] *** Joins: SingingBoyo (singingboy@moz-15629474.ubcsecure.wireless.ubc.ca)
[22:21:03] *** Joins: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl)
[22:21:16] *** Joins: maik (maik@moz-A79D08D1.dip0.t-ipconnect.de)
[22:21:39] <tikue_> the iterator equivalent of vec.contains() is iter().any(|el| el == foo) right
[22:22:05] <strcat> tikue_: yes, for now
[22:22:15] <strcat> it could have 'contains' but it's painful with containers
[22:22:29] <strcat> since you're probably really going to write '*el == foo' there
[22:22:35] <tikue_> right
[22:23:01] <strcat> max/min/sum/product are not incredibly useful for the same reason and should *perhaps* be dropped
[22:23:09] *** Quits: SingingBoyo (singingboy@moz-15629474.ubcsecure.wireless.ubc.ca) (Ping timeout)
[22:23:21] <luisbg> anybody attending the Mozilla Hackathon in Montreal tomorrow?
[22:23:24] <strcat> max_by/min_by/fold aren't much more work and you can deref, without cloning
[22:23:35] <kimundi> Is there a way to have an deref adapter that doesn't actually try to move/implicit copy out of it?
[22:24:17] <cmr> strcat: max/min/sum/product are super useful for short, pretty project euler solutions :p
[22:25:15] <pcwalton> looks like newtype struct constructors aren't being inlined? :(
[22:26:01] *** Joins: Azdle (Azdle@moz-B334B496.hfc.comcastbusiness.net)
[22:27:29] <kimundi> Hm, I'm wondering if move_iter() should be called into_iter()... Technically it's a by-value self conversion
[22:27:42] *** Joins: bheylin_ (brianheyli@moz-8255E94E.adsl.online.nl)
[22:28:13] *** Quits: tikue_ (tkuehn@E004E0C5.B9B3942C.689607DE.IP) (Quit: tikue_)
[22:28:55] *** Quits: io2 (io2@moz-A6202C16.home.otenet.gr) (Quit: )
[22:30:08] <Eridius> kimundi: cute, but it doesn't actually convert the receiver into an iterator, it wraps it in an iterator that then moves elements out. Granted, this is largely an implementation detail
[22:30:16] <Eridius> but just thinking of saying `v.into_iter()` feels.. weird
[22:30:44] <kimundi> yeah, that's what happening
[22:31:07] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[22:31:07] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/AdasPQ
[22:31:07] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[22:31:12] <kimundi> your moving the vector into an iterator object that yields the elements of the vector
[22:31:40] <engla> it's a bit weird because move_iter() is the method that provides an iterator with elements by value, but for primitive types, .iter().map(|&x| x) is a much better way to do that
[22:31:41] *** Joins: tikue_ (tkuehn@E004E0C5.B9B3942C.689607DE.IP)
[22:31:51] <engla> the latter must be incredibly common
[22:32:28] <kimundi> we should have a fn clone<T: Clone>(); in the prelude, so that that can become iter().map(clone)
[22:32:46] <kmc> heh
[22:32:58] <kmc> I like that
[22:33:20] <Eridius> engla: .iter().map(|&x| x) is common enough that I periodically argue we should have a method for it, i.e. .clone_iter()
[22:33:21] <kimundi> also we can rename clone to copy
[22:33:29] <Eridius> although kimundi's suggestion would be fine as well
[22:33:36] <engla> shouldn't it be .deref_iter() ?
[22:33:36] <kimundi> iter.map(copy)
[22:33:43] <strcat> engla: can't write that
[22:33:46] <Eridius> engla: .clone_iter() is more generic
[22:33:46] *** Quits: pudgetta (Mibbit@359B34A6.695DE54A.1951548C.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[22:34:17] <engla> strcat: the impl will be clone, of course, but still.. that's confusing. cloning &T gives &T.
[22:34:29] <kimundi> engla: deref only works witn implicit copyable types... because it doesn't actually deref, it copies out :P We no longer have the kind that allows you to be generic over those types
[22:34:36] <engla> kimundi: yes I know
[22:34:48] <strcat> kimundi: we never did ;p, Copy included ~[]
[22:34:53] <kimundi> engla: But clone is written with &self
[22:34:58] *** Quits: huhlig-home (huhlig@moz-C8339267.hfc.comcastbusiness.net) (Ping timeout)
[22:35:03] <kimundi> so it goes &T -> T
[22:35:22] *** Joins: hoverbear (andrew@moz-86FCBF4B.gv.shawcable.net)
[22:35:24] <engla> too complicated for me :|
[22:35:39] <kimundi> strcat: Hu, really? Well anyway good that it's gone now :P
[22:36:04] <strcat> kimundi: (for ~[T] where T was Copy, to clarify, and for ~str)
[22:36:06] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[22:36:06] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/6CepXg
[22:36:06] <ghrust> 13rust/06auto 149e3258e 15Daniel Micay: restore auto-detection of text files...
[22:36:06] <ghrust> 13rust/06auto 14de8a2d5 15bors: auto merge of #9344 : thestinger/rust/auto, r=pnkfelix...
[22:36:07] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[22:36:13] <kimundi> rusti: (5u.clone(), (&5u).clone(), (& &5u).clone)
[22:36:14] -rusti- <anon>:7:37: 7:50 error: attempted to take value of method `clone` on type `&&uint` (try writing an anonymous function)
[22:36:14] -rusti- <anon>:7          (5u.clone(), (&5u).clone(), (& &5u).clone)
[22:36:14] -rusti-                                               ^~~~~~~~~~~~~
[22:36:14] -rusti- error: aborting due to previous error
[22:36:14] -rusti- application terminated with error code 101
[22:36:17] <kimundi> rusti: (5u.clone(), (&5u).clone(), (& &5u).clone())
[22:36:17] -rusti- pastebinned 15 lines of output: http://sprunge.us/TYRB
[22:36:39] <strcat> clone of &'a T gives &'a T
[22:36:53] <strcat> and likewise for slices
[22:37:00] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[22:37:09] <kimundi> rusti: let (a,b,c) = (5u, &5u, & &5u); (a.clone(), b.clone(), c.clone())
[22:37:10] -rusti- pastebinned 16 lines of output: http://sprunge.us/MXcb
[22:37:36] <kimundi> ... ah right
[22:37:49] <kimundi> rusti: let (a,b,c) = (5u, &5u, & &5u); printfln!((a.clone(), b.clone(), c.clone()));
[22:37:52] -rusti- (5u, 5u, &5u)
[22:37:54] -rusti- ()
[22:37:58] <kimundi> engla: ^
[22:38:25] <kimundi> T gets auto borrowed to &T, &T gets used as is, & &T gets used as is.
[22:38:56] <kimundi> Not all that confusing really.
[22:39:07] <cmr> olsonjeffery: Still planning on the thing?
[22:40:30] * kimundi wonders how hard it would be to rename Clone to Copy
[22:40:40] <cmr> I imagine it'd just be a huge sed
[22:41:03] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[22:41:03] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14de8a2d5 to 14a95604f: 02http://git.io/N3iJvQ
[22:41:03] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[22:41:04] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[22:41:04] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/ikRWbQ
[22:41:04] <ghrust> 13rust/06auto 14e2e1061 15Brian Anderson: Fix spelling and phrasing in 0.8 release notes
[22:41:04] <ghrust> 13rust/06auto 145a0f7aa 15Brian Anderson: Add a note about improved rustc perf to 0.8 relnotes
[22:41:04] <ghrust> 13rust/06auto 14032cbfe 15bors: auto merge of #9349 : brson/rust/relnotes, r=thestinger
[22:41:06] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[22:41:15] <strcat> huh
[22:41:49] <strcat> um
[22:42:06] <strcat> bors is testing 2 things
[22:42:09] <dbaupp> https://github.com/mozilla/rust/pull/9362 r?
[22:42:11] *** Quits: vodik (simon@moz-CBE4BB13.cable.teksavvy.com) (Ping timeout)
[22:42:12] <strcat> http://buildbot.rust-lang.org/console?branch=auto&refresh=15
[22:42:22] <cmr> Uh
[22:42:25] <cmr> That's not good :|
[22:42:33] <acrichto> dbaupp: looking
[22:43:44] <strcat> brson: can you turn off bors? it did the thing where it runs 2 builds in parallel
[22:44:08] <acrichto> could one just get cancelled?
[22:44:11] <benh> wooo, parallelisation
[22:44:19] <strcat> acrichto: then it'll start another afaik
[22:44:27] <dbaupp> it's doing 0 according to http://buildbot.rust-lang.org/bors/bors.html
[22:44:34] <dbaupp> (which is presumably the problem?)
[22:44:42] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[22:44:48] <pcwalton> can we make deriving please inline
[22:44:53] <pcwalton> I can't use deriving(Eq) in Servo
[22:44:57] <pcwalton> because it doesn't inline and kills perf
[22:45:03] <dbaupp> I'd be happy with that
[22:45:05] <strcat> yikes, it doesn't inline those?
[22:45:16] <strcat> hm
[22:45:19] <pcwalton> strcat: it doesn't
[22:45:26] <dbaupp> strcat: I do believe you said we should't put #[inline] on the derived methods?
[22:45:36] <brson> strcat: what is the problem and why would turning off bors help?
[22:45:54] <strcat> brson: it's glitched in some weird way where it thinks nothing is pending, and started 2 builds
[22:45:58] <strcat> I think it's going to start more
[22:46:16] <strcat> brson: http://buildbot.rust-lang.org/console?branch=auto&refresh=15
[22:46:17] <acrichto> pcwalton: I'm not sure you'd want inline by default, but something like deriving(Eq, opts="inlined") or something like that
[22:46:25] <pcwalton> for Eq you almost always do
[22:46:28] <strcat> brson: this used to happen often, but hasn't for a long time
[22:46:30] <pcwalton> but sure
[22:46:34] <pcwalton> if you want to add another option that's fine
[22:46:38] <pcwalton> I just want all the perf footguns out
[22:47:04] <acrichto> yeah it should definitely be possible
[22:47:06] <strcat> brson: just seems that if we turn it off + cancel these and turn it on, it'll probably be fixed
[22:47:48] <strcat> ah wait it decided 1 is pending now
[22:48:00] * strcat tries just cancelling the 1st
[22:48:21] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[22:49:05] <hoverbear> Hey all, I was wondering if anyone had some literature or code samples I could toy with regarding how rust handles race conditions and threading differently then C? 
[22:49:07] <brson> bors is just a batch job. it doesn't have any state at all
[22:49:26] <cmr> hoverbear: http://winningraceconditions.blogspot.com/
[22:49:36] <brson> i actually don't see how bors is being run though ...
[22:49:44] <strcat> brson: cron?
[22:49:53] <brson> supposedly, but it's not in the crontab
[22:49:55] <hoverbear> cmr: Thank you sir.
[22:49:57] <strcat> brson: it seems okay now anyway
[22:50:02] <Eridius> hoverbear: what race conditions?
[22:50:03] <Eridius> ;)
[22:50:13] <strcat> brson: unless it decides to force push again...
[22:50:20] <Eridius> oh ok I suppose data races are not the entire set of race conditions
[22:50:24] <strcat> brson: maybe a buildbot problem and not bors
[22:50:36] <hoverbear> Eridius: Cool. We're studying threading in my OS class and I gotta say, the C solutions are a step behind even Javascript.
[22:50:48] <Eridius> hoverbear: javascript is single-threaded
[22:51:01] <hoverbear> Eridius: I mean the inherent grossness of the language.
[22:51:17] <strcat> brson: um.... actually
[22:51:20] <brson> strcat: it seems like there's a per-user crontab?
[22:51:22] <strcat> github disappeared a pull request or two
[22:51:25] <strcat> brson: yeah, there is
[22:51:28] <strcat> brson: crontab -e
[22:51:38] <strcat> brson: don't worry about it though, narrowed it down to a weird github issue
[22:51:45] <strcat> their site UI is incorrect too
[22:52:14] <brson> where is the user crontab stored?
[22:52:32] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[22:52:36] <hoverbear> Eridius: It's also totally possible to be running asynchronous function calls that operate on a state variable and have something get messed up that way, which is sort of similar.
[22:52:44] <strcat> brson: /var/spool/cron/user, I think
[22:52:50] <strcat> but crontab -e will just open it
[22:54:49] <cmr> hoverbear: well, you can't get much worse than "{} + [] === 0"
[22:55:00] <hoverbear> cmr: Yup.
[22:55:23] <Eridius> if you haven't watched 'wat', it's hilarious
[22:55:36] *** Quits: Skif (emschwar@moz-CA025D57.ip.mcleodusa.net) (Client exited)
[22:55:37] <hoverbear> cmr: I always liked how the typeof operator in JS pretty much just always returns 'Object' (Note how this is a string)
[22:55:38] <strcat> cmr: you can
[22:55:42] <Eridius> https://www.destroyallsoftware.com/talks/wat
[22:56:09] <strcat> js> a = []; a[[2] + [2]] = "foo"; a[22]
[22:56:12] <strcat> "foo"
[22:56:19] <cmr> hah
[22:56:31] <cmr> JS has some really ugly corners.
[22:56:34] <strcat> arrays really index by strings, and the JIT has to *figure out* when you're actually using them as arrays
[22:56:34] <hoverbear> Yeah. ugh.
[22:56:43] <hoverbear> cmr: ES5 isn't quite as bad thankfully.
[22:56:46] <cmr> It all makes sense if you've read the spec.
[22:56:50] <cmr> hoverbear: It's just as bad.
[22:56:55] <Eridius> strcat: that actually sounds vaguely similar to Lua tables. Have you ever looked at how they do array-like behavior?
[22:57:08] <strcat> Eridius: well, Lua tables don't coerce to strings afaik
[22:57:16] <strcat> js objects only have string keys
[22:57:18] <cmr> hoverbear: They just add features that make it less worse overall.
[22:57:23] <hoverbear> cmr: Yeah.
[22:57:25] <strcat> a[2] = 5, a["2"] = 5
[22:57:27] <strcat> those are the same
[22:57:28] <kmc> it's not like JavaScript has integers, either ;)
[22:57:31] <hoverbear> Ok.
[22:57:36] <strcat> [2] + [2] coerces both arrays to strings, first
[22:57:36] <Eridius> yeah, JS coerces. lua tables actually accept any type as a key (except nil, I guess)
[22:57:44] <Eridius> but the way that lua tables handle array-like vs map-like is cute
[22:57:46] <strcat> kmc: but it does have 32-bit int operators ;p
[22:57:51] <hoverbear> I'm considering handing in a .rs file along with my .c networking assignment. Hmm...
[22:58:13] <strcat> kmc: and didn't they add integer multiplication in ES6? I seem to recall that...
[22:58:18] <kmc> hoverbear: the language will have changed by the time the prof gets around to grading it ;)
[22:58:25] <strcat> https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul yep
[22:58:28] <kmc> strcat: yeah
[22:58:45] <hoverbear> kmc: LOL. I'm using the git pull.
[22:58:48] *** Quits: nejucomo (Adium@moz-A1B9243C.static-ip.telepacific.net) (Quit: Leaving.)
[22:59:03] <cmr> hoverbear: just say it's 0.8, it'll be close enough :p
[22:59:10] <strcat> kmc: LLVM doesn't have signed/unsigned integers - just integers :)
[22:59:14] <hoverbear> cmr: Yup.
[22:59:20] <Eridius> hoverbear: or just say what hash you built from
[22:59:21] <hoverbear> strcat: Thank goodness.
[22:59:23] <strcat> kmc: the operators are always equivalent with two's complement signed ints
[22:59:31] <Eridius> give the first line of `rustc --version`
[22:59:32] <hoverbear> I need to find ze udp socket docks.
[22:59:41] <cmr> std::rt::io::net::udp
[22:59:48] <strcat> although, they do have nsw (no-signed-wrap) and nuw (no-unsigned-wrap) to make either undefined behaviour
[23:00:02] <kmc> *nod*, you might want that compiling from C
[23:00:09] <strcat> kmc: yeah, C uses nsw
[23:00:13] <cmr> hoverbear: http://www.contrib.andrew.cmu.edu/~acrichto/doc/std/rt/io/net/udp/index.html
[23:00:15] <kmc> New South Wales
[23:00:18] <strcat> kmc: :)
[23:00:23] <kmc> I wonder if that actually exposes much backend optimization -- anyone have a cool example?
[23:00:44] <strcat> kmc: it tells them a loop with a signed int increment is never infinite
[23:00:49] <hoverbear> cmr: Thanks. I'll try to get a hello world working. :)
[23:00:56] <strcat> kmc: it exists for pointers too - GEP vs inbounds GEP
[23:01:02] <strcat> GEP is allowed to wrap, or index outside an object
[23:01:23] <strcat> switching rust's raw pointers to using inbounds GEP made LLVM able to vectorize our loops, delete our loops, unroll them, and so on
[23:01:31] <kmc> yeah that's cool
[23:01:35] *** Quits: sebcrozet (sebcrozet@moz-F96421F3.w80-13.abo.wanadoo.fr) (Ping timeout)
[23:02:01] <strcat> although for raw pointers, if you actually do accidentally index outside the object it's going to be undefined on deref anyway
[23:02:16] <strcat> so there's close to zero use case for non-inbounds GEP (C pointer arithmetic always turns to 'inbounds')
[23:02:26] <leonvv> Does anyone know where "SocketAddr" is located?
[23:02:48] <Luqman> leonvv: std::rt::io::net::ip
[23:03:05] <cmr> leonvv: http://www.contrib.andrew.cmu.edu/~acrichto/doc/std/ has a search
[23:03:19] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[23:03:49] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[23:03:49] <leonvv> Luqman: I'm getting this error: "error: unresolved import: there is no `SocketAddr` in `std::rt::io::net::ip`"
[23:03:55] <strcat> github totally ate my pull request
[23:03:55] <leonvv> cmr: Thanks will give it a try
[23:03:58] <strcat> :|
[23:04:02] <strcat> it's gone...
[23:04:16] <strcat> oh wait no
[23:04:16] <cmr> leonvv: What versino of rust are you using?
[23:04:18] <strcat> bors closed it :|
[23:04:27] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[23:04:27] <strcat> brson: https://github.com/mozilla/rust/pull/9344 here's the bors bug in action
[23:04:34] <strcat> brson: I wonder why it closed it :s
[23:04:46] <strcat> it wasn't done testing, so it wasn't trying to merge to master
[23:05:02] <strcat> also github won't let me reopen it
[23:05:02] <leonvv> cmr: 0.7, I built it a couple of hours ago
[23:05:17] <dbaupp> strcat: is the branch deleted in your repo?
[23:05:20] <strcat> aha!
[23:05:24] <strcat> it's because it's called 'auto'
[23:05:27] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[23:05:29] <strcat> it's a github bug
[23:05:37] <cmr> leonvv: 0.7 is too old. you'd want to be looking in extra::net
[23:05:54] <strcat> it considers a merge from 'branch_foo' to 'branch_foo' to be a "merge", even if it was targeted at master
[23:05:55] <Luqman> leonvv: ah, the net stack was overhauled since 0.7. and 0.8 will be released soon
[23:06:09] *** Quits: BossKonaSegway (Michael@moz-2986F42D.col.wideopenwest.com) (Connection reset by peer)
[23:06:26] *** Quits: Azdle (Azdle@moz-B334B496.hfc.comcastbusiness.net) (Quit: Leaving)
[23:07:26] <leonvv> cmr, Luqman: So all the documentation is about 0.8 ?
[23:07:37] *** Joins: BossKonaSegway (Michael@moz-2986F42D.col.wideopenwest.com)
[23:07:49] <cmr> leonvv: the docs I linked to, yes.
[23:07:55] *** jorendorff is now known as jorendorff_away
[23:08:14] <leonvv> cmr: I used the tarr file instead of the Github repo, does that make a difference?
[23:08:23] <cmr> leonvv: no
[23:08:44] <leonvv> cmr: So how would I get the 0.8 version ?
[23:08:49] <cmr> leonvv: clone from github
[23:09:17] <cmr> Eugh
[23:09:33] <cmr> pcwalton: Can you give me a pointer on where I'd look if I want child modules to be able to use parents' private modules?
[23:09:39] <cmr> I'm sick of ugly workarounds for tests :\
[23:09:39] <leonvv> cmr: But you just said that doesn't make a difference with the tarr file, and I downloaded that a couple of hours ago
[23:09:45] <Luqman> leonvv: https://github.com/mozilla/rust/archive/master.zip works
[23:09:55] <cmr> leonvv: Right. The tar file is 0.7. The git clone is master.
[23:11:05] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[23:11:05] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14032cbfe to 14a95604f: 02http://git.io/N3iJvQ
[23:11:05] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[23:11:07] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[23:11:07] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/IQCaEw
[23:11:07] <ghrust> 13rust/06auto 149e3258e 15Daniel Micay: restore auto-detection of text files...
[23:11:07] <ghrust> 13rust/06auto 14c29e76b 15bors: auto merge of #9371 : thestinger/rust/text, r=pnkfelix...
[23:11:07] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[23:11:26] <leonvv> Luqman, cmr: Thanks for your help
[23:12:56] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[23:13:29] *** Joins: SingingBoyo (singingboy@moz-15629474.ubcsecure.wireless.ubc.ca)
[23:13:55] *** Quits: jpf (jan@moz-A8C26A15.org) (Ping timeout)
[23:14:10] <pcwalton> cmr: remove privacy from resolve.rs and then add it to privacy.rs
[23:14:15] *** Joins: jpf (jan@moz-A8C26A15.org)
[23:14:18] <pcwalton> privacy.rs has more information
[23:14:40] *** Joins: nejucomo (Adium@moz-434492BB.dsl.static.sonic.net)
[23:14:54] <cmr> pcwalton: Ok.
[23:18:39] <cmr> pcwalton: Does this require any deep thought or knowledge about resolve, or mostly brute force?
[23:18:52] <pcwalton> not really, it's mostly a pure removal from resolve :)
[23:18:58] <pcwalton> just search for where it checks Public or Private
[23:19:01] <pcwalton> and rip it out
[23:19:10] <cmr> Alrighty, I can do that
[23:19:43] *** Joins: ofeldt- (ofeldt@moz-2414816B.dip0.t-ipconnect.de)
[23:20:23] *** Quits: ofeldt (ofeldt@moz-95AE0D55.dip0.t-ipconnect.de) (Ping timeout)
[23:20:45] <kimundi> Anyone know if Clone is used anywhere else in a special way beside deriving?
[23:20:55] <strcat> don't think so
[23:21:05] <pcwalton> it's not
[23:21:06] <strcat> the language doesn't know about it, beyond the syntax ext
[23:21:36] <kimundi> Thinking about making a PR that adds Copy trait and deriving mode, so that after a snapshot we can rename clone -> copy
[23:22:02] <kimundi> Is that still desirable?
[23:22:17] <strcat> wouldn't need a snapshot
[23:22:22] *** Quits: bheylin_ (brianheyli@moz-8255E94E.adsl.online.nl) (Quit: bheylin_)
[23:22:24] <strcat> afaik
[23:22:32] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[23:22:43] <dbaupp> strcat: deriving means that it would
[23:22:49] <kimundi> right
[23:23:02] <dbaupp> kimundi: you can just add a #[deriving(Copy)] that doesn't work
[23:23:18] <dbaupp> and then snap and then rename; no need for an actual Copy trait
[23:23:22] <kimundi> dbaupp: I can do even better and add one that does work :P
[23:23:36] <dbaupp> kimundi: yeah, but that's more duplication
[23:24:13] *** Quits: maik (maik@moz-A79D08D1.dip0.t-ipconnect.de) (Ping timeout)
[23:24:16] <kmc> why do we care enough about the name Copy vs Clone to disrupt all existing code?
[23:24:37] <kimundi> kmc: shorter name :P
[23:24:41] <kmc> they both seem like fine names to me
[23:24:46] *** Quits: tjc (tjc@moz-61292EE3.static.cruzio.com) (Quit: Places to go, people to annoy)
[23:24:54] <kmc> ;P
[23:25:30] <dbaupp> kmc: because we haven't had enough breaking changes recently; you know how it is... quotas to fulfill, etc etc.
[23:25:33] <dbaupp> :P
[23:25:40] <kmc> I like "clone" better, anyway, but I don't know why or feel strongly about it at all
[23:26:24] <strcat> dbaupp: yeah, that's why I'm going to break option, result, etc. next
[23:26:34] <kmc> perhaps it's because "copy" sounds like a low level operation on memory, while "clone" is a more abstract operation on objects
[23:26:48] <kmc> at this point I'm just coming up with BS reasons to prefer "clone" so that I don't have to change all of Servo's clones again
[23:26:58] <kimundi> dbaupp: Hm, how would I add a Noop deriving mode? copying an renaming the existing one was easy enough :P
[23:27:01] <strcat> Clone might be doing something like re-opening a file descriptor
[23:27:25] * strcat doesn't really care what it's called
[23:27:45] <kmc> strcat: do we have an opinion on whether Clone implementations should or shouldn't do that? imo it's up to the author of the file type what exact semantics they want
[23:27:52] <kimundi> Our semantic of clone is closer to a lowlever operation anyway
[23:27:57] <kimundi> level*
[23:28:08] <strcat> kmc: well, that's a sane thing for them to do
[23:28:10] <kmc> (recall that you can get two file descriptors pointing to the same file description, as well!)
[23:28:11] <kimundi> I mean we have DeepClone for an actually deep copy
[23:28:30] <strcat> kmc: yeah but that seems less sane, since destroying one will break the other
[23:28:30] <benh> kmc: i was going to suggest to call .clone() .dup() :)
[23:28:37] <strcat> I don't think you'd want it to dup
[23:28:48] <kimundi> .+1()
[23:28:53] *** Quits: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl) (Client exited)
[23:29:01] <kimundi> :P
[23:29:17] <dbaupp> kimundi: just copy Clone and s/clone/copy/?
[23:29:23] <strcat> POSIX almost deprecated dup/dup2
[23:29:30] <benh> huh
[23:29:31] <strcat> wouldn't not be surprised if they did it in the next iteration
[23:29:56] <strcat> (even widely used functions like gettimeofday are deprecated now ;p)
[23:30:13] <kimundi> dbaupp: that what I did right now. Added a new std::copy and syntax::...::expand::copy module and source file, and integrated them in the code next to the clone variant
[23:30:23] <dbaupp> kimundi: sounds good
[23:30:25] *** Quits: echristo (echristo@DCF57675.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[23:30:27] <kmc> strcat: what's the replacement?
[23:30:29] <kimundi> I don't think those two copies of the same copy will diverge much
[23:30:33] <cmr> kmc: clock_gettime
[23:30:35] <kimundi> same code*
[23:30:37] <kmc> for dup I mean
[23:30:39] <cmr> oh
[23:30:56] <strcat> kmc: fcntl, directly - dup/dup2 aren't officially deprecated yet though
[23:31:07] <kmc> oh I forgot about F_DUPFD
[23:31:12] <benh> i didn't know about it
[23:31:24] <kmc> Linux also has dup3()... because Linux has a version of *every single system call* with an extra arg just to let you pass O_CLOEXEC
[23:31:39] <benh> How do you replace dup2 though?
[23:32:35] <pcwalton> nmatsakis: why does rustc always insert calls to debug_borrow?
[23:32:40] <pcwalton> this is driving me nuts :)
[23:32:43] <pcwalton> I used -Z no-debug-borrows...
[23:32:52] *** Quits: dbaupp (Thunderbir@moz-EAA09AEF.lns20.syd7.internode.on.net) (Ping timeout)
[23:34:19] *** Quits: aeqwa_ (aeqwa@moz-D8E84D16.dsl.tropolys.de) (Quit: Lost terminal)
[23:35:28] *** Joins: quibbit (Mibbit@359B34A6.695DE54A.1951548C.IP)
[23:35:51] *** Joins: katis (katis@40C8AF65.EFDC2270.EE6E63A5.IP)
[23:35:59] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Quit: Lost terminal)
[23:36:26] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[23:36:26] *** ChanServ sets mode: +ao brson brson
[23:37:36] <pcwalton> oh I see, libstd is set up to always insert those checks!
[23:37:38] <pcwalton> yikes, this is bad
[23:37:54] <pcwalton> massive code bloat
[23:38:01] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[23:40:03] *** Joins: spud (spud@moz-8F8D4E52.lightspeed.bcvloh.sbcglobal.net)
[23:40:57] <pcwalton> acrichto: so you fixed the bug whereby constants weren't being inlined?
[23:41:03] <pcwalton> I think this is a symptom of that
[23:41:07] <acrichto> pcwalton: I should have
[23:41:11] <pcwalton> no constants being inlined == debug_borrows are always on
[23:41:15] <pcwalton> massive code bloat
[23:41:22] <pcwalton> ok
[23:41:25] <pcwalton> I'll upgrade servo's rust
[23:41:39] <acrichto> is that a constant?
[23:41:45] <pcwalton> the ENABLE_DEBUG that it checks is
[23:42:14] <acrichto> pcwalton: yeah that should definitely be inlined now
[23:49:05] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[23:51:54] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[23:52:30] <pcwalton> ok, rebuilding llvm :)
[23:52:50] <pcwalton> why did my @fn bounce?
[23:53:19] *** Quits: jxv (jxv@moz-8FB92450.lightspeed.irvnca.sbcglobal.net) (Quit: Leaving)
[23:53:24] <acrichto> segfaulted running rustdoc I think
[23:53:31] <pcwalton> old rustdoc?
[23:53:39] <pcwalton> ugh, come on
[23:54:03] <pcwalton> what platform?
[23:54:47] <pcwalton> can we just remove old rustdoc :)
[23:54:57] <pcwalton> it's a tremendous maintenance burden
[23:56:23] <kmc> presumably we could stop building it with new rust, and still run the old binary to document the current code
[23:56:27] <kmc> as an interim measure
[23:58:05] <acrichto> pcwalton: rustdoc_ng pull request should be up by the end of the day
[23:58:08] *** Quits: riley_ (riley@8BA43816.9AA11D69.65DDFA89.IP) (Client exited)
[23:58:09] <acrichto> it doesn't remove rustdoc though

[00:04:45] <Ilari> (Not that I expect anybody to implement it).
[00:22:08] <Tiffany> I actually tried thunderbird again, after a couple years
[00:22:27] <Tiffany> I can pretty safely say it still looks like a fossil from 2003, and that it is still incredibly annoying to setup PGP and S/MIME
[00:24:01] * Ilari is reading official recomendations about IPv6 deployment for consumer Internet connections...
[00:24:50] <Ilari> Things like recommending /56 prefixes, preferred lifetime of 7 days, valid lifetime of 30 days.
[00:27:55] <eternaleye> Tiffany: I use KMail (inside Kontact), and it makes it pretty painless
[00:28:17] <Ilari> Also, be careful about filtering ICMPv6.
[00:28:43] <Elaine> filtering icmp is always a bad idea :(
[00:29:26] <Ilari> Well, there is some ICMPv6 stuff that can be filtered (mostly the stuff that needs HL255)
[00:30:09] <Tiffany> eternaleye: painless how?
[00:38:19] <Ilari> But then there is some ICMPv6 stuff that is VERY bad idea to filter (e.g. PTBs)
[00:48:11] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[00:57:46] <eternaleye> Tiffany: I have my key in KGpg, and in my account preferences I pick which key to sign with, and whether to encrypt by default
[00:58:18] <eternaleye> Tiffany: Stuff from unknown keys is yellow and you can tell it to autofetch keys, stuff with invalid sigs is red, stuff that's valid + trusted is green
[01:07:35] *** Quits: erickt (erickt@moz-4hh.6p3.217.74.IP) (Ping timeout: 121 seconds)
[01:07:46] <Tiffany> autofetch from the key servers?
[01:09:16] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[01:37:11] <Tiffany> I like this XML encryption article
[01:37:36] <Elaine> yeah, that's a good one.
[01:37:44] <Elaine> just goes to show: sidechannels are bad mmkay
[01:38:07] <Tiffany> Minecraft is likely vulnerable to adaptive chosen ciphertext attacks on account of using unauthenticated CFB-8
[01:40:00] <Ilari> XML Encryption? Was that the total Charlie Foxtrot?
[01:40:08] <eternaleye> Tiffany: What article?
[01:40:23] <Tiffany> I thought it was linked here
[01:40:35] <Tiffany> I moved to my phone so no logs 
[01:40:51] <eternaleye> Tiffany: Well it's not in my recent scrollback
[01:42:26] <Tiffany> http://blog.cryptographyengineering.com/2011/10/attack-of-week-xml-encryption.html?m=1
[01:42:57] <Elaine> Tiffany: nah that was #rust-offtopic
[01:43:05] <Tiffany> Oh
[01:49:40] <eternaleye> Funny thing: A variant of that could probably work with any online AEAD that allows truncation (i.e., many of them)
[01:50:05] <eternaleye> Since the XML validation still leaks info about the validity of the truncated form
[01:50:37] <eternaleye> More data in favor of Rogaway's MRAE definitions :D
[01:50:42] <Tiffany> What good is an AEAD which allows truncation?
[01:51:02] <eternaleye> Tiffany: Technically speaking, a TLS session is "an AEAD which allows truncation"
[01:51:13] <eternaleye> Tiffany: Just drop later records.
[01:51:46] <Tiffany> Oh, I was thinking at the individual message level
[01:51:54] <eternaleye> Tiffany: Online AEAD, aka streaming AEAD, has that as an intrinsic behavior - if you can encrypt and decrypt streaming, you can truncate.
[01:52:13] <Tiffany> Er, oh
[01:52:23] <Tiffany> I forgot TCP was a thing
[01:52:43] <eternaleye> Tiffany: Which is a large part of Rogaway's complaint about existing Online AE definitions, such as OAE1
[01:53:06] <eternaleye> Tiffany: And is why he wrote the OAE2 paper
[01:53:18] <eternaleye> https://eprint.iacr.org/2015/189
[01:54:10] <eternaleye> Because the existing definitions and papers were ignoring the unavoidable downsides of online AE, and claiming full AE security
[01:54:21] <Tiffany> I still haven't read that other Rogaway paper you linked
[01:54:30] <eternaleye> So he made a new definition that's much clearer on them, and then provided constructions that meet it
[01:54:34] <eternaleye> Tiffany: This is that same paper
[01:54:40] <Tiffany> Oh
[01:54:42] <Elaine> lol
[01:54:44] <eternaleye> Tiffany: It's a *really* worthwhile paper
[01:55:02] <eternaleye> Tiffany: CHAIN is a construction that satisfies his new definition (OAE2)
[02:29:36] <bascule> eternaleye: heh, know my preferred solution to the truncation and ordering problem?
[02:30:38] <bascule> https://github.com/cryptosphere/cryptosphere/wiki/Data-Model
[02:31:34] <bascule> also https://gist.github.com/CodesInChaos/78b950b1489d5fa3de85
[02:35:37] <bascule> eternaleye: solving that problem correctly is a very deep rabbit hole ;)
[02:40:13] <eternaleye> bascule: Looking at that format, projecting a bit, eh? :P
[02:40:56] <bascule> ?
[02:41:16] <eternaleye> bascule: Mercator projection maps?
[02:41:20] <eternaleye> bascule: It's a pun :P
[02:41:40] <eternaleye> bascule: Also, I'd suggest that for tree-hashing, the Sakura framework is relevant
[02:43:25] <eternaleye> bascule: Also, Rogaway showed that to meet full misuse-resistant AE properties, the scheme must effectively also be an AONT
[02:43:57] <bascule> oh, you're talking about CodesInChaos's stuff
[02:44:18] <eternaleye> bascule: Hm?
[02:44:25] <bascule> Merkator
[02:44:28] <eternaleye> Yeah
[02:44:47] <bascule> my stuff is a bit more than tree-hashing
[02:45:12] <bascule> it's two parallel trees that each express a capability for the blocks they map to
[02:45:29] <bascule> one tree of keys, another tree of IDs
[02:45:44] <bascule> where the IDs are digests in a Merkle tree (so yes, tree hashing, but)
[02:46:23] <eternaleye> Mm
[02:47:10] <eternaleye> I'm not sure that exposing separate decryption capabilities for the blocks is meaningful (or beneficial)
[02:47:59] <eternaleye> Since for larger data than one block, it should be encrypted in an AONT-ish way IMO
[02:48:59] <eternaleye> Personally, my opinion is that the data should be AONT'd at the application-relevant-units level, split at the storage-units level, and have redundancy/verification added over that.
[02:49:16] <bascule> exposing a capability that exposes only hashes lets you verify the integrity of the tree (i.e. in a distributed storage system) without being able to read its contents
[02:49:19] <bascule> and WTF is AONT
[02:49:28] <eternaleye> All-or-nothing transform
[02:49:33] <bascule> Tahoe-LAFS would call ^^^ a verifycap
[02:49:37] <eternaleye> Decryption requires all of the data being present
[02:49:37] <bascule> and what does that mean?
[02:49:59] <bascule> this is to determine if all of the ciphertext is present
[02:50:13] <eternaleye> No, no
[02:50:16] <bascule> not solved in ^^^: erasure coding
[02:50:24] <bascule> this is for a distributed storage use case
[02:50:29] <eternaleye> You're conflating exactly what I was trying to separate
[02:50:33] <bascule> haha ok
[02:50:48] <bascule> well, to decrypt stuff, you have to have the stuff
[02:50:59] <bascule> a verifycap solves the problem of the stuff accidentally disappearing
[02:51:01] <eternaleye> I'm saying that some application A wants to store an arbitrary-sized blob
[02:51:02] <bascule> due to real-world failures
[02:51:10] <bascule> ok?
[02:51:23] <eternaleye> It should encrypt it _as a whole_, such that decryption fails if any part is missing
[02:51:30] <eternaleye> Then chunk it into the blocks
[02:51:36] <eternaleye> _then_ add the verification/erasure-coding
[02:51:44] <bascule> that's... exactly what his does?
[02:51:49] <bascule> this...
[02:52:00] <eternaleye> No, because the key blocks don't do the AONT/as-a-whole thing
[02:52:08] <bascule> I think you're missing the larger problems
[02:52:13] <eternaleye> Because they aggregate keys for sub blocks, which are encrypted individually
[02:52:20] <bascule> like how do you represent tree-like data structures
[02:52:39] <bascule> okay, I think we'll have to disagree here ;)
[02:52:42] <eternaleye> No, my point is that the tree-like data structure should be applied to verification but _not_ decryption
[02:52:58] <eternaleye> Because decrypting a subtree is an antifeature
[02:53:05] <eternaleye> (in terms of a blob)
[02:53:25] <eternaleye> Decrypting some range of a blob requires misfeatures elsewhere in the encryption
[02:53:26] <bascule> it's really not... being able to seek in the data is incredibly important, IMO
[02:53:46] <eternaleye> Yes, so the application level stuff should segment it in meaningful ways
[02:53:50] <bascule> are you familiar with adaptive video streaming?
[02:53:51] <bascule> hahaha
[02:54:01] <eternaleye> But application-unaware chunked encryption is quite problematic
[02:54:26] <bascule> why?
[02:54:35] <bascule> if integrity is assured in this manner
[02:54:42] <eternaleye> And I'll note that adaptive video streaming, like HLS, _does_ segment in meaningful ways at the application level.
[02:54:57] <eternaleye> It segments by time, ensuring whole frames and macroblocks and such.
[02:54:57] <bascule> sure, but with something like this you can avoid that
[02:55:13] <eternaleye> There's a reason HLS is eating http range requests' lunch...
[02:55:15] <bascule> okay sure bad example
[02:55:16] <bascule> anywho
[02:55:21] *** Joins: c74d3 (c74d3a4ebb6@moz-o33jt5.mggc.hibn.4404.2002.IP)
[02:55:22] <bascule> you want files to be unseekable
[02:55:22] <bascule> madness
[02:55:32] <eternaleye> No, I want _records_ to be unseekable
[02:55:53] <bascule> can you explain the problem with this scheme?
[02:55:57] <bascule> what's the attack?
[02:55:58] <bascule> what's the threat
[02:56:00] <bascule> start there
[02:56:26] <bascule> there is no way to reorder
[02:56:29] <bascule> there is no way to truncate
[02:56:34] <bascule> this scheme solves those problems
[02:56:36] <bascule> so what else?
[02:56:44] *** Quits: c74d (c74d3a4ebb6@moz-0ersgu.oc.cox.net) (Ping timeout: 121 seconds)
[02:56:44] <eternaleye> bascule: The attack here isn't on the crypto, it's on the application layer
[02:56:53] *** c74d3 is now known as c74d
[02:56:57] <bascule> so the attack is you can seek within ciphertext?
[02:57:07] <eternaleye> bascule: If someone has a verify cap, they could drill down to a subtree, and send that
[02:57:14] <eternaleye> bascule: Allowing truncation attacks
[02:57:33] <bascule> the only "truncation" attack possible is an inability to read the rest of the data
[02:57:39] <bascule> much like if the physical media failed
[02:58:06] <bascule> it will surface as an error to the application layer, as opposed to an unanticipated successful EOF
[02:58:12] <eternaleye> Mm
[02:58:41] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[02:59:23] <eternaleye> bascule: Lemme dig up the paper where Rogaway showed that non-AONT is incompatible with MRAE
[02:59:56] <eternaleye> bascule: IIRC, it showed that online enc/dec necessarily implies that the nonce can break integrity and/or confidentiality in some ways
[03:00:37] <eternaleye> *reusing
[03:01:33] <eternaleye> bascule: https://eprint.iacr.org/2014/793
[03:01:39] <eternaleye> bascule: p6 of the pdf, p4 of the paper
[03:02:22] <eternaleye> >> Since McOE and COPA [2,23], some recent AE schemes have been advertised as nonce-reuse misuse-resistant despite being online.⁸ But online schemes are never misuse-resistant in the sense originally defined [51].⁹ They never support automatic exploitation of novelty or verified redun- dancy [6] and are always vulnerable to a simple message-recovery attack [47]
[03:05:23] <bascule> eternaleye: each block in that scheme has a derived unique key
[03:05:29] <bascule> nonce reuse isn't possible
[03:05:39] <eternaleye> bascule: mm
[03:05:40] <bascule> in fact it just uses zero for nonces
[03:05:58] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[03:08:24] <eternaleye> Anyway, I also think that chunk-level verification/redundancy for self-healing purposes is meaningfully distinct from application-record-level verification
[03:08:49] <bascule> sure
[03:09:01] <eternaleye> I've actually been working on something substantially similar for a file-sharing system based on fountain codes
[03:11:32] <eternaleye> The AONT stuff actually winds up working out to help support a sort of proof-of-stake credit system
[03:11:41] <bascule> https://tahoe-lafs.org/trac/tahoe-lafs/wiki/NewCaps/Rainhill
[03:11:52] <bascule> ^^^ there's the Tahoe-LAFS solution to the same problem
[03:12:01] <bascule> although that actually incorporates erasure coding
[03:12:31] <bascule> I think pushing the crypto all the way down to the fundamental structring primitive massively simplifies the design
[03:13:45] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[03:18:26] <eternaleye> Mm, whereas I think that as long as the k/v store paradigm is kept (or at very least, path-k/v), the simplicity can be maintained
[03:18:56] <eternaleye> And when dealing with k/v stores, there's a natural tendency to chunk data at the application level in a sensible way
[03:19:58] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[03:25:01] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[03:26:14] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[03:29:30] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[03:30:25] *** Joins: dpc (dpc@moz-t6gr4b.ca.comcast.net)
[03:34:20] <bascule> you can do more than a k/v store
[03:34:30] <bascule> you can do HYPERSPACE HASHING!
[03:37:08] <eternaleye> Heh
[03:37:34] <eternaleye> What I mean is that the paradigm of "Here, hold this for me" leads the developer towards segmenting their data sensibly
[03:37:54] <eternaleye> And makes seeking within the record less of an issue by far
[03:37:59] <bascule> hyperspace hashing is a really cool idea. basically that the hash ring of a consistent hashing system is the degenerate case of a much larger consistent hashing universe made of hyperspaces :o
[04:01:02] *** Joins: dpc_ (dpc@moz-t6gr4b.ca.comcast.net)
[04:16:18] <kmc> i smoked some hyperspace hash once
[04:20:23] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[04:27:28] *** Joins: erickt_ (erickt@moz-njt.vqi.14.76.IP)
[04:27:55] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Connection closed)
[04:32:24] *** Quits: erickt_ (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[04:32:28] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[04:36:58] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[04:37:28] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[04:50:05] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Connection closed)
[04:50:18] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[04:57:43] <bascule> lolololol kmc
[05:06:53] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[05:25:16] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Connection closed)
[05:31:09] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[05:31:55] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Connection closed)
[05:36:10] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[05:38:35] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Connection closed)
[05:41:10] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[05:41:54] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Connection closed)
[05:46:10] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[06:06:33] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[06:49:27] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[06:53:29] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[06:55:15] *** Quits: dpc_ (dpc@moz-t6gr4b.ca.comcast.net) (Ping timeout: 121 seconds)
[06:55:30] *** Quits: dpc (dpc@moz-t6gr4b.ca.comcast.net) (Ping timeout: 121 seconds)
[06:59:38] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[07:03:04] <fkr> :(
[07:03:06] <fkr> oops
[07:03:07] <fkr> sorry
[07:03:22] *** Joins: dpc_ (dpc@moz-t6gr4b.ca.comcast.net)
[07:03:37] *** Joins: dpc (dpc@moz-t6gr4b.ca.comcast.net)
[07:07:51] *** Quits: dpc_ (dpc@moz-t6gr4b.ca.comcast.net) (Ping timeout: 121 seconds)
[07:08:02] *** Quits: dpc (dpc@moz-t6gr4b.ca.comcast.net) (Ping timeout: 121 seconds)
[07:12:07] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[08:20:57] *** Joins: dpc_ (dpc@moz-t6gr4b.ca.comcast.net)
[08:21:13] *** Joins: dpc (dpc@moz-t6gr4b.ca.comcast.net)
[08:29:27] *** Quits: dpc (dpc@moz-t6gr4b.ca.comcast.net) (Ping timeout: 121 seconds)
[08:29:42] *** Quits: dpc_ (dpc@moz-t6gr4b.ca.comcast.net) (Ping timeout: 121 seconds)
[10:57:55] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[11:02:40] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[12:42:23] *** Joins: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua)
[12:46:45] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[12:51:26] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[13:18:29] <Ilari> Lol: openssl aes-256-cbc -K $encrypted_f63987375ff8_key -iv $encrypted_f63987375ff8_iv -in test/github-secret.json.enc -out test/github-secret.json -d
[13:20:34] <Ilari> Eek, unauthenticated encryption.
[13:25:17] *** Quits: c74d (c74d3a4ebb6@moz-o33jt5.mggc.hibn.4404.2002.IP) (Connection closed)
[13:26:40] *** Joins: c74d (c74d3a4ebb6@moz-kn41j4.mggc.hibn.4404.2002.IP)
[13:26:56] *** Quits: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua) (A TLS packet with unexpected length was received.)
[13:29:17] *** Joins: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua)
[14:50:25] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[14:57:37] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[16:00:34] <bascule> Ilari: openssl enc -aes-128-ecb :D
[16:06:11] <Ilari> It is JSON inside, so if one could do adaptive chosen ciphertext attack with just indication of valid JSON for each, one could probably recover the plaintext.
[16:08:21] <Ilari> Haha, perverse incentives, SSL Labs edition: Might be one source of that 256-bit only stuff (causing obsolete crypto warnings or Chacha20 usage in Chrome).
[16:09:01] <Ilari> Not that Chacha20 is even near broken (even Chacha8 isn't, and that has less than half the rounds).
[16:29:32] *** Joins: erickt (erickt@moz-4hh.6p3.217.74.IP)
[16:30:27] <Tiffany> where is that from ilari?
[16:31:12] <Ilari> Tiffany: Let's encrypt repos (that is encrypted API key for Github for purposes of coverage reports).
[16:32:02] <Ilari> Tiffany: That github-secret.json.enc is actually in the repo (that's why that decryption is there).
[16:35:34] <Tiffany> which repo?
[16:36:52] <Ilari> Tiffany: Oh, it is pull request #422 in boulder repo
[16:38:24] <Tiffany> was that meant to be put there?
[16:39:24] <Tiffany> oh
[16:39:45] <Tiffany> I see
[16:44:21] <Tiffany> why is this there? can you not add files to travis, only set environment variables?
[16:48:37] <Ilari> Tiffany: AFAIK, you can't add files with secret contents to travis.
[16:48:53] <Tiffany> hm
[16:48:55] *** Quits: erickt (erickt@moz-4hh.6p3.217.74.IP) (Ping timeout: 121 seconds)
[16:49:03] <Tiffany> but you can set secret environment variables?
[16:49:11] <Ilari> Tiffany: Yes
[16:49:38] <Tiffany> my next question is where you would insert the adaptive chosen ciphertext attack
[16:50:13] <Ilari> Well, probably not practical, given it would need to be against the contents of the encrypted keyfile.
[16:50:32] <Tiffany> you would have to find some kind of way to bypass the pull request process
[16:50:37] <Tiffany> maybe somehow feed travis files directly
[16:50:49] <Tiffany> it would be good to authenticate in any case
[16:51:15] *** Joins: erickt (erickt@moz-4hh.6p3.217.74.IP)
[16:55:01] *** Quits: erickt (erickt@moz-4hh.6p3.217.74.IP) (Quit: Reconnecting)
[16:55:05] *** Joins: erickt (erickt@moz-4hh.6p3.217.74.IP)
[17:20:01] <bascule> https://blogs.aws.amazon.com/security/post/TxCKZM94ST1S6Y/Introducing-s2n-a-New-Open-Source-TLS-Implementation
[17:22:32] <Tiffany> "s2n supports 128-bit and 256-bit AES, in the CBC and GCM modes, 3DES, and RC4" that is a short list
[17:22:39] <Tiffany> why RC4 though, there's an RFC saying you shouldn't use it
[17:22:45] *** Quits: erickt (erickt@moz-4hh.6p3.217.74.IP) (Ping timeout: 121 seconds)
[17:22:59] <Tiffany> it's apparently disabled by default
[17:23:47] <Tiffany> this actually looks nice?
[17:26:27] <Tiffany> I can't tell whether it works with non-blocking IO
[17:40:21] <Ilari> IIRC, I saw somewhere that it does.
[17:40:36] <Tiffany> I guess I can see how
[17:40:47] <Tiffany> you set the socket as non-blocking and the recv/send functions behave just like the real ones
[17:41:15] <Ilari> Modern TLS stack would set minimum to TLS 1.2 and not implement anything besides ECDHE for key exchange at all.
[17:41:51] <Tiffany> the default cipher suite enables 1.0-1.2, but it does force ECDHE
[17:42:21] <Tiffany> I like that this doesn't have the cipher suite string nonsense openssl has
[17:42:28] <Tiffany> you just say how old and broken you want your server to be
[17:42:53] <Tiffany> https://github.com/awslabs/s2n/blob/master/docs/USAGE-GUIDE.md s2n_config_set_protocol_preferences
[17:43:08] <Tiffany> oh I can link the actual section
[17:43:08] <Tiffany> https://github.com/awslabs/s2n/blob/master/docs/USAGE-GUIDE.md#s2n_config_set_protocol_preferences
[17:43:22] *** Joins: erickt (erickt@moz-4hh.6p3.217.74.IP)
[17:48:17] *** Quits: erickt (erickt@moz-4hh.6p3.217.74.IP) (Ping timeout: 121 seconds)
[18:04:46] <Ilari> Unfortunately seems to also support RSA key exchange. :-/
[18:06:43] <Ilari> And as far as I see, it is enabled in all configurations?
[18:08:14] *** Joins: erickt (erickt@moz-4hh.6p3.217.74.IP)
[18:13:47] <bascule> RSA key exchange is the best key exchange!
[18:13:55] <bascule> - yolocrypto
[18:34:08] <Tiffany> I wonder why that's not in the table, then
[18:34:24] <Tiffany> maybe amazon takes rsa key exchange as fundamental
[18:35:08] <Tiffany> I don't really feel daring enough to disable it on my site, since it would break so many clients
[18:36:47] <Tiffany> android didn't get ECDHE until 4.4...
[18:36:58] <Tiffany> IE until 11
[18:37:13] <Tiffany> I guess I don't care much for IE 10
[18:37:20] <Tiffany> the android one is significant though
[18:37:25] <Tiffany> although I'm behind on android versions
[18:37:36] <Tiffany> how many people still have 4.3 or earlier?
[18:37:58] <Tiffany> and then there's older versions of safari which can just go and die for all I care
[18:38:19] <sfackler> Tiffany: ~50% looks like? https://developer.android.com/about/dashboards/index.html?utm_source=suzunone
[18:38:30] <Tiffany> yeah, that's pretty bad
[18:38:49] <bascule> Tiffany: can use (FF)DHE lolololol
[18:38:56] <Tiffany> what even is FFDHE?
[18:39:13] <bascule> finite field Diffie-Hellman (ephemeral)
[18:40:14] <Tiffany> I'm still not sure how finite fields work, I just know they're also used in poly1305 and GCM
[18:40:36] <Tiffany> what's wrong with (FF)DHE?
[18:41:44] <bascule> it's slow and has giant keys compared to ECDHE
[18:41:51] <Tiffany> oh
[18:42:00] <Tiffany> why does it need giant keys?
[18:42:05] <bascule> and as weakdh.org showed, there were lots of weak versions
[18:42:08] <bascule> index calculus attacks
[18:52:07] <Ilari> Well, if you require TLS 1.2 (PCI anyone?), you seem you might require ECDHE just as well...
[18:53:19] <Tiffany> oh
[18:53:34] <Tiffany> the site I was testing against ssl labs not only enforces ECDHE, but TLS 1.2 as well
[18:54:09] *** Quits: erickt (erickt@moz-4hh.6p3.217.74.IP) (Ping timeout: 121 seconds)
[18:54:36] <Tiffany> still, 50% of the android userbase is a lot to lose
[18:58:47] <Ilari> Well, PCI doesn't require TLS 1.2 as of currently (and there is some transition time for _existing_ services), but anything that supports TLS 1.1 almost invariably supports 1.2 as well.
[18:59:08] <Ilari> And anything that supports 1.2 almost invariably supports ECDHE.
[19:00:03] <Tiffany> why is that?
[19:00:19] <Tiffany> did 1.2 come out very shortly after 1.1?
[19:00:27] <Tiffany> at least, compared to 1.0
[19:00:30] <Tiffany> 1.0 is from 1999 right?
[19:00:41] <Tiffany> wikipedia time
[19:00:48] <Ilari> Also, 1.1 is very small delta from 1.0. 1.2 is much bigger one from 1.1.
[19:00:52] <bascule> Ilari: they're going to next year
[19:00:53] <Tiffany> 1999, 2006, 2008
[19:00:54] <Tiffany> yeah...
[19:01:24] <Tiffany> so everyone running shitty old crap piles is on 1.0, and then everything that's been updated in the past 7 years is running 1.2
[19:01:29] <Ilari> Jan 1999, Apr 2006, Aug 2008.
[19:02:38] <Tiffany> ooh, there's a feature list for 1.3 and it looks nice
[19:02:52] <Ilari> Tiffany: Just how complicated it is going to be?
[19:03:08] <Tiffany> https://en.wikipedia.org/wiki/Transport_Layer_Security#TLS_1.3_.28draft.29
[19:03:20] <Tiffany> I hope it's less complicated to implement
[19:03:24] <Tiffany> I might actually use it
[19:03:29] <Tiffany> not that I will be implementing it
[19:03:52] <Tiffany> I just don't want any more of these stupid state machine bugs
[19:04:30] <Tiffany> "The record layer version number has been frozen and deprecated for improved backwards compatibility" what does this mean?
[19:04:32] <Ilari> Could be useful: Modern TLS stack written in Rust.
[19:04:50] <Tiffany> hmm
[19:04:51] <Ilari> Tiffany: All records claim to be TLS 1.0.
[19:04:54] <Tiffany> actually, that would be pretty cool
[19:05:21] <Tiffany> a TLS 1.3 impl which supports only ECDHE with either AES-GCM or chacha20-poly1305
[19:05:23] <Tiffany> in rust
[19:07:39] <Ilari> TLS 1.2 (and 1.3 after final codepoints get assigned), EMS, ECDHE only, RSA/ECDSA/ECIDSA (or whatever) for certs, AES-CBC (fully protected against Lucky13), AES-GCM, Chacha20-Poly1305, P-256/P-384/P-521/Curve25519/Curve448 for key exchange, etc..
[19:09:15] <Tiffany> EMS?
[19:09:25] <Ilari> Extended Master Secret (protection against THS).
[19:11:27] <Tiffany> wow I didn't know AES-GCM was TLS 1.2+
[19:11:53] <Ilari> IIRC, AES-GCM was after TLS 1.2 and needs TLS 1.2 due to using AEAD mode.
[19:12:13] <Tiffany> yeah AEAD in general appears to be TLS 1.2+
[19:13:05] <Tiffany> oh so that's why the rename from SSL to TLS
[19:13:09] <Tiffany> it wasn't backwards compatible
[19:15:04] <klutzy> Tiffany: on name changes: http://tim.dierks.org/2014/05/security-standards-and-name-changes-in.html
[19:20:33] <Tiffany> so I'm reading that article linked in the comments of that about netscape's RNG...
[19:20:44] <Tiffany> did netscape look as blatantly incompetent then as they do now?
[19:31:53] <Ilari> Tiffany: As for the rename, it was a trademark thing.
[19:32:00] <Tiffany> oh
[19:32:04] <Tiffany> SSL is trademarked?
[20:51:46] *** Joins: erickt (erickt@moz-4hh.6p3.217.74.IP)
[21:01:47] <mcpherrin> Tiffany: It was the dark ages back then
[21:27:08] <Ilari> Haha: "I really don't want to have to be sysadmin for my effing stove"
[21:29:11] <Ilari> 'You can tell a protocol is badly justified when researchers describing it must include lists of "apparently intended properties"'
[21:31:45] <eternaleye> Ilari: Source?
[21:32:52] <Ilari> https://twitter.com/nickm_tor/status/615946585701228544
[21:36:25] <Tiffany> pets15?
[21:37:25] <Elaine> https://petsymposium.org/2015/
[21:37:31] <Elaine> I imagine
[21:40:14] <Ilari> TLS_RSA_WITH_3DES_EDE_CBC_SHA ... Supported by all configs of s2n.
[21:41:15] <Tiffany> gross
[21:41:27] <Tiffany> what's the EDE for?
[21:41:45] <Ilari> Encrypt-Decrypt-Encrypt.
[21:43:14] <Tiffany> uhh
[21:43:21] <Tiffany> with different keys?
[21:43:29] <Tiffany> so the decryption procedure is decrypt-encrypt-decrypt?
[21:45:26] <Ilari> Yeh.
[21:45:29] <Ilari> *yeah
[21:47:30] <Ilari> Construct is vulernable to meet-in-the-middle attacks, so strength is only 112 bits, not 168 bits as would be suggested by the keylength.
[22:05:16] *** Quits: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua) (Ping timeout: 121 seconds)
[22:16:23] <bascule> Ilari: o_O
[22:16:27] <bascule> Ilari: s2n makes me sad
[22:16:31] <bascule> why did they write it in C?
[22:16:34] <bascule> oh yeah
[22:16:37] <bascule> did you see the best part?
[22:17:22] <bascule> it doesn't support validating certificates
[22:17:29] <bascule> so it's only useful for servers
[22:17:42] <bascule> servers that don't validate client certs!
[22:22:16] <Elaine> yeah, s2n is pretty weird.
[22:22:41] <Tiffany> and it also depends on the crypto library part of openssl
[22:24:24] <bascule> Tiffany: well, the other day I was saying I wish they'd split libcrypto out into a separate project
[22:24:27] <bascule> exactly for this purpose
[22:24:39] <bascule> except I'd rather the replacement libssl/libtls be written in Rust and not C o_O
[22:28:44] <Ilari> How many memory-safe systems programming languages there are?
[22:29:42] <bascule> are there any others that aren't Rust? heh
[22:29:46] <Tiffany> rust, go (ish), D (if you use the safe subset, which is limited), idris (it's a bit of a stretch to call this one a systems' language), and probably some lesser known ones?
[22:29:48] <bascule> I'm sure the answer is yes
[22:30:00] <bascule> D has a garbage collector...
[22:30:02] <Tiffany> cyclone?
[22:30:05] <eternaleye> Tiffany: I don't think go is memory safe...
[22:30:07] <bascule> Idris too, I assume
[22:30:13] <Elaine> I'd rather small security critical software be written with vcc and other proof assistents than Rust at this point.
[22:30:19] <Tiffany> eternaleye: it's not thread safe, but I think it is memory safe if you don't use threads
[22:30:23] <bascule> and yes, Go is both not memory safe and has a garbage collector
[22:30:25] <Ilari> Also, seems like fairly soon stuff that doesn't do TLS 1.2 will be obsolete.
[22:30:25] <eternaleye> Tiffany: casting to interface{} gives me the heebie jeebies
[22:30:34] <Tiffany> well
[22:30:36] <eternaleye> Tiffany: If it's  not type safe, it's not memory safe
[22:30:38] <bascule> I would definitely not call Go a systems programming language
[22:30:41] <Tiffany> I didn't say they were good memory-safe systems' languages
[22:30:44] <bascule> it has a giant abstraction layer over the OS
[22:30:47] <eternaleye> Tiffany: Was it huon who did a nice post about that wrt enums?
[22:31:32] <huon> I think it was pnkfelix
[22:31:50] <huon> if you're talking about http://blog.rust-lang.org/2015/04/17/Enums-match-mutation-and-moves.html
[22:32:36] <eternaleye> Mm, no, not that post
[22:33:10] <eternaleye> It's the one that demonstrates point-by-point how taking a reference to the inside of a mutable enum blows everyone's feet off
[22:33:23] <huon> not one of mine
[22:33:52] <Elaine> manishearth's
[22:33:54] <eternaleye> Ah, seems it was Manishearth
[22:33:55] <eternaleye> http://manishearth.github.io/blog/2015/05/17/the-problem-with-shared-mutability/
[22:34:18] <Tiffany> oh I didn't think about iterator invalidation
[22:34:32] <Tiffany> I don't know how google can think that go is a foolproof language if it's so blatantly unsafe
[22:34:43] <Elaine> what makes you think google thinks that?
[22:34:46] <eternaleye> Tiffany: I don't think they ever claimed it was
[22:34:52] <Tiffany> I'm pretty sure they have
[22:35:10] <eternaleye> Tiffany: In fact, Pike pretty flatly claimed that it was made for practicality, not perfection.
[22:35:24] <Tiffany> what does practicality mean?
[22:35:28] *** Joins: dpc (dpc@moz-52v2l7.nvidia.com)
[22:35:31] <eternaleye> Tiffany: It's very much a language in the C tradition.
[22:36:11] <eternaleye> Tiffany: Provide tools that can do the job, and rely on the programmer not aiming at their feet.
[22:37:09] *** Joins: dpc_ (dpc@moz-52v2l7.nvidia.com)
[22:37:10] *** Joins: dpc__ (dpc@moz-52v2l7.nvidia.com)
[22:39:07] <eternaleye> Tiffany: This may be illustrative: http://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html
[22:39:17] *** Quits: dpc_ (dpc@moz-52v2l7.nvidia.com) (Connection closed)
[22:39:42] <eternaleye> Tiffany: A post from Rob Pike, who was on the team that started Go.
[22:40:08] *** Joins: dpc_ (dpc@moz-52v2l7.nvidia.com)
[22:40:21] *** Quits: dpc (dpc@moz-52v2l7.nvidia.com) (Ping timeout: 121 seconds)
[22:40:54] *** Quits: dpc_ (dpc@moz-52v2l7.nvidia.com) (Connection closed)
[22:41:58] <eternaleye> Tiffany: In particular, I draw your attention to the way he completely conflates generics, inheritance-based typing, and containers.
[22:42:44] <eternaleye> Tiffany: Since he seems to feel the only use for generics is containers, and all "types" are inheritance-trees of classes.
[22:43:33] *** Quits: dpc__ (dpc@moz-52v2l7.nvidia.com) (Ping timeout: 121 seconds)
[22:43:51] <Tiffany> okay, so I have no official source on that
[22:43:55] <Tiffany> but these features do seem to add up to that...
[22:44:39] <bascule> https://i.imgur.com/OROqQ7e.png
[22:44:44] <bascule> ^^^ I like C there
[22:44:53] <bascule> just use the hammer to hit the firing pin
[22:44:56] <bascule> no problem
[22:45:27] <mcpherrin> scope knife is too good
[22:46:01] <bascule> hahaha
[22:46:08] <bascule> what a handy feature eh?
[22:47:07] <mcpherrin> the C one is good except for the part where guns don't work like that ;p
[22:47:40] <Elaine> neither does writing software ;)
[22:48:20] <mcpherrin> C as a pipe gun though: I can get behind that
[22:48:33] <mcpherrin> http://www.wikihow.com/Make-a-Real-Gun#Making_an_Improvised_Pipe_Gun_sub
[22:49:22] <mcpherrin> Please note: If you attempt to fire a bullet from a piece of pipe that you're holding in your hand, and that bullet doesn't fit snugly in the piping, or the pipe isn't thick enough to withstand the pressure of the expanding explosion you're creating by striking the bullet, the pipe is going to blow up in your face, injuring or possibly killing you. Use extreme caution.
[22:49:27] <mcpherrin> Sounds like C
[22:50:22] <Elaine> I'm honestly not sure why the Go folk would have expected C++ people to see it as a viable alternative.
[22:50:47] <Elaine> You lose everything good about C++ and gain everything bad about, say, ocaml.
[22:50:48] <mcpherrin> Elaine: It is for *them*, that's why
[22:51:11] <mcpherrin> Go (supposedly?) replaced a pile of janky c++ services at google
[22:55:05] <Ilari> Heh, pipes blowing up... Reminds me of stories about "improving" military bullets and then trying to shoot those with assault rifle (which isn't built to withstand the increased power)... Dunno if that sort of stuff has actually happened.
[23:09:19] <Tiffany> I want to know which language is the actual gun in these examples
[23:10:13] <Tiffany> the only issue I have with C is that zero-cost abstraction doesn't exist
[23:11:13] <Ilari> If CFRG doesn't get more proposals than those three, I'm bit dissapointed.
[23:11:16] <Tiffany> I don't really have any issue with C++
[23:11:54] <eternaleye> Tiffany: Depends on what kind of gun
[23:13:19] <eternaleye> Tiffany: Rust might be considered a sniper rifle: Achieve the objective without risking harm to yourself
[23:13:35] <eternaleye> Tiffany: (At maximum efficiency for that constraint)
[23:13:56] <eternaleye> Tiffany: But in the end, they're all very lossy metaphors
[23:16:08] <Ilari> Heh, that phyton thing reminds me of breeders in GoL. And a pattern that would be fun to see: Caterpillar gun.
[23:31:55] <Ilari> Wonder what is the meaning for existing in context of PCI DSS...
[23:52:08] <Tiffany> the ARIN counter updated again, not it's down to 0.00887
[23:52:11] <Tiffany> it sure has slowed
[23:52:27] <Tiffany> I guess nobody really wants something as tiny as a /23 very much
[23:53:11] <Ilari> Well, there are lots of requests in queue, and those are processed. Also, given that one request can only give one allocation, one expects the rate to slow down a lot.
[23:53:32] <Tiffany> oh
[23:55:34] <Ilari> Whereas APNIC split requests, which enabled very fast depletion.

[00:07:42] <jmgrosen> sebcrozet: you should post nphysics to Hacker News -- I think they'd love it
[00:08:29] <jmgrosen> they eat up Servo and other rust projects
[00:10:18] <tiffany> I might use nphysics someday
[00:10:39] <Eridius> nphysics?
[00:11:15] <dbaupp> Eridius: https://github.com/sebcrozet/nphysics
[00:12:38] <Eridius> neat
[00:13:01] <Eridius> "rusty sexyness".
[00:14:16] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[00:18:27] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[00:20:21] <jmgrosen> ah, one question i've been wondering about: why does rustc leave .dSYM dirs around on OS X? they're quite annoying
[00:22:13] <jmgrosen> rusti: loop;
[00:22:17] -rusti- pastebinned 9 lines of output: http://ix.io/7LE
[00:22:38] <jmgrosen> rusti: loop; ()
[00:22:41] -rusti- pastebinned 12 lines of output: http://ix.io/7LF
[00:22:55] *** Joins: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net)
[00:23:13] <jmgrosen> rusti: let b: uint = 5; loop; b
[00:23:16] -rusti- pastebinned 12 lines of output: http://ix.io/7LG
[00:23:35] <MrByte> Does anyone else here develop on Windows?
[00:23:36] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[00:23:42] <jmgrosen> what's the point of `loop;` anyway?
[00:24:11] <SiegeLord> It's the 'continue' from C/C++
[00:24:15] <cmr> MrByte: I do sometimes
[00:24:37] <jmgrosen> SiegeLord: oh. that's confusing -- I thought it was just an infinite busy loop
[00:25:53] <MrByte> Experimenting with a DirectX wrapper idea (pretty sure I can make COM interfaces work in rust 0.8 thanks to the new function pointer fixes), but I'm having fun times with linking.
[00:26:01] <strcat> jmgrosen: loop {} is
[00:26:30] <jmgrosen> strcat: yeah, I got that, but I thought that's what `loop;` would do too
[00:28:24] *** Joins: eatkinson (eatkinson@moz-261EDE03.hsd1.ca.comcast.net)
[00:29:43] *** Quits: sevvie (sevvierose@moz-8BC5868E.hfc.comcastbusiness.net) (Ping timeout)
[00:30:45] *** Joins: Ralith (ralith@moz-B932C54E.hsd1.wa.comcast.net)
[00:30:45] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[00:30:46] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/172RWg
[00:30:46] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[00:30:58] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[00:32:22] *** Joins: victorporof (victorporo@9D964D4D.36D485C.2B3D3D4.IP)
[00:33:31] *** Quits: Ralith (ralith@moz-B932C54E.hsd1.wa.comcast.net) (Ping timeout)
[00:34:27] *** Quits: victorporof (victorporo@9D964D4D.36D485C.2B3D3D4.IP) (Ping timeout)
[00:36:59] *** Joins: Ralith (ralith@moz-B932C54E.hsd1.wa.comcast.net)
[00:38:59] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Ping timeout)
[00:39:18] <tiffany> huh, does fmt!("%?") not handle function types?
[00:39:37] <tiffany> it just printed this function as a ~
[00:40:15] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[00:40:26] <tiffany> rusti: fmt!("%?", &println)
[00:40:28] -rusti- ~"&"
[00:40:54] <tiffany> rusti: fmt!("%?", println)
[00:40:55] -rusti- ~""
[00:40:55] <strcat> tiffany: open issue about it
[00:41:02] <strcat> I mean, there is one
[00:41:21] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[00:41:39] <strcat> rusti: ~5 as ~ToStr
[00:41:48] <strcat> rusti: &println
[00:41:49] -rusti- &
[00:41:54] <strcat> at least it gives the sigil for a fn
[00:42:01] *** Quits: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com) (Ping timeout)
[00:42:35] <Eridius> strcat: I'm surprised rusti didn't indicate that there was no output from the ~ToStr one
[00:42:56] <strcat> it indicates it by not saying ()
[00:43:10] <strcat> Eridius: there was output
[00:43:13] <strcat> it printed a newline
[00:43:16] <Eridius> it should say _something_ so I know it's not broken
[00:43:24] <strcat> pfft, it's never broken
[00:43:34] <tiffany> I can't find the issue for this
[00:43:34] <Eridius> hah. have you updated it since you had to roll it back?
[00:43:54] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[00:43:56] <strcat> Eridius: yes
[00:44:04] <strcat> that set of commits was reverted
[00:44:20] <Eridius> ok
[00:45:34] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[00:46:55] <glyc> is there foreach(i, it; collection) {} form in Rust? i.e. I'd like to get both an iterator (it) and the integer offset i for the vector so if need be I can access collection[i] (which should == *it)
[00:47:32] <Eridius> .enumerate()
[00:47:51] <glyc> Eridius: thanks, I'll check out .enumerate()
[00:47:51] <Eridius> rusti: for (i, x) in [1,2,3].iter().enumerate() { printfln!("%d: %?", i, x) }
[00:47:55] -rusti- pastebinned 9 lines of output: http://ix.io/7LH
[00:48:03] <Eridius> rusti: for (i, x) in [1,2,3].iter().enumerate() { printfln!("%u: %?", i, x) }
[00:48:06] -rusti- pastebinned 11 lines of output: http://ix.io/7LI
[00:48:11] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[00:48:13] <Eridius> bah, rvalue issue
[00:48:26] <Eridius> rusti: let xs = [1,2,3]; for (i, x) in xs.iter().enumerate() { printfln!("%u: %?", i, x) }
[00:48:27] -rusti- 0: &1
[00:48:27] -rusti- 1: &2
[00:48:27] -rusti- 2: &3
[00:48:27] -rusti- ()
[00:48:52] <bjz_> Infiltrator: ahh, np. thought you were just looking to stir up some trouble. :)
[00:49:00] <Eridius> glyc: btw if your goal is to mutate the collection, you should just use .mut_iter()
[00:49:16] *** Quits: fyolnish (fyolnish@moz-52A8A20.uqwimax.jp) (Client exited)
[00:49:20] <Eridius> glyc: that will yield &mut T values. Trying to mutate it with `collection[i] = foo` will fail because the collection is borrowed by the iterator
[00:49:47] <glyc> Eridius: mut_iter() got it
[00:49:58] *** Quits: heftig (heftig@moz-1731F2A.dip0.t-ipconnect.de) (Ping timeout)
[00:49:59] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[00:50:16] *** Joins: samx (sami@moz-D9DA5773.dyn.optonline.net)
[00:50:18] <Eridius> rusti: let mut xs = [1,2,3]; for x in xs.mut_iter() { *x += 1 }; xs
[00:50:19] -rusti- [2, 3, 4]
[00:51:51] <glyc> Eridius: sweet, works nicely
[00:52:37] <glyc> I'd like to be able to deserailize from Thrift, is anyone working on ApacheThrift bindings?
[00:54:15] <glyc> I see https://github.com/mozilla/rust/issues/1677 but any 3rd party?
[00:54:39] *** Quits: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net) (Input/output error)
[00:54:51] <cmr> glyc: nope, not that I've heard of
[00:55:04] *** Joins: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net)
[00:55:20] <erickt> glyc: I don't think anyone is doing thrift, but we do have a protocol buffers, capn-proto, and msgpack bindings
[00:55:41] <glyc> erickt: nice!
[00:56:48] *** Quits: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net) (Ping timeout)
[00:57:29] <Infiltrator> bjz_: Well, that too.  ;)
[00:58:12] *** Joins: sevvie (sevvierose@moz-8BC5868E.hfc.comcastbusiness.net)
[00:58:28] *** Joins: a__ (a__@moz-25043B93.nycmny.fios.verizon.net)
[00:59:15] *** Joins: m_kato (m_kato@moz-C286AD9A.bitcat.net)
[00:59:37] *** Quits: miza (miza@moz-4DD51325.home.otenet.gr) (Input/output error)
[00:59:59] *** Quits: sevvie (sevvierose@moz-8BC5868E.hfc.comcastbusiness.net) (Ping timeout)
[01:00:44] *** Joins: heftig (heftig@moz-80B7FC6E.dip0.t-ipconnect.de)
[01:02:24] *** Quits: eatkinson (eatkinson@moz-261EDE03.hsd1.ca.comcast.net) (Quit: eatkinson)
[01:03:55] *** Joins: matt (Mibbit@moz-7148C1B.sub-70-198-65.myvzw.com)
[01:04:52] *** Quits: sigma (sigma@2AE71BC1.DC5B0862.37339E3A.IP) (Client exited)
[01:05:19] <glyc> let mut xs = [1,2,3]; for (i, x) in xs.mut_iter().enumerate() { *x += i; } // pointing to the += i; rustc says: mismatched types: expec\ ted `int` but found `uint` (expected uint but found int);   how do I cast from uint to int?
[01:05:41] <klutzy> i as int
[01:05:47] <glyc> klutzy: thanks!
[01:06:08] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[01:06:23] <tiffany> huh, there's no issue for higher kinded polymorphism on the tracker
[01:07:58] *** Quits: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net) (Ping timeout)
[01:09:12] <bjz_> tiffany: wut
[01:09:17] <bjz_> tiffany: really?
[01:09:30] * bjz_ is surprised
[01:09:31] <tiffany> there's one that briefly mentions it but it was closed a year ago
[01:09:58] <tiffany> and is actually about regions on type parameters, using what I'm guessing is old and replaced syntax
[01:10:22] <bjz_> tiffany: you should make one
[01:11:19] *** Joins: fyolnish (fyolnish@moz-BE2BAE5B.miinet.jp)
[01:11:34] <Eridius> rusti: let mut xs = [1,2,3]; for (i, x) in xs.mut_iter().enumerate() { *x += i }; xs
[01:11:35] -rusti- <anon>:5:79: 5:80 error: mismatched types: expected `int` but found `uint` (expected uint but found int)
[01:11:35] -rusti- <anon>:5          let mut xs = [1,2,3]; for (i, x) in xs.mut_iter().enumerate() { *x += i }; xs
[01:11:35] -rusti-                                                                                         ^
[01:11:35] -rusti- error: aborting due to previous error
[01:11:37] -rusti- application terminated with error code 101
[01:11:39] <Eridius> rusti: let mut xs = [1,2,3]; for (i, x) in xs.mut_iter().enumerate() { *x += i as int }; xs
[01:11:40] -rusti- [1, 3, 5]
[01:12:16] *** Joins: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net)
[01:12:25] <tiffany> I've never written a feature request issue before
[01:12:26] <Eridius> rusti: let mut xs = [1,2,3]; for (i, x) in Counter::new(10i, 1).zip(xs.mut_iter()) { *x += i }; xs
[01:12:30] -rusti- pastebinned 11 lines of output: http://ix.io/7LK
[01:12:53] <Eridius> oh there's a func for that now
[01:13:02] <glyc>     let mut xs = [1,2,3]; for (i, x) in xs.mut_iter().enumerate() {  *x += i as int;  printfln!("xs[%u] = %?x", i, xs[i]); /* error her\ e */ }  // error is error: cannot borrow `xmut[]` as immutable because it is also borrowed as mutable; I don't understand. Once somethi\ ng is borrowed as mutable why can't it be passed to a const function?
[01:13:08] <Eridius> rusti: let mut xs = [1,2,3]; for (i, x) in count(10i, 1).zip(xs.mut_iter()) { *x += i }; xs
[01:13:09] -rusti- <anon>:5:45: 5:50 error: unresolved name `count`. Did you mean `xs`?
[01:13:09] -rusti- <anon>:5          let mut xs = [1,2,3]; for (i, x) in count(10i, 1).zip(xs.mut_iter()) { *x += i }; xs
[01:13:09] -rusti-                                                       ^~~~~
[01:13:09] -rusti- error: aborting due to previous error
[01:13:09] -rusti- application terminated with error code 101
[01:13:20] <Eridius> bah, not in the prelude?
[01:13:25] <strcat> nope
[01:13:25] <Eridius> rusti: let mut xs = [1,2,3]; for (i, x) in std::iterator::count(10i, 1).zip(xs.mut_iter()) { *x += i }; xs
[01:13:26] -rusti- [11, 13, 15]
[01:13:44] <bjz_> tiffany: wouldn't have to be anything elaborate, just so we can track it
[01:14:00] <Eridius> glyc: you have a mutable borrow on the vector, because of .mut_iter(). You can't take a second borrow, which is what xs[i] is doing
[01:14:03] <Eridius> glyc: just use *x instead of xs[i]
[01:14:21] <tiffany> https://github.com/mozilla/rust/issues/8922
[01:14:28] <Eridius> rusti: let mut xs = [1,2,3]; for (i, x) in xs.mut_iter().enumerate() { *x += i as int; printfln!("xs[%u] = %?", i, *x); } xs
[01:14:29] -rusti- xs[0] = 1
[01:14:29] -rusti- xs[1] = 3
[01:14:30] -rusti- xs[2] = 5
[01:14:30] -rusti- [1, 3, 5]
[01:14:37] <Eridius> glyc: ^
[01:14:37] *** Quits: Ralith (ralith@moz-B932C54E.hsd1.wa.comcast.net) (Connection reset by peer)
[01:14:41] <glyc> Eridius: okay, strange, but okay.
[01:14:55] *** Joins: Ralith (ralith@moz-B932C54E.hsd1.wa.comcast.net)
[01:15:18] <Eridius> glyc: http://static.rust-lang.org/doc/tutorial-borrowed-ptr.html
[01:15:26] <glyc> Eridius: what if I want to compute xs[i] = xs[i] - xs[i-1] 
[01:15:39] <glyc> i.e. read and write
[01:15:39] <strcat> glyc: then use an index instead of an iterator
[01:15:40] <engla> mutable access is exclusive
[01:15:49] <Eridius> glyc: well you could always iterate manually ;) or you could try something fancy with a windowing iterator
[01:16:02] <Eridius> or use a scan, where the state is the previous value
[01:16:02] <glyc> engla: mutable is exclusive, okay, so just don't use the iterator then. cool. thanks!
[01:16:15] <glyc> Eridius: scan, I'll look that up.
[01:16:20] <engla> glyc: or access it through the reference you get from the iterator
[01:16:43] *** Quits: Ralith (ralith@moz-B932C54E.hsd1.wa.comcast.net) (Ping timeout)
[01:17:03] <glyc> engla, Eridius: is range() the fastest way to iterate manually?  (What's the equivalent of C's for (int i =0; i < xs.len(); ++i ) { ...
[01:17:15] <Eridius> yes, range is correct.
[01:17:28] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[01:17:28] <glyc> Eridius: correct but also low-overhead?
[01:17:30] <Eridius> rusti: let mut xs = [1,2,3]; xs.mut_iter().scan(0, |st,x| { let a = *st; *x -= *st; *st = a }).to_owned_vec()
[01:17:33] -rusti- pastebinned 9 lines of output: http://ix.io/7LL
[01:17:41] <Eridius> glyc: yeah, iterators get inlined and compiled away by llvm
[01:17:43] <strcat> glyc: well range() is going to compile to the same code as a C for loop
[01:17:48] <strcat> but the indexing will be bounds checked
[01:17:58] <glyc> strcat: great
[01:18:02] <glyc> thanks!!
[01:18:07] <Eridius> rusti: let mut xs = [1,2,3]; xs.mut_iter().scan(0, |st,x| { let a = *st; *st = *x; Some(*x - a) }).to_owned_vec()
[01:18:08] -rusti- ~[1, 1, 1]
[01:18:21] <glyc> strcat: is there a compile time flag to turn off bounds checking?
[01:18:28] <glyc> at run time
[01:18:31] <strcat> glyc: there isn't
[01:18:36] <Eridius> glyc: no, but there are unsafe methods that skip the bounds check
[01:18:39] <Eridius> you shouldn't use them though
[01:18:42] <strcat> rust is memory safe, there's no flag to make it not memory safe
[01:18:58] <Eridius> llvm should remove redundant/unnecessary bounds checks
[01:18:58] <strcat> if you can validate a specific usage of indexing, you can use the unchecked (and unsafe) indexing methods
[01:19:03] <strcat> it will remove some
[01:19:42] <glyc> strcat: ah, so the iterator should skip the bounds check, yes?
[01:19:59] <strcat> glyc: yes iterators will never have a bounds check
[01:20:06] <strcat> in some cases, LLVM can eliminate the bounds checks on indexing
[01:20:19] <Eridius> rusti: let xs = [1,5,7]; xs.window_iter(2).map(|xs| xs[1] - xs[0]).to_owned_vec()
[01:20:20] -rusti- ~[4, 2]
[01:20:47] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[01:20:50] <glyc> strcat: right, but apparently that's not all that often, if I understand the current state-of-the-art on bounds checking
[01:21:22] <strcat> glyc: yeah you're better off using iterators if you can, since you'll get fast code all the time
[01:21:22] <Eridius> glyc: if, when profiling, you determine bounds checking to be a problem, and you can prove that it's unnecessary, you can use the unsafe methods
[01:21:35] <Eridius> but unless you can prove it's unnecssary, _and_ profiling shows it to be an issue, I wouldn't worry about it
[01:21:41] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[01:22:11] <glyc> strcat, Eridius: very reasonable line of thought, thanks
[01:22:52] <glyc> what is the preferred debugger for Rust?  gdb?
[01:23:02] <glyc> lldb?
[01:23:12] <glyc> (on linux)
[01:23:30] <strcat> either should work on linux
[01:23:33] <strcat> only gdb works on OS X
[01:23:43] <strcat> because something is wrong with the call frame info on OS X :s
[01:23:55] <glyc> strcat: lldb sadness
[01:24:36] <strcat> glyc: and you need -Z debug-info
[01:24:38] <strcat> passed to rustc
[01:25:14] <glyc> strcat: I'll try -Z debug-info
[01:26:39] <glyc> strcat: nice, gdb works!!
[01:27:14] <strcat> :)
[01:28:56] *** Joins: sruggier (sruggier@moz-F1ED47A9.cpe.teksavvy.com)
[01:29:01] *** Joins: sevvie (sevvierose@moz-8BC5868E.hfc.comcastbusiness.net)
[01:29:52] *** Joins: Ralith (ralith@moz-B932C54E.hsd1.wa.comcast.net)
[01:30:45] *** Quits: matt (Mibbit@moz-7148C1B.sub-70-198-65.myvzw.com) (Quit: http://www.mibbit.com ajax IRC Client)
[01:30:49] *** Quits: sevvie (sevvierose@moz-8BC5868E.hfc.comcastbusiness.net) (Ping timeout)
[01:32:51] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[01:32:56] *** Joins: victorporof (victorporo@9D964D4D.36D485C.2B3D3D4.IP)
[01:34:53] *** Quits: jpf (jan@moz-A8C26A15.org) (Ping timeout)
[01:34:59] *** Quits: victorporof (victorporo@9D964D4D.36D485C.2B3D3D4.IP) (Ping timeout)
[01:36:02] *** Joins: benza (Mibbit@moz-99D3664A.c3-0.161-ubr1.lnh-161.md.cable.rcn.com)
[01:36:54] <benza> hi
[01:36:57] <Eridius> hi
[01:37:45] <benza> do you guys have a web server to recommend for rust or is it not one of the language's goal?
[01:38:00] <strcat> https://github.com/chris-morgan/rust-http
[01:38:06] <klutzy> https://github.com/chris-morgan/rust-http
[01:38:06] <strcat> don't know what you mean by not the language's goal
[01:38:07] <klutzy> oops.
[01:38:16] *** Joins: jpf (jan@moz-A8C26A15.org)
[01:38:17] <strcat> it's a general purpose language, and intended to be good at concurrency/networking
[01:38:18] *** Joins: dew (Instantbir@moz-D2FA52B6.static.stls.mo.charter.com)
[01:38:28] <jmgrosen> only semi-rust related, but how can I remove a particular symbol from an object file?
[01:38:56] <jmgrosen> `strip -R symbols.txt` doesn't seem to be working
[01:39:25] *** Quits: dew1 (Instantbir@moz-D2FA52B6.static.stls.mo.charter.com) (Ping timeout)
[01:39:42] <benza> so in theory rust would be a pretty good language for a web server that balances load across all cores?
[01:40:26] <sruggier> yeah
[01:40:35] <glyc> jmgrosen: don't include that symbol to begin with, might be easiest really
[01:40:51] <jmgrosen> glyc: how do I not include _rust_abi_version? :(
[01:41:32] <glyc> jmgrosen: :-(  what happens when it is included?
[01:42:31] <benza> looks like it's still very much a work in progress. Wonder if one could use a web server written in a different language but use rust for the actual business logic
[01:42:50] <jmgrosen> glyc: I'm trying to link my foo.o (an object of rust code) with libstd.a (a static version of rust's libstd), but it tells me that I have a duplicate symbol of _rust_abi_version
[01:42:55] <glyc> jmgrosen: looks like it is defined in ./librustc/middle/trans/base.rs 
[01:42:57] <cmr> benza: probably, write a fastcgi binding/library.
[01:43:11] <glyc> jmgrosen: so just comment it out and recompile, is what I would try
[01:43:17] <cmr> benza: ...as well as an entire web framework, since there are no templating libraries or anything else.
[01:43:28] <Eridius> benza: you could write `extern "C"` functions in rust, and then use it with any language that supports calling C functions
[01:43:29] <jmgrosen> glyc: I guess that's the way I'll go, then
[01:43:55] <glyc> jmgrosen: caveat: I'm a rust newbie, so my suggestions aren't rust-developer approved
[01:44:19] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[01:44:30] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[01:44:32] <Eridius> jmgrosen: you should file an issue about this
[01:44:49] <jmgrosen> glyc: ok
[01:44:52] <jmgrosen> Eridius: alright
[01:45:20] <benza> Eridius/cmr sounds like the best option until rust web frameworks mature
[01:45:30] <cmr> benza: slash are written at all :P
[01:45:36] <Eridius> jmgrosen: could you use nmedit to remove the symbol?
[01:45:43] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[01:45:52] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[01:45:55] *** Quits: Ralith (ralith@moz-B932C54E.hsd1.wa.comcast.net) (Ping timeout)
[01:45:59] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[01:46:27] <benza> I'm using the web irc client and it's not obvious what actually gets written :)
[01:46:39] * Eridius envisons a hybrid monster, using Go as the web server front-end, Rust as the actual business logic impl, and fake C headers for the Rust code to make Go happy ;)
[01:47:13] <jmgrosen> Eridius: how to use nmedit to delete a symbol?
[01:47:30] <Eridius> jmgrosen: not sure, never used it before. But the name is promising ;) maybe the -R flag?
[01:47:36] <strcat> or just use rust-http, it does work
[01:47:48] <Eridius> strcat: wtb DNS resolution >_<
[01:48:59] <jmgrosen> Eridius: that worked! thanks!
[01:49:03] <Eridius> yay
[01:49:42] <benza> mmmh, the readme says they don't read request bodies yet. Wouldn't get us very far..
[01:50:03] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[01:50:38] <benza> the project looks promising, don't get me wrong. It doesn't seem to be there yet though
[01:50:52] * bjz_ imagines Erlang/Elixir for serer side, Rust for proc gen/user facing game engine, scheme for scripting
[01:50:55] <bjz_> *server
[01:51:03] <cmr> benza: nothing is really there yet :)
[01:51:31] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[01:52:35] <Eridius> bjz_: scheme? not lua?
[01:53:22] <bjz_> h3r3tic: ping
[01:53:30] <bjz_> Eridius: not really a fan of lua
[01:53:32] <benza> cmr: rust is one of the most promising programming languages I've seen in a long time. I wish it was there already :)
[01:53:49] <benza> rust and f#
[01:54:00] <jmgrosen> how is librustrt.{so, dylib} generated?
[01:54:25] <cmr> benza: I agree. what's why I'm a contributor :)
[01:54:32] <cmr> jmgrosen: built from c++
[01:55:20] <jmgrosen> cmr: still? what was with the hype about the runtime in rust, then?
[01:55:32] <cmr> jmgrosen: it doesn't have a lot of code in it.
[01:55:47] <jmgrosen> cmr: ah, ok
[01:55:59] <benza> cmr: nice :) what are you working on? I'm involved in too many things right now but when I get more time, rust is definitely on top of the list for me
[01:56:37] <jmgrosen> cmr: is there a make rule to build just the runtime?
[01:57:01] *** Joins: eholk (eholk@moz-F70D5031.hsd1.in.comcast.net)
[01:57:36] <cmr> jmgrosen: I don't actually know.
[01:57:55] <cmr> benza: various miscellania right now, mostly documentation
[01:58:08] <cmr> Just finished up with the new rustdoc
[01:58:41] *** Quits: eholk (eholk@moz-F70D5031.hsd1.in.comcast.net) (Ping timeout)
[01:58:47] *** Joins: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net)
[01:58:52] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Quit: Gone to save the world!)
[01:59:47] *** Joins: sevvie (sevvierose@moz-8BC5868E.hfc.comcastbusiness.net)
[02:01:35] *** Quits: sevvie (sevvierose@moz-8BC5868E.hfc.comcastbusiness.net) (Ping timeout)
[02:01:46] <benza> besides servo, do we know how committed mozilla is to rust?
[02:02:17] <doublec> I think servo shows mozilla is pretty committed
[02:02:17] <cmr> benza: they pay multiple full-time developers and have more job openings afaik
[02:02:21] <jmgrosen> librustrt.a will be significantly harder to make than libstd.a was :(
[02:03:56] <benza> that's good to know. I had no idea
[02:03:56] <jmgrosen> i'm guessing no one has tried to build a static version of librustrt before?
[02:04:16] <strcat> jmgrosen: well it's going to be killed off soon
[02:04:28] <strcat> there are really not many things in there
[02:04:32] <jmgrosen> strcat: the sooner the better :D
[02:04:36] <cmr> jmgrosen: perhaps you can port the last bit of that code to rust? :D
[02:04:44] <strcat> libuv and jemalloc are already .a files when we stick them in there
[02:04:52] <jmgrosen> cmr: I wish :3
[02:04:55] <strcat> they just need to go in libstd instead
[02:08:08] <Eridius> strcat: if they go in libstd, how does a std-free rust allocate anything?
[02:08:17] <Eridius> or is that a lang item?
[02:08:21] <cmr> it's a lang item
[02:08:51] <Eridius> sigh, I'm not going to be done with WindowsPath by the time I leave on vacation :/
[02:08:55] <strcat> jemalloc overrides the libc symbols anyway
[02:09:04] <strcat> you can remove it without any harm done
[02:11:50] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[02:15:27] *** Joins: dymk_ (dymk@moz-7108CEA7.client.dyn.strong-sf34.as22781.net)
[02:16:06] *** Quits: dymk (dymk@E913D3B5.A6E21E6E.5E500FC7.IP) (Ping timeout)
[02:16:30] <benza> nice meeting you all. thank you cmr, strcat and Eridius for answering my questions
[02:16:36] *** Quits: sebcrozet (sebcrozet@moz-F96421F3.w80-13.abo.wanadoo.fr) (Ping timeout)
[02:18:58] <glyc> I've been looking at the Rust tasks and communication tutorial. I don't see any mention of portmappers or how to specify where to spawn a task. Is the assumption that everything is local to one host, or is there a distributed option somewhere?
[02:19:32] <strcat> glyc: there's not a way to do multiprocessing yet, local or remotely
[02:19:41] <Eridius> glyc: are you an Erlang user?
[02:20:11] <glyc> Eridius: yes
[02:20:18] <glyc> strcat: what do you mean, not locally?
[02:20:33] <strcat> glyc: rust can't do multiprocessing on one machine yet, let alone over a network
[02:20:41] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[02:20:43] <glyc> strcat: everthing is on a single thread?
[02:20:45] <Eridius> everything is local to a single process
[02:20:46] <strcat> no
[02:20:47] <sruggier> single process
[02:22:28] <glyc> ok. I can deal with that. I heard mention of cooperative co-routines... is that what spawn is producing?
[02:23:20] *** Quits: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[02:23:39] <strcat> glyc: rust has support for threading, and also for multiplexing green threads onto OS threads
[02:23:42] <Eridius> they're basically cooperative coroutines layered on top of os threads.
[02:23:55] <strcat> you can mix 1:1 threading or N:M threading
[02:24:01] <mark_edward> is it okay to call test functions recursively?
[02:24:03] <cmr> They are cooperative though: you need to explicitly yield.
[02:24:04] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[02:24:24] <mark_edward> cmr: are you talking to me?
[02:24:30] <cmr> no
[02:24:34] <strcat> cmr: not necessarily
[02:24:49] <strcat> you have a choice between 1:1 and N:M threading
[02:25:11] <glyc> strcat: nice.   cmr:  cooperative, need to call yeild. got it.
[02:25:21] <doublec> or do i/o, right?
[02:25:31] <strcat> that's an explicit yield
[02:25:33] <cmr> doublec: the runtime will yield for you yes.
[02:25:34] *** Joins: Liothen (liothen@moz-80EF0CD7.spkn.qwest.net)
[02:25:38] <cmr> when you call into it.
[02:25:46] <sruggier> same with port/chans, fyi
[02:26:09] <mark_edward> strcat: can functions marked #[test] call themselves recursively?
[02:26:20] <glyc> strcat: how would I request 1000 fibers on 1 thread?
[02:26:24] <strcat> mark_edward: sure
[02:27:12] *** Quits: bytewise (bytewise@moz-4A801D04.unitymediagroup.de) (Quit: Leaving)
[02:27:38] <strcat> glyc: look in the task module, at SchedMode
[02:27:44] <strcat> I don't know how much is implemented with the new runtime
[02:28:02] <Eridius> hrm, in the old task you could create explicit schedulers. In the current task, you can't, you can only control the SchedMode. Seems rather limiting
[02:28:07] <glyc> cool, I see SingleThreaded
[02:28:21] <Eridius> does using SingleThreaded mean every task spawned with that SchedMode goes on the same thread? Is there no way to have 5 tasks on one thread and 7 on another?
[02:28:35] <strcat> Eridius: you can have multiple schedulers
[02:28:39] <strcat> I don't know exactly how the API works
[02:28:44] <Eridius> strcat: but I don't see any way in the API to control that
[02:28:57] <Eridius> .spawn_sched() says it spawns a task on a "new or existing scheduler". But it's opaque
[02:29:44] <Eridius> hrm, some of this documentation is out of date. TaskBuilder.spawn() says "When spawning into a new scheduler, the number of threads requested must be greater than zero". But there's no SchedMode that lets you specify N threads anymore
[02:29:58] * Eridius hopes that this API is unfinished, and that explicit control over schedulers will come b ack
[02:30:00] <sruggier> I think the new rust rt bitrotted that stuff
[02:30:09] <strcat> Eridius: the API is not finished, in fact the module is obsolete
[02:30:19] <strcat> the functionality will be there if it's not now
[02:30:20] <Eridius> oh? it's being replaced outright? interesting
[02:30:31] *** Joins: sevvie (sevvierose@moz-8BC5868E.hfc.comcastbusiness.net)
[02:30:35] <strcat> Eridius: std::rt::task
[02:31:08] *** Quits: benza (Mibbit@moz-99D3664A.c3-0.161-ubr1.lnh-161.md.cable.rcn.com) (Quit: http://www.mibbit.com ajax IRC Client)
[02:32:19] *** Quits: sevvie (sevvierose@moz-8BC5868E.hfc.comcastbusiness.net) (Ping timeout)
[02:33:27] *** Joins: victorporof (victorporo@9D964D4D.36D485C.2B3D3D4.IP)
[02:33:29] <glyc> in libstd/run.rs:361, I see: do task::spawn_sched(task::SingleThreaded) { ... } // the documentation says this creates a whole new scheduler, and executes all subtasks on that scheduler, which would be SingleThreaded in this instance
[02:34:47] <glyc> what kind of profiling tools are available for the coroutines?
[02:35:21] <glyc> e.g. if I'm stopped in the debugger at the (gdb) prompt, can I query the live tasks?
[02:35:34] *** Quits: victorporof (victorporo@9D964D4D.36D485C.2B3D3D4.IP) (Ping timeout)
[02:37:18] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[02:38:05] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[02:38:39] <sruggier> here's some detail on the scheduling options, although it doesn't mention if or when they will come back:
[02:38:39] <sruggier> https://mail.mozilla.org/pipermail/rust-dev/2013-August/005158.html
[02:41:07] <Eridius> I seem to recall that I/O is now threadsafe (at the time of that mail it wasn't)
[02:41:17] <Eridius> is that true or am I misremembering?
[02:42:52] *** Joins: pepper_chico (pepper_chi@EF476D4E.D3DE4871.E4090502.IP)
[02:43:13] *** Quits: kimundi (kimundi@moz-E44663F3.dip0.t-ipconnect.de) (Ping timeout)
[02:43:26] <strcat> Eridius: yes, it's thread-safe now
[02:44:45] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[02:45:36] *** Quits: dymk_ (dymk@moz-7108CEA7.client.dyn.strong-sf34.as22781.net) (Ping timeout)
[02:46:19] *** Joins: kimundi (kimundi@moz-1527D01.dip0.t-ipconnect.de)
[02:46:25] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[02:46:43] *** Quits: Earnestly (earnest@moz-F387F877.dyn.plus.net) (Ping timeout)
[02:51:03] *** kimundi is now known as zz_kimundi
[02:58:04] *** zz_kimundi is now known as kimundi
[02:59:09] <klutzy> is #[abi=...] currently ignored? or it still does something?
[03:01:21] *** Joins: sevvie (sevvierose@moz-8BC5868E.hfc.comcastbusiness.net)
[03:02:46] *** Joins: Ralith (ralith@moz-B932C54E.hsd1.wa.comcast.net)
[03:03:09] *** Quits: sevvie (sevvierose@moz-8BC5868E.hfc.comcastbusiness.net) (Ping timeout)
[03:04:42] <Luqman> klutzy: i think it doesn't do anything
[03:07:06] <Eridius> rusti: fn foo(s: &str) { let s_ = Some(s.to_owned()); let s = s_.map_default(s, |s| s.as_slice()); printfln!(s) } foo(~"test")
[03:07:13] -rusti- pastebinned 11 lines of output: http://ix.io/7LP
[03:07:39] <Eridius> huh, error suggests it already lives for as long as it needs to. Strange
[03:08:14] <Eridius> well the span indicates that. I suspect the lifetime it must be valid for is actually the lifetime of the s arg
[03:08:52] <Eridius> the fun part is that would actually be valid if only I could define a new lifetime that's only valid for that block, and "shrink" s's lifetime, so to speak, to that new one
[03:09:39] *** Quits: Ralith (ralith@moz-B932C54E.hsd1.wa.comcast.net) (Ping timeout)
[03:11:22] <engla> unfoldl: hey
[03:15:41] <Eridius> rusti: fn foo(self: int) { printfln!(self) } foo(3)
[03:15:42] -rusti- <anon>:5:15: 5:16 error: found `self` in ident position
[03:15:42] -rusti- <anon>:5          fn foo(self: int) { printfln!(self) } foo(3)
[03:15:42] -rusti-                         ^
[03:15:42] -rusti- error: aborting due to previous error
[03:15:42] -rusti- application terminated with error code 101
[03:17:47] *** Joins: ChrisMorgan (chris@moz-DBA45701.its.monash.edu.au)
[03:18:18] *** Quits: indirect (indirect_m@moz-22FDA25B.hsd1.ca.comcast.net) (Connection reset by peer)
[03:18:22] *** Joins: Ralith (ralith@moz-B932C54E.hsd1.wa.comcast.net)
[03:20:59] *** Joins: tautologico (lymph@8ABDEDA.34CAB63A.7B974E06.IP)
[03:23:11] *** Joins: indirect (indirect_m@moz-22FDA25B.hsd1.ca.comcast.net)
[03:23:34] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[03:27:48] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[03:29:09] *** Quits: Ralith (ralith@moz-B932C54E.hsd1.wa.comcast.net) (Ping timeout)
[03:31:33] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[03:32:08] *** Joins: sevvie (sevvierose@moz-8BC5868E.hfc.comcastbusiness.net)
[03:32:31] <strcat> rusti: &println
[03:32:33] -rusti- &
[03:32:42] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[03:33:43] *** Joins: Ralith (ralith@moz-B932C54E.hsd1.wa.comcast.net)
[03:33:56] *** Quits: sevvie (sevvierose@moz-8BC5868E.hfc.comcastbusiness.net) (Ping timeout)
[03:34:00] *** Joins: victorporof (victorporo@9D964D4D.36D485C.2B3D3D4.IP)
[03:34:35] *** Quits: pepper_chico (pepper_chi@EF476D4E.D3DE4871.E4090502.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[03:35:35] *** Quits: ChrisMorgan (chris@moz-DBA45701.its.monash.edu.au) (Ping timeout)
[03:36:03] *** Quits: victorporof (victorporo@9D964D4D.36D485C.2B3D3D4.IP) (Ping timeout)
[03:36:35] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[03:37:03] <mark_edward> rusti: &range::<uint>
[03:37:05] -rusti- &
[03:37:46] <mark_edward> rusti: std::sys::size_of::<&fn(int)->int>()
[03:37:46] -rusti- 16u
[03:37:55] <mark_edward> rusti: std::sys::size_of::<&fn()->int>()
[03:37:56] -rusti- 16u
[03:38:05] <mark_edward> rusti: std::sys::size_of::<&fn(~[int])->int>()
[03:38:06] -rusti- 16u
[03:38:16] <mark_edward> rusti: std::sys::size_of::<~fn(~[int])->int>()
[03:38:17] -rusti- 16u
[03:38:22] <mark_edward> rusti: std::sys::size_of::<@fn(~[int])->int>()
[03:38:22] -rusti- 16u
[03:38:33] <mark_edward> all the boxes are the same size?
[03:38:57] *** Joins: Archer (Archer@moz-C36DFA25.bb.online.no)
[03:39:01] <kimundi> they are all implemented as a pointer
[03:39:38] <mark_edward> right, but 64/8 = 8, so what's the extra machine word doing?
[03:39:40] <kimundi> Or, in this case, pair of pointers
[03:39:45] <mark_edward> oh ok
[03:39:54] <kimundi> pointer to function, pointer to environment
[03:39:54] <Eridius> pointer to func, pointer to environment?
[03:39:57] <Eridius> damn
[03:40:08] <kimundi> hehe
[03:40:21] <strcat> mark_edward: a regular function pointer is just 1 word
[03:40:21] <mark_edward> makes sense. i like the C++ function object thing though
[03:40:37] *** Joins: ChrisMorgan (chris@moz-C4237BCA.its.monash.edu.au)
[03:40:40] <mark_edward> strcat: you mean an `extern &fn`
[03:40:43] <mark_edward> ?
[03:40:49] <strcat> extern fn, a regular function
[03:40:53] <strcat> fn foo() {} is an extern fn
[03:41:10] <strcat> a closure is a function + an environment, thus the two pointers
[03:41:40] <mark_edward> ah i see. where you there when this structure for closures was developed?
[03:41:56] <strcat> no
[03:42:10] <mark_edward> is it easier than C++'s method?
[03:42:29] <strcat> it is C++'s method
[03:42:33] <strcat> std::function is like ~fn
[03:42:36] <cmr> I don't see any good way to implement it besides a pair of pointers
[03:42:42] <strcat> rust doesn't have unboxed closures though
[03:43:07] <bjz> rusti: std::sys::size_of::<extern fn()>()
[03:43:08] -rusti- 8u
[03:43:12] <strcat> I have a proposal open for them, but I don't really see it happening for 1.0
[03:43:18] <bjz> rusti: std::sys::size_of::<&fn()>()
[03:43:19] -rusti- 16u
[03:43:23] <bjz> neat!
[03:43:39] * bjz understands abit more
[03:43:49] <mark_edward> i meant like the whole naked function object thing, where it compiles into a struct with a call method, and captured vars as members
[03:44:20] <strcat> as I said, I have a proposal open for adding unboxed closures via monomorphization
[03:44:30] *** Quits: Sorella (queen@9D963F5D.DF5D8AE7.54BCAB54.IP) (Quit: G'night everynyan~!)
[03:44:44] <strcat> and treating 'fn(int, int) -> bool' as essentially a trait-like type bound
[03:44:52] <mark_edward> do you know why they don't use that method for std::function?
[03:45:02] <strcat> std::function is a boxed closure
[03:45:05] <mark_edward> and can i have a link to your proposal?
[03:45:11] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[03:45:23] <mark_edward> right, why can't it just be pointer to an unboxed one?
[03:45:25] <strcat> without std::function, you have to specialize for every single function object you pass
[03:45:47] <strcat> mark_edward: that's what a boxed closure is, it's a pointer to an unboxed closure environment and a function pointer
[03:46:05] *** Joins: sapp (Mibbit@moz-3868657C.cpe.netcabo.pt)
[03:46:11] <strcat> it needs the function pointer because the object doesn't contain a function pointer, it just has a method associated with it letting you call it
[03:46:51] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[03:46:51] <mark_edward> why couldn't the compiler just desugar calling the object into calling that method? like C++ operator()
[03:47:01] <strcat> it no longer knows the type
[03:47:11] <strcat> std::function<int(int, int)> is a type
[03:47:19] <strcat> it doesn't know the concrete type of the boxed closure
[03:47:34] <strcat> that's why std::function exists, to box a closure so that you don't need to specialize for each possible kind
[03:47:44] <strcat> each closure has a unique type
[03:48:08] <mark_edward> ah i get it now. do box closures have performance drawbacks?
[03:48:10] <strcat> when boxed in std::function, they can be used as a single type
[03:48:16] <strcat> mark_edward: yes, that's the point of them
[03:48:27] <Amanieu> std::function also has pointers to a few other functions (copy constructor, destructor)
[03:48:29] <strcat> instead of specialization for each type, you box it
[03:48:36] <strcat> Amanieu: yes, similar to rust's traits
[03:48:38] <mark_edward> strcat: to have perfformance drawbacks???
[03:48:41] <strcat> mark_edward: yes.
[03:48:53] <strcat> it trades performance for smaller code size
[03:48:57] <strcat> that's the intent
[03:49:02] <strcat> rust's trait objects are the same way
[03:49:06] <mark_edward> i thought that was just a side effect. rather than the point
[03:49:15] <sapp> how can i use .map on a string? if i have:  let name = ~"john"; let name = name.map(|c| 'a'); it says "~str does not implement any method in scope named map" also on the documentation it says the map function takes a string as first argument but std::str::map(..) or str::map(..) doesnt work either
[03:49:16] <strcat> it's why it exists, to trade performance for code size
[03:49:36] <strcat> sapp: map is a default method on iterators
[03:49:47] <strcat> mark_edward: rust gives you the same choice with traits
[03:49:49] <strcat> you can do
[03:49:59] <strcat> fn foo<A: Foo>(x: A) { ... }
[03:50:01] <strcat> or you can do
[03:50:17] <strcat> fn foo(x: ~Foo) { ... }
[03:50:26] <strcat> as a type bound, it has to specialize the function for each set of types
[03:50:41] <strcat> as a trait object, it *must* be boxed, *and* it will do indirect virtual calls
[03:50:47] *** Quits: Ralith (ralith@moz-B932C54E.hsd1.wa.comcast.net) (Ping timeout)
[03:50:55] <strcat> it's the same tradeoff
[03:50:56] <Eridius> rusti: let name = "john". name.iter().map(|c| 'a').collect::<~str>()
[03:50:57] -rusti- <anon>:6:4: 6:5 error: expected `;` but found `}`
[03:50:57] -rusti- <anon>:6     };
[03:50:57] -rusti-              ^
[03:50:57] -rusti- application terminated with error code 101
[03:51:04] <Eridius> rusti: let name = "john"; name.iter().map(|c| 'a').collect::<~str>()
[03:51:04] -rusti- <anon>:5:45: 5:46 warning: unused variable: `c` [-W unused-variable (default)]
[03:51:05] -rusti- <anon>:5          let name = "john"; name.iter().map(|c| 'a').collect::<~str>()
[03:51:05] -rusti-                                                       ^
[03:51:05] -rusti- ~"aaaa"
[03:51:06] *** Quits: samx (sami@moz-D9DA5773.dyn.optonline.net) (Quit: This computer has gone to sleep)
[03:51:26] <strcat> a unique unboxed closure type requires specialization for each one, and you can't do something like store 5 different closures in a vector
[03:51:45] <strcat> boxing them as std::function erases the type
[03:51:57] <strcat> it's an entirely transparent tradeoff - it's as intended
[03:52:29] <mark_edward> ah this makes perfect sense now.
[03:52:32] <strcat> anyway rust currently only has boxed closures, so I opened an issue proposing that we support uniquely typed unboxed ones and make them more trait-like
[03:52:33] <sapp> but why does it work on vector then? like vector.map but not on strings?
[03:52:38] <mark_edward> you are a good explainer
[03:52:42] <strcat> sapp: the map method on vectors is deprecated
[03:53:33] <strcat> rusti: range(0, 3).map(|x| x * 2).to_owned_vec()
[03:53:33] -rusti- ~[0, 2, 4]
[03:53:44] <strcat> range() returns an iterator, and both vec/str have several iterators
[03:55:00] <mark_edward> rusti: range(0, 3).map(|x| x * 2).collect::<~[uint]>()
[03:55:07] -rusti- pastebinned 14 lines of output: http://ix.io/7LS
[03:55:42] <mark_edward> rusti: range(0, 3).map(|x| x * 2).collect::<~[int]>()
[03:55:44] -rusti- ~[0, 2, 4]
[03:55:53] <mark_edward> what's the difference?
[03:56:05] *** Joins: Ralith (ralith@moz-B932C54E.hsd1.wa.comcast.net)
[03:56:10] <strcat> rusti: range(0u, 3).map(|x| x * 2).collect::<~[uint]>()
[03:56:11] -rusti- ~[0u, 2u, 4u]
[03:56:24] <strcat> mark_edward: the inference doesn't work that well
[03:56:36] <mark_edward> yeah, that is annoying
[03:56:43] <strcat> and the generic literals fall back to `int`, which is silly
[03:57:27] <mark_edward> btw why do we have to go collect::<~[int]> instead of collect<~[int]>? doesn't seem... necessary
[03:57:45] *** Quits: Ralith (ralith@moz-B932C54E.hsd1.wa.comcast.net) (Ping timeout)
[03:57:46] *** Quits: ChrisMorgan (chris@moz-C4237BCA.its.monash.edu.au) (Ping timeout)
[03:57:46] <strcat> to keep the grammar from being ambiguous
[03:57:48] <Eridius> mark_edward: because collect<~[int]> is trying to do a less-than operation
[03:58:07] <Eridius> you could also just say .collect() and rely on constraining the return tyupe
[03:58:12] <strcat> C++ cannot actually be tokenized or parsed in separate steps from type checking
[03:58:13] <Eridius> or use .to_owned_vec() which always returns a ~[T]
[03:58:22] <strcat> well, it can't be tokenized at all
[03:58:45] <strcat> anyway the C++ compiler actually has to resolve turing-complete type system problems before parsing can be fully finished
[03:58:48] <mark_edward> i see. what about in type signatures though? why isn't HashSet<int> confused?
[03:58:52] <sruggier> I must have missed it in the tutorial or whatever, but the first time I needed to ::<> something, I was pretty confused for a couple of minutes
[03:58:57] <strcat> mark_edward: because it's not an expression
[03:59:12] <strcat> you can't use <, >, <<, >> in types
[03:59:19] <sapp> type `std::str::StrCharIterator<>` does not implement any method in scope named `map` i get that error
[03:59:31] <sapp> when i try with the collect
[03:59:33] <strcat> sapp: well, it does
[03:59:40] <strcat> maybe you're not on an up-to-date rust
[03:59:45] <sapp> maybe because im using 0.7?
[03:59:47] <strcat> yes
[03:59:55] <sapp> oh ok
[04:00:11] <sapp> thanks
[04:00:14] <mark_edward> do you think Rust compile speeds could be as fast as Go or D?
[04:00:14] <Eridius> in 0.7 it was called .transform()
[04:00:36] <strcat> mark_edward: as fast as D's LLVM implementation, sure
[04:00:44] <strcat> they probably already are comparable
[04:01:23] <strcat> Go's compilers aren't optimizing compilers and the language is designed to be compiled fast by leaving out many features
[04:01:29] <strcat> so no, rust will never compile as fast as it
[04:01:49] <mark_edward> Go isn't optimized?
[04:02:02] *** Quits: acrichto (acrichto@moz-17CABEB0.wv.cc.cmu.edu) (Ping timeout)
[04:02:16] <strcat> the Go compilers aren't optimizing compilers, they still try to generate reasonable machine code as they go along
[04:02:35] <strcat> and gcc has a Go frontend, so ofc that does optimize, and it compiles slower than rust
[04:03:07] <mark_edward> i see
[04:03:17] <strcat> LLVM and gcc spend almost all their time in optimization passes
[04:03:21] *** Joins: sfackler_ (sfackler@moz-AEECCEBA.com)
[04:03:27] <strcat> the frontend is pretty insignificant in the time to compile, except with optimization off
[04:04:26] <mark_edward> is it ever in the future to write a rust compiler from the top-down like DMD?
[04:04:37] <strcat> doubt it, not really a point
[04:04:38] *** Quits: sfackler (sfackler@moz-316FE70F.compute-1.amazonaws.com) (Quit: quit)
[04:04:53] <strcat> dmd's frontend is shared by the LLVM/gcc implementations of D
[04:05:15] <strcat> there's close to no point of the dmd backend existing now, they should really standardize on the LLVM one imo
[04:05:42] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[04:05:47] <strcat> so it can be fully free software + compete with C++ with the reference implementation
[04:05:50] <mark_edward> doesn't dmd provide the fastest compile times? a lot of blogs like to complain about compile times
[04:05:53] *** sfackler_ is now known as sfackler
[04:06:23] <strcat> it probably compiles faster than LLVM since the code is much less optimized
[04:06:32] *** Quits: StarLight (StarLight@moz-4851C66E.dynamic.avangarddsl.ru) (Ping timeout)
[04:06:53] <mark_edward> yeah. how did pascal/turbopascal compile so fast?
[04:07:04] <andrew-d> mark_edward: one-pass compiler :)
[04:07:08] <andrew-d> pascal is designed for that :)
[04:07:09] *** Joins: Ralith (ralith@moz-B932C54E.hsd1.wa.comcast.net)
[04:07:16] <strcat> by not being modern optimizing compilers like LLVM/gcc
[04:07:26] <andrew-d> strcat: yeah, that too :P
[04:07:30] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[04:07:54] <strcat> tcc compiles quickly, it also generates terrible code. ;p
[04:08:07] <mark_edward> what is tcc?
[04:08:11] <strcat> tiny c compiler
[04:08:20] <mark_edward> and yeah i guess not optimizing helps a lot.
[04:08:31] <strcat> not optimizing means you don't need an intermediate representation
[04:08:35] <strcat> no analysis
[04:08:38] *** Quits: sapp (Mibbit@moz-3868657C.cpe.netcabo.pt) (Quit: http://www.mibbit.com ajax IRC Client)
[04:08:49] <strcat> you just read through the code and spit out assembly in one-pass, with a language like Go
[04:08:58] <strcat> that's exactly what the Go compilers do.
[04:09:20] <andrew-d> Hokay, everyone: here's something I quickly threw together, mostly for personal use.  It's a search for error messages that Rust throws out, along with example code and an example solution.  Hopefully it's helpful to be able to see examples of code that throws an error, and how to solve it: http://rust.dunham.io/
[04:09:24] <mark_edward> why do we need to optimize so much though? stuff used to be really fast back in the day w/o optimizing compilers
[04:09:34] <andrew-d> Type "illegal" in the search box for a demo
[04:09:49] <andrew-d> (Only 1 thing there so far, so if anyone wants the admin password to add more, lemme know)
[04:09:55] <strcat> mark_edward: because no one is going to use rust if it's 2-10x slower than C compiled with a modern compiler
[04:10:05] <strcat> it runs the same optimization passes as clang
[04:10:14] <strcat> if you don't want to optimize, you don't have to
[04:10:23] <Eridius> andrew-d: it's not doign anything
[04:10:25] *** Joins: StarLight (StarLight@moz-644D52BA.dynamic.avangarddsl.ru)
[04:10:27] <strcat> we have --opt-level and the ability to specify llvm passes yourself
[04:10:59] <mark_edward> strcat: right i know, but i mean in general. software seems a lot slower than when i was younger. i've had MSword hang on me. what's happening?
[04:11:00] <Eridius> ok now it's working intermittently
[04:11:21] <andrew-d> Eridius: yeah, my server isn't super-fast.  Optimization will come in a bit :P
[04:11:23] <strcat> mark_edward: everything seems perfectly fast to me
[04:11:35] <strcat> and my computer uses 80MiB fully booted up into a graphical environment
[04:11:37] * strcat shrugs
[04:11:41] <mark_edward> you don't use eclipse enough
[04:11:41] *** Joins: ChrisMorgan (chris@moz-C4237BCA.its.monash.edu.au)
[04:11:53] <strcat> poorly written software is slow and crashes a lot
[04:12:06] <strcat> that applied 20 years ago and will apply 50 years from now ;p
[04:12:29] <Eridius> strcat: a whole 80MiB? Wow! I thought 64KiB was more than enough for anyone
[04:12:51] <mark_edward> yeah. im to young to be complaiing about stuff like that anyway. when i think of all the abstraction layers in place now though it does seem a bit troubling
[04:12:55] <glyc> mark_edward: yeah, Eclipse...lol
[04:13:01] <strcat> Eridius: yeah and it takes a whole 1800ms to boot - ridiculous right? feels like forever.
[04:13:22] *** Quits: ChrisMorgan (chris@moz-C4237BCA.its.monash.edu.au) (Ping timeout)
[04:13:23] <Eridius> that's a whole 1800000us!
[04:13:26] <mark_edward> my computer takes like 5 min to boot... ridiculous
[04:13:32] <strcat> ssd + systemd <3
[04:13:38] <glyc> one day, instead of re-writing UIs in java, they'll be re-written in Rust, and Fly Like Eagles
[04:13:41] <andrew-d> strcat: What distro are you running?
[04:13:45] <mark_edward> arch
[04:13:53] <strcat> andrew-d: doesn't really matter which distro it is though
[04:14:02] <strcat> they all boot at around the same speed, with the same software installed
[04:14:09] <mark_edward> glyc: that will be the day
[04:14:23] <fread2281> strcat: well ubuntu has lots of services
[04:14:28] <mark_edward> strcat: well the installed software is what defines the distros isn't it? that and the repos
[04:14:35] <strcat> fread2281: and a slow init system
[04:14:41] <strcat> it's mostly that.
[04:14:42] <glyc> mark_edward: it does seem perfect for UI code, does it not?
[04:14:49] *** Quits: Ralith (ralith@moz-B932C54E.hsd1.wa.comcast.net) (Ping timeout)
[04:14:55] <strcat> mark_edward: the installed software is totally up to the user on most distros
[04:15:11] <mark_edward> glyc: yup. i want QT ported to Rust. can you handle it?
[04:15:25] <strcat> if you're comparing performance, you need to install the same software on each
[04:15:26] <glyc> mark_edward: heh... coming right up
[04:15:36] <tiffany> I'm still not sure how to write a generalized FRP system in rust
[04:15:51] <glyc> tiffany, what is FRP?
[04:15:57] <tiffany> functional reactive programming
[04:15:57] <strcat> and you'll find there's almost no inherent differences in performance between them, just differences in which versions of software they package and which patches they apply
[04:16:15] <mark_edward> strcat: right, but isn't that really what defines distros?
[04:16:19] <tiffany> it is a way to cleanly express complex systems such as GUIs or network state machines and other event-heavy systems
[04:16:37] <mark_edward> tiffany: know any good tutorials?
[04:16:40] <glyc> tiffany, I vaguely recall that, does it just mean passing closures around to respond to UI events?
[04:16:43] <strcat> mark_edward: yes, they're a set of packages at N version with X and Y patches applied
[04:16:47] <tiffany> elm-lang.org has some good ones
[04:17:06] <tiffany> glyc: no, that is continuation passing, and it is what frp intends to make cleaner
[04:17:37] <mark_edward> what does FRP do differently then?
[04:17:52] * strcat needs a way to get a type name from a tydesc
[04:17:58] <tiffany> you don't have nested callbacks
[04:18:02] <tiffany> it makes them linear
[04:18:22] <tiffany> it also works more functionally
[04:19:07] <tiffany> you can have a function which takes a discrete event, such as a function to create a drawing of a clock for a certain second, and then lift it onto a signal to produce a function of that function over time, in that example creating an animation of a clock
[04:19:36] *** Joins: Ralith (ralith@moz-B932C54E.hsd1.wa.comcast.net)
[04:19:39] <tiffany> people seem to have trouble understanding its utility compared to events or futures
[04:20:14] <mark_edward> tiffany: souunds pretty cool actually. build it for Rust!
[04:20:29] <tiffany> I did try earlier before I had a better grasp of lifetimes and failed
[04:20:53] <glyc> tiffany, what does "lift it into a signal" mean specifically?
[04:20:59] <tiffany> one problem I ran into is that if you have a signal of A -> B, you need to be able to store signals of B -> C to update them, but C may vary per signal
[04:21:08] <mark_edward> tiffany: if you try again let me know and i'llwatch your repo, and contribute if i can
[04:21:27] <tiffany> glyc: it's an operation of FRP, lift takes a function and a signal and creates a signal of that signal with the function applied, kind of like map()
[04:21:50] <mark_edward> do you need functors? you can't make true functors in rust i think...
[04:22:24] <mark_edward> that sounds like an application of fmap to em
[04:22:26] <mark_edward> *me
[04:22:36] <tiffany> I don't think so
[04:23:34] <glyc> tiffany: all I know about GUI construction is that the Model-View split should be religiously observed, so you can test efficiently. Does FRP support model-view separation?
[04:24:01] <tiffany> the "model" is the function being lifted, and the "view/controller" is the signal itself
[04:25:05] <glyc> tiffany: ugh, new terminology makes my head hurt. Could we phrase things in terms of functions, messages, message queues, callback, ... these terms I understand. Signal means nothing.
[04:25:32] <tiffany> signals are an abstraction over events
[04:25:46] <glyc> what is the input and output of a signal?
[04:25:55] <tiffany> the input is a signal, and the output is a signal
[04:26:31] <tiffany> a signal contains a series of discrete events, and I'm pretty sure you could implement Applicative for a signal
[04:26:40] <glyc> tiffany: can I represent a signal as a function?
[04:26:51] <tiffany> uhh
[04:27:00] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[04:27:03] <photex> hi folks, I have some "just getting started" type questions if nobody minds
[04:27:12] <tiffany> you can create a signal from a function, but I'm not really sure what you meant
[04:27:22] <photex> first up, can function arguments have default values?
[04:27:43] * photex hasn't seen anything to suggest this... but was curious
[04:27:52] <kimundi> nope
[04:28:02] <mark_edward> photex: no. you could have something like Option<Int> and then match on it and supply your own defaults
[04:28:13] <kimundi> but that hasn't been finally decided yet
[04:28:35] <photex> hrm... I like Options, but I'll hold off on using it then
[04:28:40] * fread2281 really wants default arguments
[04:28:47] * mark_edward too
[04:28:51] <photex> second question is how to understand some of the docs
[04:28:52] <glyc> tiffany: I mean (writing in C++ for the moment, my Rust is not yet fluent): struct Signal { Signal* execute(Signal* input); } // is this a necessary and sufficient model of a signal?
[04:29:16] <photex> std::vec appears to have a function or method 'each' but I haven't been able to use it
[04:29:20] <photex> and traits
[04:29:22] <photex> ..
[04:29:30] <photex> such as std::num min and max and clamp
[04:29:31] *** Quits: Ralith (ralith@moz-B932C54E.hsd1.wa.comcast.net) (Ping timeout)
[04:29:41] <strcat> photex: I highly recommend using master, not 0.7
[04:29:42] <photex> I'm not sure how I "get at" those for a float for instance
[04:29:48] <photex> strcat: ah
[04:29:52] <strcat> `each` is long gone, as is that old iteration protocol
[04:29:56] <photex> ok
[04:30:23] <photex> I've landed on points.tail().iter().advance
[04:30:24] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[04:30:32] <photex> by way of seeing an example of that in the tutorial
[04:30:53] <photex> but it worried me because I didn't find it evident by looking at docs
[04:31:09] <photex> likewise for min, max, and clamp etc
[04:31:16] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[04:31:23] <fread2281> photex: well on master it's just points.tail().iter()
[04:31:24] <photex> so I'll go build master and see how I fare
[04:31:27] <strcat> photex: the iter function is documented in the vector module
[04:31:31] <glyc> photex: I'm new to this, and I find grepping through the source of libstd and libextra quite informative
[04:31:37] <strcat> and you'll see that it returns an implementation of the std::iterator::Iterator trait
[04:31:40] <strcat> which is documented there
[04:31:44] <strcat> photex: http://seld.be/rustdoc/master/std/iterator/index.html
[04:32:12] <photex> well, hello rustdoc
[04:32:25] <tiffany> glyc: what you'd want to do is have a struct Signal<T,U> {signals_to_update: ~[~fn(U)], func: ~fn(T) -> U} impl<T,U> Signal<T,U> {fn update(&self, val: T) {let newval = self.update(val); for f in self.signals_to_update.iter() {f(newval);}}
[04:32:31] <tiffany> I think
[04:32:32] <strcat> photex: http://seld.be/rustdoc/master/std/iterator/trait.Iterator.html that's the important trait
[04:32:37] <tiffany> I also think I forgot a }
[04:33:07] <bjz> rusti: struct A(int); A(1) + 1
[04:33:08] -rusti- <anon>:5:24: 5:32 error: binary operation + cannot be applied to type `main::A`
[04:33:08] -rusti- <anon>:5          struct A(int); A(1) + 1
[04:33:08] -rusti-                                  ^~~~~~~~
[04:33:09] -rusti- error: aborting due to previous error
[04:33:09] -rusti- application terminated with error code 101
[04:33:55] *** Joins: Ralith (ralith@moz-B932C54E.hsd1.wa.comcast.net)
[04:34:18] <strcat> photex: the old rustdoc is being replaced, because it's worse than just looking at the code ;p
[04:34:20] <fread2281> rusti: struct A(int); A(1).add(1)
[04:34:20] -rusti- <anon>:5:33: 5:34 error: mismatched types: expected `&int` but found `<VI1>` (expected &-ptr but found integral variable)
[04:34:20] -rusti- <anon>:5          struct A(int); A(1).add(1)
[04:34:21] -rusti-                                           ^
[04:34:21] -rusti- error: aborting due to previous error
[04:34:21] -rusti- application terminated with error code 101
[04:34:32] <fread2281> rusti: struct A(int); A(1).add(&1)
[04:34:33] -rusti- 2
[04:34:37] *** Joins: victorporof (victorporo@9D964D4D.36D485C.2B3D3D4.IP)
[04:34:45] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[04:35:06] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[04:35:06] <photex> strcat: I didn't want to criticize ;) But yeah... these new docs are so much better
[04:35:31] <photex> thank you for all the help, I'll return to emacs for a while
[04:35:48] <glyc> tiffanry: ok, that makes sense
[04:36:26] <glyc> tiffany: that looks like D code, does that not work?
[04:36:36] <tiffany> it's meant to be rust code
[04:36:39] <glyc> err sorry, looks like Rust code
[04:36:41] *** Quits: victorporof (victorporo@9D964D4D.36D485C.2B3D3D4.IP) (Ping timeout)
[04:36:42] <tiffany> but I would be unsurprised if it didn't work
[04:36:53] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[04:36:57] <glyc> tiffany: where were you having difficult?
[04:37:02] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[04:37:08] <tiffany> I don't really remember, it was a couple weeks ago
[04:37:26] <glyc> tiffany: well, I'll give it go here, just sec...
[04:37:52] <tiffany> oh, I think the problem was I needed to be using @
[04:38:05] <tiffany> because of signals with multiple input signals
[04:38:13] *** Joins: valenting (Thunderbir@8758046C.84D5EFD5.FB866788.IP)
[04:38:32] <tiffany> I was having great difficulty implementing lift2
[04:39:39] <tiffany> I guess I'll have another go at it tomorrow
[04:41:14] *** Joins: sonwow (sonwow@5AB4884B.FCC4549.14D5B978.IP)
[04:42:09] *** Quits: DasIch (dasich@moz-5EDA591.de) (Ping timeout)
[04:45:38] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[04:47:11] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[04:47:18] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[04:47:22] *** Quits: valenting (Thunderbir@8758046C.84D5EFD5.FB866788.IP) (Ping timeout)
[04:48:34] <olsonjeffery> #8645 reverted ;_;
[04:49:08] <Eridius> olsonjeffery: yeah, it was causing crashes
[04:50:25] <mark_edward> http://seld.be/rustdoc/master/std/option/index.html doesn't seem to list the methods on the Option type, i can't find them
[04:51:16] <glyc> tiffany: still trying to get this to compile, almost there...
[04:51:19] <Eridius> you're right. It also doesn't list what traits Option implements. cmr, Seldaek: ^
[04:54:13] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[04:54:27] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[04:55:57] <glyc> tiffany: okay, got it going http://mibpaste.com/NnBgIL 
[04:57:22] <tiffany> forcing ints?
[04:58:40] <glyc> tiffany: just simplified it. 
[04:58:59] <glyc> should be easy to parameterize now that it compiles
[04:59:53] <glyc> tiffany: I think the only tricky part would be if a child in the tree needs to point back to her parent
[05:00:26] <tiffany> lift2 is pretty difficult to implement because it's synchronous
[05:00:36] <tiffany> it doesn't update the signal until all of the signals it is built on have updated
[05:00:49] <tiffany> unless one of them is an asynchrnous signal, in which case that one doesn't have to update
[05:01:25] <glyc> tiffany: that means just doing depth first search on the tree
[05:01:55] <tiffany> you can't search the tree because multiple types are at hand, thus the list of functions rather than list of signals
[05:02:05] *** Joins: eatkinson (eatkinson@moz-261EDE03.hsd1.ca.comcast.net)
[05:02:23] <tiffany> the way I was doing it was with two closures that talk to each other
[05:02:24] <glyc> tiffany: ??
[05:03:24] <glyc> tiffany: visitor pattern
[05:04:20] <glyc> tiffany: if you really need double dispatch, but I'm not sure that's even really necessary here
[05:04:48] <tiffany> signals built from multiple signals are very important when writing frp applications
[05:05:03] <tiffany> otherwise it's just composition of operations
[05:05:43] <glyc> I'm still stuck on the 'can't search the tree' part. could you elaborate what is difficult there?
[05:06:31] <tiffany> glyc: you can't have a Signal<T,U> that contains Signal<U,V>'s where V varies for each instance of a signal it contains without some kind of runtime code, which I don't know of any way to do in rust
[05:06:49] <tiffany> I mean I guess you could use enums but that limits the types that can be used
[05:07:31] <glyc> tiffany: okay, slow down for me... U is inputs, V is outputs?
[05:07:38] <tiffany> yeah
[05:07:57] <glyc> and why do the outputs need to vary?
[05:08:35] <tiffany> that's like asking why you can't write a map function with the output type being the same as the input type
[05:08:46] <glyc> indeed
[05:08:48] *** Joins: mib_cc56me (Mibbit@moz-ACC86400.services.adelaide.edu.au)
[05:09:03] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[05:09:07] <Eridius> rusti: "".split_iter('a').to_owned_vec()
[05:09:09] -rusti- ~[""]
[05:09:32] <glyc> tiffany: I'm just observing that if you don't have a driving use for the complexity, then keep it simpler
[05:09:47] <glyc> YNGTNI, etc
[05:10:07] <tiffany> many of the examples on elm-lang.org use that kind of functionality
[05:10:17] <tiffany> a very common use is to limit the sampling rate of a signal
[05:11:11] <tiffany> as for multiple types, a very obvious example is writing any kind of network code: you're not chaining the same type over and over again
[05:11:44] *** Quits: mib_cc56me (Mibbit@moz-ACC86400.services.adelaide.edu.au) (Quit: http://www.mibbit.com ajax IRC Client)
[05:11:51] *** Joins: victorporof (victorporo@9D964D4D.36D485C.2B3D3D4.IP)
[05:13:45] <tiffany> if I wanted to write something to specifically suffice for writing FRP code, I could implement it manually as others have done successfully
[05:13:53] *** Joins: nsf (nsf@moz-EEF3238A.convex.ru)
[05:14:59] <glyc> I thought the point was to allow composition. Do you want the composition of the tree to be typechecked at compile time or run time?
[05:15:16] <tiffany> if I wanted to do composition I would be calling them elements
[05:15:33] <glyc> composition of signals
[05:15:55] <tiffany> er, calling them pipelines
[05:15:56] <tiffany> uhh
[05:15:59] <jeaye> Why does %? output units now? :(
[05:16:05] <tiffany> well, I want to have a graph of signals, rather than a line
[05:16:15] <tiffany> anyway, I need to go to bed
[05:16:16] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[05:16:21] <jeaye> Is there a similar specification for the old functionality without the suffixed units?
[05:16:22] <glyc> cheerio
[05:16:44] <jeaye> rusti: fmt!("%?", 5)
[05:16:46] -rusti- ~"5"
[05:17:08] <jeaye> rusti: let f: f32 = 0.0; fmt!("%?", f)
[05:17:09] -rusti- ~"0f32"
[05:17:20] <strcat> jeaye: no, %? is reflection for debugging
[05:17:27] <glyc> jeaye: let i = 23; fmt!("%d", i)
[05:17:32] <strcat> use the new format
[05:17:39] <jeaye> strcat: What's that?
[05:17:50] <strcat> rusti: format!("{} {} {}", 5, 5u, 10u16)
[05:17:51] -rusti- ~"5 5 10"
[05:17:58] <strcat> rusti: format!("{:?} {:?} {:?}", 5, 5u, 10u16)
[05:17:59] -rusti- ~"5 5u 10u16"
[05:18:13] <jeaye> Fancy. Sort of reminds me of boost::format
[05:18:17] <strcat> ? corresponds to repr (same as %?) and is *not* a stable output format
[05:18:24] <strcat> in fact I am changing it right now
[05:18:26] <strcat> ;p
[05:18:34] <strcat> jeaye: also, println! and print!
[05:18:36] <strcat> are the new format
[05:18:41] <jeaye> ah
[05:18:42] <jeaye> Thanks, mate
[05:18:50] <jeaye> Is there a doc on this?
[05:18:57] <jeaye> Or just mailing list entries?
[05:18:57] <strcat> also, things like this
[05:19:06] <strcat> rusti: format!("{0} {1} {0}", 5, 2)
[05:19:07] -rusti- ~"5 2 5"
[05:19:12] <strcat> jeaye: no docs yet afaik
[05:19:17] <jeaye> mmk
[05:19:19] <strcat> but the old one will be removed at some point
[05:19:42] <jeaye> will format! become fmt! when that happens?
[05:19:46] <strcat> yeah, I think so
[05:20:07] <strcat> jeaye: also, it's able to write to a writer
[05:20:18] <strcat> so you can format to a string, or directly to output without needing extra allocs
[05:20:42] <glyc> rusti: format!("{} {}", "can be a string?", 10)
[05:20:43] -rusti- ~"can be a string? 10"
[05:20:51] <strcat> it's trait-based
[05:21:00] <strcat> it can be any type implementing the formatting trait(s)
[05:21:34] <strcat> and if there's no impl, you can always use the ? format specifier to get reflection
[05:22:06] <glyc> niice
[05:22:40] *** Quits: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net) (Ping timeout)
[05:23:03] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[05:23:23] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[05:24:34] *** Joins: tgummerer (tgummerer@moz-5DC8FA44.tbcn.telia.com)
[05:25:11] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[05:25:39] <strcat> hm
[05:25:47] <strcat> need to check if a ty_struct is a tuple struct or not...
[05:27:45] <strcat> rusti: struct Foo { __field__: int }
[05:27:46] -rusti- ()
[05:27:49] <strcat> that's annoying ;[
[05:27:51] <strcat> hm
[05:27:53] <jeaye> rusti: format!("\\2 '{}'", 5)
[05:27:54] -rusti- <anon>:5:17: 5:27 error: invalid escape character `2`
[05:27:54] -rusti- <anon>:5          format!("\\2 '{}'", 5)
[05:27:54] -rusti-                           ^~~~~~~~~~
[05:27:54] -rusti- error: aborting due to previous error
[05:27:54] -rusti- application terminated with error code 101
[05:27:57] <jeaye> :(
[05:28:31] <strcat> "\\2"
[05:28:34] <strcat> rusti: "\\2"
[05:28:35] -rusti- "\\2"
[05:28:37] <strcat> probably a bug
[05:28:41] <jeaye> rusti: fmt!("\\2 '%d'", 5)
[05:28:42] -rusti- ~"\\2 \'5\'"
[05:28:49] <jeaye> Damnit
[05:28:51] <strcat> I guess you have to pass it as a str for now
[05:28:59] <strcat> should be reported though
[05:29:08] <jeaye> I use those escape sequences as markup for text coloring.
[05:29:11] <strcat> rusti: format!("{}", "\\2")
[05:29:12] -rusti- ~"\\2"
[05:29:52] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[05:30:12] <bjz> rusti: format!("{:s}", "\\2")
[05:30:13] -rusti- ~"\\2"
[05:30:17] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[05:30:37] <bjz> rusti: print!("{}", "\\2")
[05:30:37] -rusti- \2()
[05:30:42] <bjz> ah
[05:31:26] <bjz> jeaye: ping
[05:31:38] <strcat> hm
[05:31:54] <jeaye> ticketed
[05:31:59] <jeaye> bjz: pong
[05:32:04] <bjz> https://github.com/bjz/glfw-rs/blob/master/src/glfw/lib.rs#L505
[05:32:18] <bjz> jeaye: wrapped the Key modifiers
[05:32:28] <jeaye> Ah, this is good.
[05:32:34] <bjz> :)
[05:33:50] <bjz> jeaye: do you do any testing on windows?
[05:33:52] <jeaye> rusti: format!("\\2")
[05:33:52] -rusti- <anon>:5:17: 5:22 error: invalid escape character `2`
[05:33:53] -rusti- <anon>:5          format!("\\2")
[05:33:53] -rusti-                           ^~~~~
[05:33:53] -rusti- error: aborting due to previous error
[05:33:53] -rusti- application terminated with error code 101
[05:34:05] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[05:34:09] <jeaye> bjz: I have not yet, but I'll need to eventually.
[05:34:16] <bjz> jeaye
[05:34:18] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[05:34:20] * jeaye has no Windows machines.
[05:34:23] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[05:34:32] <bjz> jeaye: h3r3tic was saying there was an issue with calling conventions
[05:34:46] *** Joins: squiddy (squiddy@moz-CB1FFF0E.adsl.alicedsl.de)
[05:35:04] <bjz> jeaye: I think we might need to set the gl calls to extern "C stdcall" fn
[05:35:31] <jeaye> ah
[05:35:47] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[05:35:47] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/Fe-5Pg
[05:35:47] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[05:35:48] <bjz> and it will choose the best, according to nmatsakis
[05:35:48] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[05:35:48] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/weUAbA
[05:35:48] <ghrust> 13rust/06auto 14c4bb883 15novalis: Fix #8898
[05:35:48] <ghrust> 13rust/06auto 148f678ae 15bors: auto merge of #8928 : novalis/rust/fix-8898, r=thestinger...
[05:35:48] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[05:36:00] <bjz> I just need somebody to test that it works
[05:36:11] <jeaye> I haven't switched to gl-rs
[05:36:17] <bjz> oh ok
[05:36:20] <bjz> no worries
[05:36:41] <strcat> rusti: struct Foo { $: 2 }
[05:36:41] -rusti- <anon>:5:22: 5:23 error: expected ident
[05:36:41] -rusti- <anon>:5          struct Foo { $: 2 }
[05:36:41] -rusti-                                ^
[05:36:41] -rusti- application terminated with error code 101
[05:36:52] <jeaye> Probably won't for some time (because it'll take effort!). I need to focus more on game-central features.
[05:36:59] <bjz> sure
[05:38:16] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[05:40:17] <myname> jeaye: what kind of game are you working at?
[05:41:37] <jeaye> myname: https://github.com/jeaye/q3
[05:42:18] <jeaye> myname: It's a spare-time project, so it doesn't progress too quickly, but it gives me a chance to hack away at Rust. :)
[05:43:27] <myname> not very interesting for me, but pretty neat
[05:44:24] <jeaye> Are you working on a game?
[05:44:57] *** Quits: tgummerer (tgummerer@moz-5DC8FA44.tbcn.telia.com) (Ping timeout)
[05:45:05] <myname> i'd love to, but i have not a single idea for a game that i would actually play
[05:45:17] <jeaye> heh
[05:46:04] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[05:47:38] <myname> did you ever had that "one game" that makes every other idea sounding boring
[05:47:44] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[05:48:09] <jeaye> Yes.
[05:48:20] <myname> for me, it's dwarf fortress
[05:49:17] <jeaye> heh, I've a colleague that plays Dwarf Fortress.
[05:50:10] <jeaye> Closest I'd get is nethack or aardwolf. Not nearly the same though.
[05:50:13] *** Quits: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net) (Ping timeout)
[05:50:29] <myname> never heard of aardwolf
[05:50:36] <jeaye> It's a mud
[05:50:50] <myname> but cataclysm dda looks promising (but also pretty hard to learn)
[05:51:08] <jeaye> aren't they all? :P
[05:51:22] <myname> well, it depends
[05:51:51] <myname> i played nethack first and stuff like nlarn got pretty easy
[05:53:07] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[05:53:24] *** Joins: Uther (Instantbir@moz-1B244B05.hfc.dyn.abo.bbox.fr)
[05:55:29] *** Joins: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com)
[05:57:35] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[05:58:19] *** Quits: eatkinson (eatkinson@moz-261EDE03.hsd1.ca.comcast.net) (Quit: eatkinson)
[06:00:22] <bjz> rusti: let mut v = [1, 2, 3]; for (a, b) in v.mut_iter().zip([1, 2, 3].iter()) { *a = a + b } v
[06:00:23] -rusti- <anon>:5:88: 5:93 error: binary operation + cannot be applied to type `&mut int`
[06:00:23] -rusti- <anon>:5          let mut v = [1, 2, 3]; for (a, b) in v.mut_iter().zip([1, 2, 3].iter()) { *a = a + b } v
[06:00:23] -rusti-                                                                                                  ^~~~~
[06:00:23] -rusti- error: aborting due to previous error
[06:00:25] -rusti- application terminated with error code 101
[06:00:36] <bjz> rusti: let mut v = [1, 2, 3]; for (a, b) in v.mut_iter().zip([1, 2, 3].iter()) { *a = *a + b } v
[06:00:36] -rusti- <anon>:5:93: 5:94 error: mismatched types: expected `int` but found `&int` (expected &-ptr but found int)
[06:00:37] -rusti- <anon>:5          let mut v = [1, 2, 3]; for (a, b) in v.mut_iter().zip([1, 2, 3].iter()) { *a = *a + b } v
[06:00:37] -rusti-                                                                                                       ^
[06:00:37] -rusti- error: aborting due to previous error
[06:00:38] -rusti- application terminated with error code 101
[06:00:55] <bjz> rusti: let mut v = [1, 2, 3]; for (a, b) in v.mut_iter().zip([1, 2, 3].iter()) { *a = *a + *b } v
[06:01:01] -rusti- pastebinned 11 lines of output: http://ix.io/7M0
[06:01:18] <bjz> :/
[06:01:24] <bjz> strcat: ^?
[06:01:51] <bjz> rusti: let mut v = [1, 2, 3]; let u = [1, 2, 3]; for (a, b) in v.mut_iter().zip(u.iter()) { *a = *a + *b } v
[06:01:52] -rusti- [2, 4, 6]
[06:07:50] *** Joins: fabiand (fabiand@moz-B43CF293.adsl.alicedsl.de)
[06:12:14] *** Joins: tgummerer (tgummerer@moz-5DC8FA44.tbcn.telia.com)
[06:14:15] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[06:15:09] <sfackler> bjz: probably https://github.com/mozilla/rust/issues/3511
[06:16:08] <Eridius> cripes. path2::posix is 403 lines without tests. path2::windows is 811 lines without tests.
[06:16:11] *** Quits: tgummerer (tgummerer@moz-5DC8FA44.tbcn.telia.com) (Ping timeout)
[06:16:39] <Eridius> and I don't even know if path2::windows is correct yet, because I still have to write the test suite
[06:17:19] <jeaye> Eridius: :|
[06:18:51] *** Quits: tautologico (lymph@8ABDEDA.34CAB63A.7B974E06.IP) (Quit: tautologico)
[06:19:12] <Eridius> jeaye: windows paths are nasty beasts
[06:19:34] <Eridius> appending one path to another is a mess too, because of paths like C:foo.txt
[06:19:46] <Eridius> C:foo.txt means "foo.txt relative to the cwd on volume C", and every volume has an independent cwd
[06:20:13] <Eridius> so the best I can do is if you do `C:/foo/bar`.join(`C:baz`) it will produce `C:/foo/bar/baz`, but joining C:baz to anything else will just yield C:baz
[06:20:17] <Eridius> which is crazy
[06:20:31] <Eridius> but since I can't know what the cwd is on volume C unless I'm joining it to a volume C path, I don't have a choice
[06:22:01] *** Joins: tgummerer (tgummerer@moz-5DC8FA44.tbcn.telia.com)
[06:22:47] <mm> Eridius: WTF, windows.
[06:23:49] <Eridius> also you can start a path with \\?\, which disables string processing (and requires the path to be relative)
[06:24:04] <Eridius> \\?\foo/bar/baz is actually a path with a single component "foo/bar/baz", yet \foo/bar/baz would actually be interpreted as \foo\bar\baz
[06:24:34] <Eridius> (although I'm not sure when you can actually use \\?\ paths outside of UNC naming, which in this case is \\?\UNC\server\share\path)
[06:24:43] <Eridius> unlike regular UNC which is just \\server\share\path
[06:25:39] <Eridius> I suppose you can say \\?\C:\Users
[06:26:00] <Eridius> which apparently works with the `dir` command. And ugh, I think I need to complicate Windows paths even further
[06:26:04] <strcat> ughhhh
[06:26:10] <strcat> I really don't want to build an Option myself
[06:26:14] <strcat> this stupid reflect code.
[06:26:21] <Eridius> because if you pop \\?\C: you'd get \\?\ and C:, which is obviously wrong
[06:26:26] <Eridius> grrr
[06:26:47] <Eridius> either that or I could just ignore that and continue on
[06:27:02] <Eridius> since joining .. to \\?\C: would actually yield \\?\C:\..
[06:27:33] *** Quits: Ralith (ralith@moz-B932C54E.hsd1.wa.comcast.net) (Ping timeout)
[06:27:35] *** Quits: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net) (Input/output error)
[06:30:14] <strcat> rusti: enum { Bar { x: int, y: int } } Bar { x: 5, y: 10 }
[06:30:14] -rusti- <anon>:5:14: 5:15 error: expected ident, found `{`
[06:30:15] -rusti- <anon>:5          enum { Bar { x: int, y: int } } Bar { x: 5, y: 10 }
[06:30:15] -rusti-                        ^
[06:30:15] -rusti- application terminated with error code 101
[06:30:28] <strcat> rusti: enum Foo { Bar { x: int, y: int } } Bar { x: 5, y: 10 }
[06:30:29] -rusti- Bar(5, 10)
[06:30:32] <strcat> stupid repr
[06:30:41] <Eridius> I didn't realize enum variants could have named fields
[06:30:41] *** Joins: int3_ (int3_@2C194632.3778D849.1D6E592A.IP)
[06:30:55] <strcat> Eridius: enum variants are the same as structs
[06:31:06] <strcat> there are unit structs, tuple structs and structs, and the same kinds of enum variants
[06:31:22] <Eridius> I suppose that makes sense. I just haven't seen an enum variant with named fields before
[06:31:36] <strcat> because no one knows they exist
[06:31:52] <Eridius> sigh, I really wish borrowck operated at a more fine-grained level
[06:32:00] *** Quits: KindOne (KindOne@moz-749DF21A.dynamic.ip.windstream.net) (Ping timeout)
[06:32:05] <Eridius> `self.repr.truncate(self.prefix_len())` should work, goddammit
[06:32:14] <strcat> that's just a bug
[06:32:22] <Eridius> yeah I know
[06:32:23] <strcat> doesn't require a redesign
[06:32:46] <Eridius> I wish borrowck could also return borrows earlier than the end of the scope. i.e when a variable is no longer referenced, its borrow should be returned
[06:32:58] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[06:33:15] <strcat> Eridius: http://ix.io/7M3 enum reflection
[06:33:17] <strcat> :|
[06:33:24] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[06:33:25] <Eridius> I have code in here that uses `let val = { /* 20+ lines of code */ }; if val.is_some() { ... } else { ... }` purely so I can scope a borrow
[06:33:54] * strcat doesn't really want to teach it to know about named fields anymore
[06:33:58] <Eridius> haha
[06:34:04] *** Quits: int3_ (int3_@2C194632.3778D849.1D6E592A.IP) (Client exited)
[06:34:10] <Eridius> opaqueptrty.
[06:34:24] *** Joins: int3_ (int3_@2C194632.3778D849.1D6E592A.IP)
[06:34:42] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[06:34:45] <Eridius> yay, path2::windows now compiles! and a test I added to path2::posix failed! \o/
[06:36:09] *** Joins: KindOne (KindOne@moz-749DF21A.dynamic.ip.windstream.net)
[06:36:12] *** Quits: int3_ (int3_@2C194632.3778D849.1D6E592A.IP) (Ping timeout)
[06:36:18] <Eridius> windows::Path now exists! https://github.com/kballard/rust/commit/89cd4646073ce443dc04f354f38339e0ae58e6f9 too bad it has almost 0 tests and probably has a half-dozen bugs in it
[06:36:35] <Eridius> not to mention the \\?\C:\ thing I mentioned a few minutes ago that I need to decide how to handle
[06:36:45] <strcat> Eridius: https://github.com/mozilla/rust/issues?direction=desc&labels=A-reflect&sort=created&state=open I only just started reporting these
[06:37:07] *** Quits: jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Quit: zzz)
[06:37:21] <Eridius> strcat: reporting them is the first step to getting them fixed. Keep at it!
[06:37:31] <Eridius> now, I think it's time to finish packing for my international flight that leaves in 14 hours
[06:38:13] <strcat> Eridius: well I also fixed ~6 of these issues already
[06:38:26] <strcat> they are just really annoying to find
[06:38:36] <strcat> (the fixed ones aren't open bugs ;p)
[06:38:43] *** Joins: int3_ (int3_@2C194632.3778D849.1D6E592A.IP)
[06:40:47] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[06:40:47] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/weUAbA
[06:40:47] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[06:42:02] *** Quits: int3_ (int3_@2C194632.3778D849.1D6E592A.IP) (Client exited)
[06:43:25] *** Quits: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca) (Connection reset by peer)
[06:46:06] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[06:46:30] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[06:46:32] *** Quits: KindOne (KindOne@moz-749DF21A.dynamic.ip.windstream.net) (Ping timeout)
[06:48:10] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[06:49:09] *** Quits: tgummerer (tgummerer@moz-5DC8FA44.tbcn.telia.com) (Ping timeout)
[06:49:40] *** Joins: recrack (Mibbit@B4104EBB.3CC170B1.1E14B209.IP)
[06:50:11] *** Joins: KindOne (KindOne@moz-749DF21A.dynamic.ip.windstream.net)
[06:51:54] *** Joins: Ralith (ralith@114DA04D.CD83ED0A.BCDF04A6.IP)
[06:57:47] *** Joins: acrichto (acrichto@moz-69F2E428.ugrad.cs.cmu.edu)
[06:58:05] *** Joins: pyrac (pyrac@DFC5DF94.73C89388.AD05C589.IP)
[06:59:43] *** Joins: SingingBoyo (brandon@4DF3381A.51F4D838.4F048BDC.IP)
[06:59:44] *** Joins: tgummerer (tgummerer@moz-5DC8FA44.tbcn.telia.com)
[07:00:34] <strcat> /home/strcat/projects/rust/src/librustc/middle/trans/reflect.rs:55:31: 55:32 error: unresolved name `i`. Did you mean `b`?
[07:00:36] <strcat> wow
[07:00:42] <strcat> this is the first time this suggestion was right
[07:00:48] <strcat> ;p
[07:01:01] <Eridius> it suggested the right thing for me earlier too!
[07:01:14] <Eridius> error: unresolved name `path_`. Did you mean `path`?
[07:01:18] *** Joins: sebcrozet (sebcrozet@moz-7FB6C00B.w193-252.abo.wanadoo.fr)
[07:01:58] <Eridius> of course earlier today IIRc it said error: unresolved name `count`. Did you mean `xs`? Which is a pretty wacky suggestion
[07:02:13] <Eridius> I assume it uses levenshtein distance, or something similar, but I'm guessing its threshold is set too high
[07:02:54] <strcat> Eridius: well the problem is that it only considers local vars
[07:03:01] <Eridius> that does sound like a problem
[07:04:18] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[07:04:21] *** Joins: sk (sk@76BFB31C.71F9CB99.78DD174B.IP)
[07:04:38] *** flaper87|afk is now known as flaper87
[07:10:43] *** Quits: tgummerer (tgummerer@moz-5DC8FA44.tbcn.telia.com) (Ping timeout)
[07:12:37] *** Joins: threecreepio (jdp@moz-71E164C9.cust.bredbandsbolaget.se)
[07:18:10] *** Quits: victorporof (victorporo@9D964D4D.36D485C.2B3D3D4.IP) (Quit: victorporof)
[07:20:46] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[07:20:46] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/B7L1FA
[07:20:46] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[07:20:47] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[07:20:48] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/8WaYkA
[07:20:48] <ghrust> 13rust/06auto 14cbd143f 15Ilyong Cho: turn off android ndk asm pass
[07:20:48] <ghrust> 13rust/06auto 146a3dd30 15bors: auto merge of #8931 : ILyoan/rust/turnoff_android_ndk_asm, r=thestinger...
[07:20:48] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[07:21:33] *** Joins: victorporof (victorporo@9D964D4D.36D485C.2B3D3D4.IP)
[07:24:39] *** Quits: victorporof (victorporo@9D964D4D.36D485C.2B3D3D4.IP) (Quit: victorporof)
[07:25:51] *** Joins: tikue_ (tkuehn@moz-424BC304.hsd1.pa.comcast.net)
[07:26:21] <tikue_> rusti: [1u] + [2u]
[07:26:22] -rusti- <anon>:5:9: 5:20 error: failed to find an implementation of trait std::vec::Vector<uint> for [uint, .. 1]
[07:26:22] -rusti- <anon>:5          [1u] + [2u]
[07:26:22] -rusti-                   ^~~~~~~~~~~
[07:26:22] -rusti- application terminated with error code 101
[07:26:40] <Eridius> that seems like the wrong trait...
[07:27:14] *** Joins: Ms2ger (Ms2ger@F84917BA.3387515C.187A1082.IP)
[07:27:35] <tikue_> rusti: ~[1u] + ~[2u]
[07:27:37] -rusti- ~[1u, 2u]
[07:27:48] <tikue_> rusti: ~[1u] + [2]
[07:27:49] -rusti- <anon>:5:9: 5:20 error: failed to find an implementation of trait std::vec::Vector<uint> for [int, .. 1]
[07:27:49] -rusti- <anon>:5          ~[1u] + [2]
[07:27:49] -rusti-                   ^~~~~~~~~~~
[07:27:49] -rusti- application terminated with error code 101
[07:27:54] <Eridius> rusti: [1u].as_slice() + [2u]
[07:27:54] -rusti- <anon>:5:9: 5:31 error: failed to find an implementation of trait std::vec::Vector<uint> for [uint, .. 1]
[07:27:55] -rusti- <anon>:5          [1u].as_slice() + [2u]
[07:27:55] -rusti-                   ^~~~~~~~~~~~~~~~~~~~~~
[07:27:56] -rusti- application terminated with error code 101
[07:28:00] <Eridius> rusti: [1u].as_slice() + [2u].as_slice()
[07:28:05] -rusti- pastebinned 20 lines of output: http://ix.io/7M7
[07:28:10] <Ms2ger> rusti: ~[1u] + &[2]
[07:28:12] -rusti- pastebinned 14 lines of output: http://ix.io/7M8
[07:28:23] <Ms2ger> rusti: ~[1u] + &[2u]
[07:28:23] -rusti- ~[1u, 2u]
[07:28:34] *** Quits: threecreepio (jdp@moz-71E164C9.cust.bredbandsbolaget.se) (Quit: threecreepio)
[07:29:39] <tikue_> rusti: struct Foo; ~[Foo] + &[Foo]
[07:29:39] -rusti- <anon>:5:21: 5:36 error: failed to find an implementation of trait std::clone::Clone for main::Foo
[07:29:40] -rusti- <anon>:5          struct Foo; ~[Foo] + &[Foo]
[07:29:40] -rusti-                               ^~~~~~~~~~~~~~~
[07:29:40] -rusti- application terminated with error code 101
[07:29:49] <tikue_> rusti: #[deriving(Clone)] struct Foo; ~[Foo] + &[Foo]
[07:29:49] -rusti- <anon>:5:40: 5:55 error: failed to find an implementation of trait std::clone::Clone for main::Foo
[07:29:49] -rusti- <anon>:5          #[deriving(Clone)] struct Foo; ~[Foo] + &[Foo]
[07:29:50] -rusti-                                                  ^~~~~~~~~~~~~~~
[07:29:50] -rusti- application terminated with error code 101
[07:30:30] *** Joins: z0w0 (zack@moz-30F36A45.qld.bigpond.net.au)
[07:31:39] *** Quits: huhlig-home (huhlig@moz-C8339267.hfc.comcastbusiness.net) (Connection reset by peer)
[07:32:37] *** Joins: huhlig-home (huhlig@moz-C8339267.hfc.comcastbusiness.net)
[07:32:56] *** Joins: cmr (moznet@moz-EC676DFE.members.linode.com)
[07:33:03] *** Joins: sankha93 (Instantbir@CAF6D3FF.9C875DCD.9105FBCF.IP)
[07:33:47] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[07:33:56] *** Quits: sankha93 (Instantbir@CAF6D3FF.9C875DCD.9105FBCF.IP) (Quit: Gone to save the world!)
[07:34:35] *** Quits: Archer (Archer@moz-C36DFA25.bb.online.no) (Connection reset by peer)
[07:34:49] *** Joins: Archer (Archer@moz-C36DFA25.bb.online.no)
[07:35:48] <SingingBoyo> how do you convert a string to an int again?  totally blanking out
[07:37:38] *** Joins: lenstr (lenstr@E0E80B8D.ED45D46B.DFEAE789.IP)
[07:37:58] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[07:38:03] <tikue_> rusti: fn copy<T: Clone>(t: &T) -> T { t.clone() }
[07:38:07] -rusti- ()
[07:38:49] <strcat> SingingBoyo: FromStr trait
[07:39:22] *** Quits: pyrac (pyrac@DFC5DF94.73C89388.AD05C589.IP) (Quit: pyrac)
[07:42:40] *** Joins: pyrac (pyrac@DFC5DF94.73C89388.AD05C589.IP)
[07:44:38] <glyc> SingingBoyo:  let s = "12"; let int_from_str :int = FromStr::from_str(s).unwrap();
[07:45:54] <mark_edward> does TotalORd not give you ==?
[07:46:55] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[07:47:13] <tikue_> rusti: fn copy<T: Clone>(v: &[T]) -> ~[T] { v.clone() }
[07:47:15] -rusti- <anon>:5:46: 5:57 error: mismatched types: expected `~[T]` but found `&[T]` ([] storage differs: expected ~ but found &)
[07:47:15] -rusti- <anon>:5          fn copy<T: Clone>(v: &[T]) -> ~[T] { v.clone() }
[07:47:16] -rusti-                                                        ^~~~~~~~~~~
[07:47:16] -rusti- error: aborting due to previous error
[07:47:16] -rusti- application terminated with error code 101
[07:47:18] <tikue_> why
[07:47:56] <strcat> tikue_: hm?
[07:48:03] <strcat> Clone gives you back the same type
[07:48:11] <tikue_> ah
[07:48:12] <tikue_> :\
[07:48:13] <strcat> &[T] and ~[T] are unrelated types
[07:48:17] <tikue_> how do i go to an owned vec?
[07:48:23] <strcat> to_owned
[07:48:27] <tikue_> ah thank you
[07:48:35] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[07:48:42] *** Quits: recrack (Mibbit@B4104EBB.3CC170B1.1E14B209.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[07:48:55] <mark_edward> strcat: do TotalORd/Eq not provide the operators <,>,==,etc?
[07:48:58] <strcat> no
[07:49:02] <mark_edward> why?
[07:49:08] <strcat> because Eq/Ord provide them
[07:49:14] *** Joins: huhlig-home2 (huhlig@moz-C8339267.hfc.comcastbusiness.net)
[07:49:42] <mark_edward> but does every type that implements TotalOrd/Eq guaranteed to implemen Ord/Eq?
[07:50:22] <strcat> they could be
[07:50:25] <strcat> they aren't right now
[07:50:36] <strcat> TotalOrd inherits from TotalEq, that's all
[07:51:23] <mark_edward> this makes me sad. im making a tree thing with Node<K: TotalOrd, V> and i have to call .cmp() all the time and i have no nice operators :(
[07:52:26] <strcat> a type's implementation of the partial ordering might not be the same as the total ordering though
[07:52:34] <strcat> floats have a defined order, and then a defined total order
[07:52:39] <strcat> so right now the traits are unrelated
[07:52:57] *** Joins: threecreepio (jdp@moz-1A9F0A3C.cust.bredband2.com)
[07:54:11] <tikue_> are list comprehensions of interest to anyone else?
[07:54:29] *** Quits: Deewiant (deewiant@moz-C015B7F8.iki.fi) (Ping timeout)
[07:54:41] *** Joins: Deewiant (deewiant@moz-C015B7F8.iki.fi)
[07:55:12] *** Joins: victorporof (victorporo@9D964D4D.36D485C.2B3D3D4.IP)
[07:55:56] <strcat> tikue_: can define them with macros
[07:56:21] <tikue_> strcat: so then a list comprehension macro in the prelude
[07:56:38] <strcat> doesn't belong in the stdlib imo
[07:56:52] <tikue_> why
[07:56:59] <strcat> idiomatic rust doesn't do heap allocations all the time
[07:57:10] *** Quits: lenstr (lenstr@E0E80B8D.ED45D46B.DFEAE789.IP) (Client exited)
[07:57:17] <strcat> there are usually much better ways to write stuff
[07:57:36] <tikue_> it wouldn't have to heap allocate
[07:57:44] <strcat> so then just make an iterator?
[07:57:50] <tikue_> ?
[07:58:03] <tikue_> they're orthogonal 
[07:58:04] <strcat> I mean what will it do then
[07:58:14] <strcat> either it's going to make a container, or an iterator
[07:58:24] <tikue_> [el for el in v.iter()] would return [&T]
[07:58:36] <strcat> [&T] isn't a type
[07:58:51] <strcat> you can't make a fixed-size vector that way, you need to know a size in advance
[07:58:53] <strcat> it's part of the type
[07:58:54] <tikue_> sorry
[07:58:57] <tikue_> i meant ~[&T]
[07:59:31] <strcat> so then it *will* encourage heap allocations ;p
[07:59:37] <strcat> and special-case a specific vector type even more
[08:00:11] <tikue_> perhaps you're right :)
[08:00:15] <strcat> what happens if we want most of our vectors to be small vectors?
[08:00:22] <strcat> we're going to pay for all the special casing of ~[T]
[08:00:39] *** Joins: squiddy_ (squiddy@moz-4236ED38.adsl.alicedsl.de)
[08:01:32] *** Quits: squiddy (squiddy@moz-CB1FFF0E.adsl.alicedsl.de) (Ping timeout)
[08:01:40] *** Quits: victorporof (victorporo@9D964D4D.36D485C.2B3D3D4.IP) (Ping timeout)
[08:03:08] *** Quits: thesnowdog (doug@15B51297.CDB23781.6F17036B.IP) (Connection reset by peer)
[08:03:25] *** Quits: fabiand (fabiand@moz-B43CF293.adsl.alicedsl.de) (Quit: Verlassend)
[08:05:41] *** Joins: fabiand (fabiand@moz-B43CF293.adsl.alicedsl.de)
[08:05:57] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[08:09:27] *** Joins: thesnowdog (doug@15B51297.CDB23781.6F17036B.IP)
[08:10:19] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[08:10:19] *** ChanServ sets mode: +o pnkfelix
[08:10:47] *** Quits: SingingBoyo (brandon@4DF3381A.51F4D838.4F048BDC.IP) (Ping timeout)
[08:11:15] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[08:16:29] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Ping timeout)
[08:20:34] *** Joins: CarpNet (ac@moz-FD24B77.sohonet.co.uk)
[08:22:34] *** Quits: sonwow (sonwow@5AB4884B.FCC4549.14D5B978.IP) (Quit: Lost terminal)
[08:26:00] *** Joins: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk)
[08:28:51] *** Joins: SingingBoyo (brandon@4DF3381A.51F4D838.4F048BDC.IP)
[08:29:52] *** Quits: StarLight (StarLight@moz-644D52BA.dynamic.avangarddsl.ru) (Ping timeout)
[08:30:53] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[08:30:53] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/8WaYkA
[08:30:53] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[08:33:52] <tikue_> what's the easiest way to split a vector in two?
[08:34:10] <tikue_> like [0 .. 20] ==> ([0 .. 10], [10 .. 20])
[08:34:25] *** Joins: sonwow (sonwow@5AB4884B.FCC4549.14D5B978.IP)
[08:34:52] <tikue_> i see mut split but why is there no split that returns immutable slices
[08:35:16] <strcat> mut_split exists because it won't let you take multiple mutable slices
[08:35:18] <dbaupp> tikue_: not needed
[08:35:31] <tikue_> oh i see
[08:35:35] <tikue_> so what's the best way to do it then?
[08:35:49] <dbaupp> .slice_to(n), .slice_from(n)
[08:35:56] <tikue_> ok thanks, that makes sense
[08:38:05] <tikue_> a put_back method for iterators would make merging two sorted lists trivial
[08:38:43] <dbaupp> there's Peekable
[08:38:47] <dbaupp> or something like that
[08:38:53] * dbaupp checks
[08:39:18] <tikue_> for (first, second) in l1.iter().zip(l2.iter()) { if first < second { result.push(first); l2.put_back(second) } else { result.push(second); l1.put_bck(first); } }
[08:39:23] * tikue_ shrugs
[08:40:45] <myname> tikue_: doesn't make much sense to me with a parameter
[08:40:55] <strcat> tikue_: there is Extendable
[08:41:03] <strcat> rust's iterators are memory safe, they will never be output ranges like D
[08:41:18] <dbaupp> let (i1, i2) = (l1.peekable(), l2.peekable()); loop { match (i1.peek(), i2.peek()) { (Some(a), Some(b)) => result.push(if *a < *b {i1.next()} else {i2.next()}.unwrap()), ... }
[08:41:18] <myname> push_back with no parameter would make sense to me as you only have to change the pointer
[08:41:40] <tikue_> ah yes, true
[08:41:41] *** Joins: anri (solancile@moz-E49E7C4B.hsd1.wa.comcast.net)
[08:42:12] <dbaupp> strcat: you haven't happened to have delved into rustc::metadata much, have you?
[08:42:16] <strcat> dbaupp: nope
[08:42:22] <myname> i.e. something like a "repeat current iteration"
[08:42:26] <strcat> dbaupp: also, https://github.com/mozilla/rust/pull/8927 r?
[08:42:50] *** Joins: mama (myat@77487EB8.16540EFD.5138F352.IP)
[08:43:00] <dbaupp> rusti: let () = &print;
[08:43:02] -rusti- <anon>:5:13: 5:15 error: mismatched types: expected `&extern "Rust" fn(&str)` but found `()` (expected &-ptr but found ())
[08:43:03] -rusti- <anon>:5          let () = &print;
[08:43:03] -rusti-                       ^~
[08:43:03] -rusti- error: aborting due to previous error
[08:43:03] -rusti- application terminated with error code 101
[08:43:14] <strcat> rusti: &println
[08:43:16] -rusti- &
[08:43:19] <dbaupp> strcat: is this correct https://github.com/mozilla/rust/pull/8927/files#L2R676 ?
[08:43:26] <dbaupp> shouldn't that be &&fn() ?
[08:43:36] <dbaupp> wait
[08:43:38] <dbaupp> I see
[08:43:38] <strcat> dbaupp: the first & is just for the wrapper
[08:43:41] <dbaupp> yeah
[08:43:54] <strcat> anyway I'll do the actual fn types later
[08:44:00] <tikue_> strcat: what is extendable?
[08:44:03] <dbaupp> why are you testing printing `&extern fn` though?
[08:44:11] <strcat> tikue_: look in std::iterator
[08:44:26] <strcat> there are FromIterator/Extendable
[08:44:32] <tikue_> ah ys
[08:44:33] <tikue_> yes
[08:44:44] <strcat> dbaupp: because it's a fn, it handles all fns the same :s
[08:44:49] <tikue_> i'm not sure how that is related to a put_back() method though?
[08:45:00] * strcat shrugs
[08:45:05] <strcat> dbaupp: I just wanted it inside something
[08:45:12] <strcat> could be a tuple or whatever
[08:45:18] <dbaupp> strcat: why?
[08:45:22] <strcat> dbaupp: finds more bugs
[08:45:27] * dbaupp is confused by the extra layers
[08:45:28] <dbaupp> ok
[08:45:57] <strcat> and in theory the visit_class_field should use Option<&str>
[08:46:09] <dbaupp> rusti: struct Foo(int); Foo(1)
[08:46:10] -rusti- main::Foo{__field__: 1}
[08:46:12] <strcat> but I really, really don't want to extend that manual IR building to Option
[08:46:22] <strcat> until &str has the Option optimization
[08:46:26] <dbaupp> rusti: struct Foo { __field__: int } Foo { __field__: 1 }
[08:46:27] -rusti- main::Foo{__field__: 1}
[08:46:33] <dbaupp> hm
[08:46:36] <dbaupp> :(
[08:46:42] <strcat> dbaupp: well I fixed that
[08:46:51] <strcat> it prints as main::Foo(1) now
[08:47:11] <dbaupp> will it print something with a field actually called `__field__` as that too though?
[08:47:21] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[08:47:23] <strcat> dbaupp: no I did it based on the ident's actual type
[08:47:38] <strcat> __field__ is just filler, I don't look for it
[08:47:48] <strcat> it could just use a blank string instead of that
[08:47:50] <strcat> it's weird
[08:47:53] <dbaupp> https://github.com/mozilla/rust/pull/8927/files#L0R259 ?
[08:48:11] <strcat> dbaupp: yes that checks for it properly
[08:48:16] <dbaupp> doesn't interning mean that a user __field__ si the same as a normal field?
[08:48:26] <dbaupp> *internal __field__
[08:48:35] * dbaupp doesn't really know how it works
[08:48:37] <strcat> a user __field__ is just a normal field
[08:48:41] <strcat> dbaupp: the __field__ thing is filler
[08:48:43] <strcat> it's not used anywhere
[08:48:54] <strcat> it needs to pick a string to put in there for unnamed fields
[08:48:56] <strcat> it uses __field__
[08:49:01] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[08:49:01] <strcat> but it's not how you check for an unnamed field
[08:49:12] <strcat> it's caused by token.rs
[08:49:16] <strcat> worst module ever
[08:49:38] <strcat> it also causes the __foreign_mod__ thing
[08:49:40] <strcat> yay token.rs.
[08:50:06] <dbaupp> I kinda don't believe you :S (this presumably means I'm wrong though :) )
[08:50:31] <strcat> there is similar code elsewhere
[08:50:42] <dbaupp> where?
[08:50:50] <strcat> how about I just add a test?
[08:50:52] <dbaupp> (and is that code correct?)
[08:51:01] <dbaupp> heh, yup :)
[08:51:31] <strcat> dbaupp: really though I originally changed __field__ to 0field
[08:51:36] <strcat> and then checked for the 0
[08:51:41] <strcat> and then realized I didn't need a hack at all
[08:51:46] <strcat> since __field__ was useless filler
[08:52:31] * strcat compiles
[08:52:39] <strcat> std.rs --test takes so long
[08:53:32] <dbaupp> eurgh,
[08:53:34] <dbaupp> ast.rs:31:pub fn new_ident(name: Name) -> ident { ident {name: name, ctxt: empty_ctxt}}
[08:53:34] <dbaupp> ast_util.rs:830:pub fn new_ident(name: Name) -> ident { ident {name: name, ctxt: 0}}
[08:53:44] <dbaupp> (empty_ctxt == 0)
[08:54:20] <strcat> dbaupp: uh... I was wrong to trust debug-info ;[
[08:54:27] * strcat fixes it
[08:58:18] <strcat> dbaupp: I am just reapplying my 0 hack :s
[08:58:40] *** Joins: kumel (kumel@BD9B35B2.60E2620B.EBFADDB2.IP)
[08:58:40] <strcat> rusti: struct { __field__: int }
[08:58:41] -rusti- <anon>:5:16: 5:17 error: expected ident, found `{`
[08:58:41] -rusti- <anon>:5          struct { __field__: int }
[08:58:41] -rusti-                          ^
[08:58:41] -rusti- application terminated with error code 101
[08:58:45] <strcat> rusti: struct Foo { __field__: int }
[08:58:47] -rusti- ()
[08:58:50] <strcat> rusti: struct Foo { __field__: int } Foo(2)
[08:58:57] *** Quits: tikue_ (tkuehn@moz-424BC304.hsd1.pa.comcast.net) (Quit: tikue_)
[08:59:04] <strcat> rusti: struct Foo { __field__: int }; Foo(2)
[08:59:08] <strcat> rusti: 5
[08:59:09] -rusti- pastebinned 8 lines of output: http://ix.io/7M9
[08:59:10] -rusti- pastebinned 8 lines of output: http://ix.io/7Ma
[08:59:10] -rusti- 5
[08:59:12] <dbaupp> strcat: what about `<unnamed_field>` or something more descriptive
[09:00:11] *** Parts: kumel (kumel@BD9B35B2.60E2620B.EBFADDB2.IP) ()
[09:00:14] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Client exited)
[09:00:46] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[09:00:52] <strcat> dbaupp: ok there
[09:01:35] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[09:02:28] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[09:02:50] <dbaupp> strcat: r+
[09:03:00] <dbaupp> strcat: btw, have you seen https://github.com/mozilla/rust/pull/8884
[09:03:13] <strcat> well I didn't actually look at it yet
[09:05:47] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[09:05:47] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/2Rup-Q
[09:05:47] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[09:05:49] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[09:05:49] <ghrust> 01[13rust01] 15bors pushed 5 new commits to 06auto: 02http://git.io/oHZtOg
[09:05:49] <ghrust> 13rust/06auto 147a52154 15Daniel Micay: repr: print functions as `fn()`
[09:05:49] <ghrust> 13rust/06auto 14cc1f002 15Daniel Micay: repr: add support for trait objects...
[09:05:49] <ghrust> 13rust/06auto 14331d2d6 15Daniel Micay: repr: handle tuple structs sanely...
[09:05:51] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[09:05:52] <eevee> rusti: #[deriving(Clone)] struct foo { bytes: [u8, ..8] }
[09:05:53] -rusti- ()
[09:06:33] *** Joins: Earnestly (earnest@moz-F387F877.dyn.plus.net)
[09:06:55] <strcat> deriving doesn't work in function scopes
[09:07:48] <eevee> ah
[09:07:49] * dbaupp was going to try to fix that, but there's a huge patch to macros pending that he doesn't want to interfere with
[09:07:57] <eevee> well i am getting:
[09:07:57] <eevee> amulet/termios.rs:136:15: 136:20 error: mismatched types: expected `[i32, .. 32]` but found `&[i32, .. 32]` (expected vector but found &-ptr)
[09:08:10] <eevee> trying to derive Clone on a termios struct, which contains an [i32, ..32]
[09:08:34] <dbaupp> fixed length vectors don't implement any traits
[09:08:38] <eevee> i take it fixed-size vectors aren't cloneable
[09:08:39] <eevee> yeah
[09:08:42] <eevee> well that sucks
[09:08:43] <dbaupp> so deriving doesn't work
[09:08:55] * dbaupp has a fix that will make the error message more understandable
[09:08:58] * dbaupp implements it now
[09:09:25] <eevee> i had a similar error on an enum that contained another not-Clone enum so that shed some light  :)
[09:11:35] <eevee> ah, #7622
[09:15:55] *** Quits: thesnowdog (doug@15B51297.CDB23781.6F17036B.IP) (Connection reset by peer)
[09:16:25] <eevee> i can't add my own implementation either?  hm.
[09:16:54] <dbaupp> you should be able to implement Clone on the struct itself
[09:17:29] <strcat> dbaupp: https://github.com/mozilla/rust/issues?direction=desc&labels=A-reflect&page=1&sort=created&state=open ;p
[09:17:31] <strcat> new bug category
[09:17:36] *** Joins: thesnowdog (doug@15B51297.CDB23781.6F17036B.IP)
[09:17:38] <strcat> anyway
[09:17:50] <strcat> it would make my life easier if the tydescs just had the names...
[09:18:00] <strcat> should have done that first ;p
[09:19:41] <eevee> be there /any/ terser way to copy a fixed-length vector than [v[0], v[1], v[2], v[3], ... v[31]]
[09:20:13] <dbaupp> eevee: if it contains i32, then `v` should work (it'll be implicitly copyable)
[09:20:30] <eevee> ah right
[09:20:33] * dbaupp doesn't know if it should be copyable or copiable, since his spellchecker marks both)
[09:20:42] <eevee> ...but Clone doesn't take advantage of that
[09:20:43] *** Joins: mib_zgflxq (Mibbit@A1793499.EC15082C.D7C984E0.IP)
[09:20:54] <eevee> this is a little silly
[09:21:19] <strcat> it can't take advantage of it
[09:21:32] <strcat> you can't write an impl for all sizes of fixed-size vectors
[09:21:33] <dbaupp> well, at the moment, implementing Clone for fixed length vectors would require writing out impl Clone for [T, .. n] for all 2^64 possible values of n
[09:21:37] <strcat> rust's type system can't express it
[09:21:56] <strcat> even integers in the type system are not enough
[09:22:02] <strcat> you need some special wildcard integer
[09:22:06] * dbaupp doesn't think the compiler would cope with a source file that long
[09:22:24] <dbaupp> strcat: <T: Clone, n: uint> Clone for [T, .. n] or something
[09:22:56] * strcat shrugs
[09:22:59] <strcat> 2 years from now maybe
[09:23:51] <eevee> strcat: deriving(Clone) is compiler wizardry in the first place, so it seems funny that it should be bound by the type system for copying built-in types that already implicitly copy
[09:24:24] <strcat> it's not compiler wizardry, it's a syntax extension
[09:24:34] <strcat> at some point you'll probably be able to write them
[09:25:00] <strcat> it only deals with the AST afaik, no types
[09:25:09] <strcat> takes in an AST, and produces one
[09:25:44] *** Quits: mib_zgflxq (Mibbit@A1793499.EC15082C.D7C984E0.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[09:26:43] <strcat> we could make Clone a lang hardcode a lazy emitter of clone impls for fixed-size vecs
[09:26:54] <strcat> make Clone a lang item and*
[09:27:18] <strcat> but do we hardcode every single trait we want fixed-size vectors to impl into the compiler?
[09:27:21] <strcat> Clone won't be the last
[09:27:33] <andrew-d> eevee: Are you looking to just clone one fixed-size vector to another?  Or something else?
[09:27:39] <strcat> why not DeepClone? why not Ord/Eq?
[09:27:45] <andrew-d> rusti: { let x: [int, ..4] = [1,2,3,4]; let y = x.to_owned(); x[0] + y[1] }
[09:27:51] -rusti- timeout triggered!
[09:28:01] <andrew-d> rusti: { let x: [int, ..4] = [1,2,3,4]; let y = x.to_owned(); x[0] + y[1] }
[09:28:06] -rusti- 3
[09:28:12] *** Quits: Uther (Instantbir@moz-1B244B05.hfc.dyn.abo.bbox.fr) (Ping timeout)
[09:28:19] <eevee> strcat: why does it need to be a trait at all when i implemented it manually just fine with `return termios{ a: self.a, b: self.b, ... }`
[09:28:45] <strcat> because Clone is a trait and you want it implemented for fixed-size vectors
[09:28:46] *** Quits: SingingBoyo (brandon@4DF3381A.51F4D838.4F048BDC.IP) (Ping timeout)
[09:29:13] <eevee> no i don't; i want it implemented for this thing that happens to contain a fixed-size vector.  i don't actually care how the vector is copied  :)
[09:29:40] <strcat> deriving isn't the place to do that, it has no knowledge of types
[09:29:58] <strcat> if it want it to work, you want magic to impl Clone as-needed for fixed-size vectors
[09:30:26] <strcat> it's an issue for any trait
[09:30:41] *** Joins: victorporof (victorporo@9D964D4D.36D485C.2B3D3D4.IP)
[09:30:42] <strcat> it happens to be the case you care about right now, but the other traits are important too
[09:30:52] <dbaupp> rusti: struct Foo { x: ~int, y: ~int } let y = Foo { x: ~1, y: ~2 }; Foo { x: ~3, .. y }
[09:30:54] -rusti- main::Foo{x: ~3, y: ~2}
[09:31:06] <strcat> uh
[09:31:08] <dbaupp> rusti: struct Foo { x: ~int, y: ~int } let y = Foo { x: ~1, y: ~2 }; (Foo { x: ~3, .. y }, y)
[09:31:13] -rusti- pastebinned 8 lines of output: http://ix.io/7Mb
[09:31:26] <eevee> huh i wonder if i could just do `return termios{ ..self }`
[09:31:38] <dbaupp> probably
[09:31:43] * dbaupp was accidentally helpful
[09:32:22] <andrew-d> ... I didn't know that worked.
[09:32:37] <eevee> seems to be a syntax error to not have at least one k:v pair
[09:32:43] *** Quits: victorporof (victorporo@9D964D4D.36D485C.2B3D3D4.IP) (Ping timeout)
[09:33:37] <eevee> and the error is on the opening brace, ha
[09:33:41] <dbaupp> rusti: struct Foo { x: int, y: int } Foo { .. Foo { x: 1, y: 1 } }
[09:33:42] -rusti- <anon>:5:43: 5:44 error: expected one of `; }` but found `{`
[09:33:42] -rusti- <anon>:5          struct Foo { x: int, y: int } Foo { .. Foo { x: 1, y: 1 } }
[09:33:42] -rusti-                                                     ^
[09:33:42] -rusti- application terminated with error code 101
[09:33:48] <eevee> yeah that
[09:33:54] <dbaupp> rusti: struct Foo { x: int, y: int } Foo { , .. Foo { x: 1, y: 1 } }
[09:33:54] -rusti- <anon>:5:43: 5:44 error: expected one of `; }` but found `{`
[09:33:54] -rusti- <anon>:5          struct Foo { x: int, y: int } Foo { , .. Foo { x: 1, y: 1 } }
[09:33:54] -rusti-                                                     ^
[09:33:54] -rusti- application terminated with error code 101
[09:34:29] <dbaupp> rusti: struct Foo { x: int, y: int } let x = Foo { x: 1, y: 1 }; Foo { x: x.x, .. x }
[09:34:31] -rusti- main::Foo{x: 1, y: 1}
[09:34:44] <dbaupp> hm, I guess I coulda chosen a better variable name than `x`
[09:35:00] <eevee> oh no
[09:35:00] <eevee> amulet/trie.rs:32:16: 32:20 error: value may contain borrowed pointers
[09:35:09] * strcat is glad it prints the struct names now ;p
[09:35:27] <strcat> really need to remove opaque_box and float
[09:36:08] <dbaupp> eevee: can't put & inside @ anymore
[09:36:41] <eevee> that's probably going to make me really really sad later, but in this case i don't *have* & inside @; it's a @ that contains @itself
[09:37:09] <eevee> i see rustc was fixed by adding + 'static all over the place and that seems to work for some reason
[09:37:43] <eevee> otherwise it can't be sure @T isn't a &?
[09:40:09] *** Joins: tikue_ (tkuehn@moz-424BC304.hsd1.pa.comcast.net)
[09:42:31] <eevee> hey hey, compiles
[09:42:54] <eevee> AND works
[09:43:00] <andrew-d> :D
[09:43:13] <dbaupp> gaaaaaaaah
[09:43:29] * dbaupp meets the horrible interaction between syntax extensions and auto-deref yet again.
[09:43:58] <eevee> AND there are so many warnings oh wow.
[09:44:11] <eevee> also this code is pre-static-methods so there are all these awful faux constructors
[09:45:28] *** Quits: robarnold (rob@BD56354E.DB510C09.6E370BFC.IP) (Ping timeout)
[09:46:18] <dbaupp> golly, that's some trait header. https://github.com/sebcrozet/nphysics/blob/916199c0a672194826b2696c97c5a5597b070c54/src/integration/body_integrator.rs#L111
[09:46:40] <andrew-d> Whoah
[09:46:58] <eevee> wow
[09:47:10] <andrew-d> M: <all the traits>
[09:47:11] <andrew-d> Jeez
[09:47:18] <eevee> M: *
[09:47:46] <andrew-d> Wonder if it'd be possible to implement something like:
[09:47:56] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[09:47:58] <andrew-d>    trait Foobar = Clone + ToString
[09:49:37] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[09:50:09] <dbaupp> andrew-d: https://github.com/mozilla/rust/issues/8634
[09:50:44] <andrew-d> dbaupp: Hah, shoulda known someone else has thought of it :P
[09:51:02] <SimonSapin> whatâ€™s the new way instead of ::<T> to provide a type hint for a return value?
[09:52:02] <dbaupp> SimonSapin: for a static method?
[09:52:10] <SimonSapin> dbaupp: I â€¦ think so
[09:52:20] <eevee> now i'm back to my still-unresolved crazy borrow errors.  unless maybe the trait issues i was stumbling across are fixed in master now
[09:52:23] <dbaupp> SimonSapin: let tmp: T = Foo::bar(); /* use tmp */
[09:52:36] <SimonSapin> dbaupp: no way to do it in an expression?
[09:52:53] <dbaupp> SimonSapin: not yet, it will become Foo::<for T>::bar()
[09:53:03] <dbaupp> (or something along those lines)
[10:01:19] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[10:02:08] <SimonSapin> dbaupp: oh â€¦ this is actually a hint for the type that implements the trait, not the return value. https://github.com/mozilla-servo/rust-core-foundation/blob/master/base.rs#L19
[10:02:46] <SimonSapin> The error is at https://github.com/mozilla-servo/rust-core-foundation/blob/master/base.rs#L57
[10:04:40] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[10:08:51] <mark_edward> what are the new printing/formatting macros again?
[10:10:44] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[10:10:44] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/oHZtOg
[10:10:44] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[10:12:32] <tikue_> rusti: let recursive = |n: uint| -> uint { if n <= 0 { 0 } else { recursive(n - 1) } } // can't work because lambdas are anonymous
[10:12:34] -rusti- <anon>:6:4: 6:5 error: expected `;` but found `}`
[10:12:34] -rusti- <anon>:6     };
[10:12:34] -rusti-              ^
[10:12:34] -rusti- application terminated with error code 101
[10:12:41] <tikue_> rusti: let recursive = |n: uint| -> uint { if n <= 0 { 0 } else { recursive(n - 1) } }; // can't work because lambdas are anonymous
[10:12:41] -rusti- <anon>:5:68: 5:77 error: unresolved name `recursive`.
[10:12:41] -rusti- <anon>:5          let recursive = |n: uint| -> uint { if n <= 0 { 0 } else { recursive(n - 1) } }; // can't work because lambdas are anonymous
[10:12:42] -rusti-                                                                              ^~~~~~~~~
[10:12:42] -rusti- error: aborting due to previous error
[10:12:42] -rusti- application terminated with error code 101
[10:13:27] <eevee> rusti: let recursive; recursive = |n: uint| -> uint { if n <= 0 { 0 } else { recursive(n - 1) } };
[10:13:28] -rusti- <anon>:5:79: 5:88 error: the type of this value must be known in this context
[10:13:28] -rusti- <anon>:5          let recursive; recursive = |n: uint| -> uint { if n <= 0 { 0 } else { recursive(n - 1) } };
[10:13:29] -rusti-                                                                                         ^~~~~~~~~
[10:13:29] -rusti- error: aborting due to previous error
[10:13:30] -rusti- application terminated with error code 101
[10:13:43] <bjz> mark_edward: print! println! format!
[10:13:57] <eevee> rusti: let recursive: fn(uint) -> uint; recursive = |n: uint| -> uint { if n <= 0 { 0 } else { recursive(n - 1) } };
[10:13:59] <mark_edward> bjz: thanks!
[10:14:01] -rusti- pastebinned 6 lines of output: http://ix.io/7Md
[10:14:59] <bjz> rusti: let recursive: &fn(uint) -> uint; recursive = |n: uint| -> uint { if n <= 0 { 0 } else { recursive(n - 1) } };
[10:15:00] -rusti- <anon>:5:98: 5:107 error: capture of possibly uninitialized variable: `recursive`
[10:15:00] -rusti- <anon>:5          let recursive: &fn(uint) -> uint; recursive = |n: uint| -> uint { if n <= 0 { 0 } else { recursive(n - 1) } };
[10:15:00] -rusti-                                                                                                            ^~~~~~~~~
[10:15:00] -rusti- error: aborting due to previous error
[10:15:02] -rusti- application terminated with error code 101
[10:15:04] <mark_edward> dbaupp: why are we making the type hint thing even lengthier????
[10:15:25] <bjz> eevee: hehe^
[10:15:39] <eevee> rusti: there is no pleasing you is there
[10:15:39] -rusti- <anon>:5:15: 5:17 error: expected one of `; }` but found `is`
[10:15:40] -rusti- <anon>:5          there is no pleasing you is there
[10:15:40] -rusti-                         ^~
[10:15:40] -rusti- application terminated with error code 101
[10:15:40] <bjz> eevee: dammit!
[10:15:53] <bjz> eevee: rustc is too smart
[10:16:00] <eevee> yes
[10:16:13] <eevee> all my pain on a new rust release boils down to "i got away with this before, now i can't"
[10:16:20] <bjz> yep
[10:16:27] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[10:16:56] <tikue_> so no recurisve lambdas right?
[10:17:10] <tikue_> i was just wondering if there was a way to inherit type parameters for inner functions
[10:17:42] <tikue_> fn foo<T>() { fn bar() { /* do something with a T type without calling it fn bar<T>() */ } }
[10:18:00] <eevee> rusti: let mut recursive: &fn(uint) -> uint = |n| { n }; recursive = |n: uint| -> uint { if n <= 0 { 0 } else { recursive(n - 1) } }; recursive(3)
[10:18:01] -rusti- 0u
[10:18:07] <eevee> beautiful
[10:18:26] <tikue_> hahaha eevee you cheater
[10:18:38] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Ping timeout)
[10:18:47] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[10:18:47] *** ChanServ sets mode: +o pnkfelix
[10:21:00] *** Joins: StarLight (StarLight@moz-41A99168.dynamic.avangarddsl.ru)
[10:21:59] <tikue_> rusti: 1 / 2
[10:21:59] -rusti- 0
[10:22:29] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[10:24:07] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[10:26:52] <eevee> whoa what clio compiles
[10:27:29] <eevee> awesome.  as a reward, sleep.
[10:28:01] <tikue_> rusti: match &[1, 2] { &[a, ..] => printfln!(a), _ => () }
[10:28:01] -rusti- <anon>:5:32: 5:33 error: unexpected token: `]`
[10:28:01] -rusti- <anon>:5          match &[1, 2] { &[a, ..] => printfln!(a), _ => () }
[10:28:01] -rusti-                                          ^
[10:28:01] -rusti- application terminated with error code 101
[10:28:15] <tikue_> rusti: match &[1] { &[a, ..] => printfln!(a), _ => () }
[10:28:15] -rusti- <anon>:5:29: 5:30 error: unexpected token: `]`
[10:28:15] -rusti- <anon>:5          match &[1] { &[a, ..] => printfln!(a), _ => () }
[10:28:15] -rusti-                                       ^
[10:28:16] -rusti- application terminated with error code 101
[10:28:26] <tikue_> rusti: let v = &[1];
[10:28:27] -rusti- <anon>:5:13: 5:14 warning: unused variable: `v` [-W unused-variable (default)]
[10:28:27] -rusti- <anon>:5          let v = &[1];
[10:28:27] -rusti-                       ^
[10:28:27] -rusti- ()
[10:28:44] <tikue_> rusti: let v = &[1]; match v { &[a, ..] => printfln!(a), _ => () }
[10:28:44] -rusti- <anon>:5:40: 5:41 error: unexpected token: `]`
[10:28:44] -rusti- <anon>:5          let v = &[1]; match v { &[a, ..] => printfln!(a), _ => () }
[10:28:45] -rusti-                                                  ^
[10:28:45] -rusti- application terminated with error code 101
[10:28:59] <tikue_> can you match on the first element of a list?
[10:30:11] <tikue_> rusti: let v = [];
[10:30:11] -rusti- <anon>:5:13: 5:19 error: cannot determine a type for this local variable: unconstrained type
[10:30:12] -rusti- <anon>:5          let v = [];
[10:30:12] -rusti-                       ^~~~~~
[10:30:12] -rusti- error: aborting due to previous error
[10:30:12] -rusti- application terminated with error code 101
[10:30:23] <tikue_> rusti: let v: [uint, ..0] = [];
[10:30:23] -rusti- <anon>:5:13: 5:14 warning: unused variable: `v` [-W unused-variable (default)]
[10:30:23] -rusti- <anon>:5          let v: [uint, ..0] = [];
[10:30:23] -rusti-                       ^
[10:30:24] -rusti- ()
[10:30:41] <tikue_> rusti: let v: [uint, ..0] = []; match v { [] => println("empty") }
[10:30:42] -rusti- empty
[10:30:42] -rusti- ()
[10:31:03] <tikue_> rusti: let v: &[uint, ..0] = &[1]; match v { &[] => println("empty"), _ => () }
[10:31:04] -rusti- <anon>:5:31: 5:35 error: mismatched types: expected `&[uint, .. 0]` but found `&[<VI0>]` (expected &-ptr but found vector)
[10:31:04] -rusti- <anon>:5          let v: &[uint, ..0] = &[1]; match v { &[] => println("empty"), _ => () }
[10:31:04] -rusti-                                         ^~~~
[10:31:04] -rusti- error: aborting due to previous error
[10:31:04] -rusti- application terminated with error code 101
[10:31:10] *** Joins: victorporof (victorporo@9D964D4D.36D485C.2B3D3D4.IP)
[10:31:16] <tikue_> rusti: let v: &[uint] = &[1]; match v { &[] => println("empty"), _ => () }
[10:31:16] -rusti- <anon>:5:42: 5:45 error: mismatched types: expected `&[uint]` but found an &-pointer pattern
[10:31:16] -rusti- <anon>:5          let v: &[uint] = &[1]; match v { &[] => println("empty"), _ => () }
[10:31:16] -rusti-                                                    ^~~
[10:31:16] -rusti- error: aborting due to previous error
[10:31:17] -rusti- application terminated with error code 101
[10:31:26] <tikue_> rusti: let v: &[uint] = &[1u]; match v { &[] => println("empty"), _ => () }
[10:31:27] -rusti- <anon>:5:43: 5:46 error: mismatched types: expected `&[uint]` but found an &-pointer pattern
[10:31:27] -rusti- <anon>:5          let v: &[uint] = &[1u]; match v { &[] => println("empty"), _ => () }
[10:31:27] -rusti-                                                     ^~~
[10:31:27] -rusti- error: aborting due to previous error
[10:31:28] -rusti- application terminated with error code 101
[10:31:31] <tikue_> rusti: let v: &[uint] = ~[1u]; match v { &[] => println("empty"), _ => () }
[10:31:32] -rusti- <anon>:5:43: 5:46 error: mismatched types: expected `&[uint]` but found an &-pointer pattern
[10:31:32] -rusti- <anon>:5          let v: &[uint] = ~[1u]; match v { &[] => println("empty"), _ => () }
[10:31:35] -rusti-                                                     ^~~
[10:31:37] -rusti- error: aborting due to previous error
[10:31:39] -rusti- application terminated with error code 101
[10:31:49] <tikue_> rusti: let v: &[uint] = ~[1];
[10:31:56] -rusti- pastebinned 7 lines of output: http://ix.io/7Me
[10:32:04] <tikue_> rusti: let v: &[uint] = &[1];
[10:32:04] -rusti- <anon>:5:13: 5:14 warning: unused variable: `v` [-W unused-variable (default)]
[10:32:04] -rusti- <anon>:5          let v: &[uint] = &[1];
[10:32:04] -rusti-                       ^
[10:32:05] -rusti- ()
[10:32:15] <tikue_> rusti: let v: &[uint] = &[1]; match v { }
[10:32:17] -rusti- pastebinned 9 lines of output: http://ix.io/7Mf
[10:32:35] <tikue_> rusti: let v: &[uint] = &[1]; match v { &[1] => "ok", _ => ".." }
[10:32:36] -rusti- <anon>:5:42: 5:46 error: mismatched types: expected `&[uint]` but found an &-pointer pattern
[10:32:36] -rusti- <anon>:5          let v: &[uint] = &[1]; match v { &[1] => "ok", _ => ".." }
[10:32:36] -rusti-                                                    ^~~~
[10:32:37] -rusti- error: aborting due to previous error
[10:32:37] -rusti- application terminated with error code 101
[10:32:48] <tikue_> rusti: let v: &[uint] = &[1]; match v { [1] => "ok", _ => ".." }
[10:32:49] -rusti- "ok"
[10:33:01] <tikue_> rusti: let v: &[uint] = &[1]; match v { [1, ..] => "ok", _ => ".." }
[10:33:01] -rusti- <anon>:5:48: 5:49 error: unexpected token: `]`
[10:33:02] -rusti- <anon>:5          let v: &[uint] = &[1]; match v { [1, ..] => "ok", _ => ".." }
[10:33:02] -rusti-                                                          ^
[10:33:02] -rusti- application terminated with error code 101
[10:33:09] <tikue_> rusti: let v: &[uint] = &[1]; match v { [1, b] => "ok", _ => ".." }
[10:33:10] -rusti- <anon>:5:46: 5:47 warning: unused variable: `b` [-W unused-variable (default)]
[10:33:10] -rusti- <anon>:5          let v: &[uint] = &[1]; match v { [1, b] => "ok", _ => ".." }
[10:33:10] -rusti-                                                        ^
[10:33:11] -rusti- ".."
[10:33:15] *** Quits: victorporof (victorporo@9D964D4D.36D485C.2B3D3D4.IP) (Ping timeout)
[10:33:18] <tikue_> rusti: let v: &[uint] = &[1]; match v { [1..] => "ok", _ => ".." }
[10:33:18] -rusti- <anon>:5:46: 5:47 error: unexpected token: `]`
[10:33:19] -rusti- <anon>:5          let v: &[uint] = &[1]; match v { [1..] => "ok", _ => ".." }
[10:33:19] -rusti-                                                        ^
[10:33:19] -rusti- application terminated with error code 101
[10:33:27] <tikue_> rusti: let v: &[uint] = &[1]; match v { [1, ] => "ok", _ => ".." }
[10:33:27] -rusti- <anon>:5:46: 5:47 error: unexpected token: `]`
[10:33:28] -rusti- <anon>:5          let v: &[uint] = &[1]; match v { [1, ] => "ok", _ => ".." }
[10:33:28] -rusti-                                                        ^
[10:33:28] -rusti- application terminated with error code 101
[10:33:42] <tikue_> rusti: let v: &[uint] = &[1, 2]; match v { [1, b] => "ok", _ => ".." }
[10:33:42] -rusti- <anon>:5:49: 5:50 warning: unused variable: `b` [-W unused-variable (default)]
[10:33:42] -rusti- <anon>:5          let v: &[uint] = &[1, 2]; match v { [1, b] => "ok", _ => ".." }
[10:33:42] -rusti-                                                           ^
[10:33:43] -rusti- "\x1cok"
[10:33:57] <tikue_> rusti: let v: &[uint] = &[1, 2]; match v { [1, ..b] => "ok", _ => ".." }
[10:33:57] -rusti- <anon>:5:51: 5:52 warning: unused variable: `b` [-W unused-variable (default)]
[10:33:57] -rusti- <anon>:5          let v: &[uint] = &[1, 2]; match v { [1, ..b] => "ok", _ => ".." }
[10:33:57] -rusti-                                                             ^
[10:33:58] -rusti- "\x1cok"
[10:34:12] <tikue_> rusti: let v: &[uint] = &[1, 2]; match v { [1, ..b] => b, _ => fail!() }
[10:34:13] -rusti- &[2u]
[10:34:21] <tikue_> rusti: let v: &[uint] = &[1, 2, 3, 4, 5]; match v { [1, ..b] => b, _ => fail!() }
[10:34:22] -rusti- &[2u, 3u, 4u, 5u]
[10:34:40] <pnkfelix> tikue_: just a reminder, rusti accepts private messages.
[10:34:50] <tikue_> pnkfelix: sorry :(
[10:34:59] <pnkfelix> tikue_: np
[10:35:46] <tikue_> i don't know why that doesn't get more attention though. that's really cool pattern matching
[10:37:59] *** Quits: Archer (Archer@moz-C36DFA25.bb.online.no) (Ping timeout)
[10:38:30] *** Quits: z0w0 (zack@moz-30F36A45.qld.bigpond.net.au) (Ping timeout)
[10:38:39] *** Joins: Archer (Archer@moz-C36DFA25.bb.online.no)
[10:39:54] *** Quits: Archer (Archer@moz-C36DFA25.bb.online.no) (Connection reset by peer)
[10:40:43] *** Quits: Earnestly (earnest@moz-F387F877.dyn.plus.net) (Ping timeout)
[10:42:42] *** Quits: reyre|away (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Connection reset by peer)
[10:42:54] *** Joins: reyre|away (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[10:43:22] *** Quits: Diamond (dick@moz-D7E07B36.ks.ks.cox.net) (Client exited)
[10:47:30] *** Joins: fyolnish_ (fyolnish@moz-BE2BAE5B.miinet.jp)
[10:47:59] *** Quits: fyolnish (fyolnish@moz-BE2BAE5B.miinet.jp) (Ping timeout)
[10:48:12] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[10:49:10] *** Quits: fyolnish_ (fyolnish@moz-BE2BAE5B.miinet.jp) (Ping timeout)
[10:49:52] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[10:51:37] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.1)
[10:52:30] *** Joins: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP)
[10:54:38] *** Joins: DasIch (dasich@moz-5EDA591.de)
[10:59:02] *** Quits: LRN (LRN@moz-50DF30B.nationalcablenetworks.ru) (Ping timeout)
[10:59:31] *** Joins: LRN (LRN@moz-50DF30B.nationalcablenetworks.ru)
[11:04:14] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[11:04:23] <tikue_> anyone have a link to strcat's arch nightly build?
[11:06:16] *** Quits: pyrac (pyrac@DFC5DF94.73C89388.AD05C589.IP) (Quit: pyrac)
[11:08:28] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[11:12:47] *** Joins: Shaladdle (Shaladdle@moz-424BC304.hsd1.pa.comcast.net)
[11:12:59] <Shaladdle> is there a tcp library for rust in stdlib or something?
[11:20:00] <tikue_> rusti: struct Foo(~[uint]); let mut foo = Foo(~[]); foo.push(1u); foo
[11:20:00] -rusti- main::Foo{__field__: ~[1u]}
[11:20:48] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[11:23:14] *** Joins: victorporof (victorporo@9D964D4D.36D485C.2B3D3D4.IP)
[11:24:20] <dbaupp> SimonSapin: ah :( I think that temporarily requires a dummy param hack: fn type_id(_hint_hack: Option<Self>) -> CFTypeID; and call it like `AbstractCFTypeRef::type_id(None::<T>)
[11:24:36] <dbaupp> mark_edward: because the current set up is damn confusing
[11:25:46] <dbaupp> trait Foo<U,V> { fn bar<X,Y>() } is called by Foo::bar<U,V,Self,X,Y>, which pretty strange, since `Self` isn't a proper param--it's just magically appearing--and U and V are connected to the trait, not the method
[11:26:01] *** Joins: fyolnish (fyolnish@moz-41D2D424.uqwimax.jp)
[11:27:40] *** Quits: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP) (Ping timeout)
[11:29:25] <SimonSapin> dbaupp: yeah, itâ€™s gonna be a pain
[11:30:38] <dbaupp> SimonSapin: yup :( how much is it used?
[11:30:51] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[11:31:02] <bjz> dbaupp: I get so confuzed by that
[11:31:07] * dbaupp really should experiment with/get the source of servo sometime
[11:31:18] <dbaupp> bjz: the params? yup
[11:31:36] <bjz> rusti: ApproxEq::approx_epsilon::<f64>()
[11:31:43] -rusti- pastebinned 7 lines of output: http://ix.io/7Mh
[11:31:47] <bjz> rusti: ApproxEq::approx_epsilon::<f64,f64>()
[11:31:50] -rusti- pastebinned 10 lines of output: http://ix.io/7Mi
[11:31:57] <dbaupp> it's particularly annoying when you only need to specify one set (e.g. just the Self type, or just X Y) and are forced to type everything :/
[11:31:57] <SimonSapin> dbaupp: rust-io-surface rust-core-graphics rust-core-foundation rust-core-text
[11:32:08] <bjz> rusti: ApproxEq::approx_epsilon::<f64,f64,f64>()
[11:32:11] -rusti- pastebinned 10 lines of output: http://ix.io/7Mj
[11:32:20] <dbaupp> SimonSapin: used extensively in them?
[11:32:24] <bjz> D:<
[11:32:24] <dbaupp> bjz: that will never work
[11:32:36] <dbaupp> bjz: the Self syntax has been disappeared
[11:32:50] <SimonSapin> dbaupp: grep gives 19 lines
[11:32:51] <bjz> rusti: ApproxEq::<f64>::approx_epsilon::<f64>()
[11:32:54] -rusti- pastebinned 7 lines of output: http://ix.io/7Mk
[11:33:00] <bjz> dbaupp: ohhh
[11:33:05] <bjz> dbaupp: so that's why
[11:33:10] <dbaupp> rusti: let tmp: f64 = ApproxEq::approx_epsilon::<f64>(); tmp
[11:33:12] -rusti- pastebinned 7 lines of output: http://ix.io/7Ml
[11:33:17] <bjz> heh
[11:33:27] <dbaupp> wat
[11:33:45] <dbaupp> rusti: let tmp: f64 = ApproxEq::approx_epsilon(); tmp
[11:33:46] -rusti- <anon>:5:24: 5:48 error: cannot determine a type for this bounded type parameter: unconstrained type
[11:33:46] -rusti- <anon>:5          let tmp: f64 = ApproxEq::approx_epsilon(); tmp
[11:33:46] -rusti-                                  ^~~~~~~~~~~~~~~~~~~~~~~~
[11:33:46] -rusti- application terminated with error code 101
[11:34:00] <bjz> rusti: ApproxEq::<f64,f64>::approx_epsilon()
[11:34:01] *** Quits: Ms2ger (Ms2ger@F84917BA.3387515C.187A1082.IP) (Quit: bbl)
[11:34:03] <dbaupp> ok; it's literally not possible to call that function
[11:34:03] -rusti- pastebinned 10 lines of output: http://ix.io/7Mm
[11:34:07] <bjz> :P
[11:34:10] <dbaupp> :(
[11:34:20] <dbaupp> it needs the Option<Self> trick/hack
[11:34:31] <bjz> that sucks :(
[11:35:06] <bjz> rusti: Real::pi::<float>()
[11:35:08] -rusti- pastebinned 7 lines of output: http://ix.io/7Mn
[11:35:25] <bjz> rusti: Real::<float>::pi()
[11:35:29] -rusti- pastebinned 10 lines of output: http://ix.io/7Mo
[11:35:46] <dbaupp> rusti: let tmp: float = Real::pi(); tmp
[11:35:48] -rusti- 3.14159265
[11:36:10] <dbaupp> it's only the static methods that don't return Self (or something with Self in it) that are unpossible
[11:36:35] <bjz> we'll have that issue with associated items
[11:36:50] <bjz> they are basically associated functions
[11:37:08] <dbaupp> it'll be fixed soon
[11:37:11] * dbaupp lives in hope
[11:40:53] *** Joins: pyrac (pyrac@DFC5DF94.73C89388.AD05C589.IP)
[11:43:15] <bjz> dbaupp: ahh https://github.com/mozilla/rust/blame/master/src/libstd/num/f64.rs#L206
[11:43:34] <bjz> dbaupp: was wondering how std::num still compiled
[11:43:35] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[11:48:34] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[11:49:24] *** Quits: sk (sk@76BFB31C.71F9CB99.78DD174B.IP) (Quit: Leaving)
[11:50:14] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[11:53:44] *** Quits: mama (myat@77487EB8.16540EFD.5138F352.IP) (Quit: )
[12:07:34] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[12:10:58] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[12:12:56] *** Joins: lenstr (lenstr@E0E80B8D.ED45D46B.DFEAE789.IP)
[12:13:15] *** Quits: sebcrozet (sebcrozet@moz-7FB6C00B.w193-252.abo.wanadoo.fr) (Ping timeout)
[12:15:25] *** Quits: lenstr (lenstr@E0E80B8D.ED45D46B.DFEAE789.IP) (Client exited)
[12:15:55] *** Joins: lenstr (lenstr@E0E80B8D.ED45D46B.DFEAE789.IP)
[12:16:04] *** Quits: lenstr (lenstr@E0E80B8D.ED45D46B.DFEAE789.IP) (Client exited)
[12:18:42] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[12:20:22] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[12:21:58] *** Quits: tav (tav@moz-C302A43C.range86-149.btcentralplus.com) (Connection reset by peer)
[12:24:57] <dbaupp> src/test/run-pass/infinite-loops.rs, what a peculiar test
[12:25:09] * dbaupp doesn't see how that test could ever finish
[12:26:02] *** Joins: tav (tav@moz-C302A43C.range86-149.btcentralplus.com)
[12:26:48] *** Joins: sebcrozet (Thunderbir@moz-7FB6C00B.w193-252.abo.wanadoo.fr)
[12:26:56] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[12:27:04] *** Joins: spider-mario (spidermari@moz-2F72F6FF.dsl.quantic-telecom.net)
[12:27:30] <cmr> Eridius: Yes. emi, traots are brplem/
[12:27:50] <cmr> hm
[12:27:54] <cmr> enum traits are broken
[12:28:25] <dbaupp> cmr: I think your keyboard is an enum trait :P
[12:28:37] <cmr> dbaupp: just my fingers :P
[12:29:09] <kimundi> you're typing with broken fingers? ouch
[12:30:03] *** Joins: sk (sk@61A494B3.BA40E8A.AAC02D62.IP)
[12:30:44] <cmr> most hand damage I've typed with is sprain
[12:32:03] <cmr> https://github.com/mozilla/rust/issues/4259#issuecomment-23643198
[12:33:09] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[12:33:54] *** Quits: tikue_ (tkuehn@moz-424BC304.hsd1.pa.comcast.net) (Quit: tikue_)
[12:41:25] *** Quits: squiddy_ (squiddy@moz-4236ED38.adsl.alicedsl.de) (Input/output error)
[12:45:08] *** Joins: squiddy (squiddy@moz-4236ED38.adsl.alicedsl.de)
[12:45:59] *** Quits: sebcrozet (Thunderbir@moz-7FB6C00B.w193-252.abo.wanadoo.fr) (Ping timeout)
[12:46:05] *** Joins: sebcrozet (Thunderbir@moz-C27D92D8.w193-252.abo.wanadoo.fr)
[12:49:02] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[12:51:39] <bjz> dbaupp: hawp, that test is funny
[12:52:05] <bjz> "Commenting this out, as this will hang forever otherwise. Even after seeing the comment above, I'm not sure what the intention of this test is."
[12:56:27] *** Quits: Shaladdle (Shaladdle@moz-424BC304.hsd1.pa.comcast.net) (Quit: Leaving)
[13:00:53] *** Joins: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net)
[13:05:20] *** Joins: Earnestly (earnest@moz-F387F877.dyn.plus.net)
[13:06:03] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[13:07:39] *** Quits: victorporof (victorporo@9D964D4D.36D485C.2B3D3D4.IP) (Quit: victorporof)
[13:07:44] *** Joins: hellmage (luyun@9276F686.13582C43.8395810B.IP)
[13:07:52] *** Quits: lerc (quassel@B2E8CAD3.A8D14E52.788638A4.IP) (Ping timeout)
[13:10:41] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[13:12:19] *** Joins: tikue_ (tkuehn@moz-FEADCD38.hsd1.pa.comcast.net)
[13:14:05] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[13:15:00] *** Quits: sonwow (sonwow@5AB4884B.FCC4549.14D5B978.IP) (Quit: Lost terminal)
[13:15:51] <tikue_> when pattern matching against a vector, you always get a slice right?
[13:16:39] *** Quits: m_kato (m_kato@moz-C286AD9A.bitcat.net) (Quit: Leaving...)
[13:17:32] <dbaupp> tikue_: for the .. match, mostly
[13:17:49] <dbaupp> (it doesn't work with mutable vectors)
[13:17:59] <tikue_> dbaupp: ok, thank you. i'm trying to write an "elegant" merge sort, but i'm trying to avoid copying best i can
[13:18:04] <tikue_> just for funsies
[13:19:09] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[13:19:33] *** Quits: pyrac (pyrac@DFC5DF94.73C89388.AD05C589.IP) (Quit: pyrac)
[13:20:46] *** Joins: lerc (quassel@B2E8CAD3.A8D14E52.788638A4.IP)
[13:20:49] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[13:26:06] *** Quits: tikue_ (tkuehn@moz-FEADCD38.hsd1.pa.comcast.net) (Quit: tikue_)
[13:29:24] *** Joins: tikue_ (tkuehn@moz-FEADCD38.hsd1.pa.comcast.net)
[13:31:24] *** Joins: Palmik (palmik@moz-CC484FDD.tmcz.cz)
[13:39:47] <dbaupp> https://github.com/mozilla/rust/pull/8932 r?
[13:41:57] <dbaupp> cmr: thanks
[13:42:09] <cmr> dbaupp: no, thank you!
[13:42:42] *** Joins: pepper_chico (pepper_chi@AA55BC4F.B300DF31.F546FA5F.IP)
[13:43:10] <dbaupp> cmr: never! you're the one to be thanked
[13:43:41] <cmr> So I'm trying to write a simple kernel in Rust, https://github.com/cmr/cmoss/
[13:44:06] <dbaupp> "cmoss"?
[13:44:19] * dbaupp doesn't understand the lack of oxidisation puns
[13:44:35] <dbaupp> in any case, awesome! :)
[13:44:53] *** Quits: oBex (darryl@moz-DDDD2CB8.nyc.res.rr.com) (Quit: Leaving)
[13:45:08] <cmr> oxidation puns are in short supply unfortunately.
[13:45:32] <cmr> Anyway https://github.com/cmr/cmoss/blob/master/kernel/x64/kernel.rs, it calls to __morestack
[13:45:45] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[13:45:45] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/SS3N7A
[13:45:45] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[13:45:47] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[13:45:47] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/yiaUtg
[13:45:47] <ghrust> 13rust/06auto 149dd723d 15Huon Wilson: Un-xfail/move/delete some tests.
[13:45:47] <ghrust> 13rust/06auto 144ed6014 15Huon Wilson: Add tests for 2 fixed issues....
[13:45:47] <ghrust> 13rust/06auto 14dc3cdc4 15bors: auto merge of #8932 : huonw/rust/closed-issues, r=cmr
[13:45:49] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[13:45:54] <cmr> which is obviously kinda a problem in a bare metal environment
[13:46:03] *** Quits: tikue_ (tkuehn@moz-FEADCD38.hsd1.pa.comcast.net) (Quit: tikue_)
[13:46:34] <dbaupp> you can just define __morestack to be a noop, right?
[13:46:44] <dbaupp> which kinda sorta maybe gets around the problem
[13:46:55] <cmr> It compiles into https://gist.github.com/cmr/1745636a5a06bea0c13a
[13:47:11] <cmr> Line 8 confuzzles me
[13:47:25] <cmr> dbaupp: I'd rather like to avoid stack growth entirely, as I won't have it at all.
[13:47:30] <dbaupp> rusti: #[no_mangle] fn __morestack() { } 
[13:47:30] -rusti- ()
[13:47:48] <cmr> defining it as a noop works around it but will fail in mysterious ways if I actually overflow the stack
[13:47:51] <dbaupp> cmr: right, but it's probably not possible as it stands
[13:47:58] <dbaupp> isn't that always the case?
[13:48:12] <dbaupp> overflowing the stack without guards does bad things.
[13:48:16] <cmr> yes, but I have no idea what rust assumes about its runtime environment.
[13:48:37] <cmr> (this is part of my work on runtimeless/profile-based libstd)
[13:48:43] <cmr> (as well as a toy OS project :p)
[13:48:59] *** Joins: tikue_ (tkuehn@moz-FEADCD38.hsd1.pa.comcast.net)
[13:49:35] <cmr> It looks like it's storing the stack size in TLS
[13:49:40] <cmr> (which is what the fs segment is used for)
[13:51:02] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Quit: Leaving)
[13:51:44] *** Joins: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca)
[13:52:58] <tikue_> rusti: match [1] { [_, ..tl] => printfln!(tl), _ => () }
[13:52:59] -rusti- <anon>:5:49: 5:50 error: unreachable pattern
[13:52:59] -rusti- <anon>:5          match [1] { [_, ..tl] => printfln!(tl), _ => () }
[13:52:59] -rusti-                                                           ^
[13:52:59] -rusti- error: aborting due to previous error
[13:53:00] -rusti- application terminated with error code 101
[13:53:03] <cmr> well, fixed_stack_segment did interesting things.
[13:53:10] <tikue_> rusti: match &[1] { [_, ..tl] => printfln!(tl), _ => () }
[13:53:11] -rusti- &[]
[13:53:11] -rusti- ()
[13:54:13] <dbaupp> cmr: "interesting"?
[13:54:17] *** Joins: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net)
[13:54:49] <cmr> http://ix.io/7Mz
[13:54:55] <cmr> I have no idea what it's doing anymore :p
[13:55:03] <tikue_> rusti: match &&[1] { [_, ..tl] => printfln!(tl), _ => () }
[13:55:04] -rusti- <anon>:5:15: 5:17 error: unexpected token: `&&`
[13:55:04] -rusti- <anon>:5          match &&[1] { [_, ..tl] => printfln!(tl), _ => () }
[13:55:04] -rusti-                         ^~
[13:55:04] -rusti- application terminated with error code 101
[13:55:08] <dave1629> The Rust grammar in the manual uses "block" many times, but I can't find any actual definition of block : ??.
[13:55:17] <tikue_> rusti: match & &[1] { [_, ..tl] => printfln!(tl), _ => () }
[13:55:17] -rusti- <anon>:5:24: 5:33 error: mismatched types: expected `&&[<VI0>]` but found a vector pattern
[13:55:17] -rusti- <anon>:5          match & &[1] { [_, ..tl] => printfln!(tl), _ => () }
[13:55:17] -rusti-                                  ^~~~~~~~~
[13:55:17] -rusti- error: aborting due to previous error
[13:55:17] -rusti- application terminated with error code 101
[13:55:26] <cmr> dave1629: the grammar is incomplete andlikely out of date.
[13:55:27] <tikue_> rusti: match & &[1] { &[_, ..tl] => printfln!(tl), _ => () }
[13:55:28] -rusti- &[]
[13:55:28] -rusti- ()
[13:55:48] <tikue_> dave1629: a block is { â€¦ }
[13:56:05] <olsonjeffery> acrichto: ping
[13:56:18] <tikue_> anything declared in a block is scoped to the block
[13:56:49] <olsonjeffery> rusti: 4+3
[13:56:50] -rusti- 7
[13:56:50] <dave1629> I don't think it is used to include the {'s: if_expr : "if" expr '{' block '}' ...
[13:57:15] <tikue_> dave1629: well that's the syntax for an if expression, which requires braces
[13:57:17] <dave1629> seems like it is something like block : statements? expr
[13:57:49] <dbaupp> dave1629: probably closer to `statements* expr?` (I guess?)
[13:58:28] <tikue_> rusti: let two = 3; { let two = 2; } two
[13:58:28] -rusti- <anon>:5:28: 5:31 warning: unused variable: `two` [-W unused-variable (default)]
[13:58:28] -rusti- <anon>:5          let two = 3; { let two = 2; } two
[13:58:28] -rusti-                                      ^~~
[13:58:29] -rusti- 3
[13:58:31] <dave1629> Is the end expr necessary?  My understanding is a block is an expr and its value is the value of the last expr?
[13:58:46] <Palmik> Hmm. Rust probably does not support multiparameter traits, right?
[13:59:42] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[13:59:46] <dbaupp> rusti: trait Foo<T, U> { fn bar(&self); } impl Foo<int, uint> for ~str { fn bar(&self) { } } // Palmik?
[13:59:47] -rusti- ()
[14:00:42] <Palmik> Yes, like that! I did not find it in the doc and when I tried it I placed the type variable right after 'trait'.
[14:00:43] <dbaupp> dave1629: not really, `{}` is a valid block, as is something like ` { fn foo() {} }` or `{ print("foo"); }`
[14:00:45] <Palmik> Thanks.
[14:01:18] <dbaupp> dave1629: (in all those cases the block is still an expr, and has value & type ().)
[14:01:23] <dave1629> dbaupp I see, thanks!  This make sense, it will just have type (), and could lead to compile errors
[14:01:59] <Palmik> dave1629: it actually is in the manual, I was looking at the tutorial.
[14:02:11] <Palmik> upps, I meant dbaupp, sorry.
[14:02:29] <tikue_> dbaupp: the fact that a function's block doesn't require two sets of braces, is that just sugar?
[14:02:48] <tikue_> or in if-expr or the like
[14:02:50] <dbaupp> tikue_: what/where/when/why?
[14:02:59] <dbaupp> I don't understand the question?
[14:03:03] <tikue_> dbaupp: fn foo() { /* stuff */ }
[14:03:09] <tikue_> the braces are part of the function grammar
[14:03:17] <tikue_> and inside there is a block that technically doesn't have its own braces
[14:03:23] <Palmik> dbaupp: probably whther foo() /* one line stuff */ is legal.
[14:03:31] <tikue_> Palmik: it's not
[14:03:35] <tikue_> Palmik: unless it's a closure
[14:03:40] <Palmik> Therefore it's not just sugar.
[14:04:01] <dbaupp> tikue_: oh, I think the manual's grammar implicitly defines `block` to not have the {} (is that what you're asking?)
[14:04:31] <tikue_> dbaupp: then what is it called when you use { } around something to locally scope it? is that not a block?
[14:04:43] <dbaupp> I guess so
[14:04:53] <dbaupp> (i guess it is a block, that is.)
[14:04:58] <tikue_> yea hm
[14:05:23] <dbaupp> (looking for consistency in the manual's grammar is bad: it's entirely wrong in many places.)
[14:05:40] <tikue_> hehe
[14:07:08] *** Joins: samx (sami@moz-D9DA5773.dyn.optonline.net)
[14:07:20] <tikue_> anyone know how much slower recursive merge is compared to an imperative merge? (mergesort merge, i mean)
[14:07:52] <dbaupp> tikue_: I guess #[bench] would know ;P
[14:08:09] <tikue_> dbaupp: oo, how does #[bench] work?
[14:08:15] <tikue_> rust bench foo?
[14:08:20] <dbaupp> https://github.com/mozilla/rust/wiki/Doc-unit-testing#benchmarking
[14:08:59] <dbaupp> Don't know if there's `rust bench` sugar yet, but `rust --test foo.rs; foo --bench` definitely works
[14:09:00] <tikue_> oh thank you!
[14:10:50] *** Joins: vodik (simon@moz-CBE4BB13.cable.teksavvy.com)
[14:11:15] *** Quits: samx (sami@moz-D9DA5773.dyn.optonline.net) (Quit: This computer has gone to sleep)
[14:12:57] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[14:13:31] *** Quits: tikue_ (tkuehn@moz-FEADCD38.hsd1.pa.comcast.net) (Quit: tikue_)
[14:13:46] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[14:17:40] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Quit: Lost terminal)
[14:17:58] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[14:18:01] *** Joins: pyrac (pyrac@moz-DD0FB000.math.u-bordeaux1.fr)
[14:18:09] <darkf> there isn't a way to add data members to traits, or subtype structs, is there? because otherwise i have to duplicate some accessors across impls, which is ugly :\
[14:18:44] <kimundi> both don't work, yeah
[14:19:02] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[14:19:34] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[14:19:36] <darkf> that's rather unfortunate
[14:21:14] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[14:22:43] <unfoldl> Is it possible to make Rust run multiple test files at once? or create a main test file which includes all other test files?
[14:22:47] <unfoldl> I have two test files, `test/foo_test.rs` and `test/bar_test.rs`, which I'm currently running as `rust test test/foo_test.rs` and `rust test test/bar_test.rs`.
[14:23:12] <olsonjeffery> unfoldl: yes, it is
[14:23:28] <olsonjeffery> libstd, libextra are structured that
[14:23:36] <kimundi> Well, if you make the test module part of the crate itself you only have to runt rust test once, and it will test the tests in parallel
[14:24:09] <olsonjeffery> or have a test_main.rs or something
[14:24:25] <olsonjeffery> that pulls the foo_test and bar_test modules in
[14:25:41] <unfoldl> olsonjeffery: yes, that worked, thanks!
[14:28:53] <olsonjeffery> it would actually be really nice if all of the tests in std/extra were structured that way..
[14:29:03] <olsonjeffery> well, i guess there's tradeoffs in each approach
[14:29:24] <olsonjeffery> but doing make-check-stage1 and then not discovering something is wrong in a #[test]-annotated fn until the very last time is brutal
[14:30:04] <olsonjeffery> but doing tests in-module gives access to testing non-exported functions and other conveniences
[14:30:21] <olsonjeffery> and the rust testing discipline isn't really hardcore into testing just the public api, afaik
[14:30:33] *** Joins: tautologico (lymph@8ABDEDA.34CAB63A.7B974E06.IP)
[14:30:56] *** Quits: threecreepio (jdp@moz-1A9F0A3C.cust.bredband2.com) (Quit: threecreepio)
[14:31:31] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[14:34:00] *** Joins: halorgium (z@moz-7A333983.spork.in)
[14:35:48] *** Quits: Nisstyre (wes@moz-FD86289.netflash.net) (Client exited)
[14:36:10] *** Joins: Ms2ger (Ms2ger@B7B2FF50.C60A97A6.F9FB0584.IP)
[14:43:32] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[14:44:08] <engla> unfoldl: I gave you that iterator comment on the parser on reddit. pretty fun thing, you can even nest parsers
[14:44:33] *** Joins: adridu59 (Mibbit@moz-6C393FDD.rev.numericable.fr)
[14:49:31] *** Quits: adridu59 (Mibbit@moz-6C393FDD.rev.numericable.fr) (Quit: http://www.mibbit.com ajax IRC Client)
[14:50:14] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[14:53:02] *** Quits: fabiand (fabiand@moz-B43CF293.adsl.alicedsl.de) (Quit: Verlassend)
[14:54:04] *** Joins: victorporof (victorporo@9D964D4D.36D485C.2B3D3D4.IP)
[14:55:33] *** Joins: victorporof_ (victorporo@9D964D4D.36D485C.2B3D3D4.IP)
[14:56:26] *** Joins: RogueVector (victorporo@9D964D4D.36D485C.2B3D3D4.IP)
[14:56:30] *** Quits: victorporof (victorporo@9D964D4D.36D485C.2B3D3D4.IP) (Ping timeout)
[14:57:21] *** Joins: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net)
[14:57:43] *** Quits: victorporof_ (victorporo@9D964D4D.36D485C.2B3D3D4.IP) (Ping timeout)
[14:58:34] <SiegeLord> Hmm... clone must return Self, eh?
[15:00:44] <engla> of course
[15:04:02] *** Joins: adridu59 (Mibbit@moz-6C393FDD.rev.numericable.fr)
[15:04:06] <adridu59> https://github.com/mozilla/rust/pull/8901
[15:04:23] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[15:05:19] <adridu59> its a bit odd, I mean those bors build failures... is it something that will be fixed?
[15:05:41] <SiegeLord> I guess I'll call it copy() then
[15:05:54] <SiegeLord> It's essentially going from &[] back to []
[15:06:06] <SiegeLord> What does Rust call that operation?
[15:06:20] <engla> .to_owned() for &[T] to ~[T]
[15:06:50] <engla> rusti: [1].to_owned()
[15:06:51] -rusti- ~[1]
[15:07:36] *** Joins: io2 (io2@moz-A6202C16.home.otenet.gr)
[15:08:10] *** Joins: samx (sami@moz-D9DA5773.dyn.optonline.net)
[15:08:40] <benh> rusti: (~"foo") as &str
[15:08:41] -rusti- <anon>:5:9: 5:25 error: non-scalar cast: `~str` as `&str`
[15:08:41] -rusti- <anon>:5          (~"foo") as &str
[15:08:41] -rusti-                   ^~~~~~~~~~~~~~~~
[15:08:41] -rusti- error: aborting due to previous error
[15:08:41] -rusti- application terminated with error code 101
[15:08:45] *** Quits: Ms2ger (Ms2ger@B7B2FF50.C60A97A6.F9FB0584.IP) (Ping timeout)
[15:08:49] <benh> how do you go the other way explicitly?
[15:11:28] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[15:12:06] <pnkfelix> benh: You can just pass an ~str to a function that takes a &str
[15:12:18] <pnkfelix> rusti: let s = ~"foo"; fn f(x:&str) -> ~str { x.to_owned() + x }; f(s)
[15:12:19] -rusti- ~"foofoo"
[15:12:33] <benh> but that's implicitly :(
[15:13:09] <pnkfelix> benh: What's your goal here?
[15:14:09] <benh> I don't remember :( I was just reminded that I was wondering about this a while ago
[15:15:14] <pnkfelix> benh: This option is probably just as implicit, but maybe you'll like it better:
[15:15:21] <pnkfelix> rusti: let s = ~"foo"; let t : &str = s; let u = t.to_owned() + t; u
[15:15:22] -rusti- ~"foofoo"
[15:15:27] <adridu59> how can I do a pause in Rust? like halt till the user presses enter
[15:16:14] <engla> benh: .as_slice()
[15:16:24] <tiffany> adridu: you can do stdin().read_line()
[15:16:43] <engla> rusti: println!("{:?}", (~"hi there").as_slice())
[15:16:47] -rusti- pastebinned 23 lines of output: http://ix.io/7MG
[15:16:57] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[15:17:07] <engla> oh well
[15:17:25] <pnkfelix> rusti: let s = ~"foo"; let t = s.as_slice(); let u = t.to_owned() + t; u
[15:17:26] -rusti- ~"foofoo"
[15:17:41] <pnkfelix> you need to ensure the borrowed reference does not outlive the owned reference
[15:17:55] <pnkfelix> (this is in part why I was wondering what benh's goal was)
[15:20:01] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[15:20:21] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[15:21:21] *** Quits: pyrac (pyrac@moz-DD0FB000.math.u-bordeaux1.fr) (Ping timeout)
[15:21:41] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[15:24:58] *** Joins: Ms2ger (Ms2ger@B7B2FF50.C60A97A6.F9FB0584.IP)
[15:25:22] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[15:25:31] <benh> i'm surprised that rust temporaries don't live as long as C++ ones, ie to the next ;
[15:25:39] <benh> but I guess semicolons aren't as big a deal in rust
[15:25:51] <pnkfelix> benh: there's an issue open for this
[15:26:02] <pnkfelix> benh: (or maybe just a blog post of Niko's, let me check)
[15:26:18] *** Quits: adridu59 (Mibbit@moz-6C393FDD.rev.numericable.fr) (Quit: http://www.mibbit.com ajax IRC Client)
[15:26:33] <benh> i see there is https://github.com/mozilla/rust/issues/3511 
[15:26:51] <pnkfelix> benh: that's it
[15:34:43] <benh> I hope we end up with some innermost-enclosing-statement rules, I don't like let x = &foo(); ;)
[15:35:21] *** Joins: boredomist (user@moz-63CF9F31.res-cmts.sesp.ptd.net)
[15:37:36] *** Joins: nano (nano@moz-74CAD1CA.superkabel.de)
[15:47:10] *** Joins: threecreepio (jdp@moz-71E164C9.cust.bredbandsbolaget.se)
[15:47:54] <engla> what about  foo(&mut 2)  ?
[15:48:14] <engla> I guess that one is ok
[15:52:26] *** Quits: hellmage (luyun@9276F686.13582C43.8395810B.IP) (Quit: Leaving.)
[15:52:49] *** Parts: sebcrozet (Thunderbir@moz-C27D92D8.w193-252.abo.wanadoo.fr) ()
[15:53:06] *** Quits: tupshin (quassel@moz-E7B03838.c3-0.nyr-ubr1.nyr.ny.cable.rcn.com) (Ping timeout)
[15:56:08] *** Quits: pepper_chico (pepper_chi@AA55BC4F.B300DF31.F546FA5F.IP) (Quit: Textual IRC Client: www.textualapp.com)
[15:59:42] *** Quits: Ms2ger (Ms2ger@B7B2FF50.C60A97A6.F9FB0584.IP) (Ping timeout)
[15:59:53] *** Quits: nano (nano@moz-74CAD1CA.superkabel.de) (Connection reset by peer)
[16:02:21] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[16:11:36] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[16:12:11] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[16:12:30] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[16:12:47] <jmgrosen> so what does `-Z jit` do?
[16:16:12] <SiegeLord> Oh damn... you can't return an option from a clone either...
[16:17:09] <engla> hehe SiegeLord what are you trying to do?
[16:17:39] <SiegeLord> Well, write a clone function... but since it can fail I can't actually implement the Clone trait
[16:17:43] <SiegeLord> Not a big deal, I guess
[16:20:02] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[16:20:06] *** Joins: victorporof (victorporo@9D964D4D.36D485C.2B3D3D4.IP)
[16:20:22] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[16:20:42] <kimundi> SiegeLord: Well, you can call 'fail!()' in your clone impl :P
[16:21:10] *** Quits: RogueVector (victorporo@9D964D4D.36D485C.2B3D3D4.IP) (Ping timeout)
[16:21:22] <SiegeLord> So call one method maybe_clone() and implement clone() via that?
[16:21:29] *** Joins: jdsanders (Adium@moz-84CB7548.hlrn.qwest.net)
[16:22:02] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[16:22:17] <kimundi> Maybe?
[16:22:47] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[16:22:48] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[16:24:14] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[16:25:59] *** Joins: miza (miza@moz-4DD51325.home.otenet.gr)
[16:26:05] <jdsanders> Hi folks, it looks like between 0.6 and 0.7, int::range went away (I'm guessing as part of the internal/external iterator stuff?), and I'm having trouble finding a good replacement for it - I see uint::iterator, but of course that gives me uints instead of ints - where should I be looking?
[16:27:39] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[16:28:38] <fread2281> jdsanders: just use range
[16:29:01] <Palmik> Did something change in 0.8 with respect to when "extern mod std;" is implicit?
[16:29:24] <fread2281> jdsanderare you on 0.7 or HEAD?
[16:30:02] <jdsanders> fread2281 âˆ’ 0.7
[16:30:11] <jdsanders> (although I also have HEAD, if there's a better way to do it there)
[16:31:14] <jdsanders> sorry, I'm not sure how to "use range" - if I just say literally range(0, 1000) I get an unresolved name - or do you mean `use range` like a crate named range
[16:31:25] <fread2281> jdsanders: on HEAH, just use range (in prelude from iterator)
[16:31:46] <fread2281> jdsanders: just range(0,1000) on HEAD
[16:31:59] <kimundi> Palmik: No
[16:32:29] <kimundi> Palmik: It's allways implicitly included in your crate, unless you disable it with a #[no_str]; attribute
[16:33:11] <kimundi> rusti: range(0, 10).to_owned_vec()
[16:33:11] -rusti- ~[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[16:33:25] <kimundi> rusti: range(0, 10).map(|x| x + 15).to_owned_vec()
[16:33:26] -rusti- ~[15, 16, 17, 18, 19, 20, 21, 22, 23, 24]
[16:34:11] *** Joins: Uther (Instantbir@moz-1B244B05.hfc.dyn.abo.bbox.fr)
[16:37:34] *** Quits: eevee (eevee@moz-9A8E1439.evrt.wa.frontiernet.net) (Connection reset by peer)
[16:37:43] *** Joins: eevee (eevee@moz-9A8E1439.evrt.wa.frontiernet.net)
[16:37:44] *** Quits: spider-mario (spidermari@moz-2F72F6FF.dsl.quantic-telecom.net) (Connection reset by peer)
[16:37:46] <jmgrosen> so anyone know what the JIT is about?
[16:38:13] <engla> the jit is used by rusti
[16:38:22] <jmgrosen> ah
[16:39:05] <engla> but for me it segfaults on almost any input at the moment
[16:39:11] <jmgrosen> :(
[16:39:34] <jmgrosen> on a completely different note, how does one tell rustpkg what libraries a package requires?
[16:39:40] <jdsanders> fread2281,kimundi: thanks! out of curiosity - how would you do it in 0.7?
[16:39:42] <cmr> jmgrosen: with extern mod
[16:40:11] <jmgrosen> cmr: and you put them in a lib/ directory, or something?
[16:40:21] <cmr> jmgrosen: no, it fetches and builds them itself.
[16:40:32] <jmgrosen> cmr: â€¦where does it fetch them from?
[16:40:38] <kimundi> jdsanders: I'm not sure if that range function existed in 0.7 already
[16:40:41] <cmr> jmgrosen: dependson the package id
[16:40:55] <cmr> right now it knows how to use git.
[16:41:25] <engla> jdsanders: in 0.7 you need int::range
[16:41:37] <jmgrosen> cmr: say I require glfw-rs. do I just do "extern mod glfw-rs;" and it magically knows where to get it from, or what?
[16:41:44] <fread2281> engla: there is none
[16:41:58] <fread2281> jdsanders: it's probably uint::iterate
[16:42:06] <cmr> jmgrosen: extern mod glfw = "github.com/bjz/glfw-rs.git" or something like that.
[16:42:11] *** Quits: vodik (simon@moz-CBE4BB13.cable.teksavvy.com) (Ping timeout)
[16:42:13] <jmgrosen> cmr: ah, got it now
[16:42:13] <engla> it should be  std::int::range
[16:42:15] <jmgrosen> cmr: thanks
[16:42:18] <engla> std::uint::range etc
[16:43:02] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[16:43:40] <Earnestly> Dumb question; why doesn't rust let us use unbraced bodies for single statements?
[16:43:53] <jdsanders> engla: it doesn't seem like std::int::range exists in 0.7
[16:44:00] <jdsanders> (though std::uint::range definitely does)
[16:44:16] <jdsanders> http://static.rust-lang.org/doc/0.7/std/int.html
[16:45:31] <kimundi> Earnestly: you mean like 'if foo() bar();' ?
[16:45:49] <jdsanders> i could actually change what I have to std::uint::range because I'm not using negative numbers, but then I have to deal with all my type signatures being wrong, and of course, if I *did* have negative numbers, I'm not sure what I'd do
[16:46:25] <cmr> Earnestly: because then you would need parenthesis to disambiguate the conditional expression
[16:48:15] <engla> jdsanders: maybe not. it's in int_macros.rs
[16:48:40] <engla> jdsanders: so it should be there
[16:53:56] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[16:54:38] <jdsanders> hmm, yeah, looks like you're right - I was relying on docs
[16:54:39] <jdsanders> thanks
[16:55:10] <engla> I knew there were there but indeed they are not in the docs
[16:55:27] <engla> because they are expanded from a macro for i8 to int
[16:55:50] <jdsanders> gotcha, oh well - I prefer the HEAD way anyway
[16:56:24] <engla> of course. everyone who doesn't has been banished from the land
[16:56:33] <jdsanders> haha
[16:57:02] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[16:57:57] <jdsanders> also, I've been generally super impressed with the stability of HEAD, so it's easy to use it for actual things, which is awesome
[16:59:00] <cmr> All of our tests need to pass for a change to be merged into master
[16:59:12] *** Joins: lenstr (lenstr@E0E80B8D.ED45D46B.DFEAE789.IP)
[17:00:23] <SiegeLord> Well... all enabled tests ;)
[17:01:06] <SiegeLord> And sometimes things slip through the testing, like with the uncompressed metadata
[17:01:36] *** Quits: lenstr (lenstr@E0E80B8D.ED45D46B.DFEAE789.IP) (Client exited)
[17:02:00] <SiegeLord> Let's see what the initial commit of Rust looked like...
[17:02:02] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[17:02:21] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[17:03:43] <Thiez> does a rust 'finally' block always run, even when a task is caused to fail from the outside?
[17:05:51] *** Quits: CarpNet (ac@moz-FD24B77.sohonet.co.uk) (Quit: Leaving)
[17:06:05] <Palmik> Hmm, how could I go about transforming 'fn (&[u8]) -> bool' into 'extern "C" fn(*c_uchar, size_t) -> c_int'?
[17:06:08] <kimundi> afaik the finally is implemented with a destructor, which run during task unwinding, so I'd say 'yes'
[17:06:32] <Palmik> Rust does not support currying, right?
[17:06:38] <kimundi> nope
[17:06:39] <Thiez> kimundi: that's what I thought, however... what if the task failure occurs during the destructor?
[17:06:54] <Thiez> or are destructors immune from external task failure?
[17:06:58] <kimundi> Thiez: That's not yet celarly defined/decided/implemented
[17:07:26] <sfackler> the process aborts right now iirc
[17:07:50] *** Quits: samx (sami@moz-D9DA5773.dyn.optonline.net) (Quit: This computer has gone to sleep)
[17:08:07] <kimundi> Acording to the manual, it would enter a 'best efford' mode where unwinding continues, but no destructors are run anymore. But afaik right now that doesn't work that way. I think it just aborts
[17:09:00] <jdsanders> What's the idiomatic way to do something like 10.times now? `for _ in range(0, 10)` works fine, but seems a bit chatty
[17:09:06] <Thiez> I think it might be useful to define the behaviour
[17:09:16] <kimundi> rusti: strucht Foo; impl Drop for Foo{ fn drop(&self) { println("destroyed"); } }; {let x = ~Foo; } "test"
[17:09:17] -rusti- <anon>:5:17: 5:20 error: expected one of `; }` but found `Foo`
[17:09:17] -rusti- <anon>:5          strucht Foo; impl Drop for Foo{ fn drop(&self) { println("destroyed"); } }; {let x = ~Foo; } "test"
[17:09:17] -rusti-                           ^~~
[17:09:17] -rusti- application terminated with error code 101
[17:09:25] <kimundi> rusti: struct Foo; impl Drop for Foo{ fn drop(&self) { println("destroyed"); } }; {let x = ~Foo; } "test"
[17:09:26] -rusti- <anon>:5:89: 5:90 warning: unused variable: `x` [-W unused-variable (default)]
[17:09:26] -rusti- <anon>:5          struct Foo; impl Drop for Foo{ fn drop(&self) { println("destroyed"); } }; {let x = ~Foo; } "test"
[17:09:26] -rusti-                                                                                                   ^
[17:09:26] -rusti- destroyed
[17:09:28] -rusti- "test"
[17:09:31] <cmr> Thiez: destructors cannot fail.
[17:09:36] <kimundi> rusti: struct Foo; impl Drop for Foo{ fn drop(&self) { fail!("destroyed"); } }; {let x = ~Foo; } "test"
[17:09:36] -rusti- <anon>:5:87: 5:88 warning: unused variable: `x` [-W unused-variable (default)]
[17:09:37] -rusti- <anon>:5          struct Foo; impl Drop for Foo{ fn drop(&self) { fail!("destroyed"); } }; {let x = ~Foo; } "test"
[17:09:37] <Thiez> rusti: do 2.times { println("hai"); }
[17:09:39] <cmr> If they fail, undefined behavior results.
[17:09:40] -rusti-                                                                                                 ^
[17:09:41] *** Joins: pyrac (pyrac@moz-30AD8801.w90-60.abo.wanadoo.fr)
[17:09:43] -rusti- task <unnamed> failed at 'destroyed', <anon>:5
[17:09:45] -rusti- application terminated with error code 101
[17:09:46] -rusti- hai
[17:09:46] <Thiez> jdsanders: ^
[17:09:48] -rusti- hai
[17:09:50] -rusti- ()
[17:09:52] <jdsanders> Thiez: ah, was missing the `do` part like a dummy
[17:09:53] <jdsanders> thanks
[17:10:02] <Thiez> np, it used to be 'for' I think
[17:10:13] <jdsanders> yeah, but `for` expects an `in` now
[17:10:17] <cmr> Thiez: Part of the motivation of the effect system was having a way to assert and verify that destructors do not fail.
[17:10:17] <jdsanders> so do is the thing
[17:10:56] <Thiez> cmr: that's nice, but I don't think most people are going to be annotating their functions with effects
[17:11:40] <Thiez> and unsafe destructors are pretty nice to have...
[17:11:41] <cmr> Thiez: that's part of the design goal of the feature.
[17:11:43] <cmr> "A user who doesn't care about effects in their code should not have to write any effect annotations."
[17:11:48] <cmr> Well, unsafe is unsafe.
[17:11:58] <Thiez> I like my unsafe :p
[17:13:17] <Thiez> especially as a malloc replacement, allocate with ~, then transmute to *mut, and when you want to free, simply transmute it back to ~ and have the drop glue eat it :)
[17:15:03] *** Quits: jdsanders (Adium@moz-84CB7548.hlrn.qwest.net) (Quit: Leaving.)
[17:16:17] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[17:16:37] <Thiez> anyway, it would be nice to have a 'always execute this code, even when there is some external task failure' block
[17:17:35] <kimundi> well, that is finally
[17:17:47] <kimundi> closes you can get
[17:17:52] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Ping timeout)
[17:17:59] <Thiez> rusti: struct Foo; impl Drop for Foo{ fn drop(&self) { loop{}; } }; {let _x = Foo; } "test" // <- bad destructor :p
[17:18:04] -rusti- timeout triggered!
[17:18:20] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[17:18:42] <kimundi> Well, "Don't do that" :)
[17:18:46] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[17:18:46] <Thiez> ok, I'll try and use that
[17:19:00] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[17:19:47] <Thiez> I'm asking because the (very nice) concurrent mpsc queue that was suggested as a messagequeue replacement has a possibility of breaking the queue when one of the producers stops executing at a very specific point
[17:20:06] *** Joins: bytewise (bytewise@moz-4A801D04.unitymediagroup.de)
[17:20:08] *** Joins: test (Mibbit@moz-3868657C.cpe.netcabo.pt)
[17:20:41] <Thiez> would be bad for external task failure to interrupt there :p
[17:20:49] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[17:21:01] <test> hey guys, i can build rust 0.7 just fine but trying to build the one from github (master) i get error at configure: ./configure: 926: ./configure /rust-master/src/llvm/configure: not found
[17:21:08] <test> but works just fine with 0.7
[17:21:15] <cmr> Thiez: there's unkillable for that.
[17:21:28] *** Quits: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net) (Ping timeout)
[17:21:43] <Thiez> cmr: but it should be okay if I use finally right? If it were to work as advertised
[17:21:54] <cmr> I have no idea what finally does or how it works.
[17:22:12] <cmr> But if you need to complete an operation and can't be killed during it, unkillable is the way to go
[17:22:17] <Thiez> it runs a function in drop :)
[17:22:24] *** Joins: lenstr (lenstr@E0E80B8D.ED45D46B.DFEAE789.IP)
[17:22:29] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[17:23:12] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[17:23:13] <Thiez> I'll check out unkillable, if it's not too expensive it might be okay
[17:23:18] *** Joins: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net)
[17:24:40] *** Quits: threecreepio (jdp@moz-71E164C9.cust.bredbandsbolaget.se) (Quit: threecreepio)
[17:24:43] *** Joins: ofeldt- (ofeldt@moz-B08F1AF8.dip0.t-ipconnect.de)
[17:25:20] *** Quits: ofeldt (ofeldt@moz-21267FEC.dip0.t-ipconnect.de) (Ping timeout)
[17:25:42] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[17:26:05] <bblum> Thiez: the cost of unkillable is an atomic xchg at each end of the section
[17:26:14] <cmr> Ok, so that's really weird. There's no __morestack stuff in the LLVM rustc emits, but there is in the assembly when using -S.
[17:26:16] <bblum> unkillable can also fail at either end of the section
[17:26:19] <Thiez> that seems very acceptable.
[17:26:31] <bblum> Thiez: finally is also a fine option
[17:26:36] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[17:26:42] *** Quits: miza (miza@moz-4DD51325.home.otenet.gr) (Connection reset by peer)
[17:26:56] <Thiez> but I have a feeling unkillable has better guarantees
[17:28:25] <cmr> Where/when does morestack emission happen?
[17:29:08] *** Joins: adridu59 (Mibbit@moz-6C393FDD.rev.numericable.fr)
[17:29:19] *** Quits: adridu59 (Mibbit@moz-6C393FDD.rev.numericable.fr) (Quit: http://www.mibbit.com ajax IRC Client)
[17:29:36] <Luqman> cmr: in the function prologue i believe
[17:30:22] *** Joins: jdsanders (Adium@moz-84CB7548.hlrn.qwest.net)
[17:30:43] <cmr> Luqman: in trans, I mean
[17:31:27] <Palmik> I have a foo.rs, which is the crate root (of a library). Is it possible to prefix the module name (e.g. so that it becomes bar::baz::foo)?
[17:31:43] <test> i downloaded the master branch using "download as zip" but i get an error at configure: ./configure: 926: ./configure /rust-master/src/llvm/configure: not found but i built 0.7 just fine. anyone?
[17:31:52] <Palmik> Without creating too many *.rs files (ideally nony)
[17:32:01] <Palmik> s/nony/none/
[17:32:05] <Luqman> cmr: the calls to morestack are inserted by llvm
[17:32:07] <Thiez> test: I suggest trying to do a git clone
[17:32:12] <cmr> test: you need to clone with git.
[17:32:19] <Luqman> cmr: llvm/lib/CodeGen/PrologEpilogInserter.cpp
[17:32:25] <jmgrosen> Palmik: does the name of the file *have* to be foo.rs?
[17:32:28] <test> oh ok thanks
[17:32:29] <cmr> Can't have git submodules without a git repo.
[17:32:32] <Palmik> jmgrosen: no.
[17:32:34] *** Quits: huhlig-home2 (huhlig@moz-C8339267.hfc.comcastbusiness.net) (Quit: Leaving)
[17:32:55] <test> thanks, im really new to git so
[17:33:00] <jmgrosen> Palmik: name the file bar.rs; then do `mod baz { mod foo { /* code */ } }`
[17:33:03] <Luqman> cmr: the reason why they're no longer there is because the segmented stacks is not actually enabled in the new rt afaik
[17:33:07] <jmgrosen> err, pub mod, not mod
[17:34:06] <cmr> Luqman: I'm writing an OS kernel in Rust, so I'm trying to pare down the runtime dependencies to zero. It seems to expect some sort of structure in TLS, which I don't have nor want.
[17:34:07] <Palmik> jmgrosen: that sounds nice, thanks. By the way, what happens when I have multiple external modules that have root with the same name, is that even possible (like it is in Haskell for example)?
[17:34:49] <Palmik> I'm asking (and the previous question) because I would like to decouple one library into multiple libraries and preserve the module structure.
[17:34:52] <cmr> Luqman: is there an attribute I can slap onto my main function to disable everytrhing segmented-stack related?
[17:34:54] <jmgrosen> Palmik: I have a hunch, let me try
[17:35:47] <cmr> It looks like llvm looks for the no-split-stack attribute.
[17:36:09] <cmr> and trans uses the same thing, so looks like that'sit
[17:36:13] * cmr tries
[17:36:31] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[17:36:41] <cmr> Yup!
[17:36:51] *** Joins: miza (miza@moz-4DD51325.home.otenet.gr)
[17:37:01] *** Quits: test (Mibbit@moz-3868657C.cpe.netcabo.pt) (Quit: http://www.mibbit.com ajax IRC Client)
[17:37:02] <Palmik> In case it's not possible, it might pose a problem once there are multiple libraries with similar domains. People would have to come up with unique names for their crate roots.
[17:37:33] *** Quits: lenstr (lenstr@E0E80B8D.ED45D46B.DFEAE789.IP) (Client exited)
[17:38:02] <Luqman> cmr: as in a rust attribute?
[17:38:14] <cmr> Luqman: yeah. #[no_split_stack]
[17:41:11] *** Parts: sruggier (sruggier@moz-F1ED47A9.cpe.teksavvy.com) ()
[17:42:05] <Luqman> cmr: that's only per-function though
[17:42:11] <erickt> aatch: ping
[17:43:22] *** Quits: jdsanders (Adium@moz-84CB7548.hlrn.qwest.net) (Quit: Leaving.)
[17:43:25] <Luqman> cmr: perhaps might be worth add a crate one to completely set EnableSegmentedStacks to false in librustc/back/link.rs
[17:43:26] <jmgrosen> cmr: how can you specify meta attributes to pick a particular crate? I think it's possible but I'm not sure how at the moment
[17:43:39] <cmr> Luqman: It looks like theonlyother way to turn off split stacks is the `Fn.getTarget().Options.EnableSegmentedStacks`
[17:43:41] <cmr> Yeah
[17:44:12] *** Joins: pepper_chico (pepper_chi@14AC4DFD.704EE6B0.E4090502.IP)
[17:44:13] <cmr> jmgrosen: that I don't know
[17:44:20] <jmgrosen> alright
[17:44:30] <cmr> Luqman: I was thinking a -Z option, but crate attr is probably better.
[17:45:22] <Luqman> jmgrosen: do you mean something like `extern mod extra(vers="0.8-pre");` ?
[17:46:01] <jmgrosen> Luqman: ah, thanks!
[17:46:23] <jmgrosen> Palmik: in each crate, you can specify metadata -- name, version, author, and uuid
[17:46:54] <jmgrosen> Palmik: and then in the extern mod, as Luqman said, you can use any number of the attributes to be more specific -- uuid should be unique to a particular crate
[17:47:13] <Palmik> I see, thanks!
[17:47:57] <jmgrosen> Palmik: for the metadata in the crate, the syntax is #[link(name = "blah", vers = "0.0.1", author = "John", uuid = "asdfbdahsf")];
[17:49:10] <Palmik> Yup, I already use some of these. Did not know you could use them to specify which external crate you want though. 
[17:53:05] *** Quits: pyrac (pyrac@moz-30AD8801.w90-60.abo.wanadoo.fr) (Quit: pyrac)
[17:54:56] *** Joins: orshem (orshem@C5E06B1E.A5B6B765.E3D28531.IP)
[17:56:12] *** Joins: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[17:56:33] *** Joins: jviereck (Adium@moz-58A87BA7.dip0.t-ipconnect.de)
[17:59:34] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[18:04:41] *** Joins: threecreepio (jdp@moz-71E164C9.cust.bredbandsbolaget.se)
[18:05:01] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Ping timeout)
[18:06:01] *** Joins: pyrac (pyrac@moz-30AD8801.w90-60.abo.wanadoo.fr)
[18:11:34] *** Quits: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk) (Client exited)
[18:11:49] <kimundi> Palmik: Additionally, the crate roots of external libraries are completely separate module hierarchies. In principle, you're free to 'extern mod' an library under whatever name you like and include it in in any module of you're crate
[18:12:07] *** Joins: sebcrozet (sebcrozet@moz-87D51607.w80-13.abo.wanadoo.fr)
[18:14:01] <Palmik> kimundi: what do you mean by 'extern mod an library under whatever name you like'?
[18:14:31] <Luqman> Palmik: something like extern mod realstd(name = "std");
[18:15:24] <Palmik> Ah, OK, thank you guys. :)
[18:15:54] *** Quits: pepper_chico (pepper_chi@14AC4DFD.704EE6B0.E4090502.IP) (Ping timeout)
[18:16:08] <jmgrosen> sebcrozet: do you think kiss3d would work for a small but "real" game?
[18:16:36] *** Joins: pepper_chico (pepper_chi@14AC4DFD.704EE6B0.E4090502.IP)
[18:17:04] *** Eridius is now known as Eridius|vacation
[18:17:07] <Eridius|vacation> see ya'll in a week!
[18:17:17] *** Joins: jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net)
[18:17:54] *** Quits: Palmik (palmik@moz-CC484FDD.tmcz.cz) (Quit: Lost terminal)
[18:18:33] *** Quits: ktos (ktos@moz-D3D6BE18.swidnica.mm.pl) (Ping timeout)
[18:19:46] *** Joins: ktos (ktos@moz-D3D6BE18.swidnica.mm.pl)
[18:21:20] *** Quits: pyrac (pyrac@moz-30AD8801.w90-60.abo.wanadoo.fr) (Quit: pyrac)
[18:21:22] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[18:21:44] *** Joins: samx (sami@moz-D9DA5773.dyn.optonline.net)
[18:23:02] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[18:23:39] <engla> see you
[18:23:58] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[18:26:12] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[18:26:38] *** Joins: pyrac (pyrac@moz-30AD8801.w90-60.abo.wanadoo.fr)
[18:30:03] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[18:30:26] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[18:31:31] *** Joins: miloshadzic (miloshadzi@F8195CC5.425C93D4.449B8A48.IP)
[18:32:01] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[18:34:17] *** Quits: paulproteus (quassel@rose.makesad.us) (Ping timeout)
[18:34:23] *** Joins: paulproteus (quassel@moz-E86A3B42.makesad.us)
[18:35:34] *** Joins: eatkinson (eatkinson@moz-261EDE03.hsd1.ca.comcast.net)
[18:36:22] *** Joins: zeuxcg (zeuxcg@moz-80D1F912.hsd1.ca.comcast.net)
[18:36:41] <sebcrozet> jmgrosen: atm, no. Kiss3d does not allow custom obj loading, nor custom shaders.
[18:38:10] *** Quits: samx (sami@moz-D9DA5773.dyn.optonline.net) (Quit: This computer has gone to sleep)
[18:38:35] <sebcrozet> jmgrosen: maybe once those two features are implemented, it could be used for very very simple gamesâ€¦
[18:40:51] <mark_edward> cmr: ping
[18:41:11] <mark_edward> sebcrozet: your stuff is super cool btw! i just saw it on reddit
[18:41:20] <cmr> mark_edward: pong
[18:41:22] <tiffany> I should rewrite my engine in rust
[18:41:33] <sebcrozet> mark_edward: thanks!
[18:42:02] <mark_edward> cmr: there seems to be no way to see the methods of Option<T> with the new docs: http://seld.be/rustdoc/master/std/option/index.html or am i doing it wrong?
[18:42:09] <cmr> mark_edward: known bug
[18:42:15] <cmr> enums aren't handled correctly
[18:42:58] <mark_edward> cmr: ah i see. when do you think it will be resolved? few weeks? i must say overall these new docs are really great! props to you and Seldaek
[18:43:16] <cmr> no idea, that's Seldaek's thing, though I could take a poke at it
[18:43:49] <cmr> I'll do it in 20 minutes
[18:44:19] *** Joins: obk (Mibbit@moz-B0F26027.red.bezeqint.net)
[18:45:17] <tiffany> does anyone know how rust's runtime behaves in an environment with dynamically loaded shared libraries?
[18:45:20] <engla> it's also showing all 'use' as 'pub use' again
[18:45:26] <cmr> tiffany: just fine
[18:45:32] <tiffany> like, does the runtime cross a dlsym() boundary, and what happens if it's started mutliple times?
[18:45:44] <cmr> tiffany: even x-platform interface in std::unstable::dynamic_lib
[18:46:04] <cmr> tiffany: you neeed to start the runtime explicitly if you're calling rust code from FFI
[18:46:32] <tiffany> cmr: and if you do need to start it explicitly, what happens if multiple shared libraries start it?
[18:46:48] <cmr> tiffany: I do not know.
[18:47:50] <obk> Trying to do `let mut (foo, bar) = baz()` I get "use multiple local declarations instead of e.g. `let mut (x, y) = ...`". Actually I need `let (mut foo, bar) = baz()`, which doesn't work either. What's the right way to do it? Or just not use tuples?
[18:48:14] <cmr> obk: let (foo, bar) = baz(); let mut foo = foo; let mut bar = bar;`
[18:48:18] <tiffany> are there docs for std::unstable?
[18:48:18] <Ralith> tiffany: if it doesn't handle it, PR some global state in the init function to make it safe :P
[18:48:34] <obk> cmr: Ah. Right, I guess. But Ugh.
[18:48:45] <cmr> obk: it's annoying, but temporary
[18:49:28] <obk> What would it become?
[18:49:37] <cmr> let (mut x, mut y) = baz()
[18:49:53] <cmr> I hope the distributive syntax is re-introduced.
[18:50:10] <obk> Yes, that would be better.
[18:50:11] <cmr> since hte parens are required now it's obvious what it should do (IMO)
[18:50:26] <kimundi> mut will become an pattern binding modifier like ref, right now It'S something separate from the pattern language
[18:50:55] <obk> Right, now one can say ref mut x in a pattern but not just mut x.
[18:51:04] <kimundi> yeah
[18:51:20] <cmr> tiffany: http://seld.be/rustdoc/master/std/unstable/index.html and whatever is in the official docs
[18:51:25] <kimundi> If it gets implemneted, you will be able to say 'mut ref mut'! :D
[18:51:26] <engla> but if the pattern is in a function or closure parameter, then you can say mut x
[18:51:55] <kimundi> engla: That's special cased like 'let mut', not a pattern
[18:52:11] <kimundi> at least not yet
[18:52:55] <enix> what is the minimum guaranteed size of a uint? 16 or 32 bits?
[18:53:05] <kimundi> it's allways machine pointer size
[18:53:12] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[18:53:35] <kimundi> therefore, uint and int == 32bit or 64bit ususally
[18:53:52] *** Joins: roboguy (roboguy@moz-266CFD9E.cm.sunflower.com)
[18:53:54] <kimundi> If you need a specific size, use the sized variants
[18:54:02] <enix> ah, but they could be 16
[18:54:21] <enix> i just wanted to know if its ok to take a u32 and cast it to a uint or if that would fail on some platforms
[18:54:25] <kimundi> If there are 16bit pointer platforms where rust runs then it would be indeed possible
[18:54:43] <kimundi> should be fine
[18:54:43] <enix> but, it sounds like it will fail on 16 bit platforms, if any existed
[18:55:01] <roboguy> hey, I'm having some rust issues. I'm on OS X and I just installed it (this is my first time trying to use it) and whenever I try to run the rust compiler in (seemingly) any way it immediately either segfaults or sigtraps
[18:55:19] <enix> thanks
[18:55:29] <kimundi> well, such an hypothetical platfrom would have a lot of problems with libraries, no need to make it compatible now :P
[18:55:35] *** Quits: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Ping timeout)
[18:56:38] <roboguy> ah, wait, 'rust' isn't the rust compiler is it? that's the thing that's crashing. should I just use rustc directly?
[18:56:40] <kimundi> roboguy: Hmm... Sadly I have no experience with OSX :(
[18:56:48] <kimundi> right
[18:57:04] <kimundi> rust is just a little wrapper for rustc, rusti, rustpkg and rustdoc
[18:57:16] <kimundi> +I shouldn't just crash... but for some reason it does
[18:57:32] <kimundi> anyway, what's important is rustc
[18:57:36] <roboguy> ok, cool
[18:57:42] <roboguy> thanks!
[18:59:35] *** Joins: fabiand (fabiand@moz-B43CF293.adsl.alicedsl.de)
[18:59:35] <jeaye> roboguy: 'rustc' is the compiler
[18:59:45] *** Joins: carleastlund (cce@moz-C8071335.c3-0.smr-ubr1.sbo-smr.ma.cable.rcn.com)
[18:59:49] <kimundi> roboguy: Btw If you plan to play around with it more I recommend building git HEAD instead of using the last release. Unless you're already doing that/lose interest in the next half hour ;)
[19:00:19] *** Quits: pyrac (pyrac@moz-30AD8801.w90-60.abo.wanadoo.fr) (Quit: pyrac)
[19:00:25] <jeaye> roboguy: 'rustc my_src.rs' 
[19:00:27] <roboguy> kimundi: haha, ok. I hear there's a lot of development going on
[19:00:33] <kimundi> yeah
[19:00:47] <roboguy> another thing is, I hear rust has a bit of an unusual memory management scheme and I was wondering there's somewhere I could read about it?
[19:01:45] <jeaye> There's the tutorial on the main site ( http://static.rust-lang.org/doc/tutorial.html ) and also this: http://static.rust-lang.org/doc/0.6/tutorial-borrowed-ptr.html
[19:01:52] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Ping timeout)
[19:02:07] <kimundi> Basically it's just that the releases are purely snapshots that happen all 3 months, and have no advantage against building the most current version
[19:03:59] <cmr> jeaye: don't link to 0.6 docs
[19:04:46] <jeaye> Didn't realize there was a 0.7 version, sorry
[19:05:02] <cmr> you link to HEAD in one and a release in the other :p
[19:05:43] <jeaye> One was bookmarked, the other was easy to navigate to.
[19:06:13] <fabiand> hey
[19:06:15] <carleastlund> Here's the HEAD link for any interested: http://static.rust-lang.org/doc/tutorial.html#borrowed-pointers
[19:06:40] <enix> Is there a cfg() for checking if you are on a 64bit or a 32bit platform?
[19:06:51] *** Joins: Jesin (Jessin_@moz-A680C20B.cc.lehigh.edu)
[19:07:05] <jeaye> carleastlund: That's not the same article
[19:07:07] <cmr> enix: target_word_size
[19:07:12] <carleastlund> jeaye: oops!
[19:07:22] <enix> ooh, cool. is that it bytes or bits?
[19:07:28] <carleastlund> http://static.rust-lang.org/doc/tutorial-borrowed-ptr.html
[19:07:46] <jeaye> Yeahup, that's it.
[19:08:26] *** Quits: igl1 (igl@moz-AA42D59E.adsl.alicedsl.de) (Ping timeout)
[19:08:32] *** Joins: igl (igl@moz-8182AB55.adsl.alicedsl.de)
[19:09:56] <roboguy> thanks!
[19:10:41] <roboguy> huh, this configure script is a bit different
[19:11:02] <cmr> handmade with love by graydon
[19:14:39] <olsonjeffery> anyone have a recent/clean rusti build on hand? mine is segfaulting and im curious if its just me
[19:14:46] <mark_edward> why are randomly generated uints so large in magnitude?
[19:15:15] <cmr> mark_edward: because there are a lot of bits, many of which represent a very large value?
[19:15:35] <carleastlund> mark_edward: if they're generated with a uniform distribution, most of them are going to use most of the available magnitude.  Otherwise the distribution would be skewed very low, and not be uniform.
[19:15:38] <fabiand> hey - should managed ptrs be removed from the language?
[19:15:49] <cmr> fabiand: pcwalton thinks so
[19:16:03] <fabiand> cmr, yes, I read that post .. I just wonder about the state of it :)
[19:16:08] <mark_edward> ah i understand now! for some reason i was thinking of a normal distribution, not a uniform one
[19:16:13] <cmr> fabiand: it hasn't been attempted.
[19:16:15] <fabiand> cmr, I actually quite like the configure script
[19:16:33] <fabiand> cmr, okay ..
[19:17:20] *** Joins: samx (sami@moz-D9DA5773.dyn.optonline.net)
[19:17:44] <carleastlund> mark_edward: yeah, uniform is probably a good default distribution, but for some purposes a normal or a geometric distribution may serve better.  Distributions aren't one size fits all, much as random testing would be easier if they were.  :)
[19:17:55] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[19:18:30] *** Quits: fabiand (fabiand@moz-B43CF293.adsl.alicedsl.de) (Quit: Verlassend)
[19:19:40] *** Joins: pyrac (pyrac@moz-30AD8801.w90-60.abo.wanadoo.fr)
[19:19:49] <cmr> dbaupp has a randomlibrary with tons of other distributions.
[19:21:43] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[19:22:42] <roboguy> I don't think I've ever seen configure scripts and Makefiles download stuff
[19:22:50] <roboguy> interesting
[19:22:59] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[19:22:59] *** ChanServ sets mode: +o pnkfelix
[19:23:14] <miza> is there a way to have working sketch in 0.8-pre?
[19:23:23] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[19:25:49] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[19:28:51] *** Quits: pyrac (pyrac@moz-30AD8801.w90-60.abo.wanadoo.fr) (Quit: pyrac)
[19:29:32] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[19:30:24] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[19:32:56] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[19:32:56] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Connection reset by peer)
[19:33:03] <MrByte> No idea why I get link errors against LoadLibraryA (or LoadLibrary or LoadLibraryW) out of kernel32, but not for GetProcAddress.
[19:33:25] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[19:33:36] *** Joins: eholk (eholk@moz-F70D5031.hsd1.in.comcast.net)
[19:34:45] *** Quits: samx (sami@moz-D9DA5773.dyn.optonline.net) (Quit: This computer has gone to sleep)
[19:35:47] *** Quits: squiddy (squiddy@moz-4236ED38.adsl.alicedsl.de) (Input/output error)
[19:35:50] *** Quits: orshem (orshem@C5E06B1E.A5B6B765.E3D28531.IP) (Quit: Leaving)
[19:40:22] <jmgrosen> are there any gui library wrappers yet?
[19:40:44] <cmr> jmgrosen: nope
[19:40:57] <nsf> in the current state maintaining these will be a nightmare imho
[19:41:20] <cmr> yup, especially since they're huge
[19:41:24] <doomlord> use console+webui :)
[19:41:32] <erickt> hey folks, is anyone online that knows how to use rustpkg? I can't get it to work
[19:41:33] <nsf> yeah, gtk has 4k functions iirc
[19:42:08] <erickt> I *think* https://github.com/brson/rust-sdl is supposed to work with rustpkg
[19:42:13] <erickt> but I can't get it to work
[19:42:26] <olsonjeffery> tjc is working on rustpkg right now, is all i know
[19:42:35] <cmr> ohh so that's how you use pkg.rs
[19:42:35] <olsonjeffery> id like to give it a spin, but yeah. im not help right now.
[19:43:06] *** Quits: eatkinson (eatkinson@moz-261EDE03.hsd1.ca.comcast.net) (Quit: eatkinson)
[19:43:10] <miza> i have some questions
[19:43:21] <erickt> cmr: you're supposed to use it somehow :)
[19:43:30] <erickt> maybe there's a test...
[19:43:35] <miza> how can i get the bit size of a variable
[19:44:04] <acrichto> olsonjeffery: pong
[19:44:12] <miza> and can i have an 2bits integer or 4 or whatever
[19:44:22] <olsonjeffery> acrichto: howdy! im mourning #8645 ;_;
[19:44:29] <olsonjeffery> i just rebased on top of that revert.
[19:44:44] <acrichto> olsonjeffery: ah yes, sorry I've been meaning to comment on that
[19:44:52] <olsonjeffery> so. yeah. was curious if you're going to try and work on it?
[19:44:55] <acrichto> basically the bots started segfaulting during the test suite frequently
[19:44:58] <olsonjeffery> im also going to work on these failing windows tests.
[19:45:03] <olsonjeffery> re: file io on udp..
[19:45:08] <olsonjeffery> 8816 and 8810 iir
[19:45:09] <olsonjeffery> +c
[19:45:23] <jmgrosen> rusti: use sys; sys::size_of::<for int>()
[19:45:32] <acrichto> I was never able to reproduce the segfaults locally, so I wasn't quite sure how I was going to debug it, but I think that the best thing to do would to be to decouple the upgrade from the new process bindings
[19:45:32] <olsonjeffery> acrichto: that sucks! have you figured out why?
[19:45:34] -rusti- pastebinned 7 lines of output: http://ix.io/7MV
[19:45:39] * olsonjeffery nods
[19:45:49] <jmgrosen> rusti: use sys; sys::size_of::<int>()
[19:45:52] -rusti- pastebinned 8 lines of output: http://ix.io/7MW
[19:45:55] <olsonjeffery> acrichto: yes, please. as i said in my comment.. newer libuv has a lot going for it
[19:45:56] <acrichto> I think that it's pretty extractable, at least I attempted to have that be the case
[19:46:01] <olsonjeffery> like a cross-platform stat struct
[19:46:04] <olsonjeffery> and the err num stuff
[19:46:09] <jmgrosen> use std::sys; sys::size_of::<int>()
[19:46:11] <acrichto> that seems slightly convenient :P
[19:46:18] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[19:46:21] <jmgrosen> rusti: use std::sys; sys::size_of::<int>()
[19:46:22] -rusti- 8u
[19:46:29] <olsonjeffery> acrichto: timely is more like it.
[19:46:29] <jmgrosen> miza: ^
[19:46:34] <olsonjeffery> i have it working with "the old style"
[19:46:35] <jmgrosen> miza: although that's in bytes, not bits
[19:46:41] <olsonjeffery> but im not enthusiastic about how it'll port
[19:46:49] <olsonjeffery> and im going to spend some time on windows
[19:47:18] <olsonjeffery> jmgrosen: also that's going to include padding/alignment, which may be what you want/don't want..
[19:47:22] *** Joins: wting (wting@moz-B19BCE71.austin.res.rr.com)
[19:47:27] <acrichto> olsonjeffery: ok, I may be able to get around to this tonight, but it may be as late as tomorrow night :(
[19:47:54] <jmgrosen> olsonjeffery: ah, right
[19:47:59] <miza> jmgrosen: have you answer from the other question?:p
[19:48:20] <olsonjeffery> acrichto: well.. at this point, ive done enough hairy rebases that you'd be doing me a solid if you hold off until i land my next batch of file io work.
[19:48:21] <jmgrosen> miza: an integer smaller than 8 bits? not built into the language
[19:48:23] <olsonjeffery> which i think i need to land soon
[19:48:24] <miza> jmgrosen: if i could have a two bits integer
[19:48:28] <olsonjeffery> and work on those windows errors :/
[19:48:34] <acrichto> olsonjeffery: ah, nevermind then :)
[19:48:41] <miza> ok
[19:48:44] <acrichto> I will attempt the upgrade after your stuff lands
[19:48:57] <jmgrosen> miza: what's the use case?
[19:48:58] <olsonjeffery> acrichto: you've got enough irons in the fire, as-is
[19:49:09] <olsonjeffery> but i do agree that landing the libuv upgrade would be quite helpful
[19:49:15] <miza> i am reading this article
[19:49:17] <miza> http://www.multigesture.net/articles/how-to-write-an-emulator-chip-8-interpreter/
[19:49:28] *** Joins: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net)
[19:49:31] <miza> an i want to implement in rust for excerising
[19:49:36] <miza> and learn about emulation
[19:50:25] <jmgrosen> miza: where's the part about 2 bit integers?
[19:51:15] <miza> xmm u are right :p
[19:55:16] <erickt> cmr / olsonjeffery: in case you're interested, to have a repo compatible with rustpkg, you seem to put the files in src/foo
[19:56:46] *** Quits: eholk (eholk@moz-F70D5031.hsd1.in.comcast.net) (Quit: eholk)
[19:57:04] <olsonjeffery> erickt: ty
[19:57:07] <roboguy> miza: I see stuff about 2-byte values but not 2-bit values
[19:57:31] <miza> roboguy: yes, i saw wrong
[19:58:06] <jmgrosen> rust has u8/u16/u32/u64 and i8/i16/i32/i64
[19:59:56] *** Quits: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net) (Quit: dave1629)
[20:01:26] *** Quits: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net) (Input/output error)
[20:01:26] *** Quits: pepper_chico (pepper_chi@14AC4DFD.704EE6B0.E4090502.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[20:01:52] *** Quits: jviereck (Adium@moz-58A87BA7.dip0.t-ipconnect.de) (Quit: Leaving.)
[20:02:15] *** Joins: pepper_chico (pepper_chi@14AC4DFD.704EE6B0.E4090502.IP)
[20:02:15] *** Quits: nsf (nsf@moz-EEF3238A.convex.ru) (Quit: WeeChat 0.4.1)
[20:02:27] *** Joins: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net)
[20:08:47] <roboguy> rust doesn't have higher kinded polymorphism (yet) does it?
[20:10:50] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[20:10:50] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14dc3cdc4 to 147ff102a: 02http://git.io/N3iJvQ
[20:10:50] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[20:10:51] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[20:10:51] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/7A2NUg
[20:10:51] <ghrust> 13rust/06auto 140691c01 15Luqman Aden: libsyntax: Remove obsolete fixme.
[20:10:51] <ghrust> 13rust/06auto 14462604a 15Luqman Aden: librustc: Check for empty crate link meta name and vers.
[20:10:52] <ghrust> 13rust/06auto 14fc9fa2c 15bors: auto merge of #8933 : luqmana/rust/ot, r=pnkfelix...
[20:10:54] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[20:14:20] *** Quits: bytewise (bytewise@moz-4A801D04.unitymediagroup.de) (Connection reset by peer)
[20:19:50] <sfackler> roboguy: nope. there's a bug to follow: https://github.com/mozilla/rust/issues/8922
[20:20:43] <roboguy> sfackler: hmm, how hard is it to find a good entry point into the rust compiler source?
[20:21:54] <sfackler> not sure. I haven't done any work on the compiler itself
[20:22:11] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[20:23:51] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[20:26:53] <mark_edward> i do not understand the new format! why Python-style! i never figured it out!
[20:27:42] <mark_edward> how to format a type that implements ToStr? println!("{0!s}", my_struct); doesn't work
[20:29:10] *** Joins: samx (sami@moz-D9DA5773.dyn.optonline.net)
[20:29:49] *** Joins: Shaladdle (Shaladdle@moz-424BC304.hsd1.pa.comcast.net)
[20:29:54] <mark_edward> acrichto: do you understand how the new format! works?
[20:30:08] *** Quits: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net) (Quit: dave1629)
[20:30:32] <jmgrosen> rusti: let mut foo: int; foo = 5; foo
[20:30:33] -rusti- 5
[20:30:41] <engla> mark_edward: acrichto wrote it, so I'd hope so
[20:30:57] <engla> mark_edward: tostr needs remodeling
[20:31:25] <mark_edward> what's the current way to print a struct that implements ToStr then?
[20:31:41] <sfackler> my_struct.to_str() :P
[20:31:45] <engla> rusti: format!("{}", true.to_str())
[20:31:46] -rusti- ~"true"
[20:31:53] <engla> I think you have to call to str
[20:32:01] *** Quits: victorporof (victorporo@9D964D4D.36D485C.2B3D3D4.IP) (Quit: victorporof)
[20:32:08] <sfackler> you can also implement std::fmt::Default and use format!("{}", my_struct)
[20:32:22] <mark_edward> engla: okay. i though tit would use python's !s or !r stuff
[20:32:33] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[20:32:44] <mark_edward> isn't std::fmt::Default basically ToStr?
[20:33:20] <sfackler> with the ability to customize output
[20:33:47] *** Quits: onr (uid5726@moz-31ABA2C0.irccloud.com) (Quit: )
[20:34:16] <jmgrosen> and it won't necessarily allocate any new stuff
[20:34:51] <mark_edward> well there needs to be a #[deriving(Default)] or something, like with ToStr
[20:35:09] <engla> right, or something similar to replace ToStr
[20:35:25] <engla> mark_edward: docs are here  https://github.com/mozilla/rust/blob/master/src/libstd/fmt/mod.rs
[20:36:01] <mark_edward> thanks
[20:36:44] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[20:37:56] <engla> could BufferedReader be a generic thing in the new io?
[20:39:12] <mark_edward> engla: i think that actually needs to be made a docs and linked to by the tutorial... it'd be super helpful
[20:40:21] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[20:40:29] <engla> I think it gets the syntax wrong so it doesn't even show up in module docs
[20:40:48] <engla>  /**! but it should be /*!
[20:41:35] *** Quits: obk (Mibbit@moz-B0F26027.red.bezeqint.net) (Quit: http://www.mibbit.com ajax IRC Client)
[20:43:13] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[20:45:33] *** Joins: tikue_ (tkuehn@moz-FEADCD38.hsd1.pa.comcast.net)
[20:52:21] <mark_edward> how do you print curly braces with the new println!?
[20:52:38] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[20:55:06] <mark_edward> the python "{{" and "}}" seem not to work!
[20:55:40] <pnkfelix> mark_edward: what does C# do?
[20:55:52] <mark_edward> i don't know C#
[20:56:30] <benh> \\{\\} seems to work :D
[20:56:40] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[20:56:46] <benh> (\\{} apparently ends the string early?)
[20:57:01] <myname> wait
[20:57:24] <myname> so you have to use \\\\ for a single \ in output of printfln?
[20:57:49] <benh> apparently
[20:57:49] <kimundi> rusti: printfln!("\\\\")
[20:57:50] -rusti- "\\\\"
[20:57:50] -rusti- ()
[20:58:01] <myname> interesting
[20:58:06] <kimundi> rusti: printfln!("\\\\ {:s}", "foo")
[20:58:06] <benh> rusti: println!("\\\\")
[20:58:06] -rusti- <std-macros>:240:20: 240:36 error: too many arguments to fmt!. found 2, expected 1
[20:58:07] -rusti- <std-macros>:240             println(fmt!($($arg),+))
[20:58:07] -rusti-                                      ^~~~~~~~~~~~~~~~
[20:58:07] -rusti- application terminated with error code 101
[20:58:07] -rusti- \
[20:58:07] -rusti- ()
[20:58:29] <benh> rusti: println!("foo \\{} bar")
[20:58:30] <kimundi> rusti: println!("\\\\ {:s}", "foo")
[20:58:30] <myname> what
[20:58:30] -rusti- foo {
[20:58:31] -rusti- ()
[20:58:31] -rusti- \ foo
[20:58:31] -rusti- ()
[20:59:22] <myname> i take that as a yes
[20:59:40] <kimundi> seems that way, yeah
[21:00:02] <kimundi> rusti: println!("\\\\ {:s}", "\\\\")
[21:00:02] -rusti- \ \\
[21:00:03] -rusti- ()
[21:00:14] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[21:00:51] *** Joins: bytewise (bytewise@moz-4A801D04.unitymediagroup.de)
[21:01:53] *** Quits: samx (sami@moz-D9DA5773.dyn.optonline.net) (Quit: This computer has gone to sleep)
[21:03:12] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[21:06:29] <strcat> rusti: 2
[21:06:30] -rusti- 2
[21:06:33] *** Joins: derek (Mibbit@moz-879A60DA.range86-178.btcentralplus.com)
[21:06:35] <strcat> rusti: println
[21:06:42] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[21:06:45] <strcat> rusti: &println
[21:06:45] -rusti- &
[21:06:52] <strcat> hm
[21:07:04] <strcat> rusti: struct Foo(int); Foo(2)
[21:07:05] -rusti- main::Foo{__field__: 2}
[21:07:16] <derek> I am very confused, how can I print a number such as 5? println(5) doesn't work, println(5.to_str()) also fails
[21:08:07] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[21:08:18] <strcat> derek: 5.to_str() fails because 5 isn't a specific type
[21:08:21] <strcat> it's a generic literal
[21:08:33] <derek> then how does one print an integer?
[21:08:38] <tikue_> rusti: let two: uint = FromStr::from_str("2").unwrap();
[21:08:39] -rusti- <anon>:5:13: 5:16 warning: unused variable: `two` [-W unused-variable (default)]
[21:08:39] -rusti- <anon>:5          let two: uint = FromStr::from_str("2").unwrap();
[21:08:40] -rusti-                       ^~~
[21:08:40] -rusti- ()
[21:08:42] <jmgrosen> rusti: 5i.to_str()
[21:08:43] -rusti- ~"5"
[21:08:58] <derek> thats very counter intuative
[21:09:15] <derek> why can't you just go println(5)
[21:09:22] <strcat> because println takes a &str
[21:09:24] <benh> rusti: println!("{}", 5)
[21:09:25] -rusti- 5
[21:09:25] -rusti- ()
[21:09:27] <jmgrosen> well, 5 can be: u8, u16, u32, u64, uint, i8, i16, i32, i64, int
[21:09:32] <engla> derek: the generic formatting macros are print!() and println!()
[21:09:38] <benh> jmgrosen: but they all print the same!
[21:09:46] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[21:09:51] <strcat> benh: with the default formatting, sure
[21:09:51] <jmgrosen> benh: eh, true :P
[21:10:07] <strcat> rusti: println!("{:?}", 5u)
[21:10:08] -rusti- 5u
[21:10:08] -rusti- ()
[21:10:15] <derek> could it not just infer it from the number itself?
[21:10:22] <benh> What's :?
[21:10:26] <derek> surely that would be a lot cleaner and simpler
[21:10:29] <benh> sorry, what's :??
[21:10:33] <strcat> derek: it's a normal function
[21:10:36] <strcat> it takes &str
[21:10:45] <benh> rusti: println!("{:?}", "")
[21:10:46] -rusti- ""
[21:10:46] -rusti- ()
[21:10:48] <engla> benh: same as %?, std::repr
[21:10:53] <benh> right
[21:11:12] <derek> but in other languages you can just go print(5)
[21:11:12] <strcat> derek: it's inefficient to allocate a string just to print something, so there are format string ones
[21:11:32] <derek> but it looks ugly
[21:11:36] <strcat> println could use T: DefaultFormatStringTrait (whatever it's called)
[21:11:38] <strcat> and take &T
[21:11:40] <strcat> but it doesn't
[21:11:43] <derek> and bloats everything
[21:12:03] <engla> strcat: that trait is called String :)
[21:12:09] <engla> namespaces you know
[21:12:18] <jmgrosen> derek: perhaps static typing isn't for you :P
[21:12:29] <derek> just auto boxing
[21:12:49] <strcat> derek: rust generics don't use boxing
[21:12:58] <strcat> trait objects do, but not generic functions with trait bounds
[21:13:06] <jmgrosen> derek: http://michaelwoerister.github.io/2013/09/02/generics-and-debug-info.html
[21:13:09] <derek> maybe have it automaticly and then people can use their ugly string formats if they want effeicny
[21:13:11] <strcat> anyway you could write a function taking println(&5)
[21:13:53] *** Joins: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP)
[21:13:56] <derek> but the nthat does not work for strings
[21:14:03] <strcat> it would work for strings
[21:14:07] <strcat> it could be a generic function
[21:14:29] <jmgrosen> rusti: use std::fmt; fn println_thing<T: fmt::default>(param: &T) { println!("{}", param); } println_thing(&5);
[21:14:29] -rusti- <anon>:5:43: 5:55 error: attempt to bound type parameter with a nonexistent trait `fmt::default`
[21:14:29] -rusti- <anon>:5          use std::fmt; fn println_thing<T: fmt::default>(param: &T) { println!("{}", param); } println_thing(&5);
[21:14:31] -rusti-                                                     ^~~~~~~~~~~~
[21:14:31] <derek> there should be a generic print function as standerd anyway
[21:14:33] -rusti- error: aborting due to previous error
[21:14:35] -rusti- application terminated with error code 101
[21:14:39] <jmgrosen> rusti: use std::fmt; fn println_thing<T: fmt::Default>(param: &T) { println!("{}", param); } println_thing(&5);
[21:14:43] -rusti- pastebinned 10 lines of output: http://ix.io/7N6
[21:15:09] <jmgrosen> hmm
[21:15:17] <jmgrosen> rusti: use std::fmt; fn println_thing<T: fmt::Default>(param: &T) { println!("{}", *param); } println_thing(&5);
[21:15:22] -rusti- pastebinned 11 lines of output: http://ix.io/7N7
[21:15:31] *** Joins: eholk (eholk@moz-F70D5031.hsd1.in.comcast.net)
[21:15:32] <benh> Are macros scoped within modules btw?
[21:15:43] *** Joins: jdsanders (Adium@moz-84CB7548.hlrn.qwest.net)
[21:15:47] <benh> is println! a reexport of std::io::wtf::println! or is it just println?
[21:15:49] <benh> +!
[21:15:52] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[21:15:52] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/7A2NUg
[21:15:52] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[21:15:57] <derek> i guess I'll find another languge to learn, this gives me to much of a headache
[21:16:03] <strcat> benh: they are either private to a module, or global to a crate
[21:16:34] <engla> derek: come back in a few months and Rust is another language.. it's a WIP
[21:16:51] <derek> engla: i hope so
[21:17:07] <derek> needs to work on being less ugly :P
[21:17:09] <strcat> I highly doubt the format stuff is going to change
[21:17:48] <strcat> at most println/print would become generic fns taking 1 param
[21:18:33] <roboguy> you guys wouldn't happen to know if there's documentation for the rust compiler source, would you?
[21:18:44] <tikue_> hey all
[21:18:51] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Quit: Gone to save the world!)
[21:19:03] *** Quits: sebcrozet (sebcrozet@moz-87D51607.w80-13.abo.wanadoo.fr) (Ping timeout)
[21:19:18] *** Joins: sebcrozet (sebcrozet@moz-A855F6C0.w82-127.abo.wanadoo.fr)
[21:21:49] <miza> could i define fixed size vector?
[21:22:18] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[21:22:37] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[21:22:47] <jmgrosen> rusti: let foo = [0u, ..4]; foo
[21:22:47] -rusti- [0u, 0u, 0u, 0u]
[21:22:50] <jmgrosen> miza: ^
[21:23:04] <miza> i want to do this in a struct
[21:23:16] <jmgrosen> so you want the type
[21:23:18] <jmgrosen> ?
[21:23:41] <pnkfelix> roboguy:  there's a README.txt in src/librustc/ ...
[21:23:52] <jmgrosen> rusti: struct Container { foo: [uint, ..4] } Container { foo: [1u, ..4] }
[21:23:53] -rusti- main::Container{foo: [1u, 1u, 1u, 1u]}
[21:23:53] <miza> y
[21:24:17] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[21:24:38] <tikue_> derek: you can use printfln!
[21:24:45] <tikue_> rusti: printfln!(5);
[21:24:46] -rusti- 5
[21:24:46] -rusti- ()
[21:24:58] <roboguy> pnkfelix: thanks
[21:25:23] <benh> rusti: printfln!(println)
[21:25:23] -rusti- ()
[21:25:27] <benh> :(
[21:25:49] <strcat> printfln is obsolete
[21:25:51] <strcat> ;p
[21:26:06] * tikue_ thinks printfln! should stay solely for this purpose
[21:26:13] <tikue_> i find myself using it a lot
[21:26:17] <tikue_> when i just want a quick print
[21:26:31] <strcat> tikue_: the old format strings are obsolete though
[21:26:35] <strcat> and printfln uses %? there
[21:26:39] <strcat> repr is for debugging only
[21:26:47] <strcat> it's very slow, and is not a stable format
[21:26:56] <strcat> it could change to printing "integer: five" tommorow
[21:26:58] <tikue_> rusti: qsort(~[1, 4, 2, 7, 5])
[21:26:58] -rusti- <anon>:5:9: 5:14 error: unresolved name `qsort`.
[21:26:58] -rusti- <anon>:5          qsort(~[1, 4, 2, 7, 5])
[21:26:58] -rusti-                   ^~~~~
[21:26:58] -rusti- error: aborting due to previous error
[21:26:58] -rusti- application terminated with error code 101
[21:26:59] <strcat> you can't depend on it
[21:27:13] *** Joins: joebobjoe (Mibbit@1EEF8F2.50A2C647.5A42B74E.IP)
[21:27:20] <derek> rusti: printfln!(5)
[21:27:21] -rusti- 5
[21:27:21] -rusti- ()
[21:27:22] <benh> I don't like \\\\
[21:27:26] <benh> or \\{\\}
[21:27:28] <benh> :(
[21:27:31] <derek> rusti: printfln!("hullo")
[21:27:32] -rusti- "hullo"
[21:27:32] -rusti- ()
[21:27:36] <derek> yay it works
[21:27:40] <derek> rusti: printfln!("hullo" + 5)
[21:27:42] <joebobjoe> Is it true that "the typechecker checks that every control path in a function ends with a return or diverging expression"? I thought returns were optional?
[21:27:42] -rusti- pastebinned 9 lines of output: http://ix.io/7N8
[21:27:50] *** Quits: eholk (eholk@moz-F70D5031.hsd1.in.comcast.net) (Quit: eholk)
[21:28:18] <strcat> joebobjoe: you don't need to return with a "return" statement
[21:28:19] <tikue_> strcat: it doesn't matter
[21:28:21] <sfackler> returns are optional in that fn foo() {} is equivalent to fn foo() -> () {}
[21:28:23] <strcat> but you can't have branches that don't return
[21:28:28] <miza> jmgrosen: thanks
[21:28:30] <Earnestly> the rusti bot must surely be one of the biggest contributors of ix.io traffic
[21:28:48] <carleastlund> strcat: what would a branch that doesn't return at all look like?
[21:28:48] <derek> rusti: printfln!("hullo" +~ 5)
[21:28:51] <tikue_> strcat: the convenience is worth almost every other downside, because you only use functions like that for convenience anyway
[21:28:51] -rusti- pastebinned 9 lines of output: http://ix.io/7N9
[21:28:58] <derek> rusti: printfln!(~"hullo" + 5)
[21:29:00] -rusti- pastebinned 9 lines of output: http://ix.io/7Na
[21:29:04] <derek> ug
[21:29:12] <tikue_> derek: rust is strongly typed
[21:29:16] <joebobjoe> strcat: Hm. Well that quote is wrong then?
[21:29:42] <derek> tikue, works in java
[21:29:46] <strcat> joebobjoe: no, you're just interpreting 'return' as meaning 'return statement' when it really means a semantic return from a function
[21:30:00] <benh> I'd agree that the quote is misleading
[21:30:11] <tikue_> derek: not in python, which is even dynamic but things str + int is a bad idea
[21:30:11] <strcat> all it's conveying is that you can't have a branch where there would be uninitialized memory or an invalid object returned
[21:30:13] <pnkfelix> derek: But not in Perl.  Different languages make different choices w.r.t ad-hoc polymorphism
[21:30:15] <tikue_> thinks*
[21:30:26] <eevee> well, it /runs/ in perl, but it doesn't do what you want
[21:30:28] <mark_edward> i don't understand trait resolveing
[21:30:33] <Earnestly> derek: You should see what VimL does to that.
[21:30:38] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.1)
[21:30:38] <joebobjoe> strcat: No. The docs have "return" in backticks, i.e., `return`
[21:30:48] <derek> hmmf
[21:30:50] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Ping timeout)
[21:30:52] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[21:30:52] *** Quits: derek (Mibbit@moz-879A60DA.range86-178.btcentralplus.com) (Quit: http://www.mibbit.com ajax IRC Client)
[21:31:00] <tikue_> rusti: println!("{}, {}", "hello", 5);
[21:31:01] -rusti- hello, 5
[21:31:01] -rusti- ()
[21:31:15] <mark_edward> if T impl's std::fmt::Default, why can't i say format!("{}", x) where x: &T?
[21:31:54] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[21:32:39] <joebobjoe> I have a noob question. Why does fmt! have to be a syntax extension? Why cannot it just be a function?
[21:32:56] <mark_edward> no varargs support
[21:32:56] <tikue_> mark_edward: it's a different type, and i assume that someone thinks it'd be a bad idea to assume you want to dereference a pointer in a format! call
[21:33:12] <joebobjoe> mark_edward: Ah. Thanks.
[21:33:22] <TD-Linux> also a function means it would have runtime type checking
[21:33:25] <benh> tikue_: so you have to move things to print them?
[21:33:36] <benh> Or does the macro borrow them?
[21:33:38] <tikue_> benh: yeah i was about to ask, i think that's mildly broken but would like a second opinion on that
[21:33:40] <mark_edward> tikue_: so how do i print the output of iterators? if i do format!("{}", *x) it complains about moving
[21:33:48] *** Joins: adu (ajr@moz-F930C5C9.washdc.fios.verizon.net)
[21:33:57] <tikue_> mark_edward: yes i know. i think that's not fully complete, but like i said, i'd like a second opinion from someone
[21:34:01] <carleastlund> mark_edward: can you clone the value?
[21:34:03] <joebobjoe> I don't see why fmt! could not just take a tuple or something...
[21:34:17] <tikue_> joebobjoe: tuples are statically typed
[21:34:28] <joebobjoe> Oh, right
[21:34:28] <tikue_> joebobjoe: (1, 2) is not the same type as (1, 2, 3)
[21:34:35] <sfackler> it could take an array of trait objects, but then you'd lose compile time type checks against the format string
[21:34:38] <tikue_> but maybe a vector
[21:34:42] <tikue_> yeah true
[21:34:51] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[21:34:55] <joebobjoe> I see. fmt! allows us more guarantee
[21:34:56] <benh> 17:14 < pnkfelix> benh: What's your goal here?
[21:34:59] <sfackler> and trait objects are a pain to deal with right now
[21:35:01] <mark_edward> carleastlund: i guess. who's in charge of format!? this stuff needs to be resolved. i shouldn't have to mvoe to print, and i should be able to format references
[21:35:05] <sfackler> it'd look like
[21:35:07] <benh> ^ let s = ~"foo"; println!("{}", s); moves s, so I need to explicitly slice it :)
[21:35:22] *** Quits: adu (ajr@moz-F930C5C9.washdc.fios.verizon.net) (Quit: adu)
[21:35:24] <sfackler> fmt("{}{}", [&2 as &Default, & &"hello" as &Default]) :(
[21:35:27] <tikue_> mark_edward: format! is very new, and it's still being finished
[21:35:41] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[21:35:43] <joebobjoe> What is the difference between fmt! and format!?
[21:35:48] <doomlord> i'm guessing type inference complicates implementing  varargs, from the discussion i saw on default args..
[21:35:51] <tikue_> joebobjoe: fmt! is deprecated
[21:36:07] <joebobjoe> But it is still in the trunk's tutorial :(
[21:36:12] <mark_edward> if fmt! is deprecated format! needs to match it's functionality
[21:36:19] <tikue_> joebobjoe: tutorial isn't up to date :(
[21:36:21] <mark_edward> but format! has problems with references
[21:36:27] <benh> and escapes
[21:36:32] <tikue_> mark_edward: that's why it's not officially deprecated yet, presumably
[21:36:34] <sfackler> mark_edward: have you tried implementing Default for &'self T?
[21:36:39] <joebobjoe> Why am I liking Rust so much better than C++?
[21:36:41] <carleastlund> mark_edward: Probably someone can implement fmt::Default for & types, at least for cloneable types.  I'm not one of the devs, though, just an outside enthusiast, so I dunno how/whether that's likely to happen.
[21:36:43] <tikue_> rusti: format!("{}", &[1u, 2, 3] as &Default)
[21:36:46] -rusti- pastebinned 11 lines of output: http://ix.io/7Nb
[21:36:50] <tikue_> joebobjoe: because it's awesome :P
[21:36:53] <tikue_> and safe
[21:36:56] <mark_edward> carleastlund: that makes sense. i'll try that
[21:37:06] <doomlord> to me rust is like cleaned up c++
[21:37:09] <pnkfelix> benh: I see.  I was unaware that the new format lib was moving its arguments (rather than taking borrowed references)
[21:37:11] <joebobjoe> As a noob, my C++ programs always throw exceptions :(
[21:37:24] <carleastlund> joebobjoe: because the compiler actually helps you with the tricky bits of low-level programming, as opposed to C/C++ that heap all the burden on you manually.  :)
[21:37:26] <benh> me too until just now :)
[21:37:27] <pnkfelix> benh: Clearly this is a topic of debate even now
[21:37:32] <tikue_> pnkfelix: yeah it is, i just assume it's a big
[21:38:02] <tikue_> rusti: let v = ~[1, 2, 3]; println!("{}", v); v
[21:38:05] -rusti- pastebinned 10 lines of output: http://ix.io/7Nc
[21:38:16] <tikue_> rusti: let v = ~[1, 2, 3]; println!("{:?}", v); v
[21:38:19] -rusti- pastebinned 14 lines of output: http://ix.io/7Nd
[21:38:24] <tikue_> pnkfelix:  ^
[21:38:26] <joebobjoe> carleastlund: Whenever I watch a C++ tech talk, they are always like "C++ is safe, if you do this and that." But I can never remember to do "this" and "that."
[21:38:34] <tikue_> joebobjoe: :)
[21:38:38] <jmgrosen> rusti: let v = ~[1, 2, 3; println!("{:?}", &v); v
[21:38:38] -rusti- <anon>:6:4: 6:5 error: incorrect close delimiter: `}`
[21:38:38] -rusti- <anon>:6     };
[21:38:38] -rusti-              ^
[21:38:38] -rusti- application terminated with error code 101
[21:38:47] <jmgrosen> : rusti: let v = ~[1, 2, 3]; println!("{:?}", &v); v
[21:38:51] <eevee> "minefields are safe if you don't step on the mines"  you don't say
[21:38:57] <jmgrosen> rusti: let v = ~[1, 2, 3]; println!("{:?}", &v); v
[21:38:58] -rusti- &~[1, 2, 3]
[21:38:58] -rusti- ~[1, 2, 3]
[21:39:02] <tikue_> rusti: let v = [1, 2, 3]; println!("{:?}", v); v
[21:39:03] -rusti- [1, 2, 3]
[21:39:03] -rusti- [1, 2, 3]
[21:39:07] <carleastlund> joebobjoe: "safe if you do X" = "not safe" in my book, "safe" has to mean "regardless".
[21:39:41] <carleastlund> (or at worst "safe unless you call unsafe.X" since it is often useful to have explicitly labeled escapes to unsafe stuff)
[21:39:53] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[21:39:56] <joebobjoe> carleastlund: Well, in the same vein, you can say, "Rust is only safe as long as you do not use the `unsafe` keyword"
[21:40:03] <joebobjoe> yea lol
[21:40:20] <doomlord> easier to ensure you're not using unsafe, or that unsafe parts didn't change from one version to the next
[21:40:25] <carleastlund> Yeah, I'm fine with a finite number of _exceptions_ to safety, I'm not happy with a finite narrow path to safety itself.
[21:40:28] <joebobjoe> But at least, as a noob, I know when I am doing something stupid in Rust.
[21:40:36] <carleastlund> Exactly.
[21:40:44] <tikue_> rusti: let v = ~[1, 2, 3]; println!("{:?}", &*v); v
[21:40:51] -rusti- pastebinned 11 lines of output: http://ix.io/7Ne
[21:41:53] *** Quits: Infiltrator (Infiltrato@4669028E.25A9890C.4B4F1E7A.IP) (Ping timeout)
[21:41:56] <joebobjoe> My school is switching from Java to C++ for teaching datastructures and algorithms. They are idiots.
[21:42:09] *** Joins: Infiltrator (Infiltrato@4669028E.25A9890C.4B4F1E7A.IP)
[21:42:20] <doomlord> oh not at all
[21:42:37] <doomlord> java is like C++ minus all  the bits i like
[21:42:47] <joebobjoe> Okay, but they did not even tell me about the Rule of Three/Five
[21:42:53] <joebobjoe> Yet they told me to use raw pointers
[21:42:54] <tikue_> hey all, i've been playing around with pattern matching and writing simple sorting algorithms
[21:43:12] <tikue_> i'm having some issues with my merge sort. it can only sort about 3000 elements before stack overflow, whereas quicksort can merge like 20 million or more
[21:43:17] <eevee> java and c++ are both awful for teaching datastructures and algorithms
[21:43:17] <tikue_> they're both recursive which is what confuses me
[21:43:18] *** Joins: pheleas_frog (Mibbit@moz-B5B2C481.ed.protectedgroup.com)
[21:43:22] <doomlord> i think you'd have to see raw pointers to really get an understanding of algorithms, maybe i'm biased with asm/C origins ...
[21:43:26] *** Quits: pheleas_frog (Mibbit@moz-B5B2C481.ed.protectedgroup.com) (User has been banned from Mozilla (no spamming here))
[21:43:30] <eevee> they have too many concerns that are neither datastructures nor algorithms
[21:43:40] <joebobjoe> Then make it tail recursive?
[21:43:47] <tikue_> https://gist.github.com/tikue/798fb3b07e81cd603828
[21:43:55] <tikue_> joebobjoe: rust doesn't have TCO yet
[21:44:12] <joebobjoe> Oh
[21:44:19] <joebobjoe> Parallel collections?
[21:44:33] <joebobjoe> eevee: What language should algos be taught in? Lisp?
[21:44:33] <tikue_> i'm not looking to rewrite my code
[21:44:41] <tikue_> just insight into why qsort is more memory efficient
[21:44:46] <carleastlund> doomlord: raw pointers have little to nothing to do with teaching algorithms.  Just taught Algorithms and Data twice at Northeastern U using Racket, had no problems at all.
[21:44:55] <sigma> 2 languages, Haskell and ASM :)
[21:45:16] <eevee> joebobjoe: python
[21:45:27] <carleastlund> Algorithms should be taught in any language that can present the concepts directly without bogging down in unnecessary details.
[21:45:49] *** Joins: jgilbert (jgilbert@moz-4C088FCE.hsd1.ca.comcast.net)
[21:45:49] <joebobjoe> carleastlund: What is Racket? Is it new?
[21:45:58] <sigma> A Lisp would work as well, but seeing the ASM and how the computer actually executes it is very useful
[21:46:09] <doomlord> c is a nice balance there, imo
[21:46:11] <eevee> sigma: sure, but learn to drive before you pop open the hood.
[21:46:25] <carleastlund> joebobjoe: Short answer: it's the new name of PLT Scheme, a Lisp/Scheme dialect; long answer: see racket-lang.org or join #racket on irc.freenode.net for more details :)
[21:46:30] <eevee> programming is first and foremost about solving problems, not figuring out where you need to put * to make the compiler happy
[21:46:44] <joebobjoe> carleastlund: Using raw pointers is not even advisable for modern C++. I do not know why my professors allow us to use them :D
[21:46:51] <carleastlund> sigma: seeing low-level machine details is a useful part of computer science, but irrelevant to algorithmic details.
[21:46:52] <sigma> eevee: dunno, most algorithms don't require any complicated instructions
[21:47:10] <doomlord> reality is about managing finite resources. with GC you sort of overlook some of it IMO.. size/speed tradeoffs
[21:47:18] <sigma> carleastlund: but being able to step through each step gives a nice level of intuition
[21:47:18] *** Joins: squiddy (squiddy@moz-4236ED38.adsl.alicedsl.de)
[21:47:29] <carleastlund> sigma: you can step through each step in any language
[21:47:34] <eevee> sigma: not complicated for an established programmer, but complicated for someone who doesn't even know what a variable is, let alone what the difference between int and long is
[21:47:43] <joebobjoe> I think Rust would be a good option for teach algos and ds, because so many things are required to be explicit.
[21:47:49] <carleastlund> doomlord: reality is, yes; but that's a separate topic from algorithms.  That's a very good topic for a systems course.
[21:48:05] <doomlord> its not so much the "where to put the *" .. some algorithms/techniques involve tricks for minimizing allocations/fragmentation whatever
[21:48:23] <doomlord> ok we'd just be arguing over names
[21:48:30] <sigma> ahh yeh, but I wouldn't try teaching a proper DS&A course until the students had some intuition for some language
[21:48:43] <jdsanders> Hey, where does the functionality of std::pipes from 0.7 live in HEAD?
[21:48:45] <joebobjoe> eevee: But Python does not have TCO, and many algos can be expressed w/ tail recursion
[21:49:20] <carleastlund> A lot of this does depend on how advanced / what kind of algos / data structures one is trying to deal with.  But even constant-factor issues can be addressed in any language.  One can imagine computers designed to natively execute Python or Lisp or Racket or Rust or whatever.
[21:49:20] *** Quits: pepper_chico (pepper_chi@14AC4DFD.704EE6B0.E4090502.IP) (Quit: Textual IRC Client: www.textualapp.com)
[21:49:37] <carleastlund> Lisp machines don't even require imagining, they did exist.
[21:49:43] <doomlord> i think peopel who come from GC langauges dont like rust,  but people who come from C/C++ do, are there exceptions..
[21:49:59] <pnkfelix> carleastlund: or just disassemble the code vectors in your favorite Scheme runtime system.  :)
[21:50:02] <eevee> i like rust and i come from...  all over the place but largely perl/python
[21:50:09] <carleastlund> I "come from" GC most recently, and I adore Rust.
[21:50:10] <tikue_> doomlord: my background is in significant part python and java, and i love rust :3
[21:50:14] <joebobjoe> doomlord: People just need to get adapted to the concept of "boxing" and "ownership" instead of "naming"
[21:50:14] <sigma> I come from GC'd languages and love rust. it gives me all the control I didn't have without losing any of the expressiveness
[21:50:22] <doomlord> ok fair enough
[21:50:33] <doomlord> seems i made a sweeping generalization :)
[21:50:36] <tikue_> :P
[21:50:39] <joebobjoe> I come from GC and I am grokking Rust, after struggling with C++
[21:50:55] <tikue_> granted, i know some SML and prolog and twelf etc, so i have an appreciation for pattern matching and functional paradigms
[21:51:08] <doomlord> a lot of it is just 'modern c  with extra checks and more convinient syntax..'
[21:51:16] <sigma> C++ programmers likely grok it all quicker as they already have an intuition for stack vs heap, etc
[21:51:37] <doomlord> maybe i'm underestimating "people who come from GC langauges" :)
[21:51:37] <carleastlund> C++ programmers are not the only ones with an intuition for stack vs heap.
[21:51:43] <joebobjoe> sigma: #c++ on freenode always get mad at me when I say the words "stack" or "heap"
[21:51:56] <sigma> no, they're not, but they all have that intuition
[21:52:13] <sigma> I wasn't saying "only c++ programmers get it quickly."
[21:52:21] <joebobjoe> carleastlund: What was the biggest issue your students ran into with Racket?
[21:52:21] <carleastlund> sigma: you've been fortunate to meet some very clever C++ programmers, I assure you the world is full of plenty who couldn't explain the difference between stack vs heap if their job depended on it.
[21:52:22] <doomlord> there's some weird zealots in the C++ community,, who look down on C, but also look down on the idea of C++ alternatives like Rust.. which are what C++ would be without C legacy... go figure..
[21:53:00] <carleastlund> joebobjoe: The only "issue" they had was unfamiliarity, which one can run into with any language, if it's not the first one you saw.
[21:53:03] <joebobjoe> doomlord: I agree. I find C++ advocates annoying. Not everyone has the time to become a language lawyer.
[21:53:15] <carleastlund> (and that was only some of them, they'd all seen _some_ Racket before, just not necessarily much or recently)
[21:53:33] <joebobjoe> carleastlund: So you taught datastructures with immutable state?
[21:53:46] <joebobjoe> I am unfamiliar with Racket
[21:53:57] <carleastlund> joebobjoe: I taught both mutable and immutable data structures.  In some cases both versions of one data structure.
[21:54:28] <joebobjoe> carleastlund: Immutable datastructures can get pretty hairy, though?
[21:54:29] <carleastlund> joebobjoe: I'll happily discuss what I taught privately but I think I'd rather not clutter up the rust channel more with a course I taught that wasn't in Rust.  :)
[21:54:36] <joebobjoe> Yes sir
[21:54:39] *** Quits: io2 (io2@moz-A6202C16.home.otenet.gr) (Quit: )
[21:55:59] <jdsanders> ah, I don't think anybody saw my question about this earlier, but in case anyone else is looking for std::pipes - looks like it lives in std::comm now
[21:57:21] <tikue_> so if anyone is interested in taking a look, i have two *very* similar mergesort algorithms, one of which can sort millions of elements, and one that cant sort more than 3000. i don't know why the one is so much better. if anyone wants to take a look, here's the gist:https://gist.github.com/tikue/798fb3b07e81cd603828
[21:57:52] *** Quits: roboguy (roboguy@moz-266CFD9E.cm.sunflower.com) (Input/output error)
[21:58:34] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[21:58:35] <pnkfelix> tikue_: clone() is not free.
[21:58:45] <tikue_> pnkfelix: neither is to_owned() i thought?
[21:59:19] <joebobjoe> tikue: You mean 3000 before it stack overflows?
[21:59:25] <tikue_> joebobjoe: yea
[21:59:35] <pnkfelix> tikue_: but you're only doing the to_owned at the leaves of the recursion, no?
[21:59:41] <tikue_> the "good" one copies the entire arrays before merging, whereas the "bad" one only copies one element at a time
[21:59:49] <tikue_> pnkfelix:  no, each level of recursion calls merge
[21:59:51] <pnkfelix> tikue_: (oh, that was not true)
[22:00:55] *** Quits: joebobjoe (Mibbit@1EEF8F2.50A2C647.5A42B74E.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[22:02:20] *** Joins: askalski (akuda@2BA4E5A7.CC7751E8.6712E96B.IP)
[22:02:57] *** Quits: miza (miza@moz-4DD51325.home.otenet.gr) (Input/output error)
[22:03:39] *** Joins: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net)
[22:03:49] *** Joins: eatkinson (eatkinson@moz-7F38FB48.airbears.berkeley.edu)
[22:04:06] *** Quits: askalski (akuda@2BA4E5A7.CC7751E8.6712E96B.IP) (Quit: Wychodzi)
[22:06:55] <pnkfelix> tikue_: Looking at this, I'm actually wondering if LLVM is managing to do TCO in one case and not the other â€¦ ?
[22:07:23] *** Quits: Jesin (Jessin_@moz-A680C20B.cc.lehigh.edu) (Quit: Leaving)
[22:07:49] <pnkfelix> tikue_: Have you tried writing new variants that use loop { â€¦ } in merge() instead of recursion?  That might be a way to experimentally test that hypothesis.
[22:08:20] <pnkfelix> tikue_: (Another way would be to inspect the generated code.  There are various switches for that, but I don't have them at my finger tips.)
[22:09:22] <tikue_> pnkfelix: i had an imperative version using loop -- it wasn't very pretty but seemed to work just fine
[22:09:35] *** Quits: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net) (Quit: dave1629)
[22:09:43] *** Joins: pepper_chico (pepper_chi@14AC4DFD.704EE6B0.E4090502.IP)
[22:09:54] <pnkfelix> tikue_: And which strategy did it use, of the two you linked? 
[22:10:15] <pnkfelix> tikue_: (I suppose it could be interesting to port both variants to loop { â€¦ } and see what happens.
[22:10:22] <tikue_> pnkfelix: it wasn't recursive -- actually i think i misunderstand your hypothesis
[22:10:42] <pepper_chico> rust is like go in respect to OO? which means it's based on structural typing ( a.k.a. static duck typing )?
[22:10:53] <benh> not really
[22:11:09] <benh> I want to say it's more like haskell in that it's not all that OO
[22:11:14] <benh> but at least everything is nominal now
[22:11:17] <engla> no duck typing in Rust
[22:11:18] <benh> not structural
[22:11:22] <tikue_> pnkfelix: it recursively sorted but did the merging iteratively, with a mutable vector
[22:11:57] <pepper_chico> oh, ok
[22:12:23] <pepper_chico> I was reading the tutorial and saw implementation of methods for enum and structures
[22:12:34] *** Joins: joebobjoe (Mibbit@1EEF8F2.50A2C647.5A42B74E.IP)
[22:12:44] <pnkfelix> tikue_: You linked to two recursive formulations, "bad_sort.rs" and "good_sort.rs"  As in both versions of merge were recursive.  I'm suggesting you take each one, and take their merge's, and make iterative versions.  And see how those behave.
[22:13:10] <pepper_chico> which is somewhat like go does, but go has the static duck typing having interfaces and using them on function arguments
[22:13:14] <joebobjoe> Why do `fn`s in Rust not close on their superscope?
[22:13:39] *** Joins: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net)
[22:13:45] <benh> closures are written like "|args| body"
[22:13:53] <tikue_> pnkfelix: the code is equivalent other than the merges though, so what would i be comparing?
[22:13:54] <benh> named `fn`s are specifically not closures
[22:14:08] <tikue_> or do you mean two different iterative versions
[22:14:23] <joebobjoe> benh: I said "why"
[22:14:32] <eevee> speaking of, what's the plan for handling conflicting trait methods
[22:14:49] <pnkfelix> tikue_: My hypothesis (with zero evidence) is that LLVM is managing to compile one variant to a tail-call-optimized version.  So I'm suggesting you get rid of the recursion yourself, but *leave in* the other differences (the calls to clone, etc)
[22:14:55] <pepper_chico> I suppose rust takes advantage of generic programming for polymorphism instead of static duck typing
[22:14:56] <mm> joebobjoe: There's overhead associated with having a closure, and most of the time you don't want one.
[22:15:15] <tikue_> pnkfelix: ok i gotcha, i'll try it out
[22:15:31] *** Joins: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[22:15:49] <pnkfelix> tikue_: (I'd actually be very surprised if I was right; I don't have much intuition for what LLVM can and cannot do)
[22:16:45] <joebobjoe> mm: What do you mean by, "most of the time you don't want one?"
[22:17:16] *** Joins: roboguy (roboguy@moz-266CFD9E.cm.sunflower.com)
[22:17:17] <carleastlund> joebobjoe: most of the time you probably don't want to keep extra references to the enclosing scope around for arbitrary amounts of time.
[22:17:31] <carleastlund> (that's my assumption, anyway)
[22:18:12] <joebobjoe> Yea but why
[22:18:38] <carleastlund> Because then you can't release any of the resources you've kept that extra reference to.
[22:18:44] <pnkfelix> joebobjoe: one decent reason: because it complicates reasoning about when objects die
[22:20:29] <joebobjoe> hm
[22:22:02] *** Quits: joebobjoe (Mibbit@1EEF8F2.50A2C647.5A42B74E.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[22:23:00] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[22:23:41] *** Quits: Uther (Instantbir@moz-1B244B05.hfc.dyn.abo.bbox.fr) (Ping timeout)
[22:24:41] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[22:31:54] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Connection reset by peer)
[22:32:21] <glyc> I'm curious about building rust, since llvm takes forever. I already have llvm3.3 installed, is there some way to tell the rust build system to use the pre-installed llvm ?
[22:32:38] <mm> glyc: No, rust has patches applied to LLVM
[22:32:42] <pnkfelix> glyc: you have to use our fork of LLVM, unfortunately
[22:32:49] <glyc> ah, drat, was afraid of that
[22:32:50] <glyc> ok
[22:33:09] <mm> Hopefully in the future things can be stabalized and upstreamed, but it's not happening for now
[22:33:17] <glyc> gotcha
[22:34:17] <tikue_> pnkfelix:  turns out i messed up -- i had commented out the actual function call >_< they're both equally bad heh
[22:34:43] <pnkfelix> tikue_: Okay.
[22:35:06] <pnkfelix> tikue_: But an iterative loop { â€¦ } version of merge works fine, right?
[22:35:57] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[22:35:59] <tikue_> pnkfelix: i haven't finished writing that version yet. having issues with multiple mutable borrowed pointers
[22:38:49] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[22:41:54] *** Joins: tjc (tjc@5FEEDD2E.870F2FA5.2370DFC3.IP)
[22:41:54] *** ChanServ sets mode: +o tjc
[22:42:06] *** Quits: roboguy (roboguy@moz-266CFD9E.cm.sunflower.com) (Input/output error)
[22:42:54] *** tjc changes topic to 'New Runtime is landed! http://www.rust-lang.org | logs at https://botbot.me/mozilla/rust/ and http://irclog.gr/#browse/irc.mozilla.org/rust | Code of conduct: https://github.com/mozilla/rust/wiki/Note-development-policy#conduct | http://huonw.github.io/isrustfastyet/mem/ | landings http://buildbot.rust-lan'
[22:43:01] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[22:43:49] <cmr> mm: someone is actually working on upstreaming the patches right now
[22:43:54] *** Quits: sebcrozet (sebcrozet@moz-A855F6C0.w82-127.abo.wanadoo.fr) (Quit: Gone)
[22:44:33] *** tjc changes topic to 'http://www.rust-lang.org | logs at https://botbot.me/mozilla/rust and http://irclog.gr/#browse/irc.mozilla.org/rust | Code of conduct: https://github.com/mozilla/rust/wiki/Note-development-policy#conduct | http://huonw.github.io/isrustfastyet/mem | landings http://buildbot.rust-lang.org/console'
[22:46:00] *** Joins: riddochc (riddochc@moz-DC89FF14.ip.mcleodusa.net)
[22:46:51] <mark_edward> hown  would you guys compare Rust to Nimrod?
[22:47:09] <cmr> mark_edward: yes.
[22:47:30] <cmr> except nimrod seems to be a much smaller/dead project
[22:47:53] <mark_edward> cmr: Really? they seem to be much arther along than rust. at least more stable
[22:48:00] <tikue_> rusti: let mut it = (~[1u, 2, 3]).move_iter().peekable(); match it.peek() { Some(_) => it.next(), None => it.next() }
[22:48:01] -rusti- Some(1u)
[22:48:55] <doomlord> i saw they want to remove the wikipedia page on nimrod
[22:49:06] <glyc> outrageous
[22:49:34] <mark_edward> who? why? i thought nimrod was mroe popular than rust
[22:50:00] <doomlord> what are its key features... compare/constrast
[22:50:09] <cmr> 20 contributors
[22:50:16] <tikue_> rusti: let mut it1 = (~["a", "b", "c"]).move_iter().peekable(); let mut it2 = (~[1u, 2, 3]).move_iter().peekable(); match (it1.peek(), it2.peek()) { (Some(_), _) => it.next(), _ => it2.next() }
[22:50:24] -rusti- pastebinned 5 lines of output: http://ix.io/7Nm
[22:50:25] <cmr> though the main author seems fairly active.
[22:50:43] <tikue_> rusti: let mut it1 = (~["a", "b", "c"]).move_iter().peekable(); let mut it2 = (~[1u, 2, 3]).move_iter().peekable(); match (it1.peek(), it2.peek()) { (Some(_), _) => it1.next(), _ => it2.next() }
[22:50:47] -rusti- pastebinned 5 lines of output: http://ix.io/7Nn
[22:50:49] <mark_edward> doomlord: i want to see ethat as well. i don't know very much about nimrod, and they seem to be "in our space" so to speak
[22:51:03] <tikue_> rusti: let mut it1 = (~["a", "b", "c"]).move_iter().peekable(); let mut it2 = (~[1u, 2, 3]).move_iter().peekable(); match (it1.peek(), it2.peek()) { (Some(_), _) => it1.next(), _ => it1.next() }
[22:51:04] -rusti- Some("a")
[22:51:07] <jeaye> rusti: format!("\\2")
[22:51:07] -rusti- <anon>:5:17: 5:22 error: invalid escape character `2`
[22:51:08] -rusti- <anon>:5          format!("\\2")
[22:51:08] -rusti-                           ^~~~~
[22:51:08] -rusti- error: aborting due to previous error
[22:51:08] -rusti- application terminated with error code 101
[22:51:11] <jeaye> rusti: format!("\\\\2")
[22:51:12] -rusti- ~"\\2"
[22:51:28] <jeaye> rusti: format!("\\\2")
[22:51:28] -rusti- <anon>:5:16: 5:17 error: unknown string escape: 50
[22:51:28] -rusti- <anon>:5          format!("\\\2")
[22:51:28] -rusti-                          ^
[22:51:28] -rusti- application terminated with error code 101
[22:52:13] <tikue_> pnkfelix: do you think you could take a look at my merge function? i'm getting borrow check compiler error that doesn't make sense to me
[22:53:34] <pnkfelix> tikue_: I can look briefly, but I'm going to be hitting the sack in 10 min or so
[22:53:39] <tikue_> ok, i appreciate it
[22:53:48] <tikue_> https://gist.github.com/tikue/798fb3b07e81cd603828#file-merge-rs 
[22:53:56] <tikue_> that's the fn, and the compile error is in that gist as well
[22:54:19] <pnkfelix> tikue_: By the way, there is a merge sort in src/libextra/sort.rs, in case you want a working reference to read
[22:54:29] <tikue_> pnkfelix: oh right! i forgot about that. thank you
[22:55:20] <engla> tikue_: it's borrow check because .peek() returns a reference that freezes the peekable iterator
[22:55:32] <tikue_> engla: yes, but then i destructure the reference
[22:55:32] <tikue_> immediate
[22:55:35] <tikue_> imediately
[22:55:40] <tikue_> gah, immediately*
[22:56:18] <tikue_> engla: i did the same thing above but it didn't cause an error
[22:56:22] <tikue_> rusti: let mut it1 = (~["a", "b", "c"]).move_iter().peekable(); let mut it2 = (~[1u, 2, 3]).move_iter().peekable(); match (it1.peek(), it2.peek()) { (Some(_), _) => it1.next(), _ => it1.next() }
[22:56:23] -rusti- Some("a")
[22:56:50] <engla> tikue_: that's not the case for your last case in the match. but sure, there are errors about the earlier lines too..
[22:57:06] <engla> tikue_: does Some(*) make a difference?
[22:57:11] <engla> compared to Some(_)
[22:58:19] <engla> treemap extracts a comparison result from .peek() and returns it before matching on the comparison. https://github.com/mozilla/rust/blob/master/src/libextra/treemap.rs#L601
[22:58:54] <tikue_> oh interesting
[22:59:08] <tikue_> the * doesn't make a difference
[23:00:27] <benh> rusti: println!("\\\\2 {}")
[23:00:28] -rusti- <anon>:5:18: 5:28 error: invalid reference to argument `0` (there are 0 arguments)
[23:00:28] -rusti- <anon>:5          println!("\\\\2 {}")
[23:00:28] -rusti-                            ^~~~~~~~~~
[23:00:28] -rusti- error: aborting due to previous error
[23:00:28] -rusti- application terminated with error code 101
[23:00:31] <tikue_> rusti: Some(1u) < None
[23:00:32] -rusti- false
[23:00:37] <tikue_> rusti: None < Some(1u)
[23:00:38] -rusti- true
[23:00:40] <benh> rusti: println!("\\\\2 {}", 5)
[23:00:41] -rusti- \2 5
[23:00:41] -rusti- ()
[23:00:48] <tikue_> rusti: Some(1u) < Some(2u)
[23:00:48] -rusti- true
[23:00:56] <tikue_> rusti: Some(2u) < Some(1u)
[23:00:57] -rusti- false
[23:01:00] <tikue_> interesting
[23:01:19] <tikue_> rusti: cmp(Some(2u), Some(1u))
[23:01:20] -rusti- <anon>:5:9: 5:12 error: unresolved name `cmp`.
[23:01:20] -rusti- <anon>:5          cmp(Some(2u), Some(1u))
[23:01:20] -rusti-                   ^~~
[23:01:20] -rusti- error: aborting due to previous error
[23:01:20] -rusti- application terminated with error code 101
[23:01:22] <engla> Option is ordered like a vector where None is [] and Some(x) is [x]
[23:01:46] <tikue_> rusti: use std::cmp::cmp; cmp(Some(2u), Some(1u))
[23:01:48] -rusti- pastebinned 8 lines of output: http://ix.io/7Np
[23:01:48] <erickt> does anyone know if it's possible to merge symbols in a macro?
[23:01:52] <pnkfelix> tikue_: is it even necessary to use peek here?
[23:02:12] <tikue_> pnkfelix: yeah, because if it's (Some, Some) you need to compare against the larger one in the next iteration
[23:02:13] <pnkfelix> tikue_: (oh, never mind, yes.  I need to go to bed)
[23:02:17] <tikue_> :) night
[23:03:15] <tikue_> rusti: TotalOrd::cmp(Some(1u), Some(2u))
[23:03:15] -rusti- <anon>:5:9: 5:22 error: unresolved name `TotalOrd::cmp`.
[23:03:16] -rusti- <anon>:5          TotalOrd::cmp(Some(1u), Some(2u))
[23:03:16] -rusti-                   ^~~~~~~~~~~~~
[23:03:16] -rusti- error: aborting due to previous error
[23:03:16] -rusti- application terminated with error code 101
[23:03:32] *** Quits: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com) (Ping timeout)
[23:03:36] <sfackler> erict: there is concat_idents! but it can only handle idents :(
[23:03:51] <erickt> sfackler: thanks! that works for me
[23:04:18] <engla> you'll need luck erickt 
[23:04:42] <engla> luck or a better concat_idents!
[23:06:24] *** Quits: pepper_chico (pepper_chi@14AC4DFD.704EE6B0.E4090502.IP) (Quit: Textual IRC Client: www.textualapp.com)
[23:06:38] <glyc> is there a way to control ram usage during a build?  my build machine has 384MB and I'm running out of memory and gettting killed at: compile_and_link: x86_64-unknown-linux-gnu/stage0/lib/rustc/x86_64-unknown-linux-gnu/lib/libextra.so
[23:06:57] <engla> tikue_: ah, I guess those treemap iterators implement basically the same algorithm
[23:06:57] <glyc> (build of rust)
[23:07:11] <engla> tikue_: except Union skips duplicates
[23:07:32] <tikue_> engla: yeah it looks really similar.
[23:08:01] <pnkfelix> glyc: I don't think that's enough RAM, not right now
[23:08:21] <pnkfelix> glyc: I think one of the readmes documents the current peak memory usage of the self-hosted build
[23:08:26] <glyc> prikfelix: arg. ok. I'll upgrade the vm.
[23:08:29] <benh> I thought we were looking at multiple gigabytes right now.
[23:08:40] <jeaye> rusti: println!("\\\\2 {}", 5)
[23:08:42] -rusti- \2 5
[23:08:42] -rusti- ()
[23:08:52] <jeaye> rusti: format!("\\\\2 {}", 5)
[23:08:53] -rusti- ~"\\2 5"
[23:09:02] <tikue_> engla: it's strange. it compiles if i take out the last case
[23:09:03] <benh> README.md says 1.8G
[23:09:10] <engla> tikue_: it should :)
[23:09:11] <tikue_> engla: it's like the vars are binding in the other match arms
[23:09:17] <pnkfelix> glyc: see this: https://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust
[23:09:18] <engla> nice
[23:09:19] <benh> jeaye: oh :(
[23:09:24] <tikue_> engla: right but why are there phoney compile errors?
[23:09:25] <jeaye> benh: :P
[23:09:36] <benh> oh, that's just the string being printed as a literal
[23:09:43] <glyc> prikfelix: I'll check that out. thanks.
[23:09:46] <benh> rusti: println(format!("\\\\2 {}", 5))
[23:09:47] -rusti- \2 5
[23:09:47] -rusti- ()
[23:09:55] <jeaye> benh: Ah. That was misleading.
[23:09:57] <engla> tikue_: good question. could report a bug
[23:10:05] <benh> Backslashes are the devil
[23:10:09] <jeaye> hehe
[23:10:33] <eevee> why does the new format syntax use backslashes
[23:11:22] *** Quits: tjc (tjc@5FEEDD2E.870F2FA5.2370DFC3.IP) (Ping timeout)
[23:12:32] <engla> it doesn't
[23:13:02] <benh> rusti: println!("\\ \\{ \\}")
[23:13:02] -rusti- <anon>:5:18: 5:30 error: invalid escape character ` `
[23:13:03] -rusti- <anon>:5          println!("\\ \\{ \\}")
[23:13:03] -rusti-                            ^~~~~~~~~~~~
[23:13:03] -rusti- error: aborting due to previous error
[23:13:03] -rusti- application terminated with error code 101
[23:13:08] <benh> rusti: println!("\\\\ \\{ \\}")
[23:13:09] -rusti- \ { }
[23:13:10] -rusti- ()
[23:13:31] <riddochc> So, I'm curious. It's been (comparatively) a while since 0.7, and a lot of changes since then. What's the plan for an 0.8 release?
[23:13:37] <tikue_> engla: any idea what i would call this error?
[23:14:00] <engla> I don't know
[23:14:13] <cmr> riddochc: there is a release every three months
[23:14:34] <SiegeLord> So is it known why you need to doubly escape things, and will it be fixed?
[23:15:05] <pnkfelix> tikue_: Here's a variant that compiles https://gist.github.com/pnkfelix/6418092
[23:15:19] <benh> I figure it's because you write a string literal in the first place with the usual backslash escapes, then the formatting bits parse the string literal and do their own special treatment of backslashes
[23:15:34] <benh> I assume it's not a bug...
[23:15:43] <eevee> it greatly resembles one  :)
[23:15:51] <tikue_> pnkfelix: good workaround, thanks for the inspiration :)
[23:15:56] <SiegeLord> Why does it need to do special treatment of backslashes?
[23:15:57] <benh> There's a few things I'd like to declare bugs but alas...
[23:16:01] <benh> SiegeLord: So you can escape { }
[23:16:13] <benh> In case you want to generate a string that literally contains { }
[23:16:18] <pnkfelix> tikue_: I don't know if the style is what nmatsakis would do.  But its a pattern I have been resorting to a lot recently, mostly to keep my head sane while trying to reason about the borrowing
[23:16:25] <benh> I assume you're with the "should use {{ / }}" camp?
[23:16:30] <riddochc> cmr: Ok, I hadn't noticed that.  There's projects on github that don't build with 0.7, do most people just use the tip of master, or what?
[23:16:39] <SiegeLord> That or allow arbitray characters after \
[23:16:43] <SiegeLord> *arbitrar
[23:16:45] <SiegeLord> y
[23:16:45] *** Joins: tjc (tjc@D3A278CC.854F919D.8B824544.IP)
[23:16:45] *** ChanServ sets mode: +o tjc
[23:16:51] <tikue_> pnkfelix: i had something that compiled yesterday without doing it, but i can't for the life of me remember what i did
[23:16:52] <cmr> riddochc: yes, either master, or they're out of date.
[23:17:08] <eevee> benh: {{ is certainly less weird than quadruple backslashes
[23:17:16] <benh> eevee: agreed
[23:17:33] <eevee> imagine if the output were headed for a regex engine!  octuple backslashes
[23:18:48] <engla> eevee: unfortunately there are some format features that will use nested { }  already
[23:18:53] <benh> clearly we should ship a regexp engine that uses a different character for its escapes
[23:18:57] <benh> like %!
[23:18:58] <engla> eevee: https://github.com/mozilla/rust/blob/master/src/libstd/fmt/mod.rs
[23:19:15] <engla> (select and plural)
[23:19:16] <tikue_> riddochc: yeah master is definitely preferred
[23:19:41] <eevee> well, you only /really/ need to escape {
[23:20:08] <benh> you need to escape } too because currently a spurious } confuses the formatter ;)
[23:20:14] <benh> rusti: println!("foo } bar")
[23:20:15] -rusti- foo 
[23:20:16] -rusti- ()
[23:20:18] <eevee> well then.
[23:20:27] <eevee> that one's definitely a bug  :)
[23:20:34] <benh> yeah, I filed an issue :))
[23:20:37] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Ping timeout)
[23:20:57] *** Quits: tjc (tjc@D3A278CC.854F919D.8B824544.IP) (Ping timeout)
[23:20:58] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Ping timeout)
[23:21:01] <riddochc> cmr, tikue_: Thanks. I wasn't quite sure about the role of the other branches (e.g. try3?) - Is that documented somewhere?
[23:21:19] <benh> My guess is they're related to the operation of the build bots
[23:21:34] <SiegeLord> Does the select and plural require { and { to be next to each other?
[23:21:38] <engla> tikue_: you shouldn't clone in the Some, Some case though
[23:21:55] <cmr> riddochc: those are internal to the project.
[23:22:08] <engla> tikue_: you can use .next() on the chosen iterator and get the value
[23:22:22] <pnkfelix> rusti: println!("{} who needs to escape curly braces? {}", "{", "}")
[23:22:23] -rusti- { who needs to escape curly braces? }
[23:22:23] -rusti- ()
[23:22:24] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[23:23:03] <eevee> can select and plural just...  use a different delimiter?
[23:23:24] <SiegeLord> If so, I'd still do {{ for literal { and "{ {" for whatever use plural/select do
[23:23:27] *** Joins: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com)
[23:23:32] <SiegeLord> Not that I really think they need it, from what I'm reading
[23:23:45] <tikue_> engla: implicitly cloneable values would fix this problem right? because then you could do (Some(&el1), Some(&el2))
[23:23:47] <tikue_> no reference
[23:24:03] <tikue_> it's just the generic version that has issues
[23:24:31] <engla> well yes. but you can use the .peek references to compare, when you feed the next value you can use .next()
[23:24:34] <engla> instead of cloning
[23:24:56] <tikue_> engla: i wasn't cloning though
[23:25:07] *** Quits: kgriffs (Adium@moz-7E0D846A.aus1.rackspace.com) (Ping timeout)
[23:25:13] <SiegeLord> Alternatively, you can also make the formatter's handling of \ to be more permissive
[23:25:15] *** Joins: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[23:25:20] <engla> aha ok I was reading the other paste
[23:25:25] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[23:25:36] <tikue_> ah gotcha
[23:25:39] *** Joins: tjc (tjc@5FEEDD2E.870F2FA5.2370DFC3.IP)
[23:25:39] *** ChanServ sets mode: +o tjc
[23:25:40] <engla> sorry
[23:28:09] *** Quits: eatkinson (eatkinson@moz-7F38FB48.airbears.berkeley.edu) (Quit: eatkinson)
[23:29:25] <tikue_> it'd be nice to be able to clone in patterns
[23:29:27] <tikue_> explicitly
[23:30:02] <pnkfelix> tikue_: I think the language already tried that path
[23:30:32] <pnkfelix> tikue: (back when it had explicit `copy` and `move` operators.)
[23:30:39] <benh> Presumably you'd clone the thing you're matching on and then move out of the patterns?
[23:31:05] <tikue_> pnkfelix: ah, right
[23:31:31] <jeaye> Best way to track down this error? http://dpaste.com/1364092/
[23:31:31] <tikue_> benh: how do you move out of the pattern?
[23:31:37] <jeaye> It doesn't say anything about my source.
[23:31:39] <dcrewi> does rust forbid borrowing a mutable reference to something that is borrowed in more than one task?
[23:31:48] <benh> I thought moving is what happens when you don't say ref?
[23:31:49] <tikue_> why doesn't `let _ = ptr` move it out of scope?
[23:31:58] <tikue_> benh: yeah it does
[23:32:06] <jeaye> dcrewi: Borrowed pointers are not safe between tasks.
[23:32:18] <tikue_> benh: but the problem isn't cloning
[23:32:20] <dcrewi> jeaye: oh, that is right
[23:32:25] <jeaye> dcrewi: And borrowing something as mutable that's already borrowed by something else (mutable or not) is not safe.
[23:32:36] <tikue_> benh: the problem is how to not have a reference to the original thing
[23:32:46] <tikue_> benh: so that it doesn't freeze the object
[23:32:56] <engla> tikue_: we knew this would be tricky when adding the Peekable thing. but we didn't come up with a solution more than that treemap link :)
[23:33:06] <dcrewi> jeaye: so in that case, you can't borrow it mutably?
[23:33:17] <tikue_> engla: it certainly is tricky!
[23:33:27] <tikue_> engla: one thought i had was having a put_back() method
[23:33:44] *** Quits: threecreepio (jdp@moz-71E164C9.cust.bredbandsbolaget.se) (Quit: threecreepio)
[23:33:53] <jeaye> dcrewi: If it's inter-task, definitely not. If it's borrowed by something else already, definitely not. You can try managed boxes, or just re-work your design.
[23:33:58] <jeaye> As far as I know, anyway.
[23:34:00] *** Quits: riddochc (riddochc@moz-DC89FF14.ip.mcleodusa.net) (Quit: *poof*)
[23:35:45] <dcrewi> jeaye: I'm writing some code that uses util::swap and/or util::replace and was wondering how it could possibly be thread-safe; the answer is because the compiler restricts taking mutable references
[23:40:31] *** Joins: samx (sami@moz-D9DA5773.dyn.optonline.net)
[23:40:44] <jdsanders> Hey - when I try to add an immutable vector to a mutable vector using +=, I get "error: binary operation + cannot be applied to type `@[<V7>]`", but when I use `x = x + y`, it works fine - is this intended, or is it a bug?
[23:41:11] <tikue_> engla: ok, this is the best i can do: https://gist.github.com/tikue/798fb3b07e81cd603828#file-merge-rs
[23:41:21] <cmr> jdsanders: @[] is never mutable.
[23:41:57] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[23:42:23] <kimundi> jdsanders: And I think the assign operator variants are still disabled untile their get proper overload support
[23:42:32] <engla> tikue_: haha, I that double match is tempting but I think I'd prefer a temporary. but yes, that's what you have to do I guess. Why not extend your notion of less than to Option and use true/false instead of left right?
[23:42:50] <kimundi> Anyone know what to do if 'make tidy' exists with error 123?
[23:43:07] <pnkfelix> kimundi: does it really not report what went wrong?
[23:43:26] <kimundi> nope
[23:43:54] <kimundi> wait...
[23:43:57] <pnkfelix> kimundi: I'd use a mix of `remake â€”trace` and or the VERBOSE=1 argument to make to track down what command line was actually running.
[23:44:07] <pnkfelix> kimundi: and then I'd check if I could reproduce the error
[23:44:09] <jdsanders> cmr, kimundi: thanks
[23:44:17] <kimundi> Ah, it DOES report what goes wrong, it's just inermingeld between the NOTE reportings
[23:44:28] <kimundi> too long line
[23:44:47] <pnkfelix> kimundi: maybe we need to make that a rust lint warning.  :)
[23:45:21] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[23:45:22] * pnkfelix ducks
[23:45:26] *** Joins: roboguy (roboguy@moz-266CFD9E.cm.sunflower.com)
[23:45:44] *** Joins: tupshin (quassel@moz-E7B03838.c3-0.nyr-ubr1.nyr.ny.cable.rcn.com)
[23:45:51] <kimundi> pfff, it'S one char to long :P
[23:46:13] <kimundi> because I renmaed 'm_imm' to MutImmutable''
[23:46:26] <cmr> MutImmutable
[23:46:33] <cmr> that's an oxymoron if ever I saw one.
[23:46:47] <kimundi> there is also MutMutabler
[23:46:58] <kimundi> The first Mut is for 'Mutability'
[23:47:12] <cmr> can't it just be Mutable and Immutable?
[23:47:25] *** Quits: tjc (tjc@5FEEDD2E.870F2FA5.2370DFC3.IP) (Ping timeout)
[23:47:36] <mark_edward> dbaupp: ping
[23:47:51] <kimundi> cmr: Maybe, but with the broad scope of code it touched I didn't want to make any more risks ;)
[23:48:14] <tikue_> engla: once more, with feeling: https://gist.github.com/tikue/798fb3b07e81cd603828#file-merge-rs
[23:48:31] <jeaye> I'm getting an error that doesn't hint to any of my own source. Ideas?
[23:48:32] <jeaye> <std-macros>:69:49: 69:67 error: too many arguments to fmt!. found 2, expected 1
[23:48:34] <jeaye> <std-macros>:69             ::std::sys::FailWithCause::fail_with(fmt!( $($arg),+ ), file!(), line!())
[23:48:39] <engla> nice tikue_ 
[23:48:43] <kimundi> The current style for enum variants seems to be to give then a Prefix, for better or worse
[23:49:27] <kimundi> jeaye: You're passing an additional second argument to fail! without including it in the format string
[23:49:52] <kimundi> rusti: if true { fail!(" test, %s", "foo") }
[23:49:53] -rusti- task <unnamed> failed at ' test, foo', <anon>:5
[23:49:53] -rusti- application terminated with error code 101
[23:49:59] <kimundi> rusti: if true { fail!(" test", "foo") }
[23:50:00] -rusti- <std-macros>:69:49: 69:67 error: too many arguments to fmt!. found 2, expected 1
[23:50:00] -rusti- <std-macros>:69             ::std::sys::FailWithCause::fail_with(fmt!( $($arg),+ ), file!(), line!())
[23:50:00] -rusti-                                                                  ^~~~~~~~~~~~~~~~~~
[23:50:00] -rusti- application terminated with error code 101
[23:50:04] <jeaye> kimundi: That's what I guessed too, but searching for every fail! in my source didn't turn anything up that looked back. I can look again.
[23:50:14] <kimundi> hmm
[23:50:17] <jeaye> s/back/bad/
[23:51:54] <engla> tikue_: if you want to benchmark it you should use vec::with_capacity for the merged vector so that it doesn't need to grow
[23:52:15] <tikue_> engla: good call
[23:52:18] <jdsanders> Is there a better way to iterate over a `&[int]` than `for i in v.iter() { â€¦ }`?
[23:52:36] <cmr> jdsanders: no, why?
[23:52:39] *** Quits: Shaladdle (Shaladdle@moz-424BC304.hsd1.pa.comcast.net) (Quit: Leaving)
[23:52:40] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[23:52:41] <jeaye> rusti: fail!("({}) {}", 43, 53)
[23:52:42] -rusti- <std-macros>:69:49: 69:67 error: too many arguments to fmt!. found 3, expected 1
[23:52:42] -rusti- <std-macros>:69             ::std::sys::FailWithCause::fail_with(fmt!( $($arg),+ ), file!(), line!())
[23:52:42] -rusti-                                                                  ^~~~~~~~~~~~~~~~~~
[23:52:42] -rusti- application terminated with error code 101
[23:52:47] <jeaye> ahah!
[23:53:05] <mark_edward> what's the rust equivalent of sprintf?
[23:53:08] *** Joins: tjc (tjc@D3A278CC.854F919D.8B824544.IP)
[23:53:08] *** ChanServ sets mode: +o tjc
[23:53:16] <benh> format!
[23:53:18] <cmr> mark_edward: fmt!/format! both return a string.
[23:53:36] <eevee> benh is very excited about string formatting
[23:53:39] <kimundi> jdsanders: That's the best way. There are planns to make the .iter() call uneccessary in the future.
[23:53:40] <mark_edward> right but say i wanted to like add to a string
[23:53:44] <benh> yup
[23:53:56] <jdsanders> cmr: I guess explicitly asking for the iterator from a vector seems odd to me because I think of vectors as fundamentally iterable
[23:53:58] <jeaye> benh: Is that a bug, or am I missing something? ^
[23:54:01] <jdsanders> kimundi: ah, makes sense
[23:54:16] <eevee> btw i love the new `for` syntax and also the generic `range` in prelude
[23:54:17] <cmr> jdsanders: They are iterable, that's why they have iterators over them :)
[23:54:31] <jeaye> eevee: :)
[23:54:32] <benh> jeaye: I think fail! might still use the old fmt! instead of the new format!
[23:54:34] <cmr> jdsanders: you need to create an iterator object that keeps track of where you are.
[23:54:35] <eevee> just be python with typing imo
[23:54:42] <cmr> vectors don't store that information themselves.
[23:54:53] <benh> rusti: fail!("(%d) %d", 43, 53)
[23:54:57] -rusti- pastebinned 9 lines of output: http://ix.io/7Nt
[23:55:03] <tikue_> cmr: still, there are plans in the vein of what kimundi suggests right?
[23:55:14] <cmr> tikue_: no, afaik they've been abandoned as infeasible.
[23:55:17] <benh> well, rusti doesn't like failing halfways though :(
[23:55:19] <cmr> ask strcat when he's on.
[23:55:24] <jeaye> rusti: if true { fail!("(%d) %d", 43, 53) }
[23:55:25] -rusti- task <unnamed> failed at '(43) 53', <anon>:5
[23:55:26] -rusti- application terminated with error code 101
[23:55:36] *** Quits: carleastlund (cce@moz-C8071335.c3-0.smr-ubr1.sbo-smr.ma.cable.rcn.com) (Quit: carleastlund)
[23:55:48] <jeaye> benh: Gah! :(
[23:55:58] <jeaye> Inconsistencies make me sad.
[23:56:08] <jdsanders> cmr: that makes sense to me, there is this difference between in my mind between just "iterable" and "fundamentally" or "innately" iterable, but I get that the distinction doesn't make too much sense :)
[23:56:48] <jeaye> rusti: if true { fail!("{}", 4) }
[23:56:48] -rusti- <std-macros>:69:49: 69:67 error: too many arguments to fmt!. found 2, expected 1
[23:56:48] -rusti- <std-macros>:69             ::std::sys::FailWithCause::fail_with(fmt!( $($arg),+ ), file!(), line!())
[23:56:48] -rusti-                                                                  ^~~~~~~~~~~~~~~~~~
[23:56:48] -rusti- application terminated with error code 101
[23:57:16] <benh> jdsanders: the difference between iterator and iteratee? :)
[23:58:03] <kimundi> https://github.com/mozilla/rust/pull/8939 r+ anyone? I'm only 85% sure it will pass the test suite, but bors doesn't have much to do right now so... (I can't test all platforms anyway)
[23:58:14] <jdsanders> benh: yeah
[23:58:54] <jdsanders> kimundi: if there are plans to make .iter() unnecessary, how would that work? Would it just be syntax sugar, or would vectors actually be changed somehow?
[23:59:17] <benh> I assumed the for-loop would just call .iter() so we wouldn't have to
[23:59:27] <benh> (idempotent .iter() on Iterators?)
[23:59:52] <kimundi> jdsanders: It would work with an Iterable trait that vector implements, and that the 'for' syntax would use as alternative to the 'Iterator' trait

[00:00:45] *** Parts: synackse (jordyd@2D608993.77F880E0.D9401097.IP) ()
[00:01:03] *** Joins: synackse (jordyd@2D608993.77F880E0.D9401097.IP)
[00:02:05] <jadbaires> what...  (*s).x can be written s.x  ?
[00:02:16] <jadbaires> can't this be confusing?
[00:02:27] *** Quits: marianoguerra (marianogue@moz-F325B300.dip0.t-ipconnect.de) (Ping timeout)
[00:02:44] *** Quits: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net) (Ping timeout)
[00:02:49] <Eridius> jadbaires: auto-deref
[00:02:52] <jadbaires> as in looking at code s would appear to be a struct whereas it actually is a pointer to one
[00:02:53] <Eridius> it's useful
[00:03:45] *** Quits: cgaebel (clark@ADA4DDE2.290DF317.EE6E63A5.IP) (Quit: ChatZilla 0.9.90.1 [Firefox 26.0/20131206145143])
[00:04:07] <jadbaires> is there more to it than just being able to write s.x rather than (*s).x?
[00:04:08] *** Joins: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP)
[00:04:41] <jadbaires> Eridius: some sort of more advanced usage
[00:04:48] <o11c> it's useful all the way up until the language implements smart pointers
[00:05:03] <jadbaires> what are those?
[00:05:15] <dbaupp> o11c: in what way? you mean because it doesn't work on smart pointers?
[00:05:16] <o11c> in rust, Gc<> and Rc<>
[00:05:38] <o11c> dbaupp: because smart pointers have members of their own as well as members of their target
[00:05:49] <strcat> o11c: so does ~
[00:05:54] <o11c> yeah, I know auto-deref isn't implemented for rust's smart pointers *yet*
[00:06:11] <o11c> strcat: ... right, I forgot about that part of Rust
[00:06:14] *** Quits: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP) (Ping timeout)
[00:06:42] <o11c> but isn't that only methods, not fields?
[00:06:42] <jadbaires> so... what is the purpose of auto-deref? the main motivation
[00:06:59] <dbaupp> o11c: auto-deref is slightly intelligent (i.e. you can call methods on the underefed type, and presumably access fields), but yeah, it's annoying trying to convince the compiler that you actually want to call some method on the outer type, not the inner one
[00:06:59] <Matthias247> less typing
[00:07:02] <o11c> to get rid of the parentheses
[00:07:30] <dbaupp> jadbaires: foo().bar().baz() is waaaaay nicer than (*(*foo()).bar()).baz()
[00:07:31] <o11c> it's not the *s that are the problem, is the precedence issuee
[00:07:57] <jadbaires> why not go the C path and do something like  foo()->bar()->baz()
[00:08:03] <eddyb> jadbaires: please no
[00:08:09] <jadbaires> eddyb: why?
[00:08:11] <Eridius> dbaupp: calling methods on the outer type will be easier once we have UFCS
[00:08:30] <Eridius> jadbaires: among other things, that route doesn't work if you have multiple indirections to go through
[00:08:33] <Eridius> which auto-deref supports
[00:08:50] <o11c> admittedly it's a hack, but half the time in C++, I write foo()[0]->bar()[0]->baz()
[00:09:03] <Eridius> o11c: hah, I never even thought of that before
[00:09:12] <Eridius> foo()[0][0].bar()
[00:09:20] <o11c> if not for the 0, that wouldn't be terrible
[00:09:23] <mark_edward> simply add support for each hyphen indicating a level of indirection (**x).foo() -> x-->foo() !!!!
[00:09:24] <jadbaires> Eridius: what do you mean by  multiple indirections? 
[00:09:34] <jadbaires> Eridius: ~~T
[00:09:35] <jadbaires> ?
[00:09:36] <o11c> the precedence issue is basically "we don't have a postfix deref operator"
[00:09:36] <Eridius> rusti: let x = &&&5i; x.clone()
[00:09:37] -rusti- <anon>:10:17: 10:19 error: unexpected token: `&&`
[00:09:37] -rusti- <anon>:10         let x = &&&5i; x.clone()
[00:09:37] -rusti-                           ^~
[00:09:37] -rusti- application terminated with error code 101
[00:09:39] <Eridius> meh
[00:09:48] <Eridius> rusti: let x = &(&(&5i))); x.clone()
[00:09:50] -rusti- pastebinned 7 lines of output: http://ix.io/age
[00:10:03] <Eridius> pfft, getting parens wrong. But you get the idea
[00:10:07] <jadbaires> right I see
[00:10:13] <jadbaires> pointer to pointer to pointer
[00:10:16] <Matthias247> mark_edward: not bad ;)
[00:10:42] <Eridius> jadbaires: it's nice because that means that things that vend pointers like .iter() can often be ignored
[00:10:54] <dbaupp> Eridius: yes, it will; I've been hanging out for UFCS for #[deriving] for forever :P
[00:11:02] *** Quits: hacker_sam (hacker_sam@C0FE520A.661C02A7.B0CE379A.IP) (Connection reset by peer)
[00:11:11] <dbaupp> (don't konw how it will work with field access though, as o11c points out)
[00:11:12] <jadbaires> Eridius: oh
[00:11:23] *** Joins: hacker_sam (hacker_sam@C0FE520A.661C02A7.B0CE379A.IP)
[00:11:28] <Eridius> dbaupp: it didn't occur to me until now that UFCS needs to be able to support something like (&int)::foo() too and not just StructName::foo
[00:11:36] <mark_edward> why don't smart pointers implement a function pointer?
[00:11:43] <jadbaires> Eridius: I didn't even know .iter() was a pointer
[00:11:44] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[00:11:49] <Eridius> jadbaires: .iter() on vectors yields &T
[00:11:50] <mark_edward> s/function pointer/Deref trait
[00:11:55] <jadbaires> Eridius: I see
[00:11:58] <Eridius> jadbaires: because yielding T requires cloning
[00:12:07] <kimundi> mark_edward: because we don't have one yet
[00:12:17] <jadbaires> Eridius: got it
[00:12:21] <kimundi> mark_edward: once we have, they will
[00:12:24] <mark_edward> kimundi, what's holding one up
[00:12:25] <Eridius> mark_edward: there is some plan to allow smart pointers to work like that but I don't know the details
[00:12:59] <Eridius> I believe the trick is actually taking SmartPointer<T> and turning it into &T
[00:13:04] <Eridius> rather than actually dereffing it
[00:16:13] *** Quits: AvianFlu (AvianFlu@974D245D.130DDD13.67CD788C.IP) (Input/output error)
[00:16:49] <mark_edward> ah i see
[00:17:07] <mark_edward> nothing a few calls to transmute can't fix /s
[00:21:14] <dbaupp> Eridius: Trait::foo(&int)
[00:21:29] *** Joins: an (Mibbit@moz-A082F561.adsl.xtra.co.nz)
[00:21:33] <Matthias247> mark_edward: transmuting Traits doesn't really work
[00:21:33] <dbaupp> Eridius: (since currently the only way to put methods on those types is traits.)
[00:21:36] *** Parts: an (Mibbit@moz-A082F561.adsl.xtra.co.nz) ()
[00:21:56] *** Joins: anonymous_29563 (Mibbit@moz-A082F561.adsl.xtra.co.nz)
[00:22:39] *** kimundi is now known as zz_kimundi
[00:22:55] <Eridius> dbaupp: (&Foo)::bar() then
[00:23:09] <Eridius> well no that requires traits too doesn't it
[00:23:12] <Eridius> pfft
[00:26:01] <jadbaires> why is it that the closure in .map(...)  is a reference to an element rather than the element itself? efficiency?
[00:26:15] *** Quits: synackse (jordyd@2D608993.77F880E0.D9401097.IP) (Quit: synackse)
[00:26:16] <eddyb> jadbaires: so that it works with everything
[00:26:23] *** Quits: fhahn (fhahn@moz-7924DB5C.vie.surfer.at) (Ping timeout)
[00:26:27] <eddyb> jadbaires: it's not about map, but iter/mut_iter on vectors
[00:26:41] *** Joins: alan_andrade (alan_andra@moz-90372B97.hsd1.ca.comcast.net)
[00:26:46] <eddyb> that is, .iter() returns a type that implements Iterator<&Element>
[00:26:48] *** Quits: tcreate (tcreate@moz-80F3706A.hsd1.ma.comcast.net) (Client exited)
[00:26:55] <Eridius> jadbaires: which .map() are you talking about?
[00:26:57] <jadbaires> eddyb: got it
[00:27:08] <Eridius> jadbaires: .map() on an iterator takes the element the iterator yields. .iter() on a vec yields &T
[00:27:23] <jadbaires> Eridius: oh
[00:27:23] <Eridius> .map() on a vec directly (which returns another vec) also takes &T, and it does this because it doesn't consume the receiver
[00:27:50] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Ping timeout)
[00:27:56] <jadbaires> I see I see
[00:29:24] *** Joins: synackse (jordyd@2D608993.77F880E0.D9401097.IP)
[00:31:37] <dbaupp> Eridius: that said, it is desired to be able to write `impl uint { .. }` etc. in libstd
[00:31:46] <Eridius> treue
[00:31:49] <Eridius> *true
[00:31:55] <dbaupp> Eridius: although, I think the major problem is with traits
[00:32:08] <dbaupp> so directly impl'd methods aren't too concerning
[00:33:27] *** Quits: tryzor (bzlandfill@moz-1116CEB1.dip0.t-ipconnect.de) (Quit: CGI:IRC (Ping timeout))
[00:33:42] *** Joins: fhahn (fhahn@moz-7924DB5C.vie.surfer.at)
[00:35:47] *** Quits: alan_andrade (alan_andra@moz-90372B97.hsd1.ca.comcast.net) (Input/output error)
[00:36:39] *** Quits: jdm (jdm@A7937365.8212E19F.1D05C454.IP) (Quit: Lost terminal)
[00:39:58] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[00:40:46] *** Joins: derek_c (derek@moz-CE6E60A5.cit.cornell.edu)
[00:41:42] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[00:44:35] *** Joins: dr_bibble (Mibbit@moz-CEF6EAF3.bethere.co.uk)
[00:48:44] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[00:51:16] *** Quits: Sorella (queen@9D963F5D.DF5D8AE7.54BCAB54.IP) (Quit: It is tiem!)
[00:52:06] *** Joins: nrc_ (nrc@6D0546D1.9A5DBD9A.84D1E168.IP)
[00:52:27] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[00:52:39] *** Quits: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP) (Ping timeout)
[00:52:54] *** nrc_ is now known as nrc
[00:55:45] *** Joins: tcreate (tcreate@moz-80F3706A.hsd1.ma.comcast.net)
[00:57:11] *** Quits: Matthias247 (Miranda@moz-BDD35EC0.hsi5.kabel-badenwuerttemberg.de) (Connection reset by peer)
[00:57:12] *** Joins: alan_andrade (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net)
[00:57:27] *** Quits: tcreate (tcreate@moz-80F3706A.hsd1.ma.comcast.net) (Ping timeout)
[00:57:54] *** Quits: nrc (nrc@6D0546D1.9A5DBD9A.84D1E168.IP) (Ping timeout)
[00:57:54] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[00:57:57] *** Quits: nham (Mibbit@moz-2C6185F8.lightspeed.dybhfl.sbcglobal.net) (Quit: http://www.mibbit.com ajax IRC Client)
[00:58:25] *** Joins: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP)
[00:59:09] *** Quits: dmillerw (dylan@moz-F9231FD9.eugn.qwest.net) (Quit: Leaving)
[01:00:29] *** Quits: alan_andrade (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net) (Ping timeout)
[01:02:50] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[01:04:14] *** Quits: prooftechnique (prooftechn@moz-1C9C6B71.hsd1.vt.comcast.net) (Quit: )
[01:04:53] *** Joins: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP)
[01:05:21] *** Quits: onelson (owen@18CF7301.95770028.5B6BFE7D.IP) (Input/output error)
[01:07:02] *** Quits: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP) (Ping timeout)
[01:07:14] *** Joins: cgaebel (clark@ADA4DDE2.290DF317.EE6E63A5.IP)
[01:07:26] <cgaebel> how do I specify a reference to a mutable string?
[01:08:05] <strcat> cgaebel: &mut ~str
[01:08:23] <cgaebel> strcat: thanks. that's weird.
[01:08:26] <strcat> why?
[01:08:42] <cgaebel> strcat: is it one layer of indirection or two?
[01:08:46] <strcat> two
[01:09:03] <strcat> if that's not making sense, you probably want [u8] and not a string
[01:09:04] <cgaebel> strcat: oh. there's no way to collapse it down to one?
[01:09:08] <strcat> cgaebel: no
[01:09:18] <strcat> cgaebel: strings are UTF-8
[01:09:31] *** Joins: Mouq (Mouq@moz-54126586.hsd1.pa.comcast.net)
[01:09:31] <strcat> cgaebel: mutating a character pretty much implies the possibility of needing to resize the string
[01:09:35] <cgaebel> strcat: but still. if I were doing this in C I would use char* buf and size_t len
[01:09:45] <strcat> cgaebel: so... you don't want a string
[01:09:50] <strcat> cgaebel: use &mut [u8]
[01:09:54] <cgaebel> sure I do.
[01:09:59] *** Quits: derek_c (derek@moz-CE6E60A5.cit.cornell.edu) (Ping timeout)
[01:09:59] <strcat> cgaebel: so it's unicode?
[01:10:07] <cgaebel> but yeah I see it now. The resizing requires two levels.
[01:10:11] <cgaebel> thanks.
[01:10:29] <cgaebel> strcat: yeah it's unicode.
[01:10:32] * o11c repeats "it's better to be unicode oblivious"
[01:10:37] <strcat> we could have &mut str, but there wouldn't be much you could do with it
[01:10:59] <strcat> o11c: yeah, better to treat strings as black boxes if you can
[01:11:01] <strcat> can't always do that
[01:11:02] <cgaebel> strcat: yeah. I realize now that you need two levels of indirection to support resizing. I didn't see that before.
[01:11:05] *** Joins: onelson (owen@18CF7301.95770028.5B6BFE7D.IP)
[01:12:00] *** Joins: alan_andrade (alan_andra@moz-36A7C66.hfc.comcastbusiness.net)
[01:13:41] <eevee> there's &mut [char] too
[01:13:59] <eevee> for pretending you can meaningfully edit a sequence of codepoints either
[01:14:47] *** Joins: zggh (zggh@moz-C34BE8E5.hsd1.ca.comcast.net)
[01:15:41] <cgaebel> eevee: lol
[01:16:39] <skrylar> unicode is hell :(
[01:17:19] <Mouq> rusti: let föo = 42
[01:17:19] -rusti- <anon>:11:5: 11:6 error: expected `;` but found `}`
[01:17:20] -rusti- <anon>:11     };
[01:17:20] -rusti-               ^
[01:17:20] -rusti- application terminated with error code 101
[01:18:02] <cgaebel> rusti: let föo = 42;
[01:18:05] -rusti- pastebinned 8 lines of output: http://ix.io/agp
[01:19:09] <Mouq> cgaebel: Ahh, ok, thank you. I was curious about UTF8 in Rust programs
[01:19:37] <cgaebel> lol np. I like the error message.
[01:21:32] <dbaupp> Mouq: it's semi-supported, but as you can see from the ^~ line (it should be ^~~), the compiler unfortunately doesn't emit error messages properly with multi-byte characters (and a few other minor problems)
[01:22:36] *** Quits: gwty (gwtypc@BEB2E7A8.D37BBF03.CF29F6CE.IP) (Ping timeout)
[01:26:39] <Mouq> dbaupp: I see, thanks :)
[01:27:52] *** Joins: derek_c (derek@moz-A44964B8.cit.cornell.edu)
[01:28:05] <o11c> odd, what kind of error could make the ~ sequence *shorter* ?
[01:28:13] <dbaupp> yeah, it's very weird
[01:28:28] <o11c> rusti: let fföoo = 42;
[01:28:30] -rusti- pastebinned 8 lines of output: http://ix.io/agq
[01:28:55] <cmr> does it just not count multi-byte chars?
[01:28:59] <dbaupp> rusti: let a虎b = 42;
[01:29:01] -rusti- pastebinned 8 lines of output: http://ix.io/agr
[01:29:03] <o11c> I was just thinking that
[01:29:19] <o11c> rusti: let fööööööo = 42;
[01:29:22] -rusti- pastebinned 8 lines of output: http://ix.io/ags
[01:29:30] <dbaupp> cmr wins!
[01:30:34] <dbaupp> why on earth would it only be counting ascii characters?
[01:30:36] *** Joins: simlay (simlay@moz-490DE04A.amandrai.net)
[01:30:37] <dbaupp> how weird
[01:30:57] *** Quits: aklt (aklt@moz-E66E9BCB.u.parknet.dk) (Quit: leaving)
[01:31:19] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Connection reset by peer)
[01:31:32] <Eridius> rusti: let föoöoöoöoöo = 42;
[01:31:34] -rusti- pastebinned 8 lines of output: http://ix.io/agt
[01:31:38] <Eridius> haha nice
[01:31:57] <yuriks> is anyone aware of an option parsing library other than the one in extra?
[01:33:22] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[01:33:50] <dbaupp> yuriks: there may be one listed on http://www.rust-ci.org/
[01:35:55] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[01:38:14] *** Quits: dr_bibble (Mibbit@moz-CEF6EAF3.bethere.co.uk) (Quit: http://www.mibbit.com ajax IRC Client)
[01:38:31] *** Quits: Ferreus (ferreus@moz-3C083E18.pools.arcor-ip.net) (Quit: WeeChat 0.4.3-dev)
[01:39:16] *** Joins: dmac (dmac@moz-94F55C3.hfc.comcastbusiness.net)
[01:40:02] *** Quits: kvanb (kvanb@754FCA9B.CCE6F951.1611EE05.IP) (Ping timeout)
[01:40:29] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[01:40:46] *** Quits: arturo (Thunderbir@moz-E83B14F0.superkabel.de) (Ping timeout)
[01:41:11] *** Joins: kvanb (kvanb@moz-C6EC06B9.lnse3.lon.bigpond.net.au)
[01:42:16] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[01:43:27] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Ping timeout)
[01:43:40] <yuriks> dbaupp: I found Knob, which is for configuration. But then I found out that extra::getopts already does what I wanted it to :P
[01:44:56] <dbaupp> yuriks: cool
[01:45:07] <dbaupp> (btw, the extra::getopts::groups submodule is better than the parent)
[01:45:18] *** Quits: synackse (jordyd@2D608993.77F880E0.D9401097.IP) (Ping timeout)
[01:45:23] <yuriks> dbaupp: exactly :)
[01:45:30] <cmr> why do we even have non-groups anymore.
[01:45:39] <cmr> when getopts is removed from extra we should fix that
[01:45:47] <dbaupp> because no-one's done any work on it
[01:45:52] <cmr> is anyone currently dissolving getopts? I might do that tonight
[01:47:18] <yuriks> I was about to rewrite something similar to python's argparse
[01:51:15] *** Joins: wittytwit (Mibbit@moz-3DA5D4DF.dhcp.embarqhsd.net)
[01:52:09] *** Joins: synackse (jordyd@2D608993.77F880E0.D9401097.IP)
[01:52:15] <wittytwit> So is there anyway to get the file descriptor for an open file in Rust? I was hoping to be able to get one to use with ProcessOptions, and haven't been having any luck
[01:53:20] <cmr> wittytwit: using libnative, open() returns a FileDesc, which has an .fd() method.
[01:53:45] <wittytwit> libnative = libc?
[01:53:48] <cmr> no
[01:53:51] <cmr> libnative
[01:54:01] *** Joins: dmillerw (dylan@moz-F9231FD9.eugn.qwest.net)
[01:54:01] <cmr> http://static.rust-lang.org/doc/master/guide-runtime.html
[01:54:46] <wittytwit> I see. Thanks! Hopefully I'll find it there. I'm not sure how I avoided that for the past few hours
[01:56:19] *** Joins: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz)
[01:56:43] <dbaupp> http://static.rust-lang.org/doc/master/native/io/file/fn.open.html fwiw
[01:56:52] *** Quits: Jesin (Jesin@moz-3A2C5D36.washdc.fios.verizon.net) (Quit: Leaving)
[01:58:47] *** Quits: reima (Instantbir@moz-6615EE69.dip0.t-ipconnect.de) (Quit: Leaving.)
[01:59:16] *** Joins: jvoorhis (jvoorhis@moz-84A91726.ptld.qwest.net)
[02:00:40] *** Joins: alan_and_ (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net)
[02:03:11] *** Quits: alan_and_ (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net) (Ping timeout)
[02:03:25] *** Joins: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp)
[02:04:10] *** Quits: johnsoft (johnsoft@moz-7E09A266.neo.res.rr.com) (Ping timeout)
[02:04:24] *** Joins: johnsoft (johnsoft@moz-7E09A266.neo.res.rr.com)
[02:05:05] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[02:05:20] *** Quits: squiddy (squiddy@moz-19BAE379.adsl.alicedsl.de) (Quit: Leaving)
[02:05:38] *** Joins: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP)
[02:07:41] *** Quits: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP) (Ping timeout)
[02:08:26] *** Joins: bt3ze (bt3ze@moz-3F0303DA.hsd1.va.comcast.net)
[02:09:16] *** Joins: victorporof (victorporo@53EBB099.7C27E871.79933D60.IP)
[02:09:31] <cgaebel> does all rust code build single-threadedly? I've got many more cores just lying around doing nothing while I try to build a stage2.
[02:10:17] *** Quits: bt3ze (bt3ze@moz-3F0303DA.hsd1.va.comcast.net) (Ping timeout)
[02:10:22] <cmr> cgaebel: yes.
[02:10:33] <yuriks> hm, what's the raw printing function? With no formatting
[02:10:39] *** Quits: victorporof_ (victorporo@53EBB099.7C27E871.79933D60.IP) (Ping timeout)
[02:10:43] <cmr> yuriks: std::io::println exists.
[02:10:47] <yuriks> quick search in std didn't find it
[02:10:54] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Quit: TheHydroImpulse)
[02:10:55] <cgaebel> cmr: any timeline on multithreaded builds? or is it going to be post-1.0?
[02:11:15] <yuriks> wha- I had searched for 'print' on the std docs and it hadn't found anything O_o
[02:11:17] <cmr> cgaebel: whenever LLVM gets parallelization we'll benefit from that.
[02:11:32] <cgaebel> cmr: can't each module be built in parallel?
[02:11:35] <cmr> cgaebel: there's no current plans for parallelizing our side of it.
[02:11:36] <cmr> no.
[02:11:39] <cgaebel> cmr: ala C
[02:11:41] <cmr> not naively, at least.
[02:11:44] <cgaebel> why not?
[02:11:46] <cmr> certainly not like C
[02:11:52] <cmr> interdependencies.
[02:12:11] <cmr> they can be translated independantly, but that's llvm's bug, not ours.
[02:12:11] *** Quits: doomlord_ (servitor@moz-841308DB.range86-160.btcentralplus.com) (Ping timeout)
[02:12:24] <cgaebel> oh ok.
[02:12:26] <dbaupp> yuriks: our doc search fails weirdly sometimes
[02:12:26] <cmr> if you tick passes on any build (http://huonw.github.io/isrustfastyet/mem/) you can see llvm is the slow part.
[02:12:47] <cmr> yuriks: it shows up for me?
[02:12:48] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[02:12:57] <cgaebel> oh wow.
[02:13:00] <yuriks> cmr: yeah, it showed up now too
[02:13:08] *** Joins: victorporof_ (victorporo@53EBB099.7C27E871.79933D60.IP)
[02:13:12] <yuriks> I did it on a different tab, though
[02:13:13] <sp3d> how does irfy decide when it updates?
[02:13:24] <cmr> sp3d: the bencher is currently down because I ran out of disk space.
[02:13:28] <dbaupp> sp3d: it runs every 15 minutes
[02:13:39] <sp3d> cmr: oic!
[02:13:41] <dbaupp> but the /mem page depends on cmr collecting data
[02:13:52] *** Joins: doomlord_ (servitor@moz-858B6E73.range86-148.btcentralplus.com)
[02:14:08] <sp3d> someone buy cmr a bigger disk in the interest of rusct memory usage feedback!
[02:14:15] <sp3d> rustc*
[02:14:44] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[02:14:44] *** Quits: victorporof (victorporo@53EBB099.7C27E871.79933D60.IP) (Ping timeout)
[02:15:14] *** Quits: Mouq (Mouq@moz-54126586.hsd1.pa.comcast.net) (Quit: Lost terminal)
[02:15:39] <cmr> if I removed some of my games I could have space...
[02:16:04] <sp3d> you could ring-buffer old data out
[02:16:19] <sp3d> though it would be nice to keep it around for historical purposes
[02:16:38] <cmr> I don't want to remove because I actually do use the old ones sometimes...
[02:16:39] *** Joins: aruniiird (aruniiird@28876D92.F24A7F1B.260B031E.IP)
[02:16:42] <sp3d> yeah
[02:16:57] * cmr goes to check how cheap amazon glacier is
[02:17:01] <strcat> cmr: compress everything? ;p
[02:17:08] <strcat> how big is it anyway?
[02:17:30] <cmr> well I currently have 382G of rust builds.
[02:17:35] <strcat> ;s
[02:17:48] *** Joins: hoverbear (hoverbear@moz-86FCBF4B.gv.shawcable.net)
[02:17:55] <strcat> cmr: can you just delete stage1, etc. ?
[02:18:00] <cmr> going back to 0.6
[02:18:03] <cmr> strcat: I only keep stage2
[02:18:03] <dbaupp> cmr: contact mozilla
[02:18:15] <strcat> cmr: symlink the compiler libs to the target libs
[02:18:20] <strcat> cmr: that's what my arch packages do
[02:18:29] <dbaupp> cmr: i imagine they may be willing to send you a HDD and host them themselves
[02:18:31] <dbaupp> for bisection
[02:18:34] <strcat> cmr: same ABI
[02:18:35] <dbaupp> maybe
[02:19:44] <cmr> strcat: compiler libs are stage2/lib and target libs are in stage/lib/rustc yeah?
[02:19:55] <cmr> that should save significant amounts of space
[02:20:22] <mark_edward> cmr, you do do great stuff for Rust, a $70 2TB HDD would be a great gift to keep IRFY running!
[02:20:46] <strcat> cmr: yes look at what rust-git does
[02:21:03] <strcat> cmr: also it changed from rustc -> rustlib at some point...
[02:21:09] <cmr> yeah
[02:21:39] *** Quits: johnsoft (johnsoft@moz-7E09A266.neo.res.rr.com) (Ping timeout)
[02:21:53] *** Joins: johnsoft (johnsoft@moz-7E09A266.neo.res.rr.com)
[02:24:29] <bvssvni> is it possible to run a terminal command from Rust and get the result?
[02:25:29] *** Quits: onelson (owen@18CF7301.95770028.5B6BFE7D.IP) (Input/output error)
[02:26:00] <dbaupp> bvssvni: std::run
[02:26:16] <bvssvni> dbaupp: thanks
[02:27:47] *** Joins: onelson (owen@18CF7301.95770028.5B6BFE7D.IP)
[02:31:14] *** Joins: victorporof (victorporo@53EBB099.7C27E871.79933D60.IP)
[02:32:46] *** Quits: victorporof_ (victorporo@53EBB099.7C27E871.79933D60.IP) (Ping timeout)
[02:33:44] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Client exited)
[02:34:12] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[02:34:16] *** Quits: Zylinski (karl@moz-58495553.static.spa.siw.siwnet.net) (Quit: )
[02:34:56] *** Joins: victorporof_ (victorporo@53EBB099.7C27E871.79933D60.IP)
[02:35:19] *** Quits: achim (achim@moz-4165261.dip0.t-ipconnect.de) (Ping timeout)
[02:35:57] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Ping timeout)
[02:36:11] *** Quits: victorporof (victorporo@53EBB099.7C27E871.79933D60.IP) (Ping timeout)
[02:38:43] *** Joins: achim (achim@moz-30EA2B29.dip0.t-ipconnect.de)
[02:41:01] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[02:42:41] *** Joins: rofrol_ (rfrolow@moz-535883E.threembb.ie)
[02:42:52] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[02:45:09] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[02:45:09] *** ChanServ sets mode: +ao brson brson
[02:45:25] *** Quits: rofrol_ (rfrolow@moz-535883E.threembb.ie) (Ping timeout)
[02:46:15] *** Quits: synackse (jordyd@2D608993.77F880E0.D9401097.IP) (Quit: synackse)
[02:46:45] *** Joins: rofrol_ (rfrolow@moz-535883E.threembb.ie)
[02:47:04] *** Quits: alan_andrade (alan_andra@moz-36A7C66.hfc.comcastbusiness.net) (Input/output error)
[02:47:05] *** Joins: Jesin (Jesin@moz-3A2C5D36.washdc.fios.verizon.net)
[02:47:59] *** Quits: Armavica (virgile@moz-AD428ED7.ens.fr) (Ping timeout)
[02:48:45] *** Joins: synackse (jordyd@2D608993.77F880E0.D9401097.IP)
[02:50:10] *** Quits: ricepuddin (graham@moz-7D68765A.cable.virginm.net) (Ping timeout)
[02:50:18] *** Quits: johnsoft (johnsoft@moz-7E09A266.neo.res.rr.com) (Ping timeout)
[02:50:20] <dbaupp> is it a common thing for ARM asm to use regA = regB + 0 instead of a normal regA = regB mov?
[02:50:22] *** Joins: SingingBoyo (SingingBoy@DA28FB90.A5D0D593.4F048BDC.IP)
[02:50:30] *** Joins: johnsoft (johnsoft@moz-7E09A266.neo.res.rr.com)
[02:50:47] <skrylar> hrm
[02:50:52] <eddyb> dbaupp: not really
[02:51:05] <eddyb> it's not like MIPS where you don't have mov (AFAIK)
[02:51:08] <dbaupp> weird
[02:51:19] <skrylar> I haven't worked with ARM, so I don't know if add is faster than mov. I know there are a few derps with CPUs, like xor a,a being faster than a := 0 on intel
[02:51:32] *** Quits: rofrol_ (rfrolow@moz-535883E.threembb.ie) (Quit: WeeChat 0.4.2)
[02:51:42] <eddyb> isn't xor a, a shorter?
[02:52:04] <eddyb> and it doesn't involve extracting the constant operand
[02:52:07] <skrylar> IIRC it takes less clock time to run xor because mov actually has to go through a different path
[02:52:31] <eddyb> it's like int3 vs int 3
[02:52:38] <eddyb> (among other things)
[02:52:57] <skrylar> there was also another opcode which was for getting pointer addresses that people sometimes abused as a multiply-and-add 
[02:53:07] <skrylar> that's the extent of my minmaxing knowledge for CPU opcodes though :<
[02:53:25] <dbaupp> lea <3
[02:54:00] <eddyb> skrylar: but it only does powers of two
[02:54:16] <cmr> skrylar: it has to do with data dependencies.
[02:54:17] <eddyb> and a few of them at that - I guess it's useful because it's shorter and specialized
[02:54:28] <cmr> more than anything..
[02:54:33] <eddyb> cmr: on the code memory?
[02:54:39] <cmr> it's also a special case, as documented in the intel manual.
[02:54:41] <cmr> eddyb: on the opcode.
[02:54:45] <cmr> xor eax, eax
[02:54:48] <cmr> can only use eax
[02:54:58] <eddyb> oh, mov is not specialized?
[02:55:07] *** Quits: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp) (Client exited)
[02:55:14] <cmr> it may be.
[02:55:16] <cmr> check the manual.
[02:55:27] *** Joins: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp)
[02:55:34] <eddyb> my 2008 hard copies are getting old
[02:55:43] <cmr> did you *print* the hard copies?
[02:55:47] <eddyb> and I should be in bed
[02:55:58] <skrylar> I know that when I gist this GUI model later, you're all going to cringe xD
[02:56:01] <eddyb> cmr: Intel stopped giving them away for free?
[02:56:04] <dbaupp> eddyb: use your (laptop?) in bed
[02:56:09] <cmr> eddyb: do they give them away for free now?
[02:56:10] <dbaupp> solves the problem \o/
[02:56:12] * skrylar eyes at all the Option<Rc<RefCell<Sadness>>>
[02:56:15] * cmr checks.
[02:56:21] <eddyb> dbaupp: that doesn't solve the sleeping problem
[02:56:45] <eddyb> skrylar: reminds me I have to implement NonZero for Rc to be considered a non-nullable pointer
[02:56:57] <eddyb> cmr: I didn't actually need them until I started fiddling with wiREd
[02:57:02] <dbaupp> skrylar: write it as Option<Rc<RefCell<Happy>>> and it'll be fine
[02:57:12] *** Quits: derek_c (derek@moz-A44964B8.cit.cornell.edu) (Ping timeout)
[02:57:12] *** Quits: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp) (Ping timeout)
[02:57:15] <cmr> strcat: yay you saved me almost half of a disk space?
[02:57:18] <cmr> s/?/!
[02:57:28] <dbaupp> eddyb: strcat implemented the NonZero thing a while ago, but it got rejected because the approach wasn't perfect, aiui
[02:57:48] <strcat> it was rejected because I didn't implement error reporting as I didn't know where to put it
[02:57:53] <dbaupp> cmr: yay another 2000 benches
[02:57:58] <strcat> they wanted errors on non-word-size things
[02:58:06] <strcat> but only trans knows about the size
[02:58:09] <dbaupp> 'they' was possibly me... :S
[02:58:10] <eddyb> strcat: oh, heh
[02:58:14] * dbaupp apologises
[02:58:14] <strcat> and I couldn't think of a good place to put the check
[02:58:17] *** Joins: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp)
[02:58:44] <eddyb> strcat: repeating the transmute error situation would've been too bad?
[02:59:07] <eddyb> cmr: (when I realized I can implement most opcodes by copying the text from the opcode tables)
[02:59:48] <strcat> well it could just work like the transmute error...
[03:00:18] <eddyb> then it's easy, put it in type_of
[03:00:37] <eddyb> that handles all type instantiation ever
[03:01:26] <eddyb> if it's ty_struct and it matches the lang item DefId, make sure the result is word-sized
[03:01:36] <eddyb> 5 lines of extra code?
[03:01:47] <eddyb> strcat: the problem surely has to be more complicated than this
[03:02:59] <dbaupp> eddyb: lang item?
[03:03:07] *** Joins: alan_andrade (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net)
[03:03:08] <dbaupp> oh, struct NonZero<T> { x: *T }?
[03:03:30] <eddyb> dbaupp: doesn't even have to be a pointer (it would be named NonNullable in that case)
[03:03:34] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[03:03:43] *** Quits: cgaebel (clark@ADA4DDE2.290DF317.EE6E63A5.IP) (Ping timeout)
[03:05:06] *** Quits: Jesin (Jesin@moz-3A2C5D36.washdc.fios.verizon.net) (Ping timeout)
[03:05:07] <eddyb> dbaupp: just need to prevent unchecked instantiation, maybe with a "new" method requiring Eq and Zero and returning Option<NonZero<T>>
[03:05:42] *** Quits: alan_andrade (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net) (Ping timeout)
[03:06:20] <eddyb> (which would be... noop, considering the guarantees NonZero provides)
[03:06:23] *** Joins: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP)
[03:06:34] *** Quits: kellogh (timkellogg@moz-704A74D.hsd1.co.comcast.net) (Quit: kellogh)
[03:06:52] <dbaupp> unchecked instantiation would be ok... if it where `unsafe`
[03:06:57] <dbaupp> *were
[03:07:40] <eddyb> dbaupp: I guess an Allocator could return NonZero<*T>
[03:08:08] <eddyb> our exchange_malloc implementation already checks the return value for NULL
[03:08:32] *** Quits: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP) (Ping timeout)
[03:09:05] *** Quits: dmillerw (dylan@moz-F9231FD9.eugn.qwest.net) (Ping timeout)
[03:09:11] <eddyb> so something like Rc wouldn't even have to bother with constructing a NonZero (apart from the Drop code which has to zero it to prevent double free. oooh that's a funny thought)
[03:09:42] *** Joins: dmillerw (dylan@moz-F9231FD9.eugn.qwest.net)
[03:09:42] <cmr> dbaupp: sp3d: bencher back up.
[03:09:45] *** nrc is now known as nrc|afk
[03:09:49] <cmr> it'll take a while for the builder to catch up with master.
[03:09:51] <dbaupp> cmr: \o/
[03:10:05] <eddyb> cmr: I think last thing you wanted to try was RUST_THREADS=1
[03:10:08] <dbaupp> eddyb: that's a cool idea :)
[03:10:22] <dbaupp> eddyb: (malloc's returning NonZero)
[03:10:59] <eddyb> well, "alloc"
[03:11:17] <eddyb> strcat: if Rc were using NonZero<*T> and we would be emitting some kind of guarantees that it's never null to LLVM, that could eliminate the null checks guarding reentering drop
[03:11:20] <cmr> eddyb: rustc is single threaded?
[03:11:32] <eddyb> cmr: it has at least two tasks
[03:11:39] <strcat> eddyb: there's no way to communicate non-null to LLVM without writing a pass
[03:11:40] <cmr> one of which blocks on the other...
[03:11:58] *** Joins: hjr3 (hradtke@moz-842BF853.hsd1.ca.comcast.net)
[03:12:05] <eddyb> cmr: we're running out of non-deterministic things to check for
[03:12:13] *** Joins: alan_andrade (alan_andra@9BAE160D.B329E60.1B55CB72.IP)
[03:12:22] <eddyb> strcat: free calls wouldn't fail with null... but we'd be running dtors twice
[03:12:55] <strcat> eddyb: I don't understand what you mean
[03:13:16] <strcat> ~T already acts like the attribute I was going to add for Rc
[03:13:18] <strcat> it obviously works
[03:13:29] <strcat> Option<~T> is already 1 word
[03:13:30] <eddyb> strcat: the logic is: if I'm not null {run dtor; free}
[03:13:35] <strcat> Option<Rc<T>> should be one word too
[03:13:44] <strcat> eddyb: are you talking about something else?
[03:14:08] *** Joins: ercxx (ercan@moz-88DD3A7E.dyn.optonline.net)
[03:14:09] <eddyb> strcat: if we teach LLVM about nonull, it might remove the if and always run the dtor and free
[03:15:19] <eddyb> so we should maybe possibly really try to avoid zeroing things and rely on the information from the analysis passes
[03:16:32] *** Joins: alan_andrade_ (alan_andra@9BAE160D.B329E60.1B55CB72.IP)
[03:16:36] *** Quits: alan_andrade (alan_andra@9BAE160D.B329E60.1B55CB72.IP) (Ping timeout)
[03:17:15] *** Joins: a_m0d (a_m0d@moz-2F294D00.acanac.net)
[03:17:15] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[03:17:36] *** Quits: eddyb (eddy@832D2DE5.66315F97.FB866788.IP) (Ping timeout)
[03:17:56] *** Quits: JesseH (Jesse@moz-BD21A528.mc.at.cox.net) (Ping timeout)
[03:18:38] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Connection reset by peer)
[03:18:49] *** Joins: kellogh (timkellogg@moz-704A74D.hsd1.co.comcast.net)
[03:20:38] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[03:20:43] *** Joins: mib_10en8d (Mibbit@moz-239EF635.pete-bam-1.adsl.virginm.net)
[03:21:00] <mib_10en8d> what's release date for rust 1?
[03:21:09] *** Quits: LinearInterpol (RJones@moz-E6F82C3A.maine.res.rr.com) (Ping timeout)
[03:21:16] <strcat> mib_10en8d: there isn't a set release date
[03:21:32] <cmr> 0.10 comes after 0.9, not 1.0
[03:21:33] <mib_10en8d> 1 month? 3 months? 6months? 1 yr?
[03:22:13] <mib_10en8d> I take it it's not yet mature fo rproduction.
[03:22:53] <strcat> you can definitely use rust in production today if you understand what you're doing
[03:23:08] <mib_10en8d> would the syntax change?
[03:23:26] <mib_10en8d> do I have to keep rewriting what I write?
[03:23:27] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Quit: TheHydroImpulse)
[03:23:35] <dbaupp> s/rewrite/update/
[03:23:45] <dbaupp> it won't change dramatically, maybe little bits and pieces
[03:23:45] <strcat> mib_10en8d: you would have to update it as stuff in the stdlib is renamed, etc.
[03:23:59] <strcat> if you don't want to deal with that then rust isn't what you want
[03:24:09] *** Quits: aruniiird (aruniiird@28876D92.F24A7F1B.260B031E.IP) (Ping timeout)
[03:24:10] <mib_10en8d> but no update at language level, just libs?
[03:24:26] <dbaupp> there are some changes to the language
[03:24:29] <strcat> the language will still gain new features and may change
[03:24:38] <strcat> there's no stability promise
[03:24:48] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[03:24:49] <strcat> 22:25:07      strcat | if you don't want to deal with that then rust isn't what you want
[03:25:01] <dbaupp> but they're not huge, and, in theory, the compiler is now warning about most of the old syntax that is due for removal/change
[03:25:01] *** Quits: zz_kimundi (kimundi@moz-CC8364D0.dip0.t-ipconnect.de) (Ping timeout)
[03:25:11] <strcat> definitely not a lot of work to cope with the changes at this point, but it is a bit of work
[03:25:17] <dbaupp> (so you can pre-emptively avoid using it)
[03:26:26] <mib_10en8d> according to http://redd.it/1w7bqs :  I have been trying to write a (slow-action, text based) game server, and the lack of non-blocking networking is painful right now.
[03:26:33] *** Joins: leeks (Mibbit@6193090B.AB4B4D69.284344F5.IP)
[03:26:34] *** Joins: csherratt (csherratt@moz-7685819.cpe.teksavvy.com)
[03:26:41] *** Quits: new_one (new_one@338D8DF9.4C461BEC.59A381B9.IP) (Ping timeout)
[03:27:30] *** Quits: halorgium (z@moz-27C0632C.spork.in) (Quit: gone)
[03:27:31] <mib_10en8d> unfortunately non blocking io would be a blocking obstacle for my production app :(
[03:27:43] <mib_10en8d> lack of*
[03:27:49] <dbaupp> yes, there are still parts that aren't complete, and in that case, Rust isn't an option
[03:27:59] <strcat> you can use non-blocking I/O in rust the same way as you can from C
[03:28:14] *** Quits: alan_andrade_ (alan_andra@9BAE160D.B329E60.1B55CB72.IP) (Connection reset by peer)
[03:28:16] <strcat> if you expect a high-level interface to be there for most things, then rust isn't what you're looking for
[03:28:22] *** Joins: alan_andrade (alan_andra@9BAE160D.B329E60.1B55CB72.IP)
[03:28:27] <strcat> it's not at that point
[03:28:39] *** Joins: zz_kimundi (kimundi@moz-19888B08.dip0.t-ipconnect.de)
[03:28:50] <strcat> give it a few years for the library ecosystem to mature, otherwise you can expect to be using C libraries from rust
[03:28:56] *** zz_kimundi is now known as kimundi
[03:29:58] <mib_10en8d> does rust dynamically load a c library and call its functions without the need for a wrapper?
[03:30:07] *** Quits: alan_andrade (alan_andra@9BAE160D.B329E60.1B55CB72.IP) (Ping timeout)
[03:30:16] *** Joins: cgaebel (clark@moz-92F543E4.nycmny.east.verizon.net)
[03:30:36] <strcat> mib_10en8d: you can call C directly from rust
[03:30:39] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[03:30:46] <mib_10en8d> sweet.
[03:30:47] <strcat> you will end up needing to write a high-level wrapper in rust yourself
[03:30:52] <strcat> to make it safe
[03:31:10] *** Joins: alan_andrade (alan_andra@9BAE160D.B329E60.1B55CB72.IP)
[03:32:37] <pyon> Just like it is a bad idea to throw from C++ destructors, it is an equally bad idea to fail!/assert!/whatever from drop, right?
[03:32:54] <dbaupp> pyon: yeah
[03:33:10] <dbaupp> if you fail!() in drop while the task is already failing the process aborts
[03:33:13] *** Quits: leeks (Mibbit@6193090B.AB4B4D69.284344F5.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[03:33:50] <yuriks> what is the correct way to invoke rustpkg from a makefile?
[03:34:02] *** Quits: mib_10en8d (Mibbit@moz-239EF635.pete-bam-1.adsl.virginm.net) (Quit: http://www.mibbit.com ajax IRC Client)
[03:34:21] <pyon> Sometimes I wish there were only two kinds of failure: whole-program-aborting failures and Option/Result. That would completely do away with the poisoning control overhead in MutexArc and RWArc.
[03:34:27] <yuriks> I have a workspace with a collection of tools and want to rebuild them as needed, can't figure out any way to not have to rebuild them all every time
[03:34:48] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Client exited)
[03:34:53] <pyon> It is supposedly a single bool, but in actuality it takes a whole byte + alignment.
[03:35:09] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[03:36:56] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Ping timeout)
[03:37:12] *** Quits: alan_andrade (alan_andra@9BAE160D.B329E60.1B55CB72.IP) (Ping timeout)
[03:38:49] <strcat> pyon: in rust-core there's only abort (logic errors, out-of-memory, out-of-stack) and Option/Result
[03:38:56] <strcat> well, at least that's my plan
[03:39:04] <strcat> I haven't written much in it that requires error handling yet.
[03:39:13] <strcat> just various stubs
[03:39:30] *** Joins: aruniiird (aruniiird@28876D92.F24A7F1B.260B031E.IP)
[03:40:27] <pyon> Oh, nice!
[03:40:29] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Quit: TheHydroImpulse)
[03:41:07] <strcat>  I don't like unwinding
[03:41:34] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[03:42:20] <strcat> it's often a really easy way to deal with implementing a clean shutdown... but it adds a lot of flow control complexity, binary bloat (unwind tables) and prevents some optimizations
[03:43:14] <strcat> imo, it's a lot harder to reason about than C code riddled with gotos for error handling due to lack of RAII
[03:43:18] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[03:43:24] <strcat> which is already annoying to reason about.
[03:43:32] <pyon> Yeah, I agree with that.
[03:44:42] <pyon> It is just that I want assertion failures and the like to fprintf to stderr, drop everything and then exit(EXIT_FAILURE). Then, if a drop itself fails, the only additional effect is that it keeps printing more stuff to stderr.
[03:45:10] <cgaebel> how would I write an unsafe option type with only .put() .set() .take()  .get_ref() .get_mut_ref(), but where I maintain the "is_some" bit on my own. I don't want the overhead of an enum type.
[03:45:24] <strcat> pyon: dropping everything requires unwinding though :P
[03:45:44] <pyon> Mmm... Then drop the dropping, just exit(EXIT_FAILURE).
[03:45:46] <cgaebel> if I have an UnsafeOption<int>, its size should be 8 bytes
[03:46:16] <pyon> cgaebel: Just for int?
[03:46:24] <pyon> (Or anything the same size of a pointer)
[03:46:46] <cgaebel> no I need it to be generic
[03:46:47] <strcat> cgaebel: just use int?
[03:46:59] *** Quits: dmac (dmac@moz-94F55C3.hfc.comcastbusiness.net) (Quit: Leaving)
[03:47:02] *** Quits: japaric (japaric@BA37D376.D2FA42B.95AFB88D.IP) (Ping timeout)
[03:47:16] <cgaebel> strcat: I actually need it to be UnsafeOption<T>
[03:47:17] <strcat> rusti: use std::unstable::intrinsics::uninit; unsafe { let x: int = uninit(); }
[03:47:18] <cgaebel> for all T.
[03:47:20] -rusti- pastebinned 10 lines of output: http://ix.io/agx
[03:47:33] <strcat> cgaebel: struct Identity<T>(T);
[03:47:39] <strcat> I guess I'm not really understanding what you want
[03:47:45] <strcat> uninit is generic
[03:47:56] <cgaebel> I'm building a hashtable.
[03:48:00] <strcat> rusti: use std::unstable::intrinsics::uninit; unsafe { let mut x = uninit(); x = 5; x }
[03:48:05] <cgaebel> keys are currently stored in an ~[Option<K>]
[03:48:06] -rusti- <anon>:10:61: 10:66 warning: value assigned to `x` is never read, #[warn(dead_assignment)] on by default
[03:48:06] -rusti- <anon>:10         use std::unstable::intrinsics::uninit; unsafe { let mut x = uninit(); x = 5; x }
[03:48:06] -rusti-                                                                       ^~~~~
[03:48:06] -rusti- timeout triggered!
[03:48:09] <strcat> rusti: use std::unstable::intrinsics::uninit; unsafe { let mut x = uninit(); x = 5; x }
[03:48:10] -rusti- <anon>:10:61: 10:66 warning: value assigned to `x` is never read, #[warn(dead_assignment)] on by default
[03:48:10] -rusti- <anon>:10         use std::unstable::intrinsics::uninit; unsafe { let mut x = uninit(); x = 5; x }
[03:48:11] -rusti-                                                                       ^~~~~
[03:48:13] -rusti- 5
[03:48:16] <cgaebel> I want to change it to a ~[K]
[03:48:20] <cgaebel> with some values "undefined"
[03:48:24] <strcat> cgaebel: so use uninit
[03:48:29] *** Quits: hjr3 (hradtke@moz-842BF853.hsd1.ca.comcast.net) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[03:48:29] <cgaebel> strcat: alright.
[03:48:34] <cgaebel> just making sure my usecase matches.
[03:48:39] <strcat> cgaebel: well, or just don't initialize the whole vector
[03:48:56] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[03:49:17] <cgaebel> ok. thanks.
[03:49:26] <strcat> rusti: use std::vec_ng::Vec; let mut xs = Vec::with_capacity::<int>(10); unsafe { xs.set_len(10); }
[03:49:27] -rusti- <anon>:10:44: 10:69 error: the impl referenced by this path has 1 type parameter, but 0 type parameters were supplied
[03:49:27] -rusti- <anon>:10         use std::vec_ng::Vec; let mut xs = Vec::with_capacity::<int>(10); unsafe { xs.set_len(10); }
[03:49:27] -rusti-                                                      ^~~~~~~~~~~~~~~~~~~~~~~~~
[03:49:27] -rusti- error: aborting due to previous error
[03:49:27] -rusti- application terminated with error code 101
[03:49:38] <strcat> rusti: use std::vec_ng::Vec; let mut xs = Vec::<int>::with_capacity(10); unsafe { xs.set_len(10); }
[03:49:42] -rusti- pastebinned 7 lines of output: http://ix.io/a6T
[03:49:47] <strcat> rusti: use std::vec_ng::Vec; let mut xs = Vec::<int>::with_capacity(10); unsafe { xs.set_len(10); } xs.len()
[03:49:48] -rusti- 10u
[03:50:19] <cgaebel> lol
[03:50:44] *** Joins: new_one (new_one@990A9309.E8040809.B3C0173E.IP)
[03:50:45] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[03:52:08] <cgaebel> rusti: vec::from_fun(10u, |_| std::unstable::intrinsics::uninit<uint>())
[03:52:11] -rusti- pastebinned 14 lines of output: http://ix.io/agy
[03:52:19] <cgaebel> rusti: vec::from_fun(10u, |_| std::unstable::intrinsics::uninit<std::uint>())
[03:52:22] -rusti- pastebinned 14 lines of output: http://ix.io/agz
[03:52:30] <strcat> cgaebel: I would use with_capacity + set_len
[03:52:39] <strcat> so it performs well at -O0
[03:52:43] <cgaebel> strcat: what's vec_ng?
[03:52:59] <strcat> the future replacement for ~[T]
[03:53:05] <cgaebel> ok
[03:53:13] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[03:53:14] *** ChanServ sets mode: +ao dherman dherman
[03:53:22] <strcat> cgaebel: https://github.com/mozilla/rust/issues/11875 unlike ~[T], it's not slow :{
[03:53:24] <strcat> :P *
[03:53:27] <bvssvni> with does 'ng' mean?
[03:53:29] <strcat> ugh, smiley typos are the worst
[03:53:50] <bvssvni> *what
[03:54:02] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[03:54:04] *** Joins: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[03:54:11] <strcat> bvssvni: next-generation, it will be std::vec in the future
[03:54:19] <bvssvni> ah
[03:54:26] *** Quits: a_m0d (a_m0d@moz-2F294D00.acanac.net) (Quit: Leaving.)
[03:54:27] <strcat> just hard to port all the code to it in one go
[03:56:20] *** Joins: leafstorm (leafstorm@moz-F57A2464.rh.ncsu.edu)
[03:57:34] *** Joins: japaric (japaric@56FF3E09.8FD1E798.5C7588CA.IP)
[04:03:55] *** Joins: pcwalton (pcwalton@moz-DA87EE4.hsd1.ca.comcast.net)
[04:03:55] *** ChanServ sets mode: +ao pcwalton pcwalton
[04:06:01] *** Joins: alan_andrade (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net)
[04:06:50] *** Quits: quux00 (uid24415@moz-E77DEB21.irccloud.com) (Quit: Connection closed for inactivity)
[04:06:55] *** Quits: dmillerw (dylan@moz-F9231FD9.eugn.qwest.net) (Quit: Leaving)
[04:07:07] *** Quits: new_one (new_one@990A9309.E8040809.B3C0173E.IP) (Client exited)
[04:07:08] *** Joins: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP)
[04:08:28] *** Quits: alan_andrade (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net) (Ping timeout)
[04:08:31] *** Quits: an0nymous (Jacob@moz-F04BA440.tx.res.rr.com) (Quit: Leaving)
[04:09:23] *** Quits: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP) (Ping timeout)
[04:12:49] *** Joins: halorgium (z@moz-27C0632C.spork.in)
[04:12:55] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[04:13:44] *** Joins: jensnockert (jensnocker@moz-988C9930.e0f8471ae7fa.afb.bredband2.com)
[04:13:56] *** Quits: pcwalton (pcwalton@moz-DA87EE4.hsd1.ca.comcast.net) (Quit: pcwalton)
[04:15:37] *** Quits: jensnockert (jensnocker@moz-988C9930.e0f8471ae7fa.afb.bredband2.com) (Ping timeout)
[04:16:42] *** Joins: emerson (Icedove@6F3CD6F5.77F4443F.66AE2FF3.IP)
[04:18:30] <skrylar> strcat: is it going to replace the backend for ~[T] and keep the syntax?
[04:19:39] <strcat> skrylar: no
[04:20:19] <skrylar> so in the future we have to use vectors like annoying C++ classes? :(
[04:20:38] <strcat> I don't think it will be more annoying
[04:20:41] *** Joins: Jesin (Jesin@moz-3A2C5D36.washdc.fios.verizon.net)
[04:20:46] <strcat> ~[T] -> Vec<T> isn't bad
[04:20:55] <Eridius> Vec<T> will be needed to have a growable vector. Most code that uses vectors will use &[T].
[04:20:58] <o11c> it's not a good idea to have owned vecs at the language level
[04:21:01] <strcat> it's consistent with the other containers (HashMap<K, V>, HashSet<T>, etc.)
[04:21:06] <o11c> vecs by value and slices make sense
[04:21:12] <skrylar> if I wanted everything to look like C++0X, I would just use C++0X :\
[04:21:24] <strcat> it's not about looking like C++ or not looking like C++
[04:21:30] <strcat> it wasn't considered as part of the design
[04:21:50] <o11c> C++ made a LOT of good decisions, it just has to deal with legacy.
[04:21:53] <strcat> [T] is going to mean slice
[04:21:59] <strcat> slices are a ptr and a len
[04:22:04] <o11c> (and also it is a committee ... see the digit separator thing)
[04:22:10] <strcat> you will be able to have &[T], &mut [T], as you can do now
[04:22:17] <strcat> and *also* ArbitrarySmartPointer<[T]>
[04:22:23] <strcat> like Rc<[T]>
[04:22:37] <skrylar> i realize my opinions are just going to suffocate under the dogpile, but i really think having 20 <<<>><<><><><><<>'s in a line are really really really ugly
[04:22:47] <strcat> but this means ~[T] (Uniq<[T]>, lets ignore that syntax) isn't going to be growable
[04:22:55] <strcat> skrylar: the fact is that rust uses <> for generics
[04:23:01] *** Quits: synackse (jordyd@2D608993.77F880E0.D9401097.IP) (Ping timeout)
[04:23:04] <strcat> and there will be several vector implementations
[04:23:04] <skrylar> it already looks horrible dealing with Rc<Cell<blah>> in that the amount of shift key pressing rivals emacs key chording at times
[04:23:09] <o11c> skrylar: well, they refuse to use [] for generics even though it's perfectly possible
[04:23:15] <strcat> skrylar: so then your problem is with the generics syntax
[04:23:26] <strcat> skrylar: it is not a problem created by fixing slices/vectors
[04:23:49] *** Joins: synackse (jordyd@2D608993.77F880E0.D9401097.IP)
[04:24:12] <skrylar> strcat: correct; i find the syntax utterly painful on my fingers half the time
[04:24:34] <strcat> I prefer Rc[T] over Rc<T> too
[04:24:36] <o11c> sometimes in C++ I do: template<class T> using ptr = T*;
[04:24:38] <strcat> but it's too late for rust
[04:24:56] <o11c> strcat: it's not too late until 1.0 ... just make a compiler that accepts both for a while
[04:25:01] <strcat> o11c: it's nice for function ptrs
[04:25:20] <skrylar> i was actually working on an Io-inspired compiler before coming to rust, partly because I really like how Io humanizes Lisp syntax
[04:25:24] <strcat> o11c: it is too late to change the basic parts of the syntax like that imo
[04:25:31] <strcat> o11c: not 'too late' as in not possible
[04:25:33] <skrylar> (which was also part of my introduction to UTF-8 Hell)
[04:25:48] <strcat> o11c: too late as in you aren't going to convince the community/developers to change the syntax
[04:26:04] <strcat> you aren't going to convince them to use significant whitespace, [] for generics, etc.
[04:26:17] <skrylar> i wonder if there's be any value in a study for syntax ergonomics
[04:26:33] <o11c> significant whitespace is a "major change", but [] for generics seems pretty popular
[04:26:55] <strcat> if I could summon my ideal language into existence right now it would use significant whitespace like haskell does (not the icky python way) and [] for generics
[04:26:57] <strcat> ;p
[04:27:12] <skrylar> I don't have anything to substantiate it, I just find it interesting that languages such as Lisp or Smalltalk or Haskell have *very* productive people 
[04:27:30] <skrylar> And C++, which "technically" has a lot of the same things in Boost, though it looks like syntactic barf, are not as productive
[04:27:40] <o11c> yeah, I am fond of significant whitespace (if only because there are no OTBS wars), but I wouldn't ask for it.
[04:27:51] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Client exited)
[04:27:54] <skrylar> eh, i don't like significant whitespace :)
[04:28:12] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[04:28:18] <strcat> skrylar: fwiw, I dislike how python does it, so I really do mean haskell style significant whitespace
[04:28:26] <skrylar> maybe if you designed your language with elastic tabstops (http://nickgravgaard.com/elastictabstops/) 
[04:28:29] <strcat> python's is way too rigid/brittle
[04:28:34] *** Joins: jakerr (jakerr@moz-1095CD08.kanagawa.ocn.ne.jp)
[04:28:35] <o11c> from __future__ import       ;
[04:28:46] <pyon> o11c: hahaha
[04:29:01] <o11c> or in rust terms: #[    ];
[04:29:02] *** Quits: markos (markos@moz-7AAF4B96.xdsl.toledo.be) (Ping timeout)
[04:29:21] <skrylar> i might tinker around with my language again at a later date :\ rust is probably a better springboard than C99 was
[04:29:58] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Ping timeout)
[04:30:01] <skrylar> I figured it would be neat to model a language as a DSL within a scripting language, (there's that Lua/C thing.. Terra, does something kind of like that)
[04:30:17] <skrylar> gives you metaprogramming and CTFE fo free
[04:30:22] <skrylar> *for
[04:32:42] <strcat> skrylar: I think it would be easy to do CTFE on top of LLVM
[04:33:41] <skrylar> strcat: well this was basically to take Io, which is basically a javascript-y prototype based language with lisp-ish syntax
[04:33:47] <skrylar> shifting the parenthesis over one, so you have "Foo bar()"
[04:34:01] <pyon> How about using compile-time code execution for more ambitious purposes, e.g., extending the type system? I mean, like Gilad Bracha's idea of pluggable type systems, minus type checking being optional.
[04:34:16] <skrylar> and the "compiler" just takes in a set of objects; you can abuse Io's syntax hard enough that your actual "compiled" code is just a beaten up and abused DSL
[04:34:21] <ercxx> strcat: is your archlinux package compiled with the necessary android config options?
[04:34:22] <strcat> pyon: well that's basically C++ templates right there :P
[04:34:37] <strcat> ercxx: no, it can only build for target == host atm
[04:34:47] <ercxx> strcat: ok,thanks
[04:34:56] <skrylar> you get a lot of things for cheap, because you are directly touching the AST at all times
[04:35:07] <strcat> ercxx: I'll gladly build support for cross-compiling
[04:35:07] <skrylar> all though "code generating code" brain melts most people :(
[04:35:10] <pyon> strcat: But I mean using a separate metaprogramming language, that eliminates the need for unsafe blocks in the "ordinary" programming language.
[04:35:13] <strcat> ercxx: just haven't looked into how to do it
[04:35:26] *** Joins: tcreate (tcreate@moz-90E5C923.hsd1.ma.comcast.net)
[04:35:41] <strcat> ercxx: I'd like to have split packages for x86_64 <-> i686 linux, and also mingw-w64 support, and I guess android
[04:35:54] <pyon> strcat: e.g., all the unsafe stuff is pushed to compile-time code execution, so the worst that can happen is that the compiler fails horribly, not your program at runtime.
[04:36:09] <strcat> pyon: not really possible
[04:36:14] <strcat> pyon: the compiler is one giant unsafe block
[04:36:15] <ercxx> strcat: and I'm pretty sure you have all the time in the world to maintain 4 packages :)
[04:36:23] <strcat> pyon: proving the compiler correct sounds super hard
[04:36:25] <strcat> ;p
[04:36:49] <strcat> ercxx: well it just needs to be in the PKGBUILD and then the server building it will happily carry on
[04:36:55] <strcat> I only have to do something if it breaks :)
[04:36:56] *** Joins: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP)
[04:37:07] <pyon> strcat: That's the thing - you only need to prove it correct modulo abnormal termination. And compiler plugins can fail as much as you want.
[04:37:09] <ercxx> strcat: which would never happen :)
[04:38:08] <strcat> pyon: but you need the compiler's code generation to be correct
[04:38:31] <strcat> and any optimizations
[04:38:49] *** Quits: Jesin (Jesin@moz-3A2C5D36.washdc.fios.verizon.net) (Ping timeout)
[04:38:58] <strcat> like, prove http://llvm.org/docs/doxygen/html/SROA_8cpp_source.html is correct ;)
[04:39:06] *** Joins: nham (Mibbit@moz-2C6185F8.lightspeed.dybhfl.sbcglobal.net)
[04:39:14] *** Joins: Jesin (Jesin@moz-3A2C5D36.washdc.fios.verizon.net)
[04:39:53] <pyon> :-O
[04:40:55] <strcat> I guess if you start from a typed, safe IR, then you can do most of the optimization work on that
[04:41:01] <strcat> I think that's how haskell is built
[04:41:23] <strcat> but everyone wants faster, faster, faster so you'll have the low-level optimizations anyway...
[04:42:06] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[04:42:27] <pyon> Anyway... back to Earth^H^H^H^H^HRust, I am going to try this rust-core thing. :-)
[04:43:09] <strcat> not much there yet ;p
[04:43:20] *** Quits: wittytwit (Mibbit@moz-3DA5D4DF.dhcp.embarqhsd.net) (Quit: http://www.mibbit.com ajax IRC Client)
[04:43:37] <strcat> the main feature intended to be there was having all of the containers available for freestanding usage
[04:43:41] <strcat> via allocator support
[04:43:49] <strcat> but generic dtors don't work :(
[04:43:51] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[04:43:58] <pyon> Oh, std::sync is notoriously absent. :-(
[04:43:59] *** Joins: markos (markos@moz-7AAF4B96.xdsl.toledo.be)
[04:44:19] <strcat> pyon: locks are in the thread module
[04:44:31] *** Quits: jadbaires (jadrian@moz-7CA7E852.dsl.telepac.pt) (Quit: Konversation terminated!)
[04:44:33] <pyon> Ah!
[04:44:39] <strcat> concurrent data structures are in concurrent, and there's an arc module
[04:44:59] <strcat> the sharded hash table needs love - currently hashes everything twice and find only works via clone
[04:45:11] * strcat shrugs
[04:45:17] <pyon> MutexArcBox does not have a bool flag! Hooray!
[04:46:22] *** Quits: Jesin (Jesin@moz-3A2C5D36.washdc.fios.verizon.net) (Quit: Leaving)
[04:46:34] *** Joins: Jesin (Jesin@moz-3A2C5D36.washdc.fios.verizon.net)
[04:47:24] <strcat> I submitted many of the changes to the stdlib itself so... it's sort of just a place for me to play with stuff implemented how I think is 'right' :P
[04:48:07] <pyon> Ah. :-)
[04:50:36] <strcat> pyon: like, one day maybe I'll convince people that Eq and Ord should actually mean equality and ordering
[04:50:47] <strcat> but until then, rust-core can have what I think is a sane Eq/Ord ;P
[04:50:53] *** Quits: tcreate (tcreate@moz-90E5C923.hsd1.ma.comcast.net) (Client exited)
[04:50:53] <strcat> (i.e. floats don't implement them)
[04:51:26] <strcat> floats need their own min/max/clamp anyway
[04:51:34] <pyon> "floats don't implement them" --> YES!
[04:52:16] <strcat> not an incredibly useful library yet though
[04:52:38] <pyon> I was already resigned to SML being the only language that acknowledged that equality for float didn't make sense.
[04:53:10] <strcat> pyon: they do still have ==/!= operators, but they don't meet the Eq bound
[04:53:13] <pyon> Heck, even Haskell defines Eq and Ord for floats, and that is sad. :-(
[04:53:16] <strcat> since that's built-in
[04:53:19] <pyon> Oh.
[04:53:22] <strcat> but the trait impl isn't built-in
[04:53:35] <strcat> so that part is sad, depending on your PoV
[04:53:57] * strcat doesn't really care
[04:54:15] *** Quits: japaric (japaric@56FF3E09.8FD1E798.5C7588CA.IP) (Ping timeout)
[04:54:23] <strcat> generic code can assume Eq/Ord are a sane equivalence relation and total ordering
[04:54:47] <pyon> Yeah! At least this means I cannot make a TreeMap whose keys are float, which is a good thing.
[04:54:50] <strcat> and I guess to deal with floats, functions like xs.sort_by(...) will work
[04:55:02] <strcat> pyon: and you can't use them as hash table keys
[04:55:04] <strcat> which is a big issue
[04:55:15] <strcat> not just because you're relying on exact float comparisons
[04:55:27] <strcat> insert a NaN into a hash table
[04:55:31] <strcat> now search for it, you won't find it
[04:55:34] <strcat> doesn't compare equal
[04:55:39] <pyon> Yeah.
[04:55:40] <strcat> insert another NaN - it uses *another* bucket
[04:55:41] *** Joins: japaric1 (japaric@DDF50A2B.40EC661E.5C7588CA.IP)
[04:55:55] <strcat> rusti: let nan = 0.0 / 0.0; nan
[04:55:56] -rusti- NaNf64
[04:56:35] <strcat> rusti: let mut xs = std::hashmap::HashSet::new(); for _ in range(0, 20) { xs.insert(0.0 / 0.0) } xs
[04:56:36] -rusti- <anon>:10:52: 10:101 error: mismatched types: expected `()` but found `bool` (expected () but found bool)
[04:56:36] -rusti- <anon>:10         let mut xs = std::hashmap::HashSet::new(); for _ in range(0, 20) { xs.insert(0.0 / 0.0) } xs
[04:56:37] -rusti-                                                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[04:56:37] -rusti- error: aborting due to previous error
[04:56:37] -rusti- application terminated with error code 101
[04:56:39] <strcat> rusti: let mut xs = std::hashmap::HashSet::new(); for _ in range(0, 20) { xs.insert(0.0 / 0.0); } xs
[04:56:42] -rusti- pastebinned 1 lines of output: http://ix.io/agH
[04:56:50] <strcat> meh
[04:56:52] *** Quits: tiffany (kawaii@moz-FC0DB29D.dhcp.embarqhsd.net) (Connection reset by peer)
[04:56:52] *** Joins: derek_c (derek@moz-CE6E60A5.cit.cornell.edu)
[04:56:54] <strcat> reflection can't see it now
[04:56:58] <dbaupp> size: 20
[04:57:16] <strcat> dbaupp: yep
[04:57:20] <strcat> rusti: let mut xs = std::hashmap::HashSet::new(); for _ in range(0, 20) { xs.insert(0.0 / 0.0); } xs.len()
[04:57:21] -rusti- 20u
[04:57:22] <strcat> !
[04:57:29] <strcat> rusti: let mut xs = std::hashmap::HashSet::new(); for _ in range(0, 2000) { xs.insert(0.0 / 0.0); } xs.len()
[04:57:29] <pyon> heh
[04:57:30] -rusti- 2000u
[04:57:43] <pyon> ikr wth
[04:57:45] <strcat> and now inserting into that table is basically O(n)
[04:58:14] <strcat> unless you're lucky and you only inserted a few dozen and don't need to insert other keys near that monstrosity
[04:58:18] *** Joins: tiffany (kawaii@moz-FC0DB29D.dhcp.embarqhsd.net)
[04:58:33] <strcat> rusti: let mut xs = std::hashmap::HashSet::new(); for _ in range(0, 200000) { xs.insert(0.0); } xs.len()
[04:58:34] -rusti- 1u
[04:58:41] <strcat> rusti: let mut xs = std::hashmap::HashSet::new(); for _ in range(0, 200000) { xs.insert(0.0 / 0.0); } xs.len()
[04:58:45] <strcat> timeout
[04:58:47] -rusti- timeout triggered!
[04:58:48] <strcat> wooo O(n)
[04:58:51] <pyon> hahaha
[04:59:44] <strcat> rustilite: fn main() {}
[04:59:47] * strcat messes with rustilite
[05:02:04] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[05:02:05] <strcat> pyon: ofc, at least they aren't js/php :P
[05:02:28] <strcat> rustilite: var a = new Boolean(false); a == false
[05:02:28] -rustilite- true
[05:02:38] <strcat> rustilite: var a = new Boolean(false); if (a) { console.log("true") } a == false
[05:02:38] -rustilite- true
[05:02:39] -rustilite- true
[05:02:47] * strcat loves that one
[05:02:50] <pyon> lol
[05:02:59] <strcat> puts NaN to shame
[05:03:16] *** jorendorff_away is now known as jorendorff
[05:06:02] *** Quits: csherratt (csherratt@moz-7685819.cpe.teksavvy.com) (Ping timeout)
[05:06:04] *** Quits: synackse (jordyd@2D608993.77F880E0.D9401097.IP) (Quit: synackse)
[05:06:41] *** Joins: csherratt (csherratt@moz-7685819.cpe.teksavvy.com)
[05:07:58] *** Joins: gwty (gwtypc@2D0C08FA.3AF9C23B.45DA6411.IP)
[05:08:37] *** Joins: alan_andrade (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net)
[05:11:54] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: sleep)
[05:11:56] *** Quits: alan_andrade (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net) (Ping timeout)
[05:16:32] *** Quits: Earnestly (earnest@moz-1CE0D638.dyn.plus.net) (Ping timeout)
[05:16:55] *** Quits: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz) (Quit: Busying myself...)
[05:19:34] *** Quits: Jesin (Jesin@moz-3A2C5D36.washdc.fios.verizon.net) (Quit: Leaving)
[05:19:58] *** Quits: valenting (Thunderbir@moz-EF716D84.xdsl.toledo.be) (Ping timeout)
[05:20:48] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[05:21:44] *** Quits: BossKonaSegway (Michael@moz-2986F42D.col.wideopenwest.com) (Connection reset by peer)
[05:23:57] *** Joins: BossKonaSegway (Michael@moz-2986F42D.col.wideopenwest.com)
[05:25:22] *** Quits: aruniiird (aruniiird@28876D92.F24A7F1B.260B031E.IP) (Ping timeout)
[05:27:53] *** Quits: kellogh (timkellogg@moz-704A74D.hsd1.co.comcast.net) (Quit: kellogh)
[05:29:27] *** Quits: johnsoft (johnsoft@moz-7E09A266.neo.res.rr.com) (Ping timeout)
[05:29:48] *** Quits: canhtak (canhtak@moz-9E539298.wl.t.ulaval.ca) (Quit: canhtak)
[05:29:48] *** Joins: slimer (Mibbit@A2BF1BA0.F93A2643.971E19F6.IP)
[05:29:56] *** Joins: johnsoft (johnsoft@moz-7E09A266.neo.res.rr.com)
[05:30:07] *** Joins: canhtak (canhtak@moz-9E539298.wl.t.ulaval.ca)
[05:32:26] *** Quits: slimer (Mibbit@A2BF1BA0.F93A2643.971E19F6.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[05:34:46] *** Joins: Jesse (jruderman@moz-9754CB0.hsd1.ca.comcast.net)
[05:41:16] <yuriks> https://github.com/yuriks/OpenVikings/blob/master/tools-ng/Makefile
[05:41:20] <yuriks> eurgh. Make is just all kinds of terrible
[05:41:37] <yuriks> if anyone has any cleanups to suggest I'd be glad to take them :)
[05:42:39] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[05:44:27] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[05:46:53] *** Quits: anonymous_29563 (Mibbit@moz-A082F561.adsl.xtra.co.nz) (Quit: http://www.mibbit.com ajax IRC Client)
[05:51:30] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[05:59:23] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[06:00:55] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Connection reset by peer)
[06:02:38] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[06:02:48] *** Joins: tcreate (tcreate@moz-90E5C923.hsd1.ma.comcast.net)
[06:11:52] *** Joins: alan_andrade (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net)
[06:14:18] *** Quits: alan_andrade (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net) (Ping timeout)
[06:14:40] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[06:14:59] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[06:16:35] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[06:22:03] *** Quits: darthdeus (darthdeus@EEC5B4DB.3B96A244.4E88690D.IP) (Quit: Leaving...)
[06:29:46] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[06:30:34] *** Quits: jakerr (jakerr@moz-1095CD08.kanagawa.ocn.ne.jp) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[06:31:48] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Ping timeout)
[06:32:08] *** Quits: tcreate (tcreate@moz-90E5C923.hsd1.ma.comcast.net) (Client exited)
[06:32:49] *** Joins: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[06:34:47] *** Joins: jackneill (jackneill@moz-F643C3DE.pool.digikabel.hu)
[06:39:04] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.2)
[06:39:09] *** Quits: gwty (gwtypc@2D0C08FA.3AF9C23B.45DA6411.IP) (Ping timeout)
[06:39:15] *** Joins: tcreate (tcreate@moz-90E5C923.hsd1.ma.comcast.net)
[06:39:58] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[06:41:04] *** Quits: victorporof_ (victorporo@53EBB099.7C27E871.79933D60.IP) (Quit: victorporof_)
[06:43:13] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[06:45:00] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[06:47:24] *** Quits: jvoorhis (jvoorhis@moz-84A91726.ptld.qwest.net) (Client exited)
[06:47:48] *** Joins: jvoorhis (jvoorhis@moz-84A91726.ptld.qwest.net)
[06:49:33] *** Quits: jvoorhis (jvoorhis@moz-84A91726.ptld.qwest.net) (Ping timeout)
[06:50:54] *** Joins: gwty (gwtypc@FB838CD7.DCF3E831.27560D6E.IP)
[06:51:23] <skrylar> hrm
[06:51:43] <skrylar> Now I'm starting to see why pointer equality was useful in RCs
[06:51:57] *** Joins: diaz (Mibbit@moz-12ADC7C1.rev.vodafone.pt)
[06:52:58] *** Quits: cgaebel (clark@moz-92F543E4.nycmny.east.verizon.net) (Ping timeout)
[06:52:58] *** Quits: gwty (gwtypc@FB838CD7.DCF3E831.27560D6E.IP) (Ping timeout)
[06:54:46] *** Quits: tcreate (tcreate@moz-90E5C923.hsd1.ma.comcast.net) (Client exited)
[06:54:46] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[06:55:33] *** Joins: alan_andrade (alan_andra@moz-7559582E.hsd1.ca.comcast.net)
[06:55:41] *** Joins: cgaebel (clark@ADA4DDE2.290DF317.EE6E63A5.IP)
[06:56:05] *** Joins: tcreate_ (tcreate@moz-90E5C923.hsd1.ma.comcast.net)
[06:57:53] *** Quits: derek_c (derek@moz-CE6E60A5.cit.cornell.edu) (Ping timeout)
[07:05:11] <mcpherrin> rusti: 299_792_000f64/60f64
[07:05:16] -rusti- 4996533.33333333f64
[07:08:53] *** Quits: james4k (james@moz-9BB5AE72.consolidated.net) (Ping timeout)
[07:11:42] *** Quits: tcreate_ (tcreate@moz-90E5C923.hsd1.ma.comcast.net) (Client exited)
[07:12:46] *** Joins: tcreate (tcreate@moz-90E5C923.hsd1.ma.comcast.net)
[07:13:51] *** Joins: derek_c (derek@moz-A44964B8.cit.cornell.edu)
[07:14:42] *** Joins: alan_and_ (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net)
[07:16:06] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[07:17:58] *** Quits: alan_and_ (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net) (Ping timeout)
[07:18:10] *** Joins: jvoorhis (jvoorhis@moz-84A91726.ptld.qwest.net)
[07:19:33] *** Joins: Armavica (virgile@moz-AD428ED7.ens.fr)
[07:19:52] *** Quits: jvoorhis (jvoorhis@moz-84A91726.ptld.qwest.net) (Ping timeout)
[07:23:04] *** Quits: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net) (Quit: Leaving.)
[07:23:31] *** Joins: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[07:24:53] *** Quits: nham (Mibbit@moz-2C6185F8.lightspeed.dybhfl.sbcglobal.net) (Quit: http://www.mibbit.com ajax IRC Client)
[07:25:30] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[07:25:34] *** Joins: gwty (gwtypc@2D0C08FA.3AF9C23B.45DA6411.IP)
[07:25:53] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[07:26:49] *** Quits: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net) (Quit: Leaving.)
[07:28:06] *** Quits: nate (pinkeh@moz-B8462C56.members.linode.com) (Quit: ...)
[07:28:09] *** Quits: tcreate (tcreate@moz-90E5C923.hsd1.ma.comcast.net) (Client exited)
[07:28:32] *** Joins: nate (cs61-nherm@moz-A3C418FF.hcs.harvard.edu)
[07:29:28] *** Quits: maxli (maxli@moz-EE42E0E.student.cs.uwaterloo.ca) (Quit: Leaving.)
[07:30:09] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[07:30:54] *** Quits: derek_c (derek@moz-A44964B8.cit.cornell.edu) (Quit: Leaving)
[07:31:10] *** Quits: nate (cs61-nherm@moz-A3C418FF.hcs.harvard.edu) (Quit: leaving)
[07:31:22] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[07:34:12] *** Joins: maxli (maxli@moz-EE42E0E.student.cs.uwaterloo.ca)
[07:34:34] *** Quits: hoverbear (hoverbear@moz-86FCBF4B.gv.shawcable.net) (Quit: Taking a nap.)
[07:35:54] *** Quits: maxli (maxli@moz-EE42E0E.student.cs.uwaterloo.ca) (Ping timeout)
[07:36:27] *** Joins: nate (pinkeh@moz-A3C418FF.hcs.harvard.edu)
[07:36:27] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[07:38:56] *** Quits: sankha93 (uid12218@moz-31ABA2C0.irccloud.com) (Ping timeout)
[07:38:56] *** Quits: machty (sid13535@moz-31ABA2C0.irccloud.com) (Ping timeout)
[07:38:56] *** Quits: LQDH (uid17894@moz-31ABA2C0.irccloud.com) (Ping timeout)
[07:38:56] *** Quits: escalant3 (uid14896@moz-31ABA2C0.irccloud.com) (Ping timeout)
[07:40:10] *** Quits: diaz (Mibbit@moz-12ADC7C1.rev.vodafone.pt) (Quit: http://www.mibbit.com ajax IRC Client)
[07:40:19] *** Joins: escalant3 (uid14896@moz-31ABA2C0.irccloud.com)
[07:42:45] *** Joins: LQDH (uid17894@moz-31ABA2C0.irccloud.com)
[07:42:47] *** Joins: machty (sid13535@moz-31ABA2C0.irccloud.com)
[07:43:30] <cmr> Any announcements for TWiR?
[07:43:45] * cmr should probably also ask that question when most americans are awake
[07:43:47] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[07:43:50] *** Joins: sankha93 (uid12218@moz-31ABA2C0.irccloud.com)
[07:45:30] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[07:50:27] *** Joins: dbussink (dbussink@moz-E0A5568C.bussink.me)
[07:53:32] *** Quits: gwty (gwtypc@2D0C08FA.3AF9C23B.45DA6411.IP) (Ping timeout)
[07:53:32] *** Quits: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net) (Ping timeout)
[07:53:36] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Client exited)
[07:54:02] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[07:54:07] *** Joins: tcreate (tcreate@moz-90E5C923.hsd1.ma.comcast.net)
[07:55:44] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Ping timeout)
[07:55:45] *** Joins: marianoguerra (marianogue@moz-6201702.dip0.t-ipconnect.de)
[07:56:52] *** Joins: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[07:57:43] *** Quits: mojoB (mojoB@moz-A4312114.static.exetel.com.au) (Quit: leaving)
[07:58:13] *** Quits: thewonderidiot (mike@moz-5506A033.hsd1.ca.comcast.net) (Connection reset by peer)
[08:03:03] *** Quits: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net) (Ping timeout)
[08:06:21] *** Joins: devbug (quassel@23AC5F12.9D950176.3655BBF5.IP)
[08:06:56] *** Quits: tcreate (tcreate@moz-90E5C923.hsd1.ma.comcast.net) (Client exited)
[08:07:31] *** Joins: tcreate (tcreate@moz-90E5C923.hsd1.ma.comcast.net)
[08:08:02] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[08:09:14] *** Quits: tcreate (tcreate@moz-90E5C923.hsd1.ma.comcast.net) (Ping timeout)
[08:09:17] *** Quits: markos (markos@moz-7AAF4B96.xdsl.toledo.be) (Quit: Ex-Chat)
[08:10:22] *** Joins: aruniiird (aruniiird@28876D92.F24A7F1B.260B031E.IP)
[08:12:21] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[08:12:39] *** Quits: aruniiird (aruniiird@28876D92.F24A7F1B.260B031E.IP) (Ping timeout)
[08:12:46] *** Joins: fyolnish (fyolnish@moz-DF51EDFB.panda-world.ne.jp)
[08:15:36] *** Joins: jensnockert (jensnocker@moz-988C9930.e0f8471ae7fa.afb.bredband2.com)
[08:16:37] <cmr> Not a single typo in TWiR!
[08:16:44] * cmr crosses fingers, probably just jinxed it
[08:17:11] *** Joins: dapz (textual@moz-F958911.hsd1.ca.comcast.net)
[08:17:26] <kimundi> cmr: Typos are like bugs: There are always some left :P
[08:17:28] *** Quits: jensnockert (jensnocker@moz-988C9930.e0f8471ae7fa.afb.bredband2.com) (Ping timeout)
[08:18:08] *** Joins: alan_and_ (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net)
[08:18:31] *** Quits: jeaye (jeaye@moz-34FEF2BB.hsd1.ca.comcast.net) (Quit: zzz)
[08:18:50] *** Joins: jvoorhis (jvoorhis@moz-84A91726.ptld.qwest.net)
[08:20:39] *** Quits: jvoorhis (jvoorhis@moz-84A91726.ptld.qwest.net) (Ping timeout)
[08:20:39] *** Quits: alan_and_ (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net) (Ping timeout)
[08:20:59] *** Quits: marianoguerra (marianogue@moz-6201702.dip0.t-ipconnect.de) (Ping timeout)
[08:22:07] <cmr> http://cmr.github.io/blog/2014/02/01/this-week-in-rust/
[08:22:08] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[08:26:35] *** Joins: claudiu (claudiu@moz-D5BFAAB5.hsd1.ca.comcast.net)
[08:27:35] *** Quits: rustilite (rustilite@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[08:27:43] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[08:28:02] *** Quits: zztr (Thunderbir@moz-CA50D606.dsl.static.sonic.net) (Quit: zztr)
[08:28:03] *** Joins: aruniiird (aruniiird@moz-3DB73AA5.azulsystems.com)
[08:28:06] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Connection reset by peer)
[08:28:30] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[08:28:55] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[08:29:42] <alan_andrade> Considering this: https://gist.github.com/anonymous/39fc52f026c027c2dcbe
[08:29:57] <alan_andrade> How can I pass a pointer to getgroups() ?
[08:31:35] <cmr> alan_andrade: looks like the getgroups function signature in rust would be fn getgroups(num: c_int, groups: *c_void)
[08:32:01] <alan_andrade> *c_void is like pointer to null ?
[08:32:28] <cmr> it's void* in C
[08:32:50] <alan_andrade> oh
[08:33:00] *** Joins: victorporof (victorporo@53EBB099.7C27E871.79933D60.IP)
[08:33:20] <alan_andrade> And how would you initialize the array ?
[08:33:40] *** Joins: claudiu_ (claudiu@CB447DD5.6B10AC3.E2F59BBC.IP)
[08:33:41] <cmr> well whatever xmalloc is you want to be binding that in Rust
[08:33:52] <cmr> so that it uses the same allocator to free it...
[08:34:30] *** Quits: claudiu (claudiu@moz-D5BFAAB5.hsd1.ca.comcast.net) (Ping timeout)
[08:34:33] *** Quits: ercxx (ercan@moz-88DD3A7E.dyn.optonline.net) (Quit: WeeChat 0.4.2)
[08:35:00] *** Quits: Yurumechan (23f9939a@B2F514.E4420F21.EEF52F3A.IP) (Ping timeout)
[08:36:02] *** Joins: dmac (dmac@moz-94F55C3.hfc.comcastbusiness.net)
[08:36:27] *** Joins: tcreate (tcreate@moz-90E5C923.hsd1.ma.comcast.net)
[08:37:01] <alan_andrade> : ( I'm lost. 
[08:38:03] <alan_andrade> whatever xmalloc is, you wanto be binding that in Rust  ::  How do I that ?
[08:38:03] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Connection reset by peer)
[08:39:22] <cmr> dunno, what are you trying to write?
[08:39:26] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[08:39:37] <alan_andrade> I'm porting id.c
[08:39:42] <cmr> which is?
[08:39:56] <alan_andrade> From coreutils
[08:39:57] <alan_andrade> https://github.com/uutils/coreutils
[08:40:07] *** Joins: dbaupp|ph (dbaupp@moz-6DF78F5B.pa.nsw.optusnet.com.au)
[08:40:30] <cmr> oh
[08:40:35] <cmr> can't you just call getgroups from libc?
[08:41:14] <alan_andrade> oh, I haven't tried that
[08:41:28] <dbaupp|ph> cmr: twir has 2 instances of [text] without a link
[08:41:50] *** Quits: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp) (Client exited)
[08:41:52] <cmr> if you see its manpage, it will return the number of groups there are if you pass gidsetsize as 0, then you can find the gid_t structure from the header, and allocate a ~[Gid] (where Gid is the Rust equivalent to gid_t) and pass a pointer to that (.as_ptr() method) to the libc function
[08:41:55] <cmr> dbaupp|ph: dammit!
[08:42:11] *** Joins: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp)
[08:42:13] <dbaupp|ph> both have "renamed" in them
[08:42:36] *** Joins: Yurumechan (23f9939a@B2F514.E4420F21.EEF52F3A.IP)
[08:42:48] <dbaupp|ph> (you did jinx it :P )
[08:43:19] *** Joins: rustilite (rustilite@moz-54F7FD49.cpe.net.cable.rogers.com)
[08:43:31] <zxcdw> cmr: It's February now :)
[08:43:39] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[08:43:40] <zxcdw> (Reddit TWIR says Jan 1st)
[08:43:52] *** Quits: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp) (Ping timeout)
[08:43:57] <cmr> dammit
[08:44:05] * cmr should do TWiR earlier in the night
[08:44:19] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[08:44:32] *** Quits: dbaupp|ph (dbaupp@moz-6DF78F5B.pa.nsw.optusnet.com.au) (Ping timeout)
[08:46:03] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[08:46:45] *** Quits: Jesse (jruderman@moz-9754CB0.hsd1.ca.comcast.net) (Quit: Jesse)
[08:48:19] *** Quits: csherratt (csherratt@moz-7685819.cpe.teksavvy.com) (Quit: csherratt)
[08:48:33] *** Joins: io2 (io2@moz-7C3DDBE8.home.otenet.gr)
[08:48:34] *** Quits: pyon (user@B454AC64.92B6FB33.1C8C8CE9.IP) (Quit: brb)
[08:53:02] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Client exited)
[08:53:32] *** jorendorff is now known as jorendorff_away
[08:53:33] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[08:54:12] *** Joins: DAddYE_ (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[08:54:12] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Connection reset by peer)
[08:55:34] *** Quits: tcreate (tcreate@moz-90E5C923.hsd1.ma.comcast.net) (Client exited)
[08:55:35] *** Joins: LinearInterpol (RJones@moz-E6F82C3A.maine.res.rr.com)
[08:55:52] *** Quits: geomyidae (quassel@DD6F7E3A.21468E9A.30200F38.IP) (Ping timeout)
[08:55:52] *** Quits: onelson (owen@18CF7301.95770028.5B6BFE7D.IP) (Ping timeout)
[08:55:53] *** Quits: NewFolder (adamle@moz-38947329.dedicated.allstream.net) (Connection reset by peer)
[08:55:54] *** Quits: Ralith (ralith@moz-67D4EB93.customer.broadstripe.net) (Ping timeout)
[08:56:06] *** Joins: jensnockert (jensnocker@moz-988C9930.e0f8471ae7fa.afb.bredband2.com)
[08:56:08] *** Joins: geomyidae (quassel@DD6F7E3A.21468E9A.30200F38.IP)
[08:56:12] *** Joins: pyon (user@B454AC64.92B6FB33.1C8C8CE9.IP)
[08:56:14] *** Joins: Ralith (ralith@moz-67D4EB93.customer.broadstripe.net)
[08:56:15] *** Joins: vadimcn_ (chatzilla@FB06B64.76F9E272.DA40C4B3.IP)
[08:56:19] *** Quits: vadimcn (chatzilla@FB06B64.76F9E272.DA40C4B3.IP) (Ping timeout)
[08:56:27] *** vadimcn_ is now known as vadimcn
[08:57:14] *** Joins: onelson (owen@18CF7301.95770028.5B6BFE7D.IP)
[08:57:50] *** Joins: NewFolder (adamle@moz-38947329.dedicated.allstream.net)
[08:57:57] *** Quits: jensnockert (jensnocker@moz-988C9930.e0f8471ae7fa.afb.bredband2.com) (Ping timeout)
[08:58:35] *** Joins: jvoorhis (jvoorhis@moz-84A91726.ptld.qwest.net)
[09:00:19] *** Quits: jvoorhis (jvoorhis@moz-84A91726.ptld.qwest.net) (Ping timeout)
[09:00:46] *** flaper87|afk is now known as flaper87
[09:00:58] *** Quits: nrc|afk (nrc@7BE24E90.A5032A01.3CFC199D.IP) (Ping timeout)
[09:01:42] *** Joins: dmac1 (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[09:02:41] *** Joins: mankyKitty (Instantbir@moz-F98AF264.rev.sfr.net)
[09:03:18] <alan_andrade> I'm getting an error about the pointer being modified before it get's freed
[09:03:24] *** Quits: dmac1 (Adium@moz-94F55C3.hfc.comcastbusiness.net) (Ping timeout)
[09:03:55] <alan_andrade> let n_groups = unsafe { libc::getgroups(13, groups.as_mut_ptr()) };
[09:04:33] <alan_andrade> let mut groups: ~[libc::gid_t] = ~[];
[09:04:52] *** Joins: Seb (Seb@moz-97344273.actrix.co.nz)
[09:05:11] *** Joins: Ms2ger (Ms2ger@3A6075EE.3EF83E22.692B9746.IP)
[09:06:32] *** Joins: adridu59 (Mibbit@moz-E1FF077C.rev.numericable.fr)
[09:07:00] <adridu59> dbaupp: think I've got a patch for SNAP
[09:07:07] <adridu59> haven't tried it however
[09:07:40] *** Ms2ger is now known as Ms2ger|llvmdevroom
[09:08:34] *** Quits: DAddYE_ (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Client exited)
[09:08:49] *** Quits: aruniiird (aruniiird@moz-3DB73AA5.azulsystems.com) (Ping timeout)
[09:09:05] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[09:09:19] *** Joins: nooblit (Mibbit@moz-CBA73F0A.dhcp.ftwo.tx.charter.com)
[09:09:59] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[09:10:48] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[09:11:50] <nooblit> I know Rust is not finished yet but when it is, would it be suitable to learn for a first time language? I want to learn a programming language and reading about this language, it sounds safer than c++?
[09:11:57] *** Joins: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz)
[09:12:27] *** Joins: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp)
[09:13:31] <benh> It probably will not change too much between now and 1.0
[09:14:11] *** Quits: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp) (Ping timeout)
[09:14:26] <benh> That is, it'll still be recognizable and code will require less fixing up than for previous language changes. And of course things you learn about programming are forever, not just one language! ;)
[09:14:53] <kimundi> nooblit: Its maybe not the best choice for a first language because of its complexity, but if you want to start by digging in deep, then its certainly a safer and less confusing start than C++ I'd say.
[09:15:11] <dbaupp> adridu59: awesome! :)
[09:15:28] <dbaupp> adridu59: you should try it. (I think I described a testcase for it in the issue?)
[09:15:34] <kimundi> Of course C++ has the advantage of having decades of code examples, docs and documentation
[09:15:34] * dbaupp checks
[09:15:45] <benh> I wouldn't be afraid so much of the complexity and maybe more that you can't throw a computer out of a window without hitting some C++ programmer on the head, but-- yeah
[09:15:51] <kimundi> But thats also its disadvantage, because it changed a lot in the meantime ;)
[09:16:27] <cmr> nooblit: as a first language I think it's an extraordinarily poor choice.
[09:16:57] <cmr> nooblit: it's complex and relatively poorly documented, and many of its decisions are made to solve difficult problems, that a beginner can't easily identify with.
[09:17:20] <nooblit> Yeah, I think the only barrier for me is there are not tutorials for first time programmers like myself, they all assume you know one :), I tried to learn D but I didn't find any beginner tutorials. But if I have too I'll learn c++ so I can learn Rust.  
[09:17:44] <cmr> so not only will you be struggling with Rust itself, you'll be struggling with the very concepts it implicitly assumes understanding of
[09:17:46] <cmr> yeah
[09:17:49] <cmr> I wouldn't recommend C++ either.
[09:17:58] <cmr> Python, or Ruby, are good choices.
[09:18:12] <cmr> or, in this day and age, javascript!
[09:18:19] <nooblit> I would learn python but I want a fast language.
[09:18:45] <cmr> shouldn't the goal be knowing any language at all, rather than having very fast execution? :)
[09:18:47] <adridu59> C
[09:19:16] <adridu59> Python is cool to know alognside system languages for writings scripts and simple programs
[09:19:19] <nooblit> I hear that a lang is like a tool though, right tool for the right job but I'm not sure I can learn all of them.
[09:19:20] <cmr> C has its pitfalls but isn't that bad of a language to get started with... it's harder to "get stuff done" though, comparatively.
[09:19:23] <adridu59> all scripts on the rust repo use python
[09:19:37] <adridu59> and it has some of the best tutorials out there
[09:19:39] *** Joins: Saj (Sajuuk@moz-840D0658.netvisao.pt)
[09:19:43] <adridu59> so it might be a good plan
[09:19:44] <dbaupp> nooblit: once you've got some inexperience in one language, learning the next is easier
[09:19:49] <dbaupp> *experience
[09:20:05] <dbaupp> and two makes the third easier, etc.
[09:20:23] *** Joins: alan_and_ (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net)
[09:20:31] <cmr> nooblit: they're all tools, but you need to understand *what* you're doing before you can use a hammer.
[09:20:42] <cmr> What is a nail? What is a nail used for?
[09:20:44] <cmr> etc
[09:21:00] <dbaupp> (e.g. the skills/ideas one learns from Python are (mostly) transferable to C, C++, D, Rust.)
[09:21:00] <adridu59> dbaupp: I don't know why but when pulling upstream I have that `src/llvm` fallout and git submodule update fails
[09:21:00] <cmr> And whether a screw is a better choice, or a bolt.
[09:21:07] <nooblit> Hey, if I do choose to learn c++ first, would subset of it should I use, I read about people trying to program in c++ like they program in C and people said that is wrong.
[09:21:14] <dbaupp> adridu59: `git checkout src/llvm` iirc
[09:21:33] * dbaupp somehow manages to fix that stuff, but can never remember how to describe it to someone else
[09:21:35] <cmr> nooblit: hard to say. the "modern" subset is very complex..
[09:21:47] <cmr> dbaupp: git submodule update?
[09:21:51] <adridu59> dbaupp: nice thanks
[09:21:57] <cmr> if it fails, dunno..
[09:22:01] <cmr> submodules are magic to me.
[09:22:16] <cmr> (the bad kind of magic, the kind that explodes in face and turns sister into frog, etc)
[09:22:26] <adridu59> dbaupp: oh no it doesn't work
[09:22:27] <nooblit> Well thanks for the info buys, If I knew more about programming, I would try to help with Rust but I'll have to use it after I get more experience. 
[09:22:52] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[09:22:59] *** Joins: eddyb (eddy@832D2DE5.66315F97.FB866788.IP)
[09:23:13] <bjz> nooblit
[09:23:23] <bjz> nooblit: dw, we'll still be here!
[09:23:27] <bjz> :)
[09:23:37] *** Joins: awidegreen (awidegreen@moz-9FADBE94.a357.priv.bahnhof.se)
[09:23:45] *** Quits: alan_and_ (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net) (Ping timeout)
[09:24:26] *** Joins: aruniiird (aruniiird@28876D92.F24A7F1B.260B031E.IP)
[09:24:31] <bjz> nooblit: re programming like C in C++, yes that is not the recommended way
[09:25:31] <bjz> nooblit: the issue with C++ is that it is an extremely complex language, and all the defaults are things that should be discouraged
[09:25:35] *** Quits: mankyKitty (Instantbir@moz-F98AF264.rev.sfr.net) (Ping timeout)
[09:25:43] *** Quits: canhtak (canhtak@moz-9E539298.wl.t.ulaval.ca) (Quit: canhtak)
[09:25:55] <bjz> nooblit: you have to learn lots of 'culture' before you can be proficient
[09:26:28] <adridu59> dbaupp: should have just reran ./configure tbh
[09:26:35] <dbaupp> adridu59: does that work?
[09:26:35] <adridu59> (my bad)
[09:26:47] <alan_andrade> https://gist.github.com/alan-andrade/8765242
[09:27:05] <adridu59> dbaupp: well I just trashed my local copy without trying
[09:27:23] <nooblit> c++ Is it just the memory management that is hard or is it because there is so many design choices ?
[09:27:26] *** Joins: csherratt (csherratt@moz-7685819.cpe.teksavvy.com)
[09:27:29] <alan_andrade> cmr if pointer can't be changed, how could I interact with libc::getgroups ?
[09:27:52] <cmr> alan_andrade: you are making an empty vector and trying to put 69 elements in it.
[09:28:04] <adridu59> nooblit: there problem is the unsafety of the language itself, you have to handle things carefully
[09:28:06] <cmr> do std::vec::with_capacity(69) and then .set_len()
[09:28:12] <cmr> or default-initialize it.
[09:28:14] <dbaupp> nooblit: there are lot of historical constrains that the language has had to squeeze itself around
[09:28:20] *** Quits: csherratt (csherratt@moz-7685819.cpe.teksavvy.com) (Quit: csherratt)
[09:28:22] <bjz> nooblit: I would recommend Scheme or Racket as a first language http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/
[09:28:23] <adridu59> nooblit: it is simpler than Rust through because Rust provides safety by semantics
[09:28:40] <adridu59> nooblit: but C++ will crash at runtime
[09:28:50] <adridu59> (if you do things wrong)
[09:29:01] <FliPPeh> Or worse, it won't crash
[09:29:01] <dbaupp> adridu59: writing correct C++ is not simpler than Rust.
[09:29:20] <bjz> nooblit: http://mitpress.mit.edu/sicp/full-text/book/book.html
[09:30:05] <nooblit> I'll take a look at it bjz, and also, is it appropriate for me to be asking these questions in here? I don't want to annoy anyone ?
[09:30:17] <cmr> nooblit: yes, this is the right place.
[09:30:22] <bjz> nooblit: no it's fine
[09:30:32] <bjz> nooblit: it's a great question
[09:31:28] <bjz> adridu59: Rust exposes the true complexities up front, where as C and C++ hide it until it's a problem
[09:31:28] <alan_andrade> cmr It worked. Thank you   \o/
[09:32:05] <kimundi> The fact that people that want to learn programming end up here in the first place is already great :D
[09:32:18] <bjz> kimundi: ++
[09:32:18] *** Quits: fyolnish (fyolnish@moz-DF51EDFB.panda-world.ne.jp) (Connection reset by peer)
[09:32:42] <FliPPeh> How many people have ended up here because they were looking for Rust, the game?
[09:32:45] <bjz> nooblit: if I might ask, what brought you here?
[09:32:48] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Client exited)
[09:33:02] <bjz> FliPPeh: they mainly stuble in on the freenode channel
[09:33:02] <kimundi> FliPPeh: A order of magnitude more T_T
[09:33:08] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[09:33:17] <FliPPeh> I've seen a few of them on /r/rust
[09:33:19] <FliPPeh> Always fun
[09:33:21] <bjz> FliPPeh: >_<
[09:33:43] <dbaupp> FliPPeh: there's 3 or 4 posts a day on /r/rust
[09:33:44] <nooblit> I tried to learn Scala as a first time language but the book I found was called atomic and it was outdated and no longer supported. So then I tried D and didn't find any newbie guides. I hope people make a good guide for rust for new people after 1.0 is out a while.
[09:33:56] <dbaupp> FliPPeh: (from people looking for /r/playrust)
[09:34:28] *** Joins: p1start (Mibbit@moz-A082F561.adsl.xtra.co.nz)
[09:34:35] <dbaupp> y'all need to be less nice about directing them to /r/playrust, btw. :P
[09:34:51] <cmr> I've just been reporting them now.
[09:34:53] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[09:35:01] *** Quits: p1start (Mibbit@moz-A082F561.adsl.xtra.co.nz) (Quit: http://www.mibbit.com ajax IRC Client)
[09:35:01] <bjz> nooblit: what are your goals with learning programming? just general interest?
[09:35:06] <bjz> cmr: flagging?
[09:35:22] <cmr> bjz: yeah
[09:35:30] <bjz> I might do that then
[09:35:31] <dbaupp> cmr: yup, the posts I remove regularly have 2 or 3 reports
[09:35:33] <nooblit> Well my goals are to make bots for playing single player games, ai and just make stuff for fun.
[09:35:47] *** Quits: Ms2ger|llvmdevroom (Ms2ger@3A6075EE.3EF83E22.692B9746.IP) (Ping timeout)
[09:35:50] <nooblit> I like computers and I just want to do it for fun.
[09:36:13] <FliPPeh> Talk about goals, anyone got any ideas for a pet project I could start in rust?
[09:36:16] <FliPPeh> I can't write another IRC bot
[09:36:16] <nooblit> But I don't want a langauge that is slow because bots and ai need  to be fast.
[09:36:20] <FliPPeh> Getting ridiculous
[09:36:39] <cmr> FliPPeh: write an Adventure clone.
[09:36:39] <adridu59> dbaupp: seems like I'm passing the wrong makefile variable
[09:36:39] *** Joins: p1start (rewi@moz-A082F561.adsl.xtra.co.nz)
[09:36:53] <cmr> (https://en.wikipedia.org/wiki/Adventure_%28Atari_2600%29)
[09:36:56] <nooblit> Not irc bot, a game bot with AI logic, for single player hobby
[09:37:25] <FliPPeh> cmr: As in text adventure game?
[09:37:28] *** Joins: gwty (gwtypc@2D0C08FA.3AF9C23B.45DA6411.IP)
[09:37:43] <cmr> nooblit: I think you overestimate the needs of most AI, and underestimate the performance of most languages.
[09:37:47] <nooblit> No, a game using hero engine
[09:37:48] <cmr> FliPPeh: https://en.wikipedia.org/wiki/Adventure_%28Atari_2600%29
[09:37:58] <cmr> ah hero?
[09:38:03] <cmr> can't really use rust with hero..
[09:38:11] <nooblit> Yeah HeroEngine is the name of the game engine.
[09:38:20] <nooblit> It use HeroScript and c++
[09:38:41] <nooblit> But I don't really want to learn c++ first if I can learn something like Rust
[09:38:54] <FliPPeh> Hmm, writing a game is a nice idea. Is there an SDL wrapper for rust?
[09:39:03] <cmr> FliPPeh: yes, but glfw is usually prefered.
[09:39:16] <cmr> well, if you're using SDL's 2d api that'd make sense.
[09:39:20] <Seb> So I'm seeing a super strange issue with FFI: the pointer I'm passing in is not getting received, instead a pointer for a sleeper_list::SleeperList::new is in it's place ... https://gist.github.com/SebastianEdwards/38585f9757f0451b543a
[09:39:25] <cmr> but there are many bindings in various states of completion :)
[09:39:29] <dbaupp> FliPPeh: https://github.com/mozilla/rust/wiki/Computer-Graphics-and-Game-Development
[09:39:35] <cmr> FliPPeh: #rust-gamdev
[09:39:36] <bjz> FliPPeh: we have a #rust-gamedev channel
[09:39:40] <bjz> xD
[09:39:42] <cmr> yeah that
[09:40:18] <dbaupp> Seb: I don't think passing CString is corrcet
[09:40:23] <dbaupp> Seb: it's not just a *char
[09:40:56] <dbaupp> Seb: you should be passing *c_char
[09:41:12] <dbaupp> Seb: which you can get with .with_ref(|ptr| ...), http://static.rust-lang.org/doc/master/std/c_str/struct.CString.html
[09:41:40] <dbaupp> Seb: (the definition of CString: http://static.rust-lang.org/doc/master/src/std/home/rustbuild/src/rust-buildbot/slave/doc/build/src/libstd/c_str.rs.html#100-103 )
[09:42:02] <dbaupp> I imagine the ABI consequence of being a struct, and the extra field/larger size will be causing the problems you're seeing
[09:42:42] *** Joins: Ms2ger|llvmdevroom (Ms2ger@3A6075EE.3EF83E22.692B9746.IP)
[09:43:27] <dbaupp> is there a reason we have .with_ref(|ptr| ...) rather than .as_ptr()?
[09:43:32] *** Ms2ger|llvmdevroom is now known as Ms2ger|K3corridor
[09:44:21] <cmr> dbaupp: as_ptr makes letting the pointer escape the actual lifetime even easier
[09:44:23] *** Quits: p1start (rewi@moz-A082F561.adsl.xtra.co.nz) (Ping timeout)
[09:44:31] *** Quits: hacker_sam (hacker_sam@C0FE520A.661C02A7.B0CE379A.IP) (Client exited)
[09:44:39] <Seb> dbaupp: Yep, you nailed it... Thanks so much!
[09:44:42] <cmr> We could probably be returning an &'a c_char
[09:44:52] *** Joins: hacker_sam (hacker_sam@C0FE520A.661C02A7.B0CE379A.IP)
[09:44:52] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[09:45:17] <cmr> but I think with_c_str also uses the small string optimization...
[09:45:19] <dbaupp> cmr: I just think having it disguised by a closure (a) encourages using .unwrap(), and (b) doesn't help super-much
[09:45:29] <cmr> dbaupp: yeah, I agree.
[09:45:38] <dbaupp> and (c) closures == :( when a non-closure solution is pretty much identical
[09:46:39] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[09:46:44] <nooblit> I know nobody can really know ths answer to this but if you had to guess, how long do you think it could be until Rust is at stable version?
[09:47:05] <dbaupp> adridu59: ping
[09:47:13] <dbaupp> nooblit: planned for before the end of the year
[09:47:19] <cmr> nooblit: 6-10 months.
[09:47:30] <cmr> nooblit: and that's just language stability, not library or ABI stability.
[09:47:34] <nooblit> wow that's allot faster than I thought.
[09:47:56] <dbaupp> I hope we delay the release if some desirable features aren't complete though
[09:48:01] *** Joins: jakerr (jakerr@moz-1095CD08.kanagawa.ocn.ne.jp)
[09:48:11] <dbaupp> rather than trying to stick to that schedule too forcefully
[09:48:19] <nooblit> Yeah, you don't want to rush it.
[09:48:30] *** Joins: alan_and_ (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net)
[09:48:33] <kimundi> nooblit: Doesn't mean its finished at that point though, just that its stable and all future changes will be backwars compatible
[09:48:49] <jakerr> Is there documentation about "proc" somewhere? I didn't see it in the manual or std.
[09:48:52] <adridu59> dbaupp
[09:48:59] <adridu59> dbaupp: the patch does not work
[09:49:19] <nooblit> why do all langs make itself backwards compatible before they are stable?
[09:49:36] <cmr> nooblit: to have a base to make it stable on..
[09:49:37] <adridu59> dbaupp: there are nested grep and xargs that pass arguments in a odd way, the `triple` var ends up being the name of a file
[09:49:51] <cmr> jakerr: http://smallcultfollowing.com/babysteps/blog/2013/10/10/fn-types-in-rust/
[09:49:59] <adridu59> dbaupp: but I was wondering, do we even need triple?
[09:50:03] <nooblit> But what if it needs to change before it's stable, and the change cannot be compatiable?
[09:50:17] <cmr> nooblit: we make those changes before 1.0, of course.
[09:50:21] <adridu59> dbaupp: we just want to check SNAP number which is the same for all platforms anyway
[09:50:33] <cmr> adridu59: don't depend on it being the same.
[09:50:48] <nooblit> Ok, so most library add ons will be done after 1.0 then?
[09:50:59] <adridu59> cmr: right, different hashes
[09:51:01] *** Quits: alan_and_ (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net) (Ping timeout)
[09:51:05] <cmr> nooblit: libraries won't be declared back compat/stable for 1.0
[09:51:16] *** Joins: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp)
[09:51:16] <cmr> at least not most of them
[09:51:49] <kimundi> nooblit: The problem is the is only a limited window of opportunity - if we spend the next five years perfecting the language and the libraries we will have lost the current momentum behind the language. 
[09:52:43] <kimundi> So instead we try to make it stable enough for 1.0 so that people can start to use a "finished" language, and then start improving on that in a way that will not invalidate the existing stuff
[09:52:45] <nooblit> I understand, the more people who use it the faster you can get the lang rolling.
[09:52:55] <adridu59> cmr: not a fan of forall
[09:52:58] *** Quits: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp) (Ping timeout)
[09:52:58] *** Joins: alonlevy (alon@C646CF2A.423BDA8F.692B9746.IP)
[09:53:09] <cmr> adridu59: see the ML thread.
[09:54:18] <nooblit> After 1.0 you should contact universities and sell it as learning to program the "safe" way or something along those lines. Get the students to help improve the lang but giving the projects to add to open source.
[09:55:08] <adridu59> cmr: so, is the triple checking important?
[09:55:11] *** Joins: jdm (jdm@moz-DB4A9C19.scl3.mozilla.com)
[09:55:12] *** ChanServ sets mode: +o jdm
[09:55:13] <kimundi> jakerr: Not sure if there a proper docs currently
[09:55:19] <kimundi> jakerr: What do you want to know?
[09:55:29] <adridu59> cmr: because with SNAP you just snap against the generic hash
[09:55:39] *** Ms2ger|K3corridor is now known as Ms2ger|omw
[09:55:40] <cmr> adridu59: ah good point
[09:55:43] <cmr> adridu59: should be fine.
[09:55:54] <adridu59> cmr: I'll see about removing it then
[09:55:58] <kimundi> nooblit: Heh, one university already does it, despite the language being unfinished :)
[09:56:16] <kimundi> nooblit: http://rust-class.org/
[09:56:20] *** Joins: tcreate (tcreate@moz-90E5C923.hsd1.ma.comcast.net)
[09:56:52] <bjz> dbaupp: what "desirable features" do you refer to?
[09:57:13] <nooblit> Well, I guess someone stole my idea :)
[09:57:22] *** Quits: Ms2ger|omw (Ms2ger@3A6075EE.3EF83E22.692B9746.IP) (Ping timeout)
[09:58:01] *** Quits: tcreate (tcreate@moz-90E5C923.hsd1.ma.comcast.net) (Ping timeout)
[09:58:26] *** Joins: steffenomak (steffenoma@moz-FB0A4BEB.student.uu.se)
[09:58:27] *** Joins: Ms2ger|llvmdevroom (Ms2ger@3A6075EE.3EF83E22.692B9746.IP)
[09:58:43] <kimundi> nooblit: In fact, students of the course did some major contributions to the compiler last release circle - its a win win situation ;)
[09:58:56] *** Joins: diverse (diverse@moz-ED94B8D.oc.oc.cox.net)
[09:59:19] *** Joins: jvoorhis (jvoorhis@moz-84A91726.ptld.qwest.net)
[09:59:37] <nooblit> kimundi , that's nice, the more students get on board the faster the lang will improve.
[09:59:55] <Luqman> kimundi: man, doing my os course now i kinda wish it was rust instead :P
[10:00:03] *** Quits: jakerr (jakerr@moz-1095CD08.kanagawa.ocn.ne.jp) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[10:00:06] <cmr> Luqman: I'm using Rust in my OS class :D
[10:00:18] <cmr> The deal is that I just need to walk my prof through the programs :p
[10:00:30] <Ms2ger|llvmdevroom> Heh
[10:00:33] <nooblit> Luqman, hey suggest it to your teacher, maybe they might take interest.
[10:00:39] <cmr> https://github.com/cmr/cs444-lab1, will be posting the rest of the stuff as it is assigned..
[10:00:40] <diverse> cmr: that's pretty cool
[10:00:45] <cmr> there's only 3 programming assignments :\
[10:00:55] <cmr> a shell, a FUSE filesystem, and something else that's silly.
[10:01:03] *** Quits: jvoorhis (jvoorhis@moz-84A91726.ptld.qwest.net) (Ping timeout)
[10:01:09] <eddyb> the filesystem sounds cool
[10:01:11] <cmr> pretty boring imo
[10:01:19] <eddyb> cmr: I've already seen a FUSE demo in rust, months ago
[10:01:22] <kimundi> Luqman: Heh, I had my OS course shortly before I discovered Rust - I wished I knew what I know today back then, then maybe I would've actually learned something useful from all those "write some bad C" assignments :P
[10:01:29] <cmr> eddyb: there's a pure-rust impl of the protocol.
[10:02:28] <eddyb> why are they called "OS courses"?
[10:02:36] <eddyb> unless you're cursing OSes
[10:02:45] <cmr> well the main course material is actually studying kernels etc.
[10:02:55] <cmr> it's just the programming assignments in mine that are lame.
[10:03:01] <eddyb> bleah
[10:03:02] *** Joins: jviereck (Adium@moz-56DDD13.dip0.t-ipconnect.de)
[10:03:19] *** Joins: squiddy (squiddy@moz-9D801C8C.adsl.alicedsl.de)
[10:04:03] *** Joins: dmac1 (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[10:04:21] <eddyb> I vaguely remember I tried to make my own OS in C, ended up copying pieces from tutorials and some old VGA thing that let me have 600x400 or something lame like that
[10:04:47] <cmr> heh
[10:04:54] <Luqman> we use a simple os (os161) that's missing various things like locks, processes, virtual memory that we have to implement
[10:05:10] *** Quits: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz) (Quit: Busying myself...)
[10:05:10] *** Joins: olivernn (olivernigh@moz-7CE0F8.access.mtnbusiness.co.za)
[10:05:11] <eddyb> then I played with Exclaim, wrote a (bad) FAT driver and a silly UI thing that looked like win95
[10:05:20] <FreeFull> I've written x86 ASM that would run directly on the hardware, but didn't try to write an OS
[10:05:30] <eddyb> (still C, ~12yo IIRC)
[10:05:46] *** Quits: dmac1 (Adium@moz-94F55C3.hfc.comcastbusiness.net) (Ping timeout)
[10:05:48] <eddyb> cmr: and then I graduated to C++ (in pedigree) and learned the joys of abstractions and polymorphism
[10:05:49] <FreeFull> http://wiki.osdev.org/Main_Page  Handy resource nowadays
[10:06:09] <Luqman> i just finished writing up a program to stress my locks & condition variables by feeding some cats and mice :P
[10:06:15] <FreeFull> eddyb: "Joys of abstraction and polymorphism" makes me think more of Haskell
[10:06:52] <nooblit> Anyone have an opinion on this?  in c++, is it the memory management or just design choices that make the lang difficult. I was thinking maybe it would be easy to learn if I only learn to program a subset of it the correct way and practice smart pointers?
[10:06:53] *** Joins: rca (rcatolino@D84C5999.F01B4DB2.520D6FA6.IP)
[10:06:55] <eddyb> FreeFull: I remember it when it was much simpler. I wonder if anyone finished the couple RealTek NIC pages that were there back in the day
[10:07:32] <eddyb> FreeFull: oh I didn't claim C++ was perfect - far from it, but wielded carefully, it proved more useful than C
[10:08:15] <eddyb> rust - you just take it and apply as much as you can over the burned area
[10:08:25] <FreeFull> If you do it extremely carefully, you can insert abstractions and polymorphism into C too
[10:08:30] <FreeFull> Rust is awesomeness
[10:08:53] <cmr> FreeFull: the unfortunate part about "polymorphism" in C is you basically end up requiring dynamic dispatch.
[10:09:00] <cmr> Language support can ease that.
[10:09:07] <FreeFull> Yeah, lots of void pointers
[10:09:08] <diverse> eddyb: and the compiler will tell you want you start to get burned. :P
[10:09:10] <nooblit> FreeFull , you're making me want to use Rust but I don't know how to program hello wrold in anything yet lol\
[10:09:22] <diverse> nooblit: use Rust now!
[10:09:22] <cmr> rusti: println!("hello world")
[10:09:24] -rusti- hello world
[10:09:24] -rusti- ()
[10:09:29] *** Joins: jakerr (jakerr@moz-1095CD08.kanagawa.ocn.ne.jp)
[10:09:52] *** Joins: mankyKitty (Instantbir@moz-F98AF264.rev.sfr.net)
[10:09:56] <eddyb> hello world is getting less and less interesting these days
[10:10:01] <nooblit> diverse, I would but there is no guide for begginers like me I think.
[10:10:17] <cmr> eddyb: good!
[10:10:45] <jakerr> kimundi: sorry, walked away after asking about proc earlier. I was just curious what it is technically. Is it a keyword, is it a fn?
[10:10:58] <eddyb> cmr: the shortest program that compiles is a good starting point IMO. some languages have an empty file, most compiled languages have the main function
[10:11:08] <diverse> nooblit: just play around with the tutorial and guides online and causally ask questions, you will gradually learn more and more.
[10:11:09] <eddyb> jakerr: it's a closure with a heap-allocated capture box
[10:11:24] <kimundi> jakerr: And it can only be called once
[10:11:32] <eddyb> jakerr: it moves all its captures in there and you can send it across tasks and whatnot. and you can only call it once
[10:11:45] <kimundi> rusti: let f = proc() 5; f()
[10:11:47] -rusti- 5
[10:12:10] <eddyb> nooblit: we have the official tutorial (more like a language feature guide) and there's a tutorial by someone else, maybe that's slightly better for you
[10:12:28] <eddyb> rustilite: fn main(){} // this is the shortest Rust program that compiles, nooblit
[10:12:29] *** Joins: mindcat (mindcat@926CFB1F.DC005319.857BDFA9.IP)
[10:12:31] <kimundi> rusti: let s = ~"abc"; let f = proc(x: ~str) s + x; f(~"xyz")
[10:12:32] -rusti- ~"abcxyz"
[10:12:52] <eddyb> nooblit: sadly, you can't see the result from rustilite because that program outputs nothing :P
[10:13:02] <kimundi> ^ this captures the variable s in a heap allocated box, and then the proc value can be send between tasks
[10:13:45] *** Quits: Ms2ger|llvmdevroom (Ms2ger@3A6075EE.3EF83E22.692B9746.IP) (Ping timeout)
[10:14:32] <eddyb> cmr: what I was going to say earlier - playing with an OS in uni is too mainstream, try doing it in middle school instead :))
[10:15:03] <fournm> eddyb: just saw that massive commit in this week in rust, wow congrats on that one
[10:15:14] <eddyb> fournm: which one?
[10:15:52] <cmr> eddyb: env ptr
[10:16:08] <cmr> eddyb: I was only messing around with python and batch scripting in middle school
[10:16:09] <adridu59> dbaupp,cmr: I have it working
[10:16:22] <cmr> adridu59: thanks for fixing my broken code <3
[10:16:33] * cmr swears he had tested it
[10:16:35] <eddyb> cmr: touched WINAPI once. ewww
[10:16:45] <fournm> Yeah, the env pointer one
[10:16:47] <cmr> Is there a typechecked scripting language? Oh right, go...
[10:17:02] *** Quits: alan_andrade (alan_andra@moz-7559582E.hsd1.ca.comcast.net) (Input/output error)
[10:17:28] *** Joins: alan_andrade (alan_andra@moz-7559582E.hsd1.ca.comcast.net)
[10:17:32] <jdm> typescript
[10:17:44] <jdm> dart-ish
[10:17:48] <benh> Does haskell running in ghci count?
[10:17:54] <mankyKitty> cmr: or the Shelly package for Haskell.. hawt scripting
[10:18:00] <cmr> yeah, typescript is really nice
[10:18:04] <eddyb> AS3, but as much as typescript
[10:18:09] <cmr> I wish they would finish the spec...
[10:18:12] *** Joins: arturo (Thunderbir@moz-E83B14F0.superkabel.de)
[10:18:22] <FreeFull> Haskell can be used for scripting
[10:18:25] <cmr> most of the really interesting parts aren't finished yet!
[10:18:28] <fournm> now that I have a desk again I really need to get into contributing
[10:18:32] <FreeFull> #!/usr/bin/runhaskell
[10:18:34] <eddyb> fournm: oh, yeah, my only commit larger than that was the one where I renamed thing in libsyntax from snake_case to UpperCamelCase :P
[10:18:47] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[10:18:57] <jakerr> kimundi: Thanks I was pretty clear on the usage but less so about the capture semantic. That made it clear. It seems a bit strange to me that the two closure syntaxes look so different, proc(x) ...; vs |x| ...;
[10:19:05] <diverse> eddyb: you did a great amount of clean up, it's impressive.
[10:19:16] *** Quits: alan_andrade (alan_andra@moz-7559582E.hsd1.ca.comcast.net) (Ping timeout)
[10:19:31] <benh> eddyb: you must be making bank from all these per-commit bitcoin rewards or whatever that was
[10:19:43] <cmr> you probably almost have a whole dime!
[10:19:45] <kimundi> jakerr: They used to be identical, but have been deliberately separated to indicated where heap allocations happen.
[10:20:33] <nooblit> HEY I found this cool site http://www.compileonline.com/ , Rust is on there, I can use this to learn Rust on correct or is that an older version?
[10:20:50] *** Quits: arturo (Thunderbir@moz-E83B14F0.superkabel.de) (Ping timeout)
[10:21:24] <eddyb> benh: heh, if I wanted money from doing this (which I kinda do), my only solution would getting a job at mozilla or some other company with interesting in Rust (samsung working on servo? I don't know any others)
[10:21:42] <cmr> nooblit: it's 0.9, which is relatively recent.
[10:21:48] <eddyb> cmr: how does this make sense? fp-elim has been re-disabled, but only if debuginfo generation is disabled.
[10:21:58] <nooblit> eddyb, you could do work on odesk freelance.
[10:22:03] <benh> eddyb: Presumably. I have zero experience with that though. :)
[10:22:17] <benh> nooblit: But who there is going to pay for rust *compiler* work?
[10:22:39] <nooblit> people who no nothing about programming and just want you to make something do something.
[10:22:46] <nooblit> *know
[10:22:54] <cmr> eddyb: we don't do frame pointer elimination when debuginfo is disabled.
[10:23:13] *** Quits: fournm (Aria@moz-ABB60BA0.austin.res.rr.com) (Quit: Leaving)
[10:23:17] <cmr> we used to never do it.
[10:23:18] <eddyb> cmr: but if debuginfo is disabled... ooh, you mean for the occasional backtrace?
[10:23:20] <cmr> but then we did.
[10:23:25] *** Quits: limeburst (me@247D1419.D73964AC.27A8748.IP) (Client exited)
[10:23:34] <benh> you could also start your own company that uses rust to make money somehow and then pay yourself to make rust better~
[10:23:35] <cmr> so now it's re-disabled, when debuginfo is also disabled.
[10:23:42] <cmr> eddyb: yes.
[10:23:44] <diverse> nooblit: should I assume you have no programming experience?
[10:23:50] <eddyb> nooblit: I've done freelancing since 6th grade or so. that's how I've got my shiny new laptop. well, it was shiny and new three years ago :/
[10:24:16] <nooblit> eddyb, I do not know any language yet.
[10:24:37] <nooblit> Well I speak English but I'm not good at that either lol.
[10:24:52] <cmr> nooblit: I suggest you stop thinking about what to get started with and just get started with *something*
[10:25:05] <diverse> I second cmr
[10:25:23] <diverse> nooblit: programming is best learned by doing it.
[10:25:33] *** Quits: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net) (Quit: dave1629)
[10:25:38] <nooblit> It's just me, I'm picky, I don't want some outdated jive, I want a cool lang that is better.
[10:25:51] <eddyb> benh: that would require some money to start with. I did have some plans during the years, but I've never set any one of them fully in motion :(
[10:26:08] <eddyb> cmr: do we still have @Trait?
[10:26:19] <nooblit> People scare me from learing c++ cuz they say its hard and people who do c++ say higher lvl lang are too slow so idk what to learn yet.
[10:26:43] <benh> nooblit: There's lots of interesting programs people can write for which higher level languages aren't too slow
[10:26:50] <jakerr> kimundi: let procedure = proc |x| {...};   let closure = |x| {...}; would be better imho, since now proc(x) looks kind of like a fn call, and I'd prefer if the parameter list for the closure types looked the same. Anyhow it's just an aesthetic issue, not a big deal.
[10:26:52] <cmr> rusti: let x: @Writer = File::open(Path::new("whatever")) as @riter;
[10:26:58] -rusti- pastebinned 14 lines of output: http://ix.io/agO
[10:27:09] *** Joins: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net)
[10:27:10] <cmr> eddyb: nope
[10:27:12] <eddyb> @rita
[10:27:14] *** Quits: KindOne (KindOne@FF63190B.D40F8E6E.EC6A1518.IP) (Ping timeout)
[10:27:15] <cmr> eddyb: it was the first to go.
[10:27:18] <diverse> nooblit: tell me, what language interested you the most right now?
[10:27:25] <eddyb> cmr: wait, what?
[10:27:31] <cmr> nooblit: anything is better than nothing...
[10:27:38] <eddyb> when, my take glue removal was... days ago
[10:27:50] <cmr> nooblit: anything you learn is going to basically be universally applicably.
[10:27:52] <kimundi> nooblit: Higer level languages can be _slower_ than C++, but they are not _slow_. :) For most situations, the difference doesn'T matter. :)
[10:27:53] <cmr> *applicable
[10:27:54] <benh> nooblit: and languages like javascript aren't going anywhere, slow or not
[10:27:55] <cmr> eddyb: hm?
[10:27:57] <nooblit> Well, I like Rust and D
[10:28:26] <diverse> nooblit: then there is beginning, you know where to start.
[10:28:42] <nooblit> I was going to learn go but people say it doesn't have generics. I don't know what generics are but people seem to think it's a big deal.
[10:28:47] *** Quits: refold (gman@moz-42D68426.a258.priv.bahnhof.se) (Quit: leaving)
[10:28:49] <cmr> lol
[10:28:52] <patpat> haha
[10:28:53] <cmr> nooblit: just learn something :)
[10:28:54] <kimundi> jakerr: Oh, I share that sentiment actually :)
[10:28:59] <bjz> nooblit: just make sure you don't get yourself stuck in the OO/imperative mode of thinking
[10:29:03] <flaper87> haha
[10:29:11] <eddyb> cmr: ty::ty_trait(_, _, ty::BoxTraitStore, _, _)
[10:29:14] <cmr> nooblit: nothing is perfect, everything is flawwed, there's always something better.
[10:29:24] <benh> nooblit: learn go then :)
[10:29:43] <benh> nooblit: There's lots of people who are enthusiastic about go, that's a big plus when learning something
[10:29:47] <Tobba> wait, go doesnt have generics?
[10:29:48] <bjz> nooblit: generics are good if you have a static type system, it means you can write something that works across lots of different types
[10:29:53] <cmr> Tobba: nope.
[10:29:56] <bjz> Tobba: no it does not
[10:30:08] *** Joins: limeburst (me@247D1419.D73964AC.27A8748.IP)
[10:30:13] <nooblit> Well, I wanted to start of learning Go to make a simple GUI that is a aimbot for a single player game but I couldn't find any GUI stuff for Go and I don't know anything about servers.
[10:30:19] <eddyb> Tobba: neither does Java, technically
[10:30:20] <bjz> nooblit: if you are using a dynamically typed language generics don't matter
[10:30:37] <Tobba> java has some form of generics which are terrible and everyone hates afaik
[10:30:44] <eddyb> Tobba: it's fake
[10:30:54] <cmr> Tobba: they compile into regular object types :\
[10:30:56] <eddyb> like using only trait objects in Rust
[10:30:58] *** Quits: quasisphere (btw@DC685DC2.94302614.1D0D91FF.IP) (Quit: WeeChat 0.4.2)
[10:30:59] <cmr> for bytecode compatibility.
[10:31:08] <cmr> it's pretty gross.
[10:31:13] <bjz> Tobba: you have to use boxed types :[
[10:31:26] *** Joins: KindOne (KindOne@moz-BF98147F.dynamic.ip.windstream.net)
[10:31:28] <Tobba> oh god
[10:31:31] <eddyb> Tobba: imagine writing fn foo<R: Reader>(r: &R); and getting fn foo(r: &Reader);
[10:31:35] <kimundi> Well java _has_ generics - they are just implemented with type erasure
[10:31:39] <benh> I've been idly reading the java spec and the type theory machinery behind their limited generics is more involved tha "compiles into regular object types" makes it sound
[10:31:58] <bjz> Tobba: you can't have ArrayList<int>, you need ArrayList<Integer>
[10:32:14] <benh> It's not monomorphized, but eh
[10:32:27] <cmr> benh: sure, the typechecking etc is more complicated.
[10:32:39] <cmr> eddyb: nvm, @Trait still exists, was confused with something else.
[10:32:55] <Tobba> though I guess it fits the agenda of the JVM being stupidely easy to implement and java running on everything
[10:33:21] *** Quits: jdm (jdm@moz-DB4A9C19.scl3.mozilla.com) (Quit: Lost terminal)
[10:33:36] <benh> Those List<? extends Foo> types are kinda weird too ;)
[10:33:48] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[10:34:14] *** Quits: rca (rcatolino@D84C5999.F01B4DB2.520D6FA6.IP) (Ping timeout)
[10:34:48] <Tobba> I was gonna look up if google had made dalvik not suck yet, apparently they're replacing it with ART
[10:35:08] <Tobba> now lets see if my phones battery can last longer than a day or two, or better yet, if the GPU can stop crashing
[10:35:35] <benh> maybe they should replace it with go 8)
[10:35:39] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[10:35:54] <mankyKitty> I really didn't expect messing with a vec of enum values would bite me this hard... ><
[10:36:08] * mankyKitty goes back to re-re-re-read the ownership tutorial
[10:40:34] <nooblit> I have an idea, we could all pitch in like 15 dollars to Mozilla like on kick starter and they could use that money to hire cheap programmers  on oOesk by outscoring to India and Philippines. They could buy 100s of programmers real cheap with the amount we could raise if they outsourced it to there on odesk, they could help yall get stuff done. Bad idea?     
[10:40:52] <eddyb> "cheap programmers" lol
[10:40:58] <mankyKitty> ...
[10:41:02] <Tobba> do it
[10:41:07] <diverse> heh
[10:41:10] <Tobba> the results would be so hilarious it'd be worth it
[10:41:23] *** Quits: aruniiird (aruniiird@28876D92.F24A7F1B.260B031E.IP) (Ping timeout)
[10:41:37] <nooblit> Well, I hired them to do some webpage stuff, they work cheap.
[10:41:48] <Tobba> just make sure they only get access to a copy of the repo, they'd probably end up irrepairably breaking the repo by rewriting history
[10:42:03] *** Joins: arturo (Thunderbir@moz-E83B14F0.superkabel.de)
[10:42:59] <diverse> nooblit: just worry about learning what you want to learn
[10:43:09] <nooblit> Someone at Mozilla would have to run the kickstarter though,  
[10:43:20] <Tobba> nooblit: actually wait you're serious?
[10:43:24] <Tobba> cue laughtrack
[10:43:28] <diverse> Tobba: he is
[10:43:32] <Tobba> jesus fuck
[10:43:37] <diverse> yeah, i know
[10:43:39] *** Joins: rca (rcatolino@D84C5999.F01B4DB2.520D6FA6.IP)
[10:44:13] <nooblit> Well, that is the idea of hired help?
[10:44:53] <nooblit> If it's open source, you could raise allot of money just pitching in like 5$
[10:45:03] *** Joins: victorporof_ (victorporo@53EBB099.7C27E871.79933D60.IP)
[10:45:16] <Tobba> "cheap programmers" á la India tends to end in one hell of a mess
[10:45:25] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[10:45:40] <nooblit> Well, wouldn't someone at mozzila oversee what goes in the repository ?
[10:45:44] *** Quits: olivernn (olivernigh@moz-7CE0F8.access.mtnbusiness.co.za) (Ping timeout)
[10:46:05] *** Quits: victorporof (victorporo@53EBB099.7C27E871.79933D60.IP) (Ping timeout)
[10:46:39] <nooblit> Well, nvm then lol, guess it's dumb idea, I'm not experienced in these matters. 
[10:47:09] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[10:47:27] *** Joins: nkoep (nik@moz-DC05FB0B.pool.mediaways.net)
[10:47:38] <Tobba> its basicaly russian roulette since you can end up with actually decent programmers
[10:48:06] <nooblit> Ofcoures you don't have to hire cheap or outsrouce, we could hire a professional firm with a good reputation. 
[10:48:11] <diverse> how should I say this, we wouldn't want to hire just any random programmer, we would perfer to get people with high expertise in one area, like implementing a great package manager that will supplement rustpkg as it's being remove atm.
[10:48:15] <Tobba> except all chambers are loaded but the bullets and theres the off chance the bullet might fire backwards
[10:48:45] <Tobba> okay that sentance came out mangled, anyways
[10:49:37] <nooblit> Hire a good US based firm with a good reputation.
[10:49:51] <Tobba> such as... mozilla?
[10:49:54] <eddyb> hire me
[10:49:58] <Tobba> ^
[10:50:42] <Tobba> that also came out a bit wrong actually, but mozilla are already paying a few guys to work on rust AFAIK
[10:50:53] <nooblit> Well, my idea is to supplement Mozilla, to move things along faster, we already have Mozilla .
[10:50:56] *** Joins: Matthias247 (Miranda@moz-BDD35EC0.hsi5.kabel-badenwuerttemberg.de)
[10:50:59] *** Joins: alan_andrade (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net)
[10:51:44] <FliPPeh> You want lazy programmers, not cheap programmers
[10:52:25] <nooblit> Well they would prob hire a firm to do it if they did anything like that.
[10:54:14] *** Quits: alan_andrade (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net) (Ping timeout)
[10:54:45] *** Joins: eibwen (kvirc@moz-A786C6BF.dip0.t-ipconnect.de)
[10:55:13] <doomlord_> mozilla has about 6 people on it full time? whats the ratio of full time paid to community input
[10:55:25] <doomlord_> [i know focussed input counts for a lot more]
[10:56:04] <nooblit> A while back I  seen some company selling some kind of fast real time garbage collector but I don't remember reading if it was for some specific lang. I'm just thinking that there is allot of ways we could get Rust improved that other open source communities never seem to think about.
[10:57:02] *** Quits: devbug (quassel@23AC5F12.9D950176.3655BBF5.IP) (Input/output error)
[10:57:15] *** Joins: tcreate (tcreate@moz-90E5C923.hsd1.ma.comcast.net)
[10:57:15] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[10:58:03] <eddyb> who's Jurily on IRC?
[10:58:20] <Matthias247> sometimes less is more
[10:58:27] <jakerr> Can I print the memory address pointed to by a ~ptr in an unsafe block. If so how?
[10:58:49] *** Quits: dapz (textual@moz-F958911.hsd1.ca.comcast.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[10:58:57] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[10:59:05] <jakerr> to_unsafe_ptr maybe?
[10:59:26] <Matthias247> but this is something the management at my company also doesn't understand. They just contract more and more people/companys - and the problems get even  worse
[11:00:03] *** Joins: jvoorhis (jvoorhis@moz-84A91726.ptld.qwest.net)
[11:00:07] <Matthias247> jakerr: yes, to unsafe poiinter, then cast to raw pointer, and if the print doesn't accept that cast to uint
[11:00:50] <Matthias247> ehm, to_unsafe_ptr is already raw ;)
[11:01:13] *** Joins: nawfel (Mibbit@3E12675.5E872927.DFAB1F33.IP)
[11:01:32] *** Quits: onelson (owen@18CF7301.95770028.5B6BFE7D.IP) (Ping timeout)
[11:01:46] *** Quits: jvoorhis (jvoorhis@moz-84A91726.ptld.qwest.net) (Ping timeout)
[11:01:51] <nooblit> Matthias247 , I think i know where you're coming from, sometimes what you need is quality and cohesion not just trying to throw money at a problem. 
[11:01:51] *** Joins: Ms2ger (Ms2ger@961DA5D0.EA0ABEA5.692B9746.IP)
[11:02:03] <Matthias247> exactly
[11:02:27] <jakerr> Thanks Matthias247 it works :)
[11:02:35] <jakerr> let a = ~10; unsafe { println!("~10 ptr is {:?}", ptr::to_unsafe_ptr(a)); }
[11:02:36] <nawfel> hello ? what is the version of rusti
[11:02:48] <jakerr> gives ~10 ptr is (0x7fc9115024c0 as *())
[11:02:51] <eddyb> rusti: version
[11:02:52] -rusti- "rustc 0.10-pre (4cd555d 2014-01-24 03:28:15 -0500)"
[11:03:02] <eddyb> nawfel: that's how you check ^^
[11:03:10] <nawfel> thx :)
[11:03:29] *** Ms2ger is now known as Ms2ger|janson
[11:03:45] <eddyb> jakerr: that's an odd heap address if I ever saw one. I guess x64 can end up with those
[11:04:00] <Matthias247> jakerr: with {:?} it's generelly easy because that prints everything (or crashes). if you wanted ith without the "as *()" you might need an additional cast
[11:04:29] *** Joins: dmac1 (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[11:04:30] <eddyb> Matthias247: what do you mean?
[11:04:34] <Matthias247> eddyb: would be hard to get this on x32 ;)
[11:05:00] <FliPPeh> Is there some predefined constant in the rust compiler that allows you to check its version, like clang can do with __clang__{major,minor,patchlevel}__?
[11:05:03] <jakerr> Cool I just wanted to use it to understand Rc type. The docs are a bit sparse still :)
[11:05:14] <nawfel> can i use rusti elsewhere just not to distract you ?
[11:05:15] <eddyb> rusti: let a = ~10; println!("~10 ptr is {:p}", unsafe{ptr::to_unsafe_ptr(a)})
[11:05:29] <eddyb> nawfel: a private query
[11:05:45] -rusti- pastebinned 23 lines of output: http://ix.io/agP
[11:05:49] <Matthias247> eddyb: you mean about the crash?
[11:06:03] <eddyb> the cast
[11:06:06] <nawfel> eddyb: how ?
[11:06:18] <eddyb> nawfel: /query rusti
[11:06:23] <eddyb> rusti: let a = ~10; println!("~10 ptr is {:p}", unsafe{::std::ptr::to_unsafe_ptr(a)})
[11:06:24] -rusti- <anon>:10:50: 10:86 warning: unnecessary `unsafe` block, #[warn(unused_unsafe)] on by default
[11:06:24] -rusti- <anon>:10         let a = ~10; println!("~10 ptr is {:p}", unsafe{::std::ptr::to_unsafe_ptr(a)})
[11:06:24] -rusti-                                                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[11:06:24] -rusti- ~10 ptr is 0x7f0328000e20
[11:06:25] -rusti- ()
[11:06:30] <Matthias247> eddyb: ah, because I didn't knew {:p}.
[11:06:35] *** Quits: barosl (barosl@3DE683B6.E551553C.7544CABF.IP) (Quit: 랜덤은 쇠퇴했습니다.)
[11:06:50] <eddyb> rusti: let a = ~10; println!("~10 ptr is {:p}", &*a)
[11:06:59] -rusti- pastebinned 8 lines of output: http://ix.io/agQ
[11:07:58] <FreeFull> rusti compiles to 32-bit executables, apparently
[11:08:13] <eddyb> FreeFull: no it doesn't
[11:08:33] <eddyb> those are 12 hex nibbles
[11:08:34] <FliPPeh> That is obviously a 64 bit pointer
[11:08:42] <FliPPeh> :d
[11:10:26] *** Quits: dmac1 (Adium@moz-94F55C3.hfc.comcastbusiness.net) (Ping timeout)
[11:11:01] <nooblit> Question about GC in Rust, would it be possible to have soft realtime GC on thread local heaps. Asynchronous message passing between threads, so no "stop the world" mechanism is necessary?
[11:11:05] <FreeFull> eddyb: You're right
[11:11:21] <FreeFull> 48-bit executables!
[11:11:27] *** Joins: rca_ (rcatolino@moz-6D1B2709.adsl.proxad.net)
[11:11:31] * eddyb rolls eyes
[11:11:34] <FreeFull> =P
[11:11:53] *** Quits: LinearInterpol (RJones@moz-E6F82C3A.maine.res.rr.com) (Ping timeout)
[11:12:07] *** Quits: rca (rcatolino@D84C5999.F01B4DB2.520D6FA6.IP) (Ping timeout)
[11:12:18] <nooblit> I read about a GC like that on something called nimrod, it sounded efficient.
[11:12:38] <eddyb> nooblit: you can comment about it on one of our GC-related issues
[11:13:03] <eddyb> nooblit: or talk to pnkfelix
[11:13:04] <FliPPeh> As far as I understand, the GC in Rust isn't an integral part at all
[11:13:23] <Matthias247> nooblit: it is planned that the GC is only thread-local
[11:13:26] <eddyb> FliPPeh: we want one in a library and just enough language support so it's not awful
[11:13:26] <nooblit> Yeah it's in the library, but it can still do that with hooks right?
[11:13:32] <Matthias247> or better said task-local
[11:13:49] <nooblit> message passing
[11:15:17] *** Quits: awidegreen (awidegreen@moz-9FADBE94.a357.priv.bahnhof.se) (Ping timeout)
[11:16:08] *** Quits: kvanb (kvanb@moz-C6EC06B9.lnse3.lon.bigpond.net.au) (Ping timeout)
[11:17:22] <nooblit> I will suggest it to pnkfelix then, maybe it can work like that from the library. 
[11:17:28] <nawfel> can i give rusti a pastbin ?
[11:17:42] <Matthias247> message passing is already there and currently asynchronous. But several people don't like the asynchronous
[11:18:01] <eddyb> nawfel: not really
[11:18:17] <nooblit> Doesn't asynchronous make it so that it doesn't cause the program to freeze waiting for GC?
[11:19:32] <Matthias247> that discussions didn't take the GC into account. However it doesn't matter, since you wouldn't be able to send GCed objects anyway
[11:19:47] <Matthias247> because the GC is task-only
[11:19:50] <nawfel> eddyb: then, when can i post a feature request ? here https://github.com/mozilla/rust/issues ?
[11:20:05] <eddyb> nawfel: rusti is just an IRC bot
[11:20:17] <eddyb> nawfel: it's strcat unofficial project
[11:20:20] <eddyb> *strcat's
[11:21:44] *** Quits: Ms2ger|janson (Ms2ger@961DA5D0.EA0ABEA5.692B9746.IP) (Ping timeout)
[11:21:53] <nawfel> ping strcat
[11:22:13] <diverse> nawfel: strcat is not here
[11:22:15] <eddyb> nawfel: he's not around right now
[11:22:31] <nooblit> Would it be possible to copy the GC of  -> http://nimrod-lang.org/ and make it work from the library? Sorry if my question sounds dumb, I'm really new to all of this but I like learning about all this and want to help even though I don't know much at this time.
[11:22:31] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Connection reset by peer)
[11:23:36] *** Quits: rca_ (rcatolino@moz-6D1B2709.adsl.proxad.net) (Ping timeout)
[11:24:35] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[11:24:35] <nooblit> i
[11:26:26] <skrylar> i should probably play around with nimrod
[11:26:37] *** jorendorff_away is now known as jorendorff
[11:26:49] <skrylar> i tend not to touch anything that calls emitting C code "compiling", because that tends to be a saddeningly slow compile-link-run cycle
[11:27:19] <FliPPeh> Haskell compiles pretty quickly
[11:27:22] *** jorendorff is now known as jorendorff_away
[11:27:35] *** Quits: tcreate (tcreate@moz-90E5C923.hsd1.ma.comcast.net) (Ping timeout)
[11:27:47] *** Quits: mankyKitty (Instantbir@moz-F98AF264.rev.sfr.net) (Quit: mankyKitty)
[11:27:51] <nooblit> For me, i don't care about how long it  takes to compile, it can take a week for all I care, I just want to to RUN fast lol
[11:28:02] <skrylar> eh, i've watched a cabal build cycle for pandoc from scratch
[11:28:03] <FliPPeh> Then you'll LOVE C++
[11:28:12] <diverse> heh
[11:28:13] <nooblit> lol
[11:28:15] *** Joins: rca (rcatolino@moz-997DEF82.adsl.proxad.net)
[11:28:22] <skrylar> I quite like Pascal and D1's really short compile times
[11:28:24] <FliPPeh> Especially if you use boost
[11:28:39] <nooblit> I think they are on D2 now?
[11:28:47] <skrylar> yes, but D2 is crap IMO
[11:28:48] *** Joins: jsonnull (Thunderbir@26F61E6.CFD9471D.494A0F8B.IP)
[11:28:49] <FliPPeh> D2 is quite a bit slower
[11:28:54] <nooblit> Ah
[11:28:58] <FliPPeh> Although I do like their metaprogramming
[11:29:01] <skrylar> Its been infected with stupid Java-isms :\
[11:29:08] <FliPPeh> Like querying structure members and emitting code at compile time
[11:29:13] <FliPPeh> I wish rust had that
[11:29:20] <skrylar> supposedly its going to
[11:29:31] <skrylar> I will admit I did choose rust over nimrod simply because rust direct compiles <_<
[11:29:42] <FliPPeh> Also Nimrod sounds silly
[11:29:57] <Matthias247> but is easier to google ;)
[11:30:08] <nooblit> Lol, i thought so but it's really a clever name for a language if you think about the meaning.
[11:30:17] <FliPPeh> But Rustlang gets automatic popularity with people picking up Rust the game
[11:30:19] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Ping timeout)
[11:30:31] *** Joins: jur (Mibbit@moz-2F3F58B9.speed.planet.nl)
[11:30:58] <skrylar> nah, it gets google bombed :)
[11:31:04] <Matthias247> i think that makes it even worse. search results will have even more false results
[11:31:31] <nooblit> There is another language that is like Nimrod from what I can tell called Felix.
[11:31:35] <jur> Hi there, I met someone from the #rust team at POPL 2014, and we talked at length about the type system of Rust and the type error diagnosis. Is he maybe around?
[11:31:54] <skrylar> i wonder if nimrod has a full utf lib
[11:32:16] <skrylar> that is another reason i like rust; i hated dealing with massive utf support libs and maintaining my light C one :|
[11:32:17] <FliPPeh> Pff UTF
[11:32:19] <FliPPeh> ASCII for laif
[11:32:20] <nooblit> skrylar have you looked at Felix ?
[11:32:46] <skrylar> i seem to remember seeing a mostly white page with felix the cat on it, and deciding it wasn't a very well supported language :\
[11:33:41] <nooblit> Yeah, I haven't looked at it in a long time but just thought you may be interested in it 
[11:34:11] *** Joins: alexherbo2 (alexherbo2@moz-5686FDD1.w83-199.abo.wanadoo.fr)
[11:34:26] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[11:34:33] *** Joins: mgottschlag (quassel@moz-8A0EB40C.cust.bluewin.ch)
[11:35:25] <Luqman> jur: what was his name?
[11:35:57] <nooblit> Hey, since I want to learn Rust, what is the next closest language to learn like Rust that has newbie programmer tutorials or videos for first time programmers. Something that will make Rust easier to understand? 
[11:35:58] *** Quits: dmac (dmac@moz-94F55C3.hfc.comcastbusiness.net) (Quit: Leaving)
[11:36:10] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[11:36:53] <Matthias247> hard to say. For the whole memory management and basic stuff: Learn C
[11:36:54] <nooblit> I don't want something way different that teaches bad habits
[11:37:05] <eddyb> nooblit: then just go ahead and learn rust
[11:37:14] <eddyb> nooblit: jump feet first in cold water
[11:37:16] <Matthias247> but a lot of higher level stuff is taken from the functional world
[11:37:29] <Matthias247> eddybs advice is probably the best
[11:37:49] <nooblit> I can try to learn Rust but i do not understand any terminology, it's like speaking Russian lol 
[11:37:53] *** Joins: Ms2ger (Ms2ger@961DA5D0.EA0ABEA5.692B9746.IP)
[11:37:57] *** Joins: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net)
[11:38:05] <eddyb> nooblit: you don't need terminology nor theory, just code
[11:38:05] <Matthias247> although I don't consider rust and easy language to lern
[11:38:22] *** Ms2ger is now known as Ms2ger|janson
[11:38:34] <eddyb> Matthias247: I would argue it's a much better language to start in than the C/C++ blend I've had to deal with in highschool
[11:38:39] <jsonnull> You pick up terminology as you go, the important thing is to have some basic understand to build your knowledge upon. Since you already want to learn rust, that may as well be it.
[11:38:39] *** Quits: alonlevy (alon@C646CF2A.423BDA8F.692B9746.IP) (Ping timeout)
[11:38:50] <nooblit> Well, Rust is more powerful than say a scripting lang, Rust is more in the league of c++ correct?
[11:38:55] <jsonnull> Correct.
[11:39:31] <eddyb> nooblit: Rust can't easily do some of the dynamic things you'd have in a scripting language. but it can be way more performant
[11:39:55] <Matthias247> eddyb: we started with pascal :)
[11:39:59] <nooblit> I like performance, just the way I am.
[11:40:09] <eddyb> some things are easier/nicer than in C++, while some C++ feature have no real equivalents (HKT for example. I didn't even know C++ had it)
[11:40:09] <Matthias247> everyone likes that
[11:40:12] <mgottschlag> hey, I am trying to understand  Rust (have not yet written any code) but keep finding constructs which do not seem to be explained in the reference - anybody can explain line 47 here to me, especially the "**"? http://static.rust-lang.org/doc/master/src/std/home/rustbuild/src/rust-buildbot/slave/doc/build/src/libstd/clone.rs.html#27-42
[11:40:31] <nooblit> HKT ?
[11:40:37] <Ms2ger|janson> C++ has higher-kinded types?
[11:40:46] *** Joins: rca_ (rcatolino@moz-A5AE67A5.adsl.proxad.net)
[11:41:02] <nooblit> what is higher kinded types ? 
[11:41:13] <eddyb> nooblit: do you know generics/templates?
[11:41:21] *** Quits: rca_ (rcatolino@moz-A5AE67A5.adsl.proxad.net) (Quit: leaving)
[11:41:22] *** Quits: rca (rcatolino@moz-997DEF82.adsl.proxad.net) (Ping timeout)
[11:41:27] <mgottschlag> is "**" equal to "dereference as far as possible"?
[11:41:34] <nooblit> I think generics is some way to abstract functions?
[11:41:36] <eddyb> mgottschlag: nope
[11:41:44] <eddyb> nooblit: and types/traits
[11:41:59] <Matthias247> mgottschlag: it's do it 2 times
[11:42:17] <mgottschlag> okay, but &self can only be dereferenced once, right?
[11:42:22] <mgottschlag> ah, nvm
[11:42:24] <eddyb> mgottschlag: depends on the type
[11:42:37] <dbaupp> nooblit: the plan is for completely thread-local GC
[11:42:57] <mgottschlag> I see, the type of self was ~T, so &self is &~T -.-
[11:42:59] <dbaupp> nooblit: and the nimrod GC is non-tracing, and so not so desirable
[11:43:22] <nooblit> Tracing is faster right?
[11:43:37] *** Ms2ger|janson is now known as Ms2ger|omw
[11:43:40] *** Joins: doener (doener@moz-C68F600D.unity-media.net)
[11:44:10] <dbaupp> bjz: desirable things things like DST, gc, unboxed closures etc. and making sure they all work together, iron out weird interactions
[11:44:15] <eddyb> nooblit: struct ADumbPair<T, U> {left: T, right: U} gives you a structural type with two fields, each of which gets its type from one of the generic type params <T, U> - so you can have ADumbPair<bool, int> or ADumbPair<~str, ~str> or whatever combination you want
[11:44:34] <dbaupp> bjz: I'm concerned that we won't be able to bolt on some features which are being delayed as "backward compatible"
[11:44:41] <dbaupp> bjz: (especially unboxed closures)
[11:45:09] <nooblit> Ok so I can use 2 different data types in the same argument or function is what you're saing?
[11:45:09] <dbaupp> nooblit: tracing isn't necessarily faster, but it allows nicer behaviour
[11:45:20] *** Quits: Ms2ger|omw (Ms2ger@961DA5D0.EA0ABEA5.692B9746.IP) (Ping timeout)
[11:45:22] <dbaupp> (such as moving memory around to reduce the total memory use.)
[11:45:58] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[11:46:05] <nooblit> dbaupp I see, so it's more efficient. 
[11:46:09] <eddyb> nooblit: well... the "template" name from C++ might make it clearer. you write the type/trait/function once and it can be used with any different types
[11:46:30] <eddyb> nooblit: HKT lets you have a generic type parameter be generic itself, so you can do T<U>, if T were a HKT, and other things, some useful, some silly
[11:46:35] *** Quits: jur (Mibbit@moz-2F3F58B9.speed.planet.nl) (Quit: http://www.mibbit.com ajax IRC Client)
[11:46:49] <dbaupp> nooblit: it's hard to compare them directly, they have different trade-offs; but yeah, I believe tracing is more desirable (it's certainly what Rust is working toward)
[11:47:34] <nooblit> O i think i understand, I did a little programming with Scala and learned how to make functions and arrys and you had to tell if something was a int or boolean and a function was something you could use again.
[11:47:40] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[11:48:53] <nooblit> Well the function saved you from having to write the logic over and over, you could just name the function to whatever you where doing.
[11:49:20] <eddyb> it's not just about functions
[11:50:50] <Matthias247> generics are about making functions that work not only with one type but with a set of types
[11:51:54] <nooblit> So if you write it something like, if it's a boolean do this and if it's a int do this, and if it's this type work this way or work with more than one at the same time.
[11:51:57] *** Joins: ricepuddin (graham@moz-7D68765A.cable.virginm.net)
[11:52:17] <Matthias247> and I don't think it's necessary to reason about something like HKT when you start programming
[11:52:39] <eddyb> nooblit: that reminds me of D's static if's, but Rust doesn't really work like that
[11:52:56] <Matthias247> eddyb: more about c++ template specialization :)
[11:53:12] <eddyb> nooblit: it's just "this code works with any type" or, after you learn traits "this code works with any type that implements this trait"
[11:53:21] *** victorporof_ is now known as victorporof_|away
[11:53:22] <Matthias247> nooblit: no, you do always the same operation. But it would be implemented differnetly for the types
[11:54:05] *** Joins: darthdeus (darthdeus@EEC5B4DB.3B96A244.4E88690D.IP)
[11:54:15] *** Quits: KindOne (KindOne@moz-BF98147F.dynamic.ip.windstream.net) (Ping timeout)
[11:54:18] <nooblit> Well, the concept sounds simple enough, I'm sure I'll be able to do this once I start practicing some real code.
[11:54:44] *** Joins: alan_andrade (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net)
[11:54:56] <nooblit> I'm not doing this for work or anything, I just want to do it for fun.
[11:55:06] <Matthias247> e.g. you can make a function that adds two types like fn<T> add(a:T, b:T) -> T { return a+b; }. And this would work for all types that are addable, like ints, floats, etc.
[11:55:19] <eddyb> that's wrong syntax and it won't work
[11:55:23] <Matthias247> I know
[11:55:46] <nawfel> where can i find this irc's history
[11:55:47] <eddyb> fn add<T: Add<T, T>>(a: T, b: T) -> T { a+b }
[11:55:51] <Matthias247> but it won't be easier to understand with correct syntax
[11:55:55] <eddyb> nawfel: "logs" in the topic
[11:56:01] <eddyb> Matthias247: hehe
[11:56:04] <nawfel> logs
[11:56:15] <nawfel> "logs"
[11:56:46] <Matthias247> in c++ the wrong syntax works :)
[11:56:58] <eddyb> nawfel: I mean, this link: https://botbot.me/mozilla/rust
[11:57:03] <nawfel> ok!! i have found it 
[11:57:10] <nawfel> thx eddyb 
[11:57:15] <nooblit> Well I understand int's,floats, but I don't know how to read the syntax yet like -> ect. Only language I ever started with was Scala and didn't get very far because the tutorial atomic was out of date.
[11:57:16] *** Quits: alan_andrade (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net) (Ping timeout)
[11:57:52] <eddyb> nooblit: -> is for the return type of a function
[11:58:04] <nawfel> good bye, you are awesome guys
[11:58:08] *** Quits: nawfel (Mibbit@3E12675.5E872927.DFAB1F33.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[11:58:30] *** Joins: KindOne (KindOne@moz-BF98147F.dynamic.ip.windstream.net)
[11:58:59] <nooblit> eddyb so -> T { a+b } is Return T and T is a+b
[11:59:07] <eddyb> nooblit: this definition fn add<T: Add<T, T>>(a: T, b: T) -> T { a+b } basically reads: this is a function, named "add", that is defined for all types T that can be added with another value of type T to produce a result of type T (so, like, adding two integers to produce a third integers)
[11:59:34] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[11:59:36] <eddyb> it takes two arguments, a and b, both of type T and it returns type T. the return value is the sum of its two arguments
[12:00:28] <nooblit> Does it return T regardless of what type a and b are? It makes it type T?
[12:00:44] *** Joins: markos (markos@3A6075EE.3EF83E22.692B9746.IP)
[12:00:49] *** Joins: jvoorhis (jvoorhis@moz-84A91726.ptld.qwest.net)
[12:00:55] <eddyb> nooblit: a and b and the return value are all the same type, T
[12:01:11] *** Joins: Ferreus (ferreus@moz-2583F76D.pools.arcor-ip.net)
[12:01:33] <eddyb> nooblit: that is, the function can take two int's and return an int, but if you try to give it an int and a float, it won't work, it has to be the same type
[12:02:08] <nooblit> O ok I understand, it's the same in Scala
[12:02:34] <jakerr> The Rc doc for clone says: "Returns a copy of the value. The contents of owned pointers are copied to maintain uniqueness, while the contents of managed pointers are not copied." Can someone please explain what it means about the "contents of owned pointers..." bit? 
[12:02:37] *** Quits: jvoorhis (jvoorhis@moz-84A91726.ptld.qwest.net) (Ping timeout)
[12:02:57] <eddyb> jakerr: clone for ~T will copy the entire value in another ~T
[12:03:31] <jakerr> Rc can't be constructed with an owned pointer as the value though no?
[12:03:41] <eddyb> jakerr: so if you have ~[int], it will duplicate the entire vector. and it recurses so cloning a ~[~[int]] can become exponential
[12:03:47] <nooblit> is ~ like unique ptr in c++? 
[12:03:51] <FliPPeh> Yep
[12:03:52] *** Quits: luz (lucy@moz-CD18B14B.customer.cdi.no) (Ping timeout)
[12:03:53] <eddyb> nooblit: pretty much
[12:04:08] <eddyb> jakerr: no, though it would make sense
[12:04:22] <Matthias247> that is strange. a clone of an Rc should not do anythign with the content. Only return a copy of the Rc around it and increase the refcount
[12:04:32] <eddyb> Matthias247: Rc is not an owned pointer
[12:04:47] <jakerr> The doc is on http://static.rust-lang.org/doc/master/std/rc/struct.Rc.html though.
[12:05:03] <eddyb> jakerr: the doc is for the Clone trait
[12:05:07] <jakerr> It makes it appear that the clone impl for Rc<T> in particular
[12:05:13] *** Joins: luz (lucy@moz-CD18B14B.customer.cdi.no)
[12:05:16] <eddyb> do we still show the trait's docs for impls?
[12:05:32] <jakerr> Yeah it's confusing.
[12:05:32] <Matthias247> ah, it's a problem because of the inherited doc comments
[12:05:46] <eddyb> jakerr: it's only there because it's here http://static.rust-lang.org/doc/master/std/clone/trait.Clone.html
[12:05:50] <jakerr> Got it. So I'm not crazy :)
[12:06:38] <silven> was @-pointers GC:d or RC:d?
[12:06:43] <nooblit> Why hasn't anyone made a scripting language that compiles into another language. Like have python compile into Rust and then have the compiler compile Rust into byte-code? That way you could use python lang to right Rust. 
[12:06:50] <silven> And, it's being removed 100% right?
[12:06:51] <eddyb> silven: what's :d?
[12:07:04] <silven> "Somehting:ed"
[12:07:05] <eddyb> @T acted like a GC-managed pointer but it was doing refcounts
[12:07:19] <eddyb> silven: so, 'd?
[12:07:23] <silven> ya :P
[12:07:32] <jakerr> So if someone explicitly documents "impl<T> Clone for Rc<T>" would the doc only show the most specific one?
[12:07:32] <silven> English is not my native language
[12:07:43] <eddyb> jakerr: not sure if that even works
[12:08:39] * dbaupp guesses silven is Scandinavian?
[12:08:42] <jakerr> eddyb: okay, thanks.
[12:08:52] <eddyb> jakerr: hmpf, it doesn't have docs http://static.rust-lang.org/doc/master/src/std/home/rustbuild/src/rust-buildbot/slave/doc/build/src/libstd/rc.rs.html#93-101
[12:09:06] *** Joins: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[12:09:16] <dbaupp> individuals aren't documented at all, aiui
[12:09:24] <dbaupp> *individual impls
[12:09:33] *** Joins: tcreate (tcreate@moz-90E5C923.hsd1.ma.comcast.net)
[12:10:13] <nooblit> I herd since Rust is still being developed the docs are in a state of flux and incomplete at the moment. At least I read that somewhere. 
[12:10:36] <Matthias247> nooblit: search for haxe
[12:10:54] <Matthias247> nooblit: you can compile that into c as well as as3 or javascript
[12:10:56] *** Quits: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net) (Ping timeout)
[12:11:39] *** Quits: sigma (sigma@moz-B2E77065.range86-184.btcentralplus.com) (Ping timeout)
[12:11:51] <nooblit> Matthias247 well, why would anyone ever want to write C then if they can use a scripting lang to write it?
[12:12:16] <nooblit> I didn't even know they had that
[12:12:33] <Matthias247> it won't give you an optimized result
[12:12:45] <nooblit> doesn't the compiler do that?
[12:13:04] <Matthias247> and it won't give you a stable C API
[12:13:28] <nooblit> Does haxe convert it to C or to bye code?
[12:13:31] *** Joins: reima (Instantbir@moz-2AF30DCC.dip0.t-ipconnect.de)
[12:13:48] <Matthias247> you can do optimizations in C that you can't express in higher-level languages
[12:13:50] *** Joins: aklt (aklt@moz-E66E9BCB.u.parknet.dk)
[12:13:57] <jakerr> eddyb: This is an example where the doc is overridden: http://static.rust-lang.org/doc/master/src/std/home/rustbuild/src/rust-buildbot/slave/doc/build/src/libstd/cell.rs.html#191-195
[12:13:59] <Matthias247> nooblit: it has different options
[12:14:09] <eddyb> jakerr: does it show up in the docs?
[12:14:13] <eddyb> Matthias247: and the other way around
[12:14:18] <jakerr> it works http://static.rust-lang.org/doc/master/std/cell/struct.RefCell.html
[12:14:33] <eddyb> jakerr: you can submit a PR for Rc docs if you want to :)
[12:14:53] <nooblit> Hmm well they need to optimize haxe so that it writes efficent C code, Like if I say do this in haxe, haxe compiles it into a fast C version.
[12:14:57] *** Joins: alonlevy (alon@C646CF2A.423BDA8F.692B9746.IP)
[12:15:38] *** Quits: arturo (Thunderbir@moz-E83B14F0.superkabel.de) (Ping timeout)
[12:15:41] <jakerr> I'm still trying to learn the language so don't think I can doc it well. Which is why I was trying to read those docs :)
[12:15:51] <jakerr> eddyb:^
[12:15:54] <nooblit> Matthias247 I take it haxe would still be bast, being that C is still fast even if it's not efficiently written? 
[12:16:23] <Matthias247> C is not necessarily fast when not efficiently written
[12:16:48] <nooblit> Matthias247 well it would be faster than Java ??
[12:16:48] <eddyb> nooblit: it doesn't really have the safety guarantees of rust
[12:16:49] <Matthias247> I would say for > 50% of all programmers Java and C# programs would outperform their results in C or C++
[12:16:50] <FliPPeh> C++ is faster at times
[12:17:19] <FliPPeh> But language speed is not important in 90% of use cases
[12:17:31] <Matthias247> that's also true
[12:18:21] <jakerr> eddyb: Happy to file a couple issues though. I'm thinking one to document that specific case in Rc. And one requesting that rust-doc makes it apparent some-how that a doc is inherited.
[12:18:25] <nooblit> I guess people like languages like people like cars, luxury vs sports car kinda thing. 
[12:18:41] *** Quits: mgottschlag (quassel@moz-8A0EB40C.cust.bluewin.ch) (Ping timeout)
[12:18:46] <eddyb> jakerr: sounds good :D
[12:18:53] *** Joins: oberstet (quassel@moz-5E97C680.dynamic.mnet-online.de)
[12:19:20] *** Quits: tcreate (tcreate@moz-90E5C923.hsd1.ma.comcast.net) (Client exited)
[12:19:20] <FreeFull> nooblit: What sort of car would Haskell be?
[12:19:32] <nooblit> Given my analogy of cars, what would Rust be? 
[12:19:34] <eddyb> nooblit: Rust is a luxury sports car with a jet engine in the making
[12:19:46] <dbaupp> jakerr: fwiw I think the correct solution for inherited docs is to do what haddock does and just not show them on the impl's, just on the trait definitions
[12:19:50] <eddyb> 2.0 might include warp
[12:19:55] <dbaupp> (do file an issue though)
[12:19:58] <reima> What's the difference between ~"" and "".to_str(), and why would one prefer one over the other?
[12:19:59] *** Joins: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp)
[12:20:02] <Matthias247> inheriting docs a good thing at first. You won't like to document to_str() each time to implement it
[12:20:12] <reima> I was wondering because of this: https://github.com/pcwalton/sprocketnes/commit/587aa82339fed03b40ad7f32eb5b508a741d6005
[12:20:18] <FliPPeh> Haskell is a luxury car that has a chauffeur that does all the things for you
[12:20:24] <FreeFull> rusti: "".to_str()
[12:20:25] -rusti- ~""
[12:20:26] <Matthias247> But you should overwrite the docs if the behavior is different
[12:20:34] <FliPPeh> You just tell it what is to be done and don't car how it needs to be done
[12:20:38] <nooblit> FreeFull	I'm not a programmer, but i've herd people talk about Haskell in a way that sounds like a luxury.
[12:20:39] <eddyb> reima: to_str() in that case does to_owned() which is almost identical to ~"", no real reason to use the former
[12:20:40] <FliPPeh> care even
[12:21:22] <eddyb> reima: that's a weird commit
[12:21:22] <dbaupp> Matthias247: for traits, the docs come from the parent
[12:21:29] <nooblit> maybe haskell is a  Mercedes Benz? 
[12:21:35] <dbaupp> if you don't match the parent, then you shouldn't be implementing the trait
[12:21:53] <FliPPeh> I like to thing that C is a go-cart
[12:21:59] <nooblit> lol
[12:22:02] <dbaupp> (although that's possibly to idealistic in Rust, where there's the nitty-gritty details of the machine to worry about.)
[12:22:05] <FliPPeh> It's tiny and barebones and if you do something wrong it's horribly painful
[12:22:08] <eddyb> FliPPeh: then what is go?
[12:22:10] <reima> eddyb: I guess it's just a matter of personal preference then and that's why pcwalton did that change
[12:22:14] <Matthias247> nooblit: No, Mercedes is no real extraordinary/luxury. More like a Maybach or Bentley maybe ;)
[12:22:24] <FliPPeh> eddyb: A go-cart with it's steering on the back
[12:22:27] <eddyb> reima: or he was expecting a change in rust
[12:22:29] <nooblit> What kind of car would Java be lol?
[12:22:36] *** Joins: Ms2ger (Ms2ger@961DA5D0.EA0ABEA5.692B9746.IP)
[12:22:44] <Matthias247> a Volkswagen ;)
[12:22:46] <reima> eddyb: Good point
[12:23:06] *** Ms2ger is now known as Ms2ger|ateamdevroom
[12:23:19] <Matthias247> dbaupp: I think that's ok. And for the impl's it should either show the doc on the impl or if that is missing than take it from the trait
[12:24:40] <eddyb> Matthias247: that's what it's doing right now
[12:25:07] <Matthias247> then it's fine and only the doc on the Rc::Clone impl should be updated :)
[12:25:22] <nooblit> Matthias247 wow the Maybach Landaulet looks nice and expensive lol
[12:25:27] <eddyb> you mean Clone<for Rc> :P
[12:25:48] <Matthias247> you  know what I mean
[12:25:54] <dbaupp> Matthias247: I disagree with that
[12:26:04] <dbaupp> Matthias247: I think it should show nothing by default
[12:26:22] <dbaupp> and show the docs from the impl if they exist
[12:26:34] <dbaupp> if someone wishes to see the trait docs, they can click through to the trait
[12:26:59] <dbaupp> our doc pages are very long and cluttered due to having all the docs of Clone etc. repeated everywhere
[12:27:00] <Matthias247> and then you would want want to redocument things like to_str(), hashcode, etc. all them time?
[12:27:12] <dbaupp> no, just omit them
[12:27:25] <dbaupp> it's "obvious" what they do because they come from a trait
[12:27:27] *** Joins: csherratt (csherratt@moz-7685819.cpe.teksavvy.com)
[12:27:34] <dbaupp> i.e. their behaviour is described elsewhere
[12:27:47] <nooblit> I would like the front page to be a big video intro that teaches noobs how to program like, this is called a function and this is what a int is lol. But I'm prob outnumbered on that.
[12:27:57] <dbaupp> and only deviations from the expected behaviour should be described on the individual impls
[12:28:02] *** Joins: sigma (sigma@C91C7F36.70518F41.9D18269F.IP)
[12:28:54] *** Quits: csherratt (csherratt@moz-7685819.cpe.teksavvy.com) (Quit: csherratt)
[12:29:52] <Matthias247> hey, I heard some people here like big pages with all info on it, because that's vim optimized :)
[12:30:13] <dbaupp> for HTML docs?
[12:30:39] <Matthias247> no, that was for code and just kidding
[12:30:45] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Client exited)
[12:31:00] <nooblit> maybe it's not obvious it comes from a trait if you come from a scripting language and this is your first one? Or maybe it is?
[12:31:08] <Matthias247> but for html docs I think you can fix that with a short index of all functions for the overview
[12:31:09] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[12:31:16] <dbaupp> meh
[12:31:27] <dbaupp> Haskell never shows docs on impls, e.g.: http://hackage.haskell.org/package/time-1.4.1/docs/Data-Time-Clock.html#t:UniversalTime
[12:31:38] <dbaupp> (the instances section)
[12:31:46] *** Quits: aklt (aklt@moz-E66E9BCB.u.parknet.dk) (Quit: leaving)
[12:31:59] <dbaupp> and it makes it very easy to establish the things that you can and can't do with a type
[12:32:02] <Matthias247> and rust should do everything that Haskell does?
[12:32:09] <dbaupp> of course not!
[12:32:11] <Matthias247> Javadoc does it
[12:32:30] <dbaupp> java doesn't really have traits/type classes
[12:32:35] <Matthias247> if you think about interfaces instead of traits
[12:32:55] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Ping timeout)
[12:33:00] <dbaupp> and rust should do everything that Java does? :P
[12:33:14] <FliPPeh> Rust should do nothing that Java does
[12:33:31] <markos> could anyone suggest a workaround solution here? trying bootstrapping on armhf using the prebuilt binaries on https://github.com/mozilla/rust/issues/10482.  http://paste.debian.net/79767/
[12:33:42] <Matthias247> I think every lang that I know of and that has a reasonable doc system shows the interface docs on the implementation when there the doc is missing
[12:33:57] <dbaupp> haskell has a reasonable doc system
[12:34:18] <Matthias247> yes, but I don't know haskell :)
[12:34:20] <flaper87> I agree with dbaupp here
[12:34:23] <nooblit> dbaupp is for smart people, not everyone is smart lol like me.
[12:34:36] <nooblit> Haskell :)
[12:34:38] <dbaupp> anyway, scroll to the bottom of http://static.rust-lang.org/doc/master/std/option/enum.Option.html
[12:34:41] <jakerr> Can I tag my issue or do owners do that? Here's the first one: https://github.com/mozilla/rust/issues/11991
[12:34:42] <FliPPeh> Love me some haskell
[12:34:51] <flaper87> jakerr: owners
[12:34:56] <FliPPeh> I love it when the compiler yells at me for the slightest type mismatch
[12:34:58] <flaper87> jakerr: what tag do you need?
[12:35:07] <FliPPeh> It's compensation for my years of python usage
[12:35:12] <flaper87> jakerr: actually, "repo collabs" and owners
[12:35:26] <jakerr> flaper87: A-rustdoc
[12:35:27] <dbaupp> we really don't need to see all that crap about clone and iter_bytes etc. etc.
[12:35:38] <dbaupp> just click on the trait name to see the docs there
[12:35:40] <FliPPeh> That I agree with
[12:35:45] <flaper87> jakerr: done
[12:35:51] <FliPPeh> Especially when the trait documentation doesn't match the implementation
[12:36:00] <FliPPeh> Very confusing as we saw before
[12:36:02] <jakerr> Thanks :)
[12:36:17] <dbaupp> yeah, exactly, because the trait docs were not written with the current type in mind
[12:36:45] <Matthias247> they should be writtten independet from actual types
[12:36:57] <Matthias247> that's why they are traits :)
[12:36:57] <flaper87> jakerr: np
[12:37:02] *** Joins: mgottschlag (quassel@moz-8A0EB40C.cust.bluewin.ch)
[12:37:14] <Matthias247> The clone doc isn't as it seems
[12:37:15] <nooblit> dbaupp when Rust is 1.0 will you have docs for new people that never programed before? That is one reason I didn't learn D and a few others because all of there tutorials are geared for people who already know how to program. I'd like my first language if I'm able to be something more modern.
[12:37:57] <Matthias247> nooblit: I think that's what books are for and not short docs on websites
[12:38:37] <nooblit> Matthias247 Well, if someone writes a book for Rust, I'll definitely buy it. 
[12:39:37] * markos agrees with nooblit 
[12:39:48] <markos> is there anyone writing one by any chance? :)
[12:40:00] <FliPPeh> That would be foolish
[12:40:07] <flaper87> nooblit: a Rust book will most likely teach you how to program with Rust but not how to program in general. It could certainly point you to places where to read about certain concepts but...
[12:40:33] <markos> flaper87, why would it be foolish?
[12:40:38] *** Joins: tcreate (tcreate@moz-90E5C923.hsd1.ma.comcast.net)
[12:40:40] <nooblit> markos I think they would need to wait for Rust 1.0 to write it because it will change too much before then.
[12:40:42] <FliPPeh> :V
[12:40:46] <markos> you mean now or in general?
[12:40:47] <flaper87> markos: FliPPeh said that, not me :D
[12:40:52] <flaper87> markos: but I agree
[12:40:54] <Matthias247> flaper87: if all books would be written in that way then nobody would have a chance to start
[12:40:54] <dbaupp> nooblit: Rust isn't designed to be a beginners language, so i don't think there will be any "official" worked aimed at that
[12:40:55] <flaper87> now
[12:41:03] <markos> flaper87, sorry, tab completion :)
[12:41:28] <dbaupp> Matthias247: "they should be writtten independet from actual types" can be quite difficult, especially if the behaviour is best illustrated by an example
[12:41:33] <flaper87> Matthias247: not sure what you mean exactly. I'm talking about a "rust specific" book, not a programming book
[12:41:37] <markos> well, some things must have been fixed already
[12:41:38] <nooblit> dbaupp c++ is designed to be a beginners language but there is plenty of begginer tutorials teaching c++
[12:41:43] <flaper87> "general programming book"*
[12:41:54] <FliPPeh> C++ is absolutely NOT designed to be a beginners language
[12:41:54] <Matthias247> I think a book makes no sense as long as the language and the libraries are not stable
[12:41:58] <dbaupp> nooblit: yes, I said "official" for a reason: others may write beginners tutorials
[12:42:04] <eddyb> dbaupp: is there anything wrong with me thinking it's a better beginners language than many of the ones used to teach students programming from scratch?
[12:42:04] <flaper87> nooblit: a good way to start is going through tutorials, read docs and books about the concepts you don't know
[12:42:18] <flaper87> and write examples and test apps based on the things you've learned
[12:42:29] <flaper87> experimenting is IMHO one of the best ways to learn
[12:42:29] <nooblit> i mistyped, I meant it's NOT for beginners but there is tons of tutorials on c++ for new people
[12:42:34] <FliPPeh> ah
[12:42:45] <FliPPeh> Well, that's because C++ is also a very old language
[12:42:48] <markos> Matthias247, a good idea would be an online book that would be worked on while the language is still in progress, but published soon after 1.0 is fixed
[12:43:05] <FliPPeh> Lots of time for resources to accumulate (and become outdated and more harmful than helpful)
[12:43:09] <markos> waiting for 1.0 to be released to *start* writing a book is foolish
[12:43:32] <dbaupp> eddyb: maybe, but I think the trouble even experienced programmers have with convincing borrowck to pass their programs is a good indication that it won't work super-well for beginners
[12:43:35] <dbaupp> eddyb: don't really know
[12:44:01] <nooblit> markos why, the language will change vastily once 1.0 comes out so the book will be worthless? 
[12:44:19] <FreeFull> Haskell is 5 years older than Java
[12:44:32] <FliPPeh> Anything you write now can be completely different in a few weeks
[12:44:35] <dbaupp> eddyb: (i.e. they're program is probably legitimately non-memory safe, but... people have to start somewhere, and starting with pages of compiler errors isn't encouraging.)
[12:44:40] <flaper87> eddyb: I think I agree with you. It can be frustrating to start *the hard way* but at the end, if people succeed at learning the "hard" language, they'll definitely appreciate it
[12:44:45] <FreeFull> Python is 4 years older than Java
[12:44:50] <FliPPeh> The tutorial on the page still teaches @T which is now as good as gone
[12:44:59] <markos> nooblit, that's my point, I don't think it *will* change vastily, I think most of the stuff will still apply maybe with minor changes
[12:45:06] <tiffany> that's not necessarily true though, a lot of rust has remained the same for as long as I've been around
[12:45:06] <Matthias247> dbaupp: I agree. I did productively program in more than 10 languages in the last years. But Rust was without questiosn the hardest. Even with the knowledge from the others.
[12:45:21] <markos> and that's what preview releases are for
[12:45:22] *** Joins: zofrex (zofrex@moz-92CD32EC.cable.virginm.net)
[12:45:34] <tiffany> pattern matching, lifetimes, etc. have all stayed more or less the same and don't plan on changing much until 1.0
[12:45:39] <FreeFull> C++ is 12 years older than Java
[12:45:48] <nooblit> Matthias247 What's so hard about Rust? Surely it's not as difficult as c++?
[12:46:02] <FliPPeh> The compiler yells at you a lot
[12:46:06] <tiffany> you can definitely write a (perhaps not textbook-length) book on rust, and keep it up to date as the language changes
[12:46:17] <FreeFull> tiffany: I wouldn't bother until Rust hits 1.0
[12:46:31] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[12:46:53] <Matthias247> nooblit: a lot of things, lifetimes, ownerships in pattern matching, type conversions. Designing "interfaces"
[12:47:12] *** Quits: mgottschlag (quassel@moz-8A0EB40C.cust.bluewin.ch) (Ping timeout)
[12:47:15] <eddyb> tiffany: steveklabnik is doing that
[12:47:38] <Matthias247> nooblit: C++ is a large area. Basic c++ isn't necessarily difficult. The problem with C++ is that the language is gigantic, and most people don't know it completely
[12:47:42] <nooblit> I mean a book that teaches someone using Rust with no programming knowledge whatsoever. Like starting with basic stuff, functions and loops and types and simple hello world. Then moving on to more complex. 
[12:48:20] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[12:48:26] <tiffany> I don't think rust is necessarily a good introductory language
[12:48:28] <markos> nooblit, I'd rather have a Rust Cookbook, like consider programming in general as granted and provide solutions to common problems
[12:48:32] <tiffany> there's a high overhead to jumping in and writing a calculator
[12:48:42] <markos> or Rust for C++ developers or similar
[12:48:52] *** Joins: kvanb (kvanb@moz-70B2A571.lnse5.win.bigpond.net.au)
[12:49:08] <FliPPeh> In addition to being large, in C++ there are many ways to do something due to C++ having evolved over a few decades with new features coming up but having to maintain backwards compatibility
[12:49:41] <Matthias247> that's what I meant with "large" :)
[12:49:47] <nooblit> tiffany But I feel it is a waste of my time to learn another language I don't want to use just so I can start to learn Rust, I want to have Rust as my first language so that it doesn't seem strange coming from a different language I guess.
[12:50:09] <FliPPeh> You *can* use raw pointers but references are much safer, you can allocate on the heap and pass the pointer around or use unique_ptr, you can iterate over a vector manually or use range-for
[12:50:25] <Matthias247> even people that programmed C++ for a long time have no clue about move semantics and rvalue references or any other fancy c++11 features
[12:50:32] <FliPPeh> Many books teach old practices that are long replaced
[12:51:31] <Matthias247> nooblit: I think learning something that is widely used and has a lot of the same patterns than other languages is never bad
[12:51:34] <markos> Matthias247, I'm one, programmed C++ for years, but didn't follow it lately, tried to start reading about C++11, got confused, gave up, ended up here :)
[12:51:38] <nooblit> I thought in c++  Memory management is typically done by passing memory allocations as arguments when the life-time of an object is exposed in its API. I don't know what that means but I read it in a forum.
[12:52:03] <tiffany> I think the best language I can recommend to beginners is python
[12:52:15] <FliPPeh> Bah, duck typing
[12:52:16] <tiffany> besides, if rust is a strange language to you then it's a good thing
[12:52:20] <tiffany> it means you'll learn something new
[12:52:25] <FliPPeh> Learn C, C is fun and minimal and you learn something about the hardware as well
[12:52:40] <tiffany> it's all fun and games until you cause a segfault before knowing what pointers are
[12:52:49] <FliPPeh> Fun!
[12:53:02] <zofrex> I think learning only one language is bad, full stop. No programmer should know only one language, or even one paradigm, imo.
[12:53:10] <FliPPeh> ^
[12:53:24] <FliPPeh> Programming Languages are tools and that's it
[12:53:33] <nooblit> I'm not a programmer, I just want to learn it as a hobby for fun, to make bots for single player games and to make games for fun.
[12:53:37] <tiffany> learning new ways of programming are an important part of how to become a better programmer
[12:54:01] <Matthias247> nooblit: if you want to have an easy start with games probably look at C# and Unity
[12:54:06] <nooblit> Well, I guess I don't do it for $$ I do it for fun
[12:54:17] <zofrex> I fiddled with QBasic and then VB6 when I began, and the first structured programming learning I did was C, which I actually really loved as a beginner, but I know to some people that's a pretty intimidating place to start. It kinda depends on what you want to make, really, and what you want to learn - I wanted to understand the computer, so I went low level.
[12:54:18] <FliPPeh> All good programmers do it for fun
[12:54:29] <dbaupp> nooblit: most of the people on this channel are programming for fun :)
[12:54:29] <Ms2ger|ateamdevroom> zofrex, sure, sure, but *please*, don't make me do logic programming again :)
[12:54:33] <markos> nooblit, you're not a programmer *now*, if you catch the virus, that's it, you'll be coding till you die :)
[12:54:36] <tiffany> I haven't made a single dollar off of being a programmer yet and I've used tens of languages
[12:54:39] <zofrex> *lol* +1 to that
[12:54:40] <FliPPeh> My experience with work-only-programmers has been awful
[12:54:43] <dbaupp> (and some happen to get paid to do it too.)
[12:55:04] <Matthias247> Ms2ger|ateamdevroom: logic in the sense of VHDL/Verilog or in the sense of prolog? :)
[12:55:05] <FliPPeh> They learn what they HAVE to learn and then make it awful for people who know better and have to work with them
[12:55:22] <Ms2ger|ateamdevroom> Matthias247, prolog
[12:55:36] <tiffany> I don't think I would suggest anyone try rust without having first having used C or C++, and poked at functional programming
[12:55:44] <Matthias247> Ms2ger|ateamdevroom: oh yes, that's really painful. Only had to use it at university though
[12:55:49] <tiffany> a lot of the design decisions are confusing if you don't know the background
[12:55:51] <Ms2ger|ateamdevroom> Matthias247, though what I've heard of Verilog didn't exactly make me want to try it :)
[12:55:54] <Ms2ger|ateamdevroom> Same here
[12:55:58] <FliPPeh> Ahh, VHDL
[12:56:03] <FliPPeh> Fond memories of pain and suffering
[12:56:11] <nooblit> Well, I've never really thought about doing it for $$ but I'm not opposed to it, but I've herd people on the net complain because there work makes them use a langauge when they want to use a different one, If I do work, it will be using a language I choose. 
[12:56:15] <zofrex> @nooblit: LUA might be interesting, lots of games use that as a scripting language, and there are game frameworks in it. Python is also great for game programming, C# has XNA which is lovely, Java is actually nice for game programming too. There's loads of options
[12:56:18] <Matthias247> VHDL is also fun :)
[12:56:33] <FliPPeh> Love me some Lua
[12:56:36] <Matthias247> but also quite verbose
[12:56:38] <FliPPeh> (Not an acronym by the way)
[12:56:43] <tiffany> it's Lua
[12:56:49] <zofrex> (my bad, thanks for the correction)
[12:56:50] <tiffany> LUA is a fork of Lua where everything is in CAPS
[12:56:53] <Ms2ger|ateamdevroom> nooblit, that's a privilege not everyone has :)
[12:57:14] <FliPPeh> If you do Lua you can also easily hop into C due to its nice C API
[12:57:26] *** Joins: alan_andrade (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net)
[12:57:31] <FliPPeh> Lua is my goto scripting language to embedd when I write C or C++
[12:57:38] <FliPPeh> So fun
[12:57:49] <tiffany> some of the things lua does are really irritating
[12:57:50] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[12:57:54] <tiffany> at least, once you have a big code base
[12:58:01] <Matthias247> I'm providing my @work library in 7 languages, so that every user can use what he likes :)
[12:58:02] <FliPPeh> One-Based indexing for example
[12:58:04] <zofrex> I never got my head round it. But I found learning Lua made it easier for me to learn Javascript properly.
[12:58:05] <tiffany> no, no
[12:58:07] <tiffany> that's trivial
[12:58:08] <FliPPeh> You'd think you get used to it
[12:58:11] <Matthias247> But only if I liked it too and provided it :)
[12:58:14] <tiffany> I got used to 1-based indexing
[12:58:25] <tiffany> the real pains are typos not being errors
[12:58:36] <FliPPeh> Well, that's most dynamic languages for you
[12:58:37] <tiffany> and generally errors only being caught when the code is reached
[12:58:44] <FliPPeh> Reason I hate doing big projects in python
[12:58:59] <tiffany> python is a little bit more structured, and at least errors when a variable isn't defined
[12:59:05] <tiffany> lua just treats all undefined variables as nil
[12:59:08] <FliPPeh> But only when you execute it
[12:59:08] <zofrex> I work on a huge mobile app written in javascript and that is just the worst, when a typo takes it out
[12:59:22] <tiffany> though, to be fair
[12:59:32] <Matthias247> tiffany: many times the errors won't event be caught and the program will continue with undefined behavior
[12:59:33] <nooblit> I've herd some people say that python + C has replaced their need for c++. Now not knowing any langs yet, what do yall think about that combo? Would I be able to do allot with C and Python or would I be doing it the hard way?
[12:59:36] <tiffany> there is strict.lua, which makes any variables that don't exist cause an error
[12:59:41] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[12:59:41] <Matthias247> that's why I hate javascript
[12:59:48] *** Joins: jdm (jdm@moz-DB4A9C19.scl3.mozilla.com)
[12:59:48] *** ChanServ sets mode: +o jdm
[12:59:49] *** Quits: alan_andrade (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net) (Ping timeout)
[13:00:01] <Ms2ger|ateamdevroom> Who doesn't hate JS? :)
[13:00:06] <tiffany> I've heard bad things about python's C API
[13:00:21] <Matthias247> Ms2ger|ateamdevroom: don't know. At least we are on a Mozilla server? :)
[13:00:22] <FliPPeh> Ms2ger|ateamdevroom: Most newer programmers who started in the NodeJS era :(
[13:00:28] <tiffany> though, people using python + C usually go the other way around, wrapping C libraries up using FFI
[13:00:41] <FliPPeh> Can't wait for that fallout when NodeJS applications have to be maintained years in the future
[13:00:47] *** Quits: tcreate (tcreate@moz-90E5C923.hsd1.ma.comcast.net) (Client exited)
[13:00:52] <Ms2ger|ateamdevroom> NodeJS, the new COBOL?
[13:00:55] <zofrex> I stopped hating JS once I learnt it properly rather than hacking around in it. I actually found learning Lua made me much better at Javascript weirdly enough
[13:01:02] <Matthias247> node.js is also one thing I can't understand at all
[13:01:18] <FliPPeh> You see, it's web scale
[13:01:29] <nooblit> tiffany When I was reading debate threads on langs, trying to figure out which one was better, all I got is that all languages suck lol.
[13:01:29] <Matthias247> but I also think it's probably a thing that newbies like
[13:01:32] <zofrex> nooblit: seeing as you want to program game bots, if you want something that interfaces nicely with C I would definitely recommend Lua. It's really really common in game programming and dovetails very nicely with C
[13:01:34] *** Joins: jvoorhis (jvoorhis@moz-84A91726.ptld.qwest.net)
[13:01:34] <tiffany> node.js is apparently okay in and of itself, it's just how it markets itself, how the community acts, and how poorly javascript handles callback hell
[13:01:49] <Ms2ger|ateamdevroom> nooblit, I think I'd probably agree with that :)
[13:01:54] <FliPPeh> NodeJS snippet: )})})})})})});
[13:01:56] <tiffany> nooblit: there is no better language, only a language better suited to a specific problem
[13:01:57] <FliPPeh> aka the new lisp
[13:02:12] <Ms2ger|ateamdevroom> Promises will fix everything, though
[13:02:12] <zofrex> re: typos causing errors and lack of static checking, I have found that 100% test coverage really makes that problem go away
[13:02:23] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[13:02:27] <tiffany> flippeh: I would bet one of those FRP-for-javascript libraries would go quite well with node.js
[13:02:34] *** Quits: kvanb (kvanb@moz-70B2A571.lnse5.win.bigpond.net.au) (Quit: kvanb)
[13:02:40] <FliPPeh> nooblit: There are 2 kinds of languages, those everyone complains about and those nobody uses
[13:03:06] <FliPPeh> I think Stroustrup said that
[13:03:15] <nooblit> tiffany Well people often say there is no better language but I believe in reality, there are probably languages for a spesific job that are desgined better, I mean they can't all be equal because they are so different, I assume one has to be better at something.
[13:03:19] <tiffany> 100% test coverage isn't always practical
[13:03:19] *** Quits: jvoorhis (jvoorhis@moz-84A91726.ptld.qwest.net) (Ping timeout)
[13:03:33] <tiffany> I don't know of any way to unit test my game engine, because of a lot of the code being related to graphics
[13:03:43] <zofrex> indeed not. but if you can do it or close to it then typos get caught nice and early.
[13:03:59] <FliPPeh> tiffany: You recruit a few people who sit and test whether or not the thing being drawn is correct
[13:04:22] <zofrex> nooblit: don't discount the value of personal taste. you're going to spend a lot of time with the language, you're going to get to know each other intimately, personality counts for a lot :P
[13:05:00] <Matthias247> FliPPeh: sounds realisitic if she doesn't earn anything with her engine :)
[13:05:51] <FliPPeh> There's probably a few people in third world countries who do that for very little money
[13:06:00] <FliPPeh> Depressing fact
[13:06:14] <Matthias247> and there are really things that are very problematic to unit test
[13:06:23] <nooblit> Does python + C do everything that c++ can do but without all the headache? maybe I'll learn that combo if not I'll look at lue or LUE whatever it's called.
[13:06:32] <FliPPeh> I say no
[13:06:42] <Matthias247> all things were small code parts don't work for themselves, but it works only as a whole. And with interaction from outside
[13:06:43] <patpat> Lua*
[13:06:44] <tiffany> what do you mean by "can"
[13:07:05] <FliPPeh> You trade one set of headaches for another
[13:07:10] <Matthias247> nooblit: no
[13:07:16] <tiffany> writing the majority of your application in python with the hot path bits being written in C only really works when your application actually has a hot path
[13:07:34] <nooblit> By can I mean speed and expressiveness 
[13:07:40] <Matthias247> I would say it's even more complex, because you have to deal with a foreign function interface
[13:07:45] *** Joins: fyolnish (fyolnish@moz-EF224D80.uqwimax.jp)
[13:07:54] <FliPPeh> Also, C + Python or Python + C?
[13:07:58] <FliPPeh> There's a differences
[13:08:00] <tiffany> having to deal with interop between multiple languages is painful
[13:08:00] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[13:08:01] <zofrex> strictly speaking any language can do anything any other language can. that's kind of like asking if both rollerskates and a spy plane can get from London to Manchester. Yes, but they're designed for very different applications.
[13:08:09] <Matthias247> If you want to go native buy a good book about C++ and read that. It really isn't that bad
[13:08:11] <tiffany> unless you're using COM, then COM is painful
[13:08:48] <nooblit> Well if I'm making a bot, I'll need to use winAPI at some point correct?
[13:08:55] <tiffany> no
[13:09:02] <FliPPeh> Gah, WinAPI
[13:09:09] <zofrex> +1 to what tiffany said. Don't mix unless you need to. Actually, don't do anything unless you need to. Or want to. There is no good way or right way, just grab the tools you need to achieve the task in front of you, and start doing it :)
[13:09:09] <tiffany> well, it depends what you're doing
[13:09:13] <FliPPeh> That abuse of the beautiful C language
[13:09:18] <tiffany> if you're trying to feed input into some other application, then possibly
[13:09:29] *** Joins: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[13:09:39] <tiffany> if you do it with python and C, you'll probably have to do the same though
[13:09:48] <tiffany> also, the windows API is horrible, you should not start with trying to wrangle it
[13:09:49] <nooblit> tiffany I don't know what tools i need but I'm learning a great deal about all the tools from all of you :)
[13:10:03] *** Quits: alonlevy (alon@C646CF2A.423BDA8F.692B9746.IP) (Ping timeout)
[13:10:34] <nooblit> So all of you think lue or LUE is a good lang for that?
[13:10:49] <FliPPeh> If I had to pick any reason for my full switch to Linux, it's the Win32 API
[13:11:01] <nooblit> Lol
[13:11:04] <tiffany> it's lua
[13:11:08] <mark_edward> what is the bottom type in Rust?
[13:11:12] *** Quits: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net) (Ping timeout)
[13:11:17] <tiffany> I don't think there is any way to feed input into another application with lua
[13:11:19] <FliPPeh> Does Rust have a bottom type?
[13:11:35] <tiffany> isn't ! a sort of bottom type?
[13:11:45] <mark_edward> tht must be what fail!() is right, because you can use it anywhere in matches
[13:11:48] <mark_edward> i think
[13:11:53] <nooblit> Someone said lue is used as a scripting lang in games.
[13:11:54] <FliPPeh> Also, you can feed input into another program in Lua with popen
[13:12:00] <FliPPeh> Lua!
[13:12:03] <FliPPeh> Not Lue
[13:12:09] <Matthias247> nooblit: if you want to make a bot for a game that supports scripting than use the language that that game uses. If you want to make a bot for a language that supports no scirpting, then learning C++ will be your least problem
[13:12:10] <tiffany> that's stdio kind of input
[13:12:11] <nooblit> Yeah Lua
[13:12:12] <tiffany> not mouse movement kind
[13:12:23] <tiffany> some games support lua scripting, not all
[13:12:29] <tiffany> making a bot for a game is a pretty big endeavour
[13:12:34] <FliPPeh> Well, since that is OS-dependant, no
[13:12:52] <Matthias247> even more if he thinks about aimbots ;)
[13:12:54] <FliPPeh> Although hacking up a tiny module in C that does that is easy
[13:13:04] *** Joins: NiccosSystem (NiccosSyst@AB1AFDE.FC7B0C35.A7597CB6.IP)
[13:13:11] <tiffany> easy if you consider C and windows API easy
[13:13:18] <zofrex> I would try to find some focus. Pick some small thing that you want to exist or make, and then figure out what you're going to use - not the other way around
[13:13:36] <nooblit> Matthias247 I was thinking of making something like a color bot that use RGB pixils and screen shots and imput mousekeys.
[13:13:50] *** Ms2ger|ateamdevroom is now known as Ms2ger|omw
[13:14:32] *** Joins: Earnestly (earnest@moz-1CE0D638.dyn.plus.net)
[13:15:23] <nooblit> Like a simple duck hunt game where you shoot a duck on the screen and reload a gun. I think that would be fun to make.
[13:15:36] <nooblit> Not the game I mean the bot that shoots
[13:16:01] *** Quits: Ms2ger|omw (Ms2ger@961DA5D0.EA0ABEA5.692B9746.IP) (Ping timeout)
[13:16:06] <FliPPeh> The hard thing about that is interfacing the game
[13:16:10] <tiffany> ^
[13:16:23] <FliPPeh> Certainly not easy for beginners
[13:16:47] <nooblit> wouldn't I just need winapi or mouseEvent then a grid number?
[13:17:34] <nooblit> Well, I'll start with something easier then, no big deal.
[13:17:41] *** Joins: alonlevy (alon@C646CF2A.423BDA8F.692B9746.IP)
[13:18:31] *** Joins: tryzor (bzlandfill@moz-9D6F2D3.dip0.t-ipconnect.de)
[13:20:53] *** Joins: Ms2ger|omw (Ms2ger@961DA5D0.EA0ABEA5.692B9746.IP)
[13:21:03] <nooblit> I got it ! :)  This tutorial is in python, it's a web bot that plays a game http://dev.tutsplus.com/tutorials/how-to-build-a-python-bot-that-can-play-web-games--active-11117 Would this be hard to do in c++ or Lua?
[13:21:18] *** Ms2ger|omw is now known as Ms2ger|lightning
[13:21:49] <nooblit> I could just convert his instructions into c++
[13:22:28] <FliPPeh> Probably not
[13:22:36] <FliPPeh> Because it relies on libraries to do most of the work
[13:24:14] <nooblit> O i see, it has win32 library 
[13:24:25] <nooblit> Good point
[13:25:43] <nooblit> So how different is Rust compared to c++. People in here said Rust would be hard to learn for a beginner but is it as hard as c++ for a beginner? 
[13:25:58] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Quit: Leaving...)
[13:26:26] <tiffany> C++ will compile your first program faster but it'll also be the first to produce the incorrect result and/or crash
[13:26:28] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[13:26:31] <nooblit> The only reason I thought it would be easier is because it's supposed to be more memory safe.
[13:26:37] <tiffany> by faster I mean as in it will produce less errors for you to fix
[13:26:49] <doomlord_> nooblit its very similar to c++
[13:26:57] <FliPPeh> Not very
[13:26:59] <FliPPeh> A bit
[13:27:16] <nooblit> But doesn't Rusts memory safety make it allot more easier? 
[13:27:27] <FliPPeh> Not really
[13:27:28] <doomlord_> it has new ideas, but it's definitely closer to c++11 than anything else
[13:27:31] <FliPPeh> It makes it safer
[13:27:38] <FliPPeh> Safer doesn't mean easier
[13:27:46] <tiffany> it makes programs safer at the expense of being easier
[13:27:49] <doomlord_> heh more time spent battling compile errors
[13:28:02] <tiffany> C++ programs have some pretty terrible bugs that require you to drop into a debugger and have sometimes hours-long debugging sessions
[13:28:02] <doomlord_> safer = more time arguing with the compiler, but less time debugging
[13:28:11] <tiffany> yeah, that
[13:28:14] <doomlord_> a win overall, but still a learning curve
[13:28:30] <nooblit> doomlord_ compile errors that I couldn't find in c++11?
[13:28:37] <FliPPeh> s/C++ programs/Badley written C++ programs"
[13:28:40] <FliPPeh> /*
[13:28:47] <doomlord_> it catches more errors at compile time - there's more complexity in the compiler
[13:29:03] <FliPPeh> Badly even
[13:29:03] <doomlord_> so you've got a few extra concepts, like borrow, pointer-lifetimes
[13:29:16] <FliPPeh> Also you get concepts
[13:29:20] <nooblit> Well I thought catching them at compile time was easier than trying to find the error at run time?
[13:29:24] <doomlord_> but ultimately its just safety for things you'd understand in C++
[13:29:25] <FliPPeh> As in, template parameter concepts
[13:29:37] <FliPPeh> The thing C++ desperately needs
[13:30:01] <doomlord_> nooblit - yes its easier overall, but possibly a bit of exta learning up front.. "whats this error, how do i fix it"
[13:30:01] <Matthias247> FliPPeh: the template constraint thing? Yes, i agress
[13:30:28] <doomlord_> nooblit i can't comment not learning both from scratch at the same time - i would just say its the same ballpark as C++, in complexity
[13:30:32] <tiffany> in C++, instead of "what's this error, how do I fix it", you get a crash
[13:30:48] <FliPPeh> Or worse, you get no crash
[13:30:55] <nooblit> I think I would prefer learning up front. I want to learn the correct way the first time, not incorporate bad habits so Rust sounds like a better language for me.
[13:30:56] <doomlord_> i guess i'm just used to debugging :) a few debug prints / asserts later.. you realise your error
[13:31:05] <doomlord_> whereas in Rust, you'll be staring at a compile error
[13:31:09] *** Ms2ger|lightning is now known as Ms2ger|omw
[13:31:17] <Matthias247> tiffany: I think the "what's this error" comes mostly when you try to debug somebody elses code. When it's your code you mostely know the source
[13:31:28] <doomlord_> it *is* a win overall, but i'm not sure i'd say its 'easier'
[13:31:39] <doomlord_> it will pay dividends in large projects for sure
[13:32:19] <doomlord_> its possible it might even have a steeper learning curve? like haskell but less extreme? 
[13:32:38] <FliPPeh> Let's summarize: it's different
[13:32:44] <nooblit> Would yall say it enforces good habits that are not enforced on c++? I don't want to form bad habits. I heard allot of people are teaching newbies in c++ bad habits. 
[13:32:47] <doomlord_> in haskell some 'basic things' are difficult - but you're paying complexity for safety that pays dividends in large projects
[13:32:53] <doomlord_> nooblit definitely
[13:33:11] <doomlord_> nooblit: rust will make you a better C++ programmer, much more so than haskell , IMO, because its so much more similar
[13:34:41] <doomlord_> you can take patterns from Rust back to C++, and you'll have been forced to think of safe solutions
[13:35:04] <doomlord_> ^ having said that, C++ doesn't have ADTs
[13:35:33] <tiffany> before getting into rust I didn't think about safely freeing memory after I'm done with it as much
[13:35:40] <nooblit> Where can I learn about patterns in Rust?
[13:35:49] <Matthias247> using the safe pattern from rust (like immutability or the concept of shareable types) also to other languages is for sure a good thing
[13:36:17] <doomlord_> by using it :) what i really mean is whilst you can throw pointers around all over the place in C++, and get brittle code, in Rust, you are forced to write things in a safe way
[13:36:20] <Matthias247> tiffany: hmm, but that's also one thing that C++ will force you to do :)
[13:36:26] <FliPPeh> I would argue that using Rust could make you a *worse* C++ programmer
[13:36:35] <tiffany> not really
[13:36:35] <nooblit> I like the concept of immutability, that is why I tried to learn Scala but Couldn't find a guide for first time programmer. 
[13:36:37] <FliPPeh> Since Rust enforces that your memory is safe so you get used to it
[13:36:45] <tiffany> it's not very hard to accidentally leave a destructor empty in C++
[13:36:49] <tiffany> but I'm mostly referring to C
[13:36:52] <FliPPeh> And a C++ compiler won't yell at you for not using unique_ptr
[13:36:53] <doomlord_> a lot of Rust is basically compile time enforced "modern C++"
[13:36:57] *** Joins: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net)
[13:36:59] *** Joins: mgottschlag (quassel@moz-8A0EB40C.cust.bluewin.ch)
[13:37:20] <Matthias247> absolutely
[13:37:22] <jakerr> Is the current language grammar documented somewhere? Or must I derive it from token.rs and parse.rs?
[13:37:32] <doomlord_> its Java and other GC based languages that will make you a *worse* C++ programmer
[13:38:06] <FliPPeh> For most intents and purposes you could view Rust as a GC based language
[13:38:16] <FliPPeh> Since you never manually have to release memory
[13:38:23] <doomlord_> i reserve the term "GC based" for things with a garbage collection runtime;
[13:38:34] <Matthias247> I think that's a bad comparison
[13:38:38] <tiffany> reference counting isn't really a runtime is it?
[13:38:40] <doomlord_> to me Rust is similar to C++ in being *deterministic memory management8
[13:38:44] <doomlord_> to me Rust is similar to C++ in being *deterministic memory management*
[13:38:45] *** Quits: ecl3ctic (Mibbit@578C64B6.F0F44EFA.76AE55C1.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[13:38:51] <Matthias247> because all things that are really easy to do in GC languages are ultra-hard to do in rust
[13:38:54] <zofrex> Learning Rust is making me a better Java programmer - I'm making everything shared immutable, and working on eliminating nulls entirely
[13:38:58] <doomlord_> you think about whether things are going on the stack or heap, you have ownership
[13:39:22] <tiffany> I think garbage collection is generally any sort of way of having multiple owners of data without worrying about whose responsibility it is to free it
[13:39:27] <doomlord_> its a higher learning curve than a GC language, i think ?
[13:39:39] <zofrex> way higher. GC makes life so easy.
[13:39:59] <tiffany> not if you're trying to squeeze performance
[13:40:01] <nooblit> I'm going to try to learn how to program by trying to learn Rust, I'll give it a go, but what tutorial do I use tutorial Master or tutorial 0.9?
[13:40:02] <doomlord_> (and thats why I would say C++ is the closest point of reference)
[13:40:43] <Matthias247> zofrex: for me null and Option<T> are somewhat the same thing. Can't find big advantages in the latter
[13:41:26] <nooblit> On the Rust website which tutorial do I use? there is more than one.
[13:41:30] <zofrex> There are huge advantages in the latter. I have some fields in my model classes that could possibly be missing. Previously this was documented, and every time someone accessed that field they had to remember to check for null, or we could potentially get a crash there later
[13:41:46] <zofrex> With Option<T> the programmer is forced to handle the case where there is no data there, every time - so no crashes.
[13:41:59] <tiffany> unless you use .unwrap()
[13:42:03] <doomlord_> i keep forgetting to mention ADTs and hence Option<T> etc in  rusts list of advantages when explaining it :)
[13:42:04] <dbaupp> and, without Option<T>, you never need to handle it
[13:42:13] *** Quits: sankha93 (uid12218@moz-31ABA2C0.irccloud.com) (Quit: )
[13:42:15] <Matthias247> tiffany: exactly that's the problem :)
[13:42:18] <tiffany> in which case you're either a terrible person or you have a case in which the data will always  be there but the compiler can't prove it
[13:42:18] <dbaupp> (i.e. fields that don't have Option<T> are known to be valid always.)
[13:42:23] <doomlord_> they're very central to rusts standard libraries etc (eg iteration)
[13:42:23] <jakerr> nooblit: Go with the master tutorial. Things are changing fast.
[13:42:31] *** Joins: sankha93 (uid12218@moz-31ABA2C0.irccloud.com)
[13:42:46] <nooblit> jakerr	Thank you
[13:43:09] <tiffany> to be fair though, null pointer segfaults bring the entire application toppling down in C and C++, whereas in rust a None.unwrap() only causes a single task to fail
[13:43:14] <zofrex> dbaupp - exactly! JetBrains made a nice Java-like language for the JVM that has two types of references, nullable and non-nullable, which looks really nice
[13:43:17] <doomlord_> if rust ever gets multi-parameter typeclasses/traits , would that be in the far future (post 1.0)
[13:43:19] <tiffany> the failure can propagate of course, but at least it's recoverable
[13:43:38] <doomlord_> whats the situation with operator overloading at the minute (maybe they can be some special case)
[13:43:39] <jakerr> nooblit: No problem. BTW that also implies also using a build of rustc at master.
[13:43:53] <jakerr> I update my rustc every other day or so.
[13:44:18] <zofrex> tiffany: in theory a NPE can be contained to the thread it occurs in in Java too, but writing software that is robust enough to lose a thread and keep working is a very difficult challenge
[13:44:19] <Matthias247> tiffany: but for most applications a half-alive application would probably be even worse than a completely crashed one
[13:44:26] <nooblit> module names are separated with double-colon (::) what are modules?
[13:44:37] <Matthias247> tiffany: I don't think most applications would restart single tasks
[13:44:58] <tiffany> not necessarily
[13:45:10] <tiffany> for something like a web server, having one client request topple the whole web server is somewhat of a disaster
[13:45:36] <tiffany> there are cases in which a single process has some significantly isolated components that function without each other
[13:45:43] <Matthias247> yes, there are cases where you want to recoer
[13:45:44] <Matthias247> recover
[13:46:05] <Matthias247> but e.g. in a game when one task is dead you are probably messed up anyway
[13:46:53] <jakerr> nooblit: They are a way to organize your code into logical groups. See: http://static.rust-lang.org/doc/master/tutorial.html#crates-and-the-module-system
[13:47:04] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[13:47:13] *** Quits: alexherbo2 (alexherbo2@moz-5686FDD1.w83-199.abo.wanadoo.fr) (Quit: WeeChat 0.4.3-dev)
[13:47:34] <nooblit> I just thought of something, the only reason c++ would be easier is if you are writing unsafe code in c++? Is this a correct
[13:48:08] <doomlord_> i'll give you one observation... i find rust can be harder work naming
[13:48:09] <FliPPeh> unsafe { } is always an option
[13:48:24] <nooblit> I don't want unsafe
[13:48:27] <zofrex> In my opinion, which is heavily coloured by me learning C early in my life, C and C++ have a 'model' for how the computer and programming language works which is relatively simple to understand, and create abstractions and metaphors to help one reason about it
[13:48:35] <doomlord_> basically in C++ you can overload without needing to name a trait, also you can 'overload' on multiple parameters - thats what I personally find 'easier' in C++
[13:48:39] <zofrex> and the 'model' for programming in Rust I find much harder to wrangle in my head
[13:48:49] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[13:49:00] <eddyb> zofrex: that excuse about C is also used by Haskell
[13:49:09] <eddyb> "functional is so much easier to reason about"
[13:49:33] <FliPPeh> It can be
[13:49:39] <nooblit> doomlord_ I take it overload without needing to name a trait is considered hazardous ?
[13:49:44] <zofrex> I found that somewhat true for Haskell too, it mapped to other things I already understood quite well
[13:49:46] <doomlord_> i like the idea of haskell but always can't be bothered persevering without simple structure access "foo.bar"
[13:49:50] <zofrex> Perhaps I just haven't found the right mapping for rust
[13:50:08] <doomlord_> nooblit - it isn't hazardous at all, but traits have other advantages (clearer error messages)
[13:50:15] <tiffany> lambda calculus is arguably the easiest to reason about
[13:50:21] <FliPPeh> doomlord_: That's why many Haskell developers use lenses nowadays
[13:50:56] <nooblit> Does Rust do recursion instead of loops like Scala?
[13:51:04] <doomlord_> no its loops
[13:51:08] <eddyb> nooblit: not really
[13:51:11] <FliPPeh> But you can.
[13:51:26] <eddyb> as long as you make sure you don't have destructables on the stack
[13:51:30] <eddyb> those mess up TCO
[13:51:32] <tiffany> rust does not guarantee tail call optimization, so infinite loops will eventually stack overflow if you aren't careful
[13:51:34] <FliPPeh> Come to think of it, does the current rustc have tail call optimization?
[13:51:48] <FliPPeh> hah
[13:51:49] <tiffany> llvm has tail call optimization, but it isn't perfect
[13:51:53] <eddyb> FliPPeh: we never had and maybe never will any special behavior for TCO
[13:52:08] <FliPPeh> That's okay, we have loops
[13:52:21] *** Quits: alonlevy (alon@C646CF2A.423BDA8F.692B9746.IP) (Ping timeout)
[13:52:30] <SiegeLord> Can Rust ever have computed goto's?
[13:52:33] <eddyb> FliPPeh: if LLVM can optimize away everything between the call and the return of the function, and it meets the tail call requirements, it will be a tail call
[13:52:39] *** Quits: q66 (q66@moz-30F47C55.range86-151.btcentralplus.com) (Quit: Leaving)
[13:52:42] <eddyb> SiegeLord: why'd you want those for?
[13:52:59] <eddyb> they sound highly dangerous
[13:53:01] <Matthias247> however I really don't understand all the ramblings about recursion and TCO. The number of recursive functions I had in all of my programs tends towards 1%
[13:53:02] <SiegeLord> Some people find them very efficient for certain tasks
[13:53:11] *** Quits: gwty (gwtypc@2D0C08FA.3AF9C23B.45DA6411.IP) (Ping timeout)
[13:53:18] <tiffany> gotos are nice for writing state machines
[13:53:20] <FliPPeh> I use gotos in C for error handling only
[13:53:33] <tiffany> and I use state machines more in rust than anywhere else
[13:53:34] <FliPPeh> But with RAII and friends in Rust you don't need that
[13:53:39] <Matthias247> fib(n) is no real world use-case
[13:53:48] <eddyb> tiffany: we have matching in Rust
[13:53:48] <SiegeLord> http://eli.thegreenplace.net/2012/07/12/computed-goto-for-efficient-dispatch-tables/
[13:54:04] *** Joins: new_one (new_one@C6CC5851.CCA5821A.B3C0173E.IP)
[13:54:20] <tiffany> pattern matching is not a replacement for state machines
[13:54:27] <nooblit> Someone on the D forms wanted to use LLVM for the D lang but it was too much of a hassle. What is the diffference between LLVM and other types? LLVM have any perks?
[13:54:42] <FliPPeh> LLVM D compiler is a thing tho
[13:54:53] <FliPPeh> I used the LLVM based ldc compiler
[13:55:08] *** Quits: cgaebel (clark@ADA4DDE2.290DF317.EE6E63A5.IP) (Ping timeout)
[13:55:14] *** Ms2ger|omw is now known as Ms2ger|lafontaine
[13:55:15] *** Joins: q66 (q66@moz-30F47C55.range86-151.btcentralplus.com)
[13:55:17] <SiegeLord> It works great... faster than rustc too ;)
[13:55:17] <eddyb> SiegeLord: how do function calls compare to that?
[13:55:42] <tiffany> llvm is by far the easiest way for your language to come within 90% of the speed of C on benchmarks
[13:56:10] <nooblit> The more i hear about Rust the more I like it.
[13:56:16] <eddyb> SiegeLord: I can see tail calls to functions being as efficient
[13:56:31] <SiegeLord> Maybe
[13:57:12] <eddyb> SiegeLord: thanks for the link anyways, it's relevant to what I'm working on (inflate and its dynamic huffman tables)
[13:57:15] <SiegeLord> I'm not an expert on them, but I've seen them used in C for the last bit of performance
[13:57:50] *** Joins: nszceta (hax@moz-E6CA8D6.hsd1.pa.comcast.net)
[13:57:52] <patpat> rusti: let test1 = 10; static test2 = test1 + 5;
[13:57:53] -rusti- <anon>:10:38: 10:39 error: expected `:` but found `=`
[13:57:53] -rusti- <anon>:10         let test1 = 10; static test2 = test1 + 5;
[13:57:53] -rusti-                                                ^
[13:57:53] -rusti- application terminated with error code 101
[13:57:56] <eddyb> though I've decided that a table of generic functions specialized for the right values is too much of a cost, at least for the initial implementation
[13:58:05] <patpat> oh yeah
[13:58:12] <eddyb> patpat: a static can only refer to other statics and you also need a type
[13:58:34] <SiegeLord> I wouldn't know if Rust makes you a better C++ programmer
[13:58:44] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[13:58:56] <FliPPeh> Possibly a better programmer at least
[13:59:01] <SiegeLord> Porting a D program to C++ atm after having used Rust for a bit... I can't really channel much Rust into it
[13:59:02] <FliPPeh> As does learning any new language
[13:59:20] <patpat> yup, why can you not initialize a static with the current value of a variable?
[13:59:30] <SiegeLord> The const system is too different, for one
[13:59:37] *** Joins: jvoorhis (jvoorhis@moz-84A91726.ptld.qwest.net)
[13:59:38] <doomlord_> but is that with D as a starting point... what about writing a new C++ program, having rust shape your thinking
[13:59:49] <Matthias247> SiegeLord: you probably think abit more on lifetimes. Even if you don't explicitely see them
[13:59:55] *** Joins: alan_andrade (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net)
[14:00:10] <nooblit> Once Rust is stable and has more libraries, do you think Rust will be fast enough for 3d type games since you can do manual memory management like c++?
[14:00:16] <Matthias247> SiegeLord: or you know that sharing mutable data can cause problems
[14:00:18] <SiegeLord> Maybe... my experience is "I'm glad I don't have naggy-mc-nag rustc nagging me about them"
[14:00:23] <tiffany> rust is already fast enough for it
[14:00:26] <tiffany> the problem is library support
[14:00:29] <doomlord_> nooblit rust is fast enough for 3d games for sure, it can match C
[14:00:48] <SiegeLord> On the other hand, I feel like I'm writing a house of cards
[14:00:50] *** Quits: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net) (Quit: dave1629)
[14:01:18] <doomlord_> nooblit - i am still faster coding with C++ because of tools support (IDE) and just plain familiarity
[14:01:21] <FliPPeh> Python also is fast enough for 3D games if you are smart about it
[14:01:24] <patpat> rusti: let test1: int = 10; static test2: int = (5 + test1);
[14:01:25] -rusti- <anon>:10:55: 10:60 error: attempt to use a non-constant value in a constant
[14:01:25] -rusti- <anon>:10         let test1: int = 10; static test2: int = (5 + test1);
[14:01:25] -rusti-                                                                 ^~~~~
[14:01:25] -rusti- error: aborting due to previous error
[14:01:26] -rusti- application terminated with error code 101
[14:01:28] *** Quits: jvoorhis (jvoorhis@moz-84A91726.ptld.qwest.net) (Ping timeout)
[14:01:35] <tiffany> the problem with rustc's nagging is that sometimes there are no ways around it; I haven't worked on my programming language implemented in rust in a while because of a compiler bug
[14:01:38] <doomlord_> but i'm an ex-game programmer, and RUst interests me in light of C++ problems i've seen for real
[14:01:44] *** Joins: tcreate (tcreate@moz-90E5C923.hsd1.ma.comcast.net)
[14:02:13] <SiegeLord> I think the nagging is a good thing, but I can't deny is sometimes gets annoying ;)
[14:02:31] <tiffany> the issue I had where I was causing rustc to crash has been fixed though, at least
[14:02:38] <tiffany> now it just prints an error about infinitely recursive types
[14:02:45] <patpat> rusti: let test1: int = 10; let test2: ~[int] = ~[0, ..test1];
[14:02:46] -rusti- <anon>:10:57: 10:62 error: expected constant integer for repeat count but found variable
[14:02:46] -rusti- <anon>:10         let test1: int = 10; let test2: ~[int] = ~[0, ..test1];
[14:02:47] -rusti-                                                                   ^~~~~
[14:02:47] -rusti- error: aborting due to previous error
[14:02:47] -rusti- application terminated with error code 101
[14:03:02] <patpat> hmm
[14:03:19] *** Quits: alan_andrade (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net) (Ping timeout)
[14:03:29] <eddyb> patpat: we don't have VLAs
[14:03:31] <nooblit> tiffany Cool so it's already really fast, someone on another site said that once Rust has been stable version, that the devs would be tweaking performance stuff and it would be faster later after most of the things are worked out more time can be given to increase performance even more. 
[14:03:46] <patpat> eddyb: ah, ok
[14:03:55] <tiffany> rustc itself applies no optimizations right now, everything is done by llvm
[14:04:00] <tiffany> afaik
[14:04:34] *** victorporof_|away is now known as victorporof_
[14:05:14] <patpat> eddyb: Will rust support VLAs in future?
[14:05:30] *** Joins: vertexclique (vertexcliq@5682FAC6.F2420704.951DB911.IP)
[14:05:40] <eddyb> patpat: there are some strong reasons against them
[14:05:45] <patpat> oh
[14:05:52] <eddyb> (botching optimizations)
[14:06:04] <nooblit> Hey since everything has a "safe" standardized way of writing programs, wouldn't that just make it easier for compiler optimizations? 
[14:06:25] <tiffany> in some cases it does
[14:06:33] <sp3d> there are some fairly cool optimizations that are theoretically possible but not yet implemented
[14:06:42] <tiffany> rust's iterators currently optimize down to C-for-loops-or-better
[14:06:48] <nooblit> Like the compiler can detect the the entire thing is safe, so it can make certain deductions about the code.
[14:08:00] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Connection reset by peer)
[14:08:57] <nooblit> sp3d I really hope when the devs have time, they will focus on those performance optimizations. 
[14:08:58] *** Joins: moostik (Icedove@moz-133D2136.w92-139.abo.wanadoo.fr)
[14:09:22] *** Quits: adridu59 (Mibbit@moz-E1FF077C.rev.numericable.fr) (Quit: http://www.mibbit.com ajax IRC Client)
[14:09:23] <dbaupp> sp3d: such as?
[14:09:32] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[14:09:45] *** Joins: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[14:10:31] <Matthias247> nooblit: why do you focus so much on performance? performance is propably one of the least problems that rust has
[14:11:12] <sp3d> dbaupp: e.g. aliasing analysis, maybe at some point in the future discriminant combination
[14:11:23] <dbaupp> sp3d: tbaa would be awesome
[14:11:28] <sp3d> truth
[14:11:32] *** Quits: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net) (Ping timeout)
[14:11:51] <nooblit> Matthias247 I'm completely ignorant of the state of Rust at this time, as I have no programming experience, I suppose I like the idea of a fast language as a matter of taste, like people like sports cars.  
[14:11:52] <SiegeLord> Would Cell's break aliasing analysis?
[14:11:52] <dbaupp> I don't see how discriminant combination can work and allow taking references to the interior, though.
[14:12:09] *** Quits: jdm (jdm@moz-DB4A9C19.scl3.mozilla.com) (Quit: Lost terminal)
[14:12:12] <sp3d> it wouldn't be trivial
[14:12:16] <dbaupp> SiegeLord: tbaa would have to handle that (or something)
[14:12:28] <dbaupp> SiegeLord: at the very least, tbaa could just apply to Freeze values
[14:12:35] <SiegeLord> I see
[14:12:52] <sp3d> but it would be more feasible for private enums where all the use cases can be individually tweaked
[14:13:07] <zofrex> tiffany: could TCO guarantees replace your need for gotos when writing state machines?
[14:13:33] <tiffany> there are replacements for goto - in my current code using gotos, it's just functions which call each other, which likely wastes stack space
[14:13:35] *** Quits: markos (markos@3A6075EE.3EF83E22.692B9746.IP) (Ping timeout)
[14:13:55] <tiffany> what I could do is have each function representing a state return which state to transition to next, and have a function which automatically calls it
[14:14:18] <eddyb> zofrex: forcing 0/minimal stack usage would be better IMO
[14:14:19] <sp3d> it seems like in the interpreter-mainloop computed goto case a sufficiently smart compiler could generate similar code for a match of the right form?
[14:14:29] <nooblit> Matthias247 also I suppose if the speed could be faster than c++ perhaps the mainstream would adopt it and game engines would be developed for it, if it was adopted by industry that can only increase the productivity in fixing any issues Rust has. 
[14:14:39] <FliPPeh> nooblit: For almost all intents and purposes, Rust is even at this point fast enough, the bottleneck is almost never the programming language
[14:14:47] <sp3d> but optimizing match codegen is a pretty complicated beast
[14:14:53] <eddyb> sp3d: oh, yeah, LLVM should totally be able to jump directly instead of changing the state and switching over it again
[14:14:54] <FliPPeh> Same goes for C and C++
[14:15:00] <eddyb> sp3d: not sure if it's implemented
[14:15:58] <nooblit> FliPPeh Is not one of the goals of Rust to be the new c++?
[14:16:10] <FliPPeh> No
[14:16:16] *** Quits: vertexclique (vertexcliq@5682FAC6.F2420704.951DB911.IP) (Ping timeout)
[14:16:20] <kimundi> nooblit: No, Rusts goal is it to be good at things C/C++ is good at
[14:16:33] <kimundi> Not to replace it, but to offer an alternative
[14:16:39] *** Joins: csherratt (csherratt@moz-7685819.cpe.teksavvy.com)
[14:16:42] <kimundi> And its already pretty close
[14:16:46] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Quit: TheHydroImpulse)
[14:16:52] <Matthias247> nooblit: That won't work. As soon as other issues aren't fixed and the language/library is not stable nearly nobody will adopt it, even it is ultra-high performance. And this is not speccific about rust but matters for all kind of technologies
[14:17:15] <FliPPeh> D is for many things a better C++ and it's not mainstream
[14:17:27] <kimundi> People are already starting to write game engines and operating system kernels in Rust, its just nothing major yet
[14:17:46] <FliPPeh> It's more than the speed of a language that makes it a success
[14:18:02] *** Quits: csherratt (csherratt@moz-7685819.cpe.teksavvy.com) (Quit: csherratt)
[14:18:02] *** Quits: tryzor (bzlandfill@moz-9D6F2D3.dip0.t-ipconnect.de) (Quit: CGI:IRC (EOF))
[14:18:06] <FliPPeh> It's the whole infrastructure and tooling that makes or breaks a language
[14:18:21] <FliPPeh> And C++ had decades to build up to that
[14:18:23] *** Joins: vertexclique (vertexcliq@52D48DF9.67763579.951DB911.IP)
[14:18:29] <Matthias247> yes, therefore Java/C# are extremely successful. Despite being slower than C++
[14:18:30] <nooblit> I read they put the GC in the library to target the same market as c++ is in.
[14:18:40] *** Joins: csherratt (csherratt@moz-7685819.cpe.teksavvy.com)
[14:18:50] *** Quits: Seb (Seb@moz-97344273.actrix.co.nz) (Client exited)
[14:18:52] *** Joins: lenstr (lenstr@DA24AAD3.9636F313.7A27613B.IP)
[14:19:24] <nooblit> Java/c# are used for different things than c++ from what I understand,
[14:19:32] <tiffany> I intend to write bits of my engine in rust, but the majority of the code is currently in C
[14:19:37] <Matthias247> not necessarily
[14:19:53] <nooblit> mostly
[14:20:03] *** Quits: csherratt (csherratt@moz-7685819.cpe.teksavvy.com) (Quit: csherratt)
[14:20:07] <Matthias247> you can't do an OS in Java. But you can do most applications
[14:20:29] <nooblit> Yes, C#/Java are both used for applications not c++
[14:20:39] <kimundi> c++ is too
[14:20:40] <Matthias247> c++ is also used for applications
[14:20:42] *** Joins: csherratt (csherratt@moz-7685819.cpe.teksavvy.com)
[14:20:57] <Matthias247> probably for 80% of all desktop applications
[14:20:58] <nooblit> well I mean most of the code would not be for most apps correct?
[14:21:36] <Matthias247> c++ is language designed for doing any kind of programming
[14:21:45] <nooblit> I thought most people write gui or desktop apps in something like C#/Java and only use c/c++ when they need performance?
[14:21:45] *** Quits: mgottschlag (quassel@moz-8A0EB40C.cust.bluewin.ch) (Ping timeout)
[14:21:51] *** Joins: nham (Mibbit@moz-2C6185F8.lightspeed.dybhfl.sbcglobal.net)
[14:21:53] <diverse> FliPPeh: you can't compare C++ to D. D more close to Java, than anything else for what it does.
[14:21:59] <Matthias247> and it is also used therefore
[14:22:03] *** Quits: csherratt (csherratt@moz-7685819.cpe.teksavvy.com) (Quit: csherratt)
[14:22:28] <kimundi> nooblit: Its certainly not "most"
[14:22:43] *** Joins: csherratt (csherratt@moz-7685819.cpe.teksavvy.com)
[14:22:50] <Matthias247> there are not many Java GUI apps
[14:23:06] <kimundi> nooblit: Really, most problems can be solved with most languages, and are.
[14:23:19] *** Joins: alonlevy (alon@C646CF2A.423BDA8F.692B9746.IP)
[14:23:38] <nooblit> Most problems have a laungauge that is suited for it, scripting, apps, C for real time ect
[14:23:49] *** Quits: lenstr (lenstr@DA24AAD3.9636F313.7A27613B.IP) (Client exited)
[14:24:13] *** Quits: csherratt (csherratt@moz-7685819.cpe.teksavvy.com) (Quit: csherratt)
[14:24:23] <kimundi> Well sure, picking the right language for the right job. But there are tons of influencing factors that influence that
[14:24:23] *** Joins: lenstr (lenstr@DA24AAD3.9636F313.7A27613B.IP)
[14:25:06] <diverse> nooblit: C can be used for anything, it's however, due to convenience, it's more _convenient_ to use other languages that make doing the job easier.
[14:25:19] <diverse> that's why you select languages for a certain task
[14:25:28] <nooblit> But in general, i'm incorrect that the majorty of code on most desktop apps wouldn't be written in something higher lvl than c++ and only use a small part of c++ for the performance parts? 
[14:25:52] <nooblit> Why would you write the entire thing in c++?
[14:26:07] *** Quits: lenstr (lenstr@DA24AAD3.9636F313.7A27613B.IP) (Ping timeout)
[14:26:12] <diverse> nooblit: that depends entirely on you
[14:26:19] <FliPPeh> C++ is pretty high level
[14:26:28] <FliPPeh> It has good libraries for desktop development
[14:26:33] <kimundi> nooblit: Its often easier to write something in the same language than to have diffderent languages interact wit each other in the same codebase
[14:27:22] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (No route to host)
[14:27:25] <nooblit> Well, do any of you actually know the % of programs that are made in scripting to the ratio of c++?
[14:27:26] <Matthias247> as I said. most desktop applications are written in C++
[14:27:29] <kimundi> nooblit: For example, what if you want to mix a language that is build entirely on objects with something that doesn't even have them? (Which is the case with C and pretty much most other languages)
[14:27:37] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[14:27:43] *** Quits: tcreate (tcreate@moz-90E5C923.hsd1.ma.comcast.net) (Client exited)
[14:27:51] *** Joins: mib_p0erif (Mibbit@moz-24904900.range86-178.btcentralplus.com)
[14:27:54] *** Joins: tcreate (tcreate@moz-90E5C923.hsd1.ma.comcast.net)
[14:28:16] *** Parts: emerson (Icedove@6F3CD6F5.77F4443F.66AE2FF3.IP) ()
[14:28:43] *** Quits: mib_p0erif (Mibbit@moz-24904900.range86-178.btcentralplus.com) (Quit: http://www.mibbit.com ajax IRC Client)
[14:29:03] <nooblit> Matthias247 well thanks for answering my question, that's interesting. I thought c# would be fast enough to write most desktop apps in and would be easier than c++ so I figured it was either Java or c#.
[14:30:01] <Matthias247> they both would be good enough to write them. But C++ is just so much longer around
[14:30:07] *** Quits: alonlevy (alon@C646CF2A.423BDA8F.692B9746.IP) (Ping timeout)
[14:30:20] <kimundi> nooblit: Random google search result I found: http://langpop.com/
[14:30:24] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[14:30:56] <kimundi> Top 5: C, Java, PHP, JavScript, C++
[14:31:23] *** Quits: NiccosSystem (NiccosSyst@AB1AFDE.FC7B0C35.A7597CB6.IP) (Client exited)
[14:31:50] *** Joins: alonlevy (alon@C646CF2A.423BDA8F.692B9746.IP)
[14:31:51] <nooblit> kimundi	Those google results are no accurate imo take it with a grain of salt, words like the letter C are typed into google or random letters can show up but it is interesting.
[14:32:49] <kimundi> nooblit: Well, you can choose how to weight the sources on that page
[14:33:20] <Matthias247> you could also take this: http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html  But that takes also only into account the current "questions about them" and not how many programs acutally are developed in the languages
[14:34:09] *** Joins: markos (markos@3A6075EE.3EF83E22.692B9746.IP)
[14:35:34] <nooblit> Matthias247 If you were going to write a desktop app for windows, that something simple like a GUI that scanned some files and ordered them and delete some files, would you use c# or c++? 
[14:35:48] <FliPPeh> The problem with C# is, that it's basically Windows only
[14:36:00] <nooblit> Yes , I said for windows
[14:36:01] <diverse> nooblit: you can use either
[14:36:13] <Matthias247> I would most likely use c#
[14:36:20] <kimundi> nooblit: For windows only, visual studio and C# is the obvious choice if its just about getting a fast working result
[14:36:43] <kimundi> But c++ would work as well
[14:37:14] <nooblit> Well that's what I thought too, is why I figured c# was mostly used for desktop GUIs because its easier than c++ for simple things.
[14:37:30] <kimundi> nooblit: desktop gui != windows desktop gui
[14:37:39] <nooblit> most desktops are windows
[14:37:49] <nooblit> so most desktops
[14:37:59] <sp3d> rusti: enum Foo {};
[14:38:01] <Matthias247> If you want to interface with a lot of native libraries in your GUI then c++ might be better
[14:38:01] -rusti- pastebinned 10 lines of output: http://ix.io/ahc
[14:38:14] <Matthias247> or if you want to do cross-platform
[14:38:14] *** Quits: tcreate (tcreate@moz-90E5C923.hsd1.ma.comcast.net) (Client exited)
[14:38:18] <sp3d> yay, ICE
[14:38:46] *** Quits: fyolnish (fyolnish@moz-EF224D80.uqwimax.jp) (Client exited)
[14:38:54] <jxs> hey guys! What usually means the "expansion site" error?
[14:39:05] <FliPPeh> Something exploded in a macro
[14:39:21] <kimundi> jxs: "expansion site" is not a error, it is additional information for the actual error message :)
[14:40:02] <nooblit> I guess what I'm trying to say is, I think on windows desktops, that most of the simple programs that are GUIs, would be logically easier to write using java or c# and things like games and real time stuff would be better with c++, so the way I see it Rusts target is the same as c++s target but they can all do both.
[14:40:26] *** Quits: zofrex (zofrex@moz-92CD32EC.cable.virginm.net) (Quit: zofrex)
[14:40:42] <jxs> oh yeah, i saw now the whole message, thanks
[14:40:46] <nooblit> I thinks Rusts goal should be a better c++.
[14:40:47] <kimundi> nooblit: That would be a correct assertion, I'd say.
[14:41:18] <doomlord_> one reason for looking into rust is the issues with multithreaded code in C++ , rusts safety is potentially a big benefit
[14:41:43] <kimundi> nooblit: Well, Rusts goal is to be good at where C++ is good at - but "replacing with C++" not one of its goals.
[14:41:56] <doomlord_> C++ is here to stay
[14:41:57] <diverse> kimundi: you just said that
[14:42:07] <kimundi> I did?
[14:42:20] <diverse> kimundi: I saw it beening said earlier, yes.
[14:42:28] <kimundi> Ah, yeah that might be
[14:42:53] <diverse> nooblit: quit being picky and just program already
[14:43:02] <kimundi> :D
[14:43:29] <nooblit> So given all of that, that was my reasoning for focusing on speed. In my mind, I was thinking if Rust became faster than c++ it replace it. 
[14:43:40] *** Joins: AvianFlu (AvianFlu@moz-51534E77.c3-0.43d-ubr2.qens-43d.ny.cable.rcn.com)
[14:43:48] <nooblit> diverse I was answering someones question about why i focus on speed, not being picky at all.
[14:44:04] <doomlord_> it wont be faster than C++
[14:44:05] *** Joins: bt3ze (bt3ze@moz-3F0303DA.hsd1.va.comcast.net)
[14:44:08] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[14:44:08] *** ChanServ sets mode: +ao dherman dherman
[14:44:47] *** Quits: jviereck (Adium@moz-56DDD13.dip0.t-ipconnect.de) (Quit: Leaving.)
[14:45:01] <doomlord_> it does the same job as C++ with greater safety
[14:45:36] <nooblit> Well being safe can save big gaming companies allot of time and therefore money if they use Rust for gaming one day.
[14:45:59] <FliPPeh> That can take a few decades
[14:46:00] <doomlord_> big companies have established C++ sourcebases
[14:46:03] <FliPPeh> ^
[14:46:06] <strcat> a language could easily be faster than C or C++ by focusing on giving more guarantees to the backend, but rust isn't that language
[14:46:08] <doomlord_> its something for pioneers to jump on
[14:46:20] <FliPPeh> Also, it's not a language that is fast
[14:46:24] <Matthias247> it's a tradeoff. You also need to take general development speed into account
[14:46:25] <FliPPeh> It's the implementation
[14:46:33] <Matthias247> and having people that understand that language
[14:46:34] <kimundi> Rust can in theory become a little bit faster than C++ in some areas, due to better guarantees for the optimizing compiler, but in others it will likely be a bit slower for safety reasons. All in all, it will probably simply be on the same level with C++
[14:46:39] <strcat> FliPPeh: so rust on LLVM vs. C/C++ on LLVM then
[14:46:47] <doomlord_> in C++ you have 'restrict' , its just a PITA sometimes
[14:46:49] <strcat> rust doesn't really have the ability to be faster
[14:46:59] <strcat> doomlord_: restrict isn't enough
[14:47:31] <strcat> you can have a language with SIMD vectors, an effects system (with the ability to make a promise to the compiler), rewrite rules and other performance-oriented features
[14:47:38] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[14:47:52] <doomlord_> ^ ok restrict *plus intrinsics* is how gamedeveloppers use C++
[14:48:07] <doomlord_> it works,  its just a PITA
[14:48:10] <FliPPeh> plus customized standard libraries, debuggers and tools
[14:48:13] *** Joins: nawfel (Mibbit@3E12675.5E872927.DFAB1F33.IP)
[14:48:32] <FliPPeh> and low level CPU and GPU features
[14:48:40] <FliPPeh> inline assembly, ...
[14:48:46] <doomlord_> generally we had CPU's that were too new to count on having good compiler support , in games
[14:48:58] <doomlord_> of course now thats changed that they've gone to x86
[14:49:23] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[14:49:38] <nooblit> I wish we could use this http://www.youtube.com/watch?v=00gAbgBu8R4 "unlimited polygons" 
[14:49:49] <nawfel> please strcat , teach rusti how to compile PastBins
[14:49:59] <strcat> nawfel: ?'
[14:50:02] <FliPPeh> I haven't seen anything come out of that project
[14:50:10] <strcat> I'm not going to have rusti making http requests on behalf of people :P
[14:50:17] *** Joins: Sorella (queen@9D963F5D.DF5D8AE7.54BCAB54.IP)
[14:50:44] <doomlord_> nooblit, IMO polygons will remain because of animation, but pointclouds are great for scanned content
[14:50:51] <nooblit> It's a video about having unlimited polygon count.
[14:51:03] <doomlord_> nooblit, you can still get normal mapped polygonal aproximations, displacement maps for polygon engines
[14:51:18] *** Joins: tcreate (tcreate@moz-90E5C923.hsd1.ma.comcast.net)
[14:51:21] <doomlord_> but all the pointcloud tools would be great ways of sourcing content
[14:51:44] <jxs> i think it would be awesome to see that on the doc, kimundi the tradeoffs between c++ and rust :P
[14:51:47] <tiffany> nooblit: they copletely gave up on trying to use it as tech for games, and backpedaled on their claims about how powerful it was
[14:52:02] <doomlord_> yeah polygons are here to stay, IMO
[14:52:13] <FliPPeh> here to shrink*
[14:52:15] <tiffany> currently, they're looking into selling a product to displace the current sad state of point cloud geographical data viewers
[14:52:27] <nooblit> tiffany I don't know why, they are selling this for map data right now
[14:52:41] <nooblit> guess they couldn't get it to work for us?
[14:52:53] <tiffany> the marketing hyped it as something it wasn't
[14:52:54] <doomlord_> game scenes are more dynamic 
[14:53:03] <doomlord_> nooblit character animation is really imporant
[14:53:18] *** Quits: victorporof_ (victorporo@53EBB099.7C27E871.79933D60.IP) (Quit: victorporof_)
[14:53:19] <doomlord_> you need good topology for animation
[14:53:30] <strcat> I'll be happy just to get rust performing as well as C with minimal application of `unsafe`
[14:53:35] <tiffany> it would be impossible for their tech to handle dynamic scenes
[14:53:57] <nooblit> couldn't you do the world in scan and just do the character as animation? 
[14:54:07] <strcat> the non-null issue is a big one
[14:54:09] <patpat> nooblit: That video seems ridiculous
[14:54:19] <doomlord_> nooblit the worlds would still want repeats usually
[14:54:32] <doomlord_> nooblit, scanned means having everything unique, which is a huge amount of data
[14:54:44] <tiffany> it's just not a very practical thing to be putting in a game
[14:54:55] <doomlord_> carmac's rage engine tried unique everywhere as its USP, and it wasn't compelling
[14:55:02] <doomlord_> it was a valid experiment sure
[14:55:12] <tiffany> if you want a huge amount of detail but don't really care about the harddrive space, you should be looking into sparse voxel octrees and megatextures
[14:55:26] <doomlord_> game artists are skilled at approximating scenes with repeating layered textures...
[14:55:31] <doomlord_> instanced models..
[14:56:03] <doomlord_> also you need objects to be marked up with surface properties... how they react when shot etc, so just plain scanning isn't as  useful as you might think
[14:56:14] <jakerr> is match the only way to get at tuple elements?
[14:56:14] *** Joins: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net)
[14:56:28] <jakerr> I have a tuple and want to return the second element.
[14:56:32] *** Quits: tcreate (tcreate@moz-90E5C923.hsd1.ma.comcast.net) (Client exited)
[14:56:32] <kimundi> Besides, with VR on the horizon pure graphic fidelity will become less important than high framerates
[14:57:01] *** Joins: tcreate (tcreate@moz-90E5C923.hsd1.ma.comcast.net)
[14:57:11] <jakerr> And I wrote this: return match my_tuple { (_, ret) => ret }
[14:57:17] <jakerr> Looks a bit ug
[14:57:32] <kimundi> jakerr: let (_, ret) = tup;
[14:57:55] <jakerr> Ah ok let :)
[14:57:56] <jakerr> Thanks
[14:58:30] <kimundi> jakerr: also, we have accesors implemented on tuples ;)
[14:58:32] *** Joins: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net)
[14:58:41] *** Quits: tcreate (tcreate@moz-90E5C923.hsd1.ma.comcast.net) (Ping timeout)
[14:58:42] <kimundi> rusti: (1u, 2u).n1()
[14:58:43] -rusti- 2u
[14:58:54] <jakerr> Ah even better!
[14:58:56] <kimundi> (Ugly, but short)
[14:59:04] <jakerr> How many ns do we have ;)
[14:59:06] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[14:59:12] <diverse> jakerr: 12
[14:59:16] <kimundi> jakerr: i THINK UP TO 12, 13
[14:59:18] *** Joins: awidegreen (awidegreen@moz-9FADBE94.a357.priv.bahnhof.se)
[14:59:19] <kimundi> whoops
[14:59:21] <FliPPeh> Ugh, it's haskell all over
[14:59:27] *** Quits: vertexclique (vertexcliq@52D48DF9.67763579.951DB911.IP) (Ping timeout)
[14:59:28] *** Quits: nawfel (Mibbit@3E12675.5E872927.DFAB1F33.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[14:59:40] <FliPPeh> With typeclass instances for (a, b), (a, b, c), (a, b, c, d), ...
[14:59:45] <strcat> FliPPeh: worse, since there's more than one kind of n
[14:59:46] <jakerr> rusti: (1,2,3,4,5,6,7,8,9,10,11,12).n11()
[14:59:48] -rusti- 12
[14:59:48] *** Joins: vertexclique (vertexcliq@1F8F5B47.125B31C4.6F578A69.IP)
[14:59:54] <jakerr> rusti: (1,2,3,4,5,6,7,8,9,10,11,13).n12()
[14:59:56] -rusti- pastebinned 5 lines of output: http://ix.io/ahe
[14:59:57] <strcat> FliPPeh: at a minimum, you need & and &mut
[14:59:58] <strcat> but...
[15:00:02] <jakerr> hehe yep 12
[15:00:06] *** Joins: LinearInterpol (RJones@moz-E6F82C3A.maine.res.rr.com)
[15:00:09] <strcat> for some reason it is implemented as doing it by-value for 'n1'
[15:00:17] <strcat> so that means it's going to end up having 3 methods
[15:00:22] *** Joins: jvoorhis (jvoorhis@moz-84A91726.ptld.qwest.net)
[15:00:47] <sp3d> shouldn't we be able to use macros for this?
[15:00:49] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[15:00:55] <strcat> it does use macros
[15:01:02] <strcat> it doesn't make it any less bad for users of the code
[15:01:10] <FliPPeh> Still better than C++ tho
[15:01:17] <strcat> what makes it better than C++?
[15:01:19] <FliPPeh> std::get<0>(tup)
[15:01:24] <FliPPeh> std::get<1>(tup)
[15:01:24] <sp3d> I thought macros had '!' in them
[15:01:26] <FliPPeh> ...
[15:01:31] *** Quits: tiffany (kawaii@moz-FC0DB29D.dhcp.embarqhsd.net) (Input/output error)
[15:01:40] <strcat> FliPPeh: that's better than needing n functions up to an arbitrary limit
[15:01:50] <strcat> std::get could be defined as a tuple method
[15:01:53] <FliPPeh> Yes, but I was going from an interface perspective
[15:02:02] *** Quits: jvoorhis (jvoorhis@moz-84A91726.ptld.qwest.net) (Ping timeout)
[15:02:05] <kimundi> The only nice short way to give value, ref, mut ref for indices of arbitrary sized tuples is explicit syntax support. Only alternatively is to pattern match all the time.
[15:02:08] <FliPPeh> .nN does look somewhat better
[15:02:09] <strcat> FliPPeh: x.n<0>()
[15:02:32] <strcat> and C++ doesn't need to have both n and n_mut
[15:02:45] <strcat> atm rust has n working by-value so it needs n_ref and n_mut_ref
[15:02:50] <strcat> n_mut_ref_1
[15:02:52] <strcat> great
[15:02:57] <FliPPeh> yuck
[15:03:17] *** Joins: alan_andrade (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net)
[15:03:49] <strcat> anyway I think the by-value n methods need to be removed
[15:03:53] <strcat> should only have by-ref and by-mut-ref
[15:04:13] <kimundi> I think trying to solve this with existing rust syntax and typesystem features is just a non-starter. The current implementation is just a convenience hack, but I don't see it as the final solution.
[15:04:20] <nooblit> Why did they name it Rust?
[15:04:36] <FliPPeh> Why didn't they name it not Rust?
[15:04:41] <strcat> nooblit: graydon said it was named after https://en.wikipedia.org/wiki/Rust_(fungus)
[15:05:01] <nooblit> strcat Thank you 
[15:05:08] <strcat> don't know _why_
[15:05:30] <kimundi> Well, naming is hard :P
[15:05:36] <diverse> Rust is a language you can tRust
[15:05:43] <nooblit> Lol
[15:05:53] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[15:05:54] <nooblit> They should change it to Trust
[15:05:57] *** Quits: alan_andrade (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net) (Ping timeout)
[15:06:00] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[15:06:11] <FliPPeh> "Rust" really doesn't instill a sense of stability
[15:06:41] <jxs> kimundi, or is there any doc at all describing rust safety design decisions to avoid c++ pitfalls?
[15:06:48] <nooblit> when I first herd the name, it brings pictures of brown or old junk.
[15:06:49] <strcat> jxs: no
[15:07:09] <jxs> ok
[15:07:43] <dwrensha> rust makes bare metal less pointy
[15:07:45] <jakerr> So the talk about recursion and lack of tail-call-optimization made me want to write fib iteratively in rust and see how expressive I could make it:
[15:07:48] <jakerr> https://gist.github.com/jakerr/09c35e4021ba45a3a06c
[15:08:23] *** Joins: mgottschlag (quassel@moz-3E841DE2.cust.bluewin.ch)
[15:08:35] *** Joins: tcreate (tcreate@moz-90E5C923.hsd1.ma.comcast.net)
[15:08:50] <kimundi> jakerr: Heh, nice.
[15:09:01] *** Joins: fyolnish (fyolnish@moz-EF224D80.uqwimax.jp)
[15:09:08] *** Joins: kellogh (timkellogg@moz-704A74D.hsd1.co.comcast.net)
[15:09:34] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[15:09:54] <jakerr> kimundi: thx :)
[15:10:04] *** Joins: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[15:10:37] *** Quits: new_one (new_one@C6CC5851.CCA5821A.B3C0173E.IP) (Client exited)
[15:11:10] *** Quits: jackneill (jackneill@moz-F643C3DE.pool.digikabel.hu) (Quit: WeeChat 0.4.2)
[15:11:31] *** Joins: jackneill (jackneill@moz-F643C3DE.pool.digikabel.hu)
[15:11:38] *** Quits: KindOne (KindOne@moz-BF98147F.dynamic.ip.windstream.net) (Ping timeout)
[15:11:51] *** Quits: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net) (Ping timeout)
[15:13:18] *** Quits: nszceta (hax@moz-E6CA8D6.hsd1.pa.comcast.net) (Ping timeout)
[15:14:18] *** Parts: jakerr (jakerr@moz-1095CD08.kanagawa.ocn.ne.jp) (Textual IRC Client: www.textualapp.com)
[15:14:29] <FreeFull> I wonder if you could write fib as an infinite iterator
[15:14:42] <strcat> yes
[15:14:51] <strcat> although you need big integers
[15:15:03] <strcat> and I doubt you want to use the libextra implementation ;p
[15:15:16] <nooblit> This probably isn't practical but I did have an idea how to make Rust faster than c++, you could make it run off a GPU built into the language?
[15:15:31] <strcat> huh?
[15:15:40] *** Joins: KindOne (KindOne@moz-59654FDC.dynamic.ip.windstream.net)
[15:16:02] <nooblit> Make it where the programs you write, use the power of the graphics card.
[15:16:07] <strcat> you can't just apply a GPU as an optimization to arbitrary code
[15:16:10] <nooblit> built into the lang
[15:16:39] <Tobba> does rust have any good way to send http requests yet
[15:16:52] *** Quits: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net) (Input/output error)
[15:16:54] <strcat> Tobba: depends what you mean by good
[15:16:59] <Tobba> nooblit: not even going to explain how stupid this is
[15:17:09] <strcat> if need proxy support and https, I think you're going to be stuck with libcurl
[15:17:42] <Tobba> also you have to realize
[15:17:44] <nooblit> Tobba I'm sure I wouldn't understand anyway Tobba
[15:17:54] <Tobba> GPUs are SHITE at basicaly everything other than rendering and mining bitcoins
[15:18:08] <strcat> Tobba: well, and they're no good at mining scrypt cryptocurrency
[15:18:18] <strcat> that's the intent of scrypt though
[15:18:18] <Tobba> still better than CPUs afaik
[15:18:29] <Tobba> that was the intent yes
[15:18:30] <Matthias247> Tobba: there's rust-http. But depending on your requirements it may not be a good way
[15:18:31] <FreeFull> strcat: Not sure how you'd make a recursive iterator though
[15:18:40] <Tobba> the problem is the proof of work itself
[15:18:51] <Tobba> no matter how you put it its an infinitely parallelised problem
[15:18:52] *** Joins: csherratt (csherratt@moz-7685819.cpe.teksavvy.com)
[15:18:58] <strcat> FreeFull: recursion and iteration can express the same things
[15:19:04] <Tobba> which means GPUs will always beat CPUs, afaik all scrypt really did was have high memory requirements etc
[15:19:12] <strcat> no reason you need recursion for that
[15:19:30] <FreeFull> strcat: I'm thinking something like translating    fibs = 0:1:zipWith (+) fibs (tail fibs)   into Rust
[15:19:51] <strcat> implement the standard naive fibonacci function
[15:19:58] <strcat> the iterative version
[15:20:09] <strcat> take the body and put it in a next function with the state in self
[15:20:11] <strcat> done
[15:20:16] <Tobba> ugh
[15:20:24] <FreeFull> That's not the same
[15:20:29] <nooblit> Tobba http://www.extremetech.com/computing/160367-new-programming-language-makes-turning-gpus-into-supercomputers-a-snap
[15:20:40] *** Quits: csherratt (csherratt@moz-7685819.cpe.teksavvy.com) (Quit: csherratt)
[15:20:46] <nooblit> New programming language makes turning GPUs into supercomputers a snap
[15:20:50] <FreeFull> The goal is more how it's done than having an iterator of fibs
[15:20:51] <Tobba> that title
[15:21:02] <Tobba> whoever wrote this should impale themselves on a spike, stat
[15:21:07] <nooblit> Lol
[15:21:29] <FreeFull> It's clearly not how it works
[15:22:05] <FliPPeh> You can assume that all articles like that are full of crap
[15:22:38] <Tobba> maybe a language designed for it could make things easier and give a super tiny speedup
[15:22:47] <Tobba> but properly written OpenCL code will work just as well
[15:22:47] <nooblit> Dam, they always get my hopes up then if find out is BS
[15:23:07] <FliPPeh> Tech journalists are good at building hype with bullshit
[15:23:11] <FreeFull> We already have OpenCL, CUDA and Accelerate
[15:23:18] <FliPPeh> It's all they do since they have no hands on experience at all
[15:23:25] <FliPPeh> And only go by what is marketed to them
[15:23:40] <Tobba> harlan seems to be some lisp-ish functional language aka ((((((((((((((()))))))))))))))
[15:24:07] <FreeFull> I swear there was another lispish language that already did what harlan claims to do
[15:24:17] *** Quits: achim (achim@moz-30EA2B29.dip0.t-ipconnect.de) (Quit: ["Textual IRC Client: www.textualapp.com"])
[15:24:34] <Tobba> what does harlan even claim to do
[15:24:50] <Tobba> from what I can read its designed to be simple as a research thing
[15:24:56] *** Quits: kellogh (timkellogg@moz-704A74D.hsd1.co.comcast.net) (Quit: kellogh)
[15:25:16] <eddyb> have I see eholk around?
[15:25:36] *** Joins: m_kato (chatzilla@moz-8B47AE65.tokynt01.ap.so-net.ne.jp)
[15:25:53] <Matthias247> even if you had a programming language that would run concurrently on CPU and GPU - you would at first need software that could utilize it
[15:26:20] <nooblit> " "Harlan – a declarative programming language that simplifies development of applications running on GPU" That's what I could find 
[15:26:33] <eddyb> https://github.com/eholk/harlan
[15:26:35] <Matthias247> and dividing software reasonably into parallel constructs is hard
[15:26:38] <eddyb> s/see/seen/
[15:26:47] <Tobba> nooblit: GPUs are basicaly like if you took a few thusand really shitty and simple processors smacked together into one chip
[15:26:57] *** Joins: canhtak (canhtak@moz-8A625E1D.wl.t.ulaval.ca)
[15:27:17] * strcat is tempted to make a thin veneer over LLVM IR making it possible to write it by hand without going insane
[15:27:23] <FliPPeh> Good at simple math and that's it
[15:27:27] *** Joins: csherratt (csherratt@moz-7685819.cpe.teksavvy.com)
[15:27:29] <Tobba> not even that
[15:27:34] <Tobba> it takes like 4 cycles to multiply two numbers
[15:27:41] <FliPPeh> Fast at simple math*
[15:27:43] <Tobba> (on most GPUs)
[15:27:51] <FreeFull> GPUs are good at floating point
[15:28:00] <Tobba> eh
[15:28:03] <FreeFull> Bad at anything involving branches
[15:28:16] <Tobba> they mostly have dedicated floating point calc stuff yeah
[15:28:24] <nooblit> Isn't there some kind of net gain in performance the more you add compared to one more powerful cpu?
[15:28:33] <Tobba> they also only have one instruction decoder per like, 32 cores
[15:28:43] <Tobba> or well, more like 32 ALUs in one core, but anyways
[15:28:44] <FliPPeh> If you have lots of numbers to crunch, sore
[15:28:46] <FliPPeh> sure even
[15:28:52] *** Quits: csherratt (csherratt@moz-7685819.cpe.teksavvy.com) (Quit: csherratt)
[15:28:55] <FliPPeh> But they are useless for general purpose computing
[15:29:10] <FreeFull> I'm looking forward to the mill architecture, but that is still years away
[15:30:01] <Tobba> actually, a good description of what GPUs are good at is probably "big mapreduce operations"
[15:30:29] *** Quits: alonlevy (alon@C646CF2A.423BDA8F.692B9746.IP) (Ping timeout)
[15:31:14] <SiegeLord> They're not so good at the reduce bit, heh
[15:31:27] <Tobba> it depends tbh
[15:31:27] *** Joins: kris (kris@moz-6D20263F.fullrate.dk)
[15:31:45] <Tobba> if you're doing rendering they can reduce just fine
[15:31:53] <Tobba> if you're doing OpenCL then yep you're fucked
[15:31:55] <eddyb> hmm, I needed reducing in one my projects
[15:31:59] <reima> FliPPeh: Lots of numbers to crunch is one thing, but the crunching should also be data-parallel, otherwise GPU computing is no win
[15:32:12] <FliPPeh> yep
[15:32:18] <Tobba> actually, it might be able to reduce, I havent touched it that much
[15:32:39] <eddyb> that is, I produce a bitset for each pixel, and I want to count the number of occurrences for each bit
[15:32:50] <Tobba> if you're rendering you can just tell the rasterizer/blending unit to veto the data
[15:32:54] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[15:32:55] *** ChanServ sets mode: +ao dherman dherman
[15:33:03] *** Joins: jviereck (Adium@moz-56DDD13.dip0.t-ipconnect.de)
[15:33:31] <reima> Tobba: How is rendering different from OpenCL in regard to reducing?
[15:33:55] <Tobba> when you're rendering, vertecies get sent over to the rasterizer, pixels get sent over to the blending unit
[15:34:13] <Tobba> can just tell the rasterizer or blending unit to ignore the data
[15:34:33] <Tobba> although I get your point in that actually producing a list of results, yeah you're not gonna be able to reduce that
[15:34:46] <Tobba> I guess you could use atomics but depending on how much you do it might end up just spinning most of the time
[15:36:01] <SiegeLord> The reduction algorithms I saw reduce on the level of a workgroup, and then do the final reduction on the CPU
[15:36:11] <SiegeLord> So you still, in principle, get a 32-64x speedup... but...
[15:36:17] <Tobba> well yeah
[15:36:45] *** Joins: lenstr (lenstr@1453F6BE.9636F313.7A27613B.IP)
[15:36:46] *** Joins: alonlevy (alon@C646CF2A.423BDA8F.692B9746.IP)
[15:37:25] *** Quits: AvianFlu (AvianFlu@moz-51534E77.c3-0.43d-ubr2.qens-43d.ny.cable.rcn.com) (Input/output error)
[15:37:33] <Tobba> the mill looks interesting though
[15:37:38] <reima> Tobba: It of course depends on the nature of the reduction step. If it's always "reduce 2 elements to 1", that's not a problem. If it's not so regular on the other hand...
[15:37:42] <Tobba> it still needs to have a few normal registers tho, so eh
[15:37:59] <nooblit> Tobba Sorry I don't want to spam with links but I had to ask, is this article also BS about this Harlen thing http://www.isgtw.org/feature/harlan-new-programming-language-accelerates-gpu-computing ?
[15:38:31] *** Quits: lenstr (lenstr@1453F6BE.9636F313.7A27613B.IP) (Ping timeout)
[15:38:34] <Tobba> harlan literally compiles down to OpenCL code
[15:38:36] <Tobba> afaik
[15:38:59] <Matthias247> PS3 had lot's of pseudo-cores. And nobody wanted to use them ;)
[15:39:27] <Tobba> nooblit: I'm not sure if it claims a speedup, I dont really get why they claim harlan to be some new super fast thing tho
[15:39:29] <reima> Matthias247: You mean the SPUs?
[15:39:33] <Tobba> speedup from it is pretty much bullshit
[15:39:33] <Matthias247> yes
[15:39:44] <Tobba> it might make things easier to program tho, but as far as I can see harlan is meant for research
[15:40:08] <eddyb> more so than Rust :P
[15:40:14] <reima> Matthias247: Well, some people definitely used them, so "nobody" is a bit harsh ;)
[15:40:14] <Tobba> heh
[15:40:53] *** Joins: AvianFlu (AvianFlu@moz-51534E77.c3-0.43d-ubr2.qens-43d.ny.cable.rcn.com)
[15:41:04] <Matthias247> reima: yes, ok :) But they also had to sell AAA titles and therefore had an really urgent need to utilize them
[15:41:40] <Matthias247> I guess most would have been happier with higher frequency on the normal cores
[15:43:41] *** Quits: mgottschlag (quassel@moz-3E841DE2.cust.bluewin.ch) (Ping timeout)
[15:43:44] <nooblit> Matthias247 Yeah i herd that lots of cpu cache misses are because the difference in speed of Ram and the cpu. That the increase in speed of the cpu has been more of in increase while the cycle time of ram has been slower.
[15:44:04] *** Quits: m_kato (chatzilla@moz-8B47AE65.tokynt01.ap.so-net.ne.jp) (Quit: ChatZilla 0.9.90.1 [Firefox 29.0a1/20140131095418])
[15:44:08] <reima> Guerilla Games did some amazing stuff with the SPUs, like software rasterizing the scene for occlusion culling
[15:44:39] <reima> And weren't there even whole supercomputer clusters made out of PS3s?
[15:45:10] <reima> But yes, most of the time the SPUs were probably un(der)used
[15:45:15] <Matthias247> that was the original business idea for the cell cpu
[15:45:19] <nooblit> reima I think so, I think that had yellow dog linux installed on them. 
[15:46:07] <Matthias247> nooblit: no, the linux ony ran on the ppc core
[15:46:37] <Tobba> at least I guess the SPUs drove parallelism forward a bit
[15:46:57] <Tobba> I have yet to touch any of AMDs APUs
[15:47:03] <Tobba> afaik its just a CPU and a GPU on the same die though
[15:47:24] *** Quits: jviereck (Adium@moz-56DDD13.dip0.t-ipconnect.de) (Quit: Leaving.)
[15:47:26] <nooblit> well I know people had yellow dog linux installed on ps3
[15:47:31] <Matthias247> is it even the same die or only the same package?
[15:48:07] <Tobba> same die definitely
[15:48:11] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[15:48:12] <Tobba> they share the memory controller AFAIK
[15:48:18] <Matthias247> at least the AMD HUMA thing sould make it work a little better
[15:48:29] <Tobba> yeah and HUMA is an important part
[15:48:34] *** Quits: Ms2ger|lafontaine (Ms2ger@961DA5D0.EA0ABEA5.692B9746.IP) (Ping timeout)
[15:49:11] <jxs> guys, when i pass an owned box as argument to a function which has @ as the parameter, it becomes a managed box? 
[15:49:26] <Matthias247> no. you can't pass it
[15:50:00] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[15:50:34] <jxs> ok, so only managed boxes can be passed?
[15:50:36] *** Joins: mgottschlag (quassel@moz-3E841DE2.cust.bluewin.ch)
[15:51:38] *** Joins: nano (nano@moz-ED77243C.superkabel.de)
[15:52:34] *** Joins: jviereck (Adium@moz-56DDD13.dip0.t-ipconnect.de)
[15:52:44] <strcat> jxs: yes, but it's a bit weird to ask because @ isn't really part of the language anymore :P
[15:52:54] <strcat> @mut is gone and @ is on the way out
[15:53:00] <strcat> already feature-gated
[15:53:08] <jxs> oh srsly? ok then thanks
[15:53:27] <reima> Oh. rustpkg is no more?
[15:53:28] <nooblit> is that because they put the GC in the library?
[15:53:33] <Tobba> yeah
[15:53:34] <jxs> http://static.rust-lang.org/doc/master/rust.html#memory-boxes
[15:53:37] <Tobba> @ was basicaly a shit idea
[15:53:37] <jxs> i was reading that
[15:53:38] <strcat> rust doesn't have a garbage collector at this point
[15:53:55] <nooblit> But they are going to put GC in library for you
[15:53:59] <nooblit> i think
[15:54:00] <strcat> std::rc is an implementation of shared ownership with weak ptrs
[15:54:22] <Tobba> std::gc is basicaly just refcounting atm afaik
[15:54:25] <Tobba> proper GC will rock tho
[15:54:29] <strcat> std::gc is not yet implemented, it's just a stub currently using overly eager refcounting (slower than Rc) and leaking cycles until tasks end
[15:54:29] <jxs> so managed boxes are going to be deprecated?
[15:54:34] <strcat> jxs: they are deprecated
[15:54:37] <Tobba> they are
[15:54:39] <strcat> you can't use them by default
[15:54:41] <jxs> ok thanks
[15:54:43] <strcat> it will error out
[15:55:04] <strcat> @5
[15:55:07] <strcat> rusti: @5
[15:55:09] -rusti- pastebinned 8 lines of output: http://ix.io/ahl
[15:55:13] <nooblit> Tobba tell me more about proper GC ? 
[15:55:35] <strcat> Tobba: well, perhaps
[15:55:42] <strcat> but it does add burden to library types
[15:55:44] <Tobba> well, right now Gc isnt really implemented, it sort of works but it just refcounts
[15:55:46] <strcat> they need to cooperate with tracing
[15:56:11] <strcat> so it makes rust less of a systems language as you can't just sit down and write a smart pointer, at least without adding a NonManaged bound
[15:56:13] <Tobba> a proper garbage collector is coming up which will make it... actually work and collect garbage through a better way than refcounting
[15:56:17] <strcat> unless you tackle tracing
[15:56:24] <jxs> so, shouldn't managed boxes doc be removed?
[15:56:43] <strcat> jxs: you can submit a pull request removing them from the documentation and I'll accept it
[15:56:44] <Tobba> they should
[15:56:54] <jxs> ok strcat will do, thanks 
[15:56:56] <Tobba> basicaly, the docs suck and noone is really updating them at this point
[15:57:04] <Tobba> managed boxes are used in tons of examples too iirc
[15:57:32] *** Joins: hoverbear (hoverbear@moz-86FCBF4B.gv.shawcable.net)
[15:57:35] <strcat> I did do a fair bit of work on the tutorial, http://static.rust-lang.org/doc/master/tutorial.html#implementing-a-linked-list that section is up-to-date/high-quality
[15:57:51] <nooblit> I herd someone before saying something about  tracing
[15:58:20] *** Quits: steveno (steveno@moz-2B2BE86F.hsd1.pa.comcast.net) (Ping timeout)
[15:58:54] *** Joins: aurynj (Eon@583ABBE5.60FA2E28.B9E25744.IP)
[15:59:24] *** Joins: teosz (teosz@EB63E8F2.1AC00AF5.3EA6AAD8.IP)
[15:59:33] <nooblit> Do you think it would be good for new people to learn Rust with the GC on once it's fixed or do they need to jump in and learn the memory/ownership thing anyway?
[15:59:54] *** Joins: maxli (maxli@moz-F47DD19B.student.cs.uwaterloo.ca)
[16:00:15] <Tobba> strcat: wouldent the List be better off as struct { value: u32, next: Option<~List> }
[16:00:19] <strcat> nooblit: need to learn it anyway, and it's also easier
[16:00:23] <strcat> as mutability is inherited
[16:00:26] <strcat> instead of a dynamic problem
[16:00:32] <strcat> Tobba: then it can't be empty
[16:00:33] *** Quits: AvianFlu (AvianFlu@moz-51534E77.c3-0.43d-ubr2.qens-43d.ny.cable.rcn.com) (Input/output error)
[16:00:43] <Tobba> hm yeah
[16:00:50] <strcat> Tobba: an owned linked list isn't very useful in practice anyway
[16:00:57] <strcat> so it's not really attempting to micro-optimize it
[16:01:04] <Tobba> heh yeah
[16:01:06] *** Joins: jvoorhis (jvoorhis@moz-84A91726.ptld.qwest.net)
[16:01:10] <strcat> intrusive linked lists are useful and persistent linked lists are useful
[16:01:13] <strcat> but not really one like that
[16:01:16] <strcat> can just use a vector
[16:01:26] <eddyb> Tobba: type List<T> = Option<~struct {value: T, next: List<T>}>
[16:01:36] *** Quits: maxli (maxli@moz-F47DD19B.student.cs.uwaterloo.ca) (Ping timeout)
[16:01:48] <Tobba> yep thats it
[16:02:00] <strcat> eddyb: but then you have an extra branch at the start
[16:02:13] * strcat shrugs
[16:02:19] *** Joins: FrozenCow (FrozenCow@moz-E69F48E.dynamic.upc.nl)
[16:02:26] <strcat> it seems like the same tradeoff to me ;p
[16:02:27] <FreeFull> strcat: The branch isn't extra though
[16:02:33] <hoverbear> Ohoh this feature rocks. https://github.com/mozilla/rust/pull/11217 Default Generic types!
[16:02:41] <strcat> FreeFull: it is extra over the one you can't make empty
[16:02:42] *** Joins: daschl (Adium@moz-DC6DE6E2.vie.surfer.at)
[16:02:44] <Tobba> it also avoids having Nil being allocated
[16:02:49] *** Quits: jvoorhis (jvoorhis@moz-84A91726.ptld.qwest.net) (Ping timeout)
[16:02:53] <FreeFull> strcat: Emptiness is a branch, so yeah
[16:02:55] <Tobba> empty lists in eddyb's fashion are p much no cost
[16:02:59] <FreeFull> You can't have both
[16:03:11] <strcat> you can have both
[16:03:24] <strcat> I can write a linked list in C with the best of both worlds
[16:03:39] <strcat> just link the first node to itself and have the end condition be stopping when you wrap around
[16:03:47] <strcat> a -> b -> c -> d -> a
[16:03:56] *** Joins: maxli (maxli@moz-F47DD19B.student.cs.uwaterloo.ca)
[16:03:57] <strcat> then you have a single branch
[16:04:11] <FreeFull> You have to keep track of the start of the list then
[16:04:19] <FreeFull> And I never heard of that way to do it before
[16:04:22] <strcat> FreeFull: you don't, you just use the first node
[16:04:27] <strcat> FreeFull: this is how the linux kernel does linked lists
[16:04:30] <strcat> it's faster
[16:04:45] <FreeFull> How do you know which one is the first?
[16:04:47] <strcat> http://www.martinbroadhurst.com/articles/circular-linked-list.html
[16:05:11] <strcat> FreeFull: you know because you have a variable called first holding the first node :P
[16:05:13] *** Quits: fyolnish (fyolnish@moz-EF224D80.uqwimax.jp) (Quit: Bye)
[16:05:23] *** Quits: alonlevy (alon@C646CF2A.423BDA8F.692B9746.IP) (Ping timeout)
[16:05:25] <strcat> or a pointer to it
[16:05:29] *** Quits: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net) (Quit: dave1629)
[16:05:39] <strcat> if you don't care about which is the first, then you don't keep a reference to the first node
[16:05:43] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[16:05:45] *** Joins: alan_andrade (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net)
[16:05:47] <strcat> but you probably do
[16:05:48] <FreeFull> strcat: Then you are keeping track =P
[16:05:49] *** Joins: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net)
[16:05:55] <strcat> FreeFull: but there is no extra branch
[16:06:04] <nooblit> Would it be possible later on for Rust to have a library add on that lets you capture the screen to capture the RGB pixels  and compare that image to a screen shot you have to make a color bot, that can like for example find a target by takings pictures really fast and shoot the target?
[16:06:11] <strcat> it doesn't destroy branch prediction with a NULL sentinel
[16:06:16] <strcat> it can keep predicting ahead
[16:06:24] <FreeFull> strcat: I don't see why you'd care about this unless you need high efficiency linked lists
[16:06:44] <strcat> FreeFull: because there's no reason to use a linked list if you don't need high efficiency intrusive data structures
[16:07:06] <strcat> (ignoring persistent data structures for the moment)
[16:07:43] <strcat> lets say you have a file object and it needs to be in 5 lists
[16:08:06] *** Quits: vertexclique (vertexcliq@1F8F5B47.125B31C4.6F578A69.IP) (Ping timeout)
[16:08:22] <strcat> struct file { the file object bits; file *one; file *two; file *three; file *four; file *five; }
[16:08:40] <strcat> now you have 1 allocation (the file)
[16:08:46] <strcat> and the linked lists require zero additional allocation
[16:08:53] <strcat> and by making them circular, you avoid an extra branch
[16:08:55] <strcat> so yeah, this matters in a kernel
[16:08:56] *** Quits: alan_andrade (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net) (Ping timeout)
[16:09:18] <eddyb> strcat: oooh, that's cool
[16:09:29] <FreeFull> I don't feel like Rust will let you have circular structures on the stack without unsafe blocks
[16:09:37] <strcat> this is how the linux kernel does most data structure
[16:09:45] <strcat> they use intrusive lists, intrusive red-black trees, etc.
[16:10:04] <strcat> intrusive data structures is one of two valid reasons to use an rbtree over a b-tree :)
[16:10:26] *** Joins: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[16:10:35] <eddyb> strcat: IntrusiveList<T, "one">, IntrusiveList<T, "two">
[16:10:39] <strcat> the other being the node reference invalidation guarantee (a reference/iterator is only invalidated if it points to a node that was removed - and in an intrusive data structure, it will remain valid until that object is actually gone)
[16:10:50] <eddyb> strcat: or 'one and 'two. we really need to start allowing this in one way or another
[16:10:57] <strcat> eddyb: I am not sure that it is possible
[16:11:08] <strcat> it's important though
[16:11:13] *** Joins: newguy (Mibbit@C53B0424.8878667B.DDE5D3F6.IP)
[16:11:21] <strcat> eddyb: http://www.boost.org/doc/libs/1_55_0/doc/html/intrusive.html the C++ way of doing it
[16:11:25] <eddyb> strcat: the question is how, not whether it is possible
[16:11:29] <strcat> same stuff but abstracted more
[16:11:51] <strcat> eddyb: it is not necessary possible to make this a safe pattern in rust
[16:11:54] <newguy> im trying to create a function that takes in two functions as paramaters, and returns a function. can someone help me with this?
[16:11:55] <strcat> necessarily*
[16:12:14] *** Quits: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net) (Ping timeout)
[16:12:14] *** Joins: vertexclique (vertexcliq@C2DE76BA.54513D59.268C6403.IP)
[16:12:14] <strcat> eddyb: for one thing, this allows you to have N references to a node
[16:12:19] <strcat> eddyb: so it can't be mutable
[16:12:23] <strcat> eddyb: unless you do that dynamically
[16:12:26] <strcat> so you've already lost to C
[16:12:37] <eddyb> IntrusiveList<T, static Field: &'static str> ... impl<T: HasField<Field>, static Field: &'static str> ...
[16:12:58] <strcat> eddyb: if it has to be immutable, it's pretty pointless
[16:13:11] <eddyb> hmm, you do have a point
[16:13:26] <eddyb> strcat: unless you put Cell's inside
[16:13:43] <eddyb> 0-cost abstractions <3
[16:13:44] <strcat> eddyb: sure, but now you're severely limited in what you can use
[16:13:54] <strcat> Cell isn't really a 0-cost abstraction
[16:14:03] <strcat> it's a 0-cost workaround for a compiler check
[16:14:13] <strcat> but it's not usable for many types
[16:14:48] <strcat> anyway I'm pretty convinced that intrusive data structures in rust are not very viable
[16:15:10] *** Quits: vertexclique (vertexcliq@C2DE76BA.54513D59.268C6403.IP) (Ping timeout)
[16:15:26] <strcat> and for that reason and others, I don't think saying safety + contained unsafe blocks comes without a heavy cost is honest
[16:16:07] <strcat> rust can still be pretty fast, but it's not going to let you write efficient C as people write in the linux kernel without making the whole program unsafe
[16:17:30] * strcat needs a blog
[16:17:57] <eddyb> strcat: you want me to spend all my time commenting on it?
[16:17:59] *** Quits: bt3ze (bt3ze@moz-3F0303DA.hsd1.va.comcast.net) (Client exited)
[16:18:21] *** Joins: bt3ze (bt3ze@moz-3F0303DA.hsd1.va.comcast.net)
[16:18:31] *** Quits: awidegreen (awidegreen@moz-9FADBE94.a357.priv.bahnhof.se) (Ping timeout)
[16:19:17] <sp3d> the strcat blog would be nice for people that don't have time to backread all of #rust :D
[16:19:37] <strcat> atm I might be posting more about stuff other than rust...
[16:19:53] *** Quits: newguy (Mibbit@C53B0424.8878667B.DDE5D3F6.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[16:19:53] <pzol> do channels support queing like an actor or something? 
[16:20:02] *** Quits: bt3ze (bt3ze@moz-3F0303DA.hsd1.va.comcast.net) (Ping timeout)
[16:20:05] <strcat> pzol: they're unbounded FIFO queues
[16:20:19] <pzol> strcat ok thx
[16:20:27] <strcat> single-consumer, multi-producer
[16:20:42] <aurynj> single consumer lol
[16:21:27] *** Joins: awidegreen (awidegreen@moz-9FADBE94.a357.priv.bahnhof.se)
[16:22:23] <strcat> aurynj: https://mail.mozilla.org/pipermail/rust-dev/2014-January/008154.html (my post on the mailing list about that)
[16:22:26] * strcat shrugs
[16:23:12] <aurynj> ah
[16:23:29] <yuriks> and a day after I struggle with build systems, rustpkg is removed, huh
[16:23:57] <aurynj> it took a long time I get it... sorry
[16:24:13] <strcat> aurynj: hm?
[16:24:23] *** Quits: steffenomak (steffenoma@moz-FB0A4BEB.student.uu.se) (Quit: WeeChat 0.4.2)
[16:24:31] <aurynj> just i misunderstood the topic
[16:24:43] <strcat> oh
[16:24:59] <SiegeLord> yuriks: Use CMake!
[16:26:03] *** Quits: oberstet (quassel@moz-5E97C680.dynamic.mnet-online.de) (Client exited)
[16:26:04] *** Quits: tcreate (tcreate@moz-90E5C923.hsd1.ma.comcast.net) (Client exited)
[16:26:11] *** Joins: newguy (Mibbit@C53B0424.8878667B.DDE5D3F6.IP)
[16:26:12] *** Quits: jviereck (Adium@moz-56DDD13.dip0.t-ipconnect.de) (Quit: Leaving.)
[16:26:15] *** Joins: jviereck (Adium@moz-56DDD13.dip0.t-ipconnect.de)
[16:26:30] *** Quits: jviereck (Adium@moz-56DDD13.dip0.t-ipconnect.de) (Client exited)
[16:27:03] <newguy> whats the difference between println!("{}", x) vs println!("{:s}", x) vs println!("{:d}", x)
[16:27:38] <eddyb> newguy: first one should work with anything formattable while the other two are specific
[16:27:57] <eddyb> newguy: string and decimal, respectively
[16:27:58] <myname> it will be more clear if you use something different than a simple number
[16:27:59] <newguy> oh ok, so i could just use "{}" every single time?
[16:27:59] *** Joins: alonlevy (alon@C646CF2A.423BDA8F.692B9746.IP)
[16:28:02] <yuriks> SiegeLord: I ended up just blotching together a Makefile. I'm not a huge fan of CMake, specially if it'll require me to use a large library for rust support
[16:28:12] <myname> you could, but you should only for debugging
[16:28:19] <newguy> ok thanks!
[16:28:21] <eddyb> myname: no, that's {:?}
[16:28:24] <myname> ah
[16:28:25] <myname> okay
[16:28:33] <myname> newguy: what eddyb said
[16:28:46] <newguy> ok
[16:28:47] <eddyb> newguy: you can use "{}" if you don't need something specific, like padding with zeroes for numbers and whatnot
[16:28:55] <strcat> eddyb: what I did yesterday: http://ix.io/aho (using tor + mailinator + breaking a captcha to skirt by an API limit :P)
[16:29:02] <strcat> want a blog post about *that*? ;P
[16:29:05] <myname> but {} will not always work
[16:29:05] <yuriks> (this is what I ended up with: https://github.com/yuriks/OpenVikings/blob/master/tools-ng/Makefile )
[16:29:11] * strcat doesn't know why there are API limits in the first place if you can just avoid them
[16:29:24] * sp3d would read a blog like that
[16:29:26] <strcat> oh and I hate pycurl.
[16:29:27] <eddyb> strcat: hah, I have a server somewhere running a PHP script from a cron job, making google searches behind TOR
[16:29:31] <strcat> despise pycurl.
[16:29:49] <sp3d> is it significantly worse than the C interface?
[16:29:53] <yuriks> SiegeLord: all build systems suck. All of them :)
[16:30:02] <pzol> If I want to read from many tasks (potentially thousands a second) and write from ONE and I don't care if the readers have the newest "version", what would be the best approach?
[16:30:03] <Tobba> eddyb: what for
[16:30:05] <strcat> sp3d: no, it basically *is* the C interface
[16:30:09] <sp3d> ouch
[16:30:17] <Tobba> yuriks: I've heard good things about premake
[16:30:30] <SiegeLord> yuriks: Can't realistically use none, so you've got to choose something... a Makefile is an okay start ;)
[16:30:45] <strcat> I started with requests + torsocks and then realized I needed to map certain connections to certain tor servers
[16:30:56] <strcat> so went from 1 line of code to 20 lines of code for the same stuff
[16:30:59] *** Joins: AvianFlu (AvianFlu@moz-51534E77.c3-0.43d-ubr2.qens-43d.ny.cable.rcn.com)
[16:31:25] <Tobba> makefiles are...
[16:31:26] <Tobba> okay
[16:31:37] <Tobba> they do one thing and do it reasonably
[16:31:39] <strcat> now I'm tempted to make really good curl/sqlite3/libxml2 bindings for rust and stop using python for stuff like this :P
[16:32:19] <newguy> i have a question about spawning tasks
[16:32:30] <newguy> so if i have a function that prints a letter for n times
[16:32:34] *** Joins: csherratt (csherratt@moz-7685819.cpe.teksavvy.com)
[16:32:37] <strcat> sp3d: http://ix.io/ahp the initial part (then it has to break a captcha and then do what I actually wanted :P)
[16:32:39] <yuriks> Tobba: I've used premake a bit, it's ok for C++. I dislike systems that build knowledge of the thing you're building into the build system though
[16:32:40] <strcat> sp3d: *huge* pain.
[16:32:54] <SiegeLord> Tobba: I wonder what that one thing is, 'cause I don't know of any ;)
[16:32:58] <yuriks> tup was the most pleasant to use so far, but it has other issues...
[16:32:59] <strcat> sp3d: seriously you have to pass callbacks to get data
[16:32:59] *** Quits: teosz (teosz@EB63E8F2.1AC00AF5.3EA6AAD8.IP) (Ping timeout)
[16:33:01] <newguy> and i spawn 3 processes that print different letters, why is it that when i use println i see interleaving and when i use print i dont see any interleaving?
[16:33:10] * strcat shrugs
[16:33:22] <Tobba> SiegeLord: probably the "stop if one task fails" bit
[16:33:26] <Tobba> other than that...
[16:33:29] <eddyb> newguy: because it buffers based on lines
[16:33:31] <strcat> it's python so a micro-optimization like that is just *weird*
[16:33:32] <SiegeLord> XD
[16:33:35] *** Quits: AvianFlu (AvianFlu@moz-51534E77.c3-0.43d-ubr2.qens-43d.ny.cable.rcn.com) (Input/output error)
[16:33:45] *** Joins: AvianFlu (AvianFlu@moz-51534E77.c3-0.43d-ubr2.qens-43d.ny.cable.rcn.com)
[16:33:45] <strcat> well
[16:33:48] <newguy> eddyb: what do you mean exactly?
[16:33:52] <Tobba> also strcat: reminds me of that exploit PoC I wrote in python
[16:33:59] <yuriks> Makefiles competer with regular expressions on unreadability :)
[16:33:59] <Tobba> it started out as 20 lines, did some XML reading etc
[16:34:00] <strcat> I imagine it just passes you data you need to deallocate anyway... haven't used the C API for a while
[16:34:10] <Tobba> then it became like 20 lines extra because the ftp library sucked
[16:34:15] <eddyb> newguy: there's a per-task stdout that buffers until you have a full line and then outputs it
[16:34:18] <strcat> sp3d: look at developer_login
[16:34:22] <Tobba> then the xml parser was swapped for regex because the standard one was terrible
[16:34:26] <strcat> can't believe how bad the nytimes site is.
[16:34:33] *** Quits: alonlevy (alon@C646CF2A.423BDA8F.692B9746.IP) (Ping timeout)
[16:34:34] <sp3d> :D
[16:34:36] <newguy> eddyb: ok thanks
[16:35:01] <strcat> sp3d: want to log in? do an actual login (get + post, sane), now for some odd reason you need to transfer the login to another part of the site
[16:35:11] <strcat> takes a GET + *three* POSTs
[16:35:12] <strcat> wat???
[16:35:29] <strcat> in a browser, javascript redirects you along 4 times
[16:35:37] <strcat> if you have js off, you have to click 3 'continue' buttons
[16:36:06] *** Joins: alonlevy (alon@C646CF2A.423BDA8F.692B9746.IP)
[16:36:13] * strcat curses at their sadistic web developers
[16:36:19] <strcat> that's one way to ensure you always have a job
[16:36:48] <sp3d> yeah, it would be so nice if the open-source community banded together a little more to whip the web into something more programmable
[16:37:01] <Tobba> lets start by killing php
[16:37:13] <Tobba> and then make sure node.js doesnt take its place
[16:37:15] <strcat> sp3d: the sad part is that the API I wanted to use (retrieving nytimes comments + metadata) breaks when you go back further than 100k comments old
[16:37:15] <sp3d> tools like plowshare and youtube-dl make me all warm and fuzzy
[16:37:20] <strcat> sp3d: so this was pointless :)
[16:37:22] <sp3d> aww
[16:37:34] <strcat> I need to crawl their entire site and fetch the comments another way
[16:37:34] <Matthias247> Tobba: i guess that's already too late
[16:37:39] <Tobba> probably
[16:37:43] <strcat> sp3d: I can't see why they'd put a 5k limit on this API anyway
[16:37:47] <Tobba> I guess node.js *might* be a better alternative to php
[16:37:55] <strcat> the alternative is me making hundreds of thousands of http requests to the site itself
[16:37:56] * strcat shrugs
[16:38:03] <strcat> well, millions
[16:38:06] <Tobba> the default php interpreter is absymally bad, so I guess JS is a step up
[16:38:20] <sp3d> presumably nobody thought it through that well
[16:38:31] <strcat> sp3d: definitely
[16:38:33] <strcat> it's a bad API :P
[16:38:43] <strcat> so, it lets you fetch comments indexed by how recent they are
[16:38:52] <strcat> 25 at a time (you give a multiple of 25 as an offset)
[16:38:53] <sp3d> race conditions!
[16:38:55] <strcat> yep
[16:38:57] <strcat> you can miss them
[16:39:01] <strcat> so I need to run many passes
[16:39:07] <strcat> and it slows down progressively 
[16:39:16] <sp3d> how fast?
[16:39:26] <strcat> it starts at ~10k per minute
[16:39:29] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Client exited)
[16:39:39] <strcat> by 50k, it is down to ~25 per second
[16:39:49] <strcat> by 100k, it takes 4 minutes to retrieve each 25
[16:39:50] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[16:39:54] <strcat> and then the API craps out and gives horrible errors
[16:40:02] <strcat> at a bit over 100k old
[16:40:04] <Tobba> a fucking ++
[16:40:09] <Tobba> guessing they're just doing a MySQL query
[16:40:11] <sp3d> haha
[16:40:14] <Tobba> and using LIMIT
[16:40:18] <Tobba> and sorts
[16:40:20] <o11c> see, this is why you don't do queries by offset
[16:40:22] <strcat> from the data I do have, I know the nytimes has a bit under a million comments per year
[16:40:24] <strcat> so I barely got any of them
[16:40:29] <o11c> you do query by > last key from the previous
[16:40:31] <Matthias247> Tobba: node.js has some very good technology behind it and also a good ecosystem. But it's still the javascript I don't like :)
[16:40:42] <Tobba> "very good technology"
[16:40:47] <Tobba> tbh I wouldent call V8 terribly good tech
[16:40:48] <strcat> Tobba: it bubbles up errors from mysql
[16:40:49] <strcat> Tobba: fwiw
[16:40:55] <Tobba> lol
[16:41:04] <sp3d> o11c: maybe there's no shared context and they didn't expect to need caching :/
[16:41:04] <strcat> Tobba: they have this "DB Slayer" thing on top of it giving awful errors
[16:41:09] <sp3d> hahaha
[16:41:10] <Tobba> the fuck
[16:41:13] <strcat> Tobba: http://code.nytimes.com/projects/dbslayer/wiki
[16:41:15] <strcat> don't ask me
[16:41:17] <sp3d> dbs layer
[16:41:36] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Ping timeout)
[16:41:37] <strcat> sp3d: well, it's an attempt at wordplay
[16:41:42] <sp3d> yeah
[16:41:46] <Matthias247> Tobba: in terms of javascript runtimes it is ;)
[16:41:48] <strcat> anyway the only thing I know about it is that it sucks
[16:42:06] <Tobba> I'm not sure if I can rightfully call it crap even though its fast
[16:42:13] *** Quits: AvianFlu (AvianFlu@moz-51534E77.c3-0.43d-ubr2.qens-43d.ny.cable.rcn.com) (Input/output error)
[16:42:17] <strcat> sp3d: their API returns json with {"status": "OK", "results": { ... }}
[16:42:18] <Tobba> then again I call LuaJIT good and have you seen its source code
[16:42:18] <newguy> what can we use Port<> Chan<> for?
[16:42:23] <strcat> sp3d: status is always "OK", even when it's not - ofc
[16:42:28] <newguy> what is it most commonly used for?
[16:42:54] <Matthias247> for communication between tasks
[16:43:01] <Tobba> strcat: wait, NYT perform their SQL queries and get results back in JSON
[16:43:02] <sp3d> so you get an http 200 around a json OK around something that might have failed :D
[16:43:09] <Tobba> kill it with fire
[16:43:09] <o11c> sp3d: see, this is why "premature optimization is evil" is evil
[16:43:27] <sp3d> o11c: profiling would show plenty of problems here I'm sure
[16:43:31] <o11c> ALWAYS expect the spanish sql query
[16:43:32] <strcat> sp3d: just have a 'while True' loop with `if data["status"] == "OK" and "errors" not in data["results"]: continue`
[16:43:37] <strcat> sp3d: status is always "OK" though
[16:43:40] <strcat> my check is pretty useless
[16:43:53] <Tobba> actually someone should go and make a good web safe language
[16:43:56] <strcat> the "errors" part works
[16:44:19] <Tobba> I guess rust could work but eh
[16:44:29] <o11c> Tobba: agreed ... that's one way for a language to win
[16:44:35] <strcat> sp3d: er, s/continue/break/
[16:44:38] <strcat> anyway, web stuff.
[16:44:49] <o11c> the hard problem is: if you change one file, you want to restart the web app without restarting the server
[16:44:54] <Tobba> yeah
[16:45:24] <sp3d> I've been meaning to write something that just link-crawls a few layers deep looking for media files satisfying criteria (e.g. 320 mp3s or w/e) but I keep not getting around to it
[16:45:36] *** Quits: Kxepal (Miranda@moz-447F3688.pppoe.mtu-net.ru) (Ping timeout)
[16:46:53] <sp3d> it would save a lot of time but there's no way to easily iterate from just looking at dumb html source to running js in pages
[16:47:14] <sp3d> I should probably see if the Servo architecture is amenable but it probably isn't
[16:47:55] <Tobba> then again, dynamically reloadable rust code could totally work
[16:48:09] <Tobba> just have to make sure it doesnt launch any stray threads somewhere
[16:48:42] *** Joins: cgaebel (clark@ADA4DDE2.290DF317.EE6E63A5.IP)
[16:48:44] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[16:48:51] *** Joins: olivernn (olivernigh@moz-7CE0F8.access.mtnbusiness.co.za)
[16:48:54] *** Joins: Kxepal (Miranda@moz-1A176845.pppoe.mtu-net.ru)
[16:49:18] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[16:49:39] *** Joins: Jesin (Jesin@moz-3A2C5D36.washdc.fios.verizon.net)
[16:50:21] <hoverbear> Tobba: Javascript.
[16:50:33] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[16:50:36] <Tobba> dear god no
[16:51:19] <hoverbear> Tobba: Javascript is literaly the language of the web. It sucks, yes, but if you're looking for a web language, it works.
[16:51:23] <sp3d> that said, there's a big empty space for embeddable *actually headless* web client code
[16:51:47] <sp3d> embedding QtWebkit and not displaying is the State of the Art there :|
[16:51:50] <FliPPeh> It works because there literally is nothing else
[16:51:59] <FliPPeh> So it doesn't matter how much it sucks because you HAVE to use it
[16:51:59] <Tobba> I was referring to a web server language
[16:52:04] <Tobba> I kinda messed the wording up there, but anyways
[16:52:24] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Quit: Leaving...)
[16:52:27] <hoverbear> Tobba: Why write in a different language on your backend then your frontend?
[16:52:41] *** Quits: mindcat (mindcat@926CFB1F.DC005319.857BDFA9.IP) (Quit: leaving)
[16:52:59] <Tobba> because no sane person would write code where performance is everything (well, depends on how big your site is) in a language which will never be faster than emulating x86 on a toaster
[16:53:57] <hoverbear> Tobba: No sane person would write code where performance is everything on a web app. Write Javascript with Node (It uses libuv just like rust) and call rust code from if where you need it performant?
[16:54:19] *** Quits: csherratt (csherratt@moz-7685819.cpe.teksavvy.com) (Quit: csherratt)
[16:55:02] *** Quits: alonlevy (alon@C646CF2A.423BDA8F.692B9746.IP) (Ping timeout)
[16:55:38] <Tobba> would probably just result in a ton of FFI juggling
[16:55:44] <Matthias247> the question is why would you want to write javascript at all? :) On the frontend the answer is: "Because there is not alternative". But on the backend it's not true
[16:56:30] <Tobba> unless you go full facebook and just throw more servers at it (they used PHP with goddamn APACHE) you're gonna have to write code thats fast
[16:57:10] *** Quits: japaric1 (japaric@DDF50A2B.40EC661E.5C7588CA.IP) (Ping timeout)
[16:57:16] <hoverbear> Don't get me wrong, I'd love to use Rust (or anything else really) on the server. But right now rust is too immature, and Node.js's ES5/6 support makes it signifigantly less bad to write for then browsers.
[16:57:28] *** Quits: newguy (Mibbit@C53B0424.8878667B.DDE5D3F6.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[16:57:52] <hoverbear> Node gives you generators (think iterator in rust), .map, .reduce, .filter, etc etc etc.
[16:58:06] <Tobba> I'll stop bashing apache when I stop being able to bring an apache server down with 100kb/s of traffic
[16:58:50] <hoverbear> Also, why is github not serving my desktop css? :S
[16:59:47] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[16:59:55] <FliPPeh> Github has been pretty broken for me these past few days
[17:00:00] * o11c <3 nginx
[17:00:07] * FliPPeh <3 lighttpd
[17:00:08] <hoverbear> FliPPeh: WOrks on all my other machines :(
[17:00:40] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[17:00:48] <o11c> I haven't had any problems with github myself, but someone else was complaining it was slow to clone something the other day ...
[17:01:40] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[17:01:46] <Tobba> I also like how reddit is written in python
[17:01:50] *** Joins: jvoorhis (jvoorhis@moz-84A91726.ptld.qwest.net)
[17:01:57] <FliPPeh> Probably why it breaks all the time
[17:02:03] <Tobba> and people use it as an example to somehow claim that python is fast enough for it
[17:02:09] *** Joins: japaric1 (japaric@290150F2.C68AB816.F29ED47E.IP)
[17:02:48] <Tobba> it just sits behind gigantic cache servers
[17:03:17] <Tobba> and still falls over at the slightest increase in load
[17:03:31] *** Quits: jvoorhis (jvoorhis@moz-84A91726.ptld.qwest.net) (Ping timeout)
[17:03:39] <nooblit> well, I don't want to learn that then...
[17:04:10] *** Quits: markos (markos@3A6075EE.3EF83E22.692B9746.IP) (Quit: Ex-Chat)
[17:04:14] <Tobba> python is alright
[17:04:22] <Tobba> I just dont see the appeal of using it on a massive website
[17:04:50] <o11c> I want to see an AOT language for the web that acts
[17:05:11] <o11c> like a scripting language, somehow
[17:05:23] <o11c> but taking care of compilation is complicated
[17:05:24] <Tobba> static typing usually means you can AOT it
[17:05:39] <nooblit> isn't that what Go is for?
[17:05:42] *** jorendorff_away is now known as jorendorff
[17:05:47] <o11c> hm, possibly
[17:05:58] <o11c> I've been avoiding looking at Go because of the GC
[17:06:20] <o11c> just like I avoided Rust for a long time
[17:06:22] <nooblit> for web stuff?
[17:06:40] <o11c> web stuff doesn't need GC, it just needs safe pools
[17:06:51] <Tobba> also heh, rails
[17:07:11] <Tobba> v4 is out and their site still runs v2 I think
[17:07:14] <o11c> but still, Go is probably they best we'll get for a while
[17:07:53] *** Quits: moostik (Icedove@moz-133D2136.w92-139.abo.wanadoo.fr) (Ping timeout)
[17:08:26] *** Joins: a_m0d (a_m0d@moz-2F294D00.acanac.net)
[17:09:25] *** Joins: alan_andrade (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net)
[17:09:35] *** Quits: Jesin (Jesin@moz-3A2C5D36.washdc.fios.verizon.net) (Quit: Leaving)
[17:10:11] <o11c> I would like to see Rust on ... rotors? racks?
[17:10:21] <o11c> lots of good r words, but no *great* ones
[17:10:45] *** Joins: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[17:12:30] *** Quits: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net) (Ping timeout)
[17:12:40] *** Joins: aruniiird (aruniiird@28876D92.F24A7F1B.260B031E.IP)
[17:12:43] *** Quits: alan_andrade (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net) (Ping timeout)
[17:13:58] *** Joins: gwty (gwtypc@6DB449F9.8B64350F.F64220F6.IP)
[17:15:35] *** Quits: hacker_sam (hacker_sam@C0FE520A.661C02A7.B0CE379A.IP) (Ping timeout)
[17:16:19] *** Quits: KindOne (KindOne@moz-59654FDC.dynamic.ip.windstream.net) (Ping timeout)
[17:16:26] *** Quits: dnyarri (dnyarri@moz-84E87CA5.kapsi.fi) (Ping timeout)
[17:16:31] *** Quits: rootnode (rootnode@moz-7FAB5E8.ip1.george24.com) (Ping timeout)
[17:16:41] *** Quits: nkoep (nik@moz-DC05FB0B.pool.mediaways.net) (Quit: Leaving)
[17:16:56] <o11c> racks is probably pretty good
[17:17:15] *** Joins: kvark (Mibbit@moz-F30E0473.cpe.net.cable.rogers.com)
[17:17:17] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[17:17:21] <o11c> if the idea of rails was to constrain you somewhat ...
[17:17:31] <sp3d> Rust on Rushes
[17:17:44] <kvark> Q: what is the proper way of iterating from N to 1 (inclusive)?
[17:17:59] <kvark> range(N,0) doesn't do anything
[17:18:06] <o11c> try adding -1
[17:18:44] <sp3d> range_step?
[17:18:51] <japaric1> Q: Is there a simpler way to sum the elements of a vector than (~[1u, 2]).iter().fold(0, |a, &b| a + b)? I tried ~[1u, 2].iter().sum() but fails with "failed to find an implementation of trait std::ops::Add<&uint,&uint>"
[17:19:34] *** japaric1 is now known as japaric
[17:19:45] <kvark> o11c: sp3d: range_step(N,0,-1) doesn't seem to do anything ether... I know I can do range(0,N).rev() but that would give me indices from N-1 to 0 instead of from N to 1
[17:19:45] <eddyb> kvark: range_inclusive(1, N).rev() 
[17:19:47] <o11c> rusti: std::iter::range_step(10, 0, -1).to_owned_vec()
[17:19:48] -rusti- ~[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
[17:20:03] *** Joins: KindOne (KindOne@moz-C7A9A6E3.dynamic.ip.windstream.net)
[17:20:04] <kvark> hmm
[17:20:07] <strcat> rusti: range_inclusive(1, 10).rev()
[17:20:07] -rusti- <anon>:10:9: 10:24 error: unresolved name `range_inclusive`.
[17:20:07] -rusti- <anon>:10         range_inclusive(1, 10).rev()
[17:20:07] -rusti-                   ^~~~~~~~~~~~~~~
[17:20:08] -rusti- error: aborting due to previous error
[17:20:08] -rusti- application terminated with error code 101
[17:20:18] <strcat> rusti: std::iter::range_inclusive(1, 10).rev().to_owned_vec()
[17:20:19] -rusti- ~[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
[17:20:26] <o11c> std::iter is needed for anything but plain range()
[17:20:34] <kvark> okie, thanks!
[17:20:35] <o11c> rust's prelude system is sad
[17:20:39] <strcat> o11c: I know, I wrote it ;p
[17:20:41] *** Quits: daschl (Adium@moz-DC6DE6E2.vie.surfer.at) (Quit: Leaving.)
[17:20:47] <strcat> (the range stuff)
[17:21:03] <strcat> well I wrote pretty much all of iter with Eridius who did the size hints
[17:21:25] <strcat> it sucks :(
[17:21:43] <strcat> need real random access iterators and some good solution for the index overflow issue
[17:21:46] *** jorendorff is now known as jorendorff_away
[17:22:05] <o11c> it's unsolvable without an extra bool, and easy with ...
[17:22:27] <strcat> by overflow issue I mean when you have an index method
[17:22:37] <o11c> hm?
[17:23:06] <strcat> iter.idx(n)
[17:23:11] <strcat> for a random access iterator
[17:23:15] <strcat> like
[17:23:22] <strcat> a.chain(b).idx(n)
[17:23:26] <o11c> it would just fail!() I expect ...
[17:23:37] <strcat> o11c: by overflow I mean
[17:23:40] <strcat> lets say 'a' is 2GiB
[17:23:46] <strcat> chain it to itself N times
[17:24:01] <strcat> now, on a 32-bit OS, you cannot index the whole iterator
[17:24:22] <kvark> rusti: let N=10u; std::iter::range_step(N,0,-1).to_owned_vec()
[17:24:23] -rusti- ~[]
[17:24:26] <strcat> even though it's of finite size
[17:24:26] <kvark> see!
[17:24:30] <o11c> hm ... well, IMO it's wrong to directly index even with random access iterators
[17:24:31] <kvark> strcat: ^
[17:24:36] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[17:24:46] <o11c> kvark: guessing problem is -1u ?
[17:24:58] <strcat> kvark: that's not -1
[17:25:06] <strcat> rusti: let x: uint = -1; x
[17:25:07] -rusti- 18446744073709551615u
[17:25:19] <strcat> - shouldn't be defined on uint, imo
[17:25:23] <o11c> in C that would be a well-defined wrap though ...
[17:25:36] <strcat> o11c: it is a well-defined wrap in rust too
[17:25:43] <strcat> o11c: it's not making an int and casting it as uint
[17:25:47] <strcat> it's applying negation to a uint
[17:25:47] <kvark> strcat: so given my N is uint, and I don't want to cast to int, my only choice is to use range_inclusive(1,N).rev() ?
[17:25:55] <o11c> let N=10u; let d=-1u; N + d
[17:26:04] <o11c> rusti: let N=10u; let d=-1u; N + d
[17:26:05] -rusti- 9u
[17:26:10] <strcat> kvark: yes
[17:26:19] <kvark> ok, thanks
[17:26:36] <o11c> oh!
[17:26:51] <o11c> it must be terminating on a > comparison because step > 0
[17:27:12] <SiegeLord> It's not the checked add in it?
[17:27:24] <strcat> o11c: it terminates on overflow
[17:27:31] *** Joins: kellogh (timkellogg@moz-704A74D.hsd1.co.comcast.net)
[17:28:07] <strcat> I don't really see a solution to this problem for range_step{,_inclusive}
[17:29:59] *** Joins: victorporof (victorporo@53EBB099.7C27E871.79933D60.IP)
[17:30:01] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[17:30:13] *** Joins: dnyarri (dnyarri@moz-84E87CA5.kapsi.fi)
[17:30:50] *** Joins: bt3ze (bt3ze@moz-3F0303DA.hsd1.va.comcast.net)
[17:34:26] <zokier`> is there a way to specify some initialization code to be run once before unit tests?
[17:35:20] *** Joins: teosz (teosz@EB63E8F2.1AC00AF5.3EA6AAD8.IP)
[17:36:41] *** Joins: Zylinski (karl@moz-58495553.static.spa.siw.siwnet.net)
[17:36:50] *** Joins: NiccosSystem (NiccosSyst@AB1AFDE.FC7B0C35.A7597CB6.IP)
[17:37:37] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[17:37:37] *** ChanServ sets mode: +ao dherman dherman
[17:38:51] *** Joins: vertexclique (vertexcliq@C497D134.CA49E691.17913DC0.IP)
[17:39:31] *** Joins: jviereck (Adium@moz-56DDD13.dip0.t-ipconnect.de)
[17:40:11] <jxs> strcat, https://github.com/joaoxsouls/rust/blob/master/doc/rust.md#owned-boxes removed managed boxes references and tried to add the examples from the tutorial
[17:43:32] *** Quits: vertexclique (vertexcliq@C497D134.CA49E691.17913DC0.IP) (Ping timeout)
[17:43:42] *** jorendorff_away is now known as jorendorff
[17:43:51] *** Joins: hacker_sam (hacker_sam@C0FE520A.661C02A7.B0CE379A.IP)
[17:44:29] *** Joins: jroweboy (Mibbit@moz-18814A6B.provo.static.broadweavenetworks.net)
[17:44:32] *** jorendorff is now known as jorendorff_away
[17:44:42] *** Joins: newguy (Mibbit@C53B0424.8878667B.DDE5D3F6.IP)
[17:45:31] <newguy> does anyone know if path object syntax follows "/dir/subdir" or "dir/subdir"?
[17:45:42] *** Quits: olivernn (olivernigh@moz-7CE0F8.access.mtnbusiness.co.za) (Ping timeout)
[17:46:03] *** Joins: james4k (james@moz-9BB5AE72.consolidated.net)
[17:46:04] <newguy> what should i be passing in as a string?
[17:46:25] <o11c> newguy: it depends on whether you want an absolute or a relative path ...
[17:46:32] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[17:46:40] <newguy> o11c: what is the difference?
[17:47:01] <newguy> i think i want relative
[17:47:16] <sp3d> absolute paths start in the filesystem root folder and relative ones start in the current folder
[17:47:25] <newguy> oh ok, then i need relative
[17:48:03] <newguy> which syntax would be correct for a relative path?
[17:48:36] <FreeFull> Just skip the initial /
[17:48:41] <newguy> oh ok!
[17:48:43] <newguy> thanks
[17:49:09] <FreeFull> This applies to everywhere, not just Rust
[17:49:16] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[17:50:14] *** Quits: kris (kris@moz-6D20263F.fullrate.dk) (Ping timeout)
[17:50:53] <o11c> newguy: wait, are you on Windows? The docs are generated on Linux.
[17:51:00] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[17:51:32] <newguy> im on mac os x
[17:54:33] *** Quits: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP) (Client exited)
[17:55:05] *** Joins: arturo (Thunderbir@moz-E83B14F0.superkabel.de)
[17:56:58] <kvark> acrichto: DC is implemented for rust-compress, see #4. The interface is a bit complex,.. will see how it evolves when we have an actual usage of DC in a compressor.
[17:58:33] <Zylinski> In this short example code: https://gist.github.com/KarlZylinski/8772190 When I set 'layers = new_layers;' at the bottom of the main loop, does that simply move 'new_layers' into 'layers' without copying it's elements or will it copy the vector elements of 'new_layers' into 'layers'?
[17:59:04] *** Joins: nrc|afk (nrc@7BE24E90.A5032A01.3CFC199D.IP)
[17:59:19] *** Joins: Lovot (root@AE31FB56.8153C3BF.F3C9A2D9.IP)
[17:59:40] <kvark> Zylinksi: you can check by adding println!("{:?}",new_layers); at the end
[17:59:56] <kvark> Zylinski: ^
[18:00:01] *** Quits: aruniiird (aruniiird@28876D92.F24A7F1B.260B031E.IP) (Ping timeout)
[18:00:15] <Zylinski> oh, I can see it that value has been moved away using that you mean? :)
[18:00:19] <Zylinski> see if*
[18:00:29] <kvark> yeah. I bet on it being moved
[18:00:39] <Zylinski> Ok, thank you
[18:00:43] <strcat> Zylinski: assign/passing is always a shallow copy
[18:00:49] <kvark> rustc will complain that the value has been moved, if it has
[18:00:59] <strcat> there aren't exceptions, rust will never do an implicit heap allocation as there are no copy/move constructors like C++
[18:01:14] <strcat> closer to C in that regard (passing/assigning/returning is always equivalent in depth to C)
[18:02:04] <Zylinski> Didn't compile because new_layers was moved :)
[18:02:35] <Zylinski> I love rustc, whenever my code actually compiles I almost never have any issues except logical ones
[18:02:35] *** Joins: jvoorhis (jvoorhis@moz-84A91726.ptld.qwest.net)
[18:03:56] <Zylinski> It forces me to write better code, which is nice. This way of writing code has affected my day job as well, I've stopped using null in c# for instance : )
[18:04:23] *** Quits: jvoorhis (jvoorhis@moz-84A91726.ptld.qwest.net) (Ping timeout)
[18:05:41] <newguy> why is it that this gives me a mismatched type compilation error: os::change_dir(Path::new(relative_path)); where relative path is a ~str
[18:07:14] *** Joins: p1start (rewi@moz-A082F561.adsl.xtra.co.nz)
[18:07:37] *** Joins: tcreate (tcreate@moz-90E5C923.hsd1.ma.comcast.net)
[18:08:15] <strcat> newguy: what's the type error it gives
[18:08:28] <newguy> expected `&std::path::posix::Path` but found `std::path::posix::Path` (expected &-ptr but found struct std::path::posix::Path)
[18:08:42] <strcat> because change_dir takes &Path and you're giving it Path
[18:08:59] <strcat> need &Path::new(...)
[18:09:12] *** Joins: moostik (Icedove@moz-133D2136.w92-139.abo.wanadoo.fr)
[18:09:15] <newguy> fixed it. thanks. sorry im new to rust :(
[18:09:40] <strcat> no need to apologize
[18:09:55] *** Quits: p1start (rewi@moz-A082F561.adsl.xtra.co.nz) (Ping timeout)
[18:10:01] *** Quits: elij (elij@E6C4342E.9D386EAF.AF7F4FE0.IP) (Ping timeout)
[18:11:05] *** Joins: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[18:12:05] *** Quits: alex-abreu (alex@moz-7421D6C9.mc.videotron.ca) (Client exited)
[18:12:46] *** Quits: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net) (Ping timeout)
[18:13:08] *** Joins: alan_andrade (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net)
[18:13:57] *** Joins: elij (elij@E6C4342E.9D386EAF.AF7F4FE0.IP)
[18:14:06] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[18:14:21] <jxs> in the ownership section on the tutorial says that "Rust formalizes the concept of object ownership to delegate management of an object's lifetime to either a variable or a task-local garbage collector." in this case what is a task local garbage collector?
[18:14:47] <eddyb> jxs: ignore that part, legacy cruft
[18:14:58] <eddyb> it's not really a GC and it's on its way out
[18:15:03] <jxs> ok, i can also remove it and PR
[18:15:12] <eddyb> possibly
[18:15:14] <jxs> since i am on it
[18:15:32] *** Quits: alan_andrade (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net) (Ping timeout)
[18:15:57] <jxs> also "An object's owner is responsible for managing the lifetime of the object by calling the destructor, and the owner determines whether the object is mutable." how can the owner manage the lifetime of the object?
[18:16:14] *** Joins: kris (kris@moz-6D20263F.fullrate.dk)
[18:16:14] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[18:16:19] <eddyb> jxs: my moving something like ~T around
[18:16:32] *** Quits: hacker_sam (hacker_sam@C0FE520A.661C02A7.B0CE379A.IP) (Ping timeout)
[18:16:52] *** Joins: hacker_sam (hacker_sam@C0FE520A.661C02A7.B0CE379A.IP)
[18:18:59] <jxs> ah ok thanks, but also when a variable allocates memory on the heap with let y = ~10;  when a goes of the scope the memory is freed?
[18:19:39] <eddyb> jxs: yeah
[18:20:25] <eddyb> jxs: the thing with the lifetimes.... if you return ~T from a function and put it on the stack of the caller, it has a "longer" lifetime. if you put it in a static mut (unsafely), it has 'static lifetime, etc.
[18:23:15] <jxs> ok thanks eddyb, also back to GC, theres no GC but there's a mechanism that at the end of each scope free's memory from variables that go out of scope, is that right? 
[18:23:49] <eddyb> jxs: that's not garbage collection, that's RAII
[18:24:24] <jxs> ok nice thanks eddyb!
[18:25:11] *** Joins: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP)
[18:25:25] <strcat> jxs: it calls the destructor when a variable goes out of scope
[18:25:29] <strcat> doesn't necessarily free memory
[18:25:39] <strcat> for example, Rc's destructor decreases the reference count
[18:25:48] <strcat> calling clone increases the reference count
[18:26:19] <jxs> ok, and when the rc is decreased, when is the memory freed?
[18:26:40] *** Quits: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP) (Connection reset by peer)
[18:26:49] <pyon> jxs: When the reference count drops to zero, the object is dropped and the corresponding memory freed?
[18:26:57] *** Joins: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP)
[18:27:19] *** Joins: p1start (rewi@moz-A082F561.adsl.xtra.co.nz)
[18:27:23] <strcat> yes, although it's a bit more complicated because it supports weak pointers
[18:27:31] <strcat> but if it didn't support weak pointers, that's what it would do
[18:27:57] *** Quits: bt3ze (bt3ze@moz-3F0303DA.hsd1.va.comcast.net) (Client exited)
[18:28:22] *** Joins: bt3ze (bt3ze@moz-3F0303DA.hsd1.va.comcast.net)
[18:28:48] *** Quits: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP) (Ping timeout)
[18:29:23] *** Joins: new_one (new_one@6F9548B7.4BFECEA2.B3C0173E.IP)
[18:30:07] <jxs> pyon, yes but the memory is allocated right? so it's unavailable for allocation and needs to be freed
[18:30:16] *** Quits: bt3ze (bt3ze@moz-3F0303DA.hsd1.va.comcast.net) (Ping timeout)
[18:30:22] <jxs> even if are no references pointing to it
[18:30:30] <jxs> there are*
[18:31:16] <pyon> jxs: It could internally use a dumb C pointer with no ownership semantics. When the object needs to be freed, you just cast the dumb pointer to a owned pointer.
[18:33:00] <newguy> is it not possible to initialize a global vector in rust?
[18:33:21] <doomlord_> a 'global' ? what do you want one of them for :)
[18:33:30] <pyon> newguy: It is possible to initialize a static fixed-size vector of constants.
[18:34:01] <doomlord_> ok some sort of lut
[18:34:30] <pyon> newguy: But then the type is not ~[T], rather, [T, ..5] (replace 5 with whatever the actual size is).
[18:34:34] <newguy> oh but it cant be mutable?
[18:34:36] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[18:34:46] <pyon> newguy: static variables in general cannot be mutable.
[18:34:47] <newguy> for example: static mut history_log: ~[~str] = ~[];
[18:34:50] <newguy> :(
[18:34:52] <pyon> newguy: And this is a Good thing.
[18:34:56] <pyon> Good Thing*
[18:35:28] <newguy> but i'd like to access a vector from somewhere other than the current scope
[18:35:53] <pyon> newguy: If you want to share a mutable object across tasks, you can use either a MutexArc or a RWArc (both in extra).
[18:36:43] <arturo> hi, isn't it possible to create a generic method? the implementation compiles ok but when calling it i always get "error: cannot call a generic method through an object"
[18:36:47] <newguy> im able to create a static mutable int but not a vector
[18:37:06] <pyon> newguy: Both ensure that no two users can write to the same object concurrently, and, in the case of RWArc, it allows concurrent reads, but not concurrent writes or reads-writes.
[18:37:17] <pyon> newguy: Static mutable int?
[18:37:24] <newguy> pyon: yes
[18:37:39] <pyon> Has the language definition changed when I was not looking? :-O
[18:37:49] <newguy> static mut visitor_count: int = 0;
[18:37:51] <newguy> that line compiles
[18:37:57] <newguy> when it is outside of main
[18:38:18] *** Quits: nooblit (Mibbit@moz-CBA73F0A.dhcp.ftwo.tx.charter.com) (Quit: http://www.mibbit.com ajax IRC Client)
[18:38:52] *** Quits: jga (asdf@AB3456D.C4F09350.B5524284.IP) (Ping timeout)
[18:39:47] <pyon> newguy: This line compiles as well: "static mut x: [int, ..5] = [0,1,2,3,4];"
[18:40:19] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[18:40:54] <jroweboy> What does it mean for something to implement the 'Send' Trait. I can't really find anything on what is required to implement the Send trait
[18:41:09] <pyon> jroweboy: It means it can be sent across tasks.
[18:41:27] <pyon> jroweboy: For example, you cannot send Rc<T>s across tasks.
[18:41:35] <jroweboy> pyon: How come?
[18:42:23] <eddyb> it's not safe
[18:42:59] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[18:43:02] <newguy> pyon: how would i create a mutable vector that holds strings?
[18:43:03] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Connection reset by peer)
[18:43:29] *** Joins: Jesin (Jesin@moz-3A2C5D36.washdc.fios.verizon.net)
[18:43:38] <eddyb> newguy: RWArc<Vec<~str>> I would say
[18:43:46] <eddyb> if you need it across tasks and whatnot
[18:44:17] <pyon> Yeah, RWArc is your friend - when there are races, it ensures one task can modify the object at a time.
[18:44:34] <jroweboy> Ah ok then. Well, when I try to make a struct that is sendable it says that I can't have any ~ pointers or any &'a pointers in it. What kind of lifetimes are allowed in Send then?
[18:44:58] <pyon> jroweboy: Huh? ~ pointers are very much allowed.
[18:45:09] <eddyb> they are the only ones allowed, apart from arcs, really
[18:45:16] <pyon> jroweboy: If you are the sole owner, you can transfer that sole ownership to a different task.
[18:45:30] *** Joins: Ms2ger (Ms2ger@B7B2FF50.C60A97A6.F9FB0584.IP)
[18:45:33] <jroweboy> pyon: Oh, I got that wrong :) My struct in question only has &'a lifetimes in it :p
[18:45:48] <pyon> jroweboy: Well, tasks have unsynchronized lifetimes.
[18:46:03] <pyon> jroweboy: So if you have a lifetime in the context of one task, that lifetime might not even make sense in the other task.
[18:46:13] <eddyb> jroweboy: &'static is fine because it lives in static memory, presumably. everything else isn't safe
[18:46:29] <eddyb> (lifetime-wise)
[18:46:33] <pyon> jroweboy: Oh, yeah, I was talking about non-static lifetimes.
[18:46:46] *** Quits: p1start (rewi@moz-A082F561.adsl.xtra.co.nz) (Ping timeout)
[18:47:43] <jroweboy> So I can have a static variable inside my non static struct correct? Lemme go try something real fast
[18:48:12] <pyon> jroweboy: "struct Foo { bar: &'static Bar, baz: &'static Baz }" is perfectly okay.
[18:49:29] <jroweboy> pyon: Thanks a bunch! I got it to work now :D
[18:50:08] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[18:50:10] *** Joins: onelson (owen@18CF7301.95770028.5B6BFE7D.IP)
[18:50:16] <pyon> jroweboy: Note, however, that &'static is very limited in terms of what it can point to - it can only point to static objects.
[18:51:04] *** Quits: stephenmac7 (quassel@moz-F2C114C1.hsd1.fl.comcast.net) (Client exited)
[18:51:50] <arturo> isn't this allowed? struct SomeStruct; impl SomeStruct{ fn some_fn<T>(p: P<T>){....}}
[18:51:51] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[18:52:03] <arturo> it compiles fine but then i cannot call it
[18:52:20] *** Joins: bt3ze (bt3ze@moz-3F0303DA.hsd1.va.comcast.net)
[18:52:20] <pyon> arturo: Show us the code where the call is made.
[18:53:36] <jroweboy> pyon: Thanks for that point. Another question I'm having is why can I not index a tuple like its an vector (like in python a tuple can be indexed [0][1]..etc) Is there some reason for not allowing that
[18:53:53] <pyon> jroweboy: Because tuples and vectors are conceptually different things.
[18:54:13] <sp3d> jroweboy: because tuples consist of elements with varying types 
[18:54:17] <pyon> jroweboy: Actually, Python does the wrong thing in treating them like they belong to the same mathematical sort.
[18:54:21] <sp3d> but expressions must have a definite type
[18:55:16] <newguy> If i create an RWArc vector, should this be declared inside main or can i declare it globally
[18:55:17] <newguy> ?
[18:55:59] <arturo> pyon: something like http://pastebin.com/E5SR974M
[18:56:28] <arturo> in renderer.draw i get error: cannot call a generic method through an object
[18:56:46] <pyon> rusti: struct Foo; struct Bar<T>; impl Foo { fn foo<T>(_: Bar<T>) { println!("Success!") } } let bar: Bar<int> = Bar; Foo::foo(bar) // arturo
[18:56:47] -rusti- Success!
[18:56:47] -rusti- ()
[18:57:44] <enix> I'm a bit confused about why Rust requires me to manually derive some impls that feel unecessary. I'm not quite sure how to phrase my question succinctly, so, I put it here: https://gist.github.com/DaGenix/8772910. Any help would def be appreciated!
[18:57:48] <pyon> arturo: How is mesh declared?
[18:57:48] *** Quits: canhtak (canhtak@moz-8A625E1D.wl.t.ulaval.ca) (Quit: canhtak)
[18:57:58] *** Joins: canhtak (canhtak@moz-8A625E1D.wl.t.ulaval.ca)
[18:58:13] <arturo> it's a struct, i think it works for static functions but not if it's called through an object
[18:58:24] <arturo> foo.foo(bar) won't work
[18:59:03] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[18:59:14] <eddyb> enix: you can always take &T instead of T
[18:59:57] *** Quits: teosz (teosz@EB63E8F2.1AC00AF5.3EA6AAD8.IP) (Ping timeout)
[18:59:58] <eddyb> enix: if we have autoref for regular function arguments, it would make both foo(x) and foo(&x) work
[19:00:10] <pyon> rusti: struct Foo; struct Bar<T>; impl Foo { fn foo<T>(&self, _: Bar<T>) { "Success!" } } let foo = Foo; let bar: Bar<int> = Bar; foo.foo(bar) // arturo
[19:00:12] -rusti- pastebinned 5 lines of output: http://ix.io/ahE
[19:00:12] *** Joins: pepper_chico (pepper_chi@2E27DB8.A156809A.4D7FED01.IP)
[19:00:15] <pyon> dang
[19:00:34] <pyon> rusti: struct Foo; struct Bar<T>; impl Foo { fn foo<T>(&self, _: Bar<T>) -> &'static str { "Success!" } } let foo = Foo; let bar: Bar<int> = Bar; foo.foo(bar) // arturo
[19:00:36] -rusti- "Success!"
[19:01:11] <arturo> huh, weird, it's probably something else then, thanks
[19:01:13] <pzol> Is there a shorter way? let s = &~"abc.def.ghi"; s.split('.').take(1).collect::<~[&str]>().shift();
[19:01:15] <pzol> rusti: let s = &~"abc.def.ghi"; s.split('.').take(1).collect::<~[&str]>().shift();
[19:01:19] -rusti- pastebinned 7 lines of output: http://ix.io/a6T
[19:01:26] <newguy> what is a missing lifetime specifier?
[19:01:40] <pyon> newguy: Provide some context.
[19:01:48] <pyon> newguy: e.g., the code that fails.
[19:01:50] <newguy> static mut log: ~[&str] = ["hi"];
[19:02:20] <pyon> newguy: Well, when you have & references, you need to specify their lifetime, unless it can be inferred.
[19:02:26] <sp3d> "&" means it's a borrow; you can suffix 'something to & to name the lifetime of the borrow
[19:02:39] <sp3d> for a static string like "hi" you can use the special 'static (forever) lifetime
[19:02:42] <pyon> newguy: static mut log: ~[&'static str] = ["hi"];
[19:02:53] <sp3d> ^
[19:02:54] *** Quits: awidegreen (awidegreen@moz-9FADBE94.a357.priv.bahnhof.se) (Ping timeout)
[19:03:16] *** Joins: jvoorhis (jvoorhis@moz-84A91726.ptld.qwest.net)
[19:03:18] <pyon> newguy: Although something is still fishy with that ~ that has no counterpart in the right-hand side.
[19:04:28] *** Joins: daschl (Adium@moz-DC6DE6E2.vie.surfer.at)
[19:04:28] <enix> eddyb: I'm still a bit confused. I think what I don't understand is why &T isn't automatically considered to implement T
[19:04:55] <yuriks> how ofteng is rust-lang.org docs updated?
[19:04:58] *** Quits: jvoorhis (jvoorhis@moz-84A91726.ptld.qwest.net) (Ping timeout)
[19:05:04] <newguy> pyon: sorry to keep bugging you about this issue, but i still dont understand why i cannot create a global mutable vector
[19:05:07] <eddyb> enix: having &T implementing every Trait T implements is a workaround
[19:05:14] <yuriks> (nightly or after each merge?)
[19:05:47] <pyon> newguy: That would mean that you have variable-size static data, which it is my understanding is not allowed.
[19:06:18] *** Quits: daschl (Adium@moz-DC6DE6E2.vie.surfer.at) (Ping timeout)
[19:06:30] <eddyb> enix: taking things by value means moving them in a generic situation, that's why most functions that look like foo will take &T and not T
[19:06:45] <newguy> pyon: other than using RWArc, is it possible to create a vector that member functions can access?
[19:06:46] <pyon> newguy: In any case, mutable static data is unsafe (and indeed can only be used as mutable within unsafe blocks), so it is better to share mutable data across tasks using MutexArc and RWArc.
[19:06:57] *** Joins: alan_andrade (alan_andra@moz-5CEA5B40.hfc.comcastbusiness.net)
[19:07:06] <pyon> newguy: Member functions from where?
[19:07:17] <newguy> pyon: from within the same class
[19:07:21] <newguy> functions defined outside main
[19:07:28] <pzol> eddyb Is there a shorter way (getting the first word)? let s = ~"abc.def.ghi"; s.split('.').take(1).collect::<~[&str]>().shift();
[19:08:11] <eddyb> pzol: .take(1).collect::<~[&str]>().shift(); is .next()
[19:08:23] <pzol> eddyb :D
[19:08:27] <pyon> newguy: without explicitly passing it all around, right?
[19:08:33] <newguy> correct!
[19:09:06] <pyon> newguy: http://static.rust-lang.org/doc/master/std/local_data/index.html -- this could be a solution
[19:09:25] <pyon> newguy: But it is not really global, just task-local.
[19:09:51] <newguy> ok
[19:09:52] <newguy> thanks!
[19:09:58] <enix> eddyb: indeed. What I am really working on is creating a Reader that wraps another Reader. I couldn't decide if it should take the wrapped Reader by value and require an unwrap() to give it back or if it should take a reference. I was hoping that I could use generics so that it could do both when I ran into this, but, the more think about it, my approach may be flawed anyway. Thanks!
[19:10:38] <cgaebel> does anyone know how I can fix this error? http://pastebin.com/5TzTJAVk
[19:10:46] *** Joins: quasisphere (btw@DC685DC2.94302614.1D0D91FF.IP)
[19:11:13] <pyon> cgaebel: What error?
[19:11:29] *** Joins: alonlevy (alon@moz-2A967E5F.static.coditel.net)
[19:11:30] <cgaebel> pyon: in a comment near the bottom on the line it's at
[19:11:30] *** Joins: AvianFlu (AvianFlu@moz-51534E77.c3-0.43d-ubr2.qens-43d.ny.cable.rcn.com)
[19:11:43] <cgaebel> pyon: starting on line 43
[19:12:00] <pyon> cgaebel: Line 37
[19:12:08] <pyon> fn next(&'a mut self)
[19:12:16] <pyon> Perhaps that?
[19:12:35] <pyon> No, no, wait.
[19:12:37] <pyon> Ignore me.
[19:12:41] <cgaebel> error: method `next` has an incompatible type: expected concrete lifetime, but found bound lifetime parameter &
[19:12:42] <pyon> I'm dumb.
[19:12:46] <pyon> Yeah, I'm dub.
[19:12:48] <pyon> dumb*
[19:12:50] <cgaebel> I tried that, too :P
[19:14:17] *** Quits: mgottschlag (quassel@moz-3E841DE2.cust.bluewin.ch) (Ping timeout)
[19:15:37] *** Joins: alan_and_ (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net)
[19:15:39] *** Quits: alonlevy (alon@moz-2A967E5F.static.coditel.net) (Ping timeout)
[19:15:58] *** Quits: kaeso (kaeso@moz-F21FF626.unstable.it) (Ping timeout)
[19:16:10] *** Quits: a_m0d (a_m0d@moz-2F294D00.acanac.net) (Quit: Leaving.)
[19:16:29] *** Quits: pepper_chico (pepper_chi@2E27DB8.A156809A.4D7FED01.IP) (Quit: WeeChat 0.4.1)
[19:16:39] *** Quits: maxli (maxli@moz-F47DD19B.student.cs.uwaterloo.ca) (Input/output error)
[19:17:03] *** Joins: maxli (maxli@moz-B19F68ED.student.cs.uwaterloo.ca)
[19:17:56] *** Quits: eddyb (eddy@832D2DE5.66315F97.FB866788.IP) (Ping timeout)
[19:18:18] *** Quits: alan_and_ (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net) (Ping timeout)
[19:18:32] <yuriks> hmm, why do I need to put "use std;" to used std::os::args in submodules, but not on the crate root?
[19:18:36] *** Joins: jga (asdf@A2FD2A4E.7179CBA0.B5524284.IP)
[19:19:35] *** Quits: jroweboy (Mibbit@moz-18814A6B.provo.static.broadweavenetworks.net) (Quit: http://www.mibbit.com ajax IRC Client)
[19:19:40] <pzol> fn first_word(s: &str) -> &str {s.clone().split('.').next().unwrap() } gives me cannot infer an appropriate lifetime for region in type/impl due to conflicting requirements
[19:20:22] *** Quits: johnsoft (johnsoft@moz-7E09A266.neo.res.rr.com) (Ping timeout)
[19:20:25] <Ms2ger> Try fn first_word(s: &'a str) -> &'a str 
[19:20:34] *** Joins: johnsoft (johnsoft@moz-7E09A266.neo.res.rr.com)
[19:21:04] *** Joins: a_m0d (a_m0d@moz-2F294D00.acanac.net)
[19:21:07] <cmr> and drop the clone.
[19:21:20] <pzol> Ms2ger fn first_word<'a>(s: &'a str) -> &'a str {s.split('.').next().unwrap() } => borrowed value does not live long enough in the caller :(
[19:21:34] <cmr> hm
[19:23:40] *** Quits: hoverbear (hoverbear@moz-86FCBF4B.gv.shawcable.net) (Quit: This bear's gotta fly.)
[19:25:26] *** Joins: hoverbear (hoverbear@moz-86FCBF4B.gv.shawcable.net)
[19:25:48] *** Joins: rootnode (rootnode@moz-7FAB5E8.ip1.george24.com)
[19:25:53] <strcat> yuriks: you don't *need* to put use std
[19:26:00] <strcat> yuriks: in an expression, paths are relative
[19:26:10] <strcat> std::foo means 'relative to the current crate, look for std::foo'
[19:26:20] <strcat> and there's a hidden extern mod std;
[19:26:27] <strcat> yuriks: ::std::foo will work elsewhere
[19:26:32] <strcat> use statements are absolute by default
[19:26:34] <yuriks> ah, I need a leading ::
[19:26:48] <hoverbear> There any up to date Textmate syntax files for rust?
[19:27:04] <strcat> yuriks: well, I'd do 'use std;' :)
[19:27:09] <strcat> yuriks: but just pointing out why
[19:27:20] <newguy> does anyone know how to print a path variable within print? or do i have to convert to string first?
[19:27:22] <strcat> it's a bit weird
[19:27:30] <cgaebel> What's the difference between the pattern Some(ref mut bucket) and Some(&mut bucket)? Is there one?
[19:27:42] *** Joins: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP)
[19:27:46] <yuriks> strcat: it's different from C++ where you only need :: if you want to explicitly search the global namespace first
[19:28:23] <cmr> cgaebel: one takes a reference to the bucket, one is invald.
[19:28:43] <cgaebel> cmr: cool
[19:29:01] <cmr> Some(&bucket) would dereference bucket, though.
[19:29:04] *** Quits: StarLight (StarLight@moz-394A896.dynamic.avangarddsl.ru) (Ping timeout)
[19:29:23] *** Quits: maxli (maxli@moz-B19F68ED.student.cs.uwaterloo.ca) (Ping timeout)
[19:29:27] *** Joins: eddyb (eddy@832D2DE5.66315F97.FB866788.IP)
[19:29:39] *** Quits: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP) (Ping timeout)
[19:32:42] *** Joins: maxli (maxli@moz-B19F68ED.student.cs.uwaterloo.ca)
[19:32:43] <pzol> there is something inherently wrong with match() and lifetimes
[19:33:41] *** Quits: Lovot (root@AE31FB56.8153C3BF.F3C9A2D9.IP) (Ping timeout)
[19:34:55] *** Joins: tcsc (tcsc@moz-ADC0ED45.hsd1.ct.comcast.net)
[19:36:21] *** Joins: alisdair (textual@28441AAB.AC6E1995.F0AE27BD.IP)
[19:36:21] <pyon> pzol: Well, yeah, they do not play nicely.
[19:36:37] <jxs> when refering to dereferencing, it's getting the value referenced in the pointer right?
[19:37:07] *** Quits: a_m0d (a_m0d@moz-2F294D00.acanac.net) (Quit: Leaving.)
[19:38:05] *** Joins: Lovot (root@AE31FB56.8153C3BF.F3C9A2D9.IP)
[19:38:10] <strcat> pzol: wrong as in unsound? or you just mean it doesn't do as much analysis as it could so it's overly strict
[19:38:42] <pyon> strcat: pzol: e.g., if you do some_map.find_mut(&key), intending to return the existing entry if it indeed exists, or insert a new entry if there is presently none, you need to use something like "some_map.find_mut(&key).map(|&entry| entry).unwrap_or_else(|| { some_map.insert(key, new_value); new_value })
[19:39:08] <strcat> it's not broken though
[19:39:10] <pyon> If you use a match, even in the None branch you cannot insert the new entry into the map.
[19:39:34] <pyon> I can objectively see why it works that way, but it is still somewhat annoying.c
[19:39:41] <strcat> borrow checking will never be as lenient as it could be in theory
[19:39:48] <strcat> it can be made better
[19:40:05] <pzol> strcat pyon  yes, similar case... 
[19:41:01] <pyon> pzol: Well, in general what you actually need is *two* matches. The first one just to project references into something non-reference-y, the second one to actually compute useful results (at least in the remaining branches).
[19:41:55] <pzol> pyon I ended up with if map.contains_key(&key) {} else {}
[19:42:09] *** Joins: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[19:42:13] <pyon> Oh.
[19:42:15] *** nrc|afk is now known as nrc
[19:42:36] <pyon> Anyway, the Share trait will only be ready in 1.0, right? :-(
[19:42:57] <pzol> pyon what's the Share trait?
[19:43:09] <newguy> Does anyone know how to get the root directory?
[19:43:24] <cmr> newguy: "get" in what way?
[19:43:36] *** Quits: Armavica (virgile@moz-AD428ED7.ens.fr) (Ping timeout)
[19:43:39] <pyon> pzol: https://github.com/mozilla/rust/issues/11781
[19:43:45] <newguy> i just want to assign it to a var
[19:43:53] <newguy> to a path variable
[19:43:55] <pyon> newguy: The root of the whole file system?
[19:43:58] *** Quits: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net) (Ping timeout)
[19:44:02] <cmr> Path::new("/")
[19:44:02] <newguy> yes
[19:44:27] <newguy> sorry, i'm being unclear
[19:44:43] <newguy> cmr: on my mac, when i use cd, it takes me right below my desktop[
[19:44:50] <newguy> cmr: isnt that my root directory?
[19:44:52] <cmr> to your home directory, yes.
[19:44:54] <pyon> newguy: that is your home directory
[19:44:54] <cmr> newguy: no.
[19:44:55] <newguy> ohhh
[19:45:07] <cmr> and it's *above* your desktop, not below it..
[19:45:15] <newguy> oh sorry
[19:45:32] <newguy> is there then a way to be able to retrieve my home directory?
[19:45:34] <eddyb> great, now chrome has a silly look to it. oh, I have the "a", must be the experimental Aura stuff
[19:45:47] <pyon> :-O
[19:46:33] * pyon stopped caring about Chrome when it started failing to synchronize my custom search engines. Firefox FTW.
[19:46:36] <eddyb> ohh, fancy scrollbars
[19:47:19] <newguy> cmr: is there a way to retrieve my home directory?
[19:47:36] <cmr> newguy: http://static.rust-lang.org/doc/master/std/index.html?search=home
[19:47:49] <cgaebel> is there a pragma like #[deprecated(use_instead=some_other_function)]?
[19:47:51] <newguy> cmr: many thanks
[19:48:06] <cmr> cgaebel: #[deprecated="Use some_other_function instead"]
[19:48:12] <cmr> cgaebel: and it's called an attribute
[19:48:25] <cgaebel> cmr: thanks!
[19:50:23] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[19:52:03] *** Quits: cgaebel (clark@ADA4DDE2.290DF317.EE6E63A5.IP) (Ping timeout)
[19:52:06] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[19:53:23] *** Joins: cgaebel (clark@ADA4DDE2.290DF317.EE6E63A5.IP)
[19:54:32] *** Joins: pilf (pilf@44BF5D7D.B6A69891.5411983D.IP)
[19:55:33] <newguy> so homedir() returns an Option<Path>, and if I try to change_dir, I get a compilation error because change_dir takes a &Path
[19:55:56] <cmr> newguy: look at the docs for Option
[19:56:03] <newguy> cmr: k
[19:57:25] *** Quits: tav (tav@moz-3A80D80B.range109-154.btcentralplus.com) (Ping timeout)
[19:59:20] *** Joins: mgottschlag (quassel@moz-3E841DE2.cust.bluewin.ch)
[20:00:05] *** Quits: cgaebel (clark@ADA4DDE2.290DF317.EE6E63A5.IP) (Ping timeout)
[20:00:43] *** Quits: Ms2ger (Ms2ger@B7B2FF50.C60A97A6.F9FB0584.IP) (Quit: nn)
[20:00:48] *** Joins: cgaebel (clark@ADA4DDE2.290DF317.EE6E63A5.IP)
[20:01:01] *** Joins: xazax (xazax@moz-D7592A2A.csoma.elte.hu)
[20:01:30] <pzol> ok ok ok I admit it... I was wrong, the compiler was right
[20:02:02] <bstrie_boot> cmr: qotw ^
[20:02:38] <cmr> recorded
[20:04:15] *** Joins: jvoorhis (jvoorhis@moz-84A91726.ptld.qwest.net)
[20:05:00] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[20:05:50] *** Quits: ricepuddin (graham@moz-7D68765A.cable.virginm.net) (Ping timeout)
[20:06:09] *** Quits: jvoorhis (jvoorhis@moz-84A91726.ptld.qwest.net) (Ping timeout)
[20:06:50] *** Quits: bt3ze (bt3ze@moz-3F0303DA.hsd1.va.comcast.net) (Client exited)
[20:07:13] *** Joins: ercxx (ercan@moz-88DD3A7E.dyn.optonline.net)
[20:07:13] *** Joins: bt3ze (bt3ze@moz-3F0303DA.hsd1.va.comcast.net)
[20:09:02] *** Quits: bt3ze (bt3ze@moz-3F0303DA.hsd1.va.comcast.net) (Ping timeout)
[20:09:18] *** Quits: cgaebel (clark@ADA4DDE2.290DF317.EE6E63A5.IP) (Ping timeout)
[20:09:33] *** Quits: arturo (Thunderbir@moz-E83B14F0.superkabel.de) (Ping timeout)
[20:09:43] *** Joins: cgaebel (clark@ADA4DDE2.290DF317.EE6E63A5.IP)
[20:09:44] <yuriks> is there a shortcut for Repeat::new(x).take(n)?
[20:09:53] <yuriks> more specifically, .take(1)
[20:10:08] <FreeFull> Making a new iterator with one element?
[20:10:15] <yuriks> yeah...
[20:10:46] <kvark> yuriks: I use Some(&x).move_iter()
[20:10:46] *** Quits: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp) (Client exited)
[20:11:07] *** Joins: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp)
[20:12:50] *** Quits: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp) (Ping timeout)
[20:13:12] <alan_andrade> Why this: "function calls in constants are limited to struct and enum constructors" ?
[20:13:16] *** Joins: arturo (Thunderbir@moz-4F69776.superkabel.de)
[20:13:50] *** Quits: newguy (Mibbit@C53B0424.8878667B.DDE5D3F6.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[20:14:01] *** Joins: bt3ze (bt3ze@moz-3F0303DA.hsd1.va.comcast.net)
[20:14:40] <alan_andrade> rusti: static GETGROUPS_T:uint = mem::size_of::<libc::c_int>();
[20:14:43] *** Joins: alonlevy (alon@E1180375.38BBA7B3.1D05C454.IP)
[20:14:46] -rusti- pastebinned 29 lines of output: http://ix.io/ahN
[20:15:12] <alan_andrade> rusti: static GETGROUPS_T:uint = mem::size_of::<int>();
[20:15:14] <cmr> alan_andrade: you can't call functions in constant expressions.
[20:15:14] -rusti- pastebinned 11 lines of output: http://ix.io/ahO
[20:15:37] <alan_andrade> I just realized that, what's the reason ?
[20:15:44] *** Quits: bt3ze (bt3ze@moz-3F0303DA.hsd1.va.comcast.net) (Ping timeout)
[20:15:57] <cmr> function calls aren't constant.
[20:17:06] <alan_andrade> but the size of an integer will always be same correct ? 
[20:17:16] <strcat> alan_andrade: no
[20:17:20] <cmr> doesn't matter, it doesn't consider function calls constant.
[20:17:31] *** Joins: marianoguerra (marianogue@moz-264F509.dip0.t-ipconnect.de)
[20:17:34] <strcat> alan_andrade: oh you mean 'on the same platform'
[20:17:36] <strcat> then yes
[20:18:32] *** Joins: alan_and_ (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net)
[20:18:37] *** Quits: mgottschlag (quassel@moz-3E841DE2.cust.bluewin.ch) (Ping timeout)
[20:18:56] <alan_andrade> I see. It makes sense.
[20:19:19] <kvark> strcat: maye we just need a size_of! macro to let these constants work?
[20:19:26] <strcat> it can't be done with a macro
[20:19:30] <cmr> kvark: sizeof is already a keyword.
[20:19:33] <cmr> just needs to be implemented.
[20:19:37] <yuriks> is there no equivalent of StrVector::connect that works on an Iterator<str> instead?
[20:19:40] <strcat> cmr: it's a keyword because it's reserved
[20:19:45] <strcat> *not* because it's viewed as a missing feature
[20:20:03] <kvark> strcat: why can't it be done in a macro?
[20:20:04] <strcat> keywords were reserved based on the potential to want them in the future
[20:20:20] <strcat> kvark: macros have no awareness of types, let alone the ability to query LLVM
[20:20:30] <strcat> they take a token tree
[20:20:36] <strcat> and operate on that
[20:20:41] <kvark> oh, macros are so weak still
[20:20:45] <cmr> "weak"
[20:20:46] <strcat> kvark: they will always be that way
[20:20:48] <cmr> they're syntax operations.
[20:20:48] <strcat> that's what macros are
[20:20:52] <cmr> that's what they were intended to be.
[20:20:56] <kvark> any plans of letting macros to access type info?
[20:20:56] <strcat> they're not type-based metaprogramming
[20:20:59] <strcat> kvark: no
[20:21:02] <strcat> that's not what macros are
[20:21:03] *** Quits: alan_and_ (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net) (Ping timeout)
[20:21:09] <cmr> kvark: macros are syntactical transformation
[20:21:12] <cmr> nothing more
[20:21:35] <strcat> macros are token tree transforms
[20:21:45] <kvark> cmr: strcat: well, Scala and Boo have a different view on what macro should be able to do
[20:22:04] <strcat> kvark: link?
[20:22:41] <cmr> kvark: http://boo.codehaus.org/Syntactic+Macros doesn't look like it?
[20:22:46] <kvark> for this example, it seems pretty straightforward to me that size_of(int) should be accessible for a constant, since we are compiling for a constant target platform
[20:23:12] <cmr> kvark: there is no requirement that parsing even has llvm available, at all.
[20:23:14] <cmr> (and it doesn't)
[20:23:27] <strcat> kvark: parsing isn't platform specific and can't be
[20:23:40] <strcat> macros are a parser feature
[20:24:04] <kvark> oh god, Boo's website is ugly
[20:24:40] <strcat> being able to call size_of would be permitted if we had CTFE
[20:24:50] <FreeFull> rusti: Some(3).as_iter()
[20:24:51] -rusti- <anon>:10:9: 11:6 error: type `std::option::Option<<generic integer #0>>` does not implement any method in scope named `as_iter`
[20:24:51] -rusti- <anon>:10         Some(3).as_iter()
[20:24:52] -rusti- <anon>:11     };
[20:24:52] -rusti- error: aborting due to previous error
[20:24:52] -rusti- application terminated with error code 101
[20:24:57] <strcat> special-casing it would be a backwards compatibility hazard and an embarassment
[20:25:01] <FreeFull> rusti: Some(3).iter()
[20:25:04] -rusti- pastebinned 16 lines of output: http://ix.io/ahP
[20:25:23] <cmr> rusti: println!("{:?}", Some(3).iter())
[20:25:26] -rusti- pastebinned 15 lines of output: http://ix.io/ahQ
[20:26:03] *** Quits: cgaebel (clark@ADA4DDE2.290DF317.EE6E63A5.IP) (Ping timeout)
[20:26:30] *** Joins: cgaebel (clark@ADA4DDE2.290DF317.EE6E63A5.IP)
[20:27:16] *** Quits: tupshin_ (quassel@moz-E7B03838.c3-0.nyr-ubr1.nyr.ny.cable.rcn.com) (Client exited)
[20:27:17] <yuriks> developing in libextra isn't very fun at all X_X. Recompiles all the way from stage0
[20:27:31] <cmr> yuriks: make check-stage1-extra NO_REBUILD=1
[20:28:26] *** Joins: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP)
[20:29:08] *** Joins: ricepuddin (graham@moz-7D68765A.cable.virginm.net)
[20:29:18] *** Joins: jeaye (jeaye@moz-34FEF2BB.hsd1.ca.comcast.net)
[20:30:07] <yuriks> cmr: that only compiles up to stage1, or only from stage1?
[20:30:22] <cmr> don't know what you mean
[20:30:29] *** Quits: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP) (Ping timeout)
[20:30:33] <yuriks> how does that differ from a regular make?
[20:30:58] <cmr> it doesn't build stage2
[20:31:07] *** Quits: cgaebel (clark@ADA4DDE2.290DF317.EE6E63A5.IP) (Ping timeout)
[20:31:32] *** Joins: cgaebel (clark@ADA4DDE2.290DF317.EE6E63A5.IP)
[20:31:36] <yuriks> what I mean by "compiles up to stage1" then
[20:31:46] <yuriks> that should be a bit faster I guess, thanks
[20:31:56] <mcpherrin> most of the time you can just build only libextra, no?
[20:32:11] <strcat> you can always just build libextra if it's all you modified
[20:32:16] <mcpherrin> depends what you're doing in libextra I guess
[20:32:24] <strcat> rustc lib.rs --test
[20:32:28] *** Quits: alonlevy (alon@E1180375.38BBA7B3.1D05C454.IP) (Ping timeout)
[20:33:34] <yuriks> I'm just doing some tweaks to the getopts library. I'll try tha once this build here finishes
[20:33:54] <strcat> or specify the stage you want and NO_REBUILD=q
[20:33:58] <strcat> NO_REBUILD=1 *
[20:34:25] <strcat> but if you have a system rustc that's new enough (I almost always do...), then that works
[20:34:36] <kvark> cmr: strcat: https://github.com/bamboo/boo/wiki/Syntactic-Macros
[20:34:43] <kvark> In boo, macros are CLI objects that implement the Boo.Lang.Compiler.IAstMacro interface
[20:34:47] <yuriks> I just add the stage2 output dir to my path
[20:35:01] <kvark> in Boo, macros are abstract CLI code with access to the full AST
[20:35:14] <yuriks> kvark: that's syntax extensions in Rust
[20:35:32] <cmr> kvark: yes, I saw that.
[20:35:42] <cmr> kvark: AST does not include type information.
[20:36:16] <kvark> cmr: I've done lots of Boo macros in the past, and I'm pretty sure I worked with types there
[20:36:24] <kvark> will try finding this code now
[20:36:33] <strcat> cmr: the AST does, a token tree doesn't
[20:36:36] <cmr> even looking at the scala docs you need to explicitly run a type checking pass to get type info.
[20:37:00] <strcat> type inference makes life a lot harder
[20:37:20] *** Quits: hdevalence (quassel@moz-D125A39F.home3.cgocable.net) (Ping timeout)
[20:37:20] *** Joins: Takuin (AndChat680@moz-21A5F23D.ks.ks.cox.net)
[20:38:14] *** Joins: xyproto (alexander@moz-251295DE.members.linode.com)
[20:38:37] <kvark> https://code.google.com/p/kri/source/browse/lib/code/spec/Simple.boo
[20:38:43] <kvark> these are my Boo macros
[20:39:07] <kvark> lots of type manipulation there
[20:39:38] <cmr> https://github.com/bamboo/boo/blob/master/src/Boo.Lang.Compiler/Ast/SimpleTypeReference.cs
[20:40:08] *** Quits: arturo (Thunderbir@moz-4F69776.superkabel.de) (Ping timeout)
[20:40:27] <cmr> looks like it's just a placeholder that's resolved later.
[20:40:50] <cmr> yes/
[20:40:52] <cmr> ?
[20:41:22] *** Joins: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp)
[20:41:25] <kvark> dunno, but at least they have a Name :)
[20:42:51] <kvark> and scala macros: http://www.scala-lang.org/api/current/index.html#scala.reflect.macros.Context
[20:43:04] *** Quits: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp) (Ping timeout)
[20:43:06] <kvark> type Type = Universe.Type  The type of Scala types, and also Scala type signatures.
[20:43:13] *** Joins: willingc (willingc@moz-B4760708.san.res.rr.com)
[20:43:18] *** Joins: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp)
[20:44:29] *** Joins: arturo (Thunderbir@moz-E83B14F0.superkabel.de)
[20:45:02] *** Quits: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp) (Ping timeout)
[20:47:12] <cmr> yeah scala seems to do weird things.
[20:47:27] *** Joins: mgottschlag (quassel@moz-3E841DE2.cust.bluewin.ch)
[20:47:27] *** Joins: dmillerw (dylan@moz-587EA058.eugn.qwest.net)
[20:47:57] <dmillerw> Say I have a vector " let colors: &[Color] = &[Color::red(), Color::black()]; ", is there any way to get the amount of elements inside it?
[20:48:10] <kvark> color.len() ?
[20:48:10] <cmr> dmillerw: .len()
[20:48:48] <dmillerw> figures I was looking for the wrong thing
[20:48:53] <dmillerw> thanks
[20:49:35] *** Quits: alan_andrade (alan_andra@moz-5CEA5B40.hfc.comcastbusiness.net) (Input/output error)
[20:49:36] <cmr> dmillerw: http://static.rust-lang.org/doc/master/complement-cheatsheet.html#how-do-i-get-the-length-of-a-vector :)
[20:49:59] <dmillerw> *bookmarks* :P
[20:50:09] *** Joins: alan_andrade (alan_andra@moz-5CEA5B40.hfc.comcastbusiness.net)
[20:50:13] *** Joins: nkoep (nik@moz-DC05FB0B.pool.mediaways.net)
[20:50:32] <yuriks> what's with rust/src/foo.c? :P
[20:50:38] <kvark> dmillerw: if only we could reverse the time to read bookmarks *before* we actually need them :)
[20:50:46] <dmillerw> That'd be wonderful
[20:50:55] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[20:51:13] *** Quits: eddyb (eddy@832D2DE5.66315F97.FB866788.IP) (Ping timeout)
[20:51:23] *** Quits: xazax (xazax@moz-D7592A2A.csoma.elte.hu) (Quit: Leaving)
[20:51:53] *** Quits: alan_andrade (alan_andra@moz-5CEA5B40.hfc.comcastbusiness.net) (Ping timeout)
[20:52:39] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[20:52:47] *** Quits: kellogh (timkellogg@moz-704A74D.hsd1.co.comcast.net) (Quit: kellogh)
[20:54:56] *** Quits: nano (nano@moz-ED77243C.superkabel.de) (Connection reset by peer)
[20:55:08] *** Quits: AvianFlu (AvianFlu@moz-51534E77.c3-0.43d-ubr2.qens-43d.ny.cable.rcn.com) (Input/output error)
[20:57:19] *** Joins: AvianFlu (AvianFlu@moz-51534E77.c3-0.43d-ubr2.qens-43d.ny.cable.rcn.com)
[20:57:38] *** Joins: jrupac (ajay@moz-BF77C4D6.nyc.res.rr.com)
[20:57:43] *** Joins: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[20:59:24] *** Quits: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net) (Ping timeout)
[21:01:42] *** Joins: nszceta (hax@moz-E6CA8D6.hsd1.pa.comcast.net)
[21:02:32] *** Joins: alan_andrade (alan_andra@moz-7559582E.hsd1.ca.comcast.net)
[21:03:32] *** Quits: ercxx (ercan@moz-88DD3A7E.dyn.optonline.net) (Quit: WeeChat 0.4.2)
[21:04:13] *** Joins: awidegreen (awidegreen@moz-9FADBE94.a357.priv.bahnhof.se)
[21:04:15] *** Joins: derek_c (derek@moz-DDB48529.cit.cornell.edu)
[21:04:18] *** Joins: alexherbo2 (alexherbo2@moz-5686FDD1.w83-199.abo.wanadoo.fr)
[21:04:50] *** Joins: jvoorhis (jvoorhis@moz-84A91726.ptld.qwest.net)
[21:06:36] *** Quits: jvoorhis (jvoorhis@moz-84A91726.ptld.qwest.net) (Ping timeout)
[21:08:03] *** Quits: awidegreen (awidegreen@moz-9FADBE94.a357.priv.bahnhof.se) (Ping timeout)
[21:08:21] <jxs> guys, when doing mutable operations inside a function, boxes can't be passed by reference, must always move ownership right?
[21:08:22] *** Quits: tcreate (tcreate@moz-90E5C923.hsd1.ma.comcast.net) (Connection reset by peer)
[21:08:39] *** Joins: tcreate (tcreate@moz-90E5C923.hsd1.ma.comcast.net)
[21:08:56] <strcat> jxs: what do you mean by boxes?
[21:09:06] *** Joins: olivier (olivier@F06FF1D6.4D0638.416762B.IP)
[21:09:16] <strcat> ~T has value semantics, but you can pass &mut T pointing into that box
[21:09:24] <strcat> or &mut ~T (although you usually wouldn't want that)
[21:09:35] *** Quits: sigma (sigma@C91C7F36.70518F41.9D18269F.IP) (Ping timeout)
[21:11:20] <jxs> by boxes i mean variables with heap references
[21:11:26] <jxs> ok strcat 
[21:11:50] <jxs> so, when doing mutable operations one should always move ownership to the function
[21:12:01] <strcat> jxs: no, that doesn't really make sense
[21:12:33] <strcat> &mut exists
[21:13:02] <strcat> passing/assigning/returning is by-shallow-copy
[21:13:31] <strcat> if the type contains NoPod, &mut, a destructor or a closure then it moves ownership
[21:13:37] *** Quits: new_one (new_one@6F9548B7.4BFECEA2.B3C0173E.IP) (Ping timeout)
[21:13:38] *** Joins: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp)
[21:13:45] *** Joins: awidegreen (awidegreen@moz-9FADBE94.a357.priv.bahnhof.se)
[21:14:08] <olivier> Hey #rust, is there a reason some HashTable Methods accepts a "reference" key, e.g. get, while some others accept only a "value" key, e.g. insert_or_update_with ? Why shouldn't I be able to pass a reference to insert_or_update_with ?
[21:14:17] *** Joins: kellogh (timkellogg@moz-704A74D.hsd1.co.comcast.net)
[21:14:50] <strcat> olivier: if it needs to take ownership, it takes a value
[21:14:55] <strcat> if it doesn't, then it takes a reference
[21:15:15] <jxs> as &mut you mean for example fn increment(mut x: &int) ?
[21:15:18] <strcat> olivier: you can certainly store references in a hash table, but you can also store non-references
[21:15:23] *** Quits: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp) (Ping timeout)
[21:15:29] <strcat> jxs: no
[21:15:33] *** Quits: Kxepal (Miranda@moz-1A176845.pppoe.mtu-net.ru) (Quit: Kxepal)
[21:15:39] <strcat> jxs: you can't mutate through that reference
[21:15:47] <strcat> you have a mutable variable, holding an immutable reference
[21:15:55] *** Quits: pyon (user@B454AC64.92B6FB33.1C8C8CE9.IP) (Quit: restart)
[21:15:56] *** Joins: Kxepal (Miranda@moz-1A176845.pppoe.mtu-net.ru)
[21:16:24] <jxs> ahh ok
[21:16:43] *** Quits: Zylinski (karl@moz-58495553.static.spa.siw.siwnet.net) (Ping timeout)
[21:17:18] *** Joins: payload (Mibbit@moz-5D7AF663.dip0.t-ipconnect.de)
[21:18:31] <strcat> jxs: mutability is inherited from the owner
[21:18:39] <strcat> a reference doesn't express ownership though
[21:18:52] <strcat> &int doesn't express ownership of an int, it's an immutable view of an int
[21:19:20] <strcat> &mut int is a mutable view of an int
[21:19:31] <strcat> there are both & and &mut *because* they don't express ownership
[21:20:34] <jrupac> quick question, now that 'do foo {...}' is gone, are there any cases where you can use a lambda block expression without the '|...|' before the block?
[21:20:48] *** Joins: new_one (new_one@6F9548B7.4BFECEA2.B3C0173E.IP)
[21:20:59] <jxs> strcat, but I if only have fn increment(x: &int) then i get "cannot assign to imutable dereference of &pointer"
[21:21:04] *** Joins: alan_and_ (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net)
[21:21:26] *** Quits: canhtak (canhtak@moz-8A625E1D.wl.t.ulaval.ca) (Quit: canhtak)
[21:21:27] <strcat> 16:19:59       strcat | &int doesn't express ownership of an int, it's an immutable view of an int
[21:21:28] <strcat> 16:20:27       strcat | &mut int is a mutable view of an int
[21:21:41] <strcat> jxs: &int is an immutable reference
[21:21:46] <strcat> you can't mutate what it observes
[21:21:50] *** Quits: blank_name (blank_name@75624DB1.E6D3F868.537E532E.IP) (Ping timeout)
[21:22:13] <strcat> whether or not you make the variable holding the reference mutable, that just determines whether you can assign another reference to the variable
[21:23:03] <strcat> rusti: fn increment(x: &mut u32) { *x += 1 } let mut x = 5; increment(&mut x); x
[21:23:04] -rusti- 6u32
[21:23:28] *** Quits: alan_and_ (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net) (Ping timeout)
[21:23:30] <strcat> `x` owns the integer
[21:23:37] <strcat> er
[21:23:42] <strcat> let me rename one of those
[21:23:50] <strcat> rusti: fn increment(a: &mut u32) { *a += 1 } let mut x = 5; increment(&mut x); x
[21:23:52] -rusti- 6u32
[21:24:07] <strcat> `x` owns the integer, and &mut x obtains a mutable reference observing it
[21:24:14] <strcat> the reference doesn't own it
[21:24:33] <strcat> so whether or not the variable holding the reference is mutable doesn't matter
[21:24:38] <nrc> if I have a fn which takes a closure f and I want to use it in a closure which I pass to another fn, I get errors because f is a non-copyable stack closure and is moved and I use it. Is there a way out here?
[21:24:40] <nrc> i.e, code is fn f1(f: |...|) { f2(..., |x| { ...; f(x); })}
[21:25:21] <jxs> ok strcat thanks!
[21:25:33] *** Joins: ofeldt (ofeldt@moz-1A2A81B5.dip0.t-ipconnect.de)
[21:26:30] *** Quits: ofeldt- (ofeldt@moz-7B3F5D4E.dip0.t-ipconnect.de) (Ping timeout)
[21:28:52] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Ping timeout)
[21:29:11] *** Joins: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP)
[21:30:32] *** Quits: aurynj (Eon@583ABBE5.60FA2E28.B9E25744.IP) (Ping timeout)
[21:30:44] *** Joins: Seb (Seb@moz-97344273.actrix.co.nz)
[21:31:08] *** Quits: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP) (Ping timeout)
[21:31:09] *** Joins: lpy_ (lpy@B744D17C.B31F127E.E99F7FDB.IP)
[21:32:20] <reima> How do I initialize a fixed size vector with a vector slice?
[21:32:51] *** Quits: lpy_ (lpy@B744D17C.B31F127E.E99F7FDB.IP) (Ping timeout)
[21:33:37] <strcat> reima: iterate over both and assign
[21:33:48] <strcat> there are convenience methods to do it
[21:34:08] *** Quits: mgottschlag (quassel@moz-3E841DE2.cust.bluewin.ch) (Ping timeout)
[21:34:57] *** Quits: exobit_ (textual@moz-E06F46F0.corp.bitshelter.com) (Ping timeout)
[21:35:21] <reima> let x: [u8, ..4] = [0, ..4]; and then assign?
[21:37:15] <eibwen> can I tell the rust compiler that a specific type must not fall out of scope? like undefining the desctructor?
[21:37:19] <strcat> reima: yes
[21:37:20] *** Joins: newguy (Mibbit@490AFC12.A9DA0237.DDE5D3F6.IP)
[21:37:48] <cgaebel> eibweb: I think std::unsafe::intrinsics::forget() is what you're looking for
[21:38:03] <reima> strcat: So I assume there is no way to get around the zero (or whatever) initialization?
[21:38:26] <cgaebel> reima: std::unsafe::intrinsics::uninit() for uninitialized values!
[21:38:39] <strcat> cgaebel: not necessary for this
[21:38:40] <cgaebel> man, that module is way too useful.
[21:38:48] <strcat> it won't compile to something different
[21:38:55] <cgaebel> bah
[21:39:02] <mcpherrin> std::unsafe::screw_it_im_writing_C
[21:39:58] *** Quits: alan_andrade (alan_andra@moz-7559582E.hsd1.ca.comcast.net) (Input/output error)
[21:40:24] *** Joins: alan_andrade (alan_andra@moz-7559582E.hsd1.ca.comcast.net)
[21:40:41] <cgaebel> meh. From what I've been finding, rust is better than trying to write high performance code in basically every other language.
[21:40:53] <newguy> is fork() and exec() supported in rust?
[21:41:15] <strcat> newguy: you're free to call C functions
[21:41:16] <reima> strcat, cgaebel: Ok, thanks
[21:41:33] <newguy> strcat: thanks
[21:41:38] <strcat> cgaebel: should really verify that it's not doing what you want before reaching for unsafe code though
[21:41:59] <strcat> there aren't many cases when uninit can tell LLVM something new
[21:42:11] <cgaebel> strcat: yeah. but the inline test suite stuff is a LOT nicer than trying to do it in C.
[21:42:11] *** Quits: alan_andrade (alan_andra@moz-7559582E.hsd1.ca.comcast.net) (Ping timeout)
[21:42:31] <LinearInterpol> How was rust "started"? Flex/Bison + LLVM?
[21:42:38] <cmr> LinearInterpol: no
[21:42:40] <strcat> LinearInterpol: ocaml and a hand-written code generator
[21:42:41] <cgaebel> it made it very easy for me to verify my implementation with lots of tests before dropping in the high-performance stuff
[21:42:43] <cmr> LinearInterpol: hand writen in ocaml.
[21:42:48] <hoverbear> I'm having some trouble figuring out how to implement a "swap" between types with the recent tuple struct changes... Test: https://travis-ci.org/Hoverbear/rust-rosetta/builds/18096000 Code: https://github.com/Hoverbear/rust-rosetta/blob/master/swap.rs
[21:42:51] <LinearInterpol> ...Ah.
[21:43:50] <strcat> hoverbear: just remove the dereference
[21:44:03] <kvark> strcat: why isn't Graydon working on Rust now?
[21:44:15] <hoverbear> strcat: The prints are fine doing that, but the second call doesn't work. There is a new way to get the first item of a tuple yes? like (1,2,3).1st ?
[21:44:19] <cmr> hoverbear: for differing types, let Gizmo(ref mut inner1) = thing_one; let Waffle(ref mut inner2) = thing2; and swap inner1/inner2
[21:44:39] *** Quits: jackneill (jackneill@moz-F643C3DE.pool.digikabel.hu) (Ping timeout)
[21:44:47] <strcat> hoverbear: wrapping the outer part or the inner part is equivalent when there's one element
[21:44:47] <cmr> hoverbear: you should remove the derefence though... doesn't work on master.
[21:44:49] <strcat> it outputs the same code
[21:44:53] <strcat> er
[21:44:58] <strcat> s/wrapping/swapping/
[21:45:37] <hoverbear> cmr: What does the "ref" bit do?
[21:45:37] *** Joins: mojoB (mojoB@moz-A4312114.static.exetel.com.au)
[21:45:48] <cmr> hoverbear: take a reference to the thing being 
[21:45:52] <cmr> matched against
[21:46:03] <cmr> strcat: do you know of a better way to say what ref and ref mut do?
[21:46:19] <hoverbear> cmr: Right but I want to swap the values, not the references.
[21:46:44] <strcat> hoverbear: you were never swapping the values
[21:46:52] <hoverbear> strcat: Good point, these are pointers.
[21:46:55] <cmr> hoverbear: you take mutable references to the inner field, and swap their contents.
[21:47:02] <cmr> the contents just happen to be &'static str
[21:47:06] <kimundi> hoverbear: swap is implemented by taking mutable references to both values
[21:47:16] <strcat> hoverbear: struct Foo(int); is the same size of int and swapping the outer part is the same as getting a ref to the inner part and swapping it
[21:47:25] *** Joins: blank_name (blank_name@75624DB1.E6D3F868.537E532E.IP)
[21:48:00] <strcat> hoverbear: I would look at what C is doing on rosetta rather than C++
[21:48:07] <strcat> rust is more like C when it comes to this stuff
[21:48:10] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[21:48:15] <hoverbear> strcat: I'm not looking at either, but yes I generall compare it with C
[21:48:27] <strcat> no move/copy constructors, and references are values rather than special
[21:48:47] <cmr> Gizmo and Waffle are different types, which is why you need to swap their guts.
[21:48:59] <hoverbear> cmr: Yes, I think so, I'm not sure how though.
[21:49:15] <strcat> rusti: let x = 5; let y = &x; *y
[21:49:17] -rusti- 5
[21:49:19] <strcat> is the same as
[21:49:24] <strcat> rusti: let x = 5; let ref y = x; *y
[21:49:24] <cmr> let Gizmo(ref mut inner1) = thing_one; let Waffle(ref mut inner2) = thing2; swap(inner1, inner2);
[21:49:26] -rusti- 5
[21:49:28] <strcat> why?
[21:49:31] *** Quits: jviereck (Adium@moz-56DDD13.dip0.t-ipconnect.de) (Quit: Leaving.)
[21:49:31] <strcat> because `x` is a pattern
[21:49:50] <olivier> hey, is it normal this isn't compiling?
[21:49:52] <strcat> rusti: let x = (5, 10); let (a, _) = x; a
[21:49:54] <olivier> fn main() { /*
[21:49:54] -rusti- 5
[21:49:55] <olivier> //*/ }
[21:49:56] <strcat> rusti: let x = (5, 10); let (ref a, _) = x; a
[21:49:59] -rusti- pastebinned 16 lines of output: http://ix.io/ahW
[21:50:01] <hoverbear> cmr: That's strange syntax. O.o
[21:50:02] <strcat> rusti: let x = (5, 10); let (ref a, _) = x; *a
[21:50:03] -rusti- 5
[21:50:17] <strcat> hoverbear: the syntax of `let` is 'let pattern = expr'
[21:50:30] *** Quits: dbaupp (Thunderbir@moz-68C83524.lns20.syd6.internode.on.net) (Ping timeout)
[21:50:34] <strcat> you can have any number of variable bindings in the pattern
[21:50:39] <hoverbear> strcat: So it's like a type delcaration? Or that's how I'm declaring the variable?
[21:50:51] <cmr> rustilite: fn main() { /* //*/ }
[21:50:52] -rustilite- <anon>:1:14: 1:23 error: unterminated block comment
[21:50:52] -rustilite- <anon>:1 fn main() { /* //*/ }
[21:50:52] -rustilite-                       ^~~~~~~~~
[21:50:52] -rustilite- application terminated with error code 101
[21:50:56] <strcat> hoverbear: look at the tuple example
[21:51:01] <strcat> rusti: let x = (5, 10); let (a, _) = x; a
[21:51:02] -rusti- 5
[21:51:08] <strcat> rusti: let x = (5, 10); let (a, b) = x; a + b
[21:51:09] -rusti- 15
[21:51:14] *** Joins: kvanb (kvanb@moz-70B2A571.lnse5.win.bigpond.net.au)
[21:51:16] <hoverbear> Ah, ok, I'll play around with it.
[21:51:17] <strcat> rusti: let x = (5, 10); let (ref a, _) = x; *a
[21:51:18] -rusti- 5
[21:51:25] <strcat> hoverbear: ref asks to bind the variable by-ref
[21:51:26] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[21:51:38] <strcat> hoverbear: in that last one, it's a reference into the tuple
[21:51:43] *** Joins: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp)
[21:51:47] <strcat> rusti: let x = (5, 10); let (ref a, b) = x; *a + b
[21:51:49] -rusti- 15
[21:51:54] <strcat> there, `a` is &int, `b` is int
[21:52:13] <olivier> cmr: Is this expected behavior?
[21:52:25] <strcat> rusti: use std::util::swap; let x = (5, 10); let (ref mut a, ref mut b) = x; swap(a, b); x
[21:52:29] -rusti- pastebinned 8 lines of output: http://ix.io/ahX
[21:52:39] <strcat> rusti: use std::util::swap; let mut x = (5, 10); let (ref mut a, ref mut b) = x; swap(a, b); x
[21:52:40] -rusti- (10, 5)
[21:52:48] <strcat> hoverbear: swapping the tuple elements
[21:53:11] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[21:53:11] <strcat> anyway the syntax for a variable binding is a pattern is
[21:53:16] <strcat> [ref] [mut] identifier
[21:53:21] <strcat> where ref and mut are optional
[21:53:22] <olivier> rustilite: fn main() { /*//*/ }
[21:53:24] -rustilite- <anon>:1:14: 1:22 error: unterminated block comment
[21:53:24] -rustilite- <anon>:1 fn main() { /*//*/ }
[21:53:24] -rustilite-                       ^~~~~~~~
[21:53:24] -rustilite- application terminated with error code 101
[21:53:26] *** Quits: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp) (Ping timeout)
[21:53:40] <strcat> atm there's no way to obtain a mutable variable holding a mutable reference via a binding
[21:53:43] <olivier> is this not compiling expected behavior?
[21:53:44] <olivier> fn main() { /*//*/ }
[21:53:49] <olivier> rustilite: fn main() { /*//*/ }
[21:53:49] -rustilite- <anon>:1:14: 1:22 error: unterminated block comment
[21:53:49] -rustilite- <anon>:1 fn main() { /*//*/ }
[21:53:49] -rustilite-                       ^~~~~~~~
[21:53:49] -rustilite- application terminated with error code 101
[21:54:09] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.2)
[21:54:16] <SiegeLord> You're opening two block comments
[21:54:20] <SiegeLord> One nested in the other
[21:54:55] <olivier> Ok
[21:55:07] <olivier> I was thinking C++ comments
[21:55:08] <olivier> thanks
[21:55:54] <olivier> Helped by the fact that kate rust coloring doesn't support nested block comments
[21:56:20] *** Quits: eibwen (kvirc@moz-A786C6BF.dip0.t-ipconnect.de) (Ping timeout)
[21:56:26] <newguy> what is the relation between tasks and ports/channels?
[21:56:37] <newguy> are they related at all?
[21:56:52] *** Quits: tcreate (tcreate@moz-90E5C923.hsd1.ma.comcast.net) (Client exited)
[21:58:02] *** Joins: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[21:58:39] <kimundi> newguy: The latter can be used to communicate between the former
[21:59:01] <newguy> thanks
[21:59:14] *** Joins: bt3ze (bt3ze@moz-3F0303DA.hsd1.va.comcast.net)
[21:59:29] *** Quits: new_one (new_one@6F9548B7.4BFECEA2.B3C0173E.IP) (Ping timeout)
[21:59:44] *** Quits: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net) (Ping timeout)
[21:59:45] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[22:01:55] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[22:03:49] *** Joins: new_one (new_one@6F9548B7.4BFECEA2.B3C0173E.IP)
[22:04:42] *** Quits: blank_name (blank_name@75624DB1.E6D3F868.537E532E.IP) (Ping timeout)
[22:05:15] *** Joins: tcreate (tcreate@moz-90E5C923.hsd1.ma.comcast.net)
[22:05:35] *** Joins: jvoorhis (jvoorhis@moz-84A91726.ptld.qwest.net)
[22:06:11] *** Quits: payload (Mibbit@moz-5D7AF663.dip0.t-ipconnect.de) (Quit: http://www.mibbit.com ajax IRC Client)
[22:06:44] *** Quits: bt3ze (bt3ze@moz-3F0303DA.hsd1.va.comcast.net) (Client exited)
[22:07:14] *** Joins: bt3ze (bt3ze@moz-3F0303DA.hsd1.va.comcast.net)
[22:07:21] *** Quits: jvoorhis (jvoorhis@moz-84A91726.ptld.qwest.net) (Ping timeout)
[22:07:21] *** Quits: assaf__ (assaf@moz-793E73B7.cable.012.net.il) (Ping timeout)
[22:07:34] <dmillerw> Trying out the ncurses lib, and it's calling for a library called GL on linux, but I can't for the life of me figure out what it is
[22:07:38] <dmillerw> (
[22:07:47] <dmillerw> #[link(name = "GL")]
[22:08:07] *** Joins: blank_name (blank_name@75624DB1.E6D3F868.537E532E.IP)
[22:08:31] *** Quits: derek_c (derek@moz-DDB48529.cit.cornell.edu) (Ping timeout)
[22:08:47] <o11c> ytf does ncurses need OpenGL ?
[22:08:58] *** Quits: bt3ze (bt3ze@moz-3F0303DA.hsd1.va.comcast.net) (Ping timeout)
[22:09:04] <mcpherrin> dmillerw: aka libGL
[22:09:13] <mcpherrin> aka http://dri.freedesktop.org/wiki/libGL/
[22:10:05] *** Quits: blank_name (blank_name@75624DB1.E6D3F868.537E532E.IP) (Ping timeout)
[22:10:30] *** Joins: bt3ze (bt3ze@moz-3F0303DA.hsd1.va.comcast.net)
[22:10:45] <dmillerw> Ahhh. Didn't expect that
[22:11:29] *** Quits: heftig (heftig@moz-3471764.dip0.t-ipconnect.de) (Ping timeout)
[22:11:35] <newguy> bt3ze: are you available?
[22:11:53] <Takuin> Remember ubuntu seperates runtime from development files too
[22:12:04] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.2)
[22:12:22] *** Joins: assaf__ (assaf@moz-7BEF2C55.inter.net.il)
[22:13:02] *** Quits: willingc (willingc@moz-B4760708.san.res.rr.com) (Quit: Leaving...)
[22:13:57] <hoverbear> cmr, strcat: Thanks for the help with that, I didn't know Rust did destructuring, that's really cool.
[22:16:46] *** Joins: heftig (heftig@moz-EC7CAF60.dip0.t-ipconnect.de)
[22:17:44] <NiccosSystem> What are the |s used for
[22:18:12] <NiccosSystem> That looked kind of blunt, should've put a ? there
[22:19:09] <SiegeLord> As in the binary/boolean or operator or as in the |a| expr ?
[22:19:44] <NiccosSystem> the |a| expression
[22:19:46] *** Quits: awidegreen (awidegreen@moz-9FADBE94.a357.priv.bahnhof.se) (Ping timeout)
[22:20:00] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[22:20:09] <mcpherrin> NiccosSystem: |a| { ... } is a closure
[22:21:15] <NiccosSystem> like, on rust's front page there is this example -> let mut odds = nums.iter().map(|&x| x * 2 - 1); what purpose does it do
[22:21:47] <mcpherrin> NiccosSystem: The portion inside the | | binds variables which are used in the following expression
[22:22:13] *** Quits: maxli (maxli@moz-B19F68ED.student.cs.uwaterloo.ca) (Input/output error)
[22:22:33] <mcpherrin> NiccosSystem: map() is a function that takes a closure and applies it to each item in the iterator
[22:23:03] *** Joins: maxli (maxli@moz-B19F68ED.student.cs.uwaterloo.ca)
[22:23:04] <NiccosSystem> so it is kind of like a quick function
[22:23:29] *** Joins: alan_andrade (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net)
[22:23:29] <mcpherrin> NiccosSystem: Yes.  The function doesn't have a name, and you don't need to explicitly give types
[22:23:32] <NiccosSystem> like a lambda?
[22:23:37] <mcpherrin> it's exactly a lambda
[22:23:41] <NiccosSystem> ah.
[22:23:48] <NiccosSystem> Cool, thanks man :-)
[22:25:56] <hoverbear> How can I "unwrap" a tuple struct inline?
[22:26:38] <kimundi> hoverbear: { Let Foo(b) = baz(); b} :P
[22:26:39] *** Quits: alan_andrade (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net) (Ping timeout)
[22:27:06] <hoverbear> rusti: struct Gizmo(&'static str); let mut thing = Gizmo("Bear"); println!("{}", thing)
[22:27:23] -rusti- pastebinned 8 lines of output: http://ix.io/ahZ
[22:27:48] <hoverbear> kimundi: Sorry, I need to afk, but that's my issue.
[22:28:00] <kimundi> what is the issue there?
[22:28:11] <hoverbear> kimundi: I want it to print "Bear"
[22:28:29] <kimundi> rusti: struct Gizmo(&'static str); let Gizmo(thing) = Gizmo("Bear"); println!("{}", thing);
[22:28:32] -rusti- pastebinned 7 lines of output: http://ix.io/a6T
[22:28:41] *** Quits: Jesin (Jesin@moz-3A2C5D36.washdc.fios.verizon.net) (Ping timeout)
[22:28:45] <kimundi> rusti: struct Gizmo(&'static str); let Gizmo(thing) = Gizmo("Bear"); println!("{}", thing)
[22:28:47] -rusti- Bear
[22:28:47] -rusti- ()
[22:29:30] <kimundi> rusti: struct Gizmo(&'static str); let thing = Gizmo("Bear"); println!("{}", {let Gizmo(x) = thing; x})
[22:29:31] -rusti- Bear
[22:29:31] -rusti- ()
[22:30:14] <hoverbear> kimundi: Ohhh the closure(?), I see. Clever.
[22:30:22] <kimundi> no closure
[22:30:32] <kimundi> its just a nested block
[22:30:38] <hoverbear> Ah, ok.
[22:30:40] *** Joins: kaeso (kaeso@moz-F21FF626.unstable.it)
[22:30:41] *** Joins: amir (amir@moz-467F7F30.cust.bluewin.ch)
[22:30:49] <kimundi> rusti: let x = { let a = 1; a + a }; x
[22:31:00] *** Joins: ljrmorgan (Mibbit@77F344AF.6095F186.A0B21F13.IP)
[22:31:39] -rusti- 2
[22:31:54] *** Joins: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP)
[22:31:55] *** Joins: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[22:32:17] *** Quits: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net) (Ping timeout)
[22:33:28] <hoverbear> COol, that works. Thanks!
[22:33:41] *** Quits: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP) (Ping timeout)
[22:36:32] <newguy> after i split a string on spaces and store them in an array, whenever i access an index, it returns the ascii value, not the &str that I want
[22:37:55] <kimundi> newguy: could you show your code?
[22:38:58] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Connection reset by peer)
[22:39:06] <newguy> solved it!
[22:39:13] <newguy> kimundi: false alarm
[22:39:17] <newguy> sorry
[22:40:28] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[22:40:50] *** Quits: jrupac (ajay@moz-BF77C4D6.nyc.res.rr.com) (Ping timeout)
[22:40:50] *** Quits: Ferreus (ferreus@moz-2583F76D.pools.arcor-ip.net) (Quit: WeeChat 0.4.3-dev)
[22:43:03] *** Joins: eibwen (kvirc@moz-EA24C30.dip0.t-ipconnect.de)
[22:43:42] *** Joins: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp)
[22:44:31] *** Quits: omnus (omnus@moz-2E009EE2.stny.res.rr.com) (Ping timeout)
[22:45:30] *** Quits: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp) (Ping timeout)
[22:45:52] *** Quits: maxli (maxli@moz-B19F68ED.student.cs.uwaterloo.ca) (Ping timeout)
[22:45:54] *** Joins: blank_name (blank_name@75624DB1.E6D3F868.537E532E.IP)
[22:46:16] *** Quits: tcreate (tcreate@moz-90E5C923.hsd1.ma.comcast.net) (Client exited)
[22:47:50] *** Joins: maxli (maxli@moz-B19F68ED.student.cs.uwaterloo.ca)
[22:48:30] *** Joins: seich_ (seich@1099D8B5.6D05C9BA.624CE61B.IP)
[22:48:45] *** nrc is now known as nrc|afk
[22:49:22] *** Quits: olivier (olivier@F06FF1D6.4D0638.416762B.IP) (Client exited)
[22:49:22] *** Quits: seich_ (seich@1099D8B5.6D05C9BA.624CE61B.IP) (Quit: Lingo - http://www.lingoirc.com)
[22:50:09] <newguy> I split on a string and store the results in an array. when i print array[1] it prints out what i expect, and then when i follow that print statement with an if statement that says if array[1] is equal to some token, it doesnt enter the if statement, even though the condition is met
[22:50:21] *** Joins: madalynn (Mibbit@moz-4A19983C.ip227.fastwebnet.it)
[22:51:14] <madalynn> what's the correct macro syntax here? http://pastebin.com/DVuuftgn it says "expected ident, found test.txt"
[22:51:58] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[22:52:27] <FreeFull> newguy: Could you show us the code?
[22:52:38] <newguy> Sure. one sec.
[22:52:50] <kimundi> madalynn: assuming you want to pass a string token like "test.txt", then the correct macro variable type would be expr
[22:52:52] *** Joins: assaf758 (assaf@moz-A7FA4FAE.cable.012.net.il)
[22:53:08] <newguy> freefull: http://pastebin.com/Q64nwX04
[22:53:28] <madalynn> thanks
[22:53:40] <newguy> freefull: the print statement prints: &
[22:53:41] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[22:53:49] <FreeFull> newguy: Are you sure there aren't any characters you can't see?
[22:53:54] *** Quits: assaf__ (assaf@moz-7BEF2C55.inter.net.il) (Ping timeout)
[22:53:55] <FreeFull> Such as \0
[22:54:05] <TheHydroImpulse> bjz cmr http://rustbyexample.github.io/ - Still working on the content, but let me know what you think
[22:54:12] <kimundi> madalynn: if you want to literally just pass the tokens of test.txt, you need to write a custom parser of filepaths and hope that all tokens are supported by rusts parser :)
[22:54:18] <FreeFull> > "Test".as_bytes()
[22:54:23] <FreeFull> rusti: "Test".as_bytes()
[22:54:25] -rusti- &[84u8, 101u8, 115u8, 116u8]
[22:54:26] *** Joins: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp)
[22:54:27] *** Quits: FrozenCow (FrozenCow@moz-E69F48E.dynamic.upc.nl) (Client exited)
[22:54:31] <FreeFull> rusti: "Test\0".as_bytes()
[22:54:33] -rusti- &[84u8, 101u8, 115u8, 116u8, 0u8]
[22:54:59] <FreeFull> rusti: println!("{} {}", "Test", "Test\0");
[22:55:02] -rusti- pastebinned 7 lines of output: http://ix.io/a6T
[22:55:09] <FreeFull> rusti: println!("{:s} {:s}", "Test", "Test\0");
[22:55:10] *** Joins: jrupac (ajay@moz-BF77C4D6.nyc.res.rr.com)
[22:55:11] <madalynn> no i just wanted to pass the path to the file, the doc gave me the impression ident was correct
[22:55:12] -rusti- pastebinned 7 lines of output: http://ix.io/a6T
[22:55:38] <FreeFull> That's not an error message I expected o.o
[22:55:39] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[22:55:42] <newguy> lol
[22:56:08] *** Quits: tcsc (tcsc@moz-ADC0ED45.hsd1.ct.comcast.net) (Quit: computer sleeping)
[22:56:21] *** Quits: madalynn (Mibbit@moz-4A19983C.ip227.fastwebnet.it) (Quit: http://www.mibbit.com ajax IRC Client)
[22:56:53] <newguy> freefull: the program enters the if statement if i enter: a & a
[22:57:10] <newguy> freefull: any token after the index that I need
[22:57:42] *** Quits: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp) (Client exited)
[22:57:56] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Quit: TheHydroImpulse)
[22:57:58] <FreeFull> newguy: Could you have it print out the bytes?
[22:58:03] *** Joins: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp)
[22:58:32] *** Joins: TheHydroImpulse (androirc@moz-7374A0F2.wireless.telus.com)
[22:59:06] *** Quits: onelson (owen@18CF7301.95770028.5B6BFE7D.IP) (Ping timeout)
[22:59:44] *** Quits: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp) (Ping timeout)
[23:00:22] *** Quits: NiccosSystem (NiccosSyst@AB1AFDE.FC7B0C35.A7597CB6.IP) (Ping timeout)
[23:00:39] *** Joins: assaf__ (assaf@moz-E4D7531C.inter.net.il)
[23:01:19] <newguy> freefull: sure, one sec
[23:01:24] *** Quits: assaf758 (assaf@moz-A7FA4FAE.cable.012.net.il) (Ping timeout)
[23:01:31] *** Quits: kellogh (timkellogg@moz-704A74D.hsd1.co.comcast.net) (Quit: kellogh)
[23:02:13] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[23:02:50] *** Joins: aklt (aklt@moz-E66E9BCB.u.parknet.dk)
[23:02:56] *** Joins: NiccosSystem (NiccosSyst@moz-F7C30915.connect.netcom.no)
[23:03:34] *** Quits: jrupac (ajay@moz-BF77C4D6.nyc.res.rr.com) (Ping timeout)
[23:03:41] <NiccosSystem> In the tutorial, at section 3.2, isn't the formatting of the i32 example wrong?
[23:03:48] <newguy> freefull: how do i print a string as bytes?
[23:03:54] <newguy> word.as_bytes() does not compile
[23:03:58] <NiccosSystem> Not a big deal at all but thought I'd mention it
[23:05:49] *** Joins: dbaupp (Thunderbir@2702835C.D5A1DCF.37681C44.IP)
[23:06:18] *** Quits: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net) (Quit: dave1629)
[23:06:19] *** Joins: jvoorhis (jvoorhis@moz-84A91726.ptld.qwest.net)
[23:06:31] *** Joins: a_m0d (a_m0d@moz-2F294D00.acanac.net)
[23:07:01] <newguy> does anyone know how to print a &str as bytes?
[23:08:04] *** Quits: jvoorhis (jvoorhis@moz-84A91726.ptld.qwest.net) (Ping timeout)
[23:08:40] *** Joins: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net)
[23:08:42] *** Joins: kellogh (timkellogg@moz-704A74D.hsd1.co.comcast.net)
[23:09:26] *** Joins: hdevalence (quassel@moz-D125A39F.home3.cgocable.net)
[23:10:45] <kimundi> rusti: println!("{:?}", "foo".as_bytes())
[23:10:47] -rusti- &[102u8, 111u8, 111u8]
[23:10:47] -rusti- ()
[23:10:51] <kimundi> newguy: ^
[23:11:38] *** Joins: chromatic (chromatic@moz-28CBC7F4.hsd1.or.comcast.net)
[23:11:47] <newguy> kimundi: thanks
[23:11:57] <NiccosSystem> When do you guys reckon rust would be eligible for a 1.0 release?
[23:12:09] *** Joins: jrupac (ajay@moz-BF77C4D6.nyc.res.rr.com)
[23:12:14] <kimundi> NiccosSystem: Its planned somewhere before 2015
[23:12:34] <kimundi> NiccosSystem: But apart from that "when it's done"
[23:13:12] <hoverbear> It's a beautiful language already.
[23:13:29] <NiccosSystem> I know and agree with the "when it's done" philosophy
[23:13:58] <newguy> kimundi: when i used "{}", it didnt work, why do i need to use "{?}"
[23:14:11] <NiccosSystem> And it is indeed awesome already
[23:14:41] <chromatic> {?} or {?:}?
[23:14:50] <newguy> {:?}
[23:15:00] <chromatic> I always get that backwards.
[23:15:05] *** Joins: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz)
[23:15:49] *** Quits: kvanb (kvanb@moz-70B2A571.lnse5.win.bigpond.net.au) (Ping timeout)
[23:16:47] *** Joins: tcreate (tcreate@moz-90E5C923.hsd1.ma.comcast.net)
[23:17:01] <kimundi> :? is the debugging-always works variant, with non-stable output. {} uses the default formatting trait, but requires that the thing you want to show with it actually implements it
[23:17:08] <chromatic> {} means "use the default format for the type" and "{:?}" is the fallback when there's no default format, so you get basic information.
[23:17:16] <kimundi> &[T] does apparently not implemnt it, so it doesn't work
[23:17:26] *** Quits: bt3ze (bt3ze@moz-3F0303DA.hsd1.va.comcast.net) (Client exited)
[23:17:57] *** Joins: bt3ze (bt3ze@moz-3F0303DA.hsd1.va.comcast.net)
[23:18:03] *** Quits: jrupac (ajay@moz-BF77C4D6.nyc.res.rr.com) (Ping timeout)
[23:18:05] *** Quits: doener (doener@moz-C68F600D.unity-media.net) (Quit: leaving)
[23:18:19] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[23:18:31] *** Quits: tcreate (tcreate@moz-90E5C923.hsd1.ma.comcast.net) (Ping timeout)
[23:18:37] *** Joins: doublec (farv@moz-EC11DA4D.members.linode.com)
[23:18:46] *** Joins: tcreate (tcreate@moz-90E5C923.hsd1.ma.comcast.net)
[23:19:30] *** Joins: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net)
[23:19:43] *** Quits: bt3ze (bt3ze@moz-3F0303DA.hsd1.va.comcast.net) (Ping timeout)
[23:19:46] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Client exited)
[23:20:08] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[23:20:27] *** Quits: marianoguerra (marianogue@moz-264F509.dip0.t-ipconnect.de) (Ping timeout)
[23:20:35] *** Quits: tcreate (tcreate@moz-90E5C923.hsd1.ma.comcast.net) (Ping timeout)
[23:20:37] <dwrensha> note that the "default formatting trait" is now `std::fmt::Show`
[23:21:24] *** Joins: jdm (jdm@moz-4AA3652E.cable.virginm.net)
[23:21:24] *** ChanServ sets mode: +o jdm
[23:21:38] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[23:21:39] <chromatic> ImmutableTuple12? I see how the sausage gets made.
[23:21:57] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[23:24:53] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[23:24:58] <dmillerw> I'm getting "cannot determine a type for this bounded type parameter when trying to create a new RequestWriter from rust-http. I'm doing it the exact same way the example does it, and yet mine errors out where the example works fine
[23:24:58] <yuriks> performance-wise, is there much of a difference between doing ("foo " + bar + " baz") vs format!("foo {} baz", bar)?
[23:24:59] *** flaper87 is now known as flaper87|afk
[23:25:07] *** Quits: NiccosSystem (NiccosSyst@moz-F7C30915.connect.netcom.no) (Ping timeout)
[23:25:38] <dbaupp> yuriks: format!() allocates once-ish
[23:25:47] <dbaupp> + allocates twice
[23:25:51] *** Joins: NiccosSystem (NiccosSyst@moz-F7C30915.connect.netcom.no)
[23:26:21] <yuriks> and is nicer too, what a deal
[23:26:41] *** Joins: alan_andrade (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net)
[23:26:59] <dmillerw> my code: https://gist.github.com/dmillerw/8abde9bc2eda05f260f1 example: https://gist.github.com/dmillerw/a54556b331dbd47522cc
[23:27:06] *** Joins: thewonderidiot (mike@moz-5506A033.hsd1.ca.comcast.net)
[23:28:06] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[23:28:37] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[23:28:37] *** ChanServ sets mode: +ao dherman dherman
[23:29:01] *** Joins: Krymise (Nietzsche@moz-CA789EF5.nwrknj.fios.verizon.net)
[23:29:46] <hoverbear> Would I theoretically be able to write kernel modules in Rust?
[23:29:51] *** Joins: tiffany (kawaii@moz-FC0DB29D.dhcp.embarqhsd.net)
[23:30:15] <Earnestly> (There are kernels written *in* rust atm, so probably yes.)
[23:30:22] *** Quits: alan_andrade (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net) (Ping timeout)
[23:30:25] <hoverbear> Earnestly: Awesome.
[23:30:30] *** Quits: dbaupp (Thunderbir@2702835C.D5A1DCF.37681C44.IP) (Ping timeout)
[23:30:38] *** Joins: tcreate (tcreate@moz-90E5C923.hsd1.ma.comcast.net)
[23:30:38] *** jorendorff_away is now known as jorendorff
[23:32:04] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Client exited)
[23:32:34] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[23:32:39] *** Joins: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP)
[23:34:18] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[23:34:22] *** Quits: lpy (lpy@B744D17C.B31F127E.E99F7FDB.IP) (Ping timeout)
[23:34:29] <newguy> if i have a boolean flag that i'd like to keep global, i have to use unsafe {}
[23:34:36] <newguy> is it really that unsafe though?
[23:34:51] <newguy> should i be weary of modifying a global boolean in different places in my program?
[23:34:51] *** Quits: squiddy (squiddy@moz-9D801C8C.adsl.alicedsl.de) (Quit: Leaving)
[23:34:53] *** Joins: fournm (Aria@moz-ABB60BA0.austin.res.rr.com)
[23:35:21] <yuriks> newguy: it's unsafe in the context of concurrency
[23:35:37] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[23:35:38] <newguy> ok, how else should i handle using boolean glags/
[23:35:40] <newguy> flags
[23:35:48] <yuriks> local variables? :)
[23:36:02] <newguy> but i need access to that variable in another function
[23:36:03] <newguy> :(
[23:36:13] <yuriks> then pass it around
[23:36:21] <newguy> as a param?
[23:36:33] <yuriks> what I usually did (in C++, I didn't write much Rust yet) is create some sort of context struct to hold these kinds of values
[23:36:39] *** Quits: TheHydroImpulse (androirc@moz-7374A0F2.wireless.telus.com) (Client exited)
[23:36:40] *** Quits: Tobba (Tobba@moz-462B7F7F.ias.bredband.telia.com) (Ping timeout)
[23:36:41] *** Joins: TheHydroImpulse (androirc@moz-7374A0F2.wireless.telus.com)
[23:36:46] <newguy> ok
[23:36:56] <yuriks> yeah. There might me a more appropriate rust solution but I don't know it
[23:37:10] <newguy> in terms of concurrency, will my program not be concurrent if  i use global vars?
[23:37:26] <yuriks> no because that can lead to data races
[23:37:32] <yuriks> if two threads access it at the same time
[23:37:48] <newguy> oh gotcha
[23:37:53] <newguy> thank you
[23:38:16] *** Quits: io2 (io2@moz-7C3DDBE8.home.otenet.gr) (Quit: )
[23:39:59] <yuriks> hmm, why can't I search for "iter" in the rustdocs? It ignores the search
[23:40:26] <newguy> yuriks: i am able to
[23:40:29] <newguy> refresh?
[23:40:29] <yuriks> hm, just a lack of feedback for no results I guess... (I was searching in extra :)
[23:40:32] <yuriks> tried
[23:40:51] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[23:40:53] <newguy> yuriks: http://static.rust-lang.org/doc/master/std/str/trait.StrSlice.html?search=iter
[23:41:18] <yuriks> newguy: compare: http://static.rust-lang.org/doc/master/extra/getopts/groups/index.html?search=iter
[23:41:32] <newguy> lolwut
[23:42:11] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[23:42:17] *** Joins: victorporof_ (victorporo@53EBB099.7C27E871.79933D60.IP)
[23:42:47] *** Joins: jrupac (ajay@moz-BF77C4D6.nyc.res.rr.com)
[23:43:29] *** Quits: victorporof (victorporo@53EBB099.7C27E871.79933D60.IP) (Ping timeout)
[23:44:28] *** Joins: canhtak (canhtak@moz-945C7B49.wl.t.ulaval.ca)
[23:44:34] *** Quits: jrupac (ajay@moz-BF77C4D6.nyc.res.rr.com) (Ping timeout)
[23:45:12] *** Quits: eibwen (kvirc@moz-EA24C30.dip0.t-ipconnect.de) (Ping timeout)
[23:45:27] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Client exited)
[23:45:58] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[23:47:05] <Takuin> I tried to create a struct whith an property of type RenderWindow (sfml), it through up a lifetime flag. I cant figure out how to approach this at all.
[23:47:42] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[23:49:30] *** Quits: NiccosSystem (NiccosSyst@moz-F7C30915.connect.netcom.no) (Quit: Bye)
[23:49:43] *** Quits: reima (Instantbir@moz-2AF30DCC.dip0.t-ipconnect.de) (Quit: Leaving.)
[23:50:24] *** Joins: bt3ze (bt3ze@moz-3F0303DA.hsd1.va.comcast.net)
[23:50:55] <yuriks> how do I declare a "stateless" lambda? That doens't capture anything from the environment
[23:51:07] <yuriks> would be equivalent to passing a fn, but I want to do it inline
[23:51:48] <newguy> can somebody give me an example of how to spawn processes?
[23:51:59] <jensnockert> Am I just tired, or shouldn't "[1, 3, 7, 13, 21, 31, 43, 57, 73, 91, 111].iter().rposition(|v| n >= v)" work?
[23:52:05] *** Quits: bt3ze (bt3ze@moz-3F0303DA.hsd1.va.comcast.net) (Ping timeout)
[23:53:08] <jensnockert> I get a borrow check error, https://gist.github.com/jensnockert/6c54302aa95661970d59
[23:53:15] *** Quits: amir (amir@moz-467F7F30.cust.bluewin.ch) (Ping timeout)
[23:54:12] <jxs> newguy http://www.rust-lang.org/
[23:54:22] <jxs> the example
[23:55:23] <newguy> thanks
[23:56:52] <jxs> np :)
[23:57:11] <dwrensha> newguy, jxs: the front page example has shows *tasks* not *processes*
[23:57:25] <dwrensha> Here's an example of a process being spawned: https://github.com/mozilla/rust/blob/master/src/test/run-pass/issue-10626.rs
[23:57:46] <jxs> oh, true, sorry 
[23:57:57] <newguy> its ok. thank you dwrensha
[23:59:34] <jxs> by the way, i might have probably misread, but, is the do keyword going to be deprecated from the language? 
[23:59:55] *** Quits: nszceta (hax@moz-E6CA8D6.hsd1.pa.comcast.net) (Ping timeout)
[23:59:57] <newguy> thats what i heard

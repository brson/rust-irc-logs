[00:00:12] <tikue> SiegeLord: which rule are you referring to?
[00:00:53] <SiegeLord> When omitting a semicolon produces 1) compiler error 2) return from a function
[00:01:05] <cmr> Omitting a compiler never returns from the function.
[00:01:08] <cmr> Erm
[00:01:12] <cmr> s/compiler/semicolon/
[00:01:27] <bjz_> unless you use `return`
[00:01:29] <bjz_> :)
[00:01:44] <roo> or unless you are at the end of the block
[00:02:02] <cmr> roo: that doesn't return from the function either, it just returns anyway when it gets there
[00:02:36] <roo> that is the confusion i would imagine.
[00:02:38] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[00:02:43] <cmr> brson: it's seems you are more right than I would have initially assumed
[00:03:00] <roo> or at least part of it.
[00:03:10] <cmr> I went through the LWN article again (read it the day it came out) and realized I'd forgotten about how they interact with attributes.
[00:03:17] <Eridius> hrm, that lwn article is oddly wrong about the semicolons in if
[00:03:27] <SiegeLord> Oh, that's an easy one
[00:03:38] <SiegeLord> I actually knew about the attributes... it's a simple rule, heh
[00:04:03] <cmr> I had never needed it before... at least not consciously.
[00:05:19] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[00:05:26] *** Quits: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP) (Quit: eatkinson)
[00:05:42] *** Quits: jorendorff (jorendorff@moz-1747FB68.hsd1.tn.comcast.net) (Quit: jorendorff)
[00:07:13] <graydon> the main rules are: semis end-and-discard expression statements, and they're usually unnecessary immediately after a }.
[00:07:30] <graydon> you might want a }; if you are using the result of an expression that ends in }
[00:07:33] <SiegeLord> I'd be reassured if 1) omitting the semicolon never caused an early return 2) compiler errored out if you made a mistake with them
[00:07:40] <graydon> for example: let x = if a { foo } else { bar };
[00:07:55] <Eridius> SiegeLord: why would omitting a semicolon cause an early return?
[00:07:57] <cmr> graydon: I think of that as needing a semicolon after a let, though, not as after the block
[00:07:58] <Eridius> `return` causes an early return
[00:08:01] <graydon> omitting a semi never causes an early return
[00:08:09] <graydon> cmr: yes, exactly.
[00:08:20] <roo> I don't think they are worried about early return, they are worried about the tpe of the return
[00:08:22] <SiegeLord> Eridius: Why not :P
[00:08:30] <roo> type*
[00:08:33] <SiegeLord> Anyway, I'm reassured on that point
[00:08:51] *** Quits: joelteon (joel@moz-317E8D0C.io) (Ping timeout)
[00:08:52] <graydon> cmr: that sort of thing (nesting a }-expr inside a ;-stmt) are the only cases you wind up with "};"
[00:08:57] <bblum> acrichto: yess, i got it right on the first try, i think
[00:09:14] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[00:09:18] <Eridius> the only oddity of the semicolon as far as I'm concerned is that omitting it after the last expression in a block does not change anything if that expression was already typed as ()
[00:09:23] <graydon> and the "when to omit a ;" rule is equally simple: when you want the enclosing form to get a non-nil value out.
[00:09:26] <EXetoC> SiegeLord: you get an error then, if it's not the last expression
[00:09:33] <Eridius> this is why `if { foo() } else { bar() }`, when not used as an expression, is legal iff `foo()` and `bar()` have no return value
[00:09:44] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[00:10:18] *** Quits: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP) (Ping timeout)
[00:10:53] *** Quits: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP) (Quit: WeeChat 0.4.2-dev)
[00:11:04] *** Joins: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP)
[00:11:12] <SiegeLord> That's not surprising... they both return '()'
[00:11:21] <graydon> Eridius: yes. that was intentional. what would you expect it to do?
[00:11:32] <Eridius> graydon: I agree it's correct behavior. But it's not what the lwn article claimed the behavior was
[00:11:48] <brson> the lwn article was not correct about semicolons in rust
[00:12:08] <SiegeLord> So in that case, you can never cause a bug by forgetting/adding an extra ;. Is that correct?
[00:12:25] <Eridius> the semicolon does 2 things. It terminates a statement, and it discards the value of the statement. So you use it whenever you need those behaviors.
[00:12:37] <bblum> hm
[00:12:47] <cmr> SiegeLord: except attributes...
[00:12:55] <bblum> there sure is a lot of stack closure copying in librustc
[00:13:04] <SiegeLord> cmr: Right... fair enough
[00:13:06] <bblum> come on bors why haven't you seen my PR yet
[00:13:08] <bblum> bors bors bors
[00:13:18] <cmr> SiegeLord: I think usually it just "looks right" for attributes though.
[00:13:30] <brson> i want to remove the semicolon attribute syntax still
[00:14:06] <cmr> brson: and replace it with what?
[00:14:11] <SiegeLord> rusti: enum A { #[deriving(Eq)] B }
[00:14:12] -rusti- ()
[00:14:19] <graydon> https://people.mozilla.com/~graydon/function-instruction-sizes.txt
[00:14:27] <graydon> for those curious about pathological code generation cases in LLVM
[00:14:37] <cmr> Also, can someone explain why tuple-structs emit an actual function that does construction?
[00:14:37] <graydon> er, in trans, in terms of LLVM instructions
[00:14:45] <brson> cmr: #![attribute]
[00:14:59] <graydon> bblum: which PR?
[00:15:05] <SiegeLord> When are the semicolon attributes used anyway?
[00:15:11] <brson> cmr: or `# attribute` and `#! attribute`
[00:15:14] <Eridius> brson: yes because if there's one thing we need, it's more syntax
[00:15:24] <bblum> graydon: https://github.com/mozilla/rust/pull/7248
[00:15:32] <cmr> brson: #! would be consistent with doc comments.
[00:15:36] <brson> cmr: yes
[00:15:39] <cmr> brson: But also conflict with shell syntax.
[00:15:44] <cmr> Erm, interpreter syntax
[00:15:45] <brson> yep
[00:16:05] <cmr> But... not sure that's useful for rust, at all
[00:16:11] <graydon> bblum: the r=foo or r+ comment has to be the first thing in the comment
[00:16:12] <brson> cmr: https://github.com/mozilla/rust/issues/2569
[00:16:17] <cmr> And if it is, the interpreter could just shave off the first line :p
[00:16:17] <graydon> not just randomly scattered in it
[00:16:19] <bblum> graydon: oh
[00:16:26] <bblum> i can r= myself right?
[00:16:30] <graydon> no
[00:16:56] <cmr> brson: Although!
[00:16:59] <cmr> brson: #^
[00:17:06] <graydon> r+ though, hopefully that'll stick
[00:17:06] <cmr> As in "look up there, that's what this applies to"
[00:17:09] <bblum> graydon: thanks
[00:17:13] <bblum> i was about to r= niko then :P
[00:17:25] <cmr> Oh
[00:17:28] <cmr> Someone already suggested that :(
[00:17:49] <Eridius> is #[attr]; really so confusing that we neeed new syntax?
[00:17:53] *** Quits: eholk (eholk@moz-61CBCD5E.uconnect.utah.edu) (Ping timeout)
[00:17:58] <cmr> Eridius: I think it is, yes.
[00:18:13] <cmr> I'm just one person though
[00:18:25] <bblum> graydon: I take it "burningtree" is a special keyword for r=, then?
[00:18:28] <graydon> I think we'll be able to live with it as-is.
[00:18:31] <doy> i've never found rust's semicolon rules confusing at all
[00:18:41] <Eridius> I feel like if we add new syntax we have to keep the ; after it, or it will still look like it applies to the following expression
[00:18:45] <graydon> bblum: no, I've just put that in when I'm explaining why I'm force-pushing things to master and bors is shut off
[00:18:47] <Eridius> and if we keep the ; then why bother with new syntax
[00:18:56] <bblum> graydon: oh, it goes with force-pushes; ok
[00:19:05] <SiegeLord> I'd just restrict some attributes to have semicolons, and some not to (if this is not restrictive)
[00:19:12] <graydon> bblum: as a matter of habit. "why are there these non-bors pushes in the history?"
[00:19:24] <bblum> yeah
[00:20:15] <sp3d> #[attr]; is the kind of thing I would hate to e.g. explain to someone learning rust as a first language
[00:20:45] <sp3d> it's not *complicated* but seems like a really weird distinction to make
[00:21:03] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[00:21:30] <brson> I don't like that the distinction comes *after* you've read the attribute - it's easy to not eyeball-parse that far
[00:21:39] <sp3d> yeah
[00:21:50] <bblum> what's the deal with attribute semicolons? o_O
[00:21:57] <bblum> i always thought it just didn't mean anything
[00:22:04] <cmr> bblum: and... that's the problem
[00:22:08] <bblum> oh, i bet it means "doesn't apply to the thing in front of it"
[00:22:13] <cmr> yup
[00:22:15] <bblum> er, behind it i guess
[00:22:16] <bblum> yeah
[00:22:16] <sp3d> it makes it apply to the crate rather than the following thing afaik
[00:22:35] <bblum> well, that sort of makes sense when you think about C's "while (true);"
[00:22:48] <sp3d> with that logic you'd expect it to be a nop
[00:23:04] <bblum> no, with that logic i'd understand it by analogy with "while (true); { break; }"
[00:23:25] <sp3d> ah, I guess so
[00:24:16] <cmr> Semicolons pretty much have become invisible to me, so them having significant, not-easily-compiler-checkable semantics is really bad
[00:25:02] <bblum> anyway, i don't care what colour this bikeshed gets painted
[00:25:22] <Eridius> I don't think that #[attr]; is something that newbies really need to learn to begin with, so worrying about how to explain it to newbies seems unnecessary
[00:25:50] *** Joins: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP)
[00:25:55] <aatch|bed> graydon, I'm about to rebase https://github.com/mozilla/rust/pull/7182 ... again. Can you look through it?
[00:26:18] *** Joins: joelteon (joel@moz-317E8D0C.io)
[00:26:36] <graydon> aatch|bed: ok
[00:26:40] *** aatch|bed is now known as aatch
[00:26:50] <aatch> graydon, thanks.
[00:27:42] <graydon> meanwhile if someone wants an adventure in fixing codegen
[00:27:43] <cmr> aatch: you might want to pull in https://github.com/nikomatsakis/rust/commit/77109fabfcbc80e101d2c36eea7a2f0de815fa2c if it conflicts with your ppaux cleanup
[00:27:56] <graydon> I have a hunch we are doing the worst of our badness now in the match code
[00:28:00] <cmr> (part of https://github.com/mozilla/rust/pull/7280)
[00:28:12] <cmr> (well, it is 7280)
[00:28:49] <graydon> I say this for 2 reasons: (1) nobody understands the match code, (2) the largest number-of-instruction functions both by LLVM and x64 code are basically big matches with not much magic in the arms.
[00:29:09] <graydon> I suspect there might be another quadratic codegen case lurking in there
[00:29:27] <aatch> to the doener-mobile!
[00:29:31] <graydon> consider the #1 most-LLVM-instructions function, middle::trans::foreign::trans_intrinsic
[00:29:42] <graydon> 18596 instructions generated
[00:29:54] * doener is confused
[00:30:01] <graydon> if you look at it, it is not a _small_ function, but it's .. mostly just a bunch of strcmp => dispatch to simple block patterns
[00:30:13] <cmr> graydon: yeah, that seemed realllly fishy to me too. the match arms look like they'd only be ~15 instructions
[00:30:17] <graydon> it makes no sense that it'd take 18,000 instructions to make that work
[00:30:22] *** Quits: Ralith (ralith@moz-1D643576.wireless.sfu.ca) (Ping timeout)
[00:30:25] <aatch> doener, didn't you fix another quadratic codegen problem?
[00:30:43] <bblum> pauls: do macros have the ability to generate fresh identifiers?
[00:30:48] <doener> ah, ok, now I get it (didn't read the context yet)
[00:31:00] <cmr> doener: actually we're going to turn you into a car and drive you around
[00:31:33] <bblum> pauls: i'm thinking something like "curry3!(f, x, y)" would expand to "|__id1,__id2,__id3| f(x,y,__id1,__id2,__id3)"
[00:31:45] <graydon> I'd recommend making some simple tests, isolated match expressions in solo functions, and then seeing what codegen we do there
[00:31:47] <graydon> and working backwards
[00:31:47] *** Joins: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP)
[00:32:10] <graydon> erickt: just the person I was interested in seeing!
[00:32:30] <cmr> graydon: Do you know why tuple-struct constructors are constructed with actual functions?
[00:32:35] <graydon> https://people.mozilla.com/~graydon/function-instruction-sizes.txt has a surprisingly large number of encoder functions ranking high in the output also
[00:33:18] <graydon> cmr: probably because enums are. which I think was an old decision with several not-likely-reasonable motives anymore.
[00:33:29] *** Quits: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net) (Client exited)
[00:33:29] <graydon> (I think the ctor used to be a function, as in, you could take an enum ctor and use it _as_ a function)
[00:33:35] *** Quits: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP) (Ping timeout)
[00:33:43] <sully> oh, can you not do that anymore?
[00:33:49] <cmr> graydon: Ok, just tying to make sure I'm not missing something obvious here, because I don't see why they should be functions, at all.
[00:33:56] <doener> 1640 allocas in trans_intrinsic
[00:33:58] <graydon> maybe you can. I just .. I wouldn't mind if we had to lose that ability to win some sort of major cleanup
[00:34:14] <doener> well, take a few memcpys that are in between there
[00:34:25] <cmr> I'm looking at the trans code for tuple-structs because it makes ugly IR and I thought it'd be an easy fix :)
[00:34:30] *** Joins: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net)
[00:34:58] <cmr> Having spent a few hours untangling various pieces of trans to wrap my head around it... I'm thoroughly convinced that was a false assumption.
[00:35:56] <aatch> nothing in trans is an easy fix
[00:36:19] <cmr> aatch: your --passes work is making my life infinity times better though
[00:36:38] <graydon> aatch: I'm a little disturbed that Type is yet a 4rd representation of types called .. Type
[00:36:41] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Quit: Leaving.)
[00:36:42] <graydon> but otherwise this mostly looks good
[00:36:49] <graydon> (LLType perhaps?)
[00:36:57] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[00:37:02] <aatch> graydon, I could live with that I guess
[00:37:15] <graydon> *shrug* I wouldn't block this change on it
[00:37:30] <graydon> just wondered what you thought. I guess they're type disjoint and clearly from different layers of the compiler.
[00:37:33] <graydon> probably not a big deal
[00:38:30] *** Quits: bent (chatzilla@moz-932324BF.hsd1.ca.comcast.net) (Quit: ChatZilla 0.9.90-rdmsoft [XULRunner 18.0.2/20130201065344])
[00:38:32] <sully> yeah, I think it would be good to indicate that it is an llvm type?
[00:38:43] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Ping timeout)
[00:39:07] <aatch> sully, thing is, in trans, the only other major type usage is via ty::t
[00:39:22] <cmr> which is also a terrible name btw
[00:39:40] <bblum> wee, 3 files changed, 20 insertions(+), 282 deletions(-)
[00:40:40] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[00:42:05] <cmr> how are fields of tuple structs accessed? only by destructuring?
[00:42:34] <aatch> graydon, just pushed the rebase. I'm rebuilding now, just to make sure it works, but I have to go do housework.
[00:43:07] *** Quits: seth (seth@moz-BE33DA21.fw1.sfo1.mozilla.net) (Input/output error)
[00:43:47] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[00:44:43] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[00:45:12] <cmr> What is an 'llfndecl'?
[00:45:18] <cmr> having ValueRef everywhere is really opque
[00:45:23] <cmr> *opaque
[00:45:53] <cmr> Just having typedefs mapping to useful names that I could look up in the llvm docs would be fine
[00:47:06] <graydon> aatch: r=me with any quantity of said comments approved, including a rebase if you need to
[00:47:08] <graydon> looks good
[00:47:17] <graydon> s/approved/addressed/
[00:47:21] <graydon> (sorry, long day)
[00:48:54] *** Quits: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net) (Quit: carllerche)
[00:50:18] <cmr> (sorry if I'm repeating known complaints about trans. but trying to get hacking in it is really perilous)
[00:50:28] * cmr bed
[00:50:37] <graydon> cmr: no, it's fine
[00:51:10] <graydon> they're real concerns and .. honestly we're short of labour and left too much tech debt in trans, many hands welcome there
[00:52:14] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Client exited)
[00:52:22] <doener> looks like trans_intrinsic is mostly grown by two or three things I've looked into before. allocas bloated by immediate return values, and empty blocks from scoping (relies on llvm blocks) and with_cond
[00:52:39] <doener> at least that's what a first glance says
[00:53:04] <doener> 3am over here though, so I might be (way) off. Anyway, I'll dig deeper tomorrow
[00:53:45] *** Quits: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP) (Quit: eatkinson)
[00:53:51] *** Joins: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net)
[00:53:57] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[00:54:20] *** Quits: eschweic1 (Adium@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[00:54:25] *** Quits: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net) (Quit: carllerche)
[00:54:58] <sully> oh, right, I was going to look into self's dumbness
[00:55:47] *** Joins: brendan (brendaneic@6CE790D5.927818F1.82490606.IP)
[00:56:12] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[00:56:50] *** Quits: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com) (Quit: Computer has gone to sleep.)
[00:56:51] *** Joins: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP)
[00:56:55] *** Joins: eschweic (Adium@2557E599.66715431.D25A875A.IP)
[00:58:16] <bblum> <3 <3 <3 git rebase
[00:58:22] <bblum> what would i do without you
[00:58:27] <bblum> probably a bunch of awful cherry picks
[00:58:30] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[00:58:44] *** Quits: brendan (brendaneic@6CE790D5.927818F1.82490606.IP) (Ping timeout)
[00:59:00] *** Quits: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP) (Quit: eatkinson)
[00:59:19] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[00:59:49] <SiegeLord> What exactly does the -o command line switch do with rustc?
[00:59:55] <steven_is_false> Is there a --disable-opt flag of some sort for Rust's configure so I can build it faster?
[01:00:06] <SiegeLord> Doing rustc crate.rs -o test doesn't really do anything
[01:00:42] <strcat> steven_is_false: disabling optimizations will make it take 10x longer ;\
[01:01:09] <steven_is_false> strcat: Oh I thought someone said that it would be shorter.
[01:01:21] <doener> steven_is_false: only the first stage
[01:01:32] <steven_is_false> Maybe they meant for disable-optimize-llvm, and disable-optimize-cxx
[01:01:41] <doener> steven_is_false: the other two will be built with a non-optimized compiler, which is sloooow
[01:01:48] <steven_is_false> but those don't get rebuilt too often.
[01:01:59] <strcat> steven_is_false: not optimizing LLVM will make it incredibly slow too
[01:02:13] <steven_is_false> strcat: okay
[01:02:17] *** Joins: jrfeenst (jrfeenst@moz-F912484F.cpe.norwoodlight.com)
[01:02:19] <strcat> it has to compile itself twice
[01:02:44] <strcat> once with the compiler it actually just built
[01:02:49] <strcat> so... you really want optimizations
[01:03:08] <steven_is_false> Is valgrind on by default?
[01:03:48] <strcat> no
[01:04:15] <steven_is_false> cool
[01:04:25] <roo> SiegeLord: it controls the name of the output. rustc crate.rc -o test, creates executable named test (supposing its not supposed to compile as a dynamic library)
[01:04:42] <SiegeLord> Oh, right... it is that in this case
[01:05:06] *** Quits: doener (doener@moz-121949B3.unitymediagroup.de) (Ping timeout)
[01:06:13] *** Quits: bytbox (s@moz-D83E9B31.wireless.umd.edu) (Ping timeout)
[01:06:42] <SiegeLord> I'm still trying to come to grip with rustpkg... I don't get how lib.rs is supposed to function
[01:06:51] <SiegeLord> If you do rustc lib.rs you'll get a lib.so
[01:07:10] <SiegeLord> If you rustpkg it (I think) you'll get <base_directory_name>.so
[01:07:26] <graydon> yes, that's intentional
[01:07:31] <roo> seems reasonable
[01:07:44] <SiegeLord> That seems very puzzling to me
[01:07:54] <graydon> main.rs will be turned into an executable, test.rs and bench.rs will become tests and benchmark executables
[01:07:54] <roo> You wouldn't want every library on your system named lib
[01:08:00] <graydon> and lib.rs will be made into a library
[01:08:24] <graydon> they're filename conventions. so that the package manager can decide what to do just by looking at them.
[01:08:35] <SiegeLord> So a rustpkg-compliant repository cannot be compiled with plain rustc?
[01:08:43] *** Quits: infynyxx (infynyxx@moz-B75C70D1.hsd1.md.comcast.net) (Client exited)
[01:08:52] <graydon> rustpkg is a thing that runs rustc
[01:09:04] <graydon> you could do it manually
[01:09:19] <SiegeLord> I wouldn't know what name to give the .so file
[01:09:19] <graydon> rustc -o <base_directory_name> lib.rs say
[01:09:37] <SiegeLord> That doesn't work atm
[01:09:39] *** Joins: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com)
[01:09:54] <graydon> then there's a bug
[01:10:01] *** Quits: EXetoC (ex@moz-2DBEB1E4.customer.t3.se) (Quit: WeeChat 0.4.1)
[01:10:14] <graydon> apologies, I have to go now. but it's not supposed to be a great mystery, just a file naming convention for choosing outputs
[01:10:21] <graydon> and deciding what to do with inputs
[01:10:30] *** Joins: bytbox (s@moz-2E27684C.student.umd.edu)
[01:10:36] <graydon> without too much additional metadata / degrees of freedom
[01:11:10] *** Quits: graydon (Adium@A5087023.2354C43D.D8E68FF6.IP) (Quit: Leaving.)
[01:11:12] <SiegeLord> I guess I'd be ok with it if rustc -o worked for shared libraries... I'll see what I can do about it
[01:11:38] *** Quits: Nisstyre (wes@moz-FD86289.netflash.net) (Quit: Leaving)
[01:11:53] <aatch> cmr, I agree on the ValueRef front. Part of the reason for my latest refactoring is trying to make TypeRef a little less opaque
[01:11:58] <aatch> I mean, it's not perfect
[01:14:24] *** Quits: H4199 (chatzilla@moz-64E556D3.austin.res.rr.com) (Ping timeout)
[01:15:09] <roo> SiegeLord: how are you letting the compiler know it is supposed to be a library? Attributes? or are you passing in the --lib flag?
[01:15:21] <SiegeLord> I tried both
[01:15:55] <cmr> Idea!
[01:16:00] <cmr> Rename tuple-struct to named tuple
[01:16:20] *** Joins: cdidd (cdidd@moz-16366370.broadband.corbina.ru)
[01:17:10] *** Joins: barosl (barosl@E287D94F.C81E10FB.7544CABF.IP)
[01:17:14] *** Joins: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP)
[01:17:52] <SiegeLord> I think rustpkg invokes rustc via the library API and not via process spawning
[01:18:11] <SiegeLord> So it avoids this... the fancy-lib test case, however, seems to rely on the -o flag to work
[01:18:18] <SiegeLord> It doesn't compile atm though, so heh
[01:18:22] <SiegeLord> Looks like a legit bug
[01:18:24] *** Quits: cstrahan (cstrahan@E8551FC6.D607B8C4.F5F9A4BE.IP) (Quit: leaving)
[01:18:26] <sully> ok, wee
[01:18:31] <aatch> SiegeLord, it does use the library API
[01:18:36] <sully> I think I can get rid of the cast we generate for every single mention of self
[01:18:43] <cmr> SiegeLord: Isn't there a crate attribute that sets library name?
[01:18:59] *** Joins: cstrahan (cstrahan@moz-78F40D85.dsl.rcsntx.sbcglobal.net)
[01:19:15] <cmr> Oh you tried attributes
[01:19:18] *** Quits: cstrahan (cstrahan@moz-78F40D85.dsl.rcsntx.sbcglobal.net) (Quit: leaving)
[01:19:56] <SiegeLord> Oh, indeed
[01:20:02] <SiegeLord> Yes, if I remove it, -o starts working
[01:21:07] <SiegeLord> Hmm... so are the #[link attributes even used by rustpkg?
[01:22:03] <cmr> they might not be, you'd have to ask tjc about it when he's around.
[01:22:35] <SiegeLord> It seems it infers the version from the git tag, name from the directory name... no mention of author and license
[01:22:41] <SiegeLord> So it probably does
[01:23:07] *** Quits: eschweic (Adium@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[01:23:15] *** Quits: dju (dju@moz-83BD5EC.dmz.me) (Quit: ZNC - http://znc.in)
[01:25:19] <roo> Yeah I am not quite comfortable with rustpkg yet, i dont really understand certain conventions, and rustc is pretty simple to use. Using hidden directories as a search path seems a little weird
[01:25:50] <cmr> roo: it's not quite ready for use yet either
[01:27:58] <SiegeLord> lol, I was confused why my #[link attribute wasn't working
[01:28:04] <SiegeLord> Forgot a semicolon
[01:28:05] <SiegeLord> :P
[01:28:12] <sp3d> haha
[01:28:19] <cmr> That is amusingly relevant
[01:28:36] <cmr> SiegeLord: And you were the one who said you didn't find it confusing!
[01:28:47] <SiegeLord> Hehe :[
[01:29:33] <SiegeLord> Ok, looks like rustpkg does *not* ignore the link attribute
[01:29:42] <SiegeLord> That seems reasonable
[01:29:52] <SiegeLord> So no bug, I think
[01:33:17] *** Joins: dju (dju@moz-83BD5EC.dmz.me)
[01:39:03] *** Quits: echristo (echristo@60A74940.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[01:43:41] <tcsc> are traits implemented as virtual method calls?
[01:44:22] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: WeeChat 0.4.1)
[01:44:29] <steven_is_false> tcsc: There are two uses of traits.
[01:44:49] <strcat> tcsc: methods use static dispatch, generics + type bounds are static dispatch
[01:44:53] <steven_is_false> tcsc: As bounds in type parameters fn <T : Trait> foo(T, etc..
[01:44:59] <strcat> you can cast an object to a trait object and that has a vtable
[01:45:06] <tcsc> ah, okay, that makes sense
[01:46:08] *** Parts: ecr (ereed@2557E599.66715431.D25A875A.IP) ()
[01:46:58] *** Quits: bytbox (s@moz-2E27684C.student.umd.edu) (Ping timeout)
[01:47:08] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[01:47:23] *** Joins: SiegeLord (siege@moz-CAF07B4C.hsd1.ma.comcast.net)
[01:50:59] *** Joins: vcl (chatzilla@1137E56D.76F9E272.DA40C4B3.IP)
[01:51:16] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[01:53:09] *** Parts: steven_is_false (user@moz-144077DE.bchsia.telus.net) (ERC Version 5.3 (IRC client for Emacs))
[01:53:45] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[01:54:22] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[01:56:04] <steven_is_false> What does the match foo { Bar(*) => etc... syntax mean?
[01:56:55] <pcwalton> steven_is_false: it's the same as Bar(_), except it doesn't care how many fields are in Bar
[01:57:08] <steven_is_false> pcwalton: okay, thanks
[01:59:42] *** Quits: jjr (jeffrey@moz-2A1ACF92.cpe.cableone.net) (Quit: jjr)
[02:00:28] <roo> the self namespace prevents lookup outside of the current module right?
[02:01:35] <roo> or the current level of the namespace rather
[02:05:02] *** Quits: zz_kimundi (kimundi@moz-386FFA95.dip0.t-ipconnect.de) (Ping timeout)
[02:05:39] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[02:06:25] <steven_is_false> Can someone help me out with my patch to Rust at https://github.com/sstewartgallus/rust/tree/cleanup_front ? I'm getting a mysterious internal compiler error.
[02:08:30] *** Joins: zz_kimundi (kimundi@moz-C228B6B4.dip0.t-ipconnect.de)
[02:08:30] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[02:08:52] *** zz_kimundi is now known as kimundi
[02:09:24] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[02:09:40] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[02:11:38] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[02:12:51] <strcat> that's good, I found some kind of bug ;p
[02:17:50] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[02:19:13] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[02:19:13] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/_dbBkQ
[02:19:13] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[02:19:27] *** Joins: infynyxx (infynyxx@moz-8BE8F2CD.hsd1.md.comcast.net)
[02:19:50] <brson> gj, bors
[02:21:13] *** Quits: infynyxx (infynyxx@moz-8BE8F2CD.hsd1.md.comcast.net) (Ping timeout)
[02:21:24] <tcsc> is there a safe way to get the binary representation of a double?
[02:21:45] <steven_is_false> Other than the circular import issue what else could cause the rust compiler to hang on compiling indefinitely?
[02:21:51] <tcsc> err, u64 representation of an f64
[02:22:15] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[02:22:15] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/Ve8H2Q
[02:22:16] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[02:22:20] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[02:22:20] <ghrust> 01[13rust01] 15bors pushed 14 new commits to 06auto: 02http://git.io/1DnfvA
[02:22:20] <ghrust> 13rust/06auto 143dbdb3a 15James Miller: Methodize TypeNames
[02:22:20] <ghrust> 13rust/06auto 14b4b2cbb 15James Miller: Change calls for TypeName stuff to methods
[02:22:20] <ghrust> 13rust/06auto 1466d8e8b 15James Miller: Make log_fn_time a method
[02:22:20] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[02:22:55] <steven_is_false> tcsc: I don't think so. The u64 would be a machine dependent representation.
[02:23:10] <strcat> strcat@thinktank i ~/projects/rust iterator % git grep '\.each ' | wc -l
[02:23:12] <strcat> 186
[02:23:13] <steven_is_false> tcsc: If you really had to you could use cast::transmute though.
[02:23:15] <strcat> strcat@thinktank i ~/projects/rust iterator % git grep '\.advance ' | wc -l
[02:23:16] <strcat> 944
[02:23:18] <strcat> progress? ;p
[02:23:33] <strcat> just a few hundred more and we can replace 'for' pretty painlessly...
[02:23:37] <tcsc> steven_is_false: it's ieee 754 basically everywhere though, but yeah, transmute works
[02:23:53] <tcsc> i guess it depends on the byte order too
[02:24:01] <steven_is_false> tcsc: But before you do can you use I think it's called frexp, or ldexp?
[02:24:18] <tcsc> i cannot
[02:24:47] <steven_is_false> Well okay, but make sure to use it in a somewhat portable way.
[02:25:22] *** Joins: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net)
[02:27:13] *** Quits: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net) (Ping timeout)
[02:27:38] *** Joins: echristo (echristo@60A74940.D6CCE4AE.77834EAA.IP)
[02:29:32] *** Quits: Sodel_the_V (user@moz-853663E1.va.shawcable.net) (Quit: Eaten by a grue)
[02:30:06] <bstrie> strcat: does the "for" overhaul mean that non-local returns are no longer a thing in rust?
[02:30:29] <strcat> bstrie: well return/break in a for loop will actually just break or return
[02:30:32] <strcat> they won't be able to fail
[02:30:49] <bstrie> strcat: right, but are there other scenarios where people require nonlocal returns?
[02:31:01] <strcat> don't know what you mean by non-local return
[02:31:07] <strcat> we don't actually have non-local returns, it's a hack
[02:31:07] <bstrie> besides our hilarious internal iterators trying to emulate for loops
[02:31:11] <strcat> it doesn't always work
[02:31:35] <strcat> 'return' in a for loop just returns false
[02:32:23] <strcat> rusti: fn broken(f: fn(int) -> bool) -> bool { f(2); f(2); f(2); } for broken |x| { println(x.to_str()); break }
[02:32:25] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/fbRa
[02:32:36] <strcat> rusti: fn broken(f: &fn(int) -> bool) -> bool { f(2); f(2); f(2); } for broken |x| { println(x.to_str()); break }
[02:32:37] -rusti- <anon>:9:9: 9:69 error: not all control paths return a value
[02:32:37] -rusti- <anon>:9          fn broken(f: &fn(int) -> bool) -> bool { f(2); f(2); f(2); } for broken |x| { println(x.to_str()); break }
[02:32:38] -rusti-                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[02:32:38] -rusti- error: aborting due to previous error
[02:32:38] -rusti- application terminated with error code 101
[02:32:45] <strcat> rusti: fn broken(f: &fn(int) -> bool) -> bool { f(2); f(2); f(2); true } for broken |x| { println(x.to_str()); break }
[02:32:47] -rusti- 2
[02:32:47] -rusti- 2
[02:32:47] -rusti- 2
[02:32:47] -rusti- ()
[02:32:54] <strcat> rusti: fn broken(f: &fn(int) -> bool) -> bool { f(2); f(2); f(2); true } for broken |x| { println(x.to_str()); return; }
[02:32:55] -rusti- 2
[02:32:55] -rusti- 2
[02:32:55] -rusti- 2
[02:33:11] <strcat> and ofc it doesn't borrow check as if it was a real return/break
[02:33:55] <strcat> (it's also currently implemented in a broken way)
[02:34:01] <aatch> steven_is_false, certain recursive types can cause the compiler to hang
[02:34:01] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[02:34:02] <strcat> can make it read invalid memory
[02:34:57] *** Joins: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP)
[02:36:01] *** Quits: echristo (echristo@60A74940.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[02:36:38] *** Quits: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP) (Ping timeout)
[02:37:42] <steven_is_false> aatch: Actually the compiler was just compiling really slow for some reason.
[02:38:00] <steven_is_false> aatch: And my previous problem was having a generic function inside a normal function.
[02:38:07] <bblum> aatch: really? like what
[02:39:05] <steven_is_false> Just pushed my fix to my repo. Now I still have a mysterious ICE in my build but it's a different one.
[02:39:18] <pcwalton> yay, run-pass tests are passing now
[02:41:55] *** Quits: joelteon (joel@moz-317E8D0C.io) (Ping timeout)
[02:41:56] *** Quits: threecreepio (jdp@moz-DB2D70E9.cust.bredbandsbolaget.se) (Quit: threecreepio)
[02:45:28] *** Quits: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP) (Ping timeout)
[02:46:56] *** Joins: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net)
[02:47:21] *** Quits: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[02:49:19] *** Joins: dbaupp (Thunderbir@moz-73E90475.lns20.syd6.internode.on.net)
[02:49:25] *** Joins: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP)
[02:51:03] *** Quits: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP) (Quit: eatkinson)
[02:52:46] *** Joins: joelteon (joel@moz-317E8D0C.io)
[02:54:34] *** Quits: joelteon (joel@moz-317E8D0C.io) (Ping timeout)
[02:56:32] *** Joins: joelteon (joel@moz-317E8D0C.io)
[02:57:41] <brson> how do i convert an iterator to a vector?
[02:57:47] <aatch> brson, .collect
[02:58:42] <brson> thanks
[02:58:53] <brson> I expected .to_vec()
[02:59:32] <strcat> brson: collect is generic
[03:00:00] *** Quits: jga (asdf@FE876AEA.207DAD7B.B5524284.IP) (Ping timeout)
[03:02:39] *** Quits: kimundi (kimundi@moz-C228B6B4.dip0.t-ipconnect.de) (Ping timeout)
[03:03:05] *** Quits: pcwalton (pcwalton@43CB6079.66715431.D25A875A.IP) (Quit: pcwalton)
[03:05:47] *** Joins: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP)
[03:07:35] *** Quits: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP) (Ping timeout)
[03:08:15] *** Joins: Aetherspawn (Aetherspaw@moz-8811D9F0.static.tpgi.com.au)
[03:09:16] *** Quits: jrfeenst (jrfeenst@moz-F912484F.cpe.norwoodlight.com) (Quit: jrfeenst)
[03:09:30] *** Quits: steven_is_false (user@moz-144077DE.bchsia.telus.net) (Ping timeout)
[03:09:41] <aatch> Ok, next on my hit-list. Refactoring function-related code.
[03:09:53] <tcsc> is assert! always on, or is it based on some NDEBUG-esque cfg flag?
[03:09:59] *** Joins: zz_kimundi (kimundi@moz-3B0D7C12.dip0.t-ipconnect.de)
[03:10:07] <aatch> tcsc, is always on at the moment
[03:10:24] *** zz_kimundi is now known as kimundi
[03:10:27] <tcsc> at the moment?
[03:10:41] <aatch> rustc will likely grow a `--no-asserts` at some point
[03:11:00] <aatch> but on the ever-growing list of things to do it's close to the bottom.
[03:11:32] <tcsc> okay
[03:12:00] *** Joins: Ralith (ralith@moz-50F3C77.vc.shawcable.net)
[03:12:07] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[03:13:19] <dbaupp> tcsc: it's probably fairly easy to implement
[03:13:26] <dbaupp> tcsc: in some form at least
[03:13:39] <strcat> aatch: not for assert!
[03:13:46] <strcat> we'd need debug_assert!
[03:13:57] <strcat> because assert is actually being used as a shortcut for a condition/fail
[03:14:05] <aatch> strcat, oh true
[03:14:06] <strcat> an actual assert should abort
[03:14:19] <strcat> and should be off with optimizations
[03:14:24] <strcat> debug_assert! would be fine imo
[03:14:44] <aatch> assert is used in places like assert!(idx < len, "Index out of bounds")
[03:14:45] <dbaupp> tcsc: hm, actually, maybe not. (it's very dependent on the order in which the compiler handles things...)
[03:15:33] <aatch> dbaupp, I'm fairly sure macro expansion happens before cfg-item stripping
[03:15:46] <dbaupp> aatch: yes, it does
[03:15:51] <dbaupp> aatch: I made it do that ;)
[03:16:01] <dbaupp> (it should probably strip, expand, strip again.)
[03:16:04] *** Joins: jga (asdf@C6DDBF98.79F9C1CA.B5524284.IP)
[03:16:16] <aatch> dbaupp, oh yeah. I forgot about that.
[03:16:30] * dbaupp fixes it
[03:16:38] <tcsc> oh, the cfg wouldn't apply to the macro definition?
[03:16:55] <aatch> tcsc, you can't, at the moment, apply attributes to macros
[03:17:12] <aatch> its a limitation, rather than something intentional
[03:17:18] <strcat> you can just make an assert macro call a function
[03:18:01] <aatch> tcsc, (you'll notice a lot of things that are prefixed with "at the moment" or "in theory")
[03:18:15] <dbaupp> you can wrap in `#[macro_escape] #[cfg(...)] mod foo { macro_rules! foo() } and that is indistinguishable from `macro_rules! foo()`
[03:18:31] <dbaupp> (however, one can't actually use this to define two versions of foo! yet.)
[03:18:48] <dbaupp> strcat: will LLVM eliminate the conditional check?
[03:19:04] <aatch> if it's a compile-time constant yes
[03:19:09] <dbaupp> (for assert!(foo, bar) => if !foo { assert_fn(bar) })
[03:19:19] <dbaupp> aatch: and if it's not?
[03:19:27] <aatch> dbaupp, well then no
[03:19:41] <dbaupp> (presumably it can eliminate it if it can prove it has no side-effects?)
[03:19:59] <aatch> if it's an empty branch, then probably
[03:20:23] <tcsc> couldn't you tell llvm it's unreachable?
[03:20:28] <aatch> since that would almost certainly get picked up by control-flow simplification.
[03:21:28] <tcsc> e.g. #[inline(always)] #[cfg(no_debug)] fn assert_fn(â€¦) { __builtin_unreachable(); }
[03:21:41] *** Quits: SiegeLord (siege@moz-CAF07B4C.hsd1.ma.comcast.net) (Connection reset by peer)
[03:22:00] <aatch> tcsc, yep, in fact the function is util::unreachable()
[03:22:46] <strcat> aatch: that doesn't tell it it's unreachable
[03:22:50] <strcat> it's just a shortcut to fail
[03:23:07] <aatch> strcat, but trans marks those blocks as unreachable
[03:23:16] <aatch> it falls through to LLVM
[03:23:16] <strcat> aatch: doesn't matter
[03:23:25] <strcat> unreachable compiles to throwing an exception
[03:23:36] <strcat> it doesn't do what unreachable does
[03:23:39] <strcat> it does what fail!() does
[03:23:45] <aatch> I guess.
[03:23:50] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[03:24:22] <strcat> __builtin_unreachable is an assertion that the control flow never gets there - it's an optization
[03:24:29] <aatch> At any rate, LLVM has the smarts to compile out an empty branch.
[03:24:32] <strcat> util::unreachable puts code there that would actually do something
[03:25:15] <dbaupp> do we have a __builtin_expect equivalent yet?
[03:25:26] <aatch> strcat, right. maybe we need an unreachable intrinsic.
[03:25:38] <aatch> "need" - could have, rather
[03:25:44] <strcat> aatch: if we find a use case ;p
[03:25:47] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[03:25:57] <aatch> It wouldn't be hard to add, heh
[03:26:45] <aatch> Hmm, I can't think of any case that wouldn't be better served by actually failing.
[03:27:15] <aatch> since it serves as a nice fall back if your assumptions are wrong.
[03:27:29] <dbaupp> aatch: match x % 3 { 0 => ..., 1 => ..., 2 => ..., _ => <unreachable> } (if x is unsigned)
[03:27:58] <aatch> dbaupp, yeah, then you change 3->4, forget to update the match and it doesn't complain.
[03:28:02] <strcat> dbaupp: llvm will compile it out
[03:28:04] <strcat> doesn't matter
[03:28:18] <dbaupp> strcat: oh ok, good!
[03:28:21] <strcat> builtin_unreachable is only for when it wouldn't be able to know - and in that case it usually wouldn't be safe
[03:28:29] <tcsc> assert!(perform_expensive_function() == expected_result)  ?
[03:28:37] <tcsc> that would be a case where it makes a difference
[03:28:43] <strcat> tcsc: assert isn't for debugging though
[03:28:45] <dbaupp> aatch: yeah, presumably it'd only be an absolute micro-optimisation
[03:28:48] <strcat> it's just a shortcut for writing failure cases
[03:28:50] <tcsc> well, debug_assert then
[03:28:51] <aatch> strcat, we use the range attributes for enum discriminants, right?
[03:28:56] <strcat> aatch: yes
[03:28:58] <strcat> aatch: and bools
[03:29:04] <dbaupp> aatch: (when the user is already digging around with unsafe)
[03:29:18] <strcat> dbaupp: yeah but the use cases for it are really rare
[03:29:27] <dbaupp> strcat: correct
[03:29:36] <aatch> and the few that exist are dealt with by LLVM anyway.
[03:29:51] <dbaupp> (to be clear, I'm not particularly interested in it.)
[03:30:53] <aatch> my PR will be through soon*! (*1hr)
[03:31:11] <aatch> Then I can bulk out the rest of the atomic types.
[03:31:34] <dbaupp> we're using some ec2 machines for buildbot now, right?
[03:31:55] <aatch> dbaupp, correct. They're like half the speed of the other bots though.
[03:32:28] <dbaupp> aatch: that explains why irfy looks like \/\/ :(
[03:32:45] <aatch> dbaupp, yeah... :'(
[03:32:59] * dbaupp thinks it's basically useless now
[03:33:13] <aatch> Well cmr will have his stuff ready soon, you'll be able to use that instead. Right?
[03:33:28] <dbaupp> aatch: yeah
[03:33:47] * dbaupp has all sorts of plans for making irfy awesome with that data
[03:33:57] <aatch> Next on my refactoring list: Values/ValueRefs
[03:33:58] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[03:34:07] <aatch> This one is gonna be tricky.
[03:36:29] *** Quits: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com) (Quit: Computer has gone to sleep.)
[03:36:38] *** Joins: erickt1 (erickt@49C4075F.3AC15C18.2321E71E.IP)
[03:36:39] * aatch is tempted to start on another snapshot, just to be able to use default methods.
[03:37:44] <dbaupp> aatch: I won't complain
[03:38:26] *** Quits: erickt1 (erickt@49C4075F.3AC15C18.2321E71E.IP) (Ping timeout)
[03:39:13] *** Quits: heftig (heftig@moz-5E306FE6.dip0.t-ipconnect.de) (Ping timeout)
[03:39:55] <aatch> Hmm, from looking at it, looks like our recent spate of long-time-between-snapshots is the exception
[03:40:25] <aatch> I mean, there are a few cases of having one dated the next day, and most are like 5-6 days apart
[03:41:27] <dbaupp> is it possible for it to be "automated"?
[03:41:41] <dbaupp> i.e. every day or so master gets pushed to snap-stage3
[03:41:47] <dbaupp> (or week)
[03:41:54] <aatch> dbaupp, technically.
[03:42:00] *** Joins: heftig (heftig@moz-DDC44F26.dip0.t-ipconnect.de)
[03:42:24] <aatch> but you still have to manually update the compiler itself in order to get it to build under the snapshot
[03:42:50] <dbaupp> ah, right. and presumably having human oversight is required... because having a broken snapshot would be bad.
[03:43:30] <aatch> dbaupp, yep. Like the error I encountered of it not having libextra in the snapshot tarball
[03:43:54] <dbaupp> yup
[03:44:20] <dbaupp> (although the registration patch goes through bors/buildbots, so it's probably not too bad.)
[03:45:10] <aatch> Ok, so bblum needs a snapshot to continue anyway, so I bumped the priority of his PR, it's only behind some minor commits anyway.
[03:45:26] <bblum> i might not actually need it
[03:45:38] <bblum> it is uncertain
[03:45:39] <aatch> bblum, no?
[03:46:04] <bblum> well, it's also not like i'm totally blocked on it even if so
[03:46:06] <bblum> i have other stuff i can do
[03:46:20] <bblum> but in any case, with https://github.com/mozilla/rust/issues/7264 , it Just Works
[03:47:20] <aatch> bblum, fair enough. Either way, kinda unfair to make a snapshot just before it goes through.
[03:47:34] <bblum> just before what goes through?
[03:48:03] <bblum> but yeah, last year, we would have a snapshot every week or so
[03:48:10] <bblum> frequently more
[03:48:13] <aatch> bblum, https://github.com/mozilla/rust/pull/7248
[03:48:30] <bblum> oh, yes, before my pr goes through
[03:48:41] <bblum> come on bors, just take it
[03:48:54] <aatch> bblum, it's waiting on /my/ PR
[03:49:14] <bblum> i see, bors is testing your thing?
[03:49:33] <aatch> bblum, yes
[03:50:07] <bblum> just force push all open PRs, how bad could it be
[03:50:09] <aatch> It may actually conflict though
[03:51:49] <aatch> Dammit, one conflict
[03:53:20] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: WeeChat 0.4.1)
[03:53:24] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[03:54:03] *** Joins: brson (brson@72B1AFF8.AD1E507F.3688B332.IP)
[03:54:04] *** ChanServ sets mode: +o brson
[03:54:20] <aatch> bblum, ok, so fair warning, you're gonna get a conflict if my PR passes (which it look like it will). just one though.
[03:55:09] <dbaupp> aatch: how do you check conflicts without actually running a merge/rebase?
[03:55:10] <aatch> one file*
[03:55:19] <bblum> aatch: no :( can you fix it
[03:55:21] <aatch> dbaupp, I merged his branch in.
[03:55:28] <aatch> bblum, I dunno how...
[03:55:33] <dbaupp> aatch: oh, right
[03:55:34] <bblum> hm well
[03:55:44] <bblum> you could merge my branch and then fix the conflict in yours
[03:55:45] <bblum> i mean, i could fix it
[03:55:50] <bblum> but, then it would have to wait until monday
[03:55:56] <aatch> bblum, why?
[03:56:05] <bblum> 'cause I won't be back at my work laptop until then
[03:56:18] <bblum> well, i mean, i guess i could pull and work at home
[03:56:45] <aatch> bblum, it's just from adding that extra field from ty_trait.
[03:58:48] <bblum> oh yeah
[03:58:57] <bblum> changing ADT definitions sure is a pain
[03:59:45] <bblum> aatch: i don't suppose you can use "ty_trait(*)"
[03:59:59] <aatch> bblum, needs the store
[04:00:04] <bblum> busted
[04:00:42] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: WeeChat 0.4.1)
[04:01:46] <bblum> clearly we should have a partial-* form
[04:02:05] <bblum> (well, really, this is what records are for)
[04:03:00] <dbaupp> rusti: enum A { X(u8, u8, u8) } match X(1,2,3) { X(1, *) => true, _ => false }
[04:03:01] -rusti- <anon>:9:56: 9:57 error: unexpected token: `*`
[04:03:01] -rusti- <anon>:9          enum A { X(u8, u8, u8) } match X(1,2,3) { X(1, *) => true, _ => false }
[04:03:01] -rusti-                                                                  ^
[04:03:01] -rusti- application terminated with error code 101
[04:03:14] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[04:03:22] <dbaupp> rusti: enum A { X {a: u8, b: u8, c: u8} } match X(1,2,3) { X{a: 1, _} => true, _ => false }
[04:03:23] -rusti- <anon>:9:50: 9:51 error: unresolved name `X`.
[04:03:23] -rusti- <anon>:9          enum A { X {a: u8, b: u8, c: u8} } match X(1,2,3) { X{a: 1, _} => true, _ => false }
[04:03:23] -rusti-                                                            ^
[04:03:23] -rusti- error: aborting due to previous error
[04:03:23] -rusti- application terminated with error code 101
[04:03:30] *** Quits: devbug (quassel@moz-E1DE087C.bchsia.telus.net) (Ping timeout)
[04:03:35] <dbaupp> rusti: enum A { X {a: u8, b: u8, c: u8} } match X {a:1,b:2,c:3} { X{a: 1, _} => true, _ => false }
[04:03:36] -rusti- true
[04:03:38] <aatch> bblum, well what do you think the best plan of action is?
[04:03:56] <Aetherspawn> ping! someone used rusti
[04:04:10] *** Quits: tav (tav@moz-5ED3AF3C.range86-152.btcentralplus.com) (Quit: tav)
[04:04:39] <Aetherspawn> oh wow, there's record matching. That's awesome.
[04:05:19] <bblum> aatch: if i resolve the conflict, it will involve rebasing my latest branch up to latest master, and then i will either force-push to bblum/trait-bounds or open a fresh PR
[04:05:31] <bblum> presumably you will have the same problem though
[04:06:04] <aatch> bblum, what do you mean? The only issue here is that it'll bounce when bors tries to merge it.
[04:06:49] <bblum> not if i push -f the fix before bors picks it up, which i guess is not likely
[04:07:26] <bblum> anyway i can just wait for that to happen, make the fix, and make a new PR and r= somebody
[04:07:31] *** Joins: erickt1 (erickt@49C4075F.3AC15C18.2321E71E.IP)
[04:07:37] <aatch> bblum, yeah, just wait for the bounce, fix it and then re-approve.
[04:08:03] <bblum> i know it was terrible but this makes me miss the old rustbot
[04:08:13] <aatch> just give it a higher priority (I did p=10) and you just get bumped down one on the list.
[04:09:18] *** Quits: erickt1 (erickt@49C4075F.3AC15C18.2321E71E.IP) (Ping timeout)
[04:10:00] <aatch> bblum, if it's any consolation, it seems that that conflict is the only thing, it's building fine.
[04:10:14] <aatch> (This is your branch merged into mine)
[04:10:23] <bblum> good
[04:13:18] <aatch> I wonder if brendanc will get to do his crazy octopus merge thing
[04:14:22] *** Joins: devbug (quassel@moz-E1DE087C.bchsia.telus.net)
[04:15:31] <bblum> aatch: http://lulabs.net/octopus.scale.png
[04:15:57] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[04:16:06] <aatch> bblum, heh, that's awesome
[04:16:25] <bblum> friend of mine made this a long time ago
[04:16:45] <aatch> I recognize the handle, kalendrael.
[04:21:06] *** Quits: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca) (Quit: Leaving)
[04:23:59] <strcat> dbaupp: https://github.com/mozilla/rust/pull/7289 so close ;p, needs a rebase already
[04:24:48] <aatch> strcat, I am not suprised with there being 181 changed files
[04:25:39] <dbaupp> strcat: yay!
[04:25:39] <strcat> 182 now, had to fix a pretty print test ;p
[04:25:50] <dbaupp> strcat: that looks like so much fun :(
[04:25:55] <strcat> lol
[04:26:07] <strcat> yeah considering that there are many other each methods left so 'sed' didn't work
[04:26:13] <strcat> what I actually did was sed them all to iter().advance
[04:26:19] <strcat> and then fix the ones that shouldn't have been migrated
[04:26:26] <dbaupp> heh
[04:26:46] <strcat> so I only had to deal with like 200 errors instead of 2000 ;\
[04:26:54] <strcat> CONFLICT (content): Merge conflict in src/librustc/back/link.rs
[04:27:01] <strcat> not too bad
[04:27:07] <strcat> but I bet a commit has introduced another .each by now
[04:27:09] <strcat> ;[
[04:27:34] <dbaupp> (is there a reason run-pass/static-method-test.rs is removed?)
[04:27:42] <aatch> strcat, I tried to avoid that, if it's any consolation.
[04:27:49] <strcat> dbaupp: yes, it used BaseIter and has to be totally rewritten
[04:28:04] <dbaupp> strcat: have/will you?
[04:28:26] <strcat> well we already have other static methods everywhere... there's FromIterator + tests in another pull
[04:28:50] * strcat doesn't know what it's specifically supposed to be testing ;\
[04:29:50] <strcat> also there were 3 cases I had to migrate to vec::each for now.... because of bugs
[04:29:54] *** Joins: H4199 (chatzilla@moz-64E556D3.austin.res.rr.com)
[04:30:00] <dbaupp> :(
[04:30:10] <strcat> a type inference bug (I could probably just annotate the types) + an actual bug in codegen
[04:30:18] <strcat> I'll report both later
[04:30:37] <dbaupp> (the 'for x.each' -> 'let y = x; for x.iter().advance' pattern is annoying :( )
[04:30:49] <strcat> does someone want to r+ it? ;p
[04:30:52] <strcat> dbaupp: yep rvalue bugs
[04:31:03] <strcat> I hope we get that fixed soon
[04:31:16] <strcat> foo.move_into().borrow()
[04:31:19] <strcat> works fine
[04:31:20] *** Quits: BitPuffin (quassel@moz-49828767.cust.tele2.se) (Ping timeout)
[04:31:22] <strcat> foo().move_into().borrow()
[04:31:24] <strcat> doesn't work.
[04:32:10] <strcat> but anyway they're easy to find
[04:32:15] <strcat> let r = with r.iter() on the next line
[04:32:26] <dbaupp> (I hope people don't get annoyed about the p=20... aatch/bblum?)
[04:32:37] <dbaupp> strcat: yeah
[04:32:39] <bblum> uh whatever
[04:33:04] <strcat> it will probably need rebasing a few times anyway, I'm running make check yet again
[04:33:19] <strcat> close to being able to replacing 'for'.... 
[04:33:28] <strcat> could just replace the remaining internal loops with 'do'
[04:33:41] <strcat> to replace*
[04:33:56] <dbaupp> strcat: not quite, ... return/break :(
[04:34:08] <dbaupp> (as in, it's not a straight replacement)
[04:34:13] <strcat> dbaupp: well we should allow 'return' inside nested closures
[04:34:20] <strcat> afaik the only reason we don't is that it'd be confusing with for loops
[04:34:26] <strcat> since it does something really weird in for loops.
[04:34:28] <dbaupp> returning from the outer function?
[04:34:31] <strcat> dbaupp: inner
[04:34:35] <strcat> you can't return from an outer function
[04:34:53] <strcat> break can be 'return false' in 'do'
[04:34:55] * strcat shrugs
[04:35:05] *** Quits: tcsc (tcsc@moz-ADC0ED45.hsd1.ct.comcast.net) (Quit: computer sleeping)
[04:35:08] <strcat> or not, don't really care
[04:35:10] <bblum> afair we don't have return in block closures for the specific reason that it might confuse people who intend for it to return from the outer function
[04:35:10] <dbaupp> yep, `for ... return` requires slightly more work though
[04:35:45] <bblum> i personally would not be sad to see it mean return from the inner closure
[04:35:49] <strcat> dbaupp: there aren't going to be many left in a few days
[04:36:01] <dbaupp> strcat: :D
[04:36:03] <strcat> strcat@thinktank i ~/projects/rust iterator % git grep '\.advance ' | wc -l
[04:36:05] <strcat> 1025
[04:36:07] <strcat> strcat@thinktank i ~/projects/rust iterator % git grep '\.each ' | wc -l   
[04:36:09] <strcat> 108
[04:36:34] <bblum> thinktank is a great name for a laptop
[04:36:38] <strcat> so soon .advance can just be the identity function
[04:36:42] <strcat> bblum: a thinkpad ofc :)
[04:36:53] <bblum> i was hoping it would be a macbook just for the troll factor
[04:37:07] <aatch> Man, thinkpads are immortal
[04:37:15] <bblum> not true
[04:37:32] <strcat> they have delicate lines of thinkpads (edge and carbon)
[04:37:54] <strcat> this is just a t530, it's a tank ;p
[04:38:00] <aatch> I was thinking of the T-series
[04:38:08] <bblum> magrathea, my t60p, died 2 springs ago, just before i got vipassana, the w520 mozilla gave me
[04:38:12] *** Joins: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com)
[04:38:14] <bblum> after 5 years of life
[04:38:25] <aatch> Knew a girl at uni that had a 10-year-old thinkpad, still going strong.
[04:38:33] <strcat> bblum: most laptops get broken hinges after 1-2 years though ;p
[04:38:48] <bblum> the cpu fan was very rattly for the last year, and the monitor cable was getting sketchier and sketchier
[04:39:14] <bblum> oh yeah, also the hard drive wouldn't serve data any faster than like 11MB/s
[04:39:17] <aatch> my laptop gave up after 5 years, but I'm not exactly the standard user.
[04:39:38] * strcat has a dog who likes making laptops fall on the ground
[04:39:39] <aatch> Also business laptops >>> consumer laptops
[04:39:46] <strcat> power cable? perfect thing to run into
[04:39:49] <bblum> i used the accidental damage warranty a handful of times to get practically every part except the hard drive replaced at least once
[04:40:30] <strcat> at least it wasn't a dell/hp one ;p
[04:40:40] <strcat> 100% cpu usage? emergency shutoff.
[04:40:48] <aatch> bahahaha
[04:40:51] <strcat> older macbook airs did that too
[04:40:58] <strcat> run 'yes' in a terminal -> shuts off
[04:41:22] <aatch> seems like a great way to troll people.
[04:41:30] <strcat> intel cpus just throttle themselves a lot now though....
[04:41:58] <strcat> so instead of shutdowns, silly ultrabooks are just throttled to low speeds all the times
[04:42:05] <strcat> time*
[04:42:57] <strcat> I was looking forward to intel's replacement for ondemand with linux 3.9 but it doesn't work with ivy bridge yet :(
[04:43:15] <aatch> ok, so there doesn't seem to be anything in the current codebase that /needs/ changing for a new snapshot.
[04:43:19] <aatch> Which is nice
[04:44:41] <aatch> this build took 5hrs: http://buildbot.rust-lang.org/builders/master-linux/builds/130
[04:45:07] <strcat> aatch: we need to cancel leftovers from failed builds
[04:45:43] <strcat> http://buildbot.rust-lang.org/builders/auto-win-32-opt/builds/24 this one is... stuck
[04:46:13] <strcat> aatch: I'm sure your refactor will conflict anyway ;p
[04:46:17] <strcat> yep
[04:46:20] <strcat> it will
[04:46:21] <strcat> oh well ;\
[04:47:06] <strcat> aatch: ah because linux3/linux4 are EC2
[04:47:20] <aatch> strcat, yep.
[04:48:24] <strcat> huh, linux5
[04:48:25] <aatch> Need to ask graydon to tweak the settings so the EC2 bots aren't used for some of the builds
[04:48:30] <strcat> http://buildbot.rust-lang.org/builders/auto-linux-all-opt/builds/25 ;\
[04:48:50] <aatch> strcat, there are 8 linux buildslaves
[04:49:03] <aatch> 1, 1b, 2, 2b, 3-6
[04:49:03] <strcat> how many are real hardware?
[04:49:17] <aatch> probably only 1 and 2 are "real"
[04:49:24] <strcat> aatch: ideally we wouldn't have ec2 ones at all
[04:49:48] <aatch> Well the ec2 ones would be fine for the quicker builds.
[04:50:20] <aatch> but when it inflates a 2hr build time to 4-5hrs, thats bad
[04:50:44] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[04:50:50] <aatch> inflating a 30min build time to 1-1.5hrs. bad, but not nearly as much
[04:51:04] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[04:52:37] <strcat> I'm sure mozilla can sacrifice a few more computers
[04:54:01] <aatch> They probably can, but I imagine it's not as easy as just going up to the receptionist and asking her to order some.
[04:54:11] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[04:56:05] *** Quits: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Quit: Don't tell them I was here...)
[05:01:23] *** Joins: infynyxx (infynyxx@moz-8BE8F2CD.hsd1.md.comcast.net)
[05:01:37] *** Quits: steven_is_false (user@moz-144077DE.bchsia.telus.net) (Client exited)
[05:05:24] <Eridius> strcat: dammit, my vec-stuff needed rebasing because someone else also added use std::iterator::IteratorUtil. But they put a space in that I didn't >_<
[05:05:36] <Eridius> `use std::iterator::{Iterator, IteratorUtil}`
[05:05:38] * strcat did that
[05:05:40] <strcat> I think
[05:05:42] <strcat> :D
[05:05:46] <Eridius> pfft
[05:05:50] * Eridius shakes his fist
[05:06:01] <strcat> more doc pull requests for my master-doc-pull-request to gobble up
[05:06:14] <aatch> om nom nom docs.
[05:06:24] <Eridius> strcat: indeed you did make the change
[05:06:44] <Eridius> thanks for the heads-up. I'm surprised bors doesn't comment when a PR goes stale
[05:06:49] <strcat> https://github.com/mozilla/rust/pull/7270 lots ;p
[05:07:02] <strcat> but anyway the queue is really backed up ;[
[05:07:04] <aatch> Eridius, he does when he tries to merge it :P
[05:07:24] <Eridius> aatch: I thought that's how it goes stale? It was listed as STALE in the queue
[05:07:39] <strcat> Eridius: github detects it
[05:07:43] <strcat> so bors doesn't do anything
[05:07:48] <strcat> github should have a way to notify you
[05:07:48] <Eridius> :O
[05:07:51] <strcat> but it's github so it doesn't
[05:08:06] <aatch> I opened this: https://github.com/mozilla/rust/issues/7290
[05:08:07] <strcat> 'On Monday June 24, we will begin rejecting pushes which add or modify files that are larger than 100 MB.'
[05:08:45] <aatch> What on earth happened that made them implement that?
[05:09:10] <strcat> aatch: people started storing videos and crap
[05:09:24] <aatch> Ugh. This is why we can't have nice things.
[05:09:39] <strcat> rusti: 2
[05:09:41] <strcat> rusti: 2
[05:09:42] -rusti- 2
[05:09:43] -rusti- 2
[05:09:43] <strcat> rusti: 2
[05:09:45] -rusti- 2
[05:10:12] * strcat is sad that there's basically nothing left to add to playpen ;[
[05:10:48] <bblum> do we have more bots than PRs to test in parallel
[05:11:06] <bblum> if so, we could parallelize by having some of the bots run stdtest, extratest, syntaxtest, etc
[05:11:12] <bblum> while others run run-pass, etc
[05:12:31] *** Quits: bytbox (s@moz-D83E9B31.wireless.umd.edu) (Ping timeout)
[05:13:03] <aatch> bblum, the issue is that each build is a different configuration.
[05:13:27] <bblum> oh
[05:15:03] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[05:16:23] <aatch> And the problem we currently have is that some of the bots are slow, so if they decide to grab, say, auto-linux-all-opt, it takes an already slow build and does it even more slowly
[05:17:17] <aatch> while the faster bots do a faster build in less than half the time.
[05:19:36] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[05:20:18] <aatch> Example: http://buildbot.rust-lang.org/builders/auto-linux-all-opt/builds/25 vs http://buildbot.rust-lang.org/builders/master-linux/builds/133
[05:34:32] <aatch> Ugh... Almost 3hrs to compile...
[05:44:54] <dbaupp> aatch: 6 minutes left!
[05:46:19] <aatch> dbaupp, it's done!
[05:49:11] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[05:49:11] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/1DnfvA
[05:49:11] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[05:50:05] <dbaupp> yay!
[05:52:07] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[05:52:07] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/8Xtwtw
[05:52:07] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[05:52:41] <dbaupp> strcat: :(
[05:53:46] <strcat> dbaupp: it will break against after bblum's
[05:54:01] <dbaupp> strcat: I think bblum's conflicts with aatch's
[05:54:09] <strcat> dbaupp: I'm going to set p=1 on the doc one
[05:54:14] <strcat> and I'll land it after that cycle
[05:55:05] <dbaupp> strcat: oh, ok. (fwiw, you probably won't conflict with erickt's one, which is likely to be the next one that has any chance of making it in.)
[05:55:07] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[05:55:07] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/8Xtwtw
[05:55:07] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[05:55:09] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[05:55:09] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/O7kWEQ
[05:55:09] <ghrust> 13rust/06auto 1434d2c67 15Kevin Ballard: Add method .set_memory in vec::bytes for &[u8]...
[05:55:09] <ghrust> 13rust/06auto 1477cac76 15Kevin Ballard: Add methods .move_from() and .copy_from() to vec...
[05:55:09] <ghrust> 13rust/06auto 145a3fb6b 15bors: auto merge of #7210 : kballard/rust/vec-stuff, r=thestinger
[05:55:12] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[05:55:18] <bjz_> yay!
[05:55:30] <bjz_> mammoth effort mr aatch!
[05:55:46] <strcat> oh nvm
[05:55:49] <strcat> I can land it after this one
[05:56:13] <erickt> dbaupp: I'm not going to be able to rebase tonight, so please don't wait on me for anything
[05:56:33] <dbaupp> erickt: oh, I didn't even realise it was stale
[05:56:43] <erickt> yep :(
[05:56:47] <strcat> erickt: no worries, just figuring out how to land changing nearly 1000 .each to .iter().advance ;p
[05:57:24] <aatch> I broke a lot of trans-related PRs
[05:58:16] <dbaupp> aatch: and strcat is probably breaking the rest ;D
[05:58:30] <aatch> All in the name of progress!
[05:59:39] <strcat> I don't think I'm really going to be breaking anything that's not already broken atm
[05:59:47] <strcat> aatch killed them all already ;p
[06:00:00] <aatch> mwuahaha
[06:00:13] <strcat> including his own
[06:00:28] <aatch> Yes...
[06:00:39] <aatch> Though I think that was broken before
[06:08:18] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[06:10:05] <strcat> stupid bor
[06:10:07] <strcat> s
[06:10:31] <aatch> strcat, what now?
[06:10:41] <strcat> it stopped checking my pull
[06:10:44] <strcat> closing it and reopening
[06:10:46] <strcat> ;\
[06:19:31] *** Joins: infynyxx_ (infynyxx@moz-8BE8F2CD.hsd1.md.comcast.net)
[06:19:50] *** Quits: infynyxx (infynyxx@moz-8BE8F2CD.hsd1.md.comcast.net) (Connection reset by peer)
[06:26:51] <aatch> strcat, do you think that LLVM would consider two undefined operations the "same" when trying to do mergefunc?
[06:27:15] <dbaupp> strcat: bors hasn't found it yet :(
[06:29:47] *** Joins: sankha93 (Instantbir@7FDB90C9.F989CC7B.62DB355F.IP)
[06:31:39] *** Quits: infynyxx_ (infynyxx@moz-8BE8F2CD.hsd1.md.comcast.net) (Client exited)
[06:32:02] *** Joins: infynyxx (infynyxx@moz-8BE8F2CD.hsd1.md.comcast.net)
[06:33:58] *** Quits: infynyxx (infynyxx@moz-8BE8F2CD.hsd1.md.comcast.net) (Ping timeout)
[06:37:08] <strcat> aatch: dunno, but it can do whatever it wants with undef code
[06:37:19] <strcat> until it's all gone we have no guarantees *anything* will work ;\
[06:37:42] <strcat> dbaupp: can you r+ it yourself
[06:37:50] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[06:38:06] <dbaupp> strcat: on the same pr_
[06:38:10] <dbaupp> ?
[06:38:14] <strcat> dbaupp: meh let me reopen it completely
[06:38:21] *** Joins: infynyxx (infynyxx@moz-8BE8F2CD.hsd1.md.comcast.net)
[06:38:43] <aatch> strcat, I just had a thought that might it might be the reason why mergefunc broke everything.
[06:39:01] <strcat> aatch: would make sense
[06:39:17] <strcat> dbaupp: https://github.com/mozilla/rust/pull/7292
[06:40:06] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[06:40:09] *** Quits: infynyxx (infynyxx@moz-8BE8F2CD.hsd1.md.comcast.net) (Ping timeout)
[06:40:31] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Client exited)
[06:40:40] <aatch> since it's gonna just assume that two, for example, glue calls are the same, even if they aren't. Which also probably explains why it seemed to kill the HashMap impl
[06:41:15] <aatch> since that generates a lot of merge-able functions so there's a higher chance of that kind of collision.
[06:41:26] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[06:43:19] <dbaupp> strcat: done
[06:43:46] <strcat> hopefully it works...
[06:44:11] <dbaupp> it doesn't conflict with the current pr, does it?
[06:44:14] *** Quits: cdidd (cdidd@moz-16366370.broadband.corbina.ru) (Ping timeout)
[06:44:33] <strcat> dbaupp: don't think so
[06:44:59] <dbaupp> is all the undef behaviour "Undefined behavior: Call return type mismatches callee return type"?
[06:45:09] <dbaupp> (I assume that it's non-trivial to fix?)
[06:45:38] <strcat> lots of probably trivial to fix
[06:47:51] <aatch> it's trivial to fix, but it's trivial in context with trans code
[06:50:26] <strcat> dbaupp: it's not picking it up
[06:50:28] <strcat> ;\
[06:51:19] <strcat> going to shove it into my other PR
[06:51:25] <dbaupp> strcat: it's picked up 7289
[06:51:33] <dbaupp> (but not your r=)
[06:51:47] <strcat> that's closed
[06:51:54] <dbaupp> yeah
[06:52:07] <dbaupp> it's still listed in http://buildbot.rust-lang.org/bors/bors.html though
[06:52:19] <strcat> so bors is totally broken atm.
[06:53:21] <strcat> lets see what happens now
[06:53:55] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[06:54:48] <dbaupp> 7292 is now listed
[06:55:02] <strcat> wtf
[06:55:07] <dbaupp> (maybe it's just delayed?)
[06:55:09] <strcat> it only sees the closed one?
[06:55:14] * dbaupp doesn't understand
[06:55:26] <dbaupp> heh :(
[06:55:27] <strcat> dbaupp: I'm waiting a cycle before doing anything though
[06:55:43] <dbaupp> strcat: yeah, I don't know
[06:55:49] <strcat> leaving both open
[06:55:56] <dbaupp> strcat: maybe having the commit twice is breaking it?
[06:59:26] <dbaupp> strcat: seems to have got it now
[06:59:33] <strcat> dbaupp: because it's gone completely
[06:59:51] <dbaupp> gah!
[06:59:59] <strcat> I deleted the branch and cherry-picked it to my other pull
[07:00:24] <strcat> https://github.com/mozilla/rust/pull/7274
[07:00:26] * strcat shrugs
[07:00:33] <strcat> stupid bors playing mind tricks on me
[07:00:55] *** Quits: sankha93 (Instantbir@7FDB90C9.F989CC7B.62DB355F.IP) (Quit: Instantbird 1.4 -- http://www.instantbird.com)
[07:01:28] *** Joins: Blei (philipp@moz-650B9C6A.cust.bluewin.ch)
[07:01:49] <aatch> strcat, bors is the master of mind games.
[07:02:59] <strcat> well he tricked me into reducing his workload by a pull
[07:03:02] <strcat> so good for him ;p
[07:05:01] <Blei> sooo many stale pull requests XD
[07:05:33] <aatch> Blei, mea culpa
[07:06:17] <Blei> aatch: haha, no but great work on the trans refactoring
[07:06:29] <aatch> Blei, thanks.
[07:06:50] <aatch> I'm not sure where to start next though. I'm running out of low-hanging fruit.
[07:06:53] <Blei> i'm glad it has finally landed
[07:07:22] <aatch> Blei, you and me both. I rebased it 3 times today.
[07:08:20] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[07:08:20] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 145a3fb6b to 14dc4560d: 02http://git.io/N3iJvQ
[07:08:20] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[07:08:22] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[07:08:22] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/9jOTgA
[07:08:22] <ghrust> 13rust/06auto 1428eb19a 15Daniel Micay: vec: remove BaseIter implementation...
[07:08:22] <ghrust> 13rust/06auto 143bbf472 15bors: auto merge of #7289 : thestinger/rust/iterator, r=huonw,huonw...
[07:08:22] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[07:08:40] <aatch> hurrah
[07:08:53] <dbaupp> heh I review that twice, apparently
[07:09:14] <dbaupp> also... that pull request is closed :(
[07:09:17] <dbaupp> dammit bors
[07:09:42] <aatch> Weird... the current build isn't done either...
[07:10:02] <aatch> Well, this is gonna be fun...
[07:10:21] <dbaupp> wtf
[07:10:47] <dbaupp> strcat: I think we broke him properly :/
[07:11:18] <Blei> hmm, when was std::uint::range removed? i missed that
[07:11:44] <dbaupp> it wasn't?
[07:12:02] <dbaupp> rusti: for std::uint::range(0, 3) |i| { println(i.to_str()) }
[07:12:06] -rusti- 0
[07:12:06] -rusti- 1
[07:12:06] -rusti- 2
[07:12:06] -rusti- ()
[07:12:11] <Blei> huh
[07:12:15] <Blei> http://buildbot.rust-lang.org/builders/auto-win-32-nopt/builds/24/steps/test/logs/stdio
[07:12:15] *** Quits: anri (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net) (Quit: anri)
[07:12:34] <Blei> what is going on
[07:12:55] <dbaupp> I bet `::std::uint::range` would work
[07:13:01] <dbaupp> what pr is that from?
[07:13:13] <Blei> oh, right. the merged run-pass tests...
[07:13:20] *** Joins: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au)
[07:13:23] <Blei> thanks, i'll fix it
[07:13:28] <Blei> https://github.com/mozilla/rust/pull/7214
[07:13:30] <dbaupp> (`use std;` would work too)
[07:13:45] <Blei> needs a rebase anyway, thanks to the trans refactoring
[07:15:17] <strcat> why did bors merge that?
[07:15:19] <strcat> it was closed
[07:15:46] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[07:15:46] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 143bbf472 to 14dc4560d: 02http://git.io/N3iJvQ
[07:15:46] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[07:15:48] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[07:15:48] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/I9qzig
[07:15:48] <ghrust> 13rust/06auto 1434d2c67 15Kevin Ballard: Add method .set_memory in vec::bytes for &[u8]...
[07:15:48] <ghrust> 13rust/06auto 1477cac76 15Kevin Ballard: Add methods .move_from() and .copy_from() to vec...
[07:15:48] <ghrust> 13rust/06auto 14529943d 15bors: auto merge of #7210 : kballard/rust/vec-stuff, r=thestinger
[07:15:50] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[07:15:53] <strcat> and it's not done with the last one
[07:15:56] <aatch> AHHHHH
[07:16:20] <dbaupp> is there a kill switch for bors?
[07:16:26] <aatch> strcat, that's the one it thought was done...
[07:16:34] <aatch> dbaupp, yeah, on graydon's pc...
[07:16:43] <strcat> well
[07:16:48] <strcat> wtf
[07:17:00] <strcat> ok when those tests pass I'll manually merge Eridius' pull
[07:17:10] <strcat> assuming bors doesn't
[07:17:22] <strcat> uh wtf is it doing
[07:17:23] <dbaupp> what timezone's graydon in?
[07:17:24] <strcat> it's adding more
[07:18:05] <dbaupp> bors' status page only lists one?
[07:18:51] <dbaupp> (should I file a bug?)
[07:20:43] <strcat> it won't stop making more builds
[07:22:22] <bblum> the classic "benevolent" AI story
[07:22:45] <Eridius> hrm, is someone mucking with bors? I just had tests "fail", with the failure being that the web page "stop" button was pressed
[07:23:05] <strcat> Eridius: it decided to go haywire
[07:23:16] <aatch> Eridius, look down a couple commits on the console
[07:23:18] <strcat> Eridius: merged a closed pull request on top of yours and decided dbaupp reviewed it twice
[07:23:24] <strcat> then merged yours again on top of it
[07:23:31] <strcat> and started up the builds 3 times over
[07:23:42] <Eridius> hah
[07:23:44] <strcat> I cancelled them
[07:23:52] <Eridius> nice job bors
[07:23:55] <strcat> when the tests pass I'll manually merge it and we'll see what happens
[07:24:04] <strcat> for now I think it's safely stuck
[07:24:13] <strcat> http://buildbot.rust-lang.org/grid?branch=auto&refresh=15
[07:24:17] <dbaupp> Eridius: (the failures seem to be from the second merge of yours.)
[07:24:34] <strcat> dbaupp: it posted the failures twice though
[07:24:57] <strcat> stupid AIs ;[
[07:25:04] <dbaupp> strcat: 3 tiems
[07:25:06] <dbaupp> s/em/me/
[07:25:24] <strcat> does it appear to be stopped now? I force cancelled all of the incorrect builds
[07:25:57] <strcat> I think it ran two builds on top of each other
[07:26:01] <strcat> and clobbered it
[07:26:31] <aatch> Eridius, you did just get a regular failure on one of the bots though
[07:26:46] <Eridius> aatch: oh?
[07:26:53] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[07:26:53] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14529943d to 14dc4560d: 02http://git.io/N3iJvQ
[07:26:53] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[07:26:54] <strcat> aatch: doesn't look like it?
[07:26:56] <strcat> uh
[07:26:58] <strcat> bors, please stop
[07:26:59] <aatch> http://buildbot.rust-lang.org/builders/auto-linux-32-opt/builds/26/steps/test/logs/stdio
[07:27:46] <Eridius> aatch: assertion failure in tcp? Must be something else. My commit adds new API, not modifies existing API
[07:27:56] <aatch> actually, yeah.
[07:28:01] <strcat> I think it got confused by an r+ on an older commit and a newer one
[07:28:12] <aatch> I think the console is lying to me...
[07:29:21] * strcat thinks bors needs a kill switch :|
[07:30:04] <strcat> that's just great.
[07:32:52] <strcat> aatch: it looks like nothing failed?
[07:33:00] <strcat> aatch: http://buildbot.rust-lang.org/grid?branch=auto&refresh=15
[07:33:57] <aatch> strcat, huh. that's different to what the console tells me...
[07:34:04] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[07:34:04] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14f6f6b31 to 14dc4560d: 02http://git.io/N3iJvQ
[07:34:04] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[07:34:06] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[07:34:06] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/V0D_zA
[07:34:06] <ghrust> 13rust/06auto 140a7ee42 15Daniel Micay: iterator: add a size_hint default method...
[07:34:06] <ghrust> 13rust/06auto 140b04814 15Daniel Micay: iterator: add a FromIterator trait...
[07:34:06] <ghrust> 13rust/06auto 14688a1a8 15Daniel Micay: vec: remove BaseIter implementation...
[07:34:07] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[07:34:17] <strcat> aatch: https://github.com/mozilla/rust/pull/7274 also look at this
[07:34:24] <strcat> aatch: it's like there are two bors processes....
[07:34:30] <strcat> bors replied 7 minutes ago
[07:34:32] <strcat> saw approval from huonw
[07:34:34] <strcat> at thestinger@688a1a8
[07:34:36] <strcat> bors replied just now
[07:34:38] <strcat> saw approval from huonw
[07:34:40] <strcat> at thestinger@688a1a8
[07:34:43] <strcat> it's going to clobber it again
[07:35:09] <aatch> oh crap...
[07:35:21] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[07:35:21] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 148427439 to 14dc4560d: 02http://git.io/N3iJvQ
[07:35:21] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[07:35:23] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[07:35:23] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/MSIQFA
[07:35:23] <ghrust> 13rust/06auto 140a7ee42 15Daniel Micay: iterator: add a size_hint default method...
[07:35:23] <ghrust> 13rust/06auto 140b04814 15Daniel Micay: iterator: add a FromIterator trait...
[07:35:23] <ghrust> 13rust/06auto 14688a1a8 15Daniel Micay: vec: remove BaseIter implementation...
[07:35:25] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[07:35:33] <strcat> please, please stop bors :(
[07:35:48] <strcat> well I don't know what to do
[07:35:54] <strcat> it's going to keep doing this afaict
[07:36:11] <dbaupp> strcat: https://github.com/mozilla/rust/issues/7293 (fix up anything that's wrong please :) )
[07:36:41] <dbaupp> strcat: does anyone other than graydon have access to bors?
[07:36:48] <strcat> no
[07:37:35] <dbaupp> gah!
[07:38:19] <strcat> dbaupp: it got worse
[07:38:33] <strcat> it just did it *again*
[07:38:34] *** Joins: jviereck (Adium@moz-3D1EE18F.dip0.t-ipconnect.de)
[07:38:35] <strcat> fyi
[07:38:37] <strcat> dbaupp: http://buildbot.rust-lang.org/grid?branch=auto&refresh=15
[07:38:45] <dbaupp> yeah, I'm watching it :(
[07:39:53] <Blei> the conflicts, they burn
[07:40:24] <dbaupp> strcat: in theory, it won't be able to break anything, since it doesn't force-push to master
[07:40:33] <dbaupp> (hopefully... :S )
[07:41:00] <strcat> anyway it broke completely
[07:43:27] <strcat> well what should we do?
[07:43:38] <strcat> as soon as builds fail/finish it's going to start more :|
[07:44:11] <dbaupp> can we just shutdown all the builders?
[07:44:48] <strcat> we can cancel all the builds
[07:44:54] <dbaupp> (or will the "graceful shutdown" bit be too graceful?)
[07:45:44] <strcat> I'm just cancelling all of the builds it started
[07:46:48] *** Quits: jviereck (Adium@moz-3D1EE18F.dip0.t-ipconnect.de) (Quit: Leaving.)
[07:47:36] *** Joins: jviereck (Adium@moz-3D1EE18F.dip0.t-ipconnect.de)
[07:48:24] *** Joins: nano (nano@moz-972880B.superkabel.de)
[07:48:43] <strcat> buildbot doesn't seem to want to cooperate either
[07:49:15] <dbaupp> D:
[07:51:11] <strcat> anyway closing my pull request and giving up for tonight
[07:51:18] <strcat> hopefully it stops seeing it
[07:52:18] <aatch> In other new, master is currently green
[07:52:22] <gavinb> Greetings, I'm starting work on bug #7251 to remove uv I/O from libextra. Can anyone explain why there are two copies of uvll.rs and uvio.rs under src/libstd/rt which are mostly but not entirely the same?
[07:52:39] <aatch> gavinb, part of the io/scheduler re-write
[07:53:02] <gavinb> ah ok
[07:53:08] <aatch> probably not a good idea to touch the stuff under rt/ without talking to brson first.
[07:53:16] <strcat> I wouldn't be surprised if github was at fault
[07:53:23] <strcat> all of the current builds appear to be stalled on git
[07:53:31] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[07:53:52] <dbaupp> gavinb: that is, as far as I understand it, src/rt is where the uv functionality is moving
[07:53:57] <dbaupp> (so it's not needed in extra anymore)
[07:54:00] <gavinb> aatch: yes, I asked for suggestions on bits to work on, and this was in the list.
[07:54:40] <aatch> gavinb, ah, ok, yeah. Just remove it from extra
[07:55:04] <Luqman> dbaupp: er, moving *to* src/rt? i thought we were trying to reduce as much as possible from src/rt
[07:55:06] <gavinb> yes, I removed it, and am now working through fixing the breakage. :)
[07:55:06] *** Quits: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com) (Ping timeout)
[07:55:08] <aatch> should be as easy as just deleting the files and updating std.rc (or extra.rs)
[07:55:18] <aatch> Luqman, libstd/rt
[07:55:29] <dbaupp> Luqman: yeah, typo
[07:56:21] <gavinb> Well there's net_tcp.rs and net_ip.rs in libextra which depended on this deprecated uv support. So I presume I need to modify those to use the uv support in libstd/rt, right?
[07:56:55] <Luqman> those will be removed altogether afaik
[07:57:08] <aatch> gavinb, hmm... not sure. They are likely going to be obsoleted, but I doubt anybody will fault you for keeping them working for now
[07:57:34] <strcat> dbaupp: he keeps commenting that it failed ;\
[07:57:43] <strcat> 3rd one...
[07:58:02] <dbaupp> strcat: :(
[07:58:24] <gavinb> hm, they depend on the removed IoTask support from uv, so to replace it could be fiddly. Best I confer with brson I guess...
[07:59:07] *** Joins: sankha93 (Instantbir@7FDB90C9.F989CC7B.62DB355F.IP)
[07:59:49] <dbaupp> strcat: I guess we just hope graydon has some magic incantations to fix everything
[08:00:46] *** Quits: sankha93 (Instantbir@7FDB90C9.F989CC7B.62DB355F.IP) (Ping timeout)
[08:01:58] <strcat> he just reported that it failed again
[08:02:00] <strcat> 5th time
[08:02:21] *** Joins: sankha93 (Instantbir@7FDB90C9.F989CC7B.62DB355F.IP)
[08:02:42] * dbaupp sighs
[08:03:21] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[08:03:21] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14331b262 to 14dc4560d: 02http://git.io/N3iJvQ
[08:03:21] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[08:03:23] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[08:03:23] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/CbOvlQ
[08:03:23] <ghrust> 13rust/06auto 1488534ae 15Alex Crichton: Fix compiling empty fmt! strings
[08:03:23] <ghrust> 13rust/06auto 148a3254e 15bors: auto merge of #7227 : alexcrichton/rust/issue-7218, r=brson...
[08:03:23] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[08:03:49] <strcat> it might be okay now
[08:04:02] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[08:04:02] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 148a3254e to 14dc4560d: 02http://git.io/N3iJvQ
[08:04:02] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[08:04:09] <strcat> no, nevermind
[08:04:32] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[08:04:32] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/Ji0p9g
[08:04:32] <ghrust> 13rust/06auto 1488534ae 15Alex Crichton: Fix compiling empty fmt! strings
[08:04:32] <ghrust> 13rust/06auto 14484466d 15bors: auto merge of #7227 : alexcrichton/rust/issue-7218, r=brson...
[08:04:32] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[08:05:09] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Ping timeout)
[08:06:40] <dbaupp> bors! >:(
[08:06:47] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[08:06:47] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14484466d to 14dc4560d: 02http://git.io/N3iJvQ
[08:06:48] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[08:06:50] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[08:06:50] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/Z8c0ug
[08:06:50] <ghrust> 13rust/06auto 1488534ae 15Alex Crichton: Fix compiling empty fmt! strings
[08:06:50] <ghrust> 13rust/06auto 14fffc87b 15bors: auto merge of #7227 : alexcrichton/rust/issue-7218, r=brson...
[08:06:50] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[08:07:10] <dbaupp> fucking hell... he is broken.
[08:10:27] <aatch> 3 now
[08:10:42] <aatch> strcat, just leave everything alone
[08:11:05] <strcat> aatch: yep I am
[08:11:14] <strcat> cancelling builds doesn't help
[08:11:20] <strcat> it just makes it move onto the next PR and do the same mess
[08:11:31] <aatch> strcat, yeah, makes it worse...
[08:11:35] *** Joins: nef (andor@moz-B1384951.neferty.in)
[08:11:55] *** Quits: brson (brson@72B1AFF8.AD1E507F.3688B332.IP) (Quit: leaving)
[08:15:08] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[08:20:28] *** Quits: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu) (Ping timeout)
[08:21:52] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[08:21:52] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14fffc87b to 14dc4560d: 02http://git.io/N3iJvQ
[08:21:52] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[08:21:55] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[08:21:56] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/cELPZA
[08:21:56] <ghrust> 13rust/06auto 148066dfd 15Philipp BrÃ¼schweiler: syntax::diagnostics: Color the ^~~~ in green for better visibility...
[08:21:56] <ghrust> 13rust/06auto 1424da870 15bors: auto merge of #7230 : Blei/rust/green-squiggle, r=pcwalton...
[08:21:56] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[08:24:37] *** Joins: eatkinson (eatkinson@moz-A7CDB794.dia.static.qwest.net)
[08:25:45] *** Joins: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu)
[08:28:55] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[08:28:55] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1424da870 to 14dc4560d: 02http://git.io/N3iJvQ
[08:28:55] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[08:29:28] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[08:29:28] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/zlvQ7A
[08:29:28] <ghrust> 13rust/06auto 1488534ae 15Alex Crichton: Fix compiling empty fmt! strings
[08:29:28] <ghrust> 13rust/06auto 145efd02e 15bors: auto merge of #7227 : alexcrichton/rust/issue-7218, r=brson...
[08:29:28] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[08:35:31] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.1)
[08:36:33] *** Quits: eatkinson (eatkinson@moz-A7CDB794.dia.static.qwest.net) (Quit: eatkinson)
[08:36:49] *** Quits: sankha93 (Instantbir@7FDB90C9.F989CC7B.62DB355F.IP) (Ping timeout)
[08:37:13] *** Quits: jviereck (Adium@moz-3D1EE18F.dip0.t-ipconnect.de) (Quit: Leaving.)
[08:37:16] *** Quits: bytbox (s@moz-D83E9B31.wireless.umd.edu) (Ping timeout)
[08:37:40] *** Joins: mblbruce (mblbruce@moz-D00392B8.fagotten.org)
[08:40:56] *** Joins: sankha93 (Instantbir@7FDB90C9.F989CC7B.62DB355F.IP)
[08:42:24] *** Joins: berak (chatzilla@4C491ED3.5E545589.16E13E53.IP)
[08:44:08] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[08:52:55] *** Quits: heftig (heftig@moz-DDC44F26.dip0.t-ipconnect.de) (Quit: Quitting)
[08:57:02] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[09:03:07] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[09:05:05] *** Joins: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com)
[09:09:03] *** Quits: sankha93 (Instantbir@7FDB90C9.F989CC7B.62DB355F.IP) (Quit: Instantbird 1.4 -- http://www.instantbird.com)
[09:09:37] <cmr> aatch: did your PR land?
[09:10:00] <aatch> cmr, it did
[09:10:04] <aatch> then bors exploded.
[09:11:19] *** Quits: barosl (barosl@E287D94F.C81E10FB.7544CABF.IP) (Quit: ëžœë¤ì€ ì‡ í‡´í–ˆìŠµë‹ˆë‹¤.)
[09:12:00] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[09:12:37] <cmr> well, that's good at least
[09:12:42] * cmr is writing twir
[09:14:28] *** Joins: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com)
[09:19:35] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[09:20:18] *** Quits: devbug (quassel@moz-E1DE087C.bchsia.telus.net) (Client exited)
[09:20:31] <cmr> I'm actually sad green squiggle didn't land./
[09:22:09] *** Quits: hugod (user@BFEB3FC7.1742D5AE.CD432688.IP) (Connection reset by peer)
[09:23:07] <aatch> cmr, lol. Blame bors
[09:23:35] *** Joins: heftig (heftig@moz-DDC44F26.dip0.t-ipconnect.de)
[09:24:09] *** Quits: goffrie (goffrie@moz-9153684F.dsl.ncf.ca) (Ping timeout)
[09:27:15] *** Quits: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au) (Quit: gavinb)
[09:27:47] *** Joins: hugod (user@BFEB3FC7.1742D5AE.CD432688.IP)
[09:28:05] *** Joins: EXetoC (ex@moz-2DBEB1E4.customer.t3.se)
[09:28:34] *** Quits: vcl (chatzilla@1137E56D.76F9E272.DA40C4B3.IP) (Ping timeout)
[09:29:09] *** Quits: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com) (Ping timeout)
[09:29:32] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[09:29:32] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 145efd02e to 14dc4560d: 02http://git.io/N3iJvQ
[09:29:32] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[09:29:37] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[09:29:37] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/XlGgDw
[09:29:37] <ghrust> 13rust/06auto 148066dfd 15Philipp BrÃ¼schweiler: syntax::diagnostics: Color the ^~~~ in green for better visibility...
[09:29:37] <ghrust> 13rust/06auto 14e9a8c07 15bors: auto merge of #7230 : Blei/rust/green-squiggle, r=pcwalton...
[09:29:37] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[09:29:45] <Blei> again?
[09:30:24] <cmr> What is bors doing :|
[09:30:31] <dbaupp> breakin' shit
[09:30:43] <cmr> those poor buildbots must be dying
[09:30:48] <cmr> from the load, that is
[09:30:52] <dbaupp> https://github.com/mozilla/rust/issues/7293
[09:31:39] <cmr> That's fun
[09:31:43] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[09:32:51] <mblbruce> I have a pointer question, and though I fear the answer may fry my brain, I need to understand this to fix an error in my code... I'm trying to vec::pop(), but rustc disapproves: expected `&mut ~[<V22>]` but found `&mut [~str]`. I'm not even sure I understand exactly what the type it expects actually means. Why should it care that the mutable borrowed pointer is derived from a unique vector? It could just as easily be a managed vector. Confusion 
[09:32:52] <mblbruce> sets in.
[09:32:55] <aatch> There are currently six (6) builds running...
[09:33:25] <cmr> mblbruce: paste the code
[09:33:40] <dbaupp> cmr: fwiw, single case enum = enum Foo { Bar(x,y,z) }
[09:34:19] <dbaupp> (I think sstewartgallus/steven_is_false is saying `enum Foo(x, y, z)` would be the new syntax.)
[09:34:22] <cmr> mblbruce: You're using the code in such a way that it expects some infered type in the vector, but it found a slice of ~str instead
[09:34:30] *** Joins: goffrie (goffrie@moz-9153684F.dsl.ncf.ca)
[09:34:43] <dbaupp> cmr: I don't think that's the problem
[09:35:17] <dbaupp> mblbruce: it's subtle, but the difference is `&mut ~[]` vs `&mut []`
[09:35:27] <aatch> mblbruce, it needs a `&mut ~[T]` because it needs to change the actual vector
[09:35:45] <dbaupp> mblbruce: the former is a mutable pointer to a ~[], the latter is a slice into a vector where the elements can be modified
[09:35:58] <cmr> dbaupp: wouldn't the <V22> be ~str if it knew what it wanted?
[09:36:00] <aatch> whereas a `&mut [T]` is merely a slice into a vector that you can modifiy the elements through
[09:36:05] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[09:36:05] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14e9a8c07 to 14dc4560d: 02http://git.io/N3iJvQ
[09:36:05] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[09:36:05] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[09:36:05] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/OIc1Nw
[09:36:05] <ghrust> 13rust/06auto 1488534ae 15Alex Crichton: Fix compiling empty fmt! strings
[09:36:05] <ghrust> 13rust/06auto 1460767d2 15bors: auto merge of #7227 : alexcrichton/rust/issue-7218, r=brson...
[09:36:06] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[09:36:08] * cmr can never remember the rules for that
[09:36:14] <dbaupp> gah! bors >:(
[09:36:22] <aatch> cmr, that's likely an artifact of the error printer.
[09:36:32] <dbaupp> cmr: yeah, the problem is it can't match <V22> against the ~str
[09:36:33] <aatch> which is why there is a further explanation normally.
[09:36:42] <dbaupp> cmr: because it's missing a layer of pointers
[09:36:46] * mblbruce is trying to wake brain cells that have lain dormant since a haskell class long ago
[09:37:02] <aatch> mblbruce, post the code somewhere.
[09:37:12] <aatch> We can help better that way
[09:37:18] <dbaupp> cmr: it's (&mut (~ [ (~str) ] )) vs (&mut [ (~str) ])
[09:37:32] *** Quits: goffrie (goffrie@moz-9153684F.dsl.ncf.ca) (Ping timeout)
[09:37:38] <aatch> Also, if you're new, we can point out other things you may be doing wrong.
[09:37:55] <dbaupp> cmr: it's trying to match `&mut A` against &mut [B]` and these can't be unified
[09:38:09] <dbaupp> (because &[] slices are different to normal &'s)
[09:38:10] <mblbruce> aatch: I will, thanks. I'll just go figure out the GitHub gist thingy, and paste a link when it's done. Thanks everyone.
[09:38:35] <aatch> mblbruce, and, as a question we will likely ask anyway, what version are you using? More specifically, did you build from a recent master?
[09:39:18] <mblbruce> aatch: Yes, I built it from master yesterday. Had to do it to test and create issue 7276.
[09:39:36] <aatch> mblbruce, cool, just making sure.
[09:39:40] <dbaupp> aatch: have you (or anyone) touched master? because bors is now complaining about `No active merge of candidate 88534ae found, likely manual push to master`
[09:39:48] <aatch> dbaupp, nope.
[09:39:49] <dbaupp> aatch: (I'm guessing it's just general brokenness though)
[09:40:02] <dbaupp> aatch: ok, cool
[09:40:09] <aatch> Last time I touched master was when I did the snapshot.
[09:41:04] <aatch> dbaupp, most recent commit to the master branch is from bors
[09:42:45] <dbaupp> aatch: bors is stupid :/
[09:42:55] <aatch> dbaupp, agreed
[09:43:21] <dbaupp> aatch: (that said, it's really nice when it works...)
[09:43:21] <aatch> why is it even trying to merge to master??
[09:44:30] <dbaupp> it's not, it's rebasing/merging on top of it
[09:44:36] <dbaupp> (I think)
[09:44:37] *** Joins: spider-mario (spidermari@AC277065.4C6652EF.EC2613E4.IP)
[09:45:15] <dbaupp> hmm, it's probably because bors is detecting the auto branch is in the "wrong" place
[09:46:02] <aatch> acrichto, I'm not sure your PR will still compile on the latest master. I made quite a few changes to trans.
[09:46:38] <aatch> I may be wrong though.
[09:48:00] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[09:48:13] *** Parts: berak (chatzilla@4C491ED3.5E545589.16E13E53.IP) ()
[09:49:22] *** Quits: spider-mario (spidermari@AC277065.4C6652EF.EC2613E4.IP) (Ping timeout)
[09:52:04] *** Joins: spider-mario (spidermari@AC277065.4C6652EF.EC2613E4.IP)
[09:54:57] *** Joins: goffrie (goffrie@moz-9153684F.dsl.ncf.ca)
[09:55:20] *** Quits: spider-mario (spidermari@AC277065.4C6652EF.EC2613E4.IP) (Ping timeout)
[09:56:45] *** Joins: nano (nano@moz-972880B.superkabel.de)
[09:57:16] *** Joins: spider-mario (spidermari@AC277065.4C6652EF.EC2613E4.IP)
[09:58:02] *** Quits: spider-mario (spidermari@AC277065.4C6652EF.EC2613E4.IP) (Input/output error)
[09:58:03] <mblbruce> So I made a partial gist, since the entire thing involves a decent amount of code and a number of files. There's a bunch of fail()s in there that will be return option/result later, etcâ€¦ The usual disclaimers for crappy playground codeâ€¦ https://gist.github.com/mblbruce/5840213
[09:58:58] <aatch> mblbruce, ah, ok.
[09:59:26] <cmr> mblbruce: what are you writing btw?
[09:59:52] <aatch> So, in Rust, strings and vectors are treated a little differently to other types.
[10:00:16] <mblbruce> cmr: It's just a simple financial bookkeeping/simulation tool I use that I'm porting from Go. Nothing cool, unfortunately.
[10:00:35] *** Joins: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com)
[10:00:47] <aatch> as such, a ~str or a ~[] is an owned string or vector, where a &str or a &[] is a _slice_ into a string or vector
[10:00:57] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[10:01:43] <aatch> so you can have, ~[1,2,3,4,5], and a slice into it &[2,3,4]. The slice is over the same block of memory
[10:02:25] <aatch> but you can't change the vector itself through a slice.
[10:02:45] <aatch> because that information is stored in a place that the slice can't get to.
[10:03:44] <aatch> So if you want to change the vector itself, you need it to be a &mut ~[~str]
[10:03:44] <mblbruce> aatch: Ok, that makes perfect sense. So how do I pass a borrowed ptr to the original vector instead of slicing it?
[10:04:18] <cmr> mblbruce: & ~[]
[10:04:23] <aatch> rusti: let a = ~[1,2,3]; fmt!("%?", &mut a)
[10:04:26] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/XHjO
[10:04:38] <aatch> rusti: let mut a = ~[1,2,3]; fmt!("%?", &mut a)
[10:04:40] -rusti- ~"&mut ~[1, 2, 3]"
[10:05:05] <aatch> as opposed to
[10:05:54] <aatch> rusti: let mut a = ~[1,2,3]; let b : &mut [int] = a; fmt!("%?", b)
[10:05:54] -rusti- ~"&[mut 1, mut 2, mut 3]"
[10:06:11] <aatch> heh, wasn't quite expecting that.
[10:06:51] <Blei> err, that's a bug
[10:06:58] <dbaupp> yay, deprecated syntax!
[10:07:19] <aatch> lol, nobody bothered to update that part of the repr?
[10:07:47] <cmr> aatch: make sure you add a test for that :p
[10:08:14] <aatch> cmr, I am taking a break from rustc for a bit...
[10:08:20] <aatch> before trans eats me
[10:08:28] <cmr> omnomnom
[10:08:49] <cmr> If all it takes is a human sacrifice to get trans actually look like rust code, I'll gladly throw you into the volcano.
[10:08:50] <kimundi> mblbruce, aatch: Well you can change the elements reachable through a &mut [], but not the vector itself, so no push/pop etc
[10:08:55] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[10:08:55] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1460767d2 to 14dc4560d: 02http://git.io/N3iJvQ
[10:08:55] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[10:08:58] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[10:08:58] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/C4UqhA
[10:08:58] <ghrust> 13rust/06auto 148066dfd 15Philipp BrÃ¼schweiler: syntax::diagnostics: Color the ^~~~ in green for better visibility...
[10:08:58] <ghrust> 13rust/06auto 14bc3fcee 15bors: auto merge of #7230 : Blei/rust/green-squiggle, r=pcwalton...
[10:08:58] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[10:09:13] <Blei> again?!
[10:09:21] <aatch> Blei, yep
[10:09:21] <Blei> bors: third times the charm
[10:09:35] <aatch> it might even push another PR, just for kicks
[10:10:16] <aatch> There are currently 8 builds going...
[10:11:18] <dbaupp> Blei: https://github.com/mozilla/rust/issues/7293
[10:11:24] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[10:11:25] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14bc3fcee to 14dc4560d: 02http://git.io/N3iJvQ
[10:11:25] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[10:11:27] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[10:11:27] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/PgvtIQ
[10:11:27] <ghrust> 13rust/06auto 1488534ae 15Alex Crichton: Fix compiling empty fmt! strings
[10:11:27] <ghrust> 13rust/06auto 1460888c5 15bors: auto merge of #7227 : alexcrichton/rust/issue-7218, r=brson...
[10:11:27] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[10:11:47] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[10:12:04] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[10:12:12] <mblbruce> My original declaration of the vector is "let mut tokens: ~[~str] = ~[];" and then I just pass it as "tokens", assuming that it will be automagically borrowed. So, instead of the current function argument type of "&mut [~str]" it should be "&mut ~[~str]", and I should pass the variable not as "tokens" but asâ€¦?
[10:12:35] <dbaupp> mblbruce: '&mut tokens'
[10:12:44] <aatch> instead of tokens, pass `&mut tokens`
[10:12:59] <aatch> mblbruce, done much C/C++?
[10:13:51] <mblbruce> aatch: Not that much C++ as I'm not a big fan, but quite a bit of C. Probably not the most esoteric parts of it, though.
[10:14:54] <cmr> I'm sad.
[10:15:01] <cmr> The "breaking changes" this week is "breaking change"
[10:15:05] <dbaupp> cmr: because bors?
[10:15:10] <dbaupp> oh
[10:15:14] <dbaupp> which?
[10:15:15] <cmr> And only 2 PRs in "notable additions, bugfixes, and cleanups"
[10:15:21] <cmr> dbaupp: vector iter work
[10:15:46] <dbaupp> there was a snapshot!
[10:15:52] <dbaupp> and, err, bors is broken?
[10:15:53] <strcat> well there were like 3 days without commits
[10:16:00] <dbaupp> (that's two things.)
[10:16:02] <aatch> mblbruce, ok, well '&' is similar to the addr-of operator in C
[10:16:30] <cmr> strcat: I know, and it's sad :(
[10:16:44] <dbaupp> aatch: ("is identical", ignoring mutability?)
[10:17:02] <aatch> cmr, what are the two PRs?
[10:17:13] <cmr> https://github.com/mozilla/rust/pull/7259 and https://github.com/mozilla/rust/pull/7182
[10:17:28] <aatch> Because default methods landed
[10:17:41] <cmr> What was the PR that did that?
[10:17:49] <cmr> I don't see it in the list of PRs merged this week...
[10:17:59] <cmr> Then again, I don't see the trans refactor in it either
[10:18:28] <aatch> https://github.com/mozilla/rust/pull/7203
[10:18:38] <cmr> Debuginfo also landed
[10:18:41] <dbaupp> cmr: github seems to list half of bors' merges as "closed", and half as "merged"
[10:18:53] <dbaupp> github is silly
[10:18:57] <cmr> dbaupp: that's really obnoxious
[10:19:03] <cmr> That means all of my numbers are probably off
[10:19:09] <dbaupp> yup :(
[10:19:18] <dbaupp> (you could just grep the change log?)
[10:19:27] <cmr> Yeah... that's what I'm going to start doing
[10:19:31] * cmr not happy
[10:21:00] *** Joins: doener (doener@moz-121949B3.unitymediagroup.de)
[10:21:02] <dbaupp> cmr: git log --author 'bors'  --pretty=oneline 'master@{1 week ago}'..master | wc -l => 45
[10:21:39] <Blei> heh, there was a bug in my intrinsic patch, it only raised an assertion when rebased on top of the trans refactoring though
[10:21:46] <Blei> mysterious
[10:22:05] <aatch> Blei, really? Weird. Actual bug or merge fallout?
[10:22:11] <mblbruce> Thanks everyone. Your proposed change pleases rustc wrt that particular error, so I'll get on to the next one.
[10:22:23] <Blei> aatch: actual bug, i think
[10:22:30] <Blei> maybe it got pointercasted away before
[10:22:57] <aatch> Blei, oh yeah, I removed a few unneccesary pointer casts
[10:23:16] <Blei> great, that should help compile times :)
[10:23:29] <Blei> cmr: did you bench aatch's trans refactoring? might be interesting
[10:23:40] <cmr> Blei: I didn't because he said it wouldn't change much perf wise
[10:23:57] <Blei> yeah, it probably wouldn't
[10:24:09] <cmr> I can bench it if you want, I have no problem with that
[10:24:28] <Blei> not sure if it's worth it, i was just curious
[10:24:32] <aatch> cmr, oh, actually, I've made more changes that might since then. I'm not sure how big it would be.
[10:25:00] <cmr> Bench it is
[10:25:14] <cmr> @mention me in any PRs you want benched and I will.
[10:25:33] <cmr> I'm still ironing out the bugs in my script, otherwise I'd run a bot over all the PRs
[10:28:28] *** Quits: roo (Mibbit@moz-97A935F1.dynamic.ip.windstream.net) (Quit: http://www.mibbit.com ajax IRC Client)
[10:28:36] *** Joins: rubber-duck (rubber-duc@moz-CBF18172.dsl.iskon.hr)
[10:30:05] <strcat> did bors decide to stop his rampage?
[10:30:13] <aatch> strcat, for now
[10:30:21] <aatch> not sure if he's working or not though.
[10:30:59] <dbaupp> strcat: he seems to go quiet for a while and then suddenly start a few more builds :(
[10:31:44] <dbaupp> (also, bors' status page lists 2 PRs as pending, so it's probably not several independent instances.)
[10:32:25] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[10:32:28] <aatch> heh, 'unpop'
[10:33:07] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.1)
[10:36:31] <rubber-duck> anyone knows what "is_XID_start" and "is_XID_continue" in std::char are for ? they are undocumented
[10:36:49] <aatch> rubber-duck, they're unicode character classes
[10:37:14] <aatch> XID_start means it can start a word, XID_continue means it can continue it.
[10:37:16] <cmr> http://www.unicode.org/reports/tr31/ I think
[10:37:21] <aatch> They are mostly there for the parser
[10:37:21] <cmr> aatch: Identifier, actually
[10:37:23] <cmr> not word
[10:37:33] <aatch> cmr, eh, close enough
[10:38:00] <aatch> Ugh, I found a bug in rustc.
[10:38:01] <doener> aatch: sweet, your refactoring landed :-)
[10:38:08] <aatch> doener, it did!
[10:38:14] *** Joins: pyrac (pyrac@moz-9180E00E.w86-201.abo.wanadoo.fr)
[10:38:15] <dbaupp> aatch: just one bug?
[10:38:27] <aatch> dbaupp, one I didn't know about.
[10:38:31] <dbaupp> heh ;P
[10:39:20] <aatch> 'index out of bounds: the len is 1 but the index is 3', /home/james/projects/rust/compiler/src/librustc/middle/subst.rs:58
[10:39:31] <cmr> rubber-duck: if you want to send a PR with docs that'd be cool
[10:39:36] <kemurphy> is there any way to force a static item into .data instead of .rodata?
[10:39:45] <aatch> kemurphy, not yet
[10:40:02] <dbaupp> aatch: I may've seen that one just recently... is it default methods?
[10:40:03] <aatch> acrichto, has a PR for mutable static items open
[10:40:05] <cmr> `mut static`?
[10:40:17] <cmr> yuck yuck yuck...
[10:40:32] <kemurphy> "mut static" soungs gross... "unsafe static" perhaps?
[10:40:33] <dbaupp> cmr: (isn't it `static mut`?)
[10:40:37] <aatch> cmr, no... static mut of course
[10:40:39] <Blei> cmr: a previous proposal called it const mut
[10:40:41] <cmr> dbaupp: I don't know
[10:40:49] <kemurphy> sounds*
[10:40:49] <cmr> It's the concept I'm against, not the syntax :p
[10:40:58] *** Joins: vcl (chatzilla@1137E56D.76F9E272.DA40C4B3.IP)
[10:41:12] <cmr> I recognize its utility, but still... yuck
[10:41:12] <kemurphy> cmr: presumably you still can't mutate it from rust itself... can you?
[10:41:15] <Blei> cmr: think about it as having a static address
[10:41:23] <aatch> https://github.com/mozilla/rust/pull/7291
[10:41:24] <Blei> then it works pretty well
[10:41:27] <dbaupp> cmr: it allows us to implement more stuff in pure Rust
[10:41:30] <aatch> There ^^^^
[10:41:33] <dbaupp> cmr: which is always a good thing
[10:41:36] <benh> How do I avoid " error: multiple matching crates for `syntax`" when updating rustc without make clean inbetween?
[10:41:51] <aatch> benh, by running a make clean inbetween?
[10:41:53] <dbaupp> benh: go into the directory and delete the older one
[10:41:59] <aatch> Or that
[10:42:04] <cmr> dbaupp: as long as it requires an unsafe block it's ok I guess
[10:42:10] <aatch> cmr, it does
[10:42:10] <dbaupp> cmr: yeah, it does
[10:42:12] <benh> It didn't use to need me to do that :(
[10:42:22] <aatch> benh, you don't always need to
[10:42:32] <aatch> but sometimes there are changes that require it.
[10:42:50] <benh> Are there more of these changes recently...?
[10:42:58] <aatch> benh, probably
[10:43:09] <aatch> I can't quite remember how it works it out.
[10:43:42] <mblbruce> From looking at the implementation of slice_chars(), it would seem that is is zero-indexed, begin-inclusive and end-non-inclusive. Is that correct?
[10:44:02] <cmr> mblbruce: 'exclusive', and yes, all slices are I believe.
[10:44:09] <dbaupp> mblbruce: yes
[10:44:34] <mblbruce> cmr, dbaupp: Ok, thanks.
[10:44:43] <aatch> dbaupp, you were right, default methods
[10:44:53] <aatch> sully, default methods are still broken!
[10:45:02] <dbaupp> aatch: "cool" I guess
[10:45:04] *** Joins: BitPuffin (quassel@moz-49828767.cust.tele2.se)
[10:45:11] <dbaupp> aatch: (they're less broken than they were before)
[10:45:27] <cmr> A lot of good stuff actually landed this week
[10:45:34] <dbaupp> aatch: do you have a small testcase?
[10:45:42] <aatch> dbaupp, actually yeah.
[10:45:45] * cmr sends bug report to github
[10:45:48] <aatch> I'll try to get it smaller
[10:45:57] <dbaupp> ok, i leave you to file that one
[10:46:00] <aatch> but it's in a file < 100 lines
[10:46:03] <benh> oh right, that pesky "actually making releases" thing
[10:46:12] * dbaupp has 2 other default method bugs
[10:50:14] *** Joins: nano (nano@moz-972880B.superkabel.de)
[10:50:52] *** Joins: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP)
[10:51:24] <cmr> I'm continually amazed how well llvm optimizes our terrible IR
[10:55:07] <aatch> Ok, so it happens if you mix default methods and, not-default methods
[10:55:25] <aatch> but you have to have generics
[10:56:43] <dbaupp> I've got `method not found in AST map?!` by calling a default method in some circumstances
[10:56:53] <dbaupp> I can't narrow them down though. :(
[10:58:01] <aatch> Well I got this down to 7 SLOC
[10:58:06] <cmr> doener: it seems you are the hero of trans performance
[11:00:32] <doener> aatch: the largest change in that PR was probably the move to methods instead of functions, right?
[11:00:33] <aatch> https://github.com/mozilla/rust/issues/7295
[11:00:41] <aatch> doener, yep
[11:01:16] <aatch> Oh, and implementing the rest of the atomic intrinsics
[11:01:27] *** Joins: roo (Mibbit@moz-97A935F1.dynamic.ip.windstream.net)
[11:02:09] <kemurphy> what are default methods exactly?
[11:02:13] * dbaupp thinks atomics + static mut is perfect
[11:02:26] <cmr> kemurphy: methods attached to a trait, rather than a trait impl, that things implementing that trait get for free.
[11:02:39] <aatch> kemurphy, look at the link I posted, the second method is a default method
[11:03:01] <kemurphy> ah, cute
[11:03:11] <kemurphy> kinda line extension methods in c#, it seems
[11:03:31] <kemurphy> like*
[11:04:20] <doener> aatch: ok, so we really need to get the trans (and resulting code) for methods fixed, there seems to be a bump in compile times and a drop in performance. I guess it's because of https://github.com/mozilla/rust/issues/4402
[11:04:52] <cmr> doener: I thought someone said last night they were almost done fixing that. Maybe Blei?
[11:05:49] <aatch> doener, I do vaguely remember a PR to that nature, yes
[11:06:49] <Blei> what about methods is broken? only compile time/performance or other stuff?
[11:07:44] <aatch> Blei, only performance, theres an extra level of indirection apparently
[11:07:51] <doener> Blei: extra level of indirection, so &self for a struct Foo would pass a pointer to a pointer, while a function with a &Foo argument only passes a simple pointer
[11:08:09] <cmr> All `self` references also involve a pointer cast, but that's just a codegen thing I think
[11:08:18] <Blei> doener: oh, that's bad
[11:08:57] <aatch> doener, that said, I didn't introduce too many actual methods, so it shouldn't be that bad
[11:09:05] <aatch> Most of them were static methods.
[11:10:15] <cmr> Blei: want me to re-bench the intrinsics patch?
[11:10:40] <doener> aatch: ok
[11:10:59] <Blei> cmr: it's only a rebase, it shouldn't have changed the performance. probably
[11:11:03] <dbaupp> aatch: I would imagine .ptr/.ptr_to get called a lot?
[11:11:13] <aatch> doener, that said, I did make ptr_to() a method
[11:11:22] <cmr> Blei: there was one commit that didn't get benched, removing that glue from rt, what about that one?
[11:11:22] <aatch> so that probably has some impact
[11:11:24] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[11:11:24] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1460888c5 to 14dc4560d: 02http://git.io/N3iJvQ
[11:11:24] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[11:11:28] <doener> yeah, that's the one I was  thinking about
[11:11:30] <aatch> BORS
[11:11:34] <cmr> bors why :(
[11:11:36] <dbaupp> silly bors! :(
[11:11:56] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[11:11:56] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/9gl8uQ
[11:11:56] <ghrust> 13rust/06auto 148066dfd 15Philipp BrÃ¼schweiler: syntax::diagnostics: Color the ^~~~ in green for better visibility...
[11:11:56] <ghrust> 13rust/06auto 1416b3f39 15bors: auto merge of #7230 : Blei/rust/green-squiggle, r=pcwalton...
[11:11:57] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[11:12:27] <indutny> oh
[11:12:33] <indutny> just noticed bug in my pull request :P
[11:12:35] <cmr> On the plus side, this is definitely exercising all of the build slaves, there shouldn't be out of date llvm or anything after this :p
[11:12:39] <Blei> cmr: it was only used in extra::arena and std::gc, both of which aren't really used anywhere afaict
[11:12:40] <indutny> mmap should return *mut c_void
[11:12:43] <indutny> otherwise its not usable
[11:12:47] <indutny> cmr: want me to open another PR?
[11:12:54] <cmr> indutny: No, just push a commit to it
[11:12:58] <doener> cmr: hm, can't find any reference to 4402 in the irc logs. sully said something about the casts. I might have mentioned that I have been working on it, but not yesterday, I think
[11:13:03] <indutny> cmr: ok, will do
[11:13:36] *** Joins: jviereck (Adium@moz-3D1EE18F.dip0.t-ipconnect.de)
[11:13:43] <cmr> 155663:2013-06-21 21:16:22sullyI think I can get rid of the cast we generate for every single mention of self
[11:13:46] <cmr> doener: is what it was
[11:14:24] <doener> ok
[11:14:53] * dbaupp wonders if mozilla is paying for this EC2 cpu time
[11:15:21] *** Quits: jviereck (Adium@moz-3D1EE18F.dip0.t-ipconnect.de) (Quit: Leaving.)
[11:16:42] <cmr> That's interesting
[11:16:51] <cmr> The performance characteristics of rustc are changing, memory-wise
[11:17:06] <cmr> http://i.imgur.com/6LPrikf.png
[11:17:33] <indutny> by a couple of mbs
[11:17:36] <indutny> it seems
[11:17:36] <aatch> Odd
[11:17:45] <cmr> indutny: not the actual difference in the bench, the shape of the graph
[11:17:48] <cmr> llvm used to be a flat line
[11:17:49] <doener> for which PR is that?
[11:17:52] <indutny> ah
[11:17:53] <cmr> https://github.com/mozilla/rust/pull/7202
[11:18:14] <dbaupp> cmr: that's a nice graphing script you've got there ;P
[11:18:18] <cmr> dbaupp: :p
[11:18:24] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[11:18:24] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1416b3f39 to 14dc4560d: 02http://git.io/N3iJvQ
[11:18:24] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[11:18:27] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[11:18:27] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/jygMfw
[11:18:27] <ghrust> 13rust/06auto 1488534ae 15Alex Crichton: Fix compiling empty fmt! strings
[11:18:27] <ghrust> 13rust/06auto 1404a98ce 15bors: auto merge of #7227 : alexcrichton/rust/issue-7218, r=brson...
[11:18:28] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[11:18:39] * dbaupp sighs
[11:18:40] <aatch> why bors, why?!
[11:18:44] <cmr> dbaupp: the R script is slower than the python one using matplotlib it feels like... but I don't care, it works well :)
[11:18:47] <dbaupp> what timezone in graydon in?
[11:18:48] <aatch> Why do you hate us.
[11:18:50] <doener> cmr: ah, the change is not in that graph, but when compared to previous graphs, right?
[11:18:55] <cmr> doener: yes
[11:19:01] *** Joins: MaikKlein (maik@moz-E6D51931.dip0.t-ipconnect.de)
[11:19:03] <dbaupp> cmr: yeah, probably is
[11:19:16] <Blei> cmr: it's the trans refactoring! maybe
[11:19:25] <cmr> Blei: it was before the trans refactoring wasn't it?
[11:19:31] <cmr> Blei: I'm just about to bench that one
[11:19:36] <Blei> haha, oops
[11:19:51] <cmr> Actually it was after trans refactor pt 1, but I think all the graphs I've been making are.
[11:20:00] <indutny>  uint (64 bits) to &'static fn() (128 bits)
[11:20:03] <indutny> err
[11:20:07] <dbaupp> hm, graydon's in vancover, right?
[11:20:10] <indutny>  transmute called on types with different sizes: uint (64 bits) to &'static fn() (128 bits)
[11:20:13] <dbaupp> indutny: transmuting?
[11:20:19] <indutny> why is fn 128 bit?
[11:20:20] <aatch> indutny, yes
[11:20:20] <indutny> ah
[11:20:39] <dbaupp> indutny: &fn has an function pointer and an environment pointer
[11:20:45] <indutny> oh god...
[11:20:46] <cmr> (it's a closure)
[11:20:51] <indutny> ok, how can I cast memory to function?
[11:21:05] <dbaupp> cast to `extern "Rust" fn`
[11:21:13] <indutny> what about args?
[11:21:14] <dbaupp> (it's a plain function, without the env pointer)
[11:21:15] <aatch> if you want a normal function pointer, you can transmute to extern <abi> fn
[11:21:16] <indutny> and return type
[11:21:22] <aatch> indutny, all in the signature
[11:21:24] <indutny> &extern "Rust" fn(uint) -> uint
[11:21:26] <indutny> like this?
[11:21:29] <dbaupp> yes
[11:21:31] <aatch> indutny, sans '&'
[11:21:33] <cmr> Not the &
[11:21:40] <indutny> yikes
[11:21:40] <dbaupp> aatch: really?
[11:21:41] <indutny> works!
[11:21:42] <indutny> :)
[11:21:43] <indutny> thank you
[11:21:46] <aatch> dbaupp, yep.
[11:21:57] <aatch> It's what's in the start lang item now
[11:21:57] * dbaupp possibly has bugs
[11:22:05] *** Quits: MaikKlein (maik@moz-E6D51931.dip0.t-ipconnect.de) (Ping timeout)
[11:22:19] <indutny> well, not really
[11:22:20] <indutny> it just casts :P
[11:22:28] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[11:25:08] *** Quits: roo (Mibbit@moz-97A935F1.dynamic.ip.windstream.net) (Quit: http://www.mibbit.com ajax IRC Client)
[11:25:15] <Blei> cmr: that commit was from before turning jemalloc of again
[11:25:21] <Blei> might be the difference
[11:25:26] <cmr> Ahhhh yeah that would do it.
[11:25:51] <benh> (... but rustc compiling a bunch faster (almost 25%?) is great :)
[11:26:25] <aatch> benh, is that from start to end?
[11:26:36] <cmr> aatch: I'm not benching trans refactor pt 1, is that ok?
[11:26:42] <doener> aatch: interesting, the bitcode with your patch is smaller, so with '--passes ""' it's actually faster.
[11:26:56] <doener> for both, libstd and librustc
[11:26:58] <aatch> doener, interesting.
[11:27:17] <benh> aatch: right after a make-clean, doesn't include llvm and the configurey bits
[11:27:28] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[11:27:32] <aatch> benh, ok, that's probably due to the new snapshot
[11:27:42] <benh> ah
[11:28:07] <aatch> since now the first stage isn't being run done with the slow old snapshot. Which also produced a slow stage1 compiler
[11:28:31] <aatch> ~10hrs of babysitting the buildbots for that snapshot...
[11:29:31] <indutny> the only thing I dislike about recent mman bindings
[11:29:36] <indutny> is that MAP_FAILED is a c_int
[11:29:39] <indutny> and not c_void*
[11:29:50] <indutny> but I've no idea on how initialize static c_void* variable as -1
[11:30:10] *** Joins: roo (Mibbit@moz-1648A2AF.dynamic.ip.windstream.net)
[11:30:17] <indutny> any thoughts?
[11:30:28] <dbaupp> indutny: does `(-1) as *c_void` work?
[11:30:29] <Blei> rust-buildbot: static a: *std::libc::c_void = -1 as *std::libc::c_void;
[11:30:33] <indutny> oooh
[11:30:35] <indutny> as
[11:30:36] <cmr> rusti: use std::libc::c_void; static x: *c_void = -1 as *c_void
[11:30:37] <aatch> indutny, static MAP_FAILED : *c_void = -1 as *c_void;
[11:30:37] -rusti- <anon>:10:4: 10:5 error: expected `;` but found `}`
[11:30:37] -rusti- <anon>:10     };
[11:30:37] -rusti-               ^
[11:30:37] -rusti- application terminated with error code 101
[11:30:51] <cmr> rusti: use std::libc::c_void; static x: *c_void = -1 as *c_voidl
[11:30:52] -rusti- <anon>:10:4: 10:5 error: expected `;` but found `}`
[11:30:52] -rusti- <anon>:10     };
[11:30:52] <dbaupp> rusti: static a: *std::libc::c_void = -1 as *std::libc::c_void; a
[11:30:52] -rusti-               ^
[11:30:52] -rusti- application terminated with error code 101
[11:30:53] <cmr> rusti: use std::libc::c_void; static x: *c_void = -1 as *c_void;
[11:30:53] -rusti- 18446744073709551615
[11:30:54] -rusti- ()
[11:31:03] <dbaupp> huh?
[11:31:11] <cmr> That was me, sorry
[11:31:39] <dbaupp> why is it looking for a ;?
[11:31:49] <dbaupp> oh
[11:31:50] <dbaupp> I see
[11:31:52] <aatch> doener, do you know what the box fields are for?
[11:31:53] <cmr> It isn't, I left mine out of the static decl
[11:32:07] <dbaupp> cmr: yeah, I've worked it out now :)
[11:32:19] <indutny> yikes
[11:32:20] <doener> aatch: which ones?
[11:32:22] <indutny> it works :)
[11:32:35] <aatch> in the box header, there's refcount and two others
[11:33:07] <aatch> refcount, typedesc, and two others.
[11:33:33] <dbaupp> aatch: 'prev' and 'next' ?
[11:33:42] <aatch> Oh yeah.
[11:34:18] *** Quits: BitPuffin (quassel@moz-49828767.cust.tele2.se) (Ping timeout)
[11:34:55] <doener> aatch: something about memory management for @boxes
[11:35:34] <Blei> they form a linked list of all allocations of a task, used by the box annihilator to clean up cycles when a task finishes
[11:35:44] <Blei> *managed allocations
[11:35:47] *** Quits: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk) (Ping timeout)
[11:35:49] <aatch> Blei, ahh, thank you
[11:36:04] <cmr> graydon said they are unneeded when the GC lands, but since that isn't going to happen soon, cleaning up or removing the headers would be nice
[11:38:02] <doener> ah, the size difference might be due to the removed non_gc_box_cast (addrspace cast-away)
[11:38:24] <aatch> doener, really? I didn't expect it to make that much difference
[11:38:42] <doener> there were tons of those IIRC
[11:38:49] <aatch> Well that's nice then
[11:39:11] *** Quits: Blei (philipp@moz-650B9C6A.cust.bluewin.ch) (Quit: WeeChat 0.4.1)
[11:42:03] <dbaupp> cmr: it seems strange that https://github.com/mozilla/rust/pull/7202#issuecomment-19855115 seems to have had no memory effect?
[11:42:34] <cmr> dbaupp: yeah
[11:43:52] <cmr> dbaupp: commented on the PR with a thought about that
[11:44:35] <doener> it's the spikey thing slightly over 500MB around 10s that's gone
[11:44:40] <doener> that's were the borrowck happens
[11:44:46] <doener> s/were/where/
[11:45:08] <cmr> yeah, but ... that memory usage is nothing compared to the rest
[11:45:17] <cmr> it shouldn't cause pcwalton to swap
[11:46:04] <doener> I didn't expect it to help much. The largest allocs there were around 6MB each, three of them per nesting level, and most allocations were a lot smaller
[11:46:33] <dbaupp> cmr: it might be larger on a code base that uses regions more
[11:46:36] * dbaupp doesn't know
[11:46:48] <cmr> Oh, maybe servo? servo doesn't use a recent rust though
[11:46:59] <doener> yeah, or more macros or whatever
[11:47:47] <aatch> doener, what would be preventing getting rid of the environment pointer in functions with immediate returns?
[11:49:16] <doener> aatch: I don't know. Does the return value type make a difference there?
[11:49:41] <cmr> dbaupp: aatch: doener: https://gist.github.com/cmr/add7860b9819508d0840
[11:49:47] <cmr> Did I miss anything important?
[11:50:44] <dbaupp> cmr: default methods are significantly less broken, not exactly working
[11:50:56] <dbaupp> cmr: (they don't seem to play well with generics)
[11:50:58] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[11:50:58] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1404a98ce to 14dc4560d: 02http://git.io/N3iJvQ
[11:50:58] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[11:51:00] <cmr> dbaupp: they're enabled by default now, but I'll ad the caveat
[11:51:01] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[11:51:01] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[11:51:01] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/oRHJDw
[11:51:01] <ghrust> 13rust/06auto 148066dfd 15Philipp BrÃ¼schweiler: syntax::diagnostics: Color the ^~~~ in green for better visibility...
[11:51:01] <ghrust> 13rust/06auto 14bc7937a 15bors: auto merge of #7230 : Blei/rust/green-squiggle, r=pcwalton...
[11:51:02] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[11:51:12] <dbaupp> cmr: no they're not
[11:51:17] <cmr> dbaupp: they aren't?
[11:51:20] <dbaupp> cmr: still need #[allow(default_methods)]
[11:51:25] <cmr> ah
[11:51:29] <doener> cmr: 7154 was already in last weeks twir
[11:51:50] <cmr> oops, that's embarassing
[11:52:05] <dbaupp> doener: no! you deserve to be mentioned twice :D
[11:52:14] <cmr> (thrice)
[11:52:29] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[11:52:29] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14bc7937a to 14dc4560d: 02http://git.io/N3iJvQ
[11:52:29] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[11:52:31] <aatch> man, reading the IR after that refactoring is soo much nicer
[11:52:31] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[11:52:31] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/cqXJUQ
[11:52:31] <ghrust> 13rust/06auto 1488534ae 15Alex Crichton: Fix compiling empty fmt! strings
[11:52:31] <ghrust> 13rust/06auto 14de7dc81 15bors: auto merge of #7227 : alexcrichton/rust/issue-7218, r=brson...
[11:52:32] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[11:52:51] *** Joins: cr (anonymous@moz-21AE2A3.dip0.t-ipconnect.de)
[11:53:09] <dbaupp> cmr: (also, the .each removal hasn't actually landed... that's what broke bors :( )
[11:53:10] <aatch> We are getting closer to sane IR!
[11:53:12] *** Joins: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk)
[11:53:18] <dbaupp> cmr: (.eachi is)
[11:53:29] <cmr> dbaupp: oh, ok
[11:53:30] <dbaupp> aatch: the landed refactoring? or a new one?
[11:53:36] <aatch> dbaupp, landed one
[11:53:38] <dbaupp> cmr: (that is, eachi has been removed.)
[11:53:43] <dbaupp> aatch: cool :)
[11:53:44] <aatch> I made some tweaks to the IR output
[11:54:09] <dbaupp> cmr: however, it'd be nice to say that .each will be disappearing, and that it would make strcat's life much easier to not add more instances of it
[11:54:10] <benh> What's the iteratorish way to say eachi?
[11:54:24] <aatch> like making local structs and enums be named in a format that doesn't cause LLVM to put double quotes around it.
[11:54:32] <cmr> benh: for foo.iter().enumerate().advance |(i, elem)| { ... }
[11:54:39] <cmr> benh: see twir when I publish it in a few minutes
[11:54:56] <dbaupp> aatch: that seems like a sensible one to do :)
[11:55:13] <aatch> Basically, if you have struct Foo, the type in LLVM is %struct.Foo
[11:55:21] *** Joins: MaikKlein (maik@moz-E6D51931.dip0.t-ipconnect.de)
[11:55:24] <benh> ... .eachi was shorter
[11:55:35] <bjz_> dbaupp: will there be an eachi shortcut in the future?
[11:55:45] <dbaupp> cmr: fwiw it'd be nice if the list of links at the bottom had their titles rather than just the URLs (especially the mailing list ones)
[11:55:46] <bjz_> dbaupp: that uses iterators?
[11:55:49] <cmr> benh: it will be for vec.enumerate() |(i, elem)| { ..} with the new syntax
[11:55:56] <dbaupp> benh, bjz_: hopefully ^
[11:56:04] <cmr> benh: or something close to it
[11:56:08] <bjz_> each/eachi is very nice
[11:56:14] <dbaupp> the .advance will be removed
[11:56:22] <bjz_> cool
[11:56:36] <bjz_> that's good
[11:56:43] <aatch> Also, fewer bit casts, no addrspaces
[11:56:57] <bjz_> dbaupp: and the iter too, with default methods right?
[11:56:58] <dbaupp> (and, there's no particular reason .each/.eachi couldn't be added back in, using external iterators, but we're trying to get the str and vec apis as small as possible at the moment)
[11:57:17] <dbaupp> bjz_: strcat seems to think it's possible, I don't really understand how
[11:57:25] <dbaupp> bjz_: (I hope so, though)
[11:57:48] <bjz_> dbaupp: each/map/zip are very pretty, would be a shame to lose them, but I understand you need an intermediate form
[11:58:05] <aatch> doener, ok, so I'm pretty sure the environment pointer is useless
[11:58:36] <aatch> in methods
[11:58:45] <cmr> TwiR published, waiting for github pages to update...
[11:58:47] <dbaupp> bjz_: yeah, there was a huge proliferation of redundant fns/methods in str/vec, so strcat and I will be/have been quite ruthless in removals
[11:59:03] <bjz_> yeah of course
[11:59:06] <cmr> dbaupp: I'll update with page titles later, thanks for the suggestion
[11:59:07] <bjz_> it was crazy :P
[11:59:25] <bjz_> (*is* crazy)
[11:59:56] <dbaupp> bjz_: yeah, there were 5 ways of going str -> [u8]
[12:00:06] <dbaupp> bjz_: and the documentation for 3 of them was wrong :/
[12:00:07] <bjz_> 8[
[12:00:22] <dbaupp> cmr: cool :)
[12:00:59] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[12:00:59] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14de7dc81 to 14dc4560d: 02http://git.io/N3iJvQ
[12:00:59] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[12:01:10] <doener> aatch: in methods? self gets passes in env
[12:01:24] <aatch> doener, yeah, but I don't think it needs to be.
[12:01:31] <doener> s/passes/passed/
[12:01:33] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[12:01:33] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/odb4pQ
[12:01:33] <ghrust> 13rust/06auto 148066dfd 15Philipp BrÃ¼schweiler: syntax::diagnostics: Color the ^~~~ in green for better visibility...
[12:01:33] <ghrust> 13rust/06auto 147418a75 15bors: auto merge of #7230 : Blei/rust/green-squiggle, r=pcwalton...
[12:01:34] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[12:01:38] <aatch> I don't see why it couldn't just be the type.
[12:01:40] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[12:01:40] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 147418a75 to 14dc4560d: 02http://git.io/N3iJvQ
[12:01:40] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[12:01:41] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[12:01:41] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/2B37sA
[12:01:41] <ghrust> 13rust/06auto 1488534ae 15Alex Crichton: Fix compiling empty fmt! strings
[12:01:41] <ghrust> 13rust/06auto 149f6b990 15bors: auto merge of #7227 : alexcrichton/rust/issue-7218, r=brson...
[12:01:42] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[12:01:57] *** Joins: threecreepio (jdp@moz-DB2D70E9.cust.bredbandsbolaget.se)
[12:01:59] <aatch> I swear to god bors.
[12:02:11] <cmr> aatch: just force-push to master or something
[12:02:24] <cmr> an empty commit
[12:02:30] <aatch> I don't know if that'll fix it though...
[12:02:55] <doener> aatch: you mean a specialized argument instead of the "generic" env pointer? Probably. I don't know how that interacts with traits. IIRC sully was working on that yesterday
[12:02:59] <dbaupp> cmr: I think we decided before to just let graydon hit the kill switch, instead of fiddling and making this worse :S
[12:03:08] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[12:03:16] <doener> s/traits/trait objects/
[12:03:19] <cmr> Graydon probably won't be around for 4-5 hours
[12:03:50] <aatch> doener, yeah. But I think trait objects will just get covered by the fact that they'll get passed as regular types
[12:03:54] <dbaupp> cmr: yeah, but bors is designed to continue working despite someone manually pushing to master
[12:04:04] <aatch> As in, passed as trait objects.
[12:04:05] <dbaupp> cmr: so it seems unlikely that doing so would fix anything
[12:04:13] <cmr> dbaupp: he is?
[12:04:16] <dbaupp> cmr: and it could easily make bors blow up more
[12:04:17] <dbaupp> cmr: yeah
[12:04:20] <cmr> oh
[12:04:35] <aatch> it would probably fix self-by-value too
[12:05:06] <dbaupp> cmr: (strcat tried just killing the builds on the buildbot by hand... didn't help :( )
[12:05:46] <doener> aatch: how would you know which cast you need when you call a method on a trait object?
[12:06:33] <doener> a new type of glue?
[12:06:54] <aatch> doener, well if you can get the method's ValueRef, you can just cast it to the right type from the argument type
[12:07:09] <aatch> doener, I don't think a new glue will be needed.
[12:07:29] <aatch> I'm just gonna experiment for the moment.
[12:07:55] <doener> aatch: maybe I'm just being dense, but how do you get the original object's ValueRef for a trait object? 
[12:08:18] <aatch> doener, I don't think you can.
[12:08:33] <aatch> but calling methods on trait objects is done by a vtable
[12:09:01] <aatch> since the whole point is that we don't know the concrete type at compile time.
[12:09:17] <doener> right. But you need to produce the cast as compile time, don't you?
[12:09:26] <doener> s/as compile/at compile/
[12:09:46] <aatch> doener, hmm, it'll be a pointer at some offset, right?
[12:10:52] <dbaupp> cmr: (https://github.com/mozilla/rust/pull/7147 isn't really an iterator patch. :) )
[12:11:19] <doener> hm, I think I'm mixing things up in my head. The vtable would have to have a generic "self" pointer, just like "env" today
[12:11:30] <doener> so there's no cast needed for the call
[12:11:44] <aatch> doener, that's the point.
[12:12:02] <cmr> http://cmr.github.io/blog/2013/06/22/this-week-in-rust/
[12:12:08] <aatch> I'm pretty sure that almost all the casts we do that aren't from transmute are bogus
[12:12:49] <aatch> With possibly the exception of traits and enums
[12:25:23] <hoelzro> how is one supposed to create an empty hashmap::linear::LinearSet? let set = LinearSet {}; isn't cutting it
[12:25:38] <aatch> hoelzro, linearset is old
[12:25:45] <hoelzro> oh, ok
[12:25:50] <aatch> thus, you are using a very old version of rust
[12:25:54] <hoelzro> it was just the first thing I found for sets
[12:25:56] <hoelzro> I'm on 0.6
[12:25:58] <aatch> I strongly suggest updating.
[12:26:08] <engla> hoelzro: it's called LinearSet::new()
[12:26:19] <hoelzro> aatch: to HEAD?
[12:26:20] <engla> hoelzro: and will be HashSet::new() in the dev version
[12:26:24] <hoelzro> engla: ah, ok
[12:26:27] <aatch> hoelzro, yes
[12:26:38] <aatch> for one, there are numerous language changes
[12:26:51] <aatch> and fixes
[12:26:56] <hoelzro> hmm
[12:27:06] <aatch> you will have a much better time with the latest master
[12:27:28] *** Joins: kyle2000 (kyle2000@6EDB4D7A.341FCD98.3031298E.IP)
[12:27:29] <aatch> and now the "trunk" docs on the website should stay more-or-less up to date with it.
[12:27:58] <aatch> (They're updated when something gets pushed to master)
[12:28:25] <kyle2000> can anyone tell me anything about the code under /src/libstd/rt/io?
[12:28:42] <aatch> kyle2000, I know a little, what do you wanna know?
[12:28:52] <kyle2000> is the /src/libstd/rt/io code like experimental new io functionality that'll eventually replace the existing io functionalities?
[12:29:01] <aatch> kyle2000, yes
[12:29:09] <aatch> it's integrated into the new scheduler
[12:29:32] <kyle2000> aatch: sweetness. i think i will start using it then. it looks much better than the existing io code.
[12:29:44] <cmr> Does it work?
[12:30:07] <aatch> kyle2000, cool. If you want to use the new scheduler, you have to set the RUST_NEWRT environment variable.
[12:30:16] <aatch> it should _mostly_ work
[12:30:27] <aatch> depends on how much brson has managed to fix
[12:30:40] <cmr> aatch: http://i.imgur.com/ZJkqK0L.png
[12:31:03] <aatch> cmr, cool
[12:31:26] <aatch> dropped LLVM memory usage by a respectable amount
[12:31:36] <aatch> like doener said, probably from the smaller IR
[12:31:54] <cmr> also a titch faster
[12:32:03] <cmr> (end time and start time is within noise)
[12:32:04] <doener> that's weird
[12:32:14] <engla> nice graph format, showing both memory and time
[12:32:19] <doener> it was 12% slower for me
[12:39:27] <cmr> indutny: ping
[12:40:07] <doener> cmr: how do you measure?
[12:40:18] <cmr> doener: I use https://github.com/cmr/rust-bench
[12:40:28] <cmr> let me upload my 'benchit' script
[12:40:53] <cmr> https://github.com/cmr/rust-bench/blob/master/benchit.py
[12:42:33] <doener> cmr: I have no idea about imgur, but maybe remove the imgur_id?
[12:42:43] <cmr> nah it's fine
[12:42:49] <cmr> it's a per-application api key
[12:43:03] <doener> ok
[12:43:14] <cmr> Also those are the steps I do, but for benching old/already-merged PRs, I do it manually (so I can use a different "master")
[12:44:01] <rubber-duck> doesn't it make more sense for slice API to be "".slice(begin, size) instead of (begin, end) 
[12:44:14] <indutny> cmr: pong
[12:44:20] <indutny> sup?
[12:44:23] <cmr> rubber-duck: it's essentially substr, which uses begin, end
[12:44:37] <cmr> indutny: Do you want to add a safe wrapper for mman stuff? Is that possible?
[12:44:45] <cmr> indutny: your comment about checking for MMAP_FAILED reminded me
[12:44:58] <rubber-duck> cmr, but you don't have the begin < end condition if you use size
[12:44:59] <indutny> wellâ€¦ yes, its possible
[12:45:05] <indutny> and I seen that guy's post
[12:45:18] <indutny> do you want it to be just a vector?
[12:45:19] <cmr> rubber-duck: well you just need size < slice.size, which is the same thing
[12:45:28] <indutny> or something more complicated
[12:45:51] <cmr> indutny: it should probably return an unsafe pointer to be useful, but just a simple safe api around mmap that returns an Option<*mut u8> or something
[12:46:16] <cmr> indutny: I don't know the details of mmap for what would constitute a useful safe api
[12:46:48] <cmr> rubber-duck: oh I see, you're right
[12:46:58] <rubber-duck> cmr, you have that anyway with end < size :| i guess it's nitpicking but it seems less error prone
[12:47:15] <cmr> rubber-duck: yeah, I completely brain-farted that one!
[12:47:52] <indutny> cmr: :)
[12:48:09] <indutny> ok, I'll figure out something
[12:48:13] <dbaupp> cmr, indutny: (that can be added later)
[12:48:15] <cmr> indutny: I can r+ the PR now if it will take some time
[12:48:24] <indutny> yeah, better do it now
[12:48:30] <indutny> it have many unrelated changes anyway
[12:48:40] <indutny> like sysconf flags
[12:48:41] <aatch> cmr, please dont
[12:48:48] <aatch> with bors on the fritz
[12:48:49] <rubber-duck> FWIW C# uses start, length 
[12:48:51] <indutny> aatch: why?
[12:48:52] <cmr> oh right
[12:49:00] <indutny> ah
[12:49:06] <aatch> indutny, nothing personal
[12:49:15] <indutny> :)
[12:49:16] <indutny> gotcha
[12:49:26] <mblbruce> I have kind of a multi-part question... It begins with: time::strptime() returns a Result<Tm, ~str> which I assume is a stack-allocated Result that may contain a stack-allocated Tm?
[12:49:28] <aatch> I didn't approve a decent PR earlier for the same reason.
[12:49:50] <cmr> rubber-duck: yeah, it's probably better to be start, length. It'd be an invasive change though, I think
[12:49:58] <aatch> mblbruce, correct.
[12:50:33] <doener> cmr: I wonder if the results skewed by the memory accounting.
[12:50:48] <mblbruce> 2) Then when I match that value I get a result::Ok(day) where day is a stack-allocated Tm? What I'd like day to be is a ~Tm that I can pass into a function (which may or may not store it somewhere, but in any case it won't be used in the caller after passing it into the function). Not exactly sure what the best way to achieve that is. 3) Or should I be passing a &Tm (derived from the stack-allocated Tm) into the function and then let the function
[12:50:48] <doener> s/skewed/are skewed/
[12:50:48] <mblbruce> make a copy if it so wishes? 4) And if so, how do I create that copy?
[12:51:08] <cmr> doener: I don't think it is, it'd only be off by a few ms, the kernel memory accounting is lazy and doesn't interrupt the process afaik. Want me to time it without?
[12:51:17] <dbaupp> mblbruce: why do you need a ~Tm?
[12:51:34] <dbaupp> mblbruce: (rather than just a plain Tm, that is)
[12:51:51] <aatch> mblbruce, unless you have a good reason otherwise, you want to pass as &Tm
[12:51:52] <rubber-duck> cmr, yeah I don't think changing that is possible at this point it would be impossible to catch the errors since type checking does nothing for you here, ashame but oh well
[12:51:54] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[12:51:54] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 149f6b990 to 14dc4560d: 02http://git.io/N3iJvQ
[12:51:54] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[12:51:58] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[12:51:58] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/ofIu_w
[12:51:58] <ghrust> 13rust/06auto 148066dfd 15Philipp BrÃ¼schweiler: syntax::diagnostics: Color the ^~~~ in green for better visibility...
[12:51:58] <ghrust> 13rust/06auto 1401a2d69 15bors: auto merge of #7230 : Blei/rust/green-squiggle, r=pcwalton...
[12:52:00] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[12:52:07] <doener> cmr: that would be great. I'm getting wary about my own benchmarks... I ran both builds 4 times and had a consistent 10-12% difference
[12:52:08] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[12:52:08] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1401a2d69 to 14dc4560d: 02http://git.io/N3iJvQ
[12:52:08] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[12:52:09] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[12:52:09] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/P22jmQ
[12:52:09] <ghrust> 13rust/06auto 1488534ae 15Alex Crichton: Fix compiling empty fmt! strings
[12:52:09] <ghrust> 13rust/06auto 14535f758 15bors: auto merge of #7227 : alexcrichton/rust/issue-7218, r=brson...
[12:52:09] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[12:52:10] <dbaupp> mblbruce: in any case, the copy would be `~*tm`
[12:52:11] <aatch> otherwise, a strait Tm will be moved by default.
[12:52:34] <cmr> rubber-duck: oh it's easily possible, breaking changes are fine. you'll just need to be careful to update every call site in the compiler.
[12:53:24] <cmr> rubber-duck: usually it's called like foo..slice(0, foo.len()) because that's the only way to get a slice to the contents of a vec/str
[12:53:26] <aatch> rubber-duck, with that in mind, I suggest opening an issue about it first.
[12:53:27] <dbaupp> rubber-duck: we probably want both (start, end) and (start, length)
[12:53:34] <dbaupp> cmr: that's no longer true
[12:53:38] <dbaupp> cmr: .as_slice()
[12:53:38] <aatch> dbaupp, I thought we did.
[12:53:41] <cmr> dbaupp: oh nice!
[12:53:47] <dbaupp> aatch: have both?
[12:53:57] <dbaupp> aatch: we had .substr which was (byte index, char length)
[12:54:00] <aatch> Both a start, length and start, end
[12:54:09] <aatch> or was substr removed?
[12:54:09] <dbaupp> aatch: and >50% of the uses were incorrect
[12:54:15] <dbaupp> so I removed it
[12:54:19] <aatch> fair enough.
[12:55:09] <cmr> rusti: "â˜Žfooo".slice(1, 3)
[12:55:11] -rusti- rust: task failed at 'assertion failed: self.is_char_boundary(begin)', /build/rust-git/src/rust/src/libstd/str.rs:1331
[12:55:11] -rusti- rust: domain main @0x245f1b0 root task failed
[12:55:11] -rusti- application terminated with error code 101
[12:55:15] <cmr> Ok, good.
[12:55:25] <aatch> heh, telephone
[12:55:27] <dbaupp> rusti: "â˜Žfooo".slice_chars(1, 3)
[12:55:27] -rusti- "fo"
[12:55:46] <cmr> Just making sure there wasn't a soundness hole *there* too
[12:55:53] <hoelzro> ok, for now I'm using the LinearSet (building HEAD in the background), and I have an alias for it (use Set = core::hashmap::linear::LinearSet).  I'm trying to call set.contains, but it's complaining that LinearSet doesn't have a contains method.  Is there something else I need to add to import it?
[12:56:33] <cmr> hoelzro: you'll probably need to import the trait that has the contains method, it might not be in the prelude in 0.
[12:56:35] <cmr> 6
[12:56:36] <aatch> hoelzro, there's a trait called Set
[12:56:41] <hoelzro> ah, I see
[12:56:51] <aatch> you're probably shadowing it by accident
[12:56:57] <hoelzro> so to use a method, you need to import both the impl and the trait?
[12:57:01] <hoelzro> oh, I see
[12:57:05] <hoelzro> I'll try a different alias
[12:57:06] <cmr> No, just the trait
[12:57:21] <aatch> hoelzro, try HashSet (since thats the new name)
[12:57:23] <hoelzro> ok
[12:57:26] <hoelzro> ok, that did it
[12:57:48] <hoelzro> should a warning be issued when an alias shadows a trait (or another name?)
[12:57:54] <cmr> probably
[12:58:06] <cmr> I'd go so far as to say it should be an error..
[12:58:26] <cmr> with #[allow(shadowing)]
[12:58:29] <mblbruce> I suppose it's a pretty small struct to copy in this case. I'm just trying to be efficient for when I run into a similar situation with a data type that is less cheap to copy. But a borrowed ptr to it would seem like a good choice in this case, and then copying it with ~*var. But that brings me to the final part of the questionâ€¦ I can't help feeling that I should be able to get a ~Result<~Tm, ~str> to begin with, and the ability to pass that ~T
[12:58:29] <mblbruce> on, thereby invalidating the original ~Result but sparing me the need of copying anything.
[12:59:12] <hoelzro> cmr: should I file an issue?
[12:59:23] <cmr> mblbruce: the reason it doesn't return a ~Tm is to allow the user to decide how it is to be stored.
[12:59:52] <aatch> mblbruce, for larger structs, they are returned by a pointer argument
[13:00:06] <engla> hoelzro: maybe test the git version first
[13:00:15] <hoelzro> ok, I'll try that when it's done building
[13:01:18] <aatch> so if you call `~make_big_thing()` it will allocate in the `~`-heap and pass a pointer to the `make_big_thing` function
[13:02:09] <cmr> ohhh is that why constructors take a pointer to the result?
[13:02:14] <cmr> (talking about the generated IR)
[13:02:20] <aatch> cmr, yes
[13:02:27] <mblbruce> aatch: Oh, that sounds really nice.
[13:02:28] <dbaupp> aatch: does that work for something like `fn f() -> Big { let big = Big; <initialise big>; return big; }`
[13:02:29] <cmr> Handy optimization
[13:02:38] <dbaupp> aatch: as in, is big memcpy'd at the end?
[13:02:41] <aatch> dbaupp, not sure.
[13:03:10] <aatch> the IR generated is probably a memcpy, though I imagine that LLVM optimizes it
[13:03:18] <cmr> aatch: could you add that to https://github.com/mozilla/rust/wiki/Doc-lowlevel-details ?
[13:03:33] <aatch> cmr, sure, one I confirm that it's true
[13:03:36] <aatch> once*
[13:03:38] <cmr> heh :)
[13:04:59] <aatch> And the answer is yes
[13:05:27] <mblbruce> aatch: So the return value of f() lacking a pointer qualification (~/@/&) doesn't indicate anything relating to stack-allocation, but rather that the caller has the sole responsibility for deciding it's allocation mode?
[13:05:39] <aatch> mblbruce, yes
[13:06:31] <aatch> for large return types, a pointer to allocated memory is passed to the function.
[13:07:00] <mblbruce> aatch: That's really neat, I have to say.
[13:07:20] <aatch> Which is actually what C does already. it just doesn't let you say "allocate on the heap".
[13:07:30] *** Joins: spider-mario (spidermari@moz-B8FA2FF4.rev.sfr.net)
[13:07:51] <mblbruce> Yeah
[13:07:52] *** Joins: Blei (philipp@moz-650B9C6A.cust.bluewin.ch)
[13:07:57] <aatch> As in, for large return types, the C abi changes to what we have. But the pointer is always stack-allocated
[13:08:21] <aatch> pointer is _to_ stack-allocated memory, rather
[13:08:50] <dbaupp> aatch: the answer is yes for my example too?
[13:09:04] <dbaupp> aatch: (or is that what you checked?)
[13:09:09] <aatch> dbaupp, I'll check.
[13:09:42] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[13:10:58] <aatch> dbaupp, yep, memcpy at the end, from this:
[13:11:03] <aatch> let mut a = [0, ..8];
[13:11:03] <aatch>         a[3] = 5;
[13:11:03] <aatch>         a
[13:11:14] <dbaupp> aatch: :( with opts?
[13:11:37] <aatch> dbaupp, unfortunately, yes
[13:11:43] <dbaupp> gah! :/
[13:12:01] <aatch> Though that's at the IR level
[13:12:21] *** Quits: rubber-duck (rubber-duc@moz-CBF18172.dsl.iskon.hr) (Quit: Leaving)
[13:12:21] <cmr> I imagine the opt is only when you have a `return Struct { ... } `
[13:12:38] <mblbruce> So, when a function returns a Result<T, ~str> and the caller decides the allocation mode for the Result, that same mode applies to the (possible) instance of T, right?
[13:13:21] <aatch> mblbruce, depends on what Result does with T.
[13:13:27] <aatch> In this case, yes
[13:13:54] <aatch> because Result is enum Result<T,U> { Ok(T), Err(U) }
[13:13:58] <dbaupp> aatch: even just `let a = [..]; a` does the same thing :(
[13:14:05] <aatch> dbaupp, really?
[13:14:17] <cmr> dbaupp: what about just `return [0, ..8]`?
[13:14:19] <dbaupp> aatch: yup
[13:14:29] <aatch> cmr, that works fine
[13:14:55] <cmr> that's what I figured... it'd be difficult to optimize for the case of an intermediate.
[13:14:58] <cmr> Although not really
[13:15:11] <dbaupp> aatch: it puts 0 into a stack array, and then immediately moves that stack array back into registers to put it into the return pointer
[13:15:14] <cmr> Figure out the name that is returned, replace that name everywhere with the first parameter of the function
[13:15:52] <cmr> 'course that's just theoretical, not sure how it actually plays out in trans
[13:16:21] <mblbruce> aatch: Not sure I understand what "does with T" means, as it's just an enum one can pat match against. In what situation would T not have the same allocation mode as the Result?
[13:16:22] <aatch> in the case of just [0,..8], it compiles down to a bitcast and a memset
[13:16:49] <aatch> mblbruce, well the T is just the type it is paramaterized over.
[13:16:54] <dbaupp> aatch: oh, I'm looking at the asm
[13:17:10] <dbaupp> aatch: (so I'm seeing what the memset becomes, I guess)
[13:17:25] <mblbruce> aatch: Oh, right. The T could have a ptr qualification in itself. Sorry.
[13:17:36] <aatch> In the case of Result, it stores it by value,
[13:18:10] <aatch> but another type might store it in ~T or @T or even another datastructure altogether.
[13:18:31] <aatch> dbaupp, the memset for me becomes 8 movq instructions.
[13:19:18] <aatch> Although, add inlining in for small functions and it starts to become a bit of a non-issue
[13:19:21] <cmr> I wonder how sophisticated llvm's cost model for lowering memset is
[13:20:07] <aatch> cmr, well if i make it 64 ints it lowers to a memset call
[13:20:28] <mblbruce> aatch: How would Result need to be defined to allow a function returning a Result<T, U> to pass the decision of the allocation mode of T on to its caller?
[13:20:38] <dbaupp> aatch: yup, same
[13:20:59] <aatch> at 16 it's just movq, at 24 it's memset
[13:21:03] <dbaupp> aatch: although, for the `let a = ; a` variant the first memset is 4 sse movapd's
[13:21:44] <aatch> mblbruce, you said you have some experience with C, right?
[13:21:57] <dbaupp> aatch: it'd be cool if we could pass alignment information (when we know it) for the out pointer
[13:22:10] <mblbruce> aatch: Yes
[13:22:17] <aatch> dbaupp, that should be really, really easy.
[13:22:36] <dbaupp> aatch: yay!
[13:22:57] <dbaupp> "out pointer" is the correct terminology, right?
[13:23:16] <cmr> I think so
[13:23:43] <aatch> mblbruce, ok, well structs in rust are the same as structs in C, memory wise. So a rust struct `struct Foo { a: int, b: float }` is, in memory, an int and a float, one after the other.
[13:23:58] <cmr> It's the same as the C pattern init_type(type *out). for stack allocation it'd be 'type foo; init_type(foo);'
[13:24:14] <cmr> doener: Sans running in cgroup: 150.74s before refactor pt2, 127.98s after, I think you're right.
[13:24:30] <aatch> mblbruce, for a generic struct, `struct Foo<T> { a: T }`, a is whatever type T is when you do something with it.
[13:25:00] <cmr> doener: It's good that we caught this.
[13:25:14] <dbaupp> cmr: so refactor pt2 did make it faster?
[13:25:39] <cmr> Hm
[13:25:47] <cmr> doener: my results are the opposite of yours
[13:25:48] <aatch> so if you make it `Foo<int>` you get `{ a: int }`, Foo<~Foo>, `{ a: ~Foo }`
[13:25:58] <cmr> dbaupp: yes, but the main result is that the memory accounting significantly skews timing results
[13:26:09] <dbaupp> cmr: oh
[13:26:15] <doomlord> (alignment... i recall problems with alignment for simd types on the stack on some compilers... just thinking what its like these days, with the addition of 256bit simd and haswell gather to make better use of it)
[13:26:17] <dbaupp> cmr: is it the busy sampling?
[13:26:21] <cmr> I think it's because I'm polling it every 0.03ms :p
[13:26:25] <cmr> dbaupp: testing it to find otu
[13:26:35] <mblbruce> aatch: I'm with you so far. =o)
[13:26:41] <dbaupp> cmr: well, at 0.03ms that'd be a reasonable reason ;)
[13:27:31] <aatch> mblbruce, so if you have a struct defined like `struct Bar<T> { ptr: ~T }`, then no matter what T you have, it will always be allocated in the heap
[13:27:39] <aatch> even if T is itself a pointer
[13:27:49] <doener> cmr: oh, I read that backwards... makes it even more confusing though
[13:27:51] <cmr> dbaupp: is measuring every ms fine, in terms of data integrity?
[13:27:54] <aatch> since Rust doesn't care.
[13:27:56] *** Joins: mib_4sgdd5 (Mibbit@moz-740C3387.dyn.tyfon.se)
[13:28:00] <dbaupp> cmr: yeah
[13:28:08] <dbaupp> cmr: it'd nice to have it tuneable
[13:28:46] <dbaupp> cmr: so "general" measurements are every ms (or even 5ms or more), but one can run very finely to catch transient spikes
[13:29:13] <cmr> dbaupp: there's always valgrind for fine-tuned memory profling too
[13:29:21] <cmr> and jemalloc's instrumentation
[13:29:32] <dbaupp> cmr: yup, I think strcat likes cgroups more
[13:29:40] <mblbruce> aatch: Ok. I think I follow.
[13:29:41] <cmr> they are lighter weight
[13:29:46] <cmr> less work to use :p
[13:29:50] <dbaupp> and they're more accurate
[13:29:55] *** Joins: jrfeenst (jrfeenst@moz-F912484F.cpe.norwoodlight.com)
[13:30:01] <dbaupp> (I believe)
[13:30:08] <cmr> Well I don't think that's true for how I'm measuring, but it's true for max_usage_in_bytes
[13:30:16] <aatch> mblbruce, so you can't know where a type parameter might be stored, just from the type signature.
[13:30:30] <cmr> There's also kmem for measuring kernel resources, I think max_usage_in_bytes includes that, not sure
[13:30:32] <dbaupp> cmr: oh, is usage_in_bytes not accurate?
[13:30:50] <cmr> dbaupp: I don't think it includes kernel resources
[13:31:13] <cmr> Especially since I'm measuring from memory.stat, not memory.usage_in_bytes
[13:31:26] *** Quits: kyle2000 (kyle2000@6EDB4D7A.341FCD98.3031298E.IP) (Quit: Leaving)
[13:31:41] <cmr> Maybe that's my performance problem. memory.stat probably requires all the caches to be flushed and such?
[13:31:45] * cmr tries usage_in_bytes
[13:32:10] <dbaupp> what's the difference?
[13:32:29] <cmr> https://www.kernel.org/doc/Documentation/cgroups/memory.txt
[13:32:44] <cmr> For efficiency, as other kernel components, memory cgroup uses some optimization
[13:32:45] <cmr> to avoid unnecessary cacheline false sharing. usage_in_bytes is affected by the
[13:32:47] <cmr> method and doesn't show 'exact' value of memory(and swap) usage, it's an fuzz
[13:32:49] <cmr> value for efficient access. (Of course, when necessary, it's synchronized.)
[13:32:51] <cmr> If you want to know more exact memory usage, you should use RSS+CACHE(+SWAP)
[13:32:53] <cmr> value in memory.stat(see 5.2).
[13:33:22] <dbaupp> I see
[13:33:23] <doener> cmr: any chance that you swapped the results? I can't seem to come up with any other idea about how they could be pretty much exactly opposite
[13:33:27] * doener is getting desperate
[13:33:34] <cmr> doener: no, there isn't, sorry :(
[13:33:52] <cmr> I double checked
[13:33:55] <dbaupp> doener: what architecture?
[13:33:57] <cmr> doener: what's your hardware?
[13:33:59] <doener> x86_64
[13:34:04] <dbaupp> cmr: (you're on x86-64 linux?)
[13:34:07] <cmr> yes
[13:34:12] <doener> i7 3770k 16GB RAM, up-to-date Debian sid
[13:34:25] <dbaupp> cmr: I guess measuring memory.stat is the one we want
[13:34:31] <cmr> I've a E3-1230v2, 16GB RAM, up-to-date arch
[13:34:34] <dbaupp> cmr: but measuring it more slowly...
[13:35:03] <doener> I'm even not doing anything while benchmarking to avoid skewed results by turbo boost
[13:35:19] *** Quits: mib_4sgdd5 (Mibbit@moz-740C3387.dyn.tyfon.se) (Quit: http://www.mibbit.com ajax IRC Client)
[13:35:22] <cmr> well, I'm irc-ing while doing it, but that's hardly a cpu buster
[13:35:54] <doener> yeah, irc is running as well, but nothing that actually uses any significant amount of cpu time
[13:37:01] <mblbruce> aatch: Thanks for taking the time to explain. I'll do some more playing around and try not to get ahead of myself with these questions. It's just that I've been wandering the forest for some time now looking without much luck for a language that fits all the stuff I want to do, which makes one want to know the pros and cons as early as possible before committing lots of time and lines of code.
[13:37:16] <dbaupp> doener, cmr: which commits are each of you building?
[13:37:22] <cmr> dbaupp: in the graph
[13:37:44] <cmr> 544f615 and e3ef750
[13:38:05] <aatch> mblbruce, well Rust is pretty good. There are a lot of people here that have said more-or-less "Rust is the language I keep meaning to build myself"
[13:38:20] <cmr> doener: I'm measuring building stage2 librustc with the stage2 rustc
[13:38:26] <cmr> doener: what are you measuring?
[13:38:36] <cmr> (not that there should be mcuh of a difference, given the recent snapshot)
[13:39:01] <aatch> mblbruce, just be wary that Rust is in alpha still, so there are sharp corners here and there, and there, and there
[13:39:10] <cmr> oh and especially over there :p
[13:39:16] <dbaupp> aatch: and there, and there, and there
[13:39:25] <cmr> pre-alpha
[13:39:34] <dbaupp> (everything is a sharp corner, essentially)
[13:39:36] <aatch> And especially there ->
[13:40:05] * aatch points to trans, which is just a mass of spikes, that are themselves covered in spikes
[13:40:10] <dbaupp> (clearly, Rust is actually the Weierstrauss function)
[13:40:56] <doener> dbaupp: f886520 and dc4560d
[13:41:18] <dbaupp> doener: hm, well that might explain the difference
[13:41:56] <cmr> I'm not using the bors merge, I'm using the commit before it, and the PR's parent
[13:42:14] <cmr> (which is doener's IR improvement)
[13:43:59] <dbaupp> there appears to be b8efa2eb between the two non-refactor commits
[13:44:09] <dbaupp> but that really shouldn't explain the perf difference?
[13:44:42] <mblbruce> aatch: That's the feeling I'm getting too. I pay the bills with C on barely-embedded systems writing code that would benefit greatly from some memory safety (and a lot of other Rust features) but still decently preserved performance and similar memory consumption. In my spare time I mostly bolt ugly stuff together with C/Ruby/Python while flirting with Scala and Go and considering dusting off my Haskell that has long since rusted (no pun intended
[13:44:43] <mblbruce> but nothing is making me really happy. Maybe Rust does, and I don't mind sharp edges while stuff is being figured out.
[13:44:56] <doener> I'm building the versions cmr is using now
[13:44:58] <cmr> I'd hope not, they're functionally equivalent... jost some syntax changes
[13:45:01] <Aetherspawn> > 1 +1
[13:45:42] <doener> cmr: I'm measuring building stage2 with an installed rustc of the respective version (should be the stage2 rustc, right?
[13:45:45] <dbaupp> Aetherspawn: wrong channel? ;)
[13:45:49] <cmr> doener: yup
[13:45:53] <aatch> mblbruce, well there is somebody that wants to get Rust running on embedded systems.
[13:46:04] <Aetherspawn> kinda. I setup a lambdabot /finally/
[13:46:09] <cmr> mblbruce: somebody that's doing it for their honors thesis, at that!
[13:46:15] <cmr> or, plans to
[13:46:19] <Aetherspawn> I was just curious if rusti and lambdabot were both bound to >
[13:46:22] <Aetherspawn> I might setup a rusti :D
[13:46:32] <dbaupp> Aetherspawn: rusti's bound to `rusti:`
[13:46:37] <mblbruce> aatch, cmr: That sounds great
[13:47:14] <aatch> For pretty much the same reasons, memory safety in embedded environments without sacrificing performance.
[13:48:09] <aatch> If you never use @ (which isn't hard) then you get pretty much complete control over the environment.
[13:49:40] <mblbruce> aatch: Yeah, I read pcwalton's post about relegating managed memory to std/extra. I wonder what that would look like, though. Hopefully not to complicated/verbose for the situations when you actually want it.
[13:51:46] <Aetherspawn> I designed haskell designed for the stack today
[13:52:07] <MaikKlein> i hate java
[13:52:26] <cmr> MaikKlein: that's pretty random :p
[13:52:31] <doomlord> i liked the idea of the GC being customizable (but the idea of being able to dodge it altogether is even better :) )
[13:52:38] <aatch> MaikKlein, good, that makes you a sentient human
[13:52:41] <doomlord> java is like C++ minus the bits i actually like
[13:52:46] <MaikKlein> ups sry I thought it was just in my head :D
[13:53:30] <cmr> doomlord: and plus terrible memory characteristics
[13:53:32] <MaikKlein> I don't dislike jvm, just java :p
[13:53:32] <Aetherspawn> map is possible on immutable stack lists if there is a way to pattern match the size of intermediate lists
[13:53:41] <Aetherspawn> I was messing around earlier and came up with something like this:
[13:53:51] <Aetherspawn> let map' n ([a;n]:c:[b;_]) f = | n > 0 map' (n-1) $ a : (f c) : b
[13:54:36] *** aatch is now known as aatch|bed
[13:55:08] <mblbruce> Sounds like this cannel is filled to the brim with disillusioned language hunters...
[13:55:14] <cmr> Yup
[13:55:19] <Aetherspawn> all of us.
[13:55:33] <cmr> Rust: the island of misfit programmers
[13:55:40] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Connection reset by peer)
[13:55:42] *** Joins: maxli1 (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[13:55:47] <Aetherspawn> Rust: where /all the things/ get pulled
[13:57:11] <mblbruce> Somehow that makes me oddly optimisticâ€¦ ;o)
[13:57:21] <cmr> dbaupp: using usage_in_bytes doesn't make it less overhead-y
[13:57:30] <dbaupp> cmr: oh :(
[13:57:33] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[13:57:33] *** Quits: maxli1 (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Connection reset by peer)
[13:57:39] <dbaupp> cmr: so the only choice is slower?
[13:57:43] <dbaupp> (that's fine by me)
[13:57:52] <cmr> well I haven't turned downt he polling frequency yet
[13:58:01] <cmr> was just testing different measurement methods
[13:58:14] <cmr> it is significantly less accurate though
[13:58:28] <MaikKlein> in rust it's always like "wow I can really do that?" and in java "wow I really can't do that?" :( , okay enough hate for today 
[13:58:37] <cmr> dbaupp: http://i.imgur.com/BZHfONI.png
[13:58:51] <cmr> you can see the lower resolution
[13:58:58] <dbaupp> cmr: 1ms?
[13:59:11] <dbaupp> (yeah, the transients in the first bit are gone)
[13:59:12] <cmr> no, that's the difference with memory.usage_in_bytes vs memory.stat
[13:59:18] <dbaupp> oh
[13:59:23] <dbaupp> yup
[13:59:40] <MaikKlein> what
[13:59:44] <dbaupp> Maybe measuring memory usage and performance should be entirely separate?
[13:59:48] <MaikKlein> rustc needed 1gb of memory?
[13:59:51] <Blei> shouldn't something like 10ms polling be good enough?
[14:00:06] <cmr> MaikKlein: yeah
[14:00:08] <dbaupp> Blei: dunno
[14:00:28] <cmr> Oh wait
[14:00:32] <cmr> That *is* with a 1ms delay
[14:00:39] <cmr> And also usage_in_bytes
[14:01:31] <dbaupp> Blei: the small spikes in http://i.imgur.com/Ct8UHKc.png might be missed
[14:01:43] <cmr> will, not might
[14:01:50] <dbaupp> Blei: of course, it depends what one is optimising for
[14:01:56] <hoelzro> hmm
[14:02:02] <hoelzro> what does the Rust build process use Perl for?
[14:02:11] <dbaupp> cmr: not necessarily... the measurement could occur at precisely the right time
[14:02:14] <dbaupp> hoelzro: LLVM
[14:02:16] <doener> cmr: still the same results: https://gist.github.com/dotdash/5840963
[14:02:20] <hoelzro> oh, really?
[14:02:24] <hoelzro> crazy
[14:02:58] <cmr> doener: Your build is also a full minute slower than mine.
[14:03:02] <dbaupp> Blei: (i.e. if one is wanting to get a hyperaccurate memory profile, or just an approximate one with low performance impact)
[14:03:17] <dbaupp> hoelzro: yeah, LLVM seems to require perl for some reason
[14:03:42] <doener> cmr: hu? it's about 20s faster
[14:04:02] <cmr> doener: oh wait, hurr, 150 seconds is 2 minutes 3 seconds
[14:04:07] <cmr> *30
[14:04:23] <cmr> time... who needs it
[14:05:24] <EXetoC> snails
[14:06:19] *** Joins: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca)
[14:11:36] <doener> cmr: in http://i.imgur.com/BZHfONI.png
[14:11:40] <doener> oops
[14:11:48] *** Joins: z0w0 (zack@moz-DD233ABD.lnse4.woo.bigpond.net.au)
[14:11:49] <doener> cmr: in that graph, master is faster
[14:12:29] *** Quits: threecreepio (jdp@moz-DB2D70E9.cust.bredbandsbolaget.se) (Quit: threecreepio)
[14:13:14] <dbaupp> doener: but not much? didn't you say 10%? (or was it 10s?)
[14:13:32] <doener> dbaupp: that graph still has _some_ overhead for allocations
[14:13:44] <dbaupp> doener: yes
[14:13:57] <cmr> I can confirm that memory profiling is definitely skewing the timing results.
[14:14:19] <cmr> but it should be by a constant factor
[14:14:23] <doener> dbaupp: and master has more of them. The previous one had them head-to-head, time-wise. Reduced penalties make master faster, but removing the memory profiling makes master slower?
[14:14:29] <doener> dbaupp: that seems wrong
[14:14:51] <cmr> Fix: run it twice! report timing via bar graph, ignore absolute time from memory bench
[14:14:52] <dbaupp> that does seem very strange :/
[14:15:27] <cmr> doener: I'm going to rerun things
[14:15:37] <dbaupp> cmr: measuring perf and mem separately seems like it's the best solution
[14:15:43] <MaikKlein> rust has some concepts of aspect oriented programming right?
[14:15:59] <cmr> MaikKlein: maybe via trait objects?
[14:16:09] <cmr> MaikKlein: I haven't looked at AOP for a while, can't remember the details
[14:16:33] *** Joins: cdidd (cdidd@moz-664B49E1.broadband.corbina.ru)
[14:17:15] <MaikKlein> afaik it is extending functionality without really changing the code, like 5.log(); which is possible in rust
[14:17:43] <doener> cmr: sorry for being so insistent about this, but I really want to understand what's going on.
[14:17:53] <cmr> doener: me too, it's fine
[14:18:10] <cmr> I want to have accurate data to make decisions with.
[14:18:53] *** Joins: kyle2000 (kyle2000@6EDB4D7A.341FCD98.3031298E.IP)
[14:19:02] <cmr> I'm rerunning just the `time` measurement with make cleans.
[14:21:40] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Connection reset by peer)
[14:21:43] <kyle2000> friends, i am having great trouble with the std::io::ReaderUtil class and std::io::Reader, too.
[14:22:05] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[14:22:08] <kyle2000> durn i can't post my code here
[14:23:16] <kyle2000> http://pastebin.com/6nD64kCE
[14:23:36] <kyle2000> it tells me:
[14:23:44] <cmr> kyle2000: well, first I think you need &mut Reader, second I think only @-trait objects are working right now
[14:24:39] <kyle2000> cmr: even with that it gives me:
[14:24:42] <kyle2000> error: failed to find an implementation of trait std::io::Reader for &mut std::io::Reader
[14:24:53] <kyle2000> but if it's broken then maybe i should just wait
[14:24:57] <cmr> You're right I think. When I have it use @Reader it works
[14:25:11] <kyle2000> yes but i don't want to use @Reader.
[14:25:26] <kyle2000> programming languages do what i tell them to.
[14:25:26] <cmr> I don't even know what the sigils on trait objects mean
[14:26:02] <dbaupp> kyle2000: there's basically no way around it right now :(
[14:26:03] <kyle2000> all i want is my function to take a Reader and then call a method of ReaderUtil on it.
[14:26:08] <kyle2000> dbaupp: okay thanks
[14:26:19] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[14:26:27] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[14:26:34] <dbaupp> kyle2000: when the new runtime and io library lands, the whole heirarchy should be more sensible
[14:26:36] <z0w0> you can try (*input).read_char()
[14:26:45] <z0w0> if i'm reading this correctly
[14:26:51] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[14:26:57] <z0w0> pun not intended
[14:27:12] <dbaupp> rusti: fn grab_the_inputs(input: &Reader) -> char { input.read_char() }
[14:27:13] -rusti- <anon>:9:54: 9:73 error: failed to find an implementation of trait std::io::Reader for &std::io::Reader
[14:27:13] -rusti- <anon>:9          fn grab_the_inputs(input: &Reader) -> char { input.read_char() }
[14:27:13] -rusti-                                                                ^~~~~~~~~~~~~~~~~~~
[14:27:13] -rusti- application terminated with error code 101
[14:27:21] <dbaupp> rusti: fn grab_the_inputs(input: &Reader) -> char { (*input).read_char() }
[14:27:22] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/HVXZ
[14:27:35] <z0w0> ohwell
[14:27:36] <cmr> Does anyone know what the sigils on trait objects mean?
[14:27:48] <dbaupp> cmr: the same as on normal things
[14:27:59] <cmr> ok
[14:28:23] <kyle2000> z0w0: sorry that does not work but thank you for the idea. it gives me: error: type &std::io::Reader cannot be dereferenced
[14:28:25] *** Joins: jensnock_ (jensnocker@moz-8BE55278.customer.t3.se)
[14:28:41] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Ping timeout)
[14:28:44] <kyle2000> dbaupp: is there a tentative timeline for when the new runtime and io library might be ready for serious use?
[14:28:44] <dbaupp> i.e. @Foo = { gc'd pointer to object, pointer to vtable }, ~Foo = { owned pointer to object, pointer to vtable }, &Foo = { borrowed pointer to object, pointer to vtable }
[14:28:53] <dbaupp> kyle2000: I don't know
[14:29:30] <dbaupp> kyle2000: as I understand it, large swathes are in the tree at the moment, but are turned off in the default compile
[14:29:59] <kyle2000> dbaupp: okay many thanks. i am eagerly awaiting this new functionality.
[14:30:02] <dbaupp> kyle2000: that may just be the new scheduler though, not sure how the io side of it is progressing
[14:30:07] <dbaupp> kyle2000: so am i! :)
[14:30:36] <z0w0> especially interesting because it makes working with TCP not annoying :)
[14:31:08] <z0w0> unlike the current wrapper..
[14:31:20] *** Joins: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[14:31:23] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[14:31:23] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14535f758 to 14dc4560d: 02http://git.io/N3iJvQ
[14:31:24] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[14:31:25] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[14:31:25] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/OeXfWw
[14:31:25] <ghrust> 13rust/06auto 148066dfd 15Philipp BrÃ¼schweiler: syntax::diagnostics: Color the ^~~~ in green for better visibility...
[14:31:25] <ghrust> 13rust/06auto 14b8c376b 15bors: auto merge of #7230 : Blei/rust/green-squiggle, r=pcwalton...
[14:31:26] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[14:32:13] *** Quits: jrfeenst (jrfeenst@moz-F912484F.cpe.norwoodlight.com) (Quit: jrfeenst)
[14:32:19] <kyle2000> cmr: maybe i am wrong (i am a rust dummy) but i was thinking of traits like Java interfaces. if i have a function parameter like &Reader then i can pass in a ByteReader or even my own custom type implementing the Reader trait.
[14:32:34] <cmr> kyle2000: that is correct
[14:34:20] <kyle2000> does anyone else find rust a rollercoaster? i get so excited at times when i read about it. i am throbbing with arousal and excitement. but then i try to use it and i run into serious problems that compromise my code's design and that makes me very very sad. :(
[14:34:21] <MaikKlein> how would I do sth like this https://gist.github.com/MaikKlein/5841087 ?
[14:34:45] *** Joins: lmandel (lmandel@556E85CD.E855F8D7.412CF160.IP)
[14:34:50] <cmr> kyle2000: it is mostly i/o that is very bad right now, the rest is more-or-less ok
[14:34:59] <dbaupp> kyle2000: yeah... I have all sorts of amazing plans... and they hit the wall that is compiler bugs :(
[14:35:19] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[14:35:20] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14b8c376b to 14dc4560d: 02http://git.io/N3iJvQ
[14:35:20] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[14:35:27] <cmr> MaikKlein: V as PrintVisistor I think?
[14:35:39] <kyle2000> cmr: that is true. it is io that causes me the most pains. but this is unfortunate because io is so important to so many problems! i can't even move onto a different problem i want to solve because they all involve massive amounts of io!
[14:35:49] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[14:35:49] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/1g4y6A
[14:35:49] <ghrust> 13rust/06auto 1488534ae 15Alex Crichton: Fix compiling empty fmt! strings
[14:35:49] <ghrust> 13rust/06auto 145812fff 15bors: auto merge of #7227 : alexcrichton/rust/issue-7218, r=brson...
[14:35:49] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[14:35:50] <cmr> kyle2000: yup :(
[14:36:20] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[14:36:25] <dbaupp> MaikKlein: can you do `fn do_sth<V: Visior<~str>>(&self, v: &V, s: ~str)`?
[14:36:32] <z0w0> ^
[14:36:35] <z0w0> i think that's right
[14:36:35] <dbaupp> (or are you wanting objects on purpose?)
[14:37:11] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[14:37:13] <dbaupp> MaikKlein: also, word of warning, &Trait is not very functional at the moment, e.g. you can't borrow [~@]Trait -> &Trait yet.
[14:37:15] <indutny> I think rust needs some better support of bitfields
[14:37:22] <indutny> like enum { R = 1, W = 2, E = 3 }
[14:37:29] <indutny> let v = R | W | E
[14:37:38] <indutny> and some basic methods
[14:37:41] <indutny> v.has(R)
[14:37:48] <indutny> do we already have this?
[14:38:00] <SiegeLord> Don't think so... and yes, it'd be nice
[14:38:01] <indutny> well, bitvset is pretty much it
[14:38:09] <indutny> butâ€¦ its too far from language itself
[14:38:23] <cmr> What would the language add that the library cannot?
[14:38:27] <dbaupp> indutny: I could imagine a macro/syntax extension would fit in well
[14:38:34] <indutny> dbaupp: yeah, probably
[14:38:41] <dbaupp> cmr: lighter-weight
[14:38:43] <indutny> cmr: syntax sugar
[14:38:44] <cmr> Or syntax in general?
[14:38:59] <indutny> I'm just thinking about API for mmap
[14:39:04] <indutny> and it has a lot of flags
[14:39:11] *** Joins: Nisstyre (wes@moz-FD86289.netflash.net)
[14:39:12] <indutny> which are not really supported by the language
[14:39:12] <kyle2000> i wish that the rust home page had a list of stuff that was badly broken. like i only use rust on week ends and i regret that i don't have time to follow it through out the week. so it would be very convenient if every saturday i could look at the rust home page and see what isn't working. then i can work on some other project instead. like parameter passing problems with borrowed pointers are really severe i think.
[14:39:45] <indutny> what about following type declaration `flags MmapFlags { Readable, Writable, Executable}`
[14:39:58] <indutny> and `mmap(f: MmapFlags)
[14:40:13] <indutny> or probably `#[enum_kind="flags"] enum ...`
[14:40:35] <indutny> something that'll allow me to bit-or and bit-and values
[14:40:38] <z0w0> honestly, i actually prefer the current way it is set out
[14:40:38] <cmr> kyle2000: That would be a good project. Sort of like the opposite of what I do with 'This Week in Rust' (list the breaking changes)
[14:40:40] <indutny> and perform matching
[14:40:43] <Blei> kyle2000: you could do something like `fn grab_the_inputs<T: Reader>(input: &T) ...`, that should at least work
[14:40:53] <z0w0> flags are handled as a vector slice
[14:40:55] <cmr> indutny: You can already overload bitwise operations
[14:41:04] <cmr> And indexing
[14:41:06] <MaikKlein> cmr, dbaupp , I think the problem here is that I have a PrintVisitor which implements Visitor<~str> but rust doesn't make the connection. I think I would need to write sth like "o.do_sth(v as Visitor<~str>, ~"Hello");"
[14:41:07] <indutny> but it won't work for enums
[14:41:12] <dbaupp> kyle2000: that problem is essentially entirely passing &Trait objects, not borrowed pointers in general
[14:41:14] <indutny> cmr: because there're no such values...
[14:41:15] <indutny> like R | W
[14:41:37] <dbaupp> MaikKlein: you'd actually need `o.do_sth(&v as &Visitor<~str>, ...)`
[14:41:37] <indutny> ah, meh
[14:41:44] <dbaupp> MaikKlein: trait objects have to be boxed.
[14:41:45] <indutny> I'll figure out something
[14:41:53] <indutny> probably array of flags
[14:41:59] <cmr> Right, that's the problem... I don't know how to solve it, but the trait system can already express the ideas, and llvm optimizes them well with inlining
[14:42:17] <indutny> yeah, it can
[14:42:17] <z0w0> indutny: see how rust-sdl handles it
[14:42:22] <indutny> rust-sdl?
[14:42:22] <kyle2000> Blei: many many thanks! that does at least compile for me!
[14:42:36] *** Quits: bytbox (s@moz-D83E9B31.wireless.umd.edu) (Ping timeout)
[14:42:42] <z0w0> https://github.com/brson/rust-sdl
[14:42:54] <z0w0> flags are handed around as a vector, and it works well imo
[14:42:57] <indutny> oh nice
[14:43:03] <kyle2000> dbaupp: oh i see. well i consider passing &Trait objects to be a critical part of borrowed pointers. in my opinion if they aren't working then borrowed pointers as a whole are broken.
[14:43:15] <indutny> I see
[14:43:23] <cmr> kyle2000: I have never used a trait object outside of i/o
[14:43:25] <dbaupp> kyle2000: trait objects aren't really used that much, other than io
[14:43:34] <cmr> kyle2000: I always use traits and generics
[14:43:36] <dbaupp> (and the compiler code)
[14:43:48] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[14:43:55] <dbaupp> kyle2000: using <T: Trait> ( .. t: T ...) is the normal pattern
[14:44:08] <cmr> kyle2000: they perform better and are cleaner, static dispatch instead of runtime dispatch with vtable lookup
[14:44:18] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[14:44:22] <cmr> A single inlineable call rather than 2 levels of indirection...
[14:44:27] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[14:44:42] <dbaupp> (they also have the advantage of actually working at the moment)
[14:44:45] <kyle2000> cmr, dbaupp: oh i see. i wish this was made clearer to us rust news. i had no idea and i've read through the tutorial and manual time and time again.
[14:44:46] <SiegeLord> Except with the current rustc codegen they lead to giant code bloat, from what I understand :P
[14:44:59] <kyle2000> *us rust newbs
[14:45:08] <dbaupp> kyle2000: yeah, there is a lot of hidden/unknown features
[14:45:18] <cmr> kyle2000: Yes, the documentation is unfortunately sparse... maybe you would like to write something, for others to improve? :)
[14:45:36] <cmr> kyle2000: it's hard to write documentation for newbs from experienced perspective
[14:45:36] <dbaupp> kyle2000: do you happen to know about #[deriving]? And/or `ref` in matches?
[14:45:44] <kyle2000> cmr: i would if i knew what i was talking about but i have so much trouble with rust as it is. i would just be making it worse i think with misinformations!
[14:46:52] <dbaupp> kyle2000: (to be clear, those are underdocumented but useful features.)
[14:47:34] <z0w0> i'm surprised deriving isn't documented, it's not particularly that hard of a topic to explain
[14:48:07] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[14:48:24] <mblbruce> On average, how often is a language change decided upon nowadays? As opposed to library changes.
[14:48:24] <kyle2000> dbaupp: i had no idea they existed! i will research them.
[14:49:06] <z0w0> mblbruce: i'd say only if everyone in the mozilla team agrees with it
[14:49:10] <MaikKlein> dbaupp, now it works thanks
[14:49:16] <dbaupp> z0w0: it is documented, slightly
[14:49:26] <dbaupp> z0w0: not sure if they've made it to the website though
[14:50:02] <dbaupp> http://static.rust-lang.org/doc/tutorial.html#deriving-implementations-for-traits
[14:50:16] *** Joins: Sodel_the_V (user@moz-853663E1.va.shawcable.net)
[14:50:19] <dbaupp> http://static.rust-lang.org/doc/rust.html#deriving
[14:50:27] <mblbruce> z0w0: Any idea as to the frequency of changes nowadays?
[14:50:42] <z0w0> that seems in-depth enough imo
[14:50:46] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[14:51:11] <dbaupp> kyle2000: and `ref` is mentioned *very* briefly in this section http://static.rust-lang.org/doc/rust.html#match-expressions
[14:51:32] <dbaupp> "Patterns that bind variables default to binding to a copy or move of the matched value (depending on the matched value's type). This can be made explicit using the copy keyword, changed to bind to a borrowed pointer by using the ref keyword, or to a mutable borrowed pointer using ref mut."
[14:51:36] <z0w0> mblbruce: probably only one drastic syntax-wise change every minor version, two or so backwards-incompatible backend changes per minor versions?
[14:52:43] <z0w0> it use to be heaps of changes early on obviously, probably around v0.5-0.6 there hasn't been many drastic changes
[14:52:57] <z0w0> (from memory)
[14:53:09] <MaikKlein> but do I really have to cast? can't rust figure out that PrintVisitor implements Visitor<~str>? https://gist.github.com/MaikKlein/5841146
[14:53:36] <z0w0> using generics didn't work?
[14:54:03] <SiegeLord> It's nice to be explicit about such things
[14:54:20] <MaikKlein> no it was complaining, that it expects Visitor<~str>
[14:55:31] <dbaupp> MaikKlein: yes, the cast is necessary if you are using trait objects
[14:56:05] <mblbruce> z0w0: Ok. That sounds like something slowly approaching it's final form. Of course, it's much better to cook it longer and make changes for the better instead of rushing it out. I'm happy to wait. Would it be correct to assume that language changes/bugfixes are prioritised above library changes/bugfixes?
[14:56:06] <z0w0> cmr: i was going to work on a rustdoc rewrite plan before you started up your rewrite plan. didn't follow the email all the way through, but did you end up deciding on whether or not to use sphinx or continue on with our own generator?
[14:56:20] <cmr> z0w0: I haven't decided that yet, no.
[14:56:44] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[14:56:58] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[14:57:03] <dbaupp> mblbruce: yes
[14:57:37] <cmr> z0w0: I am leaning towards own generator for now, but I do not want to *preclude* other generators. I'd like to have the documentation data available for other generators to be written
[14:57:42] <z0w0> cmr: if you end up deciding to keep our own, i reckon adding a embedded search bar - in a similar manner to sphinx  (optional flag because it would include JS on the page) and 
[14:57:56] <z0w0> source code viewer
[14:58:04] <cmr> Yes, those are two big features I do want
[14:58:12] <dbaupp> mblbruce: small things do get changed semi-regularly, e.g. `copy` in matches was recently removed, as was implicitly copying type parameters with the `Copy` bound (which made some programs spew thousands of lines of errors)
[14:58:12] <z0w0> as in, click on a link somewhere near a symbol to see it in included source code form
[14:58:50] <dbaupp> cmr: (it'd be nice for the symbols in the source to be links too... :D )
[14:59:23] <cmr> MaikKlein: I meant to talk to you but usually when we are both on I am working
[14:59:32] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[14:59:32] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 145812fff to 14dc4560d: 02http://git.io/N3iJvQ
[14:59:32] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[14:59:35] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[14:59:35] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/AMua9Q
[14:59:35] <ghrust> 13rust/06auto 148066dfd 15Philipp BrÃ¼schweiler: syntax::diagnostics: Color the ^~~~ in green for better visibility...
[14:59:35] <ghrust> 13rust/06auto 1427a4e8b 15bors: auto merge of #7230 : Blei/rust/green-squiggle, r=pcwalton...
[14:59:36] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[14:59:37] <cmr> MaikKlein: I think the rustdoc work sortof overlaps with the autocompletion things, not sure though
[14:59:50] <dbaupp> dammit bors :/
[15:00:17] <z0w0> exams are finally over, can finally work on the central rustpkg repo thingy i've been planning to make
[15:00:33] <cmr> z0w0: also rustpkg needs documentation and a tutorial...
[15:00:48] <cmr> z0w0: For example, I figured I'd be able to drop a pkg.rs in a directory, run `rustpkg` and it would be built
[15:00:57] <z0w0> talk to tjc, it's out of my hands now
[15:01:06] <cmr> but there is weird things about workspaces and such..
[15:01:08] <cmr> ok
[15:01:18] <z0w0> i only committed the prototype
[15:01:24] <z0w0> he's working on the final product
[15:01:38] <MaikKlein> cmr, I didn't start yet. I was reading though some files. In which files are you working atm?
[15:02:50] <cmr> MaikKlein: none, actually, right now. but, I'm going to end up needing to take a symbol name from the source code and run resolve on it, to figure out what to link to in the documentation (so you can clik on symbols and see their documentation)
[15:03:25] <cmr> And I think that is similar to what autocomplete needs to do?
[15:03:37] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[15:03:37] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1427a4e8b to 14dc4560d: 02http://git.io/N3iJvQ
[15:03:37] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[15:03:38] <z0w0> cmr: basically purely functional and there were multiple places you could have crates installed, iirc tjc might actually be removing that in favour of local workspaces everywhere
[15:03:41] <MaikKlein> yes that is what I was figuring out
[15:03:41] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[15:03:41] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/18IsZw
[15:03:41] <ghrust> 13rust/06auto 1488534ae 15Alex Crichton: Fix compiling empty fmt! strings
[15:03:41] <ghrust> 13rust/06auto 141b3fa05 15bors: auto merge of #7227 : alexcrichton/rust/issue-7218, r=brson...
[15:03:44] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[15:04:03] <cmr> Ok. I have no idea how to do it, though :)
[15:04:31] <MaikKlein> yeah I wasn't sure either that's why I wanted to make the hook in the parsing :)
[15:04:35] <cmr> doener: https://gist.github.com/cmr/4623e782147cac2f72bd so far
[15:04:55] <z0w0> biggest hurdle for my rewrite was figuring out how to do resolve properly so that exports were actually linked correctly
[15:05:10] *** Joins: HomeGlobalGamers (Mibbit@moz-E3F6DBC6.eastlink.ca)
[15:05:17] <cmr> z0w0: of rustdoc?
[15:05:21] <z0w0> that's actually my biggest annoyance with the current rustdoc
[15:05:24] <z0w0> yeah
[15:05:26] <MaikKlein> once all methods a resolved to id's in a hashmap can I get information like types and names? or are they gone?
[15:05:32] <cmr> yeah, I think that's going to be my biggest problem too
[15:05:49] <HomeGlobalGamers> YOUING PRIMARY GAMES
[15:05:56] *** Quits: HomeGlobalGamers (Mibbit@moz-E3F6DBC6.eastlink.ca) (Quit: http://www.mibbit.com ajax IRC Client)
[15:06:21] *** Joins: yong (chatzilla@74DA0C97.4E87ADC2.263D9828.IP)
[15:06:21] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[15:06:31] <z0w0> wat
[15:06:32] *** Joins: tutle (Mibbit@moz-6DA639AF.w80-13.abo.wanadoo.fr)
[15:06:37] <doener> cmr: that's the one that you had at 150s before, right?
[15:07:30] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Quit: Leaving.)
[15:08:00] *** Quits: Sodel_the_V (user@moz-853663E1.va.shawcable.net) (Quit: Eaten by a grue)
[15:08:23] <cmr> doener: no, thatwas the one I had at 127.98
[15:08:56] <doener> cmr: but that's _before_ the refactoring
[15:08:59] <cmr> I don't actually know that I was grabbing the right number...
[15:09:10] <cmr> doener: oh, right
[15:09:45] *** Quits: tutle (Mibbit@moz-6DA639AF.w80-13.abo.wanadoo.fr) (sand.mozilla.org gravel.mozilla.org)
[15:09:45] *** Quits: yong (chatzilla@74DA0C97.4E87ADC2.263D9828.IP) (sand.mozilla.org gravel.mozilla.org)
[15:09:45] *** Quits: jensnock_ (jensnocker@moz-8BE55278.customer.t3.se) (sand.mozilla.org gravel.mozilla.org)
[15:09:45] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (sand.mozilla.org gravel.mozilla.org)
[15:09:45] *** Quits: cdidd (cdidd@moz-664B49E1.broadband.corbina.ru) (sand.mozilla.org gravel.mozilla.org)
[15:09:45] *** Quits: z0w0 (zack@moz-DD233ABD.lnse4.woo.bigpond.net.au) (sand.mozilla.org gravel.mozilla.org)
[15:09:45] *** Quits: Blei (philipp@moz-650B9C6A.cust.bluewin.ch) (sand.mozilla.org gravel.mozilla.org)
[15:09:45] *** Quits: spider-mario (spidermari@moz-B8FA2FF4.rev.sfr.net) (sand.mozilla.org gravel.mozilla.org)
[15:09:45] *** Quits: MaikKlein (maik@moz-E6D51931.dip0.t-ipconnect.de) (sand.mozilla.org gravel.mozilla.org)
[15:09:45] *** Quits: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk) (sand.mozilla.org gravel.mozilla.org)
[15:09:45] *** Quits: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP) (sand.mozilla.org gravel.mozilla.org)
[15:09:45] *** Quits: pyrac (pyrac@moz-9180E00E.w86-201.abo.wanadoo.fr) (sand.mozilla.org gravel.mozilla.org)
[15:09:46] *** Quits: doener (doener@moz-121949B3.unitymediagroup.de) (sand.mozilla.org gravel.mozilla.org)
[15:09:46] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (sand.mozilla.org gravel.mozilla.org)
[15:09:46] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (sand.mozilla.org gravel.mozilla.org)
[15:09:46] *** Quits: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com) (sand.mozilla.org gravel.mozilla.org)
[15:09:46] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (sand.mozilla.org gravel.mozilla.org)
[15:09:46] *** Quits: EXetoC (ex@moz-2DBEB1E4.customer.t3.se) (sand.mozilla.org gravel.mozilla.org)
[15:09:46] *** Quits: heftig (heftig@moz-DDC44F26.dip0.t-ipconnect.de) (sand.mozilla.org gravel.mozilla.org)
[15:09:46] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (sand.mozilla.org gravel.mozilla.org)
[15:09:46] *** Quits: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com) (sand.mozilla.org gravel.mozilla.org)
[15:09:46] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (sand.mozilla.org gravel.mozilla.org)
[15:09:46] *** Quits: mblbruce (mblbruce@moz-D00392B8.fagotten.org) (sand.mozilla.org gravel.mozilla.org)
[15:09:46] *** Quits: H4199 (chatzilla@moz-64E556D3.austin.res.rr.com) (sand.mozilla.org gravel.mozilla.org)
[15:09:46] *** Quits: Ralith (ralith@moz-50F3C77.vc.shawcable.net) (sand.mozilla.org gravel.mozilla.org)
[15:09:46] *** Quits: kimundi (kimundi@moz-3B0D7C12.dip0.t-ipconnect.de) (sand.mozilla.org gravel.mozilla.org)
[15:09:46] *** Quits: Aetherspawn (Aetherspaw@moz-8811D9F0.static.tpgi.com.au) (sand.mozilla.org gravel.mozilla.org)
[15:09:46] *** Quits: dbaupp (Thunderbir@moz-73E90475.lns20.syd6.internode.on.net) (sand.mozilla.org gravel.mozilla.org)
[15:09:46] *** Quits: dju (dju@moz-83BD5EC.dmz.me) (sand.mozilla.org gravel.mozilla.org)
[15:09:46] *** Quits: cr (anonymous@moz-21AE2A3.dip0.t-ipconnect.de) (sand.mozilla.org gravel.mozilla.org)
[15:09:46] *** Quits: ion (ion@heh.fi) (sand.mozilla.org gravel.mozilla.org)
[15:09:46] *** Quits: igl (igl@moz-960CE228.adsl.alicedsl.de) (sand.mozilla.org gravel.mozilla.org)
[15:09:46] *** Quits: illissius (illissius@moz-19397A63.catv.broadband.hu) (sand.mozilla.org gravel.mozilla.org)
[15:09:46] *** Quits: cscottnet (cscott@moz-2577C94A.net) (sand.mozilla.org gravel.mozilla.org)
[15:09:46] *** Quits: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP) (sand.mozilla.org gravel.mozilla.org)
[15:09:46] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (sand.mozilla.org gravel.mozilla.org)
[15:09:46] *** Quits: sk (sk@61A494B3.BA40E8A.AAC02D62.IP) (sand.mozilla.org gravel.mozilla.org)
[15:09:46] *** Quits: dsirenko (mitra@8E712A0.54C21BA0.9F317420.IP) (sand.mozilla.org gravel.mozilla.org)
[15:09:46] *** Quits: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk) (sand.mozilla.org gravel.mozilla.org)
[15:09:46] *** Quits: RMF (RMF@moz-8C13D5A2.dsl.telepac.pt) (sand.mozilla.org gravel.mozilla.org)
[15:09:46] *** Quits: zheng_li (zheng_li@moz-D6711E9E.xenplanet.org) (sand.mozilla.org gravel.mozilla.org)
[15:09:46] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (sand.mozilla.org gravel.mozilla.org)
[15:09:46] *** Quits: Boreeas (Boreeas@moz-F35C832D.boreeas.net) (sand.mozilla.org gravel.mozilla.org)
[15:09:47] *** Joins: Ralith (ralith@moz-50F3C77.vc.shawcable.net)
[15:10:10] <cmr> Of course the only 3 people that get split are the only 3 I'm actively conversing with
[15:10:41] *** Joins: H4199 (chatzilla@moz-64E556D3.austin.res.rr.com)
[15:11:58] *** Joins: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com)
[15:12:01] *** Joins: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk)
[15:12:04] *** Joins: heftig (heftig@moz-DDC44F26.dip0.t-ipconnect.de)
[15:12:04] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[15:12:06] *** Joins: dsirenko (mitra@8E712A0.54C21BA0.9F317420.IP)
[15:12:06] *** Joins: cdidd (cdidd@moz-664B49E1.broadband.corbina.ru)
[15:12:10] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[15:12:14] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[15:12:16] *** Joins: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP)
[15:12:16] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[15:12:19] *** Joins: RMF (RMF@moz-8C13D5A2.dsl.telepac.pt)
[15:12:21] *** Joins: MaikKlein (maik@moz-E6D51931.dip0.t-ipconnect.de)
[15:12:22] *** Joins: dju (dju@moz-83BD5EC.dmz.me)
[15:12:23] *** Joins: kimundi (kimundi@moz-3B0D7C12.dip0.t-ipconnect.de)
[15:12:24] *** Joins: igl (igl@moz-960CE228.adsl.alicedsl.de)
[15:12:24] *** Joins: doener (doener@moz-121949B3.unitymediagroup.de)
[15:12:24] *** Joins: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com)
[15:12:25] *** Joins: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk)
[15:12:27] *** Joins: ion (ion@heh.fi)
[15:12:27] *** concrete.mozilla.org sets mode: +R 
[15:12:36] *** Joins: sk (sk@61A494B3.BA40E8A.AAC02D62.IP)
[15:12:47] <MaikKlein> was the irc down?
[15:13:01] <cmr> One of the servers went down I think
[15:13:11] <SiegeLord> Yeah, the workspace bit of rustpkg is unclear even after re-reading the documentation
[15:13:17] *** Joins: Blei (philipp@moz-650B9C6A.cust.bluewin.ch)
[15:13:20] <doener> cmr: so there was probably just a mislabeling? Times matched the commits, but commits were marked wrongly as before/after?
[15:13:30] <cmr> doener: maybe!
[15:13:34] *** Joins: askalski (akuda@moz-F98A7193.neoplus.adsl.tpnet.pl)
[15:13:37] <cmr> second one is almost done
[15:14:47] *** Quits: vcl (chatzilla@1137E56D.76F9E272.DA40C4B3.IP) (Ping timeout)
[15:15:52] *** Joins: zheng_li (zheng_li@moz-D6711E9E.xenplanet.org)
[15:16:21] <MaikKlein> oh there was a massive change in rustc in the last 7 days?
[15:16:36] <cmr> MaikKlein: there were some refactorings in trans
[15:16:49] <MaikKlein> cmr, hm okay then I am just stupid
[15:16:52] <cmr> doener: ok, it shows as faster again
[15:17:30] *** concrete.mozilla.org sets mode: -R 
[15:17:32] *** Joins: dbaupp (Thunderbir@moz-73E90475.lns20.syd6.internode.on.net)
[15:17:46] <cmr> doener: https://gist.github.com/cmr/4623e782147cac2f72bd
[15:17:57] <cmr> doener: I added a git rev-parse HEAD immediately before to *ensure* I wasn't mixing them up
[15:18:15] <cmr> Slightly faster, essentially the same.
[15:18:18] <cmr> Which is what the graph showed
[15:18:24] <hoelzro> how do you do labelled loops in rust HEAD? label: loop { ... }, right?
[15:18:37] <cmr> hoelzro: 'label: ...
[15:18:44] <cmr> hoelzro: I don't actually know how the feature works though :)
[15:18:48] <hoelzro> hmm
[15:19:28] <cmr> https://github.com/mozilla/rust/blob/master/src/test/run-pass/labeled-break.rs
[15:19:47] <cmr> Why is that xfail'd
[15:20:02] <cmr> it runs here...
[15:20:29] <dbaupp> same
[15:21:16] <hoelzro> same
[15:22:08] <doener> cmr: hm, you're running under gnu time, not bash's built-in time. That does some accounting. I'll run with that, too
[15:22:25] <cmr> zsh's builtin, actually, I think
[15:22:26] <hoelzro> wee! I think I found a bug!
[15:22:50] <doener> hm, ok, then I'll try gnu time first, then install zsh
[15:22:50] *** Joins: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP)
[15:22:52] <cmr> yeah it's zsh's builtin
[15:22:59] <cmr> I did initially do the measurements with gnu time
[15:23:25] *** Quits: kyle2000 (kyle2000@6EDB4D7A.341FCD98.3031298E.IP) (Quit: Leaving)
[15:23:45] <hoelzro> https://gist.github.com/hoelzro/5841254
[15:23:57] <hoelzro> is that error message unexpected?
[15:25:37] <dbaupp> hoelzro: I get "internal compiler error: Break to unknown label"
[15:25:49] <dbaupp> how strange
[15:25:51] <cmr> Oh it's because of the closure I bet
[15:25:52] <hoelzro> dbaupp: on which version of Rust?
[15:25:58] <hoelzro> mhmm
[15:26:00] <hoelzro> that's my guess
[15:26:00] <cmr> freakin' for closures always ruin everything
[15:26:05] * cmr hates them
[15:26:05] <hoelzro> mwahaha
[15:26:32] <dbaupp> hoelzro: yesterday
[15:26:45] <cmr> "yesterday" is a very invalid version :p
[15:26:47] <hoelzro> hmm
[15:27:25] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[15:27:30] <dbaupp> and with f886520 (which is today, maybe?) I get the same error
[15:28:11] *** Joins: mblbruce (mblbruce@moz-D00392B8.fagotten.org)
[15:28:24] <hoelzro> I get the pasted error using Rust pulled from about an hour or two ago
[15:29:18] <hoelzro> and that shadowing behavior is present on HEAD as well
[15:29:46] <dbaupp> strange (my rust is exactly one patch out-of-date)
[15:30:19] <dbaupp> (admittedly it's a pretty big one, but it probably shouldn't've affected that part of the code.)
[15:30:43] <dbaupp> also, acrichto will have a lot of notifications from bors https://github.com/mozilla/rust/commit/88534aedfa357adbf6600e0aae1b4fcd77e3b10f
[15:31:17] <dbaupp> and Blei too https://github.com/mozilla/rust/commit/8066dfd4ad24c011f581c80b818ac352711a5942
[15:32:53] <doener> cmr: I give up. gnu time and zsh make no difference and I'm out of ideas
[15:33:43] <SiegeLord> I wonder where bright green is more visible...
[15:34:38] <cmr> doener: It is weird...
[15:35:52] <MaikKlein> does someone know if I can get names out of a defmap? Or are the names gone as soon as rust has parsed the source code?
[15:36:09] <cmr> MaikKlein: hang on a sec I think I've done this before..
[15:36:56] <cmr> hm nope, that was span_to_snippet...
[15:37:01] <MaikKlein> :D
[15:37:41] <cmr> MaikKlein: session.str_of(name), is what I was thinking of.
[15:37:44] <Blei> dbaupp: so true. my inbox is totally spammed by bors
[15:39:00] *** Quits: lmandel (lmandel@556E85CD.E855F8D7.412CF160.IP) (Quit: lmandel)
[15:39:36] <dbaupp> MaikKlein: syntax::ast_map::node_id_to_str, maybe
[15:39:57] <MaikKlein> dbaupp, ah that looks reasonable thanks
[15:41:13] <cmr> rusti: type cc = char; let x: cc = 'f'; x
[15:41:14] -rusti- 'f'
[15:41:30] *** Joins: bytbox (s@moz-2E27684C.student.umd.edu)
[15:41:34] *** Joins: Boreeas (Boreeas@moz-F35C832D.boreeas.net)
[15:41:36] <dbaupp> Blei: I apologise for the part I had in bors exploding :(
[15:41:55] <dbaupp> (hopefully it wasn't 'cause I screwed something up.)
[15:42:24] <dbaupp> Blei: https://github.com/mozilla/rust/issues/7293 if you haven't seen it.
[15:44:00] * dbaupp goes to bed, hoping it'll all be fixed in the morning
[15:45:43] *** Quits: dbaupp (Thunderbir@moz-73E90475.lns20.syd6.internode.on.net) (Ping timeout)
[15:46:21] *** Quits: bytbox (s@moz-2E27684C.student.umd.edu) (sand.mozilla.org gravel.mozilla.org)
[15:46:21] *** Quits: Boreeas (Boreeas@moz-F35C832D.boreeas.net) (sand.mozilla.org gravel.mozilla.org)
[15:46:22] *** Joins: bytbox (s@moz-2E27684C.student.umd.edu)
[15:47:34] <MaikKlein> btw what does bors mean?
[15:47:49] <bct> how do i get something like this to compile?
[15:47:51] <bct> fn _head(data: &[u8]) -> &[u8] { data.slice(0, 1) } 
[15:48:39] <cmr> bct: fn _head<'a>(data: &'a [u8]) -> &'a [u8]
[15:48:46] <cmr> bct: you need explicit lifetimes
[15:48:59] <cmr> MaikKlein: it's a name taken from a book
[15:49:11] <cmr> MaikKlein: http://en.wikipedia.org/wiki/The_Last_of_the_Masters#The_last_government is linked on its github page (https://github.com/bors)
[15:49:22] *** Joins: robert (robertknig@moz-C34822AC.range86-166.btcentralplus.com)
[15:49:56] <bct> ah, thanks. i had trouble finding much information about explicit lifetimes - it's not in the tutorial and there's not much in the manual.
[15:50:11] <cmr> http://static.rust-lang.org/doc/tutorial-borrowed-ptr.html#named-lifetimes
[15:51:03] <bct> oh, of course. thanks.
[15:51:08] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[15:51:34] <MaikKlein> wow the book seems interesting 
[15:54:33] *** Joins: kkszysiu (quassel@moz-BB74E41D.neoplus.adsl.tpnet.pl)
[15:54:38] <MaikKlein> <- scifi fan
[15:56:21] <robert> Is it possible to convert a ~ptr or @ptr to &ptr without passing it to a function or using a let expression?
[15:56:59] <cmr> robert: transmute maybe
[15:57:05] *** Quits: kkszysiu (quassel@moz-BB74E41D.neoplus.adsl.tpnet.pl) (Quit: http://quassel-irc.org - Chat comfortably. Anywhere.)
[15:57:07] <cmr> Or actually
[15:57:08] *** Joins: kkszysiu (quassel@moz-BB74E41D.neoplus.adsl.tpnet.pl)
[15:57:11] <cmr> rusti: ~5 as &int
[15:57:12] -rusti- <anon>:9:9: 9:19 error: non-scalar cast: `~<VI0>` as `&int`
[15:57:12] *** Quits: kkszysiu (quassel@moz-BB74E41D.neoplus.adsl.tpnet.pl) (Connection reset by peer)
[15:57:13] -rusti- <anon>:9          ~5 as &int
[15:57:13] -rusti-                   ^~~~~~~~~~
[15:57:13] -rusti- error: aborting due to previous error
[15:57:13] -rusti- application terminated with error code 101
[15:57:32] <cmr> rusti: std::cast::transmute(~5) as &int
[15:57:34] -rusti- <anon>:9:9: 9:41 error: the type of this value must be known in this context
[15:57:34] -rusti- <anon>:9          std::cast::transmute(~5) as &int
[15:57:34] -rusti-                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[15:57:34] -rusti- error: aborting due to previous error
[15:57:34] -rusti- application terminated with error code 101
[15:57:42] <cmr> rusti: unsafe { std::cast::transmute(~5u) as &int }
[15:57:43] -rusti- <anon>:9:18: 9:51 error: the type of this value must be known in this context
[15:57:43] -rusti- <anon>:9          unsafe { std::cast::transmute(~5u) as &int }
[15:57:43] -rusti-                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[15:57:44] -rusti- error: aborting due to previous error
[15:57:44] -rusti- application terminated with error code 101
[15:57:52] <cmr> eh?
[15:58:05] <cmr> rusti: unsafe { std::cast::transmute(~5u) } as &uint
[15:58:05] -rusti- <anon>:9:44: 9:45 error: found `as` in ident position
[15:58:05] -rusti- <anon>:9          unsafe { std::cast::transmute(~5u) } as &uint
[15:58:05] -rusti-                                                      ^
[15:58:05] -rusti- error: aborting due to previous error
[15:58:06] -rusti- application terminated with error code 101
[15:58:17] <cmr> well that span is wrong
[15:58:27] <robert> cmr: In this case I just want to compare a ~str field from a struct with an &str argument passed to a function for equality
[15:58:37] <doener> rusti: let x: &int = @5;
[15:58:38] -rusti- <anon>:9:13: 9:14 warning: unused variable: `x` [-W unused-variable (default)]
[15:58:39] -rusti- <anon>:9          let x: &int = @5;
[15:58:39] -rusti-                       ^
[15:58:39] -rusti- ()
[15:58:50] <cmr> rusti: ~"foo" == foo
[15:58:51] -rusti- <anon>:9:19: 9:22 error: unresolved name `foo`.
[15:58:51] -rusti- <anon>:9          ~"foo" == foo
[15:58:51] -rusti-                             ^~~
[15:58:52] -rusti- error: aborting due to previous error
[15:58:52] -rusti- application terminated with error code 101
[15:58:52] <cmr> rusti: ~"foo" == "foo"
[15:58:53] -rusti- <anon>:9:19: 9:24 error: mismatched types: expected `~str` but found `&'static str` (str storage differs: expected ~ but found &'static )
[15:58:53] -rusti- <anon>:9          ~"foo" == "foo"
[15:58:55] -rusti-                             ^~~~~
[15:58:57] -rusti- error: aborting due to previous error
[15:58:57] *** concrete.mozilla.org sets mode: +M 
[15:58:58] <cmr> hm
[15:58:59] -rusti- application terminated with error code 101
[15:59:31] <MaikKlein> rusti:  *(~"foo") == "foo"
[15:59:32] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/dIOc
[15:59:46] <cmr> rusti: ~"foo".as_slice() == "foo"
[15:59:47] -rusti- <anon>:9:30: 9:35 error: mismatched types: expected `~&str` but found `&'static str` (expected ~-ptr but found &'static str)
[15:59:48] -rusti- <anon>:9          ~"foo".as_slice() == "foo"
[15:59:48] -rusti-                                        ^~~~~
[15:59:48] -rusti- error: aborting due to previous error
[15:59:48] -rusti- application terminated with error code 101
[15:59:55] <MaikKlein> :D
[15:59:55] <cmr> rusti: (~"foo").as_slice() == "foo"
[15:59:57] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/iKZE
[16:01:44] *** Joins: threecreepio (jdp@moz-DB2D70E9.cust.bredbandsbolaget.se)
[16:01:48] <MaikKlein> rusti: let s = ~"D"; let s1 = &s; 
[16:01:49] -rusti- <anon>:9:27: 9:29 warning: unused variable: `s1` [-W unused-variable (default)]
[16:01:49] -rusti- <anon>:9          let s = ~"D"; let s1 = &s; 
[16:01:50] -rusti-                                     ^~
[16:01:50] -rusti- ()
[16:02:22] <doener> rusti: let uniq = ~"foo"; let slice: &str = uniq;
[16:02:23] -rusti- <anon>:9:32: 9:37 warning: unused variable: `slice` [-W unused-variable (default)]
[16:02:23] -rusti- <anon>:9          let uniq = ~"foo"; let slice: &str = uniq;
[16:02:23] -rusti-                                          ^~~~~
[16:02:23] -rusti- ()
[16:02:37] <Blei> glue is so weird
[16:02:49] *** Joins: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP)
[16:03:03] <Blei> i only now noticed, that it actually only ever uses one of the 3 arguments, the first two are always null
[16:03:09] <doener> MaikKlein: yours create a &~str instead of &str
[16:03:33] <cmr> Blei: so... can you remove the first two? :D
[16:04:00] *** concrete.mozilla.org sets mode: -M 
[16:04:02] <Blei> i hope, but i'm sure it will involve much stage0 hackery ~.~
[16:04:03] <hoelzro> there's no way to clear errno from within Rust, is there?
[16:04:12] <doener> Blei: does it have a retslot? That should be removed. The envslot might be required atm
[16:04:32] <MaikKlein> rusti: let s = ~"D"; let s1 = &s; s1 
[16:04:33] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/SHRJ
[16:04:34] <doener> "required" meaning "some codepaths might expect its existence"
[16:04:36] <Blei> it doesn't have a ret slot, but the tydesc argument is never used
[16:04:50] <Blei> what kind of codepaths?
[16:05:17] <doener> Blei: IIRC the argument position calculation expects an env slot
[16:05:33] <doener> Blei: doesn't the drop glue use the tydesc?
[16:05:33] <Blei> bleh
[16:05:53] <Blei> i.. don't think so?
[16:06:03] <Blei> let me check on the rustc generated code
[16:06:37] <cmr> hoelzro: I don't think so, I had to bind SetLastError manually on windows.
[16:06:45] <hoelzro> crap.
[16:07:25] <Blei> rusti: os::set_exit_status(2);
[16:07:26] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/RbZD
[16:07:30] <cmr> hoelzro: https://github.com/mozilla/rust/blob/master/src/libstd/os.rs#L996 and below... I personally would very much like the ability to set errno cross-platformly :)
[16:07:31] <Blei> rusti: std::os::set_exit_status(2);
[16:07:31] -rusti- ()
[16:07:31] -rusti- application terminated with error code 2
[16:07:46] <cmr> Blei: errno is a TLS thing used in the libc and kernel api... not return code
[16:07:49] <Blei> oh, errno
[16:07:51] <Blei> sorry
[16:07:53] <cmr> :p
[16:08:34] *** Joins: Boreeas (Boreeas@moz-F35C832D.boreeas.net)
[16:09:45] <sully> aatch|bed: yeah, there are still a bunch of default method bugs
[16:09:48] <sully> aatch|bed: what is the one you found?
[16:10:10] <cmr> aatch|bed: he opened a PR
[16:10:12] <cmr> it's assigned to you
[16:10:16] <cmr> Or, an issue, rather
[16:10:42] <doener> hm, maybe not
[16:11:01] <Blei> doener: i couldn't find any instance of it being used
[16:11:02] <sully> aatch|bed: ah, yeah, I have a a patch for that ready to push at some point
[16:11:36] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[16:11:36] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 141b3fa05 to 14dc4560d: 02http://git.io/N3iJvQ
[16:11:36] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[16:11:39] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[16:11:39] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/_tieaA
[16:11:39] <ghrust> 13rust/06auto 148066dfd 15Philipp BrÃ¼schweiler: syntax::diagnostics: Color the ^~~~ in green for better visibility...
[16:11:39] <ghrust> 13rust/06auto 14b064ec8 15bors: auto merge of #7230 : Blei/rust/green-squiggle, r=pcwalton...
[16:11:40] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[16:14:24] <cmr> Oh lord this test is ancient
[16:14:46] <cmr> https://github.com/mozilla/rust/blob/master/src/test/run-pass/class-cast-to-trait-cross-crate.rs
[16:15:08] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[16:15:08] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14b064ec8 to 14dc4560d: 02http://git.io/N3iJvQ
[16:15:08] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[16:15:09] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[16:15:09] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/e-RLAA
[16:15:09] <ghrust> 13rust/06auto 1488534ae 15Alex Crichton: Fix compiling empty fmt! strings
[16:15:09] <ghrust> 13rust/06auto 14bdb51dd 15bors: auto merge of #7227 : alexcrichton/rust/issue-7218, r=brson...
[16:15:10] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[16:19:37] <mblbruce> The bug related to borrowed ptrs to traits, is it a blocker for 0.7?
[16:20:24] <engla> is bors walking in circles?
[16:21:09] <cmr> engla: yup
[16:21:24] <cmr> mblbruce: probably not
[16:21:26] *** Quits: askalski (akuda@moz-F98A7193.neoplus.adsl.tpnet.pl) (Quit: Wychodzi)
[16:21:31] <cmr> mblbruce: it's not a new bug
[16:22:21] <cmr> mblbruce: https://github.com/mozilla/rust/issues?milestone=10&state=open
[16:22:43] *** Joins: rajul (quassel@A2DDF553.812B5995.2051BA92.IP)
[16:23:29] *** Quits: rajul (quassel@A2DDF553.812B5995.2051BA92.IP) (sand.mozilla.org gravel.mozilla.org)
[16:23:29] *** Quits: Boreeas (Boreeas@moz-F35C832D.boreeas.net) (sand.mozilla.org gravel.mozilla.org)
[16:24:14] <mblbruce> cmr: Ok. So milestone 10 is 0.7 and it currently has 27 blockers?
[16:24:34] *** Joins: rajul (quassel@A2DDF553.812B5995.2051BA92.IP)
[16:24:41] <cmr> mblbruce: none of them are real blockers, some might slip. but yes.
[16:24:48] <cmr> https://github.com/mozilla/rust/issues/milestones btw
[16:26:34] <mblbruce> cmr: Are the milestone due dates automatically derived through issue completion statistics or are they manually set?
[16:26:43] <cmr> mblbruce: manually
[16:27:02] <cmr> mblbruce: 0.7 will be released in 8 days, unless the tree explodes and catches on fire.
[16:27:30] <hoelzro> ptr::offset(ptr, offset) is the Rust equivalent of ptr + offset, right?
[16:28:10] <cmr> hoelzro: no, that's the Rust equivalent of ptr[count]
[16:28:35] <cmr> Oh, wait, yes.
[16:28:37] <cmr> You are right
[16:28:43] <cmr> I forgot pointer arith there for a second
[16:29:13] <cmr> bblum: ping
[16:32:02] <hoelzro> hmm
[16:32:08] <hoelzro> it doesn't seem to be working for me =(
[16:34:56] <mblbruce> cmr: Out of curiosity, are there any wild guesstimations for the other milestones?
[16:35:06] <cmr> mblbruce: nope
[16:35:22] <cmr> mblbruce: initially 1.0 was planned for by-the-end-of-the-year
[16:35:31] <cmr> which corresponds roughly to the backwards-compatible milestone
[16:37:15] *** Joins: pyrac (pyrac@moz-9180E00E.w86-201.abo.wanadoo.fr)
[16:38:20] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[16:39:22] *** Quits: MaikKlein (maik@moz-E6D51931.dip0.t-ipconnect.de) (Ping timeout)
[16:39:43] *** Joins: _1126 (1126@moz-83D60E55.lileth.net)
[16:49:36] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[16:50:04] *** Joins: Boreeas (Boreeas@moz-F35C832D.boreeas.net)
[16:51:05] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[16:51:05] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14bdb51dd to 14dc4560d: 02http://git.io/N3iJvQ
[16:51:05] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[16:51:23] *** Quits: Boreeas (Boreeas@moz-F35C832D.boreeas.net) (sand.mozilla.org gravel.mozilla.org)
[16:51:23] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (sand.mozilla.org gravel.mozilla.org)
[16:51:35] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[16:51:37] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[16:51:37] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/oa_6zA
[16:51:37] <ghrust> 13rust/06auto 148066dfd 15Philipp BrÃ¼schweiler: syntax::diagnostics: Color the ^~~~ in green for better visibility...
[16:51:37] <ghrust> 13rust/06auto 143079f1c 15bors: auto merge of #7230 : Blei/rust/green-squiggle, r=pcwalton...
[16:51:37] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[16:52:02] * acrichto wakes up to 38 bors emails for one PR
[16:52:45] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[16:52:45] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 143079f1c to 14dc4560d: 02http://git.io/N3iJvQ
[16:52:45] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[16:52:47] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[16:52:47] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/1dHLAw
[16:52:47] <ghrust> 13rust/06auto 1488534ae 15Alex Crichton: Fix compiling empty fmt! strings
[16:52:47] <ghrust> 13rust/06auto 143cf7281 15bors: auto merge of #7227 : alexcrichton/rust/issue-7218, r=brson...
[16:52:47] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[16:54:38] <engla> bors I think you ruined your chances of getting contributor of the month again
[17:01:22] *** Joins: sankha93 (Instantbir@45B9B9EE.11A4F4B4.CA052C06.IP)
[17:01:22] *** Joins: illissius (illissius@moz-19397A63.catv.broadband.hu)
[17:06:54] *** Quits: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[17:08:31] *** Joins: cowp (Mibbit@moz-9FE842F.cpe.net.cable.rogers.com)
[17:08:34] *** Joins: Boreeas (Boreeas@moz-F35C832D.boreeas.net)
[17:08:42] <cmr> rusti: let x = 42u; x.to_str()
[17:08:44] *** Joins: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net)
[17:08:44] -rusti- ~"42"
[17:08:48] *** cowp is now known as caitp
[17:09:10] *** Parts: caitp (Mibbit@moz-9FE842F.cpe.net.cable.rogers.com) ()
[17:09:56] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[17:10:44] *** Joins: vk (chatzilla@moz-389FEE13.hsd1.ca.comcast.net)
[17:11:47] *** Parts: mblbruce (mblbruce@moz-D00392B8.fagotten.org) ()
[17:11:53] <bblum> cmr: pong
[17:12:18] *** Joins: infynyxx (infynyxx@moz-3F965C5E.sub-70-193-6.myvzw.com)
[17:12:21] <cmr> I... don't remember what i was going to ask you
[17:12:30] <cmr> I think it was about https://github.com/mozilla/rust/issues/7303
[17:12:45] <cmr> I'm not sure about that though
[17:15:23] <bblum> is it xfailed or something
[17:15:31] <cmr> yes
[17:15:35] <cmr> I'm going through all the xfailed
[17:15:40] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[17:15:53] <cmr> Unsurprisingly, most of them actually work or test year+ old language features
[17:18:09] *** Joins: BitPuffin (quassel@moz-49828767.cust.tele2.se)
[17:23:32] *** Quits: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk) (Connection reset by peer)
[17:23:39] *** Quits: infynyxx (infynyxx@moz-3F965C5E.sub-70-193-6.myvzw.com) (Client exited)
[17:24:24] *** Joins: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk)
[17:30:31] *** Joins: jrfeenst (jrfeenst@moz-F912484F.cpe.norwoodlight.com)
[17:30:51] *** Joins: cr (anonymous@moz-21AE2A3.dip0.t-ipconnect.de)
[17:35:15] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[17:36:12] *** Joins: kyle2000 (kyle2000@6EDB4D7A.341FCD98.3031298E.IP)
[17:42:07] *** Quits: bytbox (s@moz-2E27684C.student.umd.edu) (Ping timeout)
[17:43:28] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[17:46:12] *** Joins: spider-mario (spidermari@moz-B8FA2FF4.rev.sfr.net)
[17:46:25] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[17:47:44] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[17:48:32] *** Quits: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net) (Ping timeout)
[17:48:47] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[17:54:16] *** Quits: kyle2000 (kyle2000@6EDB4D7A.341FCD98.3031298E.IP) (Quit: Leaving)
[17:54:42] *** Quits: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu) (Connection reset by peer)
[17:56:01] *** Joins: xazax (xazax@moz-EC71964B.pool77-111.dyn.tolna.net)
[17:56:05] <xazax> hi
[17:56:21] <xazax> what is the idiomatic way now to parse an str to an int?
[17:58:20] <cmr> rusti: let x = "123"; let y: i8 = std::i8::from_str(x)
[17:58:20] -rusti- <anon>:10:4: 10:5 error: expected `;` but found `}`
[17:58:20] -rusti- <anon>:10     };
[17:58:20] -rusti-               ^
[17:58:20] -rusti- application terminated with error code 101
[17:58:24] <cmr> rusti: let x = "123"; let y: i8 = std::i8::from_str(x); y
[17:58:24] -rusti- <anon>:9:36: 9:57 error: mismatched types: expected `i8` but found `std::option::Option<i8>` (expected i8 but found enum std::option::Option)
[17:58:24] -rusti- <anon>:9          let x = "123"; let y: i8 = std::i8::from_str(x); y
[17:58:24] -rusti-                                              ^~~~~~~~~~~~~~~~~~~~~
[17:58:25] -rusti- error: aborting due to previous error
[17:58:27] -rusti- application terminated with error code 101
[17:58:27] *** concrete.mozilla.org sets mode: +M 
[17:58:39] <cmr> rusti: let x = "123"; let y: i8 = std::i8::from_str(x).unwrap(); y
[17:58:41] -rusti- 123
[17:58:46] <cmr> xazax: like that I think
[17:59:03] <cmr> xazax: I thought int and stuff implemented http://static.rust-lang.org/doc/std/from_str.html#trait-fromstr
[17:59:16] <cmr> bjz_: did you change that around during numeric reform?
[18:01:53] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[18:03:30] *** concrete.mozilla.org sets mode: -M 
[18:04:25] *** Quits: dew (Instantbir@moz-66796D51.dhcp.stls.mo.charter.com) (Ping timeout)
[18:06:02] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Quit: WeeChat 0.4.1)
[18:07:41] *** Quits: bytbox (s@moz-D83E9B31.wireless.umd.edu) (Ping timeout)
[18:11:59] *** Joins: bytbox (s@moz-2E27684C.student.umd.edu)
[18:13:04] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[18:13:43] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[18:13:43] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 143cf7281 to 14dc4560d: 02http://git.io/N3iJvQ
[18:13:43] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[18:13:45] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[18:13:45] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/LCMz1A
[18:13:45] <ghrust> 13rust/06auto 148066dfd 15Philipp BrÃ¼schweiler: syntax::diagnostics: Color the ^~~~ in green for better visibility...
[18:13:45] <ghrust> 13rust/06auto 14c2e8a3c 15bors: auto merge of #7230 : Blei/rust/green-squiggle, r=pcwalton...
[18:13:45] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[18:15:00] *** Quits: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP) (Ping timeout)
[18:15:09] *** Quits: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP) (Ping timeout)
[18:16:58] *** Joins: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP)
[18:16:59] *** Joins: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net)
[18:17:15] *** Joins: MaikKlein (maik@moz-E6D51931.dip0.t-ipconnect.de)
[18:18:25] <MaikKlein> hm
[18:18:30] <cmr> How can I move a port into a heap closure? That is, I have `do spawn { ... }` and I want to capture a port
[18:18:31] <MaikKlein> how do I reverse a string?
[18:19:49] <cmr> rusti: "foo".reverse()
[18:19:50] -rusti- <anon>:9:9: 10:5 error: type `&'static str` does not implement any method in scope named `reverse`
[18:19:52] -rusti- <anon>:9          "foo".reverse()
[18:19:52] -rusti- <anon>:10     };
[18:19:52] -rusti- error: aborting due to previous error
[18:19:52] -rusti- application terminated with error code 101
[18:19:52] <engla> there is rev_iter at least, but the usual unicode cautions apply
[18:20:01] <cmr> oh
[18:20:22] <cmr> rusti: let x: ~str = "foo".rev_iter().collect(); x
[18:20:23] -rusti- <anon>:9:23: 9:50 error: failed to find an implementation of trait std::iter::FromIter<char> for ~str
[18:20:23] -rusti- <anon>:9          let x: ~str = "foo".rev_iter().collect(); x
[18:20:23] -rusti-                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[18:20:23] -rusti- application terminated with error code 101
[18:20:38] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[18:20:39] <cmr> rusti: let x: ~[char] = "foo".rev_iter().collect(); x
[18:20:41] -rusti- ~['o', 'o', 'f']
[18:20:42] <MaikKlein> ah yeah I completely forgot about collect
[18:20:59] <cmr> rusti: let x: ~[char] = "fâ˜Žoâ˜Žo".rev_iter().collect(); x
[18:21:00] -rusti- ~['o', '\u260e', 'o', '\u260e', 'f']
[18:21:03] <MaikKlein> hm
[18:21:14] <MaikKlein> does collect always make a vector?
[18:21:17] <cmr> rusti: let x: ~[char] = "fâ˜Žoâ˜Žo".rev_iter().collect(); x.to_str()
[18:21:19] -rusti- <anon>:9:54: 10:5 error: failed to find an implementation of trait std::to_str::ToStr for char
[18:21:19] -rusti- <anon>:9          let x: ~[char] = "fâ˜Žoâ˜Žo".rev_iter().collect(); x.to_str()
[18:21:19] -rusti- <anon>:10     };
[18:21:19] -rusti- application terminated with error code 101
[18:21:25] <cmr> MaikKlein: I don't think it has to
[18:21:25] <engla> collect is only implemented for ~[T] at the moment
[18:21:39] <bblum> collect should well be implemented for any container
[18:21:47] <engla> it needs FromIter at the moment, will be FromIterator
[18:22:00] <engla> so a new trait is waiting, and then we can implement it for the collections
[18:22:00] <MaikKlein> rusti: let x: ~str = "foo".rev_iter().collect(); x
[18:22:01] -rusti- <anon>:9:23: 9:50 error: failed to find an implementation of trait std::iter::FromIter<char> for ~str
[18:22:01] -rusti- <anon>:9          let x: ~str = "foo".rev_iter().collect(); x
[18:22:01] -rusti-                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[18:22:02] -rusti- application terminated with error code 101
[18:22:07] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[18:22:08] <MaikKlein> rusti: let x: ~str = ~"foo".rev_iter().collect(); x
[18:22:10] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/YGjJ
[18:22:11] <bblum> too bad we don't have HKT
[18:22:14] <bblum> or you could do
[18:22:23] <bblum> fn collect<C: Collection<T>, T>(iterator<T>) -> C<T>
[18:22:32] <bblum> it would be so leet
[18:22:47] <bblum> oh wait, you don't need hkt
[18:22:50] <bblum> fn collect<C: Collection<T>, T>(iterator<T>) -> C
[18:23:09] *** Quits: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net) (Ping timeout)
[18:23:13] <bblum> iterator.collect::<Tree<T>>()
[18:23:13] <MaikKlein> is str a collection?
[18:23:18] <MaikKlein> of chars?
[18:23:23] <cmr> yes
[18:24:03] <MaikKlein> rusti: let x = ~"foo".rev_iter().collect(); x
[18:24:04] -rusti- <anon>:9:18: 9:45 error: cannot determine a type for this bounded type parameter: unconstrained type
[18:24:04] -rusti- <anon>:9          let x = ~"foo".rev_iter().collect(); x
[18:24:04] -rusti-                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[18:24:04] -rusti- application terminated with error code 101
[18:24:57] <MaikKlein> rusti: let s = ~"foo"; let x: ~str = s.rev_iter().collect(); x
[18:24:58] -rusti- <anon>:9:39: 9:62 error: failed to find an implementation of trait std::iter::FromIter<char> for ~str
[18:24:58] -rusti- <anon>:9          let s = ~"foo"; let x: ~str = s.rev_iter().collect(); x
[18:24:58] -rusti-                                                 ^~~~~~~~~~~~~~~~~~~~~~~
[18:24:58] -rusti- application terminated with error code 101
[18:25:21] <MaikKlein> hm
[18:25:38] <engla> bblum: it will be possible yes
[18:26:01] *** Quits: diegoyam (quassel@FF9B1514.A4EC3D18.3A1EC144.IP) (Ping timeout)
[18:26:36] <MaikKlein> how would I need to write this? let x: ~str = ~"foo".rev_iter().collect(); x
[18:26:48] <cmr> MaikKlein: there is no FromIter for ~str yet
[18:26:54] <MaikKlein> ah okay
[18:27:03] <cmr> You need to collect into a ~[char] and turn that into a str... I don't know how :p
[18:27:52] <MaikKlein> rusti: [~"Hello"].toStr();
[18:27:52] -rusti- <anon>:9:9: 9:28 error: type `[~str, .. 1]` does not implement any method in scope named `toStr`
[18:27:53] -rusti- <anon>:9          [~"Hello"].toStr();
[18:27:53] -rusti-                   ^~~~~~~~~~~~~~~~~~~
[18:27:53] -rusti- error: aborting due to previous error
[18:27:53] -rusti- application terminated with error code 101
[18:28:01] <MaikKlein> rusti: [~"Hello"].to_str();
[18:28:02] -rusti- ()
[18:28:10] <cmr> a ~[char]  is
[18:28:19] <cmr> rusti: let x = ~['a', 'b', 'c']; x
[18:28:20] -rusti- ~['a', 'b', 'c']
[18:28:47] <cmr> rusti: let x = ~['a', 'b', 'c']; str::from_chars(x)
[18:28:49] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/ebKX
[18:28:56] <cmr> rusti: let x = ~['a', 'b', 'c']; std::str::from_chars(x)
[18:28:58] -rusti- ~"abc"
[18:29:04] <cmr> MaikKlein: there we go ^_^
[18:29:27] <MaikKlein> ah 
[18:29:48] <MaikKlein> rusti: ['a'].to_str();
[18:29:49] -rusti- <anon>:9:9: 9:24 error: failed to find an implementation of trait std::to_str::ToStr for char
[18:29:49] -rusti- <anon>:9          ['a'].to_str();
[18:29:49] -rusti-                   ^~~~~~~~~~~~~~~
[18:29:49] -rusti- application terminated with error code 101
[18:30:02] *** Joins: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP)
[18:30:23] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[18:30:34] *** Quits: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP) (Quit: buildmaster reconfigured: bot disconnecting)
[18:31:03] <MaikKlein> rusti: let x: ~[char] = ~"foo".rev_iter().collect(); x
[18:31:05] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/QWBd
[18:31:48] <cmr> rusti: let x: ~[char] = (~"foo").rev_iter().collect(); x
[18:31:49] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/AeZJ
[18:32:41] <cmr> rusti: let s = ~""fâ˜Žoâ˜Žo"; let x: ~[char] = s.rev_iter().collect(); x
[18:32:41] -rusti- <anon>:9:21: 9:21 error: unknown start of token: 9742
[18:32:42] -rusti- <anon>:9          let s = ~""fâ˜Žoâ˜Žo"; let x: ~[char] = s.rev_iter().collect(); x
[18:32:42] -rusti-                               ^
[18:32:42] -rusti- application terminated with error code 101
[18:32:46] <cmr> rusti: let s = ~"fâ˜Žoâ˜Žo"; let x: ~[char] = s.rev_iter().collect(); x
[18:32:47] -rusti- ~['o', '\u260e', 'o', '\u260e', 'f']
[18:32:59] <cmr> rusti: let s = ~"fâ˜Žoâ˜Žo"; let x: ~[char] = s.rev_iter().collect(); std::str::from_chars(x)
[18:33:00] -rusti- ~"o\u260eo\u260ef"
[18:33:07] <cmr> rusti: let s = ~"fâ˜Žoâ˜Žo"; let x: ~[char] = s.rev_iter().collect(); println(std::str::from_chars(x));
[18:33:09] -rusti- oâ˜Žoâ˜Žf
[18:33:09] -rusti- ()
[18:33:11] <MaikKlein>  rusti: let x: ~[char] = "foo".rev_iter().collect(); std::str::from_chars(x)
[18:33:21] <MaikKlein> .
[18:33:25] <MaikKlein> rusti: let x: ~[char] = "foo".rev_iter().collect(); std::str::from_chars(x)
[18:33:26] -rusti- ~"oof"
[18:33:54] <Blei> segfaults, segfaults everywhere
[18:33:55] *** Joins: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP)
[18:34:19] <Blei> that's why i'm using rust! but it doesn't help!1!
[18:35:09] *** Quits: vk (chatzilla@moz-389FEE13.hsd1.ca.comcast.net) (Ping timeout)
[18:35:17] <MaikKlein> :D
[18:37:41] <engla> MaikKlein: the standard unicode cautions are that you risk to split codepoints that should be together
[18:37:49] <engla> placing the combining characters before the horse and so on
[18:38:03] <engla> (about reversing ~str)
[18:38:23] <cmr> silly unicode
[18:38:29] <cmr> silly non-english languages
[18:38:32] <cmr> making everything hard :(
[18:38:58] <engla> since 1993
[18:39:02] <engla> or whenever utf-8 debuted
[18:39:13] <engla> somewhere around then
[18:40:07] *** Joins: infynyxx (infynyxx@moz-246C4FFD.sub-70-193-2.myvzw.com)
[18:40:20] <engla> is it naÃ¯ve to think english can fit inside ascii?
[18:42:19] <Blei> engla: stop impressing people with your encyclopÃ¦dic knowledge
[18:42:46] *** Quits: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com) (Quit: Textual IRC Client: www.textualapp.com)
[18:43:52] <engla> <Blei> (â•¯Â°â–¡Â°ï¼‰â•¯ï¸µ â”»â”â”»
[18:44:53] <Blei> (ãƒŽï½€Ð”Â´)ãƒŽå½¡â”»â”â”»
[18:44:55] <MaikKlein> not the cleanest example of visitor in rust https://gist.github.com/MaikKlein/5842059 what can I improve?
[18:45:09] <cmr> MaikKlein: what is a visitor?
[18:45:21] <MaikKlein> visitor pattern
[18:45:26] <cmr> I don't know what that is
[18:45:42] <MaikKlein> i think functors are similar
[18:45:52] <MaikKlein> just read the code
[18:45:53] <cmr> I don't know what those are either :p
[18:45:54] <MaikKlein> :D
[18:46:00] *** Quits: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP) (Ping timeout)
[18:46:33] *** Joins: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP)
[18:46:34] <MaikKlein> so that you can easily add behavior without changing existent code
[18:47:05] <MaikKlein> i think I should make a real life example
[18:47:36] <cmr> I think it's a good example of trait objects, fwiw :p
[18:47:53] <doomlord> na
[18:48:02] <MaikKlein> i don't even know what trait objects are
[18:48:03] <doomlord> anyone here used rust from a host C/C++ program?
[18:48:09] <MaikKlein> :p
[18:48:19] <MaikKlein> v: &'r Visitor<~str> this?
[18:48:19] <doomlord> is that possible .. some modules in rust with a C interface, called from c++
[18:48:21] <cmr> MaikKlein: &Trait, like &PrintVisistor
[18:48:26] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[18:48:32] <cmr> doomlord: sure. extern "C" fn(...) { ... }
[18:48:43] <cmr> doomlord: you need to do rustc -c, though, and link yourself
[18:48:55] <doomlord> and just stuff them in my main project makefile..
[18:49:09] <MaikKlein> cmr, just a struct that useses a trait?
[18:49:13] <doomlord> i'd get similar object files out of it?
[18:49:16] <MaikKlein> uses*
[18:49:45] <cmr> doomlord: you'd get object files you could link to in c/c++. you can only call extern "C" functions though (exactly how C++ does it)
[18:50:06] <cmr> MaikKlein: Do you know what a vtable is?
[18:51:05] <MaikKlein> cmr, not really, but I saw that often in rustc :P I thought of it as a lookup table or sth
[18:51:18] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Quit: Leaving.)
[18:51:50] <MaikKlein> ah http://en.wikipedia.org/wiki/Virtual_method_table
[18:51:55] <cmr> MaikKlein: yeah, it's a lookup table of methods. So basically a trait object is a pointer to a datum, and a pointer to a vtable. For any given trait object &Trait, the vtable will always be the same
[18:51:59] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[18:51:59] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14c2e8a3c to 14dc4560d: 02http://git.io/N3iJvQ
[18:51:59] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[18:52:01] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[18:52:01] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/ynuuUQ
[18:52:01] <ghrust> 13rust/06auto 14de471a2 15Philipp BrÃ¼schweiler: Fix take glue of owned trait objects...
[18:52:01] <ghrust> 13rust/06auto 14f39d8a8 15bors: auto merge of #7214 : Blei/rust/fix-owned-traits, r=pcwalton...
[18:52:01] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[18:52:06] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[18:52:14] *** Quits: infynyxx (infynyxx@moz-246C4FFD.sub-70-193-2.myvzw.com) (Client exited)
[18:52:32] *** Joins: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net)
[18:52:56] <cmr> So when you do "v as &Visitor<~str>", it is creating a "Visitor' vtable for PrintVisitor, that has a "visit" method that is looked up, and knows how to deal with the struct PrintVisitor
[18:53:35] <cmr> That way you can call the Visitor methods on any struct that has a Visitor impl.
[18:53:41] <MaikKlein> ok then I knew what it was :)
[18:53:56] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Ping timeout)
[18:54:00] <cmr> That's what a trait object is.
[18:54:01] *** Joins: steven_is_false (user@B3396033.459BA655.23E4E477.IP)
[18:54:07] <MaikKlein> ok thanks
[18:54:20] <cmr> https://github.com/mozilla/rust/wiki/Doc-lowlevel-details documents this a little
[18:55:57] <MaikKlein> I wonder if I could do the same thing with static dispatch
[18:56:17] *** Quits: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP) (Ping timeout)
[18:56:45] <MaikKlein> i think I probably could
[18:57:17] <cmr> Yup. should be able to do impl<T: Visitor<~str> SomeObject { fn do_sth(&self, v: &T, s: ~str) { v.visist(s) }, I think
[18:57:29] <cmr> something like that :p
[18:57:56] <MaikKlein> ok now I know the difference, I always thought it would be the same
[18:57:59] *** Joins: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP)
[18:58:03] *** Quits: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net) (Ping timeout)
[18:58:17] <cmr> nope
[18:58:43] <MaikKlein> yeah I realized that now :)
[18:58:47] <MaikKlein> but it looked so similar
[18:59:54] <MaikKlein> its probably because every "generic" in rust is generated by the compiler at compile time and by generic I mean impl<T: Visitor<~str 
[19:00:21] <MaikKlein> so "generic" is just static/dynamic dispatch?
[19:00:34] <cmr> Generics like that are always static dispatch
[19:00:51] <cmr> Trait objects are the only way to get dynamic dispatch
[19:01:32] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[19:02:12] <Blei> looks good, 1 argument down
[19:02:20] <Blei> let's see if the unit tests explode
[19:02:51] *** Quits: steven_is_false (user@B3396033.459BA655.23E4E477.IP) (Ping timeout)
[19:03:21] <MaikKlein> i come from languages like java so dynamic dispatch is the only thing I knew. 
[19:03:48] <MaikKlein> but static dispatch is pretty awesome, I wonder what the limits are
[19:03:49] <cmr> Yup. Trait objects are exactly like java interfaces, as I understand them (I haven't used java in 3 years)
[19:03:55] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[19:04:22] <cmr> MaikKlein: well, there are problems with generated code size... it generates a separate function for every usage of the generic (like C++ templates do).
[19:04:30] <cmr> Sometimes they can be inlined and optimized down, sometimes not
[19:04:31] <bblum> they are better because they are also typeclasses
[19:05:03] <MaikKlein> omg static dispatch ftw, no stupid casts anymore
[19:05:18] <bblum> rule of thumb is you get static dispatch when the trait name appears in the <T: ...> parameterization
[19:05:34] <bblum> and dynamic dispatch when the trait is used as the type name (as an existential / "object")
[19:05:46] *** Joins: anri (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net)
[19:06:47] *** Joins: dew (Instantbir@moz-66796D51.dhcp.stls.mo.charter.com)
[19:07:05] <MaikKlein> and static dispatch probably also compiles slower
[19:08:13] <SiegeLord> You generally want to try to hoist your generic functions... that fixes many of these issues
[19:08:17] *** Quits: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP) (Ping timeout)
[19:08:27] <cmr> SiegeLord: what does that mean?
[19:08:51] <SiegeLord> You basically separate the non-generic part of the function into a non-generic function
[19:09:28] *** Joins: Thad (chatzilla@moz-C35F90AE.tx.res.rr.com)
[19:09:32] <cmr> Ah
[19:09:37] <cmr> And branch into the generic part?
[19:09:48] <cmr> is this a compiler optimization?
[19:09:57] <Thad> I want the NEW syntax.  How to get around the multiple matching crates for 'syntax' error during build ??
[19:10:11] <cmr> Thad: 'make clean'
[19:10:12] <SiegeLord> I don't know if compilers do that... I've only seen this technique done manually
[19:10:21] <Thad> cmr: thanks.  I'll try it.
[19:11:27] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[19:11:34] *** Quits: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[19:12:46] <MaikKlein> ok now i have both https://gist.github.com/MaikKlein/5842182
[19:12:49] <MaikKlein> dynamic and static
[19:13:45] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[19:13:47] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.1)
[19:14:48] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[19:15:02] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[19:15:04] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[19:15:25] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[19:17:09] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[19:17:44] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[19:18:38] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[19:19:41] *** Quits: xazax (xazax@moz-EC71964B.pool77-111.dyn.tolna.net) (Quit: Ex-Chat)
[19:19:55] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[19:20:56] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[19:21:36] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[19:23:03] <MaikKlein> are super traits already working?
[19:23:18] <cmr> trait inheritance?
[19:23:22] <MaikKlein> y
[19:23:22] <SiegeLord> I do think that the union of static/dynamic with traits is a very appealing property of Rust
[19:24:01] <cmr> I... am not sure. I saw a few trait inheritance tests mark as "expected failure", but I don't know the extent that they are working or broken.
[19:24:31] <cmr> I knoe a pattern like "A, B inherit from A, C inherit from B, trying to call an A method on C" is broken
[19:24:49] <MaikKlein> hm okay
[19:26:37] <MaikKlein> cmr, I saw that you are studying cs now?
[19:26:54] <cmr> MaikKlein: I begin in august
[19:27:05] *** Joins: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net)
[19:27:12] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[19:27:54] <MaikKlein> cmr, then you are probably far ahead of your classmates :)
[19:28:11] <cmr> MaikKlein: probably, except in math and science :p
[19:28:49] *** Quits: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net) (Ping timeout)
[19:29:28] <MaikKlein> yeah math ... :X I write 2 math exams in two weeks
[19:31:43] <MaikKlein> sully is working on default methods?
[19:31:48] <cmr> yes
[19:32:02] <MaikKlein> I want them so bad
[19:32:03] *** Quits: jrfeenst (jrfeenst@moz-F912484F.cpe.norwoodlight.com) (Quit: jrfeenst)
[19:33:02] <cmr> I think if you have #[allow(default_methods)]; or something like that you can use them
[19:33:15] <MaikKlein> cmr, you messed up a link on your blog , http://michaelwoerister.github.io/, there is a comma
[19:33:29] <cmr> MaikKlein: oops, thank you
[19:33:33] <Blei> so, extern c function pointers are not implemented correctly yet, right?
[19:33:47] <cmr> Blei: https://github.com/mozilla/rust/pull/6661
[19:33:49] <Blei> at least i couldn't get rustc to produce a function pointer without an env argument
[19:33:49] <cmr> nope
[19:33:51] <strcat> there's something implemented correctly in rustc?
[19:33:55] <strcat> ;p
[19:33:57] <Blei> cmr: thanks
[19:34:05] *** Quits: sankha93 (Instantbir@45B9B9EE.11A4F4B4.CA052C06.IP) (Ping timeout)
[19:34:44] <Thad> cmr:  That worked "make clean".  Thanks.  Confirmed now that Rust can build with GCC 4.6.2 on Win7 now.  Yeah !
[19:35:00] <cmr> Thad: It needed 4.5 before right?
[19:35:04] <Thad> yeap
[19:35:06] <cmr> yay!
[19:36:01] <SiegeLord> I tried 4.7 on WinXP, but it didn't work... what did you do to get 4.6.2 working?
[19:36:57] <sully> yeah, I am working on default methods
[19:37:04] <sully> lots of progress being made, but a lot is broken with them
[19:38:06] *** Joins: sankha93 (Instantbir@D36BB451.7878E78E.CA052C06.IP)
[19:38:19] <MaikKlein> <33
[19:38:28] *** Quits: threecreepio (jdp@moz-DB2D70E9.cust.bredbandsbolaget.se) (Quit: threecreepio)
[19:38:53] <doomlord> anyone here actually used the android support (ndk?)
[19:38:56] <strcat> sully: is inlining broken?
[19:38:57] *** Joins: tcsc (tcsc@moz-ADC0ED45.hsd1.ct.comcast.net)
[19:39:00] <strcat> of default methods
[19:39:20] <sully> I believe I got cross crate default methods working
[19:39:20] <cmr> doomlord: yichoi probably has, he's the one who usually does the android fixes
[19:39:38] <strcat> meh something is still wrong with bors
[19:39:42] <strcat> he's not picking up the retries
[19:40:20] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[19:40:49] <strcat> and that windows bot is broken
[19:40:54] <strcat> just made the current PR fail ;\
[19:41:55] <cmr> Blei: benching the intrinsic overhaul
[19:42:08] <Blei> TAIL: can't open +2
[19:42:28] <Blei> cmr: thanks! this time it might make a small difference
[19:42:33] <strcat> Blei: I think the windows bots just have intermittent failures like that
[19:42:46] <strcat> anyway doesn't look like anything will be landing
[19:42:55] <Blei> bleh
[19:43:01] <cmr> I was hoping the weekend would put a dent in the queue :(
[19:43:22] <cmr> Around 1pm my time I was wondering where all the west coasters were, then I remembered it's saturday...
[19:43:32] <doomlord> i gave up on my efforts to get rust onto the iphone... my mac is halfbroken too so i'm not actively working with ios at theminute
[19:43:45] <strcat> cmr: it's putting a dent in the queue by reducing contributions ;\
[19:44:17] <strcat> + everything people do is going to be broken by my vector stuff from 5 days ago
[19:44:23] <strcat> should have landed days ago
[19:45:07] <acrichto> it is kinda sad that I've had a request open for 9 days and it's been getting rebased twice a day and still hasn't made it through :(
[19:45:22] *** Quits: sankha93 (Instantbir@D36BB451.7878E78E.CA052C06.IP) (Ping timeout)
[19:46:29] *** Joins: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net)
[19:47:05] *** Joins: patrick (patrick@moz-7C097820.hsd1.mn.comcast.net)
[19:47:43] <strcat> we could just manually merge some of the things that already got tested when it went haywire...
[19:48:19] *** Quits: dew (Instantbir@moz-66796D51.dhcp.stls.mo.charter.com) (Ping timeout)
[19:49:20] *** Joins: sankha93 (Instantbir@3ABDD4F9.7F6282B1.CA052C06.IP)
[19:50:07] *** patrick is now known as Azdle
[19:50:11] <indutny> cmr: just in case if you're curious - https://github.com/indutny/masm.rs
[19:50:43] <cmr> indutny: masm like microsoft's masm?
[19:50:47] <indutny> haha
[19:50:50] <indutny> like macro assembler
[19:50:59] <indutny> and that's all
[19:51:01] <indutny> https://github.com/indutny/masm.rs/blob/master/test/runner.rs
[19:51:07] <cmr> (microsoft's is called macro assembler :p)
[19:51:20] <indutny> well, it has nothing in common
[19:51:27] <indutny> hm...
[19:51:31] <indutny> probably I should rename the project
[19:51:33] <indutny> into just asm.rs
[19:51:34] <indutny> :P
[19:51:38] <cmr> that would work
[19:51:53] <indutny> done
[19:52:05] <cmr> You said you were writing a JIT?
[19:52:15] <indutny> yep
[19:52:23] <cmr> Very cool :)
[19:52:26] <indutny> I'm half there, already have working reg. allocator
[19:52:31] <indutny> and now working on asm.rs
[19:52:45] <indutny> then I'm going to write High-Level IR component
[19:52:54] <indutny> and tie them together with my Erlang BEAM parser
[19:53:06] <indutny> to create ultimate erlang jit compiler and vm :P
[19:53:06] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[19:53:06] <ghrust> 01[13rust01] 15thestinger pushed 2 new commits to 06master: 02http://git.io/jmNKDQ
[19:53:06] <ghrust> 13rust/06master 148066dfd 15Philipp BrÃ¼schweiler: syntax::diagnostics: Color the ^~~~ in green for better visibility...
[19:53:06] <ghrust> 13rust/06master 1469e0704 15Daniel Micay: Merge pull request #7230 from Blei/green-squiggle...
[19:53:06] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[19:53:10] <indutny> written in rust
[19:53:12] <cmr> Heheh
[19:53:29] <Blei> woo
[19:53:34] <Blei> strcat: thanks
[19:53:46] * strcat will just put the vector one through try and manually build it on the bots ;\
[19:53:54] <cmr> indutny: A very cool project, I'll include it in next week's twir :)
[19:54:00] <indutny> haha
[19:54:04] <indutny> which one?
[19:54:13] <indutny> https://github.com/indutny/linearscan.rs or asm.rs?
[19:54:15] <cmr> ther eg allocator and asm.rs
[19:54:24] <indutny> oh, cool
[19:54:26] <indutny> thanks
[19:54:26] <Earnestly> strcat: Do you have rust nightly builds on pkgbuild?
[19:54:31] <Thad> SiegeLord: not anything different than what I documented on the Wiki for installing on Windows environment.
[19:54:31] <strcat> Earnestly: yes
[19:54:41] <strcat> Earnestly: http://pkgbuild.com/~thestinger/repo/
[19:54:41] <engla> yay, master advanced
[19:54:42] <indutny> cmr: may eventually, I'll write rustc in rust
[19:54:45] <Earnestly> strcat: ta
[19:54:46] <SiegeLord> Thad: I see...
[19:54:51] <indutny> s/may/may be/
[19:54:53] <cmr> indutny: rustc is written in rust
[19:55:01] <indutny> I mean without external dependencies
[19:55:08] <indutny> read: without llvm
[19:55:34] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[19:55:35] <ghrust> 01[13rust01] 15thestinger pushed 3 new commits to 06try: 02http://git.io/FH0lmA
[19:55:35] <ghrust> 13rust/06try 14bdb9d67 15Daniel Micay: iterator: add a size_hint default method...
[19:55:35] <ghrust> 13rust/06try 142afaba2 15Daniel Micay: iterator: add a FromIterator trait...
[19:55:35] <ghrust> 13rust/06try 14b2fb826 15Daniel Micay: vec: remove BaseIter implementation...
[19:55:37] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[19:55:47] <indutny> but that's mostly madness
[19:56:13] *** Joins: threecreepio (jdp@moz-DB2D70E9.cust.bredbandsbolaget.se)
[19:56:19] *** Joins: vittorioromeo (quassel@moz-45F541F0.retail.telecomitalia.it)
[19:56:30] <vittorioromeo> hello everyone 
[19:57:04] <vittorioromeo> I'm a C++ programmer who wants to try Rust
[19:57:21] <Thad> SiegeLord: the only difference being that I upgraded to 4.6.2 using "mingw-get upgrade gcc"  which pulls down the latest gcc package binary 4.6.2 for MinGW 
[19:57:33] <Earnestly> vittorioromeo: https://github.com/mozilla/rust/wiki/Rust-for-CXX-programmers
[19:57:33] <indutny> vittorioromeo: hi
[19:58:04] <SiegeLord> Thad: I just installed the latest when I installed MinGW
[19:58:43] <SiegeLord> And I got (I think) a currupt rustllvm.dll created by stage0
[19:58:54] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[19:58:54] <ghrust> 01[13rust01] 15thestinger pushed 8 new commits to 06master: 02http://git.io/azup6A
[19:58:55] <ghrust> 13rust/06master 147d61b00 15Brian Anderson: More 0.7 release notes
[19:58:55] <ghrust> 13rust/06master 14525933d 15Ralph Bodenner: Show defaults in rustdoc usage message
[19:58:55] <ghrust> 13rust/06master 1487c1105 15Joris Rehm: fix text of tutorials
[19:58:55] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[19:58:57] <SiegeLord> If I got my terminology right
[19:59:24] <vittorioromeo> Earnestly: I read that :p 
[19:59:40] <Thad> SiegeLord: how do you know that it was corrupt ?  what told you that or pointed to that ?
[19:59:40] <vittorioromeo> was wondering, how do I convert something to a string?
[19:59:50] <cmr> vittorioromeo: Convert what to a string?
[19:59:58] <cmr> vittorioromeo: Many things have a to_str method, but not everything (yet)
[19:59:59] <SiegeLord> Thad: When it tried to link rustc, it was missing some symbols
[20:00:12] <Blei> rusti: 1u.to_str()
[20:00:16] -rusti- ~"1"
[20:00:37] <vittorioromeo> cmr: a integer, for example
[20:00:37] <SiegeLord> Thad: I did nm rustllvm.dll from the snapshot and from the generated one, and the generated one was definitely missing those symbols
[20:01:06] <Thad> SiegeLord: ah, ya know what ?  I might be still using the LLVM that was compiled with 4.5   I betcha.
[20:01:29] <SiegeLord> Thad: I also had to download libstdc++6.dll for the snapshot rustc to even run
[20:01:42] <SiegeLord> It crashed with the libstdc++ that came with 4.7
[20:01:42] <Thad> SiegeLord: so as long as LLVM is first compiled with 4.5 then your probably OK to then upgrade GCC after that.
[20:01:52] <Blei> good night, all
[20:01:56] *** Quits: Blei (philipp@moz-650B9C6A.cust.bluewin.ch) (Quit: WeeChat 0.4.1)
[20:01:57] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[20:01:57] <ghrust> 01[13rust01] 15thestinger pushed 2 new commits to 06master: 02http://git.io/4TBzGw
[20:01:57] <ghrust> 13rust/06master 14df626ea 15Alex Crichton: Fix compiling empty fmt! strings
[20:01:57] <ghrust> 13rust/06master 14df166ba 15Daniel Micay: Merge pull request #7227 from alexcrichton/issue-7218...
[20:01:59] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[20:02:15] <SiegeLord> I don't need Windows support atm, I just wanted to be a contrarian and try MinGW 4.7 :P
[20:02:20] <Thad> SiegeLord: could you try a scratch install / build with my steps on the Wiki now ?
[20:02:50] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[20:02:50] <ghrust> 01[13rust01] 15thestinger 04force-pushed 06try from 14b2fb826 to 14fe66af3: 02http://git.io/k471pw
[20:02:50] <ghrust> 13rust/06try 14468cbd9 15Daniel Micay: iterator: add a size_hint default method...
[20:02:50] <ghrust> 13rust/06try 14c934266 15Daniel Micay: iterator: add a FromIterator trait...
[20:02:50] <ghrust> 13rust/06try 14fe66af3 15Daniel Micay: vec: remove BaseIter implementation...
[20:02:52] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[20:03:01] <SiegeLord> I don't want to break my MinGW install... there's quite a few other things there...
[20:03:28] <SiegeLord> Maybe when I reinstall Windows
[20:04:03] <Thad> SiegeLord: OK
[20:04:34] <tcsc> rusti: std::bool::xor((3 as bool), (2 as bool))
[20:04:35] -rusti- true
[20:04:47] <tcsc> rusti: std::bool::xor(true, true)
[20:04:48] -rusti- false
[20:04:51] <tcsc> is that a bug?
[20:04:59] <MaikKlein> cmr, why have you done rust-bench? doesn't rust already have a benchmarking system with #[bench] or sth?
[20:05:08] <strcat> rusti: 3 as bool
[20:05:09] -rusti- true
[20:05:11] <strcat> rusti: 2 as bool
[20:05:13] -rusti- true
[20:05:15] <strcat> tcsc: yes 'as' is broken
[20:05:19] <strcat> should report it
[20:05:22] <tcsc> okay
[20:05:32] <MaikKlein> rusti: 4 as bool
[20:05:33] -rusti- true
[20:06:18] <MaikKlein> rusti: 0 as bool
[20:06:19] -rusti- false
[20:06:19] <strcat> manually spinning up all the auto builders is a pain
[20:06:38] <strcat> rusti: let x: u8 = std::cast::transmute(4 as bool); x
[20:06:39] -rusti- <anon>:9:21: 9:53 error: call to unsafe function requires unsafe function or block
[20:06:39] -rusti- <anon>:9          let x: u8 = std::cast::transmute(4 as bool); x
[20:06:39] -rusti-                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[20:06:40] -rusti- error: aborting due to previous error
[20:06:40] -rusti- application terminated with error code 101
[20:06:49] *** Quits: Thad (chatzilla@moz-C35F90AE.tx.res.rr.com) (Quit: ChatZilla 0.9.90 [Firefox 22.0/20130617145905])
[20:06:49] <strcat> rusti: unsafe { let x: u8 = std::cast::transmute(4 as bool) }; x
[20:06:49] -rusti- <anon>:9:62: 9:63 error: expected `;` but found `}`
[20:06:49] -rusti- <anon>:9          unsafe { let x: u8 = std::cast::transmute(4 as bool) }; x
[20:06:49] -rusti-                                                                        ^
[20:06:49] -rusti- application terminated with error code 101
[20:06:58] <strcat> rusti: unsafe { let x: u8 = std::cast::transmute(4 as bool); x }
[20:07:00] -rusti- 4
[20:07:07] <strcat> tcsc: ^ shows the issue
[20:07:12] <strcat> 'as' doesn't truncate to i1
[20:07:14] <strcat> like it should
[20:07:16] <strcat> for conversions to bool
[20:07:26] <cmr> MaikKlein: Yes, but I made rust-bench to measure memory usage.
[20:07:37] <cmr> (mostly)
[20:08:23] <tcsc> strcat: thanks, 3 as bool as u8 also works.
[20:08:25] <MaikKlein> cmr, ah ok
[20:08:44] <cmr> And also for the programs in src/test/bench which don't use the benchmark runner (they're for the http://benchmarksgame.alioth.debian.org/)
[20:09:03] *** Quits: roo (Mibbit@moz-1648A2AF.dynamic.ip.windstream.net) (Quit: http://www.mibbit.com ajax IRC Client)
[20:10:34] *** Joins: roo (Mibbit@moz-2D4AC215.dynamic.ip.windstream.net)
[20:10:46] *** Quits: pyrac (pyrac@moz-9180E00E.w86-201.abo.wanadoo.fr) (Quit: pyrac)
[20:10:46] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[20:11:30] <strcat> http://buildbot.rust-lang.org/console?branch=try&refresh=15 yay?
[20:11:39] <strcat> there are 2 half-dead ones stuck in git though
[20:13:03] *** Joins: devbug (quassel@moz-E1DE087C.bchsia.telus.net)
[20:13:41] *** Joins: timot (timot@96CD51CC.D7290CF.898DC978.IP)
[20:14:15] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[20:14:15] *** ChanServ sets mode: +o brson
[20:18:20] <SiegeLord> Hmm... I'm starting to think that the github integration of rustpkg isn't a great idea... it forces the package name to have the same name as the repository
[20:18:32] <cmr> SiegeLord: does it?
[20:18:42] <cmr> That part isn't done yet afaik
[20:19:40] <SiegeLord> You can rustpkg install from github right now
[20:19:52] <cmr> Just because it works doesn't mean it's done
[20:20:39] <SiegeLord> I wish there was a design document... I don't know what's incomplete and what's intentional... :/
[20:20:53] <cmr> pester tjc about it when he's on
[20:21:02] <cmr> he's been at a conference this past week though
[20:21:33] <SiegeLord> I see
[20:22:10] <MaikKlein> i don't understand
[20:22:19] <MaikKlein> install rustpkg from github?
[20:22:37] *** Quits: timot (timot@96CD51CC.D7290CF.898DC978.IP) (Quit: Konversation terminated!)
[20:22:54] *** Joins: timot (timot@96CD51CC.D7290CF.898DC978.IP)
[20:23:32] *** Quits: sk (sk@61A494B3.BA40E8A.AAC02D62.IP) (Ping timeout)
[20:23:32] <SiegeLord> You can do rustpkg install catamorphism/test-pkg
[20:23:40] <SiegeLord> Err
[20:23:50] <SiegeLord> rustpkg install github.com/catamorphism/test-pkg
[20:24:51] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[20:26:15] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[20:27:31] <MaikKlein> rustpkg is sth like cmake?
[20:27:33] <MaikKlein> just in rust?
[20:27:45] <cmr> No. it's more like npm.
[20:27:58] <cmr> Or... I suppose kinda like python's distutils, or luarocks
[20:28:16] <cmr> It's a package manager, not a build system
[20:28:40] <SiegeLord> I don't know about that, it seems a build system too
[20:28:55] <cmr> SiegeLord: well it just uses rust's crate attributes for the build stuff, no?
[20:29:03] <cmr> rustc does that for free
[20:29:05] <MaikKlein> ah 
[20:29:20] <MaikKlein> so it's like rustpkg install lmath
[20:29:23] <MaikKlein> for example?
[20:29:31] <SiegeLord> cmr, as far as I understand, it can automatically take care of extern mod foo;
[20:29:37] <SiegeLord> It'll try to find foo, and build it
[20:30:02] <SiegeLord> And tjc wants this syntax too: extern mod foo = "github.com/blah/blah"
[20:30:10] <strcat> yay one bot passed
[20:30:12] *** Joins: pyrac (pyrac@moz-9180E00E.w86-201.abo.wanadoo.fr)
[20:30:23] <strcat> always a good sign ;p
[20:30:47] <MaikKlein> this would be really cool
[20:31:13] <MaikKlein> so it's more like hm
[20:31:26] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[20:31:26] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14f39d8a8 to 14df166ba: 02http://git.io/N3iJvQ
[20:31:26] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[20:31:27] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[20:31:27] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/s0XFhg
[20:31:27] <ghrust> 13rust/06auto 14de471a2 15Philipp BrÃ¼schweiler: Fix take glue of owned trait objects...
[20:31:27] <ghrust> 13rust/06auto 140739c6b 15bors: auto merge of #7214 : Blei/rust/fix-owned-traits, r=pcwalton...
[20:31:27] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[20:31:42] <strcat> oh bors actually feels like doing something again
[20:31:55] <MaikKlein> ah so it's like maven?
[20:32:25] *** Joins: vk (chatzilla@F92596F.2DEF7520.EF7679FA.IP)
[20:36:06] <SiegeLord> I don't know if I like every single decision though... what if you wanted to grab the same library from a different repository
[20:36:12] <SiegeLord> Or install it manually
[20:36:24] <SiegeLord> All 3 atm produce 3 separate package installations
[20:36:46] *** Quits: kini (kini@moz-92AA953A.members.linode.com) (Ping timeout)
[20:36:53] <strcat> SiegeLord: it's in an early state
[20:37:09] *** Joins: kini (kini@moz-92AA953A.members.linode.com)
[20:37:14] <strcat> bugs != design decisions
[20:37:22] <SiegeLord> I don't think any of those are bugs
[20:37:45] <strcat> there are like 3 different unique ids it requires you to use
[20:37:54] <strcat> I really doubt it's not going to use any of them to uniquely identify it
[20:38:31] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Input/output error)
[20:39:20] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[20:41:48] <strcat> oh well
[20:42:03] *** Quits: MaikKlein (maik@moz-E6D51931.dip0.t-ipconnect.de) (Ping timeout)
[20:42:24] <strcat> now there are two things being tested....
[20:42:37] <strcat> I'll just make both land when they pass, they don't overlap at all
[20:42:56] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Input/output error)
[20:43:03] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[20:44:12] <cmr> strcat: mac failure http://buildbot.rust-lang.org/builders/auto-mac-64-opt/builds/33/steps/test/logs/stdio
[20:44:40] *** Quits: timot (timot@96CD51CC.D7290CF.898DC978.IP) (Quit: Konversation terminated!)
[20:44:50] <strcat> yep I guess that one won't be landing
[20:44:55] <strcat> ;p
[20:44:56] *** Joins: timot (timot@96CD51CC.D7290CF.898DC978.IP)
[20:45:05] *** Joins: EXetoC (ex@moz-2DBEB1E4.customer.t3.se)
[20:46:42] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[20:53:47] *** sam113101 is now known as sam113101_afk
[20:54:28] *** Quits: sankha93 (Instantbir@3ABDD4F9.7F6282B1.CA052C06.IP) (Quit: Instantbird 1.4 -- http://www.instantbird.com)
[20:55:03] *** Quits: pyrac (pyrac@moz-9180E00E.w86-201.abo.wanadoo.fr) (Quit: pyrac)
[20:55:58] <cmr> strcat: If I wanted to point noobs to a place in the rust source to draw inspiration of well-written rust, where would that be?
[20:57:05] <strcat> don't know
[20:57:07] <strcat> nowhere? ;p
[20:57:18] <cmr> that's what I thought :p
[20:57:36] <strcat> std::iterator will be nice when it's not full of workarounds for compiler bugs
[20:57:51] <doomlord> has rust been around long enough for people to know what well written is :)
[20:58:19] *** Joins: pyrac (pyrac@moz-9180E00E.w86-201.abo.wanadoo.fr)
[20:58:54] <strcat> cmr: extra::treemap would be nice if not for all the workarounds I had to use :[
[20:59:01] <strcat> some of them can go away now
[20:59:09] <cmr> I think the terminfo code is decent
[20:59:15] <cmr> (biased, of course)
[20:59:32] <strcat> but not finished ;p
[20:59:38] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[21:00:03] <Luqman> cmr: pcwalton's nes emulator perhaps
[21:00:03] *** Joins: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net)
[21:00:30] <strcat> Luqman: I think it's still full of borrowck workarounds from before that stuff was greatly improved
[21:00:53] * strcat looks
[21:01:02] <Luqman> hasn't been updated for a while
[21:01:54] <strcat> yep it has workarounds that aren't needed anymore
[21:02:09] <strcat> as in unsafe transmutes
[21:03:00] *** Joins: MaikKlein (maik@moz-E6D51931.dip0.t-ipconnect.de)
[21:03:44] <strcat> cmr: idiomatic rust would use stack discipline + moves + borrows, no @/~ sigils anywhere
[21:03:52] <strcat> ~ belongs in container implementations, not outside of them
[21:04:08] <strcat> and @ belongs in persistent containers (which we don't have yet)
[21:04:31] <Jeaye> You can point them to my code for what not to do. :P
[21:04:37] <strcat> (other than ~[], which is perfectly fine to have everywhere)
[21:04:49] <doomlord> seriously, ~/@ like * in c++11 ?
[21:05:02] <strcat> ~ and especially @ are code smell
[21:05:02] <MaikKlein> what
[21:05:04] <MaikKlein> no ~ ?
[21:05:06] <cmr> Context: I'm writing a  "How I got started hacking rustc, and how you can too!" blog post
[21:05:12] <strcat> MaikKlein: right
[21:05:21] <doomlord> ok you qualify with ~[]
[21:05:30] <strcat> application code shouldn't have to use owned pointers or managed pointers
[21:05:41] <strcat> those are implementation details of owned/persistent containers
[21:06:12] <MaikKlein> rusti: let a = 5; let b= a; a
[21:06:14] -rusti- <anon>:9:24: 9:25 warning: unused variable: `b` [-W unused-variable (default)]
[21:06:14] -rusti- <anon>:9          let a = 5; let b= a; a
[21:06:14] -rusti-                                  ^
[21:06:14] -rusti- 5
[21:06:45] <doomlord> but ~[] is ' a very common owned container' i guess, under your worldview? (like using std::vector in c++)
[21:06:46] <MaikKlein> how would I make that move?
[21:06:55] <strcat> MaikKlein: you don't want it to move
[21:06:58] <strcat> doesn't make sense
[21:07:24] <strcat> doomlord: yes
[21:07:35] *** Quits: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net) (Ping timeout)
[21:07:47] <MaikKlein> why not?
[21:07:51] <tcsc> is it intentional that the functions from io don't handle EINTR?
[21:07:51] <strcat> MaikKlein: doesn't make sense
[21:07:58] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[21:08:02] <cmr> tcsc: probably not
[21:08:02] <strcat> MaikKlein: you can just dereference ~int and copy out of it
[21:08:08] <cmr> tcsc: the io code is awful
[21:08:10] <strcat> ~int is pointless
[21:08:17] <strcat> an int is already 1 word
[21:08:18] <MaikKlein> yes it was just an example
[21:08:25] <doomlord> so stack safety means many things which would be unique_ptr<T> in C++ can just go on the stack
[21:08:31] <MaikKlein> lets say instead of int, there way two huge objects
[21:08:35] <MaikKlein> were*
[21:08:36] <strcat> doomlord: well unique_ptr is code smell in C++ too
[21:08:46] <strcat> it generally means you didn't bother using C++ libs that use RAII and need to wrap things
[21:09:12] <strcat> MaikKlein: sure, but why would you have huge objects?
[21:09:25] <MaikKlein> don't know :D
[21:09:33] <Earnestly> strcat: If you know what I mean ;)
[21:09:41] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[21:09:42] <MaikKlein> when should I use move?
[21:09:51] <strcat> MaikKlein: you shouldn't want to "use" moves
[21:10:00] *** Quits: EXetoC (ex@moz-2DBEB1E4.customer.t3.se) (Ping timeout)
[21:10:04] <strcat> moves are just what happens when you shallow copy an object with a destructor
[21:10:38] <strcat> ~[], HashMap, HashSet, TreeMap, TreeSet, files, sockets, etc. will move when you pass them by-value
[21:10:42] <strcat> no effort required on your part
[21:10:45] *** Joins: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net)
[21:11:07] <strcat> ~ has two use cases
[21:11:28] <strcat> 1) implementing a recursive data structure (99.5% of application code shouldn't need to do this)
[21:11:34] <roo> Is there a reason why make install adds a rustc/ directory to /usr/local/bin on mingw?
[21:12:02] <strcat> 2) cheaply moving around a huge struct (which 99% of application code shouldn't have in the first place)
[21:12:02] <doomlord> "~[] will move when you pass by value" - is there a commented code fragment that clarifies that
[21:12:15] <doomlord> move vs copy vs borrow
[21:12:16] <strcat> doomlord: types with destructors move ownership when you shallow copy them
[21:12:26] <strcat> move == shallow copy that moves ownershi[p
[21:12:38] <MaikKlein> hm ok
[21:12:41] <strcat> rusti: let a = 5; let b = a; a
[21:12:41] -rusti- <anon>:9:24: 9:25 warning: unused variable: `b` [-W unused-variable (default)]
[21:12:41] -rusti- <anon>:9          let a = 5; let b = a; a
[21:12:42] -rusti-                                  ^
[21:12:42] -rusti- 5
[21:12:45] <strcat> shallow copy
[21:12:54] <doomlord> "shallow copy" = ?
[21:13:09] <strcat> a copy of everything owned by the variable
[21:13:22] <strcat> as shallow as you can go
[21:13:44] <doomlord> what would a 'deep copy' be
[21:13:54] <strcat> copying beyond what it owns
[21:14:11] <strcat> as in deep copying through @ or Rc
[21:14:38] <doomlord> ah,@ of course, very different
[21:14:56] <strcat> you can't copy *less* than what it owns
[21:15:12] <strcat> so at minimum, a copy is a copy of the directly owned data
[21:15:31] <strcat> and if something it owns has a destructor - that copy *is* a move
[21:15:31] <cmr> strcat: how large of a struct do you consider large?
[21:15:39] <strcat> cmr: 8 words?
[21:15:42] <cmr> Ok
[21:15:44] *** Quits: MaikKlein (maik@moz-E6D51931.dip0.t-ipconnect.de) (Ping timeout)
[21:15:44] *** Joins: EXetoC (ex@moz-2DBEB1E4.customer.t3.se)
[21:15:54] <strcat> 4-word struct is usually going to be better off on the stack
[21:15:55] *** Quits: EXetoC (ex@moz-2DBEB1E4.customer.t3.se) (Quit: WeeChat 0.4.1)
[21:15:59] *** Joins: EXetoC (ex@moz-2DBEB1E4.customer.t3.se)
[21:16:21] <strcat> calling 'fn foo(x: int, y: FourWordStruct)' on x86_64 will just pass-by-register
[21:17:07] <cmr> rusti: fn foo(x: ~int) { }
[21:17:09] -rusti- <anon>:9:16: 9:17 warning: unused variable: `x` [-W unused-variable (default)]
[21:17:09] -rusti- <anon>:9          fn foo(x: ~int) { }
[21:17:09] -rusti-                          ^
[21:17:09] -rusti- ()
[21:17:11] <strcat> if you put it in ~, you can move it around with a 1-word copy + 1-word zero
[21:17:15] <cmr> I didn't even know that was possible.
[21:17:22] <strcat> cmr: what was?
[21:17:27] <cmr> strcat: ~t params
[21:17:34] <strcat> ~ isn't special
[21:17:36] <cmr> I know
[21:17:41] <cmr> And it's in the tutorial adn stuff
[21:17:44] <strcat> it can be implemented in a library
[21:17:47] <cmr> I just forgota bout it because it isn't useful :p
[21:18:14] <strcat> here's the thing:
[21:18:27] <strcat> if you *do* have a huge struct, you can just pass it by & deeper into the call stack
[21:19:07] <strcat> if you put it in ~, it now has a destructor so it moves
[21:19:22] <strcat> an actual copy requires a heap alloc... so you'd rarely need/want that
[21:20:36] <strcat> I would be fine with only having &/&mut as sugar and the ~/@ sigils not being used
[21:20:46] <strcat> most code shouldn't need them...
[21:20:52] <toddaaro> 4
[21:21:09] <toddaaro> (irssi confusion, sorry)
[21:21:54] *** Quits: pyrac (pyrac@moz-9180E00E.w86-201.abo.wanadoo.fr) (Quit: pyrac)
[21:21:58] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[21:25:54] <roo> Is there a reason why make install adds a rustc/ directory to /usr/local/bin on mingw? It interferes with mingw resolving rustc to rustc.exe
[21:26:35] <strcat> roo: don't know, it shouldn't do that
[21:26:51] <strcat> it doesn't do anything like that on *nix
[21:26:52] <brson> roo: https://github.com/mozilla/rust/issues/3319
[21:27:02] <roo> i just moved it, and everything seems to work fine
[21:27:06] * roo looks
[21:27:30] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[21:27:38] *** Quits: heftig (heftig@moz-DDC44F26.dip0.t-ipconnect.de) (Ping timeout)
[21:27:44] * strcat found a weird codegen bug :(
[21:28:04] <doomlord> is there a good explanation of what match can do beyond switch,for educating c++ people
[21:28:14] *** Quits: robert (robertknig@moz-C34822AC.range86-166.btcentralplus.com) (Ping timeout)
[21:28:46] <cmr> doomlord: patterns are very powerful. they can do ranges, guards, binding to variables, conditionals...
[21:28:54] <strcat> it's always an exhaustive match against a set of patterns
[21:29:27] <doomlord> no fallthough, safer of course
[21:29:38] <doomlord> and you've GOT to handle every option?
[21:29:44] <strcat> yes
[21:29:49] <strcat> you provide a set of patterns
[21:29:51] <cmr> But you can cheat
[21:29:54] <strcat> C++ switch is just a branch table on a primitive integer value
[21:30:04] <cmr> match x { 1 => ..., _ => ... }
[21:30:06] <sp3d> just out of curiosity: do matches ever get the sort of jump-table optimizations that switches do?
[21:30:07] <strcat> well you can "cheat" by providing a pattern that matches anything
[21:30:09] <doomlord> pattern matching knows more about types..
[21:30:15] <strcat> sp3d: sure, they compile to the same LLVM IR
[21:30:19] <doomlord> its not something i've used.
[21:30:19] <sp3d> cool
[21:30:26] <engla> doomlord: match is an expression, so each branch must evaluate to a value of the same type
[21:30:33] <strcat> doomlord: switch doesn't know about types, it's a branch on an integer value
[21:30:35] <doomlord> i just haave "switch on steroids" in my head
[21:30:40] <strcat> match is matching against a set of patterns
[21:30:49] <strcat> match can do what switch does, but it's not really anything like it
[21:30:53] <doomlord> ah i've seen people fudge something like a match expression in C++ a long way round :)
[21:31:14] <strcat> doomlord: for example
[21:31:27] <strcat> (int, Option<int>)
[21:31:30] <strcat> there's a data structure
[21:31:32] <strcat> so....
[21:31:42] <strcat> (x, Some(y))
[21:31:49] <strcat> (x, None)
[21:31:55] <strcat> is an exhaustive set of patterns you could match
[21:31:56] <strcat> or...
[21:32:06] <strcat> (1 .. 100, Some(y))
[21:32:10] <strcat> (x, Some(y))
[21:32:16] <strcat> (x, None)
[21:32:26] <doomlord> destructuring is really neat
[21:32:33] <strcat> if you match on (bool, bool)
[21:32:39] <strcat> it will make you handle all 4 cases
[21:32:52] <doomlord> there's neat ways of handling something like "errorcode,value" ?
[21:32:57] <strcat> (true, true), (true, false), (false, true), (false, false)
[21:32:58] <cmr> Or! (x @ 1 .. 100, Some(y)), x is bound to the matched value
[21:33:04] <strcat> doomlord: sure
[21:33:27] <doomlord> error,value= DoSomethingWhichMightFail();   if (error!=..) ....  <<<<<< better with match.. ?
[21:33:28] <steven_is_false> One can't do Duffs device with a match expression.
[21:33:30] <strcat> doomlord: https://github.com/thestinger/rust/commit/468cbd9d014d4f8610694057f1a8132f1eaf0b19 there are some examples with (Option<uint>, Option<uint>) here
[21:33:36] <strcat> doomlord: that doesn't make sense though
[21:33:42] <strcat> doomlord: you wouldn't return an error *and* a value
[21:33:47] <strcat> you would return *either* an error or a value
[21:33:53] <doomlord> errorCode
[21:34:04] <strcat> doomlord: if an error happens I'm assuming you won't get a value
[21:34:05] <cmr> Result<value, int>
[21:34:09] <strcat> so returning both doesn't make sense
[21:34:11] <strcat> you'd return
[21:34:21] <doomlord> oh you'd use a tagged union?
[21:34:24] <doomlord> an enum?
[21:34:25] <strcat> doomlord: yes, an enum
[21:34:39] <strcat> you either return the error or the result
[21:34:43] <strcat> and the caller can match out of it
[21:34:46] *** Joins: heftig (heftig@moz-DDC44F26.dip0.t-ipconnect.de)
[21:34:57] <strcat> or use a shortcut method to get what they want, because you'd probably use Result/Either
[21:35:01] <strcat> which are enums
[21:35:14] <doomlord> so my idea of error,value is like a manually expanded tagged-union (i'm hesitant to start calling that enum :) )
[21:35:40] <strcat> doomlord: you can't return that though
[21:35:46] <strcat> if you don't have a value, you can't return a value
[21:35:54] <strcat> you *need* to use an enum if you don't always get a value
[21:36:09] <cmr> Or use some meaningful non-value, which doesn't always exist
[21:36:25] <doomlord> ok match comes into its own with tagged-union/'enums' 
[21:36:27] <doomlord> i guess..
[21:36:37] <strcat> doomlord: well it matches against patterns
[21:36:44] <doomlord> or rather match has more possibilities not immiediately apparent to C++ -head
[21:36:55] <strcat> you can match against values inside fields of structs
[21:36:59] <strcat> match against variants of enums
[21:37:02] <strcat> values inside tuples
[21:37:08] <strcat> and any nested combination of those.
[21:37:11] <cmr> Values and ranges inside vectors too
[21:37:19] <cmr> There are also match guards
[21:37:29] <strcat> and ranges of integers
[21:37:31] <doomlord> i do like rusts' idea of everything-is-an-expression
[21:37:39] <cmr> match x { x if cond => {...}, x => ..., _ => ... }
[21:37:42] <doomlord> thats really elegant IMO
[21:38:13] <cmr> And like, match x { a | b => ..., c => ... }
[21:38:15] <doomlord> wait  what does that do, match x{ x if cond => ...
[21:38:25] <cmr> doomlord: only takes the arm if the condition is true
[21:38:33] <doomlord> ah, a | b ... much better way of doing fallthough :)
[21:38:35] <strcat> 'x' is the destructuring part
[21:38:40] <cmr> Oh, right
[21:38:49] <cmr> replaec "match x" with "match foo" :p
[21:38:54] <cmr> didin't realize I had a clash there
[21:39:20] <strcat> rusti: let x = Some(5); let y = Some(2); match (x, y) { (Some(a), Some(b)) => 1, _ => 2 }
[21:39:22] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/VXGC
[21:39:32] <strcat> rusti: let x = Some(5); let y = Some(2); match (x, y) { (Some(a), Some(b)) => a + b, _ => 0 }
[21:39:32] -rusti- 7
[21:39:38] <strcat> rusti: let x = Some(5); let y = Some(11); match (x, y) { (Some(a), Some(b)) => a + b, _ => 0 }
[21:39:39] -rusti- 16
[21:39:43] <strcat> rusti: let x = Some(5); let y = None; match (x, y) { (Some(a), Some(b)) => a + b, _ => 0 }
[21:39:43] <cmr> strcat: can you use -A unused-variable?
[21:39:44] -rusti- 0
[21:39:51] <strcat> cmr: I did before but I decided against it
[21:40:00] <cmr> Why?
[21:40:03] <strcat> sometimes you do want to demonstrate warnings
[21:40:06] <cmr> That's true
[21:40:11] <strcat> rusti: let mut x = 5; x
[21:40:11] -rusti- <anon>:9:17: 9:18 warning: variable does not need to be mutable [-W unused-mut (default)]
[21:40:12] -rusti- <anon>:9          let mut x = 5; x
[21:40:12] -rusti-                           ^
[21:40:12] -rusti- 5
[21:40:24] <strcat> rusti: let mut x = @mut 5; *x = 6; x
[21:40:25] -rusti- <anon>:9:17: 9:18 warning: variable does not need to be mutable [-W unused-mut (default)]
[21:40:25] -rusti- <anon>:9          let mut x = @mut 5; *x = 6; x
[21:40:25] -rusti-                           ^
[21:40:25] -rusti- @6
[21:40:30] *** Quits: tcsc (tcsc@moz-ADC0ED45.hsd1.ct.comcast.net) (Quit: computer sleeping)
[21:43:25] <doomlord> match SomethingThatMightFail { Some(x) => ...use x    None=>...it failed}  <<< so thats the better way of doing the 'check error code..'
[21:43:36] <cmr> doomlord: yep
[21:43:42] <strcat> well Option is only for when you have 1 error case
[21:43:44] <strcat> like looking up a key
[21:44:00] <strcat> either the key is there: Some(key), or it isn't: None
[21:44:13] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[21:44:18] <strcat> otherwise you can use Result
[21:45:02] <strcat> fn open(filename: &str, mode: FileMode) -> Result<File, OSError>
[21:45:16] <strcat> so you get either Ok(File) or Err(OSError)
[21:45:41] <strcat> where OSError can have an error code field + use strerror for to_str, or whatever
[21:47:50] <doomlord> does rust avoid null pointers outside of unsafe blocks
[21:48:13] <cmr> Not at runtime
[21:48:24] <cmr> You can't have a null dereference outside of unsafe blocks
[21:48:33] <cmr> But, like, Option<~Foo> is optimized into a nullable pointer
[21:48:47] <doomlord> perfect
[21:48:48] *** Quits: spider-mario (spidermari@moz-B8FA2FF4.rev.sfr.net) (Connection reset by peer)
[21:48:50] <strcat> doomlord: ~, & and @ are non-nullable
[21:48:57] <strcat> inside an Option, they'll optimize to a nullable ptr
[21:49:02] <strcat> but you can never accidentally deref null
[21:49:17] <strcat> rusti: std::sys::size_of::<~(int, int)>()
[21:49:18] -rusti- 8
[21:49:23] <strcat> rusti: std::sys::size_of::<Option<~(int, int)>>()
[21:49:24] -rusti- 8
[21:50:44] <doomlord> i suppose option could also do that sometimes nasty c pattern of "index, or -1"
[21:51:35] <strcat> doomlord: yes that's an error case where the error is always for the same reason
[21:51:44] <strcat> that's mostly what Option is for
[21:52:06] <strcat> decompress(data: &[u8]) -> Option<~[u8]>
[21:52:11] <roo> or where the error case is communicated out of bounds, though I am not sure that makes sense in rust for most things
[21:52:19] <cmr> (out of band)
[21:52:21] <strcat> only 1 error: invalid compressed data
[21:52:29] <roo> yeah thats what i meant XD
[21:52:34] <doomlord> would it be possible to get the same optimziation out of it... an index who might use  1bit or 1 value forvalidity
[21:52:53] <strcat> doomlord: an index will be a uint so there's no spare bit
[21:53:35] <cmr> and llvm isn't that smart, I don't think
[21:53:39] <strcat> if it inlines it can do whatever it wants though
[21:53:41] <strcat> and will
[21:53:44] <strcat> cmr: well it can;t
[21:53:56] <strcat> it's not allowed to change the ABI of an external function
[21:54:02] <doomlord> 31bit index or something
[21:54:07] <cmr> fastcc!
[21:54:11] <strcat> doomlord: we don't have a 31-bit integer type
[21:54:14] <strcat> cmr: still can't change the ABI
[21:54:18] <strcat> fastcc is a specific ABI
[21:54:33] <strcat> it can't sometimes decide to pass/return a certain type a different way
[21:54:33] *** Joins: rubber-duck (rubber-duc@moz-F5E2ABA9.dsl.iskon.hr)
[21:54:36] <strcat> it *has* to be consistent
[21:54:57] <doomlord> i suppose such cases can be rearchitected to something safer
[21:55:16] *** Joins: igl1 (igl@moz-3485F8C3.adsl.alicedsl.de)
[21:55:23] <strcat> doomlord: if the function is small enough for passing an extra word to matter, it's going to get inlined
[21:55:32] <strcat> it's not a kind of optimization you need to worry about
[21:55:39] <doomlord> sometimes it might be data, not a temporary
[21:55:44] <strcat> much like passing by-value vs by-ref
[21:55:54] *** Quits: igl (igl@moz-960CE228.adsl.alicedsl.de) (Ping timeout)
[21:55:57] <strcat> if you don't need ownership and it's a generic T, take it by-ref
[21:56:10] <strcat> if the function is big enough to not be inlined, the extra ptr in cache + deref won't matter
[21:56:18] <strcat> if it is inlined, it won't use a ptr
[21:56:38] <strcat> compilers aren't stupid enough for micro-optimizations like that to ever matter
[21:56:58] <doomlord> a low level case.. triangle indices with a bit or code for strip-breaks (perhaps thats a case for bitfields in option types or something..)
[21:57:12] <cmr> I'm amazed at how well LLVM optimizes our terrible IR
[21:57:15] <doomlord> tri-strip^
[21:57:23] <strcat> cmr: our IR isn't really terrible (beyond the undef behaviour)
[21:57:32] <strcat> it's just much, much more redundant than it should be
[21:57:33] <cmr> strcat: there's a lot of it and a lot of it is unnecessary
[21:57:37] <cmr> right
[21:57:40] <strcat> cmr: doesn't matter though
[21:57:48] <strcat> we still give it essentially the same set of information that clang does
[21:57:49] <doomlord> i always thought a big benefit of LLVM IR was IR->IR transformation optimizations being available across languages
[21:57:58] <strcat> it doesn't care how much IR it gets, it just takes longer to break down
[21:58:05] <cmr> doomlord: it is, and it does
[21:58:16] <cmr> strcat: and that amazes me!
[21:58:34] <strcat> cmr: doesn't really amaze me ;p, that's why it uses SSA
[21:58:46] <strcat> you can provide 200x as much IR doing the same thing and it will break down the same code
[21:58:54] <cmr> strcat: I don't know much about compilers and optimizations, so the things they do are often wonderous to me :)
[21:59:01] <strcat> if you actually add extra indirection via pointers, it won't
[21:59:03] <cmr> (implementing them, that is)
[21:59:26] <strcat> hurry up buildbot :(
[22:03:05] <brson> http://brson.github.io/archaea/index.html
[22:03:07] *** Quits: RMF (RMF@moz-8C13D5A2.dsl.telepac.pt) (Ping timeout)
[22:03:28] <cmr> brson: what's this?
[22:04:07] *** Joins: RMF (RMF@moz-8C13D5A2.dsl.telepac.pt)
[22:04:14] <cmr> Heh
[22:04:18] <cmr> "Revert" "Un-revert"
[22:05:32] * strcat should finally make rusti into a web server
[22:05:34] <strcat> service*
[22:05:54] <cmr> iter two() -> int { put 0; put 1; } impure fn main() { let vec[mutable int] a = vec(mutable -1, -1, -1, -1);
[22:05:55] <strcat> I have the backend part ;p
[22:05:57] <cmr> Hm that is one line
[22:06:02] <strcat> http://ix.io/6k6 woooo, web dev! ;p
[22:06:03] <cmr> Anyway
[22:06:09] <cmr> I'm glad rust doesn't look like that any more
[22:06:56] <engla> interesting website
[22:07:11] <cmr> Indexing was a.(0)?
[22:07:15] <cmr> What sort of syntax is that O_o
[22:07:27] <strcat> :D
[22:08:20] <brson> the generics are interesting http://brson.github.io/archaea/generic-fn.html
[22:08:53] <cmr> It's interesting to see the language evolve
[22:09:05] <cmr> I went trhough some xfail'd tests today
[22:09:16] <cmr> I didn't know rust ahd a `class` concept + keyword at one point
[22:10:48] <doomlord> class.. ew
[22:10:55] <strcat> meh I really hate javascript
[22:11:09] <cmr> doomlord: yeah the current system is muuuch better than what I saw
[22:11:18] <cmr> Which, of course, is why it's in place...
[22:11:36] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[22:15:08] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[22:15:18] <strcat> *@!&
[22:16:00] * strcat wishes "use strict"; enforced that the right # of params was passed
[22:16:19] *** Joins: ramige (ramige@moz-28AD658E.dynamic.ip.windstream.net)
[22:18:40] <brson> bstrie: I think my link got caught in the spam trap on reddit
[22:19:03] <strcat> http://ix.io/6k8
[22:19:28] <strcat> now if only I knew where my attempt at doing it in js was going wrong...
[22:19:43] <strcat> does XMLHttpRequest not allow you to specify a port?
[22:19:47] * strcat shrugs
[22:19:56] <cmr> no I don't think so
[22:20:16] <cmr> because of cross-origin
[22:20:24] <strcat> any way to override that? ;\
[22:20:25] <cmr> there's a header you can set to allow it
[22:20:30] <cmr> I don't remember what it is any more.
[22:20:31] <strcat> ah
[22:20:35] <strcat> I'll do that
[22:20:36] * cmr is an expatriate web dev
[22:20:46] <strcat> I don't feel like actually setting up proxying from nginx
[22:20:54] <strcat> just for this...
[22:21:47] <cmr> CORS, that's what it is
[22:22:16] *** Parts: steven_is_false (user@moz-144077DE.bchsia.telus.net) (ERC Version 5.3 (IRC client for Emacs))
[22:22:34] <strcat> cmr: http://www.w3.org/TR/2008/WD-access-control-20080912/#access-control-allow-origin
[22:22:40] <strcat> alright
[22:22:40] <strcat> lemme try that
[22:24:40] <strcat> or I could just serve static files from python
[22:24:51] * strcat will just do that
[22:28:32] *** Joins: dew (Instantbir@moz-66796D51.dhcp.stls.mo.charter.com)
[22:28:51] *** Joins: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net)
[22:29:03] *** Quits: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net) (Quit: tikue)
[22:29:43] *** Quits: victorporof (victorporo@70DEDDA.9004F55.9B1E38F4.IP) (Quit: victorporof)
[22:29:49] <cmr> Blei's intrinsics overhaul PR brings the pre-llvm spike in librustc under 1GB \o/
[22:30:18] <rubber-duck> how come string implements Zero but Zero is a numeric trait :|
[22:30:51] <strcat> rubber-duck: because for some reason that got used instead of something called Default with 'new' method
[22:30:55] <strcat> I think it was a mistake
[22:31:06] <rubber-duck> also in vec
[22:31:09] <strcat> feel free to open an issue about it
[22:31:12] <engla> I think logically Zero should iniherit some kind of more basic trait to create a new value(?)
[22:31:20] <rubber-duck> yea default sounds more correct
[22:31:30] <strcat> trait Default { fn new() -> Self; }
[22:31:33] *** Quits: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net) (Ping timeout)
[22:31:50] <engla> the idea is to be able to zero structs, like in C  struct X x = {0}
[22:32:19] <strcat> okay but ~[] isn't "zero" for any definition of zero
[22:32:31] <strcat> or ""
[22:32:40] <strcat> or an empty set/map
[22:32:41] <rubber-duck> engla, I don't think that's a valid use case - since you can't initialize some fields as 0 
[22:32:58] *** aatch|bed is now known as aatch
[22:33:05] <engla> what kind of fields are you thinking of?
[22:33:12] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[22:33:18] <rubber-duck> engla, any reference/pointer ?
[22:33:39] <rubber-duck> engla, eg. owned pointer can't be 0 ?
[22:33:58] <kimundi> better trait Default { fn new_default() -> Self; though, wouldn't want to needlessly block the short name 'new()'
[22:34:05] <engla> true, it would use the Zero impl of the ~T
[22:34:23] <strcat> kimundi: 'new' without an argument is a perfectly fine thing to call a default
[22:34:28] <rubber-duck> you can maybe create a instance of ~T with Zero recursively but that doesn't sound very useful 
[22:34:39] <rubber-duck> strcat, but can you overload the name ?
[22:34:47] <strcat> don't know what you mean
[22:35:03] <rubber-duck> ie. can you have Foo::new() and Foo::new(arg...)
[22:35:07] <strcat> no
[22:35:15] <strcat> if a type can implement a no-parameter method for construction, they can implement Default's new method
[22:35:19] <aatch> but you call trait methods as Trait::new
[22:35:44] <strcat> if they have 2 methods for construction with no parameters, they can call the one they want to be default construction 'new' (if they want that) or just *not implement the trait* if they don't
[22:35:47] <strcat> there's no conflictr
[22:36:05] <strcat> adding something to a trait doesn't reserve the name
[22:36:10] <kimundi> strcat: Well ironically 'new()' wouldn't really be the default one then, but the specific 'initialisize with default value'
[22:36:44] <strcat> dunno what you mean
[22:36:54] <kimundi> let x = Point::new(23, 54); let y = point::new_empty();
[22:36:56] <strcat> if a type wanted to implement Default, they could implement it
[22:37:07] <strcat> kimundi: sure, they can still do that
[22:37:17] <strcat> traits don't reserve names
[22:37:19] <engla> HashSet::new() is better than calling   Default::new()
[22:37:24] <engla> clearer code
[22:37:26] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Quit: Leaving.)
[22:37:29] <kimundi> not if they want to implement Qefault at the same time, no?
[22:37:31] <strcat> engla: and method reform will allow that
[22:37:42] <engla> that's good
[22:37:43] <strcat> kimundi: if they want to implement default, the 'new' method can't take any arguments
[22:37:48] <strcat> I'm failing to see what your point is ;\
[22:38:09] *** Quits: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP) (Quit: night)
[22:38:10] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[22:38:28] <engla> I like it. Simple traits are great.
[22:38:31] <strcat> if they don't have a sensible default construction they shouldn't implement Default
[22:38:44] <strcat> or whatever it's called.
[22:39:10] <strcat> if they do have a sensible default construction without parameters, they can implement it
[22:39:14] <kimundi> That you want to provide Default for convinience, but also want your new() fn to take arguments because that's the one you'd usually use to construct the type manually.
[22:39:27] <cmr> Those are conflicting requirements
[22:39:29] <aatch> strcat, by the way, I'm pretty sure there is a Zero impl for strings
[22:39:33] <rubber-duck> if you define it like that then "new" by convention becomes a "initialize with no args" right - but I've seen new used already is there a convention already for using it ?
[22:39:38] <strcat> aatch: I know, but there shouldn't be
[22:39:42] <strcat> it's really, really wrong to do that
[22:39:50] <strcat> we should have added a trait, not misused Zero ;\
[22:40:07] <cmr> kimundi: Would probably need to introduce `init` if you want both...
[22:40:22] <aatch> rusti: let a : ~str = Zero::zero(); a
[22:40:23] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/PSOe
[22:40:31] <strcat> aatch: I know it's there
[22:40:32] *** Quits: roo (Mibbit@moz-2D4AC215.dynamic.ip.windstream.net) (Quit: http://www.mibbit.com ajax IRC Client)
[22:40:37] <strcat> I'm saying it shouldn't be
[22:40:45] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[22:40:49] <strcat> default initialization != zero
[22:41:06] <aatch> Eh, I don't find much use for Zero in general
[22:41:07] <strcat> a type can have a zero value that isn't the default initialization
[22:41:39] <strcat> anyway reporting a bug
[22:41:54] <cmr> strcat: example: UUID
[22:41:55] *** Quits: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk) (Connection reset by peer)
[22:42:02] <aatch> anyway, so bors has taken a chill pill?
[22:42:06] <cmr> (good example, atleast)
[22:42:08] <strcat> aatch: yep
[22:42:08] <cmr> aatch: yes
[22:42:13] <strcat> aatch: graydon reverted a change he made
[22:42:28] *** Joins: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk)
[22:42:32] <cmr> he really shouldn't screw with our essential infrastructure and then go to bed :p
[22:43:31] *** Joins: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net)
[22:43:37] <kimundi> What I mean is, a Default imp usually means you're not calling the constructor yourself, but letting it call by someone else, wich means it doesn't matter much if it's the longer form. If you call the constructor yourself you'd probably want 'new()' be the one that does the most obvious thing: let s = String::new("hell"); let p = Point::new(15,69);
[22:44:17] <strcat> from_str from_coords
[22:44:29] <strcat> now you actually know what it's doing from looking at it
[22:44:38] <cmr> (15, 69) as Point
[22:45:19] <aatch> struct Point(int,int); Point(1,2)
[22:45:33] *** Quits: ramige (ramige@moz-28AD658E.dynamic.ip.windstream.net) (Quit: Leaving)
[22:45:48] <kimundi> I mean, I'd see it as kinda pointless if the new recommended name instead of 'new(...)' becomes 'new_with(...)', and even more pointless to have no convention at all for a constructor function name.
[22:46:25] <Luqman> i thought the convention was new(), and from_*()
[22:46:52] <strcat> kimundi: the recommended name for a zero-parameter fn is new
[22:47:16] <rubber-duck> welp then it makes sense to formalize that as Default trait I agree
[22:47:19] <strcat> anyway I'm fine with using init() for Default
[22:47:24] <cmr> kimundi does make a good point though... `new` is a nice name to have reserved for Default
[22:47:24] <strcat> I don't care about new vs init
[22:47:31] <strcat> cmr: ok so I'll use init
[22:47:43] <cmr> or, too nice of a name, that is
[22:47:46] <cmr> strcat: I'm fine with that
[22:48:17] <strcat> if a type's default initialization is the main way it's initialized (probably the case most of the time), it might as well be the nicest name
[22:48:51] <cmr> Yeah. And I really don't see Default being used outside of... mostly containers
[22:49:20] <aatch> sully, ping
[22:49:51] <sully> aatch: pong
[22:50:01] <aatch> sully, you got any ideas about: https://github.com/mozilla/rust/issues/7295
[22:50:45] <sully> aatch: yeah, I found that bug on Wednesday or Thursday and have a fix in my repo
[22:50:53] <sully> was planning to batch it up with some other fixes
[22:50:54] <aatch> sully, ah, awesome!
[22:50:58] <Luqman> strcat: rebased https://github.com/mozilla/rust/pull/7269
[22:51:10] <aatch> sully, is it a single commit that I can cherry-pick?
[22:51:20] <sully> yeah one second
[22:51:55] <aatch> (It's kinda-not-really blocking a project I'm working on)
[22:52:40] <sully> I pushed my working branch to my fork; the commit mentioned the issue
[22:52:51] <aatch> sully, thanks
[22:53:36] *** Joins: roo (Mibbit@moz-2D4AC215.dynamic.ip.windstream.net)
[22:54:56] *** sam113101_afk is now known as sam113101
[22:55:54] <sully> at least, I think that is the same bug
[22:56:00] <sully> tell me if that doesn't fix it
[22:57:05] <cmr> sully: add it to the test suite..
[22:58:50] <sully> it's the weekend, and this is a work in progress patch
[22:59:55] <sully> but yeah, I will commit tests for it
[23:00:09] *** Quits: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com) (Ping timeout)
[23:00:47] <aatch> sully, so looking at your commit, seems like I was mostly right in my analysis, it was looking for a trait parameter in the function's parameter list?
[23:01:15] *** Quits: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Ping timeout)
[23:01:46] <sully> well, the parameter lists need to be combined
[23:01:55] <sully> and it wasn't properly getting the parameters on the trait
[23:02:10] *** Quits: Azdle (patrick@moz-7C097820.hsd1.mn.comcast.net) (Quit: Leaving)
[23:02:37] <aatch> sully, ok. Everything between driver and trans is a mystery to me to be honest
[23:03:21] <cmr> So having looked at a lot of memory usage graphs of rustc, a typical example of which is http://i.imgur.com/zySpBGe.png, it seems between the big pre-llvm spike and the plateau there is a large chunk of memory that isn't getting free'd.
[23:03:36] *** Quits: cdidd (cdidd@moz-664B49E1.broadband.corbina.ru) (Input/output error)
[23:03:40] <cmr> I imagine the big spike is trans or something, and the drop is the AST
[23:03:55] <aatch> cmr, probably a cycle somewhere
[23:03:57] <cmr> But what's all the gunk before the climb to the spike that isn't getting free'd?
[23:04:07] *** Joins: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[23:04:11] <Luqman> aatch: i know that feeling. I thought i had somewhat understood typeck::method... nope :P
[23:04:22] <cmr> Figuring out what it is and how to get rid of it would do miracles for memory usage..
[23:04:24] <sully> I mean, we build up tons of tables
[23:04:30] <sully> and keep them for basically ever
[23:04:35] <sully> shoved in session and tcx and stuff
[23:04:49] <aatch> cmr, graydon's gc might help in some cases.
[23:05:02] <cmr> I looks like the drop after the spike is equal in magnitude to the bumpy rise after the startup-climb
[23:05:46] <aatch> cmr, possibly the ast, since I think we drop it after trans
[23:06:01] <cmr> What would be built up before the AST?
[23:06:07] <aatch> or atleast, some of the AST
[23:06:10] <strcat> aatch: no, the gc will only increase mem usage
[23:06:16] <strcat> it's not going to make things better
[23:06:23] <strcat> unless we migrate 99% of things to extra::rc
[23:06:28] <aatch> strcat, let me live in hope!
[23:06:35] <strcat> aatch: it still hits oom on 32-bit
[23:06:38] <strcat> with his gc
[23:06:46] <strcat> so it's like 3x mem usage ;\
[23:07:00] <strcat> I think we'll have no choice but to add a pointer trait + migrate to extra::rc to land it
[23:07:07] <aatch> That said, there is a lot that could be move to Rc<T>
[23:07:13] <strcat> because I don't think it'd be acceptable to regress mem usage that much
[23:07:27] <cmr> rustc is already a disgusting memory glutton
[23:08:10] <cmr> I wonder... would it be possible to dump IR to disk, kill the rustc process, run LLVM on the IR, and then do all the `back` stuff?
[23:08:23] <cmr> or separate it into a task or something
[23:08:27] <strcat> no need
[23:08:34] <strcat> cmr: the latter
[23:09:00] <aatch> It's the fact that the AST isn't sendable that's the problem
[23:09:10] <strcat> or we could just migrate 99% to &/~/Rc and land the gc for things that can have cycles
[23:09:12] <strcat> would be fine
[23:09:13] <aatch> because of the heavy @-usage
[23:09:53] <cmr> Does Rc perform better than the current @?
[23:09:53] <aatch> That said, I'm not sure if the AST has any cycles...
[23:10:10] * cmr goes to look at the fabled Rc's implementation
[23:10:24] <aatch> cmr, probably slightly worse, but not much.
[23:10:28] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[23:11:16] <rubber-duck> wait if from_ is the convention for constructor - why does Path use Path("...") ? shouldn't it be Path::from_str("...") ?
[23:11:29] <aatch> rubber-duck, yes, it should
[23:11:29] <strcat> cmr: the compiler doesn't support making smart pointers yet
[23:11:33] <strcat> there's no way to omit the drop flag
[23:11:43] <strcat> when we can omit the drop flag, Rc will perform better than @
[23:11:46] *** Quits: bytbox (s@moz-2E27684C.student.umd.edu) (Ping timeout)
[23:11:49] <strcat> because @ copies instead of moving.
[23:12:15] <strcat> Rc isn't a pointer right now, it's 2 words - ptr and drop flag
[23:12:30] *** Quits: cr (anonymous@moz-21AE2A3.dip0.t-ipconnect.de) (Ping timeout)
[23:12:35] <strcat> yay for things being special cased in the compiler and user-defined types being second-rate
[23:13:13] <strcat> + no way to extra::Rc have an * operator
[23:13:55] <rubber-duck> aatch, it doesn't seem to work, Path::from_str() = "\"!!! (resolving module in lexical scope) module wasn\\\'t actually a module!\""
[23:14:19] <aatch> rubber-duck, that's probably because there isn't a method.
[23:14:34] <aatch> the Path("...") style is old
[23:14:36] <cmr> I have a feeling Path is some of the oldest code in the compiler.
[23:14:44] <cmr> well, in libstd
[23:14:56] <aatch> feel free to modernize it.
[23:15:15] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[23:15:19] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[23:15:24] <strcat> ok anyway this crappy web service works
[23:15:40] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Leaving...)
[23:15:45] <engla> there is an issue to change it. a linux path is not compatible with the restrictions placed on the str type
[23:16:00] <strcat> yes it should use [u8]
[23:16:04] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[23:16:07] <strcat> so should env variables
[23:16:17] <cmr> Paths on windows are utf-16 though
[23:16:26] <rubber-duck> oh it turns out it's defined in GenericPath trait so I need to call let foo : Path = GenericPath::from_str()
[23:16:30] <strcat> cmr: on NTFS
[23:16:33] *** Quits: vk (chatzilla@F92596F.2DEF7520.EF7679FA.IP) (Ping timeout)
[23:16:41] <cmr> strcat: who uses non-NTFS?
[23:16:47] <strcat> cmr: doesn't matter, has to be supported
[23:16:57] <cmr> strcat: right, but so does the utf-16 case
[23:17:04] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[23:17:08] <strcat> cmr: there will be files you can't remove/open
[23:17:17] <strcat> assuming windows supports that
[23:18:00] <strcat> UDF enforces unicode file names without \0, hmm
[23:18:32] <brson> nmatsakis: I intend to move all the dynamic borrowck code  from unstable::lang to rt::borrowck to make it accessible to the annihilator under the new scheduler
[23:18:48] <cmr> Whoa, what's dynamic borrowck
[23:19:02] <aatch> cmr, the stuff that handle @mut borrowing
[23:19:12] <cmr> Ah, rooting and that "fun" stuff?
[23:19:13] <aatch> handles*
[23:19:21] <aatch> more like freezing
[23:19:37] <strcat> cmr: dynamically failing
[23:19:57] <strcat> cmr: look at the extra::rc::RcMut implementation
[23:20:01] <strcat> with_borrow and with_mut_borrow
[23:20:04] <strcat> @mut does it *implicitly*
[23:20:17] <aatch> strcat, what was your idea for removing the drop flag?
[23:20:20] <strcat> https://github.com/mozilla/rust/issues/7140 <- which I think is bad
[23:20:30] <strcat> aatch: #[no_drop_flag], zero the struct instead and call the destructor N times
[23:20:47] <aatch> So it's up to the author to handle it?
[23:20:50] <strcat> until nmatsakis and pcwalton figure out how to statically remove it at least
[23:20:51] <strcat> aatch: sure
[23:21:02] <strcat> it is in C++
[23:21:15] <aatch> hmm, doesn't look like it'd be too hard.
[23:21:23] *** Joins: Lovot (root@AE31FB56.8153C3BF.F3C9A2D9.IP)
[23:21:31] <cmr> To the aatch-mobile!
[23:21:55] <strcat> free(nullptr) is a no-op and that's what unique use
[23:22:05] <strcat> Rc/RcMut would check if the ptr is null before doing refcount -= 1
[23:22:16] <strcat> unique pointers use*
[23:22:18] <cmr> strcat: with_borrow and with_mut_borrow don't look that bad...
[23:22:20] <aatch> (disclaimer: all assertions of difficultly are relative to the badness of trans)
[23:22:26] <strcat> cmr: sure, but they have fail cases
[23:22:33] <strcat> cmr: and @mut has those same fail cases
[23:22:46] <strcat> it's just entirely implicit so 99% of users aren't going to realize they are opting into dynamic failures
[23:22:51] <cmr> Yeah
[23:22:58] <strcat> confusion about the 'borrowed' error is common here
[23:23:10] <strcat> it should be explicitly opt-in imo
[23:23:16] <strcat> if you pass around @mut by-value instead, it won't value
[23:23:16] <cmr> I agree with that
[23:23:20] <strcat> won't fail*
[23:23:24] * strcat can't type atm
[23:23:36] <strcat> cmr: well go voice your agreement on the issue :)
[23:23:39] <kemurphy> can someone tell me what BoxHeaderRepr.{prev,next} are used for?
[23:23:41] *** Joins: devbug_ (quassel@moz-E1DE087C.bchsia.telus.net)
[23:23:42] <cmr> Avoiding dynamic failure is one of the reasons I am interested in Rust
[23:23:47] <strcat> cmr: https://github.com/mozilla/rust/issues/7140 <- there
[23:23:50] <aatch> kemurphy, for the box annihilator
[23:23:57] <cmr> kemurphy: linked list of something or another
[23:24:01] *** Quits: devbug (quassel@moz-E1DE087C.bchsia.telus.net) (Ping timeout)
[23:24:04] <strcat> kemurphy: for exchange allocations, the header shouldn't be there
[23:24:22] *** Quits: vittorioromeo (quassel@moz-45F541F0.retail.telecomitalia.it) (Input/output error)
[23:24:23] <aatch> the allocations form a linked list that the annihilator traverses to free the data.
[23:24:31] <aatch> because you can get cycles with @
[23:24:39] <strcat> @, @mut and ~ *containing* managed pointers need the header until the gc lands
[23:24:52] <strcat> but ~ without managed pointers shouldn't have it - it's awful
[23:24:53] <aatch> as strcat says, it shouldn't even be there for regular ~-ptrs
[23:25:05] <strcat> worst performance issue in all of rust imo
[23:25:13] <strcat> makes trees nearly unusable
[23:25:15] <kemurphy> aatch: ah, i don't see them being used anywhere besides cleanup.rs in libstd
[23:25:37] <strcat> kemurphy: right, they're only there to free cycles when a task ends
[23:25:37] <aatch> kemurphy, might be in src/rt
[23:25:45] <kemurphy> strcat: ah gotcha. /me is rooting around with zero.rs and related stuff, looks like it should be safe to cut away
[23:25:52] <strcat> @mut needs a place to store whether it's frozen too
[23:25:56] <strcat> kemurphy: cutting it away won't work though
[23:26:00] <strcat> kemurphy: the compiler needs to be fixed
[23:26:04] *** Joins: dbaupp (Thunderbir@moz-73E90475.lns20.syd6.internode.on.net)
[23:26:11] <strcat> for example closures calling the exchange allocator (~fn) and store their size in the header
[23:26:16] *** Joins: jrfeenst (jrfeenst@moz-F912484F.cpe.norwoodlight.com)
[23:26:28] <kemurphy> ... hence why they're called null_0 and null_1 in zero.rs. makes sense now.
[23:26:34] <strcat> and everything assumes it has a header
[23:26:44] <strcat> so you can't make the allocs not have that space
[23:26:54] <strcat> everything is an offset from the start
[23:27:09] <strcat> anyway, terrible implementation issue that needs to be fixed
[23:27:24] <strcat> happens to be *the thing* that I dislike most about rust atm
[23:27:46] * strcat has a fairly good idea on how to go about removing it though
[23:27:47] <kemurphy> anyone currently working on it, or any plan for a fix yet?
[23:27:52] <strcat> kemurphy: no one is working on it
[23:28:01] <strcat> and there's no schedule on when it will get fixed
[23:28:09] <cmr> kemurphy: it can be trivially removed after the GC lands according to graydon.
[23:28:16] <strcat> cmr: that's not really true
[23:28:24] <strcat> I don't think graydon knows how much depends on it in trans
[23:28:29] <strcat> and that ~fn uses it
[23:28:59] <strcat> the headers on exchange allocs can be removed *now*
[23:29:02] <strcat> the gc doesn't have to land
[23:29:04] <strcat> doesn't matter
[23:29:14] <kemurphy> strcat: i'm almost tempted to give it a stab, but i fear i might need more knowledge of the inner workings of rustc than i currently have
[23:29:21] <strcat> kemurphy: it's going to be a pain
[23:29:34] <strcat> the first step is making it so the header doesn't have to be initialized by the exchange allocator
[23:29:43] <strcat> so you'd need to split ~fn off to a different allocator
[23:29:46] <strcat> which means adding lang items
[23:29:51] *** Joins: victorporof (victorporo@70DEDDA.9004F55.9B1E38F4.IP)
[23:29:57] <kemurphy> aren't there already separate lang items?
[23:29:59] <strcat> + ~fn probably uses the same glue code as ~
[23:30:01] <strcat> kemurphy: no
[23:30:06] <strcat> ~fn uses the exchange allocator + uses the header
[23:30:09] <kemurphy> there's exchange_malloc and malloc
[23:30:19] <kemurphy> and exchange_free and free
[23:30:23] <strcat> kemurphy: doesn't matter, ~fn can't use local_malloc
[23:30:32] <strcat> (malloc)
[23:30:41] <strcat> needs to be a third set of them
[23:30:47] <kemurphy> ah gotcha
[23:30:49] <strcat> + fixing trans glue
[23:31:02] <strcat> for example the current glue for copying ~ boxes always copies over the header
[23:31:15] <strcat> so it needs to only copy the header for ones with managed pointers inside or ones that are ~fn
[23:31:36] <strcat> + whatever other stuff is horribly broken that I didn't run into yet
[23:31:59] <strcat> but anyway you can make your own unique pointer that doesn't suck instead
[23:32:09] <strcat> if only we could omit the drop flag, at least
[23:32:54] <strcat> but anyway if you have any code that needs allocations, it'll be worse than java right now.
[23:33:19] <kemurphy> should i go read Rc<T> for an example?
[23:33:25] <aatch> strcat, I'm trying to omit the drop glue
[23:33:55] <aatch> hard part at the moment is getting the information to glue
[23:34:00] <aatch> drop flag*
[23:34:55] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Client exited)
[23:35:45] *** Quits: victorporof (victorporo@70DEDDA.9004F55.9B1E38F4.IP) (Ping timeout)
[23:35:48] <strcat> kemurphy: there's a unique ptr in the ffi tutorial
[23:36:01] <strcat> kemurphy: but atm rust adds a drop flag so the "pointer" is 2 words instead of 1
[23:37:18] <strcat> all things that will be fixed, but I can't tell you when... :(
[23:37:31] <strcat> hopefully before 1.0
[23:37:40] <strcat> because it's embarrassingly bad
[23:38:19] <aatch> sully, that patch fixes the issue
[23:39:17] <kemurphy> strcat: cool, thanks :)
[23:39:30] <sully> aatch: excellent
[23:40:06] <aatch> I haven't actually tested to see if the code it compiles works, but it compiles
[23:41:13] <kemurphy> strcat: i'm actually still curious so i'm gonna go poke around in librustc/middle/trans/ for a bit and see how long it takes before i get totally lost :P
[23:42:10] <strcat> http://i.imgur.com/ryIIenJ.png got it working
[23:42:11] <strcat> yay
[23:42:33] <strcat> just need to use a real app server so it can be concurrent
[23:42:36] <aatch> sweet!
[23:43:00] * strcat *thinks* playpen should already handle concurrency
[23:43:03] <strcat> but I haven't tested
[23:43:37] <strcat> mount namespace + MS_PRIVATE + read-only filesystem and the cgroups are namespaced as playpen/parent_pid
[23:43:50] * strcat tries
[23:44:45] <kemurphy> hm, what's the difference between heap_managed and heap_managed_unique?
[23:45:20] <strcat> kemurphy: managed unique is a ~ containing a managed ptr
[23:45:35] <strcat> it needs to be known about by the gc
[23:45:49] <strcat> the exchange allocator is only for ~ *not* containing @
[23:46:20] <strcat> what makes it so problematic is that lots of trans code treats both kinds of ~ as the same thing
[23:47:43] <kemurphy> i see
[23:48:55] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[23:52:47] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[23:59:26] <strcat> yay
[23:59:29] <strcat> bors landed something

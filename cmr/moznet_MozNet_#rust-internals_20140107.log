[00:03:17] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[00:03:17] *** ChanServ sets mode: +ao dherman dherman
[00:16:00] <acrichto> brson: we really need core dumps on linux
[00:16:16] <acrichto> brson: this intermittent failure on run-fail tests I've only seen on linux, not on osx yet (where we have core dumps)
[00:16:38] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[00:16:38] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14d20bcc4 to 141f1838e: 02http://git.io/N3iJvQ
[00:16:39] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[00:29:54] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Quit: Lost terminal)
[00:30:08] *** Joins: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com)
[00:30:53] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[00:30:53] *** ChanServ sets mode: +qo brson brson
[00:31:53] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[00:31:53] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 148349dbc to 141f1838e: 02http://git.io/N3iJvQ
[00:31:53] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[00:31:55] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[00:31:55] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/4HbJnQ
[00:31:55] <ghrust> 13rust/06auto 142297b08 15Brian Anderson: Use the full version string for the windows installer exe
[00:31:55] <ghrust> 13rust/06auto 1421f9fa4 15Brian Anderson: Delete the installer exe when cleaning
[00:31:55] <ghrust> 13rust/06auto 14b6602cb 15bors: auto merge of #11354 : brson/rust/versionwin, r=alexcrichton...
[00:31:57] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[00:33:50] *** Quits: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Quit: lkuper)
[00:35:10] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[00:36:03] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[00:36:03] *** ChanServ sets mode: +qo brson brson
[00:48:18] *** Quits: geoffhill (geoffhill@moz-738DC0DB.org) (Ping timeout)
[01:05:01] <dbaupp> acrichto: ping
[01:05:06] <acrichto> dbaupp: pong
[01:05:41] <dbaupp> acrichto: the reason that native::start starts on a task with None for the stack bounds is we have no sane way to find them, right?
[01:05:54] <acrichto> dbaupp: yeah, but that's going to have to change
[01:05:59] <dbaupp> (find the bottom edge, that is)
[01:06:03] <pcwalton> brson: r? https://github.com/mozilla/rust/pull/11358
[01:06:06] <acrichto> we should just make a guess...
[01:06:35] <dbaupp> oh, *have* to change? why?
[01:06:59] <acrichto> right now the main thread on libnative is not protected against stack overflow
[01:07:07] <acrichto> which if we make the default to be libnative, that's unacceptable
[01:07:23] <acrichto> this is why lang_start (unused) in libnative spawns a new thread to run the main function
[01:07:31] <acrichto> but that's also unacceptable for all gui applications
[01:08:10] <dbaupp> ah, ok
[01:08:25] *** Joins: canhtak (canhtak@moz-DB18D73D.wl.t.ulaval.ca)
[01:08:55] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[01:10:04] <dbaupp> acrichto: would it be ok if I converted at least just converted stack_bounds to return (uint, Option<uint>) for now? (since we always know the top edge/some approximation to the top edge)
[01:10:23] <dbaupp> (well (Option<uint>, uint), I guess.)
[01:10:39] <acrichto> yeah I'd be ok with that
[01:11:38] <acrichto> dbaupp: honestly for now we should just say that the size of the main thread is 2MB
[01:11:51] <acrichto> I *think* it's at least that most of the time
[01:12:06] <dbaupp> should I just do that, and file a bug about doing it properly?
[01:12:23] <acrichto> yeah I think that's fine
[01:12:30] <acrichto> don't bother updating native::lang_star
[01:13:18] *** kimundi is now known as zz_kimundi
[01:13:52] <dbaupp> just native::start?
[01:14:01] <cmr> wouldn't it be (uint, Option<uint>) ? stack grows from high to low. the lower bound isn't known.
[01:14:15] <dbaupp> cmr: it's (low, high)
[01:14:23] <cmr> right
[01:14:25] <cmr> oh
[01:14:27] <cmr> derp
[01:14:38] <dbaupp> acrichto: also, shouldn't it be *() (or something) rather than uint?
[01:14:41] * cmr blames the painkiller
[01:15:08] <acrichto> dbaupp: I don't have a preference one way or another, I assume uint == sizeof(pointer) so it doesn't really matter that much to me
[01:15:32] <cmr> I don't think they're ever treated as a pointer
[01:16:28] <dbaupp> cmr: painkiller?
[01:16:44] <cmr> I had some minor surgury done today. Minor, but painful
[01:16:53] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[01:17:08] <dbaupp> acrichto: GreenTask.coroutine is always Some in any context in which one might be interested in stack_bounds, right?
[01:17:15] <dbaupp> cmr: get well soon :)
[01:17:24] <cmr> dbaupp: thanks!
[01:17:39] <acrichto> cmr: oh dear you should definitely take it easy!
[01:17:55] <acrichto> dbaupp: yes, sched tasks are the ones that don't know the stack bounds (they run on native threads)
[01:18:07] <cmr> acrichto: Why do GUI apps need to run on the main thread, exactly?
[01:18:11] *** Quits: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com) (Quit: Jesse)
[01:18:19] <cmr> I know it's a restriction, but I never quite understood why.
[01:18:22] <acrichto> cmr: not entirely sure, I'm just told that nothing works if you don't use the main thread
[01:18:29] <cmr> Does it matter which thread they use, as long as it's the same thread?
[01:18:49] <acrichto> I think the main one is special somehow
[01:19:49] *** Joins: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com)
[01:20:26] *** Joins: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[01:22:35] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[01:24:07] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[01:26:05] <brson> on win32 and cocoa the gui only works on the main thread but I don't know why
[01:26:08] <brson> doesn't seem to matter with X
[01:28:01] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.2)
[01:31:18] <cmr> win32 is sad, but what's cocoa's excuse? ;p
[01:35:58] <pnkfelix> cmr: this discussion thread seems relevant: http://www.cocoabuilder.com/archive/cocoa/315103-why-is-the-threading-and-ui-updating-designed-to-be-done-only-on-main-thread.html
[01:35:59] <aatch> X doesn't need the main thread, but GL normally wants it.
[01:41:07] <pnkfelix> cmr: (or at least, I had thought from my initial skim that it had informed Apple employees who were involved in Cocoa's design.  But now I think it only had at best *clients* of Cocoa from Apple, not the designers.)
[01:41:39] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[01:41:40] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/4HbJnQ
[01:41:40] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[01:42:53] *** Quits: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com) (Quit: Jesse)
[01:43:13] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[01:44:27] <dbaupp> Hm, now that we have std::gc::Gc separate to @; it might actually be feasible to land a proper (but crude) GC for Gc, because we don't have to worry about memory use while bootstrapping (at least, not now). any thoughts?
[01:44:44] <cmr> all of my +1
[01:45:40] <sfackler> wasn't pcwalton working on integrating bohem yesterday?
[01:45:59] <cmr> that was dbaupp :p
[01:46:08] <cmr> or actually that may have been pcwalton yesterday
[01:46:18] <pcwalton> not me
[01:46:28] <sfackler> oh
[01:46:38] <brson> i'm going to have to buy a new computer for rust dev. i keep ooming
[01:46:38] <dbaupp> sfackler: I wrote https://github.com/huonw/boehm-rs if that's what you're thinking of
[01:46:41] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[01:46:41] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/ZsfDUg
[01:46:41] <ghrust> 13rust/06auto 1403e9157 15Alex Crichton: Don't read forever on a file descriptor...
[01:46:41] <ghrust> 13rust/06auto 1488cd935 15Alex Crichton: Fix parallel makefile builds...
[01:46:41] <ghrust> 13rust/06auto 14529785e 15Alex Crichton: Don't abort if duplicate rlibs are found
[01:46:43] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[01:46:49] <pcwalton> dbaupp: I'm ok with it
[01:47:14] <pcwalton> as pnkfelix pointed out though, we need to investigate how easy it would be to make Boehm not stop all threads.
[01:47:22] <pcwalton> I think that's the most important thing to do before committing to boehm
[01:47:58] <dbaupp> I asked http://stackoverflow.com/questions/20921988/running-boehm-gc-per-thread about that, btw.
[01:48:13] <cmr> there's also http://www.ravenbrook.com/project/mps/ too
[01:48:15] <dbaupp> I guess finding the boehm mailing list and asking it there would be a good idea too.
[01:48:28] <dbaupp> cmr: doesn't that have some licensing concerns
[01:48:45] <cmr> dbaupp: yes but we really just need to *ask* to resolve them
[01:48:51] <pcwalton> dbaupp: IIRC they're resolvable
[01:48:52] <cmr> (ie, they're not untenable unless the devs say no)
[01:48:58] <dbaupp> ok
[01:49:59] <cmr> I'll ask them about it
[01:51:12] <klutzy> on win32 gui works on non-main thread; it just becomes complicated since gui window is sticked to thread
[01:51:39] <cmr> klutzy: so as long as you do all the work on the thread you started with, it's fine?
[01:52:21] <pnkfelix> dbaupp: pcwalton: even if we cant hack BDW to not stop all threads, it still might be nice to have it integrated just as a reference point while working on other GCs.
[01:52:26] <pcwalton> yup
[01:52:42] <klutzy> cmr: yep. I even have a hello-gui exe written in rust
[01:52:52] <cmr> Ok, that resolves windows.
[01:53:14] <cmr> I might try writing a silly cocoa thing that inits off the main thread...
[01:54:46] <dbaupp> pcwalton, pnkfelix: it would be pretty cool to have some way to swap in different GCs "live", like we can swap in different runtimes; any thoughts on how to do this? (Each Task object stores a ~GcAllocator object, where GcAllocator is a trait, and do something like libgreen and libnative?)
[01:55:11] <pcwalton> perhaps, yeah. although I would be kinda sad to lose the inline fast path but maybe it doesn't matter
[01:55:21] <dbaupp> hm, yeah
[01:56:04] <cmr> task_gc, ala task_rng?
[01:57:00] <pnkfelix> dbaupp: the tricky part there is whether you want to go all the way to supporting swapping in GC's that require different write-barriers
[01:57:07] <pcwalton> that too
[01:57:30] <pnkfelix> dbaupp: though in practice I think it wouldn't be too bad to figure out a standard inline barrier that all GC's share and let them differ on out-of-line details.
[01:57:34] <pcwalton> I got a proof of concept "function context" and "block context" to work that uses the new arena
[01:57:41] <pcwalton> with lifetimes and no unsafe code
[01:57:44] <pcwalton> time to try converting trans
[01:57:57] <pcwalton> should cut down on most of the malloc during trans
[01:58:02] <pcwalton> and refcount traffic
[01:58:14] <dbaupp> pnkfelix: i.e. have a write_barrier method on GcAllocator that passes enough information for most GC's to work?
[01:58:24] <pcwalton> also as a nice bonus it statically prevents you from mixing up two functions' basic blocks
[01:58:52] <pnkfelix> dbaupp: yeah, but in practice you will need to still have some inline code that (hopefully) filters out the majority of the out-of-line calls
[01:59:03] <jack> do we have a semaphore or something?
[01:59:24] <jack> Ports can be cloned, but i need some way to signal that can be
[01:59:33] <pcwalton> jack: there are some in extra
[01:59:37] <pcwalton> extra::sync
[01:59:38] <jack> s/Ports can/Ports can't/
[01:59:38] <pnkfelix> dbaupp: Assuming we don't need Generational but do need Incremental, you'd want an inline fast-path to e.g. check if there is a Gc currently ongoing
[01:59:41] <pcwalton> back in a bit
[02:00:02] <dbaupp> pnkfelix: ah, yes.
[02:00:03] *** Quits: pcwalton (pcwalton@moz-C07D5168.p2p.sfo1.mozilla.com) (Quit: pcwalton)
[02:00:28] <dbaupp> pnkfelix: maybe single inheritance would allow us to have a struct GcBase { gc_in_progress: bool } or something
[02:00:41] <dbaupp> pnkfelix: and so it's a static look up to check that
[02:01:13] <pnkfelix> dbaupp: yeah maybe.  Or maybe don't even worry about it; I'm not yet convinced we'll even want to worry about incremental gc for 1.0
[02:01:53] <dbaupp> pnkfelix: just go with stop-the-thread full collection?
[02:01:56] <cmr> I'm not particularly convinced that Rust will even benefit that much from a state-of-the-art gc, considering how (relatively) infrequently it's going to be used.
[02:01:58] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[02:01:58] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/iwtSuA
[02:01:58] <ghrust> 13rust/06auto 1479def2c 15Brian Anderson: More 0.9 release notes
[02:01:58] <ghrust> 13rust/06auto 14f28aa66 15Brian Anderson: Update AUTHORS.txt
[02:01:58] <ghrust> 13rust/06auto 14738dc27 15bors: auto merge of #11356 : brson/rust/0.9relnotes, r=alexcrichton
[02:02:00] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[02:02:21] <dbaupp> cmr: with pointer traits and a state-of-the-art gc it might get used more than it currently does
[02:02:37] <dbaupp> cmr: (since we would no longer need to absolutely discourage its use.)
[02:02:38] <pnkfelix> dbaupp: Yes.  (but on the flip side, if we do emit an inline fast-path, ideally it would be something that also could be generalized to gen.gc.  E.g. something that extracted header bits from the objects involved in the write.)
[02:03:21] <pnkfelix> dbaupp: But its hard to predict how much generalization is worth trying to throw in, especially at this early junction.  Better to leave that for Rust 2.0)
[02:03:45] <cmr> dbaupp: sure, but what high perf code is going to be relying on the gc, when we have such wonderful alternatives available?
[02:03:48] <cmr> yeah what pnkfelix said
[02:04:07] <dbaupp> cmr: some code gets faster with a GC
[02:04:14] <pnkfelix> dbaupp: and in terms of raw throughput, its hard to compete with a well-tuned stop-the-thread local gc.
[02:04:55] <pnkfelix> (when comparing against gen.gc or incr.gc)
[02:05:05] <dbaupp> ok
[02:06:02] <dbaupp> I'll try to experiment with something... it'll probably turn out horribly. :)
[02:06:46] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[02:06:46] <ghrust> 01[13rust01] 15brson merged 06master into 06dist-snap: 02http://git.io/V5VQew
[02:06:46] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[02:15:58] *** Quits: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Quit: lkuper)
[02:33:46] <cmr> acrichto: I'm beginning to think that File::open/create should take a string rather than a path, if only for the fact that they're supposed to be the convencience methods; open_mode can take the Path
[02:34:12] <cmr> it's really obnoxious to have example code with File::open(&Path::new("foo.txt"))
[02:34:27] <cmr> I personally don't mind it, but it looks bad
[02:34:33] <cmr> and bstrie complains to no end about it ;p
[02:36:48] <acrichto> cmr: I've kinda come to think that as well
[02:37:06] <acrichto> it's a bit tough b/c I think it should continue to take &Path
[02:37:16] <acrichto> but that just means it should take ToPath, yet another trait
[02:37:22] <bstrie> my opinion is that the Path type is valuable for path manipulation, but we don't need that for just opening a file
[02:37:46] <bstrie> the failure mode of "path is not valid" is the same either way
[02:38:16] <bstrie> and yes I would like open to take both paths and strings, if feasible
[02:38:32] <acrichto> well I suppose the trait is ToCStr
[02:38:42] <acrichto> so it wouldn't be adding another one
[02:38:59] <acrichto> but this is setting a precedent for all other I/O constructors
[02:39:08] <acrichto> e.g. TcpStream and TcpListener
[02:39:16] <acrichto> which *sorely* need a string constructor
[02:40:28] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[02:40:28] *** ChanServ sets mode: +ao dherman dherman
[02:40:49] <dbaupp> acrichto: https://github.com/mozilla/rust/pull/11360 r?
[02:41:24] <cmr> That PR really sits uncomfortably with me.
[02:41:41] <acrichto> how so?
[02:41:56] <cmr> because it can be wrong and thus unsafe
[02:42:10] <cmr> there's not really a better way to do it though
[02:42:13] <acrichto> well there's not really an alternative
[02:42:16] <acrichto> right now you just overflow
[02:42:17] <cmr> main thread is already unsafe, whether we know th e bounds or not
[02:42:23] <acrichto> (the main thread has no bounds)
[02:42:25] <cmr> I just don't like it
[02:42:36] <acrichto> yeah I've looked a bunch and I can't find a way to figure it out
[02:42:40] <acrichto> the stack size that is
[02:42:55] <acrichto> man I wish we could write a kernel for all rust to run under
[02:42:59] <acrichto> it would make things *a lot* easier
[02:43:43] <dbaupp> "man I wish we could write a kernel for all rust to run under" linux isn't that big, right?
[02:43:51] <cmr> nah
[02:43:54] <cmr> could rewrite it in a few hours
[02:44:05] <acrichto> "the kernel isn't full yet"
[02:44:18] <acrichto> the linux kernel has a lot of things in it lol
[02:46:36] <brson> we could continue to default to being off the main thread for native::start and force apps to opt in
[02:48:15] <acrichto> hm, so #[boot] has off the main thread and native::start puts you on the main thread
[02:48:38] <brson> that's surprising
[02:48:42] <brson> i would expect start to use boot
[02:49:18] <acrichto> our startup sequence :(
[02:49:29] <acrichto> btw pcwalton suggested we remove lang="start"
[02:49:44] <acrichto> "main" => boot => "rust main"
[02:50:13] <brson> so have the boot function outside of standard and make it responsible for init/cleanup?
[02:50:29] <acrichto> yeah
[02:50:32] <brson> wouldn't that just be 'start'?
[02:50:47] <acrichto> well my proposal is:
[02:50:51] <acrichto> "main" => start => boot => "rust main"
[02:51:06] <acrichto> we'd just be combining {start => boot}
[02:51:19] <acrichto> everything would be wrapped in rt::init()/rt::cleanup()
[02:51:20] <brson> removing lang = "start" doesn't reduce any complexity. lang start is the one that nobody needs to know about
[02:51:37] <acrichto> that's what I thought, he also didn't have super strong opinions
[02:51:43] <acrichto> just that it kinda is spaghetti
[02:52:03] <brson> I would rather remove #[start]
[02:52:23] <brson> you can duplicate start by just defining whatever the platform specific main function is yourself
[02:52:44] <acrichto> #[no_main]; #[no_mangle] fn main() {}
[02:52:45] <acrichto> like that?
[02:52:47] <brson> yes
[02:53:00] <brson> well main(argv, argv) -> c_int
[02:53:06] <acrichto> ah yeha
[02:53:08] <acrichto> hmm
[02:53:09] <brson> on unix at least
[02:53:11] <brson> different on windows
[02:53:28] <acrichto> the main usage of #[start] today is gui apps, right
[02:53:29] <acrichto> ?
[02:53:48] <brson> gui's and sprocketnes
[02:53:56] <brson> but sprocketnes would probably be happy with libnative
[02:54:22] <brson> well, maybe. pcwalton may like not using the runtime just for the his own reasons
[02:54:31] <acrichto> well sprocketnes doesn't use main at all
[02:54:37] <acrichto> b/c sdl provides a main function
[02:54:37] <brson> oh right
[02:54:41] <brson> it does #[no_main]
[02:54:51] <acrichto> but if we removed #[start] all GUI apps would have to have windows-specific logic
[02:55:02] <cmr> AFAICT the *only* library that requires running on the main thread is cocoa
[02:55:03] <brson> no, they would boot into libnative on the main thread
[02:55:03] <acrichto> b/c libnative doesn't boot you on the main thread
[02:55:04] <cmr> everything else is fine
[02:55:07] <brson> acrichto: right
[02:55:09] <cmr> thread unsafe, but doesn't require main thread.
[02:55:23] <cmr> (GUI library that is)
[02:55:33] <acrichto> hmm... so by default you wouldn't be on the main thread with libnatie
[02:55:36] <acrichto> but you could opt into it?
[02:55:38] <brson> cmr: are you sure about win32?
[02:55:43] <brson> i've never heard that
[02:55:46] <cmr> brson: according to klutzy yes.
[02:55:51] <bjz> Damn Cocoa :P
[02:56:00] <cmr> something like only the thread that creates the window can update it
[02:57:27] <brson> maybe we can create a way to override boot that does start on the main thread
[02:57:40] <brson> can libnative define two boots?
[02:57:52] <acrichto> so many boots
[02:57:55] <acrichto> three-legged rust
[02:58:01] <cmr> bwahahah
[02:58:04] <brson> then we can say guis should write `#[boot(main_thread)] extern crate native;`
[02:58:28] <acrichto> what would #[boot(main_thread)] extern create green; do?
[02:58:46] <brson> maybe boot = "main_thread", then looks up the 'main_thread' function
[02:59:26] <acrichto> I still am not a huge fan of #[no_boot] + #[boot] extern crate
[02:59:37] <acrichto> but it's orthogonal
[02:59:40] <acrichto> in theory we could do that
[02:59:48] <acrichto> you would annotate each boot-function
[02:59:57] <brson> maybe the ideal would be to default boot to libnative, on the main thread, and force green threaders to spawn a task pool
[03:00:00] <acrichto> #[boot(main_thread)] fn boot_main_thread() {}
[03:00:00] <brson> then there's no boot
[03:00:02] <brson> or start
[03:00:30] <acrichto> so libnative provides '#[no_mangle] fn main() {}' ?
[03:00:48] *** Quits: blank_name (blank_name@78B04CD2.66204B68.6D228269.IP) (Ping timeout)
[03:00:51] <brson> i was thinking there would still be a lang start
[03:01:02] <brson> probably don't want to override main in a library
[03:01:17] <acrichto> hmm
[03:01:36] <acrichto> libgreen would probably want a convenience "boot a pool" function in that case
[03:01:45] <acrichto> b/c we don't want to make socket server bootup terrible
[03:02:09] <acrichto> ugh rustpkg tests
[03:02:14] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[03:02:14] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14738dc27 to 14b6602cb: 02http://git.io/N3iJvQ
[03:02:14] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[03:02:18] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[03:02:18] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/0fwJdg
[03:02:18] <ghrust> 13rust/06auto 1403e9157 15Alex Crichton: Don't read forever on a file descriptor...
[03:02:18] <ghrust> 13rust/06auto 146e31d82 15Alex Crichton: Fix parallel makefile builds...
[03:02:19] <ghrust> 13rust/06auto 14417a304 15bors: auto merge of #11355 : alexcrichton/rust/read-waits-forever, r=brson...
[03:02:21] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[03:07:25] *** Quits: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[03:07:38] <larsberg> brson, cmr: on Windows, you can definitely create windows on a separate thread and then only a subset of the API is safe for usage across threads
[03:08:01] <larsberg> but I'm not certain you can get away without calling GetMessage/TranslateMessage/PostMessage on the main thread without getting an hourglass or screwing up async i/o, etc.
[03:09:08] <Eridius> I'm having some bizarre lifetime/borrowck issues, if anyone has any insight: https://github.com/mozilla/rust/issues/11361
[03:09:16] <larsberg> there are (or at least used to be ~10 years a go) a lot of services that make some really bad assumptions about synchonizing through the main thread's message queue (e.g., using an invisible window). 
[03:09:32] <larsberg> might work in a post-XP world, but I'd test it a bit before banking on it
[03:09:57] <cmr> larsberg: well the idea is that you still only have one thread touching the window, but that it's not the main thread.
[03:10:17] <larsberg> cmr: that's fine
[03:10:23] <cmr> that's what I thought
[03:10:40] <larsberg> but the question is: what else breaks if the *real* main thread isn't pumping messages? that I don't know
[03:10:58] <cmr> ah
[03:11:08] <larsberg> maybe libuv doesn't use any of the built-in async/overlapped I/O stuff and it's safe
[03:11:27] <cmr> well if it's not universally safe then that's no good at all
[03:11:39] <cmr> what is it with these libs and their weird on-main-thread requirement :(
[03:11:41] <larsberg> I don't know enough about it to be sure, but some of that stuff used to deliver I/O completion messages to a hidden window and you had to pump messages in the "right" way to get them delivered
[03:12:15] <larsberg> there was also hackery in the OS that would cause it to think the app was frozen if you didn't call GetMessage (or PeekMessage) from the main thread every so often and you'd get the hourglass or "Frozen App" dialog
[03:12:25] <larsberg> it may have changed - my knowledge is a bit dated
[03:12:33] <larsberg> but it certainly wasn't safe circa 2002
[03:14:11] <cmr> merry 2014 ;P
[03:15:50] <larsberg> hey, it's Microsoft. I ran into back-compat hackery even then in Windows to keep code from the late 80s working (in this case, it was like WinZip 3 with some bad stuff they did in Win3.11... still there and tested for in Vista)
[03:17:23] <brson> acrichto: does rustdoc's test extractor understand should_fail tests?
[03:17:47] <acrichto> brson: it should
[03:18:02] <acrichto> although technically compilation could fail and the test would succeed
[03:18:07] <acrichto> which is probably bad now that I think about it...
[03:18:09] <cmr> brson: ```rust,should_fail
[03:18:15] <cmr> should work
[03:18:58] *** Joins: pcwalton (pcwalton@moz-DA87EE4.hsd1.ca.comcast.net)
[03:18:58] *** ChanServ sets mode: +ao pcwalton pcwalton
[03:19:39] *** Quits: a_m0d|home (a_m0d@moz-322A4DE4.acanac.net) (Quit: Leaving.)
[03:21:31] <brson> is 'ignore' better than 'xfail' for marking broken tests?
[03:21:40] <brson> i should have asked that in #rust i guess
[03:28:25] *** Joins: tjc (tjc@F3CCDC5.685D2433.3ADED9A0.IP)
[03:28:25] *** ChanServ sets mode: +o tjc
[03:30:24] *** Quits: tjc (tjc@F3CCDC5.685D2433.3ADED9A0.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[03:33:44] *** Quits: zz_kimundi (kimundi@moz-9DB60884.dip0.t-ipconnect.de) (Ping timeout)
[03:35:59] <cmr> acrichto: oh, I was also thinking that the file convenience constructors should return a BufferedStream
[03:36:25] <acrichto> that I would be much more opposed to
[03:36:52] <cmr> "how do I read a line" has a grossly long answer
[03:37:02] *** Joins: zz_kimundi (kimundi@moz-32142F5A.dip0.t-ipconnect.de)
[03:37:04] *** zz_kimundi is now known as kimundi
[03:37:05] <acrichto> hmm...
[03:39:19] <brson> r? https://github.com/mozilla/rust/pull/11364
[03:41:06] <acrichto> zomg we have a index page!
[03:41:09] <acrichto> http://static.rust-lang.org/doc/master/index.html
[03:41:19] * acrichto learned something new today
[03:41:43] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[03:41:43] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14417a304 to 14b6602cb: 02http://git.io/N3iJvQ
[03:41:43] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[03:42:31] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[03:42:31] <ghrust> 01[13rust01] 15alexcrichton 04force-pushed 06try from 14c274a68 to 14921ec1f: 02http://git.io/k471pw
[03:42:31] <ghrust> 13rust/06try 1439c59d5 15Alex Crichton: Fix leaking trait imports across modules...
[03:42:31] <ghrust> 13rust/06try 14e87682c 15Alex Crichton: rustc: De-indent portions of middle::resolve...
[03:42:32] <ghrust> 13rust/06try 14934a6d9 15Alex Crichton: std: Fill in all missing imports...
[03:42:34] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[03:43:21] <cmr> brson: https://github.com/mozilla/rust/wiki/Doc-detailed-release-notes#changes-to-closures
[03:43:23] <cmr> sorry that took so long
[03:43:32] <cmr> I got sidetracked down a dozen different, diverging paths
[03:43:50] <acrichto> cmr: btw you don't need unwrap()
[03:44:08] <acrichto> also spawn is in the prelude
[03:44:09] <cmr> acrichto: oh hey that's cool
[03:44:31] <cmr> I didn't have it buffered before
[03:44:34] <brson> cmr: thank you!
[03:44:40] <acrichto> man looking at some of http://static.rust-lang.org/doc/master/complement-cheatsheet.html I think some of those could be updaed...
[03:45:05] <cmr> they've been written in the past two weeks!
[03:45:26] <acrichto> brson: it may be time in the docs to have a 'define HTML_GUIDE'
[03:45:38] <acrichto> I have a feeling the same blob is copy/pasted many times
[03:46:02] <dbaupp> http://static.rust-lang.org/doc/master/complement-cheatsheet.html#c-function-signature-conversions :(
[03:46:02] <brson> acrichto: what does 'define HTML_GUIDE' mean?
[03:46:14] <acrichto> brson: just a makefile macro
[03:46:16] <cmr> oh that poor table
[03:46:36] <acrichto> are pandoc tables different?
[03:46:42] <acrichto> or maybe they need a flag
[03:47:03] <cmr> also the syntax highlighting is gone
[03:47:06] <acrichto> http://stackoverflow.com/questions/4546547/how-do-i-specify-tables-in-my-markdown-document-using-pandoc-syntax
[03:47:12] <brson> yeah pandoc tables are probably different
[03:47:14] <cmr> is the doc builders' pygmentize too old?
[03:48:03] <brson> no, the tutorial is highlighted
[03:48:17] *** Joins: jdm_ (jdm@moz-AC9499B2.cable.teksavvy.com)
[03:48:52] <acrichto> brson: I don't think these tests are running
[03:48:54] <acrichto> for docs
[03:49:00] <acrichto> or at least not the cheatsheet
[03:49:06] <acrichto> should they be?
[03:49:19] <brson> i don't think they're wired up yet
[03:49:43] <acrichto> mk
[03:51:18] <brson> i'll try to fix the table and the syntax highlighting and address dbaupp's comments about the pointer guide tonight
[03:51:54] <dbaupp> if that PR lands, I'm happy to address my comments myself.
[03:52:33] <dbaupp> pnkfelix: ping
[03:52:44] <pnkfelix> dbaupp: pong
[03:52:46] <brson> dbaupp: ok, you're on it
[03:54:33] <dbaupp> pnkfelix: I've been thinking about write barriers and so on, and I realised that we don't actually know when we are writing to a Gc pointer, since Gc<RefCell<...>> is the only way to get inner mutability, and .borrow()-ing the RefCell out allows one to pass it around arbitrarily, completely disassociated with the Gc it came from.
[03:54:42] <dbaupp> pnkfelix: (and not every .borrow() corresponds to a write)
[03:55:09] <pnkfelix> dbaupp: oh yes, we need to emulate the write-barriers conservatively in response to borrows
[03:55:14] <dbaupp> pnkfelix: (I'm extremely experienced with GCs, so I might be completely misundestanding something)
[03:55:28] <dbaupp> so every Gc.borrow() requires a write barrier?
[03:55:46] <pnkfelix> dbaupp: do we have distinguished mut_borrow() vs borrow() ?
[03:55:59] <dbaupp> not at the moment
[03:56:18] <dbaupp> since the mutability is via teh RefCell stored in the Gc
[03:56:25] <dbaupp> not from the Gc<> type itself
[03:56:28] <aatch> dbaupp, you mean "inexperienced"?
[03:56:34] <dbaupp> aatch: yes
[03:56:43] * dbaupp is also inexperienced at making sense, apparently
[03:57:13] <dbaupp> pnkfelix: maybe we do need a true GcMut type after all?
[03:57:18] <pnkfelix> dbaupp: well we'll need to do something.  Niko and I were talking through this some time ago but I've now forgotten the details.
[03:58:26] <pnkfelix> dbaupp: I assume the reason we don't want a GcMut type is because ... its hopefully a simpler mental model to compose separate types?
[03:59:26] <cmr> was I doing anything for anyone?
[03:59:29] <dbaupp> pnkfelix: that's my understanding, yes
[04:00:55] <pnkfelix> dbaupp: we probably do not want every Gc.borrow() to require a write-barrer, but I am not yet sure by what means we will avoid that.
[04:02:00] <dbaupp> We could have .borrow() -> &T on Gc<T> for T: Freeze, and .borrow_with_write_barrier() for Gc<T> for arbitrary T.
[04:02:25] <dbaupp> but that seems ugly, to say the least.
[04:04:24] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Quit: leaving)
[04:04:27] <dbaupp> pnkfelix: and maybe an unsafe `.borrow_no_write_barrier()` for arbitrary T too, for when the user is definitely handling it read-only.
[04:09:52] *** Quits: jdm_ (jdm@moz-AC9499B2.cable.teksavvy.com) (Quit: Lost terminal)
[04:10:09] *** Quits: jdm (jdm@moz-DB4A9C19.scl3.mozilla.com) (Quit: leaving)
[04:11:29] <pnkfelix> dbaupp: yeah maybe.  Can't hurt to see how that looks.
[04:14:57] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[04:29:29] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[04:29:29] <ghrust> 01[13rust01] 15alexcrichton 04force-pushed 06try from 14921ec1f to 14426f770: 02http://git.io/k471pw
[04:29:29] <ghrust> 13rust/06try 14426f770 15Alex Crichton: Fix remaining cases of leaking imports
[04:29:29] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[04:32:33] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Connection reset by peer)
[04:33:04] <acrichto> hm, so implicit casting of a trait immediately drops the value
[04:34:12] <dbaupp> acrichto: https://github.com/mozilla/rust/issues/11197
[04:34:15] <dbaupp> oh
[04:34:17] <dbaupp> you opened it
[04:34:22] <acrichto> hehe
[04:34:48] <sfackler> dbaupp: I'm leaning towards making a GcMut type that internally wraps a RefCell
[04:35:04] <sfackler> since the current way of foo.borrow().borrow().get() is insane
[04:35:25] <acrichto> wouldn't that become foo.borrow() with a deref trait?
[04:35:33] <dbaupp> or foo.get()
[04:35:36] <sfackler> maybe?
[04:35:42] <acrichto> Gc<T> -> &RefCell implicit
[04:35:45] <sfackler> I think the RefCell borrow at least should be explicit
[04:35:47] <sfackler> since it can fail
[04:35:49] <acrichto> &RefCell -> &RefCellThing explicit
[04:35:52] <sfackler> but I dont' know if others agree
[04:35:54] <acrichto> &RefCellExplicit -> T implicit
[04:36:05] <dbaupp> ah, yeah, that's what I meant
[04:36:08] <acrichto> ref cell should definitely be explicit
[04:36:14] * dbaupp got .get and .borrow in the wrong order
[04:36:15] <pcwalton> down to 19 errors with shoving Blocks into an arena
[04:36:17] <acrichto> but everything else should be implicit
[04:36:21] <sfackler> yeah
[04:36:23] * pcwalton crosses fingers
[04:36:23] <acrichto> pcwalton: nice!
[04:36:28] <pcwalton> this is the most lifetime-y code ever
[04:36:34] <pcwalton> and shows that holy crap rust is expressive
[04:36:38] <dbaupp> that's half the reason that we have RefCell isn't it? (explicit borrows/no implicit failures)
[04:37:02] <acrichto> pcwalton: do you know off the top of your head how to cancel a cleanup in trans?
[04:37:02] <sfackler> acrichto: is the external macro PR on the meeting agenda? it's basically ready to go except for the build system issues and maybe some namespacing
[04:37:07] <pcwalton> acrichto: revoke_clean
[04:37:08] <sfackler> but I'm not sure if namespacing is a blocker
[04:37:25] <acrichto> sfackler: ah yes I shall place it on, we sadly have a full agenda though so may not get around to it
[04:37:28] <acrichto> pcwalton: thanks
[04:37:31] <sfackler> np
[04:41:47] *** Quits: dcrewi (david@moz-AB8667CE.gyrae.net) (Ping timeout)
[04:41:57] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[04:41:57] <ghrust> 01[13rust01] 15alexcrichton 04force-pushed 06try from 14426f770 to 14098ac69: 02http://git.io/k471pw
[04:41:57] <ghrust> 13rust/06try 14098ac69 15Alex Crichton: Fix remaining cases of leaking imports
[04:41:57] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[04:42:22] *** Joins: vfetwnuncszu (david@moz-AB8667CE.gyrae.net)
[04:42:22] *** vfetwnuncszu is now known as dcrewi
[04:45:18] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[04:51:43] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[04:51:44] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/yFW-ZQ
[04:51:44] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[04:56:41] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[04:56:41] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/QXke7A
[04:56:41] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[04:56:43] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[04:56:43] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/KIesfg
[04:56:43] <ghrust> 13rust/06auto 1403e9157 15Alex Crichton: Don't read forever on a file descriptor...
[04:56:43] <ghrust> 13rust/06auto 143639a2c 15Alex Crichton: Fix parallel makefile builds...
[04:56:44] <ghrust> 13rust/06auto 148e4c248 15bors: auto merge of #11355 : alexcrichton/rust/read-waits-forever, r=brson...
[04:56:46] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[04:58:35] *** Quits: ChristopherBurg (Christophe@moz-2C03E71B.hfc.comcastbusiness.net) (Quit: NO CARRIER)
[05:00:19] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[05:00:19] <ghrust> 01[13rust01] 15alexcrichton 04force-pushed 06try from 14098ac69 to 14ac38494: 02http://git.io/k471pw
[05:00:19] <ghrust> 13rust/06try 14ac38494 15Alex Crichton: Fix remaining cases of leaking imports
[05:00:19] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[05:00:29] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[05:05:08] *** Quits: pnkfelix (pnkfelix@moz-DFAA4E15.p2p.sfo1.mozilla.com) (Input/output error)
[05:16:35] *** Quits: canhtak (canhtak@moz-DB18D73D.wl.t.ulaval.ca) (Quit: canhtak)
[05:20:05] <pcwalton> got it compiling
[05:20:11] <pcwalton> it's segfaulting though. I suspect a bug in the arena.
[05:34:37] *** Joins: eddyb (eddy@EE946B63.921A1753.FCAAE698.IP)
[05:42:38] <dbaupp> hm, getting GC rooting working with ~ and ~[] will be really annoying.
[05:43:02] <dbaupp> It would be much easier if they were library types.
[05:51:39] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[05:51:39] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 148e4c248 to 145efac2b: 02http://git.io/N3iJvQ
[05:51:39] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[05:51:40] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[05:51:40] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/wAr2UA
[05:51:40] <ghrust> 13rust/06auto 14d3833c3 15Brian Anderson: extra: Remove condition from semver
[05:51:40] <ghrust> 13rust/06auto 1407950e7 15bors: auto merge of #11296 : brson/rust/anti-cond, r=alexcrichton...
[05:51:41] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[06:00:27] *** Quits: vadimcn (chatzilla@FB06B64.76F9E272.DA40C4B3.IP) (Connection reset by peer)
[06:01:08] *** Joins: vadimcn (chatzilla@FB06B64.76F9E272.DA40C4B3.IP)
[06:22:08] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[06:22:08] *** ChanServ sets mode: +ao dherman dherman
[06:22:09] *** Quits: dcrewi (david@moz-AB8667CE.gyrae.net) (Ping timeout)
[06:22:56] *** Quits: pcwalton (pcwalton@moz-DA87EE4.hsd1.ca.comcast.net) (Quit: pcwalton)
[06:28:11] *** Joins: vfetwnuncszu (david@moz-AB8667CE.gyrae.net)
[06:28:26] *** vfetwnuncszu is now known as dcrewi
[06:34:06] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[06:34:06] <ghrust> 01[13rust01] 15alexcrichton 04force-pushed 06try from 14ac38494 to 14bbd4d8e: 02http://git.io/k471pw
[06:34:06] <ghrust> 13rust/06try 1451e9b32 15Alex Crichton: Fix remaining cases of leaking imports
[06:34:06] <ghrust> 13rust/06try 14d421a54 15Alex Crichton: stdtest: Fix all leaked trait imports
[06:34:07] <ghrust> 13rust/06try 14bbd4d8e 15Alex Crichton: extratest: Fix all leaked trait imports
[06:34:09] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[06:44:55] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[06:44:56] <ghrust> 01[13rust01] 15alexcrichton 04force-pushed 06try from 14bbd4d8e to 1498c95e4: 02http://git.io/k471pw
[06:44:56] <ghrust> 13rust/06try 1498c95e4 15Alex Crichton: extratest: Fix all leaked trait imports
[06:44:56] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[06:50:40] *** Quits: dcrewi (david@moz-AB8667CE.gyrae.net) (Ping timeout)
[06:50:42] *** Joins: tjc (tjc@moz-6EB4E533.dsl.tsoft.com)
[06:50:42] *** ChanServ sets mode: +o tjc
[06:53:54] *** Joins: vfetwnuncszu (david@moz-AB8667CE.gyrae.net)
[06:54:05] *** vfetwnuncszu is now known as dcrewi
[07:14:56] *** Quits: tjc (tjc@moz-6EB4E533.dsl.tsoft.com) (Quit: Textual IRC Client: www.textualapp.com)
[07:29:50] *** Quits: jld (jld@moz-B94C75AD.xlerb.net) (Ping timeout)
[07:31:56] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[07:31:56] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/wAr2UA
[07:31:56] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[07:36:46] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[07:36:46] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/c7r5OQ
[07:36:46] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[07:36:47] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[07:36:47] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/NKHEpg
[07:36:47] <ghrust> 13rust/06auto 1403e9157 15Alex Crichton: Don't read forever on a file descriptor...
[07:36:47] <ghrust> 13rust/06auto 1489f8bc2 15Alex Crichton: Fix parallel makefile builds...
[07:36:47] <ghrust> 13rust/06auto 14777f1e8 15bors: auto merge of #11355 : alexcrichton/rust/read-waits-forever, r=brson...
[07:36:49] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[07:38:17] *** Joins: jld (jld@moz-B94C75AD.xlerb.net)
[07:59:10] <Eridius> what the hell? TcpStream.eof() is implemented as fail!()
[08:00:38] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[08:29:17] *** flaper87|afk is now known as flaper87
[08:40:56] *** Quits: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP) (Ping timeout)
[08:46:44] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[08:46:44] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/NKHEpg
[08:46:44] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[08:49:59] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[08:51:42] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[08:51:42] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/PMJ3Jw
[08:51:42] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[08:51:42] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[08:51:42] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/tmAAig
[08:51:43] <ghrust> 13rust/06auto 1420ccfde 15Nif Ward: Added in Clone/TotalEq/TotalOrd/ToStr traits to all parts of btree....
[08:51:43] <ghrust> 13rust/06auto 146b17fa3 15bors: auto merge of #11263 : niftynif/rust/btree, r=catamorphism...
[08:51:43] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[08:58:37] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[08:58:37] <ghrust> 01[13rust01] 15alexcrichton pushed 1 new commit to 06try: 02http://git.io/vdVG6Q
[08:58:37] <ghrust> 13rust/06try 140f7f896 15Alex Crichton: Fixup the rest of the tests in the compiler
[08:58:37] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[09:37:30] <eddyb> this is amusing: ast::purity is all about impurity
[09:37:43] <eddyb> I guess rust had pure functions at one point
[09:38:02] <dbaupp> yes
[09:38:58] <dbaupp> eddyb: (background for the removal, if you're interested: http://thread.gmane.org/gmane.comp.lang.rust.devel/3674/focus=3855 )
[09:40:19] <eddyb> dbaupp: I remember reading that
[09:51:43] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[09:51:43] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 146b17fa3 to 14777f1e8: 02http://git.io/N3iJvQ
[09:51:43] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[10:24:34] *** Quits: jld (jld@moz-B94C75AD.xlerb.net) (Ping timeout)
[10:24:53] *** Quits: Eridius (kevin@moz-533B0DB4.us) (Ping timeout)
[10:28:13] *** Joins: Eridius (kevin@moz-533B0DB4.us)
[10:33:14] *** Joins: jld (jld@moz-B94C75AD.xlerb.net)
[10:40:05] *** Joins: canhtak (canhtak@moz-DB18D73D.wl.t.ulaval.ca)
[11:01:53] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[11:01:53] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/gkRrcQ
[11:01:53] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[11:06:51] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[11:06:51] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/ie8lzw
[11:06:51] <ghrust> 13rust/06auto 14a98eb50 15Jan Niklas Hasse: Use target libraries instead of host libraries. Fixes #11243
[11:06:51] <ghrust> 13rust/06auto 14ab6d631 15bors: auto merge of #11338 : jhasse/rust/patch-rustpkgtarget, r=alexcrichton
[11:06:51] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[11:07:23] *** Quits: canhtak (canhtak@moz-DB18D73D.wl.t.ulaval.ca) (Quit: canhtak)
[11:52:22] *** Joins: Jesse (jruderman@moz-9754CB0.hsd1.ca.comcast.net)
[11:53:23] <eddyb> this might be useful for my adventures in trans http://llvm.lyngvig.org/Articles/Mapping-High-Level-Constructs-to-LLVM-IR
[11:54:23] <dbaupp> eddyb: you're assuming trans is sane :P
[11:57:41] <eddyb> wait, what, LLVM args can be named? and we're not using that? pffft
[11:58:21] <eddyb> dbaupp: no, I'm not, but I'm learning how to sanitize it
[11:58:52] <dbaupp> that's no fun :P
[11:59:03] <dbaupp> is the self patch still crashing?
[11:59:45] <eddyb> dbaupp: I can make it bootstrap, but I don't want to get it in with the old argument allocation behavior
[12:00:01] *** Joins: a_m0d|home (a_m0d@moz-322A4DE4.acanac.net)
[12:00:04] <eddyb> nmatsakis needs to review it anyway, better do it after his cleanup fixes
[12:01:07] <eddyb> also, I understand that the datalayout contains the mangling scheme - so can't LLVM do all that work for us?
[12:02:34] * dbaupp is dumb
[12:02:56] <dbaupp> I added a lint, but then forgot to call the function checking the lint in the lint visitor, and was wondering why the lint didn't trigger
[12:03:27] <dbaupp> eddyb: does clang use LLVM to mangle?
[12:03:41] <eddyb> not sure. I just read about that feature on the LLVM weekly
[12:03:50] <eddyb> oh, I know how to check
[12:05:37] <eddyb> declare %"class.std::basic_ostream"* @_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc(%"class.std::basic_ostream"*, i8*) #0
[12:06:27] <eddyb> dbaupp: so no. or at least not yet. it might be a recent change in LLVM git
[12:07:19] <eddyb> also, I think this explains why rust trans has "struct.Foo" and "enum.Bar"
[12:07:23] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[12:07:23] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14ab6d631 to 14bc395bc: 02http://git.io/N3iJvQ
[12:07:23] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[12:07:28] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[12:07:28] <ghrust> 01[13rust01] 15bors pushed 7 new commits to 06auto: 02http://git.io/s56imQ
[12:07:28] <ghrust> 13rust/06auto 148b03264 15Huon Wilson: std::trie: add an mutable-values iterator.
[12:07:28] <ghrust> 13rust/06auto 14ca1f104 15Huon Wilson: std::trie: remove some obsolete internal iterators.
[12:07:28] <ghrust> 13rust/06auto 1494790dd 15Huon Wilson: std::trie: use macros to share code between the iterator implementations.
[12:07:30] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[12:11:18] <dbaupp> bleh, 851 errors
[12:11:27] <dbaupp> maybe this lint isn't such a good idea.
[12:15:30] <eddyb> dbaupp: what kind of lint?
[12:16:34] <dbaupp> eddyb: I added a #[managed] annotation (for library defined GC pointers), and this is checking that no such things end up in ~, @, ~[] or @[], since there is no way to root them
[12:16:45] <dbaupp> (i.e. the GC will ignore those references and possibly deallocate the pointer.)
[12:17:09] <dbaupp> the problem is any generic type gets hit by it.
[12:17:18] <eddyb> that's not such a good idea
[12:17:26] <dbaupp> what isn't a good idea?
[12:17:54] <eddyb> just denying it
[12:18:09] <dbaupp> for safety, you mean?
[12:18:31] <eddyb> the proper solution would be to implement that automatically derived Traceable nmatsakis and pnkfelix were talking about
[12:18:53] <dbaupp> no, this is very different
[12:19:01] <dbaupp> well, not very different
[12:19:09] <dbaupp> but mildly different.
[12:20:06] <dbaupp> AIUI tracing is for "I'm scanning a value of this type, which words should I check", and rooting is "what chunks of memory should I look at"
[12:20:46] <dbaupp> if you have ~[T: Traceable], you need to know to look inside the vector to be able to trace those allocations.
[12:33:31] *** kimundi is now known as zz_kimundi
[12:34:45] <eddyb> dbaupp: oh, right, ~[T] with T: NeedsRooting would have to generate extra code for allocation and growable vector operations. ~T: NeedsRooting in general would call a hook on allocation
[12:37:46] <dbaupp> it'd be easy-as-pie if ~ and ~[] (etc) were defined in the libraries, rather than the compiler
[12:38:00] <eddyb> dbaupp: why?
[12:38:24] <dbaupp> well, not completely easy
[12:38:31] <eddyb> don't you need NeedsRooting (or whatever you may call the trait) to propagate through types?
[12:38:39] <dbaupp> but you won't have to get the compiler to emit the hooks
[12:38:41] <dbaupp> (which is hard)
[12:39:04] <dbaupp> (i.e. you need lang items or something to feed back into the compiler, which is complicated & less flexible)
[12:39:19] <dbaupp> eddyb: currently no
[12:39:43] <dbaupp> it's a `owns_managed::<T>()` intrinsic that checks if T contains anything with #[managed]
[12:39:55] <eddyb> is that implement already?
[12:40:00] <eddyb> *implemented
[12:40:07] <dbaupp> there is currently an owns_managed that checks for @
[12:40:13] <dbaupp> but I added one that checks for #[managed]
[12:40:37] <dbaupp> named owns_new_managed, having renamed the current owns_managed to owns_at_managed
[12:40:42] * dbaupp <- creative
[12:41:43] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[12:41:44] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14c22394d to 14bc395bc: 02http://git.io/N3iJvQ
[12:41:44] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[12:41:57] <eddyb> dbaupp: yeah, but how do you know what to do?
[12:42:07] <dbaupp> whaddya mean?
[12:42:13] <eddyb> wouldn't a trait lang item be the right thing to do?
[12:42:17] <dbaupp> how do I know what to do when something contains #[managed]?
[12:42:21] <dbaupp> maybe
[12:42:38] <dbaupp> but that gets rather annoying
[12:42:59] <eddyb> something that can be derived for types that don't implement it (but contain fields that implement it)
[12:43:00] <dbaupp> you'd need Uniq::new(...) Uniq::from_managed(...) and then anything generic using Uniq would need the same
[12:43:16] <eddyb> dbaupp: why?
[12:43:57] <dbaupp> because you can write `Uniq::new(T)` and do something different internally for `T: Managed` and `T: !Managed`.
[12:44:03] <dbaupp> *can't
[12:44:18] *** Quits: a_m0d|home (a_m0d@moz-322A4DE4.acanac.net) (Quit: Leaving.)
[12:44:48] <eddyb> dbaupp: you mean in completely library code?
[12:44:58] <dbaupp> yes
[12:45:27] <dbaupp> (we *need* library support for this, ~ and ~[] aren't the only possibly non-managed GC roots.)
[12:45:44] <dbaupp> e.g. Rc would need to root its values too.
[12:45:55] <eddyb> dbaupp: an intrinsic which does the right thing without requiring bounds?
[12:46:04] <dbaupp> "the right thing"
[12:46:14] <dbaupp> how does it know what the right thing is?
[12:46:25] <dbaupp> the GC won't be defined in the compiler
[12:46:42] <dbaupp> (having this intrinsic lets libraries do the right thing.)
[12:46:58] <eddyb> i.e. it calls either the user-implemented NeedsRooting trait or the derived version of it, if required
[12:48:23] <dbaupp> I have a feeling that can't work in general: how can it tell what the actual root is?
[12:48:57] <dbaupp> we could have an intrinsic `mark_gc_root::<T>(start_ptr, end_ptr)` or something, I guess.
[12:48:58] *** Parts: eddyb (eddy@EE946B63.921A1753.FCAAE698.IP) (Konversation terminated!)
[12:49:13] *** Joins: eddyb (eddy@EE946B63.921A1753.FCAAE698.IP)
[12:49:25] <eddyb> sorry, accidental part (no idea what I pressed)
[12:49:36] <dbaupp> it's not the greatest solution, since it requires putting a branch in every function that manipulates allocations with two
[12:49:39] <dbaupp> erm
[12:49:42] <dbaupp> wrong thign
[12:49:44] <eddyb> dbaupp: I'm going at this almost blind, do you have a better description of the rooting process?
[12:49:44] <dbaupp> https://botbot.me/mozilla/rust-internals/msg/9491334/
[12:50:11] <dbaupp> yeah, at it's most basic you tell the GC "there could be references to GC pointers in this memory region"
[12:50:13] <eddyb> the branch condition is a constexpr
[12:50:51] *** Joins: a_m0d|home (a_m0d@moz-322A4DE4.acanac.net)
[12:51:03] <dbaupp> (yes, the problem with the branch is having to make suer all that code is correct, having manually written all the branches; not the perf of the if true/if false branch.)
[12:51:10] <eddyb> oh, mark_gc_root sounds less precise than I was thinking
[12:51:45] <dbaupp> what were you thinking?
[12:52:16] <dbaupp> (I guess mark_gc_root::<T>(start_ptr, length) would be better)
[12:53:20] *** Quits: a_m0d|home (a_m0d@moz-322A4DE4.acanac.net) (Quit: Leaving.)
[12:53:52] <eddyb> dbaupp: I guess I was still thinking of Traceable, something touching each field, recursively. I don't know now :S
[12:54:35] <eddyb> btw, Rc would use Uniq to allocate, and in such a way that it does the right thing if Uniq does the right thing
[12:54:46] <dbaupp> eddyb: it still applies
[12:55:04] <dbaupp> you need to tell the GC that there are things to trace in some memory region
[12:55:15] <dbaupp> (hence the <T> parameter to mark_gc_root)
[13:00:24] <eddyb> dbaupp: so what do you do for ~~~[T]?
[13:01:06] <eddyb> dbaupp: wait, no, that would root just the innermost allocation
[13:02:54] <eddyb> this might be simpler than I thought, the intrinsic just calls the appropriate implementation for that range, deriving is just a pass-through
[13:03:57] <eddyb> dbaupp: so ~T has to be rooted, but it doesn't require rooting (if it's placed in a vector - ~[~T] - for example)
[13:06:17] <eddyb> s/has to be rooted/has to root its contents/
[13:13:11] *** zz_kimundi is now known as kimundi
[13:16:49] <dbaupp> yes, exactly
[13:20:14] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[13:51:37] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[13:51:37] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/zRHpfA
[13:51:37] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[13:56:37] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[13:56:38] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/WwSrAQ
[13:56:38] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[14:01:08] *** Joins: sigma (sigma@moz-BFB7A653.range86-143.btcentralplus.com)
[14:20:03] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Client exited)
[14:20:12] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[14:21:30] <eddyb> dbaupp: the three namespaces + shadowing makes for cool tricks and painful refactoring :S
[14:23:08] <dbaupp> eddyb: how so?
[14:24:22] <eddyb> dbaupp: try finding uses of the "item" enum
[14:25:34] <eddyb> de-globbed modules do give me an entry point
[14:31:37] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[14:31:37] *** ChanServ sets mode: +ao dherman dherman
[14:44:46] *** Quits: tedh (tedh@moz-F3B34318.hsd1.il.comcast.net) (Ping timeout)
[14:45:07] *** Joins: tedh (tedh@moz-F3B34318.hsd1.il.comcast.net)
[14:48:49] <eddyb> dbaupp: "de-snaking" sounds better than "rustifying", doesn't it?
[14:51:15] <dbaupp> eddyb: maybe
[15:00:09] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[15:06:43] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[15:06:43] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/upiuPg
[15:06:43] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[15:07:12] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[15:11:37] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[15:11:37] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/PPInnA
[15:11:37] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[15:11:39] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[15:11:39] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/49ccug
[15:11:39] <ghrust> 13rust/06auto 146b2a6cb 15Alex Crichton: Register new snapshots
[15:11:39] <ghrust> 13rust/06auto 14983f307 15bors: auto merge of #11348 : alexcrichton/rust/snapshots, r=brson
[15:11:39] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[15:21:08] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[15:25:59] *** kimundi is now known as zz_kimundi
[15:34:31] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[15:58:55] <eddyb> dbaupp: can't wait for #[deny(non-camel-case-types)]
[16:06:54] <eddyb> hmm, could we parallelize parts of the compile process? parsing, for example, can be done separately for each file - nevermind, the ident interner (it's worse when you enter middle)
[16:07:58] <eddyb> acrichto: libnative is missing #[allow(non-camel-case-types)] for C types
[16:08:25] <dbaupp> eddyb: #[allow(non_camel_case_types)] ;P
[16:08:41] <dbaupp> eddyb: and, yeah, we could parallelise parsing if we had a parallel hashmap
[16:08:53] <eddyb> dbaupp: for the interner? everything else is safe?
[16:09:07] <dbaupp> as far as i can remember
[16:09:27] <acrichto> eddyb: don't you mean it's missing the deny? they're allowed by default I think
[16:10:16] <eddyb> acrichto: std seemed to compile fine with RUSTFLAGS="-D non-camel-case-types"
[16:10:40] <acrichto> that's b/c it allows it explicitly in some cases
[16:10:43] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[16:10:43] *** ChanServ sets mode: +ao dherman dherman
[16:10:46] <acrichto> there's a deny directive at the top of libstd
[16:11:07] <acrichto> I think that in long ago rust it was not normal to have camelcase types and the lint mode was to assist porting over to camelcase types
[16:11:37] <eddyb> yeah, I mean, std::libc allows it, so should libnative where it uses C type names
[16:11:54] <acrichto> why? libnative isn't supposed to be compiled with -D non-camel-case-types
[16:12:09] <acrichto> if it should be compiled with that there should be an attribute in lib.rs
[16:14:29] <eddyb> acrichto: yeah, well, I'm going a bit purist on libsyntax so I found it weird that libnative's new code fails where std/extra/green/rustuv don't
[16:14:59] <eddyb> don't worry about it, I guess, if there's no explicit policy about it
[16:15:08] <acrichto> dunno, seems like just a stylistic thing to me that libnative doesn't want b/c it'll just need #[allow] everywhere
[16:18:02] *** Joins: gwty (gwtypc@D015B940.C0AE0958.71EA9E17.IP)
[16:21:44] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[16:21:44] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/49ccug
[16:21:44] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[16:21:50] <eddyb> dbaupp: just 193 to go :P
[16:22:09] <dbaupp> yum
[16:22:16] <dbaupp> \o/ a std build with a "proper" GC
[16:22:23] <dbaupp> let's see how badly this crashes...
[16:24:35] <dbaupp> yay, it doesn't entirely die
[16:25:04] <dbaupp> acrichto: hm, is it impossible to use RUST_LOG=... logging while the Task is borrowed (via Local::borrow)?
[16:26:05] <acrichto> dbaupp: yeah logging assumes a local task is available
[16:26:34] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[16:26:34] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/XxXzWQ
[16:26:34] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[16:26:35] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[16:26:35] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/zmsr8Q
[16:26:35] <ghrust> 13rust/06auto 145464d48 15Mick Koch: Fix formatting of some code blocks in pdf docs...
[16:26:35] <ghrust> 13rust/06auto 143912a87 15bors: auto merge of #11350 : kchmck/rust/fix-pdf-glitches, r=alexcrichton...
[16:26:36] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[16:26:43] <dbaupp> bleh :(
[16:27:19] <dbaupp> I'll work around this later I think...
[16:27:31] * dbaupp goes to bed; at 3.30am.
[16:34:32] *** Joins: Kxepal832 (Miranda@moz-CEB0DF31.pppoe.mtu-net.ru)
[16:34:52] *** Quits: Kxepal (Miranda@moz-30036DE2.pppoe.mtu-net.ru) (Ping timeout)
[16:34:57] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[16:34:57] <ghrust> 01[13rust01] 15alexcrichton merged 06master into 06snap-stage3: 02http://git.io/NZxnEQ
[16:34:57] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[16:44:54] <eddyb> aaaaah, that's what clownshoes are =))
[16:46:26] *** zz_kimundi is now known as kimundi
[16:49:52] <jack> acrichto: what's supposed to happen if you recv() on a port and then that port dies later?
[16:50:21] <jack> i think i've found an odd little race condition.
[16:50:51] <jack> The code sends a message A to a chan. then immediate sends message B which contains a port
[16:50:59] <jack> it then calls recv() on the port
[16:51:06] <jack> but in processing message A, the task dies
[16:51:21] <jack> and now the recv() is blocked forever
[16:51:22] <acrichto> jack: not following, code?
[16:51:45] <acrichto> what do you mean by a "port dying later"
[16:52:20] <jack> enum Message { A(uint), B(Port<()>) }
[16:52:56] *** flaper87 is now known as flaper87|afk
[16:52:58] <jack> chan.send(A(1)); let (rport, rchan) = Chan::new(); chan.send(B(rchan)); rport.recv()
[16:53:07] <jack> if the task dies processing A(1) then recv() hangs.
[16:53:22] <jack> is that intende?
[16:53:26] <jack> intended
[16:53:37] <acrichto> hm, so chan is still active so the internal queue hasn't been dropped yet
[16:54:02] <acrichto> what you want is that when a port dies all pending messages are destroyed
[16:54:11] <jack> when will the task's queues be dumped?
[16:54:22] *** Joins: pcwalton (pcwalton@moz-DA87EE4.hsd1.ca.comcast.net)
[16:54:22] *** ChanServ sets mode: +ao pcwalton pcwalton
[16:54:30] <acrichto> right now channels destroye pending messages when both halves are dropped
[16:55:13] <jack> how do i fix this? :)
[16:55:23] <acrichto> do you need to continue to use 'chan'?
[16:55:33] <jack> this is in a test, so the test is over
[16:55:41] <acrichto> if you can drop 'chan', drop it
[16:55:46] <jack> chan is never used again, but i don't know that the other end has faile.d
[16:55:48] <acrichto> drop it before rport.recv()
[16:55:56] <acrichto> send on it then drop it
[16:55:57] <jack> but it seems very weird to drop the chan before calling recv
[16:56:05] <acrichto> you're dropping the channel you sent on
[16:56:20] <jack> there might be a valid case where i want to keep it to send more stuff, but am waiting on a response
[16:56:22] <acrichto> that ensures that when the port dies on the ohter end from unwinding all messages in the channel are destroyed
[16:56:30] <acrichto> oh, so you do use it afterwards
[16:56:43] <jack> I don't here, but I can imagine a different case where I might.
[16:56:58] <jack> We use this pattern a lot in servo where we send one message and wait on the response immediately.
[16:57:16] *** Joins: pnkfelix (pnkfelix@moz-C07D5168.p2p.sfo1.mozilla.com)
[16:57:44] <acrichto> can the message A contain the port?
[16:57:57] <jack> The message A is irrelevant except that it causes failure.
[16:58:10] <acrichto> yes, but if it contained the port then it would be dropped when the task failed
[16:58:24] <acrichto> meaning the receiving task would wake up in failure
[16:58:30] <jack> the specific implementation here is that A is Decode(Url) and B is Exit
[16:58:41] <acrichto> DecodeUrlThenExit
[16:58:41] <jack> why would i pass the exit chan to decode?
[16:59:02] <jack> Why would I create this special message just for a test case of a pattern that is illegal? :)
[16:59:16] <jack> this test is for sending the wrong messages
[16:59:16] <acrichto> I'da have to talk this over a bit more, train arriving
[16:59:33] <acrichto> brb
[16:59:37] <jack> ie, sending Decode before the image is fetched.
[17:02:42] * jack works on a small test case.
[17:06:06] *** Joins: blank_name (blank_name@78B04CD2.66204B68.6D228269.IP)
[17:16:15] <acrichto> jack: if you're sending Exit, then you're saying "I don't need this channel any more"
[17:16:18] <acrichto> so why not drop it?
[17:16:41] <acrichto> and if you're waiting on a task, you could also use the notify_chan which you pass to spawn (rather than explicitly using a chan)
[17:19:30] <jack> what if it wasn't exit but some synchronous call?
[17:23:26] <acrichto> jack: so what you're asking for is that all contents are destroyed as soon as you know none of them will be received
[17:23:43] <acrichto> right now I'm tempted to say that we shouldn't do that, which means that this pattern will just not work
[17:23:55] <acrichto> if we do that instead, then this pattern will work just fine
[17:27:38] <larsberg> acrichto: it's not clear what we would do otherwise, other than change a lot of our recvs into a select across the port we want to recv on and the notify_port. and I don't even think that would work in general because often the sender does not "own" the other task, so it doesn't have a handle on the notify_port.
[17:27:52] <larsberg> e.g. when JS in the script task queries layout for an element's position
[17:35:06] <acrichto> jack: larsberg: how frequent is this pattern?
[17:36:48] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[17:36:49] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/zmsr8Q
[17:36:49] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[17:38:29] <larsberg> acrichto: probably in 5-10ish places right now. There's the script one, but also a bunch of shutdown-related ones for e.g. when we're closing a tab and need to ensure each of the subtasks has finished, but the order is set up between the peer tasks, not the parent (so they don't have the notify_port)
[17:38:39] <larsberg> and then our resource loader tasks use that pattern pretty extensively
[17:39:16] <larsberg> meh, closer to 5 (from a quick rgrep)
[17:39:40] <acrichto> I'm having a tough time wrapping my head around dropping the buffer when one half dies, it may just need a better abstraction
[17:39:45] <acrichto> like a WorkQueue
[17:39:56] <acrichto> which is created from a port and upon destruction it drains the port
[17:40:22] <acrichto> something like
[17:40:25] <acrichto> WorkQueue<T:
[17:40:27] <acrichto> WorkQueue<T>
[17:40:36] <acrichto> WorkQueue::new(port: Port<WorkMessage<T>>)
[17:40:49] <acrichto> enum WorkMessage<T> { Data(T), Shutdown(Port<()>) }
[17:41:36] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[17:41:36] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/KD__Jg
[17:41:36] <ghrust> 13rust/06auto 14ac2a24e 15Alex Crichton: Support arbitrary stdout/stderr/logger handles...
[17:41:36] <ghrust> 13rust/06auto 147dbd12a 15bors: auto merge of #11353 : alexcrichton/rust/improve-logging, r=brson...
[17:41:37] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[17:41:39] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[17:41:39] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/V_d3kQ
[17:41:39] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[17:53:02] *** Joins: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP)
[17:53:40] *** Quits: Jesse (jruderman@moz-9754CB0.hsd1.ca.comcast.net) (Quit: Jesse)
[17:53:44] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[17:53:44] *** ChanServ sets mode: +qo brson brson
[17:57:06] <pnkfelix> acrichto: pcwalton: is there a usual room in SFO for the mtg?
[17:57:28] <acrichto> pnkfelix: huh, dunno, I'm usually in MTV for it
[17:57:32] <pcwalton> "at each team member's house" ;)
[17:59:26] <pnkfelix> acrichto: oh i see, i didn't know you flip betwee SFO and MTV 
[18:07:26] *** Joins: glaebhoerl (glaebhoerl@3391DE98.E9231B2.A0179ACD.IP)
[18:20:54] <eddyb> tt_tok is cool, but how do I rename it to UpperCamelCase? TTTok?
[18:21:08] <eddyb> it works for MRExpr and such, but TTT looks silly
[18:21:14] <eddyb> same for ii_item
[18:21:44] <sfackler> I think it would either be TTTok or TtTok
[18:22:12] <sfackler> iirc at some point a couple months ago it was decided that Rust would to e.g. HttpResponse instead of HTTPResponse
[18:22:22] *** Joins: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com)
[18:22:32] <cmr> yes, that was a thing that happened.
[18:22:40] <sfackler> (the real solution is enum mod :D)
[18:22:41] <eddyb> sfackler: but the enum is TokenTree. mod scoping for enums would help at least a little here
[18:22:56] <eddyb> sfackler: hah, thinking of that at the same time :P
[18:23:00] <sfackler> TokenTreeTok!
[18:27:13] *** Joins: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net)
[18:27:13] *** ChanServ sets mode: +o tjc
[18:43:44] <eddyb> oh, hey, JSON serialized AST is smaller now. but I'm guessing that's used only for tests
[18:50:36] <jack> acrichto, larsberg: deadlock minimal example: https://gist.github.com/metajack/8304480
[18:56:33] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[18:56:33] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/KD__Jg
[18:56:33] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[18:57:03] <eddyb> dbaupp: great, I'll break quote again :/
[18:57:38] <eddyb> #[cfg(stage0)] fn tt_tok(...) -> TokenTree {TTTok(...)} // might do the trick
[18:59:11] *** Quits: gwty (gwtypc@D015B940.C0AE0958.71EA9E17.IP) (Ping timeout)
[19:01:20] <jack> acrichto, larsberg: that example is basically showing that mixing async and sync messages will deadlock if you cause a failure.
[19:01:43] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[19:01:43] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/6iI05Q
[19:01:43] <ghrust> 13rust/06auto 1420ccfde 15Nif Ward: Added in Clone/TotalEq/TotalOrd/ToStr traits to all parts of btree....
[19:01:43] <ghrust> 13rust/06auto 141d40fd4 15bors: auto merge of #11263 : niftynif/rust/btree, r=catamorphism...
[19:01:43] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[19:01:44] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[19:01:44] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/MQeNTQ
[19:01:44] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[19:01:49] <jack> because the chan is in alive in limbo in the queue of a failed task.
[19:03:49] <acrichto> brson: I'm curious to your thoughts on jack's example as well
[19:04:38] <acrichto> brson: basically the failure mode right now is that there's a Chan sitting in the queue of another channel, and the other channel has had its port destroyed (but the sending half is alive) so the pending queue instances aren't destructed yet
[19:05:09] <jack> if this pattern is in servo we haven't triggered the failure that causes it. this is adapted from a unit test that specifically tries to cause a failure and make sure we fail.
[19:05:17] <jack> so the unit test now deadlocks instead
[19:05:59] <jack> what i personally expected was that when the task dies, my port.recv() would fail.
[19:07:24] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Ping timeout)
[19:08:04] <larsberg> jack: presumably we would hit it if script sent a request for an element's position to layout but layout died before answering it. script would be blocked in the recv(). Not that layout would ever die :-)
[19:08:53] <jack> larsberg: yes. i think it could happen for sure. we just haven't hit it yet :)
[19:09:37] <larsberg> well, we still have linked task failure in the version of rust we are using
[19:09:58] <larsberg> so it could only happen in new-Rust
[19:11:48] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[19:11:48] *** ChanServ sets mode: +ao dherman dherman
[19:12:07] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[19:18:42] <brson> jack acrichto: in previous iterations we made the port drain the queue when dropped
[19:19:30] <brson> when we had the c++ runtime
[19:19:46] <brson> that would fix the problem i think, but it's not clear it's the right thing to do
[19:20:02] <sfackler> acrichto: pcwalton just read the meeting notes. the new tests will probably fail most of the time at stage1, which is something that should probably be worked out before it merges
[19:20:21] <acrichto> brson: it seems to me like the right thing to do though, as in it makes the most semantic sense in my head
[19:20:47] <acrichto> sfackler: the tests that fail are just make check-stage1-rpass-full?
[19:21:01] <sfackler> check-stage1-rpass I think
[19:21:06] <sfackler> and possibly check-stage1-cfail
[19:21:22] <acrichto> hmm those are actually commonly run
[19:21:31] <acrichto> you could move them to rpass-full
[19:21:39] <acrichto> they wouldn't actually need to be there, but those are much less commonly run
[19:22:05] <brson> istm like whatever build system we have there will be a stage where loadable syntax crates are invalid
[19:22:23] <brson> maybe we should just have a seperate set of tests
[19:22:33] <sfackler> brson: I think if the auxilliary crate is built by stage-n-1 rustc it should always work
[19:22:34] <acrichto> I still think we need a story for libstdmacros
[19:22:38] <sfackler> well, after a new snapshot
[19:23:01] <brson> sfackler: that sounds like a hack to me. real world code isn't going to be doing that
[19:23:26] *** Joins: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[19:23:56] <sfackler> brson: right, but I *think* that it should be more stable at higher stages
[19:24:19] <sfackler> at some point it should hit a fixed point
[19:24:53] <sfackler> at the very least, linking against rustc's version of libsyntax should make it more stable
[19:25:37] <sfackler> acrichto: pcwalton's idea about 2-phase compilation seems like a decent direction but I think it needs to be fleshed out
[19:26:19] <acrichto> sfackler: I still think that from a usability perspective everything should "just work" with "extern mod std;"
[19:26:32] <jack> brson, acrichto: what is the disadvantage to draining on task failure?
[19:26:43] <sfackler> acrichto: I think it would, there would just be 2 crates searched for when you do that
[19:26:46] <acrichto> sfackler: in the ideal world, that directive links against libstd, pulls in libstdmacros into the compiler, etc
[19:26:49] <sfackler> the compile time one and the link time one
[19:27:01] <acrichto> jack: it's unclear how to implement it right now
[19:27:13] <acrichto> jack: or rather it's not trivial to add to channels
[19:27:15] <sfackler> I think pcwalton's idea was to actually output 2 crates when you build a lib, the one with all the macros and the runtime one
[19:27:36] <acrichto> sfackler: that's what I would expect, but you run into a bootstrapping problem, libstd can't use its own macros
[19:27:45] <acrichto> sfackler: in that libstd can't have any logging/printing/conditions/etc
[19:27:49] <acrichto> or at least not pretty ones
[19:27:50] <sfackler> it could if you build the macro one first and then link it into the compiler!
[19:28:11] <acrichto> but then were does the libstd come from for the macro crate?
[19:28:26] <sfackler> rustc's perferrably
[19:28:35] <sfackler> since it'll be loaded into rustc's process
[19:28:52] <sfackler> this goes back to that bug that brson filed I think
[19:29:41] <jack> I guess I can remove that test for now.
[19:29:52] *** Quits: pcwalton (pcwalton@moz-DA87EE4.hsd1.ca.comcast.net) (Quit: pcwalton)
[19:30:48] <acrichto> sfackler: hm interesting, that makes me think that the stages we have right now are correct
[19:30:55] *** Quits: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net) (Ping timeout)
[19:31:06] <acrichto> sfackler: so then the compiler knows that it's compiling a syntax library, it links against its own libstd (from stage n-1)
[19:31:18] *** Joins: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net)
[19:31:18] *** ChanServ sets mode: +o tjc
[19:31:25] <sfackler> it's a bit silly to distribute 2 versions of libfoo but it's not too crazy
[19:31:46] <sfackler> you could maybe just only use the versions of libfoo that rustc links against and toss the extra copies completely
[19:32:08] *** Quits: TimAbraldes (quassel@moz-7FD19BDC.hsd1.or.comcast.net) (Input/output error)
[19:32:27] <acrichto> sfackler: I don't follow, why are we distributing two copies of libfoo?
[19:32:57] <sfackler> there's one that rustc uses and the other one that goes into /usr/lib
[19:33:15] <acrichto> not necessarily
[19:33:20] <acrichto> libfoo is bundled inside of libfoomacros
[19:33:25] <acrichto> you just strip out most of it all the time
[19:34:06] <acrichto> rustc foo.rs would basically run compilation twice, once to produce libfoo-macros.so and once to produce libfoo.{some,extension}
[19:34:07] <sfackler> I think the idea would be to limit the entry points on the libfoomacros build to just the macro registrar
[19:34:15] <sfackler> so the dead code pass can get rid of most of it
[19:34:31] <sfackler> right
[19:34:34] <acrichto> we may need to optimize rustc to make the build times reasonable, but that way you also define all macros in the crate itself
[19:34:46] <sfackler> yep
[19:35:28] <acrichto> hm, so would the compiler inject 'extern mod syntax'?
[19:35:32] <sfackler> if it's true that the vast majority of the build time is spent in llvm then stripping stuff that isn't used by the macro stuff should make the macro crate pretty tiny
[19:35:33] <acrichto> I think it should
[19:35:50] <sfackler> that seems kind of magical
[19:35:59] <acrichto> well we inject extern mod std right now
[19:36:08] <acrichto> otherwise everyone needs
[19:36:17] <acrichto> "#[phase(syntax)] extern mod syntax;"
[19:36:23] <acrichto> or maybe #[cfg(syntax)] extern mod syntax;
[19:36:25] <sfackler> I think pcwalton's idea was that you'd have something like "#[phase(syntax)] mod macros { extern mod syntax; #[macro_registrar] fn foo(...) {...} }"
[19:36:40] <acrichto> hm yes that's what I would expect
[19:36:49] *** Quits: tedh (tedh@moz-F3B34318.hsd1.il.comcast.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[19:37:54] <sfackler> I guess it could be a #[cfg(syntax)] there instead
[19:38:05] <sfackler> but I kind of prefer phase
[19:39:17] <acrichto> I think in that case phase is better
[19:39:32] <acrichto> b/c it's a whole nother compilation session, not just configuration
[19:40:17] *** Joins: gwty (gwtypc@B8540510.B7CA1378.F44414AF.IP)
[19:41:52] <acrichto> sfackler: cool, so it sounds like you/pcwalton are aware of my concerns, I think dherman/pcwalton wanted to convene on loadable syntax extensions, and other than that I think it's good to go
[19:42:14] <sfackler> cool
[19:42:53] <acrichto> sfackler: and again, awesome work!
[19:46:58] <sfackler> :D
[19:53:21] *** Quits: friggle (friggle@moz-A607EAFA.members.linode.com) (Ping timeout)
[19:53:32] *** flaper87|afk is now known as flaper87
[20:00:11] *** Joins: tedh (tedh@moz-F3B34318.hsd1.il.comcast.net)
[20:03:43] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[20:04:19] <strcat> https://github.com/mozilla/rust/pull/10926 r?
[20:06:58] <strcat> cmr: sec, added an extra commit
[20:07:07] <strcat> there was a method added to Rc since I wrote this
[20:07:48] <cmr> should probably beak on Weak too
[20:07:50] <cmr> r=me if you add it
[20:08:01] <strcat> hm
[20:08:23] <eddyb> oooh, meeting
[20:08:40] <eddyb> wait, no cheap Rc? is that fair?
[20:08:41] <strcat> cmr: just between Weak and other Weak?
[20:08:56] <strcat> eddyb: that's what was decided so that's what I'm implementing
[20:08:59] <cmr> strcat: probably yeah
[20:09:27] <strcat> eddyb: it's not a huge difference
[20:10:04] <strcat> still 2 words smaller than the @ boxes with the extra feature of supporting non-owning cyclical refs without leaks
[20:10:06] <eddyb> default type params didn't make it to the meeting *sad face*
[20:10:29] <strcat> cmr: hm
[20:10:40] <cmr> strcat: comparing Weak and Rc is useful too
[20:10:48] *** Quits: eddyb (eddy@EE946B63.921A1753.FCAAE698.IP) (Quit: Konversation terminated!)
[20:10:49] <acrichto> strcat: out of curiosity, why the NonManaged bound/
[20:10:55] <cmr> I wonder if we should have a ToPtr or something like that, to get a raw pointer out of a smart pointer.
[20:10:56] *** Joins: eddyb (eddy@EE946B63.921A1753.FCAAE698.IP)
[20:11:00] <strcat> acrichto: because it can't use ~ to allocate anymore
[20:11:02] *** Quits: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[20:11:10] <strcat> since ~ couples deallocation with destruction
[20:11:17] <strcat> but tbh, Rc never worked with @ inside
[20:11:20] <strcat> I don't know why
[20:11:29] <strcat> I tried to support it but didn't test it
[20:11:36] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[20:11:36] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/6iI05Q
[20:11:36] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[20:11:45] <acrichto> strcat: so this is just a pre-emptive thing to prepare for a gc?
[20:11:45] <eddyb> strcat: in the AST I'd use a custom Rc with an u8 ref-count anyway
[20:11:55] <strcat> acrichto: it's broken now for @ inside
[20:12:02] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[20:12:03] <acrichto> how come?
[20:12:06] <eddyb> because the repr differs
[20:12:13] <strcat> acrichto: because it has a header
[20:12:20] <eddyb> it doesn't take a pointer to the interior, it casts the pointer itself
[20:12:41] <strcat> acrichto: or do you mean what I wrote here? 
[20:12:56] <strcat> acrichto: with Rc, as written, it was broken with @ due to the ~ ref being different
[20:13:07] <eddyb> sooo do I wait another week?
[20:13:09] <strcat> without the Send/Freeze bound, you can create cycles in both
[20:13:17] <acrichto> strcat: where's that used? (I should read the patch more closely)
[20:13:26] <strcat> acrichto: not used anymore
[20:13:35] <acrichto> oh, so we can drop the NonManaged bound?
[20:13:39] <strcat> acrichto: no
[20:13:51] <strcat> acrichto: Rc used to allocate with malloc/free and was changed to ~ with the intent being to support gc
[20:13:53] <acrichto> hm, I still don't follow why we need it to be not managed...
[20:14:10] <acrichto> so this isn't needed right now, it's just needed in the future for a "real gc"?
[20:14:18] <strcat> acrichto: I removed the Send/Freeze bound and needed to prevent use-after-free with @ in dtors
[20:14:37] <strcat> acrichto: it's needed now
[20:14:46] <strcat> acrichto: it's the same problem that caused #[unsafe_destructor] to be required
[20:14:56] <strcat> acrichto: so, if you make a cycle of Rc, it's supposed to leak
[20:15:09] <strcat> if there are @ inside, it may try to free part of the graph, and cycle back around and call dtors twice
[20:15:38] <eddyb> that's worse than just a repr difference
[20:15:45] <strcat> the counts will underflow
[20:15:50] <strcat> and it will keep looping calling dtors
[20:16:27] <acrichto> strcat: wait so you have an @ in a ring of Rcs, and during annihilation it will run the destructor for the @-box, which may lead the ring of Rcs to being destroyed, but where's the failure?
[20:16:34] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[20:16:34] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/0CsAtA
[20:16:34] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[20:16:37] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[20:16:37] <ghrust> 01[13rust01] 15bors pushed 7 new commits to 06auto: 02http://git.io/XFDOmg
[20:16:37] <ghrust> 13rust/06auto 14bfcea0b 15Daniel Micay: add a `NonManaged` kind...
[20:16:37] <ghrust> 13rust/06auto 14b1a96bd 15Daniel Micay: stop treating `Rc` cycles as unsafe
[20:16:37] <ghrust> 13rust/06auto 14404f788 15Daniel Micay: add a strong/weak reference counted pointer type
[20:16:39] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[20:20:06] <acrichto> strcat: I'm cancelling the build b/c brson/I are unclear on why a new kind is needed
[20:20:22] <acrichto> if we add a new kind we need to discuss it further I think, I don't see any documentation as to why the kind is needed
[20:21:27] <strcat> rusti: std::rc::Rc::new(@5)
[20:21:31] -rusti- std::rc::Rc<@int>{ptr: (0x7f4b6c000f80 as *mut ())}
[20:21:31] -rusti- leaked memory in rust main loop (1 objects)
[20:21:31] -rusti- out: /build/rust-git/src/rust/src/rt/memory_region.cpp:184: memory_region::~memory_region(): Assertion `false' failed.
[20:21:31] -rusti- application terminated abnormally with signal 11 (Segmentation fault)
[20:21:33] <strcat> er
[20:21:47] <strcat> anyway that's not going to let me get far enough to demonstrate
[20:22:10] <strcat> so lets say you make
[20:22:54] <strcat> Rc1 -> @1 -> Rc1
[20:23:09] <strcat> the annihilator will come along to free that @
[20:23:14] <strcat> despite the cycle
[20:24:06] <acrichto> is that a problem?
[20:25:16] <strcat> in order to drop the Rc, it will first drop the inner type
[20:25:19] <strcat> which is the @
[20:25:24] <strcat> and inside that is the Rc
[20:25:37] <strcat> and now the refcount goes from 0 to uint::max
[20:25:57] <strcat> anyway if there are other types in this chain like ~, there will be memory unsafety
[20:26:15] <acrichto> I'm still not following, this seems perfectly normal and safe?
[20:26:34] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[20:26:34] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 140874645 to 141d40fd4: 02http://git.io/N3iJvQ
[20:26:34] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[20:41:46] <strcat> acrichto:     let x = Rc::new(Gc::new(5));
[20:41:47] <strcat> well
[20:42:01] <strcat> it isn't able to get to the point where I can cause the cycle issue
[20:42:11] <strcat> failed at 'assertion failed: self.live_allocs.is_null()', /build/rust-git/src/rust/src/libstd/rt/local_heap.rs:135
[20:42:13] <strcat> zsh: illegal hardware instruction  ./foo
[20:42:15] <strcat> from that one line
[20:42:17] <strcat> without the bound
[20:42:58] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[20:43:06] <strcat> anyway I don't know why it didn't work with the old Rc and I don't know why it runs into this problem now
[20:43:20] <strcat> I do know there's a safety issue with the annihilator if you make cycles of Rc with @ inside
[20:44:46] *** Quits: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Quit: lkuper)
[20:46:57] <eddyb> strcat: how do you not know?
[20:47:13] <eddyb> or are you referring to something else?
[20:47:15] <strcat> because take glue isn't part of my thought model for rust code
[20:47:32] <strcat> I don't know how to write correct unsafe code in the presence of it - I haven't ever thought about it
[20:47:58] <strcat> how do you call a destructor on an object at some address, if the object has take glue?
[20:48:15] <eddyb> how does that have anything to do with take glue?
[20:48:21] <strcat> the cycle part doesn't
[20:48:26] <strcat> the reason it fails atm does
[20:48:31] <eddyb> does it work if you adjust for the managed box header?
[20:48:40] <strcat> eddyb: it's not allocating with ~ anymore
[20:48:49] <eddyb> oh, okay
[20:48:51] <strcat> I changed it
[20:49:07] <strcat> anyway let me try one more thing
[20:49:08] <eddyb> so it would use an allocator directly?
[20:49:35] <eddyb> Rc<T, A=DefaultHeap> and Uniq<T, A=DefaultHeap> with no interaction between the two?
[20:49:59] <eddyb> (other than moving out of an Rc with ref-count of 1 or anything like that)
[20:50:13] <strcat> if you wanted, sure
[20:50:15] <eddyb> though you can do that with the value inside which sounds safer
[20:50:51] <eddyb> strcat: I'm tempted to have an special ref-counted ptr in the ast and do emplace folding where possible
[20:51:51] <eddyb> massif shows folding spikes which leave unfreed pages with the default allocator, so there should be a memory usage/performance improvment
[20:53:40] *** Joins: pcwalton (pcwalton@moz-C07D5168.p2p.sfo1.mozilla.com)
[20:53:40] *** ChanServ sets mode: +ao pcwalton pcwalton
[20:58:19] <eddyb> dbaupp: down to 162
[20:58:54] <eddyb> so far:  95 files changed, 1961 insertions(+), 2007 deletions(-)
[20:59:22] <kimundi> eddyb: what are you changing?
[20:59:51] <eddyb> kimundi: de-non-camel-case-types-ifying libsyntax
[21:00:07] <kimundi> ah, nice :)
[21:00:29] <kimundi> There are a lot unturned camels in that one :P
[21:05:29] *** Joins: friggle (friggle@moz-A607EAFA.members.linode.com)
[21:05:47] *** Joins: jdm (jdm@moz-AC9499B2.cable.teksavvy.com)
[21:09:42] <friggle> perhaps of interest to some of you, I started up http://llvmweekly.org/issue/1 yesterday
[21:10:22] <cmr> friggle: ah so it was you! thanks, it's super cool
[21:11:25] <friggle> cmr: thanks, I was rather inspired by This Week in Rust (which I've found super helpful for rust, so figured a similar summary of changes for llvm would go down well)
[21:13:00] <cmr> friggle: what do you use for email subscriptions etc?
[21:13:49] <friggle> cmr: I just coded up a double opt-in registration procedure using mailgun. The API is well documented and it seems to get the job done pretty well
[21:16:14] <friggle> only deliverability problems have been the subscription confirmation request with @arm.com email servers. Their spam filter 'quarantines' it, so they get delivered at the end of the day in a list of suspicious emails. Having interned at ARM before, I'm willing to put that down to IT weirdness ;)
[21:17:50] <cmr> friggle: ah cool, didn't know about mailgun
[21:20:52] <pcwalton> acrichto: brson: how do you feel about using TLS more in rustc for things like the type context, the crate context, etc?
[21:21:02] <pcwalton> it would save a lot of refcount bumps for immortal things
[21:21:25] <strcat> pcwalton: might be slow, though
[21:21:31] <pcwalton> for now.
[21:21:39] <pcwalton> I don't care about fixable slowness
[21:21:45] <strcat> even static TLS is pretty slow in dynamically linked binaries
[21:21:54] <pcwalton> it would also let us remove plenty of @s
[21:21:57] <pcwalton> which is my real motive ;)
[21:24:25] *** Joins: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net)
[21:24:25] *** ChanServ sets mode: +o tjc
[21:29:07] *** Quits: eddyb (eddy@EE946B63.921A1753.FCAAE698.IP) (Ping timeout)
[21:29:17] *** Quits: kimundi (kimundi@moz-32142F5A.dip0.t-ipconnect.de) (Ping timeout)
[21:31:52] <jack> What is hte difference between std::io::Process and std::run::Process?
[21:32:02] <jack> er, std::io::process::Process even
[21:32:59] *** Joins: kimundi (kimundi@moz-AEB542AA.dip0.t-ipconnect.de)
[21:33:05] *** Joins: dogweather (dogweather@moz-4EC23EE5.hsd1.or.comcast.net)
[21:36:47] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[21:36:47] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/PDj9Aw
[21:36:47] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[21:41:21] <brson> friggle: your llvm weekly is really neat. thanks
[21:41:33] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[21:41:33] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/50etfA
[21:41:33] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[21:41:34] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[21:41:34] <ghrust> 01[13rust01] 15bors pushed 8 new commits to 06auto: 02http://git.io/yZbKJQ
[21:41:34] <ghrust> 13rust/06auto 14c1e3e2d 15Alex Crichton: Fix leaking trait imports across modules...
[21:41:34] <ghrust> 13rust/06auto 14f117549 15Alex Crichton: rustc: De-indent portions of middle::resolve...
[21:41:35] <ghrust> 13rust/06auto 140655eda 15Alex Crichton: std: Fill in all missing imports...
[21:41:37] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[21:41:46] <acrichto> strcat: sry was out to lunch, but I'm don't think that just b/c Rc<@T> crashes means that we should have a NonManaged bound, we need to understand that it's not a bug in the annihilator
[21:41:56] <acrichto> jack: std::run is more "convenient"
[21:42:01] <acrichto> jack: or at least it was ages ago
[21:42:18] <strcat> acrichto: but I think it's fundamentally unsafe if you make cycles of Rc
[21:42:19] <strcat> *shrug*
[21:42:29] <friggle> brson: you're welcome, glad it's useful to people.
[21:42:33] <acrichto> strcat: can you explain why? I am still in a state of not understanding
[21:43:00] <strcat> acrichto: well I was going to demonstrate what I think will happen but it doesn't work at all :(
[21:43:01] <brson> pcwalton: well, you know i don't like tls generally, but I don't mind polluting rustc. if it was my pref i'd probably want a single dynamic scope session, not a lot of different variables
[21:43:15] <acrichto> strcat: if it doesn't work at all, that sounds very bad, as in there are other bugs
[21:43:35] <strcat> acrichto: I don't really think so, I think my code just doesn't work in the presence of take glue
[21:43:46] <acrichto> brson: pcwalton: we already use TLS for the llcx, so we may we well just stick the whole ccx into TLS if we keep going that
[21:44:28] <acrichto> strcat: I haven't heard any reason why Gc shouldn't be in Rc other than "it just crashes and I don't know why"
[21:45:00] <strcat> because you can create cycles of Rc now and the annihilator can't be aware of them
[21:45:05] <strcat> and it has no way to mark them as already destroyed
[21:45:46] <acrichto> strcat: that is not a problem, that sounds like it's just a leak
[21:45:58] <acrichto> that's just something you can do with Rc, it doesn't sound like a soundness bug
[21:46:13] <strcat> I'm talking about the presence of @ inside a cycle
[21:46:17] <acrichto> again, I'm just trying to understand, I'm unsure of whether it's sound or not
[21:46:20] <strcat> the annihilator will start destroying at the @
[21:46:37] <acrichto> that's not a problem, how is that wrong?
[21:46:46] <acrichto> the Rc cycle is going to leak, the Gc things will be deallocated, where's the bug?
[21:47:06] <strcat> no the Rc cycle won't leak, the annihilator is ripping it apart from the inside
[21:47:29] <acrichto> ok, so that's better than before?
[21:47:31] <strcat> if you have Rc1 -> @ -> Rc1 where there is 1 ref to Rc1 (inside itself)
[21:47:37] <strcat> the annihilator will come along to free the @
[21:47:46] <strcat> will do so by destroying the Rc inside the @
[21:47:58] <strcat> and the Rc will try to destroy itself by destroying the inner @
[21:48:41] <acrichto> it Rc will not run the destructor of @
[21:48:52] <acrichto> during annihilation no @ destructors are run other than those that the annihilator is running
[21:48:57] <acrichto> all objects are "immortal"
[21:48:59] <acrichto> or at least so I thought
[21:49:47] <strcat> acrichto: the Rc is allocated with a ~ though
[21:49:56] <strcat> I can remove that
[21:50:08] <acrichto> yes, so the ~ box will be destroyed
[21:50:16] <acrichto> in destroy the ~ box the refcount on the @ is decremented
[21:50:23] <strcat> but the Rc can form a separate cycle
[21:50:26] <acrichto> the refcount goes from 0x777777 to 0x7777776
[21:50:34] <strcat> Rc1 -> {Rc1, @} -> Rc1
[21:50:37] <strcat> er
[21:50:44] <strcat> yes that makes sense ^
[21:51:11] <strcat> so the Rc holds a ref to itself and to the @, which holds a ref back to the Rc too
[21:51:12] <acrichto> so that will never get deallocated?
[21:51:23] <acrichto> if the rc holds a ref to itself it will never be destroyed
[21:51:24] <strcat> but it destroys the ~
[21:51:37] <acrichto> the rc refcount will always be > 1 if it holds a ref to itself
[21:52:38] <strcat> I'm convinced I could write sample code demonstrating this causing unsafety if it didn't assert for whatever reason
[21:52:40] * strcat shrugs
[21:53:01] <acrichto> strcat: until I see such code, I'm led to believe that it's safe to have @ in Rc
[21:53:13] <acrichto> if it's aborting then we need to fix these problems
[21:53:15] <strcat> not as implemented with ~ atm
[21:53:35] <strcat> anyway I'll remove the bound and it can be unsound, I don't care
[21:53:36] <acrichto> again, I am led to believe that it's safe until you can show me some code that fails
[21:53:41] <strcat> I don't want to keep arguing about the details about this
[21:54:03] <acrichto> I want the Rc type to be sound, but I don't want to add bounds that we don't understand why they're there
[21:55:28] <strcat> so you want me to reimplement it without ~?
[21:55:38] <acrichto> strcat: if you are concerned that it is unsound, then I am too, and I want to come to and understanding as to whether it's sound or not
[21:56:04] <acrichto> right now we are in the situation that you think it is unsound but I remain unable to be convinced
[21:56:33] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[21:56:33] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14b33eb25 to 144329fc6: 02http://git.io/N3iJvQ
[21:56:33] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[21:56:34] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[21:56:34] <ghrust> 01[13rust01] 15bors pushed 8 new commits to 06auto: 02http://git.io/pRf7_Q
[21:56:34] <ghrust> 13rust/06auto 14c1e3e2d 15Alex Crichton: Fix leaking trait imports across modules...
[21:56:34] <ghrust> 13rust/06auto 14f117549 15Alex Crichton: rustc: De-indent portions of middle::resolve...
[21:56:35] <ghrust> 13rust/06auto 140655eda 15Alex Crichton: std: Fill in all missing imports...
[21:56:35] <strcat> I think cycles of them are going to be unsound when the @ annihilator comes along
[21:56:37] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[21:56:43] <acrichto> if someone else can be convinced then that's fine, I just want there to be a full understanding of why there is a NonManaged bound
[21:56:46] <strcat> but right now, it uses ~, and won't work at all with @ inside
[21:57:02] <strcat> I can rewrite it to do allocation/initialization manually
[21:57:09] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Quit: Lost terminal)
[21:57:18] <strcat> or use transmutes
[21:57:20] <acrichto> you keep saying that cycles are unsound with @, I understand your have a concern about this, I do not understand why this is a concrern
[21:57:30] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[21:57:30] *** ChanServ sets mode: +qo brson brson
[21:57:35] <brson> oomed again
[21:59:55] <strcat>     pub fn borrow<'a>(&'a self) -> &'a T {
[21:59:57] <strcat>         unsafe { &(*self.ptr).value }
[21:59:59] <strcat>     }
[22:00:01] <strcat> acrichto: atm it does this
[22:00:17] <strcat> so, if I'm going to make it support @ inside (whether or not it's sound), that needs to change
[22:00:40] <acrichto> why?
[22:00:57] <strcat> because when  @ is inside that's indexing into the header in the ~
[22:01:19] <strcat> it needs more transmutes or to call exchange_malloc itself
[22:01:32] <acrichto> no T == @T
[22:01:44] <acrichto> self.ptr is just a unique malloc'd pointer
[22:01:46] <acrichto> there's no headers here
[22:02:06] <strcat> ~T and ~U where U has managed stuff inside are different
[22:02:24] <acrichto> ugh I thought we fixed that
[22:02:27] <strcat> managed-unique ~ has the list threaded through it and they get freed at some point
[22:02:37] <cmr> we fixed it so that ~T where T doesn't contain managed doesn't have a nasty repr
[22:03:00] <strcat> anyway I tried adding the necessary transmutes
[22:03:04] <strcat> but now the take glue does something weird
[22:03:57] <acrichto> strcat: ~@int involes local_malloc with size of 8
[22:04:17] <strcat> local_malloc != exchange_malloc, it adds a header
[22:04:24] <acrichto> ugh that's right
[22:04:33] <strcat> anyway it's not really that hard to work around
[22:05:01] <acrichto> just transmute it to &~T
[22:05:06] <acrichto> and deref through there
[22:05:17] <strcat> yes that's how I was finding the take glue problem
[22:05:50] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[22:07:06] <acrichto> strcat: ok so now that I understand that the ~ allocation of RcBox<T> is actually done on the local heap, then it may make more sense that htere's a problem with annihilation
[22:07:14] <acrichto> b/c the annihilator will attempt to deallocate the ~ box
[22:07:28] <strcat> that's not what I think is the problem though ;p
[22:07:47] <strcat> I can make it allocate without ~
[22:07:58] <acrichto> so if you don't use ~, you're still worried about a problem?
[22:08:07] <strcat> yes
[22:08:30] <acrichto> seems I still have more to understand
[22:08:32] <glaebhoerl> I think I get what strcat is saying
[22:08:34] <glaebhoerl> maybe
[22:08:47] <strcat> I'm convinced myself there's a problem involving custom destructors referring to the inner Rc if there is also an @ referring to that Rc
[22:08:56] <strcat> if there is a cycle involving that Rc too
[22:09:21] <strcat> anyway I'll get it working without ~ and try to demonstrate
[22:11:24] <glaebhoerl> if you have cycle such that there's an Rc (#1), inside that is an @ (#2), and inside that is an Rc (#3) referring to #1, then the cycle leaks, the GC comes in and frees #2 because the whole thing isn't rooted anywhere, so #3 is now uninitialized, in the process the destructor for #3 is called (because it was inside #2), which decrements the refcount for #1, causing the destructor for #1 to run in turn, which might try to access #
[22:11:26] <glaebhoerl> 2, which is uninitialized
[22:11:51] <glaebhoerl> (but wasn't there a rule that destructors aren't allowed to touch managed data? if so, maybe that obviates this issue?)
[22:11:56] *** Quits: shachaf (shachaf@moz-F37E0395.members.linode.com) (Ping timeout)
[22:12:11] <glaebhoerl> er "#2 is now uninitialized" in the above
[22:12:21] <strcat> glaebhoerl: you need the Rc cycle to be separate
[22:12:33] <acrichto> glaebhoerl: the destructor for #2 will not run again (the annhilator protects against this)
[22:13:35] <glaebhoerl> acrichto: do I remember right that there's also rules preventing destructors from touching managed data?
[22:13:42] <strcat> yes
[22:13:52] <glaebhoerl> strcat: why? (wrt. separate cycle)
[22:13:55] <strcat> can't implement Drop for a type with @ inside
[22:14:02] <glaebhoerl> oh
[22:14:10] <acrichto> glaebhoerl: the annihilation phase can be seen at https://github.com/mozilla/rust/blob/master/src/libstd/cleanup.rs#L70
[22:14:16] <strcat> Rc in a cycle directly with @ is managed and it won't let you implement Drop on a dtor with that Rc inside
[22:14:21] <strcat> but I don't think this stops it
[22:15:04] <acrichto> glaebhoerl: this is part of the reason why I think #[unsafe_destructor] exists
[22:15:21] <strcat> isn't it the whole reason?
[22:15:31] <strcat> generic types that aren't managed should be fine
[22:15:33] <acrichto> some business with type parameters I think, I was never totally sure
[22:15:42] <strcat> acrichto: because generic types can be managed
[22:15:51] <acrichto> yeah I dunno
[22:15:55] <strcat> and there's no bound you can put to say a type isn't managed
[22:16:02] <strcat> impl<T> Drop for Foo<T> { ... }
[22:16:16] <strcat> where it's 'struct Foo(T)'
[22:16:19] <glaebhoerl> strcat: there's also some funny business with it not getting monomorphised correctly or something (or I seem to remember some bug report to that effect)
[22:16:20] <strcat> T could be @
[22:16:27] <strcat> glaebhoerl: that's fixed
[22:16:40] <sfackler> generic destructors vtables are fixed?
[22:16:43] <strcat> no
[22:16:49] <sfackler> oh ;_;
[22:17:03] <strcat> that gets you a compile-time failure though
[22:17:38] *** Quits: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com) (Connection reset by peer)
[22:18:02] *** Joins: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com)
[22:18:26] <glaebhoerl> strcat: anyway, what's your version of the Rc+Gc problem where the Rc cycle is separate?
[22:27:55] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[22:27:56] *** ChanServ sets mode: +qo brson brson
[22:30:29] <kimundi> acrichto: r? https://github.com/mozilla/rust/pull/10854
[22:39:19] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[22:41:05] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[22:41:06] *** ChanServ sets mode: +qo brson brson
[22:42:56] *** Quits: glaebhoerl (glaebhoerl@3391DE98.E9231B2.A0179ACD.IP) (Ping timeout)
[22:46:34] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[22:46:34] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14c933e28 to 144329fc6: 02http://git.io/N3iJvQ
[22:46:34] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[22:46:36] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[22:46:36] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/hZ_IWg
[22:46:36] <ghrust> 13rust/06auto 14ec66608 15Marvin LÃ¶bel: Renamed Option::map_default and mutate_default to map_or and mutate_or_set
[22:46:36] <ghrust> 13rust/06auto 149cc75b6 15bors: auto merge of #10854 : Kimundi/rust/result_compose_map_mutate_or, r=alexcrichton...
[22:46:37] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[22:49:25] *** flaper87 is now known as flaper87|afk
[22:56:23] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[22:56:24] *** ChanServ sets mode: +ao dherman dherman
[22:56:36] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[22:56:36] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 149cc75b6 to 144329fc6: 02http://git.io/N3iJvQ
[22:56:36] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[22:56:38] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[22:56:38] <ghrust> 01[13rust01] 15bors pushed 8 new commits to 06auto: 02http://git.io/D1G3kA
[22:56:38] <ghrust> 13rust/06auto 14c1e3e2d 15Alex Crichton: Fix leaking trait imports across modules...
[22:56:38] <ghrust> 13rust/06auto 14f117549 15Alex Crichton: rustc: De-indent portions of middle::resolve...
[22:56:38] <ghrust> 13rust/06auto 140655eda 15Alex Crichton: std: Fill in all missing imports...
[22:56:41] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[22:56:46] *** Quits: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[22:59:25] *** Joins: TimAbraldes (quassel@moz-7FD19BDC.hsd1.or.comcast.net)
[23:14:10] *** Joins: a_m0d|home (a_m0d@moz-322A4DE4.acanac.net)
[23:15:29] *** Quits: pcwalton (pcwalton@moz-C07D5168.p2p.sfo1.mozilla.com) (Ping timeout)
[23:24:24] *** Joins: pcwalton (pcwalton@moz-C07D5168.p2p.sfo1.mozilla.com)
[23:24:25] *** ChanServ sets mode: +ao pcwalton pcwalton
[23:33:27] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[23:41:22] <dbaupp> hm, a safe GC would be much easier without ~ and ~[] being defined in the compiler
[23:42:03] <strcat> dbaupp: what about custom uses of malloc or lets say qt/gtk allocators
[23:42:41] <dbaupp> strcat: "easy" enough, just register the blocks of memory as GC roots if necessary
[23:43:36] <dbaupp> (if necessary == contains GC pointers directly; which currently requires a branch on a owns_managed::<T>() equivalent... but I can't think of a better way :( )
[23:44:13] <dbaupp> at the very least thoguh, my current design means that Rc doesn't have to have a NonManaged bound, since there's no headers or anything.
[23:44:49] <strcat> dbaupp: owns_managed doesn't really work
[23:44:54] <strcat> because you can't change a type repr with it
[23:45:05] <strcat> but I guess you mean with boehm?
[23:45:06] <dbaupp> also, there's no equivalent to ~[~"foo", ~"bar", ~"baz"] for library defined vector types other than `let mut v = Vec::new(); v.push(~"foo"); v.push(~"bar"); v.push(~"baz");` :(
[23:45:20] <dbaupp> yeah, no headers inline, everything is stored in side tables
[23:45:25] <strcat> dbaupp: Vec::from_slice([1, 2, 3])
[23:45:34] <dbaupp> doesn't work for moving things
[23:46:05] <dbaupp> could have a trait that's impled for [T, .. n] for a selection of small n, but that's obviously hideous.
[23:46:39] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[23:46:39] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14af20f86 to 144329fc6: 02http://git.io/N3iJvQ
[23:46:39] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[23:46:41] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[23:46:41] <ghrust> 01[13rust01] 15bors pushed 5 new commits to 06auto: 02http://git.io/3iqV9A
[23:46:41] <ghrust> 13rust/06auto 14f5ee077 15Brian Anderson: mk: Fix formatting of docs.mk
[23:46:41] <ghrust> 13rust/06auto 14d4639ad 15Brian Anderson: doc: Update style of index, organization and trim out some excess.
[23:46:42] <ghrust> 13rust/06auto 146f09d80 15Steve Klabnik: Add Pointer tutorial, rename borrowed pointer tutorial.
[23:46:44] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[23:46:53] <dbaupp> (I'm currently not using boehm; just a crappy pure Rust, completely conservative GC. Much easier to be just stop-the-task that way.)
[23:53:36] <kimundi> acrichto: Do'h! I forgot to actually commit my latest option default rebase changes
[23:53:43] <kimundi> No wonder the build failed :P
[23:54:51] <kimundi> acrichto: r? https://github.com/mozilla/rust/pull/10854

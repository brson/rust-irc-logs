[00:12:10] *** Quits: achanda (achanda@moz-qv7q4n.ca.comcast.net) (Connection closed)
[00:23:59] <nrc> aturon: assuming you're not around, but just going to leave some questions/comments about specialisation here for when you are
[00:24:13] <nrc> in the hazard/type checking section
[00:25:10] <nrc> The obvious solution to me is that specialised impls cannot change the assoc types given by the less specialised impls - is that impossible to check, or are there use cases for allowing the types to change?
[00:26:55] <nrc> general opinion: this is a really exciting and useful feature, but the extra complexity in the trait system (already too complex, IMO) is kinda scary
[00:29:06] <nrc> do you have use cases for `default` on individual methods as opposed to on impls?
[00:30:26] <nrc> (I'd probably like to see `default impl` in addition to per-method early, rather than saved for later)
[00:47:03] *** Quits: scott (uid25790@moz-e5ok1n.brockwell.irccloud.com) (Quit: Connection closed for inactivity)
[00:57:53] *** Joins: scott (uid25790@moz-e5ok1n.brockwell.irccloud.com)
[01:12:30] *** Joins: achanda (achanda@moz-qv7q4n.ca.comcast.net)
[01:17:32] *** Quits: achanda (achanda@moz-qv7q4n.ca.comcast.net) (Ping timeout: 121 seconds)
[01:31:49] *** bpugh is now known as bpugh_
[01:31:49] *** bpugh_ is now known as bpugh
[03:32:19] <jroesch> nrc what is the correct way to find the defining Item given a TypeParameterDef? I thought that I could look it up in the AST map, but it appears I was wrong (at least from the output of my code) 
[03:40:56] <nrc> jroesch: you should be able to look up the def_id in the def map - is that what you are trying?
[03:42:23] <jroesch> I've been trying to get really good errors for default type parameter fallback, and so I'm trying to compute the span for the item that a TypeParameterDef originates from. I was just doing `tcx.map.find(def.def_id.node)`
[03:43:07] <jroesch> tried looking up the parent as well
[03:43:28] <jroesch> with get_parent then looking that up 
[03:43:33] <jroesch> got `None` back for both
[03:43:42] <nrc> you need to first look up def.def_id in tcx.def_map
[03:43:50] <nrc> (I think)
[03:44:48] <nrc> wait, maybe not - are they always from the local crate?
[03:45:58] <nrc> jroesch: OK, ignore everything I said
[03:46:41] <nrc> so, the def_id is just the id of the trait where the type parameter is defined, iirc and then the index tells you which actual type parameter you are referring to
[03:49:03] *** Joins: achanda (achanda@moz-qv7q4n.ca.comcast.net)
[03:49:38] <nrc> bleugh, that doesn't seem to be true, actually, I must be misremembering
[03:50:06] <jroesch> yeah that was the impression I got from reading through the code
[03:50:07] <nrc> so, def_id is the id of the type param, but it is probably not kept in the ast map - the ast map doesn't contain every node
[03:51:43] <nrc> you could probably add it to the ast map, if you wanted
[03:54:11] <jroesch> would that be the easiest way to do it? I really just want to be able to show users the definition site of a default, currently I show where the variables originate in the program, and I think the message is way more helpful if we show the def as well 
[03:59:22] <nrc> I think the ast map is the only way to map an id back to a node and thus the span
[03:59:55] <nrc> you could probably look up the trait itself in the tcx some how, and then show that, rather than individual params
[04:03:04] <jroesch> nrc yeah it seems messier that way, I'll look into adding to the ast_map 
[04:07:39] *** Quits: achanda (achanda@moz-qv7q4n.ca.comcast.net) (Connection closed)
[04:38:14] *** Joins: brianpWins (brianpWins@moz-k8k.f5v.22.185.IP)
[04:38:52] *** Quits: brianpWins (brianpWins@moz-k8k.f5v.22.185.IP) (Client exited)
[05:01:35] *** Joins: achanda (achanda@moz-qv7q4n.ca.comcast.net)
[06:56:02] *** Quits: achanda (achanda@moz-qv7q4n.ca.comcast.net) (Connection closed)
[06:57:03] *** Quits: scott (uid25790@moz-e5ok1n.brockwell.irccloud.com) (Quit: Connection closed for inactivity)
[07:03:17] *** Joins: achanda (achanda@moz-qv7q4n.ca.comcast.net)
[07:16:50] *** Quits: achanda (achanda@moz-qv7q4n.ca.comcast.net) (Connection closed)
[08:01:58] *** Joins: Tobba (Tobba@moz-oecqnu.plus.com)
[08:28:44] *** Quits: barosl (barosl@moz-tmp.qma.67.220.IP) (Quit: Leaving)
[08:47:56] *** Joins: barosl (barosl@moz-tmp.qma.67.220.IP)
[11:37:17] *** Joins: achanda (achanda@moz-qv7q4n.ca.comcast.net)
[11:50:39] *** Quits: achanda (achanda@moz-qv7q4n.ca.comcast.net) (Connection closed)
[12:15:40] *** Joins: achanda (achanda@moz-qv7q4n.ca.comcast.net)
[12:37:10] *** Joins: Tuba (Tobba@moz-oecqnu.plus.com)
[12:37:16] *** Quits: Tuba (Tobba@moz-oecqnu.plus.com) (Connection closed)
[14:18:03] *** Quits: achanda (achanda@moz-qv7q4n.ca.comcast.net) (Connection closed)
[14:49:07] *** Quits: Tobba (Tobba@moz-oecqnu.plus.com) (A TLS packet with unexpected length was received.)
[15:15:32] *** Joins: Tobba (Tobba@moz-oecqnu.plus.com)
[15:23:04] <nmatsakis> aturon: so there is something else I wanted to briefly mention to you
[15:23:17] <nmatsakis> I've been weighing the interesting question of how a closure should be (conceptually, at least) desugared
[15:23:27] <nmatsakis> i.e., what should the struct look like
[15:23:40] <nmatsakis> what the compiler currently does is sort of incoherent, and there are various ICEs etc as a result
[15:24:16] <nmatsakis> what we currently do is something like `struct Closure<'a,'b,X,Y> { upvar1: T_upvar1, }` (for a by-move)
[15:24:25] <nmatsakis> where 'a,'b,X,Y are the parameters in scope from the creating fn
[15:24:37] <nmatsakis> this is sort of incoherent because T_upvar1 may reference other things that are not listed in those parameters
[15:24:48] <nmatsakis> e.g. some region from the surrounding fn
[15:24:57] <nmatsakis> we have some specialized code to make regioncking "sort of" sound
[15:25:08] <nmatsakis> but it's not living up to the promise that closure types should be treated in the compiler "as if" they were a struct
[15:25:13] <nmatsakis> an alternative that I am weighing is
[15:25:22] <nmatsakis> struct Closure<UV1,...> { upvar1: UV1 }
[15:25:39] <nmatsakis> this is all relatively invisible to the user
[15:25:46] <nmatsakis> except for some extreme examples
[15:25:49] <nmatsakis> where people create cycles with closure types
[15:25:58] <nmatsakis> which would be ill-typed under the newer desugaring
[15:26:17] <nmatsakis> this is probably good because it also simplifies the upvar inference (which currently doesn' work well around such cycles anyway)
[15:29:11] <nmatsakis> interestingly this also intersects incr. compilation
[15:29:16] <aturon> nmatsakis: hm, that's very interesting -- potential implications for `impl Trait`
[15:29:26] * nmatsakis ponders
[15:29:29] <aturon> (which i had assumed would worked in the first style)
[15:29:44] <nmatsakis> not obvious to me what those implications are just now
[15:29:55] <aturon> well, so for example,
[15:30:06] <aturon> we wanted it to be the case that you could name the result type as a path,
[15:30:13] <aturon> instantiating all of the variables that would be in scope
[15:30:25] <nmatsakis> yes, that should still be possible I think
[15:30:33] <nmatsakis> but the path would be a kind of type-alias,
[15:30:37] <nmatsakis> which I guess has interactions with HKT etc
[15:30:47] <nmatsakis> i.e., it WOULDN'T be an HKT
[15:30:51] <nmatsakis> now one thing is
[15:30:54] <nmatsakis> move closures could work a bit differently
[15:31:08] <nmatsakis> well not in the general case
[15:31:11] <nmatsakis> but certainly if you return the closure out
[15:31:16] <nmatsakis> it cannot have internal regions and the like
[15:31:22] <nmatsakis> so there ought to be some sort of "wrapper" type
[15:31:24] <nmatsakis> that fits the original scheme
[15:31:31] <aturon> ok, i see
[15:31:59] <aturon> so, a different way of looking at this is that you haven't recorded enough of the parameters 
[15:32:26] <nmatsakis> yes
[15:32:34] <nmatsakis> the reason for the vesion I wrote
[15:32:39] <nmatsakis> is that it's relatively easy to implement
[15:32:43] <nmatsakis> it's not (presumably) what a user would do
[15:32:50] <nmatsakis> which is to filter out a more "minimal" set of parameters
[15:33:02] <nmatsakis> it might be worth thinking that through a bit more because
[15:33:06] <nmatsakis> the same translation is needed
[15:33:08] <nmatsakis> for parameter types etc
[15:33:16] <nmatsakis> e.g., if you have &'x i32 for some 'x within the current fn
[15:33:27] <nmatsakis> you want this to be translated to for<'a> &'a i32 (sort of)
[15:33:39] <nmatsakis> and of course if you have &'x i32 and &'y i32, where both 'x and 'y are in the current fn
[15:33:45] <aturon> (actually, i'm confused about how `struct Closure<UV1,...> { upvar1: UV1 }` could possibly work)
[15:33:55] <nmatsakis> youw ant the same, but with a possible relationship between 'x and 'y
[15:34:03] <nmatsakis> how so?
[15:34:04] <aturon> (ah, you move the details into the impl block for the closure trait?)
[15:34:08] <nmatsakis> the type of the closure basically be
[15:34:14] <nmatsakis> Closure<&'x i32>
[15:34:22] <nmatsakis> if &'x i32 is the type of the variable
[15:34:27] <nmatsakis> and yes
[15:34:30] <nmatsakis> you move it to the impl block
[15:34:35] <nmatsakis> conceptually
[15:34:47] <nmatsakis> I've actually got to run soon for an hour
[15:34:58] <aturon> ok, we can come back to this later
[15:35:07] <aturon> it's often the case that impl blocks are "more expressive"
[15:35:11] <nmatsakis> (yes, just wanted to raise it on the radar)
[15:35:16] <aturon> since we don't fully internalize the possibilities there into the type system
[15:35:20] <nmatsakis> I want to think in particular about the 
[15:35:29] <aturon> e.g. we don't have full HRTBs but you can express them in impl blocks
[15:35:29] <nmatsakis> possibility that I can kill two birds with one stone
[15:35:33] <aturon> ok
[15:35:39] <nmatsakis> in terms of rewriting types like  &'x i32
[15:35:46] <nmatsakis> into/out of parametrization
[15:35:51] <nmatsakis> I sort of 75% worked out a scheme for doing this
[15:35:57] <nmatsakis> but it was a while back and I've forgotten the details
[15:36:01] <nmatsakis> and I know you prob have no ide what i'm talking about
[15:36:09] <nmatsakis> so I'll try to elaborate with some examples :)
[15:36:24] <aturon> my gut feeling is that it *should* be possible to do this following something like the original strategy, but i can see how it might be more complicated or potentially require type system features we can't yet express except at the impl level
[15:36:27] <aturon> haha ok
[15:52:10] *** Joins: Tuba (Tobba@moz-oecqnu.plus.com)
[15:52:10] *** Quits: Tuba (Tobba@moz-oecqnu.plus.com) (Connection closed)
[16:07:48] <aturon> nrc: thanks for the feedback! i'll add some text addressing the points you raised
[16:08:25] <aturon> huon: acrichto: did y'all want to look over the specialization draft before I post it? no pressure -- you can always just read and leave comments on the RFC PR once posted, of course
[16:08:39] <huon> aturon: I had a read of it
[16:08:45] <huon> aturon: no particular comments
[16:08:53] * aturon takes that for r+ ;-)
[16:09:59] <acrichto> aturon: sure!
[16:10:07] <acrichto> aturon: link?
[16:10:33] <aturon> acrichto: https://github.com/aturon/rfcs/blob/impl-specialization/text/0000-impl-specialization.md
[16:10:49] <aturon> i have some improvements in the pipeline but that should be enough to get your initial feedback
[16:11:12] <acrichto> aturon: ok, don't wait up for me to post, but I'll try to get around to it by the end of today
[16:11:27] <aturon> ok, thanks, and no rush
[16:31:14] *** Joins: achanda (achanda@moz-qv7q4n.ca.comcast.net)
[16:44:08] *** Quits: Tobba (Tobba@moz-oecqnu.plus.com) (A TLS packet with unexpected length was received.)
[17:50:54] <acrichto> aturon: I'm not sure if this is explicitly spelled out, but we'll probably have to make `default` a contextual keyword instead of a full-blown keyword
[17:50:56] <acrichto> e.g. Default::default
[17:59:06] <acrichto> aturon: we should chat some more over lunch
[19:09:46] <sfackler> aturon: that looks really good. I think there's a missing "default" before the add_assign impl in the partial impls section btw
[19:16:14] <sfackler> aturon: one other possible way to work around the extend specialization problem would be to allow specialization of parameterized trait methods *in the same impl block*
[19:17:04] <sfackler> i.e. impl Extend for Vec { fn extend<I>(...) where I: IntoIterator { ... } fn extend(&mut self, i: &[T]) { ... } }
[20:17:26] *** Quits: jroesch (sid26078@moz-o13a59.charlton.irccloud.com) (*.net *.split)
[20:17:26] *** Quits: huon (huon@moz-hj272o.8rnv.rggd.6180.2400.IP) (*.net *.split)
[20:17:26] *** Quits: spastorino (sid27384@moz-i6sgse.brockwell.irccloud.com) (*.net *.split)
[20:17:26] *** Quits: frewsxcv (sid86219@moz-dneii9.brockwell.irccloud.com) (*.net *.split)
[20:17:26] *** Quits: aturon (sid379@moz-hhfc8n.0j4i.jtu0.0101.2620.IP) (*.net *.split)
[20:17:26] *** Quits: pkondzior (sid768@moz-nrgp4s.highgate.irccloud.com) (*.net *.split)
[20:17:26] *** Quits: nrc (sid365@moz-3taf2s.0j4i.jtu0.0101.2620.IP) (*.net *.split)
[20:17:26] *** Quits: nmatsakis (sid381@moz-32a8b5.0j4i.jtu0.0101.2620.IP) (*.net *.split)
[20:17:26] *** Quits: pnkfelix (sid344@moz-nnnecs.0j4i.jtu0.0101.2620.IP) (*.net *.split)
[20:17:26] *** Quits: seancorfield (sid45586@moz-lphn72.highgate.irccloud.com) (*.net *.split)
[20:17:40] *** Joins: frewsxcv (sid86219@moz-dneii9.brockwell.irccloud.com)
[20:17:40] *** Joins: seancorfield (sid45586@moz-lphn72.highgate.irccloud.com)
[20:17:40] *** Joins: spastorino (sid27384@moz-i6sgse.brockwell.irccloud.com)
[20:17:40] *** Joins: jroesch (sid26078@moz-o13a59.charlton.irccloud.com)
[20:17:40] *** Joins: nmatsakis (sid381@moz-32a8b5.0j4i.jtu0.0101.2620.IP)
[20:17:40] *** Joins: pnkfelix (sid344@moz-nnnecs.0j4i.jtu0.0101.2620.IP)
[20:17:40] *** Joins: aturon (sid379@moz-hhfc8n.0j4i.jtu0.0101.2620.IP)
[20:17:40] *** Joins: nrc (sid365@moz-3taf2s.0j4i.jtu0.0101.2620.IP)
[20:17:40] *** Joins: huon (huon@moz-hj272o.8rnv.rggd.6180.2400.IP)
[20:17:40] *** Joins: pkondzior (sid768@moz-nrgp4s.highgate.irccloud.com)
[20:25:41] *** Quits: jroesch (sid26078@moz-o13a59.charlton.irccloud.com) (*.net *.split)
[20:25:41] *** Quits: huon (huon@moz-hj272o.8rnv.rggd.6180.2400.IP) (*.net *.split)
[20:25:41] *** Quits: spastorino (sid27384@moz-i6sgse.brockwell.irccloud.com) (*.net *.split)
[20:25:41] *** Quits: frewsxcv (sid86219@moz-dneii9.brockwell.irccloud.com) (*.net *.split)
[20:25:41] *** Quits: aturon (sid379@moz-hhfc8n.0j4i.jtu0.0101.2620.IP) (*.net *.split)
[20:25:41] *** Quits: pkondzior (sid768@moz-nrgp4s.highgate.irccloud.com) (*.net *.split)
[20:25:41] *** Quits: nrc (sid365@moz-3taf2s.0j4i.jtu0.0101.2620.IP) (*.net *.split)
[20:25:41] *** Quits: nmatsakis (sid381@moz-32a8b5.0j4i.jtu0.0101.2620.IP) (*.net *.split)
[20:25:41] *** Quits: pnkfelix (sid344@moz-nnnecs.0j4i.jtu0.0101.2620.IP) (*.net *.split)
[20:25:41] *** Quits: seancorfield (sid45586@moz-lphn72.highgate.irccloud.com) (*.net *.split)
[20:26:07] *** Joins: frewsxcv (sid86219@moz-dneii9.brockwell.irccloud.com)
[20:26:07] *** Joins: seancorfield (sid45586@moz-lphn72.highgate.irccloud.com)
[20:26:07] *** Joins: spastorino (sid27384@moz-i6sgse.brockwell.irccloud.com)
[20:26:07] *** Joins: jroesch (sid26078@moz-o13a59.charlton.irccloud.com)
[20:26:07] *** Joins: nmatsakis (sid381@moz-32a8b5.0j4i.jtu0.0101.2620.IP)
[20:26:07] *** Joins: pnkfelix (sid344@moz-nnnecs.0j4i.jtu0.0101.2620.IP)
[20:26:07] *** Joins: aturon (sid379@moz-hhfc8n.0j4i.jtu0.0101.2620.IP)
[20:26:07] *** Joins: nrc (sid365@moz-3taf2s.0j4i.jtu0.0101.2620.IP)
[20:26:07] *** Joins: huon (huon@moz-hj272o.8rnv.rggd.6180.2400.IP)
[20:26:07] *** Joins: pkondzior (sid768@moz-nrgp4s.highgate.irccloud.com)
[21:08:51] *** Joins: scott (uid25790@moz-e5ok1n.brockwell.irccloud.com)
[21:09:43] *** Joins: Tobba (Tobba@moz-4l45on.skybroadband.com)
[22:01:24] <aturon> RFC posted: https://github.com/rust-lang/rfcs/pull/1210 -- acrichto, sfackler, can you leave your remarks as comments there?
[22:03:01] <acrichto> aturon: will do!
[22:07:35] *** Quits: Tobba (Tobba@moz-4l45on.skybroadband.com) (A TLS packet with unexpected length was received.)
[22:12:07] <sfackler> will do
[22:12:17] <sfackler> I am super excited for specialization
[22:15:36] *** bpugh is now known as bpugh_
[22:15:37] *** bpugh_ is now known as bpugh
[22:17:38] <huon> aturon: exciting!
[22:17:54] <aturon> :D
[22:23:44] <jroesch> aturon: yay, re-reading once more and I'll do a feedback dump as well :)
[22:24:00] <aturon> jroesch: awesome, thanks!
[22:24:18] <jroesch> I'm really excited to see this stuff go live (hopefully sooner then later) 
[22:44:47] <jroesch> aturon: I think we should ideally purpose an implementation related RFC as well (I think nrc was talking about doing this), we will probably want to wait a couple weeks for the full design to shake out though now that I think about it.
[22:45:39] <jroesch> propose* stupid autocorrect 
[23:02:21] <nrc> +1
[23:28:02] <aturon> jroesch: fwiw, the RFC covers the implementation in some detail
[23:28:28] <aturon> (in terms of connecting the abstract specification of specialization to an algorithm based on existing compiler support)
[23:28:47] <jroesch> yeah I think the core is there for sure, just more in terms of internal interfaces, data structures and the like 
[23:29:25] <aturon> ok, gotcha. i'm certainly game for that :)
[23:31:03] <jroesch> cool, I'm writing some comments and put that in there just to record it some place 
[23:31:57] *** Quits: achanda (achanda@moz-qv7q4n.ca.comcast.net) (Connection closed)
[23:32:44] *** Joins: achanda (achanda@moz-qv7q4n.ca.comcast.net)
[23:36:41] *** Quits: achanda (achanda@moz-qv7q4n.ca.comcast.net) (Connection closed)
[23:49:00] *** Joins: achanda (achanda@moz-qv7q4n.ca.comcast.net)

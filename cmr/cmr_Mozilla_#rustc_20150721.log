[00:20:35] *** Joins: aatch (james@moz-i1k1ks.tlms.2o1v.e006.2406.IP)
[00:45:29] *** Quits: brson (brson@moz-cfhap5.mtv2.mozilla.com) (Quit: leaving)
[02:32:37] *** Joins: achanda (achanda@moz-qv7q4n.ca.comcast.net)
[02:42:34] *** Quits: achanda (achanda@moz-qv7q4n.ca.comcast.net) (Connection closed)
[02:47:08] *** Quits: kimundi (kimundi@moz-cd45a7.dip0.t-ipconnect.de) (Ping timeout: 121 seconds)
[02:47:13] *** Joins: c74d3 (c74d3a4ebb6@moz-hhitpj.mggc.hibn.4404.2002.IP)
[02:47:39] *** Joins: achanda (achanda@moz-qv7q4n.ca.comcast.net)
[02:47:47] *** Quits: achanda (achanda@moz-qv7q4n.ca.comcast.net) (Connection closed)
[02:47:52] *** Quits: c74d (c74d3a4ebb6@moz-0ersgu.oc.cox.net) (Ping timeout: 121 seconds)
[02:48:36] *** c74d3 is now known as c74d
[02:49:03] *** Quits: c74d (c74d3a4ebb6@moz-hhitpj.mggc.hibn.4404.2002.IP) (Connection closed)
[02:49:22] *** Joins: kimundi (kimundi@moz-04oaee.dip0.t-ipconnect.de)
[02:49:35] *** Joins: c74d (c74d3a4ebb6@moz-hhitpj.mggc.hibn.4404.2002.IP)
[03:12:22] *** Joins: achanda (achanda@moz-qv7q4n.ca.comcast.net)
[03:15:00] *** Quits: c74d (c74d3a4ebb6@moz-hhitpj.mggc.hibn.4404.2002.IP) (Connection closed)
[03:15:49] *** Joins: c74d (c74d3a4ebb6@moz-hhitpj.mggc.hibn.4404.2002.IP)
[03:18:44] *** Quits: eddyb (eddyb@moz-6s1.6n6.26.188.IP) (Ping timeout: 121 seconds)
[03:24:42] *** Joins: eddyb (eddyb@moz-ic7.82i.25.188.IP)
[03:36:08] *** Joins: bkoropoff (bkoropoff@moz-kthi5c.wa.comcast.net)
[04:51:18] *** Quits: c74d (c74d3a4ebb6@moz-hhitpj.mggc.hibn.4404.2002.IP) (Connection closed)
[04:51:36] *** Joins: c74d (c74d3a4ebb6@moz-hhitpj.mggc.hibn.4404.2002.IP)
[05:19:14] *** Joins: laumann (thomas@moz-n9e72h.0.fullrate.dk)
[05:28:26] *** Quits: bkoropoff (bkoropoff@moz-kthi5c.wa.comcast.net) (Client exited)
[05:33:53] *** Quits: laumann (thomas@moz-n9e72h.0.fullrate.dk) (Ping timeout: 121 seconds)
[05:34:10] *** Quits: aatch (james@moz-i1k1ks.tlms.2o1v.e006.2406.IP) (Quit: Leaving)
[06:28:12] *** Joins: nagisa (nagisa@moz-8t068g.static.zebra.lt)
[06:28:25] *** Joins: c74d3 (c74d3a4ebb6@moz-0ersgu.oc.cox.net)
[06:29:07] *** Quits: c74d (c74d3a4ebb6@moz-hhitpj.mggc.hibn.4404.2002.IP) (Ping timeout: 121 seconds)
[06:29:52] *** c74d3 is now known as c74d
[06:46:17] *** Joins: laumann (thomas@moz-3m6.3kq.109.2.IP)
[08:04:54] *** Quits: achanda (achanda@moz-qv7q4n.ca.comcast.net) (Connection closed)
[08:12:35] *** Quits: nagisa (nagisa@moz-8t068g.static.zebra.lt) (A TLS packet with unexpected length was received.)
[08:20:15] *** Quits: laumann (thomas@moz-3m6.3kq.109.2.IP) (Ping timeout: 121 seconds)
[08:38:30] *** Joins: killercup (killercup@moz-gibg6f.dip0.t-ipconnect.de)
[11:31:48] *** Joins: killercu_ (killercup@moz-gibg6f.dip0.t-ipconnect.de)
[11:34:46] *** Quits: killercup (killercup@moz-gibg6f.dip0.t-ipconnect.de) (Ping timeout: 121 seconds)
[12:45:17] *** Joins: arielby (Mibbit@moz-cmi.jfj.114.192.IP)
[13:44:49] *** Quits: killercu_ (killercup@moz-gibg6f.dip0.t-ipconnect.de) (Quit: Bye)
[14:04:27] *** Quits: arielby (Mibbit@moz-cmi.jfj.114.192.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[14:55:54] *** Joins: achanda (achanda@moz-qv7q4n.ca.comcast.net)
[15:04:23] *** Quits: achanda (achanda@moz-qv7q4n.ca.comcast.net) (Connection closed)
[15:15:18] *** Joins: arielb1 (Ariel@moz-or7vgm.red.bezeqint.net)
[15:22:30] *** Joins: laumann (thomas@moz-3m6.3kq.109.2.IP)
[15:26:52] *** Quits: laumann (thomas@moz-3m6.3kq.109.2.IP) (Ping timeout: 121 seconds)
[15:42:45] *** Joins: brson (brson@moz-cfhap5.mtv2.mozilla.com)
[15:42:45] *** ChanServ sets mode: +qo brson brson
[15:43:55] <eddyb> pnkfelix: thinking more about it, maybe I can isolate the existing snapshotting to the coercions that actually modify/introduce inference variables
[15:46:16] <eddyb> unifying with Box<_> in the expected = Box<Trait> case should be fine, no less than forcing Box<Trait> is
[16:48:27] * doener feels like he's whining whenever acrichto asks for codegen tests...
[16:48:50] <acrichto> lol no worries, if it's hard to add it's not the end of the world
[16:48:55] <acrichto> just nice to have regression tests wherever possible
[16:52:40] <Luqman> doener: up for a review? :D https://github.com/rust-lang/rust/pull/27017
[17:03:52] <eddyb> speaking of codegen, I'm curios if ptr::write(p, create()) optimizes out the copy
[17:07:19] <eddyb> http://is.gd/q112tO so this doesn't optimize nicely
[17:07:51] <eddyb> oh it's missing noalias http://is.gd/H4YrYv
[17:08:29] <eddyb> doener: what would be the best course of action for an API providing raw pointers to a fresh allocation to be used with ptr::write for in-place initialization?
[17:09:35] <eddyb> doener: it looks like LLVM only optimizes the write if the pointer is noalias. should we make `Unique` a lang item and add noalias to its field?
[17:10:15] <eddyb> pnkfelix: ^^ related to perfecting box desugaring. technically we could have an unsafe function returning &mut T to an uninitialized T and ptr::write to that. should optimize perfectly
[17:10:22] <eddyb> but it seems fragile
[17:11:50] <eddyb> I guess I'll use it for now any way
[17:12:20] <pnkfelix> eddyb: In my experience I have to call the intrinsic directly
[17:12:45] <eddyb> look at the IR for my last link above, in Release mode
[17:12:53] <pnkfelix> llvm optimizer will otherwise put value on stack
[17:13:13] <eddyb> I could try the intrinsic with *mut T, I guess. but that doesn't help with the statemenet-less desugaring
[17:13:35] <eddyb> *statement-less
[17:13:40] <pnkfelix> But I will look at what you posted.  Maybe it's due to some other difference between our examples
[17:14:10] <eddyb> https://github.com/eddyb/rust/blob/e46adf899b2f7807607ad9d69975e6f9c131a840/src/test/run-pass/box-protocol-unsized.rs
[17:14:50] <eddyb> this is one recent attempt, with extra Unsize-based impls, you can ignore those
[17:15:14] <eddyb> it's also not a great impl, but good enough to test a few things
[17:16:44] <doener> eddyb: that's not about noalias, but dereferenceable
[17:16:49] <eddyb> oh!
[17:16:58] <eddyb> doener: does it really not care about anything else?
[17:17:28] <doener> eddyb: needs both in fact
[17:17:32] <eddyb> the perfect choice here would be an out-pointer, but we don't have those (and they're hard to design)
[17:17:42] <eddyb> doener: yeah, I'll stick with &mut T, I guess
[17:18:17] <eddyb> oh look gists also changed UI slightly
[17:18:35] <eddyb> ACE is no longer optional
[17:18:41] <arielb1> eddyb: ptr::write must be a copy
[17:18:58] <eddyb> arielb1: unwinding?
[17:19:08] <doener> eddyb: let's just go with pascal-style named return values
[17:19:10] <arielb1> https://github.com/rust-lang/rust/pull/27017
[17:19:15] <arielb1> wrong one
[17:19:17] <arielb1> https://internals.rust-lang.org/t/pre-rfc-become-assignments-for-reliable-rvo-dps/2363/10
[17:20:21] <eddyb> arielb1: LLVM optimizes it out the copy though
[17:20:24] <eddyb> s/it//
[17:20:43] <eddyb> let me remove the nounwind and see what happens
[17:21:05] <arielb1> in the *foo = create(); it can't
[17:21:08] <arielb1> what if create reads foo
[17:21:09] <arielb1> ?
[17:21:16] <eddyb> how could it?
[17:21:20] <eddyb> it's noalias
[17:21:55] <arielb1> noalias?
[17:22:12] <eddyb> &mut T is marked as noalias
[17:22:26] <arielb1> eddyb: with &mut T there is the dtor problem technically
[17:22:35] <arielb1> there isn't a dtor for [usize; 4] through
[17:23:15] <eddyb> arielb1: I am using &mut T with ptr::write
[17:24:02] <arielb1> eddyb: it does work in that case
[17:24:04] <arielb1> for me at least
[17:24:18] <arielb1> of course, only if no dtor is present
[17:24:39] <eddyb> nope :D
[17:24:56] <eddyb> arielb1: http://is.gd/77nYVp
[17:25:13] <eddyb> initialize is still only a call to create
[17:26:00] <arielb1> eddyb: dtor
[17:26:12] <eddyb> on what?
[17:26:13] <arielb1> eddyb: you are breaking the rules
[17:26:24] <arielb1> no uninitialized &mut
[17:26:31] <eddyb> it's never read from
[17:27:10] <eddyb> the &mut comes from a malloc call, having &mut instead of *mut is a cheap way to get noalias + dereferenceable
[17:27:16] <arielb1> eddyb: I am quite sure that &mut must always point to a valid value
[17:27:51] <eddyb> I would use something like Unique, yes, but that's more plumbing to do in trans
[17:28:08] <eddyb> arielb1: well, this might be avoidable if we inline the calls all the way down to the allocator
[17:28:30] <eddyb> and mark the return of that as noalias
[17:28:59] <eddyb> doener: did we ever get noalias on liballoc functions?
[17:29:04] *** Joins: achanda (achanda@moz-m7s4h8.static.monkeybrains.net)
[17:29:24] <eddyb> that doesn't get us dereferenceable though, and you're saying that's needed :/
[17:29:30] <Luqman> eddyb: wasn't there #[allocator]
[17:29:44] <eddyb> Luqman: I just don't recall whether that was ever merged
[17:30:10] <eddyb> https://github.com/rust-lang/rust/blob/master/src/liballoc/heap.rs#L26
[17:30:32] <Luqman> seems so
[17:31:30] <Luqman> eddyb: oh but je_mallocx is marked https://github.com/rust-lang/rust/blob/master/src/liballoc/heap.rs#L218
[17:34:00] <eddyb> oh
[17:34:09] <eddyb> that might do it, I'm not sure
[17:54:50] <doener> wth? https://github.com/rust-lang/rust/blob/master/src/libcore/mem.rs#L249-L254
[17:55:34] <Luqman> ...
[17:56:27] <Elaine> pnkfelix: ^ can you explain that? (I think you made that particular intrinsic)
[17:56:42] <eddyb> doener: cfg(stage0)
[17:56:59] <Luqman> ah, that^
[17:57:01] <eddyb> the indirection wasn't expanded when the attribute and old impl was removed
[17:57:08] <eddyb> at least that's my best guess, could use blame
[17:57:19] <doener> yeah, looks like it
[17:57:38] <doener> though I wonder why the cfg attr wasn't applied to dropped() itself. oh well
[17:59:27] <arielb1> eddyb: do you think using *const Ty<'static> in ADTDef would be too crazy?
[17:59:50] <eddyb> arielb1: to avoid the Option shennanigans for delayed initialization?
[17:59:57] <arielb1> eddyb: for variance
[17:59:59] <eddyb> oh
[18:00:05] <arielb1> I mean, it is within an IVar
[18:00:14] <arielb1> it is essentially IVar<*const Ty<'static>>
[18:00:30] <eddyb> right, because the IVar needs invariance, just like any Cell
[18:00:32] <arielb1> that's TyS<'static> actually
[18:00:35] <arielb1> eddyb: right
[18:01:24] <eddyb> here's a crazy thought :D
[18:01:53] <eddyb> make a custom IVarTy<'write, 'read>
[18:02:03] <arielb1> eddyb: Unsafe is always invariant
[18:02:24] <arielb1> also, 'write would leak to Ty
[18:02:35] <eddyb> IVarTy<'a, 'a> is writable (w/ Ty<'a>), IVarTy<'a, 'b> is...
[18:02:39] <eddyb> arielb1: drat, you're right :(
[18:04:58] <arielb1> eddyb: if UnsafeCell was variant
[18:05:27] <arielb1> I could have intern_adtdef return a special marker
[18:05:59] <eddyb> mutation is annoying to deal with
[18:06:10] <eddyb> arielb1: wait, coming back to IVarTy<'write, 'read>
[18:06:32] <eddyb> arielb1: what if Ty only held IVarTy<'tcx, 't- I'm dumb
[18:07:53] <arielb1> eddyb: I can play this game with ADTDef
[18:08:00] <arielb1> store ADTDef<'ty, 'static> in the tcx
[18:08:08] <eddyb> or that, yeah
[18:08:10] <arielb1> and allow mutability for ADTDef<'tcx, 'tcx> 
[18:08:28] <arielb1> that would be API-safe
[18:08:37] <eddyb> same representation, different capabilities, using only lifetimes as switches
[18:08:54] <arielb1> can't be captured because lack of HKT
[18:09:15] <arielb1> and I still need Unique<TyS<'static>> because of invariance
[18:10:22] <eddyb> I was going to say, I can't think, too much anxiety. just 11 hours until I find out the results of uni admission
[18:11:39] <arielb1> eddyb: we would have to change the ABI rules
[18:11:42] <arielb1> or maybe just clarify them
[18:11:49] <arielb1> transmuting between Foo<'a> and Foo<'b> is alright
[18:11:59] <arielb1> or add covariance
[18:12:53] <arielb1> eddyb: that would in fact work with IVar<'read, 'write, T>
[18:12:57] <arielb1> except for invariance
[18:13:13] <arielb1> and 'write needs to be other-way-variant
[18:13:28] <arielb1> use for reverse-variance found - should tell nmatsakis 
[18:13:58] <eddyb> like PhantomData<fn(&'write T)>?
[18:14:06] <arielb1> eddyb: yes
[18:14:07] *** Quits: brson (brson@moz-cfhap5.mtv2.mozilla.com) (Connection closed)
[18:14:16] <arielb1> its going to be removed
[18:14:26] <eddyb> that's the first time I hear about it
[18:14:29] <arielb1> I can emulate it with transmute
[18:14:38] <eddyb> is that backwards-compatible?
[18:15:02] <arielb1> eddyb: soundness
[18:15:38] <nmatsakis> oh, I don't doubt there are uses for contravariance :) -- but what's the situation in detail?
[18:15:59] <eddyb> it's a hack to deny writing an IVar based on lifetimes
[18:16:01] <nmatsakis> (contravariance in fn sigs, specifically, is what we have to remove, not actually "reverse variance for regions", though that's currently the only way to get that)
[18:16:17] <eddyb> nmatsakis: is it related to the projection issues?
[18:16:35] <nmatsakis> eddyb: no, see https://github.com/rust-lang/rust/issues/25860
[18:17:11] <nmatsakis> I have a write-up somewhere that is perhaps easier to follow
[18:17:44] <eddyb> isn't the fix there "more WF checks"?
[18:18:01] *** Joins: brson (brson@moz-cfhap5.mtv2.mozilla.com)
[18:18:02] *** ChanServ sets mode: +qo brson brson
[18:19:41] <arielb1> nmatsakis: so contravariance is going to be supported?
[18:19:50] <nmatsakis> arielb1: I didn't plan to, no.
[18:19:55] <nmatsakis> I'm just saying we COULD
[18:19:55] <eddyb> nmatsakis: oh, something else, if you have the time: I failed to present the situation clearly and now the discussion is going in circles https://github.com/rust-lang/rfcs/pull/1216
[18:20:05] <nmatsakis> but I'd rather not
[18:20:17] <arielb1> nmatsakis: I can emulate it in this case with unsafe
[18:20:20] <arielb1> so that's fine
[18:20:58] *** Joins: nagisa (nagisa@moz-8t068g.static.zebra.lt)
[18:21:17] <eddyb> nmatsakis: but I'm pretty sure they're reinventing the wheel in a complicated way and without clear rules
[18:22:11] <nmatsakis> eddyb: yes I agree, it's hard to follow the conversation, but it sounds dubious to me
[18:22:19] <arielb1> I mean, struct TyIVar<'tcx, 'bound>(Unique<TyS<'static>>, PhantomData<(TyS<'tcx>, *mut TyS<'bound>)>);
[18:22:27] <nmatsakis> eddyb: I've been avoiding clicking on that RFC ;) I'll try to chime in
[18:23:00] <eddyb> at least they're not pushing for subtyping
[18:23:12] <eddyb> that was not fun
[18:23:29] <arielb1> actually, IVar<Unique<TyS<'static>>>
[18:24:01] <arielb1> and only allow fulfilling TyIVar<'a, 'a>
[18:24:39] <arielb1> and PhantomData should be "fn(Ty<'bound>) -> Ty<'static>"
[18:24:53] <arielb1> "fn(Ty<'bound>) -> Ty<'tcx>"
[18:26:08] <arielb1> nmatsakis: do you think my analysis/desugaring in https://github.com/rust-lang/rust/issues/27086 is correct?
[18:29:11] <nmatsakis> arielb1: not sure, I'll take a look
[18:53:12] *** Joins: laumann (thomas@moz-n9e72h.0.fullrate.dk)
[19:19:49] *** Quits: brson (brson@moz-cfhap5.mtv2.mozilla.com) (Ping timeout: 121 seconds)
[19:51:07] *** Joins: LinuxBunny (Retep998@moz-vlal7g.east.verizon.net)
[19:55:04] *** Quits: WindowsBunny (Peter@moz-vlal7g.east.verizon.net) (Quit: Leaving.)
[20:07:31] *** Joins: brson (brson@moz-cfhap5.mtv2.mozilla.com)
[20:07:31] *** ChanServ sets mode: +qo brson brson
[20:11:47] <nmatsakis> MIR branch... kind of works. http://people.mozilla.org/~nmatsakis/killme.svg 
[20:22:18] <eddyb> nmatsakis: I can read that!
[20:22:27] <eddyb> although there's a lot of noise
[20:22:44] <nmatsakis> it's generating drops unconditionally right now
[20:22:45] <nmatsakis> which doesn't help
[20:22:57] <eddyb> τ₀, τ₁, τ₂, ... might be nicer to see
[20:23:08] <nmatsakis> yeah, I should probably change from using Debug
[20:23:11] <nmatsakis> to using some other trait
[20:23:15] <nmatsakis> since we can emit full HTML
[20:23:17] <nmatsakis> in these graphviz files
[20:23:19] <nmatsakis> well, not full
[20:23:24] <nmatsakis> but I could probably do subscripts
[20:23:40] <nmatsakis> anyway, the branch right now just lets you write
[20:23:40] <eddyb> I used unicode in my disassembler/lifter thing
[20:23:43] <eddyb> worked really well
[20:23:56] <eddyb> also, either prefix binops or use operators
[20:23:56] <nmatsakis> #[rustc_mir(graphviz="foo,dot")] to dump mir manually
[20:24:00] <nmatsakis> there is some unimpl'd stuff
[20:24:02] <eddyb> a Div b looks jarring :D
[20:24:26] <eddyb> nmatsakis: tooling <3
[20:24:29] <nmatsakis> but I'll prob put up a PR soon just to try and get stuff in tree
[20:24:39] <nmatsakis> oh, it's blocked on a bug fix grr
[20:24:40] <nmatsakis> forgot about that
[20:24:47] <eddyb> just being able to see something that's not a mess of LLVM IR
[20:24:48] <nmatsakis> I'll have to open that PR first :)
[20:25:00] <eddyb> it's glorious
[20:25:13] <eddyb> nmatsakis: do you not have constants yet?
[20:25:52] <eddyb> I would expect the first branch to be unconditional. or at least branch on a constant
[20:26:50] <nmatsakis> eddyb: I'm not doing any constant evaluation, I'd expect to do that as a second pass
[20:26:59] <eddyb> constant propagation?
[20:27:05] <nmatsakis> right
[20:27:29] <nmatsakis> we could possibly do it while building the MIR too, I don't have a super strong opinion. I'm just not :)
[20:27:33] <eddyb> but doesn't that mean there's two constant-evaluation passes?
[20:27:52] <nmatsakis> so we should talk over how constants work because the current setup is a mess and i'm not as yet doing anything to make it cleaner :)
[20:27:58] <nmatsakis> but I can't do that right now, I have to leave soon
[20:28:00] <eddyb> one working on the HIR, presumably, and one on the MIR
[20:28:20] <eddyb> nmatsakis: typing constant expressions in array lengths and whatnot, that's the pressing issue IMO
[20:28:27] <nmatsakis> well, I think we should collapse constants into some intermediate IR
[20:28:36] <nmatsakis> that MIR can reference
[20:28:41] <nmatsakis> but also HIR
[20:28:45] <nmatsakis> I'll try to write out what I mean
[20:28:58] <nmatsakis> eddyb: yes, I know, but I think there's other pressing issues too, like the fact that we have two constant evaluators :)
[20:29:01] <nmatsakis> though those are interconnected
[20:29:17] <eddyb> the lack of precise types is screwing us up
[20:29:23] <eddyb> otherwise we could have everything in one place
[20:29:44] <eddyb> + emitting constant ADTs in trans
[20:33:56] <eddyb> I was going to say that this summer is looking pretty good
[20:34:07] <eddyb> but it's almost August already
[20:37:27] <arielb1> nmatsakis: use nicer names for temps
[20:37:52] <arielb1> that could make it clearer
[20:39:05] <arielb1> like $n
[20:40:24] <arielb1> also, literal operators
[20:43:01] <jroesch> nmatsakis: let me know when you start thinking about the constant stuff. I also had some similar thoughts about an IR/abstract machine kind of thing for dealing with constant eval
[20:46:43] <eddyb> I don't see why you would use anything more complicated than an expression tree. but there's probably a few different ways to handle projections, and the HIR would not work for all of them
[20:48:23] <jroesch> my thoughts are just if we begin to move towards more constant evaluation we are going to eventually want to capture more semantics then integer addition, and if you start embedding an ad-hoc interpreter you might as well actually just write an interpreter/abstract machine with fixed semantics and execute on that
[21:07:21] <brson> i've melded together mem::uninitialized for i64/u64/isize/usize
[21:07:28] <brson> my first successful meld
[21:09:13] <eddyb> brson: via mergefunc? or something more high-level?
[21:10:00] <brson> eddyb: more high level
[21:11:04] <eddyb> I'm guessing you handle the uninitialized intrinsic as equivalent for types of the same size
[21:11:16] <eddyb> brson: do you have actual size computation available?
[21:11:41] <eddyb> if you need it, we should move forward with lifting layout computation from trans
[21:12:20] <eddyb> https://github.com/rust-lang/rfcs/pull/1168#issuecomment-117418440
[21:13:55] *** Quits: laumann (thomas@moz-n9e72h.0.fullrate.dk) (Ping timeout: 121 seconds)
[21:16:35] <brson> eddyb: as written, this happens in trans during monomorphization
[21:17:03] <eddyb> ah, you're set then
[21:17:45] <eddyb> (I remember stories of such melding which would go wrong in horrible ways, because the analysis was incomplete)
[21:18:38] <brson> yes it's risky
[21:18:45] <brson> how do you ask if a ty is a fat pointer?
[21:19:02] <eddyb> there is a function with that name
[21:19:08] <eddyb> type_is_fat_pointer IIRC
[21:21:53] <brson> yes indeed
[21:24:52] *** Quits: arielb1 (Ariel@moz-or7vgm.red.bezeqint.net) (Quit: Ex-Chat)
[21:30:46] <jroesch> brson: is it possible to schedule another crater run? doesn't have to be today just tweaked type inference a little bit based on some conversation between nmatsakis and we have a feeling this will resulted in larger breakage. The two SOs were from a cargo regression that acrichto has an open PR for
[21:36:45] <brson> jroesch: yes can you link me the pr again?
[21:37:11] <eddyb> doener: this is pretty inefficient https://github.com/rust-lang/rust/blob/master/src/libcore/raw.rs#L157
[21:37:56] <eddyb> doener: however... if you cast &&str to &Slice<u8>, for example, and read the length field, it's much cleaner
[21:38:29] <eddyb> one alloca and a trivially elidable load, instead of 3 allocas and memcpy's, IIRC
[21:39:28] <eddyb> doener: besides, we need to account for fat pointers of varying sizes, so we should stop assuming things
[21:40:07] <eddyb> for slices you have (*T, [usize; N]) where N is the number of dimensions, more or less
[21:41:45] <eddyb> I think you can already construct (usize, (usize, (usize,))) from [[[T]]] with a trait impl (except for the fact that [[[T]]] doesn't work atm)
[21:49:36] <brson> jroesch: ok, building compilers now
[21:49:52] <jroesch> brson: err I have secondary branch I want you to build, hold on
[21:50:05] <brson> jroesch: oh, not the main pr at all?
[21:50:26] <jroesch> yeah, I branched to keep the histories distinct 
[21:51:01] <jroesch> It was having trouble with a line of code in the stdlib, probably need a little longer before its ready just wanted to give you the heads up
[21:51:27] <brson> ok, just tell me when
[21:53:15] <doener> eddyb: mmmh
[21:54:50] <eddyb> doener: copying around Slice<T> on the stack is pointless
[21:55:10] <eddyb> doener: especially when you could use e.g. &mut Slice<T> to change the length
[21:55:24] <doener> eddyb: yeah, same as the ref_fat_ptr from yesterday, basically
[21:55:28] <eddyb> heh
[21:59:03] <brson> pnkfelix: to bail out of function melding i need to figure out if any instantiated type parameters need to be dropped and whether a given generic function actually destroys a value of that type. how do?
[21:59:27] <brson> pnkfelix: i guess most importantly, how do i get all the drops in a function?
[22:00:06] <pnkfelix> brson:I'm about to hit the sack
[22:00:09] <eddyb> by iterating the MIR and looking at the DROP operations, ofc :P
[22:00:19] <pnkfelix> brson: its not an easy thing to do right now
[22:00:41] <pnkfelix> brson: but
[22:00:55] <brson> hm, maybe i can just bail any time a type param implements drop
[22:00:58] <brson> conservatively
[22:01:34] <pnkfelix> brson: at what phase are you doing this analysis?
[22:02:25] <brson> pnkfelix: during monomorphization
[22:03:54] <pnkfelix> brson: yeah for right now i don't have a better suggestion; the fragments computation does actually provide much of this info, I think (or at least it would be something easier to then traverse)
[22:04:20] <pnkfelix> brson: but its not currently exposed in a way that I think you'll be able to directly use
[22:05:07] <brson> ok
[22:06:29] <pnkfelix> brson: for example PR gh26173 does expose some of the fragments computation in fields that are carried in the tcx
[22:08:24] <pnkfelix> brson:  but even there, I'm not 100% if that will give you the data you're looking for.  E.g. much of that infrastructure is focused on "identify the paths to data that is moved on one branch but not moved on the other"
[22:09:01] <pnkfelix> brson: while it sounds like you just want "give me the list of every type" (or every "path to data" ?  not sure from your description) that could end up being dropped.
[22:10:15] <pnkfelix> brson: Having said that, if there's some change I can make to this data structure that would improve the precision of your analysis, then I should look into doing that.
[22:10:28] <pnkfelix> brson: but for the short term, yeah, for now just bail whenever a type param impl Drop
[22:16:10] <jroesch> eddyb: you are on board with removing builtinbounds? I kind of want to just axe the struct, I have this old enumset PR lying around
[22:16:22] <jroesch> and people want to just use bitflags instead
[22:16:39] <eddyb> jroesch: I told you using a vector or something would be better
[22:16:48] <eddyb> instead of screwing around with bit collections
[22:16:48] <jroesch> yeah I haven't worked on it since then
[22:17:14] <eddyb> although those are easier to write than to refactor all places in rustc that touch the respective data
[22:17:31] <jroesch> yeah, but it feels like it might just be worth doing as a background task
[22:23:50] <brson> ok, i have more trans qs
[22:24:30] <brson> during monomorphization i want to recursively do some analysis of a callee. how do i get the appropriate new type substitutions for the callee?
[22:24:36] <brson> here's the line i have to fill out https://github.com/brson/rust/blob/meld/src/librustc_trans/trans/meld.rs#L259
[22:25:28] *** Joins: barosl_ (barosl@moz-tmp.qma.67.220.IP)
[22:26:28] <eddyb> brson: https://github.com/rust-lang/rust/blob/master/src/librustc_trans/trans/common.rs#L1017
[22:26:34] *** Quits: barosl (barosl@moz-tmp.qma.67.220.IP) (Ping timeout: 121 seconds)
[22:26:36] <eddyb> brson: or just call that function directly
[22:27:16] <brson> thanks
[23:25:00] *** Quits: nagisa (nagisa@moz-8t068g.static.zebra.lt) (Ping timeout: 121 seconds)
[23:28:05] *** Quits: barosl_ (barosl@moz-tmp.qma.67.220.IP) (Ping timeout: 121 seconds)
[23:29:05] *** Joins: barosl (barosl@moz-tmp.qma.67.220.IP)

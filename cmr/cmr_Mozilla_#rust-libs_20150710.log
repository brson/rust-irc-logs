[00:05:46] *** Quits: nagisa (nagisa@moz-8t068g.static.zebra.lt) (Ping timeout: 121 seconds)
[01:32:48] *** Quits: Rym (uid91135@moz-n2i7qm.charlton.irccloud.com) (Quit: Connection closed for inactivity)
[01:33:34] *** Quits: ChrisMorgan (ChrisMorgan@moz-g6osuq.tpgi.com.au) (Ping timeout: 121 seconds)
[01:56:22] *** Quits: bluss (bluss@moz-ec5o68.cust.bredbandsbolaget.se) (Ping timeout: 121 seconds)
[02:09:08] *** Quits: brson (brson@moz-cfhap5.mtv2.mozilla.com) (Quit: leaving)
[02:15:52] *** Quits: kimundi (kimundi@moz-mgf8eg.hrr4.28s0.57bc.2002.IP) (Ping timeout: 121 seconds)
[02:20:55] *** Joins: kimundi (kimundi@moz-l9v88u.dtlu.8ps3.57bc.2002.IP)
[02:22:52] *** Joins: achanda (achanda@moz-qv7q4n.ca.comcast.net)
[02:42:30] *** Quits: achanda (achanda@moz-qv7q4n.ca.comcast.net) (Connection closed)
[04:19:54] *** Joins: achanda (achanda@moz-qv7q4n.ca.comcast.net)
[04:53:19] <Gankro> I just spent way too long doing extreme mental gymnastics to eliminate branches in Vec allocation code
[04:59:54] <Gankro> I have platform-specific cfgs
[05:00:37] <huon> ?
[05:05:06] <huon> Gankro: oh, target_pointer_width?
[05:05:16] <Gankro> huon: yep
[05:05:37] <Gankro> #NoRegrets
[06:11:19] *** Quits: achanda (achanda@moz-qv7q4n.ca.comcast.net) (Connection closed)
[08:00:43] *** Joins: bluss (bluss@moz-ec5o68.cust.bredbandsbolaget.se)
[08:58:56] <SimonSapin> Gankro: Iâ€™m curious what this looks like, is it up yet?
[10:13:04] *** Quits: stl (stl@moz-stg.7dk.15.176.IP) (Ping timeout: 121 seconds)
[10:19:43] *** Joins: ChrisMorgan (ChrisMorgan@moz-g2hg6v.tpgi.com.au)
[10:20:33] *** Joins: stl (stl@moz-stg.7dk.15.176.IP)
[10:56:46] *** Joins: nagisa (nagisa@moz-8t068g.static.zebra.lt)
[11:34:50] *** Joins: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua)
[12:58:12] *** Quits: ChrisMorgan (ChrisMorgan@moz-g2hg6v.tpgi.com.au) (Ping timeout: 121 seconds)
[13:27:09] *** Quits: nagisa (nagisa@moz-8t068g.static.zebra.lt) (Ping timeout: 121 seconds)
[13:32:31] *** Joins: nagisa (nagisa@moz-8t068g.static.zebra.lt)
[13:41:29] *** Quits: blank_name (blank_name@moz-b62.iv2.183.192.IP) (Ping timeout: 121 seconds)
[13:45:34] <bluss> burntsushi: ok, with current nightly the quickcheck ICE is gone again, that's good
[13:55:44] *** Joins: quantheory (quantheory@moz-pjo3s1.36gq.r6rv.0280.2601.IP)
[14:13:03] *** Joins: brson (brson@moz-bjsp1u.tmodns.net)
[14:13:03] *** ChanServ sets mode: +qo brson brson
[14:15:54] *** Quits: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua) (Ping timeout: 121 seconds)
[14:20:58] *** Quits: barosl_ (barosl@moz-tmp.qma.67.220.IP) (Quit: Leaving)
[14:22:11] *** Quits: nagisa (nagisa@moz-8t068g.static.zebra.lt) (Ping timeout: 121 seconds)
[14:38:58] *** Joins: nagisa (nagisa@moz-8t068g.static.zebra.lt)
[14:59:15] *** Quits: nagisa (nagisa@moz-8t068g.static.zebra.lt) (Connection closed)
[15:30:14] <Gankro> SimonSapin: Still need a bit of work, and I want to port VecDeque as well and do some benches to make sure I didn't screw up someone's delicate optimization
[15:53:53] *** Joins: achanda (achanda@moz-qv7q4n.ca.comcast.net)
[16:26:46] *** Joins: nagisa (nagisa@moz-8t068g.static.zebra.lt)
[16:34:12] <brson> Gankro: what are you porting VecDeque to?
[16:34:52] <Gankro> brson: https://github.com/rust-lang/rust/compare/master...Gankro:raw-vec?expand=1
[16:35:03] <Gankro> moving allocation logic from libcollection up into liballoc
[16:36:18] <Gankro> (details still being hashed out)
[16:36:30] <huon> hah
[16:36:54] <bluss> that's great
[16:41:38] <Gankro> Also accidentally some stuff about cloning boxed slices falls out
[16:42:04] <bluss> yes it's the best solution for that
[16:50:53] <Gankro> lol
[16:51:13] <Gankro> let new_len = self.len() + additional;
[16:51:13] <Gankro>         assert!(new_len + 1 > self.len(), "capacity overflow");
[16:51:18] <Gankro> thanks overflow checks
[16:51:23] <Gankro> You're doing a great job
[16:51:45] <bluss> weird
[16:59:54] *** Joins: blank_name (blank_name@moz-ttfeua.mi.frontiernet.net)
[17:00:35] <bluss> oh that's an "after the fact" overflow check. I guess it's legal.. unlike in some other languages
[17:15:43] <bluss> Gankro: I think overflow in allocation size calculation should oom. Trying to allocate !0 bytes will oom, so why should it panic if I try to allocate more than that?
[17:16:06] <Gankro> bluss: IMO panicking is more neighbourly
[17:16:36] <bluss> playbot: Vec::<u8>::with_capacity(!0)
[17:16:38] -playbot- playpen: application terminated abnormally with signal 4 (Illegal instruction)
[17:16:41] <bluss> playbot: Vec::<u16>::with_capacity(!0)
[17:16:43] -playbot- thread '<main>' panicked at 'capacity overflow', /home/rustbuild/src/rust-buildbot/slave/stable-dist-rustc-linux/build/src/libcore/option.rs:330
[17:16:43] -playbot- playpen: application terminated with error code 101
[17:16:45] <Gankro> bluss: agreed
[17:17:24] <Gankro> Asking for catastrophic amount of memory (that we can notice incidentally) is usually a logic error. It's better to tear down the thread than take down the whole application, no?
[17:17:51] <bluss> sure panic is nicer
[17:18:28] <bluss> but I'm not sure it's worth it
[17:18:37] <Gankro> what do you mean "worth it"?
[17:18:53] <bluss> code size for panic
[17:19:54] <Gankro> That's only binary size; no runtime impact, right?
[17:20:13] <bluss> maybe not
[17:21:45] <Gankro> Oh?
[17:22:30] <bluss> surely it must have some cost with the overflow branches to panic in different places
[17:22:50] <Gankro> Those branches would need to be there if we aborted too
[17:23:05] <bluss> they can all jump to the oom place
[17:23:25] <Gankro> cc acrichto ^
[17:24:19] <Gankro> argh why does Box<[T]> not have slice methods in liballoc :S
[17:25:08] <bluss> Gankro: can you get the SliceExt trait? that should do it I hope
[17:25:23] * Gankro thought all of that was killed for inherent impls
[17:25:34] <bluss> it's there for libcore consumers
[17:26:04] <huon> can't have inherent methods on primitive types in more than two crates
[17:29:40] <SimonSapin> two, not one?
[17:31:41] <huon> whoops, I merged "two or more" and "more than one"...
[17:32:45] <bluss> Can't be more than a single impl block either 
[17:36:02] <Gankro> reem: Shit, implementing Clone for Box<[T]> is a bit of a breaking change
[17:36:37] <bluss> I think it fits under minor change
[17:36:52] <huon> Gankro: in what way?
[17:36:55] <huon> oh, &[T]
[17:38:09] <Gankro> changes the return value of .to_owned
[17:38:17] <Gankro> Before it was Vec, now it's Box
[17:38:29] <bluss> that sounds worse
[17:38:42] <bluss> doesn't the ToOwned trait guide this?
[17:38:46] <huon> oh, argh
[17:39:11] <bluss> Guide it to Vec
[17:39:19] <Gankro> bluss: I'm not sure what you mean
[17:39:21] <huon> work around is `(*box_slice).to_owned()`?
[17:39:35] <huon> (i.e. from box_slice.to_owned())
[17:39:43] <bluss> Gankro: ok I see what you mean now
[17:40:15] <Gankro> Oh actually this isn't this bad
[17:40:25] <Gankro> It's only on Box<[T]> itself
[17:41:00] <Gankro> The only breakage in std seems to be self.inner.to_owned().into_boxed_slice()
[17:41:05] <Gankro> So... yay that's shorter now!
[17:41:29] <bluss> Gankro: I guess you will add clone to Box<str> too?
[17:41:54] <Gankro> bluss: that would make sense, yes
[17:43:09] <Gankro> ok sweet. Vec and VecDeque both ported
[17:43:17] <Gankro> Now to do some benchmarking
[17:43:41] <Gankro> They should both be a bit faster for push/insert because there's a fast-path for that now
[17:44:25] <Gankro> Since RawVec knows it has less than isize::MAX bytes allocated it can blindly double its capacity (and only check for exceeding isize::MAX on 32-bit)
[17:45:46] <huon> doesn't LLVm'
[17:46:02] <huon> s smarts multiple multiplications can be collapsed to one on 64-bit?
[17:46:12] <huon> wait... we do allocations and stuff. nvm.
[17:59:27] <bluss> Gankro: this is the bench I used for vec![x; N] if you want  https://gist.github.com/bluss/846954bb009803833143
[17:59:48] <Gankro> bluss: not in the repo?
[18:00:06] <bluss> don't think so
[18:00:22] <Gankro> kk
[18:02:04] <Gankro> Wait
[18:02:11] <Gankro> I probably shouldn't run benches while making rustc
[18:02:15] <Gankro> probably
[18:03:33] <Gankro> actually let's do it for funsies
[18:07:46] <Gankro> bluss: the variance is too high to get a decent measurement :/
[18:08:48] <bluss> not a big surprise
[18:08:59] <bluss> Gankro: you could do the before benchmarks during build
[18:09:20] <bluss> just to spice up the numbers, right
[18:09:24] <Gankro> haha
[18:52:06] <bluss> Gankro: can I comment on your branch? I'm excited for it
[18:52:30] <bluss> Gankro: Your Box<[T]> is taking a shortcut we can't :) T is Clone, not Copy
[18:52:57] <Gankro> bluss: I don't follow
[18:53:00] <Gankro> Oh shit
[18:53:02] <Gankro> duh
[18:53:03] <Gankro> yes
[18:53:08] <Gankro> I am dumb
[18:53:17] <bluss> Gankro: you're an optimist
[18:53:21] <Gankro> bluss: But yeah feel free
[18:53:41] <bluss> Gankro: like the clone for Box<[T]> issue says, all three of ptr, cap, len are needed for a panic safe box builder
[18:53:59] <bluss> Gankro: your branch is a useful unification for clone for box anyway
[18:54:27] <Gankro> I'm debugging a panic with ZSTs right now
[18:58:05] <Gankro> Hmm this is an annoying problem
[18:58:49] <Gankro> You want to be able to round-trip a Box<[()]> through RawVec but it wants to force empty allocations to be maximal
[19:00:18] <Gankro> This might be a nail-in-the-coffin problem
[19:00:58] <bluss> be maximal?
[19:01:04] <bluss> what do you mean?
[19:01:24] <Gankro> bluss: I force cap to usize::MAX on ZSTs so that ZST-handling code falls naturally out of capacity management
[19:02:15] <bluss> right
[19:02:33] <Gankro> But that means you can't just do raw_vec.shrink_to_fit(len); raw_vec.into_box()
[19:02:33] <bluss> Gankro: so you need to special case for ZST in a couple of more places?
[19:02:55] <Gankro> Yeah
[19:03:06] <Gankro> I'm just not sure where the right place to require that is
[19:03:36] <Gankro> Probably easiest to just force it on consumers...
[19:03:52] <Gankro> Since "I have all the capacity" is in fact semantically correct
[19:09:41] <bluss> hm ok
[19:15:55] *** Quits: achanda (achanda@moz-qv7q4n.ca.comcast.net) (Ping timeout: 121 seconds)
[19:30:19] <SimonSapin> I get doing all this for correctness, but is Vec<ZeroSized> useful at all?
[20:02:01] *** Joins: brson_ (brson@moz-bro.mg6.56.172.IP)
[20:04:39] *** Quits: brson (brson@moz-bjsp1u.tmodns.net) (Ping timeout: 121 seconds)
[20:05:10] <bluss> say  struct Graph<N, E> { n: Vec<N>, e: Vec<E> }  it's useful so that special cases (that may be common cases) like Graph<(), i32> don't blow up
[20:05:41] <bluss> maybe that doesn't make sense on its own
[20:06:07] <bluss> it's useful when you can just compose pieces together and then you set one of the parameters to () and it still just works
[20:06:21] <Gankro> SimonSapin: Yeah basically it just falls out of generics and you want them to be handled. I'm not necessarily optimizing for them to be the fastest. Just that users don't need to think about them.
[20:09:44] <Gankro> ... Ok I might actually be able to make this work
[20:10:33] <Gankro> I can store a normal value in the `cap` field and just have the cap() method have the branch for ZST
[20:11:42] <bluss> Gankro: any good benchmark results?
[20:11:54] <Gankro> bluss: Still dealing with bugs
[20:12:05] <Gankro> (just got back from lunch)
[20:12:07] <bluss> aha
[20:12:53] <Gankro> Hmm
[20:13:24] <Gankro> I need to resist the need to optimize the repr of RawVec instead to only be one usize when T's size is 0
[20:13:37] <Gankro> That's really probably not worth it.
[20:15:09] <bluss> I think you can skip that for the first version
[20:18:43] <Gankro> It's technically a trade-off: either I can preserve ZST lens or optimize the REPR
[20:18:51] <Gankro> You can't do both
[20:23:20] <bluss> lens? sorry
[20:23:35] <bluss> oh length
[20:24:57] *** Joins: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua)
[20:26:09] <Gankro> ah, yeah
[20:42:36] <Gankro> bluuuh I need to make a stupid panic guard to do this exception safe
[20:42:56] * Gankro looks at reem's PR in earnest for the first time just now and sees he did exactly that
[20:43:33] *** Joins: achanda (achanda@moz-qv7q4n.ca.comcast.net)
[20:43:43] <reem> Even wrote a test for it
[20:45:08] <Gankro> reem: probably easiest to land what you have now and for me to rebase on top of you
[20:45:18] * Gankro shakes fist and unwinding
[20:45:33] <Gankro> That copy_nonoverlapping was so clean ;_;
[20:46:38] <Gankro> Or delay yours long enough so that you can rebase on me.........
[20:47:17] <Gankro> reem: I assume this is mostly you dicking around with your day of being blocked on the nightly; this isn't something you need ASAP?
[20:48:01] <reem> I was just inspired to do some rust libs work
[20:48:03] <reem> Not urgent
[20:49:15] <bluss> Gankro: yeah your Clone was really nice, it just forgot to actually call clone()..
[20:49:22] <bluss> :-P
[20:49:27] <Gankro> So Elegant
[20:49:35] <reem> Damn zero sized types
[20:49:36] <bluss> all the world is just bits
[20:49:53] <Gankro> reem: This is why I'm writing RawVec. It's a fucking nightmare
[20:50:42] <bluss> Gankro: do you have any quick info on what vecdeque does with its 1 unit of extra capacity?
[20:51:06] <Gankro> bluss: it's to differentiate between "full" and "empty"
[20:51:16] <Gankro> Without the padding value they would be indistinguishable
[20:51:34] <reem> Gankro: RawVec is Membuf + len?
[20:51:59] <reem> Curious what the middle ground is between that and just Vec
[20:52:02] <bluss> Gankro: I gave it a try to turn it into zero allocation when empty, but that thing made it difficult
[20:52:04] <Gankro> reem: Membuf very precisely engineered so all of your code is perfectly uniform for all T
[20:52:15] <bluss> Gankro: and thank you, my dealer of quick info
[20:52:28] <reem> Membuf handles this iirc
[20:52:45] <Gankro> reem: I would be super surprised
[20:52:49] <reem> Yup, just handled it at the allocation layer
[20:53:02] <reem> It does work with ZST
[20:53:33] <Gankro> reem: If I were to write Vec on top of memBuf, would I ever have to check if T has zero-size?
[20:53:46] <Gankro> esp. for checking if my len will overflow
[20:54:11] <reem> Membuf is just ptr, cap
[20:54:16] <Gankro> Yes
[20:54:23] <reem> ptr == 1 for ZST
[20:54:29] <Gankro> RawVec will handle your len overflows
[20:54:30] <reem> cap is 0
[20:54:55] <reem> It has a ken
[20:54:57] <reem> Len*
[20:55:00] <Gankro> no
[20:55:22] <Gankro> When you reserve you tell it how much you have and how much more you need. And it does all the math.
[20:55:39] <Gankro> You can also roundtrip a Box<[T]> through it without losing the len
[20:56:01] <Gankro> Or convert your Vec to a Box<[T]> uniformly with shrink_to_fit
[20:56:23] <Gankro> Vec is so clean now
[20:57:01] <Gankro> It also handles isize::MAX overflow on 32-bit platforms
[20:57:28] <Gankro> Nobody Knows The Corner Cases I've Seen
[21:02:08] <Gankro> acrichto: Are any of our builders 32-bit with PAE?
[21:06:06] <acrichto> Gankro: I don't think so
[21:06:09] <acrichto> mostly b/c I don't know what PAE
[21:06:11] <acrichto> is
[21:06:15] <acrichto> other than something address extensions
[21:06:21] <acrichto> which unless it's on by defualt no one has enabled
[21:06:25] <acrichto> words
[21:06:35] <Gankro> acrichto: Do we test x32 at all?
[21:06:48] <acrichto> Gankro: hm, what do you mean by x32?
[21:07:14] <Gankro> acrichto: https://en.wikipedia.org/wiki/X32_ABI
[21:08:08] <acrichto> Gankro: ah in that case I believe the answer is no
[21:08:16] <Gankro> hmm
[21:08:20] <acrichto> not sure if we even have that as a target
[21:08:31] <Gankro> *shrug*, this code will go untested
[21:08:45] <acrichto> Gankro: our codebase has 100% coverage
[21:08:47] <acrichto> unacceptable
[21:08:56] <Gankro> The code is covered
[21:09:02] <acrichto> r+
[21:09:19] <Gankro> Just no machine will ever actually test this branch
[21:09:37] <acrichto> r-
[21:11:41] <bluss> Gankro: I remember strcat's suggestion to just return null in the allocator for > isize::MAX
[21:11:51] <bluss> Gankro: jemalloc maintainers declined
[21:12:07] <Gankro> bluss: It's also a janky strategy because we want to support other allocators
[21:12:13] <Gankro> or just... other version of jemalloc even
[21:13:00] <bluss> true. It's a recurring issue though, not just in vec
[21:13:13] <Gankro> That's why RawVec Solves All Our Problems :)
[21:13:21] <Gankro> It's only actually an issue in Vec
[21:13:26] <Gankro> HashMap can't trigger it
[21:13:34] <Gankro> VecDeque can't trigger it
[21:13:46] <Gankro> Everyone else builds on Vec
[21:13:57] <Gankro> Or uses smaller allocation chunks
[21:14:05] <Gankro> (Box<Node>)
[21:14:35] *** Quits: achanda (achanda@moz-qv7q4n.ca.comcast.net) (Ping timeout: 121 seconds)
[21:15:13] <Gankro> recall that the specific exploit is: sucessfully allocate >int::MAX byte-sized objects 
[21:15:19] <Gankro> 64-bit: can't happen
[21:15:36] <Gankro> HashMap on 32-bit: hashes are 64-bit
[21:16:10] <Gankro> Oh wait, I'm off by one. VecDeque can trigger it
[21:16:17] <Gankro> because isize::MAX isn't a power of two
[21:16:28] <Gankro> Well good thing it uses RawVec :P
[21:17:09] <Gankro> Box<[T]> can't trigger it if all uses go through RawVec
[21:20:10] <bluss> memmap or such interfaces must also not offer bigger slices than that
[21:20:26] <bluss> also only relevant on 32-bit I guess
[21:20:46] <eternaleye> acrichto: PAE is "Physical Address Extensions" - it allows the kernel to access up to 64GB of address space. Though each userspace process can only access 4GB.
[21:21:11] <acrichto> ah yeah I knew I'd heard of that before
[21:21:48] <Gankro> acrichto: basically makes it plausible to acquire > int::MAX in one allocation
[21:22:37] <eternaleye> Gankro: Well, 64-bit can as well...
[21:22:48] <Gankro> eternaleye: ??
[21:22:55] <eternaleye> Gankro: Linux is LP64
[21:23:00] <eternaleye> Gankro: 'int' is still i32
[21:23:10] <Gankro> I said isize, not int
[21:23:19] <eternaleye> Gankro: Oh, no, you originally said isize, it's just int on the most recent
[21:23:31] <eternaleye> Gankro: >> acquire > int::MAX in one allocation
[21:23:33] <Gankro> oh lol
[21:23:34] <bluss> we need to upgrade Gankro to Rust 1.0
[21:23:43] * Gankro will never forget
[21:23:50] <bluss> or circa Rust 1.0-alpha?
[21:23:59] <bluss> the crazy times
[21:24:21] <Gankro> I came to Rustlang for tildes and you idiots removed it all before I even got here!!!
[21:24:33] <eternaleye> I'm still vaguely sad 'protocols' died :P
[21:24:41] <eternaleye> Yeah, I actually liked the tildes
[21:24:48] <eternaleye> But library types are cool too
[21:24:52] <bluss> yeah I didn't want to get rid of the tildes
[21:24:58] <Gankro> ~[T] sounded pretty janky
[21:25:18] <reem> I arrived right around when ~[T] was shifted to Vec<T> and there was much confusion
[21:25:34] <reem> much much confusion
[21:26:09] *** Joins: achanda (achanda@moz-qv7q4n.ca.comcast.net)
[21:26:09] <Gankro> they were literally the same, right?
[21:26:25] <bluss> hm first ~[T] was a single pointer
[21:26:40] <bluss> not sure if it was changed to the three word representation, or if that came with Vec
[21:27:21] <Gankro> I meant more so that it was better thana box
[21:28:41] <Gankro> But yeah I'd forgotten about ~[T] pointing to (len, cap, T, T, T, T)
[21:29:14] <bluss> and pointing to something like  (unused, gc, header, len, cap, etc)
[21:29:37] <Gankro> lol wut
[21:30:22] <bluss> https://github.com/rust-lang/rust/pull/11535
[21:31:53] <Gankro> Man, Rust was cray
[21:32:00] <bluss> oh this was first https://github.com/rust-lang/rust/pull/7816
[21:32:53] <bluss> rust was crazy
[21:35:32] <Gankro> hm... I feel like I'm causing an infinite loop in a runpass test now...
[21:36:17] <bluss> surely ZST related
[21:39:36] <Gankro> let _: Box<Iterator<Item = _>> = Box::new(vec![NonOrd].into_iter()); is pegging my CPU :S
[21:39:45] <Gankro> Where NonOrd is ZST
[21:40:41] <bluss> so is from_elem broken or IntoIter?
[21:41:16] <Gankro> Maybe it's the macro itself
[21:41:17] <bluss> Gankro: if we aborted on capacity overflow, then &[(); !0];  wouldn't be an ICE, instead just an oom
[21:41:27] <bluss> Gankro: now we've got an ICE on our hands
[21:41:37] <bluss> :)
[21:41:58] <Gankro> bluss: That's honestly probably better than looking like we segfaulted :P
[21:42:17] <bluss> yeah that's at  &[(); 1 << 32];
[21:42:53] <Gankro> Also does that capacity overflow?
[21:43:00] <bluss> core dump
[21:43:06] <bluss> or whatever
[21:43:08] <Gankro> No the first example
[21:43:09] <Gankro> !0
[21:43:16] <Gankro> Surely that works
[21:43:17] <bluss> capacity overflow yes
[21:43:26] <Gankro> ..why?
[21:43:56] <bluss> I'll have to debug it now
[21:44:11] <Gankro> I don't understand the vec macro
[21:44:44] <Gankro> Why does it recursively call itself
[21:45:39] <bluss> Gankro: probably just to cover the trailing comma case
[21:45:46] <bluss> yeah
[21:46:13] <Gankro> I didn't realize that was a thing in macros
[21:46:15] <Gankro> to worry about
[21:46:22] <bluss> I've done it
[21:46:23] <Gankro> I suppose it makes sense
[21:50:11] *** Quits: achanda (achanda@moz-qv7q4n.ca.comcast.net) (Ping timeout: 121 seconds)
[21:54:08] *** Joins: achanda (achanda@moz-qv7q4n.ca.comcast.net)
[22:02:31] <bluss> Gankro: ok trans simply makes a vec![const_expr; n]  for a  [const_expr; n] in a constant expression
[22:02:35] <bluss> like a static or so
[22:03:04] <bluss> and the const_expr description value is not zero size
[22:05:48] <Gankro> Shit I've clearly messed up no_drop_flag logic
[22:06:29] <Gankro> Even if I mem::forget it locks up because it's all "I gots to drop ya"
[22:08:53] *** Quits: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua) (Ping timeout: 121 seconds)
[22:10:38] <Gankro> lmao I'm so stupid
[22:11:45] <Gankro> self.buf.cap() != mem::POST_DROP_USIZE
[22:12:03] <Gankro> good thing I definitely *didn't* just hardcode that to usize::MAX for ZSTs
[22:12:29] <Gankro> Casually just count to 2^64 several times per ZST vec
[22:15:24] <bluss> ah so it's  not infinite after all
[22:15:28] <bluss> then you're fine
[22:15:34] <Gankro> Constant Time even
[22:15:48] <bluss> it's in spec
[22:16:01] <Gankro> I think this is my favourite comment now
[22:16:27] <Gankro> NOTE: this is currently abusing the fact that ZSTs can't impl Drop. Or rather, that impl'ing Drop makes them not zero-sized. This is OK because exactly when this stops being a valid assumption, we don't need unsafe_no_drop_flag shenanigans anymore.
[22:17:20] <bluss> I think you're just saying that ZSTs don't impl Drop
[22:18:10] <Gankro> I just like that this is a self-resolving hack
[22:57:43] *** Joins: ChrisMorgan (ChrisMorgan@moz-g2hg6v.tpgi.com.au)
[23:39:40] <Gankro> bluss: https://github.com/rust-lang/rust/pull/26955
[23:54:28] <SimonSapin> Gankro: can I haz a copy of RawVec on crates.io? Seems more solid than whatever SmallVec does at the moment
[23:55:16] <Gankro> SimonSapin: it obvi has to be unstable; I'd like to just expose it in std if possible.

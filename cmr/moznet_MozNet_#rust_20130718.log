[00:00:12] <cmr> graydon: also obnoxious: you can't have inter-crate `pub mod` without exposing those mods outside of the crate as well
[00:00:27] <graydon> cmr: intra-crate you mean?
[00:00:30] <strcat>         // Generate code that, dynamically, indexes into the
[00:00:32] <strcat>         // tydesc and calls the drop glue that got set dynamically
[00:00:34] <cmr> intra, yes
[00:00:34] <strcat> o_o
[00:00:36] <Eridius> what I want is a private module that exposes a type and a function to its parent, and nothing else. Is that possible?
[00:01:12] <strcat> Eridius: no because of bugs, but yes in theory ;p
[00:01:27] <dbaupp> Eridius: you can make sure the module isn't public, by importing it as `mod foo;` right?
[00:01:38] <graydon> Eridius: sibling items of mod one, in parent, should be able to see it. mod two should not, that's probably a bug.
[00:01:47] <Eridius> dbaupp: yes I tried using two files, with one importing the other using `mod foo;`, and I could still see it
[00:01:48] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[00:01:49] <doomlord_> @mut is broken , is that so?
[00:02:05] <dbaupp> Eridius: "it"?
[00:02:07] <doomlord_> borrowed ptrs to @mut or something
[00:02:08] <graydon> check bug tracker for dupes on visibility bugs, if not open one.
[00:02:09] <Eridius> graydon: did I misspeak? mod two is a sibling of mod one. it's mod top { mod one {} mod two {} }
[00:02:20] <Eridius> dbaupp: "it" is the pub function in mod one
[00:02:31] <strcat> doomlord_: it works, it just has dynamic failure cases
[00:02:33] <strcat> they're intended
[00:02:34] <graydon> Eridius: non-mod sibling items. each mod is supposed to not-inherit any bindings, but be a fresh environment.
[00:02:38] <Eridius> ah
[00:02:46] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[00:03:12] <Eridius> graydon: so if I have mod top { mod one { pub fn foo(); } mod two {} } then foo() should only be visible to non-mod siblings of mod one, inside of mod top?
[00:03:20] <Eridius> and the parent of mod top shouldn't see it?
[00:03:23] <graydon> Eridius: we used to do inherit-what-your-parent-can-see and it confused everything. patrick argued it encouraged anti-modular coding anyways since sub-mods wound up fixed-in-place and depending on stuff in outer files, hard to tell why a resolve failure was happening. so we made them all empty by default.
[00:03:24] <Eridius> because that's what I was expecting
[00:03:33] <graydon> Eridius: correct
[00:03:44] <dbaupp> the buildbot appears to have failed on pcwalton's last commit. (but I guess people've already noticed.)
[00:03:51] <Eridius> ok good, so I can just write code like this and eventually the compiler will enforce what I'm expecting
[00:03:52] *** Quits: qmx (qmx@moz-D6C3C2E6.qmx.me) (Ping timeout)
[00:03:53] <doomlord_> that seems ot be what i'm running into .. trying to figure out a workaround. prepending one item to a borrowed vector with @ptrs (my use is immutable, but the orignals are mutable?) is causing the failiures
[00:03:59] <graydon> Eridius: you would need to re-export "one::foo" from top, or make "one" public
[00:04:07] <Eridius> graydon: that makes sense
[00:04:09] *** Quits: echristo (echristo@4241698A.2E4FD3DD.225F4543.IP) (Ping timeout)
[00:04:18] <graydon> Eridius: hopefully! confirm my statements here with pcwalton but I believe that's how we left it.
[00:04:26] <pcwalton> grr, ok
[00:04:34] <Eridius> graydon: that's certainly the behavior that makes the most sense to me
[00:04:43] <cmr> Is it intentional that an ast::Ty can refer to type-parameterized types, ie in enum Foo<U, V> { A(U), B(V) }, the Ty's in the args of the tuple_variant_kind's have concrete id's?
[00:05:36] <bblum> macro_rules hopefully!()
[00:05:41] *** Joins: echristo (echristo@60A74940.D6CCE4AE.77834EAA.IP)
[00:05:45] <bblum> err. macro_rules! hopefully()
[00:06:33] <toddaaro> brson: how important are runtime context asserts to you? we had a lot of "assert!(context() == SchedulerContext)" and such, and since there is so much churn in what it means to be in task or sched context they have all been nuked out
[00:06:41] <cmr> I suppose it'd map to a def_ty_param
[00:06:47] <toddaaro> brson: so I should put some back in, but I'm not sure what the ideal number is
[00:06:55] <tikue> rusti: let mut a = 1; let mut b = a;
[00:06:57] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[00:07:00] <tikue> gah
[00:07:04] <tikue> what's wrong with rusti
[00:07:09] *** Joins: qmx (qmx@moz-D6C3C2E6.qmx.me)
[00:07:09] <engla> bblum: can you review this? https://github.com/mozilla/rust/pull/7865
[00:07:15] <bblum> sure
[00:07:29] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[00:07:45] <bblum> engla: oh, um... i'm already doing exactly that in my enormous task killing pull request
[00:08:07] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[00:08:33] <pcwalton> graydon added a "copy"
[00:08:34] <pcwalton> fixing
[00:08:46] <strcat> doomlord_: @ doesn't have the failure cases, only @mut
[00:08:51] <graydon> pcwalton: sorry :(
[00:08:59] <bblum> engla: your 1st commit is redundant with me, but your 2nd commit is something i didn't bother to do
[00:09:02] <engla> bblum: hm ok, I thought you didn't since you filed that issue
[00:09:10] <doomlord_> i'm getting some sort of runtime borrow error (its posible its @mut, )
[00:09:15] <engla> bblum: ok that's fine, you can take my commit into your branch 
[00:09:19] <cmr> doomlord_: @mut is the only way to get that, yes.
[00:09:20] <bblum> engla: yeah i filed it because i was going to add fn take() but did not want to rename swap_unwrap
[00:09:22] <doomlord_> (just trying to figure out a workaround..)
[00:09:25] <bblum> engla: yeah i will cherry pick it
[00:09:30] <engla> great
[00:09:31] <cmr> doomlord_: you know what causes it right?
[00:09:42] <doomlord_> not exactly
[00:09:49] <ecr> anyone know why 'make check' seems to be deadlocking on net::tcp::test::tcp_ipv4_server_and_client_test::impl64::test_gl_tcp_server_access_denied on a fedora VM?
[00:10:01] <cmr> Mutating a @mut which has a & or &mut borrowed, borrowing &mut while &mut or & is borrowed.
[00:10:14] <cmr> and borrowing & while a &mut is borrowed from it
[00:10:16] <cmr> I think that's it
[00:10:17] *** Quits: dormiens (dormiens@2F2DB458.B767B9B7.2675F9C0.IP) (Ping timeout)
[00:10:29] *** Joins: dormiens (dormiens@2F2DB458.B767B9B7.2675F9C0.IP)
[00:10:56] <doomlord_> i didn't think any mutation was going on, but of course the only way to be sure is for it not to be mut in the first place. (bindgen source... )
[00:13:42] <strcat> doomlord_: it can happen just from borrows
[00:14:07] <doomlord_> rust: task failed at 'borrowed at gen.rs:252', gen.rs:862
[00:14:09] <strcat> borrowing a second &mut when you have either an & or &mut borrow, borrowing & while &mut is borrowed
[00:14:33] <strcat> doomlord_: compile without optimization
[00:14:38] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[00:14:57] *** Joins: Yurume_ (yurume@AC58A8CE.8A059B47.E313B915.IP)
[00:15:39] <doomlord_> ok i'll try that, but i wonder if i can workaround by copying the argument, or re-ordering something to avoid it. ultimately it could just be an index that gets passed along..
[00:16:16] <strcat> it should tell you where both borrows happen
[00:16:18] <strcat> with opt off
[00:16:25] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[00:16:34] <brson> toddaaro: i'm partial to asserting a lot of invariants, but the ideal number is a judgement call
[00:17:07] <toddaaro> brson: should we have a toggleable debug_assert! or something?
[00:17:10] <dbaupp> toddaaro, brson: it's possible to have a debug_assert!(..) macro that only gets enabled with --cfg debug
[00:17:27] <toddaaro> dbaupp: I guess that would be a good option then
[00:17:41] <toddaaro> I wouldn't mind putting them everywhere ever if they had a flag like that
[00:18:05] <doomlord_> yes it does appear to
[00:18:05] <dbaupp> https://github.com/mozilla/rust/blob/master/src/libsyntax/ext/expand.rs#L499 is how cfg'd macros have to be implemented
[00:18:33] <toddaaro> we already have rtdebug! and we toggle it by swapping an _ between two implementations
[00:18:40] <toddaaro> so when we finally tackle that we could do this macro too
[00:18:43] <brson> toddaaro: are these checks performance issues?
[00:19:01] <toddaaro> brson: every check would be a TLS hit and something like 6 dereferences and a pile of function calls
[00:19:07] <toddaaro> brson: for the context-related ones that is
[00:20:39] <bblum> brson: is the 2-word self thing a compile problem or a running-the-code problem
[00:20:43] <doomlord_> i could try and re-work the source to not use mut in the firstplace ... but that'll be a pretty drastic fork that has even less change of getting merged back :)
[00:20:55] <Eridius> when calling into C code, what's the right way to handle errno?
[00:21:32] <toddaaro> brson: tomorrow afternoon probably we should do a walkthrough of the new TLS stuff in the scheduler. It took awhile longer than I was hoping to get going, but it seems pretty solid now. Just enabling tests and cleaning at this point.
[00:21:50] <toddaaro> brson: the change_context function in sched was ... difficult
[00:22:19] <brson> sorry i'm in a meeting now
[00:22:27] <toddaaro> brson: ok, we can chat later
[00:23:49] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[00:24:13] <bblum> is there a way to fast-forward a branch only halfway
[00:24:19] <bblum> be like, i just wnat to FF up to this commit
[00:24:24] <strcat> Eridius: there's an errno_location binding
[00:24:30] <tikue> rusti: let mut a = 1; let mut b = a;
[00:24:32] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/CISB
[00:24:35] <Eridius> strcat: just found os::last_os_error() which is even better
[00:24:48] <tikue> rusti: let mut a = 1; let mut b = a; b += 1; b
[00:24:49] -rusti- <anon>:7:17: 7:18 warning: variable does not need to be mutable [-W unused-mut (default)]
[00:24:49] -rusti- <anon>:7          let mut a = 1; let mut b = a; b += 1; b
[00:24:49] -rusti-                           ^
[00:24:49] -rusti- 2
[00:25:05] <tikue> let a = 1; let mut b = a; b += 1; b // why does a not need to be mutable
[00:25:11] <tikue> rusti: let a = 1; let mut b = a; b += 1; b // why does a not need to be mutable
[00:25:12] -rusti- 2
[00:25:20] <strcat> because you don't mutate it
[00:25:29] <tikue> strcat: but wouldn't b inherit a's mutability
[00:25:29] <strcat> rusti: let a = 1; let mut b = a; b += 1; (a, b)
[00:25:31] -rusti- (1, 2)
[00:25:49] <strcat> tikue: no, mutability isn't inherited from something you assign from
[00:25:55] <tikue> rusti: struct Foo(uint); let a = Foo(1); let mut b = a;
[00:25:56] <strcat> mutability is determined by the owner
[00:25:58] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/jEbM
[00:26:25] <tikue> strcat: this is one of those things where I'm like, why didn't I realize that months ago :P
[00:26:52] <strcat> tikue: mutability isn't part of the type except for non-Freeze things (@mut, RWARC, RcMut, Cell)
[00:26:59] <strcat> it comes entirely from the owner
[00:27:09] <strcat> (also &mut and &const are non-Freeze)
[00:27:28] <tikue> strcat: does that mean you would never need a function to say something like fn foo (mut a: Foo) { // change a }
[00:27:40] <tikue> strcat: could it just be fn foo (a: Foo) { // change a }
[00:27:46] <strcat> don't know what you mean
[00:27:49] <strcat> a is by-value
[00:27:56] <tikue> strcat: yes
[00:28:09] <strcat> so you can't change it in a way that would be visible from the caller, unless it contains non-Freeze + non-owned fields
[00:28:42] <strcat> tikue: I think you're seeing it as a more complicated system than it is
[00:28:47] <strcat> mutable owner -> mutable all the way down
[00:28:53] <strcat> immutable owner -> immutable all the way down
[00:29:08] <tikue> rusti: fn foo (mut x: uint) { x += 1; } let mut a = 1; foo(a);
[00:29:12] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/aUhI
[00:29:23] <strcat> you're not mutating 'a'
[00:29:30] <strcat> it's still 1
[00:29:30] <Eridius> rusti: fn foo(mut x: uint) { x += 1; } let a = 1; foo(a); a
[00:29:32] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/djWi
[00:29:33] <tikue> rusti: fn foo (mut x: uint) { x += 1; } let a = 1; foo(a);
[00:29:36] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/DTfY
[00:30:02] <tikue> rusti: fn foo (mut x: uint) -> uint { x += 1; x } let a = 1; foo(a)
[00:30:03] -rusti- 2
[00:30:06] <Eridius> hrm, the "unused" warning is kinda wrong. Yeah the use is in a dead store, but that's not the same as never used
[00:30:09] <tikue> strcat: ok, get it. thank you :)
[00:30:26] <tikue> Eridius:  I disagree. mutating it isn't using it
[00:30:28] <tikue> (imo)
[00:30:48] <Eridius> tikue: isn't using what? the "use" here refers to the variable, not to the data held by it
[00:31:04] <bblum> Eridius: you're a resident git expert right
[00:31:11] <Eridius> rusti: fn foo(mut x: uint) { x += 1; info!(x); }; let a = 1; foo(a); a
[00:31:13] <tikue> Eridius: ok, I agree with that :P
[00:31:13] -rusti- 1
[00:31:14] <Eridius> bblum: sure
[00:31:18] <bblum> Eridius: is there a way to fast-forward a branch only partway to a commit that i specify
[00:31:19] *** Joins: mulemmasr (muslimmasr@1B6E22E1.4186B72C.563BE9DB.IP)
[00:31:26] <Eridius> bblum: define "only partway"
[00:31:30] *** Quits: mulemmasr (muslimmasr@1B6E22E1.4186B72C.563BE9DB.IP) (User has been banned from Mozilla (abuse))
[00:31:48] <bblum> Eridius: git branch -d behind_branch; git checkout HEAD~N; git checkout -b behind_branch
[00:31:54] <bblum> while on ahead_branch
[00:31:58] <graydon> gotta head out for a few hours, back in a while
[00:32:10] <eevee> git checkout -b behind_branch HEAD~N
[00:32:13] <graydon> I would like to express sincere thanks to everyone who's been improving the language since last time I hacked on workcache
[00:32:20] <bblum> eevee: well behind_branch already exists
[00:32:23] <graydon> 90% of the stuff-that-did-not-work before now works, and I can remove most workarounds
[00:32:25] <bblum> i wish for one command to do it
[00:32:34] <Eridius> bblum: git checkout -B behind_branch HEAD~N
[00:32:40] <Eridius> -B means "reset the branch if it exists; create otherwise"
[00:32:41] <eevee> yes that
[00:32:58] <bblum> oh ok
[00:32:59] <bblum> nice
[00:33:00] <eevee> or if you didn't want to switch branches you can do the same with git-branch
[00:33:14] <Eridius> bblum: anyway, so you have a branch that's behind master (or some other branch) by M commits (where M >= N, due to potential merges)
[00:33:22] <Eridius> bblum: so what exactly do you want to do with behind_branch?
[00:33:34] <bblum> uh
[00:33:37] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Connection reset by peer)
[00:33:45] <bblum> i want to do precisely what the command you just gave does
[00:33:48] <bblum> so.
[00:33:53] *** Joins: samx (sami@moz-48EC0983.dyn.optonline.net)
[00:34:24] <bblum> engla: check out that beautiful cherry-pick https://github.com/mozilla/rust/pull/7858
[00:34:39] <Eridius> bblum: ok so when you said "fastforward only partway" what you meant was "create or reset a given branch to a given commit"?
[00:34:48] <bblum> Eridius: yes
[00:34:50] <Eridius> ok
[00:34:55] <bblum> was there some ambiguity where i could have meant something else
[00:35:01] <bblum> (i mean, if so, what was it)
[00:35:08] <engla> nice
[00:35:11] <Eridius> note that git checkout -B does not ensure the branch is a fast-forward
[00:35:15] <cmr> I thought you meant partially apply a commit
[00:35:23] <engla> hope the patch has a nice life in its new branch
[00:35:28] <Eridius> bblum: if you want to ensure that your change is a fast-forward you can actually use `git push`, as in `git push . HEAD~N:behind_branch`
[00:35:37] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[00:35:45] <bblum> that's... odd
[00:35:45] <Eridius> this will create behind_branch at the point HEAD~N, or it will fast-forward behind_branch if it already exists, and it will bail if the change is not a fast-forward
[00:35:49] <bblum> i will not remember that for sure :P
[00:36:01] <Eridius> bblum: . as a refspec to git-push means "the current repo". everything else is just normal git push behavior
[00:36:09] <bblum> presumably 'checkout -B' it will complain anyway if it will leave unmerged commits dangling?
[00:36:14] <Eridius> err not a refspec, as a repo
[00:36:28] <Eridius> bblum: `checkout -B` will probably not complain at all unless you give it an invalid commit
[00:36:39] <bblum> hmm, danger
[00:36:50] <Eridius> bblum: the only command that will complain about leaving unmerged commits behind is `git branch -d`
[00:37:01] <bblum> i see
[00:38:07] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[00:38:07] <doomlord_> yikes. i will have to put this down now and sleep. so much of what i wanted to do works but i fail on being able to prepend one arguement to a list because of this @mut thing :) tommorrw...
[00:38:35] <Eridius> if you want the "safe" version you can say `git config alias.update-branch 'f() { git branch -d "%1" && git branch "$1" "$2"; }; f'`
[00:38:48] <Eridius> bblum: this will give you a command `git update-branch behind_branch HEAD~N`
[00:39:20] <bblum> huh, i see, ok
[00:39:24] <Eridius> if you pass the --global flag to `git config` then this is stored in ~/.gitconfig for use everywhere
[00:39:47] <bblum> i do not feel like remembering this update-branch thing but thanks anyway
[00:39:53] <Eridius> well you can name it whatever you want
[00:40:15] <bblum> i mean. whatever i name it i will have to ship it about among all machines i use
[00:40:16] <Eridius> or you could just decide you don't care about the dangling commits error and use `git checkout -B ...` ;)
[00:40:31] <brson> toddaaro: when building with CFG_ENABLE_DEBUG rustc is called with `--cfg debug` so you could create a macro that calls a #[cfg(debug)] function, but I don't think anybody ever uses CFG_ENABLE_DEBUG so it will always be off
[00:40:34] <Eridius> I keep my ~/.gitconfig synchronized on all machines I use (along with other dotfiles)
[00:40:46] <brson> toddaaro: we could possibly make rustc automatically define #[cfg(debug)] when building with -g
[00:41:00] <toddaaro> brson: that could be cool
[00:41:01] <cmr> http://rustlog.octayn.net/post/55735239211/status-update, 'night all
[00:41:06] <dbaupp> brson, toddaaro: I have a debug_assert patch, just testing it now :)
[00:41:18] <bblum> Eridius: well, every other git command i run is git show-branch, so i am unlikely to lose commits if i check first
[00:41:21] <toddaaro> dbaupp: fancy!
[00:41:32] <Eridius> brson: what's -g? I don't see it in `rustc --help`, unless it was just added. Does it just emit debug symbols?
[00:41:51] <jensnockert> Eridius: Yes.
[00:41:53] <brson> Eridius: sorry, it's probably `-Z debug-info` at the moment since it's still experimental
[00:42:17] <Eridius> brson: ok, I'd be nervous about having that turn on a debug config. What if I want debug info in the production configuration of my app?
[00:42:39] <brson> Eridius: fair point
[00:43:02] <brson> I think pcwalton also wants to turn off debug! completely when not using -g. this is probably in the same category
[00:43:23] <brson> maybe the generation of debug info and debug build mode are separate things
[00:43:52] <Eridius> I could envision one arg turning both on, but I'd still want separate knobs for each
[00:44:12] <dbaupp> brson, toddaaro: https://github.com/mozilla/rust/pull/7869
[00:44:17] <dbaupp> brson: that's already been done
[00:44:33] <Eridius> dbaupp: assert! != debug!
[00:44:38] <brson> dbaupp: what, and how?
[00:44:49] <dbaupp> brson: https://github.com/mozilla/rust/pull/7822
[00:44:54] <Eridius> #[macro_escape]?
[00:45:19] <dbaupp> Eridius: it means that macros escape from the module
[00:45:23] <Eridius> ah
[00:45:54] <dbaupp> Eridius: i.e. normally a macro scope is pushed when entering a module, but macro_escape stops that, and so any macros get put into the parent one.
[00:46:15] <Eridius> dbaupp: I assume that eventually we'll have proper macro visibility that will obsolete this?
[00:47:06] <dbaupp> Eridius: maybe/hopefully... it'd be a little strange because it'd essentially require reimplementing a resolve in syntax
[00:47:23] <dbaupp> *libsyntax
[00:47:45] <Eridius> dbaupp: it would let us drop that massive string we prepend to every file
[00:48:07] <dbaupp> Eridius: only the top of the crate
[00:48:23] <dbaupp> and we actually prepend the parsed ast (fwiw)
[00:48:29] <Eridius> oh? huh.
[00:48:33] <Eridius> still, would be nice to kill that with fire
[00:48:34] *** Quits: Voomer (Voomer@moz-9D83462.dyn.centurytel.net) (Ping timeout)
[00:48:38] <strcat> aatch: any luck reverting that memory regression?
[00:48:45] <strcat> seems like it's going to get harder to revert
[00:48:51] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[00:49:55] <dbaupp> strcat: the way to fix it is probably de-@ the rest of the ast and convert syntax::fold to consume, rather than take by reference
[00:49:59] <dbaupp> *best way
[00:50:24] *** Quits: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com) (Ping timeout)
[00:50:37] <dbaupp> Eridius: right, but it's not that much of a hack... at least compared to the other possible solutions.
[00:51:15] *** Quits: ozten (ozten@moz-DD3B00B4.hsd1.wa.comcast.net) (Quit: ozten)
[00:52:28] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[00:52:35] *** Quits: BitPuffin (quassel@moz-49828767.cust.tele2.se) (Ping timeout)
[00:56:21] <bstrie> graydon: would it be useful to have an "I-justabug" tag for all the issues that are rejected for milestones? I was thinking that would make it possible to easily determine which bugs have never been considered for milestones, but I'm not sure if it's your intention to eventually categorize every single bug
[00:57:26] <kmc> is there a way to further de-mangle a name like std..option..Option$LT$$SP$mut$x20$LP$$RP$$GT$::_ca13189eefa1925b::glue_drop_12279
[00:57:29] <strcat> you know they're nominated from the comment nominating them
[00:57:53] * strcat hates our name mangling
[00:57:58] <bstrie> strcat: right, I was talking just in the bug list view, from the perspective of someone trying to find overlooked bugs to nominate
[00:58:02] <dbaupp> kmc: in theory it's reversable
[00:58:17] <dbaupp> kmc: I dont think anyone's written a tool to do it yet though
[00:59:08] <strcat> the default methods adding to cmp are a big perf issue
[00:59:08] <dbaupp> kmc: but that's Option<@mut ()>
[00:59:11] <strcat> if you use them
[00:59:16] <strcat> they don't get inlined ;[
[00:59:18] <strcat> hrm
[00:59:20] <bstrie> strcat: basically I'm concerned that the "backwards-compatible" milestone will pass with us overlooking issues that actually affect backwards compatibility
[00:59:33] <dbaupp> strcat: I believe #[inline] works on default methods
[00:59:45] <dbaupp> (but I'm not sure.)
[01:00:10] <kmc> what does the x20 part mean? ASCII space?
[01:00:14] <engla> I don't think the default methods in Ord are used yet
[01:00:15] <dbaupp> kmc: yeah
[01:00:27] *** Quits: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com) (Quit: ecr)
[01:00:49] <dbaupp> kmc: the mangling algorithm: https://github.com/mozilla/rust/blob/master/src/librustc/back/link.rs#L682
[01:03:33] <dbaupp> engla: sorry for the nitpicky review :(
[01:03:34] <kmc> i see, thanks
[01:03:47] <dbaupp> engla: wait, wrong person
[01:04:10] * dbaupp can't read
[01:04:15] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[01:04:15] <ghrust> 01[13rust01] 15pcwalton pushed 1 new commit to 06master: 02http://git.io/FnFvxw
[01:04:15] <ghrust> 13rust/06master 14d300a64 15Patrick Walton: compiletest: Remove stray copies.
[01:04:15] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[01:05:36] <toddaaro> brson: you around still? I am looking at the test case in sched.rs called "fn handle()" and I don't know what it is supposed to be testing
[01:05:50] *** Joins: sanxiyn (tinuviel@858F408C.B797260D.EF43EC08.IP)
[01:06:17] <toddaaro> brson: scheduler startup has changed, so it doesn't work as is, and I wrote a "new" version that does seemingly the same thing, but I'm not sure I'm testing what it tests
[01:06:35] *** Joins: strcat1 (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[01:06:35] <sanxiyn> IRC test
[01:06:39] <dbaupp> kmc: (the `_` arm just maps character to `\x01`, `\u0011`, `\U0011223344` and then to the same thing but with $ instead of \)
[01:06:41] <cmr> sanxiyn: you're alive
[01:06:53] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (NickServ (GHOST command used by strcat1))
[01:06:59] <sanxiyn> cmr: I am
[01:07:03] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (NickServ (GHOST command used by strcat1))
[01:07:11] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[01:07:15] *** strcat1 is now known as strcat
[01:07:33] <dbaupp> sanxiyn: did you see jensnockert's blog post? http://www.reddit.com/r/rust/comments/1igvye/vision_for_rust_simd/
[01:07:34] <brson> tjc: change_dir_locked is a pretty strange function. i assume this was to work around races in test cases?
[01:07:37] <sanxiyn> dbaupp: Yes
[01:07:57] <brson> toddaaro: looking
[01:08:16] <toddaaro> brson: thanks
[01:08:42] <bblum> brson: did you see the enormous PR i linked a bit ago?
[01:09:57] <brson> bblum: yes, thanks
[01:10:24] <brson> toddaaro: it's a smoke test of SchedHandle. it looks like it's not really 'testing' anything though, in the sense that if sched handles didn't work it would still succeed
[01:10:39] <tjc> brson: yes
[01:10:51] <brson> toddaaro: I guess it's testing that, if a handle exists, releasing the handle does allow the scheduler to exit
[01:12:03] <toddaaro> brson: hm, so the important thing to keep is sched handle creation?
[01:12:35] <toddaaro> brson: I'll ponder this a bit and get it going
[01:12:50] <sanxiyn> dbaupp: By the way, I pretty much agree with his analysis
[01:12:59] <dbaupp> graydon: does the buildbot-build for pcwalton's latest push need to be triggered manually?
[01:13:06] *** Joins: foo (Mibbit@357E2FA1.983BBEF4.60C86946.IP)
[01:13:19] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[01:13:19] <ghrust> 01[13rust01] 15pcwalton merged 06master into 06auto: 02http://git.io/ddDlPA
[01:13:19] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[01:14:55] <dbaupp> sanxiyn: cool! (It's a pretty good sign when the two people who seem to be the most knowledgeable agree :) )
[01:15:15] *** Quits: echristo (echristo@60A74940.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[01:16:10] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[01:18:05] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[01:20:56] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[01:21:20] <brson> toddaaro: no, the important thing is that SchedHandle destruction destroys the RemoteCallback and drops the event loop ref count
[01:22:08] <Eridius> why do I see both target_os="darwin" and target_os="macos" in the source? Despite the host triple being x86_64-apple-darwin, the target_os cfg seems to be "macos" for me
[01:22:27] <brson> Eridius: "darwin" is a mistake
[01:27:53] <Eridius> rusti: let x: [int, ..2] = [1, 2]; (std::ptr::to_unsafe_ptr(&x), std::ptr::to_unsafe_ptr(&x[0]))
[01:27:54] -rusti- ((0x7f569d399790 as *()), (0x7f569d399790 as *()))
[01:27:55] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: Places to go, people to annoy)
[01:28:13] <Eridius> ok good. I assume I can rely on the fact that an array has no box and just use the former?
[01:29:09] <Eridius> actually, that types wrong. I guess I need the latter
[01:30:23] <Eridius> rusti: let x: [i32, ..2] = [1,2]; (std::ptr::to_unsafe_ptr(&x[0]), std::ptr::to_unsafe_ptr(&x[1]))
[01:30:25] -rusti- ((0x7f19fb61c798 as *()), (0x7f19fb61c79c as *()))
[01:31:19] *** Quits: eschweic1 (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[01:31:45] <dbaupp> is there a way to print the repr of a type?
[01:32:18] <homa_rano> where might I find a doc for the fmt! syntax?
[01:32:19] <brson> bblum: task::atomically seems to be much trickier in the new scheduler since there are many ways to context switch besides yield(). are the places that use it still correct?
[01:32:22] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[01:32:32] <brson> bblum: and can we get rid of it?
[01:33:26] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[01:33:29] <Eridius> homa_rano: besides the mentions in the tutorial/manual? Not sure if there's any real docs. It supports a subset of printf formatting, plus the %? token which prints the (potentially unsafe) representation of the value
[01:33:31] <dbaupp> homa_rano: std::unstable::extfmt
[01:33:55] <dbaupp> homa_rano: https://github.com/mozilla/rust/blob/master/src/libstd/unstable/extfmt.rs
[01:34:24] <Eridius> dbaupp: boy, the rustdoc comments in there would be a lot more useful if the unstable module wasn't omitted from the documentation
[01:34:33] <strcat> dbaupp: as in what %? does in fmt!?
[01:34:38] <dbaupp> Eridius: yup
[01:34:49] <dbaupp> strcat: no, as in, Some(1) => Option<int>
[01:34:53] <strcat> oh
[01:35:09] <strcat> dbaupp: we could expose that as an intrinsic
[01:35:20] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[01:35:25] * dbaupp has a 'matched no variant' error, created by the parser
[01:35:43] <dbaupp> strcat: so it's not possible now?
[01:35:44] <Eridius> dbaupp: so fmt! is parsed in libsyntax, but it calls out to std::unstable::fmt to actually drive it, or what?
[01:35:52] <dbaupp> Eridius: yeah, essentially
[01:35:57] <Eridius> good to know
[01:36:19] <dbaupp> Eridius: most of the formatting logic is in std, but not all, so it's a little awkward.
[01:37:02] *** Quits: goffrie (goffrie@moz-A3ADCE7B.dsl.ncf.ca) (Ping timeout)
[01:37:04] *** Joins: goffrie (goffrie@moz-A3ADCE7B.dsl.ncf.ca)
[01:37:20] <dbaupp> strcat: oh, there's a 'visit_tydesc' intrinsic already, is that it?
[01:38:39] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[01:39:13] *** Quits: Archer (Archer@moz-B3C4C551.bb.online.no) (Ping timeout)
[01:40:35] <homa_rano> hmm, I was hoping for something in fmt! to print the type of the var in question
[01:41:27] <dbaupp> homa_rano: haha, exactly what I've been looking for too!
[01:41:35] <Eridius> just throw a compile error!
[01:41:37] *** Joins: Archer (Archer@moz-B3C4C551.bb.online.no)
[01:42:01] <Eridius> hrm, std::repr::write_repr looks interesting
[01:42:14] <dbaupp> homa_rano: but, yeah, if you're just trying to work out what type a thing is, just do `let foo: () = my_variable;` and look at the error message
[01:42:17] <Eridius> rusti: let x: i64 = 3; std::repr::write_repr(std::os::stdout(), &x)
[01:42:18] -rusti- <anon>:7:47: 7:62 error: unresolved name `std::os::stdout`.
[01:42:19] -rusti- <anon>:7          let x: i64 = 3; std::repr::write_repr(std::os::stdout(), &x)
[01:42:19] -rusti-                                                         ^~~~~~~~~~~~~~~
[01:42:19] -rusti- error: aborting due to previous error
[01:42:19] -rusti- application terminated with error code 101
[01:42:27] <Eridius> rusti: let x: i64 = 3; std::repr::write_repr(std::io::stdout(), &x)
[01:42:29] -rusti- 3()
[01:42:31] <Eridius> bleh
[01:42:31] *** Joins: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[01:43:12] <strcat> yeah the visitor just walks the types
[01:43:20] <strcat> so you find out what they are by walking them
[01:43:24] <strcat> *but* it isn't the real type
[01:43:32] <strcat> it's just *the primitives it is built from*
[01:43:47] <dbaupp> i.e. the LLVM types?
[01:43:51] <strcat> no
[01:43:52] <strcat> rust types
[01:44:12] <strcat> dbaupp: look at unstable::intrinsics::TyVisitor
[01:44:31] <dbaupp> oh, what's *not* a primitive then?
[01:45:00] <dbaupp> ("visit_enter_class"... what's a class?)
[01:45:07] <strcat> a struct
[01:45:24] <strcat> it won't tell you type parameters or anything
[01:45:34] <Eridius> it would be nice to have a %T token in fmt!() that resolves to the name of the type
[01:45:56] <dbaupp> nor will it tell you the name :'(
[01:46:15] *** Quits: azakai_ (alon@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[01:47:16] *** Quits: geomyidae (cole@DD6F7E3A.21468E9A.30200F38.IP) (Quit: Konversation terminated!)
[01:47:17] <sp3d> huh... how do you get a ~T from an &T (performing the deep copy)?
[01:47:35] <Eridius> .clone()?
[01:47:39] <dbaupp> sp3d: yep
[01:47:49] <dbaupp> sp3d: ~x.clone()
[01:47:51] <sp3d> seems to return another &T from the error message I'm getting :x
[01:47:59] <dbaupp> oh, ~(*x).clone()
[01:48:08] <dbaupp> (it probably means that x doesn't implement Clone.)
[01:48:08] <sp3d> really?
[01:48:18] <sp3d> it's a struct I defined, so it dosen't do anything fancy
[01:48:30] <dbaupp> #[deriving(Clone)] struct Foo { ... }
[01:48:48] <sp3d> ~*x worked
[01:48:49] <acrichto_> dbaupp: would you consider renaming debug_assert to dassert?
[01:48:49] <sp3d> thanks
[01:49:17] <dbaupp> acrichto_: I would, is there a precedent or something?
[01:49:27] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Ping timeout)
[01:49:36] <acrichto_> dbaupp: probably not, I just wouldn't like typing 'debug_'
[01:49:37] *** Joins: azakai_ (alon@moz-BBE3ABD.mv.mozilla.com)
[01:49:46] <dbaupp> acrichto_: aha
[01:50:27] *** Quits: lmandel (lmandel@8B192B20.1F93A08E.ADB88A9.IP) (Quit: lmandel)
[01:50:29] <strcat> acrichto_: well they shouldn't really be common
[01:50:30] *** Joins: geomyidae (cole@DD6F7E3A.21468E9A.30200F38.IP)
[01:50:30] <Eridius> woohoo, I have code now that bumps the fd limit to the max allowed when running std::rt::run_in_mt_newsched_task()
[01:50:32] <dbaupp> in that case I'm less keen on it (as in, dassert! isn't *obviously* 'debug assert')
[01:50:36] <acrichto_> dbaupp: apparently there's a Debug.Assert with microsoft stuff, but dassert comes up with a header on google
[01:50:37] <strcat> leaving around debugging stuff means you probably did something wrong
[01:50:40] <strcat> ;p
[01:50:57] <acrichto_> strcat: it's userful for asserting invariants all over the place
[01:51:07] <acrichto_> strcat: I've used dassert before and it was incredibly useful
[01:51:20] <strcat> you can move the invariants into the type though
[01:51:27] *** Joins: MaikKlein1 (maik@moz-EF706AF.dip0.t-ipconnect.de)
[01:51:31] <dbaupp> strcat: not always
[01:51:40] <acrichto_> not always though, although this was in C so I'm not sure how well it would translate
[01:51:43] <strcat> if you can assert it, you can move it into a type
[01:51:51] <strcat> it just might not be fast enough
[01:52:00] <dbaupp> strcat: right, not without cost.
[01:52:21] <strcat> for example, are we going to put one of these into bsearch, asserting that the array is sorted?
[01:52:27] *** Quits: foo (Mibbit@357E2FA1.983BBEF4.60C86946.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[01:52:34] <strcat> you *can* pass an unsorted array into it
[01:52:45] *** Joins: lmandel (lmandel@8B192B20.1F93A08E.ADB88A9.IP)
[01:52:59] *** Quits: azakai_ (alon@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[01:53:19] <acrichto_> strcat: well I can think of scenarios where they shouldn't be left around, although that doesn't mean they shouldn't be left around in *every* scenario
[01:53:24] <dbaupp> strcat: would there be a problem with doing so?
[01:55:02] <strcat> dbaupp: well if you make it abort, I don't think there would be a huge problem
[01:55:07] <MaikKlein1> will rt stay forever?
[01:55:25] <strcat> but if it fails, it's different behaviour with/without debugging enabled
[01:55:44] <strcat> you can end up relying on that behaviour
[01:56:17] <dbaupp> so debug_assert/dassert should abort
[01:56:18] <dbaupp> ?
[01:56:28] <acrichto_> dbaupp: assert should always abort?
[01:56:39] <brson> how do you run tests without the #[bench]es?
[01:56:40] *** Quits: Archer (Archer@moz-B3C4C551.bb.online.no) (Quit: Leaving)
[01:56:48] <strcat> brson: it does by default
[01:56:49] <dbaupp> brson: aren't they normally ignored?
[01:56:53] <strcat> you have to pass --bench to run them
[01:57:20] <brson> how do i make `make check-stage1-extra` not run the benchmarks?
[01:57:43] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[01:57:54] <dbaupp> acrichto_: probably not, it'd require changing (most) of the assert!'s in the code base to if !cond { fail!() }
[01:58:02] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[01:58:25] <acrichto_> dbaupp: wait I'm confused what you're saying. That's what assert does now, no?
[01:58:42] <brson> graydon: is there a mechanism in the makefiles to suppress --bench? this is really slow
[01:59:06] <dbaupp> acrichto_: right, and functions with invalid argument should `fail!`, not `abort`
[01:59:29] <dbaupp> acrichto_: the point about debug_assert abort-ing is because otherwise debug/not-debug behaviour changes
[01:59:42] <dbaupp> (as fail!'s can be "caught", a little bit.)
[02:00:04] <acrichto_> dbaupp: wait the whole point of debug_assert is to expensively assert invariants while developing and not when compiling with optimizations
[02:00:14] <acrichto_> dbaupp: yes debug/opt is different, but if they are then opt is wrong
[02:00:47] <dbaupp> acrichto_: if you're developing in debug mode, you might accidentally rely on debug_assert! failing
[02:01:12] <dbaupp> and then have a subtle bug when it disappears for the release build
[02:01:55] <acrichto_> dbaupp: I guess so? Although that to me also sounds like saying transmute is unsafe so you shouldn't use it (even when you need it)
[02:02:09] *** Joins: cowboyd (cowboyd@moz-DD0FF83.lightspeed.austtx.sbcglobal.net)
[02:03:19] <dbaupp> acrichto_: it's slightly different, because transmute does the same thing no matter the compiler flags, where as debug_assert! doesn't
[02:03:23] *** Quits: MaikKlein1 (maik@moz-EF706AF.dip0.t-ipconnect.de) (Ping timeout)
[02:03:33] <dbaupp> (i.e. there are factors other than the code itself that dictate its behaviour.)
[02:04:03] <acrichto_> dbaupp: well regardless my vote is to have this, but call it dassert! -- If we either don't have it or it's called debug_assert I wouldn't be too broken up :)
[02:04:21] <dbaupp> haha :)
[02:04:29] *** Quits: sanxiyn (tinuviel@858F408C.B797260D.EF43EC08.IP) (Ping timeout)
[02:04:32] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[02:04:38] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[02:05:17] <bblum> brson: 'places that context switch' should not be relevant for atomically
[02:05:26] <bblum> i do not think that getting rid of atomically would be a good idea
[02:05:32] <bblum> as it is a very important assertion
[02:06:36] <brson> bblum: i don't understand why. the docs say it 'inhibits scheduling operations'
[02:06:52] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[02:06:57] <bblum> ah, it does not inhibit on its own; it merely asserts that no scheduling happens
[02:07:31] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[02:08:07] <bblum> if scheduling were to happen, that would be very bad, and the fault of whoever wrote the operation that caused scheduling in the atomically section
[02:08:11] <tikue> hey guys, quick question: if I do something like `my_chan.send(1); my_chan.send(2);` is there a deterministic order in which those messages arrive?
[02:08:29] * tikue hopes yes
[02:08:45] <bblum> brson: the check is that you never deschedule a thread while it is holding a pthread mutex; if you did, it could deadlock the scheduler
[02:09:09] *** Joins: Thad (chatzilla@moz-C35F90AE.tx.res.rr.com)
[02:09:19] <brson> bblum: so everywhere that a task gets descheduled needs to check that the inhibit_yield flag is 0, right?
[02:09:25] <bblum> right
[02:09:30] <tikue> rusti: let (port, chan) = std::comm::stream(); chan.send(1); chan.send(2); port.recv() == 1
[02:09:32] <bblum> this should not be expensive; it's not atomic or anything
[02:09:32] <brson> ok
[02:09:41] <tikue> ah
[02:10:26] <bblum> uh... oops, speaking of which, i meant to put assert_may_sleeps in the scheduler
[02:11:00] <bblum> i suppose i should note somewhere in a comment that atomically is meant for library use only
[02:11:10] <Thad> Either a new bug, regression here ?  rust_upcall.cpp   http://pastebin.mozilla.org/2647053
[02:11:24] <brson> bblum: yeah, we should bury this in std::rt probably
[02:11:34] <brson> same for unkillable
[02:11:47] <bblum> i think unkillable should be user-usable probably
[02:12:02] <bblum> i could imagine someone doing unsafe casting stuff or accessing C resources that they need to free
[02:12:06] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[02:12:19] <bblum> btw, https://github.com/mozilla/rust/issues/7832
[02:12:26] <bblum> oh, i see you saw
[02:12:42] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[02:13:55] *** Quits: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com) (Quit: pcwalton)
[02:14:40] <bblum> i'm also not convinced that atomically should do what unkillable does in addition
[02:14:46] <bblum> getting killed while holding a pthread mutex is fine
[02:15:09] <bblum> although it's not like you would receive the kill signal any time during
[02:17:08] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[02:17:33] * strcat hopes this works
[02:19:07] *** Quits: samx (sami@moz-48EC0983.dyn.optonline.net) (Quit: This computer has gone to sleep)
[02:23:53] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[02:26:03] *** Quits: Thad (chatzilla@moz-C35F90AE.tx.res.rr.com) (Quit: ChatZilla 0.9.90.1 [Firefox 23.0/20130703181823])
[02:26:18] *** Quits: cowboyd (cowboyd@moz-DD0FF83.lightspeed.austtx.sbcglobal.net) (Client exited)
[02:27:10] *** Quits: paulproteus (quassel@rose.makesad.us) (Ping timeout)
[02:27:41] *** Joins: paulproteus (quassel@moz-E86A3B42.makesad.us)
[02:28:46] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[02:31:30] <sp3d> huh
[02:31:32] <sp3d> rusti: 0b01f
[02:31:35] -rusti- 1
[02:31:38] <sp3d> rusti: 0b01.
[02:31:39] -rusti- <anon>:6:12: 6:13 error: binary float literal is not supported
[02:31:39] -rusti- <anon>:6     let r = {
[02:31:39] -rusti-                      ^
[02:31:39] -rusti- application terminated with error code 101
[02:31:43] <sp3d> ???
[02:32:16] <strcat> . makes it a float
[02:32:21] <sp3d> so does f
[02:32:31] <sp3d> rusti: 0b01f + 0.5
[02:32:32] -rusti- 1.5
[02:32:44] <sp3d> rusti: 0b01 + 0.5
[02:32:45] -rusti- <anon>:7:16: 7:19 error: mismatched types: expected `<VI0>` but found `<VF0>` (expected integral variable but found floating-point variable)
[02:32:45] -rusti- <anon>:7          0b01 + 0.5
[02:32:45] -rusti-                          ^~~
[02:32:45] -rusti- error: aborting due to previous error
[02:32:45] -rusti- application terminated with error code 101
[02:33:54] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[02:34:14] <dbaupp> rusti: 0b0.1
[02:34:14] -rusti- <anon>:6:12: 6:13 error: binary float literal is not supported
[02:34:14] -rusti- <anon>:6     let r = {
[02:34:14] -rusti-                      ^
[02:34:14] -rusti- application terminated with error code 101
[02:34:25] <steven_is_false> Suppose I have a key value list of type &'static [(Key, Value)]. What's the best way to get the key for the value?
[02:35:34] <sp3d> relatedly, a ":type <expr>" in rusti would be the bee's knees
[02:36:06] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[02:37:58] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[02:39:50] *** Quits: Earnestly (earnest@2AB30F53.FB5005.2BCC804A.IP) (Ping timeout)
[02:40:03] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[02:42:50] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[02:43:23] *** Quits: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net) (Ping timeout)
[02:43:26] *** Joins: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net)
[02:44:47] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[02:44:57] *** Joins: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net)
[02:46:23] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[02:46:23] *** ChanServ sets mode: +o tjc
[02:46:39] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: Places to go, people to annoy)
[02:48:41] *** Quits: kimundi (kimundi@moz-BF6F2565.dip0.t-ipconnect.de) (Ping timeout)
[02:50:36] *** Quits: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu) (Quit: Leaving)
[02:51:40] *** Joins: kimundi (kimundi@moz-16A93411.dip0.t-ipconnect.de)
[02:51:46] *** Joins: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net)
[02:51:59] <sp3d> apparently there's a compile-fail test for that
[02:52:18] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[02:52:18] <ghrust> 01[13rust01] 15brson pushed 7 new commits to 06try: 02http://git.io/bNyiFg
[02:52:18] <ghrust> 13rust/06try 14432b1c6 15Brian Anderson: extra: Remove uv, net, timer code...
[02:52:18] <ghrust> 13rust/06try 144ab3994 15Brian Anderson: extra: Add url module...
[02:52:18] <ghrust> 13rust/06try 1431ef99e 15Brian Anderson: std: Remove weak_task API. Unused
[02:52:19] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[02:52:20] <sp3d> but it fails because it contains three incorrect items, any one of which would cause a compilation failure
[02:54:01] *** kimundi is now known as zz_kimundi
[02:55:49] *** Joins: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu)
[02:56:04] <dwrensha> Hi, I have a question about traits. Is it possible to have a trait like this:
[02:56:06] <dwrensha> trait Constructable<'self> { fn construct<'a>(v : &'a [u8]) -> Self<'a>; }
[02:56:35] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[02:56:46] <dbaupp> rusti: trait Constructable<'self> { fn construct<'a>(v : &'a [u8]) -> Self<'a>; }
[02:56:48] -rusti- <anon>:7:72: 7:80 error: region parameters are not allowed on this type
[02:56:48] -rusti- <anon>:7          trait Constructable<'self> { fn construct<'a>(v : &'a [u8]) -> Self<'a>; }
[02:56:48] -rusti-                                                                                  ^~~~~~~~
[02:56:48] -rusti- error: aborting due to previous error
[02:56:48] -rusti- application terminated with error code 101
[02:56:57] <dwrensha> I was told a few weeks ago that traits and region variables don't work well together
[02:57:04] <dwrensha> but it really seems like this should be possible
[02:57:16] <engla> Self<'a> is not possible
[02:57:20] <dbaupp> yeah, i've found 2 uses for it
[02:57:26] <steven_is_false> Rust does not currently support higher order generics.
[02:57:28] <dbaupp> (where it'd be *very* useful.)
[02:57:36] <dwrensha> how is this higher order?
[02:57:39] <dbaupp> steven_is_false: this is slightly different... it's just lifetimes
[02:57:45] <steven_is_false> Like F<bar> or Self<'r>
[02:58:11] <steven_is_false> dbaupp: Sure lifetiimes are a different kind than types but it's still basically similar.
[02:59:01] <dbaupp> steven_is_false: maybe... I don't know the internals of that part of the compiler
[02:59:04] <dwrensha> So there's no future plan to support this kind of thing?
[02:59:13] <dbaupp> dwrensha: I hope there is!
[03:01:29] *** Quits: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com) (Quit: tikue)
[03:02:43] <dbaupp> dwrensha: (you could/should file a bug about it :) )
[03:03:35] <dbaupp> a quick search doesn't turn up anything similar, so I guess it's not a duplicate (but doesn't matter if it is).
[03:06:30] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[03:06:43] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[03:06:43] *** Quits: toddaaro (toddaaro@moz-98F46974.us) (Ping timeout)
[03:06:57] *** Joins: toddaaro (toddaaro@moz-98F46974.us)
[03:07:49] *** Quits: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net) (Quit: ChatZilla 0.9.90 [Firefox 22.0/20130618035212])
[03:07:53] *** Joins: cowboyd (cowboyd@moz-DD0FF83.lightspeed.austtx.sbcglobal.net)
[03:08:34] *** Joins: jfbk (textual@moz-EEA9CFB3.nyc.res.rr.com)
[03:08:54] *** Quits: LU324 (stuff@moz-A17E9A7B.dyn.embarqhsd.net) (Ping timeout)
[03:09:17] *** Quits: steven_is_false (user@moz-144077DE.bchsia.telus.net) (Ping timeout)
[03:09:34] *** Quits: tiffnya (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net) (Ping timeout)
[03:09:43] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[03:11:14] <dbaupp> strcat: is it possible to trigger a build for a whole branch? http://buildbot.rust-lang.org/console?branch=auto&refresh=15
[03:14:00] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[03:15:05] <strcat> dbaupp: nope, one by one
[03:15:24] *** Quits: jdm (jdm@moz-AC89B3C8.vlan445.asr1.yyz1.gblx.net) (Quit: Lost terminal)
[03:15:50] <dbaupp> what do I need to put in http://buildbot.rust-lang.org/builders/auto-mac-32-opt again?
[03:15:56] <dbaupp> just 'auto'?
[03:16:06] <dbaupp> (and rust/rust)
[03:17:19] <strcat> yes
[03:19:23] <dbaupp> hm, http://buildbot.rust-lang.org/builders/auto-bsd-64-opt/builds/246/steps/git/logs/stdio ?
[03:19:38] *** Joins: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com)
[03:19:45] <dbaupp> oh, I think I put it in the wrong box
[03:21:07] <graydon> I will restart
[03:21:09] * dbaupp hopes this doesn't break anything
[03:21:21] <graydon> dbaupp: don't sweat it, I'm back, I'll babysit for the rest of the night
[03:21:53] <graydon> oh, you restarted already?
[03:22:30] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[03:24:03] <dbaupp> yeah, I just went through each builder and force a build on auto
[03:24:06] <dbaupp> *forced
[03:24:34] *** Quits: geomyidae (cole@DD6F7E3A.21468E9A.30200F38.IP) (Client exited)
[03:24:58] *** Quits: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com) (Quit: Jesse)
[03:26:52] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[03:26:52] <sp3d> rusti: 0bf
[03:26:54] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/PDSj
[03:27:31] <dbaupp> sp3d: cool
[03:28:34] *** Joins: geomyidae (cole@DD6F7E3A.21468E9A.30200F38.IP)
[03:28:36] <sp3d> interestingly, that's not what a local rusti gives, though both fail
[03:28:53] *** Quits: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com) (Quit: tikue)
[03:28:55] <sp3d> ("unresolved name `f`")
[03:29:46] <dbaupp> how od
[03:29:47] <dbaupp> d
[03:29:57] <dbaupp> it looks like it is splitting the line, or something
[03:30:04] <dbaupp> acrichto_: ping
[03:30:17] <sp3d> dbaupp: see above for more context; literals are kinda broken
[03:30:36] <dbaupp> sp3d: yeah, I saw it.
[03:30:38] <sp3d> just binary ones from what I can tell though
[03:31:05] <sp3d> all I wanted was syntax highlighting, but I too gazed deep into the rabbit-hole :|
[03:31:06] <dbaupp> ooohh. maybe: the serialisation is printing the float-string (empty) followed by f, leaving `f`.
[03:31:20] <sp3d> ah, maybe
[03:32:54] <acrichto_> dbaupp: pong
[03:33:21] <dbaupp> acrichto_:  ^ (local-rusti fails strangely on `0bf`)
[03:33:36] <dbaupp> is my explanation possibly correct?
[03:34:01] <dbaupp> is it a known bug that the ast can't be printed with '%?'?
[03:34:32] <dbaupp> ('task failed at 'enum value matched no variant', /home/huon/rust/src/libstd/repr.rs:534')
[03:34:35] *** Quits: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net) (Client exited)
[03:34:54] <acrichto_> dbaupp: oh dear RUST_LOG=rusti isn't very useful
[03:35:07] <acrichto_> it uses pp or other to print the ast though
[03:35:19] <acrichto_> and rustc --pretty normal print 0bf and not like "0b f"
[03:35:33] <dbaupp> rusti: stringify!(0bf)
[03:35:35] -rusti- "f"
[03:35:56] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[03:36:09] <acrichto_> that may have something to do with it...
[03:36:43] <acrichto_> dbaupp: oh argh debug! printing is turned off by default now :(
[03:36:51] <dbaupp> :( sorry
[03:36:51] <acrichto_> I'm gonna miss that
[03:38:01] <dbaupp> (you can build with ./configure --enable-debug)
[03:38:59] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[03:39:08] <acrichto_> dbaupp: sp3d: feel free to open an issue, rebuilding will take some time
[03:39:33] <dbaupp> sp3d: (you can, if you want.)
[03:41:34] <acrichto_> dbaupp: btw you were right about opt-lang-items breaking linking
[03:41:50] <acrichto_> dbaupp: although apparently there's also runtime segfaults if you link to a crate which was built with #[no_std]
[03:42:07] <dbaupp> acrichto_: oh, with the opt-lang-items, or before that?
[03:42:10] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[03:42:14] <graydon> is there a deriving(Clone) ?
[03:42:17] <dbaupp> yes
[03:42:31] <acrichto_> dbaupp: opt-lang-items caused an ICE, fixing that leads to a segfault
[03:42:39] <bblum> graydon: there is a deriving for each thing in libsyntax/ext/deriving/
[03:42:40] <acrichto_> dbaupp: not sure if it was there before
[03:42:44] <graydon> ok
[03:42:49] <dbaupp> graydon: http://static.rust-lang.org/doc/rust.html#deriving has a list
[03:42:50] <bblum> deriving clone is basically great
[03:42:53] <dbaupp> (or the source)
[03:43:18] <dbaupp> acrichto_: I'll test
[03:43:23] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[03:43:35] <dbaupp> acrichto_: anything other than #[no_std]; (and zero.rs, I guess)?
[03:43:56] <acrichto_> dbaupp: fn foo() {}
[03:45:04] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[03:45:18] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[03:45:45] *** Parts: poiru (poiru@moz-FA10A1CD.fi) ()
[03:46:02] <dbaupp> acrichto_: I get linker errors :S
[03:46:09] <acrichto_> what are they?
[03:46:17] <dbaupp> undefined reference to `zero::start::_2f80cee48b6a9562::_0$x2e0'
[03:46:31] <dbaupp> and zero::annihilate::...
[03:46:39] <acrichto_> weird
[03:46:49] <dbaupp> maybe I'm doing something wrong
[03:47:03] <acrichto_> oh well I guess I also didn't mention that I'm linking to a file which does have libstd
[03:47:10] <dbaupp> oh, I need `pub mod zero;`
[03:47:21] <acrichto_> so I'm building libfoo with #[no_std], then bar.rs has 'extern mod foo' but uses std
[03:47:27] <acrichto_> in theory that should work
[03:47:32] <acrichto_> but bar.rs should also work with #[no_std]
[03:47:52] <dbaupp> all the lang items have duplicate entry complains
[03:47:59] <dbaupp> *complaints
[03:48:26] <acrichto_> what if they both have #[no_std]? link errors?
[03:48:45] <dbaupp> no, it works fine with pub mod zero (but link errors with just mod zero)
[03:48:54] <dbaupp> and it runs without segfaulting
[03:49:13] <acrichto_> interesting
[03:50:40] <acrichto_> dbaupp: aha! it currently works if both have #[no_std]
[03:50:59] <acrichto_> I may have a fix for when the main program has std, and the crates have #[no_std] though
[03:51:17] <dbaupp> cool! including the .each_item ICE?
[03:51:31] <acrichto_> yes
[03:51:44] <graydon> we should write a deriving(new) :)
[03:52:07] *** Joins: pcwalton (pcwalton@moz-481A040C.hsd1.ca.comcast.net)
[03:52:07] *** ChanServ sets mode: +o pcwalton
[03:52:23] <acrichto_> graydon: that's kinda deriving(Zero), but not quite
[03:52:26] <dbaupp> graydon: there's Zero which things like HashMap support
[03:52:29] *** Quits: pcwalton (pcwalton@moz-481A040C.hsd1.ca.comcast.net) (Input/output error)
[03:52:40] <graydon> no, I mean, one that writes a pass-all-the-args ctor
[03:52:45] <dbaupp> oh
[03:52:45] <graydon> I write quite a number of those
[03:52:50] <dbaupp> neat
[03:52:59] <graydon> fn new(a,b,c) -> T { T { a: a, b: b, c: c } }
[03:53:00] <dbaupp> I'm currently improving deriving, so I'll add that
[03:53:06] <graydon> it's a boring function to write :)
[03:54:02] <graydon> though ... I guess _often_ it's not quite like that. often includes a few other bits (a clone call, a by-ref vs. by-ownership change, a sub-constructor-call)
[03:54:33] <dbaupp> so maybe not?
[03:55:13] <acrichto_> osx gdb is so bad by default :(
[03:55:21] <acrichto_> *old
[03:56:47] <graydon> huh
[03:56:56] *** Quits: anri (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net) (Ping timeout)
[03:56:57] <graydon> deriving(Clone) is giving me some grief
[03:57:05] <dbaupp> do you have a & pointer?
[03:57:07] <graydon> maybe I want deepclone
[03:57:08] <graydon> ?
[03:57:10] <graydon> um
[03:57:20] <graydon> yes
[03:57:22] <dbaupp> what's the data structure/error?
[03:57:30] <graydon> no. maybe.
[03:57:51] <graydon> it's complaining that one of the fields in the struct is T when it expected &T
[03:57:57] <graydon> one of the _fields_
[03:57:57] <graydon> hmm
[03:57:59] <acrichto_> graydon: https://github.com/mozilla/rust/issues/7724
[03:57:59] *** Quits: jfbk (textual@moz-EEA9CFB3.nyc.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[03:58:00] <dbaupp> auto-deref interacts very badly with pointers and macros... no way to turn it off/specify that you actually want the impl to be
[03:58:19] <graydon> ok
[03:58:20] <dbaupp> (i.e. which type's impl you want the method from)
[03:58:30] <graydon> so the real error is the inner thing has no Clone
[03:58:47] <graydon> except the inner thing _does_ have clone
[03:59:04] <acrichto_> oh, then maybe not...
[03:59:06] <graydon> oh, maybe not. I put the deriving(Clone) on the wrong place
[03:59:07] <graydon> eek
[03:59:13] <graydon> ignored attributes. another bug no doubt :)
[03:59:44] <bblum> i think they are ignored inside blocks
[03:59:52] <dbaupp> bblum: yes
[03:59:53] <bblum> and also if you misspell them
[03:59:54] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[03:59:58] * dbaupp is also fixing that atm
[04:00:38] <dbaupp> we should probably have a sidetable that records which attributes are used/not and then lint it.
[04:01:11] <graydon> I'm always a little surprised about the json module
[04:02:36] <graydon> does hashmap not implement clone?
[04:03:07] * graydon wonders if json should be treemap while we're at it. things coming out of json objects in random order seems to cause no end of churn.
[04:03:14] <dbaupp> looks like it doesn't
[04:03:42] <acrichto_> graydon: there's a FIXME about comparing Json maps being super slow, a treemap would make it trivially easy and much faster as well
[04:04:47] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Ping timeout)
[04:04:51] <graydon> oh, yeah, now I know why I'm always confused by the json module
[04:05:34] *** Joins: vk (vk@858480B7.B568D26C.93B001FA.IP)
[04:05:35] <graydon> you can serialize-to-json and you can also toJson something and then serialize _that_
[04:05:47] <graydon> and you get completely different hings
[04:05:48] <graydon> things
[04:06:21] <graydon> but they're both in the same module
[04:06:23] <graydon> very confusing
[04:07:02] *** Joins: strcat1 (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[04:07:05] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[04:07:05] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[04:07:17] *** strcat1 is now known as strcat
[04:07:45] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[04:08:41] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[04:08:43] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[04:09:38] *** Joins: anri (solancile@moz-E49E7C4B.hsd1.wa.comcast.net)
[04:12:43] <strcat> hrm
[04:12:52] <strcat> it seems like ~fn is allocating *two* box headers
[04:12:54] <strcat> maybe I'm wrong
[04:20:22] <dbaupp> does anyone have any complaints about https://gist.github.com/huonw/d3c5c85df45475340555 ?
[04:20:37] <dbaupp> (as an extension to the current #[deriving])
[04:20:55] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (No route to host)
[04:21:09] <graydon> sweet
[04:21:12] <graydon> ship it!
[04:21:21] * graydon half kidding? I dunno, it seems cool
[04:21:28] <strcat> can w be ignored implicitly?
[04:21:30] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[04:21:31] <graydon> and harmless for people who just want "some order"
[04:21:44] <graydon> which is like 9/10 of users. "I need an order so I can use a treemap"
[04:21:50] <graydon> "lexicographic something"
[04:21:51] <sp3d> how does deriving work? are all the derivables hard-coded into the compiler?
[04:21:56] <graydon> sp3d: yes
[04:22:27] <dbaupp> sp3d: currently yes, when syntax extensions become loadable I'm hoping that it'll be changed so that custom deriving's can be loaded
[04:22:39] <acrichto_> dbaupp: you should strictly verify the arguments to Ord() and in theory provide suggestions
[04:22:59] <sp3d> my gut feeling is that it'd be nice if something with domain-specific logic had a little bit more syntactic evidence of that, kinda like foo!()
[04:23:14] <sp3d> but I guess if deriving is always magic more or less anything goes if it's documented
[04:23:25] <graydon> someday it will be external and will compete with http://repetae.net/computer/haskell/DrIFT/ but not today
[04:23:26] <dbaupp> acrichto_: yes, I'm going to have a cmp-option-parser that only recognises test_order, ignore, reverse (and disables ones that don't make sense)
[04:23:40] <dbaupp> acrichto_: and check field names, etc etc.
[04:23:56] <dbaupp> strcat: ignored implicitly?
[04:24:01] <acrichto_> dbaupp: awesome!
[04:24:15] <strcat> dbaupp: it's not used in the order
[04:24:39] <dbaupp> strcat: it could be, but I was assuming that the most common case would be a single field going first
[04:24:53] <strcat> oh
[04:24:58] <dbaupp> and that'd just be #[deriving(Ord(test_order(field)))], rather than having to list everything
[04:25:35] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[04:25:41] <dbaupp> made the pretty printer segfault :(
[04:25:59] <dbaupp> how have I broken this so much?? ... there's no unsafe in libsyntax at all :/
[04:26:22] <strcat> it's a good thing pcwalton is removing ~fn: Copy because I think I probably just broke it
[04:26:30] <strcat> it looks like it was already broken
[04:26:32] <strcat> but...
[04:27:04] <strcat> look at librustc/middle/trans/closure.rs
[04:27:28] <strcat> make_opaque_cbox_take_glue
[04:27:31] * strcat sighs
[04:27:42] <strcat>         let sz = Load(bcx, GEPi(bcx, tydesc, [0u, abi::tydesc_field_size]));
[04:27:44] <strcat>         // Adjust sz to account for the rust_opaque_box header fields
[04:27:46] <strcat>         let sz = Add(bcx, sz, machine::llsize_of(ccx, Type::box_header(ccx)));
[04:27:49] <strcat> afaict... it takes a size and then adds a box header
[04:28:08] <strcat> and then it asks a function *which adds another box header* to allocate that much
[04:28:10] *** Quits: Nisstyre (wes@moz-FD86289.netflash.net) (Quit: Leaving)
[04:28:29] <strcat> I guess that just meant it had unused space at the end
[04:29:22] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[04:29:38] <strcat> or it stores a nested box header on purpose... I doubt it though
[04:29:50] <strcat> (our closures are pretty messed up)
[04:31:55] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[04:32:09] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[04:33:02] *** Joins: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com)
[04:33:41] <strcat> graydon: hrm, it looks like the auto failure might have just been some ephemeral rustpkg git issue
[04:34:21] *** Quits: vk (vk@858480B7.B568D26C.93B001FA.IP) (Quit: vk)
[04:36:04] <dbaupp> A few things passed, so presumably pcwalton finally got all the copy's?
[04:37:19] <dbaupp> acrichto_: does the optional lang item thing allow for overwriting lang items?
[04:37:42] <acrichto_> dbaupp: no, it's just so you don't have to bother with what you don't want
[04:37:49] <acrichto_> you still can't define duplicate lang_items
[04:37:53] <dbaupp> acrichto_: ok, thought so
[04:38:03] <acrichto_> but now it's possible to have a libcore with #[no_std] with things like option/either/vec/str
[04:38:06] <acrichto_> (in theory)
[04:38:14] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[04:38:24] <dbaupp> (it'd be neat if you could overwrite ones from other crates, or something like that.)
[04:38:29] <strcat> and hashmap/deque/priority_queue/treemap ;p
[04:38:37] <strcat> iterators
[04:38:42] <strcat> lots of stuff doesn't need the runtime
[04:38:47] <strcat> actually... hashmap does because of the RNG
[04:38:51] <strcat> the rest don't
[04:38:57] <dbaupp> RNG only needs it for 1 thing
[04:39:04] * dbaupp is fixing that, maybe
[04:39:05] <acrichto_> strcat: oh yes! that would be really nice
[04:39:09] <acrichto_> although they all need ~[]
[04:39:12] <acrichto_> which makes it difficult
[04:39:49] <dbaupp> the other option is to #[cfg(not(no_runtime))] large portions of std, and so it can be built in a reduced format.
[04:40:01] <strcat> http://ix.io/6IJ working on this atm :)
[04:40:13] <strcat> the end of that horrible allocator I had to add
[04:41:12] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[04:43:03] <graydon> shall I turn auto bors again?
[04:44:00] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[04:44:56] *** Joins: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net)
[04:45:49] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[04:46:39] *** Quits: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net) (Ping timeout)
[04:47:08] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[04:47:08] *** ChanServ sets mode: +o dherman
[04:48:26] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[04:49:16] <strcat> graydon: can you make it try pcwalton's stuff in auto again?
[04:49:20] <graydon> sure
[04:49:34] <graydon> I mean .. all it does is build auto
[04:49:37] <graydon> did we get a clean build on auto?
[04:50:00] <strcat> graydon: it hit some rustpkg git failure on one bot
[04:50:09] <graydon> the valgrind bot?
[04:50:14] <strcat> yeah
[04:50:17] <strcat> mac
[04:51:23] <graydon> so I will run 'em all again
[04:51:25] <graydon> and hope it passes
[04:51:29] <graydon> but I'll be asleep when it does
[04:52:12] <graydon> restarted all
[04:52:24] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Ping timeout)
[04:53:53] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[04:54:17] <ChrisMorgan> Any chance someone could approve https://github.com/mozilla/rust/pull/7747? The disussion that has taken place there about having a :RustRun function is a new thing and explicitly out of scope for that PR.
[04:55:50] <dbaupp> ChrisMorgan: have you put your server's code online yet? :)
[04:56:01] <ChrisMorgan> dbaupp: not yet.
[04:58:35] <dbaupp> ChrisMorgan: is https://github.com/dotdash/rust/commit/48cf515ba54cfa289f1b20a3bdc5d5b7ede9739d meant to be part of that PR?
[04:58:48] <dbaupp> oh, that's just a reference!
[04:58:56] <dbaupp> how confusing
[04:59:00] <ChrisMorgan> dbaupp: no, it's a separate matter and has its own PR too.
[04:59:48] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[04:59:49] *** ChanServ sets mode: +o dherman
[04:59:49] <dbaupp> yeah, it's just listed in on the front page of that PR, and looks similar to an actual commit
[04:59:56] * dbaupp has worked out what's up now
[05:00:16] * ChrisMorgan was thrown by it a bit looking at it ten minutes ago
[05:01:30] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[05:01:45] <ChrisMorgan> It's a pity "request" and "response" start with the same letter, you know.
[05:01:57] <dbaupp> hm?
[05:02:16] * dbaupp is missing some context
[05:02:40] <ChrisMorgan> Might be convenient to use a single-character variable name when you're referencing it a lot. Can become a strong convention.
[05:03:57] <ChrisMorgan> Go has gone for "r" for Request and "w" for ResponseWriter. Mine also has Request and ResponseWriter structs.
[05:04:23] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[05:05:11] <dbaupp> oh, I see
[05:06:01] <dbaupp> 't' and 'e'? (resist the first-letter supremacists! :P )
[05:06:28] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[05:06:29] <dbaupp> yeah, r and w make sense to me. (r = reader = input, w = writer = output)
[05:06:51] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[05:07:24] <aatch> y and m, make obfustication part of the API
[05:07:41] <aatch> "It was hard to write, it should be hard to use!"
[05:08:23] <sp3d> q and p
[05:08:35] <dbaupp> Ð° and a
[05:08:41] <sp3d> only sample letters w/ tails
[05:08:43] <dbaupp> (the first is cyrillic)
[05:09:12] * dbaupp loves unicode
[05:09:13] <aatch> _5 _p
[05:09:37] <aatch> (with the added bonus of warning suppression)
[05:11:50] <dbaupp> _ âŸ
[05:12:10] <dbaupp> aatch: have you got the graphics drivers workin'?
[05:12:18] <aatch> dbaupp, haven't has time...
[05:12:23] <aatch> had*
[05:12:33] <aatch> Big new project at work.
[05:12:53] <aatch> which does involve me hacking around in the HipHop source code.
[05:15:22] <dbaupp> ah, interesting?
[05:15:38] <dbaupp> (or is it very hacky?)
[05:15:52] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[05:17:32] *** Joins: bytewise (bytewise@moz-649C630D.unitymediagroup.de)
[05:19:25] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Ping timeout)
[05:20:30] <aatch> dbaupp, pretty interesting.
[05:20:52] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[05:20:56] <aatch> We use PHP where I work, and until recently a specific PHP framework
[05:21:21] <aatch> But we've been pushing the limits on the framework for ~2 years now and it's starting to show
[05:21:40] <aatch> (most obviously with slow page loads that we can't fix)\
[05:22:05] <aatch> So, new codebase, figured that using the faster HipHop VM was a good idea.
[05:22:27] <aatch> unfortunately, we want to use PostgreSQL, but there is no pgsql extension for HipHop
[05:22:40] <aatch> So I'm writing one.
[05:23:22] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[05:23:25] <aatch> The HipHop source code is sooooo much nicer than Zend
[05:23:39] <aatch> probably _because_ it's written in C++
[05:24:05] *** Joins: dew (Instantbir@moz-2C6F2E2.dhcp.stls.mo.charter.com)
[05:25:18] <mcpherrin> aatch: People outside FB use HipHop? (Or are you there?)
[05:25:33] <aatch> mcpherrin, a few people do, but not many. I'm not at FB though
[05:25:53] <aatch> We'll be like the... 5th, 6th?
[05:26:19] <aatch> My experience with rust lends itself well to using under-documented codebases.
[05:26:26] *** Joins: lpapp (lpapp@759BF865.314C6558.9EF092A5.IP)
[05:26:43] <lpapp> hi, can someone explain that on the compiler level what happens for a borrowed pointer?
[05:26:53] <aatch> lpapp, can you be more specific?
[05:27:08] <strcat> at runtime it's just a pointer
[05:27:28] <lpapp> I have been told that there is no runtime overhead
[05:27:33] <strcat> right
[05:27:35] <lpapp> I would like to understand how that can happen.
[05:27:40] <strcat> it's just a pointer at runtime
[05:27:56] <aatch> lpapp, well we statically enforce almost everything
[05:28:07] <strcat> you take a borrowed pointer to a value, it can't outlive that value
[05:28:07] <lpapp> how is it different to const or ref then?
[05:28:10] <strcat> it's statically enforced
[05:28:22] <strcat> it can't ever be dangling
[05:28:29] <strcat> it can't ever point to an invalid object
[05:28:40] <lpapp> just like ref or const?
[05:28:49] <strcat> don't know what you mean by ref or const
[05:28:50] <aatch> lpapp, we have &mut as well that says you are allowed to write through it.
[05:29:02] <aatch> lpapp, with `&` being immutable
[05:29:17] <aatch> lpapp, the reason is because `&mut` has different semantics.
[05:29:29] <aatch> but at runtime there is no difference.
[05:30:08] <lpapp> I do not follow.
[05:30:17] <strcat> lpapp: what do you mean by 'ref or const'
[05:30:20] <strcat> ?
[05:30:21] <lpapp> if it is only a static compiler time check, that is what reference can already do.
[05:30:27] <lpapp> or if you make a const pointer.
[05:30:32] <strcat> a reference where
[05:30:37] <strcat> in what language?
[05:30:42] <lpapp> C++
[05:30:52] <strcat> lpapp: it's trivial for a C++ reference to become dangling/invalid
[05:31:11] <strcat> take a reference into a container, resize it
[05:31:19] <strcat> have a reference that outlives what it pointed at
[05:31:29] <strcat> take a reference inside a tagged union, change the type of the tagged union
[05:31:55] <lpapp> how does the compiler work internally to solve that?
[05:32:03] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[05:32:11] <lpapp> I am mostly wondering if this feature is something that is worth considering for C++ as well in the future, you know.
[05:32:12] <strcat> it enforces that the borrowed pointer can't outlive the value it points at
[05:32:13] <aatch> lpapp, rust has a region system that infers the lifetimes of objects.
[05:32:15] <strcat> it inherits the lifetime
[05:32:26] <strcat> it infers locally within a function
[05:32:33] <lpapp> strcat: how can it enforce?
[05:32:40] *** Quits: lmandel (lmandel@8B192B20.1F93A08E.ADB88A9.IP) (Quit: lmandel)
[05:32:49] <strcat> lpapp: just by making it not escape past where the lifetime would end
[05:32:56] <strcat> it's pretty simple inside a local function, there are scopes
[05:33:09] <strcat> and they can be used more than locally
[05:33:17] <strcat> because you can annotate function signatures with named lifetimes
[05:33:17] <aatch> and between functions you have to provide extra lifetime info
[05:33:34] <strcat> lpapp: http://static.rust-lang.org/doc/tutorial-borrowed-ptr.html
[05:34:49] <strcat> and statically enforced freezing prevents reference/iterator invalidation
[05:34:59] <strcat> for example in the resizing a container or changing a tagged union type cases
[05:36:00] <strcat> immutable borrowed pointers are a different concept from const
[05:36:10] <strcat> const means read-only *through that reference*, it can still be mutated
[05:36:19] <strcat> through another handle
[05:36:38] <strcat> so it would be unsafe to take references deeper inside, since they could be invalidated externally
[05:36:47] <eevee> can i have a struct that contains both an object x and another object y that borrows from x
[05:37:29] <aatch> eevee, maybe, but it'd be difficult
[05:38:40] <eevee> i have a Terminal and it can spin off a Canvas which needs to borrow the terminal so it knows what to write to
[05:38:41] <lpapp> the problem is that with the tutorial in my case that, it only presents the API
[05:38:55] <lpapp> so a geek like me cannot understand how it is solved on the compiler level.
[05:38:59] *** Quits: geomyidae (cole@DD6F7E3A.21468E9A.30200F38.IP) (Quit: Konversation terminated!)
[05:39:06] <lpapp> it is not that clear how it would be even possible.
[05:39:13] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[05:39:19] <eevee> and now i want to hold onto a few Canvases persistently, but i need to keep the Terminal around, but i cannot seem to tell rust that the pair of them are hanging around together
[05:39:22] <aatch> lpapp, it's pretty simple actually. All objects have a defined lifetime.
[05:39:34] <strcat> lpapp: objects have owning variables, the variable goes away at the end of the scope
[05:39:47] <lpapp> yes
[05:39:47] <aatch> even C++ has this information (hence RIAA)
[05:39:49] <strcat> the reference inherits the lifetime from what it points at, it can't escape outside that scope
[05:39:51] <strcat> that's all
[05:40:07] <lpapp> but it is not like you know until runtime whether another place would like to modify that variable.
[05:40:13] <aatch> (RAII rather)
[05:40:16] <lpapp> if you guarantee a copy, that is a memory overhead
[05:40:20] <strcat> lpapp: you do, rust tracks mutability statically
[05:40:36] <lpapp> strcat: but how can a native compiler do that?
[05:40:40] <strcat> mutability is inherited down the whole owned tree
[05:40:43] <lpapp> what is the background asm logic?
[05:40:51] <strcat> lpapp: there isn't background logic, it's done at compile-time
[05:40:54] <aatch> lpapp, there is none
[05:41:02] <aatch> lpapp, except for @mut
[05:41:05] <lpapp> aatch: C++ only has semi-raii
[05:41:12] <strcat> lpapp: variables are mutable or immutable
[05:41:16] <strcat> everything they own inherits that
[05:41:27] <strcat> rust knows the top-level owners, and it knows their scope
[05:41:33] <strcat> so it knows the lifetime of every value
[05:41:56] <aatch> the only exceptions are `@`/`@mut`
[05:42:05] <strcat> @ still has entirely static borrowing
[05:42:06] <lpapp> strcat: well, C++ also has also const non-cost differentiation of course.
[05:42:10] <strcat> because it's known to be immutable
[05:42:20] <strcat> lpapp: const references are immutable objects though
[05:42:28] <strcat> the object is immutable *through* the reference
[05:42:37] <strcat> aren't immutable objects*
[05:42:39] <strcat> silly typo
[05:42:58] <lpapp> yes
[05:43:01] <strcat> rust has a concept of 'const' too but it might end up removed because it hasn't proven to be useful anywhere
[05:43:05] <dbaupp> aatch: @ has 'task lifetime
[05:43:09] <dbaupp> (I guess.)
[05:43:10] <lpapp> but how can a compiler guarantee this? I still do not follow.
[05:43:17] <strcat> lpapp: how can it guarantee what?
[05:43:23] <aatch> lpapp, ownership semantics.
[05:43:23] <lpapp> to become valid
[05:43:26] <strcat> what specific thing?
[05:43:34] <lpapp> say, there is another data path, where it might me modified
[05:43:40] <lpapp> it is figured out during the run time.
[05:43:44] <strcat> lpapp: no, it isn't
[05:43:47] <lpapp> not much the compiler can do about it, really.
[05:43:51] <dbaupp> aatch: also, nice, re hiphop
[05:43:59] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[05:44:04] <aatch> lpapp, then the compiler will reject the program
[05:44:17] <strcat> lpapp: if there are two paths of flow control and it's modified in one, then it assumes it will be modified
[05:44:22] <lpapp> aatch: why would it reject if it is not modified?
[05:44:24] <strcat> but that's not very relevant to lifetimes
[05:44:27] <lpapp> you cannot really know until the runtime.
[05:44:43] <strcat> lpapp: because it enforces memory safety without runtime checks
[05:44:46] <strcat> that's just what it does
[05:44:52] <aatch> lpapp, because if it _might_ be modified, then it needs to be mutable.
[05:45:02] <lpapp> ok, that is not too smart.
[05:45:03] <dbaupp> lpapp: the compiler knows every function that "requests" mutability, and assumes that any function that does so can modify it (and so, to be safe, it assumes that it is.)
[05:45:38] <aatch> lpapp, except it's what allows us to assert that any Rust program that segfaults (without using unsafe) indicates a bug in the compiler
[05:45:58] <strcat> 'segfault' is the *best* thing that could happen from memory unsafety, a quick death
[05:46:02] <lpapp> you limit yourself.
[05:46:10] <lpapp> even if it was not modified, you take it like that.
[05:46:29] <strcat> lpapp: otherwise it would have to add runtime checks and there would be dynamic failure cases
[05:46:30] <aatch> There is no difference in safety between a function that might modify and a function that does.
[05:46:44] <lpapp> strcat: exactly what shared pointer does, yes.
[05:46:46] <strcat> lpapp: I'm not sure we're really talking about the same thing
[05:47:19] <lpapp> well, I thought a bit more about this feature.
[05:47:24] <aatch> lpapp, exactly, we have a single, somewhat uncommon, case that has runtime checks.
[05:47:24] <lpapp> but it is apparently less than I thought.
[05:47:44] <lpapp> so it is basically just a very specific case when you accept that, it might not be modified at all, but you wanna safety either way.
[05:48:04] <strcat> it knows whether or not something is mutable
[05:48:15] <strcat> it doesn't have to consider if something 'might' be modified
[05:48:22] <lpapp> yes, but mutable does not mean, it will be modified.
[05:48:46] <aatch> lpapp, but the compiler can't know that. How do you deal with functions in other crates in that case?
[05:48:57] <strcat> lpapp: you wouldn't take something as &mut if you weren't ever going to modify it
[05:49:04] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[05:49:09] <strcat> if you take it as &mut you have a path where you modify it
[05:49:30] <strcat> if the compiler assumed you didn't.... it would have to insert a *dynamic failure* instead of giving you errors at compile-time
[05:49:33] <lpapp> aatch: correct
[05:49:51] <lpapp> 06:49 < strcat> lpapp: you wouldn't take something as &mut if you weren't ever going to modify it -> I am not saying, it is not going to be modified
[05:49:55] <lpapp> sometimes it might be.
[05:50:05] <aatch> lpapp, I'm not sure what your point is.
[05:50:07] <strcat> okay, and there's no difference between 'sometimes' and 'always'
[05:50:07] <lpapp> it is the matter of the runtime operation.
[05:50:11] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[05:50:16] <strcat> lpapp: it's not, because that would turn into a runtime failure
[05:50:17] <lpapp> aatch: the point is, it is not a fully fledged feature
[05:50:30] <lpapp> sure, it might help some people, but one needs to understand the limitations as well.
[05:50:30] <aatch> lpapp, but it is, it's one of the most mature features in Rust
[05:50:58] <aatch> lpapp, the limitations are that you can reason much better about the safety of your application.
[05:50:59] <lpapp> no no
[05:51:02] <strcat> lpapp: if you want a dynamic failure if you do modify it, you can use Cell
[05:51:03] <lpapp> it has clear limitation
[05:51:06] <strcat> the choice to have dynamic failure is there
[05:51:18] <lpapp> you will get a compiler error even if practically there is nothing wrong with a use case.
[05:51:30] <aatch> lpapp, yes. Which is good.
[05:51:36] <lpapp> good for you, yes...
[05:51:38] <strcat> Cell acts as an immutable type but allows you to mutate the contents
[05:51:53] <strcat> if you do something wrong, it does a dynamic failure
[05:51:59] *** Joins: fabiand (fabiand@moz-8C5E098B.adsl.alicedsl.de)
[05:52:01] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Input/output error)
[05:52:07] <lpapp> strcat: I know there is a dynamic choice.
[05:52:14] <aatch> lpapp, because otherwise somebody can do something wrong and get a failure.
[05:52:19] <lpapp> since you cannot do anything else for smarter things.
[05:52:36] <strcat> lpapp: the borrow checker does do control flow analysis, etc.
[05:52:36] <lpapp> strcat: I am just saying, someone should not look at this feature as the most intelligent.
[05:52:40] <lpapp> it is a compromise.
[05:52:52] <strcat> everything in language design is a compromise ;p
[05:52:54] <lpapp> baring in mind what you can do on the compiler level.
[05:53:12] <strcat> lpapp: it could do a lot more if it wasn't meant to be a set of simple rules
[05:53:19] <strcat> but it explicitly only does local analysis
[05:53:25] <strcat> so that the errors are easy to understand
[05:53:34] <strcat> and so it doesn't make compiles slow
[05:53:35] <aatch> lpapp, ever seen Haskell type errors?
[05:53:45] <lpapp> aatch: no
[05:54:15] <aatch> lpapp, not good, because type inference in Haskell is whole-program
[05:54:27] <lpapp> to me it seems, it would be nice to add this feature to the upcoming C++ standards or TRs.
[05:54:39] <lpapp> it is not really bound to rust in theory.
[05:54:49] <lpapp> I do not see a technical limitation why C++ could not specify this.
[05:55:06] <aatch> lpapp, it's not, but if it isn't in C++ now, it's not likely to be. The theories are very old.
[05:55:22] <lpapp> why not likely?
[05:55:30] <strcat> lpapp: because it would mean making a whole new stdlib
[05:55:31] <strcat> with new APIs
[05:55:33] <lpapp> range based cases are not there.
[05:55:38] <lpapp> or getting half tuples.
[05:55:41] <lpapp> concept, modules, etc
[05:55:45] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[05:55:49] <lpapp> old theory does not mean it is a bad theory.
[05:55:52] *** Joins: Uther (Instantbir@moz-1B244B05.hfc.dyn.abo.bbox.fr)
[05:55:56] <lpapp> if it is not yet present.
[05:56:15] <lpapp> strcat: why would it?
[05:56:17] <strcat> they would need to add 2 new pointer types (unlikely) and then add them throughout the stdlib
[05:56:33] <lpapp> not entirely sure what you mean.
[05:56:47] <strcat> lpapp: rust's borrowed pointers have different semantics than C++ references
[05:57:10] <lpapp> 2 new pointer types?
[05:57:13] <strcat> lpapp: yes
[05:57:15] <lpapp> we are discussing only one.
[05:57:20] <lpapp> what would be the second?
[05:57:22] <strcat> lpapp: we are discussing two
[05:57:29] <strcat> &, an immutable borrowed pointer
[05:57:32] <strcat> &mut, a mutable one
[05:57:33] *** Quits: duckinator (nick@moz-74B346B5.mostlyincorrect.info) (Ping timeout)
[05:57:36] <strcat> the semantics are different
[05:57:54] *** Quits: toshok (toshok@moz-67C55A1F.com) (Ping timeout)
[05:57:54] <lpapp> what is the point of a mutable borrowed pointer?
[05:58:03] <lpapp> why would stl need to add this anyway to the API?
[05:58:03] *** Quits: jack (jack@moz-DF5A9AA3.members.linode.com) (Ping timeout)
[05:58:10] <lpapp> it is not like the stl api is full of smart pointers.
[05:58:15] <lpapp> they still operate with raw pointers.
[05:58:15] <strcat> they aren't smart pointers
[05:58:20] *** Joins: geomyidae (cole@DD6F7E3A.21468E9A.30200F38.IP)
[05:58:32] <strcat> lpapp: it uses references
[05:58:35] <strcat> heavily
[05:58:50] <lpapp> so ... ?
[05:58:52] <aatch> lpapp, you can have multiple immutable borrows, but only one mutable borrow (and it must be the *only* borrow).
[05:59:00] *** Joins: toshok (toshok@moz-67C55A1F.com)
[05:59:09] <strcat> well &mut can alias with &const, but &const is pretty pointless
[06:00:08] <lpapp> well, mutable or not, it is still one type
[06:00:15] <aatch> lpapp, nope, different types
[06:00:16] <lpapp> of course you can have const and non-const in C++ as well.
[06:00:18] <strcat> lpapp: it's two very different types
[06:00:22] <strcat> lpapp: it's not related to const
[06:00:48] <strcat> C++ would need the concept of immutable references (different than const references)
[06:00:48] <lpapp> why not?
[06:00:58] <strcat> lpapp: because const means immutable through that reference
[06:01:04] <strcat> the object can still be mutated through another handle
[06:01:10] <lpapp> yeah, that is what I was just thinking of.
[06:01:22] *** Joins: jack (jack@moz-DF5A9AA3.members.linode.com)
[06:01:24] <strcat> rust technically has &, &mut and &const
[06:01:27] <strcat> but...
[06:01:29] <lpapp> so what is the point of mutable borrowed pointer?
[06:01:29] <strcat> &const hasn't really found any use cases
[06:01:39] <lpapp> the whole point of borrowed pointer was to defend its modification
[06:01:44] <lpapp> prevent*
[06:01:51] <strcat> lpapp: not really 'the whole point'
[06:02:00] <aatch> lpapp, no, the whole point is to allow access without taking ownership
[06:02:14] <strcat> the point is you can take any number of overlapping & references to an object
[06:02:21] <strcat> and they are just references, no runtime machinery
[06:02:30] <strcat> the restrictions are in place to make it memory safe
[06:02:33] <lpapp> you can already do that with weak pointers.
[06:02:45] <strcat> weak pointers have a dynamic failure case and heavy runtime overhead
[06:02:57] *** Joins: duckinator (nick@moz-74B346B5.mostlyincorrect.info)
[06:03:21] <lpapp> well, to me it sounds perfect, to add an immutable concept to C++
[06:03:27] <lpapp> I do not see why it would be useless ....
[06:03:34] <strcat> it wouldn't be useless
[06:03:34] <lpapp> actually, I think it would be a big step ahead.
[06:03:34] *** Joins: mib_90k09k (Mibbit@moz-85EBF7FC.range86-129.btcentralplus.com)
[06:03:54] *** Quits: mib_90k09k (Mibbit@moz-85EBF7FC.range86-129.btcentralplus.com) (Quit: http://www.mibbit.com ajax IRC Client)
[06:03:55] <lpapp> probably no one took the opportunity to work out a proposal in favor of "more important" features.
[06:04:40] <strcat> the immutable part is just one of the restrictions on &
[06:05:19] <lpapp> yeah, but it should be doable with whatever syntax.
[06:05:25] <strcat> the compiler still has to track/infer lifetimes and handle scopes where objects are 'frozen'
[06:05:35] <lpapp> I mean, in worst case scenario, borrowed stuff could live alongside the reference semantic.
[06:05:57] <strcat> and guarantee objects are valid
[06:05:58] <strcat> so...
[06:06:10] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[06:06:12] <strcat> track flow control + where objects are initialized + where they are moved from
[06:06:58] <aatch> add in bounded lifetimes.
[06:07:02] *** Joins: strcat1 (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[06:07:16] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[06:07:54] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[06:07:58] *** strcat1 is now known as strcat
[06:08:06] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[06:09:16] <lpapp> mind you if I publish a summary of this conversation on my blog post?
[06:09:24] <lpapp> http://lpapp.blogspot.ie/2013/07/c-and-compile-time-guaranteed-pointer.html
[06:09:24] <lpapp> here
[06:10:15] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[06:14:07] *** Quits: cowboyd (cowboyd@moz-DD0FF83.lightspeed.austtx.sbcglobal.net) (Client exited)
[06:15:21] *** Joins: cowboyd (cowboyd@moz-DD0FF83.lightspeed.austtx.sbcglobal.net)
[06:17:35] <graydon> valgrind passed
[06:17:49] <graydon> I think I'll turn bors back on shortly
[06:17:53] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[06:17:59] <graydon> gosh this SIMD stuff is just way over my head :(
[06:18:40] * jensnockert hugs graydon.
[06:19:11] <graydon> jensnockert: what was the .. problem with what sanxiyn was doing?
[06:19:56] <graydon> just that it produces too many new struct names?
[06:19:58] <jensnockert> graydon: Well, this would bring it in line with sanxiyn's original PR, plus some extra features.
[06:20:12] <jensnockert> graydon: Not only that, but that we need to generate new ones in trans.
[06:20:35] <graydon> because ..
[06:21:31] <jensnockert> Because a swizzle of a vector has a (possibly) different type than the original type, but no type declaration.
[06:21:36] <graydon> #[simd] struct vec4<T> (T,T,T,T); is no good?
[06:21:54] <graydon> can you be super clear on what a swizzle is? I don't know about it
[06:22:10] <jensnockert> A reshuffle of the elements.
[06:22:36] <graydon> so I know that SIMD units have shuffle operations
[06:22:37] <jensnockert> For example a.s3210 would get the 4th, 3rd, 2nd and 1st element, in that order.
[06:23:03] <graydon> but isn't that going to produce another vec4 (or some other vecN type)?
[06:23:21] <jensnockert> Yes, or some other vecN type.
[06:23:22] <graydon> IOW don't we just wind up with vec1 .. vec16 say, plus a whole lot of methods to effect shuffles?
[06:23:45] <graydon> what's the s up front on the swizzle operation?
[06:24:03] <graydon> s means shuffle and extract short as well?
[06:24:03] *** Quits: igl (igl@moz-65234DC8.adsl.alicedsl.de) (Connection reset by peer)
[06:24:05] <graydon> or ..
[06:24:09] <graydon> just s means swizzle
[06:24:11] <jensnockert> graydon: Just OpenCL notation that you want to use numeric indices.
[06:24:14] <graydon> ok
[06:24:17] <jensnockert> The default is xyzw.
[06:24:29] <lpapp> strcat: aatch thank you for your time and help.
[06:24:50] <graydon> I mean certainly you will wind up with um O(N^2) methods on each vecN if we do it the simplest way
[06:24:58] <jensnockert> graydon: The problem is that with AVX we would need up to vec32, and on Xeon Phi, up to vec64.
[06:25:04] <graydon> 64 eh?
[06:25:10] <graydon> that's some vector!
[06:25:15] <jensnockert> graydon: It is actually 17!
[06:25:33] <graydon> how's that?
[06:25:41] <jensnockert> Well, technically infinite.
[06:25:53] <jensnockert> All orderings, for all sizes.
[06:25:58] <graydon> ok ok
[06:26:01] <graydon> so let's back off a sec here
[06:26:14] <jensnockert> Sure.
[06:26:27] <graydon> suppose we make methods-on-#[simd] magic and accept .sNNNNNNN in a fallback mode
[06:26:29] <graydon> as you suggest
[06:26:33] <jensnockert> Yes.
[06:26:59] <graydon> can we live with tuple-struct vecs? presumably only in the powers-of-2 between 2 and 64
[06:27:16] <graydon> that's only 6 new types
[06:27:32] <graydon> vec2, vec4, vec8, vec16, vec32, vec64
[06:27:45] <jensnockert> vec3 is probably required as well, but it is acceptable.
[06:28:44] <graydon> I mean, to what extent are you wincing saying that? I don't want to be a total jerk about it, just .. trying to keep from adding first class tycons. they affect a fair bit.
[06:29:00] <jensnockert> tycons?
[06:29:14] <graydon> type constructors. <a,b,c> for example
[06:29:18] <jensnockert> Ah.
[06:29:30] <graydon> all the representations-of-types everywhere in the toolchain have to learn about them
[06:29:44] <graydon> it's a bit of a thing to do. we've been trying to make the set of tycons go down over time.
[06:29:56] *** Quits: aatch (aatch@moz-B437F499.pocketrent.com) (Client exited)
[06:29:58] <graydon> we used to have quite a few too many, you may recall :)
[06:29:59] <strcat> evil expr.rs
[06:30:10] <jensnockert> graydon: We still do ;)
[06:30:13] <graydon> yeah
[06:30:15] <graydon> arguably so
[06:30:24] <graydon> (not as bad as some languages, but..)
[06:31:20] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[06:31:57] <jensnockert> I don't think that they actually need constructors though.
[06:32:06] <graydon> jensnockert: what do you mean?
[06:32:07] *** Quits: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca) (Quit: Leaving)
[06:32:34] <jensnockert> graydon: As I implemented, you would just cast a fixed-size vector to a SIMD type when you need one.
[06:33:07] <pnkfelix> graydon: I will assume that you don't actually need my triage emails given the explanation I posted in the comments.  Let me know if you still want to see them
[06:33:24] <graydon> jensnockert: I'm confused. ty_simd_vec is the constructor. do you think it should exist, or not?
[06:33:36] <jensnockert> graydon: Oh, sorry, I misunderstood.
[06:34:46] <jensnockert> graydon: It would be possible, but you would need to be able to go from VecN1 to VecN2 in trans.
[06:35:03] <graydon> "go from"?
[06:35:21] <graydon> you mean like if two different people define #[simd] Vec4<T> ?
[06:35:47] <jensnockert> graydon: As in, if you have a type VecN1, and someone performs a shuffle operation on it, you need to be able to get the VecN2 type somewhere.
[06:36:15] <bblum> it seems like simd should not be something users can arbitrarily use
[06:36:21] <bblum> as some things cannot be simdeed
[06:36:44] <bblum> maybe more like a bunch of lang item types
[06:37:07] <jensnockert> bblum: LLVM can just turn SIMD types the processor doesn't support into scalar operations.
[06:37:09] <graydon> jensnockert: I believe if we went this route it'd be more like #[lang(simd4)] struct Vec<4>(T,T,T,T) and the automatically-provided swizzles would look up their result type in the lang-items table
[06:37:26] <graydon> would that suffice?
[06:37:33] *** Parts: lpapp (lpapp@759BF865.314C6558.9EF092A5.IP) ()
[06:37:57] <graydon> 6 new lang items with Extreme Magic on their method suite
[06:38:02] <jensnockert> #[lang(simd4)] struct Vec4(T, T, T, T) ?
[06:38:10] <graydon> yeah. you know lang items?
[06:38:21] <jensnockert> Yes, I just wondered if the <4> was special in some way.
[06:39:09] <strcat> graydon: maybe you could send another email with the triage bugs that expired
[06:39:13] <graydon> well, I'm supposing we defined 6 new types this way, lang item simd2 called Vec2, lang item simd4 called Vec4, etc. etc.
[06:39:18] <bblum> can type-level naturals help here
[06:39:27] <bblum> https://gist.github.com/bblum/3885017
[06:39:38] <graydon> could call it lang item vec2 .. vec64 instead
[06:39:59] <pnkfelix> strcat: so that people feel guilty for not getting to them?  :(
[06:40:00] <jensnockert> Names are not important here, imho.
[06:40:14] *** Quits: geomyidae (cole@DD6F7E3A.21468E9A.30200F38.IP) (Connection reset by peer)
[06:40:50] <strcat> pnkfelix: well you're not supposed to feel guilty ;p
[06:41:01] <jensnockert> We cannot parse a type like #[simd] [T, ..n] yet, right?
[06:41:06] <graydon> jensnockert: are you following the idea though? we'd hook in 6 new lang items with names "vec2", "vec4", "vec8", etc. each of which is a tuple-struct
[06:41:15] <jensnockert> graydon: I think so.
[06:41:30] <pnkfelix> strcat: Another option is maybe bugs should not be renominated for triage until a longer period had passed.  Both options would require the triage script to keep some internal state from week to week; less for your suggestion, but still some.
[06:41:33] <graydon> also worth noting that you could try to generate the shuffles from destructuring assignment
[06:42:17] <jensnockert> graydon: Yes, but to do that I think we might have to rewrite half of trans.
[06:42:20] <graydon> let foo = Vec4(a,b,c,d); let Vec4(c,b,b,a) = foo;
[06:42:36] <graydon> yeah. not sure it's worthwhile trying to recognize.
[06:42:43] <graydon> besides, that unpacks them
[06:42:45] <dbaupp> graydon: it'd probably have to be let new_foo@Vec(c,b,b,a) = foo, or something?
[06:42:45] <graydon> you want a shuffle
[06:42:55] <jensnockert> graydon: Essentially the same thing.
[06:43:25] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[06:43:47] <doomlord> haswell / gather 
[06:43:52] <graydon> yeah, I guess dbaupp has the idea right, an @-pattern
[06:43:57] <graydon> anyway, I gotta get laundry and go to sleep
[06:44:02] * jensnockert hugs graydon.
[06:44:15] <graydon> :) hope we find something satisfactory
[06:44:26] <graydon> I feel bad discussing it because it's like .. the kind of code I just have zero experience writing
[06:44:33] <doomlord> tuples prefered to structs and [T,..4] for simd ?
[06:44:51] <jensnockert> graydon: To compensate I have almost zero experience with compilers.
[06:45:10] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[06:45:14] <dbaupp> jens-don has 100% experience with both!
[06:45:15] <jensnockert> doomlord: No, tuple-structs is what is discussed here.
[06:45:16] <graydon> I think we wound up thinking structs in https://github.com/mozilla/rust/pull/5841 and https://github.com/mozilla/rust/pull/6214
[06:45:23] <graydon> (tuple structs)
[06:45:38] <graydon> so this is why the current round of jensnockert's work struck me as a bit of a surprise
[06:45:43] <doomlord> tuple structs sorry.. its true that simd code does sort of get away from the .x ,.y , .z way of thinking  lot of the time
[06:45:43] <graydon> if it's just accidental divergence, no worries
[06:45:50] <graydon> i wasn't sure if it's like "NO WE MUST DO IT THIS OTHER WAY"
[06:46:00] <dbaupp> rusti: #[test_the_parser] type Foo = int;
[06:46:03] -rusti- ()
[06:46:08] <jensnockert> graydon: It isn't, but I just couldn't get the current path to work at all.
[06:46:08] <graydon> in which case I am curious which bits are essential, which would just be nice, which are maybe not so important, just accidental
[06:46:45] <jensnockert> graydon: Since I couldn't create new types at compiletime, but langitems would solve that, I think.
[06:46:48] <graydon> jensnockert: what do they do for swizzles selecting elements from 64-element vectors?
[06:46:54] <strcat> hide it behind a -Z flag and you don't have to get it right the first few times ;p
[06:46:55] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[06:47:07] <graydon> .s34_43_12?
[06:47:10] <jensnockert> graydon: In OpenCL you would have to nest them.
[06:47:26] <jensnockert> a.hi.hi.sF
[06:47:32] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[06:47:49] <graydon> oh, so the maximum openCL thing is 8 elements long?
[06:48:01] <jensnockert> It only has syntax for 16 items.
[06:48:09] <dbaupp> hex works?
[06:48:14] <graydon> hex up to 16. haha.
[06:48:32] <jensnockert> graydon: Mostly because 16 float items is large enough.
[06:48:51] <graydon> but you can only grab 16 elements out in a single shuffle that way?
[06:49:06] <graydon> I can't do a 64-to-64 element shuffle on a phi
[06:49:17] <pnkfelix> graydon: is the tree still closed?
[06:49:22] <pnkfelix> oh duh
[06:49:29] * pnkfelix needs to learn to read subject lines of channel
[06:49:34] <graydon> http://buildbot.rust-lang.org/tgrid?branch=auto&refresh=15 is all green
[06:49:38] <graydon> time to reopen!
[06:49:47] <strcat> nice
[06:49:49] *** Joins: jaen (jaen@moz-21C35F3C.play-internet.pl)
[06:50:01] <jensnockert> graydon: It has a shuffle function if you want such wide shuffles.
[06:50:05] *** graydon changes topic to 'http://www.rust-lang.orgÂ | logs at https://botbot.me/mozilla/rust/ and http://irclog.gr/#browse/irc.mozilla.org/rust | http://huonw.github.io/isrustfastyet/mem/ | landings http://buildbot.rust-lang.org/bors/bors.html'
[06:50:16] <graydon> jensnockert: ok
[06:50:28] <graydon> gotta go get laundry. lmk if bors does something zany while I'm out.
[06:50:31] <jensnockert> graydon: And you can concatenate vectors in OpenCL.
[06:50:47] * jensnockert hugs graydon again.
[06:51:03] * strcat is reminded of C++'s nightmarish tuple metaprogramming
[06:51:08] <dbaupp> jensnockert: i.e. SIMD<4> ++ SIMD<2> => SIMD<6>?
[06:51:21] <jensnockert> dbaupp: I would prefer ||, but yes.
[06:51:29] <jensnockert> OpenCL just uses cast syntax.
[06:51:37] <jensnockert> (uint4)(a, b)
[06:51:44] * dbaupp was using the first operator for concat that he thought of
[06:51:47] <strcat> http://en.cppreference.com/w/cpp/utility/tuple/tuple_cat *shudder*
[06:51:52] <jensnockert> But I doubt that is an option in Rust.
[06:52:06] <dbaupp> simd_concat!(a,b) would be
[06:52:10] * strcat has a failed attempt to make a nicer form of boost::variant lying around
[06:52:13] <dbaupp> but overloading operators would work too
[06:52:42] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[06:52:42] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/KjRW1A
[06:52:42] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[06:53:02] <strcat> hrm
[06:53:47] <strcat> dbaupp: https://github.com/mozilla/rust/pull/7842 r? just the last 3 unreviewed ones
[06:56:08] <strcat> I think there's something horribly wrong with glue for @ ;p, didn't figure it out yet
[06:56:15] <dbaupp> hm, simd_concat! would require deep compiler trickery to be any more use than just a function/operator
[06:56:24] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[06:57:14] <strcat> this all seems to push heavily at the limits of the type system ;p
[06:57:37] <dbaupp> always!
[06:57:50] <jensnockert> I think a Vec4<T> type would push the limits of the current implementation :S
[06:58:06] <strcat> C++ has variadic templates and integers as type parameters for this kind of stuff
[06:58:55] <strcat> really painful/scary but... it works
[06:58:57] <dbaupp> (I believe at least nmatsakis didn't think that adding integers as type parameters would be a bad idea.)
[06:59:01] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[06:59:11] <strcat> dbaupp: well I think ghc has them
[06:59:15] * dbaupp wants fixed size vectors to be sensible
[06:59:19] <dbaupp> strcat: yeah, with extensions
[06:59:26] <doomlord> i do miss them but their absence is not crippling
[06:59:33] <strcat> yeah so we can look at what they do, and see what problems they had if any
[06:59:40] <jensnockert> From an implementation point of view, it would be a lot easier to use fixed-size vectors as the backing type. What about #[simdn] type i8x16 = [i8, ..16]; I thinkâ€¦
[06:59:53] <dbaupp> strcat: any type can be promoted to a kind, in fact.
[06:59:59] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[07:00:18] <dbaupp> jensnockert: I think typedef information gets lost somewhere
[07:00:28] <strcat> immediately basically
[07:00:39] <jensnockert> Oh, yeahâ€¦
[07:00:42] <jensnockert> Urghâ€¦
[07:01:14] <dbaupp> #[simdn] struct i8x16([i8, .. 16]); would work though
[07:01:17] <jensnockert> I still don't have _any_ idea how to get a Vec4<i32> from a Vec8<i16> or example.
[07:01:24] <dbaupp> and there could be sugar for it
[07:01:28] <dbaupp> cast::transmute?
[07:01:39] <jensnockert> No, I mean in the compiler.
[07:01:48] <strcat> PointerCast? ;p
[07:01:58] <jensnockert> No, the actual t / Type
[07:02:07] <jensnockert> Well, only t is a problem, really.
[07:02:23] <strcat> this really seems like something integer type params are needed for
[07:02:29] <dbaupp> I'd guess it's not implemented?
[07:02:32] <strcat> Vec<T, N>
[07:02:42] <jensnockert> If we had that, this wouldn't be an issue.
[07:02:43] <strcat> and you'd just be able to grab T and N in the compiler
[07:02:48] <strcat> and deal with it systematically
[07:03:00] <strcat> jensnockert: well you could define all the numbers you need as types
[07:03:03] <strcat> ;p
[07:03:15] <dbaupp> rusti: trait uint {} 
[07:03:16] -rusti- ()
[07:03:31] <strcat> struct V1; struct V2; struct V3; struct V4; ...
[07:03:32] <dbaupp> rusti: trait uint {} fn foo<A: uint>(x: A, y: uint) {}
[07:03:33] <jensnockert> strcat: Yeah, 5 * 10 types, just 50 lang-items suddenlyâ€¦
[07:03:35] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/ZLFP
[07:03:49] <dbaupp> well, that's fun.
[07:03:51] <strcat> jensnockert: well I mean you'd do
[07:03:56] <strcat> Vec<i16, V2>
[07:04:45] <dbaupp> what about Vdecimal<V1, Vdecimal<V2, V3>> for encoding 123
[07:05:01] <dbaupp> (or 321, whichever is easiest.)
[07:05:11] *** Quits: cowboyd (cowboyd@moz-DD0FF83.lightspeed.austtx.sbcglobal.net) (Client exited)
[07:05:12] <strcat> dbaupp: that sounds like boost mpl
[07:05:15] <strcat> ;p
[07:05:28] <graydon> jensnockert: what do you mean "get a Vec4<i32> from a Vec8<i16>"?
[07:05:30] <dbaupp> strcat: yup, and various haskell type-level libraries too
[07:05:56] <strcat> dbaupp: mpl is really scary though
[07:06:03] <jensnockert> graydon: I have an intrinsic that takes one as an argument, and returns the other, how would I create the ty:t for the resulting type?
[07:06:04] <strcat> I'm sure it's scarier than anything in haskell
[07:06:15] <strcat> dbaupp: they have functions, iterators, strings, etc.
[07:06:28] <dbaupp> all in the types?
[07:06:51] <graydon> jensnockert: how is the type signature of the intrinsic written?
[07:07:22] <graydon> yay bors is back in business
[07:07:34] <jensnockert> Ok, bad example with an intrinsic, since you could just let the user write signatures for them.
[07:07:50] <graydon> picked right back up where it left off, re-merged dotdash's intrinsics fixes
[07:07:52] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[07:07:58] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[07:08:06] <jensnockert> \o/
[07:08:30] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[07:08:31] <strcat> dbaupp: http://www.boost.org/doc/libs/1_54_0/libs/mpl/doc/refmanual/sort.html
[07:08:47] <dbaupp> strcat: (i'd assume that people... probably oleg... have done that in Haskell too, but Haskell's is actually vaguely designed to do it.)
[07:08:54] <strcat> well just look around http://www.boost.org/doc/libs/1_54_0/libs/mpl/doc/refmanual.html
[07:08:56] <graydon> jensnockert: in any case, I am about to fall asleep, can we pick it up tomorrow? :)
[07:08:58] <strcat> it's very strange stuff
[07:09:07] <jensnockert> graydon: Yeah, I need to think about it.
[07:09:23] <dbaupp> strcat: is that quicksort?
[07:09:39] <jensnockert> graydon: Don't let my thinking aloud keep you awake.
[07:09:54] <graydon> k. g'night
[07:10:01] <strcat> dbaupp: dunno, whatever they were enable to encode in types
[07:10:03] *** Quits: graydon (graydon@moz-1C52C8D0.cable.teksavvy.com) (Quit: Leaving.)
[07:10:09] <jensnockert> grayGood night.
[07:10:13] <strcat> it has to be recursive ofc
[07:10:19] <strcat> so probably a quicksort
[07:10:31] <dbaupp> yeah
[07:10:40] <dbaupp> (and the complexity is correct.)
[07:11:00] *** Quits: jaen (jaen@moz-21C35F3C.play-internet.pl) (Ping timeout)
[07:11:34] <strcat> dbaupp: and this is how you define a string
[07:11:40] <strcat> boost::mpl::string<'Hell','o Wo','rld!'>
[07:12:00] <strcat> you have to chunk it into 4-byte sections
[07:12:22] *** Joins: geomyidae (cole@DD6F7E3A.21468E9A.30200F38.IP)
[07:12:39] *** Quits: geomyidae (cole@DD6F7E3A.21468E9A.30200F38.IP) (Quit: Konversation terminated!)
[07:12:48] *** Joins: geomyidae (cole@DD6F7E3A.21468E9A.30200F38.IP)
[07:12:48] <dbaupp> how strange
[07:13:21] <strcat> they build a lot of weird stuff with it
[07:13:29] <strcat> like boost xpressive, static regexp
[07:13:40] <strcat> "<(\\w+)>.*?</\\1>" becomes '<' >> (s1= +_w) >> '>' >> -*_ >> "</" >> s1 >> '>'
[07:13:41] <strcat> ;p
[07:14:11] <strcat> since they actually want it to be efficient... they're expression templates, rather than composed functions
[07:14:19] *** zz_kimundi is now known as kimundi
[07:18:15] <strcat> dbaupp: in some ways C++ templates are a nicer language than C++ ;p
[07:18:17] <strcat> pattern matching!
[07:18:29] <strcat> anyway off to sleep
[07:18:30] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.1)
[07:24:43] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[07:34:42] *** Quits: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Quit: zzz)
[07:37:54] <jensnockert> ChrisMorgan: There is certain irony in that emacs feels as slow today, as it did 15 years ago.
[07:38:11] <jensnockert> And it probably did 15 years before that.
[07:38:22] <dbaupp> more features; or something
[07:38:42] <dbaupp> (it has a package manager now! ... yay for text-editor-operating-systems.)
[07:39:23] *** Joins: Ms2ger (Ms2ger@moz-12781595.adsl-dyn.isp.belgacom.be)
[07:42:24] <jensnockert> dbaupp: Yeah, and emacs lisp is horribly slow.
[07:42:42] <Ralith> emacs lisp is undoubtedly the problem with emacs
[07:42:43] <dbaupp> yup ... it's the best part?
[07:42:58] * dbaupp thinks jensnockert should add simd to elisp
[07:43:05] <Ralith> heh
[07:43:13] * jensnockert thinks it needs a JIT first.
[07:43:17] <dbaupp> edit 16 characters at once, or something
[07:43:30] <Ralith> reminds me of my SIMD work on Idris
[07:43:49] <Ralith> it's not very useful right now since everything's boxed
[07:44:14] <Ralith> but even on non-native backends people have expressed interest in it as a way to perform several arithmetic operations without boxing
[07:45:02] <Ralith> (because the vector gets unboxed/boxed once, instead of each element getting unboxed individually)
[07:45:43] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[07:47:34] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[07:47:49] *** Joins: doener (bs@moz-AA189A5A.unitymedia.biz)
[07:48:02] <jensnockert> Yeah, it could be useful, but not amazingly so.
[07:48:56] <dbaupp> I wonder how hard it would be to add a very simple form of generic integers
[07:48:58] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[07:49:04] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[07:49:10] <dbaupp> i.e. Simd<T, n>
[07:49:27] <dbaupp> not supporting operations on them or anything like that
[07:49:35] <Ralith> that's the sort of question I used to ask myself
[07:49:47] <Ralith> and here I am years later hacking on a dependently typed language impl
[07:49:52] <dbaupp> haha
[07:50:43] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[07:50:51] <dbaupp> is idris bootstrapping?
[07:50:57] <Ralith> not yet
[07:51:04] <Ralith> insufficient man-hours to justify an attempt
[07:51:16] <Ralith> (insufficient man-hours available, that is)
[07:52:03] <dbaupp> oh :(
[07:52:03] <Ralith> it's expected that, come selfhosting, it will prove to be a very good platform, though; DTs are characteristically great at representing ASTs.
[07:52:15] <Ralith> there's already exciting things happening with EDSLs
[07:52:36] <Ralith> why is bootstrapping of particular importance to you?
[07:52:44] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Ping timeout)
[07:54:41] *** Joins: SimonSapin (simon@moz-D0C2F181.zone2.bethere.co.uk)
[07:56:56] <dbaupp> no, I was just interested if it was :)
[07:57:13] <Ralith> ah
[07:57:21] <dbaupp> (and bootstrapping is a neat feature/test of the language)
[07:57:33] <Ralith> it's certainly something we'd like to see, but one must prioritize
[07:58:43] <dbaupp> yeah, of course
[07:59:07] <Ralith> hm
[07:59:16] <Ralith> has anyone *done* a self-hosted dependently typed compiler before?
[07:59:24] <Ralith> I should probably ask #agda that
[07:59:46] <Ralith> might make an interesting thesis topic
[08:00:12] <dbaupp> a cursory google doesn't turn up anything
[08:00:26] *** Quits: Houm (Houm@moz-25669AA8.fbx.proxad.net) (Ping timeout)
[08:03:13] *** Joins: Houm (Houm@moz-25669AA8.fbx.proxad.net)
[08:07:14] <dbaupp> is there a way to set the max recursion depth with an env variable?
[08:07:21] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[08:08:22] <dbaupp> it seems 600,000+ stack frames kills gdb
[08:09:16] <Ralith> I'm impressed you fit that on the stack
[08:10:54] <dbaupp> as am I
[08:12:00] <dbaupp> (I'm less impressed that I've somehow broken the bootstrap build, and don't know how to check where the infinite recursion is coming from because gdb eats all my memory.)
[08:12:56] *** Quits: geomyidae (cole@DD6F7E3A.21468E9A.30200F38.IP) (Connection reset by peer)
[08:17:50] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[08:18:53] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[08:19:14] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[08:23:19] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[08:24:19] *** Quits: doomlord_ (servitor@moz-13E69BC8.range86-180.btcentralplus.com) (Ping timeout)
[08:24:26] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[08:30:51] *** Joins: CarpNet (ac@moz-FD24B77.sohonet.co.uk)
[08:31:37] *** Quits: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com) (Ping timeout)
[08:34:46] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[08:34:46] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/t1_APw
[08:34:46] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[08:37:46] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[08:37:46] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/rLQ0_g
[08:37:46] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[08:37:47] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[08:37:47] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/QWl18A
[08:37:47] <ghrust> 13rust/06auto 1481c576c 15Niko Matsakis: Issue #7444 - Borrowck permits moved values to be captured
[08:37:47] <ghrust> 13rust/06auto 14782853c 15Niko Matsakis: Issue #7444 - Update neg test and pos test for move by capture
[08:37:47] <ghrust> 13rust/06auto 14cee5c4a 15bors: auto merge of #7849 : nikomatsakis/rust/issue-7444-capture-moved-value, r=bblum...
[08:37:49] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[08:39:26] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[08:42:35] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[08:46:16] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[08:47:02] *** Joins: montezuma (Mibbit@A1793499.EC15082C.D7C984E0.IP)
[08:48:07] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[08:49:18] <doener> dbaupp: I'd try to set RUST_MAX_STACK to something low
[08:50:18] <doener> dbaupp: and probably RUST_MIN_STACK as well, since we're now starting at 2MB
[08:51:42] <dbaupp> ah, right, yeah, that would've worked (although I've already found the problem)
[08:51:49] *** Joins: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[08:52:44] <doener> oh, what happened to irsy?
[08:52:53] <doener> no more new date?
[08:52:56] <doener> s/date/data/
[08:54:30] <dbaupp> cmr's bencher is out of action
[08:55:05] <dbaupp> various problems; it dropped of the internet for a bit, and then had to be removed from the rack to put another server in or something.
[08:55:17] *** Joins: mye (mye@moz-7955B1FF.dip0.t-ipconnect.de)
[08:55:19] * dbaupp doesn't know the details
[08:56:07] <dbaupp> the worst bit is it could've been using the time to bench old commits, but I think I wrote the script wrong so it's just wasted the time throwing exceptions. :(
[08:56:23] <dbaupp> (except for the time where it's off.)
[08:58:14] *** Quits: dwhyte (dwhyte@ED9190FB.B72E355F.7BF4A4B0.IP) (Quit: Leaving.)
[09:02:04] *** Quits: montezuma (Mibbit@A1793499.EC15082C.D7C984E0.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[09:02:28] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[09:03:08] *** Quits: SimonSapin (simon@moz-D0C2F181.zone2.bethere.co.uk) (Ping timeout)
[09:03:32] *** Quits: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu) (Quit: Leaving)
[09:04:07] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[09:06:50] *** Joins: victorporof (victorporo@3692B70F.2484615.4A6B528C.IP)
[09:07:00] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[09:09:25] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[09:13:54] *** Joins: aatch (aatch@moz-2BB0AC01.cable.telstraclear.net)
[09:15:29] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[09:15:34] *** Joins: z0w0 (zack@A76ECE44.E8D776F0.D76C0449.IP)
[09:20:11] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[09:24:10] *** kimundi is now known as zz_kimundi
[09:28:45] *** Quits: aatch (aatch@moz-2BB0AC01.cable.telstraclear.net) (Connection reset by peer)
[09:36:18] *** Joins: james (james@moz-2BB0AC01.cable.telstraclear.net)
[09:36:43] *** Quits: james (james@moz-2BB0AC01.cable.telstraclear.net) (Quit: Leaving)
[09:37:17] *** Joins: aatch (aatch@moz-2BB0AC01.cable.telstraclear.net)
[09:39:13] *** zz_kimundi is now known as kimundi
[09:41:24] *** Quits: PeterSP (peter@moz-4DAF5777.bstnma.fios.verizon.net) (Ping timeout)
[09:41:47] <aatch> Woo, finally got my new computer working
[09:45:22] *** Joins: PeterSP (peter@moz-4DAF5777.bstnma.fios.verizon.net)
[09:46:33] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[09:46:48] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[09:46:54] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[09:48:04] *** Joins: BitPuffin (quassel@moz-49828767.cust.tele2.se)
[09:48:36] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[09:49:49] *** Quits: aatch (aatch@moz-2BB0AC01.cable.telstraclear.net) (Client exited)
[09:54:10] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[09:54:15] *** Joins: james (james@moz-2BB0AC01.cable.telstraclear.net)
[09:54:22] *** Quits: james (james@moz-2BB0AC01.cable.telstraclear.net) (Quit: Leaving)
[09:54:27] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[09:54:51] *** Joins: aatch (aatch@moz-2BB0AC01.cable.telstraclear.net)
[09:55:08] *** Quits: aatch (aatch@moz-2BB0AC01.cable.telstraclear.net) (Quit: Leaving)
[09:55:16] *** Joins: aatch (aatch@moz-2BB0AC01.cable.telstraclear.net)
[09:56:01] *** Quits: Uther (Instantbir@moz-1B244B05.hfc.dyn.abo.bbox.fr) (Ping timeout)
[09:57:55] *** Joins: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP)
[10:05:27] *** Quits: ross (ross@moz-8A84103E.br.br.cox.net) (Quit: )
[10:11:01] *** Joins: Earnestly (earnest@2AB30F53.FB5005.2BCC804A.IP)
[10:13:25] <doener> aatch: somebody told me that you could tell me something about the mergefunc pass not working correctly with rustc?
[10:14:49] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[10:15:49] <aatch> doener, hmm? Oh right. So when I did work on the optimization passes, I initially added in a "mergefunc" pass, thinking that it would help reduce code bloat from excessive monomorphising.
[10:16:22] <aatch> But during testing resolve, well, exploded.
[10:17:12] <aatch> eventually I tracked it down to being the mergefunc pass. I don't know for sure what the cause was, but my guess is that the undefined behaviour let LLVM merge functions that weren
[10:17:21] <aatch> weren't actually identical.
[10:19:27] <doener> too bad
[10:19:45] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[10:19:45] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/QWl18A
[10:19:45] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[10:20:34] <aatch> doener, you might be able to turn it back on, since much of the undefined behaviour has gone (though there is still quite a bit around instrinsic::transmute)
[10:22:49] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[10:22:49] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/hRPP7g
[10:22:49] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[10:22:51] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[10:22:51] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/m1EGtQ
[10:22:51] <ghrust> 13rust/06auto 143b158b3 15Felix S. Klock II: Silence various warnings in bootstrap build.
[10:22:51] <ghrust> 13rust/06auto 140335339 15bors: auto merge of #7876 : pnkfelix/rust/fsk-silence-warnings-from-bootstrap-build, r=alexcrichton...
[10:22:52] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[10:22:56] <doener> aatch: hm, what's undefined there?
[10:23:45] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[10:24:10] <aatch> doener, actually, I might be wrong. I think the llvm guys said the lint warning we were getting was a false positive
[10:25:08] <aatch> basically it was doing some weird things at codegen where it was bitcast-ing a function
[10:25:12] <doener> aatch: ah, those, they result from monomorphization, not transmute itself
[10:25:35] <doener> and yeah, Blei said that the #llvm guys said that they're false positives
[10:26:07] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[10:29:48] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[10:30:12] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[10:30:58] *** Quits: aatch (aatch@moz-2BB0AC01.cable.telstraclear.net) (Quit: Leaving)
[10:32:00] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[10:33:01] *** Joins: pnkfelix|rcirc (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[10:33:54] <ChrisMorgan> Style question: [type, ..num] or [type, .. num]?
[10:34:26] <doener> the former
[10:35:13] <ChrisMorgan> Then why do compile errors show the latter?
[10:35:49] *** Quits: victorporof (victorporo@3692B70F.2484615.4A6B528C.IP) (Connection reset by peer)
[10:35:53] <doener> good question
[10:37:09] <doener> I based my answer on grep results. 140 vs. 43 in the rust source
[10:37:34] <doener> and those 43 seem to be mostly in old code
[10:37:53] * ChrisMorgan was going to do exactly that immediately after asking but then got sidetracked by a commit message he was in the process of writing
[10:38:41] <doener> https://github.com/mozilla/rust/wiki/Note-style-guide has nothing on it
[10:39:31] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[10:39:55] <nmatsakis> ChrisMorgan: I personally dislike the ' .. ' style
[10:40:03] <nmatsakis> but I think brson liked it :)
[10:40:12] <nmatsakis> and maybe he made the pretty printing code
[10:40:33] <nmatsakis> so I agree with doener, the former
[10:40:36] * ChrisMorgan has no strong opinion on that particular matter but wishes to follow the conventions.
[10:42:50] <cmr> dbaupp: should be back up today
[10:47:20] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[10:48:23] *** Joins: jfbk (textual@moz-EEA9CFB3.nyc.res.rr.com)
[10:49:08] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[10:49:49] *** Quits: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP) (Quit: Leaving.)
[10:50:10] *** Joins: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP)
[10:55:59] <dbaupp> cmr: cool!
[10:56:13] <cmr> Did decopy land?
[10:56:26] <dbaupp> cmr: (could you adjust the script so that the except clause catches any git errors too?)
[10:56:27] <dbaupp> yeah
[10:56:31] <cmr> dbaupp: (yes)
[10:56:39] <dbaupp> it was "effortless" once the tree was closed
[10:56:52] <dbaupp> just required 2 small patches
[10:57:07] <dbaupp> (well, and the rebases that pcwalton had been doing for days.)
[10:57:47] <cmr> I think Clone should really be automatically derived
[10:59:13] <dbaupp> that's sort-of exactly the reason that we've moved away from Copy
[10:59:25] <dbaupp> (not enough control/no customisability)
[10:59:43] <cmr> Well I have no problem with being able to implement it yourself
[11:00:01] <cmr> but having to go into rustc to add #[deriving(Clone)] for stuff I use in rustdoc is no fun ;(
[11:00:19] <dbaupp> oh, so it gets derived if there is no hand-written Clone implementation
[11:00:21] <dbaupp> ?
[11:00:21] <cmr> right
[11:00:33] <cmr> and if it's eligible
[11:00:33] <dbaupp> (what happens if a type shouldn't be Cloneable?)
[11:00:40] <cmr> #[no_clone]
[11:01:13] <dbaupp> seems very magical... (the automatically-derived-if-not-implemented bit.)
[11:01:24] <cmr> it is a bit magical yes
[11:02:17] <cmr> but it's the only way to copy something, and if you need to copy something and the author of a library forgot to slap #[deriving(Clone)] onto it, you're screwed
[11:02:35] <dbaupp> right
[11:03:24] <dbaupp> you could post to the ML about it, or something.
[11:06:21] *** Quits: StarLight (StarLight@moz-C8C82E57.pppoe.avangarddsl.ru) (Ping timeout)
[11:08:02] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[11:09:45] *** Joins: StarLight (StarLight@moz-534A0739.pppoe.avangarddsl.ru)
[11:11:34] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[11:12:41] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[11:13:40] *** Quits: heftig (heftig@moz-E8A91210.dip0.t-ipconnect.de) (Quit: Quitting)
[11:13:48] *** Joins: heftig (heftig@moz-E8A91210.dip0.t-ipconnect.de)
[11:13:54] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[11:14:03] *** Quits: heftig (heftig@moz-E8A91210.dip0.t-ipconnect.de) (Quit: Quitting)
[11:14:44] *** Joins: heftig (heftig@moz-E8A91210.dip0.t-ipconnect.de)
[11:16:57] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[11:18:49] <cmr> The "Copy" kind could be used to determine if a type is eligible for an automatic Clone impl, right?
[11:19:32] <dbaupp> I think Copy was literally removed
[11:19:44] <cmr> well
[11:19:52] <dbaupp> (but in theory, I guess the logic would be the same)
[11:19:55] <cmr> yeah
[11:27:18] <cmr> post sent
[11:27:39] <dbaupp> post read
[11:30:44] <dbaupp> wow... on first blush, it looks like we load crates 3 times!
[11:30:51] * dbaupp is hopefully reading this incorrectly
[11:30:59] <cmr> I wouldn't doubt it :p
[11:31:30] <dbaupp> and, we do an absolutely pointless copy of the whole ~[u8] metadata
[11:31:48] <cmr> And we reparse it every time we went something from it
[11:32:12] <dbaupp> yay!
[11:33:31] <dbaupp> ok... maybe it's more than 3 times: it appears that if another imported crate requires it, then it gets loaded several times more
[11:35:48] <doener> dbaupp: the "raw" ebml metadata? IIRC that was cached last time I checked
[11:36:24] <doener> dbaupp: which code path are you looking at?
[11:36:33] <dbaupp> doener: I'm seeing is the calls to the `crate_name_from_metas` function
[11:36:35] * dbaupp broke it
[11:36:47] <dbaupp> (and fixed it.)
[11:37:16] <dbaupp> doener: and as far as I can tell, that gets called if and only if a crate is loaded
[11:38:33] *** Joins: sk (sk@A298A44C.54A580E3.78DD174B.IP)
[11:38:35] *** Joins: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[11:39:15] *** Quits: Mowah (Mowah@moz-7A6BF5A3.cust.bredbandsbolaget.se) (Ping timeout)
[11:40:03] *** Joins: jviereck (Adium@moz-D2131F5F.ethz.ch)
[11:42:40] *** Quits: jviereck (Adium@moz-D2131F5F.ethz.ch) (Quit: Leaving.)
[11:42:50] <doener> dbaupp: that's via resolve_crate which uses a cache
[11:43:05] <doener> dbaupp: there's another callpath via read_crates
[11:43:24] <doener> read_crates -> warn_if_multiple_versions -> crate_name_from_metas
[11:43:47] <doener> and that just walks over the cache crates
[11:44:08] <doener> cached even
[11:44:35] <dbaupp> oh, so there is... I don't know how I missed that with my grepping.
[11:44:43] * dbaupp is less concerned now
[11:45:50] *** Joins: jviereck (Adium@moz-D2131F5F.ethz.ch)
[11:46:03] <jfbk> how would one clone a fixed-length vector?
[11:46:29] <dbaupp> it's probably not possible
[11:46:39] <dbaupp> (especially with copy now gone.)
[11:47:01] <dbaupp> you'd have to make a new one, and then walk over them clone each element by hand.
[11:47:06] <dbaupp> *cloning
[11:47:47] <dbaupp> let mut new_vec = [0, .. len]; for new_vec.mut_iter().zip(old_vec.iter()) |(x,y)| { *x = y.clone(); }, I guess
[11:47:55] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[11:49:45] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[11:49:49] <dbaupp> except one doesn't necessarily have a `0` element... and in that case you probably have to fill it with std::unstable::intrinsics::init, and use ...::intrinsics::move_val_init (both very unsafe), and be very sure that there won't be a fail! until after the vector is fully initialised.
[11:50:36] *** Joins: RMF (RMF@moz-F40FCF19.dsl.telepac.pt)
[11:53:22] *** Quits: jviereck (Adium@moz-D2131F5F.ethz.ch) (Quit: Leaving.)
[11:58:38] *** Joins: samx (sami@moz-48EC0983.dyn.optonline.net)
[11:59:02] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[12:01:43] *** Quits: _Vi (vi@527C345F.497AA854.B16B3BE6.IP) (Ping timeout)
[12:03:37] *** Joins: romain (Mibbit@D76F9C6.B82D76A3.B89ABEAF.IP)
[12:03:38] *** Quits: romain (Mibbit@D76F9C6.B82D76A3.B89ABEAF.IP) (Quit: romain)
[12:03:51] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[12:04:42] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[12:04:42] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/m1EGtQ
[12:04:42] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[12:07:10] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Quit: Computer has gone to sleep.)
[12:07:41] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[12:07:41] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/AqinCA
[12:07:41] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[12:09:51] <jfbk> dbaupp:  thanks! I got that rolled into a macro for fixed-len vec newtype structs at https://gist.github.com/jfager/5936197, but it's a little clunky - have to pass the vec type and size rather than just the newtype struct
[12:11:33] <dbaupp> oh, neat!
[12:12:32] <doener> jfbk: you just have to implement CTFE to avoid that ;-)
[12:13:22] <engla> .clone() could fail! I guess
[12:13:56] <jfbk> Chlorotrifluoroethylene?
[12:14:10] <doener> compile time function execution
[12:15:05] *** Quits: samx (sami@moz-48EC0983.dyn.optonline.net) (Quit: This computer has gone to sleep)
[12:15:13] <jfbk> i'll get right on that
[12:15:26] <dbaupp> doener: how would that help in this instance?
[12:16:09] <dbaupp> (it'd have to be able to deconstruct the type, right?)
[12:16:28] <doener> dbaupp: you could at least stop passing in the length
[12:23:48] *** Joins: LU324 (stuff@moz-A17E9A7B.dyn.embarqhsd.net)
[12:26:25] *** kimundi is now known as zz_kimundi
[12:30:34] *** Joins: novabyte (Instantbir@moz-3E0F9699.cable.virginmedia.com)
[12:38:01] <jfbk> trying to roll the newtype declaration and all its trait impls into one macro, so name, type, and size all only get declared once - fixed_vec_type!(Foo, u8, 2).  not working too well, compiler doesn't see the trait impls for the type
[12:41:00] <doener> looks like they don't survive the macro expansion
[12:41:22] <doener> at least they're missing from "rustc --pretty expanded fixed_vec_type.rs"
[12:41:39] *** Quits: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Client exited)
[12:42:27] <engla>  macros can only expand to one item
[12:42:58] <engla> so you need an enclosing mod for example
[12:43:11] <engla> one item is a fn, struct, impl, mod or so
[12:43:35] <jfbk> so?
[12:43:48] <engla> just a word
[12:43:56] <jfbk> oh, right, sorry
[12:44:51] <engla> current std::num::uint_macros  does this
[12:45:14] <engla> the macro expands to one `mod generated { `
[12:45:37] <engla> then in std::num::u8, it says pub use self::generated::*;  before the macro expansion
[12:48:03] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[12:48:28] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[12:50:20] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[12:50:51] *** Joins: _Vi (vi@527C345F.497AA854.B16B3BE6.IP)
[12:54:03] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[12:55:09] *** zz_kimundi is now known as kimundi
[13:01:29] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[13:05:00] *** Joins: MaikKlein1 (maik@moz-EF706AF.dip0.t-ipconnect.de)
[13:09:10] *** Quits: z0w0 (zack@A76ECE44.E8D776F0.D76C0449.IP) (Client exited)
[13:10:26] *** Quits: MaikKlein1 (maik@moz-EF706AF.dip0.t-ipconnect.de) (Ping timeout)
[13:11:34] <ChrisMorgan> I wish Rust's documentation were all done in Sphinx/reStructuredText rather than Markdown. Such a lousily written mess, Markdown is, whereas reStructuredText and Sphinx are well defined, and Sphinx is actually *designed* to do this sort of thing.
[13:12:00] <cmr> ChrisMorgan: Saunter on over to #rustdoc-wg :)
[13:12:02] <engla> I like reST as well
[13:12:57] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[13:13:08] <ChrisMorgan> Besides which, it's nice having filetypes "rust" and "rst" ;-)
[13:13:33] <doener> re-un-structured text
[13:15:09] <ChrisMorgan> Come join #rustdoc-wg and let's discuss it, engla, doener, anyone else!
[13:15:38] *** Joins: mw (mw@moz-3AF0517D.adsl.highway.telekom.at)
[13:19:08] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[13:21:24] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[13:22:09] *** kimundi is now known as zz_kimundi
[13:24:39] *** Joins: sankha93 (Instantbir@F240151E.4F548E43.F44414AF.IP)
[13:27:42] *** Joins: Azdle (Azdle@moz-B334B496.hfc.comcastbusiness.net)
[13:28:23] *** Joins: MaikKlein1 (maik@moz-EF706AF.dip0.t-ipconnect.de)
[13:28:56] *** Quits: DeokjinKim (Mibbit@B4104EBB.3CC170B1.1E14B209.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[13:31:20] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[13:33:17] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Ping timeout)
[13:34:31] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[13:34:34] *** Quits: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[13:34:40] *** zz_kimundi is now known as kimundi
[13:36:58] *** Quits: reyre (rick@B2D8AB09.33EE9F8A.1139E686.IP) (Quit: Leaving)
[13:37:21] *** Joins: reyre (reyre@86C3727C.33EE9F8A.1139E686.IP)
[13:40:34] <ssbr> kimundi: derp derp derp
[13:40:53] <ssbr> kimundi: I got caught up in a lot of stuff and then never got back to it. I should get back to it now. Why not?
[13:41:19] <ssbr> (getting caught up in a lot of stuff includes, among other things, securing employment so that I'm not a hobo anymore)
[13:41:42] *** Joins: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca)
[13:41:48] *** Quits: BitPuffin (quassel@moz-49828767.cust.tele2.se) (Ping timeout)
[13:41:48] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[13:42:49] *** Joins: bago (Mibbit@AAD91DB.221AB9F7.2B8011A1.IP)
[13:42:49] *** Quits: bago (Mibbit@AAD91DB.221AB9F7.2B8011A1.IP) (Quit: bago)
[13:43:01] *** Joins: bago (Mibbit@AAD91DB.221AB9F7.2B8011A1.IP)
[13:43:54] *** Quits: bago (Mibbit@AAD91DB.221AB9F7.2B8011A1.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[13:43:58] <kimundi> ssbr: He, no pressure :-) Was just wondering
[13:44:08] *** Quits: MaikKlein1 (maik@moz-EF706AF.dip0.t-ipconnect.de) (Ping timeout)
[13:44:27] <ssbr> too late, I'm under so much pressure I'm going to explode
[13:44:43] *** Quits: mye (mye@moz-7955B1FF.dip0.t-ipconnect.de) (Quit: mye)
[13:44:52] <ssbr> (That's a lie, I just wanted you to feel bad.)
[13:45:04] <kimundi> xD
[13:49:02] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[13:49:41] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[13:49:41] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/lsBFEg
[13:49:41] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[13:50:57] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[13:52:43] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[13:52:44] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/ZVhJWg
[13:52:44] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[13:54:11] <jfbk> engla: thanks for the help, got it working in a single file context (updated in that gist).  for some reason i can't get the pattern you're using for the num stuff (exporting defs nicely via pub use from another file) to work for me.  out of time, gotta go to work
[13:55:36] *** Quits: jfbk (textual@moz-EEA9CFB3.nyc.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[13:57:16] *** kimundi is now known as zz_kimundi
[14:02:53] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[14:03:57] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[14:06:59] *** Quits: KindOne (KindOne@moz-16B3D182.dynamic.ip.windstream.net) (Ping timeout)
[14:09:59] *** Joins: KindOne (KindOne@moz-854E31FC.dynamic.ip.windstream.net)
[14:15:15] *** zz_kimundi is now known as kimundi
[14:20:02] *** Joins: Guest (textual@34641662.FB4DE631.66C78B76.IP)
[14:20:04] *** Quits: Guest (textual@34641662.FB4DE631.66C78B76.IP) (Quit: Guest)
[14:20:15] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[14:20:15] *** ChanServ sets mode: +o dherman
[14:20:19] *** Joins: Guest (textual@34641662.FB4DE631.66C78B76.IP)
[14:20:27] *** Quits: Guest (textual@34641662.FB4DE631.66C78B76.IP) (Quit: Textual IRC Client: www.textualapp.com)
[14:20:35] *** Joins: Guest (textual@34641662.FB4DE631.66C78B76.IP)
[14:20:41] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[14:21:47] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[14:22:54] *** Joins: cowboyd (cowboyd@moz-1BD02A1E.sw.biz.rr.com)
[14:24:20] <engla> ok
[14:24:57] <ChrisMorgan> Style question: given `struct Foo { bar: bool }`,  `Foo { bar: bool }` or some variant in the white space department?
[14:25:30] <ChrisMorgan> No space between the struct name and the { is one I've come across a bit.
[14:25:43] <bstrie> ChrisMorgan: there's no defined style there yet. go wild
[14:25:46] <cmr> that's the style I use
[14:26:18] <ChrisMorgan> bstrie: but I don't want to make decisions! I just want to follow conventions! ;-)
[14:26:22] <bstrie> style will be dictated by whoever rewrites the pretty printer
[14:26:55] <engla> Ascii{chr: 0 }  seems to be the common style but it looks unbalanced
[14:27:04] <bstrie> ChrisMorgan: then I recommend you be consistent by avoiding all whitespace, including newlines. `struct Foo{bar:bool};Foo{bar:bool};`
[14:27:33] <ChrisMorgan> Sure, that's a convention for rusti... hang on, where's rusti gone?
[14:27:54] <bstrie> ideally every rust file would just be a single line
[14:28:05] <dbaupp> (preferably use a font where the letters' holes are filled in. or even better, one where they are just black squares.)
[14:28:08] <engla> the editor can pretty print it
[14:28:10] <Ms2ger> Rust minifiers?
[14:28:37] <engla> since whitespace has no semantic meaning, every editor can pretty print the file as the user chooses
[14:28:37] <bstrie> Ms2ger: we have a tool for that, it's called "rustc"
[14:28:49] <cmr> rustc is a bloatifier though
[14:28:53] <bstrie> it's true
[14:28:55] <bstrie> it's a very bad tool
[14:28:58] <bstrie> :)
[14:29:02] <ChrisMorgan> Delete it!
[14:29:02] <dbaupp> ChrisMorgan: he runs on strcat's laptop, and via strcat's wifi, which is unreliable
[14:29:10] <dbaupp> pretty printing libstd is really fun
[14:29:26] <bstrie> cmr: once you're done with rustdoc and rusti and rustfmt we need you to rewrite rustc too
[14:29:31] <cmr> bstrie: on it
[14:29:37] <bstrie> take your time
[14:29:47] <Ms2ger> bstrie, and then rustdoc and rusti and rustfmt again?
[14:29:56] <bstrie> Ms2ger: yes, obviously
[14:29:58] <dbaupp> lines begin with ~500 columns of whitespace
[14:30:10] <bstrie> dbaupp: *line
[14:30:10] <dbaupp> cmr: extra and std probably need some attention too
[14:30:20] *** Quits: cowboyd (cowboyd@moz-1BD02A1E.sw.biz.rr.com) (Client exited)
[14:30:30] <bstrie> every rust file appears to be just a single empty line until you scroll right
[14:30:36] <Ms2ger> Clearly indentation should be 1-space / 1-space / 2-space / 3-space / 5-space / 8-space / ...
[14:30:40] <dbaupp> bstrie: (this was the current pprinter on libstd)
[14:30:43] <ChrisMorgan> cmr: "take your time" â‰¡ "you have six to eight weeks".
[14:30:52] <bstrie> dbaupp: hahaha, no way
[14:31:38] <bstrie> ChrisMorgan: no, that's silly. if he can get it done in one week, that would also be fine.
[14:32:09] <dbaupp> I'm hoping to see a "rewrite rustc" pr by saturday, cmr
[14:32:22] * dbaupp would be happy to r+ it
[14:32:24] <bstrie> it's ok if it's a bit rough
[14:32:50] <bstrie> cmr: have you considered rewriting rustc in ocaml instead of rust?
[14:34:52] <ChrisMorgan> Write it in Go! And then rewrite Go's compiler in Rust!
[14:35:00] <dbaupp> cmr: (that was my saturday, btw. you've got 24 hours.)
[14:35:27] <ChrisMorgan> dbaupp: what, you give him an extra 35 minutes?
[14:36:09] <dbaupp> People always say I'm too lax with deadlines.
[14:37:18] <bstrie> dbaupp: honestly I'm pissed that he's taken this long on it already
[14:37:41] <dbaupp> it's nearly been 10 minutes!
[14:37:57] <bstrie> it really just feels like a complete lack of professionalism
[14:38:45] *** Joins: NickeNyfiken (bzlandfill@moz-E95AAC1.c.fiberdirekt.net)
[14:38:58] <bstrie> an incompetent grad student could have written a self-hosting lisp interpreter by now
[14:39:07] <bstrie> watch, I'll do it myself
[14:39:23] <bstrie> read(eval(print(loop())))
[14:39:37] <bstrie> I think I got that backwards :P
[14:39:38] * dbaupp thinks that's a strange looking lisp
[14:39:44] <bstrie> hahaha
[14:39:50] <bstrie> I'm so bad at programming
[14:40:03] <dbaupp> at least you've got the incompetent bit down pat :P
[14:40:30] <Ms2ger> (read(eval(print(loop))))?
[14:40:43] <dbaupp> in any case, cmr should have definitely finished on trans by now.
[14:40:49] <doener> (loop (print (eval (read))))
[14:40:53] <bstrie> well I think it's actually (loop(eval(print(read))))
[14:40:57] <bstrie> er, yeah
[14:41:29] * dbaupp gets the feeling that cmr is ignoring us
[14:41:33] <bstrie> so really in lisp it's not a repl, it's a LEPR
[14:41:37] *** Joins: mye (mye@moz-7955B1FF.dip0.t-ipconnect.de)
[14:41:39] <bstrie> dammit, LPER
[14:41:53] <dbaupp> its parens start falling off?
[14:41:54] <bstrie> I feel like I'm developing dyslexia in my old age
[14:42:00] <Ms2ger> A leper?
[14:42:26] <bstrie> read().eval().print().loop()
[14:42:33] <bstrie> I'm sure we could make this work in javascript
[14:42:46] <klutzy> should i prepare directory structure as ./src/<modname>/{main,lib,test,bench}.rs to be installed by rustpkg?
[14:42:50] <NickeNyfiken> Hi guys, just started to look at rust and got stuck at creating a vector with values 1,2,3...  How would one do that? like x = range(1,10) in python
[14:42:56] <dbaupp> bstrie: clearly that's just the new implementation of rusti
[14:43:18] <dbaupp> bstrie: 4 method calls! it's barely worth including as standard
[14:43:23] <bstrie> NickeNyfiken: do you just want to iterate over the values, or do you actually want the vector?
[14:43:37] <klutzy> the doc says so, but i'm a little confused; if so, https://github.com/mozilla/rust/blob/master/src/librustpkg/testsuite/pass/commands.txt seems outdated
[14:43:38] <NickeNyfiken> I assigned the values in a loop, but then I couldn't use them since the compiler thought they could be uninitialized 
[14:43:40] <bstrie> NickeNyfiken: unlike in python, creating vectors just to iterate over them isn't idiomatic
[14:43:42] <dbaupp> NickeNyfiken: vec::from_fn(10, |i| i) makes a vector
[14:43:47] <dbaupp> (with the values.)
[14:44:02] <NickeNyfiken> hm, thx
[14:44:28] <bstrie> NickeNyfiken: not quite, if you want values in the range [1, 10) you'll need to tweak that
[14:44:35] <bstrie> because it's giving you [0, 10)
[14:44:45] <dbaupp> NickeNyfiken: but as bstrie says, you should be trying to use iterators for, err, iteration
[14:44:49] <klutzy> actually i'm curious if there exist any repository which meets with rustpkg behaviours
[14:44:49] <NickeNyfiken> No I want to have a vector to try to implement quicksort as a way of getting a taste of rust
[14:44:58] <bstrie> vec::from_fn(9, |i| i+1)
[14:45:00] <bstrie> is what you want
[14:45:01] <dbaupp> oh, ok :)
[14:45:15] <dbaupp> klutzy: I think catamorphism might have a test one
[14:45:19] <NickeNyfiken> I just need something to sort :)
[14:45:36] <dbaupp> klutzy: https://github.com/catamorphism/test-pkg
[14:45:42] <dbaupp> dunno if it builds/works
[14:45:50] <bstrie> dammit, where's rusti when you need it
[14:46:02] <dbaupp> bstrie: swallowed by strcat's wifi
[14:46:02] <bstrie> I think we actually need a new gender pronoun for bots
[14:46:24] <dbaupp> klutzy: well, that's 3 months old... so maybe not.
[14:46:48] <bstrie> klutzy: rustpkg is still too new to be usable
[14:46:58] <klutzy> dbaupp: yes, I found it from his blog and got more confused :P
[14:47:02] <dbaupp> haha
[14:47:04] <bstrie> klutzy: we're really inconsistent with packaging and directory structure right now, sorry
[14:47:21] <dbaupp> bstrie: but we're consistently inconsistent, so it's ok!
[14:47:30] *** Parts: mw (mw@moz-3AF0517D.adsl.highway.telekom.at) ()
[14:47:40] *** Quits: sankha93 (Instantbir@F240151E.4F548E43.F44414AF.IP) (Client exited)
[14:47:43] <dbaupp> klutzy: I believe someone had something that worked... and I got it work with their help, can't remember the magic though
[14:47:56] <bstrie> NickeNyfiken: you could also just do `let x = [1,2,3,4,5,6,7,8,9];`
[14:48:00] <dbaupp> I'll see if i've still got the dir structure around somewhere.
[14:49:36] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[14:51:09] <engla> NickeNyfiken: there is no good replacement for `range(0, 10)` at the moment, but there probably will be
[14:51:10] <dbaupp> klutzy: I've got ./src/modname/main.rs and `rustpkg build modname` puts the built executable at `./build/modname/modname`.
[14:51:17] <dbaupp> engla: definitely will be.
[14:51:22] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[14:51:22] *** Joins: sankha93 (Instantbir@E677A839.19E4BF68.25B273F5.IP)
[14:52:02] <NickeNyfiken> well it seem like it would be very easy to implement range() in terms of vec::from_fn
[14:52:17] <klutzy> dbaupp: oh, it's a tragedy :o
[14:52:20] <engla> NickeNyfiken: this is one variant. https://gist.github.com/anonymous/2eaa34d20490706a003e   You can create a vec from range  with   range(0,10).collect::<~[int]>()
[14:52:26] <engla> that's range as iterator
[14:52:27] <cmr> Counter::new(0, 1).take_(10).collect::<~[int]>()
[14:52:30] <dbaupp> klutzy: and lib.rs seems to work too.
[14:52:40] <dbaupp> (i.e. it builds a library.)
[14:52:41] <engla> just like range is in Py 3
[14:52:49] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[14:53:23] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[14:53:40] <klutzy> dbaupp: so rustpkg is quite usable but no repo is prepared to use it?
[14:53:49] <cmr> klutzy: it's almost usable
[14:53:52] <ChrisMorgan> Well, I think I shall be wise and go to bed rather than starting on a Rust domain for Sphinx or working on my HTTP server.
[14:54:29] <dbaupp> klutzy: not sure about "quite usable"... I'd guess there's a pile of bugs to be ironed out
[14:55:01] <dbaupp> klutzy: but yes, I don't know of any repo designed for rustpkg yet
[14:55:06] <cmr> rustdoc_ng!
[14:55:15] <dbaupp> really?
[14:55:18] <cmr> well, what do you mean by repo?
[14:55:23] <cmr> I do use rustpkg
[14:55:24] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[14:55:24] *** ChanServ sets mode: +o dherman
[14:55:30] <cmr> (for rustdoc_ng that is)
[14:55:37] <dbaupp> klutzy: https://github.com/cmr/rustdoc_ng
[14:55:47] <dbaupp> cmr: oh, so you don't need src/.../?
[14:55:48] *** Joins: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP)
[14:55:49] <cmr> It will hopefully be the first rustpkg user in rust ;)
[14:55:55] *** Quits: Houm (Houm@moz-25669AA8.fbx.proxad.net) (Ping timeout)
[14:56:03] <cmr> dbaupp: Well you need to setup a rustpkg working directory somewhere
[14:56:12] <cmr> I have ~/.rustpkg/src that I cloned rustdoc_ng into
[14:56:20] <jedestep> how much would people prefer rustpkg over something more typical (i.e. make)?
[14:56:27] <klutzy> cmr: i was confused that rustpkg doc says src/<pkgname>/ structure but nobody does that
[14:56:28] <dbaupp> cmr: ah! that makes more sense
[14:56:44] <cmr> klutzy: That's for rustpkg's working directory, not the actual projects themselves
[14:56:58] <cmr> jedestep: make isn't a package manager
[14:57:09] <cmr> rustpkg can call out to make if you don't want to use rustpkg as your build system
[14:57:12] <dbaupp> jedestep: in theory rustpkg will manage everything, so many builds could be `rustpkg build` with very little extra logic.
[14:57:22] *** Joins: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP)
[14:57:32] <jedestep> I just meant as a build tool
[14:57:59] <dbaupp> it knows about rust dependencies and invoking the compiler etc etc.
[14:58:13] <cmr> rustpkg is great for simple things right now but I don't know how well it will scale for complex projects
[14:58:35] <dbaupp> we'll see if/when rust itself migrates to it.
[14:58:39] <cmr> yup
[14:58:48] <jedestep> I tried to set it up for a project I'm working on but it has nested directories and C dependencies and stuff
[14:59:02] <cmr> rust is the perfect testcase: dependencies on complex C and C++ libraries, multiple components, etc
[14:59:05] <cmr> and staging
[14:59:27] <dbaupp> jedestep: yeah, it's really immature and poorly documented/exampled
[14:59:39] <jedestep> I made it infinite loop :I
[14:59:51] <dbaupp> did you file a bug?
[15:00:06] <jedestep> I think I got disgusted and gave up, ultimately forgetting to file a bug
[15:00:11] <jedestep> I'll do that though
[15:01:24] <dbaupp> I have a feeling `cannot move out of ...` errors are going to be the most common question about Rust on SO.
[15:01:40] <cmr> yeah
[15:02:01] <dbaupp> http://stackoverflow.com/questions/17727016/cannot-move-out-of-dereference (the latest one)
[15:02:12] <jedestep> I would expect some `cannot borrow X as both mutable and immutable` also
[15:02:25] <jedestep> seems easy to fix but there are some corner cases that are really bizarre
[15:02:32] <dbaupp> yeah, and a pile of "what are lifetimes"
[15:06:35] *** Joins: Houm (Houm@moz-25669AA8.fbx.proxad.net)
[15:06:45] *** husebyERRAND is now known as huseby
[15:09:43] *** Joins: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP)
[15:09:49] <bstrie> oh no, there are getting to be a *lot* of rust questions on SO :(
[15:10:01] <bstrie> all of those will need to be updated once we get to backwards-compatibility
[15:10:03] <dbaupp> oh no?
[15:10:06] <dbaupp> oh.
[15:10:09] *** Quits: reyre (reyre@86C3727C.33EE9F8A.1139E686.IP) (Client exited)
[15:10:14] <bstrie> inaccurate info is worse than no info
[15:10:19] <bstrie> it's like php
[15:10:27] <bstrie> where every tutorial was written in 2002
[15:10:52] * dbaupp will be willing to trawl through old answers at fix them up.
[15:10:57] <bstrie> hell, in 2005 I learned how to write web pages by reading a howstuffworks article from *1998*
[15:11:09] <bstrie> frames and tables ruled the day
[15:11:13] <bstrie> it didn't even mention css
[15:11:19] <Ms2ger> CSS? What's that? ;)
[15:11:35] <dbaupp> (although, as the questions get older and older, they'll get increasingly irrelevant/be dupes of newer questions.)
[15:11:49] <bstrie> would be good to mark them as dupes, then
[15:11:55] <bstrie> save us some trouble
[15:12:15] <dbaupp> yeah, I haven't actually looked... I was just assuming that there'd be repeats
[15:12:27] <dbaupp> (especially in a year or 2 when 1.0 comes out.)
[15:12:36] <bstrie> don't say 2 ;_;
[15:12:45] <Ms2ger> Three
[15:12:53] <bstrie> ;;;_;;;
[15:12:57] <dbaupp> gah, sorry! s/year/month/ ... typo
[15:12:59] *** kimundi is now known as zz_kimundi
[15:13:01] <doener> 0b0100
[15:13:16] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[15:13:40] <dbaupp> cmr's should be done on rustc soon, and then it'll just be writing documentation and some tooling. easy!
[15:13:57] <bstrie> I think we're approaching this the wrong way
[15:14:04] <bstrie> we're spending all this time writing tools
[15:14:11] <bstrie> why don't we just write a tool that writes the tools for us?
[15:14:25] <cmr> bstrie: it's called "reproduction" ;P
[15:14:33] <doener> can't we just declare us as tools? Job done
[15:14:58] <dbaupp> (can we declare cmr as the tool, and us writing it as telling him to work on rustc?)
[15:15:03] <bstrie> cmr: never heard of it, but I'll take your word for it. start reproducting for the good of rust
[15:15:26] <dbaupp> (sorry, cmr :P )
[15:15:35] <bstrie> dbaupp: sadly no, I don't think cmr will fit in an ethernet cable
[15:15:45] <dbaupp> have you tried?
[15:15:53] <cmr> please don't emulsify me
[15:15:56] <bstrie> you make a persuasive argument
[15:15:58] <dbaupp> we can't know for sure until we do
[15:16:01] <bstrie> haha
[15:16:04] *** Joins: nano (nano@moz-972880B.superkabel.de)
[15:16:07] <Ms2ger> For science!
[15:16:53] <bstrie> cmr: it's ok, we'll keep you in version control so that we can undo the emulsification
[15:17:55] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[15:18:31] <dbaupp> cmr: we'll even set up some tests for bors to run, so that we keep you all green.
[15:19:31] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[15:21:59] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[15:25:44] *** Joins: reyre (reyre@86C3727C.33EE9F8A.1139E686.IP)
[15:32:39] *** Quits: NickeNyfiken (bzlandfill@moz-E95AAC1.c.fiberdirekt.net) (Quit: CGI:IRC)
[15:34:40] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[15:34:40] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/2btkGA
[15:34:40] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[15:36:39] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[15:37:01] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Ping timeout)
[15:37:41] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[15:37:41] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/9HjhHA
[15:37:41] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[15:37:41] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[15:37:41] <ghrust> 01[13rust01] 15bors pushed 7 new commits to 06auto: 02http://git.io/Ue40CA
[15:37:41] <ghrust> 13rust/06auto 148d56158 15Daniel Micay: stop initializing ref_count for stack closures...
[15:37:41] <ghrust> 13rust/06auto 140239a06 15Daniel Micay: rm unused visit_str method from TyVisitor
[15:37:42] <ghrust> 13rust/06auto 140bc204e 15Daniel Micay: rm unnecessary stage0 `zero_memory` fn
[15:37:44] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[15:39:32] *** Quits: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP) (Client exited)
[15:39:49] *** Quits: sk (sk@A298A44C.54A580E3.78DD174B.IP) (Quit: Leaving)
[15:40:30] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[15:41:34] *** Joins: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP)
[15:42:18] *** Quits: nattofriends (tsutsumi@moz-4CEEC7AA.warosu.org) (Ping timeout)
[15:44:11] *** Joins: deepdog (deepdog@moz-BE31AF27.hr.hr.cox.net)
[15:47:39] *** Joins: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net)
[15:49:22] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[15:50:47] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[15:59:44] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[16:05:17] *** Joins: Kruppe (user@moz-4DDA8AB8.uwaterloo.ca)
[16:07:59] *** Quits: novabyte (Instantbir@moz-3E0F9699.cable.virginmedia.com) (Quit: bye bye)
[16:08:40] *** Joins: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net)
[16:10:41] *** Joins: nattofriends (tsutsumi@moz-4CEEC7AA.warosu.org)
[16:11:28] *** Joins: vodik_ (simon@moz-9EC368A5.dsl.bell.ca)
[16:14:53] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[16:15:43] *** zz_kimundi is now known as kimundi
[16:16:05] *** Joins: doener_ (doener@moz-121949B3.unitymediagroup.de)
[16:18:01] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[16:18:14] <kimundi> Hi, I notice that currently Option::get and Option::unwrap are identical. So now I'm removing unwrap, any objections?
[16:20:38] *** Joins: victorporof (victorporo@B7024D9D.5270B130.78DC9724.IP)
[16:20:46] <engla> bblum has a lot of changes to Option in the pipeline
[16:20:46] <dbaupp> no, pcwalton actually asked for someone to do that.
[16:21:09] <engla> (inside this PR) https://github.com/mozilla/rust/pull/7858
[16:21:11] <engla> but probably not that
[16:21:19] *** Quits: victorporof (victorporo@B7024D9D.5270B130.78DC9724.IP) (Quit: victorporof)
[16:21:34] *** Joins: Voomer (Voomer@moz-9E18DF24.dyn.centurytel.net)
[16:22:02] <bblum> kimundi: objection, there is a naming consistency issue which must be decided
[16:22:06] *** Joins: victorporof (victorporo@B7024D9D.5270B130.78DC9724.IP)
[16:22:26] *** Quits: paulproteus (quassel@rose.makesad.us) (Ping timeout)
[16:22:38] <bblum> also i have a big pull request which i would like to avoid continuously rebasing for minor library cleanup reasons
[16:23:17] *** Quits: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP) (Client exited)
[16:23:32] *** Joins: paulproteus (quassel@moz-E86A3B42.makesad.us)
[16:23:58] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[16:24:48] *** Joins: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP)
[16:24:51] <kimundi> bblum: okay, will stop for now then. Is the naming question get vs unwrap?
[16:24:57] <bblum> yep
[16:25:03] <bblum> and get_ref too
[16:25:11] <bblum> and take_unwrap
[16:25:22] <bblum> this concerns many functions :P
[16:25:25] <kimundi> yeah
[16:25:38] <kimundi> I
[16:26:13] <kimundi> I'd rename anything *unwrap to get
[16:26:45] <bblum> what do you think should happen to arc::unwrap?
[16:26:55] <bblum> as there is already an arc::get that means something different
[16:27:08] *** Joins: ozten (ozten@19BD73A1.5D8BCA3A.A0C1B52F.IP)
[16:27:17] <bblum> and unwrap_ref makes no sense
[16:27:38] <kimundi> what does arc::get do?
[16:27:47] <bblum> have a look
[16:27:52] <bblum> extra/arc.rs
[16:29:51] <kimundi> isn't that basically get_tef?
[16:30:02] <kimundi> tef*
[16:30:12] <kimundi> ref**
[16:30:20] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[16:30:23] <bblum> hmmm
[16:30:37] <bblum> yes, but arc has no functionality that would be get_not_ref, so the shortest name is used
[16:30:50] <bblum> perhaps questionably, but i'm fine with that
[16:30:52] *** Quits: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com) (Ping timeout)
[16:31:01] <bblum> btw, i thought option::get used to be fn(&self) -> T ?
[16:31:08] <bblum> why did it change?
[16:31:20] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[16:31:25] <bblum> it is now fn(self) -> T, and get_ref is fn(&'a self) -> &'a T
[16:31:30] <bblum> so old get is missing
[16:31:37] <dbaupp> bblum: copy was removed
[16:31:51] <kimundi> right, old get did copy
[16:31:54] <dbaupp> if you want old get: `option.get_ref().clone()`
[16:32:02] <bblum> oh geez
[16:32:18] <bblum> right, T:Copy
[16:32:21] <kimundi> now way can be expressed as opt.clone().get()
[16:32:30] <dbaupp> (that also works.)
[16:32:34] <kimundi> new*
[16:32:46] *** Joins: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com)
[16:32:48] <bblum> how about making get be fn<T:Clone>(&self) -> T ?
[16:33:17] <kimundi> should be called get_clone then
[16:33:24] *** Quits: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP) (Ping timeout)
[16:33:35] <kimundi> and that... isn't much shorter
[16:33:41] <bblum> perhaps
[16:33:57] <bblum> ok, what i think should happen is that unwrap should stay as-is, and get_ref should be renamed to get
[16:34:29] <bblum> that is consistent with ARC, and i favour eliminating clunky underscore-laden-2-word function names when possible
[16:34:46] <dbaupp> that sounds nice
[16:35:06] <bblum> btw, this is part of https://github.com/mozilla/rust/issues/7830
[16:35:15] <bblum> although i did not know of it when i created that issue
[16:35:32] <bblum> the issue probably also applies to Either functions
[16:35:37] <dbaupp> "My vote is for the shorter name being consuming, and having a -ref suffix." ;P
[16:35:39] <engla> this naming problem comes back everywhere in rust, to handle by value, by ref, by-mut-ref variants
[16:35:53] <engla> best to be consistent as widely as possible
[16:36:13] <bblum> dbaupp: well, that's about eliminating suffixes; i don't care about eliminating characters
[16:36:30] <bblum> although hm
[16:36:33] <bblum> it's a problem
[16:36:34] <dbaupp> engla: yeah, x, x_ref, x_mut_ref seems like it's the only thing that can be globally consistent like that
[16:36:36] <engla> align it with .map and make .map() consuming
[16:36:39] *** Joins: graydon (graydon@moz-1C52C8D0.cable.teksavvy.com)
[16:36:39] *** ChanServ sets mode: +qo graydon graydon
[16:36:50] *** Quits: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP) (Client exited)
[16:36:52] <graydon> sorry I'm late. machine decided "camera does not exist" so had to reboot.
[16:36:56] <graydon> #rust-triage shall we?
[16:36:59] <dbaupp> engla: (.map will probably be replaced by iterators)
[16:37:11] <engla> option map?
[16:37:15] <dbaupp> yeah
[16:37:19] <bblum> i suppose get and get_ref beats unwrap and get in my head, when considering only option
[16:37:22] <dbaupp> well, maybe.
[16:37:24] *** Joins: nslus (nslus@6BC3A018.3A8A22C3.59B6123A.IP)
[16:37:27] <dbaupp> probably not actually.
[16:37:43] * dbaupp should've thought before speaking
[16:37:45] <engla> Option needs a lot of sugar
[16:37:50] <bblum> but we can't make ARC's functions be called get_ref and get, because then people will unsuspectingly use get
[16:37:57] <bblum> and what to do with take_unwrap anyway
[16:38:16] <kimundi> could remove it
[16:38:19] <dbaupp> people shouldn't be really be using .get* with option anyway.
[16:38:26] <kimundi> take().get()
[16:38:30] <engla> there are lots of usecases
[16:38:36] <engla> for .get_ref() etc
[16:38:46] <bblum> take_unwrap and get_ref are too pervasive to remoe
[16:38:47] <bblum> remove
[16:38:51] <bblum> take_get()... maybe
[16:39:12] *** Joins: mschifer (Adium@2400BFD9.81DDA1E3.9BBDBC7E.IP)
[16:40:04] <bblum> maybe there is another verb we can use
[16:40:25] *** Quits: flowsnake (flowsnake@moz-1918C33E.aztw.cable.virginmedia.com) (Ping timeout)
[16:40:27] <kimundi> well, I'm in the mids of a unwrap->get and take_unwrap->take_get rename
[16:40:36] <bblum> what about ARC?
[16:40:40] <dbaupp> engla: right, but they're (a little bit) equivalent to dereferencing null.
[16:40:59] <kimundi> I could contine
[16:41:04] <cmr> dbaupp: and sometimes that's what I want
[16:41:16] <cmr> I'm just going to be doing None => fail!(...) anyway
[16:41:23] <cmr> Option::get was useful sugar
[16:41:35] <dbaupp> cmr: yes, right (I'm not advocating for removing them.)
[16:41:42] <engla> dbaupp: of course, but sometimes you have already excluded the None case
[16:42:02] <cmr> bblum: extract
[16:42:02] <dbaupp> engla: well, unwrap it and pass &'a around
[16:42:24] <dbaupp> engla: (safely unwrap it, where you excluded None)
[16:42:24] <engla> unwrap isn't different from get_ref
[16:42:43] <dbaupp> yeah, bad choice of words unwrap != ".unwrap()"
[16:43:13] <kimundi> re arc: get->ged_ref
[16:43:13] <kimundi> ^what's wrong with that?
[16:43:24] <engla> a usecase: RingBuf uses Option<T> so that it can have empty slots. But the invariant is that the "allocated" range of the underlying vec, has all Some(T)
[16:43:37] <dbaupp> ah, yes
[16:43:39] <bblum> kimundi: If arc::unwrap() has a shorter name than arc::get(), people will use the unwrap function by accident, and it will be a disaster.
[16:44:11] <bblum> cmr: extirpate
[16:44:18] <kimundi> i don't see arc unwtap... unlanded pr?
[16:44:21] <cmr> extricate you mean?
[16:44:22] *** Joins: flowsnake (flowsnake@moz-1918C33E.aztw.cable.virginmedia.com)
[16:44:26] <cmr> hah
[16:44:28] <bblum> kimundi: oh yeah, it's unlanded, one sec
[16:44:30] <cmr> extirpate is actually a word
[16:44:46] <cmr> .deport()
[16:45:04] <bblum> kimundi: https://github.com/bblum/rust/commit/d4c74fa6e70d56a0d747acee32a22555a3d62052#L0R126
[16:45:10] <dbaupp> gah, seriously... there is a *Util trait in a different module, and it's conflicting with method calls in this one... without being imported :/
[16:45:18] <bblum> kimundi: it is not an operation to be taken lightly
[16:45:23] <dbaupp> dammit #5898
[16:48:35] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[16:48:38] <kimundi> hm, so both option and  arc do the same, but we want to guide people to different fns in both
[16:49:01] <bblum> yes
[16:49:17] <bblum> although one difference to note is that arc::get is the only one of the four that will not fail
[16:51:03] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[16:52:49] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Ping timeout)
[16:53:19] *** Quits: pnkfelix|rcirc (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Input/output error)
[16:53:49] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[16:53:50] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Leaving...)
[16:54:18] *** Quits: dew (Instantbir@moz-2C6F2E2.dhcp.stls.mo.charter.com) (Ping timeout)
[16:54:49] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[16:54:50] *** Joins: azakai_ (alon@moz-BBE3ABD.mv.mozilla.com)
[16:56:02] *** Quits: vodik_ (simon@moz-9EC368A5.dsl.bell.ca) (Quit: work)
[16:56:15] <kimundi> get for ref and unwrap for consume seem the best choices
[16:56:46] <bblum> map_unwrap ?
[16:57:32] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[16:57:35] <bblum> consume should be renamed too; that is a good poitn
[16:57:45] *** Joins: CanhTak (Mibbit@moz-3104B86D.rev.sfr.net)
[16:57:59] *** Quits: fabiand (fabiand@moz-8C5E098B.adsl.alicedsl.de) (Quit: Verlassend)
[16:59:28] *** Joins: tjc (tjc@moz-6EB4E533.dsl.tsoft.com)
[16:59:28] *** ChanServ sets mode: +o tjc
[16:59:52] *** Quits: CanhTak (Mibbit@moz-3104B86D.rev.sfr.net) (Quit: http://www.mibbit.com ajax IRC Client)
[17:00:11] *** Joins: a_make (a__@moz-250D9B4.nycmny.fios.verizon.net)
[17:00:19] <bblum> kimundi: feel free to comment on the issue i linked with other naming inconsistencies like consume
[17:00:19] *** Quits: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net) (Ping timeout)
[17:00:32] <bblum> kimundi: i think this is maybe worth an RFC about
[17:00:46] <kimundi> so get, unwrap, take
[17:00:51] <bblum> well, definitely worth an RFC, and maybe worth bringing up at the rust meeting
[17:00:58] *** Joins: CanhTak (Mibbit@moz-3104B86D.rev.sfr.net)
[17:01:23] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[17:01:27] <kimundi> well, I'm on the go right now...
[17:01:58] *** Quits: nslus (nslus@6BC3A018.3A8A22C3.59B6123A.IP) (Quit: Leaving.)
[17:03:51] <bblum> um well
[17:03:59] <bblum> please don't land anything until after my enormous PR goes in?
[17:05:21] *** Joins: eholk (eholk@moz-466C519D.uconnect.utah.edu)
[17:06:11] <eschweic> If I need to move ~ pointers around, I can use util::replace, right?
[17:06:17] <bblum> yes
[17:06:24] <eschweic> cool
[17:07:47] *** Quits: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu) (Ping timeout)
[17:10:24] <kimundi> bblum: sure
[17:11:07] *** Joins: josh (josh@moz-C350AC70.hsd1.mn.comcast.net)
[17:12:09] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[17:12:09] *** ChanServ sets mode: +o brson
[17:12:09] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[17:12:36] *** Quits: josh (josh@moz-C350AC70.hsd1.mn.comcast.net) (Quit: josh)
[17:12:41] *** Joins: josh (josh@moz-C350AC70.hsd1.mn.comcast.net)
[17:12:46] *** Joins: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu)
[17:12:47] <bblum> i think i still favour get + unwrap
[17:13:10] <bblum> get connotes leaving the existing thing there; unwrap connotes that the existing thing goes away
[17:13:35] <bblum> the latter connotation will be important for people who aren't familiar with linear types
[17:13:56] <kimundi> bblum: he, just noticed that get, take, unwrap would map one to one to &self, &mut self and self. That's nice :-) 
[17:13:59] *** Quits: mye (mye@moz-7955B1FF.dip0.t-ipconnect.de) (Quit: mye)
[17:14:52] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[17:15:09] <engla> and get_mut_ref can have the name .get_mut() ?
[17:15:12] <kimundi> Anyway I'm all for get, take, unwrap now :P
[17:15:22] <kimundi> yes
[17:15:50] *** Quits: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk) (Client exited)
[17:16:02] <kimundi> well... one thing
[17:16:28] <kimundi> no, nevermind
[17:16:53] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[17:16:53] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/Ue40CA
[17:16:53] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[17:17:06] <bblum> i was hoping for map_consume/map_unwrap to get the shorter name of 'map'
[17:17:09] *** Joins: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com)
[17:17:09] *** ChanServ sets mode: +o pcwalton
[17:17:23] <bblum> i still don't know what the global picture looks like
[17:17:29] <bblum> which is why i think it's rust-meeting-worthy
[17:17:48] <bblum> because i have this nagging feeling that removing _ref suffixes just won't work
[17:17:49] <kimundi> err, no wait. there is one important distinction to make
[17:18:54] *** Joins: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP)
[17:19:20] *** Quits: bnicholson (bnicholson@moz-E98974C1.hsd1.ca.comcast.net) (Ping timeout)
[17:19:47] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[17:19:47] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/vcue2g
[17:19:47] <ghrust> 13rust/06auto 147ef9e72 15blake2-ppc: hashmap: Remove .consume() has rename .consume_iter() to .consume()...
[17:19:47] <ghrust> 13rust/06auto 14f83c118 15bors: auto merge of #7833 : blake2-ppc/rust/hashmap-consume, r=alexcrichton...
[17:19:47] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[17:19:50] <kimundi> get, take, unwrap should have the same semantic on None
[17:20:26] <kimundi> or rather: On empty one-element conrainer
[17:20:39] <bblum> take doesn't though
[17:21:00] <kimundi> right, that's the problem
[17:21:21] <engla> hashmap uses pop(K) -> Option<V>, get(K) -> &V, get_mut(K) -> &mut V, where those are Key, Value params. unwrap could be named .pop()
[17:21:36] *** Quits: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net) (Ping timeout)
[17:21:54] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[17:22:05] <kimundi> need take_opt, get_opt, unwrap_opt in the global case
[17:22:11] <bblum> oof, hashmap is part of this too huh
[17:22:39] <engla> all containers are part of it, at least related
[17:22:41] <kimundi> (useless on Option of course)
[17:22:43] <bblum> in the event that not all constraints can be filled, i definitely prefer short, memorable names to clunky but consistent ones
[17:22:44] <engla> Option is a simple container
[17:23:25] *** Joins: mschifer1 (Adium@moz-6F601BE7.lightspeed.sntcca.sbcglobal.net)
[17:23:35] *** Joins: nslus (nslus@6BC3A018.3A8A22C3.59B6123A.IP)
[17:24:01] <kimundi> we can either treat 1elem containers special, or treat all the same
[17:24:26] *** Parts: nslus (nslus@6BC3A018.3A8A22C3.59B6123A.IP) ()
[17:24:54] *** Quits: mschifer (Adium@2400BFD9.81DDA1E3.9BBDBC7E.IP) (Ping timeout)
[17:25:10] <kimundi> I think treating them special might end up nicer, but it might hurt in generics
[17:26:05] *** Quits: josh (josh@moz-C350AC70.hsd1.mn.comcast.net) (Quit: josh)
[17:27:03] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[17:27:08] <kimundi> {option, arc}.pop() feels strange... but would have the same lenght as get()
[17:27:26] *** Quits: mschifer1 (Adium@moz-6F601BE7.lightspeed.sntcca.sbcglobal.net) (Quit: Leaving.)
[17:27:29] *** Joins: mschifer (Adium@moz-6F601BE7.lightspeed.sntcca.sbcglobal.net)
[17:27:42] <kimundi> maybe that's the better way
[17:27:51] <engla> it's probably a bad idea
[17:28:08] <engla> Option is special after all, it's used everywhere
[17:29:04] <kimundi> get, take unwrap -> get, pop, remove
[17:29:44] *** Quits: deepdog (deepdog@moz-BE31AF27.hr.hr.cox.net) (Connection reset by peer)
[17:30:06] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[17:30:10] <kimundi> hm, no wait
[17:30:16] <hansjorg> New Ubuntu PPA with nightly and release versions: https://launchpad.net/~hansjorg/+archive/rust
[17:31:09] <kimundi> get, take, unwrap -> get, pop, unwrap
[17:31:23] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Quit: Computer has gone to sleep.)
[17:31:49] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[17:32:22] <kimundi> okay, pop would end up replacing take, not unwrap :-/ï»¿  
[17:33:05] *** Quits: victorporof (victorporo@B7024D9D.5270B130.78DC9724.IP) (Ping timeout)
[17:33:26] *** Joins: victorporof (victorporo@B7024D9D.5270B130.78DC9724.IP)
[17:33:37] <kimundi> opt.pop_unwrap()   :|
[17:34:04] <Ms2ger> opt.get_pop_unwrap()
[17:34:32] *** Joins: bnicholson (bnicholson@moz-BBE3ABD.mv.mozilla.com)
[17:35:11] <kimundi> oi, those names are bad enough, don't invent more xD
[17:35:35] <engla> forget I said pop
[17:35:55] * engla forgets about pop
[17:35:55] <kimundi> xD
[17:37:38] *** Quits: CarpNet (ac@moz-FD24B77.sohonet.co.uk) (Quit: Leaving)
[17:38:02] <engla> I put the storm in brainstorm. you bring the brain
[17:38:48] <kimundi> serious RFC: Treading Option, Arc, etc as 1 element container causes more harm than good. Don't do that
[17:39:10] <bstrie> engla: and I'll bring everything else
[17:39:40] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[17:39:45] <kimundi> If necessery, there can be a opt.into_container() -> OptionContainer
[17:41:13] *** Joins: josh (josh@moz-B7F7B970.hfc.comcastbusiness.net)
[17:41:49] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[17:42:11] *** Quits: LU324 (stuff@moz-A17E9A7B.dyn.embarqhsd.net) (Ping timeout)
[17:44:37] <bblum> renaming take_unwrap to one word would be cool
[17:44:43] *** Joins: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com)
[17:44:45] <bblum> although it is just the composition of take and unwrap
[17:45:30] *** Joins: LU324 (stuff@moz-A17E9A7B.dyn.embarqhsd.net)
[17:45:31] *** Joins: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net)
[17:46:28] <kimundi> it would be the composition of take_opt and unwrap
[17:47:13] <kimundi> though... regular take might not be usefull...
[17:47:48] <kimundi> so maybe keep take as is
[17:47:59] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[17:48:41] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[17:52:07] *** Joins: cowboyd (cowboyd@moz-1BD02A1E.sw.biz.rr.com)
[17:53:40] <bblum> what would 'regular take' mean
[17:53:41] *** Quits: Kruppe (user@moz-4DDA8AB8.uwaterloo.ca) (Client exited)
[17:54:09] <kimundi> for maximum consistency,  take()->Option T and unwrap->T could be expressed as take->T and take_opt()->Option T
[17:54:33] <bblum> hmm
[17:55:28] <kimundi> Meh, need to write up the 3+ possible szenarios I've come up with here at home
[17:57:54] *** Quits: CanhTak (Mibbit@moz-3104B86D.rev.sfr.net) (Quit: http://www.mibbit.com ajax IRC Client)
[17:58:21] <doener_> hm, looks like the unoptimized ll code for librustc grew by 10% since yesterday
[17:58:41] *** Joins: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch)
[18:00:06] <bblum> eholk: is there any reason that wait_event needs to return the packet-header-as-event to the selecting task... that the selecting task can't fulfill otherwise by just iterating the packets and checking for which one is ready?
[18:00:24] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[18:00:52] *** Quits: mschifer (Adium@moz-6F601BE7.lightspeed.sntcca.sbcglobal.net) (Connection reset by peer)
[18:00:52] *** Joins: mschifer1 (Adium@moz-6F601BE7.lightspeed.sntcca.sbcglobal.net)
[18:00:54] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Connection reset by peer)
[18:00:54] <eholk> bblum: i don't recall, but i doubt it. It's kind of handy to say "this is the even that work you up."
[18:01:05] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[18:01:06] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[18:01:11] <bblum> the event that you got all worked up about
[18:01:12] *** Joins: mye (mye@moz-7955B1FF.dip0.t-ipconnect.de)
[18:01:50] *** Quits: josh (josh@moz-B7F7B970.hfc.comcastbusiness.net) (Quit: josh)
[18:02:06] <pcwalton> brson: r? https://github.com/mozilla/rust/pull/7871
[18:02:09] <sully> ... my train ran out of power.
[18:02:11] <sully> and is stuck
[18:02:21] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[18:02:29] <eholk> bblum: wow, that was a stunning number of typos in my last message
[18:02:35] <true_droid> anyone experienced malloc error on OS X 10.7? https://gist.github.com/alco/6031502
[18:02:38] <eholk> i meant "this is the event that woke you up"
[18:02:39] <bblum> eholk: c.c
[18:02:41] <bblum> yes
[18:02:42] <true_droid> I've installed latest rust 0.7 from homebrew
[18:02:46] <sully> "what is this I don't even"
[18:02:54] <toddaaro> sully: why were you on a train?
[18:03:02] *** Quits: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP) (Ping timeout)
[18:03:03] <toddaaro> sully: ecr mentioned that SF office has no power
[18:03:08] *** Joins: lpapp (lpapp@759BF865.314C6558.9EF092A5.IP)
[18:03:12] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[18:03:14] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[18:03:20] <lpapp> hi, what threading support do you have in the language with rust?
[18:03:24] <sully> toddaaro: coming to MTV
[18:03:27] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[18:03:40] <toddaaro> wait what kind of train
[18:03:42] <true_droid> I had previously installed 0.6 and had no problem with it
[18:03:47] <sully> a caltrain
[18:03:50] <toddaaro> caltrain uses normal engines?
[18:03:52] <bblum> lpapp: http://static.rust-lang.org/doc/tutorial-tasks.html
[18:03:53] <toddaaro> they sound like normal engines
[18:03:58] <toddaaro> and spew smoke like normal engines
[18:04:06] <sully> yeah, it isn't an electric train.
[18:04:20] <toddaaro> did they say something about running out of power? or are you just stopped?
[18:04:24] <lpapp> bblum: thanks.
[18:04:28] *** Joins: mschifer (Adium@moz-BE33DA21.fw1.sfo1.mozilla.net)
[18:04:45] *** Quits: tjc (tjc@moz-6EB4E533.dsl.tsoft.com) (Quit: zzzzzzzzzz)
[18:04:51] <toddaaro> it could be the inevitable train-hits-car somewhere due to the completely bonkers way caltrain interacts with the roads
[18:05:04] <sully> yeah, they said the train was out of power
[18:05:09] <sully> the lights and AC just turned off
[18:05:12] <toddaaro> that is hilarious
[18:05:15] <sully> anyways, I will be late.
[18:05:20] <toddaaro> are they letting people off?
[18:05:32] <sully> I don't think so
[18:05:32] *** Quits: mschifer1 (Adium@moz-6F601BE7.lightspeed.sntcca.sbcglobal.net) (Ping timeout)
[18:05:36] <toddaaro> where are you on the route?
[18:05:40] <sully> we aren't really in a place compatible with getting off
[18:05:49] <sully> around redwood city, I think?
[18:06:03] <bblum> sully accidentally boarded the trollercoaster instead of the train
[18:06:17] *** Joins: fabiand (fabiand@moz-8C5E098B.adsl.alicedsl.de)
[18:06:19] <sully> lights and AC back on...
[18:06:26] <sully> and moving again
[18:06:47] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Connection reset by peer)
[18:07:02] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[18:08:49] <Ms2ger> Wait, caltrain still uses steam trains?
[18:09:45] *** Joins: Kruppe (user@moz-4DDA8AB8.uwaterloo.ca)
[18:10:32] *** Parts: lpapp (lpapp@759BF865.314C6558.9EF092A5.IP) ()
[18:10:33] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Connection reset by peer)
[18:10:48] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[18:13:31] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[18:13:32] *** Joins: lpapp (lpapp@759BF865.314C6558.9EF092A5.IP)
[18:13:39] <lpapp> how many people work on rust in full-time?
[18:19:02] *** Joins: lkuper (lkuper@1DA54DF2.B2F13A36.EA79609A.IP)
[18:20:59] <homa_rano> is there a way to return a struct with a borrowed pointer in it?
[18:21:45] <homa_rano> say, for an iterator struct to point into a borrowed chunk of data
[18:21:54] <engla> sure
[18:22:07] <homa_rano> the named lifetime docs seem unhelpful
[18:22:16] *** Joins: ecr1 (Thunderbir@moz-BBE3ABD.mv.mozilla.com)
[18:22:23] <kimundi> homa_rano: They are even required for this ;)
[18:22:33] <homa_rano> I surmised as much
[18:22:54] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[18:23:05] <kimundi> I think it works somewhat like this: struct Foo<'a, T> { data: &'a T }
[18:23:07] *** Quits: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[18:23:11] *** Quits: Yurume_ (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[18:23:34] <kimundi> bblum: Gonna write up a RFC now
[18:23:51] *** Quits: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu) (Ping timeout)
[18:24:07] *** Joins: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu)
[18:24:47] <engla> homa_rano: the extra::ringbuf iterators do that, no tricks or unsafe code
[18:24:49] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Ping timeout)
[18:26:04] <homa_rano> just the example I was looking for, thanks
[18:28:32] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[18:28:32] *** ChanServ sets mode: +o dherman
[18:29:13] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[18:29:18] <bblum> lpapp: 5
[18:31:34] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[18:33:06] <lpapp> bblum: ok, that is not much.
[18:33:50] <bblum> 6 if you count dherman, who is our boss but mostly actually works on other stuff
[18:34:06] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[18:34:16] <bblum> there are additionally 4 rust interns this summer and 3(?) servo interns
[18:34:39] <lpapp> servo?
[18:34:58] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[18:35:27] <kmc>  https://github.com/mozilla/servo a prototype web browser rendering engine written in Rust
[18:35:40] <lpapp> right
[18:35:48] <kmc> it's almost certainly the biggest Rust project other than the Rust compiler itself
[18:35:57] <kmc> and is sort of the reason Rust exists
[18:36:08] <lpapp> looks like this trait stuff is similar to concepts in C++.
[18:36:22] <cmr> lpapp: you mean concepts are similar to typeclasses? :)
[18:36:48] *** Quits: lkuper (lkuper@1DA54DF2.B2F13A36.EA79609A.IP) (Ping timeout)
[18:36:57] <dherman> ...and similar to interfaces in Java and traits in the Smalltalk literature
[18:37:03] <lpapp> cmr: no
[18:37:17] * dherman thought both lpapp and cmr were right
[18:37:28] <cmr> dherman: it's a matter of which one came first
[18:37:44] <lpapp> cmr: typeclasses are in Haskell.
[18:37:49] <lpapp> I referred to traits in rust
[18:37:50] <cmr> lpapp: and rust
[18:37:54] <cmr> traits are typeclasses.
[18:38:04] <lpapp> "Traits are the way to tell the Rust compiler about functionality that a type must provide."
[18:38:05] <dherman> lpapp: cmr is giving you some of the history
[18:38:14] <lpapp> w00t history?
[18:38:17] <dherman> traits in Rust are similar *both* to concepts in C++ and typeclasses in Haskell
[18:38:18] <dherman> and in fact,
[18:38:23] <kmc> Caltrain uses diesel-electric locomotives (http://en.wikipedia.org/wiki/Caltrain#Locomotives); there are plans to electrify the line and switch to electric-multiple-unit trains, possibly as part of California High Speed Rail, but it'll take like a decade and infinity billion dollars for various dumb reasons
[18:38:24] <dherman> concepts were inspired by typeclasses
[18:38:38] *** Quits: fabiand (fabiand@moz-8C5E098B.adsl.alicedsl.de) (Quit: Verlassend)
[18:39:54] *** Quits: lpapp (lpapp@759BF865.314C6558.9EF092A5.IP) (Ping timeout)
[18:40:01] *** Joins: lmandel (lmandel@8B192B20.1F93A08E.ADB88A9.IP)
[18:40:24] <Ms2ger> kmc, wow, those Americans are even farther behind than I'd realized :)
[18:40:37] <kmc> yeah passenger rail in the USA is pathetic
[18:41:02] <jasom> how do I get a backtrace from an ICE?
[18:41:19] <cmr> jasom: on non-windows, RUST_LOG=::rt::backtrace
[18:41:21] <cmr> (or gdb)
[18:41:40] <jasom> cmr: the gdb backtrace was non-informative
[18:41:56] <cmr> jasom: well, that's all there is
[18:42:15] <jasom> no, rt::backtrace was from closer to the ICE
[18:42:20] <jasom> the gdb one was from a later assertion
[18:42:27] <bstrie> who all saw nmatsakis' talk today? what was it about?
[18:43:09] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[18:43:46] *** Joins: lpapp (lpapp@759BF865.314C6558.9EF092A5.IP)
[18:43:57] <lpapp> sorry, got disconnected due to a flaky hostel internet connection.
[18:44:08] <kmc> i saw the dry run yesterday; it was about how Rust provides memory safety, using iterator invalidation in a hashmap as a case study
[18:44:54] *** Quits: ozten (ozten@19BD73A1.5D8BCA3A.A0C1B52F.IP) (Quit: ozten)
[18:44:56] <lpapp> does rust have something like modules in C++?
[18:45:02] <kmc> C++ has modules?
[18:45:19] <lpapp> it is on the way, yes.
[18:45:27] <kmc> oh, then i don't know
[18:45:27] <strcat> kmc: clang has an early sketch of them
[18:45:36] <strcat> they'll probably be proposed for C++17 or the one after ;p
[18:45:36] *** Joins: lpapp_ (lpapp@759BF865.314C6558.9EF092A5.IP)
[18:45:41] *** Quits: cowboyd (cowboyd@moz-1BD02A1E.sw.biz.rr.com) (Client exited)
[18:45:43] <kmc> Rust has modules (which are a unit of namespacing and encapsulation) and also crates (which are a unit of compilation and linking)
[18:46:02] <dherman> C++ modules are being designed in an absurdly harder setting
[18:46:03] <lpapp> strcat: yeah, but TR is fine.
[18:46:12] <dherman> trying to retrofit modules on top in a way that's more-or-less compatible with #include
[18:46:27] <kmc> yikes
[18:46:28] <dherman> we had the benefit of putting them in from the get-go
[18:46:37] <strcat> lpapp: do they really ever add major compiler features to technical reports?
[18:46:48] <lpapp_> strcat: yes, of course.
[18:47:14] <lpapp_> or perhaps not.
[18:47:16] <jasom> can I get the name of the function it'
[18:47:18] <lpapp_> well, concepts go into TR
[18:47:20] <jasom> it's compiling when it ICEs?
[18:47:29] <cmr> jasom: nope
[18:48:12] <jasom> if I could even get e.g. trans_block to print a line # on each entry that would be nice
[18:48:38] <cmr> you'd have to add in a debug! yourself
[18:48:50] <cmr> or an info!, don't want to get drowned by the other debug! stuff
[18:49:44] <strcat> dherman: afaik what they did is forbid mixing both
[18:50:00] <strcat> dherman: it will translate #include <map> into 'import map' via a header->module mapping
[18:51:18] <jasom> it calls update_source_pos, so I can just turn debug output on; how do I get that to happen?
[18:51:40] <cmr> RUST_LOG=rustc=4
[18:51:48] <strcat> dherman: http://clang.llvm.org/docs/Modules.html#modularizing-a-platform
[18:51:49] <cmr> you'll want to use a path to something more selective though
[18:51:58] <cmr> like rustc::middle::trans::whatever=4
[18:51:59] <bblum> brson: is there any question about whether or not to do #5372
[18:52:14] *** Joins: victorporof_ (victorporo@C5842721.834833CE.4A6B528C.IP)
[18:53:12] <brson> bblum: no, #5372 is a go
[18:53:33] *** Quits: victorporof (victorporo@B7024D9D.5270B130.78DC9724.IP) (Ping timeout)
[18:54:11] *** Quits: victorporof_ (victorporo@C5842721.834833CE.4A6B528C.IP) (Client exited)
[18:54:17] *** Joins: victorporof (victorporo@B7024D9D.5270B130.78DC9724.IP)
[18:54:36] <brson> though Thiez's point is probably true - it'll make them less pleasant to use unless they can be captured mutably
[18:55:44] <dherman> strcat: right... chris lattner was telling us about that
[18:55:52] <olsonjeffery> man, the whole ~RtioIfaceObject thing for ~object is bleh.
[18:56:05] <bblum> brson: i don't understand that point.
[18:56:19] <bblum> oh, hm
[18:56:22] <bblum> i see.
[18:56:24] <brson> olsonjeffery: i think ~object has been improved. maybe it works now?
[18:56:30] <brson> though I doubt it
[18:56:32] <olsonjeffery> brson: i just tried it and it didn't work..
[18:56:45] *** Quits: bytewise (bytewise@moz-649C630D.unitymediagroup.de) (Quit: Leaving)
[18:56:48] *** Parts: lpapp_ (lpapp@759BF865.314C6558.9EF092A5.IP) ()
[18:56:51] *** Parts: lpapp (lpapp@759BF865.314C6558.9EF092A5.IP) ()
[18:56:59] <olsonjeffery> have a UvTimer that impls RtioTimer, a timer_init() -> ~RtioTimer on UvIoFactory
[18:57:03] *** Quits: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch) (Ping timeout)
[18:57:07] <strcat> brson: it sometimes does work
[18:57:13] <olsonjeffery> and the compiler wouldn't play along
[18:57:22] <strcat> I tested it a bit after removing exchange alloc headers and it doesn't seem to crash anymore
[18:57:25] <strcat> in common cases at least
[18:57:33] <olsonjeffery> had to have it return RtioTimerObject (which i missed the other factory methods doing, hence the mistake)
[18:57:41] <olsonjeffery> so, that's ~object in a nutshell. heh.
[18:57:55] <olsonjeffery> ~RtioTimerObject, even
[18:58:11] <strcat> ~fn on the other hand... :p
[18:59:03] *** Joins: MaikKlein1 (maik@moz-4CFF4604.dip0.t-ipconnect.de)
[18:59:06] *** Joins: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP)
[18:59:22] <olsonjeffery> so just to reason through this: the issue is not being able to represent ~Foo as a ~FooTrait .. hence newtypeing ala pub type FooTraitObject = Foo .. ?
[18:59:29] *** Joins: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com)
[19:00:08] <brson> bblum: the `let (port, chan) = stream()` pattern will no longer give you usable endpoints either, and `let mut (port, chan)` isn't valid
[19:00:12] <brson> sad
[19:00:24] <bblum> oh yeah, that's troublesome
[19:00:41] <bblum> when are we gonna get let (mut port, mut chan) ?
[19:00:52] *** Quits: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com) (Quit: tikue)
[19:01:31] *** Joins: victorporof_ (victorporo@C5842721.834833CE.4A6B528C.IP)
[19:01:34] <graydon> motion: rust is extremely pleasing to hack in
[19:01:42] <brson> olsonjeffery: yeah, the newtyping is just to make it clear where all the fixes go once twiddle objects work
[19:01:42] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[19:01:42] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/vcue2g
[19:01:42] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[19:01:45] *** Quits: victorporof_ (victorporo@C5842721.834833CE.4A6B528C.IP) (Client exited)
[19:01:51] *** Joins: victorporof_ (victorporo@B7024D9D.5270B130.78DC9724.IP)
[19:01:56] <brson> graydon: seconded
[19:01:59] *** Joins: cowboyd (cowboyd@moz-1BD02A1E.sw.biz.rr.com)
[19:02:03] <graydon> all opposed?
[19:02:08] <graydon> ...
[19:02:14] *** Joins: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com)
[19:02:16] <cmr> motion carries!
[19:02:22] <brson> bblum: haven't heard anything about mut bindings
[19:02:26] *** Joins: zslayton1 (Mibbit@1D191528.269AFE30.6A3AF4D7.IP)
[19:02:29] *** Quits: victorporof (victorporo@B7024D9D.5270B130.78DC9724.IP) (Ping timeout)
[19:02:46] <graydon> writing an iterator that consumes its argument with no copies is ... completely rad
[19:03:02] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[19:03:34] *** Quits: victorporof_ (victorporo@B7024D9D.5270B130.78DC9724.IP) (Ping timeout)
[19:03:56] <bblum> we have done a pretty good job adapting our libraries to the linear type thing
[19:04:19] <graydon> the question is: can I use http://images2.wikia.nocookie.net/__cb20120330224944/tron/images/8/8e/Digitize-Laser_Orange.png in a talk slide?
[19:04:23] <brson> bblum: pcwalton says both these problems are going to be fixed
[19:04:26] <bblum> it's fun to think about the moves under the hood and sometimes you forget about them and get easy compile errors but it never really bites you hard anymore
[19:04:28] <graydon> I bet the copyright police would say it's not ok
[19:04:41] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[19:04:41] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/QBqejA
[19:04:41] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[19:04:43] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[19:04:43] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/J_vKVw
[19:04:43] <ghrust> 13rust/06auto 145d4b990 15gifnksm: tutorial: remove duplicate link references....
[19:04:43] <ghrust> 13rust/06auto 14827a6d2 15gifnksm: tutorial: remove unused link references.
[19:04:43] <ghrust> 13rust/06auto 14874eb19 15bors: auto merge of #7845 : gifnksm/rust/tutorial-remove-dup, r=cmr...
[19:04:45] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[19:05:20] <olsonjeffery> btw, got my rust shirt. thanks so much!
[19:05:20] <engla> strcat: I'm going to bug you with a suggestion, implementing Clone for some iterators, posted a PR https://github.com/mozilla/rust/pull/7882 what do you think about it?
[19:05:48] <strcat> engla: yeah I think they should have Clone
[19:05:54] *** Quits: mye (mye@moz-7955B1FF.dip0.t-ipconnect.de) (Quit: mye)
[19:06:19] <Ms2ger> graydon, that might be covered by Fair Use in the US
[19:06:21] <strcat> engla: the vector clone impl looks unsafe though
[19:06:26] <graydon> Ms2ger: oh?
[19:06:30] <graydon> which part of fair use?
[19:06:35] * graydon always gets a bit confused
[19:06:35] <engla> strcat: why?
[19:06:49] <strcat> engla: because the VecIterator it returns has an arbitrary lifetime
[19:06:49] <graydon> education? :)
[19:06:50] <Ms2ger> The one I vaguely remember from the time I worked on Wikipedia? :)
[19:06:56] <strcat> engla: it should have the same lifetime
[19:06:58] *** Joins: echristo (echristo@DCF57675.D6CCE4AE.77834EAA.IP)
[19:07:03] <strcat> engla: lifetime: self.lifetime
[19:07:04] <engla> strcat: ok not sure if that's really so
[19:07:18] <strcat> engla: you don't have a lifetime parameter to the return value and you're using transmute
[19:07:34] * strcat isn't sure if it should really compile
[19:07:35] <engla> it should be constrained by the fn clone signature in the trait
[19:07:43] <engla> I'm sure it compiles
[19:08:28] <strcat>  +    fn clone(&self) -> VecIterator<T> { 
[19:08:35] <strcat> that's missing one of the parameters though?
[19:09:06] <engla> I have recently learned that the lifetime parameters can be omitted
[19:09:07] <jasom> ah, yet another case of I was silly to even try using the "if" feature of match
[19:09:25] <cmr> jasom: are pattern guards broken?
[19:09:59] <jasom> cmr: in certain cases
[19:10:02] *** Quits: _Vi (vi@527C345F.497AA854.B16B3BE6.IP) (Ping timeout)
[19:10:09] <strcat> graydon: I don't think you have to worry about it, it's the same as wikipedia including low-res copyrighted images under fair use
[19:10:12] <engla> strcat: I didn't test so that your scenario couldn't happen, but it looked safe comparing with the fn iter() method. But I'll test it now
[19:10:22] <jasom> cmr: biggest outstanding one is if you do something like _ if (foo) => ... _ => ...
[19:10:33] <graydon> strcat: oh, huh. ok. because that image goes through my head just about every time I use linear destructuring :)
[19:10:41] <graydon> maybe it's a generational thing :)
[19:11:15] <bstrie> graydon: even in the worst case scenario where there's a legion of disney copyright lawyers attending the presentation, it would be great publicity for rust! lots of programmers will empathize with our plight
[19:11:23] <graydon> haha
[19:11:46] <Ms2ger> And if graydon gets some time inside... Oh well
[19:11:56] <bstrie> Ms2ger: graydon is canadian, he's above the law
[19:12:02] <bstrie> untouchable
[19:12:06] <bblum> north of the law maybe
[19:12:10] <graydon> canada has got pretty law-n-order in recent years
[19:12:12] <bstrie> definitely north of the law
[19:12:15] <bblum> but not necessarily at higher altitude
[19:12:19] <graydon> we even put a digital locks provision in. sad sad.
[19:12:29] <graydon> "I can write my own copyright law" etc
[19:12:34] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[19:12:49] <kimundi> Uuuurk, I'm thinking to math-y right now
[19:13:06] <graydon> fair dealing in canada is actually more-strict than fair use in the US
[19:13:12] <graydon> (no parody, for example)
[19:13:15] <bstrie> woah
[19:13:18] <Ms2ger> kimundi, as a mathematician, I can assure you there is no such thing :)
[19:13:22] <bstrie> it's like a totalitarian state
[19:13:49] <bstrie> I'm okay with being extrajudicially murdered by drones, just don't take away weird al
[19:14:16] *** Quits: lucian (lucian@moz-22A14C6A.cable.virginmedia.com) (Ping timeout)
[19:14:29] <bblum> boy i am not having an easy time discovering what the select-on-an-arbitrary-length vector is for the new ports and chans
[19:14:39] <bblum> hmmmmm
[19:16:11] <bstrie> bblum: looks like you'll just have to add type-level numerics to rust
[19:16:18] <engla> strcat: hm it looks like that was a real problem. Omitting lifetime parameter didn't behave like I expected.
[19:16:28] <bblum> bstrie: i'm sure that's the way, yes.
[19:16:51] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Connection reset by peer)
[19:17:41] *** Joins: victorporof (victorporo@B7024D9D.5270B130.78DC9724.IP)
[19:17:51] <graydon> bstrie: US drones patrol into our airspace, IIRC
[19:18:04] <graydon> bstrie: certainly my apartment is within range. most canadians live within 100km of the border.
[19:19:17] <strcat> graydon: just try to keep the number of likely tagged buzzwords down in your messages
[19:19:24] <bblum> straw poll: if i have a function parameterized over
[19:19:27] <strcat> you're already on high alert after that last one
[19:19:29] <graydon> strcat: yeah
[19:19:35] *** Quits: diegoyam (quassel@FF9B1514.A4EC3D18.3A1EC144.IP) (Ping timeout)
[19:19:40] <bblum> <T1, T2: Trait<T1>, T3, T4: Trait<T3>>
[19:19:45] <bblum> what do I name T1-4?
[19:19:55] <strcat> "airspace", "within range", "border"
[19:19:56] <bblum> T,A,B,U? AA,A,BB,B?
[19:19:56] <cmr> U, V, W, H
[19:20:01] <graydon> strcat: I mean, I'm on IRC already, I think that's considered "pretty suspicious" these days, no?
[19:20:04] <bblum> A,C,G,T? ;)
[19:20:09] *** Joins: doomlord (doomlod@42802052.53E08B38.C3DDD137.IP)
[19:20:13] <olsonjeffery> I can just imagine the generals and high level administration officials sitting around a table at a targetting meeting: "Well, they call him the BDFL... All I know is it has Dictator in the name!"
[19:20:17] <strcat> graydon: probably ;p
[19:20:24] <graydon> let's just drop the whole matter and go have a picnic
[19:20:24] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Connection reset by peer)
[19:20:31] <bstrie> olsonjeffery: we'll have to think of a more discreet alias for BDFL
[19:21:06] <graydon> moved: omit suspicious keywords in #rust
[19:21:08] <olsonjeffery> well, im sure graydon is safe, as is.. unlike rob pike is at the meeting
[19:21:46] <bblum> i think the right answer is probably AT, A, BT, and B
[19:22:12] <bstrie> graydon: we'll take it to #rust_for_terrorists
[19:22:28] <strcat> bblum: for the iterators I named the element types A, B, C and corresponding iterators T, U, V ;p
[19:22:30] *** Quits: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP) (Ping timeout)
[19:22:37] <bblum> or maybe TA, A, TB, B
[19:22:37] *** Quits: MaikKlein1 (maik@moz-4CFF4604.dip0.t-ipconnect.de) (Ping timeout)
[19:22:53] <eevee> terrorusts
[19:22:55] <bblum> maybe i should use unicode greek letters
[19:22:57] <bstrie> hahaha
[19:23:01] <bblum> is that cool to do in the libraries?
[19:23:03] <bstrie> eevee: I really like that name for rust users
[19:23:12] <engla> A for the iterator and Î± for the element
[19:23:23] <pcwalton> graydon: r? https://github.com/mozilla/rust/pull/7884
[19:23:43] * graydon mildly serioius. feeling a bit spooked out past few months. tinfoil-hat-world seems to be .. a conservative underestimate.
[19:23:53] *** Quits: victorporof (victorporo@B7024D9D.5270B130.78DC9724.IP) (Ping timeout)
[19:24:08] <strcat> engla: but basically it should be able to compile without transmute
[19:24:10] <bstrie> graydon: "conservative" is a watchword!
[19:24:14] <graydon> ay ay ay
[19:24:16] *** Joins: victorporof (victorporo@B7024D9D.5270B130.78DC9724.IP)
[19:24:23] <graydon> pcwalton: memory use +/- ?
[19:24:24] <strcat> the new lifetime should be the same as the old
[19:24:30] <engla> strcat: yup, I've confirmed the problem and used your fix
[19:24:33] *** Joins: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP)
[19:25:04] <graydon> pcwalton: several of those are @mut. no effect on un-sharing them? (i.e. they weren't supposed to be same-value, multiply-accessed)?
[19:25:04] <strcat> cmr: is the isrustfastyet mem bot still testing stuff?
[19:25:08] <strcat> seems to be falling behind
[19:25:09] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[19:25:14] <cmr> he is currently offline
[19:25:20] <strcat> ah
[19:25:28] <cmr> hopefully back today
[19:26:57] <doomlord> wouldnt a "terrorust" be someone using rusts anti-patterns 
[19:27:16] *** Quits: victorporof (victorporo@B7024D9D.5270B130.78DC9724.IP) (Ping timeout)
[19:27:25] *** Joins: victorporof (victorporo@B7024D9D.5270B130.78DC9724.IP)
[19:27:25] *** Quits: victorporof (victorporo@B7024D9D.5270B130.78DC9724.IP) (Client exited)
[19:28:26] <olsonjeffery> woohoo! wrote my first newsched binding!
[19:28:37] <strcat> heh, wine supports android now
[19:28:39] <doomlord> re the borrowed @mut problem, would changing a program to just use @ *everywhere* get it working(never mind if thats efficient or not)
[19:28:52] <strcat> so android has more support for legacy windows applications than windows phone
[19:29:01] <jasom> cmr: and I'm collecting versions of my lib that have other ICEs in pattern guards; I may or may not reduce them but will eventually file issues
[19:29:02] <olsonjeffery> brson: do you think you could whip up a quick gist or point to where i get an idea how to write user-level code using newsched? compiler flags, example main() etc
[19:30:22] <jasom> but so far every ICE i've gotten on 0.7 has involved a pattern guard
[19:30:51] <cmr> olsonjeffery: ask ChrisMorgan if/when he's around, he's been writing an http server with the newrt
[19:30:59] <cmr> doomlord: yes, it would
[19:31:06] <cmr> doomlord: or, rather, using @mut everywhere
[19:31:47] <doomlord> ok thats good news, so one could use rust as a simple utility language with @...  or write efficient code the ~/stack way
[19:31:51] <jasom> I heard a rumor that @ is going away; is there any truth to that?
[19:32:02] <graydon> strcat: that is extremely cool
[19:32:06] <graydon> (wine + android)
[19:32:15] <graydon> huge respect for wine folks. that is an amazing task.
[19:32:18] <strcat> graydon: I imagine it only works on x86 devices though ;p
[19:32:19] <Ms2ger> There has been some talk about moving @ out of the language proper
[19:32:20] <graydon> sure
[19:32:23] <jack> jasom: it has not been decided yet but is under discussion
[19:32:40] <kmc> strcat: or for running Windows RT programs :D
[19:32:51] <jasom> Ms2ger: that's roughly what I heard; that managed pointers could be implemented as a library
[19:33:02] <doomlord> it seems GC and non GC just doesn't mix well, but i like the idea of being able to do both in the same language
[19:33:03] <Ms2ger> We must be reading the same blog :)
[19:33:07] <graydon> jasom: it'd only be about changing superficial interfaces of it and/or librarifying it more. we're not "getting rid of GC" or anything
[19:33:11] <doomlord> just not the same program
[19:33:31] <kmc> doomlord: why do you say they don't mix
[19:33:39] <graydon> doomlord: they work together. the interfaces are a bit fussy, but it's fine.
[19:33:41] <jasom> Personally, I have a language that I like a lot for "I don't care about GC pauses" so they are an uninteresting part of rust for me
[19:34:06] <doomlord> &/@mut problem , well it could just be my lack of experience with GC languages.. (C++ background..)
[19:34:08] *** Joins: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch)
[19:34:10] <cmr> jasom: what is the interesting part of rust?
[19:34:20] <Ms2ger> Types!
[19:34:24] <jasom> cmr: a systems language that tracks pointer lifetimes
[19:34:26] *** Quits: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch) (Max SendQ exceeded)
[19:34:29] <Ms2ger> And syntax bikesheds!
[19:34:32] <graydon> jasom: yeah, we just need them for .. there are pretty large classes of programs for which "cyclic references" are a natural component. failure to gc those means people make their own "graph" container storing nodes and write their own GC in there..
[19:34:33] <strcat> engla: sec let me look again
[19:34:36] <kmc> jasom: maybe you don't care about thread-local GC pauses but you can't afford a global GC pause
[19:34:39] <Ms2ger> (Sorry)
[19:35:19] <graydon> jasom: but I suspect we might also manage to ship the rust standard library with no GC uses, or .. very few. it seems ~ and & combine well enough for many cases
[19:35:32] <graydon> it's nice to be able to offer the tradeoff
[19:35:37] <cmr> libstd doesn't have any @ except at-vec iirc
[19:35:38] <doomlord> i think youve  made good choices making compact syntax for the most useful extremes in memory management
[19:35:45] *** Joins: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch)
[19:36:13] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[19:36:13] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[19:36:19] <jasom> kmc: there are huge swaths of programs for which SBCL's GC pauses are short enough; e.g. user-facing applications where anything shorter than 200ms goes unnoticed
[19:36:19] <cmr> Guhh
[19:36:25] *** Quits: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com) (Quit: tikue)
[19:36:31] <engla> cmr: still in Rand for TLS I think
[19:36:35] *** Joins: strcat1 (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[19:36:42] <strcat1> engla: btw I don't think #[deriving(Clone)] will work on a struct with a borrowed pointer atm
[19:36:46] <strcat1> because auto-deref is messed up
[19:36:50] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[19:36:51] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[19:36:51] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[19:36:55] <engla> yeah it didn't work on VecIterator
[19:36:56] *** strcat1 is now known as strcat
[19:37:07] <cmr> Does anyone know an extension or anything for gmail that 1. starts replies at the bottom, 2. auto-expands the thing you're quoting?
[19:37:08] *** Quits: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch) (Max SendQ exceeded)
[19:37:20] *** Joins: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch)
[19:37:36] <engla> strcat: do you mean some of the str iterators will be wrong with Clone?
[19:37:40] * bstrie did not realize that tony hoare created quicksort
[19:37:50] <strcat> engla: well I mean it won't actually create working Clone impls
[19:37:53] <strcat> it will just be a no-op
[19:38:26] <strcat> rusti: #[deriving(Clone)] struct Foo { x: int } let a = Foo { x: 5 }; let b = a.clone(); println(fmt!("%?", b))
[19:38:28] -rusti- <anon>:7:80: 7:90 error: type `main::Foo` does not implement any method in scope named `clone`
[19:38:29] -rusti- <anon>:7          #[deriving(Clone)] struct Foo { x: int } let a = Foo { x: 5 }; let b = a.clone(); println(fmt!("%?", b))
[19:38:29] -rusti-                                                                                          ^~~~~~~~~~
[19:38:29] -rusti- error: aborting due to previous error
[19:38:29] -rusti- application terminated with error code 101
[19:38:29] <jasom> cmr: sure, it's called an IMAP client :)
[19:38:38] <strcat> oh well...
[19:38:40] <strcat> rusti can't do deriving
[19:38:42] <strcat> separate issue
[19:38:44] <strcat> ;p
[19:38:46] <engla> yeah
[19:38:51] <strcat> doesn't work in function scopes
[19:38:58] <strcat> engla: anyway the issue is this:
[19:39:00] <cmr> jasom: there are none I've found worth using except notmuch...
[19:39:08] *** Quits: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch) (Ping timeout)
[19:39:11] <strcat> rusti: let x = 5; let y = &x; println(fmt!("%?", y.clone()))
[19:39:12] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/AjLG
[19:39:18] <engla> anyway deriving Clone did work partially on VecIterator, but it would require that T implemented Clone too, which is wrong
[19:39:22] <strcat> rusti: let x = 5i; let y = &x; println(fmt!("%?", y.clone()))
[19:39:24] -rusti- 5
[19:39:24] -rusti- ()
[19:39:36] <strcat> it turns &int -> int
[19:39:39] <engla> I have no idea how that interacts with generics and clone tbh
[19:39:47] <strcat> rusti: let x = 5i; let y = &x; println(fmt!("%?", (&y).clone()))
[19:39:49] -rusti- &5
[19:39:49] -rusti- ()
[19:40:00] <strcat> you need & &int to get &int from Clone
[19:40:04] *** Joins: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch)
[19:40:08] <strcat> and deriving can't really deal with that
[19:40:15] <strcat> so it just doesn't work on any struct with borrowed ptrs
[19:40:22] *** Quits: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch) (Max SendQ exceeded)
[19:40:50] <strcat> auto-deref is often a misfeature :(
[19:40:51] *** Joins: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch)
[19:41:11] <jasom> cmr: I'll have to checkout notmuch; I have all my e-mail in a local maildir anyway
[19:41:19] <cmr> jasom: it's an extremely useful tool
[19:41:42] <strcat> cmr: I don't like what they did to gmail
[19:41:45] *** Joins: jgilbert (jgilbert@moz-7B0110AD.mv.mozilla.com)
[19:41:50] <strcat> can't edit the text box in an external editor anymore
[19:41:55] <cmr> strcat: neither do I
[19:42:01] <cmr> the service is degrading imo
[19:42:05] <strcat> filled with html nonsense even when set to plain text
[19:42:20] <cmr> (I stopped hosting my own mail after my postfix exploded)
[19:42:39] <strcat> I still like it as a mail host
[19:42:46] <strcat> just not their web app
[19:42:49] <cmr> right
[19:42:59] *** Quits: sankha93 (Instantbir@E677A839.19E4BF68.25B273F5.IP) (Ping timeout)
[19:43:10] <engla> strcat: I've got an example where it seems to work, deriving(Clone) on extra::dlist::DListIterator (part of that PR)
[19:43:29] <strcat> hm
[19:43:44] <strcat> engla: does it work on the str ones?
[19:43:55] <strcat> maybe there's a workaround in place now
[19:44:02] *** Joins: tcsc (tcsc@moz-ADC0ED45.hsd1.ct.comcast.net)
[19:44:04] <engla> don't know
[19:44:05] *** Quits: tcsc (tcsc@moz-ADC0ED45.hsd1.ct.comcast.net) (Input/output error)
[19:44:11] *** Joins: tcsc (tcsc@moz-ADC0ED45.hsd1.ct.comcast.net)
[19:45:21] *** Quits: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch) (Max SendQ exceeded)
[19:45:29] *** Joins: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch)
[19:45:34] *** Quits: jgilbert (jgilbert@moz-7B0110AD.mv.mozilla.com) (Ping timeout)
[19:45:41] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[19:46:31] *** Joins: jgilbert (jgilbert@moz-7B0110AD.mv.mozilla.com)
[19:47:47] <engla> I'm testing
[19:48:05] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[19:48:47] <kmc> are cyclic references between crates not allowed? i want to import (or just "forward declare") a struct from crate B so that a struct in crate A can contain an @ pointer to that struct, but B already depends on A
[19:49:05] <bstrie> kmc: I don't think cycles are allowed
[19:50:16] *** Joins: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP)
[19:50:56] <graydon> confirming: it's not possible for me to clone an extern fn() or any other existential?
[19:51:05] <graydon> (this is a kinda big problem if so)
[19:51:34] <strcat> graydon: or fixed-size arrays
[19:51:41] <strcat> because we lack integers in the type system
[19:51:50] <strcat> so you can't write an implementation for fixed-size arrays of any trait
[19:51:57] <graydon> ok
[19:52:01] <strcat> (if anyone wonders why they have no methods)
[19:52:20] <graydon> things that used to be copyable are now not-at-all copyable. we need to address that, I think.
[19:53:06] <engla> extern fn is still implicitly copyable
[19:53:29] <kmc> isn't there fn: Copy()
[19:53:39] <engla> Copy was removed yesterday
[19:53:51] <strcat> I wonder if I can rm ~fn take glue
[19:54:16] <kmc> engla: the trait was??
[19:54:20] <graydon> engla: implicitly copyable doesn't work with deriving(Clone), so if I have a map full of functions, I'm out of luck
[19:54:21] <kmc> er, I guess it's called Clone
[19:54:24] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Quit: Leaving.)
[19:54:32] <graydon> (or any other existential)
[19:54:43] <engla> right
[19:54:47] <strcat> graydon: you'd have been out-of-luck before if maps actually implemented reseeding on clones
[19:54:57] <graydon> probably
[19:55:18] <strcat> basically everything now suffers the pain that things with destructors suffered
[19:55:21] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[19:55:42] *** Quits: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP) (Client exited)
[19:56:10] <strcat> you couldn't copy a fixed-size array of things with destructors before, etc. ;p
[19:57:10] <engla> kmc: yes, and you can't use fn:Clone() since Clone is not a builtin
[19:57:54] <engla> strcat: str iterators .iter() and .split_iter() work with simple tests. clone() compiles, yields the same elements
[19:58:06] <strcat> ah okay
[19:58:08] * strcat will r+
[19:58:18] *** Joins: dwhyte (dwhyte@ED9190FB.B72E355F.7BF4A4B0.IP)
[19:58:23] <engla> I can add tests for str iterators
[19:58:49] <strcat> well what we really need is tests for deriving
[19:58:54] *** Joins: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP)
[19:59:25] <engla> hm
[19:59:49] <jdm> has any progress been made on snapshotting?
[20:00:08] <cmr> aatch might have something in the works but if not, no
[20:00:17] <strcat> the one aatch started is old now though
[20:00:17] <mark_edward> strcat: how is arch for development
[20:00:26] <cmr> he doesn't want to snapshot the memory regression
[20:00:32] <smvv> rusti: enum AB { None, A { a: int }, B { b: int } } let b = Some(B {b: 1}); match b { Some(A { a: _ }) => true, _ => false }
[20:00:34] -rusti- true
[20:00:41] <smvv> is this a known bug? ^
[20:00:47] *** Quits: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP) (Client exited)
[20:00:48] <strcat> mark_edward: it's great, newest stable releases of everything, most things you could ever want in the repos and everything else in the AUR ;p
[20:00:50] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[20:00:57] *** Joins: mschifer1 (Adium@moz-BE33DA21.fw1.sfo1.mozilla.net)
[20:01:00] <cmr> Plus no separate -dev packages!
[20:01:03] *** Quits: mschifer (Adium@moz-BE33DA21.fw1.sfo1.mozilla.net) (Ping timeout)
[20:01:11] <mark_edward> strcat: i'm heavily invested in ubuntu... i do think i might like to switch
[20:01:22] <mark_edward> what do you use for a DE?
[20:01:55] <strcat> I just use a window manager that comes with a panel/systray
[20:02:06] <kmc> engla: ah
[20:02:12] <strcat> don't have a need for anything but a bunch of terminals, web browser and editor
[20:02:15] <mark_edward> ok.
[20:02:24] <strcat> all I need is a window manager that lets me arbitrarily tab/stack/tile things
[20:02:26] <mark_edward> i see
[20:03:05] <kmc> hm so is there a general solution to the "cyclic references between structs defined in different crates" problem? or do I just need to break the cycle
[20:03:09] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[20:03:24] <strcat> kmc: break it or define them in the same crate
[20:03:44] <kmc> ok
[20:03:49] <strcat> crate deps should (have to?) be a tree
[20:04:50] <kmc> makes sense
[20:05:01] <kmc> a totally reasonable language rule that unfortunately will make my life harder
[20:05:06] <strcat> well s/tree/DAG/
[20:08:29] *** mschifer1 is now known as mschifer
[20:08:34] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Quit: Leaving.)
[20:08:44] *** Joins: mye (mye@moz-7955B1FF.dip0.t-ipconnect.de)
[20:09:37] *** Joins: jgilbert_ (jgilbert@moz-BBE3ABD.mv.mozilla.com)
[20:09:55] *** Quits: jgilbert (jgilbert@moz-7B0110AD.mv.mozilla.com) (Ping timeout)
[20:14:11] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[20:15:59] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[20:17:23] *** Quits: reyre (reyre@86C3727C.33EE9F8A.1139E686.IP) (Client exited)
[20:18:33] <graydon> poll: fn consume() or fn consume_iter() ?
[20:19:52] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[20:20:13] <Eridius> context?
[20:22:42] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[20:23:40] <steven_is_false> Hi, for my pull request https://github.com/mozilla/rust/pull/7875#issuecomment-21198772 I need to benchmark whether or not the format string construction is an issue. What's the best way to benchmark changes to the standard library like this?
[20:23:59] <cmr> steven_is_false: the built-in benchmark runner, usually
[20:24:12] <steven_is_false> Okay.
[20:24:35] *** Parts: steven_is_false (user@moz-144077DE.bchsia.telus.net) (ERC Version 5.3 (IRC client for Emacs))
[20:25:20] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[20:26:16] *** Quits: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP) (Ping timeout)
[20:27:24] <kmc> where is the in-memory layout of @mut boxes documented
[20:27:29] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Quit: Leaving.)
[20:27:50] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[20:28:49] <kmc> more specific question: is the reference count the first word
[20:29:45] *** Quits: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net) (Ping timeout)
[20:30:52] <doener_> kmc: yes, see struct  BoxHeaderRepr here http://static.rust-lang.org/doc/0.7/std/managed_raw.html#struct-boxheaderrepr
[20:30:53] *** Quits: kini (kini@moz-92AA953A.members.linode.com) (Quit: bye)
[20:31:07] *** Joins: kini (kini@moz-92AA953A.members.linode.com)
[20:31:37] *** Joins: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP)
[20:32:29] *** Quits: jgilbert_ (jgilbert@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving)
[20:33:10] <kmc> thanks! i definitely approve of having runtime structures like this accessible from the language itself
[20:33:20] *** Joins: robertknight (robertknig@moz-B6DD6E0B.range86-166.btcentralplus.com)
[20:33:22] <kmc> that Haskell lib 'vacuum' is really cool... lets you walk heap structures including closures
[20:33:56] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[20:35:04] *** Quits: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP) (Ping timeout)
[20:35:17] *** Quits: rbancroft (rumble@moz-4E8E0D7F.cg.shawcable.net) (Ping timeout)
[20:35:26] *** Joins: rbancroft (rumble@moz-4E8E0D7F.cg.shawcable.net)
[20:36:04] *** Quits: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu) (Ping timeout)
[20:36:48] *** Joins: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu)
[20:37:06] *** Joins: strcat1 (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[20:37:22] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[20:37:34] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[20:37:42] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[20:39:10] *** Joins: pnkfelix|rcirc (pnkfelix@moz-43495417.fbx.proxad.net)
[20:39:13] <steven_is_false> So I just ran make check-stage1-bench and it doesn't report the results to the console. How do I get the results so I can post it with the pull request as evidence?
[20:39:43] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Ping timeout)
[20:39:48] <steven_is_false> Like is there a file somewhere that stores the benchmark results?
[20:40:36] <graydon> that probably ran the ... compiletest benchmarks
[20:40:38] <graydon> test/bench/*
[20:40:54] <steven_is_false> graydon: Thanks!
[20:41:19] <graydon> microbenchmarks are done with #[bench]
[20:41:25] <graydon> no no, you're misunderstanding
[20:41:35] <graydon> I mean that check-stage1-bench is not running useful benchmarks
[20:41:45] <graydon> it's running like computer-language-benchmark-game tests
[20:41:53] <graydon> you want microbenchmarking with #[bench] inside the stdlib
[20:42:01] <graydon> there are instructions in that PR
[20:42:03] <graydon> "rustc --test --opt-level=3 std.rs && ../std --bench hashmap"
[20:42:24] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[20:42:24] *** ChanServ sets mode: +o dherman
[20:42:41] <steven_is_false> graydon: Hashmap doesn't have any #[bench] microbenchmarks.
[20:42:41] *** Joins: ozten (ozten@19BD73A1.5D8BCA3A.A0C1B52F.IP)
[20:42:54] <graydon> then you'll need to write some :)
[20:43:20] <steven_is_false> Okay.
[20:43:30] <graydon> (I mean, to satisfy a timing-comparison request. ideally everything should have lots of #[bench] benchmarks but few people have done many of them yet)
[20:43:30] *** Quits: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu) (Ping timeout)
[20:43:58] <Eridius> when is it appropriate to use `make check-stage1-*` vs `make check-stage2-*`?
[20:44:01] <graydon> make check-stage1-std will also run the std crate testrunner and will, by default, save benchmarks
[20:44:04] *** Joins: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu)
[20:44:08] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[20:44:13] <cmr> There are some in src/test/core-map.rs
[20:44:17] <graydon> stage2 for anything where you changed codegen (if you edited librustc)
[20:44:34] <graydon> stage1 is usually ok for libraries since they're rebuilt by then
[20:44:39] <cmr> I have a PR waiting in the queue to restructure the benchmarks to be betterly, but I couldn't figure out the makefile stuff
[20:44:39] <graydon> (stage0 is actually ok for a lot of library changes)
[20:44:51] *** Joins: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP)
[20:44:52] <graydon> cmr: ok. we can work on untangling that a bit.
[20:45:02] <graydon> I need to get lunch and head to office. still working from home, like a dope.
[20:45:38] * Ms2ger shakes his fist at makefiles
[20:45:53] *** Joins: wilsonk|2 (kvirc@moz-8E86F35A.cg.shawcable.net)
[20:46:16] <pnkfelix|rcirc> Ms2ger: here's another advertisement for remake: http://bashdb.sourceforge.net/remake/
[20:46:41] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[20:46:41] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/J_vKVw
[20:46:41] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[20:46:53] *** Quits: wilsonk-laptop (kvirc@moz-8E86F35A.cg.shawcable.net) (Ping timeout)
[20:48:12] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Ping timeout)
[20:48:17] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[20:49:38] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[20:49:38] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/kU-TwQ
[20:49:38] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[20:49:40] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[20:49:40] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/hwZ2Aw
[20:49:40] <ghrust> 13rust/06auto 148885b74 15Alex Crichton: Add documentation about mutable statics to rust.md
[20:49:40] <ghrust> 13rust/06auto 1478f8b40 15bors: auto merge of #7846 : alexcrichton/rust/static-mut-dox, r=pnkfelix...
[20:49:40] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[20:49:56] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[20:50:18] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[20:50:36] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[20:50:36] *** ChanServ sets mode: +o dherman
[20:52:23] *** Quits: Kruppe (user@moz-4DDA8AB8.uwaterloo.ca) (Ping timeout)
[20:53:17] <kmc> does __morestack do something clever with frame pointers so that GDB can follow the segmented stack? or perhaps it's not really clever but just the obvious thing you would do
[20:53:30] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[20:53:30] <cmr> kmc: the clever thing is its name
[20:54:11] *** Joins: Uther (Instantbir@moz-1B244B05.hfc.dyn.abo.bbox.fr)
[20:54:14] *** Joins: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com)
[20:54:35] *** Parts: Uther (Instantbir@moz-1B244B05.hfc.dyn.abo.bbox.fr) ()
[20:56:04] <graydon> r? someone https://github.com/mozilla/rust/pull/7885
[20:56:30] <graydon> both. gdb knows not to mention __morestack and __morestack sets up frame pointers so gdb can follow
[20:56:38] *** Quits: graydon (graydon@moz-1C52C8D0.cable.teksavvy.com) (Quit: Leaving.)
[20:57:19] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[20:57:48] *** Joins: _Vi (vi@527C345F.497AA854.B16B3BE6.IP)
[21:04:38] *** Joins: eschweic1 (Adium@moz-BBE3ABD.mv.mozilla.com)
[21:04:40] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Connection reset by peer)
[21:04:49] *** Joins: erickt1 (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[21:04:49] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Connection reset by peer)
[21:05:27] <kmc> oh, it does mention __morestack for me, but whatever
[21:05:29] <kmc> that's fine
[21:06:53] *** Joins: pnathan (Adium@moz-BDC3EE62.tukw.qwest.net)
[21:07:30] *** Joins: carllerche (carllerche@moz-CDE5367B.dsl.static.sonic.net)
[21:08:49] <kmc> unfortunately I think valgrind is less good at following the stack :/
[21:09:50] <bblum> what's the replacement for eachi?
[21:09:55] <strcat1> ideally rustc would output the DWARF unwinding info
[21:09:57] <bblum> iter().enumerate().advance ?
[21:09:59] <cmr> .iter().enumerate().advance
[21:10:00] <bblum> strcat1: ^
[21:10:02] <bblum> thanks
[21:10:13] <strcat1> bblum: enumerate will become a default method on Iterable
[21:10:20] <strcat1> they just don't work quite well enough yet
[21:10:31] <strcat1> 1 more showstopper bug fix needed + snapshot needed
[21:10:33] *** strcat1 is now known as strcat
[21:11:41] *** Joins: jaen (jaen@moz-36261275.internetdsl.tpnet.pl)
[21:12:13] *** Joins: Nisstyre (wes@moz-FD86289.netflash.net)
[21:14:31] <sully> hey, I've got a PR: https://github.com/mozilla/rust/pull/7886
[21:14:48] <sully> could someone look at it?
[21:14:55] *** Quits: flowsnake (flowsnake@moz-1918C33E.aztw.cable.virginmedia.com) (Connection reset by peer)
[21:14:57] *** Joins: brendan (brendaneic@10487EE8.58B1B661.22B0E380.IP)
[21:15:09] <strcat> heh just as I mentioned that bug ;p
[21:15:33] *** Joins: flowsnake (flowsnake@moz-1918C33E.aztw.cable.virginmedia.com)
[21:15:40] *** Quits: brendan (brendaneic@10487EE8.58B1B661.22B0E380.IP) (Quit: brendan)
[21:16:19] <sully> wait, which bug
[21:16:31] <sully> oh, the cross crate one?
[21:16:31] <strcat> sully: the metadata one for default methods
[21:16:39] <sully> yeah, god, that's a really bad bug.
[21:16:49] <sully> oh, did it end up getting filed by anyone other than me?
[21:16:53] *** Quits: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Quit: msingle)
[21:17:01] <sully> I just realized that I never looked to see if anybody else hit it before I filed it yesterday
[21:17:21] * sully was bad and only filed the bug as I was about to fix it
[21:17:34] <strcat> yeah I was running into that still ;p
[21:17:43] <strcat> since a lot of the iterator/container stuff is #[inline]
[21:17:46] <sully> this is the one bug that I feel pretty bad about
[21:17:57] <strcat> well they didn't work at all before you fixed them ;p
[21:18:01] <sully> because all of the other bugs were things that were broken when I showed up
[21:18:18] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Ping timeout)
[21:18:26] <bblum> strcat: ok, i have two vectors of equal length, and i want to iterate over them, one in by-ref mode and one by consuming the elements
[21:18:26] <sully> I mean, it was a bug that happened because I implemented xc default methods in a way that I knew wasn't the right way
[21:18:29] <bblum> strcat: what now?
[21:18:30] <sully> because it was simpler
[21:18:39] <strcat> bblum: zip will work
[21:18:46] <sully> without bothering to think it through properly
[21:18:51] <bblum> strcat: .consume_iter() ?
[21:19:05] <bblum> nice, guessed it in one
[21:19:11] <strcat> rusti: let xs = [1, 2, 3], let ys = ~[1, 2, 3]; for xs.iter().zip(ys.consume_iter()).advance |(x, y)| { println(fmt!("%? %?", x, y)) }
[21:19:13] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/UWUX
[21:19:15] <sully> I just noticed today that I actually had a note in my TODO list saying something about "defid drift and xc default methods"
[21:19:26] <strcat> rusti: let xs = [1, 2, 3]; let ys = ~[1, 2, 3]; for xs.iter().zip(ys.consume_iter()).advance |(x, y)| { println(fmt!("%? %?", x, y)) }
[21:19:28] <sully> so apparently I thought about this a few weeks ago, and then only really realized it last week
[21:19:28] -rusti- &1 1
[21:19:28] -rusti- &2 2
[21:19:28] -rusti- &3 3
[21:19:28] -rusti- ()
[21:19:34] <dherman> strcat: ping
[21:19:37] <strcat> dherman: pong
[21:19:50] <dherman> looking for some nice examples of pattern-matching for my talk
[21:20:00] <dherman> I'm told https://github.com/mozilla/rust/blob/master/src/libextra/treemap.rs is roughly Okasaki red-black trees
[21:20:15] <sully> hm, should I try to do a snapshot once my PR lands?
[21:20:25] <dherman> which is usually a nice demonstration of how concise pattern-matching can be
[21:20:28] <cmr> sully: please do (and good luck, you'll need it)
[21:20:28] <strcat> dherman: that doesn't really make great use of pattern matching though
[21:20:34] <dherman> ok
[21:20:36] <strcat> dherman: when I wrote it, match didn't work with lifetimes
[21:20:38] <sully> is snapshotting painful now?
[21:20:49] <bblum> strcat: is this right? for ports.mut_iter().zip(handles.consume_iter()).enumerate().advance |(index, (port, handle))| {
[21:20:50] <sully> I did tons of snapshots last summer and didn't think it was that bad
[21:20:51] <cmr> there are a bunch of staged changes
[21:21:00] <strcat> bblum: yep that looks right
[21:21:03] <bblum> hot
[21:21:05] <cmr> what's it been? a month?
[21:21:16] <strcat> bblum: I just wish we had the new loop for .advance would be gone :(
[21:21:23] <strcat> new for loop*
[21:21:26] <bblum> yes
[21:21:29] <bblum> actually i don't think i need the enumerate in this position
[21:22:07] <dherman> strcat: right you are, all I see is Option and cmp matches
[21:22:26] *** Quits: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu) (Ping timeout)
[21:22:26] <bblum> oh, i do need it
[21:22:43] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[21:22:56] <dherman> strcat: do you know of a nice simple functional rb tree using ~ instead of @?
[21:23:08] <dherman> I found https://github.com/stevej/rustled/blob/master/red_black_tree.rs but it's using managed pointers
[21:23:23] <strcat> dherman: nope, I don't :(
[21:23:30] <dherman> k, no worries
[21:24:02] *** Joins: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu)
[21:24:10] *** Joins: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP)
[21:24:11] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[21:25:24] *** Joins: MaikKlein1 (maik@moz-4CFF4604.dip0.t-ipconnect.de)
[21:26:07] <kimundi> bblum: I wrote down what I came up with earlier on IRC in https://github.com/mozilla/rust/issues/7887
[21:26:39] <strcat> dherman: it's tricky to do it with no copies or @
[21:26:54] <strcat> less tricky now, so maybe there could be more pattern matching
[21:27:01] <strcat> it needs a lot of swaps though
[21:27:34] *** Quits: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu) (Ping timeout)
[21:27:56] *** Quits: dwhyte (dwhyte@ED9190FB.B72E355F.7BF4A4B0.IP) (Quit: Leaving.)
[21:28:09] *** Joins: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu)
[21:28:10] *** Joins: reyre (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[21:29:31] *** Joins: brendan (brendaneic@10487EE8.58B1B661.22B0E380.IP)
[21:29:37] <MaikKlein1> what does RFC mean?
[21:29:41] <strcat> request for comments
[21:29:42] <doener_> request for comments
[21:29:43] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Ping timeout)
[21:29:48] <Ms2ger> IETF standard?
[21:29:52] <MaikKlein1> ah thanks
[21:30:30] <jasom> Hmm, whenever I enable logging on a ::rt:: crate, it fails with critbit: /export/jmiller/home/src/rust-0.7/src/rt/rust_log.cpp:137: void rust_log::trace_ln(rust_task*, uint32_t, char*): Assertion `!task->on_rust_stack() && "logging on rust stack"' failed.
[21:30:35] <pcwalton> yay, bootstrapped with @'static
[21:30:35] *** Quits: brendan (brendaneic@10487EE8.58B1B661.22B0E380.IP) (Quit: brendan)
[21:30:46] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[21:30:48] *** Quits: Azdle (Azdle@moz-B334B496.hfc.comcastbusiness.net) (Ping timeout)
[21:31:07] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[21:31:20] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[21:31:51] *** Quits: erickt1 (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[21:32:12] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[21:32:41] *** Quits: reyre (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Connection reset by peer)
[21:32:51] *** Joins: reyre (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[21:33:29] <steven_is_false> What's @'static?
[21:34:19] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[21:35:01] <bblum> kimundi: looks good, thanks
[21:35:07] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[21:35:16] *** Quits: pnathan (Adium@moz-BDC3EE62.tukw.qwest.net) (Quit: Leaving.)
[21:35:27] *** Joins: _1126 (1126@moz-83D60E55.lileth.net)
[21:35:35] *** Parts: steven_is_false (user@moz-144077DE.bchsia.telus.net) (ERC Version 5.3 (IRC client for Emacs))
[21:36:45] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[21:36:45] *** ChanServ sets mode: +o brson
[21:37:15] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[21:37:17] *** Joins: brendan (brendaneic@10487EE8.58B1B661.22B0E380.IP)
[21:37:29] *** Joins: Vert (quassel@8A83479C.391ACC8C.CAF63861.IP)
[21:37:42] *** Joins: strcat1 (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[21:37:42] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[21:38:12] *** Quits: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com) (Quit: pcwalton)
[21:38:20] *** Joins: pnathan (Adium@moz-BDC3EE62.tukw.qwest.net)
[21:38:20] *** Quits: brendan (brendaneic@10487EE8.58B1B661.22B0E380.IP) (Quit: brendan)
[21:39:09] *** Quits: Vert (quassel@8A83479C.391ACC8C.CAF63861.IP) (Ping timeout)
[21:39:26] *** Joins: Vert (quassel@8A83479C.391ACC8C.CAF63861.IP)
[21:41:54] *** Quits: Houm (Houm@moz-25669AA8.fbx.proxad.net) (Ping timeout)
[21:42:02] *** Quits: robertknight (robertknig@moz-B6DD6E0B.range86-166.btcentralplus.com) (Ping timeout)
[21:42:03] *** Joins: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com)
[21:42:03] *** ChanServ sets mode: +o pcwalton
[21:42:09] *** Quits: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net) (Input/output error)
[21:42:58] *** Joins: Houm (Houm@moz-25669AA8.fbx.proxad.net)
[21:44:39] *** Quits: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu) (Ping timeout)
[21:44:51] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[21:46:13] *** Joins: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu)
[21:47:24] *** Joins: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net)
[21:48:01] *** Quits: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu) (Ping timeout)
[21:49:00] *** Quits: Vert (quassel@8A83479C.391ACC8C.CAF63861.IP) (Client exited)
[21:49:58] *** Quits: heftig (heftig@moz-E8A91210.dip0.t-ipconnect.de) (Ping timeout)
[21:50:20] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[21:51:21] <jedestep> does IteratorUtil::filter only work with ~[&&T]?
[21:52:14] <jedestep> I'm trying to filter a ~[T] filter.collect() seems to be returning ~[&&T], but trying to transform it with |x| **x makes it think I input a ~[&&&T]
[21:53:28] *** Quits: Ms2ger (Ms2ger@moz-12781595.adsl-dyn.isp.belgacom.be) (Quit: nn)
[21:54:01] *** Quits: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch) (Quit: Leaving.)
[21:54:17] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[21:54:19] <jedestep> basically it appears that filter is returning an iterator over ~[&T] instead of over ~[T]
[21:54:56] <jedestep> and then collecting them transforms it again into ~[&&T]
[21:55:09] *** Quits: saml (sam@moz-14C16814.cst.lightpath.net) (Quit: Leaving)
[21:57:17] <jedestep> trying to do it in two steps, it seems that collect is expecting an iterator over ~[~[&&T]] somehow
[21:57:56] *** Joins: heftig (heftig@moz-B6FEC520.dip0.t-ipconnect.de)
[21:59:05] *** Joins: graydon (Adium@A5087023.2354C43D.D8E68FF6.IP)
[21:59:05] *** ChanServ sets mode: +qo graydon graydon
[21:59:16] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[21:59:23] <kimundi> jedestep: That all sounds strange
[21:59:35] *** Joins: brendan (brendaneic@10487EE8.58B1B661.22B0E380.IP)
[22:00:18] <jedestep> so I have ~[Foo]
[22:00:55] <engla> jedestep: filter will pass a &A if the iterator element is A
[22:01:03] <jedestep> let mut a = foos.iter().filter(|a| match a { FooThing(~"asdf") => true, _ => false } ).collect::<~[Attribute]>()
[22:01:13] <engla> what the iterator element is depends on the source
[22:01:25] *** Quits: brendan (brendaneic@10487EE8.58B1B661.22B0E380.IP) (Quit: brendan)
[22:01:35] *** Quits: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP) (Ping timeout)
[22:02:02] <jedestep> sorry, should be |a| match *a ...
[22:02:49] <jedestep> even with the deref there, it wants me to change FooThing to &FooThing; it's thinking that foos is ~[&&Foo] even though I pass foos in as ~[Foo]
[22:02:51] <kimundi> jedestep: iter() on vec gives you &Foo's, filter on &Foo's will give you &&Foo's in the filter closure
[22:03:28] <kimundi> vec.iter() -> iterator over references to vec's elements
[22:03:53] *** Quits: cowboyd (cowboyd@moz-1BD02A1E.sw.biz.rr.com) (Client exited)
[22:03:54] <strcat1> filter gives you &A only inside the closure though
[22:03:55] <jedestep> even with match *a { &FooThing
[22:03:57] <strcat1> if you have
[22:03:58] <doomlord> i always find myself flailing around abit randomly with *a and |&a| and so on
[22:04:06] <strcat1> Iterator<&int> and you filter it
[22:04:08] <jedestep> I get a type error saying it expected an iterator over &Foo but found one over Foo
[22:04:09] <kimundi> it.filter(|e| ...) -> e is a reference to the thing it iterates over 
[22:04:13] <strcat1> the filtered iterator is still Iterator<&int>
[22:04:27] <strcat1> it passes & &int to the predicate
[22:04:36] <strcat1> because it doesn't require A to be clonable
[22:04:55] <jedestep> I feel like it would be nice to filter a list essentially in-place
[22:05:11] <jedestep> so I wouldn't have to then transform the list by dereferencing everything
[22:05:30] <strcat1> sure but that requires random access
[22:05:39] <cmr> And also a mutable reference
[22:05:39] <strcat1> there aren't random access traits yet
[22:05:41] *** strcat1 is now known as strcat
[22:05:57] <jedestep> still, the current nature of filter is incredibly unintuitive
[22:06:07] <strcat> I don't think so
[22:06:10] <jedestep> I filtered out only some elements, but I got back a list that's not even the same type
[22:06:13] <strcat> it takes Iterator<A>
[22:06:16] <jedestep> *every* element in my list appears to have changed
[22:06:16] <strcat> it passes &A to the predicate
[22:06:19] <strcat> it returns Iterator<A>
[22:06:22] *** Quits: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP) (Ping timeout)
[22:06:27] <strcat> jedestep: it doesn't change the element types
[22:06:30] <strcat> it passes them through unchanged
[22:06:37] <jedestep> it does not return Iterator<A>, it is returning Iterator<&A> to me
[22:06:45] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[22:06:47] <strcat> no, it doesn't return Iterator<A>
[22:07:10] <kimundi> rusti: struct Foo(uint); let foos = [Foo(3), Foo(4), Foo(5)]; let mut a = foos.iter(); a.filter(|&a| match a { &Foo(4) => true, _ => false } ).collect::<~[Foo]>()
[22:07:22] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/BCMf
[22:07:25] <cmr> It takes an iterator, runs a predicate on each item, and yields a reference to the item if the predicate is true.
[22:07:33] <cmr> It seems quite obvious to me.
[22:07:41] <strcat> no it doesn't yield a reference
[22:07:42] <strcat> it passes them through unchanged
[22:07:57] <jedestep> cmr: the nature of it seems obvious
[22:07:58] <strcat>     fn next(&mut self) -> Option<A> {
[22:08:00] <strcat>         for self.iter.advance |x| {
[22:08:01] <jedestep> but it does not appear to be doing that
[22:08:02] <strcat>             if (self.predicate)(&x) {
[22:08:04] <strcat>                 
[22:08:06] <strcat> it does do that
[22:08:08] <cmr> right
[22:08:08] <strcat> I'm looking at it
[22:08:08] *** Quits: echristo (echristo@DCF57675.D6CCE4AE.77834EAA.IP) (Ping timeout)
[22:08:11] <strcat> I wrote it to do that
[22:08:19] <strcat> it passes a reference to the predicate
[22:08:23] *** Joins: brendan (brendaneic@10487EE8.58B1B661.22B0E380.IP)
[22:08:26] <strcat> it yields by-value
[22:08:37] <kimundi> rusti: struct Foo(uint); let foos = [Foo(3u), Foo(4u), Foo(5u)]; let mut a = foos.iter(); a.filter(|&a| match a { &Foo(4u) => true, _ => false } ).collect::<~[Foo]>()
[22:08:39] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/ORMf
[22:08:46] <jedestep> what is incorrect about the statement kimundi wrote
[22:08:52] *** Quits: brendan (brendaneic@10487EE8.58B1B661.22B0E380.IP) (Quit: brendan)
[22:08:55] <strcat> jedestep: iter() on vectors yields &int
[22:08:58] <strcat> well
[22:09:00] <strcat> &T
[22:09:08] * kimundi is wondering the same. Or rather, rearching the bug
[22:09:10] <strcat> so you have Iterator<&Foo>
[22:09:12] <strcat> it's not a bug.
[22:09:15] <strcat> it's entirely intended
[22:09:23] <strcat> filter doesn't change the element type of the iterator
[22:09:31] <jedestep> then why does that statement not work?
[22:09:31] <strcat> you pass in Iterator<&int>, you get out Iterator<&int>
[22:09:34] <kimundi> yes, but what am I doing wrong then? :P
[22:09:41] <strcat> kimundi: you have Iterator<&Foo>
[22:09:44] <strcat> you pass it to filter
[22:09:47] <strcat> you get out Iterator<&Foo>
[22:09:53] <strcat> and then you try to treat it as Iterator<Foo>
[22:09:53] *** Quits: Nisstyre (wes@moz-FD86289.netflash.net) (Quit: Leaving)
[22:09:59] <kimundi> ah, right
[22:10:03] <strcat> use consume_iter and it will work
[22:10:08] <strcat> on ~[]
[22:10:13] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Ping timeout)
[22:10:16] <strcat> or copy the elements
[22:10:20] <kimundi> rusti: struct Foo(uint); let foos = [Foo(3u), Foo(4u), Foo(5u)]; let mut a = foos.iter_consume(); a.filter(|&a| match a { &Foo(4u) => true, _ => false } ).collect::<~[Foo]>()
[22:10:22] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/AfeQ
[22:10:33] <strcat> fixed-length vectors don't have methods
[22:10:42] <kimundi> rusti: struct Foo(uint); let foos = ~[Foo(3u), Foo(4u), Foo(5u)]; let mut a = foos.iter_consume(); a.filter(|&a| match a { Foo(4u) => true, _ => false } ).collect::<~[Foo]>()
[22:10:44] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/TKeg
[22:10:54] <strcat> consume_iter
[22:10:59] <kimundi> rusti: struct Foo(uint); let foos = ~[Foo(3u), Foo(4u), Foo(5u)]; let mut a = foos.consume_iter(); a.filter(|&a| match a { Foo(4u) => true, _ => false } ).collect::<~[Foo]>()
[22:11:01] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/OgDL
[22:11:12] <kimundi> yay
[22:11:20] <strcat> you don't need the temporary though
[22:11:22] <strcat> anyway
[22:11:24] <strcat> iter() gives by-ref
[22:11:26] <strcat> that's just what it does
[22:11:33] <strcat> so you end up with Iterator<&VectorElementType>
[22:11:38] <strcat> filter doesn't change the element type
[22:11:39] <jedestep> kimundi: struct Foo(uint); let foos = [Foo(3u), Foo(4u), Foo(5u)]; let mut a = foos.iter(); a.filter(|&a| match a { &Foo(4u) => true, _ => false } ).transform(|x| x.clone()).collect::<~[Foo]>();
[22:11:45] <kimundi> sure, was missing the transform-deref-clone part
[22:11:59] <strcat> it's implicitly copyable so you don't really need clone
[22:12:02] <strcat> just |&x| x
[22:12:04] *** Joins: dwhyte (dwhyte@ED9190FB.B72E355F.7BF4A4B0.IP)
[22:12:04] <strcat> or |x| *x
[22:12:16] <strcat> or you could use filter_map
[22:12:30] <jedestep> strcat: got cannot move out of dereference errors for that
[22:12:40] <jedestep> tried filter_map, had the same issue
[22:12:51] <strcat> I don't know what type you have
[22:13:01] <strcat> Foo(uint) won't move ownership
[22:13:10] <jedestep> mine has ~str in it which is probably why
[22:13:19] <strcat> yes so then it's not implicitly copyable
[22:13:22] <strcat> it has a destructor
[22:13:35] <kimundi> rusti: struct Foo(uint); let foos = ~[Foo(3u), Foo(4u), Foo(5u)]; let mut a = foos.iter(); a.filter_map(|&a| match a { Foo(4u) => Some(Foo(4u)), _ => None } ).collect::<~[Foo]>()
[22:13:38] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/hBQZ
[22:13:49] <zslayton1> I'm working on a CloneIterator implementation to replace .transform(|x| x.clone())
[22:14:06] <zslayton1> I'll be submitting a rough draft PR in the next day or two for comments
[22:14:09] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[22:14:23] <strcat> I don't really think each container should have an extra iterator implementation
[22:14:29] <strcat> they already have 6
[22:14:34] <kimundi> zslayton1: Just write it and be done withh it :P
[22:14:46] <strcat> .map(clone) is what it should be
[22:14:50] <strcat> and can be
[22:15:05] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[22:15:25] *** Joins: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP)
[22:15:44] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[22:15:49] <strcat> and default methods will be on iterables so...
[22:15:49] <zslayton1> kimundi: It's mostly done, I just haven't had a chance to look at it in a couple of days. ::shakes fist at full time job::
[22:16:07] <strcat> let xs = [1, 2, 3]; xs.map(clone).collect::<~[int]>()
[22:16:20] <zslayton1> strcat: Oh.
[22:16:28] <zslayton1> strcat: That... that is pretty elegant. 
[22:16:31] <zslayton1> nuts.
[22:17:47] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[22:18:20] <zslayton1> I guess it was educational at any rate.
[22:18:42] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[22:19:12] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[22:19:55] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[22:20:14] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[22:21:18] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[22:22:51] <MaikKlein1> we don't use .rc anymore right?
[22:23:04] <bblum> no
[22:23:29] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Ping timeout)
[22:23:45] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[22:23:46] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[22:27:20] *** Joins: dew (Instantbir@moz-2C6F2E2.dhcp.stls.mo.charter.com)
[22:27:33] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[22:27:56] <bblum> strcat: [x,y,z,w].iter().take(2) iterates over x and y right
[22:28:12] <strcat> bblum: yes
[22:30:35] <bblum> strcat: is it generally more efficient to use .enumerate() last in a chain of thingies, or does it not matter?
[22:31:23] <engla> fyi, it's still take_()
[22:31:31] <bblum> oic
[22:31:42] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[22:31:42] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/hwZ2Aw
[22:31:42] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[22:32:44] *** Joins: pnathan1 (Adium@B9840254.2CD8A5F8.477B877D.IP)
[22:33:24] <bblum> strcat: reverse?
[22:33:44] <strcat> bblum: rev_iter
[22:33:51] <strcat> bblum: it doesn't really matter where you use enumerate
[22:33:55] <bblum> and if i'm already using mut_iter?
[22:33:57] <strcat> they all get inlined into one loop
[22:34:01] <strcat> bblum: there's a mut rev one
[22:34:07] <strcat> I forget if it's rev_mut or mut_rev
[22:34:09] <strcat> ;p
[22:34:09] <bblum> oh good
[22:34:19] <bblum> i had grepped for rev_mut_iter >_>
[22:34:24] <engla> mut_rev_iter
[22:34:32] <strcat> there are 6 on vectors - consume_iter, rev_iter and iter and their reverse forms
[22:34:39] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[22:34:40] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/a_sE6g
[22:34:40] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[22:34:51] <strcat> bblum: technically, rev_iter() is just implemented as this:
[22:35:05] <strcat>     fn rev_iter(self) -> VecRevIterator<'self, T> {
[22:35:07] <strcat>         self.iter().invert()
[22:35:09] <strcat>     }
[22:35:14] <bblum> oh .invert() huh
[22:35:23] <strcat> bblum: because vector/dlist/deque iterators are double-ended
[22:35:26] <strcat> there's next_back too
[22:35:28] <bblum> my next question was going to be is that efficient but i guess if you have a separate type for it
[22:35:31] <strcat> invert flips next/next_back
[22:35:40] <strcat> bblum: it's efficient
[22:35:51] *** Joins: strcat1 (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[22:36:18] <bblum> wow, iterators make this select implementation really pretty
[22:36:26] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (NickServ (GHOST command used by strcat1))
[22:36:27] <bblum> mind you, i haven't even tried to compile it yet, but
[22:36:28] *** strcat1 is now known as strcat
[22:36:31] *** Joins: BitPuffin (quassel@moz-7C12CE89.cust.tele2.se)
[22:36:38] <strcat> bblum: basically a vector iterator is 2 pointers, start and end
[22:36:49] <strcat> so next() increments start and checks against end
[22:36:51] *** Joins: rusti_ (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[22:36:54] *** Quits: doener_ (doener@moz-121949B3.unitymediagroup.de) (Quit: leaving)
[22:36:54] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[22:36:57] <strcat> and next_back() moves the end
[22:37:02] <bblum> http://pastebin.mozilla.org/2651657 here's what i've got so far
[22:37:10] <bblum> oh ok i see
[22:37:36] <sully> hm, doesn't anybody know what the deal with ty::SelfMode is
[22:37:41] <sully> it has the following comment above it:
[22:37:52] <sully> // XXX: This should probably go away at some point. Maybe after destructors do?
[22:38:13] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Textual IRC Client: www.textualapp.com)
[22:38:36] <cmr> yeah I saw that too
[22:38:40] <strcat> bblum: http://ix.io/6Jk that's all invert does, it's all pretty simple
[22:38:41] <strcat> implementation-wise
[22:38:46] <cmr> I squinted at it and then moved on
[22:38:51] <strcat> it optimizes out all the intermediate structs
[22:38:57] <bblum> strcat: you do god's ork
[22:39:02] <strcat> ;)
[22:40:12] <engla> yes it's really cool. love the double ended iterator trait, removed some redundancy
[22:40:20] <Luqman> sully: whether it passes self by-copy of by-ref afaik
[22:41:16] <strcat> bblum: and with default methods we can have stuff like more efficient skip on vectors, etc. (although I bet it optimizes out anyway)
[22:41:41] <strcat> can add a way to move n forwards, and just implement a default with `next`
[22:41:49] <strcat> vectors/deques can do that more efficiently
[22:42:41] *** Quits: doomlord (doomlod@42802052.53E08B38.C3DDD137.IP) (Ping timeout)
[22:42:44] <bblum> strcat: but yes, check out the code i pasted if you want some validation for iterators
[22:42:52] <bblum> it comes in super hand
[22:42:54] <bblum> handy
[22:44:16] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[22:45:04] <graydon> so ..  many .. bitrotted branches
[22:45:09] <graydon> what do I do with them all? it is a mystery
[22:45:40] <pcwalton> graydon: r? https://github.com/mozilla/rust/pull/7884
[22:45:53] <graydon> pcwalton: yeah, I was asking about that earlier..
[22:46:01] <graydon> there are a bunch of @mut in there going away
[22:46:06] <strcat> still need to flesh out double-ended iterators
[22:46:07] <brendanc> place a flower on the pr once a year
[22:46:09] <graydon> those suggest to me "shared mutable state" used by different subsystems
[22:46:11] <strcat> missing a lot of implementations on the adaptors
[22:46:13] <strcat> like...
[22:46:20] <graydon> pcwalton: are you sure they're not important?
[22:46:22] <pcwalton> graydon: all the tests pass
[22:46:25] <strcat> if you filter/map something, and it's a double-ended iterator, it should still be one
[22:46:26] <graydon> huh
[22:46:51] <graydon> not trying to foot-drag, just wondering if maybe nmatsakis would know for sure
[22:46:58] <pcwalton> the match stuff scares me a bit but I think our test coverage for pattern matching is pretty good
[22:47:00] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[22:47:00] <strcat> bblum: it'll be nice to have them for I/O, decoding/encoding, etc. ;p
[22:47:01] <graydon> rubber-stamping changes in the typechecker I don't understand ... worries me :(
[22:47:18] <pcwalton> nmatsakis: can you take a quick look at https://github.com/mozilla/rust/pull/7884 ?
[22:47:18] <strcat> bblum: like a streaming parser could be Iterator<(TokenType, &str)>
[22:48:05] *** Quits: carllerche (carllerche@moz-CDE5367B.dsl.static.sonic.net) (Quit: carllerche)
[22:48:08] <graydon> pcwalton: it's just the @mut CheckLoanContext that worries me, really
[22:48:25] <pcwalton> well, nothing seems to mutate it
[22:48:45] <graydon> oh? yeah, I guess there'd have been another change if so :)
[22:49:06] <bblum> strcat: yes, i am pleased about the lazy infinite list use cases
[22:49:18] <graydon> r+ then, hope you're right! :)
[22:50:04] <graydon> cmr: can you elaborate some on 7644, what makes you think there's a windows failure we can't fix?
[22:50:48] <cmr> graydon: aatch said it, not me
[22:50:50] <cmr> I have no idea
[22:50:51] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[22:50:54] <cmr> I can look through the logs if you want?
[22:51:22] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[22:51:24] *** Joins: diegoyam (quassel@FF9B1514.A4EC3D18.3A1EC144.IP)
[22:51:39] <graydon> cmr: I'll wait for aatch to show up, thanks
[22:51:49] <dherman> having trouble building from git sources
[22:51:56] <dherman> can someone help me diagnose the issue?
[22:52:00] <graydon> dherman: certainly
[22:52:02] <cmr> dherman: sure
[22:52:03] <dherman> LLVM build error
[22:52:15] <graydon> fresh pull or stale workspace?
[22:52:25] <dherman> well, it was stale and I did a git pull
[22:52:27] <graydon> make clean-llvm if it has state
[22:52:31] <dherman> ah
[22:52:42] <graydon> llvm we try to be aggressive about caching and subsequently .. well, that happens :(
[22:52:42] <strcat> it's supposed to do it automatically now
[22:52:44] <dherman> i'll try that
[22:52:55] <dherman> the tree I had sitting around was ancient
[22:53:07] <dherman> probably should've just gotten a fresh tree
[22:53:11] <graydon> if not, try a fully-clean (destroy-the-builddir) build first
[22:53:18] <graydon> it's not ideal but the makefiles are .. imperfect :(
[22:53:28] <dherman> no worries
[22:55:48] <MaikKlein1> if I made a PR and I want to update the PR, can I just do a commit?
[22:55:54] <cmr> MaikKlein1: yes
[22:56:22] <MaikKlein1> cmr, ok thanks
[23:01:11] *** Quits: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP) (Client exited)
[23:02:03] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Leaving...)
[23:02:18] *** Quits: pnathan1 (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[23:02:33] *** Joins: mib_roswqx (Mibbit@84E199D6.DCDBCF8E.83D0DF30.IP)
[23:03:33] <graydon> brson: ping
[23:03:48] <bblum> pauls: ping
[23:04:02] <graydon> 7883 is aersome and I want to help you land it; are you preoccupied / in need of any help rebasing?
[23:04:11] <graydon> awesome even. so awesome it broke my keyboard.
[23:04:31] <bblum> wow +83 -5000
[23:04:42] <graydon> what's the change?
[23:04:55] <MaikKlein1> cmr, should I merge the commits? 
[23:04:59] <bblum> graydon: the diffstat on that pull request
[23:05:03] <MaikKlein1> cmr, or doesn't it matter?
[23:05:05] <graydon> oh, yeah
[23:05:08] <bblum> -6000 even
[23:05:11] <cmr> MaikKlein1: doesn't matter (and doesn't make sense?(
[23:05:26] <MaikKlein1> cmr, :D
[23:05:42] <MaikKlein1> <- git noob
[23:06:45] <bblum> umm... if i move two noncopyables into a statically-sized vector on the stack, can i get them back out again in any way short of match?
[23:07:02] <bblum> (and will match even work?)
[23:07:21] <pcwalton> bblum: vec::consume
[23:07:29] <strcat> bblum: it should, but I wouldn't be surprised if vector patterns were always slices
[23:07:31] <pcwalton> consume_iter
[23:07:34] <bblum> pcwalton: all at once instead of one at a time?
[23:07:36] <strcat> pcwalton: that's just for ~[] though
[23:07:37] <pcwalton> strcat: yeah they are, it's a bug
[23:07:43] <strcat> fixed-size vectors have no methods
[23:07:44] <bblum> let mut ports = [a, b]; select(ports); ... a and b ...
[23:07:58] <strcat> they just coerce to slices, making them usable in most cases
[23:08:53] <tikue> hey does anyone know why TreeMapIterator iterates over nodes instead of keys?
[23:09:23] <graydon> so it can issue k/v pairs efficiently
[23:09:28] <graydon> (not sure what the question is)
[23:09:54] * strcat really wants method resolve fixed ;p
[23:10:00] <strcat> .map instead of .transform would be nice
[23:10:33] <tikue> graydon: Well presumably you'd iterate over a tree to do something with the information at each node, i.e. the keys?
[23:10:53] <graydon> it does provide the keys
[23:10:54] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[23:10:55] <strcat> well it gives you the values too because it's no less efficient to give you both
[23:10:57] <graydon> it also provides the values
[23:10:59] <graydon> why not?
[23:11:06] <tikue> heh, I suppose no reason :O)
[23:11:06] <strcat> the maps will also have iterators like (&K, &mut V)
[23:11:17] <strcat> not sure if treemap has one yet
[23:11:24] <strcat> hashmap does
[23:12:24] <ChrisMorgan> olsonjeffery: my newrt HTTP server just uses std::rt::io::net::tcp and then needs to be run with RUST_NEWRT=1 or it will fail. There's nothing else special about it.
[23:12:39] <cmr> ChrisMorgan: where's the source? :3
[23:13:10] <Luqman> strcat: i think i've got that fixed. just need to clean it up
[23:13:23] <jdm> bblum: nice, marking an issue as both easy and hard
[23:13:39] <bblum> jdm: it should maybe be two separate issues
[23:13:42] <bblum> one easy and one hard :P
[23:13:43] *** Joins: themgt (themgt@moz-7834B2B9.cm.vtr.net)
[23:13:49] <jdm> that would make more sense, yes :)
[23:13:52] <kimundi> "easy to fix, once you solved the hard part"
[23:13:55] <ChrisMorgan> cmr: ~/vc/rust-dev/wsgiport/src ;-) (I was originally intending to be basing my work against Python's WSGI before deciding it wouldn't be a Good Nlan)
[23:14:01] <cmr> heh
[23:14:18] <bblum> kimundi: in this case, "easy to do the first part, hard to extend that feature to solve the second problem"
[23:14:29] <bblum> (where the first part would be valuable in its own right)
[23:14:34] <ChrisMorgan> s/Nlan/Plan/
[23:15:42] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[23:16:00] <strcat> Luqman: oh, nice :)
[23:16:21] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[23:18:16] *** Joins: Benvie (brandon@5FD20F9A.53D07D95.EFF8B7BF.IP)
[23:18:25] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[23:19:06] <Luqman> strcat: this right? https://github.com/mozilla/rust/issues/3429
[23:20:08] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[23:23:11] *** Joins: cubic_ (cubic@moz-FE5AD6C7.mc.videotron.ca)
[23:23:58] *** Quits: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca) (Ping timeout)
[23:24:06] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[23:24:41] *** Quits: mye (mye@moz-7955B1FF.dip0.t-ipconnect.de) (Quit: mye)
[23:24:52] <strcat> Luqman: I think so
[23:24:55] *** Quits: Benvie (brandon@5FD20F9A.53D07D95.EFF8B7BF.IP) (Quit: )
[23:24:57] <strcat> I reported a separate bug though
[23:25:02] <strcat> hopefully a duplicate but maybe not ;p
[23:25:23] <strcat> Luqman: https://github.com/mozilla/rust/issues/5898
[23:26:14] *** Joins: jfbk (textual@moz-EEA9CFB3.nyc.res.rr.com)
[23:27:05] <Luqman> 15
[23:27:48] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[23:27:49] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[23:28:16] *** Quits: ozten (ozten@19BD73A1.5D8BCA3A.A0C1B52F.IP) (Quit: ozten)
[23:28:57] *** Joins: aatch (aatch@moz-B437F499.pocketrent.com)
[23:30:06] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[23:31:06] <Luqman> strcat: so now it only complains about all the kinds of ints it could be :P but it works with 5i
[23:31:16] <strcat> Luqman: ah, nice
[23:31:24] <strcat> looking forward to that landing :)
[23:31:31] <strcat> except it would have to be snapshotted
[23:31:38] *** Joins: pnathan1 (Adium@B9840254.2CD8A5F8.477B877D.IP)
[23:32:22] <graydon> anyone know what's blocking a snapshot? I hear rumors..
[23:32:32] <strcat> graydon: I don't really think anything is
[23:32:47] <Luqman> last i remember aatch was trying to do one but the linux bot was broken
[23:32:47] <strcat> there was that regression and aatch didn't want to snapshot it but... we really need one ;p
[23:32:48] <graydon> ok
[23:32:59] <jack> graydon: r? https://github.com/mozilla/rust/pull/7893
[23:33:18] <strcat> I think that last snapshot is too old to work?
[23:33:25] <aatch> strcat, correct
[23:33:35] <aatch> well, not without significant effort anyway.
[23:33:36] <strcat> for example vector_exchange_malloc existed when it was done
[23:33:49] <strcat> but that never made it to stage0 and is gone now
[23:33:54] <MaikKlein1> hm if I have "use lmath::vec::*;" we don't call lmath a crate anymore?
[23:33:55] <graydon> Do we still need perl? I bet we do :(
[23:33:59] <graydon> it's for like 1 command somewhere
[23:34:18] <jack> graydon: I didn't review and confirm the prereqs, just moved the list around :)
[23:34:26] <dherman> graydon: I bugged jack about the readme because I misunderstood it and have been building Rust for the last 2 hours
[23:34:31] <graydon> yeah, I know, just despairing :)
[23:34:35] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[23:34:46] <graydon> r+
[23:34:57] *** Joins: strcat1 (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[23:35:01] <graydon> dherman: what did you wind up doing?
[23:35:08] <strcat1> my router really likes being irritating
[23:35:18] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (NickServ (GHOST command used by strcat1))
[23:35:23] *** Quits: rusti_ (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[23:35:23] <Luqman> hmm so run-pass/conditional-debug-macro-off.rs will fail it you configure with --enable-debug
[23:35:32] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[23:35:34] <dherman> graydon: well, first I unnecessarily built the release, thinking it was required to build the git sources
[23:35:34] *** strcat1 is now known as strcat
[23:35:47] <dherman> then I built from git and it failed b/c it was too stale
[23:35:55] <dherman> then I did make llvm-clean and it still failed
[23:36:05] <graydon> aw nuts
[23:36:05] <dherman> then I blew away the whole repo and did a fresh git clone
[23:36:09] <dherman> and that's what's building now
[23:36:10] <graydon> how's that going? :)
[23:36:13] *** Quits: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP) (Ping timeout)
[23:36:16] <dherman> so far so good
[23:36:20] <dherman> building llvm
[23:36:24] <dherman> like ya do
[23:36:26] <dherman> ;)
[23:36:31] <graydon> sorry. some folks have asked us if we can provide step-by-step reconstruction of the snaps from the source history
[23:36:37] <graydon> and it .. would be possible in theory. in practice, nope.
[23:36:42] <dherman> oh it's fine
[23:36:54] <graydon> I feel a bit bad about it. at least the snap process has worked out mostly-ok.
[23:37:01] <dherman> just curious: what are the mods to llvm that we've done that require us to build from source?
[23:37:10] <graydon> 2 years self hosted, 0 instances of getting irrevocably stuck in a corner
[23:37:17] <graydon> um
[23:37:20] <strcat> dherman: there's one for our weird FFI calls
[23:37:23] <graydon> I think not a ton at this point
[23:37:25] <strcat> an attribute
[23:37:36] <graydon> some FFI stuff maybe? you can review the diff on the submodule
[23:37:47] <graydon> there was some GC stuff before but I think it's no longer relevant
[23:37:49] *** Quits: pnathan1 (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[23:38:19] *** Quits: reyre (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Client exited)
[23:40:16] <strcat> technically I think the chain iterator could be double-ended
[23:40:22] <strcat> if both iterators are double-ended
[23:40:36] <Luqman> also the arm splitstack stuff isn't upstream yet either
[23:40:58] *** Joins: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net)
[23:40:59] <strcat> I think we're really due for an LLVM update too...
[23:41:24] *** Joins: tjc (tjc@moz-15A42B79.lightspeed.sntcca.sbcglobal.net)
[23:41:24] *** ChanServ sets mode: +o tjc
[23:42:50] <strcat> other projects have similar issues with needing LLVM patches
[23:42:54] <strcat> cling, mesa, blender...
[23:43:02] <Ralith> blender?
[23:43:03] <Ralith> o.O
[23:43:05] <MaikKlein1> we specify the crate them via #[link(name = "cratename"... right?
[23:43:13] <MaikKlein1> crate name*
[23:43:18] <strcat> Ralith: yeah something to do with opencl I guess
[23:43:21] <Ralith> oh that reminds me
[23:43:26] <strcat> mesa uses it to optimize shaders
[23:43:30] <Ralith> graydon: is GC in rust still planned to be a thing?
[23:43:36] <graydon> Ralith: yes
[23:43:45] <graydon> need to work on perf for a while first, it can't land presently
[23:43:54] <strcat> well LLVM uses two versions of it
[23:43:55] <strcat> heh.
[23:43:57] <strcat> er, I mean mesa
[23:44:01] *** Quits: MaikKlein1 (maik@moz-4CFF4604.dip0.t-ipconnect.de) (Quit: Leaving)
[23:44:10] *** Joins: MaikKlein (maik@moz-4CFF4604.dip0.t-ipconnect.de)
[23:44:18] <strcat> they use one for radeon (to optimize shaders) and another for their optimized software rendering stack (llvmpipe)
[23:44:22] <strcat> different versions.
[23:44:27] <Luqman> gallium3d also has a software rasterizer that uses llvm
[23:44:32] <strcat> Luqman: yeah, llvmpipe
[23:45:26] <strcat> llvmpipe got a huge boost from the loop vectorizer
[23:45:27] <strcat> 2x faster ;p
[23:45:40] <strcat> kinda pointless though
[23:45:58] *** Joins: reyre (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[23:46:18] <Ralith> graydon: there exists an extremely mature GC toolset known as the 'memory pool system' (http://www.ravenbrook.com/project/mps/) representing, iirc, on the order of 30 man-years of refinement. It's commercial+GPL licensed, but the copyright holders seem open to adding exceptions for open source programming language implementations/runtimes, and have in fact already done so for OpenDylan.
[23:46:30] <graydon> yeah, I know about MPS
[23:46:33] <Ralith> oh well
[23:46:38] <graydon> it's a nice system!
[23:46:41] <Ralith> guess I put too much effort into typing that out
[23:46:44] <Ralith> is it inappropriate for rust?
[23:46:45] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[23:46:45] *** ChanServ sets mode: +o brson
[23:46:46] <graydon> sorry :(
[23:46:51] <Ralith> not your fault ^^
[23:46:52] <graydon> um, it .. _might_ be
[23:47:05] <graydon> the GPL thing is definitely a sticky point, I'd have to dig further into it
[23:47:47] <MaikKlein> oh cool we can now add licenses to github projects
[23:47:59] <graydon> I think I got the impression it was a little overkill for us but I'd be happy to re-investigate
[23:48:05] <graydon> if there's a possibility of a license exception
[23:48:16] <Ralith> I've spoken with the copyright holder on the issue (re: possible use in idris) and he's *extremely* friendly and open to discussing license stuff
[23:48:17] <graydon> I mean, it'd have to be ... a pretty _broad_ license exception
[23:48:32] <graydon> as we would be including it in all downstream rust projects
[23:48:46] <Ralith> yes, that's the class of exception already in place for dylan
[23:48:50] *** Quits: vodik (simon@moz-CBE4BB13.cable.teksavvy.com) (Quit: WeeChat 0.4.2-dev)
[23:48:54] <Ralith> if I understand you correctly
[23:48:59] *** Joins: vodik (simon@moz-CBE4BB13.cable.teksavvy.com)
[23:49:27] <graydon> more or less. we could discuss that, anyways, to make sure it was suitable. it's an interesting possibility, I didn't know they considered exceptions
[23:49:35] <Ralith> the spirit of it seems to be (IANAL) "Programs written in dylan can use this with no restriction as part of the dylan RTS so long as they're not just hacks to let someone get away with using MPS more or less directly"
[23:49:46] <graydon> right, yeah
[23:49:52] <graydon> has to be done carefully but might be possible
[23:49:59] * Ralith nod
[23:50:13] <graydon> the broader issues I think we'd be concerned with relate more to how much we can do in the safe language
[23:50:32] <graydon> but ... lemme look it over again, it's been a while. I did know about it but passed it over as "more than we need, and not correctly licensed"
[23:50:37] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[23:50:39] <Ralith> I'm not sure of the technical details you're concerned about, but it does seem to be *very* configurable.
[23:51:03] <Ralith> a dev described it to me as "not a GC so much as a collection of GCs under one project umbrella"
[23:51:04] <graydon> yeah. that itself can be a maintenance burden, but I read you. GCs are fussy as hell to get right, I'm certainly willing to consider it :)
[23:51:10] <Ralith> ^^
[23:51:13] <Ralith> good luck!
[23:51:21] <Ralith> they've got a channel on freenode they're quite reachable in during UK hours
[23:52:21] *** Joins: brendan (brendaneic@10487EE8.58B1B661.22B0E380.IP)
[23:52:25] <Ralith> as I'm considering it for similar use, I'll be very interested to see how the licensing discussion goes, if it comes to that
[23:52:44] *** Quits: brendan (brendaneic@10487EE8.58B1B661.22B0E380.IP) (Quit: brendan)
[23:53:27] <cmr> We can have a precise GC, can't we?
[23:54:04] <Ralith> MPS supports not only precise GC, but precise GC plus conservative handling of foreign stack/register contents
[23:54:15] <cmr> oh nice
[23:54:36] *** Joins: brendan (brendaneic@10487EE8.58B1B661.22B0E380.IP)
[23:55:18] <graydon> yeah. it's a good system .. shall I just try to find the devs on IRC to chat licensing at some point?
[23:55:41] <Ralith> it'd certainly suit well to make initial contact
[23:55:47] <Ralith> #memorypoolsystem on freenode
[23:55:53] <graydon> I'll also need to read through the API and run it through the rest of the team, we have a lot of GC-clever folks here who'd want to review the idea before we dig too far in
[23:56:00] <jdm> if I have a non-immediate struct S that just contains POD and pass it to a function that takes |foo: S|, does a copy occur?
[23:56:01] *** Quits: vodik (simon@moz-CBE4BB13.cable.teksavvy.com) (Ping timeout)
[23:56:10] <graydon> re-reading docs now. it's been a year or so since I browsed their stuff.
[23:57:04] <jdm> do we implicitly pass by reference, or move the value, or something else?
[23:57:22] *** Joins: vodik (simon@moz-CBE4BB13.cable.teksavvy.com)
[23:57:29] <graydon> define copy
[23:57:38] *** Quits: brendan (brendaneic@10487EE8.58B1B661.22B0E380.IP) (Quit: brendan)
[23:57:46] <graydon> the ABI might copy it, might pass by ref, depending on size / type
[23:58:18] <graydon> semantically, we have an implicit-copy rule that will copy sometimes, move others
[23:58:35] <graydon> but never when it's detectable in any sense other than pointer-value-checking
[23:59:23] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)

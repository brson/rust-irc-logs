[00:00:23] *** Quits: cc (cc@moz-9962C9F4.rev.numericable.fr) (Quit: cc)
[00:02:45] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Client exited)
[00:02:55] *** Quits: mschifer (Adium@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[00:08:28] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Quit: Leaving.)
[00:09:36] *** Quits: thou (thou@moz-1C1CA9F7.fasttrackcomm.net) (Input/output error)
[00:12:03] *** Quits: azita (Azita@2557E599.66715431.D25A875A.IP) (Quit: azita)
[00:13:34] <yichoi> pcwalton: did you check the #6214 ?
[00:13:58] <pcwalton> looking
[00:19:48] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[00:22:02] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[00:22:44] *** Joins: z0w0 (zack@moz-1F110DD8.lnse2.woo.bigpond.net.au)
[00:25:36] <nmatsakis> pcwalton: I think I've decided you were right, and we should remove C-like enums and replace with a deriving mode for a method like to_uint()
[00:25:45] <pcwalton> heh
[00:25:58] <pcwalton> I'm not sure if I'm right
[00:26:01] <pcwalton> they're a very popular feature
[00:26:04] <pcwalton> even if I think they're useless ;0
[00:26:05] <pcwalton> ;)
[00:26:15] <nmatsakis> I don't think they're useless, but I think this deriving mode would be more useful.
[00:26:16] <strcat> well I think we just need a syntax ext to generate a flag type
[00:26:23] <strcat> with | overloaded
[00:26:26] <nmatsakis> and anyhow writing "v as uint" is much less nice than "v.to_uint()"
[00:26:28] <aatch> strcat, that would be awesome.
[00:26:34] <nmatsakis> strcat: we don't need a syntax extension
[00:26:45] <nmatsakis> strcat: the reason I had this thought was that I was ust writing a genreic EnumSet<E>
[00:26:53] <nmatsakis> for any enum type E that implements a ToUint trait...
[00:26:59] <nmatsakis> and I thought, boy this is dumb.
[00:27:11] <strcat> nmatsakis: you should be able to pick the underlying type though
[00:27:17] <strcat> and OR them together in most cases
[00:27:27] <aatch> Even if you limit it to primitive types.
[00:27:31] <strcat> that's what a C enum is usually used for, bitsets
[00:27:34] <nmatsakis> strcat: huh? I don't really get how that's relevant.
[00:27:40] *** Quits: brendan (brendaneic@2557E599.66715431.D25A875A.IP) (Quit: brendan)
[00:28:01] <nmatsakis> I mean, we have various EnumSetU32 or whatever
[00:28:03] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[00:28:07] <nmatsakis> there's really only a few options
[00:28:50] * strcat will just do it by hand for libmagic
[00:28:51] <nmatsakis> strcat: this EnumSet<E> was just "struct EnumSet<E> { bits: u32 }"
[00:28:56] <strcat> ah
[00:29:09] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[00:29:09] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/zfmxcQ
[00:29:09] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[00:29:28] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[00:29:28] *** ChanServ sets mode: +o dherman
[00:29:29] *** Quits: bent (chatzilla@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: ChatZilla 0.9.90-rdmsoft [XULRunner 18.0.2/20130201065344])
[00:29:41] <nmatsakis> strcat: so technically it only works for any enum of less than 32 membres :)
[00:29:58] <noct> pcwalton: Have you mentioned why you think they're useless somewhere?
[00:30:09] <pcwalton> noct: because the conversion only goes one way
[00:30:14] <pcwalton> you can go enum -> int but not int -> enum
[00:30:18] <pcwalton> furthermore enums are not good for C interop
[00:30:31] <pcwalton> because their bit representation is unspecified in both Rust and C
[00:31:11] <aatch> nmatsakis, I think i get it, so you have an implementation for EnumSet<E> that takes some enum, E, and then you have set() and check() methods and similar?
[00:31:22] <nmatsakis> pcwalton: I don't think they're useless, quite the opposite, but I do think that "foo.to_uint()" is at least as nice to write if not nicer than "foo as uint"... (plus it would be great to get the reverse direction too)
[00:31:32] <noct> yeah, the latter is quite an an annoyance in C alone
[00:31:37] <nmatsakis> (though I often don't need it)
[00:31:41] <nmatsakis> (but when you do...)
[00:31:47] <nmatsakis> aatch: yeah, right. 
[00:31:59] <strcat> http://ix.io/5wA for example I have this right now... which should really be a struct with pre-defined constants
[00:32:07] <nmatsakis> aatch: so e.g., "fn contains(&self, elem: E) -> bool { self.bits & (1 << E.to_uint) != 0 }"
[00:32:12] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[00:32:13] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/vlswXw
[00:32:13] <ghrust> 13rust/06auto 1411f7cb2 15Niko Matsakis: When autoborrowing a fn in trans, adjust the type of the datum to be `&fn`....
[00:32:13] <ghrust> 13rust/06auto 14d35eb6e 15bors: auto merge of #6302 : nikomatsakis/rust/issue-6141-leaking-owned-fn, r=brson...
[00:32:13] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[00:32:21] <strcat> so instead of [MAGIC_SYMLINK, MAGIC_MIME_TYPE] you can pass MAGIC_SYMLINK | MAGIC_MIME_TYPE
[00:32:33] <nmatsakis> (and you can overload | too)
[00:32:48] <aatch> Which means it stays type-safe too :D
[00:33:20] <nmatsakis> anyway, gotta go, bbl, just wanted to tell pcwalton he was right about that... :)
[00:42:42] *** Joins: wilkie (wilkie@moz-57D49853.pitbpa.fios.verizon.net)
[00:44:13] *** Quits: wilmoore (wilmoore@moz-BDA77E4A.public.wayport.net) (Ping timeout)
[00:45:20] *** Joins: Thad (chatzilla@moz-C35F90AE.tx.res.rr.com)
[00:46:24] <bstrie> wilkie: I reduced that bug a bit: https://gist.github.com/bstrie/5537371
[00:47:32] <bstrie> wilkie: afaict it only happens if you attempt to reference the tag within a pattern-matched enum whose tag is a struct casted to a unique trait object
[00:47:46] <Thad> brson:  Did a git pull... make clean... build is crashing on compile and link for core.dll  (rustc.exe causes fatal exception in Windows 7) http://pastebin.mozilla.org/2383288
[00:47:46] <bstrie> which is... very specific :)
[00:48:02] <Thad> brson: but it now passes the Libuv ! :)
[00:48:23] <aatch> bstrie, https://github.com/mozilla/rust/pull/6259 r?
[00:49:24] *** Joins: lmandel (lmandel@FE1F74.86ED00A7.971E19F6.IP)
[00:49:27] <bstrie> aatch: looks good, thanks
[00:49:50] <aatch> bstrie, thanks.
[00:54:02] <wilkie> bstrie: nice
[00:54:34] <bstrie> wilkie: https://github.com/mozilla/rust/issues/6318
[00:54:35] *** Quits: bnicholson (bnicholson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[00:55:07] *** Joins: mrplant (Mibbit@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[00:55:31] <wilkie> bstrie: awesome. thanks for looking into it.
[00:57:47] <brson> Thad: that's unfortunate. I've seen stage0 rustc crash building core before but don't know what the solution is. Often it happens when doing an unoptimized build but it looks like you are doing optimizations
[00:58:01] <brson> Thad: is this a regression? did it used to build?
[00:59:41] *** Quits: SiegeLord (siege@moz-56D7E78.bstnma.fios.verizon.net) (Connection reset by peer)
[00:59:56] *** Quits: jclements (jclements@2557E599.66715431.D25A875A.IP) (Quit: jclements)
[01:00:07] *** Quits: stephank (stephank@FE6D378F.A6EC7F74.1E99A072.IP) (Ping timeout)
[01:00:10] *** Joins: steven_is_false (quassel@moz-144077DE.bchsia.telus.net)
[01:01:18] *** Joins: Jesin (Jessin_@moz-A03A364F.cc.lehigh.edu)
[01:01:28] <pcwalton> brson: r? https://github.com/mozilla/rust/pull/6232 last two commits
[01:01:32] <pcwalton> it's removing modes entirely from the language
[01:01:51] *** Joins: SiegeLord (sl@moz-56D7E78.bstnma.fios.verizon.net)
[01:02:07] <steven_is_false> Hi! Just for fun I was figuring out how to build Rust using autotools (Basically the only special thing I need to do is define a linker LINK = ld, and define a suffix rule for getting object files $(RUSTC) $(AM_RUSTCFLAGS) $(RUSTCFLAGS) -c -o $@ $< . Anyways now  that I've got an object file I don't know how to link it.
[01:02:16] *** Quits: echristo (echristo@60A74940.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[01:02:28] <aatch> steven_is_false, -Z print-link-args
[01:02:43] <aatch> will give you the link args that it would have used.
[01:03:13] <aatch> (how you integrate that information is up to you though)
[01:03:23] <steven_is_false> aatch: Is there some way to get that information automatically?
[01:03:30] *** Joins: stephank (stephank@FE6D378F.A6EC7F74.1E99A072.IP)
[01:03:31] <aatch> steven_is_false, what do you mean?
[01:04:10] <steven_is_false> aatch: It's not a good idea to just copy and paste it in.
[01:04:22] <steven_is_false> aatch: I think I've got a good idea though.
[01:04:26] <aatch> no, but it prints it to stdout.
[01:04:36] <steven_is_false> aatch: You need to give a crate file
[01:04:40] <aatch> and you can build the object at the same time.
[01:05:18] <aatch> so rustc -Z print-link-args -c <file> will still give you a .o file
[01:05:26] <Thad> brson: never built with w64-mingw32 ... trying again with configure setup for pc-mingw32    (I'm using my customized platform.mk file btw)
[01:06:50] *** Quits: lerc_ (quassel@121-74-236-56.telstraclear.net) (Client exited)
[01:06:51] *** Quits: klapaucius (klapaucius@272B8F8B.5692770D.BB41F968.IP) (Connection reset by peer)
[01:07:01] <Thad> brson: yes, it used to build with i686-pc-mingw32 but doesn't seem to like LLVM 4.7.2 ... at all
[01:07:12] *** Joins: sonwow (sonwow@5AB4884B.FCC4549.14D5B978.IP)
[01:07:45] *** Joins: klapaucius (klapaucius@272B8F8B.5692770D.BB41F968.IP)
[01:08:39] <steven_is_false> aatch: This doesn't work with an out of tree build.
[01:09:18] <steven_is_false> aatch: Because -Z print-link-args thinks that the object file should be in the original source directory
[01:09:18] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[01:13:37] <pcwalton> nmatsakis: did you decide to disallow partial borrows of @mut after all?
[01:14:02] <nmatsakis> pcwalton: no?
[01:14:06] <pcwalton> oh
[01:14:10] <nmatsakis> pcwalton: did you get an error mentioning that?
[01:14:11] <pcwalton> I saw a comment to that effect
[01:14:16] *** Joins: int3_ (int3_@moz-98676091.subnet-248.amherst.edu)
[01:14:19] <pcwalton> in the big doc comment
[01:14:21] <nmatsakis> oh, must be outdated.
[01:14:23] <pcwalton> at the top of the file
[01:14:23] <nmatsakis> oh, the big doc comment IS outdated
[01:14:24] <pcwalton> ok
[01:14:32] <nmatsakis> I'm planning to rewrite it this week
[01:14:35] <nmatsakis> to reflect reality
[01:14:36] <pcwalton> I was about to say that there are a lot of explicit borrows of @mut
[01:14:38] <pcwalton> in servo
[01:14:41] <pcwalton> and they're kind of annoying
[01:14:50] *** Joins: lerc (quassel@moz-B7C43FE2.telstraclear.net)
[01:14:56] <nmatsakis> no, I dropped it in favor of "best effort" detection
[01:15:02] <pcwalton> right
[01:15:03] <pcwalton> ok
[01:15:08] <nmatsakis> it was annoying in rustc too
[01:18:31] <sonwow> str/vec::from_slice and str/vec::to_owned do exactly same thing, so there is an issue about their name. (#3356)
[01:18:58] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[01:19:25] <sonwow> So I want to change `from_slice` to another name. However, I don't know what is the proper name...
[01:19:57] <aatch> sonwow, uh, in my copy, to_owned is a method and from_slice is a free function
[01:20:07] <aatch> in vec at least
[01:20:08] <steven_is_false> aatch: So I figured out a workaround but now I have a problem. I'm getting the object file linked in twice.
[01:20:41] <bstrie> aatch: if they do the same thing, they should just be the same name
[01:20:47] <bstrie> so... pick one :)
[01:21:07] <aatch> bstrie, well in that case, it's obviously to_owned
[01:21:26] <aatch> since my_vec.from_slice() doesn't really make sense
[01:21:39] <aatch> from_slice is a "constructor" name
[01:21:53] <aatch> so you wouldn't expect to call it on an object.
[01:22:21] <aatch> steven_is_false, what's the work around?
[01:22:26] <engla> why are the implementations different for the same function?
[01:22:36] <aatch> engla, bitrot
[01:22:48] <steven_is_false> aatch: Oh, I just wrote it to a file like you said. It's just a bit messy though.
[01:22:51] <pcwalton> so many modes in the test suite
[01:23:56] <aatch> steven_is_false, yeah, it would be nice to have something like a "link mode", but I'm not sure how it would work.
[01:24:26] <aatch> In fact, the best place to start would be to have rustc able to do incremental recompilation.
[01:24:28] *** Joins: Ralith (ralith@moz-50F3C77.vc.shawcable.net)
[01:24:47] <aatch> Unfortunately that seems to be really hard
[01:25:53] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[01:27:21] <steven_is_false> aatch: I've never looked at the problem
[01:28:24] <aatch> steven_is_false, since crates are the unit of compilation, you need to figure out what might have been changed between runs.
[01:28:41] <steven_is_false> Okay.
[01:28:45] <aatch> so we need a graph of the crate module dependencies
[01:29:16] <aatch> after that it's a matter of figuring out what the best way to cache the data is and all that.
[01:29:47] *** Joins: sammykim (sammy.kim@5AB4884B.FCC4549.14D5B978.IP)
[01:32:58] *** Joins: \n (_n@moz-C2B49FFE.hsd1.ca.comcast.net)
[01:33:31] <\n> brson: is there a compile flag to not generate the .dSYM dir with rustc?
[01:34:02] <\n> pcwalton, nmatsakis: ^
[01:34:17] <bstrie> \n: I thought debug info was disabled by default...
[01:34:43] <\n> I'm using 0.6, without current changes
[01:34:55] <aatch> \n, I'm guessing that .dSYM is the output of dsymutil?
[01:35:04] <aatch> (I'm not a mac user)
[01:35:46] <\n> idk running just `rustc myfile.rs` gives a warning: warning: no debug symbols in executable (-arch x86_64)
[01:36:05] <\n> and generates the dir
[01:36:38] <nmatsakis> \n: not that I know of
[01:36:44] <aatch> \n, you are on OSX, right?
[01:36:47] <\n> yep
[01:37:03] <\n> but 0.6, without any patches
[01:37:09] <aatch> can you delete the folder, then run `dysymutil <crate>`
[01:37:20] <aatch> where `<crate>` is the .so file
[01:37:37] <aatch> dsymutil*
[01:38:11] <aatch> If my guess it right, it should re-generate the directory.
[01:39:02] <\n> yes
[01:39:14] *** Quits: thomaslee_ (thomaslee@moz-6C3931E3.static.twtelecom.net) (Client exited)
[01:39:15] <\n> but why is dsymutil being run
[01:39:17] <\n> ?
[01:39:51] <aatch> \n, no idea, a mac thing I assume. There's a comment saying "Clean up on Mac OSX" right above it.
[01:40:23] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.0)
[01:40:37] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[01:41:23] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Quit: Leaving.)
[01:41:48] <\n> aatch: ok thanks
[01:43:16] *** Joins: tcsc (tcsc@moz-A838B260.dhcp.nwtn.ct.charter.com)
[01:44:11] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[01:44:12] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/vlswXw
[01:44:12] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[01:45:39] *** Quits: \n (_n@moz-C2B49FFE.hsd1.ca.comcast.net) (Client exited)
[01:47:14] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[01:47:14] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/10_cWQ
[01:47:14] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[01:47:19] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[01:47:19] <ghrust> 01[13rust01] 15bors pushed 20 new commits to 06auto: 02http://git.io/8w97dg
[01:47:19] <ghrust> 13rust/06auto 148a45cbb 15Patrick Walton: libstd: Remove mutable fields from fileinput and net_tcp
[01:47:19] <ghrust> 13rust/06auto 14e989708 15Patrick Walton: libstd: Remove mutable fields from flatpipes and io_util
[01:47:20] <ghrust> 13rust/06auto 1482971f8 15Patrick Walton: libstd: Remove mutable fields from future and par
[01:47:22] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[01:48:35] <sonwow> aatch, even if from_slice and to_owned were not same thing, they do similar works. so issue #3356 suggests that make their name similarly. what do you think about this?
[01:48:36] <cmr> aatch: with incremental compilation could also come parallel compilation, yes?
[01:48:42] <SiegeLord> What exactly are rust conditions?
[01:49:13] <aatch> sonwow, change from_slice to to_owned, but I'm not too bothered.
[01:49:30] <cmr> it sucks to have 7/8 cores idle during most of the rust build
[01:49:36] *** Quits: Thad (chatzilla@moz-C35F90AE.tx.res.rr.com) (Quit: ChatZilla 0.9.90 [Firefox 21.0/20130430204233])
[01:49:42] <aatch> Ideally you wouldn't have the free function at all, but that feature is coming later.
[01:49:50] <bstrie> cmr: run seven copies of dwarf fortress while compiling
[01:49:54] <aatch> cmr, possibly, that's harder though.
[01:51:05] <bstrie> sonwow: yes, "from_slice" does not really make sense if it is a method
[01:51:16] <steven_is_false> aatch: So there is one bug. -Z print-link-args does not work with -Z static (-o is foo.o when it should be foo)
[01:51:16] <SiegeLord> This incremental compilation idea still assumes crate as a single core compillation unit
[01:51:36] <aatch> SiegeLord, it does.
[01:51:49] <SiegeLord> So, you'd still have to break apart your program into a whole bunch of crates to have it be of any use
[01:51:52] <cmr> the only problem with that is that crates can be huge
[01:52:03] <aatch> it wouldn't cache object files.
[01:52:22] <aatch> it would split the crate into subtrees and cache them, probably as llvm bitcode
[01:52:23] <SiegeLord> And if that's the case, then just writing a makefile should be, in principle, fine
[01:52:37] <SiegeLord> At least as far as parallel compillation goes
[01:52:49] <SiegeLord> I don't know why rustc and runtime are not setup that way
[01:53:04] <aatch> SiegeLord, it's to allow for better optimization.
[01:53:18] <bstrie> wilkie: ah, a pittsburgher... we'll have to get together sometime for RUSTCON PITTSBURGH '012 PART TWO: "THIS TIME, IT'S STILL NOT IN 2012"
[01:54:27] <cmr> I'm fine with large crates, I think they make a lot of sense conceptually, they're just slow to compile.
[01:54:36] <SiegeLord> aatch, I don't see what that has to do with anything. rustc et al. compillation process produces a number of shared libraries. Surely at least a couple could be compiled in parallel
[01:54:50] <SiegeLord> Like librusti and librustpkg
[01:54:57] <wilkie> bstrie: :) come to openhack
[01:55:17] <aatch> SiegeLord, I think we're talking about different things
[01:55:41] <sonwow> thanks! aatch, bstrie.
[01:55:49] <bstrie> wilkie: I don't know what that is!
[01:56:18] <SiegeLord> aatch, I'm talking about what can be done right now, it's a more coarse grained/manual idea than what you're proposing
[01:56:33] <SiegeLord> At least, as far as I understand it
[01:56:39] <aatch> SiegeLord, well yes.
[01:57:01] <wilkie> bstrie: http://openhack.github.io/pittsburgh/
[01:57:03] <SiegeLord> To double check, if you touch a file in a crate, it will force the entire crate to be recompiled as if you touched all files in a crate?
[01:57:10] <SiegeLord> (in your proposal)
[01:58:05] <aatch> SiegeLord, I don't really have a proposal, but it wouldn't have to recompile the entire crate ideally
[01:58:21] <aatch> Currently it does though
[01:58:51] <cmr> llvm would still have to retranslate the entire crate, though
[01:59:27] <aatch> cmr, not if we store llvm bitcode, it would still have to translate from bc to native code, but that isn't the slow step
[01:59:33] <cmr> right
[01:59:53] <SiegeLord> Oh, then I misunderstood... incremental single crate compilation would indeed be a big step forward
[01:59:55] <aatch> its the entire "middle" part of rustc
[02:00:00] <bstrie> wilkie: oh good, so I have three weeks to stop being so horribly socially inept :)
[02:00:46] <aatch> which is resolving, type checking, borrow checking, flow checking, and all those other checks
[02:01:10] <aatch> translation into llvm isn't even particularly slow.
[02:01:30] <SiegeLord> I seem to remember a set of numbers that broke each step down in terms of time it took
[02:01:39] <wilkie> bstrie: pretty much :) we can get some people into some rust stuff
[02:02:11] <bstrie> wilkie: I think the event would be over before they finished compiling ;_;
[02:02:13] <aatch> SiegeLord, -Z time-passes
[02:02:22] <SiegeLord> Ah
[02:02:56] *** Quits: kimundi (kimundi@moz-DAD78822.dip0.t-ipconnect.de) (Ping timeout)
[02:03:22] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[02:03:37] <wilkie> bstrie: haha. yeah ;_; (not if I give them remote access to a dev machine :)
[02:03:53] <bstrie> we'll just have them use rusti!
[02:04:00] <bstrie> rusti: exist
[02:04:11] <bstrie> I guess we will not have them use rusti.
[02:04:51] <wilkie> rusti> 2+2 <\n> 4 leaked memory in rust main loop <crash> ;_;
[02:05:14] <bstrie> yeah, we have a better rusti here in the channel... sometimes :)
[02:05:38] <aatch> bstrie, it runs on strcat's laptop, so it's when he's on
[02:05:47] *** Quits: EXetoC (ex@moz-2DBEB1E4.customer.t3.se) (Quit: WeeChat 0.4.0)
[02:06:03] <bstrie> haha, really?
[02:06:17] <bstrie> I could just let him use my junk vps
[02:06:43] <aatch> bstrie, yeah. He wants to run it on his little arm server, but rustc doesn't do arm linux yet
[02:06:44] *** Joins: zz_kimundi (kimundi@moz-58BC8525.dip0.t-ipconnect.de)
[02:06:53] <aatch> bstrie, does it run arch linux?
[02:07:06] <bstrie> oh right, my vps doesn't have enough ram to compile rust... I need to set up swap or something
[02:07:10] *** zz_kimundi is now known as kimundi
[02:07:12] <bstrie> aatch: no, debian
[02:07:29] <cmr> it takes me hours to compile rust on my netbook, mostly because of all the swapping.
[02:07:37] <cmr> ~6hr
[02:08:02] <bstrie> right, but I don't think that my server ever swaps at all... maybe it does. I'm bad at computers
[02:08:40] <wilkie> 6 hours!?!
[02:08:43] <wilkie> oh netbook
[02:11:54] *** Joins: bnicholson (bnicholson@moz-E98974C1.hsd1.ca.comcast.net)
[02:11:54] <sp3d> ~how much ram does it take to compile rust?
[02:12:02] <aatch> sp3d, 1-1.5G
[02:12:04] <cmr> more than a gig :p
[02:12:18] <bstrie> sp3d: 1.5, but if you're building llvm in parallel it can take tons more
[02:12:24] <cmr> it's mostly linking that hurts the most
[02:12:25] <bstrie> I got up to 5 gigs with -j8
[02:12:35] <sp3d> you guys really are going head-to-head with webkit :P
[02:12:40] *** Joins: mib_r35sn1 (Mibbit@moz-AB722A1C.mc.videotron.ca)
[02:13:52] <mib_r35sn1> if it can help anyone: https://github.com/HOLYCOWBATMAN/rust-asm-demo
[02:14:38] <cmr> mib_r35sn1: handy, thanks!
[02:14:50] <bstrie> mib_r35sn1: I feel like that ought to be in the tutorial somewhere
[02:15:30] <mib_r35sn1> feel free to use it anywhere you like
[02:15:36] *** Joins: eholk (eholk@moz-4E33D4F.wavecable.com)
[02:16:39] *** Quits: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net) (Quit: Computer has gone to sleep.)
[02:19:19] <Luqman> bstrie: mib_r35sn1 err that only works because link_args is really more like gcc args :P
[02:20:12] <bstrie> Luqman: still, there should be a mention *somewhere* in the tutorial about asm from rust, it only takes like two lines for a hello world
[02:20:45] <cmr> also inline asm
[02:20:56] <bstrie> I still feel like the current main tutorial needs to be split into "basic language features" and "advanced language features" pages
[02:21:53] <brson> i disagree about discussing assembly language in the tutorial
[02:22:08] <brson> but I agree it needs to be broken out into more 'chapters'
[02:23:10] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[02:23:11] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14d4cb79b to 14d35eb6e: 02http://git.io/N3iJvQ
[02:23:11] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[02:23:12] <bstrie> brson: I agree that there are features that need to be mentioned somewhere, but are too esoteric for the current tutorial and too minor for dedicated tutorials
[02:23:13] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[02:23:13] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/vwWCkg
[02:23:13] <ghrust> 13rust/06auto 140addefa 15James Miller: Improved vim indent file for rust
[02:23:13] <ghrust> 13rust/06auto 1480b2926 15James Miller: General fixes for vim...
[02:23:13] <ghrust> 13rust/06auto 143c4b32c 15bors: auto merge of #6259 : Aatch/rust/vimfile, r=bstrie...
[02:23:16] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[02:23:21] <aatch> :d
[02:23:25] <aatch> :D
[02:23:45] <aatch> bstrie, ideally we'll have a language reference eventually
[02:23:49] <bstrie> stuff like asm and labeled break, etc
[02:23:50] <cmr> it's silly that bors runs tests fo PRs that don't even touch code
[02:24:20] <aatch> but at the moment, such a reference would need updating weekly
[02:24:21] <bstrie> cmr: yes, it's conceivable that the etc dir could be its own repo
[02:24:53] <bstrie> cmr: but I still want a tutorial that mentions those things... language references are for implementers and language nerds. I
[02:25:01] <bstrie> 'm not going to read the java reference, for example
[02:25:02] <bstrie> I've tried
[02:25:28] <bstrie> and failed
[02:28:13] <bstrie> e.g. the language reference regarding labeled break would have to go into the grammar of labels and all that junk. I just want a 10-word section saying "hey we don't have goto but here's a neat thing you can do to simulate it in loops [short code example]"
[02:28:26] *** Quits: eholk (eholk@moz-4E33D4F.wavecable.com) (Quit: eholk)
[02:29:03] <aatch> bstrie, ok, well maybe language reference is a bad name. I guess the manual would cover all of that.
[02:29:18] <aatch> More formally than a tutorial, but less formal than a reference.
[02:31:12] <bstrie> sounds good
[02:31:27] <ILyoan> bjz: ping?
[02:34:39] *** Quits: thelivingded (thelivingd@moz-9453CC48.austin.res.rr.com) (Ping timeout)
[02:35:21] *** Parts: judder (maradukewa@DABDEEA3.F2C0D0AC.78E362FE.IP) ()
[02:37:16] *** Quits: Jesin (Jessin_@moz-A03A364F.cc.lehigh.edu) (Quit: Leaving)
[02:40:26] *** Quits: catpig (catpig@moz-9AC8F33A.dip0.t-ipconnect.de) (Quit: Verlassend)
[02:44:22] *** Quits: graydon (graydon@3853DDD.39EEDBB3.D758B1AA.IP) (Quit: Leaving.)
[02:44:56] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[02:48:43] *** Joins: dbaupp (Thunderbir@8D0E22F1.D5A1DCF.37681C44.IP)
[02:53:30] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Quit: leaving)
[02:53:34] <steven_is_false> Hoorah! I got the ATS compiler working.
[02:54:07] <cmr> What is ATS?
[02:54:42] <steven_is_false> cmr: Basically, like Rust only more ML like, and compiles to C code instead of LLVM.
[02:54:59] <cmr> oh it's a language
[02:55:01] <steven_is_false> cmr: I don't think it has the multitasking support Rust has.
[02:56:50] *** Quits: dbaupp (Thunderbir@8D0E22F1.D5A1DCF.37681C44.IP) (Ping timeout)
[03:00:13] *** Quits: an0nymous (an0nymous@moz-A6B0CE4.tx.res.rr.com) (Quit: Leaving)
[03:00:14] <cmr> In middle::resolve there are two types of namespace: TypeNS and ValueNS. What are they and how do they differ?
[03:00:31] *** Quits: sonwow (sonwow@5AB4884B.FCC4549.14D5B978.IP) (Quit: Lost terminal)
[03:01:22] <aatch> cmr, at the risk of sounding redundant, one is the namespace for types, the other is for values. Since values occupy a different namespace to type, there are two seperate namespaces
[03:01:26] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[03:01:44] <aatch> this is why you can do let str : ~str = ~"string"
[03:01:50] *** Quits: kimundi (kimundi@moz-58BC8525.dip0.t-ipconnect.de) (Ping timeout)
[03:01:58] <cmr> ohh, I see now
[03:03:11] *** Joins: Jesin (Jessin_@4FE0CEF2.B4552BE7.C85D72.IP)
[03:03:18] *** Quits: steven_is_false (quassel@moz-144077DE.bchsia.telus.net) (Quit: http://quassel-irc.org - Chat comfortably. Anywhere.)
[03:03:55] *** Quits: Diablo-D3 (diablo@moz-F06B3F31.port.east.myfairpoint.net) (Quit: This computer has gone to sleep)
[03:05:23] *** Joins: zz_kimundi (kimundi@moz-587F344C.dip0.t-ipconnect.de)
[03:05:40] *** Quits: Jesin (Jessin_@4FE0CEF2.B4552BE7.C85D72.IP) (Ping timeout)
[03:05:45] *** zz_kimundi is now known as kimundi
[03:07:10] *** Joins: Jesin (Jessin_@4FE0CEF2.B4552BE7.C85D72.IP)
[03:10:16] *** Quits: mib_r35sn1 (Mibbit@moz-AB722A1C.mc.videotron.ca) (Quit: http://www.mibbit.com ajax IRC Client)
[03:10:36] *** Joins: steven_is_false (quassel@moz-144077DE.bchsia.telus.net)
[03:16:31] *** Quits: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Leaving...)
[03:16:43] *** Joins: thou (thou@moz-1C1CA9F7.fasttrackcomm.net)
[03:18:27] *** Joins: dymk (dymk@moz-791093B6.sub-70-211-65.myvzw.com)
[03:18:44] *** Quits: balpert (balpert@moz-3F2493CA.compute-1.amazonaws.com) (Client exited)
[03:20:39] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[03:21:19] <fread2281> does anyone have a link to the paper that says good refcounting and GC are the same thing
[03:21:27] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[03:21:31] <cmr> "A Unified Theory of Garbage Collecting"
[03:21:34] *** Quits: int3_ (int3_@moz-98676091.subnet-248.amherst.edu) (Client exited)
[03:21:50] <fread2281> cmr: thanks
[03:21:59] <cmr> or something very close to that
[03:22:14] <fread2281> cmr: yep, that's what it is
[03:22:34] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[03:23:28] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[03:25:47] <sp3d> fread2281: http://ubuntuone.com/3VFdu647Vgl6fj8WRiXCTk
[03:27:49] *** Quits: Jesin (Jessin_@4FE0CEF2.B4552BE7.C85D72.IP) (Ping timeout)
[03:28:18] <dymk> Is there a way in Rust to make some arbitrary sized type, a la "type MyType = int[3]" is 3 ints big?
[03:28:41] <aatch> dymk, [T,..n] will make a fixed-size vec
[03:29:08] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[03:29:09] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/vwWCkg
[03:29:09] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[03:29:42] <dymk> aatch, oh I didn't think of that, thanks
[03:30:01] *** Joins: barosl (barosl@1E71221E.C81E10FB.7544CABF.IP)
[03:30:07] *** Joins: int3_ (int3_@moz-98676091.subnet-248.amherst.edu)
[03:32:10] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[03:32:10] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/-kYShw
[03:32:10] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[03:32:12] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[03:32:12] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/z_19pA
[03:32:12] <ghrust> 13rust/06auto 146af447a 15Niko Matsakis: Add test for #4666, which didn't *quite* seem to be covered by...
[03:32:12] <ghrust> 13rust/06auto 145a1afaf 15bors: auto merge of #6303 : nikomatsakis/rust/issue-4666-test, r=nikomatsakis...
[03:32:13] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[03:36:02] *** Joins: Diablo-D3 (diablo@moz-F06B3F31.port.east.myfairpoint.net)
[03:36:14] *** Joins: jdm (jdm@DB05BBF2.BB1F48F2.971E19F6.IP)
[03:36:17] *** Quits: Diablo-D3 (diablo@moz-F06B3F31.port.east.myfairpoint.net) (Quit: do coders dream of sheep()?)
[03:38:25] *** Joins: Diablo-D3 (diablo@moz-F06B3F31.port.east.myfairpoint.net)
[03:41:46] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[03:42:37] *** Joins: akashj87 (akash@299034BF.F09595B1.35E3DDC8.IP)
[03:43:00] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[03:43:04] *** Joins: Jesin (Jessin_@4FE0CEF2.B4552BE7.C85D72.IP)
[03:43:16] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[03:50:03] *** Quits: tcsc (tcsc@moz-A838B260.dhcp.nwtn.ct.charter.com) (Quit: computer sleeping)
[03:53:14] *** Quits: blitter (blitter@moz-7C98731E.dyn.centurytel.net) (Quit: Leaving)
[03:55:49] *** Joins: brson (brson@E02A6CDD.75598729.B6A3AE99.IP)
[03:55:49] *** ChanServ sets mode: +o brson
[03:56:53] *** Quits: brson (brson@E02A6CDD.75598729.B6A3AE99.IP) (Quit: leaving)
[03:58:03] *** Joins: brson (brson@E9CDE21E.991753BB.CA4D1600.IP)
[03:58:03] *** ChanServ sets mode: +o brson
[03:58:55] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[04:00:00] *** Joins: an0nymous (an0nymous@moz-A6B0CE4.tx.res.rr.com)
[04:02:41] <dymk> rusti: type MyType = u32; static MyTypeBytes = sys::size_of::<MyType>()
[04:02:41] <rusti> foo.rs:5:47: 5:48 error: expected `:` but found `=`
[04:02:41] <rusti> foo.rs:5          type MyType = u32; static MyTypeBytes = sys::size_of::<MyType>()
[04:02:41] <rusti>                                                         ^
[04:02:47] <dymk> rusti: type MyType = u32; static MyTypeBytes: uint = sys::size_of::<MyType>()
[04:02:48] <rusti> foo.rs:6:4: 6:5 error: expected `;` but found `}`
[04:02:48] <rusti> foo.rs:6     });
[04:02:48] <rusti>              ^
[04:03:18] *** Joins: sk (sk@61A494B3.BA40E8A.AAC02D62.IP)
[04:03:36] <aatch> dymk, you can't have function calls in static items
[04:03:47] <cmr> rusti: type MyType = u32; static MyTypeBytes: uint = sys::size_of::<MyType>();
[04:03:49] <rusti> more than 5 lines of output, pastebinned: http://sprunge.us/eiUh
[04:04:38] <dymk> Is there a size_of variant that can be called outside of a function? 
[04:04:49] <aatch> dymk, no, sorry
[04:06:37] <strcat> need eval!() ;p
[04:08:01] <sammykim> r? https://github.com/mozilla/rust/pull/6297
[04:09:41] *** Joins: dbaupp (Thunderbir@8D0E22F1.D5A1DCF.37681C44.IP)
[04:10:26] <Luqman> sammykim: r+
[04:10:40] *** Joins: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[04:11:50] <sammykim> Luqman: Thxs a lot
[04:15:02] *** Quits: dbaupp (Thunderbir@8D0E22F1.D5A1DCF.37681C44.IP) (Ping timeout)
[04:18:19] *** Joins: dbaupp (Thunderbir@8D0E22F1.D5A1DCF.37681C44.IP)
[04:19:13] <dymk> strcat: actually compile time executed functions would be awesome :P
[04:19:43] <dymk> or compile time executed strings, anything like that
[04:19:45] *** Joins: sonwow (sonwow@5AB4884B.FCC4549.14D5B978.IP)
[04:21:08] <dymk> however then there'd have to be a way for the compiler to verify that a function is pure, and it seems like that's been dropped
[04:21:54] <strcat> the 'pure' keyword didn't correspond to something you could use for that
[04:22:29] <dymk> then there is hope!
[04:22:53] <dymk> has CTFE been discussed for Rust in the past?
[04:22:54] <cmr> At the very least, special-casing size_of could be useful.
[04:23:17] <dymk> cmr: submitted an issue about that
[04:30:31] <cmr> [0:18:07]~/entropy> RUST_LOG=rustc=2 rustc foo.rs 
[04:30:33] <cmr> rust: task 7f1c202060e0 ran out of stack
[04:30:39] <cmr> yay iloops
[04:30:43] *** Quits: lmandel (lmandel@FE1F74.86ED00A7.971E19F6.IP) (Quit: lmandel)
[04:32:15] <brson> dymk: syntax extensions (procedural macros) are rust code executed at compile time. they can't be implemented outside the compiler yet but it should be possible to run arbitrary code eventually
[04:36:49] *** Joins: piiiiiiiiiiiiiiiinj9000eeves (Mibbit@moz-AB722A1C.mc.videotron.ca)
[04:39:54] <barosl> niiiiiiiiiiiiiiiiiiiiice nick dude
[04:39:59] *** Quits: pcwalton (pcwalton@43CB6079.66715431.D25A875A.IP) (Ping timeout)
[04:40:48] <piiiiiiiiiiiiiiiinj9000eeves> <3
[04:41:44] *** Quits: piiiiiiiiiiiiiiiinj9000eeves (Mibbit@moz-AB722A1C.mc.videotron.ca) (Quit: http://www.mibbit.com ajax IRC Client)
[04:42:12] <strcat> ugh bors is stuck
[04:43:43] <strcat> buildbot needs handholding yet again ;p
[04:45:36] <brson> strcat: how can you tell?
[04:46:00] <strcat> brson: the auto bots are green and weren't doing anything
[04:46:08] <strcat> just forced builds for the tip of auto on all 3
[04:46:28] <strcat> usually fixes it afaik
[04:46:33] *** Joins: graydon (graydon@3853DDD.39EEDBB3.D758B1AA.IP)
[04:46:33] *** ChanServ sets mode: +qo graydon graydon
[04:48:02] <yichoi> pcwalton has gone
[04:48:04] <yichoi> :(
[04:48:51] <yichoi> he supposes to answer about #6214
[04:49:03] *** Quits: jgilbert (jgilbert@2557E599.66715431.D25A875A.IP) (Ping timeout)
[04:49:11] <yichoi> brson: pinb
[04:49:17] <yichoi> brson: ping
[04:51:18] *** Quits: bnicholson (bnicholson@moz-E98974C1.hsd1.ca.comcast.net) (Input/output error)
[04:52:03] <aatch> Well I managed to output a very naive module dependency graph for libcore
[04:52:32] <cmr> sweet!
[04:52:48] <aatch> Pretty much everything depends on vec, which is funny
[04:53:12] <bjz> :)
[04:53:46] <dymk> Is there a way to define methods on a type? eg, "type MyType = int; impl MyType { }". Compiler is yelling at me because of it, saying that I need to declare an interface first. 
[04:54:11] <strcat> MyType isn't a type, it's another name for int
[04:54:21] *** Joins: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net)
[04:54:31] <aatch> dymk, you can't implement methods on a type that wasn't declared in the same crate
[04:54:50] <doy> 'type' is a somewhat misleading name for that keyword
[04:54:52] <dymk> 'type' seems like a bit of a misnomer then ;) 
[04:55:01] <aatch> this has been said.
[04:55:27] <dymk> 'alias' maybe
[04:55:32] *** Quits: graydon (graydon@3853DDD.39EEDBB3.D758B1AA.IP) (Quit: Leaving.)
[04:55:38] <dymk> still under the 6 char limit
[04:55:46] <strcat> https://github.com/mozilla/rust/issues/5752
[04:56:21] <dymk> fair enough; it'll be interesting to see where that goes
[04:57:03] <cmr> what *is* a newtype anyway?
[04:58:14] <strcat> struct Foo(int) - a new type ;p
[04:58:21] <sp3d> a little stronger than a typedef
[04:58:24] *** Quits: igl (igl@moz-4EA55111.adsl.alicedsl.de) (Ping timeout)
[04:58:49] *** Quits: mrplant (Mibbit@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: http://www.mibbit.com ajax IRC Client)
[04:59:20] *** Joins: igl (igl@moz-894C9094.adsl.alicedsl.de)
[04:59:31] <brson> yichoi: pong
[05:00:01] <yichoi> brson: hi minor question.
[05:00:46] <brson> ok
[05:00:49] <yichoi> brson: in case of #6085
[05:00:56] *** Quits: noct (quassel@moz-BAA6B280.com) (Ping timeout)
[05:01:02] <sonwow> brson: are you working on #6306?
[05:01:42] *** Joins: noct (quassel@moz-BAA6B280.com)
[05:02:10] <yichoi> brson: do you want like that change from pub fn make_dir(p: &Path, mode: c_int) to pub fn make_dir(p: &Path, mode: mode_t) 
[05:03:28] <brson> yichoi: I'm not sure, I'll take a look
[05:03:28] *** Quits: SiegeLord (sl@moz-56D7E78.bstnma.fios.verizon.net) (Quit: It's a joke. It's all a joke.)
[05:04:42] <bjz> dymk: impling on type aliases got removed several days ago
[05:05:08] <dymk> oh bummer, why?
[05:05:28] <bjz> I don't know
[05:05:50] <strcat> that sounds like it was a bug
[05:05:58] <strcat> wouldn't be coherent afaik
[05:06:11] <strcat> they aren't a new type, you could have multiple implementations of the same stuff
[05:06:34] <bjz> dymk: https://github.com/mozilla/rust/pull/6087
[05:06:45] <brson> yichoi: no, I think I would prefer an enum that specified possible modes, taking into account the windows API, which is currently just *ignoring* the parameter. I can't even tell from the source what the valid values are.
[05:06:46] <bjz> strcat: oh yeah, that makes sense
[05:06:55] *** Quits: Jesin (Jessin_@4FE0CEF2.B4552BE7.C85D72.IP) (Ping timeout)
[05:07:05] <strcat> brson: well, ideally not an enum
[05:07:07] <brson> yichoi: graydon could disagree though. I'm not sure what his vision for that module is and he usually likes less abstraction than I
[05:07:11] <strcat> we just need a flag type with | overloaded
[05:07:16] <strcat> and some constants
[05:07:26] <strcat> casting to an int to OR them would be annoying
[05:07:45] <brson> strcat: ok
[05:07:51] <bjz> dymk: I agree the keyword 'type' is rather unfortunate. No idea what could be done at this stage though. :(
[05:08:11] <strcat> bjz: not too late to change something like that, it's easy to port
[05:08:22] <strcat> unlike changing semantics or *really* changing the syntax
[05:08:37] *** Quits: a__ (a__@moz-B4E30208.nycmny.fios.verizon.net) (Ping timeout)
[05:08:45] <cmr> Was it called type as a shorter form of "typedef"?
[05:09:03] <strcat> probably ;p
[05:09:45] <bjz> I had a crazy idea a while back
[05:09:47] <bjz> https://gist.github.com/bjz/5265476
[05:09:56] <brson> strcat: what type do you think it should be if it's not an enum?
[05:10:03] <yichoi> brson:   looks like define mode types irst then change c_int to it.  
[05:10:33] <brson> yichoi: yes, agreed
[05:10:35] <strcat> brson: just some like struct Flag { priv flag: c_int } with some statics predefined and a BitOr implementation
[05:10:43] <bjz> ie. use 'type' for 'struct'
[05:10:49] <strcat> something like*
[05:11:06] <strcat> brson: I used an enum for a few C bindings and it's just not very nice
[05:11:12] *** Quits: dymk (dymk@moz-791093B6.sub-70-211-65.myvzw.com) (Quit: Leaving)
[05:11:20] <ILyoan> bjz: hi, question
[05:11:23] <cmr> bjz: I'd go for it.
[05:11:24] <strcat> because you have to pass in an array, the caller can pre-combine flags
[05:11:27] <strcat> can't*
[05:11:32] * strcat really can't type right now
[05:11:34] <bjz> cmr: yeah?
[05:11:49] <yichoi> brson:  are there any reference to define mode_t ? 
[05:12:03] <bjz> ILyoan: did you see your pull
[05:12:12] <bjz> ILyoan: brson and I commented on it
[05:12:20] <ILyoan> bjz: yeah I saw it
[05:12:29] <bjz> ILyoan: thoughts?
[05:12:31] <cmr> bjz: yeah. I'd also name "tuple struct" to "named tuple" while you're at it :p
[05:12:44] <strcat> brson: sec
[05:13:09] <bjz> cmr: well yeah, once we got rid of 'struct', you wouldn't need it
[05:13:27] <bjz> cmr: 'tuple struct' always sounded weird
[05:13:32] <cmr> I agree
[05:13:43] <brson> strcat: attaching impls to an `struct Flag` or attaching them to an `enum Flag` seem very similar to me
[05:14:00] <strcat> brson: you can't OR the variants of an enum though
[05:14:00] <jack> github down for you guys? i get 500 trying to submit issues :(
[05:14:00] <bjz> strcat: did you see that gist?
[05:14:13] <strcat> brson: unless you predefine a variant for all possible combinations
[05:14:23] <jack> seems to have cleared up.
[05:14:42] <strcat> bjz: sec, let me finish this thing first
[05:14:50] <ILyoan> I think there are two option, one is chaning approx_eq() implementation so that it uses relative error method, and another is separating method
[05:14:51] <brson> strcat: not safely, true
[05:15:24] <ILyoan> bjz: I would like to know your preference.
[05:15:31] <strcat> brson: match assumes it knows all the possible cases when you match on one
[05:15:40] <cmr> bjz: Although, struct makes a good parallel to C, 'type' obscures that a bit, but nothing a bit of documentation couldn't fix.
[05:16:06] <cmr> Something I don't really understand yet is how rust works at runtime. What is an impl, how do generics work, how are things represented, etc.
[05:16:15] <brson> strcat: I see, thanks
[05:16:37] <cmr> A bit of documentation about that would be supercool
[05:16:42] <aatch> cmr, 2 of those 3 things are dealt with at compile time
[05:16:51] <brson> sonwow: no, I'm not working on #6306
[05:16:52] <strcat> brson: and I sent in a commit a while back that puts LLVM range asserts on bool + enum discriminant loads, since match already makes that assumption
[05:17:13] <bjz> ILyoan: could you comment on your pull with the difference between those methods?
[05:17:16] <cmr> aatch: generics are compile-time, then, and generate separate code for each type, a-la c++ templates?
[05:17:35] <aatch> cmr, yep. the process is called monomorphization.
[05:17:38] <sp3d> yeah, "rust for gobject flunkies" or such a C-oriented walkthrough of how traits and method dispatch work would be cool
[05:17:42] <ILyoan> bjz: okay
[05:17:49] <bjz> ILyoan: it would be nice not to have to add another trait
[05:18:00] <strcat> sp3d: statically, unless you use traits as objects
[05:18:20] <strcat> a trait object is a ptr to the object + a ptr to a vtable
[05:18:31] <sp3d> just the pair of pointers?
[05:18:40] <strcat> yes but that's *only* if you use traits as objects
[05:18:42] <sp3d> yeah
[05:19:26] <cmr> so like fn foo<T:ToStr>(a: T) or what?
[05:19:32] <strcat> foo<T: Ord, U: Eq + Add<U, U>>(a: &T, b: &T, c: &U) -> (bool, U) is just static
[05:19:49] <strcat> cmr: that's just static dispatch, no vtables
[05:19:55] *** Joins: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net)
[05:20:04] <strcat> fn foo(a: &Ord, b: &Ord) -> bool is dynamic dispatch
[05:20:11] <cmr> ah
[05:20:14] <cmr> that makes sense.
[05:20:35] <strcat> a and b are represented as a fat pointer to a vtable (with the Ord methods, and I imagine anything that Ord inherits from) and the object
[05:20:47] <strcat> with the ptr to the object being &, ~ or @ depending on the trait object type
[05:21:06] <sp3d> the only difference syntactically is that the former is <parameterized>?
[05:21:37] <strcat> sp3d: yes, parameterized -> static dispatch (specialization), using traits as objects -> dynamic dispatch
[05:21:41] <strcat> rusti: sys::size_of::<@Ord>()
[05:21:42] <rusti> 16
[05:21:52] <strcat> 2 ptrs
[05:21:57] <sp3d> cool; I was unclear on what using "trait objects" actually implied
[05:22:41] *** Joins: SimonSapin (simon@moz-C4A83ED9.net-89-2-126.rev.numericable.fr)
[05:23:22] <strcat> bjz: well, I'd prefer just not treating aliases in a special way
[05:23:32] <strcat> use a = y; // resolve a as y
[05:23:45] *** Quits: disjukr (disjukr@D4D5F731.A5F7C7E2.84F431B6.IP) (Connection reset by peer)
[05:23:51] <bjz> that would be nice
[05:23:53] <strcat> that's what C++11 does
[05:23:58] *** Joins: disjukr (disjukr@D4D5F731.A5F7C7E2.84F431B6.IP)
[05:24:09] <strcat> using foo = bar::baz;
[05:24:18] <bjz> much less confusing
[05:24:27] <strcat> template<typename T> using foo = std::vector<T>;
[05:24:31] <cmr> But are a and y trated identically?
[05:24:35] <cmr> *treated
[05:24:40] <bjz> yup
[05:24:54] <cmr> Isn't that different from what "type" does now?
[05:25:00] <bjz> no
[05:25:02] <cmr> Oh
[05:25:21] <bjz> it's an alias
[05:25:31] <james4k> is there much server-side web work being done in rust?
[05:25:32] <bjz> not a new type
[05:25:38] *** Joins: akashj87_ (akash@19C99B11.5A2CA02E.35E3DDC8.IP)
[05:25:54] <bjz> hence all the confusion around using 'type'
[05:25:57] <cmr> yeah :p
[05:26:22] *** Quits: akashj87 (akash@299034BF.F09595B1.35E3DDC8.IP) (Ping timeout)
[05:26:32] <sonwow> brson: thanks, I'll move core::task::local_data/local_data_priv to core::local_data/local_data_priv. 
[05:27:36] *** Joins: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP)
[05:27:49] <bjz> james4k: I haven't heard about much
[05:28:02] <bjz> james4k: but that wouldn't stop you :)
[05:28:35] <youknowone> oh.. moznet allow my proxy server again
[05:28:46] <youknowone> long time no see. hello
[05:28:51] <cmr> aatch: strcat: https://github.com/mozilla/rust/wiki/Doc-lowlevel-details is that accurate? Mind adding some stuff? :)
[05:29:10] *** Quits: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Ping timeout)
[05:29:28] <strcat> cmr: well trait objects need a pointer type
[05:30:35] <strcat> cmr: sec
[05:32:26] *** Joins: akash__ (akash@7CA05C5F.E6EC7554.35E3DDC8.IP)
[05:32:58] *** Quits: akashj87_ (akash@19C99B11.5A2CA02E.35E3DDC8.IP) (Ping timeout)
[05:33:00] <cmr> Is there any technical reason one can't have trait-object-by-value?
[05:33:24] <aatch> cmr, because it wouldn't know the size
[05:33:53] <strcat> cmr: same reason you can't have base-class-by-non-pointer for OOP in C++, etc.
[05:34:03] <strcat> can't have unboxed stuff if you don't know the size, which you need specialization for
[05:34:20] <cmr> I don't actually know c++ or any other such oop lang :(
[05:35:16] <cmr> Makes sense though
[05:35:47] <ILyoan> bjz: commented on the PR could you take a look at it?
[05:37:25] *** Quits: klapaucius (klapaucius@272B8F8B.5692770D.BB41F968.IP) (Ping timeout)
[05:37:36] <strcat> &Trait really doesn't want to compile
[05:38:24] <strcat> and... @ToStr -> error: internal compiler error: unexpected failure
[05:39:03] <strcat> so yeah, if trait objects actually worked I could make an example. ;p
[05:39:08] <cmr> heh
[05:39:11] <strcat> http://ix.io/5wP :(
[05:39:35] <strcat> yay I got the buildbot unstuck
[05:40:13] <strcat> cmr: I'll just write one as if trait objects worked. ;p
[05:40:52] *** Joins: bnicholson (bnicholson@moz-E98974C1.hsd1.ca.comcast.net)
[05:41:10] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[05:41:10] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/z_19pA
[05:41:10] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[05:41:53] <ILyoan> bjz: https://github.com/mozilla/rust/pull/6296
[05:43:17] <strcat> cmr: https://github.com/mozilla/rust/wiki/Doc-lowlevel-details there
[05:44:03] <cmr> strcat: Cool, thanks!
[05:44:11] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[05:44:11] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/1IRI7w
[05:44:11] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[05:44:14] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[05:44:14] <ghrust> 01[13rust01] 15bors pushed 21 new commits to 06auto: 02http://git.io/WkpMMA
[05:44:14] <ghrust> 13rust/06auto 141fe8b8a 15Patrick Walton: libstd: Remove mutable fields from fileinput and net_tcp
[05:44:14] <ghrust> 13rust/06auto 14db5ea90 15Patrick Walton: libstd: Remove mutable fields from flatpipes and io_util
[05:44:15] <ghrust> 13rust/06auto 14c37abee 15Patrick Walton: libstd: Remove mutable fields from future and par
[05:44:17] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[05:44:26] *** Quits: akash__ (akash@7CA05C5F.E6EC7554.35E3DDC8.IP) (Quit: Leaving)
[05:44:29] <cmr> Details like these are important, I think, especially as rust targets systems programming, where these details are important.
[05:47:34] *** Joins: akashj87 (akash@7CA05C5F.E6EC7554.35E3DDC8.IP)
[05:48:46] <strcat> brson: https://github.com/thestinger/rust-magic/commit/16a4fe0505f3c35cd4fa8fb051a5e6f396d2b2eb here's what I mean, specifically
[05:48:56] <strcat> I think that's a lot nicer to use
[05:49:08] <strcat> you can do 'let x = FlagA | FlagB | FlagC;
[05:49:12] <strcat> instead of dealing with an array
[05:49:28] <strcat> and it's as type safe
[05:49:36] <cmr> loooots of boilerplate though
[05:49:46] <yichoi> strcat: looks reasonable
[05:50:09] <strcat> yeah implementing it is more painful without a syntax ext or macro to make it easier
[05:50:17] <strcat> could easily be a macro
[05:50:50] <Jeaye> strcat == thestinger ?
[05:50:53] <strcat> yes
[05:50:53] <yichoi> strcat: can start to implement mode_t with your idea
[05:51:12] <Jeaye> strcat: Thanks for the Arch builds. :D
[05:51:36] <strcat> Jeaye: np :)
[05:55:09] *** Joins: klapaucius (klapaucius@272B8F8B.5692770D.BB41F968.IP)
[05:55:41] * aatch feels slightly dirty using @mut all over the place
[05:57:00] *** Quits: dbaupp (Thunderbir@8D0E22F1.D5A1DCF.37681C44.IP) (Ping timeout)
[05:58:16] <bjz> aatch: I love how 'mut' makes you feel naughty
[05:58:30] *** Joins: wuwei`lab (wuwei@1A513F49.818D7924.FAA9ED67.IP)
[05:58:36] *** Quits: klapaucius (klapaucius@272B8F8B.5692770D.BB41F968.IP) (Ping timeout)
[05:58:47] <aatch> bjz, it's not just `mut`, it's mutable chared
[05:58:50] <aatch> shared*
[05:58:57] <bjz> yep
[05:59:00] <bjz> :)
[05:59:09] <aatch> I can handle mutable, but I prefer it owned.
[05:59:14] * aatch is building a graph
[05:59:31] <aatch> So owned isn't really an option
[06:00:17] *** Joins: Sodel_the_V (user@moz-853663E1.va.shawcable.net)
[06:02:12] <rroels> if I do this:
[06:02:14] <rroels> static rnd: rand::IsaacRng = rand::IsaacRng::new();
[06:02:15] <rroels> it says:
[06:02:21] <rroels> function calls in constants are limited to struct and enum constructors
[06:02:31] <aatch> rroels, static is immutable data
[06:02:32] <rroels> isn't that a struct constructor?
[06:02:43] <rroels> ah, good point
[06:02:52] <aatch> In fact, it's stored in the read-only segment of the object file
[06:02:54] <cmr> rroels: No, struct constructor would be like Foo {a: 2, b: 2}
[06:03:02] <rroels> aaah, I see
[06:03:28] <rroels> thanks
[06:03:41] <aatch> rroels, there is no global mutable data in rust (well not easily anyway)
[06:07:14] *** Joins: klapaucius (klapaucius@272B8F8B.5692770D.BB41F968.IP)
[06:10:20] *** Joins: nukkesi (nukke@moz-1D115A2B.sd.sd.cox.net)
[06:10:40] *** Joins: pyrac (pyrac@moz-516480D0.w92-156.abo.wanadoo.fr)
[06:12:17] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[06:12:17] *** ChanServ sets mode: +o dherman
[06:12:19] *** Joins: haard (fredrik@18E6EC45.6A26450D.BE04C429.IP)
[06:13:11] <strcat> Jeaye: it's nice to be able to just set up automatic builds on arch's build server ;p
[06:13:55] <strcat> saves a lot of people compiling it themselves hopefully
[06:14:25] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[06:18:50] *** Quits: eevee (eevee@moz-6BEA2DBB.evrt.wa.frontiernet.net) (Ping timeout)
[06:18:59] *** Quits: brson (brson@E9CDE21E.991753BB.CA4D1600.IP) (Quit: leaving)
[06:20:01] *** Joins: tcsc (tcsc@moz-A838B260.dhcp.nwtn.ct.charter.com)
[06:20:12] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[06:20:12] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 141e4d4ea to 145a1afaf: 02http://git.io/N3iJvQ
[06:20:12] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[06:20:14] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[06:20:14] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/lm0ROQ
[06:20:14] <ghrust> 13rust/06auto 147455f98 15Sangeun Kim: Make lint_table static
[06:20:14] <ghrust> 13rust/06auto 14356ebe8 15Sangeun Kim: extranous thing is removed
[06:20:14] <ghrust> 13rust/06auto 1486500fb 15bors: auto merge of #6297 : sammykim/rust/static-lint-table, r=luqmana
[06:20:16] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[06:21:01] *** Quits: steven_is_false (quassel@moz-144077DE.bchsia.telus.net) (Client exited)
[06:21:01] *** Joins: fabiand (fabiand@moz-53800E1C.adsl.alicedsl.de)
[06:26:38] <Jeaye> strcat: Oh yeah.
[06:26:43] *** Quits: wuwei`lab (wuwei@1A513F49.818D7924.FAA9ED67.IP) (Ping timeout)
[06:26:56] <Jeaye> I've overheated my laptop multiple times from trying to compile with too many jobs. :|
[06:27:38] *** Joins: eevee (eevee@moz-C02C240F.evrt.wa.frontiernet.net)
[06:28:31] *** Quits: fabiand (fabiand@moz-53800E1C.adsl.alicedsl.de) (Client exited)
[06:31:31] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Leaving...)
[06:31:33] *** Joins: fabiand (fabiand@moz-53800E1C.adsl.alicedsl.de)
[06:31:38] *** Quits: RMF (RMF@moz-BBAAC65A.dsl.telepac.pt) (Ping timeout)
[06:32:53] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[06:35:34] *** Joins: RMF (RMF@moz-52793E40.dsl.telepac.pt)
[06:37:18] *** Joins: webber46 (webber46@moz-AC14FDEA.se)
[06:37:43] *** Joins: mindginative (mindginati@moz-9C555AF3.spmconsultants.co.nz)
[06:37:54] *** Quits: mindginative (mindginati@moz-9C555AF3.spmconsultants.co.nz) (Quit: brb)
[06:44:44] *** Quits: thou (thou@moz-1C1CA9F7.fasttrackcomm.net) (Input/output error)
[06:47:13] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[06:47:18] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.0)
[06:51:12] <sammykim> Q] How can I make two strings as a string, If it's difference type. One is borrowed type, the other is owned type. I want to make them as a borrowed string.
[06:53:15] <sammykim> or isn't there concat for borrowed string?
[07:06:53] *** Quits: jdm (jdm@DB05BBF2.BB1F48F2.971E19F6.IP) (Ping timeout)
[07:13:55] *** Joins: jviereck (Adium@moz-A2DCE0DD.dclient.hispeed.ch)
[07:14:35] <rroels> good question, don't know the answer though, i'm a rust-noob
[07:18:31] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[07:19:56] <thomaslee> anybody know the difference between a reexported item vs. an explicit item wrt the metadata encoding/decoding stuff?
[07:20:07] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[07:20:10] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[07:20:10] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/lm0ROQ
[07:20:10] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[07:23:12] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[07:23:12] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/DUoqsg
[07:23:12] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[07:23:13] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[07:23:13] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/nacHNQ
[07:23:13] <ghrust> 13rust/06auto 1443165b5 15Daniel Micay: rc: remove the managed pointer workaround
[07:23:13] <ghrust> 13rust/06auto 1496eb1e5 15Daniel Micay: arc: mark RWARC as non-Const
[07:23:13] <ghrust> 13rust/06auto 14625e518 15bors: auto merge of #6305 : thestinger/rust/rc, r=nikomatsakis
[07:23:16] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[07:28:37] *** Joins: Blub\w (wry@moz-80BF0D66.wireless.dyn.drei.com)
[07:29:26] <jaen>  https://news.ycombinator.com/item?id=5671652 - that's pretty interesting, Carmack trying to write a game in Haskell
[07:32:28] *** Quits: Sodel_the_V (user@moz-853663E1.va.shawcable.net) (Ping timeout)
[07:34:09] *** Quits: haard (fredrik@18E6EC45.6A26450D.BE04C429.IP) (Broken pipe)
[07:34:10] *** Joins: haard (fredrik@18E6EC45.6A26450D.BE04C429.IP)
[07:35:06] *** Quits: lerc (quassel@121-74-236-56.telstraclear.net) (Ping timeout)
[07:37:05] *** Joins: lerc (quassel@499C857C.869384DE.788638A4.IP)
[07:37:22] *** Quits: heftig (heftig@moz-ED63EB3D.dip0.t-ipconnect.de) (Ping timeout)
[07:38:48] <ssbr> Wasn't Sweeney all about FP as well?
[07:41:13] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[07:42:36] *** Joins: jensnockert (jensnocker@moz-5C7F2150.setothd.dyn.perspektivbredband.net)
[07:44:21] *** Joins: heftig (heftig@moz-C8CBE7BC.dip0.t-ipconnect.de)
[07:46:11] *** Quits: devbug (quassel@moz-E1DE087C.bchsia.telus.net) (Client exited)
[07:47:02] <nukkesi> ssbr: sorta. he seemed interesting in trying FP, but didn't seem to like Haskell in particular that much.
[07:47:38] <ssbr> I thought he was all, "FP is the way to go, but game developers will never use haskell. Maybe something more like ML?"
[07:47:44] <ssbr> btw rust is something more like ML ;)
[07:48:21] *** Quits: lerc (quassel@121.75.133.243) (Ping timeout)
[07:48:34] <ssbr> http://www.st.cs.uni-saarland.de/edu/seminare/2005/advanced-fp/docs/sweeny.pdf <-- what I was thinking of (haven't reread yet, dunno if my summary was accurate)
[07:48:49] *** Joins: Palmik (palmik@moz-79CD58C8.vpn.muni.cz)
[07:49:35] *** Quits: jensnockert (jensnocker@moz-5C7F2150.setothd.dyn.perspektivbredband.net) (Ping timeout)
[07:50:02] <nukkesi> yep, that's what i'm reading right now.
[07:50:18] *** Joins: lerc (quassel@499C857C.869384DE.788638A4.IP)
[07:50:29] <ssbr> hm, he likes dependent types. I didn't notice that before.
[07:50:31] <nukkesi> the Haskell slides are at the very end. he talks specifically about the problems he has with Haskell.
[07:51:06] *** Joins: jensnockert (jensnocker@moz-5C7F2150.setothd.dyn.perspektivbredband.net)
[07:51:36] <ssbr> nukkesi: none of them are problems with FP though
[07:52:17] *** Joins: wunki (wunki@moz-7300E3D6.ip.prioritytelecom.net)
[07:52:23] <ssbr> the scary thing is that I think he wants ATS
[07:52:34] <ssbr> ( http://en.wikipedia.org/wiki/ATS_%28programming_language%29 )
[07:52:59] <nukkesi> interesting bit: on slide 20, he mentions that they never use assembly. but it's a bit vague. i wish there was a video of this talk.
[07:55:53] <ssbr> man, he really likes dependent types. They're littered throughout the slides.
[08:00:49] <rroels> I have a struct, and I want to get an unsafe pointer to pass to an external C function. Is ptr::addr_of still usable? I can't seem to import it
[08:01:36] *** Joins: joshua_ (joshua@moz-45967CBE.emarhavil.com)
[08:01:37] <aatch> rroels, borrowed pointers now automatically coerce to unsafe pointers
[08:01:44] <rroels> cool
[08:01:44] *** Quits: joshua_ (joshua@moz-45967CBE.emarhavil.com) (Quit: joshua_)
[08:01:45] *** Joins: joshua_ (joshua@moz-45967CBE.emarhavil.com)
[08:01:48] <rroels> I'll try that, thanks
[08:02:24] *** Joins: dbaupp (Thunderbir@moz-7D1EB5E8.lns20.syd6.internode.on.net)
[08:02:43] *** Quits: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Quit: zzzZZZzzz)
[08:03:42] <rroels> aatch: thanks! works great
[08:03:48] <rroels> sorry for all the the dumb questions
[08:03:53] <rroels> I'm just loving Rust so far
[08:04:02] <aatch> rroels, it's fine
[08:12:56] *** Quits: jensnockert (jensnocker@moz-5C7F2150.setothd.dyn.perspektivbredband.net) (Ping timeout)
[08:13:10] *** Joins: jensnockert (jensnocker@moz-5C7F2150.setothd.dyn.perspektivbredband.net)
[08:16:08] *** Quits: tcsc (tcsc@moz-A838B260.dhcp.nwtn.ct.charter.com) (Quit: computer sleeping)
[08:18:04] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[08:19:34] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[08:32:10] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[08:32:10] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/nacHNQ
[08:32:10] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[08:35:12] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[08:35:12] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/TUdgIA
[08:35:12] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[08:35:14] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[08:35:14] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/zxdJ7Q
[08:35:14] <ghrust> 13rust/06auto 144cd51c4 15Brian Anderson: rt: Move win32_require out of the rust_kernel type...
[08:35:14] <ghrust> 13rust/06auto 1421aaa7f 15Brian Anderson: rt: Eliminate the dependency on rust_kernel from rust_rng
[08:35:14] <ghrust> 13rust/06auto 143b6a32d 15Brian Anderson: core::rt: Add a test that rng works with new tasks
[08:35:16] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[08:38:21] *** Quits: jensnockert (jensnocker@moz-5C7F2150.setothd.dyn.perspektivbredband.net) (Connection reset by peer)
[08:38:22] *** Joins: jensnockert (jensnocker@moz-5C7F2150.setothd.dyn.perspektivbredband.net)
[08:38:26] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[08:51:00] *** Quits: nukkesi (nukke@moz-1D115A2B.sd.sd.cox.net) (Quit: WeeChat 0.4.0)
[08:54:05] *** Joins: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[08:54:45] *** Joins: lucian_ (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[08:54:45] *** Quits: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP) (Connection reset by peer)
[08:55:02] *** Quits: jensnockert (jensnocker@moz-5C7F2150.setothd.dyn.perspektivbredband.net) (Ping timeout)
[08:55:32] *** Quits: lerc (quassel@121.75.133.243) (Ping timeout)
[08:57:32] *** Joins: lerc (quassel@6174E42B.BEFA2430.788638A4.IP)
[08:57:55] *** Quits: Blub\w (wry@moz-80BF0D66.wireless.dyn.drei.com) (Quit: bb)
[09:00:35] *** Joins: jensnockert (jensnocker@moz-5C7F2150.setothd.dyn.perspektivbredband.net)
[09:01:46] *** Quits: lerc (quassel@121.75.155.67) (Ping timeout)
[09:03:45] *** Joins: lerc (quassel@6174E42B.BEFA2430.788638A4.IP)
[09:04:45] <dbaupp> Built-in benchmarking is nice
[09:05:04] <aatch> dbaupp, easy to use?
[09:05:25] <dbaupp> aatch: yup
[09:05:39] <rroels> where can I find info about this?
[09:06:01] <dbaupp> aatch, rroels: https://github.com/mozilla/rust/wiki/Doc-unit-testing#benchmarking
[09:06:10] <rroels> thanks
[09:07:01] <aatch> That's fairly recent, right? I think I remember somebody mentioning they were going to do it recently
[09:07:02] <dbaupp> (the hardest bit was working out that the compiled file needed the --bench flag, not rustc.)
[09:07:47] <dbaupp> aatch: no idea, the first time I used it was 5 minutes ago
[09:08:16] <dbaupp> aatch: is 4 months recent? https://github.com/mozilla/rust/pull/4515
[09:08:29] <aatch> dbaupp, maybe not then lol
[09:08:58] *** Joins: trapni (trapni@moz-6A0EA166.dawanda.com)
[09:09:29] *** Joins: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP)
[09:12:28] *** Quits: akashj87 (akash@7CA05C5F.E6EC7554.35E3DDC8.IP) (Ping timeout)
[09:13:18] *** Quits: sully (sully@moz-45967CBE.emarhavil.com) (Ping timeout)
[09:13:32] *** Joins: inolen (Adium@moz-FA2406D8.socal.res.rr.com)
[09:13:53] *** Joins: sully (sully@moz-45967CBE.emarhavil.com)
[09:14:02] <aatch> Well it turns out that using libsyntax as an external library for a regular program isn't actually that hard
[09:14:21] <aatch> I mean, it's not easy either, but surprisingly little hoop-jumping required
[09:14:38] <ssbr> What kind of hoop-jumping was unexpectedly not there?
[09:14:49] <ssbr> (I could have phrased that question better...)
[09:15:51] <aatch> ssbr, I'm not sure, but you can get an AST in like 3 lines of code.
[09:18:57] <dbaupp> aatch: yeah, I found that too
[09:19:03] <dbaupp> it was really convenient
[09:19:42] <dbaupp> (except, doing anything (including read-only) in parallel involving the ast is hard.)
[09:28:39] <ssbr> What do you do for a test case that can only succeed or loop forever? The test runner output doesn't seem to make clear which test is taking forever (I would've hoped for the line at the bottom to be something like "test foo:test_infinite_loop ...")
[09:30:04] *** Joins: berak (chatzilla@875EAED4.6062171A.1A5CC7E5.IP)
[09:30:38] <aatch> ssbr, just have a counter and fail when it gets above some value
[09:31:01] <aatch> Since presumably you can work out some upper limit for the input
[09:33:58] <ssbr> I can. not exactly trivially. I am not in the mood to think very much :(
[09:34:44] <ssbr> can I declare a block of code to only be compiled within a test case using #[test]?
[09:35:00] <ssbr> eh, to only be compiled when I'm doing rustc --test rather
[09:35:02] <aatch> ssbr, #[cfg(test)]
[09:35:08] <ssbr> aatch: ah, excellent
[09:35:31] <aatch> ssbr, a fairly common pattern is to have #[cfg(test)] on a mod test {}
[09:38:22] <dbaupp> ssbr: e.g. https://github.com/mozilla/rust/blob/master/src/libcore/vec.rs#L2957
[09:41:10] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[09:41:10] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/zxdJ7Q
[09:41:10] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[09:44:12] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[09:44:12] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/q671xQ
[09:44:12] <ghrust> 13rust/06auto 14387d6c5 15Niko Matsakis: Lift restriction on calling extern C functions, and propagate...
[09:44:12] <ghrust> 13rust/06auto 141d7a136 15bors: auto merge of #6309 : nikomatsakis/rust/issue-3678-type-of-extern-fns, r=nikomatsakis...
[09:44:13] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[09:45:33] *** Joins: zakora (NC@moz-8EAF945F.fbx.proxad.net)
[09:49:30] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[09:53:22] *** Joins: akashj87 (akash@7CA05C5F.E6EC7554.35E3DDC8.IP)
[09:54:49] *** Quits: jensnockert (jensnocker@moz-5C7F2150.setothd.dyn.perspektivbredband.net) (Input/output error)
[10:01:39] *** Quits: jviereck (Adium@moz-A2DCE0DD.dclient.hispeed.ch) (Quit: Leaving.)
[10:05:22] *** Joins: jviereck (Adium@moz-A2DCE0DD.dclient.hispeed.ch)
[10:05:41] *** Joins: wuwei`lab (wuwei@1A513F49.818D7924.FAA9ED67.IP)
[10:09:25] *** kimundi is now known as zz_kimundi
[10:10:21] *** Quits: Yurumechan (23f9939a@B2F514.E4420F21.EEF52F3A.IP) (Client exited)
[10:10:35] *** Joins: Yurumechan (23f9939a@B2F514.E4420F21.EEF52F3A.IP)
[10:11:15] *** Quits: Yurumechan (23f9939a@B2F514.E4420F21.EEF52F3A.IP) (Client exited)
[10:12:37] <jaen> ssbr: a bit late to comment since I went to do other things, but dependent types are pretty swell, for example you wouldn't have to have Eq for all practical lengths of tuples implemented in core if Rust had dependent types. And yeah, ATS is pretty damn scary. I think Idris is a better choice here. Or Rust, if you aren't so bent on dependent typing. I think Rust does quite a big portion of what
[10:12:38] <jaen> Sweeney touches on in the presentation. It's good enough to almost stop me from wanting to implement my own language one day.
[10:13:43] <ssbr> Sweeney seems to consider safe unchecked array access to be vital for performance
[10:13:52] <ssbr> which Rust can't do :(
[10:14:14] <jaen> Well, that's part of not being dependently typed I'm afraid ; /
[10:14:31] <ssbr> Yup.
[10:16:47] *** Quits: jviereck (Adium@moz-A2DCE0DD.dclient.hispeed.ch) (Quit: Leaving.)
[10:16:52] <dbaupp> ssbr: it can do unchecked array access, via unsafe_get, unsafe_ref, and unsafe_set
[10:17:07] *** Joins: jviereck (Adium@moz-A2DCE0DD.dclient.hispeed.ch)
[10:17:15] <jaen> dbaupp: but thatdoesn't guarantee index to be valid, right?
[10:17:24] <dbaupp> (oh, wait "safe")
[10:17:27] *** Joins: Yurumechan (23f9939a@B2F514.E4420F21.EEF52F3A.IP)
[10:17:46] <dbaupp> jaen: yup, hence "unsafe" (I didn't read the previous thing fully)
[10:18:18] <jaen> right
[10:18:19] <ssbr> It might be interesting to see how much work it would take to add on indexed types to an extension of rust
[10:18:28] <ssbr> I ain't doing that, though
[10:19:07] <jaen> I think they tacked something like that on Haskell without it being dependently typed so it's definitely possible, but you'd probably have to sacrifice a couple PhDs to get it working
[10:19:34] *** zz_kimundi is now known as kimundi
[10:22:32] *** Quits: jviereck (Adium@moz-A2DCE0DD.dclient.hispeed.ch) (Quit: Leaving.)
[10:24:48] <ssbr> http://www.haskell.org/haskellwiki/GHC/Indexed_types
[10:25:13] * aatch just spent a few hours trying to figure out how to do incremental recompilation
[10:25:26] <aatch> Answer: with great difficulty
[10:29:26] <dbaupp> aatch: but it's possible?
[10:29:44] <aatch> dbaupp, probably.
[10:30:02] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[10:31:45] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Ping timeout)
[10:32:47] <aatch> At some point after the resolve step, you need to write all the information to some index.
[10:33:14] *** Joins: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net)
[10:33:21] <aatch> Then use the index to skip various bits.
[10:33:32] <aatch> based on the relative ages of the files.
[10:33:44] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[10:33:50] *** Quits: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[10:34:05] <dbaupp> aatch: so, not the easiest thing
[10:34:11] <aatch> dbaupp, nope.
[10:34:33] <aatch> It would require a massive refactoring of pretty much the entire of rustc::middle
[10:34:57] <dbaupp> aatch: ah
[10:35:05] <aatch> in order to be aware of files, and to be able to utilize a cache.
[10:35:12] <dbaupp> aatch: as in, the most complex part of the whole source tree
[10:35:15] <z0w0> there is a workcache library that should probably be used for that sort of thing
[10:36:03] <aatch> Since the entire point is to skip the type and borrow checks, but if one file changes, then you still need to check any files that depend on definitions from that file.
[10:38:59] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Ping timeout)
[10:39:15] *** Joins: EXetoC (ex@moz-2DBEB1E4.customer.t3.se)
[10:39:32] <aatch> Right now, everything is just loaded into a single AST and each pass does it's thing.
[10:40:20] *** Quits: wuwei`lab (wuwei@1A513F49.818D7924.FAA9ED67.IP) (Quit: Leaving)
[10:40:37] <ssbr_> How should I split a string literal over multiple lines? I was hoping I could use "abc" + "def", but rust doesn't like adding &'static str, even if they're literals
[10:41:31] <dbaupp> ssbr_: literals can span multiple lines
[10:41:40] <dbaupp> like """ in python
[10:41:46] <ssbr_> oh.
[10:42:01] <ssbr_> egh. but then I have to dedent all the way to the beginning of the next line
[10:42:25] <dbaupp> ssbr_: I think it strips whitespace to match the start quote
[10:42:31] <dbaupp> (maaaybe... I can't remember)
[10:42:35] <ssbr_> dbaupp: this is crazy
[10:42:40] <ssbr_> I will try it and see what happens
[10:43:17] <ssbr_> no, looks like it keeps the leading whitespace and the newline
[10:43:28] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[10:43:42] <aatch> ssbr_, put a '\' at the end of the line
[10:43:55] <aatch> inside the string
[10:44:09] <ssbr_> aatch: doesn't that still mean I have to dedent all the way to the beginning of the next line?
[10:44:11] <dbaupp> ssbr_: yeah :( (but yes, you can escape the newline and the leading whitespace via \ as aatch says)
[10:44:16] <aatch> ssbr_, I don't think so
[10:44:31] *** Joins: jdm (jdm@DB05BBF2.BB1F48F2.971E19F6.IP)
[10:44:35] <ssbr_> you are correct
[10:44:40] <ssbr_> That's crazy!
[10:45:05] <ssbr_> I guess I can get used to it though
[10:45:23] <dbaupp> ssbr_: crazy in a bad way?
[10:45:38] <aatch> ssbr_, I think a '\' before a newline in a string means "compress all the whitespace down to a single space" but I might be wrong.
[10:45:49] <ssbr_> dbaupp: I think so, but I could also just not be used to it and actually it's great
[10:46:45] <dbaupp> aatch: nope, it means compress it to nothing
[10:47:01] <ssbr_> aatch: thankfully, no
[10:47:14] <ssbr_> it's just the indentation up to the quote from the first line
[10:47:17] <aatch> dbaupp, actually, that makes more sense
[10:47:18] <ssbr_> (to nothing)
[10:48:19] <ssbr_> I really don't want this infinite loop check to run except in the test case, but #[cfg(test)] only applies to items
[10:49:12] <ssbr_> I mean, if my code is correctly written, an infinite loop will never happen. And there's test cases to check that it's correctly written. So why should I make it check at runtime for everyone?
[10:49:50] <dbaupp> ssbr_: abstract a small bit into two internal fns with #[inline(always)] and #[cfg(test)] on the version that has the check
[10:49:54] <dbaupp> (maybe)
[10:50:40] *** Quits: sk (sk@61A494B3.BA40E8A.AAC02D62.IP) (Quit: Leaving)
[10:51:05] <ssbr_> well there's three bits of code that need to only exist during testing: "let mut loop_counter = 0;", "if loop_counter > foo.len() { fail!() }", "loop_counter += 1"
[10:51:31] <ssbr_> I don't see how some helper function can do all of those unless it returns some closures that do those things
[10:51:34] <ssbr_> can closures be inlined?
[10:51:52] <dbaupp> not sure
[10:52:10] <dbaupp> would be repeated with two versions?
[10:52:13] <dbaupp> *how much code
[10:52:33] <ssbr_> dbaupp: a lot
[10:52:45] <ssbr_> I mean I could refactor so that the body of the loop is a separate function that always gets inlined, maybe
[10:52:58] <ssbr_> eh, but no
[10:53:11] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[10:53:11] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/q671xQ
[10:53:11] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[10:53:13] <ssbr_> it'd have to return a closure once again, since there's setup that goes before the loop, and an outer loop
[10:53:26] <ssbr_> oh wait no, I can pass in mutable references
[10:53:27] <ssbr_> still
[10:53:31] <ssbr_> this is yucky
[10:53:53] <dbaupp> what's this actually testing?
[10:54:17] <dbaupp> that the re engine does loop forever on something?
[10:54:28] <ssbr_> dbaupp: a naive implementation of backtracking search will loop forever on "()*". I need to test that this isn't what I do.
[10:54:41] <benh> How do *mut T pointers behave regarding, like, inheriting mutability?
[10:54:46] <dbaupp> ssbr_: aha
[10:55:00] *** Quits: skchrko_ (sk@61A494B3.BA40E8A.AAC02D62.IP) (Ping timeout)
[10:55:43] <ssbr_> as an aside: regexp engines like python's explicitly disallow such regexps, rather than handling them
[10:55:46] <ssbr_> I don't really know why
[10:56:08] <dbaupp> benh: the actual pointer isn't necessarily mutable (inherited), but the contents always are mutable (is that what you are asking?)
[10:56:10] <ssbr_> (it's not even for performance reasons; python implements the right thing so that it wouldn't loop forever)
[10:56:12] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[10:56:12] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/Z5y8kg
[10:56:12] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[10:56:14] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[10:56:14] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/xMBzjA
[10:56:14] <ghrust> 13rust/06auto 14db1a274 15Fedor Indutny: io: handle fread() errors...
[10:56:14] <ghrust> 13rust/06auto 1483838aa 15bors: auto merge of #6311 : indutny/rust/fix/handle-io-fread-errors, r=z0w0...
[10:56:14] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[10:56:27] <dbaupp> ssbr_: because it makes tests awkward to implement?
[10:56:37] <ssbr_> dbaupp: haha :)
[10:56:41] <benh> dbaupp: I'm wondering whether I should default to *mut T or *T when I personally don't care, but users of my API might
[10:57:07] <benh> if a *mut T is in a non-mut struct, does it turn into *T? If a *T is in a mut struct, does it turn into *mut T?
[10:57:22] <dbaupp> benh: if you're not mutating it, *T
[10:57:36] <dbaupp> benh: there are probably casts that do that
[10:57:37] <z0w0> yes to both afaik
[10:57:51] <z0w0> mut fields got removed, i think?
[10:58:01] <benh> plain "as" happily casts unsafe pointers
[10:58:06] <benh> hmm
[10:58:22] <benh> maybe I'll transmute it to a borrowed pointer instead
[10:58:51] <z0w0> if the user doesn't need to mutate it then it makes sense for it not to be mutable
[10:59:54] <dbaupp> benh: taking borrowed pointers would be better than unsafe, if you can manage it
[11:00:19] *** lucian_ is now known as lucian
[11:02:25] *** kimundi is now known as zz_kimundi
[11:03:23] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Ping timeout)
[11:04:33] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[11:05:41] *** Quits: SimonSapin (simon@moz-C4A83ED9.net-89-2-126.rev.numericable.fr) (Ping timeout)
[11:14:18] *** Joins: spider-mario (spidermari@moz-2BC095A6.rev.sfr.net)
[11:20:37] *** Quits: klapaucius (klapaucius@272B8F8B.5692770D.BB41F968.IP) (Ping timeout)
[11:20:45] *** Joins: jviereck (Adium@moz-A2DCE0DD.dclient.hispeed.ch)
[11:22:36] *** Quits: Yurumechan (23f9939a@B2F514.E4420F21.EEF52F3A.IP) (Client exited)
[11:22:44] *** Joins: doomlord (doomlod@moz-568ADDE2.range86-176.btcentralplus.com)
[11:24:45] *** Quits: sonwow (sonwow@5AB4884B.FCC4549.14D5B978.IP) (Quit: leaving)
[11:28:07] *** Joins: Yurumechan (23f9939a@B2F514.E4420F21.EEF52F3A.IP)
[11:28:15] *** Quits: EXetoC (ex@moz-2DBEB1E4.customer.t3.se) (Ping timeout)
[11:29:15] *** Quits: Yurumechan (23f9939a@B2F514.E4420F21.EEF52F3A.IP) (Client exited)
[11:30:33] *** Joins: jensnockert (jensnocker@moz-5C7F2150.setothd.dyn.perspektivbredband.net)
[11:32:52] *** Joins: cc (cc@moz-9962C9F4.rev.numericable.fr)
[11:32:57] *** Joins: akashj87_ (akash@18A40DF7.9EA85462.35E3DDC8.IP)
[11:33:34] *** Joins: Yurumechan (23f9939a@B2F514.E4420F21.EEF52F3A.IP)
[11:33:51] <engla> is this valid?  trait Monoid : Add<Self,Self> + num::Zero {}     I mean the use of Self there.
[11:34:00] *** Quits: akashj87 (akash@7CA05C5F.E6EC7554.35E3DDC8.IP) (Ping timeout)
[11:37:49] <aatch> engla, should be.
[11:38:10] <aatch> not that trait inheritance works properly anyway
[11:38:13] <engla> it seems to work in some contexts and gives confusing errors in others. I'll test some more
[11:38:27] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Ping timeout)
[11:39:05] <tristram> hello, is there a more compact way to declare let mut t : HashMap<int,int> = HashMap::new();
[11:39:18] <tristram> (without repeating HashMap) ?
[11:40:07] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[11:40:07] <ssbr> tristram: you could say "let mut t = HashMap::new()"
[11:40:21] <ssbr> and let it infer type based on usage elsewhere in the function
[11:40:27] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[11:41:20] <ssbr> AFAIK you only need to declare the types of statics, and things for which rust can't figure out the type (e.g. maybe you never actually add anything to the hashmap, or pass it anywhere)
[11:41:40] <ssbr> (and only use it in contexts that are polymorphic over the type of key/value)
[11:43:30] <tristram> meh, I get an ICE (indeed, it cannot deduce the type in my test)
[11:43:33] <tristram> thanks
[11:44:35] <lucian> tristram: if you do something simple to it, like add a literal, it'll work. i was surprised by that just recently
[11:44:35] *** Joins: sk (sk@199EC8B2.57A579BA.78DD174B.IP)
[11:44:55] *** Quits: jviereck (Adium@moz-A2DCE0DD.dclient.hispeed.ch) (Connection reset by peer)
[11:44:55] *** Joins: jviereck1 (Adium@moz-A2DCE0DD.dclient.hispeed.ch)
[11:45:23] *** Quits: sk (sk@199EC8B2.57A579BA.78DD174B.IP) (Quit: Leaving)
[11:45:27] <tristram> it does indeed :)
[11:46:14] <ssbr_> what's so surprising about type inference? :(
[11:47:15] <ssbr_> I don't know if Rust uses some variation on HM, but in HM you look over a function and look at all the ways in which a value is used, and based on that gather type constraints. You then try to merge all the type constraints to get a type (this is prolog-style unification). If any merge fails, you give a type error.
[11:47:16] <tristram> couldn't rust infer what traits are implemented just from the methods ?
[11:47:27] *** Joins: judder (maradukewa@DABDEEA3.F2C0D0AC.78E362FE.IP)
[11:48:03] <ssbr_> tristram: I guess if you had the relevant traits imported. What about conflicting method names?
[11:48:18] <ssbr_> (note: I don't know much about traits)
[11:48:35] <tristram> good point for the conflicts
[11:49:19] *** Joins: akash__ (akash@235D763D.89E1AFDD.35E3DDC8.IP)
[11:49:39] <doomlord> i iike the way traits unify compile time and runtime polymorphism
[11:50:05] *** Quits: akashj87_ (akash@18A40DF7.9EA85462.35E3DDC8.IP) (Ping timeout)
[11:50:11] <doomlord> maybe unify is the wrong word
[11:50:42] <doomlord> but it seems like one concept is doing the job of several C++ features
[11:50:49] <aatch> ssbr_, Rust does use a HM-like algorithm
[11:51:08] <aatch> It doesn't extend past function bodies, that's all
[11:51:09] *** Joins: akashj87_ (akash@73A66FA.3010DFE1.35E3DDC8.IP)
[11:51:34] *** Quits: akash__ (akash@235D763D.89E1AFDD.35E3DDC8.IP) (Ping timeout)
[11:52:51] *** Joins: sk (sk@199EC8B2.57A579BA.78DD174B.IP)
[11:53:37] *** Quits: akashj87_ (akash@73A66FA.3010DFE1.35E3DDC8.IP) (Ping timeout)
[11:53:46] *** Joins: akashj87_ (akash@3170B0A8.373F35FC.35E3DDC8.IP)
[11:55:05] <lucian> ssbr_: i was surprised because, for example, scala doesn't go that far
[11:55:19] <ssbr_> it doesn't? that's sad :(
[11:55:32] <doomlord> aparently whole program type inference is undesirable for large programs
[11:55:40] <ssbr_> Coming from OCaml it seems pretty straightforward to me, except that I have to declare types for items
[11:55:47] <engla> aatch: I'll have to revisit this when trait inheritance is fixed. At this point, I see things like expected `core::ops::Add<'a,'a>` but found `core::ops::Add<self,self>` (expected type parameter but found self)
[11:56:01] <ssbr_> but that's fine, since it lets Rust do more things than HM can strictly handle, if it wants to
[11:56:09] <lucian> ssbr_: rust's bootstrap was ocaml, so perhaps there are reasons why that is true :)
[11:56:14] <ssbr_> (also, OCaml code can get unreadable because of this, unless you use -annot)
[11:56:46] <lucian> i like that haskell has a strong convention of annotating "items"
[11:57:12] <ssbr_> right. And it has that because you just can't do some things without forcing annotations. In haskell's case, typeclasses
[11:57:15] <ssbr_> (apparently)
[11:57:33] <ssbr_> I wonder if the same problem applies to rust traits? (I don't know very much about the monomorphism restriction and stuff)
[11:57:33] <lucian> it does yet all you if you leave them out, but quite rarely
[11:57:53] <lucian> (haskell, that is)
[11:57:59] <ssbr_> well, haskell gives warnings all the time if you leave them out, but it only fails in some circumstances involving typeclasses AIUI
[12:02:11] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[12:02:11] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/xMBzjA
[12:02:11] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[12:05:11] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[12:05:11] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/3tJ6MQ
[12:05:11] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[12:05:14] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[12:05:14] <ghrust> 01[13rust01] 15bors pushed 7 new commits to 06auto: 02http://git.io/6Y0oxQ
[12:05:14] <ghrust> 13rust/06auto 146bcc3a6 15Brian Anderson: Add some tests for local data + borrowed pointers
[12:05:14] <ghrust> 13rust/06auto 14398cd18 15Brian Anderson: core: Replace Durable with 'static
[12:05:14] <ghrust> 13rust/06auto 14ccc4c1a 15Brian Anderson: std: Replace Durable with 'static
[12:05:17] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[12:05:48] *** Quits: sk (sk@199EC8B2.57A579BA.78DD174B.IP) (Quit: Leaving)
[12:05:56] *** Quits: akashj87_ (akash@3170B0A8.373F35FC.35E3DDC8.IP) (Quit: Leaving)
[12:06:45] *** Joins: akashj87 (akash@3170B0A8.373F35FC.35E3DDC8.IP)
[12:07:25] *** Joins: mib_c3v5ht (Mibbit@4E4DE4E5.9D85AA30.3376CD77.IP)
[12:11:38] *** Quits: mib_c3v5ht (Mibbit@4E4DE4E5.9D85AA30.3376CD77.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[12:12:43] *** Quits: jack (jack@EF36212C.8FA609AD.840029BC.IP) (Quit: Leaving.)
[12:15:13] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[12:17:20] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Ping timeout)
[12:21:02] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[12:30:59] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Ping timeout)
[12:33:52] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[12:38:13] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[12:40:31] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Ping timeout)
[12:41:16] *** Quits: jensnockert (jensnocker@moz-5C7F2150.setothd.dyn.perspektivbredband.net) (Input/output error)
[12:54:43] *** Quits: berak (chatzilla@875EAED4.6062171A.1A5CC7E5.IP) (Ping timeout)
[12:55:49] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[12:55:53] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[12:56:11] *** Joins: dylukes (dylukes@moz-5EF8B0CF.hfc.comcastbusiness.net)
[12:56:52] *** Quits: dylukes (dylukes@moz-5EF8B0CF.hfc.comcastbusiness.net) (Quit: ["Textual IRC Client: www.textualapp.com"])
[12:57:38] *** Joins: berak (chatzilla@875EAED4.6062171A.1A5CC7E5.IP)
[12:59:00] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[13:07:24] *** Joins: micrypt (micrypt@moz-A42A6DC5.eu-west-1.compute.amazonaws.com)
[13:12:19] *** Joins: bjz (brendanzab@moz-C1DF04F7.lns8.woo.bigpond.net.au)
[13:14:11] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[13:14:11] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/6Y0oxQ
[13:14:11] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[13:16:00] <dbaupp> nmatsakis: ping
[13:16:35] <nmatsakis> dbaupp: pong.
[13:17:13] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[13:17:13] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/PPB5eQ
[13:17:13] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[13:17:17] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[13:17:17] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/MHNeeg
[13:17:17] <ghrust> 13rust/06auto 141813ab5 15ILyoan: testsuite: update a test for #4350
[13:17:17] <ghrust> 13rust/06auto 1437becd8 15bors: auto merge of #6321 : ILyoan/rust/test4350, r=z0w0
[13:17:17] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[13:17:35] <dbaupp> nmatsakis: https://github.com/mozilla/rust/pull/6267 is xfailing the windows tests correct there?
[13:17:45] *** Joins: saml (sam@moz-14C16814.cst.lightpath.net)
[13:18:38] <nmatsakis> dbaupp: lemme loook...seems...unlikely
[13:18:47] *** Joins: sk (sk@199EC8B2.57A579BA.78DD174B.IP)
[13:19:43] <dbaupp> nmatsakis: yeah... the tests pass perfectly fine on my computer (linux)... :S
[13:20:13] <nmatsakis> dbaupp: actually, given the failures, it is... not wrong exactly.
[13:20:21] <nmatsakis> this is a fixable problem with the xfail-fast
[13:20:24] <nmatsakis> but I think it'd be a separate patch to fix it
[13:20:35] <nmatsakis> the problem seems to be that xfail-fast is not issuing a "use core" at the root of the generated file,
[13:20:44] <nmatsakis> and the deriving code is not hygienic, and hence relies on that
[13:20:56] <nmatsakis> (I kind of think `use core` ought to be in the prelude)...
[13:21:20] <nmatsakis> dbaupp: I think what I'd rather do is open a FIXME bug relating to this problem and xfail-fast them with the issue #
[13:21:28] <nmatsakis> dbaupp: as a rule I think we should never xfail-fast without an issue #
[13:21:37] <nmatsakis> dbaupp: or xfail-test 
[13:21:40] <nmatsakis> dbaupp: (though of course we do it all the time)
[13:21:50] <nmatsakis> or at least a comment saying why :)
[13:22:00] <nmatsakis> let me comment on the PR
[13:22:28] <nmatsakis> dbaupp: not sure if you are familiar with the `fastcheck` thing or why it is so problematic
[13:23:43] <dbaupp> nmatsakis: not much at all... I think I vaguely heard that it builds the whole thing into a single executable for performance?
[13:24:08] <nmatsakis> dbaupp: yeah it basically makes a single gigantic rs file which concatenates each of the other rs files as a separate module
[13:24:19] <nmatsakis> dbaupp: this does not play so well with our resolution rules that `use` is always relative to the crate
[13:24:46] <nmatsakis> dbaupp: I think the main reason we haven't fixed it is that we want to remove it anyhow
[13:25:14] <dbaupp> nmatsakis: oooooh yuck
[13:25:26] <bjz> nmatsakis: https://github.com/mozilla/rust/issues/6037#issuecomment-17603623
[13:25:30] <dbaupp> nmatsakis: windows seems to get in the way of a lot of things sometimes
[13:26:00] <dbaupp> nmatsakis: I'll open an issue and update those tests
[13:26:18] <nmatsakis> bjz: we should allow the leading `|` in match as well...
[13:26:28] <nmatsakis> bjz: O'Caml does and it is nice.
[13:26:40] *** bhearsum is now known as bhearsum|bbiab
[13:27:08] <nmatsakis> dbaupp: are you huonw?
[13:27:12] <bjz> nmatsakis: how would that work? when you want a predicate instead of a pattern?
[13:27:15] <dbaupp> nmatsakis: yes
[13:27:18] <nmatsakis> dbaupp: ok :)
[13:27:44] <nmatsakis> bjz: no no, I just meant as a general thing. Like right now you write: "match foo { X() | Y() => { ... } }"
[13:27:57] <nmatsakis> bjz: but it'd be kind of nice if you could write "match foo { | X() | Y() => { ... } }"
[13:28:14] <nmatsakis> bjz: precisely because when you put those on separate lines, you eliminate the question of "where does the | go"?
[13:28:24] <bjz> ahhh
[13:28:26] <bjz> yup
[13:28:37] <nmatsakis> bjz: and it reads nicely: every line that begins with | is a pattern
[13:28:44] <bjz> also for tuples? (blah, blah,) ?
[13:29:02] *** Joins: jensnockert (jensnocker@moz-5C7F2150.setothd.dyn.perspektivbredband.net)
[13:29:28] <nmatsakis> bjz: I think we allow that today?
[13:29:54] <nmatsakis> we try to allow for trailing separates
[13:29:55] <bjz> ooh, really?
[13:29:56] <nmatsakis> *separators
[13:30:04] <nmatsakis> to avoid diff hazards
[13:30:08] <bjz> ok, gotta update this then: https://github.com/mozilla/rust/blob/incoming/src/libcore/num/f64.rs#L636
[13:30:20] <bjz> it looks less bad when stacking too
[13:30:48] <rroels> Is there a clean way of looping X times? u8::range(0, 52) |i| { } gives warnings if you don't actually need/use i
[13:30:50] <rroels> And a while loop where you have to update the counter yourself is kinda lame imho
[13:31:16] <bjz> rroels: 52.times
[13:31:30] <nmatsakis> rroels: u8::range(0, 52) |_| { } is my preferred way, but there is also 52.times
[13:31:38] <dbaupp> nmatsakis: https://github.com/mozilla/rust/issues/6330
[13:31:44] <rroels> sweet, learned something new
[13:31:46] <rroels> thanks
[13:31:58] <bjz> rroels: a leading _ suppresses all unused variable warnings
[13:32:03] <nmatsakis> dbaupp: looks great.
[13:32:20] <rroels> bjz: cool, TIL
[13:32:29] *** Quits: webber46 (webber46@moz-AC14FDEA.se) (Quit: webber46)
[13:33:13] <bjz> nmatsakis: so do you think it might be reasonable to add cond! to expand? I don't want to bloat things. But I think it's useful for clarity purposes
[13:33:39] <dbaupp> nmatsakis: updated! r?
[13:35:46] *** Joins: akashj87_ (akash@60CDC30.20412040.35E3DDC8.IP)
[13:36:00] *** Quits: haard (fredrik@18E6EC45.6A26450D.BE04C429.IP) (Ping timeout)
[13:36:09] *** Quits: akashj87 (akash@3170B0A8.373F35FC.35E3DDC8.IP) (Ping timeout)
[13:39:35] <nmatsakis> dbaupp: r+
[13:40:06] <bjz> nmatsakis: I made some updates to my comment - cleaned up some things
[13:40:10] <dbaupp> nmatsakis: thanks :)
[13:40:23] <nmatsakis> bjz: ok, I confess I don't have a terribly strong opinion. It's probably worth adding something like that since I think it'll be a common request.
[13:41:10] <nmatsakis> bjz: I might ... rather make "match () { if cond => ... }" be syntactic sugar for "match () { () if cond => ... } ", but then I guess in general having macros over complex syntax is preferable
[13:41:25] <nmatsakis> bjz: and maybe "match ()" is kind of hokey
[13:41:36] * nmatsakis shrugs
[13:41:37] <bjz> nmatsakis: it feels like a hack
[13:42:16] <nmatsakis> bjz: yeah, maybe. I guess I'd... rather have cond! than allow you to omit the expression in match, just because that seems likely to lead to confusing error messages.
[13:42:32] <bjz> nmatsakis: yup
[13:43:04] <bjz> nmatsakis: I've come across this several times before, that's why I'm pushing for it
[13:43:15] <nmatsakis> bjz: yeah, it's a common feature request, so I'm in favor of adding some sort of cond! macro
[13:44:04] <bjz> nmatsakis: I have it implemented on a branch I've just got to run the tests
[13:44:19] <bjz> nmatsakis: I'll r? graydon though
[13:44:32] <nmatsakis> bjz: I imagine there may be some bikeshedding as to cond!(if cond =>) vs cond!(| cond =>)
[13:44:41] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Connection reset by peer)
[13:44:53] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[13:45:01] <nmatsakis> bjz: does your macro allow you to write cond!(| x == 3 | y == 4)? I guess that can't work, it's ambiguous.
[13:45:11] <bjz> it does
[13:45:18] <bjz> oh wait
[13:45:20] <bjz> no
[13:45:23] <nmatsakis> bjz: I meant cond!(| x == 3 | y == 4 => value)
[13:45:51] <nmatsakis> that doesn't really make much sense
[13:46:03] <nmatsakis> just wondering because the use of | looks a lot like what appears in match statements
[13:46:05] <bjz> that's cond!(| x == 3 || y == 4 { value })
[13:46:11] <nmatsakis> right, you can always write it this way
[13:46:14] <nmatsakis> it just doesn't format as nicely
[13:46:18] <nmatsakis> if you move x == 3 and y== 4 to separate lines
[13:46:18] <bjz> yeah
[13:46:20] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[13:46:31] <bjz> that is an issue
[13:46:37] <nmatsakis> bjz: it does require `=>`, right?
[13:46:38] *** Joins: haard (fredrik@F3248749.C2E49760.92AEF337.IP)
[13:46:39] <nmatsakis> or not
[13:46:46] *** Joins: EXetoC (ex@moz-2DBEB1E4.customer.t3.se)
[13:47:14] <nmatsakis> let me look at the macro again :)
[13:47:17] <bjz> no it doesn't. I ammended my comment to say that => can be confusing with ==, <=, >=
[13:47:21] <bjz> sure
[13:47:22] <nmatsakis> ah
[13:48:21] *** Quits: akashj87_ (akash@60CDC30.20412040.35E3DDC8.IP) (Quit: Leaving)
[13:48:22] <bjz> yeah I'm not sure cond!(| x == 3 | y == 4 {}) would work, as it expects an expr
[13:48:45] *** Quits: sk (sk@199EC8B2.57A579BA.78DD174B.IP) (Quit: Leaving)
[13:48:55] <nmatsakis> it can't work, right
[13:49:02] <bjz> I could do double bars, but then the underscore is hard to format
[13:49:08] <nmatsakis> it's fine, I was just musing
[13:49:08] <bjz> :P
[13:49:20] <bjz> no, it's a good question
[13:49:57] * bjz likes having his code neat, so he empathises
[13:50:28] *** Quits: haard (fredrik@F3248749.C2E49760.92AEF337.IP) (Ping timeout)
[13:51:45] <dbaupp> has there been a recent change that meant that `unsafe`-ty isn't being checked properly?
[13:52:20] <dbaupp> (I was told I had an unnecessary unsafe block with `unsafe { vector.unsafe_get(i) }`)
[13:52:58] <nmatsakis> dbaupp: it's plausible I broke that with my borrowck changes...or at least broke the code that checks whether unsafe is needed.
[13:53:15] <nmatsakis> dbaupp: can you make a small test case?
[13:53:29] <nmatsakis> (clearly one is missing)
[13:54:23] *** Joins: sk (sk@199EC8B2.57A579BA.78DD174B.IP)
[13:54:33] <dbaupp> nmatsakis: `fn main() { unsafe { (~[]).unsafe_get(1) } }`
[13:54:50] <dbaupp> unsafe.rs:1:12: 1:42 warning: unnecessary `unsafe` block
[13:54:51] <dbaupp> unsafe.rs:1 fn main() { unsafe { (~[]).unsafe_get(1) } }
[13:55:10] <nmatsakis> rusti: fn main() { unsafe { (~[]).unsafe_get(1) } }
[13:55:12] <rusti> more than 5 lines of output, pastebinned: http://sprunge.us/CEgd
[13:55:23] * nmatsakis wonders how frequently rusti is recompiled
[13:55:26] <dbaupp> rusti: unsafe { (~[]).unsafe_get(1) }
[13:55:27] <rusti> line longer than 100 columns, pastebinned: http://sprunge.us/WEWG
[13:55:39] <dbaupp> :(
[13:55:44] <nmatsakis> dbaupp: interesting...
[13:56:00] <nmatsakis> rusti: (~[]).unsafe_get(1)
[13:56:00] <dbaupp> rusti: unsafe { (~[1i,2]).unsafe_get(1) }
[13:56:03] <rusti> line longer than 100 columns, pastebinned: http://sprunge.us/CCfM
[13:56:03] <rusti> more than 5 lines of output, pastebinned: http://sprunge.us/QREM
[13:56:17] <dbaupp> (type inference?)
[13:56:23] <nmatsakis> presumably, interesting that it ICE'd
[13:56:40] <nmatsakis> rusti: (~[1i,2]).unsafe_get(1)
[13:56:41] <rusti> 2
[13:56:47] <nmatsakis> huh. ok, something's clearly broken.
[13:56:57] <dbaupp> rusti: fmt!("%?", (~[]).unsafe_get(1))
[13:56:57] <nmatsakis> gotta fix THAT
[13:56:58] <rusti> line longer than 100 columns, pastebinned: http://sprunge.us/ZZWW
[13:57:48] * nmatsakis files an issue
[13:58:30] <dbaupp> nmatsakis: on a slightly older incoming build, the ICE gives: `internal compiler error: Autoderef but type not derefable: [type error]`
[13:59:12] <nmatsakis> dbaupp: ok.
[13:59:17] <dbaupp> same as https://github.com/mozilla/rust/issues/5062
[14:00:23] <nmatsakis> oh
[14:00:46] <nmatsakis> dbaupp: https://github.com/mozilla/rust/issues/6331
[14:00:51] <nmatsakis> I sort of remember seeing some issue about method unsafety
[14:00:56] <nmatsakis> now that you mentio nit
[14:01:08] <nmatsakis> yes, https://github.com/mozilla/rust/issues/3080
[14:01:42] <nmatsakis> wow, 9 months. embarassing.
[14:01:48] <nmatsakis> I'll fix that...
[14:02:33] <dbaupp> nmatsakis: https://github.com/mozilla/rust/pull/6332 r?
[14:03:04] <dbaupp> nmatsakis: oh, so it's "just" not implemented, rather than being recently broken?
[14:03:14] *** Joins: dan_johnsin (dan_johnsi@6902762D.11B071D.FB9A45AF.IP)
[14:03:18] <dbaupp> rusti: unsafe fn f() {} f()
[14:03:20] <rusti> more than 5 lines of output, pastebinned: http://sprunge.us/dLUR
[14:03:21] <nmatsakis> dbaupp: I guess? I thought I had fixed that
[14:04:00] *** Quits: jviereck1 (Adium@moz-A2DCE0DD.dclient.hispeed.ch) (Quit: Leaving.)
[14:04:01] <nmatsakis> dbaupp: r+
[14:04:09] <dbaupp> nmatsakis: thanks :)
[14:04:34] <dbaupp> bjz: I broke one of your `cond!` examples https://github.com/mozilla/rust/pull/6332 :P
[14:04:38] *** Joins: jviereck (Adium@moz-A2DCE0DD.dclient.hispeed.ch)
[14:05:08] <bjz> poo
[14:05:10] <bjz> :P
[14:05:13] <bjz> oh wells
[14:05:26] <bjz> much nicer anyway
[14:05:27] <bjz> :)
[14:05:36] *** Quits: jviereck (Adium@moz-A2DCE0DD.dclient.hispeed.ch) (Quit: Leaving.)
[14:06:48] *** Joins: jviereck (Adium@moz-A2DCE0DD.dclient.hispeed.ch)
[14:08:07] *** Quits: jensnockert (jensnocker@moz-5C7F2150.setothd.dyn.perspektivbredband.net) (Input/output error)
[14:08:35] *** Quits: jviereck (Adium@moz-A2DCE0DD.dclient.hispeed.ch) (Quit: Leaving.)
[14:13:44] *** Joins: sammykim_ (sammykim__@48AEBDE2.ACF655DA.97B9B372.IP)
[14:17:45] *** Quits: cdidd (cdidd@moz-8884680.broadband.corbina.ru) (Input/output error)
[14:21:41] *** Joins: webber46 (webber46@moz-F6310FF0.lha.sgsnet.se)
[14:23:22] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[14:23:22] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/MHNeeg
[14:23:22] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[14:26:12] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[14:26:12] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/hXJJlw
[14:26:12] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[14:26:15] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[14:26:15] <ghrust> 01[13rust01] 15bors pushed 6 new commits to 06auto: 02http://git.io/_YqS0Q
[14:26:15] <ghrust> 13rust/06auto 14b20eb97 15Huon Wilson: libsyntax: extend generic deriving code to handle almost all possible traits....
[14:26:15] <ghrust> 13rust/06auto 141cf2108 15Huon Wilson: libsyntax: convert #[deriving(IterBytes)] to generic deriving
[14:26:17] <ghrust> 13rust/06auto 145e1d6c2 15Huon Wilson: libsyntax: add #[deriving(Rand, ToStr)]....
[14:26:18] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[14:27:54] *** Quits: sammykim_ (sammykim__@48AEBDE2.ACF655DA.97B9B372.IP) (Connection reset by peer)
[14:29:15] *** Quits: int3_ (int3_@moz-98676091.subnet-248.amherst.edu) (Client exited)
[14:30:19] <bjz> best commit title ever sammykim: https://github.com/mozilla/rust/commit/356ebe879276c5627d6010fce9dc8b054165e17b
[14:32:22] *** Quits: heftig (heftig@moz-C8CBE7BC.dip0.t-ipconnect.de) (Quit: Quitting)
[14:32:34] *** Joins: jviereck (Adium@moz-A2DCE0DD.dclient.hispeed.ch)
[14:33:30] *** Joins: heftig (heftig@moz-C8CBE7BC.dip0.t-ipconnect.de)
[14:33:42] *** Joins: lmandel (lmandel@FE1F74.86ED00A7.971E19F6.IP)
[14:35:26] <bjz> doomlord: might be of interest to you: https://github.com/mozilla/rust/pull/6296
[14:35:50] *** Joins: jorendorff (jorendorff@moz-1747FB68.hsd1.tn.comcast.net)
[14:36:14] <bjz> doomlord: i'd like the perspective of a 'high performance graphics fellow'
[14:36:18] *** Joins: Scriptor (historium@moz-E06F46F0.corp.bitshelter.com)
[14:36:22] *** Joins: int3_ (int3_@9A375198.26321F00.F7721B25.IP)
[14:37:43] *** Quits: zakora (NC@moz-8EAF945F.fbx.proxad.net) (Quit: Computer has gone to sleep.)
[14:38:33] *** Joins: zakora (NC@moz-8EAF945F.fbx.proxad.net)
[14:38:33] *** Quits: zakora (NC@moz-8EAF945F.fbx.proxad.net) (Max SendQ exceeded)
[14:39:00] *** Joins: zakora (NC@moz-8EAF945F.fbx.proxad.net)
[14:39:12] *** Quits: zakora (NC@moz-8EAF945F.fbx.proxad.net) (Quit: Computer has gone to sleep.)
[14:39:53] *** Parts: cc (cc@moz-9962C9F4.rev.numericable.fr) ()
[14:47:25] *** Quits: int3_ (int3_@9A375198.26321F00.F7721B25.IP) (Ping timeout)
[14:49:09] *** Joins: int3_ (int3_@9A375198.26321F00.F7721B25.IP)
[14:49:23] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[14:50:53] *** Quits: fabiand (fabiand@moz-53800E1C.adsl.alicedsl.de) (Quit: Verlassend)
[14:50:57] *** Joins: Yurume_ (yurume@AC58A8CE.8A059B47.E313B915.IP)
[14:51:26] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[14:52:44] *** Quits: Yurume_ (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[14:53:43] *** Quits: judder (maradukewa@DABDEEA3.F2C0D0AC.78E362FE.IP) (Ping timeout)
[14:54:19] *** Quits: int3_ (int3_@9A375198.26321F00.F7721B25.IP) (Ping timeout)
[14:54:46] *** Joins: thou (thou@moz-1C1CA9F7.fasttrackcomm.net)
[14:55:27] *** Joins: int3_ (int3_@9A375198.26321F00.F7721B25.IP)
[14:58:38] *** Quits: paulproteus (quassel@rose.makesad.us) (Ping timeout)
[14:59:37] *** Joins: paulproteus (quassel@moz-E86A3B42.makesad.us)
[15:03:44] *** Joins: mdu (mdu@moz-9962C9F4.rev.numericable.fr)
[15:04:28] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[15:08:48] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Client exited)
[15:10:18] <doomlord> bjz - thanks for the link i'l  take a look
[15:10:49] *** bhearsum|bbiab is now known as bhearsum
[15:10:59] <bjz> doomlord: I haven't got a good grasp of this stuff yet, so I need help :)
[15:15:16] <doomlord> i like approx_eq taking an epsilon
[15:15:41] <doomlord> most code i've written i've avoided comapring floats for equality so much... but it does happen
[15:15:59] <doomlord> near to zero is more common (eg avoiding divide by zero cases)
[15:16:00] <bjz> doomlord: approx_eq was already there
[15:16:17] <doomlord> ok so its a new function approx_eq_eps ?
[15:16:24] <bjz> doomlord: aye
[15:16:34] <doomlord> fair enough
[15:16:40] *** Quits: wunki (wunki@moz-7300E3D6.ip.prioritytelecom.net) (Ping timeout)
[15:16:55] <bjz> doomlord: as in, I moved FuzzyEq from std into core, and renamed it to ApproxEq
[15:16:56] <doomlord> (c++ would just overload it but you need a new function name i gather)
[15:17:02] <bjz> yeah :(
[15:17:17] <doomlord> which has its + and - points. easier to search.
[15:17:21] <bjz> it's more the algorithm I'm concerned with
[15:17:55] <bjz> the discussion about the edge-cases, and how they affect performance
[15:17:57] <doomlord> one thing i'll say is i've usually compared a squared difference with epsilon-squared
[15:18:18] *** Joins: Blub\w (wry@moz-1D8D58C3.wireless.dyn.drei.com)
[15:18:33] <doomlord> having said that though there's probably not much in it, fabs might be widely available
[15:19:00] <doomlord> also, for me at least code that does 3 things based on a range test is more common too..
[15:19:26] <doomlord> eg..   diff=a-b;   if (diff<-epsilon) {   } else if diff<+epsilon { .... } else { ..... }
[15:19:44] <doomlord> .. but that doesn't negate the value of "approx_eq_eps" being there at all. its still useful
[15:20:38] <doomlord> ah yes. approximately zero comes up from a vector length squared, so its known its >0
[15:20:47] <ssbr> I like the idea of an approximate equality trait to begin with
[15:21:04] <bjz> ssbr: it's already there
[15:21:15] <ssbr> do you know how annoying it is to write test cases with floats in compound datastructures in even a language that supports approximate comparisons among floats, like python?
[15:21:22] <ssbr> it's stupid
[15:21:32] <bjz> the issue is over this: https://github.com/mozilla/rust/pull/6296
[15:21:37] <ssbr> bjz: right, that's what I mean
[15:21:38] <ssbr> it's awesome
[15:21:48] <bjz> ssbr: also note that we have assert_appox_eq!
[15:21:49] <ssbr> the rest is details <_<
[15:21:57] <bjz> added by yours truley
[15:22:01] <ssbr> thank you :>
[15:22:07] <ssbr> (now document it D:<)
[15:22:07] *** Joins: SiegeLord (sl@moz-56D7E78.bstnma.fios.verizon.net)
[15:22:26] <bjz> https://github.com/mozilla/rust/pull/6263
[15:22:29] <bjz> yeah
[15:22:41] <bjz> not sure where to add documentation for it
[15:22:49] <ssbr> there is nowhere
[15:22:56] <ssbr> none of the assert_* macros are documented :(
[15:22:59] <ssbr> assert*
[15:23:02] <bjz> yah
[15:23:10] *** zz_kimundi is now known as kimundi
[15:23:19] <bjz> maybe we should add a doc for 'included macros'
[15:23:38] * bjz wishes macros were in a better state
[15:24:05] <bjz> if macros couls be exported from core, and have doc comments, then we'd be in a much ahppier place
[15:24:13] <bjz> *could
[15:24:26] *** Joins: ksev (DrunkenPan@D30D3973.D5A563EE.47C41102.IP)
[15:24:33] <ssbr> yes
[15:24:41] <ssbr> I don't think that's so hard in principle, is it?
[15:24:54] <bjz> pauls pauls_: ^ :]
[15:25:03] <ssbr> did I say something bad :(
[15:25:06] <bjz> z0w0: ^
[15:25:13] <ssbr> stop pinging people with my ignorant comment
[15:25:14] <bjz> (no, haha)
[15:25:18] <ssbr> you're making me feel self-conscious
[15:25:22] <pauls_> I think that exportable macros are definitely going to happen... someday.
[15:25:29] <bjz> I was pointing to my comment
[15:25:35] <bjz> pauls_: :)
[15:25:36] <ssbr> I was thinking you can have the macro AST dumped as part of crate metadata, and then it's just a matter of actually loading it and so on
[15:25:36] <pauls_> Doc comments for them would be tricky.
[15:25:47] <ssbr> in principle
[15:26:08] <kimundi> ssbr: The problem is that macros are not as integrated in the rust source as a mod, fn etc.
[15:26:20] <pauls_> I don't remember though, it might not be that bad.
[15:26:21] <bjz> pauls_: I am currently adding one to expand.rs - so it's in the front of my mind
[15:26:38] <ssbr> kimundi: the rust source?
[15:26:39] <pauls_> When my wrists are better, I'll be contributing again, and I'll know more about what's going on.
[15:26:50] <bjz> pauls_: :( RSI?
[15:26:52] <pauls_> (and they are getting better! just slowly)
[15:26:54] <pauls_> Yeah.
[15:27:01] <bjz> stay healthy man
[15:27:12] <bjz> sorry for being a winger :)
[15:28:45] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[15:28:56] <kimundi> ssbr: Err, what I mean is all top level items in a source file. Like 'mod', 'fn', 'use' etc. They are called items. The problem is that macros are not implemented as items they're different. hence you can'T import/export them, they used to ignore scoping until recently etc.
[15:29:33] <kimundi> Annd it also means you can'T attach attributes to them, and hence also not docs
[15:29:52] <ssbr> kimundi: Surely, then, the answer is to make them items (and to make macro_rules! a macro that expands to said item)?
[15:31:11] <kimundi> ssbr, I don't know the exact implementation details that lead to them being differnt. pauls_ would have to answer that :)
[15:34:15] *** Quits: int3_ (int3_@9A375198.26321F00.F7721B25.IP) (Client exited)
[15:38:12] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[15:38:12] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/_YqS0Q
[15:38:12] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[15:38:20] *** Quits: ksev (DrunkenPan@D30D3973.D5A563EE.47C41102.IP) (Ping timeout)
[15:41:14] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[15:41:14] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/IxNthg
[15:41:14] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[15:41:15] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[15:41:15] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/bvaFzQ
[15:41:15] <ghrust> 13rust/06auto 1480061ec 15Brian Anderson: rt: Remove rust_call_nullary_fn...
[15:41:15] <ghrust> 13rust/06auto 14b21f37c 15bors: auto merge of #6323 : brson/rust/nullary, r=thestinger...
[15:41:15] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[15:43:22] *** Joins: ksev (DrunkenPan@D30D3973.D5A563EE.47C41102.IP)
[15:43:36] *** Joins: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se)
[15:45:27] *** Joins: lkuper (lkuper@moz-D6AAFF3.cs.indiana.edu)
[15:46:38] *** Joins: zakora (NC@moz-8EAF945F.fbx.proxad.net)
[15:46:38] *** Quits: zakora (NC@moz-8EAF945F.fbx.proxad.net) (Max SendQ exceeded)
[15:47:08] *** Joins: zakora (NC@moz-8EAF945F.fbx.proxad.net)
[15:47:26] *** Joins: int3_ (int3_@moz-CCE06A4A.subnet-248.amherst.edu)
[15:48:46] *** Quits: MX80 (MX80@moz-32BE33CD.dsl.g3telecom.net) (Ping timeout)
[15:50:15] *** Joins: FluffySauce (textual@moz-E5BC5F6F.sea.popcap.com)
[15:50:57] *** kimundi is now known as zz_kimundi
[15:52:15] *** Joins: MX80 (MX80@moz-32BE33CD.dsl.g3telecom.net)
[15:52:48] <bjz> nmatsakis: I r?ed graydon, but here's my PR https://github.com/mozilla/rust/pull/6333
[15:59:28] <TD-Linux> is the format of crates defined anywhere?
[16:01:41] *** Quits: lkuper (lkuper@moz-D6AAFF3.cs.indiana.edu) (Quit: Leaving)
[16:01:50] *** Joins: lkuper (lkuper@moz-D6AAFF3.cs.indiana.edu)
[16:01:50] <TD-Linux> whoops nvm
[16:02:02] *** Joins: dherman (dherman@2557E599.66715431.D25A875A.IP)
[16:02:02] *** ChanServ sets mode: +o dherman
[16:02:23] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[16:07:21] *** Quits: trapni (trapni@moz-6A0EA166.dawanda.com) (Quit: Leaving)
[16:08:47] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[16:11:28] *** Quits: dbaupp (Thunderbir@moz-7D1EB5E8.lns20.syd6.internode.on.net) (Ping timeout)
[16:13:03] *** Quits: busylizzy (lisa@85228838.12D0DC84.211374C4.IP) (Ping timeout)
[16:15:24] *** Joins: bent (chatzilla@moz-BE33DA21.fw1.sfo1.mozilla.net)
[16:16:20] *** Quits: int3_ (int3_@moz-CCE06A4A.subnet-248.amherst.edu) (Client exited)
[16:20:39] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[16:21:01] *** Joins: echristo (echristo@CFC3C6C3.D6CCE4AE.77834EAA.IP)
[16:22:47] *** Joins: busylizzy (lisa@85228838.12D0DC84.211374C4.IP)
[16:23:04] *** Quits: Ralith (ralith@moz-50F3C77.vc.shawcable.net) (Ping timeout)
[16:24:41] *** Joins: Jesse (jruderman@moz-BE33DA21.fw1.sfo1.mozilla.net)
[16:24:57] *** Joins: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net)
[16:25:04] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Ping timeout)
[16:28:51] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[16:30:10] *** Joins: jclements (jclements@2557E599.66715431.D25A875A.IP)
[16:30:15] *** Quits: EXetoC (ex@moz-2DBEB1E4.customer.t3.se) (Quit: WeeChat 0.4.0)
[16:36:32] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[16:36:42] *** Quits: pyrac (pyrac@moz-516480D0.w92-156.abo.wanadoo.fr) (Ping timeout)
[16:36:55] *** Joins: pyrac (pyrac@moz-516480D0.w92-156.abo.wanadoo.fr)
[16:38:16] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[16:39:51] *** Joins: EXetoC (ex@moz-2DBEB1E4.customer.t3.se)
[16:39:52] *** Quits: EXetoC (ex@moz-2DBEB1E4.customer.t3.se) (Quit: EXetoC)
[16:40:27] *** Quits: jviereck (Adium@moz-A2DCE0DD.dclient.hispeed.ch) (Quit: Leaving.)
[16:43:24] *** Quits: ssbr_ (ssbr@A9D9D38C.B6F034AC.72A31D6.IP) (Ping timeout)
[16:43:25] *** Joins: vosen (vosen@moz-266BA656.icpnet.pl)
[16:43:36] *** zz_kimundi is now known as kimundi
[16:44:04] *** Quits: inolen (Adium@moz-FA2406D8.socal.res.rr.com) (Quit: Leaving.)
[16:45:04] *** Joins: Ralith (ralith@moz-95DA29C.wireless.sfu.ca)
[16:46:34] *** Quits: Blub\w (wry@moz-1D8D58C3.wireless.dyn.drei.com) (Ping timeout)
[16:46:50] *** Joins: mschifer (Adium@2557E599.66715431.D25A875A.IP)
[16:50:17] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[16:50:17] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/bvaFzQ
[16:50:17] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[16:50:39] *** Joins: EXetoC (ex@moz-2DBEB1E4.customer.t3.se)
[16:53:13] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[16:53:13] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/C91XHA
[16:53:13] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[16:53:16] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[16:53:16] <ghrust> 01[13rust01] 15bors pushed 22 new commits to 06auto: 02http://git.io/LZm6CA
[16:53:16] <ghrust> 13rust/06auto 14a91b55e 15Patrick Walton: libstd: Remove mutable fields from fileinput and net_tcp
[16:53:16] <ghrust> 13rust/06auto 14ba2ce0f 15Patrick Walton: libstd: Remove mutable fields from flatpipes and io_util
[16:53:17] <ghrust> 13rust/06auto 148ff0194 15Patrick Walton: libstd: Remove mutable fields from future and par
[16:53:19] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[16:57:19] *** Joins: Blub\w (wry@moz-7BC9C9D6.wireless.dyn.drei.com)
[16:59:18] *** Joins: pcwalton (pcwalton@43CB6079.66715431.D25A875A.IP)
[16:59:18] *** ChanServ sets mode: +o pcwalton
[16:59:39] *** Joins: doener (doener@moz-121949B3.unitymediagroup.de)
[17:01:50] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[17:02:42] *** Quits: sk (sk@199EC8B2.57A579BA.78DD174B.IP) (Quit: Leaving)
[17:03:00] *** Joins: infynyxx_ (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[17:03:23] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[17:03:48] *** Joins: jgilbert (jgilbert@moz-E7782931.hsd1.ca.comcast.net)
[17:04:35] *** Quits: pcwalton (pcwalton@43CB6079.66715431.D25A875A.IP) (Quit: pcwalton)
[17:05:38] *** Joins: pcwalton (pcwalton@43CB6079.66715431.D25A875A.IP)
[17:05:38] *** ChanServ sets mode: +o pcwalton
[17:07:48] *** Quits: LimeBurst (me@247D1419.D73964AC.27A8748.IP) (Quit: leaving)
[17:08:18] *** Joins: ssbr_ (ssbr@moz-BB1842E5.wireless.utoronto.ca)
[17:13:47] *** Quits: RMF (RMF@moz-52793E40.dsl.telepac.pt) (Connection reset by peer)
[17:13:50] <nmatsakis> bjz: ok.
[17:15:12] *** Quits: mdu (mdu@moz-9962C9F4.rev.numericable.fr) (Quit: mdu)
[17:19:49] *** Joins: LimeBurst (me@247D1419.D73964AC.27A8748.IP)
[17:22:05] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[17:24:31] *** Quits: Ralith (ralith@moz-95DA29C.wireless.sfu.ca) (Ping timeout)
[17:24:39] *** Joins: qerub (qerub@E4D98B3D.A417A335.DF3C7188.IP)
[17:25:08] *** Quits: ksev (DrunkenPan@D30D3973.D5A563EE.47C41102.IP) (Ping timeout)
[17:25:58] *** Joins: Ralith (ralith@moz-95DA29C.wireless.sfu.ca)
[17:26:41] *** Joins: int3_ (int3_@moz-34B610F6.subnet-248.amherst.edu)
[17:26:41] *** Joins: graydon (Adium@A5087023.2354C43D.D8E68FF6.IP)
[17:26:41] *** ChanServ sets mode: +qo graydon graydon
[17:26:48] *** Joins: RMF (RMF@moz-52793E40.dsl.telepac.pt)
[17:27:20] *** Joins: jviereck (Adium@moz-340574DC.dclient.hispeed.ch)
[17:28:26] *** Quits: int3_ (int3_@moz-34B610F6.subnet-248.amherst.edu) (Ping timeout)
[17:30:24] <graydon> hm hm
[17:30:31] *** Quits: Diablo-D3 (diablo@moz-F06B3F31.port.east.myfairpoint.net) (Ping timeout)
[17:30:35] <graydon> curious symptom in rebased gc:
[17:30:43] <graydon> "uses all system memory during parsing and invokes OOM-killer"
[17:30:48] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[17:30:52] *** Joins: Diablo-D3 (diablo@moz-F06B3F31.port.east.myfairpoint.net)
[17:31:07] <graydon> I'm impressed we can even _leak_ that much. if that's indeed what's happening.
[17:32:42] *** Quits: jviereck (Adium@moz-340574DC.dclient.hispeed.ch) (Quit: Leaving.)
[17:33:17] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Quit: Computer has gone to sleep.)
[17:33:27] *** Quits: CarpNet (ac@moz-FD24B77.sohonet.co.uk) (Quit: Leaving)
[17:33:35] *** Quits: z0w0 (zack@moz-1F110DD8.lnse2.woo.bigpond.net.au) (Quit: Leaving.)
[17:33:40] <benh> hm, when you have an unsafe pointer p and move out of *p, p is a partially moved value and can't be used again
[17:34:03] <benh> is that by design? "move out of *p, libc::free(p)" seems like a reasonably safe patterns as these things go in unsafe{}-land
[17:34:56] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[17:34:56] *** ChanServ sets mode: +o brson
[17:34:58] <benh> I guess the ffi tutorial swaps a new value instead
[17:35:18] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[17:35:18] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14ce43d03 to 14b21f37c: 02http://git.io/N3iJvQ
[17:35:18] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[17:35:22] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[17:35:22] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/LiWxMw
[17:35:22] <ghrust> 13rust/06auto 143532350 15Zack Corr: Add #[cfg(debug)] flag to rust suite compilation. Closes #3068
[17:35:22] <ghrust> 13rust/06auto 14270b508 15bors: auto merge of #6326 : z0w0/rust/cfg-debug, r=yichoi
[17:35:22] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[17:35:28] *** Quits: qerub (qerub@E4D98B3D.A417A335.DF3C7188.IP) (Quit: qerub)
[17:36:10] <pcwalton> aww come on
[17:37:05] <graydon> ?
[17:37:13] <strcat> benh: swapping in an 'uninit' value would be faster than moving atm
[17:37:16] <strcat> because moving zeroes
[17:37:29] <strcat> LLVM will optimize away an uninit swap to a copy
[17:37:30] <otters> I don't think anyone saw my issue :<
[17:37:30] <pcwalton> grrrrr
[17:37:39] <pcwalton> demuting and demoding bitrotted due to stuff landing
[17:37:40] <strcat> need an uninit intrinsic :)
[17:37:43] <otters> I feel like there's a simple reason this is happening https://github.com/mozilla/rust/issues/6274
[17:37:47] <otters> can I work around it?
[17:37:49] * pcwalton is tempted to suggest that we close the tree
[17:37:51] *** Joins: inolen (Adium@moz-9F4F17DF.tourcaster.com)
[17:38:00] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[17:38:16] <graydon> pcwalton: p=9999 doesn't cut it?
[17:38:39] <graydon> happy to suspend bors for a bit to give you rebase-time if you need it
[17:39:13] <graydon> (if bors was really smart it'd auto-prioritize changes by size?)
[17:39:15] <benh> strcat: Oh, I didn't realize it zeroed. I really need to learn to read assembly. :(
[17:40:04] <strcat> anyway I have to go find all the cases breaking the mutability rules and mark them with #[mutable] so we can use llvm.invariant ;p
[17:41:23] <strcat> tricky with moves I guess
[17:41:33] <strcat> but at least it could be used on &
[17:42:03] <benh> What does #[mutable] do? Uninherited mutability with less enticing syntax than mut fields?
[17:42:14] <strcat> it just makes them not Const
[17:42:22] <strcat> still up to the type to be safe
[17:42:23] <benh> oh
[17:42:39] <strcat> doesn't change borrowck rules or anything
[17:43:17] <graydon> strcat: if "breaking mutability rules without #[mutable]" is going to imply "bad codegen", I suggest rethinking..
[17:43:58] <graydon> unsafe { } is frequently about breaking mutability rules. maybe turn off llvm.invariant in functions that use unsafe { } as well?
[17:44:30] <strcat> graydon: would need to turn it off everywhere
[17:44:36] <graydon> hmm
[17:44:36] *** Joins: mdu (mdu@moz-9962C9F4.rev.numericable.fr)
[17:44:41] <strcat> can't go llvm.invariant -> non-invariant and change it with unsafe {}
[17:44:57] <Jeaye> R[ob]ust ^_^
[17:44:59] <graydon> I guess I don't understand the implications
[17:45:05] <strcat> graydon: if we want alias analysis at all we have to enforce the rules
[17:45:10] <strcat> it won't be enforced for *
[17:45:35] <strcat> mostly because the stdlib abuses * a lot and doesn't use *mut ;\
[17:45:38] <bjz> graydon: https://github.com/mozilla/rust/pull/6333 r?
[17:45:50] *** Joins: skchrko_ (sk@61A494B3.BA40E8A.AAC02D62.IP)
[17:45:54] <bjz> graydon: if you have time
[17:46:14] *** Joins: mib_u7dl4e (Mibbit@moz-3C1CB73C.meshcapital.com)
[17:46:15] <nmatsakis> graydon: I am not sure if unsafe {} is frequently about breaking mutability rules...
[17:46:22] <graydon> strcat: again, I .. would be careful, this sounds like it requires some ML discussion. I would like alias analysis too but if it means "unsafe { ... }" on its own becomes radically-less-safe, I think it's worth rethinking
[17:46:28] <nmatsakis> graydon: ...in fact, I hope that this is...never the case?
[17:46:40] <strcat> graydon: well any sort of TBAA will make unsafe {} less safe
[17:46:40] *** Quits: mib_u7dl4e (Mibbit@moz-3C1CB73C.meshcapital.com) (Quit: http://www.mibbit.com ajax IRC Client)
[17:46:42] <nmatsakis> I know it is now in some cases.
[17:46:50] <strcat> graydon: C has basic type-punning rules
[17:46:57] *** Joins: catpig (catpig@moz-4F520E5D.dip0.t-ipconnect.de)
[17:47:15] <strcat> I don't think it's too much to ask that people respect the same rules they respect in C/C++ inside unsafe {}
[17:47:30] <graydon> understood. and I know this bites C++ programs. real ones. they wind up building with -fno-strict-aliasing and such
[17:47:43] <graydon> right. so .. what are those rules?
[17:47:49] *** Joins: yong (chatzilla@74DA0C97.4E87ADC2.263D9828.IP)
[17:48:03] <graydon> I guess that's what I'm getting at. if someone _is_ going to break mutability rules, I suspect they'll think that writing unsafe { ... } is enough
[17:48:13] <strcat> graydon: well I hope they won't
[17:48:18] <graydon> and if it's not, it seems decidedly odd to require a nonlocal decoration aside from "unsafe { ... }"
[17:48:23] <strcat> breaking the mutability rules means you pretty much need to fully understand borrowck
[17:48:26] <graydon> maybe the unsafe keyword needs a different modification?
[17:48:31] <strcat> and if you do, you'll know it's not a good idea
[17:48:41] <strcat> Cell was unsafe until recently
[17:48:44] <strcat> because the field was pub
[17:48:57] <strcat> I'm sure 99% of the cases where people want to break the rules aren't safe even without AA
[17:49:08] <strcat> the rules are pretty close to a 1:1 match with what is safe
[17:49:43] <strcat> https://github.com/mozilla/rust/blob/incoming/src/libcore/cell.rs cell doesn't ever take &mut to the value inside
[17:49:46] <strcat> which would be unsound
[17:50:11] <graydon> this has turned into a morality argument, which I didn't want to make it
[17:50:16] <graydon> I'm talking mechanism and rules
[17:50:40] <benh> Hm, if you have a & &mut T, you can't borrow the inner pointer out at all?
[17:50:41] <strcat> graydon: well you would have to respect that &mut is a unique handle (which you essentially already do) and that & is a ptr to a frozen object
[17:50:47] <graydon> what are the rules they have to obey, what goes wrong if they get it wrong, and what mechanism can we put in place to make it such that they don't have to write _two_ qualifications-about-the-unsafety?
[17:51:13] <strcat> graydon: the same rules that apply to & and &mut outside of unsafe
[17:51:22] <graydon> my only real point here is that telling someone "oh, unsafe { .. } doesn't tell the compiler enough to know you're unsafe, you need to be _extra_ unsafe with #[mutable]' is decidedly non-discoverable, a footgun, mechanism-wise
[17:51:25] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Quit: Leaving.)
[17:51:35] <strcat> graydon: well unsafe is a footgun :)
[17:51:42] <strcat> you really need to know how the language works to use it safely
[17:51:44] <strcat> already
[17:52:06] <graydon> why is the ptr-to-frozenness aspect essential?
[17:52:07] *** Quits: inolen (Adium@moz-9F4F17DF.tourcaster.com) (Ping timeout)
[17:52:12] *** Joins: inolen (Adium@moz-9F4F17DF.tourcaster.com)
[17:52:22] <strcat> graydon: because we allow & to alias, so marking it invariant is the next best thing
[17:52:25] *** Quits: johns (johns@2557E599.66715431.D25A875A.IP) (Ping timeout)
[17:52:30] <graydon> IOW if I have a buffer, that's uniquely owned, and I transmute it to mutable and call read() to load it with fresh bytes ....
[17:52:58] <graydon> I would _think_ that is kosher-if-weird (the buffer becomes a sort of nondeterministic weird thing) but not memory-model-breaking
[17:53:12] <graydon> if by doing that I am actually going to cause the compiler to generate bad code, that's surprising in the bad way
[17:53:14] <strcat> graydon: well LLVM won't go and break the world
[17:53:22] <strcat> but it might not make the write visible through the & and ~ ptrs
[17:53:28] <graydon> that part is ok
[17:53:38] <graydon> if that's all we're talking about
[17:53:49] <strcat> invariant is basically just telling it that it doesn't have to keep dereferencing the ptr
[17:53:56] <strcat> it can assume it's unchanging
[17:54:09] <strcat> they added it for vtables
[17:54:14] <graydon> so #[mutable] means "this function actually makes some of the things you pass to it change, even though its signature says it doesn't"
[17:54:37] <strcat> graydon: the thing about #[mutable] is that generally if you don't use it where you should, you've made unsound code in the existing language
[17:54:43] <strcat> Cell is unsound with #[mutable]
[17:54:49] <strcat> you can put it in an ARC and make the ARC a cycle
[17:54:59] <strcat> without #[mutable] *
[17:55:14] <nmatsakis> I feel like if we wind up keeping Cell
[17:55:23] <nmatsakis> we should maybe just add mut fields back in
[17:55:33] <nmatsakis> I'm hoping #[mutable] is a transitionary thing
[17:55:49] <nmatsakis> but maybe it's a better version of mutable fields, in that it's clearly "advanced"
[17:56:24] <graydon> cell is _unsound_ without #[mutable] ? or with it?
[17:56:29] <strcat> graydon: without it
[17:56:35] <graydon> ok. and becomes "sound" with it?
[17:56:38] <strcat> graydon: yes
[17:56:40] <graydon> I don't know what sound means here exactly
[17:56:53] <nmatsakis> what strcat means is that mutation is happening (via transmute_mut)
[17:56:57] <strcat> graydon: because Cell is essentially *the way* to break the mutability rules
[17:57:00] <nmatsakis> but because there are no mut declarations
[17:57:07] <nmatsakis> it's not visible to the borrow checker
[17:57:09] <strcat> and it was marked as Const before
[17:57:17] <strcat> which is used as a bound in some places like ARC
[17:57:22] <strcat> but it *isn't* Const
[17:57:31] <strcat> all #[mutable] does is remove the Const bound
[17:58:00] *** Joins: jviereck (Adium@moz-340574DC.dclient.hispeed.ch)
[17:58:13] <strcat> graydon: https://github.com/mozilla/rust/commit/c99409b332a2bee95e1139c6786c99a06cca9d3b
[17:58:35] <strcat> I'm not 100% sure it's safe now but I'm pretty sure....
[17:58:36] <graydon> mhm
[17:58:59] <brson> there are also types that want to pretend to be Const but aren't, like ARC
[17:59:01] <graydon> it feels like cell ought to be unsafe-fn land
[17:59:13] *** Joins: ksev (DrunkenPan@CB7DAFF1.B919BE8A.47C41102.IP)
[17:59:15] <brson> actually, ARC is not currently Const, but we do need things like it to be
[17:59:19] <graydon> or, oh, does it dynamically enforce a check about borrowed-ness?
[17:59:23] <strcat> brson: I marked RWARC as non-Const
[17:59:34] <brson> strcat: is ARC Const?
[17:59:46] <strcat> brson: does it ever mutate the handles?
[17:59:48] *** Quits: sully (sully@moz-45967CBE.emarhavil.com) (Ping timeout)
[17:59:59] <strcat> I think it's fine if it mutates the thing it points to
[18:00:04] <strcat> for refcounting
[18:00:14] *** Joins: sully (sully@moz-45967CBE.emarhavil.com)
[18:00:15] <brson> strcat: I'm just asking what the type system thinks of it now
[18:00:26] <strcat> brson: yeah it's Const
[18:00:31] *** Quits: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP) (Client exited)
[18:00:32] <strcat> anything without @mut or #[mutable] is Const
[18:00:50] <nmatsakis> I think ARC is a good example where it makes sense to break the rules,
[18:00:50] *** Joins: johns (johns@2557E599.66715431.D25A875A.IP)
[18:01:01] <strcat> graydon: Cell doesn't let you take & or &mut ptrs
[18:01:04] <nmatsakis> because the mutation is (1) private to the module and (2) only done via atomic primitives.
[18:01:10] <strcat> graydon: you can only deal with it through closures passes to the methods
[18:01:18] <brson> futures too
[18:01:23] <strcat> and it swaps the contained value with None when it hands it to you
[18:01:26] <brson> futures of Const things at least
[18:01:32] <nmatsakis> brson: yes, futures too.
[18:02:00] <strcat> I don't think ARC would be hurt by marking & ptrs as invariant though
[18:02:11] <strcat> it's never modified (refcount--) while there's an & ptr to the handle
[18:02:29] *** Quits: johns (johns@2557E599.66715431.D25A875A.IP) (Connection reset by peer)
[18:02:38] <graydon> strcat: ok. so that makes it safely usable and sort of ... "sound" in the sense that the codegen knows to always reload it, and it's a "normal" value as far as the borrow checker is concerned (that just happens to sometimes change underfoot) ?
[18:03:11] <strcat> graydon: yeah
[18:03:45] <strcat> graydon: without Const, there wouldn't be a way to tell codegen "don't use invariant on & ptrs to this*
[18:03:58] <graydon> ok. I still kinda expect people will forget #[mutable] with some frequency. can you think of any way to make that occurrence less-common?
[18:04:08] <graydon> without Const? or without #[mutable]?
[18:04:31] <strcat> well I think we should really encourage never breaking the mutability rules
[18:04:34] <strcat> it's really, really hard to get right
[18:04:47] <strcat> @mut was completely unsound until niko's new borrowck branch landed
[18:05:01] <strcat> if *we* can't get it right, we can't expect other people to get it right
[18:05:10] <strcat> if they want a mutable field they can use Cell
[18:05:16] <strcat> which is already safe
[18:06:12] <strcat> afaik the only people who are going to deal with it are those writing C bindings
[18:06:30] <strcat> if they wrap a mutable refcounted type they already need to implement freezing correctly
[18:06:50] <strcat> https://github.com/mozilla/rust/blob/incoming/src/libstd/rc.rs#L102 which is non-trivial
[18:08:43] *** Joins: int3_ (int3_@moz-34B610F6.subnet-248.amherst.edu)
[18:09:19] <Boreeas> In core, hashmap.rs defines HashMap as 'pub struct HashMap<K,V>'. I can import the hashmap module with 'use core::hashmap', but using 'hashmap::HashMap' gives me 'error: use of undeclared type name `hashmap::HashMap`'. Using 'core::hashmap::HashMap' instead gives me 'error: unresolved name'
[18:09:29] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[18:09:38] <Boreeas> Can someone explain me what I'm doing wrong? Relevant code snippet here: http://pastebin.com/hPu80Un4
[18:10:14] <strcat> Boreeas: using incoming or 0.6?
[18:10:18] *** Joins: thelivingded (thelivingd@moz-9453CC48.austin.res.rr.com)
[18:10:18] <strcat> it had a different name in 0.6
[18:10:44] <benh> What *can* I do with a & &mut T?
[18:10:53] <strcat> benh: pretty much nothing afaik
[18:11:02] <strcat> ref_eq ;p
[18:11:12] <strcat> or maybe not even that
[18:11:39] <strcat> but yeah you could cast the &mut as *mut and compare it as an integer in safe code ;p
[18:11:42] <benh> Time to use that let &x= bug and set myself up for disappointment when that's fixed
[18:11:48] <Boreeas> strcat: 0.6
[18:11:56] *** Joins: nukkesi (nukke@moz-1D115A2B.sd.sd.cox.net)
[18:11:59] <strcat> Boreeas: in 0.6 it's core::hashmap::linear::LinearMap
[18:12:01] <cantsin> Boreeas: use core::hashmap::linear::{LinearMap};
[18:12:05] *** Joins: johns (johns@2557E599.66715431.D25A875A.IP)
[18:12:07] <cantsin> or what strcat said :)
[18:12:21] <Boreeas> Ahh
[18:12:40] <strcat> benh: what do you want to do with it exactly?
[18:12:43] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[18:12:59] <strcat> could you just make it &mut &mut instead?
[18:13:09] *** Quits: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP) (Ping timeout)
[18:13:18] <Boreeas> Weird, I should be on incoming. The code I have here is incoming, I guess I did the build wrong
[18:13:51] <strcat> Boreeas: what's the snippet of code you have that won't compile?
[18:14:10] *** Quits: johns (johns@2557E599.66715431.D25A875A.IP) (Input/output error)
[18:14:14] <Boreeas> http://pastebin.com/hPu80Un4, namely the definition of ExecutionContext
[18:14:36] *** Joins: johns (johns@2557E599.66715431.D25A875A.IP)
[18:14:41] <Boreeas> Right, I see my problem. I cloned mozilla/rust, but didn't build it
[18:16:34] <benh> strcat: I actually just wanted to get an unsafe pointer out. I'm just toying around with a bit of unsafe code similar to the Unique example in the ffi tutorial.
[18:16:53] <benh> strcat: https://gist.github.com/ben0x539/5542361#file-gistfile1-rs-L46 - note line 46 and 54 which I couldn't figure out how to write properly
[18:16:58] <cyndis> with the new io system, will it be possible to select on an fd and a port at the same time?
[18:17:16] *** Quits: pcwalton (pcwalton@43CB6079.66715431.D25A875A.IP) (Connection reset by peer)
[18:18:00] *** Joins: pcwalton (pcwalton@43CB6079.66715431.D25A875A.IP)
[18:18:00] *** ChanServ sets mode: +o pcwalton
[18:18:06] <strcat> benh: it should be *mut
[18:19:23] <strcat> well
[18:19:26] <benh> The field only really has to be an unsafe pointer during construction and destruction, it seems neater to have it as a &-poiner while it's alive...
[18:20:02] <strcat> it's stuck as &mut though
[18:20:23] *** Quits: FluffySauce (textual@moz-E5BC5F6F.sea.popcap.com) (Quit: Computer has gone to sleep.)
[18:20:38] <benh> I kinda hoped accessing a &mut field in a non-mut object would make it look like a & field :(
[18:21:50] <pcwalton> nmatsakis: I get a borrow check error in deriving(Rand) but when I pretty=expanded it it works
[18:22:03] <benh> I suppose it doesn't actually get much easier than the rc.rs thing you linked
[18:22:18] *** Joins: jviereck1 (Adium@moz-71F6F35C.dynamic.hispeed.ch)
[18:22:51] <pcwalton> oh, I see
[18:22:54] <pcwalton> deriving is sharing ASTs!!!
[18:23:03] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[18:23:03] <pcwalton> deriving produces ASTs that are not trees
[18:23:11] <strcat> benh: RcMut is a lot more complicated since it needs to implement freezing like @mut
[18:23:35] *** Quits: jviereck (Adium@moz-340574DC.dclient.hispeed.ch) (Ping timeout)
[18:23:58] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[18:24:15] <nmatsakis> pcwalton: there was a reported issue on that, I suspected as much
[18:24:57] <strcat> graydon: btw the check for exchange_alloc vs local_alloc is wrong
[18:25:05] <strcat> graydon: seems to be based on Owned, which doesn't mean managed
[18:25:11] * strcat doesn't know where that code is
[18:25:17] <graydon> strcat: hm?
[18:25:23] <joshua_> hmm... anyone happen to know when c_vec lost its unsafe annotation?
[18:25:33] <strcat> graydon: & ptrs are non-Owned but not managed for example
[18:25:36] <joshua_> http://static.rust-lang.org/doc/std/c_vec.html vs http://static.rust-lang.org/doc/0.6/std/c_vec.html -- this seems like a ergression
[18:25:52] <graydon> strcat: what are you looking at?
[18:26:07] <strcat> graydon: LLVM IR for non-Owned things in ~ allocations
[18:27:35] <joshua_> aha, git blames acrichto :-)
[18:27:38] <strcat> hm
[18:28:15] *** Quits: mdu (mdu@moz-9962C9F4.rev.numericable.fr) (Ping timeout)
[18:29:02] <strcat> it's hard to tell what it's doing since it generates so maybe glue_drop/glue_take functions
[18:29:47] <strcat> afaict I can make it use exchange_alloc and local_free
[18:30:51] *** Joins: devbug (quassel@moz-E1DE087C.bchsia.telus.net)
[18:32:44] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Quit: Leaving.)
[18:33:45] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[18:34:37] <strcat> graydon: ok nvm it's some other bug
[18:35:06] <strcat> my reduced example doesn't get the dangling alloc :(
[18:35:25] *** Joins: flipcoder (flipcoder@moz-EE3A28B2.dhcp.rvsd.ca.charter.com)
[18:35:43] <jdm> brson: having fun with emoticons on github?
[18:36:05] <graydon> jdm: he's provoked me to start using them too. brightens up the day :)
[18:36:08] <jdm> haha
[18:36:23] <flipcoder> rust have weak ptrs?
[18:36:27] <benh> I don't think the Unique type in the example in https://github.com/mozilla/rust/blob/incoming/doc/tutorial-ffi.md#destructors is safe 
[18:36:39] <graydon> bjz: re cond! .. is { } possible for invocation? and is is possible to omit the leading | in each clause, or is that difficult-to-parse?
[18:36:45] <strcat> benh: why?
[18:36:48] <benh> borrow() seems to return a borrowed pointer with arbitrary lifetime, the 'self doesn't actually seem tied to the lifetime of the struct
[18:37:15] *** Quits: jgilbert (jgilbert@moz-E7782931.hsd1.ca.comcast.net) (Connection reset by peer)
[18:37:23] <benh> Presumably because it doesn't say Unique<'self, T> in the impl line
[18:37:57] <benh> If you change the test in main to something like let p: &int; { let mut y = Unique::new(5); *y.borrow_mut() = 10; p = y.borrow(); io::println(p.to_str()); } io::println(p.to_str()); it compiles and prints 10, then 0
[18:38:33] <strcat> benh: ah it should be using a parameter on the methods
[18:38:41] *** Quits: doener (doener@moz-121949B3.unitymediagroup.de) (Quit: leaving)
[18:39:24] <strcat> 'self used to implicitly be on &self
[18:39:30] <strcat> and that's when I wrote it ;p
[18:39:36] *** Quits: thelivingded (thelivingd@moz-9453CC48.austin.res.rr.com) (Ping timeout)
[18:39:53] <benh> fn borrow<'a>(&'a self) -> &'a T { seems to complain properly
[18:40:21] *** Quits: fairfieldt (chatzilla@F0DA239E.246E5E69.4AE11518.IP) (Ping timeout)
[18:40:29] <graydon> hmm
[18:40:37] <benh> I was being stupid and tried to fix it by saying Unique<'self, T>, and it would yell at me because Unique doesn't contain borrowed pointers
[18:41:02] *** Joins: fairfieldt (chatzilla@F0DA239E.246E5E69.4AE11518.IP)
[18:41:12] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[18:41:12] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/LiWxMw
[18:41:12] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[18:41:33] <graydon> if x.foo is a @~str, and I do (*x.foo).len() in a crate with #[allow(vecs_implicitly_copyable)], will I get an vector duplication before making that method call?
[18:41:52] <strcat> graydon: I think it will copy if moving fails
[18:41:53] <graydon> *a
[18:41:56] <strcat> it's really weird
[18:42:00] <graydon> "if moving fails"?
[18:42:18] <strcat> graydon: if moving it results in an error somewhere down the line
[18:42:26] <strcat> it changes the semantics completely
[18:42:28] <graydon> whaaaa
[18:42:37] <graydon> this has to go
[18:42:42] <strcat> graydon: I ran into this with treemap, it's really bad
[18:42:44] *** Joins: thelivingded (thelivingd@moz-9453CC48.austin.res.rr.com)
[18:42:51] <strcat> something changed that made the iterator no longer valid
[18:43:05] <strcat> so vecs_implicitly_copyable stepped in and started making .next() copy the whole thing
[18:43:12] <graydon> right
[18:43:19] *** Quits: pcwalton (pcwalton@43CB6079.66715431.D25A875A.IP) (Ping timeout)
[18:43:23] * strcat hates that attribute ;p
[18:43:37] <graydon> I am ... there is a very curious bit of code in the parser that does this. to the source string. on each token read.
[18:43:57] <graydon> copying-and-leaking the entire source file on each token would explain how I'm managing to eat all system memory during stage2
[18:44:12] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[18:44:12] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/JYYwwA
[18:44:12] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[18:44:13] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[18:44:13] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/nqZx4Q
[18:44:13] <ghrust> 13rust/06auto 147eb2a5b 15Brian Anderson: rt: Remove useless libuv wrappers. #5429...
[18:44:13] <ghrust> 13rust/06auto 146044be8 15bors: auto merge of #6196 : brson/rust/uvwrappers, r=brson...
[18:44:13] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[18:44:42] <strcat> benh: I think the bug might show up in a few places in the vec module too
[18:44:44] <strcat> looking now
[18:45:46] <benh> Speaking of vecs: Should/could there be an impl Clone for [T, ..N]?
[18:46:03] *** Quits: jviereck1 (Adium@moz-71F6F35C.dynamic.hispeed.ch) (Quit: Leaving.)
[18:46:09] <strcat> I think the compiler would have to do it
[18:46:12] <strcat> for arbitrary N
[18:46:37] <strcat> benh: well
[18:46:52] <strcat> that's probably a problem...
[18:47:30] <strcat> can methods be defined on [T, ..N] at all?
[18:47:38] <graydon> hmm. nope. that wasn't it :((
[18:47:47] <graydon> bloody inlining
[18:48:49] <strcat> benh: same problem with std::Rc btw
[18:49:24] <benh> strcat: it seems kinda invalid that there's a lifetime called 'self that isn't actually tied to the receiver
[18:49:32] <nmatsakis> brson: r? https://github.com/mozilla/rust/pull/6336
[18:49:43] <benh> I mean, you don't get to call it 'self if it's declared as a parameter to the function, but it's okay as a parameter to the impl and does... what?
[18:50:20] <flipcoder> what's the weak_ptr equivalent in rust?
[18:50:34] *** Joins: pcwalton (pcwalton@43CB6079.66715431.D25A875A.IP)
[18:50:34] *** ChanServ sets mode: +o pcwalton
[18:50:37] <strcat> flipcoder: there isn't one
[18:50:49] <strcat> flipcoder: @ is going to be managed by a gc, so cycles will be collected
[18:51:21] <nmatsakis> benh: it should prob be an error---though it's not a problem that's unique to 'self
[18:51:27] <strcat> it would be tricky to implement a reference counted pointer type with a *safe* weak_ptr
[18:51:32] *** Quits: thou (thou@moz-1C1CA9F7.fasttrackcomm.net) (Input/output error)
[18:51:36] <nmatsakis> benh: I presume the body of this function used transmute or sometihng to generate the return value?
[18:51:40] <benh> yeah
[18:51:49] <strcat> I think it would be very slow
[18:52:01] <cmr> it would require runtime checks at every access.
[18:52:12] <flipcoder> is that what c++11/boost do?
[18:52:18] <cmr> And error handling around those accesses.
[18:52:22] <strcat> flipcoder: no, they just aren't memory safe
[18:52:25] <strcat> flipcoder: well
[18:52:25] *** Quits: pcwalton (pcwalton@43CB6079.66715431.D25A875A.IP) (Ping timeout)
[18:52:27] <strcat> they're *also* slow
[18:52:39] *** Joins: jviereck (Adium@moz-71F6F35C.dynamic.hispeed.ch)
[18:52:47] <strcat> shared_ptr/weak_ptr uses an atomic reference count and afaik the reference count is allocated separately than the value
[18:52:57] <cmr> In python weak refs smartly handle the referend going away by throwing exception on invalid access.
[18:52:58] <flipcoder> yeah
[18:53:08] <strcat> weak_ptr knows if the object is expired
[18:53:12] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[18:53:12] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 146044be8 to 14270b508: 02http://git.io/N3iJvQ
[18:53:12] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[18:53:14] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[18:53:14] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/IZ6RHA
[18:53:14] <ghrust> 13rust/06auto 14e6bb916 15Brian Anderson: Move flate from core to std
[18:53:14] <ghrust> 13rust/06auto 14702f34b 15bors: auto merge of #6205 : brson/rust/flate, r=brson...
[18:53:14] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[18:53:15] <strcat> so the object must have a vector of weak_ptrs
[18:53:40] <strcat> which pretty much explains why shared_ptr is so much slower than the gc in ocaml/haskell
[18:53:45] <nmatsakis> benh: right. so, there is an open isue somewhere to issue a warning (or even an error) if the region on the return value does not appear in some parameter...
[18:53:47] <flipcoder> i think it just has separate ref count
[18:53:57] <strcat> flipcoder: how does the weak_ptr know the shared_ptr is gone?
[18:53:58] <nmatsakis> benh: ...because I claim it is almost always a mistake, and the only way to have such a fn that type checks...
[18:54:05] *** Joins: solancile (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net)
[18:54:10] <nmatsakis> benh: ...is to use a transmute or return something in the 'static region...
[18:54:11] *** Quits: jviereck (Adium@moz-71F6F35C.dynamic.hispeed.ch) (Quit: Leaving.)
[18:54:17] <nmatsakis> benh: ...in which case you might as well declare the 'static region.
[18:54:20] <strcat> flipcoder: the shared_ptr has to know about them to be able to make them expired, unless the weak_ptr increments a refcount too
[18:54:20] <flipcoder> checks the ref count to the proxy object i think
[18:54:21] *** Joins: Jesin (Jessin_@moz-A03A364F.cc.lehigh.edu)
[18:54:28] <flipcoder> separate ref count for weak, yeah
[18:54:31] <nmatsakis> benh: since your declaration basically says: "I can give you a pointer that will live as long as you want it to"
[18:54:31] <strcat> flipcoder: ah
[18:54:43] <benh> yeah, that is what I think I expected
[18:54:54] <benh> I *thought* I observed it working like that at one point too
[18:55:19] <flipcoder> strcat: so it's possible to do with unsafe code, just will be slow?
[18:55:26] <ssbr_> Tee hee hee. People that try to work around the lack of macros are very funny: https://github.com/isis-project/WebKit/blob/master/LayoutTests/fast/regex/script-tests/pcre-test-1.js
[18:55:37] <strcat> nmatsakis: specifically in this case it's a snippet of code I wrote before the meaning of 'self changed, and I didn't think to check if it had stayed correct ;p
[18:55:52] <strcat> flipcoder: yes, it's possible to do it
[18:55:54] <ssbr_> I was thinking of what set of PCRE-based tests I should go off of. I think the JS tests used in webkit/firefox are pretty reasonable, since JS is a hip modern language. Thoughts?
[18:55:58] <strcat> flipcoder: you could make it safe by failing if it expired too
[18:55:58] *** Joins: wunki (wunki@moz-D4C0427D.cm-6-7d.dynamic.ziggo.nl)
[18:56:08] <nmatsakis> strcat: yeah, this is partly why I advise using the unsafe "copy_lifetime" routines
[18:56:11] <nmatsakis> strcat: rather than transmute
[18:56:15] <ssbr_> (for basing the semantics of regexps off of, for my implementation)
[18:56:28] <nmatsakis> strcat: they are not so prone to letting anything through
[18:56:30] <strcat> flipcoder: mutable refcounted types are tricky to write in a safe way though
[18:56:51] <benh> strcat: And yeah it seems I can impl a Clone-like trait for [T,..3]
[18:56:55] <nmatsakis> strcat: not sure if you've seen those...
[18:57:12] *** Quits: dherman (dherman@2557E599.66715431.D25A875A.IP) (Quit: dherman)
[18:57:13] <strcat> nmatsakis: yeah I saw copy_lifetime
[18:57:43] <benh> I didn't, thanks :)
[18:58:13] <friggle> ssbr_: one would expect the webkit re test suite is fairly good, considering they compile regexes
[18:58:20] *** Joins: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com)
[18:58:30] <flipcoder> strcar:  so let's say i had a @ pointer to an object that held an optional @ with a weak ref count, think that would work?
[18:58:52] <strcat> flipcoder: well you don't need weak_ptr for @
[18:59:03] <strcat> it's not going to be refcounted
[18:59:21] <strcat> you can make a *separate* refcounted type in a library with a weak_ptr 
[18:59:25] *** Joins: pcwalton (pcwalton@2557E599.66715431.D25A875A.IP)
[18:59:25] *** ChanServ sets mode: +o pcwalton
[18:59:26] *** Quits: Ralith (ralith@moz-95DA29C.wireless.sfu.ca) (Ping timeout)
[18:59:33] <strcat> but still
[18:59:36] <strcat> it can't really be safe.
[18:59:58] <ssbr_> friggle: indeed, it is much larger than the python re test suite
[19:00:00] <brson> nmatsakis: are you going to land EnumSet? I think I want to use it for https://github.com/mozilla/rust/issues/6085
[19:00:04] <strcat> if the type *allows* cycles to exist, it's not safe code - it can allow stuff to outlive the task
[19:00:14] <nmatsakis> brson: it's in that pull request I just sent you
[19:00:17] <strcat> it's just not an abstraction you can make into safe code
[19:00:31] <flipcoder> hmm ok
[19:00:37] <ssbr_> which is great. Huge test suites from Python did more for catching subtle errors when I implemented these before, than my own custom-built test suites ever did
[19:00:57] <brson> nmatsakis: oh, I thought that was just a test case
[19:00:59] <strcat> ofc there's probably some scheme you could come up with where weak_ptr could still reference the refcounted ptr without the refcounted pointer able to be cyclical
[19:01:08] <nmatsakis> brson: nope, I'm using it 
[19:01:14] <strcat> it's just going to be really hard to make safe ;p
[19:01:23] <nmatsakis> brson: actually a legit criticism of the PR is that I didn't make any test cases :)
[19:01:43] <nmatsakis> brson: (that is, no unit tests for EnumSet---the PR itself shouldn't change behavior)
[19:01:48] *** Quits: Palmik (palmik@moz-79CD58C8.vpn.muni.cz) (Ping timeout)
[19:02:15] <flipcoder> I may try to make it work using safe code, im still trying to wrap my brain around this stuff though
[19:02:58] <strcat> flipcoder: there's a safe reference counted pointer type in std::rc now if you want somewhere to start from
[19:03:09] <strcat> well, safe after I send in a PR with a minor fix ;p
[19:03:20] <flipcoder> hah
[19:03:23] <strcat> RcMut should be fine though... only Rc has the minor problem
[19:03:40] <flipcoder> there's lots of c++ guys that got used to using weak, so you may hear about this a lot
[19:03:50] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Textual IRC Client: www.textualapp.com)
[19:04:56] <flipcoder> thanks anyway :P
[19:06:15] <cyndis> brson: are there any plans regarding select in the new io system?
[19:06:17] <strcat> nmatsakis: I'll switch these to copy_lifetime while I'm at it
[19:06:37] *** Joins: thelivingdedx (thelivingd@moz-9453CC48.austin.res.rr.com)
[19:06:40] <cmr> cyndis: io multiplexing in general, or specifically select?
[19:07:12] <cyndis> i'd like to select the writing of an alsa fd to determine if it needs more data
[19:07:59] <brson> cyndis: still to be decided. how to implement it in the new design is completely unresolved
[19:08:14] <cyndis> brson: ok
[19:08:23] <brson> cyndis: what other object would you be receiving on in your use case?
[19:08:30] <cyndis> a pipe
[19:08:35] *** Quits: thelivingdedx (thelivingd@moz-9453CC48.austin.res.rr.com) (Quit: Leaving)
[19:09:06] *** Joins: sk (sk@61A494B3.BA40E8A.AAC02D62.IP)
[19:09:25] <strcat> nmatsakis: ah there's no copy_mut_lifetime, guess I'll add that.
[19:10:32] <kimundi> nmatsakis: Is that EnumSet the EnumSet<E> { data: uint } you talked about?
[19:11:11] *** Joins: blitter (blitter@moz-7C98731E.dyn.centurytel.net)
[19:12:10] <nmatsakis> brson: added some simple tests...
[19:12:15] <nmatsakis> kimundi: yeah
[19:12:52] <kimundi> ssbr_: So, I was thinking if 'ShortestMatch', 'LongestMatch', 'PCRE' are being considered seperate engines, then I think it would maybe make sense to have the Flags be individual for each engine, instead of allways the same set for all RegularExpression Engines.
[19:13:51] *** Quits: noam (noam@F6B530A7.720527A7.416762B.IP) (Ping timeout)
[19:13:56] <kimundi> nmatsakis: Would it maybe make more sense to define it as EnumSet<E, D> { data: D } ? This way you could choose how much space to take.
[19:14:01] <ssbr_> kimundi: Ooh, that's a tough call.
[19:14:10] <nmatsakis> kimundi: yeah, that's not unreasonable.
[19:14:25] <nmatsakis> kimundi: I put the EnumSet in rustc specifically because I hadn't taken the time to try and "round it out" to a library
[19:14:32] <nmatsakis> kimundi: but that would be a good generalization
[19:14:44] <nmatsakis> kimundi: we ought to make the CLike trait a bit more official and add a deriving mode too (imo)
[19:15:21] <kimundi> nmatsakis: Yeah, sth like #[deriving(EnumSet(u8))]
[19:15:26] <kimundi> ssbr_: How so?
[19:15:33] <nmatsakis> kimundi: no, just #[deriving(CLike)] is all you need..
[19:15:41] <ssbr_> kimundi: I was considering that there's a body of flags that every regexp engine should be expected to support
[19:15:45] <nmatsakis> kimundi: then you can just use it with EnumSet<YourEnumType, u8>
[19:15:48] *** Joins: FrozenCow (FrozenCow@moz-9DF5D010.dynamic.upc.nl)
[19:16:03] <ssbr_> kimundi: but maybe that's not so, actually. It's reasonable for a specialized engine not to support some flag, or some syntax feature, that is incompatible with its goals
[19:16:28] <kimundi> ssbr_: Would mean a bit of refactoring to make it generic, yeah.
[19:16:29] <ssbr_> kimundi: what about options that affect parsing?
[19:16:49] <strcat> nmatsakis: https://github.com/mozilla/rust/pull/6337 r?
[19:17:09] <ssbr_> as I understand it from last time, we've separated out the notion of a parser from a regexp engine, and that's fine and I'd prefer to keep it that way
[19:18:02] <nmatsakis> strcat: r+
[19:18:23] *** Joins: judder (maradukewa@DABDEEA3.F2C0D0AC.78E362FE.IP)
[19:18:48] *** Joins: dherman (dherman@2557E599.66715431.D25A875A.IP)
[19:18:48] *** ChanServ sets mode: +o dherman
[19:18:50] <kimundi> ssbr_: Hmm. I guess to be fully general you'd want users to support providing both parsers and engines, but not require the first one. Something like a default method that uses the standard one per default?
[19:18:50] <ssbr_> kimundi: I don't think there are any popular flags that affect both parsing _and_ compilation/interpretation, so maybe two sets of options?
[19:18:57] *** Joins: noam (noam@F6B530A7.720527A7.416762B.IP)
[19:19:21] *** Joins: Nisstyre (wes@moz-FD86289.netflash.net)
[19:19:29] <ssbr_> kimundi: mm, I don't follow
[19:19:40] <ssbr_> (although I get you're talking about something other than options now)
[19:20:37] <ssbr_> hmmmm
[19:20:47] <ssbr_> actually, wait
[19:20:57] <ssbr_> do we want longest/shortest/pcre to be engines?
[19:21:09] <ssbr_> or options for an engine? I'm not so sure about this
[19:21:28] <ssbr_> for myself, I would implement all three with basically the same regexp implementation in many cases
[19:21:36] <ssbr_> it's just that backtracking search can only implement the last one
[19:21:46] <kimundi> ssbr_: Right basically in my head (which might not reflect reality in the slightest), I imagine a 'trait RegularExpressionEngine<AST> { fn parse(&str) -> AST; fn compile(AST) -> CompiledRegularExpression}  '
[19:22:13] <ssbr_> kimundi: nah, TBH I don't like tying the parser to the compiler
[19:22:23] *** Quits: bleibig (bleibig@moz-58EF3B3A.rochester.res.rr.com) (Quit: bleibig)
[19:22:25] <ssbr_> a public AST that any compiler can use would surely be fine?
[19:22:39] <kimundi> ssbr_: They don't need to be seperated in the implementation. I'm just thinkisng of a way to seperate it formally, so that a user can plugin something custom and have it work
[19:22:40] <strcat> what about existing regexp libs where they're one and the same?
[19:22:41] <ssbr_> and then parsers for e.g. different regex syntaxes (posix regexes vs PCRE, in particular, would be options)
[19:23:15] <strcat> it seems like the engine is tied to the parser
[19:23:25] <strcat> an re2-style one doesn't support as many features
[19:23:57] <ssbr_> strcat: well, if you have a public AST, a compiler for RE2 regexes can reject an AST containing backreferences
[19:24:20] <ssbr_> but if you literally want to wrap PCRE/RE2, their public interfaces don't let you pass in ASTs AFAIK
[19:25:09] *** Quits: raze (raze@moz-4E6675AF.bredband.comhem.se) (Ping timeout)
[19:25:52] <ssbr_> for me personally, I value being able to pass in an AST because it makes it useful from libraries that do other things. e.g. maybe somebody writes a PEG parser, and wants to optimize the special case of PEGs that happen to be regular expressions, so he translates the PEG AST to a regexp AST and then into the re module. (I know a guy that wants to do just this, thus the example)
[19:26:11] <ssbr_> but it does mean that this particular API can't wrap actual existing regexp libraries
[19:26:12] <brson> cyndis: for simple use cases it's easy to implement select-like patterns with tasks, as long as you can tolerate allocating an extra task
[19:26:12] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[19:26:12] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14702f34b to 14270b508: 02http://git.io/N3iJvQ
[19:26:12] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[19:26:15] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[19:26:15] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/RINkzw
[19:26:15] <ghrust> 13rust/06auto 14be8dc61 15Brian Anderson: rustc: Move code for discovering the crate entry point into its own pass...
[19:26:15] <ghrust> 13rust/06auto 1498f5c6d 15Brian Anderson: rustc: Only accept main functions at the crate level. #4433
[19:26:17] <ghrust> 13rust/06auto 143970d02 15Brian Anderson: rustc: Fix the logic for finding the Android main function...
[19:26:18] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[19:26:31] <kimundi> ssbr_: maybe just have a compile(&str) -> CompiledRegularExpression, and have the AST be an implementation detail? This way users can just use your included parser and AST, and write an own compiler, write those theirself, or wrap something external
[19:26:37] <brson> cyndis: that's not sufficient for many things though
[19:26:51] <kimundi> ssbr_: Again, nothing speaks against combining the three engines you want to support into one codepath "behind the scenes" 
[19:26:59] <cyndis> brson: i've done something like it for now, but yeah, there's problems
[19:27:22] <ssbr_> kimundi: the thing is I specifically don't want the AST to be an implementation detail, because producing it is valuable for users :(
[19:27:28] <cyndis> for example, i have a task waiting on stdin and because of that the program can never exit :)
[19:27:43] <cyndis> except by ctrl+c
[19:27:43] *** Joins: themgt (themgt@moz-248BBB96.dhcp.gnvl.sc.charter.com)
[19:27:44] *** Quits: themgt (themgt@moz-248BBB96.dhcp.gnvl.sc.charter.com) (Client exited)
[19:27:50] <ssbr_> kimundi: there could be two traits, one that has compile(&AST) and one that has compile(&str)
[19:28:08] <ssbr_> and then a default implementation of the latter in terms of the former using the usual builtin parser?
[19:28:09] <kimundi> ssbr_: Well users can still use it if they want, no? What use cases do you think of that wouldn't work this way?
[19:28:10] *** Quits: fread2281 (zcarterc@moz-CB181B42.dia.static.qwest.net) (Ping timeout)
[19:28:34] <brson> cyndis: what is the solution to that? if you were reading from stdin in C and decided to exit what would you do?
[19:28:34] *** Quits: ksev (DrunkenPan@CB7DAFF1.B919BE8A.47C41102.IP) (Ping timeout)
[19:28:38] <ssbr_> kimundi: if the interface that accepts ASTs isn't public, how can a user pass in ASTs?
[19:28:49] <ssbr_> (you called it "an implementation detail")
[19:28:58] *** Joins: jeff (jeff@69765D56.D8FB3E69.FCBF9AFD.IP)
[19:29:05] <cyndis> brson: i could select on both stdin and an exit signal
[19:29:19] *** Quits: Jesse (jruderman@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: Jesse)
[19:29:52] <ssbr_> kimundi: you're talking about the case of a person writing a compiler who wants to reuse the existing parser; I mean someone who wants to write their own parser but reuse the compiler
[19:30:08] <ssbr_> I don't see why I wouldn't want to support both
[19:30:29] <kimundi> ssbr_: I could be clearer :) What I mean is, while it would be an implementation detasil for the 'compile(&str) -> CompiledRE' method, you could still cleanly an neatly publically expose parser, compiler and the AST type in the re libary as building blocks for others
[19:31:05] <ssbr_> kimundi: OK
[19:31:09] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[19:31:50] <kimundi> ssbr_: So you'd be able to use either compiler or parser, but wouldn't be required by the trait definition to use any of them if it's not necessarty for your usecase.
[19:31:58] <ssbr_> kimundi: sure
[19:32:41] <cmr> ssbr_: have you abandoned the idea of compiling REs at compile-time or is this separate?
[19:33:11] <kimundi> Of course just because I think it should be done that way doesn't mean it's the right thing todo... :)
[19:33:12] <ssbr_> kimundi: I think I'd like multiple traits though -- one for compiling just straight strings to regexps, and then another for AST to regexps -- and then you support both if you can (e.g. if you're writing something from scratch in Rust reusing the parser), or only the string interface if you can't (e.g. you're wrapping a specific regexp implementation like PCRE)
[19:33:33] <ssbr_> cmr: it's separate
[19:33:51] <ssbr_> cmr: well, right now, everything we're discussing basically can't be done at compile-time
[19:34:04] <ssbr_> but compile-time regexp validation/compilation is useful even if it isn't so general
[19:34:04] <cmr> right, that's what I noticed
[19:34:12] * cmr nods
[19:35:02] <kimundi> ssbr_: Hm, so you'd be chained to your specific AST format if you use the corresponding trait, but can just not do that If you don't want? Sounds also possible, and would allow for compiletime parsing of regular expressions in those cases.
[19:35:35] <ssbr_> kimundi: ah, I hadn't thought about that. Yes, it would allow compile-time parsing (but not compiling) if it were done a certain way
[19:35:37] <ssbr_> hypothetically
[19:35:58] <kimundi> cmr: Basically the plan is to have an interface for runtime regular expression compilation, and have thze macro for regular expressions just special case some invokations to fully compiletime compilation.
[19:36:19] <ssbr_> kimundi: I think that on its own makes it valuable ;)
[19:36:25] *** Joins: thomaslee_ (thomaslee@moz-6C3931E3.static.twtelecom.net)
[19:36:29] <kimundi> yup
[19:36:32] <ssbr_> (but I don't have a clue as to how to actually encode it to make sure it can be done)
[19:37:13] <ssbr_> kimundi: can I rely on you to work that out? :p
[19:37:46] <kimundi> ssbr_: I try my best, but I can't promise anything ;)
[19:37:52] <ssbr_> kimundi: that's fine too
[19:37:57] *** Quits: int3_ (int3_@moz-34B610F6.subnet-248.amherst.edu) (Client exited)
[19:38:07] <ssbr_> the actual API details can wait a long time before they're nailed down
[19:38:17] *** Quits: dherman (dherman@2557E599.66715431.D25A875A.IP) (Quit: dherman)
[19:38:38] <brson> cyndis: thanks. I'll start thinking more seriously about how to work select into the design. it's important. bbl lunch
[19:38:40] <ssbr_> I'm going to add a note on the wiki page to this effect, I don't want to forget that this can be done
[19:38:59] <cmr> brson: what about kqueue or epoll, too?
[19:39:03] <cyndis> brson: :)
[19:39:33] <ssbr_> kimundi: seriously nice thought though!
[19:39:46] *** Joins: ksev (DrunkenPan@CB7DAFF1.B919BE8A.47C41102.IP)
[19:39:56] <jdm> is there a way to disable the unnecessary mutability lint pass?
[19:40:24] <thomaslee_> hey folks, looking for advice on https://github.com/mozilla/rust/issues/4202 per my last comment. Am thinking I can address the issue by essentially ensuring that we include the static methods associated with a reexported trait in a crate's metadata. Something like "use sub_mod::Foo" actually means "use sub_mod::Foo; use sub_mod::Foo::<all-static-methods-on-Foo>" for traits (where the static methods are prefixed by "Foo"
[19:40:24] <thomaslee_> ).
[19:40:37] <kimundi> ssbr_, so from the top of my head we'd have RegularExpressionCompiler { fn compile(AST) -> CompiledRegularExpression}, and RegularExpressionParseCompiler { fn parse_compile(&str) -> CompiledRegularExpression } Now the question is how to get a nice fallthrough logic for that, which doesn't imply syntax extension magic... 
[19:41:17] <cyndis> cmr: i would imagine libuv wraps all these mechanisms in some way
[19:41:32] <cmr> Oh is the new io system wrapping libuv?
[19:41:38] <cmr> That's fine then, libuv is solid.
[19:41:41] <cyndis> yes
[19:42:01] <cyndis> the default is libuv, but i think it also allows other implementations
[19:42:23] <ssbr_> kimundi: well, in the worst case, there can be two syntax extensions: re_parse! and re! , where re! uses only the RegularExpressionParseCompiler trait, so that it can't change parsing
[19:42:55] <ssbr_> whereas re_parse! specifically invokes a parser (and can do stuff at compile-time)
[19:43:06] <ssbr_> I'm not even sure how you special-case the builtins without special syntax for them, though
[19:43:11] <ssbr_> (in either case)
[19:43:41] *** Joins: thou (thou@moz-1C1CA9F7.fasttrackcomm.net)
[19:43:57] *** Joins: jgilbert (jgilbert@2557E599.66715431.D25A875A.IP)
[19:49:54] *** Joins: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net)
[19:50:53] <acrichto> joshua_: https://github.com/mozilla/rust/pull/6339
[19:53:16] *** Joins: int3_ (int3_@moz-34B610F6.subnet-248.amherst.edu)
[19:55:13] *** Joins: berak_ (chatzilla@875EAED4.6062171A.1A5CC7E5.IP)
[19:55:40] *** Quits: berak (chatzilla@875EAED4.6062171A.1A5CC7E5.IP) (Ping timeout)
[19:55:41] *** berak_ is now known as berak
[19:56:29] *** Quits: FrozenCow (FrozenCow@moz-9DF5D010.dynamic.upc.nl) (Client exited)
[19:57:57] *** Quits: Blub\w (wry@moz-7BC9C9D6.wireless.dyn.drei.com) (Quit: bbtm)
[19:58:20] <ssbr_> kimundi: actually
[19:58:36] <ssbr_> kimundi: maybe it's desirable to separate the API out explicitly, from at compile time vs at run time
[19:58:40] *** Joins: mzabaluev (mzabaluev@moz-91FFD755.dhcp.inet.fi)
[19:58:55] <mzabaluev> failures:
[19:58:56] <mzabaluev>     flatpipes::test::test_serializing_boxes
[19:59:03] <mzabaluev> Is it known?
[19:59:25] <ssbr_> kimundi: consider the return type of re!() -- if it's at compile time, we could guarantee that it will never fail. But at runtime, we can't, so it needs to -> Option<...>
[19:59:53] <ssbr_> kimundi: also, it's probably desirable in itself to know for a fact that something is done at compile time or not
[20:00:06] <ssbr_> maybe this is an argument for an additional flag or form that only works at compile time
[20:00:15] <ssbr_> and disables the run-time fallback
[20:05:08] *** Quits: int3_ (int3_@moz-34B610F6.subnet-248.amherst.edu) (Client exited)
[20:06:46] *** Quits: jdm (jdm@DB05BBF2.BB1F48F2.971E19F6.IP) (Quit: Lost terminal)
[20:08:27] *** Joins: Jesse (jruderman@moz-BE33DA21.fw1.sfo1.mozilla.net)
[20:08:28] *** Quits: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se) (Connection reset by peer)
[20:08:47] *** Joins: int3_ (int3_@moz-34B610F6.subnet-248.amherst.edu)
[20:10:46] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Client exited)
[20:10:48] <kimundi> ssbr_: Hmm... Good point about it needing to be option. Though in that case you could just fail I guess, The user has to make sure he passes a valid regular expression himself after all.
[20:11:18] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[20:11:20] *** Joins: Ralith (ralith@moz-50F3C77.vc.shawcable.net)
[20:12:27] <ssbr_> kimundi: it's probably pretty reasonable to expect users to read a regexp from user input or a file
[20:12:32] <joshua_> acrichto, thanks!
[20:12:44] <ssbr_> kimundi: maybe that isn't so common that it needs to be part of the primary API though
[20:12:50] <cmr> mzabaluev: probably not, report a bug just to be safe.
[20:13:06] <kimundi> ssbr_: Right, but then you could just have an external validator for it.
[20:13:36] <ssbr_> kimundi: well, validation would amount to parsing
[20:14:28] <ssbr_> they'd end up specifically doing compile( match parse(...) { Err(_) => ... Ok(x) => x } )
[20:14:38] *** Quits: zakora (NC@moz-8EAF945F.fbx.proxad.net) (Quit: Textual IRC Client: www.textualapp.com)
[20:14:47] <mzabaluev> cmr: is x86 even tested before advancing incoming?
[20:14:54] <cmr> mzabaluev: yes
[20:14:57] <cmr> actually
[20:15:05] <kimundi> ssbr_: Yeah, so at the point where the parser returns an ASt, it would be an Option<AST>. But the default code path then assumes it works so that it can return an CompiledRegularExpression.
[20:15:32] <ssbr_> kimundi: assuming that we don't want to support the use case of unknown regexps in the usual API
[20:15:57] <ssbr_> kimundi: but also, the desire to force things to be verified at compile time is maybe compelling
[20:15:58] <mzabaluev> cmr: my machine must be somehow special then. Only recently there was an assertion on build, now it's just a test failure.
[20:16:33] <ssbr_> all you have to do is add a variable option, and the parser can't work until it knows what options it gets (runtime)
[20:16:41] <ssbr_> and no verification or compilation is done at compile time
[20:16:45] <ssbr_> and it can look kinda innocuous
[20:17:21] <ssbr_> all this needs is a particular form in the macro though
[20:17:39] <ssbr_> so that instead of falling back, it gives an error at compile-time
[20:17:49] <ssbr_> s/macro/syntax extension/
[20:18:07] <kimundi> ssbr_: I think we need to start using ann etherpad or something, I'm loosing track of all the details I need to track xD
[20:18:17] <ssbr_> kimundi: haha, there is the wiki page
[20:18:33] <ssbr_> you can just create a new section titled "kimundi notes" or something
[20:18:36] <ssbr_> https://github.com/mozilla/rust/wiki/Lib-re
[20:18:43] <cmr> mzabaluev: maybe. not 100% sure
[20:19:01] <ssbr_> kimundi: I've put some of what we've just talked about there already, but there's stuff from earlier that hasn't been mentioned, and some details are missing.
[20:19:05] <cmr> pretty sure there is though
[20:19:08] *** Parts: berak (chatzilla@875EAED4.6062171A.1A5CC7E5.IP) ()
[20:19:16] <ssbr_> kimundi: scroll down to section 4, module writing
[20:19:42] *** Joins: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se)
[20:20:30] <cmr> graydon: What is the OS/platform coverage for the buildbots? I see a ML thread asking what *should* be covered but nothing specifiny *what* is
[20:20:54] <graydon> cmr: which ML thread?
[20:21:05] <cmr> https://mail.mozilla.org/pipermail/rust-dev/2012-November/002650.html
[20:21:30] <graydon> ah
[20:21:35] <graydon> currently nothing close to that
[20:21:52] *** Quits: wunki (wunki@moz-D4C0427D.cm-6-7d.dynamic.ziggo.nl) (Ping timeout)
[20:22:29] <graydon> we do .. effectively ubuntu 12 LTS, centos 6, freebsd 9, win server 2008, and osx 10.7.4 lion
[20:23:07] <ssbr_> kimundi: I'm heading offline for a bit to grab lunch
[20:23:12] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[20:23:12] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/RINkzw
[20:23:13] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[20:23:19] <ssbr_> kimundi: feel free to add some stuff to that to keep track of what you need to remember
[20:25:31] *** Quits: int3_ (int3_@moz-34B610F6.subnet-248.amherst.edu) (Client exited)
[20:25:44] <cmr> graydon: what archs?
[20:25:48] <cmr> just x86-64?
[20:26:28] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[20:26:29] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/aoVkYQ
[20:26:29] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[20:26:31] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[20:26:31] <ghrust> 01[13rust01] 15bors pushed 24 new commits to 06auto: 02http://git.io/GtfCcQ
[20:26:31] <ghrust> 13rust/06auto 14a91b55e 15Patrick Walton: libstd: Remove mutable fields from fileinput and net_tcp
[20:26:31] <ghrust> 13rust/06auto 14ba2ce0f 15Patrick Walton: libstd: Remove mutable fields from flatpipes and io_util
[20:26:33] <ghrust> 13rust/06auto 148ff0194 15Patrick Walton: libstd: Remove mutable fields from future and par
[20:26:35] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[20:27:14] <graydon> x64 and x86 for linux and osx. x86-only for win. x64-only for freebsd.
[20:27:28] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[20:27:33] <graydon> there's also android and linux-arm-eabi work going on, but neither is in the buildbot pool yet
[20:27:40] <graydon> (and there's a mips port, but that's even less-maintained)
[20:29:22] <bjz> pauls_ pauls: https://github.com/mozilla/rust/pull/6333#issuecomment-17631577
[20:29:23] *** Joins: int3_ (int3_@moz-34B610F6.subnet-248.amherst.edu)
[20:29:35] <bjz> graydon: ^
[20:29:54] *** Joins: steven_is_false (quassel@moz-144077DE.bchsia.telus.net)
[20:30:35] *** Quits: mzabaluev (mzabaluev@moz-91FFD755.dhcp.inet.fi) (Ping timeout)
[20:30:52] <pauls_> bjz, nice.
[20:31:00] *** Quits: tupshin (quassel@moz-E7B03838.c3-0.nyr-ubr1.nyr.ny.cable.rcn.com) (Client exited)
[20:31:12] <pauls_> There's no way to use `{}` around an invocation currently.
[20:31:17] <graydon> isn't there?
[20:31:22] <bjz> dang.
[20:31:26] <steven_is_false> Hi! I was looking over the recent commits, and saw that the Durable trait was being replaced with 'static in the compiler a lot. Does that mean that there is going to be more work on constraining generics using arbitrary lifetimes?
[20:31:28] <graydon> weird. I thought that was kinda a .. design goal in the new system
[20:31:36] <pauls_> I don't remember why we removed that; originally, you could use either for any macro...
[20:31:44] *** Quits: int3_ (int3_@moz-34B610F6.subnet-248.amherst.edu) (Client exited)
[20:32:05] <pauls_> ...it sounds like what people want is to be able to say "this macro uses `()`" vs. "this macro uses `{}`"?
[20:32:16] <steven_is_false> pauls_: That would be nice for cases like declaring new structure tpes.
[20:32:17] <graydon> I think so, yeah
[20:32:24] <pauls_> I don't have any real objection to that, except that it seems a little arbitrary.
[20:32:49] <pauls_> e.g., should `macro_rules!` use `{}`, because it's a declaration?
[20:32:49] <graydon> (also this-macro-uses-[], since those are also tt-delims)
[20:33:08] <graydon> probably. it'd read much more clearly!
[20:33:27] <graydon> (I've also a longstanding interest in renaming it macro! as there's no collision with #macro at this point)
[20:33:48] <bjz> plus my editor has trouble with the auto-indenting of () vs {}
[20:33:50] <benh> (( "this-macro-uses-<> because it emits xml" ))
[20:33:53] *** Joins: Sodel_the_V (user@moz-853663E1.va.shawcable.net)
[20:34:01] <pauls_> graydon, but how will people know what it is that macros do, then?
[20:34:04] <pauls_> : P
[20:34:05] <graydon> <> aren't tt delimiters
[20:34:24] *** Joins: tupshin (quassel@moz-E7B03838.c3-0.nyr-ubr1.nyr.ny.cable.rcn.com)
[20:34:34] <graydon> pauls: they don't have to. never have. they just need to know where they _are_, which is indicated by macroname! followed by a tt
[20:34:38] *** Quits: jgilbert (jgilbert@2557E599.66715431.D25A875A.IP) (Ping timeout)
[20:34:47] <steven_is_false> Is there a void type in the standard libraries? This is easily implemented as pub mod Void { pub struct Void { priv contents : () } } but it'd still be nice to have.
[20:35:13] <graydon> steven_is_false: () is the 0-sized-type. you need it to be nominal?
[20:35:22] <benh> void as in uninhabited?
[20:35:28] <bjz> pauls_: it's weird. I have thought about the arbritrary-ness of {} vs (), but it would be nice for extending syntax
[20:35:38] <steven_is_false> graydon: () is the unit type. I want uninhabited like benh mentions.
[20:35:44] <pauls_> (I mean, how will they know that macros rule. Sorry. IRC!)
[20:35:52] *** Quits: ssbr_ (ssbr@moz-BB1842E5.wireless.utoronto.ca) (Ping timeout)
[20:36:10] <graydon> pauls: oh, I see. indeed, restating that macros rule regularly does seem like healthy positive-thinking
[20:36:26] <bjz> pauls_: macros rule!
[20:36:26] <graydon> but I recently finished a book that suggests that positive-thinking affirmations tend to have the opposite effect they intend
[20:36:34] <bstrie> pauls_: yes, I've been one who's longed for macros that can be invoked with {}
[20:36:39] <bstrie> () for control flow is... heresy :)
[20:36:42] * bjz likes macros ver much
[20:36:53] <bjz> verrrr much
[20:36:57] <graydon> (the book suggested several other things as well -- hardly enough to make a book)
[20:37:05] <pauls_> There's another change that I think we might want to make that could be usefully rolled up with these other two changes, which is getting rid of the silly extra invocation style that `macro_rules!` uses.
[20:37:12] <pauls_> So...
[20:37:12] <bstrie> they don't need to be permissive, it's good to enforce that a macro defined with {} must be invoked with {}, and vice versa
[20:37:14] <graydon> steven_is_false: huh. what for?
[20:37:18] *** Quits: seth (seth@moz-BE33DA21.fw1.sfo1.mozilla.net) (Ping timeout)
[20:37:31] *** Joins: jgilbert (jgilbert@43CB6079.66715431.D25A875A.IP)
[20:37:38] <graydon> bstrie: yes, I agree with that. mixing invocation forms tends to ... surprise everyone
[20:37:41] <bjz> bstrie: agreed
[20:37:42] <graydon> (on the same macro)
[20:38:01] <pauls_> `macro!{ my_macro!($x:expr) => ($e) }` for paren-invocation
[20:38:02] <steven_is_false> graydon: Phantom types mostly. I want to do pub struct Compiled (Phantom); pub struct Uncompiled (Phantom); and then have a program type polymorphic over whether it's compiled or not.
[20:38:13] <pauls_> `macro!{ my_macro!{$x:expr} => ($e) }` for brace-invocation
[20:38:14] <bstrie> pauls_: that looks mice
[20:38:21] <bstrie> er
[20:38:22] <bstrie> nice
[20:38:24] <graydon> pauls: yeah
[20:38:29] <graydon> +1
[20:38:34] <bstrie> don't mind me, sleep deprivation...
[20:38:36] <bjz> ++1
[20:38:40] <kimundi> also +1 :)
[20:39:06] <graydon> even mice like it!
[20:39:08] <bstrie> the unique macro invocation syntax has always seemed like a very bizarre special case. glad to be rid of it
[20:39:15] <pauls_> bstrie, I was hoping for "...in the eye, and tells them that we're sorry that they have to die, but we need our science"
[20:39:22] *** graydon is now known as just_a_mouse
[20:39:23] *** Joins: seth (seth@moz-C03D0C61.vlan426.asr1.sfo1.gblx.net)
[20:39:26] <just_a_mouse> +1
[20:39:28] <bstrie> haha
[20:39:30] *** just_a_mouse is now known as graydon
[20:39:46] <bstrie> er, unique macro definition syntax...
[20:39:49] <bjz> pauls_: so about the parsing issue without `|`
[20:39:54] <bstrie> to reiterate, sleep deprivation
[20:40:07] <EXetoC> bjz: 1 = 1 + 1? omg what are you doing to math?
[20:40:12] <pauls_> Doing all this while changing the name will make the backwards-compatibility issue better.
[20:40:13] <bjz> bstrie: we enjoy having some entertainment
[20:40:17] <bstrie> EXetoC: we overloaded + to mean *
[20:40:24] <EXetoC> phew
[20:40:39] *** Quits: pyrac (pyrac@moz-516480D0.w92-156.abo.wanadoo.fr) (Quit: pyrac)
[20:40:41] <bstrie> EXetoC: unfortunately now you also dereference pointers with +
[20:40:54] <bjz> pauls_: https://gist.github.com/bjz/32d12591b55f3b6488a4
[20:41:11] <steven_is_false> bstrie: Would that make borrowed pointers now declared as -T?
[20:41:19] <graydon> bjz: yeah, O
[20:41:20] <pauls_> bjz, ah the dreaded local ambiguity bug.
[20:41:26] <bjz> heh
[20:41:27] <pauls_> Well, "limitation".
[20:41:35] <bjz> understandable
[20:41:38] <graydon> I'm not sure how easy { $expr } is to grab as a block
[20:41:45] <graydon> (or what "block" counts as in our grammar presently)
[20:42:16] <bstrie> steven_is_false: those are actually anti-pointers, which are completely safe to use as long as you don't let them come into contact with regular pointers
[20:42:28] <pauls_> You're not going to be able to do anything about that in the short, (and probably medium) term. The macro parser, effectively, doesn't want to dive into parsing a rust nonterminal...
[20:42:39] <pauls_> ...without the assurance that it's the only option...
[20:42:54] <pauls_> ...because the Rust parser kills the whole task on parse failure.
[20:43:09] <bstrie> ^T can be a charm pointer, and %T can be a strange pointer. let's have a whole quantum pointer zoo
[20:43:21] *** Joins: int3_ (int3_@moz-432A7121.public.wayport.net)
[20:43:22] <bjz> we can't do the weird recursive trickery?
[20:43:27] <pauls_> I believe that it's basically requiring the macro grammar to be LL(0). 
[20:43:34] <kimundi> RFC: macro?() syntax for 'magic'-macros. Does one of thousand random things on each expansion. ;)
[20:43:43] <bstrie> LL(-1)
[20:44:03] <pauls_> bjz, the parser just reports failure by task killing. ) :
[20:44:17] <pauls_> ...so you can't use it speculatively.
[20:44:34] <bjz> kimundi: you need to write 'please;' randomly through the invocation
[20:44:55] <bstrie> sure you can, just need to use the try/catch-by-task-spawning hack
[20:44:58] <kimundi> bjz: Right, but not too often!
[20:45:05] <bjz> kimundi: and cross your fingers
[20:45:22] <bjz> pauls_: so no?
[20:45:58] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Quit: Leaving.)
[20:47:05] <steven_is_false> So I need to work around some recent changes that break deriving equality for structures that have destructors. I'm not sure if that is an error, or  a deliberate decision. If it was a decision is there a justification or an easy work around?
[20:47:32] <bstrie> steven_is_false: how recent?
[20:47:46] <pauls_> bjz, nope. There's been some talk of rewriting the parser, however.
[20:48:04] <pauls_> ...and if that happens, then it'll presumably make everything better.
[20:48:17] <bjz> graydon: does this mean we should hold off on this pr?
[20:48:22] <steven_is_false> bstrie: I just downloaded the new compiler on incoming today.
[20:48:31] <steven_is_false> bstrie: I
[20:48:40] <bjz> graydon: until after these things have been fixed?
[20:48:50] <bstrie> steven_is_false: was it working recently? because there was a change to what types are allowed to have safe destructors, but that was a while ago
[20:48:51] <steven_is_false> I can't remember how old my last copy was.
[20:49:17] * bjz will get cond! into rust eventually
[20:49:28] <steven_is_false> bstrie: The error was deconstructing struct not allowed in pattern.
[20:49:43] * bjz bjz wonders if do and for could be macros
[20:49:49] <steven_is_false> bstrie: I don't think it has to do with destructor safety.
[20:52:33] <bstrie> I'm not sure then
[20:54:13] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[20:55:56] *** Joins: jdm (jdm@F2D29657.F60B0462.67AC9B1.IP)
[20:56:01] <steven_is_false> bstrie: There was a big commit 2 days ago reworking the generic deriving code. I have no idea if that code caused that to happen.
[20:56:14] <bstrie> I must have missed that
[20:56:16] <strcat> steven_is_false: can you give an example?
[20:56:56] <steven_is_false> strcat: #[deriving(Eq)] pub struct Foo; impl Drop for Foo { fn finalize (&self) {} } should do it.
[20:58:45] <strcat> foo.rs:1:11: 1:13 error: deconstructing struct not allowed in pattern (it has a destructor)
[20:58:48] <strcat> oh that makes sense
[20:59:27] <strcat> I wonder why the deriving code uses a pattern
[21:01:14] *** Quits: jgilbert (jgilbert@43CB6079.66715431.D25A875A.IP) (Ping timeout)
[21:01:24] <kimundi> ssbr: ping
[21:01:50] <kimundi> bjz: what does cond!() do?
[21:02:26] <EXetoC> https://gist.github.com/bjz/32d12591b55f3b6488a4
[21:02:37] <bjz> kimundi: means you don't have to do ifelseifelseifelse if you have lots of conditions
[21:03:26] <kimundi> ah, so 'sugar' for if else chains?
[21:03:30] <bjz> yah
[21:03:36] <bjz> like scheme has
[21:03:55] * bjz has been doing some SICP lately
[21:05:14] <steven_is_false> Welp, It's easy enough to work around this for now. I'll go file an issue though.
[21:05:37] <strcat> brson: btw std::rc doesn't have @ in it anymore
[21:07:11] <Luqman> bjz: i like the cond macro!
[21:08:11] <mcpherrin> mmm delicious cond
[21:10:11] <cmr> aatch: ping
[21:10:11] *** Quits: infynyxx_ (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[21:10:33] <strcat> yay!
[21:10:39] <strcat> github implemented my feature request
[21:10:49] <strcat> the issue search can filter open/closed bugs :)
[21:10:57] <strcat> (like the old issue search....)
[21:11:11] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[21:11:11] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14d499c8a to 1465ded84: 02http://git.io/N3iJvQ
[21:11:11] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[21:11:13] <benh> I was about to ask where that went, earlier...
[21:11:14] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[21:11:14] <ghrust> 01[13rust01] 15bors pushed 8 new commits to 06auto: 02http://git.io/sj_J7A
[21:11:14] <ghrust> 13rust/06auto 148e0c6fa 15Seo Sanghyeon: Port IRBuilder::CreateVectorSplat
[21:11:14] <ghrust> 13rust/06auto 14f3217a5 15Seo Sanghyeon: Check SIMD vector types
[21:11:14] <ghrust> 13rust/06auto 14c5a7be6 15Seo Sanghyeon: Add core::simd and define SIMD vector types
[21:11:16] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[21:11:37] *** Quits: Mowah (Mowah@moz-59D1A475.cust.bredbandsbolaget.se) (Connection reset by peer)
[21:11:49] *** Quits: saml (sam@moz-14C16814.cst.lightpath.net) (Quit: Leaving)
[21:12:41] <lkuper> informal poll: how much memory do you have on the machine you build rustc on?
[21:12:49] *** Joins: Mowah (Mowah@moz-59D1A475.cust.bredbandsbolaget.se)
[21:13:06] <cmr> 16GB (and 1GB on my netbook)
[21:13:14] <Flibo> 4 GB
[21:13:16] <benh> 8G, give or take
[21:13:36] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[21:13:36] <lkuper> https://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust suggests 2 GB, but that's kinda low...
[21:13:39] <ksev> 32 GB on desktop, 16 on laptop
[21:14:06] <EXetoC> cmr: but you don't build on the one with 1GB, right?
[21:14:09] <cmr> lkuper: 2GB is plenty
[21:14:15] <cmr> EXetoC: I do, unfortunately
[21:14:23] <EXetoC> fun
[21:14:27] <cmr> yeah :p
[21:14:44] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[21:14:54] <EXetoC> I tried, but it was swapping like crazy. how long does it take for you?
[21:14:55] <Luqman> iirc you need ~1.5 gb
[21:14:56] <cmr> I usually only build stage1
[21:15:10] <cmr> EXetoC: ~6 hours for a full build.
[21:15:12] <steven_is_false> So if there was a Void type in the standard library it'd go in core::util right?
[21:15:35] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[21:15:46] <strcat> cmr: o_o
[21:15:51] <cmr> it's only when I'm at school (where ssh is blocked) and have other things to do while I wait for the build
[21:16:01] <EXetoC> not that bad I guess, assuming that you have more than one computer
[21:16:14] <cmr> mm, my desktop builds in something like 20 minutes
[21:16:15] <EXetoC> right
[21:16:18] <lkuper> I ask because just now, I was trying to do a google hangout with astrieanna and her browser crashed three times  because she was simultaneously trying to build rustc with 2 GB ram
[21:16:20] <strcat> it takes me 12 mins to do the 3 stages, and then I guess ~15 for the tests
[21:16:34] <lkuper> (building to stage2)
[21:16:48] *** Joins: jgilbert (jgilbert@2557E599.66715431.D25A875A.IP)
[21:16:49] <strcat> lkuper: browsers use a lot of memory ;p
[21:17:09] <lkuper> strcat: I suppose especially when using something like hangouts
[21:17:12] <strcat> lkuper: http://ix.io/5mt
[21:17:23] <strcat> lkuper: if you're on linux, that will show you the order the oom killer will murder stuff
[21:17:32] <lkuper> but I was also building on my laptop with 4 GB and didn't seem to have any trouble
[21:17:39] <strcat> it uses RES + SWAP basically, if you aren't using oom_score_adj
[21:17:47] <Luqman> strcat: all 3 stages in 12mins? what do you build on?
[21:17:48] *** Joins: dherman (dherman@2557E599.66715431.D25A875A.IP)
[21:17:48] *** ChanServ sets mode: +o dherman
[21:17:59] <strcat> Luqman: ivy bridge laptop CPU
[21:18:27] <strcat> it takes ~50% longer on an 8-core nehalem xeon because it's clocked lower ;p
[21:18:41] *** Quits: jorendorff (jorendorff@moz-1747FB68.hsd1.tn.comcast.net) (Quit: jorendorff)
[21:18:51] <strcat> well, I think it's really a dual socket machine
[21:19:01] * strcat would have to check cpuinfo
[21:19:49] <lkuper> I think it would be responsible of us to suggest more than 2 GB if you want to be able to do other things and/or not have the build take hours
[21:20:08] <strcat> or we could fix the memory usage :)
[21:20:11] <cmr> the build takes about 1.4-1.6GB of memory
[21:20:36] <jaen> when I was doing Java 8GB was not enough, the laptop freezing to the point of non-usability
[21:20:38] <strcat> cmr: it peaks at ~2GiB
[21:20:40] <cmr> so the prerequisites should probably say "2GB RAM available for the build process"
[21:20:41] <jaen> so I don't think it's that bad
[21:20:41] <strcat> librustc
[21:21:00] <lkuper> cmr: yeah, something like that
[21:21:56] <lkuper> in the meantime perhaps I'll suggest that astrieanna and I use IRC rather than hangouts :D
[21:22:06] <cmr> heh, yeah
[21:23:44] <bjz> graydon: https://github.com/mozilla/rust/pull/6333#issuecomment-17634772
[21:24:32] <lkuper> cmr: so it takes 6 hours on your 1 GB machine?  swapping frantically?
[21:24:44] <cmr> lkuper: for all 3 stages, yes.
[21:25:06] <cmr> I've only done that build once, while I was sleeping...
[21:25:13] <lkuper> cmr: I'm impressed it works at all and/or that you're that patient
[21:25:14] <lkuper> ah
[21:25:55] <strcat> can use something like zswap ;p
[21:26:20] <strcat> or zram
[21:28:02] <cmr> https://gist.github.com/cmr/76abad9f3e253fe0ad8b/raw/2312d52075f2d9d14da8b66c845ade6ef8b6dc02/gistfile1.txt
[21:28:14] <cmr> Should the span cover "mut" instead?
[21:28:25] <cmr> Or both mut and the varname
[21:28:50] <benh> The variable is the subject of the error message, so it seems fair that it's being pointed at
[21:29:28] <cmr> it'd be cool to have a span point at a specific character but be able to expand left and right
[21:29:47] <benh> with let mut x = 1, y = 2; pointing at mut would be unclear i guess
[21:30:09] <cmr> rusti: let mut x = 1, y = 2; y
[21:30:12] <rusti> more than 5 lines of output, pastebinned: http://sprunge.us/PMUZ
[21:30:29] <cmr> hmm, good point.
[21:30:37] <cmr> I didn't think of that case
[21:30:38] <lkuper> strcat: how much ram for that 12-minute build?
[21:30:59] * lkuper wants to give people a rough idea of how long a build takes on the getting started page
[21:31:48] <cmr> https://gist.github.com/cmr/0457a4249967b34e9e06/raw/4de54e44abe20ca94ad5120bef0115501b1d7126/gistfile1.txt
[21:31:53] <cmr> "mismatched types: expected `[type error]` but found an enum or structure pattern"
[21:32:05] <benh> heh
[21:32:07] <cmr> It seems silly to continue going on after the error that causes inference to fail
[21:32:09] <steven_is_false> So I just made a tiny change to libcore/util.rs but now I'm getting nearly everything else recompiled. Is there any way to not have this happen?
[21:32:15] <benh> expected type error? well here you go then!
[21:32:30] <cmr> steven_is_false: unfortunately not
[21:32:59] <steven_is_false> cmr: So I'll have to just deal with it until incremental building happens?
[21:33:01] <cmr> yet, at least.
[21:33:04] <cmr> steven_is_false: yup
[21:33:12] <steven_is_false> cmr: Okay.
[21:33:40] *** Joins: ssbr_ (ssbr@moz-2E1A56C2.wireless.utoronto.ca)
[21:33:56] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[21:34:08] <Flibo> i'm trying to install rust on a windows machine, do i just add C:\Rust to the path in MSYS and i should be good to go?
[21:34:44] <EXetoC> are those character modifiers for the vim scripts intentional? can't remember
[21:34:52] <strcat> lkuper: well it's a mid-range ivy bridge cpu with 8GiB of memory, but I don't think it really benefits from having everything cached
[21:35:04] <strcat> it's just incredibly slow if you have >3GiB of memory
[21:35:14] <strcat> <3GiB, I mean ;p
[21:35:19] <EXetoC> s/for/in
[21:35:37] <strcat> lkuper: librustc definitely peaks a bit above 2GiB
[21:35:42] <cmr> strcat: I don't understand how your laptop can build faster than my ivy bridge xeon box (clocked at 3.7ghz)
[21:36:09] <strcat> cmr: dunno. how long does it take you? (I'm not including the tests)
[21:36:20] <cmr> I'm doing a timing run now
[21:36:38] <strcat> timing make?
[21:36:46] <Luqman> strcat: 12 min for optimized or not?
[21:36:46] <cmr> time make -j8, specifically
[21:36:53] <strcat> cmr: the rust build is serial
[21:37:00] <cmr> the llvm one isn't :p
[21:37:16] <Luqman> also, if you're building other targets
[21:37:19] <strcat> cmr: I'm not including LLVM, just what it takes to rebuild stage0, stage1 and stage2
[21:37:19] <cmr> nor libuv
[21:37:40] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[21:37:42] *** bhearsum is now known as bhearsum|afk
[21:37:48] <strcat> I don't have to rebuild LLVM on 90% of the builds so I don't know how long that takes
[21:38:21] <lkuper> I'm doing a timing run myself, including LLVM
[21:38:35] <steven_is_false> Okay bye guys
[21:38:37] *** Quits: steven_is_false (quassel@moz-144077DE.bchsia.telus.net) (Client exited)
[21:38:55] <lkuper> oh, I forgot -j :/
[21:38:58] <strcat> lkuper: well, LLVM's build basically scales with the # of cores
[21:39:29] <lkuper> probably not if you forget -j
[21:39:33] <strcat> lkuper: right :)
[21:39:41] <strcat> -j will make you go oom :), need a limit on it
[21:39:53] <Luqman> not if you have enough memory :P
[21:40:02] <strcat> 128GiB? ;p
[21:40:06] <cmr> Someone asked the other day why libcore/libstd/libsyntax etc couldn't build in parallel, but I don't remember a reason why. Was there?
[21:40:14] <benh> Most build systems seem to guess a reasonable number for -j :(
[21:40:19] <strcat> cmr: libstd depends on libcore
[21:40:21] <Luqman> strcat: 192*
[21:40:26] <strcat> libsyntax depends on libstd
[21:40:30] <strcat> librustc depends on libsyntax
[21:40:38] <strcat> entirely serial from a crate standpoint
[21:40:40] <cmr> ah
[21:40:54] <lkuper> I have 4 cores with hyperthreading, 2 without; I'm never sure if that means I should do -j2 or -j4
[21:41:11] <cmr> lkuper: -j4 usually brings a modest speedup
[21:41:17] <strcat> lkuper: chrt to SCHED_BATCH and use -j8
[21:41:42] <strcat> lots of it is I/O bound
[21:42:00] <strcat> if you don't build it in tmpfs ;p
[21:42:05] <cmr> strcat: what does that do?
[21:42:12] <lkuper> hm
[21:42:25] <strcat> SCHED_BATCH? it's a different scheduler queue
[21:42:31] <strcat> it uses longer time slices so it's better for throughput
[21:42:35] <strcat> but terrible for interactive stuff
[21:42:52] <cmr> that's handy
[21:43:04] <lkuper> I wonder what the buildbots use
[21:43:06] <benh> hm
[21:43:10] <benh> clearly make should set that :(
[21:43:20] *** Quits: jdm (jdm@F2D29657.F60B0462.67AC9B1.IP) (Ping timeout)
[21:44:27] <strcat> sometimes I like SCHED_IDLE for builds though ;p
[21:44:42] <cmr> strcat: where can documentation about these be found?
[21:44:50] <cmr> chrt(1) isn't very helpful
[21:45:10] <benh> sched_setscheduler(2) is slightly more so
[21:45:21] <strcat> probably the kernel docs
[21:45:24] <strcat> sec
[21:45:36] <cmr> so it is!
[21:45:41] <cmr> I was looking at sched_setscheduler(3p)
[21:45:47] <cmr> which, as usual, was pretty useless
[21:46:02] <strcat> https://www.kernel.org/doc/Documentation/scheduler/sched-design-CFS.txt
[21:46:07] <strcat>   - SCHED_BATCH: Does not preempt nearly as often as regular tasks
[21:46:09] <strcat>     would, thereby allowing tasks to run longer and make better use 
[21:46:10] <benh> cheers
[21:47:00] <strcat> seems that it was written ages ago though
[21:47:20] <strcat> but the idea is that SCHED_BATCH jobs don't care about latency
[21:47:44] <strcat> so the scheduler context switches a lot less often
[21:48:28] <Luqman> so it takes me ~15 to build rust not counting llvm 
[21:48:43] <strcat> Luqman: what hardware do you have?
[21:48:56] <cmr> It takes me 8:30 to get to stage2 where it promptly dies because of my in-progress patch :p
[21:49:12] <Luqman> strcat: i7-3720QM
[21:49:16] <Flibo> any windows users? how do you use the REPL?
[21:49:42] <cmr> Flibo: rusti? it's mostly broken, but it should be rusti.exe
[21:49:44] <strcat> Luqman: ah that makes sense, it probably doesn't turbo up as high for the 1-core tasks as a dual core
[21:49:56] <strcat> or maybe it does....
[21:49:59] <strcat> dunno :)
[21:50:10] *** Quits: ksev (DrunkenPan@CB7DAFF1.B919BE8A.47C41102.IP) (Ping timeout)
[21:50:12] <strcat> there's an i7z tool for watching it
[21:50:16] *** Joins: ksev (DrunkenPan@CB7DAFF1.B919BE8A.47C41102.IP)
[21:50:27] <Flibo> i don't have it, the only exe i see is rustc.exe
[21:51:03] *** Joins: jdm (jdm@F2D29657.F60B0462.67AC9B1.IP)
[21:51:38] <kimundi> Flibo: The windows package is broken insofar as it doesn't contain anything else than rustc
[21:51:44] <Luqman> strcat: max turbo frequency is supposedly 3.6
[21:51:47] <Flibo> oh i see
[21:52:18] <strcat> Luqman: my desktop has an i7-2600k that I overclocked quite a bit, but I haven't actually tried building rust on it :(
[21:52:32] <strcat> just on this mid-range-ish i5 in my laptop
[21:53:29] <strcat> my desktop is at 5GHz before turbo ;p
[21:53:34] <strcat> which is about a 30% overclock
[21:53:57] * strcat thinks turbo is off though
[21:54:02] <cmr> yowzer!
[21:54:18] <cmr> does that actually help a lot? I imagine you'd be severely memory-bound by that point
[21:54:26] <cmr> (memory speed, that is)
[21:54:47] <strcat> cmr: well it still scales directly for stuff like compiling and encoding
[21:55:37] <strcat> anyway overclocking is boring now
[21:55:56] <strcat> you pay extra for the k cpu, you buy a 50 dollar heatsink, and you bump up the multiplier ;p
[21:57:50] * lkuper added a word of warning at https://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust#memory-usage
[21:58:09] <lkuper> (edits welcome if anyone has timing anecdata to add)
[21:58:09] <strcat> for some reason it seems that the k series all have no VT-d
[21:58:14] <strcat> I guess that's their way of making you get a xeon
[21:58:20] <cmr> that's why I got a xeon
[21:58:30] <cmr> (that and it had hyperthreading for cheaper than an i7)
[21:58:44] <strcat> I think hyperthreading is actually a waste
[21:58:54] <cmr> basically it's an unoverclockable i7 without a gpu
[21:59:02] <strcat> afaik if you turn it off you can overclock 10-15% at the same power usage (so the same heat)
[21:59:13] <strcat> and it never benefits anything I do
[21:59:41] <cmr> for the price of an i5
[21:59:50] <cmr> I thought it was a good traedof at the time but now I'm not so sure
[21:59:59] <strcat> cmr: well none of their CPUs are overclockable now, except the k series
[22:00:06] <cmr> when I upgrade in a few years I probably won't make the same decision
[22:00:51] <jaen> Incidentally is there any plan to make rust repl not suck and be more like, I don't know pry or someting, or it's still somewhat up in the air?
[22:00:57] <jaen> Because I cry every time I can't use rusti
[22:01:02] <strcat> their artificial product line segmentation is now enforced pretty well ;p
[22:01:07] <cmr> jaen: yes
[22:01:15] <mcpherrin> jaen: yeah, there were some mailing list psots recently about having it not suck
[22:01:41] <aatch> jaen, it would be nice for it to be working again.
[22:01:58] <jaen> Oh, that sounds nice, playing with haskells, rubies and clojures I got all reply
[22:02:06] <jaen> And it was first thing I tried with rust
[22:02:17] <aatch> But it is lower-priority that a lot of other things
[22:02:27] <cmr> For example, a working compiler :p
[22:02:31] <jaen> figures ; d
[22:03:00] <lkuper> jaen: there's a plan to make a plan to make rusti not suck.
[22:03:36] <strcat> even when it did work it was ridiculously slow and still couldn't run everything
[22:03:51] <strcat> cling is not *nearly* that slow ;p
[22:03:54] <cmr> well speed isn't exactly the main focus of a repl for a /static/ language
[22:04:13] <strcat> cmr: it took a noticeable amount of time to compile even trivial stuff.
[22:04:42] <otters> ghci is the reincarnation of jesus christ
[22:04:49] <lkuper> jaen: I brought it up on the mailing list a couple of weeks ago and got a couple of people showing interest.  step one is to write tests.  in fact, today astrieanna wrote what is as far as I know the first-ever test for librusti.
[22:05:04] <jaen> I'd love to help if I thought I were up to the task, but probably that's beyond me ; /
[22:05:19] <cmr> jaen: tests are the main thing needed right now
[22:05:55] <jaen> Last time I tried to test I gave up not knowing how to mock a search engine ~~'
[22:05:57] <aatch> I haven't investigated the JIT backend of rustc
[22:06:08] <jaen> Though I imagine it's way easier to test on low-level
[22:06:14] <aatch> I'm too scared...
[22:06:25] <aatch> jaen, I feel your pain.
[22:06:43] <lkuper> jaen: we don't know what we're doing either.  we're kinda flying by the seat of our pants.  I've only ever worked on rustc, not any of the libraries/tools.
[22:07:04] <lkuper> but we have a test, and now we're going to make that test test something useful!
[22:07:25] <tristram> you have my full moral support for rusti
[22:07:42] <lkuper> and then, we'll write ...ANOTHER test!
[22:07:54] <strcat> lkuper: maybe looking at how cling does it would be helpful -> http://root.cern.ch/drupal/content/cling
[22:08:03] <lkuper> strcat: cling is interesting
[22:08:03] <jaen> That's testacular, if you forgive the pun.
[22:08:11] <strcat> lkuper: afaik it's not that much code
[22:08:28] <aatch> tristram, "moral" support might get in the way. What if they need to do something immoral to get it to work?
[22:08:37] <lkuper> strcat: so, right now rusti is based on the JIT backend
[22:08:56] <lkuper> strcat: it literally just takes what the user types and wraps it in a main function that it gins up
[22:09:08] *** Joins: steven_is_false (quassel@1E3F14AE.29819A33.115CE8E4.IP)
[22:09:12] <lkuper> this doesn't seem right
[22:09:13] <tristram> aatch: ;) be immoral if needed! Its just I could hardly help myself
[22:09:22] <lkuper> I mean...maybe there's a more principled way to do it
[22:09:24] <strcat> lkuper: yeah that's not right. what if you make an error?
[22:09:25] <kimundi> I have a terminology question. If compilation starts with parsing and produces an AST, how would one call the remaining parts that start with consuming the AST?
[22:09:30] <aatch> tristram, or you meant morale?
[22:09:30] <strcat> lkuper: does it break it forever?
[22:09:51] <aatch> kimundi, compilation passes
[22:09:55] <strcat> afaik it has to keep track of the state itself
[22:09:58] <cmr> aatch: ping
[22:10:03] <aatch> cmr, pong
[22:10:03] <tristram> aatch: maybe im doing a terrible translatino from a french expresion :/
[22:10:06] <lkuper> strcat: yeah, error handling in the repl should definitely not work like it does for rustc
[22:10:13] <cmr> tristram: no, aatch was just poking fun
[22:10:16] <steven_is_false> I'm so annoyed struct Void (~Void); doesn't work. That the type is uninhabitable is the whole point!
[22:10:33] <lkuper> strcat: for example, you shouldn't get unused variable warnings
[22:10:49] <strcat> what's funny is that cling uses the same semicolon thing as rust
[22:10:49] <aatch> lkuper, there might be a way around that.
[22:10:57] <benh> steven_is_false: How about struct Void(SomePrivTypeI'mNotReexporting)?
[22:10:57] <cmr> aatch: So the vim indentation indents 'match' incorrectly. For example, match foo {\n Some(x) => bar,\n None => baz \n}
[22:11:02] <strcat> leaving off the semicolon makes it print what that expression evaluated to
[22:11:05] <kimundi> steven_is_false: err, but that definiion would be in infinite size...
[22:11:06] <cmr> aatch: the None line will be indented a level from the Some line
[22:11:11] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[22:11:11] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/sj_J7A
[22:11:11] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[22:11:16] <aatch> cmr, I know, I've hit a few times
[22:11:16] <steven_is_false> kimundi: Note the ~.
[22:11:20] <cmr> aatch: not sure if it's easy to fix or even worth fixing
[22:11:26] <lkuper> aaactually, if I understood anything at all about the condition system, maybe it's the principled way to go about this
[22:11:29] <aatch> I'll get around to fixing it some time.
[22:11:31] <kimundi> steven_is_false: Yes, because the ~
[22:11:42] <benh> Does anyone know what toggle in the vim config I need to flip to get struct members not to unindent themselves as soon as I type the :?
[22:11:46] <kimundi> steven_is_false: Pointers take up space too :P
[22:12:00] *** Joins: azita (Azita@2557E599.66715431.D25A875A.IP)
[22:12:02] <benh> kimundi: but finitely so
[22:12:12] *** Joins: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net)
[22:12:34] <aatch> steven_is_false, how would you construct a Void(~Void)?
[22:12:51] <strcat> needs an Option in there
[22:12:53] <benh> You wouldn't, that's the point :D
[22:12:54] <steven_is_false> aatch: You wouldn't that's the point.
[22:12:55] <kimundi> benh: Not if the definition includes itself, like here.......... wait that doesn't make sense. steven_is_false, benh foret what I said
[22:13:12] <aatch> steven_is_false, then what use is it?
[22:13:20] * kimundi is also to tired at this point
[22:13:37] <steven_is_false> aatch: Consider Either<Void, T>. that's equivalent to simply T.
[22:13:51] <aatch> steven_is_false, yes...
[22:13:56] <steven_is_false> I plan on using it for phantom types also.
[22:14:08] <aatch> phantom types?
[22:14:14] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[22:14:14] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/ir31gw
[22:14:14] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[22:14:17] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[22:14:17] <ghrust> 01[13rust01] 15bors pushed 25 new commits to 06auto: 02http://git.io/NUcmiQ
[22:14:17] <ghrust> 13rust/06auto 14a91b55e 15Patrick Walton: libstd: Remove mutable fields from fileinput and net_tcp
[22:14:17] <ghrust> 13rust/06auto 14ba2ce0f 15Patrick Walton: libstd: Remove mutable fields from flatpipes and io_util
[22:14:17] <ghrust> 13rust/06auto 148ff0194 15Patrick Walton: libstd: Remove mutable fields from future and par
[22:14:17] <cmr> rusti: Either<(), int>
[22:14:18] <rusti> foo.rs:5:18: 5:19 error: expected `;` or `}` after expression but found `,`
[22:14:18] <rusti> foo.rs:5          Either<(), int>
[22:14:18] <rusti>                            ^
[22:14:19] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[22:14:28] <lkuper> kimundi: well, the names of those compiler passes depend on what the compiler does, that is, what language is being compiled
[22:14:53] *** jdm is now known as jdm|away
[22:14:54] <steven_is_false> aatch: Consider a Program <T> type where T might be Compiled, or Uncompiled.
[22:15:01] <lkuper> kimundi: rustc has a typechecking pass, a name resolution pass, ...
[22:15:09] <steven_is_false> aatch: Compiled, and Uncompiled would be defined like struct Compiled(Void);
[22:15:15] <aatch> steven_is_false, enum
[22:15:29] <steven_is_false> aatch: This is a type level enum not a data level enum
[22:15:38] <kimundi> steven_is_false: You can just do 'struct Compiled;'
[22:15:49] <kimundi> UNless I'm missing something
[22:15:57] <aatch> kimundi, no, that's right
[22:16:01] <steven_is_false> kimundi: But then it is inhabited, and I'll be exporting stuff I don't need to export.
[22:16:03] <aatch> It's an opaque struct
[22:16:13] <cmr> What does inhabited mean?
[22:16:27] <strcat> rusti: struct Foo; sys::size_of::<Foo>()
[22:16:28] <rusti> 0
[22:16:29] <kimundi> steven_is_false: Ah, so a struct thats not constructable
[22:16:49] <strcat> well it won't be exported if it's not pub
[22:16:50] *** Quits: int3_ (int3_@moz-432A7121.public.wayport.net) (Ping timeout)
[22:16:55] <lkuper> kimundi: you might have some analysis and optimization passes in there, too
[22:16:57] <strcat> if it's not pub you can't construct it yourself
[22:17:12] <steven_is_false> strcat: But then I have to do struct Compiled { priv contents : () } which is right back to what I had earlier.
[22:17:18] <aatch> strcat, can you even construct opaque types safely?
[22:17:22] <strcat> steven_is_false: no you don't
[22:17:30] <strcat> steven_is_false: structs themselves can be pub/priv
[22:17:34] <strcat> by default they're private
[22:17:44] *** Joins: int3_ (int3_@9A375198.26321F00.F7721B25.IP)
[22:17:45] <steven_is_false> strcat: I want to export the typename but not the data instance.
[22:17:52] *** Quits: victorporof (victorporo@90976241.6D2FB7A4.79933D60.IP) (Quit: victorporof)
[22:18:16] <aatch> steven_is_false, I'm not sure if what you are talking about makes sense.
[22:18:57] <steven_is_false> aatch: Well surely you understand the concept even if you might argue it's of little use.
[22:19:20] <aatch> steven_is_false, I don't understand the concept you're trying to convey.
[22:19:48] <aatch> More accurately, I don't understand why `struct Foo;` doesn't suit your needs.
[22:19:57] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Quit: Leaving.)
[22:20:06] <strcat> steven_is_false: http://ix.io/5y1 is it really any different than this
[22:20:09] <steven_is_false> aatch: I told you it exports a constructor which shouldn't be exported.
[22:20:11] <kimundi> aatch: It makes sense. It would mean that you couldn't construct the type in usercode, but pass it along and work with it if you get it from the libary
[22:20:12] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[22:20:15] <strcat> steven_is_false: it doesn't
[22:20:20] <aatch> steven_is_false, no it doesn't
[22:20:23] <strcat> if it's not pub you can't construct it in other modules
[22:20:24] <cmr> strcat: lkuper: 17:37 for a full build
[22:20:37] <aatch> how do construct something that doesn't have a size?
[22:20:37] <cmr> chrt -b 0 make -j8  1149.95s user 30.41s system 111% cpu 17:37.49 total
[22:20:40] <strcat> you can still end up with one if the module constructs it
[22:20:41] <steven_is_false> strcat: But the type name isn't exported in that case.
[22:21:16] <strcat> steven_is_false: yeah, they can't refer to the type name but they can still store it
[22:21:27] <kimundi> aatch: struct Foo; let f = Foo;
[22:21:28] <steven_is_false> strcat: That's actually an annoying thing about Rust where it lets one export a function but not the type name of it's argument, or result.
[22:21:41] <aatch> rusti: struct Foo; let f Foo;  f
[22:21:41] <rusti> foo.rs:5:27: 5:30 error: expected `;` but found `Foo`
[22:21:41] <rusti> foo.rs:5          struct Foo; let f Foo;  f
[22:21:41] <rusti>                                     ^~~
[22:21:47] <aatch> rusti: struct Foo; let f = Foo;  f
[22:21:48] <rusti> {}
[22:21:59] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Ping timeout)
[22:22:06] <steven_is_false> strcat: Anyways new is the wrong function. One would want fn absurd (Void) -> !
[22:22:41] <tristram> https://gist.github.com/Tristramg/5543989 << I have troubles understanding why HashMap::get asks me for a &&a type
[22:22:53] *** Joins: devinus (devinus@moz-BED25650.austincc.edu)
[22:23:21] <strcat> tristram: because the key is &N
[22:23:29] <strcat> hashmap's find function takes &K
[22:23:30] <kimundi> lkuper: Hmm. Basically I'm looking for a pair of names for '&str -> CompiledRegularExpression' and ''AST -> CompiledRegularExpression
[22:23:41] <strcat> and K is &N
[22:24:26] <tristram> oh ! thanks
[22:24:28] <lkuper> kimundi: does the first call the second?
[22:24:44] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[22:24:53] <strcat> the get method is kind of pointless since it just wraps .find() and makes it fail with a generic error message on None
[22:24:57] <strcat> much like .unwrap()
[22:25:08] <strcat> or .expect("I care enough to give a real error message") ;p
[22:25:28] <aatch> strcat, it is a little nicer when you are sure that it exists.
[22:25:36] <tristram> yeah, I found out that, but in this case, not finding would mean there is a bug in my code
[22:25:37] <aatch> (or least, sure that it should)
[22:25:38] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Quit: Leaving)
[22:25:39] <lkuper> kimundi: I'd call the first "compile" and the second "translate", perhaps.  or I'd write one called "compile" and I'd have it call "parse" with type &str -> AST and then pass the result of that to "translate" with type AST -> CompiledRegularExpression
[22:25:44] <kimundi> lkuper: It might, but it doesn't have too. Basically its for providing two different enrtypoints in the pipeline but both end with a Compiled Object
[22:26:05] <strcat> aatch: .find().unwrap() is less painful than an API that's twice as big, impo
[22:26:07] <strcat> imo*
[22:26:17] <aatch> strcat, fair enough.
[22:26:27] <strcat> .pop, .swap, etc. are missing an equivalent to get
[22:26:42] <tristram> so now it complains it returns and &bool, so I cannot negate it (!), what would be the cleanest approach ?
[22:26:48] <aatch> I don't really notice most of the time though.
[22:26:54] <strcat> tristram: dereference it
[22:26:56] <aatch> tristram, deref the bool?
[22:27:23] <aatch> !*map.get(&thing)
[22:27:26] <lkuper> kimundi: or "parse" and "generate", perhaps.  it depends what's involved.
[22:27:34] <kimundi> lkuper: Can't do &str->AST->CRE because that would lock users to the buildin AST format. Want to allow both custom AST-compilation and custom parser
[22:27:42] <tristram> I have mixed feeling, I play way much with pointers, refs, derefs than in production C++ code
[22:27:53] <tristram> thanks for the help
[22:28:05] <strcat> tristram: not really true
[22:28:10] <strcat> std::map's find returns an iterator
[22:28:10] <zq> all your ltin and marilyn crap
[22:28:13] <zq> omfg
[22:28:16] <strcat> you have to check it against .end()
[22:28:17] <zq> stop switching my window
[22:28:33] <lkuper> kimundi: I see.  well, in any case "translate" or "generate" might be suitable
[22:28:51] <strcat> and it takes a key by const &
[22:29:01] <tristram> strcat: true indeed (I guess I have that feeling because Im not sure what Im doing ;) )
[22:29:12] <lkuper> kimundi: here's a gist with the names of all the passes from a compiler I worked on.  might provide inspiration. https://gist.github.com/lkuper/5544089
[22:29:14] <aatch> tristram, don't worry about it in Rust. The compiler generally tells you if you are trying to do something bad.
[22:29:42] <strcat> well if it don't use unsafe you can't get memory safety wrong ;p
[22:29:45] <tristram> yes! I appreciate a lot decent compiler messages
[22:29:49] *** Quits: devinus (devinus@moz-BED25650.austincc.edu) (Ping timeout)
[22:30:02] * aatch would like more decent error messages
[22:30:38] <strcat> rusti: 5.clone()
[22:30:40] <rusti> more than 5 lines of output, pastebinned: http://sprunge.us/OeRT
[22:31:03] *** Quits: lkuper (lkuper@moz-D6AAFF3.cs.indiana.edu) (Ping timeout)
[22:31:16] <aatch> I still get surprised when Rust code I write compiles first time, I understand the borrow checker pretty well now but still expect to get it wrong.
[22:31:23] <tristram> if they fit in my console buffer history and I can scroll back to the first line, its already better than g++ ;)
[22:31:55] <strcat> tristram: well rustc's life is easier
[22:31:56] <aatch> tristram, that's because most of the messages bail out of the compiler.
[22:32:01] <strcat> generics are type-checked on definition
[22:32:17] <strcat> C++ templates have to be type checked for each instantiation, and they don't convey *anything* about intent/concepts
[22:32:24] <aatch> I love that feature.
[22:32:32] <strcat> unless you sprinkle 1000 static_asserts around and that still doesn't really help
[22:32:40] *** Joins: devinus (devinus@moz-BED25650.austincc.edu)
[22:32:49] *** Quits: solancile (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net) (Quit: Leaving)
[22:32:50] <aatch> Since it means I can know that a function will work for any instantiation.
[22:33:53] *** Joins: raze (raze@moz-4E6675AF.bredband.comhem.se)
[22:34:03] <tristram> anyway, Im glad I choose graphs to play with rust, I stumble on many different aspects of the language
[22:36:41] <TD-Linux> C++11 actually makes iterators usable at least
[22:39:07] *** Quits: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net) (Quit: Computer has gone to sleep.)
[22:39:55] <strcat> TD-Linux: in specific cases
[22:39:58] <strcat> they still don't compose
[22:40:09] <strcat> maybe one day they'll standardize Boost.Range
[22:41:38] *** Quits: webber46 (webber46@moz-F6310FF0.lha.sgsnet.se) (Quit: webber46)
[22:43:54] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[22:45:47] *** Quits: jeff (jeff@69765D56.D8FB3E69.FCBF9AFD.IP) (Quit: jeff)
[22:46:11] *** Joins: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net)
[22:48:14] *** Joins: mib_l1b4vk (Mibbit@moz-70A5EBB1.dsl.mweb.co.za)
[22:48:15] *** Quits: Scriptor (historium@moz-E06F46F0.corp.bitshelter.com) (Quit: Scriptor)
[22:48:36] *** Joins: jorendorff (jorendorff@moz-30F4FB9E.hfc.comcastbusiness.net)
[22:50:05] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[22:52:38] *** Quits: ssbr_ (ssbr@moz-2E1A56C2.wireless.utoronto.ca) (Ping timeout)
[22:53:16] *** Quits: Mowah (Mowah@moz-59D1A475.cust.bredbandsbolaget.se) (Ping timeout)
[22:53:49] *** Quits: Jesin (Jessin_@moz-A03A364F.cc.lehigh.edu) (Ping timeout)
[22:53:50] <steven_is_false> Bye
[22:53:52] *** Quits: steven_is_false (quassel@1E3F14AE.29819A33.115CE8E4.IP) (Client exited)
[22:53:57] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[22:54:18] <Jeaye> o.O
[22:56:11] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Ping timeout)
[22:58:21] *** Quits: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net) (Quit: Computer has gone to sleep.)
[23:01:53] <ssbr> kimundi: it occurs to me that the requirement "force re!() to be statically compiled" might be satisfied by assigning the result to a static item
[23:02:28] <ssbr> kimundi: "static regexp : CompiledRegexp = re!(...)" would only succeed if re!() can do its work at compile time
[23:02:38] <ssbr> if re!() is designed right
[23:02:58] <kimundi> hmm.. not sure if that would work
[23:03:19] *** Quits: mib_l1b4vk (Mibbit@moz-70A5EBB1.dsl.mweb.co.za) (Quit: http://www.mibbit.com ajax IRC Client)
[23:03:52] <aatch> ssbr, why not just say that re! is always statically compiled?
[23:04:12] <ssbr> kimundi: that's another option
[23:04:17] <kimundi> ssbr: I'm thinking of an additional annotation you'd put in the re!() invokation: https://gist.github.com/Kimundi/5543809
[23:04:19] <ssbr> or giving re!() a flag to force static compilation
[23:04:30] <ssbr> er, sorry, aatch 
[23:04:40] <ssbr> I don't really have any opinion as to what's "best" at all.
[23:04:48] <aatch> why not have re! be static compiled and have a different function for runtime compilation?
[23:04:51] <aatch> That's what D does
[23:05:04] <kimundi> aatch: Because that doesn't always work, and the question is what to allow how.
[23:05:05] <ssbr> kimundi: ^
[23:05:09] <ssbr> der
[23:05:13] <aatch> regex(re) vs staticRegex!(re)
[23:05:15] <ssbr> kimundi: why doesn't it always work?
[23:05:19] *** Quits: disjukr (disjukr@D4D5F731.A5F7C7E2.84F431B6.IP) (Connection reset by peer)
[23:05:21] *** Quits: devbug (quassel@moz-E1DE087C.bchsia.telus.net) (Connection reset by peer)
[23:05:21] *** Joins: devbug_ (quassel@moz-E1DE087C.bchsia.telus.net)
[23:05:30] *** Joins: disjukr (disjukr@D4D5F731.A5F7C7E2.84F431B6.IP)
[23:05:40] <aatch> You only allow literal strings in the re! version.
[23:06:01] *** Quits: devinus (devinus@moz-BED25650.austincc.edu) (Quit: Computer has gone to sleep.)
[23:06:01] <kimundi> ssbr: Ah, I just mean things like a non static re string or custom engines
[23:06:18] <aatch> kimundi, then you don't use re! syntax extension
[23:06:32] *** Joins: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net)
[23:06:33] <ssbr> kimundi: sure, but having the syntax extension only do complete compile time work is not too unreasonable
[23:06:50] <ssbr> aatch: what about the case of parsing at compile time, but compiling at run time?
[23:07:19] <aatch> ssbr, how often would that come up?
[23:07:20] <kimundi> Yeah, but if the syntax extension can do both you don't need to refactor your codebase if you switch from one to tho other
[23:07:31] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[23:07:40] <aatch> http://dlang.org/std_regex.html
[23:07:55] <ssbr> aatch: I'm not sure. It would happen if you pass in variable flags that don't affect parsing, but do affect compilation; or if you select a regexp engine dynamically, or one which isn't built-in
[23:08:17] <ssbr> kimundi: if it's just removing a ! maybe the refactor isn't so huge a deal
[23:08:21] *** Joins: ssbr_ (ssbr@A9D9D38C.B6F034AC.72A31D6.IP)
[23:08:22] <ssbr> well
[23:08:30] <ssbr> removing the ! and changing the return type I suppose
[23:08:30] <aatch> You guys are over thinking this.
[23:08:43] <kimundi> aatch: Is that in D an actual design decission, or an artifact of not being able to decide that it compiletime?
[23:08:59] <ssbr> (well, even the return type is...)
[23:09:12] <kimundi> aatch: What's wrong with thinking of an unified api?
[23:09:22] *** Quits: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com) (Client exited)
[23:09:30] <ssbr> kimundi: TBH it's not clear to me that a unified API is desirable
[23:09:32] <strcat> I thought re! was going to parse/compile and output an object you can use at compile-time
[23:09:41] <strcat> I mean runtime
[23:09:43] * strcat sighs
[23:09:46] *** Joins: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com)
[23:09:49] <ssbr> in that the benefit of easier refactoring might be offset by the downside of not knowing what it does
[23:09:53] <ssbr> (compile vs runtime work)
[23:10:03] <aatch> kimundi, nothing, but you are so focussed on this "unified API" that you seem to be missing the point
[23:10:18] <kimundi> strcat: In optimum case yes. but what if you want to plugin an custom parser, or compiler, or put in an non-static string?
[23:10:22] <ssbr> (and compile vs runtime work are different in what errors they can raise, etc. etc.)
[23:10:25] <strcat> why would there just be re!(literal) (compile-time) and re(slice) (runtime)
[23:10:34] <aatch> kimundi, how often do you need to do that though?
[23:10:35] <strcat> kimundi: you don't have to worry about that
[23:10:38] <kimundi> aatch: what point am I missing?
[23:10:51] <aatch> When was the last time you plugged in a custom regex engine to something?
[23:10:55] <strcat> if someone wants to use re2 or another engine/parser they can do it
[23:10:59] <ssbr> kimundi: then you go from re!() to re()
[23:11:06] <strcat> it doesn't factor into the design decisions for a built-in one afaict
[23:11:25] <aatch> kimundi, that people want simplicity and speed, not infinite customisability
[23:11:25] *** Quits: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com) (Ping timeout)
[23:11:43] <strcat> re2 or pcre isn't going to reuse any of a built-in regexp impl in rust
[23:12:07] <kimundi> aatch: But this does not decrease speed, and increase simplcity...
[23:12:26] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[23:12:48] <aatch> kimundi, syntax extension have no type information available except for literal expressions
[23:13:13] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[23:13:36] <kimundi> aatch: I was told otherwise. IF that was wrong information, then yes this would pose a problem
[23:13:53] <strcat> syntax exts just deal with tokens afaik
[23:13:53] <ssbr> strcat: in fairness, they might be able to reuse the parser
[23:13:57] <strcat> and output more tokens
[23:14:02] <strcat> ssbr: why?
[23:14:08] *** Joins: devinus (devinus@moz-BED25650.austincc.edu)
[23:14:12] <strcat> different regexp implementations have different grammars
[23:14:15] <aatch> strcat, they output AST
[23:14:17] <ssbr> strcat: why would they do such a thing, or how would they want to?
[23:14:26] <strcat> ssbr: what's the use case
[23:14:44] <ssbr> strcat: using a different regexp engine because it's faster
[23:14:59] <strcat> ssbr: if it's faster it should be the default
[23:15:12] <ssbr> strcat: no regexp engine is fastest for every regex
[23:15:31] <strcat> ssbr: so where are these regexp engines with pluggable grammars?
[23:15:31] <ssbr> but it's hopefully not an issue, you're right.
[23:15:42] <ssbr> strcat: I wrote one
[23:15:47] <ssbr> but that's because I wanted pluggable grammars
[23:16:00] <strcat> design decisions in the engine are often reflected in the grammar itself
[23:16:04] <ssbr> (I wanted to define regexps using automata notation, since some regular languages are really hard to define with regexps)
[23:16:09] <ssbr> strcat: not really
[23:16:21] <ssbr> other than the presence or absence of a few key constructs
[23:16:28] <strcat> perl regexp can execute arbitrary code
[23:16:36] <ssbr> sure
[23:16:56] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[23:17:09] *** Quits: int3_ (int3_@9A375198.26321F00.F7721B25.IP) (Client exited)
[23:17:22] <ssbr> as far as being able to replace the engine or parser, I don't see any reason to disallow it
[23:17:29] <graydon> guh
[23:17:48] <ssbr> internally, I would be using it to switch between interpreters of bytecode
[23:17:52] <strcat> ssbr: if it makes the API more complicated, there should be a good reason to do it
[23:17:52] *** Quits: aatch (aatch@moz-2BB0AC01.cable.telstraclear.net) (Ping timeout)
[23:18:01] <graydon> -ftrapv does not appear to trap integer overflow on ints, despite dispatching to a helper function to do the +. it traps long overflows though.
[23:18:14] <strcat> graydon: with gcc or clang?
[23:18:14] <ssbr> strcat: just because you can replace the parser or the interpreter, does not mean that the "usual" API will be complicated
[23:18:21] <strcat> graydon: gcc's impl is brokenb
[23:18:24] <strcat> broken*
[23:18:25] <kimundi> strcat: But it doesn't make it more complicated
[23:18:25] <graydon> -fsanitize=integer traps long overflows in C++ but not in C, and int overflows in neither
[23:18:28] <ssbr> strcat: like, there can be the "usual" API of re(regexp, options)
[23:18:35] <graydon> I'm so glad these are kept working! very confidence inspiring
[23:18:40] <strcat> graydon: strange ;p
[23:18:47] *** Joins: dbaupp (Thunderbir@moz-7D1EB5E8.lns20.syd6.internode.on.net)
[23:18:48] <ssbr> strcat: and the "optional" API of bar::execute(foo::parse(regexp, flags), flags2)
[23:19:04] <ssbr> strcat: is having a more complex API for more complex use cases so bad a thing?
[23:19:15] <strcat> ssbr: if the use case is shown to exist ;p
[23:19:51] <ssbr> strcat: well, I can talk about software or interfaces I've wanted to write using regexps
[23:20:17] <ssbr> but some of them, you can say "well if you want that, just write it into the library", but what I mean is, "what if someone that isn't writing a whole regexp library wants taht"
[23:20:49] *** Joins: aatch (aatch@moz-2BB0AC01.cable.telstraclear.net)
[23:21:03] <ssbr> this isn't something that concerns me a whole lot right now, mostly I'm still writing the base implementation
[23:21:14] <kimundi> strcat: Honestly If I understand it right most of the api discussed here would exist anyway as part of the implementation. Might as well make it public and optionally usable then.
[23:21:15] <ssbr> I spent a few hours trying to port the JS test cases badly
[23:21:18] <ssbr> (oops.)
[23:21:49] <ssbr> kimundi: there's an argument to be made that it ties hands as far as backwards compatibility goes
[23:22:16] <ssbr> I'm not sure I accept the complexity argument though. If people are bothered by complexity in the "advanced api" section of the docs, maybe they shouldn't read that section of the docs
[23:22:48] <ssbr> but yes, with the current plan, I would want to separate parsing and executing anyway
[23:22:56] <ssbr> and have two parsers and three executors
[23:23:00] <ssbr> (there's only one compiler though)
[23:23:29] <kimundi> ssbr: Hm, howmight it make backwards compat harder? Wouldn't the AST format be pretty much final?
[23:23:33] <aatch> ssbr, 2 parsers?
[23:23:34] <ssbr> this can be simplified to one parser and three interpreters, or even one parser and two interpreters if we don't care about speed
[23:23:53] <ssbr> aatch: I personally place value on supporting the POSIX syntax
[23:23:57] <ssbr> but this is not necessary
[23:24:03] <aatch> ssbr, ah.
[23:24:16] <ssbr> if there is consensus that this is just me wishing for features rust doesn't need, only one parser is necessary
[23:24:27] <ssbr> aatch: but then, for me personally, I'd want to be able to define a POSIX regexp parser externally ;)
[23:24:31] <ssbr> (if that was the case)
[23:24:38] <seth> in this line of code: "impl<'self, T: Ord + Eq> BinarySearchMethods<'self, T> for &'self [T] {", what do those single quotes mean?
[23:25:01] <strcat> seth: 'self is a named lifetime, it's covered in the borrowed ptr tutorial
[23:25:15] <seth> strcat: ah ok, will go read that. thanks
[23:26:12] <aatch> At any rate, all of that stuff would live in std, an re! syntax extension would just use a pre-defined parser and compiler to generate a statically compiled regex that can take advantage of compile-time optimizations.
[23:26:18] <kimundi> ssbr: It just occured to me that if we ever get pluggable syntax extensions it might even be possible to support non-buildin external compiletime compiled re's. But that's far off. :)
[23:26:27] *** Joins: cdidd (cdidd@moz-D4A67B0B.broadband.corbina.ru)
[23:26:34] <ssbr> kimundi: that would be my hope, yeah
[23:26:40] <aatch> kimundi, not as far off as you might think though.
[23:26:47] <ssbr> well
[23:26:55] <ssbr> kimundi: it should be possible just with dynamic loading of crates
[23:27:07] <strcat> all it takes is for someone to sit down for a day and implement dlopen stuff
[23:27:18] <dbaupp> is `match foo { A { x: ref x, y: ref y } => ... }` actually unsafe if foo has a destructor? (as far as I can tell it's the same as `let x = &foo.x, y = &foo.y`?)
[23:27:25] <ssbr> if the re!() syntax accepts the name of a crate/module that implements the compiler or whatever
[23:27:42] <strcat> dbaupp: if you didn't take them by-ref it would consume foo
[23:27:46] <strcat> I think that's the case it deals with
[23:27:49] <dbaupp> strcat: yes
[23:27:52] <ssbr> then the syntax extension loads said crate, runs relevant code, spits out result
[23:27:56] <strcat> it could probably be special cased to work with all refs
[23:27:57] <dbaupp> strcat: but taking them by ref is safe?
[23:28:02] <strcat> nmatsakis or pcwalton, any idea? ^
[23:28:14] <strcat> dbaupp: afaik yes
[23:28:15] <dbaupp> strcat: it would be quite nice for macros/syntax extensions
[23:28:16] <aatch> dbaupp, you broke things!
[23:28:30] <kimundi> ssbr: Well with 'far off' I meant that there first needs to be an api for pluggable syntax extensios before I can think about how they could be used.
[23:28:52] <ssbr> kimundi: I'm saying I don't think they're necessary
[23:29:01] <dbaupp> aatch: I have a history of this :(
[23:29:05] <aatch> kimundi, the current API is actually kinda close to something usable
[23:29:10] <pcwalton> uh... not sure off the top of my head
[23:29:20] <kimundi> ssbr: Right, I see that now. Could do that directly.
[23:29:34] * strcat doesn't understand that _match.rs code
[23:29:37] <ssbr> aatch: btw, another reason I personally like an extensible re module is that I have a personal interest in research of implementation techniques
[23:29:57] <ssbr> (so I kind of would want to use the std re as my personal playground)
[23:30:00] <ssbr> but that is maybe also selfish :p
[23:30:05] <cmr> So I'm working on narrowing down and elaborating the different types of resolution failures that can happen with an import. Given the code "use foo::bar;", I have a span that covers 'foo::bar', but I'd like to narrow it doesn to just 'foo'. I have an ast::ident for "foo", if that helps.
[23:30:16] <dbaupp> strcat et al: fwiw, this is the problem https://github.com/mozilla/rust/issues/6341
[23:30:17] <ssbr> (personal playground as in, it supports the APIs necessary to play, without me actually modifying the module)
[23:30:18] <aatch> ssbr, look at core::task for an idea of how to have a multi-layered api for that.
[23:30:19] <cmr> s/doesn/down/
[23:31:38] <aatch> cmr, you could re-span, after figuring out the new size of the span
[23:32:25] <cmr> aatch: how does that work? I was thinking just make a new span with same lo and a hi of lo+len(str_of(ident)), but I'm not sure how well that plays with multibyte characters, as the indexes are bytes?
[23:32:29] <ssbr> aatch: the option setting API is a little interesting there
[23:32:47] <dbaupp> cmr: `str::char_len`
[23:32:49] <ssbr> I was wondering halfheartedly before how one sets only _some_ options away from the defaults
[23:33:04] <ssbr> task does it via task().option1().option2()
[23:33:06] <cmr> dbaupp: ah, that's more like it!
[23:33:13] <dbaupp> rusti: (str::char_len(""), str::len(""))
[23:33:14] <rusti> (3, 6)
[23:33:23] <ssbr> (as opposed to in python, you might do task(option1=..., option2=...)
[23:33:42] <strcat> ssbr: are they just boolean flags? or actually options?
[23:33:48] <cmr> Is this a good solution? I wasn't sure if there was some "more correct" way to do it already somewhere in libsyntax or elsewhere.
[23:34:00] <cmr> (the codebase is large and I have barely scratched the surface)
[23:34:08] <aatch> cmr, well the spans are attached to items, not idents
[23:34:08] <strcat> cmr: char_len is wrong if you want # of glyphs
[23:34:20] <strcat> but I don't think any of the compiler code reports errors properly aligned yet
[23:34:35] <ssbr> strcat: well, most are flags (e.g. "ignore case"), but something like selecting a backend (backtracking search vs thompson style) would be an option with more than two possibilities
[23:34:43] <ssbr> for re!() you can just make this syntax
[23:35:02] <strcat> ssbr: well the flags can just be dealt with using a single flag type
[23:35:03] <ssbr> I was thinking for re() you'd use an options struct. Maybe this task()-like API gives a nice way to produce such structs.
[23:37:16] *** Quits: spider-mario (spidermari@moz-2BC095A6.rev.sfr.net) (Input/output error)
[23:37:38] <aatch> ssbr, btw, for the re! you can have a variable number of arguments, so something like re!("ab(a|b)") would be default options and re!("ab(a|b)", "i") would set whatever option the flag 'i' corresponds to.
[23:38:28] <strcat> graydon: heh, today the delta was bigger than the compressed pkg :(
[23:38:32] <dbaupp> aatch: out of interest, have you worked on rust-fmt at all recently? :)
[23:38:36] <graydon> awww
[23:38:37] <strcat> so it got automatically discarded
[23:38:41] <aatch> dbaupp, nope sorry
[23:38:48] <pcwalton> I have ideas for rustfmt
[23:38:56] <dbaupp> aatch: np... neither have I
[23:39:05] <aatch> pcwalton, shoot
[23:39:23] <pcwalton> basically make it token tree based and try to adopt a consistent style w/r/t braces
[23:39:29] <pcwalton> for example, there should always be a newline after an {
[23:39:50] <pcwalton> [] and () should try to be on one line if possible but otherwise fall back to opening a box and lining up everything under the (
[23:40:06] <dbaupp> pcwalton: (this is for printf/`fmt!`-style string formatting)
[23:40:08] <pcwalton> some sorts of refactorings will only be possible outside of macro invocations, like alphabetizing "use" statements
[23:40:11] <pcwalton> ohh
[23:40:14] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[23:40:15] <pcwalton> *that* kind of rustfmt.
[23:40:16] <pcwalton> never mind.
[23:40:26] <cmr> heh
[23:40:28] <dbaupp> pcwalton: haha :)
[23:40:30] <aatch> pcwalton, I was wondering what you were going on about...
[23:41:09] * strcat waits for rusti to reboot himself
[23:41:12] <dbaupp> if anyone's interested, there's a work-in-progress at https://github.com/Aatch/rust/tree/new-fmt
[23:41:13] <ssbr> kimundi: btw, given all that has been said here, and also the possible restrictions on what re!() can even do, I think it's probably best that re!() only do compile time, and there be a separate function (re() or something) for run-time.
[23:41:23] <aatch> I'm like "Is he criticizing the code style?"
[23:41:24] <ssbr> kimundi: a parse!() syntax extension would also be nice though.
[23:41:43] <ssbr> since at least that lets you verify the syntax, even if the options or backend are not able to be used statically.
[23:42:11] <graydon> pcwalton: I have been thinking similar thoughts, though I'm not sure if it'll be required
[23:42:59] *** jdm|away is now known as jdm
[23:43:20] <graydon> there are 3 benefits to being tt-based: (1) rustfix can operate on tts, (2) the pp algorithm gets simpler to implement / maintain, (3) code looks generally more-uniform due to only looking at delimiters
[23:43:44] <graydon> (1) we can handle by just doing fixes in the tt form after tt-parse and before full-parse
[23:44:04] <pcwalton> what about reformatting inside macros?
[23:44:07] <pcwalton> inside macro calls
[23:44:17] <graydon> we currently do something like what you're saying inside macros
[23:44:24] <graydon> that is, a simple tt-only rule applies
[23:44:26] <graydon> in the pp
[23:44:29] <pcwalton> well, it just strings tokens together on one line, it doesn't do boxes very well
[23:44:37] <graydon> it does boxes on { boundaries
[23:44:39] <graydon> not ( and [
[23:44:40] <graydon> but iti could
[23:44:46] <graydon> it's an extra couple lines of code
[23:45:04] <graydon> the thing I'm more curious about are the (2) and (3) benefits
[23:45:10] <graydon> uniformity and maintenance
[23:45:21] <graydon> but: we also sometimes want to print ASTs.
[23:45:38] <graydon> I don't actually know how to accomplish that if we excise the AST pp layer
[23:45:52] <pcwalton> we have to have a way to convert ASTs back into token trees
[23:45:55] <pcwalton> basically
[23:46:13] *** Joins: int3_ (int3_@moz-34B610F6.subnet-248.amherst.edu)
[23:46:18] <graydon> we could. or we could enumerate all the cases we print ASTs and try to figure out ways around them.
[23:46:29] <dbaupp> graydon, pcwalton: printing after macro/syntax extension expansion is pretty useful, so it'd be nice not to lose that
[23:46:34] <pcwalton> yes
[23:46:56] <kimundi> ssbr: Hmm... I'm not convinced that a best-effort re!() is a bad thing
[23:47:01] <graydon> or we could just leave the AST pp in place. it's not actually so bad. if you run it today, there are only a handful of places it's off. I believe with "some effort" (none has been spent in a while) it could be pushed to satisfactory.
[23:47:29] *** Quits: EXetoC (ex@moz-2DBEB1E4.customer.t3.se) (Quit: WeeChat 0.4.0)
[23:49:33] *** Quits: devinus (devinus@moz-BED25650.austincc.edu) (Quit: Computer has gone to sleep.)
[23:49:39] <pcwalton> graydon: I think bors is stuck
[23:49:44] <pcwalton> it failed on my pull. again. sigh.
[23:49:45] <graydon> dammit
[23:50:03] * pcwalton wants to nuke most of the benchmarks
[23:50:55] *** Quits: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net) (Quit: ["Textual IRC Client: www.textualapp.com"])
[23:51:07] <pcwalton> they're so full of really old crufty code
[23:51:14] <strcat> graph500-bfs seems to run too quickly to be measuring anything
[23:51:27] <strcat> unless there's a way to make the input bigger
[23:51:36] <pcwalton> I think graph500 was a test for large-scale distributed supercomputing systems?
[23:51:50] <strcat> dunno. but it's too fast ;p
[23:51:56] <kimundi> graydon: Given the choice between a regex!() SE that only works at compiletime with static strings and buildin engines, and one that does the same but also allows non-static strings and custom engines, but then falls back to runtime compilation, which would you prefer?
[23:52:14] <pcwalton> I would like compile-time regexes to exist if possible
[23:52:53] <graydon> the latter. we'll get some at runtime.
[23:53:20] <pcwalton> but yes, runtime regexes are a nice use case
[23:53:26] <strcat> wouldn't there be both a compile-time syntax ext and a runtime fn?
[23:53:32] <graydon> though ... I expect the former is fine for a start. one thing at a time?
[23:54:30] <benh> ... fresh build including llvm: 108 minutes. we aren't still talking about build times, are we? ;)
[23:55:00] <nmatsakis> strcat: you were asking about matching against structs with dtors?
[23:55:07] <strcat> nmatsakis: dbaupp was
[23:55:07] <Flibo> 60 minutes and counting
[23:55:15] <strcat> nmatsakis: could it allow by-ref matches?
[23:55:41] <strcat> apparently it's used in deriving
[23:55:42] <nmatsakis> strcat: dbaupp: yes, by-ref should be ok. What we want to prevent is moving things out from inside the struct
[23:55:44] <dbaupp> nmatsakis, strcat: I just filed https://github.com/mozilla/rust/issues/6344
[23:56:05] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[23:56:05] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 149fead5e to 145a65f51: 02http://git.io/N3iJvQ
[23:56:05] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[23:56:09] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[23:56:09] <ghrust> 01[13rust01] 15bors pushed 9 new commits to 06auto: 02http://git.io/1Deifg
[23:56:09] <ghrust> 13rust/06auto 14783f5d5 15Alex Crichton: Implement a new protocol for `for` loops that's much more easily composable
[23:56:09] <ghrust> 13rust/06auto 148866919 15Alex Crichton: core: Use the new `for` protocol
[23:56:10] <ghrust> 13rust/06auto 1415f5661 15Alex Crichton: std: Use the new `for` protocol
[23:56:11] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[23:56:49] <strcat> benh: well I just measured a few ;p
[23:57:13] <benh> I suspect I won't be measuring another one before going to sleep ;)
[23:57:16] <strcat> arch's build server takes 30 mins to clone the repo and submodules + build llvm and the stages
[23:57:25] <strcat> faster on my laptop though.
[23:57:34] *** Quits: Jesse (jruderman@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: Jesse)
[23:57:45] <strcat> (also the compression + deltas is included in that 30mins, and takes a while)
[23:57:49] <nmatsakis> I miss github issue search so much
[23:57:50] *** Quits: thou (thou@moz-1C1CA9F7.fasttrackcomm.net) (Broken pipe)
[23:57:52] <graydon> we would all dearly love to fix the compilation speed
[23:57:59] <strcat> nmatsakis: the new thing is less bad now
[23:58:03] <benh> oh i'm not complaining
[23:58:07] *** Quits: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se) (Client exited)
[23:58:09] <strcat> if you're on the issue tracker the search at the top defaults to issues
[23:58:16] <nmatsakis> strcat: not...for me.
[23:58:18] <strcat> and they added open/closed filters after I sent in a report :)
[23:58:23] *** Joins: Jesse (jruderman@moz-BE33DA21.fw1.sfo1.mozilla.net)
[23:58:26] <strcat> nmatsakis: maybe ctrl-f5?
[23:58:31] <strcat> they keep changing the css/js
[23:58:40] <benh> there was some talk about how much memory people have, and what affects build times, so I thought I'd give a clean build a shot
[23:58:44] <nmatsakis> strcat: I...have no idea what ctrl-f5 does
[23:58:49] <strcat> nmatsakis: force-refresh
[23:58:51] <pcwalton> modes will not die :(
[23:58:52] <strcat> at least in firefox
[23:58:54] <benh> I'm surprised that my laptop is so slow though :(
[23:58:54] <james4k> is it very likely the compilatino speed will improve much?
[23:58:54] <strcat> ignores cache
[23:59:28] <kimundi> graydon, pcwalton It's not final, but the design question is: one regex!() that tries best effort for compiletime compilation, but at worst case compiles at runtime, or one static_regex!() just for compiletime compilation, and seperate apis for runtime compilation. It wouldn'r really complicate it to have all in one regex!(), just a few optional arguments to actually choose between options.

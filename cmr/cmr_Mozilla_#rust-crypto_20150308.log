[00:00:05] <bascule> Ilari: o_O
[00:00:33] <eternaleye> bascule: Because what's important about Tng isn't any specific protocol; it's that it provides a sane way to create and deploy protocols, and ensure they'll work sanely
[00:00:49] <bascule> eternaleye: sounds like what Parrot was trying to do for dynamic language VMs
[00:00:59] <Ilari> I think that is even running code, not just some out-of-reality specs.
[00:01:04] <eternaleye> bascule: More like how the "narrow waist" of IP was SUPPOSED to work
[00:01:12] <bascule> eternaleye: I think I'd prefer working backward from the security model
[00:01:19] <eternaleye> bascule: That's orthogonal
[00:01:22] <bascule> lol
[00:01:26] <bascule> it is so totally not orthogonal
[00:01:30] <eternaleye> bascule: What you want there is inside the isolation layer
[00:01:33] <bascule> no
[00:01:48] <bascule> have you ever read anything about capabilities/CapTP?
[00:01:57] <eternaleye> Um, yes? We've talked about it.
[00:02:05] <bascule> I don't remember talking about it, but anyway
[00:02:10] <eternaleye> CapTP would operate _over_ a protocol that is described by Tng
[00:02:22] <eternaleye> It would integrate with the Isolation layer for some things
[00:02:30] <bascule> what is this extra layer providing?
[00:02:31] <Ilari> bascule: Also, reminds me of some PHB stuff: 2RTT in cold case for encrypted DNS is allegedly a disaster (I'm not so sure).
[00:02:36] <eternaleye> bascule: It's not an extra layer
[00:02:45] <eternaleye> bascule: You are thinking at the wrong level of abstraction
[00:02:51] <bascule> I just totally do not understand what point you're trying to make
[00:03:05] <bascule> there's a thing that does a thing and you can't describe it
[00:03:06] <Ilari> bascule: Obviously hot case must not have extra round trips.
[00:03:07] <bascule> what does it do
[00:03:09] <bascule> why should I care?
[00:03:27] <eternaleye> bascule: You're thinking of "does a thing" in the wrong scope.
[00:03:29] <bascule> Ilari: eliminating those superfluous round trips is exactly what a cohesive CapTP-style protocol could do
[00:03:40] <eternaleye> bascule: You're thinking 'does a thing' in the 'running code sending packets' sense
[00:04:13] <bascule> you can introduce a principal to another principal in a 0RTT way such that the two principals initate a session because a third principal created it for them, but the third principal does not know the session key(s)
[00:04:30] <Ilari> bascule: Sure, one can eliminate the extra round trips in cold case, but is it worth the trouble?
[00:04:34] <bascule> eternaleye: can you really not give me a 1-like elevator pitch of what this thing does?
[00:04:43] <eternaleye> bascule: Tng is "the taxonomy of 'layer 4' as a monolithing thing is stupid and counterproductive, and here is a nice factoring of it into layers 4.1 through 4.4"
[00:04:47] <eternaleye> *monolithic
[00:04:54] <bascule> Ilari: if it can be done correctly
[00:04:59] <eternaleye> bascule: The paper explains _why_ it's stupid and counterproductive
[00:05:08] <bascule> eternaleye: you're preaching to the choir?
[00:05:09] <eternaleye> bascule: As well as the benefits of the factoring they choose
[00:05:16] <Ilari> bascule: Also, recursive-DNS and TLS only have two principals. :-)
[00:05:17] <bascule> but you still can't tangibly tell me what this thing is or how it works
[00:05:20] <eternaleye> bascule: The factoring is the important part
[00:05:56] <bascule> so like, there's existing primitives you have to build on
[00:05:59] <bascule> how does it map to those?
[00:06:02] <bascule> in one sentence
[00:06:19] <eternaleye> bascule: You're asking for the exact topic of the paper in one sentence.
[00:06:22] <bascule> like "It operates over UDP but implements a custom decongestion algorithm"
[00:06:45] <eternaleye> bascule: Completely off base
[00:06:48] <bascule> ^^^ CurveCP, MinimaLT, QUIC
[00:06:51] <bascule> o_O
[00:07:13] <eternaleye> bascule: It separates Layer 4 into the actual concerns.
[00:07:15] <bascule> so this is some kind of magical ponies and unicorns protocol magic pixie dust?
[00:07:20] <eternaleye> bascule: No
[00:07:21] <bascule> that's not answering my question
[00:07:31] <eternaleye> bascule: one sec, lemme frame it
[00:07:40] <bascule> so there's a real Internet
[00:07:43] <bascule> made out of real hardware
[00:07:45] <bascule> using real protocols
[00:07:51] <bascule> what does it really do?
[00:07:58] <eternaleye> Hold still and let me type!
[00:08:00] <bascule> lol
[00:11:34] <eternaleye> bascule: Okay, so it splits layer 4 into the following. 4.1: Endpoint layer. NAT operates here. UDP is a purely endpoint-layer protocol, and in TNG can be used as exactly that. 4.2: Flow layer. Performance-enhancing proxies operate here, but currently break things like TCP fate-sharing. DCCP conflates layers 4.1 and 4.2. 4.3: Isolation layer. DTLS is pretty much a pure isolation-layer protocol: it tries to provide integ/auth/confid, 
[00:11:35] <eternaleye> without changing the underlying semantics if possible. 4.4: Semantics layer. This concerns the application-level interface: Streams or datagrams? Ordered or unordered? Single-channel or multiple?.
[00:11:50] <eternaleye> TCP operates at all of these, with a null Isolation layer
[00:12:10] <eternaleye> TLS is poorly-designed according to this, because the isolation layer isn't protecting the semantics layer
[00:12:22] <bascule> I don't think I understood anything you said
[00:12:29] <eternaleye> Read the paper.
[00:12:29] <bascule> I agree TLS is poorly designed
[00:12:33] <bascule> and a layering violation
[00:12:34] <bascule> sure
[00:12:44] <tiffany> [18:59] <Ilari> I think WebRTC actually uses SCTP over DTLS over UDP. :-)
[00:12:53] <tiffany> I tried to figure out how firefox's webrtc impl uses libusrsctp
[00:12:56] <bascule> yeah that's... insanity
[00:12:59] <tiffany> but I couldn't even find any calls to recv/send
[00:13:16] <eternaleye> bascule: Basically, the point of Tng is "People! You keep designing protocols without a sensible vocabulary to talk about what they're doing!"
[00:13:53] <eternaleye> bascule: So you get lots of "distinction without a difference" and reinvented wheels
[00:13:57] <bascule> eternaleye: I think messaging is probably best solved at layer 7
[00:14:13] <bascule> and for transport, UDP or TCP are both options
[00:14:17] <eternaleye> bascule: So you get stuff like QUIC having to reinvent CC from scratch, and so forth
[00:14:25] <bascule> I don't necessarily like QUIC
[00:14:28] <eternaleye> bascule: The point is that 'for transport' is a harmful concept there
[00:14:28] <bascule> I hate the implementation
[00:14:34] <bascule> lol
[00:14:42] <bascule> there aren't any other practical options
[00:14:48] <eternaleye> bascule: Thinking of 'transport' as a monolithic thing is exactly the problem
[00:14:50] <bascule> I think that's where this conversation started
[00:14:51] <bascule> lol
[00:14:51] <Ilari> bascule: Heh, that TLS comment reminds me of: <@Ilari> SSL and TLS just seems incompetently designed.
[00:15:01] <bascule> heh
[00:15:25] <eternaleye> bascule: Tng is exactly "Transport as a monolithic concept is a problematic abstraction, and this is a better one"
[00:15:27] <bascule> eternaleye: I'm more concerned with things like promise pipelining
[00:15:39] <bascule> and replicated state machines
[00:15:40] <eternaleye> bascule: Yes, and that happens _over_ a transport
[00:15:46] <eternaleye> bascule: Tng is _in_ transports
[00:15:57] <bascule> I have no clue what point you're trying to make
[00:15:59] <bascule> you keep saying things
[00:16:05] <bascule> they seem to contradict themselves
[00:16:06] <bascule> *shrug*
[00:16:14] <eternaleye> You're conflating multiple layers of abstraction
[00:16:16] <bascule> lol
[00:16:28] <eternaleye> I'm trying to make points about the layers of abstraction themselves
[00:16:32] <bascule> I'm talking about the real world layers of abstraction
[00:16:37] <Ilari> Also, is there problem where userspace does not get access to all the features kernelspace does when implementing protocols?
[00:16:37] <eternaleye> While you talk about things built on them
[00:16:39] <bascule> and I'm fully aware of the complaints you're making
[00:16:48] <bascule> you are doing a terrible job of explaining how things should be refactored
[00:17:04] <bascule> you have to start with the real world and work your way up
[00:17:17] <eternaleye> bascule: Yes, because I'm trying to condense a very careful paper into IRC.
[00:17:44] <eternaleye> bascule: And that's exactly what Tng is _doing_
[00:17:52] <bascule> where's the code?
[00:17:52] <eternaleye> bascule: It's not about replacing TCP or UDP
[00:17:58] <bascule> they can't
[00:18:03] <bascule> although you answered my question poorly
[00:18:06] <bascule> because there are two answers
[00:18:14] <eternaleye> bascule: The 'code' is the IETF draft they submitted
[00:18:18] <bascule> o_O
[00:18:19] <eternaleye> bascule: It's _not a protocol_
[00:18:28] <Ilari> E.g. code up an app that communicates with UDP datagrams. Do you get access to things like ICMP errors your packets generated and ECN markings those packets got?
[00:18:30] <bascule> have they implemented... whatever it is?
[00:18:36] <bascule> in any form?
[00:18:38] <bascule> or is it just papers?
[00:18:39] <eternaleye> bascule: It's _fixing the terms used to describe the abstractions_
[00:18:51] <bascule> [img:cool story bro]
[00:19:01] <eternaleye> Just read the paper.
[00:19:08] <bascule> ok I probably should
[00:19:09] <bascule> not now
[00:19:13] <bascule> I have synthesizers to play with
[00:19:19] <eternaleye> Heh
[00:19:31] <bascule> but this sounds about as promising as okTurtles
[00:20:11] <eternaleye> bascule: Does this image explain it better than I have? http://dedis.cs.yale.edu/2009/tng/img/splash.png
[00:20:17] <eternaleye> It's on the main page. Right there.
[00:20:20] <Ilari> Could one just run TCP congestion control in userspace, for some UDP-based protocol?
[00:20:21] <bascule> Ilari: re: reinventing X.509/TLS, it's probably not going to happen
[00:20:35] <bascule> Ilari: that's exactly what QUIC does ok and CurveCP does poorly
[00:21:10] <bascule> see also LEDBAT
[00:21:19] <eternaleye> >> High-level illustration of the Tng architecture, and how new and existing transport protocols fit into it.
[00:21:31] <Ilari> They later just copied TCP congestion control? It looked a lot inferrior to TCP a while back...
[00:21:40] <bascule> eternaleye: why do they want to use DTLS o_O
[00:21:51] <bascule> like DTLS is basically "I just lost interest"
[00:21:57] <eternaleye> bascule: They don't "want to" use anything
[00:21:59] <eternaleye> bascule: augh
[00:22:02] <bascule> lol
[00:22:04] <eternaleye> bascule: It's a _taxonomy_
[00:22:29] <bascule> ok well I'll probably care when this replaces the OSI model as the thing everyone uses
[00:22:36] <Ilari> bascule: Well, TLS 1.3 draft... Basically very little of SSLv3 is remaining.
[00:22:39] <bascule> and actually affects protocol design
[00:22:39] <eternaleye> bascule: It's not meant to replace the OSI model
[00:22:44] <eternaleye> bascule: Its a minor extension
[00:22:46] <bascule> what is it meant to do then?
[00:22:48] <bascule> lol k
[00:22:56] <eternaleye> *it's
[00:23:44] <eternaleye> bascule: Basically, it leaves the OSI model the same, but it says that layer 4 has four sub-layers that are important to reason about when designing stuff that operates at layer 4
[00:23:52] <bascule> eternaleye: I guess I want to do the opposite... move all the smarts to layer 7
[00:24:06] <eternaleye> bascule: The problem there is that 'layer 7' becomes layer 4.
[00:24:13] <tiffany> that seems to be what everyone is doing these days, bascule
[00:24:13] <eternaleye> bascule: It doesn't fix much of anything.
[00:24:15] <bascule> layer 4 is UDP
[00:24:38] <bascule> provided you can configure your entire network infrastructure to treat your UDP traffic right
[00:24:42] <eternaleye> bascule: And then you get multiple different ideas of what congestion control means, which is great fun!
[00:24:42] <bascule> which is a bit of an undertaking
[00:24:45] <Ilari> OSI layer stuff has very little to do with reality.
[00:24:51] <bascule> no, you should pick one
[00:24:57] <bascule> Ilari: yeah, fuck it ;)
[00:25:00] <eternaleye> bascule: Yes. That's what the transport layer is for.
[00:25:25] <bascule> eternaleye: I feel like we're going around in circles
[00:25:30] <eternaleye> bascule: The fact that it conflates all four sublayers means people have been reimplementing it because they can't drop semantics without dropping CC
[00:25:58] <eternaleye> bascule: Tng is designed to make what you want (move semantics into the application layer) easier.
[00:26:01] <bascule> I also think I'm for the layer 7 entangling of all of these concerns
[00:26:14] <bascule> because that's how you build optimally efficient protocols that produce as little traffic as possible
[00:26:17] <eternaleye> bascule: By making endpoints and CC and such reusable components, rather than horrifically entwined with semantics.
[00:26:53] <bascule> and in fact these protocols can have all the awesome features that people always dreamed of that for lack thereof make systems slow today
[00:26:54] <eternaleye> bascule: You could see Tng as guidelines for how to _design_ your layer 7 protocols over UDP
[00:27:06] <bascule> that's a sales pitch I can get on board with
[00:27:14] <eternaleye> bascule: Just like OSI is a set of guidelines for how to design protocols in general
[00:27:24] <bascule> OSI needs to DIAF
[00:27:40] <eternaleye> bascule: Tng is saying "Hey, the OSI guidelines for layer 4 are incomplete and stupid"
[00:27:55] <bascule> I'm just like unfortunately they are what they are
[00:28:11] <Ilari> Basically, when Internet networking is concerned, there are bascially only 4 layers (sometimes with sublayers).
[00:28:17] <eternaleye> bascule: Except they're not.
[00:28:22] <eternaleye> bascule: Those guidelines, split into sublayers, are actually pretty sensible
[00:28:43] <bascule> good luck effecting change
[00:28:53] <eternaleye> Ilari: They agree - note that 'Application' is immediately above their split-up 'transport'
[00:29:17] <bascule> I like how TLS bleeds into both the session and presentation layers
[00:29:24] <bascule> in an ad hoc way
[00:29:38] <eternaleye> bascule: Sure, but session/presentation are deeply weird anyway.
[00:29:47] <bascule> nobody knows what they are
[00:29:59] <eternaleye> bascule: I agree that those should both be considered part of application. As do the Tng folks.
[00:30:18] <bascule> the layers that matter are 1,2,3,4 and 7
[00:30:32] <eternaleye> Agreed
[00:30:34] <bascule> TLS may as well be layer 7
[00:30:50] <eternaleye> See, that's where I think Tng is a better codification of the same thing you want.
[00:31:03] <bascule> cool
[00:31:09] <tiffany> I kind of like the tng thing
[00:31:19] <tiffany> I just kind of accept that everything is going to be tunnelled over udp
[00:31:27] <eternaleye> Semantics are isolated from the network infrastructure by the isolation layer
[00:31:37] <Ilari> Also, with encryption, there is tradeoff between how much you can protect and your reach.
[00:31:44] <eternaleye> So applications can have their specific semantics without issues of deployability
[00:31:59] <bascule> tiffany: I mean, there are so many things that TCP gives you for free that are hard to do with UDP
[00:32:11] <bascule> tiffany: especially things like MPTCP
[00:32:17] <tiffany> er.. like what?
[00:32:20] <eternaleye> bascule: That's pretty much exactly what Tng is trying to fix
[00:32:24] <eternaleye> tiffany: Multipath TCP
[00:32:32] <bascule> switching from 3G to WiFi
[00:32:38] <bascule> and having your traffic seamlessly redirected
[00:32:40] <tiffany> I mean tcp itself
[00:32:49] <bascule> TCP gives you decongestion
[00:32:51] <Ilari> What layer is UDP in that 4-layer model? Well, usually third, but it can a sublayer of the second too (e.g. LISP).
[00:32:57] <tiffany> I've found that udp applications are more likely to support roaming than tcp applications
[00:33:03] <eternaleye> tiffany: Congestion control, windowing, fate-sharing, many more things.
[00:33:04] <bascule> and fancy stacks can dynamically change their decongestion model on-the-fly
[00:33:12] <eternaleye> tiffany: Useful stream abstractions
[00:33:16] <eternaleye> tiffany: Reliability.
[00:33:27] <bascule> messaging people hate stream semantics ;)
[00:33:40] <eternaleye> tiffany: But each one has to reimplement roaming, and often redesign it from scratch.
[00:33:42] <tiffany> I have never found a use for stream semantics
[00:33:45] <Ilari> And I hope nobody is crazy enough to stick (D)TLS in anywhere except the fourth...
[00:33:48] <eternaleye> bascule: Messaging people would like SST
[00:33:55] <eternaleye> bascule: Dynamic streams - one stream per message
[00:34:10] <eternaleye> bascule: No issue of datagram size, but no HOL blocking
[00:34:11] <tiffany> eternaleye: sure
[00:34:18] <bascule> I mean there are protocols that do all of this but also have fancy crypto
[00:34:18] <tiffany> it would be nice if there was a way to compose new protocols
[00:34:20] <tiffany> instead of layering
[00:34:20] <eternaleye> bascule: That's part of what Tng is intended to make feasible
[00:34:29] <tiffany> and if the libraries weren't god awful
[00:34:37] <tiffany> most of them just instantly preclude the use of async IO
[00:34:38] <eternaleye> tiffany: Layering _is_ a way to compose new protocols
[00:34:45] <eternaleye> tiffany: The layers can be internal to the API
[00:34:47] <tiffany> it's not a terribly good one from my experience
[00:35:00] <bascule> I really care about the protocols I think are actually useful
[00:35:04] <eternaleye> tiffany: The issue isn't with layering as a method; it's with the chosen layers.
[00:35:05] <tiffany> they always tend to bundle too many features
[00:35:08] <tiffany> way more than I care about
[00:35:17] <tiffany> and have bad implementations
[00:35:18] <eternaleye> tiffany: Exactly.
[00:35:25] <bascule> Ilari: what do you think about QUIC vs CurveCP vs Noise vs MinimaLT?
[00:35:36] <bascule> vs ...?
[00:35:42] <eternaleye> tiffany: The 'too many features' is what happens when what should be several layers is treated as one.
[00:35:53] <tiffany> I was investigating how hard it'd be to integrate encryption into the udp reliability layer I work on
[00:35:57] <eternaleye> tiffany: That's exactly the argument Tng makes
[00:36:06] <tiffany> looked at curvecp, and I immediately hated how huge the header overhead is
[00:36:34] <tiffany> 8 bytes of magic at the start of every packet, for not really any good of a reason
[00:36:43] <eternaleye> MinimaLT is pretty close to what Tng would recommend in terms of "how to design a protocol"
[00:36:49] <tiffany> the 32 byte client public key in every message is almost understandable, but ugh
[00:37:02] <eternaleye> The only issue is how it does CC above the 'isolation layer' of its crypto
[00:37:04] <tiffany> I'll check that out
[00:37:10] <tiffany> any good links?
[00:37:24] <eternaleye> tiffany: DJB's paper is pretty much it AFAIK
[00:37:24] <tiffany> I see a paper
[00:37:27] <tiffany> alright
[00:37:28] <Ilari> bascule: Well, with whatever used over UDP, the problem is that CC tends to suck (usually by performance sucking, because protocol designers _really_ want to avoid TCP-unfriendly stuff).
[00:38:59] <Ilari> bascule: Not that I can't destroy my net connection with a single TCP stream...
[00:39:22] <eternaleye> bascule: And you're still thinking protocols. Tng is aimed at protocol designers, not protocol consumers.
[00:39:29] <bascule> Ilari: at least with QUIC, you have Google tuning the decongestion
[00:39:44] <bascule> eternaleye: you keep saying words, but I don't think the words mean what you think they mean, heh
[00:40:02] <eternaleye> bascule: Well, they may mean different things to different people.
[00:40:27] <tiffany> why does this include sequence number and acknowledgement fields?
[00:40:29] <eternaleye> bascule: But you keep coming back to specific protocols, which is kind of not the issue when it comes to Tng
[00:40:42] <bascule> eternaleye: I guess I care more about specific protocols than I do Tng
[00:40:56] <eternaleye> bascule: Tng is less for people saying "which protocol should I use" and more for people saying "How should my new protocol operate"
[00:41:16] <bascule> cool, well, I want to build shit and don't have decades to wait for people to design the perfect protocol
[00:41:23] <eternaleye> bascule: Yes.
[00:41:30] <tiffany> so I only care about the cryptography layer
[00:41:37] <tiffany> does the implementation actually distinguish the different layers?
[00:41:41] <bascule> also while I haven't read the Tng paper
[00:41:42] <eternaleye> bascule: Tng is for people to be able to make case-specific protocols in a sane manner without it taking FOREVER
[00:41:53] <bascule> my reaction to Dissent is it has great properties on paper and pretty shitty properties in the real world
[00:42:09] <eternaleye> bascule: Tng and Dissent are so unrelated it's not even a thing
[00:42:14] <eternaleye> bascule: Neither even mentions the other
[00:42:25] <bascule> sounding kind of similar to me...
[00:42:55] <eternaleye> bascule: It's just that Tng, as a thing for networking, fits better in the DEcentralized and DIStributed systems group's remit than anywhere else at Yale.
[00:42:59] <Ilari> The congestion control is so serious thing that TCPM WG (which maintains TCP) is allowed to specify new TCP congestion controls by itself.
[00:43:04] <Ilari> *is not allowed
[00:43:26] <eternaleye> bascule: That's literally the limit of their connection.
[00:43:40] <bascule> Ilari: seems like the model the world is moving to is having multiple different decongestion algorithms and dynamically choosing the optimal one based on network behavior
[00:43:45] <eternaleye> bascule: Tng started as an outgrowth of Bryan Ford (the packrat parsers guy) designing SST
[00:44:04] <eternaleye> bascule: Oh, that Remi thing?
[00:44:07] <bascule> eternaleye: sure, and CapTP started as an outgrowth of Mark Miller designing E
[00:44:13] <eternaleye> bascule: Exactly.
[00:44:23] <bascule> and... nobody uses any of that, because it's not really practical
[00:44:26] <eternaleye> bascule: He was never involved in Dissent
[00:44:28] <eternaleye> bascule: At all
[00:44:31] <bascule> except maybe Cap'n Proto ;)
[00:44:44] <eternaleye> bascule: He wanted to design a protocol, and then found "Wait, this taxonomy is _shit_"
[00:44:56] <Ilari> TCP-unfrendliness is viewed as _extremely_ bad thing (threat against everyone).
[00:45:05] <bascule> and went down the conceptual rabbit hole, never to emerge
[00:45:37] <bascule> Ilari: there's definitely some retuning to be done on the layer 4 side if you want to favor these sorts of UDP-based transports
[00:45:48] <bascule> but they aren't necessarily TCP-unfriendly
[00:46:28] <Ilari> In that 4-layer model, I don't think you can actually stick anything more to the third layer if you put UDP there.
[00:47:20] <Ilari> At least I don't think Linux allows doing that.
[00:47:24] <eternaleye> Ilari: UDP is pretty much a perfect realization of the 'endpoint layer'
[00:47:50] <eternaleye> Ilari: (well, its checksums are a wasted effort what with the isolation layer, but it's pretty damn close)
[00:49:04] <Ilari> OTHO, Linux allows putting all kinds of weird stuff into 2nd layer (and even allows screwing with these things in userspace if you want).
[00:49:10] <eternaleye> bascule: To make a comparison, Tng says "trait Transport { } is an awful API. We should split it up into small, targeted traits like Endpoint { } (which struct UDP is a really nice impl of)"
[00:51:37] <Ilari> E.g. Want to stick IPv4 and IPv6 as sublayers of 2nd layer? No problem.
[00:56:25] <Ilari> Well, There might be ways to play odd tricks with 3rd layer (I think there are a few applications that do).
[01:09:22] <tiffany> I had skimmed that text and read struct and got worried
[01:09:41] <tiffany> far too many protocols and file formats rely on sending C structs over the internet
[01:10:57] <tiffany> heh, the checksum field
[01:11:15] <tiffany> but the header length wouldn't be aligned to 4 bytes without it!
[01:11:49] <tiffany> capn proto is surprisingly picky about alignment, requiring 8 bytes
[01:13:08] <Ilari> Lol... Some advice from MS to disable TLS ciphersuites breaking Windows Update.
[01:17:13] <Ilari> Lol: "If you discover a major security vulnerability, do you first contact (a) the vendor (b) the press (c) a lawyer; or (d) a graphic designer."
[01:26:28] <Ilari> bascule: Also, apparently TRAM tried to use some bad crypto and got DISCUSS for it.
[01:48:25] *** Joins: gsingh93 (gulshan@moz-3fu4am.mi.comcast.net)
[02:12:02] *** Joins: adu (ajr@moz-0foa9t.md.comcast.net)
[02:31:01] *** Quits: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua) (Ping timeout: 121 seconds)
[02:33:48] <bascule> o_O https://news.ycombinator.com/item?id=9163294
[02:34:02] <bascule> RSA, ECC, who cares, I want to completely reinvent PKI from the ground up
[02:43:36] <Ilari> Hmmm... "IETF-EC-448" (from PHB post).
[03:06:53] *** Joins: tan (tan@moz-rrp3h1.fios.verizon.net)
[03:07:20] *** Quits: tan (tan@moz-rrp3h1.fios.verizon.net) (Quit: Leaving...)
[04:02:25] <adu> I all
[04:02:41] <adu> I renamed my library from "cryptoil" to "sha"
[04:03:32] <adu> and published in on cargo
[04:04:19] <adu> it was tough deleting all the SIMD stuff to make it work with current rust
[04:36:01] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[04:47:45] *** Joins: erickt (erickt@moz-hc1ntj.sntcca.sbcglobal.net)
[04:50:08] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[04:55:25] <Ilari> adu: It should works on current rust if you disable debug assertions.
[04:56:07] <adu> SIMD is working again?
[04:56:20] <Ilari> adu: You are meaning the ICE or something else?
[04:56:24] <adu> or did someone just figure out that as a work-around?
[04:56:41] <Ilari> Work-around.
[04:56:55] <adu> yes
[04:57:11] <Ilari> Unfortunately, there doesn't seem to be a way to disable debug assertions without disabling debug symbols.
[04:57:51] <adu> https://github.com/rust-lang/rust/issues/23155
[04:57:52] <adu> https://github.com/rust-lang/rust/issues/23037
[04:57:56] <adu> https://github.com/rust-lang/rust/issues/19917
[04:57:59] <adu> https://github.com/rust-lang/rust/issues/17170
[04:58:11] <adu> it's one of those SIMD ICE's
[04:59:22] <adu> I think the first two are duplicates, actually
[04:59:55] <Ilari> The two others look older?
[05:00:44] <Ilari> adu: One can recognize the first two by error talking something about overflow.
[05:01:29] <Ilari> adu: It could even be possible (if unlikely) that you hit ICE that isn't any of those.
[05:01:56] <adu> yes, there was one involving u32x4(0, 0, 0, 0).0
[05:02:22] <Ilari> Bug number?
[05:02:23] <adu> but that's an issue with tuple syntax, not simds
[05:02:32] <adu> I don't remember if it has a bug number
[05:03:31] <adu> anyways, I think I'm going to stay away from simd for now
[05:03:34] <Ilari> Well, if it doesn't (and it isn't subcase of another bug, which would mean it has bug number), it should be reported  (unless already fixed).
[05:03:37] <adu> until the dust settles
[05:06:53] <adu> Ilari: ah, I found it
[05:06:54] <adu> http://is.gd/Cq9TVU
[05:06:58] <adu> that's the tuple one
[05:07:20] <adu> "extractvalue indices invalid"
[05:08:00] <adu> https://github.com/rust-lang/rust/issues/3170
[05:08:04] <adu> https://github.com/rust-lang/rust/issues/13701
[05:09:40] <adu> Ilari: I think I finally got the OOP stuff "perfect" for Digests
[05:09:42] <adu> http://andydude.github.io/rust-sha/sha/sha256/struct.Sha256.html
[05:10:09] <adu> you can even use std::hash to get the first 8 bytes of a Sha256 digest :)
[05:13:27] <adu> and the fact that digest() returns Self lets you use it as "Sha256::default().digest(message).to_hex()"
[05:31:27] *** Quits: gsingh93 (gulshan@moz-3fu4am.mi.comcast.net) (Ping timeout: 121 seconds)
[06:06:06] *** Quits: erickt (erickt@moz-hc1ntj.sntcca.sbcglobal.net) (Ping timeout: 121 seconds)
[06:15:08] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[07:21:17] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[07:31:17] *** Quits: adu (ajr@moz-0foa9t.md.comcast.net) (Client exited)
[07:33:01] *** Quits: enix (enix@moz-0mgr2v.fios.verizon.net) (Ping timeout: 121 seconds)
[08:18:10] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[08:22:38] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[09:18:55] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[09:23:43] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[11:08:17] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[11:12:27] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[13:29:52] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[13:40:43] *** Joins: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua)
[14:12:13] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[14:16:59] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[14:31:41] *** Joins: branchp (branchp@moz-k5a.7g2.93.84.IP)
[14:58:27] *** Joins: adu (ajr@moz-0foa9t.md.comcast.net)
[15:33:19] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[15:56:09] *** Quits: adu (ajr@moz-0foa9t.md.comcast.net) (Client exited)
[17:05:53] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[17:19:18] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[17:20:12] *** Joins: adu (ajr@moz-0foa9t.md.comcast.net)
[17:29:31] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[17:37:56] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[17:53:04] *** Quits: adu (ajr@moz-0foa9t.md.comcast.net) (Client exited)
[18:05:31] <Ilari> I actually mostly made my hashes crate overflow-compatible (mostly, because usize->Wrapping<u32> and Wrapping<X>->u8 conversions are still overflow-unfriendly). However, the ECC crate is much more difficult to convert.
[18:19:00] <Tobba> why would you rely on overflow semantics in ECC
[18:19:14] <bascule> lolol
[18:19:34] <bascule> did the Wrapping stuff actually land yet?
[18:19:40] <bascule> seems kinda... shitty
[18:19:42] <Tobba> my implementation completely avoids it
[18:20:06] <Tobba> though it doesn't do those really nonsensical fucky implementations for specific prime fields
[18:20:13] <bascule> also it took me about 30 minutes to figure out how to parse a hexadecimal string into an integer today o_O
[18:20:26] <bascule> the eventual solution was just grepping the rust source code
[18:20:59] <bascule> but hey, now I'm iterating over the pkt-lines of a Macaroon, yay!
[18:24:56] <Ilari> Worse, it landed partially. Missing big enough chunks that your code will break again.
[18:26:23] <Ilari> E.g. You seemingly can't do truncating cast from u32 (or its wrapping version) to u8 in a way that won't break when rest of the changes land.
[18:26:32] <bascule> o_O
[18:27:09] <Dcoder> it made me replace n*(n-1) with n*n - n
[18:27:18] <Dcoder> which means you can rely on integers to be a ring anymore
[18:27:20] <Dcoder> can't
[18:27:22] *** Joins: adu (ajr@moz-0foa9t.md.comcast.net)
[18:31:07] <Ilari> Also annying that one can't use <op>= for wrapping types.
[18:31:25] <Dcoder> is that a temporary limitation or by design?
[18:31:42] <Ilari> Dunno.
[18:34:49] <Ilari> I thought l <op>= r; was internally just turned into l = l <op> r, but apparently not.
[20:36:45] *** Quits: adu (ajr@moz-0foa9t.md.comcast.net) (Client exited)
[22:06:53] *** Joins: adu (ajr@moz-18snl1.fios.verizon.net)
[22:07:35] *** Quits: adu (ajr@moz-18snl1.fios.verizon.net) (Client exited)
[22:24:41] *** Joins: adu (ajr@moz-18snl1.fios.verizon.net)
[22:30:45] *** Quits: adu (ajr@moz-18snl1.fios.verizon.net) (Client exited)
[22:33:57] *** Joins: adu (ajr@moz-18snl1.fios.verizon.net)
[22:54:12] *** Quits: adu (ajr@moz-18snl1.fios.verizon.net) (Client exited)
[22:56:09] *** Joins: enix (enix@moz-0mgr2v.fios.verizon.net)

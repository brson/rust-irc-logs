[00:00:04] *** Quits: lucian (lucian@moz-22A14C6A.cable.virginmedia.com) (Input/output error)
[00:00:35] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[00:00:55] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: Places to go, people to annoy)
[00:01:20] *** Quits: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com) (Quit: pcwalton)
[00:01:25] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[00:01:35] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[00:01:41] *** Quits: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com) (Quit: tikue)
[00:02:15] *** Quits: lucian (lucian@moz-22A14C6A.cable.virginmedia.com) (Ping timeout)
[00:02:34] *** Joins: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP)
[00:03:02] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[00:03:10] <mihneadb> cmr: how do you "use" extra::stats?
[00:03:14] <mihneadb> it's not in std, is it?
[00:03:25] <strcat> extern mod extra;
[00:03:27] <cmr> mihneadb: `extern mod extra; use extra::stats;`
[00:03:32] <mihneadb> thanks
[00:03:33] <mihneadb> ah
[00:03:38] <mihneadb> just std gets linked by default
[00:03:38] <mihneadb> ?
[00:03:40] <strcat> yes
[00:03:40] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[00:03:42] *** Joins: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com)
[00:03:51] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[00:04:21] <strcat> imo we should pick and choose the parts of libextra we are willing to standardize/maintain and move the rest out to other repositories soon
[00:04:29] <strcat> so we just have libstd
[00:05:05] <mihneadb> cmr: so.. if I have pub fn foo in stats.rs
[00:05:06] <sully> at this point in the language evolution, though, having lots of things in the main rust build is good
[00:05:16] <sully> because it means that things don't bitrot
[00:05:27] <mihneadb> cmr: trying to do use extra::stats::foo; unresolved import
[00:05:36] <mihneadb> does this not work for functions?
[00:05:59] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[00:05:59] *** ChanServ sets mode: +o brson
[00:06:35] <cmr> rusti: extern mod extra; use extra::getopts::optopt; optopt();
[00:06:36] -rusti- <anon>:5:9: 5:26 error: "extern mod" declarations are not allowed here
[00:06:36] -rusti- <anon>:5          extern mod extra; use extra::getopts::optopt; optopt();
[00:06:36] -rusti-                   ^~~~~~~~~~~~~~~~~
[00:06:36] -rusti- error: aborting due to previous error
[00:06:36] -rusti- application terminated with error code 101
[00:06:39] <cmr> oh pfah
[00:07:24] <cmr> mihneadb: it does work with functions though
[00:07:30] <cmr> mihneadb: what's the exact code you're using?
[00:08:49] <mihneadb> cmr: http://pastebin.mozilla.org/2790382
[00:08:55] <mihneadb> did a whole make
[00:09:00] <mihneadb> maybe I should make clean first?
[00:09:21] <bblum> toddaaro: during stuff like change_task_context, the task has been taken out of TLS in order to pass it around, right?
[00:09:23] <cmr> did you make install?
[00:09:41] <toddaaro> bblum: which task?
[00:09:48] <bblum> the task about to deschedule
[00:09:53] <bblum> or switch or whatever
[00:10:04] <mihneadb> cmr: did not! thanks :)
[00:10:17] <toddaaro> bblum: change_task_context grabs the old task by taking it out of TLS, so you should never need to worry about that aspect of it
[00:10:26] <toddaaro> by the time the function "is done" the next task should be in TLS
[00:10:27] <mihneadb> cmr: works nwo
[00:10:28] <mihneadb> now
[00:10:29] *** Joins: pcwalton (pcwalton@moz-BBE3ABD.mv.mozilla.com)
[00:10:29] *** ChanServ sets mode: +o pcwalton
[00:10:35] <mihneadb> I ll make a pull req and go from there
[00:10:40] <bblum> ooh, i see
[00:10:42] *** Quits: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com) (Quit: ecr)
[00:11:23] *** Quits: dew (Instantbir@moz-8A63B53.dhcp.stls.mo.charter.com) (Connection reset by peer)
[00:11:41] *** Quits: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP) (Client exited)
[00:14:02] *** Quits: jorendorff (jorendorff@moz-1747FB68.hsd1.tn.comcast.net) (Ping timeout)
[00:15:31] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[00:16:09] *** Quits: mschifer (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[00:16:39] <tikue> the borrow checker is having problems recognizing that a pointer is no longer borrowed at the end of a block. is there a way around this?
[00:16:55] <strcat> what's an example?
[00:17:07] <tikue> sec
[00:17:18] <Eridius> huon wilson doesn't hang around here, does he?
[00:17:24] <cmr> Eridius: he's dbaupp
[00:17:31] <Eridius> haha ok
[00:17:37] <Eridius> dbaupp: you around?
[00:17:42] <tikue> strcat: https://gist.github.com/tkuehn/8749469b17b7e4a8e432
[00:20:47] <strcat> tikue: it is still borrowed, because you're pushing them somewhere
[00:21:27] <tikue> strcat: how do you do a tree iterator without this problem?
[00:21:34] <tikue> without using @ 
[00:22:09] <strcat> it uses &
[00:22:32] <strcat> you can write a mutable one
[00:23:03] <strcat> but you can't yield &mut and *also* store something it can reference
[00:23:27] <strcat> if you yield &mut Foo, you can't have any references left to anything inside Foo anywhere
[00:23:51] <tikue> I'm not seeing a good way to do this without using @mut
[00:23:56] <cmr> unsafe code!
[00:23:58] <cmr> ;p
[00:24:01] <strcat> cmr: no
[00:24:05] <strcat> it's not a safe interface
[00:24:18] <cmr> right
[00:24:20] <strcat> the borrow checker is being accurate here
[00:24:21] <mihneadb> make check takes forever
[00:24:36] <strcat> it's not really a limitation
[00:24:47] <strcat> @mut makes the possible failure cases dynamic + adds more
[00:24:57] <tikue> heh
[00:24:57] <cmr> right, and I'm saying (half-jokingly) the good way to do it without @mut is unsafe code
[00:25:00] *** Quits: lmandel (lmandel@279FD858.EFF8FC7B.ADB88A9.IP) (Quit: lmandel)
[00:25:03] <tikue> ok
[00:25:04] <tikue> fair enough
[00:25:06] *** Joins: jj2baile (jon@moz-DCEF6040.csclub.uwaterloo.ca)
[00:25:44] <tikue> strcat: the problem is 
[00:26:09] <strcat> you basically can't have an &mut iterator over tree nodes
[00:26:18] <strcat> it can yield &mut to fields
[00:26:23] <strcat> but it can't overlap with the children
[00:26:33] <strcat> since then you have aliasing &mut references to nodes
[00:26:36] <tikue> strcat: the problem is that that is very limiting
[00:26:45] <tikue> strcat: there are safe ways to use a mutable tree iterator
[00:26:57] <strcat> well it's fundamentally required for the interface to be safe though
[00:26:59] <Eridius> strcat: was there an intentional decision to try to match python behavior for a bunch of things, or is that just an artifact of people's familiarity with python?
[00:27:05] <tikue> strcat: and it needs to be mutable if you want to use, e.g. iter().find() to get a mutable ndoe
[00:27:17] <strcat> Eridius: the latter
[00:27:22] <strcat> it's the same as D and Boost.Range and Python
[00:27:31] <strcat> it's closest to D
[00:27:42] <Eridius> strcat: I've never touched D. Where's the documentation on that?
[00:27:53] <strcat> Eridius: http://dlang.org/phobos/std_range.html
[00:28:14] <Eridius> the vector splitting iterators seem to match python split behavior, but python splitting behavior feels wrong to me (it behaves differently than other languages I'm failiar with)
[00:28:22] <strcat> Eridius: Iterator is D's InputRange, Iterator+Clone is ForwardRange, DoubleEndedIterator is BidirectionalRange, RandomAccess <-> RandomAccess
[00:28:46] <tikue> Eridius: vector splitting?
[00:28:57] <strcat> Eridius: the vector split ones do what rust's old functions yielding ~[] did
[00:29:00] <Eridius> tikue: yeah, there's functions .split_iter(), .splitn_iter(), etc
[00:29:26] <strcat> they inherited the old behaviour rather than explicitly having that design decision
[00:29:41] <Eridius> in this particular case, splitn() returns up to N+1 subsequences, which feels weird (splitn to me means return up to n sequences), and it also returns an empty sequence after the last element in the list, if the last element was split on
[00:29:45] <Eridius> which is also weird to me
[00:30:03] *** Quits: ozten (ozten@moz-DD3B00B4.hsd1.wa.comcast.net) (Quit: ozten)
[00:30:15] <tikue> strcat: bottom-up iteration could work, right?
[00:30:49] <strcat> tikue: well you then can't yield another &mut Node until the last you yielded is gone
[00:31:01] <strcat> tikue: they can't ever have &mut Node and also a reference to a child
[00:31:08] <tikue> right
[00:31:08] <tikue> ugh
[00:31:17] <tikue> so basically there's no good way to do tree iteration
[00:31:24] <strcat> you can do tree iteration
[00:31:34] <strcat> you can't yield &mut references to Node objects referencing the children
[00:31:41] <tikue> that's what i would consider tree iteration
[00:31:57] <strcat> you can do it with &, or you can yield &mut to every field except the children
[00:32:09] <tikue> strcat: how?
[00:32:17] <strcat> tikue: pattern-matching out the children field
[00:32:23] <tikue> strcat: interesting
[00:32:25] <strcat> like this
[00:32:27] <tikue> let me try that
[00:32:30] *** Joins: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca)
[00:32:40] <strcat> rusti: let mut t = (1, 2); let (ref x, ref mut y) = t; (*x, *y)
[00:32:40] -rusti- (1, 2)
[00:32:45] <tikue> yeah
[00:32:47] <tikue> thanks i'll try that
[00:33:34] *** Quits: dim-an (ermolovd@moz-A1FD62E4.yandex.net) (Quit: dim-an)
[00:33:50] <strcat> tikue: so you could have NodeProxy or something with every field but 'children'
[00:33:56] <strcat> with &mut refs
[00:34:23] *** Joins: vk (chatzilla@moz-389FEE13.hsd1.ca.comcast.net)
[00:34:24] <tikue> eh actually this isn't what I want
[00:34:46] <tikue> i want to be able to do tree.mut_iter().find(|node| node == something)
[00:34:56] <tikue> which is obviously safe
[00:34:58] *** Quits: brianm (brianm@moz-9B7D279E.dsl.static.sonic.net) (Quit: Leaving...)
[00:35:24] <strcat> tikue: is == going to compare by object identity, or does it actually have to compare fields?
[00:35:36] <tikue> strcat: it'd be node.id == something
[00:36:01] <kmc> did uint::range turn into uint::iterate? and the bounds are different now?
[00:36:17] <strcat> uint::iterate is going to be removed
[00:36:24] <strcat> uint::range was replaced by the 'range' iterator
[00:36:34] <kmc> how do i use that?
[00:36:46] <strcat> rusti: for x in range(0, 3) { printfln!("%d", x) }
[00:36:47] -rusti- 0
[00:36:47] -rusti- 1
[00:36:47] -rusti- 2
[00:36:47] -rusti- ()
[00:36:59] <kmc> ok, thanks
[00:37:08] <strcat> rusti: range(0, 10).zip(range(10, 20)).collect::<~[(int, int)]>()
[00:37:09] -rusti- ~[(0, 10), (1, 11), (2, 12), (3, 13), (4, 14), (5, 15), (6, 16), (7, 17), (8, 18), (9, 19)]
[00:37:15] <tikue> rusti: for x in range(0u, 3) { printfln!(x); }
[00:37:16] -rusti- 0
[00:37:16] -rusti- 1
[00:37:16] -rusti- 2
[00:37:16] -rusti- ()
[00:37:19] <kmc> so it uses return type inference to know that I wanted uint?
[00:37:40] <strcat> kmc: well it's just (start: A, stop: A) and then it yields A
[00:37:43] <engla> it's a normal generic function
[00:37:45] <strcat> so it could infer from multiple places
[00:38:04] <strcat> but integer literals fall back to 'int' if it can't infer.... so you have to be careful
[00:38:09] <kmc> right
[00:38:19] <strcat> I have an RFC open about removing that fallback, but not everyone would agree
[00:39:00] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Connection reset by peer)
[00:39:03] *** Joins: maxli1 (maxli@B5559308.9C54E60.2FA4EA88.IP)
[00:40:36] <kmc> Haskell has it too, but warns with -Wall
[00:40:40] <kmc> (GHC does I mean)
[00:41:33] <strcat> kmc: it defaults to Integer though
[00:41:37] <strcat> and that's a bigint
[00:41:57] <strcat> defaulting to `int` can easily cause bugs - you may have wanted uint, and when we should eventually have inference extended to big ints
[00:42:18] <strcat> or maybe you wanted a type with checked overflow - default to `int` prevents making that first-class
[00:42:22] <strcat> defaulting to*
[00:42:54] <strcat> it's just scary to have both inference + a fallback when there are big semantic differences
[00:43:28] <strcat> ghc also has generic string literals but it's not like your program will break because you have a slower string ;p
[00:44:17] <kmc> right
[00:44:36] <kmc> why would I get "cannot borrow immutable self value as mutable" in a function which is fn foo(&mut self, ...)
[00:45:05] <tikue> kmc: if the struct calling the method is immutable
[00:45:15] <kmc> hm right
[00:45:44] * strcat wants to remove Times ;s
[00:46:03] <tikue> strcat: you mean...
[00:46:28] <tikue> rusti: do 10.times { print("hi"); }
[00:46:29] -rusti- hihihihihihihihihihi()
[00:47:18] <strcat> yes - I think it's not worth having
[00:47:34] <cmr> I agree
[00:47:35] <strcat> you can't break from it and you have the restrictions of a closure, to save a few characters
[00:47:37] <cmr> it's cute, but nothing more
[00:47:38] <Eridius> strcat: whoa, D's splitter is really weird
[00:47:46] <tikue> strcat: pcwalton agrees
[00:47:53] <strcat> Eridius: also http://www.boost.org/doc/libs/1_54_0/libs/tokenizer/
[00:47:58] <strcat> Eridius: it's a whole lib ;3
[00:48:09] <Eridius> it doesn't give you an empty elem at the end (which is what python does) if the last element matches... unless you're splitting a string consisting purely of one instance of that element. Then it does
[00:48:13] <Eridius> that's really screwy
[00:49:29] <Eridius> I assume they were trying to let the output distinguish between the case of splittign an empty list, and splitting a list with one elem that matches the separator, but honestly the right solution would have been to make the empty list return an empty list
[00:53:28] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[00:54:29] <bjz> strcat: agree re. times, sadly
[00:55:27] <tikue> :( it doesn't hurt to keep it around though
[00:55:36] <tikue> sometimes it _is_ a nice alternative
[00:55:50] <strcat> it does hurt
[00:56:00] <tikue> strcat: why
[00:56:07] <strcat> multiple ways to do the same thing has a cognitive overhead
[00:56:23] <cmr> More docs, more things to explain to users, longer to compile.
[00:56:25] <tikue> strcat: nothing else does what do does
[00:56:25] <strcat> and using 5.times is going to lead to hitting closure-related errors
[00:56:31] <Eridius> it also tempts people to use it even though it's sub-optimal
[00:56:33] <strcat> tikue: what do you mean?
[00:56:40] *** Joins: dew (Instantbir@moz-8A63B53.dhcp.stls.mo.charter.com)
[00:56:45] <tikue> strcat: for _ in range requires a variable
[00:56:51] <bjz> strcat: are you saying you want you tho have to do: gcd(2i, 3i)?
[00:56:54] <strcat> _ isn't a variable
[00:57:00] <strcat> bjz: no
[00:57:03] <strcat> bjz: it would still infer.
[00:57:05] <Eridius> strcat: tell that to the match checker ;)
[00:57:10] <tikue> strcat: the syntax requires a variable, _ is a placeholder
[00:57:19] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[00:57:19] <strcat> bjz: you'd need one 'i' or a function taking an int somewhere
[00:57:20] <cmr> tikue: the syntax requires a pattern
[00:57:24] <cmr> _ is the blackhole pattern
[00:57:25] <tikue> cmr: fine
[00:57:26] <tikue> :P
[00:57:29] <tikue> my point is
[00:57:30] <bjz> strcat: or gcd::<int>(2, 3)
[00:57:34] <tikue> do doesn't take a pattern
[00:57:42] <tikue> do x.times rather
[00:57:44] <strcat> bjz: well you could have 'let x = gcd(2, 3); foo(x)'
[00:57:47] <strcat> where foo takes int
[00:57:51] *** Joins: samx (sami@moz-48EC0983.dyn.optonline.net)
[00:57:52] <strcat> bjz: but atm, consider this
[00:58:04] *** Quits: maxli1 (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[00:58:16] <strcat> bjz: let x = 10; foo(x); for i in range(0, x) { ... }
[00:58:19] <strcat> where foo takes uint
[00:58:23] <strcat> you're iterating over uints
[00:58:29] <strcat> now remove foo(x), you're iterating over ints
[00:58:39] <strcat> very easy to have bugs from this fallback
[00:58:57] <strcat> using 'int' requires thought - it wraps on overflow, and has a different upper bound than uint
[00:59:41] <strcat> in many cases you really need a big integer
[00:59:51] <strcat> or an overflow-checked fixed-width integer
[01:00:26] <mihneadb> cmr: so if I'm taking an Iterator<U>, most of the times U will be a &-type, correct?
[01:00:43] <strcat> not really most of the time
[01:00:56] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Connection reset by peer)
[01:00:56] *** Joins: eschweic1 (Adium@moz-BBE3ABD.mv.mozilla.com)
[01:01:00] <mihneadb> no?
[01:01:08] <strcat> there are lots of value iterators, like range() and count()
[01:01:11] <mihneadb> I thought when you did .iter() you get an Iterator with &
[01:01:11] *** Quits: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com) (Quit: tikue)
[01:01:13] <strcat> and consume_iter
[01:01:18] <mihneadb> ah, ok
[01:01:21] <strcat> mihneadb: iter() on vectors
[01:01:29] <mihneadb> I see
[01:01:29] <strcat> vectors also have consume_iter()
[01:01:32] <strcat> and mut_iter()
[01:01:38] <mihneadb> consume?
[01:01:43] <mihneadb> what's the semantics of that/
[01:01:48] <strcat> moves the vector into the iterator, yields values
[01:01:50] <mihneadb> I figure you get a copy?
[01:01:51] <strcat> without copies
[01:01:53] <mihneadb> ah
[01:01:57] <mihneadb> it actually moves it
[01:01:57] <mihneadb> ok
[01:02:04] <mihneadb> strcat: so..
[01:02:07] <strcat> I think range() will be pretty common
[01:02:15] <mihneadb> if my function takes in Iterator<U> and makes a HashMap<U, uint>
[01:02:21] <mihneadb> and I call it with a "hello".iter()
[01:02:32] <mihneadb> the hash map will end up storing &chars, correct?
[01:02:37] *** Quits: pcwalton (pcwalton@moz-BBE3ABD.mv.mozilla.com) (Quit: pcwalton)
[01:02:37] *** Quits: eschweic1 (Adium@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[01:02:38] <strcat> mihneadb: yes
[01:02:47] <strcat> well, actually no
[01:02:54] <strcat> iter() on &str yields 'char' by-value
[01:02:58] <strcat> str doesn't store char
[01:03:04] <strcat> it stores utf-8
[01:03:06] <strcat> as u8
[01:03:09] <mihneadb> my bad
[01:03:09] <mihneadb> so
[01:03:16] *** Joins: pcwalton (pcwalton@moz-BBE3ABD.mv.mozilla.com)
[01:03:16] *** ChanServ sets mode: +o pcwalton
[01:03:21] <mihneadb> iter on str yields u8, not &u8?
[01:03:28] <strcat> mihneadb: no, it yields 'char'
[01:03:36] *** Joins: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net)
[01:03:41] <mihneadb> oh, it does the conversion
[01:03:42] <cmr> pcwalton: ping
[01:03:43] <mihneadb> ?
[01:03:45] <strcat> mihneadb: yes
[01:03:49] <mihneadb> strcat: ok. then.. 
[01:03:52] <strcat> mihneadb: there's also a byte iterator
[01:03:54] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[01:03:55] <mihneadb> if I have a vector of some structs
[01:03:57] <strcat> but it likely yields u8 by-value
[01:04:00] <mihneadb> and I pass it in to my function
[01:04:02] <pcwalton> cmr: pong
[01:04:09] <mihneadb> will the hashmap end up having &structs ?
[01:04:09] <strcat> mihneadb: pass it how?
[01:04:13] <mihneadb> .iter()
[01:04:14] <strcat> mihneadb: depends on which iterator you use
[01:04:17] <strcat> yes
[01:04:19] <mihneadb> ok
[01:04:19] <cmr> pcwalton: I have a usage of each_path in https://github.com/cmr/rustdoc_ng/blob/master/clean.rs#L1060
[01:04:21] <strcat> with iter(), you will have &Foo
[01:04:28] <strcat> but that's not your function's responsibility to deal with
[01:04:29] <cmr> pcwalton: Is there any other way to do this without iterating over everything?
[01:04:36] <mihneadb> strcat: so they those &Foo's in the hashmap will point to the memory used by the callee?
[01:04:37] <strcat> the caller can use .transform(|x| x.clone())
[01:04:38] <pcwalton> rustdoc is probably a legitimate use of each_path
[01:04:41] <strcat> mihneadb: yes
[01:04:57] <mihneadb> strcat: and is that alright? Will the compiler enforce the lifetime of that?
[01:05:04] <pcwalton> oh hmm
[01:05:08] <cmr> I'm just using it to find the fully-qualified path to a reference to an item in another crate
[01:05:10] <pcwalton> I think there is a function in the decoder for that
[01:05:13] <strcat> mihneadb: yes it will enforce the lifetime - you don't have to worry about that, rust is memory-safe
[01:05:24] <strcat> if you take <A, Iterator<A>>
[01:05:27] <strcat> and they use vec.iter()
[01:05:31] <strcat> A will be &'r T
[01:05:32] *** Joins: chmanchester (chmanchest@E48845AB.3A9F9BD4.4C2245EF.IP)
[01:05:35] <mihneadb> strcat: ok
[01:05:35] <bjz> pcwalton: so you got sprocket working with SDL?
[01:05:38] <pcwalton> isn't there a path thing in the metadata?
[01:05:39] <pcwalton> bjz: yes
[01:05:41] <pcwalton> but it's an updated sdl
[01:05:54] <mihneadb> strcat: and is that OK? In C-land, nice behaviour on the API would clone the stuff into the map
[01:05:54] <strcat> sdl2 yet? ;p
[01:06:10] <strcat> mihneadb: yes that's okay, it's not up to your function to decide
[01:06:14] <bjz> pcwalton: can I use the same principles with glfw?
[01:06:14] <strcat> the caller chooses if they copy or not
[01:06:38] <strcat> mihneadb: you can't force them to copy, move or pass by-reference, if A is generic - they choose
[01:06:45] <pcwalton> bjz: yes
[01:06:54] <mihneadb> strcat: right. I was thinking if there's a way of doing something like *A
[01:06:55] *** Joins: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com)
[01:06:56] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[01:06:58] <strcat> they can use consume_iter to move, iter() to pass by-ref, or iter().transform(|x| x.clone()) to copy
[01:07:03] <strcat> mihneadb: no, and you don't want to
[01:07:04] <cmr> pcwalton: Maybe. Can I ask the decoder or csearch for the path of an item?
[01:07:11] * cmr very unfamiliar with metadata
[01:07:15] <strcat> mihneadb: there's no need to make it not work with by-value iterators
[01:07:19] <pcwalton> cmr: you can ask it for the ebml doc for the item and there's a path tag in there I think
[01:07:25] <pcwalton> you may have to add a method to decoder
[01:07:25] <mihneadb> strcat: ok, I understand. Good guy rustc :)
[01:07:29] <pcwalton> it's under item_path
[01:07:30] <mihneadb> thanks for the tips!
[01:07:33] <strcat> mihneadb: np
[01:07:43] <brson> a rustpkg test is still failing under the new runtime. may not land tonight still :(
[01:08:01] <tikue> son i am disappoint
[01:08:05] <strcat> mihneadb: iter() and consume_iter() are the simple by-ref and by-value cases, and then they can xs.iter().transform(|x| x.clone()) for by-value without moving
[01:08:16] <mihneadb> yep, got it
[01:08:25] <bjz> pcwalton: where should I look for your workaround?
[01:08:30] *** Quits: chmanchester (chmanchest@E48845AB.3A9F9BD4.4C2245EF.IP) (Input/output error)
[01:08:32] <pcwalton> what workaround?
[01:08:34] <mihneadb> strcat: actually, you are right. You do the same in C-land with void* 
[01:08:44] <pcwalton> it's not really a workaround, it's how it's supposed to work :)
[01:08:52] <pcwalton> anyway, look at nes.rc and main.rs in sprocketnes
[01:08:57] <pcwalton> use #[no_main] and define a main function yourself
[01:09:10] <pcwalton> that function can then start the scheduler with std::rt::start if it wnats
[01:09:11] <pcwalton> wants
[01:09:18] <pcwalton> sprocketnes itself is runtimeless though
[01:09:34] <cmr> pcwalton: thanks
[01:09:53] <strcat> C++ iterator functions usually do 'template<typename T> T last(T start, T end) { }' so it would work the same as <A, Iterator<A>>
[01:10:09] <strcat> er
[01:10:12] <strcat> <A, T: Iterator<A>>
[01:10:22] <mihneadb> strcat: was thinking C, but yes
[01:10:23] <mihneadb> ty
[01:10:29] <bjz> pcwalton: how does  it know what the main fn is?
[01:10:29] * mihneadb gtg
[01:10:44] *** Quits: mihneadb (mihneadb@E48845AB.3A9F9BD4.4C2245EF.IP) (Input/output error)
[01:10:52] <pcwalton> bjz: actually for your purposes you can probably just annotate a function with #[start] and not use no_main
[01:11:12] <brson> if you are going to call rt::start then you should use #[start] so you can get the crate map
[01:12:36] <brson> this is how you start the runtime: https://github.com/mozilla/rust/blob/master/src/test/run-pass/core-rt-smoke.rs
[01:12:41] <bjz> pcwalton: so I should remove the do task::spawn_sched(task::PlatformThread) { ?
[01:12:49] <pcwalton> yes,. that is no longer supported
[01:13:03] <brson> and this is how you do it on the main thread: https://github.com/mozilla/rust/blob/master/src/test/run-pass/rt-start-main-thread.rs
[01:13:12] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[01:13:13] <bjz> cool, will look
[01:13:27] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Connection reset by peer)
[01:13:59] <bjz> brson: so it needs the args?
[01:14:20] <brson> bjz: yes, you have to pass the arguments through
[01:14:54] <brson> rustpkg's test_uninstall seems pretty brokish
[01:15:00] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[01:15:18] <bjz> brson: so I don't need #[no_main]?
[01:15:26] <bjz> just #[start]?
[01:15:28] <pcwalton> you don't
[01:16:46] *** Joins: brianm (brianm@moz-9B7D279E.dsl.static.sonic.net)
[01:17:05] <strcat> tikue: we could always special-case 'for' in the same way as 'do'
[01:17:11] <strcat> for range(0, 10) { }
[01:17:22] <strcat> and just have that use _ as the pattern
[01:17:25] <bjz> brson: can a user call start_on_main_thread multiple times in an app?
[01:17:31] <tikue> strcat: that's a very good point
[01:17:41] <strcat> tikue: that involves implementing it as more than just desugaring, but I think it will happen anyway
[01:17:46] <strcat> for sane error messages
[01:17:51] <tikue> heh
[01:17:54] <tikue> what do they look like now?
[01:18:03] <tikue> i haven't got any for error msgs yet
[01:18:10] <strcat> rusti: let foo = 5; for x in foo { }
[01:18:10] -rusti- <anon>:5:22: 6:5 error: type `&mut <VI0>` does not implement any method in scope named `next`
[01:18:10] -rusti- <anon>:5          let foo = 5; for x in foo { }
[01:18:10] -rusti- <anon>:6     };
[01:18:10] -rusti- error: aborting due to previous error
[01:18:10] -rusti- application terminated with error code 101
[01:18:27] <strcat> without a span
[01:18:29] <tikue> rusti: for _ in range(0, 3) { 1 / 0; }
[01:18:29] -rusti- rust: task failed at 'attempted to divide by zero', <anon>:5
[01:18:30] -rusti- rust: domain main @0x7de100 root task failed
[01:18:30] -rusti- application terminated with error code 101
[01:18:33] <tikue> lol
[01:18:40] <strcat> because it happened in expanded code
[01:18:46] <strcat> and not from a macro
[01:19:27] *** Joins: ross (ross@moz-8A84103E.br.br.cox.net)
[01:19:49] <brson> bjz: no, because start_on_main_thread contains global init and cleanup functions. there's another function, run_on_main_thread that can be used though. basically, there are init(), run(), and cleanup()
[01:19:59] <brson> run can be done arbitrary numbers of times between init and cleanup
[01:20:16] <brson> and probably even in parallel with each other
[01:20:16] <bjz> is there an example of run_on_main_thread?
[01:20:31] <brson> bjz: no, it's only used by start_on_main_thread
[01:20:35] <strcat> tikue: I'm also starting to think we need more than desugaring just to make it work directly on an Iterable trait
[01:20:38] <brson> read std/rt/mod.rs
[01:20:40] <strcat> anyway not a big deal
[01:20:47] <strcat> desugaring is a great way to do the initial implementation
[01:21:28] <tikue> strcat: can't wait til it works on iterable traits :)
[01:21:57] <bjz> brson: is it in master yet?
[01:22:19] <bjz> brson: or just on your repo?
[01:22:40] *** Quits: joshua_ (joshua@moz-45967CBE.emarhavil.com) (Ping timeout)
[01:22:45] *** Quits: sully (sully@moz-45967CBE.emarhavil.com) (Ping timeout)
[01:22:47] <brson> bjz: it's on master
[01:22:57] <strcat> bblum: +1 for num_squigglies ;p
[01:23:06] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[01:23:06] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/JJ1jHg
[01:23:06] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[01:23:23] *** Quits: bent (chatzilla@moz-932324BF.hsd1.ca.comcast.net) (Quit: ChatZilla 0.9.90.1-rdmsoft [XULRunner 22.0/20130619132145])
[01:23:36] <bjz> brson: woops! looking at the wrong folder :P
[01:24:12] <bjz> brson: oh cool, run_on_main_thread is pretty simple
[01:25:00] *** Joins: recrack (Mibbit@B4104EBB.3CC170B1.1E14B209.IP)
[01:25:16] <bjz> brson: oh, you need to run init and cleanup though?
[01:26:03] <bjz> brson: I currently have glfw::spawn, I just didn't want to smother folks' use of start_on_main_thread if they wanted it
[01:26:08] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[01:26:08] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/zSeWTQ
[01:26:08] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[01:26:10] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[01:26:10] <ghrust> 01[13rust01] 15bors pushed 7 new commits to 06auto: 02http://git.io/_0swRw
[01:26:10] <ghrust> 13rust/06auto 143c6895d 15Brian Anderson: std::rt: 2MB stacks again
[01:26:10] <ghrust> 13rust/06auto 145cc8fa0 15Brian Anderson: std::rt: Pull RUST_MIN_STACK from the environment
[01:26:11] <ghrust> 13rust/06auto 14c2d1e9e 15Brian Anderson: std: Allow spawners to specify stack size
[01:26:13] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[01:26:27] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[01:26:37] <brson> bjz: yeah, they both do need to be run
[01:26:49] *** Quits: aatch (aatch@moz-B437F499.pocketrent.com) (Ping timeout)
[01:26:55] <brson> bjz: you are encapsulating the runtime startup in glfw::spawn?
[01:27:14] <bjz> brson: aye, I think I'll hae to stop doing that though
[01:27:49] <bjz> don't really want to reduce the flexibility of the lib
[01:27:50] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[01:28:02] <bjz> ie. I want it libby, not frameworky
[01:28:07] *** Joins: aatch (aatch@moz-B437F499.pocketrent.com)
[01:29:58] <brson> Maybe we'll end up making some PlatformThread equivalent that is lighter weight than starting an entire scheduler that might not be used
[01:30:06] * strcat is used to the weird world of python when it comes to libs like that
[01:30:31] <strcat> they put their init code in the module
[01:30:50] <strcat> some nltk libs take 20s to import ;]
[01:31:05] <pcwalton> doesn't Go have static initializers too?
[01:31:14] * strcat forgets
[01:31:34] <pcwalton> http://golang.org/ref/spec#Program_execution
[01:31:39] <pcwalton> func init()
[01:31:50] * pcwalton sighs
[01:32:20] <bjz> brson: this is what I currently do: https://github.com/bjz/glfw-rs/blob/master/src/glfw.rs#L108
[01:33:28] <brson> bjz: i've seen it. newrt doesn't work like that. i understand if that is making you unhappy
[01:33:50] <bjz> brson: no worries, just gotta get used to the new way
[01:34:34] <brson> let's see how much backlash there is before adding PlatformThread back
[01:34:42] <pcwalton> I really like the new way
[01:34:45] <bjz> brson: can't please everyone :) far better we have a nice new rt
[01:34:51] <pcwalton> much cleaner than starting off the main thread and jumping back to the main thread
[01:35:01] <pcwalton> just run your main thread only code on the main thread to begin with
[01:35:15] *** Quits: mark_edward (quassel@981AA104.E81F12CD.76F66111.IP) (Ping timeout)
[01:35:23] <bjz> pcwalton: yeah, I'm sure I will appreaciate the benefits in the future :)
[01:35:33] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[01:35:46] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[01:35:58] <bjz> maybe we could have an attribute for the entrypoint?
[01:36:06] <pcwalton> it's called by libc, so
[01:36:11] <pcwalton> it has to have a name
[01:36:21] <pcwalton> a certain name, that is -- main or WinMain
[01:36:33] <pcwalton> (rather it's called by crt0, sorry)
[01:36:54] <bjz> #[start_on_main_thread] fn main(argc: int, argv: **u8, crate_map: *u8) -> int {
[01:37:01] <pcwalton> you can just do
[01:37:09] <toddaaro> brson: first iteration of workstealing seems to be working
[01:37:17] <pcwalton> #[start] fn main(argc: int, argv: **u8, crate_map: *u8) -> int
[01:37:32] <toddaaro> brson: performance is pretty bad though, likely the naive deque, will have to profile to confirm
[01:37:32] <brson> #[main_thread] fn main() { } imo
[01:37:47] <brson> which would be just like current main but pinned to the main thread
[01:37:49] <bjz> brson: just an idea
[01:37:52] <pcwalton> toddaaro: worse than the shared work queue?
[01:37:59] <toddaaro> brson: around 11.7s before changes, around 12.5s now
[01:38:02] <bjz> brson: dunno how feasable
[01:38:15] <toddaaro> this is for a parfib benchmark, so maybe other cases it is faster
[01:38:31] <bjz> brson: it's good to have the flexibility of calling rt:: start_on_main_thread
[01:39:02] <strcat> bjz: so do you actually need to keep running certain things on the main thread, or only your init code?
[01:39:08] *** Joins: sully (sully@moz-45967CBE.emarhavil.com)
[01:39:34] <bjz> strcat: glfw needs to be schedualed on the main thread, because it works with windowing
[01:39:42] <brson> toddaaro: nice!
[01:40:54] *** Joins: joshua_ (joshua@moz-45967CBE.emarhavil.com)
[01:40:57] <brson> wonder when tiobe will add rust. surely we're more popular than nxt-g, whatever that is
[01:41:28] <bjz> brson: should email them :)
[01:41:38] <brson> oh, it's the lego mindstorms language. i guess we can't beat that
[01:41:46] <bjz> haha
[01:42:10] <brson> we'll, tiobe tracks dozens of languages i haven't heard of. surely we can beat some
[01:42:45] <brson> maybe a dozen. i guess i've heard of most of them
[01:42:55] <brson> rust is better than squirrel though
[01:43:02] <tikue> what is squirrel
[01:43:15] <jeaye> A language.
[01:43:32] <miloshadzic> Are there rust bindings for openssl?
[01:43:55] <bjz> tikue: game scripting lang
[01:44:00] <doomlord> what was that site comparing languages.. the hammer principle or something
[01:45:04] <brson> bbl
[01:45:05] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Quit: leaving)
[01:45:46] <jeaye> bjz: Any progress on getting glfw-rs workin'?
[01:45:55] <bjz> jeaye: almost there
[01:46:00] <jeaye> :D
[01:46:04] <bjz> jeaye: was just discussing it
[01:46:29] <bjz> jeaye: it will be more complex though, not as clean as just calling glfw::spawn
[01:46:37] <bjz> https://github.com/mozilla/rust/blob/master/src/test/run-pass/rt-start-main-thread.rs
[01:47:03] <bjz> jeaye: but there will be benefits to the new way I think
[01:47:23] <jeaye> bjz: Excellent. So that has landed? What else needs to be done?
[01:47:43] *** Quits: samx (sami@moz-48EC0983.dyn.optonline.net) (Quit: This computer has gone to sleep)
[01:47:46] <bjz> jeaye: I think so, rebuilding rust now, and fixing glfw
[01:48:15] <jeaye> Fuck yes. Let me know. Also, I'll test out that shared context bit first thing when I get home tonight.
[01:48:28] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[01:48:31] <bjz> jeaye: sweet
[01:49:14] <toddaaro> wow, upping to parfib(30) from 25 was pretty big
[01:49:36] <toddaaro> workstealing becomes slightly faster, but also uses around 20% of the peak memory that the shared queue does
[01:52:31] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[01:54:19] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[01:54:59] <Eridius> damn, default methods don't let me make any assumptions whatsoever about the type of Self
[01:55:17] <Eridius> I was hoping I could assume certain trait implementations and let any conflicts arise on the impl
[01:55:22] <Eridius> err trait conformance
[01:55:31] <strcat> use trait inheritance if you need it
[01:55:43] <strcat> there's no way to implement default methods for only certain traits
[01:55:49] <strcat> we're missing that
[01:55:58] <bjz> that would be super nice
[01:56:00] <strcat> for only types implementing certain traits*
[01:56:23] * strcat needs it for range's size_hint
[01:56:32] <Eridius> specifically I'm trying to implement saturating arithmetic, and I figured I'd do it as a trait with default methods, and then write empty impls for all the built-in numeric types
[01:56:42] <strcat> well I guess I need something a bit different ;p
[01:57:23] <bjz> Eridius: I feel your pain
[01:57:42] <bjz> Eridius: there are lots of limiting things to traits atm
[01:57:49] <Eridius> I keep needing saturating addition when implementing size_hint(), so I figured maybe I should just write it for real
[01:57:55] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[01:57:58] <bjz> Eridius: hopefully they can be improved though
[01:59:35] <Eridius> ok, inheriting from Int, and using Zero::zero(), seems to be working
[01:59:43] <strcat> acrichto: btw I think something went wrong about the LLVM upgrade
[01:59:57] <strcat> acrichto: you touched the auto clean trigger, but it was before the last touch of the auto clean trigger
[02:00:07] <strcat> so it doesn't actually rebuild automatically - the bots may not have really tested it
[02:00:36] *** Quits: thomaslee (thomaslee@moz-6C3931E3.static.twtelecom.net) (Client exited)
[02:00:38] <bjz> Eridius: the challenge is if you want to imple for a general type, then do speeding impls for specific types
[02:00:45] <acrichto> strcat: lemme look at the logs for the builds
[02:00:47] <bjz> *speedy
[02:01:12] <Eridius> bjz: well that's the normal use-case for default methods, no?
[02:01:45] <strcat> no
[02:01:58] <Eridius> ok sorry, _a_ normal use-case
[02:02:02] <strcat> default methods let you implement the method based on the other methods provided by the trait, or those provided by a trait it inherits from
[02:02:09] <acrichto> strcat: llvm was rebuild on all the bots
[02:02:13] <strcat> acrichto: hrm
[02:02:16] * strcat shrugs
[02:02:18] <acrichto> are there issues?
[02:02:30] <strcat> acrichto: it's not rebuilding for me locally, and I noticed a few other people mention it
[02:02:33] <Eridius> strcat: "Based on the other methods" is what I thought "impl for a general type" meant
[02:02:51] <acrichto> strcat: I've had a few times where 'make; make' actually built it
[02:02:56] <acrichto> for some reason the first one fails, not quite sure why
[02:03:06] <Eridius> hrm is there a way to trigger the test runner from main(), i.e. without passing --test?
[02:03:20] *** Quits: pcwalton (pcwalton@moz-BBE3ABD.mv.mozilla.com) (Quit: pcwalton)
[02:03:21] <strcat> Eridius: it doesn't build the tests without --test
[02:03:34] <Eridius> strcat: and that's not because of the usual #[cfg(test)] directives?
[02:03:45] <strcat> I don't think it will build #[test] fns without --test
[02:03:50] <Eridius> hmm ok
[02:04:26] <strcat> the cfg(test) idiom is mostly to deal with unused imports and helper fns
[02:04:34] <Eridius> strcat: looks like you're right, I can't even call the test manually if I have #[test] on it
[02:09:06] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[02:09:18] *** Quits: echristo (echristo@DCF57675.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[02:11:43] <bjz> Eridius: you can't specialise default impls for *different* trait bounds
[02:11:56] <Eridius> bjz: yeah, that's something I wish you could do
[02:12:01] <bjz> aye
[02:12:46] <bjz> I wish you could impl multiple times on a T, then it would give you and error if there was an ambiguity
[02:13:07] <bjz> would be complex to figure out though
[02:13:38] <strcat> bjz: well we need trait complements ;p
[02:13:38] <Eridius> alternatively I wish you could have some way of saying "if x conforms to interface Foo, then do {stuff with x as a Foo}"
[02:14:03] <bjz> strcat: aye, set operations for trait bounds would be cool
[02:14:05] <strcat> impl<T: Foo + Bar> Baz for T
[02:14:12] <strcat> impl<T: !Foo + Bar> Baz for T
[02:14:14] <strcat> are not overlapping
[02:14:27] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[02:14:34] <bjz> kind of why I wish we used & instead of +
[02:14:41] <strcat> bjz: + is okay
[02:14:51] <strcat> the overloads for set ops in python don't use +
[02:14:53] <strcat> they use the logical operators
[02:14:56] <strcat> | is union
[02:15:00] <strcat> & is intersect
[02:15:06] <strcat> ^ is symmetric difference
[02:15:08] *** Joins: ssalbiz (ssalbiz@moz-DCEF6040.csclub.uwaterloo.ca)
[02:15:14] <ChrisMorgan> - is difference
[02:15:18] <bjz> impl<T: Foo | (Bar & Baz)>
[02:15:44] *** Quits: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se) (Client exited)
[02:15:54] <bjz> I do find the positioning of the trait bounds on an impl super difficult to format
[02:16:02] <bjz> ie presentation wise
[02:16:28] <ChrisMorgan> How often would people actually want such things, though?
[02:16:41] <bjz> ChrisMorgan: I would use them
[02:16:55] <bjz> ChrisMorgan: we could use them in std too
[02:17:02] <ChrisMorgan> I haven't been able to come up with any uses for itâ€”what have I not thought of?
[02:17:02] <bjz> ie. the numerics
[02:17:32] <bjz> strcat: the difficuly with set operations is that they're not very extensible
[02:17:50] *** Joins: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP)
[02:17:59] <ChrisMorgan> bjz: what precisely with the numerics?
[02:18:34] <bjz> specialising for integers, reals etc
[02:18:41] *** Joins: sanxiyn (tinuviel@858F408C.B797260D.EF43EC08.IP)
[02:19:29] <ChrisMorgan> I still want a more specific example.
[02:20:18] <ChrisMorgan> Something like the `abs` jensnockert provided in https://github.com/mozilla/rust/issues/7059?
[02:20:50] <ChrisMorgan> 'Cos that doesn't require such fancy set operations.
[02:22:30] *** Joins: eagen (eagen@moz-92A457CB.hsd1.mn.comcast.net)
[02:30:22] *** Quits: eagen (eagen@moz-92A457CB.hsd1.mn.comcast.net) (Quit: Leaving)
[02:31:04] *** Joins: brson (brson@72B1AFF8.AD1E507F.3688B332.IP)
[02:31:04] *** ChanServ sets mode: +o brson
[02:32:59] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[02:33:32] *** Joins: wizeman (quassel@moz-7B7FCA15.dyn.user.ono.com)
[02:40:56] *** Quits: zz_kimundi (kimundi@moz-22A48A03.dip0.t-ipconnect.de) (Ping timeout)
[02:43:56] *** Joins: zz_kimundi (kimundi@moz-8A1835DB.dip0.t-ipconnect.de)
[02:44:23] *** zz_kimundi is now known as kimundi
[02:46:20] <bjz> ChrisMorgan: I guess it's more when you start getting into abstract algebra. I'll try to get some examples
[02:47:22] <acrichto> brson: is 4479 basically fast_ffi?
[02:48:25] *** Quits: brianm (brianm@moz-9B7D279E.dsl.static.sonic.net) (Quit: Leaving...)
[02:49:08] <strcat> fast_ffi is still slow :S, I think it would be better to not do caching ourselves and rely on jemalloc caching it (it caches up to 4MiB large allocs)
[02:49:53] <bjz> brson: You've met with a terrible fate, haven't you?
[02:50:05] <bjz> brson: fatal runtime error: runtime tls key not initialized
[02:50:36] <bjz> :S
[02:51:29] <sfackler> are static items supposed to default to public?
[02:51:41] <bjz> sfackler: no
[02:51:51] <sfackler> they do currently :/
[02:52:04] <engla> It must be an oversight
[02:52:43] <sfackler> i'll file a bug
[02:52:45] <vk> Hey all, I've got this error, "error: mismatched types: expected `@~[~str]` but found `@std::str::CharSplitIterator<,char>` (expected vector but found struct std::str::CharSplitIterator)" after making the following modification:
[02:52:46] <vk> -            let name = @str::split_char_nonempty(name, '.');
[02:52:48] *** Quits: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP) (Quit: Lost terminal)
[02:52:48] <vk> +            let name = @name.split_options_iter('.', name.len(), false);
[02:52:49] <vk> can a CharSplitIterator be turned into a vector or returned as a vector somehow?
[02:53:20] <acrichto> sfackler: it's a bug, but I think there's an issue already for it
[02:53:26] <engla> vk: yes, if you call .to_owned_vec()
[02:53:47] <acrichto> sfackler: also, I think it's only cross crate they're public by default
[02:54:51] <bjz> brson: I was just doing rt::start_on_main_thread
[02:55:05] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Connection reset by peer)
[02:55:36] <bjz> brson: ohh
[02:55:54] <bjz> brson: does *everything* have to be within the closure?
[02:56:25] <bjz> brson: seems like it
[02:56:34] <vk> engla: cool. thanks!
[02:56:50] *** Quits: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com) (Quit: tikue)
[02:56:52] <bjz> if that's the case, then it would make more sense to have a #[main_thread] attribute
[02:57:13] <brson> acrichto: more or less, yes
[02:57:44] <brson> bjz: using any runtime features before calling rt::init() will fail
[02:57:53] <bjz> mm
[02:57:57] <bjz> I see now :P
[02:57:58] <brson> basically, yes. everything needs to happin in the start closure
[02:58:19] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[02:59:44] <bjz> brson: sweet, we are in business again!
[03:00:05] <bjz> jeaye ^
[03:01:10] *** Joins: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net)
[03:03:11] <bjz> jeaye: pushed!
[03:03:13] *** Quits: nyx (cedalion@moz-FC228802.wp.shawcable.net) (Quit: WeeChat 0.4.1)
[03:03:30] <bjz> brson: so does that mean we now have a Rust runtime?
[03:03:47] <bjz> or is this just a step along the way?
[03:04:56] *** Joins: thesnowdog (doug@94FEF15E.9D0B7490.6F17036B.IP)
[03:05:06] *** Quits: thesnowdog (doug@94FEF15E.9D0B7490.6F17036B.IP) (Quit: WeeChat 0.4.1)
[03:05:49] <strcat> there will still always be C unless we rewrote libc/libuv in rust on certain platforms
[03:06:28] *** Quits: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[03:08:01] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[03:08:02] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1438bf25a to 14bbda3fa: 02http://git.io/N3iJvQ
[03:08:02] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[03:08:12] *** Quits: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net) (Ping timeout)
[03:08:50] <brson> bjz: yes, glfw is running on a basically pure-rust runtime
[03:09:23] *** Joins: brianm (brianm@moz-9B7D279E.dsl.static.sonic.net)
[03:09:50] <strcat> brson: do malloc/free run in the red zone?
[03:10:13] <strcat> like when you've filled a stack segment
[03:10:40] <brson> strcat: no
[03:10:48] <strcat> does the scheduler run them for you?
[03:11:03] <olsonjeffery> brson: i don't know if you're already aware of this, but: i asked in #libuv about methods of transitioning handles to different loops. apparently the only means is via sending across a pipe.
[03:11:09] <olsonjeffery> so. lots of interestingness, there.
[03:11:20] <brson> strcat: in the old runtime they are just like any other ffi. in the new runtime we don't have segmented stacks yet so it's moot.
[03:11:25] <strcat> ah
[03:14:20] <gavinb> When trying to initialise a static constant array, I get the somewhat inscrutable error: "constant contains unimplemented expression type". Does that mean using this type ~[uint] is just unsupported in this version?
[03:14:51] <ChrisMorgan> gavinb: can't have constant owned pointers
[03:14:56] <bjz> brson: https://github.com/bjz/glfw-rs#example-code
[03:15:10] <ChrisMorgan> Instead, use a type like [uint, ..42]
[03:15:37] <ChrisMorgan> e.g. `static NUMS: [uint, ..5] = [3, 1, 4, 1, 5];`
[03:15:46] <gavinb> ChrisMorgan: Aha, thanks - that's perfect.
[03:15:49] *** Quits: sanxiyn (tinuviel@858F408C.B797260D.EF43EC08.IP) (Ping timeout)
[03:15:54] <bjz> gavinb: ~ is malloc/free - you can't do that statically
[03:16:10] <brson> olsonjeffery: maybe they misunderstood the question
[03:16:41] <strcat> rusti: let x = "foo".len;
[03:16:44] -rusti- <anon>:5:17: 5:26 error: attempted to take value of method `len` on type `&'static str` (try writing an anonymous function)
[03:16:44] -rusti- <anon>:5          let x = "foo".len;
[03:16:45] -rusti-                           ^~~~~~~~~
[03:16:45] -rusti- error: aborting due to previous error
[03:16:45] -rusti- application terminated with error code 101
[03:17:04] <joelteon> has tuple syntax changed?
[03:17:08] <strcat> no
[03:17:14] <joelteon> oh
[03:17:17] <joelteon> is in a reserved word now?
[03:17:21] <strcat> yes
[03:17:31] <joelteon> that'll do it
[03:18:27] <olsonjeffery> brson: https://github.com/joyent/libuv/blob/master/include/uv.h#L1084
[03:19:38] *** Quits: ssalbiz (ssalbiz@moz-DCEF6040.csclub.uwaterloo.ca) (Quit: Lost terminal)
[03:19:46] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[03:21:14] <olsonjeffery> i mean, it's for passing file descriptors around, which i take it are the underlying primitives that various uv handles use..
[03:21:35] <olsonjeffery> bnoodhuis said it's basically a thin layer atop sendmsg/recvmsg on unix
[03:21:46] *** Joins: lmandel (lmandel@moz-76CE9D51.cable.teksavvy.com)
[03:22:08] <brson> olsonjeffery: true, if you need to pass file handles between processes then you can do so with pipes
[03:22:27] <olsonjeffery> brson: but that doesn't work w/ network sockets?
[03:23:30] <olsonjeffery> what i read seemed to indicate that it would (server/client network servers was one of the use cases discussed for sendmsg/recvmsg). but maybe im in over my head, heh.
[03:24:22] <brson> for scaling I/O in the rust scheduler we need to be able to create two (or more) uv event loops, open a server socket on one, accept an incoming connection, then migrate that connection from the original uv event loop to another uv event loop. a uv handle is an fd plus some other state and afaik they are associated with a specific event loop, so we need a mechanism to change that association
[03:24:41] <brson> node doesn't have this problem because js is single-threaded
[03:24:48] <brson> so my assumption is that uv doesn't implement such a thing
[03:24:54] <brson> not that I have looked closely
[03:25:18] <Eridius> r? https://github.com/mozilla/rust/pull/8323
[03:25:59] <brson> found another bug in newrt
[03:26:07] * brson failure
[03:26:12] <gavinb> Would a take_n() iterator be generally useful? Return a vector of n elements (i.e. subset) while the predicate is true.
[03:26:34] <strcat> there's take
[03:26:39] <Eridius> gavinb: not sure what you mean
[03:26:56] <strcat> rusti: range(0, 10).take_(5)
[03:27:00] -rusti- {iter: {state: 0, stop: 10, one: 1}, n: 5}
[03:27:00] *** Joins: sanxiyn (tinuviel@858F408C.B797260D.EF43EC08.IP)
[03:27:08] *** Quits: sanxiyn (tinuviel@858F408C.B797260D.EF43EC08.IP) (Input/output error)
[03:27:09] <jeaye> bjz: Awesome! :D
[03:27:26] <strcat> rusti: let xs = range(0, 10).take_(5).collect::<std::hashmap::HashSet>(); xs.len()
[03:27:27] -rusti- <anon>:5:50: 5:71 error: wrong number of type arguments: expected 1 but found 0
[03:27:27] -rusti- <anon>:5          let xs = range(0, 10).take_(5).collect::<std::hashmap::HashSet>(); xs.len()
[03:27:27] -rusti-                                                            ^~~~~~~~~~~~~~~~~~~~~
[03:27:27] -rusti- application terminated with error code 101
[03:27:35] <strcat> rusti: let xs = range(0, 10).take_(5).collect::<std::hashmap::HashSet<int>>(); xs.len()
[03:27:36] -rusti- 5
[03:27:43] <erickt1> bblum: ping
[03:27:44] <sfackler> Eridius: is signed integer overflow defined in Rust?
[03:27:45] <gavinb> Eridius: keep returning groups of N elements until the source is empty
[03:28:10] <Eridius> sfackler: my belief is that yes, overflow is fully defined for both signed and unsigned in Rust
[03:28:17] <strcat> it is
[03:28:29] <Eridius> gavinb: is that different than ChunkIter?
[03:28:40] <strcat> to get undef behaviour you have to use nsw (no-signed-wrap) or nuw (no-unsigned-wrap) in the LLVM ops, and rust doesn't and won't
[03:28:48] <strcat> rust is memory safe.
[03:28:57] <strcat> it couldn't be if it did that, due to the implications of undef behaviour
[03:29:05] <sfackler> right
[03:29:30] <strcat> rust does have things with undefined *results*, like shifts longer than the bit size of the integer
[03:29:36] <strcat> but no undef behaviour in safe code
[03:29:44] <strcat> (but yes - integer overflow always wraps)
[03:29:54] <gavinb> Eridius: oh! I was looking in iterator.rs. Didn't notice that hiding in vec!
[03:30:31] <Eridius> gavinb: yeah you could theoretically write one for generic Iterators, but it's easier to do for vec since you can just take slices of the existing vector
[03:30:40] <Eridius> whereas one with a generic iterator would have to allocate its own buffer
[03:30:57] <strcat> CPUs actually implement it as wrapping, C just leaves it as undefined because unlike unsigned overflow it's rarely used on purpose and it makes it easier to prove loops are terminating
[03:31:03] <gavinb> Right, makes sense - slice is more efficientâ€¦ cool
[03:31:28] <strcat> for (int i = 0; i <= n; i++) {} // always terminates
[03:31:31] <Eridius> gavinb: the idea of a BufferedIterator has been suggested before
[03:31:39] <strcat> for (unsigned i = 0; i <= n; i++) {} // might not terminate
[03:31:48] <strcat> (but you can make better examples with real arithmetic in the end cond)
[03:32:27] <Eridius> for reference, my motivation for doing Saturating now is I was starting to add size_hints to the new vec iterators, and I need to use saturating math again there
[03:32:34] <gavinb> Eridius: well ChunkIter does just what I'm after, so I'll use that and get rid of another 'for' loop. Iterators rock. :)
[03:32:59] <olsonjeffery> brson: https://github.com/joyent/libuv/blob/master/include/uv.h#L372
[03:33:06] <strcat> and it "always terminates" because if if n == INT_MAX, it'd be undefined, and thus not C :)
[03:33:11] <olsonjeffery> i really think this supports actually passing around uv handles..
[03:33:16] <olsonjeffery> ill follow up again, tomorrow.
[03:33:26] <olsonjeffery> if anything, ill just try and gin up a POC in rust, maybe
[03:34:20] <brson> olsonjeffery: ok, that's great
[03:35:39] *** Quits: lmandel (lmandel@moz-76CE9D51.cable.teksavvy.com) (Quit: lmandel)
[03:35:56] *** Quits: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com) (Ping timeout)
[03:36:48] <joelteon> how are you supposed to construct a RecvPacketBuffered?
[03:36:52] <brson> hm, that's going to be a pretty impossible interface to use for our purposes, since it requires creating a pipe endpoint on two different loops. heavyweight and requires knowing ahead of time which loops the transfer is going to happen between
[03:37:07] *** Quits: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net) (Client exited)
[03:37:16] <olsonjeffery> brson: yeah, i noticed that. it seemed like it'd have to be a deliberate step :/
[03:37:39] *** Joins: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net)
[03:37:43] <brson> i guess there might be some kind of round-robin approach we could use to intentionally distribute I/O across cores, but it's not very general
[03:38:05] <joelteon> and is it supposed to represent an endpoint or a packet of data?
[03:38:08] <joelteon> I can't actually tell from reading the source
[03:38:09] <olsonjeffery> well you could set up the pipe at sched-spawn time...
[03:38:19] <brson> would rather just be able to do I/O on whatever core the task happens to be running on
[03:39:15] <ChrisMorgan> Passing sockets to a completely separate process is something which I *really* want in the slightly-longer-termâ€”makes live-upgrading a server process feasible.
[03:39:19] *** Quits: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net) (Ping timeout)
[03:39:19] <olsonjeffery> so, looking at the web server example... main thread that accepts connections starts up, receives incoming requests and passes them off to child-scheds on a round-robbin basis using established pipes..
[03:39:43] <engla> strcat: I hope you don't mind if i ask you about r of https://github.com/mozilla/rust/pull/8265 again?
[03:39:44] <olsonjeffery> anyways, not ideal. im just living in realm of what seems immediately possible.
[03:41:14] <brson> i guess for the server case, if your pattern is just accept->read->repeat, then your tasks are all going to start reading on the same thread anyway, tying them all to the same core, due to the way the scheduler works, so maybe servers are going to have to specifically go out of there way to load-balance
[03:41:37] <strcat> engla: r+
[03:42:03] <brson> no, that's not true as long as individual reads could deregester their handles from the event loop. read currently works like read_start->fill buffer->read_stop
[03:42:24] <brson> after read_stop the scheduler can migrate you to a different thread, so when you resume you could then be doing i/o elsewhere
[03:42:48] <brson> i/o is such a pita
[03:43:37] <bjz> rusti: ||{3}
[03:43:56] <bjz> :/
[03:44:05] <bjz> rusti: ||{3}()
[03:44:05] -rusti- <anon>:5:11: 6:5 error: expected function but found `<VI0>`
[03:44:05] -rusti- <anon>:5          ||{3}()
[03:44:05] -rusti- <anon>:6     };
[03:44:05] -rusti- error: aborting due to previous error
[03:44:06] -rusti- application terminated with error code 101
[03:44:46] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[03:44:48] *** Quits: recrack (Mibbit@B4104EBB.3CC170B1.1E14B209.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[03:44:57] <bjz> rusti: use std::unstable::finally::Finally; ||{3}.finally(|| "hi")
[03:44:57] -rusti- <anon>:5:48: 6:5 error: type `<VI0>` does not implement any method in scope named `finally`
[03:44:57] -rusti- <anon>:5          use std::unstable::finally::Finally; ||{3}.finally(|| "hi")
[03:44:58] -rusti- <anon>:6     };
[03:44:58] -rusti- error: aborting due to previous error
[03:44:58] -rusti- application terminated with error code 101
[03:45:11] <bjz> rusti: use std::unstable::finally::Finally; (||{3}).finally(|| "hi")
[03:45:11] -rusti- <anon>:5:65: 5:69 error: mismatched types: expected `()` but found `&'static str` (expected () but found &'static str)
[03:45:11] -rusti- <anon>:5          use std::unstable::finally::Finally; (||{3}).finally(|| "hi")
[03:45:12] -rusti-                                                                           ^~~~
[03:45:12] -rusti- error: aborting due to previous error
[03:45:12] <engla> strcat: thank you!
[03:45:13] -rusti- application terminated with error code 101
[03:45:19] <bjz> rusti: use std::unstable::finally::Finally; (||{3}).finally(||)
[03:45:19] -rusti- <anon>:5:64: 5:65 error: unexpected token: `)`
[03:45:19] -rusti- <anon>:5          use std::unstable::finally::Finally; (||{3}).finally(||)
[03:45:19] -rusti-                                                                          ^
[03:45:19] *** concrete.mozilla.org sets mode: +M 
[03:45:20] -rusti- application terminated with error code 101
[03:45:44] *** brson sets mode: -M 
[03:46:11] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[03:46:48] <brson> I don't understand how shootout-spectal norm is working: it reads os::args()[1], which is a bogus index
[03:46:55] <brson> several other benchmarks do this too
[03:47:27] <acrichto> brson: I noticed that you and pcwalton originally wrote the 'fixedstacksegment' attribute in LLVM, but I also noticed that adding attributes to LLVM may be easier now than it was before (https://github.com/alexcrichton/llvm/commit/8b627827c47f3acb85d3a89b6f89007b3f951c3e), would you be ok with me modifying/collapsing the llvm patches to add fixedstacksegment as just a string argument? I figured that with fewer patches we could probably upstream ea
[03:47:56] <olsonjeffery> "could probably upstream ea"
[03:48:06] <brson> ugh! why tf can os::args be overridden in TLS
[03:48:12] <acrichto> "could probably upstream easier, but losing  authorship is a shame :(
[03:48:15] <acrichto> "
[03:48:42] *** Quits: Earnestly (earnest@CAE8D902.48DC5685.39C00A7A.IP) (Ping timeout)
[03:48:55] <brson> acrichto: that's fine
[03:55:15] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[03:55:30] <brson> oh, that's hilarious. all these benchmarks that are reading os::args()[1] are *silently failing* in the old runtime
[03:55:48] <strcat> heh
[03:56:15] <strcat> does it add an extra element?
[03:56:31] <strcat> the null?
[03:56:33] <brson> strcat: nope. they are actually failing, but the process is returning 0 for some reason
[03:56:40] <brson> runtime appears to be broken
[03:57:14] <brson> what is going on ...
[03:57:43] <strcat> brson: what's fun is that when I removed the old `for`, I uncovered a broken old iterator by writing a loop with `do` depending on the bool ret value
[03:57:49] <strcat> and... it happened to be the one used to xfail tests
[03:57:57] <strcat> so it passed, because it ignored 99% of the tests
[03:58:02] * strcat sighs
[03:58:16] <strcat> the try-win bot caught it because check-fast uses a different path
[03:58:30] <strcat> (reminds me of that)
[03:58:42] <strcat> bugs breaking the ability to run tests are fun
[04:01:25] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[04:02:21] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[04:02:25] <brson> oh, well. oldrt is dying anyway
[04:03:33] <ChrisMorgan> I've got augmented assignment up to the stage where it fails in LLVM :-)
[04:03:34] <ChrisMorgan> rustc: /home/chris/vc/rust/src/llvm/lib/IR/Instructions.cpp:276: void llvm::CallInst::init(llvm::Value*, llvm::ArrayRef<llvm::Value*>, const llvm::Twine&): Assertion `(Args.size() == FTy->getNumParams() || (FTy->isVarArg() && Args.size() > FTy->getNumParams())) && "Calling a function with bad signature!"' failed.
[04:03:53] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[04:04:22] <strcat> augmented assignment?
[04:04:39] <strcat> oh, the in-place ops
[04:05:32] <ChrisMorgan> Indeedy.
[04:05:53] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[04:06:08] <shachaf> Hmm, rustc crashes when run with argc==0
[04:06:11] <shachaf> task failed at 'shift: empty vector', /home/shachaf/Src/rust/rust/src/libstd/option.rs:348
[04:06:20] <shachaf> kmc will not be surprised to hear this.
[04:06:49] <strcat> shachaf: what exactly are you running?
[04:07:19] <strcat> if I run `rustc` it prints the help
[04:07:23] <shachaf> That's argc==1
[04:07:30] *** Joins: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net)
[04:07:32] <strcat> how can argc be 0?
[04:07:33] <shachaf> I'm running roughly execl("/usr/local/bin/rustc", NULL);
[04:08:07] <shachaf> You'd be surprised at how many programs fail this way.
[04:08:24] * ChrisMorgan has certainly always assumed argc >= 1
[04:08:29] <shachaf> It's not a particularly big deal.
[04:09:06] <shachaf> I don't know of any concrete case where it's been a security issue (you can segfault some common suid binaries this way but not in a useful way).
[04:09:08] <strcat> shachaf: I'm actually surprised the C/POSIX standards allow it to be 0, but indeed they do
[04:10:00] *** Quits: dwhyte (dwhyte@1922756A.EDC594B0.7BF4A4B0.IP) (Client exited)
[04:10:01] <shachaf> strcat: You aren't the only person surprised by it.
[04:10:09] <strcat> related fun thing is pulling an avahi and writing to argv - it changes the program's command line in programs like top, and if you remove the \0 it will mess up programs looking in /proc
[04:10:23] <strcat> (but you're allowed)
[04:10:30] <shachaf> Yep, I've seen that with a program that used strtok to parse argv.
[04:10:36] <strcat> I do that all the time ;]
[04:10:40] <strcat> shachaf: getopt does it
[04:10:42] <strcat> it reshuffles them
[04:10:58] <strcat> it puts switches first basically
[04:11:09] <strcat> so you have a contiguous array of args at the end
[04:11:32] <strcat> anyway it's weird regardless :]
[04:12:09] *** Joins: dwhyte (dwhyte@1922756A.EDC594B0.7BF4A4B0.IP)
[04:12:38] <shachaf> "A few minutes ago I spoke with Ken Thompson. He confirms that he and his colleagues never wanted argc to be 0; and he agrees with me that the authors of C89 should not have allowed that case to be legal. He is pretty sure that Plan 9, in particular, always ensured that argc>=1, by supplying a default environment if necessary."
[04:13:07] <shachaf> I'd like to see a case where it's a security issue but I can't even contrive a realistic one.
[04:13:19] <shachaf> (In C, I mean. This is all a bit off-topic here.)
[04:13:20] <strcat> shachaf: dotfiles are similar
[04:13:23] <strcat> they were an accident
[04:13:41] <strcat> they decided to hide . and .., and did it by checking a[0] == '.'
[04:14:15] <strcat> https://plus.google.com/101960720994009339267/posts/R58WgWwN9jp
[04:14:32] * strcat has alias ls='ls -Ah --color=auto' anyway
[04:15:14] <brson> bblum: bench/task-perf-linked-failure deadlocks
[04:15:19] <brson> i'm going to xfail it for now
[04:15:26] <shachaf> Does -h do anything without e.g. -l?
[04:15:27] <shachaf> I guess it's useful so you can just use -l later.
[04:15:36] <strcat> shachaf: no, but it's harmless without it ;)
[04:16:32] <strcat> I really hate the whole concept of hidden files
[04:16:47] <strcat> especially stupid file dialogs where you sometimes can't even show them
[04:17:28] <Yurumechan> https://github.com/lifthrasiir/rust-encoding/commit/e51b792 ha, error recovery with UTF-8 was hard to get right.
[04:17:28] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Quit: WeeChat 0.4.1)
[04:19:01] <ChrisMorgan> Can I get much debug info from rustc? I imagine I need to recompile it with --enable-debug?
[04:19:08] <strcat> yes
[04:20:39] *** Joins: steven_is_false (user@C5B76363.1FF1EBF8.1ECA502.IP)
[04:21:12] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[04:21:25] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[04:22:16] <sam113101> shouldn't hidden files be a function of the file system?
[04:22:53] <steven_is_false> Okay, many of the people here (like cmr for example) seem to know about and care about sandboxing software, and security somewhat. Does anyone here know any good resources for learning more about securing code with OS support (an example of what I mean is given by this question I asked here http://www.reddit.com/r/AskComputerScience/comments/1jr6hy/how_can_i_practically_and_portable_sandbox_my/ ?)
[04:23:04] *** Quits: jgilbert (jgilbert@moz-7B0110AD.mv.mozilla.com) (Ping timeout)
[04:23:10] <brson> ChrisMorgan: what's the link to your http source?
[04:23:25] <ChrisMorgan> brson: http://hg.chrismorgan.info/rusthttpserver
[04:24:18] <strcat> sam113101: they shouldn't exist at all ;P
[04:25:08] <strcat> instead you can just put files in sane places :S
[04:25:12] <doublec> strcat: something like vx32 might interest you http://pdos.csail.mit.edu/~baford/vm/
[04:25:19] <ChrisMorgan> brson: not especially useful yet; thus far it basically only takes care of the matters of connection management and basic HTTP parsing and emission. No parsing of URLs, no cache directive interpretation, not even transfer encoding yet.
[04:25:21] <doublec> oops, steven_is_false ^^
[04:25:45] <steven_is_false> doublec: Neat.
[04:27:30] *** Quits: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net) (Ping timeout)
[04:27:30] <brson> ChrisMorgan: that's fine. Can I mention it in my status update to the mailing list?
[04:27:38] <ChrisMorgan> Sure.
[04:27:58] <ChrisMorgan> I should already be spending much less time on it than I do, what with Uni work and all...
[04:28:08] <sam113101> strcat: how would IÂ hide my porn folder, though?
[04:28:10] <ChrisMorgan> Such a delightful time-sink, though :-)
[04:31:05] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[04:31:32] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[04:33:12] *** Quits: lucian (lucian@moz-22A14C6A.cable.virginmedia.com) (Ping timeout)
[04:33:13] <steven_is_false> doublec: That's cool but it seems like it's very specific to x86. Also I'm not sure how well Vx32 would work with regards to many small communicating tasks each with the lowest possible permissions.
[04:33:39] <strcat> well, seccomp is great
[04:33:54] <strcat> just disallow anything but read/write/exit/execve and you have a good start
[04:34:13] <steven_is_false> strcat: seccomp seems kind of confusing but I may have to go there.
[04:34:22] <strcat> it's not very confusing
[04:34:35] <strcat> you build a ruleset of allowed syscalls, it's like iptables for syscalls
[04:34:49] <strcat> can choose a set of allowed params too if you want
[04:35:48] <strcat> steven_is_false: https://github.com/thestinger/rust-seccomp/blob/master/seccomp.rs#L98 that's pretty easy
[04:35:56] <steven_is_false> I never understood iptables either :)
[04:36:00] <acrichto> strcat: now we're on LLVM head -- #8328, or at least by just ignoring the assertion failure in llvm...
[04:36:28] <Eridius> strcat: regarding your comment on Saturating, I can rewrite it to be `a.saturating_add(b)` if you think that's better. I just kind of liked the idea of static methods in a trait as a way to namespace them
[04:36:39] <strcat> acrichto: ignoring the assert seems bad...
[04:36:39] *** Quits: boredomist (user@moz-63CF9F31.res-cmts.sesp.ptd.net) (Ping timeout)
[04:36:47] <Eridius> I originally considered making a mod called saturating with a method add, but I decided I didn't want to increase the set of modules
[04:36:48] <strcat> acrichto: the asserts tell you when you would otherwise be corrupting memory, etc.
[04:37:16] <acrichto> strcat: that is true indeed, so far it seems benign and I trust valgrind to tell me otherwise: https://github.com/alexcrichton/llvm/commit/d2a698c4402898f5ca446db0a69e9d10ec47a8c2
[04:37:26] <strcat> acrichto: valgrind doesn't catch memory corruption
[04:37:26] <sfackler> is there any way to get rustc to dump an ast somewhere?
[04:37:30] <strcat> acrichto: it catches a *small subset*
[04:37:42] <brson> ChrisMorgan: what is the path forward for factoring your server into both a client and server?
[04:37:43] <strcat> acrichto: it won't catch overshooting an array and writing into another, or generating bad IR
[04:37:50] <strcat> and so on
[04:38:06] <acrichto> strcat: true, well then we just can't upgrade now I guess
[04:38:32] <strcat> what's the assert?
[04:38:38] <acrichto> strcat: in that link
[04:38:47] <acrichto> the one right below it
[04:38:52] <ChrisMorgan> brson: I'm working more on the HTTP interpretation, using lots of enum and struct goodness rather than lots of strs, and that will cater for both client and server; that's probably the point at which I'll make it both client and server rather than just server.
[04:39:08] <ChrisMorgan> Need to play with ragel.
[04:39:24] <steven_is_false> strcat: note: /usr/bin/ld: error: cannot find -lseccomp What would seccomp be named under for my package manager?
[04:39:33] <steven_is_false> Or do I have to build it from source?
[04:40:03] <strcat> it's libseccomp on my distro
[04:40:54] <steven_is_false> strcat: I should really move to a rolling release distro.
[04:41:26] <ChrisMorgan> steven_is_false: what OS are you using?
[04:41:54] <steven_is_false> ChrisMorgan: I'm currently using the Ubuntu derived Trisquel distro.
[04:42:19] <ChrisMorgan> General idea for such things is that a -lX will be libX, but for a more general approach to find a package, use `apt-cache search seccomp`. This on Ubuntu reveals libseccomp1 and libseccomp-dev.
[04:43:24] <ChrisMorgan> (And you can use `apt-cache show libseccomp-dev` for details of the package.)
[04:43:34] <strcat> you need seccomp2
[04:44:39] <ChrisMorgan> And thus the answer seems to be that it ain't in the Ubuntu package, for libseccomp{1,-dev} are at 1.0.1-2.
[04:44:49] <ChrisMorgan> s/package/package repositories/
[04:45:20] <steven_is_false> Of course, seccomp isn't portable to Windows, or Mac anyways.
[04:45:42] <steven_is_false> I know Windows has it's own arcane security features.
[04:45:53] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Connection reset by peer)
[04:45:55] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Connection reset by peer)
[04:45:55] <ChrisMorgan> s/it's/its/
[04:45:57] *** Quits: jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Quit: zzz)
[04:46:28] <steven_is_false> Yes it is makes no sense in that context.
[04:46:42] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[04:47:02] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[04:47:31] <strcat> steven_is_false: OS X and windows don't have an analogy to seccomp/namespaces though
[04:47:46] <strcat> they have forms of sandboxing, but not ones you would want to run untrusted code under
[04:48:24] *** Quits: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net) (Ping timeout)
[04:48:37] <steven_is_false> Don't people care about security?
[04:49:16] <strcat> well, it's not a common use case
[04:49:35] <strcat> but seccomp is pretty useful as a blunt hammer to limit privs in general
[04:49:40] *** Joins: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net)
[04:49:43] <brson> ChrisMorgan: how much effort is involved in that? servo needs a new http client asap. should i hack on yours or hack together my own replacement in the short term?
[04:49:54] <steven_is_false> I recall that there was some kind of exec function right?
[04:49:55] <strcat> freebsd jails are close to providing the same functionality as namespaces - not quite though.
[04:51:39] <ChrisMorgan> brson: my ideas are rather grand; whether this is a good thing or not remains to be seen. Let me go ahead and push the beginnings of something I'm working on with it and show it to you.
[04:53:09] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[04:53:09] <steven_is_false> strcat: Thanks for the help anyways
[04:53:09] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/M2TzDA
[04:53:09] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[04:54:19] <steven_is_false> I'm looking at the code in std::run, and I think I see a bug.
[04:54:38] <steven_is_false> Isn't the fork(), exec() pattern unsafe in multithreaded programs?
[04:54:39] <vk> I'm getting a @~[&str] out of this, "let name = @name.split_options_iter('.', name.len(), false).to_owned_vec();", is it possible to get @~[~str] out of it instead?
[04:55:20] <Eridius> steven_is_false: fork only preserves the current thread in the new process
[04:55:24] <Eridius> at least, on OS X. I assume that's POSIX
[04:55:38] <steven_is_false> Eridius: Right but it's all overwritten anyways by exec.
[04:55:38] <strcat> Eridius: it is
[04:55:59] <Eridius> steven_is_false: right. so why do you think it's unsafe?
[04:56:06] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[04:56:07] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/7yI8qA
[04:56:07] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[04:56:08] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[04:56:08] <ghrust> 01[13rust01] 15bors pushed 9 new commits to 06auto: 02http://git.io/uLv-kQ
[04:56:08] <ghrust> 13rust/06auto 14473fc5c 15Brian Anderson: std::rt: 2MB stacks again
[04:56:08] <ghrust> 13rust/06auto 146ef93bc 15Brian Anderson: std::rt: Pull RUST_MIN_STACK from the environment
[04:56:09] <ghrust> 13rust/06auto 142f2e102 15Brian Anderson: std: Allow spawners to specify stack size
[04:56:09] *** Joins: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net)
[04:56:11] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[04:56:28] <steven_is_false> Eridius: The fork leaves things in a broken state. With for example locks in malloc left in a bad state.
[04:56:48] <steven_is_false> But everything is overwritten by exec anyways so I guess it doesn't matter.
[04:57:07] <strcat> malloc uses pthread_atfork
[04:58:14] <steven_is_false> strcat: So malloc on Linux "does the right thing" but POSIX doesn't guarantee that behaviour right?
[04:58:34] <strcat> don't know about what POSIX says
[04:59:03] <Eridius> steven_is_false: ok yeah, almost everything is unsafe after a fork(), which is why you typically just exec() after
[04:59:09] * brson crosses fingers
[04:59:41] <Eridius> might be nice to use posix_spawn() on platforms that support it
[04:59:55] <steven_is_false> Eridius: Does that mean a multithread shell would have to do a fork(); exec(self) call for maximum portability?
[05:00:47] <Eridius> steven_is_false: ..maybe? I don't know. I haven't really looked into the issue of unsafety after fork very much, since I've never had any call to do anything besides exec()
[05:00:56] <steven_is_false> Fair enough.
[05:01:56] <Eridius> I suppose in theory you could design your app such that all threads take a read lock (and release it periodically, e.g. every pass through a runloop) and you take a write lock before forking. That way you know all your threads are in a known-good state
[05:02:07] <Eridius> but of course this requires having exclusive control over all threads
[05:02:14] *** Quits: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca) (Connection reset by peer)
[05:03:14] <steven_is_false> Shouldn't some kind of lock suspending the garbage collector, and the task switching be held during the spawn_processs_os call (given forks unsafety?)
[05:03:30] <Eridius> what garbage collector?
[05:04:02] <steven_is_false> Eridius: The one that is planned to land eventually.
[05:04:32] <Eridius> steven_is_false: as long as spawn_process_os doesn't call into the runtime after forking, I don't think there's a problem
[05:06:12] <steven_is_false> Eridius: Are we planning on making a guarantee that Rust will not insert task::yield() calls automatically?
[05:06:23] <Eridius> I have no idea
[05:06:38] <Eridius> one would hope that if we did choose to do that, we'd have some way of disabling it for a span of code
[05:07:15] <steven_is_false> Okay, I'll submit an issue asking for clarification.
[05:07:49] <steven_is_false> Would anyone like to be cc'd?
[05:08:19] <steven_is_false> Also what's the technical name for this guarantee?
[05:09:03] <Eridius> cooperative tasks, as opposed to preemptive tasks?
[05:10:09] <steven_is_false> I guess.
[05:11:37] <strcat> there's an issue about it already
[05:11:55] <steven_is_false> strcat: Oh thanks.
[05:12:10] <steven_is_false> Could give me a link?
[05:12:26] <steven_is_false> *Sorry, I meant "Could you give me a link?"
[05:12:31] <strcat> Eridius: the issue is that actual thread-local storage will get clobbering from a yield
[05:12:37] <strcat> clobbered*
[05:12:41] <strcat> like errno
[05:12:46] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[05:13:21] <strcat> although maybe errno is handled by set_tid_address
[05:13:23] <strcat> dunno
[05:13:24] <Eridius> strcat: yeah I wondered about errno last time I had to use last_os_error
[05:13:43] * strcat isn't sure if errno is normal TLS
[05:13:55] <strcat> if it is normal pthread TLS I guess it'd be fine...
[05:14:42] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[05:15:35] * strcat shrugs
[05:15:38] <Eridius> strcat: do you want me to re-do my Saturating PR to use regular methods?
[05:15:47] <strcat> Eridius: yes
[05:15:56] <strcat> just because it's the convention to use methods
[05:16:19] <Eridius> yeah, I just kinda liked the idea of using a trait as a namespace, but I suppose it's just not very consistent
[05:17:00] *** Quits: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net) (Ping timeout)
[05:18:08] <steven_is_false> If we have task::yield calls inserted automatically that means we'd have Haskell like semantics. If we did that would we need Haskell's ffi's unsafe keyword to indicate that don't mind if any other running Haskell threads in the system are blocked for the duration of the call?
[05:18:16] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[05:18:16] *** ChanServ sets mode: +o dherman
[05:20:10] *** Parts: steven_is_false (user@C5B76363.1FF1EBF8.1ECA502.IP) (ERC Version 5.3 (IRC client for Emacs))
[05:20:41] <strcat> we're really not going to insert yields
[05:20:50] <strcat> it's slow and unpredictable
[05:21:23] <bjz> strcat: too late, he left!
[05:21:29] * strcat shrugs
[05:21:39] <bjz> :P
[05:21:40] <strcat> but really inserting a yield into a loop would be a killer for perf
[05:21:54] <strcat> it would suddenly be 100% opaque to LLVM
[05:22:04] <strcat> no vectorizing, no loop-deletion, no loop-idioms
[05:22:55] <strcat> would not be surprised by a 50% perf hit for rustc, considering just switching to external iterators was a 20% speedup
[05:25:27] *** Joins: maikklein2 (maik@moz-18E00DC1.dip0.t-ipconnect.de)
[05:28:39] <sfackler> what should the ident of a ast::Field from an enum struct expression be?
[05:28:47] *** Quits: maikklein2 (maik@moz-18E00DC1.dip0.t-ipconnect.de) (Ping timeout)
[05:29:42] <strcat> sfackler: enum structs can have named fields
[05:29:54] <strcat> it's probably called __field__ or something like that for unnamed fields in tuple structs
[05:31:55] <Eridius> strcat: switching to a.saturating_add(b) triggered an ICE :/
[05:32:08] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[05:32:10] <sfackler> thanks
[05:32:14] <Eridius> Saturating::add(-2, -max_value) worked, but (-2).saturating_add(-max_value) complained about multiple methods in scope, then ICE'd
[05:32:33] <strcat> -2i
[05:32:37] <strcat> known bug
[05:32:37] <Eridius> yeah I was about to do that
[05:32:52] <strcat> well "bug"
[05:33:08] <Eridius> I guess with the static method approach, the 2nd arg disambiguated it, but with this one it needs the receiver to be explicit?
[05:34:48] <strcat> no, explicitly giving the trait name disambiguated it
[05:35:15] <strcat> saturating_add could be provided by 2 traits
[05:35:18] <Eridius> 2?
[05:35:25] <strcat> yes
[05:35:33] <strcat> there's only a conflict if you try to impl both for a type
[05:35:35] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[05:35:36] <Eridius> what's the 2nd?
[05:35:39] <strcat> *could be*
[05:35:51] <Eridius> ok but it's not. There's only 1 trait with that
[05:35:55] <strcat> it doesn't know
[05:36:01] <strcat> it doesn't know what the type of -2 is
[05:36:14] <strcat> so it doesn't know how to look up the methods of -2
[05:36:23] <strcat> can't infer a type from a method
[05:36:31] <Eridius> I thought the problem was there's multple implementations of Saturating and it didn't know which one to use since it didn't know the type of -2
[05:36:50] <strcat> that too
[05:36:55] <strcat> but you'll find there are more problems
[05:38:16] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[05:38:16] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1407f5c7c to 146f88f4d: 02http://git.io/N3iJvQ
[05:38:16] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[05:38:19] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[05:38:19] <ghrust> 01[13rust01] 15bors pushed 13 new commits to 06auto: 02http://git.io/ac0Pdw
[05:38:19] <ghrust> 13rust/06auto 14ce682cb 15blake2-ppc: std: Add .consume_iter() for Option, to make it reusable...
[05:38:19] <ghrust> 13rust/06auto 14109e0d8 15blake2-ppc: std: Convert Result to use external iterators...
[05:38:20] <ghrust> 13rust/06auto 14c5e4c55 15blake2-ppc: std: Remove unused trait bound in Result::map
[05:38:22] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[05:40:36] <ChrisMorgan> brson: http://hg.chrismorgan.info/rusthttpserver/rev/8dcbac9b2540 shows a little bit of the direction I want to head: structure everywhere, from top to bottom. Got to go just now, be back in quarter of an hour or so and then I'd like to discuss it further with you.
[05:46:17] *** Joins: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net)
[05:46:34] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[05:46:35] <sammykim> acrichto: squashed all commits
[05:46:55] <acrichto> sammykim: thanks!
[05:47:09] <sammykim> acrichto: more thanksful to u!
[05:50:09] <Eridius> strcat: updated the PR
[05:50:40] *** Quits: Jesin (Jessin_@moz-1B1307FF.eecs.lehigh.edu) (Quit: Leaving)
[05:51:35] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[05:51:41] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Ping timeout)
[05:52:47] *** Joins: thomaslee (thomaslee@moz-306D3DF4.hsd1.or.comcast.net)
[05:53:59] *** Quits: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[06:02:07] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[06:02:11] *** Quits: ab (alex@BC9D99CC.37C1012D.FE617B51.IP) (Ping timeout)
[06:02:50] <ChrisMorgan> brson: back now, can discuss this HTTP client business.
[06:04:10] *** Quits: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net) (Connection reset by peer)
[06:04:31] *** Joins: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net)
[06:04:37] *** Quits: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net) (Ping timeout)
[06:08:00] *** Joins: rlin-nb (rlin@moz-99690620.hinet-ip.hinet.net)
[06:08:07] *** Joins: jaen (jaen@moz-E5C38B19.neoplus.adsl.tpnet.pl)
[06:11:25] <sfackler> is there any way to print the ast of a bit of rust code?
[06:13:16] <acrichto> sfackler: --pretty identified
[06:15:24] <sfackler> thanks
[06:16:40] <sfackler> acrichto: can I get the raw ast (e.g. ast::ident{....}) instead of it pretty printed?
[06:17:02] <acrichto> not by default that I know of, but insertion of a %? may help
[06:20:53] *** Joins: jedisct1 (Mibbit@moz-2FCD418B.hsd1.ca.comcast.net)
[06:25:39] <jedisct1> Hi everyone!
[06:26:44] <jedisct1> I was looking for a HTTP server that would work with Rust 0.8, but looking at the recent IRC log, it looks like ChrisMorgan's httpserver is exactly that :)
[06:27:08] <ChrisMorgan> jedisct1: far from full-featured, though.
[06:28:17] *** Joins: sebcrozet (sebcrozet@moz-6DA639AF.w80-13.abo.wanadoo.fr)
[06:28:20] <ChrisMorgan> Nor particularly stable.
[06:30:24] *** Joins: gits1225 (gits@3E55327C.4ABA99D2.C6104E0F.IP)
[06:30:34] *** Joins: dim-an (ermolovd@moz-FE167E47.nationalcablenetworks.ru)
[06:30:58] <sfackler> i'm working on https://github.com/mozilla/rust/issues/2248 but am having trouble constructing an Option type properly. I have https://gist.github.com/sfackler/dec3f284b523bfebd35c, but the stage1 compiler's complaining that "`std::option::Some` does not name a structure". Do variants have different asts than normal structs?
[06:33:19] *** Joins: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net)
[06:35:49] *** Quits: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net) (Ping timeout)
[06:40:32] *** Quits: lerc (quassel@D9C8F2D2.85A70C12.788638A4.IP) (Ping timeout)
[06:41:07] *** Quits: jedisct1 (Mibbit@moz-2FCD418B.hsd1.ca.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[06:41:26] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[06:42:49] *** Joins: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP)
[06:48:47] *** Joins: eatkinson (eatkinson@moz-5CF47426.dia.static.qwest.net)
[06:49:26] <brson> ChrisMorgan: Let's talk another time. I don't think I can concentrate just now
[06:49:36] *** Quits: brson (brson@72B1AFF8.AD1E507F.3688B332.IP) (Quit: leaving)
[06:53:17] *** Quits: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net) (Input/output error)
[06:53:33] *** Quits: nattofriends (tsutsumi@moz-4CEEC7AA.warosu.org) (Ping timeout)
[06:54:14] *** Joins: nattofriends (tsutsumi@moz-4CEEC7AA.warosu.org)
[07:00:21] *** Quits: sebcrozet (sebcrozet@moz-6DA639AF.w80-13.abo.wanadoo.fr) (Ping timeout)
[07:00:43] *** Joins: sebcrozet (sebcrozet@moz-D8879CC3.w80-13.abo.wanadoo.fr)
[07:02:19] *** Joins: jensnockert (jensnocker@moz-5386F410.mobileonline.telia.com)
[07:02:47] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.1)
[07:04:51] *** Quits: sebcrozet (sebcrozet@moz-D8879CC3.w80-13.abo.wanadoo.fr) (Ping timeout)
[07:04:56] *** Joins: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net)
[07:06:17] *** Joins: sebcrozet (sebcrozet@moz-D8879CC3.w80-13.abo.wanadoo.fr)
[07:06:36] *** Quits: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net) (Ping timeout)
[07:08:51] *** Joins: cypher (ircnet@moz-EA42E471.static.surfer.at)
[07:11:25] * ChrisMorgan wonders why with rustc built with --enable-debug and running with RUST_LOG=rustc=4 the compiler sits guzzling a core after `rust: ~"Looking up {crate: 1, node: 128177}"` for half a minute or more before getting any further
[07:11:44] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[07:15:37] <ChrisMorgan> So, any time I use fmt! or anything that uses fmt! (e.g. assert_eq!), rustc takes over a minute longer to compile my code. Weird. And nasty, very nasty.
[07:15:48] *** Quits: jensnockert (jensnocker@moz-5386F410.mobileonline.telia.com) (Input/output error)
[07:16:11] *** Quits: thomaslee (thomaslee@moz-306D3DF4.hsd1.or.comcast.net) (Connection reset by peer)
[07:16:14] *** Quits: vk (chatzilla@moz-389FEE13.hsd1.ca.comcast.net) (Quit: ChatZilla 0.9.90.1 [Firefox 23.0/20130729175331])
[07:16:28] *** Joins: thomaslee (thomaslee@moz-306D3DF4.hsd1.or.comcast.net)
[07:17:09] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[07:17:10] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/ac0Pdw
[07:17:10] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[07:17:49] *** Joins: jensnockert (jensnocker@moz-5386F410.mobileonline.telia.com)
[07:18:45] <ChrisMorgan> ARGH! And compilation fails in a different place altogether with --enable-debug :-(
[07:19:00] <darkf> those are the best kinds of bugs! ;)
[07:19:13] <ChrisMorgan> I mean, with RUST_LOG=rustc=4.
[07:19:16] <darkf> rustc takes like 30-40 minutes to compile for me, rather excruciatingly
[07:20:07] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[07:20:08] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/cMBS4g
[07:20:08] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[07:20:45] <ChrisMorgan> Without RUST_LOG=rustc=4, it gets an LLVM assertion failure which leads to SIGSEGV, but with it, it fails at 'item_path', /home/chris/vc/rust/src/librustc/middle/trans/base.rs:2427.
[07:21:26] <ChrisMorgan> (Thus, an ICE rather than a total crash.)
[07:24:32] *** Quits: ross (ross@moz-8A84103E.br.br.cox.net) (Quit: )
[07:26:09] *** Quits: rfw (rfw@moz-C65A114.rfw.name) (Ping timeout)
[07:28:46] *** Quits: dew (Instantbir@moz-8A63B53.dhcp.stls.mo.charter.com) (Ping timeout)
[07:29:26] *** Joins: rfw (rfw@moz-C65A114.rfw.name)
[07:32:42] <ChrisMorgan> Can one get RUST_LOG to include file names and line numbers whence the output came?
[07:33:33] *** Joins: mcclurmc (mcclurmc@moz-8D61EFD1.cable.virginmedia.com)
[07:35:16] <klutzy> ChrisMorgan: I've reported ICE with RUST_LOG=rustc=4 several months ago
[07:35:28] <klutzy> I don't know if it is fixed now
[07:35:52] <ChrisMorgan> It certainly makes it hard to debug problems in modifications to the compiler.
[07:36:34] *** Quits: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net) (Quit: gavinb)
[07:37:17] <ChrisMorgan> I'm not certain if it's my code which is causing it or not. Whatever it is, RUST_LOG=rustc=4 certainly shouldn't change the failure cause.
[07:37:33] <klutzy> I tried to search the issue and github gave me an unicorn :'(
[07:37:55] <ChrisMorgan> Well, if I remove the use of += it still ICEs in the same way, so I guess it isn't my code.
[07:38:47] *** Joins: dmi3y (dmi3y@9FD26F63.6075981B.B8FD5DE3.IP)
[07:38:54] * ChrisMorgan is getting around it with RUST_LOG=::rt::backtrace,rustc=4,rustc::middle::trans::base=3
[07:39:02] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Connection reset by peer)
[07:39:19] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[07:40:15] <klutzy> ChrisMorgan: I actually reported 0-byte code case
[07:40:18] <klutzy> :P
[07:40:26] <ChrisMorgan> So now all it is is that any cross-crate stuff is agonisingly slow.
[07:40:54] *** Joins: vk (chatzilla@moz-389FEE13.hsd1.ca.comcast.net)
[07:41:21] <klutzy> maybe some debug! messages have incorrect or infinite-loop routine..
[07:41:40] *** Joins: true_droid (true_droid@moz-123FD9B8.beck.volia.net)
[07:42:15] <ChrisMorgan> And to get around that, I add to my RUST_LOG incantation rustc::metadata=3
[07:42:37] *** Quits: diegoyam_ (quassel@FF9B1514.A4EC3D18.3A1EC144.IP) (Ping timeout)
[07:42:58] <ChrisMorgan> (The "Looking up {crate: ...}" and "lookup up {crate: ...}" messages come from rustc::metadata::{csearch, decoder}.)
[07:43:22] <ChrisMorgan> And so now at last I can get in a reasonable amount of time a potentially useful debug log.
[07:46:02] *** Quits: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP) (Client exited)
[07:47:21] *** Joins: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP)
[07:48:35] *** Quits: jensnockert (jensnocker@moz-5386F410.mobileonline.telia.com) (Ping timeout)
[07:50:38] *** Quits: santiago (santiago@moz-8ADE82B4.socal.res.rr.com) (Ping timeout)
[07:51:10] *** Joins: mrordinaire (Mibbit@1A659656.A607747.FD383126.IP)
[07:51:26] *** Joins: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl)
[07:53:01] *** Quits: mrordinaire (Mibbit@1A659656.A607747.FD383126.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[07:56:15] *** Joins: jensnockert (jensnocker@moz-A5E5C224.mobileonline.telia.com)
[07:57:45] *** Quits: eatkinson (eatkinson@moz-5CF47426.dia.static.qwest.net) (Quit: eatkinson)
[07:59:35] <ChrisMorgan> Got something that _might_ be valuable... the line before the crash is a `rust: ~"Call(llfn=..., args=...)"` line; a manual `x.add_assign(&y)` has args=~[~"*{i64}", ~"*{i64, *tydesc, *i8, *i8, i8}", ~"*{i64}"], while mine has an extra arg at the start, ~"*{i64}".
[08:00:21] <ChrisMorgan> (Sorry, the known-good one _lacks_ the ~"*{i64}", while my translated += inserts it.)
[08:01:20] *** Quits: jensnockert (jensnocker@moz-A5E5C224.mobileonline.telia.com) (Ping timeout)
[08:05:16] *** Joins: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net)
[08:06:39] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[08:06:56] *** Quits: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net) (Ping timeout)
[08:08:19] *** Quits: lucian (lucian@moz-22A14C6A.cable.virginmedia.com) (Ping timeout)
[08:10:59] * ChrisMorgan wishes it were as easy as defining a syntax rule ($lhs:expr += $rhs:expr;) => ((&mut $lhs).add_assign($rhs);)
[08:11:47] <bjz> should the root module of a library be called mod.rs or lib.rs?
[08:13:27] <ChrisMorgan> Or [cratename].rs? (As is done in the rust repository.)
[08:14:04] *** Quits: dim-an (ermolovd@moz-FE167E47.nationalcablenetworks.ru) (Ping timeout)
[08:14:22] <vk> I'm tempted to say lib.rs based off of http://static.rust-lang.org/doc/rustpkg.html, but I don't actually know.
[08:19:02] *** Joins: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP)
[08:21:34] *** Joins: Ms2ger (Ms2ger@EDC982F3.6890FC55.187A1082.IP)
[08:23:59] *** Joins: mark_edward (quassel@981AA104.E81F12CD.76F66111.IP)
[08:24:48] *** Joins: santiago (santiago@moz-8ADE82B4.socal.res.rr.com)
[08:29:23] *** Joins: dim-an (ermolovd@moz-A1FD62E4.yandex.net)
[08:29:27] *** Joins: thesnowdog (doug@94FEF15E.9D0B7490.6F17036B.IP)
[08:30:12] *** Joins: CarpNet (ac@moz-FD24B77.sohonet.co.uk)
[08:31:44] <bjz> ChrisMorgan: I'm doing [cratename].rs, but I thought I read that mod.rs had been 'blessed'. I think it was cmr on TWiR
[08:31:59] <mark_edward> hey if i call call transmute to get a &[u8] to an &[u64] is the length still the number of bytes instead of the number of 64bit words?
[08:38:21] *** Quits: vk (chatzilla@moz-389FEE13.hsd1.ca.comcast.net) (Quit: ChatZilla 0.9.90.1 [Firefox 23.0/20130729175331])
[08:38:22] *** Quits: busylizzy (lisa@85228838.12D0DC84.211374C4.IP) (Ping timeout)
[08:38:43] *** Joins: busylizzy (lisa@85228838.12D0DC84.211374C4.IP)
[08:38:57] <mark_edward> has the RUST_LOG log spec changed?
[08:39:19] *** Joins: azita (Azita@C828EC68.8E67A50A.508D426F.IP)
[08:39:28] *** Joins: jensnockert (jensnocker@moz-32C5EE18.mobileonline.telia.com)
[08:40:14] <Eridius> bjz: [name]/mod.rs has been blessed as an alternative to [name].rs
[08:40:25] <Eridius> bjz: I don't know if that means anything regarding the name for the root module file
[08:40:52] <Eridius> mark_edward: the length in what sense? .len() returns the number of elements
[08:41:20] <mark_edward> Eridius: right, is the number of elements properly changed?
[08:41:35] <Eridius> mark_edward: I believe the in-memory representation uses bytes, so it should work
[08:42:21] <Eridius> rusti: unsafe { std::cast::transmute::<~[u8],~[u64]>(~[1,2,3,4]).len() }
[08:42:21] -rusti- 0
[08:42:56] <Eridius> rusti: unsafe { std::cast::transmute::<~[u8],~[u64]>(~[1,2,3,4,5,6,7,8]).len() }
[08:42:56] -rusti- 1
[08:43:14] <Eridius> rusti: unsafe { std::cast::transmute::<~[u8],~[u32]>(~[1,2,3,4,5,6,7,8]).len() }
[08:43:14] -rusti- 2
[08:43:15] <mark_edward> that's cool
[08:43:39] *** Quits: dmi3y (dmi3y@9FD26F63.6075981B.B8FD5DE3.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[08:43:45] <mark_edward> do you know anything about the RUST_LOG spec changing? i have some log statements ive been using for a while stop working
[08:44:20] <Eridius> mark_edward: are they debug!()?
[08:44:34] <mark_edward> yeah
[08:44:36] <Eridius> debug! no longer emits anything by default
[08:44:55] <Eridius> I know when compiling rust itself you give --enable-debug to ./configure. Not sure if that flag works when given to rustc on your own projects
[08:44:56] *** Quits: KindOne (KindOne@moz-B6AF9A13.dynamic.ip.windstream.net) (Ping timeout)
[08:44:58] <Eridius> or if you use --cfg debug
[08:45:00] <Eridius> or what
[08:45:02] <mark_edward>       okay
[08:45:12] <mark_edward> i may have forgotten --cfg debug
[08:45:58] <klutzy> rusti: let (a, b) = unsafe { std::cast::transmute::<&[u32], (*u8, uint)>([1u32,2u32,3u32,4u32]) }; b
[08:45:59] -rusti- <anon>:5:14: 5:15 warning: unused variable: `a` [-W unused-variable (default)]
[08:45:59] -rusti- <anon>:5          let (a, b) = unsafe { std::cast::transmute::<&[u32], (*u8, uint)>([1u32,2u32,3u32,4u32]) }; b
[08:45:59] -rusti-                        ^
[08:45:59] -rusti- 16
[08:46:55] *** Joins: mib_sfs (Mibbit@moz-2B18508A.kla-tencor.com)
[08:47:01] <sebcrozet> Hi. Does inlining work for generics?
[08:47:16] *** Quits: rlin-nb (rlin@moz-99690620.hinet-ip.hinet.net) (Quit: Leaving.)
[08:47:57] <Seldaek> who's "in charge" for rustpkg and https://github.com/mozilla/rust/blob/master/doc/rustpkg.md ?
[08:48:44] *** Joins: KindOne (KindOne@moz-B909808.dynamic.ip.windstream.net)
[08:50:37] *** Quits: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl) (Ping timeout)
[08:53:49] *** Joins: dmi3y (dmi3y@9FD26F63.6075981B.B8FD5DE3.IP)
[08:53:52] *** Joins: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[08:54:19] *** Joins: orshem (orshem@C5E06B1E.A5B6B765.E3D28531.IP)
[08:54:19] *** Quits: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP) (Connection reset by peer)
[08:54:22] *** Quits: azita (Azita@C828EC68.8E67A50A.508D426F.IP) (Quit: azita)
[08:54:38] *** Joins: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[08:54:47] *** Joins: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk)
[08:57:13] *** Quits: dwhyte (dwhyte@1922756A.EDC594B0.7BF4A4B0.IP) (Connection reset by peer)
[08:58:26] *** Joins: dwhyte (dwhyte@1922756A.EDC594B0.7BF4A4B0.IP)
[09:01:08] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[09:01:52] *** Joins: mrordinaire (Mibbit@1A659656.A607747.FD383126.IP)
[09:03:38] <mrordinaire> hi, I'm working with the AST generated by librustc. It seems that declarations such as `use ...` or `extern mod ...` is not included in the AST. Could anyone tell me where to find them?
[09:05:36] *** Joins: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net)
[09:06:13] <Seldaek> mrordinaire: I'm really not sure whether it's called like that in the AST, but look for view_items or something along those lines, might help
[09:06:50] *** Quits: dwhyte (dwhyte@1922756A.EDC594B0.7BF4A4B0.IP) (Quit: Leaving.)
[09:07:37] *** Joins: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com)
[09:08:00] *** Joins: dwhyte (dwhyte@1922756A.EDC594B0.7BF4A4B0.IP)
[09:09:30] <mrordinaire> Seldaek: cool! thanks!
[09:11:01] <bjz> rusti: unsafe { std::cast::transmute::<~[u8],~[u16]>(~[1,2,3,4,5,6,7,8]) }
[09:11:01] -rusti- ~[513, 1027, 1541, 2055]
[09:11:14] <bjz> :)
[09:12:03] <bjz> Seldaek: I think tjc was doing quite a bit of work on it recently
[09:12:07] <Seldaek> ok
[09:12:31] <Seldaek> I'm reviewing the wiki and I have complaints ;)
[09:12:35] <bjz> hehe
[09:12:45] <bjz> yeah, I'm sure he'd like to hear them
[09:13:19] <bjz> Seldaek: I'm pretty sure the wiki might have slid out of date though
[09:13:32] <bjz> updates would be welcome I'm sure
[09:13:53] <bjz> but it might not be worth it if things are in flux
[09:14:00] <Seldaek> well i'm talking of https://github.com/mozilla/rust/blob/master/doc/rustpkg.md which isn't in the wiki actually, and the document state it is the truth of all things rustpkg :)
[09:14:02] <bjz> you'd have to talk to tjc
[09:14:10] <Seldaek> yeah will do, thnaks
[09:14:18] <bjz> cool :)
[09:14:20] *** Quits: mcclurmc (mcclurmc@moz-8D61EFD1.cable.virginmedia.com) (Ping timeout)
[09:15:01] <bjz> Seldaek: I believe z0w0 was the original author of rustpckg, but he might not be working on it any more
[09:16:08] <z0w0> i haven't touched it for months, very out of date with rust stuff :(
[09:16:13] <bjz> :P
[09:16:16] <Seldaek> heh ok
[09:16:26] <bjz> z0w0: different languages?
[09:16:28] <Seldaek> tjc is catamorphism on github yes?
[09:16:32] <bjz> aye
[09:16:38] <Seldaek> k I'll shoot him an email then
[09:16:42] <z0w0> bjz: been working on haskell stuff atm
[09:16:51] <bjz> z0w0: nice!
[09:16:59] <bjz> z0w0: at least it's not php :)
[09:17:25] <bjz> or VB
[09:17:29] <bjz> or java :)
[09:17:29] <z0w0> my haskell game engine got a fair few stars so i've been focusing on getting it stable and i started working, so had little time for rust :/
[09:17:33] *** Quits: jensnockert (jensnocker@moz-32C5EE18.mobileonline.telia.com) (Input/output error)
[09:17:47] <bjz> heh, sounds like fun
[09:18:00] <z0w0> bjz: i have been using java for work.. unfortunately, lol
[09:18:10] <bjz> did you see carmack mention it in his quake con speech?
[09:18:43] <z0w0> saw the buzz about it, haven't had time to watch/listen to it though
[09:19:06] * bjz is super interested in what carmack would think of Rust
[09:20:13] <z0w0> i remember there being rumours about some gamedev company trialing with rust... but i'm not up to date with gossip
[09:20:20] <z0w0> it was in this channel i think
[09:20:59] <bjz> it's a little early to even be 'trailing' it :(
[09:21:06] <bjz> *trialing
[09:21:11] <Seldaek> there are a few people owrking on game stuff I think, but not sure if it's professionally, given the rate of change still it's a bit nuts
[09:21:13] <z0w0> and seeing how p.language agnostic carmack is, i wouldn't be surprised
[09:22:07] <bjz> z0w0: I hope he can help bring other languages into the discourse
[09:22:18] *** Quits: santiago (santiago@moz-8ADE82B4.socal.res.rr.com) (Ping timeout)
[09:22:26] <z0w0> i think rust has been heading in the same direction since at least 0.3-0.4ish, sure there'd be heaps of breaking changes as versions are released but there's no reason you wouldn't be able to try out the merits of it for gamedev
[09:22:39] <bjz> z0w0: yep
[09:24:23] *** Quits: dwhyte (dwhyte@1922756A.EDC594B0.7BF4A4B0.IP) (Quit: Leaving.)
[09:24:32] *** Joins: jensnockert (jensnocker@moz-A5E5C224.mobileonline.telia.com)
[09:24:52] *** Joins: dwhyte (dwhyte@1922756A.EDC594B0.7BF4A4B0.IP)
[09:25:54] <z0w0> bjz: anyway, been meaning to cleanup my old mvc framework for rust and actually make it work (w/ the new runtime)
[09:26:00] <z0w0> it's on my list :v
[09:26:01] <bjz> rusti: fn f() -> Option<&int> { Some(&3) } f().unwrap()
[09:26:02] -rusti- pastebinned 11 lines of output: http://sprunge.us/UAeV
[09:26:07] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[09:26:07] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14a185581 to 14f8cf234: 02http://git.io/N3iJvQ
[09:26:07] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[09:26:11] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[09:26:11] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/26I59g
[09:26:11] <ghrust> 13rust/06auto 14a76943b 15Sangeun Kim: Move EnumSet into libextra
[09:26:11] <ghrust> 13rust/06auto 148adcba4 15bors: auto merge of #8054 : sammykim/rust/move-EnumSet, r=alexcrichton...
[09:26:11] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[09:26:55] <bjz> rusti: fn f<'a>() -> Option<&'a int> { Some(&'a 3) } f().unwrap()
[09:26:56] -rusti- pastebinned 11 lines of output: http://sprunge.us/JhOK
[09:27:15] <bjz> rusti: fn f() -> Option<~int> { Some(~3) } f().unwrap()
[09:27:15] -rusti- ~3
[09:28:02] <bjz> z0w0: so that would mean better windows support?
[09:29:26] <z0w0> for the web framework? probably, considering the other one depended on mongrel2
[09:29:57] <bjz> ooh wait
[09:30:10] <bjz> woops - wires crossed
[09:30:39] <bjz> for some reason I read mvc as msvs
[09:31:04] <z0w0> ah
[09:32:21] <Seldaek> z0w0: web framework sounds interesting.
[09:35:26] <dbaupp> acrichto: ping
[09:37:34] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[09:37:53] *** Joins: santiago (santiago@moz-8ADE82B4.socal.res.rr.com)
[09:39:39] *** Quits: jensnockert (jensnocker@moz-A5E5C224.mobileonline.telia.com) (Ping timeout)
[09:40:37] *** Quits: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net) (Ping timeout)
[09:41:39] *** Joins: maikklein2 (maik@moz-18E00DC1.dip0.t-ipconnect.de)
[09:44:50] *** Joins: jensnockert (jensnocker@moz-A5E5C224.mobileonline.telia.com)
[09:50:43] *** Quits: jensnockert (jensnocker@moz-A5E5C224.mobileonline.telia.com) (Ping timeout)
[09:51:58] *** Joins: jensnockert (jensnocker@moz-3D772E8D.mobileonline.telia.com)
[09:57:47] *** Quits: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP) (Quit: Konversation terminated!)
[09:57:57] *** Quits: jensnockert (jensnocker@moz-3D772E8D.mobileonline.telia.com) (Input/output error)
[09:58:19] *** Joins: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP)
[09:58:37] *** Quits: mark_edward (quassel@981AA104.E81F12CD.76F66111.IP) (Ping timeout)
[10:03:08] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[10:06:12] *** Joins: mark_edward (quassel@981AA104.E81F12CD.76F66111.IP)
[10:06:27] <mark_edward> doomlord: ping
[10:06:33] <doomlord> hi
[10:08:22] <mark_edward> doomlord: i'm looking for help. and im not sure if it's fair to ask someone to get so involved in my project, but i've been stuck for weeks now
[10:08:28] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[10:09:07] <doomlord> what type of project .. 
[10:09:36] *** Quits: maikklein2 (maik@moz-18E00DC1.dip0.t-ipconnect.de) (Ping timeout)
[10:09:47] *** Joins: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net)
[10:09:56] <mark_edward> doomlord: it should be fairly simple. I'm trying to implement Keccak (winning cnadidate for SHA-3) in pure Rust, going off of the reference C code
[10:10:07] <mark_edward> key word, should have been simple
[10:11:23] <doomlord> hehe someone suggested writing a clang based C to unsafe-Rust  converter :)
[10:11:44] <mark_edward> thatd' be nice, lol
[10:12:05] <doomlord> although macros would surely break it :)
[10:12:13] <mark_edward> yeah :(
[10:12:32] <doomlord> (is the reference code macro-heavy?)
[10:13:11] <mark_edward> not too much. mostly used for constants. there's an index rol64 macro, but they were easily translated into rust macros
[10:13:21] <mark_edward> *index AND rol64
[10:13:31] <dbaupp> mark_edward: link to the code?
[10:13:48] * dbaupp has recently converted a pile of C random number generators to Rust
[10:13:53] <dbaupp> mark_edward: (the C code)
[10:13:54] <mark_edward> https://github.com/MarkJr94/rust-keccak
[10:14:09] *** Quits: fredy (fredy@moz-E7647C0E.vm.okeanos.grnet.gr) (Ping timeout)
[10:14:09] <mark_edward> the C code can only be found in a zip file, and there's a ton of files
[10:15:47] <mark_edward> nvm, found a git hub repo https://github.com/gvanas/KeccakCodePackage/tree/master/KeccakF-1600/Reference
[10:16:58] *** Joins: fredy (fredy@moz-E7647C0E.vm.okeanos.grnet.gr)
[10:17:12] <mark_edward> the relevant files are keccaksponge.h/c keccakf1600reference.c/h keccakf1600interface.c and 
[10:17:55] <mark_edward> well the zip file contains keccakNISTinterffsce.h/c
[10:18:16] <dbaupp> well, you should be able to essentially transliterate the code statement by statement
[10:18:20] <dbaupp> (in theory)
[10:18:28] <mark_edward> that's essentially what i've done
[10:18:47] <dbaupp> and so, what's the problem?
[10:19:00] <mark_edward> and im sure i have the block permutation part right, i've checked using a file that contains the intermediate values after each round
[10:19:14] <mark_edward> but i don't get the same output when i try and hash, say a string
[10:19:43] <dbaupp> ah...
[10:19:56] <dbaupp> does the hash include the null terminator in the C code?
[10:20:01] <dbaupp> (and not in the Rust)
[10:20:07] <dbaupp> (or vice versa?)
[10:20:09] *** Quits: dwhyte (dwhyte@1922756A.EDC594B0.7BF4A4B0.IP) (Client exited)
[10:20:51] *** Joins: lerc (quassel@B2E8CAD3.A8D14E52.788638A4.IP)
[10:21:10] <mark_edward> the tests in fails https://github.com/MarkJr94/rust-keccak/blob/bughunt/nist.rs#L77-L138
[10:22:32] <dbaupp> is that the smallest testcase that fails?
[10:22:33] *** Joins: Earnestly (earnest@CAE8D902.48DC5685.39C00A7A.IP)
[10:22:47] <mark_edward> dbaupp: i don't think so. here is the relevant test in C: https://gist.github.com/MarkJr94/6163389
[10:23:01] <mark_edward> dbaupp: i don't know how to make a smaller one in this case
[10:23:05] <dbaupp> (also, s/PosixPath/Path/)
[10:23:52] <dbaupp> I guess comparing kc.hash("foo") and the C equivalent would be a start... does that pass?
[10:25:38] *** Quits: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net) (Ping timeout)
[10:25:55] <dbaupp> (alsoalso, I believe iterators have an .nth(n) method, so you don't need .collect()[n])
[10:26:07] <mark_edward> not at all. i know the block function is working right, so the error must be somewhere in the ssqueezing/absorbing process, but i've gone over and over the code, and it seems i've exactly translated it
[10:26:20] <mrordinaire> rusti: mod Inside { struct A{i int}}
[10:26:20] -rusti- <anon>:5:33: 5:36 error: expected `:` but found `int`
[10:26:20] -rusti- <anon>:5          mod Inside { struct A{i int}}
[10:26:20] -rusti-                                           ^~~
[10:26:20] -rusti- application terminated with error code 101
[10:26:27] <doomlord> brb
[10:26:27] <mrordinaire> rusti: mod Inside { struct A{i: int}}
[10:26:28] -rusti- ()
[10:26:38] <mrordinaire> rusti: mod Inside { struct A{i: int}} Inside::A{}
[10:26:39] -rusti- <anon>:5:49: 5:50 error: expected `;` or `}` after expression but found `{`
[10:26:39] -rusti- <anon>:5          mod Inside { struct A{i: int}} Inside::A{}
[10:26:39] -rusti-                                                           ^
[10:26:39] -rusti- application terminated with error code 101
[10:26:46] <mrordinaire> rusti: mod Inside { struct A{i: int}} A{}
[10:26:46] -rusti- <anon>:5:41: 5:42 error: expected `;` or `}` after expression but found `{`
[10:26:46] -rusti- <anon>:5          mod Inside { struct A{i: int}} A{}
[10:26:47] -rusti-                                                   ^
[10:26:47] -rusti- application terminated with error code 101
[10:27:05] <dbaupp> rusti: mod Inside { struct A{i: int}} A{ i: 1}
[10:27:05] -rusti- <anon>:5:40: 5:41 error: `A` does not name a structure
[10:27:06] -rusti- <anon>:5          mod Inside { struct A{i: int}} A{ i: 1}
[10:27:06] -rusti-                                                  ^
[10:27:06] -rusti- error: aborting due to previous error
[10:27:06] -rusti- application terminated with error code 101
[10:27:14] <dbaupp> rusti: mod Inside { struct A{i: int}} Inside::A{ i: 1}
[10:27:15] -rusti- <anon>:5:40: 5:49 error: `Inside::A` does not name a structure
[10:27:15] -rusti- <anon>:5          mod Inside { struct A{i: int}} Inside::A{ i: 1}
[10:27:15] -rusti-                                                  ^~~~~~~~~
[10:27:15] -rusti- error: aborting due to previous error
[10:27:15] -rusti- application terminated with error code 101
[10:27:23] <dbaupp> rusti: mod Inside { pub struct A{i: int}} Inside::A{ i: 1}
[10:27:24] -rusti- {i: 1}
[10:28:00] <mrordinaire> dbaupp: wow, I've been missing that
[10:28:01] <dbaupp> mark_edward: can you print more intermediate results? to narrow down exactly where it is?
[10:28:04] <mrordinaire> dbaupp: thanks a bunch
[10:28:12] *** Quits: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com) (Ping timeout)
[10:28:44] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[10:28:52] <mark_edward> dbaupp: i print a ton, i print each block that''s being absorbed, and i print after each phase of each round of the permutation
[10:28:59] *** Joins: ILHSWC (Mibbit@F03BEF9E.297EA72C.17406662.IP)
[10:29:11] <mark_edward> i also print what's going to be squeezed
[10:29:12] *** Parts: ILHSWC (Mibbit@F03BEF9E.297EA72C.17406662.IP) ()
[10:29:22] <dbaupp> mark_edward: and... so you know which line/function call it's breaking on?
[10:29:30] <dbaupp> (if you don't... then you're not printing enough :P )
[10:30:45] *** Quits: noam (noam@F6B530A7.720527A7.416762B.IP) (Connection reset by peer)
[10:31:06] <dbaupp> (for ease of comparison, just printing e.g. the sum of the spongestate buffers is probably enough.)
[10:31:21] *** Joins: noam (noam@F6B530A7.720527A7.416762B.IP)
[10:31:26] <mark_edward> dbaupp: the problem is that the first place i see a difference from expected output is nonsensical
[10:31:33] <dbaupp> mark_edward: where?
[10:31:42] *** Joins: WABPBC (Mibbit@F03BEF9E.297EA72C.17406662.IP)
[10:31:43] *** Joins: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se)
[10:31:55] <mark_edward> after the last phase of the last round, i have the right state
[10:32:13] <dbaupp> link to code line?
[10:32:18] <mark_edward> i have a file that has all the intermediate states with a given input of 400 bytes that are zeroed
[10:32:38] <WABPBC> Is the documentation included with the compiler source licensed under the same license as the compiler?
[10:32:58] <dbaupp> WABPBC: I think so
[10:33:02] <mark_edward> dbaupp: here https://github.com/MarkJr94/rust-keccak/blob/bughunt/reference.rs#L148-L151 the output of that call to dump() is correct
[10:33:23] *** Quits: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se) (Ping timeout)
[10:33:25] <mark_edward> dbaupp: but here it's wwrong https://github.com/MarkJr94/rust-keccak/blob/bughunt/reference.rs#L171
[10:33:30] <mark_edward> doesn't make anysense
[10:34:21] <dbaupp> yes, that doesn't make sense
[10:34:27] *** Joins: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se)
[10:34:32] <dbaupp> hm... are you missing a pass, or something?
[10:34:50] *** Quits: WABPBC (Mibbit@F03BEF9E.297EA72C.17406662.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[10:34:57] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Client exited)
[10:35:08] <dbaupp> or doing a different number of ROUND_N's?
[10:35:21] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[10:37:00] *** Joins: dylukes (dylukes@moz-B100DB2B.home.otenet.gr)
[10:37:01] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Ping timeout)
[10:37:07] <mark_edward> nope. i can put the reference code in a gist if you want to see. and my ROUND_N is correct (24)
[10:37:13] <mark_edward> dbaupp: here is the reference: https://gist.github.com/MarkJr94/6163464
[10:37:31] <dylukes> heyo guys
[10:37:39] <mark_edward> heyo
[10:37:44] <dylukes> So, can someone explain the rationale for the switch in for syntax?
[10:37:52] <dylukes> Is the old for (do-esque) syntax still there
[10:37:54] <dylukes> ?
[10:38:34] <mark_edward> i dont think so
[10:39:24] <dylukes> Well, the docs are a little incomplete then. The syntax block still shows the old syntax...
[10:39:35] <dbaupp> dylukes: one reason the syntax was change is because it is no longer a closure, so `for x |y| { ... }` is "lying"
[10:39:38] <dbaupp> *changed
[10:39:45] <dylukes> Ah okay. So it's iterator based now?
[10:39:49] <dbaupp> mark_edward: that's very strange
[10:39:54] <dbaupp> dylukes: yup
[10:40:10] <dylukes> mmk. and ruby-esque trailing closure is also gone?
[10:40:19] <dbaupp> `for <pattern> in <iterator> { <code> }`
[10:40:27] <dbaupp> dylukes: no, `do` is still around
[10:40:33] <dylukes> Er I meant for like
[10:40:44] <dylukes> `range(0, 10) |x| { <code> }`
[10:41:01] <dylukes> Is it `do range(0,10) |x| { <code> }` now?
[10:41:02] <dbaupp> yeah, `do range(0, 10) |x| { <code>; true }`
[10:41:16] <dylukes> the true has to be explicit, hm. 
[10:41:16] <dbaupp> although, that's not true: range is now an iterator.
[10:41:22] <dylukes> Ah okay.
[10:41:39] <dylukes> So, another question. For vectors is there a standard fold method/function?
[10:41:41] <dbaupp> almost everything that used to use `for` has been converted to the new syntax
[10:41:50] <dbaupp> v.iter().fold(init, f)
[10:41:58] <dylukes> ah, it's on iterators now.
[10:42:08] <dbaupp> (or, `do v.iter().fold(init) |..| { ... }`)
[10:42:11] <dylukes> so if I wanted to say, produce a list of multiples of 10... 
[10:42:25] <dylukes> let mults = range(0, 10).fold(... what?
[10:42:30] <dylukes> sum of muiltiples*
[10:42:50] *** Joins: thomaslee_ (thomaslee@moz-306D3DF4.hsd1.or.comcast.net)
[10:42:52] *** Quits: thomaslee (thomaslee@moz-306D3DF4.hsd1.or.comcast.net) (Connection reset by peer)
[10:42:53] <mark_edward> dbaupp: do you see anything here that would substantillly change the appearance of the ference output compared to mine? https://gist.github.com/MarkJr94/6163464#file-reference-c-L29-L43
[10:42:59] <dbaupp> rusti: range(0, 10).transform(|x| 10*x).fold(0, |sum, new| sum + new)
[10:43:00] -rusti- 450
[10:43:03] <dbaupp> dylukes: ^
[10:43:28] <dylukes> ah neat. excellent :).
[10:43:34] <dylukes> Another small question then...
[10:43:44] <dylukes> I was looking at chan/ports (a very nice abstraction)... 
[10:43:49] *** Quits: thomaslee_ (thomaslee@moz-306D3DF4.hsd1.or.comcast.net) (Client exited)
[10:43:54] <dylukes> how can one wrap the output of a port as an "iterator" :)?
[10:44:03] <dbaupp> not yet
[10:44:06] <dylukes> Perhaps a port of futures.
[10:44:18] <dylukes> which would require a little glue but...
[10:44:22] <dbaupp> (as in, it's not yet implemented.)
[10:44:32] <dylukes> So they will actually be usable as streams?
[10:45:07] <dbaupp> you could write something like `struct PortIterator<T>(Port<T>); impl Iterator for PortIterator { fn next(&mut self) -> Option<T> { (**self).try_recv() } }`
[10:45:15] <dbaupp> which would be a blocking iterator
[10:45:33] <dbaupp> mark_edward: no; especially if it's matching on other output
[10:46:06] <dylukes> hm
[10:46:28] <dylukes> Automatic dereferencing still bothers me some how.
[10:46:42] <dbaupp> mark_edward: how is diplayBytes called?
[10:46:46] <dylukes> At least in that case it's not clear to me why two levels of indirection are implicitly present.
[10:46:57] <dylukes> One from it being borrowed in the scope of next, and one... why?
[10:47:10] <dbaupp> &mut self : &mut PortIterator (one layer)
[10:47:31] <dylukes> "(**self).try_recv()"
[10:47:35] <dbaupp> and you can deref newtype structs (structs with a single anonymous field) to "extract" their value
[10:47:40] <dbaupp> (the other layer)
[10:47:59] <dylukes> what, no newtype { deStruct :: ... } ;p
[10:48:01] <dylukes> (jk)
[10:48:17] <dbaupp> i.e. the two derefences are to get at the Port<T> inside the &mut PortIterator
[10:48:19] <dylukes> So then, struct is kind of like newtype, type is like type?
[10:48:41] <dbaupp> struct name(x) == newtype name = name x
[10:48:48] <dbaupp> and yeah, type's like type
[10:48:57] <dbaupp> (assuming you're talking about haskell.)
[10:48:59] <dylukes> I am
[10:49:03] <dylukes> C + Haskell + Ruby with a dash of Scala and Go 
[10:49:06] <dylukes> is what I'm seeing in 0.7/0.8 
[10:49:15] <dylukes> The Ruby influence is rapidly decaying.
[10:49:23] <dbaupp> apparently there's dashes of OCaml too
[10:49:32] * dbaupp doesn't know enough OCaml to recognise them if they are there
[10:49:36] <dylukes> I've only noticed that in naming.
[10:49:38] <dylukes> Option for instance.
[10:49:49] <dylukes> match statements rather than case statements.
[10:50:02] <mark_edward> good in my eyes. Ruby is an infernal language. i couldnt get a grip on it. so many different ways to do one thing
[10:50:30] <mark_edward> begin and end vs good old fashioned braces! my keyboard can only take so much typing
[10:51:04] <dylukes> haha
[10:51:11] <dylukes> did you ever do the metakoan?
[10:51:17] <mark_edward> nope
[10:51:22] <dylukes> that's about where most people are like: "what the bloody hell"
[10:51:34] <dylukes> It's essentially implementing attr_accessor within the language.
[10:51:43] <dylukes> And then extending it up from Object to Class to Module
[10:51:57] <mark_edward> :-( that makes me sad
[10:52:09] <dylukes> Ruby lets you template here docs, mix them into the eigenclass of Module (which is parent to Class) and do all sorts of shenanigans.
[10:52:22] <dylukes> Suddenly: "why are my vtables so slooow???"
[10:52:42] <dylukes> eh dbaupp 
[10:52:48] <dylukes> that impl statement doesn't introduce T.
[10:53:01] <dbaupp> er, yeah. sorry:
[10:53:19] <dbaupp> impl<T> Iterator<T> for PortIterator<T> { fn next(&mut self) -> Option<T> { (**self).try_recv() } }
[10:53:37] <bjz> dbaupp: a decent amount of ML
[10:53:39] <dylukes> so free variables in impl's have to go on the impl keyword
[10:53:42] <dylukes> like mut
[10:53:50] <dylukes> type parameterized keywords, go
[10:53:53] <bjz> dbaupp: pattern matching
[10:53:54] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[10:54:07] <bjz> dbaupp: algebraic datatypes
[10:54:28] <bjz> dbaupp: was more so when we had records
[10:55:07] <dylukes> error: instantiating a type parameter with an incompatible type `T`, which does not fulfill `Send` on `(**self).try_recv()`
[10:55:11] <dbaupp> bjz: all Haskell too ;)
[10:55:14] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[10:55:15] <dylukes> Looks like it needs a constraint as well
[10:55:21] <dylukes> impl<T: Send> no?
[10:55:31] <dbaupp> dylukes: should work
[10:55:41] <dylukes> well it typechecks
[10:55:50] <dbaupp> dylukes: and, yeah, free variables need to be declared, as you say.
[10:56:09] <dbaupp> bjz: (well, except for the records.)
[10:56:09] <dylukes> Last time I played with rust was 0.5/6
[10:56:17] <dbaupp> *anonymous records
[10:56:17] <dylukes> looks like it's coming together a bit :)
[10:56:29] <dbaupp> yeah, it's stabilising/improving/actually nice :)
[10:56:32] *** Joins: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com)
[10:56:35] <bjz> dbaupp: well, ML precedes Haskell, so it would be more likely the influence comes more from there. And considering it was originally written in a ML-derived language...
[10:56:36] <dylukes> damn, I have 0.7 on here.
[10:56:58] <bjz> dbaupp: but it could be splitting hairs
[10:57:19] <dylukes> Haskell derives from Miranda which comes from ML, SASL by way of ISWIM, and KRC.
[10:57:30] <dylukes> And a dash of Hope which is evident syntacticlaly.
[10:57:41] <bjz> dbaupp: subjectively, it definitely feels more ml-ish than haskellish, besides the type classes
[10:57:46] <bjz> dylukes: aye
[10:57:53] <dylukes> KRC contributed the non-strict aspects, I believe.
[10:58:01] <dylukes> Hope the syntax (but not the non-strict/type inference)
[10:58:04] <dbaupp> bjz: maybe.. I've never used any ml much at all.
[10:58:20] <bjz> dbaupp: also, ML languages are eager, Haskell is lazy
[10:58:30] <dbaupp> bjz: minor difference :P
[10:58:37] <dylukes> I find it funny that ML and Haskell both derive from ISWIM
[10:58:39] <bjz> dbaupp: huge difference :P
[10:58:42] <dylukes> despite it never having been implemented...
[10:59:08] <dylukes> bjz: hey, the Haskell Report doesn't actually mandate non-strictness :)
[10:59:21] <bjz> dylukes: really?
[10:59:24] <dylukes> mmhm
[10:59:29] <dylukes> It's an implementation detail.
[10:59:48] <dylukes> Denotationally the strictness is not specified nor is it relevant. 
[11:00:02] <mark_edward> doesnt lazyness increase space requirements?
[11:00:05] <dylukes> forcing thunks, strictness annotations ($) and such are extensions to the language.
[11:00:15] <dylukes> The Haskell Report is only concerned with denotational semantics.
[11:00:27] <dbaupp> mark_edward: not really
[11:00:43] <mark_edward> i thought space leaks were  abig problem in haskell
[11:00:45] <dbaupp> mark_edward: (as in, laziness doesn't directly imply more space.)
[11:00:46] <dylukes> Ah, looks like the 2010 report does mention it.
[11:01:02] <dylukes> Section 6.2. That's new.
[11:01:13] <mark_edward> dbaupp: practically though?
[11:01:22] <dbaupp> mark_edward: it's just the implementations which build up thunks and so on.
[11:01:38] <dylukes> Even so, $ can just be a noop in strict versions of Haskell.
[11:01:50] <mark_edward> dbaupp: how else can it be done?
[11:01:54] <dylukes> I mean, it *technically* is. GHC just gives it special side effects.
[11:01:59] <dbaupp> mark_edward: dunno
[11:02:17] <dylukes> Actually, $ kind of breaks the niceness of haskell largely. It has side effects which escape IO.
[11:02:25] <dylukes> but it's a necessary evil.
[11:02:26] <dbaupp> mark_edward: in any case, the space leaks are from "poorly" written code.
[11:02:34] <dbaupp> dylukes: $ has side effects??
[11:02:39] <dylukes> Yes, forcing thunk evaluation :p.
[11:02:52] <dbaupp> isn't that `seq`?
[11:02:56] <dylukes> Same thing.
[11:02:57] <doomlord> laziness is a big part of what gives haskell its elegance ? (reducing programs to pure expressions with minimal managemnt)
[11:03:04] <mark_edward> dbaupp: what causes them?
[11:03:08] *** Quits: dmi3y (dmi3y@9FD26F63.6075981B.B8FD5DE3.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[11:03:39] <dbaupp> mark_edward: building up huge changes of unevaluated thunks (e.g. summing a list `(1 + (2 + (3 + (4+ (5 + ... ))))`)
[11:03:42] <dbaupp> *chains
[11:03:54] *** Joins: dmi3y (dmi3y@9FD26F63.6075981B.B8FD5DE3.IP)
[11:03:59] <dylukes> seq does force functions which $ does not though
[11:04:18] <dbaupp> dylukes: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Base.html#%24 ?
[11:04:31] <mark_edward> dbaupp: isn't that the natural way to do things in a functional language though? that's how we did in when i was taught scheme in school
[11:04:40] <dbaupp> dylukes: or is there some trickiness / RULES hidden somewhere?
[11:04:51] <dylukes> seq is just
[11:04:52] <dylukes> seq :: a -> b -> b
[11:04:52] <dylukes> seq _ y = y
[11:05:01] <dylukes> there is most certainly ghc black magic involved.
[11:06:19] *** Joins: Florob (florian@E4BCD297.B50A917B.CD80E335.IP)
[11:06:20] <dylukes> Ah wait no! My bad!
[11:06:25] <dylukes> ($) is normal. ($!) uses seq. ;p
[11:06:45] <dbaupp> mark_edward: right, but laziness means that you get a space leak doing it the naive way
[11:06:47] <dylukes> http://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1260006.2
[11:06:55] <dbaupp> mark_edward: (you need a strict fold to avoid it)
[11:07:08] *** Joins: rust-noob (Mibbit@moz-3112320B.graz.surfer.at)
[11:07:16] <dbaupp> dylukes: no wonder I was confused! :)
[11:07:20] <dylukes> My bad :)
[11:07:38] <mark_edward> what are the benefits of lazyness?
[11:07:53] <dylukes> representing streams as infinite lists, i.e.
[11:08:02] <dylukes> abandoning computation early
[11:08:03] <dbaupp> you can deal with infinite data structures at no cost
[11:08:06] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[11:08:06] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/26I59g
[11:08:06] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[11:08:14] <dbaupp> (e.g. game trees for a chess AI.)
[11:08:15] <doomlord> i think lazyness contributes to simplifying how much code you have to write
[11:08:17] <dylukes> essentially, you only compute what is strictly needed when it's non-strict.
[11:08:46] <doomlord> without laziness, programmers manually manage active sets/caching/buffering more ?
[11:08:56] <dylukes> Yeah, good example dbaupp. In *general* you can just "express" the problem.
[11:09:05] <dylukes> It removes you from the operational concerns.
[11:09:24] <dylukes> Of course the second you want performance, that's a moot point. But it's helpful for naive prototypes.
[11:09:25] <bjz> doomlord: that's what I would have thought
[11:09:35] <mark_edward> we can make an effectively infinite list in Rust using iterators. is there an iterator that lets you define the successive elemnt using a closure?
[11:09:38] <mark_edward> that would do it
[11:09:40] <bjz> doomlord: I haven't done enough haskell though
[11:10:02] <doomlord> i've only toyed with it a little
[11:10:03] <dylukes> mark_edward: Is there a iterator::from_fn?
[11:10:05] <dbaupp> mark_edward: std::iterator::Unfoldr
[11:10:06] <dylukes> i.e. a generator?
[11:10:19] * dbaupp took the name straight from Haskell
[11:10:28] <mark_edward> yeah i think
[11:10:29] *** Joins: maikklein2 (maik@moz-18E00DC1.dip0.t-ipconnect.de)
[11:10:31] <dbaupp> (I guess it should be renamed to just plain `Unfold`)
[11:11:01] <dylukes> yeah, haha, the left/right aspect isn't especially relevant.
[11:11:05] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[11:11:05] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/xpt--A
[11:11:05] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[11:11:05] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[11:11:06] <ghrust> 01[13rust01] 15bors pushed 6 new commits to 06auto: 02http://git.io/3Jky2A
[11:11:06] <ghrust> 13rust/06auto 14849e90a 15Steven Fackler: Added hexadecimal encoding module...
[11:11:06] <ghrust> 13rust/06auto 146f87a44 15Steven Fackler: Some minor hex changes
[11:11:06] <ghrust> 13rust/06auto 1475c4bfc 15Steven Fackler: ToBase64 and ToHex perf improvements...
[11:11:07] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[11:11:17] <dbaupp> yup, and especially as we only have one direction of fold on iterators
[11:11:23] <dylukes> unfoldl = (unfoldr (fmap swap . f) x)
[11:11:25] <dylukes> literally.
[11:11:45] <maikklein2> everyone is talking about functors in Rust, aren't colsures also functors?
[11:11:48] <dylukes> it's exactly the same as unfoldr except it prepends intstead of appends.
[11:11:58] *** Quits: thesnowdog (doug@94FEF15E.9D0B7490.6F17036B.IP) (Quit: WeeChat 0.4.1)
[11:12:02] <doomlord> hehe C++ functors or haskell functors ...
[11:12:04] *** Quits: rust-noob (Mibbit@moz-3112320B.graz.surfer.at) (Quit: http://www.mibbit.com ajax IRC Client)
[11:12:04] <dylukes> maikklein2: perhaps you're misunderstanding what functor means in Haskell.
[11:12:14] <dylukes> C++ functors have nothing to do with theoretical functors. 
[11:12:31] <dbaupp> maikklein2: they are functors in the haskell sense, but not in they way you are meaning :P
[11:12:31] <maikklein2> dylukes, oh okay that could be the reason :)
[11:13:08] <dylukes> a functor is a mapping, in this context, between a type and functions/methods over it.
[11:13:17] <dylukes> to another type and similar functions.
[11:13:47] <dylukes> saying "[T] is a functor" is erroneous. It's more like "it has arbitrary functors with respect to T"
[11:14:10] <dylukes> the morphism from [T1] to [T2] is given by map, for instance.
[11:14:29] <dylukes> map being a higher order function that essentially "promotes" a morphism from a single T1 to a T2 to a morphism from a [T1] to a [T2]
[11:14:56] <dylukes> given that "base function" you just have to have a "wrapper" that promotes it to the relevant functor, yes?
[11:14:58] <dylukes> that's fmap.
[11:15:12] *** Quits: Earnestly (earnest@CAE8D902.48DC5685.39C00A7A.IP) (Ping timeout)
[11:15:27] <dylukes> it has to handle the functor-izable types special traits. For Maybe/Option its handling nullability, for [...] it's handling non-determinism
[11:15:28] <maikklein2> ok so it's just a conversion from one type to another
[11:15:46] <dbaupp> not "just" that
[11:16:14] <dbaupp> it's promoting a function that acts on normal values, to one that acts on values that are inside a functor
[11:16:17] <dylukes> Okay wait
[11:16:20] <dylukes> Oh, the term functor has one confusing thing in Haskell
[11:16:22] <dbaupp> (i.e. fmap does that.)
[11:16:27] <dylukes> every functor in haskell is an ENDOfunctor from Hask to Hask
[11:16:39] <mark_edward> ..............
[11:16:42] <dylukes> where Hask is the made up name for the "category" of haskell objects.
[11:16:46] <dylukes> okay so let me simplify this
[11:16:47] <mark_edward> what?
[11:16:57] <dylukes> a functor, mathematically, is the following
[11:17:11] <dylukes> say you have two categories C and D. it suffices to know a category is a group of objects and morphsms/arrows/mappings between them.
[11:17:38] <dbaupp> so, really, a monad is just a monoid in the category of endofunctors.
[11:17:41] <dylukes> yes
[11:17:43] <ldunn> easy!
[11:17:44] <dylukes> a functor F is a mapping in the category *of categories*
[11:17:46] * dbaupp stops being annoying.
[11:17:55] <dylukes> the arrows in the category of categories are functors.
[11:18:01] <dylukes> So say you have C and D
[11:18:07] <dylukes> for every x in C, you have F(x) in D
[11:18:19] <dylukes> and for every f : X â†’ Y in C
[11:18:21] *** Joins: Earnestly (earnest@3F74F9E2.8E6FE497.30311652.IP)
[11:18:27] <dylukes> you have F(f) : F(X) â†’ F(Y) in D
[11:18:37] <dylukes> basically, a category is a collection of objects and morphism
[11:18:47] <dylukes> the category OF categories is the same, except the morphisms are special and called functors
[11:19:02] <dylukes> and they have to additionally map morphisms in categories to morphisms in other categories
[11:19:17] <dylukes> the usual thing that trips people up in the application to haskell is "well what are C and D?"
[11:19:27] <dylukes> they're BOTH the same category. The category of haskell values and functions.
[11:19:35] * Ms2ger blinks
[11:19:46] * mark_edward tripped a while ago
[11:19:49] <dylukes> When the source and destination of a functor are both the same category,
[11:19:53] <dylukes> it's called an endofunctor 
[11:19:57] <dylukes> a functor from something to itself.
[11:20:08] <dylukes> its a mapping of values and functions to other values and functions
[11:20:08] <bjz> cool
[11:20:16] <dylukes> anyways, there's a strong theoretical meaning
[11:20:20] <dylukes> C++ functors, who the fuck knows.
[11:20:26] <dbaupp> (fwiw, these concepts aren't particularly difficult... there's just a bit of jargon here and there. :) )
[11:20:32] <dylukes> Yeah :p.
[11:20:37] <dylukes> I'm a mathematics major.
[11:20:42] * dbaupp is too
[11:20:43] <mark_edward> i understood it at some point whne i was more into Rust
[11:20:44] <ldunn> so functions are the morphisms in Hask?
[11:20:48] <mark_edward> *haskell
[11:20:48] <maikklein2> hm yeah I think I just have to see some code
[11:20:54] <dylukes> yes
[11:20:55] <maikklein2> problem is haskell looks somewhat crazy :D
[11:21:03] <dylukes> (â†’) constructs morphisms :). 
[11:21:07] * bjz wonders if he should have chosen mathematics instead of CS
[11:21:08] <ldunn> mrm
[11:21:11] *** Joins: WABPBC (Mibbit@F03BEF9E.297EA72C.17406662.IP)
[11:21:20] <dbaupp> bjz: what a silly question! clearly, yes. :P
[11:21:22] <dylukes> So 3 :: Int is an object, (-) :: Int â†’ Int is a morphism.
[11:21:25] <dylukes> okay so you may ask
[11:21:28] <dylukes> well what about binary functions
[11:21:31] * ldunn waits for rust to compile again so that it won't bug him about duplicate language items :(
[11:21:35] <dylukes> That comes down to currying in Haskell.
[11:21:39] <mark_edward> haskell is too academic for me. how can joe blow programmer who is used to programming data entry in VB ever hope to get it's key concepts
[11:21:47] <dylukes> The nice category theoretical stuff is kind of ugly dealing with multi-parametered functions
[11:21:48] <mark_edward> it can't ever get that big
[11:22:02] <dylukes> thankfully f (x, y, z) is isomorphic to f (x) (y) (z)
[11:22:09] <bjz> dbaupp: CS, at least at RMIT, is just a glorified IT course
[11:22:18] <dbaupp> mark_edward: they're not hard to understand (once you get them).. they're pretty hard to explain :)
[11:22:29] <dbaupp> bjz: seems similar here (USyd)
[11:22:44] <maikklein2> rusti: Counter::new(0u, 1).take_(5)
[11:22:44] <dylukes> It's like the whole monad business.
[11:22:45] -rusti- pastebinned 11 lines of output: http://sprunge.us/iiJi
[11:22:53] <dylukes> It's really best to just see the definition, take it at face value
[11:23:01] <dylukes> it's not any more complicated than an iterator with its next/yield/whatever.
[11:23:15] <mark_edward> rememver most high school grads in the US never did calculus though. how are they goign to get this? set theory, categories? ISOMORHPIC???
[11:23:22] <dylukes> but yes
[11:23:22] <maikklein2> has anyone programed functors in Rust?
[11:23:26] <dbaupp> bjz: it's slightly embarassing that the maths majors who do the CS courses routinely do much better than all the rest of the cohort
[11:23:27] <dylukes> a monad is just a monoid in the category of endofunctors.
[11:23:32] <dbaupp> maikklein2: yes
[11:23:36] <mark_edward> maikklein2: didnt you try?
[11:23:48] <dylukes> Eventually "a monad is just a monoid in the category of endofunctors" is actually the most concise explanation XD
[11:23:56] <maikklein2> mark_edward, me? :D dunno I hope not
[11:23:57] <dylukes> Like to me, that makes the most sense now that I know the jargon.
[11:24:01] <dbaupp> maikklein2: http://www.reddit.com/r/rust/comments/1a57pw/haskeller_playing_with_rust_a_question_about/c8ut2ux :)
[11:24:06] <dylukes> That's not a metaphor ,it's literally what it is :p.
[11:24:14] <maikklein2> dbaupp, thanks
[11:24:29] <bjz> dbaupp: might have been better to do mathemagics, and do abit of discrete and category stuff. That's what CS should really be. Oh automata and languages would be good as well.
[11:24:31] <dbaupp> maikklein2: (it uses the same hack as the most recent reddit post)
[11:24:32] *** Joins: rust-noob (Mibbit@moz-3112320B.graz.surfer.at)
[11:24:43] *** Joins: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net)
[11:24:59] <dbaupp> bjz: yeah, it seems that essentially, one has to wait until 3rd year to get anything even close to that here
[11:24:59] * bjz is still getting to grips with all of that. tons to learn
[11:25:07] <dylukes> My business card literally says "mathemagician" haha.
[11:25:09] <dylukes> It's great.
[11:25:12] <bjz> :D
[11:25:13] <dylukes> "programmer + mathemagician"
[11:25:23] <dbaupp> (that said, I'm not doing any CS courses this semester, heh)
[11:25:30] <dylukes> CS courses pad my grades...
[11:25:32] <maikklein2> what is a flatmap? is it [[1,2],[3,4]] creates [1,2,3,4] ?
[11:25:34] <dylukes> I'm going into my second year atm.
[11:25:46] <dylukes> About to take my second to last course in analytic calculus. 
[11:25:52] <dbaupp> dylukes: where?
[11:25:55] <bjz> dbaupp: can't wait to have another go at this: https://www.coursera.org/course/proglang
[11:25:56] <dylukes> University of Pittsburgh
[11:26:05] <WABPBC> Can you use arbitrary-precision integers and floats?
[11:26:16] <dbaupp> WABPBC: there's extra::bigint
[11:26:23] *** Quits: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net) (Ping timeout)
[11:26:26] <dylukes> here we basically do 413: intro to proofs and sets and etc etc, 420: formalized Calc I and II.
[11:26:43] <dylukes> and then "A Calc I" and "A Calc II" are balls to the wall analysis.
[11:26:44] <dbaupp> WABPBC: but nothing for floats (unless you could rationals + bigints as arbitrary-prec floats)
[11:26:48] <dylukes> well, undergraduate analysis.
[11:26:51] *** Quits: dmi3y (dmi3y@9FD26F63.6075981B.B8FD5DE3.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[11:26:54] *** Joins: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca)
[11:27:00] <rust-noob> how can I order a vector by the result of a custom function?
[11:27:05] * dbaupp never did an intro to proofs class :P
[11:27:06] *** Joins: thesnowdog (doug@94FEF15E.9D0B7490.6F17036B.IP)
[11:27:13] <dylukes> It was hardly an intro haha
[11:27:22] <dbaupp> rust-noob: extra::sort::something_here
[11:27:29] * bjz feels so overwhelmed when it comes to the world of mathemagics. needs to get off his arse and do more study.
[11:27:30] <dylukes> I wrote a research paper involving the Brunn-Minkowski inequality.
[11:27:32] <dbaupp> rust-noob: quite a few take a lt closure
[11:27:38] <dylukes> and an n-dimensional proof of the isoperimetric inequality
[11:27:44] <dylukes> >__>
[11:28:00] <dylukes> The equivalent of "a monad is..." in undergraduate mathematics is
[11:28:00] <mark_edward> quit making up words :P
[11:28:11] <rust-noob> ok, let's see what I can find ;)
[11:28:12] <dylukes> "well continuity just means the preimage maps open sets to open sets"
[11:28:30] <bjz> mark_edward: that's a mathematicians favourite past time
[11:28:34] <dylukes> much better than the 3/4-clause definition given otherwise.
[11:28:44] <dylukes> :p
[11:28:45] <dbaupp> bjz: actually, reusing "regular" and "normal"
[11:29:14] <bjz> mark_edward: just go for a walk through a university labrary's mathematics section. it's hilarious
[11:29:17] <dylukes> After a few years of math, whenever people say "just normal numbers, man"
[11:29:23] <dylukes> I'm like "what does that EVEN MEANNNN"
[11:29:26] <bjz> haha
[11:29:29] <Ms2ger> dylukes, how else would you define continuity? ;)
[11:29:33] <mark_edward> dbaupp: i did one, you didnt miss anything fun. i used to know all about open sets and series an the real numbers and countable infinite and im glad to have fforgotten
[11:29:34] <bjz> WHAT IS A NUMBER
[11:29:41] <dylukes> Ms2ger: 4 clause definition involving cluster points that only works on the real line :p
[11:29:45] <dbaupp> dylukes: (and that defn is more general than the normal epsilon etc.)
[11:29:51] <mark_edward> rusti: 1
[11:29:51] <dylukes> for more so.
[11:29:52] -rusti- 1
[11:30:00] <mark_edward> bjz: there you go!
[11:30:29] <dbaupp> mark_edward: I mean, my uni throws us into the "deep end" for proof-based classes... I still did all that stuff
[11:30:49] <dylukes> rusti: println(fmt!("%? on %? on %?", "stacks", "stacks", "stacks"));
[11:30:50] -rusti- "stacks" on "stacks" on "stacks"
[11:30:50] -rusti- ()
[11:31:11] <dylukes> rusti: println(fmt!("%? on %? on %?", ~"heaps", ~"heaps", ~"heaps"));
[11:31:12] -rusti- ~"heaps" on ~"heaps" on ~"heaps"
[11:31:12] -rusti- ()
[11:31:14] *** Quits: WABPBC (Mibbit@F03BEF9E.297EA72C.17406662.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[11:31:27] <mib_sfs> what is the syntax for the assembly generated by rustc?
[11:31:28] <dylukes> A preview of my new ebook: Rust for Hustlas.
[11:31:28] * maikklein2 doesn't get that joke
[11:31:31] <dbaupp> dylukes: psh, that's a lame "basic" definition of continuity :P `f(B_epsilon(a)) \subseteq B_delta(f(a))` with soe for alls
[11:31:33] <mark_edward> heaps arent a recursive data structure
[11:31:37] <dbaupp> *some for alls
[11:31:54] <dbaupp> mib_sfs: -S
[11:31:58] <bjz> dylukes: we have printf! and prinfln! now
[11:32:03] <dylukes> oh srsly?
[11:32:04] <dylukes> well fuck me
[11:32:07] <dylukes> er, fork*
[11:32:08] <bjz> hehe, np
[11:32:21] <dylukes> there are children in here.
[11:32:27] <bjz> takes time for the message to filter down
[11:32:29] <dbaupp> mib_sfs: (i.e. `rustc -S file.rs`) is that what you're asking?
[11:32:34] <dylukes> really intelligent asian children who speak math.
[11:32:36] <mark_edward> for swearing you are sentenced to porting rustc to Malebolge
[11:32:37] <mib_sfs> dbaupp: i'mean the intel or at&t synax?
[11:32:40] *** Joins: dmi3y (dmi3y@9FD26F63.6075981B.B8FD5DE3.IP)
[11:32:42] <dbaupp> mib_sfs: oh, I don't know
[11:32:43] <dylukes> mark_edward: noooooo!
[11:32:58] <maikklein2> fmap != flatmap right?
[11:33:04] <mark_edward> i wonder if someone could make a rust to malebolge transpiler
[11:33:04] <mib_sfs> dbaupp: no problem
[11:33:05] <dylukes> fmap == functorial map
[11:33:14] <maikklein2> k
[11:33:18] <dbaupp> mark_edward: trans in malbolge would probably be cleaner :P
[11:33:21] <dylukes> ideally it would just be "map"
[11:33:27] <dylukes> but that was taken before functors came into the language
[11:33:34] <mark_edward> it's like a really shitty assembly right? LLVM can add it as a target
[11:33:35] <dylukes> so, translating to Rust...
[11:33:37] <dbaupp> maikklein2: flatmap == monadic bind (>>=) :P
[11:33:49] * maikklein2 ????????????ß
[11:33:55] <maikklein2> :D
[11:34:05] <dylukes> impl<T> ...functor... for [T] { fmap = map; } 
[11:34:13] <dylukes> in Rustskell
[11:34:36] <ldunn> murr. If I define an impl on ~[T], do I need to do anything in particular to to able to use whatever methods the impl defines?
[11:34:38] <cmr> dbaupp: you pinged yesterday?
[11:34:44] <dbaupp> mark_edward: it's *really* shitty, yes
[11:34:53] <dylukes> ldunn: have them in scope :)?
[11:34:56] *** Quits: dmi3y (dmi3y@9FD26F63.6075981B.B8FD5DE3.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[11:35:03] <mib_sfs> dbaupp: according to wikipedia, rust generates in at&t syntax
[11:35:54] <mib_sfs> not sure rust or llvm 
[11:35:55] <bjz> mib_sfs: of course wikipedia is the most up-to-date source on all things Rust
[11:36:04] <bjz> :D
[11:36:11] <dylukes> For April Fools, rust-lang should advertise having replaced the LLVM backend with COBOL.
[11:36:28] <dylukes> then I can use my rust code with http://www.coboloncogs.org/INDEX.HTM
[11:36:58] <mib_sfs> bjz: it does not say about rust, i generated a file and compared with wikipedia examples of at&t syntax
[11:37:25] *** Quits: true_droid (true_droid@moz-123FD9B8.beck.volia.net) (Client exited)
[11:37:27] <bjz> ah
[11:37:29] <dylukes> ugh
[11:37:35] <bjz> urrrgh
[11:37:36] <dylukes> I once wrote space invaders in MIPS 
[11:37:43] <dylukes> that was... *twitch*
[11:37:55] <dylukes> well a simplified version of space invaders with 1px "sprites" :)
[11:37:59] <dylukes> on a 64x64 virtual display
[11:38:11] <dylukes> so collision detection was somewhat easier.
[11:38:24] <maikklein2> we needed to write towers oh hanoi in mips
[11:38:27] <maikklein2> of*
[11:38:31] <dylukes> My classmates versions could handle ~128 objects on screen at once.
[11:38:36] <dylukes> I managed ~5000
[11:38:40] <dylukes> bullet hell version ;P.
[11:39:10] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[11:40:36] *** Quits: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se) (Ping timeout)
[11:40:40] <dylukes> I'll brb. Going to grab a bite to eat. I am currently... here: http://cl.ly/Qfs6
[11:41:03] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[11:41:03] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14a47407e to 148adcba4: 02http://git.io/N3iJvQ
[11:41:03] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[11:41:05] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[11:41:06] <ghrust> 01[13rust01] 15bors pushed 5 new commits to 06auto: 02http://git.io/qUE7sA
[11:41:06] <ghrust> 13rust/06auto 145092421 15Huon Wilson: std: adjust str::test_add so that the macro expands to all 3 items (#8012)....
[11:41:06] <ghrust> 13rust/06auto 14b55884c 15Huon Wilson: testsuite: remove 2 very outdated testcases; functionality is tested by other class-*.rs tests....
[11:41:06] <ghrust> 13rust/06auto 143c38e77 15Huon Wilson: testsuite: remove incorrect section of 2 test cases. (Also, &const is disappearing.)...
[11:41:08] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[11:41:17] <dylukes> btw
[11:41:22] <dylukes> if I want to play with 0.8
[11:41:35] *** Joins: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[11:42:01] <dylukes> what do
[11:42:08] <bjz> ya?
[11:42:11] <dylukes> ja?
[11:42:17] <bjz> ragh?
[11:42:19] <maikklein2> ?
[11:42:24] <bjz> ?!
[11:42:25] <dylukes> blimey.
[11:42:27] <dylukes> $?
[11:42:28] <maikklein2> current master is 0.8pre
[11:42:29] <dylukes> $! 
[11:42:37] <dbaupp> dylukes: build from master
[11:42:40] <dylukes> okey doke
[11:42:45] <bjz> dylukes: build from master
[11:42:47] <dbaupp> dylukes: and then start hacking, and submit pull requests :P
[11:42:59] <dylukes> Just need to get it into brew for niceties switching versions.
[11:43:05] <bjz> dylukes: implement higher order types for us
[11:43:15] <bjz> :D
[11:43:20] <dylukes> bjz: That's all rust needs. Dependent types :p.
[11:43:43] <dylukes> But what about codependent types, he says... 
[11:43:45] <dylukes> :p
[11:44:13] <bjz> dylukes: they say they will look at PRs for HOTs, but they can't spare dev time on them
[11:44:30] <bjz> dylukes: ie. the core devs
[11:44:34] <dylukes> PRs?
[11:44:40] <bjz> pull requests
[11:44:45] <bjz> on github
[11:44:57] <dylukes> Yeah I noticed there are suddenly a lot more people in here who aren't graydon and co.
[11:45:02] <dylukes> I remember when this had like.. 80 people.
[11:45:06] <bjz> hehe
[11:45:09] <dylukes> and was mostly just nmatsakis and graydon and a few others bantering.
[11:45:11] <bjz> we are growing
[11:45:27] <bjz> :)
[11:46:01] <bjz> dylukes: we are well past D at any rate
[11:46:05] <bjz> #d
[11:46:09] *** Quits: rust-noob (Mibbit@moz-3112320B.graz.surfer.at) (Quit: http://www.mibbit.com ajax IRC Client)
[11:46:12] * maikklein2 wants to use opengl in rust :(
[11:46:14] <bjz> (if that means anything)
[11:46:19] <bjz> maikklein2: :(
[11:46:29] <bjz> maikklein2: gotta figure out this problem
[11:46:30] <bjz> :(
[11:46:31] <maikklein2> do you think it is hard to port opengl es to the current master?
[11:46:32] <dbaupp> bjz: fwiw, nmatsakis has requested that someone doing HKT talk to him first
[11:46:57] <dbaupp> bjz: (possibly trying to direct their energies into more-bang-for-the-buck efforts.)
[11:47:01] <Ms2ger> HKT48?
[11:47:03] <bjz> dbaupp: yeah, that makes sense
[11:47:59] <bjz> maikklein2: need to figure out lmath. were you using it?
[11:48:08] <dylukes> HKT?
[11:48:12] <dylukes> Higher kinded types?
[11:48:18] <bjz> i think so
[11:48:22] <dylukes> maikklein2: heh I tried that a while ago
[11:48:25] <dylukes> the module/crate system got in my way
[11:48:31] <dylukes> I think it's a bit better now.
[11:48:50] <bjz> dylukes: I have a fn pointer loader, but it's blocked
[11:48:50] <dylukes> but I ended up coming up with a turing-complete variant of the #[] system...
[11:49:01] <bjz> :P
[11:49:08] <dylukes> Clearly the solution is the pop and lock.
[11:49:21] <bjz> dylukes: dbaupp was thinking of doing that too :P
[11:49:31] *** Joins: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se)
[11:49:41] <bjz> maikklein2: I think jeaye has a opengles version that works on master
[11:49:45] * Florob swallows the "fancy dance moves" comment
[11:49:53] <dylukes> Every day I just pthread_mutex_lock(stack->pop());
[11:50:10] <maikklein2> bjz, I had a glimpse on it, it wasn't updated 4 months ago 
[11:50:20] <maikklein2> bjz, but maybe it is working haven't tested it :)
[11:50:28] <ldunn> harrumph. Does `mod` not import implementations, perhaps?
[11:50:37] <dylukes> so guys
[11:50:38] <ldunn> perhaps I'll have to figure out how to get `use` to work >_>
[11:50:39] <dylukes> should I get this?
[11:50:40] <dylukes> http://www.thinkgeek.com/product/f141/
[11:50:52] <dylukes> I don't tend to wear nerdy shirts (just black button downs and jeans), but... this one is kinda great.
[11:50:59] <bjz> ldunn: you need to import the Trait
[11:51:10] *** Quits: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se) (Ping timeout)
[11:51:45] <bjz> dylukes: haha, I have to say, that joke is a little tired
[11:51:45] <dylukes> "So basically typeclasses are like the Job system in Final Fantasy 3, except you can use a GameGenie to have all of them at once" 
[11:51:50] <dylukes> bjz: true.
[11:51:56] <bjz> dylukes: :P
[11:51:57] *** Joins: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se)
[11:52:00] <ldunn> bjz: ahh
[11:52:37] <dylukes> ...rust is gonna take forever to build again isn't it
[11:52:41] <dylukes> I remember it taking for-goddamn-ever.
[11:52:48] <dbaupp> yup
[11:52:50] <dylukes> lol libuv
[11:52:56] <dylukes> those guys screwed me over mildly.
[11:52:58] <bjz> dylukes: llvm
[11:53:05] <dylukes> oh god
[11:53:12] <dylukes> I went in and wrote a huge patch to fix ipv4/6 agnosticism
[11:53:15] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Ping timeout)
[11:53:21] <bjz> dylukes: once you build it once, it goes lots quicker the next time
[11:53:23] <dylukes> then they said "eh it can't go in for another 3-4 major versions"
[11:53:24] <dbaupp> although, if've you've built rust's llvm recently, you won't have to do the full llvm build.
[11:53:36] <dylukes> and then they did it themselves or used someone elses nearly identical patch
[11:53:36] <dylukes> and I'm not even mad.
[11:53:37] <cmr> recently == past few days
[11:53:39] <cmr> it was just updated
[11:53:45] <dylukes> yeaaah haha
[11:53:48] <dylukes> nope
[11:54:06] <cmr> well, the update doesn't require a full rebuild
[11:54:15] <bjz> dylukes: did they know you though?
[11:54:17] <dylukes> oh lovely ,there are still four stages :)
[11:54:22] <dylukes> bjz: know me?
[11:54:23] <bjz> dylukes: 3
[11:54:29] <dylukes> 0, 1, 2, 3
[11:54:31] <dylukes> index from zero, son.
[11:54:35] <bjz> dylukes: the llvm folks
[11:54:39] <bjz> oh fff
[11:54:40] <dylukes> No. Haha.
[11:54:41] <bjz> hahaha
[11:54:45] <cmr> stage3 isn't actually run
[11:54:46] <bjz> *facepalm*
[11:54:59] <dylukes> But, it was funny. They had all this code to handle ipv4 vs ipv6 and I was like
[11:55:02] <dylukes> "what are you even doing"
[11:55:06] <dylukes> "the point is you don't have to care"
[11:55:11] <dylukes> "that's why it's agnostic"
[11:55:17] <dylukes> "just use getaddrinfo and stop caring"
[11:55:18] *** Joins: WABPBC (Mibbit@F03BEF9E.297EA72C.17406662.IP)
[11:55:26] <ldunn> bjz: er, how do I import the trait? :P
[11:55:53] <bjz> ldunn: use foo::bar::Trait;
[11:55:57] <dylukes> Dr. Strangenetcode, or: How I Learned to Stop Caring and Love getaddrinfo
[11:56:19] <dylukes> Is there common good practice with use statements? I kinda prefer doing use foo::bar and elsewhere bar::Trait
[11:56:22] <ldunn> oh, pefect - thanks much
[11:56:28] *** Quits: WABPBC (Mibbit@F03BEF9E.297EA72C.17406662.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[11:56:32] <dylukes> also, is there any performance difference for lookup? 
[11:56:40] <dbaupp> dylukes: it all happens at compile time
[11:56:47] <dylukes> well, true.
[11:57:05] <dylukes> I'm hoping the crisp Aegean breeze will help keep my laptop cool for LLVM building.
[11:57:16] <bjz> dylukes: I think it's mixed
[11:57:18] <dbaupp> dylukes: but you can't go `use foo::bar; use bar::Trait;` any more, assuming that's what you're talking about?
[11:57:18] <maikklein2> bjz, what do you think causes this in glcore? "error: unresolved name `glGenBuffers". Do you think its a problem with your glewinfo script?
[11:57:22] <dylukes> please please please let this be a parallelized build...
[11:57:28] <dylukes> dbaupp: no heh
[11:57:33] <bjz> maikklein2: no idea :(
[11:57:43] <dylukes> Can you make -j8 for rust/llvm?
[11:57:49] *** Quits: eevee (eevee@moz-58058235.evrt.wa.frontiernet.net) (Connection reset by peer)
[11:57:53] *** Joins: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au)
[11:57:58] <dylukes> let's find out
[11:58:01] *** Joins: eevee (eevee@moz-58058235.evrt.wa.frontiernet.net)
[11:58:04] <dbaupp> yes
[11:58:14] <dbaupp> it helps for llvm, but not for rustc itself
[11:58:14] <bjz> maikklein2: I really don't want to sight it again :( should probably just delete the repo.
[11:58:20] <dylukes> yeah but still
[11:58:28] <dylukes> I can run four instances of clang without a significant perf hit.
[11:58:33] <dylukes> So that's nearly 4x faster >_>.
[11:58:35] <dbaupp> (helps a lot for llvm)
[11:58:49] <dbaupp> yeah, rustc just has 0 build parallelism at the moment.
[11:59:08] <dylukes> Oh god
[11:59:11] <dylukes> MipsFrameLowering.cpp
[11:59:16] <dbaupp> (both in the bootstrapping buildsystem, and in the compiler itself.)
[11:59:34] <dylukes> Heh, my teacher haaaaated me for manually fp-optimizing my code :p.
[11:59:40] <dylukes> or using jump tables all over the goddamn place
[11:59:47] <dylukes> I implemented map/fold in assembly.
[11:59:49] <dylukes> And used them.
[11:59:52] <dylukes> it was great. 
[12:00:05] <dylukes> higher order "functions" in MIPS? sure why not.
[12:00:16] <dylukes> with tail call optimization :)
[12:00:20] <dylukes> well, hand done.
[12:00:31] <maikklein2> bjz, oh........... 
[12:00:40] <maikklein2> bjz, I am just sutpid
[12:00:46] <dylukes> I did a smaller assignment with no stack, just cactus-tree heap allocations... 
[12:00:52] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[12:00:54] <bjz> maikklein2: what happened?
[12:01:12] <maikklein2> bjz, I didn't even recognized your extern folder
[12:01:16] <dylukes> How to troll a systems architecture professor :p.
[12:01:18] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[12:01:50] <bjz> ?
[12:02:35] <maikklein2> nvm
[12:02:45] <dylukes> that was a remarkably quick llvm build : - ).
[12:02:48] <dylukes> It's already at the tests.
[12:03:18] <dylukes> aaand.. stage0... stage1... on stage2...
[12:09:18] <dylukes> anyhow
[12:09:20] <dylukes> bbl
[12:09:21] *** Quits: dylukes (dylukes@moz-B100DB2B.home.otenet.gr) (Quit: ["Textual IRC Client: www.textualapp.com"])
[12:10:21] <sebcrozet> Anybody knows how to get the (scalar) multiplication inlined in generic code?
[12:11:32] <bstrie> sebcrozet: is this in the same crate, or across multiple crates?
[12:11:52] <dbaupp> sebcrozet: what do you mean? (example code?)
[12:12:04] <sebcrozet> bstrie, dbaupp, Here: https://gist.github.com/sebcrozet/6162829
[12:12:10] *** Joins: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net)
[12:12:34] *** Joins: sk (sk@6A9E0928.E92B26F8.78DD174B.IP)
[12:13:18] <sebcrozet> compiled with --opt-level = 3
[12:13:27] <dbaupp> sebcrozet: in theory monomorphisation should mean that there's no difference (I think) :S
[12:13:44] <bstrie> dbaupp: if those two don't produce the same code, it's a bug. could you file it?
[12:13:44] <cmr> sebcrozet: you're compiling with -O right?
[12:13:47] *** Joins: dmi3y (dmi3y@9FD26F63.6075981B.B8FD5DE3.IP)
[12:13:56] <dbaupp> bstrie: me?
[12:13:59] <bstrie> er
[12:14:01] <sebcrozet> cmr: --opt-level=3
[12:14:03] <cmr> Ok
[12:14:07] <cmr> So yeah, bug
[12:14:11] <bstrie> sebcrozet: ^^^^
[12:14:40] <cmr> It's maybe a missing #[inline] or something similar in libstd
[12:15:06] <sebcrozet> ok
[12:15:16] <dbaupp> cmr: it's not
[12:15:31] <dbaupp> cmr: actually wait...
[12:15:33] * dbaupp checks
[12:15:37] <sebcrozet> So I file it or bstrie does?
[12:15:45] <cmr> you do!
[12:15:48] <sebcrozet> ok
[12:15:49] <dbaupp> it is
[12:16:14] <dbaupp> does someone want to just go and put inline (always?) on all the lame impls in num/?
[12:16:26] <dbaupp> or should I do it
[12:16:33] <cmr> #[inline(ifitdoesn'tinconvenienceyou)]
[12:16:35] * dbaupp nominates himself.
[12:16:41] * cmr nominates dbaupp
[12:16:48] <bstrie> dbaupp: be careful, we just recently removed all the inline-always from everywhere
[12:16:57] <dbaupp> heh... f64 % has #[inline] but nothing else does
[12:17:03] <dbaupp> bstrie: I know
[12:17:18] <dbaupp> bstrie: but these are fn mul() -> { *self * *other } 
[12:17:19] <dbaupp> etc
[12:17:19] <bstrie> maybe just start with #[inline] on things that don't have it
[12:17:23] <bstrie> ok
[12:17:38] <bstrie> #[inline(always)] is probably fine on things that are a single statement
[12:18:12] <bstrie> let's have a lint mode for functions with no semicolons in them, so that we can tell what to always inline :P
[12:18:53] <dbaupp> sebcrozet: could you try that with f32 instead of f64?
[12:19:01] <sebcrozet> dbaupp: ok
[12:19:43] <dbaupp> it seems like only the f64 arithmetic traits are missing the hint... all the other types have them... and the slow operations like sin all have them too.
[12:20:04] <cmr> Why should addition or multiplication be fast?
[12:20:06] <cmr> :p
[12:20:49] <dbaupp> bstrie: (it seems that everything else just has #[inline], so I'm leaving it as that for the moment.)
[12:22:20] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[12:24:09] *** Joins: true_droid (true_droid@moz-123FD9B8.beck.volia.net)
[12:25:04] *** Joins: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net)
[12:25:34] <sebcrozet> dbaupp: not sure what happens with f32. The call to `mul` disapearedâ€¦ but I cant find if it has been replaced by an assembly instructionâ€¦
[12:26:05] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[12:26:06] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/o62LFg
[12:26:06] <ghrust> 13rust/06auto 14476dfc2 15blake2-ppc: std: Use correct lifetime parameter on str::raw::slice_bytes...
[12:26:06] <ghrust> 13rust/06auto 14ca63850 15bors: auto merge of #8308 : blake2-ppc/rust/str-slice-bytes, r=alexcrichton...
[12:26:06] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[12:26:58] <sebcrozet> dbaupp: ahhh, my bad. I found it. So f32 inlines well.
[12:27:22] <dbaupp> sebcrozet: ok, cmr was right... missing #[inline]s.
[12:27:42] <sebcrozet> dbaupp: there is still a lot of nop on the generic version compared to the other oneâ€¦
[12:27:56] <dbaupp> bstrie: https://github.com/mozilla/rust/pull/8332 r?
[12:28:13] <cmr> sebcrozet: nop is for alignment fwiw
[12:28:32] <bstrie> dbaupp: arr-plus
[12:28:55] *** Quits: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net) (Ping timeout)
[12:29:01] <bstrie> cmr: but is it weird that they only show up in the generic version?
[12:29:18] <cmr> bstrie: depends on their sizes
[12:29:20] <bstrie> to me, monomorphization should imply identical output
[12:29:58] <cmr> if the *only* difference is nop, that is very weird indeed
[12:30:15] <bstrie> sebcrozet: could you file a bug about those nops?
[12:30:22] <bstrie> better safe than sorry
[12:30:38] *** Joins: samx (sami@moz-48EC0983.dyn.optonline.net)
[12:30:49] *** Joins: DoomBoom (DoomBoom@6B14631A.ACEC7723.5D1D3FEF.IP)
[12:30:57] <sebcrozet> issue for the inlining bug: #8333
[12:31:17] *** Quits: maikklein2 (maik@moz-18E00DC1.dip0.t-ipconnect.de) (Ping timeout)
[12:31:44] *** Quits: mib_sfs (Mibbit@moz-2B18508A.kla-tencor.com) (Quit: http://www.mibbit.com ajax IRC Client)
[12:32:30] *** Quits: z0w0 (zack@moz-E12708D5.lns6.woo.bigpond.net.au) (Client exited)
[12:34:56] <dbaupp> hm, it appears monomorphisation also does constant folding
[12:35:52] <cmr> In the AST?
[12:35:58] *** Quits: reyre (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Quit: Leaving)
[12:36:20] <dbaupp> at the LLVM level, I think.
[12:36:42] <dbaupp> the generic function doit(1.0f64) gets folded to `ret 1.0`
[12:36:55] * dbaupp doesn't know the mechanism at all
[12:37:28] <bstrie> it seems like a hazard if generic functions have any different optimization behavior from normal functions
[12:37:42] <bstrie> bad for understanding what's going on
[12:38:12] <sebcrozet> bstrie: bug for nops: #8334
[12:38:59] <dbaupp> ; Function Attrs: noinline uwtable
[12:38:59] <dbaupp> define internal fastcc void @"_ZN9doit_339016_72210f96d6c99867_0$x2e0E"() #0 { "while loop body.lr.ph.i":  ret void }
[12:39:12] <bstrie> sebcrozet: thanks
[12:39:21] <dbaupp> (is the IR of the monomorphised generic one)
[12:40:19] <dbaupp> ah! if I actually use the return value, it turns into a noop loop, with a `ret double 1.000000e+00` at the end.
[12:42:11] <sebcrozet> Thanks guys for fixing this. All those `mul` calls where a bottleneck on numeric code.
[12:42:46] <dbaupp> thanks for catching it!
[12:43:43] <dbaupp> should #8333 be closed now?
[12:43:55] <dbaupp> (or should I add "Fixes #8333" to 8332?)
[12:43:57] <bstrie> dbaupp: not til that pull lands
[12:43:58] <bstrie> yes
[12:44:22] <dbaupp> done
[12:44:47] <cmr> https://gist.github.com/cmr/5da898b77811594f34e9
[12:44:50] *** Quits: orshem (orshem@C5E06B1E.A5B6B765.E3D28531.IP) (Quit: Leaving)
[12:44:55] <cmr> Shouldn't it know which one to pick based on the return type?
[12:45:11] <cmr> Or, based on the type that GlobImport wants?
[12:45:46] *** Quits: samx (sami@moz-48EC0983.dyn.optonline.net) (Quit: This computer has gone to sleep)
[12:45:46] <dbaupp> nope
[12:45:49] <bstrie> is GlobImport generic?
[12:45:56] <dbaupp> what if the return types were the same?
[12:47:59] <cmr> Well then it would object
[12:48:08] <cmr> bstrie: it isn't
[12:48:12] *** Joins: samx (sami@moz-48EC0983.dyn.optonline.net)
[12:48:16] <cmr> It couldn't work in the general case
[12:48:24] <cmr> but it'd be nice if it had some smarts
[12:48:27] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[12:49:57] *** Joins: tcr_ (tcr@moz-EE576D3C.hsd1.ma.comcast.net)
[12:49:57] *** Quits: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net) (Connection reset by peer)
[12:51:37] *** Quits: tcr_ (tcr@moz-EE576D3C.hsd1.ma.comcast.net) (Ping timeout)
[12:55:38] *** Quits: samx (sami@moz-48EC0983.dyn.optonline.net) (Quit: This computer has gone to sleep)
[12:55:54] *** Joins: Sergio965 (sergiobz@moz-8D70E596.wireless.csail.mit.edu)
[12:57:47] *** Quits: ysuzuki (ysuzuki@moz-FEE44B6.net220148245.t-com.ne.jp) (Ping timeout)
[12:58:06] *** Joins: ysuzuki (ysuzuki@moz-FEE44B6.net220148245.t-com.ne.jp)
[12:58:25] *** Quits: jesse99 (jesse99@moz-F226420.hsd1.wa.comcast.net) (Ping timeout)
[12:59:12] *** Joins: jesse99 (jesse99@moz-F226420.hsd1.wa.comcast.net)
[13:02:01] *** Quits: cdidd (cdidd@moz-EFDE14D1.broadband.corbina.ru) (Ping timeout)
[13:02:06] *** Quits: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se) (Client exited)
[13:02:19] *** Joins: cdidd (cdidd@moz-D144383A.broadband.corbina.ru)
[13:02:35] <mrordinaire> hi, could anyone tell me how to recover back the identifier string hidden by the ident struct and SCTable (in syntax::ast)?
[13:03:26] <cmr> mrordinaire: syntax::parse::token::ident_to_str(ident)
[13:06:14] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[13:07:15] *** Joins: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se)
[13:07:47] <mrordinaire> cmr: thanks
[13:08:04] *** Joins: WABPBC (Mibbit@F03BEF9E.297EA72C.17406662.IP)
[13:08:26] <mrordinaire> cmr: what is the fastest way to get the parse tree from a source file?
[13:08:55] <cmr> mrordinaire: https://github.com/cmr/rustdoc_ng/blob/master/core.rs#L48
[13:09:02] <cmr> Everything in that function up to that line, more or less
[13:09:21] <Sergio965> Is there any way to typecheck in a macro?
[13:09:27] *** Quits: WABPBC (Mibbit@F03BEF9E.297EA72C.17406662.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[13:09:33] <Sergio965> IE, check that an expression is of a certain type?
[13:09:35] <cmr> Sergio965: no, macro expansion is long before typecheck
[13:09:44] <Sergio965> :(
[13:09:46] <cmr> Sergio965: Just assume it's correct and let the compiler do the rest for you
[13:11:01] *** Joins: WABPBC (Mibbit@F03BEF9E.297EA72C.17406662.IP)
[13:11:16] <Sergio965> Sounds good.
[13:11:44] <mrordinaire> cmr: thanks
[13:12:27] *** Quits: dmi3y (dmi3y@9FD26F63.6075981B.B8FD5DE3.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[13:12:28] *** Quits: WABPBC (Mibbit@F03BEF9E.297EA72C.17406662.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[13:13:04] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[13:13:21] *** Quits: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se) (Client exited)
[13:13:23] *** Quits: jesse99 (jesse99@moz-F226420.hsd1.wa.comcast.net) (Ping timeout)
[13:13:42] *** Quits: cdidd (cdidd@moz-D144383A.broadband.corbina.ru) (Input/output error)
[13:13:46] *** Joins: jensnockert (jensnocker@moz-79DA4C50.mobileonline.telia.com)
[13:14:33] *** Joins: dmi3y (dmi3y@9FD26F63.6075981B.B8FD5DE3.IP)
[13:15:27] *** Joins: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se)
[13:15:45] *** Joins: cdidd (cdidd@moz-D3F9BA73.broadband.corbina.ru)
[13:15:58] *** Quits: mrordinaire (Mibbit@1A659656.A607747.FD383126.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[13:16:08] *** Quits: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au) (Quit: gavinb)
[13:17:07] *** Quits: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se) (Ping timeout)
[13:17:18] *** Joins: Ionelia (ionelia@moz-1972B0C0.residential.rdsnet.ro)
[13:17:49] *** Joins: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se)
[13:17:55] *** Parts: Ionelia (ionelia@moz-1972B0C0.residential.rdsnet.ro) ()
[13:17:56] *** Quits: cdidd (cdidd@moz-D3F9BA73.broadband.corbina.ru) (Input/output error)
[13:23:06] *** Joins: cdidd (cdidd@moz-A1FC9540.broadband.corbina.ru)
[13:23:07] <Sergio965> So I'm defining a macro in a module, let's call it "modulea". How do I use it from another module? I'm currently getting "error: macro undefined".
[13:23:18] <cmr> #[macro_escape] I think
[13:23:33] <cmr> macros are still very second-class in that they can't really be exported
[13:23:40] <cmr> (yet)
[13:24:05] <Sergio965> Where is "#[macro_escape]" mentioned in the docs?
[13:24:10] <cmr> probably nowhere
[13:24:16] *** Joins: sw17ch (sw17ch@moz-62998E95.hfc.comcastbusiness.net)
[13:24:31] <Sergio965> "attrs in macros are not yet supported"
[13:24:36] <Sergio965> Is the error I get.
[13:24:52] <cmr> Ah the attribute goes on the module
[13:25:00] <cmr> See src/libstd/nuym/int_macros.rs for an example
[13:25:18] <dbaupp> Sergio965: code?
[13:26:23] *** Quits: jensnockert (jensnocker@moz-79DA4C50.mobileonline.telia.com) (Ping timeout)
[13:26:46] <Sergio965> Hmm, that removed the warning, but still getting macro undefined.
[13:27:06] <Sergio965> Er, the previous error.
[13:27:37] *** Joins: jensnockert (jensnocker@moz-131195AC.mobileonline.telia.com)
[13:31:49] *** Joins: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP)
[13:31:51] <Sergio965> Bah. What does "error: cannot move out of dereference of & pointer"?
[13:31:53] <Sergio965> Mean?
[13:32:07] <cmr> rusti: let x = 5; let y = &x; let z = *y; z
[13:32:08] -rusti- 5
[13:32:10] <cmr> hm
[13:32:18] <cmr> rusti: let x = 5; let y = &x; let z = *y; (x, z)
[13:32:19] -rusti- (5, 5)
[13:32:35] <cmr> rusti: struct Foo; let x = Foo; let y = &x; let z = *y; (x, z)
[13:32:36] -rusti- ({}, {})
[13:32:39] <cmr> ;_;
[13:32:55] <dbaupp> cmr: implicitly copyable
[13:33:01] <cmr> Sergio965: basically you have a &-ptr and you're trying to move out of it, but you can't because that would transfer ownership, and you don't own it
[13:33:11] <dbaupp> rusti: let x = ~[]; let y = &x; let z = *y; (x, z)
[13:33:12] -rusti- pastebinned 6 lines of output: http://sprunge.us/bbFW
[13:33:14] <Sergio965> Trying to move out of it?
[13:33:20] <dbaupp> rusti: let x = ~[1i]; let y = &x; let z = *y; (x, z)
[13:33:21] -rusti- pastebinned 11 lines of output: http://sprunge.us/PjTB
[13:33:29] <dbaupp> Sergio965: move == take ownership
[13:33:57] <Sergio965> Hmm.
[13:34:15] <dbaupp> Sergio965: and so you aren't allowed to take ownership of something hidden behind a reference (by definition, a non-owning pointer)
[13:34:18] <bstrie> so remind me, anything smaller than a pointer is implicitly copyable?
[13:34:23] <dbaupp> (because something else owns it.)
[13:34:39] <cmr> That would be stealing!
[13:34:40] <dbaupp> bstrie: unit struct with a dtor
[13:35:02] <dbaupp> bstrie: with #[unsafe_no_drop_flag] => 0 sized
[13:35:18] <bstrie> dbaupp: I'm not following the conversation, I just mean in general.
[13:35:25] <bstrie> I want to know what is and is not implicitly copyable
[13:35:27] *** Quits: cdidd (cdidd@moz-A1FC9540.broadband.corbina.ru) (Quit: Leaving)
[13:35:39] *** Joins: cdidd (cdidd@moz-A1FC9540.broadband.corbina.ru)
[13:35:40] <dbaupp> bstrie: yeah, that's a general thing that's not implicitly copyable and is smaller than a pointer?
[13:36:09] <bstrie> dbaupp: so is a u64 implicitly copyable on x64, but not on x86?
[13:36:09] *** Joins: sankha93 (uid12218@moz-31ABA2C0.irccloud.com)
[13:36:13] <dbaupp> bstrie: essentially the only things that aren't implicitly copyable are generics, things with dtors, and things containing non-implicitly copyable types. (I think.)
[13:36:21] <dbaupp> bstrie: oh, no.
[13:36:21] *** Joins: cade (cade@moz-DB3BF95F.members.linode.com)
[13:36:39] <cmr> It has nothing to do with size
[13:36:43] <bstrie> ok
[13:36:49] <cmr> [u8, ..10000] is implicitly copyable
[13:37:02] <bstrie> I guess I just don't understand the rules at all, then
[13:37:07] <cmr> me either tbh
[13:39:56] *** Joins: Azdle (Azdle@moz-B334B496.hfc.comcastbusiness.net)
[13:40:16] *** Joins: samx (sami@moz-48EC0983.dyn.optonline.net)
[13:40:29] <dbaupp> i'm *fairly* sure the rules are just about dtors (and generics)
[13:40:58] <bstrie> how can I tell when a copy is happening?
[13:41:15] <bstrie> just any time there's a pass-by-value?
[13:41:16] <dbaupp> a move is a memcpy under the hood too
[13:41:34] <dbaupp> so yeah, pass-by-val
[13:42:20] <engla> rusti: let v = [1,2,3,4]; let it = v.iter(); (it, it)
[13:42:21] -rusti- pastebinned 16 lines of output: http://sprunge.us/eUNg
[13:42:53] <engla> duh. anyway, even the v.iter() is copyable
[13:42:58] <dbaupp> rusti: let v = [1,2,3,4]; let it = v.iter(); printfln!((it, it))
[13:43:00] -rusti- line longer than 150 columns, pastebinned 2 lines of output: http://sprunge.us/JdRO
[13:43:22] *** Joins: reyre (reyre@916689EC.33EE9F8A.1139E686.IP)
[13:43:26] <cmr> I'm very much not a fan of implicit copies
[13:43:30] <cmr> but they make the language nicer to use
[13:43:34] <cmr> a lint would be nice
[13:43:50] <dbaupp> cmr: you were attempting the lint-by-copy-size weren't you?
[13:43:59] <dbaupp> (or was it just the lint for huge structs one?)
[13:44:00] <cmr> dbaupp: no, just definition of large types
[13:44:26] <dbaupp> http://php.net/manual/en/class.recursiveiteratoriterator.php
[13:44:36] <dbaupp> even php has iterators!
[13:44:59] <cmr> RecursiveIteratorIterator
[13:45:08] <cmr> must have borrowed that from java
[13:45:10] <cmr> :p
[13:45:40] <cmr> the new php site looks nice
[13:45:46] <cmr> doesn't look like it came out of the early 2000s
[13:47:08] *** Quits: dmi3y (dmi3y@9FD26F63.6075981B.B8FD5DE3.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[13:49:11] *** Joins: dmi3y (dmi3y@9FD26F63.6075981B.B8FD5DE3.IP)
[13:49:31] *** Quits: cdidd (cdidd@moz-A1FC9540.broadband.corbina.ru) (Quit: Leaving)
[13:51:30] *** Joins: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP)
[13:52:03] <Sergio965> So "cannot move out of dereference of & pointer" is happening inside of an a struct's implementation. The function signature is fn (&mut self, â€¦), and inside I do: "self.some_attr". Why would this happen on dereferencing self?
[13:52:08] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[13:52:31] <cmr> Sergio965: you cannot move out of self, you don't own it
[13:52:47] <Sergio965> ?
[13:52:49] <Florob> rusti: "Ã¤" == "aÌˆ"
[13:52:50] -rusti- false
[13:53:11] <Sergio965> How am I trying to move out of it by accessing and attr?
[13:53:55] <SimonSapin> Sergio965: I think it depends on what you do with it
[13:54:34] *** Joins: cdidd (cdidd@moz-166BF1DB.broadband.corbina.ru)
[13:55:09] <smvv> rusti: "a".equals(&(&"a"))
[13:55:09] -rusti- true
[13:55:15] <smvv> rusti: "a".equals("a")
[13:55:15] -rusti- <anon>:5:20: 5:23 error: mismatched types: expected `&&str` but found `&'static str` (expected &-ptr but found &'static str)
[13:55:16] -rusti- <anon>:5          "a".equals("a")
[13:55:16] -rusti-                              ^~~
[13:55:16] -rusti- error: aborting due to previous error
[13:55:16] -rusti- application terminated with error code 101
[13:55:18] <Sergio965> Sigh. I'm really confused.
[13:55:35] <smvv> why is the double borrow reference needed?
[13:55:41] <jensnockert>         /me hugs Sergio965.
[13:56:01] <SimonSapin> Sergio965: well, could you pastebin the code?
[13:56:21] <dbaupp> smvv: because .equals is generic, so it has to take T.equals(&T)
[13:56:21] <engla> Florob: yes, there is no handling of normalization forms
[13:56:31] <dbaupp> smvv: and in this case, T == &str
[13:56:41] <dbaupp> rusti: "a".equals(&("a"))
[13:56:41] -rusti- true
[13:56:52] <smvv> rusti: (*"a").equals("a")
[13:56:53] -rusti- pastebinned 8 lines of output: http://sprunge.us/QODJ
[13:56:57] <dbaupp> rusti: "a".equals(& &"a")
[13:56:58] -rusti- true
[13:57:05] <smvv> rusti: "a".equals(&"a")
[13:57:06] -rusti- <anon>:5:20: 5:24 error: mismatched types: expected `&&str` but found `&str` (expected &-ptr but found &str)
[13:57:06] -rusti- <anon>:5          "a".equals(&"a")
[13:57:06] -rusti-                              ^~~~
[13:57:06] -rusti- error: aborting due to previous error
[13:57:06] -rusti- application terminated with error code 101
[13:57:10] <dbaupp> smvv: &str != & (str)
[13:57:10] *** Joins: nano (nano@moz-972880B.superkabel.de)
[13:57:17] <dbaupp> smvv: and &"foo" == "foo"
[13:57:18] <Sergio965> https://gist.github.com/SergioBenitez/6164649
[13:57:32] <Sergio965> Error on line 135.
[13:57:37] *** Joins: boredomist (user@moz-63CF9F31.res-cmts.sesp.ptd.net)
[13:57:42] <smvv> i'm still bit confused by the whole &str vs ~str vs slices thing
[13:57:56] <dbaupp> smvv: &str is a slice
[13:58:15] <smvv> but why's a stack allocated str a slice?
[13:58:15] <dbaupp> smvv: it's a (pointer, length) pair to the interior of some other string
[13:58:20] <dbaupp> (essentially.)
[13:58:26] <smvv> i see
[13:59:08] <dbaupp> a stack allocated one is a slice because the data is placed on the stack and a pointer taken to it and put in that struct
[13:59:12] *** Joins: maxli1 (maxli@13F2CEC5.7672369.D8E68FF6.IP)
[13:59:38] <smvv> ok that makes sense :)
[13:59:56] *** Joins: ssalbiz (ssalbiz@moz-21D6B3DE.csclub.uwaterloo.ca)
[14:00:35] <cmr> Sergio965: ` let mem = self.memory;`
[14:00:40] <cmr> That moves from self into a local
[14:01:16] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[14:01:21] <Sergio965> Okay...
[14:01:28] *** Joins: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP)
[14:01:45] <Sergio965> That's bad?
[14:01:58] <cmr> Not so much bad as invalid  ;p
[14:02:04] <Sergio965> Why?
[14:02:06] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[14:02:06] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/o62LFg
[14:02:06] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[14:02:14] <Sergio965> I do it on line 111 without any problem.
[14:02:29] <engla> self.memory is   Option<&'self mut[ConsoleCharacter, ..(CHARS)]>
[14:02:41] <Sergio965> Uh huh...
[14:02:45] <cmr> uint is implicitly copyable
[14:02:46] <engla> it's invalid to duplicate &'self mut ... something
[14:03:01] <Sergio965> Why?
[14:03:03] *** Quits: dmi3y (dmi3y@9FD26F63.6075981B.B8FD5DE3.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[14:03:25] <Sergio965> Even if it's happening in the struct implementation which is &'self?
[14:03:43] <engla> mutable pointers, so  &mut [X] or &mut Y   can't be duplicated because the mutable access is exclusive
[14:04:17] <Sergio965> But I used to have the pointer be &'self mut[ConsoleCharacter, ..(CHARS)] and it worked fine.
[14:04:39] <Sergio965> Why does having it be an Options<&'self mut â€¦> change anything?
[14:04:44] <Sergio965> Option*
[14:04:58] <dbaupp> it doesn't
[14:05:06] *** Joins: dmi3y (dmi3y@9FD26F63.6075981B.B8FD5DE3.IP)
[14:05:07] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[14:05:07] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/woozhw
[14:05:07] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[14:05:10] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[14:05:10] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/2v_q-w
[14:05:10] <ghrust> 13rust/06auto 14991648d 15Alex Crichton: Use TreeMap's ord implementation for Json...
[14:05:10] <ghrust> 13rust/06auto 14ba3d03d 15bors: auto merge of #8312 : alexcrichton/rust/use-treemap, r=erickt...
[14:05:10] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[14:05:10] <Sergio965> :\
[14:05:23] <Sergio965> So it was an accident before?
[14:07:25] *** maxli1 is now known as maxli
[14:07:58] *** Quits: samx (sami@moz-48EC0983.dyn.optonline.net) (Quit: This computer has gone to sleep)
[14:08:16] *** Quits: cdidd (cdidd@moz-166BF1DB.broadband.corbina.ru) (Ping timeout)
[14:11:09] <Sergio965> I am at a total loss.
[14:11:09] *** Quits: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP) (Client exited)
[14:11:22] <engla> no idea Sergio965. 
[14:11:38] <engla> you need to use `match` to access it
[14:12:01] <dbaupp> Sergio965: are you refering to the `let rem = (self.x as int) + n;` on line 111?
[14:12:15] <Sergio965> dbaupp: Yeah, but I can see why that wouldn't be an issue.
[14:12:20] <Sergio965> engla: Let me try that.
[14:12:28] <engla> Sergio965: this will not work   mem = transmute(0xb8000u);    because the representation of a &mut []  is not just a pointer
[14:12:42] <dbaupp> Sergio965: in that case, x is implicitly copyable, so it just gets copied out of self, not moved.
[14:12:45] <Sergio965> engla: That's already worked.
[14:13:00] *** Joins: maikklein2 (maik@moz-18E00DC1.dip0.t-ipconnect.de)
[14:13:23] *** Quits: Florob (florian@E4BCD297.B50A917B.CD80E335.IP) (Quit: leaving)
[14:13:36] <dbaupp> Sergio965: you probably want `let memory = self.memory.get_ref(); (*memory)[self.position()] = cons_char`
[14:13:45] <engla> Sergio965: anyway,  libstd/unstable/raw.rs  has structs for the representation of types like the slice
[14:13:47] <Sergio965> dbaupp: I tried that. Didn't work.
[14:14:20] <dbaupp> Sergio965: error message?
[14:14:31] <Sergio965> cannot assign to an `&mut` in a `&` pointer; try an `&mut` instead
[14:14:31] <Sergio965> dev/console.rs:141     (*memory)[self.position()] = cons_char;
[14:14:41] <dbaupp> well, that's entirely different :)
[14:14:42] *** Joins: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP)
[14:15:02] <Sergio965> (and then: dev/console.rs:142:4: 142:9 error: cannot borrow `*self` as mutable because it is also borrowed as immutable
[14:15:02] <Sergio965> dev/console.rs:142     self.advance(1);)
[14:15:14] <dbaupp> Sergio965: .get_mut_ref()
[14:15:25] *** Quits: maikklein2 (maik@moz-18E00DC1.dip0.t-ipconnect.de) (Ping timeout)
[14:15:34] <Sergio965> error: cannot borrow `*self` as immutable because it is also borrowed as mutable
[14:15:46] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[14:16:18] <Sergio965> engla: Matching also gives error: cannot move out of dereference of & pointer.
[14:16:34] <engla> Sergio965: that depends on what you write inside the pattern match
[14:16:36] <engla> :)
[14:16:43] <engla> Some(ref mut mem) => 
[14:16:59] <engla> Sergio965: anyway, sorry I didn't read your type properly, it's not a slice
[14:17:08] *** Joins: lolwat (nano@moz-972880B.superkabel.de)
[14:17:08] *** Joins: orshem (orshem@C5E06B1E.A5B6B765.E3D28531.IP)
[14:17:14] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[14:17:19] <Sergio965> engla: Just tried that: cannot borrow `*self` as immutable because it is also borrowed as mutable
[14:17:37] <engla> well that error does not pertain to that line
[14:17:49] <Sergio965> dev/console.rs:138:31: 138:36 error: cannot borrow `*self` as immutable because it is also borrowed as mutable
[14:17:49] <Sergio965> dev/console.rs:138       Some(ref mut mem) => mem[self.position()] = cons_char
[14:18:17] *** Joins: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP)
[14:18:38] <engla> it's the self.position call
[14:18:40] <Sergio965> Yeah.
[14:18:45] <Sergio965> Removing it fixed it.
[14:18:53] <Sergio965> Why's that?
[14:18:56] *** Quits: lolwat (nano@moz-972880B.superkabel.de) (Ping timeout)
[14:19:04] <engla> the error message tries to explain it
[14:19:06] <Sergio965> If we go from mutable -> immutable, we borrow again?
[14:19:21] <engla> mutable access is exclusive
[14:19:38] <engla> so before you take a mutable pointer to the interior of self.. you do with Some(ref mut mem)
[14:19:49] <engla> you have to do this self.position()  before that
[14:20:16] <Sergio965> Interesting.
[14:20:23] <Sergio965> Awesome.
[14:20:40] <Sergio965> So why can't I make the call to Option.unwrap or get_mut_ref?
[14:20:47] <Sergio965> Isn't that the whole point of lifetimes?
[14:21:00] <Sergio965> (That I can return a pointer safely?)
[14:21:06] <engla> unwrap calls by value
[14:21:07] <Sergio965> (Well, not the whole point, but a major point.)
[14:21:11] *** Quits: sw17ch (sw17ch@moz-62998E95.hfc.comcastbusiness.net) (Ping timeout)
[14:21:11] <dbaupp> Sergio965: it should work with get_mut_ref if you move the .position call before it?
[14:21:20] <engla> we already know you can't take self.memory by value, so no .unwrap() possible
[14:21:46] <Sergio965> It does indeed.
[14:21:49] <Sergio965> dbaupp: it does indeed.
[14:21:51] <Sergio965> :\
[14:22:01] <engla> get_mut_ref  will work if you put a scope around the place you use it    {  let mem = ... .get_mut_ref(); .... }  
[14:22:05] <engla> yeah
[14:22:14] <dbaupp> Sergio965: .get_mut_ref is exactly the same as the match
[14:22:17] <Sergio965> Yeah
[14:22:23] <dbaupp> (it is presumably doing that match internally too.)
[14:22:26] <Sergio965> I figured maybe because it was a call something would happen.
[14:22:26] *** Joins: sw17ch (sw17ch@moz-39D8564F.wndsny.tds.net)
[14:23:38] <Sergio965> differently.
[14:23:41] <Sergio965> Whew.
[14:23:45] <Sergio965> That was interesting.
[14:24:15] <Sergio965> One last problem.
[14:24:38] <Sergio965> I can't get use those macros (print, and println) in other modules. I get "undefined macro".
[14:25:25] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[14:25:55] <engla> the macros are called printf! and printfln!
[14:25:56] <Sergio965> Thanks for the tremendous help, engla and dbaupp! That was fantastic.
[14:26:13] <Sergio965> They are what?
[14:26:19] <engla> print and println are functions
[14:26:22] <Sergio965> :\
[14:26:35] <Sergio965> I have macro_rules print( â€¦ ).
[14:26:49] <engla> oh, your own macros
[14:26:52] <Sergio965> Yeah. :)
[14:26:56] *** Joins: cdidd (cdidd@moz-9CDAEB16.broadband.corbina.ru)
[14:27:48] <engla> you have to use the hack attribute #[macro_escape];
[14:27:52] <Sergio965> I do.
[14:27:59] <engla> macro export is not implemented yet. Only works inside a crate
[14:28:18] <Sergio965> I have #[macro_escape] at the top of the macro.
[14:28:28] <engla> just put it at the top of the file
[14:28:35] <Sergio965> Er.
[14:28:37] <Sergio965> module*
[14:28:46] <Sergio965> https://gist.github.com/SergioBenitez/6164649
[14:28:57] *** Joins: lmandel (lmandel@13F2CEC5.7672369.D8E68FF6.IP)
[14:29:04] <Sergio965> Is this something put in after 0.7?
[14:29:38] <engla> try with a semicolon
[14:29:45] <Sergio965> Tried it, no go. :(
[14:30:01] <bstrie> rusti: range(1,10)
[14:30:01] -rusti- {state: 1, stop: 10, one: 1}
[14:30:22] <bstrie> rusti: range(1,10).collect::<~[int]>()
[14:30:23] -rusti- ~[1, 2, 3, 4, 5, 6, 7, 8, 9]
[14:30:25] <dbaupp> Sergio965: you'll need `=> ( { unsafe { initialize(); } console.log($msg) } )` (with the extra {}), btw.
[14:30:34] <dbaupp> https://github.com/mozilla/rust/issues/8012
[14:31:02] <dbaupp> Sergio965: what was the error message?
[14:31:11] <Sergio965> error: macro undefined: 'println
[14:31:13] <bstrie> rusti: range(1,10).foldl(0, |a, b| a+b)
[14:31:14] -rusti- pastebinned 8 lines of output: http://sprunge.us/bZbC
[14:31:25] <bstrie> rusti: range(1,10).fold(0, |a, b| a+b)
[14:31:26] -rusti- 45
[14:31:40] <dbaupp> Sergio965: you'll need to put the mod statement that imports that module before anything that uses the macors
[14:31:43] <dbaupp> *macros
[14:32:04] <Sergio965> I do.
[14:32:10] <Sergio965> I can use other things from that module.
[14:32:14] <Sergio965> Just not the macros.
[14:32:56] <dbaupp> can you put all your code up then?
[14:33:54] <Sergio965> https://gist.github.com/SergioBenitez/6165035
[14:33:59] <Sergio965> That's the caller.
[14:34:31] <bstrie> rusti: range(1, 1_000_000_001).fold(0, |a, n| a+n)
[14:34:36] -rusti- timeout triggered!
[14:34:45] <bstrie> oh right, that needs to be compiled with opts
[14:34:50] <bstrie> sorry rusti
[14:35:15] <bstrie> in any case
[14:35:18] <bstrie> I have a question
[14:35:56] <bstrie> in the above example, my machine gives me a negative result from overflow because it's inferring the integer depths to something less than 64
[14:36:13] <bstrie> I can fix this if I add a u64 suffix to either numeric literal
[14:36:34] <engla> integer literals default to int, right?
[14:36:39] <bstrie> right
[14:36:45] <bstrie> if they can't be inferred otherwise
[14:36:46] <bstrie> but
[14:37:04] *** Joins: WABPBC (Mibbit@F03BEF9E.297EA72C.17406662.IP)
[14:37:10] <bstrie> I can also (for example) put a u8 suffix on the `1` literal
[14:37:26] <bstrie> which infers the 1 billion to u8
[14:37:31] <dbaupp> Sergio965: you need macro_escape on dev too
[14:37:38] <Sergio965> dev is just a folder
[14:37:40] <WABPBC> Why does Rust look a lot like Haskell?
[14:37:41] <bstrie> but you can't put a u8 suffix on the 1 billion literal, because it realizes that the literal is out of range
[14:37:48] <Sergio965> WABPBC: Inspiration?
[14:37:57] <dbaupp> Sergio965: no, it's not just a folder, it's a Rust `mod` too
[14:38:03] <bstrie> so I'm wondering if it's possible to move the "this literal is out of range for its size" check until after the type inference
[14:38:06] <bstrie> in fact
[14:38:13] <bstrie> it would be nice if it informed the type inference
[14:38:22] <dbaupp> bstrie: there's a bug open about it somewhere
[14:38:29] <Sergio965> dbaupp: What do you mean? Where would I put the macro_escape?
[14:38:40] *** Quits: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[14:39:11] <dbaupp> Sergio965: #[macro_escape] mod dev { ... }
[14:39:23] <dbaupp> Sergio965: or mod dev { #[macro_escape]; ... }
[14:39:46] <WABPBC> Are functions first-class citizens?
[14:40:11] <bstrie> yep
[14:40:28] <bstrie> rusti: let x = |i| i+1; x(1)
[14:40:28] -rusti- <anon>:5:21: 5:22 error: the type of this value must be known in this context
[14:40:28] -rusti- <anon>:5          let x = |i| i+1; x(1)
[14:40:28] -rusti-                               ^
[14:40:29] -rusti- error: aborting due to previous error
[14:40:29] -rusti- application terminated with error code 101
[14:40:37] *** Quits: WABPBC (Mibbit@F03BEF9E.297EA72C.17406662.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[14:40:48] <bstrie> rusti: let x = |i: int| i+1; x(1)
[14:40:49] -rusti- 2
[14:41:12] <bstrie> rusti: let x = |i| i+1i; x(1)
[14:41:12] -rusti- <anon>:5:21: 5:22 error: the type of this value must be known in this context
[14:41:12] -rusti- <anon>:5          let x = |i| i+1i; x(1)
[14:41:13] -rusti-                               ^
[14:41:13] -rusti- error: aborting due to previous error
[14:41:13] -rusti- application terminated with error code 101
[14:41:27] <bstrie> rusti: let x = |i| i+1; x(1i)
[14:41:28] -rusti- <anon>:5:21: 5:22 error: the type of this value must be known in this context
[14:41:28] -rusti- <anon>:5          let x = |i| i+1; x(1i)
[14:41:28] -rusti-                               ^
[14:41:28] -rusti- error: aborting due to previous error
[14:41:28] -rusti- application terminated with error code 101
[14:41:34] <bstrie> hm
[14:45:37] *** Joins: WABPBC (Mibbit@F03BEF9E.297EA72C.17406662.IP)
[14:45:54] <WABPBC> Who is rusti
[14:46:02] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[14:46:16] <bstrie> WABPBC: a very fast typist
[14:46:25] <bstrie> it's an irc bot that interprets rust code
[14:46:37] <bstrie> rusti: "hello, WABPBC"
[14:46:38] -rusti- "hello, WABPBC"
[14:46:54] <Sergio965> Woo!
[14:47:00] <Sergio965> Good, good stuff.
[14:47:17] <Sergio965> Thanks for your time, engla, dbaupp. I really appreciate it.
[14:47:52] <jedestep> how does 5.times work with the new for loops?
[14:48:07] <bstrie> jedestep: `do 5.times { ... }`
[14:48:12] <orshem> how can i call code from libextra? i tried extern mod extra; use extra::rc; but i get error: failed to resolve import 'extra::rc'
[14:48:13] <jedestep> oooo
[14:48:17] *** Quits: WABPBC (Mibbit@F03BEF9E.297EA72C.17406662.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[14:48:52] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[14:49:22] <bstrie> orshem: works for me
[14:49:29] *** Quits: jaen (jaen@moz-E5C38B19.neoplus.adsl.tpnet.pl) (Ping timeout)
[14:49:30] *** Joins: tchoma (tchoma@moz-E58E29CC.dsl.static.sonic.net)
[14:49:40] <dbaupp> orshem: you need the extern mod at the top of the crate
[14:49:57] <dbaupp> orshem: (i guess `use self::extra::rc;` might work when its not.)
[14:50:08] <orshem> bstrie: weird
[14:50:20] <Sergio965> orshem: Yeah. Order is extern mod, then uses, then mods.
[14:50:30] <orshem> dbaupp: oh top of the crate? not the mod?
[14:50:39] <dbaupp> rusti: yeah
[14:50:39] -rusti- <anon>:5:9: 5:13 error: unresolved name `yeah`.
[14:50:40] -rusti- <anon>:5          yeah
[14:50:40] -rusti-                   ^~~~
[14:50:40] -rusti- error: aborting due to previous error
[14:50:40] -rusti- application terminated with error code 101
[14:50:44] <dbaupp> orshem: yeah
[14:50:46] <bstrie> haha
[14:50:48] <orshem> Sergio965: i know :) i broke my head on this all through yesterday
[14:50:48] <dbaupp> haha
[14:50:50] <Sergio965> Lol,
[14:51:14] <orshem> i even wrote to the mailing list on this :D
[14:51:24] *** Quits: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP) (Quit: victorporof)
[14:52:55] <Sergio965> I think they're trying to remove the arbitraryness of it.
[14:55:30] *** Joins: maikklein2 (maik@moz-18E00DC1.dip0.t-ipconnect.de)
[14:57:36] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[14:58:19] <cmr> The reason `use` has to come before every other item right now is that it affects the entire scope.
[14:58:59] <cmr> If `use` occured after other items, the import would take affect before the occurence of the statement
[14:59:06] <cmr> (this is to simplify the resolve algorithm)
[14:59:41] <cmr> I don't think it'd hurt anything to allow `mod` items before `use`
[14:59:54] *** Quits: sw17ch (sw17ch@moz-39D8564F.wndsny.tds.net) (Quit: sw17ch)
[14:59:57] *** Quits: maikklein2 (maik@moz-18E00DC1.dip0.t-ipconnect.de) (Ping timeout)
[15:00:18] *** Joins: jaen (jaen@moz-F0CEC9C7.play-internet.pl)
[15:01:01] <orshem> cmr: it just seems more logical that mod should precede use. i first buy something then i use it. or so i think
[15:01:11] <cmr> orshem: yes, I agree
[15:01:14] *** Quits: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net) (Ping timeout)
[15:01:18] <cmr> but there *are* good reasons for the way it is now
[15:01:20] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[15:01:20] *** ChanServ sets mode: +o dherman
[15:01:25] <cmr> they're just less obvious
[15:01:39] <Sergio965> There aren't good reasons for the developers.
[15:02:05] <Sergio965> Er, for those programming in Rust.
[15:02:29] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[15:03:05] <bstrie> Sergio965: don't think that "it makes resolve easier" is merely an excuse out of laziness. it's more likely that this rule actually makes resolve *decidable*
[15:03:11] <cmr> Sergio965: https://gist.github.com/cmr/21d28131643ceaabbdd4
[15:03:17] <bstrie> but you'll have to ask pcwalton to be sure
[15:03:19] <cmr> Sergio965: What bar() does that call?
[15:03:23] <Ms2ger> bstrie, pff, decidability is boring
[15:03:34] <Ms2ger> bstrie, can't rust decide the halting problem for me?
[15:04:01] <Sergio965> cmr: Is use allowed not as the first thing in a block?
[15:04:12] <Sergio965> bstrie: Why not do two scans?
[15:04:16] <bstrie> Ms2ger: I once invented a programming language that solved the halting problem. all programs would be run in a `while true` block, so that the answer to the halting problem, for all possible programs, was "no" :)
[15:04:25] <cmr> Sergio965: No, but it would be if the "arbitrary rule" was removed
[15:04:45] <Ms2ger> bstrie, nice
[15:04:56] <Ms2ger> bstrie, but what if I managed to crash?
[15:05:13] <Sergio965> cmr: The "arbitrary rule" I was referring to was the order of the extern mod, use, and mod statements. Certainly they should precede all other statements (except #[]).
[15:05:15] <bstrie> Ms2ger: ah, I've got you beat there too. the program does not crash, and just begins overwriting arbitrary memory
[15:05:25] <Ms2ger> :D
[15:05:28] <bstrie> the language was called TIGERSWORD
[15:05:35] <Sergio965> If you overwrite enough arbitrary memory, the OS will restart.
[15:05:50] <bstrie> TIGERSWORD solves the halting problem
[15:05:53] *** Quits: brianm (brianm@moz-9B7D279E.dsl.static.sonic.net) (Quit: Leaving...)
[15:05:54] <bstrie> TIGERSWORD cannot be stopped
[15:06:00] <bstrie> not by crashes
[15:06:02] <bstrie> not by anything
[15:06:03] <Sergio965> Eh, assuming you have access to physical memory.
[15:06:13] *** Quits: true_droid (true_droid@moz-123FD9B8.beck.volia.net) (Client exited)
[15:06:20] <Sergio965> bstrie: That's great marketing.
[15:06:26] <Sergio965> Now I want to use this language.
[15:06:46] <Ms2ger> Well, the answer to the halting problem is the constant "yes"
[15:06:56] <bstrie> when clicking a link in the online documentation for TIGERSWORD, sometimes the web page will crank up the volume on your speakers to maximum and play a roaring sound while clip art of a tiger with swords for legs jumps out of the screen at you
[15:07:07] <Ms2ger> Because all programs will finish when the sun explodes
[15:07:23] <Sergio965> What if I pull the plug?
[15:07:26] <Sergio965> Or smash the machine to bits?
[15:07:37] *** Joins: bent (chatzilla@moz-932324BF.hsd1.ca.comcast.net)
[15:07:42] <Sergio965> (no pun intended)
[15:07:44] <bstrie> Sergio965: tigersword will install rootkits on your machine that will resume the program as soon as power is restored
[15:07:52] <Sergio965> Haha.
[15:08:01] <bstrie> the only way to stop TIGERSWORD is the destroy the machine forever
[15:08:17] <bstrie> the reason I never implemented this languge is because it would be very hard to debug
[15:08:22] <bstrie> it's simply before its time
[15:08:26] <Ms2ger> It would be what? :)
[15:10:00] <orshem> what's the difference between Rc::from_freeze and Rc::from_send? or between freeze and send
[15:10:07] <orshem> freeze is less than send?
[15:10:14] <cmr> orshem: Freeze means deep immutability
[15:10:23] <cmr> Ie, it isn't mutable, and nothing it contains is mutable, recursively
[15:10:34] <orshem> and send is less?
[15:10:51] <cmr> Send just means it doesn't contain borrowed references or managed boxes, recursively
[15:11:52] <orshem> cmr, thanks
[15:17:38] *** Quits: jaen (jaen@moz-F0CEC9C7.play-internet.pl) (Quit: WeeChat 0.4.1)
[15:17:40] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Client exited)
[15:17:47] *** Joins: jaen (jaen@moz-F0CEC9C7.play-internet.pl)
[15:18:02] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[15:18:41] *** Joins: vosen (vosen@moz-266BA656.icpnet.pl)
[15:19:40] <orshem> error: capture of possibly uninitialized variable: `result`. but i'm using it to store new value not to retrieve...  
[15:19:44] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Ping timeout)
[15:19:57] <cmr> orshem: Yeah, it's very restrictive in what it accepts.
[15:20:01] <cmr> It needs to be initialized
[15:21:49] <orshem> cmr :(
[15:21:55] <orshem> i thought it would be smarter
[15:22:00] *** Joins: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP)
[15:22:16] <cmr> Well it could be smarter, it just needs to *know* that the closure you give it never accesses it uninitialized
[15:22:27] <orshem> oh well i usually like explicit in all the things
[15:22:43] <cmr> Which is possible to verify for closure literals I think
[15:22:48] <orshem> cmr, it should, it only appears as a lvalue
[15:22:59] <cmr> Open an issue for it
[15:23:14] <orshem> i will. thanks
[15:23:52] <doomlord_> whats the reason for not being able to impl for a type outside its' crate , would it create any inconsistent behaviours if you could? ( i know you can make a trait and impl that)
[15:24:18] <cmr> doomlord_: yes, it would
[15:24:28] <cmr> doomlord_: it would mean multiple crates could impl the same trait for a trait
[15:24:33] <cmr> which would cause link failure
[15:25:10] <cmr> (when linking those crates together, that is)
[15:25:50] *** Joins: sw17ch (sw17ch@moz-62998E95.hfc.comcastbusiness.net)
[15:27:21] *** Quits: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com) (Ping timeout)
[15:28:26] *** Quits: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP) (Ping timeout)
[15:29:54] *** Joins: diegoyam (quassel@FF9B1514.A4EC3D18.3A1EC144.IP)
[15:30:26] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[15:31:12] <bstrie> doomlord_: for historical insight, see https://github.com/mozilla/rust/wiki/Proposal-for-unifying-traits-and-interfaces , section "Instance coherence"
[15:31:21] <bstrie> doomlord_: also note that "iface" is the old keyword for "trait"
[15:31:45] <doomlord_> ah yes i encountered 'iface' online :)
[15:32:13] <jack> iface, the best keyword to use when you want to potentially violate two trademarks at the same time :)
[15:32:27] <doomlord_> haha
[15:32:52] <doomlord_> heh just dont make a "book" describing them all 
[15:33:37] *** Joins: dylukes (dylukes@moz-B100DB2B.home.otenet.gr)
[15:35:07] <jedestep> book.rs: //This file contains the headers of all ifaces in the project.
[15:35:08] <orshem> bstrie, you changed the name after lawsuit from Apple?
[15:35:51] <bstrie> orshem: it was either that, or rewrite the compiler in objective-C
[15:35:55] <bstrie> we had no choice
[15:36:08] <orshem> :)
[15:36:23] <bstrie> objective-Rust
[15:36:28] <bstrie> Rust With Classes
[15:36:57] <bstrie> Rustâ™­
[15:37:43] <jedestep> RustScript please
[15:37:44] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[15:37:44] *** ChanServ sets mode: +o dherman
[15:38:09] *** Quits: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com) (Input/output error)
[15:38:13] <jedestep> JRust
[15:38:18] <bstrie> RustScript will be a concatenative programming language with prototypal inheritance
[15:39:06] <bstrie> however, we've learned many lessons from javascript. it will require semicolons at both the beginning and end of every line, to appease both camps
[15:39:19] <bstrie> IronRust
[15:39:22] <Ms2ger> bstrie++
[15:39:55] <bstrie> we could also do RuRu, which is a rust compiler in rust
[15:39:57] <bstrie> how novel
[15:40:11] <doomlord_> i think i'd favour significant whitespace.. if it wasn't for spaces vs tabs..
[15:40:25] *** Quits: DoomBoom (DoomBoom@6B14631A.ACEC7723.5D1D3FEF.IP) (Ping timeout)
[15:41:07] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[15:41:07] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/2v_q-w
[15:41:07] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[15:41:27] <Ms2ger> doomlord_, everyone (except one guy called Tab) has given up on tabs :)
[15:41:36] <cmr> I haven't given up tabs
[15:41:41] <cmr> tabs for indentation, spaces for alignment
[15:41:44] <cmr> the One True Way
[15:41:52] <cmr> (and really it's the only way that makes sense if you think about it)
[15:41:56] <bstrie> spaces for indentation, tabs for alignment
[15:42:02] <bstrie> the One True Way To Piss Off Cmr
[15:42:10] <orshem> i have no problem with the syntax of rust and i don't understand the semantics of it so i'm ok
[15:42:18] <sam113101> what's alignment though?
[15:42:21] <jedestep> cmr the tab user, who chastised me for using tabs in the one PR i made ;)
[15:42:25] <doomlord_> tabsize=4, perfection. tabsize=2? just press space twice. tabsize=8? too much, but for asm source you can just press tab twice
[15:42:25] *** Joins: Kruppe (user@moz-4DDA8AB8.uwaterloo.ca)
[15:42:26] <cmr> sam113101: anything that isn't a tab
[15:42:32] <Ms2ger> foo(a,
[15:42:35] <Ms2ger>     b)
[15:42:36] <cmr> sam113101: *isn't indentation
[15:42:44] <sam113101> IÂ use tabs for that
[15:42:50] <cmr> jedestep: well, it's not *my* prefered style, but it is the style rust uses
[15:42:56] <cmr> sam113101: you are wrong!
[15:42:59] <Ms2ger> ^
[15:43:03] <jedestep> I know I only kid
[15:43:08] <cmr> Tabs are a semantic character that indicate the level of indentation of a line
[15:43:12] <sam113101> IÂ put a tab before a, then a tab before b and the two align
[15:43:14] <bstrie> let's not begin a spaces-vs-tabs argument. we all know that vim is better than emacs.
[15:43:15] <cmr> the spaces are to make things lineup pretty
[15:43:19] <jedestep> in my opinion
[15:43:24] <jedestep> lines should be separated with form-feed
[15:43:34] <cmr> sam113101: well they don't align if tab size equals 27, for example
[15:43:46] <jedestep> \n and \r are clunky and primitive
[15:43:48] <jedestep> \f is the true way
[15:44:07] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[15:44:07] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/5bZyXw
[15:44:07] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[15:44:10] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[15:44:10] <ghrust> 01[13rust01] 15bors pushed 6 new commits to 06auto: 02http://git.io/hbvHgw
[15:44:10] <ghrust> 13rust/06auto 14bcf62e7 15Michael Sullivan: Make node_id_to_str print more useful info in some cases. Closes #2410.
[15:44:10] <ghrust> 13rust/06auto 14a200816 15Michael Sullivan: Fix an unused variable warning and clean up some dead code/names.
[15:44:11] <ghrust> 13rust/06auto 14fd01031 15Michael Sullivan: Warn when using -o option on libraries. Closes #6554.
[15:44:13] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[15:44:19] <sam113101> well, it olds true for tabs + spaces too
[15:44:31] <sam113101> wait
[15:44:36] <sam113101> no forget it
[15:44:43] <bstrie> jedestep: I disagree, I think lines should be separated with U+001E RECORD SEPARATOR. formfeed is a relic of the 1990s
[15:44:55] * jensnockert hugs bjz.
[15:45:01] <sp3d> heh
[15:45:04] <sam113101> IÂ am sleep deprived
[15:45:07] <jedestep> formfeed is worth 30 points on a compilers assignment so it must be the best
[15:45:20] <sp3d> we could do what ghc does
[15:45:33] <jedestep> Rust--?
[15:45:38] <bstrie> jedestep: U+001E is *position* 30 in ascii, so it must be the best!
[15:45:47] <sp3d> and only actually accept a subset of the newlines the spec describes
[15:46:05] <bjz> jensnockert: why does i deserve hug?
[15:46:13] <jensnockert> Because it is really hot here.
[15:46:16] <Ms2ger> Hey, where's register_fn_full/register_fn_fuller gone?
[15:46:21] <bjz> 8[
[15:46:43] <jedestep> :âˆ«
[15:46:44] <jensnockert> I'm building a hardware FLAC player, with code in Rust.
[15:46:55] <jensnockert> I hope I'll get it working :S
[15:47:08] <bjz> I hope so too!
[15:47:15] *** Joins: graydon (Adium@A5087023.2354C43D.D8E68FF6.IP)
[15:47:15] *** ChanServ sets mode: +qo graydon graydon
[15:48:11] <darkf> jensnockert: sounds very interesting!
[15:48:13] <jensnockert> I slightly chickened out of the idea of writing a MP3 player when I realized that guys from Fraunhofer was here :S
[15:48:36] <cmr> what is Fraunhofer?
[15:49:10] <jensnockert> They made MP3 and charge money from people who implement it.
[15:49:14] <cmr> oh
[15:49:38] <cmr> Good thing we have ogg and opus then eh?
[15:49:41] <sam113101> that's evil
[15:49:44] <Ms2ger> Yay, patents
[15:49:51] *** Quits: jaen (jaen@moz-F0CEC9C7.play-internet.pl) (Ping timeout)
[15:49:53] <cmr> sam113101: it's not evil, it's good business
[15:50:02] <bstrie> when the heck does the mp3 patent expire
[15:50:10] <Ms2ger> If you don't like them, http://patents.stackexchange.com/ might be of interest
[15:50:15] <jensnockert> Well, the problem with MP3 is that the patents are really mushy, and no one really knows which patents there are and who owns them.
[15:50:39] <bstrie> mp3 came out in 1995
[15:50:45] <bstrie> patents expire 20 years after filing
[15:50:48] <bstrie> that was 8 years ago
[15:50:52] <bstrie> how can any patents still exist
[15:50:59] <bstrie> wait
[15:51:01] <bstrie> I'm dum
[15:51:03] <sp3d> :D
[15:51:06] * bstrie sits in the corner
[15:51:07] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[15:51:10] <cmr> 8 years ago
[15:51:13] * cmr checks the date
[15:51:15] <cmr> nope
[15:51:23] <darkf> 18 years ago. but there are all kinds of legal loopholes everywhere
[15:51:26] <bstrie> so bad at math
[15:51:29] *** Joins: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net)
[15:51:30] <cmr> plus patent extension
[15:51:42] <sam113101> oh shit
[15:51:43] <darkf> same way works in the 40s are not in the public domain for some reason
[15:51:48] <sam113101> darkf you're back
[15:51:51] <jack> jensnockert: why not write a Opus encoder/decoder?
[15:52:00] <jack> free of patents, and needed anyway :)
[15:52:01] <jensnockert> jack: Because it is complex.
[15:52:07] <cmr> mp3 isn't?
[15:52:14] <jensnockert> jack: Also, it isn't necessarily free of patents.
[15:52:16] <darkf> sam113101: I thought I knew you. sam113101 :)
[15:52:17] <jensnockert> cmr: MP3 is really simple.
[15:52:18] <bstrie> "The various MP3-related patents expire on dates ranging from 2007 to 2017 in the U.S."
[15:52:18] <jack> jensnockert: unlike mp3, you have access to the whole opus team.
[15:52:23] *** Joins: chii (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP)
[15:52:30] *** Quits: reyre (reyre@916689EC.33EE9F8A.1139E686.IP) (Ping timeout)
[15:52:32] * jack puts on his Xiph hat.
[15:53:00] <jensnockert> I can write an MP3 decoder in my sleep, and so could probably most of you in here.
[15:53:07] <jensnockert> FLAC is even simpler.
[15:53:11] <graydon> yeah we have like .. a large percentage of the xiph team working for mozilla presently :)
[15:53:19] <jack> jensnockert: i don't think opus decode is so hard.
[15:53:41] *** Quits: dmi3y (dmi3y@9FD26F63.6075981B.B8FD5DE3.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[15:53:41] *** Joins: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com)
[15:53:56] <Ms2ger> graydon, would be nice if we could get them off C ;)
[15:54:06] <jack> graydon: i had no idea until tjc was on a video call that rillian sat right next to you :)
[15:54:15] <graydon> jack: yup!
[15:54:31] <jack> Ms2ger: they need to ship to embedded platforms that don't even have c++ compilers. so i think that is a nonstarter for the official builds.
[15:54:37] <jack> Daala can't even use C99.
[15:54:40] <graydon> jack: he lives a few blocks from me. I recommended him for the job :)
[15:55:17] *** Joins: ozten (ozten@moz-DD3B00B4.hsd1.wa.comcast.net)
[15:55:37] <jensnockert> jack: The libopus decoder is like 4-5 times as large as the ffmpeg FLAC decoder.
[15:55:59] <jack> flac is not really comprable. it does nothing fancy at all.
[15:56:14] <jensnockert> jack: It isn't insurmountable, but considering I need to write it in Rust, port the code to a Cortex M4, and do it in less than 24h, I feel that simpler might be the key.
[15:56:21] <jack> MPEG1 is also a lot more complex than gzipping a movie.
[15:57:04] <jack> jensnockert: the world just does not need more mp3 decoders.
[15:57:18] <jack> i mean, if flac is simple, use flac ;)
[15:57:23] <jensnockert> jack: No, I am well aware.
[15:57:40] <jack> vorbis probably isn't that much more complex than mp3.
[15:57:52] <jensnockert> jack: Maybe 2x?
[15:58:12] <jack> hardly performance is pretty close. remember in vorbis you donj't have two levels of MDCT
[15:58:13] <jensnockert> jack: Just parsing ogg is a bitch compared to a MPEG1 ES.
[15:58:19] <jack> the stupid subbanding in mp3 is silly
[15:58:41] <jensnockert> The other part is a polyphase filter, not a MDCT though.
[15:58:50] <jack> are you talking about the headers? ogg_packet is just length + flags + payload afaik.
[15:59:19] <jensnockert> jack: MPEG1 is just "payload"
[15:59:30] <jack> so encode some "just payload" ogg files :)
[15:59:41] <jensnockert> I could, but that would be cheating.
[16:00:03] *** Joins: reyre (reyre@B2D8AB09.33EE9F8A.1139E686.IP)
[16:00:54] <dylukes> quick question
[16:01:00] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[16:01:00] *** ChanServ sets mode: +o brson
[16:01:06] *** Joins: jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net)
[16:01:16] <dylukes> er brb
[16:02:02] *** Joins: Florob (Florob@moz-39532932.de)
[16:02:35] *** Joins: tjc (tjc@moz-6EB4E533.dsl.tsoft.com)
[16:02:35] *** ChanServ sets mode: +o tjc
[16:02:43] *** Joins: mike (Mibbit@moz-11F9F15.red-83-37-58.dynamicip.rima-tde.net)
[16:03:05] <mike> hey, how can I get input from the keyboard?
[16:03:26] <cmr> mike: from stdin? or what
[16:03:31] <jedestep> std::io::stdin
[16:03:53] <graydon> https://etherpad.mozilla.org/Meeting-weekly-2013-08-06
[16:04:05] <mike> for example how to know if the user touch the left arrow
[16:05:13] <kmc> to read terminal keypresses instantly you will need to put the terminal into a raw mode
[16:05:25] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Ping timeout)
[16:05:37] <mike> how can I do it?
[16:06:17] <kmc> are you on a unix system? the quick hack there is to invoke the external command "stty raw"
[16:06:44] <mike> no, I'm on windows xp
[16:06:49] <kmc> ok then I don't know, sorry
[16:06:56] <mike> Anybody knows?
[16:07:37] <darkf> mike: you'll probably have to wrap the console C API for that. (or, you know, conio.h, which is evil). or ncurses. :)
[16:08:02] <cmr> mike: You want to write a console program... in rust... targetting Windows XP?
[16:08:20] <darkf> why not?
[16:08:28] <mike> really is a space game, with ascii characters
[16:08:42] <darkf> yeah you will definitely want something like ncurses
[16:08:43] <mike> pretty simple
[16:09:00] <cmr> Well it's the combination of a nasty API plus a pre-alpha programming language plus an EOL OS..
[16:09:04] <darkf> i think there are some bindings but they're likely out of date, and you will need an implementation for windows (I recommend pdcurses)
[16:09:18] <cmr> (pdcurses is quite good)
[16:09:28] <jensnockert> Hurray, SIMD on the weekly meeting <3.
[16:09:46] <cmr> graydon: Can you discuss allowing `mod` items before `use`?
[16:10:38] <graydon> jensnockert: was there ... something new to discuss about SIMD? I thought "nominal tuples + lang items" was an acceptable strategy
[16:10:50] <jensnockert> graydon: I think so.
[16:11:09] <bstrie> I read "samsung" in the servo meeting notes and for a moment thought it was someone named Sam Sung
[16:11:12] <jensnockert> graydon: Except that those types are broken in rustc right now.
[16:11:25] <jensnockert> graydon: They don't work genericly cross-crate.
[16:11:41] <graydon> ok, so .. assuming we fix _that_ :)
[16:11:48] <jensnockert> graydon: Yes, that would be fine.
[16:12:00] <jensnockert> At least in my opinion.
[16:12:55] <sebcrozet> Is there any doc about that ?
[16:13:00] <sebcrozet> SIMD in rust I mean.
[16:13:11] *** Quits: jensnockert (jensnocker@moz-131195AC.mobileonline.telia.com) (Connection reset by peer)
[16:13:52] *** Quits: tchoma (tchoma@moz-E58E29CC.dsl.static.sonic.net) (Ping timeout)
[16:13:58] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[16:14:50] <cmr> sebcrozet: the person who probably knows the most about it just DC'd :p
[16:15:31] <sebcrozet> cmr: DC'd ?
[16:15:36] <cmr> disconnected
[16:15:56] <sebcrozet> cmr: ah, ok.
[16:16:17] *** Joins: lhatsk (Adium@moz-3292591F.pool.mediaways.net)
[16:16:31] <toddaaro> brson: can you look at issues 4495 and 6856? went through and closed a few runtime issues
[16:17:01] <toddaaro> brson: I think one can be closed, other could use a little clarification
[16:21:51] *** Quits: tjc (tjc@moz-6EB4E533.dsl.tsoft.com) (Quit: zzzzzzzzzz)
[16:22:44] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[16:22:56] <kmc> still baffled by this error: http://pastebin.mozilla.org/2795472
[16:25:32] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[16:26:02] *** Joins: mib_2pjobt (Mibbit@moz-D3D15A0C.vie.surfer.at)
[16:26:19] <kmc> "cannot borrow immutable self value as mutable" inside a function which takes &mut self
[16:26:23] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[16:27:05] *** Joins: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP)
[16:27:43] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[16:28:17] <dylukes> okay so question
[16:28:22] <dylukes> say I do the following
[16:28:25] *** Joins: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com)
[16:28:34] <dylukes> let (port, chan): (Port<int>, Chan<int>) = stream(); let mut port_iter = PortIterator(port);
[16:28:44] <dylukes> where struct PortIterator<T>(Port<T>); with an impl of Iterator
[16:28:58] <dylukes> if I do `for i in port_iter {...}`
[16:29:07] *** Quits: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP) (Ping timeout)
[16:29:30] <dylukes> and I *drop* the `mut` qualifier on port_iter,
[16:29:31] <dylukes> I get
[16:29:31] <dylukes> error: cannot borrow immutable local variable as mutable
[16:29:54] <cmr> dumitru: correct
[16:29:57] <bstrie> dylukes: advancing an iterator mutates it
[16:30:03] <cmr> guh
[16:30:04] <dylukes> aaaah okay.
[16:30:05] <cmr> too many d
[16:30:06] <dylukes> Duly noted.
[16:30:12] <dylukes> Would it be advisable to heap allocate here btw?
[16:30:25] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[16:30:47] <bstrie> dylukes: heap allocate the iterator? shouldn't be needed, it's not very large
[16:30:49] <cmr> dylukes: no, don't heap allocate unless you absolutely have to
[16:30:54] <mike> How can I print all the values of an array?
[16:30:55] <dylukes> alrighty
[16:30:56] <bstrie> rusti: [1,2,3].iter()
[16:30:57] -rusti- pastebinned 15 lines of output: http://sprunge.us/KQXh
[16:31:04] <bstrie> rusti: range(0,1)
[16:31:04] -rusti- {state: 0, stop: 1, one: 1}
[16:31:10] <dylukes> also what's the close method on ports?
[16:31:38] *** Joins: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP)
[16:31:40] <olsonjeffery> how do i see the output of rtdebug! when running tests?
[16:31:47] *** Joins: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP)
[16:32:14] <bstrie> dylukes: do you really need to close the port manually?
[16:32:18] <dylukes> Yep :p
[16:32:25] <dylukes> otherwise try_recv() will never return None.
[16:32:31] <dylukes> and the iterator will never terminate.
[16:32:37] <brson> toddaaro: done
[16:32:58] <dylukes> I assume it's set up to close on destruct?...
[16:33:03] <dylukes> but then there's no way to signal an end of resource :\
[16:33:25] <jack> how do i clone something with a raw pointer?
[16:33:30] *** Quits: mib_2pjobt (Mibbit@moz-D3D15A0C.vie.surfer.at) (Quit: http://www.mibbit.com ajax IRC Client)
[16:33:44] <mike> How can I print all the values of an array?
[16:33:55] *** Joins: blauken (blauken@moz-E7EA111C.clients.kiwiirc.com)
[16:33:55] <bstrie> dylukes: try `let _ = my_port;`
[16:34:01] <bstrie> that might drop it?
[16:34:06] *** Joins: jensnockert (jensnocker@moz-131195AC.mobileonline.telia.com)
[16:34:17] <bstrie> would be interesting if it does
[16:34:23] <dylukes> actually, just doing the sends in another task seems to work.
[16:34:25] <jdm> does #[path] still exist?
[16:34:32] <cmr> mike: for item in vec.iter() { println(item.to_str()); }
[16:34:32] <dylukes> do spawn { for i in range(0, 10) { chan.send(i); }
[16:34:44] <cmr> jdm: for the file to pull a module from? yes
[16:34:45] <olsonjeffery> brson: did you see my question? what's the secret sauce? thanks.
[16:34:48] *** Joins: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net)
[16:34:50] <jdm> cmr: hmm, interesting.
[16:34:54] <jdm> I assumed we removed it totally
[16:34:58] <jensnockert> sebcrozet: Sorry, missed your message before I went to dinner. There's not much documentation for Rust SIMD yet, because it is mostly not implemented.
[16:34:59] <jdm> but we just removed unnecessary ones
[16:35:55] <sebcrozet> jensnockert: but you told about some types in rustc which are broken atm ?
[16:36:14] <brson> olsonjeffery: no, I didn't see it. can you repost?
[16:36:15] *** Joins: maikklein2 (maik@moz-18E00DC1.dip0.t-ipconnect.de)
[16:36:19] <jensnockert> sebcrozet: Yeah, but that's all structs defined like struct randomtype<T> (T, T, T, T)
[16:36:34] <jensnockert> sebcrozet: Not SIMD-specific.
[16:36:38] <dylukes> wtf
[16:36:45] <dylukes> did SharedChan disappear in 0.8?
[16:36:52] <cmr> dylukes: Yes it did
[16:36:59] <dylukes> anything replacing it?
[16:37:00] *** Joins: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com)
[16:37:00] *** ChanServ sets mode: +o pcwalton
[16:37:01] <sebcrozet> jensnockert: ah ok.
[16:37:02] <olsonjeffery> brson: how do i see the output of rtdebug! when running tests?
[16:37:05] *** Quits: mike (Mibbit@moz-11F9F15.red-83-37-58.dynamicip.rima-tde.net) (Quit: http://www.mibbit.com ajax IRC Client)
[16:37:08] <dylukes> or do I need another task to merge them :\?
[16:37:22] <brson> SharedChan still exists
[16:37:23] <cmr> dylukes: wait no
[16:37:27] <cmr> I was thinking of PortSet
[16:37:29] <cmr> sorry
[16:37:32] <dylukes> did it move to extra?
[16:37:36] <dylukes> it's still doc'd in std
[16:37:42] <sebcrozet> jensnockert: so this will be replaced by simd-specific types?
[16:37:51] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[16:37:54] <brson> olsonjeffery: you have to manually edit macros.rs to swap the naming of rtdebug! and rtdebug_!. it's pretty hackish
[16:38:21] <brson> should attach this to a global probably
[16:38:26] <jensnockert> sebcrozet: No, SIMD types would just share some code with those types.
[16:38:39] <dylukes> brson: where is it?
[16:38:40] <joelteon> so RecvPacketBuffered is the only Selectable thing right now, isn't it?
[16:38:46] <joelteon> is that supposed to represent a packet or an endpoint?
[16:38:51] *** Joins: Uther (Instantbir@moz-1B244B05.hfc.dyn.abo.bbox.fr)
[16:39:20] <sebcrozet> jensnockert: I see.
[16:39:30] <sebcrozet> jensnockert: thanks.
[16:39:55] *** Joins: mihneadb (mihneadb@E48845AB.3A9F9BD4.4C2245EF.IP)
[16:40:00] <jensnockert> sebcrozet: np.
[16:40:03] *** Quits: sk (sk@6A9E0928.E92B26F8.78DD174B.IP) (Input/output error)
[16:40:23] <sebcrozet> jensnockert: Is there anything I can follow on github so that I get fresh infos about simd implementation?
[16:41:01] <jensnockert> sebcrozet: Yeah, I'll find the bugs, and mine and sanxiyns rust repos.
[16:41:09] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[16:42:12] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[16:42:49] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Ping timeout)
[16:43:11] <jensnockert> sebcrozet: It is blocking on https://github.com/mozilla/rust/issues/7899.
[16:43:33] <brson> https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-08-06
[16:43:35] <jensnockert> So you should be able to follow those.
[16:44:30] *** Quits: chii (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[16:44:41] <sebcrozet> Great. Thanks both.
[16:45:11] *** Joins: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net)
[16:46:16] *** Joins: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com)
[16:46:29] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[16:47:45] <dylukes> So.... SharedChan is gone?...
[16:47:47] <brson> dylukes: std::comm::SharedChan
[16:47:51] <dylukes> Yeah its not working.
[16:47:53] *** Quits: dim-an (ermolovd@moz-A1FD62E4.yandex.net) (Ping timeout)
[16:47:58] <dylukes> "error: unresolved name `std::comm::SharedChan`."
[16:47:59] <brson> dylukes: SharedChan::new(chan)
[16:48:04] <brson> the ctor changed
[16:48:20] <dylukes> what's the proper syntax for multiple assignments in one let now?
[16:48:40] <cmr> let (a, b) = (1, 2)
[16:49:40] <maikklein2> btw are functors in haskell not called a "design pattern"?
[16:49:59] <maikklein2> because I alwas read that there are no patterns in functional langauges
[16:50:05] <maikklein2> which confuses me
[16:50:30] <Ms2ger> No, no, there's no design in functional languages
[16:50:31] * Ms2ger ducks
[16:50:43] <joelteon> that seems like a weird meaningless statement that people like to make maikklein2 
[16:50:45] <joelteon> they're pretty common
[16:50:56] <brson> bblum: hitting some failures and deadlocks related to linked failure. bench/task-perf-linked-failure deadlocks. one of the bots deadlocked last night (http://buildbot.rust-lang.org/builders/auto-mac-64-opt-vg/builds/774), and I've seen at least one spurious failure related to linked failure. can you investigate? I will also try to find something reproducable
[16:51:03] <kmc> I wouldn't call Functor a design pattern because it's actually a thing in a library
[16:51:09] <kmc> but there are many design patterns in Haskell
[16:51:12] <maikklein2> joelteon, do you know if there are books about it? I really want to learn some functional design patterns
[16:51:23] <joelteon> just write some code, mate
[16:51:27] <joelteon> you'll pick up the good ones
[16:51:47] <kmc> half of all "design patterns" in the world are standardized workarounds for language flaws and half of the remainder are common sense
[16:52:04] <Yoric> That's the thing. Functional programming actually makes it quite easy to turn most of your design patterns into libraries, so you don't call them design patterns, you call them libraries.
[16:52:04] <Yoric> Although I would say that a number of uses of Functors are design patterns.
[16:52:20] *** Joins: tchoma (tchoma@moz-BE33DA21.fw1.sfo1.mozilla.net)
[16:52:29] <Yoric> (e.g. functorizing maps to ensure safe equality checks in OCaml)
[16:52:35] <kmc> Haskell does have a fair number of standard workarounds for language flaws (or for unavoidable consequences of the language design)
[16:52:36] *** Quits: cypher (ircnet@moz-EA42E471.static.surfer.at) (Quit: Leaving...)
[16:52:59] *** Joins: Vert (quassel@moz-15870EF5.skybroadband.com)
[16:53:42] <mark_edward> hey is there a way to alias a use statement?
[16:53:51] <cmr> mark_edward: what do you mean?
[16:54:13] <mark_edward> something like pythin import VERYLONGNAME as shrt
[16:54:20] <cmr> use x shrt = verylongname
[16:54:26] <cmr> s/ x//
[16:54:31] *** Joins: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com)
[16:54:39] *** Quits: Vert (quassel@moz-15870EF5.skybroadband.com) (Ping timeout)
[16:54:51] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[16:54:58] *** Joins: Vert (quassel@moz-15870EF5.skybroadband.com)
[16:55:22] <maikklein2> like use mytask = std::task::*; ?
[16:55:37] <cmr> can't so it with glob imports
[16:55:44] <mark_edward> maikklein2: i think globs dont work with that
[16:55:47] <cmr> *do it
[16:55:49] <cmr> Or list imports
[16:55:55] <mark_edward> i mean "ditto cmr" :P
[16:56:01] <maikklein2> what are considered global imports?
[16:56:01] <erickt__> bblum: r? https://github.com/mozilla/rust/pull/8294
[16:56:04] <cmr> use foo::bar::baz is just sugar for use baz = foo::bar::Baz
[16:56:04] <maikklein2> extra and std?
[16:56:10] <mark_edward> maikklein2: i used it like this
[16:56:18] <joelteon> can you use just a function from a module?
[16:56:23] <mark_edward> maikklein2: use memset = std::ptr::copy_nonoverlapping_memory
[16:56:24] <cmr> joelteon: yes
[16:56:25] <dylukes> yeah
[16:56:26] <joelteon> the only way I know how to do it is use module::*
[16:56:28] <dylukes> I need a way to close channels.
[16:56:36] <dylukes> :\
[16:56:48] <dylukes> otherwise the iterator will never die...
[16:57:04] <dylukes> Just a .done() or .close() would be good.
[16:57:18] <erickt__> mark_edward: I think you mean memcpy, not memset :)
[16:58:34] *** erickt is now known as erickt_
[16:59:16] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[16:59:17] <dylukes> brson: should I file a bug report for this?
[16:59:54] <dylukes> for the moment I can just send an Option type instead of just int...
[17:00:10] <maikklein2> joelteon, you can just do "module::my_fn(1,2,3);"
[17:00:23] <cmr> maikklein2: no you can't, that's not how it works
[17:00:27] <maikklein2> ?
[17:00:29] <cmr> 1. wrong sytnax, 2. wrong semantics
[17:00:39] <cmr> use module::{my_fn1, my_fn2, my_fn3}
[17:00:47] *** Quits: StarLight (StarLight@moz-14366CBD.dynamic.avangarddsl.ru) (Ping timeout)
[17:00:51] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[17:00:52] <cmr> Everything in the list needs to be an ident exported by the module
[17:01:04] <cmr> it's not like bash brace expansion
[17:01:06] <maikklein2> is this special to functions?
[17:01:17] <cmr> no.
[17:01:18] <maikklein2> because I can do this with structs
[17:01:19] *** Joins: true_droid (true_droid@moz-123FD9B8.beck.volia.net)
[17:01:27] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[17:01:32] <cmr> maybe I'm confused by what you meant by (1,2,3)
[17:01:45] <maikklein2> i call the function in the module
[17:01:49] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[17:01:49] <mark_edward> erickt__: yeah, lol
[17:01:49] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[17:02:58] <cmr> oh right! function application
[17:03:00] <cmr> yes, ignore me
[17:03:13] <sully> hm... make check fails for me
[17:03:21] <sully> because of a codegen ratchet regressions
[17:03:32] <cmr> sully: good good, it's working
[17:03:39] <brson> dylukes: i haven't been following your travails, but can you let the channel go out of scope?
[17:03:53] <sully> ok, but I haven't changed anything!
[17:03:55] <dylukes> Say this is in a main function, or the channel is on the heap...
[17:04:11] <dylukes> Regardless, for a stream to be useful it has to be closable/errorable.
[17:04:21] <dylukes> These things can be bolted on after the fact with Result/Option types though
[17:04:56] *** Quits: orshem (orshem@C5E06B1E.A5B6B765.E3D28531.IP) (Quit: Leaving)
[17:05:12] *** Joins: StarLight (StarLight@moz-D04EF820.dynamic.avangarddsl.ru)
[17:05:25] <SimonSapin> r? https://github.com/mozilla/rust/pull/8231
[17:05:59] <dylukes> though here, I would have to write a new version of SharedChan that counts its clones and how many have been closed... it's not pretty.
[17:06:41] <dylukes> ah wait, here I think I got it.
[17:06:44] *** Joins: dim-an (ermolovd@moz-FE167E47.nationalcablenetworks.ru)
[17:07:05] <dylukes> I had the original Chan floating around. the clone and the original SharedChan are moved into tasks and deallocate properly :) 
[17:07:07] *** Joins: dmi3y (dmi3y@moz-2345EED7.pool.ukrtel.net)
[17:07:48] <toddaaro> brson: I wrote up the "live flag" + non-blocking event loop check in issue #8341
[17:07:55] <toddaaro> brson: let me know if you have questions on it
[17:08:06] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[17:08:06] *** ChanServ sets mode: +o tjc
[17:08:12] <brson> toddaaro: ok
[17:08:43] <toddaaro> brson: libuv does appear to provide the necessary functionality via the "mode" you pass to uv_run, previously you used DEFAULT and in this design we would use RUN_ONCE and NOWAIT depending on the situation
[17:08:58] <doomlord_> is there something to get an ast_node from (ty::ctxt, NodeId)
[17:09:04] <dylukes> okay well
[17:09:12] <dylukes> here's a totally contrived version of the first Project Euler problem.
[17:09:13] <dylukes> https://gist.github.com/DylanLukes/6166445
[17:10:16] *** Joins: jviereck (Adium@moz-1F0637E1.ethz.ch)
[17:10:42] <dylukes> there we go, much better now
[17:12:52] <maikklein2> dylukes, does this work? (**self)
[17:13:16] <cmr> yes
[17:13:23] <maikklein2> why two times **
[17:13:28] <maikklein2> there is only one &
[17:13:57] <cmr> The dereference operator on newtype structs access the thing the newtype is wrapping
[17:14:01] *** Quits: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com) (Ping timeout)
[17:14:19] <maikklein2> oh
[17:14:39] *** Joins: thomaslee (thomaslee@moz-6C3931E3.static.twtelecom.net)
[17:14:46] <kmc> I have some old code that does Â«use std::gc::rustrt;Â», does that module still exist and where is it?
[17:14:53] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[17:14:56] <cmr> kmc: no it was removed last week
[17:15:05] <maikklein2> i never use newtype structs
[17:15:14] <cmr> as well as all the rt bits that it reuqired
[17:15:17] *** Quits: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk) (Client exited)
[17:16:06] <cmr> oh I forgot to send twir to the ml
[17:16:13] <brson> toddaaro: why is it better to do the non-blocking call to run?
[17:16:24] <brson> hold on, let me read your issue
[17:16:37] <dylukes> I asked the same thing maikklein2 
[17:16:52] <dylukes> anyhow, that's a pretty contrived but functional solution it seems.
[17:19:22] <cmr> bstrie: do you know who rustcvswvi on reddit is?
[17:19:24] *** Joins: azakai (alon@moz-BBE3ABD.mv.mozilla.com)
[17:19:27] <bstrie> cmr: nope
[17:19:34] <bstrie> very mysterious
[17:19:54] <maikklein2> dylukes, do you have anyidea why it runs endless if you delete the second spawn?
[17:19:59] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[17:20:07] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[17:20:07] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/hbvHgw
[17:20:07] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[17:20:09] <maikklein2> dylukes, so that you don't send with the chan2
[17:21:27] <toddaaro> brson: wrote a spawn benchmark, 15 microseconds per right now
[17:21:41] <cmr> *cough* https://github.com/mozilla/rust/issues/7532
[17:21:47] *** cade is now known as cade_lunch
[17:21:49] <cmr> <3 if there are rt ones too
[17:21:53] <dylukes> maikklein2: no I fixed that
[17:21:55] <mark_edward> toddaaro: is that good or bad?
[17:22:05] <dylukes> the problem was I had let chan = SharedChan... then cloned both chan1 and chan2
[17:22:13] <toddaaro> mark_edward: no clue, hopefully it will get faster
[17:22:16] <dylukes> so chan1 and chan2 got moved into the spawned tasks and deallocated, but the original chan did not :)
[17:22:29] <mark_edward> toddaaro: do you know the statistic for Go?
[17:22:30] <cmr> toddaaro: do you know what it was on the old scheduler?
[17:22:47] <toddaaro> no and no
[17:22:50] <toddaaro> these would be good things to know
[17:23:07] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[17:23:07] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/cAKfHg
[17:23:07] <ghrust> 13rust/06auto 14fff59ed 15Simon Sapin: Add to_ascii_upper, to_ascii_lower and eq_ignore_ascii_case in std::ascii
[17:23:07] <ghrust> 13rust/06auto 1462ec4e5 15bors: auto merge of #8231 : SimonSapin/rust/ascii-upper-lower-case, r=cmr...
[17:23:08] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[17:23:08] *** Joins: jedisct1 (Mibbit@F4489DB3.9747582C.3464FAC3.IP)
[17:23:28] <mark_edward> doomlord_: pongo
[17:23:36] *** Joins: mschifer (Adium@moz-BBE3ABD.mv.mozilla.com)
[17:24:20] <doomlord_> hi
[17:24:27] <SimonSapin> thanks cmr
[17:24:29] <maikklein2> dylukes, hm I am amlost certain that this is a language bug
[17:24:45] <mark_edward> doomlord_: my keccak impl is correct for the empty string
[17:24:50] * mark_edward throws party
[17:25:05] <doomlord_> hehe :)
[17:25:11] <maikklein2> cmr, can you tests sth? https://gist.github.com/DylanLukes/6166445 do you know why the program doesn't terminate if you comment line 21 out?
[17:25:23] <mark_edward> 1 down, infinity to go!
[17:26:14] <bblum> erickt__: that's a nice merge node you've got in your pull request
[17:26:18] <bblum> erickt__: can you get rid of it maybe
[17:26:19] <dylukes> Is there a vec/set thing that preserves uniqueness?
[17:26:24] <dylukes> Like a mathematical set?
[17:26:39] <maikklein2> yes
[17:26:40] <pcwalton> type `std::iterator::Map<,ast::ident,ast::PathSegment,std::vec::ConsumeIterator<ast::ident>>` does not implement any method in scope named `push`
[17:26:46] * pcwalton thought he was looking at a C++ error message for a second
[17:26:53] <dylukes> maikklein2: where?
[17:27:00] <pcwalton> (I kid) :)
[17:27:08] <pcwalton> (although I did actually think it was C++)
[17:27:22] <mark_edward> pcwalton: nah it's still way clearer. i have't dealt with boost or written anything overly complex template wise, and that is so clear
[17:27:41] <mark_edward> compared to certain instantiation errors i've seen, where it lists everything it tried
[17:27:51] <maikklein2> dylukes, I think you want an hashset
[17:27:57] <dylukes> indeed
[17:28:24] *** Joins: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP)
[17:28:25] <SimonSapin> dylukes: http://static.rust-lang.org/doc/std/hashmap.html#struct-hashset
[17:28:28] <maikklein2> dylukes, std::hashmap::hashset
[17:28:35] <mark_edward> pcwalton: did the segmented stack thing ever get resolved?
[17:28:46] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[17:29:00] <pcwalton> not sure what you mean by segmented stack thing
[17:29:11] <maikklein2> btw is it true that if a program leaks memory the program becomes exploitable?
[17:29:30] *** Quits: dylukes (dylukes@moz-B100DB2B.home.otenet.gr) (Quit: Computer has gone to sleep.)
[17:29:42] <mark_edward> pcwalton: there was some big kerfluffle about what stack sizes programs should get, and performance, and whether they should be growable
[17:30:00] <kmc> maikklein2: not in general, unless you are talking about exploiting it to consume memory
[17:30:15] <pcwalton> mark_edward: in the new scheduler there is no stack growth
[17:30:27] <pcwalton> so probably the debate will resume when someone wants to try to add it :)
[17:30:39] <maikklein2> kmc, not sure but I think I read something on the irc here, I was just wondering
[17:30:40] *** Quits: blauken (blauken@moz-E7EA111C.clients.kiwiirc.com) (Quit: http://www.kiwiirc.com/ - A hand crafted IRC client)
[17:30:47] <mark_edward> pcwalton: what's the default stack size with std::task::spawn?
[17:30:55] <pcwalton> I think 4MB or something
[17:30:56] <pcwalton> it's huge
[17:30:59] <pcwalton> because rustc relies on it
[17:31:09] <pcwalton> it needs to be toned down but we're just trying to land the scheduler right now
[17:31:14] <mark_edward> i see
[17:31:29] <mark_edward> do you have an estimate for it landing?
[17:31:41] *** Quits: lhatsk (Adium@moz-3292591F.pool.mediaways.net) (Quit: Leaving.)
[17:32:02] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[17:32:02] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1462ec4e5 to 143dfb55a: 02http://git.io/N3iJvQ
[17:32:02] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[17:32:05] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[17:32:05] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/MBoN-Q
[17:32:05] <ghrust> 13rust/06auto 1447e82c8 15Ben Blum: (cleanup) Uncomment an assertion that now holds.
[17:32:05] <ghrust> 13rust/06auto 141f95bd7 15Ben Blum: Lazily initialize 'leaf node' taskgroups for unlinked spawns, for an apparent 11% speedup.
[17:32:06] <ghrust> 13rust/06auto 147208095 15bors: auto merge of #8317 : bblum/rust/fast-spawn-unlinked, r=brson...
[17:32:08] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[17:32:56] <pcwalton> mark_edward: asap.
[17:33:00] <pcwalton> brson has been trying.
[17:33:13] <mark_edward> wow, cool!
[17:33:23] <mark_edward> cmr: you have an early scoop for the next TWIR :)
[17:33:29] <jedisct1> Is there any HTTP server that works with Rust 0.8? Thought rusthttpserver would, but noppe :(
[17:33:47] <erickt_> bblum: yeah, I can get rid of the merge. It was just making my life a little simpler :)
[17:34:01] <cmr> jedisct1: rusthttpserver does, what problem are you having with it?
[17:34:04] *** Joins: lhatsk (Adium@moz-3292591F.pool.mediaways.net)
[17:34:15] *** Quits: lhatsk (Adium@moz-3292591F.pool.mediaways.net) (Quit: Leaving.)
[17:34:32] <jedisct1> It doesn't even compile
[17:34:39] <jedisct1> librusthttpserver/codegen/branchify.rs:28:24: 28:35 error: expected `;` or `}` after expression but found `next_branch` librusthttpserver/codegen/branchify.rs:28                 foreach next_branch in branch.children.mut_iter() {                                                                   ^~~~~~~~~~~ libc++abi.dylib: terminating with uncaught exception 
[17:34:44] <cmr> replace foreach with for
[17:34:48] <cmr> that change is only a few days old
[17:35:03] <brson> pcwalton: in my branch I've changed it back to 2MB and had rustc request 4MB
[17:35:07] <erickt_> bblum: It's going to take me a bit to get to as I'm bisecting a bug in https://github.com/mozilla/rust/pull/8296
[17:35:11] <brson> not that 2MB is great
[17:35:28] <jedisct1> librusthttpserver/codegen/status.rs:142:24: 145:32 error: type `std::option::Option<uint>` does not implement any method in scope named `get`
[17:35:48] <cmr> renamed to unwrap
[17:35:51] <cmr> even newer change
[17:36:01] <jedisct1> :)
[17:37:16] *** Quits: CarpNet (ac@moz-FD24B77.sohonet.co.uk) (Quit: Leaving)
[17:37:24] <jedisct1> server.rs:43:48: 43:67 error: mismatched types: expected `std::rt::io::net::ip::SocketAddr` but found `std::rt::io::net::ip::IpAddr` (expected struct std::rt::io::net::ip::SocketAddr but found enum std::rt::io::net::ip::IpAddr) server.rs:43         let mut optlistener = TcpListener::bind(config.bind_address);
[17:37:43] <cmr> *that* I don't know about
[17:38:12] <bblum> erickt_: OK
[17:39:56] *** Quits: maikklein2 (maik@moz-18E00DC1.dip0.t-ipconnect.de) (Ping timeout)
[17:42:30] <joelteon> how do you create a RecvPacketBuffered? is there some standardized way?
[17:44:25] <toddaaro> running these benchmarks I'm noticing that nearly 100% of the runtime is in kernel mode
[17:44:28] <toddaaro> is this expected?
[17:44:46] *** Quits: reyre (reyre@B2D8AB09.33EE9F8A.1139E686.IP) (Client exited)
[17:45:22] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Connection reset by peer)
[17:45:32] <toddaaro> for example, in a message microbench that makes a few pairs of ping-ponging tasks and has them each pingpong 10k messages (for 4 pairs on 8 "cores") I get 3m20s of kernel time and 4.4s of user time
[17:45:34] *** Quits: jviereck (Adium@moz-1F0637E1.ethz.ch) (Quit: Leaving.)
[17:45:42] <toddaaro> brson bblum : does this match what you expect?
[17:46:03] <bblum> that is not expected
[17:46:12] <toddaaro> ok, that is what I thought
[17:46:13] <bblum> see if you can figure out what system calls are used
[17:46:20] <toddaaro> what should I do to do that?
[17:46:23] <cmr> strace
[17:46:34] <bblum> strace won't give you perf numbers
[17:46:39] <bblum> i bet perf or gprof will
[17:46:42] <cmr> it'll give you a syscall list
[17:46:44] <joelteon> RecvPacketBuffered takes a *mut Packet<T> and I have NO idea what that's supposed to be
[17:46:48] <cmr> perf does yeah
[17:46:54] *** Quits: Mowah (Mowah@moz-436C35C5.cust.bredbandsbolaget.se) (Ping timeout)
[17:47:02] <bblum> joelteon: just use RUST_NEWRT=1 and use std::rt::select for no
[17:47:03] <bblum> w
[17:47:04] <toddaaro> ok, so I run perf and magic comes out?
[17:47:12] <cmr> perf record your_benchmark
[17:47:26] <cmr> `perf report` will then show an annotation of all functions run and time spent in each
[17:47:29] <brson> ecr: where was that big libuv macro you found yesterday?
[17:47:33] <bblum> joelteon: used to be you had to use a select macro to do it
[17:47:36] <cmr> (it's a sampling profile so there is some fuzz involved)
[17:47:41] <bblum> hmm i wonder if we can keep the select macro
[17:48:42] <toddaaro> cmr: k, thanks
[17:48:50] *** Quits: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net) (Quit: echristo)
[17:49:00] *** Quits: n0v (n0v@moz-690FFF9D.org) (Connection reset by peer)
[17:49:20] *** Joins: cypher (ircnet@moz-1D494DB3.vie.surfer.at)
[17:49:27] <tjc> sully: did you ever find a solution for that indentation problem in emacs?
[17:49:27] <joelteon> bblum: what is an instance of Select?
[17:49:31] <tjc> (you were having that problem, right?)
[17:49:33] <joelteon> heh, Port isn't
[17:49:35] *** Joins: n0v (n0v@moz-690FFF9D.org)
[17:49:55] <bblum> joelteon: std::comm::rt::Port is
[17:49:59] <joelteon> oh
[17:50:03] <joelteon> of course
[17:50:04] <sully> tjc: yes
[17:50:25] <joelteon> oh, I found it!
[17:50:27] <joelteon> std::rt::comm
[17:50:29] *** Joins: Mowah (Mowah@moz-436C35C5.cust.bredbandsbolaget.se)
[17:50:31] <bblum> where is nmatsakis? is he on PTO?
[17:50:36] <sully> tjc: doing (setq-default tab-width 4) in .emacs will do it
[17:50:41] <sully> bblum: yes
[17:50:42] <tjc> sully: oh, great, thanks
[17:50:54] <sully> tjc: if you don't want to do that across the board, though, you can just put it in a rust-mode-hook
[17:51:13] <tjc> sully: I don't edit anything else where it matters :-D
[17:51:54] <tjc> sweet, sweet indentation, it's so good to have you again
[17:52:35] <bblum> joelteon: oops yeah i misspelled rt::comm
[17:53:24] <cmr> I have a https://github.com/cmr/rustdoc_ng/blob/master/clean.rs#L74 and the Module that contains a lot of those, which in turn might contain some of those. Is it possible to write a generic function that takes any Item<T> and then putz about with the attrs without touching inner?
[17:53:25] <toddaaro> ok, looks like 70% of time is spent in _raw_spin_unlock_irqrestore
[17:53:34] <ecr> brson: libuv/src/unix/loop-watcher.c
[17:53:37] <toddaaro> and another 10% in __do_softirq
[17:53:40] <cmr> toddaaro: contended locks perhaps?
[17:53:54] <toddaaro> cmr: I'm mauling the work_queue we have that is just a queue in a lock
[17:53:58] <toddaaro> so that could be it
[17:54:12] <cmr> _raw_spin_unlock_irqrestore is part of the kernel spinlock api
[17:54:26] <toddaaro> do our exclusives exposed in the runtime do that?
[17:54:37] <toddaaro> or is libuv doing that behind the scenes?
[17:54:56] <cmr> I don't think the kernel exposes spinlocks to userspace, it probably just uses them in the futex implementation
[17:55:07] <cmr> futex being what drives mutexes and pthreads
[17:55:19] <toddaaro> ok, so it probably is the work queue contestation then
[17:55:21] *** Joins: reyre (reyre@B2D8AB09.33EE9F8A.1139E686.IP)
[17:55:31] <toddaaro> is there a good way to tell what lock is the one creating all those calls?
[17:55:37] *** Joins: brianm (brianm@moz-E7EE7321.ptr.us.xo.net)
[17:55:40] <mark_edward> what'd be the fastest way to set all elements of a vector to zero?
[17:55:46] <cmr> not with perf I don't thin
[17:55:48] <cmr> k
[17:55:52] <toddaaro> ok
[17:55:53] <sfackler> r? https://github.com/mozilla/rust/pull/8287 build failed the first time due to the get -> unwrap change
[17:55:55] <bblum> toddaaro: no
[17:56:03] <bblum> raw_spin_lock_irqwhatever is the kernel's stuff
[17:56:11] <bblum> that is not what pthread mutexes use
[17:56:22] <toddaaro> oh, in that case what would create a zillion uses of it?
[17:56:31] <Sergio965> Is there a way to implement something for all structs? Some like: impl <T: Struct> SomeTrait for T { } ?
[17:56:34] <bblum> that's also not the name of a system call
[17:56:34] <Sergio965> Something*
[17:56:44] <toddaaro> bblum: it is the symbol given by perf
[17:56:48] <bblum> well, it's wrong
[17:57:03] <cmr> perf just tells you where the ip is during a sample, it can't be wrong
[17:57:13] <toddaaro> "69.64%  stdtest-x86_64-  [kernel.kallsyms]                     [k] _raw_spin_unlock_irqrestore"
[17:57:15] <bblum> Sergio965: no, you may as well just say all types
[17:57:23] <brson> toddaaro: responded on the issue tracker
[17:57:26] <bblum> toddaaro: well, look a few frames up i guess?
[17:57:27] <toddaaro> brson: k
[17:58:00] <mark_edward> cmr: do you have a suggestion?
[17:58:00] <Sergio965> bblum: No. All structs share certain properties. For example, using reflection, I should be able to retrieve a list of the struct's field names, types, and values.
[17:58:05] <toddaaro> bblum: how?
[17:58:17] <cmr> mark_edward: creating a new vector or zeroing and existing one?
[17:58:22] <bblum> toddaaro: i dunno, figure out how to use the tool
[17:58:29] <mark_edward> cmr: zeroing an existing one
[17:58:37] *** Joins: mcpherrin (mimcpher@moz-21D6B3DE.csclub.uwaterloo.ca)
[17:58:42] <cmr> mark_edward: for x in vec.mut_iter() { *x = 0 }
[17:58:49] <cmr> is the safe way
[17:58:52] <cmr> should be optimized quite well
[17:58:57] <SimonSapin> oh noes
[17:59:03] <SimonSapin> did foreach become for already?
[17:59:10] <mark_edward> SimonSapin: yup
[17:59:10] <cmr> bblum: pthreads use futexes which use spinlocks
[17:59:15] <cmr> (in the contended case)
[17:59:20] <bblum> Sergio965: we... don't have that sort of reflection
[17:59:38] <cmr> bblum: sure we do! how do you think fmt! works?
[17:59:45] *** Joins: rusti (rusti@moz-61B073BC.cpe.net.cable.rogers.com)
[17:59:45] <bblum> oh hm
[17:59:53] <bblum> hmm, maybe
[17:59:56] <cmr> it's messy as all hell, but we do have it
[18:00:10] <bblum> i guess i oculd see getting a list of the struct's innards
[18:00:11] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[18:00:12] <graydon> nothing a little polish wouldn't address
[18:00:13] <jedisct1> I'm still very new to Rust, working on a small project to get more familiar with it. But what is the best way to track changes? Is watching the git log the only way, or is there something else I can refer to, especially to see what has changed since 0.7?
[18:00:29] <cmr> jedisct1: http://cmr.github.io/blog/categories/this-week-in-rust/
[18:00:34] <bblum> we still aren't able to manipulate values based on reflected-upon data though
[18:00:45] <cmr> graydon: yup
[18:00:49] <jedisct1> cmr: thanks!
[18:00:50] <cmr> std::reflect is in a sad state
[18:00:59] <bblum> cmr: hmm, you have a point
[18:01:10] <bblum> i bet it will end up being the mutex protected workqueue after all
[18:01:41] * cmr knew all that time wasted prodding at the kernel would pay off one day
[18:02:17] <bblum> cmr: but wait, are you telling me that when a pthread mutex is contended, it *spins in kernel space*?
[18:02:23] <Sergio965> Are the names of struct fields stored in memory like the names of enums?
[18:02:37] <cmr> bblum: not always, but it can
[18:02:54] <bblum> oh you mean a spinlock protects something else that the kernel uses, like a little-lock
[18:02:59] <bblum> cmr: also, explain the fact that it was spin_unlock rather than spin_lock
[18:03:11] <cmr> bblum: I'd have to go look at the source again but it does some clever hash thing, and the spinlock is used to protect the buckets
[18:03:19] <Sergio965> What reflection is there currently in Rust?
[18:03:36] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[18:03:37] <toddaaro> cmr: what buckets are spinlock protected?
[18:03:40] <bblum> cmr: per-process buckets?
[18:03:49] * cmr goes to look
[18:05:24] *** Joins: chii (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP)
[18:07:10] <bstrie> so brson is trying to enable the new scheduler right now, does that also mean that std::io is getting replaced right now?
[18:07:21] <joelteon> it looks that way
[18:07:23] <bblum> bstrie: yes
[18:07:31] <joelteon> so we should, one day, be able to make a port/chan pair of a tcpstream, right?
[18:07:31] <bstrie> huzzah
[18:07:35] *** Joins: leaper (Mibbit@894D2C62.9F275360.C28326FD.IP)
[18:07:40] <bstrie> does newio use &trait rather than @trait?
[18:07:59] <bstrie> which is to say, can I finally stop commenting out io in benchmarks?
[18:08:00] <cmr> toddaaro: do you have a benchmark I can use?
[18:08:06] <leaper> is there a way to tell rust to output llvm ir than bitcode?
[18:08:16] <bstrie> leaper: rustc --emit--llvm
[18:08:21] <bstrie> I think
[18:08:22] <toddaaro> cmr: hm, I can push my current code a fork
[18:08:22] <cmr> leaper: rustc --emit-llvm [-S]
[18:08:31] <bstrie> cmr: what's the -S do
[18:08:36] <cmr> bstrie: IR instead of bitcode
[18:08:36] <toddaaro> though I found out how to make a graph with perf, and it looks like libuv callbacks run in kernel space
[18:08:39] <graydon> bstrie: not yet, no
[18:08:44] <toddaaro> so "running the program" counts as kernel space
[18:09:08] <graydon> bstrie: std::io hasn't seen work yet. The plumbing is still wip.
[18:09:08] <toddaaro> though maybe I'm interpreting this backwards
[18:09:14] <leaper> cmr: that worked perfectly..thanx
[18:09:23] <leaper> *thanks
[18:09:34] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[18:10:04] <graydon> bblum: why wouldn't you be able to manipulate data based on reflection?
[18:10:05] <sully> graydon: the current master is failing make check for me with a ratchet error; is this happening for everyeone?
[18:10:19] <sully> oh, hm. I have debug spew enabled.
[18:10:21] * sully experiements
[18:10:50] <toddaaro> cmr: if you really want to dive in I have a branch named "ws" on my rust fork at github.com/toddaaro/rust, and the tests I'm running are the ones that look like benchmarks at the bottom of sched.rs
[18:10:58] *** cade_lunch is now known as cade
[18:11:13] <bblum> graydon: i mean like struct.set_field(struct.list_fields()[2], 9999)
[18:11:36] <graydon> bblum: nothing preventing it aside from high level APIs. the machinery's lying around.
[18:11:44] <bblum> graydon: i am also led to believe that it's a privacy nightmare in java, but i don't know why exactly
[18:12:22] <graydon> bblum: in java they tried to use visibility and other language-level mechanisms (stack walking, security tokens, classloaders) as a security system.
[18:12:28] <brson> bblum: not sure if you got my message earlier, but I need you to investigate linked failure deadlocks and non-deterministic failures. bench/task-perf-linked-failure deadlocks, and doc-tutorial/handling_task_failure_5 deadlocks non-deterministically. I've also seen another non-determisitic linked-failure failure somewhere else that i haven't pinned down
[18:12:36] *** Quits: thesnowdog (doug@94FEF15E.9D0B7490.6F17036B.IP) (Ping timeout)
[18:12:51] *** Joins: thesnowdog (doug@94FEF15E.9D0B7490.6F17036B.IP)
[18:13:01] <bblum> brson: alright
[18:13:14] <kimundi> sebcrozet: message from the past: yes, inlining works for generics, but it only works cross crate if you add #[inline] hints
[18:13:20] <brson> the doc test can be generated with `make check-stage1-doc-tutorial` and run with `for i in {0..100000}; do x86_64-unknown-linux-gnu/test/doc-tutorial-tasks/handling_task_failure_5.stage1-x86_64-unknown-linux-gnu || break; done`
[18:13:38] <brson> plus the newrt has to be turned on
[18:14:01] <cmr> toddaaro: would using the stage1 compiler be fine?
[18:14:01] <bblum> right
[18:14:05] <graydon> bblum: rust's official stance is "language is not a security system". at absolute most I'd say we'd put visibility-breaking in the 'unsafe' category. but even that seems to me to be a stretch.
[18:14:30] <cmr> It's certainly inadvisable.
[18:14:41] <joelteon> will there one day be a Select implementation for TcpStream?
[18:14:54] <toddaaro> cmr: I think so, I've been running "make check-stage0-std" to get the test executables
[18:15:00] <bblum> graydon: hmm, stuff like RWArc relies on visibility to keep its interface safe
[18:15:01] <cmr> toddaaro: ok
[18:15:13] <sebcrozet> kimundi: Yes thatâ€™s what I guessed. Since the lack of inlining for f64 was due to missing #[inline] hints.
[18:16:19] <graydon> bblum: assuming you don't say "unsafe { ... break the world ... }"
[18:16:37] <sebcrozet> kimundi: thanks for validating my understanding :)
[18:16:38] <joelteon> or that might not be the best idea
[18:16:38] <toddaaro> ok, so the "source" of the calls is what this perf graph shows, and 96.66% of this spin_unlock stuff is coming from "extract_buf", now I'm looking into what exactly that is
[18:16:46] <joelteon> because I'd both need to select forever on the socket, and be able to write to it whenever I wanted
[18:16:52] <joelteon> and that would necessitate two threads having access to it
[18:16:58] <joelteon> and that's a no-no
[18:17:28] <toddaaro> oh wow, extract_buf is part of the random number generator
[18:17:50] <cmr> Are you spawning lots of tasks in a tight loop? Those each make their own rng don't they?
[18:18:06] <toddaaro> yea, I sort of assumed rng was "free"
[18:18:08] *** Quits: reyre (reyre@B2D8AB09.33EE9F8A.1139E686.IP) (Quit: Konversation terminated!)
[18:18:12] <joelteon> or maybe I could use extra::arc
[18:18:18] *** Joins: Zanpo (Mibbit@moz-62AF0EAB.net.uwaterloo.ca)
[18:18:24] <graydon> bblum: I guess if you or others feel strongly about it, we can make reflection.priv_fields() unsafe
[18:18:36] <cmr> graydon: strcat has strong feelings about it
[18:18:45] <toddaaro> I'm building a new rng *every time I try to steal tasks*
[18:18:54] <toddaaro> so if that is slow no wonder
[18:18:57] <graydon> bblum: I don't think it's necessary to go further than that in hiding or making-impossible things that would otherwise plainly be possible using unsafe { ... } and sufficient levels of ruthlessness.
[18:19:20] <toddaaro> what is an efficient way to get "I don't care at all if this is actually random" random integers that are small?
[18:19:29] <toddaaro> (0-128 or so)
[18:20:37] <graydon> bblum: ok, I'll talk to him about it when he returns.
[18:21:36] <bstrie> toddaaro: see the custom rng implemented in https://github.com/logicchains/levgen-benchmarks/blob/master/R.rs
[18:21:43] <bstrie> it's very simple
[18:21:56] <cmr>  seed = 6364136223846793005ULL*seed + 1;
[18:21:57] <cmr>  return seed>>33;
[18:22:00] <cmr> That is what musl-libc does
[18:23:01] <ecr> I suggested grabbing a random seed when a scheduler is created and then just using an internal pseudorandom generator from that
[18:23:27] <toddaaro> ok, how does this weird thing work? do you just get garbage in the register after shifting that much?
[18:23:48] <cmr> Oh it's a u64
[18:23:51] <toddaaro> bstrie: I have no clue how your thing works, but it looks super simple
[18:23:55] <bblum> graydon: yeah, just making priv_fields be unsafe would satisfy me
[18:23:57] <cmr> probably an important detail :p
[18:24:04] <cmr> the seed is, that is
[18:24:08] <cmr> it returns a u32
[18:24:10] <cmr> i32 really
[18:24:22] <bblum> graydon: or perhaps whatever equivalent would allow you to write to those fields
[18:24:47] <bblum> but i do feel strongly that privacy/visibility are part of the toolkit that rust offers for implementing safe interfaces with unsafe stuff under the hood
[18:25:03] <kmc> after upgrading Rust, I'm getting "error: cannot determine a type for this bounded type parameter: unconstrained type" on code that used to work
[18:25:08] <kmc> any idea what the specific language change was?
[18:25:10] <graydon> bblum: mhm. assuming -- as I think is fair -- that a dedicated attacker running code on the same machine as you can infer the contents of anything they want. but you're right, modifying might be a little much without unsafe { ... }
[18:25:21] <cmr> kmc: code that used to work when?
[18:25:32] <kmc> ~1 month ago version (I can find the exact commit if desired)
[18:25:37] <cmr> ok
[18:25:40] <cmr> no that's fine
[18:25:45] <kmc> it's on this impl https://github.com/mozilla/servo/blob/master/src/components/util/tree.rs#L88
[18:26:00] <kmc> which is kind of a weird situation that would probably want associated types if we had them
[18:26:05] *** Quits: slartoff (Mibbit@CDEB6BFF.D3A46DCA.B1AF74A1.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[18:28:19] <kmc> I guess the problem is that N is unconstrained because theoretically there could be multiple impls of TreeNode<NR>, even though that doesn't make sense
[18:28:40] <kmc> and this is the problem that fundeps solve in Haskell, but ass-types solve it in a nicer way
[18:28:50] <Ms2ger> ass-types?
[18:28:53] <kmc> but right now I just want to figure out why it used to work and see if I can trick Rust into letting it work again :)
[18:29:42] <kmc> Ms2ger: associated types; imagine like  trait Container { type Elem; fn index(i: uint) -> Elem }
[18:30:00] <ecr> can you write a binary number in rust?
[18:30:01] <kmc> then you could have  impl<T> Container for ~[T] { type Elem = T; ... }
[18:30:10] <cmr> rusti: 10101b
[18:30:11] -rusti- <anon>:5:14: 5:15 error: expected `;` or `}` after expression but found `b`
[18:30:12] -rusti- <anon>:5          10101b
[18:30:12] -rusti-                        ^
[18:30:12] -rusti- application terminated with error code 101
[18:30:17] <cmr> rusti: 0b10101
[18:30:19] <kmc> but also things like impl Container for str { type Elem = char; ... }
[18:30:19] -rusti- 21
[18:30:31] <ecr> thanks
[18:30:45] <Ms2ger> 0b10101u32?
[18:31:26] <ecr> rusti: 0b10101u32
[18:31:27] -rusti- 21
[18:32:13] <joelteon> wait
[18:32:22] <joelteon> so does select() return whether or not there's data available?
[18:32:50] <bstrie> I think the idea of select is that it blocks until there's data available
[18:32:56] <kmc> rusti: 0b1111_0000_1111_0000_u32
[18:32:56] -rusti- 61680
[18:32:57] *** Quits: leaper (Mibbit@894D2C62.9F275360.C28326FD.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[18:32:57] <joelteon> yeah, that's what I thought
[18:33:13] <joelteon> but it returns if one of the channels is closed, and I don't know how the channel would have gotten closed
[18:33:19] <kmc> rusti: 0x4D_AF_5F_1E_95
[18:33:20] -rusti- 333654728341
[18:33:47] <joelteon> it seems like the channel is just closing once I'm done sending data through it
[18:33:54] <joelteon> I thought you had to close them manually
[18:34:37] <bblum> brson: ok, this task-perf-linked-failure test case is deadlocking because it was written before task::spawn meant spawn_watched
[18:35:25] <cmr> toddaaro: http://octayn.net/benches/perf.svg
[18:36:03] *** Quits: maxli (maxli@13F2CEC5.7672369.D8E68FF6.IP) (Quit: Leaving.)
[18:36:08] *** Joins: maxli (maxli@13F2CEC5.7672369.D8E68FF6.IP)
[18:36:08] *** Quits: Sergio965 (sergiobz@moz-8D70E596.wireless.csail.mit.edu) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[18:36:12] <toddaaro> cmr: wow how do you make those!
[18:36:16] <sp3d> mmm, flamegraphs
[18:36:18] <cmr> Looks like what, 80-90% is in the rng?
[18:36:21] <cmr> toddaaro: lovingly, by hand
[18:36:25] <bblum> brson: it is fixed with this diff - http://pastebin.mozilla.org/2796197
[18:36:29] <cmr> http://dtrace.org/blogs/brendan/2012/03/17/linux-kernel-performance-flame-graphs/
[18:36:51] <toddaaro> cmr: yea, I had no idea rng the way I was doing it wasn't free
[18:37:03] <toddaaro> cmr: so I guess mega-perf win is about to happen
[18:37:27] <cmr> toddaaro: I'm not familiar with schedulers at all but what do you need a random number for?
[18:37:54] <toddaaro> cmr: to pick a scheduler to steal from, usual strategy is just pick one at random
[18:38:01] <cmr> ah
[18:38:03] <toddaaro> "random" being "don't do the same thing too much"
[18:38:19] <cmr> rust's default rng is probably far too sophisticated for that simple requirement, yeah
[18:38:24] <cmr> it's a strong prng iirc
[18:38:26] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Quit: Lost terminal)
[18:38:29] <toddaaro> so urandom is so overkill I don't even have the words, I'm working on getting a really silly fast function in place
[18:38:41] <toddaaro> http://en.wikipedia.org/wiki/Linear_congruential_generator
[18:38:54] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[18:38:54] *** ChanServ sets mode: +o brson
[18:38:54] <toddaaro> cmr: thanks a ton for that flame graph, I'm going to have to start doing that all the time
[18:39:10] <bstrie> toddaaro: fastest rng imaginable: fn random() -> int { return 4; }
[18:39:21] <brson> bblum: what's going wrong in the test case?
[18:39:46] <toddaaro> bstrie: that would be pretty fast
[18:39:47] <Ms2ger> Guaranteed random by a fair dice roll?
[18:39:49] <Seldaek> toddaaro: I guess that or mersenne twister should help
[18:40:04] *** Quits: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Ping timeout)
[18:40:06] <kmc> mersenne twister is good
[18:40:18] <kmc> MWC256 here http://forums.wolfram.com/mathgroup/archive/2003/Feb/msg00456.html is another nice fast RNG
[18:40:28] <toddaaro> my requirements are so low I could just hardcode a list of random integers about 30 long and cycle it
[18:40:41] <kmc> but if you don't need super speed then I think reading urandom is fine too
[18:41:01] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[18:41:06] *** Joins: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[18:41:11] <kmc> I get like 15 MB/s from it
[18:41:29] <kmc> it may be "overkill" quality-wise but is that actually bad
[18:41:49] <cmr> kmc: in performance sensitive non-random-required code? probably
[18:41:53] <Seldaek> toddaaro: what are you doing (I missed the beginning I think)
[18:42:06] <cmr> a context switch just for a random number isn't that great
[18:42:21] <kmc> presumably the IO is buffered
[18:42:29] <toddaaro> Seldaek: picking what queue a workstealing scheduler steals from, I naively used Rust's default RNG and ended up with code that spends 90% of the runtime in kernel rng
[18:42:35] <bblum> brson: so the test spawns a "middle" descendant taskgroup which spawns a "grandchild" descendant taskgroup. the middle task then exits early, and the grandchild spawns a bunch of linked tasks which block forever, and then also exits early;
[18:42:44] <kmc> so you only context switch occasionally
[18:42:52] <pcwalton> use xorshift
[18:42:53] <kmc> like I said, 15 MB/s
[18:42:57] <cmr> kmc: and, it's slow right now *because* the prng is seeded from urandom
[18:42:58] <bblum> brson: the original task waits for this early  exit, then fails, hoping to kill all of the blocking-forever tasks with its failure
[18:43:04] <sully> ok, so, I disabled debug spew, and I still fail ratchet tests
[18:43:06] <cmr> kmc: so, reading from urandom is too slow
[18:43:11] <kmc> o
[18:43:12] <kmc> k
[18:43:22] <Seldaek> toddaaro: oh I see :) yeah that indeed doesn't sound like something you need safe randomness for, then again I'm sure many people said that and it came back to haunt them ;)
[18:43:23] <bblum> brson: but because of spawn_watched, the grandchild's early-exit is actually not so much with the exiting and more with the waiting for its linked children.
[18:43:28] <kmc> I may have missed the context, toddaaro said their requirements were low but maybe that doesn't include speed
[18:43:30] <pcwalton> just use a static mut seed for the RNG
[18:43:38] <pcwalton> and unsafe race on it
[18:43:41] <pcwalton> doesn't matter :)
[18:43:54] <toddaaro> kmc: oh, yea randomness requirements are low speed is ridiculously important
[18:43:58] <kmc> ah I see
[18:44:07] *** Quits: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Ping timeout)
[18:44:15] <toddaaro> ideally a handful of instructions, which it looks like some of these simple psudorandom generators are
[18:44:15] <bstrie> fn is_zero(&self) -> bool { true }
[18:44:21] <kmc> yep
[18:44:24] <bstrie> amusingly, this is not inlined
[18:44:27] <kmc> also on Ivy Bridge you could use RDRAND :)
[18:44:32] <bstrie> this is from the impl Zero for ()
[18:44:49] <kmc> seems to push about 500 - 800 MB/s
[18:46:26] *** Quits: cdidd (cdidd@moz-9CDAEB16.broadband.corbina.ru) (Input/output error)
[18:48:00] <toddaaro> brson bblum looks like I'm still at 70% in rng, as try_recv is using it somehow
[18:48:13] <toddaaro> know what in there does? I'm not seeing it
[18:48:19] <bblum> you're in rng now?
[18:48:26] <brson> bblum: i see, thanks
[18:48:32] <toddaaro> oh there it is, two impls of something
[18:48:48] <toddaaro> so it looks like every single receive in the runtime goings through urandom rng
[18:49:05] <mark_edward> rusti: let res = [0u8, ..20]; for &b in res.iter() { printf!("%01x", b as uint); }
[18:49:05] -rusti- 00000000000000000000()
[18:49:08] <toddaaro> at least when you are in #[cfg(test)]
[18:49:10] <bblum> toddaaro: uh yeah, that should only be in test builds
[18:49:15] <cmr> bblum: the spinlock was from getting entropy for urandom fwiw
[18:49:22] <toddaaro> bblum: ok why is this
[18:49:26] *** Joins: cdidd (cdidd@moz-9F1ECBB7.broadband.corbina.ru)
[18:49:28] <cmr> not the lock at all
[18:49:37] <bblum> toddaaro: look at the comments in optimistic_check()
[18:49:42] <joelteon> "type `std::rand::IsaacRng` does not implement any method in scope named `gen_uint_range`" wat
[18:49:52] <cmr> joelteon: std::rand::RngUtil isn't in scope
[18:50:07] <Seldaek> cmr: see, it weirds out everyone :p
[18:50:16] <toddaaro> bblum: ok, this has to change
[18:50:24] <cmr> it should be in the prelude probably
[18:50:38] <toddaaro> bblum: it can't be implemented this way, as the current check is ~70% of program runtime
[18:50:42] <toddaaro> bblum: which ruins the benches
[18:50:53] *** Joins: reyre (reyre@B2D8AB09.33EE9F8A.1139E686.IP)
[18:50:55] <bblum> oh the benches run under cfg test do they
[18:51:08] *** ozten is now known as ozten|lunchify
[18:51:09] <toddaaro> bblum: for now I'll comment it out, but I guess we need to implement more of the psedorandom stuff for this
[18:51:21] <bblum> ok, well, it doesn't need to be truly using a strong random number generator or anything
[18:51:29] <toddaaro> yea, we just need a library I suppose
[18:51:36] <bblum> do we have a fast PRNG?
[18:51:37] <cmr> xorshift *is* fast
[18:51:43] <cmr> just gotta use it instead of isaac
[18:51:49] <toddaaro> oh, is it already in the library?
[18:51:59] <cmr> yes, std::rand::XorShiftRng
[18:52:08] <bblum> great, thank you cmr
[18:52:16] <bblum> toddaaro: please change it to that  :P
[18:52:25] <cmr> has 128 bits of state, so it's easy to stash into tls if you need to keep the seed around
[18:52:34] <toddaaro> how is an XorShiftRng initialized?
[18:52:44] <cmr> ::new() or ::new_seeded()
[18:52:44] *** Joins: echristo (echristo@DCF57675.D6CCE4AE.77834EAA.IP)
[18:52:45] <toddaaro> we currently build one at each check and use it once then toss it
[18:53:25] <toddaaro> in the sched I hacked a "random_seed" field into the struct for pseudo random numbers to use as the running seed, but we don't really have anything here
[18:54:06] <toddaaro> I'll have to think about this, likely the correct answer is that the scheduler provides an rng via XorShiftRng accessible through TLS
[18:54:11] <toddaaro> well, or tasks
[18:54:15] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[18:54:21] <bblum> yeah that sounds like a decent approach
[18:54:30] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[18:54:32] <bblum> although i mean
[18:54:37] <bblum> what  other demand is there for such a service?
[18:54:48] <mark_edward> cmr: i have something like that last mssage i sent to rusti in my code, and i think it's not printing zeroes. because my hash output is correct in every way except for the missing zeroes
[18:54:50] <toddaaro> "anything that wants fast random numbers"
[18:54:52] <toddaaro> should be a big set
[18:54:58] <mark_edward> cmr:which seems etrememly unlikely
[18:55:12] *** Quits: chii (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[18:55:17] <bstrie> rusti: range(10, 9)
[18:55:19] -rusti- {state: 10, stop: 9, one: 1}
[18:55:30] <bblum> one: 1.
[18:55:44] <bblum> toddaaro: how big is it actually today
[18:55:58] <bblum> oh or do you mean outside the scheduler
[18:56:06] <bblum> yeah i think the old runtime had a "task RNG"
[18:56:13] <cmr> the new one doesn't?
[18:56:38] <bstrie> rusti: range_step(0, 10, 2)
[18:56:41] -rusti- <anon>:5:9: 5:19 error: unresolved name `range_step`.
[18:56:41] -rusti- <anon>:5          range_step(0, 10, 2)
[18:56:41] -rusti-                   ^~~~~~~~~~
[18:56:41] -rusti- error: aborting due to previous error
[18:56:41] -rusti- application terminated with error code 101
[18:57:13] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Quit: WeeChat 0.4.1)
[18:57:14] *** Joins: samx (sami@moz-48EC0983.dyn.optonline.net)
[18:57:16] <bstrie> rusti: for i in range(0, 10).skip(2) { printf!(i); }
[18:57:16] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[18:57:18] -rusti- 23456789()
[18:57:30] <engla> reverse ranges, range_step etc are not implemented yet I think
[18:57:46] <bstrie> rusti: for i in range(0, 5).reverse() { printf!(i); }
[18:57:47] -rusti- <anon>:5:18: 5:41 error: type `std::iterator::Range<int>` does not implement any method in scope named `reverse`
[18:57:47] -rusti- <anon>:5          for i in range(0, 5).reverse() { printf!(i); }
[18:57:47] -rusti-                            ^~~~~~~~~~~~~~~~~~~~~~~
[18:57:48] -rusti- error: aborting due to previous error
[18:57:48] -rusti- application terminated with error code 101
[18:57:53] <bstrie> rusti: for i in range(0, 5).rev() { printf!(i); }
[18:57:54] -rusti- <anon>:5:18: 5:37 error: type `std::iterator::Range<int>` does not implement any method in scope named `rev`
[18:57:54] -rusti- <anon>:5          for i in range(0, 5).rev() { printf!(i); }
[18:57:55] -rusti-                            ^~~~~~~~~~~~~~~~~~~
[18:57:55] -rusti- error: aborting due to previous error
[18:57:55] *** concrete.mozilla.org sets mode: +M 
[18:57:57] -rusti- application terminated with error code 101
[18:58:01] <cmr> it's .invert
[18:58:07] <bstrie> rusti: for i in range(0, 5).invert() { printf!(i); }
[18:58:09] -rusti- <anon>:5:18: 5:40 error: failed to find an implementation of trait std::iterator::DoubleEndedIterator<<V298>> for std::iterator::Range<int>
[18:58:09] -rusti- <anon>:5          for i in range(0, 5).invert() { printf!(i); }
[18:58:09] -rusti-                            ^~~~~~~~~~~~~~~~~~~~~~
[18:58:09] -rusti- application terminated with error code 101
[18:58:11] <cmr> if it implements it
[18:58:13] <cmr> yeah
[18:58:33] <bstrie> can you use an adaptor to implement range_step right now?
[18:59:16] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Ping timeout)
[18:59:16] <bstrie> I realize that it's trivial to implement just a range_step function, you can even reuse the current Range struct (maybe rename `one` to `step`)
[18:59:27] <bstrie> but I'm curious if there's something like a repeated skip()
[19:00:18] <cmr> skiperator
[19:00:32] <toddaaro> oh wow this is faster now
[19:01:08] <bstrie> rusti: for i in range(0,5).take_() { printf!(i); }
[19:01:09] -rusti- <anon>:5:18: 5:38 error: this function takes 1 parameter but 0 parameters were supplied
[19:01:09] -rusti- <anon>:5          for i in range(0,5).take_() { printf!(i); }
[19:01:10] -rusti-                            ^~~~~~~~~~~~~~~~~~~~
[19:01:10] -rusti- error: aborting due to previous error
[19:01:10] -rusti- application terminated with error code 101
[19:01:41] <bstrie> rusti: for i in range(0,5).take_(2) { printf!(i); }
[19:01:41] -rusti- 01()
[19:01:50] <bstrie> ok, so take is just the opposite of skip
[19:02:39] <cmr> Some of you might be interested in this: https://www.youtube.com/watch?v=QGw-cy0ylCc
[19:02:54] *** concrete.mozilla.org sets mode: -M 
[19:03:06] <engla> yay +M expired
[19:03:21] <engla> bstrie: no convenient way to implement a skip I guess
[19:03:30] <Ms2ger> engla, quick, spam some more
[19:03:48] <mark_edward> cmr: I saw that! very interesting my first real job had me dealing with cpu architectures and stuff. although im no electrical engineer
[19:03:50] <engla> it would be dumb to censor myself
[19:04:13] <bblum> SIGH. make check-stage1-doc-tutorial built a version of llvm that refuses to link, and when i go to just 'make', it's deciding that it needs to build LLVM again
[19:04:15] <Ms2ger> You're not registered?
[19:04:16] <engla> bstrie: I guess you just have the hard task of finding a name for such an adaptor, then just implement it
[19:04:51] <Seldaek> cmr: I have no idea what it's about, but I'm glad I read the two top comments :p
[19:06:08] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Ping timeout)
[19:06:16] *** ozten|lunchify is now known as ozten
[19:06:59] <toddaaro> ok, with this rng stuff message sends went from ~3ms to 1.2 us
[19:07:17] * cmr whistles
[19:07:45] <Seldaek> hehe, nice
[19:07:48] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[19:07:48] *** ChanServ sets mode: +o dherman
[19:08:37] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[19:08:37] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/MBoN-Q
[19:08:37] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[19:09:29] <bblum> brson: i would love to have an answer for you about the tutorial test case, but i find myself rebuilding llvm. could you pastebin the test or something?
[19:09:33] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Ping timeout)
[19:09:54] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[19:09:54] *** ChanServ sets mode: +o dherman
[19:10:19] <pcwalton> hmm, is there a way to flatten a vector of vectors?
[19:10:29] <sully> hm, should be
[19:10:39] <pcwalton> or an iterator over vectors
[19:10:43] <bblum> fn concat
[19:10:53] <pcwalton> I have an iterator over vectors actually
[19:11:07] <engla> pcwalton: iterators have .flat_map_ too
[19:11:10] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[19:11:11] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/CdtsYQ
[19:11:11] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[19:11:30] <mark_edward> pcwalton: a combination of folding and the chain iterator thngy?
[19:11:33] <engla> it.flat_map_(|vec| vec.consume_iter()).to_owned_vec() ?
[19:11:57] <engla> now.. consume_iter isn't that efficient
[19:12:02] <engla> concat is probably better
[19:12:34] <brson> bblum: here's the doc test https://gist.github.com/brson/6167610
[19:13:01] <bblum> brson: thank you
[19:13:07] <bblum> most likely it's the use of task::yield
[19:13:16] *** Quits: rusti (rusti@moz-61B073BC.cpe.net.cable.rogers.com) (Ping timeout)
[19:13:37] *** Joins: rusti (rusti@moz-61B073BC.cpe.net.cable.rogers.com)
[19:14:09] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[19:14:09] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/CdtsYQ
[19:14:09] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[19:14:09] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[19:14:10] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/6a93YA
[19:14:10] <ghrust> 13rust/06auto 14d5de801 15Alex Crichton: Re-enable rusti tests
[19:14:10] <ghrust> 13rust/06auto 146972eb4 15bors: auto merge of #8321 : alexcrichton/rust/enable-rusti, r=cmr...
[19:14:10] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[19:14:52] <SimonSapin> Any idea what this means? http://pastebin.mozilla.org/2796388
[19:14:58] <toddaaro> ok, so newrt does ~150k messages per second per core using streams
[19:16:18] <toddaaro> so we are competitive with akka on that front, maybe faster, as they are a "high level" library doing 20 messages before each context switch to get 1m per core per second, while we do a context swap each message
[19:17:04] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Ping timeout)
[19:17:18] <bblum> brson: you say this one is a nondeterminstic hang? with RUST_THREADS=1 it hangs because "loop { task::yield() }" is equivalent to "loop { }"
[19:17:34] *** kimundi is now known as zz_kimundi
[19:17:37] <cmr> toddaaro: is this on your ws branch?
[19:17:58] <toddaaro> cmr: yea
[19:18:04] <bblum> however, i also have gotten it to *segfault*...
[19:18:10] <toddaaro> I need to run that test on master now to see how it compares
[19:18:36] <cmr> toddaaro: I don't think you pushed your changes
[19:18:52] <toddaaro> oh, good point
[19:19:36] <mark_edward> is there any reason why a statement like this: printf!("%1x", b as uint); where b: u8 would fail to print zeroes?
[19:19:48] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[19:19:48] *** ChanServ sets mode: +o dherman
[19:20:12] <toddaaro> cmr: I pushed, the benchmarks are currently kinda terrible and hardcoded in the sched.rs tests, but it is up there now
[19:20:56] *** Joins: igl (igl@moz-759C7295.adsl.alicedsl.de)
[19:21:32] *** Quits: igl1 (igl@moz-7572D644.adsl.alicedsl.de) (Ping timeout)
[19:22:37] <bblum> arghhhh, the stack trace is useless
[19:22:48] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Ping timeout)
[19:23:55] <bblum> time for me to audit 21 call sites to deschedule_running_task_and_then
[19:24:01] *** Quits: samx (sami@moz-48EC0983.dyn.optonline.net) (Quit: This computer has gone to sleep)
[19:24:25] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[19:24:25] *** ChanServ sets mode: +o dherman
[19:24:42] <bblum> brson: uh, anyway, in order to fix the hang on that test (and in all of the tutorial tests, presumably), replace the implementation of sleep_forever() with "let (p,_c) = oneshot(); p.recv()"
[19:26:12] <sebcrozet> Is `my_vec.slice_from(10).iter()` the best way to get an iterator on a vector starting with the 10th element ?
[19:26:36] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Ping timeout)
[19:27:13] <engla> I think that's the best way sebcrozet
[19:27:16] <bblum> oh... good grief, my select implementation has the deschedule_...and_then environment race. o_o
[19:27:31] <sebcrozet> engla: ok. thanks.
[19:27:51] <toddaaro> bblum: I didn't think through the details of your type thing
[19:27:55] <toddaaro> bblum: but I love the idea
[19:28:00] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[19:28:00] *** ChanServ sets mode: +o dherman
[19:28:06] <toddaaro> bblum: if that works without miserable syntactic overhead I'm a megahuge fan
[19:28:16] <bblum> toddaaro: ? you mean the idea in #8132?
[19:28:31] <toddaaro> bblum: I think so, the env type for avoiding the env race?
[19:28:43] <bblum> yeah
[19:28:55] *** Joins: dherman_ (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[19:29:09] <SimonSapin> with the new for loop, 'in' is a keyword, right?
[19:29:51] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Ping timeout)
[19:30:19] <doomlord_> heh. trying to snap out of my C habit of writing source files 'backwards'.. calleesfirst, callers later..
[19:30:29] <graydon> I still write that way. ML habit.
[19:30:31] <SimonSapin> cmr: r? Again :( foreach became for in the meantime https://github.com/mozilla/rust/pull/8231
[19:30:39] <graydon> the other rust devs yell at me
[19:30:51] <graydon> it's a little game we play. that I am losing. as I should.
[19:30:52] *** Quits: dherman_ (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Ping timeout)
[19:31:25] <mark_edward> is there any reason why a statement like this: printf!("%1x", b as uint); where b: u8 would fail to print zeroes?
[19:31:27] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[19:31:27] *** ChanServ sets mode: +o dherman
[19:31:41] <doomlord_> in C/C++ its to avoid needing to prototype things :) but i figure i can actually put the 'most important function' at the top now..
[19:32:29] <SimonSapin> r? https://github.com/mozilla/rust/pull/8346
[19:32:44] <Seldaek> can you mark a function as returning two traits with foo() -> TraitA + TraitB?
[19:33:07] <Zanpo> Seldaek: do you mean something implementing those 2 traits?
[19:33:09] <Eridius> Seldaek: even one trait there won't work, unless you mean to return a trait object (at which point you need a box)
[19:33:18] <Eridius> fn foo<T: TraitA+TraitB>() -> T
[19:33:23] <Eridius> that will work if you want to return a concrete type
[19:33:44] <Seldaek> Eridius: yes what I meant was it'd return a struct implementing those two traits
[19:34:08] <Eridius> Seldaek: well you'll need a generic method, even for a single trait, since you're actually returning a concrete type rather than a trait object
[19:34:30] <Seldaek> ok thanks
[19:34:43] <Seldaek> guess I'll need to compile this before sending a pull request :P
[19:35:10] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[19:35:44] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: zzzzzzzzzz)
[19:36:33] *** Quits: cypher (ircnet@moz-1D494DB3.vie.surfer.at) (Quit: 410 Gone)
[19:38:26] *** Joins: pupoque1 (Adium@297D6F99.EF706C30.C0C64AB3.IP)
[19:38:32] <toddaaro> am I allowed to put infinity in a speedup graph if changes make previously unrunnable programs runnable
[19:38:57] *** Parts: erickt_ (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) ()
[19:39:58] <bblum> no :P
[19:40:18] <bstrie> toddaaro: only if you use a logarithmic axis
[19:40:23] <bblum> graydon: no way, callees first is the way and the light
[19:40:51] *** Quits: Ms2ger (Ms2ger@EDC982F3.6890FC55.187A1082.IP) (Quit: nn)
[19:40:55] <cmr> Program should go from more abstract to less abstract, callers first is the way and the light
[19:40:56] <toddaaro> bstrie: I should practice log scaled graphs
[19:41:13] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[19:41:25] <graydon> cmr: heh. I .. personally don't agree, but I've lost this fight. it's ok.
[19:41:25] <toddaaro> you can work numbers like people can barely imagine
[19:41:46] <graydon> cmr: I usually understand systems better from the bottom up
[19:42:00] <graydon> show me the primitives and I can guess what the high level algorithms are going to try to do, etc.
[19:42:02] <toddaaro> graydon: I'm going to convert over to your #bench stuff now, what is the best reading on how to use that?
[19:42:13] <graydon> toddaaro: sec
[19:42:14] <toddaaro> graydon: I'd like to take parameters somehow too
[19:42:16] <toddaaro> graydon: k
[19:42:21] <cmr> https://github.com/mozilla/rust/wiki/Doc-unit-testing#benchmarking
[19:42:32] <cmr> (yay awesomebar)
[19:42:35] <graydon> oh .. yeah that
[19:42:40] <graydon> I was just about to paste it
[19:42:47] <graydon> "take parameters" in what sense?
[19:43:36] <toddaaro> oh, awesome a document
[19:43:56] <toddaaro> parameters such as how many messages to send, how many ping-pong pairs, etc.
[19:44:10] <toddaaro> how many schedulers to use
[19:44:27] <Seldaek> Eridius: I must be doing it wrong, but I got error: mismatched types: expected `T` but found `lala::Struct`
[19:44:36] <cmr> Traditionally I've seen environment variables used for that
[19:44:44] <toddaaro> for example, no-ws took 6m10s and swapped a lot to run a test that takes 26s in the workstealing variant
[19:45:01] <Eridius> Seldaek: did you declare the function in some trait as returning a T, but then implemented it as returning a lala::Struct?
[19:45:26] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[19:45:37] *** Joins: dherman_ (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[19:45:37] <Seldaek> Eridius: it's not a function in a trait, it's a standalone function returning a struct
[19:45:41] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Ping timeout)
[19:45:41] *** dherman_ is now known as dherman
[19:46:00] <graydon> toddaaro: I recommend making helper functions that do the work then separate #[bench] benchmarks for a variety of settings. see for example the relationship between benchmarks and helpers in extra::treemap::bench and extra::container::bench
[19:46:04] <Eridius> Seldaek: ok so you wrote the function type as returning T, but in the body you just return a lala::Struct?
[19:46:10] <Seldaek> yup
[19:46:26] <Eridius> Seldaek: you can't do that. If you know the concrete type you're returning ahead of type, just declare that you return that
[19:46:28] <Seldaek> I'd expect this to be valid, is Struct implements T
[19:46:32] *** Joins: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com)
[19:46:39] <Eridius> *ahead of time
[19:46:40] <cmr> Seldaek: T isn't a trait, T is a type
[19:46:51] <Seldaek> cmr: yes well T of Foo+Bar traits :p
[19:47:05] <graydon> toddaaro: that also lets you see obvious nonlinearities and such since your cases (10,1000,100000) are all shown side-by-side in the result set
[19:47:05] <Eridius> Seldaek: `fn foo<T>() -> T { return lala::Struct{} }` is pointless
[19:47:07] <bblum> brson: toddaaro: please see my latest comment on https://github.com/mozilla/rust/issues/8132 and tell me if you like it better than the previous idea (I do, due to the select use case)
[19:47:10] <Eridius> just use `fn foo() -> lala::Struct`
[19:47:53] <Seldaek> Eridius: what I'm trying to do, perhaps it doesn't make sense though, is to make a generic interface so that anyone using it can know they get a T back, but can't rely on specifics of lala::Struct, they can only use stuff provided by the traits declared as T
[19:47:56] <toddaaro> graydon: ok, is there a way to easily toggle benches? it would be nice to have "long mode" which is half an hour and "short mode" which is on par with the existing benches
[19:48:08] <Seldaek> Eridius: so if lala::Struct becomes foo::Struct in the future it wouldn't trip everyone up
[19:48:11] <graydon> half an hour?!
[19:48:17] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[19:48:17] <toddaaro> performance testing!
[19:48:26] <graydon> toddaaro: the inner loop of benchmarks should be miliseconds at most
[19:48:36] <toddaaro> the goal is somewhat different than #bench, so maybe a different tool is appropriate
[19:48:39] <toddaaro> oh, yea that won't work out
[19:48:40] <graydon> it's measuring nanoseconds-per-iteration
[19:48:42] <Eridius> Seldaek: two options. One, use a type declaration to provide a once-off type name which is documented as implementing your traits, but is actually a lala::Struct
[19:48:53] <toddaaro> the short tests I'm thinking of are 10-15s per iteration
[19:48:54] <Eridius> Seldaek: two: make it an actual newtype that reimplements just those traits by calling through to the real struct
[19:48:56] <graydon> toddaaro: what are you trying to do exactly?
[19:49:01] <graydon> toddaaro: what takes 10s to run?
[19:49:11] <toddaaro> graydon: run a variety of benchmark programs to strain the runtime
[19:49:18] <Eridius> Seldaek: or 3, just document on the function that callers should not rely on the return type being stable, but that it guarantees conformance to some traits
[19:49:48] <graydon> toddaaro: "strain"?
[19:50:14] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[19:50:14] *** ChanServ sets mode: +o tjc
[19:50:20] <toddaaro> long tests do a much better job of exposing issues, like a microbench on message sending that only does a few thousand messages works on pre-ws-newrt, but if you do a few million messages you need ~12GB of memory
[19:50:24] <joelteon> how do you sleep the current task
[19:50:44] <toddaaro> so I want to pull out as many quirks like that as I can
[19:50:55] <Seldaek> Eridius: okay, two sounds good but I'm not sure how to achieve that apart from struct StableStruct(lala::Struct);.. then what I impl Foo and Bar for StableStruct and forward everything? Sounds like a lot of boilerplate :/
[19:51:02] <graydon> toddaaro: can you extrapolate the nonlinearity there from less-than-a-few-million?
[19:51:18] <graydon> toddaaro: like if you send 1, 10, 100, 1000, 10,000, surely you can see a pattern
[19:51:22] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[19:51:52] <toddaaro> graydon: maybe, but I'm unsure, it was a slow growth over runtime of the program that looked somewhat like a memory leak
[19:51:59] <graydon> in any case, yes, something that eats 12gb of memory is not good for this; that will cause a buildhost to page
[19:52:10] <toddaaro> I don't want buildbot running these for sure
[19:52:19] <graydon> it runs all #[bench] benchmarks
[19:52:24] <toddaaro> I guess #bench really isn't what I want
[19:52:24] <graydon> in the standard crates
[19:52:27] <brson> bblum: why is yield a no-op? the implementation does deschedule the task
[19:52:43] <toddaaro> I can toss a few simple micro micro benches in there, but for my stress testing I need, well, stress testing
[19:52:57] <Eridius> Seldaek: yeah, it is boilerplate, but that will guarantee callers can't make any assumptions. If I were you I'd probably just document that callers should not rely on the return type being stable
[19:53:01] <bblum> brson: it puts it back on the front of the scheduler queue, so the scheduler will always resume the yielding task first
[19:53:09] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[19:53:14] <brson> bblum: why doesn't that cause a failure?
[19:53:15] <toddaaro> brson: yea, we don't have a concept of yield
[19:53:40] <graydon> toddaaro: yeah. I'm not sure what to say about that; the thing is that if you put code in that's not built and run regularly, it'll bitrot into oblivion pretty fast
[19:53:46] <bblum> brson: what... type of failure do you mean?
[19:53:56] <toddaaro> brson: why would it? you succesfully descheduled the task to yield, you just happened to yield back to where you came from
[19:54:09] <toddaaro> graydon: blah, bitrot would be an issue
[19:54:15] <brson> bblum: these test cases are expecting to fail during the yield because of linked failure
[19:54:18] <graydon> toddaaro: I'd strongly recommend trying to get things-you-want-to-measure into standard forms that don't eat gigabytes to measure. if you need to add more instrumentation, that's also desirable.
[19:54:21] <Seldaek> Eridius: that sounds like a recipe for disaster and pissing off lots of people when you *do* change it. "I told you so" doesn't usually appease angry mobs :) I'd expect traits to work exactly in that use case, they are interfaces
[19:54:38] *** Quits: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP) (Ping timeout)
[19:54:38] <graydon> toddaaro: I recognize it isn't always possible, but that'll keep them alive the longest, if they run on each checkin.
[19:54:49] <bblum> brson: ah right. it does not fail because it's trying to yield to the task that is about to send it a kill signal, but hasn't yet
[19:54:50] <Eridius> Seldaek: the problem is the caller has to be able to figure out what the real return type is during compilation
[19:54:50] <toddaaro> graydon: how hard would it be to pass environment variables into benches? can I just read them in the init code before running iterations?
[19:55:04] <graydon> toddaaro: you could do that, yes.
[19:55:25] <graydon> the timer is only running during bh.iter { ... }
[19:55:26] <toddaaro> graydon: ok, I'll aim for that then, and default to super short benches but have a way to manually pass the "stress" parameter or something
[19:55:28] <Eridius> Seldaek: the fact that your implementation always returns lala::Struct is meaningless. The caller could think that it's supposed to return a foobar::Baz due to constraints at the callsite
[19:55:56] <Eridius> Seldaek: which basically means the type used in the implementation is dependent upon the types as resolved by the caller, not vice versa
[19:56:09] <graydon> toddaaro: I can't guarantee the benchmark harness will have sensible thoughts about an iteration that runs that long though.
[19:56:34] <Eridius> graydon: r? https://github.com/mozilla/rust/pull/8203 I rebased onto latest master
[19:56:47] <toddaaro> brson: dunno if you read scrollback, sorted out the rng issues in the workstealing runtime and message passing is now ~5us per message, speedup for workstealing compared to old sched on the pingpong benchmark is ~14x, currently trying to figure out best approach to benchmarking more stuff
[19:57:01] *** Quits: dmi3y (dmi3y@moz-2345EED7.pool.ukrtel.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[19:57:13] <cmr> Seldaek: Traits aren't interfaces. Trait *objects* are interfaces
[19:57:29] <brson> bblum: this test is doing loop { yield() } and waiting for the grandparent to fail. why is it deadlocking?
[19:57:33] <cmr> (in the java sense, at least)
[19:57:42] <Seldaek> Eridius: I see, maybe my approach is a bit naive when taking static typing in full consideration. But I'd expect the compiler to enforce that at callsite one can't constraint it stronger than the traits "returned" by the function. Then again one can not type something as a trait as far I understand, so that probably can't work..
[19:57:44] <brson> toddaaro: that's badass
[19:57:47] <toddaaro> graydon: ah, ok. I'll see where I end up
[19:57:53] *** Quits: Zanpo (Mibbit@moz-62AF0EAB.net.uwaterloo.ca) (Quit: http://www.mibbit.com ajax IRC Client)
[19:57:58] <graydon> toddaaro: if the body of the iter block is long, it'll probably make the iteration count drop to 1, and then take 50 samples of it and exit.
[19:58:16] <toddaaro> brson: yea, it turns out it was just slow because it spent ~all the time in rng via unrandom contesting a kernel spinlock
[19:58:18] <Seldaek> Eridius: I just wish the compiler would do the boilerplate for me, but I guess it's not as simple
[19:58:27] <cmr> toddaaro: not contesting, I don't think
[19:58:32] <cmr> toddaaro: it was on purpose to gather entropy
[19:58:36] <toddaaro> cmr: ohhhh, ok
[19:58:41] <Seldaek> cmr: what's a trait object? a struct + impl of an interface?
[19:58:42] *** Joins: Blub\0 (wry@7E3BB9D.71150E1A.237AE2BA.IP)
[19:58:46] <Seldaek> cmr: err, s/interface/trait
[19:58:48] <Eridius> Seldaek: it would be neat if you could derive any trait on a newtype struct and have it just call through to the underlying type
[19:58:52] <cmr> Seldaek: Data + vtable
[19:59:04] <bblum> brson: hmm, actually -- you saw it deadlock on multiple cores?
[19:59:08] *** Quits: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP) (Ping timeout)
[19:59:14] <brson> bblum: yes
[19:59:24] <brson> i didn't try one core though
[19:59:24] <bblum> with a global waitqueue it 'should not', so i need to look at this more
[19:59:32] <bblum> with one core it livelocks all the time
[19:59:37] <bblum> due to the yield thing
[19:59:54] <Seldaek> Eridius: yes, that would make the matter already a lot better. I'm not sure how hard it'd be to do though
[19:59:57] <brson> ah, ok i understand why it would livelock on a single core
[20:00:37] <brson> seems like we need yield to do something useful. there needs to be some randomness in the scheduler to avoid these scenarios
[20:00:49] *** Joins: Zanpo (Mibbit@moz-BC6EF590.net.uwaterloo.ca)
[20:00:51] <bblum> yes, my analysis also doesn't explain why it would deadlock/livelock on multiple cores, because we have a global runqueue
[20:00:52] <brson> i can hear graydon thinking 'i told you so'
[20:00:54] <graydon> Eridius: sadly further comments :(
[20:01:10] *** Joins: kud1ing (Mibbit@moz-EEC1DBE2.pools.arcor-ip.net)
[20:01:13] *** Quits: jj2baile (jon@moz-DCEF6040.csclub.uwaterloo.ca) (Ping timeout)
[20:01:25] <graydon> brson: (why?)
[20:01:28] <kud1ing> Evening
[20:01:31] *** Quits: Zanpo (Mibbit@moz-BC6EF590.net.uwaterloo.ca) (Quit: http://www.mibbit.com ajax IRC Client)
[20:01:36] <Eridius> graydon: oh damn. I was wondering where the cstring patch went, I was going to take another look at it
[20:01:43] <kud1ing> My PR #8314 fails to merge into auto. Can i find out why?
[20:01:43] <Eridius> but I was hoping to sneak my process patch in first
[20:01:51] <brson> graydon: because you were very insistent on doing random scheduling and the new scheduler is atm strictly not random
[20:01:57] <brson> and it causes problems
[20:02:07] <graydon> Eridius: you might get in before it, but it'd be unsafe-and-crashy until someone mops up
[20:02:31] <kud1ing> i can't seem to make sense of http://buildbot.rust-lang.org
[20:02:42] <SimonSapin> cmr: bors does not seem to be picking up https://github.com/mozilla/rust/pull/8231 again
[20:02:47] <Eridius> graydon: well by "get it in before" I was hoping I could get it in, then adopt the new approach when the cstring patch lands, but I didn't know when that was planned on landing. Since you say you just decided to accept it, it makes more sense to rewrite my patch on top
[20:02:47] <graydon> brson: is its non-randomness a problem, or is it a problem that it's trying to pull in randomness? I can't quite follow
[20:02:54] <Seldaek> brson: seeing as you reviewed my last getopts PR, would you mind giving an opinion on https://github.com/mozilla/rust/pull/8307? I need a core dev to yay or nay that last comment.
[20:02:58] <joelteon> ooh, the Port internals are weird and unsafe
[20:03:03] <cmr> kud1ing: https://github.com/mozilla/rust/pull/8314 failed because of a merge conflict
[20:03:06] <cmr> kud1ing: rebase
[20:03:29] <graydon> kud1ing: you probably want http://buildbot.rust-lang.org/console?branch=auto&refresh=15
[20:03:34] *** Quits: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[20:03:44] <cmr> SimonSapin: bors lists it as approved, what's the problem you see?
[20:03:51] <Eridius> graydon: is there any way to build a PR on top of another and tell bors about the dependency?
[20:03:59] <brson> bblum: it is a livelock, not a deadlock
[20:04:00] <graydon> Eridius: nope
[20:04:16] <brson> bblum: two cores at 100%
[20:04:19] <graydon> Eridius: I mean, you can just tell the reviewer that it should go in after the other
[20:04:32] <kud1ing> graydon: i can't find the PR number 8314 or the name of my branch there
[20:04:35] <graydon> Eridius: or try to merge the two and close the other
[20:04:49] <Eridius> graydon: yeah ok. I'm just going to wait until #8296 actually lands
[20:04:53] <kud1ing> cmr: can you tell me where you see that?
[20:04:54] <SimonSapin> cmr: it was approved, the build failed, I force-pushed to fix it, you r+â€™d again, and now bors does not seem to be starting a new buid
[20:05:03] <bblum> brson: thank you, that is helpful
[20:05:04] <cmr> SimonSapin: No, he's building something else right now
[20:05:08] <cmr> SimonSapin: he has a lot of work
[20:05:17] <SimonSapin> ok, so itâ€™s in the queue
[20:05:22] <SimonSapin> can I see this somewhere?
[20:05:23] <cmr> kud1ing: it's in the comments on https://github.com/mozilla/rust/pull/8314
[20:05:33] <cmr> kud1ing: the only reason a merge fails is merge conflict
[20:05:34] <brson> bblum: maybe i'll just xfail these tests while we figure out what to do about yield
[20:05:34] <graydon> kud1ing: http://buildbot.rust-lang.org/bors/bors.html has the queue, buildbot is just current-status
[20:05:39] <SimonSapin> I expected bors to at least comment "saw approvalâ€¦"
[20:05:55] <kud1ing> cmr: yes, but where is the conflict?
[20:06:04] <brson> graydon: there are two different discussions about randomness. some of our previously-working test cases are livelocking because the new scheduler's algo is not random
[20:06:05] <cmr> kud1ing: Dunno, rebase it onto master and see
[20:06:07] <Eridius> SimonSapin: bors doesn't comment until it attempts to actually merge the PR
[20:06:16] <SimonSapin> ok, thanks Eridius 
[20:06:25] <SimonSapin> is borsâ€™s status visible somewhere?
[20:06:33] <cmr> http://buildbot.rust-lang.org/bors/bors.html
[20:06:38] <cmr> As already mentioned
[20:06:39] <graydon> brson: heh. ok.
[20:06:51] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Quit: Lost terminal)
[20:06:54] <bblum> brson: i expect if you change sleep_forever() to block forever on a port, it will work
[20:06:56] <kud1ing> cmr: ok
[20:07:00] <SimonSapin> thanks cmr, sorry I missed it earlier
[20:07:02] <bblum> same as i did with the LF tests in task/mod.rs
[20:07:08] * kud1ing googles for git rebase
[20:07:10] <bblum> but i gotta understand why it's hanging on two cores
[20:07:14] <Seldaek> bblum: he's gone :)
[20:07:17] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[20:07:17] *** ChanServ sets mode: +o brson
[20:07:18] <bblum> damn it
[20:07:39] <bblum> brson: i expect if you change sleep_forever() to block forever on a port, it will work, same as i did with the LF tests in task/mod.rs
[20:07:46] <toddaaro> ok, more perf time, anyone know what acpi_pm_read is for in the kernel?
[20:08:01] <cmr> toddaaro: power management
[20:08:05] <bblum> it's for reading acpi power management 
[20:08:08] <toddaaro> wut
[20:08:10] <toddaaro> how do I get rid of that
[20:08:14] <toddaaro> it is taking 25% of runtime
[20:08:25] <cmr> http://labs.creativecommons.org/2012/04/10/setting-kernel-clocksource-to-hpet-solves-mysterious-performance-issues/, https://bugzilla.redhat.com/show_bug.cgi?id=815213
[20:08:44] <bblum> i love the url on that one
[20:09:33] <graydon> it's possibly because we're asking for precise clock time when doing bench
[20:09:42] *** Quits: mark_edward (quassel@981AA104.E81F12CD.76F66111.IP) (Ping timeout)
[20:09:48] <graydon> I have been considering switching it over to rdtsc with a timestamp calibration loop later
[20:09:55] <graydon> this would be excellent arguments in favour of that
[20:10:42] *** Joins: orshem (orshem@C5E06B1E.A5B6B765.E3D28531.IP)
[20:10:45] <toddaaro> this is without any bench code right now, just running the test directly
[20:10:46] *** Joins: mark_edward (quassel@981AA104.E81F12CD.76F66111.IP)
[20:10:52] <bblum> brson: i have it hanging with just one core at 100%... and it started swapping
[20:10:55] *** Parts: orshem (orshem@C5E06B1E.A5B6B765.E3D28531.IP) (Leaving)
[20:11:07] <bblum> uh, i guess that means both cores could have been at 100% if it weren't swapping
[20:11:10] *** Joins: orshem (orshem@C5E06B1E.A5B6B765.E3D28531.IP)
[20:11:16] <cmr> toddaaro: can you push to your branch?
[20:11:21] <bblum> sheesh that's like the 3rd time i've lost my disk cache today
[20:11:22] * cmr wants to look
[20:11:26] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[20:11:53] <kmc> did anybody have any breakthrough re: my needing-fundeps problem, while I was eating lunch?
[20:12:29] <cmr> I have a https://github.com/cmr/rustdoc_ng/blob/master/clean.rs#L74 and the Module that contains a lot of those, which in turn might contain some of those. Is it possible to write a generic function that takes any Item<T> and then putz about with the attrs without touching inner?
[20:12:44] <kmc> at  https://github.com/mozilla/servo/blob/master/src/components/util/tree.rs#L88  I get "error: cannot determine a type for this bounded type parameter: unconstrained type" whereas this worked a month ago
[20:13:49] <toddaaro> cmr: I think it is current now, I'll double check
[20:14:02] <cmr> oh ok
[20:14:12] <toddaaro> cmr: yea, I pushed it, I haven't actually changed anything for awhile
[20:14:37] <toddaaro> just copied some stuff into a non-ws branch so I could compare numbers
[20:14:42] <brson> we should probably rm task::yield for now since it doesn't successfully yield
[20:15:13] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Quit: WeeChat 0.4.1)
[20:15:17] <toddaaro> brson: mostly agree, but not fully, as we could modify yield to at least hit the event loop before re-executing the task
[20:15:26] *** Quits: reyre (reyre@B2D8AB09.33EE9F8A.1139E686.IP) (Quit: Konversation terminated!)
[20:15:30] *** Quits: LU324 (weechat@9AF4F288.83671C58.1B5D53D7.IP) (Quit: WeeChat 0.3.8)
[20:15:49] <toddaaro> brson: so you couldn't yield to a task, but you could yield to incoming IO (say, if you were in a long for loop)
[20:15:53] <brson> toddaaro: it looks like it does that now
[20:16:24] <toddaaro> brson: does it? I thought it looked for a new task immediatly
[20:16:37] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[20:16:52] <toddaaro> it is confusing to have this named yield though, as it isn't really what task::yield means
[20:16:55] *** Quits: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com) (Quit: tikue)
[20:17:19] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[20:17:44] <bblum> we can have it reorder the first 2 tasks on the runqueue, and randomly scale 2 up to N
[20:18:07] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[20:18:13] <bblum> so usually it just reorders 2 to be fast, but will occasionally also eat the entire runqueue and put the yielding task at the very back
[20:18:19] <bblum> to guarantee progress
[20:18:31] <toddaaro> bblum: that is so horrifyingly ugly I don't even know what to say
[20:18:48] <bblum> it's better than eating the entire runqueue every time
[20:19:36] <toddaaro> but just not having yield is an option
[20:19:53] <brson> yeah, maybe. we also need to think of this in context of what work-stealing in a non-strict environment requires to avoid livelock. ideally we have one method of injecting randomness into the scheduler
[20:20:08] <brson> *livelock or starvation
[20:20:20] <bblum> non-strict?
[20:20:20] <toddaaro> the most naive thing is to occasionally steal even if you have work to do locally
[20:20:45] *** Joins: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com)
[20:20:51] *** Joins: jj2baile (jon@moz-DCEF6040.csclub.uwaterloo.ca)
[20:20:52] <toddaaro> as stealing is already a randomness introduction, so you just leverage that to make sure it is happening every so often
[20:20:55] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[20:21:13] <brson> 'fully-strict' is the term the work stealing papers use to describe fork-join trees. workstealing is correct for fully-strict tasks, but not for what we have
[20:21:30] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[20:21:46] <brson> toddaaro: and maybe yield means, 'go steal'
[20:21:51] *** Joins: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net)
[20:21:59] <bstrie> I bet strcat thought I wouldn't notice a pull that removes .times()
[20:22:02] <bstrie> nice try, my friend
[20:22:24] <bblum> we could use a big-reader lock for scheduler workqueues, and take it in write mode when you want to safely put the yielding task at the back of the workqueue
[20:22:46] <bblum> that's not really better than eating the whole queue though
[20:22:58] <Eridius> bstrie: just submit a new PR that re-adds it under the name .repeatsfor() which returns a struct that has one method .times()
[20:23:07] *** Quits: kud1ing (Mibbit@moz-EEC1DBE2.pools.arcor-ip.net) (Quit: http://www.mibbit.com ajax IRC Client)
[20:23:08] <Eridius> err repeats_for
[20:23:14] <Eridius> bstrie: do repeats_for(3).times() {}
[20:23:17] <brson> toddaaro: using stealing as the source of randomness doesn't help in the single-threaded case
[20:23:18] <bstrie> haha
[20:23:35] <toddaaro> brson: it does - steal from yourself
[20:23:36] <brson> oh, yeah it might since you can steal from yourself
[20:23:38] <brson> yeah
[20:23:39] <toddaaro> yeop
[20:23:56] <bstrie> do repeats_for(3).times { strcat.to_spite(); }
[20:24:29] <Eridius> for a_number_of_repetitions_equal_to(3).do() { ... }
[20:25:46] <tjc> for a_number_of_repetitions_equal_to(3).please_do() { â€¦ }
[20:26:46] <toddaaro> hm, so 25% of time is spent in the acpi_pm stuff, and I can't easily change it to hpet as virtualbox doesn't seem supportive of the idea
[20:27:01] *** Quits: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk) (Ping timeout)
[20:27:04] <cmr> toddaaro: which benchmark are you running?
[20:27:19] <toddaaro> cmr: the messaging testcase
[20:27:24] <toddaaro> cmr: I'll get the full name
[20:27:26] <bstrie> tjc: actually I'm envisioning a .please() method on all T, so we can do `do for_a_number_of_repetitions_equal_to(3) { ... }.please()`
[20:27:29] <cmr> toddaaro: I know which one
[20:27:32] <cmr> http://octayn.net/benches/perf.svg is my box on that test
[20:28:05] <Eridius> bstrie: error: INSUFFICIENTLY POLITE
[20:28:12] <tjc> bstrie: the for loop iteration protocol can change to return ThankYou or EvenMore instead of None or Some(..)
[20:28:32] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[20:28:35] <Eridius> bstrie: don't forget to add COMEFROM if you want to reinvent INTERCAL
[20:28:53] <bstrie> tjc: we'd be the politest programming language since, yeah, intercal
[20:29:03] <cmr> toddaaro: the top three offenders are free, is_utf8, and malloc
[20:29:20] <tjc> bstrie: I'm cool with that
[20:29:28] <bblum> why does context::swap call strdup_uniq???
[20:29:49] <tikue> bblum: how does the task naming stuff work?
[20:29:51] <bblum> oh rtdebug huh
[20:29:58] <toddaaro> cmr: interesting, can you check which clocksource you are using?
[20:30:00] <cmr> toddaaro: want the full perf.trace?
[20:30:08] <bblum> tikue: when you spawn a task, you can name it by being like, 
[20:30:21] <toddaaro> cmr: hm, not yet, I'll dig around a bit more with mine but I might take you up on that later
[20:30:23] <cmr> toddaaro: tsc
[20:30:26] <bblum> tikue: let mut t = task(); t.name(whatever); do t.spawn { .. {
[20:30:27] <bblum> }
[20:30:50] <cmr> toddaaro: let me set to acpi_pm and see how it changes
[20:31:08] <bstrie> just the other day I was mentioning how the "Year" field in the infobox on rust's wikipedia article is highly contentious. today it appears that, in addition to having a "Year" of 2006, 2008, 2012, and 2014, we are now also potentially a 2010 language
[20:31:12] <tikue> bblum: it'd be nice if t.name() returned the task itself. then you could do `do task().name("tim's task").spawn { â€¦ }`
[20:31:25] <toddaaro> cmr: yea, if you can do that it would be awesome, thankyou
[20:31:26] <mark_edward> can someone help me with this weird lifetime issue and iterator chaining? https://gist.github.com/MarkJr94/6168319
[20:31:35] <tjc> bstrie: Wikipedia is greatâ€¦ it keeps so many people busy
[20:31:46] <bblum> tikue: yes there's a bug open on that, it's just a cleanup issue
[20:31:47] <Eridius> mark_edward: damn, nice pipeline
[20:31:49] <bblum> tikue: it used to be like that
[20:31:50] <cmr> toddaaro: in general VMs aren't good for benchmarking though
[20:32:03] <tikue> bblum: oh ok :) and here I am thinking I've got something new and original to contribute :P
[20:32:07] <Eridius> mark_edward: I think you're running into the rvalue issue
[20:32:08] <bblum> tikue: ;)
[20:32:09] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[20:32:16] <cmr> toddaaro: only 3.13% of the time is in acpi_pm_read on my box
[20:32:16] <Eridius> mark_edward: you need to stuff the results of your first .collect() into a var
[20:32:19] <mark_edward> Eridius: i only wish it worked!
[20:32:22] <bblum> tikue: oh, it only works with the new runtime though
[20:32:28] <tikue> bblum: yeah I figured
[20:32:30] *** Joins: Luqman (laden@moz-DCEF6040.csclub.uwaterloo.ca)
[20:32:30] <mark_edward> Eridius: that's disappointing :(
[20:32:42] <Eridius> mark_edward: yeah, there's an old issue on this, don't have the number handy. It will be fixed some day
[20:33:02] <cmr> mark_edward: or just avoid the collect calls
[20:33:12] <cmr> mark_edward: why do you want intermediate vectors?
[20:33:15] <Eridius> also, based on your use of .collect().chunk_iter(2), maybe it's time we add a BufferIterator that buffers up n items and yields them in a &[]
[20:33:20] <toddaaro> cmr: wow! so something fishy is going on with my end, last run was up to 43% in acpi_pm_read
[20:33:40] <Eridius> cmr: we have no pure iterator equivalent to .collect().chunk_iter(2)
[20:33:46] <toddaaro> I'm using a vm in virtualbox on osx host, so I wonder if that is causing the problem
[20:33:57] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[20:33:57] *** ChanServ sets mode: +o dherman
[20:33:59] * Eridius thinks he'll go write one now
[20:34:04] <cmr> toddaaro: http://octayn.net/benches/perf_acpi_pm.svg
[20:34:07] <tikue> what is chunk_iter
[20:34:15] <Eridius> tikue: yields slices &[] of length n
[20:34:18] <engla> Eridius: I think it's tricky to fit the slice liftime into the Iterator trait
[20:34:26] <Eridius> tikue: kinda like .window_iter() but it's non-overlapping
[20:34:28] <tikue> Eridius: ah gotcha
[20:34:32] <engla> Eridius: go ahead and figure it out!
[20:34:40] <Eridius> engla: the yielded slice would have its lifetime pegged to the iterator object
[20:34:42] <bblum> brson: ok, i have not gotten it to peg 2 cores at 100, but i have it having one core at 100 and the other one in the 'join()' call that comes out of rt::run_()
[20:34:42] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[20:34:57] <Eridius> engla: something like BufferIter<'self> where .next() yields &'self []
[20:34:58] <tikue> Eridius: oh and there's no current way to go from one iterator to a chunk iterator? only from vec to chunk iterator?
[20:35:09] <Eridius> tikue: yeah. .chunk_iter() is defined in vec, it yields slices of the vector
[20:35:11] <SimonSapin> Eridius: it would have to yield ~[&T], right?
[20:35:17] <Eridius> SimonSapin: it would yield &[A]
[20:35:18] <engla> Eridius: yes right, I don't think you can do that with .next(). please prove me wrong
[20:35:37] <SimonSapin> Eridius: I mean the equivalent on iterators
[20:35:46] <SimonSapin> without vectors
[20:35:57] <Eridius> SimonSapin: not sure what you mean
[20:35:57] *** Quits: gits1225 (gits@3E55327C.4ABA99D2.C6104E0F.IP) (Quit: )
[20:36:36] <cmr> toddaaro: why aren't you just running it native?
[20:36:43] <cmr> does newsched not work on os x yet?
[20:36:53] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[20:36:57] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[20:37:05] <toddaaro> doing real work native on osx is just not on the todo list for my lifetime
[20:37:18] <SimonSapin> vec.chunk_iter() yields slices from vec, but you donâ€™t have such a vector in a potential iter.chunks()
[20:37:21] <cmr> heh
[20:37:36] <toddaaro> ideally I'd just use a testing server, but the mozilla model doesn't include dev servers
[20:37:45] <Eridius> SimonSapin: the vector would live in the iterator itself
[20:37:49] <bblum> symbolic debugging sure would be nice right about now
[20:38:04] <toddaaro> and last time I tried a university machine it did god knows what for a day and I never managed to make it run make check
[20:38:12] <cmr> toddaaro: I can let you ssh into my box
[20:38:24] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[20:38:27] <toddaaro> cmr: I appreciate the offer, but I can figure something out
[20:38:32] <SimonSapin> Eridius: ok, maybe. But it still needs to contain &pointers if you donâ€™t want to copy. So &[&T] at best
[20:38:36] <cmr> ok
[20:38:51] <toddaaro> I'll just have to try more university machines, need to get rust working on them anyway
[20:39:02] <Eridius> SimonSapin: who's copying? If the underlying iterator yields A, this one should be able to yield &[A]
[20:39:05] <Eridius> moves are fine
[20:40:00] <SimonSapin> ok. So you get &[A] from this, then call next. Does the vector you got changes from under you?
[20:40:07] <Eridius> although it just occurred to me, the fact that it will yield a &[u8] potentially freezes the iterator itself. Which may be problematic
[20:40:10] <SimonSapin> Or can lifetimes encode that kind of thing?
[20:40:13] <Seldaek> in a newtype's impl, how do you access the inner type?
[20:40:20] <cmr> Seldaek: *self
[20:40:24] <Seldaek> thanks
[20:40:26] <cmr> **self if it's a &self
[20:40:38] <cmr> You "dereference" the value
[20:40:53] <Eridius> SimonSapin: the borrowed pointer will make the struct immutable while the pointer is outstanding. Which makes me worried that it might not actually return the pointer in time. I may run into freezing issues
[20:41:04] <Eridius> worst-case I can yield ~[A], although I'd rather not
[20:42:24] <SimonSapin> Eridius: but since [A].iter() yields &A, [A].iter().chuncks() would yield &[&A] or ~[&A]
[20:42:36] <cmr> http://seld.be/rustdoc/master/std/iterator/trait.IteratorUtil.html
[20:42:41] <Seldaek> cmr: makes sense, but it's going horribly wrong :p
[20:42:46] <Eridius> SimonSapin: the & part of &A isn't part of the iterator guarantee there. That's just how VecIterator works
[20:42:51] <Eridius> SimonSapin: ~[A].consume_iter() yields A
[20:42:58] <SimonSapin> yes
[20:43:06] <Eridius> SimonSapin: so when I say &[A], the A in this case could very well be &B
[20:43:32] <jdm> is there some way to get the length of a fixed-length vector?
[20:43:44] <jdm> there's no length method for obvious reasons
[20:43:47] <Eridius> jdm: just call .len()? it should auto-slice
[20:43:47] <cmr> jdm: yeah, you type it into the source :)
[20:43:48] <jdm> and vec::len doesn't exist
[20:43:50] *** Quits: Florob (Florob@moz-39532932.de) (Client exited)
[20:44:01] <cmr> rusti: let x = [0u, ..32]; x.len()
[20:44:02] -rusti- 32
[20:44:10] <jdm> oh, huh
[20:44:42] <jdm> thanks
[20:44:45] <cmr> engla: is there any recommended way to apply a function to every element of an iterator without caring about the result at all?
[20:44:53] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[20:44:56] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[20:45:12] <Seldaek> cmr: is it possible I have ot do (**self).foo() to disambiguate? it seems to try to deref the return value of foo() instead
[20:45:14] <Eridius> cmr: for x in iter?
[20:45:26] *** Joins: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk)
[20:45:31] <Eridius> cmr: or you could use .map() and return (), or you could use .peek() and just ignore the return type
[20:45:44] <engla> cmr: don't know
[20:45:45] <cmr> Eridius: well, that's not as quite a nice as iter.each(f), but it'll do I guess
[20:45:47] <joelteon> if I have a type synonym for a function type, can I define a toplevel function using that synonym?
[20:46:01] <Eridius> Seldaek: . binds tighter than * IIRC, so (*self).foo() if you need to call foo on *self
[20:46:11] <Eridius> cmr: .advance() still exists
[20:46:20] <engla> cmr: there should be something added to do that
[20:46:23] <Seldaek> Eridius: aye, seems to help, though it still fails
[20:48:29] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[20:51:07] <doomlord_> can't remember/find .. how to initialize a mutable vector with an initial value & count  (or generate from a function )
[20:51:26] <doomlord_> ^actually i need both .. generate one, init another
[20:51:32] <joelteon> is the fn_factory in par::map called for each item in the vector, or just once?
[20:51:45] <cmr> doomlord_: std::vec::from_fn
[20:51:50] <cmr> doomlord_: the other stuff is in vec::raw
[20:51:57] <doomlord_> thanks
[20:53:02] <joelteon> from the source, it looks like it's called once for each vector item
[20:53:16] *** Joins: jgilbert (jgilbert@moz-BBE3ABD.mv.mozilla.com)
[20:53:21] <joelteon> oh, no, it's called once per slice
[20:53:28] <doomlord_> from_elem ok
[20:53:35] <joelteon> what if I need to do something different in the fn_factory for each slice?
[20:53:38] *** Joins: wilkie (wilkie@moz-A435EAAD.pitbpa.fios.verizon.net)
[20:53:59] <joelteon> not slice, vector member.
[20:54:06] <joelteon> what if I need to call fn_factory for each thing in the vector
[20:54:56] *** Quits: Kruppe (user@moz-4DDA8AB8.uwaterloo.ca) (Client exited)
[20:54:57] <joelteon> i need to generate a new SharedChan for every item in this vector
[20:55:38] <bblum> brson: well, i can't figure out the exact reason. but, it appears to work fine if i change yield to receiving on a dead port.
[20:56:04] <joelteon> i wonder how many indexes mapi generates
[20:56:15] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[20:56:15] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/6a93YA
[20:56:15] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[20:56:43] <cmr> Is there any way to express this? https://github.com/cmr/rustdoc_ng/blob/wip/visit.rs#L3
[20:56:50] <cmr> graydon maybe?
[20:57:30] <cmr> Item<T> is https://github.com/cmr/rustdoc_ng/blob/wip/clean.rs#L74, I want to mutate the stuff on the item without touching the inner
[20:57:40] <cmr> will probably have to refactor it into an enum rather than a generic struct?
[20:57:48] <cmr> (the inner field, that is)
[20:58:03] <brson> bblum: ok. I've done that on my branch
[20:58:11] <brson> thanks
[20:58:49] <graydon> cmr: no, not if you're passing the function in
[20:58:57] <graydon> cmr: the function has to be reified to a single function
[20:59:18] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[20:59:18] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/qcONzA
[20:59:18] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[20:59:21] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[20:59:21] <ghrust> 01[13rust01] 15bors pushed 11 new commits to 06auto: 02http://git.io/8aidCQ
[20:59:21] <ghrust> 13rust/06auto 1452787e9 15Brian Anderson: std::rt: 2MB stacks again
[20:59:21] <ghrust> 13rust/06auto 14260b444 15Brian Anderson: std::rt: Pull RUST_MIN_STACK from the environment
[20:59:22] <ghrust> 13rust/06auto 141bf5b19 15Brian Anderson: std: Allow spawners to specify stack size
[20:59:24] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[20:59:50] <graydon> cmr: that is, the monomorphization pass has to have turned all type variables into concrete types when it's emitting code. each of the calls to f there assumes f has a different concrete type.
[21:00:25] <graydon> cmr: which would be fine if f were the name of an external function; it'd just stamp out multiple copies of it. but you're calling a first class value there. that value has to have _one_ concrete type.
[21:01:09] <Eridius> uh oh. I just realized that by not having a laptop at the moment, since I'm going on vacation for a week starting tomorrow, that means I'll be cut off from rust :/
[21:01:19] <cmr> graydon: could the closure be moved into a trait or other such thing?
[21:01:39] <cmr> I thought a closure would be easiest but if that's not the case I can use something else
[21:01:41] <graydon> cmr: this is the meaning of the FAQ entry https://github.com/mozilla/rust/wiki/Doc-language-FAQ#why-arent-values-type-parametric-why-only-items
[21:01:45] <bblum> brson: toddaaro: can you send on a ChanOne from inside a CleanupJob callback?
[21:01:59] <bblum> my guess is no, huh?
[21:02:00] <graydon> cmr: no polymorphic values, only polymorphic definitions (items)
[21:02:10] <cmr> Ohhhh a FAQ!
[21:02:12] <cmr> Exciting!
[21:02:33] <bblum> i guess that is what tube is for huh
[21:03:29] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[21:03:34] <toddaaro> bblum: that doesn't sound like it should work
[21:03:37] <toddaaro> bblum: what is tube?
[21:03:44] <toddaaro> well, hm
[21:03:51] *** Quits: sw17ch (sw17ch@moz-62998E95.hfc.comcastbusiness.net) (Quit: sw17ch)
[21:04:00] <toddaaro> I really haven't thought enough about using primitives inside cleanup jobs
[21:04:09] *** Joins: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com)
[21:04:13] <toddaaro> it appears to work pretty well, as the network code uses a lot of them in there I think
[21:04:15] <cmr> graydon: so if I had like `fn collapse_docs<T>() { ... }`, I could do collapse_docs(x) in all of those loops?
[21:04:24] <graydon> cmr: yes
[21:04:31] <bblum> i just want to send a unit from sched context to task context, and it needs to work cross-CPU
[21:04:42] <cmr> That'd be a lot of code duplication, I'll just use an enum for inner
[21:05:00] <graydon> cmr: yeah. this is the tradeoff :(
[21:05:10] *** Quits: lucian (lucian@moz-22A14C6A.cable.virginmedia.com) (Ping timeout)
[21:05:21] <joelteon> ok, somehow inside the par::mapi function factory, I need to know the index of the current element
[21:05:39] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[21:05:40] <cmr> Thing is, I originally used an enum, then I realized "All of these variants just have a single struct, I can use a generic!"
[21:06:27] *** Joins: LU324 (weechat@9AF4F288.83671C58.1B5D53D7.IP)
[21:07:29] <graydon> :(
[21:07:37] <bblum> brson: does tube work cross-CPU?
[21:07:42] <brson> bblum: no
[21:08:00] <bblum> hmm
[21:08:29] <cmr> graydon: It'd be convient to buy into runtime parameterization, just like I can buy into dynamic dispatch
[21:08:48] <cmr> Quite a bit more complexity though
[21:09:01] <graydon> cmr: if it makes you feel better, we once (2 years ago?) had the implementation strategy of runtime parameterization
[21:09:08] <graydon> cmr: you do not want to go there. promise.
[21:09:18] <cmr> graydon: Ok! Good enough for me
[21:09:29] <graydon> I thought such things as "a little extra arithmetic at runtime can't be so bad!"
[21:09:33] <graydon> hahahaha hahahaha hahahaha
[21:09:39] <graydon> well
[21:09:42] <graydon> gotta learn somehow
[21:09:49] <graydon> and it does generate "less code" in one dimension
[21:09:54] <graydon> but so much more in every other
[21:09:59] <bblum> brson: can I send on a ChanOne inside of a CleanupJob callback? I thought I couldn't because it's full of borrow::<Scheduler>, but tube send seems to borrow the scheduler too, so...
[21:10:36] <cmr> graydon: how was it implemented? The "manual" version I'm doing now is stuffing all the possible types into an enum, although I assume you can't do that in the compiler
[21:10:38] <toddaaro> bblum: I feel like we should just define the concurrency primitive for that context
[21:10:41] <graydon> cmr: like when you index into a structure. it has to load values out of type descriptors passed in as a vector of extra hidden parameters into a function, then add up the offsets dynamically, and adjust the pointer by that amunt.
[21:10:50] *** Joins: robertknight (robertknig@moz-AB0E96D7.range86-162.btcentralplus.com)
[21:10:51] <cmr> oh yuck
[21:10:55] <bblum> toddaaro: i don't get what you mean
[21:10:56] <graydon> yeah FUN TIMES
[21:11:06] <graydon> we did that. rustboot and rustc 0.1 .. 0.2 I think both did that?
[21:11:10] <graydon> maybe we had removed it by 0.1
[21:11:13] <toddaaro> bblum: if we properly handle everything that is going on we can make cleanup job context just as full featured as task context
[21:11:16] <graydon> it was doing that when we bootstrapped anyways
[21:11:33] <toddaaro> bblum: and then we can just use pipes to communicate stuff around in sched context
[21:11:35] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[21:11:45] <brson> bblum: borrow::<Scheduler> shouldn't work inside the CleanupJob
[21:12:10] <brson> the cleanup job should be running weth Scheduler already borrowed
[21:12:17] <bblum> brson: but tube::send seems to take the scheduler too
[21:12:31] <graydon> cmr: I should also point out that bootstrapping did actually take about an hour per run of rustc-on-itself
[21:12:39] <graydon> finding bugs .. real slow
[21:12:49] <bblum> ah yes, the cleanup job runs with the scheduler unsafe_borrowed
[21:12:56] <brson> that's not right
[21:13:13] <bblum> otherwise tube isn't right o_O
[21:13:19] <cmr> graydon: that is horrifying
[21:13:24] *** Quits: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP) (Quit: Lost terminal)
[21:13:34] <brson> the scheduler being borrowed during the cleanup job is to prevent doing further context switches from the cleanup job, which can lead to infinite recursion
[21:13:38] <toddaaro> ah yes, I did unsafe_borrow there because regular borrow
[21:13:39] <brson> tube's shouldn't be sending from cleanup jobs
[21:13:45] <bblum> :q
[21:13:46] <bblum> oops
[21:13:47] <toddaaro> triggered the bug
[21:13:53] <toddaaro> where I guess tube didn't work
[21:14:02] <toddaaro> so I handwaved and added unsafe and the tests passed
[21:14:06] <toddaaro> so I stopped thinking about it
[21:14:09] <bblum> brson: well, tube::test::simple_test does
[21:14:18] <toddaaro> it *would* be nice to do regular borrow on the scheduler for cleanup job
[21:15:35] <brson> bblum: heh, simple_test is guaranteed not to rendevouz with the reciever, so not do the context switch
[21:15:44] <bblum> sigh :P
[21:15:45] <brson> hacky
[21:15:55] <brson> tube is pretty rough
[21:16:08] <bblum> alright, well, i need a way to send a unit from the cleanup job to the task
[21:16:20] <bblum> alternately, i could just make select() use a LittleLock
[21:16:37] <bblum> that would work but it would hold the LittleLock for O(n) time :(
[21:17:01] <bblum> *alternatively
[21:17:52] <cmr> graydon: The problem with *this* approach is now I'm trading off compile failure for runtime failure. There's no way for the compiler to know and assert that mod.structs only contains Item with an inner of StructItem variant
[21:18:09] <Seldaek> may I attract some smart people attention towards https://github.com/mozilla/rust/issues/8353 ? It sounds like a somewhat important change to me.
[21:18:19] <bblum> brson: so, what is the infinite recursion that can be triggered by doing send() inside a cleanup job?
[21:18:23] <bblum> maybe we can avoid it somehow
[21:18:33] <brson> bblum: you can enqueue a callback and do the send from there
[21:19:09] <bblum> oh hm, ok, great
[21:19:44] <cmr> Seldaek: The "correct" solution to this problem is trait objects
[21:19:48] <brson> bblum: cleanup jobs are run immediately after context switches, so if you repeatedly context switch in cleanup jobs, you have a call stack that ends up being a bunch of run_cleanup_jobs
[21:20:02] <cmr> Seldaek: pub fn rng() -> ~Rng
[21:20:09] <cmr> pub fn weak_rng() -> ~Rng
[21:20:24] <toddaaro> you could do a send by creating a task inside a cleanup job, and making that task have a function that sends on the pipe, and then continue
[21:20:27] <brson> it's only a problem if you have a bunch of mutually context switching jobs
[21:20:31] <Eridius> cmr: if by "correct" you mean slow
[21:20:36] <toddaaro> (enqueuing the task instead of running it)
[21:20:41] <brson> which i did in `send` at one point
[21:20:41] <bblum> brson: but, if my second context switch frame is one from send(), which doesn't context switch on its own, it would be fine, right?
[21:20:43] <toddaaro> oh, you could also use async_async_send@
[21:20:43] <cmr> Eridius: vtable lookup isn't really slow
[21:20:47] <toddaaro> s/@/!
[21:20:49] <Eridius> cmr: slower than static dispatch
[21:20:50] <cmr> Eridius: larger code, but neglibly slower
[21:20:53] <toddaaro> async_async_send would be entirely safe
[21:20:57] <cmr> Well yes, doing things is slower than not doing them :p
[21:20:58] <brson> bblum: yes, technically
[21:21:00] <Seldaek> cmr: I know it's my fault, but I don't get what that means compared to what it is now, or why it's not done already that way
[21:21:03] <bblum> brson: not that i should be allowed to, mind you, since the callback solution seems fine enough
[21:21:10] <toddaaro> as you no longer have any scheduling in the cleanup job, so there would be no issue
[21:21:23] <bblum> alright
[21:21:25] <toddaaro> bblum: so go ahead with async_async_send, that solves the problem
[21:21:31] <Seldaek> cmr: in any case, please answer on github I think it'd be better to keep it there :)
[21:21:32] <graydon> Seldaek: if you remove the impl of RngUtil in your 3rd attempt, it ought to work, no?
[21:21:33] <pcwalton> iterators are really convenient
[21:21:39] <pcwalton> ++iterators
[21:21:47] <cmr> Seldaek: (also, RngUtil never needs to be implemented on anything that implements Rng)
[21:22:03] <cmr> Seldaek: Ok, will do in a bit
[21:22:09] <pcwalton>         for ty in path.segments.iter().flat_map_(|s| s.types.iter()) { self.resolve_type(ty, visitor) }
[21:22:16] <graydon> yeah. I think it should more-or-less work if you just impl Rng; it's complaining that you implemented RngUtil twice, not Rng.
[21:22:17] <toddaaro> if rustc runs out of memory, will it spin at 100%?
[21:22:22] <Eridius> Seldaek: you don't need RngUtil, that automatically works on any Rng
[21:22:28] <graydon> pcwalton: yeah, it's pretty slick
[21:22:29] <Eridius> Seldaek: so you can remove RngUtil on all 3 of your attempts
[21:22:35] <toddaaro> I can't figure out how to get it to build on a server I'm using, it has been stuck compiling stage0 for 25 minutes, using ramdisk
[21:22:38] <Seldaek> cmr/graydon: ah ha. ok that owuld make it less verbose, and would explain the conflicts I had, but still it's just lucky that in this case Rng only has one required method.. if it was 10 the point still stands that an auto-impl-generator on derive would be good
[21:23:10] <cmr> Seldaek: yes, I agree that the point still stands
[21:23:47] <graydon> Seldaek: I'm not sure what deriving has to do with it, tbh.
[21:23:51] *** Joins: Peter (chatzilla@moz-97742234.new.ox.ac.uk)
[21:23:55] <graydon> Seldaek: I'm not trying to be dismissive, sorry; just a bit confused
[21:24:21] <cmr> graydon: a #[deriving(something)] would be slapped onto the newtype that automatically derives all the traits the newtype'd type implements, but replacing any use of self with (*self) 
[21:24:24] <cmr> aiui
[21:24:29] <graydon> deriving() is for implementing particular traits whose implementations are sorta naturally based on the structure of the struct
[21:24:42] <cmr> So, (*self).foo()
[21:24:45] <ecr> basically they want GeneralizedNewtypeDeriving
[21:24:57] <cmr> or, rather fn foo(&self) { (*self).foo() }
[21:24:59] <graydon> I see. so this strikes me as a bit more like pcwalton's query about overridable operator * or such
[21:25:01] <Seldaek> graydon: no harm done, but yes what cmr said.. 
[21:25:19] <Eridius> graydon: what Seldaek wants is a way to say "this function returns some type that implements trait Foo", without actually being a generic function
[21:25:33] <Seldaek> and without having to type too much ;)
[21:25:41] <pcwalton> yeah, I had envisioned overloadable * as a sort of GeneralizedNewtypeDeriving
[21:25:41] <cmr> Eridius: that is exactly what trait objects are though
[21:25:45] <pcwalton> it's different
[21:25:50] <pcwalton> but it is also safe ;)
[21:26:03] <pcwalton> which is not true for GeneralizedNewtypeDeriving (granted, only when combined with GADT's, but still...)
[21:26:12] <Eridius> cmr: yeah, but trait objects are dynamic dispatch. It would be nice to have some syntax that doesn't force dynamic dispatch
[21:26:16] <graydon> mhm. I'm a little confused about how all these pieces fit together, but would caution about rushing to a particular conclusion
[21:26:21] <brson> bblum: run-pass/send-iloop fails periodically too: "fatal runtime error: assertion failed: task.unwinder.unwinding"
[21:26:32] <brson> i'm going to look into it, but could use help
[21:26:33] <graydon> for example, if the trait has a return type of self, you're faced with having to re-wrap it?
[21:26:36] <cmr> Eridius: How can you do it *without* dynamic dispatch?
[21:26:39] <Eridius> the idea being that the caller doesn't have to be able to deal with _any_ type that implements a given trait, it only has to deal with some concrete type, but isn't allowed to treat it as anything more than the trait
[21:26:40] <pcwalton> I would caution as well; GHC rushed into GeneralizedNewtypeDeriving
[21:26:43] <bblum> brson: sure, btw, to make a callback, it's "do sched.event_loop.callback { .... }", right?
[21:26:50] <pcwalton> and as a result broke their type system
[21:26:53] <pcwalton> and it is still not fixed
[21:26:56] <graydon> yeah. let's not do that :(
[21:26:57] <pcwalton> due to questions like graydon's
[21:27:26] <sp3d> Eridius: what if two functions return a "Rng" single-type-trait-object like proposed but the "hidden" types differ?
[21:27:29] <Eridius> cmr: make the real return type part of the actual ABI, but just annotate it so the caller is prevented from assuming it's more than trait Foo
[21:27:29] <brson> bblum: yes
[21:27:31] <pcwalton> the overloadable * thing is basically just a tweak on Go's system which is not that flexible but is also trivially sound
[21:27:49] <graydon> pcwalton: I regret I still haven't digested the whole scope of that either :(
[21:27:56] <Eridius> pcwalton: sadly it's not as powerful as Go's, because with Go you can embed multiple structs
[21:28:06] <pcwalton> Eridius: I don't really like that though, it leads to diamons
[21:28:08] <pcwalton> diamonds
[21:28:14] <pcwalton> graydon: I need to tweak it, Jesse pointed out that it breaks moving GC
[21:28:18] <graydon> ok
[21:28:29] <graydon> woah, Go lets you embed two copies of a subobject?
[21:28:32] <pcwalton> yeah. :(
[21:28:34] <graydon> which does it dispatch to? :((
[21:28:40] <Eridius> pcwalton: it's nice in ways though. I can say struct LockableFoo { sync.Mutex; Foo; }
[21:28:40] <pcwalton> gives you an error
[21:28:47] *** Joins: azita (Azita@moz-9997F785.static.cablecom.ch)
[21:28:47] <Eridius> pcwalton: which is trivially a version of Foo that supports locking
[21:28:59] <Eridius> graydon: it searches the embedded structs in source order
[21:29:03] <pcwalton> Eridius: yes, but I would like to prevent dreaded diamonds
[21:29:08] <pcwalton> oh really
[21:29:09] <graydon> mm. that is cute.
[21:29:09] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[21:29:09] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14a8ba398 to 146972eb4: 02http://git.io/N3iJvQ
[21:29:09] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[21:29:10] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[21:29:10] <ghrust> 01[13rust01] 15bors pushed 5 new commits to 06auto: 02http://git.io/PMblGQ
[21:29:10] <ghrust> 13rust/06auto 14bd472d1 15Tim Chevalier: rustpkg: Eliminate a copy
[21:29:10] <ghrust> 13rust/06auto 142455f8e 15Tim Chevalier: Makefiles: make rustpkgtest depend on rustpkg executable
[21:29:10] <ghrust> 13rust/06auto 14ada0ae1 15Tim Chevalier: std/rustc/rustpkg/syntax: Support the `extern mod = ...` form...
[21:29:11] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[21:29:12] <pcwalton> so it just dispatches to the first?
[21:29:15] <Eridius> pcwalton: yep
[21:29:16] <pcwalton> that's just a language design mistake IMO
[21:29:20] <pcwalton> very dangerous
[21:29:32] <cmr> pcwalton: I think Go is a language design mistake when it comes to things that matter..
[21:29:35] <cmr> but that's a different topic
[21:29:37] <pcwalton> struct A { ... } struct B { A; ... } struct C { A; ... } struct D { B; C; ... }
[21:29:42] <pcwalton> let's not go overboard, Go did a lot of things right
[21:29:46] <graydon> that sounds a bit dangerous, yeah. you're not always going to know which lockable subobject you're locking, to take the concrete example seriously
[21:29:46] *** Quits: jensnockert (jensnocker@moz-131195AC.mobileonline.telia.com) (Connection reset by peer)
[21:29:46] <cmr> Yes, it did
[21:29:47] <pcwalton> but this is wrong IMHO :)
[21:29:49] <ecr> isn't the intuitive way to resolve diamonds just requiring the programmer annotate?
[21:29:51] <Eridius> pcwalton: yeah you get two copies of A there. It's ugly, but you can simply avoid writing struct D ;)
[21:30:07] <Eridius> and in that case if you call a method of A, it'll call it on B's copy of A
[21:30:15] <pcwalton> Eridius: that's a footgun, isn't it?
[21:30:23] <Eridius> pcwalton: I don't think it's been a problem in practice
[21:30:29] <Eridius> you're not really supposed to end up with complicated embedding hierarchies
[21:30:31] <pcwalton> that's what Go always says, I'm not convinced :)
[21:30:38] <doomlord_> could you just make any diamonds a compile time error
[21:30:39] <pcwalton> they also say that about null pointers
[21:30:44] <Eridius> pcwalton: most embeds are done with named fields, that don't have implicit method dispatch
[21:30:51] <Eridius> you only get the implicit method dispatch when you use unnamed fields
[21:31:00] <pcwalton> right, but we're talking about unnamed fields here
[21:31:16] <graydon> well, what are _we_ talking about, for rust? :)
[21:31:24] <brson> bblum: send-iloop looks like it's probably got similar scheduling issues to the other yield test cases. the failure mode looks weird though
[21:31:33] <bblum> i agree
[21:31:35] <pcwalton> I would propose limiting any such feature to single inheritance only to prevent dreaded diamonds
[21:31:58] <Eridius> pcwalton: it's certainly possible to do something nasty and end up with multiple copies of a struct via embeds. It doesn't tend to be a problem in practice though due to how people use embeds
[21:32:14] <Seldaek> graydon: ultimately all I'm trying to achieve here is forward-compatibility, and avoiding us having to break BC or piss users off in the future. locking down function signatures to strict interfaces is a good way to do that.
[21:32:16] <bblum> brson: it also appears to segfault
[21:32:16] <Eridius> If you're really worried about diamonds, you could simply make the diamond pattern an error, but allow multiple inheritance otherwise
[21:32:23] <graydon> Eridius: if it's not a problem in practice, then being prevented also shouldn't be a problem in practice :)
[21:32:44] <Eridius> graydon: preventing multiple inheritance isn't the same thing as preventing diamonds. My cute little LockableFoo struct relies on embedding both Foo and sync.Mutex in order to work
[21:32:48] <pcwalton> I think the diamond problem is not just a problem with the same class, it is also a problem when you have the same method on multiple thing
[21:33:00] <pcwalton> on if Foo has a Lock method
[21:33:11] <pcwalton> if Mutex has a Lock method and if Foo has a Lock method
[21:33:11] <Eridius> pcwalton: that's no different than having LockableFoo implement a method that Foo also implements
[21:33:23] <pcwalton> it silently delegates to the first one
[21:33:27] <graydon> Eridius: ah I see, agreed
[21:33:29] <pcwalton> what if you change the order?
[21:33:32] <Eridius> and in fact you can do precisely that if you wish to dispatch to the second embedded struct instead of the first
[21:33:42] <pcwalton> it silently chooses the first though
[21:33:42] <Eridius> order affects method resolution
[21:33:49] <pcwalton> yes, and I'm saying that's a misfeature
[21:34:03] <pcwalton> violates principle of least surprise
[21:34:17] <Eridius> it does? It seems pretty straightforward to me that it picks the first one it finds
[21:34:28] <cmr> It seems pretty straightforward to me that order doesn't matter
[21:34:30] <Luqman> brson: for the arm buildbots, would they be android or some flavour of linux?
[21:34:39] <pcwalton> you should have to tell the compiler which method you want to delegate to
[21:34:39] <Eridius> pcwalton: this seems equivalent to changing the order in single inheritance. If I have A : B and I swap that to B : A that changes method resolution
[21:34:42] <bblum> brson: stack trace for the segfault: http://pastebin.mozilla.org/2797119
[21:34:49] <cmr> It doesn't matter what order my functions are in my module, or methods in my trait, why this special case?
[21:34:52] <bblum> i worked hard to get that unoptimized build with no inlined functions :P
[21:34:54] <tikue> rusti: let v = [1, 2, 3]; v.iter().map(|&i| i + 1)
[21:34:55] <brson> Luqman: the one I am working on is an x86 linux bot cross-compiling to the android ndk
[21:34:55] -rusti- pastebinned 8 lines of output: http://sprunge.us/NKdV
[21:35:02] <pcwalton> cmr++
[21:35:12] <tikue> rusti: let v = [1u, 2, 3]; v.iter().transform(|&i| i + 1)
[21:35:13] -rusti- pastebinned 16 lines of output: http://sprunge.us/eWNC
[21:35:16] <pcwalton> method resolution semantics in Go are insanely complex actually
[21:35:19] <pcwalton> when I looked into it
[21:35:21] <tikue> rusti: let v = [1u, 2, 3]; v.iter().transform(|&i| i + 1);
[21:35:22] -rusti- ()
[21:35:25] <graydon> this is about intuitions. some people think A before B means shadowing in some contexts, not others.
[21:35:38] <graydon> it's hard to say what's ideal. but I think generally "less order-dependence is better"?
[21:35:45] <pcwalton> I agree
[21:36:06] <graydon> we've had people (reasonably) argue that they don't even want _variable_ shadowing to happen in a local scope.
[21:36:08] <cmr> Even if it weren't a problem for other reasons, I think introducing order dependency special cases is bad. Adds mental burden
[21:36:13] *** Quits: mihneadb (mihneadb@E48845AB.3A9F9BD4.4C2245EF.IP) (Connection reset by peer)
[21:36:23] <bblum> brson: oh, the stack trace doesn't say anything because the cleanup job is run on the scheduler's stack
[21:36:27] <bblum> sigh
[21:36:39] <Eridius> personally, I have no problem with explicitly annotating the order for lookup
[21:36:53] <Eridius> what I'm arguing against is enforcing single inheritance due to concerns that can be addressed via other mechanisms
[21:37:03] <graydon> yeah. I think that's what I'd prefer in such cases (similar to if we ever have a mechanism for disambiguating colliding trait method names)
[21:37:05] *** Quits: Guest (textual@34641662.FB4DE631.66C78B76.IP) (Quit: Textual IRC Client: www.textualapp.com)
[21:37:15] <brson> bblum: interesting. I haven't seen that segfault ye
[21:37:18] <brson> -t
[21:37:24] <cmr> I agree
[21:37:24] *** Joins: mihneadb (mihneadb@E48845AB.3A9F9BD4.4C2245EF.IP)
[21:37:27] <graydon> I do not know how you'd go about it though, notation-wise. or even what the right thing to do is.
[21:37:28] <pcwalton> I think dreaded diamonds are just worth categorically forbidding due to the pain they cause in C++
[21:37:39] <graydon> like suppose you embed two lockable objects in a super-object
[21:37:43] <graydon> serious use cae
[21:37:45] <graydon> case
[21:37:47] <graydon> likely one even
[21:37:53] <Eridius> graydon: I would say you designed your object wrong
[21:37:53] <cmr> I do not know what a diamond is and why it is dreaded; is this purely lookup in the case of inheritance or something else?
[21:37:53] <graydon> what is supposed to happen when you call outer.lock()?
[21:38:16] <pcwalton> the point of language design is to make it hard to do the wrong thing
[21:38:17] <graydon> Eridius: you don't notice you did it. you forgot about it.
[21:38:25] <pcwalton> you can also argue in this way about null pointers
[21:38:28] <pcwalton> and the Go developers do
[21:38:31] <pcwalton> Rust rejects that notion
[21:38:32] <Eridius> graydon: if you have two lockable sub-structs, then you should use named fields
[21:38:37] <graydon> Eridius: this is about a footgun, which is precisely the "tried to do something, did something wrong" case
[21:38:50] *** Quits: lmandel (lmandel@13F2CEC5.7672369.D8E68FF6.IP) (Quit: lmandel)
[21:38:51] <graydon> Eridius: so do we trap it?
[21:39:10] <Eridius> because the correct answer for what happens when you call outer.lock() is you shouldn't be able to call outer.lock(). You have two internal locks, neither controls synchronization for the whole struct
[21:39:18] <graydon> Eridius: great!
[21:39:20] <graydon> I like that answer
[21:39:22] <graydon> so how do we trap it?
[21:39:26] <graydon> can we ensure we trap it at compile time
[21:39:27] <graydon> ?
[21:39:29] <graydon> (not link time)
[21:39:33] <graydon> (definitely not runtime!)
[21:39:39] <cmr> (link failures are dreadful :( )
[21:39:49] <Eridius> maybe just throw an error if there's any possible method ambiguity?
[21:40:15] <graydon> is it an ambiguity the user can overcome without having to redesign upstream libraries?
[21:40:19] <Eridius> i.e. if the intersection of (methods of sub-struct A) and (methods of sub-struct B) is both non-empty, and larger than the subsequent intersection with (methods of outer struct)
[21:40:23] *** Quits: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP) (Quit: victorporof)
[21:40:23] <graydon> (also an important consideration)
[21:40:32] <Eridius> graydon: so if there's ambiguity, you have to implement the method on the outer struct
[21:40:38] *** Quits: sebcrozet (sebcrozet@moz-D8879CC3.w80-13.abo.wanadoo.fr) (Quit: Gone)
[21:40:52] <graydon> ok. that sounds pretty sweet to me. and you can do that by changing from unnamed fields to named fields?
[21:40:58] <Seldaek> Eridius: this is a pretty elegant way to disambiguate actually, I prefer that than insane annotations
[21:41:33] <Eridius> graydon: named fields don't have implicit method resolution
[21:42:02] <graydon> right. so if I hit this error and say "oh no, I'm a fool!" I can redesign my object to use named fields, implement the methods in question manually, and keep moving, right?
[21:42:05] <graydon> I'm not completely stuck
[21:42:27] <Eridius> yep
[21:42:40] <Eridius> or don't even use named fields, just implement the method on the outer struct
[21:42:55] <Eridius> any method on the outer struct will be prefered over methods on the embedded ones (just like regular inheritance in OOP)
[21:43:09] <pcwalton> except the "this" pointer is wrong and there are no downcasts but yeah
[21:43:11] <Seldaek> but then how do you route the call to one of the inner structs?
[21:43:33] <Eridius> so if I have `struct Foo { sync.Mutex; Bar }` and Bar is independently lockable, I could say `func (f *Foo) Lock() { f.Bar.Lock() }`
[21:43:46] <Eridius> Seldaek: unnmaed fields can be accessed by using their type as a name
[21:43:51] <graydon> ok. then that sounds pretty reasonable. I don't have strong preferences, don't really like OO-style most of the time anyways. but I won't complain if we wind up someplace like that.
[21:43:53] <Seldaek> oh fair enough
[21:44:01] <bblum> brson: the function pointer that is getting passed in to switch_running_tasks_and_then::anon::expr_fn is bogus
[21:44:03] <pcwalton> that doesn't work in rust
[21:44:05] <pcwalton> because not all types are nominal
[21:44:06] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[21:44:06] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14ec6f0f0 to 146972eb4: 02http://git.io/N3iJvQ
[21:44:06] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[21:44:06] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[21:44:07] <ghrust> 01[13rust01] 15bors pushed 12 new commits to 06auto: 02http://git.io/nvudvQ
[21:44:07] <ghrust> 13rust/06auto 1452787e9 15Brian Anderson: std::rt: 2MB stacks again
[21:44:07] <ghrust> 13rust/06auto 14260b444 15Brian Anderson: std::rt: Pull RUST_MIN_STACK from the environment
[21:44:07] <ghrust> 13rust/06auto 141bf5b19 15Brian Anderson: std: Allow spawners to specify stack size
[21:44:09] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[21:44:11] <bblum> brson: strongly suspect this environment race issue
[21:44:13] <pcwalton> e.g. if the inner field is a tuple
[21:44:15] <graydon> yeah you can't put a type as a field-name
[21:44:17] <bblum> since that function pointer is in the environment
[21:44:25] <ecr> you can just destruct self to get the nameless field positionally, no?
[21:44:31] <Eridius> graydon: I'm not advocating for precisely the same syntax, or even for unnamed fields. I'm not sure what the right way to represent this in rust is
[21:44:40] <Eridius> I'm just advocating for having some way to deal with this without re-writing every single method
[21:44:49] <graydon> Eridius: sure sure
[21:44:50] <graydon> understood
[21:45:13] <Seldaek> well, I'm glad overall everyone seems rather positive about the idea at least
[21:45:17] <graydon> I think pcwalton wants that too! he is after all writing a browser that implements a DOM worth of OO-inheritence-thinking :)
[21:45:17] <brson> bblum: yeah, seems likely
[21:45:27] <pcwalton> graydon: no, this won't work for the DOM
[21:45:28] <pcwalton> no downcasts
[21:45:30] <graydon> ah
[21:45:32] <graydon> bummer
[21:45:33] <bblum> brson: yes, that's what's causing it -- as soon as BlockedTask::try_block succeeds at blocking the task, it can get killed awake, which will clobber the 'f' on its stack frame captured in the environment
[21:45:42] *** Joins: mw (mw@moz-3B2CBD34.adsl.highway.telekom.at)
[21:45:43] <graydon> pcwalton: single inheritence does though?
[21:45:51] <pcwalton> in general I think Go has gotten everyone too uncritically accepting of the "composition is better than inheritance" mantra
[21:46:05] <bblum> brson: this is quite similar to the problem in select()
[21:46:06] <pcwalton> it is true unless you are actually doing things that inheritance was designed for
[21:46:14] <graydon> :)
[21:46:15] <pcwalton> GUIs and DOMs and simulations and stuff
[21:46:22] *** Quits: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net) (Input/output error)
[21:46:24] <pcwalton> then you really need downcasts and for the "this" pointer to be correct
[21:46:48] <cmr> I've never actually seen a GUI library that doesn't either use a language with OO or fake it (gtk), does one exist?
[21:47:12] <pcwalton> cmr: I have yet to see one
[21:47:22] *** Quits: robertknight (robertknig@moz-AB0E96D7.range86-162.btcentralplus.com) (Ping timeout)
[21:47:34] <brson> bblum: subtle. is it fixable?
[21:47:37] *** Joins: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl)
[21:47:38] <Eridius> Surely there's at least one FRP GUI
[21:47:38] <pcwalton> in Rust enums work pretty well, they aren't extensible without changing the enum definition
[21:47:42] <graydon> if you're going to write idiomatic code, I suppose, yeah. not sure. I really don't do OO types very well. I'm always ready to accept the next person who shows up saying they have a faithful encoding of OO into pi calculus or whatever.
[21:47:44] <pcwalton> but otherwise it works
[21:47:56] <pcwalton> I don't mean to be combative btw
[21:48:03] <graydon> oh, record + enum-for-the-variant-part
[21:48:04] <cmr> pcwalton: Although it's worth nothing that game simulations often use a component-based model rather than inheritance
[21:48:17] <graydon> yeah, that's the clunky algebraic-types encoding. I imagine it works ok-ish.
[21:48:21] <bblum> brson: "how much overhead will we have to incur to fix it?"
[21:48:38] <pcwalton> so maybe trying to solve this use case with Deref was too clever
[21:49:11] <pcwalton> especially since it doesn't quite work for the pointer case
[21:49:20] *** Quits: saml (sam@moz-14C16814.cst.lightpath.net) (Quit: Leaving)
[21:49:22] <pcwalton> I think probably the way to make it work in Rust would be something like
[21:49:49] <bblum> brson: at least, we can avoid doing any extra sync in the case of unkillable tasks
[21:49:54] *** Parts: pupoque1 (Adium@297D6F99.EF706C30.C0C64AB3.IP) ()
[21:50:03] <pcwalton> #[autoderef_to(lock, bar)] struct Foo { lock: sync::mutex, bar: Bar }
[21:50:32] <cmr> Should https://github.com/mozilla/rust/issues/5853 be closed as a dupe of https://github.com/mozilla/rust/issues/37 ?
[21:50:41] <cmr> (or the other way around)
[21:50:53] <Eridius> pcwalton: using annotations like that is the approach I was thinking of too, although I wouldn't call it "deref" in this case since it doesn't affect what happens if you use the * operator
[21:51:00] *** Quits: Blub\0 (wry@7E3BB9D.71150E1A.237AE2BA.IP) (Quit: night)
[21:51:23] *** Quits: heftig (heftig@moz-51BCBA1E.dip0.t-ipconnect.de) (Ping timeout)
[21:52:45] <Seldaek> pcwalton: would this syntax allow deriving traits automatically though? I assume so.
[21:53:03] <pcwalton> it will not derive traits automatically, but it will make the . operator "see through"
[21:53:35] *** Quits: vosen (vosen@moz-266BA656.icpnet.pl) (Quit: Leaving)
[21:54:32] <Seldaek> pcwalton: hmm ok, so that would make my use case work as far as I can see
[21:54:43] *** Quits: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com) (Ping timeout)
[21:54:48] *** Quits: orshem (orshem@C5E06B1E.A5B6B765.E3D28531.IP) (Ping timeout)
[21:54:48] <bblum> brson: hmm... I think that if we just switch all of the context switchers to take extern fn and explicitly passed environments, then this bug will be solved 'en passant'
[21:54:51] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[21:54:54] <bblum> dammit
[21:54:56] <bblum> come back
[21:54:57] <Seldaek> haha
[21:55:04] <Seldaek> it's your day
[21:55:43] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[21:55:43] *** ChanServ sets mode: +o brson
[21:56:10] <bblum> brson: hmm... I think that if we just switch all of the context switchers to take extern fn and explicitly passed environments, then this bug will be solved 'en passant'
[21:56:22] <bblum> (also, have not seen the assertion you mentioned yet)
[21:57:39] <bblum> brson: a "quick fix" though (so we could get the runtime turned on asap) would be to do the oneshot channel thing that adds an extra xchg to the context switch path
[21:57:58] <bblum> take it back out later when we have time to overhaul the whole interface
[21:58:32] <brson> bblum: which thing in the environment is being invalidated here?
[21:58:35] <brson> in try_block
[21:59:09] <bblum> brson: the closure that switch_running_tasks_and_then passes to change_task_context captures 'f' in its environment
[21:59:33] *** Joins: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com)
[21:59:39] <bblum> in the case i observed, the function pointer itself got clobbered (though it could have been anything)
[22:00:13] <bblum> (well, i guess if it was anything, the function pointer would also have been clobbered, and would have been the earliest failure, so that was the most likely outcome)
[22:00:32] <brson> bblum: how can the function pointer itself be clobbered? they're passed by value.
[22:01:19] <bblum> brson: ah, 'f' is the user-provided closure. switch_running_tasks_and_then creates another closure to wrap 'f', and passes that one by value.
[22:01:35] <bblum> 'f' is part of the environment of the wrapper
[22:01:57] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Textual IRC Client: www.textualapp.com)
[22:02:09] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[22:02:09] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14dab1c9d to 146972eb4: 02http://git.io/N3iJvQ
[22:02:09] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[22:02:09] <brson> so is what's going on here that try_block gives away the task pointer, *then* calls the user-specified closure?
[22:02:11] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[22:02:11] <ghrust> 01[13rust01] 15bors pushed 5 new commits to 06auto: 02http://git.io/R4jJtg
[22:02:11] <ghrust> 13rust/06auto 14bd472d1 15Tim Chevalier: rustpkg: Eliminate a copy
[22:02:11] <ghrust> 13rust/06auto 142455f8e 15Tim Chevalier: Makefiles: make rustpkgtest depend on rustpkg executable
[22:02:11] <ghrust> 13rust/06auto 14e641f25 15Tim Chevalier: std/rustc/rustpkg/syntax: Support the `extern mod = ...` form...
[22:02:13] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[22:02:34] <brson> after giving away tha task that may invalidate the closure environment?
[22:02:45] <bblum> brson: pretty much, though it's only "giving away" in the sense that a handle to the kill flag is already stored in the taskgroup bookkeeping
[22:02:59] <bblum> you would not see this particular crash without linked failure
[22:03:25] <brson> right, for normal-path code to resume it needs the ~BlockedTask, not the ~Task
[22:03:41] <bblum> so it does not appear that it is giving it away, since the line simply reads "Right(blocked_task) => f(sched, blocked_task)"
[22:03:49] <tikue> brson: rust-lang.org needs an update to the code example :)
[22:04:11] *** bent is now known as bent|phone
[22:04:16] <tikue> (unless it's only supposed to reflect the last 0.X release)
[22:04:28] <Eridius> is there an issue on the fact that you can't use a lifetime parameter from the impl line as the lifetime of &self?
[22:04:28] <brson> tikue: we usually only update it at point releases
[22:04:38] *** Joins: Liothen (liothen@moz-80EF0CD7.spkn.qwest.net)
[22:04:38] <tikue> yeah that makes sense
[22:04:43] <Eridius> i.e. I can't say `fn next(&'self mut self) -> Option<&'self [A]>` because it complains about the lifetime parameter
[22:05:22] <bblum> Eridius: i think it wants you to write fn next<'a> ...
[22:05:45] <Eridius> bblum: that won't work. I need the lifetime parameter to be in the impl line
[22:05:50] <Eridius> because I'm implementing Iterator<&'self [A]>
[22:05:58] <bblum> huh.
[22:06:22] *** Joins: reyre (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[22:06:30] <bblum> should that not be Option<&'self A> then?
[22:06:42] <Eridius> bblum: no, I'm returning a slice from a buffer that I have
[22:06:46] <engla> Eridius: I hit this too when discussing iterator::Repeat. Don't know if there is an issue
[22:06:49] <Eridius> one of my field is ~[A]
[22:06:53] <bblum> Eridius: in any case, maybe it will just work if you write &mut self ?
[22:07:00] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[22:07:07] <Eridius> bblum: nope, it complains that the lifetime of self.buf.as_slice() can't outlive self.buf
[22:07:10] <kmc> hey sully maybe you can help with my trait problem, got a minute?
[22:07:20] <kmc> I think you made some relevant changes in the range of Rust commits I am upgrading over
[22:07:21] <Eridius> throwing a cast::transmute() makes it compile, but this requires unsafe
[22:08:09] <bblum> brson: anyway, my suggestion is to do the ChanOne callback thing now, and later revert it when we have a better plan
[22:08:12] <bblum> i can do this if you want
[22:09:26] <Eridius> none of the open issues look relevant. I guess I have to file one
[22:09:28] <brson> bblum: how will your proposed solution work?
[22:09:43] *** Quits: Azdle (Azdle@moz-B334B496.hfc.comcastbusiness.net) (Quit: Leaving)
[22:09:44] *** Joins: strcat (strcat@moz-61B073BC.cpe.net.cable.rogers.com)
[22:09:49] *** Joins: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com)
[22:09:49] *** ChanServ sets mode: +o pcwalton
[22:11:07] <sully> kmc: ok, what's up?
[22:11:37] <bblum> brson: inside change_task_context, let (p,c) = oneshot(); it will put the c in the cleanup job ("GiveTask(current_task, f_opaque, c)"), after run_cleanup_job() but before check_killed() it will do p.recv(), 
[22:11:40] <Luqman> Eridius: impl<'self> doesn't work?
[22:11:43] <kmc> so this impl now fails with current Rust  https://github.com/mozilla/servo/blob/master/src/components/util/tree.rs#L88  with the message "error: cannot determine a type for this bounded type parameter: unconstrained type"
[22:12:02] <bblum> brson: and in run_cleanup_job(), after calling the f(), it will do c.send(())
[22:12:14] <kmc> there should be a 1-to-1 relationship between N and NR but Rust doesn't have fundeps or any other way to express that, afaik
[22:12:22] <bblum> brson: or rather, it will do self.event_loop.callback { c.send(()) }
[22:12:36] <kmc> but what puzzles me is this did work as of about a month ago, so is there a way to contort the code back into working
[22:12:58] <strcat> graydon: I *think* I have iterators compiling to code as good as C++ ones now btw
[22:13:04] <strcat> added an intrinsic for inbounds GEP
[22:13:16] <graydon> strcat: that is very exciting
[22:13:20] <strcat> I'll show a before and after of the IR
[22:13:28] <graydon> pre-optimization?
[22:13:29] <strcat> atm we end up with 2 checks - one against the end, one against null
[22:13:31] <strcat> graydon: yeah
[22:13:34] <strcat> well
[22:13:34] <graydon> :))))
[22:13:36] <strcat> probably after
[22:13:38] <Eridius> Luqman: nope
[22:13:44] <strcat> in the post-optimization IR we have 2 ptr compares
[22:13:53] <Eridius> Luqman: I think it's not properly treating 'self as the lifetime of &mut self
[22:13:56] <strcat> because it thinks the ptr might overflow, and considers null to be different than end
[22:13:57] <Eridius> or something, not entirely sure
[22:14:08] <Luqman> Eridius: paste the code?
[22:14:10] <strcat> graydon: basically, the for loop checks for None - which is represented as null
[22:14:17] <strcat> graydon: and the iterator checks against 'end'
[22:14:22] <Eridius> Luqman: I'm whipping up a tiny sample to file an issue on. Will paste that in a minute
[22:14:27] <strcat> graydon: so atm, it actually leaves both checks due to overflow
[22:14:42] <graydon> strcat: right
[22:14:49] <graydon> wait, "due to overflow"?
[22:14:55] <strcat> graydon: non-inbounds GEP wraps
[22:15:10] <strcat> and the loop checks != end
[22:15:12] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[22:15:16] <strcat> er
[22:15:18] <strcat> I mean it checks == end
[22:15:34] <strcat> so if you do .offset(1) it does + 8 (for int)
[22:15:37] <graydon> oh, you mean, otherwise it'd merge the null check and the ==end check?
[22:15:38] <strcat> and you could miss 'end'
[22:15:50] <strcat> graydon: yeah, with inbounds it can just merge them
[22:16:13] <strcat> another issue was iter() and mut_iter() still did ptr -> int -> ptr
[22:16:18] *** Quits: azita (Azita@moz-9997F785.static.cablecom.ch) (Quit: azita)
[22:16:20] <brson> bblum: send and recv both do context switching. it seems like that presents a problem if we want to use them to work around a bug in context switching
[22:16:36] <strcat> and LLVM's "basicaa" alias analysis pass doesn't handle that :(
[22:17:05] <graydon> ok. so if there are 2 fixes -- #1 (ptr-int-ptr) and #2 (inbounds) -- which of those fixes is applied to our tree presently, and which do you have working out-of-tree?
[22:17:14] <strcat> graydon: both are out-of-tree
[22:17:28] <strcat> graydon: https://github.com/mozilla/rust/pull/8326 it's the last two here, still compiling to make sure it will work though ;]
[22:17:30] <graydon> ok. and when you apply both it still does 2-compares?
[22:17:37] <strcat> will see soon ;]
[22:17:40] <graydon> ok
[22:17:45] <strcat> graydon: also I *hope* it will vectorize, etc. now
[22:17:49] <strcat> I have examples in C++ where it does
[22:17:51] <bblum> brson: good point, hmmm
[22:17:53] <strcat> trying to match clang's IR basically.
[22:18:34] <strcat> let xs = [0.0, ..100000]; for x in xs.mut_iter() { *x += 10 }
[22:18:39] <strcat> should become SSE/AVX
[22:18:45] <strcat> at --opt-level=3
[22:19:01] * cmr would hope it becomes a memset
[22:19:03] <cmr> oh +=
[22:19:05] <cmr> duh
[22:19:31] <strcat> cmr: = 10 won't actually become a memset, become memset does byte patterns
[22:19:33] *** Quits: jyasskin_w (jyasskin@DAF66858.C60FE7DC.4065847B.IP) (Client exited)
[22:19:44] <cmr> Right-o, and that is a multibyte value
[22:19:44] <strcat> = 0 would, but not atm due to the non-inbounds gep + casts
[22:19:46] <Eridius> Luqman: https://github.com/mozilla/rust/issues/8355
[22:20:22] <strcat> cmr: it can vectorize though - in C++ it turns += or = into <double * 2> or <double * 4> operations (depending on whether AVX is on or just the baseline x86_64 with SSE2)
[22:21:05] <graydon> whee
[22:21:18] <graydon> you know how to turn avx on on rustc, yes? :)
[22:21:24] <strcat> --target-feature
[22:21:53] <strcat> rustc --target-feature sse3,sse41,sse42,avx --opt-level=3
[22:22:29] *** Quits: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP) (Ping timeout)
[22:22:36] <strcat> and on ivy/sandy bridge, vector-unaligned-mem and fast-unaligned-mem :)
[22:23:01] <strcat> graydon: avx512 in haswell is pretty insane.
[22:23:09] <strcat> they increase the # of vector registers to 32, and they are 512-bit
[22:23:17] <cmr> strcat: have you seen the talks about the Mill architecture?
[22:23:34] <bblum> brson: well, we could just use a pthread semaphore in place of the oneshot
[22:23:45] <strcat> cmr: I saw it mentioned but didn't really look into it at all
[22:23:50] <toddaaro> are there any known issues compiling rust on redhat?
[22:23:52] <bblum> or, well, whatever platform-equivalent wrapper abstraction there is
[22:24:14] <cmr> toddaaro: shouldn't be, the snap builders use some old centos
[22:24:17] <bblum> brson: initialize it to 0, and use signal for send and wait for recv
[22:24:28] *** zz_kimundi is now known as kimundi
[22:24:33] <toddaaro> cmr: something is going on with my campus network, can't get rust to compile properly on them
[22:24:54] <toddaaro> a machine I left someplace seems to be working fine, but the faster better servers? nope.
[22:24:57] <strcat> graydon: partial success
[22:24:59] <graydon> strcat: 512, 1024, if the ILP is there it's probably no harm to expose it
[22:25:05] <strcat> graydon: optimizes the 2 checks to 1 check, but doesn't vectorize yet
[22:25:09] <graydon> aww
[22:25:16] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[22:25:18] <graydon> well, bonus points! ship what you got!
[22:25:38] <strcat> graydon: http://ix.io/76c stage0, http://ix.io/76b stage1
[22:25:39] <bblum> brson: there is no risk of deadlock because if it happens on the same CPU then the signal will always happen first, and wait() will only block a scheduler thread for as long as the cleanup_job lasts
[22:25:43] <strcat>   %11 = icmp eq double* %10, %.val.i.i
[22:25:45] <strcat>   %12 = icmp eq double* %10, null
[22:25:47] <strcat>   %or.cond.i = or i1 %11, %12
[22:25:49] <strcat> that's the ugliness I killed
[22:25:53] <strcat> (both are --opt-level=3)
[22:26:10] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[22:26:36] <graydon> wow
[22:26:38] <strcat> graydon: it might vectorize with LLVM's svn, it got a lot better since 3.3
[22:26:50] *** Quits: Nisstyre (wes@moz-FD86289.netflash.net) (Quit: Leaving)
[22:27:01] *** Joins: sigma (sigma@moz-BE11A887.range109-151.btcentralplus.com)
[22:27:05] <graydon> strcat: did you add codegen tests for this?
[22:27:20] <strcat> graydon: no, I haven't
[22:27:25] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[22:27:28] <strcat> it could probably just be #[bench]
[22:27:44] <graydon> strcat: codegen tests will ensure we're emitting just-as-good as clang
[22:27:56] <cmr> graydon: I thought they just ensured we dont' regress?
[22:28:02] <graydon> I'm happy to write some up if you just want to gist the cases you're using, I can clean them up
[22:28:14] <strcat> graydon: I'm quite happy I fixed this issue though - I really didn't understand why the iterators became 2 checks
[22:28:16] <graydon> cmr: sure. so if we _get_ to clang-level, it'll prevent us from leaving it again :)
[22:28:22] <cmr> heh
[22:28:22] <strcat> finally figured it out after fixing that from_elem performance issue
[22:28:24] <cmr> good point
[22:28:31] * strcat understands how LLVM does pointers a lot more now
[22:28:41] <graydon> strcat: you've been amazingly persistent on it!
[22:29:07] *** Quits: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk) (Ping timeout)
[22:29:31] *** Joins: jyasskin_w (jyasskin@DAF66858.C60FE7DC.4065847B.IP)
[22:31:21] <strcat> I'm still not really sure if it's worth keeping around a non-unsafe 'offset'
[22:31:24] <strcat> will deal with that later
[22:31:50] <strcat> I mean... it's not like you can deref it if it's out-of-bounds
[22:32:07] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[22:32:07] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14b46a89e to 146972eb4: 02http://git.io/N3iJvQ
[22:32:07] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[22:32:07] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[22:32:07] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/NrxBAQ
[22:32:07] <ghrust> 13rust/06auto 1488b21f5 15Simon Sapin: Add to_ascii_upper, to_ascii_lower and eq_ignore_ascii_case in std::ascii
[22:32:07] <ghrust> 13rust/06auto 145b4244d 15bors: auto merge of #8231 : SimonSapin/rust/ascii-upper-lower-case, r=cmr...
[22:32:08] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[22:33:14] *** Joins: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk)
[22:33:23] <brson> bblum: i'm very reluctant to give up that much ground in the context switching function
[22:34:06] <bblum> brson: sure, it depends how quickly you wanna get the new runtime out the door
[22:34:16] *** bent|phone is now known as bent
[22:34:22] <bblum> brson: we could also just convert the whole interface to use the extern fn trick now
[22:35:48] <bblum> i'm just suggesting this as a trick that could be implemented in ten minutes and then put back later
[22:36:38] *** Quits: busylizzy (lisa@85228838.12D0DC84.211374C4.IP) (Ping timeout)
[22:37:10] <Eridius> crud. using cast::transmute() to force the pointer to have the desired lifetime doesn't actually freeze self (probably because I can't annotate &mut self with the lifetime parameter)
[22:37:29] <Eridius> (this is in my attempt to implement a ChunkIter for generic iterators)
[22:37:29] *** Quits: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[22:37:51] <Eridius> so either I document the fact that the pointer can in fact change out from under you if you call .next() again, or just give up and use ~[A] instead of &[A]
[22:38:22] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[22:38:59] <strcat> Eridius: it's not memory safe so documenting wouldn't be enough
[22:39:04] <strcat> it'd need to be unsafe
[22:39:27] <Eridius> strcat: yep, I was just testing that, and you're right. I can destroy the iterator entirely and still have the pointers outstanding
[22:39:40] <strcat> Eridius: well the lifetime is supposed to be tied to the container
[22:39:46] <strcat> not the iterator
[22:39:46] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[22:39:56] <graydon> strcat: earlier bblum was saying that you had concerns about exposing a reflection system?
[22:40:04] <ggherdov_> [OT] just in case anybody wants to compete in the ICFP programming contest next w/e, deadline for registration is 90 minutes from now. Look: http://research.microsoft.com/en-us/events/icfpcontest2013/
[22:40:11] <strcat> graydon: I forget what I said, if I did say anything ;p
[22:40:30] <graydon> strcat: I think it had to do with the opportunity to violate visibility rules
[22:40:37] <graydon> set private fields say
[22:40:39] <cmr> strcat: It was related to %? and private fields
[22:40:40] <strcat> I have concerns about the existing reflection allowing you to read priv fields without unsafe
[22:40:50] <graydon> ok. if it were unsafe, that'd do?
[22:40:54] <strcat> yes
[22:41:03] <strcat> I'm fine with it if we don't brand it as safe ;p
[22:41:05] <graydon> like if we split the APIs into safe-that-is-public and unsafe-that-is .. ok
[22:41:09] <strcat> yeah
[22:41:15] <bblum> well but wait
[22:41:21] <bblum> if you do fmt!("%?", thing)
[22:41:25] <bblum> you can just parse the fields ouot
[22:41:27] <graydon> _reading_ or setting?
[22:41:44] <strcat> graydon: reading seems wrong too, without unsafe
[22:41:46] <bblum> personally i only care about prohibiting writing
[22:41:49] <bblum> but fmt! lets you read
[22:42:00] <graydon> strcat: I think it's probably the case that any sufficiently motivated party can _read_ private state out of memory on a machine they're executing on
[22:42:01] <kmc> so is there a common pattern in Rust to work around the lack of functional dependencies or associated types in traits?
[22:42:19] *** Quits: dim-an (ermolovd@moz-FE167E47.nationalcablenetworks.ru) (Quit: dim-an)
[22:42:22] <strcat> graydon: yes, but they'd need unsafe {}
[22:42:27] <strcat> to use raw ptrs
[22:42:28] <brson> bblum: what is the extern fn trick and how will it solve the problem? I am imagining it solves the problem by putting the enviroment in the heap, which we could also do by changing the closure to ~fn, but one of the core ideas here is that the environment is on the stack
[22:43:06] <graydon> strcat: they could call perfectly safe APIs that just happen to give them information that reveals info they can use
[22:43:12] <strcat> graydon: just imagining some future usage of rust where unsafe {} is disallowed and the stdlib isn't there - only curated safe libs
[22:43:18] <graydon> strcat: my general feeling is that "safe" does not mean "sandbox", it just means memory-safe
[22:43:33] <bblum> brson: the environment would be passed in a struct on the stack
[22:43:44] <graydon> strcat: and that attempts to sandbox at a language level will cause us to fall into the java security theatre hole
[22:44:18] <cmr> ggherdov_: thanks!
[22:44:25] *** Joins: mudpit (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP)
[22:44:28] *** Joins: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net)
[22:44:54] <brson> bblum: on the calling tasks's stack?
[22:45:04] <mudpit> quick question, if I use Process::new to spawn a process, and the containing main task dies (via fail or similar), what happens to the spawned process?
[22:45:20] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Ping timeout)
[22:45:27] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[22:45:30] <graydon> strcat: I mean, if "curate the APIs" is the solution then I'm find "curating" reflection out of such a subset also. but if you can call os::run or even .. things that reveal timing info, I imagine you can dig your way out of observation-sandbox pretty quick
[22:45:37] *** Joins: jensnockert (jensnocker@moz-A5E5C224.mobileonline.telia.com)
[22:45:42] <graydon> strcat: even perfectly safe stuff
[22:45:46] <graydon> "memory safe"
[22:45:50] <strcat> graydon: yeah, you could - but fmt! is a language feature
[22:46:00] *** Joins: busylizzy (lisa@85228838.12D0DC84.211374C4.IP)
[22:46:02] <Eridius> grr. I don't see any way to yield &[A] because I simply cannot put a lifetime parameter on &mut self without rustc complaining
[22:46:08] <Eridius> and without that, I can't tie the lifetime of the result to self
[22:46:13] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[22:46:16] <strcat> graydon: if you could choose to not import it, I guess I wouldn't care very much
[22:46:17] <Eridius> even though I'm yielding &'self [A], that's apparently not good enough
[22:46:20] <pcwalton> &'self mut self?
[22:46:26] <Eridius> pcwalton: https://github.com/mozilla/rust/issues/8355
[22:46:41] <graydon> strcat: I see. ok. I think we can arrange _something_ suitable for that problem.
[22:46:53] <Eridius> basically, it complains that it wanted a concrete lifetime but found a bound lifetime parameter.
[22:47:06] <Eridius> it even says it expected the concrete lifetime &'self, but it doesn't recognize that the parameter I gave it was... 'self
[22:47:20] <bblum> brson: yes, and then moved into the cleanup job
[22:47:31] <pcwalton> Eridius: hmm, bug I guessd
[22:47:33] <pcwalton> guess
[22:47:38] <Eridius> hence why I filed an issue
[22:47:40] <mudpit> so is Process::new like a spawn, a spawn_supervised, or other? (i.e. how are the failure modes linked?)
[22:48:08] <bblum> brson: (inside a linear permission token)
[22:49:15] <strcat> graydon: we are actually starting to generate good IR in many cases ;P
[22:49:30] <graydon> strcat: :)
[22:49:52] <graydon> strcat: you might want to take a look at match { ... }, I think there's still room there
[22:49:57] <strcat> yeah, and bools
[22:50:27] <strcat> + I want some really terrible initial TBAA ;p
[22:50:55] <mudpit> nvm got it, the child task doesn't go down
[22:50:59] <strcat> I think that'd just mean another Load/Store taking a ty::t and outputting a metadata node with the string
[22:51:08] <strcat> + a little C++ LLVM pass, loaded as a .so
[22:51:12] <graydon> like I think we compile in an empty match-guard block with a jump->jump-> on every arm, even though few arms have guards
[22:51:17] <strcat> can just start with @ does not alias ~
[22:52:48] <strcat> and tbaa.struct to make LLVM not generate copies of padding ;]
[22:52:51] <strcat> lots of little wins
[22:53:25] *** kimundi is now known as zz_kimundi
[22:54:25] <brson> bblum: many of the uses of deschedule_running_task_and_then expect to be able to write into the calling task's stack. this is pretty much how I/O works - create a buffer on the stack; block the task; write to the buffer; unblock the task. just passing the environment as a struct won't solve anything if that struct contains a bunch of pointers into the unwound stack
[22:54:29] *** Quits: tchoma (tchoma@moz-BE33DA21.fw1.sfo1.mozilla.net) (Ping timeout)
[22:55:25] <bblum> brson: the environment would be inside a token that you would have to give away if you wanted to give the task to the scheduler
[22:55:32] <bblum> brson: and the token would have a method fn get
[22:55:41] <bblum> er, fn get_env(&'a self) -> &'a mut E
[22:56:34] <jensnockert> If I have two nested loops, how can I break out of both?
[22:56:35] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[22:56:53] <cmr> jensnockert: labeled break!
[22:56:57] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[22:57:02] <jensnockert> cmr: What is the syntax?
[22:57:09] <cmr> not sure!
[22:57:16] * jensnockert has been coding for 24h, isn't totally aware anymore.
[22:57:21] <cmr> 'foo ... { ... { break 'foo; } }
[22:57:22] <cmr> I think
[22:57:24] <dbaupp> jensnockert: 'label: loop { ... break 'label; .. }
[22:57:38] <dbaupp> (works with while too, and *should* work with for, but doesn't currently.)
[22:58:26] <strcat> I think it's just a parser-level issue with `for`
[22:58:28] *** Joins: tchoma (tchoma@moz-BE33DA21.fw1.sfo1.mozilla.net)
[22:58:38] <bblum> brson: the drawback about the extern fn / permission token trick is that it's polymorphic over the environment type instead of existential, so it would make the context switcher have to get monomorphized once per different environment that it's called with
[22:58:47] <strcat> probably just need to add "for" to a condition somewhere
[22:58:54] <jedisct1> Hi guys. Noob question, sorry. I get "Illegal anonymous lifetime: anonymous lifetimes are not permitted here" here, on the stream: &mut TcpStream line : https://gist.github.com/jedisct1/428880216c853f802c99/raw
[22:59:38] <jedisct1> The TcpStream value is just what I get from Cell::new(listener.accept().unwrap()).take()
[23:00:01] <jedisct1> I get what the error means, but how to fix it?
[23:00:03] <strcat> graydon: https://github.com/thestinger/rust-seccomp/blob/master/seccomp.rs#L98 there's always this way of handling the OS part
[23:00:47] * strcat wishes we had support for extern varargs fns
[23:01:32] <brson> bblum: are you saying that the environment couldn't contain pointers into the stack?
[23:01:54] <bblum> brson: no, it definitely could
[23:02:03] <bblum> brson: should i draw up some example code?
[23:02:49] <brson> bblum: ok
[23:02:54] <graydon> strcat: :))
[23:03:20] <erickt__> strcat / dbaupp: would labeled fors need a computed goto / invoke / state machine to work?
[23:03:36] <strcat> erickt__: nope, they just desugar to 'loop'
[23:03:41] <strcat> erickt__: they're a parser feature now
[23:03:58] <cmr> jedisct1: You cannot contain &foo in a struct, only &'bar foo (ie, you need an explicit lifetime)
[23:04:14] <erickt__> strcat: neato
[23:04:24] <sully> woo!
[23:04:25] <strcat> 'for pattern in iterator { body }' becomes 'let mut it = &mut iterator; loop { match it.next() { Some(pattern) => { body }, None => break } }
[23:04:30] <sully> managed to fix a match codegen bug!
[23:04:57] <jedisct1> cmr: What would be the lifetime here? stream: &'self mut TcpStream ?
[23:04:57] <strcat> erickt__: a state machine generator would be needed for `yield`, to avoid manually implementing the iterator state machines
[23:05:04] <sully> after like two days tracking the bug down, and two days thinking about how to fix it
[23:05:16] <sully> the fix was four lines of code
[23:05:28] <cmr> jedisct1: yes, and you need struct HttpRequest<'self>
[23:05:46] <strcat> erickt__: like 'fn walk(tree: &Tree) { tree.left.map(walk); yield tree.value; tree.right.map(walk) }
[23:06:06] <strcat> instead of manually implementing a struct with a stack of state
[23:06:10] *** Quits: brianm (brianm@moz-E7EE7321.ptr.us.xo.net) (Quit: Leaving...)
[23:06:25] <cmr> sully: don't you love those bugs?
[23:06:39] <strcat> it's not quite the same thing as a state machine generator making gotos
[23:06:41] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[23:06:45] <cmr> sully: I once spent a week trying to find a really really really obscure non-deterministic C++11 threading failure that came down to a missing #include
[23:06:56] <strcat> it would just take recursion + yields and makes a struct + next() method
[23:06:57] <erickt__> strcat: yeah. I assume you saw the yield RFC?
[23:07:00] <strcat> erickt__: yeah
[23:07:22] <cmr> sully: it was linux-only (this was a cross-platform codebase)
[23:07:29] *** Joins: dwhyte (dwhyte@1922756A.EDC594B0.7BF4A4B0.IP)
[23:07:32] <strcat> graydon: if only I knew why it wouldn't vectorize ;p
[23:07:40] <strcat> looks pretty darn close to the C++... except for having the length stored
[23:07:42] <cmr> sully: anyway, what bug?
[23:07:47] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[23:07:55] <erickt__> strcat: really I'm just trying to find more places to justify state machine support in rust :)
[23:07:59] <strcat> clang is outputting TBAA nodes though
[23:08:22] * strcat is not good at interpreting "phi"
[23:08:28] <olsonjeffery> brson: how harecore do you want to be, in aio, in terms of making sure that all actions are non-blocking, even in cases where making them so would be totally artificial (tcp_bind, for example)
[23:08:30] <strcat> such a weird thing
[23:08:53] <cmr> strcat: I haven't been able to figure out what the heck it does
[23:08:59] <jedisct1> cmr: does impl HttpRequest need to be changed as well? I get Illegal lifetime 'self: the `self` lifetime must be declared on that one
[23:09:11] <pcwalton> wow, making rustc parse foo::T>::bar::<U> is a 1,000 line patch so far
[23:09:13] <cmr> jedisct1: yes, impl<'self> HttpServer<'self> I think
[23:09:18] <pcwalton> didn't expect so much fallout
[23:09:19] <pcwalton> oh well
[23:09:22] *** Joins: strgeekint (Mibbit@19AA6530.93384D21.67D94052.IP)
[23:09:32] <pcwalton> foo::<T>::bar::<U> rather
[23:09:45] <dbaupp> erickt__: I replied to that state machine gist btw :)
[23:09:47] <strcat> cmr: it lets you do stuff based on the block you came from
[23:09:51] <strgeekint> rusti: 2^15
[23:09:55] -rusti- 13
[23:10:00] <strcat> cmr: for a human, it feels similar to the pains of a language with COMEFROM ;p
[23:10:12] <pcwalton> cmr: a variable gets a different value depending on the block it came from
[23:10:15] <pcwalton> it's part of SSA form
[23:10:23] <strgeekint> rusti: 2**7.33421
[23:10:24] -rusti- pastebinned 8 lines of output: http://sprunge.us/aFeK
[23:10:32] <jensnockert> dbaupp: <3
[23:10:47] <dbaupp> rusti: 2.0.pow(&7.33421)
[23:10:48] -rusti- pastebinned 14 lines of output: http://sprunge.us/IEVG
[23:10:59] <dbaupp> rusti: 2.0f.pow(&7.33421)
[23:11:00] -rusti- 161.36792127
[23:11:02] <jedisct1> cmr: https://gist.github.com/jedisct1/428880216c853f802c99 now I get "cannot infer an appropriate lifetime due to conflicting requirements" on HttpRequest { stream: stream }
[23:11:10] <dbaupp> jensnockert: ?
[23:11:19] <jensnockert> dbaupp: For showing me the syntax.
[23:11:24] <erickt__> dbaupp: now that I think about it, I'm not sure if `pattern_matching.rs` will parse :(
[23:11:38] <dbaupp> erickt__: which part?
[23:11:49] <cmr> jensnockert: now you need fn new<'a>(stream: &'a mut ...) -> HttpRequest<'a> I think
[23:11:55] <cmr> erm, @ jedisct1
[23:11:59] <cmr> jedisct1: not positive about that though
[23:12:04] * jensnockert hugs cmr.
[23:12:10] *** Joins: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net)
[23:12:59] <jedisct1> cmr: nope :(
[23:13:11] <dbaupp> erickt__: oh, no LL(finite) way to parse `match Foo(bar, baz, qux);` vs `match Foo(bar, baz, qux) { ... }`?
[23:13:20] <erickt__> the `match if some_thing { `bar } else if other_thing { 'baz } else { 'end }`. Wouldn't the parser have to read over N tokens to determine if the match is really a computed goto?
[23:13:38] <brson> olsonjeffery: softcore
[23:13:44] <olsonjeffery> works for me
[23:13:58] <dbaupp> erickt__: isn't that `computed.rs`? but, yeah, I agree.
[23:14:00] <erickt__> dbaupp: ack, that one too. If I remember correctly we're LL(1)
[23:14:00] <brson> olsonjeffery: read and accept seem like the important ones
[23:14:02] <strgeekint> println(x);let x=12;
[23:14:20] <strgeekint> rusti: println(x);let x=12;
[23:14:20] -rusti- <anon>:5:17: 5:18 error: unresolved name `x`.
[23:14:20] -rusti- <anon>:5          println(x);let x=12;
[23:14:21] -rusti-                           ^
[23:14:21] -rusti- error: aborting due to previous error
[23:14:21] -rusti- application terminated with error code 101
[23:14:51] <dbaupp> erickt__: I guess using a different keyword would solve the match Foo(...) one... and presumably the other one too, if done right.
[23:15:23] <erickt__> dbaupp: yeah, I think so.
[23:15:48] *** Quits: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl) (Client exited)
[23:16:17] <strgeekint> Is Haskell-style pattern matching/deconstruction supported?
[23:17:05] <dbaupp> rusti: struct Yes(int, float) match Yes(1, 1.0) { Yes(2, _) => 0.0, Yes(a, b) => (a as float) + b }
[23:17:05] -rusti- <anon>:5:32: 5:37 error: expected `;` but found `match`
[23:17:06] -rusti- <anon>:5          struct Yes(int, float) match Yes(1, 1.0) { Yes(2, _) => 0.0, Yes(a, b) => (a as float) + b }
[23:17:06] -rusti-                                          ^~~~~
[23:17:06] -rusti- application terminated with error code 101
[23:17:13] <dbaupp> rusti: struct Yes(int, float); match Yes(1, 1.0) { Yes(2, _) => 0.0, Yes(a, b) => (a as float) + b }
[23:17:14] -rusti- 2
[23:17:41] <bblum> brson: ehhhh, the problem with the type system trick is basically all of the usage sites have decoupled ways that they pass the task around with relation to the environment, but "usually it still works out in the end"
[23:17:55] <bblum> mostly involving putting the task inside a cell
[23:18:25] <bblum> i am no longer confident that the type system solution would be anything more than smoke and mirrors
[23:18:38] <dbaupp> erickt__: I feel like this proposal would actually make the yield state-machine compiler much easier, too.
[23:19:08] <jedisct1> cmr: https://gist.github.com/jedisct1/428880216c853f802c99
[23:19:40] <erickt__> dbaupp: I think so too
[23:19:43] <dbaupp> erickt__: insert a goto-point just after each call to yield and convert the yields to return, and so each call to .next() jumps straight to where it left off.
[23:20:45] <sully> cmr: https://github.com/mozilla/rust/issues/6909
[23:21:08] <strgeekint> let mut x=if true {return 1;} else {return 0;}
[23:22:13] <Eridius> strgeekint: what are you trying to do?
[23:22:38] <erickt__> dbaupp: hrm, that may be tricky to guarantee safety.
[23:23:05] <erickt__> dbaupp: isn't that essentially a long jump between functions?
[23:23:14] <mw> dbaupp & erickt__: Hi, I've been thinking about how to implement a C#-like yield for Rust (see http://michaelwoerister.github.io/2013/07/26/Iterator-Blocks.html)
[23:23:26] <cmr> strcat: ^
[23:23:45] <brson> toddaaro: now that you've fixed some of the blatant problems in the scheduler, how are our new workstealing numbers compared to oldsched and to the shared queue?
[23:24:02] <dbaupp> erickt__: maybe?
[23:24:04] <erickt__> mw: did you see this issue? https://github.com/mozilla/rust/issues/7746
[23:24:20] <mw> dbaupp & erickt__: I came to the conclusion that a desugaring/ast transformation would be nice, but Rust can't have gotos in the AST
[23:24:23] <toddaaro> brson: still no clean testsuite, but quite a bit better
[23:24:31] <mw> dbaupp & erickt__: yes, I did
[23:24:34] *** Joins: jgilbert_ (jgilbert@moz-7B0110AD.mv.mozilla.com)
[23:24:35] <dbaupp> erickt__: I imagine we may have to put restrictions on what's legal in the matches, at least until we can prove that it's safe.
[23:24:38] <bblum> brson: also converting to extern just wouldn't fix the problem with try_block, since switch_running_tasks_and_then would *also* blatantly violate the sequence that the trick would be trying to enforce
[23:24:50] *** Quits: jgilbert (jgilbert@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[23:24:54] <bblum> brson: however, i do have another idea, which is basically reference counting
[23:25:00] <dbaupp> erickt__: (e.g. only implicitly copiable types without lifetimes.)
[23:25:16] <mw> dbaupp & erickt__: and that a goto would have to honour destructors correctly, which does not seem too easy 
[23:25:20] <toddaaro> brson: spent a fair bit of time trying to get going on a proper benchmarking server my lab group has, but something about rust is uncompilable so no clue what to do there, it just hangs at 100% cpu use and never finishes
[23:25:39] <toddaaro> no idea what about the environment would do that, how to document for reproduction, etc.
[23:25:43] <toddaaro> but it is a pretty major problem
[23:25:46] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[23:25:49] <cmr> toddaaro: how long has it been "hanging"?
[23:25:55] <toddaaro> cmr: 82 minutes on this run
[23:25:56] <cmr> Did you look at it in gdb to see where it's stuck?
[23:25:58] <cmr> Is it swapping?
[23:26:01] *** jgilbert_ is now known as jgilbert
[23:26:05] <toddaaro> no swapping, no allocation going on
[23:26:16] <strgeekint> rusti: f=lambda x: x^2
[23:26:17] -rusti- <anon>:5:18: 5:19 error: expected `;` or `}` after expression but found `x`
[23:26:17] -rusti- <anon>:5          f=lambda x: x^2
[23:26:17] -rusti-                            ^
[23:26:17] -rusti- application terminated with error code 101
[23:26:24] <toddaaro> I guess I should gdb + breakpoints and try and figure out what is going on
[23:26:28] <dbaupp> mw: yeah, erickt__ and I have a wip "proposal" for a limited form of goto using match (3 possible syntaxes: https://gist.github.com/huonw/6145412)
[23:26:29] <cmr> rusti: let f = |x| x*x
[23:26:30] -rusti- <anon>:6:4: 6:5 error: expected `;` but found `}`
[23:26:30] -rusti- <anon>:6     };
[23:26:30] -rusti-              ^
[23:26:30] -rusti- application terminated with error code 101
[23:26:32] <cmr> rusti: let f = |x| x*x;
[23:26:33] -rusti- <anon>:5:21: 5:22 error: the type of this value must be known in this context
[23:26:33] -rusti- <anon>:5          let f = |x| x*x;
[23:26:33] -rusti-                               ^
[23:26:34] -rusti- error: aborting due to previous error
[23:26:34] *** concrete.mozilla.org sets mode: +M 
[23:26:36] -rusti- application terminated with error code 101
[23:27:08] <cmr> rusti: let f = |x: T|<T: Mul> x*x
[23:27:08] -rusti- <anon>:5:23: 5:24 error: unexpected token: `<`
[23:27:09] -rusti- <anon>:5          let f = |x: T|<T: Mul> x*x
[23:27:09] -rusti-                                 ^
[23:27:09] -rusti- application terminated with error code 101
[23:27:10] <cmr> heh
[23:27:17] <cmr> is it even possible to have generic closure literals?
[23:27:37] <toddaaro> brson: I just put a PR up to get the current workstealing in, feel free to not merge it yet but it is there if you want to provide feedback
[23:27:55] *** Parts: strgeekint (Mibbit@19AA6530.93384D21.67D94052.IP) ()
[23:30:15] *** erickt__ is now known as erickt
[23:30:48] *** Quits: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com) (Quit: ecr)
[23:30:54] *** Joins: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com)
[23:31:01] <erickt> ack, it seems +r just got set. mw, sorry if I repeat myself
[23:31:07] <erickt> mw: I think we could do a safe constrained version of a state machine using gotos. As in `match 'start { 'start => { ..; continue 'step; }, 'step => {continue 'end } 'end => {} }`. I think it has the same semantics as our labeled loops, just that it'd jump between different states instead of just exiting the loop pattern
[23:31:13] <erickt> mw: dbaupp and I have been chatting about other variations on https://gist.github.com/huonw/6145412
[23:31:34] *** concrete.mozilla.org sets mode: -M 
[23:31:49] *** Joins: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP)
[23:32:37] <ecr> testing...
[23:33:06] <cmr> rusti: struct Foo { #[bar] x: uint }
[23:33:07] -rusti- ()
[23:33:11] <cmr> interesting
[23:33:17] <cmr> not unexpected, but interesting.
[23:33:24] <erickt> mw: supporting computed gotos would be great, but I think that would require reifying jump locations, which would mean those jump locations could be returned from functions, which would probably be dangerous
[23:33:26] *** Quits: mudpit (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[23:33:29] <mw> erickt: what seemed problematic to me with `yield` where stack objects implementing Drop and a lifetime crossing a yield  
[23:33:37] <ecr> brson, bblum: I just noticed that the Rust manual says we do preemptive task scheduling.
[23:33:46] <bblum> ecr: yeah that's false
[23:33:46] <ecr> maybe we should update that?
[23:33:51] *** Quits: ozten (ozten@moz-DD3B00B4.hsd1.wa.comcast.net) (Quit: ozten)
[23:33:52] <bblum> that's never been true
[23:34:08] <erickt> mw: yeah that's what I'm afraid of
[23:35:25] <bblum> brson: how about this: under valgrind (or otherwise in cfg(test)) using a semaphore; when trying to be fast, using an AtomicBool and spinning on it
[23:35:28] <dbaupp> erickt: why would returning jump locations be dangerous?
[23:35:31] <mw> erickt: when you do a simple desugaring into a struct, those stack variables would become struct fields, making it 'safe' again, but that would change semantics 
[23:35:42] <dbaupp> erickt: ... oh you mean if you could jump to them outside the function?
[23:36:00] <strcat> mw: you also need it to disallow moving out of it, like being a struct field ensures
[23:36:07] <erickt> dbaupp: yeah
[23:36:28] <sully> kmc: does the implementation of TreeUtils depend on N being a tree node?
[23:36:51] <dbaupp> erickt: presumably it'd only be legal in a `match` of the appropriate type?
[23:37:14] <sully> kmc: oh, looks like it definitely does...
[23:37:20] <kmc> sully: yeah, we need to call first_child() and whatever
[23:37:25] <dbaupp> erickt: (and with privacy, you could make it impossible to make such a match, maybe?)
[23:37:41] *** Joins: maikklein2 (maik@moz-89870D9B.dip0.t-ipconnect.de)
[23:38:12] <mw> strcat: yeah, I have not thought much about move semantics yet
[23:39:04] <erickt> dbaupp: you could make these reified regions a hidden enum inside the function. Then it would be meaningless to return them from a function because you couldn't name their type
[23:39:44] <mw> strcat: C# has it a bit easier with yield because it does not have to make many guarantees
[23:39:45] <dbaupp> erickt: I mean, hide each enum variant
[23:40:01] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[23:40:02] <erickt> dbaupp: thats what I mean too :)
[23:40:13] <erickt> dbaupp: unfortunately I need to now catch a train
[23:40:37] <dbaupp> rusti: mod Foo { pub enum Foo { priv A, priv B } fn mk_foo() -> Foo { A } } Foo::A
[23:40:37] -rusti- <anon>:5:78: 5:84 error: unresolved name `Foo::A`.
[23:40:38] -rusti- <anon>:5          mod Foo { pub enum Foo { priv A, priv B } fn mk_foo() -> Foo { A } } Foo::A
[23:40:38] -rusti-                                                                                        ^~~~~~
[23:40:38] -rusti- error: aborting due to previous error
[23:40:38] -rusti- application terminated with error code 101
[23:40:43] <strcat> ugh, why does this refuse to vectorize >.<
[23:40:45] <dbaupp> rusti: mod Foo { pub enum Foo { priv A, priv B } fn mk_foo() -> Foo { A } } Foo::mk_foo()
[23:40:46] -rusti- <anon>:5:78: 5:89 error: unresolved name `Foo::mk_foo`.
[23:40:46] -rusti- <anon>:5          mod Foo { pub enum Foo { priv A, priv B } fn mk_foo() -> Foo { A } } Foo::mk_foo()
[23:40:46] -rusti-                                                                                        ^~~~~~~~~~~
[23:40:46] *** concrete.mozilla.org sets mode: +M 
[23:40:47] -rusti- error: aborting due to previous error
[23:40:49] -rusti- application terminated with error code 101
[23:41:00] <cmr> strcat: maybe there's a pass you don't have?
[23:41:22] <strcat> we have the same passes as clang 3.3
[23:41:33] <strcat> I've seen it vectorize before
[23:41:41] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[23:41:49] <erickt> brson: I got to run, but I just finished rebasing my str-remove-trailing-nulls PR: https://github.com/mozilla/rust/pull/8296
[23:42:04] *** Quits: Earnestly (earnest@3F74F9E2.8E6FE497.30311652.IP) (Ping timeout)
[23:42:08] <strcat> http://ix.io/76g so close to something it should be able to vectorize
[23:42:17] <strcat> from http://ix.io/76h
[23:42:20] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[23:42:25] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[23:42:38] *** Quits: Vert (quassel@moz-15870EF5.skybroadband.com) (Ping timeout)
[23:42:45] <strcat> I guess it's unhappy about aliasing
[23:42:52] *** Parts: mw (mw@moz-3B2CBD34.adsl.highway.telekom.at) ()
[23:43:19] <kmc> sully: I think maybe I can just merge the two traits
[23:43:29] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[23:43:32] <kmc> but I can't have both ref.foo() and node.foo() syntax because one of them won't be Self
[23:43:57] <brson> Eridius: thanks
[23:44:29] <brson> er. erickt
[23:44:34] <brson> Eridius: thank you too, though
[23:45:05] *** Joins: dew (Instantbir@moz-8A63B53.dhcp.stls.mo.charter.com)
[23:45:14] <cmr> https://github.com/cmr/rustdoc_ng/blob/wip/visit.rs#L24
[23:45:20] <cmr> Why do those give visit.rs:24:71: 24:73 error: cannot borrow an `&mut` in a `&` pointer; try an `&mut` instead
[23:45:22] <cmr> visit.rs:24         m.structs    = m.structs.mut_iter().filter(|x| self.visit_item(*x)).transform(|x| x.clone()).to_owned_vec();
[23:45:24] <cmr>                                  
[23:45:26] <cmr> strcat: ^ ?
[23:45:39] <cmr> I don't really understand the error
[23:45:44] *** concrete.mozilla.org sets mode: -M 
[23:45:55] <engla> strcat: is it about alignment?
[23:46:13] <strcat> engla: could be
[23:47:19] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[23:47:27] <Eridius> cmr: random thought: since you're replacing m.structs anyway, try using .consume_iter()?
[23:47:34] <cmr> Eridius: perhaps!
[23:47:42] <engla> cmr: you'd need to use .filter_map instead, so that you own the iterator element (inside the closure)
[23:47:42] <cmr> Eridius: instead of mut_iter?
[23:47:45] <Eridius> but yeah that error message looks rather confusing
[23:47:46] <Eridius> cmr: yeah
[23:48:05] <dbaupp> cmr, Eridius: probably won't work: requires moving out of a &mut pointer which is illegal
[23:48:14] <cmr> ah yes
[23:48:23] * Eridius opens up the url to read further
[23:48:30] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[23:48:31] <Eridius> oh ok, I didn't know visit_item() took a &mut
[23:48:34] <dbaupp> I think engla's suggestion would work though.
[23:48:51] <cmr> it gets me a different error, which is promising
[23:48:53] *** Joins: samx (sami@moz-48EC0983.dyn.optonline.net)
[23:48:56] <dbaupp> .filte_map(|x| if self.visit_item(x) {Some(x)} else {None}) or something
[23:49:15] <dbaupp> you could even put the clone in there, I guess.
[23:49:17] <Eridius> m.structs.consume_iter().filter_map(|x| ... ) maybe
[23:49:19] <engla> it makes sense. filter is holding the element, so you can't mutate it
[23:49:44] <cmr> Eridius: can't consumer it, m is &mut
[23:50:03] <Eridius> ok I think the error message is confusing because it says "in a `&` pointer" instead of "from a `&` pointer"
[23:50:05] <dbaupp> cmr: it's probably more efficient to do something like:
[23:50:06] <brson> bblum: i'm not sure just now. I'm going to disable some tests and try to land this code and we can think about it some more
[23:50:07] <Eridius> cmr: ooh
[23:50:14] *** Joins: heftig (heftig@moz-88B5382A.dip0.t-ipconnect.de)
[23:50:36] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[23:50:45] <dbaupp> cmr: let mut foo = ~[]; swap(m.struct, &mut foo); m.structs.extend(foo.consume_iter(). ... )
[23:50:51] <Eridius> I thought you were allowed to say m.foo = something_that_consumes(m.foo)
[23:51:08] <bblum> brson: ok with me, but be warned, this crash can happen with basically any linked failure test at all
[23:51:57] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[23:52:10] <strcat> meh
[23:52:25] <strcat> need to teach TypeContents about something like NoAlias ;p
[23:52:33] * strcat tries ~[T]
[23:52:43] <cmr> engla: no, I can't use filter_map, its interface is not jiggy with what I want to do at all
[23:52:47] <cmr> engla: I want to outright-remo
[23:52:49] <cmr> nevermind
[23:52:52] <Eridius> cmr: you're filtering and then mapping
[23:52:55] <Eridius> that's what filter_map does
[23:53:23] <cmr> Eridius: I'm not *quite* mapping (besides the clone, which is not part of what I want to be doing really, just there to appease the compiler)
[23:53:58] *** Quits: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se) (Client exited)
[23:54:20] <cmr> Ah I see how to do it now
[23:54:36] <engla> cmr: you can do it!
[23:54:46] <cmr> The interface before was "potentially mutate and return false if you want the item to be exluded from the output"
[23:54:57] <cmr> s/false/None and s/true/Option<()> and that's what you have
[23:55:01] <cmr> erm, Some(())
[23:55:13] <maikklein2> does anyone know a graphics engine with a C api?
[23:55:19] <Eridius> maikklein2: OpenGL?
[23:55:20] <cmr> maikklein2: SDL?
[23:55:32] <engla> cmr: surely you don't want to map each element to ()?
[23:55:59] <maikklein2> yeah I can use OpenGL atm, so I thought I might use a graphics engine
[23:56:07] <cmr> hm
[23:56:10] <maikklein2> cmr, I thought sdl is only for windows?
[23:56:12] <cmr> let me back up a step
[23:56:14] <cmr> maikklein2: hah, no
[23:56:18] <cmr> maikklein2: sdl is everywhere
[23:56:29] <maikklein2> cmr, I mean windowing
[23:56:42] <maikklein2> cmr, like glfw
[23:56:44] <engla> cmr: .filter_map is both .filter and .transform in one step
[23:56:53] <cmr> maikklein2: it does much much more than glfw
[23:57:29] <maikklein2> cmr,  so I could create something like space invaders with just sdl?
[23:57:29] <dbaupp> cmr: .filter(foo).transform(bar) == .filter_map(|x| if foo(&x) {Some(bar(x))} else {None})
[23:57:48] <cmr> engla: Basically what I want is to call visit_item on everything, and iff it returns false, don't include that item in the output
[23:57:56] <cmr> I would really really like to avoid copies
[23:57:59] <cmr> it just needs to be mutating
[23:58:09] <engla> cmr: if you want to include it, just pass Some(x) in .filter_map
[23:58:09] <cmr> the fact that there is a clone call hurts me
[23:58:21] <cmr> it means the entire AST will be cloned in every plugin
[23:58:25] <cmr> which is awful
[23:58:34] <dbaupp> cmr: the swap + consume_iter avoids that
[23:58:43] <bblum> brson: fwiw, i believe that the AtomicBool plan is the fastest we can possibly solve the problem; in the 1-cpu case it will have no contention (obviously) and in the cross-cpu case there will only be 1 cacheline bounce
[23:58:45] <engla> ok, I didn't look at that
[23:59:10] <Eridius> dbaupp: still involves an extra allocation (for the ~[]), which is unfortunate
[23:59:20] <dbaupp> Eridius: it needs to happen anyway
[23:59:26] <bblum> (assuming that we're ok with spinning while another cpu is in the 'critical section', which i am, since it's what kernel spinlocks do anyway)
[23:59:28] <Eridius> it does?
[23:59:33] <engla> not much you can do when removing items from an array
[23:59:48] <dbaupp> Eridius: at least... not doing that will involve removing itesm from the interior of the array: O(n): much worse than an allocation
[23:59:57] <dbaupp> *not allocating

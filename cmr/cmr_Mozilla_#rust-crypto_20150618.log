[00:47:21] <bascule> Ilari: know what's confusing?
[00:47:38] <bascule> once upon a time Curve25519 meant a D-H function that uses Montgomery x-coordinates on the wire
[00:48:22] <bascule> as opposed to, say, y^2 = x^3+486662x^2+x modulo p = 2^255-19 
[00:48:50] <bascule> now that can be differentiated with Curve25519 vs X25519
[00:49:08] <bascule> but Ed25519 refers to an EdDSA function
[00:50:40] *** Quits: brson (brson@moz-cfhap5.mtv2.mozilla.com) (Quit: leaving)
[02:05:38] *** Joins: dpc (dpc@moz-t6gr4b.ca.comcast.net)
[02:36:05] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[02:59:27] *** Quits: dpc (dpc@moz-t6gr4b.ca.comcast.net) (Connection closed)
[02:59:33] *** Joins: dpc (dpc@moz-t6gr4b.ca.comcast.net)
[03:53:29] *** Quits: dpc (dpc@moz-t6gr4b.ca.comcast.net) (Ping timeout: 121 seconds)
[04:19:51] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[04:55:29] *** Joins: dpc (dpc@moz-t6gr4b.ca.comcast.net)
[05:05:31] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[06:11:09] <eternaleye> Oh goodie: https://lwn.net/Articles/647167/
[06:11:22] <eternaleye> Let's expose an in-kernel x509 and pkcs7 parser to userspace!
[06:17:59] <Ilari> This seems almost guaranteed to be exploitable.
[06:42:11] <eternaleye> That's certainly my opinion.
[06:43:48] <Ilari> Fuzzing the crap out of that could be interesting.
[06:45:19] <Ilari> And then there are the two isogenous Edwards curves to y^2 = x^3+486662x^2+x modulo p = 2^255-19
[08:11:41] *** Quits: dpc (dpc@moz-t6gr4b.ca.comcast.net) (Ping timeout: 121 seconds)
[08:49:15] *** Joins: kunerd (kunerd@moz-kra.fte.169.87.IP)
[09:05:12] *** Joins: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua)
[09:42:37] *** Quits: kunerd (kunerd@moz-kra.fte.169.87.IP) (Ping timeout: 121 seconds)
[09:44:15] *** Joins: kunerd (kunerd@moz-kra.fte.169.87.IP)
[11:14:17] *** Quits: kunerd (kunerd@moz-kra.fte.169.87.IP) (Ping timeout: 121 seconds)
[11:18:15] *** Joins: kunerd (kunerd@moz-kra.fte.169.87.IP)
[11:30:22] *** Quits: kunerd (kunerd@moz-kra.fte.169.87.IP) (Ping timeout: 121 seconds)
[12:05:19] *** Joins: kunerd (kunerd@moz-kra.fte.169.87.IP)
[12:12:17] *** Parts: kunerd (kunerd@moz-kra.fte.169.87.IP) ()
[15:43:03] *** Joins: erickt (erickt@moz-4hh.6p3.217.74.IP)
[15:53:49] <Ilari> Classical Diffie-Hellman: On the other hand, it has better security properties than RSA key transport. On the other hand, worse.
[15:57:43] <Ilari> Better: No fixed private key to steal to decrypt past sessions. Worse: Cracking a prime cracks all sessions using it, and varying primes causes problems due to weak ones.
[16:00:50] <Tiffany> so everyone should be using DHE or ECDHE?
[16:07:14] <Ilari> ECDHE seems much less vulernable to building tables to assist in breaking keys.
[16:09:09] <Ilari> Also, looks like just about everything that does TLS 1.2 does ECDHE with P-256 (if you manage to implement that mess).
[16:11:27] <Tiffany> I wish web servers used sane defaults for crypto
[16:13:10] <Tiffany> ssl labs is very helpful in that regard
[16:13:14] <Tiffany> like changing DH primes...
[16:14:21] <Tiffany> from what I remember, every debian server uses the same DH parameters by default
[16:14:28] <Tiffany> and you have to do weird things to change them
[16:14:43] <Tiffany> how expensive is this precomputation thing?
[16:15:27] <Tiffany> oh right
[16:15:28] <Tiffany> logjam
[16:20:52] <Tiffany> ah
[16:21:00] <Tiffany> it only works with export-grade RSA?
[16:23:49] <Tiffany> a week for 512 bits, apparently
[16:23:57] <Tiffany> for the prime precomputation
[16:44:11] <Ilari> Well, it just becomes more expensive as prime size increases.
[16:44:45] <Tiffany> yeah
[16:44:57] <Tiffany> the paper says it takes 35 million core years for a 1024-bit key
[16:45:28] <Ilari> Experts guess NSA has done the precomputation for few common 1024-bit primes.
[16:45:43] <Tiffany> the paper guesses that
[16:45:57] <Tiffany> they say it's the reason why some NSA slides say they can break VPN protocols
[16:48:09] <Ilari> And with regards to TLS 1.2, PCI DSS has limitations on use of TLS 1.0 (and will be disallowed entierely mid-2016).
[16:50:32] <Ilari> There is sadly one major TLS 1.2 client that doesn't do AES-GCM: Safari in Mac OS X 10.9/10.10 and iOS 6/7/8. There one could use AES-256-CBC-SHA. Those support ECDHE (and ECDSA) too.
[16:51:51] <Tiffany> why the hell don't they?
[16:52:46] <Tiffany> my favourite cipher suite I know of is TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384, but SHA-384 is supported by just about nobody
[16:52:46] <Ilari> No idea. 10.11 and 9 add support for that.
[16:53:02] <Tiffany> on the other hand, there's TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
[16:53:17] <Tiffany> but there doesn't seem to be a TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA256
[16:53:51] <Ilari> The way I would config ciphers for 1.2 is AES-128-GCM/CHACHA20-POLY1305-GOOGLE/CHACHA20-POLY1305-IETF as tied first rank, and AES-256-CBC-SHA as second rank.
[16:54:18] <Tiffany> lighttpd doesn't give very much control over cipher preference ranking
[16:54:28] <Tiffany> or, I should say, openssl cipher suite strings
[16:55:13] <Tiffany> would the debian version of openssl support CHACHA20-POLY1305-GOOGLE or CHACHA20-POLY1305-IETF?
[16:55:49] <Ilari> No idea. Definitely not the IETF variant (currently only in GnuTLS as default-disabled).
[16:57:10] <Tiffany> it looks like google offers patches for it, but no linux distro ships them?
[16:57:52] <Tiffany> https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=9a8646510b
[16:58:59] <Tiffany> openssl list-cipher-algorithms on my machine doesn't turn up anything
[16:59:06] <Tiffany> this gitweb doesn't seem to say which branch this is on though
[16:59:27] <Tiffany> is it an orphan commit or something?
[17:00:45] <Tiffany> maybe it's been added but isn't compiled in by default
[17:00:51] <Tiffany> I have no idea
[17:00:57] <Tiffany> there's little information I'm finding
[17:03:51] <Ilari> Branches: remotes/origin/1.0.2-aead, remotes/origin/OpenSSL_1_0_2-stable
[17:04:04] <Tiffany> how'd you find that?
[17:04:41] <Ilari> Cloned the repo and used gitk.
[17:04:45] <Tiffany> oh
[17:04:50] <Tiffany> so gitweb is terrible
[17:07:23] <Tiffany> hm
[17:07:31] <Ilari> Well, at least it looks like that unless you want to support obsolete clients, you can use ECDHE exclusively...
[17:07:35] <Tiffany> TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
[17:07:38] <Tiffany> what is the SHA256 for?
[17:07:53] <cmr> mac presumably
[17:08:02] <Tiffany> poly1305 is the MAC
[17:09:44] <Ilari> The PRF-hash.
[17:10:23] <Ilari> Bit odd in that Chacha20 has 256-bit key, and those usually have SHA-384 as PRF-hash.
[17:10:50] <Tiffany> oh
[17:13:24] <Tiffany> wikipedia cites the RFC on the PRF
[17:13:44] <Ilari> The AES-256-CBC-SHA has prf-hash of SHA-256. Even if one would deduce SHA-1 from the name, that ciphersuite does not specify prf-hash, so falls under the TLS 1.2 rule that past ciphers that don't specify prf-hash use SHA-256.
[17:13:51] <Tiffany> it uses this strange construction for expanding a secret into a stream of pseudorandom data
[17:14:24] <Tiffany> oh
[17:14:27] <Tiffany> that makes a lot more sense
[17:14:49] <Tiffany> so it's a sort of shorthand for AES-256-CBC-SHA-SHA256?
[17:15:10] <Ilari> Then there are some ciphersuites with typoed names in the registry...
[17:15:21] <Tiffany> oh my
[17:15:45] <Tiffany> the strange thing about this RFC is that it specifies using the HMAC's hash function for the PRF
[17:16:11] <Ilari> TLS_PSK_DHE_WITH_AES_128_CCM_8   ... That is supposed to be TLS_DHE_PSK_WITH_AES_128_CCM_8 (or something like that).
[17:16:28] <Tiffany> oh
[17:16:42] <Ilari> The name of key exchange is DHE_PSK, not PSK_DHE.
[17:16:49] <Tiffany> so mixed up, rather than an actual spelling error
[17:19:53] <Ilari> Then there is something called RSA_PSK... Who uses that? Requires RSA implementation and does not have PFS.
[17:20:50] <Tiffany> are there any implementations of noise that already exist?
[17:21:31] <Tiffany> it's utterly ungooglable
[17:22:01] <Tiffany> in particular I implemented the ENCRYPT() primitive in rust and I'm already groaning at how tedious that was
[17:22:10] <Tiffany> I'm not even sure if I was successful, because there's no provided test vectors
[17:32:36] <Tiffany> are the noise KDF and rust-crypto hkdf_expand compatible?
[17:33:40] <Tiffany> I don't think they are
[17:33:41] <Tiffany> oh well
[17:34:01] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Connection closed)
[17:35:58] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[17:44:01] <Ilari> Oh, BSI paper downplaying twist security.
[17:54:07] *** Quits: zeiris (dan@moz-8jbmam.letter.agency) (Ping timeout: 121 seconds)
[17:56:10] *** Joins: zeiris (dan@moz-8jbmam.letter.agency)
[17:56:18] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Connection closed)
[17:57:15] <bascule> Ilari: and a Dragonfly paper from Dan Harkins, yay!
[17:59:19] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[18:03:10] *** Joins: kunerd (kunerd@moz-kra.fte.169.87.IP)
[18:49:55] *** Joins: brson (brson@moz-cfhap5.mtv2.mozilla.com)
[18:57:01] *** Parts: kunerd (kunerd@moz-kra.fte.169.87.IP) ()
[19:15:16] *** Quits: zeiris (dan@moz-8jbmam.letter.agency) (Ping timeout: 121 seconds)
[19:17:04] *** Joins: zeiris (dan@moz-8jbmam.letter.agency)
[19:21:24] *** Quits: zeiris (dan@moz-8jbmam.letter.agency) (Ping timeout: 121 seconds)
[19:22:19] *** Joins: zeiris (dan@moz-8jbmam.letter.agency)
[19:45:41] <Ilari> Guess that hidden component in domain name. :-)
[19:47:42] *** Quits: blank_name (blank_name@moz-p4egrb.mi.frontiernet.net) (Quit: leaving)
[19:48:53] *** Quits: brson (brson@moz-cfhap5.mtv2.mozilla.com) (Connection closed)
[19:49:13] <Tiffany> does rust-crypto have a secure rng anywhere? and if not, where can I get one?
[19:49:30] *** Joins: brson (brson@moz-cfhap5.mtv2.mozilla.com)
[19:49:38] *** Joins: blank_name (blank_name@moz-p4egrb.mi.frontiernet.net)
[19:50:30] <Tiffany> also, is curve25519::curve25519 the right function to use for DH?
[19:51:01] <Ilari> What library?
[19:51:06] <Tiffany> rust-crypto
[19:51:16] <bascule> Tiffany: I'd recommend sodiumoxide if that's what you want...
[19:51:18] <Tiffany> this, particularly: https://github.com/DaGenix/rust-crypto/blob/master/src/curve25519.rs#L2097
[19:51:37] <Tiffany> bascule: is there a reason to use that?
[19:51:38] <bascule> sodiumoxide has both secure RNG and curve25519 scalarmult
[19:51:40] <Tiffany> oh
[19:51:47] <bascule> and it's using curve25519-donna
[19:51:57] <Tiffany> does it also have chacha20, poly1305, hmac, and sha-512?
[19:52:00] <Tiffany> or do I need to use both
[19:52:00] <bascule> yes
[19:52:02] <Tiffany> okay
[19:52:07] <Ilari> You might want to test if it performs scalar clamping and how it reacts to high bit in basepoint.
[19:52:14] <bascule> it has all those things, and more trustworthy implementations thereof IMO
[19:52:37] <Tiffany> it might take me a while to port
[19:52:38] <bascule> also likely to be faster
[19:52:41] <Tiffany> I've already written 200 lines of code
[19:52:45] <Tiffany> and have been unable to test any of it so far
[19:55:07] <Ilari> Or just mask the problematic bits yourself.
[19:55:26] <Tiffany> bascule: where's chacha?
[19:56:55] <Ilari> If one ever wanted to even try to replace X.509 in web. What features of X.509 are actually used on web? What features one wished worked but don't work reliably enough?
[19:59:05] <Tiffany> I actually have no idea what X.509 actually does
[20:01:03] *** Quits: zeiris (dan@moz-8jbmam.letter.agency) (Ping timeout: 121 seconds)
[20:01:59] *** Joins: zeiris (dan@moz-8jbmam.letter.agency)
[20:07:21] <Tiffany> bascule: I can't find chacha from searching the documentation, and I don't see a file for it in stream::?
[20:07:47] <Tiffany> I see it has several different salsa20 round variants, and xsalsa20
[20:11:21] <Tiffany> well then
[20:11:51] <Ilari> I get the feeling that very little of X.509 features are actually used in WebPKI.
[20:13:44] <Tiffany> I wonder how hard it'd be to add
[20:13:46] <Tiffany> surely not very?
[20:14:01] <Tiffany> libsodium has chacha, and the interface is the same
[20:14:22] <Tiffany> I might be missing something though, and bascule hasn't responded
[20:16:52] <eternaleye> Tiffany: If you want a secure RNG, you should be using the OS RNG
[20:17:13] <Tiffany> eternaleye: which presumably sodiumoxide wraps in a portable way
[20:17:24] <Tiffany> linux has /dev/random, windows has whatever the hell windows has, and so on
[20:17:52] <eternaleye> Tiffany: The only reason to use another RNG is if 1.) you need HUGE amounts of randomness (which crypto really shouldn't) 2.) you can't use a file descriptor AND your OS doesn't have an FD-less way of getting randomness (see: getrandom() recently added in Linux)
[20:17:55] <Tiffany> CryptGenRandom()
[20:18:12] <eternaleye> Tiffany: /dev/urandom on Linux is the sane choice for all but a ridiculously tiny set of cases
[20:18:22] <eternaleye> Tiffany: Note the leading 'u'
[20:18:36] <Tiffany> eternaleye: I was mainly asking for a wrapper around the OS APIs
[20:19:05] <eternaleye> Tiffany: http://doc.rust-lang.org/num/rand/struct.OsRng.html
[20:19:22] <Tiffany> nice
[20:20:48] <eternaleye> Tiffany: But for crypto, a user shouldn't ever handle raw randomness; and for non-crypto, the OS RNG is likely suboptimal.
[20:21:31] <eternaleye> Tiffany: (Generally, non-crypto randomness = statistical/monte-carlo, and the OS RNG's speed is not good for that)
[20:22:21] <eternaleye> Tiffany: IMO, the closest a user-facing crypto API should ever get to raw randomness is a key generation API.
[20:22:40] <Tiffany> for some reason, the noise protocol specifies filling padding with random data, instead of just zeros
[20:22:52] <Tiffany> I don't have any idea why
[20:22:55] <Tiffany> and I suppose I can just leave it zero
[20:23:04] <eternaleye> No, do follow the spec
[20:23:16] <eternaleye> Just don't do anything silly like <T: Rng>
[20:23:19] <Tiffany> I also need to generate ephemeral keys on connection
[20:23:24] <eternaleye> Use OsRng internally, unconditionally
[20:23:37] <Tiffany> and I also need some curve25519 keys to write test cases against
[20:23:50] <eternaleye> Tests are sort of an exception
[20:24:02] <Tiffany> they can be constant, but they have to come from somewhere
[20:24:02] <eternaleye> The harness can be silly, as long as the actual usage it makes of the API is sensible
[20:24:28] <Tiffany> right now I'm more focused on getting this implemented than having a pretty API
[20:24:37] <Tiffany> I'll clean it up after
[20:24:59] <eternaleye> Heh, I tend to design from the API inwards
[20:25:23] <eternaleye> Figure out the usage workflow, design the API to support that, implement the damn thing, and if the API is infeasible revise it.
[20:41:08] <Tiffany> so
[20:41:17] <Tiffany> I see a problem with me using noise
[20:41:28] <Tiffany> it assumes that all messages are eventually delivered
[20:41:38] <Tiffany> in order
[20:42:19] <Tiffany> I am planning on doing window resending, so if a message isn't ACKed, it's just bundled into the next window
[20:43:04] <Tiffany> attackers can't really discriminate against packets if I do this, because they are bundled together
[20:43:10] <Tiffany> well, I should say messages
[20:45:01] <Tiffany> I didn't really realize it until I had implemented most of the protocol
[20:45:09] <Tiffany> I don't see an easy fix, either
[20:45:30] <Tiffany> the primary mechanism for generating keys and nonces is not at all random-access
[20:46:10] <Tiffany> I suppose I could ditch the box model immediately after the handshake completes and use the resulting key with an incrementing nonce
[20:46:28] <Tiffany> but I don't really want to deviate from the protocol
[20:48:53] <eternaleye> Tiffany: There's also the option of just not yielding messages to the user until the preceding message has been received.
[20:49:03] <eternaleye> Tiffany: I mean, that's how TCP segment resending works...
[20:49:22] <Tiffany> that is not an option if you're writing a real-time application where not all data is treated equally
[20:49:28] <eternaleye> Tiffany: Ah
[20:49:43] <Tiffany> which my initial use of this thing I'm building will not be, but I want to leave the option open
[20:49:54] <eternaleye> Tiffany: I was reading it as an implementation concern, rather than a usefulness/fitness-for-purpose concern
[20:50:13] *** Quits: zeiris (dan@moz-8jbmam.letter.agency) (Ping timeout: 121 seconds)
[20:52:00] *** Joins: zeiris (dan@moz-8jbmam.letter.agency)
[20:52:06] <Tiffany> I'm not really sure what to do
[20:53:34] <Tiffany> is there another protocol I could try?
[20:54:07] <Tiffany> I don't know why noise sequentially generates a new chacha key and nonce for every single message
[21:01:11] <Tiffany> I think I'm just going to keep the noise handshake and then use plain old same-key chacha with incrementing nonces
[21:01:43] <Tiffany> well, chacha-poly1305
[21:17:19] *** Quits: zeiris (dan@moz-8jbmam.letter.agency) (Ping timeout: 121 seconds)
[21:18:19] *** Joins: zeiris (dan@moz-8jbmam.letter.agency)
[21:26:14] <Tiffany> I've checked out sodiumoxide and added chacha, but I suppose I'd better add tests before I try to commit it
[21:35:03] *** Joins: dpc (dpc@moz-7gui97.nvidia.com)
[21:40:05] *** Quits: zeiris (dan@moz-8jbmam.letter.agency) (Ping timeout: 121 seconds)
[21:40:21] *** Joins: zeiris (dan@moz-8jbmam.letter.agency)
[21:46:46] *** Joins: dpc_ (dpc@moz-7gui97.nvidia.com)
[21:46:58] *** Quits: dpc (dpc@moz-7gui97.nvidia.com) (Connection closed)
[21:55:25] *** Joins: dpc (dpc@moz-7gui97.nvidia.com)
[21:56:07] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[21:58:31] *** Quits: dpc_ (dpc@moz-7gui97.nvidia.com) (Ping timeout: 121 seconds)
[22:00:42] *** Joins: dpc_ (dpc@moz-7gui97.nvidia.com)
[22:02:08] *** Quits: zeiris (dan@moz-8jbmam.letter.agency) (Ping timeout: 121 seconds)
[22:02:40] *** Joins: zeiris (dan@moz-8jbmam.letter.agency)
[22:04:31] *** Quits: dpc (dpc@moz-7gui97.nvidia.com) (Ping timeout: 121 seconds)
[22:04:45] <Tiffany> I added a test from the TLS suite draft... I didn't realize that this was 256 bytes of keystream
[22:04:55] <Tiffany> I manually converted it to u8 literals
[22:08:10] *** Quits: zeiris (dan@moz-8jbmam.letter.agency) (Ping timeout: 121 seconds)
[22:08:27] *** Joins: zeiris (dan@moz-8jbmam.letter.agency)
[22:09:04] *** Quits: dpc_ (dpc@moz-7gui97.nvidia.com) (Ping timeout: 121 seconds)
[22:14:16] <eddyb> Tiffany: what do you mean by that last bit? what was the conversion?
[22:14:32] <Tiffany> eddyb: a block of base16 to u8 hex literals
[22:14:37] <Tiffany> i.e. inserting ", 0x"
[22:14:47] <Tiffany> 256 times
[22:15:19] <eddyb> s/(..)/, 0x\1/ :P
[22:15:26] <eddyb> or something like that
[22:15:40] <Tiffany> I didn't realise it was so big
[22:15:44] <Tiffany> it didn't look big in the RFC
[22:15:54] <Tiffany> I figured it would be 1 block, or 64 bytes
[22:16:13] <Tiffany> that and I'm no regex wizard
[22:16:54] <bascule> Tiffany: what version of Noise are you looking at?
[22:16:58] <Tiffany> hopefully I'll remember that trick the next time I need to insert some base16 into test cases
[22:17:00] <Tiffany> bascule: noise 1
[22:17:08] <Tiffany> does noise 2 behave nicely for my purposes?
[22:17:10] <bascule> heh ok
[22:17:16] <bascule> Trevor's already on the way to Noise 3, FYI
[22:17:17] <bascule> lol
[22:17:21] <Tiffany> uh huh
[22:17:26] <Tiffany> I only saw a noise 2 branch, so I assumed
[22:17:28] <bascule> also chacha is in libsodium but maybe not in sodiumoxide
[22:17:34] <Tiffany> yeah..
[22:17:38] <bascule> https://github.com/trevp/noise/blob/master/noise.md
[22:17:39] <Tiffany> I just submitted a PR for it
[22:17:41] <bascule> cool
[22:17:48] <bascule> ^^^ that's the latest version
[22:18:03] <bascule> he switched from "boxes" and "pipes" to "messages" and "sessions"
[22:18:04] <bascule> amazing
[22:18:43] <Tiffany> oh
[22:18:47] <Tiffany> I've been going by the wiki
[22:20:11] <bascule> yeah that's new
[22:20:17] <bascule> are you on the ML?
[22:20:49] <Tiffany> which ML?
[22:20:52] <bascule> noise
[22:21:01] <Tiffany> well, I'm not, where is it?
[22:21:06] <Tiffany> I didn't know it had one
[22:21:31] <bascule> noise@moderncrypto.org
[22:21:38] <Tiffany> wow, I didn't know travis CI showed the build progress live
[22:21:47] <bascule> https://moderncrypto.org/mailman/listinfo/noise
[22:21:49] <bascule> yep
[22:25:11] <Tiffany> oh, I see there's been mention of tcp vs udp on the mailing list
[22:25:38] <cmr> Lame, the main site shows an elliptic curve over the reals.
[22:25:47] <cmr> Over an actually used field looks much more undecipherable :P
[22:27:49] <Tiffany> like this? https://sage.math.uni-goettingen.de/doc/static/bordeaux_2008/_images/modpcurve.png
[22:28:18] <Tiffany> there's a silly amount of those nub shaped curves if you search google images
[22:29:30] <cmr> Of course, that's what an elliptic curve looks like.
[22:29:50] <cmr> I mean re the "nub shaped curves"
[22:29:52] <cmr> Yes, like that
[22:30:18] <Tiffany> hmm
[22:30:21] <Tiffany> I see symmetry
[22:30:42] <Tiffany> I guess it looks indecipherable because of the modulus?
[22:30:51] <Tiffany> I wonder what it looks like if you connect the dots
[22:42:32] <bascule> orion
[22:42:36] <bascule> lol
[22:43:09] <Tiffany> orion?
[22:43:23] <bascule> making a constellation joke
[22:43:28] <bascule> this is probably more appropriate:
[22:43:29] <bascule> http://cdn.arstechnica.net/wp-content/uploads/2013/10/elliptic-curve-crypt-image01.gif
[22:43:51] <Tiffany> nice
[22:44:25] <cmr> ah, neat gif.
[22:51:10] *** Quits: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua) (Ping timeout: 121 seconds)
[22:56:43] <eternaleye> bascule: What's with the vertical mirroring? Sign?
[22:57:13] <cmr> eternaleye: that's just how the group operation works.
[22:57:38] <eternaleye> Mm
[23:07:16] <eternaleye> >> ENCRYPT(k, authtext, plainttext), DECRYPT(k, authtext, ciphertext): AEAD_CHACHA20_POLY1305 from RFC 7539. k is a 44-byte value consisting of 32 bytes key and 12 bytes nonce. k is updated by inverting each bit of the nonce and then calculating a 64-byte ChaCha20 output with the previous key and new nonce, then taking the first 44 bytes as the new key and nonce.
[23:07:32] <eternaleye> I just have to say, regarding the key update thing... what?
[23:07:50] <eternaleye> Is it saying that on each message, it updates k?
[23:07:57] <eternaleye> That seems... slightly insane.
[23:08:45] <eternaleye> Honestly, this is what nonces are _for_
[23:09:07] <eternaleye> Especially for the case of, well, sending _unordered messages_
[23:12:22] <eternaleye> it seems like Noise 3 is completely unable to support anything other than SOCK_SEQPACKET semantics (or SOCK_STREAM over SOCK_SEQPACKET, since that just means ignoring stuff)
[23:12:53] <bascule> yes, it rekeys on each message
[23:12:59] <bascule> that's part of its replay attack prevention
[23:13:06] <eternaleye> Actually, I wonder if ChaCha20-Poly1305 satisfies Rogaway's MRAE
[23:13:09] <bascule> it's called a ratcheting protocol :P
[23:13:16] <eternaleye> Then Noise could just use CHAIN
[23:13:23] <bascule> we use a similar protocol in our readers
[23:13:52] <eternaleye> bascule: Sure, but it does mean that the (super nice and general) handshake is useless for any case but sequential transfer.
[23:14:11] <bascule> he's trying to solve that too
[23:14:13] <eternaleye> bascule: If it supported *either* unordered delivery or branching, then it'd be considerably more useful.
[23:14:19] <bascule> you should read all of the threads on the Noise mailing list
[23:14:22] <bascule> and check out Noise v2
[23:14:23] <eternaleye> (Since one can implement either in terms of the other)
[23:14:26] <eternaleye> bascule: I have
[23:14:30] <eternaleye> bascule: And I just read v3
[23:14:36] <bascule> Noise v2 was about generalizing the key exchange
[23:14:46] <eternaleye> bascule: The list is very quiet; most of the messages I read last month.
[23:14:58] <eternaleye> bascule: There were only two new threads, and no new messages in old threads
[23:15:05] <bascule> anyway, it's not that he isn't thinking of those use cases, it's just he wants to solve the most important one :P
[23:15:17] <eternaleye> bascule: Sure, but then why spec the transport?
[23:15:30] <bascule> why... not spec the transport?
[23:15:52] <eternaleye> bascule: If he *only* specs the key exchange, people can use it to key stuff that exists, like IPSEC or TLS-PSK, until he does a proper transport
[23:16:10] <eternaleye> bascule: But he's wedding the key exchange to a transport that feels half-baked to me
[23:17:19] <eternaleye> bascule: I agree the key exchange is the important part. That's why I think that half-assing a transport is a mistake: Put it on the back burner entirely until the key exchange is fleshed out.
[23:18:16] <eternaleye> bascule: Heck, Noise-KEX -> STARTTLS<TLS_PSK> could be damn usable _today_
[23:21:29] *** Quits: zeiris (dan@moz-8jbmam.letter.agency) (Ping timeout: 121 seconds)
[23:23:16] *** Joins: zeiris (dan@moz-8jbmam.letter.agency)
[23:36:51] <Tiffany> eternaleye: yeah I don't like the rekeying either
[23:37:03] <Tiffany> bascule: why are replay attacks a problem?
[23:37:19] <cmr> Tiffany: I'm not sure what you're asking
[23:37:23] <cmr> like, in general?
[23:37:29] <Tiffany> no I mean in this case
[23:37:35] <Tiffany> like, why does rekeying fix replay attacks
[23:37:40] <Tiffany> why don't using nonces fix those?
[23:39:20] <bascule> Tiffany: using sequential nonces would also solve the same problem, yes
[23:39:36] <Tiffany> so then what's rekeying for?
[23:39:38] <Tiffany> oh
[23:39:43] <Tiffany> it's because of the box chaining thing, isn't it
[23:39:53] <Tiffany> it makes it so you don't have to diverge from boxes very much in order to compose pipes
[23:40:12] <bascule> yeah
[23:40:38] *** Joins: dpc_ (dpc@moz-52v2l7.nvidia.com)
[23:48:24] <eternaleye> I feel like it's an attempt at finding a false commonality between symmetric and asymmetric operations.
[23:49:16] <eternaleye> In particular, note that the rekeying is *not* done with GCM!
[23:49:44] <eternaleye> And thus if one wants unordered messages, one is forced to 1.) use GCM (suboptimal) and 2.) send the nonces in a non-spec-compliant manner
[23:50:23] <eternaleye> That's part of what I mean by the transport bits feeling half-baked, and it being better to leave them off entirely for now
[23:50:35] <eternaleye> It feels like the ramifications haven't really been thought through.
[23:51:39] <Tiffany> I was bothered by how some parts of a box are authenticated twice
[23:52:39] <Tiffany> in particular, the ephemeral key is authenticated in the encrypted sender pubkey, and then the encrypted sender pubkey and the ephemeral key are authenticated by the body

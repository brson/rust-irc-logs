[00:15:37] *** Quits: tikue (tkuehn@moz-879E86A9.hsd1.ca.comcast.net) (Quit: tikue)
[00:21:38] *** Quits: mankyKitty (Instantbir@moz-21AD3B58.rev.sfr.net) (Quit: mankyKitty)
[00:24:58] <brson> acrichto: how's that build system change going?
[00:25:34] <acrichto> brson: I turned on tests for all things (rustpkg/rustdoc included) and it was just hitting failures
[00:25:46] <acrichto> no major blocker yet though, I'm just bad at landing things :\
[00:26:29] <brson> oh we wern't testing those?
[00:28:48] <acrichto> nah
[00:28:52] <acrichto> we were just testing std/extra docs
[00:30:53] *** Joins: lpy (lpy@2D0E5B97.EBF6444D.E99F7FDB.IP)
[00:32:41] *** Quits: lpy (lpy@2D0E5B97.EBF6444D.E99F7FDB.IP) (Ping timeout)
[00:41:38] *** Joins: pcwalton (pcwalton@moz-DA87EE4.hsd1.ca.comcast.net)
[00:41:38] *** ChanServ sets mode: +ao pcwalton pcwalton
[00:41:40] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[00:41:40] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/P_1EcA
[00:41:40] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[00:44:43] <cmr> SyntaxExpanderTTItemExpanderWithoutContext
[00:44:56] <cmr> sfackler: was that seriously a thing that existed
[00:45:47] <cmr> indeed it was.
[00:45:48] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[00:45:49] <cmr> yikes.
[00:46:10] *** Quits: c-a (c-a@moz-57C82A9.a163.priv.bahnhof.se) (Quit: Ex-Chat)
[00:46:34] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[00:46:34] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/YD_0bA
[00:46:34] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[00:46:38] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[00:46:39] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/IfnAdg
[00:46:39] <ghrust> 13rust/06auto 142611483 15Alex Crichton: Refactor the build system for easily adding crates...
[00:46:39] <ghrust> 13rust/06auto 14cdfdc1e 15Alex Crichton: Move extra::flate to libflate...
[00:46:39] <ghrust> 13rust/06auto 1474fedf3 15bors: auto merge of #11787 : alexcrichton/rust/refactor, r=brson...
[00:46:41] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[00:50:05] <dbaupp> bjz_: ping
[00:50:16] <bjz_> dbaupp: o/
[00:50:28] <dbaupp> bjz_: are you working on https://github.com/mozilla/rust/pull/11298 at all?
[00:50:37] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[00:50:59] <bjz_> I should close it
[00:52:22] <dbaupp> bjz_: I was asking because I'm going to take it over
[00:52:26] <dbaupp> if that's ok?
[00:52:31] <bjz_> sure thing
[00:52:43] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[00:57:21] <sfackler> cmr: yep D:
[00:57:50] <sfackler> It was introduced in the middle of pcwalton's elimination of @fn so I think he was on autopilot
[00:58:02] <pcwalton> I was on autopilot.
[01:07:13] *** Quits: canhtak (canhtak@moz-A9D61E16.wl.t.ulaval.ca) (Quit: canhtak)
[01:09:03] *** Quits: JesseH (Jesse@moz-BD21A528.mc.at.cox.net) (Ping timeout)
[01:11:32] <cmr> TIL: instanciate is not correct spelling of anything
[01:12:54] <dbaupp> cmr: is that from my PR?
[01:12:57] <cmr> no
[01:13:05] <cmr> writing twir
[01:13:13] <cmr> you used t
[01:13:19] <cmr> I initially used c in twir
[01:13:19] <dbaupp> ah
[01:13:23] <dbaupp> lucky
[01:13:28] <dbaupp> that would've been so embarrassing
[01:13:30] <dbaupp> ;P
[01:13:31] <cmr> :P
[01:13:52] *** Joins: canhtak (canhtak@moz-A9D61E16.wl.t.ulaval.ca)
[01:31:48] *** Joins: lpy (lpy@2D0E5B97.EBF6444D.E99F7FDB.IP)
[01:33:14] <nrc> from looking at an ast node, is there any way to tell if it the result of macro expansion?
[01:33:37] *** Quits: lpy (lpy@2D0E5B97.EBF6444D.E99F7FDB.IP) (Ping timeout)
[01:34:08] <dbaupp> nrc: there's a expn_info (or similar) field on the Span
[01:34:36] <nrc> cool, thanks dbaupp!
[01:41:41] <cmr> sfackler: did you write docs on how to use external macros yet?
[01:43:18] * dbaupp wonders if we would be (semi)-reasonable have it as doc.rs (or guide.rs) module in syntax::ext, since we have libsyntax docs online
[01:45:44] <sfackler> cmr: not yet
[01:45:47] <cmr> ok
[01:46:40] <dbaupp> acrichto: ping
[01:46:46] <acrichto> dbaupp: pong
[01:47:04] <dbaupp> acrichto: is http://static.rust-lang.org/doc/master/std/os/struct.Pipe.html obsolete now?
[01:47:04] *** Joins: jdm (jdm@moz-D434EC03.dsl.sca.megapath.net)
[01:47:08] <dbaupp> (constructor: http://static.rust-lang.org/doc/master/src/std/home/rustbuild/src/rust-buildbot/slave/doc/build/src/libstd/os.rs.html#307-314 )
[01:47:26] <acrichto> it is a little, but there are some that use it
[01:47:33] <acrichto> I don't like the interface
[01:47:43] <acrichto> maybe move it to std::io::pipe ?
[01:47:48] <dbaupp> ah, so the runtimes don't replace it exactly?
[01:47:48] <acrichto> that's probably where it belongs anyway
[01:47:58] <acrichto> io::pipe would be the best place for it
[01:48:14] <acrichto> maybe everyting in I/O should return a (Reader, Writer) pair..
[01:48:29] <dbaupp> Ok... ah, so I should make it return a FdReader/FdWriter?
[01:48:32] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[01:48:33] <dbaupp> (assuming such a thing exists?)
[01:48:48] <acrichto> right now I think we have a PipeStream
[01:49:06] <acrichto> but it is nice having the reader/writer distinction...
[01:49:16] <cmr> acrichto: does struct field privacy inheritance remove our last special case of private-by-default?
[01:49:27] <cmr> public-by-default, rather.
[01:49:39] <acrichto> cmr: kinda, we still have two cases of pub by default though
[01:49:50] <dbaupp> cmr: pub struct Foo { still_pub_by_default: int }
[01:49:53] <acrichto> dbaupp: feel free to move it wherever, I think it needs some more thought to integrate into I/O
[01:50:00] <acrichto> dbaupp: I'm going to comment on that issue
[01:50:04] <cmr> dbaupp: good point
[01:50:08] <dbaupp> acrichto: https://github.com/mozilla/rust/issues/9458 , right?
[01:50:35] <acrichto> dbaupp: whoa I was unaware of that one
[01:50:35] *** Quits: km (quassel@moz-777F24DE.kevinmehall.com) (Ping timeout)
[01:50:36] * acrichto reads
[01:50:42] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[01:50:46] <acrichto> oh that I don't care too much about
[01:50:51] <acrichto> I was thinking abut #11165
[01:51:01] <acrichto> I like that pipe returns a "reader" and a "writer"
[01:51:05] <acrichto> even if they're just file descriptors right now
[01:51:27] *** Quits: erickt_ (etryzelaar@49C4075F.3AC15C18.2321E71E.IP) (Ping timeout)
[01:52:15] <acrichto> dbaupp: https://github.com/mozilla/rust/issues/11165#issuecomment-33337539
[01:53:12] <dbaupp> acrichto: oh
[01:53:15] <dbaupp> makes sense
[01:54:01] <acrichto> dbaupp: I do think that os::pipe doesn't bleong
[01:54:38] <dbaupp> in any case, returning an explicit reader & writer solves #9458 perfectly
[01:54:43] <dbaupp> yeah, definitely
[01:55:32] <acrichto> I'm starting to warm up to (reader,writer) pairs by default
[01:55:36] <acrichto> no need to deal with split() or clone()
[01:56:02] *** Joins: km (quassel@moz-777F24DE.kevinmehall.com)
[01:56:20] <dbaupp> Only need Stream types where you can't/it's unsafe to read and write in parallel?
[01:56:32] <acrichto> perhaps yeah
[01:56:38] <acrichto> we could even have
[01:56:46] <acrichto> impl<R: Reader, W: Writer> Stream for (R, W) 
[01:56:53] <acrichto> so all code today would keep working
[01:57:02] <acrichto> you would only destructure if you needed to
[01:57:08] <acrichto> that may be a little too cute though
[01:58:18] <dbaupp> heh, would be pretty neat
[02:01:15] <acrichto> my friend brought up the weird case though of
[02:01:23] <acrichto> (StdReader, ZlibCompressor)
[02:01:37] <acrichto> it would work, it just wouldn't make much sense
[02:01:57] <dbaupp> why not?
[02:02:35] *** Joins: carter (carter@moz-58F59B3A.members.linode.com)
[02:02:37] <acrichto> a stream has kinda the concept that the data you write will be read by the person who's writing to your reader
[02:02:52] <dbaupp> maybe ZlibCompressor is a wrapper around stdout
[02:02:54] <acrichto> but I don't think it really matters that much
[02:02:55] * dbaupp shrugs
[02:02:57] <acrichto> it's true
[02:03:03] <dbaupp> yeah, it'd be a minor thing
[02:03:05] <acrichto> that's why I'd still be in favor of doing it
[02:03:18] <acrichto> new build system, yay!
[02:03:24] <cmr> ohh it landed?
[02:03:30] <cmr> \o/
[02:03:30] <acrichto> about to get pushed
[02:04:28] * dbaupp 's favourite colour is green
[02:05:38] <dbaupp> sfackler: ^^^
[02:06:45] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[02:06:45] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/IfnAdg
[02:06:45] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[02:07:23] <sfackler> dbaupp: ?
[02:08:40] <dbaupp> sfackler: acrichto and I were just discussing something similar to your comment on the (Reader, Writer) issue
[02:08:47] <sfackler> oh, cool
[02:08:50] <dbaupp> in the back scroll
[02:09:12] <acrichto> I'd like to avoid XXXStream if possible
[02:09:17] <acrichto> but it's certainly a possibility
[02:09:30] <acrichto> (if we take the reader/writer initially approach)
[02:10:44] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[02:10:52] <brson> acrichto: major kudos for getting that build system refactor merged. that was awesome
[02:11:10] <brson> oh, hey - it didn't even break android
[02:11:35] * dbaupp adds tens of new crates, just because he can
[02:11:48] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[02:11:48] <acrichto> brson: thanks!
[02:11:48] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/64p50w
[02:11:48] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[02:11:54] <acrichto> dbaupp: r+
[02:12:10] <brson> dbaupp: you joke, but it's time to open the floodgates and start thinking about what all those 'batteries' we're supposed to be including are
[02:12:42] <acrichto> and even breaking up librustrt is possible now!
[02:12:58] <acrichto> wycats noted recently that rust_test_helpers is included with libstd in all rlibs/.a files everywhere right now
[02:13:03] <acrichto> which is a little silly...
[02:13:16] <brson> yeah, it's not that big though, is it?
[02:13:22] <acrichto> miniz was also being included everywhere twice (b/c libextra included librustrt for it), but it should be fixed now
[02:13:28] <acrichto> rust_test_helpers is pretty small
[02:13:33] <acrichto> miniz was actually kinda large
[02:13:42] <acrichto> but miniz is in its own lib now for libflate
[02:13:43] <cmr> mergefunc would have helped us there wouldn't it?
[02:13:57] <acrichto> nah this is just objects being present in .a and .rlib files
[02:13:58] <brson> oh, i see, we are linking to rustrt in multiple places?
[02:14:04] <acrichto> we used to 
[02:14:15] *** Joins: tikue (tkuehn@moz-879E86A9.hsd1.ca.comcast.net)
[02:14:15] <acrichto> b/c librustrt had miniz and libextra needed miniz
[02:14:19] <dbaupp> If we want mergefunc we may have to pester #llvm to merge the patch that's apparently sitting waiting
[02:15:19] <cmr> There were 14 new contributors this week
[02:15:21] <cmr> that's insane
[02:15:33] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[02:15:41] <acrichto> nice!
[02:15:46] <dbaupp> 14! woah
[02:15:51] *** Quits: bjz_ (bjz@B398BE78.F804C29E.D35A31DF.IP) (Quit: Textual IRC Client: www.textualapp.com)
[02:15:59] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[02:16:30] <brson> \o/
[02:17:48] <brson> anybody want to mentor 'extern crate'?
[02:20:49] <dbaupp> I'd be willing to, but I'm not a great timezone for helping (most) contributors
[02:23:44] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Connection reset by peer)
[02:25:06] <brson> good enough for me!
[02:29:24] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[02:32:33] *** Joins: lpy (lpy@2D0E5B97.EBF6444D.E99F7FDB.IP)
[02:32:42] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[02:34:26] *** Quits: lpy (lpy@2D0E5B97.EBF6444D.E99F7FDB.IP) (Ping timeout)
[02:45:23] *** Quits: jdm (jdm@moz-D434EC03.dsl.sca.megapath.net) (Quit: Lost terminal)
[02:51:33] *** Joins: jensnockert (jensnocker@moz-988C9930.e0f8471ae7fa.afb.bredband2.com)
[02:52:09] <carter> brson: are there any rust things going on in the first  half of feb? i'll be in the Bay Area around then
[02:53:25] *** Quits: jensnockert (jensnocker@moz-988C9930.e0f8471ae7fa.afb.bredband2.com) (Ping timeout)
[02:56:36] <brson> carter: i don't think so, no. there will probably be a rust meetup sometime in feb, but it isn't scheduled yet
[02:56:46] <carter> ok
[02:56:52] <carter> figured i'd ask
[02:57:40] <brson> we could maybe schedule a doc sprint for sometime when you are in town - i've been considering that might be a good excuse to get people together over a weekend
[02:57:51] <carter> that could be cool
[02:58:23] <carter> i've been busy with my current freelance work + my numerical haskell stuff + trying to help (in my own small way) get ghc ready for the pending major version release
[02:58:27] <tikue> looking forward to the tuesday meetup!
[02:58:28] <carter> (AUTOCONF === evilll)
[02:58:39] <carter> so i've not been able to play with rust 
[03:05:02] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[03:14:38] *** Joins: erickt_ (etryzelaar@49C4075F.3AC15C18.2321E71E.IP)
[03:15:04] *** Joins: lpy (lpy@2D0E5B97.EBF6444D.E99F7FDB.IP)
[03:16:46] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[03:16:46] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/1WkBOw
[03:16:46] <ghrust> 13rust/06auto 14711726e 15Derek Chiang: Fix barrier docs
[03:16:46] <ghrust> 13rust/06auto 140119e46 15bors: auto merge of #11823 : derekchiang/rust/fix-barrier-doc, r=alexcrichton...
[03:16:46] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[03:17:07] <brson> anybody want to mentor 'do'?
[03:31:48] *** Joins: JesseH (Jesse@moz-BD21A528.mc.at.cox.net)
[03:32:24] *** Quits: zz_kimundi (kimundi@moz-6155981A.dip0.t-ipconnect.de) (Ping timeout)
[03:33:09] *** Quits: dbaupp (Thunderbir@moz-68C83524.lns20.syd6.internode.on.net) (Ping timeout)
[03:35:53] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Quit: leaving)
[03:36:20] *** Joins: zz_kimundi (kimundi@moz-B70A68F6.dip0.t-ipconnect.de)
[03:36:22] *** zz_kimundi is now known as kimundi
[03:36:40] <xales> anyone have an idea as to why https://github.com/mozilla/rust/pull/11797 test fails with "run-pass/issue-11411.rs:16:9: 16:16 error: cannot assign to an `&mut` in an aliasable location" ?
[03:37:04] *** Joins: dbaupp (Thunderbir@moz-68C83524.lns20.syd6.internode.on.net)
[03:38:24] <cmr> acrichto: have you seen that before?
[03:38:52] *** Quits: dbaupp (Thunderbir@moz-68C83524.lns20.syd6.internode.on.net) (Ping timeout)
[03:52:14] <acrichto> cmr: hm no I haven't seen that
[03:52:20] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Connection reset by peer)
[03:52:23] *** Joins: bytbox (s@moz-54E13927.washdc.fios.verizon.net)
[03:53:04] *** Joins: jdm (jdm@moz-D434EC03.dsl.sca.megapath.net)
[03:58:01] <cmr> rusti: static mut x: &mut int = &mut 5;
[03:58:03] -rusti- <anon>:10:23: 10:31 error: missing lifetime specifier
[03:58:03] -rusti- <anon>:10         static mut x: &mut int = &mut 5;
[03:58:03] -rusti-                                 ^~~~~~~~
[03:58:03] -rusti- error: aborting due to previous error
[03:58:03] -rusti- application terminated with error code 101
[03:58:10] <cmr> rusti: static mut x: &'static mut int = &mut 5;
[03:58:11] -rusti- <anon>:10:42: 10:48 error: references in constants may only refer to immutable values
[03:58:11] -rusti- <anon>:10         static mut x: &'static mut int = &mut 5;
[03:58:11] -rusti-                                                    ^~~~~~
[03:58:11] -rusti- error: aborting due to previous error
[03:58:12] -rusti- application terminated with error code 101
[03:58:32] <cmr> acrichto: do you think that restriction should be lifted for static muts?
[03:59:13] <acrichto> if we're going that route for &mut [T], then it seems like we should as well
[03:59:17] <cmr> though I think that might induce some other weird changes to statics... `let y = x;` what would that even do? I suppose it'd be disallowed, since it'd have to be considered as a move?
[03:59:47] <acrichto> almost everything about static mut is pretty unsafe
[03:59:50] <cmr> yeah
[03:59:53] <acrichto> the borrow checker can't reason about it
[04:00:23] <cmr> yeah
[04:01:07] <cmr> so the borrow checker should just give up for static muts?
[04:01:28] <acrichto> I would imagine so
[04:01:36] <acrichto> but niko would probably have more opinions about that
[04:01:48] <cmr> yeah
[04:01:49] <acrichto> although I think he thinks that we're already way too permissive with static mut as-is
[04:07:22] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[04:07:22] *** ChanServ sets mode: +ao dherman dherman
[04:10:29] <jdm> STDTESTDEP_$(1)_$(2)_$(3)_$(4)
[04:10:30] <jdm> yes, good
[04:10:37] <jdm> very makefile
[04:10:39] <acrichto> shhhh, don't look at that
[04:10:54] <cmr> much understand!
[04:11:18] <acrichto> but it work!
[04:11:24] <cmr> so work
[04:11:27] <cmr> wow
[04:11:30] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[04:15:33] *** bstrie_goblin is now known as bstrie_target
[04:24:24] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[04:25:53] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[04:27:17] *** Quits: pcwalton (pcwalton@moz-DA87EE4.hsd1.ca.comcast.net) (Quit: pcwalton)
[04:29:29] *** Joins: dbaupp (Thunderbir@moz-68C83524.lns20.syd6.internode.on.net)
[04:36:34] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[04:36:34] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/1WkBOw
[04:36:34] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[04:37:11] <dbaupp> r? https://github.com/mozilla/rust/pull/11834 (... sorry :( )
[04:44:44] <nrc> can anyone explain DefUpVar to me please? Like what is an up var?
[04:46:37] <xales> nrc: my understanding is, a variable in a closure that comes from the upper scope
[04:49:05] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[04:51:16] <nrc> so any variable inside a closure definition (?) which is defined outside the closure has this extra layer of indirection in the def map?
[04:52:31] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[04:53:18] <dbaupp> nrc: `let x = 1; || { foo(x) /* the captured variable x is an up var */ }`
[04:53:45] <nrc> I see
[04:53:55] <nrc> thanks xales and dbaupp :-)
[04:54:19] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[04:54:54] *** Quits: canhtak (canhtak@moz-A9D61E16.wl.t.ulaval.ca) (Quit: canhtak)
[04:55:16] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[05:06:05] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[05:15:03] <dbaupp> acrichto: ping
[05:20:49] <acrichto> dbaupp: pong
[05:22:09] *** Quits: aatch (James@moz-B437F499.pocketrent.com) (Quit: Leaving)
[05:22:38] <dbaupp> acrichto: I'm trying to deal with this fail!() bloat, and...
[05:22:47] <dbaupp> the problem is begin_unwind is generic
[05:23:29] <dbaupp> Possible solutions: have a separate fail_str(s: &str) function that people can call if they want
[05:23:41] <acrichto> where's the codegen coming from?
[05:23:47] <acrichto> generating begin_unwind or generating the Any vtable?
[05:23:48] <dbaupp> fail!("...") wouldn't be able to automatically call this, but fail!("...", ...) would
[05:24:10] <acrichto> we could definitely have fail with N arguments call fail_str
[05:24:13] <dbaupp> the generic means it's only getting instantiated in other crates
[05:24:23] <acrichto> but there's two sources of codegen
[05:24:24] <dbaupp> so it gets all the code from inside begin_unwind
[05:24:27] <acrichto> one for the Any vtable
[05:24:30] <acrichto> one for the begin_unwind
[05:24:32] <dbaupp> and all of those dependencies
[05:24:35] <acrichto> and you're sure begin_unwind is the bloat?
[05:24:59] <acrichto> ah yes, I would believe that
[05:25:08] <acrichto> so the goal is to not have begin_unwind be generic?
[05:25:10] <dbaupp> pretty sure, I can double check if you want?
[05:25:20] <dbaupp> well, avoid using the generic version where possible
[05:25:36] <acrichto> oh nah I believe you 
[05:25:42] <acrichto> taking a look at it there's a lot of code in begin_unwind
[05:25:47] <acrichto> lots of code with lots of deps
[05:26:04] <dbaupp> Hm... maybe I can break as much as possible into a non-generic function
[05:26:20] <dbaupp> rather than do these fail_str hacks
[05:26:22] * dbaupp tries
[05:26:22] <acrichto> pub fn begin_unwind_fmt(args: &fmt::Arguments file: &'static str, line: uint)
[05:26:28] <acrichto> that signature is very possible
[05:26:34] <dbaupp> ah, yes, that would work too
[05:26:37] <acrichto> it simply calls fmt::format
[05:26:41] <acrichto> and then begin_unwind
[05:26:53] <dbaupp> anyway, the thing I was really going to ask was about fail!("...")
[05:26:53] <acrichto> doesn't solve fail!("foo")
[05:27:04] <acrichto> what ideas do you have?
[05:27:06] *** Quits: tikue (tkuehn@moz-879E86A9.hsd1.ca.comcast.net) (Quit: tikue)
[05:27:11] <dbaupp> is it completely horrible to have a $str:lit_str macro NT?
[05:27:21] <dbaupp> or, hard code fail into the compiler.
[05:27:31] <acrichto> how bad is the codegen?
[05:27:40] <acrichto> like multiple hundreds of milliseconds bad?
[05:27:45] <dbaupp> yes
[05:28:00] <dbaupp> fn main() { fail!() } is 0.2s fn main() {} is 0.05s on my computer
[05:28:34] <dbaupp> (this is actually the reason for {:?} being much much slower than {}, surprisingly: there's a single .unwrap() call that kills it)
[05:28:36] <acrichto> I see, I get about a 2x improvement on osx
[05:28:46] <acrichto> interesting
[05:28:54] <dbaupp> (slow at compile time.)
[05:29:01] *** Joins: eddyb (eddy@EDE07015.D51DAF03.FB866788.IP)
[05:29:30] <acrichto> how about allocating in the macro?
[05:29:39] <dbaupp> the ~Any?
[05:29:42] <acrichto> fn begin_unwind(m: ~Any)
[05:29:49] <acrichto> my gut says no
[05:29:55] <acrichto> but I imagine that it would compile better
[05:31:30] * eddyb made this long comment hoping someone could come with a proper solution https://github.com/mozilla/rust/pull/11595#issuecomment-33331673
[05:31:35] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[05:31:35] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/PUGb8g
[05:31:35] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[05:31:36] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[05:31:36] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/YWU7mA
[05:31:36] <ghrust> 13rust/06auto 14c60db9b 15Scott Lawrence: As Either no longer exists, remove Either, Left, and Right from syntax files
[05:31:36] <ghrust> 13rust/06auto 14f1fdaa2 15bors: auto merge of #11822 : bytbox/rust/master, r=huonw...
[05:31:36] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[05:31:37] <dbaupp> yeah, ok, I'll experiment
[05:32:17] <acrichto> dbaupp: I'm also worried about code size at the callsite though
[05:32:31] <acrichto> and I would guess that an allocation would blow it up largely
[05:32:34] <acrichto> but I could be wrong
[05:32:50] <eddyb> it's not really the allocation, AFAIK, but generating the vtable
[05:32:56] <dbaupp> acrichto: yeah, maybe... in theory it's just `p = malloc() if null { abort() } p`
[05:33:07] <eddyb> dbaupp: after inlining
[05:33:30] <dbaupp> eddyb: and before inlining it's even less code, so even better
[05:33:32] <eddyb> the Any vtable has 3 functions, and there's also the global
[05:33:46] <dbaupp> eddyb: that's not code at the call site
[05:33:49] <acrichto> dbaupp: I'd talk to one of the macro guys about a different nonterminal though (jclements or jdm I think?)
[05:33:52] <eddyb> I guess they're tiny, let's see how this goes
[05:34:03] <eddyb> dbaupp: but it's code generated on demand
[05:34:18] <eddyb> (I guess there's also the drop glue)
[05:34:23] <dbaupp> yes, but it's not code that's killing the I-cache directly at the fail!() call
[05:34:36] <dbaupp> it's off somewhere else in the binary
[05:35:18] <dbaupp> acrichto: I know jclements and pauls are macro people, don't know about jdm
[05:35:30] <jdm> I am not a macro person
[05:35:47] <eddyb> jdm: but your nick starts with j! :P
[05:35:53] <acrichto> jdm: sorry :(
[05:35:59] <jdm> first adt, now macros :)
[05:36:08] <acrichto> I'm so bad
[05:36:21] <dbaupp> jdm handles every feature! \o/
[05:37:10] <dbaupp> eddyb: that's not a very long "long comment", btw :P
[05:37:32] <dbaupp> eddyb: I'd almost go so far as calling that a "short comment"
[05:40:01] <eddyb> dbaupp: pfffft I'm bad
[05:40:10] <dbaupp> heh :P
[05:40:11] <eddyb> acrichto: let's make "team bad"
[05:40:27] <acrichto> hehe
[05:40:37] <acrichto> dbaupp: +1k lines what?!, oh just tests, ah, carry on
[05:41:10] <eddyb> my record is -1k or so, I should start implementing features so I also go in the green :P
[05:41:14] <dbaupp> acrichto: yay scripts :P
[05:41:19] <acrichto> hehe
[05:41:26] <eddyb> dbaupp: it was late and I tried to explain the situation hoping someone would show up during the night with a lightbulb
[05:41:30] <acrichto> my net contribution to rust is still negative
[05:41:35] <acrichto> but I think it's becuase I deleted jemalloc
[05:41:41] <eddyb> acrichto: can we see stats somewhere?
[05:42:00] <acrichto> eddyb: https://github.com/mozilla/rust/graphs/contributors
[05:42:14] <eddyb> https://github.com/mozilla/rust/pulse omg I can see myself
[05:42:57] <eddyb> oh, that's a nice overview of merged PRs :D
[05:43:50] <dbaupp> acrichto: you're stealing all our code! >:(
[05:44:03] <acrichto> muahaha
[05:44:54] <eddyb> so I'm right behind brson and https://github.com/derekchiang
[05:45:45] <dbaupp> so anyway.. changing begin_unwind to be a wrapper that does the Any allocation around a noinline nongeneric function halves the time fn main() { fail!() } takes to compile for me
[05:46:10] <dbaupp> and reduces format!("{:?}", 1) by 100ms (out of 500ms)
[05:46:51] <acrichto> interesting!
[05:46:56] <acrichto> do you know what it looks like code-size-wise?
[05:47:07] <eddyb> oh, silly me, that's recent commits :(
[05:48:00] <acrichto> dbaupp: can #11834 be summarized by -- add a Span to a struct, rename lots of incorrect names, and then just propagate everywhere?
[05:48:00] <eddyb> still #74 per total
[05:48:31] <dbaupp> acrichto: old is 3689 lines of IR, new is 644
[05:48:36] <dbaupp> for just fail!()
[05:48:44] <acrichto> I like the sound of that
[05:48:53] <eddyb> hah, good job
[05:49:14] <dbaupp> fn main() {} is 294
[05:49:31] <eddyb> dbaupp: at --opt-level=0?
[05:49:48] <dbaupp> acrichto: it's more "rename things, use the correct span everywhere" and one single use needs to add the Span to a struct 
[05:49:53] <eddyb> (can we add -On so we can just say "-O0"?)
[05:50:07] <dbaupp> (i.e. most of the change can be done without adding the Span to the struct)
[05:50:16] <dbaupp> acrichto: (sorry... I can split it if you want?)
[05:50:23] <dbaupp> eddyb: yes no-opts
[05:50:26] <acrichto> dbaupp: oh no I was just curious, no need to split
[05:50:41] <acrichto> lol Copyright {year}
[05:51:05] <dbaupp> I borrowed the main structure of the script from generate-keyword-tests.py, fwiw
[05:51:52] <acrichto> good enough for me
[05:52:16] <eddyb> dbaupp: so we get more precise errors now for deriving? :D
[05:52:39] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[05:52:39] *** ChanServ sets mode: +ao dherman dherman
[05:52:51] <dbaupp> eddyb: we had it before, but I hadn't updated all the deriving impls to use it, apparently
[05:53:01] <eddyb> ah, okay
[05:53:05] <acrichto> dbaupp: what does the code size look like at the callsite of fail!() with M: Any vs ~Any?
[05:53:11] <dbaupp> rustilite: struct Foo; #[deriving(Eq)]struct Bar { x: Foo } fn main() {}
[05:53:18] -rustilite- pastebinned 11 lines of output: http://ix.io/a8W
[05:53:35] <dbaupp> acrichto: testing
[05:53:44] <eddyb> rustilite: struct Foo; #[deriving(Zero)]struct Bar { x: Foo } fn main() {}
[05:53:47] -rustilite- pastebinned 6 lines of output: http://ix.io/a8X
[05:55:30] <dbaupp> rustilite: struct Foo; #[deriving(Clone)] struct Bar { x: Foo } fn main() {}
[05:55:31] -rustilite- <anon>:1:24: 1:29 error: mismatched types: expected `Foo` but found `&Foo` (expected struct Foo but found &-ptr)
[05:55:31] -rustilite- <anon>:1 struct Foo; #[deriving(Clone)] struct Bar { x: Foo } fn main() {}
[05:55:31] -rustilite-                                 ^~~~~
[05:55:31] -rustilite- error: aborting due to previous error
[05:55:31] -rustilite- application terminated with error code 101
[05:55:38] <dbaupp> what that PR fixes^
[05:56:06] <eddyb> yeah, those are nasty
[05:56:33] <eddyb> https://github.com/mozilla/rust/pull/11774/files#diff-f7ad4a5ae3364771b775302f47d00063R16 this reminds me we have to make __log_level() and intrinsic
[05:56:42] <eddyb> *an intrinsic. though it's not enough
[05:56:58] <eddyb> can we tell we're calling a specific intrinsic, at the call site?
[05:57:04] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[05:57:16] <dbaupp> woah, woah, what
[05:57:43] <eddyb> dbaupp: hmm?
[05:57:51] <dbaupp> rusti: macro_rules! foo(($e:expr) => { ~$e }) *foo!("foo")
[05:57:51] -rusti- <anon>:10:48: 11:6 error: type `~str` cannot be dereferenced
[05:57:51] -rusti- <anon>:10         macro_rules! foo(($e:expr) => { ~$e }) *foo!("foo")
[05:57:51] -rusti- <anon>:11     };
[05:57:51] -rusti- error: aborting due to previous error
[05:57:52] -rusti- application terminated with error code 101
[05:58:03] <dbaupp> that's just crazy
[05:58:11] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[05:58:11] <ghrust> 01[13rust01] 15alexcrichton 04force-pushed 06try from 142bef9d6 to 145e91453: 02http://git.io/k471pw
[05:58:11] <ghrust> 13rust/06try 14a266993 15Alex Crichton: Add an AtomicU64 type to std::sync::atomics...
[05:58:11] <ghrust> 13rust/06try 1488e3b67 15Alex Crichton: Enable the +v7 feature on Android by default...
[05:58:11] <ghrust> 13rust/06try 1492eed09 15Alex Crichton: extra: Make room for more sync primitives
[05:58:12] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[05:58:20] * dbaupp files a bug
[05:58:25] <eddyb> dbaupp: for what?
[05:58:50] <eddyb> ~ ExprParen("...") is probably what allows you to get ~&'static str
[05:59:04] <dbaupp> eddyb: that macro should be equivalent to `fn foo<T>(x: T) -> ~T { ~x }`
[05:59:12] <eddyb> dbaupp: nope, add parens
[05:59:15] <dbaupp> you shouldn't be allowed to modify the parsed expr from the outside
[05:59:29] <dbaupp> if it where $e:tt, I might accept it
[05:59:31] <eddyb> dbaupp: ~"foo" isn't parsed specially
[05:59:33] <dbaupp> but not $e:expr
[05:59:48] <eddyb> it's box "foo" vs box ("foo")
[05:59:51] <dbaupp> eddyb: parens does fix it, but this is not correct
[05:59:55] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[05:59:56] *** ChanServ sets mode: +ao dherman dherman
[05:59:57] <eddyb> dbaupp: it's not in macros
[06:00:05] <eddyb> (I'm telling you so you're not wasting your time)
[06:00:20] <eddyb> dbaupp: this behavior is controlled by middle, AFAIK
[06:01:02] <eddyb> ExprBox(ExprLit(LitStr(...))) vs ExprBox(ExprParen(ExprLit(LitStr(...)))) or something like that
[06:01:09] <dbaupp> I don't think ~$e should be equivalent to ~"foo", when $e is expr
[06:01:18] <dbaupp> it becomes a textual macro that way
[06:01:48] <acrichto> dbaupp: #11820 is a long-standing issue, not introduced by #11826, right?
[06:01:48] <eddyb> dbaupp: ~$e is ExprBox(Uniq, $e) or something like that
[06:01:58] <dbaupp> acrichto: yes
[06:02:14] <dbaupp> eddyb: that's an implementation detail that shouldn't be visible
[06:02:21] <acrichto> dbaupp: so you changed the structure of the generated code which is why #[deriving(XXX)] doesn't work evrywhere?
[06:02:28] <eddyb> dbaupp: :/
[06:02:45] <dbaupp> acrichto: yes
[06:03:00] <dbaupp> acrichto: basically, it adds an extra deref which makes things unhappy, apparently
[06:03:18] <acrichto> hm
[06:03:22] <dbaupp> i.e. what was effectively (&foo).clone() is now (*&foo).clone()
[06:03:50] <acrichto> isn't that just foo.clone() ?
[06:05:36] <dbaupp> acrichto: yes, they behave the same in this instance (i.e. both are incorrect)
[06:05:54] <dbaupp> acrichto: 565 lines total for ~Any in the fail expansion
[06:05:55] <acrichto> good enough for me
[06:06:05] <dbaupp> just checking for what it looks like at the actual call site now
[06:06:10] <eddyb> dbaupp: hang on, I might have not been accurate, there is such thing as "Vstore" in the AST
[06:07:23] <eddyb> dbaupp: oh I'm an idiot, unless this was changed recently, but I doubt it
[06:08:15] <eddyb> dbaupp: "ExprLit(lit) if lit_is_str(lit)" in parser.rs
[06:08:32] *** Quits: TimAbraldes (quassel@moz-7FD19BDC.hsd1.or.comcast.net) (Input/output error)
[06:09:22] <dbaupp> acrichto: with optimisations https://gist.github.com/huonw/34a2c74ba36d93c4837b
[06:09:58] <acrichto> dbaupp: do you have the before as well?
[06:10:01] <acrichto> with <M: Any>
[06:10:03] <dbaupp> sec
[06:10:05] <acrichto> just the callsite
[06:10:56] <eddyb> dbaupp: btw, we should make exchange_malloc/free generic or at least somehow do the cast from *u8 to *T before null check
[06:11:04] <dbaupp> (what, begin_unwind itself is like 830 lines of IR, with opts)
[06:11:23] <eddyb> hah, didn't expect that
[06:11:24] <acrichto> it does a fair amount of stuff
[06:12:03] <dbaupp> carter: https://gist.github.com/huonw/6b779c1ec9aca923cc08
[06:12:06] <dbaupp> erm
[06:12:08] <dbaupp> acrichto:
[06:12:30] <acrichto> assembly-wise?
[06:12:34] <eddyb> doener had a testcase which was much better optimized with this check being after the bitcast https://gist.github.com/huonw/34a2c74ba36d93c4837b#file-opt-ll-L2
[06:12:36] <acrichto> (I'm so demanding)
[06:13:04] <acrichto> eddyb: how would that improve things?
[06:13:10] <acrichto> or rather how did that improve things?
[06:13:20] <dbaupp> acrichto: added to the gist
[06:13:57] <acrichto> 17 instructions vs 10
[06:13:58] <eddyb> acrichto: LLVM was capable to merge identical blocks and whatnot
[06:14:12] <acrichto> eddyb: huh, I would not have guessed that
[06:14:17] <acrichto> dbaupp: so that doesn't sound so bad to me at all
[06:14:42] <acrichto> dbaupp: I think that allocations normally generate lots of code b/c of landing pads, but we're already in a landing pad here so maybe it's not that bad
[06:15:13] <acrichto> dbaupp: better idea
[06:15:30] <acrichto> fn begin_unwind<M: Any>(m: M) { real_begin_unwind(~m); }
[06:15:34] <acrichto> best of both worlds?
[06:15:39] <acrichto> the instantiation would be tiny
[06:15:43] <eddyb> acrichto: the bitcast was carried after some switches and it was blocking the merging, from the start
[06:16:07] <acrichto> eddyb: ah I guess that makes sense, bitcasts I would imagine are difficult to optimize around
[06:16:31] <eddyb> he managed to initiate a merge from the end, and also from the start (by moving the bitcast before the null check)
[06:17:37] <dbaupp> acrichto: that's what I did before :P
[06:17:55] <acrichto> dbaupp: oh really? I must have missed that
[06:17:58] <dbaupp> acrichto: just testing it now
[06:18:07] <dbaupp> (I didn't get any IR or asm from it though.)
[06:18:11] <acrichto> that plus fn begin_unwind_fmt seem like a good solution to code bloat
[06:18:54] <eddyb> acrichto: for some reason, the bitcasts are moved into each of these blocks https://gist.github.com/dotdash/e1c7bdd6f3ff627cb1d3#file-gistfile1-ll-L23-L31
[06:19:03] <dbaupp> whoops, forgot the inline(never)
[06:19:06] * dbaupp recompiles
[06:20:04] <dbaupp> cmr: too fast >:(
[06:20:23] <acrichto> lol I went to r+ that
[06:20:26] <cmr> too fast?
[06:20:28] <acrichto> then I saw 2 r+
[06:20:30] <acrichto> and was intimidated
[06:20:33] <cmr> hah
[06:20:38] <cmr> he asked me to r+ it across the table :P
[06:20:44] <acrichto> cheater
[06:20:46] *** Joins: NiccosSystem (NiccosSyst@AB1AFDE.FC7B0C35.A7597CB6.IP)
[06:20:51] <dbaupp> acrichto: we need yours too
[06:20:53] <cmr> how did you even see it before he told me to do it? :P
[06:21:02] <dbaupp> for that extra stamp of approval
[06:21:11] <acrichto> hehe
[06:21:14] * dbaupp is actually xales in disguise
[06:21:28] <cmr> I wonder if we could get every reviewer to r+ a pull request...
[06:21:38] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[06:21:38] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/0bqf6w
[06:21:38] <ghrust> 13rust/06auto 14c60db9b 15Scott Lawrence: As Either no longer exists, remove Either, Left, and Right from syntax files
[06:21:38] <ghrust> 13rust/06auto 144b2fdfa 15bors: auto merge of #11822 : bytbox/rust/master, r=huonw...
[06:21:39] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[06:21:40] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[06:21:41] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14f1fdaa2 to 140119e46: 02http://git.io/N3iJvQ
[06:21:41] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[06:21:43] <eddyb> cmr: mine is still waiting :P
[06:22:07] <cmr> eddyb: typarams? trans? hell no, I ain't reviewing that!
[06:22:19] <xales> so
[06:22:20] <dbaupp> acrichto: yep, with the two-level begin_unwind the IR at the call site is the same as the fully generic one, but without the 800 line function
[06:22:21] <eddyb> cmr: already reviewed, just an issue to fix
[06:22:41] <dbaupp> I'll add begin_unwind_fmt and then submit this thing
[06:22:45] <acrichto> dbaupp: and it's still a win with compile-time?
[06:22:49] <xales> cmr has told me he is going to single-handedly write a complete C++ FFI
[06:22:50] <dbaupp> acrichto: yes
[06:22:53] <acrichto> dbaupp: nice
[06:23:47] <dbaupp> acrichto: hm, it's not quite as nice as it could be... the generic begin_unwind gets landing pads even thought it never needs them :/
[06:24:00] <eddyb> I think I have a solution... if the static did.crate != LOCAL_CRATE, then any coercion to a closure *has to have this crazy behavior*
[06:24:15] <eddyb> so I can just generate the original wrapper's name
[06:24:17] <acrichto> dbaupp: that's https://github.com/mozilla/rust/issues/5016
[06:24:26] <dbaupp> acrichto: ok, cool
[06:26:18] <dbaupp> meh, {:?} is still 10K lines of IR with this change (down from 13K!)
[06:26:43] <acrichto> dbaupp: https://github.com/mozilla/rust/issues/8484 is more relevant to the zeroing out, but it's a dupe of the previous
[06:26:45] <dbaupp> But... I guess that's irrelevant since it's probably going to disappear soon.
[06:27:06] <acrichto> if we remove reflection then we'll remove the default libm dependency on linux
[06:27:13] <acrichto> b/c reflection on floats is pulling that in
[06:27:20] <dbaupp> really? nice
[06:27:33] <acrichto> and then we'll only have libpthreads required I think
[06:27:43] <acrichto> and libc ofc
[06:27:53] <acrichto> and this is even when you link to libstd
[06:27:55] <dbaupp> librustrt?
[06:28:03] <acrichto> that's static
[06:28:05] <acrichto> so no worries
[06:28:06] <dbaupp> ah, right
[06:28:28] * acrichto enjoys the freedom of having static and dynamic native dependencies
[06:30:57] <nrc> how do I get debug symbols for rustc?
[06:31:14] <cmr> RUSTFLAGS="-Z extra-debug-info" when building.'
[06:31:31] <nrc> thanks cmr!
[06:32:00] <dbaupp> it's not good enough to be part of --enable-debug yet?
[06:32:20] <dbaupp> woah, woah
[06:32:47] <cmr> I had a PR that added it.
[06:32:55] <cmr> it failed for one of the reasons.
[06:33:07] <dbaupp> I think changing `let x = ~msg as ~Any; begin_unwind(x, ...)` to `begin_unwind(~msg, ...)` removed 35 lines from the *optimised* IR
[06:33:15] <dbaupp> (215 -> 180)
[06:33:21] <cmr> O_o
[06:33:36] <cmr> what does adjustment do differently that `as` does?
[06:33:43] <cmr> that sentence is FUBAR but you get what I mean
[06:34:48] <cmr> main.rs:138:14: 138:17 error: unresolved name `out`. Did you mean `l`
[06:34:55] <cmr> no, rustc, I actually meant out_file, but nice try
[06:35:31] <dbaupp> https://gist.github.com/huonw/33f37390510cbe47036a
[06:35:51] <dbaupp> it looks like the trait coercion may just be bogus
[06:37:58] <dbaupp> eh, doing begin_unwind(~msg as ~Any, ..) is the same; so it looks like actually the temporary, not the trait-objecting
[06:38:07] <dbaupp> (i.e. that's short too)
[06:38:12] <cmr> ok
[06:38:19] <cmr> a temporary should not be 35 lines
[06:39:09] <eddyb> it's probably doing it smarter when it's not living more than the begin_unwind call
[06:39:27] <eddyb> because we zero out allocas to cancel cleanup when we move out of lvalues
[06:39:39] <dbaupp> Ah, of course
[06:39:48] <dbaupp> it's an lvalue vs. rvalue thing
[06:39:56] <eddyb> right, that's what I should've said
[06:40:08] * dbaupp is no longer confused
[06:43:42] <eddyb> dbaupp: so how does it look now?
[06:44:03] <dbaupp> eddyb: which thing in particular?
[06:44:14] <eddyb> dbaupp: is this part shorter? https://gist.github.com/huonw/6b779c1ec9aca923cc08
[06:44:44] <dbaupp> nope, that's as short as it gets
[06:44:49] <dbaupp> but it's not longer
[06:44:52] <dbaupp> iirc
[06:44:54] * dbaupp double checks
[06:45:58] <dbaupp> yes, it's identical, even without optimisations
[06:46:14] <eddyb> then I'm not sure what those 35 lines were about
[06:46:52] <eddyb> what bugs me a little is that we check moves, so we should be able to reuse that information in trans, without doing anything smarter there
[06:49:37] <dbaupp> the 35 lines are in begin_unwind itself
[06:49:45] <dbaupp> the landing pad for the `x` temporary
[06:50:03] <dbaupp> this gist: https://gist.github.com/huonw/33f37390510cbe47036a
[06:50:52] <eddyb> dbaupp: hahaha, I just realized
[06:51:18] <eddyb> well, no, it should zero to cancel the cleanup
[06:51:28] <eddyb> here https://gist.github.com/huonw/33f37390510cbe47036a#file-tmp-ll-L32
[06:51:46] <eddyb> dbaupp: I was almost afraid it might free the ~Any it's supposed to lift out of the failing task :P
[06:53:24] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[06:55:09] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[06:57:42] <eddyb> o_O
[06:58:09] <eddyb> we have a #[address_insignificant] attribute, that controls the behavior of cross-crate instantiation of statics?
[07:02:14] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[07:02:18] <eddyb> so external_srcs could tell me whether a local ItemStatic is an inlined version from another crate
[07:05:21] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[07:08:50] <dbaupp> acrichto: any particular reason we have std::fmt::format(W, Arguments) rather than, say, Arguments.format(W)?
[07:09:18] <acrichto> not particularly I guess
[07:10:26] <dbaupp> ok
[07:10:31] <dbaupp> just wondering
[07:16:18] <xales> acrichto: cmr said you might know about how static muts are handled in trans - I'm trying to prevent it from flagging a static mut slice as constant to LLVM (re - https://github.com/mozilla/rust/pull/11797)
[07:17:15] <acrichto> xales: this is in reference to the error you're currently getting?
[07:17:26] <xales> acrichto: yeah
[07:17:27] <eddyb> xales: I'm looking at trans::consts
[07:17:52] <eddyb> though the immutability-related code I've seen looked like it did the right thing
[07:17:54] <xales> acrichto: I made some changes to trans/consts to fix the error, but it's emitting https://gist.github.com/xales/70f9f29b29c9d5662cab
[07:18:09] <xales> (which segfaults, because it makes it constant)
[07:18:12] <acrichto> xales: it looks like that error is coming from borrowck?
[07:18:14] <acrichto> oh hm
[07:18:21] <xales> yeah, I fixed borrowck
[07:18:26] <acrichto> @const = private unnamed_addr constant [1 x i64] [i64 1]
[07:18:28] <xales> I should push that
[07:18:30] <acrichto> that's what you'll want to change
[07:18:47] <acrichto> let me take a look real quick
[07:19:41] <acrichto> https://github.com/mozilla/rust/pull/11797/files#diff-5e9bda7f0339fac3cc1e94892f1c7999R597
[07:19:47] <acrichto> xales: oh I'll just comment
[07:20:21] <xales> yeah, I changed that to False, it still emitted it as constant
[07:21:28] <acrichto> you also seem to be naming it ""
[07:21:47] <xales> yeah, that's probably bad
[07:22:32] <eddyb> see how constant strings are output
[07:22:35] <acrichto> it looks like if you change that to False I'd think it'd be a mutable vector
[07:22:35] <eddyb> strNNNN
[07:22:48] <acrichto> I commented about being careful about the sub-things also need to be mutable as well
[07:23:00] <acrichto> but after thinking for a few seconds that may not be much of a worry anyway
[07:23:40] <dbaupp> acrichto: hm, weird stuff happens with the begin_unwind_fmt (the closure passed to format_args makes things upset)
[07:23:44] <dbaupp> anyway I gtg for a bit
[07:23:44] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[07:23:44] <ghrust> 01[13rust01] 15alexcrichton 04force-pushed 06try from 145e91453 to 140515d70: 02http://git.io/k471pw
[07:23:45] <ghrust> 13rust/06try 140515d70 15Alex Crichton: Generate properly aligned atomic loads/stores
[07:23:45] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[07:23:54] <acrichto> dbaupp: paste?
[07:24:04] <acrichto> dbaupp: oh when you get back I'd be willing to take a lok
[07:24:26] <eddyb> I wish strings had a name representing their contents, but that might inflate bc
[07:24:37] <xales> acrichto: it still emits it a constant when it's False; I looked at what that call actually does, and I'm looking to see what happens if the call is removed entirely (it shouldn't be necessary)
[07:24:58] <acrichto> xales: you're sure that LL code was generated with False?
[07:25:16] <xales> yeah
[07:25:47] <eddyb> I thought globals were made constant with LLVMGlobalConstantSet or something like that
[07:26:08] <acrichto> xales: can you show me the un-optimized IR?
[07:28:38] <xales> acrichto: https://gist.github.com/xales/0c3c7c41b9428ca94d82
[07:30:07] <eddyb> does anyone know how metadata works?
[07:30:18] <cmr> eddyb: nope, give up now ;p
[07:30:48] <eddyb> I have an expression inside an ItemStatic, and I want to know if its parent is from a different crate
[07:31:09] <cmr> hm
[07:31:10] <eddyb> turns out const_expr is called from a lot of places
[07:31:15] <acrichto> xales: the vector looks like it's created through C_array which calls LLVMConstArray which sounds a bit fishy
[07:31:21] <acrichto> xales: I gtg, but you may want to start by looking there
[07:31:29] <eddyb> so I can't just add an "is_in_local_crate" argument
[07:31:53] <cmr> eddyb: do you have a DefId?
[07:32:00] <eddyb> cmr: for the expr?
[07:32:14] *** Joins: japaric (japaric@6EEB4A44.E90D5F40.F29ED47E.IP)
[07:32:17] <cmr> eddyb: for the ItemStatic?
[07:32:33] <eddyb> cmr: I know how to tell if the ItemStatic was inlined, too
[07:32:38] <eddyb> using external_srcs
[07:32:52] <eddyb> but I'm in an Expr, inside the ItemStatic
[07:33:23] <eddyb> base::get_item_val calls consts::const_expr itself for ItemStatic, instead of going through consts::trans_const or w/e
[07:33:53] <eddyb> I remember someone saying "rust wasn't designed, it evolved" - much more true about rustc
[07:35:32] <eddyb> I guess I could go the sadistic way and propagate that argument through the entirety of consts + _match +base
[07:36:35] <eddyb> hmm, what does csearch::found_parent mean?
[07:37:13] *** flaper87|afk is now known as flaper87
[07:44:37] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[07:46:26] <cmr> it's a bit annoying that &~str doesn't get adjusted to a &str
[07:51:21] <eddyb> autoslice should be part of autoderef :/
[07:57:40] <flaper87> can someone retrigger this? http://buildbot.rust-lang.org/builders/auto-linux-64-nopt-t/builds/2925/steps/test/logs/stdio :(
[07:57:50] <cmr> which PR is it
[07:58:26] <flaper87> cmr: https://github.com/mozilla/rust/pull/11776
[07:58:37] <flaper87> thank you!
[07:58:50] <cmr> flaper87: are you sure you didn't cause those failures?
[07:59:15] <cmr> they're the same error..
[07:59:54] <flaper87> cmr: wait a sec! Don't retry it yet
[08:01:25] <flaper87> they are indeed related to the change but I don't think they're caused by my change. Anyway, let me give it a run locally again and double check
[08:04:49] *** Joins: lpy_ (lpy@9248CA04.F930CE91.65042015.IP)
[08:04:55] *** Quits: lpy (lpy@2D0E5B97.EBF6444D.E99F7FDB.IP) (Ping timeout)
[08:05:15] *** Quits: lpy_ (lpy@9248CA04.F930CE91.65042015.IP) (Quit: Leaving...)
[08:05:23] *** Joins: lpy (lpy@9248CA04.F930CE91.65042015.IP)
[08:06:47] *** Joins: glaebhoerl (glaebhoerl@moz-B5B88D72.catv.broadband.hu)
[08:07:53] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[08:08:18] <xales> acrichto: Yeah, that seems to be the problem; I have no idea how to go about fixing it though (what needs to be done instead of calling C_struct?)
[08:08:41] <acrichto> xales: you may need to do something like LLVMStopFlaggingThisGlobalAsConstant to the return value
[08:10:03] <cmr> acrichto: https://botbot.me/mozilla/rust-gamedev/msg/10217834/ any thoughts on that?
[08:10:11] <cmr> guh botbot's logs don't seem to be very up-to-date
[08:10:16] <cmr> anyway you should join #rust-gamedev
[08:12:09] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[08:12:31] *** Quits: glaebhoerl (glaebhoerl@moz-B5B88D72.catv.broadband.hu) (Ping timeout)
[08:12:37] *** Joins: glaebhoerl (glaebhoerl@moz-B5B88D72.catv.broadband.hu)
[08:13:31] <xales> acrichto: I don't think there's any way to make an LLVM ConstStruct be flagged non-const
[08:14:43] <eddyb> C_struct is const?
[08:15:17] <eddyb> xales: from what I've seen, globals have to be explicitly marked as constant - do you not have access to that code, to turn it off?
[08:16:04] <xales> eddyb: even when it's not marked as constant (or told to call setConstant(false)), it emits them as constant
[08:16:17] <eddyb> nasty :S
[08:16:21] <xales> yeah
[08:16:31] <acrichto> xales: static mut FOO: [uint, ..3] = [0, 1, 2]; 
[08:16:39] <acrichto> that works so there's got to be some way
[08:21:31] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[08:21:31] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/0bqf6w
[08:21:31] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[08:25:52] <eddyb> is there really no way to get the crate ID from a node ID of a random AST node that was inlined?
[08:26:27] <cmr> eddyb: node id has no crate information afaik
[08:26:34] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[08:26:34] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/UP1wIw
[08:26:34] <ghrust> 13rust/06auto 140b7f823 15Huon Wilson: syntax: Fix a missing closing code tag in docs.
[08:26:34] <ghrust> 13rust/06auto 14b233eae 15Huon Wilson: syntax: make deriving have slightly less cryptic error messages....
[08:26:34] <ghrust> 13rust/06auto 143c54730 15bors: auto merge of #11826 : huonw/rust/7621-deriving-errors, r=alexcrichton...
[08:26:36] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[08:26:40] <eddyb> cmr: I mean, if there's a map
[08:26:42] <cmr> I'm pretty sure you can even have two node id's = 4
[08:26:49] <eddyb> cmr: not really
[08:26:55] <eddyb> they get new IDs when they're inlined
[08:27:08] <cmr> oh right
[08:28:19] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[08:28:28] *** Quits: rustilite (rustilite@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[08:30:42] <dbaupp> acrichto: the problem with begin_unwind_fmt was closures can't return !, so the return value of the closure I passed to format_args! was left as an unconstrained generic. (I've worked around this with a full function for now; but I'm thinking maybe format_args should take a normal expression rather than a function: something like `format_args!(a => my_fancy_format(a), "foo {} baz", "bar")`.)
[08:31:20] <acrichto> dbaupp: hm, it also may be possible to redesign it now that rvalue lifetimes are different
[08:31:30] <dbaupp> acrichto: ah, yes
[08:31:31] <acrichto> like ideally it's "let args = fmt::format_args()"
[08:31:38] <acrichto> or, you know what I mean
[08:31:38] <dbaupp> that would be cool
[08:31:46] <dbaupp> yeah
[08:31:53] <dbaupp> file a bug?
[08:31:59] <acrichto> I should yeah
[08:32:28] <eddyb> could we do writer.write!("foo")?
[08:33:01] <acrichto> dbaupp: you can pass it a bare function
[08:33:02] <acrichto> for now
[08:33:21] <dbaupp> yeah, that's what I'm doing
[08:33:25] <acrichto> line numbers though
[08:33:36] <dbaupp> bare function defined in the macro expansion
[08:33:46] <eddyb> though it would rewrite a writer method for that one
[08:33:50] <acrichto> hm, lemme try something
[08:34:26] <dbaupp> !!!
[08:34:28] <dbaupp> apparently this gets fn main() { fail!("foo {}", "bar") } to 76 lines of IR (optimised)
[08:34:36] <acrichto> nice!
[08:34:40] <dbaupp> a plain fail!() is 181
[08:34:49] <dbaupp> and fn main() {} is 29
[08:34:56] <dbaupp> this is cool
[08:35:28] <acrichto> dbaupp: hm yeah an inner function sounds like the way to go
[08:35:56] <eddyb> dbaupp: we can go even shorter with fail!("foo {}", "bar")
[08:36:11] <eddyb> it's technically a malloc and two memcpy's
[08:36:40] <eddyb> making fail!("foo {:s}", s) shorter will probably help a lot of call sites
[08:37:37] <dbaupp> eddyb: there's 560 /fail!("/'s in the code base and 168 /fail!(".*{/'s
[08:38:04] <dbaupp> Hm, I guess there's assert!() and assert_eq!() too
[08:38:30] <eddyb> assert has just strings and assert_eq has bools, which is technically strings
[08:38:43] <dbaupp> ?
[08:38:52] <dbaupp> assert_eq prints the values of the LHS and RHS
[08:38:53] <eddyb> wait, no, it prints the values, nvm
[08:39:07] <dbaupp> gtg
[08:39:23] *** Quits: glaebhoerl (glaebhoerl@moz-B5B88D72.catv.broadband.hu) (Ping timeout)
[08:39:25] <eddyb> though now I'm curious what kind of code LLVM generates for my reimplementation + fmt::Default for bool
[08:39:34] *** Quits: erickt_ (etryzelaar@49C4075F.3AC15C18.2321E71E.IP) (Ping timeout)
[08:39:42] *** Joins: glaebhoerl (glaebhoerl@moz-B5B88D72.catv.broadband.hu)
[08:41:33] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[08:41:34] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/DMEFzw
[08:41:34] <ghrust> 13rust/06auto 140b7f823 15Huon Wilson: syntax: Fix a missing closing code tag in docs.
[08:41:34] <ghrust> 13rust/06auto 14b233eae 15Huon Wilson: syntax: make deriving have slightly less cryptic error messages....
[08:41:34] <ghrust> 13rust/06auto 14c008074 15bors: auto merge of #11826 : huonw/rust/7621-deriving-errors, r=alexcrichton...
[08:41:36] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[08:41:37] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[08:41:37] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 143c54730 to 144b2fdfa: 02http://git.io/N3iJvQ
[08:41:37] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[08:44:28] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[08:44:28] *** Joins: rustilite (rustilite@moz-54F7FD49.cpe.net.cable.rogers.com)
[08:46:19] <dbaupp> eddyb: we can theoretically do even better for assert!(foo()) too, since the format string is a static
[08:46:31] <dbaupp> I mean, the string you're formatting
[08:46:31] <eddyb> yeah, that's what I meant
[08:46:44] <dbaupp> as in, it could be a single memcpy
[08:46:56] <eddyb> dbaupp: that's a LLVM optimization waiting to be born
[08:47:04] <dbaupp> it might be a deopt
[08:47:07] <eddyb> two memcpy's don't really hurt anything other than codesize
[08:47:18] <dbaupp> since it would be duplicating the prefix and suffix of the string
[08:47:22] <dbaupp> inflating binary size
[08:47:26] <dbaupp> a little bit.
[08:47:28] <eddyb> as in, it's not going to be slower
[08:47:55] <eddyb> dbaupp: ah, right. useful if it's the only use of those strings (so the originals can be removed)
[08:48:26] <dbaupp> yeah
[08:49:14] <dbaupp> (in any case, you'd have to be using a *lot* of assert!()s to notice the difference in any app of decent size.)
[08:49:21] <eddyb> technically, it should happen for any constant byte vector
[08:51:52] *** Joins: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net)
[08:52:07] <eddyb> no, I can't just add another argument
[08:52:17] <eddyb> why? because then I have to change trans::adt as well
[08:53:56] <dbaupp> change all the things \o/
[08:54:15] <eddyb> dbaupp: just for stupid AutoAddEnv
[08:54:16] <dbaupp> (have you made progress on the static function pointer thing, or is that what you're doing now?)
[08:54:24] <eddyb> that's what I'm doing
[08:54:40] *** Joins: jensnock_ (jensnocker@moz-2ECF70FB.mobileonline.telia.com)
[08:54:55] <eddyb> I need special behavior when the static I'm doing AutoAddEnv *inside of* is not from LOCAL_CRATE
[08:55:02] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[09:06:33] *** Joins: mankyKitty (Instantbir@moz-9B898D95.enst-bretagne.fr)
[09:08:45] <acrichto> rustilite: struct Foo<'a> { v: &'a int } fn foo<'a>(f: &'a int) -> Foo<'a> { Foo { v: f } } fn main() { let args = foo(&1); }
[09:08:57] -rustilite- pastebinned 11 lines of output: http://ix.io/a92
[09:10:40] <dbaupp> acrichto: :(
[09:10:46] <acrichto> yeah...
[09:10:55] <acrichto> we could re-work how fmt works to get around it
[09:11:03] <acrichto> that may involve making it not-sound though
[09:11:05] <dbaupp> How?
[09:11:17] <acrichto> creation of fmt::Arguments is unsound
[09:11:25] <dbaupp> I'd prefer to keep the slightly idiosyncratic format_args than make it possible to screw up
[09:11:25] <acrichto> because fmt::Arguments is the "safely created thing"
[09:11:29] <acrichto> so only the compiler can safely create it
[09:11:53] <acrichto> everything is transmuted to &Void
[09:11:59] <acrichto> and fn(&Void, Formatter)
[09:12:07] <eddyb> acrichto: I fixed that btw :D
[09:12:17] <eddyb> my version has 0 transmutes
[09:12:17] <dbaupp> another problem with safety: it has to be inside an `unsafe {}` block, which presumably captures our rvalues dead.
[09:12:18] <acrichto> that lifetime thing?
[09:12:19] *** Quits: vadimcn (chatzilla@FB06B64.76F9E272.DA40C4B3.IP) (Connection reset by peer)
[09:12:38] <eddyb> acrichto: I use trait pointers instead of a fn and a &Void
[09:12:38] <acrichto> perhaps  yeah
[09:13:02] *** Joins: vadimcn (chatzilla@FB06B64.76F9E272.DA40C4B3.IP)
[09:13:21] <acrichto> anyway, sleep now
[09:13:36] <dbaupp> night
[09:13:48] *** Joins: c-a (c-a@moz-57C82A9.a163.priv.bahnhof.se)
[09:14:43] *** Joins: tikue (tkuehn@moz-879E86A9.hsd1.ca.comcast.net)
[09:21:31] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[09:21:31] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14c008074 to 144b2fdfa: 02http://git.io/N3iJvQ
[09:21:31] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[09:21:32] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[09:21:32] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/RbQaTQ
[09:21:32] <ghrust> 13rust/06auto 140b7f823 15Huon Wilson: syntax: Fix a missing closing code tag in docs.
[09:21:32] <ghrust> 13rust/06auto 14b079ebe 15Huon Wilson: syntax: improve the spans of some #[deriving] traits....
[09:21:33] <ghrust> 13rust/06auto 14d9a204b 15Huon Wilson: Add autogenerated tests for the spans of various derived traits.
[09:21:36] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[09:32:58] *** Joins: rca (rcatolino@moz-D690CDA.adsl.proxad.net)
[09:34:53] *** Quits: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP) (Ping timeout)
[09:36:08] *** Joins: doener (doener@moz-C68F600D.unity-media.net)
[09:37:35] *** Quits: lpy (lpy@9248CA04.F930CE91.65042015.IP) (Client exited)
[09:38:48] *** Quits: glaebhoerl (glaebhoerl@moz-B5B88D72.catv.broadband.hu) (Ping timeout)
[09:42:39] *** Quits: jensnock_ (jensnocker@moz-2ECF70FB.mobileonline.telia.com) (Connection reset by peer)
[09:43:23] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[09:55:24] *** flaper87 is now known as flaper87|afk
[09:58:03] <cmr> Unused item and dead code lints save my bacon again.
[10:01:50] *** Quits: jdm (jdm@moz-D434EC03.dsl.sca.megapath.net) (Quit: Lost terminal)
[10:08:03] *** Joins: lpy (lpy@9248CA04.F930CE91.65042015.IP)
[10:09:49] *** Quits: lpy (lpy@9248CA04.F930CE91.65042015.IP) (Connection reset by peer)
[10:10:16] *** Joins: lpy (lpy@9248CA04.F930CE91.65042015.IP)
[10:11:59] *** Quits: lpy (lpy@9248CA04.F930CE91.65042015.IP) (Ping timeout)
[10:13:11] <cmr> it's very inconvenient how std::libc tries to impose a structure on things.
[10:13:58] <cmr> glob reexports only solve the problem for when the original author actually remembered to use it ;(
[10:14:04] <cmr> plus it's just not very useful
[10:16:58] <eddyb> oh, I'm an idiot
[10:17:07] <eddyb> consts::trans_const uses base which uses consts
[10:17:19] <eddyb> this is entirely backwards
[10:27:31] <eddyb> cmr: woo, _match uses it for range
[10:27:56] <eddyb> though how... how does adt trans consts if it doesn't call through consts::const_expr?
[10:28:34] *** Quits: tikue (tkuehn@moz-879E86A9.hsd1.ca.comcast.net) (Quit: tikue)
[10:29:45] <eddyb> oooh, it does the terminal stuff
[10:30:07] <eddyb> cmr: yay this was easier than I thought
[10:30:46] <mankyKitty> so....close....
[10:41:33] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[10:41:33] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/RbQaTQ
[10:41:33] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[10:46:35] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[10:46:35] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/Yq9H0w
[10:46:35] <ghrust> 13rust/06auto 14f572379 15xales: Minor fix to docs.
[10:46:35] <ghrust> 13rust/06auto 141caa5b9 15bors: auto merge of #11837 : xales/rust/doc-fixes, r=cmr,huonw,alexcrichton
[10:46:35] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[10:46:48] <cmr> heh, I didn't know bors actually merged multiple rs
[10:52:02] <cmr> eugggggggh CString doesn't implement Clone.
[10:52:27] <cmr> it's painful having to write software and not being able to fix the stdlib as you go ;\
[10:55:16] <mankyKitty> hehehe
[10:55:50] <dbaupp> why can't you fix the stdlib?
[10:55:54] <cmr> well I am.
[10:56:03] <dbaupp> well ok then
[10:56:06] <dbaupp> :P
[10:56:08] <cmr> but this project won't be using the rustc that has the change
[10:56:11] <cmr> s
[10:56:13] <cmr> so I need to work around all of the things
[10:56:16] <cmr> <3 newtypes
[10:56:44] <dbaupp>  /o\ newtype structs after not being able to deref them
[10:56:56] <eddyb> #[deriving(Deref)]
[10:57:14] * dbaupp wishes we had Deref
[10:57:22] * cmr nominates eddyb
[10:57:25] <eddyb> it shouldn't be hard to implement
[10:57:31] <eddyb> though I shouldn't jinx it
[10:58:59] <dbaupp> eddyb: if you implement it'll take 40 weeks to get discussed in a meeting :P
[10:59:15] <cmr> srsly
[10:59:54] <dbaupp> especially because you are *required* to think up something else as a distraction for each meeting every week
[11:00:41] <eddyb> am I?
[11:01:16] <dbaupp> yep
[11:01:21] <dbaupp> or, we'll...
[11:01:36] <dbaupp> revoke your "friend of the tree" badge
[11:02:06] <cmr> gasp!
[11:02:14] <eddyb> dbaupp: remind me to stick that badge to my resume :P
[11:02:31] <dbaupp> that badge should *be* your resume
[11:03:29] <eddyb> dbaupp: you mean I shouldn't mention previous experience with systems programming in a custom C++ kernel?
[11:04:08] <dbaupp> eddyb: yep
[11:04:30] <dbaupp> just print out the github wiki page with your friend of the tree thingo
[11:04:54] <dbaupp> I guess you're allowed to highlight the relevant section, if you must.
[11:05:19] <eddyb> nmatsakis: it's not an error, the bare fn gets inlined into the wrapper
[11:06:03] <dbaupp> and we return to your regularly scheduled compiler development
[11:06:13] * dbaupp gets back to his review
[11:06:47] <eddyb> oh come on, I've compiled this mess only to find out I used "false" instead of "true" by default
[11:06:55] <eddyb> I guess I should've inverted my predicate
[11:08:28] <eddyb> now I hope it compiles without me having to use a different method to define a function instead of declaring it
[11:10:11] <eddyb> or is it the other way around?
[11:10:58] *** Joins: lpy (lpy@9248CA04.F930CE91.65042015.IP)
[11:11:48] *** Quits: luzie (lucy@moz-CD18B14B.customer.cdi.no) (Ping timeout)
[11:12:24] *** Joins: luziie (lucy@moz-CD18B14B.customer.cdi.no)
[11:12:48] *** Quits: lpy (lpy@9248CA04.F930CE91.65042015.IP) (Ping timeout)
[11:13:06] <cmr> oh fuck
[11:13:09] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[11:13:09] <ghrust> 01[13rust01] 15cmr pushed 1 new commit to 06master: 02http://git.io/N8y4ww
[11:13:09] <ghrust> 13rust/06master 147129960 15Corey Richardson: impl Clone for CString
[11:13:09] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[11:13:11] <cmr> shit
[11:13:18] <dbaupp> cmr: whoops :P
[11:13:20] <cmr> god dammit
[11:13:30] <cmr> The day I never thought would come ;_;
[11:13:33] <cmr> damn github web ui
[11:13:33] <dbaupp> at least bstrie_target and I have only done that with docs
[11:13:46] * cmr thought it would open a PR like it usually does
[11:13:48] <dbaupp> force push master back one commit?
[11:13:49] * cmr has commit access
[11:14:01] <cmr> and hope bors doesn't notice
[11:14:08] <dbaupp> since it doesn't compile....
[11:14:12] <eddyb> lol
[11:14:20] <dbaupp> cmr: you need an unsafe block
[11:14:25] <cmr> yes I do
[11:14:28] <dbaupp> for copy_nonoverlapping_memory
[11:14:32] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[11:14:32] <ghrust> 01[13rust01] 15cmr 04force-pushed 06master from 147129960 to 14b0280ac: 02http://git.io/V2xBBQ
[11:14:32] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[11:17:21] * dbaupp hopes no-one pulled in those 70 seconds
[11:18:34] *** flaper87|afk is now known as flaper87
[11:18:46] <cmr> :(
[11:20:15] <eddyb> dbaupp: good thing I forgot to rebase
[11:21:12] <eddyb> Global is external, but doesn't have external or dllimport or weak linkage!
[11:21:16] <eddyb> wat
[11:21:19] <eddyb> :(
[11:21:38] <dbaupp> meh, conflicting with my own PRs
[11:21:41] <dbaupp> would not recommend
[11:22:21] <eddyb> what's conflicting?
[11:22:41] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[11:23:10] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[11:24:41] <cmr> r? https://github.com/mozilla/rust/pull/11840
[11:25:01] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[11:25:21] <dbaupp> cmr: that seems simple enough, why don't you just push it straight to master?
[11:25:22] <dbaupp> :P
[11:25:27] <cmr> >_>
[11:25:27] <dbaupp> eddyb: my two deriving PRs
[11:25:48] <cmr> I didn't push anything, it was the evil web interface that I'm never using again ;_;
[11:25:56] <eddyb> dbaupp: between each other, or with trans?
[11:26:16] <dbaupp> eddyb: each other
[11:26:21] <dbaupp> one landed and invalidated the other
[11:26:40] <eddyb> dbaupp: you had a race (condition) :P
[11:26:48] <dbaupp> cmr: just be careful to do it from github.com/cmr/rust rather than mozilla/rust
[11:26:54] <dbaupp> that's what I learnt anyway
[11:27:56] * dbaupp has even set his default upstream git remote to have invalid push URL for fear of making the same mistake again
[11:28:11] <cmr> I just set upstream to read-only
[11:28:20] <dbaupp> is that possible?
[11:28:23] <dbaupp> that'd be simpler
[11:28:23] <cmr> yup
[11:28:27] <cmr> I do not remember how
[11:28:32] <cmr> but it's deffers possible
[11:28:49] <dbaupp> http://stackoverflow.com/questions/10270027/can-i-mark-a-git-remote-as-read-only
[11:28:59] <dbaupp> the second is basically what I did :P
[11:29:15] <dbaupp> oh, I guess changing to one of the read only protocols would work too
[11:29:23] <cmr> ah yeah looking now that's what I did
[11:29:31] <cmr> just git://
[11:29:54] <eddyb> I have origin which is eddyb/rust and parent which is mozilla/rust
[11:30:11] <eddyb> I started doing that for all my github forks some time ago
[11:30:21] <eddyb> git pull --rebase parent master makes complete sense :P
[11:31:40] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[11:31:40] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 141caa5b9 to 14b0280ac: 02http://git.io/N3iJvQ
[11:31:40] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[11:34:24] *** Quits: luziie (lucy@moz-CD18B14B.customer.cdi.no) (Connection reset by peer)
[11:34:36] *** Joins: luziie (lucy@moz-CD18B14B.customer.cdi.no)
[11:44:13] <cmr> re-r? https://github.com/mozilla/rust/pull/11840
[11:45:05] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Client exited)
[11:45:26] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[11:45:45] <dbaupp> cmr: if squash { r=me }
[11:46:10] <eddyb> if only we had = overloading
[11:46:16] <cmr> hell no
[11:46:28] <cmr> of all the operators I want to be certain I know what they do
[11:46:31] <cmr> = is #1
[11:47:06] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Ping timeout)
[11:47:16] * dbaupp wants postifx +
[11:47:26] <dbaupp> just so r+ is valid
[11:47:59] <eddyb> dbaupp: then I++I
[11:48:35] <eddyb> would be valid, yet ambiguous
[11:48:41] <eddyb> rusti: +5
[11:48:42] -rusti- <anon>:10:9: 10:10 error: unexpected token: `+`
[11:48:42] -rusti- <anon>:10         +5
[11:48:42] -rusti-                   ^
[11:48:42] -rusti- application terminated with error code 101
[11:48:51] <eddyb> o_O we don't have that
[11:48:58] <eddyb> it could be a sigil!
[11:49:13] <dbaupp> the + pointer
[11:49:15] <cmr> it used to be a mode.
[11:49:53] <eddyb> cmr: are you trying to resurrect something?
[11:50:20] <cmr> hm?
[11:51:35] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[11:51:35] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14baa5c8b to 14b0280ac: 02http://git.io/N3iJvQ
[11:51:35] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[11:52:39] <cmr> eddyb: did you write pure-rust zlib or just png?
[12:02:27] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[12:07:54] <eddyb> modes... I heard that was an old thing
[12:07:58] *** Quits: rca (rcatolino@moz-D690CDA.adsl.proxad.net) (Ping timeout)
[12:08:00] <cmr> it was.
[12:08:03] <eddyb> cmr: I've been putting it off, sorry
[12:08:14] <cmr> eddyb: nah just wondering the extent of what you did
[12:08:18] <cmr> you're a hero <3
[12:09:03] <eddyb> just don't start a comic book after me
[12:11:00] <dbaupp> eddyb: I reckon you'd look good in a cape
[12:11:10] <eddyb> you haven't even seen me!
[12:11:15] * dbaupp doesn't care
[12:11:40] <doener> hm, we could/should run prune-eh later or more often. Appending just that pass to what -O makes a few more functions as nounwind, and turns invokes into plain calls
[12:11:41] <eddyb> though someone showed me some older birthday pics, I look ridiculous(ly silly)
[12:11:43] *** Joins: lpy (lpy@9248CA04.F930CE91.65042015.IP)
[12:12:03] <eddyb> doener: and probably strips a ton of landing pads
[12:12:04] <dbaupp> doener: how expensive is prune-eh?
[12:12:19] <dbaupp> eddyb: (isn't that exactly what turning invokes into plain calls is?)
[12:12:28] <eddyb> doener: what's the difference with wc -l?
[12:12:54] <eddyb> dbaupp: well, you can have invoke with no landing pad, I think
[12:13:03] <dbaupp> sounds weird
[12:13:13] <eddyb> though now I'm not sure whether you need invoke for all functions that unwind
[12:13:22] <eddyb> or you can use call if you don't have a landing pad
[12:13:30] *** Quits: lpy (lpy@9248CA04.F930CE91.65042015.IP) (Ping timeout)
[12:13:30] <dbaupp> eddyb: http://llvm.org/docs/LangRef.html#invoke-instruction doesn't make the landing pad optional
[12:14:03] <eddyb> okay then, still, I want to see a wc -l difference for something decently large
[12:14:11] <doener> eddyb: about -0.2% in terms of lines of generated assembly for librustc a few thousand lines of ll
[12:14:22] <eddyb> oh, nice
[12:14:34] <eddyb> (every line counts :P)
[12:14:34] <doener> dbaupp: test run had the compile time down by ~1.5s, but that might be noise
[12:14:55] <dbaupp> doener: down! despite running more passes, nice
[12:14:55] <doener> dbaupp: (generating .s not the .so)
[12:15:19] <doener> dbaupp: it's less code, and we spend a lot in the llvm->machine passes IIRC
[12:15:32] <cmr> we do
[12:15:35] <dbaupp> yeah
[12:15:38] <eddyb> that's an interesting revelation
[12:15:55] <cmr> It makes me wonder if llvm's algorithms or data structures scale poorly for very large modules.
[12:16:04] <eddyb> doener: I still need to figure which pass devirtualizes a call but doesn't inline it, in my fmt rewrite
[12:16:44] <doener> eddyb: might be because inline costs are determined quite early IIRC
[12:16:49] *** Quits: luziie (lucy@moz-CD18B14B.customer.cdi.no) (Ping timeout)
[12:16:59] <eddyb> doener: no, I mean, it doesn't run an inlining pass
[12:17:08] <doener> eddyb: ah, ok
[12:17:18] *** Joins: luziie (lucy@moz-CD18B14B.customer.cdi.no)
[12:17:18] <eddyb> adding --passes inline gets it further
[12:19:00] <eddyb> r=nmatsakis? https://github.com/mozilla/rust/pull/11595
[12:19:01] <doener> eddyb: just mentioned it, because in the past we've seen "large" improvements in inlining behaviour by changes that just removed "trivial" stuff like unneeded unconditional branches
[12:19:09] <eddyb> that stupid corner case works
[12:19:50] <cmr> eddyb: needs rebase
[12:19:57] <eddyb> of course it does :-<
[12:20:23] <eddyb> doener: oh I have some code with some match cases that are never actually triggered, but their presence causes a 2x performance loss
[12:20:25] <dbaupp> doener: can we explicitly recalculate inlining costs occasionally?
[12:20:47] <dbaupp> eddyb: would an unreachable intrinsic help?
[12:21:00] <eddyb> dbaupp: no, those had real code in them
[12:21:17] <eddyb> point is, practically unreachable code slows down the entire function with its presence
[12:21:31] <dbaupp> oh, I see
[12:21:40] <eddyb> closures have "inlinehint" while I'd almost argue "alwaysinline" is sane for them
[12:21:42] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[12:21:46] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[12:21:51] <dbaupp> so they're not unreachable, just very rare?
[12:22:13] <dbaupp> do we have a way to mark branches as cold?
[12:22:27] *** Joins: rca (rcatolino@moz-D690CDA.adsl.proxad.net)
[12:23:24] <kimundi> Well there is a way to mark a function as cold
[12:25:17] <doener> dbaupp: we'd probably have to go back to populating the passmanager ourselves. And I'm really just guessing about the cost calculation being "too early"
[12:25:53] <dbaupp> kimundi: yup... I'm using it in the PR I was supposed to open hours ago
[12:26:09] * dbaupp should probably finish the final commit message
[12:26:54] *** Quits: mankyKitty (Instantbir@moz-9B898D95.enst-bretagne.fr) (Quit: mankyKitty)
[12:27:24] <eddyb> dbaupp: still not the point :)
[12:27:25] <dbaupp> doener: hm, that's annoying... (what would be cool is a collection of "real world" programs/benchmarks and then a superoptimiser script that determines a reasonable default set of passes, like someone did with GHC(?))
[12:27:31] *** Quits: rca (rcatolino@moz-D690CDA.adsl.proxad.net) (Ping timeout)
[12:27:43] <dbaupp> eddyb: it'd probably help, but yeah :)
[12:27:52] <eddyb> with a switch?
[12:28:01] <eddyb> dbaupp: their presence inflated the function/added closures which ended up screwing optimizations for the entire function
[12:28:03] <dbaupp> ordering the blocks
[12:28:08] <dbaupp> oh, right
[12:29:07] <eddyb> CONFLICT (content): Merge conflict in src/librustc/middle/trans/meth.rs
[12:29:11] <eddyb> *not there* :(
[12:29:56] <eddyb> oh, heh, FIXME, it could be worse
[12:31:07] *** Joins: rca (rcatolino@moz-D690CDA.adsl.proxad.net)
[12:32:43] <eddyb> cmr: what about now?
[12:34:04] <cmr> eddyb: r+
[12:35:04] <eddyb> cmr: thanks :D
[12:42:11] <kimundi> cmr: Hm, looked at your CString clone PR - is it correct to always clone to a owned CString?
[12:42:26] <cmr> kimundi: It's never incorrect :)
[12:42:59] <cmr> kimundi: do you think it should only own it if the thing it's cloned from owns it?
[12:43:06] <cmr> In my own usecase I always wanted it to be owned..
[12:43:07] <dbaupp> kimundi: you're copying it into a new allocation
[12:43:18] <dbaupp> so the new CString does own its contents
[12:43:31] <dbaupp> (otherwise you have a memory leak, right?)
[12:43:48] <cmr> well you could just not copy the contents
[12:43:52] <cmr> but that wouldn't be very useful as a clone..
[12:43:58] *** Joins: gwty (gwtypc@38A0A9BD.D56F0A4C.E7DAB6F9.IP)
[12:44:24] <kimundi> Maybe I misunderstand how CStrings are used: As far as I can see, a CString can either own the buffer it points at or not, which means its kinda like a enum between ~ and & (roughly speaking, ignoring mutability)
[12:44:39] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[12:45:18] <kimundi> In Rust types, a ~T gets cloned to a ~T and a &T gets cloned to a &T, so it would seem to me at least possible that that would be the consistent thing to do for a CString
[12:45:32] <cmr> &T is cloned to a T isn't it?
[12:45:37] <kimundi> No
[12:45:43] <dbaupp> cmr: no, there's a clone impl for &T
[12:45:45] <cmr> oh
[12:46:10] <kimundi> The clone _signature_ is using &T, but the self type is T
[12:46:37] <kimundi> therefore, clone of a &T has a self type of &T, and the method signature takes & &T
[12:46:46] <cmr> right
[12:47:40] <kimundi> Anyway, I have the feeling that clone for Cstring only memcpying if it is owned would be more consistent, in combination with a .make_owned() method
[12:47:51] *** Quits: luziie (lucy@moz-CD18B14B.customer.cdi.no) (Quit: Leaving)
[12:47:59] *** Joins: luziie (lucy@moz-CD18B14B.customer.cdi.no)
[12:48:02] <kimundi> But maybe that leads to more bugs in the long run with people misusing this api
[12:48:10] <kimundi> So... Dunno what would be better
[12:48:28] <cmr> I know that I would definitely have had a use-after-free if the Clone wasn't owning.
[12:48:36] <cmr> (and I forgot to use make_owned)
[12:48:50] <kimundi> cmr: Well, you'D not have it more than before
[12:48:57] <cmr> oh right
[12:48:59] <cmr> it was already owned
[12:49:17] <kimundi> not-owned*
[12:49:25] <cmr> Can any safe usage of CString be incorrect with clone copying the receiver's ownage?
[12:49:41] <eddyb> define "safe"
[12:49:43] <cmr> I don't thinks so...
[12:49:51] <cmr> eddyb: doesn't use the unsafe constructors.
[12:50:05] <kimundi> Well, I guess if you clone it and you can mutate it through a CString, you'd get mutable aliasing
[12:50:31] <kimundi> But I'm not sure if you can mutate it :P
[12:50:36] * kimundi should look at the docs again
[12:51:14] <cmr> no, CString is immutable.
[12:51:24] <cmr> only way to mutate it would be calling one of its unsafe methods.
[12:51:33] <kimundi> oh, then that wouldn't be a problem, I think
[12:52:00] <kimundi> (At least not from the Rust side :P)
[12:53:24] <kimundi> Also afaik clone() is defined as copying the ownership tree of the type, and notmore - which I think would technically make always-owing-clone incorrect? :?
[12:53:35] <cmr> maybe..
[12:53:37] <eddyb> I'm curious... if we send a 1KB string to C, what's costlier? the malloc or the memcpy?
[12:53:46] <cmr> eddyb: which malloc?
[12:54:06] <eddyb> cmr: if you have to copy it and add a \0
[12:54:15] <cmr> no
[12:54:18] <cmr> I mean which implementation :)
[12:54:19] <kimundi> eddyb: I'd say the memcpy
[12:54:37] <eddyb> cmr: latest glibc :P
[12:54:39] <cmr> the memcpy is *maybe* slower...
[12:54:44] <kimundi> malloc could in theory be cahced or stuff - the memcpy is always O(n)
[12:55:02] <eddyb> how about 16 bytes?
[12:55:04] <cmr> for only 1K it's going to be a close call I think
[12:55:12] <cmr> 16 bytes the malloc is definitely going to be worse.
[12:55:17] <cmr> the "memcpy" is just going to be a mov
[12:55:40] <cmr> kimundi: dbaupp: updated https://github.com/mozilla/rust/pull/11840
[12:55:43] <eddyb> SmallCString, anyone?
[12:55:48] <eddyb> or can we get alloca already?
[12:55:53] <cmr> please no alloca
[12:56:01] <eddyb> cmr: VLA only
[12:56:01] <cmr> it kills stack analysis and makes me a sadpanda
[12:56:07] <eddyb> oh :(
[12:56:20] <cmr> (runtime-sized alloca, that is)
[12:56:36] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[12:56:36] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1450eb946 to 14b0280ac: 02http://git.io/N3iJvQ
[12:56:36] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[12:56:38] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[12:56:38] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/fapQBw
[12:56:38] <ghrust> 13rust/06auto 1415ba0c3 15Eduard Burtescu: Demote self to an (almost) regular argument and remove the env param....
[12:56:38] <ghrust> 13rust/06auto 146575b90 15bors: auto merge of #11595 : eddyb/rust/env-et-self-no-more, r=nikomatsakis...
[12:56:38] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[12:57:20] <eddyb> why do I have to retry large PRs at least 3 times?
[12:57:34] <kimundi> cmr: Heh, sorry for ruining your chance at a bors merge right now :P
[12:57:41] <cmr> kimundi: it's fine, I'm in no rush
[12:58:03] <cmr> Shell for my OS assignment: https://github.com/cmr/cs444-lab1
[12:59:55] <dbaupp> cmr: does `history 2` what I expect?
[13:00:03] <cmr> dbaupp: last 2 entries, yes.
[13:00:26] <dbaupp> coolcool
[13:00:35] <cmr> it's actually wrong though, the take should be after the enumerate
[13:00:38] <cmr> (the numbering is off)
[13:01:06] <dbaupp> cmr: https://github.com/cmr/cs444-lab1/blob/master/main.rs#L83 no it doesn't! it changes to ~ here :P
[13:01:48] *** Quits: luziie (lucy@moz-CD18B14B.customer.cdi.no) (Connection reset by peer)
[13:02:01] *** Joins: luziie (lucy@moz-CD18B14B.customer.cdi.no)
[13:02:15] <cmr> dbaupp: what is this, posix sh? :p
[13:03:59] <dbaupp> cmr: is this safe?/does it work reliably? https://github.com/cmr/cs444-lab1/blob/master/main.rs#L179
[13:04:09] <cmr> dbaupp: with libnative yes afaict
[13:04:15] <cmr> haven't been able to make it die yet.
[13:04:18] <dbaupp> ok
[13:04:30] <cmr> I think the timers that just landed might have problems with the helper thread...
[13:04:51] *** Joins: luzie (lucy@moz-CD18B14B.customer.cdi.no)
[13:05:38] *** Quits: luziie (lucy@moz-CD18B14B.customer.cdi.no) (Ping timeout)
[13:06:39] <dbaupp> cmr: erm, https://github.com/cmr/cs444-lab1/blob/master/main.rs#L329 ... it continues even if res == 0xFFFF
[13:07:03] <cmr> yeah that code used to be somewhere else that did something else.
[13:07:33] <cmr> I have literally no idea how that's even supposed to work, but that's what waitstatus.h does :\
[13:07:53] <dbaupp> <3 cargo culting
[13:10:43] <cmr> dbaupp: do you know how parsers are supposed to work? is what I do sane? it's the first parser I've written besides terminfo which is super trivial
[13:11:06] <eddyb> cmr: you're supposed to use enums for a state machine
[13:11:34] <dbaupp> cmr: i.e. parse_line?
[13:11:47] <dbaupp> eddyb: bools are enums
[13:11:51] <dbaupp> :P
[13:11:56] <eddyb> I wish
[13:12:08] <eddyb> #[lang="bool"] enum bool { false, true }
[13:12:25] <dbaupp> cmr: seems reasonable, although `x 'a b'` won't work
[13:12:30] *** Joins: lpy (lpy@9248CA04.F930CE91.65042015.IP)
[13:13:44] <cmr> dbaupp: yeah
[13:13:52] <cmr> not in requirements ;p
[13:14:10] <dbaupp> cmr: also is `x & b` meant to be calling x with args ["&", "b"] rather than a syntax error?
[13:14:11] *** Quits: lpy (lpy@9248CA04.F930CE91.65042015.IP) (Ping timeout)
[13:14:23] <cmr> dbaupp: yeah that's how I decided to do it.
[13:14:34] <cmr> real sh would run x in the background then b.
[13:14:41] <dbaupp> yeah
[13:15:06] <dbaupp> I was just assuming that with one-command-per-line that & would be required to appear only at the end
[13:15:14] <dbaupp> but whatever
[13:15:27] <eddyb> if we make that work as good as clang's bool, then we will have better code for any enum with two variants
[13:16:07] <cmr> eddyb: #[repr(i1)]
[13:16:14] <cmr> probably still worse.
[13:16:28] <eddyb> cmr: that should be the default
[13:16:40] <cmr> eddyb: it would be if i1 were a valid repr ;p
[13:17:11] <eddyb> so we're just doing i8 + !range?
[13:17:25] <dbaupp> yes
[13:18:45] *** Quits: luzie (lucy@moz-CD18B14B.customer.cdi.no) (Connection reset by peer)
[13:18:58] *** Joins: luzie (lucy@moz-CD18B14B.customer.cdi.no)
[13:20:53] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[13:23:55] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[13:25:45] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[13:51:45] *** Joins: rca_ (rcatolino@moz-3F131AFE.adsl.proxad.net)
[13:52:22] *** Quits: rca (rcatolino@moz-D690CDA.adsl.proxad.net) (Ping timeout)
[13:56:51] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[14:04:02] *** Joins: lpy (lpy@9248CA04.F930CE91.65042015.IP)
[14:06:58] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[14:06:58] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/PAjMMA
[14:06:58] <ghrust> 13rust/06auto 143671ab2 15Huon Wilson: syntax: make deriving have slightly less cryptic error messages....
[14:06:58] <ghrust> 13rust/06auto 1405cbcd0 15bors: auto merge of #11826 : huonw/rust/7621-deriving-errors, r=alexcrichton...
[14:06:58] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[14:07:29] <eddyb> that took a while
[14:07:43] <eddyb> so it can't be just a simple failure... but I didn't see a merge notice
[14:08:00] <eddyb> https://github.com/mozilla/rust/pull/11595#commitcomment-5186714 what is this? a failure notice for ants?
[14:08:20] <eddyb> cmr: are the build bots down or something?
[14:08:50] <eddyb> task 'tests::no_rebuilding_dep' failed at 'no_rebuilding_dep failed for some other reason', /Users/rustbuild/src/rust-buildbot/slave/auto-mac-64-opt/build/src/librustpkg/tests.rs:1069
[14:09:00] <cmr> buildslaves are up..
[14:09:11] *** Joins: mankyKitty (Instantbir@moz-21AD3B58.rev.sfr.net)
[14:09:59] <eddyb> cmr: the rest weren't interrupted because they succeeded :)
[14:10:28] <eddyb> cmr: I lost to a flake. not even a snow flake. or some new rustpkg bug on mac
[14:10:56] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[14:11:17] *** Quits: mankyKitty (Instantbir@moz-21AD3B58.rev.sfr.net) (Quit: mankyKitty)
[14:11:18] <dbaupp> cmr: https://github.com/mozilla/rust/issues/11843 is that after doing a full make?
[14:11:48] <cmr> dbaupp: don't think so, checking with a full make.
[14:19:36] <eddyb> did anyone have the same mac failure?
[14:19:52] <eddyb> I can't even legally reproduce it
[14:21:30] <eddyb> oh, there's a retry
[14:21:36] *** Joins: canhtak (canhtak@moz-9E539298.wl.t.ulaval.ca)
[14:21:47] <eddyb> cmr: mind pushing to try in the meanwhile? if it's empty, that is
[14:22:01] <cmr> eddyb: sure
[14:22:18] <eddyb> thanks. I hate to see hours wasted on tests >:(
[14:25:05] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[14:25:05] <ghrust> 01[13rust01] 15cmr 04force-pushed 06try from 140515d70 to 1415ba0c3: 02http://git.io/k471pw
[14:25:05] <ghrust> 13rust/06try 1415ba0c3 15Eduard Burtescu: Demote self to an (almost) regular argument and remove the env param....
[14:25:05] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[14:25:53] <dbaupp> eddyb: the approved queue is pretty empty, so it's fine
[14:41:49] *** Joins: mankyKitty (Instantbir@moz-21AD3B58.rev.sfr.net)
[14:42:06] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[14:42:06] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1405cbcd0 to 14b0280ac: 02http://git.io/N3iJvQ
[14:42:06] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[14:42:06] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[14:42:06] <ghrust> 01[13rust01] 15bors pushed 1 new commit to 06auto: 02http://git.io/ZQw5iQ
[14:42:06] <ghrust> 13rust/06auto 14543eb07 15bors: auto merge of #11595 : eddyb/rust/env-et-self-no-more, r=nikomatsakis...
[14:42:06] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[14:42:27] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[14:42:27] *** ChanServ sets mode: +ao dherman dherman
[14:42:31] <eddyb> cmr: heh, I guess I'd get two successes, if it works
[14:42:48] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[14:49:53] <mankyKitty> If anyone has time I'm need of some help with this PR I've been working on for checking extern fns: https://github.com/mozilla/rust/pull/11804
[14:50:09] <mankyKitty> I've gotten a fair way (I think) but not sure how to proceed :(
[14:50:57] *** Quits: c-a (c-a@moz-57C82A9.a163.priv.bahnhof.se) (Ping timeout)
[14:51:11] *** Joins: c-a (c-a@moz-57C82A9.a163.priv.bahnhof.se)
[14:54:02] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[15:18:45] <eddyb> "This repository is currently offline."
[15:22:25] <mankyKitty> Yeah I noticed that >< poor gitty-hoob
[15:23:05] <eddyb> but linux tests worked earlier
[15:23:13] <eddyb>     [run-fail] run-fail/assert-macro-static.rs
[15:23:35] <mankyKitty> is that a happy test or a sad test?
[15:23:45] <eddyb> error: error pattern 'failed at 'test-assert-static'' not found!
[15:23:53] <eddyb> come on, what is his?
[15:24:01] <mankyKitty> what the what. o.O
[15:24:11] <mankyKitty> but YAY for linux tests working
[15:24:50] <eddyb> task '<main>' failed at 'test-assert-static', src/test/run-fail/assert-macro-static.rs:14
[15:24:52] <eddyb> it fails locally
[15:25:00] <eddyb> (which is what it's supposed to do)
[15:26:11] <mankyKitty> oh okay good... thought you'd found a broken test I hadn't seen
[15:26:44] <eddyb> http://buildbot.rust-lang.org/builders/auto-linux-32-opt/builds/3848/steps/test/logs/stdio
[15:26:56] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[15:26:56] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14543eb07 to 14b0280ac: 02http://git.io/N3iJvQ
[15:26:56] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[15:27:26] <mankyKitty> oh right
[15:27:48] <eddyb> and three slaves are behind
[15:27:51] <eddyb> it's madness
[15:28:03] <mankyKitty> :(
[15:29:16] <mankyKitty> Do you have a separate build machine for your own testing or do you do it all in one?
[15:29:36] <eddyb> mankyKitty: just my ASUS laptop :(
[15:29:44] <mankyKitty> beefy?
[15:30:48] <eddyb> when I bought it, 3 years ago, sure :P
[15:33:01] <mankyKitty> hahaha fair enough, I started contracting full time for the first time over a year ago and I treated myself to a delicious, over priced, offensively specced macbook pro
[15:34:50] <eddyb> mankyKitty: the money for this one was from freelancing. I stopped doing that because dealing with clients was too hard >_>
[15:37:40] *** Quits: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net) (Input/output error)
[15:38:17] <eddyb> http://buildbot.rust-lang.org/grid?branch=auto&refresh=15
[15:38:22] <eddyb> it's not even the right hashes
[15:38:25] <mankyKitty> eddyb: yeahhhh that i can appreciate, I want to be employed doing this (open source awesome) really
[15:38:32] <mankyKitty> eddyb: O_o whaaaaaaa
[15:38:34] <eddyb> cmr: what on earth is going on?
[15:38:44] <eddyb> and github is down so I can't check what those commits are
[15:39:11] <eddyb> "15ba0c3 merged ok, testing candidate = 543eb07"
[15:39:23] <eddyb> but neither of those is in the grid
[15:39:30] <eddyb> so what did I get a test failure for?
[15:40:15] <mankyKitty> I have no idea :(
[15:40:23] <mankyKitty> I'm barely understanding what I'm doing as it is :P
[15:42:38] <eddyb> http://buildbot.rust-lang.org/tgrid?branch=auto&refresh=15 okay, so the one that failed for me was that + 1
[15:42:49] <eddyb> the build numbers, I mean
[15:43:16] <eddyb> http://buildbot.rust-lang.org/console?branch=auto&refresh=15 maybe this is better than the waterfall
[15:44:09] <eddyb> try-linux was fine
[15:44:55] <eddyb> cmr: can I get a retry or something? this is stupid
[15:45:07] <eddyb> nothing changed, but then I failed
[15:46:32] <eddyb> nmatsakis: making it pass seems harder than getting a complete review *sigh*
[15:51:32] <Yurume> is there some way to inspect the metadata?
[15:51:56] <eddyb> Yurume: a hex editor?
[15:52:02] <Yurume> :S
[15:52:19] <Yurume> well, it might not be a problem of metadata anyway... well.
[15:52:30] <eddyb> not really, though I do have a JS prettyprinter that works for almost any data structure
[15:52:43] <pnkfelix> Yurume: when I had to debug metadata bug recently, I mostly got by via RUSTLOG instrumentation of the metadata code
[15:52:53] <eddyb> like, a NBT loader where you just drop a file and it gives you the entire structure
[15:53:01] <Yurume> that... might work.
[15:53:03] <pnkfelix> Yurume: (though I think I ended up adding a bunch more debug! calls to the code in order to get the info I needed)
[15:53:20] <Yurume> well, anyway. I suffer from the delicate calling convention issue right now
[15:54:09] *** Quits: luzie (lucy@moz-CD18B14B.customer.cdi.no) (Ping timeout)
[15:54:14] <Yurume> where the crate A defined extern fns with `stdcall` ABI and wrappers for them, and the crate B which (dynamically) links to A works fine.
[15:55:15] *** Joins: luziie (lucy@moz-CD18B14B.customer.cdi.no)
[15:55:24] <Yurume> the problem arises from the crate B using A's extern fns directly (or using generic wrappers), where `stdcall` ABI seems to be ignored and it reverts to `cdecl`.
[15:56:14] <eddyb> Yurume: I'd look at the decoding code
[15:56:39] <eddyb> Yurume: and try to find information that it doesn't actually decode, i.e. defaults
[15:56:53] <eddyb> something like abis: None
[15:57:31] <Yurume> thank you for suggestions, I'll do that
[15:58:30] <eddyb> because the encoding code just puts a bunch of data in, harder to spot that something is missing
[16:02:30] <Yurume> https://github.com/mozilla/rust/blob/master/src/librustc/metadata/encoder.rs#L1316 ...hmm!
[16:02:41] <Yurume> oops, sorry, line 1319 instead
[16:03:35] <Yurume> it encodes to ImpureFn (family 'f', which is just an Fn in the decoder) instead of ExternFn (family 'e')?
[16:03:41] *** Quits: canhtak (canhtak@moz-9E539298.wl.t.ulaval.ca) (Ping timeout)
[16:03:44] <eddyb> dbaupp, cmr, acrichto, and whomever I may annoy at this hour: retry pls? https://github.com/mozilla/rust/pull/11595
[16:06:48] <eddyb> Yurume: but where would the calling convention be encoded?
[16:06:53] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[16:08:46] <eddyb> Yurume: https://github.com/mozilla/rust/blob/master/src/librustc/metadata/tydecode.rs#L474-L486
[16:09:02] <eddyb> https://github.com/mozilla/rust/blob/master/src/librustc/metadata/tydecode.rs#L513-L522
[16:12:36] <Yurume> so it should say `[system]` or so somewhere.
[16:13:07] <eddyb> https://github.com/mozilla/rust/blob/master/src/librustc/metadata/tyencode.rs#L318
[16:13:14] <Yurume> (for extern "system" { ... })
[16:13:19] *** Joins: jdm (jdm@moz-D434EC03.dsl.sca.megapath.net)
[16:13:41] <eddyb> Yurume: you need to get something to show you the bare fn types
[16:13:54] <eddyb> Yurume: the types of those functions should be extern "system" fn....
[16:14:15] <eddyb> rusti: extern "system" { fn write(); } write
[16:14:16] -rusti- fn()
[16:14:22] <eddyb> that's not a good sign
[16:14:25] <eddyb> rusti: extern "system" { fn write(); } let () = write
[16:14:25] -rusti- <anon>:11:5: 11:6 error: expected `;` but found `}`
[16:14:25] -rusti- <anon>:11     };
[16:14:25] -rusti-               ^
[16:14:25] -rusti- application terminated with error code 101
[16:14:26] <Yurume> eddyb, but yeah, so it is a function with extern "ABI" fn types, so ImpureFn/ExternFn mismatch is... curious but might not be a non-issue.
[16:14:28] <eddyb> rusti: extern "system" { fn write(); } let () = write;
[16:14:29] -rusti- <anon>:10:45: 10:47 error: mismatched types: expected `extern "system" unsafe fn()` but found `()` (expected extern fn but found ())
[16:14:29] -rusti- <anon>:10         extern "system" { fn write(); } let () = write;
[16:14:29] -rusti-                                                       ^~
[16:14:31] -rusti- error: aborting due to previous error
[16:14:33] -rusti- application terminated with error code 101
[16:15:49] <eddyb> Yurume: check the type when it's imported from a different crate
[16:16:10] <eddyb> that let () trick should be enough
[16:16:32] <eddyb> tyencode/tydecode looks sane, so I'm not sure what's doing it
[16:19:28] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[16:19:57] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[16:21:43] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[16:24:07] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[16:24:09] *** Quits: rustilite (rustilite@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[16:25:42] *** Joins: rustilite (rustilite@moz-54F7FD49.cpe.net.cable.rogers.com)
[16:25:53] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[16:35:55] *** Quits: Kxepal (Miranda@moz-8174652F.pppoe.mtu-net.ru) (Ping timeout)
[16:38:26] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Client exited)
[16:38:48] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[16:40:42] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Ping timeout)
[16:43:54] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[16:47:24] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[16:51:06] *** Quits: luziie (lucy@moz-CD18B14B.customer.cdi.no) (Connection reset by peer)
[16:51:46] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[16:52:22] *** Joins: luz (lucy@moz-CD18B14B.customer.cdi.no)
[16:58:52] *** Joins: dherman (dherman@moz-DFAA4E15.p2p.sfo1.mozilla.com)
[16:58:52] *** ChanServ sets mode: +ao dherman dherman
[17:08:30] *** Joins: canhtak (canhtak@moz-9E539298.wl.t.ulaval.ca)
[17:12:12] *** Quits: jdm (jdm@moz-D434EC03.dsl.sca.megapath.net) (Ping timeout)
[17:14:14] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[17:15:18] <Yurume> a-ha!
[17:15:43] <Yurume> eddyb, well, I think I've found the culprit, and that was (fortunately) not a metadata but misplaced #[link] attr. :(
[17:16:03] <eddyb> Yurume: whose fault?
[17:16:12] <Yurume> rust-opengles?
[17:16:35] <Yurume> though I'm using my own fork of rust-opengles for the use with ANGLE, so I might as well be guilty
[17:18:23] *** Quits: irving-cloud (uid24297@moz-31ABA2C0.irccloud.com) (Ping timeout)
[17:19:47] <Yurume> eddyb, well, so rust-opengles had #[nolink] extern { ... } block without #[link] (which is placed before the empty extern{}) and subsequently the user crate failed to see that using symbols from that extern block requires given link args.
[17:20:10] <eddyb> oh that silly thing, seen it before
[17:20:17] <Yurume> so it was not really the calling convention problem but was the linkage problem (manifested itself as a calling convention problem).
[17:20:21] <eddyb> Yurume: is there any point to the whole thing?
[17:20:32] <Yurume> what do you mean by the whole thing?
[17:20:46] <eddyb> Yurume: the empty extern, #[nolink], etc.
[17:21:33] <Yurume> I don't think so, but #[link] block varies among the platforms (and OpenGL would have lots of symbols in the extern block) so it might mean the duplication of lots of code.
[17:22:46] <Yurume> ...or use the macro contraption. :S
[17:26:45] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[17:26:45] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/Tq4cig
[17:26:45] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[17:26:58] *** Joins: jdm (jdm@moz-C07D5168.p2p.sfo1.mozilla.com)
[17:26:58] <eddyb> can I get a retry now?
[17:27:26] <eddyb> pnkfelix: hah, that was stealthy, thanks :D
[17:28:53] *** Joins: jdm_ (jdm@moz-DFAA4E15.p2p.sfo1.mozilla.com)
[17:29:22] *** Quits: jdm (jdm@moz-C07D5168.p2p.sfo1.mozilla.com) (Ping timeout)
[17:29:51] <Yurume> gl2.rs:1467:19: 1467:32 error: macros cannot expand to foreign items
[17:29:55] <Yurume> uh-oh. :)
[17:30:19] <Yurume> eddyb, maybe I should check for such bad usage of empty extern block
[17:30:23] <Yurume> for other projects
[17:30:43] <eddyb> I know rust-png does it
[17:31:45] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[17:31:45] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/K3paiA
[17:31:45] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[17:31:48] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[17:31:48] <ghrust> 01[13rust01] 15bors pushed 1 new commit to 06auto: 02http://git.io/BhdYTA
[17:31:48] <ghrust> 13rust/06auto 14d6d7812 15bors: auto merge of #11595 : eddyb/rust/env-et-self-no-more, r=nikomatsakis...
[17:31:48] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[17:32:37] *** Quits: lpy (lpy@9248CA04.F930CE91.65042015.IP) (Client exited)
[17:47:06] <nate> jld: could you look at https://github.com/mozilla/rust/pull/11759 when you get a chance?
[17:47:36] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: rcirc on GNU Emacs 24.3.1)
[17:53:06] *** Joins: pcwalton (pcwalton@moz-DA87EE4.hsd1.ca.comcast.net)
[17:53:06] *** ChanServ sets mode: +ao pcwalton pcwalton
[17:53:08] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[17:53:18] *** jdm_ is now known as jdm
[17:55:27] *** Joins: irving-cloud (uid24297@moz-31ABA2C0.irccloud.com)
[17:58:52] *** Joins: TimAbraldes (quassel@125EF623.B2666F0E.66399531.IP)
[18:03:24] *** Joins: lpy (lpy@9248CA04.F930CE91.65042015.IP)
[18:05:23] *** Quits: lpy (lpy@9248CA04.F930CE91.65042015.IP) (Ping timeout)
[18:20:20] <doener> ouch... "configure" runs clean on the submodule :-/ bye bye llvm hackery
[18:26:58] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[18:26:58] *** ChanServ sets mode: +qo brson brson
[18:29:33] *** Quits: pcwalton (pcwalton@moz-DA87EE4.hsd1.ca.comcast.net) (Quit: pcwalton)
[18:40:52] <acrichto> Eridius: ping
[18:46:55] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[18:46:55] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/V4fVNA
[18:46:55] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[18:48:02] *** Quits: mankyKitty (Instantbir@moz-21AD3B58.rev.sfr.net) (Ping timeout)
[18:49:03] <flaper87> mmh, time tu figure out what it is that I broke with my last patch
[18:49:11] *** Joins: mankyKitty (Instantbir@moz-21AD3B58.rev.sfr.net)
[18:51:49] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[18:51:49] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/xdfBTQ
[18:51:49] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[18:51:49] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[18:51:50] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/c_DNJQ
[18:51:50] <ghrust> 13rust/06auto 14e5abe66 15Huon Wilson: std: reduce the generic code instantiated by fail!()....
[18:51:50] <ghrust> 13rust/06auto 14b4bb8c0 15Huon Wilson: std: add begin_unwind_fmt that reduces codesize for formatted fail!()....
[18:51:50] <ghrust> 13rust/06auto 1405dc3bf 15bors: auto merge of #11841 : huonw/rust/noinline-fail, r=alexcrichton...
[18:51:51] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[18:52:54] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[18:53:15] <eddyb> acrichto: https://github.com/mozilla/rust/pull/11595 - can you put UFCS (like Clone::clone) on the meeting agenda?
[18:53:53] <acrichto> eddyb: I don't know enough about how that PR affects it to talk about it
[18:54:04] <acrichto> from what I understand it just makes it so codegen is ready, but the analysis/resolve aren't ready
[18:54:13] <eddyb> acrichto: there is no special analysis
[18:54:40] <brson> eddyb: do you have a plan for being able to import methods?
[18:54:54] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[18:55:00] <eddyb> acrichto: the method already has the right type and everything, all it needs is resolve to allow it. might not even require adding code (other than tests)
[18:55:01] <brson> it would be awesome, but istr that there are big complications
[18:55:07] <eddyb> brson: oh, I didn't think of that
[18:55:59] <kimundi> I guess one difference that remains is the existence of the Self type parameter?
[18:56:22] <acrichto> brson: in the never ending saga of a mutex, the new problem of the week is that windows allows for recursive locking and we're relying on undefined behavior in posix
[18:56:48] <eddyb> kimundi: that's in traits and you don't need self to have Self
[18:57:02] <eddyb> Self is the type that the trait is implemented for
[18:57:09] <brson> acrichto: bleh
[18:57:23] <brson> acrichto: why is the recursive locking thing a problem? does it make our semantics different on different platforms?
[18:57:45] <acrichto> brson: it breaks on windows b/c two green threads on the same OS thread will grab the mutex
[18:58:10] <eddyb> rusti: use ::std::ops::Clone::clone;
[18:58:12] -rusti- <anon>:10:13: 10:15 error: expected ident, found `::`
[18:58:12] -rusti- <anon>:10         use ::std::ops::Clone::clone;
[18:58:12] -rusti-                       ^~
[18:58:12] -rusti- application terminated with error code 101
[18:58:18] <eddyb> rusti: use :std::ops::Clone::clone;
[18:58:18] -rusti- <anon>:10:13: 10:14 error: expected ident, found `:`
[18:58:18] -rusti- <anon>:10         use :std::ops::Clone::clone;
[18:58:18] -rusti-                       ^
[18:58:18] -rusti- application terminated with error code 101
[18:58:20] <eddyb> err
[18:58:22] <eddyb> rusti: use std::ops::Clone::clone;
[18:58:27] -rusti- pastebinned 8 lines of output: http://ix.io/a9q
[18:58:30] <eddyb> it's probably the wrong module, too
[18:58:33] <brson> acrichto: oh that's a mess
[18:58:45] <acrichto> brson: yeah I'm about ready to just give up on this...
[18:58:46] <brson> acrichto: what undefined behavior are we using?
[18:58:58] <acrichto> brson: locking a mutex on one thread and then unlocking it on another
[19:01:17] <kimundi> Apart from traits, regular methods on normal types could just be made importable directly with these changes, right?
[19:02:00] *** Joins: tikue (tkuehn@268C2DFE.FAD414BA.D74CC41D.IP)
[19:03:51] <brson> acrichto: in what situations are we unlocking on a different thread?
[19:04:12] *** Joins: lpy (lpy@9248CA04.F930CE91.65042015.IP)
[19:04:37] <brson> it seems bill has ideas about how to solve the windows problem
[19:04:44] <brson> so just one more to solve!
[19:04:47] <acrichto> brson: a green thread can migrate to any other os thread
[19:04:53] <acrichto> we'd have to pin green threads
[19:05:00] <acrichto> at least I think?
[19:05:12] <brson> so it's not the passing of the lock between green threads that's the problem?
[19:05:23] <strcat> if they're holding a lock
[19:05:41] <brson> at least, the passing of the lock within the mutex implementation itself
[19:06:02] *** Quits: lpy (lpy@9248CA04.F930CE91.65042015.IP) (Ping timeout)
[19:06:04] <acrichto> that's also a little bit of the problem, but I think the more pressing problem is that the green thread holding the lock could migrate anywhere
[19:07:44] <brson> are pthread semaphores more expensive than mutexes?
[19:07:54] <brson> and is this legal for semaphores?
[19:08:04] <brson> seems like it would be
[19:08:28] <strcat> brson: pthreads don't have semaphores, I think semaphores are strictly an OS object inter-process thing
[19:08:54] <acrichto> we could easily write a semaphore though
[19:09:00] <brson> posix has semaphores
[19:09:04] <brson> aparently
[19:09:13] <strcat> brson: yes, but they're a multiprocessing thing
[19:09:20] <strcat> mutexes/condvars are either
[19:09:24] <strcat> pshared is optional
[19:09:51] <acrichto> sem_init is a syscall on osx...
[19:10:10] <strcat> yes, there are POSIX semaphores
[19:10:16] <strcat> they're an interprocess OS object
[19:10:19] <strcat> they consume an fd afaik
[19:10:34] <strcat> and I doubt you can have fast locking as you do with mutexes
[19:10:46] <strcat> (ofc, you can write your own mutex/semaphore)
[19:11:01] <brson> acrichto: did any of our proposed solutions not have this problem?
[19:11:11] <acrichto> brson: which ones?
[19:11:33] <brson> any of our proposed mutex not have the unlocking on different threads problem
[19:12:09] <brson> doesn't our scheduler even rely on this undefined behavior?
[19:12:12] <acrichto> my initial design didn't have this problem
[19:12:29] <acrichto> nah the scheduler doesn't have this problem
[19:12:36] <acrichto> it's all bouncing on locks
[19:13:05] <brson> acrichto: what was the problem with your initial design?
[19:14:01] <acrichto> brson: that was was slow b/c I hypothesized that contenders weren't migrated to the same core
[19:14:38] <brson> was it slow for native threads, or green threads or both?
[19:14:49] <acrichto> everyone
[19:17:27] <Eridius> acrichto: pong
[19:17:36] <Eridius> acrichto: I just replied to #11734, if that's what you were pinging me about
[19:20:45] <brson> acrichto: a few ideas. first, we should probably throw in an rtabort when one of our mutexes gets unlocked from the wrong task, since this will itself trigger undefined behavior in the underlying mutex
[19:21:00] <brson> 2) we *could* migrate green threads back somehow
[19:21:27] <brson> 3) we could just say that mutexes don't work with mixed tasks, enforce a stricter seperation between green pools and native tasks
[19:21:51] *** Quits: tikue (tkuehn@268C2DFE.FAD414BA.D74CC41D.IP) (Ping timeout)
[19:23:00] <brson> or maybe we can have different implementations for both, and detect the situation where they are being mixed, and bump everything to the super-slow path
[19:23:49] *** Joins: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP)
[19:24:18] *** Joins: tikue (tkuehn@268C2DFE.FAD414BA.D74CC41D.IP)
[19:25:56] *** Joins: Kxepal (Miranda@moz-A53C85B.pppoe.mtu-net.ru)
[19:34:57] <acrichto> 11:21 <@brson> 2) we *could* migrate green threads back somehow
[19:35:04] <acrichto> whoops
[19:35:45] <acrichto> brson: sounds reasonable, I'm gonna play around with some semaphores first and see if I can't get anything to work
[19:37:06] <acrichto> Eridius: cool, your explanation makes sense
[19:37:08] <acrichto> Eridius: good eyes!
[19:37:23] <Eridius> acrichto: thanks
[19:38:36] *** Quits: blank_name (blank_name@E7821509.94CCB18F.53C6B850.IP) (Quit: leaving)
[19:38:45] <acrichto> Eridius: I'm a little confused on the next comment though
[19:39:05] <mankyKitty> if anyone has time to give this PR the sauron, I'd appreciate some guidance. ^_^ https://github.com/mozilla/rust/pull/11804 (if git is working yet ><)
[19:39:24] <Eridius> acrichto: the one about following symlinks?
[19:39:26] <acrichto> to_test = "/a/b/c", the symlink resolves to "../d/e", so wouldn't that join() call generate to_test = "/a/d/e"
[19:39:38] <Eridius> acrichto: yes, but then when you follow the second symlink of ../f
[19:39:46] <Eridius> you're joining that on the original "/a/b" instead of "/a/d"
[19:40:00] <acrichto> ah indeed!
[19:40:10] <Eridius> hrm, what we just said here resolves to the same path either way ;) but what I said in the comment doesn't!
[19:40:22] * acrichto will make a test
[19:40:27] *** Joins: blank_name (blank_name@E7821509.94CCB18F.53C6B850.IP)
[19:47:44] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Quit: leaving)
[19:47:48] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[19:47:48] *** ChanServ sets mode: +qo brson brson
[19:48:39] <acrichto> brson: looks like using a semaphore is 2x slower in the uncontended case, probably b/c there's 2x more mutex clals
[19:49:11] <strcat> acrichto: as in sem_open or building it on top of a mutex?
[19:49:36] <acrichto> strcat: that was building on top of a mutex, trying semaphore.h now
[19:49:47] * strcat thinks sem_open will be really slow ;p
[19:50:11] <acrichto> 5x slower in the uncontended case
[19:50:26] <strcat> acrichto: does it use fds on OS X?
[19:50:32] <acrichto> dunno
[19:50:44] <strcat> dunno what the equivalent is to /proc/self/fd on OS X
[19:51:03] <strcat> has to be a kernel object though
[19:51:08] <strcat> since you can send them to other processes
[19:51:21] <Eridius> strcat: it's an ioctl call
[19:51:28] <Eridius> I think
[19:51:35] <strcat> Eridius: what does it open() then?
[19:51:46] <Eridius> actually I'm not certain what /proc/self/fd does so I could be wrong ;)
[19:51:59] <Eridius> is it a dir containing all file descriptors?
[19:52:03] <strcat> Eridius: well /proc/self is a symlink to the /proc dir corresponding to the process
[19:52:05] <Eridius> ok
[19:52:07] <strcat> the fd dir has the open fds
[19:52:07] <Eridius> hten I don't know
[19:52:25] <Eridius> there's some way to send fds to other processes but I don't know precisely what it is
[19:52:32] <Eridius> beyond XPC I mean. There's some way that predates XPC
[19:52:34] *** Quits: mankyKitty (Instantbir@moz-21AD3B58.rev.sfr.net) (Quit: mankyKitty)
[19:52:34] <Eridius> probably mach messages
[19:52:52] <strcat> you can send fds over sockets
[19:53:00] <strcat> unix domain sockets
[19:53:01] <Eridius> ah
[19:53:29] <strcat> launchd and systemd are based on having them be inherited via fork()
[19:53:50] <strcat> well, one aspect of them
[19:53:52] <strcat> socket activation
[19:54:31] <Eridius> what exactly are you trying to do here?
[19:54:52] <strcat> I am just mentioning that sem_open is probably going to waste a lot of fds
[19:56:39] <strcat> on linux you can use a pipe as a lock ;p
[19:56:56] <Eridius> ah
[19:57:00] *** Quits: doener (doener@moz-C68F600D.unity-media.net) (Quit: leaving)
[19:57:06] <Eridius> and since the fd limit on OS X is low by default, wasting fds is not a good idea
[19:57:19] <strcat> if you don't mind writing 4096 bytes to lock and reading 4096 bytes to unlock ;]
[19:57:28] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[19:57:33] <strcat> who needs mutexes anyway? ;p
[19:59:48] <Eridius> re /proc/self/fd, if you were just suggesting trying to use that to find out if sem_open uses an fd, you could use fcntl() with F_GETFD starting at 1 and walking upwards to figure out what fds are in use
[20:00:03] <strcat> at
[20:00:05] <strcat> ah*
[20:00:06] <xales> acrichto: updated https://github.com/mozilla/rust/pull/11845 - is that what you were thinking?
[20:00:51] <acrichto> xales: indeed! sorry I forgot to mention this, but could you add a test as well?
[20:01:02] <acrichto> xales: or hm, I'll just coment on the pR
[20:01:37] <xales> acrichto: test that it can quickly rebind, or test for that failing? (I can't think of any way to fail SO_REUSEADDR)
[20:01:53] <acrichto> xales: if you bind twice it should return error on the second one
[20:02:01] *** Quits: canhtak (canhtak@moz-9E539298.wl.t.ulaval.ca) (Quit: canhtak)
[20:02:12] <acrichto> xales: it'd also be nice to have one about binding twice
[20:02:20] <acrichto> binding, accepting, closing, rebinding (should work)
[20:02:36] *** Quits: gwty (gwtypc@38A0A9BD.D56F0A4C.E7DAB6F9.IP) (Ping timeout)
[20:02:54] <xales> ah, okay
[20:03:07] <acrichto> xales: oh you also I think need to do the setsockopt before the bind()
[20:03:19] *** Joins: gwty (gwtypc@38A0A9BD.D56F0A4C.E7DAB6F9.IP)
[20:03:50] <xales> oh yes, that is important
[20:04:50] *** Joins: lpy (lpy@9248CA04.F930CE91.65042015.IP)
[20:06:49] *** Quits: lpy (lpy@9248CA04.F930CE91.65042015.IP) (Ping timeout)
[20:06:49] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[20:06:50] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/fVCYvw
[20:06:50] <ghrust> 13rust/06auto 14e5abe66 15Huon Wilson: std: reduce the generic code instantiated by fail!()....
[20:06:50] <ghrust> 13rust/06auto 14b4bb8c0 15Huon Wilson: std: add begin_unwind_fmt that reduces codesize for formatted fail!()....
[20:06:50] <ghrust> 13rust/06auto 14feacb59 15bors: auto merge of #11841 : huonw/rust/noinline-fail, r=alexcrichton...
[20:06:51] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[20:09:41] <xales> acrichto: should the test be in std or native?
[20:12:54] <acrichto> xales: std, that way you can test libgreen/libnative simultaneously
[20:14:17] *** Joins: pcwalton (pcwalton@moz-C07D5168.p2p.sfo1.mozilla.com)
[20:14:17] *** ChanServ sets mode: +ao pcwalton pcwalton
[20:19:32] *** Quits: gwty (gwtypc@38A0A9BD.D56F0A4C.E7DAB6F9.IP) (Ping timeout)
[20:20:14] *** Joins: gwty (gwtypc@38A0A9BD.D56F0A4C.E7DAB6F9.IP)
[20:20:14] *** Quits: vadimcn (chatzilla@FB06B64.76F9E272.DA40C4B3.IP) (Client exited)
[20:22:54] *** Joins: canhtak (canhtak@moz-9E539298.wl.t.ulaval.ca)
[20:30:21] *** Joins: jdm_ (jdm@moz-C07D5168.p2p.sfo1.mozilla.com)
[20:30:48] *** Quits: jdm (jdm@moz-DFAA4E15.p2p.sfo1.mozilla.com) (Ping timeout)
[20:32:18] *** Joins: jdm (jdm@moz-DFAA4E15.p2p.sfo1.mozilla.com)
[20:32:52] *** Quits: jdm_ (jdm@moz-C07D5168.p2p.sfo1.mozilla.com) (Ping timeout)
[20:34:40] <eddyb> pcwalton: r? https://github.com/mozilla/rust/pull/11723
[20:35:24] <pcwalton> eddyb: r=me
[20:35:49] <eddyb> pcwalton: sweet, thanks :)
[20:36:15] <eddyb> I hope I can step my game up, now that I managed to get (another) huge-ish PR through
[20:40:47] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[20:45:29] *** Quits: gwty (gwtypc@38A0A9BD.D56F0A4C.E7DAB6F9.IP) (Ping timeout)
[20:57:00] <nmatsakis> eddyb: ping
[20:57:08] <eddyb> nmatsakis: pong
[20:57:12] <eddyb> still here, not for long
[20:57:16] <nmatsakis> eddyb: sorry, was incommunicado, are you all set for r?'s now?
[20:57:39] <eddyb> nmatsakis: you mean on that PR that landed a few hours ago?
[20:58:20] <nmatsakis> eddyb: :) I guess so, yes.
[20:58:23] <nmatsakis> eddyb: congrats, exciting.
[20:59:18] <eddyb> thanks. I don't feel bad for not waiting for you because I've had two unrelated test failures - this should've been wrapped up two days ago. well, I guess I had to fix that odd problem with statics
[20:59:39] <eddyb> nmatsakis: the next exciting thing is https://github.com/mozilla/rust/pull/11723
[20:59:54] <nmatsakis> eddyb: yes, I saw that, nice.
[20:59:59] <eddyb> and maybe I'll try to cleanup middle::ty tomorrow
[21:00:23] <nmatsakis> eddyb: what cleanup did you have in mind for ty?
[21:01:25] *** Quits: tikue (tkuehn@268C2DFE.FAD414BA.D74CC41D.IP) (Quit: tikue)
[21:02:08] *** Joins: gwty (gwtypc@782632A0.D155B7DB.F44414AF.IP)
[21:03:22] <eddyb> nmatsakis: no extra ~ in the interner, no ty::get, maybe rename things around to CaMels, compact flags/typecontents (maybe combine them?) - mostly performance nonsense. I hope I can find uglier things so it actually has an effect on memory usage
[21:04:02] <nmatsakis> eddyb: ok. so nothing too conceptual, just refactor / cleanup?
[21:04:34] <eddyb> hence "cleanup" - the only conceptual thing is maybe about TypeContents, which I just thought about now
[21:05:40] <eddyb> nmatsakis: semantics-wise, I have the default type params PR, and the stalled-for-months-no-fun variadics, maybe we should find some time to talk more about them
[21:05:41] *** Joins: lpy (lpy@9248CA04.F930CE91.65042015.IP)
[21:07:21] <nmatsakis> eddyb: yes, we should -- now is not good, as I am in an airport, and I'll be rather busy this week (TC39 meeting), but after that would be good.
[21:07:33] <nmatsakis> eddyb: what were you planning for TypeContents?
[21:07:34] *** Quits: lpy (lpy@9248CA04.F930CE91.65042015.IP) (Ping timeout)
[21:08:41] <eddyb> nmatsakis: well, it's uint or u64 though it uses 10-12 bits, and I remembered it's separate from a type's flags, so it involves extra indirection
[21:10:52] <eddyb> nmatsakis: well, good - not night - day(?), I'm off to sleep
[21:12:57] *** Quits: jdm (jdm@moz-DFAA4E15.p2p.sfo1.mozilla.com) (Ping timeout)
[21:13:33] *** Joins: jdm (jdm@moz-C07D5168.p2p.sfo1.mozilla.com)
[21:13:49] *** Joins: tikue (tkuehn@268C2DFE.FAD414BA.D74CC41D.IP)
[21:16:33] *** Quits: eddyb (eddy@EDE07015.D51DAF03.FB866788.IP) (Ping timeout)
[21:20:41] <Eridius> acrichto: ping
[21:21:34] <acrichto> Eridius: pong
[21:21:45] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[21:21:45] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/fVCYvw
[21:21:45] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[21:22:13] <Eridius> acrichto: either I misspoke or you did not understand what I was saying about .root_path()
[21:22:33] <acrichto> oh whoops, how so?
[21:22:36] <Eridius> acrichto: os::make_absolute(original).root_path() will always return a Some, assuming that getcwd() returns an absolute path. I think getcwd() can be assumed to return an absolute path
[21:22:50] <Eridius> because if it doesn't, not only would it be considered broken, but os::make_absolute() would be broken too
[21:23:01] <acrichto> didn't you say that wasn't true o windows?
[21:23:06] <Eridius> acrichto: I'm getting to that
[21:23:09] <acrichto> cwd == "D:/" and path == "C:foo"
[21:23:25] <Eridius> os::make_absolute() may not return an absolute path under Windows if the given path is volume-relative (and not relative to the volume that getcwd() returns)
[21:23:37] <Eridius> however, .root_path() will handle that. "C:foo".root_path() == "C:"
[21:23:53] <Eridius> (it didn't used to, but I fixed that after talking to erickt sometime in the past couple of weeks)
[21:24:13] <acrichto> how do you detect a volume-relative path?
[21:24:27] <acrichto> sounds like this has to just bail out on volume-relative paths
[21:24:41] <Eridius> acrichto: well, there's a free function in std::path::windows for it, but that is only callable if you know you have a WindowsPath, which is unfortunate
[21:24:49] <Eridius> but volume-relative paths will return false from .is_absolutE()
[21:25:08] <acrichto> wait what
[21:25:10] <Eridius> I also think that calling realpath("C:foo") should just return "C:foo" instead of raising a condition
[21:25:18] <acrichto> make_absolute(&foo).is_absolute() can return false/
[21:25:45] <Eridius> yes, but only on Windows, if foo is a volume-relative path (and the volume it's relative to is not the one that getcwd() returns)
[21:25:49] <Eridius> it's rather unfortunate
[21:26:00] <acrichto> why do we even allow volume relative paths?
[21:26:05] <acrichto> they sound like they break almost everything
[21:26:22] <Eridius> unfortunately there doesn't seem to be a great alternative
[21:26:36] <Eridius> we could introduce a new condition and raise it if you try and construct a volume-relative path, but that's really quite shitty
[21:26:39] <acrichto> can't we get the current directory for that volume?
[21:26:49] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[21:26:49] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/hYe_Yg
[21:26:49] <ghrust> 13rust/06auto 14e81ab41 15Eduard Burtescu: Removed take_glue from tydesc, inlining the equivalent refcount increment code instead.
[21:26:49] <ghrust> 13rust/06auto 14760ddb3 15bors: auto merge of #11723 : eddyb/rust/more-trans-cleanup, r=pcwalton
[21:26:49] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[21:26:49] <acrichto> you said that there's cwd per volume?
[21:26:53] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[21:26:53] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/SFQXNg
[21:26:53] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[21:27:00] <Eridius> we could also just consider C:foo to be a relative path component with the name "C:foo", but I have no clue how the Windows API will handle a path that looks like "D:/foo/bar/C:baz"
[21:27:17] <Eridius> acrichto: there was. cmd.exe replicates that today as well. But the Windows APIs don't technically actually have that
[21:27:30] <Eridius> apparently various pieces of Windows software will either replicate that behavior or will not, depending on the software in question
[21:27:42] <acrichto> this seems kinda ridiculous to support?
[21:27:52] <Eridius> See Chris Morgan's comment https://github.com/mozilla/rust/pull/11579#issuecomment-32759847
[21:28:09] <Eridius> acrichto: I agree, but I dislike the idea of raising a condition on WindowsPath::new("C:foo") even more than the idea of supporting it
[21:28:29] <acrichto> well we're removing conditions anyway
[21:28:33] <acrichto> nothing should raise a condition in path
[21:28:33] <Eridius> but maybe the best solution is to just treat it as a regular path component
[21:28:36] <acrichto> it shold all return Result
[21:28:43] <Eridius> acrichto: not_utf8 is the condition it currently raises
[21:28:46] <Eridius> also null_byte
[21:28:52] <acrichto> yeah but we're removing condiitons
[21:28:56] <acrichto> so all those functions willr eturn Result
[21:29:14] <Eridius> I thought we were replacing them with dynamic variables?
[21:29:30] <Eridius> so one possible state for the dynvar is to fail
[21:29:51] <acrichto> I don't think that'll work out that hot
[21:29:57] <acrichto> regardless this is an orthogonal tangent
[21:30:11] <acrichto> this just sounds like everything with volume relative things are opposite of what you'd expect
[21:30:26] <Eridius> yeah, I've been trying to find the time to look at this some more
[21:30:42] <acrichto> are you ok with an unwrap() for now?
[21:30:45] <acrichto> and just running with it?
[21:30:49] <acrichto> in fs::realpath
[21:30:50] <Eridius> ytinasni also referenced something called "Alternate Data Stream" that "c:foo" could refer to, so I need to find out more about that
[21:31:41] <Eridius> acrichto: yes, .unwrap() is safe on .root_path(), but I have no idea what .fs_lstat() will do with a volume-relative path
[21:31:56] <acrichto> it just returns error on native right now anyway
[21:32:02] <acrichto> need to implement that for windows...
[21:32:09] <Eridius> which is why I'm suggesting `let original = os::make_absolute(original); if !original.is_absolute() { return original; }; let mut result = original.root_path().unwrap();`
[21:32:31] <Eridius> that sidesteps the entire question of how .fs_lstat() behaves with volume-relative paths
[21:32:35] <acrichto> that is just a silent error though
[21:32:40] <acrichto> that's a huge bug
[21:32:46] <Eridius> is it an error at all?
[21:32:48] <acrichto> make_absolute(foo).is_absolute() should *always* be true
[21:32:52] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[21:32:55] *** Quits: dbussink (dbussink@moz-E0A5568C.bussink.me) (Ping timeout)
[21:32:57] <Eridius> it's volume-relative. Without a volume-specific working dir, it doesn't actually refer to a specific file
[21:33:07] <acrichto> it *must* refer to a file
[21:33:12] *** Joins: dbussink (dbussink@moz-E0A5568C.bussink.me)
[21:33:15] <acrichto> like there's some notion of where it points to
[21:33:21] <Eridius> ok sure, `os::make_absolute(foo).is_absolute()` *should* be true. But it can't be true in the face of volume-relative paths. Which is really shitty
[21:33:23] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[21:33:23] <acrichto> if it's a volume relative directory you say there's a volume cwd
[21:33:35] <acrichto> why can't it be true? why can't you get the volume's cwd?
[21:33:44] <Eridius> acrichto: at this point, I'm leaning towards removing volume-relative paths, but *not* making it a condition.
[21:34:01] <Eridius> acrichto: from what I gather, the Windows API no longer has a notion of volume-specific cwds
[21:34:04] <acrichto> I'd be fine with that
[21:34:16] <Eridius> cmd.exe, and apparently anything running in that like `ls`, seems to emulate it somehow
[21:34:41] <acrichto> updated the PR
[21:35:02] <Eridius> acrichto: ok I'm going to file an issue to cover handling volume-relative paths properly. I suggest you use the 3 lines of code I wrote, with a `// FIXME` that references the new issue, so we can remove these shenanigans once that's dealt with
[21:35:08] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[21:35:29] <Eridius> hrm ok, so you've replaced this now with a fail!() if anyone calls realpath() on a volume-relative path
[21:35:40] <acrichto> it's completelyw rong to just return the original path though without raising a condition
[21:35:50] <acrichto> it's *not* realpath'd
[21:35:56] <acrichto> there could very well be any number of symlinks
[21:35:58] <Eridius> acrichto: it doesn't refer to any specific file. It seems no more wrong than to allow a nonexistant path to be returned as-is
[21:36:08] <Eridius> e.g. if /foo doesn't exist, /foo/bar/baz is returned unchanged
[21:36:42] <Eridius> the only alternative I see is to figure out how `ls`, etc. supports volume-relative paths and do the same thing
[21:37:46] <acrichto> update
[21:37:48] <acrichto> updated*
[21:38:26] <Eridius> still no good. root_path() will return "C:" for "C:foo". You need to explicitly test .is_absolute()
[21:40:29] <acrichto> I don't think the condition is actually necessary
[21:40:33] <acrichto> the early return that is
[21:40:38] <acrichto> components() will still work
[21:40:42] <acrichto> it'll just bild the path
[21:40:56] <Eridius> Issue filed as #11856
[21:41:11] <acrichto> as in, the current version I believe is sufficicent
[21:41:24] *** Quits: dbaupp (Thunderbir@moz-68C83524.lns20.syd6.internode.on.net) (Ping timeout)
[21:41:27] <Eridius> yes, it will build the path, my point is that I have no idea what .fs_lstat() will do with a volume-relative path. If you're ok with just trusting that it will Err(), then you can skip the .is_absolute() check
[21:41:52] <acrichto> let's just let fs_lstat figure that out
[21:42:13] <Eridius> acrichto: ok, the current version's .expect() string is technically inaccurate, becauase .root_path() doesn't test for absolute-ness, it just tests if there's a prefix at all
[21:42:19] <Eridius> honestly, I would recommend just using .unwrap()
[21:42:27] <Eridius> os::make_absolute(foo).root_path() will never return None
[21:42:45] <Eridius> the only reason it can is if getcwd() fails, and if that fails I would expect, well, failure
[21:43:04] * Eridius expects it can't fail in any case
[21:45:58] <acrichto> are we really going to quibble about error messages you'll never see? it's an identifiable string which is much more find-able than unwrap()'s error message?
[21:46:35] <acrichto> updated it
[21:47:05] <Eridius> acrichto: thanks. I don't expect anyone to see it, no, I'm just worried about confusing people who read the code later
[21:48:19] *** Quits: pcwalton (pcwalton@moz-C07D5168.p2p.sfo1.mozilla.com) (Quit: pcwalton)
[21:48:29] <Eridius> acrichto: hrm, I don't think the clone()'s are necessary once you've called make_absolutE()
[21:48:46] <Eridius> granted, they only show up in the error case, so it's not terribly significant
[21:49:04] <Eridius> I'll r+ this as-is if you don't want to bother removing the clones
[21:49:21] <acrichto> lemme check
[21:49:46] <acrichto> ah it still think its borrowed
[21:49:50] <acrichto> from the loop iterator
[21:49:55] <Eridius> ahhh ok
[21:50:00] <acrichto> oh well
[21:50:04] <Eridius> silly borrowck
[21:50:14] <acrichto> it'd be nice if it knew that it wasn't
[21:50:17] <acrichto> but that may be too fancy
[21:50:17] * Eridius is just mentally running through the tricky test, then will r+
[21:51:44] <Eridius> acrichto: hrm no, actually the tricky test, while it mirrors my original comment, isn't quite right. We need another directory
[21:51:57] <acrichto> I did run the test and it passed
[21:52:01] <Eridius> I was wrong when I said the original code would resolve to /a/b/f. Because c was a file, it would have still resolevd to /a/f
[21:52:06] <Eridius> well yes, it passes, it's just not testing the right thing
[21:52:13] <Eridius> my bad
[21:52:15] <acrichto> ah hm
[21:52:33] <Eridius> make /a/b/c point at ../d/e/f, make /a/d/e/f point at ../g
[21:52:41] <Eridius> and the resulting path should be /a/d/g
[21:52:48] <Eridius> the original code would have made that /a/g
[21:53:15] <acrichto> ah yes
[21:53:17] * Eridius was confused because he forgot to drop the "c" before evaluating ../f 
[21:53:24] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[21:53:31] <acrichto> man paths are hard
[21:55:14] <acrichto> testing now
[21:56:26] *** Joins: pcwalton (pcwalton@moz-C07D5168.p2p.sfo1.mozilla.com)
[21:56:26] *** ChanServ sets mode: +ao pcwalton pcwalton
[21:56:39] *** Quits: pcwalton (pcwalton@moz-C07D5168.p2p.sfo1.mozilla.com) (Quit: pcwalton)
[21:57:10] *** Joins: pcwalton (pcwalton@moz-C07D5168.p2p.sfo1.mozilla.com)
[21:57:10] *** ChanServ sets mode: +ao pcwalton pcwalton
[22:02:27] *** Quits: NiccosSystem (NiccosSyst@AB1AFDE.FC7B0C35.A7597CB6.IP) (Ping timeout)
[22:05:45] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[22:06:30] *** Joins: lpy (lpy@9248CA04.F930CE91.65042015.IP)
[22:08:12] *** Quits: lpy (lpy@9248CA04.F930CE91.65042015.IP) (Ping timeout)
[22:15:35] *** Quits: canhtak (canhtak@moz-9E539298.wl.t.ulaval.ca) (Quit: canhtak)
[22:16:58] *** Joins: NiccosSystem (NiccosSyst@AB1AFDE.FC7B0C35.A7597CB6.IP)
[22:18:36] <strcat> acrichto: look at the man page for realpath
[22:18:55] <acrichto> strcat: and?
[22:19:01] <strcat> acrichto: http://ix.io/a9D
[22:19:28] <strcat> ah POSIX 2008 changed it
[22:19:31] * strcat shrugs
[22:19:37] <strcat> I have a feeling it'll be problematic ;p
[22:20:00] <acrichto> isn't this a problem with lstat?
[22:20:16] <acrichto> readlink, that's what I mean
[22:21:51] <acrichto> oh hm, lstat gives you how large itis
[22:25:10] *** Quits: rca_ (rcatolino@moz-3F131AFE.adsl.proxad.net) (Ping timeout)
[22:35:33] *** Quits: gwty (gwtypc@782632A0.D155B7DB.F44414AF.IP) (Ping timeout)
[22:37:09] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[22:37:21] *** Joins: gwty (gwtypc@4630FEE7.E9C312B7.25B273F5.IP)
[22:37:37] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[22:38:53] *** Quits: gwty (gwtypc@4630FEE7.E9C312B7.25B273F5.IP) (Connection reset by peer)
[22:39:22] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[22:41:58] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[22:41:59] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/hYe_Yg
[22:41:59] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[22:46:59] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[22:46:59] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/FxD2XQ
[22:46:59] <ghrust> 13rust/06auto 14d39b606 15Michael Woerister: Add .rs- instead of .rc-extension to LLVM module name
[22:46:59] <ghrust> 13rust/06auto 140a03bc0 15Michael Woerister: debuginfo: Fix name attribute for DWARF compile units
[22:46:59] <ghrust> 13rust/06auto 144176343 15bors: auto merge of #11846 : michaelwoerister/rust/cu_name, r=pcwalton...
[22:47:01] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[22:47:18] <xales> writing test for SO_REUSEADDR, this fails with "receive on closed channel" for native, and does something odd for green (looking into why). it should work for native though... https://gist.github.com/xales/f8def05e4672afb9fa05
[22:48:47] *** Joins: gwty (gwtypc@8C613ED4.A388EA24.F44414AF.IP)
[22:49:11] <acrichto> xales: if yous ee that is' receiving on a closed channel then it means the native test failed
[22:50:25] <acrichto> wow that was a butchered message
[22:50:39] <acrichto> xales: baiscally look up a little and you'll see the output failure message of the native task
[22:50:46] *** flaper87 is now known as flaper87|afk
[22:53:49] *** Quits: gwty (gwtypc@8C613ED4.A388EA24.F44414AF.IP) (Client exited)
[22:58:33] *** Quits: pcwalton (pcwalton@moz-C07D5168.p2p.sfo1.mozilla.com) (Quit: pcwalton)
[22:59:51] *** Joins: pcwalton (pcwalton@moz-C07D5168.p2p.sfo1.mozilla.com)
[22:59:51] *** ChanServ sets mode: +ao pcwalton pcwalton
[23:00:26] *** Quits: NiccosSystem (NiccosSyst@AB1AFDE.FC7B0C35.A7597CB6.IP) (Ping timeout)
[23:05:23] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[23:07:14] *** Joins: lpy (lpy@9248CA04.F930CE91.65042015.IP)
[23:09:03] *** Quits: lpy (lpy@9248CA04.F930CE91.65042015.IP) (Ping timeout)
[23:11:22] *** Joins: canhtak (canhtak@moz-9E539298.wl.t.ulaval.ca)
[23:13:01] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: rcirc on GNU Emacs 24.3.50.1)
[23:15:07] *** Quits: canhtak (canhtak@moz-9E539298.wl.t.ulaval.ca) (Connection reset by peer)
[23:18:42] *** Joins: aatch (James@moz-B437F499.pocketrent.com)
[23:31:21] *** Quits: tikue (tkuehn@268C2DFE.FAD414BA.D74CC41D.IP) (Quit: tikue)
[23:39:13] *** Joins: tikue (tkuehn@268C2DFE.FAD414BA.D74CC41D.IP)
[23:39:18] *** Quits: tikue (tkuehn@268C2DFE.FAD414BA.D74CC41D.IP) (Quit: tikue)
[23:39:25] *** Joins: tikue (tkuehn@268C2DFE.FAD414BA.D74CC41D.IP)
[23:41:25] *** Quits: tikue (tkuehn@268C2DFE.FAD414BA.D74CC41D.IP) (Quit: tikue)
[23:44:13] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.2)
[23:56:50] *** Joins: dbaupp (Thunderbir@32742E97.D5A1DCF.37681C44.IP)
[23:59:07] *** kimundi is now known as zz_kimundi
[23:59:13] <dbaupp> acrichto: ping
[23:59:46] *** nrc is now known as nrc|lunch

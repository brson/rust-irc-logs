[00:00:05] <strcat> cmr: https://github.com/mozilla/rust/issues/7336#issuecomment-19895471 this
[00:00:05] <cmr> That might explain it though
[00:00:28] <cmr> Yup, -O does it
[00:00:55] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[00:02:15] <aatch> strcat, basically, stack closures *always* capture their environment by reference, and the inner closure is actually capturing the outer closure's upvar
[00:02:28] <strcat> oh
[00:02:47] <strcat> so it's more that stack closures are unsound
[00:02:51] <aatch> but that upvar is a reference, so the reference is on the stack.
[00:03:44] <aatch> of the outer closure, which gets "obliterated" when outer closure returns
[00:04:36] <aatch> strcat, not really, since if you take a pointer to the captured variable inside the outer closure, then try to use it in the returned inner closure, it fails borrow check.
[00:04:48] <aatch> I'll post on the issue with an example.
[00:05:01] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[00:05:13] <strcat> aatch: so do you know how to fix it?
[00:06:03] <aatch> strcat, not sure, I figured it out this morning in the shower, so I haven't had a chance to look at the offending code.
[00:06:11] <strcat> heh
[00:07:07] <cmr> /in/ the shower?
[00:07:15] <cmr> I mean, I get ideas and figure stuff out in the shower all the time
[00:07:21] <cmr> but actually solving a code bug?
[00:08:09] *** Joins: SiegeLord (siege@moz-CAF07B4C.hsd1.ma.comcast.net)
[00:08:25] <thiez> cmr: it's easy, you just have to learn the rustc source code by heart
[00:08:43] <aatch> thiez, that is scarily close to the truth.
[00:09:00] * aatch does not, however, have rustc memorized
[00:09:21] <cmr> nmatsakis: does your irrefut thing actually make? I'm getting
[00:09:34] <cmr> https://gist.github.com/cmr/3bfb8b9cc262cef221a3
[00:09:56] <cmr> make ran fine, but when I try to build after-the-fact I get those failures
[00:10:57] <cmr> engla: quickcheck looks so insanely useful
[00:11:16] <cmr> I should really learn haskell one of these days, it seems to have lots of wonderful software written in and for it
[00:12:18] <graydon> quickcheck is .. from what I can tell, only _sorta_ useful
[00:12:18] <thiez> cmr: try this http://www.willamette.edu/~fruehr/haskell/evolution.html :p
[00:12:43] <graydon> not to discourage you from investigating fuzzing
[00:13:21] <cmr> afaict it's free smart fuzz testing and unit testing
[00:13:42] <strcat> but often the assertions you need to write to verify it are the same as implementing the function
[00:14:08] <strcat> so you'll make the same mistake in the quickcheck assertions
[00:14:11] <graydon> yes, but I've heard from its users that it's kinda oversold. and the little bit I looked into it showed mostly trivial examples, with difficulty scaling it up.
[00:14:21] <cmr> ah, shame
[00:14:27] <sully> ok, woo
[00:14:29] <graydon> fuzzing is very hard to do automatically. but I would love work in this space. random generation of combinatorial structures is hard but also super interesting.
[00:14:49] <graydon> (also "even" exploration of them, boundary-exploration, exploration under constraints or invariants...)
[00:15:01] <sully> I think I sucesfully have eliminated the cast that happens every time self is mentioned
[00:15:07] <graydon> sully: \o/
[00:15:09] <cmr> sully: awesome!
[00:15:20] <thiez> nice, does it speed up compiling? :)
[00:15:44] *** Joins: dualhbridge (dad@moz-9FEE6D3B.maine.res.rr.com)
[00:15:45] <cmr> It was a double-indirection right?
[00:15:51] *** Parts: dualhbridge (dad@moz-9FEE6D3B.maine.res.rr.com) ()
[00:15:55] <sully> oh, there is still a double indirection
[00:16:02] <cmr> oh :(
[00:16:09] <sully> but now it doesn't also cast every time
[00:16:15] <sully> I am going to look into the double indirection, though
[00:16:22] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[00:16:26] <doener> I'm working on that
[00:16:33] <sully> on the double indirection?
[00:16:36] *** Quits: SiegeLord (siege@moz-CAF07B4C.hsd1.ma.comcast.net) (Connection reset by peer)
[00:16:37] <doener> yes
[00:16:39] <sully> oh, ok
[00:16:55] <sully> I will stop reading the argument translation code, then
[00:17:26] *** Joins: SiegeLord (siege@moz-CAF07B4C.hsd1.ma.comcast.net)
[00:17:26] <thiez> is it true that self gets passed in some magical place rather than on the stack with the other arguments?
[00:17:56] <pcwalton> it's on the stack
[00:18:02] <pcwalton> just in a weird position
[00:18:18] <thiez> is there any reason for that?
[00:18:39] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[00:18:49] <pcwalton> a legacy optimization back when self always meant &self
[00:19:00] <pcwalton> and extern "Rust" fns didn't exist.
[00:19:56] *** Quits: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP) (Quit: buildmaster reconfigured: bot disconnecting)
[00:20:11] <strcat> the return of bors?
[00:20:47] <aatch> strcat, https://github.com/mozilla/rust/issues/7336#issuecomment-19945344
[00:21:28] <cmr> "After inlining, LLVM sees the undefined behaviour and reduces it all down."
[00:21:49] <cmr> Eerily relevant to the conversation we just had..
[00:22:49] <strcat> cmr: yep it sees possible undef behaviour and assumes that it could never, ever happen
[00:22:55] <strcat> + all the assumptions that come with that :)
[00:23:42] *** Joins: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com)
[00:24:04] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Ping timeout)
[00:24:36] <aatch> but the reason it'
[00:24:55] *** Quits: BitPuffin (quassel@moz-49828767.cust.tele2.se) (Ping timeout)
[00:24:57] <aatch> it's not a codegen bug, is because trans is outputting exactly what it's told to.
[00:25:09] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[00:25:10] <strcat> so the bug is that it's allowed at all?
[00:25:35] <aatch> strcat, no, the bug is that it doesn't follow up the capture chain.
[00:25:41] <strcat> ah
[00:25:52] <aatch> It's a disconnect between the borrow checker and move checker
[00:25:55] <strcat> well I'm glad you figured it out
[00:28:29] *** Joins: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP)
[00:29:04] *** Joins: BitPuffin (quassel@moz-49828767.cust.tele2.se)
[00:31:18] <strcat> rusti: 2
[00:31:20] -rusti- 2
[00:31:20] -rusti- peak memory usage: 59612KiB
[00:31:23] *** Quits: eholk (eholk@moz-3EC295FB.uconnect.utah.edu) (Quit: eholk)
[00:31:23] <strcat> heh
[00:31:25] <strcat> still uses a ton
[00:31:53] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[00:31:58] <strcat> rusti: use std::iterator::Counter; Counter::new(5, 9).skip(5).take_while(|x| *x < 1000).fold(0, |a, b| a + b)
[00:31:59] -rusti- 55385
[00:31:59] -rusti- peak memory usage: 60468KiB
[00:32:29] <thiez> rusti: ()
[00:32:31] -rusti- ()
[00:32:31] -rusti- peak memory usage: 59748KiB
[00:32:32] <strcat> rusti: let mut map = std::hashmap::HashMap::new(); map.insert(2, 4); map.len()
[00:32:33] -rusti- 1
[00:32:34] -rusti- peak memory usage: 65356KiB
[00:32:44] <strcat> silly rustc
[00:32:59] <cmr> you should have rusti modifiers
[00:33:00] <cmr> so like
[00:33:04] <thiez> rusti: struct S{ s:Option<S> }
[00:33:05] <cmr> rusti+mem: foo
[00:33:06] -rusti- ()
[00:33:06] -rusti- peak memory usage: 59736KiB
[00:33:37] <thiez> amazing, it can fit infinite size types in only 60MB.
[00:33:37] <strcat> rusti: struct S { s: Option<S> } std::sys::size_of::<S>()
[00:33:38] -rusti- Killed
[00:33:38] -rusti- application terminated with error code 137
[00:33:38] -rusti- peak memory usage: 131072KiB
[00:33:47] <strcat> thiez: well it doesn't do anything ;p
[00:34:02] <strcat> it's capped at 128M
[00:34:33] <strcat> rusti: struct S { s: Option<S> } let x: S = None;
[00:34:34] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/NaKI
[00:34:55] <strcat> rusti: struct S { s: Option<S> } let x = S { s: None };
[00:34:56] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/iZHI
[00:35:06] <strcat> compiler dies
[00:35:11] <strcat> rather than ever spitting out a binary
[00:35:39] <strcat> graydon: is bors supposed to be on again?
[00:35:45] <graydon> I'm just finishing up
[00:35:48] <thiez> rusti: let x = [0,..104857600];
[00:35:49] -rusti- <anon>:9:13: 9:14 warning: unused variable: `x` [-W unused-variable (default)]
[00:35:49] -rusti- <anon>:9          let x = [0,..104857600];
[00:35:49] -rusti-                       ^
[00:35:49] -rusti- application terminated abnormally with signal 11 (Segmentation fault)
[00:35:49] -rusti- peak memory usage: 59712KiB
[00:35:50] <graydon> then turning it on again
[00:36:06] <strcat> graydon: http://buildbot.rust-lang.org/console?branch=auto&refresh=15 can we just merge the current one?
[00:36:33] <cmr> fwiw that one has bounced I thinke 4-5 times, it should be solid now :p
[00:36:35] <strcat> just missing mac-nopt
[00:36:46] <graydon> opt and nopt. they're both actually running.
[00:36:53] <strcat> oh
[00:37:05] <thiez> rusti: let x = [0u8,..10485760]; x[100] // This one is fun
[00:37:05] <graydon> http://buildbot.rust-lang.org/tgrid?branch=auto&refresh=15
[00:37:06] -rusti- application terminated abnormally with signal 11 (Segmentation fault)
[00:37:06] -rusti- peak memory usage: 59696KiB
[00:37:12] <aatch> strcat, heh, it already follows the upvar chain for path and self expressions.
[00:37:15] *** Joins: dbaupp (Thunderbir@moz-73E90475.lns20.syd6.internode.on.net)
[00:37:29] <strcat> graydon: ah so the interface is just being weird
[00:37:33] <graydon> yeah, somewhat
[00:37:35] <bblum> any git experts around
[00:37:46] <strcat> bblum: together we all add up to 1 git expert
[00:37:47] <cmr> bblum: what do you need?
[00:37:49] <graydon> bblum: *tentative hand up*
[00:38:13] <aatch> strcat, I think altogether we make up a bit more than 1.
[00:38:13] <bblum> so i have a local branch with some commits, and a pull request open for that branch (7363)
[00:38:17] <aatch> Maybe 1.3
[00:38:20] *** Quits: bnicholson (bnicholson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[00:38:27] <bblum> but all the commits are out of order in the PR 
[00:38:33] <bblum> why?
[00:38:38] <jack> bblum: that's just a github bug i believe.
[00:38:38] <cmr> github problem
[00:38:39] <strcat> bblum: the github PR UI is buggy
[00:38:41] <cmr> it's just a UI thing
[00:38:42] <strcat> it orders by date, not parent
[00:38:45] <thiez> github orders by date, not by parent
[00:38:53] <thiez> eh, what strcat said
[00:38:55] <bblum> yeah, i have been rebasing like mad, and i was figuring it was changing the timestamp
[00:39:05] <graydon> strcat: today I've installed a "kill off the other builds if any one fails" status reporter (which is AS OF YET untested, scary scary) and figured out why the per-slave limits weren't working (python string vs. int comparison whee) and set those limits on the conservative side so it should never page and always go to real hardware first and also boosted the instance types on AWS if and when those overflow
[00:39:13] <aatch> bblum, aha, no rebase does not update the timestamp
[00:39:16] <strcat> bblum: it's totally fine to do that, it's just github's PR UI being dumb
[00:39:19] <graydon> strcat: that _should_ get us back into a less-awful ballpark
[00:39:25] <strcat> the normal commit UI orders them by parent
[00:39:37] <bblum> sigh
[00:39:38] <cmr> it's a recent breakage too
[00:39:39] <doener> bblum: there are two timestamps, commit time and "author time". Rebase only changes the former, not the latter
[00:39:41] <cmr> did anyone report it? :p
[00:39:51] <strcat> cmr: no
[00:39:56] <strcat> cmr: I'm lazy ;p
[00:40:14] <strcat> it doesn't personally bother me so I don't do anything about it :)
[00:40:20] <graydon> yeah, there, the limits are now working properly by the look of it
[00:40:47] <strcat> graydon: oh right because python2 allows weird global comparisons
[00:40:53] <strcat> at least they fixed that
[00:40:54] <aatch> graydon, oh, did you get linux-snap-stage3 back on?
[00:41:00] <graydon> aatch: yes
[00:41:00] <strcat> TypeError: unorderable types: int() < str()
[00:41:05] <aatch> graydon, sweet
[00:41:06] <graydon> it should be running too
[00:41:10] <strcat> python2 happily compares *anything*
[00:41:24] <tikue> where does struct.downcast() live?
[00:41:27] <engla> in py2 it compares lexically by type name :-)
[00:41:42] <strcat> graydon: engla: http://ix.io/6lU then what's that ;p
[00:42:00] <strcat> python2 just does something I can't comprehend
[00:42:05] <engla> hm
[00:42:08] <strcat> I guess it's comparing addresses via id? something weird.
[00:42:29] <aatch> graydon, so it is. Awesome.
[00:42:38] <engla> it's not a newstyle class strcat
[00:42:42] <engla> that could be a problem
[00:43:00] <strcat> well, I only actually use py3 myself so... I don't have to worry about that mess ;p
[00:43:09] <engla> class A(object): pass 
[00:43:13] <engla> and you have order again
[00:43:15] <brendanc> http://stackoverflow.com/questions/3270680/how-does-python-compare-string-and-int
[00:43:15] <graydon> hm. though it appears to be limiting mac4 to only 1 build, not 2
[00:43:16] <graydon> hm hm
[00:43:17] * graydon checks
[00:43:28] <cmr> I use py2 at work, and it makes me miss py3 a lot
[00:43:30] <cmr> especially the unicode work
[00:43:30] <strcat> 1 == 2 for large values of 1
[00:43:40] <cmr> (web scraping, so... encoding is pretty much shotgun)
[00:43:40] <strcat> graydon: did you see our bool bug from earlier? ;p
[00:43:45] <graydon> bool bug?
[00:43:47] <strcat> we have 'large values of true-ish'
[00:43:59] <strcat> rusti: let x = 5u8 as bool; x
[00:43:59] -rusti- true
[00:43:59] -rusti- peak memory usage: 59732KiB
[00:44:02] <strcat> rusti: let x = 5u8 as bool; x == true
[00:44:03] -rusti- false
[00:44:03] -rusti- peak memory usage: 59580KiB
[00:44:05] <cmr> sully phrased it non-canonical bools, which I liked :P
[00:44:06] <strcat> rusti: let x = 5u8 as bool; x as u8
[00:44:07] -rusti- 5
[00:44:07] -rusti- peak memory usage: 59724KiB
[00:44:25] * strcat forgot to turn off the mem usage thing
[00:44:32] <graydon> oh dear
[00:44:35] <engla> that's a lot of memory
[00:44:57] <cmr> r? https://github.com/mozilla/rust/pull/7365
[00:45:02] <dbaupp> rusti: let x = 5u8 as bool; x ^ true
[00:45:03] -rusti- true
[00:45:32] <aatch> Should be easy to fix, just make the cast set the value.
[00:45:32] <cmr> strcat: Oh, btw, does https://github.com/cmr/rust/commit/d5ed72ccc970aa00adb14961a95f36e69786e5c5 address all of your earlier concerns about the interner?
[00:45:43] *** Parts: ecr (ereed@2557E599.66715431.D25A875A.IP) ()
[00:46:28] <dbaupp> cmr: did you do any benchmarks of the interner?
[00:46:32] <cmr> dbaupp: not yet.
[00:46:37] <strcat> cmr: can you avoid that copy in intern? hm
[00:46:43] <cmr> strcat: Not that I could figure out.
[00:46:49] <graydon> ok good
[00:46:51] <graydon> the limits work right now
[00:46:52] <graydon> phew
[00:46:55] <cmr> strcat: I was able to cut out 1 of the 2 copys
[00:47:13] <graydon> the machines _should_ avoid paging from here on in
[00:47:16] *** Joins: jensnock_ (jensnocker@moz-8BE55278.customer.t3.se)
[00:47:22] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Connection reset by peer)
[00:47:27] <graydon> things might queue up
[00:47:29] <graydon> but they won't page
[00:47:46] <cmr> dbaupp: I'll add benches of it eventually, but right now I just want to get libsyntax in okish shape
[00:47:58] <cmr> dbaupp: it's really awful... it uses @ *everywhere*
[00:48:04] <cmr> their interner was for @str
[00:48:09] <cmr> and it stored... a @str
[00:48:09] * dbaupp knows
[00:48:16] <aatch> cmr, it used to be worse
[00:48:19] <cmr> aatch: I don't doubt it!
[00:48:25] * dbaupp converted the interner from @~str to @str
[00:48:26] <aatch> used to be @~str
[00:48:28] <cmr> there was @~nonsense, right?
[00:48:30] <strcat> graydon: the ec2 bots can be really annoying
[00:48:30] <cmr> yeah
[00:48:39] <strcat> graydon: is there any way to make it put the slowest builds on the fastest bots only?
[00:48:43] <strcat> and the fastest builds onto the slowest bots
[00:48:53] <graydon> strcat: it's putting all builds on the hardware bots first, because they're fastest
[00:49:06] <strcat> graydon: yeah but it's a waste when it fills them with the 15 min builds
[00:49:09] <strcat> instead of the hour ones
[00:49:25] <strcat> I think that's why it varies so much
[00:49:42] <graydon> I know. this is the best strategy I could get working today
[00:49:49] <strcat> that's fine ;p, it's not unbearable
[00:49:53] <strcat> just an idea for the future
[00:49:56] <graydon> and I believe at this point there's enough hardware to cover all the builds on hardware
[00:49:56] *** Quits: jensnock_ (jensnocker@moz-8BE55278.customer.t3.se) (Ping timeout)
[00:50:04] <strcat> ah
[00:50:16] <graydon> it was hitting EC2 because I set it to randomize, and I did _that_ because I couldn't stop it from rate-limiting on the macs
[00:50:23] <strcat> cmr: http://www.boost.org/doc/libs/1_53_0/libs/bimap/doc/html/boost_bimap/rationale.html we need one of these
[00:50:23] <graydon> the macs are the bottleneck in any case, there's no EC2 at all for them
[00:50:26] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[00:50:29] <thiez> graydon: earlier we were talking about having a bot that just checked every PR and just runs tidy (even for PRs without r+)
[00:50:57] <graydon> so now that rate limiting on the macs is back in business, assigning everything to hardware ought to work as well as anything. I hope.
[00:50:57] <cmr> "This section assumes that you have read all other sections, the most of important of which being tutorial, std::set theory and the reference, and that you have tested the library. A lot of effort was invested in making the interface as intuitive and clean as possible. "
[00:51:02] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[00:51:03] <graydon> thiez: how so?
[00:51:08] <thiez> now of course none of us has ever in their life submitted a PR without running 'make check' first
[00:51:10] <bblum> ughhhh, so annoying that whenever you change test cases in libextra or whatever you have to build rustc again in order to test them
[00:51:29] <strcat> cmr: ;p
[00:51:35] <cmr> strcat: I barely even know C++ that well!
[00:51:36] <thiez> but I know someone who knows someone who told me their build ran for quite a while before getting rejected on tidy in the end :p
[00:51:44] <cmr> strcat: I'll take a look at it tomorrow
[00:52:08] <cmr> strcat: looks like it just maintains a bijection though?
[00:52:10] <graydon> thiez: I don't want to get into the business of building non-reviewed code automatically. not on the same machines as the production stuff. too much of an attack vector.
[00:52:11] <strcat> I haven't looked in detail at how they do that multiindex stuff
[00:52:11] <aatch> bblum, make check-stage2 NO_REBUILD=1
[00:52:13] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Ping timeout)
[00:52:14] <strcat> cmr: don't know
[00:52:23] <bblum> aatch: oh thank you
[00:52:30] <bblum> i vacate my previous complaint
[00:52:30] <graydon> thiez: maybe one of strcat's absurdly locked-down isolation chambers
[00:52:31] <cmr> Alright, I'll take a deeper look at it tomorrow, thanks for the link
[00:52:50] <bstrie> graydon: have you thought about doing test suite optimization where you track which test cases fail the most often, and run those ones first? could save a lot of time in the best-case failure case (the best-case worst-case?)
[00:53:13] <cmr> Heh
[00:53:15] <graydon> bstrie: if we got to the point where that seemed like the limiting factor, I'd be happy to work on it
[00:53:16] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[00:53:20] <thiez> does tidy have to actually execute any code tho?
[00:53:40] <graydon> there's _so much_ more lower-hanging fruit that I wouldn't want to go there just yet. not right use of time.
[00:53:46] <cmr> bstrie: Honestly I don't think we need that much smarts... especially to compensate for the crappy performance
[00:53:50] <graydon> thiez: ah, fair. I guess we could just examine the PR statically.
[00:53:55] <bstrie> graydon: basically we would just have to track which test cases fail whenever a build fails. are you collecting that data today, in a place that's not transient?
[00:54:17] <SiegeLord> A PR could inject code execution into make check :P
[00:54:17] <graydon> thiez: issuing "make tidy" is risky though. someone files a PR that replaces the makefile or tidy.py script with an attack, and we're in trouble.
[00:54:19] <strcat> bstrie: I think we can just make rustc run 100x faster on small examples
[00:54:24] <strcat> not an exaggeration
[00:54:27] <bstrie> yes, that wuold be nice too :)
[00:54:27] <graydon> strcat: yeah
[00:54:33] <graydon> I feel that is a more promising strategy :)
[00:54:46] <graydon> I was mentioning earlier today
[00:54:50] <bstrie> but optimizing the test suite in the way I'm suggesting doesn't preclude any other optimizations
[00:54:58] <graydon> I think I figured out a "good" way to do perf measurements / regression prevention
[00:55:06] <bstrie> and I presume that the test suite will continue to grow withuot bound. that's the point of a test suite!
[00:55:21] <Eridius> graydon: when the newly-compiled compiler is used to compile the compiler, I don't think you have to worry about attacks coming through a makefile sript
[00:55:24] <Eridius> *script
[00:55:40] <sully> ... getting a stack overflow when I turn on debug spew to debug this problem...
[00:55:51] <aatch> sully, yeah, that's a problem...
[00:55:56] <graydon> Eridius: thiez was suggesting we "just" run the python script tidy, not the compiler itself
[00:55:58] <strcat> sully: RUST_MIN_STACK=5000000 as a hack?
[00:56:10] <aatch> try narrowing down the logging spec
[00:56:12] <Eridius> graydon: oh I'm missing context here
[00:56:29] <thiez> cmr: could you get rid of that copy by making the HashMap store &T instead of T?
[00:56:45] <strcat> it won't be happy unless all the &T come from the same immutable source
[00:56:57] <graydon> strcat: the strategy I was thinking was pairwise tests. were you here when I mentioned this? a test runner that compiles two rust programs, or one rust program and a C++ program (supports both modes) and measures the size of the output in LLVM instructions and x86 instructions, and reports the ratio.
[00:56:58] <cmr> thiez: but then the string needs to live as long/longer than the interner
[00:57:02] <sully> logging spec is pretty narrow?
[00:57:03] <cmr> thiez: which makes no sense
[00:57:16] <strcat> graydon: don't think I was here
[00:57:20] <sully> well, can you narrow it to a single function?
[00:57:21] <Eridius> incidentally, if anyone here hasn't read Reflections on Trusting Trust by Ken Thompson, I recommend doing so: http://cm.bell-labs.com/who/ken/trust.html
[00:57:22] <graydon> strcat: it's a non-timing-sensitive number and also gives you a very clear thing-to-examine when there's a regression. you can see the problem.
[00:57:28] <strcat> graydon: I think we really, really need IR tests like clang has
[00:57:31] <graydon> Eridius: yes, we've seen it
[00:57:35] <strcat> really simple program + IR to compare against
[00:57:40] <strcat> so it can't regress
[00:57:43] <Eridius> graydon: I sure hope the snapshots are securely stored and securely transmitted
[00:57:44] <strcat> and all changes to the IR are intentional
[00:57:51] <cmr> thiez: feel free to experiment! :D
[00:57:56] <cmr> thiez: I need to go to bed though
[00:58:10] <thiez> cmr: you find the str in the hashmap, if it isn't there you insert it the vect, then you store the &str from the vec in the hashmap :)
[00:58:22] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Quit: Leaving.)
[00:58:28] <cmr> thiez: that... is genius
[00:58:28] <graydon> strcat: yes, but I think an easy way to get started getting the IR under control is comparing "should be the same" programs between rust's high level and low level constructs, and/or rust and C++-on-clang
[00:58:42] <graydon> Eridius: define "secure"
[00:58:44] <graydon> this is the interner
[00:58:44] <cmr> thiez: (I missed a medication yesterday, I've been pretty loopy today!)
[00:58:45] <graydon> t
[00:59:13] <dbaupp> thiez: it's tricky to have borrowed pointers from a struct into itself
[00:59:13] <sully> ok, it doesn't look like you can narrow it to a single function
[00:59:22] *** Joins: bnicholson (bnicholson@moz-E98974C1.hsd1.ca.comcast.net)
[00:59:24] <SiegeLord> strcat, How do you feel about Iterator::size_hints returning enum SizeHint{Finite(uint), Infinite, Unknown}
[00:59:35] <Eridius> graydon: secure storage, or secure transmission?
[00:59:39] <thiez> oh, it won't work, ignore my plan
[00:59:47] <Eridius> at the very least I hope it's served over SSL (ideally with a pinned cert, but maybe that's overkill)
[00:59:49] <aatch> SiegeLord, what use would Unknown be?
[00:59:52] <thiez> cmr: when vect resizes it moves the values
[01:00:04] <thiez> I'm not as smart as I'd hoped
[01:00:05] <cmr> thiez: ah bugger
[01:00:14] <SiegeLord> aatch, E.g. the lower bound of filter
[01:00:15] <aatch> Or more accurate, how can it make a better decision with infinite vs unknown?
[01:00:16] <Eridius> or alternatively, serve it however you want, but serve checksums up from a server over SSL (not that SSL is really that expensive anymore)
[01:00:34] <strcat> SiegeLord: I don't know if Infinite is useful
[01:00:50] <strcat> I thought about it
[01:00:58] <strcat> I couldn't think of a useful think you could do
[01:01:01] <strcat> thing*
[01:01:05] <SiegeLord> Ok
[01:01:19] <aatch> Since it's all to do with how many resources you pre-allocate
[01:01:41] <strcat> (Option<uint>, Option<uint>) with lower/upper bounds tells you a lot
[01:01:44] <aatch> infinite is useless because it isn't sensible to pre-allocate infinite memory.
[01:02:05] <aatch> (or an infinite file)
[01:02:13] <strcat> most stuff probably wants lower, but upper tells you *don't allocate more than X*
[01:02:39] <bjz> nmatsakis: ping
[01:02:54] <sully> hm.
[01:02:54] <strcat> filter can give you an upper bound but not a lower one, if you want to eagerly allocate
[01:02:56] <strcat> etc.
[01:02:57] <graydon> Eridius: they are not in an airgapped chamber with a hardware security module or such. they are on s3. we have a small number of people who have access to them. we have backups on most user's machines. they are identified by sha1 which is checked-in to our git repo, which everyone has backups of running back to beginning of time
[01:03:08] <cmr> thiez: maybe there's a data structure which allows it?
[01:03:10] <thiez> infinite might make sense, any iterator from a function might be infinite
[01:03:22] <aatch> thiez, yes, but how does it help?
[01:03:37] <aatch> How does infinite differ from unknown?
[01:03:42] <sully> an infinite type seems to be being created here.
[01:03:43] <graydon> Eridius: so an attacker would need to corrupt all the copies of everyone's git repo that has all the sha1 codes of all the snapshots they tampered with. this is implausible.
[01:03:53] <cmr> thiez: But I don't think it's really important for this first cut. The title says it all, "SimpleInterner" :)
[01:03:57] <Eridius> graydon: everyone's? No, just the target they're trying to attack
[01:03:58] <thiez> aatch: in case of infinite I wouldn't want to do the to_vec operation
[01:04:13] <thiez> cmr: fair point, we'll look at it later if it turns out to be slow
[01:04:21] <strcat> graydon: or they can be super clever and corrupt one snapshot and make it embed the same evil code into what it produces, if it's compiling rustc ;p
[01:04:33] <strcat> http://cm.bell-labs.com/who/ken/trust.html
[01:04:33] <cmr> thiez: Plus now that interners are a trait... super easy to swap out.
[01:04:45] <strcat> but there are probably scarier things to worry about
[01:04:53] <strcat> what if github gets hacked? etc.
[01:05:04] <aatch> Or deletes it's database.
[01:05:06] <aatch> again
[01:05:14] <graydon> Eridius: what's plausible is an attacker getting corruption into the snapshot lineage early enough that it would be really annoying to unwind development back past there
[01:05:16] <dbaupp> strcat: or someone edits an comment to be an r+
[01:05:16] <thiez> cmr: that's nice, I might experiment with some more creative solutions
[01:05:17] *** Quits: bent (chatzilla@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: ChatZilla 0.9.90-rdmsoft [XULRunner 18.0.2/20130201065344])
[01:05:18] <SiegeLord> Rust meetups should be key signing parties ;)
[01:05:22] <strcat> dbaupp: oh right that
[01:05:25] *** Quits: seth (seth@2557E599.66715431.D25A875A.IP) (Input/output error)
[01:05:31] <cmr> thiez: please do! :)
[01:05:41] <cmr> thiez: zero-copy would be *really* nie
[01:05:43] <cmr> *nice
[01:05:45] <graydon> dbaupp: the r+ is checked against the list of contributors we're listening to. not just anyone can r+ a change.
[01:06:12] <strcat> graydon: you can edit comments on your repo though
[01:06:15] <aatch> graydon, but anyone can edit a comment on their own commit.
[01:06:17] <cmr> What I don't understand is why hashmap moves the value
[01:06:21] <cmr> all it needs is a hash...
[01:06:23] <Eridius> aatch: wow, really?
[01:06:23] <dbaupp> graydon: someone can edit a comment on a commit in a PR (because it's in their repo) to be an r+ that looks like it's from a reviewer
[01:06:28] <graydon> Eridius: if you're talking about attacking _one_ target, an attacker has .. potentially zillions of attack channels. you started by asking about attacking the snapshots as a whole.
[01:06:31] <cmr> Unless it's for collisions?
[01:06:32] <strcat> graydon: we make r+ comments on the commit and people can edit comments on their own commits
[01:06:45] <strcat> so lets say someone made an evil commit, and I commented on it "this is evil!"
[01:06:49] <strcat> they could edit it to r+ p=500
[01:06:56] <graydon> oh?
[01:07:03] <Eridius> graydon: well if you can corrupt the snapshot as it's in-flight over the intertubes, you can potentially compromise a large set of people
[01:07:19] <Eridius> strcat: what's the p= part?
[01:07:20] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[01:07:24] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[01:07:25] <cmr> Eridius: priority
[01:07:25] <graydon> Eridius: those are checked post-download against the git repo the user has in their workspace
[01:07:37] <cmr> Eridius: bors sorts by (priority, age)
[01:07:38] <Eridius> graydon: what happens if the user isn't using a git repo?
[01:07:38] <strcat> graydon: https://github.com/thestinger/rust/commit/da1a9a30fd647dee99713b3ae3b65f006641c14e comment on this (just anything)
[01:07:50] <aatch> Eridius, then they aren't downloading a snapshot
[01:07:51] <graydon> Eridius: then it's checked against the snapshots file in the tarball
[01:08:36] <graydon> strcat: done
[01:08:37] *** Quits: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net) (Quit: carllerche)
[01:09:11] <strcat> graydon: oh, it doesn't seem to allow it anymore :)
[01:09:19] <strcat> I'm not sure what the rules are
[01:09:26] <graydon> strcat: I would assume you can't edit my words!
[01:09:33] <graydon> that'd be quite awkward
[01:09:34] <strcat> graydon: well I can, depending on the place
[01:09:36] <Eridius> strcat: I just checked my repo, I have the ability to edit your "@bors: retry" (although I didn't)
[01:09:38] <aatch> graydon, but you can sometimes.
[01:09:48] <graydon> huh. that's .. bad.
[01:09:58] <aatch> graydon, yep.
[01:10:07] <strcat> graydon: repo owners can definitely edit any issue title/text or comment text
[01:10:14] <graydon> that's an issue
[01:10:14] <strcat> not entirely sure why I can't edit your comment here.
[01:10:23] <Eridius> strcat: are you logged in?
[01:10:29] <strcat> yes
[01:10:31] <graydon> Eridius: where were you able to just edit a comment?
[01:10:46] <dbaupp> graydon: a solution would be a comment on the PR with the relevant hash `r+ 12ab34cd`
[01:10:53] <aatch> We figured probably the "easiest" solution is to have bors look at the PR comments instead, and have it use the hash
[01:11:06] <graydon> dbaupp: yes, I know. I just don't want to have to spend this evening implementing that. but I can if necessary.
[01:11:13] <Eridius> graydon: I have an edit button on strcat's comment on https://github.com/kballard/rust/commit/c1b1091a4a63971875e760bbfe76f90fec23d208, and I can click it and get a text field. I didn't try modifying it though
[01:11:18] <cmr> http://rustlog.octayn.net/post/53802684618/status-update, good night folks
[01:11:22] <strcat> Eridius: it might not allow it
[01:11:34] <strcat> it greys out 'update comment' now for me, in this place
[01:11:38] <strcat> elsewhere it allows it
[01:11:56] <dbaupp> graydon: fwiw, I can edit this one https://github.com/huonw/rust/commit/544284fb50aa043405bc8a7fbeed68928acfb10e
[01:12:06] <Eridius> strcat: care to throw a junk comment there I can edit, so I don't modify your comments that actually have meaning to bors?
[01:12:08] <bblum> does anybody but me have a handful of random run-pass failures every time they try make check-*-rpass
[01:12:13] <bblum> i run them by hand and they seem fine
[01:12:16] <bblum> valgrind seems fine
[01:12:25] <graydon> dbaupp: change pcwalton's comment there to say something beyond just r+ if you don't mind?
[01:12:29] <graydon> I am just curious to see this
[01:12:50] <dbaupp> graydon: done
[01:12:53] <graydon> oh dear
[01:12:55] <aatch> graydon, it's not high priority, just something to be aware of.
[01:12:57] *** Quits: eschweic (Adium@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[01:13:07] <graydon> for now, yes, it is "something to be aware of" for reviewers
[01:13:15] <graydon> but it should really get fixed
[01:13:19] <graydon> I will post to the mailing list
[01:13:21] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[01:13:28] <strcat> graydon: they need to expose an edit history, I really hate it :(
[01:13:45] <strcat> although, I have no idea why for once it doesn't allow me to edit a comment (the one on my commit)
[01:13:47] <aatch> fwiw, I don't think I've seen a reviewer comment on a commit without it being an r+.
[01:13:58] <dbaupp> aatch: I've seen it occasionally
[01:13:58] <aatch> normally the comments are on lines
[01:14:32] <strcat> graydon: anyway it's a terrible stupid thing github allows - silently editing comments/issues on your repos...
[01:14:43] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[01:15:02] * strcat has seen it abused
[01:15:10] <Eridius> strcat: I just modified your comment
[01:15:16] <Eridius> no indication whatsoever in the UI that I did anything to it
[01:15:21] <strcat> yep
[01:15:39] <pcwalton> maybe we need to start PGP signing our r+ comments
[01:15:50] <aatch> Eridius, you don't have commit access to the repo, right?
[01:15:58] <strcat> aatch: but his commit is on his repo
[01:16:07] <strcat> and a comment on his comment counts as being on his repo
[01:16:20] <aatch> strcat, yeah, just trying to infer the rules
[01:16:37] <strcat> aatch: I don't know why it has the update comment grayed out for graydon's comment on mine :|
[01:16:49] <aatch> maybe graydon has magic powers?
[01:17:11] <strcat> maybe if you pay github for private repos people can't edit your comments? ;p
[01:17:15] <graydon> maybe it's related to "being in a PR"
[01:18:26] <sully> ok, argh. somehow we are creating an infinite llvm type that causes type_to_str to infinitely recurse, preventing me from getting debug spew
[01:18:53] <sully> does anybody have any ideas where this could be coming from?
[01:19:22] <thiez> sully: is this is new or in existing code?
[01:19:55] *** Joins: Jesin (Jessin_@moz-157A63DD.cc.lehigh.edu)
[01:20:05] <thiez> perhaps you could temporarily change type_to_str to give some debug output before recursing?
[01:20:15] <strcat> graydon: oh
[01:20:23] <strcat> graydon: I just had to go to that page from a different link
[01:20:28] <graydon> :(
[01:20:35] <graydon> yeah, guessed
[01:20:44] <graydon> phone call, bbl
[01:20:48] <strcat> graydon: https://github.com/thestinger/rust/commit/da1a9a30fd647dee99713b3ae3b65f006641c14e
[01:22:10] <thiez> oh, this is silly, we can now change any review comment to an r+?
[01:22:27] <strcat> thiez: always could, github is silly
[01:22:46] <sully> existing, this is happening in my repo that contains a bunch of default method changes, and I haven't checked it more generally yet
[01:22:50] <sully> but I suspect it is a general problem
[01:23:00] <sully> gah, lag
[01:23:28] <sully> I have reproduced it in my two workspaces, although I have not on a clean checkout
[01:23:51] <doener> I've seen that, too
[01:23:55] <doener> thought it was my fault
[01:24:07] <thiez> and if I have a commit that gets a comment (any comment, really), and then create an evil commit and rebase my old commit on top of it, would that work?
[01:24:15] <sully> it looks like trying to build libstd with RUST_LOG=rustc=1,rustc::middle::trans::callee
[01:24:17] <dbaupp> sully: I think i saw something like that several months ago (using RUST_LOG=rustc=debug, and having rustc eat all my memory)
[01:24:29] <dbaupp> sully: (not sure of the exact RUST_LOG I had.)
[01:24:30] <Eridius> thiez: no, the rebase would change your commit and discard the comments
[01:24:35] <thiez> ah, that's good.
[01:24:54] <Eridius> well not discard... the comments are actually still on the original version of your commit, which you can still access by URL-editing
[01:25:30] <thiez> github sounds rather leaky.
[01:26:30] <dbaupp> Eridius: that's just a property of how git works
[01:26:49] <Eridius> dbaupp: yeah I know
[01:26:54] <dbaupp> cool :)
[01:26:59] <Eridius> although I do wonder how long github holds onto commented unreachable commits
[01:27:11] <Eridius> (and if it's any different than for uncommented unreachable commitS)
[01:27:54] *** Quits: EXetoC (ex@moz-2DBEB1E4.customer.t3.se) (Quit: WeeChat 0.4.1)
[01:28:21] <dbaupp> I'd guess there's no difference, but I don't know
[01:28:46] <Eridius> I could imagine github deciding to just keep every commented commit, period, because why not
[01:28:56] <Eridius> but I could also imagine them just not caring about comments and evicting unreachable commits regularly
[01:32:48] *** Quits: BitPuffin (quassel@moz-49828767.cust.tele2.se) (Ping timeout)
[01:33:11] <aatch> github at least _knows_ when there's been a comment on a deleted commit.
[01:33:43] *** Quits: diegoyam (quassel@FF9B1514.A4EC3D18.3A1EC144.IP) (Ping timeout)
[01:34:13] *** Joins: Sodel_the_V (user@moz-853663E1.va.shawcable.net)
[01:36:43] *** Joins: diegoyam (quassel@FF9B1514.A4EC3D18.3A1EC144.IP)
[01:38:50] *** Quits: Jesse (jruderman@2557E599.66715431.D25A875A.IP) (Quit: Jesse)
[01:39:31] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[01:41:00] <aatch> strcat, Argh, apparently I was off on where I thought the problem was... We already walk the upvar chain...
[01:45:20] *** Quits: mschifer (Adium@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[01:57:45] *** Quits: pcwalton (pcwalton@2557E599.66715431.D25A875A.IP) (Quit: pcwalton)
[01:59:22] * shachaf tries to figure out how to use int::range().
[01:59:41] <aatch> shachaf, don't use iterators instead
[01:59:42] <shachaf> Do I need to import something? I can see the definition in libstd/num/int_macros.rs.
[02:00:00] <dbaupp> rusti: for std::int::range(0, 3) |i| { println(fmt!("%d", i)) }
[02:00:01] -rusti- 0
[02:00:01] -rusti- 1
[02:00:01] -rusti- 2
[02:00:01] -rusti- ()
[02:00:31] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[02:00:33] <shachaf> Oh, std::int, not int.
[02:00:34] <brson> aatch: what is the iterator equivalent of int::range?
[02:00:43] <aatch> Counter I think
[02:00:54] <shachaf> Counter doesn't have an upper limit, only a step.
[02:01:00] <shachaf> (Unless I missed something.)
[02:01:13] <aatch> shachaf, you then take the number you want.
[02:01:24] <aatch> Iterators are composable
[02:01:37] <dbaupp> rusti: for std::iterator::Counter::new(0, 1).take_while(|&i| i < 3).advance |i| { println(fmt!("%d", i)) }
[02:01:38] -rusti- 0
[02:01:38] -rusti- 1
[02:01:38] -rusti- 2
[02:01:38] -rusti- ()
[02:02:00] <aatch> you can also use `take` but that currently requires type hinting.
[02:02:09] <shachaf> OK.
[02:02:19] <shachaf> Why is that a better idea than int::range?
[02:02:21] <dbaupp> shachaf: using range is fine for now
[02:02:22] <brson> really
[02:02:39] <aatch> brson, what are you "really"-ing about?
[02:02:54] <thiez> rusti: use std::iterator::*; for Counter::new(0,1).take_(3).advance |n| { println(fmt!("%d",n)) }
[02:02:55] -rusti- 0
[02:02:55] -rusti- 1
[02:02:55] -rusti- 2
[02:02:55] -rusti- ()
[02:02:57] <thiez> no type hinting?
[02:03:00] <dbaupp> shachaf: (there will be a RangeIterator of some sort, it's just tricky to make it generic and handle overflow correctly.)
[02:03:07] <aatch> Oh, it must have been fixed
[02:03:18] <brson> aatch: i was expressing sympathy with shachaf. range is short. Counter::new... etc. is long
[02:03:23] *** Joins: sankha93 (Instantbir@EA7EC93C.6957C8B2.8B6C1D65.IP)
[02:03:34] <thiez> range could easily be rewritten in terms of Counter though.
[02:03:36] <shachaf> OK.
[02:03:58] <shachaf> Thanks!
[02:04:15] <aatch> brson, well yeah. At any rate, iterators compose better, optimize better and compiler faster.
[02:04:27] <aatch> compile*
[02:04:30] <aatch> bleh
[02:05:29] <thiez> rusti: use std::iterator::*; let _unusable = Counter::new(~"foo",~"bar");
[02:05:30] -rusti- ()
[02:06:02] <dbaupp> rusti: use std::iterator::*; for Counter::new(~"foo",~"bar").take_(3).advance |s| { println(s) }
[02:06:02] -rusti- <anon>:9:35: 9:72 error: failed to find an implementation of trait std::ops::Add<~str,~str> for ~str
[02:06:03] -rusti- <anon>:9          use std::iterator::*; for Counter::new(~"foo",~"bar").take_(3).advance |s| { println(s) }
[02:06:03] -rusti-                                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[02:06:03] -rusti- application terminated with error code 101
[02:06:25] <thiez> :p
[02:06:35] <strcat> brson: it can just be 'for range(0, 10) |x| { }'
[02:06:41] <dbaupp> rusti: ~"foo" + ~"bar"
[02:06:42] -rusti- <anon>:9:18: 9:24 warning: unnecessary allocation, the sigil can be removed [-W unnecessary-allocation (default)]
[02:06:42] <strcat> with an external iterator, when 'for' is updated
[02:06:42] -rusti- <anon>:9          ~"foo" + ~"bar"
[02:06:43] -rusti-                            ^~~~~~
[02:06:43] -rusti- ~"foobar"
[02:06:51] * dbaupp is confused
[02:06:55] <thiez> string concat is magic
[02:06:57] <thiez> don't question it.
[02:07:03] <shachaf> How is for going to be updated?
[02:07:14] <dbaupp> thiez: it shouldn't be *that* magical :(
[02:07:56] <thiez> rusti: use std::iterator::*; struct NoAdd(); let _unusable = Counter::new(NoAdd,NoAdd); // ^^
[02:07:57] -rusti- ()
[02:08:11] <dbaupp> rusti: use std::iterator::*; for Counter::new(~"foo","bar").take_(3).advance |s| { println(s) }
[02:08:12] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/TbAV
[02:08:41] <thiez> rusti: use std::iterator::*; let _unusable = Counter::new((),());
[02:08:42] -rusti- ()
[02:09:08] <strcat> Counter takes T, T right now, it should probably take T, U
[02:09:15] <strcat> well...
[02:09:18] <thiez> it's funny how counter only has the A:Add<A,A> bound on the next()
[02:09:22] <strcat> then it's hard to say what the Add return value should be
[02:09:24] <dbaupp> thiez: the problem is we only have `Add<&'self str, ~str> for &'self str`, and the automatic coercion that happens with a literal non-generic + doesn't happen for the generic one
[02:09:41] <dbaupp> strcat: it should be T, since T gets stored
[02:09:51] <strcat> dbaupp: right
[02:10:51] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[02:11:05] *** Quits: bstrie (ben@moz-EBF8B9B5.zoominternet.net) (Quit: leaving)
[02:11:11] <shachaf> Is there a particular reason structs are distinguished from enums of a single summand?
[02:11:53] <dbaupp> shachaf: binary representation I guess
[02:12:34] <aatch> summand?
[02:12:51] <tjc> summand = variant
[02:12:54] <shachaf> Or whatever each possible value an enum could have is called.
[02:13:00] <shachaf> Ah, variant.
[02:13:05] <aatch> ah.
[02:13:22] <dbaupp> Rust enums have no defined format (on purpose, for optimisation reasons), but structs are meant to be compatible with C structs
[02:13:54] <shachaf> OK.
[02:13:57] *** Quits: echristo (echristo@D423593A.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[02:14:05] <aatch> Rust enums convert stuff like enum NullablePointer<T> { Null, Ptr(~T) }, to an actual nullable pointer.
[02:14:08] <shachaf> If I don't care about memory layout would a one-element enum potentially be better than a struct?
[02:14:14] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[02:14:25] <aatch> shachaf, they would probably be identical.
[02:14:35] <tjc> if you're only going to pattern match on it and you never want to use the dot notation to select fields...
[02:14:43] <tjc> then you would want a univariant enum
[02:16:39] *** Joins: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu)
[02:16:55] <shachaf> (Oh, you're Tim. Hi!)
[02:17:34] <brson> bors queue looks out of date
[02:18:07] *** Joins: kini (kini@moz-92AA953A.members.linode.com)
[02:18:46] <graydon> yes
[02:18:47] <tjc> shachaf: hi! You were at the Haskell hackathon, right?
[02:18:50] <graydon> I'll re-run bors shortly
[02:18:53] <illissius> shachaf: IMHO two good reasons: (1) so C/C++ programmers see familiar things and (2) because struct Foo { ... } is nicer than enum Foo { Foo { ... } }, even if it's just sugar
[02:19:10] <thiez> rusti: use std::iterator::*; struct S(int); impl Clone for S { fn clone(&self)->S { S(**self) }} impl Add<S,S> for S { fn add(&self, rhs: &S) -> S { S((**self) * (**rhs)) } } for Counter::new(S(1),S(2)).take_(4).advance |n|{println(fmt!("%d",*n))}
[02:19:11] -rusti- 1
[02:19:11] -rusti- 2
[02:19:11] -rusti- 4
[02:19:11] -rusti- 8
[02:19:13] -rusti- ()
[02:19:16] <shachaf> tjc: Yep, last year.
[02:19:17] <thiez> this is pretty cool.
[02:19:24] <tjc> right
[02:19:30] <shachaf> (Also this year but I don't think you were there this year.)
[02:20:03] <Eridius> you can say *foo to unwrap an enum-wrapped value?
[02:20:15] <Eridius> well in this case struct-wrapped
[02:20:22] <Eridius> rusti: struct S(int); *S(3)
[02:20:23] -rusti- 3
[02:20:25] <illissius> Eridius: for newtype-structs specifically
[02:20:25] <tjc> didn't even realize there was one this year :-)
[02:20:39] <illissius> so basically that one syntax you just used.
[02:20:40] <dbaupp> Eridius: and single variant enums
[02:20:52] <dbaupp> rusti: enum S { T(int) }; *T(3)
[02:20:53] -rusti- 3
[02:20:58] <Eridius> dbaupp: ok good, I was about to complain that univariant enums should do it too
[02:21:00] <illissius> oh? (/me didn't know that)
[02:21:12] <dbaupp> rusti: enum S { T(int, uint) }; *T(3, 4)
[02:21:13] -rusti- <anon>:9:34: 10:5 error: can only dereference enums with a single variant which has a single argument
[02:21:13] -rusti- <anon>:9          enum S { T(int, uint) }; *T(3, 4)
[02:21:13] -rusti- <anon>:10     };
[02:21:13] -rusti- error: aborting due to previous error
[02:21:13] -rusti- application terminated with error code 101
[02:21:23] <Eridius> illissius: does "newtype-struct" mean a struct with a single unnamed field?
[02:21:25] <thiez> rusti: let a = &&&3; 3****a
[02:21:25] -rusti- <anon>:9:17: 9:19 error: unexpected token: `&&`
[02:21:25] -rusti- <anon>:9          let a = &&&3; 3****a
[02:21:25] -rusti-                           ^~
[02:21:25] -rusti- application terminated with error code 101
[02:21:40] <thiez> rusti: let a = & & &3; 3****a
[02:21:41] -rusti- 9
[02:21:44] <thiez> hehehe.
[02:22:00] <dbaupp> Eridius: yes
[02:22:01] <illissius> Eridius: that's what *I* meant, but I'm not necessarily official terminology
[02:22:02] <strcat> &&& should be valid but && is a token still in the grammar from modes
[02:22:12] <strcat> should remove it
[02:22:19] <illissius> rusti: struct S { x: int }; *S { x: 5 }
[02:22:19] -rusti- <anon>:9:30: 9:32 error: can only dereference structs with one anonymous field
[02:22:19] -rusti- <anon>:9          struct S { x: int }; *S { x: 5 }
[02:22:20] -rusti-                                        ^~
[02:22:20] -rusti- error: aborting due to previous error
[02:22:20] -rusti- application terminated with error code 101
[02:22:20] <dbaupp> strcat: I thought it was the && operator
[02:22:25] <strcat> dbaupp: oh, that too :(
[02:22:34] <strcat> guess it can't be removed then?
[02:22:38] <aatch> strcat, you forgot about logical and?
[02:22:47] <strcat> aatch: yes ;p
[02:22:48] <Eridius> pfft, who needs boolean logic
[02:22:57] <dbaupp> (fun fact: the pretty printer generates && for double-references, so it's output can't compile.)
[02:23:10] *** Joins: seth (seth@FA4B6067.3BBD3C46.DD3002AF.IP)
[02:23:12] <sp3d> can you pull a C++-">>" grammar hack?
[02:23:19] <dbaupp> (at least, it does in some instances)
[02:23:25] <aatch> Eridius, more the point, you needs anything other NAND(?)
[02:23:31] <aatch> s/you/who/
[02:23:46] <aatch> sp3d what do you mean?
[02:23:47] <dbaupp> aatch: XOR is complete(?) too I think
[02:24:05] <sp3d> in modern C++, >> can be the token for rshift or close-two-templates
[02:24:18] <Eridius> aatch: did you see that HN post about implementing logic using water? one gate provided both AND and XOR functionality at the same time
[02:24:31] <aatch> sp3d, ok... I think I know where this is going.
[02:24:40] <dbaupp> sp3d: I think that'd make Rust's grammar not LL(small number)
[02:24:52] <sp3d> ouch
[02:25:17] <aatch> sp3d, Rust's grammar is something like LL(3) I think
[02:25:42] <aatch> and that's only in a very small number of cases.
[02:26:05] *** Joins: peripatetic (peripateti@moz-B5928FE2.hsd1.wa.comcast.net)
[02:26:14] <aatch> Anyway, there is no way for '>>' to be ambiguous.
[02:26:29] <sp3d> yeah, but ambiguity with && seems pretty easy to get
[02:26:31] <sp3d> :/
[02:26:33] *** Quits: seth (seth@FA4B6067.3BBD3C46.DD3002AF.IP) (Ping timeout)
[02:26:49] <thiez> but we're dropping && as a token, so there will no longer be such ambiguity
[02:26:54] <aatch> sp3d, technically, but it just parses greedily.
[02:27:18] <thiez> oh, logical &&
[02:27:20] <sp3d> thiez: what's short-circuiting logical-and?
[02:27:20] <aatch> from a grammar point of view, it's not ambiguous.
[02:27:25] * thiez dislikes.
[02:27:36] <sp3d> mm
[02:27:52] <aatch> and double-referencing like that is incredibly rare.
[02:28:32] <aatch> We could mandate a space between all tokens :D
[02:28:33] <dbaupp> the time it occurs most is getting a reference to a literal vec or string, & &"foo"
[02:28:36] <mark_edward> will you guys full rewrite trans sometime? consideriing all the issues?
[02:28:47] *** Quits: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[02:28:51] <sp3d> makes sense... I wonder if &(&x) would be a nicer convention to encourage than & &x
[02:29:09] <aatch> sp3d, I imagine that's what most people do.
[02:29:16] <dbaupp> sp3d: for strings, &("foo") also works
[02:29:21] * Sodel_the_V likes disambiguating with parens
[02:29:27] *** Joins: seth (seth@FA4B6067.3BBD3C46.DD3002AF.IP)
[02:29:36] <aatch> Sodel_the_V, that's what they're there for
[02:29:45] * dbaupp dislikes that &"foo and "foo" are the same
[02:29:49] *** Joins: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP)
[02:30:08] <aatch> dbaupp, yeah... problem is that it's confusing both ways.
[02:30:19] <dbaupp> aatch: yup
[02:30:53] <aatch> if they weren't, it'd be inconsistent with ~"foo" and @"foo"
[02:31:12] <aatch> or you'd need something stupid like ~*"abc"
[02:31:22] *** Quits: seth (seth@FA4B6067.3BBD3C46.DD3002AF.IP) (Ping timeout)
[02:31:23] <dbaupp> and inconsistent with &[] and []
[02:31:29] *** Joins: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net)
[02:31:52] <aatch> dbaupp, but it already is inconsistent with &[] and []
[02:31:56] <dbaupp> (except "foo" is different to ['f' as u8, 'o' as u8, 'o' as u8, 0u8] anyway)
[02:31:59] <dbaupp> aatch: yeah
[02:32:04] *** Joins: MaikKlein (maik@moz-129BB64.dip0.t-ipconnect.de)
[02:32:08] *** Quits: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[02:32:13] <aatch> Every language has it's warts
[02:32:19] <aatch> as warts go...
[02:33:39] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[02:34:36] *** Quits: illissius (illissius@moz-19397A63.catv.broadband.hu) (Quit: )
[02:36:52] <thiez> graydon: storing null probably does indeed make the DenseInterner smaller, but now you have to iterate over it at every find :(
[02:37:04] *** Joins: bzzzz (bzzzz@moz-7A6060F0.in)
[02:37:10] <bzzzz> does rust have ternary syntax
[02:37:21] <graydon> thiez: have to on 'find' anyway
[02:37:29] <graydon> thiez: you mean get()?
[02:37:39] <dbaupp> bzzzz: not really
[02:37:48] <thiez> eh, yes
[02:37:53] *** Quits: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP) (Ping timeout)
[02:37:54] *** Joins: cowboyd (cowboyd@moz-DD0FF83.lightspeed.austtx.sbcglobal.net)
[02:38:11] <bzzzz> let x = 2 if true else 4
[02:38:12] <dbaupp> bzzzz: but `if .. else ..` is an expression, so `if cond {a} else {b}` is the same as `cond ? a : b` in C/C++
[02:38:31] <dbaupp> rusti: let x = if true {2} else {4}; x
[02:38:31] <bzzzz> dbaupp: yeah but can i do it without those brackets?
[02:38:31] -rusti- 2
[02:38:33] <bzzzz> curly braces*
[02:38:38] <dbaupp> bzzzz: nope
[02:38:40] <aatch> bzzzz, no
[02:39:00] <bzzzz> i can't even complain
[02:39:13] *** Joins: seth (seth@FA4B6067.3BBD3C46.DD3002AF.IP)
[02:39:25] *** Joins: cubic_ (cubic@moz-FE5AD6C7.mc.videotron.ca)
[02:39:28] <aatch> If it didn't have the braces, we'd need parentheses around the condition.
[02:39:57] <bzzzz> counterexample: python
[02:40:12] *** Quits: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca) (Ping timeout)
[02:40:16] <dbaupp> bzzzz: if .. else act as the parens
[02:40:22] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[02:40:27] <bzzzz> but yeah, my previous previous remark was an expression of admiration
[02:40:34] <bzzzz> it really is aesthetically pleasing
[02:40:41] <thiez> in python they do something ugly like 'x if cond else y', right?
[02:40:51] <bzzzz> not ugly yo
[02:40:52] <dbaupp> thiez: yeah
[02:41:23] * dbaupp thinks the ordering of conditions and results is all wrong in python's
[02:41:44] <bzzzz> why? it reads perfectly in english
[02:42:30] <aatch> bzzzz, but you're not using english.
[02:42:30] <dbaupp> yeah, but I'm not writing English... I'm programming, and it's easier to see control-flow with the condition first
[02:42:39] *** Quits: seth (seth@FA4B6067.3BBD3C46.DD3002AF.IP) (Input/output error)
[02:42:48] <bzzzz> something something literate programming
[02:43:01] <dbaupp> heh
[02:43:03] <thiez> because 'do something, but only if some condition, otherwise do something else' hurts my brain more than 'if some condition do something, otherwise do something else', but perhaps I could get used to the former
[02:43:05] *** Joins: tcsc (tcsc@moz-ADC0ED45.hsd1.ct.comcast.net)
[02:43:13] <aatch> bzzzz, literate programming is for people that can't visual data flow.
[02:43:31] <aatch> visualize
[02:43:34] <bzzzz> snobby elitist
[02:43:36] <bzzzz> :p
[02:44:00] <bjz> :)
[02:44:31] <aatch> I'm using an alpha programming language trying to be the best of C++ and ML, what else am I going to be?
[02:44:45] <thiez> a masochist.
[02:44:53] <aatch> thiez, good point
[02:45:12] *** Quits: MaikKlein (maik@moz-129BB64.dip0.t-ipconnect.de) (Ping timeout)
[02:47:31] *** Joins: zxcdw (r-a@858B320D.B543C4DE.3933CC16.IP)
[02:49:09] *** Quits: hugod (user@BFEB3FC7.1742D5AE.CD432688.IP) (Ping timeout)
[02:54:08] *** Joins: roo (jesse.rudo@moz-E265BF43.dynamic.ip.windstream.net)
[02:54:28] <tikue> thiez: python's "x if y else z" isn't a statement though, it's an expression, so there is no "do" part of it
[02:54:52] <tikue> thiez: unless you're talking about comprehensions
[02:54:55] *** Joins: seth (seth@moz-D840E602.dsl.static.sonic.net)
[02:55:02] *** Joins: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net)
[02:55:23] <tcsc> does https://github.com/pcwalton/zero.rs still work?
[02:55:34] <tikue> actually those are expressions too, but I guess it's not different than servo's, which are expressions as well. so nevermind what i'm saying lol
[02:55:51] <aatch> tcsc, depends, does it have a 'sized' lang item yet?
[02:55:59] <tcsc> it does not
[02:56:04] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[02:56:15] <aatch> tcsc, in that case, no. But you can add it.
[02:56:18] <dbaupp> aatch, tcsc: https://github.com/pcwalton/zero.rs/pull/3
[02:56:48] <tcsc> ah, thanks
[02:56:54] *** Quits: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net) (Ping timeout)
[02:56:58] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[02:57:41] *** Quits: ssbr (ssbr@moz-141F89C6.block0.gvtc.com) (Ping timeout)
[02:58:39] <aatch> So close to fixing this bug. I just need to trace the source of the problem
[02:59:14] *** Quits: zz_kimundi (kimundi@moz-9E8229F3.dip0.t-ipconnect.de) (Ping timeout)
[02:59:54] *** Joins: ssbr (ssbr@moz-141F89C6.block0.gvtc.com)
[03:00:20] <bjz> nmatsakis: some ideas on precedence for generic impls: https://gist.github.com/bjz/5855557
[03:01:12] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[03:01:12] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14a8e3d4c to 14c6515ee: 02http://git.io/N3iJvQ
[03:01:12] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[03:01:16] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[03:01:16] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/62fT0Q
[03:01:16] <ghrust> 13rust/06auto 144c2c606 15Alex Crichton: Rename all files with the 'rc' extension
[03:01:16] <ghrust> 13rust/06auto 1426b4af5 15Alex Crichton: Add the `warnings` lint attribute
[03:01:16] <ghrust> 13rust/06auto 1459f99db 15Alex Crichton: Deny common lints by default for lib{std,extra}
[03:01:17] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[03:01:27] <bjz> nmatsakis: I'm not smart enough to reason about it fully, but I thought it might be good to spark some discussion
[03:02:17] *** Joins: zz_kimundi (kimundi@moz-DE7C650.dip0.t-ipconnect.de)
[03:02:44] *** zz_kimundi is now known as kimundi
[03:03:02] <bjz> nmatsakis: I definitely think the way that `impl Trait for T` smothers any other impl is concerning (but you've probably already thought about this)
[03:04:18] *** Quits: SiegeLord (siege@moz-CAF07B4C.hsd1.ma.comcast.net) (Connection reset by peer)
[03:04:53] *** Quits: roo (jesse.rudo@moz-E265BF43.dynamic.ip.windstream.net) (Ping timeout)
[03:04:54] <aatch> bjz, fwiw, I think concrete, parameterized and generic are better terms. If you think of a ~[T] as a ~Vec<T> and a (T,int) as a Tuple2<T,int>.
[03:05:20] <bzzzz> erf
[03:05:24] <nmatsakis> bjz: I've not thought about it too hard, tbh.
[03:05:34] *** Joins: roo (jesse.rudo@moz-83ED4CD4.dynamic.ip.windstream.net)
[03:05:41] <bzzzz> is ./configure's --llvm-root supposed to point to the src root of llvm?
[03:05:46] <dbaupp> (~/@/& sort-of count as generic too Unique<T>, Managed<T>, Borrowed<T>)
[03:05:47] <bjz> aatch: changed
[03:05:56] <nmatsakis> bjz: I could imagine adding a prioritization scheme like that
[03:06:00] *** Quits: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[03:06:11] <bzzzz> or the $PREFIX under which bin/ll{c,i,etc}, include/ and so forth?
[03:06:14] <bjz> nmatsakis: I don't know if it might solve the operator issue
[03:06:23] *** Quits: peripatetic (peripateti@moz-B5928FE2.hsd1.wa.comcast.net) (Quit: WeeChat 0.4.0)
[03:06:27] <bjz> nmatsakis: well, for some cases at least
[03:06:32] <nmatsakis> bjz: but I'm not sure what the diff is between the first two levels,
[03:06:34] <aatch> bzzzz, if you're trying to use a system LLVM, it won't work
[03:06:41] <bzzzz> aatch: it's not a sys
[03:06:51] <bzzzz> i git cloned and compiled in another dir
[03:06:55] <nmatsakis> bjz: oh, I guess I see. in the 2nd case, there exists some type parameter.
[03:07:15] *** Joins: eatkinson (eatkinson@130C99DB.3ABCD45F.12FC38C.IP)
[03:07:33] <bjz> nmatsakis: yep - &[int] is more specific than &[T]
[03:08:02] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[03:08:04] <aatch> dbaupp, I did think of that, but considering the current state, i.e. autoderef, I decided that they shouldn't count.
[03:08:04] <bjz> nmatsakis: but yeah, not sure of the specifics, but it might be something to think about
[03:08:11] <aatch> not for this anyway.
[03:08:16] <nmatsakis> cmr: btw did you ever get those memory results?
[03:09:06] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[03:09:22] <bjz> nmatsakis: atm we have to use macros in some cases, to impl for multiple types
[03:09:25] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[03:09:42] <bjz> nmatsakis: I'll have to see if I can find some examples in std
[03:10:28] <nmatsakis> bjz: in any case, it is certainly plausible to define a "more specific" hierarchy, though it gets complicated for parameterized traits
[03:10:34] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[03:10:44] <enix> how do you declare a multidemensional array? "fn test(x: &http://en.wikipedia.org/wiki/Special:Search?go=Go&search=u32)" gives me an error.
[03:10:45] <nmatsakis> bjz: but usually you just wind up with cases where neither impl is more specific than the other, which would presumably be an error.
[03:10:47] <bjz> nmatsakis: agreed, not sure how to handle that
[03:10:56] <bjz> nmatsakis: yes
[03:11:09] <enix> ug, "fn test(x: &[ [ u32 ] ])
[03:11:11] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[03:11:11] *** ChanServ sets mode: +o dherman
[03:11:19] *** Quits: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[03:11:33] <enix> doesn't seem to be what i want
[03:11:52] <aatch> enix, what are you trying to construct?
[03:11:54] <bjz> nmatsakis: impling (T, float, int) (T, U, int) would give an error?
[03:12:46] <bjz> nmatsakis: or maybe more like (T, float, int) and (float, T, int)
[03:12:54] <nmatsakis> bjz: I think that case would not be an error, but (T, float, U) vs (T, U, float) might be
[03:13:04] <bjz> nmatsakis: ahh yes
[03:13:04] <enix> i'm playing around with AES and trying to construct a function that take an array of an array of u32s
[03:13:09] <aatch> You can do "&[&[ u32 ]]"
[03:13:21] <bjz> nmatsakis: I can imagine you might get confusing errors though :(
[03:13:29] <aatch> Actually, make that &[~[u32]]
[03:13:41] <sp3d> would a fixed-length inner vector work?
[03:14:29] <enix> sp3d: i think a fixed length inner array will work
[03:14:58] <enix> ah, and that even compiles! nice, thanks all!
[03:15:55] <sp3d> rusti: let a:&[[u32,..2]] = [[0,1]]; a
[03:15:56] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/TJOW
[03:16:46] <sp3d> rusti: let a:~[[u32,..2]] = ~[[0,1]]; a
[03:16:47] -rusti- ~[[0, 1]]
[03:16:51] <sp3d> cool
[03:18:06] <dbaupp> aatch: true (re: pointers & impls)
[03:18:30] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[03:18:32] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz)
[03:18:33] *** Quits: Jesin (Jessin_@moz-157A63DD.cc.lehigh.edu) (Ping timeout)
[03:19:08] <enix> i thought vectors had to be declared like: [u8, ..4]. is the ".." not necessary?
[03:19:12] <aatch> hmm... seem to be having trouble figuring out how to stop stack closures from capturing upvars that are themselves captured by reference.
[03:19:29] <aatch> enix, for types, yes
[03:19:36] <aatch> as in, the '..' is needed
[03:19:48] <enix> ah, ok
[03:19:52] <dbaupp> enix: in types it is, in values it's a shortcut to fill with many copies of the one values
[03:19:58] <dbaupp> *value
[03:20:02] <graydon> fwiw
[03:20:09] <graydon> I have bumped the build limit to 3 on mac4
[03:20:12] *** Quits: lucian (lucian@moz-22A14C6A.cable.virginmedia.com) (Ping timeout)
[03:20:14] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[03:20:17] <graydon> so that all 5 mac builds can run at once
[03:20:21] <graydon> this _might_ be enough to make mac4 page
[03:20:30] <graydon> if it does, please tell someone who has access to the botmaster
[03:20:40] <graydon> to lower max_builds in the slave list to 2 on mac4 again
[03:20:44] <graydon> and run 'buildbot reconfig'
[03:20:47] <graydon> (and buy more minis!)
[03:21:03] <aatch> nmatsakis, ping
[03:21:14] <nmatsakis> aatch: pong
[03:21:16] <dbaupp> graydon: for reference, who has access to the botmaster?
[03:21:30] <aatch> nmatsakis, ok, I'm trying to fix this: https://github.com/mozilla/rust/issues/7336
[03:21:50] <bjz> nmatsakis: https://gist.github.com/bjz/5855557
[03:21:56] <graydon> dbaupp: me, brian, patrick. from the look of it.
[03:22:12] <aatch> nmatsakis, I have managed to get to the point where I know what the problem is, but I'm having trouble finding the best place to fix it.
[03:22:16] *** Joins: elifrey (peripateti@moz-B5928FE2.hsd1.wa.comcast.net)
[03:22:22] <graydon> though I've also shown tim how to operate it. I guess I didn't add him to the ACL for it yet.
[03:22:22] *** Quits: bytbox (s@moz-D83E9B31.wireless.umd.edu) (Ping timeout)
[03:22:29] <nmatsakis> aatch: this is a borrowck failure?
[03:22:51] <graydon> surgery at 8am tomorrow. wish me luck!
[03:23:07] *** Joins: Aetherspawn (Aetherspaw@moz-8811D9F0.static.tpgi.com.au)
[03:23:08] <aatch> nmatsakis, more like a capture problem. the inner closure captures the outer closure's upvar, rather than the local var
[03:23:10] <bzzzz> good luck!
[03:23:13] *** Quits: seth (seth@moz-D840E602.dsl.static.sonic.net) (Input/output error)
[03:23:51] <aatch> problem is, I can't just bound up the upvar chain, since there may be a heap closure in the way that captured by copy
[03:24:05] <aatch> in which case, capturing the upvar is fine.
[03:24:14] <nmatsakis> aatch: the problem appears to be that it is permitting the closure to be returned,
[03:24:17] <nmatsakis> aatch: which it should not be.
[03:24:20] <nmatsakis> aatch: that is never legal.
[03:24:51] <aatch> nmatsakis, ok then. So just prevent all &fn returns?
[03:25:09] <strcat> well it depends on the lifetime, right?
[03:25:10] <nmatsakis> aatch: it's not so simple as that, I mean it should fallout of the type rules, I hvea to investiate to see why it's not
[03:25:21] <strcat> you shouldn't be able to return a local one
[03:25:25] <nmatsakis> aatch: might be related to that other bug that allows you to return stack allocated vectors too,
[03:25:34] <strcat> nmatsakis: I think this is an issue with slices too
[03:25:43] <aatch> nmatsakis, sounds possible.
[03:26:01] <nmatsakis> yeah, let me take a look in a bit
[03:26:03] <nmatsakis> busy atm
[03:26:39] *** Joins: bytbox (s@moz-2E27684C.student.umd.edu)
[03:26:44] <aatch> In that case, why on earth is that test in run-pass?
[03:27:03] <strcat> &fn didn't used to be the default
[03:27:06] <strcat> for a closure
[03:27:06] <nmatsakis> aatch: who knows? but back in the day, || defaulted to @fn...
[03:27:17] <strcat> I think the test was xfailed
[03:27:23] <strcat> it got un-xfailed and I xfailed it again
[03:27:30] <strcat> and I guess that found a bug
[03:27:41] *** Quits: roo (jesse.rudo@moz-83ED4CD4.dynamic.ip.windstream.net) (Ping timeout)
[03:27:57] <graydon> \o/ the auto-interruptor works!
[03:28:07] <graydon> brendanc: you are a saint, thanks
[03:28:10] * strcat can retire now ;p
[03:28:10] <aatch> nmatsakis, ok then. The name "unconstrained_region.rs" confused me too. 
[03:28:21] <graydon> strcat: first build failure kills the others in a given push now :)
[03:29:33] <graydon> someone might want to, uh, fix the rustpkg test there?
[03:29:51] <graydon> anyway, off now. hopefully nothing explodes too bad during the night / tomorrow
[03:29:52] <graydon> ttyl
[03:30:06] <strcat>  {LLVM ERROR: Section header table goes past end of file!
[03:30:06] <strcat> huh
[03:30:18] <acrichto> yeah what's going on there
[03:30:36] <acrichto> that's the second time as well, so it's not a fluke
[03:31:12] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[03:31:12] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1427f7982 to 14c6515ee: 02http://git.io/N3iJvQ
[03:31:12] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[03:31:14] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[03:31:14] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/G9TwCA
[03:31:14] <ghrust> 13rust/06auto 144c2c606 15Alex Crichton: Rename all files with the 'rc' extension
[03:31:14] <ghrust> 13rust/06auto 1426b4af5 15Alex Crichton: Add the `warnings` lint attribute
[03:31:14] <ghrust> 13rust/06auto 1459f99db 15Alex Crichton: Deny common lints by default for lib{std,extra}
[03:31:16] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[03:31:17] <strcat> don't see how you would have caused it though
[03:31:18] *** Quits: graydon (graydon@3853DDD.39EEDBB3.D758B1AA.IP) (Quit: Leaving.)
[03:31:21] <acrichto> yeah :(
[03:31:34] <strcat> maybe one of the builders is broken
[03:32:19] <bjz> acrichto: hoy
[03:32:35] <acrichto> bjz: ?
[03:33:17] <bjz> acrichto: with your static mut implementation, will we be able to use extern fns?
[03:33:37] <bjz> acrichto: I'd like to use it for my opengl loader generator
[03:33:41] <strcat> so many each functions to kill
[03:33:43] <acrichto> bjz: how so?
[03:33:46] <strcat> vec::each can go next
[03:36:01] <dcolish> I have a small request about renaming os::make_absolute to os::realpath, is that something i'd put on the github issue tracker?
[03:36:11] <dcolish> (might not be such a small request)
[03:36:22] <bjz> acrichto: so you'd have: `extern "C" fn failing_glFoo(....) { fail!("not yet loaded) } static mut glFoo: extern "C" fn(...) = failing_glFoo; // load function pointer into glFoo`
[03:36:41] <acrichto> bjz: yeah I think you can do that?
[03:36:42] <strcat> dcolish: is it actually realpath?
[03:36:56] <bjz> acrichto: ofc, still waiting on nmatsakis' patch
[03:36:59] <strcat> realpath resolves symlinks
[03:37:06] <acrichto> bjz: if you can do that today without 'mut', then it's just more useful with my patch
[03:37:07] *** Joins: roo (jesse.rudo@moz-5E3AE203.dynamic.ip.windstream.net)
[03:37:22] <dcolish> true, i was thinking os::abspath would be a nicer name too, but realpath is more posix
[03:37:28] <bjz> acrichto: neat
[03:37:56] <bzzzz> what's the invocation to compile zero.rs?
[03:38:04] <bzzzz> getting a bunch of "duplicate entry" errors
[03:38:17] <strcat> you have to disable linking against the stdlib
[03:38:19] <dcolish> i also wonder how normalize is really working because i noticed some odd behaviors with removing relative paths
[03:38:47] <bjz> rusti: extern "C" fn foo() { println("hi") } static FOO : *u8 = foo; FOO()
[03:38:48] -rusti- <anon>:9:71: 10:5 error: expected function but found `*u8`
[03:38:48] -rusti- <anon>:9          extern "C" fn foo() { println("hi") } static FOO : *u8 = foo; FOO()
[03:38:48] -rusti- <anon>:10     };
[03:38:48] -rusti- error: aborting due to previous error
[03:38:48] -rusti- application terminated with error code 101
[03:39:07] <bjz> rusti: extern "C" fn foo() { println("hi") } static FOO : *u8 = foo as *u8; FOO()
[03:39:07] -rusti- <anon>:9:78: 10:5 error: expected function but found `*u8`
[03:39:07] -rusti- <anon>:9          extern "C" fn foo() { println("hi") } static FOO : *u8 = foo as *u8; FOO()
[03:39:07] -rusti- <anon>:10     };
[03:39:07] -rusti- error: aborting due to previous error
[03:39:08] -rusti- application terminated with error code 101
[03:39:28] <bjz> rusti: extern "C" fn foo() { println("hi") } static FOO : extern "C" fn() = foo; FOO()
[03:39:28] -rusti- <anon>:9:78: 9:81 error: mismatched types: expected `extern "C" fn()` but found `*u8` (expected extern fn but found *-ptr)
[03:39:28] -rusti- <anon>:9          extern "C" fn foo() { println("hi") } static FOO : extern "C" fn() = foo; FOO()
[03:39:28] -rusti-                                                                                        ^~~
[03:39:28] -rusti- error: aborting due to previous error
[03:39:30] -rusti- application terminated with error code 101
[03:39:39] <bjz> -_-
[03:39:52] * bjz really would love the pointer patch
[03:39:54] *** Joins: Jesin (Jessin_@moz-157A63DD.cc.lehigh.edu)
[03:40:06] <aatch> heheh
[03:40:41] <bjz> acrichto: it looks like it'd work, but we await the patch
[03:40:57] <bjz> rusti: fn foo() { println("hi") } static FOO : &fn() = foo; FOO()
[03:40:57] -rusti- <anon>:9:49: 9:54 error: Illegal anonymous lifetime: only 'static is allowed here
[03:40:57] -rusti- <anon>:9          fn foo() { println("hi") } static FOO : &fn() = foo; FOO()
[03:40:57] -rusti-                                                           ^~~~~
[03:40:57] -rusti- error: aborting due to previous error
[03:40:58] -rusti- application terminated with error code 101
[03:41:10] <bjz> rusti: fn foo() { println("hi") } static FOO : &'static fn() = foo; FOO()
[03:41:11] -rusti- <anon>:9:65: 9:68 error: mismatched types: expected `&'static fn<no-bounds>()` but found `extern "Rust" fn()` (expected fn but found extern fn)
[03:41:11] -rusti- <anon>:9          fn foo() { println("hi") } static FOO : &'static fn() = foo; FOO()
[03:41:11] -rusti-                                                                           ^~~
[03:41:11] -rusti- error: aborting due to previous error
[03:41:12] -rusti- application terminated with error code 101
[03:41:27] <bjz> rusti: fn foo() { println("hi") } static FOO : extern "Rust" fn() = foo; FOO()
[03:41:27] -rusti- <anon>:9:75: 9:78 error: internal compiler error: Cannot translate def def_const({crate: 0, node: 21}) to a callable thing!
[03:41:27] -rusti- <anon>:9          fn foo() { println("hi") } static FOO : extern "Rust" fn() = foo; FOO()
[03:41:27] -rusti-                                                                                     ^~~
[03:41:27] -rusti- application terminated with error code 101
[03:41:38] <bjz> :S
[03:41:44] <bjz> nmatsakis: ^?
[03:41:46] *** Quits: Jesin (Jessin_@moz-157A63DD.cc.lehigh.edu) (Ping timeout)
[03:42:30] *** Joins: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net)
[03:42:31] <bzzzz> strcat: what's the flag for that?
[03:42:33] <bjz> nmatsakis: will that also be fixed with your patch?
[03:42:45] <aatch> bjz, that actually looks easy to fix...
[03:43:05] <strcat> bzzzz: #[no_std]; 
[03:43:08] <aatch> Assuming...
[03:43:11] *** Quits: heftig (heftig@moz-603B6D4A.dip0.t-ipconnect.de) (Ping timeout)
[03:43:21] <aatch> rusti: let a : int = 5; a()
[03:43:21] -rusti- <anon>:9:26: 10:5 error: expected function but found `int`
[03:43:21] -rusti- <anon>:9          let a : int = 5; a()
[03:43:21] -rusti- <anon>:10     };
[03:43:21] -rusti- error: aborting due to previous error
[03:43:22] -rusti- application terminated with error code 101
[03:43:51] <bjz> ?
[03:44:11] *** Quits: roo (jesse.rudo@moz-5E3AE203.dynamic.ip.windstream.net) (Ping timeout)
[03:44:20] *** Quits: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[03:44:35] <aatch> Well currently there's just a list of def_* that can't be translated to functions.
[03:45:33] <aatch> I'm assuming that nobody bothered to change it when the ability to just have `extern fn` be used as a type landed.
[03:45:55] <bjz> would be funny if you could do: static fn foo: fn() = || { println("hi") }; foo()
[03:46:01] *** Joins: huhlig-home (huhlig@moz-C8339267.hfc.comcastbusiness.net)
[03:46:06] *** Quits: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP) (Quit: My MacBook has gone to sleep. ZZZzzz)
[03:47:15] <bjz> aatch: would you be able to fix that?
[03:47:36] <bjz> aatch: so once the fptr fix lands we can do the loader?
[03:47:59] <aatch> Well not with a closure like that, but the other, maybe...
[03:48:34] <bjz> aatch: yeah, unfortunately
[03:49:04] <aatch> It gets past type checking, so presumably it will work fine.
[03:49:23] <aatch> closure won't work because you can't coerce it to the right type.
[03:50:01] <bjz> aatch: it would be amazing if you could do: `static mut glFoo(): extern "C" fn() = || fail!("not loaded");`, but I doubt that will happen
[03:50:14] <bjz> aatch: will have to use the helper function
[03:50:35] * strcat is never sure what to do with tests when removing APIs
[03:51:03] *** Quits: eatkinson (eatkinson@130C99DB.3ABCD45F.12FC38C.IP) (Quit: eatkinson)
[03:51:44] <strcat> I don't think this test can be written another way atm ;\
[03:51:49] * strcat shrugs
[03:51:58] *** Joins: heftig (heftig@moz-7371B0A7.dip0.t-ipconnect.de)
[03:51:59] *** Quits: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net) (Ping timeout)
[03:52:02] <bjz> acrichto: anyway, thanks for the static mut (when it passes). it will make the gl loader awesome
[03:52:11] <acrichto> bjz: no problem :)
[03:52:30] <bjz> :)
[03:52:35] * bjz can't wait
[03:52:54] *** Joins: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP)
[03:53:33] * bjz has the beginnings of the xml reader: https://github.com/bjz/gl-rs/blob/master/generator.rs
[03:53:50] <bjz> (no more lua dependency!)
[03:54:43] <strcat> rusti: let xs = ~[1, 2, 3]; for xs.iter().advance |x| { println(x.to_str()) }
[03:54:44] -rusti- 1
[03:54:45] -rusti- 2
[03:54:45] -rusti- 3
[03:54:45] -rusti- ()
[03:54:57] <strcat> rusti: for (~[1, 2, 3]).iter().advance |x| { println(x.to_str()) }
[03:54:59] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/fHcO
[03:55:34] <aatch> bjz, ok, so if my assumptions are correct, the fix for calling constants should consist of about a 3 line change
[03:55:46] <bjz> :D
[03:56:18] <aatch> basically, it's a section of code that goes "shouldn't ever get here"
[03:56:56] <aatch> but since it does...
[03:57:19] *** Joins: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu)
[03:57:52] <aatch> Aww... it's not as simple as I hoped...
[03:59:14] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[04:00:12] <dcolish> i kind of think that abspath should normalize too
[04:01:54] *** Quits: cowboyd (cowboyd@moz-DD0FF83.lightspeed.austtx.sbcglobal.net) (Client exited)
[04:02:23] <acrichto> strcat: it failed with the same error again :(
[04:02:29] <strcat> acrichto: meh
[04:02:49] <bzzzz> 05:58:52 CEST /m/p/zero.rs> rust build hello.rs
[04:02:49] <bzzzz> error: no item found for `sized`
[04:02:52] <bzzzz> what do, plz halp
[04:03:14] <bzzzz> that was with #[no_std]
[04:03:31] <aatch> bzzzz, add #[lang_item="sized"] trait Sized {} to zero.rs
[04:03:54] <Luqman> just #[lang="sized"]
[04:04:14] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[04:04:14] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14fdaab34 to 14c6515ee: 02http://git.io/N3iJvQ
[04:04:14] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[04:04:16] <aatch> Oops, close
[04:04:16] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[04:04:16] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/5PqiCA
[04:04:16] <ghrust> 13rust/06auto 14079b07d 15Fedor Indutny: libc: support functions from sys/mman.h...
[04:04:16] <ghrust> 13rust/06auto 14ddd6f59 15Fedor Indutny: libc: add POSIX-compatible sysconf consts...
[04:04:16] <ghrust> 13rust/06auto 14bc70edb 15Fedor Indutny: libc: (u)int => c_(u)int for consts
[04:04:18] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[04:04:54] *** Joins: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net)
[04:05:01] <bblum> aatch: hm
[04:05:05] <bblum> there should be a zero.rs test
[04:05:06] <bblum> for that
[04:05:24] <aatch> bblum, there's already a PR open on zero.rs
[04:05:44] <aatch> pcwalton hasn't merged it yet...
[04:05:44] <bblum> oh cool
[04:05:56] *** Quits: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP) (Quit: eatkinson)
[04:06:06] <bzzzz> yes it werks
[04:06:15] <bzzzz> Luqman: tenks
[04:07:25] *** Joins: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP)
[04:07:37] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[04:07:37] *** ChanServ sets mode: +o dherman
[04:07:40] <bytbox> can macros only be invoked in certain places? I want match expr { macro!(stuff) }, where macro! expands to Pattern => expr, but I get "expected => but found !"
[04:08:25] <aatch> bytbox, macros can only be expanded into items or expressions
[04:08:32] <bytbox> aatch: ok, thanks
[04:09:19] <aatch> Oh, and if they are the first thing in an expression, the entire macro is parsed as a statement. Which can be a gotcha
[04:09:57] <aatch> So you can't do macro!(stuff).method()
[04:11:05] <bytbox> aatch: ah, ok. (That makes sense though.)
[04:11:57] *** Quits: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP) (Quit: eatkinson)
[04:12:06] <strcat> aatch: still need to fix that drop flag thing ;p
[04:12:16] <aatch> strcat, I know...
[04:12:19] * strcat is worried about it landing broken
[04:13:38] <strcat> hopefully this is the end of vec::each
[04:13:47] <strcat> it would be awesome if we could land a new for loop before 0.7... ;p
[04:13:49] * strcat dreams
[04:14:02] <aatch> strcat, that's not gonna happen.
[04:14:06] <aatch> Maybe 0.8
[04:14:18] <strcat> the tutorial is so bad
[04:14:47] <strcat> I'm going to write a container+iterator tutorial, I think I'll just remove for loops from the main tutorial when I do
[04:15:01] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[04:15:25] <bytbox> what's happening to for-loops?
[04:15:47] <strcat> going to switch to external iterators
[04:15:58] <bytbox> eh, I guess that makes sense
[04:16:08] <strcat> can still use 'do' for various internal iterator protocols, but the stdlib isn't going to use internal iterators
[04:16:58] <bblum> i hope there will still be do-style 'map'
[04:17:13] <strcat> bblum: it's painful with our current iterator protocol though
[04:17:27] <bblum> huh?
[04:18:09] <strcat> bblum: do you mean a 'map' for internal iterators?
[04:18:19] <bblum> yes
[04:18:30] <strcat> fn map<T, U>(input: &fn(&fn(T) -> bool) -> bool, output: &fn(U) -> bool, f: fn(T) -> U) -> bool
[04:18:32] <strcat> not that bad I guess
[04:18:49] <bblum> what's the deal with those input and output
[04:18:51] <aatch> strcat, for the take glue, it should still take all the elements first, right?
[04:18:56] <strcat> bblum: the input iterator and the output 
[04:19:09] <aatch> s/elements/fields
[04:19:12] <bblum> no i just mean, like, on types in particular, or derived somehow
[04:19:19] <bblum> it's just that sometimes i have a closure on hand, and an option
[04:19:26] <bblum> and i want to be like, "return opt.map(f);"
[04:19:42] <strcat> bblum: well that'll still exist
[04:19:47] <strcat> and Option implements Iterator
[04:19:54] <strcat> err
[04:20:01] <strcat> I mean option *provides* an Iterator
[04:20:07] <strcat> it will implement Iterable, once traits work...
[04:21:19] <elifrey> I am very stoked on the iterator work.  If I understand correctly, external iterators are basically pythonic generators, and internal iterators are basically pythonic iterators.
[04:21:40] <elifrey> the syntax is kind of mid stream right now, but I just rewrite it in my head :).
[04:21:57] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[04:22:02] <strcat> yes it's a pain without the ability to write an Iterable trait + the method resolve bug forcing underscores
[04:22:04] <strcat> rusti: let x = Some(5); let ys = [1, 2, 3, 4]; x.iter().chain_(ys.iter()).fold(0, |a, b| a + *b)
[04:22:05] -rusti- 15
[04:22:17] <strcat> could be
[04:22:23] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[04:22:27] <strcat> x.chain(ys).fold(0, |a, b| a + *b)
[04:22:29] <strcat> with Iterable
[04:23:05] <strcat> + not having a for loop tailored to it
[04:23:33] <strcat> and rvalue bugs making you require a temporary value to hold the iterable :(
[04:23:45] *** Joins: brson (brson@moz-6A295265.hsd1.ca.comcast.net)
[04:23:45] *** ChanServ sets mode: +o brson
[04:23:56] <elifrey> ah, I wasn't aware the whole iter() thing was do to a trait bug
[04:24:09] <strcat> iter() will still exist, along with rev_iter, mut_iter and other variants
[04:24:11] <strcat> depending on the type
[04:24:29] <elifrey> but you won't have to call iter() on an iter to make it iterable?
[04:24:30] <strcat> but iterables could provide iter() via Iterable and get the adaptors as default methods
[04:24:33] <strcat> elifrey: yeah
[04:24:37] <strcat> so
[04:25:04] <elifrey> and there's currently an overhead to the transformation, it's not just a no-op?
[04:25:14] <strcat> no overhead to function calls
[04:25:26] <strcat> LLVM will even constant-fold something like
[04:25:45] *** Joins: seth (seth@moz-D840E602.dsl.static.sonic.net)
[04:25:48] <strcat> Counter::new(5, 8).take_while(|x| *x < 10000).fold(0, |a, b| a + b)
[04:26:01] <strcat> to a compile-time integer
[04:26:20] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[04:26:31] <elifrey> cool
[04:26:37] *** Quits: brson (brson@moz-6A295265.hsd1.ca.comcast.net) (Ping timeout)
[04:26:48] <aatch> elifrey, with optimizations on, just so you don't get the wrong idea
[04:26:56] <aatch> Also, new snapshot!
[04:27:24] <sp3d> ooh, just out of the oven?
[04:27:36] * aatch will finish this take-glue stuff first.
[04:27:59] <shachaf> hi elifrey
[04:27:59] <sp3d> almost out of the oven, I guess :P
[04:28:11] <aatch> sp3d, yep, would've been done earlier, but the two bots that service linux-snap-stage3 were offline
[04:28:17] * elifrey waves at shachaf
[04:28:17] <strcat> rusti: let xs = [1, 2, 3, 4]; for xs.rev_iter().zip(xs.iter()).advance |(x, y)| { println(fmt!("%? %?", x, y)) }
[04:28:18] -rusti- &4 &1
[04:28:18] -rusti- &3 &2
[04:28:18] -rusti- &2 &3
[04:28:18] -rusti- &1 &4
[04:28:18] -rusti- ()
[04:28:21] <strcat> really much uglier than it should be atm ;p
[04:28:32] <shachaf> I thought you didn't do the whole IRC thing!
[04:28:53] <elifrey> shachaf: ha! I'm trying to learn a new trick
[04:28:59] <strcat> for xs.rev_iter().zip(xs) |(x, y)| { ... }
[04:29:01] <strcat> is the future
[04:29:18] *** Joins: brson (brson@5F06B402.AD1E507F.3688B332.IP)
[04:29:18] *** ChanServ sets mode: +o brson
[04:29:21] * strcat anxiously awaits having the language features actually work ;p
[04:29:38] <sp3d> future rust is so exciting, I wish I had more time so I could help get it there >_>
[04:29:48] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[04:30:12] * bjz wishes he was more wizardly so he could help better
[04:30:16] *** Quits: seth (seth@moz-D840E602.dsl.static.sonic.net) (Ping timeout)
[04:30:41] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[04:30:41] <ghrust> 01[13rust01] 15thestinger 04force-pushed 06try from 14e119fd5 to 14481bf03: 02http://git.io/k471pw
[04:30:41] <ghrust> 13rust/06try 14c4e3a94 15Daniel Micay: remove the redundant `each` method from OptVec
[04:30:41] <ghrust> 13rust/06try 14e8ea2f1 15Daniel Micay: container: remove internal iterators from Map...
[04:30:41] <ghrust> 13rust/06try 146c38e20 15Daniel Micay: remove the redundant each method from HashMap
[04:30:44] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[04:32:08] *** Quits: heftig (heftig@moz-7371B0A7.dip0.t-ipconnect.de) (Quit: Quitting)
[04:32:29] <dbaupp> strcat: \o/
[04:32:33] *** Joins: heftig (heftig@moz-7371B0A7.dip0.t-ipconnect.de)
[04:32:44] <strcat> heh I screwed up that commit
[04:32:59] * strcat accidentally squashed the last two
[04:33:06] <dcolish> is the best way to run libstd tests with the `make check` in tree?
[04:33:20] *** Joins: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net)
[04:34:12] <bjz> dcolish: make check-stage1-std NO_REBUILD=1
[04:34:46] <bjz> dcolish: you need a recent build for it to work though
[04:34:56] <bjz> dcolish: but it's much faster
[04:35:13] <dcolish> i'm only a few days behind master
[04:35:14] <bjz> dcolish: make sure you run the full test-suite before you PR though
[04:35:43] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[04:35:43] <ghrust> 01[13rust01] 15thestinger 04force-pushed 06try from 14481bf03 to 140efc7bd: 02http://git.io/k471pw
[04:35:43] <ghrust> 13rust/06try 140efc7bd 15Daniel Micay: remove `each` from vec, HashMap and HashSet
[04:35:43] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[04:35:53] <dcolish> sure thing
[04:36:23] <bjz> dcolish: no, I mean, in order for it to compile properly you need a recent build of the compiler, doesn't matter where you are in relation to master
[04:36:39] <aatch> Ok, seems to work fine with the memzero in the take glue
[04:36:50] <bjz> dcolish: because it skips the rebuild
[04:37:03] <dcolish> ah i see what you mean, i built it a few days ago and have only changed libstd::os
[04:37:09] <strcat> aatch: and not in drop
[04:37:14] <aatch> strcat, yes
[04:37:17] <strcat> yay!
[04:37:19] <bjz> dcolish: should be fine then
[04:37:33] * strcat really wants 8-byte Rc
[04:37:36] <aatch> I run the take glue on all the fields, then zero the struct
[04:37:51] <strcat> aatch: sounds good
[04:38:01] <dbaupp> strcat: just use x86 ;P
[04:38:15] <bjz> dbaupp: but remember, std::os is probably used quite a bit around the compiler, so after the std tests pass, make sure you check everything is ok elsewhere
[04:38:17] <strcat> dbaupp: x32*
[04:38:24] <bjz> * dcolish
[04:38:28] <strcat> dbaupp: which I could, but I'd have to make a buildbot + repo with all the packages :S
[04:38:40] <bjz> dcolish: but you probably know that already :)
[04:38:57] <strcat> dbaupp: https://en.wikipedia.org/wiki/X32_ABI
[04:39:05] <strcat> ;p
[04:39:06] <dbaupp> strcat: true
[04:39:13] <strcat> but then I could have a 4-byte Rc!
[04:39:25] *** Quits: cubic_ (cubic@moz-FE5AD6C7.mc.videotron.ca) (Connection reset by peer)
[04:39:35] <dbaupp> Use a 16-bit micro and you can have 2 byte Rc!
[04:40:29] <strcat> alright, container tutorial.
[04:41:12] <dcolish> bjz: yeah i'm going to run a full test suite after i get this done. its a pretty small change so i really hope it doesnt break anything
[04:41:33] <dcolish> s/pretty/ridiculously/
[04:42:31] <aatch> strcat, ok, updated and pushed.
[04:42:35] <bjz> who is MarkJr94 on github?
[04:43:39] <strcat> aatch: r+
[04:44:37] <bjz> is there a way of downloading a file from the interwebs in std, or will I have to use libcurl or something?
[04:45:03] <strcat> bjz: just use libcurl
[04:45:08] <strcat> the stdlib doesn't have http
[04:45:20] *** Quits: sankha93 (Instantbir@EA7EC93C.6957C8B2.8B6C1D65.IP) (Quit: Instantbird 1.4 -- http://www.instantbird.com)
[04:45:21] <bjz> yeah, I found https://github.com/MarkJr94/rust_curl
[04:45:26] <dcolish> there's rust-http-lib, but thats a bit more than you'd probably want
[04:45:43] <strcat> also curl programs write themselves
[04:45:55] <bjz> I just want to grab an xml from a cvs repo
[04:46:20] <strcat> tip: curl --libcurl foo.c http://www.google.com [and whatever else you want to do]
[04:46:25] <strcat> and bam, and working C program
[04:46:29] <strcat> could port it to rust easily
[04:46:35] *** Joins: pyrac (pyrac@moz-9180E00E.w86-201.abo.wanadoo.fr)
[04:47:00] <strcat> why think when you can have curl write your software for you ;p
[04:47:02] <mcpherrin> strcat: holy shit, that is a protip
[04:47:54] <bjz> strcat: how well would that work on windows though? would it be better to link to libcurl?
[04:48:00] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[04:48:00] *** ChanServ sets mode: +o dherman
[04:48:13] * bjz shakes fist at windows
[04:48:18] * strcat shrugs
[04:48:42] <strcat> bjz: it outputs a program that links against libcurl, just saves you from having to learn an API if you know the cli util ;p
[04:48:46] <aatch> bblum, I'm setting up a snapshot now, so whatever stuff may-or-may-not have been blocked on it won't be an issue after it.
[04:49:19] <bjz> strcat: ohh
[04:50:44] <strcat> curl has lots of weird things like that ;p
[04:51:29] <dcolish> hold the phone
[04:51:34] <dcolish> thats amazing
[04:51:37] <strcat> I'm pretty sure you can combine libcurl + libuv too, so you could probably plug it into rust's event loop somehow and do async
[04:52:55] <aatch> Hmm, you know what. I think a lot of the problems we have in trans boil down to people not realizing you can get a TypeRef from a ValueRef.
[04:53:32] <strcat> aatch: symptom of using the weird C API instead of the real API too
[04:54:04] <strcat> the actual LLVM API is much more strongly typed + easier to use
[04:54:07] <aatch> strcat, yeah, I know. But still, there is no reason to have a function that takes a ValueRef /and/ a TypeRef.
[04:54:27] <aatch> strcat, I know, I've got "proper" LLVM bindings in the works.
[04:54:32] <aatch> been waiting on default methods.
[04:54:35] <strcat> ooo
[04:54:51] * dbaupp thinks aatch should be crowned king of trans
[04:55:30] <aatch> I mean, it'll be a separate library, but I don't think it would actually be that hard to integrate with the rustc tree when done.
[04:56:04] <Luqman> aatch: going from ValueRef to TypeRef as in with val_ty ? 
[04:56:41] <aatch> Luqman, yeah. There are quite a few functions that use a ty::t to get a TypeRef for a ValueRef they already have.
[04:58:19] <aatch> When they really don't need it. Like zero_mem.
[04:59:17] <bjz> strcat: there is curl_easy_setopt(CURL *curl, CURLoption option, ...)
[04:59:28] <bjz> strcat: how would I do the vararg?
[04:59:42] <aatch> bjz, you do not.
[04:59:45] <strcat> bjz: it's always 1 ptr parameter
[04:59:50] <bjz> strcat: or could I just do it with two args?
[04:59:59] <strcat> bjz: need the last arg afaik
[05:00:21] <strcat> it won't be "officially" portable but hardcoding the last arg will work on all the OSes rust runs on
[05:00:25] <strcat> because I don't think it's ever a float
[05:00:56] <bjz> oh: https://github.com/MarkJr94/rust_curl/blob/master/curl/curl.rs#L28
[05:01:20] <bjz> https://github.com/MarkJr94/rust_curl/blob/master/curl/curl.rs#L78
[05:01:28] <strcat> ideally someone would hook up curl multi to the rust event loop.
[05:02:36] *** Parts: elifrey (peripateti@moz-B5928FE2.hsd1.wa.comcast.net) (WeeChat 0.4.0)
[05:04:19] <aatch> strcat, hey, do those size hints make a noticeable speed difference?
[05:04:49] <strcat> aatch: on iterators? if we could actually use them ;p
[05:04:54] *** Quits: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net) (Quit: eholk)
[05:04:56] <strcat> aatch: it means for example...
[05:05:07] <strcat> xs.zip(ys).collect()
[05:05:10] <strcat> with 2 vectors
[05:05:14] <strcat> will be 1 alloc for the new vector
[05:05:39] <strcat> there's still a default method bug with generics
[05:05:56] <aatch> strcat, right, so because collect can't use them, it doesn't provide the benefit yet?
[05:06:04] <strcat> aatch: right
[05:06:25] <strcat> will be a transparent backwards compatible performance improvement though
[05:06:39] <dbaupp> strcat: https://github.com/mozilla/rust/pull/7356 btw
[05:06:46] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[05:06:52] *** Joins: ysuzuki (ysuzuki@moz-A563888C.ics.keio.ac.jp)
[05:06:58] <strcat> dbaupp: that's not the fix for it though
[05:07:11] <dbaupp> oh, it's a fix for something though :)
[05:07:12] <aatch> Cool, it's just that I was able to un-stage the sizehints
[05:07:17] <strcat> dbaupp: https://github.com/mozilla/rust/issues/7341
[05:07:21] <strcat> aatch: ah
[05:07:48] <strcat> aatch: in vec.rs you'll see FromIterator
[05:07:53] <strcat> and a commented out version using the size hint
[05:08:21] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[05:08:30] <aatch> uncomment it?
[05:08:47] <strcat> aatch: no, won't work :)
[05:08:52] <strcat> I just mean that it's still disabled
[05:08:59] *** Joins: ross (ross@moz-8A84103E.br.br.cox.net)
[05:10:06] <ross> <- linux newb trying to get rust-sdl working. I can't seem to compile the demo
[05:10:27] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[05:10:32] <ross> the readme on github says to run ./configure and make, which I've done. and I can run make demos, which makes a demos executable which works
[05:10:46] <bblum> aatch: don't think i had anything
[05:10:48] <bblum> but thanks
[05:11:01] <ross> but then it says I can cd to the demo directory and call rustc demo.rc, which fails because it can't find the sdl crate
[05:11:12] *** Joins: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net)
[05:11:16] *** Joins: Cromulent|2 (Cromulent@moz-983B638D.cable.virginmedia.com)
[05:11:26] <ross> so I guess that means make didn't put the library where rust can find it?
[05:11:55] *** Joins: Cromulent|3 (Cromulent@moz-983B638D.cable.virginmedia.com)
[05:12:03] *** Quits: Cromulent|3 (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: Cromulent|3)
[05:12:12] <dcolish> did the way rustpkg finds crates change in just the last week?
[05:12:41] *** Joins: eatkinson (eatkinson@moz-A7CDB794.dia.static.qwest.net)
[05:12:43] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Ping timeout)
[05:13:09] *** Quits: Cromulent|2 (Cromulent@moz-983B638D.cable.virginmedia.com) (Ping timeout)
[05:13:11] <ross> I'm not familiar enough with linux to know where I should put libraries and such
[05:15:48] <dbaupp> ross: you possibly have to tell rust where the sdl crate is
[05:15:54] *** Quits: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net) (Quit: eholk)
[05:16:03] <klutzy> if you are inside demo, run rustc with -L ..
[05:16:03] <dbaupp> ross: `rustc -L /path/to/that/directory demo.rc`
[05:16:07] *** Joins: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net)
[05:16:31] *** Quits: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net) (Quit: tikue)
[05:16:32] <ross> oh that's what -L does huh. I blindly used it from the readme but I didn't know what it was doing
[05:17:28] <ross> thank you
[05:17:34] <mark_edward> bjz: could you tell me what would make you avoid using my library
[05:18:04] <ross> oops I ran the demo over ssh
[05:18:20] <bjz> mark_edward: I guess basically I want the bare minimum. just to grab a string
[05:18:32] <mark_edward> mine can do that! right int he read me!
[05:18:58] <dcolish> mark_edward: have you tried using rustpk with your library?
[05:19:08] <mark_edward> no, what is rustpkg?
[05:19:24] <dcolish> a package manager for rust
[05:19:33] <dcolish> i guess its a lot newer than i realized
[05:19:43] <aatch> dcolish, it's not even finished...
[05:19:44] <bjz> mark_edward: I guess I kind of looked scanned the example and was a little impatient, couldn't spend the time to figure it out, because I'm a stupid user :P
[05:20:07] <bjz> mark_edward: sorry, just letting you know my thought patterns
[05:20:19] <strcat> well, this error is special
[05:20:28] <mark_edward> no worries bro. good docs are a part of the development process
[05:20:28] <aatch> strcat, hmm?
[05:20:42] *** Quits: tjc (tjc@moz-D530ECE9.lightspeed.irvnca.sbcglobal.net) (Quit: zzzzzzzzzz)
[05:20:42] <strcat> http://ix.io/6m2 from switching vec::each(xs, closure) to xs.iter().advance(closure)
[05:20:44] * strcat sighs
[05:20:44] <dcolish> aatch: true
[05:20:47] <strcat> the one error left
[05:20:49] <bjz> mark_edward: as a lib author, I concur
[05:21:01] <bjz> mark_edward: thuser is a fickle character
[05:21:06] <dcolish> mark_edward: I thought the tests were pretty clear for simple usage
[05:21:07] <bjz> :)
[05:21:17] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[05:21:18] <strcat> http://ix.io/6m3 :|
[05:21:21] <aatch> strcat, what are you trying to change?
[05:21:30] <bjz> dcolish: as I say, users are stupid, like me
[05:21:35] <strcat> aatch: I was just finishing killing off vec::each
[05:21:38] <aatch> Ugh.
[05:21:41] <strcat> found a type inference bug
[05:21:44] *** Joins: tjc (tjc@moz-D530ECE9.lightspeed.irvnca.sbcglobal.net)
[05:21:44] *** ChanServ sets mode: +o tjc
[05:21:45] <strcat> new one
[05:21:50] <bjz> mark_edward: I think I tried looking for an example folder
[05:22:00] *** Quits: tjc (tjc@moz-D530ECE9.lightspeed.irvnca.sbcglobal.net) (Quit: Places to go, people to annoy)
[05:22:01] <bjz> mark_edward: maybe one of those might help
[05:22:08] <dcolish> bjz: check out the tests
[05:22:27] <mark_edward> yah
[05:22:33] <bjz> dcolish: where?
[05:22:44] <dcolish> https://github.com/MarkJr94/rust_curl/blob/master/curl/curl.rs#L178
[05:22:49] <bjz> dcolish: in the root dir?
[05:22:53] <aatch> mark_edward, from my perspective, something like a curl library should have a one-liner for getting the body of a page as a string.
[05:23:10] <shachaf> Is there a standard style for qualified or unqualified (i.e. ::*) imports?
[05:23:10] <mark_edward> aatch: right, makes sense
[05:23:14] <bjz> mark_edward: they should go in an example folder
[05:23:19] <dcolish> aatch: there's a wrapped up http_client too in the lib
[05:23:20] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[05:23:22] <aatch> something like `let body = curl::get_string("http://www.google.com");`
[05:23:33] <strcat> or...
[05:23:38] <bjz> mark_edward: a stupid user isn't going to look in the tests
[05:23:49] <bjz> mark_edward: :)
[05:23:52] <strcat> curl::get(url).to_str()
[05:23:58] <mark_edward> nost certainly.
[05:24:02] <aatch> That works too.
[05:24:10] <aatch> but it should be small enough to fit in the README
[05:24:14] <bjz> mark_edward:  yep, what aatch said
[05:24:16] <mark_edward> i really, really, appreciate this sort of advice guys
[05:24:29] <dcolish> idk, i think the readme does a pretty good job
[05:24:39] <dcolish> maybe the first example could be simplified more?
[05:24:45] * strcat is spoiled by requests
[05:25:01] <dcolish> requests has issues because it simplifies so much
[05:25:03] <bjz> mark_edward: if it was curl::get_str("http://foo.com/bar.xml"), I'd use it in a flash
[05:25:08] <strcat> dcolish: what issues?
[05:25:15] <dcolish> for example, it unicodes urls
[05:25:20] <bjz> mark_edward: any more complex stuff is icing
[05:25:25] <mark_edward> i can do that...
[05:25:28] <dcolish> i think it goes too far to hide things
[05:25:45] <strcat> are there any valid urls that aren't unicode?
[05:25:59] <bjz> mark_edward: I mean, the more in depth things are important though, don't get me wrong :)
[05:26:03] <mark_edward> 0x00000000.com
[05:26:07] <sp3d> valid urls are a subset of ascii afaik
[05:26:14] <mark_edward> bjz:  i understand
[05:26:27] <dcolish> there are times when that encoding will double encode bytes
[05:26:34] <bjz> mark_edward: could you let me know?
[05:26:41] <bjz> mark_edward: when you fix it?
[05:26:45] <dcolish> python's unicode is special
[05:26:51] <aatch> Not all libraries are created equal. I don't have to provide some super-simple API for llvm-rs because there is no way you'd ever be able to /anything/ useful with it.
[05:26:56] <bjz> mark_edward: I'd love to use it for my gl bindings
[05:27:06] <mark_edward> sure. im actually going to work on it now, so... it might be soon. i'll try adding an exmaples folder too
[05:27:13] <dcolish> i also dont like how requests makes every thing part of kwargs
[05:27:24] <dcolish> that's hard to document in production code, imho
[05:27:25] <bjz> mark_edward: thanks!
[05:27:44] <dcolish> i'm more of a fan of builders than kwargs
[05:28:37] <aatch> But somebody using a curl library might be doing anything from what bjz here is doing (grabbing a single page from a fixed site) to writing a web crawler that needs control over the process in order to get efficiency.
[05:28:47] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[05:28:55] <strcat> if they're writing a web crawler, curl_easy_* isn't what they want
[05:29:03] <strcat> they want curl multi + an event loop
[05:29:08] <dbaupp> bjz: you could shell out to curl for now, right?
[05:29:20] <strcat> dbaupp: our process calling APIs suck
[05:29:42] <dbaupp> strcat: it's good enough for grabbing a fixed url
[05:29:54] <mark_edward> well curl_easy is fully exposed
[05:30:04] <mark_edward> i can try adding curl_multi as a bigger project
[05:30:15] <dcolish> process_output("curl",...) would work
[05:30:24] <dbaupp> strcat: (it also has the distinction of being one of the few places that doesn't incorrectly assume utf8.)
[05:30:28] <aatch> mark_edward, probably be best to wait until the new scheduler runs.
[05:30:34] <mark_edward> right
[05:30:34] <aatch> s/runs/lands
[05:30:42] <bjz> dbaupp: I was doing that, but I think I'll wait for mark_edward
[05:30:45] <aatch> then you can implement it properly.
[05:32:28] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[05:32:52] <bjz> aatch: get_str wouldn't be too hard in the short term though
[05:32:59] <dcolish> are there expected failures with the rusti testsuite?
[05:33:07] *** Joins: seth (seth@moz-D840E602.dsl.static.sonic.net)
[05:33:16] <bjz> dcolish: yes
[05:33:22] <bjz> dcolish: oh wait
[05:33:27] <bjz> dcolish: not sure
[05:33:33] <dbaupp> aatch: should I put a priority on the snap PR?
[05:33:40] <mark_edward> what do you guys use to code rust
[05:33:50] <dcolish> https://gist.github.com/dcolish/5856148
[05:33:53] <dcolish> mark_edward: emacs
[05:33:53] <bjz> mark_edward: sublime text
[05:33:57] <mark_edward> i've been using vim and gedit, but i really would liek to use geany
[05:34:06] <mark_edward> but i cant find support for it
[05:34:08] <dbaupp> mark_edward: emacs and vim seem to be pretty common
[05:34:08] <aatch> dbaupp, would be nice, less likely to get a conflict that way
[05:34:10] <mark_edward> bjz: is sublime free
[05:34:19] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[05:34:20] <dcolish> nope
[05:34:23] <mark_edward> dcolish: i have nightmares from emacs
[05:34:24] <bjz> mark_edward: no
[05:34:28] <mark_edward> :-( ok
[05:34:33] <bjz> mark_edward: still haven't paid though
[05:34:36] <dcolish> mark_edward: sux
[05:34:40] <bjz> mark_edward: it just nags you
[05:34:53] <dbaupp> aatch: done!
[05:34:55] <bjz> mark_edward: and makes you feel bad
[05:34:59] <aatch> dbaupp, thanks
[05:35:08] <bjz> mark_edward: I really should though, it's very nice
[05:35:08] <mark_edward> i see. i have enough guilt in my life.
[05:35:11] *** Quits: seth (seth@moz-D840E602.dsl.static.sonic.net) (Ping timeout)
[05:35:19] <mark_edward> i'll wait until my paycheck
[05:35:35] <bjz> mark_edward: the nag is rare though
[05:35:49] <dbaupp> bjz: does ST have rust syntax highlighting?
[05:35:52] * strcat is perfectly happy with vim
[05:35:58] <bjz> dbaupp: yah
[05:36:17] <strcat> there's a js text editor with rust syntax highlighting + code folding + snippets so...
[05:36:39] <aatch> dbaupp, and fortunately the current build going through won't conflict
[05:36:40] <bjz> dbaupp: https://github.com/dbp/sublime-rust
[05:36:56] <dbaupp> strcat: (js text editor supported by mozilla, with involvement from pcwalton)
[05:37:21] <dcolish> mark_edward: https://github.com/mozilla/rust/wiki/Doc-packages%2C-editors%2C-and-other-tools#editors
[05:37:26] <dbaupp> bjz: wow, it's extensive
[05:37:41] <bjz> dbaupp: I helped :)
[05:37:56] <bjz> dbaupp: still need to update some of the snippets though
[05:38:08] <strcat> it really has a snippet for Some? wat ;p
[05:39:04] <dcolish> and the trigger is Some
[05:39:57] <bjz> just works with the autocomplete
[05:41:12] <strcat> librustc needs a semantic completion engine :(
[05:41:22] <bjz> strcat: aye
[05:41:23] *** Joins: balpert (balpert@moz-7E5ED302.members.linode.com)
[05:41:35] <bjz> strcat: so we can hook it up to editors nicely
[05:41:51] <strcat> like libclang's
[05:42:00] * strcat has nice semantic completion for C/C++
[05:42:01] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[05:42:07] <strcat> and quick fix support
[05:42:22] <bjz> yeah, I think that's partly because xcode needed it
[05:42:23] *** Joins: xymostech (xymostech@22A34502.AFC2BCFF.2CFD4520.IP)
[05:42:26] <strcat> clang can give suggestions for errors on lines you already typed
[05:42:29] <strcat> etc.
[05:42:36] <strcat> works well from vim
[05:43:29] <bjz> http://val.markovic.io/blog/youcompleteme-a-fast-as-you-type-fuzzy-search-code-completion-engine-for-vim
[05:43:37] <strcat> yep
[05:43:44] *** Joins: sankha93 (Instantbir@EA7EC93C.6957C8B2.8B6C1D65.IP)
[05:44:12] <strcat> more advanced since that blog post ;p
[05:44:21] <bjz> would be nice to have rustdoc integration too, like with eclipse
[05:44:42] <strcat> bjz: yep, libclang also does that btw
[05:44:44] <strcat> it can fetch doxygen strings
[05:44:50] <bjz> nice!
[05:44:50] <strcat> youcompleteme doesn't have support yet :(
[05:44:51] <strcat> open bug
[05:45:11] <Jeaye> strcat: You have context sensitive completion in Vim?
[05:45:22] <strcat> Jeaye: yes
[05:45:26] <strcat> Jeaye: http://valloric.github.io/YouCompleteMe/
[05:45:30] <Jeaye> I want! :D
[05:45:41] <Jeaye> strcat: Wait, for Rust?
[05:45:47] <strcat> Jeaye: no ;p
[05:45:47] <Jeaye> I already got that shit for C++
[05:45:57] * strcat just has crappy fuzzy identifier complete for rust
[05:45:58] <Jeaye> Oh, then I don't care. :(
[05:46:07] <Jeaye> I remember using YouCompleteMe for a while.
[05:46:22] <Jeaye> I recall going back to ctags, since it was less hassle.
[05:46:22] <bjz> strcat: so yeah, I dunno if it would be possible to do something so it could work with sublime, vim, emacs, VS, eclipse etc..
[05:46:43] <bjz> strcat: ie. people could hook into it
[05:46:46] <strcat> bjz: well libclang's solution works but it's low-level-ish
[05:46:47] <dcolish> go has a completer like that
[05:46:50] <strcat> bjz: https://github.com/nsf/gocode look at this awesome thing
[05:47:07] <bjz> aye
[05:47:13] <bjz> seen that before
[05:47:21] <dcolish> yeah thats it
[05:47:27] <dcolish> do want
[05:47:44] <strcat> more complicated in rust
[05:47:45] <bjz> tooling is super important
[05:47:48] <bjz> yeah
[05:47:58] <bjz> go is easy and fast to compile
[05:48:00] <strcat> HM-like type inference for one thing
[05:48:03] <shachaf> rusti: std::os::errno() = 0;
[05:48:07] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/SZWY
[05:48:09] <strcat> in C, Go and C++ you know the type from the RHS expression
[05:48:11] <strcat> always
[05:48:19] <shachaf> Of course setting the return value of errno() doesn't make any sense.
[05:48:19] <strcat> Go and C++ have inference from the RHS only
[05:48:27] <shachaf> But an internal compiler error is probably not right.
[05:48:41] <Jeaye> ICE!
[05:48:49] <shachaf> (Is there a version of errno() that lets me set it in the standard library?)
[05:49:47] <strcat> shachaf: need to set it to zero before a call or something?
[05:49:57] <shachaf> strcat: Yep.
[05:49:57] * strcat doesn't think there is
[05:50:08] <Luqman> shachaf: there's errno_location but you can't really use it
[05:50:21] *** Quits: pyrac (pyrac@moz-9180E00E.w86-201.abo.wanadoo.fr) (Quit: pyrac)
[05:50:33] <shachaf> strcat: (Because of glibc's awful wrapper around ptrace. :-( Worse than the raw syscall!)
[05:50:38] <shachaf> Luqman: Why not?
[05:50:52] <Jeaye> strcat: tags work well enough with rust though; jumping to a mehtod declaration, etc. works just fine.
[05:50:52] <strcat> shachaf: just use the raw syscall then ;p
[05:50:53] <shachaf> Do you just mean that it's not exported, or would it be broken to use it or something?
[05:51:06] <strcat> via syscall()
[05:51:14] <Luqman> shachaf: cause it's an inner function in the body of the linux/mac/android version of os::errno :P
[05:51:18] <shachaf> strcat: I suspect that's more trouble and less portable than just wrapping the libc call to handle the extra case.
[05:51:31] <shachaf> Luqman: OK.
[05:52:03] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzz)
[05:52:12] <shachaf> I'd be worried about a task context switch causing trouble here, but I guess tasks are coperative so it should be OK.
[05:52:19] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[05:52:32] <strcat> shachaf: yeah there's no preempt
[05:52:42] <strcat> within threads at least
[05:53:29] <strcat> so you mostly don't have to worry about a task switch wiping out the thread-local errno
[05:53:49] <strcat> just can't call anything that yields.
[05:54:01] <shachaf> Right.
[05:54:18] <shachaf> The GHC solution to this problem is to special-case errno and make it part of the thread state object. :-(
[05:54:46] <mark_edward> strcat: what happend to string::substr
[05:54:53] <strcat> what did it do?
[05:55:19] <mark_edward> error: type `~str` does not implement any method in scope named `substr`
[05:55:29] <strcat> yeah but what did it do
[05:55:46] <aatch> hurrah, I can now have a strongly-typed LLVM wrapper!
[05:55:55] <strcat> there are a few forms of slice
[05:56:27] <mark_edward> oh
[05:57:03] <mark_edward> it gave you a substring and the type was &str i believe
[05:57:09] <strcat> well that';s what slice does
[05:57:43] <strcat> heh I screwed up -W and -Z in the rustc zsh complete
[05:57:46] <strcat> it thinks they take N args
[05:57:49] * strcat sighs
[05:58:45] <strcat> this is a really awful type inference bug
[05:58:55] <acrichto> aatch: when I removed the import of Map at https://github.com/Aatch/rust/commit/6ad31ffb53f9620f9063cb441de9c7338dfbb4de#L5L21 I had to add the import into the tests module to get the tests to pass
[05:59:17] <shachaf> Do people tend to prefer "{ ...; x }" to "{ ...; return x; }"?
[05:59:23] <strcat> shachaf: yes
[05:59:26] <strcat> in fact....
[05:59:30] <aatch> acrichto, ugh. dammit.
[05:59:32] <xymostech> Hello folks, I'm running into a weird problem with moving owned stuff in a loop
[05:59:33] <strcat> acrichto: how about making redundant returns a lint warning :)
[05:59:40] <xymostech> Here's a gist of the problem: https://gist.github.com/xymostech/5856233
[05:59:47] <acrichto> strcat: redundant lints?
[05:59:49] *** Joins: pyrac (pyrac@moz-9180E00E.w86-201.abo.wanadoo.fr)
[05:59:57] <aatch> xymostech, yes
[06:00:00] <mark_edward> bjz
[06:00:07] <strcat> acrichto: well 'return x' at the end of a function block
[06:00:15] <aatch> that's expected
[06:00:22] <mark_edward> would you like the get method to retun an empty vector in case of error, or have a Result enum?
[06:00:33] <acrichto> strcat: I really like 'return x' at the end of a long block
[06:00:42] <aatch> xymostech, you're moving it, in a loop. After the first iteration, it's moved, so the second one doesn't work
[06:00:45] <bjz> mark_edward: Result is more ideomatic
[06:00:54] <xymostech> I get that
[06:00:59] <strcat> acrichto: but you know it's a return from it being at the end ;p
[06:01:04] <xymostech> But I'm trying to re-assign it back into the variable
[06:01:13] <strcat> arc.rs:798:16: 798:17 error: cannot determine a type for this bounded type parameter: unconstrained type
[06:01:14] <strcat> arc.rs:798                 };
[06:01:17] <strcat>                            ^
[06:01:22] <xymostech> I can do weird things like let (n) = ...; num = n;
[06:01:22] <strcat> has to be the worst error I've ever seen
[06:01:28] <xymostech> And it works, but that's kinda ugly
[06:01:35] <strcat> http://ix.io/6m8 it points at the brace at the end
[06:01:37] <strcat> wat?
[06:01:39] <aatch> pattern matching doesn't work like that though.
[06:02:02] <aatch> you have to have a let for it.
[06:02:14] <xymostech> Okay
[06:02:26] <strcat> infer the stupid types rustc :(
[06:02:31] <aatch> xymostech, in that, (num) is an lvalue expression.
[06:02:32] * strcat doesn't know what it wants
[06:03:33] <aatch> acrichto, so just add use container::Map to the test mod?
[06:03:38] *** Quits: pyrac (pyrac@moz-9180E00E.w86-201.abo.wanadoo.fr) (Quit: pyrac)
[06:03:51] <acrichto> aatch: yeah that made them pass for me
[06:04:05] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[06:04:09] <acrichto> aatch: https://github.com/mozilla/rust/pull/7113/files#L23L16
[06:04:34] <xymostech> So is there a way to pattern match and assign to the old variable at the same time?
[06:04:47] <strcat> acrichto: or 'use prelude::*;'
[06:04:50] <strcat> in the libstd tests
[06:05:01] <strcat> won't make cycles like it will at module-scope
[06:05:03] <acrichto> strcat: that would indeed work as well
[06:05:10] *** Quits: brson (brson@5F06B402.AD1E507F.3688B332.IP) (Quit: leaving)
[06:05:19] <acrichto> I really want "-A warnings" when compiling tests for rustc
[06:05:24] <acrichto> or really just the entire compiler
[06:05:44] <strcat> meh
[06:05:49] <strcat> I don't feel like reporting yet another bug :[
[06:06:27] <acrichto> whoa, so cmr r+'d the last commit on https://github.com/mozilla/rust/pull/7371 on a different pull reuqest, and I just submitted that pull request new and it pulled the r+ over
[06:06:42] <strcat> acrichto: yeah they're attached to the commit
[06:06:44] <acrichto> I wonder if it'll show up in bors...
[06:06:57] <strcat> acrichto: it should
[06:07:00] <strcat> if it's the last commit
[06:07:08] <acrichto> just a little odd
[06:07:09] <shachaf> Is there a general-purpose sum type, like there's a general purpose tuple?
[06:07:13] <acrichto> but makes sense
[06:07:14] <strcat> shachaf: enum
[06:07:26] <shachaf> strcat: That requires me to define my own type.
[06:07:48] <strcat> shachaf: Either?
[06:08:04] <shachaf> Oh, Either exists?
[06:08:08] <strcat> yep
[06:08:12] <strcat> std::either
[06:08:12] * shachaf should've searched for that name.
[06:08:17] <shachaf> OK then.
[06:08:33] <strcat> Either/Left/Right are in the prelude though
[06:08:34] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[06:09:57] <acrichto> oh man if we could get a snapshot every 2 days...
[06:10:33] <aatch> acrichto, I'm planning on doing one every week or so if I can get away with it.
[06:11:09] <xymostech> aatch, I updated the gist, now things are actually tuples...
[06:11:24] *** Joins: xazax_hun (Mibbit@6655692F.3B222813.3F580572.IP)
[06:11:26] <acrichto> aatch: !!
[06:11:45] <shachaf> Hmm, can I import a C FFI function by a name other than its C name?
[06:12:15] <Aetherspawn> You mean like, by its ordinal?
[06:12:16] <aatch> shachaf, you can use #[link_name] to tell the linker to use a different name, if that's what you mean?
[06:12:44] <Aetherspawn> also woot for having the master of haskell himself here. :P
[06:12:59] <xazax_hun> who? :D
[06:13:00] *** Quits: Earnestly (earnest@639E83C4.94D0CBFF.5411983D.IP) (Ping timeout)
[06:13:07] <shachaf> aatch: Ah, OK.
[06:13:09] *** Quits: ysuzuki (ysuzuki@moz-A563888C.ics.keio.ac.jp) (Client exited)
[06:13:16] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[06:13:16] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/5PqiCA
[06:13:16] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[06:14:52] *** Joins: brson (brson@5F06B402.AD1E507F.3688B332.IP)
[06:14:52] *** ChanServ sets mode: +o brson
[06:16:18] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[06:16:18] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/lGZkOg
[06:16:18] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[06:16:25] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[06:16:26] <ghrust> 01[13rust01] 15bors pushed 5 new commits to 06auto: 02http://git.io/uc9Bag
[06:16:26] <ghrust> 13rust/06auto 142afdf0d 15James Miller: Update snapshots file
[06:16:26] <ghrust> 13rust/06auto 14caa50ce 15James Miller: Remove stage0 cfgs
[06:16:26] <ghrust> 13rust/06auto 146ad31ff 15James Miller: Warning police
[06:16:26] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[06:17:11] <brson> is Copy going to be removed?
[06:18:08] <strcat> brson: I think so
[06:18:33] <strcat> Clone isn't a fully complete replacement yet because it doesn't work for fixed-size arrays
[06:18:49] <strcat> we don't have a way to write a generic impl for them
[06:18:59] <xymostech> I'm confused why I can move move something somesomi231111
[06:19:04] *** Quits: tcsc (tcsc@moz-ADC0ED45.hsd1.ct.comcast.net) (Quit: bye!)
[06:19:41] <aatch> Well that's impressive.
[06:19:48] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[06:21:56] <dbaupp> mark_edward: substr was confusing, so I removed it (pop quiz, what did each of the two arguments mean?)
[06:22:17] <mark_edward> begin index, last index, (inclusive exclusive)?
[06:22:20] <strcat> https://github.com/mozilla/rust/issues/7372 worst bug report ever made
[06:22:22] <strcat> ;p
[06:23:15] <dbaupp> mark_edward: nope... byte index, character count (i.e. unicode codepoints)
[06:23:22] <mark_edward> wtf...
[06:23:32] <dbaupp> mark_edward: (most of the uses in the libraries/rustc made similar mistakes)
[06:23:42] <dbaupp> yeah, so you want .slice()
[06:23:43] <mark_edward> oh ok. btw can you have a mutable static?
[06:23:48] <mark_edward> thanks db
[06:23:53] <dbaupp> almost
[06:24:06] <mark_edward> almost?
[06:24:06] <strcat> and it will be a feature limited to unsafe blocks
[06:24:10] <dbaupp> acrichto has a PR that implements `static mut`, but they are unsafe and should be avoid
[06:24:16] <dbaupp> *avoided
[06:24:24] <dbaupp> (as much as possible)
[06:25:26] *** Joins: roo (jesse.rudo@moz-9EBD7E45.dynamic.ip.windstream.net)
[06:26:43] <strcat> dbaupp: https://github.com/mozilla/rust/pull/7373 probably going to tack on more commits to that PR, but it should make you happy ;p
[06:27:14] <strcat> % git grep '\.each ' | wc -l
[06:27:14] <strcat> 40
[06:27:22] <strcat> % git grep '\.advance ' | wc -l
[06:27:23] <strcat> 1104
[06:27:36] <dbaupp> strcat: yay!
[06:27:51] <dbaupp> (I won't bother r+ing then)
[06:27:53] <strcat> need a new 
[06:27:56] <strcat> 'for' so badly 
[06:28:26] * strcat thinks it will hit a codegen bug on OS X anyway
[06:28:45] *** Joins: ysuzuki (ysuzuki@moz-3830D141.st.keio.ac.jp)
[06:28:47] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[06:28:47] <ghrust> 01[13rust01] 15thestinger 04force-pushed 06try from 140efc7bd to 1475bf7e2: 02http://git.io/k471pw
[06:28:47] <ghrust> 13rust/06try 1475bf7e2 15Daniel Micay: remove `each` from vec, HashMap and HashSet
[06:28:47] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[06:29:14] <dbaupp> strcat: implement it? (or even just implement for_! that expands to the right thing, to use temporarily)
[06:29:30] <strcat> dbaupp: meh
[06:29:37] <strcat> well
[06:30:39] *** Quits: ysuzuki (ysuzuki@moz-3830D141.st.keio.ac.jp) (No route to host)
[06:30:47] *** Joins: ysuzuki (ysuzuki@moz-A563888C.ics.keio.ac.jp)
[06:31:19] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[06:31:40] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[06:31:55] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[06:32:01] <strcat> dbaupp: the syntax would be weird
[06:32:12] <strcat> I don't think it would be *that* hard to replace 'for'
[06:32:26] <strcat> for foo.iter() { }
[06:32:29] <strcat> just has to compile like
[06:32:46] <dbaupp> strcat: (you should get rusti back online ;) )
[06:32:59] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[06:33:25] <strcat> let mut it = foo.iter(); loop { match it.next() { None => break, Some(/* pattern */) => { /* loop body */ } } }
[06:33:27] <dbaupp> rusti: macro_rules! for_ ( ($e:expr, $p:pat, $b:expr) => {{ let mut __it = $e; loop { match __it.next() { None => break, Some($p) => $b } } }}) let v = [1i,2]; for_!(v.iter(), i, { println(i.to_str()) })
[06:33:29] -rusti- 1
[06:33:29] -rusti- 2
[06:33:29] -rusti- ()
[06:33:34] <brson> I don't have many language changes in the release notes. surely we're missing something: https://github.com/mozilla/rust/blob/master/RELEASES.txt
[06:33:59] <strcat> brson: pcwalton has a whole queue of things to land
[06:34:19] <strcat> Owned -> Send, Const -> Freeze among others
[06:34:23] <dbaupp> brson: generics with a Copy bound now need and explicit `copy foo`
[06:34:57] <dbaupp> rusti: macro_rules! for_ ( ($e:expr, $p:pat, $b:expr) => {{ let mut __it = $e; loop { match __it.next() { None => break, Some($p) => $b } } }}) let v = [1i,2]; for_!(v.iter().enumerate(), (i, x), { println(fmt!("%d %d", i, x)) })
[06:34:59] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/IYEg
[06:35:11] <dbaupp> rusti: macro_rules! for_ ( ($e:expr, $p:pat, $b:expr) => {{ let mut __it = $e; loop { match __it.next() { None => break, Some($p) => $b } } }}) let v = [1i,2]; for_!(v.iter().enumerate(), (i, x), { println(fmt!("%u %d", i, x)) })
[06:35:12] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/ZBiT
[06:35:30] <dbaupp> rusti: macro_rules! for_ ( ($e:expr, $p:pat, $b:expr) => {{ let mut __it = $e; loop { match __it.next() { None => break, Some($p) => $b } } }}) let v = [1i,2]; for_!(v.iter().enumerate(), (i, &x), { println(fmt!("%u %d", i, x)) })
[06:35:31] -rusti- 0 1
[06:35:31] -rusti- 1 2
[06:35:32] -rusti- ()
[06:35:44] <strcat> dbaupp: I just think it would be better to fix 'for' ASAP
[06:35:44] *** Quits: roo (jesse.rudo@moz-9EBD7E45.dynamic.ip.windstream.net) (Ping timeout)
[06:35:55] <dbaupp> strcat: yes
[06:36:19] *** Quits: xazax_hun (Mibbit@6655692F.3B222813.3F580572.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[06:36:36] <shachaf> Does 'a have a special significant in the syntax or is it just a type variable?
[06:36:54] <strcat> shachaf: a lifetime, called a
[06:37:17] <strcat> for example
[06:37:39] <strcat> fn head<'a, T>(xs: &'a [T]) -> &'a T { ... }
[06:37:52] <strcat> the return value has the same lifetime as the passed in slice
[06:38:11] <strcat> so you can keep it around as long as the slice you passed in
[06:38:57] <shachaf> Ah, OK.
[06:39:10] <shachaf> I should just read the full reference manual...
[06:39:22] <strcat> shachaf: it's not really a 'full' one ;p
[06:39:41] <strcat> and it's somewhat out-of-date
[06:39:43] *** Quits: ysuzuki (ysuzuki@moz-A563888C.ics.keio.ac.jp) (Ping timeout)
[06:40:02] <strcat> shachaf: http://static.rust-lang.org/doc/tutorial-borrowed-ptr.html
[06:40:24] *** Joins: ysuzuki (ysuzuki@moz-A563888C.ics.keio.ac.jp)
[06:40:31] <kimundi> shachaf: If you got the 'a from a error message, there is also the change that it's some legacy cruft that has nothing todo with lifetimes
[06:40:34] <Jeaye> Never made a PR for Rust before. Scary. >.<
[06:40:36] *** Joins: roo (jesse.rudo@moz-EFE08125.dynamic.ip.windstream.net)
[06:41:11] <shachaf> strcat: Ah, thanks.
[06:41:17] <Jeaye> Let's get this in master, mmk? https://github.com/mozilla/rust/pull/7374
[06:41:40] <strcat> what does rustFuncCall actually match?
[06:41:48] <strcat> seems like we have ambiguity there
[06:42:05] <strcat> Variant(foo) vs Function(foo) (since we don't enforce case)
[06:42:16] * shachaf is trying to figure out the incantation for casting a struct to a *mut c_void for the FFI... Does it need to involve cast::transmute?
[06:42:21] <strcat> or NamedTuple(1, 2, 3)
[06:42:33] <strcat> shachaf: borrowed pointers will coerce to raw pointers
[06:42:35] <strcat> implicitly
[06:42:52] <strcat> the unsafe line is drawn at dereferencing them
[06:43:07] <strcat> so
[06:43:21] <dbaupp> also, `rustFuncCall    "\w\(\w\)*::<"he=e-3,me=e-3` is incorrect, since None::<int> is perfectly valid.
[06:43:22] <strcat> rusti: let mut x = 5; let y: *mut int = &mut x; y
[06:43:23] -rusti- 28196752
[06:43:34] <strcat> rusti: let mut x = 5; let y: *mut int = &mut x; y as *libc::c_void
[06:43:35] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/LQHe
[06:43:42] <strcat> rusti: let mut x = 5; let y: *mut int = &mut x; y as *mut libc::c_void
[06:43:44] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/NQPg
[06:43:50] <strcat> rusti: let mut x = 5; let y: *mut int = &mut x; y as *mut std::libc::c_void
[06:43:52] -rusti- 14983056
[06:45:15] *** Joins: pyrac (pyrac@EDE6BD92.73C89388.AD05C589.IP)
[06:45:57] *** Quits: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Ping timeout)
[06:46:01] <shachaf> (Why do I get :31:0: 31:16 error: expected `;` or `}` after expression but found `assert_encodable when I type that into my rusti? Is that a bug or am I doing something wrong?)
[06:46:47] <dbaupp> shachaf: did you leave a ; off the end of a let statement?
[06:47:56] <shachaf> I copied what strcat just wrote.
[06:48:48] *** Quits: timot (timot@58CC50AE.F194A95C.898DC978.IP) (Ping timeout)
[06:48:48] <acrichto> shachaf: you've found a bug in rusti!
[06:49:13] <strcat> dbaupp: : we could temporarily remove for loops from the language
[06:49:33] <dbaupp> strcat: that... would be a horrible change
[06:49:37] <strcat> migrate the remaining users to 'do' or a syntax ext for external iterators I mean
[06:49:39] <strcat> and then add them back
[06:49:53] * shachaf heard a rumour rust was nearly stable...
[06:50:01] <strcat> shachaf: rusti isn't
[06:50:02] <dbaupp> shachaf: heard wrong ;)
[06:50:04] <aatch> shachaf, you heard wrong.
[06:50:09] <shachaf> OK then.
[06:50:17] <aatch> You may have heard it was "stabilizing"
[06:50:26] <aatch> But that is a relative term.
[06:50:33] <strcat> dbaupp: I don't mean forever ;p
[06:50:39] <shachaf> It was a second-hand rumor.
[06:50:49] <aatch> Breaking changes now average like 1 a week instead of 3-4
[06:50:52] <dbaupp> shachaf: syntax is hopefully stable(ish), semantics are maybe starting to get stable, and libraries are not even close
[06:51:03] <dbaupp> strcat: yes
[06:51:20] <dbaupp> strcat: even so, so much code would be #[cfg(stage0)]'d
[06:51:27] <strcat> dbaupp: don't think so
[06:51:29] <strcat> we can migrate them all
[06:51:52] <dbaupp> hmm... maybe
[06:52:07] <strcat> if we use a macro and not a syntax ext
[06:52:28] <dbaupp> (it's probably best to do it after 0.7, if we can't re-add them back in time, because that'd scare everyone away from Rust)
[06:52:32] *** Quits: H4199 (chatzilla@moz-64E556D3.austin.res.rr.com) (Ping timeout)
[06:52:43] <strcat> I feel like .advance is going to scare everyone away from rust
[06:52:47] <shachaf> What do I do about a "use of possibly uninitialized value" when I mean to initialize it by passing a pointer to a C function that'll write to it?
[06:52:53] <mark_edward> how do you make doc comments again
[06:53:04] <dbaupp> strcat: we'd have to define the macro in each module
[06:53:09] <dbaupp> s/module/crate
[06:53:14] <strcat> shachaf: use the 'uninit' intrinsic from std::unstable::intrinsics
[06:53:17] <aatch> shachaf, there is an uninit() intrinsic
[06:53:24] <aatch> it's just a no-op
[06:53:28] <dbaupp> mark_edward: `///` or `/**`
[06:53:36] <shachaf> Ah, OK.
[06:53:57] <aatch> shachaf, made pretty much for this purpose :D
[06:54:14] <dbaupp> strcat: .advance isn't as bad as not having a for loop
[06:54:33] * strcat shrugs
[06:54:33] *** Quits: eatkinson (eatkinson@moz-A7CDB794.dia.static.qwest.net) (Quit: eatkinson)
[06:54:37] <strcat> we can have for! in the meantime
[06:54:54] *** Quits: roo (jesse.rudo@moz-EFE08125.dynamic.ip.windstream.net) (Ping timeout)
[06:55:15] <strcat> meh
[06:55:20] <dbaupp> can't be called `for` without removing that as a keyword
[06:55:20] <strcat> not enough mac builders for me to use try
[06:55:51] <strcat> dbaupp: the macro can be 'for_', the syntax ext would be for!
[06:55:57] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[06:56:00] *** Joins: roo (jesse.rudo@moz-8AB777B9.ip.windstream.net)
[06:56:03] <strcat> oh well
[06:56:10] * strcat doesn't know how hard it would be to replace
[06:56:21] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[06:56:26] <dbaupp> strcat: I'm not sure I understand... the parser wouldn't accept `for!(...)` even if it's a syntax extension
[06:56:26] <shachaf> strcat: Do I have to cast in two steps or something? If I have let mut x: foo;, &mut x as *mut c_void seems to be a type mismatch.
[06:56:39] <strcat> shachaf: yeah, two steps
[06:56:47] <strcat> &mut T will coerce to *mut T
[06:57:17] <strcat> the little annoyances of FFI ;p
[06:57:35] <acrichto> r? https://github.com/mozilla/rust/pull/7376
[06:57:45] <shachaf> So, what, (&mut x as *mut T) as *mut c_void?
[06:57:54] <shachaf> I guess the parentheses aren't required here.
[06:57:58] <strcat> acrichto: r+
[06:58:10] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[06:58:12] <strcat> shachaf: yeah, without parens
[06:58:44] *** Joins: barosl (barosl@E287D94F.C81E10FB.7544CABF.IP)
[06:59:04] <shachaf> Still pretty verbose. Oh well.
[06:59:10] <bjz> mark_edward: how did it go?
[06:59:33] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[06:59:33] <mark_edward> it's there! writing up examples, an going to try adding doc commments to everyone
[07:00:30] <strcat> dbaupp: actually can you r+ https://github.com/mozilla/rust/pull/7373 ?
[07:00:41] <strcat> dbaupp: I think it's going to fail on mac so... I don't feel like doing more yet
[07:00:59] <bjz> mark_edward: awesome!
[07:01:11] <mark_edward> bjz:  what should i do about the README? It's really technical right now
[07:01:36] <dbaupp> strcat: it doesn't add any more iterators does it? (just removes the internal ones for those that already have external ones?)
[07:01:49] <strcat> dbaupp: just removes them
[07:01:50] <bjz> mark_edward: I'm guessing you could have the most simple example near the beginning, then go more in depth
[07:01:59] <acrichto> did graydon say that he got around to limiting jobs on slaves for bors?
[07:02:05] <strcat> acrichto: yes
[07:02:15] <strcat> and there's no free mac one for try ;[
[07:02:19] <acrichto> because currently there are 4 builds on 1 linux box
[07:02:28] <acrichto> and 3 builds on one mac bot
[07:02:29] <bjz> mark_edward: don't forget you can do ~~~rust to get highlighting
[07:02:48] <mark_edward> bjz:  what do you mean?
[07:02:56] <strcat> syntax highlighted code examples
[07:02:58] <strcat> in docstrings
[07:03:01] <strcat> with an up-to-date pandoc
[07:03:17] <bjz> strcat: and on github md readmes
[07:03:31] <bjz> ~~~rust
[07:03:37] <bjz> blah blah
[07:03:38] <bjz> ~~~
[07:03:48] <dbaupp> bjz, strcat: isn't pandoc's syntax `~~~ {.rust}` ?
[07:03:53] <strcat> dbaupp: ~~~rust works too
[07:03:55] <strcat> as a shortcut
[07:03:56] <strcat> I think...
[07:04:04] <dbaupp> strcat: r+ (yay!)
[07:04:10] <dbaupp> strcat: oh, cool.
[07:04:12] <strcat> dbaupp: yup
[07:04:18] <bjz> dbaupp: that's what github uses, not sure if pandoc as well
[07:04:30] <strcat> ~~~rust
[07:04:32] <strcat> fn main() {}
[07:04:34] <strcat> ~~~
[07:04:36] <strcat> strcat@thinktank i ~/projects/rust/src iterator % pandoc foo.md
[07:04:38] <strcat> <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {}</code></pre>
[07:04:49] <bjz> dbaupp: I was talking about the readme
[07:05:03] <strcat> dbaupp: should update the ones in the rust source
[07:05:04] <strcat> minor thing.
[07:05:12] <dbaupp> strcat: yeah
[07:05:16] <dbaupp> bjz: right
[07:09:02] *** Joins: xazax (Mibbit@6655692F.3B222813.3F580572.IP)
[07:11:23] *** Quits: brson (brson@5F06B402.AD1E507F.3688B332.IP) (Quit: leaving)
[07:12:14] <shachaf> What is the standard way to get the sizeof a type? And if it's sys::size_of, how do I use that?
[07:12:42] <aatch> hmm, &Trait objects don't work properly at the moment, right?
[07:12:49] <Jeaye> rusti: sys::size_of::<int>()
[07:12:50] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/XfSE
[07:13:03] <aatch> rusti: std::sys::size_of::<int>()
[07:13:04] -rusti- 8
[07:13:12] <Jeaye> -_- grr
[07:13:13] <shachaf> Oh, everything is std::.
[07:13:14] <aatch> rusti: std::sys::size_of::<[int,..8]>()
[07:13:15] -rusti- 64
[07:13:49] <dbaupp> aatch: yeah, I think so
[07:13:59] <aatch> dbaupp, what about ~Trait
[07:14:11] <dbaupp> aatch: I think they were recently fixed
[07:14:19] <aatch> cool.
[07:14:21] <dbaupp> (well, there a was a PR... not sure if it landed)
[07:14:56] <dbaupp> rusti: std::sys::size_of_val(&(1u, "foo", 1f))
[07:14:56] -rusti- 32
[07:15:26] *** Quits: jaen (jaen@moz-9968C5CB.play-internet.pl) (Ping timeout)
[07:16:42] *** Quits: roo (jesse.rudo@moz-8AB777B9.ip.windstream.net) (Ping timeout)
[07:20:42] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[07:21:42] *** Quits: sk (sk@61A494B3.BA40E8A.AAC02D62.IP) (Quit: Leaving)
[07:22:45] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzz)
[07:24:20] <aatch> huh, looks like you can currently only have &'static traits atm.
[07:25:09] <aatch> But, it seems that they do work.
[07:25:26] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[07:26:18] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[07:26:24] *** Quits: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Quit: zzz)
[07:28:02] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[07:31:00] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[07:32:34] <aatch> This is actually pretty cool... I wonder how easy it would be to kill the wrapper structs and cast the ValueRef's to &'static Value traits.
[07:34:46] *** Joins: Palmik (palmik@moz-CC484FDD.tmcz.cz)
[07:35:39] *** kimundi is now known as zz_kimundi
[07:39:59] <mark_edward> is there a style guide on how to write doc commens in rust
[07:41:13] *** Joins: fabiand (fabiand@186696B8.BCE163C1.1A5CC7E5.IP)
[07:41:46] <shachaf> How do I link Rust and C code together? I can make .o files for both of them, but then what?
[07:42:22] <aatch> shachaf, you can use the link_args attribute, though it's a little hacky
[07:42:30] <aatch> since we use clang as a linker
[07:42:47] <aatch> actually, not as hacky as I thought...
[07:42:47] <strcat> for now ;p
[07:43:03] <aatch> since it's perfectly ok to pass a .o to ld
[07:43:09] <shachaf> Ah, rustc rust.rs --link-args c.o seems to work.
[07:43:27] <aatch> shachaf, you can also put it on the extern block in the source.
[07:43:39] <aatch> #[link_args="c.o"]
[07:43:46] <mark_edward> nvm, found it
[07:44:12] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: sleep)
[07:46:05] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[07:47:16] *** Joins: jdm (jdm@88F51059.F3BBB17D.144F44FA.IP)
[07:47:59] * shachaf sighs
[07:48:20] <shachaf> My FFI problem was that I wrote struct UserRegsStruct { r15: u64, r15: u64, r14: u63, ... }
[07:48:29] <shachaf> Shouldn't having two identical fields in a struct give a warning?
[07:48:39] <aatch> shachaf, probably
[07:48:53] <dbaupp> rusti: struct Foo { a: u8, a: u8 }
[07:48:56] -rusti- ()
[07:49:03] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[07:49:13] <dbaupp> rusti: struct Foo { a: u8, a: u8 } Foo { a: 1, a: 2 }
[07:49:13] -rusti- <anon>:9:49: 9:53 error: field `a` specified more than once
[07:49:13] -rusti- <anon>:9          struct Foo { a: u8, a: u8 } Foo { a: 1, a: 2 }
[07:49:13] -rusti-                                                           ^~~~
[07:49:14] -rusti- error: aborting due to previous error
[07:49:14] -rusti- application terminated with error code 101
[07:49:35] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[07:50:08] *** Joins: berak (chatzilla@8DFBE69A.6062171A.1A5CC7E5.IP)
[07:50:10] *** Quits: ysuzuki (ysuzuki@moz-A563888C.ics.keio.ac.jp) (Client exited)
[07:50:45] *** Quits: lucian (lucian@moz-22A14C6A.cable.virginmedia.com) (Ping timeout)
[07:51:59] <dbaupp> rusti: struct Foo { a: u8, a: u8 } Foo { a: 1 }
[07:51:59] -rusti- <anon>:9:37: 9:40 error: missing fields: 
[07:51:59] -rusti- <anon>:9          struct Foo { a: u8, a: u8 } Foo { a: 1 }
[07:51:59] -rusti-                                               ^~~
[07:52:00] -rusti- error: aborting due to previous error
[07:52:00] -rusti- application terminated with error code 101
[07:52:19] <ross> hm, rust-sdl doesn't include sdl_draw it seems
[07:52:26] <ross> I wonder how hard it would be to add
[07:53:06] *** Joins: Houm (Houm@moz-25669AA8.fbx.proxad.net)
[07:54:02] <dbaupp> shachaf: https://github.com/mozilla/rust/issues/7377
[07:54:33] <shachaf> Hooray!
[07:55:16] <shachaf> Is there some nice way to initialize a vector with (with 0s or something)?
[07:55:37] <dbaupp> what sort of vector?
[07:55:47] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Ping timeout)
[07:56:17] <dbaupp> if you know the length at compile time ~[0, .. LENGTH], otherwise std::vec::from_elem(length, 0)
[07:56:38] <shachaf> Aha.
[07:57:21] <shachaf> Do I need to specify the length twice when declaring it?
[07:57:30] <aatch> dbaupp, look at my magnificent hack: https://gist.github.com/Aatch/5856745
[07:57:41] <dbaupp> shachaf: I'm not sure I follow...
[07:57:46] <shachaf> In e.g. "let mut v: [u64, ..SIZE] = [0, ..SIZE];".
[07:57:57] *** Joins: SimonSapin (simon@moz-D0C2F181.zone2.bethere.co.uk)
[07:58:10] <dbaupp> shachaf: you can often let type inference handle it
[07:58:22] <aatch> shachaf, only if you 1) want a fixed-length vector and 2) type inference can't figure it out.
[07:58:22] <dbaupp> `let mut v = [0u64, .. SIZE]`
[07:58:30] <dbaupp> (or drop the u64 if it can infer that.)
[07:58:45] <dbaupp> aatch: is the hack using lowercase type/traits ;P
[07:58:52] <shachaf> OK.
[07:58:54] <aatch> dbaupp, heh, that was me be lazy
[07:59:13] <aatch> but it should make LLVM wrappers much, much easier to work with.
[07:59:13] <dbaupp> aatch: also, that's ridiculous... what's it for?
[07:59:25] <dbaupp> I see
[07:59:48] *** Joins: sk (sk@1696E5A5.E92B26F8.78DD174B.IP)
[07:59:52] <dbaupp> so just having a wrapper around the FFI pointers isn't good enough?
[08:00:17] <aatch> dbaupp, I could, but then I end up with dozens of identical structs.
[08:00:39] <dbaupp> and this is somehow better?
[08:00:56] <aatch> dbaupp, from the outside, it makes life much, much easier
[08:01:10] <aatch> that's just a proof-of-concept.
[08:01:16] <dbaupp> ok... I guess I'll see if/when I use llvm-rs :)
[08:01:46] <aatch> the malloc's only there so LLVM doesn't const-prop away everything.
[08:02:26] <dbaupp> yeah, presumably LLVM is normally doing the malloc internally
[08:02:42] <dbaupp> (i.e. the LLVM you are interfacing with, not the compiler's LLVM)
[08:02:52] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[08:03:22] <aatch> dbaupp, exactly, while technically using &'static isn't true, it's no worse than what's already there.
[08:03:41] *** Quits: devbug (quassel@moz-E1DE087C.bchsia.telus.net) (Connection reset by peer)
[08:03:41] <aatch> the lifetimes you work with are also falsely unbounded.
[08:04:05] <shachaf> Is there a convenient way to unsafely cast between vector types?
[08:04:17] <shachaf> e.g. `[u8, .. 264]` to `[u64, .. 33]`
[08:04:29] <dbaupp> aatch: presumably ~Trait would be better (if/when they can be cast to &Trait)
[08:04:34] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[08:04:37] <dbaupp> shachaf: std::cast::transmute
[08:04:47] <shachaf> (Probably I shouldn't be doing so many unsafe things... I'll just tell myself it's the FFI's fault.)
[08:05:08] <dbaupp> shachaf: unsafe is fun! it's the most reliable way to get segfaults! :D
[08:05:29] <aatch> dbaupp, not so sure, since in that case you'd get hundreds of 8-byte mallocs
[08:05:41] <aatch> actually, bigger
[08:05:43] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[08:05:44] <dbaupp> aatch: oh?
[08:06:01] <aatch> well ~Trait is still exchange_malloc'd
[08:06:21] <dbaupp> right
[08:06:24] * shachaf tries to figure out how to use transmute.
[08:06:53] <dbaupp> aatch: so you need "in-place" Trait objects (which is convenient, since &Trait fits perfectly)
[08:07:03] <aatch> dbaupp, exactly.
[08:07:38] <aatch> And eventually there should be traits that aren't required to be static.
[08:07:40] <dbaupp> rusti: let x: uint = 0x012030405060708; let v: [u8, .. 8] = unsafe{std::cast::transmute(x)}; v
[08:07:42] -rusti- [8, 7, 6, 5, 4, 3, 18, 0]
[08:07:54] <dbaupp> hm?
[08:07:55] *** Joins: roo (jesse.rudo@moz-47144263.dynamic.ip.windstream.net)
[08:08:05] <dbaupp> oh, I typoed
[08:08:25] <dbaupp> shachaf: ^
[08:09:01] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[08:09:13] <shachaf> Can I do use it inline and specify the target type explicitly?
[08:09:27] <dbaupp> well, type inference sometimes works
[08:09:52] <dbaupp> but yeah, you can write `transmute::<InitialType, TargetType>(x)`
[08:10:00] *** zz_kimundi is now known as kimundi
[08:10:01] <shachaf> Oh, the :: was what I was missing.
[08:10:02] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[08:10:14] <dbaupp> yup, it's required for non-ambiguity
[08:10:21] <shachaf> Right.
[08:10:36] <shachaf> There's no way to specify just the TargetType, is there?
[08:11:04] <dbaupp> nope
[08:11:09] <Luqman> let x: TargetType = transmute(foo); perhaps
[08:11:15] <shachaf> Sure.
[08:11:27] <dbaupp> although you can do `{ let tmp: T = transmute(x); tmp }` inline
[08:11:40] <shachaf> Hmm, maybe id::<T>(x)...
[08:11:48] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[08:11:51] <dbaupp> oh, that'd work too
[08:12:39] <shachaf> Seems odd that there's no type annotation syntax but I suppose this works.
[08:12:53] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[08:14:12] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[08:14:49] <aatch> Woo, new snapshot's almost landed.
[08:15:05] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[08:15:29] <mark_edward> hey guys, how do you hide the members of an opaque struct in the doc things
[08:15:49] <mark_edward> #[doc(hidden)] on the thing doesn't work
[08:16:20] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[08:16:28] <mark_edward> on the members
[08:17:10] <mark_edward> i tried it on the members,
[08:17:43] <aatch> mark_edward, it doesn't at the moment.
[08:17:47] <aatch> bug in rustdoc
[08:17:53] *** Quits: ross (ross@moz-8A84103E.br.br.cox.net) (Quit: )
[08:17:57] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[08:17:58] <aatch> it should hide members marked priv.
[08:18:16] <aatch> cmr is working on a new version
[08:18:18] <mark_edward> ok. so is there anyway to hide the members of a struct, if we don't want them seen?
[08:18:18] <mark_edward> in my case it's a wrapper over an unsafe pointer
[08:18:43] <aatch> mark_edward, like I said, members marked with priv
[08:18:52] <mark_edward> oh ok
[08:18:52] <aatch> _should_ be hidden
[08:18:56] <mark_edward> thanks for the info!
[08:19:45] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Ping timeout)
[08:20:34] *** Quits: roo (jesse.rudo@moz-47144263.dynamic.ip.windstream.net) (Ping timeout)
[08:20:47] *** Parts: berak (chatzilla@8DFBE69A.6062171A.1A5CC7E5.IP) ()
[08:21:01] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[08:21:03] *** Quits: pyrac (pyrac@EDE6BD92.73C89388.AD05C589.IP) (Quit: pyrac)
[08:21:24] <aatch> dbaupp, ok, I figured out why what I did works.
[08:21:33] <dbaupp> aatch: black magic?
[08:21:55] <dbaupp> shachaf: yeah, I agree about the type annotation stuff
[08:21:58] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[08:24:30] <dbaupp> aatch: landed!
[08:24:53] <aatch> kinda. Basically, a trait object is just a {*tydesc, *T} pair. Since I actually want to store a pointer, I use that handy-dandy *T to do it.
[08:25:14] <aatch> The *tydesc is actually a pointer to the vtable
[08:25:24] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[08:25:25] <dbaupp> do you have the vtable in there?
[08:25:27] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[08:25:27] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/uc9Bag
[08:25:27] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[08:27:09] <aatch> yep. and one cool thing is that if I mark the right things as #[inline], LLVM'll optimize it down to a regular function call, even cross crate
[08:27:17] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[08:27:44] <aatch> (Pretty much anything returning a &Trait)
[08:27:57] <dbaupp> that's pretty awesome!
[08:28:00] *** Joins: CarpNet (ac@moz-FD24B77.sohonet.co.uk)
[08:28:10] <dbaupp> so you get to have black magic without any performance loss
[08:28:24] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[08:28:24] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/qY37KA
[08:28:24] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[08:28:27] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[08:28:27] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/NVSr5Q
[08:28:27] <ghrust> 13rust/06auto 14434b946 15Daniel Micay: remove `each` from vec, HashMap and HashSet
[08:28:27] <ghrust> 13rust/06auto 145dee79d 15bors: auto merge of #7373 : thestinger/rust/iterator, r=huonw
[08:28:27] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[08:28:37] <aatch> dbaupp, well, a little from the indirection. I can't eliminate all of it.
[08:28:53] <dbaupp> right
[08:28:54] *** Joins: roo (jesse.rudo@moz-9740949C.dynamic.ip.windstream.net)
[08:29:20] <aatch> Oh, and they work with default methods!
[08:29:29] *** kimundi is now known as zz_kimundi
[08:30:02] <dbaupp> :D
[08:31:12] <aatch> The whole reason for this, btw, is because I need something like &[Value] to work.
[08:31:35] <aatch> So &[&Value] will have to do.
[08:31:45] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[08:31:55] <dbaupp> right, because e.g. function args aren't necessarily the same type
[08:32:07] <dbaupp> (and an enum doesn't work for some reason?)
[08:32:22] *** Joins: noam_ (noam@F6B530A7.720527A7.416762B.IP)
[08:32:40] *** Quits: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu) (Ping timeout)
[08:32:58] *** Quits: noam (noam@F6B530A7.720527A7.416762B.IP) (Ping timeout)
[08:33:07] <aatch> I could use an enum, but that is yet more code overhead to deal with.
[08:33:39] *** Quits: chee (chee@moz-E5A0DD8.org) (Quit: i am quit)
[08:34:05] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[08:34:07] <dbaupp> it gives you more safety (but I'm sure you already know that.)
[08:34:38] <aatch> dbaupp, not really. The way I'm planning gives you the same level of type-safety as the C++ api
[08:34:45] <aatch> Or atleast close
[08:34:50] <dbaupp> cool!
[08:34:55] <aatch> (I hope)
[08:35:12] <dbaupp> (I assume you're forced to bolt this on top of the C api?)
[08:35:24] <aatch> dbaupp, unfortunately, yes
[08:35:28] <mark_edward> how do you get newlines in docstrings?
[08:35:35] <mark_edward> i need to write a multiline example
[08:35:53] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[08:36:03] <dbaupp> mark_edward: https://github.com/mozilla/rust/blob/master/src/libstd/iterator.rs
[08:36:17] <dbaupp> mark_edward: the /// and /*! things in there
[08:36:19] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[08:37:43] <aatch> One issue is broken trait inheritance though...
[08:38:02] <dbaupp> yeah
[08:38:34] <dbaupp> and calling foo<T: Bar>() with self doesn't work in a default method on Bar yet
[08:38:35] <aatch> hmm, also no upcasting for traits.
[08:39:11] <aatch> as in, I can't cast a trait to a supertrait
[08:39:46] *** Joins: novabyte (Instantbir@moz-3E0F9699.cable.virginmedia.com)
[08:40:07] <dbaupp> :(
[08:40:22] <dbaupp> (is there a bug about that one?)
[08:40:46] <aatch> Dunno, wouldn't be surprised if they're all related though.
[08:41:04] *** Joins: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[08:41:16] *** Joins: lucian_ (lucian@moz-D82F7974.zone16.bethere.co.uk)
[08:41:17] *** Quits: lucian_ (lucian@moz-D82F7974.zone16.bethere.co.uk) (Input/output error)
[08:41:17] *** Quits: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP) (Connection reset by peer)
[08:41:20] <dbaupp> presumably they are
[08:41:33] <dbaupp> and someone can close like 5 issues in one go
[08:41:37] *** Joins: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[08:41:47] <aatch> The vtables aren't inherited properly either by the looks of it.
[08:41:47] <dbaupp> (I guess someone = sully, heh)
[08:42:18] <dbaupp> I guess supertrait vtables should be a pointer in the subtrait vtable?
[08:42:50] <dbaupp> (which'd make upcasting just copying two pointers.)
[08:44:43] *** Joins: jaen (jaen@moz-EE3619AB.play-internet.pl)
[08:45:10] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[08:45:57] <aatch> not sure, I'm thinking that a sub trait should just combine the vtables of all it's parents.
[08:46:59] <dbaupp> that'd work too
[08:47:22] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[08:47:54] <aatch> because you can't change the methods themselves at runtime (i.e. the vtables are immutable) that should work fine.
[08:48:14] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[08:48:19] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[08:49:10] <aatch> so `trait Foo : Bar+Baz` would have a vtable like: `[<Foo methods>, <Bar methods>, <Baz methods>]`
[08:50:04] <aatch> and when we construct the vtable, if there isn't an implementation for a supertrait method in `Foo`, we try pulling it from the supertrait itself.
[08:50:18] *** Joins: pyrac (pyrac@EDE6BD92.73C89388.AD05C589.IP)
[08:50:51] <aatch> anyway, I'm gonna go. see ya
[08:50:51] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[08:50:57] *** aatch is now known as aatch|gone
[08:51:09] *** Quits: roo (jesse.rudo@moz-9740949C.dynamic.ip.windstream.net) (Ping timeout)
[08:51:32] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[08:51:38] *** Joins: roo (jesse.rudo@moz-75602046.dynamic.ip.windstream.net)
[08:55:35] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz)
[09:01:22] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[09:01:23] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 145dee79d to 145a089c2: 02http://git.io/N3iJvQ
[09:01:23] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[09:01:25] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[09:01:25] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/_XeYTg
[09:01:25] <ghrust> 13rust/06auto 141841b31 15Alex Crichton: Add 'static mut' items to the language
[09:01:25] <ghrust> 13rust/06auto 148fdc8f3 15Alex Crichton: Support foreign 'static mut' variables as well
[09:01:25] <ghrust> 13rust/06auto 14b94f89f 15Alex Crichton: Fix 'static mut' tests
[09:01:26] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[09:03:41] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[09:03:46] *** Joins: Earnestly (earnest@639E83C4.94D0CBFF.5411983D.IP)
[09:05:47] *** Joins: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com)
[09:05:52] *** Quits: roo (jesse.rudo@moz-75602046.dynamic.ip.windstream.net) (Ping timeout)
[09:06:26] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[09:06:35] *** Quits: jaen (jaen@moz-EE3619AB.play-internet.pl) (Ping timeout)
[09:08:19] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[09:09:42] *** Joins: ysuzuki (ysuzuki@moz-A563888C.ics.keio.ac.jp)
[09:10:52] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[09:11:05] *** zz_kimundi is now known as kimundi
[09:12:44] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[09:13:46] *** Joins: EXetoC (ex@moz-2DBEB1E4.customer.t3.se)
[09:14:26] *** Joins: Blei (philipp@moz-4E4B9A0A.ethz.ch)
[09:15:39] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[09:16:40] *** Joins: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP)
[09:18:55] *** Joins: peeves (bzlandfill@6278F41C.98A5D9.13336A93.IP)
[09:22:25] *** Joins: pnkfelix (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net)
[09:22:38] *** Joins: BitPuffin (quassel@moz-49828767.cust.tele2.se)
[09:22:42] *** kimundi is now known as zz_kimundi
[09:25:00] <Blei> dbaupp: thanks
[09:25:09] <dbaupp> Blei: np
[09:28:19] *** Joins: roo (jesse.rudo@moz-11A0BD87.dynamic.ip.windstream.net)
[09:31:04] *** Quits: fabiand (fabiand@186696B8.BCE163C1.1A5CC7E5.IP) (Quit: Verlassend)
[09:35:17] *** Joins: fabiand (fabiand@186696B8.BCE163C1.1A5CC7E5.IP)
[09:35:37] *** Quits: roo (jesse.rudo@moz-11A0BD87.dynamic.ip.windstream.net) (Ping timeout)
[09:39:18] *** Quits: Sodel_the_V (user@moz-853663E1.va.shawcable.net) (Quit: Eaten by a grue)
[09:42:38] *** Joins: pnkfelix|rcirc (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net)
[09:45:53] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[09:50:18] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[09:53:20] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[09:54:48] *** Quits: SimonSapin (simon@moz-D0C2F181.zone2.bethere.co.uk) (Ping timeout)
[09:58:21] *** Joins: spider-mario (spidermari@moz-B8FA2FF4.rev.sfr.net)
[09:58:52] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[09:59:20] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[10:01:59] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[10:02:13] <mark_edward> bjz: i have a docs folder now, check it out. open the html in ur browser bro
[10:05:20] *** Joins: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP)
[10:09:54] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[10:12:35] *** zz_kimundi is now known as kimundi
[10:21:14] *** Joins: roo (jesse.rudo@moz-8A2B79D2.dynamic.ip.windstream.net)
[10:25:44] *** Quits: pyrac (pyrac@EDE6BD92.73C89388.AD05C589.IP) (Quit: pyrac)
[10:26:38] *** Quits: roo (jesse.rudo@moz-8A2B79D2.dynamic.ip.windstream.net) (Ping timeout)
[10:28:41] <cmr> indutny: it landed! finally! :D
[10:28:48] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Leaving...)
[10:28:54] <indutny> cmr: hi!
[10:28:57] <indutny> thanks :)
[10:29:02] *** Quits: fabiand (fabiand@186696B8.BCE163C1.1A5CC7E5.IP) (Ping timeout)
[10:29:11] <indutny> will finally build master
[10:32:03] *** Quits: peeves (bzlandfill@6278F41C.98A5D9.13336A93.IP) (Quit: CGI:IRC (EOF))
[10:32:21] *** Joins: MaikKlein (maik@moz-3D9AD16.dip0.t-ipconnect.de)
[10:32:31] *** Joins: jaen (jaen@81607195.6A94545C.43DC2829.IP)
[10:33:02] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[10:33:16] *** Joins: mib_5pln7n (Mibbit@810827A8.F34E366.78004705.IP)
[10:33:52] *** Quits: mib_5pln7n (Mibbit@810827A8.F34E366.78004705.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[10:35:28] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[10:35:47] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[10:37:16] *** Joins: jfbk (user@moz-EEA9CFB3.nyc.res.rr.com)
[10:37:19] *** Quits: jaen (jaen@81607195.6A94545C.43DC2829.IP) (Ping timeout)
[10:44:21] <ysuzuki> cd /etc/pki/tls/certs
[10:44:29] <ysuzuki> oops, sorry
[10:44:57] *** Parts: ysuzuki (ysuzuki@moz-A563888C.ics.keio.ac.jp) ()
[10:45:30] *** Quits: MaikKlein (maik@moz-3D9AD16.dip0.t-ipconnect.de) (Ping timeout)
[10:46:06] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Quit: Leaving.)
[10:47:02] *** Joins: fabiand (fabiand@186696B8.BCE163C1.1A5CC7E5.IP)
[10:48:17] <jfbk> is it possible to unpack vecs into fn params, e.g. like foo(*ls) in python?
[10:48:55] <cmr> jfbk: no, nor does it make sense for Rust to have that feature, because it compiels to native code, and that would require a really weird, contorted ABI
[10:49:23] <jfbk> what abt for fmt! ?
[10:49:36] <dbaupp> jfbk, nope
[10:49:38] <cmr> what about it?
[10:49:46] <cmr> fmt! is a syntax extension and gets expanded at compile time
[10:49:57] <dbaupp> but you can use %? to print arbitrary structures (including vectors)
[10:49:59] <jfbk> not a fn, so no abi concerns
[10:50:04] <cmr> right
[10:50:19] <jfbk> and already takes var-len args
[10:50:29] <jfbk> based on first arg params
[10:50:39] <jfbk> would be nice if you could pass a vec
[10:50:47] <cmr> it might be possible to extend fmt! to accept something like that
[10:50:51] <cmr> want to work on it? :)
[10:50:58] <dbaupp> jfbk, it's not clear how useful that would be
[10:51:13] <cmr> actually I'm not sure it's possible, since it runs before typeck, it doesn't know the type of its first parameter
[10:51:18] <dbaupp> let v = [1,2,3]; fmt!("%d %d", *v) // explodes
[10:51:24] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[10:51:39] <dbaupp> cmr: it actually uses generates code in such a way that typeck does the type checking
[10:51:49] <cmr> I imagine it'd expand into v[0], v[1], v[2]
[10:52:06] <dbaupp> cmr: yeah, the length isn't known at compile time
[10:52:07] <cmr> Or, actually, just as many v[x] as it needs
[10:52:14] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[10:52:15] <dbaupp> oh, right
[10:52:26] <cmr> Of course, it could *fail* at runtime
[10:52:32] <cmr> Which isn't too great...
[10:52:35] <cmr> but it's possible, I think
[10:52:56] <dbaupp> that would be a strange feature
[10:53:04] <Blei> couldn't you just write a macro?
[10:53:14] <Blei> something like star!(v, 3)
[10:53:15] <jfbk> i've got this ugly guy: https://gist.github.com/jfager/5857599
[10:53:47] <dbaupp> jfbk, you probably want a loop
[10:54:08] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[10:54:31] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[10:54:33] <cmr>  let f = u8::to_str_radix;
[10:54:38] *** Quits: fabiand (fabiand@186696B8.BCE163C1.1A5CC7E5.IP) (Ping timeout)
[10:54:40] <cmr> that's so cool, didn't know you could do that
[10:54:45] <cmr> makes sense in hindsight though
[10:54:53] * cmr would have used `use f = u8::to_str_radix;`
[10:55:41] <dbaupp> let f = |x| u8::to_str_radix(x, 16); let mut v = ~[]; for uint::range_step(0, 16, 2) |i| { s.push_str(fmt!("%s%s", f(ip[i]), f(ip[i+1])); } v.connect(":")
[10:55:56] <dbaupp> s/s.push_str/v.push/
[10:56:20] *** Joins: fabiand (fabiand@186696B8.BCE163C1.1A5CC7E5.IP)
[10:57:12] <Blei> rusti: u8::to_str_radix(1, 16)
[10:57:19] <Blei> D:
[10:57:25] <cmr> rusti: 5
[10:57:38] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/Mjij
[10:57:38] -rusti- 5
[10:57:47] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[10:57:52] <Blei> rusti: std::u8::to_str_radix(1, 16)
[10:58:38] *** Joins: ysuzuki_ (ysuzuki@moz-285468F7.net219126120.t-com.ne.jp)
[10:58:44] *** Quits: ysuzuki_ (ysuzuki@moz-285468F7.net219126120.t-com.ne.jp) (Quit: ysuzuki_)
[10:58:59] *** Joins: ysuzuki (ysuzuki@moz-285468F7.net219126120.t-com.ne.jp)
[10:59:20] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[10:59:59] <dbaupp> Blei: I think you killed it :(
[11:00:32] <Blei> poor rusti
[11:01:08] <jfbk> oh, how sad. i feel guilty now.
[11:01:28] *** Quits: ysuzuki (ysuzuki@moz-285468F7.net219126120.t-com.ne.jp) (Quit: Tiarra 0.1+svn-39209: SIGINT received; exit)
[11:01:54] *** Joins: ysuzuki (ysuzuki@moz-A563888C.ics.keio.ac.jp)
[11:02:12] *** Quits: ysuzuki (ysuzuki@moz-A563888C.ics.keio.ac.jp) (Quit: )
[11:02:14] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[11:02:18] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[11:03:06] <Blei> anyways, i think your function might have a small bug
[11:03:14] <Blei> you should pad with 0s
[11:03:29] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[11:04:45] <jfbk> yeah, it does. been living w/ it for now.
[11:06:17] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[11:07:08] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[11:08:03] *** Joins: ysuzuki (ysuzuki@moz-285468F7.net219126120.t-com.ne.jp)
[11:08:18] *** Quits: ysuzuki (ysuzuki@moz-285468F7.net219126120.t-com.ne.jp) (Quit: Tiarra 0.1+svn-39209: SIGTERM received; exit)
[11:09:37] *** Joins: ysuzuki (ysuzuki@moz-285468F7.net219126120.t-com.ne.jp)
[11:12:10] <thiez> hmmn, we have ~Trait, @Trait, and &Trait; will there be *Trait?
[11:12:37] <cmr> thiez: does *Trait make sense?
[11:12:42] <cmr> An unsafe pointer to the struct?
[11:12:51] <thiez> I don't know if that makes sense, but I think it might
[11:12:52] <cmr> It's not like you can pass a *Trait across an ffi
[11:13:30] <thiez> you can't pass {~@&}Traits across ffi either, right?
[11:13:33] <cmr> Actually, it might make sense...
[11:13:35] <cmr> no
[11:14:33] *** Joins: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[11:17:20] <dbaupp> I guess it does, it'd just be equivalent to (*opaque_box, &'static vtable), rather than (~opaque_box, &'static vtable), (@opaque_box, &'static vtable)
[11:17:26] <dbaupp> etc
[11:18:11] <cmr> The only time I can see it really making sense is if you were to wrap Qt or something like it with traits, and can't guarantee the safety of the thing you point to
[11:18:22] *** Joins: illissius (illissius@moz-19397A63.catv.broadband.hu)
[11:18:47] <thiez> I suppose one could always have 'unsafe fn magic<T,U:T>(t: &*T) -> &U { let t: &T = transmute(*t); t as &U }' or something along those lines
[11:19:00] <dbaupp> yeah, I think aatch|gone could use it for wrapping LLVM
[11:19:08] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[11:19:22] <dbaupp> thiez: yup, returning &'static U
[11:20:00] <dbaupp> thiez: https://gist.github.com/Aatch/5856745
[11:20:01] <thiez> dbaupp: I don't like that though, it implies a level of safety that we might not be able to guarantee
[11:20:14] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[11:20:16] <dbaupp> thiez: (aatch was doing this literally a few hours ago :D )
[11:20:21] <dbaupp> thiez: yeah, *Trait would be perfect for this
[11:21:27] <thiez> we'll see what the devs think about it
[11:21:59] <thiez> (ofc if we drop * in favour of &'unsafe then we don't need this)
[11:22:28] <cmr> &'unsafe is being considered
[11:22:29] <cmr> ?
[11:22:37] <cmr> I wouldn't like that very much, much more verbose.
[11:22:39] <thiez> I think I've heard about it at some point
[11:22:48] <dbaupp> cmr: how often are you using * pointers?
[11:23:03] <thiez> I didn't like it either, I like to be able to say we have 4 pointer types :p
[11:23:11] <cmr> dbaupp: every project I've done that isn't a cleanup in rustc, actually!
[11:23:18] <cmr> There are lots of useful libraries
[11:23:31] <dbaupp> cmr: well... you're using rust wrong, or something :P
[11:23:35] <cmr> Course, it's always to make a safe wrapper
[11:23:38] <thiez> I've even resorted to *mut >:D
[11:23:38] <cmr> But still
[11:23:56] <thiez> and manual mallocs
[11:24:02] <dbaupp> (presumably one would wrap these libraries into a "safe" interface, you don't have to constantly cast to/from * by hand.)
[11:24:18] <dbaupp> cmr: right
[11:24:23] <cmr> right, but when I'm writing an ffi, I don't want to be using &'unsafe everywhere
[11:24:31] <dbaupp> thiez: you're a mad man!
[11:24:33] <cmr> 1. it looks ugly, 2. it's more typing :P
[11:24:46] <cmr> I think * is perfect, it corresponds exactly to C
[11:24:55] <cmr> Well, except pointer arith
[11:24:57] <thiez> dbaupp: not really, I don't like that ~ creates a huge allocation, so manual malloc it is :p
[11:25:16] <dbaupp> thiez: "huge" = a few extra bytes?
[11:25:21] <cmr> it's 32 extra bytes
[11:25:30] <cmr> which could be larger than your struct..
[11:25:42] <dbaupp> yes
[11:25:52] <thiez> it was a linked list, so yes, the overhead was kind of large compared to the nodes :p
[11:26:17] <thiez> besides, once you cast to * and *mut, is it really that much better to have used ~?
[11:26:21] <dbaupp> thiez: oh, it was a data-structure... then you're excused for using * :P
[11:26:55] <thiez> double linked list without @ and * is tricky too :p
[11:27:53] <dbaupp> yup
[11:28:36] *** Joins: pyrac (pyrac@moz-C4B13AD4.math.u-bordeaux1.fr)
[11:30:16] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[11:32:06] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[11:32:21] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Leaving...)
[11:33:26] <thiez> it's a shame you can't google for things like &'unsafe
[11:33:34] <thiez> nor can you look for it on github
[11:34:25] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[11:34:25] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/_XeYTg
[11:34:25] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[11:34:38] <cmr> /home/cmr/hacking/rust/src/libextra/interner.rs:113:14: 113:22 error: Illegal anonymous lifetime: anonymous lifetimes are not permitted here
[11:34:39] <cmr> /home/cmr/hacking/rust/src/libextra/interner.rs:113 impl<'self, T:StrSlice> Interner<T> for DenseStringInterner {
[11:34:41] <cmr>                                                                   ^~~~~~~~
[11:34:43] <cmr> O_o
[11:35:19] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[11:35:25] <dbaupp> cmr: presumably DenseStringInterner has a borrowed pointer inside it, so you need DenseStringInterner<'self>
[11:36:10] <cmr> dbaupp: not afaict... https://gist.github.com/cmr/5846269
[11:36:31] <dbaupp> cmr: oh
[11:36:40] <dbaupp> hm, maybe the <'self, ... in the impl is confusing it
[11:36:47] * cmr removes it
[11:37:05] <cmr> h, nope, still same error, same span
[11:37:25] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[11:37:25] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/HPFhCg
[11:37:25] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[11:37:33] <cmr> Ah, pub trait StrSlice<'self>
[11:37:39] <dbaupp> cmr: wait, yeah, that
[11:37:55] <cmr> and an ice :p
[11:38:00] <dbaupp> \o/
[11:38:01] <cmr> Does
[11:38:02] <cmr>  impl<'self, T:StrSlice<'self>> Interner<T> for DenseStringInterner {
[11:38:04] <cmr> look right?
[11:38:19] <dbaupp> cmr: if you change it to T: Str, then it's more flexible
[11:38:26] <dbaupp> (and doesn't require a lifetime)
[11:38:51] <dbaupp> you'll also need to explicitly get a slice with .as_slice() though
[11:39:11] <cmr> yeah, that's what I was trying to avoid
[11:39:18] <cmr> since I *always* want a slice
[11:39:20] <cmr> rust: task failed at 'region parameterization should have inferred that this type is RP', /home/rustbuild/src/rust-buildbot/slave/snap3-linux/build/src/librustc/middle/typeck/rscope.rs:233
[11:39:35] <dbaupp> cmr: well, using Str would allow you to intern ~str and @str
[11:39:52] <dbaupp> (without having to worry about automatic coercions)
[11:40:20] <cmr> dbaupp: alright, might as well use it, especially since it seems like StrSlice is a no-go :p
[11:40:24] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[11:40:24] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/HPFhCg
[11:40:24] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[11:40:25] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[11:40:26] <ghrust> 01[13rust01] 15bors pushed 11 new commits to 06auto: 02http://git.io/oAZy-g
[11:40:26] <ghrust> 13rust/06auto 14f2c5642 15Philipp Brschweiler: Fix get_tydesc() return type...
[11:40:26] <ghrust> 13rust/06auto 14469f394 15Philipp Brschweiler: Remove intrinsic module...
[11:40:26] <ghrust> 13rust/06auto 14179ce39 15Philipp Brschweiler: Fix and reenable the reflect-visit-type test
[11:40:28] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[11:40:29] <dbaupp> hm, actually that'd probably break
[11:40:39] <cmr> Gah, still an ICE
[11:40:43] <dbaupp> cmr: in any case, StrSlice == &'self str
[11:40:53] <dbaupp> so just use that instead of having it generic
[11:41:35] <cmr> dbaupp: I initially used &'self str, but then like get would need to return a & &'self str :\
[11:41:50] <dbaupp> cmr: well it currently does that
[11:42:04] <cmr> It's just hidden behind the trait?
[11:42:10] <dbaupp> yeah
[11:43:47] <dbaupp> also, str_at could be `match self.buf.slice_from(off).iter().position(|c| c == 0) { Some(len) => ..., None => fail!() }`
[11:44:55] <dbaupp> (well, .position_() ... gah! #5898 :( )
[11:45:39] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[11:45:45] <cmr> dbaupp: Is there any way I can get rid of this double indirection without butchering the Interner trait?
[11:45:59] <dbaupp> not that I know of
[11:46:19] <dbaupp> hm, I actually guess that it doesn't work
[11:46:29] <dbaupp> and could segfault, etc.
[11:46:40] <cmr> That seems like a pretty... undesirable aspect of Rust's type system
[11:47:14] <cmr> I don't see any way to fix it though
[11:47:16] <dbaupp> does it currently compile?
[11:47:40] <cmr> no
[11:47:45] <cmr> almost got it I think
[11:48:04] <dbaupp> because it looks a lot like .get is returning Option<&str>, rather than Option<&'a &str>
[11:48:17] <cmr> yeah I fixed that locally
[11:48:26] <cmr> I'm currently fighting with conflicting lifetime requirements
[11:48:30] <dbaupp> by taking a reference to .str_at?
[11:48:34] <cmr> yeah
[11:48:48] <cmr> https://gist.github.com/cmr/4dda0998da702ee9967e
[11:48:51] <dbaupp> yeah, you can't solve the conflicing requirements
[11:49:43] <cmr> as in, what I want isn't possible at all, or there's a bug in borrowck?
[11:49:46] <dbaupp> the result of the .str_at call is a (*u8, uint) on the stack
[11:50:02] <dbaupp> so taking a reference to it, only lasts for as long as the current stack fram
[11:50:04] <dbaupp> e
[11:50:26] <dbaupp> not 'a, even though the data the *u8 points to lasts for 'a
[11:50:49] <cmr> So I... should be able to make a... ~&str?
[11:50:51] <doener> had a similar problem with the ebml decoder, resorted to using something like "do with_str_at(...) |s| { ... }"
[11:51:13] <dbaupp> cmr: that'd probably work
[11:51:20] <dbaupp> that is also really ugly
[11:51:23] <cmr> yeah
[11:51:29] <cmr> and doesn't work with the trait..
[11:52:12] <dbaupp> I'd guess you could make it return T by value
[11:52:18] <dbaupp> i.e. Option<T>
[11:52:47] <dbaupp> but that's not so nice
[11:52:48] <cmr> That'd always require copies, and doesn't work well for an actual interner.
[11:52:57] <dbaupp> not necessarily
[11:53:22] <dbaupp> e.g. Interner<&'self str> wouldn't copy
[11:53:36] <dbaupp> and Interner<&'self T> wouldn't copy
[11:53:47] <dbaupp> but that is also pretty ugly
[11:53:58] * dbaupp thinks DST would solve this
[11:54:12] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[11:54:29] *** Quits: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com) (Quit: webber46)
[11:54:39] <cmr> hm
[11:55:04] <cmr> I'm not even sure a &'self str makes sense for densestringinterner
[11:55:06] <dbaupp> I'm not sure you can do this generically and still have it nice/work
[11:55:11] <cmr> the string needs to live as long as the interner
[11:55:18] <cmr> dbaupp: neither am I :(
[11:55:27] <dbaupp> yeah... ?
[11:55:41] <dbaupp> (what about the string living as long as the interner?)
[11:55:52] <thiez> it doesn't.
[11:55:59] <thiez> that's what's wrong :p
[11:56:09] <dbaupp> thiez: why?
[11:56:39] <cmr> dbaupp: Interner<&'self str> means the string needs to be valid for the entire lifetime of the interner, no?
[11:56:44] <thiez> because it concats strings, which might result in the underlying buffer being reallocated, which might result in it getting moved in memory, which will make & point to something else
[11:56:52] <dbaupp> cmr: yes
[11:57:04] <thiez> when you interner.get(), it's only valid until the next interner.intern()
[11:57:06] <dbaupp> thiez: you're doing an immutable borrow, so you can't mutate the interner anyway
[11:57:13] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[11:57:14] <thiez> ah, then it's okay
[11:57:21] * thiez crawls back under his rock.
[11:57:27] <cmr> heh :p
[11:57:29] <dbaupp> thiez: :)
[11:57:46] <cmr> thiez: fancy that the type system captures that requirement
[11:58:02] <thiez> I know, it's how iterators work :p
[11:58:14] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[11:58:15] <thiez> lo and behold no iterator invalidation
[11:58:42] <cmr> Hm
[11:59:14] *** Joins: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net)
[11:59:30] <cmr> fn intern(&mut self, &str) on densestringinterner, does that lifetime get infered to be 'self, because the trait's method definition for Interner<T> is fn intern(&mut self, T)?
[11:59:43] <cmr> (and DenseStringInterner impl's Interner<&'self str>)
[12:00:01] <dbaupp> cmr: the &str?
[12:00:08] <cmr> dbaupp: yeah
[12:00:21] <dbaupp> hm
[12:00:29] <cmr> if it doesn't, this can totally work
[12:00:38] <dbaupp> it's not
[12:00:58] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[12:01:11] <dbaupp> the 'self lifetime refers to the lifetime of the borrowed pointers "within" the &str
[12:01:14] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[12:01:25] <dbaupp> (it doesn't have anything to do with the lifetime of the `self` object)
[12:01:39] <cmr> I should use a different name :p
[12:01:54] <dbaupp> the fact that it has to be called "self" is a historical thing that'll be cleaned up sometime
[12:02:23] <dbaupp> (it doesn't have any special properties, it's just the only lifetime that rustc'll accept in types)
[12:02:47] <dbaupp> oh, and 'static (which does have special properties, but it's the only lifetime that does)
[12:05:17] *** Joins: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[12:06:50] *** Joins: roo (jesse.rudo@moz-5F2EE5D.dynamic.ip.windstream.net)
[12:08:52] <cmr> With https://gist.github.com/cmr/5846269 I'm still getting https://gist.github.com/cmr/5a650f88096fd5729462
[12:10:31] <cmr> Shouldn't str_at return the same lifetime?
[12:10:42] <dbaupp> cmr: .get needs to return Option<&'a str>
[12:10:55] *** Quits: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Ping timeout)
[12:11:13] <cmr> dbaupp: does that mean .get needs to be parameterized by <'a>?
[12:11:19] <dbaupp> the lifetime of the string is connected to the interner, not connected to it's own borrowed pointer
[12:11:27] <dbaupp> cmr: yes, the same as .str_at
[12:12:23] <cmr> dbaupp: is this possible given the current Interner trait?
[12:12:25] *** Joins: bstrie (ben@moz-D5A1D0F5.members.linode.com)
[12:12:36] <dbaupp> what do you mean?
[12:12:38] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[12:12:50] <dbaupp> does it fail?
[12:13:14] <cmr> with /home/cmr/hacking/rust/src/libextra/interner.rs:152:4: 158:5 error: method `get` has an incompatible type: expected concrete lifetime, but found bound lifetime parameter &
[12:13:15] <cmr> /home/cmr/hacking/rust/src/libextra/interner.rs:152     fn get<'a>(&'a self, tag: uint) -> Option<&'a str> {
[12:13:18] <cmr> maybe I'm not doing it right?
[12:13:45] <dbaupp> nah, I think it is impossible :(
[12:14:34] <cmr> I feel like this *should* be possible though, and that borrowck is too inflexible
[12:14:34] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[12:14:34] <dbaupp> you could possibly have Interner<T, Ret>
[12:14:49] *** Quits: roo (jesse.rudo@moz-5F2EE5D.dynamic.ip.windstream.net) (Ping timeout)
[12:15:02] <dbaupp> so that you can control the return type of .get
[12:15:28] <cmr> hm, that should work
[12:16:15] <dbaupp> it still might not :(
[12:17:15] <cmr> /home/cmr/hacking/rust/src/libextra/interner.rs:113:41: 113:44 error: Illegal lifetime 'a: only 'self is allowed as part of a type declaration
[12:17:16] <cmr> /home/cmr/hacking/rust/src/libextra/interner.rs:113 impl<'self, 'a> Interner<&'self str, &'a str> for DenseStringInterner {
[12:17:18] <cmr>                                                                                              ^~~
[12:17:20] <cmr> bah!
[12:17:47] <dbaupp> yeah, and what happens if you use &'self str there, but parameterise .get?
[12:18:13] <cmr> conflicting requirements
[12:19:03] <dbaupp> :/
[12:19:08] <dbaupp> gah!
[12:19:22] <cmr> does this feel like a bug in borrowck to you too?
[12:19:26] <dbaupp> nope
[12:19:44] <doener> is using &'self str as the interned value worth it anyway? I'd imagine that it would be a pain to use
[12:19:53] <dbaupp> if it returns by-val, then the value has to last "forever"
[12:20:16] <dbaupp> if it returns by reference, that the thing it's taking a reference to has to last as long as the interner
[12:20:37] <dbaupp> doener: the 'self isn't the lifetime of the interner
[12:20:59] <dbaupp> doener: it's a "dummy" lifetime to satisfy rustc about borrowed pointers in types
[12:21:13] *** Quits: sankha93 (Instantbir@EA7EC93C.6957C8B2.8B6C1D65.IP) (Quit: Instantbird 1.4 -- http://www.instantbird.com)
[12:21:17] <dbaupp> (if that's what you're worried about?)
[12:23:03] *** Quits: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP) (Ping timeout)
[12:23:09] *** Quits: joelteon (joel@moz-317E8D0C.io) (Ping timeout)
[12:23:11] <doener> dbaupp: what about: i.intern(~"Foo")?
[12:23:29] <doener> dbaupp: wouldn't the stored &str become invalid right away?
[12:23:38] <dbaupp> doener: that gets coerced to &str, and then the interner does it's thing
[12:23:46] <cmr> doener: the interner copies the string
[12:23:51] <cmr> into its internal buffer
[12:23:52] <dbaupp> doener: well, no, if it did, then rustc would complain about it
[12:23:54] <cmr> at least, the bytes of it.
[12:24:06] <bstrie> so is 1.4gb of ram+swap enough to actually build rust?
[12:24:10] <cmr> and stores a hash of the string for mapping to the index in the internal buffer
[12:24:22] <cmr> bstrie: no
[12:24:25] <dbaupp> (since as far as the interner knows, the &str gets deallocated as soon as .intern returns)
[12:24:35] <cmr> bstrie: actually, maybe.
[12:24:44] <dbaupp> bstrie: it'd be pretty close
[12:24:51] <doener> dbaupp: hm, I guess this is not the Interner from libsyntax then?
[12:24:56] <dbaupp> doener: nope
[12:25:08] <dbaupp> doener: https://gist.github.com/cmr/5846269 DenseStringInterner
[12:25:11] <doener> in that case, ignore me :-)
[12:25:21] <dbaupp> :)
[12:25:22] <cmr> doener: it's intended to replace that interner though
[12:27:42] *** Joins: roo (jesse.rudo@moz-5AFD7C85.dynamic.ip.windstream.net)
[12:28:53] <dbaupp> cmr: I get the feeling that it's not possible to be generic with the current system :(
[12:29:20] *** Joins: joelteon (joel@moz-317E8D0C.io)
[12:29:44] <cmr> dbaupp: I'll bother niko about it later, he may have insight into it that we don't... I get that feeling too though
[12:30:15] <dbaupp> cmr: hopefully I'm wrong about the lifetimes stuff :)
[12:32:51] *** Quits: joelteon (joel@moz-317E8D0C.io) (Ping timeout)
[12:33:46] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[12:36:50] *** Joins: BadMOF0 (huh@moz-F31B7D19.cpe.net.cable.rogers.com)
[12:37:12] * BadMOF0 Picture of my whore ex-wife naked http://imagetwist.com/v8ee5q3ip753
[12:37:17] * BadMOF0 Picture of my whore ex-wife naked http://imagetwist.com/v8ee5q3ip753
[12:37:19] * BadMOF0 Picture of my whore ex-wife naked http://imagetwist.com/v8ee5q3ip753
[12:37:22] * BadMOF0 Picture of my whore ex-wife naked http://imagetwist.com/v8ee5q3ip753
[12:37:27] *** Quits: BadMOF0 (huh@moz-F31B7D19.cpe.net.cable.rogers.com) (Quit: )
[12:37:54] * hoelzro sighs
[12:38:53] *** Quits: dew (Instantbir@moz-66796D51.dhcp.stls.mo.charter.com) (Ping timeout)
[12:39:18] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[12:39:19] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[12:39:28] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Connection reset by peer)
[12:39:30] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[12:40:21] *** Joins: joelteon (joel@moz-317E8D0C.io)
[12:41:10] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[12:42:30] *** Quits: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net) (Ping timeout)
[12:43:48] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[12:44:20] *** Joins: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP)
[12:46:52] *** Quits: barosl (barosl@E287D94F.C81E10FB.7544CABF.IP) (Quit:  .)
[12:50:07] <doener> sully: ping
[12:53:44] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[12:53:47] *** Joins: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca)
[12:54:47] *** Quits: ysuzuki (ysuzuki@moz-285468F7.net219126120.t-com.ne.jp) (Quit: Tiarra 0.1+svn-39209: SIGTERM received; exit)
[12:55:40] *** Joins: ysuzuki (ysuzuki@moz-285468F7.net219126120.t-com.ne.jp)
[13:03:36] *** Quits: roo (jesse.rudo@moz-5AFD7C85.dynamic.ip.windstream.net) (Ping timeout)
[13:04:20] *** Joins: xLII (xLII@4BED3CB3.F5F53E8A.2D6DB75E.IP)
[13:04:34] *** Joins: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk)
[13:05:10] <bjz> mark_edward: ping
[13:08:07] *** Joins: sankha93 (Instantbir@EA7EC93C.6957C8B2.8B6C1D65.IP)
[13:08:44] *** Joins: cowboyd (cowboyd@moz-1BD02A1E.sw.biz.rr.com)
[13:13:33] *** Quits: jfbk (user@moz-EEA9CFB3.nyc.res.rr.com) (Ping timeout)
[13:15:29] *** Joins: Sodel_the_V (user@moz-853663E1.va.shawcable.net)
[13:17:35] *** Joins: chee (chee@moz-E5A0DD8.org)
[13:19:49] *** Joins: testing (Mibbit@moz-285468F7.net219126120.t-com.ne.jp)
[13:20:01] *** Quits: fabiand (fabiand@186696B8.BCE163C1.1A5CC7E5.IP) (Quit: Verlassend)
[13:20:30] *** Quits: chee (chee@moz-E5A0DD8.org) (Quit: i am quit)
[13:21:02] *** Joins: chee (chee@moz-E5A0DD8.org)
[13:22:05] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[13:23:03] *** Quits: chee (chee@moz-E5A0DD8.org) (Quit: i am quit)
[13:23:34] *** Joins: chee (chee@moz-E5A0DD8.org)
[13:23:36] <doener> was there someone trying to remove the env pointer?
[13:25:12] <cmr> doener: Blei I think
[13:25:22] *** Quits: testing (Mibbit@moz-285468F7.net219126120.t-com.ne.jp) (Quit: http://www.mibbit.com ajax IRC Client)
[13:25:42] <doener> Blei: ping
[13:25:59] <Blei> doener: pong
[13:26:18] <Blei> i didn't really try hard, to be honest
[13:26:31] *** Joins: H4199 (chatzilla@moz-64E556D3.austin.res.rr.com)
[13:26:39] <Blei> i just noticed that you can't yet call fn pointers from rust without it generating an env pointer as the first argument
[13:26:49] <Blei> oh, wait
[13:27:06] <Blei> i was trying to remove it from the glue fns, nmatsakis is trying to do it generally
[13:27:23] <Blei> (removing env pointers from fn pointer calls)
[13:27:34] <doener> wasn't the glue about removing the typedesc pointer? Or was it both?
[13:27:54] <Blei> i wanted to do both, but let the env pointer be as it is because see above :)
[13:28:01] <doener> ok
[13:28:50] <Blei> doener: https://github.com/mozilla/rust/pull/6661
[13:31:55] <doener> Blei: that only removes it for foreign functions, doesn't it?
[13:32:24] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[13:35:20] *** Quits: Aetherspawn (Aetherspaw@moz-8811D9F0.static.tpgi.com.au) (Ping timeout)
[13:36:52] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzz)
[13:38:03] <Blei> i think so
[13:40:01] *** Joins: Blub\w (wry@moz-2D425469.wireless.dyn.drei.com)
[13:40:47] *** Joins: wilfred (uid159@moz-C944F5EC.irccloud.com)
[13:42:05] <nmatsakis> I was not attempting to remove the env pointer.
[13:42:18] <nmatsakis> from Rust functions anyhow
[13:42:26] <nmatsakis> nor do I have any plans to do that, it'd be ... complicating.
[13:42:50] <nmatsakis> in particular it would make coercing bare fns into closures rather challenging
[13:42:56] <doener> ok, so I probably just confused that with Blei's attempt to get rid of the pointers in the glue fn's
[13:43:03] <Blei> yeah, sorry, i meant extern fn pointers
[13:43:09] <nmatsakis> I *have* thought about making it be the *last* argument instead of the first
[13:43:21] <nmatsakis> just to get better usage of argument registers
[13:43:28] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[13:43:48] <nmatsakis> but that kind of rules out varargs, though I doubt we'll ever want those.
[13:44:13] <cmr> to coerce a bare fn into a closure don't you just need a wrapper that takes an extra arg and passes the rest on?
[13:44:41] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[13:45:49] <nmatsakis> cmr: but you don't always know what bare fn it is
[13:46:14] <nmatsakis> cmr: i.e., if all you have is a fn ptr
[13:46:24] <nmatsakis> cmr: btw did you ever run that perf measurement?
[13:46:27] <Blei> you could pass the fn ptr to the environment of the ad-hoc closure
[13:46:29] <cmr> oh hm
[13:46:53] <Blei> *store the fn ptr in
[13:47:00] <cmr> nmatsakis: I could not get your branch to build rustc after stage2, but all the tests passed
[13:47:03] <cmr> it was very weird
[13:47:21] <cmr> I am actually in the middle of remeasuring right now, so good timing :)
[13:47:35] <cmr> (I nuked the source dir, re-cloned a new one)
[13:47:48] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[13:47:49] <nmatsakis> cmr: huh. ok.
[13:47:53] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[13:48:06] <Blei> halleluja! my pr is finally in
[13:48:21] *** Quits: cowboyd (cowboyd@moz-1BD02A1E.sw.biz.rr.com) (Client exited)
[13:49:26] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[13:49:27] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/oAZy-g
[13:49:27] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[13:50:49] <doener> cmr: I wonder if it would be useful to disable turbo boost while measuring. 
[13:52:04] <doener> that this yesterday, and thought that maybe turbo boost could explain why in one case you had the same commit at 150s and 130s in two separate runs. https://plus.google.com/114657443111661859546/posts/dLn9T4ehywL
[13:52:26] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[13:52:26] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/7kFd5w
[13:52:26] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[13:52:27] <cmr> Yeah I read that post too
[13:54:48] *** Quits: sp3d (a@moz-49806493.dhcp.stls.mo.charter.com) (Connection reset by peer)
[13:55:12] *** Joins: each (each@moz-3C6BDB1A.w92-150.abo.wanadoo.fr)
[13:55:24] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[13:55:24] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/7kFd5w
[13:55:24] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[13:55:26] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[13:55:26] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/QVhcwg
[13:55:26] <ghrust> 13rust/06auto 14544284f 15Huon Wilson: driver: perform stripping before and after macro expansion....
[13:55:26] <ghrust> 13rust/06auto 14fd396e1 15bors: auto merge of #7297 : huonw/rust/strip-expand-strip, r=pcwalton...
[13:55:26] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[13:55:30] *** Quits: zheng_li (zheng_li@moz-D6711E9E.xenplanet.org) (Ping timeout)
[13:55:40] <each> hey
[13:56:02] *** Joins: zheng_li (zheng_li@moz-D6711E9E.xenplanet.org)
[13:56:59] <Blei> hey
[13:57:27] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[13:57:51] *** Quits: zheng_li (zheng_li@moz-D6711E9E.xenplanet.org) (Ping timeout)
[13:58:01] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[13:58:01] *** ChanServ sets mode: +o dherman
[13:58:01] *** Joins: zheng_li (zheng_li@moz-D6711E9E.xenplanet.org)
[13:58:02] <each> mirc's a bit complicated
[13:58:13] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[14:05:02] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[14:05:06] *** Joins: mib_ri19yr (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP)
[14:05:14] *** Joins: fabiand (fabiand@moz-62D4E7B1.adsl.alicedsl.de)
[14:05:56] <bjz> how do I check if a file exists before I write to it?
[14:06:52] *** Joins: jclements (jclements@moz-20AD2EFB.dsl.static.sonic.net)
[14:06:55] <cmr> stat? fstat?
[14:07:28] *** Quits: each (each@moz-3C6BDB1A.w92-150.abo.wanadoo.fr) (Quit: )
[14:07:37] <bjz> path_exists?
[14:07:46] <cmr> sure, if that's what rust has :p
[14:07:51] <doener> bjz: do you want to avoid overwriting?
[14:07:55] <bjz> yep
[14:08:05] <bjz> os::path_exists I think
[14:08:16] <doener> that's racy then. Need to use O_CREAT | O_EXCL with open
[14:08:47] *** Joins: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP)
[14:08:57] <doener> probably not portable to windows though
[14:09:04] *** Quits: sankha93 (Instantbir@EA7EC93C.6957C8B2.8B6C1D65.IP) (Quit: Instantbird 1.4 -- http://www.instantbird.com)
[14:09:34] <bjz> was going to do: let path = Path("gl.xml"); if path_exists(path) {}
[14:11:56] <doener> good enough if the error condition is when the file doesn't exist, or if you don't care about race conditions (somebody else could create the file between the call the path_exists and the time you create it)
[14:12:14] <doener> s/the call that/the call to/
[14:13:23] <bjz> doener: eh, I don't think that's a massive issue
[14:14:03] *** Quits: Earnestly (earnest@639E83C4.94D0CBFF.5411983D.IP) (Ping timeout)
[14:14:22] *** Joins: sp3d (a@moz-49806493.dhcp.stls.mo.charter.com)
[14:14:28] *** Joins: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[14:14:39] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[14:14:59] <doener> probably not
[14:16:56] *** kimundi is now known as zz_kimundi
[14:18:52] <dcolish> is anyone else seeing this test failure off master? https://gist.github.com/dcolish/5858782
[14:19:15] *** Quits: jclements (jclements@moz-20AD2EFB.dsl.static.sonic.net) (Quit: jclements)
[14:20:48] *** Quits: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP) (Client exited)
[14:25:01] *** Quits: sp3d (a@moz-49806493.dhcp.stls.mo.charter.com) (Ping timeout)
[14:25:25] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[14:25:25] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14fd396e1 to 147aee5da: 02http://git.io/N3iJvQ
[14:25:25] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[14:25:25] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[14:25:25] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/qTgXrA
[14:25:25] <ghrust> 13rust/06auto 140cca08a 15James Miller: Add support for #[no_drop_flag] attribute
[14:25:25] <ghrust> 13rust/06auto 14d9f6dd2 15James Miller: Set #[no_drop_flag] on Rc<T> and AtomicOption. Add Test
[14:25:25] <ghrust> 13rust/06auto 14721164d 15James Miller: Zero the struct in the take glue, not the drop glue
[14:25:27] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[14:26:58] *** Quits: dbaupp (Thunderbir@moz-73E90475.lns20.syd6.internode.on.net) (Ping timeout)
[14:31:40] *** Joins: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu)
[14:33:40] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[14:38:18] <cmr> doener: I'm using the 3.10 rc and the intel_pstate driver, seems it doesn't work with cpupower right now, but there's a handy no_turbo file in /sys/devices/system/cpu/intel_pstate :p
[14:39:25] <cmr> on the plus side with all this down time I can fiddle with matplotlib instead of using dbaupp's useful but slow (and incoherent, to me, a non-R person) R script
[14:42:18] <cmr> doener: on the downside, it makes the compile almost 30% slower!
[14:43:11] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[14:43:19] <doener> stupid modern cpu designs :-p
[14:43:39] *** Joins: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP)
[14:43:46] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[14:44:22] *** Quits: xazax (Mibbit@6655692F.3B222813.3F580572.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[14:44:44] *** Joins: xAZAX (Mibbit@6655692F.3B222813.3F580572.IP)
[14:45:09] *** xAZAX is now known as xazax
[14:45:13] *** Quits: Blei (philipp@moz-4E4B9A0A.ethz.ch) (Quit: WeeChat 0.4.1)
[14:47:20] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Client exited)
[14:47:41] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[14:47:42] <cmr> yup, disabling turbo reduces variance to within 100ms across 3 runs
[14:49:26] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Ping timeout)
[14:53:32] <doener> my eyes haven't adjusted to the change from T_ptr() to .ptr_to() yet. Took me a dozen tries to spot that call
[14:54:45] <heftig> cmr: doesn't work with cpupower?
[14:55:16] <cmr> heftig: well the userspace governor seems borken so you can't set the frequency anymore. which makes sense, given it's a pstate driver
[14:55:33] <heftig> the only available governors for that driver are "powersave" and "performance"
[14:55:45] <cmr> right
[14:58:13] <bjz_> mark_edward: ping
[15:05:21] <cmr> nmatsakis: ping
[15:06:36] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[15:08:18] <illissius> cmr: I'm looking at your DenseStringInterner gist, and I'm probably just dense, but I'm seriously confused by the hash-incrementing thing. why would the string at a given offset ever change? and why does incrementing the *hash* help? what basis is there to believe that hash+n for not-enormously-large n is in the map, and bears any relation whatsoever to the original hash? (the point of a hash function presumably being to ensure otherwise..
[15:08:20] <illissius> .)
[15:08:43] <cmr> illissius: graydon wrote it actually.
[15:08:49] <cmr> illissius: I think it's for hash collisions.
[15:09:01] <cmr> when there's a collision, increment and pray nothing collides with that new one..
[15:09:41] *** Quits: KindOne (KindOne@E313C970.A337191.EC6A1518.IP) (Ping timeout)
[15:11:09] <cmr> Which, in practice, hopefully works, since the default hash is afaik uniformly random
[15:11:10] *** Joins: KindOne (KindOne@E313C970.A337191.EC6A1518.IP)
[15:12:05] <cmr> and given the hash space is 2^64, two hashes being that close to each other is rare, on top of the rarity of a collision
[15:12:10] <cmr> You'd have to ask graydon though
[15:12:11] *** Joins: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com)
[15:12:13] <illissius> but.. it only does that in find() (looks for hash+n in the map, which afaict never gets put there by anyone). if there's a hash collision it'll presumably mean the string never actually gets interned in intern()
[15:12:35] <illissius> oh hm
[15:12:38] <illissius> but intern() uses find()
[15:12:41] <illissius> so maybe that.
[15:12:44] <cmr> oh poo you're right I think
[15:14:52] <cmr> nmatsakis: ohhhhhh I had a really bonehead error. I was using absolute path to rustc.rc in my script, rather than relative, which of course broke when I made a dir specifically for benches.
[15:16:52] *** Joins: jclements (jclements@43CB6079.66715431.D25A875A.IP)
[15:23:46] <illissius> cmr: present understanding: if intern()ing a string that causes a hash collision, in find() it'll detect the collision, check hash+1, presumably not find it, return None, then intern() will see that the string's not interned yet, and proceed to overwrite the offset of the old string in the map with the new one
[15:24:03] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[15:24:08] <illissius> I think it'd all fit together if intern() also used hash+1 as the key in that case, but it doesn't
[15:24:16] <illissius> how do you file a bug report on a gist? :p
[15:24:52] *** Quits: pnkfelix (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net) (Quit: Leaving.)
[15:25:52] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[15:25:52] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[15:26:09] *** Quits: bytbox (s@moz-2E27684C.student.umd.edu) (Ping timeout)
[15:26:53] *** zz_kimundi is now known as kimundi
[15:28:33] *** Quits: pnkfelix|rcirc (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net) (Input/output error)
[15:29:38] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[15:29:43] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[15:29:51] *** Joins: eholk (eholk@moz-786AC74A.uconnect.utah.edu)
[15:31:30] <illissius> cmr: anyway I left a comment.
[15:31:37] *** Joins: snearch (snearch@moz-F0F2CD7E.pool.mediaways.net)
[15:32:37] <cmr> illissius: thanks for looking it over :)
[15:34:47] *** Quits: Sodel_the_V (user@moz-853663E1.va.shawcable.net) (Quit: Eaten by a grue)
[15:35:24] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[15:37:02] <jedestep> need some help resolving a circular dependency like so: https://gist.github.com/jedestep/5859425
[15:37:38] <doener> jedestep: use foo::Foo; and use bar::Foo;
[15:37:43] <doener> err, use bar::Bar;
[15:38:07] <doener> jedestep: https://github.com/mozilla/rust/issues/3352
[15:38:31] <jedestep> thanks
[15:39:15] <jedestep> i'm assuming that use foo::* is intended to work here?
[15:40:02] *** Joins: bent (chatzilla@moz-932324BF.hsd1.ca.comcast.net)
[15:40:55] <cmr> nmatsakis: http://i.imgur.com/KbB9NmO.png
[15:41:01] <cmr> nmatsakis: guess which one is yours :)
[15:41:22] <doener> cmr: for which change is that?
[15:41:35] <doener> ffi?
[15:41:38] <cmr> doener: nikomatsakis/ref-bindings-in-irrefut-patterns
[15:42:22] <erickt> cmr: what are those axis?
[15:42:28] <doener> time and memory
[15:42:36] <cmr> in bytes and seconds
[15:42:48] <erickt> neat!
[15:43:03] <cmr> once I figure out how to, I'll add axis labels, a grid, and a legend :p
[15:45:56] <bjz_> ugh http://www.xmlsoft.org/html/libxml-xmlerror.html#xmlError
[15:46:28] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[15:46:28] <bjz_> a C compiler chooses the size of an enum right?
[15:47:05] <cmr> yes
[15:47:20] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[15:47:24] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[15:47:35] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[15:49:11] *** Quits: xazax (Mibbit@6655692F.3B222813.3F580572.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[15:57:29] *** Quits: fabiand (fabiand@moz-62D4E7B1.adsl.alicedsl.de) (Quit: Verlassend)
[15:57:52] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[15:57:57] <acrichto> r? https://github.com/mozilla/rust/pull/7371
[15:58:08] *** Quits: wilfred (uid159@moz-C944F5EC.irccloud.com) (Ping timeout)
[15:59:11] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz)
[15:59:26] *** Quits: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com) (Client exited)
[16:01:10] *** Joins: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net)
[16:01:24] <cmr> acrichto: did you rebase it? I feel like I already r+'d that...
[16:01:31] <acrichto> cmr: yeah, it conflicted
[16:01:40] <cmr> ok, I'm not going crazy :)
[16:01:44] <acrichto> thanks!
[16:02:55] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Quit: Computer has gone to sleep.)
[16:03:01] *** Quits: pyrac (pyrac@moz-C4B13AD4.math.u-bordeaux1.fr) (Ping timeout)
[16:04:55] *** Joins: tjc (tjc@moz-D530ECE9.lightspeed.irvnca.sbcglobal.net)
[16:04:55] *** ChanServ sets mode: +o tjc
[16:05:24] <toddaaro> is the rust meeting in a different room today?
[16:06:29] *** Quits: bnicholson (bnicholson@moz-E98974C1.hsd1.ca.comcast.net) (Ping timeout)
[16:06:44] *** Joins: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP)
[16:07:35] <toddaaro> looks like not
[16:07:47] *** Joins: eschweic (Adium@2557E599.66715431.D25A875A.IP)
[16:08:22] *** Joins: dherman (dherman@2557E599.66715431.D25A875A.IP)
[16:08:22] *** ChanServ sets mode: +o dherman
[16:08:57] *** Joins: dualhbridge (dad@moz-9FEE6D3B.maine.res.rr.com)
[16:09:07] *** Parts: dualhbridge (dad@moz-9FEE6D3B.maine.res.rr.com) ()
[16:09:39] *** Joins: azita (Azita@2557E599.66715431.D25A875A.IP)
[16:10:22] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[16:10:36] <sully> doener: pong
[16:10:47] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[16:10:47] *** ChanServ sets mode: +o brson
[16:11:05] *** Joins: ecr (ereed@2557E599.66715431.D25A875A.IP)
[16:11:35] <doener> sully: you removed the cast for self, right? Is that code anywhere where I could have a look at it?
[16:12:02] <doener> sully: or more specifically, did that involve monomorphization of llenv?
[16:12:56] *** Quits: snearch (snearch@moz-F0F2CD7E.pool.mediaways.net) (Quit: Verlassend)
[16:14:42] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Quit: jedestep)
[16:14:44] *** Joins: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP)
[16:15:22] <sully> I'm going to push it soon
[16:15:24] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[16:15:25] <sully> it doesn't really change that much
[16:15:46] <doener> so llenv is still an opaque box pointer?
[16:16:13] *** Quits: xLII (xLII@4BED3CB3.F5F53E8A.2D6DB75E.IP) (Ping timeout)
[16:16:38] <jdm> do we have some kind of file-inclusion macro?
[16:16:44] <jdm> or syntax extension or something?
[16:16:53] <doener> I'm asking because llenv being a pointer is kind of a problem when resolving the double indirection for self
[16:16:55] <cmr> I thought we had include!()
[16:17:02] *** Joins: mib_mneisb (Mibbit@moz-1187195B.adsl.alicedsl.de)
[16:17:08] <cmr> But it may have been removed, I haven't seen any recent code use it I think
[16:17:52] <jdm> it does seem to exist in tests
[16:18:12] <doener> guess I'll just switch sty_value to ByRef for now
[16:22:43] *** Joins: bnicholson (bnicholson@2557E599.66715431.D25A875A.IP)
[16:23:04] <sully> doener: yeah
[16:23:09] *** Quits: mib_ri19yr (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[16:23:59] <bblum> https://etherpad.mozilla.org/Meeting-weekly-2013-06-25
[16:25:01] *** Quits: bnicholson (bnicholson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[16:25:04] <doener> yay, that seems to work... Should have tried that earlier, after all I already knew about the problems with self-by-value
[16:26:47] <erickt> Luqman: ping
[16:27:17] <nmatsakis> cmr: uh, which one is mine? :)
[16:27:17] <bstrie> hmm
[16:27:21] <cmr> nmatsakis: green!
[16:27:29] *** Joins: Sodel_the_V (user@moz-853663E1.va.shawcable.net)
[16:27:32] <bstrie> is .each completely excised?
[16:27:33] <nmatsakis> cmr: really! neat. :) time to r+ then!
[16:27:35] <cmr> nmatsakis: the bigger memory peak is because more code is being generated
[16:27:37] <erickt> doener: Luqman had a patch that changed sty_value to be ByRef, and ran into some issues with it
[16:27:47] <cmr> nmatsakis: and the librustc binary with your PR is 15MB, as opposed to 11MB before
[16:28:11] <cmr> nmatsakis: I can't help shake the feeling that the measurement is off though. Did you expect to see a good time win?
[16:28:17] <nmatsakis> cmr: huh. when I checked the total memory generated, it looked...like *somewhat* more but not a lot. No idea why that would increase binary size to 15 MB.
[16:28:21] <nmatsakis> cmr: to be honest, no.
[16:28:28] <nmatsakis> cmr: in fact I expected it to be about the same
[16:28:36] <nmatsakis> cmr: that's what I observed locally anyhow
[16:28:59] <bstrie> haha, well isrustfastyet seems to have calmed down a little bit
[16:29:01] <cmr> I will measure again
[16:29:11] <doener> erickt: https://github.com/mozilla/rust/pull/6725 this one?
[16:30:42] <thiez> bstrie: it surprises me how well linux-64-opt-vg is doing
[16:30:50] <thiez> for compile, not the testsuite
[16:31:22] <bstrie> thiez: which one is vg?
[16:32:41] <thiez> http://huonw.github.io/isrustfastyet/all.html
[16:32:46] <thiez> the yellow one
[16:33:08] <erickt> doener: I *think* that's the one
[16:33:38] <doener> cmr: you have a 11MB librustc? Mine's been 15MB for quite a while (actually shrinking recently)
[16:34:55] <cmr> nmatsakis: actually nevermind you just increased from 14MB to 15MB :p
[16:34:57] *** Joins: pnkfelix1 (pnkfelix@moz-43495417.fbx.proxad.net)
[16:35:02] <bstrie> "I think Rust calling Algebraic Data Types enum was a really really good idea." <-- I admit I was surprised to hear this
[16:35:17] <cmr> doener: I was measuring from the librustc from strcat's package, which must be stripped or something
[16:35:25] <cmr> which was wrong to measure against
[16:35:35] <thiez> cmr: tried stripping nmatsakis's binaries?
[16:35:36] <doener> ah
[16:35:44] <thiez> that sounds weird oO
[16:35:58] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Ping timeout)
[16:36:49] *** Joins: xLII (xLII@4BED3CB3.F5F53E8A.2D6DB75E.IP)
[16:37:06] *** Quits: Sodel_the_V (user@moz-853663E1.va.shawcable.net) (Quit: Eaten by a grue)
[16:37:17] *** Joins: lmandel (lmandel@F2D29657.F60B0462.67AC9B1.IP)
[16:37:46] <thiez> we're getting rid of *mut?
[16:37:54] <thiez> the weekly meetings always surprise me ><
[16:37:58] *** Joins: tav (tav@moz-F7A78BD6.zone7.bethere.co.uk)
[16:38:37] <friggle> surely there's ~mut?
[16:38:41] *** Joins: sp3d (a@moz-49806493.dhcp.stls.mo.charter.com)
[16:38:44] <cmr> there is no mut
[16:38:46] <cmr> ~mut
[16:38:51] <thiez> eh
[16:38:51] <friggle> cmr: why not?
[16:38:55] <cmr> inherits the mutability of its container
[16:38:55] <thiez> I meant *mut
[16:39:21] <cmr> friggle: it's owned, there's no reason to have it. there's "let mut" and "mut name: ~type" in args
[16:39:28] *** Joins: bnicholson (bnicholson@2557E599.66715431.D25A875A.IP)
[16:39:43] <friggle> cmr: that makes sense, thanks
[16:40:22] <cmr> friggle: since no one else can mutate it, there are no restrictions on what you can do with a ~type, at least none that the soundness of the type system depend on
[16:42:01] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[16:42:01] *** Joins: Kruppe (user@moz-4DDA8AB8.uwaterloo.ca)
[16:42:06] *** Quits: tav (tav@moz-F7A78BD6.zone7.bethere.co.uk) (Quit: tav)
[16:42:16] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[16:42:53] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[16:44:28] <thiez> INHTWAMA is one of the best things that happened to Rust :D
[16:44:29] *** Quits: bytbox (s@moz-D83E9B31.wireless.umd.edu) (Ping timeout)
[16:44:41] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[16:45:25] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[16:46:23] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[16:46:23] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/qTgXrA
[16:46:23] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[16:46:35] <joelteon> INHTWAMA
[16:47:03] *** Joins: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net)
[16:47:12] *** Quits: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[16:47:46] <bstrie> INHTMAWA
[16:48:02] <joelteon> what does that stand for
[16:48:20] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[16:48:23] <cmr> http://smallcultfollowing.com/babysteps/blog/2012/11/18/imagine-never-hearing-the-phrase-aliasable/
[16:48:24] <thiez> the end of the dark ages :p
[16:48:41] <bstrie> joelteon: it's an anagram for "INHTWAMA NHTWAMA HTWAMA TWAMA WAMA AMA MA A"
[16:48:49] <joelteon> which is what
[16:49:07] <thiez> it means we lost mutable slots in structs, but gained a better typesystem
[16:49:20] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[16:49:20] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/9Sfdbg
[16:49:20] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[16:49:24] <joelteon> Imagine Never Hearing The Mhrase Aliasable, Wutable Aata?
[16:49:54] <thiez> yes, the acronym is incorrect.
[16:49:54] <bstrie> joelteon: soon after posting everyone forgot what the actual anagram was
[16:49:59] <bstrie> er
[16:50:02] <bstrie> dang it
[16:50:03] <joelteon> oh
[16:50:04] <bstrie> acronym
[16:50:07] <joelteon> so it's INHTPAMA
[16:50:15] <joelteon> that's catchy
[16:50:31] <bstrie> basically just type a jumble of uppercase laters, as long as the first character is I we'll know what you mean
[16:50:34] <bstrie> IHADSTHA
[16:50:40] *** Joins: Kauhsa (kauhsa@moz-A78B2D1A.fi)
[16:51:28] <thiez> it must start with IN, then one of the next two characters must be a T, and it must end with AMA. apart from that you can choose any all-caps character sequence you like :p
[16:51:57] *** Joins: echristo (echristo@60A74940.D6CCE4AE.77834EAA.IP)
[16:52:01] <cmr> INHTWAMA is what I thought it was
[16:52:04] <thiez> regardless, the blog post is interesting to read
[16:52:10] <cmr> imagine never hearing the words alaiasable, mutable again
[16:52:19] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[16:52:19] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/9Sfdbg
[16:52:19] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[16:52:19] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[16:52:20] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/lmV2vg
[16:52:20] <ghrust> 13rust/06auto 143753278 15Ramkumar Ramachandra: resolve: report duplicate module definitions...
[16:52:20] <ghrust> 13rust/06auto 14f8a76f1 15Ramkumar Ramachandra: resolve: make error message strings more consistent...
[16:52:20] <ghrust> 13rust/06auto 14a48bd3f 15bors: auto merge of #7325 : artagnon/rust/resolve-module, r=cmr...
[16:52:21] <thiez> that works.
[16:52:21] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[16:53:01] <friggle> inhtwama...I dreamed a dream
[16:53:49] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[16:53:51] <indutny> cmr: just FYI I'm working on public api for mmap
[16:54:01] <indutny> unifying it for both win32 and unixes
[16:54:06] <cmr> indutny: Ohh, that's fancy
[16:54:18] <indutny> lets see how it'll go :)
[16:54:21] <indutny> but yeah, so far looks good
[16:54:31] *** Joins: Blei (philipp@moz-650B9C6A.cust.bluewin.ch)
[16:54:51] <friggle> I think libapr managed it
[16:55:01] <indutny> friggle: ?
[16:55:17] <indutny> probably yes
[16:55:19] <indutny> are we bundling it?
[16:55:46] <cmr> no
[16:55:46] <indutny> mingw also managed it :)
[16:55:48] <friggle> indutny: an mmap for win32+unix. No we're not, just mentioned it as an existence proof that a useful subset of windows and unix mmap-like functionality seems achievable :)
[16:55:51] <cmr> it's the apache portable runtime
[16:55:58] <indutny> I know
[16:56:07] <indutny> friggle: surely yes
[16:56:14] <indutny> I've already mapped all required bindings from winapi
[16:56:22] <indutny> now I'll unify all this stuff under a sane API
[16:56:34] <Blei> also: boost
[16:56:38] <indutny> so many of them
[16:56:51] *** Quits: eholk (eholk@moz-786AC74A.uconnect.utah.edu) (Quit: eholk)
[16:57:35] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[16:59:00] *** Joins: eholk (eholk@moz-786AC74A.uconnect.utah.edu)
[16:59:23] *** Quits: bytbox (s@moz-D83E9B31.wireless.umd.edu) (Ping timeout)
[17:00:49] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[17:03:11] *** Quits: jclements (jclements@43CB6079.66715431.D25A875A.IP) (Quit: jclements)
[17:03:20] *** Quits: ecr (ereed@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[17:03:21] *** Quits: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP) (Quit: eatkinson)
[17:03:21] *** Quits: eschweic (Adium@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[17:03:24] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[17:04:45] <eholk> what happened to ptr::addr_of?
[17:04:53] *** Quits: pnkfelix1 (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[17:05:12] <cmr> eholk: is it ptr::offset now? what was addr_of?
[17:05:35] <eholk> oh, maybe it's ptr::to_unsafe_ptr
[17:05:36] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[17:05:36] *** Joins: mschifer (Adium@2557E599.66715431.D25A875A.IP)
[17:06:17] <eholk> also, what happened to fail?
[17:06:19] <kimundi> eholk: ptrs can be cast/coerce to uints directly afaik
[17:06:25] <cmr> fail!() still exists
[17:06:30] <kimundi> eholk: IT's fail!() now
[17:06:35] *** Joins: ecr (ereed@2557E599.66715431.D25A875A.IP)
[17:06:38] <eholk> ah, cool
[17:07:24] *** Joins: pyrac (pyrac@moz-9180E00E.w86-201.abo.wanadoo.fr)
[17:07:24] <bjz_> cmr: you can use cast::transmute for converting a borrowed pointer to an unsafe pointer
[17:07:28] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[17:07:38] *** Joins: eschweic (Adium@2557E599.66715431.D25A875A.IP)
[17:07:51] <cmr> bjz_: don't tell me, tell eholk :p
[17:07:53] *** Joins: jclements (jclements@43CB6079.66715431.D25A875A.IP)
[17:07:55] *** Joins: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP)
[17:07:56] <kimundi> bjz_, cmr doesn't &T coerce to *T ?
[17:07:59] *** Joins: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP)
[17:08:14] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[17:08:33] <cmr> I don't know
[17:08:58] <Blei> rusti: let a: *int = &5; a
[17:09:43] *** Quits: tjc (tjc@moz-D530ECE9.lightspeed.irvnca.sbcglobal.net) (Quit: zzzzzzzzzz)
[17:10:02] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Ping timeout)
[17:10:42] <eholk> why aren't trait bounds allowed in structure types anymore?
[17:10:49] *** Joins: Sodel_the_V (user@moz-853663E1.va.shawcable.net)
[17:11:37] <cmr> eholk: because they aren't useful, you can't do anything with them. you can parameterize on the impl, or use trait objects
[17:11:53] <cmr> (aren't useful because of monomorphization, that is)
[17:12:13] *** Joins: MaikKlein (maik@moz-3D9AD16.dip0.t-ipconnect.de)
[17:12:26] <eholk> hmm... okay
[17:12:49] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[17:12:49] *** ChanServ sets mode: +o brson
[17:13:57] *** Joins: dylukes (dylukes@moz-B5418F79.hsd1.pa.comcast.net)
[17:13:59] <bblum> cmr: eholk: i am not convinced that's true
[17:13:59] *** Quits: dylukes (dylukes@moz-B5418F79.hsd1.pa.comcast.net) (Quit: dylukes)
[17:14:06] <bblum> i mean
[17:14:07] <bblum> i dunno
[17:14:25] <bblum> consider Sized. in the future, it might be possible to store an unsized thing at the end of a struct
[17:14:32] <bblum> like Foo { x: int, y: [u8] }
[17:14:44] <bblum> but what if you write struct Foo<T,U> { x: T, y: U } ?
[17:14:53] <eholk> If nothing else, I like the documentation you get from putting trait bounds on a struct
[17:14:58] <bblum> you can make this work by checking the kinds at the construction type of the struct
[17:15:09] <bblum> but that's confusing to people
[17:15:30] <bblum> it would be more obvious, and the kind-check would be more straightforward, if it were checked at struct definition time, 
[17:15:32] <MaikKlein> what are traitbounds? are they foo<T: Clone + Copy> ?
[17:15:38] <cmr> MaikKlein: yep
[17:15:39] <bblum> MaikKlein: yeah
[17:16:33] <cmr> eholk: actually it might be useful, now that I think about it.
[17:16:49] <cmr> eholk: I don't know why they were removed :p
[17:18:24] <kimundi> what else would it be usefull besides Sized and additional documentation?
[17:19:00] <cmr> no sure, but I'm not convinced it's *useless*
[17:19:22] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[17:19:22] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/Y0cQ_g
[17:19:22] <ghrust> 13rust/06auto 1462ccae2 15Michael Sullivan: Fix another generics bug with default methods. Closes #7295.
[17:19:22] <ghrust> 13rust/06auto 14899239d 15bors: auto merge of #7356 : msullivan/rust/default-methods, r=bblum...
[17:19:22] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[17:20:19] *** Joins: pcwalton (pcwalton@43CB6079.66715431.D25A875A.IP)
[17:20:19] *** ChanServ sets mode: +o pcwalton
[17:20:21] <eholk> bblum: i think this might be cheating, but I got 24 in a row: https://gist.github.com/eholk/5860368
[17:20:49] <thiez> eholk: that parses?
[17:20:56] <bblum> eholk: this strikes me as cheating
[17:21:07] <bblum> you can get arbitrarily many like that right
[17:21:13] <bblum> like you could put some unicode in there too
[17:21:30] <bblum> eholk: i think the challenge is for each of the sigils to have semantic/syntactic meaning
[17:21:31] <eholk> yeah, probably
[17:22:31] <pcwalton> jdm: replied to your comment on https://github.com/tkuehn/servo/commit/4d878137e86b24442409edb9d394368ae15409b8#commitcomment-3500847
[17:23:09] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[17:23:13] <eholk> bblum: yeah, i think this is basically the same as the string trick. Fortunately, we know what to rule out better now.
[17:23:24] <bblum> the string trick?
[17:23:29] <bblum> putting some in a string?
[17:23:34] <eholk> yeah
[17:24:02] <sully> or a comment
[17:24:13] <bblum> that's also clearly cheating
[17:24:21] <cmr> nmatsakis: so I ran some more trials and everything is http://i.imgur.com/Wfyayu7.png
[17:25:01] <cmr> nmatsakis: so ignoring the 3 obvious outliers, you are slower and with more memory.
[17:26:09] <eholk> did vec.each go away?
[17:26:15] <cmr> eholk: yes
[17:26:24] <cmr> eholk: for vec.iter().advance |x| { ... }
[17:26:25] <thiez> use 'for vec.iter().advance'
[17:26:32] <eholk> wait, seriously?
[17:26:36] <MaikKlein> yes
[17:26:43] <cmr> http://cmr.github.io/blog/2013/06/22/this-week-in-rust/ "Breaking changes"
[17:27:29] *** Joins: igl (igl@moz-AB9DA8DE.adsl.alicedsl.de)
[17:27:35] <bstrie> eholk: eventually the idea is to reduce that to `for vec |x| {`
[17:27:48] <kimundi> eholk: The for protocol will probably be changed so instead of 'for vec.iter().advance' you can write 'for vec'
[17:27:48] <pcwalton> or for x in vec { ... }
[17:27:49] <bstrie> eholk: just one of those awkward transition stages right now
[17:27:54] <eholk> that's scarily reminiscent of stuff like for(std::vector::const_forward_iterator i = x.begin() like we do in C++
[17:27:57] *** Joins: bytbox (s@moz-2E27684C.student.umd.edu)
[17:28:03] <eholk> oh, okay, that's better
[17:28:35] <nmatsakis> cmr: ok, thanks!
[17:28:39] <MaikKlein> i would definitely like for x in vec
[17:28:56] <cmr> MaikKlein: I'm not sure I prefer it anymore
[17:29:09] <MaikKlein> cmr, why not?
[17:29:14] <cmr> Someone in reddit made the very good point that for expr |pat| { ... } flows very well from left to right
[17:29:18] <cmr> and I agree
[17:29:39] <MaikKlein> for x in vec is very math like
[17:29:45] <cmr> even though I dislike using || outside of closures
[17:29:49] <MaikKlein> i element Integer
[17:30:12] *** Quits: CarpNet (ac@moz-FD24B77.sohonet.co.uk) (Quit: Leaving)
[17:31:07] <kimundi> n
[17:31:09] *** Quits: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP) (Ping timeout)
[17:31:09] <kimundi> :P
[17:31:12] <MaikKlein> :D
[17:31:40] <bblum> i feel like UnsafeAtomicRcBox should be called UnsafeARC
[17:31:42] <cmr> I'd much rather not: http://i.imgur.com/VPBqVCh.png
[17:31:46] <bstrie> MaikKlein: saying that something is math-like is a damning statement
[17:31:48] <bblum> i quite like ARC as a name
[17:31:54] <bstrie> now we definitely can't do it
[17:32:00] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[17:32:40] <bstrie> MaikKlein: http://quotes.burntelectrons.org/6221
[17:32:58] <eholk> kimundi: you could probably get close to that syntax in a macro
[17:33:07] <MaikKlein> bstrie, haha
[17:33:29] <kimundi> depends on wether rustc likes arbitrary unicode tokens
[17:34:11] <kimundi> I mean you can already do 'let  = 3.14;'
[17:34:18] <eholk> in macros they're fine
[17:34:20] <MaikKlein> what
[17:34:27] <eholk> you have a lot of freedom with your syntax in macros
[17:34:33] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[17:34:43] <MaikKlein> rusti: let  = 3.14;
[17:34:52] <kimundi> eholk: Sure, but rustc still needs to accept them as valid tokens afaik
[17:34:52] <MaikKlein> rusti: let  = 3.14; 
[17:35:04] <MaikKlein> rusti: "test test"
[17:35:06] <bstrie> rusti isn't here right now
[17:35:06] <kimundi> rusti is not here sadly :(
[17:35:09] <MaikKlein> T_T
[17:35:23] <bstrie> MaikKlein: ...do you not use tab-completion on usernames? :P
[17:35:37] *** Quits: echristo (echristo@60A74940.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[17:35:52] *** Quits: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk) (Client exited)
[17:35:55] <eholk> kimundi: oh, right. the forall symbol may not be legal in an identifier
[17:36:00] <MaikKlein> bstrie, for some reason I don't use it for rusti :D
[17:36:33] <MaikKlein> wow this really works let  = 3.14;
[17:36:34] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[17:36:34] *** ChanServ sets mode: +o brson
[17:36:55] <bstrie> MaikKlein: yes, we allow unicode identifiers
[17:37:14] <bstrie> MaikKlein: that *doesn't* mean we allow the entirety of unicode in identifers. just a lot of it
[17:37:16] <Blei> _some_ unicode identifiers
[17:37:35] <bstrie> XID_START[XID_CONTINUE]*
[17:37:46] <jclements> Blei: I think we do a pretty good job of conf right. What bstrie said.
[17:37:50] <cmr> Blei: no, all of them
[17:37:50] <bblum> yeah, the flip table bug was closed wontfix :(
[17:37:59] <kimundi> let  = |x| x * math::; (45)
[17:38:03] *** Joins: fuogo (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP)
[17:38:30] <bblum> uh oh, time for a vim conceal rule that changes |x| to x.
[17:38:46] <sully> uh.
[17:39:17] * sully adds a depth cutoff to type_to_str
[17:39:46] <kimundi> let foo = lambda!(  x y = x + y ); foo(45, 96) // ;)
[17:41:40] <engla> I already suggest you use greek script in macros to avoid variable name collisions
[17:42:14] <jclements> engla: uggh! you're killing me! mustworkfasteronhygiene.
[17:42:50] <Blei> so, i wrote a patch that removes nearly all llvm lint output
[17:42:59] <Blei> but it doesn't really seem to generate better code
[17:43:02] <MaikKlein> let b = true
[17:43:04] <MaikKlein> haha
[17:43:30] <Blei> compile time for rustc stayed pretty much the same, the resulting librustc*.so was 30k bigger than before
[17:43:46] <kimundi> macro_rules! m( () => ( let (, ) = helper(); let  = .bar( + 89); ... ) )
[17:43:51] <eholk> kimundi: did you see the lambda calculus interpreter macro I wrote last summer?
[17:43:53] <Blei> err, 14k bigger
[17:43:59] <cmr> Blei: does it remove undef behavior?
[17:44:02] <MaikKlein> why do we allow greek symbols? I don't even know one keybinding 
[17:44:08] *** Joins: seth (seth@moz-D840E602.dsl.static.sonic.net)
[17:44:08] <kimundi> eholk: No, but I knew that it exists
[17:44:09] <cmr> MaikKlein: because unicode.
[17:44:11] <MaikKlein> well ok i know 
[17:44:25] <eholk> i used  for the syntax for lambda abstraction :)
[17:44:30] <engla> I'm just working on quickcheck and thinking about the nicest way to have a lazy list in rust
[17:44:44] <Blei> cmr: you mean the illegal instruction bug? not sure, but i very much doubt it
[17:44:45] <kimundi> engla: ITerators?
[17:44:47] <MaikKlein> cmr, so this will stay?
[17:44:48] <Blei> i'll try it
[17:45:06] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[17:45:12] <cmr> MaikKlein: yeah, unicode isn't going anywhere..
[17:45:38] <MaikKlein> now I am scared of greek programmers :X
[17:46:35] <Sodel_the_V> MaikKlein: Don't be. :)
[17:46:43] *** Joins: Earnestly (earnest@E7C44CA8.F365B115.4FA5093E.IP)
[17:47:16] <kimundi> fn nor_implies(a: bool, b: bool, c: bool) { (a  b)  c }
[17:47:18] <MaikKlein> fn () {}; :X
[17:47:19] <Blei> cmr: nope, no change
[17:47:42] <engla> kimundi: not sure. to begin with,   fn shrink(&self) -> ~[Self]; is fine in a trait but you can't just say   -> Iterator<Self>. I haven't really tried though
[17:49:11] *** Joins: carllerche (carllerche@moz-CDE5367B.dsl.static.sonic.net)
[17:49:20] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[17:49:20] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14899239d to 14d161e63: 02http://git.io/N3iJvQ
[17:49:20] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[17:49:22] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[17:49:23] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/fEtzcA
[17:49:23] <ghrust> 13rust/06auto 1442b44b2 15Alex Crichton: Rename all files with the 'rc' extension
[17:49:23] <ghrust> 13rust/06auto 1492424f0 15Alex Crichton: Add the `warnings` lint attribute
[17:49:23] <ghrust> 13rust/06auto 14032dcc5 15bors: auto merge of #7371 : alexcrichton/rust/trying, r=cmr...
[17:49:24] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[17:51:48] *** Quits: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP) (Client exited)
[17:53:11] *** Quits: pyrac (pyrac@moz-9180E00E.w86-201.abo.wanadoo.fr) (Quit: pyrac)
[17:53:57] *** Quits: seth (seth@moz-D840E602.dsl.static.sonic.net) (Ping timeout)
[17:56:00] <MaikKlein> haha now I want to work for mozilla https://twitter.com/eassumption/status/185082256535203841/photo/1
[17:56:48] <kimundi> I KNEW that would be the Justin Bieber pic ... 
[17:56:52] <kimundi> :D
[17:57:03] <Blei> heh, with -O, the size differenc shrinks down to 3k, with the non-lint-output variant still being bigger
[17:57:54] <Blei> what. why?
[17:58:18] <mark_edward> bjz_: ping
[17:58:47] *** Joins: wilfred (uid159@moz-C944F5EC.irccloud.com)
[17:59:11] *** Joins: pyrac (pyrac@moz-9180E00E.w86-201.abo.wanadoo.fr)
[18:01:08] <bblum> check it.
[18:01:09] <bblum> syn match rustLambdaStart /|\w\w*/me=s+1 contained conceal cchar=
[18:01:09] <bblum> syn match rustLambdaEnd   /\w\w*|/ms=e-0 contained conceal cchar=.
[18:01:09] <bblum> syn match rustLambda      /|\w\w*\(\s*,\s*\w\w*\)*|/ contains=rustLambdaStart,rustLambdaEnd
[18:01:30] <cmr> do you actually use conceal?
[18:01:58] <bblum> i do now
[18:02:09] *** Joins: yong (chatzilla@74DA0C97.4E87ADC2.263D9828.IP)
[18:02:25] <bblum> i mean, look
[18:02:26] <bblum> vec.map(x. x+1)
[18:02:30] <bblum> VALID RUST
[18:03:06] <cmr> I can't barely read that, let alone comprehend any of its possible meanings
[18:03:35] *** Joins: mw (mw@moz-37671F30.adsl.highway.telekom.at)
[18:05:02] <MaikKlein> is bikeshed a real work?
[18:05:06] <MaikKlein> word*
[18:05:08] <cmr> yes
[18:05:13] <cmr> it is a shed you store bikes in
[18:05:30] *** Joins: nano (nano@moz-972880B.superkabel.de)
[18:05:49] <kimundi> MaikKlein: IT's a shed fer bikes, and it comes in many colors, but none of which people do agree on. ;)
[18:05:49] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[18:07:52] *** Joins: cowboyd (cowboyd@moz-1BD02A1E.sw.biz.rr.com)
[18:09:00] <MaikKlein> ah ok I think I  got it "This is a metaphor indicating that you need not argue about every little feature just because you know enough to do so"
[18:09:05] <MaikKlein> :)
[18:09:38] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[18:09:40] <cmr> https://en.wikipedia.org/wiki/Parkinson%27s_law_of_triviality
[18:09:56] *** Joins: echristo (echristo@D423593A.D6CCE4AE.77834EAA.IP)
[18:11:25] <MaikKlein> I don't understand . . . . they should just paint the shed rust brown
[18:11:45] *** Quits: echristo (echristo@D423593A.D6CCE4AE.77834EAA.IP) (Ping timeout)
[18:11:53] <bblum> MaikKlein: ;)
[18:11:55] *** Joins: echristo (echristo@60A74940.D6CCE4AE.77834EAA.IP)
[18:12:02] *** Quits: spider-mario (spidermari@moz-B8FA2FF4.rev.sfr.net) (Connection reset by peer)
[18:12:07] *** Joins: spider-mario (spidermari@moz-B8FA2FF4.rev.sfr.net)
[18:12:46] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[18:12:46] *** ChanServ sets mode: +o brson
[18:13:33] <bblum> brson: would i be better served reviewing this file-by-file instead of commit-by-commit?
[18:13:42] <sully> hey, I just pushed a pull request with a handful of minor changes and fixes: https://github.com/mozilla/rust/pull/7382
[18:13:44] <bblum> if so what files
[18:13:54] <sully> including eliminating the cast on every reference of self
[18:14:22] <bstrie> < MaikKlein> now I am scared of greek programmers :X
[18:14:30] <bstrie> MaikKlein: I'd like to introduce you to our friend, niko matsakis :P
[18:14:42] <bjz_> MaikKlein: there is also Wadler's law of language design
[18:14:43] <brson> bblum: probably. the runtime entrypoint is `start` in rt/mod.rs. beyond that the most important stuff is in rt/sched.rs and rt/task.rs
[18:15:01] <bjz_> MaikKlein: http://www.haskell.org/haskellwiki/Wadlers_Law
[18:15:39] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[18:15:57] <MaikKlein> bjz_, haha . Lexical syntax of comments
[18:16:35] <bblum> sully: looking
[18:16:38] *** Quits: johns (johns@2557E599.66715431.D25A875A.IP) (Input/output error)
[18:16:42] <MaikKlein> bstrie, why is he greek? :D
[18:16:51] <bblum> brson: any other files? or just sched and task
[18:17:00] <bblum> guess i could look at the diffstat to find out
[18:17:14] <MaikKlein> * d
[18:17:34] <sully> bblum: the PR you approved earlier failed tests, but it looks like it was just because the execution got interrupted
[18:17:38] <MaikKlein> how do you "think" in irc?
[18:17:45] <MaikKlein> ok this question sounds stupid
[18:17:46] <MaikKlein> :D
[18:17:49] <bblum> sully: feel free to r=bblum it
[18:17:49] <doener> /me stuff
[18:17:53] <doener> MaikKlein: ^^
[18:17:53] <MaikKlein> thanks
[18:17:57] <sully> bblum: but I am also fixing the year in the copyright notice, and will r=bblum it
[18:18:41] <brson> bblum: rt/comm.rs contains the pipe types
[18:19:59] <cmr> sully: probably means one of the builds failed somewhere, did you look through *all* the builds?
[18:20:08] <sully> oh, sigh, no
[18:20:23] <acrichto> sully: http://buildbot.rust-lang.org/grid is a good overview
[18:20:38] <cmr> handy
[18:20:41] <acrichto> looks like a 'pub fn main' was missing for one of the windows tests
[18:20:48] <sully> aaaaaaargh.
[18:21:22] <sully> argh, can I stop it from trying to build this?
[18:22:14] <acrichto> why would you want it to not build it?
[18:22:23] <bblum> sully: i probably shouldn't r+ your cleanup pr because i don't understand it
[18:22:31] <bblum> or, well, don't understand 30% of it
[18:22:40] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[18:22:47] <cmr> sully: // xfail-fast
[18:22:48] <sully> because I said to run it again without actually having fixed it
[18:23:01] <acrichto> sully: oh you can delete the comment
[18:23:04] <acrichto> and bors should ignore it
[18:23:12] <cmr> oh
[18:24:12] <sully> bblum: what don't you understand?
[18:24:20] <bblum> sully: the last commit
[18:24:22] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[18:25:19] <sully> ok
[18:25:21] <mark_edward> bjz_:  pingg
[18:25:22] <sully> well, hm
[18:25:26] <sully> brson: ping
[18:25:27] <sully> pcwalton: ping
[18:25:32] <sully> (somebody who understands trans)
[18:25:47] *** Quits: illissius (illissius@moz-19397A63.catv.broadband.hu) (Quit: )
[18:26:18] <acrichto> I think that list of people is very short :(
[18:26:46] *** Quits: MaikKlein (maik@moz-3D9AD16.dip0.t-ipconnect.de) (Ping timeout)
[18:28:09] *** Quits: eholk (eholk@moz-786AC74A.uconnect.utah.edu) (Quit: eholk)
[18:28:24] *** Quits: sk (sk@1696E5A5.E92B26F8.78DD174B.IP) (Quit: Leaving)
[18:28:40] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[18:29:59] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[18:30:07] <jedestep> how can i make just libextra
[18:30:44] <bblum> sully: if you can explain the first hunk, in base.rs
[18:30:58] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[18:31:15] <bblum> then i can r+
[18:34:06] <pcwalton> sully: pong
[18:35:12] <cmr> Does anyone have a codebase that is almost exactly comperable between 0.6 and now? I'd like some fancy graphs comparing 0.6 to 0.7, performance wise. I'm thinking the shootout benches should be fine?
[18:35:13] <sully> looking for a review of a PR that includes some trans stuff
[18:36:22] <sully> pcwalton: the trans changes are fixing the cast on every self reference
[18:40:10] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[18:40:44] <mark_edward> cmr: this is tiny but it did a lot of I/O and number crunching
[18:40:45] <mark_edward> https://github.com/MarkJr94/rusty_feds
[18:40:57] <mark_edward> problem is i added concurrency at ome point
[18:41:04] <sully> bblum: what that first block of diff does
[18:41:26] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[18:41:34] <sully> bblum: is change things so that if we have a self argument, we always cast it, even if it isn't owned
[18:41:45] <cmr> mark_edward: as long as the behavior is roughly equivalent between a version that compiles in 0.6 and a version that compiles at the end of the week, it's fine
[18:41:50] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[18:41:55] *** Quits: lucian (lucian@moz-22A14C6A.cable.virginmedia.com) (Ping timeout)
[18:41:59] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[18:42:09] *** Quits: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP) (Quit: eatkinson)
[18:42:17] <mark_edward> okay. there's only 6 commits and i had updated it. my rustc gets recompiled every day at 5am
[18:42:30] <Blei> cmr: rust-bindgen
[18:42:33] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[18:42:33] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[18:42:41] <Blei> but it's mostly io and clang
[18:42:42] <cmr> mark_edward: Ok, thanks :)
[18:42:45] <sully> bblum: the original comment was a bit misleading, because it "we should do this regardless of whether self is owned"
[18:42:48] *** Quits: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP) (Ping timeout)
[18:42:54] <sully> bblum: but really we only should do the cast regardless
[18:43:06] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[18:43:18] <sully> bblum: we should not copy it to an alloca if it is not owned, and we should definitely not install a cleanup
[18:43:37] <bblum> sully: what is the cast to/from?
[18:44:01] <bblum> i thought you were making the cast unnecessary but this hunk appears to cast more often
[18:44:04] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[18:44:17] <mark_edward> bjz_: pong
[18:44:19] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[18:44:19] *** ChanServ sets mode: +o brson
[18:44:47] <bblum> the alloca and cleanup part is clear
[18:44:50] <sully> bblum: so, the self pointer gets passed in the environment pointer argument
[18:44:58] <sully> bblum: this is stupid, but I'm not fixing it now
[18:45:11] <sully> bblum: so at some point it needs to get casted to the actual self type
[18:45:24] <sully> bblum: I am making it so that we always do that cast exactly once at the start of a method
[18:45:31] <sully> bblum: instead of doing the cast every time self is mentioned
[18:45:57] <cmr> Fancy new plots: http://i.imgur.com/YnfjiWv.png
[18:45:57] <jedestep> is there any way to just build libextra and nothing else?
[18:46:17] <acrichto> jedestep: it depends on libstd, so you'll have to build libstd as well
[18:46:19] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[18:46:19] <cmr> jedestep: there's a make target somewhere but good luck finding it... best bet is to do a make VERBOSE=1 and use the rustc line it spits out
[18:46:43] <jedestep> i'm ok to build libstd as well, just rather not build absolutely everything
[18:47:05] <acrichto> jedestep: if you already have a stage1 compiler built, and you're just tweaking it, you can build with NO_REBUILD=1 with the target 'check-extra-stage1'
[18:47:23] <doener> cmr: nice
[18:47:25] <acrichto> jedestep: that'll build from stage1 the extratest binary 
[18:47:37] *** Quits: novabyte (Instantbir@moz-3E0F9699.cable.virginmedia.com) (Quit: bye bye)
[18:47:47] <jedestep> acrichto: I'll try that thanks :)
[18:48:20] <bblum> sully: ohh, i see
[18:48:36] <jedestep> acrichto: check-extra-stage1 isn't a make target
[18:48:55] <acrichto> jedestep: oh it's check-stage1-extra
[18:48:57] <bblum> sully: i figured it would get monomorphized or something so that self would come in as the right type to begin with
[18:48:58] *** Joins: MaikKlein (maik@moz-3D9AD16.dip0.t-ipconnect.de)
[18:49:02] <bblum> sully: but i guess that's the environment packet fix?
[18:49:39] <sully> yeah, I mean, the handling of self pointers is still stupid
[18:49:45] <bblum> sully: and what's the final hunk, in meth.rs?
[18:50:06] *** Quits: Blei (philipp@moz-650B9C6A.cust.bluewin.ch) (Quit: WeeChat 0.4.1)
[18:50:15] <sully> that is fixing it so that we actually get the self type passed in when translating the method
[18:50:32] <bblum> ah so you know what to cast to?
[18:50:33] <sully> the reason it was being done this way before was because the self type getting passed in was "Self"
[18:50:36] <brson> https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-06-25
[18:50:37] <sully> which is not a real type
[18:50:53] <sully> for default methods
[18:51:30] <bblum> it isn't? seems like without the subst, you'd have to look up what Self mapped to from inside the impl, default or no
[18:53:14] *** Joins: jyasskin_w (jyasskin@DAF66858.C60FE7DC.4065847B.IP)
[18:53:36] <doener> concrete impl methods have the self type set during typechecking
[18:53:54] <bblum> oh *default* methods
[18:53:57] <bblum> not static methods
[18:54:05] <bblum> of course self is not a real type
[18:54:22] <sully> oh, that reminds me that I need to go get static default methods to work at all ever
[18:54:50] <cmr> Heh
[18:55:12] <cmr> That would fix https://github.com/mozilla/rust/issues/7332 and make me very happy
[18:55:31] <bstrie> default methods!!
[18:55:49] <bstrie> default methods are like the second coming of jesus
[18:56:05] <bstrie> we're still waiting, but it sure would be cool if it happened soon
[18:56:21] *** Joins: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP)
[18:56:25] <cmr> :p
[18:56:38] <bblum> if someone could review https://github.com/mozilla/rust/pull/7354 for me i'd be happy
[18:56:42] <bblum> since niko is out
[18:56:52] <bblum> i have 2 other PRs needing review but those contain some controversial design
[18:56:54] <bblum> this one does not
[18:56:57] <cmr> what's the head of it?
[18:57:03] <sully> hm, I think that 7332 is a dupe?
[18:57:10] <bstrie> bblum: github says you need to rebase
[18:57:14] <bblum> arghhhhhhh
[18:57:45] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[18:58:14] *** Quits: azita (Azita@2557E599.66715431.D25A875A.IP) (Quit: azita)
[18:58:37] <sully> oh, I see where we are getting infinite types from
[18:59:01] *** Quits: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP) (Quit: eatkinson)
[18:59:22] <sully> (llvm types)
[18:59:55] <sully> with unsafe pointers, you can have type self reference not mediated through an enum
[18:59:58] <bblum> bstrie: ok, rebased
[19:02:09] <sully> does llvm still not have its own union types?
[19:04:14] <bblum> what's the "[pub] extern { fn foo(); }" syntax mean?
[19:04:25] <bstrie> bblum: is there a ticket that describes the work being done here?
[19:04:36] <bblum> bstrie: https://github.com/mozilla/rust/issues/3569
[19:04:49] *** Joins: Guest__ (textual@moz-BB21156B.dynamic.csail.mit.edu)
[19:04:51] *** Guest__ is now known as Sergio965
[19:05:10] <bblum> bstrie: the "Add a run-pass test" demonstrates the expressiveness that is added
[19:05:16] <bstrie> bblum: is this also part of once fns?
[19:05:24] <bblum> no, that's separate
[19:05:45] <bblum> they are aware of each other, so not entirely orthogonal, but largely independent
[19:06:00] <Sergio965> Hi all. I'm having a bit of a problem with modules. I have a module in a folder "folder" called "module". In my main file, I do "mod folder { mod console; }" and try to use the public function "function" like so: "folder::module::function()", but I get an "unresolved name" error.
[19:06:09] <bblum> bstrie: once fns is at https://github.com/mozilla/rust/pull/7244
[19:06:15] <bblum> and contains a controversial decision
[19:06:20] <Sergio965> "mod folder { mod module; }"*
[19:06:28] <bblum> namely, just how much of the feature to put behind a -Z flag
[19:06:41] <bjz_> mark_edward: why is write_fn not publicly exported?
[19:07:24] <bjz_> mark_edward: I tried not setting the option, but I got a seqfault
[19:07:32] <bjz_> *segfault
[19:07:34] <mark_edward> i wasnt sure if something like that should be. it's unsafe, and you may want to have different such functions for your own uses.
[19:07:41] *** Joins: sk (sk@61A494B3.BA40E8A.AAC02D62.IP)
[19:07:41] <kimundi> Sergio965: the nested mod console is not public
[19:07:41] <mark_edward> but i should export it then
[19:07:47] *** Quits: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP) (Ping timeout)
[19:07:49] <bjz_> mark_edward: I dunno
[19:07:54] <bstrie> Sergio965: I'm not entirely clear on how rust works here, let me play around for a sec
[19:08:03] <kimundi> "mod folder { pub mod console; }"
[19:08:08] <Sergio965> kimundi: I have it defined as pub mod module. Is that what you mean?
[19:08:08] <bjz_> mark_edward: what does it do exactly?
[19:08:10] <Sergio965> Oh, interesting.
[19:08:37] <Sergio965> kimundi: Unfortunately, no dice.
[19:08:38] <kimundi> privacy is per module
[19:08:43] <Sergio965> bstrie: Thanks, I appreciate it.
[19:08:44] <kimundi> hmm
[19:09:02] <mark_edward> bjz_:  it gets called when curl receives data. since we're in HTTP protocol, when curl receives data from the body of the response
[19:09:07] <kimundi> try putting 'pub' on everything :P
[19:09:10] <Sergio965> Lol
[19:09:30] <kimundi> is the function() pub?
[19:09:30] <Sergio965> Nope. :(
[19:09:32] <Sergio965> Yeah.
[19:09:41] <bjz_> mark_edward: why would it segfault when I don't set it?
[19:09:46] <Sergio965> (Nope to putting pub on everything, yes to the function being public.)
[19:10:09] <Sergio965> I assumed this would work, according to the documentation: "The compiler will now look for poultry/chicken.rs and poultry/turkey.rs, and export their content in poultry::chicken and poultry::turkey. You can also provide a poultry.rs to add content to the poultry module itself."
[19:10:24] <Sergio965> For mod poultry { mod chicken; mod turkey; }.
[19:10:37] <bjz_> quack
[19:10:40] <kimundi> hmm. could you paste the code somewhere?
[19:10:51] <Sergio965> make
[19:10:53] <Sergio965> Woops.
[19:11:03] <Sergio965> Ah, figured it out.
[19:11:11] <Sergio965> The file is a module by default.
[19:11:15] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[19:11:25] <Sergio965> So I needed to do folder::module::module::function()
[19:11:27] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[19:11:40] <mark_edward> bjz_: http://curl.haxx.se/libcurl/c/curl_easy_setopt.html i think it's trying to write to a FILE* that you're supposed give it with the WRITEDATA option
[19:11:44] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[19:11:50] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[19:12:03] <mark_edward> libcurl isn't that transparent, unfortunatley
[19:12:05] *** Joins: pnkfelix|rcirc (pnkfelix@moz-43495417.fbx.proxad.net)
[19:12:08] <mark_edward> :-(
[19:13:08] <bstrie> Sergio965: I still don't understand how you got it to work, can I see the code?
[19:13:13] <cmr> pcwalton: how goes the reachable work?
[19:14:21] <mark_edward> bjz_: if you don't set the WRITEFUNCTION callback it tries to write to a FILE* given by the WRITEDATA option, but neither is set so segfault
[19:14:38] <Sergio965> bstrie: So I have a file called "module" in a folder called "folder". By default, Rust creates a module for each file. In the main file, I do "mod folder { mod module; }" which imports the module created intrinsically by Rust. Any functions defined publicly in there can be accessed via folder::module::function(), and any addition modules defined in there must be accessed by folder::module::module::function(). Does that make sense?
[19:14:54] <Sergio965> addtional*
[19:15:12] <bjz_> mark_edward: ahh
[19:15:23] *** Joins: tjc (tjc@moz-6ED8F8B5.dsl.lsan03.pacbell.net)
[19:15:23] *** ChanServ sets mode: +o tjc
[19:15:58] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Ping timeout)
[19:16:02] <mark_edward> bjz_: I can't really do anything about how obtuse it can be to use libcurl, unfortunately. there's a link to the curl docs in the README and i the docs
[19:16:05] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[19:16:41] <bstrie> Sergio965: I see now, but it still feels weird somehow
[19:16:49] <Sergio965> Yeah, but it's documented.
[19:16:58] <bjz_> mark_edward: yeah no worries
[19:17:01] <Sergio965> "The Rust namespace is arranged in a hierarchy of modules. Each source (.rs) file represents a single module and may in turn contain additional modules."
[19:17:08] <bblum> toddaaro: find -name '*.rs' | xargs sed -i 's/\s.*$//'
[19:18:22] *** Quits: carllerche (carllerche@moz-CDE5367B.dsl.static.sonic.net) (Quit: carllerche)
[19:18:46] <mark_edward> bjz_: any other advice/ recommendations? there are now docs in a docs folder as well as an examples.rs file
[19:19:15] <Sergio965> Is there a way to create a global (or per module) mutable variable?
[19:20:17] *** Quits: xLII (xLII@4BED3CB3.F5F53E8A.2D6DB75E.IP) (Ping timeout)
[19:20:31] *** Quits: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Quit: msingle)
[19:20:37] *** Joins: xLII (xLII@4BED3CB3.F5F53E8A.2D6DB75E.IP)
[19:21:23] *** Joins: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP)
[19:21:26] <mark_edward> bjz_:  also what is your use case why you're trying to write youre own WRITEFUNCTION
[19:21:47] <bjz_> mark_edward: I didn't want to
[19:21:55] <mark_edward> oh ok
[19:22:28] <bjz_> mark_edward: I'm wondering if I should set the file handle
[19:22:48] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[19:22:58] <bjz_> I was loading it into a ~[u8], then writing to a file, which isn't ideal
[19:23:00] <cmr> Sergio965: As of a few hours ago, yes.
[19:23:15] <cmr> Sergio965: "static mut x: type = expr"
[19:23:28] <mark_edward> ah i see.
[19:23:32] <Sergio965> Lol. That's what I had assumed, but it didn't work in my build.
[19:23:39] <Sergio965> Neat.
[19:23:50] <cmr> literally 8 hours ago :p
[19:24:01] <Sergio965> Is this documented in the trunk docs?
[19:24:11] <cmr> No
[19:24:19] <cmr> But see the tests at  https://github.com/alexcrichton/rust/commit/1841b31c61c2cca9c54264edd2a78b994b9638e9 for examples.
[19:24:23] <mark_edward> bjz_: then you should write a nw write_fn  for now, or pass a FILE* to easy_setopt(opt::WRITEDATA,file_ptr)
[19:24:31] *** Quits: sk (sk@61A494B3.BA40E8A.AAC02D62.IP) (Quit: Leaving)
[19:24:32] <mark_edward> i don't know how you'd get one in rust
[19:24:46] <mark_edward> but i do think i should try and provide a function like that
[19:24:58] <mark_edward> it does seem to be a reasonable use case
[19:25:08] <bjz_> mark_edward: or impl a trait on a Writer
[19:25:18] <mark_edward> what do you mean?
[19:25:51] *** Quits: ecr (ereed@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[19:26:03] <Sergio965> cmr: Awesome. Thanks!
[19:26:53] <bjz_> file.write_curl("...") maybe
[19:26:59] *** Joins: lkuper (lkuper@66AE1C4.B4544612.EA8B5958.IP)
[19:27:27] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Quit: jedestep)
[19:28:55] <mark_edward> bjz_: what would write_curl do?
[19:28:59] <bjz_> or: curl::writer(io::file_writer(&path, [io::Create]).get())
[19:29:28] *** Joins: qmx (qmx@B42C1175.A82378F3.A2BF9DEB.IP)
[19:29:51] *** Joins: roo (jesse.rudo@moz-FC907457.dynamic.ip.windstream.net)
[19:30:32] *** Quits: fuogo (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[19:35:46] <bstrie> bblum: does this PR completely fix 3569, or is it just a step?
[19:35:54] <Sergio965> Can I not modify struct fields in methods?
[19:36:10] <bstrie> Sergio965: pretty sure you can
[19:36:12] <tjc> Sergio965: the method has to take its argument like: &mut self
[19:36:12] <Sergio965> I'm creating a struct like: "let mut s = Struct { .. };"
[19:36:15] <tjc> instead of just &self
[19:36:16] <mark_edward> bjz_: what is the return value of this function?
[19:36:20] <Sergio965> Oh.
[19:36:20] <tjc> in order to be allowed to mutate it
[19:36:48] <Sergio965> That was it indeed.
[19:36:53] <bblum> bstrie: it 95% fixes it...
[19:37:13] <bblum> bstrie: I wouldn't say 3569 is done until we figure out how it interacts with once stack fns and mutable borrowing
[19:37:22] <bblum> and some cases i haven't written tests for
[19:37:30] <bjz_> mark_edward: oh, that would return a CurlWriter maybe. but it wouldn't work. you can't seem to get the file handle out of a @Writer
[19:37:37] <bblum> bstrie: but as far as implementing the type system, this pr is all you need
[19:38:02] <bblum> oh i don't mean once i mean noncopyable
[19:38:24] <mark_edward> yeah, i noticed that. maybe just have a functiontaking a Path to write to?
[19:38:29] <bblum> by that, i mean, a "&fn:Copy()" should be able to immutably reference its environment. currently a &fn:Copy can reference no environment at all.
[19:39:22] <bblum> because mutability of environment reference is not tracked
[19:39:29] <bblum> so i currently assume the worst
[19:39:40] <bblum> but that's all in https://github.com/mozilla/rust/pull/7363
[19:39:59] <cubic> http://i.imgur.com/ZFVRu07.png so, what do I do
[19:40:10] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[19:40:18] <cmr> cubic: OS?
[19:40:24] <cubic> windows
[19:40:37] <cubic> (7 x64 sp1)
[19:40:48] <cmr> cubic: mkdir build; cd build; ../configure; make;
[19:41:04] <sully> hm, how are regions handled in trans?
[19:41:08] <sully> like, where are they eliminated?
[19:41:09] <bstrie> cubic: I think we can only use a very specific version of mingw
[19:41:30] <cmr> cubic: https://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust has step-by-step instructions for windows.
[19:41:49] <bstrie> bblum: well I can look over this pr, but there's so much context I'm missing that I can't properly approve it
[19:42:07] <bstrie> at least not in a timely fashion
[19:42:35] <bblum> bstrie: would a quick exposition help or something
[19:42:47] *** Quits: jclements (jclements@43CB6079.66715431.D25A875A.IP) (Quit: jclements)
[19:43:00] *** Quits: roo (jesse.rudo@moz-FC907457.dynamic.ip.windstream.net) (Ping timeout)
[19:43:53] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[19:44:01] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[19:45:13] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[19:45:46] *** Quits: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP) (Quit: eatkinson)
[19:46:06] <bstrie> bblum: mostly I'm unclear about this notion of custom kinds... I thought the point of kinds was that the user *couldn't* provide them
[19:46:52] <doomlord> http://archive.org/details/dconf2013-day01-talk05 <<< would be interesting to see rust in this context...
[19:47:20] <bstrie> is D pivoting to try to replace lua?
[19:47:48] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Quit: WeeChat 0.4.1)
[19:48:11] <doomlord> i dont thinkso, but those guys had a go
[19:48:23] <bblum> bstrie: well the deal here is that existential types (closures+traits) are special --  if you put a "kind bound" on such a type, it restricts what types can be hidden inside
[19:49:16] <bblum> for example, a fn:Copy() can be used in more ways than a fn(). But a fn() can capture more diverse types than a fn:Copy().
[19:49:19] <bblum> (capability vs construction)
[19:49:45] <bblum> fewer kind bounds restricts capabilities. more kind bounds restrict construction.
[19:50:25] *** Joins: jclements (jclements@43CB6079.66715431.D25A875A.IP)
[19:50:29] <bstrie> bblum: I'd also like to see a chart of what it is possible to close over with each bound. like, I have no idea what fn:Const would do (isn't &const going away?)
[19:51:10] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[19:51:47] *** Quits: eschweic (Adium@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[19:51:48] *** Quits: jclements (jclements@43CB6079.66715431.D25A875A.IP) (Quit: jclements)
[19:52:05] *** Quits: MaikKlein (maik@moz-3D9AD16.dip0.t-ipconnect.de) (Ping timeout)
[19:52:38] *** Joins: eholk (eholk@moz-786AC74A.uconnect.utah.edu)
[19:52:42] <bstrie> bblum: partly my confusion stems from the fact that kinds bounds just don't exist currently, and I've never seen a definitive and comprehensive overview of their design
[19:53:14] <cmr> There was a chart in one of the issues wasn't there?
[19:53:20] <cmr> I recall seeing one
[19:53:31] <cmr> maybe it was just syntax
[19:54:14] *** Quits: lkuper (lkuper@66AE1C4.B4544612.EA8B5958.IP) (Client exited)
[19:55:41] *** Quits: dherman (dherman@2557E599.66715431.D25A875A.IP) (Quit: dherman)
[19:55:54] *** Joins: lkuper (lkuper@66AE1C4.B4544612.EA8B5958.IP)
[19:56:41] *** Quits: Sergio965 (textual@moz-BB21156B.dynamic.csail.mit.edu) (Ping timeout)
[19:58:57] *** Quits: xLII (xLII@4BED3CB3.F5F53E8A.2D6DB75E.IP) (Ping timeout)
[20:01:04] *** Joins: cr (anonymous@moz-94668A09.dip0.t-ipconnect.de)
[20:01:23] *** Parts: mw (mw@moz-37671F30.adsl.highway.telekom.at) ()
[20:03:45] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[20:05:19] *** Quits: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Leaving...)
[20:06:19] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[20:06:25] *** Quits: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP) (Ping timeout)
[20:06:55] <mark_edward> in rust, spaces vs tabs?
[20:07:04] <mark_edward> what's used in mozilla/rust?
[20:07:08] <bjz> spaces
[20:07:10] <bjz> 4
[20:07:10] <doener> spaces, four of them
[20:07:20] <bjz> 100 columns
[20:07:21] *** Joins: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP)
[20:08:53] *** Joins: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[20:09:15] *** Quits: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca) (Quit: Leaving)
[20:10:29] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[20:10:29] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/fEtzcA
[20:10:29] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[20:10:51] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[20:11:04] *** Quits: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net) (Quit: Jesse)
[20:11:12] *** Quits: Palmik (palmik@moz-CC484FDD.tmcz.cz) (Quit: Lost terminal)
[20:13:30] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[20:13:30] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/7n63zg
[20:13:30] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[20:13:33] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[20:13:33] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/yL8auA
[20:13:33] <ghrust> 13rust/06auto 149f80591 15Ramkumar Ramachandra: resolve: report duplicate module definitions...
[20:13:33] <ghrust> 13rust/06auto 14f982f42 15Ramkumar Ramachandra: resolve: make error message strings more consistent...
[20:13:34] <ghrust> 13rust/06auto 144967bd0 15bors: auto merge of #7325 : artagnon/rust/resolve-module, r=cmr...
[20:13:36] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[20:15:09] *** Joins: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca)
[20:17:18] *** Joins: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net)
[20:17:24] <SiegeLord> Hmm, it'd be nice if rustdoc followed up through pub use'd modules too
[20:17:38] <cmr> "followed up through"?
[20:18:31] <SiegeLord> Well, if you do rustdoc crate.rs, it will only generate documentation for the modules in it if they are pub
[20:19:13] <SiegeLord> But pub use provides another access point to a non-pub module, so it should count in the determination whether or not to generate documentation for that module
[20:19:36] *** Quits: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP) (Ping timeout)
[20:19:38] <cmr> Gotcha, needs to look at the visibility graph and make sure it gets everything
[20:21:07] <SiegeLord> There's no 'crate' visibility modifier, is there?
[20:21:20] <cmr> As in, make a whole crate private
[20:21:22] <cmr> ?
[20:21:36] <SiegeLord> no, like pub but only from within the crate
[20:21:48] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[20:21:51] *** Joins: eschweic (Adium@2557E599.66715431.D25A875A.IP)
[20:22:00] <cmr> Sure. "mod"
[20:22:06] <cmr> (as opposed to "pub mod")
[20:22:11] <cmr> I think
[20:22:13] <cmr> Not entirely sure
[20:22:28] <SiegeLord> So modules can use each other's items, but you can't use them from outside the crate
[20:23:01] *** Quits: mib_mneisb (Mibbit@moz-1187195B.adsl.alicedsl.de) (Quit: http://www.mibbit.com ajax IRC Client)
[20:23:22] *** Quits: victorporof (victorporo@70DEDDA.9004F55.9B1E38F4.IP) (Quit: victorporof)
[20:23:26] <SiegeLord> I guess you can whitelist such items via pub use, to an extent
[20:23:30] <SiegeLord> It's not quite the same though
[20:23:37] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[20:24:49] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[20:25:46] *** Joins: ciferkey (ciferkey@moz-37B1CA4E.prvdri.fios.verizon.net)
[20:27:58] *** Quits: eschweic (Adium@2557E599.66715431.D25A875A.IP) (Ping timeout)
[20:28:06] *** Quits: lkuper (lkuper@66AE1C4.B4544612.EA8B5958.IP) (Ping timeout)
[20:28:36] *** Quits: noam_ (noam@F6B530A7.720527A7.416762B.IP) (Connection reset by peer)
[20:29:10] <SiegeLord> Oh I know what I can do
[20:29:27] *** Joins: noam_ (noam@F6B530A7.720527A7.416762B.IP)
[20:29:42] <SiegeLord> I can put a priv module around those items, I don't think you can access those from outside the crate
[20:31:56] <SiegeLord> No, nvm... you can still access them outside the crate... that's unfortunate
[20:32:45] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[20:33:01] <kimundi> SiegeLord: A private module should not be accesizle from the outside ogf the crate
[20:33:11] <SiegeLord> Is this a bug then?
[20:33:22] <kimundi> apparently :P
[20:33:56] <SiegeLord> rusti: pub mod A { mod Priv { pub fn test() {} } } A::Priv::test();
[20:33:56] <kimundi> (I know that there ARE bugs with crate-boundary access modifiers)
[20:34:15] <SiegeLord> Except pretend that the call is outside the crate
[20:34:30] <SiegeLord> That currently works
[20:34:31] <strcat> found yet another codegen bug :(
[20:34:33] *** Joins: Jesse (jruderman@2557E599.66715431.D25A875A.IP)
[20:34:38] <cmr> strcat: is anyone surprised? :p
[20:34:48] <kimundi> SiegeLord: Better file an issue
[20:35:03] <strcat> no just disappointed that I can't do any change over +300/-300 lines without hitting 4-5 codegen bugs
[20:35:08] <cmr> heh
[20:35:31] <cmr> I hit 3 different ice's in a row trying to hash out the generic interner this morning
[20:35:34] <cmr> I've just given up on it
[20:35:53] *** Joins: lkuper (lkuper@ACA1ECB.2FC96E37.51B6877.IP)
[20:36:01] <cmr> generic interner isn't important, just a good string one
[20:36:04] <strcat> https://github.com/mozilla/rust/issues/7385 https://github.com/mozilla/rust/issues/7372 https://github.com/mozilla/rust/issues/7355 https://github.com/mozilla/rust/issues/7340 https://github.com/mozilla/rust/issues/7341 https://github.com/mozilla/rust/issues/7336
[20:36:12] <strcat> from a day of iterator changes
[20:36:51] *** Quits: pyrac (pyrac@moz-9180E00E.w86-201.abo.wanadoo.fr) (Quit: pyrac)
[20:37:02] <strcat> the const-vec-of-fns one is especially annoying since it only happens on OS X ;\
[20:37:12] <strcat> and we don't have a spare mac bot for try
[20:38:06] <SiegeLord> I guess I don't really understand how the module visibility works
[20:38:32] <SiegeLord> What exactly does "pub mod" mean
[20:38:47] <strcat> 'mod' means 'load this file and make it a module'
[20:38:56] <strcat> within the current module
[20:39:05] <strcat> if it's not pub, it's not usable by other crates
[20:39:38] <SiegeLord> So "priv mod" is actually "crate-visible mod"
[20:39:49] <SiegeLord> And not actually "priv" as it applies to items
[20:40:00] <engla> strcat: can you review this for me? https://github.com/mozilla/rust/pull/7345
[20:40:17] <strcat> engla: sec
[20:41:48] <SiegeLord> There's this bug too: https://github.com/mozilla/rust/issues/5129
[20:42:04] <SiegeLord> My current understanding of visibility modifiers on mod's tells me that it is invalid
[20:42:50] *** Joins: seth (seth@moz-BE33DA21.fw1.sfo1.mozilla.net)
[20:43:11] <cmr> SiegeLord: that should be valid, in a crarte everything can see everything else aiui
[20:43:32] <SiegeLord> I meant the issue is invalid, and the code functions correctly
[20:43:40] <cmr> oh, yes.
[20:43:50] <SiegeLord> Ok, then I'll submit it
[20:43:56] *** Quits: bytbox (s@moz-2E27684C.student.umd.edu) (Ping timeout)
[20:44:08] <SiegeLord> And code for not assuming it will get fixed 8)
[20:44:12] <SiegeLord> *for now
[20:44:40] *** Quits: txdv (quassel@966F3542.3BA477DA.14C26596.IP) (Ping timeout)
[20:46:44] *** Joins: txdv (quassel@966F3542.3BA477DA.14C26596.IP)
[20:48:20] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[20:48:43] <bstrie> erickt: wondering if you know whether https://github.com/mozilla/rust/issues/4872 is still relevant
[20:48:51] *** Joins: dherman (dherman@2557E599.66715431.D25A875A.IP)
[20:48:51] *** ChanServ sets mode: +o dherman
[20:49:00] *** Joins: ecr (ereed@2557E599.66715431.D25A875A.IP)
[20:50:10] *** Joins: eagen (eagen@8737942B.7A99C13A.B7961A98.IP)
[20:50:56] *** Joins: xLII (xLII@4BED3CB3.F5F53E8A.2D6DB75E.IP)
[20:51:14] *** Quits: xLII (xLII@4BED3CB3.F5F53E8A.2D6DB75E.IP) (Client exited)
[20:53:00] *** Joins: timot (timot@moz-275D4A76.cust.telenor.se)
[20:54:40] <bstrie> cmr: want to benchmark something? https://github.com/mozilla/rust/issues/4961
[20:55:27] <cmr> bstrie: give me a patch and sure :p
[20:57:29] <bstrie> cmr: just grep for "2" and change it to "1.5
[20:57:38] <bstrie> don't forget to omit the trailing quotation mark
[20:58:01] *** Quits: jdm (jdm@88F51059.F3BBB17D.144F44FA.IP) (Quit: Lost terminal)
[20:58:26] <bstrie> I mean, it *should* be a one-line patch, if you can figure out which line it is
[20:58:48] <cmr> right, and I don't feel like doing that :p
[20:59:06] <SiegeLord> https://github.com/mozilla/rust/issues/7388 <- Here's what I came up with... does that look like a bug?
[20:59:06] <bstrie> cmr: perf work! what if this cuts compilation time in half
[20:59:10] <bstrie> you would be a hero to us all
[20:59:26] <strcat> bstrie: it's not that simple, I think there's a next_power_of_two function
[20:59:30] <SiegeLord> Nothing less than 100x speedup is acceptable ;)
[20:59:57] *** Joins: azita (Azita@2557E599.66715431.D25A875A.IP)
[21:00:18] <cmr> strcat: bring back rusti!
[21:00:29] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[21:01:05] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[21:01:15] *** Joins: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP)
[21:01:15] *** Quits: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP) (Quit: eatkinson)
[21:01:48] *** Joins: eschweic (Adium@2557E599.66715431.D25A875A.IP)
[21:02:00] *** Joins: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP)
[21:03:33] *** Quits: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP) (Quit: eatkinson)
[21:03:49] *** Joins: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP)
[21:04:01] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[21:04:01] *** ChanServ sets mode: +o brson
[21:04:35] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Ping timeout)
[21:07:23] *** Quits: eagen (eagen@8737942B.7A99C13A.B7961A98.IP) (Quit: Leaving)
[21:08:23] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[21:08:42] <acrichto> r? https://github.com/mozilla/rust/pull/7376
[21:08:53] *** Joins: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP)
[21:10:18] *** Joins: Aetherspawn (Aetherspaw@moz-8811D9F0.static.tpgi.com.au)
[21:11:08] *** Quits: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP) (Ping timeout)
[21:11:21] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[21:11:32] <steven_is_false> cmr: You use ~/.local to store installed applications right?
[21:11:37] <cmr> steven_is_false: yes
[21:11:48] <steven_is_false> cmr: How do you handle .desktop files?
[21:11:53] <cmr> steven_is_false: I don't
[21:12:11] <cmr> I don't use a conventional desktop or DE, sorry :\
[21:12:16] <steven_is_false> cmr: Okay. I thought there might be a DESKTOP_PATH similar to MAN_PATH.
[21:12:23] <bblum> bstrie: hmm
[21:12:29] <cmr> steven_is_false: it's an xdg thing, so look at the spec maybe?
[21:12:41] <bblum> bstrie: well, such a chart would be just the same as the chart for what fulfills builtin kinds today
[21:12:46] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[21:12:48] <strcat> steven_is_false: ~/.local/share/applications/ is the local version of /usr/share/applications/
[21:12:53] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Bye!)
[21:12:59] <bblum> bstrie: the Const kind is fulfilled by anything that doesn't have a @mut or &mut inside
[21:13:14] <strcat> bblum: or #[mutable] things (Cell, RcMut, RWARC)
[21:13:20] <bblum> oh thank you strcat
[21:13:33] <bblum> i confused myself and was like "uh... what's owned but not const"
[21:14:00] <strcat> oh and &const
[21:14:18] <strcat> (yeah, &const isn't Const \o/)
[21:14:50] *** Joins: jclements (jclements@43CB6079.66715431.D25A875A.IP)
[21:15:47] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Quit: Leaving.)
[21:16:38] <steven_is_false> cmr: Thanks.
[21:17:19] <doomlord> can anyone here compare/constrast D/Rust succintly in a few lines
[21:17:45] <cmr> D: No opting out of the GC and its extensive usage in the stdlib. Rust: zero-cost abstraction
[21:17:56] <mark_edward> steven_is_false: what distro ar you using
[21:18:01] <cmr> Haven't used D in years though... just a summary as I see it
[21:18:44] <jesse98> no compile time meta-programming
[21:18:45] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[21:18:53] <friggle> D: 3 compilers. Rust: <1 ;)
[21:18:59] <cmr> Also no massive feature bloat (yet!)
[21:19:18] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[21:19:52] <jesse98> better type system and safer
[21:21:19] <bblum> bstrie: wrote a list for you: https://github.com/mozilla/rust/issues/3569
[21:24:39] <seth> is there an explanation somewhere of what is "sendable"? (i presume this means sendable from one task to another)
[21:24:58] <bblum> seth: see the link i just posted
[21:25:02] <bblum> except "Owned" == "Send"
[21:25:23] <seth> bblum: heh, quite a coincedence!
[21:25:44] *** Joins: gareth0 (gareth0@7C428FA9.3FD5F917.1A294DCF.IP)
[21:25:55] *** Quits: lmandel (lmandel@F2D29657.F60B0462.67AC9B1.IP) (Quit: lmandel)
[21:26:18] <seth> bblum: is this "mq" currently a thing in rust? i've never seen it before
[21:26:26] *** Joins: brendan (brendaneic@2557E599.66715431.D25A875A.IP)
[21:26:38] <bblum> it's my placeholder for any mutability qualifier
[21:26:46] <bblum> &mq T means &T, &mut T, or &const T
[21:26:56] <seth> bblum: ah, i see, somehow missed that
[21:27:23] <strcat> rusti: 4
[21:27:24] -rusti- 4
[21:27:25] *** Quits: ciferkey (ciferkey@moz-37B1CA4E.prvdri.fios.verizon.net) (Quit: ciferkey)
[21:27:26] <gareth0> what does &const T mean?
[21:27:33] <seth> bblum: so @/@mut stuff can't be Owned?
[21:27:38] <bblum> seth: true
[21:27:56] <bblum> gareth0: you can't mutate through it, but another path to the data might exist that will mutate from under you, so you can't use immutability guarantees
[21:27:58] *** Joins: incDec (Mibbit@moz-5949C51B.dllstx.fios.verizon.net)
[21:28:04] <seth> bblum: bummer. i would've thought that @ was safe since it's immutable
[21:28:04] <strcat> managed pointers are task-local, otherwise you'd need a global gc and you'd have data races
[21:28:11] *** Quits: Ralith (ralith@moz-50F3C77.vc.shawcable.net) (Ping timeout)
[21:28:15] <seth> strcat: ah, that'd be why =) thanks
[21:28:15] <strcat> seth: it's only immutable if the contained type is Const
[21:28:26] <bblum> seth: the Send/Owned kind exists to keep tasks from sharing state
[21:29:17] <seth> is there any kind of global heap for immutable data?
[21:29:24] <bblum> yep
[21:29:28] <gareth0> bblum, i see... so should I try and use &const T instead of & T where possible?
[21:29:33] <strcat> rusti: let xs = [1, 2, 3, 4, 5]; xs.iter().size_hint()
[21:29:34] -rusti- (Some(5), Some(5))
[21:29:38] <strcat> gareth0: no, just use &
[21:29:42] <bblum> seth: the ARC type exists for safely sharing frozen state between tasks without copying
[21:29:43] *** Quits: pcwalton (pcwalton@43CB6079.66715431.D25A875A.IP) (Quit: pcwalton)
[21:29:56] <strcat> &const will likely be removed
[21:29:59] <seth> bblum: aha. sounds like just what i need
[21:30:21] <bblum> seth: :)
[21:30:23] <gareth0> why did it ever exist, then, strcat ?
[21:30:23] <strcat> it's the @mut abstraction being non-orthogonal
[21:30:46] <incDec> Sorry if this question has already been asked before, but is there is an existing way to convert a string to hexadecimal and back in Rust?
[21:30:47] <Eridius> strcat: yay my PR broke bors
[21:31:01] <strcat> Eridius: I tried fixing it, didn't work ;[
[21:31:04] <strcat> no amount of retries helped
[21:31:11] <strcat> closed/reopened, didn't help
[21:31:14] * strcat sighs
[21:31:17] *** Quits: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Quit: msingle)
[21:31:35] <strcat> Eridius: also should probably delete the comments
[21:31:37] <strcat> from the commits
[21:31:39] <strcat> or it'll get confused
[21:31:47] <Eridius> good point
[21:31:52] <bblum> incDec: str::as_bytes and str::from_bytes
[21:32:00] <incDec> So does a method exist within Rust?
[21:32:00] *** Joins: Aetherspawn_ (Aetherspaw@moz-8811D9F0.static.tpgi.com.au)
[21:32:27] <Eridius> strcat: https://github.com/mozilla/rust/pull/7389
[21:32:33] *** Quits: Blub\w (wry@moz-2D425469.wireless.dyn.drei.com) (Quit: night)
[21:32:36] <Eridius> huh the brand new PR is already saying "Failed". That's weird
[21:32:42] <incDec> Do I have to import anything within a Rust source file to use it?
[21:32:45] <cmr> It just /knows/
[21:32:56] <cmr> incDec: What do you mean?
[21:33:07] *** Quits: Aetherspawn (Aetherspaw@moz-8811D9F0.static.tpgi.com.au) (Ping timeout)
[21:33:08] <strcat> Eridius: metadata github attaches to the commit
[21:33:18] <strcat> Eridius: you could just git commit --amend, do nothing, and push -f it
[21:33:25] <strcat> to change the commit date to make it a new commit
[21:33:40] <brson> what are some selling points related to safety in rust? no null pointers, buffer overflows, stack smashing are obvious. maybe task isolation. can we say something like 'no undefined behavior'?
[21:33:51] <Eridius> strcat: true
[21:33:58] <incDec> I'm not sure how to word this, but do I have to put the using command at the beginning of the source file to be able to use str::as_bytes and str::from_bytes?
[21:33:59] <Eridius> I didn't realize that was on the commit, I thought it was on the PR
[21:34:08] <Eridius> I assume that just leaving it as-is, since you already r+'d, won't hurt anything?
[21:34:14] <bblum> brson: no data races, no undefined behaviour
[21:34:20] <strcat> brson: no dangling pointers or iterator invalidation (key one), no uninitialized reads, no data *races* (we have race conditions, but not on data)
[21:34:22] <Eridius> incDec: well you probably need to say `std::str::as_bytes` unless you `use std::str;`
[21:34:34] *** Joins: pcwalton (pcwalton@43CB6079.66715431.D25A875A.IP)
[21:34:35] *** ChanServ sets mode: +o pcwalton
[21:34:38] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[21:34:44] <incDec> Okay
[21:34:44] <bblum> brson: no pointer arithmetic
[21:35:06] <Eridius> brson: no race conditions
[21:35:10] <bblum> brson: no leaks of "unreachable" memory 
[21:35:12] <incDec> So I just prefix std:: to str::as_bytes and str::from_bytes and no problems will come up?
[21:35:13] <strcat> we do have race conditions
[21:35:15] <strcat> just not data races
[21:35:24] <Eridius> strcat: well ok I meant data races, but now I'm curious what you're referring to
[21:35:31] *** Quits: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca) (Quit: Leaving)
[21:35:34] <strcat> you can race on filesystem access, env variables, chdir, buggy communication protocols
[21:35:38] <Eridius> ah
[21:35:42] <bblum> Eridius: have i got just the blog post for you
[21:35:43] <doomlord> less unitialized variables? 'everyhing is an expression' seems to help that?
[21:35:44] <strcat> just not on data
[21:35:47] <bblum> Eridius: http://winningraceconditions.blogspot.com/2012/10/what-is-data-race-and-when-is-race-not.html
[21:35:57] <strcat> doomlord: we don't have uninitialized reads
[21:36:14] <Eridius> bblum: heh ok
[21:36:16] <brson> thanks
[21:36:17] <steven_is_false> rusti: intrinsics::init()
[21:36:18] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/FTaU
[21:36:27] <steven_is_false> rusti: intrinsic::init()
[21:36:27] -rusti- <anon>:9:9: 9:24 error: unresolved name `intrinsic::init`.
[21:36:28] -rusti- <anon>:9          intrinsic::init()
[21:36:28] -rusti-                   ^~~~~~~~~~~~~~~
[21:36:28] -rusti- error: aborting due to previous error
[21:36:28] -rusti- application terminated with error code 101
[21:36:28] <bblum> brson: no arbitrary type coercion
[21:36:40] <incDec> So how am I able to print out the hexadecimal formatted string?
[21:36:41] <bblum> brson: no implicit lossy integer coercion
[21:36:42] <doomlord> can i claim that in an argument with someone.. rust - no uninitialized variables
[21:36:53] <strcat> doomlord: no
[21:36:58] <strcat> doomlord: no uninitialized reads
[21:37:04] <Eridius> incDec: fmt!("%x", someInt) ?
[21:37:08] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[21:37:14] <Eridius> rusti: println(fmt!("%x", 12345))
[21:37:14] <strcat> you can have uninitialized variables, it's not a bad thing
[21:37:14] <incDec> Okay
[21:37:15] -rusti- 3039
[21:37:15] -rusti- ()
[21:37:19] <bblum> no uninitialized reads is also a good one
[21:37:22] <strcat> you just can't read them until they're guaranteed to be initialized
[21:37:23] <Eridius> rusti: println(fmt!("%#x", 12345))
[21:37:24] -rusti- <anon>:9:22: 9:27 error: internal compiler error: unimplemented conversion not supported in fmt! string
[21:37:24] -rusti- <anon>:9          println(fmt!("%#x", 12345))
[21:37:24] -rusti-                                ^~~~~
[21:37:24] -rusti- application terminated with error code 101
[21:37:27] <Eridius> oh damn
[21:37:33] <Eridius> I should figure out how fmt! is implemented and fix that
[21:37:36] <bblum> do we have a safe fn uninitialized<T: POD>() yet?
[21:37:41] <bblum> i guess we don't have a POD kind huh
[21:37:56] <Eridius> strcat: how do you declare an uninitialized variable? can you just say `let x`?
[21:38:00] <strcat> Eridius: yes
[21:38:05] <incDec> Does there exist any way to convert from hex to base64 in Rust?
[21:38:05] <Eridius> huh
[21:38:12] <Eridius> incDec: are you doing matasano?
[21:38:17] <incDec> Yeah
[21:38:21] <strcat> rusti: let x = 2; let y = 5; let z; if x > y { z = x } else { z = y }; z
[21:38:22] -rusti- 5
[21:38:27] <cmr> incDec: the point is to implement it yourself :p
[21:38:30] <Eridius> incDec: I encourage you to write your own routine that converts a hex-encoded &str into a ~[u8]
[21:38:33] <strcat> rusti: let x = 2; let y = 5; let z; if x > y { z = x }; z /* possibly uninitialized read */
[21:38:33] -rusti- <anon>:9:58: 9:59 error: use of possibly uninitialized variable: `z`
[21:38:33] -rusti- <anon>:9          let x = 2; let y = 5; let z; if x > y { z = x }; z /* possibly uninitialized read */
[21:38:33] -rusti-                                                                    ^
[21:38:33] -rusti- error: aborting due to previous error
[21:38:34] -rusti- application terminated with error code 101
[21:38:46] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Ping timeout)
[21:38:48] <strcat> you can have uninitialized stuff - just can't read it
[21:38:49] <Eridius> incDec: base64 exists in the extra library already, or you could reimplement it yourself if you want to
[21:38:49] <cmr> Eridius: Or you could pick up where aatch and dbaupp left off in their fmt! reform.
[21:38:54] <Eridius> cmr: oh?
[21:39:02] <incDec> Yeah, but I have no idea where to start from
[21:39:12] <strcat> bblum: we can add POD to replace Copy when we remove it
[21:39:12] <Eridius> incDec: BTW if you're using Rust 0.6 std is called core and extra is called std
[21:39:21] *** Quits: Sodel_the_V (user@moz-853663E1.va.shawcable.net) (Quit: Eaten by a grue)
[21:39:25] <strcat> bblum: we could just start by making strings/vectors non-Copy
[21:39:28] <strcat> and then just rename it POD...
[21:39:30] <incDec> What do you mean by that?
[21:39:40] <bblum> strcat: i don't agree with making vectors non-Copy though :<
[21:39:45] <strcat> bblum: they're Clone
[21:39:48] <bblum> yeah
[21:39:51] <Eridius> incDec: I mean if you're using Rust 0.6 you might say core::str::as_bytes()
[21:39:58] <Eridius> current master of Rust calls that std::str::as_bytes()
[21:40:03] <bblum> strcat: it just raises problems with the closure/trait bounds
[21:40:06] <incDec> Okay
[21:40:13] <Eridius> incDec: this is why rust-lang.org's doc links say "Core | Standard" for 0.6 and "Standard | Extra" for Trunk
[21:40:17] <strcat> bblum: but afaik Copy is planned on being removed atm
[21:40:25] <doomlord> can anyone compare/contrast c++11 auto type inference with what rust does
[21:40:34] <cmr> doomlord: yeah, they're nothing alike.
[21:40:38] <incDec> Thanks for clearing that up
[21:40:47] <strcat> doomlord: 'auto' just lets you omit the type on the LHS by inferring it from the expression on the RHS
[21:40:53] <bblum> strcat: yeah i know
[21:41:03] <Eridius> doomlord: C++11 can have auto type inference, but it can only infer based on the concrete type of the initializer, not based on how the variable is used (AFAIK)
[21:41:11] <strcat> doomlord: rust's type inference is actually local inference in the function
[21:41:18] <doomlord> i should clarify *local* type inference as opposed to templates
[21:41:44] <strcat> doomlord: only function templates infer types, and they only infer it from the parameters they're passed
[21:41:45] <strcat> in C++
[21:41:55] <strcat> rust generics "infer" the same way
[21:41:58] <strcat> it's just not really inference
[21:42:01] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[21:42:28] <doomlord> can anyone point to a small  code example illustrating the difference
[21:42:35] <strcat> of which thing?
[21:42:43] <doomlord> the type inference
[21:42:43] <strcat> rusti: let mut xs = ~[]; xs.insert(5); xs
[21:42:45] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/hIBG
[21:42:52] <strcat> rusti: let mut xs = ~[]; xs.push(5); xs
[21:42:53] -rusti- ~[5]
[21:42:56] <strcat> there
[21:43:15] <doomlord> so the inference worked backward from xs.insert(5)?
[21:43:20] <strcat> yes
[21:43:34] <doomlord> .. would that go as far as function return type
[21:43:40] <strcat> what do you mean?
[21:43:48] <strcat> it can infer it from the functions return type, yes
[21:43:55] <doomlord> fn blah(int)->int { ........ /* i dont need to specify int inside*/}
[21:43:57] <strcat> if you return x, it can infer that x has the function's return type
[21:44:17] <strcat> if there is a place it could infer, it should infer
[21:44:19] <strcat> or it's a bug
[21:44:29] <doomlord> ok that's neat
[21:44:30] <strcat> (within the function block, ofc)
[21:44:53] <Eridius> doomlord: basically the type itself is a variable, which then has bounds placed on the possible types it can assume by how the variable is used
[21:45:09] <Eridius> so in strcat's case, the type of xs is constrained to being ~[int] based on the .insert(5) call
[21:45:18] *** Quits: azita (Azita@2557E599.66715431.D25A875A.IP) (Quit: azita)
[21:45:18] <Eridius> if a type is insufficiently constrained, you get an error
[21:45:24] <Eridius> rusti: let xs = ~[]; xs
[21:45:25] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/FbhG
[21:45:51] <Eridius> strcat: maybe you should trim off the "error: aborting due to previous error\napplication terminated with error code 101"
[21:45:57] <bblum> bstrie: pign
[21:45:58] <bblum> ping
[21:46:13] <strcat> Eridius: can't just trim stuff off, sometimes it's relevant
[21:46:23] <strcat> rusti: std::os::set_exit_status(3)
[21:46:23] -rusti- ()
[21:46:23] -rusti- application terminated with error code 3
[21:46:28] <Eridius> strcat: after throwing an error, knowing that it aborted due to the error seems, well, not useful
[21:46:36] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Client exited)
[21:46:43] <strcat> Eridius: so open a rustc bug ;p
[21:46:46] <Eridius> oh don't trim the error code under normal circumstances, only after the "error: aborting due to previous error" line
[21:46:46] <doomlord> i know some were dissapointed you can just write in c++   auto blah(...){ return ..../* return type infered from this expression*/}
[21:46:49] <strcat> I'm not going to filter rustc's output
[21:47:06] <doomlord> sounds like rust solves that the other way round?
[21:47:11] <Eridius> strcat: even when it means otherwise-short outputs have to get pastebinned?
[21:47:18] <doomlord> you write the return type ... and dont need to re-write it in the expression
[21:47:25] <strcat> doomlord: you can't write that in C++11
[21:47:36] <doomlord> i meant can''t sorrry
[21:47:39] <Eridius> doomlord: auto when used as the return type of a function is actually just an indicator that you use the -> foo return type specification
[21:47:42] <strcat> that's a planned C++14 feature
[21:47:52] <Eridius> auto blah(x) -> decltype(x) { x }
[21:47:57] <doomlord> yes.
[21:47:59] <strcat> C++14 will let you omit it
[21:48:05] <strcat> doomlord: rust could infer function signatures but it doesn't
[21:48:06] <strcat> to make it clear
[21:48:15] <strcat> haskell infers function signatures, but it's a convention to always include them
[21:48:20] <strcat> for module-level functions
[21:48:24] <cmr> graydon thinks whole program inference is a mental burden
[21:48:27] <Eridius> strcat: haskell also imposes the monomorphism restriction on inferred signatures
[21:48:32] <Eridius> which is a great can of worms to open
[21:48:40] <cmr> and I think they're a terrible, awful idea because return type has ABI implications.
[21:49:06] <benh> imo rustc should infer function signatures were omitted and edit the source file to add them
[21:49:07] <strcat> haskell doesn't have a stable ABI anyway
[21:49:13] <strcat> if you update a lib from 0.2 to 0.2.1
[21:49:18] <strcat> you have to rebuild the tree of stuff depending on it
[21:49:22] <strcat> even if the API stayed the same
[21:49:24] <strcat> ;
[21:49:26] <strcat> ;\
[21:49:37] * strcat has a lot of "fun" maintaining a bunch of haskell packages
[21:50:00] <cmr> I don't think it's acceptable for rust, a systems language, to make it *easy* to break ABI without ever changing the declaration of something
[21:50:03] <Eridius> benh: every time you have a compiler error, rust should guess at what you intended and edit your source file
[21:50:16] <steven_is_false> Ahah! I've got a reason for my fn overwrite<U>(&self, &fn()->(T, U))->U method for RWARC<T>. If an RWARC get's poisoned by failure overwrite can unpoison it!
[21:50:22] <Eridius> for the record, I agree that rust should continue requiring explicit function signatures
[21:50:34] *** Joins: Ralith (ralith@moz-281960C6.wireless.sfu.ca)
[21:50:54] <doomlord> writing in the signature and infering back from  that in the function body is good IMO
[21:51:01] <cmr> doomlord: I agree :)
[21:51:12] <doomlord> although i can see situations where you want to infer the type of an expression..
[21:51:28] <Eridius> inferring the type of an expression is useful in Haskell when you have stacks of monad transformers, or other crazy types
[21:51:34] *** Quits: Earnestly (earnest@E7C44CA8.F365B115.4FA5093E.IP) (Quit: WeeChat 0.4.2-dev)
[21:51:35] <Eridius> but the lack of higher-order kinds in rust means that's not really an issue
[21:51:41] <cmr> rusti: if true { 5 } else { 10 }
[21:51:42] -rusti- 5
[21:51:51] <strcat> Eridius: it still makes the API less clear
[21:51:59] <strcat> you have nowhere to start from
[21:52:06] <Eridius> strcat: yes. I'm all for writing down real types
[21:52:12] <strcat> when I'm doing a global change across the rust codebase, inferred types often makes it harder
[21:52:23] <strcat> but at least I have a function signature to start from
[21:52:27] <Eridius> in haskell I tend to feel that only trivial functions should infer their types; everything else should be explicit
[21:53:40] *** Joins: Earnestly (earnest@E7C44CA8.F365B115.4FA5093E.IP)
[21:53:48] *** Quits: cowboyd (cowboyd@moz-1BD02A1E.sw.biz.rr.com) (Client exited)
[21:54:30] <Jeaye> Luqman: You were working on getting color into terminals, right?
[21:54:36] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[21:55:09] <bblum> strcat: after interior for protocol goes away, we should be able to return from do closures
[21:55:30] <strcat> \o/
[21:55:32] * strcat really wants that
[21:55:46] <bblum> everybody seems to
[21:55:55] <bblum> i encouraged mr. aaro to open a ticket on it
[21:56:11] <bblum> pcwalton: ping
[21:56:15] <pcwalton> bblum: pong
[21:56:21] *** Joins: royw (royw@31A094F3.6B10AC3.E2F59BBC.IP)
[21:56:27] <bblum> pcwalton: do you think you can review https://github.com/mozilla/rust/pull/7354
[21:56:32] <pcwalton> sure
[21:57:05] <bblum> thanks :)
[21:57:13] <bblum> got two other ones i need niko to review
[21:57:28] <bblum> don't wanna have to keep rebasing while he's at conference
[21:58:18] *** Quits: Ralith (ralith@moz-281960C6.wireless.sfu.ca) (Ping timeout)
[21:58:37] <strcat> how hard would it be to actually implement a new for loop? 0.7 is going to be weird if we have .advance for every one
[21:58:46] *** Joins: illissius (illissius@A518C422.3F1C0C4.3AEF08B3.IP)
[21:59:04] <bblum> can't be that hard
[21:59:13] <bblum> just locate the magic protocol code in trans, gut it, and replace it
[21:59:20] *** Joins: johns (johns@2557E599.66715431.D25A875A.IP)
[21:59:40] <strcat> 'for iterator |pattern| { body }' -> 'let mut it = iterator; loop { match it.next() { None => break, Some(pattern) => { body } } }' is what it has to do semantically now
[21:59:51] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[21:59:53] <gareth0> its only syntactic sugar...
[21:59:53] <gareth0> ;)
[22:00:13] <strcat> niko suggested that .advance could temporarily become a no-op to land it
[22:00:23] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[22:00:24] <strcat> since that way it'd work with the old and new one
[22:00:42] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[22:01:13] *** Joins: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca)
[22:01:15] <strcat> bblum: I'm assuming the current one is somewhat hardcoded into the compiler though, for moves/borrows - maybe I'm wrong and it desugars
[22:01:15] *** Joins: Ralith (ralith@moz-281960C6.wireless.sfu.ca)
[22:01:30] <strcat> also the weird way it encodes 'return' right now
[22:01:52] *** Joins: josh (josh@CB3EC984.A5F785DE.396E4C6D.IP)
[22:02:04] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[22:02:22] *** Quits: gareth0 (gareth0@7C428FA9.3FD5F917.1A294DCF.IP) (Quit: Leaving)
[22:02:28] *** Joins: gareth0 (gareth0@7C428FA9.3FD5F917.1A294DCF.IP)
[22:02:53] *** Joins: azita (Azita@2557E599.66715431.D25A875A.IP)
[22:03:08] <strcat> Eridius: bors is still unhappy about your PR
[22:03:12] <strcat> Eridius: could you amend + force push?
[22:03:22] <Eridius> ok
[22:03:33] <bblum> strcat: hm yeah borrow check and liveness integration
[22:03:35] *** Quits: pnkfelix|rcirc (pnkfelix@moz-43495417.fbx.proxad.net) (Input/output error)
[22:03:56] <Eridius> strcat: pushed
[22:04:01] *** Quits: Ralith (ralith@moz-281960C6.wireless.sfu.ca) (Ping timeout)
[22:04:15] <cmr> I would suggest a doc sprint before 0.7, but with rustdoc sucking massive boulders, kinda pointless.
[22:05:16] <strcat> cmr: well I plan on writing a container/iterator tutorial
[22:05:21] <strcat> at least, the start of one
[22:05:50] * strcat shrugs
[22:06:01] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Quit: Leaving.)
[22:06:10] <strcat> I really want to get playpen.rust-lang.org up and running
[22:06:22] <bblum> toddaaro: brson: is there some reason we're not just using pipes with a SharedChan sendpoint for the message queues?
[22:06:24] <Eridius> playpen? why not just call it play?
[22:06:35] <bblum> sharedchan probably too slow, i guess?
[22:06:40] <strcat> Eridius: I guess it can be called play
[22:06:46] <strcat> or demo, or whatever
[22:06:57] <Eridius> play is easy to remember, especially for people who've used play.golang.org
[22:07:08] <strcat> Eridius: http://strcat.zapto.org:8000/
[22:07:13] <brson> strcat: do you have any examples of rust iterators compiling down to assembly that's identical to C?
[22:07:22] <brson> strcat: my first attempt failed
[22:07:32] <Eridius> strcat: nice
[22:07:33] <strcat> brson: with -O?
[22:07:39] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[22:07:39] <bblum> toddaaro: brson: i guess what i mean is, if sharedchan is too slow, we should implement a better sharedchan, rather than having message_queue be a separate special-case implementation
[22:07:45] <brson> strcat: yes. just looking for some compelling promotional example
[22:08:09] <strcat> brson: it will constant-fold 'Counter::new(5, 10).take_while(|x| *x < 10000).fold(0, |a, b| a + b)' to an integer ;p
[22:08:12] *** Joins: Ralith (ralith@moz-281960C6.wireless.sfu.ca)
[22:08:37] <strcat> brson: let xs = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; for xs.iter().advance |x| { } should just become a loop with 1 ptr bump + 1 ptr compare
[22:08:44] <brson> bblum: because MessageQueue is accessed from non-green-thread contexts and pipes don't work there yet
[22:08:51] <strcat> take_while, skip_while, filter, transform, fold, etc. all optimize away
[22:09:00] <Eridius> strcat: that editor renders the cursor in teh wrong spot
[22:09:00] <bblum> ahh, pipes requires the sched for blocking
[22:09:08] <strcat> Eridius: it works for me ;p
[22:09:09] <cmr> Eridius: on what borwser?
[22:09:12] <cmr> wfm too
[22:09:16] <cmr> it's just ace
[22:09:17] <Eridius> Safari
[22:09:30] <brson> strcat: gcc turns the entire loop into a single constant
[22:09:43] <brson> oh, wait you're not accumulating them
[22:09:48] <Eridius> I think it believes each letter is slightly wider than it really is
[22:09:52] <brson> i'll try that
[22:09:53] <bblum> brson: the use case for message_queue is isomorphic to pipes's send() and try_recv(), right? no blocking recv()?
[22:09:54] <Eridius> so the longer the line, the further the cursor is to the right
[22:10:06] <strcat> brson: well compare the IR from clang vs rustc
[22:10:08] <strcat> that's easier
[22:10:17] <bblum> if so, seems like the thing to do is break pipes into two strata, and implement blocking recv() at a higher level than the sched
[22:10:21] <strcat> clang -o - -S -emit-llvm foo.c
[22:10:38] <brson> bblum: yes
[22:11:13] <bblum> oh hmm... pipes send has a case where it might wake
[22:11:39] <bblum> maybe have the lower-level send() return a task that was blocked, if any, and just have a scheduler wrapper around it that asserts the blocked task is always None
[22:11:45] <sully> ok, hm.
[22:11:51] <sully> I am going to try to fix how vtables are stored.
[22:11:56] <sully> at least a little.
[22:11:58] <bblum> and a pipes wrapper which takes the blocked task and wakes it
[22:12:08] <bblum> sully: you are doing god's work
[22:13:32] <sully> although, hm.
[22:13:50] *** Quits: cr (anonymous@moz-94668A09.dip0.t-ipconnect.de) (Quit: cr)
[22:14:29] <sully> hm, I have stopped getting color in my rust error messages
[22:14:34] <brson> does anybody have dherman's strange loop slides?
[22:14:35] <cmr> That's not good
[22:15:01] <cmr> sully: mind doing RUST_LOG=extra::term=4,extra::terminfo=4 ?
[22:15:10] <cmr> (and gisting me the log)
[22:15:35] <strcat>     static xs: &'static [int] = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
[22:15:37] <strcat>     let result = xs.iter().take_while(|&x| *x < 8).fold(0, |a, b| a + *b);
[22:15:39] <strcat>     use_thing(result);
[22:15:41] <strcat> brson: will clang actually constant fold something like that?
[22:15:55] <strcat> we do generate good code for examples like that but it doesn't constant-fold if there's an array
[22:16:22] <bblum> brson: https://github.com/strangeloop/strangeloop2012/blob/master/slides/elc/Herman-Rust.pdf
[22:16:36] <strcat> we do some weird stuff
[22:16:45] <strcat> it's the fault of rustc/arrays though :(
[22:17:04] <sully> cmr: https://gist.github.com/msullivan/5862958
[22:17:07] <strcat> oh it's just heap-allocated ones that are super messed up
[22:17:26] <sully> (this might have stopped working a long time ago and I just didn't notice)
[22:17:29] *** Joins: yong_ (chatzilla@74DA0C97.4E87ADC2.263D9828.IP)
[22:17:54] <strcat> brson: http://ix.io/6mG I miss 'volatile' ;p
[22:18:12] *** Quits: yong (chatzilla@74DA0C97.4E87ADC2.263D9828.IP) (Ping timeout)
[22:18:12] <cmr> sully: your terminal doesn't support ANSI colors, use xterm-color or xterm-256color as your TERM
[22:18:18] *** Joins: Swenson (KELEBEK@5CDBDACC.3D470C6C.F82549C5.IP)
[22:18:25] *** yong_ is now known as yong
[22:18:33] <cmr> Or, at least, doesn't *advertise* the fact that it does properly
[22:18:47] <bblum> cmr: doesn't work for me either
[22:18:50] <bblum> even with TERM=
[22:18:57] <cmr> what sha? :\
[22:19:01] <strcat> bblum: with TERM=xterm-256color ?
[22:19:14] <bblum> strcat: oh that works
[22:19:25] <sully> ok, setting it to xterm-256color makes it work but I think I disapprove of xterm's default setting not working
[22:19:30] <sully> env
[22:19:32] <sully> derp
[22:19:36] <cmr> sully: xterm doesn't support 16 colors.
[22:19:52] <strcat> sully: the default setting should be xterm-256color ;p
[22:20:02] <cmr> We only use... 3, but extra::term is full-ansi colors
[22:20:06] <bblum> if i set xfce4-terminal to emulate xterm-256color, it barfs
[22:20:13] *** Quits: Ralith (ralith@moz-281960C6.wireless.sfu.ca) (Ping timeout)
[22:20:16] <bblum> so i would prefer not to do that
[22:20:27] *** Quits: brendan (brendaneic@2557E599.66715431.D25A875A.IP) (Quit: brendan)
[22:20:48] <strcat> bblum: xfce's terminal should work with TERM=xterm-256color, at least as much as it does with TERM=xterm
[22:20:52] <brson> bblum, strcat: thanks
[22:20:54] <strcat> it's just vte2
[22:20:55] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[22:21:10] <bblum> strcat: i can set an environment variable and have it work, but if i go into terminal settings, it doesn't work
[22:21:11] *** Quits: Swenson (KELEBEK@5CDBDACC.3D470C6C.F82549C5.IP) (Quit: Swenson)
[22:21:12] <sully> I mean, it seems obviously wrong to fail to use our 3 colors because a terminal doesn't support 256
[22:21:20] <bblum> i want colour back without switching terminals *or* setting an env variable every time
[22:21:21] *** Joins: Ralith (ralith@moz-281960C6.wireless.sfu.ca)
[22:21:22] <strcat> bblum: does it actually set TERM?
[22:21:26] <strcat> I think xfce terminal is broken now
[22:21:27] <cmr> sully: it only checks that 16 are supported, not 256
[22:21:30] <strcat> and can't set TERM via the setting
[22:21:38] <strcat> because vte changed and they didn't ever update it
[22:21:40] <sully> how many does xterm support?
[22:21:42] <cmr> 8
[22:22:01] <cmr> I don't even know which 8 they are, it does its own thing
[22:22:02] <bblum> i miss the bold red too
[22:22:03] <toddaaro> why is 8 not enough for the 3 colors rustc uses?
[22:22:04] <bblum> unbold red sucks
[22:22:05] <Eridius> cmr: why does extra::term require 16 colors instead of 8 anyway?
[22:22:17] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[22:22:17] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/yL8auA
[22:22:17] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[22:22:24] <bblum> strcat: i dunno. i guess i can export TERM in my bashrc.
[22:22:26] <cmr> Eridius: because extra::term is ANSI emulation/wrapping
[22:22:29] <Eridius> cmr: seems to be extra::term should advertise the number of supported colors, not just whether colors are supported. It should also allow for usign all 256 colors
[22:22:30] <strcat> bblum: or use a working terminal ;p
[22:22:41] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[22:22:47] *** Joins: brendan (brendaneic@2557E599.66715431.D25A875A.IP)
[22:22:49] <bblum> strcat: ok, the compiler author is not allowed to blame terminal software
[22:22:56] <bblum> er well
[22:23:03] <bblum> we can blame it, but we can't say switch away
[22:23:05] <Eridius> cmr: well the basic ANSI color codes only supports 8 ;) to go up to 16 you have to change the code
[22:23:25] <bblum> i'm not switching away from xfce4-terminal because it's the only terminal that has all the features i want
[22:23:33] <strcat> bblum: we can say colors are supported in terminals advertising enough color support
[22:23:40] <strcat> bblum: xfce4-terminal is just vte2 with tabs though
[22:23:42] <cmr> Eridius: no you don't? http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-048.pdf
[22:23:44] <brson> strcat: that's a good one
[22:23:46] <strcat> there are lots of other vte terminals
[22:24:05] <strcat> but vte is broken-by-default and uses 'xterm' :|
[22:24:24] <bblum> alright, i guess i'm fine if i export TERM in bashrc
[22:24:41] <strcat> bblum: it's not really right to do that though because you might use the linux console now and then, or another term
[22:24:44] <strcat> or ssh
[22:24:44] *** Quits: Ralith (ralith@moz-281960C6.wireless.sfu.ca) (Ping timeout)
[22:24:48] <toddaaro> I still don't see why there is a 16 color requirement, do we need the "new 8" colors?
[22:24:48] <Eridius> cmr: the word "color" doesn't appear anywhere in that PDF. What am I looking for?
[22:24:59] <kimundi> strcat: Did you see the last meeting notes? Specifically the links to reducers.
[22:25:03] <bblum> strcat: yeah true
[22:25:08] <strcat> kimundi: no
[22:25:11] <bblum> so, like, xterm supports more than 1 color, if i am not mistaken
[22:25:13] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[22:25:13] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/6VSYJg
[22:25:13] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[22:25:15] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[22:25:15] <ghrust> 01[13rust01] 15bors pushed 5 new commits to 06auto: 02http://git.io/N9Kl3g
[22:25:15] <ghrust> 13rust/06auto 145242e8d 15Daniel Micay: remove the redundant `each` method from OptVec
[22:25:15] <ghrust> 13rust/06auto 1464ee966 15Daniel Micay: container: remove internal iterators from Map...
[22:25:15] <ghrust> 13rust/06auto 14e67c48a 15Daniel Micay: remove `each` from vec, HashMap and HashSet
[22:25:17] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[22:25:20] <strcat> bblum: modern xterm is xterm-256color
[22:25:39] <strcat> the in-kernel linux console has 24 colors - nothing is worse than that anymore
[22:25:47] *** Joins: Ralith (ralith@moz-281960C6.wireless.sfu.ca)
[22:26:01] <strcat> it has 8 colors and bright + dim versions of each
[22:26:19] <toddaaro> so why would a terminal only show 8 then?
[22:26:30] <strcat> toddaaro: because they're broken
[22:26:39] <strcat> their terminfo is wrong ;\
[22:26:55] <bblum> also while we're on the subject, i wish to complain about the green-coloured span line for errors and warnings :|
[22:26:58] <Eridius> xterm is a de facto TERM for a bunch of terminals, even though it limits the number of colors
[22:26:58] <strcat> they're lazy so they leave it at the vte default of 'xterm' instead of making their own terminfo file
[22:27:14] <toddaaro> well, the default should be fine on something like that
[22:27:20] <doy> why has that not been fixed by now, anyway
[22:27:25] <doy> it's not like writing a terminfo file is hard
[22:27:28] <toddaaro> so if the default shouldn't be xterm the default shouldn't be xterm and then no one will have to care
[22:27:37] <strcat> doy: because vte is close to a dead project
[22:27:42] <strcat> as with 99% of gnome
[22:27:57] <strcat> there are 2-3 "active" devs who work on vte, but they have 30 other projects to look after
[22:28:02] <Eridius> one of the problems with using a new terminfo is there's a lot of legacy software that doesn't understand terminfo and instead just looks for "xterm" and "screen"
[22:28:03] <strcat> one of them has to look after all of pango
[22:28:19] <doy> Eridius: sure, but that's always going to be broken
[22:28:22] <strcat> they don't even look at bug reports
[22:28:30] <strcat> they stay UNCONFIRMED with attached, working patches
[22:28:33] <Luqman> Jeaye: no, the colours weren't me
[22:28:38] *** Quits: Ralith (ralith@moz-281960C6.wireless.sfu.ca) (Ping timeout)
[22:28:51] *** Quits: lucian (lucian@moz-22A14C6A.cable.virginmedia.com) (Connection reset by peer)
[22:28:57] <Jeaye> Luqman: Hmm, alright. I'll have to check my logs then. :)
[22:29:00] <strcat> there *are* vte-based terminals that set TERM right ;p
[22:29:11] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[22:29:32] <Jeaye> Eridius: It was you! :P
[22:29:35] <Eridius> Jeaye: when you say "getting colors into terminals", are you talking about the terminfo support?
[22:29:41] <Eridius> because that was cmr, then me
[22:29:49] <cmr> Eridius: 8.3.117
[22:29:54] <Jeaye> Yes, I reckon'
[22:29:57] *** Joins: Ralith (ralith@moz-281960C6.wireless.sfu.ca)
[22:30:10] <Jeaye> Eridius: I'm curious why I get colored output when compiling some projects, but not others.
[22:30:33] <Eridius> cmr: that section defines 8 foreground colors, using 30-37
[22:30:52] <Eridius> Jeaye: if you're using the same TERM on all compilations, then you must be using different versions of rustc
[22:31:07] <Jeaye> Same rustc all around.
[22:31:12] <strcat> Eridius: Jeaye: toddaaro: bblum: https://paste.xinu.at/eGV/
[22:31:14] <Eridius> Jeaye: same machine, terminal, and TERM?
[22:31:18] *** Quits: Aetherspawn_ (Aetherspaw@moz-8811D9F0.static.tpgi.com.au) (Connection reset by peer)
[22:31:23] <Jeaye> Eridius: Yes.
[22:31:30] *** Quits: brendan (brendaneic@2557E599.66715431.D25A875A.IP) (Quit: brendan)
[22:31:31] <strcat> ;p
[22:31:40] * strcat shrugs
[22:31:48] <Eridius> strcat: I wish ponysay looked good in my terminal, but it doesn't play nicely with my font :/ (which reminds me, I should file a bug about it)
[22:32:00] <Eridius> basically some of the block glyphs don't butt up to the edge of the bounding box for some reason
[22:32:00] *** Quits: Mowah (Mowah@moz-C7674B3E.cust.bredbandsbolaget.se) (Ping timeout)
[22:32:05] <Jeaye> strcat: heh :P
[22:32:09] *** Quits: timot (timot@moz-275D4A76.cust.telenor.se) (Ping timeout)
[22:32:09] *** Quits: EXetoC (ex@moz-2DBEB1E4.customer.t3.se) (Ping timeout)
[22:32:10] <strcat> Eridius: vte draws those itself
[22:32:11] *** Quits: noj (jon@moz-D51AE9DE.swym.se) (Ping timeout)
[22:32:13] <strcat> instead of using the font
[22:32:22] *** Joins: noj (jon@moz-D51AE9DE.swym.se)
[22:32:24] <strcat> because fonts never fill the whole box
[22:32:29] <cmr> Eridius: Right, but I don't consider setting *extra* SGR's changing the code.
[22:32:31] <Eridius> Jeaye: weird. color doesn't depend on the project, only on your TERM, terminfo file, actual terminal used, and whether you have a new-enough version of rustc
[22:32:43] <Eridius> strcat: hmm, maybe I should file a bug on Terminal to do that
[22:32:45] <strcat> Eridius: your monospace font might lack the unicode glyphs it uses
[22:32:54] <strcat> Eridius: so it might be using fallbacks
[22:32:55] *** Joins: timot (timot@9EBCF91B.ABED94CE.898DC978.IP)
[22:33:10] <Eridius> strcat: hmm, maybe
[22:33:20] *** Quits: Ralith (ralith@moz-281960C6.wireless.sfu.ca) (Ping timeout)
[22:33:22] *** Quits: incDec (Mibbit@moz-5949C51B.dllstx.fios.verizon.net) (Quit: http://www.mibbit.com ajax IRC Client)
[22:33:34] <Eridius> cmr: you say extra::term is an ANSI wrapper, but you're requiring support for SGR's that aren't in the PDF you linked
[22:33:40] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[22:33:42] <cmr> Eridius: it's sgr 1
[22:33:47] <Jeaye> Eridius: TERM is rxvt-256color all around, same rustc, and I don't know what a terminfo file is.
[22:33:54] <Eridius> cmr: no, 16 color does not mean it supports bolded colors
[22:34:16] <strcat> Jeaye: is it actually rxvt?
[22:34:24] <Jeaye> strcat: xterm, actually.
[22:34:25] <seth> how can i debug this? "Assertion failed: (!borrow_list), function delete_this, file .../servo/src/compiler/rust/src/rt/rust_task.cpp, line 80."
[22:34:34] <strcat> Jeaye: should be xterm-256color then or the escapes are wrong :(
[22:34:40] <bblum> for num_squiglies.times() { s += "~"; }
[22:34:41] <klutzy> 16 color means it supports aixterm colors, not the original xterm one
[22:34:44] <bblum> i just wanna say i'm really happy about this
[22:34:49] <Jeaye> strcat: That's good reasoning. :P
[22:34:49] <jack> seth: gdb and break on upcall_fail?
[22:35:16] <strcat> Eridius: it's finally happy with your pull ;p
[22:35:19] <strcat> http://buildbot.rust-lang.org/bors/bors.html \o/
[22:35:23] <strcat> silly bors
[22:35:25] <Eridius> strcat: \o/
[22:35:27] *** Joins: Ralith (ralith@moz-281960C6.wireless.sfu.ca)
[22:35:33] <Eridius> strcat: it couldn't have happened to a more trivial pull ;)
[22:35:40] <sully> althoug hm, maybe I shouldn't bother cleaning up the vtable representation now
[22:35:42] <cmr> Eridius: every terminal I know of interprets it as intensity, not bold... ie, 8 more colors
[22:35:53] <sully> and instead just do a bigger cleanup of substs and vtable stuff later in the summer
[22:36:01] <strcat> cmr: well, the bright/bold colors are the same
[22:36:11] <Eridius> cmr: Terminal.app has a preference for whether bold means actually bold or just intensity. I don't remember what it defaults to, but I know it at least used to default to treating it as real bold
[22:36:17] <cmr> strcat: well it could be changing the typeface not color
[22:36:18] <strcat> there are 8 colors and bright/dim versions of each
[22:36:20] <strcat> adding up to 24
[22:36:34] *** Quits: gareth0 (gareth0@7C428FA9.3FD5F917.1A294DCF.IP) (Quit: Leaving)
[22:36:41] <strcat> if you use bold, it uses bright + makes them bold
[22:36:49] <strcat> I don't think you can get bold without bright colors
[22:36:52] <seth> jack: ah yes, upcall_fail. thanks
[22:36:57] <Eridius> ok yeah it defaults to being bold even today
[22:37:04] <klutzy> you can't use bright colors as background colors as well
[22:37:10] *** Joins: EXetoC (ex@moz-2DBEB1E4.customer.t3.se)
[22:37:13] <Eridius> actually it has two checkboxes, one for "use bold fonts" and one for "use bright colors for bold text"
[22:37:17] <cmr> klutzy: that's true
[22:37:28] <strcat> Eridius: yep that makes sense
[22:37:54] <strcat> Eridius: bright/bold are separate but usually bold implies bright
[22:37:57] <klutzy> cmr: aixterm extended that, and it is now de facto standard, but terminfo still recognizes "xterm" has only 8 colors
[22:38:23] <strcat> the ncurses terminfo db is also not very good
[22:38:26] <cmr> So should we bump down extra::term to just say "allows printing colored text in 8 colors"?
[22:38:28] <strcat> it has a lot of mistakes and omissions
[22:38:29] <cmr> strcat: yeah it's awful
[22:38:39] <cmr> I was looking through it for various terminals and it's quite bad
[22:38:40] <strcat> they're missing the statusline entries
[22:38:41] <strcat> tsl/fsl
[22:38:46] *** Joins: lmandel (lmandel@556E85CD.E855F8D7.412CF160.IP)
[22:39:11] *** Joins: Mowah (Mowah@moz-C7674B3E.cust.bredbandsbolaget.se)
[22:39:20] <strcat> terminals that ship their own terminfo like urxvt can provide correct ones including tsl/fsl, etc.
[22:39:55] * strcat hopes tmux will finally start shipping a terminfo file instead of using 'screen', which has the wrong escapes for tmux...
[22:39:59] <Eridius> well that's interesting. my xterm terminfo file remaps some of the color codes. 1 is \E[34m and r is \E[31m
[22:41:57] <Eridius> well, that's what infocmp says, but `tput setaf 1` still emits \E[31m
[22:42:02] <Eridius> which leaves me a bit confused
[22:42:06] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[22:43:14] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[22:43:17] *** Quits: pcwalton (pcwalton@43CB6079.66715431.D25A875A.IP) (Quit: pcwalton)
[22:43:26] *** Quits: josh (josh@CB3EC984.A5F785DE.396E4C6D.IP) (Quit: josh)
[22:43:51] <steven_is_false> How can I assign to a value without calling the finalizer on the old value?
[22:43:59] <steven_is_false> I just want to forget about the old value.
[22:44:04] <Eridius> util::forget()?
[22:44:13] <cmr> uit's called forget but I don't recall where it lives
[22:44:17] <cmr> I thought it was an intrinsic
[22:44:20] *** Joins: Barosl (Barosl@E287D94F.C81E10FB.7544CABF.IP)
[22:44:27] <Luqman> strcat: r? https://github.com/mozilla/rust/pull/7269
[22:44:30] <Eridius> oh it's not util. I thought it was
[22:44:38] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[22:44:57] <Eridius> cast::forgeT()
[22:44:59] <strcat> Luqman: r+
[22:45:00] <Eridius> s/T/t/
[22:45:04] <Eridius> http://static.rust-lang.org/doc/std/cast.html#function-forget
[22:45:06] <strcat> heh cmr did too
[22:45:07] <cmr> strcat: you beat me to it!
[22:45:16] <cmr> by 3 seconds, according to github
[22:45:24] *** Quits: Ralith (ralith@moz-281960C6.wireless.sfu.ca) (Ping timeout)
[22:45:27] <cmr> I don't actually know why I r+'d it
[22:45:28] *** Quits: Kruppe (user@moz-4DDA8AB8.uwaterloo.ca) (Ping timeout)
[22:45:35] <cmr> All I remember is a tab opening... :p
[22:46:09] <Luqman> cmr: it's become an automatic response :P
[22:46:31] *** Joins: roo (jesse.rudo@moz-DCBE6A9B.dynamic.ip.windstream.net)
[22:46:59] <steven_is_false> Okay but I can't move out of a pointer dereference so I can't forget the value.
[22:47:07] <Eridius> cmr: why the heck does extra::term have both spellings of gray/grey?
[22:47:10] *** Joins: Ralith (ralith@moz-281960C6.wireless.sfu.ca)
[22:47:16] *** Quits: echristo (echristo@60A74940.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[22:47:17] <cmr> Eridius: not my code
[22:47:24] <Eridius> steven_is_false: util::swap it with something you can control?
[22:47:32] <steven_is_false> Eridius: That makes sense
[22:47:51] <cmr> Eridius: Those are probably the only lines I didn't change in there :p
[22:48:10] <bblum> https://github.com/mozilla/rust/pull/7391 someone please r+ this it's really easy
[22:48:19] <bblum> i hope there are no test cases for this behaviour
[22:48:19] <Eridius> cmr: heh it's pcwalton's code
[22:48:28] <sully> ok, is there anybody who would be opposed to me de-flattening vtables?
[22:48:34] <steven_is_false> How do I do an unsafe init?
[22:48:38] <cmr> sully: what does that mean?
[22:48:44] <steven_is_false> fn init<T>()->T;
[22:49:04] *** Quits: Ralith (ralith@moz-281960C6.wireless.sfu.ca) (Ping timeout)
[22:49:07] <sully> right now, in the compiler, we represent vtable resolutions as a flattened list
[22:49:11] <steven_is_false> NVM
[22:49:19] *** Joins: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[22:49:28] *** Quits: ssbr (ssbr@moz-141F89C6.block0.gvtc.com) (Ping timeout)
[22:50:08] *** Joins: dew (Instantbir@moz-66796D51.dhcp.stls.mo.charter.com)
[22:50:13] <sully> so as @~[vtable_origin]
[22:50:18] <bblum> cmr: thanks
[22:50:26] <sully> and so it has all of the vtables for the first type param, then all the vtables for the second, etc
[22:51:31] *** Joins: Ralith (ralith@moz-281960C6.wireless.sfu.ca)
[22:51:49] <bblum> strcat: ok, so, if i set TERM=xterm-256color, it interferes with whether my bright colours show up bold or not
[22:51:49] *** Joins: cr (anonymous@moz-94668A09.dip0.t-ipconnect.de)
[22:51:54] <bblum> i need my bold
[22:52:03] <Eridius> bblum: your bright colors are supposed to be bold? o_O
[22:52:03] <bblum> so i can't set TERM that way
[22:52:08] <Eridius> but bold is orthogonal to bright
[22:52:15] <bblum> well, i like it that way
[22:52:18] <Eridius> on any _proper_ terminal :P
[22:52:26] <strcat> well vte2 is buggy
[22:52:28] <bblum> i wanna be improper ._.
[22:52:31] <strcat> they don't backport fixes ;S
[22:52:38] *** Joins: echristo (echristo@D423593A.D6CCE4AE.77834EAA.IP)
[22:52:39] <bblum> i just want rustc to output colours if TERM=xterm
[22:52:44] <bblum> is that out of the question?
[22:52:53] <strcat> bblum: dunno
[22:53:17] <Eridius> hrm, why is extra::term even using the name color_light_gray? The code actually means "white"
[22:53:38] *** Quits: lmandel (lmandel@556E85CD.E855F8D7.412CF160.IP) (Quit: lmandel)
[22:54:29] <bblum> Eridius: i have a distinct white, light grey, dark grey, and black
[22:54:36] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[22:55:25] <Eridius> bblum: I think your "dark grey" is the bright version of "black"
[22:55:37] <seth> is there some way to inspect local variables in gdb with rust programs?
[22:55:40] <bblum> hm
[22:55:43] <strcat> vte has 256 colors and 255 of them can be configured, so there's no real guarantee about colors ;p
[22:55:45] <seth> not working here
[22:55:59] <strcat> unless you use the evil escapes to set the colorscheme
[22:56:12] <Eridius> strcat: does the configuration affect colors specified with \E[31m instead of \E[38;5;1m ?
[22:56:23] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[22:56:23] *** ChanServ sets mode: +o brson
[22:56:39] *** kimundi is now known as zz_kimundi
[22:56:57] <strcat> Eridius: yes
[22:57:15] <strcat> Eridius: both
[22:58:02] <strcat> and they just implement the dim escape by indexing certain pre-defined offsets into the 256 color palette
[22:58:17] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[22:58:27] <strcat> so they have...
[22:58:39] *** Joins: josh (josh@CB3EC984.A5F785DE.396E4C6D.IP)
[22:58:54] <strcat> |8 normal colors|8 bright colors|239 configurable colors|white|
[22:59:01] <Luqman> seth: the debug support still needs a lot of work
[22:59:04] <strcat> (and you can configure the first 16 too)
[22:59:20] <strcat> afaik the reason you can't edit the final color is a bug
[22:59:29] <strcat> but they never responded to my bug report
[22:59:46] * strcat thinks it's an off-by-one error on the bounds check :|
[23:00:17] <bblum> "hooray" for handwritten bounds checks
[23:00:21] *** Quits: roo (jesse.rudo@moz-DCBE6A9B.dynamic.ip.windstream.net) (Ping timeout)
[23:01:45] <strcat> bblum: at least they were off by one into the array
[23:01:47] <strcat> so it's not a security bug ;p
[23:02:10] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Textual IRC Client: www.textualapp.com)
[23:02:17] <bblum> strcat: "at least"
[23:02:22] <seth> so "also try setting RUST_LOG to ::help" is probably not the best way of describing that feature
[23:02:27] <bblum> doesn't do any good for your peace of mind though
[23:02:28] * seth edits the wiki page
[23:05:23] <strcat> bblum: well I pretty much just assume all this gnome software written in C is horribly insecure/buggy ;p
[23:05:26] *** Joins: pcwalton (pcwalton@43CB6079.66715431.D25A875A.IP)
[23:05:26] *** ChanServ sets mode: +o pcwalton
[23:07:04] *** Quits: josh (josh@CB3EC984.A5F785DE.396E4C6D.IP) (Quit: josh)
[23:08:18] *** Joins: brendan (brendaneic@2557E599.66715431.D25A875A.IP)
[23:08:18] <seth> does "debug!" flush after each logged statement?
[23:08:31] <seth> i seem to miss some output before crashing
[23:08:41] <strcat> pcwalton: btw I don't think we can have the clojure/racket-like reducer things - they seem to just be thunks
[23:08:45] <strcat> as in we'd have to use @fn
[23:09:07] <pcwalton> oh, can't use &fn?
[23:09:10] <strcat> haskell's built-in "iterator" is just a lazy list and then they have stuff like pipes because laziness sometimes sucks
[23:09:13] <strcat> pcwalton: it has to return a closure
[23:09:17] <pcwalton> oh
[23:09:19] <pcwalton> oops
[23:09:21] <strcat> i.e. the core work of map f looks like this:
[23:09:23] <strcat> (fn [f1]
[23:09:25] <strcat>   (fn [ret v]
[23:09:27] <strcat>     (f1 ret (f v))))
[23:09:29] <strcat> It takes a reducing function f1, and returns a new reducing function that calls f1 after applying f to its input.
[23:09:31] <strcat> from a blog post about it
[23:09:51] <strcat> http://clojure.com/blog/2012/05/08/reducers-a-library-and-model-for-collection-processing.html
[23:10:20] <strcat> racket is a scheme so they could be using actual coroutines with the dynamic unwind stuff afaik
[23:12:25] *** Quits: tjc (tjc@moz-6ED8F8B5.dsl.lsan03.pacbell.net) (Connection reset by peer)
[23:12:58] <strcat> http://docs.racket-lang.org/reference/dicts.html#(def._((lib._racket/dict..rkt)._dict-iterate-next))
[23:13:03] <strcat> these seem like external iterators
[23:13:40] <strcat> but racket seems to have 40 ways of iterating. ;p
[23:15:21] <strcat> http://download.racket-lang.org/docs/5.0.2/html/reference/sequences.html#(part._.Iterator_.Generators) generators are definitely external iterators (like python)
[23:15:49] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[23:16:13] * strcat doesn't know what he's supposed to be looking for ;)
[23:16:46] *** Quits: brendan (brendaneic@2557E599.66715431.D25A875A.IP) (Quit: brendan)
[23:18:15] *** Joins: tjc (tjc@moz-6ED8F8B5.dsl.lsan03.pacbell.net)
[23:18:15] *** ChanServ sets mode: +o tjc
[23:18:47] *** Quits: tjc (tjc@moz-6ED8F8B5.dsl.lsan03.pacbell.net) (Connection reset by peer)
[23:19:23] *** Quits: cr (anonymous@moz-94668A09.dip0.t-ipconnect.de) (Quit: cr)
[23:19:41] *** Quits: bytbox (s@moz-D83E9B31.wireless.umd.edu) (Ping timeout)
[23:20:05] *** Joins: MaikKlein (maik@moz-3D9AD16.dip0.t-ipconnect.de)
[23:22:17] <strcat> anyway will make a new mailing list thread about 'for'
[23:22:24] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[23:22:29] <strcat> and the requirements
[23:23:54] *** Quits: lkuper (lkuper@ACA1ECB.2FC96E37.51B6877.IP) (Ping timeout)
[23:24:11] *** Quits: joelteon (joel@moz-317E8D0C.io) (Ping timeout)
[23:24:14] *** Quits: azita (Azita@2557E599.66715431.D25A875A.IP) (Quit: azita)
[23:24:19] *** Joins: tjc (tjc@moz-6ED8F8B5.dsl.lsan03.pacbell.net)
[23:24:19] *** ChanServ sets mode: +o tjc
[23:24:31] *** Quits: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP) (Ping timeout)
[23:24:31] *** Quits: tjc (tjc@moz-6ED8F8B5.dsl.lsan03.pacbell.net) (Connection reset by peer)
[23:24:53] *** Quits: Ralith (ralith@moz-281960C6.wireless.sfu.ca) (Ping timeout)
[23:25:05] *** Joins: azita (Azita@2557E599.66715431.D25A875A.IP)
[23:25:41] *** Quits: spider-mario (spidermari@moz-B8FA2FF4.rev.sfr.net) (Input/output error)
[23:25:48] <MaikKlein> how do I activate default methods again?
[23:26:04] <cmr> MaikKlein: #[allow(default_methods)]
[23:26:11] <MaikKlein> cmr, right thanks
[23:26:25] <Luqman> local_free was for what kind of allocations again?
[23:26:36] <strcat> Luqman: managed ones
[23:26:44] <strcat> @ or ~ containing @
[23:26:56] <strcat> ~ only uses exchange alloc when it doesn't contain @
[23:28:42] *** Quits: pcwalton (pcwalton@43CB6079.66715431.D25A875A.IP) (Quit: pcwalton)
[23:30:56] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[23:31:02] *** aatch|gone is now known as aatch
[23:31:21] *** Joins: pcwalton (pcwalton@2557E599.66715431.D25A875A.IP)
[23:31:21] *** ChanServ sets mode: +o pcwalton
[23:31:54] *** Quits: MaikKlein (maik@moz-3D9AD16.dip0.t-ipconnect.de) (Ping timeout)
[23:32:16] *** Joins: joelteon (joel@moz-317E8D0C.io)
[23:32:49] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[23:33:31] <cmr> Is marking functions #[inline] ever really necessary? Does LLVM have good heuristics by default?
[23:33:34] *** Quits: eholk (eholk@moz-786AC74A.uconnect.utah.edu) (Quit: eholk)
[23:33:43] *** Joins: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP)
[23:34:00] <aatch> cmr, marking it #[inline] allows for cross-crate inlining.
[23:34:07] <cmr> Oh, right
[23:35:42] <bblum> wow i am just so much happier with the spans coloured correctly
[23:35:59] * bblum cares a bunch about good visual reinforcement
[23:37:38] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Quit: WeeChat 0.4.1)
[23:38:24] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[23:38:25] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[23:38:29] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[23:38:45] *** Quits: lucian (lucian@moz-22A14C6A.cable.virginmedia.com) (Input/output error)
[23:38:59] <brson> strcat: can i ask you about some asm?
[23:39:13] <cmr> can ask me if he says no :p
[23:39:21] <strcat> brson: I'm not great at x86 assembly ;p
[23:40:02] <brson> ok: I'm looking at this asm of an optimized iterator https://gist.github.com/brson/5863454
[23:40:09] <bblum> brson: you're gonna love this
[23:40:14] <brson> i don't understand these lines https://gist.github.com/brson/5863454
[23:40:19] <brson> wait...
[23:40:22] <brson> lines 10-13
[23:40:33] <brson> xorl -> xorb -> test -> jump
[23:41:10] <strcat> brson: the xors just zero the register
[23:41:26] <strcat>  xorb %al, %al
[23:41:27] *** Joins: jedestep (jedestep@moz-2C53377F.natpool.nyu.edu)
[23:41:28] <strcat> testb %al, %al
[23:41:30] <strcat> that's weird
[23:41:33] <brson> strcat: i don't see why though
[23:41:34] <cmr> that is weird
[23:41:48] <cmr> that's an unconditional branch
[23:42:14] <brson> bblum: what have you got/
[23:42:19] <brson> *?
[23:42:23] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[23:42:44] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[23:43:23] <strcat> brson: the loop itself is sane
[23:43:30] <strcat> I don't understand the prelude leading into it
[23:44:09] <strcat> the loop has the integer addition, the pointer addition, the end check
[23:44:42] *** Quits: H4199 (chatzilla@moz-64E556D3.austin.res.rr.com) (Ping timeout)
[23:44:59] <toddaaro> brson: he has grand ideas on the three context swap functions, it seems we might be able to clean those up a fair bit
[23:45:09] <toddaaro> brson: (assuming bblum's grand ideas work out)
[23:45:44] <brson> toddaaro: nice. i like cleanup
[23:46:16] *** Joins: H4199 (chatzilla@moz-64E556D3.austin.res.rr.com)
[23:47:21] <cmr> That jne will never be taken, why didn't it optimize that away? doesn't make sense.
[23:47:34] <cmr> yay for branch predication, right? :p
[23:47:54] <brson> cmr: ok, so you think those 4 lines are a noop?
[23:47:56] *** Quits: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com) (Ping timeout)
[23:48:19] <strcat> brson: they might be prelude for calling print_result
[23:48:25] <strcat> it knows print_result is always called
[23:48:30] <cmr> Zeroing those registers might be useful for some reason I do not know, but I don't know why the testb/jne is there
[23:48:30] <strcat> it could be setting up before the loop for some reason
[23:48:44] *** Joins: lkuper (lkuper@66AE1C4.B4544612.EA8B5958.IP)
[23:48:44] <doener> brson: line 10 initializes the "a" in the fold to 0
[23:48:45] <bblum> brson: just left a comment
[23:48:47] <aatch> `test` can alter a lot of flags
[23:48:53] <bblum> this isn't even a very grand idea
[23:49:01] <doener> brson: edi is the 32bit part of rdi
[23:49:08] <strcat> doener: ah
[23:49:12] <strcat> what's al for there?
[23:49:26] <cmr> aatch: right but why would it add a jump that's never used?
[23:49:26] <strcat> seems pretty weird to zero it and do that test
[23:49:57] <doener> yeah, that looks bogus, same for the rax test on line 18
[23:50:52] <cmr> doener: does seem odd, especially since rax is incremented, not decremented.
[23:51:10] <doener> and the interesting check is on line 22 anyway
[23:51:21] *** Quits: dherman (dherman@2557E599.66715431.D25A875A.IP) (Quit: dherman)
[23:51:30] <cmr> Someone ask the llvm people why the asm they generate is blatently unoptimized :p
[23:51:44] <doener> maybe some remains of a drop glue? That would check for 0
[23:51:47] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[23:51:49] *** Joins: Ralith (ralith@moz-50F3C77.vc.shawcable.net)
[23:51:58] <strcat> doener: no dropped things though
[23:52:11] <doener> true
[23:52:20] <aatch> Hmm, what's `%rip`? Instruction pointer?
[23:52:23] <cmr> yes
[23:52:35] <cmr> That's just what'sitcalled
[23:52:42] <cmr> relative addressing or somesuch
[23:52:49] <cmr> used for pic
[23:53:17] <strcat> it could just be our terrible closure code
[23:53:27] <strcat> from the closure in the fold
[23:53:45] <cmr> I'd still expect llvm to perform analysis and optimize the generated machine code
[23:53:51] <cmr> that's basic dataflow
[23:54:11] <strcat> well it's doing something we don't understand
[23:54:46] *** Quits: Jesse (jruderman@2557E599.66715431.D25A875A.IP) (Quit: Jesse)
[23:55:39] <Luqman> so it somehow thinks rax could become 0?
[23:56:12] <strcat> it thinks it could be a null pointer I guess? ;\
[23:56:20] <strcat> doesn't make much sense to me
[23:57:09] <strcat> oh
[23:57:13] <strcat> our IR is undef behaviour
[23:57:15] <strcat> that explains it
[23:57:32] <strcat> brson: I think this is a side effect of our broken IR
[23:57:33] *** Quits: Benvie_ (brandon@5FD20F9A.53D07D95.EFF8B7BF.IP) (Quit: )
[23:57:56] *** Quits: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP) (Ping timeout)
[23:58:19] *** Quits: joelteon (joel@moz-317E8D0C.io) (Ping timeout)
[23:58:30] <aatch> strcat, possibly... If I compile an LLVM bitcode file with clang and look at the asm it produces, we get the same thing.
[23:58:39] <strcat> http://ix.io/6mJ
[23:58:42] <strcat> lots of undef behaviour
[23:59:07] <strcat>                     if self.ptr == self.end {
[23:59:09] <strcat>                         None
[23:59:11] <strcat>                     } else {
[23:59:13] <strcat>                         let old = self.ptr;
[23:59:15] <strcat>                         self.ptr = self.ptr.offset($step);
[23:59:17] <strcat>                         Some(cast::transmute(old))
[23:59:19] <strcat>                     }
[23:59:21] <strcat> this is the vector iterator
[23:59:23] <strcat> cast::transmute causes undef behaviour
[23:59:25] <strcat> any cast::transmute.

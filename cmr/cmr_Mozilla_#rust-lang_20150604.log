[02:44:21] *** WindowsBunny is now known as BunnyServ
[02:56:07] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[03:37:25] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[04:24:49] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[07:51:13] *** Joins: Tobba (Tobba@moz-6oh.7ki.21.217.IP)
[09:00:56] *** Quits: Tobba (Tobba@moz-6oh.7ki.21.217.IP) (Ping timeout: 121 seconds)
[09:10:47] *** Joins: Tobba (Tobba@moz-6oh.7ki.21.217.IP)
[09:27:14] *** Quits: Tobba (Tobba@moz-6oh.7ki.21.217.IP) (Ping timeout: 121 seconds)
[09:50:50] *** Quits: nrc (nrc@moz-14pjgj.xtra.co.nz) (Ping timeout: 121 seconds)
[09:53:18] *** Joins: nrc (nrc@moz-14pjgj.xtra.co.nz)
[09:59:28] *** Joins: Tobba (Tobba@moz-6oh.7ki.21.217.IP)
[10:51:39] *** Quits: nrc (nrc@moz-14pjgj.xtra.co.nz) (Ping timeout: 121 seconds)
[13:02:20] *** Quits: Tobba (Tobba@moz-6oh.7ki.21.217.IP) (Ping timeout: 121 seconds)
[13:33:49] <nmatsakis> pnkfelix: one thing that came up when talking to MF and JT is that it would be helpful if we gave a way to explicitly name regions, and made sure that we have a notation for explicitly writing out regions
[13:34:01] <nmatsakis> which of cousre we've talked about doing
[13:34:10] <nmatsakis> it doesn't seem too hard to at least let you write names for blocks and statements and so forth
[13:34:20] <nmatsakis> it's a bit harder to let you specify the values for lifetimes everywhere
[13:34:43] <nmatsakis> but it'd be good to make some incremental progress here I imagine
[13:35:11] <pnkfelix> would it be an interesting start to let people put the names on the blocks and try to integrate them into the region inference error messages ?
[13:35:15] <nmatsakis> I think at least letting you write names and specify the duration on the borrow operator (e.g., let x = &'x *y) would be great
[13:35:19] <nmatsakis> yes, I was thinking that
[13:35:25] <nmatsakis> that when we lookup the scope
[13:35:28] <nmatsakis> we could see if it has a name
[13:35:28] <nmatsakis> and use it
[13:35:42] <nmatsakis> anyway, being able to give names for scopes and write them out explicitly would I think
[13:35:46] <nmatsakis> be helpful when explaining how the rules work
[13:35:49] <pnkfelix> it may not be the first step that MF + JT wanted
[13:36:10] <nmatsakis> basically what they want
[13:36:18] <nmatsakis> is a way to make the mechanics of the type system more transparent 
[13:36:19] <pnkfelix> but it seems like trying to get that working would be the smallest change that might still expose a lot of interesting infrastructure issues
[13:36:22] <nmatsakis> so that people can understand that first
[13:36:27] <nmatsakis> and then view inference as helping them along
[13:36:29] <pnkfelix> yes
[13:37:03] <pnkfelix> I see their use of "transparent" as somewhat analogous to my past use of "explicit"
[13:37:04] <nmatsakis> this is why I mentioned the two points above (giving names, using them in an `&'x` expression and types and so forth)
[13:37:31] <nmatsakis> yes, and I've always been more-or-less in favor of your principle, even though we've violated it a few places
[13:37:41] <pnkfelix> (though usually I've brought up my desire for explcitness in other contexts, e.g. variance)
[13:38:23] <nmatsakis> yes that's the main place that we've violated it that I can think of (besides lifetimes)
[13:40:45] <pnkfelix> yes.  well, there are places where we might have provided finer grain controls
[13:41:30] <pnkfelix> but that's not really the same
[13:41:51] <pnkfelix> (i'm thinking e.g. of being able to import individual methods of a trait or type)
[13:42:30] <pnkfelix> ((and I guess UFCS probably gives us the pieces necessary to emulate that...))
[13:48:20] <nmatsakis> pnkfelix: right, that's different, but true nonetheless
[13:48:48] <nmatsakis> pnkfelix: e.g. I could imagine sometime in the future being able to import fns for use in method form explicitly
[13:48:51] <pnkfelix> yeah, but not relevant.  I'm just trying to think of other examples but failing.
[13:49:19] <nmatsakis> well variance is basically the only place we do cross-crate inference
[13:49:33] <nmatsakis> so that provides a strong hint that it is unique in this regard
[13:49:59] <nmatsakis> default impls (impl Foo for ..) seem related but different
[14:12:38] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[16:46:18] *** Joins: arielb1 (Mibbit@moz-ernkhh.tau.ac.il)
[17:59:02] *** BunnyServ is now known as WindowsBunny
[19:43:08] *** Joins: nrc (nrc@moz-14pjgj.xtra.co.nz)
[20:53:12] *** Quits: arielb1 (Mibbit@moz-ernkhh.tau.ac.il) (Quit: http://www.mibbit.com ajax IRC Client)
[21:03:19] <pnkfelix> nmatsakis: given that it sounds like where-clauses kill two birds with one stone, I'm a *little* nervous about removing contravariance
[21:03:27] <pnkfelix> nmatsakis: but I think I can see the attractiveness of it
[21:04:07] <nmatsakis> pnkfelix: yeah, I know -- I think I found it attractive because it can restore the "scoped" property I was talking about, but also it seems like something we could add back, which is what I meant about stepping stones
[21:04:08] <pnkfelix> nmatsakis: I assume if we were to remove contravariance, then it would basically be gone for good; we could not put it back in later without having yet another breaking change, due to it affecting ... inference successes?
[21:04:15] <nmatsakis> pnkfelix: that is, I don't think it's a breaking change to add it back
[21:04:22] <pnkfelix> nmatsakis: oh, I assumed it would be.
[21:04:28] <nmatsakis> pnkfelix: but we'd have to of course add the for/where thing or something else
[21:04:36] <pnkfelix> nmatsakis: Okay, if you think we can take it out and then add it back in later after for/where is in
[21:04:37] <nmatsakis> pnkfelix: (if we're relying on it to handle implied bounds or provide some useful property)
[21:04:45] <nmatsakis> and if we're not relying on it to provide a useful propery, why do it :)
[21:04:45] <pnkfelix> nmatsakis: then that makes me more comfortable with the idea of taking it out
[21:05:07] <nmatsakis> but also aturon said something similar like "we'd like to know that we COULD have contravariance if we wanted it"
[21:05:14] <nmatsakis> I'm wondering how hard it would be to experiment with the for/where idea
[21:05:28] <nmatsakis> it would be nice to know the impact, but I'm wary of drawing too many lessons from a broken impl
[21:07:13] <pnkfelix> I guess my FP heart just thinks that we'll end up wanting contravariance on fn's eventually
[21:07:31] <nmatsakis> pnkfelix: oh I hear you, I think I'd be more upset if we had it for trait objects,
[21:07:41] <nmatsakis> pnkfelix: could also be that if we add more sources of subtyping, e.g. with virtual structs or something,
[21:07:44] <nmatsakis> pnkfelix: we'll regret it more
[21:07:50] <pnkfelix> ah that's true too
[21:14:26] <nmatsakis> pnkfelix: nrc: I think the thing about the for/where thing that i'm most worried about is how to deal with the "implication" bit of in subtyping. e.g. if I have `for<'a> where <$0: Trait<'a>, $1: Trait<'a>> fn(x: &'a str)` and `for<'a> where <i32: Trait<'a>, u32: Trait<'a>> fn(x: &'a str)`, what do we do? (etc)
[21:14:55] <nmatsakis> maybe if we can work through THAT somehow but...
[21:15:33] <pnkfelix> that is true, mixing System F and subtyping is known to be a hairy problem, and I imagine even with our "simplified" domain of lifetimes
[21:15:40] <pnkfelix> it probably is still bad
[21:16:11] <nmatsakis> as a mostly unrelated aside, I've been implementing this paper http://www.cs.cmu.edu/~joshuad/papers/bidir/ in Rust
[21:16:25] <nmatsakis> slowly slowly, since I only do it while having my morning coffee :)
[22:23:34] *** WindowsBunny is now known as BunnyHitler
[22:23:54] *** BunnyHitler is now known as WindowsBunny
[22:35:59] *** nrc is now known as nrc|distracted
[23:25:00] *** Quits: nrc|distracted (nrc@moz-14pjgj.xtra.co.nz) (Ping timeout: 121 seconds)

[00:11:53] *** Quits: km (quassel@moz-777F24DE.kevinmehall.com) (Ping timeout)
[00:12:03] *** Joins: km (quassel@moz-777F24DE.kevinmehall.com)
[00:17:37] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[00:19:15] *** kimundi is now known as zz_kimundi
[00:30:21] <eddyb> dbaupp: can I get more feedback or r+?
[00:31:27] <dbaupp> eddyb: yes, but not from me: I don't want to/can't make the decision about which linkages to support
[00:31:43] <eddyb> acrichto: want to join?
[00:31:57] <dbaupp> (if you need it for something now, you'll just have to use the custom patched compiler)
[00:34:18] <cmr> eddyb: link?
[00:34:31] <eddyb> cmr: https://github.com/mozilla/rust/pull/9966
[00:34:31] <dbaupp> cmr: https://github.com/mozilla/rust/pull/9966
[00:34:36] <dbaupp> heh
[00:34:37] <eddyb> ninja'd
[00:35:09] <eddyb> dbaupp: 3:30am, I should go to sleep soon, easier if I know I'm not needed anymore :P
[00:36:57] <dbaupp> eddyb: probably not, there's a lack of reviewers around on the weekend (and anyway, you can just address/respond to any comments when you wake up :) )
[00:38:10] *** Quits: dbaupp (Thunderbir@moz-54ADD9F4.lns20.syd6.internode.on.net) (Quit: dbaupp)
[00:42:54] <Eridius> Oh man, I just realized that #[feature(globs)] makes test modules more awkward to write
[00:49:30] *** Joins: dbaupp (Thunderbir@moz-54ADD9F4.lns20.syd6.internode.on.net)
[01:20:44] *** Quits: eddyb (eddy@3C6E2DBB.FFB4E060.A5830293.IP) (Quit: Konversation terminated!)
[01:21:00] *** Joins: eddyb (eddy@3C6E2DBB.FFB4E060.A5830293.IP)
[01:23:10] *** Quits: eddyb (eddy@3C6E2DBB.FFB4E060.A5830293.IP) (Ping timeout)
[01:28:47] *** Joins: eddyb9 (eddy@3C6E2DBB.FFB4E060.A5830293.IP)
[01:45:38] <cmr> Does anyone have announcement for This Week in Rust?
[02:20:14] *** Quits: brson (brson@981AA104.E81F12CD.76F66111.IP) (Quit: leaving)
[02:21:17] *** Quits: zz_kimundi (kimundi@moz-D33AF750.dip0.t-ipconnect.de) (Ping timeout)
[02:24:48] *** Joins: zz_kimundi (kimundi@moz-F488EB60.dip0.t-ipconnect.de)
[02:24:49] *** zz_kimundi is now known as kimundi
[03:00:57] *** Joins: tetsuharu (tetsuharu@moz-131F8759.xgsnu4.imtp.tachikawa.mopera.net)
[03:23:57] *** Quits: dbaupp (Thunderbir@moz-54ADD9F4.lns20.syd6.internode.on.net) (Ping timeout)
[03:24:32] *** Joins: dbaupp (Thunderbir@moz-54ADD9F4.lns20.syd6.internode.on.net)
[03:29:28] *** Quits: tetsuharu (tetsuharu@moz-131F8759.xgsnu4.imtp.tachikawa.mopera.net) (Client exited)
[03:56:10] *** Joins: jeffdb (jeff@moz-D13B6004.hsd1.ca.comcast.net)
[03:58:57] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[04:20:50] *** Quits: jeffdb (jeff@moz-D13B6004.hsd1.ca.comcast.net) (Quit: jeffdb)
[05:14:12] *** Quits: Kxepal (Miranda@moz-31F7E1D4.pppoe.mtu-net.ru) (Ping timeout)
[05:17:12] *** Joins: Kxepal (Miranda@moz-8A197C01.pppoe.mtu-net.ru)
[05:47:18] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.2)
[05:56:23] <acrichto> eddyb9: hello!
[06:30:27] <Luqman> sweet got `mut self` and `mut ~self` working
[06:30:37] <Luqman> and i've an idea how to allow mut in patterns
[06:32:05] <dbaupp> Luqman: https://github.com/mozilla/rust/issues/9792 is the "closes #xxxx" target you're looking for for the latter (if you haven't seen it...)
[06:32:45] <dbaupp> you're going to replace the `let mut? <pattern>` grammar with `let <pattern>` and have the mut part of the pattern, right?
[06:33:05] <Luqman> yep, that's the plan
[06:33:10] <dbaupp> awesome
[06:36:53] <Eridius> damn you rvalue bug, you strike again! *shakes fist*
[06:38:02] <Eridius> hrm, if I transmute ~[] into *Vec, that's gonna leak it, isn't it?
[06:38:40] <dbaupp> yes
[06:38:49] <Eridius> guess I'd better transmute() back
[06:38:52] <dbaupp> yup
[06:38:59] * Eridius is adding a test to make sure ~[()] has non-zero allocation
[06:39:15] * dbaupp though std::unstable::repr gave you the transmute-to-Vec stuff
[06:39:43] <Eridius> no, you can only get Vec if you box it as @[T]
[06:40:04] <Eridius> the impl for ~[T] is commented out with // sure would be nice to have this
[06:40:23] <dbaupp> weird
[06:41:29] <Eridius> yeah, I don't know why not
[06:41:51] <dbaupp> acrichto can probably tell you, if he's still around
[06:42:04] <Eridius> yeah I was gonna say blame points at him
[06:42:15] <acrichto> ~[@T] has a different layout than ~[T]
[06:42:32] <acrichto> one is Box<Vec<T>> the other is Vec<T>
[06:42:34] <dbaupp> ah
[06:42:38] <Eridius> huh
[06:42:47] <Eridius> would have been nice to comment to that effect
[06:42:51] <dbaupp> acrichto: a more detailed comment coulda been useful :P
[06:43:01] <acrichto> I was hoping it would actually be changing at the time
[06:43:06] <acrichto> but it doesn't look to be changing
[06:43:12] <acrichto> at least not until we possibly have a real gc
[06:44:16] <eddyb9> good morning :D
[06:45:59] <dbaupp> eddyb9: good afternoon :P (I don't think anyone more  looked at your #[linkage] pr)
[06:47:55] <Eridius> acrichto: sure would be nice if format!() could print an argument's type
[06:49:25] <dbaupp> Eridius: .ty_desc something something
[06:49:39] <dbaupp> (it has the type name in there somewhere)
[06:49:48] <Eridius> pfft
[06:49:57] <Eridius> gimme println!("{:T}", foo)
[06:51:28] <dbaupp> just add struct Type<T>(T) impl fmt::Default for Type { .. } then it's println!("{}", Type(foo)) which isn't so bad
[06:51:55] <Eridius> whoa, I can't use println!() in libstd?
[06:52:01] <Eridius> unresolved import: could not find `io` in `std`.
[06:52:21] * dbaupp found that too
[06:52:50] <dbaupp> try adding io to the weird mod std { ... } in std.rs
[06:52:56] <Eridius> yeah I was just thinking that
[06:55:20] *** Joins: eddyb (eddy@3C6E2DBB.FFB4E060.A5830293.IP)
[06:58:41] <eddyb> acrichto: great, now I have to *think* to get somewhere with this patch :)
[06:59:14] <acrichto> eddyb: yeah sorry :(, it just seems like one of those feature creep things which may be avoidable
[06:59:21] <acrichto> I'd want to at least consider avoiding it first
[06:59:51] <Eridius> eddyb: what patch is this?
[06:59:58] <eddyb> Eridius: https://github.com/mozilla/rust/pull/9966
[07:00:22] <eddyb> acrichto: for DLLs, check https://github.com/mozilla/rust/issues/7196 that I mentioned in my PR's description
[07:35:21] <dbaupp> kimundi: if failure is a tree (https://github.com/mozilla/rust/pull/9967#discussion_r7081735), then why doesn't sending the cause to the direct parent (which might then send it to its parent, if it is linked to the child that failed originally) work?
[07:35:27] * dbaupp doesn't understand this at all
[07:36:25] <kimundi> dbaupp: It's simply not implemented that way right now
[07:36:38] <kimundi> gimme a minute, there is a big fat doc comment somewhere...
[07:37:04] <dbaupp> kimundi: hm... ok, I guess you've been hitting your head against it enough to actually know how it works, whereas i haven't
[07:37:41] <kimundi> dbaupp: Okay, first there is this one: https://github.com/mozilla/rust/blob/master/src/libstd/rt/kill.rs
[07:38:46] <kimundi> Then this one: https://github.com/mozilla/rust/blob/master/src/libstd/task/mod.rs
[07:39:02] <kimundi> And finally the one I was looking ofr: https://github.com/mozilla/rust/blob/master/src/libstd/task/spawn.rs
[07:54:17] <dbaupp> kimundi: ah
[07:54:21] <dbaupp> complicated stuff :S
[07:58:20] <kimundi> indeed
[07:58:48] <kimundi> finding the solution had mor to do with guesswork on my part xD
[08:40:47] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[08:55:44] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[09:12:27] <Luqman> is_named_argument in syntax::parse still has logic for argument modes :(
[09:14:49] <dbaupp> exterminate!
[09:16:36] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[09:18:46] <dbaupp> https://github.com/mozilla/rust/pull/9973 r?
[09:19:03] <dbaupp> (just a test)
[09:21:00] <Luqman> dbaupp: r+
[09:21:47] *** Joins: jeffdb (jeff@moz-D13B6004.hsd1.ca.comcast.net)
[09:26:21] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[09:26:21] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 145d01486 to 1469e46f3: 02http://git.io/N3iJvQ
[09:26:21] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[09:26:23] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[09:26:23] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/hs_Bpw
[09:26:23] <ghrust> 13rust/06auto 14ab045fa 15Huon Wilson: testsuite: test for fixed issue. Closes #7580....
[09:26:23] <ghrust> 13rust/06auto 14424c171 15bors: auto merge of #9973 : huonw/rust/7580, r=luqmana...
[09:26:23] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[09:47:36] <Luqman> success! i've got `let (a, mut b) = (2, 3); b = 4;` working and it seems to bootstrapping
[09:52:20] <dbaupp> \o/
[10:06:51] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[10:08:35] *** Quits: jeffdb (jeff@moz-D13B6004.hsd1.ca.comcast.net) (Quit: jeffdb)
[10:23:21] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[10:31:24] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[10:31:24] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/hs_Bpw
[10:31:24] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[11:10:03] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[11:11:31] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[11:28:20] *** Quits: dbaupp (Thunderbir@moz-54ADD9F4.lns20.syd6.internode.on.net) (Ping timeout)
[11:37:12] <kimundi> Luqman: \o/
[11:38:01] <Luqman> kimundi: sadly i seem to be somehow triggering an Illegal instruction when building stage2 :(
[11:40:02] *** Joins: dbaupp (Thunderbir@moz-54ADD9F4.lns20.syd6.internode.on.net)
[11:57:39] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[12:03:14] <kimundi> hu
[12:52:18] <Luqman> i am at a loss as to why this is triggering an illegal instruction :/
[12:59:49] <eddyb> SIGILL is abort(), isn't it?
[13:00:02] <eddyb> I've heard that's how LLVM implements it
[13:00:22] <eddyb> llvm.trap, that is, used by the abort intrinsic
[13:03:08] <Luqman> so it seems, but the problem is i've no idea why it's aborting
[13:04:10] <eddyb> run it under gdb, I'd say
[13:05:57] <Luqman> it fails in a MutableMap::insert inlined in libsyntax
[13:07:26] <dbaupp> hm, there aren't many places that call abort()
[13:11:54] <dbaupp> and all of them are calling libc::abort(), not intrinsics::abort()
[13:27:52] *** Quits: dbaupp (Thunderbir@moz-54ADD9F4.lns20.syd6.internode.on.net) (Ping timeout)
[13:34:17] *** Joins: dbaupp (Thunderbir@moz-54ADD9F4.lns20.syd6.internode.on.net)
[14:06:59] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[14:58:49] <eddyb> was rustc broken at any point? I get this error when building a standalone binary: libmorestack.a(morestack.o): In function `__morestack': (.text+0x9): undefined reference to `rust_stack_exhausted'
[15:29:04] <cmr> eddyb: not to my knowledge.
[15:29:10] <cmr> eddyb: what do you mean standalone library?>
[15:29:16] <cmr> Sounds like you're not linking to librustrt.
[15:29:38] <eddyb> binary, and not sure why I said standalone
[15:31:04] <eddyb> cmr: just running rustc without flags. worked for the tests I did for my PR. this is the rust-core example, which uses #[no_std], maybe someone broke that use case?
[15:32:27] *** Joins: KokaKiwi (kokakiwi@moz-D674DAC6.kokakiwi.net)
[15:32:47] <cmr> eddyb: Well, I can reproduce.
[16:28:00] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[16:54:08] *** Joins: lkuper (lkuper@31F4CB6.A0D37E9B.51B6877.IP)
[17:00:03] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[17:05:43] *** lbergstrom is now known as lbergstrom|away
[17:21:53] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[17:31:17] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[17:31:18] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/TDcAkg
[17:31:18] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[17:31:21] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[17:31:21] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/F2ps5A
[17:31:21] <ghrust> 13rust/06auto 143e53c92 15LEE Wondong: Fix unicode errors on Windows in path_is_dir, path_exists, getcwd and rust_localtime....
[17:31:21] <ghrust> 13rust/06auto 1469860b7 15bors: auto merge of #9812 : HNO3/rust/windows-utf8, r=alexcrichton...
[17:31:22] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[17:38:20] *** Joins: tjc (tjc@moz-6EB4E533.dsl.tsoft.com)
[17:38:20] *** ChanServ sets mode: +o tjc
[17:52:55] *** Quits: eddyb9 (eddy@3C6E2DBB.FFB4E060.A5830293.IP) (Ping timeout)
[18:02:15] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[18:03:11] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[18:18:05] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[18:18:40] *** Quits: lkuper (lkuper@31F4CB6.A0D37E9B.51B6877.IP) (Ping timeout)
[18:25:17] *** Joins: lkuper (lkuper@31F4CB6.A0D37E9B.51B6877.IP)
[18:27:03] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[18:35:10] *** Quits: StarLight (StarLight@moz-8F220F46.dynamic.avangarddsl.ru) (Ping timeout)
[18:36:16] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[18:36:17] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/F2ps5A
[18:36:17] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[18:39:16] *** Joins: StarLight (StarLight@moz-C8F30533.dynamic.avangarddsl.ru)
[18:41:16] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[18:41:16] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/gPMzuA
[18:41:16] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[18:41:17] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[18:41:17] <ghrust> 01[13rust01] 15bors pushed 7 new commits to 06auto: 02http://git.io/NLxXOw
[18:41:17] <ghrust> 13rust/06auto 14f69795e 15Adrien TÃ©tar: doc: switch pandoc to html5
[18:41:17] <ghrust> 13rust/06auto 145d1fc86 15Adrien TÃ©tar: doc/rust.HTML: proper version box
[18:41:18] <ghrust> 13rust/06auto 140910051 15Adrien TÃ©tar: doc: tidy and cleanup CSS deps, add tutorial PDF generation
[18:41:20] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[18:54:36] *** Quits: tjc (tjc@moz-6EB4E533.dsl.tsoft.com) (Quit: Places to go, people to annoy)
[19:01:49] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[19:01:54] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[19:03:51] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[19:11:22] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[19:11:22] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 149a8bea1 to 1469860b7: 02http://git.io/N3iJvQ
[19:11:22] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[19:11:24] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[19:11:24] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/ubC01A
[19:11:24] <ghrust> 13rust/06auto 1426882a9 15Daniel Micay: fix typo
[19:11:24] <ghrust> 13rust/06auto 14a9aeb0c 15bors: auto merge of #9976 : thestinger/rust/typo, r=thestinger
[19:11:24] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[19:16:17] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[19:16:18] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14a9aeb0c to 1469860b7: 02http://git.io/N3iJvQ
[19:16:18] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[19:16:20] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[19:16:21] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/VkjYVA
[19:16:21] <ghrust> 13rust/06auto 1493b95dd 15Daniel Micay: fix typo
[19:16:21] <ghrust> 13rust/06auto 14ba29c11 15bors: auto merge of #9976 : thestinger/rust/typo, r=thestinger
[19:16:21] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[19:17:21] *** Joins: jeffdb (jeff@moz-D13B6004.hsd1.ca.comcast.net)
[19:18:43] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[19:50:06] *** lbergstrom|away is now known as lbergstrom
[19:55:20] *** Quits: jeffdb (jeff@moz-D13B6004.hsd1.ca.comcast.net) (Quit: jeffdb)
[19:57:07] *** Quits: StarLight (StarLight@moz-C8F30533.dynamic.avangarddsl.ru) (Ping timeout)
[20:01:21] *** Joins: strcat1 (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[20:01:35] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (NickServ (GHOST command used by strcat1))
[20:01:38] *** strcat1 is now known as strcat
[20:02:32] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[20:05:07] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[20:15:03] *** Joins: jeffdb (jeff@moz-D13B6004.hsd1.ca.comcast.net)
[20:33:39] *** Joins: jensnockert (jensnocker@moz-90732636.mobileonline.telia.com)
[20:34:38] *** Quits: jensnockert (jensnocker@moz-90732636.mobileonline.telia.com) (Connection reset by peer)
[20:39:13] *** lbergstrom is now known as lbergstrom|away
[21:01:44] *** Joins: strcat1 (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[21:01:46] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[21:01:58] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[21:02:09] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[21:02:18] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[21:02:19] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[21:28:02] *** Quits: eddyb (eddy@3C6E2DBB.FFB4E060.A5830293.IP) (Quit: Konversation terminated!)
[21:28:12] *** Joins: eddyb (eddy@3C6E2DBB.FFB4E060.A5830293.IP)
[21:30:19] *** Quits: eddyb (eddy@3C6E2DBB.FFB4E060.A5830293.IP) (Ping timeout)
[21:31:33] <strcat1> acrichto: can rustdoc be made to work on something that's not a crate?
[21:31:50] *** Quits: olsonjeffery (pf@B8927AE1.CFEFA148.239A1A9E.IP) (Ping timeout)
[21:31:50] <acrichto> probably not b/c it runs all of the analysis passes
[21:31:54] <acrichto> or at least not easily
[21:32:02] <strcat1> acrichto: I mean on a non-library
[21:32:09] <acrichto> it should be able to
[21:32:13] <strcat1> it doesn't
[21:32:15] <strcat1> it wants #[link]
[21:32:26] <acrichto> there's a bug open to remove that requirement
[21:32:40] <acrichto> the idea is to use rustpkg to infer a name
[21:32:59] <strcat1> I wish I could use macros https://github.com/thestinger/rust-core/blob/master/core/i16.rs ;p
[21:33:12] <strcat1> need #[feature] to work at module-level
[21:33:33] <acrichto> why would you not want it at the crate level?
[21:33:45] <strcat1> because rust-core isn't a crate
[21:34:00] <strcat1> it's a module to include in a single-crate project
[21:34:09] <acrichto> oh hm I guess our linkage model doesn't support it being a library at all
[21:34:12] <acrichto> it *should* though...
[21:34:26] <strcat1> I don't want it to be a library because I don't want to have to #[inline] everything
[21:35:04] <strcat1> https://github.com/thestinger/rust-core/issues/2
[21:35:17] *** Joins: jxs (joaoxsouls@moz-A7EE0DAF.compute-1.amazonaws.com)
[21:35:19] <strcat1> it's intended to be used with whole program optimization, without static/dynamic linking
[21:35:41] <strcat1> crates don't really make sense outside of the rust stdlib ecosystem
[21:35:43] *** strcat1 is now known as strcat
[21:35:56] <strcat> because they force dynamic linking
[21:36:18] <strcat> and even when they support static linking, LTO won't work :s
[21:36:35] * strcat shrugs
[21:37:32] <SiegeLord> The compillation units should get smaller, not bigger :P
[21:37:34] <strcat> rust's crate system isn't very appealing - to have incremental builds, you're forced to give up the possibility of LTO
[21:38:21] <strcat> maybe I should just design rust-core to be compiled with clang instead of rustc
[21:38:42] <strcat> SiegeLord: so how do you suggest making 1 + 1 not do a method call?
[21:39:07] <strcat> there's no point of rust-core being a crate if most functions are #[inline], it just makes it slower
[21:39:11] <strcat> (to compile)
[21:39:45] <SiegeLord> Publically distributed modules don't make sense as a general strategy
[21:40:27] <strcat> crates don't make sense as a compilation model, they force dynamic linking
[21:40:46] <strcat> and rust doesn't have an alternative to crates
[21:41:05] <SiegeLord> That can be fixed, the issues with forcing LTO cannot
[21:43:16] <strcat> if rust-core isn't a module, it can't support plugging in an allocator 
[21:43:18] <strcat> and so on
[21:43:34] <strcat> at least afaik
[21:43:53] <strcat> unless I actually make allocators part of every type like C++
[21:44:48] <SiegeLord> I'm saying that rust-core's needs are very atypical
[21:45:08] <strcat> I don't think so
[21:45:17] <strcat> in the sense that I think many people will be using it
[21:47:47] <strcat> if Rust doesn't offer low memory usage and high performance, it's a much less interesting language
[21:47:55] <strcat> and libstd doesn't offer that
[21:49:08] <strcat> I don't think the tradeoffs surrounding segmented stacks and userspace threading will be wanted in many niches where rust could work
[21:49:20] <strcat> I honestly prefer the C compilation model to this ;\
[21:49:35] <SiegeLord> I don't see how C's is different than Rust's
[21:49:43] <SiegeLord> Aside from temporary lack of static linking
[21:49:58] <strcat> C compilation units are not just libraries
[21:50:05] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[21:50:05] *** ChanServ sets mode: +qo brson brson
[21:50:37] <strcat> if you have a library with 200 files, you can do the debug build as a parallel/incremental build of independent objects that are linked together
[21:51:01] <strcat> for the release build, you can do a parallel/increment build of bytecode objects that are then optimized/linked as a single unit
[21:51:10] <SiegeLord> That's "just" a convention of Rust
[21:51:18] <SiegeLord> It's as if you wrote everything in a single file in C
[21:51:41] <SiegeLord> You could also make every file a crate in Rust, if there was static linking
[21:51:47] <strcat> static linking != LTO
[21:52:25] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[21:53:00] <SiegeLord> You could mark everything #[inline]
[21:53:24] <strcat> better to just include everything in a single crate, it's faster
[21:53:27] <strcat> to compile
[21:53:42] <strcat> SiegeLord: #[inline] is a really awful workaround
[21:53:57] <strcat> you shouldn't have to manually inline anything
[21:54:28] <strcat> your debug build should be parallel/incremental, locally optimized or not and your release build should be a nice big whole program optimization build
[21:54:37] <strcat> rust doesn't work for that
[21:54:48] <strcat> I could start using a makefile and compiling with clang
[21:54:59] <benh> :(
[21:55:03] <strcat> debug build -> build a .o, link against the binary
[21:55:14] <strcat> release build -> build a .bc, do LTO
[21:55:35] <SiegeLord> Well, #[inline] could be made default through a switch
[21:55:42] <strcat> SiegeLord: you *really* don't want #[inline]
[21:55:51] <strcat> it's much slower than LTO
[21:55:58] *** Joins: brson (brson@981AA104.E81F12CD.76F66111.IP)
[21:55:58] *** ChanServ sets mode: +qo brson brson
[21:56:06] <strcat> so, lets say you have 5 crates
[21:56:34] <strcat> #[inline] will serialize the function to an AST, and duplicate it in each crate
[21:57:23] <strcat> so now LLVM is going to optimize it 5 times
[21:57:37] <SiegeLord> Where's the 'function' located?
[21:57:51] <strcat> if you use #[inline] there is no symbol in the source crate
[21:58:07] <strcat> crate -> crate2 -> crate3
[21:58:16] <strcat> lets say crate2 calls an #[inline] function from crate
[21:58:31] <strcat> it's going to be output as a function in crate2
[21:58:42] <strcat> crate3 will call it as a symbol
[21:58:51] <strcat> if it doesn't actually get inlined
[21:59:07] <strcat> #[inline] leads to incredibly slow compiles and just doesn't work for LTO
[21:59:15] <strcat> and anyway
[21:59:21] <strcat> you don't want to put inlinehints on things
[22:00:18] <SiegeLord> Hmm, ok... but can't you output .bc from a whole crate?
[22:00:28] <strcat> sure, you can output a bc of the whole crate
[22:00:32] <SiegeLord> And then do LTO?
[22:00:34] <strcat> now you are using a makefile and clang
[22:00:37] <strcat> that's what I am going to do
[22:00:55] <SiegeLord> Well, that doesn't really fix the parallel build use case
[22:01:02] *** Joins: strcat1 (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[22:01:06] <strcat1> I am going to use clang for incremental builds of .o files and LTO builds
[22:01:08] <SiegeLord> You still will have to encourage people to create 100's of crates per program
[22:01:20] <strcat1> all I am trying to say is that I think rust's compilation model is useless
[22:01:49] <strcat1> I don't see when you would actually use a 'crate'
[22:02:02] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[22:02:10] <SiegeLord> Same place you'd so a .so in C?
[22:02:13] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[22:02:16] <SiegeLord> *you'd use
[22:02:21] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[22:02:32] <strcat1> C has a stable ABI and you can choose how much of your ABI you expose in a header
[22:02:50] <strcat1> rust doesn't have a stable ABI and any user of the library will depend on layout of private objects/fields
[22:03:31] <strcat1> you *can* expose a stable ABI from rust
[22:03:42] <strcat1> but it's no longer going to be a rustic library
[22:03:54] <SiegeLord> Is this different than C++?
[22:04:05] <strcat1> C++ has the same issue, it's not really something we have to fix, it's just the practical implications of having generics and so on
[22:04:06] <SiegeLord> With it's privacy etc
[22:04:25] <strcat1> C++ is a bit better off
[22:04:42] <strcat1> in C++, private fields leak details to the public interface in terms of object size
[22:04:54] <strcat1> in rust, they leak everything (std::reflect, std::repr)
[22:05:09] *** Joins: jdm (jdm@A931292E.20A5B7E6.930FA32.IP)
[22:05:54] <SiegeLord> Does that affect ABI? Isn't that just metadata?
[22:06:12] <strcat1> it reveals every single private type/field
[22:06:28] <strcat1> the contents, the layout
[22:06:57] <strcat1> it's not necessarily a problem, but it does mean dynamic linking is close to useless
[22:07:00] <SiegeLord> But if you don't use reflection, will your code break?
[22:07:25] <strcat1> SiegeLord: your code will break
[22:07:25] *** Joins: olsonjeffery (pf@B8927AE1.CFEFA148.239A1A9E.IP)
[22:07:37] <strcat1> I can list a few reasons
[22:07:43] <strcat1> there's obviously the size issue from C++
[22:07:55] <strcat1> but lets say the library upgrades without adding/removing any fields or changing field types
[22:08:15] <strcat1> we have these tydesc things, that are output into each crate as internal objects
[22:08:25] <strcat1> we also essentially inline every static into every crate
[22:09:36] <strcat1> (and ofc, anything using repr/reflect is fully dependent on the layout)
[22:11:05] <SiegeLord> Can you do opaque types in Rust? That seems to solve the size issue in C/C++ well enough
[22:12:32] <strcat1> in C++ you know what you're exposing by what you have in the header
[22:15:00] <SiegeLord> Is the mapping from what's cross-crate accessible to ABI that complex in Rust?
[22:15:13] <strcat1> it is very complex
[22:15:34] <strcat1> stable dynamic library ABIs are not going to be obtainable without a *lot* of effort
[22:16:29] <strcat1> haskell libraries also essentially break the ABI with every upgrade, and every compiler upgrade - we are in that situation
[22:16:59] <SiegeLord> Could we at least make the crate hash perfectly reflect the ABI?
[22:17:32] <strcat1> it wouldn't really help, if it did
[22:17:48] <SiegeLord> That way at least you won't get random breakage... you'll just have to mentally invert the hash function while programming
[22:17:49] <strcat1> a library with a stable ABI like sqlite still adds new symbols all the time
[22:17:56] <strcat1> SiegeLord: it's not about random breakage
[22:17:59] <SiegeLord> Ah, right
[22:18:57] <strcat1> the win with dynamic libraries is that you can have a single copy of the library, and upgrading it won't cause a huge rebuild except on relatively rare ABI breaking updates
[22:19:19] <strcat1> with a dynamic haskell or rust library, you have to rebuild the whole tree of stuff depending on it
[22:19:27] <strcat1> this is why I gave up on pandoc ;p
[22:19:38] <SiegeLord> Can you verify ABI in C/C++?
[22:19:52] <strcat1> SiegeLord: your ABI is in the header, you just don't change existing things in the header
[22:20:16] <strcat1> I know everyone says they hate header files, but this is the advantage they give
[22:20:18] *** strcat1 is now known as strcat
[22:21:31] <strcat> Go only supports static linking by design - pretty much because dynamic linking just isn't worth the trouble
[22:22:32] <strcat> it's worth it to a linux distribution to minimize the maintenance workload, unless you automated all the building
[22:23:36] * strcat talked to graydon about this at the mozsummit
[22:25:53] <SiegeLord> Doesn't ABI matter for static linking too?
[22:26:11] <strcat> no
[22:26:34] <strcat> static linking is just taking a bunch of object files and building a single binary
[22:26:48] <SiegeLord> I can definitely create two binary incompatible C objects that link fine, but crash when run
[22:27:09] <strcat> rust does name mangling
[22:27:30] * strcat isn't sure what you mean
[22:28:32] <SiegeLord> Well, I had a function that returned a struct by value, I compiled one object with one header, and the other with a different header
[22:28:41] <SiegeLord> One object could, e.g. define the function and the other use it
[22:28:43] <strcat> sure, if you kept around object files it would matter
[22:29:09] <strcat> static linking definitely doesn't mean *less* rebuilding than dynamic linking
[22:29:20] <strcat> all I am saying is that dynamic linking with rust won't save you any rebuilds
[22:30:15] <SiegeLord> But you keep objects around all the time, when you distribute static libraries
[22:30:18] <strcat> usually it does, and that's why people use it (clear boundaries with stable ABIs, and there's a clear soname bump when it's upgraded)
[22:31:08] <strcat> SiegeLord: I am saying that dynamic linking doesn't result in fewer rebuilds with rust/haskell
[22:31:20] <strcat> I am not saying static linking means you save on rebuilds
[22:31:30] <strcat> A -> B -> C
[22:31:51] <strcat> A is upgraded? you are rebuilding B and C, even if it seems like you don't need to, because there are so many hidden ABI leaks like tydescs
[22:32:05] <SiegeLord> I'm saying that if you're distributing compiled libraries, static or dynamic, you need to care about the ABI
[22:32:33] <strcat> if you are distributing compiled rust/haskell libraries, whether they are static/dynamic, you are rebuilding an entire reverse dependency tree on every upgrade
[22:32:53] <strcat> and generally that applies to C++ too (it definitely does for boost!)
[22:33:10] <SiegeLord> Sure, but a rebuild won't necessarily catch ABI breakage
[22:33:12] <SiegeLord> It doesn't in C
[22:33:22] <SiegeLord> I don't think it does in C++ either (in all cases)
[22:33:26] <strcat> it can catch ABI breakage
[22:33:35] <strcat> every version upgrade changes the crate hash
[22:33:58] <strcat> and your version for trunk builds should be from git describe
[22:34:16] <strcat> every commit breaks the ABI, from rust's necessary view
[22:34:50] <strcat> (hopefully, we can remove enough non-deterministic stuff that a *rebuild* doesn't break the ABI)
[22:35:26] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.2)
[22:49:02] <SiegeLord> I wonder to what extent these ABI rules can be simplified
[22:50:04] <SiegeLord> Notably, D has exactly the same issues
[22:51:10] *** Quits: lkuper (lkuper@31F4CB6.A0D37E9B.51B6877.IP) (Quit: lkuper)
[22:53:05] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[23:01:27] *** Joins: strcat1 (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[23:01:58] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[23:02:06] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[23:02:25] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[23:03:53] *** Joins: lkuper (lkuper@31F4CB6.A0D37E9B.51B6877.IP)
[23:04:06] *** strcat1 is now known as strcat
[23:19:24] *** Joins: geoffhill (geoffhill@moz-2785B672.hsd1.wa.comcast.net)
[23:25:09] *** Quits: geoffhill (geoffhill@moz-2785B672.hsd1.wa.comcast.net) (Quit: geoffhill)
[23:26:26] *** Quits: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net) (Quit: Jesse)
[23:27:16] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[23:57:17] *** Quits: lkuper (lkuper@31F4CB6.A0D37E9B.51B6877.IP) (Quit: lkuper)

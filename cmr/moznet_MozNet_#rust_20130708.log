[00:00:08] <dbaupp> aatch: I'm doing the lint visitor stuff now, btw
[00:00:15] <aatch> dbaupp, sweet
[00:00:26] <strcat> doomlord: ref mut does exist
[00:01:08] <dbaupp> aatch: I'm just going to transliterate id_visitor to a trait-visitor, and see what breaks
[00:01:17] * dbaupp has a feeling it wont work
[00:01:22] <aatch> dbaupp, it will not
[00:01:30] <dbaupp> why exactly?
[00:01:45] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[00:02:05] <aatch> dbaupp, for one, the IdVisitor has a bounded lifetime because it takes a stack closure
[00:02:34] <dbaupp> aatch: ("the IdVisitor"?)
[00:02:47] <dbaupp> surely I could make it take a @fn?
[00:03:01] *** Joins: jared (jared@moz-EE5D17ED.ph.ph.cox.net)
[00:03:19] <aatch> dbaupp, you could, but the reason I made it take a stack closure is so it capture data with borrowed pointers
[00:03:45] <dbaupp> (have you already implemented IdVisitor?)
[00:03:49] <aatch> dbaupp, I have
[00:03:59] <aatch> it's in syntax::ast_util
[00:03:59] <dbaupp> I can't see it... ?
[00:04:12] <aatch> it's used by the ast map
[00:04:19] <aatch> and a few other things
[00:04:24] <dbaupp> I can't see it :S
[00:04:39] * dbaupp is very confused
[00:04:44] <aatch> Actually, that's a lie, only the linter uses it directly
[00:04:52] <aatch> the others use it indirectly
[00:05:00] *** Joins: vk (vk@2AAA6DD0.B568D26C.93B001FA.IP)
[00:05:04] <dbaupp> is f113da36e00bdd9ccae7fc1049df159b666e6631 the head of that branch?
[00:05:46] <aatch> dbaupp, https://github.com/Aatch/rust/blob/trait-visitor/src/libsyntax/ast_util.rs#L466
[00:06:10] <aatch> 4417c606e02431eba3932e00c505b21ec0331346
[00:06:12] <dbaupp> oh, trait-visitor, not new_visitor
[00:06:19] <aatch> dbaupp, heh
[00:06:32] <aatch> dbaupp, sorry, that branch was kinda rotten
[00:06:43] <aatch> so I just pulled the visitor out
[00:07:14] <dbaupp> I see it!
[00:07:16] <dbaupp> yay
[00:08:29] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[00:09:25] <dbaupp> hm, this is going to be interesting
[00:10:34] <etw> If I want to make changes to the rust parser, what's the best workflow for testing those changes, `make` ? `make test` ?
[00:10:42] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[00:11:10] <aatch> etw, generally just trying to build is enough
[00:11:15] <dbaupp> etw: `make check` runs the whole test suite
[00:11:22] <aatch> since past stage0 it'll use your changes
[00:12:17] <etw> aatch: so generally if make succeeds I'll know I haven't broken anything, but I should still run make check to go through the test suite?
[00:12:28] <aatch> etw, yes
[00:12:38] <etw> aatch: cheers
[00:13:02] <aatch> Woo, libsyntax probably fixed
[00:13:08] <aatch> and I managed to remove a copy
[00:13:29] <etw> the parser is surpsisingly easy to understand so far
[00:15:57] <dbaupp> aatch: you haven't happened to have written an adaptor that makes the old visitors work as a new one, have you?
[00:16:04] <aatch> dbaupp, no
[00:16:09] <aatch> I thought about it.
[00:16:30] <aatch> but changing them is actually pretty mechanical
[00:16:38] <aatch> In most cases anyway
[00:19:02] <aatch> expected `&syntax::ast::Path` but found `~&~syntax::ast::Path`
[00:19:09] <aatch> typod
[00:21:03] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[00:21:14] <aatch> Also, I love this: `~ref foo`
[00:21:30] <erickt> wooo finally finished my huge patch series to remove trailing nulls from strings!
[00:22:06] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[00:22:06] <ghrust> 01[13rust01] 15erickt 04force-pushed 06try from 145bdbe9d to 14b806dd0: 02http://git.io/k471pw
[00:22:06] <ghrust> 13rust/06try 148620d75 15Erick Tryzelaar: rustc: remove some dead functions
[00:22:06] <ghrust> 13rust/06try 14e07b491 15Erick Tryzelaar: std: add str.to_c_str()
[00:22:06] <ghrust> 13rust/06try 1468d2b01 15Erick Tryzelaar: std: rename str.as_bytes_with_null_consume() to str.to_bytes()
[00:22:08] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[00:22:18] <dbaupp> erickt: \o/
[00:22:19] <erickt> now to see if it builds on linux and windows...
[00:22:31] * dbaupp was planning to experiment with that
[00:22:41] *** Quits: BluePeppers (user@moz-3799699A.range81-151.btcentralplus.com) (Client exited)
[00:23:01] <dbaupp> is it faster? Or is that too much to hope for?
[00:23:15] <erickt> Oiy. 24 patches.
[00:23:19] <erickt> dbaupp: dunno
[00:23:46] <strcat> dbaupp: more about making it sane to convert between vectors/strings
[00:24:03] <erickt> there are some semantically weird things I've found recently. I'm now no longer happy with the fact that &T types auto coerce to *T
[00:24:04] <dbaupp> strcat: right
[00:24:38] <dbaupp> strcat: I'd though that maybe reducing the number of len-1's for borrowing ~str to &str might make some difference
[00:24:39] <erickt> It's too easy for someone to write `let x = "foo"; let y: *T = &x[0];`
[00:25:12] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[00:25:24] <erickt> dbaupp: calling out to c functions that take a *char always requires a malloc now, but going from str to [u8] is free. So it's a tossup
[00:25:43] <dbaupp> erickt: right
[00:27:00] <Luqman> strcat: trait objects fixed :D
[00:27:07] <Luqman> only 2 failing tests left
[00:27:08] <strcat> erickt: eventually we should have no libc usage in libstd though.
[00:27:21] <strcat> erickt: the only fundamental thing taking a null-terminated string is the open call
[00:27:26] <strcat> Luqman: nice
[00:27:33] <erickt> strcat: getting rid of libc would be great
[00:27:47] <strcat> erickt: aatch was working on doing system calls natively
[00:27:59] <strcat> and we need to get access to the vdso on linux
[00:28:02] <erickt> strcat: what about functions like mkdir?
[00:28:06] <erickt> strcat: oooh
[00:28:07] <strcat> erickt: system calls
[00:28:15] <Luqman> strcat: https://gist.github.com/luqmana/3245bc9aa570a3d98197
[00:28:16] <strcat> erickt: syscalls don't use stack, no overhead
[00:28:20] <aatch> which requires re-working the way we handle entry
[00:28:20] <dbaupp> aatch: the problem with this new visitor code, is you need to have everything you'll need in scope when you construct the visitor, so you can't (easily) construct them "statically", if you know what I mean.
[00:28:21] <erickt> do those take *char+uints?
[00:28:37] <strcat> erickt: some do, some don't
[00:28:48] <aatch> dbaupp, hmm? Only for the IdVisitor.
[00:28:50] <strcat> for example setting the hostname takes a size
[00:29:04] <strcat> erickt: paths usually use a \0 terminator
[00:29:21] <strcat> erickt: because linux file paths are any character except \0 (and / is forbidden in names)
[00:29:25] <dbaupp> aatch: no in general, because you can't supply any extra arguments to the visiting functions
[00:29:33] <aatch> dbaupp, true.
[00:29:40] <strcat> erickt: but anything dealing with unicode can't use \0-termination because \0 is valid unicode, so it's not *that* bad
[00:29:45] <dbaupp> aatch: and so if you have something that you'll only know later, that has to be an Option<T> in the visitor
[00:30:15] <strcat> erickt: I think the only things that'll need \0-termination are already fairly expensive I/O things
[00:30:22] <strcat> where a copy is probably 1% of the cost
[00:30:27] <erickt> well, any of those syscalls that take a null terminated string will probably take longer than the IO
[00:30:31] <erickt> heh
[00:30:36] <dbaupp> aatch: would you disagree with putting a T-argument on each of the visit functions?
[00:31:00] <dbaupp> (where T is a generic.)
[00:31:05] <aatch> dbaupp, I'm not strongly against but I'm pretty sure that the vast majority would just end up passing ()
[00:31:05] <strcat> Luqman: \o/
[00:31:21] <dbaupp> aatch: right
[00:31:29] <Luqman> strcat: now to tackle the other 2
[00:31:33] <aatch> most of the visitors just build up some other data structure
[00:31:41] <dbaupp> aatch: however, I have a feeling that the lint code is unworkable without it.
[00:31:45] <Luqman> and how i didn't break anything else along the way
[00:31:57] <dbaupp> at least with it's current architecture
[00:32:39] <aatch> dbaupp, yeah, I know..
[00:32:57] <dbaupp> aatch: I think rewriting the whole thing might work better
[00:33:06] <dbaupp> well, rearranging it
[00:33:18] <erickt> Anyone got a sec to give me your opinions about the c_str module I added to wrap *libc::c_chars? https://github.com/mozilla/rust/commit/5034d7dcb76c09c363573e58f5daa006f5e4731e#L20R1
[00:33:52] <aatch> dbaupp, you could also reduce the allocations made there in that case.
[00:34:09] <dbaupp> aatch: e.g. I don't understand why it registers the lints and then immediately calls process, rather than just running the lints.
[00:34:26] <aatch> dbaupp, it doesn't make any sense to me either.
[00:34:38] <aatch> presumably there was some plan
[00:35:00] <dbaupp> erickt: if it implements str::Str then you get many of the normal string methods "for free"
[00:35:12] <erickt> oh? neat!
[00:35:55] <dbaupp> erickt: `my_c_str.as_slice().starts_with("foo")`
[00:36:14] <dbaupp> erickt: although, all those methods assume unicode, which could cause interesting explosions.
[00:37:05] <dbaupp> erickt: (so maybe not...)
[00:37:17] <strcat> I plan on moving a lot more functionality to iterators (ranges) too
[00:37:41] <erickt> dbaupp: In order to do that, I'd have to run strlen on the pointer in as_slice, unless I cached it somehow
[00:37:52] <erickt> it being the string length
[00:37:58] <dbaupp> erickt: yeah
[00:38:10] <dbaupp> (caching it seems like it might be reasonable, though, maybe?)
[00:38:20] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[00:38:30] <erickt> unfortunately there's this weird semantics with strings. Where you can always add a null in the middle of your string, and boom, your string is truncated
[00:38:52] <erickt> and your length no longer corresponds to strlen
[00:38:52] <Luqman> strcat: i *think* make_visit_glue just casts the given ValueRef to a boxed trait which messes things up
[00:38:55] *** Quits: sigma1 (sigma@51C589B3.EF2694B5.DFAC6AA7.IP) (Ping timeout)
[00:39:04] <dbaupp> aatch: lint.rs is quite old, so it's possible just more legacy code.
[00:39:21] <aatch> dbaupp, yeah. There's a lot like that
[00:39:23] <dbaupp> erickt: yeah. so caching would be wrong.
[00:40:07] <erickt> we could just document that as_slice is O(n)
[00:40:14] <doomlord> http://pastebin.com/UyVRTzBw <<< perhaps i should just use an unsafe block . tried various permutations here.. can't easily seem to re-use the generation of the tile holder adress due to some parts needing mut 
[00:40:44] <aatch> Ok, I think the enum-bloat culprit was Path
[00:40:52] <strcat> Luqman: ah
[00:40:57] <aatch> more specifically, Path-in-expr
[00:41:07] <dbaupp> doomlord: what's the error message?
[00:41:11] <strcat> erickt: we could also make a char iterator on [u8] failing when there's actually an issue
[00:41:11] <erickt> dbaupp: I also have second thoughts about modeling CStr off of Cell. I'm not sure if it makes sense to be able to take and put back a *char into the CStr wrapper
[00:41:24] <strcat> &[u8] *
[00:41:30] *** Quits: smvv_ (sander@moz-BAEA8EB2.dynamic.upc.nl) (Ping timeout)
[00:41:47] <erickt> strcat: I do at least provide a char iterator to capture some of the functionality
[00:42:40] <dbaupp> erickt: I'm not really sure, but that does seem like an easy way to get memory leaks
[00:42:45] <doomlord> various.. can't borrow twice, can't borrow immut as mut; it doesn't seem to let me match on the enum and modify both the original enum or just the contents in some arms
[00:43:14] <doomlord> whats here should work, but i'm at the mercy of a complex optimizer :)
[00:43:15] <erickt> dbaupp: agreed. But there are some c apis where you transfer ownership of a malloced *char to the library
[00:43:15] <dbaupp> erickt: "how do I call a C function with this thing? oh look .take() -> *char... my_func(c_str.take())"
[00:43:28] <dbaupp> erickt: right
[00:43:54] <dbaupp> maybe make it unsafe, but that's possibly an abuse of unsafe
[00:43:56] <erickt> I'm not sure if there's much you can do in this case other than document it
[00:43:56] <doomlord> speed/safety/convinience.. pick one :) or maybe 2..
[00:44:18] <thiez> mkae it a closure?
[00:44:47] <erickt> thiez: I got a poorly named "CStr.with" that takes a closure and passes in a *c_char
[00:44:48] <dbaupp> thiez: currently is, but this is for handing off the control of deallocation to another library
[00:45:07] <aatch> (which is not that common, to be fair)
[00:45:12] <thiez> dbaupp: make it a closure, then forget the original? :p
[00:45:45] <strcat> Luqman: it segfaults in stage2 now :(
[00:45:50] <erickt> thiez: does forget skip the destructor? that might not actually be that bad
[00:45:56] <dbaupp> erickt: calling it something scary might work too
[00:46:08] <Luqman> strcat: yea, i think i misunderstood how guards work in match arms
[00:46:08] <thiez> erickt: it does
[00:46:11] <erickt> dbaupp: I did at least make `take()` unsafe :)
[00:46:17] <Luqman> strcat: try this instead https://gist.github.com/luqmana/3245bc9aa570a3d98197
[00:46:26] <erickt> thiez: it does call it, or it doesn't? :)
[00:46:32] <thiez> it doesn't
[00:46:41] <thiez> it just pretends the value doesn't exist from that point
[00:46:43] <Luqman> strcat: er, now rather (missed a !)
[00:46:45] <dbaupp> erickt: oh, wow, so it is. (great minds, etc etc :) )
[00:47:22] <thiez> rusti: unsafe { std::unstable::intrinsics::forget(~"I'm leaking :(") }
[00:47:24] <erickt> dbaupp: however, you're going to be in an unsafe block anyway in order to call out to that c function
[00:47:25] -rusti- ()
[00:47:52] <dbaupp> erickt: ah, yes
[00:48:24] <erickt> and then I saw people writing `let ptr = str.as_imm_buf(|buf, _| buf)` all over the place to get at the inner pointer
[00:48:41] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[00:48:46] <erickt> I kinda wish you could put *T pointers into a region
[00:49:00] <ChrisMorgan> Recommended block doc comment style: (a) `/// line\n/// line`, (b) `/**\n * line\n * line\n */`, (c) `/**\nline\nline\n*/`, or (d) something else?
[00:49:05] * dbaupp would like to be able to mark any type with a region
[00:49:06] <erickt> so at least if you really want to do this, you can use a scary cast::transmute or something
[00:49:08] <doomlord> ah there was an error message mentioning aliasing.. thats encouraging to know that rust is possibly trying more agressive non-aliasing assumptions
[00:49:12] <strcat> Luqman: hm, it says it won't apply now
[00:49:19] <strcat> Luqman: could you gist the file instead?
[00:49:21] <doomlord> it didn't like me borrowing a mut that could alias another mut
[00:49:50] <strcat> doomlord: &mut can't alias &mut or &
[00:49:53] <thiez> rusti: struct S; impl Drop for S { fn drop(&self) { println("Dropped S")} } let _s = S; let _t = S; unsafe{std::unstable::intrinsics::forget(_s);}
[00:49:54] -rusti- Dropped S
[00:49:54] -rusti- ()
[00:49:57] <strcat> or reference the same memory
[00:50:08] <strcat> for memory safety
[00:50:14] <doomlord> rigth ok
[00:50:23] <strcat> and & points at immutable memory (it's not just immutable through that reference)
[00:50:37] <Luqman> strcat: https://gist.github.com/luqmana/d5f73588aabeabc0177f
[00:50:46] <doomlord> i could just do the the manual way emulating c , if worst comes to worst..
[00:50:55] <erickt> thiez: you could instead call cast::forget
[00:51:10] <thiez> cast also has forget? why the duplication...
[00:51:29] <erickt> thiez: it just calls unstable::intrinsics::forget
[00:51:41] <thiez> yes, I'm looking at it right now, and making a frowny face :p
[00:51:41] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[00:51:49] <doomlord> option<Array2d<T>> and uniform T value as my tile...  that might be more workable
[00:52:08] <thiez> I love the bump_box_refcount function though
[00:52:13] <thiez> it's so elegant.
[00:52:15] <erickt> thiez: everything in unstable could change at any point in time, so it's safer for users to not use it
[00:52:34] <dbaupp> thiez: cast::forget is the "recommended" way to call forget
[00:52:34] <doomlord> struct TileHolder {     emptyValue:T  , data:Option<~Array8x8<T> > } .. or will i have the same prolems ..
[00:52:38] <strcat> thiez: except that they won't have refcounts so anything relying on it will break ;p
[00:52:44] <thiez> fair enough, although everything in the rest of the library could also change at any point in time ;)
[00:53:13] <thiez> strcat: oh, I suppose we should aim to remove it before graydon's GC lands? :p
[00:53:22] * strcat shrugs
[00:53:25] <thiez> if any current code uses it...
[00:53:28] <strcat> they probably need to make roots instead
[00:53:37] <doomlord> i'll try again tommorrow.. past midnight here. 
[00:53:59] <thiez> it's almost 3AM here but there's a cat on my lap so I can't leave :p
[00:55:15] <erickt> thiez: it doesn't matter now, but once we hit 1.0 we won't be able to muck as much with the non-std::unstable modules 
[00:55:17] <thiez> anyway, like I said, why not use that with_as_c_str_method_thingy in combination with forget to transfer free()-responsibility to C code?
[00:55:36] *** Quits: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com) (Ping timeout)
[00:56:01] <strcat> thiez: when ~T headers are gone we can just use ~T
[00:56:03] <strcat> with C
[00:56:20] <strcat> fn c_function_handing_over_ownership() -> ~T
[00:56:22] <strcat> etc
[00:56:24] <erickt> thiez: if I could also express `*'self c_char`, which prevented people from writing `c_str.with(|buf| buf)`, using forget would be great for me
[00:56:26] <thiez> fair enough
[00:56:44] <erickt> strcat: we can't, they won't be null terminated
[00:56:53] <strcat> erickt: well I don't mean for strings
[00:56:56] * strcat missed the actual topic
[00:57:02] <erickt> righto
[00:57:13] <strcat> strings will still have box headers + the len/capacity stuff
[00:57:23] * strcat is dealing with unique vecs/strs later
[00:57:33] <strcat> need 1000 contains_managed calls ;(
[00:58:11] <thiez> erickt: what do you mean with `*'self c_char`?
[00:58:52] <thiez> do we want to prevent people from doing c_str.with(
[00:58:58] <thiez> |buf| buf)
[00:59:02] <erickt> thiez: as in you should be able to put a lifetime on an unsafe pointer
[00:59:04] <thiez> or do we wish to enable it?
[00:59:06] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[00:59:06] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14829d745 to 14ddf8247: 02http://git.io/N3iJvQ
[00:59:06] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[00:59:06] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[00:59:06] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/dhNp8Q
[00:59:06] <ghrust> 13rust/06auto 14e9ce97c 15AljazÌŒ "g5pw" SrebrnicÌŒ: Copy the correct libs when using local-rust-root...
[00:59:06] <ghrust> 13rust/06auto 146d6b1a8 15bors: auto merge of #7586 : g5pw/rust/master, r=cmr...
[00:59:07] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[00:59:45] <erickt> thiez: yes, because then you have an unsafe extra alias to the pointer, and it can allow you to access invalid memory
[00:59:58] <thiez> but that doesn't matter, because it's *ptr
[01:00:04] <thiez> and dereffing it is unsafe by definition
[01:00:47] <erickt> thiez: you could write `fn get_c_str(s: &str) *c_char { s.to_str().with(|buf| buf) }` which returns a pointer to freed memory
[01:01:01] <thiez> yes
[01:01:03] <erickt> assuming my patch landed
[01:01:39] <thiez> and you can do (5 as *int) which returns a pointer to memory location '5'
[01:01:46] <thiez> or (0 as *int) which is a null pointer :p
[01:01:51] <erickt> thiez: I would rather that if someone really wanted to shoot themselves in the foot, they'd have to write `fn get_c_str(s: &str) *c_char { s.to_str().with(|buf| cast::transmute(buf)) }` to lose the lifetime
[01:02:05] <thiez> once you start making *ptr you're giving up safety
[01:02:40] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[01:02:41] <erickt> yes, technically, but we got this wonderful region system that can easily protect us from using CStr and shooting ourselves in the foot
[01:02:42] <strcat> erickt: you could give an &
[01:02:46] <strcat> well
[01:02:51] <strcat> it'd be weird
[01:02:55] <strcat> but & coerces to *
[01:03:13] *** Quits: RMF (RMF@moz-2CA5F393.dsl.telepac.pt) (Quit: Textual IRC Client: www.textualapp.com)
[01:03:28] <erickt> and it'd really be a **c_char, and easy to escape with `*string`
[01:04:03] <dbaupp> even &'self *c_char is easy to escape with *string
[01:04:22] <thiez> so return &'self c_char instead of &'self *c_char
[01:05:02] <thiez> oh wait never mind
[01:05:17] <thiez> that ruins &str
[01:05:26] <erickt> can we auto-coerce from a &c_char to a *c_char?
[01:05:29] <thiez> no, it doesn't, does it?
[01:05:29] <erickt> thiez: how so?
[01:05:33] <Luqman> strcat: yep, so it no longer segfaults in stage2
[01:05:48] <thiez> hmmn, so return &'self c_str and it auto-coerces when you call C
[01:05:59] <erickt> thiez: oh, we could also change all the c function declarations to &c_char
[01:06:17] <thiez> you don't have to because we auto-coerce, as strcat said
[01:07:03] <strcat> if they don't allow null you might as well make them &
[01:08:04] <thiez> rusti: fn foo(t: *int)->int{unsafe{*t}} foo(&5) // Look, it autocoerces beautifully.
[01:08:05] -rusti- 5
[01:08:16] <erickt> I think this could work
[01:08:18] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[01:08:55] <erickt> and I'll be able to replace my .with() function with a .as_ptr() which is much cleaner
[01:11:12] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[01:11:27] <erickt> ok, next issue. my CStr right now is really only about going from rust to C, not the other way around. Would it make sense to make CStr wrap c strings? I'd need to have a way to mark whether or not to call free on the pointer when the CStr is dropped
[01:11:57] <strcat> erickt: free(nullptr) is valid, so you could just rely on that
[01:12:22] <strcat> erickt: there's #[unsafe_no_drop_flag] to omit the drop flag and zero on moves
[01:12:36] <strcat> (to avoid that overhead)
[01:13:38] <erickt> strcat: that wouldn't work here. I'm referring to doing something like `let x = CStr::from_c_str(libc::strerror(â€¦))` where I don't necessarily own the pointer returned to me
[01:13:46] <strcat> ah
[01:14:07] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[01:14:18] <erickt> I could just have two functions, one for transferring ownership, and one without
[01:14:39] <erickt> thanks for the tip about unsafe_no_drop_flag though, I was looking for something like that
[01:16:03] <strcat> erickt: I needed it for Rc/RcMut and aatch ended up implementing it
[01:16:27] <aatch> strcat, I was bored
[01:16:29] <strcat> just need a way to convince the compiler to do the Option<NonNullablePtr> optimization for them now
[01:16:45] <aatch> strcat, that'll probably take a pointer trait
[01:20:45] *** Joins: RMF (RMF@moz-2CA5F393.dsl.telepac.pt)
[01:20:52] <erickt> does bors no longer auto build the try branch?
[01:21:09] <aatch> erickt, the build-bots should pick it up
[01:21:19] <aatch> but all the slaves might be busy
[01:21:51] <erickt> all the try bots look to be idle: http://buildbot.rust-lang.org/console?branch=try&refresh=15
[01:22:43] <aatch> erickt, they don't have any pending builds, so I dunno whats up.
[01:22:54] <aatch> you manually add the commit though
[01:22:58] <aatch> you could*
[01:23:07] <thiez> speaking of overhead:
[01:23:09] <thiez> rusti: use std::unstable::intrinsics::size_of; unsafe{ (size_of::<u8>(),size_of::<Option<u8>>()) }
[01:23:10] -rusti- (1, 16)
[01:23:20] <thiez> options could probably be smaller... :p
[01:23:22] <erickt> aatch: I'll wait until graydon shows up
[01:23:37] <aatch> thiez, it's the tag
[01:23:48] *** Joins: eagen (eagen@moz-92A457CB.hsd1.mn.comcast.net)
[01:24:27] <thiez> the tag could be 1 bit, so I would expect Option<T> to have a size of T+1 at most
[01:24:54] <thiez> putting the tag at the end should dodge most alignment problems
[01:25:28] <aatch> thiez, true, and I think that's what was done for the drop flag
[01:25:32] *** Quits: bytewise (bytewise@moz-649C630D.unitymediagroup.de) (Quit: Leaving)
[01:25:39] <aatch> (as in it used to be at the beginning, but caused problems)
[01:26:04] <thiez> hmmn, could we do this for all enums? move the tag to the end
[01:26:20] <aatch> thiez, at any rate, enums use the alignment size.
[01:26:35] <engla> thiez: doesn't really matter, it will need to expand to alignment of the struct anyway
[01:26:37] <thiez> oh, that is a shame.
[01:27:23] <thiez> why do they do that?
[01:27:57] <aatch> unaligned reads/writes cause problems
[01:28:17] <engla> if you have options in an array the struct padding will be large enough so that each array element is aligned
[01:28:34] <strcat> erickt: yeah it doesn't build automatically
[01:28:46] <strcat> erickt: you can just force a build, but keep in mind there are no spare mac bots
[01:29:01] <thiez> so why is unaligned access okay for u8 and u16, but not for enums?
[01:29:03] <strcat> well, maybe there's 1 or 2 now... if mac5 is up
[01:29:04] *** Quits: vk (vk@2AAA6DD0.B568D26C.93B001FA.IP) (Quit: vk)
[01:29:46] <strcat> thiez: u8/u16 are aligned properly
[01:30:12] <strcat> thiez: anyway the issue is that enums should be using the smallest possible discriminant
[01:30:16] <strcat> but they always use a uint
[01:30:25] <strcat> Option<u8> should be 2
[01:30:31] <strcat> Option<u16> should be 4
[01:30:47] <strcat> it's an open issue
[01:30:48] <engla> but Option<*T> will still be 16 or maybe 12?
[01:30:56] <engla> not sure about alignment requirements for *T
[01:31:12] <thiez> I might have a look at it later
[01:31:15] <dbaupp> rusti: std::sys::size_of::<Option<*uint>>()
[01:31:16] -rusti- 16
[01:31:18] <strcat> engla: 16, on x86_64
[01:31:23] <strcat> a pointer is a word
[01:31:28] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[01:31:33] <engla> 16 is a bit much
[01:31:44] <engla> 64 bit is 8 bytes strcat 
[01:31:57] <strcat> engla: there's a discriminant
[01:32:08] <strcat> *T is nullable
[01:32:12] <thiez> I don't really see the value of Option<*T> anyway :p
[01:32:14] <strcat> it can't optimize like it does for ~T
[01:32:21] <engla> yes ok, I thought you said it had 16 bytes alignment req
[01:32:28] <aatch> thiez, well you might not have a pointer at all
[01:33:26] <thiez> aatch: for which we might use NULL, I doubt there are many situations where you want to distinguish between 'I don't have a pointer' and 'I have a null pointer' when you're already working with unsafe pointers
[01:33:44] <aatch> thiez, I agree it's not likely though
[01:34:22] <thiez> I agree that allowing it is the path of least surprise
[01:35:37] <zslayton> Could someone please translate this error message for me?: "internal compiler error: Cannot relate bound region as superregion: br_self"
[01:36:11] *** Quits: glinscott (garylinsco@789A6618.53EB7C1.FFFE3AA.IP) (Quit: glinscott)
[01:36:17] <aatch> zslayton, do you have a method with a <'self>, in an impl with <'self>?
[01:36:52] <zslayton> aatch: I have an impl with a self, but no self in the method
[01:37:08] <zslayton> aatch: however, the error is raised when I'm working with a variable in a for loop
[01:37:21] <aatch> zslayton, hmm, no idea then
[01:37:50] *** Quits: huseby (huseby@moz-4E8C421A.husebyhome.com) (Ping timeout)
[01:38:31] <dbaupp> zslayton: what's the for loop?
[01:39:37] *** Joins: huseby (huseby@moz-4E8C421A.husebyhome.com)
[01:40:41] <zslayton> dbaupp: for osi.iter.advance |x| {mystruct.myfield = *x;}
[01:40:58] <dbaupp> osi is a vector?
[01:41:10] <zslayton> osi is a struct with an 'iter' field,
[01:41:40] <strcat> zslayton: what's the type of that field?
[01:42:07] <zslayton> 'R', a generic bound to Real
[01:42:22] <zslayton> (The iterator returns &R)
[01:42:52] <strcat> &'self R?
[01:43:12] <zslayton> yes
[01:43:18] <strcat> that's probably the issue
[01:43:22] <dbaupp> zslayton: what's the exact type of `iter: SomeType`?
[01:43:24] <strcat> 'self is unrelated to the self parameter
[01:43:33] <strcat> it means the lifetime of internal borrowed pointers
[01:43:35] <strcat> you probably want
[01:43:38] <dbaupp> zslayton: it's not &'self R, is it?
[01:43:44] <zslayton> My understanding of explicit lifetimes is woefully inadequate.
[01:43:47] <zslayton> It is, I'm afraid
[01:43:49] <strcat> fn foo<'r>(&'r self) -> IterType<'r>
[01:43:58] <dbaupp> and R: Real?
[01:44:04] <zslayton> I borrowed my function header from a seemingly applicable piece of code I found
[01:44:11] <zslayton> dbaupp: yep
[01:44:33] <dbaupp> .advance shouldn't work on something of type Real
[01:44:58] <zslayton> What's the prescribed approach to using an iterator of Real?
[01:45:37] <engla> implement trait Iterator<&R> on a type  (&R for example)
[01:45:59] <aatch> you very rarely wan't to have &'self
[01:46:02] <strcat> zslayton: need to see the code
[01:46:03] <aatch> want*
[01:46:14] <strcat> or know what it's trying to do
[01:46:15] <zslayton> strcat: Sure, I'll throw it in a pastebin.
[01:46:33] <zslayton> strcat: Be warned, this was my inaugural attempt to use Traits/Generics,
[01:46:51] <zslayton> strcat: It's ... problematic at best
[01:47:07] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[01:48:22] <zslayton> http://pastebin.com/nmwfrHgX
[01:49:27] <zslayton> (Any use of *x.clone() was me trying to appease the compiler. They should probably be ignored.)
[01:50:59] <dbaupp> zslayton: in that instance, it's probably better to not have the iterator in the struct
[01:51:08] <Luqman> strcat: hitting a wall with trying to get the last 2 tests working :(
[01:51:12] <strcat> it looks like it should work though
[01:51:18] <strcat> Luqman: ;[
[01:51:22] <strcat> Luqman: yeah this is painful
[01:51:31] <strcat> I don't really understand where the visit code is implemented
[01:51:33] <dbaupp> zslayton: (since it's just consumed entirely)
[01:51:40] <strcat> Luqman: like, how it traverses pointers
[01:52:15] <zslayton> dbaupp: That's doable.
[01:52:29] <dbaupp> zslayton: (btw, an api like OSI::new().update(some_iterator).update(some_other_iterator) might work.)
[01:52:56] <zslayton> dbaupp: Hm! I like that a lot. 
[01:53:08] <dbaupp> zslayton: (or `let mut osi = OSI::new(); osi.update(some_iterator); ... osi.update(some_other_iterator);`)
[01:53:43] <zslayton> dbaupp: In which all of the iterators returned the same type, I assume
[01:54:07] <dbaupp> yes, they'd have to return whatever type osi takes
[01:54:13] <zslayton> dbaupp: Is "Real" a reasonable target here? 
[01:54:36] <zslayton> dbaupp: or would it make more sense for me to just implement f64?
[01:54:50] <dbaupp> zslayton: well, I'd actually use just Num + Orderable
[01:55:16] <dbaupp> (since for this section, you only need to be able to add and multiply, and find minimums/maximums)
[01:55:30] <zslayton> dbaupp: I intend to add standard deviation and variance, similar to Graydon's additions to libextra/stats.rs
[01:55:43] <dbaupp> zslayton: yes, they can be on a separate impl that has stronger bounds
[01:55:55] <zslayton> dbaupp: Oh! Brilliant
[01:56:09] <dbaupp> zslayton: so that Real is only needed if you want the sd, but if you only need the average, then Num is fine
[01:56:34] <zslayton> dbaupp: Makes sense
[01:56:47] <dbaupp> zslayton: (also, the iterator should be R: Real, T: Iterator<R>, since not all iterator return references.)
[01:56:56] <dbaupp> actually.
[01:56:59] <dbaupp> maybe it needs both
[01:57:12] <dbaupp> .update and .update_ref
[01:57:21] <dbaupp> or something
[01:57:53] <zslayton> dbaupp: I'd love it if some form of the finished product were considered for a pull request down the road -- is there some series of steps I should be following to request comments and define the desired functionality?
[01:58:25] <dbaupp> zslayton: well, asking here's a good one :)
[01:59:10] <aatch> zslayton, there's an issue open about improving extra::stats
[01:59:21] <dbaupp> (also, getting very basic something working and opening a pull request asking for feedback (e.g. throwing the link here) would be neat.)
[01:59:21] <aatch> (I think)
[02:00:10] <zslayton> aatch: I believe I saw that -- graydon landed a huge update sometime last week. Would it be a good idea to mention what I'm working on in a comment there?
[02:00:22] <aatch> zslayton, yep
[02:00:24] <dbaupp> zslayton: you don't need to entirely replace the functionality of extra::stats though, since some functions don't really apply to Iterators as they stand at the moment
[02:00:39] <dbaupp> (e.g. percentiles/medians)
[02:00:43] <ChrisMorgan> Python: ', '.join(words). Rust: ? (sure, I can write it out the long way, but just thought there might be something for it)
[02:01:01] <aatch> ChrisMorgan, words.connect(", ")
[02:01:02] <zslayton> dbaupp: I was going to shoot for the ones that I knew could be done in a straightforward fashion with an online algorithm
[02:01:17] <dbaupp> zslayton: sounds good
[02:01:31] <zslayton> dbaupp: I'm sure that someone who actually knows a thing or two about statistical computation will have modifications to make
[02:01:37] <ChrisMorgan> Ah, connect. Thanks, aatch.
[02:01:47] <aatch> ChrisMorgan, personally, I always found the python way backwards
[02:01:56] <zslayton> I have to turn in for the evening. Thanks for all your help!
[02:02:06] <ChrisMorgan> Many people do. For myself, I don't mind which way round it is, so long as it's there :-)
[02:02:21] <dbaupp> zslayton: yeah, getting anything is a brilliant start :) 
[02:03:19] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[02:03:38] <aatch> ok, threw a ton of `~` at some of the enums, hopefully this'll help
[02:03:52] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[02:04:20] <SiegeLord> dbaupp, Why do the quantiles not make sense for iterators?
[02:04:30] <dbaupp> aatch: ~~~~~Path?
[02:04:40] <dbaupp> aatch: just to make sure
[02:04:57] <aatch> dbaupp, no, that would be silly. ~~~@@~@~Path of course
[02:04:58] <dbaupp> SiegeLord: can they be computed "online" (i.e. in O(1) space)
[02:05:08] <dbaupp> aatch: of course, much better
[02:05:31] <dbaupp> SiegeLord: (it'd be neat if they could)
[02:05:35] <SiegeLord> dbaupp, Running statistics and summary statistics seem separate issues to me
[02:05:59] <dbaupp> SiegeLord: correct, and we were talking about the former
[02:06:06] <SiegeLord> Ok, my bad
[02:06:09] <aatch> ok, managed to get the size of Ty back down to something normal
[02:07:13] <dbaupp> SiegeLord: (they don't make sense for iterators, because we want allocations to be explicit, but to calculate the median of an iterator you need to save all the values.)
[02:07:31] <SiegeLord> Right, of course
[02:07:37] <aatch> Also, the size of expr
[02:07:43] <dbaupp> aatch: you're good at making graphs go _/\_ ;P
[02:08:00] <aatch> dbaupp, it's because I have no fear
[02:08:43] <aatch> dbaupp, hopefully it'll go down /lower/ than it did before
[02:08:55] <dbaupp> that'd be nice
[02:09:39] <aatch> dbaupp, you got any way to do one of those benchmarks? Or do I have to wait for cmr to be awake?
[02:10:00] <dbaupp> aatch: nope
[02:10:12] <aatch> dbaupp, naw
[02:10:16] <dbaupp> aatch: I think he sshs in and runs it by hand
[02:10:52] <dbaupp> (we're planning something like commenting `@isrustfastyet?` on a PR and it'd come in and bench it.)
[02:12:09] *** Joins: vk (vk@2AAA6DD0.B568D26C.93B001FA.IP)
[02:15:29] <aatch> dbaupp, from the havoc I caused to the what I just did: https://gist.github.com/Aatch/5945776
[02:17:00] *** Joins: sankha93 (Instantbir@89B66790.96C9DAB3.8B6C1D65.IP)
[02:17:19] <dbaupp> expr was big
[02:17:39] <dbaupp> TyParamBound was rather large too
[02:17:48] <aatch> dbaupp, I know...
[02:18:20] <aatch> the issue isn't so much the space, but the fact that it would only be needed by like 1-2 variants
[02:18:27] <aatch> but the rest all paid for it.
[02:18:43] <dbaupp> yeah, a lot of unused bytes
[02:18:55] <dbaupp> (yay for catching regressions as they happen!)
[02:19:21] <dbaupp> maybe there could be a lint for mismatched enum variants
[02:19:35] <dbaupp> but that'd require linting after trans, I guess?
[02:21:46] <aatch> dbaupp, and it would need to be fuzzy anyway
[02:21:57] <dbaupp> hm?
[02:22:11] <aatch> since something like Option<T> is /supposed/ to have one variant smaller than the other
[02:22:20] *** Quits: RMF (RMF@moz-2CA5F393.dsl.telepac.pt) (Ping timeout)
[02:23:00] *** Quits: Diamond (dick@moz-C01E1CD1.ks.ks.cox.net) (Client exited)
[02:23:25] <dbaupp> I was thinking that enum Foo { A, B, C, X(SomeHugeStruct) } could say "maybe you mean ~SomeHugeStruct", or something
[02:23:41] <dbaupp> (this is obviously just a nice-to-have.)
[02:25:14] <aatch> I'm gonna make sure my changes pass the tests, then approve my PR, since I think this should get through sooner rather than later.
[02:25:58] *** Quits: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net) (Quit: Jesse)
[02:26:00] *** Joins: RMF (RMF@moz-ABD30586.dsl.telepac.pt)
[02:26:01] * ChrisMorgan wishes indexing was a regular operator, such that you could use maps as foo["bar"] rather than foo.find("bar")
[02:26:21] <aatch> ChrisMorgan, you can overload index
[02:26:28] <aatch> it's just not that useful atm
[02:27:08] <ChrisMorgan> Oohâ€”but HashMap at least doesn't do it :-(
[02:27:11] *** Joins: Diamond (dick@moz-C01E1CD1.ks.ks.cox.net)
[02:27:12] <ChrisMorgan> Why isn't it that useful?
[02:27:37] <strcat> ChrisMorgan: Index is going to have to be removed
[02:27:42] <strcat> implementing it for more things would be bad
[02:27:45] <aatch> ChrisMorgan, because you can't do stuff like `let a = &thing[1];` and borrow into `thing`
[02:27:52] <strcat> or &mut
[02:28:04] <ChrisMorgan> strcat: why removed?
[02:28:17] <strcat> ChrisMorgan: because the way it is now isn't good
[02:28:17] <strcat> it has to be replaced
[02:28:26] <strcat> should remove it ASAP so it can be fixed
[02:28:34] <engla> why not add more traits so that borrowing that way could be done?
[02:28:43] <aatch> engla, that's the idea
[02:28:46] <strcat> engla: why not replace it with more traits*
[02:28:49] <strcat> the current one has to go
[02:28:55] <ChrisMorgan> So &thing[1] would borrow thing, while &thing.find(1) would borrow the returned value?
[02:28:59] <engla> sounds good aatch 
[02:29:12] <strcat> ChrisMorgan: no, the 2nd can never work
[02:29:19] <aatch> ChrisMorgan, no, thing.find(1) borrows itself.
[02:29:48] <ChrisMorgan> Then the `let a = &thing[1]` case isn't anything special, surely?
[02:29:49] <aatch> the difference is that &vec[i] takes a reference into vec
[02:29:55] <aatch> ChrisMorgan, it is
[02:30:08] <aatch> it is specifically special cased
[02:30:20] <strcat> if you want thing[i] to return by-value and & and &mut to work
[02:30:21] <strcat> like vectors
[02:30:25] <aatch> if thing is a vec
[02:30:26] <strcat> it needs 3 traits
[02:30:39] <strcat> 3 separate methods
[02:30:47] <strcat> and the current one won't be part of it
[02:30:57] <strcat> and it'll need some weird coherency checking that we don't have atm
[02:31:07] <strcat> since the return types should match
[02:31:27] <ChrisMorgan> So is the summary of the matter that general-case indexing, such as might be used to make map types more elegant, will come eventually, but can't/shouldn't be done yet?
[02:31:52] <aatch> strcat, IndexCopy, IndexRef, IndexMutRef? (And then IndexAssign + IndexOpAssign when we get assign-ops)
[02:32:04] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[02:32:04] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/dhNp8Q
[02:32:04] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[02:32:05] *** Joins: glinscott (garylinsco@789A6618.53EB7C1.FFFE3AA.IP)
[02:32:08] <aatch> ChrisMorgan, correct
[02:32:27] <ChrisMorgan> GÃ¼t :-)
[02:33:22] <strcat> aatch: well not Copy
[02:33:40] <aatch> strcat, oh, so just IndexRef + .clone()
[02:33:41] <strcat> the by-value one is really tricky to match vectors
[02:33:44] <strcat> aatch: yes
[02:33:54] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[02:33:59] <strcat> we could just leave out by-value I guess, for now
[02:34:05] <strcat> well
[02:34:15] <strcat> we don't have a trait for implicitly copyable things yet
[02:34:37] <aatch> we need a POD kind.
[02:35:02] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[02:35:02] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/EVJHzg
[02:35:02] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[02:35:07] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[02:35:07] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/E1UcnA
[02:35:07] <ghrust> 13rust/06auto 14a02e37c 15Alex Crichton: Fix a warning when generating tests
[02:35:07] <ghrust> 13rust/06auto 14e07ae9e 15bors: auto merge of #7591 : alexcrichton/rust/fix-warnings, r=huonw...
[02:35:07] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[02:35:20] <strcat> aatch: &mut isn't copyable though
[02:35:25] <strcat> and @ is
[02:35:27] <strcat> so...
[02:36:09] <aatch> strcat, boo
[02:41:31] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[02:42:19] *** Quits: kimundi (kimundi@moz-CF4108F.dip0.t-ipconnect.de) (Ping timeout)
[02:45:13] *** Joins: kimundi (kimundi@moz-E0969F96.dip0.t-ipconnect.de)
[02:47:37] *** kimundi is now known as zz_kimundi
[02:48:10] <jared> can anyone take a look at this and tell me if there is a better way? http://pastebin.com/c0JsuVMS (wasn't sure about highlighting, just choose C)
[02:48:28] *** Quits: glinscott (garylinsco@789A6618.53EB7C1.FFFE3AA.IP) (Quit: glinscott)
[02:48:50] <steven_is_false> jared: sure.
[02:49:05] <aatch> jared, you can do Some(~ref mut point)
[02:51:13] *** Joins: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[02:51:41] <jared> aatch, yep that works, thanks
[02:52:05] <jared> I knew there had to be something wrong with Some(ref mut point) => ...(*point)
[02:52:14] *** Joins: glinscott (garylinsco@789A6618.53EB7C1.FFFE3AA.IP)
[02:54:57] *** Joins: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net)
[02:55:27] *** Joins: cowboyd (cowboyd@moz-DD0FF83.lightspeed.austtx.sbcglobal.net)
[02:56:00] <tikue> bblum: ping
[02:56:06] <bblum> tikue: pong
[02:56:47] <tikue> bblum: on cmr's "the state of rust 0.7," he mentions that an Iterable trait is planned, which will obviate the need to use .iter() with for loops. I was talking a bit with you recently about "default iterators," and was under the impression that this was undesirable (special-casing = bad?)
[02:57:20] *** Quits: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Ping timeout)
[02:57:25] <bblum> hmm, i can't remember exactly what my opinion was
[02:57:28] <tikue> bblum: it seems to me like an iterable trait is essentially just a way to provide a default iterator for things. Is that not the case? and if so, what are your feelings on the iterable trait?
[02:57:53] <bblum> ok right so
[02:58:09] <bblum> i felt like it was trying to special-case out the need to write .iter() only *sometimes*
[02:58:21] <bblum> because sometimes you want to be like, for vec.iter().zip(...).filter(...)
[02:58:27] <bblum> and you can't special case out the iter() call there
[02:58:33] <Eridius> well you could
[02:58:44] <bblum> syntax sugar should be applicable in all cases
[02:58:49] <strcat> bblum: zip could be provided as a default method for iterables
[02:59:06] <bblum> well, what about .rev_iter ?
[02:59:24] <strcat> well then you want something that's not the default
[02:59:25] <bblum> default methods might make it work. i dunno.
[02:59:40] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[02:59:50] <bblum> making rev a default method might be ok
[03:00:08] <bblum> gotta go; will talk more tomorrow
[03:00:13] * ChrisMorgan also wishes Rust had the likes of Python's properties, e.g. to remap `headers.content_length` to `headers.find("Content-Length")`/`headers.insert("Content-Length", value)`
[03:00:14] <tikue> kk thanks bblum 
[03:01:11] *** Joins: seth (seth@moz-2C443A35.hsd1.co.comcast.net)
[03:01:43] <strcat> ChrisMorgan: and what if you take a reference to it?
[03:01:44] <steven_is_false> ChrisMorgan: Hmm, maybe a macro could do it? sugar!(headers.content_length) would be the same as headers.find("Content-Length")?
[03:01:51] <strcat> it won't act like a field
[03:02:09] <ChrisMorgan> steven_is_false: *shudder*
[03:02:11] <strcat> it will confuse people just like &str/&[] do
[03:02:16] <strcat> a field that isn't a field
[03:02:31] <strcat> to save 2 characters for ()
[03:02:56] <ChrisMorgan> strcat: it'd become get_X() and set_X()
[03:03:08] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[03:03:29] <ChrisMorgan> So that's probably *4* characters for get and *3* for set! =-O
[03:04:35] <strcat> and in exchange you actually know when something is a field or a method, and &/&mut on a field never give you unexpected errors
[03:04:51] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[03:04:55] <strcat> and when destructuring you aren't surprised by a field not being there
[03:05:16] <strcat> it'd be quite weird if you could access foo.bar but not destructure that field
[03:05:32] <dbaupp> ChrisMorgan: it'd be against Rust's ideals for a "field access" (normally very cheap) to be an expensive function call (e.g. searching a hashmap)
[03:05:36] <ChrisMorgan> Yeah, yeah... but it'd still be nice sometimes :P
[03:06:13] *** Quits: posco (oscarboyki@moz-4CC6D00A.hsd1.ca.comcast.net) (Quit: posco)
[03:07:07] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Ping timeout)
[03:07:55] *** Quits: Earnestly (earnest@2A2BF8F5.321FA5E6.BFD1ABFD.IP) (Ping timeout)
[03:08:28] *** Joins: MaikKlein (maik@moz-CA56C650.dip0.t-ipconnect.de)
[03:18:37] *** Quits: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net) (Ping timeout)
[03:18:51] * ChrisMorgan has just found what he really hopes to be a genuine bug in Rust
[03:19:43] <ChrisMorgan> It doesn't end up quite the easiest thing to demonstrate, as it doesn't occur if the trait is in the same crate.
[03:20:01] <SiegeLord> Would one say that Rust has no memory leaks in safe code?
[03:20:17] <SiegeLord> (modulo compiler bugs)
[03:20:19] <steven_is_false> SiegeLord: Managed pointers can lead to memory leaks.
[03:20:35] <SiegeLord> Let's say we have a GC
[03:20:38] <dbaupp> steven_is_false: not with a proper GC
[03:20:53] <dbaupp> SiegeLord: that's the aim, I think
[03:20:54] <aatch> Bollocks... seems that my change _doesn't_ fix the issue.
[03:21:03] <dbaupp> ChrisMorgan: what does it look like?
[03:21:11] <steven_is_false> dbaupp: Memory leaks happen all the time in Haskell, and JavaScript, and other garbage collected languages.
[03:21:26] <steven_is_false> dbaupp: They're simply called different names like space leaks.
[03:21:32] <steven_is_false> But they're the same thing.
[03:21:59] <steven_is_false> Consider, a process that has a vector which continuously grows over time.
[03:22:14] <SiegeLord> Damn, that's a second person I've encountered today that calls "space leaks" memory leaks :P
[03:22:14] <steven_is_false> Even in the simple case of an owned array one can have a leak.
[03:22:53] <bjz_> MaikKlein: yay! all the HOFs are gone from lmath
[03:22:59] <ChrisMorgan> Example: a straight impl block doesn't recognise methods defined in an impl block for a trait. Remove the "for X" part in the other impl and it works fine; copy the definition (I was using std::rt::io::Writer) into the same file and it's fine.
[03:23:02] <aatch> dbaupp, do you have a script for turning mem-bench output into a picture?
[03:23:14] <dbaupp> aatch: of sorts
[03:23:15] <ChrisMorgan> But I end up with a "type `&mut Foo` does not implement any method in scope named `write`"
[03:23:24] <dbaupp> aatch: sec
[03:23:38] <dbaupp> (well, if you send me the data I can do it?)
[03:23:43] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: Leaving)
[03:23:55] <aatch> dbaupp, sure, gimme a moment.
[03:23:59] <dbaupp> ChrisMorgan: in code?
[03:24:51] <dbaupp> steven_is_false: that's a different style of memory leak to what (I guess) SiegeLord was talking about... too many references to an alloc, rather than 0.
[03:25:10] <dbaupp> (in theory Rust avoids all of the latter, but the former are trickier.)
[03:25:28] <ChrisMorgan> rusti: struct Foo;impl Foo{fn foo(&mut self,bar:~str){self.write(bar.as_bytes());}}impl std::rt::io::Writer for Foo{fn write(&mut self,buf:&[u8]){}fn flush(&mut self){}}
[03:25:29] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/HcgP
[03:25:51] <ChrisMorgan> rusti: struct Foo;impl Foo{fn foo(&mut self,bar:~str){self.write(bar.as_bytes());}}impl Foo{fn write(&mut self,buf:&[u8]){}fn flush(&mut self){}}
[03:25:53] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/IPJc
[03:26:01] *** Joins: quvarxa (chatzilla@moz-978E4C31.static.tpgi.com.au)
[03:26:14] <ChrisMorgan> (That demonstrates that it works if you drop the "std::rt::io::Writer for " in the second impl block.)
[03:26:33] <dbaupp> rusti: use std::rt::io::Writer; struct Foo;impl Foo{fn foo(&mut self,bar:~str){self.write(bar.as_bytes());}}impl Writer for Foo{fn write(&mut self,buf:&[u8]){}fn flush(&mut self){}}
[03:26:34] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/gDOR
[03:26:56] <dbaupp> ChrisMorgan: to use the methods from a trait, the trait has to be in scope unqualified
[03:27:16] <dbaupp> rusti: use std::rt::io::Writer; struct Foo;impl Foo{fn foo(&mut self,bar:~str){self.write(bar.as_bytes());}}impl Writer for Foo{fn write(&mut self,_buf:&[u8]){}fn flush(&mut self){}}
[03:27:16] -rusti- ()
[03:27:19] <ChrisMorgan> Huh? Why?
[03:27:58] <dbaupp> because bad things would happen if every method from every trait was in scope automatically
[03:28:07] <dbaupp> (which is the alternative)
[03:28:18] <ChrisMorgan> I don't understand.
[03:28:30] *** Joins: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP)
[03:28:32] <ChrisMorgan> Why would bad things happen? *How* would bad things happen?
[03:29:28] <ChrisMorgan> So that means that if I wanted to, from another module, call Foo.write(), I'd need to have done `use std::rt::io::Writer`?
[03:30:27] <dbaupp> yeah
[03:30:29] *** Joins: santiago (santiago@moz-8ADE82B4.socal.res.rr.com)
[03:31:01] <dbaupp> it would make name resolution very fragile
[03:31:22] <bjz_> it'd be kinda cool if you could 'package' traits with a struct/enum
[03:31:36] <aatch> dbaupp, I uploaded what I have here: http://aatch.net/not-change.txt
[03:31:50] *** Quits: cowboyd (cowboyd@moz-DD0FF83.lightspeed.austtx.sbcglobal.net) (Client exited)
[03:31:54] <ChrisMorgan> I suppose you could get conflicts if it worked that way.
[03:32:00] <bjz_> so when you import a struct the methods would be available
[03:32:05] <dbaupp> ChrisMorgan: yeah, essentially
[03:32:29] <dbaupp> ChrisMorgan: (common traits like Writer will be in the prelude, so they'll work automatically, normally.)
[03:32:33] <bjz_> but yeah, might add too much complexity - dunno if there'd be a way to do that elegantly (probably not)
[03:32:48] <dbaupp> aatch: ok
[03:32:49] <ChrisMorgan> OK, I can see why you'd need it to be that way, but it's a nuisance and certainly not immediately obvious. And the error message doesn't help at all.
[03:32:51] <bjz_> ChrisMorgan: conflicts are the biggest problem
[03:33:06] <ChrisMorgan> So it isn't a Rust bug after all, just a thoroughly non-obvious but necessary behaviour. :-(
[03:33:18] <aatch> I pretty much just want see how the memory profile differs
[03:34:10] <dbaupp> ChrisMorgan: yeah, it'd be neat if it scanned all the traits and suggested them
[03:34:26] *** Joins: cowboyd (cowboyd@moz-DD0FF83.lightspeed.austtx.sbcglobal.net)
[03:34:28] <ChrisMorgan> Yep, that's what I'd like. Should I file an issue to that effect?
[03:35:00] <dbaupp> bjz_: that would be useful, although it might lead to similar problems (or at least make things confusing/complicate middle::resolve even more)
[03:35:04] <dbaupp> ChrisMorgan: yeah, sounds good.
[03:35:37] <ChrisMorgan> That way I get to file something. Validates my existence and all that. ;-)
[03:36:19] <bjz_> dbaupp: yep, as I said, dunno if there's a way to make it easier - probably not :(
[03:36:20] <Jeaye> Why would changing lt to gt make extra::sort::quick_sort3 an infinite loop? :P
[03:36:36] <bjz_> dbaupp: I just worry about the limitations of traits
[03:37:40] <bjz_> dbaupp: maybe you could do: impl<T:Num> Foo<T>: Num {}
[03:38:04] <bjz_> dbaupp: that would require an implementation of Num to be available
[03:38:08] <bjz_> dbaupp: i dunno
[03:38:17] *** Parts: vk (vk@2AAA6DD0.B568D26C.93B001FA.IP) ()
[03:38:25] *** Quits: jfbk (user@moz-EEA9CFB3.nyc.res.rr.com) (Ping timeout)
[03:38:26] *** Joins: vk (vk@2AAA6DD0.B568D26C.93B001FA.IP)
[03:38:28] <bjz_> dbaupp: also have to take cognitive overhead into account
[03:38:44] <bjz_> dbaupp: traits can be difficult to reason about :(
[03:38:56] <bjz_> (on a human level)
[03:39:01] <aatch> could sombody run this: https://gist.github.com/Aatch/5946068 and send me the results, pretty please?
[03:39:08] <dbaupp> bjz_: yeah, I have a feeling much of it is just something users of Rust will have to learn
[03:39:43] <aatch> specifically, with a compiler that's from before me jumping memory usage up
[03:39:57] *** Quits: Sorella (queen@78575561.924F2739.95C8B7C6.IP) (Ping timeout)
[03:40:13] <dbaupp> aatch: https://gist.github.com/huonw/8408ea875cabc786c5ea
[03:40:28] <dbaupp> aatch: `rustc 0.7 (58eb70a 2013-07-05 04:28:56 -0700)`
[03:41:08] <dbaupp> bjz_: to be clear, there are some aspects which are totally bad (lack of associated items), but there are others that are just how traits work
[03:41:20] <dbaupp> bjz_: e.g. it's the same in Haskell with their typeclasses
[03:41:36] <bjz_> I really hate FromStr::from_str :(
[03:41:47] <dbaupp> (admittedly, some bits are worse)
[03:41:47] <aatch> dbaupp, thanks
[03:41:51] * dbaupp isn't that bothered by it
[03:45:31] <dbaupp> aatch: http://www.ug.it.usyd.edu.au/~hwil7821/rust-bench/aatch.png
[03:45:35] *** Quits: quvarxa (chatzilla@moz-978E4C31.static.tpgi.com.au) (Ping timeout)
[03:45:44] <aatch> Woah
[03:45:56] <aatch> isn't that all LLVM...
[03:46:23] <dbaupp> not sure
[03:46:36] <dbaupp> (were you running with -O?)
[03:46:37] <aatch> maybe not, no optimizations.
[03:47:19] <dbaupp> I guess only the last half is LLVM then
[03:47:28] <dbaupp> i.e. from 25 or so
[03:47:49] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Client exited)
[03:47:59] <aatch> I'm running another go.
[03:48:58] *** Quits: sankha93 (Instantbir@89B66790.96C9DAB3.8B6C1D65.IP) (Ping timeout)
[03:51:56] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[03:52:29] *** Quits: eagen (eagen@moz-92A457CB.hsd1.mn.comcast.net) (Ping timeout)
[03:52:48] *** Joins: sankha93 (Instantbir@89B66790.96C9DAB3.8B6C1D65.IP)
[03:53:29] *** Quits: aatch (aatch@moz-B437F499.pocketrent.com) (Ping timeout)
[03:55:29] <strcat> dbaupp: one more attempt at finishing the header thing....
[03:55:34] <strcat> 2 failing tests left :(
[03:55:42] <dbaupp> so close! :)
[03:56:16] <vk> Question, in this scenario "let mut d = @13", the variable d can only be assigned values of type @int and nothing else?
[03:56:49] <dbaupp> vk: yes
[03:56:57] <vk> dbaupp: kay'o, thanks.
[03:57:59] <strcat> dbaupp: dangerously close ;p
[03:58:01] * strcat sighs
[03:58:25] <strcat> if only I could figure out where the actual implementation of visiting pointers was
[03:58:34] *** Joins: aatch (aatch@moz-B437F499.pocketrent.com)
[03:58:37] <strcat> reflect.rs seems to only walk the ty tree
[03:58:48] <aatch> dbaupp, ok, I can't run it with opts
[03:58:53] <dbaupp> aatch: np
[03:58:54] <strcat> need to know where the implementation of actually walking the runtime representations is :(
[03:58:58] <strcat> that's what needs fixing
[03:58:58] *** Parts: steven_is_false (user@moz-144077DE.bchsia.telus.net) (ERC Version 5.3 (IRC client for Emacs))
[03:59:10] <dbaupp> aatch: that only changes the LLVM stuff, right?
[03:59:16] <aatch> (my leaving briefly is not a coincidence)
[03:59:20] <aatch> dbaupp, seems like it...
[03:59:33] <dbaupp> aatch: you crashed your computer?
[03:59:34] <strcat> aatch: what does it have to do with leaving? ;p
[03:59:46] <ChrisMorgan> There, filed https://github.com/mozilla/rust/issues/7643 :-)
[03:59:50] <aatch> I didn't crash, I just locked up
[03:59:51] <dbaupp> strcat: there's another place in std that does reflection
[04:00:16] <strcat> dbaupp: yeah but I don't think that's the issue here
[04:00:26] <strcat> the compiler implements visiting somewhere
[04:00:26] <dbaupp> strcat: ok
[04:00:37] <strcat> the libstd part just exposes it afaict
[04:00:56] <dbaupp> trans::reflect?
[04:01:04] <strcat> that's what I was looking at
[04:01:12] <strcat> don't see any handling of the runtime box representation
[04:01:17] <strcat> maybe I'm missing something obvious
[04:01:17] <dbaupp> yep, I assumed so
[04:02:29] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[04:02:39] <strcat> I guess it's the visit glue
[04:02:42] <dbaupp> what's the ty::ty_* representation of a trait object?
[04:03:03] * strcat really can't find it ;p
[04:03:13] <dbaupp> oh
[04:03:15] <dbaupp> :(
[04:03:16] <strcat> dbaupp: it's not traits that are broken
[04:03:20] <strcat> it's just ~/~[] afaict
[04:03:30] <strcat> I think ~[] is pretending to be an ~T in the visit glue
[04:03:33] <strcat> but I don't see where
[04:03:38] <dbaupp> oh
[04:04:02] * strcat shrugs
[04:04:10] <strcat>     [run-pass] run-pass/borrowck-mut-uniq.rs
[04:04:12] <strcat>     [run-pass] run-pass/repeated-vector-syntax.rs
[04:04:14] <strcat> these are the 2 broken tests
[04:04:16] <dbaupp> yeah, is ~[T] ty::ty_uniq(ty::ty_evec(...)) ?
[04:04:25] <strcat> dbaupp: no
[04:04:34] <strcat> ty::ty_evec is either @[] or ~[]
[04:04:40] <dbaupp> I see
[04:04:43] <strcat> but sometimes the compiler pretends it's a ~ or @
[04:04:50] <strcat> which is now wrong for exchange allocs (non-managed unique)
[04:05:05] <dbaupp> :/
[04:05:08] <strcat> until I remove vector headers (a whole other probably harder project)
[04:05:27] <strcat> and less rewarding ;p
[04:07:11] *** Quits: vk (vk@2AAA6DD0.B568D26C.93B001FA.IP) (Quit: vk)
[04:07:48] *** Joins: dwhyte (dwhyte@ED9190FB.B72E355F.7BF4A4B0.IP)
[04:07:55] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[04:07:55] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/E1UcnA
[04:07:55] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[04:08:32] *** Quits: MaikKlein (maik@moz-CA56C650.dip0.t-ipconnect.de) (Ping timeout)
[04:08:46] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[04:09:48] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[04:10:55] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[04:10:55] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/AND0gA
[04:10:55] <ghrust> 13rust/06auto 14641aec7 15Daniel Micay: remove some method resolve workarounds
[04:10:55] <ghrust> 13rust/06auto 1408ec2fd 15bors: auto merge of #7595 : thestinger/rust/iterator, r=huonw...
[04:10:56] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[04:10:59] *** Quits: cowboyd (cowboyd@moz-DD0FF83.lightspeed.austtx.sbcglobal.net) (Client exited)
[04:11:28] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[04:11:29] *** ChanServ sets mode: +o dherman
[04:16:04] *** Quits: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net) (Quit: dbaupp)
[04:16:07] <strcat> stupid visit glue :(
[04:16:17] *** Quits: zz_kimundi (kimundi@moz-E0969F96.dip0.t-ipconnect.de) (Ping timeout)
[04:18:10] <strcat> aatch: any idea where the TyVisitor stuff is actually implemented?
[04:18:17] <strcat> visit_uniq, visit_evec_uniq
[04:18:20] <strcat> :q
[04:18:22] <strcat> ugh
[04:18:34] <strcat> sometimes focus doesn't feel like working ;p
[04:18:37] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[04:18:39] <aatch> strcat, I think it was recently moved into unstable::intrinsics
[04:18:43] *** Quits: sankha93 (Instantbir@89B66790.96C9DAB3.8B6C1D65.IP) (Quit: Instantbird 1.4 -- http://www.instantbird.com)
[04:19:02] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[04:19:12] <strcat> oh I think I found the problem
[04:19:18] <strcat> hrm
[04:20:01] *** Joins: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net)
[04:22:03] <aatch> hmm.. I wonder if it's because with a copy on a something containing ~ it'll do a deep copy...
[04:22:32] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[04:23:13] <Luqman> strcat: you might also want to check out libstd/repr.rs
[04:23:24] <strcat> I found an issue
[04:23:31] <strcat> opaque_trait
[04:23:34] <strcat> in type_.rs
[04:24:05] <strcat>                 Type::struct_(
[04:24:07] <strcat>                     [ tydesc_ptr, Type::unique(ctx, &Type::i8()).ptr_to()],
[04:25:46] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[04:26:00] <strcat> Luqman: are there ~Trait in either of those tests?
[04:26:16] <Luqman> no
[04:26:50] <strcat> ok that's a non-issue then
[04:26:52] <strcat> hm
[04:27:45] <acrichto1> r? #7497 and #7568?
[04:28:01] <Luqman> strcat: the issue is when you use %? it seems
[04:28:08] <strcat> Luqman: repr?
[04:28:12] <Luqman> yep
[04:28:59] <Luqman> for example `let x = ~21; println(fmt!("%?", x));` outputs ~0
[04:29:07] <strcat> great ;p
[04:29:32] <Luqman> so it's repr for unique pointers that's broken
[04:29:37] <aatch> cmr, said that the graph he did the first time was pre-Ty, right?
[04:29:42] <strcat> Luqman: ugh
[04:30:53] <strcat> Luqman: visit_ptr_inner?
[04:31:38] <Luqman> something somewhere in repr is assuming the wrong thing about the layout of ~T i think
[04:31:56] <dbaupp> aatch: yeah
[04:32:07] <aatch> Ok, I'm just gonna revert that commit.
[04:32:25] <dbaupp> :(
[04:32:35] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[04:32:41] <aatch> since I'm pretty sure the issue is that a copy expression will happily follow ~
[04:32:58] <dbaupp> yeah, it has to
[04:33:16] <aatch> and there's probably something keeping hold of the data during fold
[04:33:28] <aatch> (which really should just consume the AST
[04:33:30] <aatch> )
[04:33:43] <Luqman> strcat: looking at visit_uniq and visit_box, they're pretty much the same. So I think visit_uniq needs some modification
[04:33:45] <strcat> Luqman: yep
[04:33:47] <strcat>         do self.get::<&managed::raw::BoxRepr> |b| {
[04:34:04] <dbaupp> aatch: probably, but rewriting it would be a large task, I guess
[04:34:08] <strcat> Luqman: rebuilding atm
[04:34:11] <strcat> with 
[04:34:13] <strcat>         do self.get::<*c_void> |b| {
[04:34:17] <aatch> dbaupp, re-writing it, yes
[04:34:25] <strcat> Luqman: well
[04:34:27] <strcat> wait
[04:34:29] <aatch> making it consume the AST, maybe not.
[04:34:29] <strcat> it needs to use contains_managed
[04:34:33] <dbaupp> aatch: (well, modifying it.)
[04:34:50] * strcat sighs
[04:34:53] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[04:34:53] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1408ec2fd to 14e07ae9e: 02http://git.io/N3iJvQ
[04:34:53] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[04:34:55] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[04:34:55] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/mybQCA
[04:34:55] <ghrust> 13rust/06auto 14208eb0f 15Alex Crichton: Implement `map_mut` on the Option type...
[04:34:55] <ghrust> 13rust/06auto 1496ae000 15bors: auto merge of #7497 : alexcrichton/rust/issue-7394, r=huonw
[04:34:55] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[04:34:58] <aatch> but it's a bit of a circular dependency here.
[04:34:59] * dbaupp doesn't know how to say what he means
[04:35:00] <strcat> Luqman: this is a mess
[04:35:07] <strcat> I don't see how it can use contains_managed here
[04:35:07] <dbaupp> acrichto1: perfectly timed! :)
[04:35:20] <Luqman> strcat: perhaps just add a new visit, visit_uniq_non_managed or something
[04:35:52] <dbaupp> acrichto1: does https://github.com/mozilla/rust/pull/7568 undo the disabling-rusti-tests thing that graydon did?
[04:36:09] <strcat> Luqman: I don't really know where this gets called though
[04:36:09] <dbaupp> acrichto1: oh, right, your comment.
[04:36:12] <strcat> Luqman: well
[04:36:19] <strcat> Luqman: the compiler calls it I guess
[04:36:32] <strcat> Luqman: I could add a parameter
[04:36:38] <strcat> is_managed
[04:37:13] <Luqman> strcat: i think i've an idea of how to make it work
[04:37:17] <acrichto1> dbaupp: thanks!
[04:37:24] <strcat> Luqman: can we just add is_managed to visit_uniq?
[04:37:47] <acrichto1> dbaupp: rusti tests haven't actually been disabled yet, but they should be
[04:37:57] <dbaupp> err, we possibly have a bors on the loose http://buildbot.rust-lang.org/bors/bors.html
[04:38:20] <dbaupp> acrichto1: I though graydon pushed that straight to master
[04:38:47] <Luqman> strcat: does it have access to the ty?
[04:38:52] <strcat> Luqman: lets see...
[04:39:01] <acrichto1> dbaupp: yeah they're still enabled in master right now
[04:39:26] <strcat> Luqman: yes
[04:39:30] <strcat> Luqman: middle/trans/reflect.rs
[04:39:46] *** Joins: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[04:39:55] <strcat> Luqman: not sure where the rest is defined
[04:39:57] <strcat> ;\
[04:40:02] <strcat> ugh
[04:40:07] <strcat> Luqman: mtbl is on all of them
[04:40:09] <dbaupp> acrichto1: oh
[04:40:14] <strcat> Luqman: it'd be easier to add visit_uniq_managed
[04:40:18] <aatch> heh, cat fight on the ML it seems
[04:40:51] <strcat> aatch: I tried and probably failed to raise the level of discussion ;p
[04:40:53] <Luqman> strcat: https://gist.github.com/luqmana/a15834ce6b30ffb9b9de
[04:41:04] <strcat> Luqman: ah, nice
[04:41:13] <Luqman> well, almost
[04:41:21] <strcat> well it's a start
[04:41:23] <strcat> ;p
[04:41:38] <Luqman> needs stage0 guards
[04:42:08] <strcat> ugh
[04:42:12] <strcat> github ruins patches somehow
[04:42:16] <strcat> error: src/libstd/repr.rs: patch does not apply
[04:42:26] * strcat doesn't understand
[04:43:06] <strcat> oh nvm
[04:44:24] <strcat> Luqman: trying to build
[04:44:34] <strcat> we'll see...
[04:44:41] <bjz_> aatch: I don't really understand the segmented stack thing
[04:44:55] <bjz_> aatch: is that the cat fight you're talking about?
[04:44:58] <bjz_> :P
[04:45:01] <aatch> bjz_, kinda
[04:45:06] <aatch> more the OS flame war
[04:45:06] <strcat> bjz_: it's simple ;p
[04:45:25] <strcat> bjz_: LLVM calculates the stack space a call uses, and adds __morestack to every fn, calling our stack growth code if it needs to
[04:45:37] <strcat> instead of a big stack, we end up with many stacks
[04:45:42] <strcat> getting allocated/deallocated
[04:45:43] <strcat> segments
[04:46:01] *** Quits: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Ping timeout)
[04:46:09] <bjz_> and some folks do not like this?
[04:46:21] <strcat> bjz_: it's slow
[04:46:34] <strcat> 10-500% slower than C++, at least, depending on the case
[04:47:00] <strcat> there's another recent thread on the mailing list about a regression
[04:47:10] <bjz_> :O
[04:47:12] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[04:47:13] <strcat> but it's really just an extremely minor code size increase, turning off inlining
[04:47:22] <strcat> and then making the stack growth code kick in
[04:47:54] <strcat> 500% perf hit from stack growth alone (you can use RUST_MIN_STACK=5000000 to remove most of the overhead and check)
[04:48:01] <strcat> worst I've seen
[04:48:47] <strcat> bjz_: anyway, segmented stacks are useful for a specific case - spawning a bunch of tasks to do one thing, handle I/O
[04:49:09] <strcat> so it can just be part of the API, whether you want to not reserve a big initial segment
[04:49:29] <strcat> the thread turned into some kind of ideological battle
[04:49:39] <strcat> not based on actual facts
[04:49:41] <strcat> ;\
[04:50:02] <strcat> segmented stacks are useful, but they also suck for the general case
[04:50:08] <strcat> pretty simple imo, we need both
[04:50:10] <lkuper> would someone mind mentioning the code of conduct to that thread again?
[04:50:14] <lkuper> people are just slinging insults now
[04:50:32] <dbaupp> strcat: actual facts are just annoyances on mailing lists. :(
[04:53:52] <Jesse> "please take this thread to one of the thousands of mailing lists dedicated to OS flamewars"
[04:54:12] <lkuper> if I were a Mozilla employee I'd quote the last three insults, say that they're not acceptable, link the code of conduct again, say that the thread is over, and say that anyone who wants to politely discuss segmented stacks wrt Rust can start a new thread.
[04:55:06] <Jesse> i am sad that gmail's "murder thread" feature doesn't work when the thread has already been filtered (to a mailing list folder)
[04:55:48] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[04:55:55] * strcat doesn't think it really needs more discussing
[04:56:03] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[04:56:23] <strcat> just needs to be implemented (an API able to offer them as-needed)
[04:58:15] <strcat> Luqman: heh, so close to the end...
[04:58:16] <Jesse> in the configuration where running out of stack aborts the process, i hope we can use guard pages to avoid having a branch at the top of each function
[04:58:25] <aatch> https://github.com/mozilla/rust/pull/7644 :(
[04:58:49] <strcat> Jesse: the branch isn't actually that bad, it's only going to be a 1-5% hit
[04:59:21] <strcat> Jesse: problem with guard pages is that if you have uninit memory in a block as big as the guard page (or bigger), I don't think it'll matter
[04:59:24] <dbaupp> aatch: :(
[04:59:29] <Luqman> strcat: success \o/
[04:59:34] <strcat> Luqman: :D
[04:59:39] <sfackler> does Go run into the same segmented stack perf issues that Rust is running into? I don't remember hearing anything about it from their end.
[04:59:39] <dbaupp> Luqman: yay!
[04:59:40] <Luqman> that is running the tests manually with the stage1 rustc
[04:59:51] <Jesse> strcat: yeah, you'd need a check for large stack frames
[04:59:55] <lkuper> strcat: I think the people calling each other names on rust-dev need to be called out regardless of whether there's more to say about segmented stacks.  pretend it's some other issue that you know nothing about or have no opinion on.
[04:59:57] <strcat> Luqman: pushed it
[04:59:59] <Luqman> now to make sure it makes it through to stage2 and the rests of the tests
[05:00:21] <strcat> lkuper: well I'm no good at cat herding
[05:00:22] <Jesse> strcat: i also hope all this stuff happens very late in the llvm pipeline, so it doesn't affect inlining decisions
[05:00:23] <dbaupp> sfackler: is Go designed for C/C++-speeds?
[05:00:26] <strcat> dbaupp: no
[05:00:29] * dbaupp doesn't know
[05:00:35] <Luqman> strcat: this? https://gist.github.com/luqmana/a15834ce6b30ffb9b9de
[05:00:56] <Jesse> lkuper: i didn't know you needed to be a moco employee to declare a thread over
[05:00:56] <strcat> Luqman: yep
[05:00:58] <strcat> Luqman: just added cfg stuff
[05:01:04] <strcat> Luqman: and edited reflect.rs
[05:01:06] <strcat> err
[05:01:20] <strcat> Luqman: I applied your earlier patch ;p
[05:01:23] <dbaupp> googling "go segmented stack performance" doesn't appear to turn up anything relevant
[05:01:26] <lkuper> Jesse: you don't, and I'd do it myself but I'm some random ex-intern and occasional project volunteer.  but I'm coming awful close to doing it myself
[05:01:49] <strcat> dbaupp: they have bigger perf issues (gc, the compilers don't do real analysis/optimization)
[05:01:51] <dbaupp> Jesse: I guess it just has more weight coming from a moco employee
[05:01:59] <dbaupp> strcat: yeah, that's what I thought
[05:02:12] <Luqman> strcat: yea, i had to make some changes in libstd/reflect.rs as well
[05:02:16] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[05:02:32] <dbaupp> aatch: did you measure that reversion?
[05:02:34] <aatch> dbaupp, if I give you another file, could you make another graph, just to confirm my suspicions?
[05:02:40] <dbaupp> aatch: heh, yeah
[05:03:02] <dbaupp> aatch: I mean, no, you should just read the 3MB of json by hand ;P
[05:03:09] <aatch> I'm watching htop though and it looks like it's staying down
[05:03:33] <lkuper> I guess that by "Mozilla employee" I really mean "someone closer to the top of https://github.com/mozilla/rust/graphs/contributors than me"
[05:04:14] <Luqman> strcat: in your pull under libstd/reflect.rs in visit_uniq_managed you have self.inner.visit_uniq, shouldn't that be self.inner.visit_uniq_managed?
[05:04:21] <dbaupp> lkuper: you're 12, that's pretty high.
[05:04:44] <strcat> Luqman: heh, indeed
[05:05:26] <strcat> ugh I broke it more
[05:05:51] <strcat> Luqman: ok should be fixed now
[05:05:58] * strcat pushed
[05:08:48] <strcat> Luqman: it's possible we broken ~Trait with a 'static bound, assuming it has no tests
[05:08:52] <strcat> broke*
[05:09:07] <strcat> but I don't really know for sure
[05:09:21] <Luqman> got a code sample to compare?
[05:09:32] <strcat> Luqman: well I don't really know how to use it
[05:09:34] <strcat> ;p
[05:09:38] * strcat just talked to bblum about it before
[05:09:39] *** Quits: Nisstyre (wes@moz-FD86289.netflash.net) (Quit: Leaving)
[05:10:01] <strcat> Luqman: I guess you just put ~Trait: 'static as the type?
[05:10:02] <strcat> not sure.
[05:10:22] <aatch> dbaupp, huh, running it under mem-bench seems to kill it...
[05:10:35] <dbaupp> aatch: kill what?
[05:10:52] <strcat> Luqman: look in middle/trans/type_.rs 'fn opaque_trait'
[05:10:58] <aatch> dbaupp, the process. or something.
[05:11:07] <strcat> Luqman: it assumes all ~ is managed-unique (now that Type::unique is for that)
[05:11:18] <strcat> but.... I don't know if it's a real issue.
[05:11:31] <aatch> I'm not sure, but I get way different results (based on my watching htop change)
[05:12:32] <Luqman> strcat: i don't know, though at this point i'm tempted to just leave that off for now given the already fragile state of ~Traits
[05:12:37] <dbaupp> aatch: hm
[05:12:54] <dbaupp> aatch: can you measure a compiler before your change?
[05:13:05] <strcat> Luqman: yeah, if it has no tests... I don't really know if it ever worked well
[05:13:18] <aatch> dbaupp, unfortunately no
[05:13:30] <dbaupp> aatch: oh :(
[05:13:39] <aatch> well not easily anyway
[05:13:45] <mark_edward> so im confused.
[05:13:48] <aatch> I managed to do a no-opt build
[05:13:51] <strcat> Luqman: they still seem to segfault for me (~Trait) :\
[05:13:52] <mark_edward> what will you be doing about stacks?
[05:13:58] <strcat> Luqman: as in without my PR
[05:14:13] <glinscott> are the strings in rust utf-8?  i seem some areas where they are handling 6 byte unicode, but utf-8 is max 4 bytes
[05:14:30] <strcat> glinscott: I have a PR open to fix that
[05:14:34] <strcat> partly, at least
[05:14:38] <strcat> it still allows overlong encodings
[05:14:39] <mark_edward> strcat: do you know what will be done about the stacks?
[05:14:49] <glinscott> strcat: ok, cool.  i'm looking at push_char right now
[05:14:50] <strcat> mark_edward: well I know the issue will be resolved, not how yet
[05:14:54] <strcat> glinscott: yeah I fixed that
[05:15:05] <strcat> glinscott: fixing it broke a json test, so I disabled it
[05:15:15] <strcat> glinscott: https://github.com/mozilla/rust/pull/7612
[05:15:16] <aatch> dbaupp, that said, but computer seems to be having a hissy fit anyway...
[05:15:28] <strcat> glinscott: the json failure is reported as #7511
[05:15:29] <glinscott> strcat: ok, great.  ah, back to json encoding :).  ok, great, i'm looking at it because push_char is super slow
[05:15:30] <strcat> err
[05:15:36] <strcat> glinscott: #7611 *
[05:15:43] <aatch> dbaupp, I got this though http://aatch.net/revert-ty.txt
[05:15:50] <mark_edward> can someone also explain the Rust threading model a bit more. i was under the impression that you could do stuff like for 100.times { do spawn { ... } } because the tasks were lightweight
[05:15:59] <mark_edward> almost like go's task model
[05:16:05] <mark_edward> is that going to change?
[05:16:14] <strcat> mark_edward: you can do that with threads in C too
[05:16:40] <mark_edward> wouldn't it cause major performance issues with the threading model there?
[05:16:43] <strcat> no
[05:16:45] <dbaupp> aatch: on it
[05:16:55] <strcat> mark_edward: Go has cooperatively scheduled tasks multiplexed onto OS threads
[05:17:07] <mark_edward> will Rust do that too?
[05:17:10] <strcat> why cooperative scheduling? because without pre-emption, there's less overhead for I/O
[05:17:25] <strcat> mark_edward: rust has that, but it's not just for I/O (unlike Go's niche)
[05:17:32] <strcat> it needs real threads too
[05:17:41] <strcat> but neither of those is related to segmented stacks really
[05:17:59] <aatch> I think my graphics drivers crashed
[05:18:02] <mark_edward> what is the segmented stack issue about? Rust tasks or the real threads?
[05:18:07] <strcat> mark_edward: both
[05:18:12] <lkuper> ok, message sent to list
[05:18:25] <mark_edward> what does Go use?
[05:18:30] <strcat> segmented stacks
[05:18:58] <dbaupp> aatch: is your computer rusting?
[05:19:11] <aatch> dbaupp, not this one, it's my nice work one
[05:19:21] <aatch> probably didn't like hard-reset
[05:19:21] <strcat> segmented stacks are needed to spawn a huge number of tasks on 32-bit
[05:19:47] *** Quits: aatch (aatch@moz-B437F499.pocketrent.com) (Client exited)
[05:19:54] <strcat> on 64-bit, the only thing they accomplish is reducing the initial memory usage of a thread from page size down to something a bit smaller
[05:20:04] <strcat> they increase overall memory usage in most applications
[05:20:14] <mark_edward> what does Rust use right now?
[05:20:14] <strcat> they fragment the heap too
[05:20:19] <strcat> mark_edward: segmented stacks
[05:20:35] *** Joins: aatch (aatch@moz-B437F499.pocketrent.com)
[05:21:11] <mark_edward> could you do a writeup about this? something like this could be greatly served by this. i love all the blogposts on developments in Rust
[05:21:12] <jdm> lkuper++
[05:21:29] <mark_edward> and i'd really like to understand the implications of the various options
[05:21:32] <dbaupp> aatch: http://www.ug.it.usyd.edu.au/~hwil7821/rust-bench/revert-ty.png
[05:21:43] <dbaupp> aatch: it looks better
[05:22:17] <lkuper> jdm: thanks.
[05:22:36] <aatch> dbaupp, hmm... still spikes quite high
[05:22:39] <dbaupp> aatch: although it doesn't reduce the final memory use as much as thought?
[05:22:47] <dbaupp> yeah
[05:22:56] <aatch> though I'm not sure if that's the compiler or my computer or the script
[05:22:59] <dbaupp> possibly a property of not optimising
[05:23:10] <dbaupp> so theres a lot of code going to the linker
[05:23:35] <aatch> dbaupp, good point
[05:24:39] <bjz_> rusti: struct HSV { h: float, s: float, v: float } struct HSVA { h: float, s: float, v: float, a: float } trait ToHSVA { fn to_hsva(self) -> HSVA; } impl ToHSVA for (HSV, float) { fn to_hsva(self) -> HSVA { unsafe { std::cast::transmute(self) } } }
[05:24:41] -rusti- ()
[05:25:14] <mark_edward> i wish the real rusti worked like IRC rusti. the encodable thing is a big hassle
[05:25:40] <bjz_> rusti: struct HSV { h: float, s: float, v: float } struct HSVA { h: float, s: float, v: float, a: float } trait ToHSVA { fn to_hsva(self) -> HSVA; } impl ToHSVA for (HSV, float) { fn to_hsva(self) -> HSVA { unsafe { std::cast::transmute(self) } } } let c = (HSV { h: 0f, s: 0f, v: 0f }, 0f); let hsva = c.to_hsva(); hsva
[05:25:41] -rusti- {h: 0, s: 0, v: 0, a: 0}
[05:25:47] <bjz_> rusti: struct HSV { h: float, s: float, v: float } struct HSVA { h: float, s: float, v: float, a: float } trait ToHSVA { fn to_hsva(self) -> HSVA; } impl ToHSVA for (HSV, float) { fn to_hsva(self) -> HSVA { unsafe { std::cast::transmute(self) } } } let c = (HSV { h: 0f, s: 0f, v: 0f }, 0f); let hsva = c.to_hsva(); c
[05:25:49] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/GVdA
[05:25:49] <strcat> mark_edward: irc rusti has no state though
[05:26:15] *** Joins: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net)
[05:26:19] <bjz_> weird
[05:26:21] <dbaupp> aatch: should I r+ that commit?
[05:26:21] <mark_edward> true, but it lets you make new struts and traits easy eough
[05:26:25] <dbaupp> aatch: (with a p?)
[05:26:28] <bjz_> shouldn't `c` be moved?
[05:26:29] <aatch> dbaupp, yes
[05:26:42] <aatch> bjz_, nope
[05:26:46] <bjz_> seeing as it takes `self` not `&self`?
[05:26:50] <aatch> it's implicitly copyable
[05:26:55] *** Quits: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[05:27:14] <strcat> bjz_: stuff is moved instead of copied if it has a) a destructor or b) &mut
[05:27:21] <strcat> Luqman: ah it's still broken >.<
[05:27:43] <strcat> Luqman: some tests implemented TyVisitor
[05:28:10] <aatch> dbaupp, my unscientific method of watching htop seems to suggest that the usage is back to "normal"
[05:28:18] <dbaupp> aatch: cool
[05:28:27] <dbaupp> aatch: the proof'll be in the graphs ;P
[05:29:07] <aatch> dbaupp, I'm trying another opt-run
[05:29:52] <bjz_> rusti: struct HSV { h: float, s: float, v: float } struct HSVA { h: float, s: float, v: float, a: float } trait ToHSVA { fn to_hsva(self) -> HSVA; } impl ToHSVA for (HSV, float) { fn to_hsva(self) -> HSVA { unsafe { std::cast::transmute(self) } } } fn to_hsva(hsv: HSV, a: float) -> HSVA { (hsv,a).to_hsva() )  let c = HSV { h: 0f, s: 0f, v: 0f }; let hsva = to_hsva(c, 0f); c
[05:29:53] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/GfEJ
[05:29:56] <Luqman> strcat: shouldn't be too hard to fix
[05:30:08] <strcat> Luqman: yeah I think it's fixed now
[05:30:11] <bjz_> rusti: struct HSV { h: float, s: float, v: float } struct HSVA { h: float, s: float, v: float, a: float } trait ToHSVA { fn to_hsva(self) -> HSVA; } impl ToHSVA for (HSV, float) { fn to_hsva(self) -> HSVA { unsafe { std::cast::transmute(self) } } } fn to_hsva(hsv: HSV, a: float) -> HSVA { (hsv,a).to_hsva() } let c = HSV { h: 0f, s: 0f, v: 0f }; let hsva = to_hsva(c, 0f); c
[05:30:13] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/HUiF
[05:30:48] <bjz_> I thought that would be moved too :/
[05:31:23] <aatch> dbaupp, ok, it's definately the script
[05:31:36] <bjz_> fn to_hsva(hsv: HSV, a: float) -> HSVA { unsafe { std::cast::transmute((hsv,a)) } } let c = HSV { h: 0f, s: 0f, v: 0f }; let hsva = to_hsva(c, 0f); c
[05:31:47] <bjz_> rusti: fn to_hsva(hsv: HSV, a: float) -> HSVA { unsafe { std::cast::transmute((hsv,a)) } } let c = HSV { h: 0f, s: 0f, v: 0f }; let hsva = to_hsva(c, 0f); c
[05:31:49] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/cGCS
[05:31:57] <aatch> I'm not sure why, but it seems to just suddenly spike in memory usage
[05:32:03] <aatch> but the rust process is fine
[05:32:10] <bjz_> rusti: struct HSV { h: float, s: float, v: float } struct HSVA { h: float, s: float, v: float, a: float }  fn to_hsva(hsv: HSV, a: float) -> HSVA { unsafe { std::cast::transmute((hsv,a)) } } let c = HSV { h: 0f, s: 0f, v: 0f }; let hsva = to_hsva(c, 0f); c
[05:32:12] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/XBcQ
[05:32:55] *** Joins: zz_kimundi (kimundi@moz-A8630360.dip0.t-ipconnect.de)
[05:32:59] <strcat> aatch: well, the linker is a separate process
[05:33:03] <strcat> aatch: that's why cgroups are nice
[05:33:17] *** zz_kimundi is now known as kimundi
[05:33:39] <bjz_> rusti: struct HSV<T> { h: T, s: T, v: T } struct HSVA<T> { h: T, s: T, v: T, a: T }  fn to_hsva<T>(hsv: HSV, a: T) -> HSVA { unsafe { std::cast::transmute((hsv,a)) } } let c = HSV { h: 0f, s: 0f, v: 0f }; let hsva = to_hsva(c, 0f); c
[05:33:41] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/SZGF
[05:33:58] <bjz_> rusti: struct HSV<T> { h: T, s: T, v: T } struct HSVA<T> { h: T, s: T, v: T, a: T }  fn to_hsva<T>(hsv: HSV<T>, a: T) -> HSVA { unsafe { std::cast::transmute((hsv,a)) } } let c = HSV { h: 0f, s: 0f, v: 0f }; let hsva = to_hsva(c, 0f); c
[05:33:59] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/TQFT
[05:34:21] <bjz_> rusti: struct HSV<T> { h: T, s: T, v: T } struct HSVA<T> { h: T, s: T, v: T, a: T }  fn to_hsva<T>(hsv: HSV<T>, a: T) -> HSVA<T> { unsafe { std::cast::transmute((hsv,a)) } } let c = HSV { h: 0f, s: 0f, v: 0f }; let _hsva = to_hsva(c, 0f); c
[05:34:23] -rusti- {h: 0, s: 0, v: 0}
[05:34:31] <bjz_> (sorry for the spam)
[05:34:36] <bjz_> (will stop)
[05:35:31] <Jesse> btw, rusti responds to private messages too :)
[05:35:48] <bjz_> ooh
[05:35:56] <sfackler> Is there anything holding https://github.com/mozilla/rust/issues/7597 back?
[05:36:51] <strcat> sfackler: well they can't really be made useful yet
[05:36:57] <strcat> and also I ran into rvalue bugs
[05:36:59] <strcat> so I just didn't bother
[05:37:12] <strcat> the method resolve bug needs to be fixed
[05:37:17] <strcat> before it's useful
[05:37:27] <Luqman> strcat: *** Error in `x86_64-unknown-linux-gnu/stage2/test/extratest-x86_64-unknown-linux-gnu': malloc(): memory corruption: 0x00007fd430216330 *** :(
[05:37:36] <strcat> Luqman: aw ;[
[05:37:44] <Luqman> on the plus side run-pass and libstd all passed
[05:38:43] <Luqman> test json::tests::test_decode_struct ... extratest-x86_64-apple-darwin(50033,0x10611a000) malloc: *** error for object 0x7fe6a4100f38: incorrect checksum for freed object - object was probably modified after being freed.
[05:38:44] <strcat> Luqman: could be from ~Trait with 'static
[05:38:46] <strcat> ;p
[05:38:48] *** Joins: pyrac (pyrac@moz-B0599561.w92-162.abo.wanadoo.fr)
[05:38:48] <strcat> oh
[05:38:50] <strcat> hrm
[05:38:58] *** Joins: mye (mye@moz-5EBA714.dip0.t-ipconnect.de)
[05:39:00] *** Quits: mye (mye@moz-5EBA714.dip0.t-ipconnect.de) (Quit: mye)
[05:39:14] *** Joins: mye (mye@moz-5EBA714.dip0.t-ipconnect.de)
[05:39:16] *** Quits: mye (mye@moz-5EBA714.dip0.t-ipconnect.de) (Quit: mye)
[05:40:26] <strcat> Luqman: well that's not good
[05:40:40] <strcat> I get this
[05:40:42] <strcat> *** Error in `x86_64-unknown-linux-gnu/stage2/test/extratest-x86_64-unknown-linux-gnu': free(): invalid next size (fast): 0x00007f680022c760 ***
[05:40:53] <strcat> from json tests
[05:42:13] * strcat tries valgrind
[05:43:15] <strcat> Luqman: something goes *really* wrong there
[05:43:32] <strcat> ==12329== Invalid write of size 8
[05:43:34] <strcat> ==12329==    at 0x910CBA: json..Json::_88ff7e956437c6d::glue_take_49529 (in /home/strcat/projects/rust/src/libextra/extra)
[05:43:36] <strcat> in
[05:43:38] <strcat> I get this==12329==    by 0x96076E: json::tests::test_read_object::_268de6fe839f7f7::_0$x2e7 (in /home/strcat/projects/rust/src/libextra/extra)
[05:43:41] <strcat> inside the for loop
[05:43:45] <strcat> inside mk_object
[05:44:42] <Luqman> lol result: FAILED. 504 passed; 1 failed; 25 ignored with valgrind
[05:44:59] <Luqman> (you can ignore that one failure since it's because something is already listening on port 8888)
[05:45:33] <strcat> Luqman: all from glue_take
[05:45:34] <strcat> ;\
[05:45:41] <strcat> a specific one
[05:45:54] <strcat> oh some are not glue_take
[05:45:59] *** Quits: seth (seth@moz-2C443A35.hsd1.co.comcast.net) (Input/output error)
[05:46:13] <strcat> but could be caused by it
[05:48:34] *** Quits: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Leaving...)
[05:50:41] <mark_edward> hew
[05:50:55] <mark_edward> Rust uses a lot of move operations by default right?
[05:51:26] *** Joins: joebobjoe (joebobjoe@55F2E07A.7F841963.2213276E.IP)
[05:51:29] <mark_edward> is there anything explaining how Rust does this? likefor both POD types and resource management types like ~[T] of hashmap?
[05:51:44] <mark_edward> because we don't define move constructors ala C++
[05:51:45] <strcat> if it has a destructor or &mut, it moves ownership when you do a shallow copy
[05:51:55] <Luqman> strcat: i've no idea right now and i think i'll just head to bed right now. i need to wake up at some reasonable time :P
[05:51:59] <strcat> mark_edward: no, there's nothing explaining low-level details like that
[05:52:00] <strcat> Luqman: cya
[05:52:41] <strcat> if you impl Drop for something the compiler adds a drop flag and calls the destructor once by zeroing it on moves
[05:53:11] <strcat> but the built-in cleanup for ~/~[] works without a drop flag
[05:53:12] <mark_edward> i see. 
[05:53:23] <strcat> and there's #[unsafe_no_drop_flag] to replicate that for other types
[05:53:40] *** Joins: SimonSapin (simon@moz-D0C2F181.zone2.bethere.co.uk)
[05:58:55] *** Quits: paulproteus (quassel@rose.makesad.us) (Ping timeout)
[06:00:58] *** Joins: paulproteus (quassel@moz-E86A3B42.makesad.us)
[06:01:09] <ross> is there a tutorial on using gdb to debug rust calling a C lib?
[06:01:59] <ross> I'm getting weird behavior and I'm trying to figure out if it's a bug in passing data to the library, or if I'm just misunderstanding something
[06:05:18] <ross> it's probably simple and I'm just not very good with gdb
[06:06:26] *** Quits: dwhyte (dwhyte@ED9190FB.B72E355F.7BF4A4B0.IP) (Client exited)
[06:08:00] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[06:09:44] *** Joins: dwhyte (dwhyte@ED9190FB.B72E355F.7BF4A4B0.IP)
[06:10:24] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[06:14:29] *** Quits: pyrac (pyrac@moz-B0599561.w92-162.abo.wanadoo.fr) (Quit: pyrac)
[06:15:32] *** Quits: dwhyte (dwhyte@ED9190FB.B72E355F.7BF4A4B0.IP) (Client exited)
[06:20:31] <dbaupp> aatch: with the trait visitor, the _contents methods aren't meant to be overwritten?
[06:20:51] <aatch> dbaupp, no, they just continue the traversal
[06:20:59] *** Joins: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com)
[06:21:20] <dbaupp> aatch: so I just override visit_item and then call visit_item_contents at the end?
[06:21:27] <aatch> dbaupp, yep
[06:21:29] <dbaupp> cool
[06:21:41] <aatch> it's the same pattern as before, just a little re-arranged
[06:21:46] <ross> I guess if it doesn't have symbols then it can't really do much huh
[06:21:56] <aatch> ideally you'd be able to call the overridden method
[06:22:02] <dbaupp> aatch: right
[06:22:27] <dbaupp> ross: you can compile with `-Z debug-info`
[06:22:45] <dbaupp> ross: (at least, it gives me on linux x64.)
[06:22:49] <dbaupp> *gives me symbols
[06:23:25] <dbaupp> (since when did rust's emacs mode give syntax information?)
[06:24:38] <ross> yeah that works
[06:25:11] <ross> but I mean I'm using a pre-packaged C lib that doesn't have symbols
[06:25:16] <ross> so it was silly for me to expect to step into it
[06:27:08] <dbaupp> aatch: gaah, this lint thing is going to require a whole rearchitecture :(
[06:27:25] <aatch> dbaupp, sorry :(
[06:27:45] <dbaupp> aatch: there's like 4 different things that make it hard
[06:28:18] <dbaupp> e.g. you can't make a visitor call a different one when recursing
[06:28:26] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[06:28:57] <aatch> dbaupp, sure you can, just store the other one in the visitor
[06:29:07] <doener> r? https://github.com/mozilla/rust/pull/7645
[06:29:11] <dbaupp> aatch: yeah, but not non-intrusively
[06:29:47] <dbaupp> aatch: as in, I want to have a generic visitor that modifies the behaviour of several others by blocking certain calls
[06:29:59] <doener> last holiday one, regular work starts again today :-/
[06:30:03] <dbaupp> aatch: (conditionally blocking them)
[06:30:19] <aatch> dbaupp, hmm... not sure how to deal with that...
[06:31:20] <dbaupp> aatch: yeah, it's fine (mostly)
[06:31:39] <dbaupp> aatch: I can just make the other visitors *not* recurse and let the parent manage it.
[06:32:43] *** Joins: fabiand (fabiand@moz-DDE1FFB.adsl.alicedsl.de)
[06:33:53] *** Quits: acrichto1 (acrichto@moz-B63D64BD.res.cmu.edu) (Quit: leaving)
[06:33:59] *** Quits: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca) (Quit: Leaving)
[06:34:00] *** Joins: acrichto (acrichto@moz-B63D64BD.res.cmu.edu)
[06:34:08] *** Quits: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Ping timeout)
[06:34:33] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[06:37:57] <dbaupp> aatch: hm, this is going to be annoying
[06:38:08] <dbaupp> aatch: it'd be nice if we could "copy" implementations
[06:38:23] <aatch> dbaupp, what do you mean?
[06:38:40] <dbaupp> aatch: I essentially need default methods where they're all empty
[06:39:04] <dbaupp> aatch: but since the default methods aren't, I have to actually write them all out.
[06:39:18] <aatch> dbaupp, ugh, yeah, that's annoying...
[06:39:47] <aatch> horray, I reduced the error count to a number that doesn't rustc to ice
[06:39:51] <aatch> 253
[06:40:16] <sfackler> having a syntax extension that allows you to scan over methods in a trait would be great
[06:40:28] <sfackler> some sort of compile-time reflection I guess
[06:40:50] <strcat> sfackler: syntax exts can't really do that
[06:40:56] <strcat> they take in tokens and output an AST
[06:40:59] <strcat> they're unaware of types
[06:41:53] <sfackler> isn't fmt! aware of types in some way?
[06:42:51] <aatch> sfackler, no
[06:42:56] <acrichto> sfackler: those kinds of syntax extensions/macros are implemented in the compiler itself (part of libsyntax) so it's hard to make user-defined ones (right now at least)
[06:43:25] <aatch> fmt! has no awareness of types, other than the types of the specifiers
[06:51:25] *** Joins: relistan (relistan@moz-2DE8112B.cable.virginmedia.com)
[06:59:05] <doomlord> https://gist.github.com/dobkeratops/5946737 <<< lifetime problem.. mutating an enum within arms matched on it
[07:03:44] <dbaupp> doomlord: do the flag thing `let should_modify = match *self { EmptyTile(ref x) => *x != *desiredValue, _ => false }; if should_modify { .. }`
[07:04:11] <doomlord> seems unavoidable ok.
[07:04:40] <doomlord> generating a flag is the only way to extract information about the type i guess
[07:05:17] <doomlord> .. compared to the manual method in C where you'd test the type independantly with a switch.
[07:05:24] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Leaving...)
[07:05:47] <doomlord> getting used to the differences imposed by safety / aliasing rules :)
[07:06:52] <dbaupp> aatch: http://ix.io/6yy/diff 
[07:07:13] <dbaupp> aatch: and that's not even converting any of the visitors to use it
[07:08:26] <aatch> dbaupp, :/
[07:09:00] <dbaupp> aatch: I'm either doing something wrong (highly likely), or the trait-visitor will require some modifications
[07:09:16] <aatch> dbaupp, ok, like what?
[07:09:22] <dbaupp> (and/or default methods get modified)
[07:09:26] <dbaupp> aatch: not really sure.
[07:09:39] <dbaupp> aatch: I'll have to think about what will make this easier
[07:09:56] <dbaupp> aatch: (although you did miss enum_def_contents... fixed :) )
[07:10:19] <aatch> ugh.
[07:10:33] <dbaupp> aatch: is this the only thing blocking it?
[07:10:43] <aatch> dbaupp, not even close
[07:10:48] <dbaupp> :(
[07:11:08] <aatch> I have a feeling I'm gonna have to re-write a tonne more visitors
[07:11:13] <dbaupp> yeah
[07:11:32] <aatch> This is a massive change, so I appreciate your help
[07:11:36] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[07:11:43] *** Quits: igl1 (igl@moz-FAB28512.adsl.alicedsl.de) (Ping timeout)
[07:11:45] <bjz> Luqman: ping
[07:11:46] <dbaupp> maybe we should collect some "data" on what they do, to see what the visitor api should look like
[07:11:54] *** Joins: igl (igl@moz-E5D24A9D.adsl.alicedsl.de)
[07:12:17] <aatch> dbaupp, well I based the current api on the old one.
[07:12:30] *** Quits: SimonSapin (simon@moz-D0C2F181.zone2.bethere.co.uk) (Ping timeout)
[07:12:32] <dbaupp> yeah, but there are a few differences
[07:12:49] <dbaupp> (e.g. not passing the visitor to call to the functions)
[07:14:03] <aatch> dbaupp, but that was done as a tuple anyway, so I just made it as if that tuple was `self`
[07:14:19] <dbaupp> yeah
[07:14:50] <dbaupp> hm
[07:14:58] <aatch> since if you want to use a second visitor, you have to pass it around in the environment slot anyway
[07:15:06] <dbaupp> not really
[07:15:13] <aatch> `(E, vt<E>)`
[07:15:28] <dbaupp> e.g. lint calls a visitor once, and then hands off to another one
[07:15:46] <dbaupp> (v.visit_expr)(self, stopping)
[07:16:03] <dbaupp> (where v and stopping are both vt<@mut Session> or something)
[07:17:35] <kaeso> is bors currently not running or just in a big backlog?
[07:17:37] <dbaupp> also, not being able to substitute other visitors like you can with the struct, Visitor {override, a, few, .. some_other_visitor }
[07:17:53] <dbaupp> kaeso: possibly both
[07:17:55] *** Quits: relistan (relistan@moz-2DE8112B.cable.virginmedia.com) (Quit: relistan)
[07:18:10] <kaeso> aye
[07:18:12] <dbaupp> kaeso: it says that it's pending on 2 pull requests :/
[07:18:24] <aatch> dbaupp, not a good sign...
[07:18:39] <dbaupp> and one of them has already passed on the builbots
[07:18:40] <kaeso> dbaupp: is there a bors status page?
[07:18:44] <dbaupp> http://buildbot.rust-lang.org/bors/bors.html
[07:18:55] <kaeso> ah, thanks
[07:19:37] <bjz> dbaupp strcat: how do I do: let mx = [(*self).r, (*self).g, (*self).b].max();
[07:19:40] *** Joins: vk (vk@moz-389FEE13.hsd1.ca.comcast.net)
[07:19:50] <strcat> bjz: .iter().max
[07:20:10] <bjz> it gave me an error about Options
[07:20:17] <dbaupp> bjz: erm, self.r.max(self.g.max(self.b)) is probably more efficient
[07:20:24] <bjz> :(
[07:20:36] <bjz> damn
[07:20:38] <dbaupp> bjz: iter.max() -> Option<T>, None if the iterator is empty
[07:20:50] <dbaupp> bjz: so .iter().max().unwrap()
[07:21:42] <bjz> surely we could make a .max for tuples?
[07:22:17] <bjz> it kinda sucks we can't have a generic max/min like D does
[07:22:19] <dbaupp> aatch: ok, just doing some grepping: it seems that lint is the only thing that does `Visitor { foo, .. something_other_than_default_visitor }`
[07:22:25] <bjz> with varargs
[07:22:32] <aatch> dbaupp, well that's good
[07:22:37] <dbaupp> aatch: yeah
[07:22:42] <bjz> :(
[07:23:08] <dbaupp> bjz: eventually, [foo, bar, baz].max() will work
[07:23:11] <aatch> Yeah, one of the main problems with the old one is that heap closures and borrowed pointers really don't mix
[07:23:43] <dbaupp> yeah, moving away from it seems like it's fairly important
[07:23:44] *** Quits: Voomer (Voomer@moz-E97E8EB7.br.br.cox.net) (Connection reset by peer)
[07:23:45] *** Joins: Voomer (Voomer@moz-E97E8EB7.br.br.cox.net)
[07:23:59] <acrichto> strcat: it looks like #7595 passed all the tests, although bors looks like it got confused and didn't merge it. Once 7497 finishes testing you could probably manually merge it
[07:24:07] <dbaupp> just, getting the new api to be nice will take a bit of work
[07:24:23] <bjz> dbaupp: how?
[07:24:25] <shachaf> Are there any plans of getting :t in rusti?
[07:24:28] <shachaf> (To ask for a type.)
[07:24:45] <dbaupp> bjz: if when we have an Iterable trait
[07:24:52] <acrichto> shachaf: you could open an issue :)
[07:25:02] <bjz> dbaupp: would that be more efficient?
[07:25:03] <dbaupp> bjz: although .max() might not be one of the methods added
[07:25:14] <bjz> :(
[07:25:38] <dbaupp> bjz: it should compile to something nice, I guess. (and just thinking about it, [].iter().max().unwrap() probably optimises well anyway)
[07:25:43] <shachaf> acrichto: So far I've gotten by with getting other people to open issues for me!
[07:26:07] <shachaf> But I suppose I'll have to start doing it myself sometime.
[07:26:09] <acrichto> shachaf: feel free to, it's super-easy and no harm done at all
[07:26:09] <dbaupp> acrichto: you've done significant work on middle::lint right?
[07:26:13] <acrichto> dbaupp: yes
[07:26:43] <dbaupp> acrichto: ok, do you happen to know why item_stopping_visitor stops on methods?
[07:26:46] *** Quits: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP) (Ping timeout)
[07:27:09] <acrichto> dbaupp: methods can change the lint attributes
[07:27:26] <dbaupp> acrichto: but normal functions?
[07:27:34] <acrichto> dbaupp: they also can
[07:27:37] <dbaupp> or are they included in items?
[07:27:48] <acrichto> both have lists of attributes
[07:27:58] <acrichto> methods aren't items, though
[07:28:50] <aatch> (which is why you can't expand macros to them)
[07:29:42] <shachaf> Do Rust traits have an equivalent of e.g. class Default a where def :: a?
[07:29:49] <dbaupp> acrichto: right
[07:29:55] <dbaupp> shachaf: not yet
[07:30:07] <aatch> Ok, I now have a use for needing multiple lifetime parameters on a struct
[07:30:12] <dbaupp> shachaf: there's plans for it (they're called "associated items")
[07:30:43] <shachaf> Hmm, OK.
[07:31:12] <aatch> where I need a borrowed pointer to data with a lifetime and that data has a different lifetime to the borrow 
[07:31:13] <dbaupp> shachaf: but people don't seem to like the syntax `Default::def` to create a thing of type T, preferring T::def (among other objections)
[07:31:25] <mark_edward> the way to dump llvm is `rustc blah.rs --emit-llvm -S` right?
[07:31:34] <mark_edward> *LLVM IR
[07:31:36] <shachaf> Hmm, but you can do trait Foo { fn foo() -> Self; }
[07:31:42] <dbaupp> shachaf: yeah
[07:32:14] <dbaupp> shachaf: http://smallcultfollowing.com/babysteps/blog/2013/04/02/associated-items/, http://smallcultfollowing.com/babysteps/blog/2013/04/03/associated-items-continued/ and http://blog.pnkfx.org/blog/2013/04/22/designing-syntax-for-associated-items-in-rust/, if you're interested
[07:32:22] <dbaupp> mark_edward: yes
[07:32:56] <mark_edward> is there  way to get it to make the function names, etc recognizable?
[07:33:00] <mark_edward> the symbols i mean
[07:33:09] <dbaupp> aatch: it doesn't work to have the lifetime of the borrowed pointer the same?
[07:33:21] <aatch> dbaupp, it works, but ties them together
[07:33:24] <shachaf> dbaupp: Hmm, OK.
[07:33:42] <aatch> so you end up with overlapping borrows that shouldn't exist
[07:33:45] <dbaupp> mark_edward: #[no_mangle]
[07:34:07] <mark_edward> dbaupp: where would i put that?
[07:34:29] <shachaf> What about an equivalent of higher-kinded classes?
[07:34:31] <dbaupp> mark_edward: on whatever functions you want to have recognisable names
[07:34:33] <shachaf> I guess I can try that myself.
[07:34:38] <dbaupp> shachaf: nope, not really
[07:34:46] <mark_edward> oh... that'd be all of them...
[07:35:04] <dbaupp> mark_edward: the mangled names do include their normal name
[07:35:15] <mark_edward> i don't get it. gcc -g /clang++ -g do what i want for C/C++ and gdb/disass
[07:35:26] <dbaupp> shachaf: it's a "we'd except a patch" feature, I think
[07:35:41] <aatch> accept*
[07:35:42] <dbaupp> mark_edward: I don't know
[07:35:56] <mark_edward> hm.
[07:36:06] <dbaupp> shachaf: but you can sort-of hack something resembling it, slightly
[07:36:16] <aatch> I am solving my problem with closures
[07:36:19] <dbaupp> shachaf: except the type-inference falls down quickly
[07:36:24] <aatch> yay functional programming!
[07:37:39] <dbaupp> shachaf: e.g. Functor http://www.reddit.com/r/rust/comments/1a57pw/haskeller_playing_with_rust_a_question_about/c8ut2ux
[07:37:55] <aatch> (The visitor that builds the map now calls a closure to add the node_id/node pair)
[07:38:09] <dbaupp> shachaf: (it's a *huge* hack.)
[07:38:11] *** Joins: quvarxa (chatzilla@moz-978E4C31.static.tpgi.com.au)
[07:38:41] <shachaf> dbaupp: Indeed.
[07:38:44] <mark_edward> dbaupp: when you do --emit-llvm does -O affect what you get?
[07:38:48] <shachaf> What about rank-2 types?
[07:38:49] <dbaupp> mark_edward: yes
[07:38:51] <shachaf> (That last one is a joke.)
[07:38:56] <dbaupp> heh
[07:40:47] <strcat> ugh
[07:40:51] <strcat> stupid memory corruption bug
[07:40:53] <strcat> it better be the last
[07:41:02] <strcat> I'll be happy when I can use ~ with ffi
[07:41:41] <dbaupp> I guess it won't have much effect on compiler speed; since the compiler doesn't use ~ much at all :(
[07:41:47] <aatch> Yet
[07:41:53] * dbaupp nominates aatch to remove all @'s
[07:42:04] <aatch> dbaupp, working on it
[07:42:09] <dbaupp> aatch: yup
[07:42:16] * strcat hates this bug
[07:42:47] <strcat> it's worse than the others because it doesn't happen *everywhere*]
[07:42:57] <strcat> really not obvious what could be wrong here.
[07:44:17] <strcat> maybe ~fn, dunno
[07:47:31] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[07:48:38] <hoelzro> happy 0.7 release! (/me was on holiday)
[07:50:10] *** Joins: Ms2ger (Ms2ger@moz-E9883900.access.telenet.be)
[07:51:26] *** Quits: joebobjoe (joebobjoe@55F2E07A.7F841963.2213276E.IP) (Quit: Textual IRC Client: www.textualapp.com)
[07:53:21] *** Quits: ross (ross@moz-8A84103E.br.br.cox.net) (Quit: )
[07:56:58] <hoelzro> is there a summary of what's changed between 0.6 and 0.7 avaiable somewhere?
[07:57:10] <strcat> RELEASES.txt in the repo
[07:59:02] <aatch> Ok, working around the issue with unsafe code. yay?
[07:59:04] <hoelzro> heh
[07:59:32] <shachaf> Does Rust have any sort of general existentials? I know there's the trait-as-object thing.
[07:59:48] <shachaf> Can you make something like struct Foo<A> { x: A, f: ~fn(y: A) -> int } except existential instead of universal?
[07:59:59] <shachaf> (So the type A is hidden.)
[08:00:51] <aatch> shachaf, not really
[08:03:41] *** Quits: vk (vk@moz-389FEE13.hsd1.ca.comcast.net) (Quit: vk)
[08:05:04] <shachaf> Hmm, OK.
[08:06:35] <strcat> oh good a simple failing test case
[08:06:42] <strcat> simple-ish
[08:06:44] <strcat> ;p
[08:12:39] <Ms2ger> Encode existentials as universals? :)
[08:13:03] <shachaf> Ms2ger: You need rank-2 for that!
[08:13:44] <Ms2ger> Oh, rust doesn't allow arbitrary rank? :)
[08:13:49] <strcat> maybe I'm copying wrong...
[08:13:56] *** Joins: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP)
[08:14:09] * strcat hates the take glue
[08:14:13] <doomlord_> this "mutate tiled array" seemed a lot harder to write ... but it wouldn't be efficient to change individual values anyway so its no great loss..
[08:14:29] <shachaf> Ms2ger: Well, given that it compiles polymorphic code by instantiating it at a particular type...
[08:14:39] <doomlord_> .. any efficient code would batch up changes and apply them en masse
[08:14:52] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[08:15:15] <doomlord_> It was surprising how different this was to write though, this is the furthest i've seen the langage veer from a C/C++ mindset
[08:16:06] *** Joins: kimundi_ (kimundi@moz-D11055B1.dip0.t-ipconnect.de)
[08:16:57] *** Joins: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[08:17:33] *** Quits: kimundi (kimundi@moz-A8630360.dip0.t-ipconnect.de) (Ping timeout)
[08:17:33] *** kimundi_ is now known as kimundi
[08:18:44] <bjz> is bors working atm?
[08:18:47] *** Quits: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Ping timeout)
[08:19:04] <strcat> I think so
[08:19:06] <bjz> been waiting for this: https://github.com/mozilla/rust/pull/7635
[08:19:08] <aatch> finally!
[08:19:22] <bjz> (not that it's very important)
[08:19:29] <strcat> it failed to merge something
[08:19:36] <bjz> (in the grand scheme of things)
[08:19:43] <strcat> https://github.com/mozilla/rust/pull/7595 it passed
[08:19:45] <strcat> :S
[08:20:01] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[08:20:34] <aatch> Yay, back to my ~200 errors in rustc
[08:20:41] *** Joins: robert (robertknig@moz-17A2B1B0.range81-159.btcentralplus.com)
[08:20:43] <strcat> so take glue is somehow broken
[08:20:44] <strcat> for vectors
[08:21:00] * strcat has no idea how :|
[08:21:25] <strcat> hm
[08:21:27] <strcat> or just for ~T
[08:21:56] <strcat> aha just for ~T
[08:22:25] *** Quits: roo (jesse.rudo@moz-B7585E4C.dynamic.ip.windstream.net) (Ping timeout)
[08:23:01] * strcat thinks he knows what's wrong
[08:24:32] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Leaving...)
[08:24:48] <strcat> aatch: how's that snapshot going? ;p
[08:25:02] <aatch> I completely forgot.
[08:25:21] <strcat> aatch: I think this could be the amend fixing ~ header removal... we'll see
[08:25:21] <aatch> I think that bot is broken
[08:25:23] <strcat> :0
[08:25:47] <aatch> since it actually cancelled it at 10 hrs at one point
[08:25:54] <aatch> s/it/I/
[08:26:07] <strcat> just try again
[08:27:52] <aatch> strcat, this would be the 5th time
[08:28:00] <strcat> oh
[08:28:02] <aatch> theres only 1 bot for it
[08:29:44] <strcat> ok this stupid bot is taking forever
[08:29:47] <strcat> the longest 200s ever
[08:30:44] *** Quits: jared (jared@moz-EE5D17ED.ph.ph.cox.net) (Quit: WeeChat 0.3.8)
[08:31:11] <aatch> https://github.com/mozilla/rust/issues/7647
[08:31:33] *** Joins: CarpNet (ac@moz-FD24B77.sohonet.co.uk)
[08:32:50] <aatch> And this is why I need multiple lifetime params: https://github.com/Aatch/rust/blob/trait-visitor/src/libsyntax/ast_map.rs#L117
[08:33:08] <cmr> aatch: what do you want benched?
[08:33:20] <aatch> cmr, oh, my current PR
[08:33:27] *** Joins: jamil_1 (quassel@467FDE5C.C74DB0B7.E86700E.IP)
[08:33:42] <aatch> reverting the @Ty change
[08:33:43] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[08:33:55] <bjz> doomlord_ doomlord: hoya
[08:34:02] <doomlord> hi
[08:34:20] <bjz> are you working on graphics stuff with rust?
[08:34:54] <doomlord> starting to,
[08:35:19] <bjz> I'm wondering if you might be interested in helping out with some maths
[08:35:40] <bjz> octrees, quadtrees, intersections
[08:35:55] <bjz> color conversions
[08:36:09] <doomlord> i've just done myself a vector maths library and i'm trying approaches for various datastructures (tiled arrays etc) for that 
[08:36:19] <bjz> ahh, hehe
[08:36:26] <bjz> on github?
[08:36:34] <doomlord> here's my situation:-
[08:36:48] <mark_edward> doomlord: i want to be game/graphics programmer like you
[08:36:51] <doomlord> i had the ambition of doing an indie game iOS/android - i have engine code for that
[08:36:57] <doomlord> all C++.
[08:36:58] <mark_edward> how did you get into it?
[08:37:15] <bjz> (I currently have a maths lib, and am in need of some help from more experienced folks)
[08:37:23] <bjz> doomlord: neat
[08:37:27] <doomlord> mark_edward, years ago, i got into it in the ps1 days, i grew up on the amiga
[08:37:48] <mark_edward> did/do you work professionally in the field?
[08:37:55] <bjz> doomlord: do you have code available? I'm interested to see your approach
[08:38:00] <doomlord> did. not now. i might take another job later
[08:38:15] <doomlord> bjz, i can share the rust i'm writing sure, as really i'm learning..
[08:38:41] <doomlord> ... i've just run into differences in approach from the pointer system..
[08:38:47] <bjz> https://github.com/bjz/lmath-rs
[08:39:16] *** Quits: quvarxa (chatzilla@moz-978E4C31.static.tpgi.com.au) (Ping timeout)
[08:39:20] <bjz> still lots to do
[08:39:24] <bjz> ok, brb
[08:39:28] <doomlord> well what makes me hesitate with rust is it will defienitely stall my efforts to get a game out
[08:39:28] *** Joins: quvarxa (chatzilla@moz-978E4C31.static.tpgi.com.au)
[08:39:41] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Leaving...)
[08:39:54] <doomlord> but its generally very interesting, i like the language alot
[08:40:47] <Seldaek> cmr: regarding your last status update, I'm not sure what the node_id is, but couldn't it be used for caching ultimately so you only rebuild docs for files that got modified or something and know which nodes came from where?
[08:40:58] <mark_edward> have you seen q3 and rust SDL?
[08:41:04] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[08:41:04] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/mybQCA
[08:41:04] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[08:41:10] *** Quits: jamil_1 (quassel@467FDE5C.C74DB0B7.E86700E.IP) (Connection reset by peer)
[08:41:23] <cmr> Seldaek: Unfortunately not, they change as soon as any edit is made
[08:41:31] <doomlord> i have tried the glut bindings a bit
[08:41:58] <doomlord> i see there's glfw aswell, and i want to try the sdl bindings too
[08:42:00] <Seldaek> cmr: so it could still be used for caching no? Unless the chances for conflicts are really too high
[08:42:12] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[08:42:12] <ghrust> 01[13rust01] 15thestinger pushed 2 new commits to 06master: 02http://git.io/tuVPXg
[08:42:12] <ghrust> 13rust/06master 14641aec7 15Daniel Micay: remove some method resolve workarounds
[08:42:12] <ghrust> 13rust/06master 1444770ae 15Daniel Micay: Merge pull request #7595 from thestinger/iterator...
[08:42:13] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[08:42:19] <strcat> stupid bors
[08:42:30] <cmr> Seldaek: if you add or remove anything, every node_id changes
[08:42:36] <strcat> looks like github was at fault, not bors
[08:42:42] <cmr> (well, half of them on average)
[08:42:47] <strcat> it did a 500 error the first 3 times I hit that button
[08:42:48] <strcat> ;\
[08:43:02] <Seldaek> cmr: ah ok every node does.. that'd be worth fixing IMO but I have no idea how the code looks
[08:43:19] <aatch> Seldaek, not possible
[08:43:29] <Seldaek> alright then :)
[08:43:30] <aatch> Seldaek, it's just an incrementing counter
[08:43:32] <cmr> Seldaek: well node_id is really just an internal detail for the ast
[08:43:42] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[08:43:44] <Seldaek> ok I see
[08:43:49] <bjz> doomlord: back
[08:43:55] <doomlord> hi
[08:43:57] <strcat> I think I finally succeeded
[08:43:57] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[08:43:57] <ghrust> 01[13rust01] 15bors merged 06master into 06auto: 02http://git.io/tuVPXg
[08:43:57] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[08:44:00] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[08:44:00] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/OhiUBA
[08:44:00] <ghrust> 13rust/06auto 14ae7d7d2 15James Miller: Revert "De-share ast::Ty"...
[08:44:00] <ghrust> 13rust/06auto 14eef8a18 15bors: auto merge of #7644 : Aatch/rust/syntax-deshare, r=huonw...
[08:44:01] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[08:44:15] <bjz> doomlord: what makes you hesitate? (I can think of a quite a few reasons)
[08:44:23] <doomlord> iOS support
[08:44:32] <strcat> I'm 80% sure I broke ~Trait with a 'static bound but at this point I don't really care
[08:44:35] <strcat> it has no tests
[08:44:35] <doomlord> i coulnd't get rust working on iOS when i tried
[08:44:37] <strcat> ;p
[08:44:47] <mark_edward> doomlord: will you support linux?
[08:44:48] <cmr> "If there are no tests, it's broken"
[08:44:53] * strcat doesn't know if it ever worked
[08:44:57] <cmr> exactly :)
[08:45:02] <mark_edward> i would pay for good indo games that dont make me boot into windows
[08:45:04] <strcat> cmr: well I'll try fixing it later if I broke it + adding tests
[08:45:06] <doomlord> my current c++ codebase is iOS/android/linux/windows
[08:45:17] <strcat> -        let llty = type_of(bcx.ccx(), src_ty);
[08:45:19] <strcat> +        let llty = type_of(bcx.ccx(), body_datum.ty);
[08:45:21] <strcat> seems to be the last fix I needed
[08:45:25] <strcat> a silly mistake.
[08:45:43] <strcat> I just auticomplete the wrong thing because I'm lazy
[08:45:48] <strcat> autocompleted*
[08:45:49] <mark_edward> doomlord: do you have a ggithub account?
[08:45:56] <bjz> mark_edward: with the humble bundle and all, that seems to be more of a trend
[08:45:56] <strcat> ty<tab>, ship it!
[08:45:58] <strcat> ;p
[08:46:08] <doomlord> another reason for hesitating is:-   everyone else in the games industry uses C++ - and has moved to C++/C# , whiich might close off the opportunity to get rust in there
[08:46:15] <cmr> strcat: did it end up being a big perf win?
[08:46:24] <strcat> cmr: dunno, don't really care
[08:46:25] <mark_edward> bjz: true, it is comming. THE YEAR OF THE LINUX DESKTOP
[08:46:28] <doomlord> eg they do inhouse tools in C# now, and sometimes high level game code
[08:46:40] <doomlord> i am not touching C#
[08:46:44] <mark_edward> but rust can come as a better C# replacement
[08:46:48] <strcat> cmr: I know how much it reduces allocations by so.... ;p
[08:46:52] <cmr> mark_edward: eh? you mean c++ :p
[08:46:58] <bjz> mark_edward: I don't think that's really the case, but it's getting better
[08:46:59] <cmr> strcat: yeah
[08:47:05] <mark_edward> it can do both!
[08:47:09] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[08:47:09] <doomlord> i would like to move from C++ to rust, since it keeps everything in the same environment.. people using C# have a mix of C#+C++
[08:47:10] <strcat> cmr: I made a toy benchmark where it reduced memory usage by 75%
[08:47:13] <mark_edward> just need a lot morelibraries
[08:47:14] <strcat> cmr: but I knew it would in advance
[08:47:26] <strcat> just allocating a million (int, int)
[08:47:31] <doomlord> mark_edward,  yes but i dont put much there, i will put some of my early rust work on..
[08:47:35] *** Joins: relistan (relistan@A7E4EF66.4C1F25E9.4BA0249.IP)
[08:47:50] <mark_edward> ok cool, i'd love to see some of what you're willing to share
[08:47:51] <bjz> mark_edward: that's what I'm trying to do
[08:47:56] <bjz> mark_edward: more libs
[08:48:12] <mark_edward> how did languages like Python and Java and C# get such HUGE standard libs
[08:48:21] <doomlord> basically if i dive into rust.. i'm potentially distancing myself from mainstream work
[08:48:23] <cmr> mark_edward: time, lots of developers
[08:48:25] <mark_edward> is it just a question of funding?
[08:48:35] <strcat> Go didn't take much time to get a nice stdlib
[08:48:39] <bjz> doomlord: yup, that is a concern
[08:48:54] <aatch> strcat, but they had Google behind them...
[08:48:56] <mark_edward> strcat: but they had pretty big resources at their disposal right?
[08:48:58] <strcat> although it depends on what you mean by "nice"
[08:48:59] <doomlord> there's a lot of subtelties to learn in a langaue to truly master it
[08:49:00] <cmr> didn't Go emerge fully formed, straight out of the depths of Rob Pike himself?
[08:49:22] <mark_edward> i'd donate to Mozilla for more Rust library development if i could
[08:49:28] <mark_edward> as well as try and write stuff myself
[08:49:31] <cmr> mark_edward: donate your time :)
[08:49:35] <strcat> it has really nice crypto/networking, but hardly any data structures and no iterators
[08:49:41] <bjz> cmr: that's because they did lots of work in secret before
[08:49:57] <mark_edward> cmr: I'm not sure how much my time is worth. i'm not exactly a rockstar programmer
[08:50:00] <aatch> doomlord, and the issue for Rust is that those subtlies are still changing
[08:50:03] <bjz> cmr: Mozilla wears its projects on its sleeve
[08:50:14] <bjz> aatch: agreed
[08:50:25] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[08:50:33] <aatch> mark_edward, you don't have to do big flashy things to help.
[08:50:42] <strcat> cmr: Go is much less ambitious, it's a smaller language
[08:50:47] <aatch> filling in stuff that's missing, fixing bugs
[08:50:51] <strcat> no generics, all memory is gc'ed or on the stack
[08:50:58] <mark_edward> true.
[08:50:59] <strcat> no attempt to solve the data race issue
[08:51:08] <strcat> they wanted to ship something useful quickly
[08:51:13] <strcat> and they did
[08:51:30] <doomlord> strange how rust & go are mentioned together and they are really different
[08:51:33] <mark_edward> maybe a compression library is within my reach? i'll try and take a look at zlib, bzip2, and lzma, and see if i could do any of that
[08:51:42] <cmr> mark_edward: yes *please*
[08:51:52] <strcat> well if you really want it native
[08:52:04] <strcat> there are zlib/snappy/lz4 bindings
[08:52:20] <cmr> although the lz4 ones are buried in the depths of one of my repos
[08:52:36] <bjz> strcat: and with all due respect to the Rust devs, there is a truck load of experience on the Go Team
[08:52:52] <strcat> their regexp lib is written by the re2 author
[08:52:54] <strcat> ;p
[08:52:56] <strcat> so..
[08:53:11] <Ms2ger> doomlord, both new languages backed by browser vendors? :)
[08:53:14] <cmr> mark_edward: bindings to http://tukaani.org/xz/ would be super sweet too, as would a unified Compressor/Decompressor trait
[08:53:16] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[08:53:19] <strcat> aatch: http://buildbot.rust-lang.org/builders/auto-win-32-nopt/builds/320/steps/compile/logs/stdio weird
[08:53:24] <strcat> wat.
[08:53:28] <aatch> dbaupp, just letting you know that I'm keeping my branch rebased against the current master to try to avoid having too many conflicts.
[08:53:29] <doomlord> heh ok
[08:53:49] <aatch> strcat, WAT
[08:54:05] <mark_edward> cmr: i'd love to do something like that
[08:54:16] <strcat> aatch: https://github.com/mozilla/rust/pull/7605 r? it works
[08:54:20] <bjz> Ms2ger: I highly doubt Google will be doing V8 in Go any time soon
[08:54:28] *** Joins: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[08:54:33] <strcat> aatch: wait sorry
[08:54:34] *** Quits: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP) (Connection reset by peer)
[08:54:35] <strcat> aatch: need to push
[08:54:35] *** Joins: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[08:54:42] <Ms2ger> bjz, I don't see us doing SM in Rust either :)
[08:55:00] <strcat> aatch: ok *now* it's good to go ;p
[08:55:10] <doomlord> bjz r.e. vector maths,  i'll pastebin my vec/matrix types.. they're no where near complete, but have some issues of personal preference for me .. i like to have matrices that are collections of axis vectors
[08:55:42] <doomlord> i haven't parameterized it as much as is possible in C++ either, and want to change it still here
[08:55:58] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[08:55:58] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14eef8a18 to 1444770ae: 02http://git.io/N3iJvQ
[08:55:58] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[08:56:01] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[08:56:01] <ghrust> 01[13rust01] 15bors pushed 6 new commits to 06auto: 02http://git.io/Px-kXw
[08:56:01] <ghrust> 13rust/06auto 146e67701 15Fedor Indutny: libc: fix MAP_ANON value on linux
[08:56:01] <ghrust> 13rust/06auto 141c56046 15Fedor Indutny: libc: add _SC_* consts for non-mips linux too...
[08:56:02] <ghrust> 13rust/06auto 14822dc5f 15Fedor Indutny: libc: VirtualAlloc and FileMapping bindings
[08:56:04] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[08:56:08] <jensnockert> strcat: \o/
[08:56:11] <bjz> doomlord: I use axis vectors too
[08:56:14] <doomlord> also i just discovered you CAN deestructure tuples in function arguemnts ..  which has me tempted to try it all with tuples 
[08:56:19] <strcat> jensnockert: yeah it was... a huge pain
[08:56:21] <strcat> ;p
[08:56:29] * jensnockert hugs strcat.
[08:56:38] <strcat> Luqman helped too :)
[08:56:40] <indutny> heh
[08:56:43] <indutny> again :)
[08:56:45] * jensnockert hugs Luqman too.
[08:56:45] * strcat did most though ;p
[08:56:49] <doomlord> ok great.. i have a Matrix3<V>  .. Matrix4<V>  {   ax:V,ay:V,az:V,aw:V } ... that sort of thing
[08:56:53] * jensnockert hugs strcat a bit tighter.
[08:57:04] <bjz> doomlord: that's what I do
[08:57:07] <doomlord> i was playing with how you can express them as traits too, which is a little different to c++
[08:57:09] <doomlord> ok great
[08:57:33] <aatch> state of my branch: 98 changed files with 1,923 additions and 1,376 deletions. 
[08:57:57] <strcat> jensnockert: http://ix.io/6yE here's 'let x = ~5;' now
[08:58:07] <bjz> doomlord: the issue with destructuring is you can't destructure the self arg
[08:58:09] <jensnockert> strcat: Would that mean one can transmute a ~[u8] slice to a [u8, ..n] ?
[08:58:19] <strcat> jensnockert: no, it's only for non-managed ~T atm
[08:58:22] <strcat> I haven't done vectors 
[08:58:24] <strcat> or ~fn
[08:58:30] <jensnockert> strcat: Ah.
[08:58:35] <jensnockert> I still like it though.
[08:59:04] <cmr> Isn't the length of a ~[] stored on the other side of the pointer?
[08:59:07] * cmr doesn't know
[08:59:22] *** Quits: robert (robertknig@moz-17A2B1B0.range81-159.btcentralplus.com) (Ping timeout)
[08:59:25] <aatch> cmr, yeah, but it's more complicated than that
[08:59:27] <strcat> jensnockert: let x = ~5; now compiles to a call to malloc(8), a branch + abort on null, and a free at end of scope (inside a branch, since it sometimes has to call drop glue)
[08:59:32] <aatch> (motto of trans)
[08:59:39] <strcat> jensnockert: so it's FFI-compatible now.
[08:59:43] <jensnockert> Is it just me btw, or is transmute used more often in rust than as?
[08:59:48] <strcat> if something returns a malloc'ed struct, you can use ~Foo
[08:59:49] <jensnockert> strcat: That's awesome.
[08:59:57] <bjz> doomlord: I run into lots of code duplication problems
[09:00:09] <strcat> jensnockert: it was worth the hours of debugging ;p
[09:00:18] <bjz> doomlord: because we can't parameterise over consts
[09:00:19] <strcat> jensnockert: and hey, 75% reduced mem usage for ~int and ~(int, int)
[09:00:21] <strcat> ;p
[09:00:37] <strcat> \o/
[09:00:45] <jensnockert> strcat: Nice.
[09:01:38] <aatch> strcat, there should also be a gain (although minor) from it not needing to lots of +32 to the pointer to borrow
[09:01:39] <bjz> doomlord: I wish we had better CTFE. I've tried using macros, but it tangled everything up
[09:01:41] <doomlord> bjz, right.. i've just been doing some cases to mimick std::array<T,N>   array2, array4, array8 .. for my tiled 2d array attempt
[09:01:59] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[09:02:04] <aatch> borrowing a ~ should now be a no-op
[09:02:08] <doomlord> i was just starting to do quadtrees, octrees with array2x2, array2x2x2 ... i wont do every case :)
[09:02:17] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[09:02:31] <jensnockert> aatch: As it should be! \o/
[09:02:39] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[09:02:50] <doomlord> a load of cut paste that will be cleaned up if rust gets ints in the type system. i wont need every N ..
[09:02:52] <aatch> at runtime, &T == *T == ~T
[09:03:25] *** Joins: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk)
[09:03:26] <doomlord> bjz i was writing an FBX importer in C++, i might try and convert that to rust
[09:03:50] <doomlord> FBX importer not using the autodesk SDK, so i could use it in opensource projects and in my own proprietary apps
[09:04:25] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[09:04:31] <strcat> jensnockert: I did make things a bit more complicated since now there's an allocator for unique ~fn, an allocator for unique ~[]
[09:04:43] <strcat> and unique and managed-unique have split code paths everywhere, since managed-unique has headers
[09:04:45] <strcat> but....
[09:04:47] <strcat> it works!
[09:04:49] <strcat> and that's what counts.
[09:05:15] <aatch> strcat, you should add a test that relies on them being there.
[09:05:19] <jensnockert> Oh, wellâ€¦ I am sure that will be fixed later!
[09:05:27] <aatch> not bing there
[09:05:28] <jensnockert> If fixableâ€¦
[09:05:31] <aatch> being
[09:05:35] * aatch is tired
[09:05:38] <bjz> doomlord: I like the idea of opensourcing components of a game project
[09:05:56] <jensnockert> Meh, I should fix my numerics PR, cmr is getting restless.
[09:06:08] <cmr> which one is that?
[09:06:14] <strcat> I really want to remove ~[] headers but I need a snapshot with contains_managed and the silly bot went on vacation
[09:06:18] *** Quits: busylizzy (lisa@85228838.12D0DC84.211374C4.IP) (Ping timeout)
[09:06:23] <doomlord> https://gist.github.com/dobkeratops/5947345 <<< here's my work in progress matrix stuff... i was just toying with some ideas using traits
[09:06:26] <cmr> I just went through the whole queue yesterday to make sure failures were actually failures
[09:06:28] <bjz> jensnockert: numerics!
[09:06:46] <cmr> bors is a bit colorblind, marking things bad when they should be stale
[09:07:25] <doomlord> eg creating a trait for a matrix, and i could later expose other transformation representations through it (eg quaternion + centre, scaling .. )
[09:07:40] *** Joins: busylizzy (lisa@85228838.12D0DC84.211374C4.IP)
[09:07:44] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[09:07:55] <bjz> doomlord: ahh, interesting
[09:08:09] <doomlord> eg you might want to have axes & position in different precision 
[09:08:12] <aatch> Ok, so I've fixed a memory regression and fixed ~100 lifetime errors. Time to go home.
[09:08:22] <cmr> aatch: the benchmark is running though!
[09:08:30] <cmr> eta 2 min
[09:08:35] <aatch> cmr, ok, I'll wait
[09:08:49] <doomlord> coming from animatino packages, orientations get thrown around as Scaling/Rotation/Translation values someitimes (SRT) ..
[09:08:56] <doomlord> i've got conversions for all of that in c++ 
[09:10:34] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[09:10:50] <doomlord> bjz https://gist.github.com/dobkeratops/5947366 <<< thats the Vec3, Vec4... (i want to parameterize the scalar it uses )
[09:11:07] <doomlord> eg Vec3<f32> Vec3<f64> .. i've got that in C++ of course
[09:11:41] <doomlord> i haen't implemented quaternions yet, or a load of angles, or matrix inverse ..
[09:12:23] <bjz> mmk
[09:12:44] <doomlord> I was also finding out how much of the default methods work.. those are really handy if they DO work, but they'renot 100% yet
[09:12:59] <doomlord> i'll post my 2d arrays which i want to use for image manipulation code..
[09:13:15] <cmr> there's a fix in the queue that fixes most of the last of the errors with default methods I think
[09:13:52] <bjz> doomlord: sure thing
[09:13:59] <doomlord> https://gist.github.com/dobkeratops/5947381 <<, 2d arrays
[09:14:03] <bjz> doomlord: it's cool to see different approaches
[09:14:05] *** Joins: roo (jesse.rudo@moz-B7585E4C.dynamic.ip.windstream.net)
[09:15:02] <cmr> ah feck I forgot to pipe the output to a file
[09:15:19] <aatch> -.-
[09:15:20] <cmr> aatch: big improvement, but still overall a regression
[09:15:31] <aatch> cmr, I'll take it
[09:16:17] <aatch> Like I said, I'm pretty sure I know what the problem is, but the entire AST needs to be sendable to fix it.
[09:16:37] * strcat waits impatiently for header removal to merge
[09:16:46] <doomlord> bjz https://gist.github.com/dobkeratops/5947393 <<< this is what i'm trying to do now, a "tiled array"... intended for sparse data.. tiles can be a single value or 8x8 data. 
[09:17:19] <doomlord> I haven't really sust how to mutate an enum elegantly, but efficient code would batch up changes anyway
[09:17:19] <strcat> I'll just go to sleep and hopefully it will be done when I wake up ;p
[09:17:46] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: sleep)
[09:17:52] *** aatch is now known as aatch|gone
[09:17:55] <doomlord> bjz i should just put this all on github sometime but its really early 
[09:18:05] <bjz> doomlord: yeah defs
[09:18:28] <doomlord> it would also be possible to do vector maths built around Array3 for Vec3.. that sort of thing
[09:18:29] <bjz> doomlord: it's kind of embarrassing sometimes to have half-finished stuff online
[09:18:37] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[09:18:44] <cmr> see: lmath
[09:18:45] <cmr> ;p
[09:18:47] <doomlord> i'd prefer that in many ways,
[09:19:17] <doomlord> i'm really just learning the language and seeing what approaches do and dont work.. 
[09:19:32] <bjz> doomlord: unfortunately we don't have properties
[09:19:40] <mark_edward> cmr: i checked out the bz2 API. it should be simple enough for me to make a wrapper around that soon. 
[09:20:24] <bjz> doomlord: I would prefer to wrap a fixed length array for my vecs/points
[09:20:30] <bjz> (and matricies)
[09:20:41] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[09:20:59] <doomlord> bjz i was going to try and do a minecraft style block engine from 3d array, and possibly try to compose a 3d array as a 2d array with rle columns for the 3rd dimension, as well as a propper tiled 3d array, and octree etc..
[09:21:18] <mark_edward> are rust structs guaranteed to be laid out the same way as C structs?
[09:21:23] <bjz> cyndis: ping
[09:21:24] <aatch|gone> mark_edward, yes
[09:21:34] <doomlord> Now i know you *can* destructure tuples i'm also very tempted to do vector maths as tuples
[09:21:43] <mark_edward> another question, a bit more subtle. bzip2 c library has a struct
[09:22:03] <mark_edward> which has two members, meant to represent the high and low 32 bits of a 64bit int
[09:22:09] <doomlord> Tuples seemed neat for 2d array indices :)
[09:22:16] <bjz> doomlord: as I say, you can't desturture the self prarm, which would be limiting
[09:22:29] <mark_edward> if i replaced those 2 with one i64, would that change the layout in memory?
[09:22:32] <doomlord> ah.. 
[09:22:45] <cmr> mark_edward: no
[09:23:23] <doomlord> with a parameterized vector type , 2d array indices could be done as Vec2<uint>
[09:23:40] *** Joins: smvv_ (sander@moz-BAEA8EB2.dynamic.upc.nl)
[09:23:50] <doomlord> i should do a fixed point types and packed color types too
[09:24:07] <aatch|gone> bjz, you can still do `let &(a,b) = self` though, can't you?
[09:24:14] <mark_edward> i'm looking at this C strucct http://pastebin.com/BLUz0SXJ and looking to replace the total_X_lo32 ad total_X_hi32 members with a a single u64
[09:24:16] <bjz> yep
[09:24:30] <bjz> but that is more verbose
[09:24:52] <doomlord> bjz i'd be curious to see if rust has any existing 2d/3d array stuff too, 
[09:25:15] <bjz> doomlord: what kind of stuff?
[09:25:19] <doomlord> and as i say there's several excercises i have in mind, now sure which i'll focus on first
[09:25:45] <mark_edward> cmr: i think the ordering of the struct fields is wrong actually...
[09:26:01] <doomlord> yesterday someone else was asking for 2d arrays, and one suggestion was vector-of-vectors
[09:26:07] <cmr> mark_edward: nope, it's little endian
[09:26:34] <cmr> mark_edward: you should copy the struct layout exactly with c_uint and such
[09:26:41] <cmr> mark_edward: rust-bindgen can help with this btw
[09:26:53] <mark_edward> what's rust-bindgen?
[09:26:57] *** Quits: heftig (heftig@moz-21B2BBB0.dip0.t-ipconnect.de) (Ping timeout)
[09:27:00] <cmr> https://github.com/crabtw/rust-bindgen
[09:27:09] <cmr> generate rust declarations from C declarations
[09:28:17] <mark_edward> cool!
[09:29:51] *** Quits: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com) (Ping timeout)
[09:30:11] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[09:33:01] <mark_edward> you know what' be cool in Rust, some sort of numeric range type. so you could say `i only accept ints from 1-9`
[09:33:20] <cmr> I think that's https://en.wikipedia.org/wiki/Dependent_type
[09:36:43] *** Joins: heftig (heftig@moz-7D054C95.dip0.t-ipconnect.de)
[09:38:29] *** Joins: z0w0 (zack@moz-37A98529.lnse2.woo.bigpond.net.au)
[09:38:45] *** sam113101 is now known as sam113101_afk
[09:40:59] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[09:40:59] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 148e48594 to 1444770ae: 02http://git.io/N3iJvQ
[09:40:59] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[09:41:00] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[09:41:00] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/CcMevQ
[09:41:00] <ghrust> 13rust/06auto 14ae7d7d2 15James Miller: Revert "De-share ast::Ty"...
[09:41:00] <ghrust> 13rust/06auto 14d82bba6 15bors: auto merge of #7644 : Aatch/rust/syntax-deshare, r=huonw...
[09:41:01] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[09:41:38] <SimonSapin> rusti: std::float(".67e+3")
[09:41:40] -rusti- <anon>:7:9: 7:19 error: unresolved name `std::float`.
[09:41:40] -rusti- <anon>:7          std::float(".67e+3")
[09:41:40] -rusti-                   ^~~~~~~~~~
[09:41:40] -rusti- error: aborting due to previous error
[09:41:40] -rusti- application terminated with error code 101
[09:41:47] <SimonSapin> rusti: std::float::from_str(".67e+3")
[09:41:49] -rusti- Some(670)
[09:41:59] <jensnockert> mark_edward: As in runtime checks, or just an annotation with certain compile-time checks?
[09:42:00] <SimonSapin> rusti: std::float::from_str(".67e+3").get() == 670f
[09:42:01] -rusti- false
[09:42:11] <SimonSapin> rusti: std::float::from_str("6.7e+2").get() == 670f
[09:42:12] -rusti- true
[09:42:22] <SimonSapin> rusti: std::float::from_str("0.67e+3").get() == 670f
[09:42:23] -rusti- false
[09:42:26] <SimonSapin> â€¦
[09:42:37] <jensnockert> mark_edward: Or as in the LLVM range metadata http://llvm.org/docs/LangRef.html#range-metadata ?
[09:42:42] <SimonSapin> rusti: std::float::from_str("0.67e+2").get() == 67f
[09:42:43] -rusti- false
[09:42:49] <mark_edward> jensnockert: i'm not sure... the only real use is runtime checks, but i guess you could just use asserts...
[09:42:53] <SimonSapin> oh well
[09:43:45] *** Quits: noam (noam@F6B530A7.720527A7.416762B.IP) (Ping timeout)
[09:43:48] <SimonSapin> rusti: std::float::from_str(".68e+3").get() == 680f
[09:43:49] -rusti- true
[09:43:51] *** Joins: noam (noam@F6B530A7.720527A7.416762B.IP)
[09:45:28] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Ping timeout)
[09:45:33] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[09:45:43] <jensnockert> SimonSapin: Are you trying to find out that the from_str is broken?
[09:46:22] <SimonSapin> jensnockert: I have CSSÂ parsing that uses it, and my tests give unexpected results
[09:46:30] <doener> cmr: thanks!
[09:46:32] <mark_edward> what's the rust equivalent of a C function pointer?
[09:46:36] <cmr> np
[09:46:43] <jensnockert> SimonSapin: It is broken btw, not always, but in edge cases.
[09:46:49] <SimonSapin> oh :/
[09:47:28] <SimonSapin> well, this case gives a value that is close enough to 670 to print as such, but not enough to compare equal to it
[09:47:30] <nmatsakis> mark_edward: it will eventually be the `extern "C" fn` type, but my patch for that has been stalled for some time :( 
[09:47:39] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[09:47:42] <cmr> months!
[09:47:46] <jensnockert> SimonSapin: That may not be a bug though.
[09:47:48] *** sam113101_afk is now known as sam113101
[09:47:52] <mark_edward> what should I use for now?  `extern fn`?
[09:48:11] <SimonSapin> jensnockert: itâ€™s possible that floats work that way, but it compares equal in Python
[09:48:40] *** Joins: zelda (Mibbit@98CE9F86.3E06255A.14A8A76.IP)
[09:49:10] <SimonSapin> but itâ€™s possible that Python does more magic for this kind of case
[09:49:23] <mark_edward> cmr: does someone tell bors what to build/test or does it do it randomly?
[09:49:29] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[09:49:31] <jensnockert> SimonSapin: Could you check the bits of std::float::from_str(x) with the same number parsed in Python?
[09:49:57] <klutzy> mark_edward: currently extern fns has *u8 type
[09:50:15] <jensnockert> (As in, instead of printing it, do a cast::transmute to a u64)
[09:50:31] <mark_edward> klutzy: interesting, thanks!
[09:50:36] *** Parts: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP) ()
[09:50:39] *** Joins: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP)
[09:50:44] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[09:51:44] <cmr> mark_edward: bors processes PRs which have been r+'d and sorts by (priority, age)
[09:51:52] <cmr> (descending sort)
[09:52:02] <mark_edward> cool! who wrote bors?
[09:52:05] <Ms2ger> s/age/PR number/
[09:52:15] <cmr> graydon
[09:52:20] <SimonSapin> rusti: std::cast::transmute<f64: u64>std::f64::from_str(".67e3")
[09:52:21] -rusti- <anon>:7:33: 7:34 error: expected `;` or `}` after expression but found `:`
[09:52:21] -rusti- <anon>:7          std::cast::transmute<f64: u64>std::f64::from_str(".67e3")
[09:52:21] -rusti-                                           ^
[09:52:21] -rusti- application terminated with error code 101
[09:52:27] <SimonSapin> rusti: std::cast::transmute<f64, u64>std::f64::from_str(".67e3")
[09:52:28] -rusti- <anon>:7:33: 7:34 error: expected `;` or `}` after expression but found `,`
[09:52:28] -rusti- <anon>:7          std::cast::transmute<f64, u64>std::f64::from_str(".67e3")
[09:52:28] -rusti-                                           ^
[09:52:28] -rusti- application terminated with error code 101
[09:52:36] <SimonSapin> rusti: std::cast::transmute<f64, u64>(std::f64::from_str(".67e3"))
[09:52:36] -rusti- <anon>:7:33: 7:34 error: expected `;` or `}` after expression but found `,`
[09:52:36] -rusti- <anon>:7          std::cast::transmute<f64, u64>(std::f64::from_str(".67e3"))
[09:52:36] -rusti-                                           ^
[09:52:37] -rusti- application terminated with error code 101
[09:52:44] <cmr> Ms2ger: didn't know that, interesting
[09:52:58] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[09:52:58] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14d82bba6 to 1444770ae: 02http://git.io/N3iJvQ
[09:52:58] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[09:52:59] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[09:53:00] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/aFLBHw
[09:53:00] <ghrust> 13rust/06auto 147bf34c3 15Daniel Micay: vec: make vec_reserve_shared_actual private
[09:53:00] <ghrust> 13rust/06auto 140aedecf 15Daniel Micay: add a temporary vector_exchange_malloc lang item
[09:53:00] <ghrust> 13rust/06auto 1490f1db1 15Daniel Micay: remove headers from exchange allocations
[09:53:02] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[09:53:07] <cmr> please land, bors!
[09:53:16] *** Joins: dwhyte (dwhyte@ED9190FB.B72E355F.7BF4A4B0.IP)
[09:53:27] <SimonSapin> rusti: let i: u64 = std::cast::transmute(std::f64::from_str(".67e3")); i
[09:53:28] -rusti- <anon>:7:22: 7:72 error: call to unsafe function requires unsafe function or block
[09:53:28] -rusti- <anon>:7          let i: u64 = std::cast::transmute(std::f64::from_str(".67e3")); i
[09:53:28] -rusti-                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[09:53:28] -rusti- error: aborting due to previous error
[09:53:29] -rusti- application terminated with error code 101
[09:53:42] <SimonSapin> rusti: let i: u64 = unsafe { std::cast::transmute(std::f64::from_str(".67e3")) }; i
[09:53:43] -rusti- <anon>:1:0: 1:0 error: transmute called on types with different sizes: std::option::Option<f64> (128 bits) to u64 (64 bits)
[09:53:43] -rusti- <anon>:1 #[allow(default_methods)];
[09:53:43] -rusti-          ^
[09:53:43] -rusti- application terminated with error code 101
[09:53:53] <SimonSapin> rusti: let i: u64 = unsafe { std::cast::transmute(std::f64::from_str(".67e3").get()) }; i
[09:53:54] -rusti- 4649104598143860737
[09:54:11] <Ms2ger> Reference: http://quotes.burntelectrons.org/6997
[09:54:32] <cmr> <@graydon> I refuse to touch dates. dates are opaque strings for human amusement.
[09:54:40] <cmr> The immortal mecha-graydon speaks!
[09:54:44] *** Quits: zelda (Mibbit@98CE9F86.3E06255A.14A8A76.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[09:55:09] <cmr> anyway age and PR # are pretty much equivalent for the purposes of sorting
[09:55:20] <Ms2ger> Indeed
[09:55:42] *** Joins: pyrac (pyrac@F9CC429.73C89388.AD05C589.IP)
[09:56:29] <SimonSapin> rusti: let i: u64 = unsafe { std::cast::transmute(670f64) }; i
[09:56:30] -rusti- 4649104598143860736
[09:56:54] <cmr> a single bit of difference
[09:56:56] <cmr> nice
[09:57:17] <SimonSapin> jensnockert: In hexâ€™s thatâ€™s 0x4084f00000000001 vs 0x4084f00000000000
[09:57:32] <SimonSapin> Python probably rounds
[09:57:51] <jensnockert> SimonSapin: I am quite sure that the one in Python is correct, while the Rust one is wrong.
[09:58:30] <SimonSapin> Anyway, I used ".68e3" instead of ".67e3" in my test, that works around the issue
[09:58:59] <SimonSapin> Should I open a bug?
[09:59:14] <mark_edward> what is C NULL in Rust? just set the pointer value to zero?
[09:59:27] <jensnockert> SimonSapin: I think there is one, you should add to it.
[09:59:28] <cmr> mark_edward: also std::ptr::null(), but yes
[09:59:34] <jensnockert> SimonSapin: If there isn't, open one.
[09:59:35] <mark_edward> cool, thanks
[10:01:14] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[10:01:36] <SimonSapin> rusti: 0.67e3f
[10:01:37] -rusti- 670
[10:01:47] <SimonSapin> rusti: 0.67e3f == 670
[10:01:48] -rusti- <anon>:7:20: 7:23 error: mismatched types: expected `float` but found `<VI0>` (expected float but found integral variable)
[10:01:48] -rusti- <anon>:7          0.67e3f == 670
[10:01:48] -rusti-                              ^~~
[10:01:48] -rusti- error: aborting due to previous error
[10:01:49] -rusti- application terminated with error code 101
[10:01:52] <SimonSapin> rusti: 0.67e3f == 670f
[10:01:53] -rusti- true
[10:02:29] <SimonSapin> rusti: 0.67e3f == std::float::from_str("0.67e3")
[10:02:30] -rusti- <anon>:7:20: 8:5 error: mismatched types: expected `float` but found `std::option::Option<float>` (expected float but found enum std::option::Option)
[10:02:30] -rusti- <anon>:7          0.67e3f == std::float::from_str("0.67e3")
[10:02:30] -rusti- <anon>:8     };
[10:02:30] -rusti- error: aborting due to previous error
[10:02:30] -rusti- application terminated with error code 101
[10:02:35] <SimonSapin> rusti: 0.67e3f == std::float::from_str("0.67e3").get()
[10:02:36] -rusti- false
[10:03:20] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[10:07:43] *** Joins: drrb (drrb@1890AB83.D0F4B50F.670D5E6B.IP)
[10:08:07] *** Joins: sigma1 (sigma@51C589B3.EF2694B5.DFAC6AA7.IP)
[10:12:05] *** Joins: sk (sk@D75E713A.1D222DF7.24EDD759.IP)
[10:12:50] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[10:13:16] <SimonSapin> jensnockert: I did not find quite the same issue, so https://github.com/mozilla/rust/issues/7648
[10:13:30] *** Joins: Earnestly (earnest@2A2BF8F5.321FA5E6.BFD1ABFD.IP)
[10:13:33] <jensnockert> SimonSapin: Awesome, thanks!
[10:13:48] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[10:14:25] <AutomatedTester> is a private method only private when within a module or can it be private in an implementation?
[10:15:32] <jensnockert> SimonSapin: That should parse to an integer float btw, so the Rust one is definitely wrong.
[10:16:25] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Bye!)
[10:16:34] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[10:17:05] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[10:19:37] <kimundi> AutomatedTester: I'm not sure if methods can be private
[10:19:49] <cmr> kimundi: they can be
[10:20:02] <kimundi> Well, it certainly makes no sense for traits I think
[10:20:13] <kimundi> methods on types maybe
[10:24:23] *** Joins: robert (robertknig@moz-17A2B1B0.range81-159.btcentralplus.com)
[10:29:52] *** Parts: drrb (drrb@1890AB83.D0F4B50F.670D5E6B.IP) ()
[10:33:26] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[10:34:44] *** Quits: cdidd (cdidd@moz-F3DF983E.broadband.corbina.ru) (Ping timeout)
[10:35:24] *** Quits: doomlord_ (servitor@moz-6651F8D4.range86-145.btcentralplus.com) (Ping timeout)
[10:35:38] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[10:38:54] *** Joins: BluePeppers (user@moz-3799699A.range81-151.btcentralplus.com)
[10:41:43] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[10:41:50] *** Quits: pyrac (pyrac@F9CC429.73C89388.AD05C589.IP) (Quit: pyrac)
[10:42:30] *** Joins: lilybet (Mibbit@moz-F145F0FF.xlshosting.net)
[10:43:25] *** Joins: jensnock_ (jensnocker@moz-C5F27039.cust.bredband2.com)
[10:43:26] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Connection reset by peer)
[10:50:23] *** Joins: achim (achim@48D08254.C47AE098.3170947E.IP)
[10:53:04] <doener> cmr: may I be bold and ask for p=1? The change should reduce cycle
[10:53:22] *** Joins: cr (anonymous@moz-6968310D.dip0.t-ipconnect.de)
[10:53:27] <cmr> sure
[10:53:35] *** Quits: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk) (Ping timeout)
[10:57:46] *** Joins: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com)
[10:58:25] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Ping timeout)
[11:04:19] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[11:08:07] *** Joins: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk)
[11:08:22] *** Quits: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com) (Ping timeout)
[11:08:22] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[11:08:37] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[11:08:49] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[11:10:31] *** Quits: robert (robertknig@moz-17A2B1B0.range81-159.btcentralplus.com) (Ping timeout)
[11:11:51] *** Joins: doomlord_ (servitor@moz-6651F8D4.range86-145.btcentralplus.com)
[11:12:02] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[11:14:25] *** Quits: doomlord_ (servitor@moz-6651F8D4.range86-145.btcentralplus.com) (Quit: Leaving)
[11:14:27] *** Joins: doomlord_ (servitor@moz-6651F8D4.range86-145.btcentralplus.com)
[11:15:14] *** Parts: doomlord_ (servitor@moz-6651F8D4.range86-145.btcentralplus.com) (Leaving)
[11:15:18] *** Joins: doomlord_ (servitor@moz-6651F8D4.range86-145.btcentralplus.com)
[11:15:29] *** Quits: doomlord_ (servitor@moz-6651F8D4.range86-145.btcentralplus.com) (Quit: Leaving)
[11:15:30] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[11:15:33] *** Joins: doomlord_ (servitor@moz-6651F8D4.range86-145.btcentralplus.com)
[11:16:33] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[11:19:53] *** Joins: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com)
[11:21:13] <doener> cmr: hm, semantic conflict with the ~ header change, I've pushed a version that's rebased onto that
[11:21:35] <cmr> doener: that's in testing now right?
[11:21:50] <doener> cmr: right
[11:22:08] <doener> cmr: rebased my PR onto auto
[11:22:16] <cmr> alright, fingers crossed :)
[11:23:09] *** Joins: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP)
[11:23:31] *** Joins: mib_07pxla (Mibbit@FDA96E00.AFD65FD6.1C941E77.IP)
[11:23:37] <mark_edward> does from_buf_raw copy the memory?
[11:23:56] <cmr> mark_edward: use the source!
[11:25:29] <mark_edward> seems it does. 
[11:25:31] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[11:25:55] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[11:25:55] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/aFLBHw
[11:25:55] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[11:27:25] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[11:27:48] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[11:28:15] <engla> there go the headers
[11:28:23] <cmr> \o/
[11:28:30] <cmr> truly a momentous occasion
[11:28:49] <doener> cmr: don't bother with my PR for now, fails with a weird bug on top of auto, will investigate in the evening
[11:28:54] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[11:28:54] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/D787sg
[11:28:54] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[11:28:57] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[11:28:57] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/C3TO9g
[11:28:57] <ghrust> 13rust/06auto 14d49acef 15Alex Crichton: Add rusti/rustpkg to check-lite...
[11:28:57] <ghrust> 13rust/06auto 1465ed803 15bors: auto merge of #7568 : alexcrichton/rust/check-lite, r=huonw...
[11:28:58] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[11:29:01] <engla> yeah very cool.. time to build it and test it
[11:29:10] <cmr> doener: ok
[11:29:15] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[11:29:40] *** Joins: pyrac (pyrac@moz-88F57AAB.math.u-bordeaux1.fr)
[11:30:09] <SiegeLord> strcat finally got it to work?
[11:30:49] <cmr> he broke ~Trait in the process
[11:30:56] <cmr> but ~Trait has no tests, so it was already broken
[11:30:57] <SiegeLord> That worked?
[11:31:08] <cmr> sometimes
[11:31:13] <SiegeLord> Hehe
[11:31:13] <engla> oh
[11:31:15] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[11:32:22] <engla> hope ~Trait comes back soon
[11:32:32] <doomlord_> ouch
[11:32:41] <cmr> he plans on fixing it today afiak
[11:32:47] <cmr> (as well as adding tests)
[11:32:49] <doomlord_> i'm looking forward to trying that out after my honeymoon with enums
[11:34:29] <roo> is there something like .chain for Option, that executes the block passed to it when self == None?
[11:34:49] <kimundi> roo: afaik yes
[11:35:34] <roo> whats the name? I can't use .or() because i need to delay evaluation
[11:36:24] <Ms2ger> .map?
[11:36:40] <Ms2ger> Oh, None
[11:37:44] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[11:37:54] *** Quits: lilybet (Mibbit@moz-F145F0FF.xlshosting.net) (Quit: http://www.mibbit.com ajax IRC Client)
[11:39:50] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[11:41:24] <doener> cmr: was actually trivial, I just typo'ed the compile fix for the ~ header thing into a semantic error, PR updated. Sorry for the back and forth
[11:41:31] *** Parts: z0w0 (zack@moz-37A98529.lnse2.woo.bigpond.net.au) ()
[11:43:20] *** Joins: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[11:47:47] <roo> Ms2ger: yeah, itd be something like fn orElse(&self,blk: &fn() -> Option<T>) -> Option<T>, but im not seeing anything like that.
[11:52:53] *** Quits: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com) (Ping timeout)
[11:55:58] *** Quits: jensnock_ (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[11:59:03] *** Joins: robert (robertknig@moz-8096AA7D.range86-182.btcentralplus.com)
[12:00:24] <engla> you can implement it
[12:00:39] <engla> option could use a few more methods
[12:01:14] <SiegeLord> Is testing of the example snippets in documentation something that the rust build system does, or is it a feature of rustc?
[12:01:26] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[12:02:08] <cmr> SiegeLord: build system
[12:02:12] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[12:02:26] <mark_edward> cmr: what do you need from a compressor?
[12:02:42] <mark_edward> right now i just have a compress method that compresses a &[u8]
[12:02:47] <cmr> mark_edward: I want to be able to give it a buffer and get back a buffer
[12:02:52] <mark_edward> seems to work, but needs nor testing
[12:03:13] <cmr> Without any extra information (expected length etc), I expect the compression library to do that for me
[12:03:17] <mark_edward> cmr: well i seem to have that down. I'll push it and let you take a look in a bit
[12:03:25] <roo> engla: alright :)
[12:03:41] <mark_edward> first i need to find out if it gives the same output as it should...
[12:03:54] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[12:04:01] <mark_edward> and the only way to do that is with a decompressor...
[12:04:18] <SiegeLord> cmr, Maybe it's something for the new rustdoc to also do... at least being able to extract the snippets to a file
[12:04:32] <SiegeLord> Or to files, rather
[12:04:55] <kimundi> We definitly need a way to test code snippets in doc comments
[12:05:07] <kimundi> Those are currently rotting all the time
[12:05:48] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Quit: Leaving)
[12:10:39] <doomlord_> directory structure: within a crate build, can modules only include from downward in the directory structure   a/foo.rs  b/bar.rs    <<< can bar.rs include mod foo.rs ?
[12:11:03] <doomlord_> (i see that nested mods seem to request directories)
[12:11:34] *** Joins: novabyte (Instantbir@moz-3E0F9699.cable.virginmedia.com)
[12:12:14] <doomlord_> at the minute i dont have so much code, i could say common/<all my helper code & libs>   and various standalone programs below that using common
[12:12:31] <SiegeLord> What do you mean by "include"
[12:12:46] <cmr> doomlord_: you can use #[path="../a/foo.rs"] mod foo;
[12:12:52] <cmr> doomlord_: usually you don't want that though
[12:12:53] <doomlord_> i dont want to start making crates just yet because of what i read about the ability of certain things to not go across crate boundaries
[12:13:12] <doomlord_> "include" .. import?  reference something and bring it in 
[12:13:46] *** Quits: victorporof (victorporo@74A9C5E8.1745F5FA.9B1E38F4.IP) (Quit: victorporof)
[12:13:47] <engla> ~Trait is not entirely broken. Seems to work here.
[12:13:59] <SiegeLord> You can just specify an absolute path instead of a relative one
[12:14:11] <SiegeLord> In fact, you generally want to specify an absolute path anyway
[12:14:30] <SiegeLord> So in bar.rs you'd have use crate::a::foo;
[12:14:54] <cmr> doomlord_: see https://github.com/mozilla/rust/issues/5765
[12:15:10] <cmr> doomlord_: usually you want all/most of your mods in the crate root and just `use` what you want
[12:15:27] <doomlord_> right ok
[12:15:38] <doomlord_> i wasn't aware of these duplication problems
[12:15:48] <SiegeLord> Wait, that's a bug?
[12:15:50] <SiegeLord> I use that feature...
[12:15:52] <cmr> for examples of pretty much every crate structure under the sun, see rustc.rs, extra.rs, and std.rs, in src/{librustc,libextra,libstd}
[12:16:02] <cmr> SiegeLord: it is a feature, just poorly documented
[12:16:15] <SiegeLord> Well, not quite... I define the module itself inside the file
[12:16:26] <SiegeLord> Many of my modules have a 'mod private {}'
[12:17:14] <doomlord_> this is part of why it wants self:: ?
[12:17:31] <cmr> No, self:: is to refer to names relative to your module
[12:17:49] <cmr> all paths are relative to the crate root, self:: and super:: let you be relative to yourself
[12:18:01] <cmr> (crate is such a dumb name, can someone please come up with something better?)
[12:18:03] <doomlord_> ah and you need that if you had the module brought in locally
[12:18:11] <cmr> Right
[12:18:33] <SiegeLord> Can you do: super::super::a::foo?
[12:18:37] <cmr> yes
[12:18:42] <SiegeLord> Sweet
[12:19:01] <doomlord_> i like the idea of a :: or root:: aswell
[12:19:16] <cmr> I wouldn't mind ::, but crate-root-relative is almost always what you want
[12:20:13] <SiegeLord> I'd be probably ok with removing relative 'uses' altogether... but that might be unpopular
[12:20:22] <cmr> https://github.com/mozilla/rust/issues/4047#issuecomment-15796103
[12:23:21] <SiegeLord> So is it intractable or not?
[12:23:31] <SiegeLord> 'cause if it is, then maybe it should be simplified :P
[12:23:44] <cmr> What features would you remove?
[12:24:15] <SiegeLord> I don't know what makes it intractable
[12:24:15] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[12:24:25] *** Joins: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au)
[12:24:25] <cmr> intractable just means hard
[12:25:02] <SiegeLord> That's diluting a useful term
[12:25:23] <SiegeLord> There's no such thing as an "intractable" algorithm
[12:25:39] <SiegeLord> It might be computationally intractable, perhaps
[12:25:53] <cmr> I've never heard any other definition :\
[12:26:04] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[12:26:13] <SiegeLord> I mean, programming is hard
[12:26:18] <SiegeLord> Nobody calls programming intractable :P
[12:26:20] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[12:26:29] <cmr> have you seen the resolve code?
[12:26:30] <kimundi> SiegeLord: "SiegeLord> I use that feature..." Wich feature do you mean?
[12:26:31] <cmr> :p
[12:26:37] <SiegeLord> Intractable to me means that it's practically impossibly
[12:26:41] <SiegeLord> *impossible
[12:26:54] <cmr> I haven't heard it used that way
[12:27:01] <SiegeLord> kimundi, Multiple modules having an identically named submodule
[12:27:12] <kimundi> AH, that's not the issue
[12:27:21] <SiegeLord> Like... breaking symmetric key encryption is intractable because it takes so long
[12:27:35] <kimundi> The issue is including the same _code_ in two different places
[12:28:05] <SiegeLord> https://en.wikipedia.org/wiki/Intractability_%28complexity%29#Intractability
[12:28:33] <SiegeLord> So I'm curious if pcwalton in fact means that there's not enough computing time in the world to resolve names in Rust :P
[12:28:49] <cmr> clearly there is, we do it all the time
[12:29:00] <SiegeLord> Maybe we don't do it exactly
[12:29:28] <cmr> resolve isn't even that slow
[12:29:43] <cmr> SiegeLord: well Rust name resolution is defined by what rustc does, so...
[12:30:08] <SiegeLord> I like to live in a dreamworld with a hypothetical Rust spec ;)
[12:30:13] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[12:30:33] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[12:31:48] <SiegeLord> kimundi, Ok, I see the difference... but does your testcase actually trigger it?
[12:31:48] *** Joins: victorporof (victorporo@F32D7940.1C233438.79933D60.IP)
[12:31:56] *** Quits: robert (robertknig@moz-8096AA7D.range86-182.btcentralplus.com) (No route to host)
[12:31:56] <kimundi> trigger what?
[12:32:00] <SiegeLord> The bug
[12:32:01] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Ping timeout)
[12:32:02] <kimundi> This is not a bug
[12:32:15] <kimundi> IT's a potential cause of confusion :P
[12:32:30] <mark_edward> cmr: is there a way to randomly fill avector?
[12:33:02] <kimundi> Something that should be warned against, like unneccessary allocations etc
[12:33:03] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[12:33:35] <cmr> mark_edward: see example of how to do this in extra::deflate's tests
[12:33:40] <kimundi> To be honest I'm somewhat confused how that Issue can be seen as a bug with a testcase...
[12:33:48] <mark_edward> thanks cmr
[12:34:41] <SiegeLord> Hmm
[12:34:46] <SiegeLord> I'm confused now
[12:35:02] <SiegeLord> Why does it look for c.rs and not a/c.rs and b/c.rs?
[12:35:12] <kimundi> hu?
[12:35:34] <kimundi> ah, I didn't bother with file paths
[12:35:51] <SiegeLord> The module hierarchy is: mod crate { mod a { mod c {} } mod b { mod c {} }}
[12:35:51] <kimundi> assume all three files are right next to each other
[12:36:02] *** Quits: mib_07pxla (Mibbit@FDA96E00.AFD65FD6.1C941E77.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[12:36:06] <SiegeLord> Your testcase compiles, but I don't get why
[12:36:34] <cmr> SiegeLord: `mod ident;` looks in the current directory, not a directory with the name of the parent mod
[12:36:43] <cmr> except nested in other mod blocks
[12:36:52] <kimundi> because "mod Foo;" is just suger for "mod Foo { /* content of Foo.rs */ }"
[12:37:39] <kimundi> hence having two mod c; in different places that end up pointing to the same c.rs results in a duplicated module in your crate
[12:38:04] <gavinb> Is there some make-fu to build libstd but not the entire rest of the toolchain? The obvious doesn't seem to work.
[12:38:20] <gavinb> (This is on OS X btw.)
[12:38:41] <cmr> make stage1-std maybe?
[12:38:53] <kimundi> wich libstd do you want? stage1 or stage2, with or without tests? :P
[12:39:25] <gavinb> To answer that, I would have to have to really understand the build stages!
[12:39:30] *** Quits: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net) (Quit: Jesse)
[12:39:33] <SiegeLord> The real wtf then is that mod foo; works that way and/or that you can do it in a non-crate.rc file
[12:39:40] <SiegeLord> *.rs
[12:39:43] <SimonSapin> How do I get a mutable reference to an enum field?
[12:39:52] <cmr> SimonSapin: Foo(ref f)
[12:40:06] <cmr> SiegeLord: there's no difference between a crate.rs and a non-crate.rs though
[12:40:09] <gavinb> kimundi: I guess stage1 would be sufficient, as I just need to check for a general lack of breakage.
[12:40:26] <engla> SimonSapin: match elt {  Foo(ref mut f) => .. }
[12:40:28] <cmr> gavinb: can also just run `make` and ctrl-c when you're satisfied
[12:40:37] <cmr> oh he said mutable
[12:40:39] <cmr> duh
[12:41:01] <SiegeLord> Well, the result of there being no difference means that "confusions" like those are now made possible
[12:41:15] <SimonSapin> engla, cmr: can I do that without moving the enum?
[12:41:16] <cmr> it's a useful featured used all the time
[12:41:19] <gavinb> mark_edward: I would try vdc::from_fn() and pass in a fn that returns a random number. (I didn't see this in deflate.)
[12:41:28] <kimundi> SiegeLord: It's still usefull to do mod Foo; in a submodule imo. You just don't want any duplication in your crate. 
[12:41:33] <cmr> example: libstd/num/mod.rs
[12:41:49] <mark_edward> gavinb: I found a funcction on std::rand that actually generates random bytes, which is what I needed
[12:41:56] <SimonSapin> "error: cannot move out of dereference of & pointer"
[12:41:56] <SimonSapin> &self is the enum that Iâ€™m matching
[12:42:08] <SiegeLord> kimundi, I'd avoid it in my code
[12:42:17] <engla> SimonSapin: yes
[12:42:24] <gavinb> cmr: the problem is the stuff that it tries to build _before_ libstd, not after. But I'll try what you suggested above.
[12:42:26] <cmr> SimonSapin: try &Variant(ref mut f)?
[12:42:49] <cmr> gavinb: there is nothing built before libstd besides the runtime and llvm, both of which are necessary?
[12:42:51] <gavinb> mark_edward: cool
[12:43:07] <kimundi> SiegeLord: Sure, I'd probably too. But it can still be usefull in large codebases, or for grouping files for conditional compiled stuff.
[12:43:46] *** Quits: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk) (Ping timeout)
[12:44:24] <gavinb> cmr: well I have a working installation of the toolchain, and am only modifying libstd. If I do a 'git pull' this might update files that trigger a rebuild of the runtime and llvm, which I don't want to rebuild (yet!). I just need a quick way to only rebuild libstd, regardless of what else has changed or needs to be rebuilt.
[12:44:49] <km> Implementing the Drop trait is supposed to make a struct uncopyable, right?
[12:45:04] <kimundi> People just need to know that 'mod' is just for building the logical tree of your crate modules, and that you obviosly shouldn't include the same thing twice.
[12:45:40] <kimundi> km: Right, need to implement clone manually then
[12:46:35] <kimundi> rusti: NonCopyable
[12:46:35] -rusti- <anon>:7:9: 7:20 error: unresolved name `NonCopyable`.
[12:46:35] -rusti- <anon>:7          NonCopyable
[12:46:35] -rusti-                   ^~~~~~~~~~~
[12:46:35] -rusti- error: aborting due to previous error
[12:46:36] -rusti- application terminated with error code 101
[12:46:47] <km> I'm seeing a struct copied and the destructor called twice. See http://hastebin.com/riyaheduhe.rs
[12:47:49] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Quit: Leaving.)
[12:48:07] *** Joins: MaikKlein (maik@moz-54A7C76.dip0.t-ipconnect.de)
[12:49:03] <SimonSapin> I wish we had yield yet
[12:49:12] <kimundi> rusti: std::util::NonCopyable
[12:49:12] -rusti- <anon>:7:9: 7:31 error: unresolved name `std::util::NonCopyable`.
[12:49:12] -rusti- <anon>:7          std::util::NonCopyable
[12:49:12] -rusti-                   ^~~~~~~~~~~~~~~~~~~~~~
[12:49:12] -rusti- error: aborting due to previous error
[12:49:13] -rusti- application terminated with error code 101
[12:49:37] <kimundi> rusti: std::util::NonCopyable
[12:49:38] -rusti- <anon>:7:9: 7:31 error: unresolved name `std::util::NonCopyable`.
[12:49:38] -rusti- <anon>:7          std::util::NonCopyable
[12:49:38] -rusti-                   ^~~~~~~~~~~~~~~~~~~~~~
[12:49:38] -rusti- error: aborting due to previous error
[12:49:38] -rusti- application terminated with error code 101
[12:49:45] <kimundi> rusti: util::NonCopyable
[12:49:46] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/aOGI
[12:49:54] <Luqman> \o/ #7605 got merged
[12:50:38] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[12:50:48] <cmr> it's almost done benchmarking too
[12:52:14] <cmr> dbaupp: another feature request: hovering over the card should embolden the line in the commit timeine too
[12:52:39] *** Joins: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP)
[12:53:32] <kimundi> km: Well for some reason it copies the struct in your transform call
[12:54:21] <kimundi> km: the addresses are all different, so I don't think it is calling a destructor twice
[12:57:01] <km> kimundi: Am I misunderstanding how Drop is supposed to work, or is that a bug?
[12:57:14] <kimundi> AS far as I know, this is a bug
[12:57:25] <km> When my real destructor frees memory in C, it's still a problem even if the address of the pointer to it is different.
[12:57:42] *** Joins: bytewise (bytewise@moz-649C630D.unitymediagroup.de)
[12:57:45] *** Quits: MaikKlein (maik@moz-54A7C76.dip0.t-ipconnect.de) (Ping timeout)
[12:57:49] <kimundi> does it still work if you replace |&x| x with |x| *x ?
[12:58:04] <cmr> yeah, patterns like that are an implicit copy
[12:58:08] <cmr> I think it's a soundness bug
[12:58:34] <Luqman> i wonder how strcat fixed the libstd tests
[12:58:37] <cmr> at least, they're an implicit copy with `let`, I can't imagine they'd be different there
[12:58:56] <km> Changing it to  |x| *x gives `20:53 error: cannot move out of dereference of & pointer`
[13:00:06] <kimundi> Yeah, that's what should happesn in the other case too
[13:00:36] <km> What's the difference between 
[13:00:43] <Luqman> ah, a typo xD
[13:00:47] <kimundi> because of the Drop impl, the struct can not be copied anymore, onld moved
[13:00:56] <km> |x: &DropObject| and |&x|
[13:00:58] <kimundi> km: One has a bug, the other not :P
[13:01:17] <cmr> km: one is plain-old x with a type, one is a typelesjs destructuring pattern
[13:01:20] <cmr> *typeless
[13:01:27] *** Quits: quvarxa (chatzilla@moz-978E4C31.static.tpgi.com.au) (Quit: ChatZilla 0.9.90 [Firefox 23.0/20130703181823])
[13:01:58] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[13:01:58] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/C3TO9g
[13:01:58] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[13:02:22] <kimundi> |&x| ... == |x| {let &x = x; ...}
[13:02:43] *** Quits: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP) (Quit: Lost terminal)
[13:03:25] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[13:04:24] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[13:04:52] <mark_edward> cmr: my decompressor isn't giving me my original data back
[13:04:53] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[13:04:53] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/p4c-3A
[13:04:54] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[13:04:57] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[13:05:11] <cmr> mark_edward: bz2 right?
[13:05:17] <mark_edward> but if i print my compressor's output to stdout and pipe it to bunzip2 i get the right answer
[13:05:31] <mark_edward> which means it's a decompression problem right?
[13:05:34] <cmr> yup
[13:05:35] <mark_edward> qand yes it's bz2
[13:06:28] <cmr> are you using BZ2_bzCompress and friends or BZ2_bzRead?
[13:06:58] <engla> cmr: I think let patterns are different (until they are fixed). let patters are known unsound
[13:07:13] <engla> https://github.com/mozilla/rust/pull/7262
[13:07:30] <cmr> Closures are also irrefutable patterns
[13:08:00] <engla> yeah that PR doesn't mention 'let'. My mind just told me it was just about let
[13:09:39] <mark_edward> BZ2BzCompress
[13:09:52] <mark_edward> cmr: *BZ2_bzCompress and friends
[13:10:03] <cmr> ok (good0
[13:10:27] <cmr> I see in the manual a BZ2_bzBuffToBuffCompress and BZ_bzBuffToBuffDecompress, maybe those are useful too?
[13:11:44] <Luqman> cmr: will it post the benchmark on the pull?
[13:11:50] <cmr> Luqman: not yet
[13:11:56] *** Quits: eevee (eevee@moz-58058235.evrt.wa.frontiernet.net) (Ping timeout)
[13:12:03] <cmr> http://huonw.github.io/isrustfastyet/mem/
[13:12:08] <cmr> refresh every 5 minutes ;)
[13:12:33] <cmr> data's already there, just gotta wait for the site to pick up the changes
[13:13:23] <dbaupp> cmr: I'm trying to work on actual rust, rather than js for a bit (and you can work out which commit it is by looking at the hash, so it's nice-to-have rather than required to reduce confusion :) )
[13:13:33] <cmr> dbaupp: right
[13:13:43] <dbaupp> (it literally just pushed now, btw.)
[13:14:06] *** Joins: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com)
[13:14:25] <dbaupp> strcat's pull appear to increase memory use very slightly
[13:15:02] <cmr> that doesn't make much sense
[13:15:23] <dbaupp> no, not really
[13:15:39] <km> I'm trying to write bindings for libusb to write USB drivers in Rust. I have a function that returns a vector of Device objects, and I want to pick a Device from that vector and destroy the rest. Device implements Drop because it has to call a libusb function to unref the device. 
[13:15:42] <dbaupp> the peak is in the linking stage though
[13:15:50] <km>  I think I have to make it return a ~[~Device] vector instead of ~[Device] so I can move one out to return and let the rest get destroyed?
[13:15:59] <km> Or should I make list_devices return some kind of iterator instead of a vector?
[13:16:28] <AutomatedTester> hi, is creating a method called new() the only approach to instantiate an impl into a variable?
[13:16:48] <dbaupp> AutomatedTester: what do you mean?
[13:17:09] <cmr> AutomatedTester: no? You can call any methods on any struct you have, the new static method is just one way of getting a struct
[13:17:36] <dbaupp> km: returning an iterator would be neat, but it's not particularly necessary
[13:18:06] <dbaupp> km: also, ~[~T] rarely necessary, ~[T] is better :)
[13:18:07] <AutomatedTester> dbaupp: in a number of examples I have seen impl Foo { fn new() -> Foo{ return Foo;} } let foo = Foo::new();
[13:18:39] <dbaupp> AutomatedTester: right, that's just providing a convenience constructor, there's nothing specially about it, or the name 'new'
[13:19:19] <AutomatedTester> so I can just call methods on a struct, repeating what cmr said, I dont need to instantiate an object like i would with other langs?
[13:19:55] <cmr> you always need a fully constructed struct, but how it is constructed doesn't matter
[13:20:09] <cmr> be it a new() method or just constructing it directly
[13:20:22] <AutomatedTester> how would I do it directly?
[13:20:26] <engla> AutomatedTester: fundamentally a struct value is created with the syntax   Foo{x: 1, y: 2}
[13:20:38] <AutomatedTester> aha
[13:20:41] <cmr> rusti: struct Foo {a: int, b: uint}; Foo{a: 4, b: 2}
[13:20:43] -rusti- {a: 4, b: 2}
[13:20:49] <dbaupp> rusti: struct Foo { i: int } impl Foo { fn new() -> Foo { Foo { i: 1 } } } let x = Foo::new(); let y = Foo { i: 2 }; (x, y)
[13:20:51] -rusti- ({i: 1}, {i: 2})
[13:21:12] <AutomatedTester> ok I think I get it now
[13:21:27] <AutomatedTester> thanks for baring with me on this... I am a little slow sometimes ;)
[13:22:19] <km> How would I go about iterating over a vector and moving one element out and destroying the rest? Iterators seem to deal with borrowed pointers, and it's a bug that the code I posted above copies it.
[13:22:31] <dbaupp> km: .consume_iter()
[13:23:24] <dbaupp> rusti: let v = ~[~[1],~[2],~[3],~[4]]; for v.consume_iter().advance |x| { println(fmt!("%?", x)); }
[13:23:24] -rusti- ~[1]
[13:23:25] -rusti- ~[2]
[13:23:25] -rusti- ~[3]
[13:23:25] -rusti- ~[4]
[13:23:25] -rusti- ()
[13:23:46] <dbaupp> (~[] moves by default, just like other types with dtors)
[13:26:31] <cmr> km: v[x] works if you already know the index
[13:26:59] <dbaupp> cmr: when do you lose access to the benchmarker?
[13:27:29] <cmr> dbaupp: unknown but I should have it at least a few months more
[13:27:34] <engla> to move it out you need swap_remove
[13:27:42] <thiez> why would you lose access to the benchmarker?
[13:27:46] <dbaupp> cmr: ok
[13:27:53] <cmr> thiez: it's uh, "borrowed"
[13:28:11] *** Quits: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com) (Ping timeout)
[13:28:44] <thiez> well, in a few months surely we've optimized rustc enough that most of the buildslaves will be idle and picking their noses, so we can use those... </wishful-thinking>
[13:28:57] *** Joins: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP)
[13:29:58] <km> dbaupp: .consume_iter().find_() is exactly what I was looking for. 
[13:32:42] <SiegeLord> Is it possible to write a single function that can subslice a slice, and work for both immutable and mutable slices?
[13:32:43] <mark_edward> can you put PDFs in github
[13:32:55] <cmr> mark_edward: yes
[13:32:57] *** Joins: mye (mye@moz-5EBA714.dip0.t-ipconnect.de)
[13:33:37] <SiegeLord> As a point of reference... you can do it in D, using a special 'inout' mutability class
[13:34:01] *** kimundi is now known as zz_kimundi
[13:34:05] <engla> there is no parameterization over mutability SiegeLord 
[13:34:06] <dbaupp> SiegeLord: i.e. "parameterised" mutability
[13:34:32] <dbaupp> SiegeLord: you could use a trait, and impl it for &'self [T] and &'self mut [T]
[13:34:53] <SiegeLord> That violates the 'single function' requirement
[13:35:06] *** Joins: judder (maradukewa@5B9E91E7.2C8A8E2E.78E362FE.IP)
[13:35:21] <cmr> it's a workaround, not a solution
[13:35:48] <dbaupp> SiegeLord: sorta, it's a single trait + method, but with 2 implementations; but yeah, workaround
[13:36:17] <SiegeLord> Is this a... future feature? I think I've seen 'parametrized mutability' mentioned before
[13:37:56] <cmr> Wait, doesn't &const fulfill this?
[13:38:22] *** Joins: Sorella (queen@78575561.924F2739.95C8B7C6.IP)
[13:38:34] <dbaupp> cmr: not really
[13:39:52] <dbaupp> cmr: I think SiegeLord wants fn foo<mutability>(&mutability [T]) -> &mutability [T], so foo(&[int]) -> &[int], foo(&mut [int]) -> &[int], but foo(&const [T]) can only return &[T]
[13:40:06] <cmr> ah, right
[13:40:06] <SiegeLord> Yeah
[13:40:21] <engla> it would cleanup our APIs. everywhere there is  chain_ref, chain_mut_ref  etc
[13:40:49] <engla> or maybe.. as in this case, there is chain_ref, but not yet chain_mut_ref which is frustrating when you reach for it :)
[13:41:00] *** Joins: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com)
[13:41:02] * dbaupp opens a bug
[13:42:16] *** Joins: saml (sam@moz-14C16814.cst.lightpath.net)
[13:42:16] <cmr> so... `fn foo<&var, 'a>(x: &'a var T) -> &'a var T` is what I'm envisioning that could look like.,
[13:42:30] <cmr> Or even just introducing a &var without the parameterization syntax
[13:42:36] *** Quits: pauls (pauls@moz-BFEF1F22.ccs.neu.edu) (Ping timeout)
[13:42:54] <dbaupp> engla: hm, there might be, actually
[13:42:57] <SiegeLord> It might be the case that the lifetimes provide enough of a hint to covary the mutability
[13:43:16] <dbaupp> engla: since sometimes you want to borrow a mutable variable as immutable (to have multiple references to it)
[13:43:17] <engla> most of the time you want to preserve the mut/not mut of the &self arg
[13:43:47] <cmr> dbaupp: you can do that?
[13:43:53] <dbaupp> cmr: sure
[13:44:02] <cmr> as long as the borrow doesn't outlive the &mut I suppose that'd be ok... and it'd be immutable while you have it
[13:44:04] <dbaupp> rusti: let mut x = 1; let y = &x;
[13:44:05] <engla> good point
[13:44:05] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/fbfY
[13:44:27] <dbaupp> cmr: y is an immutable "borrow" of the mutable x
[13:44:40] <cmr> right... so do we even need a new feature?
[13:44:59] <cmr> Just let &mut be implicitly reborrowed as & in function calls
[13:45:12] <cmr> I think SiegeLord is right that lifetimes cover it
[13:45:32] <engla> right
[13:46:28] * dbaupp has stopped opening a bug
[13:46:38] <dbaupp> (someone else can, if they want. :) )
[13:46:58] <SiegeLord> So I'm confused... essentially I'd do an immutable borrow of a slice... and then what?
[13:47:21] <cmr> oh hm
[13:47:31] <cmr> you need to return a pointer with the original mutability
[13:47:39] <cmr> you can't just do an immutable borrow
[13:48:19] <cmr> Maybe when the compiler see it takes a & of one lifetime and returns a & of the same lifetime, it gives them the same mutability?
[13:48:52] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[13:48:56] *** Joins: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca)
[13:49:03] <cmr> http://huonw.github.io/isrustfastyet/mem/#48ad726,44770ae
[13:49:15] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Quit: leaving)
[13:49:18] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[13:49:19] <cmr> Luqman: higher peak memory, and a bit higher in the later parts of llvm, but overall a win
[13:49:20] <engla> cmr: that sounds good to me, but it still has the problem dbaupp mentioned
[13:49:23] <cmr> faster, too, because of the fewer allocs
[13:49:25] <cmr> engla: yeah
[13:49:48] <Luqman> cmr: yay
[13:50:04] <cmr> Luqman: of course, rustc is basically the worst measurement of that PR's impact, it barely uses ~T
[13:50:19] <cmr> but, it doesn't make it worse
[13:50:22] <SiegeLord> And ignoring slices for a bit... would this work? let mut a; { let b = &a; } *a = 1; ?
[13:50:23] <dbaupp> cmr: average memory use is possibly better than peak, hm
[13:50:44] <SiegeLord> Actually, nvm... you need this for chaining, don't you
[13:51:11] <SiegeLord> It seems like this is something that can be added without breaking backwards compatibility
[13:51:33] <SiegeLord> (assuming it's something like &var)
[13:52:05] *** Quits: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com) (Ping timeout)
[13:52:11] <doomlord_> it seems the way i was trying to use the module system was "wrong"..
[13:54:17] <doomlord_> seems it is indeed easier to have some root bring everything in and individual modules just specify namespaces for their own benefit
[13:54:32] <doomlord_> instead of the modules creating a dependancy graph themse;ves
[13:55:04] <cmr> doomlord_: yeah
[13:55:18] <cmr> that's how it was intended to be used I think, other usages quickly become awkward
[13:56:25] <cmr> dbaupp: some measure of central tendency yeah
[13:56:51] <cmr> dbaupp: they're all useful numbers
[13:57:40] <dbaupp> cmr: either the "define a heirarchy with `mod foo { mod bar; mod baz; }` in the crate", or "put `mod bar; mod baz;` in the file containing foo" work
[13:58:18] <dbaupp> cmr: the former is best when foo contains little other than modules/reexports, the latter for when it contains significant code.
[13:58:31] <dbaupp> (if you like separating things across files)
[13:58:45] <jensnockert> Prayer-time \o/
[13:59:03] <jensnockert> (As in, changing random stuff and hoping rustc still builds itself)
[13:59:14] <dbaupp> cmr: well, the variance/standard deviation (measures of central tendency) probably aren't that useful for measure total memory use ;P
[13:59:20] <dbaupp> *measuring/comparing
[13:59:36] <dbaupp> cmr: it's just the mean is more stable with respect to the linker peaks
[13:59:54] <dbaupp> since rust doesn't actually have a huge amount of control over that
[13:59:58] <cmr> mean is a measurement of central tendency too
[14:00:05] *** Joins: relistan_ (relistan@A7E4EF66.4C1F25E9.4BA0249.IP)
[14:00:32] <dbaupp> (I guess so)
[14:00:54] <dbaupp> yeah, anyway, I'll implement that sometime.
[14:01:05] <cmr> not really important
[14:01:10] <cmr> I think what you have now is awesome
[14:01:15] <SiegeLord> Median is resistant to outliers a bit
[14:01:15] *** Quits: relistan (relistan@A7E4EF66.4C1F25E9.4BA0249.IP) (Ping timeout)
[14:01:16] *** relistan_ is now known as relistan
[14:02:29] <dbaupp> SiegeLord: right, however, there are ~100,000 observations, so outliers aren't particularly worrisome
[14:03:07] *** Joins: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk)
[14:03:23] <mark_edward> cmr: https://github.com/MarkJr94/bzip2rs
[14:03:36] <dbaupp> (and measuring the outliers is actually sorta the point, since they're the points of worst memory pressure; except we're emphasising the linker memory use a lot, rather than the memory use of the actual rustc program.)
[14:03:55] <cmr> dbaupp: it'd probably be useful to separate pre-llvm from llvm+linker
[14:04:08] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[14:04:16] <dbaupp> cmr: yeah, that would be
[14:05:03] <SiegeLord> What's the point of worrying about rustc memory usage if the linker is the actual problem :P
[14:05:13] <cmr> SiegeLord: it's a measure of our efficiency
[14:05:26] <cmr> the linker isn't really a problem, it's just a spike from the baseline
[14:06:07] <cmr> mark_edward: classy usage of macros
[14:06:41] <mark_edward> thanks! Does it look like it does what you want it to do?
[14:06:50] <cmr> If only we had a way to guarantee the size of C-style enums :\
[14:07:53] <cmr> Yes
[14:08:17] <jensnockert> cmr: Aren't they int unless they are fancy?
[14:08:20] <mark_edward> yeah, i know. i had an error mixing up BZ_OK and BZ_RUN_OK earlier because they're both zero
[14:08:31] <mark_edward> jensnockert: i think they are a rust i32
[14:08:34] <cmr> Ideally we'd have a trait Compressor in extra, which bz_stream would impl
[14:08:38] <cmr> jensnockert: Who knows
[14:08:40] <cmr> it's unspecified
[14:08:49] <jensnockert> mark_edward, cmr: That would match C, which is fineâ€¦
[14:09:24] <mark_edward> well bz_stream is the C struct, that's hidden from library users
[14:09:27] <jensnockert> cmr: Isn't the Rust spec "Whatever rustc does at this moment"
[14:09:39] <cmr> jensnockert: only matches C on x86, on ARM enums are the smallest size possible by default
[14:09:52] <cmr> jensnockert: well yes, but it's intentionally unspecified, for when we do have a spec :p
[14:10:30] <cmr> mark_edward: I meant Bzip2Decompressor/Bzip2Compressor
[14:10:57] <mark_edward> oh yeah. but how would you propose getting a new thing into extra?
[14:11:13] <cmr> just open a PR adding the appopriate file to it :p
[14:11:18] <SiegeLord> An automatic binding generator might abstract away these differences, one day
[14:12:00] <jensnockert> cmr: Oh, yeah, it seems like some ARM systems use short enums by default :S
[14:12:18] <cmr> I know gcc does, dunno about clang
[14:12:44] <cmr> worst part is that enums aren't a part of any abi :\
[14:12:47] *** Joins: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[14:14:02] <cmr> `supertraits: @mut HashMap<ast::def_id, @~[@TraitRef]>`
[14:14:15] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Quit: Leaving.)
[14:14:27] <mark_edward> cmr: do you think there could be some sort of compression iterator?
[14:14:28] <cmr> hello, 5 layers of indirection
[14:14:40] <cmr> mark_edward: perhaps
[14:14:50] <jensnockert> cmr: Depends on the ABI, the Linux ARM ABI uses int enums.
[14:14:51] <cmr> A stream compressor, accepting fixed-size blocks, perhaps?
[14:15:02] <jensnockert> cmr: While others do not, Android I suppose?
[14:15:17] <engla> cmr: just think about it as a linked list
[14:15:18] <mark_edward> maybe it could be Iterator<&[u8]>?
[14:15:26] <engla> unfortunately, you always want the tail
[14:16:09] <cmr> jensnockert: well I haven't seen it as part of any psABI's, where is the linux arm abi documented?
[14:16:11] *** Quits: achim (achim@48D08254.C47AE098.3170947E.IP) (Quit: Computer has gone to sleep.)
[14:16:30] <jensnockert> cmr: http://wiki.debian.org/ArmEabiPort#Enum_sizes for example
[14:17:44] <dbaupp> mark_edward: it'd nice to be able to avoid allocations
[14:18:08] <dbaupp> mark_edward: so Iterator<&[u8]> would be nice if it could work
[14:18:12] <mark_edward> dbaupp: that's right! I think i can see how i'd pull that off...
[14:18:22] *** Joins: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[14:18:41] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[14:18:50] <cmr> mark_edward: if you do end up adding a generic interface, you should port extra::deflate to it
[14:20:16] <mark_edward> there doesn't seem to be an extra::deflate or std::deflate...
[14:21:01] <cmr> oh right, it's just extra::flate
[14:21:15] <cmr> such a dumb name
[14:22:16] <engla> struct fields are called fields rather than members in Rust right?
[14:22:37] <bstrie> engla: it's pretty unambiguous to refer to them as either
[14:22:43] <cmr> engla: seems that way most of the time
[14:22:45] <thiez> you can't go wrong with 'member fields'
[14:22:46] <cmr> I've seen both
[14:22:54] <mark_edward> just call methods methods
[14:22:55] <engla> hehe ok
[14:23:00] <Ms2ger> Field members?
[14:23:20] <bstrie> mark_edward: I call methods "member field functions"
[14:23:34] <mark_edward> bstrie: really????
[14:23:34] <cmr> and "static methods" associated functions
[14:23:42] <bstrie> mark_edward: no :)
[14:23:57] <bstrie> static associated member field functions
[14:24:00] <bstrie> SAMFF
[14:24:04] <mark_edward> oh ok... so confusing
[14:24:14] <engla> bstrie: you should have a membership card for that
[14:24:15] <bstrie> come on folks, C++ is KILLING US with its acronyms
[14:24:26] <Ms2ger> SFINAE?
[14:24:26] <bstrie> SFINAE? we can't compete with this
[14:24:29] <mark_edward> all i know is RAII and SFINAE
[14:24:34] <Ms2ger> bstrie, :D
[14:24:45] <engla> SFINAE is the most ridiculous
[14:24:53] <mark_edward> i've yet to understand what it means
[14:24:58] <bstrie> the best we have is INWHTMFABA
[14:25:00] <mark_edward> and i'm pretty sure i've used it a few times
[14:25:14] <cmr> bstrie: you just bashed keys for that one :p
[14:25:23] * Yoric is DDG-ing these acronyms.
[14:25:42] <dbaupp> "Imagine Never Hearing The Words ... Again" is Rust's catchprase
[14:25:46] <bstrie> cmr: not quite, there's some finesse involved
[14:25:53] <dbaupp> (well, also "Must Trust Rust")
[14:26:05] <bstrie> In Rust We Trust
[14:26:06] <cmr> I thought it was The Phrase...
[14:27:43] <jensnockert> In rust we trust seems very Minmatar/EVE Online.
[14:28:21] <engla> dbaupp: that's great
[14:28:27] <engla> imagine..
[14:29:16] <dbaupp> engla: (aatch came up with that one)
[14:31:44] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[14:32:15] <mark_edward> associated types would be useful here
[14:32:44] *** Joins: eagen (eagen@8737942B.7A99C13A.B7961A98.IP)
[14:33:07] *** Quits: fabiand (fabiand@moz-DDE1FFB.adsl.alicedsl.de) (Quit: Verlassend)
[14:33:12] *** Joins: fabiand (fabiand@moz-DDE1FFB.adsl.alicedsl.de)
[14:33:44] *** Quits: eagen (eagen@8737942B.7A99C13A.B7961A98.IP) (Client exited)
[14:34:27] *** Quits: relistan (relistan@A7E4EF66.4C1F25E9.4BA0249.IP) (Input/output error)
[14:34:32] *** Joins: relistan (relistan@A7E4EF66.4C1F25E9.4BA0249.IP)
[14:34:36] <dbaupp> where's aatch when you want to speak to him? :(
[14:34:42] <cmr> I know!
[14:34:47] <cmr> He's always around when you don't want him
[14:34:52] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[14:35:15] <dbaupp> heh
[14:37:37] <dbaupp> cmr: the time machines almost out of June
[14:37:48] <cmr> good
[14:37:52] * dbaupp wonders how far it can go back before explosions happen
[14:38:09] <cmr> in theory rustc *always* compiles for a given PR...
[14:38:12] <Seldaek> Gee. Sometimes I feel java developers shouldn't be allowed to touch other languages. I call for a quarantine!
[14:38:29] <Seldaek> the urge to slack off doing rust instead of dealing with this is strong
[14:38:43] <cmr> I think I'm using the most generic build commands..
[14:38:59] <dbaupp> cmr: yeah
[14:39:17] *** Quits: roo (jesse.rudo@moz-B7585E4C.dynamic.ip.windstream.net) (Ping timeout)
[14:39:22] <dbaupp> cmr: I was thinking that maybe build dependendencies might've changed, or something
[14:39:24] <cmr> anyway I plan on resetting the time machine after it gets to maybe 0.5
[14:39:26] <cmr> Maybe!
[14:39:29] <dbaupp> *dependencies
[14:39:35] <dbaupp> cmr: right, yeah
[14:39:48] <dbaupp> the historical data is "cute" rather than particularly useful.
[14:39:49] <cmr> at recent paces the time machine benches 2 PRs a week
[14:40:32] * dbaupp should set it up to show tags too
[14:40:37] * dbaupp files a bug
[14:40:46] <cmr> git name-rev
[14:40:50] <cmr> quite useful
[14:40:52] <engla> anyone want to give feedback on a doubly-linked list to replace extra::dlist (but not reimplement its features). feel free to say it's crap.
[14:40:55] <engla> https://gist.github.com/anonymous/b69277885e0b3918da28
[14:41:00] <cmr> it's utter crap
[14:41:06] <cmr> I can tell without even clicking the link
[14:41:08] <cmr> :P
[14:41:12] <engla> oh crap
[14:41:17] <engla> hey I can bribe you cmr
[14:41:45] <dbaupp> cmr: yeah, the problem is actually get the data on to the website...
[14:41:54] <dbaupp> javascript isn't my favourite language
[14:42:02] <engla> look cmr, benchmarks to compare it with  vec, deque and dlist.. https://gist.github.com/anonymous/18756d86d1dbcec32d73
[14:42:17] <cmr> ohhh now you've got me
[14:42:27] *** Joins: roo (jesse.rudo@moz-B7585E4C.dynamic.ip.windstream.net)
[14:42:48] <engla> this linked list's performance is totally dominated by the 50 ns it takes to execute  ~Node{... }
[14:42:54] <engla> as in do the allocation
[14:42:56] <engla> because it's naive
[14:43:01] <jensnockert> dbaupp: I always try to remember that it was hacked together in two weeks when I get those feelings.
[14:43:41] <dbaupp> jensnockert: heh, I've also got "using d3 for the first time ever" as an excuse
[14:44:00] * dbaupp should probably rewrite it now that he has more experience
[14:44:05] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[14:44:26] <bstrie> dbaupp: rewrite javascript? you might want to check out #spidermonkey
[14:44:42] <cmr> engla: so why haven't you opened a PR with these benchmarks yet!?!?! https://github.com/mozilla/rust/issues/7532
[14:44:44] <jensnockert> bstrie: RUSTMONKEY!!!11!
[14:44:49] <dbaupp> can't we all just run Rust in the web browser ;(
[14:44:53] *** Quits: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Ping timeout)
[14:44:56] <engla> hehe ok cmr 
[14:44:57] <cmr> dbaupp: yes, emscripten
[14:45:06] <engla> where in the tree should they go?
[14:45:17] <cmr> I dunno make something up
[14:45:31] <cmr> maybe you could restructure src/test/benches while you're at it
[14:45:39] <cmr> add a shootout subdir, and a datastructure subdir
[14:45:41] <dbaupp> cmr: do you wanna get it to work? ;P
[14:45:50] <cmr> dbaupp: nope! :p
[14:46:00] <dbaupp> cmr: I *dare* you
[14:46:07] <cmr> I wonder if asm.js will be available as a target triple one day...
[14:46:18] <dbaupp> that'd be cool
[14:47:07] <jensnockert> The problem with asm.js is that it tries to be a clean slateâ€¦
[14:47:08] *** Quits: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au) (Quit: gavinb)
[14:47:28] * jensnockert wants to be able to write most in JS, and then a small piece with asm.js.
[14:48:19] <dbaupp> as in, literally inline "assembler" for javascript?
[14:49:42] <nmatsakis> jensnockert: asm.js can call normal JS.
[14:50:09] <mark_edward> what is Rust naming conventions for setters and getters
[14:50:13] <jensnockert> nmatsakis: But you cannot pass cool stuff between the domains, likeâ€¦ ArrayBuffers.
[14:50:18] <nmatsakis> jensnockert: true.
[14:50:20] <bstrie> iirc the problem is that asm.js is even more inscrutable than regular asm :P
[14:50:22] <dbaupp> mark_edward: not having them?
[14:50:36] <mark_edward> true
[14:50:41] <jensnockert> nmatsakis: Kind of pointless if I can only shuffle around floats imho. Might be me missing a use-case though.
[14:50:50] <mark_edward> but what if the member needs to maintain a special range?
[14:50:52] <dbaupp> mark_edward: but it seems that getters are often methods of the same name as the field
[14:51:07] <nmatsakis> mark_edward: personally I'd say foo() and set_foo()
[14:51:16] <nmatsakis> mark_edward: but I don't think we have much of a convention
[14:51:32] <bstrie> I'm glad that rust doesn't have special syntax for automatically defining getters and setters
[14:51:36] <bstrie> like, so glad
[14:51:36] <mark_edward> okay, thanks.
[14:51:39] <bstrie> irrationally happy
[14:51:44] <dbaupp> bstrie: we could
[14:51:50] <bstrie> we shouldn't!
[14:51:51] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[14:51:53] * dbaupp quickly whips up a syntax extension
[14:52:14] <jensnockert> bstrie: Don't we already have automatic getters / setters?
[14:52:20] * cmr likes 'properties'
[14:52:27] <cmr> very handy
[14:52:32] <bstrie> jensnockert: no? at least not that I've ever heard of
[14:52:34] <cmr> Not suitable for rust, but very handy
[14:52:42] <dbaupp> struct Foo { #[bstrie] x: int } will create fn set_the_value_of_the_field_x() and fn get_the_value_of_the_field_x()
[14:52:42] <jensnockert> bstrie: randomstruct.fieldname ?
[14:52:59] <bstrie> dbaupp: you're a monster
[14:53:06] <cmr> hahah
[14:53:16] <doomlord_> my expereince of getters/setters in in c++ and i hate them there.. but working with rust with traits making abstraction layers is a lot more natural
[14:53:17] * dbaupp likes the brevity of "bstrie"
[14:53:31] <dbaupp> (wouldn't want to be forced to type too much)
[14:54:15] <dbaupp> doomlord_: although setters/getters rarely belong in traits
[14:54:27] <engla> dbaupp: *member field
[14:54:39] <dbaupp> (traits are normally capturing higher level behaviours, I guess)
[14:54:40] <bstrie> the classic reason for getters and setters EVERYWHERE is that if you later want to do something special there you'd have to change the API. well, 1) nobody ever does that, and 2) just change the friggin API and stop worrying
[14:55:07] <SiegeLord> I do it all the time >.>
[14:55:10] <bstrie> "Dr. Changelove OR How I Learned To Stop Worrying And Love Semantic Versioning"
[14:55:15] <Ms2ger> Later wanting to do something special?
[14:55:18] <SiegeLord> Except I use properties, so it doesn't change the syntax
[14:55:34] <cmr> It changes the ABI
[14:55:42] <cmr> which is worse, noone cares about the API
[14:55:57] <cmr> at least, I don't :p
[14:56:09] <doomlord_> i started doing it a little bit when faced with ambiguity.. should a vector be struct {x,y,z}, a tuple (T,T,T) or [T,..3] ? well.. if i have a trait i can take code from either representation
[14:56:31] <bstrie> that's fair
[14:56:33] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[14:56:33] *** ChanServ sets mode: +o dherman
[14:56:37] <dbaupp> doomlord_: right, sounds reasonable
[14:56:46] <doomlord_>  i just dont know which will work out best in rust now..
[14:57:05] <bstrie> my objection is towards the school I was trained in, which is that EVERY PUBLIC FIELD should have a getter and setter
[14:57:12] <bstrie> which is insanity
[14:57:17] <doomlord_> tuples have a big draw, being the shiny new thing i dont have in C++, and discovering you can destructure them as args makes me keen on them
[14:57:24] <dbaupp> (probably not [T, .. 3], fixed length vectors are fairly horrible atm.)
[14:57:28] <cmr> bstrie: that's what they tought in AP CS too
[14:57:31] <cmr> it's awful
[14:57:33] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[14:57:36] <cmr> java is an awful language to teach
[14:57:38] <jensnockert> dbaupp: What's wrong with [T, ..3] ?
[14:57:43] <cmr> you barely learn any concepts :\
[14:57:48] <dbaupp> doomlord_: you can destructure structs in arguments
[14:57:50] <doy> well, it makes sense in certain kinds of languages
[14:57:52] <dbaupp> jensnockert: language support
[14:58:02] <dbaupp> jensnockert: I really like the concept/try to use it
[14:58:15] <doomlord_> heh what else dont i know yet 
[14:58:21] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[14:58:25] <dbaupp> jensnockert: but they don't implement *any* traits, since each trait would have to be implemented for each size
[14:58:25] <doy> just not things like java or c++, which is where people normally introduce the concept
[14:58:34] *** Joins: Blei (philipp@moz-650B9C6A.cust.bluewin.ch)
[14:58:42] <jensnockert> dbaupp: Unlike the Tuples?
[14:58:59] <jensnockert> dbaupp: Or the structs?
[14:59:03] <dbaupp> jensnockert: right, but [int, .. 628] is actually useful, (int, int, int, ..., int) isn't
[14:59:07] <doomlord_> one thing i like about tuples - by NOT making a custom type, you're creating/depending on less context
[14:59:21] <SiegeLord> I don't think I've ever been inconvenienced by a changed ABI
[14:59:24] *** Quits: dcamp (dcamp@moz-930D5B64.hsd1.wa.comcast.net) (Quit: Linkinus - http://linkinus.com)
[14:59:34] <jensnockert> dbaupp: I agree that the support should be better, just not that it is worse than the other types.
[14:59:36] <engla> the important part of tuples is that you have type tuples, (T, U) etc
[14:59:40] <cmr> SiegeLord: it's not so much for programmers as it is for maintainers/system builders/random users
[14:59:51] <cmr> Also shitty libraries that don't use soname properly, or semver
[15:00:10] <cmr> see: dependency hell
[15:00:11] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[15:00:56] <dbaupp> jensnockert: I guess
[15:01:20] *** Joins: jdm (jdm@F2D29657.F60B0462.67AC9B1.IP)
[15:01:23] <dbaupp> jensnockert: (I keep seeing it pop up with #[deriving] though, because it makes horrible error messages if you try to derive on a struct with [,..] in it.)
[15:01:40] *** Joins: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[15:01:48] <jensnockert> dbaupp: Isn't #[deriving] just a hack though?
[15:02:01] <cmr> hack? deriving is amazing
[15:02:17] <jensnockert> amazing hack?
[15:02:18] <dbaupp> (not worse than other types that don't implement the derived trait, but it's inconsistent with ~[], and a fairly common thing to put in structs)
[15:02:19] <bjz> dbaupp: is that where we might need constants in type parameter lists?
[15:02:30] <dbaupp> bjz: it'd be amazing, yes
[15:02:32] <nielsle> Are there plans for using deriving to create something like getters and setters?
[15:02:43] <dbaupp> bstrie: ^
[15:02:47] <roo> XD
[15:02:47] <cmr> #[deriving(bstrie)]
[15:02:48] <dbaupp> nielsle: run
[15:02:49] <jensnockert> dbaupp: But ~[] and [T, ..n] are totally unrelated types, are they not?
[15:02:50] <engla> deriving is very practical
[15:02:52] <nielsle> hehe
[15:02:59] <dbaupp> jensnockert: yes, but that look the same
[15:03:16] <bjz> dbaupp: impl<T,N:uint> Foo for [T,..N] { ... }
[15:03:21] <jensnockert> dbaupp: True, the syntax is totally silly.
[15:03:30] <bstrie> nielsle: ...
[15:03:32] <dbaupp> jensnockert: in any case, #[deriving] just reads the type definition and outputs some impls into the ast, and lets the type checker deal with any mistakes
[15:03:39] <bstrie> :P
[15:03:56] <dbaupp> jensnockert: well, I quite like the syntax... ;P
[15:03:56] <bstrie> from what I hear deriving is a "hack" relative to how it's implemented in haskell
[15:03:56] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Connection reset by peer)
[15:03:58] <bstrie> or something
[15:04:12] * dbaupp knows how it's implemented in Rust, but not in Haskell
[15:04:16] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[15:04:18] <jensnockert> dbaupp: Exactly, couldn't that be done with some sort of macro?
[15:04:23] <doomlord_> pub fn v3cross<T:Num>((x0,y0,z0):(T,T,T),(x1,y1,z1):(T,T,T))->(T,T,T) {
[15:04:24] <doomlord_> 	((y0*z1-z1*y0),(z0*x1-x0*z1),(x0*y1-y0*x1))}
[15:04:29] <dbaupp> jensnockert: what?
[15:04:32] <dbaupp> jensnockert: deriving?
[15:04:38] <jensnockert> dbaupp: Yes?
[15:04:43] <dbaupp> it is one
[15:04:44] <bstrie> dbaupp: I think deriving is supposed to be somewhat generic in haskell? ie that it can derive itself to some degree
[15:04:50] <bstrie> but I really have no clue
[15:05:19] <doomlord_> vector maths implementable without declaring custom types, nice.
[15:05:25] <dbaupp> well, strictly, it's a syntax extension (i.e. macro written in Rust), but an attribute one, rather than an expr/item one.
[15:06:16] <dbaupp> bstrie: oh, yeah, iirc, in Haskell you can implement a few type classes and that makes a type class deriveable, or something
[15:06:37] <dbaupp> (Rust's deriving is probably pretty close to being able to do that, with some massaging.)
[15:07:18] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Ping timeout)
[15:07:27] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[15:07:31] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[15:07:33] <dbaupp> and is a feature that would probably only work cross-crate, not within the original crate (for a change)
[15:07:36] <mark_edward> is there anyway to go from a *T to an &[T] without copying?
[15:07:37] <dbaupp> *its
[15:07:53] <cmr> mark_edward: Yes, but not safely
[15:08:00] <dbaupp> mark_edward: there's probably a from_ptr or from_buf functions somewhere in std::vec
[15:08:10] <cmr> http://static.rust-lang.org/doc/std/vec_raw.html#function-from_buf_raw
[15:08:17] <dbaupp> (possibly in std::vec::raw)
[15:08:18] <mark_edward> cmr: that copies
[15:08:28] <cmr> Oh look that makes a ~[T]
[15:08:30] <cmr> how silly
[15:08:31] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[15:08:44] <cmr> buf_as_slice maybe?
[15:08:54] <cmr> needs do-notation though
[15:08:59] <mark_edward> but then how can i return that slice?
[15:09:02] <cmr> right
[15:09:06] *** Joins: mib_il5ws1 (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP)
[15:09:15] *** Joins: dan_johnsin (dan_johnsi@6902762D.11B071D.FB9A45AF.IP)
[15:09:16] <cmr> mark_edward: you can just use the SliceRepr and a few transmutations
[15:09:19] <engla> mark_edward: give it a lifetime with cast::copy_lifetime?
[15:10:01] <mark_edward> can SLiceRepr be transmuted into a &[T]?
[15:10:08] <cmr> Yes
[15:10:08] <dbaupp> mark_edward: yes
[15:10:21] <cmr> a SliceRepr is what a &[T] *is*
[15:10:28] <cmr> (layout wise)
[15:10:36] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Input/output error)
[15:10:42] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[15:10:50] <mark_edward> oh okay! that should solve my problem. and then i'll need to do some lifetime cast as well...
[15:11:37] <dbaupp> cast::transmute handles all your needs
[15:11:44] <dbaupp> (a one-stop shop)
[15:11:53] <cmr> transmute does lifetimes too?
[15:11:55] <cmr> fancy
[15:12:02] <cmr> truly deep magick
[15:12:07] <engla> transmute is A to B, no questions
[15:12:19] *** Quits: rhodesd (none@3646D136.4C5731DA.F395EA5B.IP) (Ping timeout)
[15:12:35] *** Quits: novabyte (Instantbir@moz-3E0F9699.cable.virginmedia.com) (Quit: bye bye)
[15:12:39] <dbaupp> rusti: let x = 1; let y: &'static int = cast::transmute(&x); y
[15:12:40] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/CCWi
[15:12:57] <dbaupp> rusti: let x = 1; let y: &'static int = unsafe{std::cast::transmute(&x)}; y
[15:12:58] -rusti- &1
[15:13:08] <engla> it does have some questions though.. type sizes or so
[15:13:32] <dbaupp> rusti: let y: &'static int = {let x = 1; std::cast::transmute(&x)}; let z = 2; y
[15:13:33] -rusti- <anon>:7:43: 7:68 error: call to unsafe function requires unsafe function or block
[15:13:33] -rusti- <anon>:7          let y: &'static int = {let x = 1; std::cast::transmute(&x)}; let z = 2; y
[15:13:33] -rusti-                                                     ^~~~~~~~~~~~~~~~~~~~~~~~~
[15:13:33] -rusti- error: aborting due to previous error
[15:13:34] -rusti- application terminated with error code 101
[15:13:45] <dbaupp> rusti: let y: &'static int = {let x = 1; unsafe{std::cast::transmute(&x)}}; let z = 2; y
[15:13:46] -rusti- <anon>:7:82: 7:83 warning: unused variable: `z` [-W unused-variable (default)]
[15:13:46] -rusti- <anon>:7          let y: &'static int = {let x = 1; unsafe{std::cast::transmute(&x)}}; let z = 2; y
[15:13:46] -rusti-                                                                                            ^
[15:13:46] -rusti- &1
[15:13:48] *** Quits: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net) (Quit: echristo)
[15:13:51] *** Joins: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[15:13:58] <dbaupp> engla: and a hilariously bad error message when they don't match
[15:14:13] <engla> is it the non-scalar cast thing?
[15:14:26] <dbaupp> nah, the span points to the very start of the file
[15:14:36] <cmr> good 'ole dummy_sp
[15:14:41] <dbaupp> rusti: std::cast::transmute::<u16,u8>(1)
[15:14:41] -rusti- <anon>:7:9: 8:5 error: call to unsafe function requires unsafe function or block
[15:14:42] -rusti- <anon>:7          std::cast::transmute::<u16,u8>(1)
[15:14:42] -rusti- <anon>:8     };
[15:14:42] -rusti- error: aborting due to previous error
[15:14:42] -rusti- application terminated with error code 101
[15:14:49] <dbaupp> rusti: unsafe{std::cast::transmute::<u16,u8>(1)}
[15:14:50] -rusti- <anon>:1:0: 1:0 error: transmute called on types with different sizes: u16 (16 bits) to u8 (8 bits)
[15:14:50] -rusti- <anon>:1 #[allow(default_methods)];
[15:14:50] -rusti-          ^
[15:14:50] -rusti- application terminated with error code 101
[15:15:01] <engla> the error message is good though
[15:15:05] <dbaupp> right
[15:15:14] <dbaupp> but it's not particularly helpful
[15:15:19] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Ping timeout)
[15:15:20] * dbaupp was exaggerating
[15:15:21] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[15:15:37] <cmr> Hyperbole is killing this generation!
[15:15:45] <dbaupp> https://github.com/mozilla/rust/issues/7316
[15:15:46] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[15:16:12] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[15:17:20] *** Joins: rhodesd (none@3646D136.4C5731DA.F395EA5B.IP)
[15:17:23] *** zz_kimundi is now known as kimundi
[15:18:02] *** Joins: lmandel (lmandel@F2D29657.F60B0462.67AC9B1.IP)
[15:18:25] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Input/output error)
[15:18:32] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[15:20:00] *** Quits: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Ping timeout)
[15:20:03] *** Joins: azita (Azita@2557E599.66715431.D25A875A.IP)
[15:20:41] <engla> ref mut knots are killing me
[15:20:52] *** Quits: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP) (Client exited)
[15:21:49] <engla> so tempting to take the transmute_mut sword
[15:25:23] *** Joins: sanxiyn (tinuviel@858F408C.B797260D.EF43EC08.IP)
[15:25:27] <sanxiyn> I need help with lint system...
[15:25:29] *** Joins: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP)
[15:25:38] <doomlord_> is there something like type-of to extract a type from a type .. like when creating a class with internal typedefs in c++
[15:25:53] <sanxiyn> error: internal compiler error: unprocessed lint
[15:26:09] <sanxiyn> This is span_bug at the end of lint.rs
[15:26:16] <doomlord_> eg if i have a type variable for a vector V =Vec3<T> ... can i get the T somehow from code taking V
[15:26:38] <sanxiyn> doomlord_: As far as I know, no.
[15:26:53] <doomlord_> granted its not essential
[15:27:04] <doomlord_> i can live without it 
[15:27:27] <doomlord_> i can make generic code take the 'T' and generate the 'Vec3' instead a lot of the time
[15:28:02] <dbaupp> sanxiyn: are you adding the lint?
[15:28:08] <sanxiyn> dbaupp: yes
[15:28:39] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[15:29:03] <sanxiyn> dbaupp: It seems that some nodes are not visited by the visitor but I can't figure out what's going on
[15:29:18] <dbaupp> sanxiyn: can I see a diff? :)
[15:29:28] <sanxiyn> wait a min
[15:30:17] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[15:30:40] *** Joins: sk_ (sk@43301EF8.3DDD1ABD.33B96495.IP)
[15:31:08] <mark_edward> i'm getting this error
[15:31:09] <mark_edward> error: transmute called on types with different sizes: &'r [u8] (128 bits) to &'r std::vec::raw::SliceRepr (64 bits)
[15:31:22] <mark_edward> what do i do!
[15:31:35] *** Quits: sk (sk@D75E713A.1D222DF7.24EDD759.IP) (Ping timeout)
[15:31:37] <cmr> mark_edward: you want to be casting to a SliceRepr, not a &SliceRepr
[15:31:47] <mark_edward> ah i see.
[15:33:21] *** Quits: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP) (Client exited)
[15:34:21] *** Joins: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP)
[15:35:22] *** Joins: bent (chatzilla@F2D29657.F60B0462.67AC9B1.IP)
[15:36:23] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[15:36:56] <sanxiyn> dbaupp: https://github.com/sanxiyn/rust/commits/qualification-lint
[15:37:04] <sanxiyn> dbaupp: https://github.com/mozilla/rust/issues/2551
[15:37:25] *** Joins: nano (nano@moz-972880B.superkabel.de)
[15:37:50] <dbaupp> sanxiyn: ah, right
[15:39:28] <sanxiyn> (It does work for toy examples)
[15:40:04] <sanxiyn> Like, using both null and ptr::null
[15:40:59] <sanxiyn> ICE is caused by codes like fn f(w: @io::Writer)
[15:41:17] <sanxiyn> Lint marks io::Writer as overqualified name, but it is somehow never processed
[15:42:34] <dbaupp> hm, I don't know
[15:42:39] <dbaupp> acrichto: ^ ?
[15:42:53] <sanxiyn> Is there a way to look at all node_id's and what they point to?
[15:43:02] <sanxiyn> This will greatly help debugging this
[15:44:00] <dbaupp> sanxiyn: is it only in function defintions?
[15:44:09] <dbaupp> (that the ICE happens)
[15:44:15] <sanxiyn> dbaupp: I don't know
[15:44:35] <dbaupp> e.g. does `let w: @io::Writer;` cause the same thing?
[15:44:43] <sanxiyn> ok wait a min
[15:45:47] <sanxiyn> dbaupp: Yes that causes the same
[15:46:19] <dbaupp> it's possibly related to types
[15:50:10] *** Joins: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com)
[15:50:51] *** Quits: fabiand (fabiand@moz-DDE1FFB.adsl.alicedsl.de) (Quit: Verlassend)
[15:51:14] <sanxiyn> dbaupp: Maybe id_visitor is buggy?
[15:51:30] *** Quits: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net) (Ping timeout)
[15:55:22] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[15:58:24] *** Joins: eschweic (Adium@2557E599.66715431.D25A875A.IP)
[15:59:04] <acrichto> sanxiyn: id_visitor is the place to look, make sure it's iterating over whatever node_id you need
[15:59:20] <sanxiyn> Yes, id_visitor *is* buggy
[15:59:22] <sanxiyn> One line fix
[15:59:31] <acrichto> sanxiyn: it in theory will iterate over all node_ids of the ast, but it doesn't actually (whatever originally used it probably didn't need it)
[15:59:41] *** Parts: glinscott (garylinsco@789A6618.53EB7C1.FFFE3AA.IP) ()
[16:01:12] *** Quits: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com) (Ping timeout)
[16:01:45] <jedestep> rusti: 4f.pow(&4f)
[16:01:46] -rusti- 256
[16:02:02] <jedestep> 4u.pow(&4u)
[16:02:08] <jedestep> rusti: 4u.pow(&4u)
[16:02:09] -rusti- <anon>:7:9: 8:5 error: type `uint` does not implement any method in scope named `pow`
[16:02:09] -rusti- <anon>:7          4u.pow(&4u)
[16:02:09] -rusti- <anon>:8     };
[16:02:09] -rusti- error: aborting due to previous error
[16:02:10] -rusti- application terminated with error code 101
[16:05:31] *** kimundi is now known as zz_kimundi
[16:06:03] *** Quits: pyrac (pyrac@moz-88F57AAB.math.u-bordeaux1.fr) (Ping timeout)
[16:06:12] *** Joins: eholk (eholk@moz-A76CD101.uconnect.utah.edu)
[16:06:21] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[16:07:03] <bjz> nmatsakis: ping
[16:07:25] *** Joins: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[16:09:16] <jensnockert> bjz: Rebased the freestanding numeric functions at last.
[16:09:38] <bjz> jensnockert: yay
[16:10:37] <nmatsakis> bjz: pong
[16:11:54] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[16:13:32] *** Quits: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu) (Client exited)
[16:14:36] <jedestep> rusti: 4i.pow(&4i)
[16:14:37] -rusti- <anon>:7:9: 8:5 error: type `int` does not implement any method in scope named `pow`
[16:14:37] -rusti- <anon>:7          4i.pow(&4i)
[16:14:37] -rusti- <anon>:8     };
[16:14:37] -rusti- error: aborting due to previous error
[16:14:37] -rusti- application terminated with error code 101
[16:16:02] *** Quits: bytewise (bytewise@moz-649C630D.unitymediagroup.de) (Ping timeout)
[16:16:17] <bjz> jedestep: unfortunately we don't have integer pow methods yet
[16:16:46] *** Joins: bytewise (bytewise@moz-649C630D.unitymediagroup.de)
[16:16:48] <jedestep> bjz: was just checking :)
[16:17:01] <bjz> rusti: int::pow(4, 4)
[16:17:07] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/cbFE
[16:17:22] <bjz> hm
[16:17:38] <bjz> jedestep: we need some though
[16:18:03] <jensnockert> bjz: Do we have a list of missing stuff in num?
[16:18:14] <bjz> jensnockert: nope
[16:18:16] <jensnockert> bjz: And/or stuff to be trashed?
[16:18:24] <jensnockert> bjz: We should add it to the meta-bug.
[16:18:26] <bjz> jensnockert: nope
[16:18:34] <bjz> jensnockert: yep
[16:18:45] <roo> rusti: std::int::pow(4,4)
[16:18:45] <bjz> x)
[16:18:46] -rusti- 256
[16:18:53] <bjz> ohh, hehe
[16:18:57] <roo> ;P
[16:19:04] <bjz> thanks roo, showing my age there
[16:19:05] <jensnockert> I think I just killed that :S
[16:19:12] <nmatsakis> so are the rusti tests enabled?
[16:19:30] <nmatsakis> they...appear to be, but I thought someone told me that they were disabled?
[16:19:36] <bjz> nmatsakis: any word on extern fns?
[16:19:50] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[16:20:11] *** Quits: relistan (relistan@A7E4EF66.4C1F25E9.4BA0249.IP) (Ping timeout)
[16:20:28] <nmatsakis> bjz: not really, I have been rebasing but haven't had time to examine the problem any further,
[16:20:35] <nmatsakis> bjz: I think pcwalton said he wanted to take a look,
[16:20:47] <nmatsakis> bjz: but afaik he has not either. I will try to touch base with him about that today.
[16:20:53] <bjz> nmatsakis: coolies
[16:21:07] <sanxiyn> nmatsakis: https://github.com/mozilla/rust/commit/f1159446ba85fbf6e1ab9ae1f412abddc195142d ?
[16:22:25] <bjz> rusti: fn f() { println("hi") } static F: extern "Rust" fn() = f; F()
[16:22:26] -rusti- <anon>:7:68: 7:69 error: internal compiler error: Cannot translate def def_static({crate: 0, node: 15}, false) to a callable thing!
[16:22:26] -rusti- <anon>:7          fn f() { println("hi") } static F: extern "Rust" fn() = f; F()
[16:22:26] -rusti-                                                                              ^
[16:22:26] -rusti- application terminated with error code 101
[16:22:57] <nmatsakis> sanxiyn: hmm
[16:23:12] <bjz> nmatsakis: I think aatch|gone was saying that^ was temporary weridness
[16:23:29] <bjz> nmatsakis: will we be able to fix that in the future?
[16:24:09] <nmatsakis> bjz: fix what in the future? rusti?
[16:24:16] <cmr> the ICE right there
[16:24:24] <nmatsakis> oh
[16:24:28] <bjz> nmatsakis: fn f() { println("hi") } static F: extern "Rust" fn() = f; F()
[16:24:31] <cmr> :p
[16:24:45] *** Quits: bnicholson (bnicholson@moz-E98974C1.hsd1.ca.comcast.net) (Ping timeout)
[16:24:55] <bjz> nmatsakis: it's more important for static muts
[16:25:07] <nmatsakis> bjz: yeah, i'm ... surprised that fails. should be easy to fix.
[16:25:12] <bjz> nmatsakis: for getting extern fn pointers
[16:26:03] <engla> you can't put any  &'r fn() into ~Trait today. regardless of lifetime or bounds
[16:26:10] *** zz_kimundi is now known as kimundi
[16:26:32] <bjz> nmatsakis: would this be possible? unsafe fn f() { println("hi") } static F: extern "Rust" unsafe fn() = f; F()
[16:26:41] *** Joins: graydon (Adium@A5087023.2354C43D.D8E68FF6.IP)
[16:26:41] *** ChanServ sets mode: +qo graydon graydon
[16:26:57] <bjz> nmatsakis: oh wait: unsafe fn f() { println("hi") } static F: extern "Rust" unsafe fn() = f; unsafe { F() }
[16:27:11] *** dherman is now known as dherman-breakie
[16:27:43] <nmatsakis> bjz: something like that should be possible, yes.
[16:29:34] <cmr> jensnockert: seamless bignums would be supercool, once that patch lands
[16:30:08] <bjz> cmr: seamless?
[16:30:45] *** Joins: echristo (echristo@D423593A.D6CCE4AE.77834EAA.IP)
[16:30:48] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[16:30:51] <cmr> bjz: literals, comparison + ops with all the builtins
[16:31:02] <cmr> ie, feels like a native type
[16:31:09] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[16:31:09] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[16:31:24] *** Joins: eevee (eevee@moz-58058235.evrt.wa.frontiernet.net)
[16:31:44] <strcat> graydon: good news, no more exchange alloc headers - it landed
[16:31:46] <bjz> cmr: unfortunately we probably won't get an Assign trait, so we won't be able to do the literals
[16:31:55] *** Quits: Houm (Houm@moz-25669AA8.fbx.proxad.net) (Ping timeout)
[16:32:25] <cmr> bjz: I'd imagine the bignum type to be a language feature, with a #[lang="bignum"]
[16:32:44] *** Quits: graydon (Adium@A5087023.2354C43D.D8E68FF6.IP) (Quit: Leaving.)
[16:32:49] <doener> is the vg build still alive? ETA went down by 10 seconds in the last hour
[16:32:52] <bjz> cmr: https://github.com/mozilla/rust/issues/5992#issuecomment-17315976
[16:33:01] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[16:33:17] <bjz> cmr: why should it be a language feature?
[16:33:25] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[16:33:28] <cmr> bjz: so it could have a literal syntax?
[16:33:33] <jack> did the rustc prelude get io and str again?
[16:33:58] <jensnockert> cmr: What patch?
[16:34:04] <cmr> jensnockert: free function
[16:34:07] *** Joins: graydon (graydon@A5087023.2354C43D.D8E68FF6.IP)
[16:34:07] *** ChanServ sets mode: +qo graydon graydon
[16:34:22] <graydon> strcat: awesome!
[16:34:32] <graydon> strcat: noticable memory-use improvement?
[16:34:40] <cmr> graydon: not for rustc
[16:34:47] <cmr> actually got 50MB worse during linking
[16:34:55] <strcat> cmr: doubt that was me ;p
[16:34:55] <graydon> ?
[16:34:58] <strcat> graydon: rustc probably doesn't use enough
[16:35:07] <graydon> ok
[16:35:20] <strcat> graydon: ~int and ~(int, int) now use 75% less memory though
[16:35:23] *** Joins: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP)
[16:35:24] <cmr> http://huonw.github.io/isrustfastyet/mem/#48ad726,44770ae it wasn't anyone else
[16:35:28] <strcat> bumps them from the 64-byte size class to 16-byte
[16:35:33] <nmatsakis> strcat: I was that the patch landed, very nice
[16:35:35] <strcat> cmr: well I did add more code
[16:36:19] <strcat> graydon: anyway they point right at the data now so... technically they are FFI compatible too
[16:36:33] <strcat> but I don't know if that's a good idea, because MSVC doesn't support swapping out the malloc/free allocator
[16:36:36] <strcat> afaik
[16:36:38] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[16:37:04] <strcat> although right now you could receive malloc'ed things from C as ~ if you wanted
[16:37:11] <graydon> right. neat.
[16:37:12] *** Joins: Houm (Houm@moz-25669AA8.fbx.proxad.net)
[16:37:37] * strcat still needs to do ~[]
[16:39:41] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[16:39:42] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[16:41:17] *** Quits: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP) (Quit: Leaving.)
[16:41:57] *** Joins: seth (seth@moz-2C443A35.hsd1.co.comcast.net)
[16:42:00] *** Joins: eagen (eagen@15B176CF.7A99C13A.B7961A98.IP)
[16:42:13] *** Quits: sanxiyn (tinuviel@858F408C.B797260D.EF43EC08.IP) (Quit: Leaving)
[16:43:16] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[16:44:07] *** Joins: bnicholson (bnicholson@2557E599.66715431.D25A875A.IP)
[16:44:08] *** Joins: riley (riley@1A20C896.96FE09F3.3002A442.IP)
[16:45:29] *** Joins: fabiand (fabiand@moz-DDE1FFB.adsl.alicedsl.de)
[16:46:56] <doener> graydon: is linux1b still alive?
[16:47:20] *** Quits: riley (riley@1A20C896.96FE09F3.3002A442.IP) (Ping timeout)
[16:47:47] <graydon> maybe? I should probably take it out of the pool
[16:47:53] <graydon> it seems to time out anytime a build lands on it
[16:48:04] *** Joins: posco (oscarboyki@636AC086.5999CED5.71743E61.IP)
[16:49:03] *** Joins: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[16:49:41] <doener> oh, it's making progress again
[16:49:48] * strcat hopes he didn't break ~Trait with a 'static bound
[16:49:52] <strcat> it doesn't seem like it has tests
[16:49:56] *** Joins: achim (achim@moz-18A0BE5A.pools.arcor-ip.net)
[16:50:13] <engla> strcat: do you have any thoughts about a mut_iter that also implements methods to insert elements into the iterated container? did you already think about a design for this? ^^
[16:50:36] <strcat> engla: well that seems impossible for most of them
[16:50:44] <strcat> since vec/hashmap need to realloc
[16:50:52] <engla> I've got a use case for a linked list. https://gist.github.com/anonymous/0bb1a91c6917017d3d2b
[16:50:57] <graydon> doener: I don't think it's making progress. it won't let me ssh in.
[16:50:59] <strcat> treemap can make guarantees like that right now but a b-tree can't
[16:51:08] *** Joins: mark_edward (quassel@moz-4A5B1251.wisolt4.epbfi.com)
[16:51:18] <engla> strcat: the module could also use it internally
[16:51:18] <doener> graydon: ETA is going down
[16:51:27] <engla> and let it stay there
[16:51:28] <doener> graydon: didn't change for almost 2 hours
[16:51:34] <graydon> :(
[16:51:44] <strcat> graydon: yeah aatch started a snapshot and it took 10 hours
[16:51:47] <graydon> yeah, I think it's time to take it out of the pool
[16:51:47] <strcat> and I guess it timed out
[16:51:49] <strcat> ;p
[16:51:58] <graydon> did it run on 1a or 1b ?
[16:52:02] <strcat> 1b
[16:52:06] <graydon> right
[16:52:37] <graydon> wait
[16:52:42] <graydon> 1b or 2b?
[16:52:58] * strcat seems to remember it being 1b but...
[16:53:03] <graydon> oh gosh, 2b is entirely offline
[16:53:04] <doener> I mean 1b, see http://buildbot.rust-lang.org/builders/auto-linux-64-opt-vg/builds/332
[16:53:21] <strcat> graydon: mac5 is missing too
[16:53:27] <strcat> I thought that existed
[16:53:56] <strcat> the buildslaves decided to throw off their chains
[16:54:04] <graydon> brson turned it on on friday I think
[16:54:08] <strcat> ah
[16:54:10] <graydon> but it seemed to go quiet shortly thereafter
[16:54:17] <graydon> ran a few builds then stopped
[16:54:21] <graydon> I'll see if I can find it
[16:54:27] <graydon> this is all very disappointing :(
[16:54:37] <strcat> well at least it's landing things ;p
[16:54:52] <graydon> 1b is actually running ...
[16:54:58] <graydon> I mean, the machine's on
[16:55:00] <graydon> I am ssh'ed into it
[16:55:00] <strcat> graydon: it did do something weird where it ignored successful tests, and moved to the next PR
[16:55:01] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[16:55:04] <doener> yeah, seems to have recovered just now
[16:55:05] <strcat> it didn't report status at all
[16:55:10] <strcat> so I just merged it manually after the next one
[16:55:23] <strcat> maybe just API failures
[16:55:27] <graydon> 1b is virtualized
[16:55:37] <graydon> I am _so sick_ of virtualized machines
[16:55:45] <strcat> heh
[16:56:00] <graydon> the only reason it's in the cluster is ... (wait for it)
[16:56:21] <graydon> it's the centos machine running $ANCIENT_ENOUGH_LINUX that we don't acquire too many modern glibc symbols accidentally
[16:56:28] <graydon>  ( / libstdc++ symbols)
[16:56:29] <graydon> when we snapshot
[16:56:42] *** Joins: blaphmat (Mibbit@moz-C8F57D19.dynamic.tstt.net.tt)
[16:56:43] <graydon> it should only be used for snaps. and we need a better solution for those too.
[16:59:27] *** Quits: azita (Azita@2557E599.66715431.D25A875A.IP) (Quit: azita)
[16:59:51] *** Quits: eschweic (Adium@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[17:00:08] *** Joins: azita (Azita@2557E599.66715431.D25A875A.IP)
[17:00:18] *** Quits: azita (Azita@2557E599.66715431.D25A875A.IP) (Quit: azita)
[17:00:33] *** Joins: azita (Azita@2557E599.66715431.D25A875A.IP)
[17:00:53] *** Quits: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP) (Quit: eatkinson)
[17:02:03] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[17:02:03] *** ChanServ sets mode: +o brson
[17:02:09] *** Quits: azita (Azita@2557E599.66715431.D25A875A.IP) (Quit: azita)
[17:03:02] *** Joins: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP)
[17:03:06] *** Joins: eschweic (Adium@2557E599.66715431.D25A875A.IP)
[17:04:12] *** Joins: azita (Azita@2557E599.66715431.D25A875A.IP)
[17:04:44] *** Quits: seth (seth@moz-2C443A35.hsd1.co.comcast.net) (Input/output error)
[17:05:53] *** dherman-breakie is now known as dherman
[17:06:39] *** Joins: joebobjoe (joebobjoe@55F2E07A.7F841963.2213276E.IP)
[17:06:43] <heftig> nmatsakis: is DST going anywhere?
[17:07:14] *** Quits: Earnestly (earnest@2A2BF8F5.321FA5E6.BFD1ABFD.IP) (Ping timeout)
[17:07:48] * strcat threw a bit of a wrench in that for now by making ~fn/~[] use different allocators
[17:07:54] <graydon> brson: mac5 online?
[17:07:58] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[17:07:58] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/eSPTFg
[17:07:58] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[17:08:19] *** Quits: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net) (Quit: Jesse)
[17:09:14] <brson> graydon: looks like it. what's wrong?
[17:09:22] *** Joins: pyrac (pyrac@moz-B0599561.w92-162.abo.wanadoo.fr)
[17:09:24] *** Joins: azakai (alon@2557E599.66715431.D25A875A.IP)
[17:09:30] *** Joins: vilonis (jared@moz-EE5D17ED.ph.ph.cox.net)
[17:09:39] <graydon> oh, huh
[17:09:48] <graydon> it's been .. connecting and disconnecting somewhat randomly
[17:09:50] <graydon> seems online now
[17:09:58] <strcat> it knows it's being watched
[17:10:11] * graydon took linux1 out of the auto pool. it'll still be available for snaps (until we get something more reasonable sorted out for those)
[17:10:18] <graydon> er, linux1b
[17:10:41] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[17:10:55] * graydon checks cycle times on linux3
[17:10:57] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[17:10:57] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/Q_BPow
[17:10:57] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[17:11:11] <graydon> 2h45 on valgrind, ouch
[17:11:20] <graydon> that is the fastest machine I can rent from amazon
[17:12:06] *** Quits: indirect (indirect_m@moz-22FDA25B.hsd1.ca.comcast.net) (Quit: ZNC - http://znc.in)
[17:12:13] <graydon> compare with the ho-hum i7 sitting under my desk, valgrind cycle time is 39min
[17:12:56] <graydon> it's not just the valgrind step, even the compile steps are comedically bad on amazon
[17:13:08] <brendanc> have you ever looked at supercell? mercurial is using it and it's very nice
[17:13:11] <graydon> 14min real hardware => 1h14 on amazon
[17:13:28] <brendanc> http://supercell.osuosl.org/
[17:13:45] <brendanc> nice beefy machine reserve for open source CI
[17:14:18] <brendanc> IIRC you can allocate up to 16 cores and 8GB RAM
[17:14:33] *** Joins: mschifer (Adium@2557E599.66715431.D25A875A.IP)
[17:14:51] *** Joins: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP)
[17:15:14] <strcat> graydon: maybe you could do more on one machine now that mem usage never goes over 1.5GiB? don't know how many run at once atm
[17:15:18] <graydon> well .. if it's a VM, I'm not honestly sure how much I feel inclined to trust it..
[17:15:40] <brendanc> it's a VM. runs hg tests very fast with -j16 though
[17:15:56] <brendanc> not isolated though
[17:16:09] *** Joins: Sergio965 (sergiobz@moz-BB21156B.dynamic.csail.mit.edu)
[17:16:31] *** Joins: pcwalton (pcwalton@43CB6079.66715431.D25A875A.IP)
[17:16:31] *** ChanServ sets mode: +o pcwalton
[17:16:51] <strcat> pcwalton: no more ~T headers :)
[17:17:07] <graydon> this is ostensibly a 15gb mem / 4 way with the highest per-core timeslice they sell
[17:17:11] <graydon> it is still _absurdly_ slow
[17:17:36] <pcwalton> strcat: I saw, awesome!
[17:17:57] <pcwalton> odd that it didn't change cycle time or memory usage
[17:18:07] <strcat> well ~[] still has them and we don't use much ~T
[17:18:10] *** Joins: Earnestly (earnest@2A2BF8F5.321FA5E6.BFD1ABFD.IP)
[17:18:13] <brendanc> I could fire up a build on supercell and see how fast it is, I suppose
[17:18:18] <strcat> all the ~T is probably managed-unique ;p
[17:18:25] <pcwalton> hmm yeah
[17:19:21] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[17:19:41] *** Joins: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net)
[17:19:45] *** Joins: Kruppe (user@moz-4DDA8AB8.uwaterloo.ca)
[17:20:22] <graydon> strcat: we're definitely <1.5gb peak now?
[17:20:47] <strcat> well there was a 300MiB regression but... once that's reverted at least, we are
[17:21:23] <strcat> graydon: http://huonw.github.io/isrustfastyet/mem/ graph of it
[17:21:47] *** Quits: pcwalton (pcwalton@43CB6079.66715431.D25A875A.IP) (Connection reset by peer)
[17:22:10] <strcat> that's with cgroups so it includes the linker
[17:22:15] *** Quits: joebobjoe (joebobjoe@55F2E07A.7F841963.2213276E.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[17:22:19] *** Quits: eagen (eagen@15B176CF.7A99C13A.B7961A98.IP) (Ping timeout)
[17:22:22] <brendanc> btw what's the right cross-platform CPP define to get architecture size? wanted to set large stacks on 64-bit and aatch didn't like me using sizeof size_t
[17:22:54] *** Joins: pcwalton (pcwalton@43CB6079.66715431.D25A875A.IP)
[17:22:54] *** ChanServ sets mode: +o pcwalton
[17:22:59] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[17:22:59] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1497563ea to 14ed69ef0: 02http://git.io/N3iJvQ
[17:22:59] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[17:23:03] <strcat> brendanc: well, size_t seems like an okay way to do it
[17:23:03] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[17:23:14] <strcat> it's just an alias of uintptr_t
[17:23:29] *** Quits: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk) (Client exited)
[17:23:29] *** Joins: rossm (rossm@moz-EE3BB1DC.br.br.cox.net)
[17:23:32] <brendanc> I thought it'd be more reliable than guessing the right define for whatever compiler set rust allows
[17:24:03] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[17:24:20] <jack> what's the new way to do eachi? is there an advancei?
[17:24:38] *** Quits: graydon (graydon@A5087023.2354C43D.D8E68FF6.IP) (Ping timeout)
[17:24:46] <pcwalton> jack: .iter().enumerate().advance
[17:24:51] <bstrie> jack: I believe it's `for foo.iter().enumerate().advance |(i, e)| {`
[17:24:54] <pcwalton> jack: and there's a meeting going on right now
[17:25:34] <strcat> jack: advance is a temporary hack until a new for loop lands
[17:25:50] *** Joins: mnemotic (niko@8FFD1BD2.9D81E74C.53DF0002.IP)
[17:26:00] <bstrie> strcat: would that also get reduced to just `for foo.enumerate |(i, e)| {` ?
[17:26:02] <jack> pcwalton: i know about hte meeting, but have no way to join.
[17:26:13] <strcat> bstrie: it could
[17:26:19] <pcwalton> oh, ok
[17:26:22] <pcwalton> sorry :)
[17:26:23] <jack> pcwalton: so we decided to cancel it
[17:27:24] * jdm wonders whether the people in CYA are still sitting there unawares
[17:28:07] <pcwalton> brson: http://huonw.github.io/isrustfastyet/mem/
[17:28:21] <pcwalton> whoa, 282 members
[17:28:27] *** pcwalton changes topic to 'http://www.rust-lang.orgÂ | logs at https://botbot.me/mozilla/rust/ and http://irclog.gr/#browse/irc.mozilla.org/rust | http://huonw.github.io/isrustfastyet/mem/'
[17:28:28] <jack> pcwalton: rror: failed to find an implementation of trait std::iterator::Iterator<<V11>> for ~[@mut layers::Image]
[17:28:42] <pcwalton> jack: hmm, that's odd
[17:28:42] *** Joins: seth (seth@moz-2C443A35.hsd1.co.comcast.net)
[17:28:46] <jack> don't all owned vectors implement that?
[17:28:49] <pcwalton> I thought so!
[17:28:56] <bstrie> strcat: also it occurs to me that with your `for` proposal it might not be unambiguous to allow empty argument lists to be elided. how do you tell if `bar` in `for foo.bar |i| {` is a field that contains an iterable, or a method that returns one?
[17:29:01] <jack> i bet it has another trait bound or something
[17:29:12] <strcat> bstrie: well I think you'll need ()
[17:29:28] <strcat> jack: it's implemented on &[] actually
[17:29:41] <strcat> it should work though
[17:29:53] <bstrie> strcat: right, which is why I've warmed to `for i in foo.bar`, to avoid the discrepancy with `do`
[17:30:05] <jack> strcat,pcwalton: this vec is inside an @mut, so i had to deref it. but tha'ts the failure i get after deref
[17:30:16] <jack> so i need ot also borrow it?
[17:30:24] <strcat> jack: no, it should coerce
[17:30:55] <jdm> well, you can see what happens when you borrow it :)
[17:32:29] <jack> borrowing it odens't help. it still can't find an implementaiton.
[17:34:14] <strcat> well it actually wants &[]
[17:34:17] <strcat> not &~[]
[17:34:29] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[17:34:31] <jack> this is the line i added:
[17:34:31] <jack>         let tiles: &[@mut layers::Image] = *self.tiles;
[17:34:32] <jack>  
[17:34:42] <strcat> dunno why it's not working :(
[17:34:55] <strcat> jack: you have .iter(), right?
[17:35:05] *** Joins: Jesse (jruderman@2557E599.66715431.D25A875A.IP)
[17:35:06] <jack> no. sigh. just enumerate.
[17:35:18] <strcat> ah I was reading the error wrong ;p
[17:35:21] <jack> so i have to call both?
[17:35:25] <strcat> jack: yeah
[17:35:36] <strcat> until method resolve works enough for me to make Iterable with default methods
[17:36:11] *** Quits: CarpNet (ac@moz-FD24B77.sohonet.co.uk) (Quit: Leaving)
[17:36:16] <jack> strcat: inside the loop it doesn't know what type tile is
[17:36:24] <jack> strcat: how can that be?
[17:36:39] <strcat> jack: what does the closure look like?
[17:36:43] <strcat> it needs (i, v)
[17:36:46] <strcat> to match out
[17:36:50] <strcat> enumerate yields tuples
[17:36:53] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[17:37:27] <jack> where is enumerate in the docs? :)
[17:37:32] <Eridius> IteratorUtil
[17:37:33] <strcat> IteratorUtil
[17:37:36] <strcat> in std::iterator
[17:37:50] <jack> i missed there is an iter and an iterator
[17:38:32] <strcat> rusti: let xs = [1, 2, 3, 4, 5]; xs.iter().fold(0, |a, &b| a + b)
[17:38:33] -rusti- 15
[17:38:37] <strcat> rusti: let xs = [1, 2, 3, 4, 5]; xs.iter().skip(2).fold(0, |a, &b| a + b)
[17:38:38] -rusti- 12
[17:38:50] <strcat> rusti: let xs = [1, 2, 3, 4, 5]; xs.iter().skip(2).transform(|&x| x * 2).fold(0, |a, b| a + b)
[17:38:51] -rusti- 24
[17:38:53] <jack> strcat: that fixed me up. thanks.
[17:38:55] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[17:39:08] *** Joins: relistan (relistan@moz-2DE8112B.cable.virginmedia.com)
[17:39:18] <heftig> rusti: let xs = [1, 2, 3, 4, 5]; xs.iter().step(2).fold(0, |a, &b| a + b)
[17:39:18] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/INhe
[17:39:22] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[17:39:23] <strcat> jack: it's the way it is to make them compose well, it's just a bit painful without Iterable
[17:39:29] <heftig> hm
[17:39:54] <strcat> heftig: s/step/take_/ ?
[17:39:58] *** Joins: glinscott (garylinsco@789A6618.53EB7C1.FFFE3AA.IP)
[17:39:59] *** Quits: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP) (Client exited)
[17:40:09] <heftig> rusti: let xs = [1, 2, 3, 4, 5]; xs.iter().take_(2).fold(0, |a, &b| a + b)
[17:40:10] -rusti- 3
[17:40:12] <heftig> no
[17:40:19] <heftig> i wanted [1,3,5]
[17:40:28] <strcat> oh don't have that yet
[17:40:33] <strcat> you'd have to enumerate and filter
[17:40:50] *** Quits: azita (Azita@2557E599.66715431.D25A875A.IP) (Quit: azita)
[17:41:25] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Quit: Computer has gone to sleep.)
[17:41:38] <strcat> rusti: let xs = [1, 2, 3, 4, 5]; xs.iter().enumerate().filter(|&(i, _)| i & 1 != 0).fold(0, |a, &b| a + b)
[17:41:39] -rusti- <anon>:7:98: 7:100 error: mismatched types: expected `(uint,&int)` but found an &-pointer pattern
[17:41:39] -rusti- <anon>:7          let xs = [1, 2, 3, 4, 5]; xs.iter().enumerate().filter(|&(i, _)| i & 1 != 0).fold(0, |a, &b| a + b)
[17:41:39] -rusti-                                                                                                            ^~
[17:41:39] -rusti- error: aborting due to previous error
[17:41:40] -rusti- application terminated with error code 101
[17:41:44] <Eridius> what do you want, something like .nth(stride, phase) (where phase is the offset into the first stride)?
[17:42:01] <strcat> rusti: let xs = [1, 2, 3, 4, 5]; xs.iter().enumerate().filter(|&(i, _)| i & 1 != 0).fold(0, |a, (_, &b)| a + b)
[17:42:02] -rusti- 6
[17:42:06] *** Quits: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP) (Quit: Textual IRC Client: www.textualapp.com)
[17:42:11] <strcat> err
[17:42:15] <strcat> rusti: let xs = [1, 2, 3, 4, 5]; xs.iter().enumerate().filter(|&(i, _)| i & 1 == 0).fold(0, |a, (_, &b)| a + b)
[17:42:16] -rusti- 9
[17:42:20] <strcat> there
[17:43:01] <strcat> kind of like how half of them can really be implemented as skip_while ;p
[17:43:33] *** Joins: abacus (snoonan_mo@moz-F95B9243.hsd1.wa.comcast.net)
[17:43:34] *** Quits: relistan (relistan@moz-2DE8112B.cable.virginmedia.com) (Quit: relistan)
[17:44:00] <heftig> Eridius: yes.
[17:44:25] *** Joins: graydon (graydon@A5087023.2354C43D.D8E68FF6.IP)
[17:44:26] *** ChanServ sets mode: +qo graydon graydon
[17:45:02] *** Quits: doener (doener@moz-121949B3.unitymediagroup.de) (Quit: leaving)
[17:45:14] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[17:45:51] *** Joins: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP)
[17:46:37] *** Joins: azita (Azita@2557E599.66715431.D25A875A.IP)
[17:47:18] *** Joins: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[17:48:50] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[17:49:28] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[17:51:50] *** Quits: smvv_ (sander@moz-BAEA8EB2.dynamic.upc.nl) (Ping timeout)
[17:52:46] *** Quits: pcwalton (pcwalton@43CB6079.66715431.D25A875A.IP) (Quit: pcwalton)
[17:53:54] *** Quits: eschweic (Adium@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[17:54:27] *** Quits: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP) (Quit: eatkinson)
[17:56:56] *** Joins: eschweic (Adium@2557E599.66715431.D25A875A.IP)
[17:57:05] *** Joins: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP)
[17:57:06] <nmatsakis> strcat: why is it take_? 
[17:57:15] <strcat> nmatsakis: method resolve is broken :(
[17:57:28] <strcat> nmatsakis: it conflicts with take on Cell, because it doesn't realize Cell doesn't qualify as an Iterator
[17:57:43] <strcat> that's also why map is called 'transform'
[17:57:53] <strcat> it was before I started using underscores
[17:58:00] <engla> IteratorUtil conflicts with every trait since it's implemented "for T"
[17:58:12] <strcat> it's for T: Iterator<A> though
[17:58:16] <strcat> it's a bug
[17:58:18] <engla> sure
[17:58:51] <strcat> nmatsakis: also stops me from making an Iterable trait with things like fold as default methods
[17:59:59] <bstrie> strcat: are default methods otherwise functioning?
[17:59:59] <strcat> bstrie: better than most things now ;p
[18:00:01] *** Joins: pcwalton (pcwalton@2557E599.66715431.D25A875A.IP)
[18:00:01] *** ChanServ sets mode: +o pcwalton
[18:00:03] <strcat> not sure if sully's fix for the cross-crate issue I ran into landed yet
[18:00:15] *** Joins: ecr (ereed@2557E599.66715431.D25A875A.IP)
[18:00:16] <strcat> but other than that, size_hint as a default method works fine
[18:00:16] <sully> which issue?
[18:00:21] *** Quits: graydon (graydon@A5087023.2354C43D.D8E68FF6.IP) (Ping timeout)
[18:00:28] <strcat> sully: the one I thought was related to inlining, but was really about privacy
[18:00:38] <strcat> the AST one
[18:00:53] <sully> ok
[18:00:55] <strcat> dunno if you actually fixed it yet at all ;p
[18:01:05] <sully> I submitted a PR for it, that got r+d
[18:01:08] <sully> I haven't followed up on it
[18:01:18] <sully> there was a lot of bors confusion
[18:01:29] <strcat> they generally work well now though, it's quite nice :)
[18:02:07] *** Quits: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP) (Ping timeout)
[18:03:45] *** Quits: vilonis (jared@moz-EE5D17ED.ph.ph.cox.net) (Ping timeout)
[18:03:57] *** Quits: blaphmat (Mibbit@moz-C8F57D19.dynamic.tstt.net.tt) (Quit: http://www.mibbit.com ajax IRC Client)
[18:04:40] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[18:07:21] *** Joins: cowboyd (cowboyd@moz-1BD02A1E.sw.biz.rr.com)
[18:08:02] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[18:08:28] *** Quits: roo (jesse.rudo@moz-B7585E4C.dynamic.ip.windstream.net) (Quit: )
[18:09:32] *** Joins: graydon (graydon@A5087023.2354C43D.D8E68FF6.IP)
[18:09:32] *** ChanServ sets mode: +qo graydon graydon
[18:10:42] <graydon> would paravirtual be slower than hvm?
[18:12:05] <strcat> graydon: I just use qemu+kvm now and it seems almost as fast as the host for cpu stuff
[18:12:10] <graydon> yeah
[18:12:15] <graydon> I don't get this at all
[18:12:30] <strcat> with virtio flipped on at least, or I/O is really slow
[18:12:32] <graydon> ssh'ed into the machine, Intel(R) Xeon(R) CPU E5-2670 0 @ 2.60GHz, 20MB cache
[18:12:38] *** Quits: mschifer (Adium@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[18:12:38] <graydon> it should be fast
[18:12:42] *** Joins: mschifer (Adium@2557E599.66715431.D25A875A.IP)
[18:13:26] <strcat> graydon: is that the amazon one?
[18:13:30] <graydon> yeah
[18:13:38] <bstrie> graydon: write a blog post lambasting aws, and then we'll post it around the internet and wait for the angry mob to provide tech support
[18:13:40] <strcat> maybe they have it on a machine with 20 bitcoin miners :|
[18:14:35] <strcat> bstrie: I remember aichallenge used it for computing the matches, and it was awful. they ended up getting the supporting companies to donate server time instead of money
[18:14:53] * strcat remembers quite a lot of lambasting
[18:14:55] <strcat> didn't fix it ;p
[18:15:18] <strcat> kind of funny that google was giving them money to pay for AWS too.
[18:15:19] <brendanc> I vaguely recall aws storage is awful, so if you're hitting disk you lose
[18:15:43] <kmc> no way mining bitcoins on EC2 is cost effective
[18:16:09] <strcat> brendanc: maybe that's why the selling point of google's compute stuff is "fast disk access" ;p
[18:16:24] <brendanc> :)
[18:16:26] <kmc> maybe on a GPU instance but probably not then either
[18:16:29] <kmc> and yeah, EBS is full of lies
[18:16:47] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[18:17:04] *** Joins: ecr1 (ereed@2557E599.66715431.D25A875A.IP)
[18:17:34] *** Joins: ecr2 (ereed@2557E599.66715431.D25A875A.IP)
[18:17:48] <brendanc> make -j doesn't work does it?
[18:18:10] *** Quits: ecr (ereed@2557E599.66715431.D25A875A.IP) (Ping timeout)
[18:18:46] *** Quits: ecr1 (ereed@2557E599.66715431.D25A875A.IP) (Ping timeout)
[18:18:46] <strcat> brendanc: a bit
[18:18:53] <sully> strcat: it looks like my fix has landed
[18:18:59] <strcat> it helps during LLVM (but you'll want to bound it to -j # or you'll go OOM)
[18:19:01] <strcat> sully: nice :)
[18:19:20] *** Parts: ecr2 (ereed@2557E599.66715431.D25A875A.IP) ()
[18:19:23] <brendanc> wondered if it would help on aws. but llvm is usually not built I think?
[18:19:32] <graydon> how do I turn on newrt?
[18:19:38] <graydon> RUST_NEWRT=1
[18:19:39] <graydon> ?
[18:19:40] <bblum> RUST_NEWRT=1 i think
[18:19:44] <graydon> mhm
[18:19:45] *** Joins: ecr2 (ereed@2557E599.66715431.D25A875A.IP)
[18:20:10] <strcat> https://developers.google.com/appengine/docs/python/config/backends#Instance_Classes I wonder what they actually mean by the "CPU limit"
[18:20:11] *** Quits: eholk (eholk@moz-A76CD101.uconnect.utah.edu) (Quit: eholk)
[18:20:40] <strcat> I wonder if 4.8GHz really means 8 600MHz cores...
[18:20:46] * strcat shrugs
[18:20:52] <strcat> looks like it ;p
[18:21:03] *** Joins: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com)
[18:21:37] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[18:22:11] *** Joins: brendan (brendaneic@2557E599.66715431.D25A875A.IP)
[18:23:03] *** Quits: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com) (Ping timeout)
[18:24:33] *** cade is now known as bug891021
[18:24:46] *** bug891021 is now known as cade
[18:27:50] *** Quits: brendan (brendaneic@2557E599.66715431.D25A875A.IP) (Quit: brendan)
[18:29:18] *** Joins: brendan (brendaneic@2557E599.66715431.D25A875A.IP)
[18:30:12] *** Joins: mschifer1 (Adium@2557E599.66715431.D25A875A.IP)
[18:30:22] *** Quits: mschifer (Adium@2557E599.66715431.D25A875A.IP) (Connection reset by peer)
[18:30:42] *** Quits: pauls_ (paul@moz-9B39917C.c3-0.smr-ubr2.sbo-smr.ma.cable.rcn.com) (Ping timeout)
[18:32:48] *** Quits: mschifer1 (Adium@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[18:32:51] *** Joins: mschifer (Adium@2557E599.66715431.D25A875A.IP)
[18:33:34] *** Quits: BluePeppers (user@moz-3799699A.range81-151.btcentralplus.com) (Ping timeout)
[18:35:10] *** Quits: brendan (brendaneic@2557E599.66715431.D25A875A.IP) (Quit: brendan)
[18:36:49] *** Joins: brendan (brendaneic@2557E599.66715431.D25A875A.IP)
[18:37:23] <doomlord_> 4.8ghz really means 8 600mhz cores ? pipeline depth might be about that long so in some ways it does
[18:37:43] <bblum> aatch|gone (or anybody else knowledgeable in this): compare-and-swaps are no slower than normal atomic swaps, right?
[18:38:00] <bblum> it doesn't even seem like it would depend on architecture
[18:38:25] *** Joins: pauls_ (paul@moz-9B39917C.c3-0.smr-ubr2.sbo-smr.ma.cable.rcn.com)
[18:40:00] *** Joins: relistan (relistan@moz-2DE8112B.cable.virginmedia.com)
[18:40:15] *** Joins: jgilbert (jgilbert@2557E599.66715431.D25A875A.IP)
[18:41:17] *** Joins: mib_83j7b9 (Mibbit@moz-D3D15A0C.vie.surfer.at)
[18:41:37] *** Joins: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com)
[18:41:50] <rossm> how does rng.gen know to generate a bool if it's in an if statement?
[18:41:59] <jensnockert> bblum: On x86 they are not much slower.
[18:42:00] <rossm> from this example at the top http://static.rust-lang.org/doc/std/rand.html
[18:42:28] <bblum> jensnockert: what causes them to be slower? just the cpu cycles for the comparison? (i.e., same as a normal local comparison?)
[18:42:52] <rossm> rusti: let mut rng = rand::rng(); if rng.gen(() { println("true"); } else { println("false"); }
[18:42:53] <sfackler> bblum: the appendicies of http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-optimization-manual.pdf have cycle counts for many ops
[18:42:53] -rusti- <anon>:8:4: 8:5 error: incorrect close delimiter: `}`
[18:42:53] -rusti- <anon>:8     };
[18:42:53] -rusti-              ^
[18:42:53] -rusti- application terminated with error code 101
[18:42:58] <strcat> rossm: it infers
[18:43:05] <jensnockert> bblum: I cannot remember why, but I remember them having different cycle counts on different models.
[18:43:10] *** Joins: eholk (eholk@moz-A76CD101.uconnect.utah.edu)
[18:43:11] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[18:43:16] <jensnockert> bblum: I doubt it matters much.
[18:43:18] <strcat> rossm: same reason stuff like this works
[18:43:24] <strcat> rusti: let mut xs = ~[]; xs.push(5); xs
[18:43:25] -rusti- ~[5]
[18:43:44] <brson> ecr2: reviewing your branch now
[18:44:00] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[18:44:42] <rossm> I get type inference. But that seems like an extreme example
[18:44:52] <rossm> I am mostly familiar with C#, where type inference is much more limited
[18:44:58] <strcat> rossm: it can infer from the usage of the type
[18:45:04] <strcat> for example that vector example infers from .push(5)
[18:45:07] <strcat> the type of the vector
[18:45:35] <strcat> it's not quite as exhaustive as it should be atm, it will get better
[18:45:52] <strcat> it sucks at handling generic calls
[18:46:24] <strcat> (as in inferring *from* them)
[18:46:27] *** Quits: reyre (rick@B2D8AB09.33EE9F8A.1139E686.IP) (Client exited)
[18:46:35] <jensnockert> bblum: Could just be decode overhead? But that list points at CAS being 3 cycles higher latency, I think?
[18:46:52] <bblum> hmmm
[18:47:02] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[18:47:04] *** Joins: reyre (rick@B2D8AB09.33EE9F8A.1139E686.IP)
[18:48:09] <jensnockert> bblum: Not that it matters on an atomic operation.
[18:48:19] <Jeaye> Do we have a set-like structure with contiguous memory storage?
[18:48:38] <strcat> no
[18:48:43] <bblum> jensnockert: because atomic ops are already expensive enough to dwarf the extra 3 cycles, you mena?
[18:48:51] <jensnockert> bblum: Exactly.
[18:48:52] <strcat> Jeaye: either inserts or searches would be O(n)
[18:49:00] <Jeaye> yep
[18:49:11] <strcat> we have a binary search at least
[18:49:40] <bblum> strcat: not theoretically, though; right? a probing hashtable has O(1) insert and search and is... all stored in the same allocator chunk, at least
[18:49:44] <bblum> if not right next to each other
[18:49:51] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[18:49:54] <bblum> if you need them all to be right next to each other, then no
[18:50:01] <strcat> bblum: yeah, I think he meant all right next to each other though
[18:50:10] <pcwalton> strcat: btw, did your exchange alloc change improve treemap perf?
[18:50:22] <strcat> pcwalton: for some instantiations of it
[18:50:24] <Jeaye> strcat: What if it were allocated all up front? Like a vector's capacity... except it can't resize.
[18:50:26] <pcwalton> ok
[18:50:28] <strcat> for TreeMap<int, int>, no
[18:50:31] <strcat> same size class as before
[18:50:36] <strcat> TreeSet<int> it sped up
[18:50:39] <Jeaye> Man, I've pretty specialized needs. >.<
[18:50:47] <pcwalton> well, that's why we have generics :)
[18:50:50] <strcat> TreeMap<int, int> narrowly misses the 64-byte size class now
[18:51:37] <strcat> pcwalton: it did speed it up by making ~3% from stripping down the allocator, and borrowing not needing an offset
[18:51:45] <strcat> just not what I hoped :)
[18:52:03] <strcat> s/making/d
[18:52:06] <pcwalton> well, perf work is like that, changes usually don't have the effects you expect
[18:52:19] <kmc> rossm: yeah it can be counterintuitive that type inference allows information to flow "backward in time" from a call site to a function being called
[18:52:19] <pcwalton> getting rid of zeroing out might help a lot
[18:52:24] <strcat> pcwalton: it might speed it up more when ffi is faster
[18:52:25] <pcwalton> also niko's FFI changes which I would like to take over
[18:52:40] <pcwalton> (and why I'm installing the windows VM)
[18:52:42] <kmc> most languages don't support return-type polymorphism
[18:52:46] <strcat> pcwalton: like, malloc might take 20ns instead of 40ns now but we wouldn't notice ;p
[18:52:56] <pcwalton> unfortunately there are a lot of backwards incompatible changes that have priority...
[18:53:17] <pcwalton> (right now: removing "copy", then @ 'static, then removing @mut)
[18:53:19] <strcat> pcwalton: I think it would be nice to be able to choose the initial stack segment size
[18:53:28] <strcat> and just drop the fancy ffi caching machinery
[18:53:41] <pcwalton> brson may have objections to that
[18:53:54] <pcwalton> usually whenever I pitch anything about that brson comes up with a case in which it will cause OOM
[18:53:58] <strcat> well it would reduce space usage for small stacks at the expense of perf
[18:54:01] <pcwalton> pitch any changes to the current stack usage
[18:54:11] <bblum> what would cause oom?
[18:54:24] <pcwalton> you have to be careful with C stacks
[18:54:31] <pcwalton> or you can cause OOM on 32 bit
[18:54:33] <pcwalton> when you have a lot of tasks
[18:54:35] <pcwalton> our benchmarks do this
[18:54:39] <bblum> oh, uh oh :P
[18:54:43] <strcat> pcwalton: aatch got syscalls working from rust
[18:54:48] <strcat> we can compile libuv with segmented stacks
[18:54:48] <bblum> 4 GB ought to be enough for anybody
[18:54:54] <strcat> and move away from libc
[18:55:06] <bblum> pcwalton: even with stuff like PAE?
[18:55:11] <strcat> I guess libuv makes a lot of libc calls though ;\
[18:55:28] <pcwalton> PAE doesn't work intra process I thought
[18:55:28] <strcat> bblum: PAE is overall afaik, not per-process
[18:55:37] <pcwalton> that's cool but isn't really a direction I care about for servo
[18:55:42] <pcwalton> we will always have tons of FFI stuff in servo
[18:55:52] <bblum> strcat: and i guess we shouldn't mandate that to run on 32 bit you turn on PAE, huh
[18:55:56] <strcat> pcwalton: right, but it can still be fast from big stacks
[18:55:58] <pcwalton> if someone wants to try to reinvent libc in Rust like Go does that's fine
[18:55:58] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[18:55:58] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/G5JkzQ
[18:55:59] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[18:56:14] <strcat> pcwalton: it'd just be slow if you used spawn_reserve(0) (or whatever the API was)
[18:56:15] <pcwalton> but I don't really care :P
[18:56:28] <pcwalton> especially since I think we should just disable split stacks on 64 bit anyway
[18:56:34] <jensnockert> pcwalton: Yeah, reinventing libc seems like a bad idea.
[18:56:45] <strcat> jensnockert: libc is a really thin layer in most cases
[18:57:00] <strcat> the kernel APIs are often nicer on linux than what glibc exposes
[18:57:02] <strcat> clone, for example
[18:57:05] *** Joins: MaikKlein (maik@moz-54A7C76.dip0.t-ipconnect.de)
[18:57:11] <jensnockert> strcat: Sure, but how many systems do we need to reinvent libc on?
[18:57:12] <strcat> far nicer than fork/pthreads
[18:57:13] <pcwalton> note that on windows this is not an option
[18:57:14] * brendanc was bouncing an idea off strcat on friday for possibly faster stack growth: spread the starting addresses around and try to mremap to grow
[18:57:15] <Jeaye> Nearly every op in here ends in 'on' or 'an'. 
[18:57:18] *** Quits: achim (achim@moz-18A0BE5A.pools.arcor-ip.net) (Quit: Computer has gone to sleep.)
[18:57:20] <Jeaye> Odd.
[18:57:36] <pcwalton> brendanc: doesn't work on 32 bit, will run out of address space
[18:57:50] <strcat> jensnockert: just linux? Go doesn't do anything special on windows
[18:57:55] <pcwalton> on windows there is no documented kernel API and it changes from windows version to windows version
[18:57:58] <brendanc> pcwalton: you'd only allocate 1 page to start?
[18:57:58] <pcwalton> I don't know what Go does
[18:58:09] <strcat> pcwalton: I don't think they try doing anything special on windows
[18:58:13] <jensnockert> strcat: Yeah, but what is the point of reinventing libc on only Linux?
[18:58:19] <pcwalton> strcat: so they use kernel32.dll?
[18:58:22] <brendanc> when you're out of space, attempt to mremap in place and only move if that fails
[18:58:32] <pcwalton> brendanc: oh, you can't move
[18:58:36] <strcat> pcwalton: I think they probably just go through libc but I've only looked at their linux code
[18:58:48] <brendanc> can't move? I thought that was what morestack did
[18:58:54] <pcwalton> it just allocates more segments
[18:58:55] <strcat> jensnockert: because not going through libc makes segmented stacks useful
[18:58:57] <pcwalton> oh, I see
[18:59:07] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[18:59:08] <ghrust> 01[13rust01] 15bors pushed 21 new commits to 06auto: 02http://git.io/5PtE7w
[18:59:08] <ghrust> 13rust/06auto 1417b3712 15Niko Matsakis: Update existing tests to account for stricter, more correct handling of irrefutable patterns
[18:59:08] <ghrust> 13rust/06auto 141670a8c 15Niko Matsakis: Add new tests for irrefutable patterns used in various tricky ways
[18:59:08] <ghrust> 13rust/06auto 14ba13482 15Niko Matsakis: update ptr intrinsics and rewrite vec routines to be more correct....
[18:59:10] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[18:59:10] <pcwalton> so that's the other reason I'm uninterested in reinventings libc
[18:59:17] <strcat> jensnockert: and someone using Rust is *probably* not going to be hosting an application server on windows ;p
[18:59:18] <jensnockert> strcat: Yes, but only on Linux?
[18:59:30] <pcwalton> it won't work on windows and Firefox's userbase is like 90% windows
[18:59:31] <pcwalton> or 
[18:59:34] <strcat> jensnockert: well it's the only place where you can really do it
[18:59:34] <pcwalton> or something absurd like that
[18:59:39] <strcat> pcwalton: but browsers don't need segmented stacks
[18:59:41] <strcat> at all
[18:59:44] <jensnockert> strcat: OS X as well?
[18:59:52] <strcat> jensnockert: don't really think there's a point
[18:59:57] <strcat> no one has OS X servers
[18:59:58] <jensnockert> strcat: I agree.
[19:00:03] <jensnockert> strcat: I do.
[19:00:08] <brendanc> guess I'm still confused about what the 32-bit target is
[19:00:17] <pcwalton> nobody really has 32 bit servers either ;)
[19:00:18] <jensnockert> brendanc: Android for example.
[19:00:19] <strcat> segmented stacks are mostly just for servers
[19:00:21] *** Quits: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net) (Quit: I'm sure it's perfectly safe)
[19:00:30] <strcat> pcwalton: yeah, but Go still uses segmented stacks on 64-bit
[19:00:35] <jensnockert> brendanc: Or ARM in general.
[19:00:36] <strcat> they're smaller than 4k + page table overhead
[19:00:36] <pcwalton> I don't think that makes sense
[19:00:45] <brendanc> mremap would probably work there?
[19:00:58] <pcwalton> at the cost of big perf problems when you hit stack segment boundaries
[19:01:17] <strcat> pcwalton: I can make 100k threads with 8MiB stacks and it uses 390MiB RES if I only touch the first page in each, but the total usage is at least a gigabyte
[19:01:40] <pcwalton> mind you, I'm happy to have segmented stacks as an option, but not as the default
[19:01:43] <strcat> small stacks could still be useful in edge cases
[19:01:47] <strcat> pcwalton: yeah, that's what I think
[19:01:53] <strcat> but I don't think we should have them as a default *anywhere*
[19:02:04] <pcwalton> agreed
[19:02:12] <strcat> you probably know when you want/need them
[19:02:13] <jensnockert> If we disable them somewhere, I think we should disable them everywhere.
[19:02:24] <pcwalton> it's possible that browsers might benefit. parallel image decoding is the canonical use case
[19:02:27] <jensnockert> (And make them an option, possibly)
[19:02:27] <pcwalton> parallel shaping maybe
[19:02:44] <brendanc> lack of overcommit on windows makes large stacks a bit scarier though?
[19:02:46] <strcat> pcwalton: and if we allow reserve(best_guess), you can essentially take an overestimate of the upper bound and get a small stack without having to do allocs
[19:03:01] <jensnockert> brendanc: Yeah, but swap.
[19:03:07] <strcat> spawn_reserve(64 * 1024) or whatever
[19:03:31] <brendanc> even with swap, lots of tasks would be a problem
[19:03:35] <pcwalton> whoa, I had a 38 second GC in firefox
[19:03:44] <pcwalton> (while swapping, presumably)
[19:03:52] * strcat doesn't have swap
[19:04:05] <strcat> I just make a swap file now and then when doing something crazy...
[19:04:34] *** Quits: eholk (eholk@moz-A76CD101.uconnect.utah.edu) (Quit: eholk)
[19:04:35] <strcat> brendanc: you still probably want large stacks by default on windows, on 32-bit too
[19:04:49] <strcat> brendanc: you need segmented stacks *more* for actually scaling up to a high # of tasks
[19:04:59] <strcat> but I think in the general case, you aren't just spawning 200k I/O handlers
[19:05:12] *** Joins: cp (cp@moz-993078EE.plus.com)
[19:05:42] <strcat> although if we did make big stacks the default, it'd probably make sense to use OS threads by default too
[19:05:45] <jensnockert> Btw. How big is a 'big' stack? 2 MB?
[19:05:53] <strcat> jensnockert: 2MiB is the default on linux for a thread
[19:06:01] <brendanc> you wouldn't need 200k tasks to hurt real mem :)
[19:06:13] <jensnockert> strcat: Yes, is that considered big?
[19:06:15] <strcat> jensnockert: yes
[19:06:23] <strcat> jensnockert: segmented stacks start at under 4K
[19:06:43] <brson> bstrie: do you understand the joke on reddit about rust beta keys? there are several posts about it
[19:06:54] <strcat> brson: there's a rust game 
[19:07:33] <strcat> brson: http://www.playrust.com/ and people often confuse it with this rust ;p
[19:07:36] <jack> what did += get replaced with for ~""?
[19:07:37] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[19:07:50] *** Quits: Earnestly (earnest@2A2BF8F5.321FA5E6.BFD1ABFD.IP) (Ping timeout)
[19:07:51] <jensnockert> This whole stack thing seems complicated, maybe we should do a FORTRAN and just skip it. </joking>
[19:07:59] *** Joins: Earnestly (earnest@2AB30F53.FB5005.2BCC804A.IP)
[19:08:00] <Jeaye> jack: foo = foo + bar
[19:08:04] <strcat> jack: just one of the methods I guess, Add doesn't provide += anymore
[19:08:08] <strcat> Jeaye: really don't want to do that
[19:08:16] <Jeaye> oh?
[19:08:24] <strcat> it will allocate a temporary string and then wipe out the old foo
[19:08:27] <strcat> when you can just append
[19:08:28] <pcwalton> jack: .push_str()
[19:08:32] <pcwalton> I think is what it is
[19:08:38] <Jeaye> ahh
[19:08:46] <kimundi> I think "spawn a 8mb task" per default, "spawn a task with at least N amount of stack" optionally, and keeping stack growth in place so that either way you don't run out of stack sounds... Good?
[19:08:47] <pcwalton> it'll come back when it has a saner API
[19:08:53] <pcwalton> an AddAssign trait
[19:09:06] <strcat> kimundi: well we can use slightly over 2MiB by default
[19:09:08] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[19:09:08] <strcat> like 3MiB
[19:09:16] <strcat> it only has to be bigger than the FFI stack size (2MiB atm)
[19:09:28] <kimundi> well, whatever is the best 'large' size
[19:09:31] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[19:09:40] <strcat> we can ask the OS what the default pthread size is
[19:09:59] <strcat> pthread_attr_setstacksize
[19:10:02] <strcat> err
[19:10:07] <strcat> pthread_attr_getstacksize * ;p
[19:11:02] <strcat> pcwalton: by the time servo is ready, 90% of the users might be on android ;p
[19:11:12] <pcwalton> yup
[19:11:29] <pcwalton> but we can't make any bets at this stage
[19:11:32] <pcwalton> have to plan for every OS
[19:11:36] <strcat> yeah
[19:12:38] <jack> what did vec::find become?
[19:12:47] <strcat> .iter().find_()
[19:13:36] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[19:13:41] *** Joins: Ripp__ (quassel@moz-16954008.hsd1.ca.comcast.net)
[19:13:55] <jack> is the _ to prevent collision with HashMap?
[19:14:06] <strcat> jack: well, with anything with a find method
[19:14:14] <strcat> jack: it can be dropped when method resolve is fixed
[19:14:42] <strcat> that might be my least favourite bug now that ~T is free of headers
[19:14:56] <strcat> I run into it *all the time* ;p
[19:15:03] *** Quits: cp (cp@moz-993078EE.plus.com) (Ping timeout)
[19:15:23] *** Joins: roo (jesse@moz-B7585E4C.dynamic.ip.windstream.net)
[19:16:04] <kmc> what were ~T headers used for originally?
[19:16:23] <strcat> kmc: well, managed and managed-unique boxes have headers and use them
[19:16:34] <strcat> @mut uses it to do dynamic freezes
[19:16:49] <strcat> @/@mut and ~ containing managed pointers use it to free cycles when the task ends atm
[19:17:01] <strcat> and it uses them to tell managed ~ apart from @
[19:17:08] <kimundi> The header where from a time where there where no ~, only the darkness of @
[19:17:15] *** Quits: MaikKlein (maik@moz-54A7C76.dip0.t-ipconnect.de) (Ping timeout)
[19:17:34] <strcat> kmc: for non-managed unique, it was just a useless 32-byte header
[19:17:41] *** Quits: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Quit: Leaving.)
[19:18:00] <strcat> it was hard to remove it because it meant adding code paths all over the compiler to handle them differently from managed ~
[19:18:15] <strcat> and it's hard to find what you need to change...
[19:18:57] * engla listens to strcat retell the epic tales of coding sessions past
[19:19:08] <kmc> "managed ~" means a ~ that holds an @ somewhere?
[19:19:12] <strcat> kmc: yeah
[19:19:15] <strcat> those still have headers
[19:19:19] <kmc> ok
[19:19:30] <strcat> also, I split off ~[] and ~fn for now (they still have headers even when non-managed)
[19:19:32] <pcwalton> btw, eventually the headers are going to just be GC metadata held on the side
[19:19:35] <pcwalton> so there be no headers
[19:20:09] <kmc> so managed ~ is not traced by the GC under normal operation, but when a task ends you need to find cycles between ~ and @?
[19:20:24] <strcat> kmc: well managed ~ are added to an intrusive linked list with @
[19:20:43] <strcat> kmc: ~T where T is managed is a different beast than where T isn't
[19:20:56] <strcat> especially now that one has a header and one doesn't
[19:21:16] <strcat> kmc: the gc isn't actually implemented yet
[19:21:18] *** Quits: pyrac (pyrac@moz-B0599561.w92-162.abo.wanadoo.fr) (Quit: pyrac)
[19:21:30] <strcat> so @ uses refcounting and cycles aren't found until the end of the task
[19:21:52] *** Joins: pyrac (pyrac@moz-B0599561.w92-162.abo.wanadoo.fr)
[19:22:03] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[19:22:26] <kmc> ok
[19:22:26] <strcat> I really wish closures didn't use the headers :(
[19:22:37] <kmc> how does @ differ from Rc<T> then?
[19:22:47] <strcat> kmc: Rc is fast ;p
[19:22:54] <pcwalton> it's implicitly copyable
[19:22:54] <strcat> kmc: @ is implicitly copyable so you can't avoid refcounts
[19:22:58] <strcat> and Rc has no header
[19:22:59] <kmc> ah
[19:23:07] <strcat> Rc prevents cycles statically with trait bounds
[19:23:15] <kmc> right
[19:23:41] *** Joins: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[19:23:44] <strcat> either the type inside it has to be Send (not managed, or Rc) or Freeze (can't make a cycle if it's immutable or inherits mutability)
[19:24:04] <strcat> and since RcMut is non-Freeze, a Freeze bound works for it too
[19:24:04] *** Quits: Blei (philipp@moz-650B9C6A.cust.bluewin.ch) (Quit: WeeChat 0.4.1)
[19:24:07] <kmc> can you elaborate re: the intrusive linked list used with managed ~
[19:24:36] <strcat> kmc: I think whenever you allocate @ or ~ it uses the prev/next ptrs in the header to add them to the end of the managed list
[19:24:45] <strcat> and when freed they can get removed
[19:24:49] <strcat> it's just a doubly-linked list
[19:24:52] <strcat> through the headers
[19:25:04] <strcat> so at the end it can find all the leaked cycles
[19:25:18] <kmc> so it's just a per-task list of all managed stuff?
[19:25:21] <strcat> kmc: yes
[19:25:24] <kmc> ok
[19:25:25] <strcat> kmc: it will be obsoleted by gc
[19:25:39] <strcat> since the gc tracks roots already
[19:26:33] *** Joins: SimonSapin (simon@moz-D0C2F181.zone2.bethere.co.uk)
[19:27:29] <doomlord_> is Rc actually built into the compiler, or a library feature
[19:27:41] <strcat> doomlord_: entirely a library feature
[19:27:53] <strcat> we need a Pointer trait though
[19:27:58] <strcat> to overload the deref/borrow sugar
[19:28:05] <strcat> (just for Rc, not RcMut)
[19:28:06] <pcwalton> well, I'm not sure we need that
[19:28:13] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[19:28:13] <pcwalton> we could just not have the deref/borrow sugar
[19:28:26] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[19:28:27] <strcat> pcwalton: *x.borrow_mut() = 5 is quite annoying though
[19:29:15] <pcwalton> possibly, yeah
[19:29:21] <pcwalton> I'd rather defer it until we know we need it
[19:29:25] <pcwalton> we can always add it later
[19:29:29] *** Joins: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch)
[19:29:31] <strcat> pcwalton: yeah that's fine
[19:29:33] <pcwalton> also I want to get it working as a method first to make sure that works
[19:30:12] <strcat> pcwalton: well borrow/borrow_mut work well for a custom unique type
[19:30:17] <strcat> and borrow for Rc
[19:30:20] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[19:30:21] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[19:30:38] *** Quits: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu) (Quit: Leaving)
[19:30:40] *** Parts: mnemotic (niko@8FFD1BD2.9D81E74C.53DF0002.IP) ()
[19:31:27] *** Quits: judder (maradukewa@5B9E91E7.2C8A8E2E.78E362FE.IP) (Ping timeout)
[19:31:28] <bblum> i am writing inhibit_kill functions and so on for the new runtime, and i have come to believe from staring at it for so long that "inhibit" can't possibly be a real word
[19:31:38] <bblum> who even comes up with this stuff
[19:31:42] <pcwalton> semantic satiation
[19:31:53] <bblum> yes
[19:32:17] <strcat> we could make a bunch of things default methods now...
[19:32:20] <bblum> amusingly, the phenomenon is also called "inhibition"
[19:32:28] <strcat> we should just remove that lint flag
[19:32:38] <pcwalton> is there still known brokenness?
[19:32:52] <strcat> pcwalton: I'm sure there is, but they're as solid as the rest of the language ;p
[19:33:00] <strcat> more solid than ~Trait
[19:33:14] <strcat> pcwalton: everyone is already using them since Iterator has one
[19:33:20] <pcwalton> hmm, ok
[19:33:35] <strcat> rusti: let xs = [1, 2, 3]; xs.iter().size_hint()
[19:33:36] -rusti- (3, Some(3))
[19:33:49] <strcat> rusti: let xs = [1, 2, 3]; xs.iter().chain_(xs.iter()).size_hint()
[19:33:50] -rusti- (6, Some(6))
[19:34:02] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[19:34:04] <strcat> FromIterator uses it to preallocate
[19:34:38] <strcat> and collect calls that
[19:34:51] * strcat found a few bugs but sully fixed them all
[19:35:41] <sully> bblum: I remember once wanting to ask someone for a muffin but not being able to because I had become convinced that muffin could not possibly be a real world
[19:35:59] <bblum> muffin.
[19:36:00] <glinscott> is it considered okay to have private functions declared in a trait?  the use case is i'm optimizing str::char_range_at, and i want to be easily inalienable.  there is a slow path (for multi-byte unicode chars), which i moved to a separate fn
[19:36:11] <glinscott> s/inalienable/inlineable/
[19:36:12] <pcwalton> glinscott: it's generally frowned upon
[19:36:33] <pcwalton> if it's a helper function just impl it directly on the type, or use a separate trait
[19:36:37] *** Quits: mib_83j7b9 (Mibbit@moz-D3D15A0C.vie.surfer.at) (Quit: http://www.mibbit.com ajax IRC Client)
[19:36:48] <jensnockert> pcwalton: Can you have helper functions inside of an impl?
[19:36:58] <pcwalton> jensnockert: not if it's a trait impl
[19:36:59] <jensnockert> As in, additional private fns inside of a trait impl?
[19:37:09] <jensnockert> pcwalton: Ah, makes sense.
[19:37:20] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[19:38:19] *** Joins: joebobjoe (joebobjoe@55F2E07A.7F841963.2213276E.IP)
[19:38:39] *** Joins: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net)
[19:38:46] <glinscott> pcwalton: ok thanks.  here is my use case - https://github.com/glinscott/rust/compare/utf8_char_width_perf#L0L1741
[19:38:53] *** Quits: joebobjoe (joebobjoe@55F2E07A.7F841963.2213276E.IP) (Quit: Textual IRC Client: www.textualapp.com)
[19:39:06] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[19:39:08] <relistan> I have a quick 0.6 -> 0.7 question for my first Rust code if there is anyone with a spare second. Is += on ~str no longer available?  Or am I doing something dumb?
[19:39:16] <relistan> Code is here: http://pastebin.com/CTd170Xq
[19:39:31] <relistan> Any help is much appreciated.
[19:39:40] <jensnockert> pcwalton: Could you please take a look at https://github.com/mozilla/rust/pull/7117 at some point? It removes the free-standing functions in f32, f64, u8â€¦ and puts them in num:: instead.
[19:39:49] <jensnockert> relistan: That is correct.
[19:39:52] <glinscott> really i just want to make the char_range_at fn as small as possible, and the uncommon path off in another fn, so the inliner can do it's work
[19:40:32] <pcwalton> sure
[19:40:35] <relistan> jensnockert: thanks. What is the replacement? having trouble with docs.  Append?
[19:40:49] *** Quits: Kruppe (user@moz-4DDA8AB8.uwaterloo.ca) (Client exited)
[19:41:29] <relistan> Ok, I'll give that a shot.  Too bad, I liked the + and += syntax
[19:41:36] <jensnockert> relistan: str::append(a, b) should work.
[19:41:43] <jensnockert> relistan: It is just temporary I think.
[19:41:59] <relistan> jensnockert: awesome, thanks!
[19:42:11] *** Joins: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net)
[19:42:24] *** Quits: busylizzy (lisa@85228838.12D0DC84.211374C4.IP) (Ping timeout)
[19:42:24] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Ping timeout)
[19:42:47] *** Quits: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[19:42:48] <mark_edward> strcat: can you take a look at something i've been writing? cmr gave me the idea
[19:42:54] <strcat> sure
[19:43:03] *** Joins: busylizzy (lisa@85228838.12D0DC84.211374C4.IP)
[19:43:51] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[19:43:58] <mark_edward> it's a little bzip2 binding. here is the repo: https://github.com/MarkJr94/bzip2rs
[19:44:01] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[19:44:22] *** Quits: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch) (Quit: Leaving.)
[19:44:28] *** Quits: Ripp__ (quassel@moz-16954008.hsd1.ca.comcast.net) (Ping timeout)
[19:44:43] <mark_edward> i've been trying to add a sort of "compression iterator"
[19:44:46] <brson> graydon: I'm running into two tricky problems when running the new runtime tests on the bots
[19:44:53] <kmc> hm so rust lets you define methods for a specific instantiation of a generic thing?  e.g. pub struct Node<View> { ... }; impl Node<ScriptView> { ... }
[19:44:54] <graydon> brson: ok
[19:44:57] <graydon> what's up?
[19:45:06] <mark_edward> strcat: if you go into bzip2.rs and go to the bottom you'll see a test illustrating it's use
[19:45:29] <brson> graydon: they are both related to doing multiple builds in parallel (in multiple workspaces)
[19:45:39] <brson> graydon: 1) ulimit is stupid low, so we run out of filehandles
[19:45:42] <mark_edward> strcat: the problem that I have is that each slice is only valid until the next iter.next() call
[19:45:43] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[19:45:44] <kmc> can you also specialize the members of a struct for different type parameters, a la C++?
[19:45:47] <strcat> mark_edward: ah bzip2 is actually stream-based
[19:45:58] <strcat> kmc: you can have generic struct type params
[19:45:58] <brson> I think that's easy enough to work around - we can just modify the bots to raise the limits
[19:46:18] <brson> graydon: but 2) we have a lot of network tests now, and they all want port numbers
[19:46:28] <strcat> kmc: the type bounds go on implementations though, and you can have impls with different type bounds
[19:46:33] <mark_edward> strcat: yeah, i can do the compression with an inplace buffer, but is there anyway to make it clear in the type system that each slice is only valid until the next next() call?
[19:46:36] <graydon> brson: eep
[19:46:44] <brson> so i get inte situations where two different workspaces try to use e.g. port 9600 at the same time
[19:46:57] <graydon> brson: yeah, of course
[19:47:00] <kmc> strcat: not sure what you mean, sorry
[19:47:00] * roo compiles rust for the first time not on windows, and sheds a single tear of joy
[19:47:11] <brson> within a single test runner i've got it solved, using monotonically increasing numbers
[19:47:13] <graydon> I wonder if it's possible to have ... a loopback sub-interface of some sort that's isolated
[19:47:23] <strcat> mark_edward: yes but I'm not sure Iterator will allow you to do that
[19:47:23] <kmc> also am i correct that the code I pasted defines a generic struct and methods for a specific instantiation of it?
[19:47:27] <graydon> brson: I guess you want this on all platforms, eh?
[19:47:32] <brson> graydon: yp
[19:47:35] <brson> *e
[19:47:51] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[19:47:57] <strcat> mark_edward: if you use foo<'r>(&'r mut self) -> &'r T, I think it would invalidate the old one on the next iter
[19:48:03] <strcat> but it won't let you put that on next
[19:48:11] <strcat> hm
[19:48:26] <brson> oh, the ulimit problem is mac only. should have mentioned
[19:48:32] <graydon> brson: when you say "one runner", do you mean one workspace / builder, or one instance of compiletest?
[19:48:39] <graydon> (do you run more than one instance of compiletest per run?)
[19:48:49] <graydon> is this like when buildbot runs 2 builders on the same machine at the same time?
[19:48:55] <mark_edward> strcat: hm indeed. And I need this sort of behavior if i want to allow this sort of compression with no heap allocs'
[19:49:10] *** Quits: txdv (quassel@966F3542.3BA477DA.14C26596.IP) (Ping timeout)
[19:49:18] <graydon> or does it happen when you have just one 'make check' running on a given machine?
[19:49:37] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[19:49:49] <brson> graydon: at the moment *most* of the network tests are in stdtest, so within a single instance of stdtest there are no collisions. concievably it could be a problem in the future if there are network tests in other places as well. for now though the problem is with running stdtest in multiple workspaces
[19:49:49] <strcat> mark_edward: the problem is that it's more restricted than Iterator's type signature
[19:50:02] <strcat> mark_edward: so it's not really possible to do it as an Iterator impl, since Iterator lacks that restriction
[19:50:06] <mark_edward> i see
[19:50:57] <mark_edward> so then it's unsafe to present with the iterator thing, because if you hold on a a slice reference, it'll just be changing out from under you
[19:51:01] <graydon> brson: ok. the options I can think of between builders are ... we can reserve a port range for each builder (say) and pull it out of a builder property, or we can use a lock so only one builder runs its tests at once (sounds bad!) ...
[19:51:16] <strcat> mark_edward: you could use &const [T] for now
[19:51:20] <strcat> but &const might be removed
[19:51:20] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[19:51:29] <strcat> &const is allowed to be mutated externally
[19:51:42] <strcat> (the vector can't change size, but it can be mutated)
[19:51:45] <brson> graydon: so have the builder pass something like --test-port-start=9600 during configure?
[19:51:49] *** Joins: txdv (quassel@966F3542.3BA477DA.14C26596.IP)
[19:51:50] <mark_edward> I see... I'll try that for now
[19:51:59] <graydon> brson: yeah, more or less. configure or env var or something.
[19:52:08] <Luqman> brson: why not pass 0 and let the os choose any free port?
[19:52:10] <brson> graydon: which is better?
[19:52:12] <strcat> graydon: on linux I know we could solve that with a network namespace - no idea if that exists on OS X
[19:52:20] <strcat> you can get a private loopback on linux
[19:52:30] <strcat> for your process and the children it spawns
[19:52:41] * strcat doubts it exists elsewhere :(
[19:53:04] <strcat> I'd still like to teach the test runner to use namespaces on linux anyway
[19:53:12] <graydon> brson: I mean, if you want to get it hacked up real easily, you could also hard-code into compiletest a different port-range depending on whether it observes itself running in a subdir of one of these strings: http://buildbot.rust-lang.org/builders
[19:53:31] <graydon> though you'd have to twiddle that any time we add new builders
[19:53:56] <graydon> you could hack it up pretty easily buildbot-side as well, passing a configure arg. just then you have to thread it all through the configure-and-build steps
[19:54:19] <graydon> strcat: yeah, compiletest should probably use cgroups, someday
[19:54:26] <graydon> but one thing at a time :)
[19:54:31] <strcat> graydon: namespaces are actually easier
[19:54:37] <strcat> (it could use both though)
[19:54:39] <graydon> still doesn't fix mac or windows
[19:54:43] <strcat> yeah, I know ;p
[19:54:44] <graydon> we need a way past this
[19:54:46] <graydon> but yeah
[19:55:16] *** Joins: eholk (eholk@moz-A76CD101.uconnect.utah.edu)
[19:55:17] *** Joins: Kruppe (user@moz-4DDA8AB8.uwaterloo.ca)
[19:55:19] <bblum> strcat: do you have a handy reference writeup for external iterators
[19:55:33] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[19:55:36] <bblum> bonus points if you have one aimed at someone already familiar with haskell
[19:55:44] <jedestep> rusti: fmt!("%x", 2)
[19:55:45] -rusti- ~"2"
[19:55:47] <strcat> bblum: not yet ;p
[19:55:52] <bblum> c.c
[19:55:54] <strcat> bblum: I started on an iterator tutorial but didn't do much for it yet
[19:56:20] <strcat> bblum: drop -> skip, map -> transform, otherwise they're similar to haskell :)
[19:56:26] <brson> Luqman: good idea. it's plausible, though would likely require restructuring a lot of tests, and doesn't cover all use cases. i'd have to look into it more
[19:56:29] * strcat really wishes it was called map though.
[19:56:49] <roo> external iterators for haskeller: haskell lists, with some plumbing to define what happens lazily
[19:56:54] <bblum> it will be called map soon though
[19:56:57] <strcat> graydon: on linux it's as simple as unshare(CLONE_NEWNET) ;p
[19:57:14] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[19:57:20] <strcat> needs to be in a setuid shim until they fix CLONE_NEWUSER though
[19:57:34] <bblum> strcat, i was debating with a haskeller the virtue of having a "default way to use map" that collects to the same collection type, even if you have a more magic one that collects to any type you want
[19:57:48] <bblum> not sure if you thought about this already, but it seems like both an easy and an important thing to do
[19:58:04] <strcat> bblum: .collect() is nice, but atm you have to specify whole types
[19:58:09] <strcat> I'd really like to be able to do...
[19:58:19] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[19:58:22] <strcat> let xs: ~[_] = it.map(|x| x * 2).collect();
[19:58:24] <strcat> and have it infer _
[19:58:41] <strcat> it can get pretty annoying
[19:58:51] <jack> strcat: where is map now?
[19:58:51] <bblum> strcat: maybe a motivator for typeof() in the type language
[19:59:01] <strcat> jack: it's called transform due to method resolve being weird
[19:59:04] <strcat> jack: could be map_
[19:59:04] <bblum> strcat: i opened an RFC for that a year ago
[19:59:24] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[19:59:24] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14652be03 to 142a8ae0e: 02http://git.io/N3iJvQ
[19:59:24] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[19:59:25] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[19:59:25] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/9dznqw
[19:59:25] <ghrust> 13rust/06auto 14b0a9d81 15Brian Anderson: Bump version numbers to 0.8-pre
[19:59:25] <ghrust> 13rust/06auto 14f7b293b 15bors: auto merge of #7577 : brson/rust/vers, r=cmr
[19:59:25] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[19:59:29] <strcat> bblum: it'd be nice to just omit parts of a type with _ though
[19:59:31] <graydon> still open, but it's more noticable now
[19:59:38] <strcat> I've used typeof as decltype in C++11 and it gets annoying
[19:59:38] <bblum> strcat: anyway, what i mean is that in the Iterable trait, the provided map method should collect to the same collection type that was provided, so people don't get confused
[19:59:47] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[19:59:56] <strcat> bblum: not sure, I don't really want to encourage copies like we do now
[20:00:13] <strcat> I've seen places with 5 chained vec methods creating 5 vectors
[20:00:13] <bblum> strcat: map_consume
[20:00:17] *** Joins: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com)
[20:00:17] *** Quits: brendan (brendaneic@2557E599.66715431.D25A875A.IP) (Quit: brendan)
[20:00:20] <bblum> oh hah gross
[20:00:24] <bblum> well, yeah, map consume
[20:01:36] <doomlord> is it just me or does the most elegant pure functional style lend itself more to haskell's lazy eval  etc
[20:01:47] <doomlord> ... and not to efficient memory management
[20:02:12] <strcat> well you can abstract more if you don't care about efficiency
[20:02:19] <strcat> since you can use more lossy abstractions
[20:02:26] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[20:02:33] <rossm> I think it works pretty great in C# for example (IEnumerable LINQ extensions)
[20:02:43] <strcat> rossm: IEnumerable is like std::iterator
[20:02:50] <doomlord> i tried setting up lazy templates to code like that in c++ but it seemed a bit clunky, 
[20:02:50] <strcat> (the rest of LINQ is more powerful)
[20:03:16] <strcat> C++ has std::async for thunks now
[20:03:34] <rossm> I mean the way you can chain the extension methods (filter, map, etc) and they're all lazy
[20:03:34] <strcat> http://en.cppreference.com/w/cpp/thread/async
[20:03:38] <strcat> still painful
[20:03:42] <strcat> rossm: yeah, that's what std::iterator does
[20:04:15] *** Joins: brendan (brendaneic@2557E599.66715431.D25A875A.IP)
[20:04:23] *** Joins: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[20:04:56] <jack> strcat: is there a to_owned() for iterators?
[20:05:12] <strcat> jack: .collect() collects to a data structure implementing FromIterator
[20:05:31] <strcat> rusti: let xs = [1, 2, 3, 4]; let ys: ~[int] = xs.iter().transform(|&x| x * 2).collect(); ys
[20:05:32] -rusti- ~[2, 4, 6, 8]
[20:06:08] <strcat> it knows to do that in 1 allocation too
[20:06:25] <Eridius> as long as the iteartor chain provides a suitable bounds
[20:06:36] <strcat> rusti: let xs = [1, 2, 3, 4]; xs.iter().transform(|&x| x * 2).size_hint()
[20:06:37] -rusti- (4, Some(4))
[20:06:43] <strcat> rusti: let xs = [1, 2, 3, 4]; xs.iter().transform(|&x| x * 2).skip(2).size_hint()
[20:06:43] -rusti- (2, Some(2))
[20:06:49] <Eridius> rusti: let xs = [1,2,3,4]; xs.iter().transform(|&x| x * 2).filter(|_| true).size_hint()
[20:06:49] -rusti- (0, Some(4))
[20:07:05] <doomlord> whats the 'size_hint'
[20:07:15] <strcat> doomlord: lower and upper bound on the # it will yield
[20:07:24] <strcat> if they are equal, it's an exact #
[20:07:33] <Eridius> None on upper means either unbounded, or bound not known
[20:07:41] <Eridius> uint::max_value on lower means unbounded (this is what Counter returns)
[20:07:54] <doomlord> does rust have default parameters at the minute
[20:08:05] <doomlord> just asking because i see size_hint()
[20:08:07] <Eridius> hrm, should probably update size_hint's docstring to explain that iterator adaptors need to be careful around uint::max_value
[20:08:37] <Eridius> doomlord: what do you mean?
[20:08:52] <doomlord> and also are these lazy iterators, needing '.collect()' to actually make the result
[20:09:13] <SiegeLord> Wait, what... why is it two different things for the two bounds?
[20:09:40] <Eridius> SiegeLord: I removed Option on the lower bound because None and Some(0) are semantically identical
[20:09:43] <doomlord> ah silly me. size_hint RETUrns the bounds lol
[20:09:56] <strcat> doomlord: yeah they are lazy
[20:10:01] <strcat> they only do as much as needed
[20:10:13] <strcat> SiegeLord: because filter can yield 0 things
[20:10:14] <SiegeLord> Eridius, To me, None on the lower bound is unbounded
[20:10:20] <strcat> regardless of the size of the original iterator
[20:10:26] <doomlord> and they potentially chain as one operation i guess?
[20:10:26] <SiegeLord> uint::max_val for unbounded is a horrible idea
[20:10:37] <strcat> SiegeLord: the *lower* bound
[20:10:38] <Eridius> SiegeLord: None means "no lower bound". Except the lower bound is already implicitly restricted to 0. can't go any lower
[20:10:45] <strcat> the lower bound is the minimum it will yield
[20:10:50] <Eridius> so None doesn't change the implicit lower bound of 0
[20:10:59] <strcat> if it will yield infinite, the lower bound is at *least* uint::max
[20:11:04] <strcat> so it's fine
[20:11:21] <strcat> instead of looping forever you get a nice immediate reserve failure ;p
[20:11:29] <Eridius> SiegeLord: you have to be careful with uint::max_value even for bounded iterators, because if your iterator chain pushes the lowr bound up to uint::max_value, it needs to saturate there and never go lower again
[20:11:31] <strcat> well "forever", it would slowly go OOM
[20:11:49] <SiegeLord> And that is preferrable to None?
[20:11:51] <Eridius> well, never go lower by a discrete amount
[20:11:52] <strcat> if you say the lower bound is 5, you have to yield at least 5
[20:12:03] <strcat> if you say it's 0, you don't know anything useful
[20:12:04] <Eridius> SiegeLord: None means "no lower bound", which is the same as 0. None does not semantically mean "infinite"
[20:12:26] <strcat> None on the upper bound means unknown or infinite
[20:12:44] <Eridius> if you wanted to redefine None to mean "infinite" you'd still have a problem, because an interator chain that hints uint::max_value as the lower bound would have to saturate there, it could not switch to None because that would be incorrect (since it would in fact terminate)
[20:12:46] <strcat> if someone comes up with a use case for knowing the difference... it could tell
[20:12:48] <strcat> ;p
[20:13:02] <strcat> the use case for knowing the lower bound is reserving
[20:13:11] <strcat> the use case for knowing the upper bound is reserving *less*
[20:13:26] <Eridius> Counter::new(0,1).take(uint::max_value/2).chain_(Counter::new(0,1).take(uint::max_value-3)).size_hint() // this has to be (uint::max_value, None)
[20:13:41] <Eridius> defining that as (None, None) would be unequivocably wrong
[20:14:18] <SiegeLord> Let me look up what chain does
[20:14:31] <Eridius> emits all the values from the first iterator, then the second
[20:14:53] <Eridius> rusti: Counter::new(0,1).take(5).chain_(Counter::new(20,1).take(5)).collect::<~[int]>()
[20:14:54] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/DKNf
[20:15:13] <Eridius> rusti: use std::iterator::Counter; Counter::new(0,1).take(5).chain_(Counter::new(20,1).take(5)).collect::<~[int]>()
[20:15:14] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/PNXX
[20:15:20] <strcat> take_
[20:15:22] <strcat> ;p
[20:15:24] <strcat> blame Cell
[20:15:24] <Eridius> bah
[20:15:32] <Eridius> rusti: use std::iterator::Counter; Counter::new(0,1).take_(5).chain_(Counter::new(20,1).take_(5)).collect::<~[int]>()
[20:15:33] -rusti- ~[0, 1, 2, 3, 4, 20, 21, 22, 23, 24]
[20:15:42] <strcat> that knows the size hint is 10 though, right?
[20:15:45] <Eridius> yes
[20:15:49] <Eridius> rusti: use std::iterator::Counter; Counter::new(0,1).take_(5).chain_(Counter::new(20,1).take_(5)).size_hint()
[20:15:50] -rusti- (10, Some(10))
[20:15:58] <strcat> ok good ;)
[20:16:07] <SiegeLord> So there are two iterators... one with uint::max_value / 2 + uint::max_value - 3... the lower bound is not uint::max_value
[20:16:23] <Eridius> FilterMapIterator is the only iterator adaptor that doesn't have a useful size_hint()
[20:16:35] <Eridius> SiegeLord: uint::max_value is _a_ lower bound
[20:16:43] <strcat> Eridius: it has an upper bound though, right?
[20:16:44] <Eridius> it's not the highest possible lower bound, but the highest possible lower bound doesn't fit in a uint
[20:16:51] <strcat> or it isn't implemented you mean
[20:16:59] <Eridius> strcat: FilterMapIterator has no knowledge about bounds. It can't
[20:17:00] <engla> FilterMapIterator can't have a sensible bound I think
[20:17:18] <strcat> Eridius: doesn't it know the same thing as filter?
[20:17:20] <Eridius> strcat: well it could check if its source iterator's upper bound is 0 and then emit (0, Some(0)), but that's the only case it can possibly handle
[20:17:26] <Eridius> and it wasn't worth implementing just for that
[20:17:36] <Eridius> strcat: oh dammit, not FilterMap. sorry
[20:17:38] <Eridius> FlattenMap or whatever it's called
[20:17:41] <strcat> oh
[20:17:42] <strcat> yeah
[20:17:57] <mark_edward> strcat: i think i just found a use case for an each method
[20:18:09] <strcat> mark_edward: what?
[20:18:17] *** Joins: tjc (tjc@2557E599.66715431.D25A875A.IP)
[20:18:17] *** ChanServ sets mode: +o tjc
[20:18:28] <mark_edward> my use case. internal iteration would better suit, right?
[20:18:36] <mark_edward> have someone pass me a closure
[20:18:37] <strcat> mark_edward: no, doesn't solve it
[20:18:49] <strcat> mark_edward: you can make a safe external iterator
[20:18:53] <strcat> just not one implementing Iterator
[20:18:59] <strcat> that's the issue
[20:19:06] <strcat> internal vs external isn't the issue
[20:19:21] <jensnockert> bjz: I made a list of what I think need to be dumped.
[20:19:22] <mark_edward> there's not really much use if it doesn't implement Iterator
[20:19:37] <jensnockert> bjz: Where dumped means I want to move it to extra.
[20:19:39] <Eridius> mark_edward: what are you doing?
[20:19:53] <mark_edward> Eridius: https://github.com/MarkJr94/bzip2rs
[20:20:30] <mark_edward> the README needs updating actualy
[20:20:31] <Eridius> so why can't you use Iterator?
[20:20:51] <Eridius> make it Iterator<&[u8]> or somesuch
[20:20:57] <strcat> &const [u8]
[20:21:06] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[20:21:13] <strcat> I guess you could also just not put a lifetime on it...
[20:21:27] <strcat> Eridius: the problem is that the next iteration mutates it
[20:21:40] <strcat> rusti: 222222222222222222222222
[20:21:40] -rusti- <anon>:6:12: 6:13 error: int literal is too large
[20:21:40] -rusti- <anon>:6     let r = {
[20:21:40] -rusti-                      ^
[20:21:41] -rusti- application terminated with error code 101
[20:22:23] <Eridius> strcat: ok, doesn't the lifetime of the &[u8] prevent you from calling .next() on the iterator until you lose your reference to the slice?
[20:22:27] <Eridius> and isn't that what you want?
[20:22:31] <strcat> Eridius: no
[20:22:38] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[20:22:39] <strcat> it doesn't prevent you
[20:22:46] <Eridius> I mean, make it &'self [u8] or something
[20:22:48] <strcat> it prevents you from modifying the container, for container iterators
[20:23:05] <strcat> Eridius: 'self doesn't refer to the self param
[20:23:10] <strcat> it refers to the contained borrowed ptrs
[20:23:14] *** Joins: dwhyte1 (dwhyte@ED9190FB.B72E355F.7BF4A4B0.IP)
[20:23:26] <strcat> I don't think you can restrict an implementation of a trait more than the generic trait
[20:23:26] <mark_edward> Eridius: the problem is that i'm trying have the output decompressed into a fixed size buffer
[20:23:29] <Eridius> 'self is still confusing
[20:23:33] <strcat> if you could, you wouldn't be implementing the trait
[20:23:43] <mark_edward> on each iteration the buffer gets emptied and refilled with more data from input
[20:23:44] <strcat> Eridius: pretend it's not called 'self
[20:23:48] <strcat> 'self is just a name *you* gave it
[20:23:55] <strcat> it has no special semantics anymore
[20:24:06] <Eridius> no? I thought it was still vaguely special
[20:24:08] <strcat> type parameters only allow 'self and 'static but 'self isn't special
[20:24:11] <strcat> Eridius: it isn't really
[20:24:14] <mark_edward> so if you have a reference to one of the results of .next(), and get another one, it's actually the same reference
[20:24:24] <Eridius> why do type params only allow 'self and 'static anyway?
[20:24:24] <strcat> Eridius: if we start allowing other names, it won't be special in any way
[20:24:26] <mark_edward> and they will keep shifiting under you during iteration
[20:24:27] <strcat> Eridius: legacy
[20:24:34] *** Quits: dwhyte (dwhyte@ED9190FB.B72E355F.7BF4A4B0.IP) (Ping timeout)
[20:24:40] <strcat> Eridius: 'self used to be implicitly on every self parameter, not anymore
[20:24:45] <strcat> mark_edward: just use &const
[20:24:51] <strcat> it will be safe if you do that
[20:25:04] <Eridius> strcat: but that won't prevent you from calling .next() 3 times in a row and then trying to look at the results
[20:25:12] <strcat> Eridius: doesn't matter
[20:25:19] <strcat> you're allowing to mutate &const externally
[20:25:22] <strcat> allowed*
[20:25:24] * strcat shrugs
[20:25:30] <Eridius> yeah but it's still surprising
[20:25:40] <strcat> I don't really think it should be an iterator if it's just returning references to itself
[20:25:57] <strcat> the Iterator trait doesn't implement a way to do that with & and internal mutation
[20:26:03] <strcat> it would need
[20:26:21] <strcat> next<'r>(&'r mut self) -> Option<&'r T>
[20:26:21] <Eridius> strcat: It might be reasonable to say that calling .next() on an iterator doesn't invalidate the results of a previous call, but I dunno.
[20:26:25] <strcat> well, for this case &'r [T]
[20:26:33] <strcat> Eridius: it has to be reasonable
[20:26:44] <rossm> so rusti sends notices now instead of responding in the channel? is that a new change?
[20:26:52] <Eridius> rossm: no
[20:26:55] <strcat> Eridius: Iterator doesn't know what the type it yields is
[20:26:56] <mark_edward> strcat: maybe i could implement a writer trait or something
[20:26:57] *** Quits: Ms2ger (Ms2ger@moz-E9883900.access.telenet.be) (Quit: nn)
[20:26:58] <strcat> the trait doesn't care
[20:27:05] <strcat> mark_edward: Reader
[20:27:21] <strcat> Eridius: it can't place any lifetime bounds on it
[20:27:24] <steven_is_false> How do I private message rusti?
[20:27:26] <strcat> it doesn't know it's a slice or borrowed ptr
[20:27:30] <strcat> steven_is_false: /query rusti
[20:27:31] <mark_edward> yeah, Reader
[20:27:37] <steven_is_false> strcat: Thank you.
[20:27:41] <rossm> if I PM rusti a query, will everybody else get a notice?
[20:27:49] <Eridius> no
[20:28:22] *** Joins: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch)
[20:28:27] <rossm> ok, thanks. I only ask because I'm getting notices for everybody's queries in the channel
[20:28:48] <strcat> rossm: NOTICE is just a normal message that's not meant to be automatically replied to
[20:29:52] <bblum> brson: what's the deal with the "use rt::task::Task;" *inside* of std::task::failing()? I tried moving it up to the top of the file but then I get "failed to find an implementation of trait rt::local::Local for task::Task"
[20:29:54] <Eridius> according to the RFCs, no client (read: bot) should automatically reply to a NOTICE
[20:30:07] <Eridius> it's basically intended for bots to use to respond to people without triggering feedback loops from other bots
[20:31:02] <rossm> oh I see the missing piece of information was I couldn't tell that some notices were directed at me, and some at the channel
[20:31:07] <mark_edward> strcat: Reader.seek doesn't make much sense in decompression i think...
[20:31:07] <rossm> that was not showing up
[20:31:42] <Eridius> rossm: your client should show NOTICEs directed at the channel in the channel buffer, and NOTICEs directed at you in your query buffer for the bot (if you have one, or the server buffer if not)
[20:31:46] <Eridius> I don't know what mIRC does in practice though
[20:32:12] <rossm> it does not do that. I'm sure there's an option in mirc's terrible settings thing
[20:32:31] <Eridius> mark_edward: I'm surprised that .seek() is part of Reader directly, instead of something like SeekableReader
[20:32:40] <Eridius> since stream-based readers will never be able to seek
[20:33:02] <mark_edward> yeah...
[20:33:08] *** Quits: sk_ (sk@43301EF8.3DDD1ABD.33B96495.IP) (Quit: Leaving)
[20:33:58] <brson> bblum: idk. maybe it's a resolve bug. I don't think I put it there to work around anything, but because that's where I needed it.
[20:33:59] <strcat> Eridius: the old I/O stuff is all on the way out
[20:34:09] <strcat> maybe brson already made new traits, dunno
[20:34:25] <Eridius> strcat: yeah, I'm basically ignoring io for now in the hopes that New IO is better
[20:34:30] <bblum> brson: i think it has to do with "pub mod rt" for the old runtime being used in the same file
[20:34:35] <bblum> i'll just work around it
[20:34:40] *** Quits: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Quit: msingle)
[20:35:18] <strcat> iterators could have reservoir sampling
[20:35:20] <strcat> ;p
[20:35:34] *** Quits: mye (mye@moz-5EBA714.dip0.t-ipconnect.de) (Quit: mye)
[20:35:37] <Eridius> strcat: ooh that would be fun
[20:36:11] <Luqman> was there a way to just build libextra tests without having to rebuild rustc?
[20:36:34] <Eridius> `make check-stage2-extra NO_REBUILD=1` works for me
[20:36:45] <Eridius> or just `rustc extra.rs --test --cfg stage2`
[20:37:03] <Luqman> sweet, thanks Eridius 
[20:39:51] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[20:39:58] <bblum> brson: is there a common "wake-up" code path where the scheduler takes the current_task and begins running code in its context?
[20:40:09] <bblum> (or two such paths?)
[20:40:09] *** Quits: graydon (graydon@A5087023.2354C43D.D8E68FF6.IP) (Ping timeout)
[20:40:57] <brendanc> running make check on a 16-core VM, I expected a load close to 16. but it seems to spend quite a good chunk of time at load 1-2
[20:41:17] <jack> where did sys::TypeDesc go?
[20:41:27] *** Joins: Ripp__ (quassel@moz-16954008.hsd1.ca.comcast.net)
[20:41:44] <strcat> jack: TyDesc in intrinsics?
[20:43:49] *** Joins: Jesin (Jessin_@moz-48B48C95.eecs.lehigh.edu)
[20:46:21] *** Quits: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch) (Quit: Leaving.)
[20:46:44] <brson> bblum: resume_task_immediately and switch_running_tasks_and_then
[20:46:55] *** Quits: dwhyte1 (dwhyte@ED9190FB.B72E355F.7BF4A4B0.IP) (Quit: Leaving.)
[20:47:38] <pcwalton> checking if OS is AIX... no
[20:47:47] * pcwalton loves ancient configure scripts
[20:48:07] <bblum> brson: it's not appropriate to fail!() in sched context, right? but those two are running in task context in the end?
[20:48:20] <bblum> (the sched -> task context "switch" is when current_task is set to Some, right?)
[20:49:15] <strcat> pcwalton: configure scripts are pretty silly overall
[20:49:19] <brendanc> make check  7022.82s user 2137.35s system 353% cpu 43:13.42 total
[20:49:22] *** Quits: mark_edward (quassel@moz-4A5B1251.wisolt4.epbfi.com) (Ping timeout)
[20:49:24] <strcat> what are they going to do if the C compiler can't compile C?
[20:49:30] <brendanc> thought it would spread better on 16 cores
[20:49:32] <strcat> they seem to suspect it must not really be a C compiler
[20:50:07] <jensnockert> strcat: Sometimes cc does terrible things.
[20:50:17] <jensnockert> strcat: I have had that check fail :S
[20:50:22] *** Quits: pcwalton (pcwalton@2557E599.66715431.D25A875A.IP) (Ping timeout)
[20:50:25] <strcat> jensnockert: on what, solaris? ;p
[20:50:31] *** Quits: tjc (tjc@2557E599.66715431.D25A875A.IP) (Ping timeout)
[20:50:34] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[20:50:36] <jensnockert> strcat: Actually, yes.
[20:50:38] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[20:50:38] *** ChanServ sets mode: +o brson
[20:50:41] <strcat> jensnockert: sun cc?
[20:50:49] *** Quits: azita (Azita@2557E599.66715431.D25A875A.IP) (Ping timeout)
[20:50:51] * strcat has heard stories about it
[20:50:52] *** Joins: tjc (tjc@2557E599.66715431.D25A875A.IP)
[20:50:52] *** ChanServ sets mode: +o tjc
[20:51:04] <jensnockert> strcat: Yes, but that wasn't really the issue.
[20:51:13] <jensnockert> strcat: Someone had added a script called cc to path.
[20:51:20] <strcat> heh
[20:51:53] <strcat> configure scripts should just have a #!/bin/rm shebang, imo
[20:51:57] <strcat> would save a lot of trouble
[20:52:14] *** Joins: pcwalton (pcwalton@2557E599.66715431.D25A875A.IP)
[20:52:14] *** ChanServ sets mode: +o pcwalton
[20:52:16] <jensnockert> Yeah, NUKE ALL THE COMPUTERS.
[20:52:23] <brson> bblum: neither of those functions contain any code that runs after the context switch
[20:52:23] <strcat> jensnockert: well then they just remove themselves ;p
[20:52:28] *** Joins: azita (Azita@2557E599.66715431.D25A875A.IP)
[20:52:40] <jensnockert> strcat: rm -rf /
[20:52:52] <strcat> rm: it is dangerous to operate recursively on â€˜/â€™
[20:52:54] <strcat> rm: use --no-preserve-root to override this failsafe
[20:52:58] <brson> bblum: run_cleanup_job always runs after the context switch, but it runs in either scheduler or task context
[20:53:00] <strcat> ;p
[20:53:07] <jensnockert> strcat: Which reminds me of Solaris cp. It cannot copy symlinks.
[20:53:15] <jedestep> it is dangerous to go alone
[20:53:38] <strcat> my shell doesn't trust me anyway
[20:53:44] <strcat> strcat@thinktank i ~/projects/rust master % rm *
[20:53:44] <brson> bblum: fail! doesn't work in sched context yet, yes
[20:53:45] <strcat> zsh: sure you want to delete all the files in /home/strcat/projects/rust [yn]? y
[20:53:47] <strcat> rm: remove all arguments? 
[20:54:08] <jensnockert> strcat: I started to copy a disk image once, was surprised it wasn't finished a few hours later, realized it had recursively copied the image and kept going in a loopâ€¦
[20:54:08] <brson> bblum: the current_task is set to Some immediately before the context switch, but is not itself the context switch
[20:54:22] <strcat> jensnockert: heh
[20:54:25] <bblum> well, it's the switch of sched-vs-task context, not cpu-registers-context, i mean
[20:54:29] <jensnockert> strcat: Solution? tar | untar
[20:54:33] <bblum> brson: i'm looking for a place to stick killed checks.
[20:57:48] <bblum> brson: in what cases would the run_cleanup_job not be running in scheduler context?
[20:58:05] <bblum> would it be sufficient to just be like "if sched.in_task_context() { check_killed() }" ?
[20:58:17] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[20:58:23] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[20:58:39] *** Quits: fabiand (fabiand@moz-DDE1FFB.adsl.alicedsl.de) (Quit: Verlassend)
[20:58:42] <brson> bblum: run_cleanup_job runs after all context switches. yes that check could be appropriate if you want the check to be immediately when a task resumes
[20:58:49] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[20:58:53] <brson> bblum: though maybe you want to do it after running the cleanup job
[20:58:59] <bblum> yeah i do for sure :P
[20:59:16] <bblum> i guess what i'm wondering is --
[20:59:42] <bblum> i want to put a killed check at the beginning and at the end of each task's "timeslice"
[21:00:00] <bblum> if i put one after run_cleanup_job inside a "if in_task_context()", will that cover all cases?
[21:00:23] <bblum> (i mean, will that cover all cases of beginning of timeslice)
[21:01:23] <doomlord> on irc i'm arguing with someone who thinks "fn " is a waste of characters. some people :)
[21:02:13] <doomlord> the ease of grepping through rust source without needing any sort of IDE setup is great, its easily worth those extra 3 characters infront of the function def
[21:02:13] <jack> doomlord: tell them to use Erlang then :)
[21:02:34] <bblum> doomlord: yeah i love how "fn foo" *always* finds where foo is defined
[21:02:39] <doomlord> it seems like a little thing but it really contributes to rust being enjoyable
[21:02:45] <bblum> yeah
[21:02:49] <engla> and fn being short
[21:02:51] <bblum> whether or not it's inside an impl, or anything
[21:02:52] <engla> that's the best
[21:02:58] <doomlord> such a simple thing
[21:03:04] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Client exited)
[21:03:05] <bblum> i don't know of any other language where that's true
[21:03:16] <doomlord> who'd have thought, after using tools like c++, that such a simple thing could make a differnce, but it does
[21:03:27] <bblum> c/c++ have different return types there; haskell has nothing; SML could have "and" instead of "fun"
[21:03:28] *** Joins: jensnock_ (jensnocker@moz-8BE55278.customer.t3.se)
[21:03:43] *** Quits: rossm (rossm@moz-EE3BB1DC.br.br.cox.net) (Quit: )
[21:03:44] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Ping timeout)
[21:03:44] *** Quits: brendan (brendaneic@2557E599.66715431.D25A875A.IP) (Quit: brendan)
[21:03:49] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[21:03:53] <doomlord> i've actually tried doing #define fn auto and #define let auto :)
[21:04:00] <strcat> bblum: c++11 has a whole new silly syntax for inferred return types too
[21:04:01] <brson> bblum: a check in run_cleanup_job will cover the beginning of the timeslice, but not the end. you would need another check in resume_task_immediately and deschedule_running_task_and_then te cover the end
[21:04:11] *** Quits: azita (Azita@2557E599.66715431.D25A875A.IP) (Ping timeout)
[21:04:23] <bblum> yeah, that's what i was thinking
[21:04:24] <strcat> bblum: auto foo() -> decltype(expr) { }
[21:04:33] <doomlord> i think you could keep unambiguous syntax and still not have to write fn... but why bother.
[21:04:35] <strcat> and lambdas are pretty damn ugly
[21:04:37] <doomlord> when its so nice
[21:04:40] <bblum> strcat: what is this decltyp thing?
[21:04:45] <bblum> brson: thanks
[21:04:46] <strcat> bblum: it's a standard 'typeof'
[21:05:02] <doomlord> right, because "typeof" is too pretty, they have to put "decltype"
[21:05:07] <bblum> strcat: and you have to put a variable name there or something?
[21:05:11] <strcat> bblum: an expression
[21:05:14] <strcat> bblum: http://en.cppreference.com/w/cpp/language/decltype
[21:05:17] <bblum> sure
[21:05:17] <doomlord> "typeof", like "sizeof". 
[21:05:24] <strcat> bblum: you can use the params
[21:05:31] <doomlord> the C++ committee say.. "how can we make our language MORE ugly"
[21:05:32] <strcat> bblum: you essentially have to paste the function body into it
[21:05:33] <strcat> ;p
[21:05:42] <strcat> you can use it elsewhere though
[21:06:02] *** Joins: brendan (brendaneic@2557E599.66715431.D25A875A.IP)
[21:06:49] <doomlord> was destructuring arguments a recent addition ?
[21:06:58] <strcat> to rust? no
[21:07:08] *** Quits: Ripp__ (quassel@moz-16954008.hsd1.ca.comcast.net) (Ping timeout)
[21:07:08] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[21:07:09] <doomlord> i'm thought i tried it before and it didn't work.. i must have done it wrong
[21:07:21] <bblum> brson: there's also a special-case timeslice end in terminate_current_task, though i don't suppose that needs a killed check... is there a similar special-case timeslice start for the first time a task ever runs?
[21:08:38] *** Quits: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net) (Input/output error)
[21:09:53] *** Quits: SimonSapin (simon@moz-D0C2F181.zone2.bethere.co.uk) (Ping timeout)
[21:10:39] *** Joins: Ripp__ (quassel@moz-16954008.hsd1.ca.comcast.net)
[21:10:39] *** Quits: cowboyd (cowboyd@moz-1BD02A1E.sw.biz.rr.com) (Client exited)
[21:11:57] *** Joins: cowboyd (cowboyd@moz-1BD02A1E.sw.biz.rr.com)
[21:13:17] *** Joins: graydon (graydon@A5087023.2354C43D.D8E68FF6.IP)
[21:13:17] *** ChanServ sets mode: +qo graydon graydon
[21:13:55] <brson> bblum: no, task start is not a special case
[21:14:01] <bblum> sweet
[21:15:09] <bjz> doomlord: some of it interacted with argument modes
[21:15:42] <brson> is there a macro yet that combines println with fmt?
[21:15:46] <bjz> rusti: fn foo(&x: &int) -> int { x } foo(&1)
[21:15:47] -rusti- 1
[21:15:51] <bblum> brson: error! ;)
[21:15:51] *** Joins: azita (Azita@2557E599.66715431.D25A875A.IP)
[21:16:09] <bjz> doomlord: ^ that wasn't possible before
[21:16:28] <bjz> doomlord: also remember you can't use pattens that could fail
[21:16:41] <strcat> brson: no but we need one, and formatting should output to a Writer
[21:16:54] <bjz> doomlord: like you can't destructure enums or vectors
[21:17:11] <strcat> formatted I/O to a file (including stdout/stderr) shouldn't have to allocate
[21:17:22] <doomlord> ah yeah i recently tried fixed length vectors, and enums i guess would  not work
[21:17:42] <strcat> fixed-length vectors should work
[21:17:44] <strcat> it's a bug
[21:18:05] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[21:19:10] <brson> what should println + fmt be called?
[21:19:14] <bblum> print!
[21:19:18] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[21:19:22] <bblum> or println!
[21:19:26] <SiegeLord> printfln
[21:19:33] <brson> maybe println!
[21:19:35] <bblum> if we already have a io::print that doesn't print a newline
[21:19:46] <tjc> pfrintln!
[21:19:53] <brson> would it be confusing to have both println and println!
[21:19:55] <brson> tjc: nice
[21:19:56] <bblum> pfrank pfenning pfrintln
[21:20:01] <strcat> brson: we could remove println
[21:20:05] *** Joins: vilonis (jared@moz-E76B3E97.ph.ph.cox.net)
[21:20:07] <bblum> brson: i don't think that would be confusing
[21:20:51] *** Joins: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch)
[21:20:52] <jack> consume used to be a vec method but is now a plain function?
[21:21:03] <bblum> another proposal would be echo!
[21:21:05] <strcat> jack: it was replaced with iterators
[21:21:10] <krdln> why not printf?
[21:21:18] <strcat> printf doesn't put a \n
[21:21:23] *** Joins: dwhyte (dwhyte@ED9190FB.B72E355F.7BF4A4B0.IP)
[21:21:30] <strcat> printlnf and printf
[21:21:32] <strcat> ;p
[21:21:41] <bblum> printfln/printlnf is pretty unwieldy
[21:21:42] <krdln> :)
[21:21:43] *** Joins: fabiand (fabiand@moz-DDE1FFB.adsl.alicedsl.de)
[21:21:47] <fabiand> hey
[21:21:51] <fabiand> I just do my first steps with rustpkg
[21:22:08] <fabiand> and wondered about some things
[21:22:12] <bblum> brson: the cleanup job in deschedule_running_task_and_then *always* runs in sched context, right?
[21:22:18] <strcat> bblum: are there are tests of ~Trait with a 'static bound?
[21:22:22] <fabiand> e.g. the docs say rustpkg is looking for main.rs and lib.rs (and others)
[21:22:23] <strcat> I'm worried I broke it ;p
[21:22:41] <strcat> dunno for sure
[21:22:42] <fabiand> now, how can i access a function in lib.rs?
[21:22:42] <krdln> i haskell printf prints on output or returns string, dependent of context
[21:22:48] <fabiand> do i have to use it with the use keyword?
[21:22:59] <brson> bblum: yes
[21:23:06] <bblum> strcat: not sure; if so, {run-pass,compile-fail}/trait-bounds-*
[21:23:16] <tjc> fabiand: lib.rs is just an ordinary Rust file; so you can use a `use` directive in it just like in any Rust file
[21:23:18] <fabiand> m ylayout is somewhat src/foo/main.rs and src/foo/lib.rs ... i put some dummy func into lib.rs which I want to call from main.rs ... 
[21:23:23] <krdln> is this possible in rust via type inference?
[21:24:01] <strcat> bblum: well it tests Freeze+Send bounds
[21:24:05] <strcat> does that use exchange alloc?
[21:24:12] <bblum> if it says ~, it does
[21:24:14] <bblum> otherwise no
[21:24:25] <fabiand> tjc, rustpkg is giving me an error at build-time: main.rs:2:4: 2:7 error: unresolved import. maybe a missing `extern mod lib`?
[21:24:26] *** Joins: brianm (brianm@moz-D74EBD8D.hsd1.co.comcast.net)
[21:24:37] <fabiand> tjc, main.rs:2 use lib::example;
[21:24:44] <strcat> bblum: I think I probably did break *something* about it
[21:24:46] <fabiand> tjc, so I wonder how I can use the lib ..
[21:24:53] <bblum> strcat: well, uh oh
[21:24:53] <strcat> because managed-unique and unique have different representations now
[21:25:00] <bblum> i see
[21:25:02] <strcat> but all the tests passed
[21:25:05] * strcat shrugs
[21:25:12] <bblum> strcat: it should not be hard to devise a test case for ~Trait:'static
[21:25:15] <strcat> it just feels like there should be something else to fix ;p
[21:25:16] <tjc> fabiand: let me experiment, hold on a sec
[21:25:21] *** Quits: Ripp__ (quassel@moz-16954008.hsd1.ca.comcast.net) (Ping timeout)
[21:25:26] <fabiand> tjc, thanks. I'm using 0.7
[21:25:48] <doomlord> http://smallcultfollowing.com/babysteps/blog/2012/02/09/auto-serialization-in-rust/ <<< i see anonymous structs there... is that obselete :) (april 2012)
[21:26:16] *** Joins: Ripp__ (quassel@moz-16954008.hsd1.ca.comcast.net)
[21:27:32] <strcat> hrm
[21:28:25] <bblum> doomlord: oh man the {|| ... } closure form
[21:28:58] <doomlord> scrolling down.. alt insteda of match, and no => ... wow its changed a lot
[21:28:58] <bjz> :)
[21:29:50] <bjz> argument modes!
[21:29:50] <roo> krdln: I can imagine a macro and a trait that could do that.
[21:30:10] *** Quits: Sergio965 (sergiobz@moz-BB21156B.dynamic.csail.mit.edu) (Ping timeout)
[21:30:35] <fabiand> tjc, https://github.com/fabiand/example.rs
[21:30:52] <tjc> fabiand: ok, the problem is what I hoped it was. in main.rs you would also have to put the line mod lib; after the use lib::example; directive
[21:30:55] <fabiand> tjc, that's what I'm using. I tried running rustpkg build in te workspace
[21:31:07] <brianm> so, how stable is rust now?
[21:31:16] <tjc> then it should compile (the other possibility was there was a bug in rustpkg with the search paths)
[21:31:27] <fabiand> tjc, could you differentiate mod and use for me, or point me to a doc doing this? :)
[21:31:43] <tjc> fabiand: you also have to write `pub fn example()` in your example.rs file so that example can be called outside that file
[21:31:55] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[21:31:55] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/9dznqw
[21:31:55] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[21:31:56] <tjc> fabiand: let me see if the docs explain the difference between mod and use, 1sec
[21:32:08] *** Quits: saml (sam@moz-14C16814.cst.lightpath.net) (Quit: Leaving)
[21:32:28] <fabiand> tjc, ah - the missing pub also helped.
[21:32:42] <tjc> fabiand: for mod vs. use, see http://static.rust-lang.org/doc/rust.html#modules
[21:32:54] <tjc> if that doesn't help, let me know and I'll try to improve it or file a bug to improve the explanation there
[21:33:24] *** Quits: rhodesd (none@3646D136.4C5731DA.F395EA5B.IP) (Ping timeout)
[21:33:51] <fabiand> tjc, thanks for your help ... !
[21:33:59] <tjc> fabiand: you're welcome!
[21:34:40] <fabiand> and - nice work ... really. finally something that's not c++ ..
[21:34:53] <fabiand> and rustpkg might really solve some things
[21:34:56] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[21:34:56] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/sLatnQ
[21:34:56] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[21:34:57] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[21:34:57] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/fncOvQ
[21:34:57] <ghrust> 13rust/06auto 1437494d3 15Gary Linscott: Switch json parsing to read_chars for performance...
[21:34:57] <ghrust> 13rust/06auto 1452949fb 15Gary Linscott: Faster check for ascii-space...
[21:34:58] <ghrust> 13rust/06auto 14149c976 15Gary Linscott: Merge branch 'unicode_perf' into json_perf
[21:35:00] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[21:35:02] <fabiand> though I didn't find many examples in e.g. the servo repos ..
[21:35:04] <tjc> :-)
[21:35:31] *** Quits: Houm (Houm@moz-25669AA8.fbx.proxad.net) (Ping timeout)
[21:35:47] * strcat ponders remaking the sort module
[21:36:20] *** Quits: dan_johnsin (dan_johnsi@6902762D.11B071D.FB9A45AF.IP) (Client exited)
[21:36:55] *** Joins: smvv_ (sander@moz-BAEA8EB2.dynamic.upc.nl)
[21:37:13] <strcat> would be nice if it could sort things like extra::deque too
[21:38:46] *** Joins: rhodesd (none@3646D136.4C5731DA.F395EA5B.IP)
[21:38:50] <brendanc> graydon: fwiw supercell ran valgrind make check in 43 minutes versus 3hr40min on linux1b
[21:39:01] <graydon> not bad
[21:39:07] <graydon> not crazy-fast, but not bad
[21:39:23] <brendanc> somewhat surprisingly to me, time only reported 353% CPU on 16 cores
[21:39:42] <fabiand> mh, is the #[bench] attribute already "supported"?
[21:39:50] <fabiand> or ist rust looking for some special fn filename?
[21:39:55] <fabiand> fn-name
[21:40:00] <strcat> fabiand: #[bench] and pass --bench to the test harness
[21:40:50] <fabiand> strcat, mh i created a bench.rs, added some file annotated with #[bench] and run the resulting ...bench file
[21:40:59] <strcat> fabiand: compile with --test
[21:41:07] <fabiand> strcat, I use rustpkg
[21:41:11] <fabiand> rustpkg build ..
[21:41:16] *** Quits: Kruppe (user@moz-4DDA8AB8.uwaterloo.ca) (Ping timeout)
[21:41:19] <strcat> well I dunno how rustpkg does things
[21:41:22] <fabiand> I just wanted to try the bench part because it's mentioned in the docs :)
[21:41:29] <fabiand> tjc, ^^
[21:41:31] <strcat> bench works though
[21:41:43] <fabiand> strcat, I believe so :)
[21:42:15] <tjc> rustpkg should automatically plug in the --bench flag if there's a file named bench.rs
[21:42:36] <tjc> fabiand ^^
[21:42:52] <fabiand> tjc, ok - is there a special fn prefix required?
[21:42:59] <fabiand> so it's picked up?
[21:43:10] <tjc> fabiand: besides #[bench] before the function(s) you want to benchmark, no
[21:43:13] <tjc> they can be named anything
[21:43:15] <fabiand> mh
[21:43:16] <fabiand> ok
[21:43:26] <fabiand> #[test] works
[21:44:29] <fabiand> tjc, that's the code http://www.fpaste.org/23803/13733198/
[21:44:44] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[21:44:44] <fabiand> the executable helloworldbench is build, but 0 tests are recognized
[21:45:31] <jack> there is not a trait for += and -= now?
[21:45:32] <tjc> fabiand: 1 sec, I'll try it
[21:45:38] <strcat> jack: not yet, there will be though
[21:45:40] <fabiand> tjc, I updated the repo .. if it helps
[21:45:43] <tjc> I haven't tested the bench stuff as much, so there may be a bug in how rustpkg handles benches
[21:45:48] <strcat> jack: that's why it no longer gets implemented by Add
[21:46:57] *** Quits: Jesin (Jessin_@moz-48B48C95.eecs.lehigh.edu) (Ping timeout)
[21:47:42] *** Quits: cowboyd (cowboyd@moz-1BD02A1E.sw.biz.rr.com) (Client exited)
[21:48:29] <tjc> fabiand: You're right, it doesn't seem to be working. I'll keep looking, possibly file a bug
[21:48:44] <fabiand> tjc, thanks that you could confirm it .. 
[21:48:52] <fabiand> at least it was a nice start with rustpkg :)
[21:48:58] <brson> graydon: is there documentation on the milestone nomination process?
[21:49:06] <graydon> brson: no, I don't think so
[21:49:11] <fabiand> thanks, tjc, for your help .. but it's getting late here ... 
[21:49:20] <brson> graydon: ok, peeps are doing it wrong
[21:49:26] <graydon> if you want I can write some up
[21:49:29] <tjc> fabiand: no problem, keep an eye on the bug database to see whether the bench thing ends up being a bug or not :-)
[21:49:31] <brson> no, I'll do it
[21:49:38] <graydon> k
[21:49:39] <fabiand> tjc, i will :)
[21:49:51] <graydon> I think I discovered a .. fascinating possible performance issue in the test runner
[21:50:07] <graydon> it appears to parse terminfo anew, for each line of output.
[21:50:16] <graydon> (doing some cleanup in test runner today)
[21:50:43] <graydon> I wonder if that's actually part of why things are slow on aws..
[21:50:45] *** Quits: bent (chatzilla@F2D29657.F60B0462.67AC9B1.IP) (Quit: ChatZilla 0.9.90-rdmsoft [XULRunner 18.0.2/20130201065344])
[21:50:46] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[21:50:47] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[21:50:53] <graydon> filesystem access is abysmal
[21:50:54] <brendanc> hard to imagine per-line cost dominating
[21:51:07] *** Quits: dwhyte (dwhyte@ED9190FB.B72E355F.7BF4A4B0.IP) (Ping timeout)
[21:51:19] <brson> it could though, unit tests are supposed to run very quickly, accessing file system is very slow
[21:51:29] *** Joins: erickt1 (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[21:51:36] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Quit: Leaving.)
[21:51:43] <brson> terminfo accesses filesystem?
[21:51:44] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[21:52:03] <strcat> brson: yeah there's a terminfo db
[21:52:10] <strcat> it uses TERM to look up the corresponding file
[21:52:11] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[21:52:13] *** Quits: erickt1 (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Connection reset by peer)
[21:52:20] <sp3d> graydon: it should be cached into RAM after the first read, if the OS is set up reasonably?
[21:52:23] *** Joins: dwhyte (dwhyte@ED9190FB.B72E355F.7BF4A4B0.IP)
[21:52:27] <graydon> one would hope!
[21:52:28] <tjc> graydon: are there any tests for #[bench]?
[21:52:29] <brson> we've also just got general scheduler issues too. I typically expect ~%50 cpu utilization for parallel workloads
[21:52:32] <fabiand> tjc, Is there a chance that yor github account is catamorphism? :)
[21:52:37] <tjc> fabiand: yes, that's me
[21:52:43] <sp3d> IO routines might be ugly, but it wouldn't be hitting 'disk' (however aws virtualizes things)
[21:52:43] <fabiand> tjc, there are a couple of bugs open against rustpkg .. ah :)
[21:52:44] <graydon> tjc: there's a very small one in, um, bitv I think?
[21:52:46] *** Quits: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch) (Quit: Leaving.)
[21:52:52] <graydon> tjc: I'm improving bench some today also
[21:53:11] <graydon> brson: yeah, it seems to spawn 2 new threads per test also, to read the output
[21:53:12] <brendanc> brson: make check ran for me at less than 25% available on a 16 core vm fwiw
[21:53:14] <tjc> graydon: ok. compiling a file with #[bench] in it with rustc --test seems to produce an executable that doesn't run the benchmark
[21:53:23] <brendanc> 353% CPU time
[21:53:23] <tjc> it's still --test, right, and not --bench? (--bench seems to be rejected anyway)
[21:53:24] <graydon> tjc: run the benchmark with --bench
[21:53:30] <graydon> --bench is on the runner
[21:53:40] <graydon> --test is how you compile all tests-and-benchmarks into a runner
[21:53:45] <graydon> --test is for rustc
[21:53:50] <graydon> --bench is for the runner
[21:54:04] <graydon> as in ./mytestsandbenchmarks => run tests only
[21:54:17] <graydon> ./mytestsandbenchmarks --bench => run tests and benchmarks
[21:54:34] <graydon> the assumption is that most of the time people do not want to run their benchmarks. maybe that's wrong.
[21:54:46] <strcat> graydon: do they run once when you run tests?
[21:54:51] <graydon> (I'm adding the performance-ratchet presently, so that will be .. tempting to turn on always)
[21:54:59] <graydon> they run when you run with --bench
[21:55:13] <graydon> I am clearly not .. making myself clear :(
[21:55:28] <strcat> graydon: well I know they run many times with --bench to get a benchmark
[21:55:34] <strcat> wasn't clear on whether they ran once without --bench
[21:55:34] <graydon> yes
[21:55:35] *** Joins: pnkfelix1 (pnkfelix@moz-43495417.fbx.proxad.net)
[21:55:40] *** Joins: Houm (Houm@moz-25669AA8.fbx.proxad.net)
[21:55:43] <graydon> oh, no, they don't run at all without --bench
[21:55:59] <graydon> maybe I should just always run all benchmarks unless you inhibit them?
[21:56:05] <graydon> (and always run in ratchet mode?)
[21:56:10] <strcat> dunno :)
[21:56:15] *** Joins: vk (vk@2AAA6DD0.B568D26C.93B001FA.IP)
[21:56:25] <engla> not sure if bench test are relevant on non-optimized builds
[21:56:35] <relistan> Quick 0.7 question if anyone has a sec: in 0.6 I could pas ~"something".to_bytes() to a fn that took ~[u8] .  In 0.7 to_bytes() is gone and I seem to have to call as_bytes().to_owned() everywhere.  Am I doin' it wrong?
[21:56:40] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Ping timeout)
[21:56:44] <tjc> graydon: even if I add --bench when running the executable, it makes no difference
[21:56:47] *** Joins: MaikKlein (maik@moz-54A7C76.dip0.t-ipconnect.de)
[21:56:49] *** Quits: fabiand (fabiand@moz-DDE1FFB.adsl.alicedsl.de) (Quit: Verlassend)
[21:56:51] <graydon> tjc: which executable?
[21:56:52] <brson> graydon: oh, yeah, those two extra threads are nasty
[21:57:02] <bblum> aatch|gone: are the atomic types intentionally copyable? it feels dangerous for them to be copyable.
[21:57:05] <tjc> graydon: the one generated when I compile the #[bench]-containing file with --test
[21:57:15] <graydon> tjc: can you pastebin the file and what you ran?
[21:57:19] <graydon> because that should work
[21:57:26] <tjc> graydon: 1sec
[21:57:51] *** Quits: vk (vk@2AAA6DD0.B568D26C.93B001FA.IP) (Quit: vk)
[21:59:13] <tjc> graydon: https://gist.github.com/catamorphism/5952847
[21:59:26] <relistan> Example of what I'm doing: https://bitbucket.org/relistan/cryptorust/src/b384164d94aab036d9dd334ce8843fea2d96bfe0/crypto.rs?at=master#cl-163
[21:59:31] *** Quits: lmandel (lmandel@F2D29657.F60B0462.67AC9B1.IP) (Quit: lmandel)
[21:59:43] <graydon> tjc: that's not a benchmark function
[22:00:32] <graydon> tjc: look at the bench harness tests in extra::bitv
[22:00:39] <engla> needs signature   f(b: &mut test::BenchHarness) { do b.iter { /* test code */ } }
[22:00:52] <graydon> you have to use the benchmark harness, otherwise it's silently discarded (much like other malformed tests, IIRC)
[22:01:03] <graydon> I think there's a bug on that. I'll try to fix it so it complains properly.
[22:01:07] <tjc> ok
[22:01:09] *** Joins: cscehr (Mibbit@AE48690.2C9B3718.5B998C92.IP)
[22:02:17] *** Joins: Jesin (Jessin_@moz-1B1307FF.eecs.lehigh.edu)
[22:02:46] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[22:03:09] *** Joins: olleharstedt (Thunderbir@moz-80D8890F.ias.bredband.telia.com)
[22:03:21] <olleharstedt> 12:02:09 AM - ollehar: any short-hand notation for matching on first argument in a function?
[22:03:21] <olleharstedt> 12:02:26 AM - ollehar: ocaml has "function" as "fun x -> match x with ..."
[22:03:31] *** Quits: jdm (jdm@F2D29657.F60B0462.67AC9B1.IP) (Ping timeout)
[22:03:36] <graydon> olleharstedt: nope
[22:03:38] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[22:03:46] <olleharstedt> roger that
[22:03:47] <pcwalton> olleharstedt: no, but you can use irrefutable destructuring in function arguments
[22:03:54] <graydon> olleharstedt: you can use ... yeah, what patrick said
[22:04:12] <graydon> we just don't have refutable pattern / multi-clause form for functions
[22:04:47] *** Quits: reyre (rick@B2D8AB09.33EE9F8A.1139E686.IP) (Ping timeout)
[22:04:50] *** Quits: relistan (relistan@moz-2DE8112B.cable.virginmedia.com) (Quit: relistan)
[22:05:04] <olleharstedt> pcwalton: ok, cool!
[22:05:22] *** Quits: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com) (Quit: webber46)
[22:06:29] *** Quits: pauls_ (paul@moz-9B39917C.c3-0.smr-ubr2.sbo-smr.ma.cable.rcn.com) (Ping timeout)
[22:06:54] <graydon> am I the only emacs user in the group anymore?
[22:06:59] <olleharstedt> actually, that is possible in ocaml too. didn't know that.
[22:07:15] <tjc> graydon: I use emacs
[22:07:19] <olsonjeffery> graydon: i too
[22:07:37] <graydon> have either of you fought it into believing that 'self is not a malformed character constant?
[22:07:49] <tjc> graydon: No, I just suffer in silence
[22:07:52] <graydon> (i.e. convinced it not to color the screen string-colored most of the day)
[22:08:09] *** Joins: rusti_ (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[22:08:11] * graydon stares angrily at code that _clearly should work_ in the emacs mode
[22:08:11] <olsonjeffery> same.
[22:08:30] * sully shaving yaks again
[22:08:40] <graydon> I wish marijn were around, I would ask him how this mode works
[22:08:44] *** Quits: rusti_ (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[22:08:53] <sully> what is marijn up to these days?
[22:09:14] *** pnkfelix1 is now known as pnkfleix
[22:09:19] *** pnkfleix is now known as pnkfelix
[22:09:24] <strcat> graydon: heh even this silly js editor knows that
[22:09:37] <graydon> you mean the one marijn wrote? :)
[22:09:49] <strcat> hm, or does it
[22:10:00] <graydon> he is doing awesome stuff as usual, but I think it's js-related
[22:10:12] <strcat> graydon: well maybe, mozilla seems to be involved with ace
[22:10:16] <graydon> yeah
[22:10:17] <olsonjeffery> tern makes emacs segfault, for me :(((
[22:10:22] <strcat> I used it to throw together a quick UI for the evalbot
[22:10:23] <olsonjeffery> i really wanted to like it, too
[22:10:34] <strcat> graydon: http://strcat.zapto.org:8000/
[22:10:38] <strcat> it has a rust mode ;p
[22:10:58] <graydon> I saw, it's fantastic!
[22:11:06] <graydon> do you want me to point playpen.rust-lang.org at it or something?
[22:11:22] <strcat> graydon: well I don't really have enough bandwidth :(
[22:11:37] <strcat> I could make a qemu instance with this in it though, if you have somewhere to put it
[22:11:39] <graydon> ok. do you want me to copy it to a machine with bandwidth? :)
[22:11:45] <strcat> graydon: yeah :)
[22:12:03] <graydon> k. it will take a little while but if you can prepare it I'll talk to someone who opens up ports and such.
[22:12:13] <graydon> maybe we don't put it on the machine with the buildbot though :)
[22:12:32] <strcat> graydon: well it needs a fair bit of memory since each request is 60-120MiB
[22:12:44] <strcat> rustc still loves eating ram
[22:12:47] <graydon> yeah
[22:13:21] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: Leaving)
[22:13:25] <pcwalton> given that aatch|gone's changes to the AST made a large difference in mem usage I am wondering if we should redo the AST to use the Servo inheritance pattern
[22:13:27] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[22:13:28] <cmr> Wow, a bunch of stuff actually landed while I was out!
[22:13:41] * cmr is pleasantly surprised
[22:13:43] <brson> graydon: I wrote some up about nomination here https://github.com/mozilla/rust/wiki/Note-milestone-nomination
[22:14:22] *** Joins: pauls_ (paul@moz-9B39917C.c3-0.smr-ubr2.sbo-smr.ma.cable.rcn.com)
[22:15:02] <graydon> brson: thanks!
[22:15:09] <MaikKlein> servo inheritance pattern?
[22:15:38] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Quit: Leaving.)
[22:15:47] *** Quits: olleharstedt (Thunderbir@moz-80D8890F.ias.bredband.telia.com) (Ping timeout)
[22:16:43] <strcat> rusti: 2
[22:16:44] -rusti- 2
[22:17:01] *** Joins: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu)
[22:17:45] <jack> did someone change how linkargs are resolved?
[22:18:23] <sully> hm, stage0 compiles should be done with -W unrecognized-lint
[22:18:34] <sully> er, whatever makes it ignored
[22:19:08] <acrichto> sully: once the next snapshot is made it'll have '-A warnings'
[22:19:34] <jack> tjc: perhaps this linkargs thing is related to your rustpkg work?
[22:19:41] <strcat> acrichto: ah so it'll only disallow them in stage{1,2}?
[22:19:54] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Quit: Leaving.)
[22:19:56] <cmr> aatch|gone was working on a snapshot I thought
[22:19:56] <tjc> jack: hmm, I haven't checked in rustpkg changes in the past week
[22:19:58] <acrichto> strcat: for lib{std,extra,rustpkg} yes
[22:20:01] <jack> basically servo fails to link with latest rust, using -L../../foo/libbar -lbar type link args
[22:20:02] <strcat> rusti: use std::cast::transmute; let x = ~5; unsafe { let y: *int = transmute(x); println((*y).to_str()); let _: ~int = transmute(y); }
[22:20:03] -rusti- 5
[22:20:03] -rusti- ()
[22:20:18] <jack> tjc: it would have been in the last 2 weeks or so
[22:20:46] *** Quits: MaikKlein (maik@moz-54A7C76.dip0.t-ipconnect.de) (Ping timeout)
[22:20:54] <mark_edward> strcat: do you have any recommendations for my bzip compression thing?
[22:20:57] <jack> it seems to be looking relative to source files not build products now
[22:21:05] <mark_edward> you think i should make it a Reader,  write?
[22:21:08] <mark_edward> *right?
[22:21:09] <strcat> mark_edward: dunno the best way to do it, I think you'll eventually want a Reader
[22:21:29] <mark_edward> I'll try out the Reader route. i think it may work out well
[22:21:46] *** Joins: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[22:21:47] <mark_edward> i'll make seek a no-op. doesn't make sense for stream type things anyway
[22:22:21] <tjc> jack: the last change I made to rustc itself was June 25 - 3789433b4f588301140c97bb5b67094a8c8576cc
[22:22:30] *** Quits: Jesin (Jessin_@moz-1B1307FF.eecs.lehigh.edu) (Ping timeout)
[22:22:43] <sully> acrichto: that will disable all warning on the stage0 build?
[22:22:43] <tjc> actually, that shouldn't matter
[22:22:44] <cmr> seek and tell don't really make sense for Reader I think
[22:22:49] <graydon> fwiw, we're having a datacenter outage presently :(
[22:22:57] <acrichto> sully: yes, for some libraries
[22:23:02] <mark_edward> strcat: should the compressor really be returning a Result enum?
[22:23:04] <strcat> graydon: as in AWS?
[22:23:18] <strcat> mark_edward: if there's more than one way it could fail
[22:23:21] <mark_edward> i mean, compression can't really fail, as long as i've written everything right, no matter what you give it
[22:23:21] <strcat> otherwise just Option
[22:23:29] <graydon> as in SCL3, the one holding many mozilla properties
[22:23:30] <strcat> mark_edward: oh compression
[22:23:36] <strcat> yeah, compression should probably always succeed
[22:23:40] <strcat> decompression should like use Option
[22:23:42] <jack> tjc: ok hmm. was hoping you'd know :)
[22:23:57] <tjc> jack: sorry, doesn't seem to have to do with something I changed :-)
[22:24:11] <tjc> I remember there being a commit involving linker args recently, but I can't think of more specific details
[22:24:28] * strcat switched it to using spaces instead of commas
[22:24:36] <strcat> but I think it would be saner to just accept it multiple times
[22:24:46] <strcat> I need a way to pass -Wl,foo
[22:24:48] <strcat> needed*
[22:25:06] <strcat> (it's weird that we pass link args to gcc...)
[22:25:26] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[22:25:26] *** ChanServ sets mode: +o dherman
[22:26:11] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[22:26:20] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[22:26:22] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Client exited)
[22:26:35] <pcwalton>  189 files changed, 2130 insertions(+), 1702 deletions(-)
[22:26:37] <pcwalton> removing copy
[22:26:47] <pcwalton> and not done yet
[22:27:01] <tikue> wow
[22:27:05] <pcwalton> but libsyntax/librustc/tests are de-copied
[22:27:26] *** Joins: z0w0 (zack@moz-37A98529.lnse2.woo.bigpond.net.au)
[22:28:48] <cmr> This are all unused copies from the lint, right?
[22:28:56] <pcwalton> no, this is every use of "copy"
[22:28:58] <pcwalton> I already got those out
[22:29:00] <cmr> oh
[22:29:08] <pcwalton> changing to .clone()
[22:29:09] <cmr> oh my
[22:30:54] <strcat> pcwalton: is it possible to teach the compiler to just fake it for fixed-size arrays for now? (as in hardcoded support)
[22:31:02] <pcwalton> I suppose, but I'd rather not
[22:31:05] <pcwalton> unless we have to
[22:31:19] <pcwalton> it'd be ugly
[22:36:36] *** Quits: z0w0 (zack@moz-37A98529.lnse2.woo.bigpond.net.au) (Client exited)
[22:36:50] <bblum> brson: ping, is there an issue number i can tag a fixme with for "the scheduler workqueue shouldn't be implemented with an exclusive"?
[22:38:30] <cmr> https://mozillians.org/en-US/u/cmr/ anyone vouch for me? :)
[22:38:47] <brson> bblum: there isn't an issue specifically dedicated to the work queue. the closest is 3095
[22:39:03] <bblum> cool thanks
[22:40:09] *** Joins: Jesin (Jessin_@moz-48B48C95.eecs.lehigh.edu)
[22:41:15] *** Quits: dew (Instantbir@moz-66796D51.dhcp.stls.mo.charter.com) (Quit: Instantbird 1.4 -- http://www.instantbird.com)
[22:41:21] *** Quits: igl (igl@moz-E5D24A9D.adsl.alicedsl.de) (Ping timeout)
[22:41:55] *** Quits: smvv_ (sander@moz-BAEA8EB2.dynamic.upc.nl) (Ping timeout)
[22:41:55] *** Quits: vilonis (jared@moz-E76B3E97.ph.ph.cox.net) (Ping timeout)
[22:42:06] *** Joins: vilonis (jared@moz-E76B3E97.ph.ph.cox.net)
[22:42:26] *** Quits: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Quit: Leaving.)
[22:42:40] *** Joins: igl (igl@moz-2AD994FE.adsl.alicedsl.de)
[22:43:52] *** Quits: vilonis (jared@moz-E76B3E97.ph.ph.cox.net) (Quit: WeeChat 0.3.8)
[22:43:58] *** aatch|gone is now known as aatch
[22:44:31] <glinscott> if i have a trait impl, and want to refer to &mut self in an inner function, what is the best way?  ie. "impl foo for ~str { fn bar(&mut self) { fn baz(s : &mut ~str) { â€¦ } } }"
[22:45:03] *** Quits: RMF (RMF@moz-ABD30586.dsl.telepac.pt) (Quit: Textual IRC Client: www.textualapp.com)
[22:45:44] <graydon> strcat: how do I do hashmap.each_value()._all() | ... | { .. } ?
[22:46:07] <graydon> mut_iter I guess?
[22:46:13] <graydon> or just iter
[22:46:19] <graydon> yeah, ok, duh me
[22:46:21] <strcat> graydon: just iter() if you don't want to mutate the values
[22:47:24] *** Quits: Houm (Houm@moz-25669AA8.fbx.proxad.net) (Ping timeout)
[22:47:46] <aatch> Anybody know why this keeps happening: http://buildbot.rust-lang.org/builders/auto-win-32-nopt/builds/326/steps/compile/logs/stdio
[22:47:49] <tikue> the iterable trait would be used so that you don't have to say .iter(), right? you'd still have to say mut_iter() if you want a mutable iterable?
[22:47:58] <strcat> tikue: yeah
[22:48:23] *** Joins: Houm (Houm@moz-25669AA8.fbx.proxad.net)
[22:48:27] <tikue> strcat: is there any way that mut_iter() could be context inferable?
[22:48:28] <graydon> aatch: nope
[22:48:38] <strcat> tikue: no
[22:48:49] <tikue> ah, too bad
[22:48:59] <strcat> even an Iterable trait is somewhat problematic because of how weird &[T] is
[22:49:11] <strcat> you end up with &'r &'r [T]
[22:49:15] *** Quits: huseby (huseby@moz-4E8C421A.husebyhome.com) (Input/output error)
[22:49:16] <tikue> weird
[22:49:18] <aatch> Argh, it repeats but I've got not idea what's causing it
[22:50:16] <cmr> hasn't that been happening intermittently?
[22:51:14] <strcat> cmr: it always happens on aatch's PR though
[22:51:14] <aatch> cmr, I dunno but it happened 3 times in a row on my PR and others have gotten through fine
[22:51:30] <cmr> ah
[22:51:44] <graydon> q:
[22:51:57] <graydon> if I use |(&k,_)| in a lambda list
[22:52:10] <graydon> is that going to copy k out of the arg?
[22:52:17] <cmr> yes
[22:52:21] <graydon> figured
[22:52:25] <strcat> graydon: if it's implicitly copyable, otherwise it won't work
[22:52:28] <graydon> mhm
[22:52:28] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[22:52:34] <cmr> strcat: even if it isn't implicitly copyable
[22:52:35] <bblum> strcat: no, otherwise it will work, but be unsound
[22:52:37] <cmr> it's broken atm
[22:52:39] <strcat> bblum: oh right
[22:52:46] <strcat> I forgot that irrefutable patterns are still broken
[22:52:48] <strcat> :)
[22:52:48] <graydon> (is it charming or horrifying that I don't actually know?)
[22:52:52] <cmr> I think niko's irrefut pr fixes that
[22:52:53] <bblum> charming
[22:52:57] *** Joins: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[22:53:00] *** Quits: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP) (Quit: night)
[22:53:02] <tikue> ;p
[22:53:05] <bblum> but yes, be careful that you don't copy any ARC handles or pipes or anything
[22:53:42] <cmr> graydon: I find it incredibly amusing that I've seen *all* the core devs ask various questions about rust, when ostensibly they're the ones who should know the most :p
[22:54:17] <strcat> yeah but I only know modern rust
[22:54:33] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[22:54:34] <strcat> I have no idea what argument modes were, beyond a vague idea of the concept, etc.
[22:54:43] <graydon> you are lucky for that
[22:54:43] <tjc> cmr: any piece of software is only successful when no single person understands it :-)
[22:55:11] <aatch> The compiler apparently hates me. It happily accepted me introducing a regression and now won't let me fix it...
[22:55:22] <cmr> heh
[22:56:32] *** Quits: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Quit: Leaving.)
[22:56:54] <jack> what's the right way to add link args for a C lib that isn't in the same directory as the crate?
[22:58:12] <aatch> Sigh, I know what caused that regression and the "proper" fix is to make the entire AST uniquely owned
[22:58:14] <graydon> aatch: that's the sort of thing they warned us about when we said we'd be self-hosting
[22:58:29] *** Quits: Ripp__ (quassel@moz-16954008.hsd1.ca.comcast.net) (Ping timeout)
[22:58:34] <cmr> aatch: *evil cackle* now go on, rewrite it!
[22:58:43] <graydon> aatch: how far towards the proper solution do you have to go before the regression goes away
[22:59:10] <aatch> graydon, not sure, I'm in the middle of one of the bigger blocks now
[22:59:33] <aatch> but reverting the change to Ty turns it from a 300MB regression to something much smaller
[22:59:42] <aatch> it just won't accept it.
[23:00:48] <aatch> graydon, the AST index is, from what I can tell, the only object to actually take advantage of te fact that the AST has shared pointers
[23:01:07] <graydon> "won't accept it" how?
[23:01:10] *** Joins: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[23:01:19] <aatch> graydon, that error I posted
[23:01:33] <aatch> has happened 3 times on this: https://github.com/mozilla/rust/pull/7644
[23:01:36] <strcat> jack: just -lfoo, and put it in the library path with LD_LIBRARY_PATH=dir
[23:01:51] <strcat> jack: ideally the C libs would all be in global locations included in your /etc/ld.so.cache
[23:02:14] <graydon> aatch: huh. that's sad.
[23:02:17] <strcat> (although you probably don't want to link relative to a dir)
[23:02:29] <graydon> aatch: it's probably an actual crash. try valgrinding your change?
[23:02:35] * strcat shrugs
[23:02:40] <aatch> graydon, hmm, good idea.
[23:02:50] <strcat> the only really sane way to deal with silly dynamic linking is a single global package manager
[23:03:00] <jack> strcat: these are servo depencies. we've been using link_args="-L../../foo/libar -lbar" but that has stopped working :(
[23:03:01] *** Quits: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Ping timeout)
[23:03:18] <strcat> jack: that seems like it should work
[23:03:31] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[23:03:46] <strcat> but it will only work because of the fragile rpath stuff
[23:03:49] <jack> it builds the crates, but building servo fails during link. it can't find those relative dirs
[23:04:09] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[23:04:09] *** ChanServ sets mode: +o brson
[23:04:23] <strcat> jack: ideally they would all just end up in a lib dir in LD_LIBRARY_PATH
[23:04:27] <strcat> for the build
[23:05:07] *** Joins: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net)
[23:05:24] <tikue> brson: these linking problems that jack is havingâ€¦it sounds really familiar to that thing that you helped me with a few weeks back. I don't remember the specifics but didn't we try messing with the levels in the crate hierarchy?
[23:05:43] <tikue> similar* not familiar -___-
[23:05:56] *** Joins: CraigE (craige@moz-DF25A0FC.wi.res.rr.com)
[23:06:25] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[23:06:53] *** Quits: cr (anonymous@moz-6968310D.dip0.t-ipconnect.de) (Ping timeout)
[23:06:53] <brson> tikue: yes, I was worried that having different directory depths was going to make the relative paths wrong when the link args were propagated to downstream crates. I recall that we ended up solving your problem though by wishing it away
[23:07:11] <dbaupp> aatch: ping
[23:07:30] *** Quits: brendan (brendaneic@2557E599.66715431.D25A875A.IP) (Quit: brendan)
[23:07:51] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[23:07:53] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[23:07:53] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/fncOvQ
[23:07:53] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[23:08:02] <tikue> brson: yeah I don't think we ever figured out why it was affecting only me, but I just cherry picked onto master and it stopped happeing
[23:08:16] <jack> brson: that appears to be exaclty what's happened. but i can't figure out why it would break now, and not when we moved the hierarchy
[23:09:04] *** Joins: cr (anonymous@moz-4C21C3DA.dip0.t-ipconnect.de)
[23:09:47] <pcwalton> oh boy, rust tried to free a null pointer
[23:09:51] <pcwalton> when I removed "copy" from rustdoc
[23:09:53] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Textual IRC Client: www.textualapp.com)
[23:10:00] *** Joins: huseby (huseby@moz-4E8C421A.husebyhome.com)
[23:10:04] * pcwalton loves our glue
[23:10:07] *** Joins: jclements (jclements@2557E599.66715431.D25A875A.IP)
[23:10:11] *** Quits: mib_il5ws1 (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[23:10:25] <jack> strcat: if i switch the rustc commandline to include LD_LIBIRARY_PATHs will i need to set LD_LIBRARY_PATH when the binary is run?
[23:10:48] <strcat> pcwalton: freeing null is technically fine, but I thought it was supposed to add checks around it to call the contained type's glue?
[23:10:52] * strcat shrugs
[23:10:55] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[23:10:55] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/deZapg
[23:10:55] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[23:10:56] <pcwalton> it hits an assert
[23:10:57] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[23:10:57] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/9pTqIw
[23:10:57] <ghrust> 13rust/06auto 1451eb1e1 15Daniel Micay: str: stop encoding invalid out-of-range `char`
[23:10:57] <ghrust> 13rust/06auto 1430c8aac 15bors: auto merge of #7612 : thestinger/rust/utf8, r=huonw
[23:10:57] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[23:11:08] *** Joins: brendan (brendaneic@2557E599.66715431.D25A875A.IP)
[23:11:20] <cmr> pcwalton: not that this is a real solution, but... kill rustdoc!
[23:11:49] * strcat wonders if it's something he broke
[23:11:59] *** Quits: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP) (Quit: eatkinson)
[23:12:02] <strcat> don't *really* think so
[23:15:07] <brson> graydon nmatsakis: I intend to start trying to upstream brson/io for serious now, but I don't have an r+ yet. The commit graph is going to be appalling, sadly, with lots of merges in many directions.
[23:15:19] <bjz> how is bors going?
[23:15:26] <graydon> brson: ok
[23:15:33] <strcat> bjz: slow and steady
[23:15:50] <bjz> strcat: chugging through the weekend's commits?
[23:16:10] <graydon> brson: I think, well, at this point I would be a perfect specimen of "bikeshed syndrome" wherein the commit is so huge I just rubber-stamp it
[23:16:19] <cmr> bjz: he did pretty good this weekend
[23:16:36] <graydon> brson: I have poked my head in from time to time and the structure of it seems much improved from the old system
[23:16:41] <Jeaye> I want to dedup a vec whilst keeping the last occurrence of each item. Is there a nice Rustic way of doing this?
[23:16:48] <bjz> cmr: just selfishly wondering if mine dropped off
[23:16:49] <graydon> brson: as well as the coding style, documentation and test coverage, etc. etc.
[23:16:54] *** Quits: huseby (huseby@moz-4E8C421A.husebyhome.com) (Quit: Leaving)
[23:16:57] <bjz> cmr: it was a very little one
[23:17:19] <graydon> brson: so I would say r+ even though, in truth, I haven't reviewed the patch series in full (and as you say, it's got to the point where reviewing its history is not terribly comprehensible anyways)
[23:17:20] <cmr> bjz: http://buildbot.rust-lang.org/bors/bors.html exists you know
[23:17:39] <bjz> ooh
[23:17:42] <cmr> it's still in there
[23:17:58] *** graydon changes topic to 'http://www.rust-lang.orgÂ | logs at https://botbot.me/mozilla/rust/ and http://irclog.gr/#browse/irc.mozilla.org/rust | http://huonw.github.io/isrustfastyet/mem/ | landings http://buildbot.rust-lang.org/bors/bors.html'
[23:18:00] *** Joins: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP)
[23:18:07] <bjz> cmr: thanks!
[23:18:14] <bjz> cmr: very useful
[23:18:25] <cmr> how can you live without looking at the bors queue every waking moment!
[23:18:48] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[23:18:59] <graydon> did dotdash's stuff land? hmm
[23:19:29] <cmr> he pulled it out
[23:19:35] <graydon> oh?!
[23:19:44] <cmr> it had an error when rebased on top of strcat's stuff iirc
[23:19:53] <cmr> said he'd fix it later
[23:20:27] <pcwalton> now a segfault :(
[23:20:47] <cmr> `error: internal compiler error: type checking without entry function` why does typeck need an entry function? to have a place to start for inference?
[23:20:47] *** Joins: huseby (huseby@moz-4E8C421A.husebyhome.com)
[23:22:07] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[23:22:22] <cmr> surely not, since lib crates don't have an entry point?
[23:22:26] <bblum> brson: the test suite claims that there are times in deschedule_running_task_and_then when the cleanup job runs in task context
[23:24:39] <olsonjeffery> brson: what does landing brson/io entail? new scheduler by default? or just the new io system in std?
[23:24:41] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[23:25:31] <brson> bblum: yes, the cleanup_job executing *in* deschedule_running_task_and_then will always be in task context. the cleanup job that is enqueued by deschedule_running_task_and_then will be run from some other function
[23:25:49] <bblum> ahhhh.
[23:25:59] <bblum> *always* in task context? not just sometimes?
[23:26:23] <brson> bblum: always, since deschedule_running_task_and_then itself is always run from task context
[23:26:31] <bjz> cmr: http://www.reddit.com/r/rust/comments/1hwbpp/bors_queue_status/
[23:26:44] <brson> olsonjeffery: sadly, as of yet my branch has no visible changes
[23:26:51] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[23:26:57] <brson> olsonjeffery: nothing will be turned on by default yet
[23:27:17] <bblum> ah right, the context that is entered in is the one that is exited in
[23:27:21] <brson> but the scheduler is almost usable by default. just a small amount of runtime porting still
[23:27:39] <pcwalton> http://www.yl.is.s.u-tokyo.ac.jp/~tosh/kml/
[23:27:53] <pcwalton> use case for rust
[23:27:57] <olsonjeffery> brson: ive been reviewing the master issues around the scheduler stuff and trying to find a place to pitch in.. ill be following up soon
[23:28:05] <olsonjeffery> exciting times!
[23:28:28] <cmr> pcwalton: interesting
[23:28:32] <cmr> olsonjeffery: awesome!
[23:28:36] <brson> olsonjeffery: great!
[23:29:02] * olsonjeffery hopes his claim to fame in rust won't always be 'the guy who prototyped the io-abstraction-so-bad-it-lead-to-a-new-scheduler ;)
[23:29:43] <bjz> rusti: use std::cast::transmute; let arr = &[1, 2, 3, 4, 5, 6]; let p: *int = unsafe { transmute(&arr) }; unsafe { *p.offset(2).offset(-1) }
[23:29:44] -rusti- 48
[23:29:55] <bjz> :S
[23:30:18] <bjz> rusti: use std::cast::transmute; let arr: &[int] = &[1, 2, 3, 4, 5, 6]; let p: *int = unsafe { transmute(&arr) }; unsafe { *p.offset(2).offset(-1) }
[23:30:20] -rusti- 48
[23:30:27] <brson> olsonjeffery: lol
[23:31:17] <strcat> bjz: decided to help bors out a bit, made another rollup one ;p
[23:31:18] <bjz> why is it so?
[23:31:29] <dbaupp> rusti: use std::cast::transmute; let arr: &[int] = &[1, 2, 3, 4, 5, 6]; let p: *int = unsafe { transmute(&arr) }; unsafe { *p.offset(1) }
[23:31:30] <bjz> 48?
[23:31:30] -rusti- 48
[23:31:46] <bjz> :P
[23:31:59] <dbaupp> rusti: use std::cast::transmute; let arr: &[int] = &[1, 2, 3, 4, 5, 6]; let p: &[u8] = unsafe { transmute(&arr) }; p
[23:32:00] -rusti- <anon>:1:0: 1:0 error: transmute called on types with different sizes: &&[int] (64 bits) to &[u8] (128 bits)
[23:32:00] <bjz> wut
[23:32:00] -rusti- <anon>:1 #[allow(default_methods)];
[23:32:00] -rusti-          ^
[23:32:00] -rusti- application terminated with error code 101
[23:32:04] *** Quits: pyrac (pyrac@moz-B0599561.w92-162.abo.wanadoo.fr) (Quit: pyrac)
[23:32:05] <strcat> bjz: 6 * 8
[23:32:13] <strcat> int is 8 bytes
[23:32:20] <dbaupp> bjz: ah, you're casting a pointer to the array, not the array itself
[23:32:20] *** Quits: Jesin (Jessin_@moz-48B48C95.eecs.lehigh.edu) (Input/output error)
[23:32:40] <dbaupp> rusti: use std::cast::transmute; let arr: &[int] = &[1, 2, 3, 4, 5, 6]; let p: *int = unsafe { transmute(arr) }; unsafe { *p.offset(1) }
[23:32:40] -rusti- <anon>:1:0: 1:0 error: transmute called on types with different sizes: &[int] (128 bits) to uint (64 bits)
[23:32:41] -rusti- <anon>:1 #[allow(default_methods)];
[23:32:41] -rusti-          ^
[23:32:41] -rusti- application terminated with error code 101
[23:32:49] <bjz> use std::cast::transmute; let arr: &[int] = &[1, 2, 3, 4, 5, 6]; let p: *int = unsafe { transmute(arr) }; unsafe { *p.offset(2).offset(-1) }
[23:32:57] <bjz> rusti: use std::cast::transmute; let arr: &[int] = &[1, 2, 3, 4, 5, 6]; let p: *int = unsafe { transmute(arr) }; unsafe { *p.offset(2).offset(-1) }
[23:32:58] -rusti- <anon>:1:0: 1:0 error: transmute called on types with different sizes: &[int] (128 bits) to uint (64 bits)
[23:32:58] -rusti- <anon>:1 #[allow(default_methods)];
[23:32:58] -rusti-          ^
[23:32:58] -rusti- application terminated with error code 101
[23:33:04] <dbaupp> rusti: use std::cast::transmute; let arr: &[int] = &[1, 2, 3, 4, 5, 6]; let (p,_): (*int, uint) = unsafe { transmute(arr) }; unsafe { *p.offset(1) }
[23:33:05] *** Joins: paupau (textual@moz-D6583788.hsd1.ca.comcast.net)
[23:33:05] -rusti- 2
[23:33:09] <Jeaye> I want to dedup a vec whilst keeping the last occurrence of each item. Is there a nice Rustic way of doing this?
[23:33:19] <dbaupp> bjz: (you probably want .as_imm_buf though)
[23:33:26] <strcat> graydon: hm the bors status page seems to be down
[23:33:46] <Eridius> Jeaye: make an Iterator adaptor that dedupes?
[23:33:48] <cmr> http://rustlog.octayn.net/post/54952611545/status-update, 'night all
[23:34:02] <graydon> as I said, the datacenter containing it is .. having issues today
[23:34:04] <graydon> 'night cmr
[23:34:13] <strcat> graydon: ah yeah it's all those web pages
[23:34:34] <bjz> dbaupp: was just looking at this: https://github.com/mozilla/rust/pull/7631/files#L0R355
[23:34:41] <graydon> I assume "datacenter is down" usually means something pretty bad
[23:34:47] <Jeaye> Eridius: Hmm, I'm not familiar with iterator adapters. Do you've an example of this?
[23:34:51] <graydon> I picture meteors raining out of the sky
[23:34:51] <bjz> dbaupp: and was like, 'as uint?'
[23:35:02] <dbaupp> bjz: oh, ok
[23:35:02] <Eridius> Jeaye: look at std::iterator. There's a bunch in there
[23:35:35] <bjz> dbaupp: how do the negatives work with offset?
[23:35:46] <bjz> rusti: -1 as uint
[23:35:46] -rusti- 18446744073709551615
[23:35:48] <Jeaye> graydon: Or someone tripped over a wire/spilled coffee. :P
[23:35:51] <bjz> oh ok
[23:36:00] <bjz> dbaupp: wraps around?
[23:36:06] <dbaupp> bjz: x + (-1 as uint) == x - 1 (the magic of twos complement)
[23:36:09] <dbaupp> bjz: yeah
[23:36:15] <bjz> dbaupp: yup, got it
[23:36:55] <graydon> Jeaye: big wire
[23:37:28] <Jeaye> Big coffee mug.
[23:37:54] <dbaupp> Jeaye: the easiest way is probably to write a "forward" dedup-er, and call it on .rev_iter(), then convert that into a vector and .reverse() it.
[23:39:07] <dbaupp> rusti: let mut x = ~[1,2,3,3,2,1]; x.reverse(); x.dedup(); x.reverse(); x
[23:39:08] -rusti- ~[1, 2, 3, 2, 1]
[23:39:43] *** Quits: brendan (brendaneic@2557E599.66715431.D25A875A.IP) (Quit: brendan)
[23:39:50] <sully> woo
[23:39:58] <sully> a static default method compiled for the first time!
[23:40:03] <Eridius> rusti: Some(3) == Some(3)
[23:40:04] -rusti- true
[23:40:06] <Jeaye> dbaupp: It's the "forward deduper" I'm trying to grasp.
[23:40:07] <dbaupp> ah, right, that only does consecutive ones
[23:40:14] <Luqman> sully: awesome!
[23:40:27] <Jeaye> sully: :)
[23:40:34] <graydon> sully: !!! \o/ \o/ !!!
[23:40:44] <graydon> default methods will save us
[23:40:44] <bblum> sully: does it execute?
[23:41:01] <sully> and it looks like it executed properly
[23:41:01] <dbaupp> Jeaye: oh, um, keep a hashset of things you've already seen, and only return them/put them into the vector if its not in the hashset
[23:41:19] <sully> I think that it will not work cross crate, yet
[23:41:21] <dbaupp> Jeaye: (or if requiring Hash is too much: a vector of things)
[23:41:26] <dbaupp> sully: yay!
[23:41:38] *** Joins: Ripp__ (quassel@moz-16954008.hsd1.ca.comcast.net)
[23:41:46] <sully> graydon: default methods work in very many cases now
[23:42:10] <Eridius> rusti: None != Some(3)
[23:42:11] -rusti- true
[23:42:37] <sully> graydon: non-static default methods that don't use trait inheritance work in basically every case I know of
[23:42:45] <Jeaye> dbaupp: Hmm, I just need to avoid duplicating the vector, since it's 2GB worth of data. I was quicksorting (in place) and then deduping, but that doesn't keep the last occurrence of each item. Sure was good on memory and speed though.
[23:43:00] *** Joins: BluePeppers (user@moz-3799699A.range81-151.btcentralplus.com)
[23:43:05] <bjz> what's the difference between a HashSet and a HashMap?
[23:43:26] <dbaupp> Jeaye: oh, qsort, reverse in place, dedup, reverse again?
[23:43:28] <Jeaye> bjz: uniqueness, I'd bet
[23:43:34] <sully> graydon: except for... cross crate calls of default methods that take advantage of trait bounds
[23:43:35] <pcwalton> bjz: hashsets don't have values
[23:43:44] <bjz> pcwalton: ahhh!
[23:44:02] <bjz> pcwalton: sorry, that's a *facepalm* moment
[23:44:06] <Jeaye> dbaupp: I'll try it. :P
[23:44:32] <Eridius> Jeaye: you need last specifically, not first?
[23:44:34] *** Joins: brendan (brendaneic@2557E599.66715431.D25A875A.IP)
[23:44:44] <Jeaye> Eridius: Yes.
[23:45:20] *** Quits: Ripp__ (quassel@moz-16954008.hsd1.ca.comcast.net) (Ping timeout)
[23:46:29] <Eridius> Jeaye: maybe something like this would work? https://gist.github.com/kballard/5953459
[23:46:32] <Eridius> I haven't tried compiling it yet
[23:46:36] * Eridius is recompiling rust right now
[23:46:49] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[23:46:54] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[23:47:09] <Eridius> assuming that works, you would be able to say myvec.iter().dedup().collect()
[23:47:23] <Eridius> of course that doesn't dedup in-place
[23:48:16] <dbaupp> Eridius: #5898 will mean that calling .dedup() will conflict with the vector .dedup()
[23:48:33] <Jeaye> dbaupp: qsort, reverse, dedup, reverse doesn't do it.
[23:48:42] <dbaupp> Jeaye: hm?
[23:48:53] <Jeaye> Eridius: Hot damn, I'll look at it.
[23:49:13] <dbaupp> rusti: let mut x = ~[1,2,3]; x.reverse(); x
[23:49:13] -rusti- ~[3, 2, 1]
[23:49:33] <dbaupp> Jeaye: is qsort a stable sort?
[23:49:43] <Jeaye> dbaupp: Not really.
[23:50:00] <Jeaye> It falls into an infinite loop if I negate my < op, too.
[23:50:09] <Eridius> dbaupp: pfft
[23:50:30] <dbaupp> So you won't necessarily be getting the last (in the original vector) occurrence after calling qsort
[23:50:52] <Jeaye> dbaupp: Yes, exactly.
[23:51:01] <Jeaye> Which is most unfortunate.
[23:51:11] <dbaupp> you could try one of the other sorts?
[23:51:18] <Jeaye> Aye.
[23:51:19] * dbaupp doesn't know how many are in-place
[23:51:30] <Jeaye> Only qsort, I beleive.
[23:51:39] <Jeaye> believe
[23:51:45] <Jeaye> beeleeve
[23:51:50] <Jeaye> Which is why I went with it.
[23:52:48] <jensnock_> How would one print the AST?
[23:53:08] <pcwalton> jensnock_: usually we just pretty print it
[23:53:31] <dbaupp> jensnock_: what type of printing?
[23:53:52] <dbaupp> jensnock_: (do you want to see macros expanded, or something?)
[23:54:11] <jensnock_> dbaupp: Not really, I want to see if something parsed correctly.
[23:54:42] <jensnock_> pcwalton: `rust build test.rs --pretty identified'-style?
[23:54:48] <pcwalton> yeah
[23:55:12] <dbaupp> jensnock_: it probably only works with the 'rustc' binary itself?
[23:55:23] *** Quits: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com) (Ping timeout)
[23:55:28] <jensnock_> dbaupp: No, that works with rust build as well.
[23:55:29] <Eridius> Jeaye: ok this code compiles: https://gist.github.com/kballard/5953459
[23:55:35] * Eridius aaaalmost got it right the first time
[23:55:43] <jensnock_> dbaupp: Or at least, that's how I just ran it.
[23:55:52] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[23:55:55] <dbaupp> jensnock_: oh, neat
[23:56:04] <Jeaye> Eridius: That code is beyond me.
[23:56:07] * Jeaye absorbs.
[23:56:23] <Eridius> DedupIteratorUtil allows you to call .dedup_() on an arbitrary iterator
[23:56:35] <Eridius> the important part is .next() of DedupIterator
[23:56:41] <Eridius> err just Dedup
[23:56:43] * Eridius should rename that
[23:56:48] <Eridius> I should also implement size_hint
[23:57:17] <Eridius> although tbh the size_hint would be (MIN(1, iter.size_hint.first), iter.size_hint.second)
[23:57:19] *** Quits: brendan (brendaneic@2557E599.66715431.D25A875A.IP) (Quit: brendan)
[23:57:21] <Eridius> which isn't great
[23:57:24] *** Joins: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com)
[23:57:57] <glinscott> thinking a bit about strings, right now, when parsing/building data structures, rust has to do the utf-8 parsing on the way in, and then when building up strings internally, it has to do utf-8 serialization.  any thought to storing strings as ~[char]?
[23:58:25] <Eridius> using ~[char] would increase the size of strings by 4x in most cases (e.g. ASCII)
[23:58:33] <paupau> these days most data comes in as UTF8 anyway...
[23:59:11] <strcat> Eridius: well and things like xml/html have a lot of the ascii characters
[23:59:11] <Eridius> and any interoperability with the outside world (e.g. i/o, ffi, etc) would require re-serializing as utf-8 anyway
[23:59:18] <glinscott> yes, of course UTF8 is prevalent, but once it's parsed, the goal should be to avoid manipulating utf-8
[23:59:33] <strcat> glinscott: manipulating char isn't very useful though
[23:59:45] <glinscott> strcat: i mean for things like building strings
[23:59:55] <glinscott> strcat: avoiding heavy logic there is very valuable

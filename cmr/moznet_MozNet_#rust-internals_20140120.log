[00:12:25] *** Joins: jsonnull (Thunderbir@E86DD23.582C899D.494A0F8B.IP)
[00:12:46] *** Quits: jsonnull (Thunderbir@E86DD23.582C899D.494A0F8B.IP) (Quit: jsonnull)
[00:12:50] *** Joins: jsonnull (Thunderbir@E86DD23.582C899D.494A0F8B.IP)
[00:14:48] *** Quits: acrichto (acrichto@moz-B63D64BD.res.cmu.edu) (Quit: leaving)
[00:14:54] *** Joins: acrichto (acrichto@moz-B63D64BD.res.cmu.edu)
[00:14:54] *** ChanServ sets mode: +o acrichto
[00:27:26] *** Quits: acrichto (acrichto@moz-B63D64BD.res.cmu.edu) (Quit: leaving)
[00:27:32] *** Joins: acrichto (acrichto@moz-B63D64BD.res.cmu.edu)
[00:27:32] *** ChanServ sets mode: +o acrichto
[00:31:09] *** Joins: new_one (new_one@B48A3C4C.4C8100B8.B3C0173E.IP)
[00:51:43] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[00:51:43] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/tZLtsA
[00:51:43] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[00:55:12] <dbaupp> given a NodeId of an ast::Ty, how do I check if it's a trait?
[00:56:44] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[00:56:44] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/PqRx2g
[00:56:44] <ghrust> 13rust/06auto 144be3262 15Huon Wilson: syntax::ext: replace span_fatal with span_err in many places....
[00:56:44] <ghrust> 13rust/06auto 147c33df0 15bors: auto merge of #11644 : huonw/rust/less-fatality, r=cmr...
[00:56:45] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[00:56:46] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[00:56:46] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/JOD3Aw
[00:56:47] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[01:13:33] <acrichto> cmr: pong
[01:14:30] *** Joins: jdm (jdm@moz-AC9499B2.cable.teksavvy.com)
[01:26:03] <cmr> acrichto: can I somehow get a syscall trace + backtrace of http://buildbot.rust-lang.org/builders/try-bsd/builds/677/steps/compile/logs/stdio, and a backtrace from http://buildbot.rust-lang.org/builders/try-win/builds/827/steps/compile/logs/stdio ?
[01:27:33] <cmr> (it's the guard_pages branch)
[01:32:07] *** Quits: gwty (gwtypc@E2C142AC.FA920D05.137C914F.IP) (Ping timeout)
[01:37:06] <dbaupp> cmr, acrichto: https://github.com/mozilla/rust/issues/11678
[01:41:36] <dbaupp> \o/ looks like the ast_map change helped
[01:44:14] *** kimundi is now known as zz_kimundi
[01:48:58] <Luqman> dbaupp: if you're still looking, there's ty::node_id_to_type
[01:50:06] <dbaupp> Luqman: thanks (I ended up just going via the ast_map, since I think that's all I need.)
[01:58:53] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[02:16:42] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[02:16:42] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/PqRx2g
[02:16:42] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[02:21:44] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[02:21:44] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/AJ9phw
[02:21:44] <ghrust> 13rust/06auto 141a8a901 15musitdev: Squashed commit of the following:...
[02:21:44] <ghrust> 13rust/06auto 14339946c 15musitdev: extra::json: add documentation and examples
[02:21:44] <ghrust> 13rust/06auto 14aeb5416 15musitdev: extra::json: add documentation and examples
[02:21:46] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[02:47:24] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[02:52:17] *** Joins: summerlight_ (summerligh@327FC32B.2C956A45.501EFF44.IP)
[02:53:23] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[02:54:17] *** Quits: summerlight_ (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[03:07:42] *** Joins: lpy (lpy@7FD2B9AB.3720F6C5.952560D4.IP)
[03:08:52] *** Quits: zz_kimundi (kimundi@moz-F79A61BC.dip0.t-ipconnect.de) (Ping timeout)
[03:09:32] <cmr> So I'm watching The Return of the King for the first time.
[03:09:37] <cmr> Battle of Minas Tirith
[03:09:40] <cmr> OMG so epic
[03:11:40] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Client exited)
[03:13:05] *** Joins: zz_kimundi (kimundi@moz-AEB7B25C.dip0.t-ipconnect.de)
[03:13:07] *** zz_kimundi is now known as kimundi
[03:13:59] <jdm> huh
[03:14:05] <jdm> how did you accomplish avoiding it for so long?
[03:14:18] <cmr> dunno.
[03:14:24] <cmr> I've read the books before
[03:14:36] <cmr> 19 years without seeing these is pretty bad.
[03:16:47] <jdm> I hope you have learned your lesson
[03:41:19] *** Quits: canhtak (canhtak@moz-6C22A50C.wl.t.ulaval.ca) (Quit: canhtak)
[03:41:44] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[03:41:44] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/AJ9phw
[03:41:44] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[03:46:37] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[03:46:37] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/MBO3ew
[03:46:37] <ghrust> 13rust/06auto 14aaf8ba7 15Flavio Percoco: Added benchmark for pow and pow_with_uint
[03:46:37] <ghrust> 13rust/06auto 143830a3b 15Flavio Percoco: Replace old pow_with_uint with the new pow func...
[03:46:38] <ghrust> 13rust/06auto 14764f2cb 15bors: auto merge of #11649 : FlaPer87/rust/pow, r=cmr...
[03:46:40] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[03:47:14] *** Joins: canhtak (canhtak@moz-6C22A50C.wl.t.ulaval.ca)
[03:58:43] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[04:07:12] *** Joins: lkuper (lkuper@6FA5FA9.52E2F3EF.FBBA4BA2.IP)
[04:09:14] <sfackler> gah, why did pcwalton have to remove @-patterns before @ :(
[04:14:56] <cmr> ... is it no longer possible to match out of a @-ptr?
[04:15:34] <sfackler> nope:  error: obsolete syntax: managed pointer pattern
[04:15:38] *** Joins: summerlight_ (summerligh@327FC32B.2C956A45.501EFF44.IP)
[04:15:52] <cmr> wll I figured that
[04:16:16] <cmr> *well
[04:16:29] <cmr> but I figured... there would have been some wa to accomplish it in the meantime
[04:17:16] <sfackler> I don't think so? it causes some duplicated logic here https://github.com/sfackler/rust-phf/blob/master/phf_mac.rs#L59-L67
[04:17:37] <dbaupp> sfackler: macros!
[04:17:55] <dbaupp> sfackler: (could I strongly encourage you to avoid using span_fatal, please?)
[04:18:09] <sfackler> since I can't just have "ExprLit(@Spanned { node: LitStr(s, _), .. })"
[04:18:17] <sfackler> dbaupp: updating it right now actually :)
[04:18:31] <dbaupp> awesome
[04:19:33] <sfackler> compiling a build with MacResult::dummy_expr as we speak
[04:19:52] <sfackler> I should probably write up some compile-fail architecture
[04:20:46] <sfackler> hmm, actually, it'd be kind of nice to release compiletest along with rustc for this kind of thing
[04:55:38] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[05:02:14] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[05:02:14] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/MBO3ew
[05:02:14] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[05:03:31] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[05:03:31] *** ChanServ sets mode: +ao dherman dherman
[05:05:02] <sfackler> welp
[05:05:07] <sfackler> has anyone seen this?
[05:05:10] <sfackler> task 'rustc' failed at 'index out of bounds: the len is 0 but the index is 0', /home/sfackler/rust/rust/src/librustc/middle/trans/common.rs:968
[05:05:28] <sfackler> must have popped up in the last ~24 hours
[05:06:36] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[05:06:36] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/xq74sg
[05:06:36] <ghrust> 13rust/06auto 1499cde84 15Dmitry Vasiliev: Ignore all newline characters in Base64 decoder...
[05:06:36] <ghrust> 13rust/06auto 1424f8b46 15bors: auto merge of #11652 : hdima/rust/base64-padding-newlines, r=alexcrichton...
[05:06:36] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[05:06:37] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[05:06:37] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/o2wbAg
[05:06:37] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[05:09:36] *** Quits: Kxepal (Miranda@moz-33C7CDB3.pppoe.mtu-net.ru) (Ping timeout)
[05:12:53] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[05:12:59] *** Joins: Kxepal (Miranda@moz-77F2B717.pppoe.mtu-net.ru)
[05:17:56] <sfackler> dbaupp: do you have a bunch of recent rustc's lying around?
[05:20:46] <sfackler> dbaupp: hrm, actually, your less-fatality thing may have broken stuff in a way I don't understand
[05:23:18] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[05:25:30] <acrichto> cmr: ping
[05:26:39] <sfackler> acrichto: does it make any sense to you why https://github.com/mozilla/rust/pull/11644 would be causing this ICE?
[05:26:49] <sfackler> task 'rustc' failed at 'index out of bounds: the len is 0 but the index is 0', /home/sfackler/rust/rust/src/librustc/middle/trans/common.rs:968
[05:26:58] <sfackler> the relavant log line is
[05:26:59] *** Quits: new_one (new_one@B48A3C4C.4C8100B8.B3C0173E.IP) (Client exited)
[05:27:03] <sfackler> find_vtable(n_param=param_numbered(1u), n_bound=0, ps=param_substs {tys:[&'static mut [std::option::Option<(&'static str,int)>], (&'static str,&'a int)], vtables:Some([[], []])})
[05:27:12] <acrichto> what code is it compiling?
[05:27:26] <sfackler> https://github.com/sfackler/rust-phf/blob/master/test.rs
[05:27:31] <sfackler> I haven't tried minimizing it yet
[05:27:49] <sfackler> I have a rustc at f7cc8a6 that compiles it fine
[05:28:00] <cmr> acrichto: pong
[05:28:01] <sfackler> and a build at 0e6455e that hits that ICE
[05:28:27] <sfackler> the only merges are the less-fatality PR and the JSON docs one
[05:28:33] <acrichto> sfackler: this is using new procedural macros? there may be some roughness around the edges?
[05:28:50] <acrichto> cmr: about those backtraces, I don't think I have logins to the linux bots (bsd) and I have no idea how to get a backtrace on windows
[05:28:51] <dbaupp> sfackler: I'd be very surprised if less-fatality broke things :(
[05:29:00] <dbaupp> sfackler: cmr has a pile of rustc's, fwiw.
[05:29:08] <acrichto> cmr: I'd recommend making a vm locally if you can
[05:29:49] <cmr> acrichto: ok.
[05:30:25] <sfackler> cmr: any chance you can try running "make check" for github.com/sfackler/rust-phf for me on commits f7cc8a625b4f405dfed8cd79dc9e59983eff3c9e and 7c33df0dbb22ce528e62b8b118880a189307963a
[05:30:38] <cmr> sfackler: are those bors merges?
[05:30:41] <cmr> I only build merge commits.
[05:30:44] <sfackler> they are
[05:30:50] <cmr> k
[05:31:18] <sfackler> PRs 11644 and 11643
[05:32:36] <cmr> sfackler: they both pass
[05:32:44] <sfackler> hmm
[05:32:56] <sfackler> try 0e6455e2b8ee707c0683c67ba224b7682aff4e85 ?
[05:33:19] <sfackler> I may just have a screwed up build
[05:35:42] <cmr> sfackler: passes.
[05:36:02] <bjz> SiegeLord: beep
[05:36:08] <SiegeLord> Yo
[05:36:12] <cmr> (with the vec iterator rename)
[05:36:12] <sfackler> ok, I guess it miscompiled or something
[05:36:14] <sfackler> thanks
[05:37:36] <bjz> SiegeLord: a set of bit-sequences of size n and its associated bitwise operations form a Boolean Algebra, right?
[05:37:48] <sfackler> cmr: did it change from Items or something?
[05:37:57] <cmr> sfackler: it changed *to* items from VecIterator :p
[05:38:37] <sfackler> you may need to re-pull? https://github.com/sfackler/rust-phf/blob/master/phf.rs#L112
[05:38:43] <SiegeLord> bjz, ...maybe
[05:38:54] <bjz> SiegeLord: eg. uints form a boolean algebra under the bitwise operations and the identities 000...0 and 1111...1
[05:39:26] <bjz> SiegeLord: therefore it might make sense to have a Boolean trait which includes those identities
[05:39:41] <bjz> SiegeLord: that would also cover `bool`
[05:39:43] <dbaupp> bjz: boolean operations form a ring
[05:39:53] <dbaupp> ^ is +, and & is *
[05:40:13] <dbaupp> (it's just (Z/2)^n, fwiw.)
[05:41:37] <bjz> dbaupp: well, to complicate things, other notations use /\ and \/. That would remove the conflict with + and *. We seem to use & and |
[05:41:54] <cmr> lol
[05:41:58] <dbaupp> bjz: it has to be xor
[05:42:08] <cmr> /\ and \/ perfect: clarity.
[05:42:23] <dbaupp> (as in, xor is the "addition" of that ring.)
[05:42:29] <sfackler> cmr: could you try again after re-pulling rust-phf? I think you have an old copy
[05:42:49] <bjz> dbaupp: ohhh, I see
[05:43:04] <bjz> dbaupp: sorry, thanks
[05:43:08] <cmr> sfackler: I literaly just cloned it after you linked.
[05:43:23] <cmr> Current branch master is up to date.
[05:43:34] * bjz needs folks to make sure he is on an even path
[05:43:41] <sfackler> hmm, how did you end up with VecIterator in there then?
[05:43:50] <cmr> no, you had Items
[05:43:57] <cmr> I had to change it to build it with 0e6455e2b8ee707c0683c67ba224b7682aff4e85
[05:44:11] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: Leaving)
[05:44:20] <dbaupp> bjz: (I was just giving you a fun mathematical fact for the day :P )
[05:44:25] <bjz> dbaupp: this is what the Data.Algebra lib (Haskell) does: http://hackage.haskell.org/package/cond-0.4.0.1/docs/Data-Algebra-Boolean.html
[05:45:02] <bjz> dbaupp: SiegeLord was concerned about constraining Zero and One under Add and One
[05:45:04] <ChrisMorgan> bjz: why would one use /\ and \/ when one could use âˆ§ and âˆ¨?
[05:45:13] <bjz> ChrisMorgan: I know right!
[05:45:38] <bjz> ChrisMorgan: I mean, everyone has âˆ§ and âˆ¨ keys don't they...?
[05:45:48] * bjz wonders if he is the only one
[05:46:43] <sfackler> cmr: now I'm really confused. Isn't 0e6455 the second most recent commit into rust/master?
[05:47:14] <cmr> https://gist.github.com/cmr/dc3adfc31936902508fe ?
[05:47:48] <sfackler> O_o
[05:48:41] <sfackler> my tree may be in a bad place?
[05:48:56] *** Quits: lkuper (lkuper@6FA5FA9.52E2F3EF.FBBA4BA2.IP) (Ping timeout)
[05:49:03] * sfackler is very confused
[05:50:29] <cmr> hm
[05:50:35] <cmr> I wonder if I have 0e6455e2b8ee707c0683c67ba224b7682aff4e85 built.
[05:50:42] <cmr> nope
[05:50:44] <cmr> sorry!
[05:51:16] <sfackler> cool! I thought I was going crazy :P
[05:51:33] <sfackler> now I just have a mysteriously broken build to deal with
[05:51:38] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[05:51:38] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1424f8b46 to 14764f2cb: 02http://git.io/N3iJvQ
[05:51:38] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[05:58:45] *** Quits: summerlight_ (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[06:03:20] <cmr> WAT
[06:03:22] <cmr> http://rasputin.com/
[06:03:30] <cmr> Someone please tell me whe google has registered rasputin.com
[06:04:28] <sfackler> isn't that the default app-engine 404 page?
[06:04:32] <cmr> oh maybe
[06:04:43] * cmr calms down his watsauce.
[06:09:58] <dbaupp> hm, is it known that enum variants are always public?
[06:11:43] <acrichto> it's even intended!
[06:12:18] <dbaupp> even for a private enum?
[06:12:39] <acrichto> hm, no
[06:12:45] <acrichto> I think that they should inherit
[06:12:55] <acrichto> sounds like the same problem as struct fields
[06:12:58] <dbaupp> https://github.com/mozilla/rust/issues/11680
[06:13:22] <acrichto> dbaupp: is that cross-crate or also inter-crate?
[06:14:32] <dbaupp> that example is just cross crate
[06:14:47] <dbaupp> but inter-crate it seems to be fine
[06:14:53] <dbaupp> well, fine-ish
[06:14:58] <acrichto> ugh probably just some metadata thing
[06:15:03] <acrichto> forgot to emit the visibility or something like that
[06:15:20] <Yurume> awww, I still don't get how rustpkg works. :( is the in-repo path still not supported?
[06:15:30] <dbaupp> acrichto: it ignores `pub` on variants too
[06:15:33] <dbaupp> even intra-crate
[06:15:43] <dbaupp> but pub-use works fine
[06:15:48] <acrichto> what
[06:16:01] <acrichto> could you comment to that effect?
[06:16:04] <dbaupp> rusti: mod foo { enum Private { pub Public } } foo::Public
[06:16:06] -rusti- pastebinned 7 lines of output: http://ix.io/a0m
[06:16:17] <acrichto> it definitely encodes the visibility
[06:16:22] <acrichto> oh hm
[06:16:27] <acrichto> I'm not sure if that's intended to work
[06:16:29] <acrichto> I suppose it should be
[06:16:30] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[06:17:37] <dbaupp> commented
[06:17:48] <acrichto> cool thanks
[06:18:00] *** Joins: summerlight_ (summerligh@327FC32B.2C956A45.501EFF44.IP)
[06:18:38] *** Joins: brson (brson@moz-5386576F.sd.sd.cox.net)
[06:18:38] *** ChanServ sets mode: +qo brson brson
[06:23:58] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[06:25:41] *** Quits: jxs (joaoxsouls@1FF12F4F.CDF09DE2.D6573861.IP) (Ping timeout)
[06:30:00] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[06:31:44] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[06:31:44] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/Q9qCLg
[06:31:44] <ghrust> 13rust/06auto 1499cde84 15Dmitry Vasiliev: Ignore all newline characters in Base64 decoder...
[06:31:44] <ghrust> 13rust/06auto 14a0ecb15 15bors: auto merge of #11652 : hdima/rust/base64-padding-newlines, r=alexcrichton...
[06:31:44] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[06:31:45] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[06:31:45] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14eb21f82 to 14764f2cb: 02http://git.io/N3iJvQ
[06:31:45] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[06:32:14] *** Joins: jxs (joaoxsouls@1FF12F4F.CDF09DE2.D6573861.IP)
[06:34:14] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[06:46:18] *** Quits: jsonnull (Thunderbir@E86DD23.582C899D.494A0F8B.IP) (Ping timeout)
[06:49:37] *** Joins: jsonnull (Thunderbir@E86DD23.582C899D.494A0F8B.IP)
[07:01:47] *** Quits: yuriks (yuriks@8E8458DA.1755AC6C.F6EE4B40.IP) (Ping timeout)
[07:16:23] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[07:24:35] *** Quits: sigma (sigma@moz-1C81041B.range86-184.btcentralplus.com) (Client exited)
[07:26:49] *** Joins: sigma (sigma@moz-1C81041B.range86-184.btcentralplus.com)
[07:27:04] *** Quits: sigma (sigma@moz-1C81041B.range86-184.btcentralplus.com) (Client exited)
[07:28:34] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[07:40:44] *** Joins: eddyb (eddy@EDE07015.D51DAF03.FB866788.IP)
[07:46:33] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[07:46:33] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/Q9qCLg
[07:46:33] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[07:47:21] <eddyb> cmr: did you redo those commits? the graph looks different
[07:47:56] <cmr> eddyb: yes.
[07:48:05] <cmr> nothing really changed
[07:48:16] <eddyb> that's weird
[07:48:36] <cmr> you can give me a larger range of commits to retry?
[07:48:43] *** Quits: jdm (jdm@moz-AC9499B2.cable.teksavvy.com) (Quit: Lost terminal)
[07:49:56] <eddyb> cmr: it could be the other thing I've mentioned in the past and forgotten about: (de)inlining avalanche (started by changing the size of a few functions), though... let me find something that doesn't touch code at all
[07:50:33] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[07:51:21] <eddyb> cmr: these have a peak in the middle, only doc changes AFAICT http://huonw.github.io/isrustfastyet/mem/#77eedda,9dbbfb8,d150f6b
[07:51:31] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[07:51:33] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Client exited)
[07:51:34] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[07:51:34] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/vojTNA
[07:51:34] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[07:51:44] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[07:54:06] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Client exited)
[07:54:36] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[07:56:18] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Ping timeout)
[07:56:53] *** Quits: brson (brson@moz-5386576F.sd.sd.cox.net) (Quit: leaving)
[08:18:38] *** flaper87|afk is now known as flaper87
[08:20:53] *** Quits: summerlight_ (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[08:33:04] *** Joins: vadimcn (chatzilla@FB06B64.76F9E272.DA40C4B3.IP)
[08:36:46] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Client exited)
[08:38:16] *** Joins: andrew-d_w (andrew-d_w@4CCE6E0C.339B431B.1E537B93.IP)
[08:38:32] *** Quits: andrew-d_w (andrew-d_w@4CCE6E0C.339B431B.1E537B93.IP) (Input/output error)
[08:38:47] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[08:38:55] *** Joins: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net)
[08:49:44] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[08:51:27] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Ping timeout)
[08:54:38] <cmr> I keep using `let` and semicolons in my python.
[08:55:01] <eddyb> cmr: just write ES6 and it will work :P
[08:55:46] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[08:55:56] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[09:06:28] *** Quits: canhtak (canhtak@moz-6C22A50C.wl.t.ulaval.ca) (Quit: canhtak)
[09:06:48] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[09:06:48] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/AFT-1w
[09:06:48] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[09:09:21] *** Quits: Sharp (Sharp@moz-EEC85237.hsd1.ca.comcast.net) (Quit: Sharp)
[09:10:57] *** Quits: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net) (Input/output error)
[09:11:38] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[09:11:38] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/OsYkNw
[09:11:38] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[09:11:56] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[09:11:56] <ghrust> 01[13rust01] 15thestinger 04force-pushed 06try from 1458d4d5c to 14b9af14e: 02http://git.io/k471pw
[09:11:56] <ghrust> 13rust/06try 14934264c 15Daniel Micay: add new vector representation as a library
[09:11:56] <ghrust> 13rust/06try 14b9af14e 15Daniel Micay: hashmap: port to Vec<T>
[09:11:56] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[09:14:59] <eddyb> strcat: oooh. did you try deprecating the ~[T] growable methods and counting the warnings in libsyntax and librustc?
[09:15:05] <strcat> no
[09:15:14] <strcat> not going to
[09:15:19] <strcat> going to remove ~[T]
[09:15:30] <strcat> no point of having two owned vector types
[09:15:35] <strcat> it's needlessly complex
[09:15:40] <eddyb> strcat: the point was to asses the damage before killing it
[09:15:51] <strcat> don't care, two owned vector types is too complex
[09:16:17] * dbaupp agrees with strcat
[09:16:24] <strcat> going to have one owned vector type and it's going to be a library one
[09:16:34] <strcat> if DST needs to add complexity, then that's a con of DST and can be dealt with then
[09:16:53] <eddyb> maybe disallow ~[T] with a lint or something?
[09:16:56] <strcat> just removing it
[09:17:00] * strcat shrugs
[09:17:03] <eddyb> strcat: under DST
[09:17:20] <strcat> with the very big assumption that DST happens, and that it happens for vectors
[09:17:27] <strcat> not going to let it hold back vectors anymore
[09:17:28] * strcat shrugs
[09:17:56] <strcat> I've had this ready to land for 5 months
[09:18:00] <strcat> no decision about DST is made yet
[09:18:05] <strcat> I seriously doubt it will happen for vectors
[09:18:26] <strcat> anyway, I think auto-slicing is bad
[09:18:43] <strcat> foo(xs) where xs is ~T or ~[T]/Vec<T>
[09:18:49] <strcat> should have value semantics
[09:19:24] <eddyb> I thought we agreed that's too much annotation burden
[09:19:36] <strcat> what annotation burden is there?
[09:19:37] <eddyb> I understand things like &mut *
[09:19:40] <eddyb> strcat: .as_slice()
[09:19:56] <strcat> eddyb: the methods will be available on both
[09:20:18] <strcat> eddyb: if we have auto-borrow for ~T, then we need it for T
[09:20:25] <strcat> doesn't make sense to have it for one and not the other
[09:20:28] <strcat> it has proven to lead to confusion
[09:20:45] <eddyb> auto-borrow is Deref, isn't it?
[09:20:47] <strcat> causes people to replace foo(x) with 5 with foo(x) using ~5
[09:20:52] <eddyb> well, no, nvm
[09:20:52] <strcat> eddyb: no, not talking about that
[09:20:57] <strcat> talking about auto-borrow for parameters
[09:21:05] <strcat> foo(x) atm will coerce ~T to &mut T or &T
[09:21:12] <strcat> or ~[T] to &mut [T] or &[T]
[09:21:14] <strcat> but...
[09:21:16] <strcat> it won't do it for T
[09:21:18] <strcat> why?
[09:21:21] <strcat> doesn't make any sense
[09:21:24] <strcat> ~T has value semantics too
[09:21:42] <eddyb> I also thought we were going to discuss allowing it for T
[09:21:43] <strcat> so either rust needs to decide that auto-borrow is okay (like C++), or stop doing it there
[09:21:47] <eddyb> and disallowing implicit &mut
[09:21:48] <strcat> eddyb: don't think so
[09:21:57] <strcat> eddyb: non-Freeze types.
[09:22:25] *** Joins: andrew-d_w (andrew-d_w@4CCE6E0C.339B431B.1E537B93.IP)
[09:22:37] *** Quits: andrew-d_w (andrew-d_w@4CCE6E0C.339B431B.1E537B93.IP) (Input/output error)
[09:23:01] *** Joins: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net)
[09:23:31] <strcat> anyway
[09:23:40] <strcat> theoretical stuff is not going to keep us on the old vector anymore
[09:26:47] <eddyb> sure, I just... bleah, I don't know
[09:27:47] <strcat> if DST has to add complexity by introducing a redundant ~[T] type, that's a DST problem, not a vector one
[09:27:49] * strcat shrugs
[09:27:59] <strcat> imo, this stuff has proven itself to be overly complex/confusing
[09:27:59] <eddyb> strcat: in that ML thread, I thought what you said was the general consensus
[09:28:18] <strcat> eddyb: if it turns out to be the consensus it can be added
[09:28:23] <strcat> it's not relevant to the vector representation
[09:28:25] <strcat> it can be done later
[09:28:29] <eddyb> strcat: I mean borrowing for everything
[09:28:56] <strcat> 04:29:17 strcat | eddyb: if it turns out to be the consensus it can be added
[09:29:11] <eddyb> about ~[T], I'm worried for one simple reason
[09:29:14] <strcat> auto-slice trait doesn't exist, deref trait doesn't exist - if and when it is decided that immutable auto-borrow for parameters is okay, it can be added for them
[09:29:19] <strcat> it's *irrelevant* to replacing ~[T]
[09:29:24] <strcat> it is a separate discussion
[09:29:44] <eddyb> I'm afraid we might want to replace Vec<T> with ~[T] in immutable data structures and whatnot
[09:29:49] <strcat> why?
[09:29:56] <strcat> ~[T] is no more immutable than Vec<T>
[09:30:50] <strcat> when DST is added, extra complexity required for DST can be introduced if it's decided that DST is worth adding that complexity
[09:30:53] <cmr> strcat: yay please kill ~[T] :)
[09:30:54] <strcat> until then, sticking with simple
[09:31:03] <eddyb> strcat: no, I understand
[09:31:08] * strcat shrugs
[09:31:16] <strcat> anyway
[09:31:19] <strcat> going to throw out ~[T]
[09:31:22] <strcat> replace it across the codebase
[09:31:36] <strcat> replace the ring buffer with the better one and replace the priority queue (both belong in libstd imo)
[09:33:01] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[09:33:01] <ghrust> 01[13rust01] 15thestinger 04force-pushed 06try from 14b9af14e to 14f759fe3: 02http://git.io/k471pw
[09:33:02] <ghrust> 13rust/06try 141f40df3 15Daniel Micay: add new vector representation as a library
[09:33:02] <ghrust> 13rust/06try 14f759fe3 15Daniel Micay: hashmap: port to Vec<T>
[09:33:02] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[09:36:13] <eddyb> strcat: ~[T] is an optimization/semantically-explicitating-frozen-length. it might even help LLVM optimize some things, though you'd use &(mut)[T] anyway for most of those. I don't know
[09:36:22] <strcat> it won't help LLVM
[09:36:56] <strcat> eddyb: you can still resize ~[T]...
[09:37:05] <eddyb> right, sorry
[09:37:06] <strcat> eddyb: just not efficiently
[09:37:22] <strcat> Vec<T> can't do more or less than ~[T] with (ptr, len)
[09:37:30] <strcat> it's going to be overly complex imo
[09:37:33] <strcat> if we do that
[09:37:38] <eddyb> I understand its complexity, but... I like being able to add/strip capacity. disable it by default, there's a certain appeal to that
[09:37:50] <eddyb> err, I missed something in that phrase
[09:37:51] <strcat> you can't 'strip' the capacity because the allocator really knows anyway...
[09:38:20] <eddyb> strcat: Vec<T, A: AllocWithCapacity>
[09:38:29] <strcat> not talking about that
[09:38:34] <strcat> I'm saying if you have ~[T] with (ptr, len)
[09:38:38] <strcat> the allocator still knows the capacity
[09:38:39] <eddyb> nono
[09:38:51] <strcat> you can still resize ~[T] without a capacity field
[09:39:00] <strcat> the capacity is *only* there as an optimization
[09:39:01] <eddyb> strcat: represent Vec<T> as ptr, len, alloc_with_capacity
[09:39:15] <strcat> eddyb: looking up the capacity in the allocator is not usually going to be cheap
[09:39:21] <eddyb> *usually*
[09:39:23] <strcat> storing the capacity inline is an optimization
[09:39:40] <strcat> eddyb: tiny micro-optimizations like this don't belong in the type system
[09:39:45] <strcat> there is no good reason to have 2 vector types
[09:39:50] <strcat> one with an inline capacity and one without
[09:39:55] <strcat> it *does not belong* in the stdlib/language
[09:40:04] <eddyb> hmm, mkay
[09:40:26] <strcat> libstd is an overcomplicated mess
[09:40:33] <strcat> simplifying this is one small step to fixing it
[09:40:44] <eddyb> strcat: what if libstd uses it internally (is it useful anywhere?) but it's not alloawed by default for users
[09:40:45] * strcat will keep yelling about M:N threading being useless too ;p
[09:41:01] <strcat> eddyb: what is useful about it?
[09:41:12] <strcat> ~[T] isn't more restricted/immutable than Vec<T>...
[09:41:18] <strcat> both inherit mutability, both can be resized
[09:41:34] <eddyb> it's a bit smaller
[09:42:04] <strcat> which is an insignificant micro-optimization
[09:42:16] <strcat> I doubt we have one place where it would really help
[09:42:26] <cmr> seriously if you have enough vectors that that matters you should just be using a different data structure.
[09:43:19] <strcat> eddyb: if you push for vector DST you're going to be upset when people who care about simplicity more than perf make *all* slices 3 words... ;p
[09:43:28] <strcat> which has been proposed already
[09:43:40] * strcat shrugs
[09:43:45] <eddyb> strcat: that doesn't make sense under DST
[09:43:57] <strcat> eddyb: nmatsakis proposed it
[09:44:07] <eddyb> strcat: it's not in DST5
[09:44:13] <strcat> eddyb: https://github.com/mozilla/rust/issues/10295
[09:45:30] <eddyb> strcat: that's crazy talk now
[09:45:36] <cmr> not really.
[09:45:42] <eddyb> 4 words for trait objects
[09:46:03] <strcat> eddyb: *shrug*
[09:46:07] <eddyb> though it could work, were you to mark such things as ~Trait:unsized
[09:46:30] <strcat> eddyb: look, if DST is added down the road and adding ~[T] as (ptr, len) turns out to make sense, then sure
[09:46:44] <strcat> we can start using ~[T] a lot and using Vec<T> as a painful 'vector builder'
[09:46:51] <strcat> it's going to make people struggle with the language more
[09:47:00] <strcat> but if there is *some thing* we actually get from doing this...
[09:47:08] <eddyb> strcat: thing is, any pointer to [T] will be (ptr, len) under DST5
[09:47:09] <strcat> beyond the micro-optimization of removing a word
[09:47:17] <strcat> eddyb: if [T] is a DST
[09:47:21] <strcat> big if, imo
[09:47:25] <eddyb> so you will have to lint against ~[T]
[09:47:50] <strcat> making the language more complex is not a good idea
[09:48:33] <strcat> needs to be smaller and simpler
[09:48:33] <eddyb> strcat: how so? I'm curious just because I want to understand the situation
[09:48:58] <strcat> because if you have both ~[T] and Vec<T> and start forcing people to convert to and from Vec<T> to change the size, you've made everything more of a PITA
[09:49:14] <strcat> realism triumphs over making everything more theoretically powerful
[09:49:37] <eddyb> strcat: I do agree that we might disable ~[T] by default, if it works implicitly
[09:49:45] <strcat> rust needs to cut back on the attempt to do everything at the expense of absolutely terrible APIs
[09:50:00] <strcat> eddyb: I've yet to see why DST for [T] is actually useful
[09:50:07] <strcat> to me, it seems like this adds yet another thing to explain
[09:50:11] <strcat> and doesn't make the language easier to learn
[09:50:13] <strcat> why would we do it?
[09:50:31] <strcat> what benefit has it been shown to have?
[09:50:44] <strcat> you don't need [T] as a DST to write a gc/rc slice
[09:50:46] <eddyb> that's an interesting question
[09:50:55] <strcat> you need Trait as a DST to have a gc/rc trait
[09:51:03] <strcat> imo, [T] as DST isn't really a useful thing to do
[09:51:11] <strcat> just write RcSlice/GcSlice
[09:51:13] <strcat> and call it a day
[09:51:24] <eddyb> it allows conversion from [T, ..N]
[09:51:45] <strcat> so ~[T, ..n] becomes 2 words?
[09:51:54] <eddyb> strcat: 1
[09:52:07] <strcat> eddyb: so then it's yet another coercion that only works on the outer layer
[09:52:16] <strcat> it does not add expressiveness
[09:52:49] <strcat> you can already convert ~[T, ..n] to Vec<T> without a copy
[09:53:01] <strcat> the real issue is the lack of generics parameterized over all fixed-size vectors
[09:53:06] <strcat> lets not hardwire stuff to work around that
[09:53:28] * strcat shrugs
[09:53:29] <eddyb> strcat: Rc<RefCell<[T, ..N]>> would coerce to Rc<RefCell<[T]>>
[09:54:09] <strcat> eddyb: which is useful why?
[09:54:22] <strcat> eddyb: this is a common thing in rust code? why does it deserve to be a weird special case in the language?
[09:54:29] <strcat> we can build in all the library types
[09:54:33] <strcat> and add all kinds of weird special cases
[09:54:42] <eddyb> but library types can't be generic enough :/
[09:54:49] <strcat> we can make it so that you can map ~[T] -> ~[U] in-place without a reallocation
[09:54:52] <strcat> when T and U are the same size
[09:54:59] <strcat> I can think of 20000 special cases to add
[09:55:01] <strcat> but lets please not
[09:55:03] <strcat> rust is too complex
[09:55:19] <strcat> adding special cases not shown to have occured a single time in real code is ridiculous
[09:55:41] <strcat> stop hardwiring special cases into the language
[09:55:48] <strcat> start giving libraries more power if you want
[09:55:54] <strcat> but really, enough of special-casing things above libraries
[09:55:55] <strcat> we're not Go
[09:56:06] <eddyb> strcat: so default type params are ok with you?
[09:56:09] <strcat> vectors don't deserve to be enshrined above other containers
[09:56:11] <strcat> eddyb: yes
[09:56:11] <eddyb> (giving libraries more power)
[09:56:22] <strcat> I am okay with adding features for libraries to use most of the time
[09:56:30] <strcat> I am not okay with adding more language magic most of the time
[09:56:49] <strcat> imo rust suffers a lot from that Go syndrome of the language doing stuff *you* can't
[09:56:56] <strcat> the language can copy fixed-size vectors
[09:57:00] <strcat> *you* can't implement Clone on them
[09:57:01] <eddyb> okay then...
[09:57:13] <strcat> the language has a concept of DST
[09:57:18] <strcat> lets say
[09:57:28] <strcat> can you make another sequence type that's a DST? no, not really
[09:58:24] <strcat> HashMap, ring buffer, priority queue, etc. could all be a DST with the same weird split between one with capacity and one without
[09:58:31] <strcat> it doesn't make sense to me
[09:59:05] <strcat> DST for traits makes sense because traits are a fundamental language feature
[09:59:09] <strcat> not a container you can reimplement
[09:59:20] <eddyb> strcat: mkay, so... what do you do with &[T] if [T] is not an unsized type?
[09:59:59] <strcat> eddyb: why should &[T] be privileged over equivalents like random access ranges?
[10:00:19] <strcat> again, this is magic being added to the language when there are library types with the same situation
[10:00:22] <strcat> I'm against that
[10:00:38] <strcat> it's bad that we have to define stuff like sort on slices
[10:00:44] <strcat> and it doesn't work on ring buffers
[10:00:50] <strcat> lets fix that, not dig a deeper hole
[10:01:08] <cmr> strcat += 1000
[10:01:19] <cmr> (error: type strcat does not implement Add)
[10:01:29] *** Quits: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP) (Ping timeout)
[10:01:33] <strcat> I want a simple language giving the power to implement very useful libraries
[10:01:40] <cmr> or whatever the awful error for += is ;p
[10:01:59] <strcat> and I really don't like the idea of working around issues in the language by hardwiring solutions for primitives
[10:02:08] <eddyb> strcat: mkay
[10:02:26] <eddyb> I wish we don't end up with MutSlice<T> in place of &mut [T]
[10:03:04] *** Joins: rca (rcatolino@moz-10E18C17.adsl.proxad.net)
[10:05:42] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[10:05:42] <ghrust> 01[13rust01] 15thestinger 04force-pushed 06try from 14f759fe3 to 1458e1f85: 02http://git.io/k471pw
[10:05:42] <ghrust> 13rust/06try 143f48d69 15Daniel Micay: add new vector representation as a library
[10:05:42] <ghrust> 13rust/06try 1458e1f85 15Daniel Micay: hashmap: port to Vec<T>
[10:05:43] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[10:06:05] <strcat> eddyb: need to be able to implement slices as a library though
[10:06:07] <strcat> if you want
[10:06:15] <strcat> for example vec::Items should be 2 words, not 3
[10:06:27] <strcat> iterators are essentially a reimplementation of slices for efficiency
[10:06:30] <eddyb> why is it 3 words?
[10:06:40] <strcat> eddyb: because you can't have a lifetime without a borrowed ptr or slice
[10:06:50] <strcat> it can't use & for the other ptrs
[10:06:52] <strcat> they are not always valid
[10:07:07] <eddyb> I mean.. what's it holding?
[10:07:20] <strcat> Option<&'a ()> set to None
[10:07:26] <eddyb> I would think self.slice = self.slice.slice_from(1) would work
[10:07:36] <strcat> eddyb: sure, it's inefficient
[10:07:48] <eddyb> o_O what's with the Option
[10:08:09] <strcat> to iterate with a slice, each iteration has to bump the ptr and decrease the len
[10:08:16] <strcat> rather than just bump the ptr
[10:08:23] <strcat> which is what optimizes well
[10:08:37] <strcat> eddyb: it needs a lifetime
[10:08:40] <strcat> eddyb: it has two raw pointers
[10:08:44] <strcat> they are not always valid ptrs
[10:08:47] <eddyb> can't it be just &[T]?
[10:08:54] <eddyb> or &'a [T], I should say
[10:08:54] <strcat> 05:09:08 strcat | to iterate with a slice, each iteration has to bump the ptr and decrease the len
[10:09:07] <eddyb> AH
[10:09:28] <eddyb> strcat: so we're missing an empty structure with a lifetime?
[10:09:31] <strcat> it has to be a very specific usage of 2 ptrs to optimize to the right thing
[10:09:36] <strcat> eddyb: yes I have an issue open about it
[10:09:55] <strcat> eddyb: we may move to 'marker types' instead of #[no_send], etc. I dunno
[10:10:20] <strcat> #[lang = "borrowed"] struct Borrowed<'a>;
[10:10:22] <eddyb> so C++ begin/end is better optimized?
[10:10:34] <strcat> eddyb: well the iterator optimizes out
[10:10:46] <strcat> but if you store an iterator somewhere, then it has an unnecessary padding word
[10:11:01] <strcat> it is as fast at iterating as C++ begin/end
[10:11:05] <strcat> using a slice wouldn't be
[10:11:43] <strcat> eddyb: anyway it's not very important
[10:12:02] <strcat> it's just simpler to have Borrowed<'a> instead of Option<&'a ()> set to None
[10:12:05] <strcat> makes a lot more sense
[10:12:13] <eddyb> so we need to use being/end *wrapped* in a safe protocol
[10:12:21] <strcat> eddyb: yes that's what it does
[10:13:07] <strcat> hm
[10:13:42] <strcat> eddyb: anyway we can make a macro or syntax ext for generic container literals
[10:13:47] <strcat> via a trait
[10:13:53] <strcat> to replace ~[1, 2, 3]
[10:14:33] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[10:15:10] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[10:26:36] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[10:26:36] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/NVTXHA
[10:26:36] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[10:27:31] *** Quits: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net) (Input/output error)
[10:31:44] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[10:31:44] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/tIv86Q
[10:31:44] <ghrust> 13rust/06auto 14a68172c 15Huon Wilson: rustc: remove the explicit count from the lang_item macro....
[10:31:45] <ghrust> 13rust/06auto 14e83e576 15bors: auto merge of #11657 : huonw/rust/less-lang-duplication, r=cmr...
[10:31:45] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[10:32:22] <eddyb> o_O
[10:33:13] <strcat> ?
[10:33:31] <eddyb> ah, just the total count
[10:38:06] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[10:39:49] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Ping timeout)
[10:41:52] <pnkfelix> so during some investigations over the weekend
[10:42:27] <pnkfelix> I found that the Writer::write implementation for MemWriter
[10:42:49] <pnkfelix> does not follow the common strategy of doubling the buffer size when the current buffer size is insufficient
[10:43:44] <eddyb> I want to get rid of MemWriter usage in format! btw
[10:43:55] <pnkfelix> and instead relies on vec::push_all's policy, which reallocs with the exact size needed for this partcular call
[10:43:56] <strcat> can't ~[u8] just implement Writer? I don't quite understand why it's separate
[10:44:24] <strcat> well, Vec<u8> :)
[10:44:38] <pnkfelix> How bad this can get seems strongly tied to the host's realloc implementation ...
[10:45:23] <strcat> pnkfelix: can we just purge it as a whole?
[10:45:42] <strcat> I have always hated string streams in C++ and StringIO in python
[10:46:24] <pnkfelix> strcat: purge what, exactly?  Get rid of dynamic buffer expansion during a write?
[10:46:32] <strcat> pnkfelix: get rid of MemWriter
[10:46:41] <strcat> impl Writer for ~[u8] { ... }
[10:46:41] <eddyb> WOO
[10:46:53] <eddyb> what is it used for?
[10:47:00] <pnkfelix> strcat: yes, but even then, you're still talking about dynamically expanding a buffer during a write, right?
[10:47:01] <eddyb> I want format! to use my 0 realloc thing
[10:47:18] <strcat> pnkfelix: well imo it should all expand to the next power of two unless you have something like _exact
[10:47:18] <eddyb> well, I guess repr still needs it until/if it can be upraded to a recursive model
[10:47:33] <strcat> pnkfelix: reserve should resize to the next power of two, and we should have reserve_exact
[10:47:34] <pnkfelix> strcat: right, so that's what I'm working my way towards
[10:47:38] <strcat> instead of reserve_at_least
[10:47:41] <pnkfelix> strcat: a discussion about the policy itself
[10:47:41] <strcat> which no one uses
[10:47:43] <strcat> pnkfelix: ah
[10:47:50] <eddyb> with proper allocator interfaces, the next power of two thing would be much better
[10:47:54] <pnkfelix> strcat: (I don't particularly care about how we break it down)
[10:48:00] <strcat> pnkfelix: well the nice way to avoid the discussion is replacing ~[T] with a sane type
[10:48:02] <strcat> ;p
[10:48:20] <eddyb> Slam/BlamAllocator has size classes, powers of two, but one word for the header
[10:48:46] <eddyb> (without that word you're looking at a costly free)
[10:50:16] <strcat> pnkfelix: I remember this discussion coming up several times before
[10:50:55] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[10:50:55] <ghrust> 01[13rust01] 15thestinger 04force-pushed 06try from 1458e1f85 to 145624101: 02http://git.io/k471pw
[10:50:55] <ghrust> 13rust/06try 145ade256 15Daniel Micay: add new vector representation as a library
[10:50:55] <ghrust> 13rust/06try 145624101 15Daniel Micay: hashmap: port to Vec<T>
[10:50:55] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[10:51:10] <eddyb> so, what's using MemWriter apart from format! and repr?
[10:51:20] <strcat> eddyb: just remove it
[10:51:22] <strcat> see what happens
[10:51:24] <strcat> :]
[10:51:26] <eddyb> hehe
[10:51:35] <eddyb> strcat: I'm working on something else, though
[10:51:44] <strcat> pnkfelix: git show 2690b513506dad53d0b86b20f8b73bc420dfb3a2
[10:52:03] <strcat> pnkfelix: so yeah, I remember now that we already came to the consensus that what those do is wrong
[10:52:12] <strcat> including that reserve is a bad name for the 'exact' one
[10:52:20] <strcat> just didn't get changed
[10:52:55] <strcat> can do better via integration with an allocator though
[10:53:07] <pnkfelix> strcat: sure
[10:54:28] <strcat> pnkfelix: https://github.com/thestinger/rust/blob/5ade256cedea6ed8e5029608481aee99f1999c1f/src/libstd/vec_ng.rs life is easy when the representation is simpler though...
[10:55:51] *** kimundi is now known as zz_kimundi
[10:55:59] <pnkfelix> strcat: yeah, i think the team (or least nmatsakis me and pcwalton) all agreed it would be good revise the ~[T] representation to a two word fat ptr.  (I know that is not what you were suggesting.)
[10:56:21] <eddyb> pnkfelix: under DST?
[10:56:30] <strcat> pnkfelix: well I think what needs to happen is removing ~[T]
[10:56:40] <strcat> then, if necessary, it can come back under DST
[10:56:56] <strcat> pnkfelix: it's just pointless to have the complication in the language/compiler imo
[10:57:10] <strcat> people get very confused about our current vectors
[10:57:23] <strcat> but not about hash tables
[10:57:29] <strcat> so imo we are doing something wrong
[11:00:03] <strcat> pnkfelix: tbh I think making [T] a DST is really unnecessary
[11:00:12] <strcat> pnkfelix: unlike traits, it's easy to implement RcSlice/GcSlice in a library
[11:00:16] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Client exited)
[11:00:38] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[11:00:40] <strcat> and I don't really like placing &[T]/&mut [T] above everything... because we lose out on flexibility
[11:00:50] <strcat> I should be able to use the stdlib sort algorithm on a ring buffer
[11:00:55] <strcat> it has O(1) random access
[11:01:01] <strcat> it's not contiguous though.
[11:01:02] <eddyb> we maybe need container traits
[11:01:12] <eddyb> (for that usecase)
[11:01:23] <strcat> eddyb: http://dlang.org/phobos/std_range.html http://dlang.org/phobos/std_algorithm.html
[11:01:39] <pnkfelix> strcat: by "placing &[T]/&mut [T]", you mean ... what, giving it privileged syntax in the language?
[11:02:10] <strcat> pnkfelix: well, whatever causes us to implement algorithms on them instead of for all containers
[11:02:20] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Ping timeout)
[11:02:30] <pnkfelix> strcat: ah i see
[11:02:45] <strcat> like most of the stuff in vec.rs on slices
[11:02:54] <strcat> could really be for all random-access containers
[11:03:13] <strcat> at least on ring buffers...
[11:03:22] <pnkfelix> so, just to bring things back to my original point
[11:03:40] * strcat wonders why language's like python don't use a ring buffer by default for their list
[11:05:39] <pnkfelix> hmm, wait.  (I was pretty sure that I had confirmed that MemWriter was not following a powers-of-two scheme, but now I cannot figure out why it was not...)
[11:06:12] *** zz_kimundi is now known as kimundi
[11:06:34] <pnkfelix> oh, maybe because its calling `push_all` and that invokes `reserve` instead of `reserve_at_least`...
[11:07:36] <pnkfelix> well, anyway, my real point was whether I should change MemWriter alone, or change the underlying vec code
[11:08:19] <strcat> pnkfelix: well 'both' ;p
[11:08:23] <strcat> except
[11:08:27] <strcat> lets throw out all of that ~[T] code
[11:08:39] <pnkfelix> strcat: I'm trying to keep the scope of my immediate work more contained
[11:10:18] *** Joins: andrew-d_w (andrew-d_w@4CCE6E0C.339B431B.1E537B93.IP)
[11:10:28] *** Quits: andrew-d_w (andrew-d_w@4CCE6E0C.339B431B.1E537B93.IP) (Input/output error)
[11:10:51] *** Joins: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net)
[11:14:26] <pnkfelix> strcat: but lets see, maybe i will be inspired
[11:15:20] *** Joins: gwty (gwtypc@928A4B44.FD2DAC3C.C924875F.IP)
[11:35:31] *** Quits: doomlord_ (servitor@moz-D9C46C01.range86-184.btcentralplus.com) (Ping timeout)
[11:38:50] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[11:47:26] <cmr> cargo-lite installs packages!
[11:47:40] <cmr> shipit.png
[11:51:54] <eddyb> pnkfelix: hmpf, do you happen to know what uses MemWriter, apart from format! and repr?
[11:53:21] <pnkfelix> eddyb: no not off hand
[11:53:59] <eddyb> I hope it's nothing important because I don't like MemWriter personally
[11:54:08] <cmr> why?
[11:54:09] <pnkfelix> eddyb: btw what is the "0 realloc thing" you alluded to above?  Something that first walks the structure to determine the needed output size and then does the output in a second pass?
[11:54:23] <eddyb> pnkfelix: the beauty of it is that it's one pass only
[11:54:34] <pnkfelix> eddyb: I'm not clear on how you can accomplish that
[11:54:36] <eddyb> cmr: harder to optimize
[11:54:37] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[11:54:42] <cmr> eddyb: who cares?
[11:54:51] <cmr> rust-postgres uses it.
[11:55:03] <eddyb> pnkfelix: recursion. sum the length as you go down, put into allocated space as you go back up
[11:55:24] <eddyb> you can keep stack data like [u8, ..64] used to print numbers
[11:55:31] <pnkfelix> eddyb: arguably that is still two passes
[11:55:38] <pnkfelix> eddyb: but I get what you are saying
[11:56:07] <pnkfelix> eddyb: (it depends on what ones view is of doing work on both the descent and the reascent in a recursive alg)
[11:56:25] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Ping timeout)
[11:56:27] <pnkfelix> eddyb: I guess the important thing is that your scheme has a simpler API
[11:56:33] <cmr> eddyb: as does rust-http
[11:57:06] <eddyb> pnkfelix: it abuses continuations though, so I'm a little bit afraid it might blow up in my face
[11:57:58] <pnkfelix> eddyb: "abuses continuations" : as in, the stack growth is O(traversal) ?
[11:58:18] <eddyb> pnkfelix: as in, everything is passing closures down the stack
[11:59:03] <eddyb> I was hoping I can get away without them *everywhere* but it turns out format_args! can be recursive
[12:00:20] <eddyb> see Formatter::run_plural, I think that's one of them. it has a for loop which has to be transformed into a recursive iteration, interpolated in other recursive iterations
[12:00:47] <eddyb> and this is a simple thing, I dread having to work in Haskell :/
[12:01:37] <eddyb> pnkfelix: so this was a for loop (I don't think that code compiles, needs some let juggling for the closure) https://gist.github.com/eddyb/f3ef987ea2d965d598d5#file-fmt-rs-L1126-L1133
[12:04:11] <pnkfelix> eddyb: hmm, I did not notice until now that fmt::write_unsafe is already parameterized over a &mut io::Writer object
[12:04:23] <pnkfelix> eddyb: so one could put in a two pass algorithm right now
[12:04:50] <pnkfelix> eddyb: (assuming that clients won't mind if their formatting methods are invoked twice instead of once)
[12:04:55] <eddyb> pnkfelix: it's not generic, though
[12:05:13] <pnkfelix> eddyb: ?  Its an object
[12:05:29] <eddyb> so it will do the same amount of virtual calls each time
[12:05:38] <pnkfelix> eddyb: right, but you pass in two different objects
[12:05:43] <pnkfelix> eddyb: the first one just counts
[12:05:54] <pnkfelix> eddyb: and discards the bytes that have been passed in
[12:06:09] <eddyb> and it's inferior than my trick because it formats numbers twice and whatnot
[12:06:30] <pnkfelix> eddyb: Sure, I can see that its not ideal
[12:06:39] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[12:06:39] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/tIv86Q
[12:06:39] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[12:06:45] <pnkfelix> eddyb: but it seems really easy to immediately deploy...
[12:07:25] <eddyb> pnkfelix: I am doing this crazy work in the hopes that in can be inlined to something small
[12:08:53] <eddyb> the current system does one indirect function call for each argument + at least one virtual call to Writer::write + all the matching on the static arrays containing the pieces
[12:10:56] <dbaupp> eddyb: have you measured how much actual overhead there is? (By hand-writing the output you're hoping to achieve?)
[12:11:15] <eddyb> print!("foo{}", "bar") should actually become just two virtual calls to Writer::write, I'm a bit afraid we have something worse blocking that transformation. I don't really now. I don't like that we use static arrays instead of directly generating code, but the latter is harder
[12:11:32] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[12:11:32] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/oz4SFQ
[12:11:32] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[12:11:33] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[12:11:33] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/6OmCpg
[12:11:33] <ghrust> 13rust/06auto 14dac3c53 15Steven Fackler: Avoid unused variable warning in quote_*!...
[12:11:33] <ghrust> 13rust/06auto 14068d828 15bors: auto merge of #11660 : sfackler/rust/quote-unused-sp, r=huonw...
[12:11:33] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[12:13:17] <ChrisMorgan> eddyb: remember that calls to write may be very expensive.
[12:15:56] <eddyb> dbaupp: well, format!("foobar"); is twice as slow as ~"foobar"; at --opt-level=3
[12:16:15] <eddyb> dbaupp: and that's without the changes that would nullify the latter to 0ns
[12:16:17] <strcat> ChrisMorgan: you don't have to worry about that
[12:16:20] <strcat> there are buffered writers
[12:16:50] <dbaupp> eddyb: how on earth can ~"foobar" be free?
[12:16:52] <ChrisMorgan> strcat: sure, they exist, but one may or may not be being used.
[12:16:52] <strcat> the whole point of the formatting writer stuff is to write directly instead of building temp stuff via allocations
[12:17:03] *** Parts: eddyb (eddy@EDE07015.D51DAF03.FB866788.IP) (Konversation terminated!)
[12:17:04] <strcat> ChrisMorgan: sure, but the writers exist *to avoid allocation*
[12:17:09] *** Joins: eddyb (eddy@EDE07015.D51DAF03.FB866788.IP)
[12:17:10] <strcat> they do more write calls, to avoid allocation
[12:17:14] <strcat> that's just how it is designed
[12:17:25] <strcat> if you care about performance you use a buffered writer
[12:17:27] <eddyb> there is apparently a key combination to close a tab
[12:17:42] <eddyb> dbaupp: weren't you around when we fixed our malloc/free situation?
[12:17:52] <dbaupp> eddyb: apparently not
[12:18:02] <eddyb> dbaupp: it was a bug that things like ~0; weren't optimized out
[12:18:03] <dbaupp> but I don't understand how allocation + memcpy can be free
[12:18:11] <eddyb> dbaupp: LLVM
[12:18:18] <eddyb> dead store elimination
[12:18:21] <dbaupp> oh, just by removing the ~"foobar" variable completely
[12:18:45] * strcat reported that issue ages ago ;p
[12:18:46] <dbaupp> surely that's not relevant to this discussion, since you're very rarely going to be allocating a dead string
[12:18:57] <strcat> https://github.com/mozilla/rust/issues/9541
[12:19:08] <eddyb> dbaupp: yes, without that (using the snapshot compiler), format! is twice as slow
[12:19:35] *** Joins: jdm (jdm@moz-AC9499B2.cable.teksavvy.com)
[12:20:04] <eddyb> format!("foo{}", "bar"); is around 1.5 times slower, I was expecting worse, TBQH
[12:20:28] <dbaupp> eddyb: format!("no formatting") is likely to be the worst case
[12:20:42] <eddyb> dbaupp: sorry, 2.5
[12:20:57] <dbaupp> since the converse ~"no formatting" is so simple
[12:21:04] <eddyb> and LTO doesn't help
[12:21:11] <dbaupp> (worse case for equivalent operations, that is)
[12:22:30] <eddyb> turns out I can't benchmark print
[12:25:27] <eddyb> interesting, almost identical times for format and print (the latter with | grep bench)
[12:26:34] <eddyb> oh, here's a thought, let's make sure LLVM optimizes fn foo(&str){} foo(~"foobar") into foo("foobar")
[12:26:53] <eddyb> (and vectors in general)
[12:27:09] <strcat> it won't optimize ~"foo" to "foo" in 99% of cases
[12:27:16] <strcat> it will only eliminate dead allocs
[12:27:50] <strcat> the only way it would "optimize" it is if another pass sees through the pointer, and does some constant eval thing
[12:27:54] <strcat> and then it can eliminate it as dead
[12:27:58] <strcat> which won't be common
[12:28:05] <eddyb> strcat: dst = alloc; memcpy(dst, src); pass dst as readonly
[12:28:29] <eddyb> I've been told readonly is a new thing and it's not as used as it could be
[12:28:50] <strcat> eddyb: it also doesn't work on slices
[12:28:53] <strcat> it's a parameter annotation
[12:29:00] <strcat> it only works if the parameter is a ptr
[12:29:40] <eddyb> and we pass slices as pointers to a tuple :(
[12:29:45] <strcat> I think you're expecting too much from LLVM, it's not nearly as smart as you think it is
[12:30:02] <eddyb> then my fmt work is pointless :(
[12:30:04] <strcat> eddyb: if we passed them by-value you still couldn't mark it
[12:30:15] <strcat> and LLVM also can't mark it
[12:30:17] <eddyb> strcat: pass them as two arguments?
[12:30:23] <strcat> please don't
[12:30:27] <eddyb> hehe
[12:30:30] <strcat> add tbaa metadata
[12:30:44] <eddyb> would that do the trick?
[12:30:51] <strcat> mark the pointer field of slices as read-only
[12:30:53] <strcat> eddyb: yes
[12:31:06] <eddyb> because you were thinking about it then decided it might be useless or close to useless
[12:31:09] <strcat> at least it lets you communicate enough info for LLVM to do it
[12:31:19] <strcat> eddyb: well it won't eliminate that allocation
[12:31:25] <strcat> it just in theory gives it the ability to do it ...
[12:32:04] <eddyb> strcat: yeah, well, I also want it to remove copies from structures passes by-value-but-indirectly, to the stack, in certain conditions
[12:32:10] *** Quits: km (quassel@moz-777F24DE.kevinmehall.com) (Ping timeout)
[12:32:13] *** Joins: km (quassel@moz-777F24DE.kevinmehall.com)
[12:32:29] <eddyb> strcat: about the latter, nicholas in #llvm said he tried it but the pass ended up not doing anything with all the safety checks
[12:33:19] <strcat> eddyb: the proper way to do it is making LLVM handle by-value parameters/returns sanely
[12:33:23] <strcat> and not doing the copies ourselves
[12:33:48] <eddyb> strcat: the optimization would help optimize even more clones, too
[12:33:56] *** Quits: Leo` (Leo@moz-83832FE2.placeholder.fr) (Ping timeout)
[12:34:09] <eddyb> we have Freeze, let's use it more in trans
[12:34:16] <strcat> eddyb: can't
[12:34:22] <strcat> librustc doesn't follow the mutability rules
[12:34:34] <strcat> can't optimize based on either aliasing guarantees or mutability 
[12:34:35] *** Joins: Leo` (Leo@moz-83832FE2.placeholder.fr)
[12:34:45] <strcat> er
[12:34:47] <strcat> libstd*
[12:34:52] <strcat> anyway it's not going to work out
[12:34:58] <eddyb> I know LTO already breaks binaries
[12:35:02] <strcat> throw out all of libstd and start over, and you can start upholding those guarantees
[12:35:05] <eddyb> my PNG tests never worked with LTO
[12:36:08] <eddyb> strcat: oh, btw, how do we deal with static data and mutability?
[12:36:21] <strcat> we make constants
[12:36:23] <eddyb> do we put a static immut non-Freeze in rodata?
[12:36:55] <strcat> yes
[12:36:59] <eddyb> hehehe
[12:37:03] <strcat> which is fine
[12:37:13] <strcat> afaik
[12:37:15] <strcat> well
[12:37:34] <strcat> I guess Cell/RefCell break it
[12:37:46] <eddyb> I realized that my optimization to only put mut bindings in allocas was going to break something like fn foo(x: Cell<int>)
[12:38:06] <strcat> yeah, it *feels* like rust has more type info than C
[12:38:08] <eddyb> it's immut, but you can't put it in a SSA slot
[12:38:09] <strcat> but it really has less...
[12:38:13] <strcat> C has type punning rules
[12:38:19] <strcat> rust has.... nothing really, that we enforce
[12:38:36] <strcat> #[no_freeze] isn't used everywhere it should be
[12:38:43] <eddyb> so much encourangement
[12:39:00] <strcat> if you start enforcing them in libstd then you can think about doing it
[12:39:07] <eddyb> *encouragement?
[12:39:12] <strcat> need to stop writing so much low quality unsafe code...
[12:39:14] <strcat> ;[
[12:39:23] <eddyb> (even the spellchecker gave up)
[12:39:45] <eddyb> strcat: needs more unsafe-related lints
[12:40:17] <eddyb> people put safe code in unsafe blocks for no reason other than looks
[12:40:28] <strcat> hm?
[12:40:38] <strcat> putting the code associated with the unsafe code in the block makes perfect sense
[12:41:04] <strcat> unsafe { let x = get_int(); unsafe_horrible_thing(x) } is fine imo
[12:41:10] <strcat> yes, you could put `x` outside of it
[12:41:10] <eddyb> not in mine
[12:41:12] *** kimundi is now known as zz_kimundi
[12:41:35] <eddyb> because harder to evaluate the unsafety's scope, and easier to accidentally add more unsafety in that block
[12:41:52] <eddyb> *because it becomes
[12:42:40] <eddyb> strcat: at least we can do egrep '\bunsafe\b'
[12:42:56] <eddyb> in case we need to review all of that
[12:44:00] <eddyb> strcat: the function creating the extern "C/system" fn wrapper (the one that calls to fn$__rust_abi) is unsafe
[12:44:09] <eddyb> just so it can call directly into LLVM
[12:44:21] <strcat> so write high-level LLVM bindings
[12:44:33] <dbaupp> $ git grep '\bunsafe\b' | wc -l => 972 (for libstd
[12:44:35] <dbaupp> )
[12:44:35] <eddyb> we have wrappers for some of the stuff
[12:44:41] *** Quits: Kxepal (Miranda@moz-77F2B717.pppoe.mtu-net.ru) (Quit: Kxepal)
[12:44:43] <strcat> eddyb: and they say they are safe but aren't
[12:44:49] <strcat> you can easily segfault librustc
[12:44:53] <strcat> in safe code
[12:45:02] *** Joins: Kxepal (Miranda@moz-77F2B717.pppoe.mtu-net.ru)
[12:45:04] <strcat> because it pretends the LLVM stuff is safe after wrapping it thinly
[12:45:16] <strcat> it doesn't draw any kind of safety boundary
[12:45:28] <strcat> it's just like all of librustc is vec.rs
[12:45:28] <eddyb> LLVM segfaults easily if you ask it to do anything bad
[12:45:34] <eddyb> like take an out of bounds argument
[12:45:46] <dbaupp> ("only" 654 that aren't just `unsafe { foo() }` on one line.)
[12:45:55] *** Quits: Kxepal (Miranda@moz-77F2B717.pppoe.mtu-net.ru) (Quit: Kxepal)
[12:46:01] <strcat> eddyb: and we should have a high-level LLVM binding letting us build LLVM without asserts
[12:46:10] <strcat> while preserving librustc's memory safety
[12:46:22] *** Joins: Kxepal (Miranda@moz-77F2B717.pppoe.mtu-net.ru)
[12:46:26] <strcat> atm librustc is a really poor example of rust
[12:46:26] <eddyb> safer LLVM, slightly slower bindings?
[12:46:31] <strcat> it doesn't draw any safety boundary
[12:46:33] <strcat> so...
[12:46:36] <strcat> it's as bad as C++
[12:46:43] <eddyb> s/safer/faster/
[12:46:49] <strcat> there is no safe/unsafe code in librustc, it's basically all unsafe ;s
[12:47:03] <eddyb> though we could build LLVM with LTO and inline all the tiny LLVM functions
[12:47:22] <strcat> eddyb: disabling LLVM asserts makes it 20-30% faster
[12:47:35] <strcat> we need the asserts because we just use raw LLVM everywhere
[12:47:50] <eddyb> strcat: has anyone ever tried LTO between librustc and LLVM?
[12:47:58] <strcat> no
[12:48:03] <eddyb> though we've only recently gained the ability to statically link, so I doubt it
[12:48:25] <strcat> you can't use real LTO in our build
[12:48:31] <strcat> unless you ship a linker and clang
[12:48:40] <eddyb> strcat: ValueRef all over the place makes it easy to mismatch types
[12:48:59] <eddyb> s/ship/allow using for building/
[12:49:20] <eddyb> oh, yeah, all those type mismatches and whatnot... those were LLVM asserts
[12:49:39] <strcat> yeah those asserts are not there in a production build of clang/llvm
[12:49:47] <eddyb> without the asserts, I could've never done anything in trans
[12:49:48] <strcat> rust can't use the system llvm until it stops depending on them being there
[12:50:11] <eddyb> strcat: well, one thing to do is stop passing so many frickin ValueRefs everywhere
[12:50:20] <eddyb> Datums are supposed to be type safe
[12:50:34] <strcat> need to step away from librustc
[12:50:35] <strcat> build rust-llvm
[12:50:38] <strcat> then make trans use it
[12:51:34] <eddyb> if we force everything to use Datum, it's much better already
[12:52:19] <eddyb> (you can't really do something like Datum without depending on librustc internals - middle::ty especially)
[12:57:48] *** Joins: bjz_ (bjz@B398BE78.F804C29E.D35A31DF.IP)
[12:57:57] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[13:11:48] <eddyb> so now I'm afraid to even test my std::fmt changes, all the fixing that I have to do and they might not even be optimized as well :(
[13:12:10] *** Joins: canhtak (canhtak@moz-6C22A50C.wl.t.ulaval.ca)
[13:17:14] *** Joins: doomlord_ (servitor@moz-D9C46C01.range86-184.btcentralplus.com)
[13:20:07] *** Joins: new_one (new_one@CCDACABD.439D8424.B3C0173E.IP)
[13:22:49] *** Joins: c-a (c-a@moz-8D7A06D6.a163.priv.bahnhof.se)
[13:24:54] *** Quits: Leo` (Leo@moz-83832FE2.placeholder.fr) (Ping timeout)
[13:31:36] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[13:31:37] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/6OmCpg
[13:31:37] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[13:32:47] *** Quits: jsonnull (Thunderbir@E86DD23.582C899D.494A0F8B.IP) (Ping timeout)
[13:36:10] *** Joins: jsonnull (Thunderbir@E86DD23.582C899D.494A0F8B.IP)
[13:36:33] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[13:36:33] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/fOFveA
[13:36:33] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[13:36:36] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[13:36:36] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/K18LUQ
[13:36:36] <ghrust> 13rust/06auto 146f3c202 15Huon Wilson: rustc: check instantiability of fixed length vectors properly....
[13:36:36] <ghrust> 13rust/06auto 1460914db 15bors: auto merge of #11661 : huonw/rust/fixed-length-instantiation, r=thestinger...
[13:36:37] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[13:37:33] *** flaper87 is now known as flaper87|afk
[13:38:59] *** Joins: Leo` (Leo@moz-83832FE2.placeholder.fr)
[13:42:26] *** Quits: canhtak (canhtak@moz-6C22A50C.wl.t.ulaval.ca) (Quit: canhtak)
[13:50:36] <dbaupp> "error: aborting due to 538 previous errors" ... I think I made a mistake.
[13:53:26] <cmr> nope!
[13:53:32] <cmr> now have fun fixing all of everything :p
[13:54:56] *** Quits: Kxepal (Miranda@moz-77F2B717.pppoe.mtu-net.ru) (Connection reset by peer)
[13:57:49] *** Joins: Kxepal (Miranda@moz-77F2B717.pppoe.mtu-net.ru)
[14:04:13] <eddyb> dbaupp: what did you change for that?
[14:09:05] <dbaupp> eddyb: adding a new lint
[14:09:10] <dbaupp> but implementing it incorrectly
[14:09:14] <dbaupp> so it barfs on libstd
[14:09:42] <eddyb> dbaupp: what for :D?
[14:10:28] <dbaupp> eddyb: using a private type in an public function
[14:10:38] <eddyb> oooh
[14:10:39] *** Joins: canhtak (canhtak@moz-6C22A50C.wl.t.ulaval.ca)
[14:10:40] <dbaupp> (e.g. `struct Foo; pub fn foo() -> Foo { .. }`)
[14:10:50] <eddyb> I think there's a bunch of std stuff that does it
[14:11:01] <dbaupp> yup
[14:11:08] <dbaupp> I've fixed the "real" ones
[14:11:41] *** Quits: gwty (gwtypc@928A4B44.FD2DAC3C.C924875F.IP) (Ping timeout)
[14:11:44] <dbaupp> but a bug meant it was complaining about any generics, which gave the spew of errors
[14:12:02] <eddyb> oooh
[14:12:04] *** Quits: canhtak (canhtak@moz-6C22A50C.wl.t.ulaval.ca) (Quit: canhtak)
[14:16:32] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[14:16:33] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1460914db to 14068d828: 02http://git.io/N3iJvQ
[14:16:33] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[14:18:20] *** Joins: canhtak (canhtak@moz-6C22A50C.wl.t.ulaval.ca)
[14:24:10] *** Quits: canhtak (canhtak@moz-6C22A50C.wl.t.ulaval.ca) (Quit: canhtak)
[14:27:12] *** Quits: doomlord_ (servitor@moz-D9C46C01.range86-184.btcentralplus.com) (Connection reset by peer)
[14:30:55] *** Joins: canhtak (canhtak@moz-6C22A50C.wl.t.ulaval.ca)
[14:31:20] *** Quits: canhtak (canhtak@moz-6C22A50C.wl.t.ulaval.ca) (Quit: canhtak)
[14:39:38] *** Joins: gwty (gwtypc@928A4B44.FD2DAC3C.C924875F.IP)
[14:41:21] <cmr> please don't share this outside of #rust-internals: https://github.com/cmr/cargo-lite
[14:41:36] <jdm> ooh
[14:41:52] <cmr> (ie, reddit, #rust, etc)
[14:44:39] <cmr> if anyone knows how to setup.py that'd be nice :)
[14:44:44] <cmr> bjz_: ^ give it a spin.
[14:48:30] * dbaupp posts it to reddit, #rust, HN
[14:48:41] * ChrisMorgan posts it to #rust-internals
[14:49:00] <eddyb> dbaupp: HN before everything else :P
[14:49:26] * dbaupp posts it to rusti
[14:49:28] <dbaupp> rusti: https://github.com/cmr/cargo-lite
[14:49:31] -rusti- pastebinned 6 lines of output: http://ix.io/a0I
[14:49:37] <cmr> har har :p
[14:49:55] <dbaupp> cmr: "naval fate"?
[14:50:01] <cmr> hurp
[14:50:04] <cmr> from the docopt example :p
[14:50:34] <cmr> docopt is super cool btw.
[14:50:40] <dbaupp> is docopt better than argparse?
[14:50:42] <cmr> best triage bug I ever got was a rust replicant of it
[14:50:48] <cmr> it parses the docstring at the top.
[14:50:52] <cmr> and makes a dict.
[14:50:53] <cmr> so yes.
[14:50:55] <cmr> yes it is.
[14:51:01] <dbaupp> Neat
[14:51:09] <cmr> by miles :p
[14:51:16] <dbaupp> but it does mean you have to write & format the full docstring :P
[14:51:48] <dbaupp> in any case, what's the <path> for install?
[14:52:13] <cmr> either a git repo, hg repo, or local path.
[14:52:25] <cmr> its treatment depends on the presence of either --git, --hg, or --local
[14:53:19] <dbaupp> erm, is install infinitely recursive? https://github.com/cmr/cargo-lite/blob/master/cargo-lite.py#L148
[14:53:32] <dbaupp> oh, no, I see
[14:53:37] <dbaupp> argv changes
[14:54:25] <ChrisMorgan> cmr: git+URL and hg+URL work well for inferring also
[14:57:56] <cmr> ChrisMorgan: feh
[14:58:02] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[14:58:34] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[14:59:12] <ChrisMorgan> cmr: you can also check if something is a Mercurial repository with the return code of `hg identify http://...`, though that's not the fastest operation
[14:59:22] <cmr> super feh
[14:59:28] <cmr> I'll implement the first, definitely not the secon.
[14:59:31] *** Quits: Leo` (Leo@moz-83832FE2.placeholder.fr) (Ping timeout)
[15:00:11] <cmr> (https://github.com/cmr/cargo-lite/issues/1)
[15:00:17] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[15:02:54] *** Joins: Leo` (Leo@moz-83832FE2.placeholder.fr)
[15:03:31] * ChrisMorgan is not impressed with plumbum for this reason: in six minutes of research, he has been unable to determine how to get a process's return code
[15:05:54] *** Joins: canhtak (canhtak@moz-6C22A50C.wl.t.ulaval.ca)
[15:06:15] <strcat> ChrisMorgan: just use sh
[15:06:25] <strcat> ChrisMorgan: http://amoffat.github.io/sh/
[15:06:27] <strcat> *shrug*
[15:06:46] <ChrisMorgan> strcat: I was just looking because cmr was using it
[15:06:46] <strcat> no point in trying overly hard to look like bash ;p
[15:06:49] <strcat> oh
[15:07:03] * ChrisMorgan is quite content using subprocess directly for most things
[15:07:53] <dbaupp> ChrisMorgan: http://plumbum.readthedocs.org/en/latest/local_commands.html#exit-codes
[15:09:00] <ChrisMorgan> OK, so it is there, and as I expectedâ€”in fail fast mode, normal to Python but unusual for the shell.
[15:17:09] <dbaupp> oh, neat librustuv doesn't have (many) dependencies, so I just got an incremental build
[15:17:11] <dbaupp> \o/
[15:22:04] *** Quits: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net) (Quit: Leaving...)
[15:22:27] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[15:27:44] *** Joins: rca_ (rcatolino@moz-18AEB6AE.adsl.proxad.net)
[15:28:20] *** Quits: rca (rcatolino@moz-10E18C17.adsl.proxad.net) (Ping timeout)
[15:28:32] *** Quits: bjz_ (bjz@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[15:28:43] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[15:32:08] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[15:34:20] *** Quits: jdm (jdm@moz-AC9499B2.cable.teksavvy.com) (Quit: Lost terminal)
[15:36:38] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[15:36:38] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/xN-5jQ
[15:36:38] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[15:37:03] *** Joins: Sharp (Sharp@moz-EEC85237.hsd1.ca.comcast.net)
[15:38:08] *** Quits: Leo` (Leo@moz-83832FE2.placeholder.fr) (Ping timeout)
[15:39:33] *** Joins: mankyKitty (Instantbir@moz-9B898D95.enst-bretagne.fr)
[15:39:34] *** Joins: Leo` (Leo@moz-83832FE2.placeholder.fr)
[15:39:50] <mankyKitty> greetings :)
[15:41:33] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[15:41:33] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/bS5MMg
[15:41:33] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[15:41:34] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[15:41:35] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/Y7oI6w
[15:41:35] <ghrust> 13rust/06auto 148e9bb34 15Alex Crichton: Fix a pathological const checking case...
[15:41:35] <ghrust> 13rust/06auto 14a3a670f 15bors: auto merge of #11662 : alexcrichton/rust/faster-parens, r=huonw...
[15:41:35] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[15:41:53] <mankyKitty> Overly excitable newbie here, I'm having a crack at this issue: https://github.com/mozilla/rust/issues/10877 .. 
[15:47:54] *** Quits: jsonnull (Thunderbir@E86DD23.582C899D.494A0F8B.IP) (Ping timeout)
[15:50:12] <bjz> mankyKitty: o/
[15:50:20] <bjz> mankyKitty: welcome!
[15:50:22] <mankyKitty> hurro !
[15:50:24] <mankyKitty> thank you 
[15:50:55] <bjz> mankyKitty: it is still early for the mozilla folks, so it might be a little quiet
[15:51:15] *** Joins: jsonnull (Thunderbir@E86DD23.582C899D.494A0F8B.IP)
[15:51:22] <mankyKitty> Yeah I thought so, I'm currently interning in France so everything is wonky for timezones
[15:51:26] <bjz> mankyKitty: that said there are quite a few of us either in different time zones or up well past their bed times
[15:51:32] <mankyKitty> haha
[15:51:43] * bjz is somewhat guilty of the latter
[15:52:39] <bjz> so yeah, things are starting to get more hectic on #rust, it's easier for your specific questions to be seen here
[15:53:13] <mankyKitty> Excellent
[15:53:24] <bjz> what brings you to our oxidised world?
[15:53:46] <bjz> :)
[15:54:11] <mankyKitty> Over the last year I've gone from a work-a-day PHP/Drupal dev to discovering Clojure, then hitting every functional branch on the way down and landing squarely in the "holy balls language hacking is awesome" pond.
[15:54:20] <bjz> nice
[15:54:30] <pnkfelix> mankyKitty: Where are you in France?
[15:54:35] <mankyKitty> Brest
[15:55:24] <pnkfelix> mankyKitty: okay that's "far" from me.  :)
[15:55:29] <mankyKitty> haha
[15:55:35] <mankyKitty> Where are you?
[15:55:39] <pnkfelix> mankyKitty: Paris
[15:55:43] <bjz> mankyKitty: the exciting thing about rust is that it has a good chance at becoming at least reasonably notable, but it's still very new, so your contributions can make a real impact
[15:55:46] <mankyKitty> Oh yeah, that's a walk
[15:56:29] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[15:56:30] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14a3a670f to 1402d4572: 02http://git.io/N3iJvQ
[15:56:30] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[15:56:33] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[15:56:33] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/EHWXKw
[15:56:34] <ghrust> 13rust/06auto 14cf56624 15Brendan Zabarauskas: Add operator trait constraints to std::num::{Zero, One} and document their appropriate use...
[15:56:34] <ghrust> 13rust/06auto 14509283d 15Brendan Zabarauskas: Improve std::num::pow implementation...
[15:56:34] <ghrust> 13rust/06auto 14be3a80d 15bors: auto merge of #11664 : bjz/rust/identities, r=alexcrichton...
[15:56:36] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[15:57:02] <mankyKitty> Yeah Rust has really grown on me when I've been tinkering with it, but all I've really done is tinker and I'd love to be able to really contribute something more. But even at uni we never touched compilers, they consider it a post-grad thing. So I'm having to learn really fast. :s
[15:57:31] <cmr> yeah plubmumb... eh.
[15:57:37] <cmr> but it's what I had on hand so it's what I used.
[15:57:47] <cmr> strcat: sh looks super nice, wish I kenw about it before I started :p
[15:57:56] <strcat> cmr: not too late
[15:57:58] <strcat> ;p
[15:58:03] <cmr> nope
[15:58:03] <eddyb> post-grad?
[15:58:05] <cmr> will refactor.
[15:58:10] <bjz> mankyKitty: yeah, you can get the hang of it nicely - that said, I don't venture into the compiler all that much - I'm mainly a library guy
[15:58:21] <mankyKitty> post graduate
[15:58:26] * eddyb didn't finish highschool, loves hacking away at rustc
[15:58:56] <mankyKitty> <-- took forever to work out language hacking is awesome. Only warming up.
[15:59:01] <bjz> mankyKitty: we have a build bot and lots of test coverage that will prevent you from pushing any dire mistakes
[15:59:22] <bjz> mankyKitty: have you looked at the wiki?
[15:59:32] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Client exited)
[15:59:51] <mankyKitty> Yep, I have a few pages open, reading up on contributions and such. Picking issues
[15:59:53] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[16:00:15] <bjz> https://github.com/mozilla/rust/wiki/Notes
[16:00:17] <bjz> oh cool
[16:01:33] <eddyb> cmr: you missed a perfect "and you never will"
[16:01:35] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Ping timeout)
[16:02:29] <bjz> mankyKitty: so Rust is your first systems lang?
[16:04:23] <mankyKitty> Yes and no, my professional experience is all PHP/Java.. But I'm a chronic tinkerer so I've messed with C/C++/Go/Erlang/Haskell/LFE/Clojure
[16:04:51] <bjz> oh neat
[16:05:15] <eddyb> mankyKitty: sounds like you'll do just fine in Rust :D
[16:05:23] <mankyKitty> Woohoo!
[16:05:39] *** Joins: yuriks (yuriks@8E8458DA.1755AC6C.F6EE4B40.IP)
[16:05:57] <bjz> mankyKitty: well at least Erlang would have taught you to accept horrible syntax
[16:06:04] * bjz jokes
[16:06:08] <bjz> XD
[16:06:31] <mankyKitty> hahaha, people say that but I've always thought it was a good fit. :P 
[16:06:41] <bjz> for Erlang?
[16:06:44] <mankyKitty> yeah
[16:06:56] <bjz> yeah, they're just not used to prolog-like langs
[16:06:56] <eddyb> isn't Erlang using functional syntax? though I don't remember much
[16:07:13] <mankyKitty> Like okay somethings could get hideous if you let it get out of hand
[16:07:16] <bjz> eddyb: was influenced greatly by prolog
[16:07:18] <mankyKitty> it's a Prolog-esque
[16:07:37] <bjz> eddyb: it was originally implemented in prolog
[16:07:41] <eddyb> I know how Haskell looks, but that's about it
[16:07:53] <eddyb> bjz: prolog... is that natural language/logic thing?
[16:07:56] <eddyb> that I never understood
[16:08:36] *** Joins: jdm (jdm@moz-AC9499B2.cable.teksavvy.com)
[16:08:38] <bjz> logic/constraint programming language
[16:08:54] <mankyKitty> Basic Erlang function with a guard: junk(Something) when is_list(Something) -> io:print(Something).
[16:09:13] <mankyKitty> I'm sure the emoticons were valid syntax >.>
[16:09:18] <bjz> like, people say functional langs are declarative - logic langs are even more so
[16:09:52] <eddyb> I remember what Smalltalk looks like because Objective-C (we can implement their OO model in Rust btw. with macros for syntax. maybe even interop with real Objective-C if you need it)
[16:14:28] <mankyKitty> I may vanish in a bit, but when I know what I want to ask about that issue, I'll be back. :) (dat issue: https://github.com/mozilla/rust/issues/10877)
[16:14:40] <bjz> eddyb: so something like: objc!(foo with_arg:x and_another_arg:y)
[16:15:12] <eddyb> bjz: why skip the []?
[16:15:19] <bjz> objc!([foo withArg:x andAnotherArg:y])
[16:15:23] <bjz> you mean?
[16:15:28] <eddyb> bjz: myeah
[16:16:06] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[16:16:10] <bjz> I guess the squaries are so smalltalkymessagey you have to have them
[16:16:33] <eddyb> bjz: I actually need variadic generics to get the argument types. or I could implement the entire thing with procedural macros now that we have them
[16:16:42] <eddyb> wait, foo is a function or a receiver?
[16:16:59] <eddyb> I guess withArg is the method, makes more sense
[16:17:18] <bjz> reciever object. I might have got things wrong though
[16:17:27] <bjz> haven't done too much objc
[16:18:40] *** Quits: mankyKitty (Instantbir@moz-9B898D95.enst-bretagne.fr) (Ping timeout)
[16:18:57] <bjz> eddyb: from memory the function is referred to as, "withArg:andAnotherArg"
[16:19:22] <eddyb> bjz: I think you're missing one character
[16:19:40] <bjz> the :?
[16:19:50] <bjz> "withArg:andAnotherArg:"
[16:19:58] <eddyb> yes :)
[16:20:18] <bjz> ooh, an example from wikipedia: [myColor changeColorToRed:5.0 green:2.0 blue:6.0];
[16:21:12] * bjz has a soft spot for the long descriptive thinigies in objc
[16:21:56] <eddyb> unsafe fn wrapper<A, B, C, R>(recv: &Many, name: &str, a: A, b: B, c: C) -> R {(recv.query_method(name, TypeId::<fn(*(), A, B, C) -> R>::of()) as fn(*(), A, B, C) -> R)(recv.as_unsafe_ref(), a, b, c)} unsafe{wrapper(myColor, "changeColorToRed:green:blue:", 5.0. 2.0. 6.0)}
[16:22:09] <eddyb> keep in mind that it won't work if you changes any of the (infered) types
[16:22:59] <eddyb> bjz: and I've never written a single line of Objective-C (++) in my life
[16:23:02] *** Quits: lpy (lpy@7FD2B9AB.3720F6C5.952560D4.IP) (Quit: Leaving...)
[16:23:41] <eddyb> bjz: you know the beauty of Many?
[16:23:55] <eddyb> it can do RTTI and even FFI behind the scenes
[16:24:06] <eddyb> all it needs to do is provide a rusty interface
[16:25:51] *** Joins: mankyKitty (Instantbir@moz-9B898D95.enst-bretagne.fr)
[16:41:30] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[16:41:30] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14be3a80d to 1402d4572: 02http://git.io/N3iJvQ
[16:41:30] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[16:41:32] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[16:41:32] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/uPPVUw
[16:41:32] <ghrust> 13rust/06auto 1488d0c18 15Steven Fackler: Add span_note to ExtCtxt...
[16:41:32] <ghrust> 13rust/06auto 14f8efde1 15bors: auto merge of #11670 : sfackler/rust/extctxt-span-note, r=alexcrichton...
[16:41:33] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[16:41:34] *** Quits: gwty (gwtypc@928A4B44.FD2DAC3C.C924875F.IP) (Ping timeout)
[16:43:21] *** Joins: gwty (gwtypc@928A4B44.FD2DAC3C.C924875F.IP)
[16:43:57] *** Quits: canhtak (canhtak@moz-6C22A50C.wl.t.ulaval.ca) (Quit: canhtak)
[16:48:00] *** Quits: mankyKitty (Instantbir@moz-9B898D95.enst-bretagne.fr) (Ping timeout)
[16:48:58] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[16:56:31] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[16:59:50] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[17:04:52] <cmr> eddyb: was that supposed to be a stab at your academic record? :p
[17:05:11] <eddyb> cmr: that's a nice way of putting it
[17:08:00] <cmr> Any other feedback for cargo-lite before I release it to the world?
[17:09:54] <SiegeLord> Did I miss a link to it?
[17:10:01] <cmr> https://github.com/cmr/cargo-lite
[17:10:18] <bjz> any idea what went wrong here? http://buildbot.rust-lang.org/builders/auto-linux-32-opt/builds/3696/steps/test/logs/stdio/text
[17:10:18] <cmr> (don't share outside of this channel plz)
[17:16:15] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[17:16:45] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[17:18:30] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[17:19:58] <bjz> cmr: any idea?
[17:20:32] <cmr> bjz: only if you comment on https://github.com/cmr/cargo-lite ;p
[17:21:46] <bjz> cmr: neat :)
[17:22:00] <cmr> bjz: (don't leak it outside of this channel plz)
[17:22:06] <cmr> bjz: which PR is that from?
[17:22:27] <bjz> https://github.com/mozilla/rust/pull/11664/
[17:23:09] <cmr> that's concerning..
[17:24:26] *** Joins: brson (brson@moz-5386576F.sd.sd.cox.net)
[17:24:26] *** ChanServ sets mode: +qo brson brson
[17:24:37] <bjz> it is?
[17:24:41] <cmr> yes
[17:24:49] <bjz> ._.
[17:24:50] <cmr> random unrelated runtime asserts?
[17:25:17] <cmr> definitely concerning :p
[17:25:18] * bjz could not pick the problem
[17:25:26] <cmr> Illegal instruction (core dumped)
[17:25:31] <cmr> means abort intrinsic
[17:25:32] <bjz> Is it something I did?
[17:25:34] <cmr> which means rtabort
[17:25:37] <cmr> no, I don't think so.
[17:25:47] <bjz> :[
[17:26:39] <eddyb> are we talking about the LTO problems?
[17:26:44] <eddyb> the runtime errors?
[17:26:58] <eddyb> I've gotten those months ago, thought LTO was just unstable
[17:27:18] <bjz> cmr: should we just try it again then?
[17:27:23] <cmr> bjz: already did.
[17:27:44] <eddyb> they still happen for programs larger than tiny tests (which I compile with -S --emit-llvm anyway most of the time)
[17:28:40] <eddyb> nevermind me, I see what bjz was talking about
[17:29:56] *** Quits: Leo` (Leo@moz-83832FE2.placeholder.fr) (Ping timeout)
[17:33:44] *** Quits: c-a (c-a@moz-8D7A06D6.a163.priv.bahnhof.se) (Quit: Ex-Chat)
[17:38:55] *** Joins: mankyKitty (Instantbir@moz-21AD3B58.rev.sfr.net)
[17:39:38] *** Quits: gwty (gwtypc@928A4B44.FD2DAC3C.C924875F.IP) (Ping timeout)
[17:41:36] *** Joins: gwty (gwtypc@1EFB01E7.E90DBF57.137C914F.IP)
[17:42:58] *** Joins: Leo` (Leo@moz-83832FE2.placeholder.fr)
[17:44:32] *** bstrie_nope is now known as bstrie_ng
[17:44:52] *** Joins: doener (doener@moz-C68F600D.unity-media.net)
[17:50:00] <bjz> cmr: https://news.ycombinator.com/item?id=7090293
[17:50:40] <bjz> "After compiling this with the latest rust built from git, I get only the "Illegal instruction" as an error message when I try to run this example."
[17:50:50] <bjz> (re. the chinese whispers thing)
[17:51:41] <cmr> yeah.
[17:52:06] *** Quits: mankyKitty (Instantbir@moz-21AD3B58.rev.sfr.net) (Quit: mankyKitty)
[17:52:14] <doener> hm, couldn't reproduce that without LTO
[17:52:36] <doener> ... using rustc built a few hours ago
[17:52:59] * bjz doesn't understand the LTO stuff
[17:53:23] <bjz> fancy pants people
[17:53:42] <doener> Loony Toons Optimization
[17:53:43] <bjz> :9
[17:53:51] <eddyb> LTO is broken, people
[17:53:57] <doener> s/Toons/Tunes/
[17:54:08] <eddyb> I've thought it was a snapshot thing when it was just added
[17:54:13] <eddyb> my PNG decoder never worked with LTO
[17:54:30] <eddyb> can we make that clear?
[17:54:58] <eddyb> it's not just that example
[17:55:10] <eddyb> (though it would be nice to reduce it because it's relatively small)
[17:55:43] <bjz> eddyb: I was mentioning it because I got "Illegal instruction" from bors
[17:56:21] <eddyb> yes, I saw that, too late though
[17:56:30] <eddyb> bjz: they might be unrelated
[17:56:42] <bjz> yeah
[17:56:43] <eddyb> LTO usually spits the runtime poems when it's broken
[17:56:53] <bjz> :(
[17:57:00] * bjz didn't get his poem
[17:57:30] <cmr> we need to include more poems
[17:58:11] <eddyb> do we have an issue for LTO breaking the runtime?
[17:58:34] <doener> I filed one for the chinese whisperer thing
[17:58:43] <eddyb> doener: oh, that was you
[17:58:44] <bjz> cmr: +1
[17:59:03] <eddyb> doener: the code is not that relevant, really
[17:59:22] <eddyb> doener: that is, LTO breaks the runtime, that code just happens to trigger it
[17:59:37] <eddyb> doener: feel free to reduce it to one line if you have time
[18:00:37] <doener> eddyb: I'd rather work on something where I feel I can do more than blind guessing ;-)
[18:01:12] <eddyb> oh, you just have to remove code from it until it starts working
[18:01:38] <eddyb> (but I guess I can do it, I'm not doing anything smart at the moment)
[18:01:41] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[18:01:41] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/uPPVUw
[18:01:41] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[18:01:45] *** zz_kimundi is now known as kimundi
[18:06:51] <doener> eddyb: ok, got something a lot smaller
[18:11:13] *** Quits: Sharp (Sharp@moz-EEC85237.hsd1.ca.comcast.net) (Quit: Sharp)
[18:11:19] *** Quits: jdm (jdm@moz-AC9499B2.cable.teksavvy.com) (Quit: Lost terminal)
[18:11:34] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[18:11:35] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/Tz97sA
[18:11:35] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[18:12:15] <eddyb> doener: what is it?
[18:12:26] <eddyb> doener: oh, cool
[18:12:33] <eddyb> doener: can you do it without spawning a new thread?
[18:12:41] <eddyb> s/thread/task
[18:12:43] <doener> I guess not
[18:13:05] <eddyb> my PNG decoder wasn't using tasks, unless it was the test runner but I doubt it a bit
[18:13:14] <eddyb> doener: try using port/chan on the main task
[18:13:17] <doener> the println!() helps to make it happen. Without it, it happens only every once in a while
[18:13:40] <eddyb> doener: println! does Local::take
[18:13:50] <eddyb> (which accesses the internal task nonsense)
[18:15:31] <doener> eddyb: what do you mean by "using port/chan on the main task"? Just "c.send(1); p.recv()" in main()?
[18:15:40] <eddyb> doener: yeah
[18:16:01] <doener> doesn't exhibit the error when run in a loop
[18:16:31] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[18:16:31] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/Tz97sA
[18:16:31] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[18:16:56] <doener> it does happen when I move both into the spawned task though
[18:17:18] <cmr> cargo-lite embargo lifted :P
[18:17:29] <doener> sometimes with the !ptr.is_null() assertion, something with take_unwrap called on None
[18:17:50] <cmr> doener: it's probably just a race condition in the runtime somewhere.
[18:19:05] <doener> cmr: only exposed with lto though
[18:19:18] <doener> cmr: or at least very hard to reproduce without it
[18:20:15] *** Quits: gwty (gwtypc@1EFB01E7.E90DBF57.137C914F.IP) (Ping timeout)
[18:28:03] <brson> cmr: what's cargo-lite?
[18:29:25] <cmr> brson: a piece of crap that more or less works.
[18:29:27] <cmr> see readme
[18:29:33] <cmr> https://github.com/cmr/cargo-lite
[18:35:00] *** Joins: Sharp (Sharp@moz-4D4C136C.dsl.pltn13.sbcglobal.net)
[18:35:21] *** Quits: Sharp (Sharp@moz-4D4C136C.dsl.pltn13.sbcglobal.net) (Quit: Sharp)
[18:39:46] *** Quits: brson (brson@moz-5386576F.sd.sd.cox.net) (Quit: leaving)
[18:40:20] *** Joins: brson (brson@moz-5386576F.sd.sd.cox.net)
[18:40:20] *** ChanServ sets mode: +qo brson brson
[18:42:45] *** Joins: Sharp (Sharp@moz-4D4C136C.dsl.pltn13.sbcglobal.net)
[18:45:38] <steveklabnik> cmr cargo-lite looks neat
[18:45:53] <steveklabnik> i've been joking that indirect needs to port bundler to rust pronto
[18:45:55] <steveklabnik> 'rustler'
[18:46:43] <sfackler> man, rustler is a great name
[18:46:44] <cmr> who is indirect?
[18:46:54] <cmr> "rustler; rustlin' your jimmies since 2014"
[18:47:03] <eddyb> cmr: come on...
[18:47:16] <eddyb> that's too close to "rustic - grinding gears since 2013"
[18:47:25] <cmr> heh
[18:47:29] <eddyb> I was going to type that in gimp, stick the rust logo on it
[18:47:33] <eddyb> and load it with VBE
[18:47:54] <eddyb> cmr: months ago
[18:48:01] <eddyb> almost two, to be precise
[18:48:06] <eddyb> what am I doing with my life?
[18:49:36] *** Joins: nate (user@C3BA61EE.F9392C3A.CB3564DC.IP)
[18:51:10] *** Joins: mankyKitty (Instantbir@moz-21AD3B58.rev.sfr.net)
[18:53:04] <steveklabnik> cmr: @indirect on twitter, he's not in this room, just #rust iirc
[18:53:10] <cmr> oh ok
[18:53:30] <steveklabnik> he's been re-doing the matasano crypto stuff in rust
[18:53:45] <steveklabnik> says it's sooo much easier than with 0.5, isn't sure if that's because he's done way more rust or because the language is tha tmuch better
[18:53:48] <steveklabnik> heh 
[18:54:10] <eddyb> the latter I would presume
[18:59:00] *** Quits: brson (brson@moz-5386576F.sd.sd.cox.net) (Ping timeout)
[18:59:29] <sfackler> steveklabnik: that's how I started contributing to Rust! I got annoyed by the extra::base64 API doing the first set of matasano challanges and fixed them
[18:59:45] <sfackler> then kept working on Rust and stopped working on the challanges >_>
[19:00:36] <steveklabnik> :)
[19:01:25] <eddyb> sfackler: oh, so you're addicted like me :D
[19:01:43] <cmr> sfackler: that's exactly why I got involved with rust too.
[19:01:46] <cmr> I also stopped working on them
[19:01:54] <cmr> although I didn't cheat and use extra::base64 :P
[19:01:59] <cmr> didn't you *read* the rules!
[19:03:30] <sfackler> cmr: well, I rewrote almost all of base64 and wrote all of hex so it's not *really* cheating :P
[19:03:41] <cmr> :P
[19:05:17] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: rcirc on GNU Emacs 24.3.1)
[19:05:25] *** Joins: brson (brson@moz-5386576F.sd.sd.cox.net)
[19:05:25] *** ChanServ sets mode: +qo brson brson
[19:05:57] *** Quits: nate (user@C3BA61EE.F9392C3A.CB3564DC.IP) (Ping timeout)
[19:10:22] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[19:10:55] *** Quits: Sharp (Sharp@moz-4D4C136C.dsl.pltn13.sbcglobal.net) (Ping timeout)
[19:17:18] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[19:19:07] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[19:26:25] *** Quits: mankyKitty (Instantbir@moz-21AD3B58.rev.sfr.net) (Quit: mankyKitty)
[19:36:38] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[19:36:38] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/NxNIXg
[19:36:38] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[20:02:49] *** Joins: nate (user@C3BA61EE.F9392C3A.CB3564DC.IP)
[20:06:05] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[20:06:34] *** Quits: nate (user@C3BA61EE.F9392C3A.CB3564DC.IP) (Ping timeout)
[20:14:47] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[20:17:31] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[20:18:43] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[20:19:11] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[20:20:59] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[20:33:07] *** Quits: brson (brson@moz-5386576F.sd.sd.cox.net) (Ping timeout)
[20:36:43] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[20:37:53] <eddyb> dbaupp: a restricted subset of my string builder optimization for formatting seems to be as fast as ~"result"
[20:38:56] *** Joins: nate (user@C3BA61EE.F9392C3A.CB3564DC.IP)
[20:40:20] <eddyb>   invoke void @"Argument$WithString::fmt::h6cfd5367bb5a9062D0aM::v0.0"(%"struct.WithString<&'static str>"* %6, %struct.StrFormat* %f.i, { void ({ i64, %tydesc*, i8*, i8*, i8 }*, %struct.StrFormat*)*, { i64, %tydesc*, i8*, i8*, i8 }* }* %3)
[20:40:36] <eddyb> hmm, why is it not inlining *that* call
[20:41:49] *** Quits: luz (lucy@moz-CD18B14B.customer.cdi.no) (Input/output error)
[20:41:52] <eddyb> strcat: what is SROA?
[20:41:54] *** Joins: luz (lucy@moz-CD18B14B.customer.cdi.no)
[20:42:04] <strcat> scalar replacement of aggregates
[20:42:24] <strcat> but it does other stuff too
[20:42:50] <strcat> eddyb: http://llvm.org/docs/doxygen/html/SROA_8cpp_source.html 3.5k LOC :)
[20:43:15] <eddyb>   %34 = call { i64, i64, [0 x i8] }* @fmt::format::haeb32b60523a15a0ae::v0.9({ i64, %tydesc*, i8*, i8*, i8 }* undef, %"struct.std::fmt::Arguments[#1]"* %__args.i.i.i.i)
[20:43:32] <eddyb> why do I have format! calls in my small implementation :/
[20:43:43] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[20:43:49] <eddyb> oh, of course, .unwrap()
[20:45:54] <eddyb> and all the vector helpers
[20:46:25] <eddyb> strcat: anyways, it seems this has potential, if only for the fact that format!("{}{}", "foo", "bar") is 3 times slower than it needs to be
[20:46:28] <eddyb> good night
[20:47:07] *** Joins: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP)
[20:48:33] *** Quits: eddyb (eddy@EDE07015.D51DAF03.FB866788.IP) (Ping timeout)
[20:56:28] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[20:56:28] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/4w5kag
[20:56:28] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[21:01:39] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[21:01:39] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/UQDVOA
[21:01:39] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[21:01:40] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[21:01:40] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/_MsIpw
[21:01:40] <ghrust> 13rust/06auto 148e9bb34 15Alex Crichton: Fix a pathological const checking case...
[21:01:40] <ghrust> 13rust/06auto 142a17d2f 15bors: auto merge of #11662 : alexcrichton/rust/faster-parens, r=huonw...
[21:01:40] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[21:02:15] *** Quits: new_one (new_one@CCDACABD.439D8424.B3C0173E.IP) (Client exited)
[21:03:05] *** Joins: canhtak (canhtak@moz-46971EF1.wl.t.ulaval.ca)
[21:16:53] *** Quits: nate (user@C3BA61EE.F9392C3A.CB3564DC.IP) (Quit: leaving)
[21:21:34] *** Joins: new_one (new_one@1E1119CE.47460DF6.B3C0173E.IP)
[21:24:05] *** Quits: new_one (new_one@1E1119CE.47460DF6.B3C0173E.IP) (Ping timeout)
[21:31:24] *** Quits: wtw (wtw@moz-D8FB7390.org) (Quit: Lost terminal)
[21:32:11] *** Joins: mankyKitty (Instantbir@moz-21AD3B58.rev.sfr.net)
[21:39:48] *** Joins: new_one (new_one@1E1119CE.47460DF6.B3C0173E.IP)
[21:46:28] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[21:46:28] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/EqtbXw
[21:46:28] <ghrust> 13rust/06auto 14c6123ca 15Alex Crichton: rustuv: Re-work sockaddr glue to not use malloc...
[21:46:28] <ghrust> 13rust/06auto 14b6f6e49 15bors: auto merge of #11636 : alexcrichton/rust/purge-all-the-c, r=brson...
[21:46:28] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[21:47:33] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[21:52:10] <strcat> acrichto: hm, doesn't WaitForMultipleObjectsEx let you do the same stuff as epoll?
[21:53:03] <strcat> The WaitForMultipleObjectsEx function can specify handles of any of the following object types in the lpHandles array:
[21:53:05] <strcat>     Change notification
[21:53:07] <strcat>     Console input
[21:53:09] <strcat>     Event
[21:53:11] <strcat>     Memory resource notification
[21:53:13] <strcat>     Mutex
[21:53:15] <strcat>     Process
[21:53:17] <strcat>     Semaphore
[21:53:19] <strcat>     Thread
[21:53:21] <strcat>     Waitable timer
[21:53:49] <strcat> is what IOCP gives you an Event?
[21:53:58] * strcat doesn't know win32 at all ;[
[21:55:20] *** Quits: mankyKitty (Instantbir@moz-21AD3B58.rev.sfr.net) (Quit: mankyKitty)
[21:57:29] <acrichto> I thought we could use it, and then I think I read something that said the maximum number of objects is like 64
[21:58:16] <acrichto> I'm unsure of how performant it is
[21:58:21] <acrichto> I also know very little about win32 though
[22:02:35] *** Joins: brson (brson@moz-5386576F.sd.sd.cox.net)
[22:02:35] *** ChanServ sets mode: +qo brson brson
[22:05:31] *** Quits: brson (brson@moz-5386576F.sd.sd.cox.net) (Quit: leaving)
[22:07:20] *** Quits: rca_ (rcatolino@moz-18AEB6AE.adsl.proxad.net) (Ping timeout)
[22:17:54] <nrc> acrichto: what do you want to use it for?
[22:17:58] *** Joins: aatch (James@moz-B437F499.pocketrent.com)
[22:18:26] <nrc> I think it is the preferred thing to use on Windows - Chromium use it in their ipc library and we use it in Firefox
[22:18:48] <nrc> where 'it' == WaitForMultipleObjectsEx
[22:19:39] <acrichto> nrc: hm, in theory for an io select() solution, but there are so many problems with select() I dunno..
[22:19:49] <acrichto> sounds like it could be a primitive for building something on top of though
[22:20:52] <nrc> I don't know about select(), but you should prefer WaitForMultipleObjectsEx to WaitMessage if you are wanting to do a basic wait/sleep in windows
[22:21:12] <acrichto> do you know about a limit of objects in WaitForMultipleObjects?
[22:21:22] *** Quits: doener (doener@moz-C68F600D.unity-media.net) (Quit: leaving)
[22:22:26] <nrc> there is a limit, MAXIMUM_WAIT_OBJECTS, and it is not fixed, I think
[22:22:38] <nrc> i.e., can vary between hardware or OSes
[22:22:54] <nrc> sounds like it is 64 in practice from this
[22:22:59] <nrc> http://stackoverflow.com/questions/5131807/is-maximum-wait-objects-really-64
[22:23:33] <acrichto> sounds kinda unfortunate :(
[22:23:36] <nrc> s/OSes/OS versions
[22:24:04] <strcat> nrc: I don't think WaitForMultipleObjects is preferred, but it's a wait to emulate select
[22:24:17] <strcat> the preferred way would be writing it how windows wants you to write it (IOCP ;p)
[22:24:30] <strcat> er
[22:24:31] <strcat> it's a way*
[22:26:10] <nrc> strcat: I know nothing of select(), I meant that if you want to 'sleep' until Windows wakes you up, you ought to use WaitForMultipleObjectsEx rather than WaitMessage - the latter is not safe and can lead to you missing your wakeup call and then just sleeping for ever
[22:29:57] *** Joins: pcwalton (pcwalton@moz-DA87EE4.hsd1.ca.comcast.net)
[22:29:57] *** ChanServ sets mode: +ao pcwalton pcwalton
[22:30:01] <strcat> nrc: ah
[22:48:57] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[22:53:10] *** Quits: canhtak (canhtak@moz-46971EF1.wl.t.ulaval.ca) (Quit: canhtak)
[22:53:23] *** Joins: canhtak (canhtak@moz-46971EF1.wl.t.ulaval.ca)
[22:56:16] <strcat> acrichto: do you think I should include the new ring buffer in that PR? or a separate one
[22:56:21] <strcat> dunno if it should be in libstd anyway
[22:56:41] <strcat> and it'd be weird to have a Deque trait in libstd implemented by one thing ;s
[22:56:42] <acrichto> strcat: let's do that in a separate PR
[22:58:04] <strcat> acrichto: will the mutex in the stdlib guarantee a deadlock? or will it be unsafe to grab it when you own it?
[22:58:14] <strcat> I guess it has to be safe due to MutexArc
[22:58:29] <strcat> safe as in deadlock ;p
[22:59:00] * strcat was wondering if RAII reference objects for MutexArc are a terrible idea or not
[22:59:06] <strcat> they encourage you to use overly large lock scopes
[22:59:19] <strcat> and easy to deadlock 
[22:59:50] <acrichto> haven't thought about it much, right now it doesn't prevent recursive locking and the OSes I've seen all deadlock if yo udo that
[23:01:13] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[23:01:50] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[23:02:42] <strcat> acrichto: well you need to set the type of a pthread mutex to non-default to guarantee deadlock
[23:02:55] <strcat> acrichto: I have a haswell thing to play with and it actually doesn't deadlock
[23:03:00] <strcat> it becomes a no-op sometimes
[23:03:09] <strcat> which is bad
[23:03:46] <strcat> x.lock(); foo(); x.unlock();
[23:03:57] <strcat> where foo calls lock then unlock...
[23:04:06] <strcat> may deadlock, may unlock and then do an undefined unlock
[23:04:23] <strcat> anyway it's a bit sad
[23:04:35] <strcat> because it can't elide the locks if it guarantees it :(
[23:05:27] <strcat> I guess there are other ways...
[23:05:40] <strcat> just not via the POSIX API
[23:06:29] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.2)
[23:06:31] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[23:06:31] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/EqtbXw
[23:06:31] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[23:10:11] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[23:11:28] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[23:11:29] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/2TVMGQ
[23:11:29] <ghrust> 13rust/06auto 14c62ef2e 15Alex Crichton: Fix cross-compiled pretty tests...
[23:11:29] <ghrust> 13rust/06auto 14bf3743c 15bors: auto merge of #11675 : alexcrichton/rust/fix-snap, r=cmr...
[23:11:29] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[23:12:59] <dbaupp> acrichto: ping
[23:13:55] <acrichto> dbaupp: pong
[23:14:01] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[23:14:01] <ghrust> 01[13rust01] 15alexcrichton merged 06auto into 06snap-stage3: 02http://git.io/U4OdIQ
[23:14:01] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[23:14:16] <dbaupp> acrichto: do you remember why we export all traits? (even completely private ones)
[23:14:34] <acrichto> dbaupp: you can expose private traits through things like function bounds
[23:14:40] <acrichto> lemme find the issue real quick
[23:15:08] <acrichto> https://github.com/mozilla/rust/issues/11225
[23:15:35] <acrichto> we basically don't walk function signatures
[23:16:13] *** Quits: canhtak (canhtak@moz-46971EF1.wl.t.ulaval.ca) (Quit: canhtak)
[23:16:14] <dbaupp> ah, ok
[23:16:38] <dbaupp> looks like I can't handle that case properly, then. :(
[23:16:48] <acrichto> yeah it does make me a little sad :(
[23:16:59] <acrichto> it's not the worst thing in the world right now though
[23:20:33] <sfackler> It does cause the missing_doc lint to spaz out
[23:20:50] <acrichto> true
[23:22:00] <sfackler> though it seems to me that making missing_doc work is a lot easier than figuring out if a trait needs to be exported
[23:23:07] <acrichto> well arguably they all do need to be documented
[23:23:18] <acrichto> pub fn foo<T: Trait>() {}
[23:23:21] <acrichto> if that's a private trait
[23:23:29] <acrichto> you'd still want documentation about it to figure out what implements it
[23:23:57] <sfackler> sure
[23:24:16] <sfackler> or forbid Trait from being private in foo
[23:24:56] <aatch> That's basically what C# does.
[23:25:42] <sfackler> imo, if a trait is exposed to a user in any way it should have to be public
[23:25:57] *** Joins: canhtak (canhtak@moz-46971EF1.wl.t.ulaval.ca)
[23:26:30] <acrichto> it's kinda all lumped into the discusion of what to do with priv structs
[23:26:31] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[23:26:31] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14bf3743c to 14b6f6e49: 02http://git.io/N3iJvQ
[23:26:31] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[23:26:37] <sfackler> yeah
[23:27:20] <sfackler> I think the policy in general is that if it's private, then it should be as if it didn't exist from the outside-of-the-crate perspective
[23:27:50] <sfackler> er, the policy should be that
[23:27:54] <acrichto> is that a decidable problem though with reexports?
[23:28:12] <sfackler> I would hope so, right?
[23:28:21] <acrichto> I suppose it should be
[23:28:28] <sfackler> a Visitor scan should be able to figure out all public things
[23:28:44] <dbaupp> I'm not sure that it's obvious that traits should be public to be in public signatures: since you may wish to use a trait object as a PIMPL-style object, or a have a "closed" class of generic things (both of these require a private trait)
[23:30:28] <dbaupp> (the first has a work around like `pub struct TraitWrapper { priv x: ~PrivateTrait }`, but I can't think of a work-around for the latter.)
[23:32:29] <sfackler> I'm not super concerned about the second case personally. #[doc(hidden)] will get you a lot of the way imo
[23:36:23] <dbaupp> I guess so
[23:38:02] <sfackler> we could even add some sort of #[internal_only] annotation to warn when using it outside the crate
[23:56:51] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[23:57:19] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[23:59:08] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)

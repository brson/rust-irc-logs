[00:00:00] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[00:00:08] *** Quits: KindOne (KindOne@moz-4C3F5651.dynamic.ip.windstream.net) (Ping timeout)
[00:00:39] <mark_edward> cmr, i thought the reason languages like C# and Java had good GC while C++ doesn't is because the Java/C# garbage collectors get way more info?
[00:01:09] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Client exited)
[00:01:41] <cmr> mark_edward: that has nothing to do with notification when the reference is copied/destroyed
[00:02:16] *** Quits: quvarxa (chatzilla@moz-978E4C31.static.tpgi.com.au) (Ping timeout)
[00:02:27] <brson> cmr: thanks for the comprehensive twir this week
[00:02:32] <mark_edward> cmr, oh okay, do you know why it is then?
[00:02:59] <cmr> mark_edward: mostly it has to do with knowing where references are, and what type they point do.
[00:03:07] <cmr> brson: np
[00:03:11] *** Joins: quvarxa (chatzilla@moz-978E4C31.static.tpgi.com.au)
[00:03:22] <mark_edward> cmr, will Rust GC's have that knowledge?
[00:03:26] *** Quits: mib_hhtfjx (Mibbit@moz-3213C615.wavecable.com) (Quit: http://www.mibbit.com ajax IRC Client)
[00:03:26] <mark_edward> *be able to
[00:03:44] <cmr> mark_edward: ask nmatsakis and pnkfelix when they're around, they've been doing all the thinking on GC
[00:04:16] <mark_edward> cmr, okay thanks\
[00:04:27] <heftig> by the way, does rust already have a map with weak keys?
[00:04:29] *** Joins: KindOne (KindOne@moz-4C3F5651.dynamic.ip.windstream.net)
[00:04:30] <mark_edward> nmatsakis, ping
[00:04:47] <strcat> heftig: weak keys? as in gc weak refs?
[00:04:51] <heftig> yes
[00:04:53] <strcat> it doesn't have a gc, so it doesn't have any gc features
[00:05:10] <strcat> heftig: I have a feeling it wouldn't require a map type, though
[00:05:10] <heftig> ah, okay, guess i was mistaken about @
[00:05:22] <strcat> heftig: @ is just a sub-par refcounting implementation
[00:05:30] <heftig> strcat: no, it's a data structure useful for caches
[00:05:37] <strcat> (and is no longer part of the stable language definition)
[00:05:45] <heftig> values are owned but keys are not. if keys get garbage collected, so do the values
[00:05:55] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Client exited)
[00:05:59] <strcat> heftig: ah
[00:06:27] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[00:06:36] *** Joins: dew1 (Instantbir@moz-E4452B8F.static.stls.mo.charter.com)
[00:06:50] <strcat> heftig: at one point there was a precise gc in-tree
[00:06:53] <strcat> and it could be switched on
[00:06:54] *** Quits: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com) (Ping timeout)
[00:07:12] <strcat> and there was a cycle collector for @, but that's gone and replaced by destroying at the end of a task
[00:07:21] *** Quits: sprang (sprang@moz-920A95C4.hsd1.ca.comcast.net) (Quit: sprang)
[00:07:30] <strcat> anyway there will be a Gc<T> type with a tracing gc but it's totally unimplemented
[00:08:12] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[00:09:40] *** Joins: tulloch (tulloch@moz-1C33A2E7.nat.csx.cam.ac.uk)
[00:11:06] <benh> Any plans to use the @ token for something else? Besides as-patterns I guess, are they still there?
[00:11:15] *** Joins: bungoman (bungoman@moz-F95B490C.tx.res.rr.com)
[00:13:26] *** Quits: bjz (bjz@moz-6AF19015.lnse4.cha.bigpond.net.au) (Ping timeout)
[00:20:58] <brson> benh: possibly replace # in attributes
[00:22:32] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[00:24:02] *** Joins: dbaupp (Thunderbir@29619B56.D5A1DCF.37681C44.IP)
[00:25:50] *** Joins: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz)
[00:25:52] *** Joins: SingingBoyo (brandon@DA28FB90.A5D0D593.4F048BDC.IP)
[00:27:47] *** Quits: jordyd (jordyd@7DAC4ACE.77F880E0.D9401097.IP) (Ping timeout)
[00:27:57] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[00:28:37] *** Quits: jdm (jdm@moz-C9C12F65.dynamic.hinet.net) (Quit: Lost terminal)
[00:29:09] *** Joins: jordyd (jordyd@7DAC4ACE.77F880E0.D9401097.IP)
[00:30:22] *** Quits: SingingBoyo (brandon@DA28FB90.A5D0D593.4F048BDC.IP) (Ping timeout)
[00:32:38] *** Quits: jordyd (jordyd@7DAC4ACE.77F880E0.D9401097.IP) (Quit: Leaving)
[00:34:33] <geomyidae> is it possible to do codegen type stuff within the build confines of rustpkg?
[00:37:08] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[00:38:58] *** Quits: tulloch (tulloch@moz-1C33A2E7.nat.csx.cam.ac.uk) (Ping timeout)
[00:40:31] *** Joins: tulloch (tulloch@moz-1C33A2E7.nat.csx.cam.ac.uk)
[00:40:38] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[00:41:40] *** Quits: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net) (Ping timeout)
[00:44:47] <dcrewi> geomyidae: it looks like rustpkg doesn't fork and exec rustc
[00:44:53] <dcrewi> geomyidae: if that's your question?
[00:45:47] <cmr> geomyidae: it should be possible with a pkg.rs, though I don't think anyone has seriously tried yet
[00:46:09] *** Quits: vodik (simon@moz-FD4ADBC6.cable.teksavvy.com) (Ping timeout)
[00:46:23] *** Joins: vodik (simon@moz-FD4ADBC6.cable.teksavvy.com)
[00:46:23] <dcrewi> oh
[00:52:27] *** Quits: jeffdb_ (jeff@moz-ED35AD97.hsd1.ca.comcast.net) (Quit: jeffdb_)
[00:53:20] *** Joins: jeffdb_ (jeff@moz-ED35AD97.hsd1.ca.comcast.net)
[00:53:52] *** Quits: carter (carter@moz-F3C2A2D8.nycmny.fios.verizon.net) (Quit: Textual IRC Client: www.textualapp.com)
[00:58:32] *** Joins: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP)
[00:59:26] *** Quits: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net) (Ping timeout)
[00:59:34] *** Joins: japaric (japaric@EEA8F44E.83887C3F.5C7588CA.IP)
[01:04:44] *** Joins: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net)
[01:05:34] *** Quits: japaric (japaric@EEA8F44E.83887C3F.5C7588CA.IP) (Quit: WeeChat 0.4.2)
[01:05:37] *** Joins: lfox (lfox@C5428AB8.4C3BA601.ECED8BE3.IP)
[01:06:59] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[01:07:49] <Amaranth> cmr: Last time I tried it (for rust-sdl2) it seemed like pkg.rs was really useless
[01:08:00] <Amaranth> You couldn't even emulate a normal rustpkg build with it
[01:08:23] <cmr> Amaranth: how long ago?
[01:08:36] *** Quits: nsf (nsf@moz-EEF3238A.convex.ru) (Quit: WeeChat 0.4.2)
[01:08:55] <Amaranth> Wanna say 2 months ago now so hopefully it is better
[01:12:04] *** Joins: sprang (sprang@moz-920A95C4.hsd1.ca.comcast.net)
[01:12:26] *** Joins: bjz (bjz@moz-6AF19015.lnse4.cha.bigpond.net.au)
[01:14:32] *** Quits: bjz (bjz@moz-6AF19015.lnse4.cha.bigpond.net.au) (Ping timeout)
[01:14:36] *** Joins: m_kato (m_kato@moz-C286AD9A.bitcat.net)
[01:15:02] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Ping timeout)
[01:15:32] *** Joins: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net)
[01:15:36] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[01:20:30] *** kimundi is now known as zz_kimundi
[01:20:34] *** Quits: Sgeo (quassel@moz-D0F30617.dyn.optonline.net) (Ping timeout)
[01:20:38] *** Joins: Sgeo (quassel@moz-D0F30617.dyn.optonline.net)
[01:20:50] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[01:22:07] *** Quits: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net) (Quit: Sharp)
[01:24:34] <sfackler> is it possible to pattern match on an owned vector?
[01:25:01] <strcat> sfackler: it borrows it to a slice, so yes
[01:25:17] <sfackler> e.g. let x = ~[10]; match x { ~[x] => x, _ => ... }
[01:25:24] <sfackler> will it move out?
[01:25:53] <strcat> that's not supported
[01:25:54] *** Joins: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net)
[01:26:10] <strcat> and won't be afaik. it's not efficient in the general case
[01:26:17] <sfackler> ok
[01:26:47] *** Quits: donri (donri@moz-9BB61102.tbcn.telia.com) (Client exited)
[01:27:09] *** Joins: bjz (bjz@moz-6AF19015.lnse4.cha.bigpond.net.au)
[01:29:10] <dbaupp> sfackler: it is supported
[01:29:28] <dbaupp> rusti: match ~[~"foo"] { [s] => s, _ => ~"bar" }
[01:29:29] -rusti- ~"foo"
[01:29:46] <dbaupp> rusti: match ~[~"foo", ~"baz"] { [s] => s, _ => ~"bar" }
[01:29:47] -rusti- ~"bar"
[01:29:51] <sfackler> cool
[01:30:03] <sfackler> I was expecting the pattern syntax to be ~[s] instead of [s]
[01:30:04] <dbaupp> strcat: stop spreading lies :P
[01:30:22] <strcat> dbaupp: I think it's buggy, then
[01:30:38] <dbaupp> strcat: example?
[01:30:46] <strcat> because the trans code definitely doesn't handle that right
[01:30:51] <dbaupp> ah, ok.
[01:30:52] <strcat> dbaupp: I'll make one
[01:31:38] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Ping timeout)
[01:34:57] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[01:35:05] *** Joins: zmthy (tim@moz-C2881CC3.ecs.vuw.ac.nz)
[01:37:58] <sam113101> when it says
[01:38:09] <sam113101> llvm[3]: Compiling something.cpp
[01:38:14] <sam113101> is it compiling llvm?
[01:38:18] <strcat> yes
[01:38:25] <sam113101> shit
[01:38:29] <sam113101> everytime man
[01:38:56] <sam113101> every goddamn time
[01:38:56] <sam113101> and it takes forever
[01:38:57] <strcat> the last rust LLVM update was in september
[01:39:09] <sam113101> there's something wrong then
[01:39:21] <sam113101> I do
[01:39:24] <sam113101> git pull
[01:39:28] <sam113101> ./configure
[01:39:31] <sam113101> make
[01:39:35] <sam113101> sudo make install
[01:39:58] <sam113101> is it supposed to recompile llvm although it hasn't been updated?
[01:40:09] <strcat> no
[01:40:12] <strcat> doesn't do it here
[01:40:17] <sam113101> (  .____.) 
[01:40:17] *** Quits: tulloch (tulloch@moz-1C33A2E7.nat.csx.cam.ac.uk) (Ping timeout)
[01:40:31] <cmr> or here
[01:41:04] <Amaranth> Rust is moving to upstream llvm now that segmented stacks are gone, right?
[01:41:26] <Amaranth> I remember someone mentioning there was only one other patch and that was a fix for an ICE that might not be a problem anymore
[01:41:41] <sam113101> ICE?
[01:41:45] <sam113101> what does it mean
[01:41:49] <cmr> internal compiler error
[01:42:14] <bjz> ICE = fun fun
[01:43:13] <cmr> I love it when the test suite catches a legitimate error in my code.
[01:43:57] *** Quits: sindork (sindork@ABFA98AB.DD47BB48.F7A44A1B.IP) (Ping timeout)
[01:44:06] *** Quits: reyre (reyre@moz-89E9865B.com) (Ping timeout)
[01:44:06] *** Quits: nonehaxor (nonehaxor@BA9CBAE.4C3B0355.EE6E63A5.IP) (Ping timeout)
[01:44:19] *** Quits: xymostech (xymostech@22A34502.AFC2BCFF.2CFD4520.IP) (Ping timeout)
[01:44:19] *** Quits: callen (callen@95EE74F7.F6EF2525.EE6E63A5.IP) (Ping timeout)
[01:44:27] *** Quits: kemurphy (kemurphy@3863AC20.C4E71399.9510F13D.IP) (Ping timeout)
[01:44:57] <bjz> cmr: like what?
[01:45:29] <cmr> bjz: well this specific one was an unwrap in a fix for https://github.com/mozilla/rust/issues/10636
[01:45:48] <cmr> assumed there was an unclosed delimiter when the incorrect close delimiter was found, when that's not true
[01:46:07] <bjz> ah
[01:47:16] *** Quits: negge (unlord@moz-5BD795E6.hsd1.va.comcast.net) (Ping timeout)
[01:47:47] *** Quits: brson (brson@EDE430AA.CB84766B.D1E74241.IP) (Ping timeout)
[01:48:51] <strcat> Amaranth: https://github.com/alexcrichton/llvm/commits/rust-llvm-2013-11-18
[01:49:07] <strcat> so yeah, close to vanilla LLVM
[01:49:15] <strcat> but it will still be a very specific version of LLVM
[01:49:36] <strcat> LLVM doesn't do stable releases with backported fixes atm
[01:51:55] *** Quits: KindOne (KindOne@moz-4C3F5651.dynamic.ip.windstream.net) (Ping timeout)
[01:51:57] *** Joins: SingingBoyo (brandon@DA28FB90.A5D0D593.4F048BDC.IP)
[01:51:59] *** Quits: Florob (Florob@moz-39532932.de) (Client exited)
[01:52:08] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[01:52:08] *** ChanServ sets mode: +ao brson brson
[01:55:41] *** Joins: KindOne (KindOne@A1D7C168.35741547.34F73994.IP)
[01:56:46] *** Joins: canhtak (canhtak@moz-6F820ACE.wl.t.ulaval.ca)
[01:58:33] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.2)
[01:59:10] *** Quits: tikue (quassel@moz-FEADCD38.hsd1.pa.comcast.net) (Connection reset by peer)
[01:59:31] *** Quits: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz) (Quit: Busying myself...)
[02:02:06] <o11c> there was discussion about it for the last couple releases though
[02:02:11] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[02:02:37] *** Quits: ricepuddin (graham@moz-7D68765A.cable.virginm.net) (Ping timeout)
[02:03:49] *** Joins: fabiand__ (fabiand@moz-742359A2.adsl.alicedsl.de)
[02:03:53] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[02:04:53] *** Quits: fabiand_ (fabiand@moz-4D0935A3.adsl.alicedsl.de) (Ping timeout)
[02:05:21] <bjz> so for callbacks, it is better to use traits now?
[02:06:52] <cmr> bjz: yes
[02:09:02] <bjz> cmr: do you remember reading a ML post on it? or was it a blog post? recently?
[02:09:12] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[02:09:12] <bjz> I seem to remember one with an example
[02:09:25] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[02:10:35] <cmr> I remember acrichto talking about they handled it in the runtime :p
[02:13:23] *** Quits: doomlord_ (servitor@moz-4625DF14.range86-184.btcentralplus.com) (Ping timeout)
[02:13:32] *** Joins: tulloch (tulloch@moz-1C33A2E7.nat.csx.cam.ac.uk)
[02:14:12] *** Joins: doomlord_ (servitor@moz-9738D381.range86-160.btcentralplus.com)
[02:17:31] *** Quits: Jesse (jruderman@moz-2ECEC9F7.oc.oc.cox.net) (Quit: Jesse)
[02:18:17] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[02:19:00] *** Joins: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz)
[02:20:59] *** Quits: dbaupp (Thunderbir@29619B56.D5A1DCF.37681C44.IP) (Ping timeout)
[02:23:00] *** Joins: kemurphy (kemurphy@3863AC20.C4E71399.9510F13D.IP)
[02:23:18] *** Joins: sindork (sindork@ABFA98AB.DD47BB48.F7A44A1B.IP)
[02:23:27] *** Joins: Jesse (jruderman@moz-2ECEC9F7.oc.oc.cox.net)
[02:25:04] *** Joins: boredomist (ruqs@B16F530C.DC641F2C.BCAEBB33.IP)
[02:25:31] *** Joins: tikue (quassel@moz-FEADCD38.hsd1.pa.comcast.net)
[02:26:55] *** Quits: SirSkidmore (taylor@moz-F145A866.com) (Ping timeout)
[02:27:25] <brson> yichoi: still trying to get android emulator running on an ec2 instance
[02:27:39] <brson> yichoi: when i start the emulator with `emulator @test -no-window` i see
[02:27:43] <brson> "Failed to Initialize backend EGL display"
[02:27:51] <brson> and "emulator: WARNING: Could not initialize OpenglES emulation, using software renderer."
[02:28:01] <brson> and it never shows up under adb devices
[02:28:25] *** Joins: dbaupp (Thunderbir@29619B56.D5A1DCF.37681C44.IP)
[02:28:33] <brson> presumably this is a problem unique to headless linux boxes. trying to figure out how to get around it
[02:29:53] *** Joins: SirSkidmore (taylor@moz-F145A866.com)
[02:33:04] *** Quits: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[02:33:37] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[02:33:54] *** Joins: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP)
[02:34:32] *** Quits: Jesse (jruderman@moz-2ECEC9F7.oc.oc.cox.net) (Quit: Jesse)
[02:37:52] *** Quits: moostik (Icedove@moz-63ED7231.w82-121.abo.wanadoo.fr) (Ping timeout)
[02:44:53] *** Quits: tulloch (tulloch@moz-1C33A2E7.nat.csx.cam.ac.uk) (Ping timeout)
[02:45:26] *** Quits: SirSkidmore (taylor@moz-F145A866.com) (Ping timeout)
[02:45:37] *** Quits: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net) (Quit: Sharp)
[02:45:38] *** Joins: SirSkidmore (taylor@moz-F145A866.com)
[02:48:08] *** Joins: axitkhurana (Adium@99E9E697.E0AEE314.6AA50C35.IP)
[02:48:17] *** jorendorff_away is now known as jorendorff
[02:49:13] *** Joins: recrack (Mibbit@B4104EBB.3CC170B1.1E14B209.IP)
[02:50:01] *** Joins: mib_cjj0bb (Mibbit@BB72E0BC.CB03F033.3126E16B.IP)
[02:50:21] *** Quits: mib_cjj0bb (Mibbit@BB72E0BC.CB03F033.3126E16B.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[02:50:47] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Quit: Gone to save the world!)
[02:51:17] <geomyidae> o_0 d3cap includes a prototype websocket server? If I didn't already think it was cool...
[02:52:17] *** Quits: SirSkidmore (taylor@moz-F145A866.com) (Ping timeout)
[02:52:39] *** Joins: refold (gman@moz-42D68426.a258.priv.bahnhof.se)
[02:57:32] *** Quits: rhodesd (none@3646D136.4C5731DA.F395EA5B.IP) (Ping timeout)
[02:57:49] *** Quits: lfox (lfox@C5428AB8.4C3BA601.ECED8BE3.IP) (Quit: )
[02:58:21] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[02:58:39] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Client exited)
[02:58:40] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[02:59:25] *** Joins: lfox (lfox@C5428AB8.4C3BA601.ECED8BE3.IP)
[03:00:09] *** Joins: SirSkidmore (taylor@moz-F145A866.com)
[03:00:41] <bjz> brson: will there be an equivalent of .finally for proc?
[03:00:59] <bjz> or 'should' there be?
[03:01:11] *** Joins: tikue_ (tkuehn@7101C711.2ACBBF24.689607DE.IP)
[03:02:02] *** Quits: SirSkidmore (taylor@moz-F145A866.com) (Ping timeout)
[03:02:14] *** Joins: SirSkidmore (taylor@moz-F145A866.com)
[03:02:31] <brson> bjz: i haven't thought about it. there used to be though
[03:02:52] <bjz> brson: there's one fo extern "Rust" fn() -> T
[03:02:56] <bjz> *for
[03:03:13] *** Joins: rhodesd (none@3646D136.4C5731DA.F395EA5B.IP)
[03:03:14] *** Quits: Kingsley (kingsley@9B172CBE.BEA5C56D.DF4B730F.IP) (Quit: Leaving.)
[03:04:06] <bjz> brson: must have changed with the closure changes
[03:05:24] *** Quits: SirSkidmore (taylor@moz-F145A866.com) (Ping timeout)
[03:05:36] *** Joins: SirSkidmore (taylor@moz-F145A866.com)
[03:07:16] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[03:08:17] *** Quits: SirSkidmore (taylor@moz-F145A866.com) (Ping timeout)
[03:08:29] *** Joins: SirSkidmore (taylor@moz-F145A866.com)
[03:10:22] *** Quits: axitkhurana (Adium@99E9E697.E0AEE314.6AA50C35.IP) (Quit: Leaving.)
[03:10:29] <bjz> rusti: fn call<T>(f: proc() -> T) -> T { f() } call(|| 2)
[03:10:29] -rusti- <anon>:9:27: 9:28 error: expected `,` but found `(`
[03:10:29] -rusti- <anon>:9          fn call<T>(f: proc() -> T) -> T { f() } call(|| 2)
[03:10:29] -rusti-                                     ^
[03:10:29] -rusti- application terminated with error code 101
[03:10:40] <cmr> rusti: version
[03:10:42] -rusti- "rustc 0.8"
[03:10:47] <bjz> oh
[03:10:49] <bjz> ha
[03:10:55] *** Joins: jfbk (jfbk@moz-EEA9CFB3.nyc.res.rr.com)
[03:10:59] *** Quits: SingingBoyo (brandon@DA28FB90.A5D0D593.4F048BDC.IP) (Quit: Lost terminal)
[03:11:16] *** Quits: jfbk (jfbk@moz-EEA9CFB3.nyc.res.rr.com) (Quit: )
[03:12:18] <brson> yichoi: i don't think i'm going to figure out how to get the emulator working on ec2 tonight
[03:12:23] *** Joins: Kingsley (kingsley@9B172CBE.BEA5C56D.DF4B730F.IP)
[03:12:28] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Ping timeout)
[03:14:11] *** Joins: tulloch (tulloch@moz-1C33A2E7.nat.csx.cam.ac.uk)
[03:14:31] *** Joins: japaric (japaric@EEA8F44E.83887C3F.5C7588CA.IP)
[03:17:17] <bjz> is `link(name = "glfw")` now link(package_id = "glfw")?
[03:17:44] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[03:18:56] <bjz> oh, seems you need both
[03:19:03] <bjz> what is package_id for?
[03:19:15] *** Quits: Soft (soft@moz-EC8D39F.yok.fi) (Ping timeout)
[03:19:21] *** Joins: ross (ross@moz-5EA04060.br.br.cox.net)
[03:19:29] *** Joins: Soft (soft@moz-EC8D39F.yok.fi)
[03:20:09] *** Quits: SirSkidmore (taylor@moz-F145A866.com) (Ping timeout)
[03:20:38] *** Quits: Dessimat0r (Dessimat0r@E879B262.8D4FD984.4320F744.IP) (Ping timeout)
[03:21:12] *** Quits: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[03:21:21] *** Joins: SirSkidmore (taylor@moz-F145A866.com)
[03:22:45] *** Quits: rhodesd (none@3646D136.4C5731DA.F395EA5B.IP) (Ping timeout)
[03:24:00] *** Quits: SirSkidmore (taylor@moz-F145A866.com) (Ping timeout)
[03:24:12] *** Joins: SirSkidmore (taylor@moz-F145A866.com)
[03:24:54] *** Joins: GeneralMaximus (ankur@2B9456D9.591B27D3.D5D59AD9.IP)
[03:24:55] *** Quits: GeneralMaximus (ankur@2B9456D9.591B27D3.D5D59AD9.IP) (Client exited)
[03:26:15] *** Quits: zz_kimundi (kimundi@moz-7ED39474.dip0.t-ipconnect.de) (Ping timeout)
[03:26:25] *** Quits: quvarxa (chatzilla@moz-978E4C31.static.tpgi.com.au) (Ping timeout)
[03:26:57] *** Joins: quvarxa (chatzilla@moz-978E4C31.static.tpgi.com.au)
[03:28:16] *** Quits: Kingsley (kingsley@9B172CBE.BEA5C56D.DF4B730F.IP) (Quit: Leaving.)
[03:28:24] *** Quits: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz) (Quit: Busying myself...)
[03:28:26] *** Joins: rhodesd (none@3646D136.4C5731DA.F395EA5B.IP)
[03:28:53] *** Quits: sp3d (s@6361F3B1.19CD1E54.8354FB35.IP) (Ping timeout)
[03:29:07] *** Joins: zz_kimundi (kimundi@moz-55BB9741.dip0.t-ipconnect.de)
[03:29:36] *** zz_kimundi is now known as kimundi
[03:30:12] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[03:33:29] *** Quits: SirSkidmore (taylor@moz-F145A866.com) (Ping timeout)
[03:33:35] *** Joins: Kingsley (kingsley@9B172CBE.BEA5C56D.DF4B730F.IP)
[03:33:42] *** Joins: SirSkidmore (taylor@moz-F145A866.com)
[03:35:03] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[03:36:27] *** Quits: SirSkidmore (taylor@moz-F145A866.com) (Ping timeout)
[03:38:59] *** Joins: SirSkidmore (taylor@moz-F145A866.com)
[03:43:16] *** Joins: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au)
[03:45:32] *** Quits: tulloch (tulloch@moz-1C33A2E7.nat.csx.cam.ac.uk) (Ping timeout)
[03:48:15] *** Joins: Dessimat0r (Dessimat0r@E879B262.8D4FD984.4320F744.IP)
[03:49:16] *** jorendorff is now known as jorendorff_away
[03:55:39] *** Joins: pepper_chico (pepper_chi@moz-F895CB32.dsl.telesp.net.br)
[04:00:05] *** Joins: dherman_ (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[04:00:41] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[04:01:55] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[04:03:24] *** Quits: dherman_ (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman_)
[04:03:38] *** Joins: adu (ajr@moz-47946E69.washdc.fios.verizon.net)
[04:05:32] *** Quits: Kingsley (kingsley@9B172CBE.BEA5C56D.DF4B730F.IP) (Quit: Leaving.)
[04:10:42] *** jorendorff_away is now known as jorendorff
[04:14:11] *** Joins: tulloch (tulloch@moz-1C33A2E7.nat.csx.cam.ac.uk)
[04:14:49] *** Quits: Earnestly (earnest@38FE72A5.82423D8F.BFD1ABFD.IP) (Ping timeout)
[04:15:43] *** Quits: Dessimat0r (Dessimat0r@E879B262.8D4FD984.4320F744.IP) (Ping timeout)
[04:15:43] *** Quits: engla (engla@moz-F64E1B0F.cust.bredbandsbolaget.se) (Ping timeout)
[04:16:00] *** Joins: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP)
[04:17:34] *** Joins: carter (carter@moz-F3C2A2D8.nycmny.fios.verizon.net)
[04:18:00] *** Quits: lfox (lfox@C5428AB8.4C3BA601.ECED8BE3.IP) (Quit: ZZZzzz…)
[04:26:22] *** Joins: jlong (jlong@moz-6DFDE846.socal.res.rr.com)
[04:26:36] *** Joins: jdm (jdm@579FEC0E.387F1B30.1A7D5C28.IP)
[04:26:36] *** ChanServ sets mode: +o jdm
[04:27:44] *** Quits: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au) (Quit: gavinb)
[04:28:10] *** Quits: pepper_chico (pepper_chi@moz-F895CB32.dsl.telesp.net.br) (Quit: Ex-Chat)
[04:29:09] *** Joins: Kingsley (kingsley@9B172CBE.BEA5C56D.DF4B730F.IP)
[04:30:06] <mark_edward> i'm trying to debug my code... and idea what std::io::File::write would look like all mangled? I want to break on it
[04:30:41] <cmr> mark_edward: you should be able to break on std::io::File::write
[04:30:55] <mark_edward> ok, thanks
[04:32:07] <mark_edward> cmr, std::io::File::write, and std::io::fs::File::write are giving me undefined symbol errors
[04:32:15] <mark_edward> s/errors/warnings/
[04:32:35] <dbaupp> mark_edward: isn't write from a triat?
[04:32:37] <dbaupp> *trait
[04:33:53] *** Joins: Jesse (jruderman@moz-2ECEC9F7.oc.oc.cox.net)
[04:34:19] *** Joins: D (d@8B60F2EF.89F3C8E3.A9905320.IP)
[04:34:34] *** Quits: D (d@8B60F2EF.89F3C8E3.A9905320.IP) (Quit: )
[04:36:27] <mark_edward> dbaupp, what does that mean for breaking it?
[04:41:11] <dbaupp> mark_edward: that it will never be 'std::io::File::write', since the method is associated with the trait too, so that appears in the name somewhere
[04:41:29] <mark_edward> does anyone know how to break on such things?
[04:42:47] *** Quits: maxli (maxli@moz-4D28BA20.student.cs.uwaterloo.ca) (Quit: Leaving.)
[04:44:13] *** Joins: maxli (maxli@moz-4D28BA20.student.cs.uwaterloo.ca)
[04:45:06] *** Quits: maxli (maxli@moz-4D28BA20.student.cs.uwaterloo.ca) (Quit: Leaving.)
[04:45:30] *** Quits: tulloch (tulloch@moz-1C33A2E7.nat.csx.cam.ac.uk) (Ping timeout)
[04:45:58] *** Joins: posco (sid14832@moz-5F4AA75A.irccloud.com)
[04:45:59] <dbaupp> mark_edward: if you're on linux, you can find the .so file and run `nm libstd-....so | grep 'Writer$File'` to find all the methods from `impl Writer for File`,and then just copy the write symbol.
[04:46:12] <mark_edward> dbaupp, thanks
[04:46:13] <dbaupp> I'd guess there's a better way :P
[04:46:23] <mark_edward> dbaupp, wait, which .so file
[04:46:28] <mark_edward> eoh nbm
[04:46:34] <mark_edward> *oh nvm
[04:48:31] *** Quits: carter (carter@moz-F3C2A2D8.nycmny.fios.verizon.net) (Quit: Textual IRC Client: www.textualapp.com)
[04:48:59] *** Quits: Krymise (Nietzsche@moz-CA789EF5.nwrknj.fios.verizon.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[04:50:55] *** Joins: devbug (quassel@23AC5F12.9D950176.3655BBF5.IP)
[04:52:59] <tedh> you can do that from with gdb with: info func Writer
[04:53:05] <mark_edward> dbaupp, /usr/lib/rust/rust-nightly/lib/rustc/x86_64-unknown-linux-gnu/lib/libstd-6425b930ca146ae9-0.9-pre.so defines no symbols according to nm
[04:54:11] *** Quits: devbug (quassel@23AC5F12.9D950176.3655BBF5.IP) (Ping timeout)
[04:54:21] <mark_edward> tedh, thanks!
[04:54:41] *** Quits: Sorella (quildreen@9D963F5D.DF5D8AE7.54BCAB54.IP) (Ping timeout)
[04:57:25] *** Joins: eholk (eholk@C95FAD69.A304C61F.3ED9AD7C.IP)
[04:59:34] *** Joins: Dessimat0r (Dessimat0r@E879B262.8D4FD984.4320F744.IP)
[04:59:52] *** Joins: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au)
[05:01:16] <gavinb> So what is the canonical way to choose a revision of master to build? HEAD is failing with massive linker errors on Mac, and I've tried taking a few different green builds from the list on the buildbot grid, to no avail.
[05:01:40] *** Quits: adu (ajr@moz-47946E69.washdc.fios.verizon.net) (Quit: adu)
[05:03:36] <sfackler> HEAD should theoretically always build
[05:03:49] *** Joins: adu (ajr@moz-47946E69.washdc.fios.verizon.net)
[05:03:56] <sfackler> commits are run though tests on a bunch of platforms before they merge
[05:04:51] *** Joins: eddyb (eddy@336E3A7F.D51DAF03.FB866788.IP)
[05:05:08] <bjz> gavinb: try doing a full reabuild of HEAD
[05:05:32] <gavinb> I did a 'make clean' before. Is that not sufficient?
[05:05:48] <klutzy> it doesn't clean llvm, but it would be sufficient for usual cases
[05:06:05] <gavinb> Ah, that might be it. The linker error seemed to be in part of LLVM...
[05:06:19] <bjz> yeah, sounds like it
[05:06:37] <bjz> it's a pain to have to rebuild llvm, but that might fix it for you
[05:06:49] <klutzy> to clean llvm.. make clean-llvm? make llvm-clean? I forgot which one is right
[05:07:31] *** jorendorff is now known as jorendorff_away
[05:08:17] <gavinb> thanks, will try that
[05:08:44] *** Quits: Jesse (jruderman@moz-2ECEC9F7.oc.oc.cox.net) (Quit: Jesse)
[05:10:45] <posco> I'm surprised I can make a param mut in a trait where the base is not mut.
[05:10:59] <posco> Is that intentional?
[05:11:28] <sfackler> is it a reference or by value?
[05:12:11] <posco> sfackler: I'm a newb with rust, but it is: mut that: ~int
[05:12:23] <sfackler> that's intentional
[05:12:39] <sfackler> that method takes ownership of 'that', so it can do whatever it wants with it
[05:13:01] <posco> okay, so it would not have been okay with mut that: &int
[05:13:18] <dbaupp> posco: no, that's ok too
[05:13:37] <sfackler> that would be fine as well, since mut in that spot just means that you can reassign 'that' to a different borrowed pointer
[05:13:50] <sfackler> going from "that: &int" to "that: &mut int" wouldn't be okay though
[05:13:57] <dbaupp> `fn foo(&self, mut x: Type) { ... }` is basically the same as `fn foo(&self, tmp: Type) { let mut x = tmp; ... }`
[05:13:57] <posco> so that is weird.
[05:14:09] *** Joins: tulloch (tulloch@moz-1C33A2E7.nat.csx.cam.ac.uk)
[05:14:33] *** Joins: Jesse (jruderman@moz-2ECEC9F7.oc.oc.cox.net)
[05:14:52] <sfackler> it's the difference between "const int *" and "int * const" in C
[05:14:58] <sfackler> (hopefully I got that syntax right)
[05:15:04] <posco> I'm still getting used how fluid mutability is in rust...
[05:15:12] *** jorendorff_away is now known as jorendorff
[05:15:13] *** Joins: maxli (maxli@moz-4D28BA20.student.cs.uwaterloo.ca)
[05:15:17] <posco> coming from the scala/haskell view of things.
[05:19:35] *** Quits: ross (ross@moz-5EA04060.br.br.cox.net) (Ping timeout)
[05:21:34] *** Joins: axitkhurana (Adium@63F3AA56.9CFBD76D.30E7AE68.IP)
[05:25:25] *** Quits: japaric (japaric@EEA8F44E.83887C3F.5C7588CA.IP) (Ping timeout)
[05:25:41] *** Joins: japaric (japaric@EEA8F44E.83887C3F.5C7588CA.IP)
[05:25:43] *** Joins: frogzilla (Mibbit@moz-3213C615.wavecable.com)
[05:26:20] <frogzilla> Anyone one else find it humorous that rust isn't even 0.9 yet, but it's already being used to write operating systems?
[05:26:35] <o11c> no
[05:26:42] *** Joins: beifeng (Mibbit@284C36E7.3062CEC3.670EEFD.IP)
[05:27:48] <apoelstra> haha
[05:28:19] <frogzilla> Most compiled languages don't get to brag about that so soon. ^_^
[05:29:41] *** Quits: japaric (japaric@EEA8F44E.83887C3F.5C7588CA.IP) (Ping timeout)
[05:29:44] <eddyb> frogzilla: I am pushing the compiler to its limits, btw
[05:30:09] *** Joins: japaric (japaric@EEA8F44E.83887C3F.5C7588CA.IP)
[05:31:16] <tikue_> frogzilla: are you referring to the UVA class or something else?
[05:32:08] <eddyb> I need to work around quadratic space usage in rustc just to compile my "tiny" x86_16 emulator (needed for VBE, if you're familiar with that) without having hundreds of GBs of RAM
[05:32:25] <frogzilla> tikue_: This. https://github.com/mozilla/rust/wiki/Operating-system-development
[05:33:04] <tikue_> i did not know about rust-osdev
[05:33:51] <eddyb> "this page is temporarily in read-only mode due to heavy traffic." - the subreddit
[05:36:00] <bjz> eddyb: reddit does that from time-to-time
[05:36:22] <bjz> 'read-only' is site-wide, I think
[05:36:32] <eddyb> somehow I interpreted that as heavy traffic on the subreddit >_>
[05:36:44] <bjz> heh
[05:37:38] *** Quits: Dessimat0r (Dessimat0r@E879B262.8D4FD984.4320F744.IP) (Ping timeout)
[05:39:45] *** Quits: sprang (sprang@moz-920A95C4.hsd1.ca.comcast.net) (Quit: sprang)
[05:40:24] *** jorendorff is now known as jorendorff_away
[05:42:37] *** Joins: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net)
[05:42:54] *** jorendorff_away is now known as jorendorff
[05:44:54] *** Quits: hoopsnake (zac@moz-12CDD1F8.hsd1.wa.comcast.net) (Quit: leaving)
[05:45:25] *** Quits: tulloch (tulloch@moz-1C33A2E7.nat.csx.cam.ac.uk) (Ping timeout)
[05:46:09] *** Joins: dd (chatzilla@8CA41291.DAD92AC8.D216A595.IP)
[05:47:04] *** Joins: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz)
[05:50:44] *** Quits: hongminhee (sid295@moz-5F4AA75A.irccloud.com) (Ping timeout)
[05:50:44] *** Quits: etrepum (sid763@moz-5F4AA75A.irccloud.com) (Ping timeout)
[05:50:44] *** Quits: robert (uid15951@moz-A42E5B7B.irccloud.com) (Ping timeout)
[05:51:01] *** Joins: robert (uid15951@moz-A42E5B7B.irccloud.com)
[05:52:14] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[05:52:22] *** Joins: etrepum (sid763@moz-5F4AA75A.irccloud.com)
[05:54:17] *** Joins: pkphilip (Mibbit@1645AEB4.D187EA78.81C3DAA1.IP)
[05:57:29] *** Quits: quvarxa (chatzilla@moz-978E4C31.static.tpgi.com.au) (Ping timeout)
[05:58:00] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[05:58:00] *** ChanServ sets mode: +ao brson brson
[05:58:11] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Quit: leaving)
[05:58:19] *** Joins: quvarxa (chatzilla@moz-978E4C31.static.tpgi.com.au)
[05:58:27] *** Joins: brson (brson@6A848D32.C1B840DD.76F66111.IP)
[05:58:27] *** ChanServ sets mode: +ao brson brson
[05:58:56] <pkphilip> Hello
[05:59:25] <pkphilip> Had a question about the vector implementation in rust and using it within the "for" loop
[06:01:18] <pkphilip> When I get the list of command line arguments using std::os::args(), it returns a vector of arguments. If I use the for loop to loop through the arguments and when I try to print each argument out, I am getting a behaviour quite different from when I use array indexing to fetch the same data from the vector
[06:01:54] *** Joins: brson_ (brson@moz-BBE3ABD.mv.mozilla.com)
[06:02:27] <ssbr> pkphilip: Specifically?
[06:02:30] <pkphilip> for arg in std::os::args() {  println(fmt!("Arg: %s", arg))}  generates an error " mismatched types: expected `&str` but found `&~str` (expected &str but found &-ptr)"
[06:02:44] *** Quits: noam (noam@F6B530A7.720527A7.416762B.IP) (Ping timeout)
[06:02:44] *** Quits: brson (brson@6A848D32.C1B840DD.76F66111.IP) (Ping timeout)
[06:03:23] <dbaupp> pkphilip: I assume you mean `for arg in args().iter() { ... }`?
[06:03:28] <ssbr> pkphilip: args is an array of pointers. Iteration over arrays yields pointers to the elements
[06:03:48] <pkphilip> However, when I access the same data like this println(fmt("Arg: %s", std::os::args[0])) it works without any problems
[06:03:49] <ssbr> pkphilip: so each arg in std::os::args().iter() is a reference to a member of std::os::args()
[06:04:01] <ssbr> in this case, a &~str
[06:04:03] <pkphilip> ssbr: yes, that is right
[06:04:14] <ssbr> pkphilip: if you access elements directly, you don't get a pointer to the contents, you get the contents. ~str.
[06:04:21] <ssbr> that is why the behavior is different.
[06:05:02] <ssbr> (so you want to use *arg)
[06:05:12] *** Quits: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au) (Quit: gavinb)
[06:05:27] *** jorendorff is now known as jorendorff_away
[06:05:33] <pkphilip> I was actually using this: for arg in std::os::args().iter()
[06:06:17] <pkphilip> So in that case you have to use *str ?
[06:06:24] <pkphilip> I mean, *arg?
[06:07:01] *** Quits: eholk (eholk@C95FAD69.A304C61F.3ED9AD7C.IP) (Quit: eholk)
[06:07:41] <dbaupp> pkphilip: at the point-of-use of arg, yes.
[06:08:24] <pkphilip> ok. When you use "for" you are still iterating through the same elements. Why is that different from when you use array indexing to iterate through the elements?
[06:08:58] <ssbr> pkphilip: When you access an array at a certain index, you ask for the value in that array. When you iterate over an array, you ask for a pointer to the value in that array.
[06:09:02] <ssbr> Different things do things differently.
[06:09:21] <pkphilip> ok. Thanks a lot for the clarification. Most appreciated.
[06:10:32] <ssbr> pkphilip: the reason iteration over vectors does this, AIUI, is that vectors might contain values that are expensive to copy out. So the most general thing is to yield pointers to contents, and let the user do whatever they want (including dereference the pointer)
[06:12:11] <pkphilip> Got it. It is quite different from how other languages implement this functionality but I can see why this makes sense
[06:13:11] <posco> not sure why this is a compiler error: mismatched types: expected `&mut ~V` but found `~V`
[06:13:25] <posco> if I own V, isn't it safe to mutate it?
[06:13:29] *** Quits: bungoman (bungoman@moz-F95B490C.tx.res.rr.com) (Client exited)
[06:13:40] <dbaupp> the problem is the types not matching, not the mutability
[06:13:59] *** Quits: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[06:14:00] <dbaupp> try taking a mutable reference to that value (i.e. `&mut foo` rather than just `foo`)
[06:14:12] *** Joins: tulloch (tulloch@moz-1C33A2E7.nat.csx.cam.ac.uk)
[06:15:19] <ssbr> pkphilip: it's similar to iteration in C, when people do *p++
[06:15:30] <ssbr> if not outright identical
[06:15:56] *** Joins: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au)
[06:16:44] *** Quits: dbaupp (Thunderbir@29619B56.D5A1DCF.37681C44.IP) (Ping timeout)
[06:19:58] *** Quits: japaric (japaric@EEA8F44E.83887C3F.5C7588CA.IP) (Ping timeout)
[06:21:43] *** Quits: dd (chatzilla@8CA41291.DAD92AC8.D216A595.IP) (Ping timeout)
[06:27:18] <pkphilip> In C++, if I have an vector of pointers, example: vector<string> v;  if I iterate through this list using a foreach loop or if I use array indexing v[1] etc.. I receive the same type of object. I don't get a pointer to a string if I use a foreach loop and a string if I use array indexing (as far as I am aware).
[06:27:24] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[06:28:04] *** Joins: jstevans (Instantbir@moz-8DBF3BC4.washdc.fios.verizon.net)
[06:29:32] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[06:30:54] <ssbr> Sure, same in Python etc.
[06:31:14] <ssbr> I just mean that Rust isn't _totally_ without precedent ;)
[06:31:51] <pkphilip> :) understood
[06:32:06] *** Joins: Dessimat0r (Dessimat0r@E879B262.8D4FD984.4320F744.IP)
[06:32:08] *** Quits: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au) (Quit: gavinb)
[06:32:47] <eddyb> pkphilip: well, vector<string> isn't a vector of pointers, those strings are unboxed
[06:33:16] <eddyb> pkphilip: and I think you can get &string in a foreach loop, if you make it explicit
[06:33:42] *** Quits: Jesse (jruderman@moz-2ECEC9F7.oc.oc.cox.net) (Connection reset by peer)
[06:34:55] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Quit: )
[06:35:11] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[06:35:12] *** Joins: barosl (barosl@3DE683B6.E551553C.7544CABF.IP)
[06:35:36] *** Quits: Dessimat0r (Dessimat0r@E879B262.8D4FD984.4320F744.IP) (Ping timeout)
[06:35:49] *** Quits: jdm (jdm@579FEC0E.387F1B30.1A7D5C28.IP) (Quit: Lost terminal)
[06:36:12] *** Quits: fabiand__ (fabiand@moz-742359A2.adsl.alicedsl.de) (Quit: Verlassend)
[06:36:54] <pkphilip> eddyb: You are right.. vector<string> isn't an array of pointers. But if it were vector<string *>, you will receive a string * if you access any item in the vector whether via a for loop or via array indexing (ofcourse, here we are referring to operator overloaded access)
[06:37:04] <posco> wrote an implementation for ToStr for ~int, but I get this:
[06:37:12] <posco>  error: cannot provide an extension implementation for a trait not defined in this crate
[06:37:34] <posco> how do you give such implementations?
[06:37:57] <posco> do all implementations have to live with the trait definitions?
[06:38:02] <eddyb> posco: you don't "own" neither of those
[06:38:16] <posco> you must own one?
[06:38:32] <eddyb> yeah, one or both, ToStr is in std and ~int is builtin
[06:38:58] <posco> failed to find an implementation of trait std::to_str::ToStr for ~int
[06:39:05] <posco> was trying to work around that
[06:39:13] <eddyb> rusti: trait Foo {} impl Foo for ~int {}
[06:39:14] -rusti- ()
[06:39:15] <pkphilip> eddyb: and ssbr:, My only concern with the way rust implements access to data stored in vectors via a for loop etc - if you are only returning the pointer to the object rather than the object itself everytime you use a for loop, wouldn't you then have to explicitly dereference the pointer to access the object and wouldn't that be the common usecase
[06:39:45] <eddyb> pkphilip: actually, indexing gives you a string*&. I'm not sure if iterating has two different methods or it always returns string*& in that case
[06:40:18] <ssbr> pkphilip: care has to be made to make the uncommon usecase efficient too, regardless
[06:40:37] <ssbr> it is very nonmagical and makes perfect sense, which makes it easy to remember even if it is different from some other languages.
[06:41:02] <eddyb> .move_iter() gives you values, btw, but that's not always desired
[06:41:25] <pkphilip> ah ok. didn't check that. Makes sense.
[06:41:36] *** Joins: engla (engla@moz-F64E1B0F.cust.bredbandsbolaget.se)
[06:42:52] *** Joins: prem (prem@1645AEB4.D187EA78.81C3DAA1.IP)
[06:43:28] *** prem is now known as pkphilip2
[06:43:55] *** Quits: pkphilip (Mibbit@1645AEB4.D187EA78.81C3DAA1.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[06:45:35] *** Quits: tulloch (tulloch@moz-1C33A2E7.nat.csx.cam.ac.uk) (Ping timeout)
[06:45:41] <pkphilip2> This is pkphilip signed in using a different irc client. ssbr: ebby: thanks for your help
[06:46:33] *** Quits: pkphilip2 (prem@1645AEB4.D187EA78.81C3DAA1.IP) (Quit: Leaving)
[06:49:53] *** Quits: boredomist (ruqs@B16F530C.DC641F2C.BCAEBB33.IP) (Client exited)
[06:49:58] *** Quits: jstevans (Instantbir@moz-8DBF3BC4.washdc.fios.verizon.net) (Ping timeout)
[06:52:17] *** Joins: tiffany (kawaii@moz-FC0DB29D.dhcp.embarqhsd.net)
[06:52:51] *** Joins: victorporof (victorporo@47B918E3.BCF05198.9B1E38F4.IP)
[06:54:51] *** Joins: dd (chatzilla@9BE163B0.70578880.F102451D.IP)
[06:54:57] <dd> hi 
[06:55:44] <dd> if i am working fixing bugs in compiler  then after editing my source  do i need to to build it using ./configure ?? or just make install ?
[06:56:23] <eddyb> dd: make rustc-stage1
[06:56:37] <eddyb> dd: that rebuilds the minimum necessary to test it
[06:56:38] <dd> i am so stuck with this term eddyb
[06:56:48] <dd> can you explain me plz
[06:56:55] <eddyb> explain what?
[06:57:17] <dd> 1st of this first time when i am working with compilers 
[06:57:26] <dd> so everything is new for me 
[06:57:32] <dd> what is this rustc-stage1??
[06:57:38] <dd> i am a student.
[06:57:40] <eddyb> rustc is the rust compiler
[06:58:08] <dd> i knw that , but rustc-stage1 what is this ??
[06:58:13] <klutzy> dd: if you type `make`, make will read Makefile and build some deafult target
[06:58:26] <klutzy> dd: if you type `make target`, it will build specified target instead
[06:58:47] <eddyb> dd: stage1 is the second build stage, we have those because the rust compiler is written in rust and sometimes it needs to be built multiple times
[06:58:49] <klutzy> dd: rust's Makefile contains some targets, rustc-stage1 is one of them
[06:58:58] <joelteon> `make' is `make all'
[06:59:49] <dd> oky 
[07:00:10] <dd> so its like creating  an instance of itself ??
[07:00:17] <eddyb> dd: stage0 is mostly downloaded from a server (prebuilt), stage1 contains your changes, stage2 contains your changes and is built with stage1 (so it can differ from stage1 sometimes)
[07:00:51] <eddyb> the default is stage2, but that takes about double the time to build, it's easier to test with just stage1
[07:01:17] *** Joins: mcarberry (mcarberry@moz-BE1C9F3F.lightspeed.frokca.sbcglobal.net)
[07:02:01] <eddyb> there's a wiki page explaining this in more detail and when you need to pay attention to it, if you're curious
[07:02:34] <dd> i am developing sir :) and its  my college project . so it HAVE TO DO IT.
[07:03:05] <eddyb> dd: okay, what file did you change (or in what directory, if there's more than one)?
[07:03:30] <dd> 1 more thing , as i will make changes in the downloaded code from which i build ?? r8.
[07:03:42] <dd> in debug info file.
[07:03:58] <dd> try to fix global variables debug info.
[07:04:03] <dd> trying*
[07:04:42] <eddyb> if you build just stage1, you will get a compiler which will (assuming you fixed the bug properly) generate the right debug info
[07:05:04] <dd> yes. eddyb :)
[07:05:06] <eddyb> if you also build stage2, the resulting stage2 compiler itself will have the right debug info
[07:05:31] <dd> m i going in r8 direction ?? i am not sure means making changes in the downloded source code is fine ??
[07:05:46] <eddyb> dd: well, are you using git?
[07:05:57] *** Joins: bungoman (bungoman@moz-F95B490C.tx.res.rr.com)
[07:06:00] <dd> yeah :)
[07:06:06] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Connection reset by peer)
[07:06:19] <eddyb> are you working on a git clone of a github fork of rust?
[07:06:24] <dd> i can keep track the changes .
[07:06:27] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[07:06:33] <dd> yeah i am :)
[07:06:52] <eddyb> then you're fine there
[07:07:38] *** Quits: bungoman (bungoman@moz-F95B490C.tx.res.rr.com) (Ping timeout)
[07:07:39] <eddyb> dd: 64-bit linux?
[07:09:06] <eddyb> after make rustc-stage1 finishes, the resulting compiler is ./x86_64-unknown-linux-gnu/stage1/bin/rustc
[07:10:16] *** Quits: refold (gman@moz-42D68426.a258.priv.bahnhof.se) (Quit: leaving)
[07:10:32] *** Quits: dd (chatzilla@9BE163B0.70578880.F102451D.IP) (Connection reset by peer)
[07:13:09] <eddyb> rusti: struct L<'self>(Option<&'self L>); let mut v = ~[L(None)]; v.push(L(&v[0])); v.push(L(&v[1])); v.push(L(&v[2])); v.push(L(&v[3])); print!("{:?} ", v[4]);
[07:13:10] -rusti- pastebinned 5 lines of output: http://sprunge.us/cLhK
[07:14:09] *** Joins: tulloch (tulloch@moz-1C33A2E7.nat.csx.cam.ac.uk)
[07:15:29] *** Joins: DeTeam (DeTeam@92C799C.31715274.F5F3AF2.IP)
[07:16:03] *** Quits: KindOne (KindOne@A1D7C168.35741547.34F73994.IP) (Ping timeout)
[07:18:44] *** Quits: axitkhurana (Adium@63F3AA56.9CFBD76D.30E7AE68.IP) (Quit: Leaving.)
[07:19:14] *** Quits: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net) (Quit: Sharp)
[07:19:30] *** Joins: axitkhurana (Adium@63F3AA56.9CFBD76D.30E7AE68.IP)
[07:19:47] *** Joins: dbaupp (Thunderbir@moz-3BE4086E.lns20.syd6.internode.on.net)
[07:20:11] *** Joins: KindOne (KindOne@moz-C5E84B27.dynamic.ip.windstream.net)
[07:22:48] *** Joins: Axord (xord@moz-C0D5F15A.lsanca.dsl-w.verizon.net)
[07:23:59] *** Parts: axitkhurana (Adium@63F3AA56.9CFBD76D.30E7AE68.IP) ()
[07:29:14] <tikue_> eddyb: that probably won't work because you'd need an immutable reference to v while also mutating it
[07:29:37] *** Joins: Dessimat0r (Dessimat0r@E879B262.8D4FD984.4320F744.IP)
[07:30:11] *** Quits: FreeFull (freefull@E424A224.387C8A0C.DC9D01B1.IP) (Quit: )
[07:30:17] <eddyb> rusti: struct L<'self>(Option<&'self L<'self>>); let mut v = ~[L(None)]; v.push(L(&v[0])); v.push(L(&v[1])); v.push(L(&v[2])); v.push(L(&v[3])); print!("{:?} ", v[4]);
[07:30:18] -rusti- pastebinned 14 lines of output: http://sprunge.us/RBWL
[07:30:31] *** Joins: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net)
[07:30:54] <eddyb> rusti: struct L<'self>(Option<&'self L<'self>>); let mut v = ~[L(None)]; v.push(L(Some(&v[0]))); v.push(L(Some(&v[1]))); v.push(L(Some(&v[2]))); print!("{:?} ", v[3]);
[07:30:55] -rusti- pastebinned 38 lines of output: http://sprunge.us/VTcP
[07:31:07] <eddyb> tikue_: >:(
[07:31:18] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[07:31:21] *** Joins: fabiand (fabiand@moz-742359A2.adsl.alicedsl.de)
[07:31:31] <tikue_> eddyb: yeah i'd be interested in finding a way to make that work as well
[07:31:32] *** Quits: quvarxa (chatzilla@moz-978E4C31.static.tpgi.com.au) (Ping timeout)
[07:31:33] *** Quits: ktt3ja (Mibbit@moz-D69B60E4.hsd1.va.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[07:31:33] <eddyb> I really need that to work, dammit
[07:31:55] <eddyb> wait, can it ever work?
[07:31:55] *** Joins: quvarxa (chatzilla@moz-978E4C31.static.tpgi.com.au)
[07:32:05] <tikue_> more generally, having multiple mutable references to disconnected parts of a vector is really useful but doesn't work now
[07:32:15] <tikue_> eddyb: i don't know
[07:32:43] <eddyb> I'm thinking right now in terms of relocations
[07:33:06] <eddyb> this one will work because it's a heap vector
[07:34:17] <eddyb> rusti: struct L<'self>(Option<&'self L<'self>>); let mut v = ~[L(None), L(None), L(None), L(None)]; v[1] = L(Some(&v[0])); v[2] = L(Some(&v[1])); v[3] = L(Some(&v[2])); print!("{:?} ", v[3]);
[07:34:20] -rusti- pastebinned 20 lines of output: http://sprunge.us/YGDj
[07:34:35] <eddyb> aaaand that's a bug
[07:34:59] <tikue_> what is?
[07:35:19] *** Quits: canhtak (canhtak@moz-6F820ACE.wl.t.ulaval.ca) (Quit: canhtak)
[07:35:41] <eddyb> tikue_: this works with structures
[07:35:47] <klutzy> borrowing vector is not elementwise
[07:36:19] *** Quits: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz) (Quit: Busying myself...)
[07:37:35] <eddyb> rusti: struct L<'self>(Option<&'self L<'self>>);struct A<'self>{a:L<'self>,b:L<'self>,c:L<'self>} let mut v = ~A{a:L(None), b:L(None), c:L(None)}; v.b = L(Some(&v.a)); v.c = L(Some(&v.b)); print!("{:?} ", v.c);
[07:37:36] -rusti- main::L<>(Some(&main::L<>(Some(&main::L<>(None))))) ()
[07:38:19] *** Joins: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au)
[07:38:34] <dbaupp> eddyb: in general it can't prove that vector indexing gives disjoint values (i.e. if they're not constants), and, with an overloaded [], it can't prove it even for constants.
[07:38:51] <tikue_> rusti: struct Foo { bar: uint, baz: uint } let mut foo = Foo { bar: 0, baz: 1 }; let Foo { bar: ref mut bar, baz: ref mut baz } = foo; *bar = 1; *baz = 2; foo
[07:38:52] -rusti- main::Foo{bar: 1u, baz: 2u}
[07:39:19] *** Joins: axitkhurana (Adium@63F3AA56.9CFBD76D.30E7AE68.IP)
[07:39:42] <tikue_> it _does_ seem incongruous though. dbaupp, perhaps dynamic checks would be worth it? :\ idk
[07:40:15] <dbaupp> tikue_: um, no more dynamic checks please.
[07:40:22] <eddyb> I think Mut is intended for dynamic mutability
[07:40:24] <dbaupp> ~[Mut<T>] (or whatever it is) for that
[07:40:27] <dbaupp> yeah
[07:40:47] <sfackler> It's RefCell now
[07:41:05] <tikue_> dbaupp: fair enough
[07:41:05] <eddyb> Mut returns RefCell from some of its methods, I think
[07:41:18] <eddyb> struct fields will actually work just fine for me
[07:41:20] <klutzy> you also could use unsafe{} if it is really safe
[07:41:36] *** Quits: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net) (Ping timeout)
[07:41:44] <sfackler> no, like the type Mut was renamed to RefCell before it merged
[07:41:50] <eddyb> ooh
[07:41:55] <eddyb> so we can't do Rc<Mut<T>> :(
[07:42:03] <dbaupp> Rc<RefCell<T>>
[07:42:06] <sfackler> yeah
[07:42:08] <eddyb> bleah
[07:42:19] <dbaupp> `pub type Mut<T> = RefCell<T>; // all fixed.`
[07:42:26] <eddyb> type mut T = RefCell<T>;
[07:42:32] <eddyb> Rc<mut T> :P
[07:42:33] <sfackler> the reasoning was that it's too hard to talk about "mut" vs "Mut with a capital M"
[07:42:55] <dbaupp> DynMut<T> maybe?
[07:42:56] <ssbr> pff, it's easy. One is "mutt" and the other is "mute"
[07:43:05] <eddyb> ssbr: haha
[07:43:05] * dbaupp needs his daily does of bikeshedding
[07:43:09] <sfackler> haha
[07:43:09] <dbaupp> *dose
[07:43:26] <eddyb> dbaupp: did you see that I managed to compile my emulator nightmare thing?
[07:43:48] <eddyb> it's not hitting trans yet, but borrowck barely uses any RAM now that every match case is its own function
[07:43:55] *** Quits: KindOne (KindOne@moz-C5E84B27.dynamic.ip.windstream.net) (Ping timeout)
[07:44:30] <dbaupp> eddyb: oh
[07:44:32] <dbaupp> eddyb: nice
[07:44:39] <dbaupp> eddyb: what's it hitting now?
[07:44:45] <eddyb> instead of being quadratic
[07:44:57] *** Quits: Dessimat0r (Dessimat0r@E879B262.8D4FD984.4320F744.IP) (Ping timeout)
[07:45:09] <eddyb> dbaupp: see #rust-internals, I think type checking is kinda bad, but manageable
[07:45:29] *** Quits: tulloch (tulloch@moz-1C33A2E7.nat.csx.cam.ac.uk) (Ping timeout)
[07:45:46] <eddyb> I didn't try with lifetime enabled, but there's no hundred thousand locals anymore, so that should be working right as well
[07:46:15] <eddyb> the only problem now is that I'm referencing parts of the created object in Context::new so I have to return a ~
[07:48:11] *** Joins: Dessimat0r (Dessimat0r@E879B262.8D4FD984.4320F744.IP)
[07:48:15] *** Joins: KindOne (KindOne@moz-7A3ED1B8.dynamic.ip.windstream.net)
[07:48:25] <dbaupp> eddyb: ah 1.6GB doesn't sound so bad.
[07:48:43] <dbaupp> (certainly better than hundreds at a least.)
[07:48:47] <eddyb> :P
[07:49:33] <eddyb> where is strcat when you need him?
[07:50:16] <dbaupp> sleeping I guess :P
[07:50:39] <eddyb> I had an interesting idea: use IRC colors for the output of rusti and maybe send the full output (within 10-20 lines) to whomever requested it
[07:50:44] *** Quits: Dessimat0r (Dessimat0r@E879B262.8D4FD984.4320F744.IP) (Ping timeout)
[07:50:53] <dbaupp> eddyb: https://github.com/thestinger/rust-playpen/blob/master/bin/irc.sh
[07:51:05] <eddyb> right, thanks :P
[07:51:58] <eddyb> well, the code which would be handling it doesn't go in there
[08:00:06] *** Quits: dju (dju@moz-83BD5EC.dmz.me) (Quit: ZNC - http://znc.in)
[08:00:15] *** Joins: bungoman (bungoman@moz-F95B490C.tx.res.rr.com)
[08:01:39] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Client exited)
[08:02:00] *** Quits: bungoman (bungoman@moz-F95B490C.tx.res.rr.com) (Ping timeout)
[08:02:16] *** flaper87|afk is now known as flaper87
[08:03:00] *** Quits: brson_ (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[08:03:02] <tikue_> it seems like in pattern matching a vector, that [ref mut x, ref mut y, ref mut z, ..] should be allowable
[08:03:45] *** Joins: peterdn (chatzilla@moz-D11BA78C.as13285.net)
[08:05:45] *** Joins: dju (dju@moz-83BD5EC.dmz.me)
[08:06:09] *** Joins: Ferreus (ferreus@moz-E56B798B.dip0.t-ipconnect.de)
[08:06:13] *** Quits: Ferreus (ferreus@moz-E56B798B.dip0.t-ipconnect.de) (Quit: Ferreus)
[08:06:17] *** Joins: Ferreus (ferreus@moz-E56B798B.dip0.t-ipconnect.de)
[08:06:24] *** Quits: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Ping timeout)
[08:06:30] *** Joins: brson (brson@6A848D32.C1B840DD.76F66111.IP)
[08:06:30] *** ChanServ sets mode: +ao brson brson
[08:06:36] <ssbr> Why isn't it?
[08:07:00] <tikue_> ssbr: vectors aren't borrowed elementwise
[08:07:12] <tikue_> because it's hard
[08:07:17] <tikue_> but that particular case seems easier
[08:07:40] <ssbr> tikue_: What do you mean "aren't" -- it sounds like you're saying "you can't do this because you can't"
[08:07:50] <ssbr> but maybe borrowing elementwise means something else
[08:08:12] <tikue_> ssbr: well, indexing into a vector requires knowing the integer value, which currently can't be determined at compile time
[08:08:26] *** Joins: Mowah (Mowah@moz-436C35C5.cust.bredbandsbolaget.se)
[08:08:40] <tikue_> so there's no way to know you're not trying to do for example, let (a, b) = (&mut v[0], &mut v[0]);
[08:08:51] <ssbr> tikue_: Oh, I see. If you borrow a mutable reference to foo[bar], and borrow another mutable reference to foo[baz], the compiler can't know they're equal
[08:08:55] <ssbr> not equal*
[08:09:01] <tikue_> yeah exactly
[08:09:06] <ssbr> still, for pattern matching, as you say...
[08:09:11] <tikue_> but with pattern matching you should be able to i think
[08:09:16] <ssbr> the compiler knows everything, the indexes are constants there
[08:09:23] *** Quits: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au) (Quit: gavinb)
[08:09:25] <tikue_> queue someone with more knowledge telling me why it's not allowable
[08:09:57] <ssbr> this does explain why I couldn't write that game I tried writing in rust
[08:10:05] <dbaupp> rusti: let mut foo = ~[1,2]; match foo { [ref mut a, ref mut b] => { *a += 1, *b += 1; }, _ => {} }; foo
[08:10:05] -rusti- <anon>:9:78: 9:79 error: expected one of `; }` but found `,`
[08:10:05] -rusti- <anon>:9          let mut foo = ~[1,2]; match foo { [ref mut a, ref mut b] => { *a += 1, *b += 1; }, _ => {} }; foo
[08:10:05] -rusti-                                                                                        ^
[08:10:05] -rusti- application terminated with error code 101
[08:10:06] <ssbr> I was confused by the type errors at the time
[08:10:19] <dbaupp> rusti: let mut foo = ~[1,2]; match foo { [ref mut a, ref mut b] => { *a += 1; *b += 1; } _ => {} }; foo
[08:10:21] -rusti- pastebinned 8 lines of output: http://sprunge.us/TZMV
[08:10:28] <tikue_> dbaupp: what do you think?
[08:10:35] <dbaupp> tikue_: it should be fine
[08:10:40] <dbaupp> tikue_: file a bug
[08:10:44] <tikue_> ok :)
[08:10:53] <dbaupp> could reference https://github.com/mozilla/rust/issues/8636 too
[08:11:06] *** Joins: mib_in224q (Mibbit@4CEED5DF.FB5956E3.C7DA06F6.IP)
[08:11:54] <mib_in224q> Did Rust support declarative specifications?
[08:12:59] <tikue_> dbaupp: hm, that issue looks like it already covers this issue. perhaps not explicitly though
[08:14:25] <sfackler> woo! https://github.com/mozilla/rust/pull/10649
[08:15:27] <eddyb> I has a problem. not sure if aliasing works right
[08:15:57] *** Joins: moostik (Icedove@moz-63ED7231.w82-121.abo.wanadoo.fr)
[08:16:01] <dbaupp> tikue_: ok, add a comment then (since I didn't even know that multiple ref-mut's doesn't work)
[08:16:09] <tikue_> ok sure
[08:16:10] <dbaupp> sfackler: \o/
[08:17:26] *** Quits: cubic (cubic@moz-80241A3A.mc.videotron.ca) (Connection reset by peer)
[08:18:05] <eddyb> rusti: struct Foo<'self>{i: int, p: Option<&'self int>} impl<'self> Foo<'self> {fn new() -> ~Foo<'self> {let foo = ~Foo{i:7,p:None};foo.p=Some(&foo.i);foo}}
[08:18:06] -rusti- pastebinned 20 lines of output: http://sprunge.us/fjUG
[08:18:31] <eddyb> rusti: struct Foo<'self>{i: int, p: Option<&'self int>} impl<'self> Foo<'self> {fn new() -> ~Foo<'self> {let mut foo = ~Foo{i:7,p:None};foo.p=Some(&foo.i);foo}}
[08:18:32] -rusti- pastebinned 17 lines of output: http://sprunge.us/jUZM
[08:20:07] *** Joins: qrpth (andreas@moz-9C921D25.ut.ee)
[08:20:55] *** Quits: nomadic (nomadic@moz-E01D5C49.hsd1.ga.comcast.net) (Ping timeout)
[08:21:05] *** Quits: mib_in224q (Mibbit@4CEED5DF.FB5956E3.C7DA06F6.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[08:21:45] <dbaupp> sfackler: do you happen to have measurements if it makes ast-folding slower/faster? (e.g. `rustc --no-trans -Z time-passes libstd/lib.rs`)
[08:22:05] <sfackler> I haven't checked
[08:22:10] <sfackler> I can run some benchmarks tomorrow
[08:22:11] *** Quits: dju (dju@moz-83BD5EC.dmz.me) (Quit: ZNC - http://znc.in)
[08:22:28] <dbaupp> ok
[08:23:21] <eddyb> sfackler: what's with the title on that PR?
[08:23:30] <eddyb> it doesn't feel right given the description
[08:25:05] <dbaupp> eddyb: it makes sense now :P
[08:25:31] <dbaupp> (and now it makes even more sense)
[08:26:28] <eddyb> dbaupp: it's... still disjoint
[08:26:39] *** Quits: jeaye (Jeaye@moz-34FEF2BB.hsd1.ca.comcast.net) (Quit: zzz)
[08:27:04] <tikue_> something else that is curious is: `let v = [1, 2, 3]; let [a, b, c] = v;` is disallowed due to refutable pattern, but also `match v { [a, b, c] => (), _ => () }` is disallowed because of an unreachable pattern. seems like it should be one or the other
[08:27:28] <sfackler> eddyb: the description is only talking about one part of it
[08:27:45] <eddyb> dbaupp: lol, saying that while I get CC'd on a different issue, with disjoint in it
[08:27:52] <eddyb> sfackler: ah, it's not obvious :S
[08:28:01] * sfackler -> bed
[08:28:41] <eddyb> no, I didn't get mentioned, I guess I was watching it
[08:29:00] <dbaupp> eddyb: look at the commits :P
[08:29:28] <dbaupp> tikue_: incomplete support for [T, .. n] in patterns
[08:29:45] <eddyb> dbaupp: I would split his PR into two
[08:30:20] <tikue_> dbaupp: incomplete in what sense? they seem as functional as &[T] when I've used them
[08:30:42] <eddyb> dbaupp: also, somehow this showed up in my notifications https://github.com/mozilla/rust/issues/8636
[08:31:03] *** Joins: dju (dju@moz-83BD5EC.dmz.me)
[08:32:55] <dbaupp> eddyb: why? the smallvector is essentially a libsyntax-only utility module to allow implementing the later two in a efficient way.
[08:33:10] <dbaupp> eddyb: I dunno why that'd show up, magic?
[08:33:13] <eddyb> it's just not obvious :P
[08:33:37] <dbaupp> tikue_: incomplete because `let [a,b,c] = v;` isn't accepted.
[08:33:45] <eddyb> "in order to implement this efficiently, I've added ..." would be more than enough
[08:33:49] *** Joins: Ms2ger (Ms2ger@moz-1B43DE50.adsl-dyn.isp.belgacom.be)
[08:33:56] <dbaupp> tikue_: also, can't implement traits for [T, .. n] in a sane way.
[08:34:16] <eddyb> basically, need integers in generics
[08:34:30] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[08:35:29] <eddyb> rusti: struct Foo<'self>{i: int, p: Option<&'self int>} impl<'self> Foo<'self> {fn new() -> ~Foo<'self> {let mut foo = ~Foo{i:7,p:None};foo.p=Some(&foo.i);~Foo{i:7,p:None}}}
[08:35:29] -rusti- ()
[08:35:39] <eddyb> ooookay, so that's the problem, moving out
[08:35:57] <eddyb> how can I store references-to-parts-of-self in a constructor?
[08:36:10] <eddyb> it should be safe, as it's explicitly owned
[08:36:26] *** Joins: nomadic (nomadic@moz-E01D5C49.hsd1.ga.comcast.net)
[08:36:30] <eddyb> rusti: struct Foo<'self>{i: int, p: Option<&'self int>} impl<'self> Foo<'self> {fn new() -> ~Foo<'self> {let mut foo = ~Foo{i:7,p:None};foo.p=Some(&'self foo.i);foo}}
[08:36:31] -rusti- pastebinned 17 lines of output: http://sprunge.us/UjCj
[08:37:08] *** Joins: avsej (avsej@DF1824D5.EFF97412.48F984E6.IP)
[08:37:41] *** Quits: mcarberry (mcarberry@moz-BE1C9F3F.lightspeed.frokca.sbcglobal.net) (Ping timeout)
[08:40:51] *** Joins: pkphilip (Mibbit@1645AEB4.D187EA78.81C3DAA1.IP)
[08:42:44] *** Quits: qrpth (andreas@moz-9C921D25.ut.ee) (Ping timeout)
[08:43:32] *** Joins: GeneralMaximus (ankur@2B9456D9.591B27D3.D5D59AD9.IP)
[08:44:59] <eddyb> dbaupp: can I even do that in some way?
[08:45:30] <eddyb> rusti: struct Foo<'self>{i: ~int, p: Option<&'self int>} impl<'self> Foo<'self> {fn new() -> ~Foo<'self> {let mut foo = ~Foo{i:7,p:None};foo.p=Some(&'self foo.i);foo}}
[08:45:31] -rusti- pastebinned 8 lines of output: http://sprunge.us/hPAb
[08:46:02] <eddyb> rusti: struct Foo<'self>{i: ~int, p: Option<&'self int>} impl<'self> Foo<'self> {fn new() -> ~Foo<'self> {let mut foo = ~Foo{i:~7,p:None};foo.p=Some(&*foo.i);foo}}
[08:46:03] -rusti- pastebinned 17 lines of output: http://sprunge.us/FUBi
[08:46:36] <eddyb> rusti: struct Foo<'self>{i: ~int, p: Option<&'self int>} impl<'self> Foo<'self> {fn new() -> ~Foo<'self> {let mut foo = ~Foo{i:~7,p:None};foo.p=Some(&*(foo.i));foo}}
[08:46:37] -rusti- pastebinned 17 lines of output: http://sprunge.us/SQii
[08:46:49] <eddyb> whaaa :(
[08:47:30] <eddyb> I hope I don't have to do Context::with_new |ctx| {}
[08:49:28] *** Joins: tulloch (tulloch@moz-99B7EB8.nat.csx.cam.ac.uk)
[08:51:07] *** Joins: qrpth (andreas@moz-9C921D25.ut.ee)
[08:51:16] <eddyb> rusti: struct Foo<'self>{i: int, p: Option<&'self int>} impl<'self> Foo<'self> {fn new() -> ~Foo<'self> {~Foo{i:7,p:None}}fn bar(&mut self){self.p=Some(&self.i);}}
[08:51:17] -rusti- pastebinned 17 lines of output: http://sprunge.us/DBeI
[08:51:51] <eddyb> rusti: struct Foo<'self>{i: int, p: Option<&'self int>} impl<'self> Foo<'self> {fn new() -> ~Foo<'self> {~Foo{i:7,p:None}}fn bar(&mut self){self.p=Some(&'self self.i);}}
[08:51:52] -rusti- pastebinned 17 lines of output: http://sprunge.us/AWdP
[08:52:13] *** Joins: mcarberry (mcarberry@moz-BE1C9F3F.lightspeed.frokca.sbcglobal.net)
[08:52:21] <eddyb> I... don't get it :(
[08:52:58] *** Quits: qrpth (andreas@moz-9C921D25.ut.ee) (Ping timeout)
[08:52:58] <eddyb> I guess it's hard for a structure to be self-referential
[08:53:42] <eddyb> but... it's safe here
[08:54:18] *** Joins: bungoman (bungoman@moz-F95B490C.tx.res.rr.com)
[08:54:39] <pnkfelix> eddyb: I think you need `&'self mut self`
[08:54:52] <pnkfelix> rusti: struct Foo<'self>{i: int, p: Option<&'self int>} impl<'self> Foo<'self> {fn new() -> ~Foo<'self> {~Foo{i:7,p:None}}fn bar(&'self mut self){self.p=Some(&'self self.i);}}
[08:54:53] -rusti- ()
[08:54:59] <eddyb> o_O
[08:55:02] <eddyb> pnkfelix: thanks :D
[08:55:11] *** Quits: Kingsley (kingsley@9B172CBE.BEA5C56D.DF4B730F.IP) (Quit: Leaving.)
[08:55:18] <eddyb> pnkfelix: but I still can't move out, right?
[08:55:25] <tikue_> oh wow, I didn't realize that couldn't be inferred 
[08:55:35] <pnkfelix> eddyb: I believe `fn bar(&mut self)` is shorthand for `fn bar<'a>(&'a mut self)`
[08:55:54] <pnkfelix> eddyb: As in, the lifetime of the reference 'a may be shorter than the lifetime of self.  (I think...)
[08:55:56] <eddyb> yeah, I know, just didn't see it >_>
[08:56:00] *** Quits: bungoman (bungoman@moz-F95B490C.tx.res.rr.com) (Ping timeout)
[08:56:03] <pnkfelix> eddyb: so we need to keep it alive longer
[08:56:17] <eddyb> rusti: struct Foo<'self>{i: int, p: Option<&'self int>} impl<'self> Foo<'self> {fn new() -> ~Foo<'self> {~Foo{i:7,p:None}}fn bar(&'self mut self){self.p=Some(&'self self.i);}} let x = Foo::new(); x.bar(); x
[08:56:18] -rusti- pastebinned 25 lines of output: http://sprunge.us/BZbT
[08:56:35] <pnkfelix> eddyb: As for moving out, … I'll have to scroll up and read more of the context
[08:57:00] <eddyb> rusti: struct Foo<'self>{i: int, p: Option<&'self int>} impl<'self> Foo<'self> {fn new() -> ~Foo<'self> {~Foo{i:7,p:None}}fn bar(&'self mut self){self.p=Some(&'self self.i);}} let x = Foo::new(); x.bar(); print!("{:?} ", x);
[08:57:02] -rusti- pastebinned 17 lines of output: http://sprunge.us/gcCI
[08:57:23] <eddyb> rusti: struct Foo<'self>{i: int, p: Option<&'self int>} impl<'self> Foo<'self> {fn new() -> ~Foo<'self> {~Foo{i:7,p:None}}fn bar(&'self mut self){self.p=Some(&'self self.i);}} let mut x = Foo::new(); x.bar(); print!("{:?} ", x);
[08:57:24] -rusti- pastebinned 14 lines of output: http://sprunge.us/dfcX
[08:57:32] *** Joins: qrpth (andreas@moz-9C921D25.ut.ee)
[08:58:40] *** Joins: mikezaby (mikezaby@moz-AA896205.home.otenet.gr)
[08:59:01] *** Parts: mikezaby (mikezaby@moz-AA896205.home.otenet.gr) ()
[08:59:52] <eddyb> rusti: struct Foo<'self>{i: int, p: Option<&'self int>} impl<'self> Foo<'self> {fn new() -> ~Foo<'self> {~Foo{i:7,p:None}}fn bar(&'self mut self){self.p=Some(&'self self.i);}} let mut x = Foo::new(); x.bar();
[08:59:53] -rusti- ()
[09:00:05] <eddyb> rusti: struct Foo<'self>{i: int, p: Option<&'self int>} impl<'self> Foo<'self> {fn new() -> ~Foo<'self> {~Foo{i:7,p:None}}fn bar(&'self mut self){self.p=Some(&'self self.i);}} let mut x = Foo::new(); x.bar(); x.i
[09:00:06] -rusti- 7
[09:00:16] <eddyb> okay, so this works :D
[09:00:28] <eddyb> rusti: struct Foo<'self>{i: int, p: Option<&'self int>} impl<'self> Foo<'self> {fn new() -> ~Foo<'self> {~Foo{i:7,p:None}}fn bar(&'self mut self){self.p=Some(&'self self.i);}} let mut x = Foo::new(); x.bar(); let p = &x.i;
[09:00:29] -rusti- pastebinned 8 lines of output: http://sprunge.us/BOSK
[09:00:49] <eddyb> rusti: struct Foo<'self>{i: int, p: Option<&'self int>} impl<'self> Foo<'self> {fn new() -> ~Foo<'self> {~Foo{i:7,p:None}}fn bar(&'self mut self){self.p=Some(&'self self.i);}} let mut x = Foo::new(); x.bar(); let x=x;let p = &x.i;
[09:00:51] -rusti- pastebinned 8 lines of output: http://sprunge.us/KJIX
[09:01:15] <eddyb> I cannot see those properly because sprunge.us defaults to text files which are wrapped :(
[09:01:16] <pnkfelix> eddyb: Do you desire to show us all of these intermediate expressions?  rusti still accepts Private Messages (and I believe such is preferred until you have something particular to demo)...
[09:01:57] <eddyb> I'm sorry. and rusti right now is suboptimal, I should use echo and rustc - instead
[09:01:58] <pnkfelix> eddyb: but, carry on if each demo was intended for the group
[09:02:34] <eddyb> nah, I tend to create monologues, even if the bot helps. bad habit
[09:02:37] *** Quits: adu (ajr@moz-47946E69.washdc.fios.verizon.net) (Quit: adu)
[09:02:39] *** Joins: oberstet (quassel@moz-D08B2E13.dynamic.mnet-online.de)
[09:04:48] <eddyb> pnkfelix: how can I freeze (de-mut) x?
[09:05:32] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Client exited)
[09:05:44] <pnkfelix> eddyb: looking
[09:06:17] <eddyb> I guess that's the same moving out problem. I want to create a self-referential structure on the heap, like some sort of fixed shape arena
[09:06:37] *** Quits: Ms2ger (Ms2ger@moz-1B43DE50.adsl-dyn.isp.belgacom.be) (Quit: bbl)
[09:07:30] <tikue_> is there a rust autoindent file for vim?
[09:07:44] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Quit: Gone to save the world!)
[09:10:07] *** Quits: nfroidure (nfroidure@moz-72C6FB61.w90-34.abo.wanadoo.fr) (Quit: Ex-Chat)
[09:10:22] *** Joins: nfroidure (nfroidure@moz-72C6FB61.w90-34.abo.wanadoo.fr)
[09:10:32] <pnkfelix> tikue_: I'm not a vim user, but have you looked in rust/src/etc/vim/ ?
[09:10:59] <tikue_> pnkfelix: yeah i just figured it out, i already had the file just hadn't turned on the setting "filetype plugin indent on"
[09:11:09] *** Joins: Dessimat0r (Dessimat0r@E879B262.8D4FD984.4320F744.IP)
[09:15:46] *** Quits: tulloch (tulloch@moz-99B7EB8.nat.csx.cam.ac.uk) (Ping timeout)
[09:17:09] *** Joins: nsf (nsf@moz-EEF3238A.convex.ru)
[09:17:48] <Leo`> merf. I can't implement a trait for both T: Send and T: Freeze :|
[09:18:21] *** Quits: flowsnake (flowsnake@moz-E4E567EE.aztw.cable.virginm.net) (Ping timeout)
[09:18:28] <eddyb> those can overlap, AFAIK
[09:18:41] <eddyb> (even if they didn't, coherence doesn't allow it yet)
[09:18:44] <Leo`> :/
[09:18:45] <Leo`> :\
[09:18:47] <Leo`> :|
[09:19:01] <Leo`> I want to impl a trait for Rc<T>
[09:19:09] <Leo`> when T is Freeze, I must use Rc::new
[09:19:18] <Leo`> and when T is Send, I must use Rc::from_send
[09:19:46] <Leo`> (the trait is Decode)
[09:19:53] <Leo`> Decodable*
[09:20:26] <Leo`> Or I could use new_unchecked
[09:20:33] <Leo`> but not sure if I should
[09:22:19] *** Joins: flowsnake (flowsnake@moz-E4E567EE.aztw.cable.virginm.net)
[09:22:26] <eddyb> rusti: struct Foo<'self>{i: ~int, p: Option<&'self int>} impl<'self> Foo<'self> {fn new() -> ~Foo<'self> {let foo = ~Foo{i:~7,p:None};let this = unsafe { ::std::cast::transmute_mut(&*foo) };this.p=Some(&*(foo.i));foo}} Foo::new()
[09:22:27] -rusti- pastebinned 17 lines of output: http://sprunge.us/LUdP
[09:22:52] *** Quits: qrpth (andreas@moz-9C921D25.ut.ee) (Ping timeout)
[09:22:58] *** Joins: qrpth (andreas@DDED6099.A98A7324.783D9E8C.IP)
[09:23:44] <eddyb> pnkfelix: I can't do even that ^?
[09:24:29] <eddyb> err, I was doing something silly
[09:24:51] <eddyb> rusti: struct Foo<'self>{i: int, p: Option<&'self int>} impl<'self> Foo<'self> {fn new() -> ~Foo<'self> {let foo = ~Foo{i:7,p:None};let this = unsafe { ::std::cast::transmute_mut(&*foo) };this.p=Some(foo.i);foo}} Foo::new()
[09:24:52] -rusti- pastebinned 5 lines of output: http://sprunge.us/TbRS
[09:24:53] <pnkfelix> eddyb: Maybe the problem is that we cannot do this with a single lifetime parameter.  It is not possible to mutably-borrow Foo for the whole duration of its life.
[09:25:35] <eddyb> pnkfelix: I don't want a mutable borrow. I only need mutable to assign to the created value
[09:25:55] *** Quits: qrpth (andreas@DDED6099.A98A7324.783D9E8C.IP) (Ping timeout)
[09:26:08] *** Joins: sigma (sigma@moz-D4F04D48.range86-174.btcentralplus.com)
[09:26:21] <pnkfelix> eddyb: oh sorry, I was still looking at the previous examples where `bar` mutably borrowed, I had not yet looked at the latest postings.
[09:26:59] <eddyb> rusti: struct Foo<'self>{i: int, p: Option<&'self int>} impl<'self> Foo<'self> {fn new() -> ~Foo<'self> {let foo = ~Foo{i:7,p:None};{let this = unsafe { ::std::cast::transmute_mut(&*foo) };this.p=Some(&foo.i);}foo}} Foo::new()
[09:27:00] -rusti- pastebinned 17 lines of output: http://sprunge.us/QagN
[09:27:59] *** Joins: qrpth (andreas@moz-9C921D25.ut.ee)
[09:28:31] *** Quits: frogzilla (Mibbit@moz-3213C615.wavecable.com) (Quit: http://www.mibbit.com ajax IRC Client)
[09:28:36] <eddyb> http://sprunge.us/QagN?_ yay no wrapping
[09:28:39] *** Joins: weirdo (Mibbit@moz-3213C615.wavecable.com)
[09:29:54] *** Joins: Jackneill (Jackneill@moz-CA2E3320.pool.digikabel.hu)
[09:29:56] <eddyb> rusti: struct Foo<'self>{i: int, p: Option<&'self int>} impl<'self> Foo<'self> {fn new() -> ~Foo<'self> {let foo = ~Foo{i:7,p:None};{let this = unsafe { ::std::cast::transmute_mut(&*foo) };this.p=Some(&'self foo.i);}foo}} Foo::new()
[09:29:57] -rusti- pastebinned 17 lines of output: http://sprunge.us/iSEh
[09:31:39] *** Quits: Kxepal (Miranda@moz-88CB069F.pppoe.mtu-net.ru) (Ping timeout)
[09:34:31] *** Joins: Kxepal (Miranda@moz-AF2D243E.pppoe.mtu-net.ru)
[09:37:03] *** Quits: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP) (Ping timeout)
[09:37:06] <eddyb> rusti: struct Foo<'self>{i: int, p: Option<&'self int>} impl<'self> Foo<'self> {fn new() -> ~Foo<'self> {~Foo{i:7,p:None}}fn bar(&'self self){let this = unsafe { ::std::cast::transmute_mut(self) };this.p=Some(&'self self.i);}} let x = Foo::new(); x.bar(); let p = &x.i;
[09:37:07] -rusti- pastebinned 4 lines of output: http://sprunge.us/IPXL
[09:37:20] <eddyb> o_O it worked :D
[09:37:21] *** Joins: ssbr_ (~ssbr@46FE74EC.C60FE7DC.4065847B.IP)
[09:38:10] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[09:38:11] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Quit: lenstr)
[09:42:45] <eddyb> pnkfelix: but this means I have to hoist the initialization to the top-most level
[09:43:46] *** Quits: Dessimat0r (Dessimat0r@E879B262.8D4FD984.4320F744.IP) (Ping timeout)
[09:44:00] *** Quits: qrpth (andreas@moz-9C921D25.ut.ee) (Ping timeout)
[09:44:21] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[09:44:49] *** Quits: jeffdb_ (jeff@moz-ED35AD97.hsd1.ca.comcast.net) (Quit: jeffdb_)
[09:45:01] <pnkfelix> eddyb: what do you mean?
[09:45:01] <eddyb> pnkfelix: I was hoping I could use ~ and have more freedom with it (self-referencing is safe because ~ can't be moved around - although I'm not sure if that is enforced/relied upon)
[09:45:28] <pnkfelix> eddyb: if you're willing to use transmute_mut in the manner you illustrated, it seems to me that you can call `bar` from within `fn new` if you want
[09:45:45] <eddyb> nope, because that borrows foo and you can't "move out"
[09:46:04] <pnkfelix> eddyb:  I just did it and it worked for me
[09:46:15] <eddyb> rusti: struct Foo<'self>{i: int, p: Option<&'self int>} impl<'self> Foo<'self> {fn new() -> ~Foo<'self> {let foo=~Foo{i:7,p:None};foo.bar();foo}fn bar(&'self self){let this = unsafe { ::std::cast::transmute_mut(self) };this.p=Some(&'self self.i);}} let x = Foo::new(); let p = &x.i;
[09:46:16] -rusti- pastebinned 17 lines of output: http://sprunge.us/JBSa
[09:46:44] <pnkfelix> eddyb: okay, give me a sec
[09:46:54] <pnkfelix> eddyb: (let me compare what you wrote to what i did)
[09:46:55] <eddyb> rusti: struct Foo<'self>{i: int, p: Option<&'self int>} impl<'self> Foo<'self> {fn new() -> ~Foo<'self> {let foo=~Foo{i:7,p:None};foo.bar();foo}fn bar(&self){let this = unsafe { ::std::cast::transmute_mut(self) };this.p=Some(&self.i);}} let x = Foo::new(); let p = &x.i;
[09:46:56] -rusti- pastebinned 17 lines of output: http://sprunge.us/AeeK
[09:47:13] <pnkfelix> eddyb: or, okay, ignore my request.
[09:47:25] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Ping timeout)
[09:48:00] *** Joins: andre_ (andre@CA528A4A.45A4338E.8EE27E6.IP)
[09:48:12] <eddyb> pnkfelix: maybe I need something stronger than just transmute_mut. because that still borrows foo and that prevents moving
[09:48:29] <pnkfelix> eddyb: that's odd, your second to last example above compiled for me
[09:48:36] *** Joins: bungoman (bungoman@moz-F95B490C.tx.res.rr.com)
[09:48:39] <pnkfelix> rusti: version
[09:48:40] -rusti- "rustc 0.8"
[09:48:40] <eddyb> heh, must've been fixed since
[09:49:09] <pnkfelix> eddyb: yes, I think you should probably dev locally off master
[09:50:12] *** Joins: Shaladdle (shaladdle@moz-FDE833F3.wv.cc.cmu.edu)
[09:50:21] *** Quits: bungoman (bungoman@moz-F95B490C.tx.res.rr.com) (Ping timeout)
[09:50:23] <eddyb> thanks, that is actually awesome. let's see if I can move bar into new
[09:52:17] <eddyb> pnkfelix: ouch, it doesn't prevent doing the same thing without ~
[09:53:08] <eddyb> I guess transmute_mut is dangerous that way
[09:53:32] *** Joins: CarpNet (ac@moz-FD24B77.sohonet.co.uk)
[09:53:35] <pnkfelix> eddyb: that's why I said "if you're willing to use transmute_mut …"
[09:53:51] <pnkfelix> yay unsafety
[09:55:21] *** Joins: tulloch (tulloch@moz-BC895BC5.damtp.cam.ac.uk)
[09:55:37] <Thiez> on the mailinglist there is some talk of a dead code elimination pass, and I was wondering how that interacts with type inference
[09:55:50] <Thiez> rusti: let x = 5; if false { let _y: u8 = 1+x; } x // Like so.
[09:55:50] -rusti- 5u8
[09:55:53] *** Joins: dsirenko (mitra@8E712A0.54C21BA0.9F317420.IP)
[09:56:11] <dbaupp> Thiez: I think that'd just mean that it was not trans-d
[09:56:30] <Thiez> ok, nice
[09:57:04] <dbaupp> (also, it was only for unused functions and items; we actually already avoid transing branches like `if false { ... }`.)
[09:57:19] <Thiez> even nicer.
[10:02:55] *** Joins: nkoep (nik@moz-D8197C3D.pool.mediaways.net)
[10:03:04] <kimundi> Hm, was that talk earlier about getting disjunct &mut T out of a &mut[T] ? Because we have a emthod for that
[10:04:22] *** Joins: qrpth (andreas@moz-BF31195A.campusnet.ee)
[10:04:59] <dbaupp> kimundi: with match
[10:05:18] <dbaupp> kimundi: (and s/disjunct/disjoint/ :P )
[10:06:07] <kimundi> Don'T know about match, but mut_split(n) gives you a (&mut[T], &mut[T]) seperated at the n
[10:06:46] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[10:07:18] <kimundi> Using that, you could write a iterator that consumes a &'a mut[T] and yields &mut T for each element
[10:08:07] <dbaupp> kimundi: https://github.com/mozilla/rust/issues/8636#issuecomment-29184137
[10:08:22] <weirdo> What's the rust equivalant of putchar?
[10:08:30] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[10:08:47] * weirdo really should rtfm more...
[10:09:04] <kimundi> rusti: println!("{}", 'h')
[10:09:05] -rusti- h
[10:09:05] -rusti- ()
[10:09:59] *** Joins: Dessimat0r (Dessimat0r@E879B262.8D4FD984.4320F744.IP)
[10:10:57] <dbaupp> rusti: std::io::stdout().write(['h' as u8])
[10:10:58] -rusti- h()
[10:12:41] *** Joins: Ms2ger (Ms2ger@moz-4040811E.ugent.be)
[10:14:33] <kimundi> not sure if you should do it that way :P
[10:14:44] *** Quits: tiffany (kawaii@moz-FC0DB29D.dhcp.embarqhsd.net) (Ping timeout)
[10:14:51] <kimundi> Doesn't play very nice with unicode
[10:15:02] *** Quits: Dessimat0r (Dessimat0r@E879B262.8D4FD984.4320F744.IP) (Ping timeout)
[10:15:03] <dbaupp> kimundi: does C's putchar? :P
[10:15:13] <kimundi> Oh, so it was C
[10:15:23] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[10:15:48] <kimundi> Still, that bad rust code :P
[10:16:01] *** Quits: nkoep (nik@moz-D8197C3D.pool.mediaways.net) (Ping timeout)
[10:16:38] *** Joins: tiffany (kawaii@moz-FC0DB29D.dhcp.embarqhsd.net)
[10:16:46] *** Joins: Dessimat0r (Dessimat0r@E879B262.8D4FD984.4320F744.IP)
[10:18:53] *** Joins: Earnestly (earnest@38FE72A5.82423D8F.BFD1ABFD.IP)
[10:19:00] *** Joins: mikezaby (mikezaby@moz-AA896205.home.otenet.gr)
[10:19:07] *** Parts: mikezaby (mikezaby@moz-AA896205.home.otenet.gr) ()
[10:19:21] <weirdo> What's incrementation in rust?
[10:20:45] *** Quits: heftig (heftig@moz-E7FBFCE3.dip0.t-ipconnect.de) (Quit: Quitting)
[10:20:47] <kimundi>  += 1
[10:22:27] <weirdo> Got it.
[10:23:56] <eddyb> ::std::int::increment(i);
[10:24:06] <weirdo> I can't get this bytebeat program to work. Halp? https://pastee.org/khch8
[10:24:50] <eddyb> weirdo: what's the error?
[10:25:03] <eddyb> also, t vs time
[10:25:18] <dbaupp> rusti: std::io::stdout::write(1)
[10:25:19] -rusti- pastebinned 11 lines of output: http://sprunge.us/EXaT
[10:25:37] <dbaupp> (oh, wait, that'll never work, it's 0.8)
[10:25:41] <eddyb> myeah
[10:26:03] * weirdo curses xterm non-copyability
[10:26:46] <eddyb> both gterm (or whatever its name is) and konsole have copy/paste
[10:27:18] <dbaupp> weirdo: it's an unresolved import, right?
[10:27:30] <weirdo> Yeah.
[10:28:27] <dbaupp> you cannot import methods like that
[10:28:49] *** Joins: amro (quassel@moz-6B07CBDB.wifihubtelecom.net)
[10:28:59] <eddyb> well, from what I've seen, stdout is a function not a module
[10:29:03] <dbaupp> use s = std::io::stdout; ... s.write(...)
[10:29:09] <dbaupp> err, s().write
[10:29:23] <eddyb> or out().write
[10:29:52] <eddyb> let out = stdout(); let put = out.write.bind(out);
[10:30:01] <eddyb> can't wait for Fn :D
[10:30:18] <dbaupp> that would be better as `Writer::write.bind(out)`
[10:30:25] *** Joins: nkoep (nik@moz-CA8EF11D.vpn.rwth-aachen.de)
[10:30:58] <eddyb> dbaupp: eeeeh, Writer:: makes it less obvious
[10:31:20] <dbaupp> eddyb: well out.write.bind(out) seems really strange
[10:31:37] <dbaupp> you're mentioning "self"
[10:31:46] <dbaupp> ... twice
[10:31:55] <eddyb> a common pattern in JS :P
[10:31:55] <dbaupp> it could just be `let put  = out.write;`
[10:32:08] <dbaupp> Rust != JS
[10:32:13] <eddyb> that just gives you the function, it's not bound
[10:32:31] <eddyb> dbaupp: that's where I was taking the bind semantics from
[10:32:45] <dbaupp> right, but in rust the unbound method would be Write::write
[10:32:58] <dbaupp> *Writer
[10:33:24] <eddyb> hmm, that makes sense. but taking out.write becomes magic
[10:33:38] <dbaupp> yes, and it would conflict with field access
[10:34:13] <weirdo> Sorry, I have a hard time following. Can I have a diff?
[10:34:30] *** Quits: zmthy (tim@moz-C2881CC3.ecs.vuw.ac.nz) (Quit: leaving)
[10:35:25] *** Joins: ricepuddin (graham@moz-7D68765A.cable.virginm.net)
[10:35:56] <dbaupp> weirdo: https://gist.github.com/huonw/85070667d0d8b5a35cf3
[10:35:59] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Ping timeout)
[10:36:04] <eddyb> dbaupp: I guess we'll have this discussion after we get the ability to implement that bind in the library
[10:36:17] <dbaupp> eddyb: yes
[10:36:46] <eddyb> .bind(_, foo, bar, _, baz) would be interesting to see
[10:37:11] <eddyb> () could be used for _, if the function doesn't have that in its arguments. maybe another unit struct
[10:37:23] <dbaupp> most of .bind can be done "manually" with a closure, right?
[10:37:41] <dbaupp> `foo.bind(_, bar)` == `|arg| foo(arg, bar)`
[10:37:54] <eddyb> or !. but that's hard to use
[10:38:04] <weirdo> dbaupp: It seems out.write.bind() takes a fn() argument.
[10:38:12] <weirdo> Using master btw.
[10:38:14] <eddyb> o_O
[10:38:17] <dbaupp> weirdo: there is no .bind?
[10:38:30] <dbaupp> weirdo: are you looking at my gist?
[10:38:39] * weirdo nods
[10:38:47] <dbaupp> yup, no .bind
[10:38:53] <eddyb> weirdo: my bind discussion is hypothetical, sorry about any confusion
[10:39:25] <eddyb> dbaupp: well, yeah, but bind has implicit rest args forwarding
[10:39:33] <weirdo> bytebeat.rs:4:14: 4:23 error: attempted access of field `write` on type `fn() -> std::io::stdio::StdWriter`, but no field with that name was found bytebeat.rs:4     let put = out.write.bind(out);                             ^~~~~~~~~
[10:39:36] *** Quits: amro (quassel@moz-6B07CBDB.wifihubtelecom.net) (Ping timeout)
[10:39:58] <eddyb> dbaupp: what have I done >_>?
[10:40:06] * weirdo actually rtfm now
[10:40:30] <eddyb> weirdo: use only this: https://gist.github.com/huonw/85070667d0d8b5a35cf3
[10:41:23] <dbaupp> weirdo: (I just added another possibility as cached.rs)
[10:41:33] <weirdo> bytebeat.rs:4:16: 4:25 error: attempted access of field `write` on type `fn() -> std::io::stdio::StdWriter`, but no field with that name was found
[10:42:00] <eddyb> weirdo: you're still not using it right. you need to call stdout/out
[10:42:14] <dbaupp> weirdo: with `use out = std::io::stdout` out is a function that returns a handle to the stdout writer.
[10:42:26] <dbaupp> (not the actual handle itself)
[10:42:32] <weirdo> eddyb: I used your gist. ;)
[10:42:36] <eddyb> weirdo: why are you not using a graphical editor?
[10:42:52] <dbaupp> weirdo: did you have `out.write(...)`?
[10:43:00] *** Joins: bungoman (bungoman@moz-F95B490C.tx.res.rr.com)
[10:43:10] *** relrod_ is now known as relrod
[10:43:11] <dbaupp> weirdo: because the gist with the `use` has `out().write(...)`
[10:43:20] <eddyb> weirdo: it seems like you're making this harder than it needs to be. any of the two files in dbaupp's gist will work
[10:43:26] *** Quits: sigma (sigma@moz-D4F04D48.range86-174.btcentralplus.com) (Client exited)
[10:43:31] <eddyb> if you could copy/paste
[10:43:46] <weirdo> eddyb: Nevermind. It worked.
[10:44:41] *** Quits: bungoman (bungoman@moz-F95B490C.tx.res.rr.com) (Ping timeout)
[10:45:12] <weirdo> If I benchmark this, should I use the code as is?
[10:46:01] <dbaupp> what do you mean by that?
[10:46:18] <weirdo> When comparing it to the C equivalant?
[10:46:33] <dbaupp> you should at least used the cached.rs one
[10:46:59] <dbaupp> by "default" it'll be slower
[10:47:01] <dbaupp> since libuv has overheads
[10:47:05] <eddyb> you can probably buffer a word at a time or something
[10:47:29] <dbaupp> if you put `#[no_uv];` on the crate (i.e. at the top of the file, with the `;`) it may be faster.
[10:48:09] <eddyb> weirdo: also, t doesn't have an explicit type, the behavior might depend on that
[10:48:23] *** Quits: Dessimat0r (Dessimat0r@E879B262.8D4FD984.4320F744.IP) (Ping timeout)
[10:48:34] <dbaupp> (it may also not work with #[no_uv];... not sure how complete it's implementation is.)
[10:48:55] *** Quits: qrpth (andreas@moz-BF31195A.campusnet.ee) (Ping timeout)
[10:49:00] <eddyb> I think it will default to int, which is intptr_t, i64 instead of i32 on x86_64
[10:49:29] *** Joins: CyBeRKeL (cyber@6B32985E.19FBB262.E24837B7.IP)
[10:51:10] <eddyb> rusti: let mut v = [0u8, ..16]; v.len()
[10:51:10] -rusti- <anon>:9:17: 9:18 warning: variable does not need to be mutable [-W unused-mut (default)]
[10:51:10] -rusti- <anon>:9          let mut v = [0u8, ..16]; v.len()
[10:51:11] -rusti-                           ^
[10:51:11] -rusti- 16u
[10:51:44] *** Quits: brson (brson@6A848D32.C1B840DD.76F66111.IP) (Quit: leaving)
[10:52:01] <eddyb> rusti: let mut v = [0u8, ..16]; for x in v.iter() {*x = 5;} v
[10:52:02] -rusti- <anon>:9:53: 9:55 error: cannot assign to immutable dereference of & pointer
[10:52:02] -rusti- <anon>:9          let mut v = [0u8, ..16]; for x in v.iter() {*x = 5;} v
[10:52:02] -rusti-                                                               ^~
[10:52:02] -rusti- error: aborting due to previous error
[10:52:02] -rusti- application terminated with error code 101
[10:53:03] <eddyb> weirdo: you could fiddle with this one https://gist.github.com/eddyb/efd922e82df7896880e6
[10:53:19] *** Joins: qrpth (andreas@39EED39.590DF183.783D9E8C.IP)
[10:55:59] * eddyb can't wait until ~[] is just (0, 0)
[10:56:51] <eddyb> (0 , 0) - even better
[10:57:09] <Ms2ger> (0_0)?
[10:57:33] *** Joins: donri (donri@moz-9BB61102.tbcn.telia.com)
[10:57:41] <eddyb> rusti: (0_0)
[10:57:42] -rusti- 0
[10:57:50] <weirdo> eddyb: Thanks.
[11:01:58] <eddyb> weirdo: you can change the 16 there to control the buffer size - you should try various powers of 2 until you find something that's fast. it depends on whether you have #[no_uv] or not
[11:03:36] <dbaupp> (you can probably also just use http://static.rust-lang.org/doc/master/std/io/buffered/struct.BufferedWriter.html rather than managing the buffer yourself, although it's probably marginally slower.)
[11:06:16] <dbaupp> eddyb, weirdo: that can be `for byte in v.mut_iter() { *byte = (... things ...); t += 1) }` which avoids bounds checks
[11:06:27] <dbaupp> s/1)/1;/
[11:06:32] <eddyb> which bound checks?
[11:06:49] <dbaupp> v[i]
[11:07:04] <eddyb> wouldn't that be optimized away?
[11:07:19] <dbaupp> can't rely on it
[11:07:23] <dbaupp> LLVM isn't great at it
[11:07:23] <eddyb> I wasn't sure how to use the mut_iter, that would've been better :P
[11:07:37] <eddyb> dbaupp: it can unroll the loop, can't it?
[11:07:41] <dbaupp> (that is, according to strcat, LLVM isn't great)
[11:07:51] <dbaupp> eddyb: don't know, have to check the IR.
[11:08:14] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[11:08:15] <kimundi> It really seems to me that indexing is pretty much obsoleted in rust at this point :P
[11:08:46] <dbaupp> kimundi: except when you need random access
[11:08:56] <eddyb> RAI pls
[11:09:07] <dbaupp> (or modifying a vector while iterating)
[11:09:17] <kimundi> Yeah, true
[11:09:24] <eddyb> kimundi: I want this to work at some point: mat[i, j]
[11:09:25] <dbaupp> eddyb: that's still indexing, just with a method call :P
[11:09:33] <dbaupp> (RAI)
[11:09:37] *** flaper87 is now known as flaper87|afk
[11:09:46] <kimundi> eddyb: Sure, thats slicing, that would be a nice extension of the indexing syntax
[11:10:24] <eddyb> since , not being an operator is pretty baked in the language
[11:10:35] *** Quits: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net) (Quit: Sharp)
[11:10:39] <eddyb> kimundi: mat would be a matrix :P
[11:10:43] <kimundi> It just seems to me as if a lot of the reasons the indexing syntax existed for are now an anti pattern in rust
[11:10:50] <kimundi> oh
[11:10:54] <kimundi> well
[11:11:03] <kimundi> not sure if this would work then
[11:11:03] <eddyb> variadic Index, mentioned this about a week ago
[11:11:05] *** Joins: Sorella (quildreen@9D963F5D.DF5D8AE7.54BCAB54.IP)
[11:11:10] *** flaper87|afk is now known as flaper87
[11:11:25] <dbaupp> eddyb: not everyone is paying attention all the time (or remembering things from a week ago)
[11:11:26] <kimundi> I gues variadic index and slicing could coexist if one oses , and the other ..
[11:12:02] <kimundi> x[a..b] // slice
[11:12:03] <eddyb> dbaupp: saying that just so I don't repeat myself to people who've read it
[11:12:10] <kimundi> x[a, b] // variadic index
[11:12:41] <eddyb> mat[(), j] could be a ColumnView :D
[11:12:42] <dbaupp> meh, x[(a,b)] isn't much more noise and it doesn't require special casing.
[11:12:51] *** Joins: SingingBoyo (brandon@DA28FB90.A5D0D593.4F048BDC.IP)
[11:13:00] * kimundi will be so happy if we get variadics. And macros that expand to multible items. And DST.
[11:13:11] <eddyb> after the Fn trait, variadic Index wouldn't be special casing
[11:13:33] <eddyb> kimundi: heeeeeey I have an idea
[11:13:34] <SingingBoyo> Is there a way to get the compiler to warn at a specific line?  IE for methods with dummy implementations?
[11:13:37] <dbaupp> kimundi: keep up https://github.com/mozilla/rust/pull/10649 :P
[11:13:53] <eddyb> a..b => range(a, b)
[11:14:04] <eddyb> then a slice is just one impl of Index
[11:14:11] <kimundi> dbaupp: I know! Finally a PR for that, exciting! :D
[11:14:30] <eddyb> mat[a..b, c..d] OMG
[11:14:32] *** Quits: CyBeRKeL (cyber@6B32985E.19FBB262.E24837B7.IP) (Ping timeout)
[11:14:51] <dbaupp> eddyb: that's how python does it
[11:15:05] <eddyb> for i of 0..9
[11:15:12] <dbaupp> SingingBoyo: `foo.span_warn(span_of_item, ...)`?
[11:15:21] <eddyb> soooo, infix ..?
[11:15:46] <kimundi> eddyb: I have a feeling people won't care much about making range() use special syntax, though
[11:15:54] <SingingBoyo> dbaupp: span_warn?  never heard of it... is  there a doc page somewhere?
[11:16:42] <eddyb> kimundi: but it's better than making v[a..b] special, I would think, since you can reuse it for other things
[11:17:16] <eddyb> (I guess we need to fix the multiple implementations of a generic trait problem, Index won't work like that right now)
[11:17:23] <dbaupp> SingingBoyo: oh, you don't mean in the compiler? just in user code?
[11:17:31] <dbaupp> SingingBoyo: I don't think there is a way.
[11:17:52] <dbaupp> eddyb: you can work around the trait thing
[11:18:12] <eddyb> also impl on builtins
[11:18:29] <eddyb> dbaupp: how?
[11:18:29] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[11:18:55] <dbaupp> trait VecIndex { fn index(&self, vec: &[...]) } impl VecIndex for uint { ... } impl VecIndex for Range { ... } impl<'self, I: VecIndex> Index<I, T> for &'self [T] { .. }
[11:19:18] <eddyb> aaaah, a generic impl forward to multiple impls
[11:19:23] <dbaupp> yes
[11:19:27] <dbaupp> it sucks
[11:19:28] <dbaupp> :(
[11:19:55] <SingingBoyo> dbaupp: yeah.  Ah well, guess it's time to use TODO comments
[11:20:09] *** Joins: CyBeRKeL (cyber@6B32985E.19FBB262.E24837B7.IP)
[11:20:11] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[11:20:28] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[11:23:44] *** Quits: SingingBoyo (brandon@DA28FB90.A5D0D593.4F048BDC.IP) (Ping timeout)
[11:23:51] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[11:25:07] *** Joins: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP)
[11:25:26] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[11:25:54] *** Joins: squiddy (squiddy@moz-27C0E5BE.adsl.alicedsl.de)
[11:29:29] *** jorendorff_away is now known as jorendorff
[11:32:20] *** Joins: sigma (sigma@moz-D4F04D48.range86-174.btcentralplus.com)
[11:35:57] *** Joins: vmx (vmx@moz-35026133.dip0.t-ipconnect.de)
[11:36:53] *** Joins: bungoman (bungoman@moz-F95B490C.tx.res.rr.com)
[11:38:38] *** Quits: bungoman (bungoman@moz-F95B490C.tx.res.rr.com) (Ping timeout)
[11:41:05] *** Quits: Ms2ger (Ms2ger@moz-4040811E.ugent.be) (Quit: bbl)
[11:44:40] <eddyb> pnkfelix: this feels like a bug. same code, works only in a method. maybe it's the auto-borrowing being different than &*ctx
[11:46:34] *** Joins: Krymise (Nietzsche@moz-CA789EF5.nwrknj.fios.verizon.net)
[11:47:16] <eddyb> hahaha, I have to do: let ctx: &Context = ctx;
[11:47:33] <eddyb> (where ctx is a ~Context)
[11:52:12] <eddyb> fn dis(&self, ${b}: &[u8], ${(new RegExp(String.raw`\b${i}\b\s+[-+]?=`).test(items.dis) ? 'mut ' : '')+i}: uint) -> u8 {
[11:52:17] *** Quits: moostik (Icedove@moz-63ED7231.w82-121.abo.wanadoo.fr) (Ping timeout)
[11:52:20] <eddyb> my code has become such a mess >_>
[11:52:56] <ssbr_> eddyb: oh, are you implementing regexps?
[11:53:04] <eddyb> nope
[11:53:11] <ssbr_> what's going on here
[11:53:18] <eddyb> that's a small piece of ES6 code generating Rust code
[11:53:39] <ssbr_> eddyb: well that does explain why I couldn't understand half of the syntax going on there
[11:53:50] <eddyb> ${x} is inserting x in a raw/template string
[11:55:04] *** Quits: Shaladdle (shaladdle@moz-FDE833F3.wv.cc.cmu.edu) (Quit: Leaving)
[11:55:24] *** Joins: moostik (Icedove@moz-C2FFB694.w82-121.abo.wanadoo.fr)
[11:58:29] *** Joins: heftig (heftig@moz-E8E2034C.inf.fh-bonn-rhein-sieg.de)
[11:59:13] *** Joins: sk (sk@61A494B3.BA40E8A.AAC02D62.IP)
[12:00:18] *** Joins: Heather (Heather@19663F6.F53BAACC.9C17E900.IP)
[12:00:26] <Heather> Hey
[12:00:34] <Heather> how to get env variable I forgot....
[12:00:38] <Heather> env! ?
[12:01:17] <hoelzro> that's at compiler time, though, isn't it?
[12:01:22] <ssbr_> Heather: stuff like that is in the os module
[12:01:23] <ssbr_> http://static.rust-lang.org/doc/master/std/os/index.html
[12:01:37] <Heather> I need live time...
[12:01:39] <Heather> wait
[12:01:40] <Heather> hoelzro
[12:01:43] <Heather> hoelzro Hello :D
[12:01:47] <hoelzro> hi!
[12:01:54] <Heather> hoelzro I think I remember you from #perl6
[12:01:59] <hoelzro> yes!
[12:02:04] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[12:02:18] <Heather> hoelzro got interesting in rust also? :)
[12:02:29] *** Quits: tulloch (tulloch@moz-BC895BC5.damtp.cam.ac.uk) (Ping timeout)
[12:02:32] <hoelzro> yes
[12:02:37] *** Quits: Krymise (Nietzsche@moz-CA789EF5.nwrknj.fios.verizon.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[12:02:38] <Heather> ssbr_ thanks
[12:02:45] <hoelzro> they're both neat languages
[12:02:49] <hoelzro> I like trying new things =)
[12:02:50] <Heather> yep
[12:03:12] <Heather> I've heard lots of critics about both )
[12:03:51] <eddyb> ES6 > Perl IMO. but I haven't looked at Perl 6 in detail
[12:04:30] <eddyb> but Rust is a different kind of crazy :P
[12:04:34] *** Joins: tulloch (tulloch@moz-BC895BC5.damtp.cam.ac.uk)
[12:04:39] <hoelzro> hehe
[12:04:46] <hoelzro> a different kind of crazy you can write an OS in ;)
[12:05:20] *** Quits: qrpth (andreas@39EED39.590DF183.783D9E8C.IP) (Ping timeout)
[12:05:28] <ssbr_> if all but ~500 LOC are in ruby, is the OS written in ruby?
[12:05:36] *** Joins: Krymise (Nietzsche@moz-CA789EF5.nwrknj.fios.verizon.net)
[12:05:48] <Heather> how can I write something alike let a, b = 1, 2 ?
[12:05:56] <eddyb> Heather: (a, b) = (1, 2)
[12:05:59] *** Joins: quvarxa_ (chatzilla@moz-978E4C31.static.tpgi.com.au)
[12:06:00] <hoelzro> ssbr_: that's a good question
[12:06:02] <ssbr_> Heather: let a = 1; let b = 2;
[12:06:11] *** Quits: quvarxa (chatzilla@moz-978E4C31.static.tpgi.com.au) (Ping timeout)
[12:06:11] *** quvarxa_ is now known as quvarxa
[12:06:12] <eddyb> ssbr_: nah, we have destructuring let
[12:06:25] <Heather> eddyb that's cool, let me try it )
[12:06:26] <ssbr_> eddyb: just because a thing exists doesn't mean it's a good idea
[12:06:28] <kimundi> rusti: let (a, b) = (1, 2); a + b
[12:06:29] -rusti- 3
[12:06:33] <Heather> just like in F#
[12:06:40] *** Quits: moostik (Icedove@moz-C2FFB694.w82-121.abo.wanadoo.fr) (Ping timeout)
[12:06:41] <ssbr_> I've used enough languages with destructuring bind to avoid this pattern
[12:06:51] <ssbr_> it starts out as let (a, b) = (1, 2)
[12:06:59] <kimundi> ssbr_: Hum, I've yet to see someone saying that using destructuring for that is bad
[12:07:15] <eddyb> too bad (a, b) = (b, a); doesn't work
[12:07:20] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Ping timeout)
[12:07:22] <myname> indeed
[12:07:31] *** Joins: Dessimat0r (Dessimat0r@E879B262.8D4FD984.4320F744.IP)
[12:07:31] <ssbr_> and then 3 years later it's let (a, b, e, d, f, koopa, clutz) = (1, 2, "harp", 4, ~[], ~"", 1)
[12:07:34] <hoelzro> oh man, I love destructuring bind...
[12:07:52] <ssbr_> deliberately constructing a tuple just to destructure it in an assignment is not good style.
[12:08:04] <kimundi> ssbr_: That sounds like the problem happend during the 3 years :P
[12:08:07] <ssbr_> question: which variable was assigned to 4?
[12:08:19] <eddyb> d, I think
[12:08:27] <ssbr_> correct!
[12:08:36] <myname> obviously!
[12:08:51] <kimundi> tuple destructuring is useful in other places too, though
[12:08:56] <ssbr_> I should've made that invalid syntax and been all "trick question!", but that would've looked stupid on my part
[12:08:59] <ssbr_> kimundi: yes
[12:09:06] <ssbr_> let (a, b) = foo; is great code
[12:09:23] <kimundi> match (a, b) { (Some(x), None) => ... (None, Some(y)) => ... }
[12:09:31] <ssbr_> but if you want to do multiple assignments on one line, that's what semicolons are for
[12:09:50] *** Joins: Kingsley (kingsley@9B172CBE.BEA5C56D.DF4B730F.IP)
[12:10:06] <kimundi> ssbr_: Maybe we just need a lint that starts complining once the tuple gets to overloaded :P
[12:10:09] <ssbr_> kimundi: yes, that's also a cool pattern! :D
[12:10:26] <kimundi> ANyway, I see the problem
[12:10:26] <eddyb> (I know a way to fix the assignment, that is (a, b) = (b, a), by using the expr as an otherwise costless cover grammar for a pattern)
[12:10:42] <ssbr_> kimundi: yeah, although it's the sort of problem that creeps up on you and won't ever be fixed unless you never started down that road anyway, probably
[12:11:11] <kimundi> ssbr_: I hate those problems :P
[12:11:17] <Heather> eh.... damn "borrowed value don't live long enough"
[12:11:35] <dbaupp> `#[warn(too_many_commas_one_line)];`
[12:11:43] <dbaupp> *_on_one_line
[12:11:54] <kimundi> That sounds useful! ;)
[12:11:58] <Heather> it's error....
[12:11:59] <eddyb> two commas one line
[12:12:20] <ssbr_> two commas enter, only one will leave.
[12:12:31] <Heather> wait there was workaround on this bug
[12:12:32] <eddyb> ssbr_: stop making it innocent
[12:12:35] <Heather> I just forgot it
[12:12:37] <eddyb> Heather: what bug?
[12:12:46] <Heather> 01"borrowed value don't live long enough"01
[12:12:52] <kimundi> It'S black again
[12:12:54] <eddyb> that's not a bug, that's your fault :P
[12:12:54] *** Quits: Sgeo (quassel@moz-D0F30617.dyn.optonline.net) (Connection reset by peer)
[12:12:54] <dbaupp> eddyb: stop making it guilty :P
[12:12:55] <Heather> when I need additional let
[12:12:55] <ssbr_> Heather: borrow the value for longer.
[12:13:00] <myname> you mean, there is a workaround for this expected behaviour?
[12:13:04] <dbaupp> eddyb: it can be a bug
[12:13:32] <kimundi> We won'T ever know without more context
[12:13:33] <dbaupp> foo.bar().baz().qux() sometimes needs to be `let tmp = foo.bar(); tmp.baz().qux()`
[12:13:56] <eddyb> dbaupp: the error message itself isn't associated with a bug
[12:14:21] <Heather> .as_ref().map    (|s| s.as_slice()) ?
[12:14:32] <dbaupp> eddyb: yes, it can be, that bug^
[12:14:46] <dbaupp> eddyb: https://github.com/mozilla/rust/issues/3511
[12:14:54] <eddyb> dbaupp: without context, that is
[12:15:03] <eddyb> you might know too much >_>
[12:15:17] <kimundi> Heather: What is the type of s ?
[12:15:34] <dbaupp> eddyb: without context it's still associated with that bug, since it can be caused by it.
[12:15:40] <Heather> don't know... but maybe it's not solution for me....
[12:15:52] <eddyb> Heather: what's to the left of .as_ref?
[12:15:58] <Heather> I've got :     let (cfg, appCfg) =  if nix  {(    & Path::new ( "~/.Sync.conf" ) ,
[12:15:59] <kimundi> Heather: What is the type of the iterator your calling as_Ref on then?
[12:16:15] <kimundi> oh wait, it's an option, right?
[12:16:18] <eddyb> (not the random spaces again)
[12:16:52] <Heather> eddyb it's what I used to avoid additional let in other situation
[12:16:55] <kimundi> Heather: COuld you just put the whole code on https://gist.github.com/ ?
[12:17:08] <dbaupp> eddyb: that comment is unnecessary, please try to keep things either useful or positive :)
[12:17:12] <Heather> kimundi yes it's becoming to complex to guess
[12:17:39] *** Joins: smarter (smarter@moz-9C03B7C7.cust.bluewin.ch)
[12:17:46] <Heather> kimundi https://gist.github.com/Heather/7640445
[12:18:21] <eddyb> there's no .as_ref().map    (|s| s.as_slice()) there
[12:18:35] <dbaupp> Heather: remove the `&`'s and it should work ok
[12:18:40] <Heather> eddyb right ... and I think if I can solve error I get with it
[12:18:43] <dbaupp> (you may need to add some later)
[12:18:59] <dbaupp> (later == lower in the code)
[12:19:07] <Heather> I think I  could add & before if
[12:19:29] <eddyb> Heather: why do you have the & in the first place?
[12:19:30] <dbaupp> I guess `let (ref cfg, ref appCfg) = if ... ` might work too
[12:19:38] <dbaupp> eddyb: because she needs &Path later
[12:19:41] *** Joins: qrpth (andreas@moz-9C921D25.ut.ee)
[12:20:05] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[12:20:05] *** Quits: quvarxa (chatzilla@moz-978E4C31.static.tpgi.com.au) (Quit: ChatZilla 0.9.90.1 [Firefox 26.0/20131118212339])
[12:20:18] <eddyb> not sure if ref will work. you can surely borrow a local though
[12:20:49] <Heather> ref works ....
[12:21:13] <Heather> dbussink thanks
[12:21:17] <Heather> dbaupp ^
[12:21:31] <Heather> eddyb kimundi gist update : https://gist.github.com/Heather/7640445
[12:21:51] <kimundi> Hm, you might also want to not use string concatenation there
[12:22:32] <dbaupp> Heather: btw, if nix is false, and $HOME is set (say to /home/Heather), you end up with `/home/Heather~/.Sync.conf` as cfg
[12:22:36] <Heather> kimundi right.... with format ?
[12:23:00] <kimundi> No, wrap the path fragments in Path objects, and use the concatenation functions there
[12:23:06] <Heather> dbaupp yes, it's typo
[12:23:46] <dbaupp> `let home = Path(genenv("HOME").unwrap_or(~"")); (home.join(".Sync.conf"), home.join(".Mirana.conf"))`
[12:23:57] <kimundi> Yeah, what dbaupp says
[12:24:04] <eddyb> that's what I was going to write, but I wasn't sure how Path works :P
[12:24:39] <eddyb> dbaupp: do we have an official style guide, with examples? sometimes I could just refer to points there
[12:24:41] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[12:24:56] <eddyb> Google has guides for a few languages and they're pretty solid
[12:24:59] <Heather> dbaupp `~str` does not implement any method in scope named `join`
[12:25:10] <Heather> ah...
[12:25:13] <Heather> on Path....
[12:25:14] *** Joins: Shaladdle (Shaladdle@moz-424BC304.hsd1.pa.comcast.net)
[12:25:17] *** Quits: Shaladdle (Shaladdle@moz-424BC304.hsd1.pa.comcast.net) (Quit: Shaladdle)
[12:25:24] <eddyb> that might be Path::new, btw
[12:25:27] <Heather> it's not logical
[12:25:27] <dbaupp> eddyb: https://github.com/mozilla/rust/wiki/Note-style-guide but it's probably not precisely what you're looking for
[12:25:39] <dbaupp> it is logical
[12:26:02] <dbaupp> to append things to a path you need to start with a path
[12:26:17] *** Joins: ofeldt (ofeldt@moz-3961C767.dip0.t-ipconnect.de)
[12:26:25] <Heather> dbaupp why? for me it soundsd better to operate on strings before create object.
[12:26:29] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[12:26:31] <kimundi> Heather: The problem is that filesystem paths are hard. :) Using strings for manipulating them just leads to bugs or just doesn't work at all
[12:26:50] <eddyb> Heather: working on Path objects isn't slower than using strings
[12:26:54] *** victorporof is now known as victorporof|away
[12:26:58] <kimundi> Heather: In fact, you can't use strings for paths at all on linux.
[12:27:13] <Heather> kimundi why
[12:27:24] *** Quits: ofeldt- (ofeldt@moz-CBEAEFD1.dip0.t-ipconnect.de) (Ping timeout)
[12:27:27] <kimundi> Heather: On linux, a filesystem path is just binary data, not utf8 as rust strings are
[12:27:34] <strcat> kimundi: depends on the filesystem
[12:27:34] <dbaupp> Heather: if you're working with paths you should be using Path, if you're working with strings you should be using str (just like if you're working with numbers use f64 or u32 or whatever, not str)
[12:28:00] <eddyb> dbaupp: https://code.google.com/p/google-styleguide/
[12:28:02] <kimundi> strcat: True
[12:28:07] <Heather> I see...
[12:28:08] <strcat> most filesystems allow any bytes other than / and \0 but some like UDF are Unicode
[12:28:10] <dbaupp> eddyb: I know them
[12:28:14] <eddyb> nvm then :P
[12:28:50] <strcat> in fact I think UDF allows / in path names
[12:28:51] <dbaupp> (this discussion is moot anyway, we need a getenv that returns ~[u8] rather than ~str; and a os::args() that does the same)
[12:29:23] <kimundi> Heather: That's also the reason why the Path type has not to_str() impl - It'S simply not possible to turn every possible path into a displayable unicode string
[12:29:34] <kimundi> (At least not in a reversible fashion)
[12:30:01] <Heather> updated gist https://gist.github.com/Heather/7640445
[12:30:02] <kimundi> dbaupp: Yeah
[12:30:12] <eddyb> couldn't it return an Option<~str> or something?
[12:30:43] <dbaupp> eddyb: that would work as a way to avoid crashing, but not to get at the data itself.
[12:30:50] *** Quits: sigma (sigma@moz-D4F04D48.range86-174.btcentralplus.com) (Client exited)
[12:31:02] <ssbr_> Either<~[u8], ~str>
[12:31:03] *** Joins: bungoman (bungoman@moz-F95B490C.tx.res.rr.com)
[12:31:06] <kimundi> Heather: "/.Sync.conf" -> ".Sync.conf"
[12:31:07] <eddyb> Heather: out of curiosity, what are you passing these paths to?
[12:31:34] <Heather> kimundi okay
[12:31:39] <dbaupp> ssbr_: that's kinda ugly if you do actually want a ~[u8]
[12:31:41] <Heather> eddyb config files for app
[12:31:58] <eddyb> Heather: ~ is usually expanded by the shell, to $HOME. it shouldn't work as an argument to a fs/io API
[12:32:04] <eddyb> s/as an/in an/
[12:32:06] <dbaupp> (I'd personally say getenv() -> ~[u8], getenv_utf8() -> Option<~str>.)
[12:32:44] *** Quits: bungoman (bungoman@moz-F95B490C.tx.res.rr.com) (Ping timeout)
[12:32:53] <Heather> eddyb hm.... right I should use HOME env for both
[12:33:03] <Heather> eddyb maybe don't do if nix at all
[12:33:08] <eddyb> Heather: yeah, there's no point in that if
[12:33:13] <kimundi> Yeah, sounds like a better design
[12:33:40] <eddyb> rusti: let (ref a, ref b) = if 1 {(1, 2)} else {(3, 4)}; (*a, *b)
[12:33:41] -rusti- <anon>:9:33: 9:34 error: mismatched types: expected `bool` but found `<VI0>` (expected bool but found integral variable)
[12:33:42] -rusti- <anon>:9          let (ref a, ref b) = if 1 {(1, 2)} else {(3, 4)}; (*a, *b)
[12:33:42] -rusti-                                           ^
[12:33:42] -rusti- error: aborting due to previous error
[12:33:42] -rusti- application terminated with error code 101
[12:33:48] <dbaupp> (Or even getenv() -> c_str::CString.)
[12:33:52] <eddyb> rusti: let (ref a, ref b) = if true {(1, 2)} else {(3, 4)}; (*a, *b)
[12:33:54] -rusti- (1, 2)
[12:33:57] <ssbr_> a problem is there there's four situations: where there is no unicode path, where the paths are decodable only by coincidence, and where the paths are unicode and the byte representation is something different, and where the paths are unicode and there is no byte representation except one you make up
[12:33:58] <strcat> Heather: fwiw you're support to use XDG_CONFIG_HOME and then fall back to ~/.config/ ;p
[12:34:03] * eddyb is surprised that works
[12:34:14] <ssbr_> the first two are linux, the third is OS X, and the fourth is windows
[12:34:15] <ssbr_> AIUI
[12:34:25] *** Joins: sigma (sigma@moz-D4F04D48.range86-174.btcentralplus.com)
[12:34:33] <dbaupp> strcat: s/support/supposed/?
[12:34:38] <strcat> yes
[12:34:43] <Heather> updated gist https://gist.github.com/Heather/7640445
[12:34:44] * strcat just woke up
[12:34:56] <kimundi> strcat: Good morning then! :)
[12:35:07] <eddyb> Heather: you're keeping the if just for a dot :P?
[12:35:10] *** Joins: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au)
[12:35:15] <tikue_> eddyb: well you can usually do something like `let a = &foo;`
[12:35:19] <Heather> eddyb yep
[12:35:24] <tikue_> rusti: let a = &1; *a
[12:35:27] <Heather> eddyb windows path don't like dots
[12:35:27] -rusti- 1
[12:35:29] <strcat> I accidentally left the concurrent hash table benchmark running all night and my room is super hot
[12:35:43] <eddyb> Heather: tell that to .minecraft
[12:35:49] <kimundi> strcat: Haha
[12:35:52] <strcat> and the logging was buggy so it didn't accomplish anything
[12:36:12] <sigma> at least you know you'll not freeze if your heating gives out
[12:36:21] <eddyb> tikue_: riiight I should've payed more attention. well, I don't really need it
[12:37:10] <eddyb> Heather: I'm curious why you need the refs in the first place. what are you doing with these paths?
[12:37:44] <Heather> eddyb use later
[12:38:00] <Heather> eddyb nothings needs Paths, everything needs & Paths
[12:38:10] <eddyb> Heather: oh, all over the API?
[12:38:21] <Heather> I think...
[12:38:22] * eddyb has to look at std::io more
[12:38:48] <Heather> eddyb but at least it goes so in my application
[12:39:04] <ssbr_> rusti: use std::path::WindowsPath; WindowsPath("D:\\hello").join(WindowsPath("\\world"))
[12:39:06] -rusti- <anon>:9:37: 10:5 error: type `std::path::WindowsPath` does not implement any method in scope named `join`
[12:39:07] -rusti- <anon>:9          use std::path::WindowsPath; WindowsPath("D:\\hello").join(WindowsPath("\\world"))
[12:39:07] -rusti- <anon>:10     };
[12:39:07] -rusti- error: aborting due to previous error
[12:39:07] -rusti- application terminated with error code 101
[12:39:14] <ssbr_> What am I doing wrong here?
[12:39:37] <dbaupp> that's weird. is the GenericPath impl #[cfg]'d?
[12:40:00] <strcat> remember that rusti is 0.8 too...
[12:40:15] * ssbr_ wanted to check if the result is D:\\world like it should be <_<
[12:40:31] <dbaupp> oh, yeah, 0.8 was before the Great Path Rewrite
[12:41:03] <dbaupp> rusti: use std::path::WindowsPath; WindowsPath("D:\\hello").push(WindowsPath("\\world"))
[12:41:03] -rusti- <anon>:9:67: 9:90 error: mismatched types: expected `&str` but found `std::path::WindowsPath` (expected &str but found struct std::path::WindowsPath)
[12:41:03] -rusti- <anon>:9          use std::path::WindowsPath; WindowsPath("D:\\hello").push(WindowsPath("\\world"))
[12:41:03] -rusti-                                                                             ^~~~~~~~~~~~~~~~~~~~~~~
[12:41:03] -rusti- error: aborting due to previous error
[12:41:05] -rusti- application terminated with error code 101
[12:41:11] <dbaupp> rusti: use std::path::WindowsPath; WindowsPath("D:\\hello").push("\\world")
[12:41:11] -rusti- std::path::WindowsPath{host: None, device: Some(~"D"), is_absolute: true, components: ~[~"hello", ~"world"]}
[12:41:42] *** Quits: GeneralMaximus (ankur@2B9456D9.591B27D3.D5D59AD9.IP) (Quit: Computer has gone to sleep.)
[12:41:50] <eddyb> Heather: carry on then. if I may nitpick, here's how I'd write it: https://gist.github.com/eddyb/7640657
[12:41:58] <ssbr_> I guess the behavior changed w.r.t. how abspaths are handled
[12:42:01] <dbaupp> so, no, it's incorrect in 0.8, but I'd guess it's correct on master (Eridius was asking ChrisMorgan questions about windows paths)
[12:42:07] <dbaupp> I guess so
[12:42:22] <eddyb> dbaupp: you almost make me feel bad for *wanting* to suggest some style changes, nevermind the actual phrasing >_>
[12:42:36] * eddyb goes back to his episode
[12:42:53] <eddyb> can't test the build with chrome open
[12:42:54] <Heather> eddyb not many differences )
[12:43:32] <eddyb> not even sure it looks better
[12:43:51] <dbaupp> eddyb: concrete style changes are useful, generic comments about having bad style are not
[12:44:03] <Heather> eddyb by the way .... just personal opinion ... chrome must die ....
[12:44:12] <Heather> with google...
[12:44:12] <eddyb> Heather: are you sure Sync.conf won't conflict with anything else? (unless it's not specific to your app, and you're just loading it)
[12:44:33] *** Quits: vmx (vmx@moz-35026133.dip0.t-ipconnect.de) (Connection timed out)
[12:44:42] <eddyb> Heather: I remember Firefox before Chrome, we used to complain all the time and call it a memory whore
[12:44:54] <Heather> eddyb :S possibly but for now I met nothing with ~sync.conf
[12:45:05] *** Quits: heftig (heftig@moz-E8E2034C.inf.fh-bonn-rhein-sieg.de) (Quit: Quitting)
[12:45:07] <dbaupp> Heather, eddyb: this is #rust, not #servo; language flamewars only. :P
[12:45:20] *** Joins: vmx (vmx@moz-35026133.dip0.t-ipconnect.de)
[12:45:33] *** Quits: apoelstra (username@moz-C92A9641.sw.biz.rr.com) (Quit: WeeChat 0.4.1)
[12:45:35] *** Joins: reyre (reyre@moz-89E9865B.com)
[12:46:58] <eddyb> Heather: ~/.config/Mirana/ would be a better place, IMO. even better, XDG_CONFIG_HOME instead of just ~/.config, like strcat said
[12:47:12] <strcat> http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html
[12:47:32] <Heather> eddyb what is XDG_CONFIG_HOME ?
[12:47:44] <eddyb> Heather: heh, see the link strcat just pasted
[12:48:13] <eddyb> strcat: whoa, it's not defined over here
[12:48:20] <strcat> eddyb: it's not supposed to be.
[12:48:23] <strcat> unless it's non-default
[12:48:25] <eddyb> hmm, ok
[12:48:34] <strcat> XDG_RUNTIME_DIR *must* be defined
[12:48:43] <strcat> the other dirs only need to be defined if you want to override fallbacks
[12:49:25] <Heather> okay so I get it different for win and nix again )
[12:49:53] <eddyb> I haven't seen /run until today, hmpf
[12:50:16] <kimundi> strcat: I have a question. Do you know if renaming .invert() on iterators to .flip() would conflict with some other meaning of the word "flip" that might be possible as operation on iterators?
[12:50:23] <strcat> kimundi: dunno
[12:50:51] <strcat> eddyb: it replaced most uses of /tmp, and is actually there in early boot
[12:50:59] *** Quits: Dessimat0r (Dessimat0r@E879B262.8D4FD984.4320F744.IP) (Ping timeout)
[12:51:01] <dbaupp> kimundi: it might be take to convert Iterator<M> into Iterator<W> /s
[12:51:06] <Heather> so I need create Mirana folder if not exist there
[12:51:09] <kimundi> dbaupp: :P
[12:51:19] <strcat> eddyb: /var/run became /run and /var/lock became /run/lock
[12:51:27] <strcat> and XDG_RUNTIME_DIR replaces insecure uses of /tmp
[12:51:31] <kimundi> I could imagine flipping a tuple... but that can be done with map anyway
[12:51:35] <strcat> (too easy to get that wrong)
[12:51:41] <ssbr_> eh, flipping the direction of a bidirectional iterator?
[12:51:52] <strcat> ssbr_: it's not a bidirectional iterator
[12:51:58] <ssbr_> strcat: I know
[12:52:18] <eddyb> strcat: since... when? I guess it's related to systemd
[12:52:21] <strcat> also, XDG_RUNTIME_DIR gets cleaned up as soon as you log out from the last place you're logged in
[12:52:25] <ssbr_> but that is a conceivable operation on some iterators
[12:52:50] <strcat> ssbr_: bidirectional iterators aren't memory safe
[12:53:00] <kimundi> ssbr_: Hm, true. But there we could just pick the name reverse(), as it would be accurate there ;)
[12:53:02] <strcat> double-ended ranges are
[12:53:17] <strcat> (bidirectional ranges, if you want to call them that - but the terminology is confusing)
[12:53:20] <Heather> how to create dir
[12:53:37] <strcat> eddyb: well /run was adopted everywhere
[12:53:37] <dbaupp> Heather: std::io::fs::<something>
[12:53:40] <ssbr_> strcat: to take a general interface and say that all implementations of that interface are unsafe seems brazen
[12:53:42] <eddyb> Heather: mkdir, it has to be somewhere in io::fs
[12:53:45] <dbaupp> Heather: I guess mkdir
[12:54:01] <strcat> ssbr_: C++ style iterators are unsafe in general
[12:54:03] <eddyb> strcat: I still have a lot of stuff in /var
[12:54:07] <Heather> thanks
[12:54:12] <ssbr_> strcat: I come from Python-land, not C++
[12:54:14] <strcat> eddyb: not talking about /var as a whole
[12:54:33] <ssbr_> I actually don't know anything about C++ iterators (un)fortunately
[12:54:47] <eddyb> strcat: /var/run. /var/lock has only one folder
[12:54:51] <strcat> eddyb: /var/run should be a symlink to /run
[12:54:55] * strcat shrugs
[12:55:03] <strcat> and /var/lock to /run/lock
[12:55:05] <eddyb> nope
[12:55:10] <strcat> but you have /run ???!
[12:55:17] <eddyb> yupp
[12:55:33] * kimundi meanwhile reaches the conclusion that invert -> flip would not cause more confusion than there already is
[12:55:33] <strcat> distro is just broken then ;p
[12:55:57] <eddyb> tmpfs on /run type tmpfs (rw,nosuid,nodev,relatime,mode=755)
[12:56:00] <ssbr_> kimundi: that seems likely
[12:56:01] <eddyb> tmpfs on /var/run type tmpfs (rw,nosuid,nodev,relatime,mode=755)
[12:56:11] <strcat> eddyb: yeah there's supposed to be 1
[12:56:19] <eddyb> strcat: they have the same contents, though. no idea how they're linked
[12:56:20] <tikue_> kimundi: is the goal to shorten the word?
[12:56:22] <strcat> instead of 3 (/run, /var/lock, /var/run)
[12:56:27] <strcat> eddyb: oh, bind mount?
[12:56:34] <strcat> eddyb: look at 'findmnt'
[12:56:39] <strcat> 'mount' is useless
[12:56:41] <strcat> (for that)
[12:56:55] <kimundi> tikue_: Yeah, and make it marginally more clear. The operation flips the next() and next_back() methods, the two ends of the Iterator
[12:56:59] <dbaupp> tikue_: kimundi's `e` key broke, and he still wants to be able to call that method
[12:57:02] <eddyb> strcat: no obvious relationship
[12:57:07] * dbaupp should probably go to bed...
[12:57:09] *** Quits: DeTeam (DeTeam@92C799C.31715274.F5F3AF2.IP) (Ping timeout)
[12:57:15] <tikue_> ;D
[12:57:22] *** Joins: DeTeam (DeTeam@3F8887A3.6883A39.F5F3AF2.IP)
[12:58:02] <kimundi> :D
[12:58:57] <tikue_> kimundi: how about tip!
[12:59:01] <tikue_> only 3 letters ;P
[12:59:34] <tikue_> short for "tip over so that the back is now front and vice versa"
[12:59:39] <kimundi> I want to remove all unneccessary rev_ iterator constructors. So instead of foo.iter() and foo.rev_iter() there would only be foo.iter() and foo.iter().flip()
[13:00:00] <kimundi> Composability \o/
[13:00:07] <Heather> updated gist https://gist.github.com/Heather/7640445 o_O
[13:00:10] <strcat> what if we want a reverse iterable trait?
[13:00:46] <eddyb> strcat: /etc/init.d/boot.rpmorig:    mount -n -t tmpfs -o mode=0755,nodev,nosuid tmpfs /run
[13:00:50] <kimundi> strcat: That... wouldn't really conflict, imo?
[13:00:54] *** Joins: heftig (heftig@411425BC.CDCB7EE7.172227A7.IP)
[13:01:26] <tikue_> the iterable trait doesn't exist yet right?
[13:01:33] <strcat> eddyb: what distro are you on?
[13:01:35] <kimundi> Yeah
[13:01:51] <kimundi> But even if it exists, there are plenty of iterator constructors that would not fall under it
[13:02:00] *** Joins: Savago (Savago@D8B9C081.E820043D.D4C04133.IP)
[13:02:12] <strcat> kimundi: but it would mean a lot of things would have rev_iter anyway
[13:02:15] <kimundi> str.word_iter() and str.rev_word_iter() etc
[13:02:29] <tikue_> :(
[13:02:49] * tikue_ would like str.byte_iter() and str.word_iter() --> str.iter()
[13:03:11] <kimundi> strcat: Sure, then it's the same situation like right now again.
[13:03:29] <eddyb> strcat: openSUSE. overdue for an update to 13.1, and it's almost 3 years old, so I might have screwed some update - see the .rpmorig suffix on that file name
[13:03:43] <kimundi> tikue_: https://github.com/mozilla/rust/pull/10622
[13:03:59] <strcat> eddyb: it seems odd that they'd have /etc/init.d at all, since I thought they used systemd
[13:04:22] <tikue_> oo
[13:04:23] <eddyb> strcat: all the scripts forward to systemd AFAIK
[13:04:36] *** Joins: Ms2ger (Ms2ger@moz-1B43DE50.adsl-dyn.isp.belgacom.be)
[13:04:57] <tikue_> oh i din't mean word_iter --> iter i meant char_iter -- iter
[13:05:36] <tikue_> kimundi: that proposal seems like a pretty good idea to me...but what about the iterable trait? 
[13:05:47] <kimundi> tikue_: Would not conflict
[13:05:58] <Heather> how to convert path to string
[13:06:03] <tikue_> kimundi: iter() would still need to exist right?
[13:06:07] <eddyb> Heather: for what?
[13:06:30] <kimundi> tikue_: If we get it, it can just implement whatever makes sense. But personally I think it's wrong to hardcode iter() on strinf to char anyway :P
[13:06:47] <Heather> eddyb self_exe_path is Path but I need to store string
[13:06:49] <kimundi> tikue_: As codepoints usually are not all that useful
[13:07:16] <eddyb> Heather: I mean, what do you need the string for?
[13:07:21] <kimundi> tikue_: Makes more sense to me to tread utf8 bytes, codepoints and grapheme clusters the same API-wise
[13:07:22] <strcat> kimundi: but neither are bytes
[13:07:33] <Heather> eddyb to store
[13:07:39] <kimundi> strcat: Exactly
[13:07:47] <eddyb> Heather: I got that, but what would you use the stored value for?
[13:07:55] <Heather> eddyb json
[13:08:10] <tikue_> kimundi: regardless, strings are clearly iterable, so they need to do _something_ for the default case
[13:08:30] *** Quits: tulloch (tulloch@moz-BC895BC5.damtp.cam.ac.uk) (Ping timeout)
[13:08:34] <kimundi> tikue_: I personally contest the _clearly_ :P
[13:09:00] <kimundi> tikue_: What is the unit of the elements for a string that makes most sense?
[13:09:02] <ssbr_> clearly iteration should be over code units
[13:09:09] <tikue_> kimundi: i don't think i have a strong opinion on that
[13:09:10] <Heather> dir_path !
[13:09:13] <kimundi> that would be bytes then
[13:09:23] <tikue_> yeah
[13:09:24] <eddyb> Heather: here's the API for paths: http://static.rust-lang.org/doc/master/std/path/trait.GenericPath.html
[13:09:27] <Heather> or not...
[13:09:46] <kimundi> tikue_: My opinion is: No iter() for strings, just .bytes(), .chars() and .glyphs() - let the user pick
[13:09:47] <ssbr_> this was a joke. iterating over code units hasn't ever been the right solution IME.
[13:09:52] <eddyb> Heather: you can do path.as_str().unwrap()
[13:10:02] <ssbr_> (iterating over _bytes_, on the other hand...)
[13:10:06] <Heather> eddyb hm, let me try
[13:10:43] <tikue_> kimundi: your proposed changes make me very happy, they're so much more aesthetically pleasing
[13:11:10] <kimundi> :)
[13:11:16] <tikue_> at least for str
[13:11:25] <tikue_> some like treemap i don't have much intuition about
[13:11:33] <kimundi> Yeah, the others get a bit... funky.
[13:12:11] <eddyb> 1.1GB. do I dare?
[13:12:22] <tikue_> but the general idea that returning an iterator as default makes sense to me, so specifying _iter() is redundant
[13:12:31] *** Quits: recrack (Mibbit@B4104EBB.3CC170B1.1E14B209.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[13:12:33] <tikue_> it reminds me of what python 3 has done with their builtin list functions
[13:14:29] *** pepijndevos is now known as pepijn
[13:14:40] *** pepijn is now known as pepijndevos
[13:15:11] <Heather> so
[13:15:11] *** Quits: pkphilip (Mibbit@1645AEB4.D187EA78.81C3DAA1.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[13:15:12] <Heather> ....
[13:15:13] <Heather> self_exe_path().as_ref().as_slice().unwrap().as_str().unwrap().to_owned()
[13:15:23] <Heather> and still doesn't work :D
[13:15:34] <Ms2ger> I'd hope that doesn't work! :)
[13:15:45] *** Joins: tulloch (tulloch@moz-BC895BC5.damtp.cam.ac.uk)
[13:15:50] <Heather> Ms2ger ideas how to get it working ?
[13:16:05] <Ms2ger> What does self_exe_path return?
[13:16:07] <Heather> I need ~str
[13:16:14] <strcat> Heather: you can't turn every path into a str
[13:16:14] <Heather> it returns Path
[13:16:16] <strcat> as said earlier
[13:16:30] <strcat> it has a display method or something
[13:16:39] <strcat> it will mangle some paths with replacement chars I guess
[13:16:59] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.2)
[13:17:08] <Heather> I was looking for another method :S
[13:17:11] <Ms2ger> Maybe self_exe_path().as_str().unwrap().to_owned()
[13:17:11] *** Parts: tikue_ (tkuehn@7101C711.2ACBBF24.689607DE.IP) ()
[13:17:17] *** Joins: tikue_ (tkuehn@7101C711.2ACBBF24.689607DE.IP)
[13:17:18] <Ms2ger> [Might fail!()]
[13:17:26] *** Joins: canhtak (canhtak@moz-6F820ACE.wl.t.ulaval.ca)
[13:17:36] *** Quits: tikue_ (tkuehn@7101C711.2ACBBF24.689607DE.IP) (Quit: tikue_)
[13:18:01] <Heather> Ms2ger self_exe_path is option
[13:18:18] <Ms2ger> You said it returns a Path?
[13:18:32] <Heather> Ms2ger sorry, I was not correct
[13:18:52] <Ms2ger> Maybe self_exe_path().unwrap().as_str().unwrap().to_owned(), then
[13:19:14] <eddyb> .map might work better in the general case :P
[13:19:17] *** Quits: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP) (Client exited)
[13:20:41] <Ms2ger> Fair
[13:20:52] <Heather> error: can only dereference enums with a single variant which has a single argument
[13:21:04] *** Joins: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP)
[13:21:16] <eddyb> you tried *x?
[13:21:21] <Heather> yes
[13:21:29] <Heather> hm
[13:21:29] <eddyb> where x is Option<T>?
[13:21:31] <Heather> I need map !
[13:21:51] <Ms2ger> You can dereference enums?
[13:22:02] <kimundi> Ms2ger: Unit structs
[13:22:07] <eddyb> Ms2ger: when they're equivalent to a newtype struct
[13:22:09] <kimundi> Ms2ger: ANd unit struct enums
[13:22:18] <eddyb> isn't unit ()?
[13:22:25] <kimundi> err
[13:22:26] <kimundi> right
[13:22:27] <eddyb> i.e. struct FooBar;
[13:22:32] <kimundi> newtype structs/newtype enmus
[13:23:04] <eddyb> the enums are pointless unless they're there for some future expandability or something
[13:24:43] <eddyb> middle::typeck::write_ty_to_tcx is my current bad guy, there's a lot of memory usage increase during type checking
[13:25:13] *** Joins: bungoman (bungoman@moz-F95B490C.tx.res.rr.com)
[13:25:18] *** Joins: lfox (lfox@moz-343B6F0C.nyc.biz.rr.com)
[13:26:09] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[13:26:34] <eddyb> well, ast_util::resolve_internal too, I think unneeded hygiene adds a serious cost to resolve, but I may be wrong and I really can't touch that without an expert around :P
[13:26:53] *** Quits: bungoman (bungoman@moz-F95B490C.tx.res.rr.com) (Ping timeout)
[13:27:27] *** Quits: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au) (Quit: gavinb)
[13:27:33] <eddyb> it's like using a room full of toilet paper rolls to wipe something clean - since it's already about hygiene
[13:27:45] *** Quits: jrw (jrw@moz-25ACAE0D.net) (Ping timeout)
[13:27:49] <eddyb> Leo`: ping
[13:27:49] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[13:29:59] *** Quits: Krymise (Nietzsche@moz-CA789EF5.nwrknj.fios.verizon.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[13:30:48] *** Quits: axitkhurana (Adium@63F3AA56.9CFBD76D.30E7AE68.IP) (Quit: Leaving.)
[13:31:22] *** Joins: jrw (jrw@moz-25ACAE0D.net)
[13:31:35] *** Joins: axitkhurana (Adium@63F3AA56.9CFBD76D.30E7AE68.IP)
[13:31:54] <Heather> self_exe_path().unwrap().as_str().as_ref().map(|z| (*z)).unwrap().as_slice().to_owned()
[13:32:08] <Heather> dbaupp still don't live long enough :(
[13:32:28] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Quit: Leaving)
[13:33:11] <eddyb> .as_ref().map(|z| (*z)) // isn't that a no-op?
[13:33:36] <Heather> eddyb not, I think
[13:34:09] <eddyb> self_exe_path().unwrap().as_str().unwrap() is a slice
[13:34:18] *** Joins: themgt (themgt@moz-83F07CDA.cm.vtr.net)
[13:34:38] <Heather> eddyb but it's already corpse
[13:34:42] <eddyb> .to_owned() on that should be enough
[13:34:59] <Heather> it don't live long enough
[13:35:00] <eddyb> Heather: what does the error point at?
[13:35:08] <eddyb> i.e. what doesn't live enough
[13:35:17] <Heather> yes
[13:35:31] <eddyb> that was a question :)
[13:35:34] <Heather> at self_exe_path
[13:35:40] <eddyb> just that?
[13:35:51] <Heather> not ....
[13:36:02] <eddyb> then? what's the full error?
[13:36:22] <eddyb> the underlined sections (spans) are very important in determining what's causing the error
[13:36:27] <Heather> eddyb https://gist.github.com/Heather/7641278
[13:37:00] *** Quits: sk (sk@61A494B3.BA40E8A.AAC02D62.IP) (Ping timeout)
[13:37:03] <Heather> what means note: ...but borrowed value is only valid for the method call
[13:37:06] <Heather> ...
[13:37:07] <kimundi> would self_exe_path().map(|p| p.as_str()).map(|s| s.to_owned()).unwrap() work? :P
[13:37:35] <Heather> no
[13:37:53] <Heather> kimundi as_str returns option
[13:37:54] <kimundi> Ah, wait, nested Options... carry on
[13:38:05] <eddyb> Heather: show errors for the suggestions, yours is too contrived to determine what's going on :P
[13:38:31] <eddyb> self_exe_path().map(|p| p.as_str().map(|s| s.to_owned())).unwrap().unwrap() might work, kimundi
[13:38:49] *** Quits: ricepuddin (graham@moz-7D68765A.cable.virginm.net) (Ping timeout)
[13:38:53] <Heather> lol
[13:38:56] <Heather> eddyb it is
[13:39:01] <Heather> Rust is hard....
[13:39:01] *** Joins: tulloch_ (tulloch@moz-BC895BC5.damtp.cam.ac.uk)
[13:39:15] <kimundi> eddyb: Lol, yeah
[13:39:25] <eddyb> Heather: try self_exe_path().unwrap().as_str().unwrap().to_owned(), what's the error for that?
[13:39:41] <eddyb> before adding to it, you have to be sure what's wrong
[13:40:10] <Heather> eddyb borrowed value does not live long enough
[13:40:23] <eddyb> Heather: which one, exactly?
[13:40:37] <eddyb> there's 5 function calls there, it could be any one of them
[13:40:38] <Heather> eddyb https://gist.github.com/Heather/7641336
[13:40:53] *** Quits: jrw (jrw@moz-25ACAE0D.net) (Ping timeout)
[13:41:13] <eddyb> {let path = self_exe_path().unwrap(); path.as_str().unwrap().to_owned()}
[13:41:24] <kimundi> Shorter: self_exe_path().and_then(|p| p.as_str()).map(|s| s.to_owned()).unwrap()
[13:41:38] <eddyb> aaah, and_then, nice
[13:41:46] <kimundi> flattens it to one Option :P
[13:42:02] <eddyb> Heather: try the last two, do they both work?
[13:42:16] <Heather> ....
[13:42:27] <Heather> rusti: print("I am dead")
[13:42:28] -rusti- I am dead()
[13:42:34] <Heather> oh you're not
[13:42:52] <Heather> rusti: 01self_exe_path().and_then(|p| p.as_str()).map(|s| s.to_owned()).unwrap(01)
[13:42:54] -rusti- <anon>:9:9: 9:10 error: unknown start of token: \x03
[13:42:54] -rusti- <anon>:9          01self_exe_path().and_then(|p| p.as_str()).map(|s| s.to_owned()).unwrap(01)
[13:42:54] -rusti-                   ^
[13:42:54] -rusti- application terminated with error code 101
[13:43:01] <eddyb> don't try to create a testcase for rusti, it's too old :P
[13:43:12] <Heather> ah...
[13:43:26] *** Joins: lazyden (lazyden@47A36AC9.35CBBBD0.F246D1AF.IP)
[13:43:26] *** Quits: lazyden (lazyden@47A36AC9.35CBBBD0.F246D1AF.IP) (Quit: lazyden)
[13:43:32] *** Joins: lazyden (lazyden@47A36AC9.35CBBBD0.F246D1AF.IP)
[13:43:37] *** Quits: lazyden (lazyden@47A36AC9.35CBBBD0.F246D1AF.IP) (Quit: lazyden)
[13:43:44] <eddyb> and you have some sort of weird character in your code, I think. can't remember \x03 being anything meaningful though. unless it's \b
[13:43:55] <bjz> how do we do functions that return functions now?
[13:43:56] <kimundi> black text
[13:44:04] <Heather> https://gist.github.com/Heather/7641375
[13:44:06] *** Joins: Florob (Florob@moz-39532932.de)
[13:44:06] <bjz> seeing as we don't have ~fn
[13:44:10] <kimundi> bjz: proc
[13:44:13] <eddyb> kimundi: too bad I can't see that, since I have black on white
[13:44:14] <kimundi> bjz: or ||
[13:44:34] <kimundi> bjz: Or a trait object
[13:44:43] *** Quits: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP) (Client exited)
[13:44:45] <kimundi> bjz: Or a struct implementing a trait
[13:44:47] <eddyb> Heather: and mine?
[13:45:01] <Heather> eddyb I think I already used to try it but let's see
[13:45:06] <Heather> ah not
[13:45:08] <Heather> and_then....
[13:45:10] <Heather> what is it
[13:45:51] *** Joins: jrw (jrw@moz-25ACAE0D.net)
[13:45:54] <Heather> eddyb https://gist.github.com/Heather/7641403
[13:46:17] <eddyb> and_then maps an Option<T> to an Option<U> and returns Option<U>. map would return Option<Option<U>>
[13:46:34] <eddyb> Heather: nah, this one: {let path = self_exe_path().unwrap(); path.as_str().unwrap().to_owned()}
[13:46:37] <Heather> hm :S
[13:47:04] <Heather> eddyb works...
[13:47:14] <Heather> or wait
[13:47:34] <Heather> eddyb you cheated )
[13:47:40] <eddyb> okay, so it's the bug dbaupp mentioned, I think
[13:47:50] <Heather> yep it is
[13:48:12] <eddyb> self_exe_path().map(|p| format!("{}", p))
[13:48:57] <eddyb> although I'm not sure if that returns any extra characters. you could also do p.as_str().unwrap() in the format, but that's silly
[13:50:22] <Heather> )
[13:50:58] <Heather> eddyb I think your maps version is way it should be done
[13:51:22] <eddyb> with the format?
[13:51:32] <Heather> eddyb with 2 maps
[13:51:45] <eddyb> ah. wasn't that kimundi?
[13:52:23] <kimundi> the and_then and map version should be the best one
[13:52:24] <Heather> eddyb hm you added correction to his variant
[13:52:58] <kimundi> But I think all this still runs into the tmeporary lifetime problem :P
[13:53:22] *** Joins: Dessimat0r (Dessimat0r@E879B262.8D4FD984.4320F744.IP)
[13:53:23] <eddyb> dbaupp: any idea if this is too big? https://github.com/mozilla/rust/blob/master/src/librustc/middle/ty.rs#L626-L661
[13:53:29] <bstrie> if this is an rvalue lifetime problem, then let nmatsakis know if you want the rules changed :P
[13:54:42] *** Joins: sk (sk@61A494B3.BA40E8A.AAC02D62.IP)
[13:55:25] *** Quits: Dessimat0r (Dessimat0r@E879B262.8D4FD984.4320F744.IP) (Ping timeout)
[13:55:31] <eddyb> bstrie: there's a bug for it, dbaupp linked it, so I'm sure he knows
[13:55:45] <eddyb> bah, extern mod rustc doesn't work :(
[13:56:14] <bstrie> just wanted to make sure that people realize that this is an area of debate
[13:58:05] *** Quits: tulloch_ (tulloch@moz-BC895BC5.damtp.cam.ac.uk) (Ping timeout)
[13:58:05] *** Quits: tulloch (tulloch@moz-BC895BC5.damtp.cam.ac.uk) (Ping timeout)
[13:58:06] <eddyb> if I use -L to add the path to librustc, it goes nuts because there's two libstd's
[13:58:24] *** Quits: beifeng (Mibbit@284C36E7.3062CEC3.670EEFD.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[13:59:00] *** Joins: Dessimat0r (Dessimat0r@E879B262.8D4FD984.4320F744.IP)
[14:02:31] * Heather goes home
[14:02:48] <Heather> btw... I want rust to support COM :P
[14:02:52] <eddyb> error: internal compiler error: trans_local_var: no llval for local/arg 151 found
[14:03:02] <eddyb> Heather: Common Object Model, the windows stuff?
[14:03:11] <Heather> eddyb Yeah
[14:03:22] <eddyb> doesn't it have C bindings?
[14:03:41] <Heather> eddyb python can do it, ruby can do it, all other stuff can do it. but I don't know how is it made
[14:04:07] <eddyb> those are libraries, outside of their respective languages
[14:04:09] <Heather> at least ability to call com objects
[14:04:41] <Heather> in python it's called win32com.client
[14:04:55] *** Quits: DeTeam (DeTeam@3F8887A3.6883A39.F5F3AF2.IP) (Ping timeout)
[14:05:11] <Heather> and I can call Dispatch progId object and then call its methods
[14:05:57] <eddyb> Heather: wait for someone to write a rust-com library or do it yourself ;)
[14:06:18] <eddyb> wow, I've managed to not throw shit at windows
[14:06:20] *** Joins: DeTeam (DeTeam@92C799C.31715274.F5F3AF2.IP)
[14:06:34] <Heather> )
[14:07:05] *** Quits: axitkhurana (Adium@63F3AA56.9CFBD76D.30E7AE68.IP) (Quit: Leaving.)
[14:07:16] <Heather> eddyb windows is cool )
[14:07:51] <eddyb> that is such an empty statement
[14:08:02] <eddyb> () would be proud
[14:08:07] <Heather> eddyb why empty?
[14:08:09] <eddyb> or ;, rather
[14:08:22] <Heather> eddyb it's my user experience at least!
[14:08:40] <Heather> eddyb and don't say that I don't know linux.
[14:08:56] <eddyb> Heather: well, if I were to say "naive", that could be interpreted as referring to the person instead of the statement (which it wasn't)
[14:09:25] <eddyb> linux is decent. windows is below that. better put, below compromise
[14:10:27] <eddyb> I think this would be a start if you want to create a library: http://msdn.microsoft.com/en-us/library/windows/desktop/ms679568(v=vs.85).aspx
[14:10:30] <Heather> eddyb well... windows is different and I like it more...
[14:10:57] <eddyb> everyone has their own skin shedding schedule, I guess
[14:11:21] <Heather> eddyb that's right
[14:11:29] <eddyb> sooner or later you're going to grow uneasy in it (in this case, windows)
[14:11:42] <Heather> eddyb grow?
[14:11:58] *** Joins: tulloch (tulloch@moz-BC895BC5.damtp.cam.ac.uk)
[14:12:03] *** Joins: tulloch_ (tulloch@moz-BC895BC5.damtp.cam.ac.uk)
[14:12:05] <kimundi> ...or not, you'll never know eddyb :P
[14:12:15] *** Joins: mermi (Mibbit@moz-8C0731D2.broadband.tenet.odessa.ua)
[14:12:21] <Heather> grow to which state? :D
[14:12:23] *** Quits: mermi (Mibbit@moz-8C0731D2.broadband.tenet.odessa.ua) (Quit: http://www.mibbit.com ajax IRC Client)
[14:12:31] <eddyb> I guess I shouldn't use fancy words like "uneasy", I don't think I can even translate it to my own native language
[14:12:39] <eddyb> Heather: "grow uneasy" as in "become uncomfortable"
[14:12:48] *** Quits: q66_ (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[14:12:51] <eddyb> restrained, limited
[14:13:07] <eddyb> kimundi: don't remember me about *that* VB amateur coder
[14:13:13] <Heather> eddyb why do I need something uncomfortable?
[14:13:16] <eddyb> s/remember/remind
[14:13:19] *** Quits: heftig (heftig@411425BC.CDCB7EE7.172227A7.IP) (Ping timeout)
[14:13:27] <kimundi> eddyb: Hm?
[14:14:05] <eddyb> kimundi: I have a "friend" who thinks Visual Basic is... well, I won't go into details. he likes it. makes me sick
[14:14:33] <kimundi> My roommate likes php, I know how you feel :P
[14:14:52] *** jorendorff is now known as jorendorff_away
[14:14:53] <Heather> I think php is not bad... and vb too....
[14:14:54] <eddyb> I started in those languages. I was 10-12
[14:15:05] <kimundi> Still, no need to tell people what they shouldn't like
[14:16:07] *** jorendorff_away is now known as jorendorff
[14:16:09] <Heather> kimundi not fully right...
[14:16:13] <eddyb> kimundi: not like, but feel proud, like happy piggies in mud. I'm not even sure where the line is anymore, too much crossing >_>
[14:16:23] <eddyb> Heather: I wish I knew your native language, so I could tell you what I really meant
[14:16:31] *** Joins: jfbk (jfbk@moz-EEA9CFB3.nyc.res.rr.com)
[14:16:40] <Heather> eddyb Russian
[14:17:04] <kimundi> your move eddyb ;)
[14:17:09] <Heather> kimundi you should tell people if you know more than they do .... It could be helpful
[14:17:19] <eddyb> oh, that explains it. I thought french at first, but it wasn't quite right
[14:17:19] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[14:17:21] <kimundi> Sure
[14:17:22] <Heather> kimundi like suggestions ...
[14:18:04] *** jorendorff is now known as jorendorff_away
[14:18:12] <eddyb> Heather: there's a lot of russians in #radare on freenode (it's related to reverse engineering), and I see the weirdest engrish from them, no offense
[14:18:22] <Boreeas> Does str::trim only cut off tradition whitespace (' ', '\t', etc.) or zero-bytes, too?
[14:18:43] <kimundi> I'm just saying, if they happy with what they are using even after explaining them the own opinion, then leave them be.
[14:18:50] <eddyb> having a different alphabet probably makes it harder, etc.
[14:18:52] <Heather> eddyb I'm working on it )
[14:19:25] <kimundi> Boreeas: afaik everything in the unicode cathegory whitespace
[14:19:32] <eddyb> Heather: I don't know any Russian. what I meant is that some things you like know might make you feel limited and constrained in the future
[14:19:47] <eddyb> s/know/now
[14:19:55] * eddyb is failing at this
[14:20:08] <Heather> eddyb I think it's more related to that we don't use English at all during childhood even in school, and rare when people start use it early.
[14:20:53] *** Joins: bungoman (bungoman@70827CB0.6C181F01.F74C56B8.IP)
[14:20:56] <eddyb> ahh, that would do it. voiced-over cartoons are the worst
[14:20:59] * kimundi just read a lot of manga fan translations, and one day he knew kung fu. Err, english
[14:21:37] <kimundi> Of course, german is fairly close to begin with...
[14:21:48] <eddyb> kimundi: your nick does make me think of kung fu panda
[14:21:54] <eddyb> ah, not a ninja? my bad
[14:22:21] <eddyb> http://msdn.microsoft.com/en-us/library/windows/desktop/ms679261(v=vs.85).aspx this doesn't look like what I would've expected :/
[14:22:22] <kimundi> damn, now I need to change my nick
[14:22:24] <kimundi> ;)
[14:22:43] <Heather> )
[14:24:18] <eddyb> http://msdn.microsoft.com/en-us/library/windows/desktop/aa367091(v=vs.85).aspx pffft, this is complicated
[14:25:05] <eddyb> error: internal compiler error: trans_local_var: no llval for local/arg 151 found :(
[14:26:57] * Heather is going home, now for sure )
[14:27:03] *** Joins: heftig (heftig@F93B1CAB.3AAA832A.172227A7.IP)
[14:27:14] *** Quits: Heather (Heather@19663F6.F53BAACC.9C17E900.IP) (Quit: ~ Trillian - www.trillian.im ~)
[14:27:58] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[14:28:19] *** Quits: vmx (vmx@moz-35026133.dip0.t-ipconnect.de) (Ping timeout)
[14:28:32] *** Joins: bjustin (bjustin@moz-8FC28563.sierrabravo.net)
[14:29:54] *** Joins: Scriptor (anonymous@moz-E06F46F0.corp.bitshelter.com)
[14:32:15] *** jorendorff_away is now known as jorendorff
[14:32:26] *** Joins: vmx (vmx@moz-7DD0B8B0.dip0.t-ipconnect.de)
[14:33:11] <nmatsakis> pnkfelix: I've been thinking more about "DST". I plan to write up a pro-con post as I see it, but I am currently feeling like we should not implement DST in the end and instead stick to our current system (actually an extended version thereof)
[14:33:33] <nmatsakis> pnkfelix: oops, changed channels, well no matter
[14:33:48] <pnkfelix> nmatsakis: okay, I'm not inclined to argue one way or another about DST.
[14:34:01] *** kimundi is now known as zz_kimundi
[14:34:06] *** Joins: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net)
[14:34:18] <bstrie> nmatsakis: not even for traits?
[14:34:49] *** Quits: heftig (heftig@F93B1CAB.3AAA832A.172227A7.IP) (Quit: Quitting)
[14:35:06] *** Joins: heftig (heftig@moz-E7FBFCE3.dip0.t-ipconnect.de)
[14:35:12] <nmatsakis> bstrie: Traits are the sticky point. Supporting DST (meaning that `[T]` and `Trait` are types) does make a few things work much nicer, in particular the interaction between objects and traits...
[14:35:38] <nmatsakis> ...but the other interpretation that I am thinking of (which turns out feeling similar to our current system in practice, though explained differently) seems simpler and perhaps cleaner.
[14:35:40] *** Joins: mib_hhrtma (Mibbit@moz-535184AB.customers.ownit.se)
[14:35:43] <nmatsakis> well, let me try to write up the two ideas
[14:35:51] *** Joins: japaric (japaric@EEA8F44E.83887C3F.5C7588CA.IP)
[14:36:14] <eddyb> whenever &[T] and ~[T] have the same repr, Rc<[T]> could work with minimal changes
[14:36:36] <nmatsakis> it's precisely this matter -- how best to support Rc<Trait> and Rc<[T]> -- that I've been thinking about a lot
[14:37:30] *** Quits: japaric (japaric@EEA8F44E.83887C3F.5C7588CA.IP) (Quit: WeeChat 0.4.2)
[14:37:35] *** jorendorff is now known as jorendorff_away
[14:37:36] *** Joins: japaric (japaric@EEA8F44E.83887C3F.5C7588CA.IP)
[14:37:53] *** Joins: abinader (abinader@D8B9C081.E820043D.D4C04133.IP)
[14:39:12] <eddyb> nmatsakis: it should be trivial in types, while functions (like Rc<T> impls) would require an Unsized/!Sized bound. is there more to it?
[14:39:33] *** Quits: Dessimat0r (Dessimat0r@E879B262.8D4FD984.4320F744.IP) (Ping timeout)
[14:39:53] <eddyb> s/impls/impl methods/
[14:40:27] <nmatsakis> eddyb: I'd not say it's trivial. 
[14:42:37] *** Joins: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP)
[14:43:02] *** Joins: Dessimat0r (Dessimat0r@E879B262.8D4FD984.4320F744.IP)
[14:43:44] <eddyb> nmatsakis: well, I don't think it requires changes to the type system, just in astconv
[14:44:14] *** Quits: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP) (Client exited)
[14:44:23] <eddyb> rusti: struct Owned<T>(~T); Owned(~[0u])
[14:44:24] -rusti- pastebinned 13 lines of output: http://sprunge.us/MeXV
[14:44:50] <eddyb> nmatsakis: ah, I see. type inference :P
[14:45:03] <eddyb> rusti: struct Owned<T>(~T); Owned::<[int]>(~[0])
[14:45:04] -rusti- pastebinned 8 lines of output: http://sprunge.us/FDZf
[14:45:59] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[14:46:08] *** Quits: jfbk (jfbk@moz-EEA9CFB3.nyc.res.rr.com) (Quit: )
[14:46:09] <eddyb> not sure how I didn't think of that for my tuple extensions, since it can appear there, too
[14:46:58] *** Joins: bynaryshef (bynaryshef@moz-647E89A6.mem.bellsouth.net)
[14:47:11] <nmatsakis> eddyb: it's not really about inference. but I don't want to go into detail on IRC -- too limited -- I'll try to write up a blog post in next day or two
[14:47:44] <eddyb> nmatsakis: I guess just allowing generic substitution for DSTs, and deferring the error to a non-pointer instance - that's the only easy part in this
[14:48:16] *** Joins: sbalmos (quassel@CA5677B6.576D0C1.ED2EFC1B.IP)
[14:48:58] *** Quits: nsf (nsf@moz-EEF3238A.convex.ru) (Quit: WeeChat 0.4.2)
[14:48:59] *** Joins: ricepuddin (graham@moz-1D7A4284.wlan.ic.ac.uk)
[14:49:35] *** Quits: Dessimat0r (Dessimat0r@E879B262.8D4FD984.4320F744.IP) (Ping timeout)
[14:50:23] *** Quits: squiddy (squiddy@moz-27C0E5BE.adsl.alicedsl.de) (Ping timeout)
[14:51:23] <eddyb> same problem I have, I should start learning about typeck and borrowck
[14:52:08] <mib_hhrtma> Sorry if its obvious but how do I do this: http://pastie.org/8507505
[14:52:21] <mib_hhrtma> I basically just need to create a proper SocketAddr
[14:53:06] *** Joins: lmandel (lmandel@13F2CEC5.7672369.D8E68FF6.IP)
[14:53:25] <eddyb> mib_hhrtma: nothing goes there. it failed
[14:53:55] <eddyb> mib_hhrtma: you can do fail!("URL invalid"), if you want to
[14:54:08] <mib_hhrtma> ah thats fine for now thx!
[14:54:10] <eddyb> or let dest = match from_str("tcp://127.0.0.1:6379").unwrap();
[14:54:33] <eddyb> (unwrap will call fail for null, but without a custom error message - not sure if that's implemented)
[14:54:41] <mib_hhrtma> i tried that actually but: task '<main>' failed at 'called `Option::unwrap()` on a `None` value', /build/rust-git/src/rust/src/libstd/option.rs:135
[14:54:59] <eddyb> mib_hhrtma: you have None - it failed
[14:55:27] <mib_hhrtma> but... its a hardcoded string and it seems valid no?
[14:55:48] <eddyb> depends on what you're sending it to
[14:56:40] <mib_hhrtma> huh? you mean it actually fails later when i try to connect?
[14:57:17] <eddyb> no, I mean it might be invalid for that from_str. I'm not sure which one it's referring to
[14:57:27] <mib_hhrtma> nop, it seems to fail in the match 
[14:57:46] <mib_hhrtma> ahhhh rust stuff i missed sec
[14:57:50] *** Joins: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP)
[14:58:12] *** Quits: ricepuddin (graham@moz-1D7A4284.wlan.ic.ac.uk) (Ping timeout)
[14:58:57] <mib_hhrtma> hmm i dont have the hang of it... How do I qualify which from_str i want?
[14:59:46] <eddyb> mib_hhrtma: where are you importing it from?
[14:59:58] <mib_hhrtma> use std::io::TcpStream; use std::io::net::ip::SocketAddr;
[14:59:58] <erickt1> nmatsakis: good morning, thanks for getting back to me on https://github.com/mozilla/rust/issues/10640. Should I close the issue, or link it into a DST metabug?
[15:00:05] <mib_hhrtma> I have only those imports
[15:00:11] <eddyb> mib_hhrtma: I don't see any from_str there
[15:00:29] <eddyb> mib_hhrtma: unless you have ::* somewhere else
[15:00:29] <mib_hhrtma> me neither but it does not complain
[15:00:35] <mib_hhrtma> not *
[15:00:39] <mib_hhrtma> no
[15:01:13] <eddyb> mib_hhrtma: then it depends on the type of url, I think
[15:01:20] <mib_hhrtma> http://pastie.org/8507525
[15:01:26] <mib_hhrtma> whole prog
[15:01:28] <eddyb> err, dest
[15:01:28] <mib_hhrtma> tiny
[15:02:15] <mib_hhrtma> does it return multiple?
[15:02:38] <eddyb> mib_hhrtma: it can be implemented by any type
[15:02:59] <eddyb> rusti: let x: int = from_str("5"); let y: bool = from_str("true"); (x, y)
[15:03:02] -rusti- pastebinned 10 lines of output: http://sprunge.us/RNVN
[15:03:06] *** Quits: sigma (sigma@moz-D4F04D48.range86-174.btcentralplus.com) (Client exited)
[15:03:17] <eddyb> rusti: let x: int = from_str("5").unwrap(); let y: bool = from_str("true").unwrap(); (x, y)
[15:03:19] -rusti- (5, true)
[15:03:39] <eddyb> mib_hhrtma: ^ it uses the return type to choose the right conversion
[15:04:25] *** Quits: dew1 (Instantbir@moz-E4452B8F.static.stls.mo.charter.com) (Ping timeout)
[15:04:26] <eddyb> http://static.rust-lang.org/doc/master/std/io/net/tcp/struct.TcpStream.html
[15:04:33] *** jorendorff_away is now known as jorendorff
[15:04:38] *** Joins: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com)
[15:04:49] *** Joins: ricepuddin (graham@moz-1D7A4284.wlan.ic.ac.uk)
[15:05:06] <mib_hhrtma> thx, I have to go back to basics a little :)
[15:05:07] <eddyb> mib_hhrtma: http://static.rust-lang.org/doc/master/std/io/net/ip/struct.SocketAddr.html it doesn't actually say what format it wants
[15:06:19] <eddyb> mib_hhrtma: try without tcp://
[15:06:19] <nmatsakis> erickt1: I think we ought to just close it
[15:07:32] *** Quits: canhtak (canhtak@moz-6F820ACE.wl.t.ulaval.ca) (Quit: canhtak)
[15:07:36] *** Joins: ianj (ianjneu@moz-7140CF01.ccs.neu.edu)
[15:07:58] <mib_hhrtma> just dropping the protocol part worked
[15:08:11] <mib_hhrtma> aha like you said :)
[15:08:37] <mib_hhrtma> thx!
[15:09:19] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Connection reset by peer)
[15:09:40] <jack> what did ~fn.finally turn into?
[15:09:44] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[15:09:45] <eddyb> jack: proc
[15:09:51] <eddyb> wait, ~fn?
[15:10:11] <klutzy> ~fn is gone (or will be)
[15:10:13] <jack> that's ~fn. let f = some_proc; f.finally(...) is what i'm asking about
[15:10:20] <klutzy> proc is new ~once fn
[15:10:53] <erickt1> nmatsakis: will do. So the reason why I ran into this is because I wanted to add support for iterating over `&mut Iterator`s. I did try implementing it directly, but I ran into an odd error: https://gist.github.com/erickt/7642679
[15:11:05] <bstrie> jack: never realized that existed. will have to ask pcwalton
[15:11:07] *** zz_kimundi is now known as kimundi
[15:11:46] <jack> bstrie: neither did i, but glfw uses it
[15:11:58] <erickt1> nmatsakis: it seems like rustc is now finding Iterator::len instead of Container::len in vec.rs, even though vecs don't seem to directly implement Iterator 
[15:12:08] <bjz> jack: I'm working on a fix
[15:12:08] *** Quits: DeTeam (DeTeam@92C799C.31715274.F5F3AF2.IP) (Quit: DeTeam)
[15:12:21] *** Joins: dherman_ (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[15:12:30] <bjz> jack: I'm having issues building the examples though to check it
[15:12:40] <jack> bjz: how did you fix that issue?
[15:12:57] <bjz> jack: I used extern "Rust" fn
[15:13:16] <nmatsakis> erickt1: the behavior of rustc when you have multiple methods with same name from distinct traits, particular with generic-y impls like "impl<T: ...> Foo for T", is pretty undefined
[15:13:25] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[15:13:36] <nmatsakis> erickt1: that last sort of impl is very handy but really wreaks havoc, I've got some ideas how to improve it, just so many things on plate
[15:13:37] <bjz> jack: I asked brson and I think he said that it should be impled for proc too
[15:13:52] *** Joins: froglegstew (Mibbit@9811B23A.916D3FF8.3BD9FE04.IP)
[15:14:13] <bjz> jack: perhaps I might be able to push my wip into a new branch and let you check it out?
[15:14:28] <jack> bjz: that would be nice. i mostly have done s/~fn/proc/ so ar :)
[15:14:56] *** Quits: dherman_ (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman_)
[15:14:58] *** Quits: ricepuddin (graham@moz-1D7A4284.wlan.ic.ac.uk) (Ping timeout)
[15:15:00] <erickt1> impl Clone for nmatsakis { … }
[15:15:08] <eddyb> erickt1: yes!
[15:15:23] *** Joins: dherman_ (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[15:15:32] <erickt1> nmatsakis: :) do you have an issue for this already, or would you like me to file one for you?
[15:15:37] <eddyb> or maybe impl nmatsakis for eddyb {}
[15:15:46] *** Joins: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net)
[15:15:51] <froglegstew> is rust suitable for my first lanuage?
[15:16:06] <nmatsakis> erickt1: imo this falls under #5527
[15:16:16] <nmatsakis> erickt1: though that issue is very light on specifics
[15:16:16] <erickt1> froglegstew: good morning! It probably would be a bit tricky to use for your first language
[15:16:31] <froglegstew> why
[15:16:40] <eddyb> froglegstew: baaad timing. 1.0 should be pretty good (and someone is working on a tutorial), but we're not there yet, things are still in flux
[15:16:46] <erickt1> froglegstew: The language is still going through some big changes, and we are light on a tutorial
[15:16:47] *** Quits: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net) (Ping timeout)
[15:17:03] <bstrie> froglegstew: how did you hear about rust?
[15:17:16] <bstrie> froglegstew: it's not common for people who haven't programmed before to find us :)
[15:17:41] *** Quits: dherman_ (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman_)
[15:18:05] <bstrie> froglegstew: that said, I'd prefer Python as a first language. but if you're looking for a challenge, then rust might not be bad :P
[15:18:32] <froglegstew> I am looking for a decent language to write a program, and read peter norvig about python and lisp
[15:18:34] <erickt1> nmatsakis: thanks. And it looks like my generic impl is https://github.com/mozilla/rust/issues/8075. I'll add my example to it
[15:19:25] <bstrie> froglegstew: what program would you like to write?
[15:19:26] <nmatsakis> froglegstew: tbh, I'd not start with Rust. If nothing else, the docs aren't really up to snuff nor targeting people who don't already know how to program
[15:19:39] <froglegstew> he said python is slow and lack of type check
[15:19:52] <nmatsakis> loath as I am to discourage anything from learning Rust
[15:19:53] <bstrie> well lisp lacks type checking too :P
[15:20:31] <froglegstew> then I turn to typed racket
[15:20:33] <bstrie> froglegstew: don't worry about languages being "slow". no serious language is so slow as to be unusable, except at the extreme high end
[15:20:44] *** Joins: ricepuddin (graham@moz-1D7A4284.wlan.ic.ac.uk)
[15:21:10] <eddyb> froglegstew: you could keep an eye on http://adridu59.github.io/rust-tuts/
[15:21:19] <bjz> jack: https://github.com/bjz/glfw-rs/pull/49
[15:21:48] <Ms2ger> froglegstew, whatever you do, don't do perl :)
[15:21:59] <froglegstew> I only want to learn one language
[15:22:03] <froglegstew> only one
[15:22:11] <bstrie> Ms2ger: nah, whatever you do, don't do intercal :P
[15:22:19] <bstrie> *INTERCAL
[15:22:23] *** Joins: canhtak (canhtak@moz-6F820ACE.wl.t.ulaval.ca)
[15:22:26] <bstrie> forgot it was an acronym
[15:22:31] <strcat> learning most of a language takes a day once you know similar ones
[15:22:35] *** Quits: ricepuddin (graham@moz-1D7A4284.wlan.ic.ac.uk) (Ping timeout)
[15:22:36] <Ms2ger> bstrie, that's obscure enough I haven't heard of it, so probably not very probable :)
[15:22:44] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[15:22:49] <bstrie> Ms2ger: the world's first esoteric language!
[15:22:54] *** Quits: thesnowdog (doug@72CF77FB.CDB23781.6F17036B.IP) (Ping timeout)
[15:22:54] <bstrie> wikipedia it
[15:22:59] <bstrie> it will make you smile
[15:23:06] <nmatsakis> intercal is great. "COME FROM". ha.
[15:23:11] <froglegstew> I search 
[15:23:23] <froglegstew> "if i want to learn only one language
[15:23:32] <froglegstew> then it said scala
[15:23:34] <pnkfelix> nmatsakis: Or, as Martin Rinard put it, the precursor to Aspect-Oriented Programming
[15:23:43] <bstrie> froglegstew: that's strange advice :P
[15:23:46] <nmatsakis> pnkfelix: even better ;)
[15:23:59] <bstrie> froglegstew: it's not about the language. what do you want to DO with the language. that's what is most important.
[15:24:12] <nmatsakis> pnkfelix: I particularly liked the multithreaded interpretation: multiple COME FROMs just causes many threads
[15:24:18] <bstrie> froglegstew: all languges excel at certain areas and fall short in others. so figuring out what you want to do will tell you the best language to use.
[15:24:19] <strcat> nmatsakis: I quite like http://esolangs.org/wiki/Entropy :P
[15:24:33] <strcat> what you need is a language like that with pointer arithmetic
[15:24:34] <froglegstew> I want to write some server side program
[15:25:00] <bstrie> froglegstew: what operating systems do you use?
[15:25:11] <bstrie> and are you willing to learn new ones :)
[15:25:11] <Ms2ger> bstrie, "PLEASE GIVE UP" <3
[15:25:17] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[15:25:19] <froglegstew> mac linux windows that's ok
[15:25:25] <pnkfelix> strcat: that is one of the best 99 bottles runs I have seen
[15:25:52] <froglegstew> yes
[15:26:01] <froglegstew> oberon?
[15:26:10] <bstrie> froglegstew: not oberon
[15:26:13] <bstrie> :P
[15:26:15] *** Joins: sigma (sigma@moz-D4F04D48.range86-174.btcentralplus.com)
[15:26:48] <bstrie> froglegstew: the most important part of learning your first language is making sure you have a lot of people to ask for help. so you need to pick a language with a big community
[15:27:18] *** Joins: sanxiyn (tinuviel@B4104EBB.3CC170B1.1E14B209.IP)
[15:27:20] <froglegstew> go?
[15:27:38] <bstrie> froglegstew: go could work, but it's a bit low-level
[15:27:44] <Scriptor> PHP?
[15:27:48] <kimundi> NO!
[15:27:52] <froglegstew> no no no
[15:28:09] <froglegstew> I need a powerful language
[15:28:15] <bstrie> kimundi: PHP still wins the "stop making me learn about setting up a programming environment and just let me write the god damn program" contest :P
[15:28:22] <Scriptor> sounds like the consensus here is PHP
[15:28:25] <kimundi> ruby? Seems to be a nice language
[15:28:25] *** Quits: Jesin (Jesin@moz-63C897DA.res.lehigh.edu) (Ping timeout)
[15:28:32] *** Quits: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[15:28:43] <bstrie> froglegstew: PHP *is* a powerful language
[15:28:47] <Scriptor> ruby's pretty nifty
[15:28:51] <Ms2ger> PHP, eww :)
[15:28:56] <bstrie> haha
[15:29:02] <bstrie> I mean, I write PHP for my job, so I am allowed to hate it
[15:29:05] <froglegstew> I hope this language makes me cool
[15:29:11] <Scriptor> same here, bstrie 
[15:29:13] <bstrie> froglegstew: oh well then PHP won't make you cool
[15:29:18] <bstrie> froglegstew: but ruby will make you VERY cool
[15:29:29] <bstrie> you will be legally allowed to wear sunglasses while indoors
[15:29:30] <Scriptor> nah, ruby's a little 2009
[15:29:32] <sanxiyn> Well programming languages usually don't make anyone cool
[15:29:41] <Scriptor> even node's starting to be past its prime
[15:29:48] <bstrie> we're all on clojure now
[15:29:55] <Scriptor> *clojurescript
[15:30:12] <bstrie> we're all on proprietary clojurescript dialects which have embraced M-expressions
[15:30:19] <froglegstew> cool+fast+one for many use+beautiful+ask for help
[15:30:26] <sanxiyn> Whenver PHP discussion comes up I link to this post:
[15:30:27] <sanxiyn> http://www.ianbicking.org/blog/2008/01/what-php-deployment-gets-right.html
[15:30:32] <sanxiyn> What PHP Gets Right
[15:30:35] *** Joins: thesnowdog (doug@7860FEB4.8E46834.6F17036B.IP)
[15:30:36] <sanxiyn> Which really rings true
[15:31:03] <bstrie> sanxiyn: it really does. I spent fuckin DAYS setting up flask
[15:31:13] <strcat> what it gets right is having a searchable name
[15:31:15] <strcat> bstrie: wat?
[15:31:18] <sanxiyn> If one wants to replace PHP (which I fully support), one first needs to understand why PHP is successful
[15:31:32] <Ms2ger> sanxiyn, I'd expected that post to say "This space intentionally left blank" ;)
[15:31:34] <strcat> bstrie: how can you spend days setting up flask ;p
[15:31:42] <sanxiyn> Ms2ger: Go read it
[15:31:43] <bstrie> strcat: I expected web programming in python to be as easy as PHP, i.e. putting a file in a directory and just proxy_passing to a server
[15:32:04] <Scriptor> sanxiyn: but only if you want to fill the same niche php did
[15:32:06] <strcat> bstrie: it's even easier
[15:32:09] <strcat> you don't need a web server
[15:32:14] <froglegstew> bstrie what os do you mean above?
[15:32:24] <sanxiyn> Scriptor: I said "if one wants to replace PHP"
[15:32:30] <comex> strcat: and there's the rub
[15:32:41] <Scriptor> whoops, sorry
[15:32:44] <comex> with a lot of these things you need to keep processes running for each application
[15:32:48] <bstrie> strcat: I spent days wrestling with virtualenv, pip, gunicorn, and supervisord
[15:32:53] <bstrie> I had to learn what "WSGI" was
[15:32:59] <strcat> bstrie: no, you didn't have to
[15:33:02] <bstrie> welp, I did
[15:33:04] <strcat> you didn't have to use any of those things
[15:33:05] <bstrie> because nothing worked
[15:33:13] <bstrie> and there were no docs to explain how to do it
[15:33:18] <comex> not so good when you want to create 50 throwaway scripts and scatter them across a web root - sure, it won't make a coherent website, but that's not the point
[15:33:19] <strcat> bstrie: has nothing to do with python or flask
[15:33:42] <strcat> you went on long pointless tangents for unrelated things
[15:33:52] <sanxiyn> bstrie: Well you could have started with Django and manage.py runserver
[15:33:56] <sanxiyn> That works for development
[15:34:15] <strcat> sanxiyn: flask doesn't need anything else
[15:34:18] <strcat> neither does bottle
[15:34:21] <sanxiyn> Yup
[15:34:33] <bstrie> strcat: it *does*. PHP Just Fucking Works, because people have put work into making it idiot-proof. you say "don't blame the language or the framework", I say "don't blame the guy who has no idea what he's doing and is given no direction on how to do it by either the language or the framework"
[15:34:38] <strcat> http://ix.io/99g here's bottle's hello world
[15:34:41] <strcat> chmod +x foo.py
[15:34:43] <strcat> ./foo.py
[15:34:49] <strcat> bottle itself is a single python file
[15:35:00] <strcat> so even if you don't have a package manager or any knowledge about that stuff it's easy to 'deploy'
[15:35:09] <sanxiyn> bstrie: That's because you didn't want to use built-in web server
[15:35:16] <Scriptor> what server would that run on
[15:35:22] <sanxiyn> wsgiref, I think
[15:35:23] <Scriptor> python's built-in onee?
[15:35:26] <sanxiyn> Yup
[15:35:30] <bstrie> you know what PHP doesn't require? the knowledge of alternatives like "bottle" or "flask" or "django" are
[15:35:32] <sanxiyn> But that doesn't matter if you want to program right away
[15:35:34] <bstrie> it Just Fucking Works
[15:35:41] <bstrie> don't get me wrong
[15:35:41] <Scriptor> is wsgiref okay for a production server?
[15:35:42] <bstrie> I still hate PHP
[15:35:48] <strcat> bstrie: no it doesn't
[15:35:50] <sanxiyn> Scriptor: No, and I think that's PHP's pro
[15:35:56] <strcat> so what were you running php behind? apache?
[15:35:59] <strcat> so you had to set up apache
[15:36:04] <strcat> that's far harder than what I just showed
[15:36:07] <Scriptor> sanxiyn: yeah, sounds about right
[15:36:10] <bstrie> strcat: you're a brilliant genius, you do *not* get to tell us idiots what we do and do not find hard :)
[15:36:24] <strcat> bstrie: so, tell me what's hard about chmod +x foo.py && ./foo.py
[15:36:28] <sanxiyn> strcat: Thankfully, Linux distributions usually preconfigure Apache with PHP so that you don't have to
[15:36:29] <strcat> on that little example
[15:36:31] <sanxiyn> strcat: That is a great asset
[15:36:46] <Scriptor> strcat: the beginners we're talking about here starting out with php never had to set up apache
[15:36:51] <sanxiyn> strcat: It isn't hard.
[15:36:55] <comex> well, i mentioned why that would be no good for me
[15:36:59] <Scriptor> they just used whatever free/cheap crappy shared host that does it all for them
[15:37:12] <comex> i suppose i could use cgi for little things, but ugh, startup time
[15:37:17] <Scriptor> so that all they have to do is either ftp or even just click the big 'upload' buttons
[15:37:29] <bstrie> strcat: first of all, you presume that more than 0.00001% of humanity is able to decipher that line, or even infer its existence, or the idea of "permissions" on files at all
[15:37:32] <sanxiyn> Scriptor: Yes, and it's important to ask why PHP has that and Python doesn't
[15:37:42] <Scriptor> sanxiyn: I fully agree
[15:37:43] <sanxiyn> Because PHP does fault isolation
[15:37:54] <strcat> bstrie: if you're on windows you don't need to deal with the permissions...
[15:38:09] <comex> btw, python also doesn't generally let you mix code and html
[15:38:13] <comex> i know, the horror, the horror - but
[15:38:20] <comex> it's useful to keep tiny things in a single file
[15:38:20] <sanxiyn> If your PHP does infinite loop, it's okay; it will be killed
[15:38:36] <sanxiyn> Handling infinite loop is critical to cheap web hosting
[15:38:43] <sanxiyn> Because people will run broken codes
[15:38:52] <sanxiyn> If your PHP leaks memory, it's okay
[15:38:56] <sanxiyn> This is critically important
[15:39:18] <strcat> sanxiyn: so how does the web host deal with them forking a bunch of processes?
[15:39:19] <sanxiyn> That's why PHP has cheap web hosting (well being their first helped) and other languages don't
[15:39:25] <strcat> obviously they can't just use it out of the box that way
[15:39:35] <Scriptor> I think they might disable forking
[15:40:21] <sanxiyn> strcat: You usually can't call fork in web host PHP
[15:40:27] <strcat> so they audited the whole php stdlib?
[15:40:27] <sanxiyn> And that's fully ok
[15:40:39] <sanxiyn> strcat: Probably not, but it's about protecting from stupidity, not malice
[15:40:42] <strcat> I can't see how that would ever be enough for a web host
[15:40:50] <strcat> they still need something more
[15:40:53] <Scriptor> we're not talking about top-quality hosting here
[15:41:18] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[15:41:29] <Scriptor> as far as I know they just disable pctnl_fork, exec, and the like
[15:41:46] <Scriptor> *pcntl
[15:41:52] <bstrie> that "hello world" from bottle amuses me in how much institutionalized knowledge it requires
[15:42:11] <Sharp> bstrie: Who cares whether PHP microoptimizes for the first thirty minutes of user experience when it doesn't measure up for the entire rest of the duration of its existence?
[15:42:17] <sanxiyn> bstrie: Well, doing PHP also requires quite some infrastructure behind it
[15:42:32] <sanxiyn> The difference is it's not you doing that work
[15:42:38] <bstrie> Sharp: I'm amused that people think that I want to be the shining champion of this terrible language
[15:42:44] <bstrie> sanxiyn: here's hello world for PHP
[15:42:45] <Sharp> I don't think you do
[15:42:47] <bstrie> hello world
[15:42:48] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.2)
[15:42:50] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[15:42:59] <bstrie> ^ done
[15:43:02] <sanxiyn> bstrie: Well uploading files using FTP also requires quite some knowledge :)
[15:43:04] <Sharp> I'm just confused about why this even matters.
[15:43:07] <sanxiyn> I've seen people struggling with that
[15:43:14] <Scriptor> Sharp: because worse is better
[15:43:18] <Scriptor> that's pretty much it
[15:43:23] <strcat> except it's actually just worse
[15:43:24] <froglegstew> If Rust is not ready, I want to learn haskell (yesod coc is friendly) as my first language, because it is fast cool type check, old for many helps, right?
[15:43:24] <sanxiyn> Installing PHP bulletin board is *extremely difficult* for most people
[15:43:29] <bstrie> sanxiyn: true, I agree. though it's saying something that that's the *biggest* hurdle to setting up a PHP environment
[15:44:02] <sanxiyn> froglegstew: Your first language?!
[15:44:04] <strcat> bstrie: yeah, because again, a single .py file is soooooo hard to deploy ;p
[15:44:05] <bstrie> froglegstew: are you really into mathematics?
[15:44:19] <sanxiyn> froglegstew: You haven't programmed before?
[15:44:29] <sanxiyn> strcat: It sort of is.
[15:44:31] *** Quits: bynaryshef (bynaryshef@moz-647E89A6.mem.bellsouth.net) (Quit: Leaving)
[15:44:40] <Scriptor> froglegstew: what's your background
[15:44:41] <froglegstew> I want to do some NLP, and never program really
[15:44:41] * strcat doesn't see how
[15:45:11] <sanxiyn> froglegstew: Ask someone who does NLP what they are using
[15:45:11] <bstrie> strcat: you know what took me a long time to realize in flask? that the route path had to be relative to the web root, and not the directory containing the file. took me *so long* to realize that was a problem, and not just a server misconfiguration
[15:45:22] <sanxiyn> froglegstew: That'd be the easiest way to decide
[15:45:27] <Scriptor> froglegstew: python has a great nlp library
[15:45:34] <bstrie> these are the sorts of things that you're too smart to realize would be problems
[15:45:34] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[15:45:36] <strcat> nltk isn't really great
[15:45:54] <strcat> there are way better java ecosystem libs - they have modern algorithms, aren't slow as hell + broken ;p
[15:45:54] <froglegstew> what is great?
[15:46:04] <Scriptor> strcat: hah, fair enough
[15:46:15] <sanxiyn> strcat: I think *NLTK Book* is a sort of good introduction book
[15:46:16] <strcat> but yes, nltk is probably better than any C/C++ lib you will find
[15:46:18] <strcat> or ruby, or haskell
[15:46:21] <sanxiyn> strcat: I agree code is not much to be proud of
[15:46:42] <sanxiyn> So if you want to use NLTK Book, use NLTK
[15:46:56] *** Quits: Florob (Florob@moz-39532932.de) (Client exited)
[15:47:16] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[15:47:19] <Scriptor> froglegstew: if you've never really programmed before, prepare for a long ramp-up before you're comfortable with nlp
[15:47:36] <Scriptor> regardless of what language you learn
[15:47:56] <froglegstew> OK, rust community is friendly
[15:47:58] <bstrie> Sharp: anyway, to answer your question, the reason why it's important that PHP optimizes for the first 30 seconds of user experience is because 99.999986% of humanity doesn't have the patience to tolerate the sort of yak-shaving it takes to set up a programming environment
[15:48:14] <froglegstew> I
[15:48:27] <froglegstew> I'd better wait rust to have a NLP lib
[15:48:30] <bstrie> froglegstew: we try :) come back once you realize that you actually do want to learn lots of languages!
[15:48:48] <Sharp> bstrie: There are only 840 programmers? :P
[15:48:54] <Sharp> But yes, I see what you mean.
[15:48:55] <bstrie> Sharp: that's an upper bound, yes
[15:49:02] *** Quits: ssbr_ (~ssbr@46FE74EC.C60FE7DC.4065847B.IP) (Ping timeout)
[15:49:09] <sanxiyn> froglegstew: Have you looked at http://nltk.org/book/ ?
[15:49:21] <mark_edward> pnkfelix, ping
[15:49:27] <pnkfelix> mark_edward: pong
[15:49:32] <sanxiyn> froglegstew: One of book's merit is that it *does not assume* you know Python
[15:49:36] <sanxiyn> It starts from Python tutorial
[15:49:59] <froglegstew> I want to learn only language, so I dare to learn python
[15:50:00] *** Joins: noam (noam@F6B530A7.720527A7.416762B.IP)
[15:50:00] <bstrie> Sharp: for all we bash PHP, it was the dead-simple ease-of-use of the LAMP stack that allowed linux to attain utter dominance of the internet in the first place
[15:50:21] <bstrie> though let's also give credit to perl, which is also frequently bashed :)
[15:50:35] <froglegstew> I want to learn only one language, so I dare not to learn python
[15:50:37] *** Quits: Deewiant (deewiant@moz-C015B7F8.iki.fi) (Ping timeout)
[15:50:38] <sanxiyn> bstrie: Perl did great when it stayed with CGI model
[15:50:39] <mark_edward> pnkfelix, so i heard that one reason C++ GC's are so bad compared to say Java/C# ones is because the C++ GC's don't have enough information. What is this missing information, and will Rust GC's be able to get their hands on it?
[15:50:44] <Sharp> Well, the L in LAMP isn't a bad thing :)
[15:50:45] <sanxiyn> bstrie: Which is sort of similar to PHP model
[15:50:50] <mark_edward> froglegstew, you can't just learn one language
[15:50:52] <bstrie> sanxiyn: indeed
[15:51:09] <sanxiyn> bstrie: mod_perl was problematic, and difference of CGI perl and mod_perl, I think, proves some points
[15:51:17] <Scriptor> imagine if WIMP caught on
[15:51:21] <kimundi> froglegstew: Leraning programming isn't really about one language. Once you understand the principles, it's easy to learn new ones
[15:51:22] <Scriptor> somehow
[15:51:29] <bstrie> froglegstew: where are you hearing that python can't be your only language? I'm not trying to dissuade you, it's just a strange position to take
[15:51:31] <mark_edward> froglegstew, and learning languages is fun anyway, i've only been programming 2 years and I know C, C++, Java, C#, Haskell, Python, Rust
[15:51:38] <sanxiyn> froglegstew: I strongly advise against learning only one language
[15:51:39] <pnkfelix> mark_edward: I think Rust will be able to do much better than C++.
[15:51:49] <sbalmos> Scriptor: WISA. Already here.
[15:51:54] <strcat> pnkfelix: (FWIW, C++11 added minimal GC support)
[15:51:59] <strcat> although afaik no one uses it
[15:52:13] <sbalmos> strcat: Wasn't that just a rename of Boehm?
[15:52:18] <strcat> no
[15:52:23] <strcat> nothing to do with boehm
[15:52:24] <sbalmos> k I'll shut up. :)
[15:52:29] <mark_edward> pnkfelix, why? If i'm correct, the Rust GC's will essentially be allocators, which is the scheme C++ ones use as well I think. what can rust do better, and why?
[15:52:30] <pnkfelix> mark_edward: The extra-information is essentially a correct description of the layout of objects, and of the frames on the stack.
[15:52:39] <froglegstew> OK, but I do not want to learn many languages
[15:52:45] <strcat> pnkfelix: http://en.cppreference.com/w/cpp/memory/gc/declare_reachable etc.
[15:53:19] <pnkfelix> strcat: okay maybe I will look at it.
[15:53:26] <froglegstew> according to strcat, I probably should learn java
[15:53:30] <strcat> afaik it's basically just tools to make a conservative gc less conservative
[15:53:31] <sanxiyn> Another PHP advantage is that you can have syntax error in one file, and another file will still work
[15:53:33] <Sharp> bstrie: It's just like, is this relevant to Rust as a language?  I really think there are only a few languages competing for the "brand new programmer" demographic, though I could be wrong about that.
[15:53:46] <sanxiyn> That is, different URLs fail indepdently
[15:53:48] <strcat> froglegstew: well if what you care about is quality NLP libraries, they are all in java ;p
[15:53:52] <sanxiyn> This is not the case in Python web frameworks
[15:53:55] <mark_edward> pnkfelix, will Rust GC's have access to this?
[15:53:55] *** Joins: FreeFull (freefull@E424A224.387C8A0C.DC9D01B1.IP)
[15:54:02] <strcat> you don't have to use java to use java libs
[15:54:03] <Sharp> froglegstew: Java is a terrible language but it has wonderful library support .
[15:54:06] <strcat> there are lots of other languages on the jvm
[15:54:07] <pnkfelix> mark_edward: Well, we have a lot of the necessary infrastructure already
[15:54:09] *** Quits: vodik (simon@moz-FD4ADBC6.cable.teksavvy.com) (Quit: class)
[15:54:28] <sanxiyn> froglegstew: So your goal is doing some natural language processing using computers?
[15:54:39] <bstrie> java might be a terrible language for learning, but so many people try so hard to make it a language for learning that it's not as bad as it could be
[15:54:58] <sbalmos> Completely depends on what's being learned
[15:55:04] <Sharp> It's not a bad language for learning, necessarily, but I find it pretty terrible for actually programming :P
[15:55:07] <sbalmos> I could argue starting with assembly. )
[15:55:13] <mark_edward> pnkfelix, really? cool. will user defined GC's using the planned `new(expr)` syntax have access to this as well?
[15:55:16] <pnkfelix> mark_edward: e.g. we already maintain TyDesc metadata and attach it to @shared objects.  (See its current layout in unstable::raw::Box<T> )
[15:55:16] <sanxiyn> sbalmos: Well, learning to program
[15:55:19] <strcat> sbalmos: just please not x86 assembly
[15:55:21] <froglegstew> so why so bad a language has so many good libs?
[15:55:39] <Sharp> froglegstew: That's a discussion I've had with a lot of people :P
[15:55:43] <pnkfelix> mark_edward: user-defined GC is a different story.  pcwalton has spent much more time promoting (and presumably thinking about) that topic.
[15:55:44] <sbalmos> strcat: Started out with the Moto 68k series.
[15:55:46] <sanxiyn> froglegstew: You could write a PhD thesis on it :)
[15:55:46] <pnkfelix> mark_edward: than I have
[15:55:50] <Scriptor> froglegstew: because history is a convoluted thing
[15:55:57] <froglegstew> sanxiyn I want to do some NLP works
[15:55:59] <bstrie> froglegstew: just like PHP, java has had very, very good marketing
[15:56:25] <sanxiyn> I think "marketing" is a codeword for "I haven't analyzed"
[15:56:25] <bstrie> froglegstew: because, at the end of the day, the popularity of a language really has very little to do with the quality of the language :) this is your first lesson!
[15:56:27] <Scriptor> everyone was excited for the successor of C++ that was going to work *everywhere*!
[15:56:35] <pnkfelix> mark_edward: My specialty has been with GC's that are tightly integrated with the compiler and runtime system.  I don't know if its feasible for a user-defined GC to be competitive, unless we expose ways for the user to e.g. emit their own write-barrier code from within rustc.
[15:56:36] <mark_edward> pnkfelix, oh ok. do you think I could ask him about this?
[15:56:41] <sanxiyn> In my opinion, Java did some specific things well, like PHP did some specific things well (including deployment)
[15:56:43] <sbalmos> Scriptor: C++/CLI? :p
[15:56:49] <FreeFull> C++ can be a pain
[15:56:52] *** Joins: ricepuddin (graham@moz-D2FF5C45.wlan.ic.ac.uk)
[15:57:13] <pnkfelix> mark_edward:  … I'm not going to stop you from talking to anyone.
[15:57:14] <strcat> Scriptor: not much of a successor to C++ if it's a totally different language :P
[15:57:19] <strcat> maybe that's how they marketed it
[15:57:27] <sanxiyn> There should be a serious research into why programming languages (or computing technologies) are adopted and why some are not
[15:57:29] *** Joins: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net)
[15:57:35] <FreeFull> Java was the COBOL replacement
[15:57:40] <sbalmos> strcat: Power4 assembly was interesting.
[15:57:53] <mark_edward> pnkfelix, i know but he seems like a busy guy, i was wondering if you think he'd be willing/able to talk on this stuff with me
[15:58:09] <sbalmos> C#'s a pretty decent language. Can't say much about its library ecosystem though
[15:58:09] *** Quits: Scriptor (anonymous@moz-E06F46F0.corp.bitshelter.com) (Ping timeout)
[15:58:19] <strcat> C# is a nice language.
[15:58:22] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[15:58:27] <froglegstew> I heard that java is good at large project
[15:58:50] <bstrie> froglegstew: java can be good for projects with *lots of developers*
[15:58:51] <pnkfelix> mark_edward: is your goal to implement your own user-defined GC?  Or are you just interested in it as a potential client of a hypothetical user-defined GC?
[15:58:52] <FreeFull> C# is a nice language, its flaw is that it's Microsoft's
[15:58:55] <sbalmos> strcat: It's getting a little schizoid with the DLR support.
[15:58:59] <sanxiyn> froglegstew: Probably true, in the sense that many large projects were done in Java, so they have accumulated wisdom
[15:59:02] <Sharp> froglegstew: It's *used* for large projects.
[15:59:02] <bstrie> froglegstew: that's distinct from "large project"
[15:59:03] *** Joins: Scriptor (anonymous@moz-E06F46F0.corp.bitshelter.com)
[15:59:05] <mark_edward> pnkfelix, interested as a client, 
[15:59:06] *** Joins: willingc (willingc@moz-B4760708.san.res.rr.com)
[15:59:07] *** Joins: saml (sam@moz-14C16814.cst.lightpath.net)
[15:59:23] <strcat> FreeFull: well it certainly has more flaws than that
[15:59:25] <sanxiyn> bstrie: Eh, how do you define "large project"?
[15:59:32] <strcat> but it's nicer than java ;p
[15:59:44] <sanxiyn> Also, you can use Java libraries in C#
[15:59:49] <sbalmos> ...
[15:59:50] <froglegstew> c# is slower than java I heard
[15:59:52] <sanxiyn> That solves some pains with library problem
[16:00:05] <strcat> froglegstew: it's not
[16:00:07] <sanxiyn> froglegstew: Probably true, but not by much
[16:00:20] <sbalmos> sanxiyn: IKVM is not a solve-all problem
[16:00:23] <FreeFull> sanxiyn: Java libraries in C#? I don't think you can
[16:00:38] <sanxiyn> sbalmos: It works fairly well
[16:00:41] <Sharp> C# and Java are both "slow," I wouldn't use either in a situation where performance was critical.
[16:00:52] <bstrie> sanxiyn: as used in http://steve-yegge.blogspot.com/2007/12/codes-worst-enemy.html
[16:00:56] <FreeFull> Sharp: What would you use?
[16:01:01] <froglegstew> some one told me that scala is decent but bad syntax
[16:01:02] *** kimundi is now known as zz_kimundi
[16:01:03] <bstrie> sanxiyn: (I think that's the right one... need to reread it)
[16:01:09] <strcat> Sharp: faster than most languages
[16:01:11] <Sharp> Probably a C-family language.  Most of the time, performance *isn't* critical :P
[16:01:17] <Sharp> strcat: True.
[16:01:31] <sbalmos> I know a number of people in the Java land where counting ms is critical.
[16:01:36] <sbalmos> But to each their own
[16:01:55] <sbalmos> As long as you have more than a hammer
[16:02:10] *** Quits: ricepuddin (graham@moz-D2FF5C45.wlan.ic.ac.uk) (Ping timeout)
[16:02:15] <bstrie> speaking of java perf, I read http://www-cs.canisius.edu/~hertzm/gcmalloc-oopsla-2005.pdf this weekend
[16:02:17] <froglegstew> If i have to use java, I would learn typed clojure instead
[16:02:22] *** Joins: nsf (nsf@moz-EEF3238A.convex.ru)
[16:02:38] <pnkfelix> mark_edward: Well, I think there are still a lot of question marks in this area for us.
[16:02:39] <sanxiyn> froglegstew: You seemed to have heard lots and lots of things, for a person who said one hasn't programmed yet
[16:02:49] <froglegstew> yes
[16:03:04] <strcat> bstrie: they're comparing to an obsolete memory allocator, though
[16:03:05] <sanxiyn> I repeat, if you want to do NLP programming, I'd locate a person nearby who does NLP programming
[16:03:10] <froglegstew> before I walk, I have to think about which leg should I put first
[16:03:13] <sanxiyn> And ask them
[16:03:14] <bstrie> strcat: right, that was my concern
[16:03:19] <strcat> tcmalloc is waaaaaaaay faster than any GC, with basically any metric you use
[16:03:34] <bstrie> I'd like to see it reproduced nowadays
[16:03:35] <sbalmos> froglegstew: And you're currently spouting out that walking with Nikes on are clearly the way to go.
[16:03:38] *** Joins: ssbr_ (~ssbr@98D3BE03.C60FE7DC.4065847B.IP)
[16:03:44] <bstrie> eight years is a long time
[16:03:59] <sanxiyn> froglegstew: put any leg first
[16:04:07] <mmalecki> froglegstew: you're thinking about it too much, if you're just getting started programming isn't about performance
[16:04:11] <bstrie> don't use your legs, we have bikes for that
[16:04:13] <pnkfelix> mark_edward: I won't attempt to speak for pcwalton.  I think if you have concrete benchmarks or use-cases where you think a user-defined GC will be necessary, we'd probably like to know about them.  (In our case, I believe a driving concern is integrating with SpiderMonkey's GC, and being able to carry smart-pointers that point into SpiderMonkey's GC-managed heap.)
[16:04:17] * Sharp would just start with Python if he had to do it over.
[16:04:23] <sanxiyn> froglegstew: Do you have some specific NLP project in mind?
[16:04:26] <mmalecki> froglegstew: just learn any language and start a project to go with it
[16:04:33] <mark_edward> sanxiyn, he heard so much because programmers spend as much time blogging as programming.
[16:04:36] <sbalmos> bstrie: Bah. That gets too sweaty and hot. We have cars for that!
[16:04:41] *** Quits: mib_hhrtma (Mibbit@moz-535184AB.customers.ownit.se) (Quit: http://www.mibbit.com ajax IRC Client)
[16:04:51] <Sharp> mark_edward: Hah.
[16:05:02] <bstrie> sbalmos: why are we even going out at all? let's just telecommute to work and order our groceries on amazon
[16:05:10] <froglegstew> sanxiyn no
[16:05:16] <sbalmos> bstrie: Been there, done that. I prefer to get out every once in a while. Cabin fever. ;)
[16:05:51] <mark_edward> pnkfelix, are user defined allocators definitely in the future?
[16:06:02] <bstrie> froglegstew: quick, go to your web browser, type Ctrl+Shift+J, then type "2 + 2" and hit enter. there, now you're officially a programmer :)
[16:06:10] <strcat> mark_edward: as soon as generic destructors work...
[16:06:27] <sbalmos> bstrie: QBasic!
[16:06:33] <sanxiyn> bstrie: Which browser is this? :)
[16:06:44] <bstrie> sanxiyn: that should work in both firefox and chrome
[16:06:59] <Sharp> bstrie: What about Internet Explorer?  Isn't that easier to use than either? :P
[16:07:02] <sanxiyn> bstrie: Can't really assume that though
[16:07:02] <froglegstew> bstrie ok I have been now
[16:07:14] <froglegstew> I use chrome
[16:07:17] *** Quits: avsej (avsej@DF1824D5.EFF97412.48F984E6.IP) (Client exited)
[16:07:18] <bstrie> sanxiyn: but if it doesn't work, then they've still experienced the pain of setting up your programming environment and thus is an honorary programmer regardless
[16:07:33] *** Quits: Scriptor (anonymous@moz-E06F46F0.corp.bitshelter.com) (Quit: Scriptor)
[16:07:38] <sanxiyn> bstrie: I really should use this routine in the future
[16:07:40] <strcat> mark_edward: https://github.com/thestinger/rust-core/blob/master/core/vec.rs as soon as generic dtors work, every container and smart pointer in rust-core will use an allocator API like that
[16:07:41] * bstrie hands froglegstew a diploma
[16:07:50] <sanxiyn> bstrie: Have you tried this before?
[16:08:09] <bstrie> sanxiyn: yeah, I do this with all my friends who ask about programming :)
[16:08:17] <sanxiyn> Yeah thought so
[16:08:24] <sanxiyn> It seems to have been practiced move
[16:08:31] <bstrie> haha
[16:08:34] <bstrie> you've found me out!
[16:08:42] <bstrie> let's be honest here
[16:08:57] <bstrie> the power of the web inspector is a pretty awesome secret of web browsers
[16:09:25] <sigma> I did not know that existed.
[16:09:31] <mark_edward> strcat, cool
[16:09:33] *** Quits: maxli (maxli@moz-4D28BA20.student.cs.uwaterloo.ca) (Quit: Leaving.)
[16:09:34] <bstrie> !!!!
[16:09:36] <froglegstew> I heard that the inventor of javascript leads the project of rust
[16:09:43] <bstrie> froglegstew: lol, nope
[16:09:45] <sigma> and the little mozilla ascii art that appears when you type help is win :)
[16:09:47] <sbalmos> *facepalm*
[16:09:49] <Sharp> froglegstew: Emphatically untrue :P
[16:09:51] <sanxiyn> froglegstew: Not really
[16:09:52] <benh> oh is it?
[16:09:56] <bstrie> froglegstew: but he works for the same company :)
[16:10:02] <pnkfelix> … he is higher in the mgmt chain ...
[16:10:09] <froglegstew> on wikipedia or some
[16:10:11] <benh> Netscape invented js, Mozilla is ~basically~ Netscape, Mozilla is heading rust ;)
[16:10:15] <Sharp> sigma: Wait, I didn't know that.
[16:10:18] <strcat> bstrie: let x = new Boolean(false); if (x) { console.log(x == false) }
[16:10:19] <sanxiyn> pnkfelix: Isn't he C-level management?
[16:10:19] <strcat> :D
[16:10:35] <strcat> bstrie: er
[16:10:35] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[16:10:37] <strcat> bstrie: var x *
[16:10:44] <strcat> I guess let will work in ffx ;p
[16:10:53] <bstrie> sigma: if you're in firefox, you get a more powerful web inspector with ctrl+shift+K (or I, or C)
[16:11:07] <froglegstew> and why the original leader leaves rust team?
[16:11:13] <froglegstew> maybe a secret
[16:11:24] <Sharp> benh: "Mozilla is ~basically~ Netscape" -- years of marketing down the drain :(
[16:11:24] <pnkfelix> sanxiyn: doesn't that put him higher up in the mgmt chain?
[16:11:25] <bstrie> froglegstew: because graydon is brilliant, but also apparently a hummingbird
[16:11:31] <sanxiyn> froglegstew: Yeah, the reason was not published
[16:11:54] <sanxiyn> pnkfelix: It does?
[16:12:03] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[16:12:21] *** Joins: Dessimat0r (Dessimat0r@E879B262.8D4FD984.4320F744.IP)
[16:12:29] <pnkfelix> sanxiyn: maybe I misunderstand what you mean by "C-level".  I took it to mean "a three letter acronym starting with a C; CTO, CFO, etc"
[16:12:43] <sanxiyn> Yes I meant that
[16:13:03] <sanxiyn> pnkfelix: I wasn't diagreeing with you :)
[16:13:14] *** Joins: Scriptor (anonymous@moz-E06F46F0.corp.bitshelter.com)
[16:13:19] <pnkfelix> sanxiyn: ah, okay, that resolves my confusion.
[16:13:27] <bstrie> from what I gathered over public discourse, graydon left because he was getting excessive stress from being the project lead
[16:13:31] <bstrie> but of course, I can only conjecture
[16:13:38] <froglegstew> Would Rust help reducing the number of languages or adding more?
[16:13:45] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Ping timeout)
[16:13:49] <sanxiyn> froglegstew: Adding more
[16:13:54] <sanxiyn> (like, one, that is, Rust)
[16:14:02] <sigma> rust will just be adding to the heap, but it looks like a good addition :)
[16:14:02] <sanxiyn> That was easy to answer
[16:14:03] <bstrie> but he's still the rust BDFL, just in exile :P
[16:14:10] *** victorporof|away is now known as victorporof
[16:14:32] <Sharp> Hanging out in this room, you will only end up trying more languages, not fewer.  Of that I can assure you.
[16:14:51] <benh> oh my sigma thank you for telling me about 'help' ;)
[16:14:52] * sanxiyn tries to remove @Pat from rustc
[16:14:53] <froglegstew> I mean if Rust succeed, some language would be gone
[16:15:03] <sanxiyn> froglegstew: It doesn't work that way
[16:15:05] <strcat> nothing would be 'gone'
[16:15:12] <bstrie> froglegstew: it's almost impossible for languages to ever become "gone"
[16:15:13] <sigma> benh: was the first thing I thought to type :)
[16:15:19] <bstrie> there are still businesses running on punched-card machines
[16:15:29] <Sharp> I've heard a couple of people come in with that sentiment now, who's doing Rust's marketing? :)
[16:15:35] <bstrie> no language will ever be totally eradicated, at least not until the sun engulfs the earth
[16:15:36] <Scriptor> if Rust succeeds it might keep people from choosing other languages for *new* projects
[16:15:46] <Scriptor> but existing code in other langs will still be there
[16:16:03] *** Quits: fabrice (fabrice@moz-94F028C6.hsd1.ca.comcast.net) (Quit: Leaving.)
[16:16:15] *** Joins: fabrice (fabrice@moz-94F028C6.hsd1.ca.comcast.net)
[16:16:20] <benh> Maybe if Rust is the final programming language, everybody else will stop inventing new ones and all the PLT people can come home again, at last.
[16:16:23] <sigma> I have a friend whose company started a new project in cobol about 4 months ago
[16:16:27] <benh> I am sure this will happen.
[16:16:31] <sanxiyn> bstrie: I see you are optimistic about future of humanity
[16:16:35] <sbalmos> rIIIIGHT
[16:16:37] <Yoric> balpert: Certainly.
[16:16:40] <Yoric> balpert: uping
[16:16:44] <Yoric> benh: Certainly.
[16:16:56] <sigma> and not even cobol 2002, cobol 1985
[16:17:34] <sanxiyn> Ada 2012 is newer than C++11!
[16:17:39] <Sharp> It certainly seems like the barrier to entry for making new languages is lower than ever.
[16:17:41] <froglegstew> about who is marketing for rust, I think that there must be some dreams that meet the ones who are willing to marketing for them.
[16:17:52] <strcat> sanxiyn: clang has full C++14 support already, it's from the future ;p
[16:18:00] <mark_edward> sanxiyn, Ada is a really nice lang from what i've seen. never used it, but seems like a better C++
[16:18:01] <strcat> sanxiyn: http://clang.llvm.org/cxx_status.html
[16:18:04] <bstrie> sanxiyn: even in the blasted, radioactive ruins of earth circa 4 billion A.D., somewhere there will exist a small cadre of self-replenishing nanobots whose collective eternal life is dedicated to maintaining a single IBM mainframe in perpetuity
[16:18:04] <strcat> :D
[16:18:18] <sigma> Rust is largely being marketted by this community at this point, I havn't seen anything from Mozilla
[16:18:30] <sanxiyn> bstrie: I guess that qualifies as optimistic
[16:18:35] <sbalmos> bstrie: Oh that'd be the ultimate. Either an S/360 or an AS/400: Tough enough to survive the end of the world
[16:18:41] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[16:18:51] <Sharp> froglegstew: Personally, I see Rust more as providing a realistic alternative to the C family than as displacing them.
[16:19:13] <sanxiyn> I see Rust as a programming language research
[16:19:17] <pnkfelix> i think it would be a mistake for mozilla to devote much effort into marketing before the language is stabilized ...
[16:19:24] <sbalmos> indeed
[16:19:33] <sbalmos> too much is changing still
[16:19:37] <pnkfelix> ((speaking for myself, not as a mozilla employee))
[16:19:49] <Sharp> I'd tend to agree with that.
[16:19:53] <Ms2ger> benh, no, the PLT people are still waiting for dependent types ;)
[16:20:21] <bstrie> hell, if this were really a research language we'd have had higher-kinded types since day one :P
[16:20:34] *** Joins: Kruppe (user@1DBD154A.F44F49AA.D02BABA9.IP)
[16:20:35] <sanxiyn> Yeah, Rust doesn't even have type operators
[16:20:35] <Sharp> Yeah, Rust isn't a research language by any stretch of the imagination :P
[16:20:38] <froglegstew> yes why not 
[16:20:45] <froglegstew> higher types
[16:20:56] *** Quits: fabrice (fabrice@moz-94F028C6.hsd1.ca.comcast.net) (Ping timeout)
[16:20:58] <bstrie> froglegstew: nobody cared enough to implement them or make them a priority
[16:20:59] <strcat> Sharp: can you name other languages with rust's form of lifetimes?
[16:21:06] <strcat> seems like research to me
[16:21:14] *** Quits: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net) (Ping timeout)
[16:21:15] *** Joins: moostik (Icedove@moz-C2FFB694.w82-121.abo.wanadoo.fr)
[16:21:23] <Sharp> strcat: Does one new feature make something a research language?
[16:21:26] <bstrie> even if cyclone had regions, lifetimes are definitely the most research-y part of rust
[16:21:27] <Ms2ger> strcat, sounds like you get to write a PhD about it :)
[16:21:28] <strcat> cyclone has a similar region system, but it's not entirely the same
[16:21:32] <sanxiyn> Sharp: Yes, usually
[16:21:42] <froglegstew> in this room who is working in rust team in mozilla
[16:21:43] <froglegstew> ?
[16:21:43] *** Joins: Deewiant (deewiant@moz-C015B7F8.iki.fi)
[16:21:45] <sbalmos> I'm just happy to play with systems-level bytecode languages.
[16:21:51] <bstrie> *especially* the sublime combination of lifetimes with affine types
[16:21:52] <sanxiyn> froglegstew: Go read https://github.com/mozilla/rust/wiki/Note-core-team
[16:21:56] <sanxiyn> It lists IRC nicks
[16:21:56] <Sharp> sanxiyn: Haha, in that case sure.  I thought it took more than that.
[16:22:06] <Scriptor> Rust isn't a bytecode language, is it?
[16:22:11] <strcat> Sharp: 'one new feature' is a pretty meaningless way to qualify it
[16:22:18] <bstrie> Scriptor: that's not a precise question :)
[16:22:19] <sanxiyn> Scriptor: At the moment only implementation is not implemented using bytecode
[16:22:30] <sanxiyn> In the future there could be a such implementation
[16:22:35] <bstrie> rust becomes LLVM bytecode
[16:22:36] <Scriptor> right
[16:22:50] <sbalmos> I wouldn't mind trying to get Rust to compile into PNaCl
[16:22:50] <bstrie> but that gets compiled AOT, rather than interpreted by a VM
[16:22:57] <sigma> Rust is currently compiled to machine code using the LLVM toolchain, it doesn't run on a vm
[16:23:10] <sbalmos> I never said bytecode = vm
[16:23:11] <sbalmos> :)
[16:23:11] <Sharp> strcat: Well, sure, you can always split up any feature into numerous subcomponents, but do named lifetimes really pervasively affect the entire codebase, and not just a handful of files?
[16:23:14] <Scriptor> hmm, I wonder if that means it's possible to use emscripten on Rust code
[16:23:16] <Scriptor> sbalmos: gotcha
[16:23:22] <strcat> Sharp: named lifetimes != the lifetime system
[16:23:25] <sanxiyn> Sharp: It does
[16:23:27] <strcat> they are one component of it
[16:23:34] <strcat> most rust code uses the borrow system heavily
[16:23:39] *** Joins: mib_gm44os (Mibbit@moz-535184AB.customers.ownit.se)
[16:23:49] <sanxiyn> Sharp: If you don't give names to lifetimes, it gets inferred
[16:23:59] <bstrie> I bet you'd have a hard time finding a single file in the rust compiler that didn't use references
[16:24:01] <sbalmos> Scriptor: I'm the twisted fool who wants to write a kernel in Rust, and use a platform-independent IR bytecode of LLVM (e.g. PNaCl) for binary distributions
[16:24:07] <sanxiyn> (That is really a lot of inference)
[16:24:13] <froglegstew> using LLVM, compared to go, would rust need more memory?
[16:24:20] <sbalmos> *facepalm*
[16:24:21] <sigma> sbalmos: that sounds awesome
[16:24:22] <bstrie> froglegstew: to compile?
[16:24:24] <strcat> sbalmos: why not just distribute the source, if you're still going to need to compile it?
[16:24:25] <sanxiyn> froglegstew: At compile time?
[16:24:29] <sigma> a little bit evil, but awesome
[16:24:29] <froglegstew> yes
[16:24:34] <sanxiyn> froglegstew: Probably, yes
[16:24:36] <Sharp> bstrie: I think using a feature is a bit difference than defining it, but sure.
[16:24:37] <bstrie> froglegstew: rust uses more memory because rust does static analysis
[16:24:45] <sanxiyn> Google's Go has a simpler backend
[16:24:47] <bstrie> go famously avoids anything expensive at compile time
[16:24:55] <strcat> the Go compilers aren't modern optimizing compilers
[16:25:03] <strcat> they just translate the source to asm in one pass
[16:25:12] <strcat> they don't build any intermediate form or do any real optimization
[16:25:18] <sigma> well, ggcgo can run optimisations can it not?
[16:25:38] <sanxiyn> Let's not start what is "real" optimization and what is not...
[16:25:40] <strcat> sigma: which is not what I'm talking about
[16:25:42] <sbalmos> strcat: We went over this Friday. Preference, caving to the inevitable commercial perception that there's IP involved that shouldn't be viewable source, the fact that there's at least some measure of speed increase by precompiling to an intermediate binary form, etc.
[16:25:51] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[16:26:16] <froglegstew> need rust more memory in runtime than go?
[16:26:18] <sbalmos> sigma: Tried it four years ago with the CLR and C#. The original remnants of my project and two others, who combined, are still working on even a base VM runtime.
[16:26:19] <sigma> ahh, I thought both gccgo and the normal go compiler fell under "the Go compilers"
[16:26:25] <strcat> froglegstew: no
[16:26:29] <sanxiyn> froglegstew: Depend on what you write, but usually no
[16:26:35] <strcat> rust as a language has the performance profile of C/C++
[16:26:51] <strcat> (including memory usage)
[16:26:53] <bstrie> sbalmos: if these commercial entities with IP on the line are fine with shipping C++, they'll be fine with shipping rust
[16:27:02] <sbalmos> bstrie: They're usually not
[16:27:07] <bstrie> well then fuck em :)
[16:27:09] <sbalmos> LOL
[16:27:21] <bstrie> not like bytecode decompilers don't exist anyway
[16:27:27] <froglegstew> but I saw a benchmark of togotogo, the memory usage is twice of go or c
[16:27:29] <sbalmos> bstrie: Wasn't disagreing there
[16:27:30] <sanxiyn> strcat: AOT is said to improve startup time
[16:27:49] <strcat> froglegstew: so, one person who doesn't know the language wrote a bogus benchmark
[16:27:52] <strcat> doesn't mean anything
[16:27:54] <Scriptor> what's togotogo
[16:27:55] <sanxiyn> As in, GCJ was not faster than HotSpot, but GCJ Eclipse started faster than HotSpot
[16:28:00] <bstrie> sbalmos: though you bring up a good point, let's invent a language with built-in DRM and then take the enterprise marketplace by storm!
[16:28:09] *** Joins: Skif (emschwar@moz-CA025D57.ip.mcleodusa.net)
[16:28:17] <sbalmos> bstrie: It's like Apple DRM (*cough*). You made an effort to protect IP, good enough.
[16:28:30] <sbalmos> bstrie: Uh... No thanks. :)
[16:28:36] <froglegstew> Scriptor a blog name
[16:28:50] <bstrie> froglegstew: link pls
[16:29:05] <Scriptor> this is difficult to search for
[16:29:36] <froglegstew> How to http://www.google.com.hk/url?sa=t&rct=j&q=rust+nimrod+d&source=web&cd=1&ved=0CCkQFjAA&url=http%3a%2f%2ftogototo%2ewordpress%2ecom%2f2013%2f08%2f23%2fbenchmarks-round-two-parallel-go-rust-d-scala-and-nimrod%2f&ei=4HqTUvTQBfGTiQeV4ICICA&usg=AFQjCNHqBbb3f9JjYgMKOUp05MxDPuPM4w
[16:29:37] <FreeFull> Let's make a language with anti-DRM
[16:29:46] <FreeFull> Even if you try implementing DRM in it, you will be foiled
[16:29:47] <bstrie> FreeFull: I think they tried that with javascript :P
[16:29:47] <strcat> sanxiyn: what about android's new AOT compiler? it's supposed to be a major increase in performance too
[16:29:55] <sanxiyn> froglegstew: Ugh can you paste URL without Google redirect?
[16:29:59] *** jorendorff is now known as jorendorff_away
[16:30:07] <benh> sanxiyn: blame google!
[16:30:09] <sbalmos> FreeFull: Don't disagree there, and wasn't even really saying anything about DRM.
[16:30:10] <sanxiyn> strcat: Haven't tried it yet (haven't looked at source either)
[16:30:15] <benh> http://togototo.wordpress.com/2013/08/23/benchmarks-round-two-parallel-go-rust-d-scala-and-nimrod/
[16:30:27] <froglegstew> yes that's it
[16:30:32] <mmalecki> is there an IRC library for Rust? just got a cool idea for a side project (removing google redirects)
[16:30:45] <strcat> language benchmarks written by someone who doesn't know the language are worthless
[16:30:47] <froglegstew> it is blocked here
[16:30:56] <tiffany> I wrote a little bit of one
[16:31:00] <sbalmos> bstrie: Okay, take another stance... Aside from FFI'ing into C libs, why does Rust allow compiling against external non-source shared libs?
[16:31:14] <tiffany> it's part of a bot which can connect and process commands synchronously
[16:31:24] <strcat> if you write *the same code* in rust and C, it will perform the same
[16:31:34] <Scriptor> froglegstew: first, 47.7 Kib isn't "twice" that of go's 30.7
[16:31:40] <strcat> it's pretty obvious really
[16:31:44] <strcat> Scriptor: it's not the same code
[16:31:45] <strcat> it's meaningless
[16:31:49] <Scriptor> but as strcat said, we don't  know anything about this guy's rust abilities
[16:31:50] <Scriptor> right
[16:31:53] <sanxiyn> Interestingly, most language benchmark code is written by someone who doesn't know the language
[16:31:58] <sanxiyn> Isn't that amazing?
[16:31:58] <mmalecki> tiffany: cool! link? gonna try building something upon it
[16:32:02] <strcat> sanxiyn: not the language benchmarks game ones
[16:32:10] <sanxiyn> strcat: Therefore "most"
[16:32:32] <strcat> and making a new benchmark where people can submit stuff is pretty worthless too, if you don't account for the fact that there's not enough interest in it to really try
[16:32:44] <froglegstew> http://shootout.alioth.debian.org/
[16:32:47] <Scriptor> all the examples run in roughly the same order of magnitude, which is good enough
[16:32:51] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[16:32:55] <tiffany> https://github.com/tiffany352/tiffbot-2
[16:33:00] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[16:33:01] <tiffany> I haven't touched it in a while
[16:33:03] <froglegstew> can someone write a rust scario
[16:33:09] <bstrie> sbalmos: I write PHP and javascript, I have no idea about anything related to C FFIs :P
[16:33:14] <sanxiyn> froglegstew: scario?
[16:33:22] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[16:33:24] <froglegstew> scenario
[16:33:37] <sanxiyn> What do you mean by Rust scenario?
[16:33:39] <Scriptor> froglegstew: it's tempting to look for hard numbers like these to compare languages, but for most cases there's no point
[16:33:42] <strcat> if you port rust code 1:1 from standard C, it doesn't perform any worse
[16:33:46] *** Joins: bungoman_ (bungoman@moz-833E2510.ptr.richards.com)
[16:33:47] <mmalecki> tiffany: thanks, it's a nice example
[16:33:48] <sbalmos> bstrie: heheheheh. I'm sorry.
[16:33:56] *** Joins: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net)
[16:33:56] <bstrie> strcat: speaking of, http://csherratt.github.io/csherratt/blog/2013/11/24/matrix-multiply-in-rust/
[16:34:05] <Scriptor> unless you're writing a mission-critical piece of code where every ms and kb matters, it doesn't really matter
[16:34:16] *** Quits: bungoman (bungoman@70827CB0.6C181F01.F74C56B8.IP) (Ping timeout)
[16:34:23] <strcat> bstrie: which is not 1:1
[16:34:31] *** jorendorff_away is now known as jorendorff
[16:34:34] <Ms2ger> Scriptor, unless it matters, it doesn't matter? :)
[16:34:36] <froglegstew> sanxiyn the url benchmark
[16:34:41] <sanxiyn> strcat: In general, I find such 1:1 translation argument suspect
[16:34:45] <sbalmos> bstrie: You've not had a PHP project yet where reparsing the source script, with all its @includes, didn't add a measurable (if not visibly noticable?) amount of time?
[16:34:46] <strcat> sanxiyn: why?
[16:34:48] <sanxiyn> http://mrale.ph/blog/2011/11/05/the-trap-of-the-performance-sweet-spot.html is why
[16:34:57] <sanxiyn> I don't completely agree, but I think he has a point
[16:35:06] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[16:35:08] <strcat> sanxiyn: it's bullshit to compare rust to C++ and use operator[] in C++ and bounds checking in rust, instead of vector::at
[16:35:09] <Scriptor> Ms2ger: unless you're in a very rare case, which someone learning how to program probably isn't in
[16:35:10] <strcat> and so on
[16:35:21] * strcat shrugs
[16:35:23] <sanxiyn> strcat: Go read the article
[16:35:31] <bstrie> sbalmos: oh of course I have :) that's why I always make sure to always write all my own libs from scratch
[16:35:39] <froglegstew> How do we see Rust, D2.0 and nimrod?
[16:35:40] <sbalmos> *facepalm*
[16:35:42] <sanxiyn> I really don't think you can say it's unfair to JavaScript if you don't use typed array and do index calculation yourself
[16:35:47] <bstrie> fewer includes, you see
[16:35:54] <mib_gm44os> How do I convert a str [u8]?
[16:35:55] *** Joins: ricepuddin (graham@moz-8D261693.wlan.ic.ac.uk)
[16:36:04] <Ms2ger> mib_gm44os, as_bytes()?
[16:36:10] <sanxiyn> strcat: Your argument is not that extreme, but it's of the same kind
[16:36:13] <Scriptor> bstrie: n...no bytecode cache?
[16:36:16] <strcat> sanxiyn: writing C in rust is no harder than writing C in C
[16:36:18] <sanxiyn> (That any JavaScript benchmark not using typed array is meaningless)
[16:36:19] <mib_gm44os> realley?
[16:36:28] <strcat> sanxiyn: in fact, I would say that writing code like the stdlib does *is not idiomatic rust*
[16:36:31] *** Quits: ssbr_ (~ssbr@98D3BE03.C60FE7DC.4065847B.IP) (Ping timeout)
[16:36:46] <bstrie> strcat: have you read the article? what I was curious about was this bit: "In each loop iteration an entire row of the matrix is calculated, vs a single element in the rust implementation."
[16:36:54] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[16:36:57] <bstrie> they had to manually unroll the loop to get C-like performance
[16:36:59] <strcat> bstrie: so, he's using bounds checked indexing in rus
[16:37:02] <strcat> and not in C
[16:37:09] <froglegstew> strcat is idiomatic rust fast or not?
[16:37:23] <strcat> what is idiomatic rust?
[16:37:23] <sanxiyn> We don't know what is idiomatic Rust yet
[16:37:27] <sanxiyn> That is my opinion
[16:37:37] <strcat> I write rust no differently than I would write C++
[16:37:49] *** Joins: bungoman (bungoman@moz-833E2510.ptr.richards.com)
[16:37:50] <jix> In my limited experience the code _I_ write in rust is as fast as code I write in C++ but I get there faster
[16:38:00] *** Quits: bungoman_ (bungoman@moz-833E2510.ptr.richards.com) (Ping timeout)
[16:38:05] <froglegstew> maybe safe here safe there
[16:38:24] <strcat> if you compare only 'safe' primitives in each rust will win, but it's not really fair to C++
[16:38:36] <strcat> because it would mean C++ couldn't use iterators, references, etc.
[16:38:54] <strcat> if you compare code written the same way in each language, it will be equivalent
[16:38:55] <jix> In C++ I often make performance compromises and do unneeded copying or unneeded refcounting with smartpointers because otherwise it is just impossible to manage the complexity
[16:39:20] <bstrie> tiffany: what does tiffbot do
[16:39:23] <froglegstew> I mean if you write safe rust code and unsafe c++
[16:39:39] *** Joins: maxli (maxli@moz-4D28BA20.student.cs.uwaterloo.ca)
[16:39:48] <strcat> anyway perhaps I should qualify it as comparing *rust-core* with C++
[16:39:55] <strcat> where rust compares quite favourably
[16:40:13] <FreeFull> It's ok to write code that isn't minimal in its resource usage, as long as it stays within reasonable bounds
[16:40:17] *** Quits: victorporof (victorporo@47B918E3.BCF05198.9B1E38F4.IP) (Quit: victorporof)
[16:40:20] <strcat> froglegstew: that's pretty meaningless, then
[16:40:33] <sanxiyn> FreeFull: Unbelievably, it's even ok to write Python
[16:40:34] <strcat> do you want to compare languages, or not?
[16:40:37] <sanxiyn> Surprise surprise
[16:40:44] <strcat> if you want to compare languages, you write the same code in each (as much as the language will let you)
[16:40:53] <strcat> if you want to compare the cost of safe abstractions, do it in both languages
[16:40:57] <FreeFull> Don't optimise for speed and memory usage until they are issues
[16:41:06] <strcat> I don't buy that
[16:41:08] <strcat> the stdlib tried that
[16:41:11] <froglegstew> ok, 
[16:41:29] <strcat> if you want to play in the C++ realm, you have to think about performance from the start
[16:41:35] <benh> arguably speed and memory usage are issues for rust *right now* because hypothetical people decide not to use it because it uses too much memory or w/e
[16:41:39] <mmalecki> strcat: well, stdlib is in hot path kinda by default
[16:41:43] <strcat> especially in embedded
[16:41:54] <strcat> mmalecki: it's certainly not written that way, though
[16:41:54] <benh> or it's an issue for rust right now because it makes strcat work on rust-core instead of std :))
[16:42:31] <FreeFull> stdlibs do have to be optimised, because of how they get used. And embedded doesn't have as many resources, so of course using them matters more
[16:42:34] <sanxiyn> I think the right interpretation is that Rust changed during 2013
[16:42:57] <sanxiyn> That is, when it started it really didn't try to play in C++ realm, and it is now
[16:43:01] *** Joins: dherman_ (dherman@moz-B31C6965.dsl.pltn13.sbcglobal.net)
[16:43:01] *** Joins: alan (alan@moz-FE02DD30.sat6.rackspace.com)
[16:43:17] <mib_gm44os> Does inferred types get transparently imported?
[16:43:17] <strcat> sanxiyn: well I agree with that
[16:43:20] <mmalecki> strcat: that's... scary
[16:43:40] <bstrie> sanxiyn: I'm not sure that's the right interpretation. the goal was always to play in the C++ realm, but I think they were initially fairly naive in thinking what they could get away with
[16:44:00] <strcat> mmalecki: why is it scary?
[16:44:02] <sbalmos> Well, so far it's been like Go, purpose-built.
[16:44:04] <tiffany> bstrie: it connects to a server and can run like 1 command
[16:44:12] <strcat> to get good performance you have to write that way from the start
[16:44:16] <strcat> bottom up
[16:44:22] <bstrie> sanxiyn: especially since the original target was C++ application development, and that gradually shifted to also encompass C-style embedded development
[16:44:26] <strcat> at least if you are talking about the stdlib here
[16:44:38] <Sharp> I do find that bolting on performance is like trying to bolt on security, it rarely works as well as you'd hope :P
[16:44:42] <sbalmos> strcat: Normally that just means using programming common sense. Premature optimization can paralyze you.
[16:45:08] <sanxiyn> sbalmos: Eh, not really?
[16:45:12] <strcat> sbalmos: in a stdlib implementation, it doesn't mean that, for sure
[16:45:14] <jix> I'd say for a stdlib you need to chose the right abstractions from the start, you don't need to have the best implementations right away
[16:45:22] <strcat> there is no 'premature optimization' in a performance-oriented *library*
[16:45:34] <mmalecki> strcat: the fact that it's not optimized is scary, or did I misunderstood you?
[16:45:35] <sbalmos> strcat: Oh, sure.
[16:45:37] <strcat> jix: you do if the implementation determines the API
[16:45:45] <sbalmos> strcat: Meant more generally
[16:45:48] <froglegstew> Rust is too slow to be born
[16:45:57] <froglegstew> more than 4years
[16:46:02] <jix> strcat: sure, then it is part of the (lack of) abstraction
[16:46:03] * sanxiyn starts to think froglegstew is trolling
[16:46:10] <sbalmos> froglegstew: I'm beginning to wonder what your purpose here is
[16:46:27] <Sharp> I think people use performance optimization in more than one way, sbalmos.  I would take it to mean "optimizing for a usage profile that might not be real," but some people seem to take it to mean, "optimizing at all."
[16:46:42] <jix> but the question "can I change this without breaking any uses" is a good indicator on how much to focus on performance at the beginning
[16:46:46] <Sharp> Er, premature optimization.
[16:46:47] <sbalmos> Sharp: true
[16:47:03] <strcat> I would seriously question why someone is interested in rust if they don't think optimizing should be something you think about as you program
[16:47:13] <sanxiyn> Sharp: Eh, I usually mean "optimizing at all"
[16:47:21] <strcat> it doesn't *let you* not 'prematurely' optimize
[16:47:26] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[16:47:44] <strcat> it forces you to think about many details that are relevant only to the performance profile
[16:47:47] <strcat> and not really semantics
[16:47:55] <sanxiyn> strcat: Very true
[16:48:20] <strcat> I don't think you can get good (as in well written C++) performance without thinking about it as you design and write most of the code
[16:48:32] <strcat> once you have 30k lines of code, it's way too late
[16:48:37] <froglegstew> but rust is the best language so far that i want to learn
[16:48:49] <mmalecki> does Rust support circular dependencies right now?
[16:48:53] <strcat> you can profile, sure, but profiling doesn't save you from 10000 paper cuts and bloat pushing stuff out of cache
[16:48:56] <sbalmos> froglegstew: Funny, half hour back you were saying typed scala
[16:48:57] * mmalecki is pondering writing a simple PM for the heck of it
[16:49:00] <bstrie> froglegstew: go read the tutorial, then, and google and words that you don't know :)
[16:49:07] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[16:49:08] <sanxiyn> strcat: I think Servo is around 30k lines :)
[16:49:11] <strcat> I was working on rust's stdlib for quite a while
[16:49:12] <sanxiyn> now
[16:49:18] <strcat> and I just decided that it's not going to be saved that way
[16:49:24] <sbalmos> Okay, what the heck is Servo supposed to be in the end?
[16:49:52] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[16:49:53] <sanxiyn> sbalmos: "Browser Engine"
[16:50:10] *** Joins: victorporof (victorporo@47B918E3.BCF05198.9B1E38F4.IP)
[16:50:13] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[16:50:20] <sbalmos> lovely
[16:50:37] <bstrie> strcat: fwiw, for quite a long time there's been some underlying sentiment that it would be easier to rewrite the stdlib than to fix it, as much as pcwalton wanted to avoid that
[16:50:47] <bstrie> by "quite a long time" I mean like pre-0.1
[16:50:54] <strcat> yeah but it won't be the same API, or the same design decisions
[16:50:55] <froglegstew> sbalmos scala is out because of its memory usages for me
[16:51:08] <sbalmos> bstrie: I think it'd make more sense if the Rc/Gc stuff got finalized first.
[16:51:25] <strcat> bstrie: https://github.com/thestinger/rust-core/blob/master/core/concurrent.rs this really looks nothing like the concurrency primitives in the stdlib, for example
[16:51:45] <bstrie> sbalmos: I agree, I think we need more features to be complete before we can begin to finalize the shape of the API
[16:52:08] <sanxiyn> I get the impression std was mostly written to support rustc, not to be "the standard library for Rust"
[16:52:09] <bstrie> semantics will change, and that will affect what is performant. syntax will change, and that will affect what is usable
[16:52:10] <benh> just put libstd behind a feature gate
[16:52:11] <benh> imo
[16:52:22] <sbalmos> bstrie: And we're back to solidifying / freezing the syntax and such first before the API can be built to take advantage of the syntax. :)
[16:52:34] *** Quits: froglegstew (Mibbit@9811B23A.916D3FF8.3BD9FE04.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[16:52:37] *** Joins: beifeng (Mibbit@9E0947B6.7BEF16F3.64FAF8EC.IP)
[16:52:49] *** Joins: jeaye (Jeaye@moz-34FEF2BB.hsd1.ca.comcast.net)
[16:52:51] <bstrie> sbalmos: yes, it's quite a pain
[16:52:58] <sbalmos> heh
[16:53:18] *** Quits: willingc (willingc@moz-B4760708.san.res.rr.com) (Client exited)
[16:53:28] *** Joins: ssbr_ (~ssbr@46FE74EC.C60FE7DC.4065847B.IP)
[16:53:29] *** Quits: blank_name (blank_name@FAB53C88.7071B2C8.31EC03F3.IP) (Quit: leaving)
[16:53:32] <sbalmos> bstrie: Keep it up, and I'll start designing my own stdlib out of sheer necessity. Then we'll end up with like CoreFoundation and the Foundation Kit. Two libs, the same thing.
[16:53:35] <sbalmos> :P
[16:53:37] *** Joins: willingc (willingc@moz-B4760708.san.res.rr.com)
[16:53:49] <strcat> sbalmos: already happened -> https://github.com/thestinger/rust-core
[16:53:54] <bstrie> and I think that strcat realizes that forking the stdlib would be just as fatal to rust as it was to D. we can all work together to make this compatible. or rather we have to, or everything will have been for nothing but historical curiosity
[16:54:04] <strcat> I don't think it is 'fatal'
[16:54:11] <bstrie> you're naive, then :)
[16:54:11] *** Joins: fabrice (fabrice@moz-7B0110AD.mv.mozilla.com)
[16:54:18] <sanxiyn> bstrie: Well OCaml also got multiple standard libraries
[16:54:24] <sbalmos> D... now there's another language I haven't toyed with in years
[16:54:27] <bstrie> a bad stdlib will kill us, you're right. two stdlibs will also kill us.
[16:54:38] <strcat> C and C++ seem to be quite successful, and they have *so many* libraries with duplicated functionality
[16:54:43] <sanxiyn> bstrie: I am not sure, but that is probably likely
[16:54:50] <strcat> I don't buy that it has anything to do with the language's success
[16:54:55] <sanxiyn> bstrie: This is why I think research into programming language adoption will be helpful
[16:54:56] <strcat> if rust-core isn't useful, no one will use it
[16:55:04] <bstrie> strcat: times have changed, people expect modern languages to have stdlibs. you can't get away without one
[16:55:06] <strcat> if it is useful, then it's not doing harm
[16:55:13] <bstrie> this isn't 1987
[16:55:14] <Ms2ger> bstrie, I dunno, have you seen JS? :)
[16:55:24] *** Quits: willingc (willingc@moz-B4760708.san.res.rr.com) (Ping timeout)
[16:55:27] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[16:55:31] <sbalmos> Ms2ger: Could argue that JS's "stdlib" is jQuery
[16:55:36] <bstrie> Ms2ger: good point, all we need for rust to be successful is vendor lock-in :)
[16:55:38] <strcat> bstrie: rust-core makes rust a viable replacement for C/C++, today
[16:55:42] <sanxiyn> strcat: Famously, OpenOffice.org had 8 or so different string classes doing about the same thing
[16:55:44] *** Joins: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com)
[16:55:46] <strcat> it doesn't need a 1.0, it's ready
[16:55:54] <sbalmos> O_O
[16:55:57] <bstrie> strcat: then you need to convince the devs to adopt it and market it
[16:55:57] <strcat> it will get more functionality, eventually
[16:56:03] <eddyb> sbalmos: that's about DOM
[16:56:08] <Ms2ger> sanxiyn, not unlike Gecko, then
[16:56:09] <sbalmos> eddyb: Yes I know
[16:56:14] <strcat> bstrie: no
[16:56:17] <strcat> I just need to keep working on it
[16:56:18] <benh> sanxiyn: A word processor is like the one place I'd expect to have a ton of different string classes :)
[16:56:21] <mib_gm44os> After the impressive roll out of the Go stdlib I must vote for a good and relevant stdlib (completely uninformed and noob view) :)
[16:56:26] <strcat> need a concurrent hash map, need a task tree library
[16:56:28] *** Joins: fabrice1 (fabrice@moz-BBE3ABD.mv.mozilla.com)
[16:56:31] <strcat> like intel tbb
[16:56:31] <sbalmos> strcat / bstrie: Heh, then we'll end up with the .Net 1.0 stdlib, which changed *drastically* to 1.1 & 2.0
[16:56:57] <sanxiyn> sbalmos: On the other hand, didn't change drastically *after that*
[16:57:01] <mmalecki> personally, I'd like to see rust's stdlib as small and as fast as possible
[16:57:05] * strcat would be done the concurrent hash map a long time ago if he wasn't distracted by irc ;p
[16:57:07] <sanxiyn> Indeed, .NET is a good precedent
[16:57:09] *** Quits: fabrice (fabrice@moz-7B0110AD.mv.mozilla.com) (Ping timeout)
[16:57:10] <strcat> mmalecki: well, that exists already
[16:57:26] <strcat> it is rust-core. it will be faster or equivalent to the C++ stdlib across the board
[16:57:39] <sbalmos> Just split out the core, concurrent stuff, collections, etc
[16:57:49] <sbalmos> I'd rather have like Qt or Boost, where things are modules
[16:57:50] <strcat> sbalmos: done, what now? :p
[16:57:55] * strcat shrugs
[16:57:57] <Ms2ger> I'd go for a pretty limited stdlib and easy dependencies
[16:58:00] <sanxiyn> Ms2ger: Difference is that after it was forked to LibreOffice, about half of them were removed
[16:58:04] <sbalmos> strcat: Shut up and get back to work! :D
[16:58:21] <Ms2ger> sanxiyn, yeah, Gecko still has them :)
[16:58:38] <Ms2ger> sanxiyn, otoh, we write our comments in English :)
[16:58:46] *** Quits: Dessimat0r (Dessimat0r@E879B262.8D4FD984.4320F744.IP) (Ping timeout)
[16:58:47] <strcat> the one thing I am unsure about vis-a-vis hash tables is SipHash
[16:58:51] <strcat> it is way too slow.
[16:59:04] <strcat> there's almost no point in using a hash table if it's this slow :(
[16:59:34] <bstrie> strcat: go ahead and implement the hokey identity hashes :P
[16:59:36] <strcat> I mean sure... it is still O(1), but who makes hash tables with 10 million elements in most cases? it's going to be as poorly performing as an rbtree for most cases
[17:00:17] <strcat> bstrie: I'll probably make the hash pluggable
[17:00:43] <sanxiyn> Which hash is current leading noncryptographic hash?
[17:00:45] <bstrie> maybe we can get away with just two hashes, HokeyFastHash and SecureAgainstCollisionHash
[17:00:48] <sanxiyn> Still Murmur?
[17:00:49] *** Joins: jeffdb_ (jeff@moz-ED35AD97.hsd1.ca.comcast.net)
[17:00:54] <strcat> sanxiyn: dunno
[17:01:00] <strcat> murmur is kind of pointless
[17:01:11] <sanxiyn> bstrie: Well even noncryptographic hash needs good distribution
[17:01:23] <sbalmos> strcat: No desire to just make the HashMap dependent on a Hashable trait?
[17:01:23] *** Joins: nano (nano@moz-74CAD1CA.superkabel.de)
[17:01:28] <bstrie> bah, more distribution is bad for cache locality
[17:01:35] <sbalmos> strcat: Require a GetHashCode?
[17:01:37] <bstrie> listen to me, I know what these words mean
[17:01:51] <strcat> sbalmos: it uses a Hash trait
[17:01:55] <Sharp> Fastest hash probably depends on the key type, no?
[17:01:55] <strcat> the existing hash table
[17:01:59] <Sharp> And the use case?
[17:02:24] <strcat> sbalmos: so... rust uses SipHash
[17:02:26] <sanxiyn> "hash table problem"
[17:02:44] <eddyb> is it round or is it square?
[17:02:59] <strcat> sbalmos: the Hash implementations all use it
[17:03:28] <strcat> SipHash is designed as a cryptographically sound pseudo-random function
[17:03:50] <strcat> that's fast enough to replace general purpose hashes like murmurhash, because it has a tiny output and is designed for speed
[17:04:06] <strcat> for strings... it's not that bad
[17:04:11] <strcat> especially medium to long length strings
[17:04:20] <strcat> but for integers.... it is a huge performance overhead over a hokey hash
[17:04:36] <sanxiyn> I guess that's what "depending on key type" comment refers to
[17:04:38] <Ms2ger> Is there some way to do Foo x; and have that call some function?
[17:04:40] <strcat> and at least in rustc most hash tables are integer keyed
[17:05:01] <strcat> Ms2ger: as in default constructors? no, rust doesn't have ctors
[17:05:17] <Ms2ger> Hrm :(
[17:06:02] <strcat> if you want the O(1) performance as a strong guarantee, I don't think there's an alternative to SipHash
[17:06:13] <sbalmos> :/
[17:06:19] <strcat> maybe someone could design a SipHash alternative for small fixed-size keys
[17:06:26] <strcat> but atm it doesn't exist and I'm not a cryptographer who could design it
[17:06:38] <strcat> ;p
[17:07:25] <sanxiyn> SipHash: another djb design
[17:08:10] <strcat> I don't think you'd want to use murmur, FNV or whatever on fixed-size integers either
[17:09:02] <strcat> last time I looked, I think libstd++/libc++ just used something like FNV for strings, the identity for fixed-size integers, and a bit of mixing in the hash table itself regardless of the key hash
[17:09:09] <sbalmos> way over my head at this point. :/ Probably some equivalent hashing voodoo in the Java/C# realm. I'm just used to implementing GetHashCode on my classes. :)
[17:09:11] <Sharp> IMO if you are really going for speed in your hash table, you should take the time to profile different bucketing schemes and figure out which one works best for your data.
[17:09:35] <Sharp> If it's not important enough to do that you can probably get away with a default implementation that's not optimal.
[17:09:36] <strcat> SipHash gives a distribution that's indistinguishable from an RNG
[17:09:41] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[17:09:46] <strcat> so open addressing is as good as you'll get
[17:10:02] <strcat> sometimes it might not be, but in general it will be
[17:10:03] <sanxiyn> strcat: Haskell has IntMap specialized for int keys
[17:10:25] <sanxiyn> (I think it is a crit-bit tree)
[17:10:29] <strcat> sanxiyn: yeah I wrote std::trie, which is already quite competitive with the hash table, despite being a really naive implementation
[17:10:40] <Sharp> Sometimes you want fast bucketing, though, isnt' that what you were complaining about? :P
[17:10:42] <strcat> so yes, maybe I should just work on that more
[17:11:15] <strcat> honestly though I've always wondered why people don't just use something like an rbtree as their buckets ;p
[17:11:25] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[17:11:37] <Sharp> I don't know either!
[17:11:37] <strcat> you lose the ordered map invariant of a tree... but you get O(1) avg perf
[17:11:43] <strcat> or you could use tries and keep O(1) worst-case
[17:11:46] <strcat> for fixed-size keys
[17:11:57] <sbalmos> Hence why everyone has multiple implementations
[17:12:06] <strcat> hash table with tries as buckets
[17:12:10] <strcat> O(1) *worst-case* lookup
[17:12:15] <strcat> 1 cache miss *on average*
[17:12:41] *** Quits: japaric (japaric@EEA8F44E.83887C3F.5C7588CA.IP) (Ping timeout)
[17:13:01] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[17:13:08] * strcat shrugs
[17:13:08] <strcat> and then you can just use a weak hash
[17:13:08] <strcat> there's no DoS vuln
[17:13:08] <strcat> so, they can cause a few cache misses
[17:13:08] <strcat> but it's a bounded worst-case
[17:13:10] *** Joins: DeTeam (DeTeam@moz-1F320A6A.dyn.broadband.iskratelecom.ru)
[17:13:45] <mib_gm44os> The doc says that a method without a declare self should be used for construction but how can i initialize stuff then or should i provide init methods?
[17:14:05] <benh> The method should return a new object
[17:14:29] <mib_gm44os> aha and i can set stuff on the new objet.. doh!
[17:14:35] <strcat> rusti: struct Foo { a: int, b: int } Foo { a: 5, b: 10 }
[17:14:37] <sanxiyn> mib_gm44os: StructName { field_name1: value1, field_name2: value2 } etc
[17:14:39] -rusti- main::Foo{a: 5, b: 10}
[17:14:49] <mib_gm44os> thx
[17:15:09] *** Quits: sanxiyn (tinuviel@B4104EBB.3CC170B1.1E14B209.IP) (Quit: Leaving)
[17:16:17] *** Quits: ricepuddin (graham@moz-8D261693.wlan.ic.ac.uk) (Ping timeout)
[17:17:03] <Ms2ger> Can I have static functions on a trait?
[17:17:13] <sfackler> yep
[17:17:29] <sfackler> e.g. FromStr::from_str
[17:18:06] *** Joins: mikezaby (mikezaby@moz-AA896205.home.otenet.gr)
[17:18:15] *** Parts: mikezaby (mikezaby@moz-AA896205.home.otenet.gr) ()
[17:18:56] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[17:19:39] *** Quits: moostik (Icedove@moz-C2FFB694.w82-121.abo.wanadoo.fr) (Ping timeout)
[17:20:24] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[17:21:02] <strcat> anyway atm rather than find a better solution than SipHash I will just use it ;p
[17:21:35] <strcat> for a sharded concurrent hash map it's important to have that nice distribution even with an O(1) bucket fallback too...
[17:23:01] <bstrie> strcat: is that "sharded", or shared?
[17:23:11] <bstrie> I could believe either...
[17:23:17] <strcat> bstrie: sharded
[17:23:26] <strcat> bstrie: so...
[17:23:27] * bstrie looks up sharded hashmaps
[17:23:34] <strcat> bstrie: well I can explain it in 2 lines
[17:23:36] <bstrie> ok
[17:23:43] <strcat> 1 hash map, with 1 lock, there's a lot of contention
[17:23:56] <strcat> but in advance, just create N hash maps in an array (shards) and use the hash to pick the right one
[17:23:58] <strcat> each one has a lock
[17:24:00] <strcat> tada!
[17:24:11] <bstrie> hm
[17:24:14] <Sharp> Now go present at a Big Data conference :P
[17:24:24] <sbalmos> Buckets of buckets! :D
[17:24:27] <strcat> you never need to change the number you have, since it's just based on the amount of parallelism (cores)
[17:24:37] <strcat> well this is what ConcurrentHashMap is in java ;p
[17:24:49] <strcat> I always expected it to be more complex
[17:26:22] * Sharp wants a PefectHash type :D
[17:26:47] <strcat> Sharp: a perfect hash mapping each key to a unique integer is still pretty imperfect :)
[17:26:57] <sbalmos> struct PerfectHash { BlackHole: (); }
[17:26:59] <sbalmos> Done!
[17:27:24] <Sharp> Heh.
[17:27:24] <strcat> unless you mean mapping each key to a unique bucket, in a set size of map ;p
[17:27:50] <strcat> Sharp: http://cmph.sourceforge.net/
[17:27:55] *** Quits: jeffdb_ (jeff@moz-ED35AD97.hsd1.ca.comcast.net) (Quit: jeffdb_)
[17:28:03] <Sharp> That is in fact what I mean, and I'm pretty sure to do it usefully it would have to be built into the compiler.
[17:28:13] *** Joins: willingc (willingc@moz-B4760708.san.res.rr.com)
[17:28:21] <bstrie> oooh 4d raytracing https://github.com/sebcrozet/nrays
[17:28:21] <Sharp> (And I'd have to give all the keys in advance).
[17:28:33] <strcat> Sharp: well look at cmph and gperf
[17:28:36] <strcat> that's what they do! :)
[17:28:45] <Sharp> I know, but they don't generate Rust :(  Or do they
[17:28:46] <Sharp> ?
[17:28:49] <Sharp> gperf didn't last time I checked.
[17:28:49] <strcat> they don't ;(
[17:28:57] <strcat> gperf generates C straight out of 1980 too
[17:29:15] <sbalmos> strcat: With the separation of function parameters from their types? :)
[17:29:40] <strcat> sbalmos: I think they fixed that... but I don't think it generates valid C89/C99/C11 ;p
[17:29:44] <sbalmos> heh
[17:30:05] <sbalmos> oh well, it's been fun as always. Time for lunch.
[17:30:23] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[17:30:45] *** Joins: Dessimat0r (Dessimat0r@E879B262.8D4FD984.4320F744.IP)
[17:30:49] <posco> I am not finding docs on how to handle allocation failures. Pointer?
[17:31:44] <posco> Is this done by making a task do the alloc, and then the task fails?
[17:31:50] <strcat> posco: the stdlib doesn't provide a way to handle allocation failures
[17:32:04] <posco> so, what happens? termination?
[17:32:06] <strcat> yes
[17:32:13] *** Joins: echristo (echristo@4241698A.2E4FD3DD.225F4543.IP)
[17:32:16] <strcat> rust as a language can handle allocation failure
[17:32:26] <strcat> but the stdlib doesn't try to do that
[17:32:45] <posco> how can I do this so the server doesn't fail at OOM?
[17:33:02] <strcat> opt-out of the stdlib, and be disciplined about not allocating in destructors
[17:33:10] <mib_gm44os> mutable struct members is it not possible?
[17:33:20] <cmr> mib_gm44os: outside of normal mutability, no.
[17:33:21] <strcat> posco: or just figure out resource constraints in advance, I guess
[17:33:30] <strcat> and drop connections yourself when you hit some bound
[17:33:43] *** Quits: qrpth (andreas@moz-9C921D25.ut.ee) (Ping timeout)
[17:33:51] <posco> How would I know when let x = ~Object { ... } will fail?
[17:33:54] <mib_gm44os> ohh... say I have a socket which is mutable
[17:34:13] <strcat> posco: if you opt-out of the stdlib, you write the ~ allocator
[17:34:19] <mib_gm44os> using self.socket.write does not work
[17:34:27] <Ms2ger> "error: trait bounds are not allowed in structure definitions"
[17:34:28] <strcat> you can unwind from the allocator
[17:34:28] <cmr> mib_gm44os: &mut self
[17:34:29] <Ms2ger> Why not?
[17:34:44] *** Joins: azakai (alon@moz-BBE3ABD.mv.mozilla.com)
[17:34:50] <strcat> Ms2ger: it's just not the intended usage of trait bounds
[17:35:00] <strcat> you use them when you require methods they provide
[17:35:08] <strcat> one struct can have different impls with different bounds
[17:35:08] <Ms2ger> ... I do?
[17:35:11] <strcat> some might require more
[17:35:12] <mib_gm44os> @cmr awesome! thx
[17:35:37] <Ms2ger> I mean, I have Foo<T>, and some of my member functions need something of that T
[17:35:43] *** Quits: echristo (echristo@4241698A.2E4FD3DD.225F4543.IP) (Ping timeout)
[17:35:48] <strcat> Ms2ger: the bound goes on the impl with those methods
[17:35:53] <posco> strcat: any docs on this? also, isn't this a showstopper for rust as a lang for a server? DDOS crashes the server if there are and ~ allocs in the loop?
[17:35:55] <cmr> Ms2ger: so impl<T: Bound> ...
[17:35:58] <Ms2ger> Fascinating
[17:35:58] <strcat> another impl could also require an extra bound
[17:36:04] *** Joins: rntz_ (rntz@moz-C76A8D96.sp.cs.cmu.edu)
[17:36:12] <strcat> Ms2ger: impl<T: Bound> Foo { }
[17:36:25] <strcat> impl<T: Bound + OtherBound> Foo { }
[17:36:33] *** Quits: alonlevy (alon@moz-EB7C9CF3.telavivmakers.org) (Ping timeout)
[17:36:38] <strcat> and on types just fulfilling Bound, they won't get the methods in the 2nd impl
[17:36:48] <strcat> there used to be bounds on types
[17:36:55] <strcat> but it was removed because it usually doesn't have a purpose
[17:36:57] *** zz_kimundi is now known as kimundi
[17:37:16] *** Quits: Kruppe (user@1DBD154A.F44F49AA.D02BABA9.IP) (Ping timeout)
[17:37:21] <Ms2ger> I don't want people to be able to use Foo<T> where T doesn't implement the trait, though
[17:37:34] *** Joins: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP)
[17:37:36] <strcat> Ms2ger: well, if at least one field is private they can't
[17:37:47] <Ms2ger> Okay, that's good enough, then
[17:38:06] *** Joins: Florob (Florob@moz-39532932.de)
[17:38:06] <Ms2ger> Less self-documenting, though
[17:38:16] *** Joins: alonlevy (alon@moz-EB7C9CF3.telavivmakers.org)
[17:38:40] <bstrie> strcat: looking for a new linux distro. do you recommend arch [y/n]
[17:38:44] <bstrie> keep in mind that I am stupid
[17:38:47] <strcat> posco: most servers likely run on linux with overcommit anyway
[17:38:47] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Client exited)
[17:39:04] <strcat> bstrie: you don't need to be very bright to use arch, as a programmer you'll have no problem
[17:39:14] <bstrie> ok I will try it this week
[17:39:19] *** Joins: moostik (Icedove@5A22E6A1.10715965.BCDF592F.IP)
[17:39:42] <posco> strcat: the finite nature of the memory and the amount of data I will be storing will cause this problem eventually.
[17:39:56] <strcat> arch is: latest upstream releases of every packages, without patches applied, vanilla upstream configs, great docs ;p
[17:40:00] <strcat> every package*
[17:40:06] <bstrie> right, the updates are what I like
[17:40:21] <bstrie> I realized today that for some reason my linux mint is stuck on like firefox 23
[17:40:30] <posco> strcat: can task::try { } not catch allocation errors?
[17:40:43] <strcat> posco: allocation errors can't fail!() because lots of destructors allocate
[17:40:48] *** Joins: nejucomo (Adium@moz-3B9BDB73.hlrn.qwest.net)
[17:40:55] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[17:40:57] <cmr> posco: allocation failure aborts.
[17:40:57] <strcat> in an alternate stdlib with very disciplined dtors, yes, you can do that
[17:41:26] <strcat> posco: and keep in mind that you aren't informed of an allocation failure on linux/freebsd anyway, although linux has a way to opt-out of overcommit
[17:41:57] <benh> per-process?
[17:42:05] <strcat> benh: no, not per-process
[17:42:14] <strcat> you need overcommit if you want to do per-process limits
[17:42:14] <bstrie> posco: I haven't been following this conversation, but if you're worried about storing an infinite number of objects can I interest you in a probabilistic data structure instead of a hashmap? :)
[17:42:15] <benh> I guess that would not make a lot of sense anyway
[17:42:22] <strcat> benh: well cgroups can do process tree limits
[17:42:25] <strcat> you can partition up the system memory
[17:42:32] <strcat> 1GiB for some process tree, 3GiB for everything else
[17:42:44] <posco> bstrie: I'm already interested.
[17:42:46] <strcat> if they hit that limit, an OOM killer runs in that specific cgroup though
[17:42:56] <posco> I want to build a bigger one.
[17:43:05] *** Joins: bmaxa (bmaxa@8920FEC0.B8F3457F.73804765.IP)
[17:43:13] <strcat> benh: the issue is that memory is a global resource
[17:43:20] <strcat> so... you don't really know why memory ran out
[17:43:23] <benh> yeah
[17:43:27] <strcat> it could be a runaway process run by a different user
[17:43:33] <strcat> and the well behaved applications are going to suffer
[17:43:39] *** Quits: Ralith (ralith@moz-132F2FD4.sea.wa.customer.broadstripe.net) (Ping timeout)
[17:43:44] <posco> I just want to fail the request, and not lose everything in memory already
[17:43:50] <strcat> so it's usually going to be more robust to just have per-user limits or maybe cgroup limits
[17:43:51] <posco> but maybe that is not possible.
[17:43:59] <cmr> posco: not in rust, not right now, not using ~
[17:44:05] *** Joins: avsej (avsej@D9A610B8.4841F515.FB33447D.IP)
[17:44:09] <strcat> cmr: with the stdlib.
[17:44:14] <cmr> right
[17:44:46] <posco> okay, so the next best thing is many small shards, and restart on crash, reload from a checkpoint.
[17:45:05] <cmr> Or use your own allocator, or don'tuse the stdlib
[17:45:05] *** Quits: vmx (vmx@moz-7DD0B8B0.dip0.t-ipconnect.de) (Quit: Leaving)
[17:45:28] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[17:45:41] <posco> cmr: ok. got it. Any docs on writing ones own allocator?
[17:46:46] <cmr> posco: what would expect in such docs? you just.. do it
[17:46:57] <cmr> rust-core has allocators you could look at
[17:47:08] *** Quits: rntz (rntz@moz-E2688BE0.compound.emarhavil.com) (Quit: leaving)
[17:47:15] *** rntz_ is now known as rntz
[17:47:17] <strcat> cmr: well not really
[17:47:22] <strcat> generic dtors don't work yet
[17:47:35] *** Joins: adridu59 (Mibbit@moz-6C393FDD.rev.numericable.fr)
[17:50:01] <doomlord_> with @ going does that mean overloads are available for general purpose smartpointers
[17:50:03] *** Quits: Ferreus (ferreus@moz-E56B798B.dip0.t-ipconnect.de) (Ping timeout)
[17:50:15] <strcat> doomlord_: yes, overloading deref
[17:50:23] <strcat> was planned whether or not @ was going away
[17:50:31] <strcat> cmr: although
[17:50:35] <doomlord_> cool, are there examples 
[17:50:39] <posco> cmr: I was assuming that there was some hook into how ~ worked. If you are saying that you link to c and do an allocation there, I get it.
[17:50:43] <strcat> doomlord_: no it's not implemented yet
[17:50:58] <cmr> posco: well no, I'm saying use a non-~ type
[17:51:00] <strcat> posco: if you aren't using the stdlib, you can define exchange_malloc/exchange_free
[17:51:15] <strcat> if you *are* using the stdlib, there's nothing you can do, it allocates all over the place and will call abort
[17:51:28] <strcat> you could define them as throwing a failure on OOM
[17:51:31] <Ms2ger> It built!
[17:51:36] <strcat> or you could define them as looping until they succeed
[17:51:41] *** Joins: sprang (sprang@moz-920A95C4.hsd1.ca.comcast.net)
[17:51:51] *** Quits: DeTeam (DeTeam@moz-1F320A6A.dyn.broadband.iskratelecom.ru) (Quit: DeTeam)
[17:51:52] <strcat> in the loop they could even try reducing memory usage somehow
[17:52:03] <strcat> (or before they failed)
[17:52:06] <posco> would it be unsound to fail on OOM?
[17:52:17] <strcat> posco: the stdlib can't
[17:52:19] <posco> I guess some destructors could not be called.
[17:52:21] <strcat> because it allocates in dtors
[17:52:23] <posco> as you said.
[17:52:25] <posco> right.
[17:52:31] <strcat> posco: it will infinite loop and abort on out-of-stack
[17:52:41] <strcat> or something awful like that
[17:52:43] <cmr> Nested failure just causes an abort, it's not unsound?
[17:52:50] <strcat> cmr: yeah I guess so
[17:52:56] *** Joins: jeffdb_ (jeff@moz-ED35AD97.hsd1.ca.comcast.net)
[17:53:00] *** Quits: abinader (abinader@D8B9C081.E820043D.D4C04133.IP) (Ping timeout)
[17:53:02] <strcat> anyway all that will happen if the stdlib tries to fail on OOM is an abort elsewhere
[17:53:10] <cmr> yup
[17:53:10] *** Joins: qrpth (andreas@39EED39.590DF183.783D9E8C.IP)
[17:53:22] <adridu59> utf8 char type is u8 right?
[17:53:28] <strcat> adridu59: char type?
[17:53:41] <strcat> adridu59: utf-8 is a variable-length encoding of code points as bytes
[17:53:46] <posco> so, using IPC to communicate to the tasks and restarting the failed ones seems like the best solution (to have stdlib compat)
[17:54:05] <Sharp> posco: Or you could just use Erlang :P
[17:54:05] <strcat> posco: you won't get a failure you can handle though
[17:54:10] <strcat> they will just bring down the process
[17:54:16] <adridu59> strcat: what type is for chars?
[17:54:22] <strcat> Sharp: erlang handles OOM by aborting
[17:54:37] <cmr> Does *any* language or runtime provide sensible OOM behavior?
[17:54:40] <Sharp> strcat: Does it abort all tasks?
[17:54:44] <strcat> adridu59: 'char'? it's a code point, not a user-perceived character
[17:54:54] <cmr> Lua will fail gracefully, but you can't continue until you get more memory.
[17:55:03] <strcat> cmr: C doesn't provide any containers or anything so you could say it does
[17:55:03] <posco> strcat: well, I would know which shard died and I could restart in a sane way. But I guess I don't need shards or IPC for that.
[17:55:10] <strcat> by omission of a useful stdlib
[17:55:15] *** Joins: glennsl (textual@moz-5D7B804F.getinternet.no)
[17:55:18] <strcat> Sharp: yes
[17:55:24] <strcat> Sharp: if erlang runs out of memory, the VM exits.
[17:55:32] <strcat> if Go runs out of memory, it exits
[17:55:35] <Sharp> strcat: In that case, considering what Erlang is used for, I'd say this probably isn't a critical concern in practice...
[17:55:35] <posco> cmr: JVM throws an error you can catch how reliably you can do anything is another story.
[17:55:42] <strcat> if glib (as in gtk) runs out of memory, it exits
[17:55:54] <Sharp> Yeah, Glib is known for that.
[17:56:34] <strcat> posco: afaik the jvm allocates the VM up-front
[17:56:42] *** Quits: nano (nano@moz-74CAD1CA.superkabel.de) (Connection reset by peer)
[17:56:52] *** Quits: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net) (Quit: Sharp)
[17:57:20] <jix> I guess having per task memory limits (maybe as an absolute 
[17:57:23] <jix> argh
[17:58:20] <strcat> and gmp aborts on OOM
[17:58:42] <strcat> C++ throws an exception, so your destructors can't allocate if you want to handle it
[17:59:01] <strcat> that's the path I expect to take in rust-core too
[18:00:21] <strcat> if the *system* as a whole runs out of memory, you are in trouble with or without overcommit
[18:00:39] <strcat> most applications can
[18:00:48] <strcat> can't do better than flushing some buffers and exiting*
[18:01:02] <jix> I think having something like a OOM killer for tasks with a partial order or weights or priorities could be useful too
[18:01:07] <strcat> so if you really allow a server to exhaust the system's memory you are in trouble
[18:01:17] <strcat> jix: rust can't kill a task
[18:01:20] <strcat> it would be unsound
[18:01:33] <strcat> they have to unwind, or the process has to exit
[18:01:36] <jix> could it make a task fail on the next allocation?
[18:01:49] <strcat> jix: then destructors can't allocate
[18:01:58] <strcat> which the stdlib doesn't (and can't, due to libuv, etc.) provide
[18:02:04] <rntz> strcat: I mean, you could "kill" a process by causing it to unwind.
[18:02:19] <rntz> and that would still be sound, iiuc?
[18:02:23] *** Quits: eddyb (eddy@336E3A7F.D51DAF03.FB866788.IP) (Ping timeout)
[18:02:27] <rntz> but of course unwinding could theoretically take forever
[18:02:28] <strcat> rntz: and what if it allocates in a dtor? yes it would be sound
[18:02:31] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[18:02:33] <strcat> but it doesn't accomplish anything with the stdlib
[18:02:41] <rntz> ah, I am missing context
[18:02:45] <strcat> rntz: guess what happens if a dtor fails? it aborts ;p
[18:03:01] <strcat> the stdlib has *many* dtors doing allocation afaik
[18:03:08] <jix> Is there even any sane way to handle OOM when dtors can allocate?
[18:03:14] <strcat> jix: no
[18:03:20] *** Quits: qrpth (andreas@39EED39.590DF183.783D9E8C.IP) (Ping timeout)
[18:03:26] <strcat> well
[18:03:30] *** Joins: eddyb (eddy@336E3A7F.D51DAF03.FB866788.IP)
[18:03:31] <strcat> you can loop forever until there's memory
[18:03:33] <strcat> ;p
[18:03:52] <jix> you could allow weak allocation in dtors... where the dtor has to handle allocation failure locally
[18:04:04] *** Joins: Kruppe (user@moz-253119B0.esg.uwaterloo.ca)
[18:04:19] <strcat> jix: in the end they really just have to not allocate
[18:04:31] <strcat> if you design that way from the start, it's not *incredibly* hard
[18:04:44] <strcat> if you *only* use unwinding to report OOM, it will work
[18:05:04] <strcat> if you use unwinding for other stuff, you end up needing destructors to enforce higher-level logic (as in equivalents to finally blocks)
[18:05:13] <strcat> and you end up needing to allocate
[18:05:41] <Ms2ger> Gah
[18:05:43] <jix> strcat: but even without unwinding you might want to use dtors for logic, don't you?
[18:06:04] <strcat> jix: yeah, and if you allocate in them you're choosing to give up handling OOM errors ;p
[18:06:12] <strcat> although, again, whether it makes sense to try handling them is questionable
[18:06:14] *** Joins: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net)
[18:06:14] *** ChanServ sets mode: +o tjc
[18:06:24] <Ms2ger> So I need to have a stack-allocated class that adds a pointer to itself to a linked list when it's created, and removes itself when it's destructed
[18:06:26] <jix> strcat: that is why I proposed this weak allocation thing
[18:06:31] <Ms2ger> Is that remotely possible?
[18:06:42] <jix> strcat: if you use dtors for logic you might want to allocate _unless_ you are in OOM
[18:07:03] <strcat> jix: but why are you using a dtor then, if you don't need to enforce the invariant?
[18:07:05] *** Joins: vodik (simon@moz-63F3D7D1.net.uwaterloo.ca)
[18:07:14] <strcat> if you can get away with not doing it, better to not do it in the first place
[18:07:30] <jix> strcat: I'll try to find a concrete example
[18:07:34] *** Joins: qrpth (andreas@39EED39.590DF183.783D9E8C.IP)
[18:07:50] <strcat> you can do a lot of stuff without running into the need to allocate
[18:08:18] <strcat> release lock, destroy mutexes/allocations, remove files, create files, do I/O (but not string building)
[18:08:40] <jix> strcat: I think allocation inside a dtor is only needed if the allocated object outlives the destructed object and interacts with other things
[18:08:50] <strcat> as long as you use an API like printf you can do quite comprehensive I/O without allocation
[18:08:58] <jix> I can't even come up with a good example for wanting that right now...
[18:08:59] *** Quits: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com) (Ping timeout)
[18:09:13] <strcat> jix: the stdlib does it a lot due to interactions with the scheduler and async I/O stuff
[18:09:36] <strcat> libuv FFI generally involves allocations
[18:09:38] <strcat> little ones
[18:10:29] *** Quits: qrpth (andreas@39EED39.590DF183.783D9E8C.IP) (Ping timeout)
[18:10:50] *** Joins: blank_name (blank_name@FAB53C88.7071B2C8.31EC03F3.IP)
[18:10:50] *** Joins: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net)
[18:10:52] *** Quits: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net) (Client exited)
[18:10:52] *** Joins: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net)
[18:11:02] *** Joins: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP)
[18:11:15] *** Quits: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net) (Connection reset by peer)
[18:11:31] *** Joins: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net)
[18:11:32] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[18:11:56] <jix> My intuition tells me that any good reason to allocate in a dtor can be special cased to work without allocation in case of OOM but I can't even come up with any good reason to allocate in a dtor in the first place
[18:12:42] <strcat> jix: well it's hard to come up with a low-level reason, but interacting with a lot of libraries does require allocation
[18:13:04] <strcat> and there are other types of resource exhaustion...
[18:13:19] <Ms2ger> So, anyone?
[18:13:23] <jix> I'm searching for program logic reasons not for things like libraries that just happen to require it
[18:13:54] <strcat> you can easily run out of file descriptors too
[18:14:15] <strcat> or on OS X, run out of threads (but that wouldn't happen on linux)
[18:14:49] *** Joins: qrpth (andreas@moz-BF31195A.campusnet.ee)
[18:14:53] <jix> but any program logic reason for allocating in a dtor must be about storing something in a "parent" or "outer" data structure I think
[18:15:27] <Leo`> eddyb: pong
[18:15:34] <jix> maybe for caching or otherwise not recomputing things
[18:15:37] <strcat> jix: you might want to do something like clean up files
[18:15:51] <strcat> and that's likely to require allocation in some cases
[18:16:00] <strcat> at least if you count opening files as allocation
[18:16:13] * strcat shrugs
[18:16:14] <jix> shouldn't you be able to do that on the stack most of the time (in theory, I'm not talking about the stdlib)
[18:16:20] <strcat> yeah
[18:16:38] <jix> I think caching really might be a reason to want allocation in dtors unless there is a OOM
[18:17:15] *** Joins: ricepuddin (graham@moz-7D68765A.cable.virginm.net)
[18:17:29] <cmr> Ms2ger: Not possible, not safely.
[18:17:40] *** Quits: nsf (nsf@moz-EEF3238A.convex.ru) (Quit: WeeChat 0.4.2)
[18:18:02] <cmr> Ms2ger: You'd need to borrow the list mutably to insert yourself, and then borrow it mutably again to remove yourself, but you already have the borrow from the insertion!
[18:18:19] <jix> but even without coming up with a good use case I think it wouldn't hurt to allow some try_alloc in dtors even when allocations are forbidden otherwise
[18:19:01] *** Joins: joelteon_ (bzzt@moz-948A3799.lightspeed.snvaca.sbcglobal.net)
[18:19:05] <Ms2ger> cmr, doesn't need to be safe; this is a linked list implemented in C++ anyway
[18:19:43] *** Joins: jstevans (Instantbir@moz-8DBF3BC4.washdc.fios.verizon.net)
[18:20:06] *** Joins: boredomist (ruqs@8186917.CC8FA3EE.E3401B6E.IP)
[18:20:06] <cmr> Ms2ger: The caller of the constructor will need to add it, unless you want to return ~T or something else.
[18:20:24] <Ms2ger> That sucks
[18:20:43] *** Quits: CarpNet (ac@moz-FD24B77.sohonet.co.uk) (Quit: Leaving)
[18:20:45] *** Joins: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com)
[18:20:50] <cmr> The constructor doesn't control where it's allocated unless it's returning a container
[18:22:31] <Ms2ger> But it would at least know where it was allocated if it was an actual constructor :/
[18:23:04] <cmr> sure
[18:23:21] *** Quits: qrpth (andreas@moz-BF31195A.campusnet.ee) (Quit: leaving)
[18:23:47] *** Joins: qrpth (andreas@moz-BF31195A.campusnet.ee)
[18:24:16] *** Quits: joelteon_ (bzzt@moz-948A3799.lightspeed.snvaca.sbcglobal.net) (Client exited)
[18:24:51] *** Quits: bascule (bascule@moz-3D395603.compute-1.amazonaws.com) (Quit: leaving)
[18:25:05] *** Joins: bascule (bascule@moz-3D395603.compute-1.amazonaws.com)
[18:28:16] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[18:29:10] <Leo`> strcat: I was trying to implement Decodable and Encodable for Rc<T> as we will probably need it if we want Rc in the AST
[18:29:28] <Leo`> but I don't know how to do with Send/Freeze
[18:29:42] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[18:29:53] <Leo`> I can't impl Decodable for Rc<T> for both T: Send and T: Freeze
[18:30:08] <strcat> so just do Freeze
[18:30:11] <Leo`> but I can't do a single impl since I have to use either new() or from_send()
[18:30:28] <Leo`> or using new_unchecked, but not sure if it's a good idea
[18:30:33] <Leo`> what's Send anyway ?
[18:30:48] <strcat> Leo`: put a Freeze bound on Encodable too
[18:30:50] <strcat> and it's done
[18:30:55] <sfackler> A type is Send if it can be sent to a different task
[18:30:58] <Leo`> which types fulfill Send but not Freeze ?
[18:31:08] <sfackler> types with borrowed pointers
[18:31:16] <sfackler> or lifetime restrictions in general I guess
[18:31:16] *** Quits: oberstet (quassel@moz-D08B2E13.dynamic.mnet-online.de) (Client exited)
[18:31:17] <cmr> No, thosearen't Send
[18:31:23] <sfackler> oh, oops
[18:31:23] <strcat> Leo`: Cell/Mut are non-freeze
[18:31:25] <sfackler> other way around
[18:31:29] <strcat> Leo`: Rc is non-send
[18:31:44] *** Joins: DeTeam (DeTeam@moz-1F320A6A.dyn.broadband.iskratelecom.ru)
[18:31:53] *** Quits: huhlig-work (Hans@moz-62A47D90.aoltw.net) (Connection reset by peer)
[18:31:55] <Leo`> ok
[18:34:37] <sbalmos> Back to reading about ABIs. :/
[18:35:16] *** Quits: bungoman (bungoman@moz-833E2510.ptr.richards.com) (Connection reset by peer)
[18:35:27] *** Joins: bungoman (bungoman@moz-B5620CD.ptr.richards.com)
[18:36:44] *** Quits: jstevans (Instantbir@moz-8DBF3BC4.washdc.fios.verizon.net) (Ping timeout)
[18:36:48] *** Quits: nkoep (nik@moz-CA8EF11D.vpn.rwth-aachen.de) (Ping timeout)
[18:36:49] <sbalmos> strcat: Was starting to plan on doing a flat virtual memory model, no ring switching, because of pointer type safety. Then it popped in my head that in my theoretical OS, there's nothing preventing someone from writing a C/C++ compiler and breaking pointer safety.
[18:37:33] <cmr> Also, unsafe code, and assembly..
[18:38:01] <sbalmos> cmr: Unsafe code and assembly would be feature-gated and/or disallowed at the compiler front end level.
[18:38:17] <cmr> Hand-assembling, then!
[18:38:43] <sbalmos> cmr: If you're to that level, more power to you! :P
[18:38:45] <Leo`> can I impl<T:IterBytes> IterBytes for @T too ? :d
[18:38:47] <tiffany> sbalmos: make an exokernel in which context switching into a safe mode is implemented by the library
[18:38:53] <cmr> Rust's features aren't meant for security.
[18:38:59] <tiffany> you could make rust run in ring 0, but all the C would be sandboxed
[18:39:05] * Leo` like doing lots of impls. that's an easy task.
[18:39:16] <strcat> Leo`: we don't need more @ stuff
[18:39:21] <strcat> it's going away
[18:39:22] <Leo`> euuuuh
[18:39:26] <Leo`> strcat: I meant Rc<T>
[18:39:28] <Leo`> sorry
[18:39:31] <strcat> Leo`: oh, yes
[18:40:05] <sbalmos> tiffany: That made my head hurt
[18:40:08] <sfackler> a generic impl like "impl<T:IterBytes> IterBytes for Rc<T>" will break all other impls unless that was recently fixed
[18:40:43] *** Quits: DeTeam (DeTeam@moz-1F320A6A.dyn.broadband.iskratelecom.ru) (Quit: DeTeam)
[18:41:55] <cmr> sfackler: only other impls for Rc<T> ?
[18:41:58] *** Quits: canhtak (canhtak@moz-6F820ACE.wl.t.ulaval.ca) (Quit: canhtak)
[18:43:10] <sfackler> cmr: possibly
[18:43:14] <sfackler> I was thinking of https://github.com/mozilla/rust/issues/8075
[18:43:35] *** Quits: Dessimat0r (Dessimat0r@E879B262.8D4FD984.4320F744.IP) (Ping timeout)
[18:44:17] <sbalmos> tiffany: So essentially you'd have to enforce, in some way, that non-Rust code is loaded into, essentially, a different personality from the normal Rust environment
[18:44:22] <Leo`> sfackler: tests seems to pass well for the moment
[18:44:29] <sfackler> cool
[18:44:38] <Leo`> sfackler: but this bug happends when you do impl<T: Foo> trait for T
[18:44:44] *** Joins: sdvhbhszo8yhwtu (esucg0aq47@92F050E5.5987FCA3.DC5114E0.IP)
[18:44:49] <Leo`> I don't think it's the same as impl<T: Foo> trait for Rc<T>
[18:44:56] <Leo`> happens*
[18:44:59] <tiffany> sbalmos: is that any different from loading up the rust stdlib vs the C stdlib?
[18:45:04] <sfackler> yeah, impl for Rc<T> should be okay
[18:45:07] <cmr> and it's only for impls of said trait, which doesn't matter in this case
[18:45:18] <tiffany> exokernels are a fun subject
[18:45:33] <tiffany> they turn a lot of assumptions about operating systems on their head
[18:45:34] <sdvhbhszo8yhwtu>   YOU MAY BE WATCHED 
[18:45:35] <sdvhbhszo8yhwtu> WARNING       WARNING      WARNING,                       WARNING
[18:45:36] <sdvhbhszo8yhwtu> WARNING             WARNING              WARNING,     WARNING         WARNING
[18:45:38] <sdvhbhszo8yhwtu>  YOU MAYWATCHED
[18:45:39] <sdvhbhszo8yhwtu> YOU MAY BE WATCHED
[18:45:40] <sdvhbhszo8yhwtu>    YOU MAY BE WATCHED
[18:45:41] <sdvhbhszo8yhwtu>             )
[18:45:42] *** Quits: sdvhbhszo8yhwtu (esucg0aq47@92F050E5.5987FCA3.DC5114E0.IP) (User has been banned from Mozilla (no spamming here))
[18:46:01] <sfackler> ruh roh!
[18:46:06] <Leo`> hum hum.
[18:46:11] <myname> not that one again
[18:46:18] <sbalmos> tiffany: Rust stdlib, C stdlib, they both have access to the same base kernel underneath, which itself is protected in Ring 0
[18:46:25] *** Joins: spider-mario (spidermari@moz-2F72F6FF.dsl.quantic-telecom.net)
[18:46:30] <sbalmos> tiffany: Trying to avoid the context switching between Ring 0/3
[18:47:17] <tiffany> if you're running in ring 0, what prevents the C stdlib from automatically switching to ring 3 before executing C?
[18:48:06] *** Quits: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[18:48:22] <o11c> sdvhbhszo8yhwtu was obviously watch :P
[18:49:24] <sbalmos> tiffany: Well, okay, from that perspective nothing. So the proposal would be normal Rust code, etc would all be in Ring 0, and the c stdlib would switch to "traditional" Ring 3 with syscalls
[18:49:51] *** Joins: Sharp (Sharp@1710C26.8381A41.8725677B.IP)
[18:50:07] <cmr> sbalmos: You could also disallow native code execution, and require all code to be in some IL that goes through a translator before execution
[18:50:14] <cmr> see: pnacl
[18:50:36] <sbalmos> cmr: Well, exactly. You weren't around this morning. The "native" distributable executable format would be pnacl
[18:51:01] <sbalmos> cmr: But that doesn't prevent a c compiler from being written that compiled to pnacl, and still is unsafe
[18:51:23] *** Joins: canhtak (canhtak@moz-6F820ACE.wl.t.ulaval.ca)
[18:51:26] *** Quits: beifeng (Mibbit@9E0947B6.7BEF16F3.64FAF8EC.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[18:51:43] <cmr> sbalmos: hm? nothing is executable except what goes through your translator, so if it's unsafe, it's because the translator isn't rejecting unsafe code.
[18:51:50] <Leo`> https://github.com/mozilla/rust/pull/10658 strcat cmr does this looks ok to you ?
[18:52:22] <Leo`> -s
[18:52:29] *** Joins: pcwalton (pcwalton@moz-C07D5168.p2p.sfo1.mozilla.com)
[18:52:29] *** ChanServ sets mode: +ao pcwalton pcwalton
[18:52:53] *** Quits: qrpth (andreas@moz-BF31195A.campusnet.ee) (Ping timeout)
[18:54:49] <sbalmos> cmr: Be back with you in a few. Real work interference. :)
[18:54:50] <pcwalton> acrichto: removing task killing opened the door to a lot of de-Celling :)
[18:54:52] <pcwalton> I'm doing some of it
[18:55:20] *** Joins: nkoep (nik@moz-D8197C3D.pool.mediaways.net)
[18:56:24] *** Joins: sdvhbhszo8yhwtu (esucg0aq47@92F050E5.5987FCA3.DC5114E0.IP)
[18:56:30] *** Joins: qrpth (andreas@39EED39.590DF183.783D9E8C.IP)
[18:57:17] *** Joins: voxpopuli (fanservice@moz-FE161659.wv.cc.cmu.edu)
[18:57:29] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[18:58:33] *** Quits: sdvhbhszo8yhwtu (esucg0aq47@92F050E5.5987FCA3.DC5114E0.IP) (User has been banned from Mozilla (no spamming here))
[18:58:47] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[18:59:51] <r-A> Will there be a 0.9 release in early december?
[19:00:07] <r-A> nono
[19:00:11] <cmr> r-A: no
[19:00:13] <r-A> January= :(
[19:01:01] <cmr> late december, early january, yeah
[19:01:05] <Ms2ger> Why does it matter to you?
[19:01:15] <Leo`> Rust 0.9 Xmas edition
[19:01:16] <yosemite> is there a quick summary I can read of what changes will be from 0.8 -> 0.9 ?
[19:01:23] *** Quits: heftig (heftig@moz-E7FBFCE3.dip0.t-ipconnect.de) (Ping timeout)
[19:01:27] <cmr> yosemite: nobody knows yet
[19:01:34] <cmr> we still have a ~month of development
[19:01:35] <tjc> r-A: just as a bit of extra background, Rust releases are more or less time-based and snapshot-like. The git HEAD always builds and passes tests on the supported platforms
[19:01:43] <pcwalton> TWiR is probably the best place for the summary so far
[19:01:50] <yosemite> cmr: understood :)
[19:01:51] <tjc> so, at least right now, there's generally no reason to wait for a release before jumping in and using it
[19:02:10] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Connection reset by peer)
[19:02:31] <ssbr_> Waiting for a binary release seems reasonable, on windows at least.
[19:02:51] *** Quits: bjustin (bjustin@moz-8FC28563.sierrabravo.net) (Ping timeout)
[19:03:25] *** Quits: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[19:03:35] *** Quits: engla (engla@moz-F64E1B0F.cust.bredbandsbolaget.se) (Ping timeout)
[19:03:36] <kimundi> binaries on windows still need the mingw libraries afaik
[19:03:38] <r-A> I just like the hype a new release brings in for a while ;)
[19:03:44] <tjc> heh
[19:03:47] <r-A> seeing people doscuss Rust related things 
[19:03:49] <tjc> Well, it does do that :-)
[19:04:01] <tjc> of course, when people blog about Rust, that brings in some hype too, and it can happen anytime :-)
[19:04:10] <cmr> I've been thinking about how we can best propagandize Rust as we approach 1.0
[19:04:15] <tjc> especially when it's somebody who doesn't work for Mozilla, and especially if they also are a person working on something people are interested in
[19:04:51] *** jorendorff is now known as jorendorff_away
[19:05:21] * strcat really wants per-module #[feature] :(
[19:05:26] *** jorendorff_away is now known as jorendorff
[19:06:08] <sbalmos> cmr: Okay, back. From the perspective of pnacl, there is no "unsafe" attribute or anything that a translator (really, LLVM platform-specific compiler) could use.
[19:06:23] <luisbg> how are vectors different from C's arrays?
[19:06:26] <ssbr_> kimundi: I remember it was much easier to get rust working on windows with the binaries. I couldn't get it to build personally, but the binaries just worked (with my setup, which already had mingw and lots of other things installed)
[19:06:27] <cmr> luisbg: they grow
[19:06:36] <strcat> luisbg: fixed-size arrays are like C arrays
[19:06:43] <luisbg> that is the main difference?
[19:06:48] <ssbr_> luisbg: they can be passed around.
[19:07:01] <luisbg> you can append to a vector
[19:07:01] *** Joins: bjustin (bjustin@moz-8FC28563.sierrabravo.net)
[19:07:01] <pcwalton> I would like to write a blog post about niko and my current thoughts on DST
[19:07:12] <pcwalton> niko had a very good idea assuming it works
[19:07:20] <ssbr_> you can only pass around a pointer to the first element of a C array, which loses size information.
[19:07:24] <luisbg> ssbr, C arrays can be passed around (by pointer to the beginning of it)
[19:07:32] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[19:07:33] <luisbg> ssbr, ooooh OK
[19:07:53] <pcwalton> which is to use existential types and consider ~[T] an existential package of ∃n.~[T, ..n]
[19:08:02] <pcwalton> and allow ~[T, ..n] to be coerced to ~[T]
[19:08:24] <pcwalton> by slapping a length on it
[19:08:28] <pcwalton> in a similar manner to the way ~Value can be coerced to ~Trait by slapping a viable on it
[19:08:30] <pcwalton> vtable
[19:09:02] <pcwalton> then we potentially don't really need DST at all
[19:09:04] <cmr> luisbg: you can append to an array, up to its length
[19:09:09] <kimundi> pcwalton: That's the one where &[T] and ~[T] are both two words, and growable vectors a optional library type, right?
[19:09:11] <sbalmos> tiffany: Not exactly sure I would like an exokernel. Too low-level, IMO. ;)
[19:09:15] <pcwalton> kimundi: right.
[19:09:18] <tiffany> it's not low level
[19:09:23] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[19:09:24] <tiffany> it's just that abstraction is optional
[19:09:49] <pcwalton> anyway this would work with custom smart pointers too in the same way as traits
[19:10:09] <pcwalton> RC<[int, ..3]> could be coerced to RC<[int]> by shoving the length next to the pointer
[19:10:10] <luisbg> cmr, yes, I meant that the length can't be changed (unless you dynamically do so by using realloc and copying the data)
[19:10:18] <sbalmos> tiffany: no worse than a microkernel. Just that, in theory, you could then have multiple different filesystem or environment servers.
[19:10:23] <luisbg> is this what Rust does internally? realloc with the new size?
[19:10:40] <pcwalton> it's just an existential package of ∃n.RC<[T, ..n]>
[19:10:41] <cmr> luisbg: (at that point it's a vector, not an array)
[19:10:50] *** Joins: mib_0xtzxy (Mibbit@moz-E1FEAFEC.nayatel.pk)
[19:10:52] <strcat> luisbg: a fixed-size array is just like a C array ([T, ..n])
[19:10:55] <strcat> a slice is (ptr, length)
[19:10:56] <tiffany> exokernels are at a kind of unusual point in between virtual machines and microkernels
[19:11:02] <kimundi> pcwalton: I like that idea, but wouldn't DST still be useful even with that plan?
[19:11:02] *** Quits: moostik (Icedove@5A22E6A1.10715965.BCDF592F.IP) (Ping timeout)
[19:11:05] <sbalmos> tiffany: Indeed
[19:11:06] <strcat> luisbg: a vector is a ptr, length and capacity, or at least it will be
[19:11:16] *** Joins: cubic (cubic@moz-80241A3A.mc.videotron.ca)
[19:11:16] <strcat> and yes, when it's full, it reallocs 2x as much space
[19:11:17] *** Joins: heftig (heftig@moz-4B41666A.dip0.t-ipconnect.de)
[19:11:18] <pcwalton> kimundi: it could be. mostly for impls I guess.
[19:11:20] <strcat> for O(1) amortized append
[19:11:26] <sbalmos> tiffany: More like mixing microkernels with the old NT "environment personality" concept
[19:11:26] <luisbg> strcat, how is length different from capacity?
[19:11:32] <pcwalton> however it seems less important
[19:11:33] <strcat> luisbg: length is how big it is
[19:11:35] <tiffany> designed to multiplex bare metal applications, with all of the OS functionality behind libraries
[19:11:39] <strcat> capacity is how much space it has room for
[19:11:41] <cmr> luisbg: capacity is the size of the allocatoin, length is the # of initialized items in that allocation
[19:11:43] <strcat> it's required for O(1) append
[19:11:45] <tiffany> you can run operating systems that have been ported to the exokernel's interface
[19:11:46] <pcwalton> and having to have fn f<unsized T> is kind of annoying complexity so...
[19:11:47] *** Quits: Savago (Savago@D8B9C081.E820043D.D4C04133.IP) (Quit: Savago)
[19:12:10] <pcwalton> I'm inclined to just try not doing DST
[19:12:14] <pcwalton> and see how far we get
[19:12:25] <tiffany> and you can often run the same library OSes on other platforms, even non-exokernel systems
[19:12:46] <cmr> pcwalton: isn't that what we're now?
[19:12:59] <pcwalton> cmr: no, you can't use custom smart pointers with []
[19:13:06] <pcwalton> RC<[T]> doesn't work, nor does RC<Trait>
[19:13:08] <luisbg> cmr, normally they would be the same, unless you initialize it with the idea of adding to it later
[19:13:21] <pcwalton> this is the biggest problem because it severely limits what custom smart pointers can do relative to C++
[19:13:29] *** Quits: mib_0xtzxy (Mibbit@moz-E1FEAFEC.nayatel.pk) (Quit: http://www.mibbit.com ajax IRC Client)
[19:13:32] <strcat> luisbg: no, they're not normally the same
[19:13:42] <strcat> if you push and it's full, it has to allocate more space
[19:13:51] <strcat> to provide O(1) append, a dynamic array allocates more than 1 more slot
[19:14:09] <strcat> and reserve has to allocate more than what you actually ask for, if it's called in a loop
[19:14:10] <tiffany> sbalmos: you may want to join #rust-osdev
[19:14:23] <sbalmos> tiffany: Was wondering if this had gone off-topic. :D
[19:14:23] <kimundi> pcwalton: Hm... I'd still really like to see DST for those advantages, adn for the possibility of newtyped unsized types
[19:14:27] <pcwalton> this existential-type proposal is a way to make RC<[T]> work without DST, by using existential types
[19:14:34] <eddyb> Leo`: sorry, I was away. any progress on @Block/Rc<Block>? also, did you do anything with tuples (for my variadic RFC - IIRC you were fiddling with it), I might want to take on that challenge myself :P
[19:14:47] <luisbg> strcat, does it provide O(1)? is the allocation done in powers of 2? or how is it done internally?
[19:15:01] <strcat> luisbg: when it's full, it doubles the size
[19:15:20] <luisbg> strcat, cool, so powers of 2 (kinda :P)
[19:15:23] <ssbr_> as long as the new size is some multiple > 1 of the old size when you reallocate, then appends are O(1) amortized
[19:15:32] <luisbg> ssbr_, nice! :)
[19:15:37] <pcwalton> I don't think that DST really helps impls that much
[19:15:41] <strcat> luisbg: and there's a dynamically sized ring buffer with O(1) prepend and append
[19:15:42] <pcwalton> because of borrowing
[19:15:53] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[19:15:54] <ssbr_> new capacity / old capacity, I should say.
[19:16:01] <pcwalton> we might be able to make newtyped unsized types work without DST, not sure
[19:16:02] <strcat> the stdlib one isn't great though, but there's not much point in landing a replacement until there's a new vector
[19:16:04] <kimundi> pcwalton: Hm?
[19:16:04] <Leo`> eddyb: I answer to the other chan, it's too noisy here :p
[19:16:15] *** Quits: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net) (Ping timeout)
[19:16:38] <pcwalton> for example the impls in Vec don't really benefit from DST I don't think
[19:17:48] *** Joins: Jesin (Jesin@moz-6536249C.cc.lehigh.edu)
[19:18:40] *** Joins: jstevans (Instantbir@moz-8DBF3BC4.washdc.fios.verizon.net)
[19:19:05] <kimundi> Implementing something with a &self method on a &[T] introduces a uneccessary indirection that you need to reason about, even if it optimizes to the same
[19:19:17] <pcwalton> you can impl with "self" though
[19:19:58] *** Joins: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP)
[19:20:03] *** Joins: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net)
[19:20:14] <pcwalton> if you're implementing a trait though you may not have that option, that's a good point...
[19:20:25] <pcwalton> but is it worth introducing the complexity of "unsized"? I dunno.
[19:20:26] <kimundi> right
[19:20:45] <kimundi> Also, self and &self are not the same
[19:20:58] <kimundi> because the Self type is different
[19:21:12] <strcat> hm? the Self type is the same, &self is just a ptr to it
[19:21:24] <strcat> or do you mean with DST
[19:21:45] <kimundi> impl &T ... self and impl T ... &self have different Self types, even if in the method both end up as &T
[19:22:14] <kimundi> With and without DST
[19:22:38] <strcat> sure but there's no such type as [T]
[19:22:43] <strcat> so you can only impl on &[T]
[19:23:05] <strcat> and if it's not a trait impl, you might as well just take 'self', but it really doesn't matter
[19:23:07] <kimundi> .... with DST there would be, and it would both work either way
[19:23:11] *** Joins: moostik (Icedove@5A22E6A1.10715965.BCDF592F.IP)
[19:23:36] <strcat> but we don't have DST today, and we don't know exactly what it would look like if we did have it
[19:23:54] <pcwalton> well, we're talking about whether DST is worth doing
[19:24:04] <kimundi> Exactly
[19:24:04] *** Joins: abinader (abinader@D8B9C081.E820043D.D4C04133.IP)
[19:24:06] *** Quits: jstevans (Instantbir@moz-8DBF3BC4.washdc.fios.verizon.net) (Ping timeout)
[19:24:38] <pcwalton> I'm not sure the Self distinction matters much in practice, do you have a specific example of a trait that you can't implement on &[T] for this reason?
[19:25:12] <kimundi> I had that issue the other week, I'll try to remember...
[19:25:43] <pcwalton> I mean, it's ugly that you have an extra level of indirection, but having two kinds of type parameters is also ugly
[19:26:05] <strcat> pcwalton: it's an issue with Iterable, because fn iter<'a>(&'a self) -> &'a T won't work with &[T]
[19:26:13] <strcat> but I'm not sure if there's any value in having that
[19:26:23] <pcwalton> ah, good point
[19:26:56] *** Quits: andre_ (andre@CA528A4A.45A4338E.8EE27E6.IP) (Quit: leaving)
[19:27:09] * nmatsakis comes in late
[19:27:10] <strcat> anyway that's why we have no Iterable trait
[19:27:26] <nmatsakis> I don't believe changing the meaning of Self is going to work out in any consistent way
[19:27:50] <pcwalton> nmatsakis: not sure what that means exactly, could you elaborate?
[19:27:54] <nmatsakis> but I also don't quite get what the issue is with an iterable trait
[19:27:59] <heftig> do you still want DST?
[19:28:06] *** Joins: Ralith (ralith@A8995AA9.62B6AF6A.922221DB.IP)
[19:28:09] <strcat> nmatsakis: the trait wants to say it takes an &self ref and returns a ref with that lifetime
[19:28:26] <strcat> but to impl it on &[T], you end up with &'a &[T] -> &'a, which doesn't work
[19:28:40] *** Quits: lfox (lfox@moz-343B6F0C.nyc.biz.rr.com) (Quit: ZZZzzz…)
[19:28:42] <TeXitoi> what is DST?
[19:28:53] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[19:28:59] <kimundi> TeXitoi: dynamic sized types
[19:29:04] <nmatsakis> strcat: do you envision `trait Iterable<I> { fn iter<'a>(&'a self) -> &'a I }`?
[19:29:07] <TeXitoi> kimundi: thanks
[19:29:15] <strcat> nmatsakis: well that's what I was thinking it would have to be
[19:29:33] <nmatsakis> strcat: that doesn't make sense to me -- the existing iter methods don't have that signature
[19:29:33] <strcat> otherwise, I can't see how you would implement it on a type like HashSet<A>
[19:29:42] <TeXitoi> kimundi: as [T, ..n] with n determined at runtime?
[19:29:49] <strcat> nmatsakis: er, sorry, Iterator<&'a T>
[19:29:50] <nmatsakis> strcat: I think what you really want there is HKT
[19:29:51] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[19:29:57] <strcat> yeah
[19:30:03] <nmatsakis> trait Iterable<I> { fn iter<'a>(&'a self) -> I<'a> }
[19:30:21] <strcat> you can write it like this:
[19:30:24] <nmatsakis> I don't think this has much to do with what the `Self` parameter is bound to
[19:30:33] <nmatsakis> alternatively,
[19:30:42] <nmatsakis> trait Iterable<I> { fn iter(self) -> I; }
[19:30:42] <heftig> TeXitoi: i think the main effect would be to make "str" and "[T]" actual types, with &str and &[T] not being any special compared to &T
[19:30:47] <nmatsakis> and impl it for &'a HashSet
[19:30:57] <strcat> hm
[19:31:02] <kimundi> TeXitoi: For example, yeh. Basically making the type system properly know about types which have their size unknown at compile time, like the [T] in a ~[T].
[19:31:12] <strcat> nmatsakis: it needs the element type in the trait to be useful though
[19:31:18] <strcat> otherwise it's not making stuff any more generic
[19:31:32] <strcat> anyway I expect we just won't define it in the near future
[19:31:35] <TeXitoi> heftig and kimundi thanks
[19:32:00] <strcat> trait Iterable<'a, A, T: Iterator<&'a A>> { fn iter(&'a self) -> T; }
[19:32:13] <nmatsakis> strcat: I don't think that is necessary.
[19:32:22] <nmatsakis> strcat: nor particularly desirable
[19:32:36] <strcat> well, if it doesn't have the element type, how do you use it to write generic code?
[19:32:38] <nmatsakis> strcat: that is, not everything will iterate over references etc.
[19:33:02] <strcat> nmatsakis: that's true, but I expect there's no way to leverage it to write anything if it doesn't encode an element type like that
[19:33:08] <strcat> anything useful*
[19:33:15] <nmatsakis> fn foo<'a, I: Iterator<&'a A>, C: Iterable<T>>(coll: C)
[19:33:21] <nmatsakis> er
[19:33:23] <nmatsakis> fn foo<'a, I: Iterator<&'a A>, C: Iterable<I>>(coll: C)
[19:33:31] <strcat> true
[19:33:32] <nmatsakis> however, I think this is not the best way to go about things
[19:33:50] <nmatsakis> that is, I suspect to make this all more palatable, we may want either HKT/associated-types-or-fun-deps
[19:34:22] *** Joins: nano (nano@moz-74CAD1CA.superkabel.de)
[19:34:28] <kimundi> I think the move to treat both Trait and [T] as existencial types makes perfect sense and simplifies a lot, but in my opinion we still should have unsized types in the type system anyway. It'd be really cool if we could remove str from the compiler and only have [T] as a buildin unsized type, with str being a unsized struct defined in libstd
[19:35:03] <pcwalton> I'm thinking we should do that anyway
[19:35:30] <pcwalton> &str == struct StringRef<'self>(&'self [u8]);
[19:35:37] <pcwalton> ~str == struct String(~[u8]);
[19:35:42] <kimundi> Urg
[19:35:44] *** Quits: canhtak (canhtak@moz-6F820ACE.wl.t.ulaval.ca) (Quit: canhtak)
[19:36:13] <kimundi> struct str { vec: [u8] }
[19:36:18] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Client exited)
[19:36:26] <pcwalton> you say "urg" but a lot of people will say "urg" when there are two kinds of type parameters
[19:36:30] *** Joins: mikezaby (mikezaby@moz-AA896205.home.otenet.gr)
[19:36:47] *** Parts: mikezaby (mikezaby@moz-AA896205.home.otenet.gr) ()
[19:36:49] <pcwalton> it's a tradeoff
[19:37:12] *** Quits: tulloch (tulloch@moz-BC895BC5.damtp.cam.ac.uk) (Ping timeout)
[19:37:12] *** Quits: tulloch_ (tulloch@moz-BC895BC5.damtp.cam.ac.uk) (Ping timeout)
[19:37:12] <kimundi> I know my voice won't change much, but I personally think the concept of 'unsized type' is easy enough to understand that it outweights such verbosity :(
[19:38:14] <strcat> the concept might be easy to understand but when exactly do you want to use it?
[19:38:19] <strcat> it adds more complexity/choice
[19:38:33] <pcwalton> anyway I haven't really made up my mind either way to be sure
[19:38:43] <pcwalton> it'll have subtle consequences
[19:38:49] <pcwalton> either way
[19:40:23] *** Joins: lfox (lfox@moz-343B6F0C.nyc.biz.rr.com)
[19:41:02] <kimundi> str, ascii_str, utf16_str, custom vector/string types that want to store additional fixed size data next to the vector data, etc
[19:41:09] *** Joins: Jesse (jruderman@moz-5973C6FA.oc.oc.cox.net)
[19:41:49] <strcat> feels really complex to me
[19:41:55] <strcat> overflow handling for the allocations
[19:42:12] <pcwalton> types like SmallString are going to have to be wired to ~, I think
[19:42:22] <pcwalton> RC<SmallString> makes no sense
[19:42:40] <strcat> right but that applies even to dynamically sized vectors
[19:42:42] *** Quits: fabiand (fabiand@moz-742359A2.adsl.alicedsl.de) (Quit: Verlassend)
[19:42:50] <strcat> because they can never be resized inside Rc
[19:42:54] <pcwalton> well, I guess it *could* make sense -- it'd work like ArrayList in Java where the backing store is ref counted -- but it would need a separate implementation because of… yeah
[19:43:06] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[19:43:37] <strcat> if DST existed and they were only defined by the compiler, I can grasp how you would deal with it
[19:43:52] <pcwalton> so DST doesn't really help SmallString
[19:43:56] <pcwalton> or SmallVector
[19:44:46] * nmatsakis writes busily
[19:44:54] <nmatsakis> I'm trying to write up a post checkpointing my current thoughts on DST
[19:45:05] <pcwalton> gonna beat me to it :)
[19:45:13] <pcwalton> but I'm sure you've been thinking more deeply about it than I have
[19:45:29] <Sharp> Unrelated to Rust, exactly, but does anyone happen to know how bash handles a normal "exit" command internally?  Is it handled as an unsendable signal?
[19:45:31] <strcat> pcwalton: like lets say you have 'struct Foo { x: [u8], y: [u8] }' ... how does this work? ;p
[19:45:46] <strcat> so I assume DST would be hard-coded?
[19:45:57] <strcat> or at least not very flexible
[19:46:11] <acrichto> pcwalton: you r+'d #10654, but we still haven't fully settled on removing conditions, and this goes against all other I/O usage today, would you be ok if I canceled the build?
[19:46:12] <pcwalton> it has various restrictions in it, yeah
[19:46:34] <strcat> I thought we settled on removing conditions?
[19:46:35] <pcwalton> acrichto: you can cancel it, I thought removing conditions was settled
[19:46:45] <kimundi> pcwalton: Also, I don't really see how its 'two kinds of type paramter' I thought you're just contemplating using the unsized keyword because the proper way, a Sized trait bound, would have to much fallout
[19:46:56] <pcwalton> well yeah
[19:47:03] <acrichto> pcwalton: we want to remove them, but I don't think that we have anything to replace them, my PR for removing io_error hasn't landed yet
[19:47:11] <pcwalton> ok
[19:47:19] <pcwalton> fair enough, feel free to cancel
[19:47:32] <sfackler> acrichto: is Result felt to be too painful to work with?
[19:47:35] <pcwalton> it ends up being two kinds of type parameters because having one kind of type parameter is too much burden :)
[19:47:40] <pcwalton> sfackler: the opposite
[19:47:46] <pcwalton> in my experience anyway
[19:47:49] <acrichto> sfackler: I think that the idea is that "fatal by default" being turned off is very sad
[19:47:51] <pcwalton> Result is nice enough to work with that we might as well use it
[19:48:00] <pcwalton> warn-unused-result fixes this...
[19:48:08] <acrichto> we don't have that though :(
[19:48:09] <pcwalton> and is needed for other patterns anyway
[19:48:19] <pcwalton> I've been agitating for it for years :)
[19:48:26] <Ms2ger> warn-unused-result would be good
[19:48:27] <pcwalton> and actually it was agreed upon months ago
[19:48:35] <Ms2ger> Also, -Werror=warn-unused-result
[19:48:37] <pcwalton> nobody has implemented it yet
[19:48:43] *** Joins: echristo (echristo@24D1937F.D6CCE4AE.77834EAA.IP)
[19:48:51] <cmr> My problem with ops returning Result is that you can't say "Do all of these io operations and fail if any of them do"
[19:48:59] <pcwalton> cmr: I think we need Haskell do notation
[19:49:02] <pcwalton> as a macro
[19:49:10] <pcwalton> that was also agreed upon years ago I think
[19:49:11] <cmr> I don't know what that is, but if it solves this problem, sure.
[19:49:19] <pcwalton> it does exactly what you said :)
[19:49:22] <cmr> Cool!
[19:49:30] *** Joins: nif (Mibbit@F773C385.3B36E0FD.F275000D.IP)
[19:49:30] <pcwalton> "you could have invented monads" ;)
[19:49:43] <pcwalton> (you did just invent monads right there) :)
[19:50:18] <kimundi> It just amounts to and_then(|| ...) chaining anyway :P
[19:50:37] <TeXitoi> monad sugar in rust? I'd love that ;)
[19:50:54] <pcwalton> kimundi: almost, except that it doesn't use an &fn so you can move out of parameters inside the and_then
[19:50:58] <pcwalton> move out of upvars rather
[19:51:17] *** Joins: Ferreus (ferreus@moz-27BAC7A0.pools.arcor-ip.net)
[19:51:57] <pcwalton> warn-unused-result would have saved me a day of bug hunting in rustc a few months ago
[19:52:04] <pcwalton> I dropped a block context on the floor in trans
[19:52:58] *** Quits: nif (Mibbit@F773C385.3B36E0FD.F275000D.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[19:53:21] <pcwalton> acrichto: but even so, your point is valid. maybe once we have those neato dynamically scoped variables we could have an "fatal_io_errors" global
[19:53:47] <acrichto> pcwalton: that's an interesting idea, although you'd still have to unwrap() everything
[19:53:52] <pcwalton> fluids (aka dynamically scoped variables) subsume conditions anyway.
[19:54:14] <pcwalton> since a condition is just a dynamically scoped closure.
[19:54:31] <pcwalton> I don't mind unwrapping everything, it's part of Rust
[19:54:36] <pcwalton> we're never going to get away from it
[19:54:43] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[19:54:45] <pcwalton> the alternative is null pointers ;)
[19:55:22] <bstrie> pcwalton: fluids??
[19:55:28] <bstrie> that's a new term
[19:55:36] <pcwalton> bstrie: dherman_ tells me it's what common lisp called dynamically scoped variables
[19:55:38] <pcwalton> he hates the term btw
[19:55:42] <bstrie> haha
[19:55:42] *** Quits: Axord (xord@moz-C0D5F15A.lsanca.dsl-w.verizon.net) (Connection reset by peer)
[19:55:54] <bstrie> iirc mitsuhiko wanted dynamically scoped variables, a long time ago
[19:56:01] * strcat finds dynamically scoped variables horribly confusing :(
[19:56:01] <pcwalton> I think they're inevitable
[19:56:03] <bstrie> not sure if he's ever heard of fluids
[19:56:11] <pcwalton> they're less confusing than globals IMHO
[19:56:29] <pcwalton> they're a natural TLS + RAII pattern
[19:56:42] <pcwalton> that we don't need to build into the language even because we have the building blocks as core parts of the langauge
[19:56:46] <pcwalton> language
[19:57:03] *** Quits: adridu59 (Mibbit@moz-6C393FDD.rev.numericable.fr) (Quit: http://www.mibbit.com ajax IRC Client)
[19:57:17] <strcat> we don't have static task (or thread) local data, though
[19:57:23] <pcwalton> I think we should
[19:57:27] <dherman_> pcwalton: fluids is a scheme term, not common lisp
[19:57:32] <pcwalton> oh, oops
[19:57:37] <pcwalton> we should make #[thread_local] work for M:N threading
[19:57:42] <pcwalton> otherwise M:N and 1:1 will just diverge
[19:57:45] <strcat> pcwalton: I'm not sure how to make it work
[19:57:48] <pcwalton> if we have to do it with life-before-main, so be it.
[19:57:49] <dherman_> https://www.google.com/search?q=fluid-let
[19:57:52] <strcat> in 1:1 the dynamic linker implements it
[19:57:59] <strcat> pcwalton: each library you dynamically load can add more thread_local
[19:58:02] <pcwalton> we can shove them in the crate map
[19:58:24] <pcwalton> then iterate over the crate map
[19:58:38] <strcat> I'm already lost on how we do something like a mutex with high quality 1:1 and M:N support *at runtime*
[19:59:23] <pcwalton> I'm ok with making the choice at compile time
[20:00:00] *** Joins: tikue_ (tkuehn@60AB20BB.EB08480C.689607DE.IP)
[20:01:28] <strcat> the java-style concurrent hash map actually works ridiculously well
[20:01:41] <pcwalton> the one written in rust?
[20:01:53] <strcat> well I just copied ConcurrentHashMap, yeah
[20:01:57] <strcat> it's really simple
[20:02:14] <strcat> fn new(shards: uint) -> ConcurrentHashMap { ... }
[20:02:22] <pcwalton> I want that in servo
[20:02:22] <strcat> it just makes that many HashMap in an array
[20:02:23] <strcat> and each one has a lock
[20:02:29] <strcat> and it uses the hash to find the right one
[20:02:36] <pcwalton> we should just make a library of concurrent data structures
[20:02:41] <strcat> I was too lazy to add a way to avoid double-hashing atm ;p
[20:03:26] <Sharp> Wow, the bash source code is… fun :P
[20:03:50] *** Quits: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com) (Ping timeout)
[20:04:36] <tikue_> strcat: what api do you expose? just clone(), find(), find_mut(), insert() etc?
[20:04:45] <Sharp> I like how it has its own file format for generating each builtin.
[20:04:51] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[20:04:59] <strcat> tikue_: it's all by-clone except swap
[20:05:12] <strcat> I guess you could make it return an RAII-like ref
[20:05:15] <strcat> releasing the lock in the dtor
[20:05:24] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[20:05:26] <strcat> anyway it's probably buggy ;p
[20:05:48] <strcat> an RAII lock like that would make it really, really easy to deadlock :(
[20:06:00] <tikue_> ah so you can't get mutable references to values in the hashmap?
[20:06:07] <strcat> right
[20:06:09] <strcat> you have to swap
[20:06:12] <tikue_> ok
[20:06:30] <pcwalton> you'll probably want an RAII-like ref
[20:06:32] <pcwalton> eventually
[20:06:58] <strcat> SipHash is really slow :(
[20:07:12] *** Joins: wilmoore (wilmoore@moz-1248C037.mystrotv.com)
[20:07:15] <strcat> it's slower than the low contention locking
[20:07:23] <strcat> :s
[20:07:23] *** Quits: sk (sk@61A494B3.BA40E8A.AAC02D62.IP) (Quit: Leaving)
[20:07:42] <strcat> I was thinking it might be because we have a streaming SipHash
[20:07:59] <strcat> wondering if LLVM would be happier with a special-cased single-pass one
[20:08:09] *** Joins: johns (johns@moz-BBE3ABD.mv.mozilla.com)
[20:08:51] <strcat> anyway it's just so ridiculously slow on integers
[20:08:59] *** Parts: strmpnk (sid2261@moz-E77DEB21.irccloud.com) ()
[20:09:06] <Florob> strcat, Why would it be faster, or similarly fast as a lock?
[20:09:11] <tikue_> it'd be cool if you could have multiple mutable references on loan from a hashmap concurrently
[20:10:14] <strcat> Florob: well they spin for a bit before waiting on a syscall, and that ends up being an insignificant cost compared to the hash
[20:10:16] *** Joins: devbug (quassel@2D4E172D.4C8B6099.9B57EA59.IP)
[20:10:35] <strcat> it's just a bit funny that a serial hashmap is not really faster than 2 threads accessing a concurrent one with locks
[20:10:54] <strcat> (even if I reduce it to 1 shard, that's actually how I wrote it at first...)
[20:10:58] *** Quits: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[20:11:01] <Florob> strcat, no futex? :(
[20:11:07] *** Joins: vmx (vmx@moz-1EBB0D31.pools.arcor-ip.net)
[20:11:12] <strcat> Florob: pthread_mutex_lock doesn't call futex right away
[20:11:18] <strcat> it spins a bit
[20:11:24] <strcat> in highly optimized asm
[20:11:34] <strcat> maybe it even knows how much contention the lock has, they are pretty big beasts
[20:12:03] <Florob> I was more thinking in terms of: Shouldn't the uncontended case not enter into kernel space at all?
[20:12:13] <strcat> Florob: it does some number of iterations in userspace before calling futex, yeah
[20:13:00] <strcat> I don't *really* understand how linux condition variables work, I think they are 2 linked lists (notified and not notified) and notification means writing to their memory
[20:13:16] <strcat> don't ask me why spurious wakeups happen ;p
[20:14:04] <kmc> http://www.akkadia.org/drepper/futex.pdf has some examples of implementing different concurrency primitives with futex
[20:16:43] <strcat> weird. glibc implements pthread_cancel with C++ exceptions
[20:17:04] <benh> :o
[20:17:23] <strcat> hm, how does that even work?
[20:17:24] <FreeFull> Is anyone working on STM for rust?
[20:17:30] <KokaKiwi> \o/ https://github.com/KokaKiwi/brainfuck-rs (useless, but it was fun to create :D)
[20:17:39] <KokaKiwi> (Oh, hello chan :p)
[20:17:42] *** Quits: willingc (willingc@moz-B4760708.san.res.rr.com) (Client exited)
[20:18:17] *** Joins: tulloch (tulloch@moz-6809CC86.nat.csx.cam.ac.uk)
[20:18:18] <vmx> cmr: i'm a rust noob, hence i ask here before commenting directly on the pull request if that's ok. isn't the right side of the or case already covered by the left one? https://github.com/cmr/rust/commit/7ce39b93fc8188fd458a286723bfa0861e0ec50b#diff-ba343ac25b603f92cef79e5fc56e11dbR321
[20:18:42] <strcat> haha, pthread_cancel calls rust destructors!
[20:18:48] <strcat> I wonder if it could be made sort of sound
[20:18:56] <strcat> anyway that's probably totally glibc specific
[20:19:24] <cmr> vmx: 
[20:19:26] <cmr> no
[20:19:29] <strcat> so.... you would need to be unwind-safe at any cancellation point
[20:19:36] * strcat looks for a list of those
[20:19:36] <vmx> *thinkingagain*
[20:19:48] <cmr> Actually..
[20:20:07] *** Quits: tikue_ (tkuehn@60AB20BB.EB08480C.689607DE.IP) (Quit: tikue_)
[20:20:20] <strcat> ah it throws in a signal handler I guess
[20:20:27] <strcat> what a weird hack
[20:20:29] *** Joins: zmthy (tim@moz-C2881CC3.ecs.vuw.ac.nz)
[20:20:34] <cmr> vmx: example: //// foo
[20:20:40] <cmr> vmx: satisfies the left, not the right
[20:20:41] *** Joins: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP)
[20:20:41] *** Joins: tikue_ (tkuehn@60AB20BB.EB08480C.689607DE.IP)
[20:21:00] <vmx> cmr: yes, but: /////
[20:21:03] <cmr> oh, wait
[20:21:08] <cmr> you asked the other way aroudn
[20:21:09] <cmr> Yes, it is.
[20:21:10] <vmx> cmr: sattisfies also the left
[20:21:20] *** Quits: vodik (simon@moz-63F3D7D1.net.uwaterloo.ca) (Quit: studying)
[20:21:32] <cmr> vmx: nice catch, thanks!
[20:21:50] * vmx did a lot of code review at work today, i'm still in that mode ;)
[20:21:51] *** Joins: willingc (willingc@moz-B4760708.san.res.rr.com)
[20:21:52] *** Quits: tikue_ (tkuehn@60AB20BB.EB08480C.689607DE.IP) (Quit: tikue_)
[20:22:40] *** Joins: jstevans (Instantbir@moz-8DBF3BC4.washdc.fios.verizon.net)
[20:23:21] *** Joins: tulloch_ (tulloch@moz-6809CC86.nat.csx.cam.ac.uk)
[20:23:57] <bstrie> vmx: nice, please go over the rest of the compiler code now
[20:24:06] <vmx> *lol*
[20:24:11] <bstrie> vmx: and have it done by wednesday, if you can. I want to close all existing bugs before thanksgiving
[20:24:23] *** Quits: jstevans (Instantbir@moz-8DBF3BC4.washdc.fios.verizon.net) (Ping timeout)
[20:24:29] <tjc> seems like a realistic goal to me
[20:24:58] <bstrie> I believe in shooting for the moon
[20:25:07] <bstrie> for even if you fail, you will land among the stars
[20:25:14] <bstrie> or, explode in a horrific fireball on the launchpad
[20:25:53] <vmx> cmr: i would also add a test case for five slashes in a row. either to the new issue test or to the existing is_line_non_doc_comment() ones. just having a single "//// test" seems a bit fragile for a unit test
[20:26:32] *** Joins: tikue_ (tkuehn@60AB20BB.EB08480C.689607DE.IP)
[20:27:02] *** Quits: Ms2ger (Ms2ger@moz-1B43DE50.adsl-dyn.isp.belgacom.be) (Quit: nn)
[20:27:27] *** Quits: tikue_ (tkuehn@60AB20BB.EB08480C.689607DE.IP) (Quit: tikue_)
[20:28:37] *** Quits: moostik (Icedove@5A22E6A1.10715965.BCDF592F.IP) (Ping timeout)
[20:28:55] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[20:29:28] *** victorporof is now known as victorporof|away
[20:30:13] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Quit: Gone to save the world!)
[20:32:45] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[20:34:50] *** Joins: SingingBoyo (brandon@moz-3F5E2B5C.ubcsecure.wireless.ubc.ca)
[20:36:02] *** Joins: Axord (xord@moz-C0D5F15A.lsanca.dsl-w.verizon.net)
[20:36:57] *** Joins: eternaleye (eternaleye@moz-5668AFCB.hsd1.wa.comcast.net)
[20:37:38] *** Joins: Dessimat0r (Dessimat0r@E879B262.8D4FD984.4320F744.IP)
[20:38:32] *** Joins: chef_ (chef@moz-F037F3DA.ipreg.mcmaster.ca)
[20:39:45] *** Parts: chef_ (chef@moz-F037F3DA.ipreg.mcmaster.ca) (See you later!)
[20:41:57] *** Quits: wilmoore (wilmoore@moz-1248C037.mystrotv.com) (Ping timeout)
[20:43:14] *** Quits: victorporof|away (victorporo@47B918E3.BCF05198.9B1E38F4.IP) (Quit: victorporof|away)
[20:43:47] *** Joins: nsf (nsf@moz-EEF3238A.convex.ru)
[20:46:21] *** Quits: SingingBoyo (brandon@moz-3F5E2B5C.ubcsecure.wireless.ubc.ca) (Quit: leaving)
[20:47:50] *** Joins: wilmoore (wilmoore@moz-1248C037.mystrotv.com)
[20:47:53] *** Joins: SingingBoyo (brandon@moz-3F5E2B5C.ubcsecure.wireless.ubc.ca)
[20:49:57] *** Quits: eddyb (eddy@336E3A7F.D51DAF03.FB866788.IP) (Ping timeout)
[20:50:27] *** Quits: wilmoore (wilmoore@moz-1248C037.mystrotv.com) (Ping timeout)
[20:51:32] *** Joins: foodoo (foodoo@moz-1A535C7.pool.mediaways.net)
[20:51:44] *** Joins: canhtak (canhtak@moz-6F820ACE.wl.t.ulaval.ca)
[20:55:22] *** Quits: nsf (nsf@moz-EEF3238A.convex.ru) (Quit: WeeChat 0.4.2)
[20:56:17] *** Joins: nsf (nsf@moz-EEF3238A.convex.ru)
[20:56:36] *** Quits: devbug (quassel@2D4E172D.4C8B6099.9B57EA59.IP) (Input/output error)
[20:57:12] *** Joins: penguin_dan (dan_johnsi@6902762D.11B071D.FB9A45AF.IP)
[20:58:56] *** Quits: jlong (jlong@moz-6DFDE846.socal.res.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[21:00:09] *** Joins: devbug (quassel@2D4E172D.4C8B6099.9B57EA59.IP)
[21:00:53] *** Quits: SingingBoyo (brandon@moz-3F5E2B5C.ubcsecure.wireless.ubc.ca) (Ping timeout)
[21:00:55] <foodoo> Hi, I want to read a tab-seperated file with the first column as string and the remaining 3 columns as integers. These 4 values then should be given to a function as independent parameters. 
[21:00:59] <foodoo> http://pastebin.com/JU9gfvBq
[21:01:21] *** Quits: pcwalton (pcwalton@moz-C07D5168.p2p.sfo1.mozilla.com) (Quit: pcwalton)
[21:01:22] <foodoo> And I have trouble coming up with a reasonable solution (and the code does not compile)
[21:01:27] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[21:01:38] *** Quits: Kruppe (user@moz-253119B0.esg.uwaterloo.ca) (Ping timeout)
[21:02:07] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[21:02:07] <foodoo> So, every line from that file is being fed to the the Package::new function as a strict
[21:02:13] <foodoo> strict -> string
[21:02:17] <cmr> foodoo: the elements that split_iter yields is a &str, ie, a pointer  into the original string.
[21:02:42] <cmr> so you're going to need name = val.to_owned(), first off.
[21:02:56] <kmc> instead of "this doesn't compile" it's more useful to provide the error message from the compiler
[21:03:06] <cmr> Or have name be a &str
[21:03:12] *** Quits: dherman_ (dherman@moz-B31C6965.dsl.pltn13.sbcglobal.net) (Ping timeout)
[21:03:21] <cmr> You don't really need to take a ~str, you can just take a &str
[21:03:28] *** Quits: qrpth (andreas@39EED39.590DF183.783D9E8C.IP) (Ping timeout)
[21:03:33] *** Joins: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net)
[21:03:57] <foodoo> kmc: Yes, I understand that compiler messages are helpful, but in this case I am rather questioning my general approach
[21:04:09] <cmr> foodoo: it's fine, just some niggling details with the types.
[21:06:38] *** Joins: jviereck (Adium@moz-CF8216D6.dip0.t-ipconnect.de)
[21:06:58] *** Quits: jviereck (Adium@moz-CF8216D6.dip0.t-ipconnect.de) (Max SendQ exceeded)
[21:07:04] *** Joins: jviereck (Adium@moz-CF8216D6.dip0.t-ipconnect.de)
[21:08:02] *** Quits: nkoep (nik@moz-D8197C3D.pool.mediaways.net) (Ping timeout)
[21:08:37] <foodoo> I wonder if this can also be done without any mutability
[21:10:22] *** flaper87 is now known as flaper87|afk
[21:11:05] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[21:12:13] *** Joins: vodik (simon@moz-FD4ADBC6.cable.teksavvy.com)
[21:12:32] *** Joins: nkoep (nik@moz-D8197C3D.pool.mediaways.net)
[21:13:40] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[21:13:50] *** Quits: alonlevy (alon@moz-EB7C9CF3.telavivmakers.org) (Ping timeout)
[21:15:36] <benh> Do we have any general "when to use int/uint vs specifically sized integer types" guidelines?
[21:15:53] <benh> or does everybody just type int/uint because it's the default?
[21:16:19] <cmr> benh: int/uint only need to be used when you need a pointer-sized integer
[21:16:26] <cmr> And the specifically sized when you only need that size.
[21:16:36] <cmr> beyond that, it's just guesswork.
[21:16:39] <sfackler> I generally use int/uint unless I am actually need exactly x bits
[21:16:41] <strcat> benh: if you don't have specific bounds you need a big integer
[21:16:52] <strcat> but in many cases 64-bit is more than enough
[21:17:08] <bstrie> 64-bit integers are pretty big integers, I guess
[21:17:27] *** Quits: nkoep (nik@moz-D8197C3D.pool.mediaways.net) (Ping timeout)
[21:17:38] <strcat> 128-bit integers are a lot bigger but big integers still exist ;p
[21:17:50] <bstrie> typedef i64 = prettybigint;
[21:17:56] *** Quits: Dessimat0r (Dessimat0r@E879B262.8D4FD984.4320F744.IP) (Ping timeout)
[21:18:09] <cmr> that is so butchered
[21:18:45] <sbalmos> heh
[21:18:52] <bstrie> haha
[21:18:56] <foodoo> uint::from_str( val ); gives me "error: unresolved name `uint::from_str`". But uint does implement the FromStr trait. What am I doing wrong? (val should be a &str)
[21:19:08] <cmr> foodoo: Which rust version are you using?
[21:19:14] <sfackler> let x: uint = FromStr::from_str(val)
[21:19:20] <cmr> .unwrap()
[21:19:25] <sbalmos> cmr: u128 for those of us (re)implementing ZFS ;)
[21:19:28] <foodoo> rustc --version reports 0.8
[21:19:34] <cmr> foodoo: then what sfackler said
[21:20:16] <foodoo> sfackler: thanks. What will I have to do in 0.9?
[21:20:41] <benh> cmr: So I should aim to use the smallest integer type that will fit all the numbers I need?
[21:20:53] <strcat> bstrie: 64-bit integers aren't really *that* big, they're not enough to do economic calculations in cents ;p
[21:20:55] <cmr> Same works in 0.9, but we also have a function in prelude: from_str::<uint>(val).unwrap()
[21:21:18] <benh> That is, rather start with i16 or i32 for human-sized numbers and only upgrade to the scary and awesome range of int when things are getting serious?
[21:21:19] <cmr> benh: generally, yes.
[21:21:22] <strcat> bstrie: derivatives market is something like 1 quadrillion? hm
[21:21:24] <bstrie> strcat: eh, we can just do those calculations in floats anyway :)
[21:21:50] <sbalmos> strcat: Now if we just took all those fractions of a cent rounding errors, and deposited them into an account somewhere...
[21:21:52] <sbalmos> oops
[21:21:58] <bstrie> maybe int should default to i8
[21:22:02] <strcat> so yeah, derivatives are already close to the 64-bit overflow
[21:22:05] <bstrie> then we'd be really fast by default.
[21:22:10] <benh> I suppose I am kind of surprised that we removed float but not int/uint
[21:22:15] <strcat> and if you had fractions of a cent you'd be screwed
[21:22:17] <bstrie> benh: there's an issue for that
[21:22:20] <strcat> benh: unlike float, they are useful
[21:22:28] <benh> bstrie: ah, but then what isn't there an issue for? :)
[21:22:31] <strcat> address space is a real thing you have to deal with
[21:22:39] <strcat> float was just... weird
[21:22:54] <benh> strcat: yeah, but is it really a thing that needs to have the most 'convenient' int-like type name?
[21:23:03] <strcat> benh: no it should be called inptr
[21:23:05] <strcat> intptr
[21:23:07] <strcat> and uintptr
[21:23:09] <strcat> ;p
[21:23:22] <strcat> rust is so screwed if segmented architectures become a thing again though'
[21:23:31] <strcat> (they won't)
[21:23:37] <benh> that sounds like *int though ;)
[21:24:29] <strcat> that's what they are called in C
[21:24:29] * benh found the issue
[21:24:32] <strcat> intptr_t, uintptr_t
[21:24:47] <benh> strcat: yeah, but aren't they also called size_t, ptrdiff_t and all kinds of other now-synonyms?
[21:24:56] <strcat> no those aren't necessarily the same
[21:24:59] <strcat> :D
[21:25:11] <strcat> benh: think about 16-bit x86 with that weird segmented stuff
[21:25:20] <benh> phew
[21:25:26] *** Quits: lmandel (lmandel@13F2CEC5.7672369.D8E68FF6.IP) (Quit: lmandel)
[21:25:39] *** Quits: anri (solancile@moz-E49E7C4B.hsd1.wa.comcast.net) (Input/output error)
[21:25:42] *** Joins: anri (solancile@moz-E49E7C4B.hsd1.wa.comcast.net)
[21:25:45] <sbalmos> strcat: Geez, going back to the 386 days?
[21:25:48] <sbalmos> :P
[21:25:49] <bstrie> I'm fine with `intptr` as a name now
[21:25:54] <bstrie> no _t though, please :)
[21:25:57] <benh> I never actually wrapped my head around how pre-32bit things work[ed] :)
[21:26:00] <strcat> sbalmos: well afaik that's probably why C has size_t and intptr_t
[21:26:05] <bstrie> I'm actually really happy with the removal of float
[21:26:05] <strcat> unless other archs did that too
[21:26:08] <sbalmos> who knows
[21:26:11] <bstrie> a lot more than I expected to be
[21:26:29] <strcat> lets remove bools now :D
[21:26:39] <sbalmos> *smack*
[21:26:43] <cmr> I don't want to rename int/uint until we have generic numeric literals and fast bigints
[21:26:46] <o11c> I think it's a mistake that rust's 'int' behaves differently on different platforms
[21:26:51] <strcat> enum Bool { True, False }
[21:26:57] <bstrie> yeah, usable bigints would be nice
[21:26:59] <o11c> at least if it's called 'intptr' it's *obvious*
[21:26:59] <strcat> o11c: it's always pointer size
[21:27:06] <sbalmos> strcat: Even though it's not a pointer
[21:27:19] <sbalmos> So what's the point? (hah)
[21:27:22] <benh> I think it's going to bite us in a bunch of naive benchmarks where people transliterate their C code and suddenly we use twice as much memory because our ints are bigger
[21:27:31] <strcat> sbalmos: array sizes, data structure sizes, pointer arithmetic
[21:27:32] <benh> ;)
[21:27:38] <bstrie> strcat: let's learn from python's example that putting True and False in that namespace is something we'll regret :)
[21:27:42] *** Joins: lmandel (lmandel@13F2CEC5.7672369.D8E68FF6.IP)
[21:27:52] <strcat> bstrie: why? we already have true and false
[21:28:05] <bstrie> but you can't reassign them
[21:28:18] <benh> I can't wait until we have explicitly scoped enums and we'll have to write Bool::True :>
[21:28:21] <strcat> >>> True = 5
[21:28:23] <strcat>   File "<stdin>", line 1
[21:28:25] <strcat> SyntaxError: assignment to keyword
[21:28:27] * strcat doesn't understand
[21:28:39] <strcat> True * 2 + 5 will work though
[21:28:47] <bstrie> ugh
[21:28:54] <rpearl> False is False is False
[21:28:58] <strcat> bstrie: oh I didn't realize they weren't keywords in python2
[21:28:59] <bstrie> then it's a good thing we got rid of that ability then :)
[21:29:13] <bstrie> but we still have True > False
[21:29:14] *** Quits: tulloch (tulloch@moz-6809CC86.nat.csx.cam.ac.uk) (Ping timeout)
[21:29:16] <strcat> bstrie: in C++:
[21:29:17] <bstrie> which is a little weird but w/e
[21:29:18] *** Quits: tulloch_ (tulloch@moz-6809CC86.nat.csx.cam.ac.uk) (Ping timeout)
[21:29:21] <strcat> bool *p = false;
[21:29:23] <strcat> it's a null ptr!
[21:29:24] *** Quits: blank_name (blank_name@FAB53C88.7071B2C8.31EC03F3.IP) (Quit: Lost terminal)
[21:29:25] <strcat> ;p
[21:29:36] <bstrie> strcat: whyyy
[21:29:40] <sbalmos> heheheh
[21:29:45] *** Joins: blank_name (blank_name@FAB53C88.7071B2C8.31EC03F3.IP)
[21:29:49] *** Quits: Jesin (Jesin@moz-6536249C.cc.lehigh.edu) (Quit: Leaving)
[21:29:49] <benh> strcat: that's so great
[21:30:02] <strcat> bstrie: nullptr literals are a C++11 feature
[21:30:08] <strcat> and nullptr_t
[21:30:13] <strcat> ;p
[21:30:22] <benh> strcat: my favorite tho is the constexpr function returning int that happened to evaluate to zero being a valid null pointer literal, or however that workeds
[21:30:25] <benh> -s
[21:30:37] <strcat> in C, NULL is (void*)0 (at least it usually is, dunno what it's standardized as)
[21:30:42] <strcat> in C++ it has to just be 0
[21:30:48] <strcat> so in templates, it's totally screwed
[21:30:50] *** Joins: tulloch (tulloch@moz-6809CC86.nat.csx.cam.ac.uk)
[21:31:00] <strcat> because it's an integer first and a pointer second but in some cases that's not true
[21:31:01] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[21:31:20] * strcat doesn't want to think about it anymore
[21:31:31] <benh> oh my, you can do int* p = sizeof(int[0]);
[21:31:38] <strcat> benh: sure
[21:31:40] <strcat> benh: you can write
[21:31:49] <strcat> benh: (**************puts)("hello world");
[21:31:51] <strcat> valid C
[21:31:53] *** Joins: huseby (huseby@moz-24DEE44B.snydernet.net)
[21:31:58] *** Joins: nkoep (nik@moz-5B73729B.vpn.rwth-aachen.de)
[21:31:59] <benh> yeah :v
[21:32:09] *** Joins: quvarxa (chatzilla@moz-978E4C31.static.tpgi.com.au)
[21:32:11] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[21:32:31] *** Joins: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP)
[21:32:49] <strcat> 2["foo"] is 'o'
[21:32:58] <strcat> well (char)'o'
[21:33:02] *** Quits: nejucomo (Adium@moz-3B9BDB73.hlrn.qwest.net) (Quit: Leaving.)
[21:33:03] <strcat> in C, 'o' is an int literal
[21:33:05] <strcat> not a char
[21:33:25] <strcat> and ofc it didn't have bools until c99 so 'a < b' is an int
[21:33:26] <strcat> yay
[21:33:41] <sfackler> strcat: 
[21:33:44] <sfackler> int main(void) {int n = sizeof(0)[“abcdefghij”]; printf(”%d\n”, n); return 0; }
[21:33:53] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[21:33:58] <strcat> sfackler: (*****printf)
[21:34:19] <strcat> sfackler: oh and you don't need return 0 in main anymore, main is special
[21:34:28] <sfackler> or a void in the main args
[21:34:33] <benh> petition to make rust string literals require smart quotes, as befits a modern, unicode aware programming language
[21:34:42] <strcat> sfackler: you do need that or it infers the type of main
[21:34:44] <cmr> please no
[21:34:48] <strcat> I'm not really sure if it's valid for main
[21:34:52] <benh> ((i mean fancy unicode quotes as introduced by the smart quotes feature))
[21:34:55] <strcat> if you write
[21:34:57] <strcat> int foo() { }
[21:34:57] *** Joins: tulloch_ (tulloch@moz-6809CC86.nat.csx.cam.ac.uk)
[21:34:59] <strcat> it means
[21:35:05] <strcat> 'infer the parameters of foo from the first usage' in C
[21:35:08] <strcat> in C++, it doesn't mean that.
[21:35:15] *** jorendorff is now known as jorendorff_away
[21:35:21] <strcat> that's why C has foo(void)
[21:35:47] <sfackler> (i c/p'd that code from somewhere)
[21:35:59] <strcat> sfackler: heh
[21:36:09] <sfackler> fun fact: the output is architecture independent
[21:36:28] <strcat> C++ adds super important features to C like lvalue ternary operator though
[21:36:50] <benh> Is that just for the benefit of references?
[21:36:57] <o11c> strcat: I think that's wrong, int foo() {} means a function with no arguments, but int foo(); means any arguments
[21:36:57] <strcat> int a = 2; int b = 5; bool b = false; (b ? a : b) = 10;
[21:36:59] <strcat> benh: no idea
[21:36:59] *** jorendorff_away is now known as jorendorff
[21:37:07] <strcat> o11c: ah, maybe
[21:37:40] <strcat> benh: all I know is that the fraction of C++ I've used has never had a use case for that.
[21:38:11] <strcat> just seems like a code golf feature ;p
[21:38:32] <sbalmos> That ventures into shoot yourself in the foot and call it a watering hole territory
[21:38:49] <Luqman> o11c: well, if you declare it as int foo() {}, the compiler won't stop you if you pass it any number of arguments
[21:38:54] *** Quits: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[21:39:17] *** Joins: pcwalton (pcwalton@moz-C07D5168.p2p.sfo1.mozilla.com)
[21:39:17] *** ChanServ sets mode: +ao pcwalton pcwalton
[21:39:20] *** Joins: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com)
[21:40:22] <pcwalton> 7th attempt to merge de-do bounced :(
[21:40:34] <pcwalton> this is a record I think
[21:41:09] <sbalmos> excellent
[21:41:17] <aatch> pcwalton, maybe lock the tree?
[21:41:17] <cmr> record for # bounces?
[21:41:23] <o11c> Luqman: that's a definition, not just a declaration
[21:41:35] <benh> because of intermittent build/test failures or bitrotted merge conflicts?
[21:41:50] <pcwalton> aatch: nah, acrichto doesn't do that when he does big stuff, I am inspired by his example :)
[21:41:58] <pcwalton> cmr: yeah
[21:42:14] <acrichto> pcwalton: haha I just bounce for a week until it finally lands
[21:42:30] <aatch> pcwalton, admirable, but don't be a matyr.
[21:42:47] <aatch> martyr(?)
[21:42:59] <aatch> SPELLING IS HERD!
[21:43:39] *** Joins: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net)
[21:43:39] *** ChanServ sets mode: +o tjc
[21:43:51] <bstrie> aatch: *hyrd
[21:44:22] *** Quits: abinader (abinader@D8B9C081.E820043D.D4C04133.IP) (Quit: Fui!)
[21:45:07] *** Quits: z0w0 (zack@moz-3C2F9E52.qcl9.cha.bigpond.net.au) (Ping timeout)
[21:45:15] *** Quits: foodoo (foodoo@moz-1A535C7.pool.mediaways.net) (Ping timeout)
[21:48:22] *** Quits: avsej (avsej@D9A610B8.4841F515.FB33447D.IP) (Client exited)
[21:49:33] *** Joins: SingingBoyo (brandon@moz-61C83175.ubcsecure.wireless.ubc.ca)
[21:50:29] *** Quits: devbug (quassel@2D4E172D.4C8B6099.9B57EA59.IP) (Ping timeout)
[21:52:37] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[21:53:17] <Leo`> does someone have some recent Rust formal description or semantics ?
[21:53:43] <kimundi> For what?
[21:54:06] <Leo`> to show to a professor in my university :p
[21:54:06] *** Quits: jviereck (Adium@moz-CF8216D6.dip0.t-ipconnect.de) (Quit: Leaving.)
[21:54:32] <bstrie> Leo`: ummmmmm, you could print out the compiler source code!
[21:54:35] <Leo`> teaching formal semantics and proofs and this kind of things. I told him about Rust, i didn't know it and asked if there were such
[21:54:40] <Leo`> bstrie: hehe
[21:54:51] <bstrie> it's technically a formal description
[21:55:00] <bstrie> but it has not been peer reviewed
[21:55:01] <Leo`> this may be a lot of paper
[21:55:14] <Scriptor> just go to your school's print shop
[21:55:20] *** Quits: Jackneill (Jackneill@moz-CA2E3320.pool.digikabel.hu) (Input/output error)
[21:55:21] <Scriptor> it'll be a nice book
[21:55:22] <bstrie> Leo`: at best, there was an old effort to formalize the borrow check
[21:55:32] <bstrie> Leo`: but nmatsakis is working on v 2.0 of that
[21:56:36] *** Quits: spider-mario (spidermari@moz-2F72F6FF.dsl.quantic-telecom.net) (Ping timeout)
[21:56:47] <Leo`> you mean for Rust 2.0 or ... ?
[21:57:03] <cmr> Leo`: there's no formalization of anything atm
[21:57:14] *** Quits: blank_name (blank_name@FAB53C88.7071B2C8.31EC03F3.IP) (Quit: leaving)
[21:57:25] <bstrie> Leo`: v 2.0 of the formalization
[21:57:26] *** Joins: jdm (jdm@moz-AC9499B2.cable.teksavvy.com)
[21:57:26] *** ChanServ sets mode: +o jdm
[21:57:43] <Leo`> bstrie: oh
[21:57:44] <cmr> we used to have a grammar but it has rotted away
[21:58:21] *** Quits: nano (nano@moz-74CAD1CA.superkabel.de) (Connection reset by peer)
[21:58:34] *** Quits: SingingBoyo (brandon@moz-61C83175.ubcsecure.wireless.ubc.ca) (Ping timeout)
[21:58:37] *** Joins: spider-mario (spidermari@moz-2F72F6FF.dsl.quantic-telecom.net)
[21:58:38] <Leo`> operational semantics and formal typing rules are more interesting
[21:58:44] <sbalmos> Most everyting is rotten. ;)
[21:58:47] <Leo`> but a formal grammar should be cool too
[21:58:59] <Leo`> cmr: sbalmos not rotten
[21:58:59] <pcwalton> Leo`: look at borrowck/doc.rs
[21:59:01] <Leo`> Rusty
[21:59:01] <pcwalton> that is the interesting part.
[21:59:03] <Leo`> :D
[21:59:04] <pcwalton> and is up to date
[21:59:05] *** Quits: eternaleye (eternaleye@moz-5668AFCB.hsd1.wa.comcast.net) (Ping timeout)
[21:59:06] <pcwalton> and is fairly formal
[21:59:08] <sbalmos> *smack*
[21:59:13] <bstrie> sbalmos: not rotten, just fermenting :) we're like wine!
[21:59:23] *** Joins: eternaleye (eternaleye@moz-5668AFCB.hsd1.wa.comcast.net)
[21:59:29] <sbalmos> Leo`: How recent is your tetanus shot? :o
[21:59:39] <kimundi> rust code doesn't rot, it oxydizes
[21:59:42] <pcwalton> Leo`: https://github.com/mozilla/rust/blob/master/src/librustc/middle/borrowck/doc.rs
[21:59:45] <Leo`> recent enough, I hope.
[21:59:45] <sbalmos> bstrie: Had more than enough of that yesterday
[21:59:46] <pcwalton> this is the interesting part of rust's type system
[21:59:57] <Leo`> oh tanks pcwalton 
[22:00:07] <Leo`> does this generates some kind of readable documentation
[22:00:07] <sbalmos> We've already informally agreed that the Rust IDE is named OxIDE
[22:00:14] <Leo`> with Rustdoc or whatever
[22:00:25] <bstrie> hahaha
[22:00:36] <Leo`> 0xIDE ? I is not a valid hexadecimal digit :(
[22:00:36] <bstrie> that's brilliant
[22:00:48] <sbalmos> Leo`: Oh not this again. We've already been down that road...
[22:01:03] *** Joins: jstevans (Instantbir@moz-8DBF3BC4.washdc.fios.verizon.net)
[22:01:09] <sbalmos> pcwalton: Does my pointer borrowing have to go through underwriting and have an appraisal done on it? :)
[22:01:25] <pcwalton> hmm?
[22:01:26] <jstevans> Does anything about the Booting to Rust (UEFI kernel) tutorial change when considering building an ARM kernel?
[22:01:26] <jstevans> http://blog.theincredibleholk.org/blog/2013/11/18/booting-to-rust/
[22:01:35] <kimundi> Leo`: It's markdown that's being used by rustdoc, and can also be pasted into gist: https://gist.github.com/Kimundi/7649708
[22:01:55] <sbalmos> jstevans: The calling convention?
[22:02:01] *** Quits: spider-mario (spidermari@moz-2F72F6FF.dsl.quantic-telecom.net) (Input/output error)
[22:02:06] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[22:02:25] *** Joins: dherman_ (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[22:02:43] <Leo`> kimundi: thanks :D
[22:02:46] *** Joins: jviereck (Adium@moz-CF8216D6.dip0.t-ipconnect.de)
[22:02:54] *** Quits: jviereck (Adium@moz-CF8216D6.dip0.t-ipconnect.de) (Client exited)
[22:03:14] <cmr> jstevans: ARM has UEFI?
[22:03:45] <jstevans> sbalmos: I figured that, but I'm not sure what that changes...
[22:04:07] <sfackler> cmr: yeah https://wiki.linaro.org/ARM/UEFI
[22:04:27] *** Quits: barosl (barosl@3DE683B6.E551553C.7544CABF.IP) (Quit: 랜덤은 쇠퇴했습니다.)
[22:05:53] *** Quits: KindOne (KindOne@moz-7A3ED1B8.dynamic.ip.windstream.net) (Ping timeout)
[22:07:49] <cmr> If it actually follows the UEFI spec, you shouldn't need to change anything.
[22:09:06] <sbalmos> cmr: Save for the calling convention, whatever register on ARM UEFI does the systable pointer handoff in, etc
[22:09:08] *** Quits: vodik (simon@moz-FD4ADBC6.cable.teksavvy.com) (Ping timeout)
[22:10:05] *** Joins: refold (gman@moz-42D68426.a258.priv.bahnhof.se)
[22:10:39] *** Joins: KindOne (KindOne@moz-113B2D00.dynamic.ip.windstream.net)
[22:12:36] <tjc> Leo` sbalmos : 1 is a valid hex digit, though :-)
[22:13:19] <sbalmos> tjc: Ya, we already went over a bigger argument that 0x1DE doesn't have enough digits to be a 16-bit number
[22:13:39] <tjc> sbalmos: okay, then pad with zeroes on the left :-)
[22:13:41] <ChrisMorgan> ... what?
[22:13:55] *** Joins: Dessimat0r (Dessimat0r@E879B262.8D4FD984.4320F744.IP)
[22:14:13] <ChrisMorgan> Extra zeroes are strictly non-essential.
[22:14:15] <sbalmos> tjc: 0x01DE. Sounds weird. :D Meh, we'll just document it as a "well, we tried..."
[22:14:37] *** Quits: vmx (vmx@moz-1EBB0D31.pools.arcor-ip.net) (Quit: Leaving)
[22:15:00] <Leo`> tjc: sbalmos 0x1DE is fine to me :P
[22:15:30] <tjc> oxoide
[22:15:34] <tjc> that's a perfectly cromulent word
[22:15:53] <sbalmos> ;)
[22:16:36] *** Quits: Dessimat0r (Dessimat0r@E879B262.8D4FD984.4320F744.IP) (Ping timeout)
[22:17:05] <bjustin> kisses and hugs IDE
[22:17:49] *** Quits: tiffany (kawaii@moz-FC0DB29D.dhcp.embarqhsd.net) (Ping timeout)
[22:18:49] <jstevans> sbalmos: according to the tutorial, UEFI requires the win64 calling convention. On ARM, even for UEFI, what is the correct thing to do?
[22:19:04] *** Joins: SingingBoyo (brandon@moz-61C83175.ubcsecure.wireless.ubc.ca)
[22:21:29] <sbalmos> no idea. Never done UEFI, much less BIOS/whatever handoff on other platforms
[22:22:34] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Quit: Leaving...)
[22:23:19] *** Quits: SingingBoyo (brandon@moz-61C83175.ubcsecure.wireless.ubc.ca) (Connection reset by peer)
[22:24:05] *** Joins: SingingBoyo (brandon@moz-A4BCD073.ubcsecure.wireless.ubc.ca)
[22:24:48] *** Quits: willingc (willingc@moz-B4760708.san.res.rr.com) (Client exited)
[22:28:32] *** Joins: ssalbiz (ssalbiz@moz-21D6B3DE.csclub.uwaterloo.ca)
[22:28:48] *** Quits: ssalbiz (ssalbiz@moz-21D6B3DE.csclub.uwaterloo.ca) (Quit: leaving)
[22:29:59] *** Quits: valenting (Thunderbir@95C905BA.4985FA88.FCAAE698.IP) (Ping timeout)
[22:35:23] *** Quits: Sorella (quildreen@9D963F5D.DF5D8AE7.54BCAB54.IP) (Ping timeout)
[22:37:03] *** Joins: Sorella (quildreen@9D963F5D.DF5D8AE7.54BCAB54.IP)
[22:37:37] *** Joins: willingc (willingc@moz-B4760708.san.res.rr.com)
[22:39:59] <pcwalton> whoa https://github.com/sebcrozet/nrays
[22:40:00] <pcwalton> generics!
[22:40:41] *** Quits: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com) (Ping timeout)
[22:40:47] <benh> oh my
[22:40:53] *** Joins: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net)
[22:40:53] <benh> 4 dimensions?
[22:41:10] <pcwalton> wow
[22:41:38] <sbalmos> holy
[22:41:48] <sbalmos> that... O_O
[22:42:00] *** Joins: sp3d (s@moz-41A29595.dhcp.stls.mo.charter.com)
[22:42:10] <kmc> these are some serious trait bounds
[22:42:24] <kmc> N: 'static + Cast<f32> + Send + Freeze + NumCast + Primitive + Algebraic + Signed + Float
[22:42:37] <sbalmos> the goggles, they do nothing!
[22:43:21] *** Joins: eholk (eholk@moz-EA69C7A5.wavecable.com)
[22:43:33] <benh> ... I'm wondering whether maybe C++ had it right all along and having all the generic parameters and their kind declared in a special bit of syntax before the item declaration proper would be easier to read in the general case of N parameters with K bounds each...
[22:43:54] <pcwalton> the Java-like style is so sugary for small functions though
[22:43:59] *** Quits: Ferreus (ferreus@moz-27BAC7A0.pools.arcor-ip.net) (Ping timeout)
[22:44:02] <benh> yeah
[22:44:18] <pcwalton> when there are a small number of bounds writing "template" is so annoying
[22:44:28] <pcwalton> it's part of the reason closures in C++11 are annoying to use
[22:44:45] <pcwalton> since every function that takes a closure has to be
[22:44:51] *** Quits: StarLight (StarLight@moz-B644A6E1.dynamic.avangarddsl.ru) (Ping timeout)
[22:44:59] <pcwalton> template<typename T> void my_HoF(T f) { … }
[22:45:07] <pcwalton> and that isn't even with concepts yet
[22:45:28] <pcwalton> besides, C++ was forced into doing it that way because of the lexer hack
[22:45:39] <pcwalton> I don't think they did it because they wanted to
[22:45:46] <strcat> pcwalton: there's the alternative of boxing every closure in a heap allocation ;p
[22:45:54] <pcwalton> which is not what rust does
[22:45:58] <strcat> right
[22:46:04] <sbalmos> g'night
[22:46:07] <pcwalton> I don't think C++ made the wrong decision
[22:46:19] <strcat> although I don't think it allocates to box non-closures
[22:46:21] <pcwalton> they made the best decision they could with backwards compatibility
[22:46:22] *** Quits: sbalmos (quassel@CA5677B6.576D0C1.ED2EFC1B.IP) (Client exited)
[22:46:26] <strcat> and it could probably do small-closure optimization ;p
[22:46:32] <pcwalton> strcat: is std::function not like rust's stack closures?
[22:46:39] <strcat> pcwalton: std::function is like ~fn
[22:46:42] <pcwalton> huh
[22:46:45] <strcat> it erases the type
[22:46:47] <pcwalton> why don't they have something like &fn?
[22:46:51] <strcat> pcwalton: dunno
[22:46:54] <kmc> std::function has a virtual operator() right?
[22:46:57] <pcwalton> seems like an obvious thing
[22:47:03] <strcat> kmc: something like that
[22:47:07] <kmc> so it won't inline f into my_HoF without more heavy-duty analysis
[22:47:23] <pcwalton> well, it's roughly the same as the analysis rust has to do
[22:47:25] *** Joins: alonlevy (alon@moz-BCF1494.bb.netvision.net.il)
[22:47:29] <kmc> whereas the generic my_HoF which takes T a subclass of std::function with a non-virtual operator() can do that easily
[22:47:30] <pcwalton> I don't think it needs to be virtual operator()
[22:47:37] <pcwalton> it just has to call through the function pointer
[22:48:12] *** Quits: ianj (ianjneu@moz-7140CF01.ccs.neu.edu) (Quit: leaving)
[22:49:06] *** Joins: StarLight (StarLight@moz-398D0B94.dynamic.avangarddsl.ru)
[22:51:14] <kmc> pcwalton: ah you're saying std::function might hold a single function pointer rather than a vtable pointer?
[22:51:20] <pcwalton> yeah
[22:51:21] *** Quits: Sorella (quildreen@9D963F5D.DF5D8AE7.54BCAB54.IP) (Ping timeout)
[22:51:31] <kmc> that would make sense
[22:51:35] <strcat> pcwalton: http://www.boost.org/doc/libs/1_55_0/doc/html/function/misc.html
[22:51:38] <strcat> ' Function pointers are faster (Boost.Function may require two calls through function pointers) '
[22:51:41] <strcat> hrm
[22:51:54] <kmc> it's still a barrier to optimization though
[22:52:10] *** Joins: Sorella (quildreen@9D963F5D.DF5D8AE7.54BCAB54.IP)
[22:52:22] <strcat> ah this is basically just rust's closure issue
[22:52:25] <strcat>  With a properly inlining compiler, an invocation of a function object requires one call through a function pointer. If the call is to a free function pointer, an additional call must be made to that function pointer (unless the compiler has very powerful interprocedural analysis).
[22:52:29] <strcat> the reason we have the env ptr param
[22:52:50] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[22:52:51] <strcat> (for them, a 'this' ptr)
[22:52:53] *** Joins: tikue_ (tkuehn@6E051717.B9B3942C.689607DE.IP)
[22:53:27] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[22:55:31] *** Joins: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com)
[22:55:35] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[22:57:34] *** Joins: jordyd (jordyd@7DAC4ACE.77F880E0.D9401097.IP)
[22:58:31] *** Quits: SingingBoyo (brandon@moz-A4BCD073.ubcsecure.wireless.ubc.ca) (Ping timeout)
[22:59:23] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[23:00:08] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[23:02:14] *** Joins: SingingBoyo (brandon@moz-A4BCD073.ubcsecure.wireless.ubc.ca)
[23:03:55] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[23:04:26] *** Joins: tiffany (kawaii@moz-FC0DB29D.dhcp.embarqhsd.net)
[23:05:00] <ChrisMorgan> ReoScript has agreed to switch from .rs to .reo; RedScript has agreed to switch from .rs to .rds; RiveScript has agreed to switch from .rs to .rive; each of these quite promptly and with full approval (I'm mildly surprised). That leaves approximately three completely dead projects I won't bother about, and Android's RenderScript. Unfortunately, I still don't think I'll have success getting that one to change extension.
[23:05:00] <bjz> pcwalton: re. generics: https://mail.mozilla.org/pipermail/rust-dev/2013-September/005457.html
[23:05:49] <bjz> pcwalton: didn't get any responses though
[23:06:20] <bjz> pcwalton: I think seb's type params are far more complex than mine though
[23:06:46] *** Joins: jst_ (quassel@moz-BBE3ABD.mv.mozilla.com)
[23:07:18] *** Quits: lmandel (lmandel@13F2CEC5.7672369.D8E68FF6.IP) (Quit: lmandel)
[23:07:25] *** Quits: tiffany (kawaii@moz-FC0DB29D.dhcp.embarqhsd.net) (Ping timeout)
[23:12:22] *** Quits: huseby (huseby@moz-24DEE44B.snydernet.net) (Quit: Leaving)
[23:13:14] <heftig> ChrisMorgan: I wonder why Rust doesn't use .rust
[23:13:22] <heftig> and .rust-crate
[23:13:33] <ChrisMorgan> .rc is obsolete, it's just .rs now.
[23:13:46] <ChrisMorgan> heftig: shorter is better, as a generalisation.
[23:13:46] <pcwalton> bjz: I usually do pub trait AffineSpace<S:Field
[23:13:56] <pcwalton> --- ident to < --- V:VectorSpace<S>>(
[23:14:07] <pcwalton> --- same level of ident --- Eq
[23:14:14] <pcwalton>  --- same level of indent --- + Zero
[23:14:15] <pcwalton> etc
[23:14:47] *** Joins: huseby (huseby@moz-B2F53871.torservers.net)
[23:14:50] <bascule> LOL @ origin of "Bors"
[23:14:54] *** Quits: Scriptor (anonymous@moz-E06F46F0.corp.bitshelter.com) (Quit: Scriptor)
[23:14:54] <heftig> woo, algebra
[23:15:16] <ChrisMorgan> Yes, visual indent not a multiple of four. Some people are strangely allergic to that—that's what happens if your tools don't support it elegantly.
[23:15:26] *** Quits: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP) (Client exited)
[23:20:48] *** Quits: Florob (Florob@moz-39532932.de) (Client exited)
[23:20:54] *** Joins: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz)
[23:22:20] *** Quits: lfox (lfox@moz-343B6F0C.nyc.biz.rr.com) (Quit: ZZZzzz…)
[23:25:46] *** Quits: snerd (motk@moz-D21A06DF.members.linode.com) (Quit: leaving)
[23:25:54] *** Joins: snerd (motk@moz-D21A06DF.members.linode.com)
[23:26:20] *** Joins: q66_ (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[23:27:21] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Ping timeout)
[23:28:46] *** Quits: SingingBoyo (brandon@moz-A4BCD073.ubcsecure.wireless.ubc.ca) (Ping timeout)
[23:30:25] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[23:30:54] *** Joins: infynyxx_ (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[23:30:54] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Connection reset by peer)
[23:32:51] *** Quits: bungoman (bungoman@moz-B5620CD.ptr.richards.com) (Client exited)
[23:33:16] *** Joins: bungoman (bungoman@moz-B5620CD.ptr.richards.com)
[23:34:09] *** Quits: bungoman (bungoman@moz-B5620CD.ptr.richards.com) (Connection reset by peer)
[23:34:21] *** Joins: bungoman (bungoman@moz-B5620CD.ptr.richards.com)
[23:34:23] *** Quits: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[23:34:27] *** Quits: eholk (eholk@moz-EA69C7A5.wavecable.com) (Quit: eholk)
[23:35:11] *** Quits: infynyxx_ (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[23:35:54] *** Joins: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net)
[23:35:54] *** ChanServ sets mode: +o tjc
[23:36:03] *** Quits: bungoman (bungoman@moz-B5620CD.ptr.richards.com) (Ping timeout)
[23:37:04] *** Quits: donri (donri@moz-9BB61102.tbcn.telia.com) (Client exited)
[23:37:58] *** Joins: sbalmos (quassel@CA5677B6.576D0C1.ED2EFC1B.IP)
[23:37:58] *** Quits: sbalmos (quassel@CA5677B6.576D0C1.ED2EFC1B.IP) (Connection reset by peer)
[23:38:11] <ssbr_> I want to introduce a (quasi-machine-generated -- loaded from a CSV file) test suite where I want to measure the percentage of tests that pass or fail. It's a sort of compliance test suite. I was thinking of writing a bunch of tests that are #[cfg(compliance)] #[test] and also have a function #[cfg(compliance)] #[main] fn run_compliance() {...}   which gives a nice report of the results in a different form than from --test. So I can run the non-c
[23:38:11] <ssbr_> ompliance tests with rustc re.rs --test, run all the tests with rustc re.rs --test --cfg compliance, and run just the compliance tests (with special output) using rustc re.rs --bin --cfg compliance. Does that sound sensible or is that dumb?
[23:38:31] <ssbr_> Not as much a rust question as maybe a software engineering question. I'm not too good on what good testing practices are.
[23:39:11] <ssbr_> (If the compliance tests are fast enough I'd mark them with #[cfg(or(test, compliance))] I guess)
[23:39:32] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[23:39:40] <ssbr_> (there's like 300K of them though, multiplied by the number of implementations, so...)
[23:39:41] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[23:40:44] *** Quits: jix (jix@moz-D969BFFC.de) (Ping timeout)
[23:41:46] *** Joins: krdln (Mibbit@moz-6F8A8560.dynamic.chello.pl)
[23:41:56] <ssbr_> oh, it'd be rustc re.rs --bin --cfg compliance --cfg test
[23:42:27] *** Joins: jix (jix@moz-D969BFFC.de)
[23:42:48] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[23:43:56] <ssbr_> actually, nah, it's probably better to just have unit tests, and process the output for alternate reports
[23:45:43] *** Joins: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP)
[23:45:54] *** Joins: sbalmos (quassel@CA5677B6.576D0C1.ED2EFC1B.IP)
[23:45:54] *** Quits: sbalmos (quassel@CA5677B6.576D0C1.ED2EFC1B.IP) (Connection reset by peer)
[23:46:03] *** Joins: sbalmos (quassel@CA5677B6.576D0C1.ED2EFC1B.IP)
[23:46:17] *** Quits: ofeldt (ofeldt@moz-3961C767.dip0.t-ipconnect.de) (Ping timeout)
[23:46:30] *** Quits: pcwalton (pcwalton@moz-C07D5168.p2p.sfo1.mozilla.com) (Quit: pcwalton)
[23:47:10] *** Joins: pcwalton (pcwalton@moz-C07D5168.p2p.sfo1.mozilla.com)
[23:47:10] *** ChanServ sets mode: +ao pcwalton pcwalton
[23:47:22] *** Quits: alan (alan@moz-FE02DD30.sat6.rackspace.com) (Ping timeout)
[23:49:18] *** Quits: fhahn (fhahn@moz-7924DB5C.vie.surfer.at) (Ping timeout)
[23:49:29] *** Joins: fhahn (fhahn@moz-7924DB5C.vie.surfer.at)
[23:50:55] *** Quits: echristo (echristo@24D1937F.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[23:53:32] *** Quits: voxpopuli (fanservice@moz-FE161659.wv.cc.cmu.edu) (Ping timeout)
[23:54:16] *** Quits: nkoep (nik@moz-5B73729B.vpn.rwth-aachen.de) (Ping timeout)
[23:56:21] <pcwalton> 9th failure
[23:56:52] <pcwalton> oh, this rustpkg test
[23:56:56] <pcwalton> I don't know why that fails
[23:58:47] *** Joins: echristo (echristo@3FB4C2BC.2E4FD3DD.225F4543.IP)
[23:58:49] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Quit: Leaving...)
[23:59:50] *** Quits: willingc (willingc@moz-B4760708.san.res.rr.com) (Client exited)

[00:14:19] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[00:29:45] *** Parts: Yurume (Yurume@moz-0t8.piq.68.115.IP) ()
[00:31:15] *** Joins: Yurume (Yurume@moz-0t8.piq.68.115.IP)
[00:47:45] <mayski> meh spam again
[00:47:51] <eternaleye> bascule: Reading your old blog stuff (specifically, the Ruby threading post), I'm struck by how your advice basically boils down to much the same behavior as Rust, before Rust behaved the way it does :D
[00:48:07] <eternaleye> mayski: /mode mayski +c, so you can only get PMs from people you share a channel with
[00:48:50] <mayski> eternaleye: thanks I tried +R too but seems the guy got around it or something
[00:50:00] <mayski> seen in #rust yesterday btw /wc <begin> <end> will close multiple windows
[00:50:07] <mayski> ^ to those waking up
[00:51:28] <eternaleye> mayski: +R means they have to be registered
[00:51:46] <eternaleye> mayski: Mozilla's IRC infrastructure doesn't require email interaction on registration, so they can spam it
[00:51:48] <mayski> yeah I thought that would've done it but guess not
[01:44:37] *** Parts: apoelstra (username@moz-pvbasl.net) ("WeeChat 1.1.1")
[01:50:39] <bascule> eternaleye: yup
[01:50:51] <bascule> eternaleye: hence why I like Rust ;)
[01:51:02] <bascule> and yeah lolspam
[01:51:05] <bascule> gonna reboot my irssi
[01:51:07] *** Quits: bascule (bascule@moz-1u4.6er.243.162.IP) (Quit: leaving)
[01:51:09] *** Joins: bascule (bascule@moz-1u4.6er.243.162.IP)
[01:51:23] <bascule> probably not the optimal solution to that stuff, lol
[01:52:24] <mayski> bascule: check above you can close them all easily
[01:52:32] <bascule> haha
[01:52:33] <bascule> too late!
[01:52:38] <mayski> :)
[01:52:41] <bascule> also I lost the backlog
[01:56:50] <eternaleye> bascule: This is why I run ZNC!
[01:57:20] <eternaleye> bascule: Anyway, irssi (and weechat) can close _ranges_ of windows with /wc <begin> <end>
[02:01:31] <bascule> cool story, I used to run ZNC, but felt mosh -> screen -> irssi -> znc was a bit too lulz
[02:01:42] <bascule> now I use Slack :o
[02:04:09] <eternaleye> Oh, I just use ZNC, and then my laptop has Konversation, and my phone has AndIRC
[02:04:27] <eternaleye> And the server running ZNC also has Bitlbee, so I can handle my other chat networks that way too
[02:04:34] <eternaleye> And get logging in the bargain
[02:04:51] <eternaleye> I mean, using mosh/screen/irssi with znc is just silly
[02:05:00] <eternaleye> Just use irssi locally if you like the interface
[02:05:20] <bascule> umm
[02:05:24] <bascule> the UX is way better if you do that
[02:05:29] <bascule> it doesn't constantly reconnect/respam you
[02:05:38] <bascule> or rather, it does, but mosh handles it seamlessly
[02:05:45] <bascule> so I'd argue the opposite is silly? heh
[02:05:59] <eternaleye> bascule: How frequently do you get disconnected? :/
[02:06:06] <bascule> all the time at work?
[02:06:08] <eternaleye> bascule: I mean, I have >30 channels, and that's a non-issue
[02:06:11] <eternaleye> Wow, that's shitty.
[02:06:13] <bascule> I take my laptop with me and I go to meetings
[02:06:28] <bascule> or go upstairs on the roof to hack
[02:06:34] <eternaleye> What, and the wifi can't handoff properly?
[02:06:37] <bascule> uhh
[02:06:40] <eternaleye> Or do you wire in when seated?
[02:06:41] <bascule> my laptop is shut
[02:06:46] <eternaleye> Ah
[02:06:50] <bascule> sometimes for 5-10 minutes
[02:06:51] <eternaleye> I turn off lid-close suspend'
[02:06:54] <bascule> lol
[02:06:59] <eternaleye> Because I hate it with a fiery passion
[02:07:03] <bascule> hahaha
[02:07:05] <mayski> amen
[02:07:10] <eternaleye> I've got a fucking battery in this thing _why_, again?
[02:07:10] <bascule> I... guess that's another solution?
[02:07:33] <eternaleye> I mean, I leave it on when I take my 2h bus ride home so I can use it tethered
[02:07:46] <eternaleye> Why the fuck would I turn it off for a 5min walk to a meeting room?
[02:08:01] <bascule> because you can? heh
[02:08:21] <eternaleye> Besides, the radeon card in here tends to glitch hard on hibernate and suspend
[02:23:39] <Tobba> on windows?
[02:23:51] <Tobba> or official Linux drivers, I guess
[02:27:42] <eternaleye> Open-source linux
[02:27:57] <eternaleye> Running 3.19, and forget what version of xf86-video-radeon
[03:46:43] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[03:48:49] <bascule> I like my laptop not operating when, say, it's in my backpack, heh
[03:57:32] <eternaleye> Mm, I use a messenger bag that actually leaves the vents of my laptop exposed
[03:57:47] <eternaleye> Especially since it's got a slice battery that keeps stuff away from them
[03:59:34] <Ilari> Heh, those BSI guys... Reminds me of that paper from them about curve selection for CFRG... That I had nothing good to say about.
[04:01:29] <eternaleye> Hm, I wonder how hard it'd be to generate LLVM IR for 64-bit-pointer data layout, and then later on apply a range-limitation pass to pointers so they're within the 32-bit range, and optimize from that.
[04:02:06] <Ilari> Thinking of mixed-mode binaries or something?
[04:02:44] <eternaleye> Ilari: More about how SystemZ apparently compiles for a 128-bit virtual architecture, and then specializes the binaries for the "real" architecture
[04:03:24] <eternaleye> Ilari: For stuff like RISC-V, it might be neat to do something similar in distro packaging - compile a fully-general one for 128, and see how much of "native" performance is recoverable by install-time specialization
[04:03:48] <eternaleye> Ilari: (The SystemZ thing is why it basically completely skipped the 32/64 switchover issues)
[04:04:02] <eternaleye> Ilari: (They just respecialized binaries on newer, 64-bit execution machines)
[04:04:40] <Ilari> Also, reminds me of multi-CPU-variant libraries. Eg. AMD64-baseline, SSE3, SSSE3, SSE4, AVX, AVX2, AVX512, etc...
[04:04:43] <eternaleye> Ilari: The fact that Rust uses fixed-size integers by default (and usize is the only unspecced one) could make it much more feasible than C
[04:04:58] <eternaleye> Ilari: Yeah, although I'd rather handle that with something like ifuncs.
[04:05:25] <eternaleye> Ilari: At first function call, check which is the best variant; then memoize that choice by overwriting the pointer in the GOT
[04:05:34] <cmr> eternaleye: what does the range-limitation pass do? Does it modify structure layout?
[04:05:57] <eternaleye> cmr: It's basically "Hey, static analysis says these can't be outside this range" annotation of values
[04:06:06] <Ilari> Also, I have once tried to look how to ELF version various rust functions.
[04:06:08] <eternaleye> cmr: It doesn't optimize on its own; it just gives info to optimizers
[04:06:42] <eternaleye> cmr: This is "info" about the execution environment, though, so normal static analysis couldn't determine it
[04:06:57] <eternaleye> cmr: I'm just wondering how much optimizers could _do_ with that
[04:07:09] <Ilari> isize/usize might be bit problematic as bitwidth alters how those wrap around.
[04:07:22] <eternaleye> Ilari: No, those would act as the larger size
[04:07:28] <eternaleye> Ilari: They'd be less _performant_ though
[04:07:38] <cmr> eternaleye: If pointers are still 64-bit always, it seems like the only thing that would change is the size of locals.
[04:07:39] <eternaleye> Ilari: Hence why Rust using fixed-size types by default is nice
[04:07:51] <cmr> when they can be determined to be < 32bit
[04:08:09] <cmr> however that analysis wouldn't be very useful unless it's global and maybe even saturating.
[04:08:11] <eternaleye> cmr: Not sure if they would anyway; does llvm turn "1u32" into a u8?
[04:08:32] <eternaleye> cmr: No, it'd strictly annotate any pointerval as cannot exceed.
[04:08:41] <eternaleye> cmr: As in, "if this was violated it'd be UB"
[04:08:49] <bascule> eternaleye: I can't stand messenger bags
[04:09:00] <bascule> they're asymmetrical and make my back hurt
[04:09:02] <eternaleye> cmr: And since usize -> pointer is unsafe { }, I think that'd be okay
[04:09:16] <eternaleye> bascule: I just put equal weight on the other side of my coat :P
[04:10:06] <cmr> eternaleye: I'm not thinking about what LLVM *does* do, but rather what it could possibly do given such information.
[04:10:26] <eternaleye> cmr: Well, loads and stores of pointers would use different instructions, for one.
[04:12:11] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[04:12:13] <eternaleye> It might be able to do some deeper optimization with more passes, though
[04:12:35] <eternaleye> Like if a struct is never passed to mem::size_of or unsafe code, it can be re-laid-out.
[04:13:01] <eternaleye> Ditto arrays
[04:13:55] <eternaleye> Actually, a big one might be function prototypes
[04:14:09] <Ilari> ifuncs would certainly be handy if working on say ECC library with code generator for multiple optimizations (especially if combined with some way to make the ECC code for given optimization be close together in the image...)
[04:14:14] <eternaleye> The size of the actual pointer passed won't break anything there since it's not serializable
[04:14:35] <eternaleye> But it _can_ save one register per pointer on 64-bit pointer vs. 32-bit pointer on a 32-bit machine
[04:14:54] <bascule> eternaleye: I don't understand how you do that without strangling yourself
[04:15:14] <eternaleye> bascule: Messenger bag straps should never be anywhere by your neck
[04:15:33] <eternaleye> bascule: They should sit on the meat of your trapezius, well past your collarbone
[04:15:51] <eternaleye> bascule: That might be why they hurt for you...
[04:15:56] <bascule> lol no
[04:15:59] <bascule> I think you misunderstand
[04:16:08] <bascule> I'm saying the only way for it to be symmetrical is to hang it off your throat
[04:16:14] <eternaleye> Oh, no
[04:16:17] <bascule> haha
[04:16:19] <mayski> also messenger bags usually have one strap going around your waist that will take a lot of the weight off
[04:16:25] <eternaleye> I have one of those Scott-e-vest coats
[04:16:29] <eternaleye> With 37 pockets
[04:16:36] <bascule> o_O
[04:16:36] <eternaleye> I just load up one side of it with stuff
[04:16:39] <cmr> lol
[04:16:53] <bascule> how do you bear the load so the weight is evenly distributed across your back?
[04:16:54] <mayski> (off your shoulders that is)
[04:17:04] <eternaleye> Look, one of those pockets can hold a macbook pro.
[04:17:05] <mayski> (or rather, shoulder)
[04:17:07] <cmr> wat
[04:17:13] <eternaleye> I have tested this.
[04:17:35] <eternaleye> It's intended as a tablet pocket, but it's juuuuust large enough for a 15in MBP
[04:17:53] <eternaleye> Of course, my laptop's a 17in dell workstation beast
[04:17:59] <eternaleye> So that's not an option :P
[04:18:19] <eternaleye> But I can get roughly equal weight on each shoulder, so I'm not having to torque myself to stand upright
[04:18:34] <eternaleye> The total is heavy, sure, but that's just exercise :P
[04:18:37] <bascule> this article suggests: put all the load on one shoulder: http://www.loadedpocketz.com/how-to-correctly-wear-a-messenger-bag/
[04:18:46] <eternaleye> bascule: Yes, of the bag itself.
[04:18:48] <bascule> when I wind up carrying my girlfriend's bag, I switch shoulders often
[04:18:56] <bascule> because the load is all unevenly distributed
[04:18:58] <bascule> and I'm like
[04:19:01] <bascule> these things are dumb
[04:19:06] <eternaleye> bascule: Mm, whereas I always wear it on my left shoulder, bag on my right hip
[04:19:13] <eternaleye> Or behind me
[04:19:17] <bascule> humanity solved this problem and it's called a backpack
[04:19:24] <cmr> lol
[04:19:33] <eternaleye> Behind me, the bag sits on my hips in back, and the strap is diagonal across my chest
[04:19:55] <eternaleye> bascule: The problem with a backpack is when you want to sit down on the bus
[04:20:08] <eternaleye> bascule: Without beaning some dude who might have a knife in the face :P
[04:20:12] <bascule> I sit down with my backpack on half the time
[04:20:18] <bascule> but often I... just stand
[04:20:18] <bascule> heh
[04:20:26] <eternaleye> bascule: Yeah, when I had one, it was way too full to keep it on
[04:20:35] <eternaleye> bascule: And I hate standing, because then I can't be on my laptop!
[04:20:43] <cmr> Sounds like you just plain carry too much shit :P
[04:20:44] <bascule> haha
[04:20:47] <eternaleye> At least not while having both hands free to type
[04:21:08] <eternaleye> cmr: I used to read three books a day before I switched to ebooks because of space constraints, so... yes?
[04:22:18] <eternaleye> Ilari: Anyway, back to ifuncs
[04:22:46] <eternaleye> Ilari: You can already sort of do that with "function multiversioning" in GCC and the __target__() attribute
[04:23:18] <eternaleye> Ilari: However, it doesn't (yet, though the wiki claims it's wanted) support taking one function and generating multiple forms of it
[04:23:33] <eternaleye> Ilari: You have to write out each form your self, though it will ifunc-select between them.
[04:26:46] <Ilari> Also what would be useful: Changing architecture for one function (it will never be reached if that architecture isn't present). E.g. for SSE code on i386 or AVX on amd64. Otherwise using the relevant registers tends to cause errors.
[04:38:36] <eternaleye> Ilari: Read up on function multiversioning
[04:38:45] <eternaleye> Ilari: It does pretty much exactly that
[04:39:05] <eternaleye> Ilari: Or, well, if you want to unconditionally change arch on a function, it's the __target__() attribute
[04:39:26] <eternaleye> Ilari: If you want "If there is AVX, use this, if there is SSE, use this", then use function multiversioning
[04:39:32] <eternaleye> Ilari: It can also go by -march values
[04:40:07] <eternaleye> Ilari: In that "If this is -march=core2, this one. If -march=haswell, this one"
[04:40:17] <eternaleye> Ilari: (at runtime)
[04:44:37] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[04:46:31] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[05:07:07] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[05:43:40] *** Quits: cmn (cmn@moz-r1h.buc.47.78.IP) (Connection closed)
[05:43:41] *** Joins: cmn (cmn@moz-r1h.buc.47.78.IP)
[05:43:44] *** Quits: cmn (cmn@moz-r1h.buc.47.78.IP) (Connection closed)
[05:44:57] *** Joins: cmn (cmn@moz-r1h.buc.47.78.IP)
[06:01:37] <Ilari> Grr... Found possible security problem in TLS 1.3. It is in part I proposed, and my original proposal didn't have the problem. At least it can't be exploited without breaking SHA-256 or similar.
[07:14:40] *** ttaubert|pto is now known as ttaubert
[07:34:15] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[07:35:01] *** Joins: jesopo (jess@lolnerd.net)
[07:39:11] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[07:44:43] *** Joins: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua)
[09:23:13] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[09:28:01] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[11:12:02] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[11:16:47] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[12:12:49] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[12:17:37] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[13:09:47] <Tiffany> eternaleye: suspend on lid close wouldn't be so bad if it were instant
[13:09:56] <Tiffany> which it has every right to be
[13:10:12] <Tiffany> I didn't turn it off for that reason though
[13:10:21] <Tiffany> I turned it off because 50% of the time my computer would fail to resume from suspend
[13:10:34] <Tiffany> I have this shitty acer laptop with awful ACPI
[13:10:39] <Tiffany> the problem happens with windows too
[13:12:35] <Tiffany> hm
[13:12:39] <Tiffany> you mention issues with AMD
[13:12:47] <Tiffany> maybe I have this problem because I have optimus graphics
[13:20:07] <Tiffany> function multiversioning would be nice
[13:20:33] <Tiffany> I have some places in my code where I do one call to a really expensive batch function
[13:20:59] <Tiffany> if I could just annotate it in a way that it generates multiple versions for different SIMD extensions (or even GPU) and branch depending on what's available
[13:21:02] <Tiffany> that would be great
[13:24:55] <Ilari> Tiffany: The problem with function multiversioning is that it relies on indirect functions, which are available on very few platforms. 
[13:32:28] <Tiffany> indirect functions?
[13:35:38] <Ilari> Tiffany: Run a function that returns address of the actual function (which can then apply CPU detection to discover the appropriate variant).
[13:37:13] <Ilari> AFAIK, not supported on Windows, not supported on Mac OS X, not supported on FreeBSD, ...
[13:38:17] <Tiffany> is this some kind of linker hackery?
[13:38:25] <Tiffany> I was thinking of something a lot more basic, although possibly slower
[13:39:39] <Ilari> And since the address is discovered at link bind time, the discovery only happens once per function (subsequent calls proceed like normal calls).
[13:42:21] <Ilari> As for linker hackery, it is explicitly supported by the dynamic linker if available.
[13:43:22] <Tiffany> I suppose for my usecase I don't mind if the branch costs
[13:45:08] <Ilari> Well, if compiling to target that supports indirect functions, GCC does support function multiversioning (with some basic features like various SSE versions and AVX versions, etc...)
[13:45:58] <Tiffany> another option that's nearly free is using a function pointer instead of relying on linker features
[13:46:28] <Tiffany> like GL extension loaders
[13:47:19] <Tiffany> set the function pointer to a function which sets the function pointer to the best implementation for the CPU
[13:52:22] <Ilari> One could have function pointer pointing to function that reloves the implementation and then patches the pointer (calling the implementation in process), but that might cause double indirection when used with shared objects.
[13:54:43] <Ilari> Unless one wants to play games with thread safety, that would need overwriting pointers to be atomic.
[14:01:36] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[14:06:21] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[14:14:17] <Tiffany> so the issue is having a general solution, rather than having a solution at all
[14:14:33] <Tiffany> my usecase is very simple, is there a way I can do this without a bunch of manual code?
[14:14:59] <Tiffany> no need to worry about threads or call overhead
[14:15:42] <Ilari> Well, there is simple solution on some platforms GCC targets (except for GPU), except it isn't portable outside those. :-/
[14:20:06] <eternaleye> Tiffany: Well, in C on Linux you can just do https://gcc.gnu.org/wiki/FunctionMultiVersioning
[14:20:55] <Tiffany> er, oh
[14:20:56] <eternaleye> Tiffany: On C on everything else, you can declare a static function pointer, have it start with the value of a detector function, and have the detector function set the pointer to the best version and then call that
[14:21:12] <eternaleye> Tiffany: (using atomic ops)
[14:21:19] <Tiffany> I was hoping for something where the compiler would do the vectorization for me
[14:21:48] <eternaleye> Tiffany: According to another page on the wiki, planned but unimplemented.
[14:21:53] <Tiffany> I have this function which has about 2000 instructions of matrix manipulation that runs on batches of hundreds
[14:22:05] <Tiffany> it autovectorizes beautifully
[14:22:37] <eternaleye> Tiffany: Might work as always_inline, and do separate multiversions that call it
[14:22:55] <eternaleye> Tiffany: IIRC, multiversioning _does_ turn on the appropriate optimizations for each body
[14:22:59] <Tiffany> nice
[14:23:11] <eternaleye> Tiffany: It just doesn't support multiple -> monomorphized
[14:36:41] <Tiffany> I read bascule's article on we crypto
[14:37:13] <Tiffany> I noticed this same problem when I first learned about mega
[14:37:47] <Tiffany> being able to sign assets using offline keys is a pretty cool idea, I wonder if it can be implemented on the web
[14:43:18] <Tiffany> hmm
[14:43:22] <Tiffany> maybe with a browser extension
[14:43:45] <Tiffany> yeah
[14:43:45] *** Joins: brson (brson@moz-cfhap5.mtv2.mozilla.com)
[14:43:55] <Tiffany> server could host signed files, extension would read them in and verify
[14:44:08] <Tiffany> though you have to deal with keys
[14:45:46] <Ilari> IIRC, there is subresource integerity being worked on in W3C, but it doesn't do anything if top-level page is compromised and doesn't support all resource types (scripts are supported tho).
[14:57:44] <eternaleye> Tiffany: The thing is, once you have an extension, you may as well just implement Tahoe-LAFS as a browser extension
[15:20:08] *** Quits: brson (brson@moz-cfhap5.mtv2.mozilla.com) (Ping timeout: 121 seconds)
[15:22:43] *** Joins: brson (brson@moz-cfhap5.mtv2.mozilla.com)
[15:27:13] <Tiffany> tahoe-LAFS?
[15:27:40] <Tiffany> you know, I think chrome apps are a good target for web crypto
[15:27:50] <Tiffany> they're static blobs that can be audited
[15:50:45] <eternaleye> Tiffany: https://www.tahoe-lafs.org/trac/tahoe-lafs
[15:54:04] <Tiffany> nice
[15:58:33] <Tiffany> I like that they have a one-page summary
[16:03:29] <Tiffany> so they encrypt with AES, authenticate with HMAC-SHA256, and sign with RSA?
[16:04:03] <Tiffany> there should be something like this built into web browsers
[16:33:47] <Ilari> Wonder how fast one could make secure 256-bit block cipher...
[16:33:58] <Ilari> (And 256 bit key too)
[16:34:53] <Tiffany> software or hardware?
[16:36:53] <Tiffany> you have chacha at 1.5 cycles per byte..
[16:37:14] <Tiffany> for hardware you could probably use simon or something like simon
[16:38:14] <Tiffany> it has a mode with 128-bit blocks + 256-bit keys + 72 rounds
[16:38:34] <Tiffany> and it's basically 4 operations not counting rotation
[16:38:40] <Tiffany> per round
[16:38:52] <Tiffany> oh, 256 bit blocks
[16:38:53] <Tiffany> hm
[16:39:15] <Tiffany> for software you can probably do better than chacha by using something that maps to SIMD registers more closely
[16:39:30] <Tiffany> like storing the whole state matrix in an AVX-512 register and doing rotations on it
[16:39:39] <Tiffany> instead of needing to work on matrix columns
[16:40:09] <Ilari> Also, the way Chacha works, it isn't block cipher.
[16:40:13] <Tiffany> oh
[16:40:14] <Tiffany> oops
[16:40:38] <Tiffany> I don't know anything about the creation of block ciphers yet, other than feistel networks
[16:41:12] <Tiffany> I imagine the biggest perf hit with feistel networks is that afaik they require a key schedule?
[16:42:45] <Ilari> Well, if one has hardware AES, 4-round feistel cipher with AES with feedforward as S-Box? And I think there was 256/256 Rijndael, but no AES accelerator can accelerate it.
[16:45:20] <Ilari> Might run under 2 cycles per byte on Haswell. Dunno about security.
[16:45:59] <Tiffany> from what I remember seeing, AES-NI only does 3.5 cycles per byte
[16:46:03] <Tiffany> unless you're talking about something else?
[16:46:17] *** Joins: erickt (erickt@moz-4hh.6p3.217.74.IP)
[16:46:57] <Ilari> Well, eBASC reports AES-128-CTR as 0.85 cycles per byte on Haswell.
[16:47:12] <Tiffany> huh
[16:47:27] <Tiffany> welp
[16:47:33] <Tiffany> I was wrong about chacha being faster than AES-NI
[16:47:58] <Tiffany> wikipedia cites 3.5 cycles per byte for AES-GCM
[16:48:56] <Ilari> I think it is good bit faster than that on Haswell.
[16:49:10] <Tiffany> ah
[16:49:15] <Tiffany> so it took multiple cycles?
[16:49:17] <Tiffany> before
[16:49:23] <Tiffany> or did they extend the instruction set?
[16:49:55] <Ilari> AES-NI is instruction set extension, that contains instructions for computing AES rounds and for carryless mul (for GCM).
[16:50:47] <Ilari> I think on haswell, AES-GCM is a bit above 1 cycle per byte (for AES-128).
[16:52:28] <Tiffany> no I mean, more than one cycle to execute an AESENC instruction
[16:53:34] <Ilari> AES blocks are 16 bytes, so that many bytes are processed in parallel...
[16:53:41] <Tiffany> yeah
[16:53:46] <Tiffany> but I'm wondering how they made it faster
[16:54:04] <Tiffany> did the AESENC instruction take more cycles to execute before?
[16:54:32] <Ilari> I think so. And also nowdays CLMUL is more efficient (less cycles) too...
[16:55:32] <Ilari> For AES-128, one needs to do 9 AESENCs + 1 AESENCLAST (since the last round is a bit different).
[16:56:01] <Tiffany> oh, there's only 10 rounds?
[16:56:36] <Tiffany> that explains it then
[16:56:47] <Ilari> Yeah. AES-192 has IIRC 12 and AES-256 has IIRC 14 (which is too few).
[16:57:13] <Tiffany> haswell makes it so AESENC takes 1 cycle, and so you end up with 10/16 cycles per byte and maybe some overhead
[16:57:21] <Tiffany> or at least, I assume so
[16:57:25] <Ilari> Funkily enough, against certain attacks, AES-256 is the weakest, AES-128 is in the middle, and AES-192 is the strongest.
[16:57:27] <Tiffany> because that would be consistent with <1 cycle per byte
[16:57:35] <Tiffany> heh
[16:58:02] <Tiffany> I wonder if that influenced djb's statement that rounds are the thing that adds security fastest
[16:58:43] <Ilari> Well, there are attacks (especially against badly designed ciphers) where more rounds won't help (e.g. slide attacks).
[17:00:41] <Tiffany> oh
[17:01:22] <Tiffany> would a slide attack work on TEA?
[17:01:46] <Ilari> I think those attacks that AES-256 is weak against were related-key attacks, that don't come up if one is just encrypting (unless rest of the system is very badly designed), but may come up if one tries to make AES do something it wasn't intended for (e.g. hash functions).
[17:01:50] <Tiffany> oh, the delta might make it not
[17:02:07] <Ilari> The standard way of breaking slide attack is to have round constants.
[17:02:15] <Tiffany> ah
[17:02:19] <Tiffany> so the delta breaks it
[17:03:38] <Tiffany> what about chacha?
[17:05:35] <Ilari> There the feedforward breaks it.
[17:05:52] <Tiffany> feedforward?
[17:07:46] <Ilari> Chacha20 feeds forward the original block to result. Which makes the thing irreversible.
[17:07:57] <Tiffany> ah
[17:08:27] <Tiffany> that would be the final part of performing a block, adding the original matrix to the result matrix, right?
[17:08:33] <Tiffany> so this only works on reversible ciphers
[17:08:48] <Ilari> Well, block ciphers are assumed reversible.
[17:08:52] <Tiffany> and if you removed that last step, you could use chacha as a block cipher and it'd be a very broken block cipher?
[17:09:34] <Ilari> Extremely broken.
[17:11:02] <Ilari> "If you can get one block (64 bytes) of known plaintext, you could recover the key" level of broken.
[17:11:43] <Tiffany> nice that it only gets a sentence or two in the original paper, then
[17:11:43] *** Joins: bpugh (bpugh@moz-715e47.ca.comcast.net)
[17:11:48] <Ilari> Heh: "Over the past 14 days, the TLS 1.0 fallback was needed on 0.00% of HTTPS requests on the beta channel, after rounding."
[17:11:51] <Tiffany> well, and a single test vector
[17:12:21] <Tiffany> the salsa20 paper, anywya
[17:12:34] <Tiffany> I don't remember the layout of the chacha paper by heart
[17:13:56] <Tiffany> I guess this is why everyone is always extremely suspicious of modifications to even very secure ciphers
[17:13:56] <Ilari> On subtle notes: "This leaves a small timing channel, since MAC performance depends to some extent on the size of the data fragment, but it is not believed to be large enough to be exploitable, due to the large block size of existing MACs and the small size of the timing signal." ... TLS 1.2, on Lucky 13.
[17:14:03] <Tiffany> you can remove one thing and break it horribly
[17:26:34] <Ilari> Apparently Chrome is planning to disable insecure TLS downgrade (at least to 1.0).
[17:27:48] <Ilari> Disabled in Firefox a while ago.
[17:41:22] <Ilari> Apparently Chrome does some downgrading to 1.1, most of that is due to IIS AES-GCM bug.
[17:43:21] <Ilari> Basically MS fucked up implementation of AES-GCM originally (it was part of some security fix). There is followup fix that fixes it to work properly, but that isn't as widely deployed as the original.
[17:48:58] *** Quits: brson (brson@moz-cfhap5.mtv2.mozilla.com) (Ping timeout: 121 seconds)
[17:56:33] *** Joins: brson (brson@moz-cfhap5.mtv2.mozilla.com)
[18:18:54] *** Joins: frewsxcv (sid86219@moz-dneii9.brockwell.irccloud.com)
[18:19:36] *** Joins: eddyb_ (eddyb@moz-aiv.t65.25.188.IP)
[18:21:45] *** Quits: brson (brson@moz-cfhap5.mtv2.mozilla.com) (Ping timeout: 121 seconds)
[18:22:32] *** Quits: eddyb (eddyb@moz-vpa.2f0.121.86.IP) (Ping timeout: 121 seconds)
[18:24:33] *** Quits: eddyb_ (eddyb@moz-aiv.t65.25.188.IP) (Ping timeout: 121 seconds)
[18:30:12] *** Joins: eddyb_ (eddyb@moz-1t4sgi.residential.rdsnet.ro)
[18:31:20] *** Quits: frewsxcv (sid86219@moz-dneii9.brockwell.irccloud.com) (Quit: )
[18:42:05] *** eddyb_ is now known as eddyb
[19:03:55] *** Joins: brson (brson@moz-cfhap5.mtv2.mozilla.com)
[19:25:47] *** Joins: Leo` (leo@moz-2f71o3.placeholder.fr)
[19:41:11] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Connection closed)
[19:43:09] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[19:58:49] *** Joins: adu (ajr@moz-vd1fau.fios.verizon.net)
[21:01:26] *** Quits: adu (ajr@moz-vd1fau.fios.verizon.net) (Ping timeout: 121 seconds)
[21:23:36] *** Quits: jesopo (jess@lolnerd.net) (Quit: et nos unum sumus)
[22:28:11] *** Quits: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua) (Ping timeout: 121 seconds)
[23:45:43] *** Quits: brson (brson@moz-cfhap5.mtv2.mozilla.com) (Quit: leaving)
[23:46:12] *** Joins: brson (brson@moz-n5b.14a.129.78.IP)

[00:03:52] *** Quits: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se) (Connection reset by peer)
[00:05:52] *** Joins: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se)
[00:06:23] <tjc> graydon: re-r? https://github.com/catamorphism/rust/commit/c42f1218a0a7b3a5c84502f9cb4b123d65148f4c -- same pull request you approved, but there's enough new code I thought I should ask again
[00:06:57] *** Joins: z0w0 (zack@moz-CF5E62C9.lns4.woo.bigpond.net.au)
[00:08:17] *** Joins: int3_ (int3_@moz-1692740B.subnet-248.amherst.edu)
[00:08:51] <strcat> tjc: https://github.com/mozilla/rust/pull/6230 r?
[00:09:51] <tjc> strcat: what does the .gitattributes thing do? I'm not familiar with that feature of git
[00:10:06] <graydon> tjc: r+ nice work
[00:10:44] <strcat> tjc: it sets default options for file globs
[00:11:09] <strcat> you have to actually use diff --check to see the whitespace errors other than non-unix newlines
[00:11:22] <tjc> strcat: so it requires that you not have the errors? or fixes them for you
[00:11:26] <tjc> either is fine, I'm just curious
[00:11:29] *** Joins: jfredett (jfredett@moz-C01C350.bstnma.fios.verizon.net)
[00:11:32] <strcat> tjc: you can ask it to fix them for you (which I did)
[00:11:37] <tjc> ok, cool
[00:11:41] <tjc> thanks for the explanation
[00:11:42] *** Joins: josh (josh@moz-6FB23C25.hvc.res.rr.com)
[00:11:46] <bjz> doomlord: lerping using vectors/scalars https://gist.github.com/bjz/6c5e7e72fbb43d9c8361
[00:11:46] <strcat> git diff $(git hash-object -t tree /dev/null) HEAD --check is a diff against an empty tree, which has no errors now
[00:12:04] <tjc> r+'ed
[00:12:14] *** Joins: noam (noam@F6B530A7.720527A7.416762B.IP)
[00:12:17] <rfw> hm, i can't get rust to ignore the fact my pattern is refutable even though i'm sure it will match, right?
[00:12:24] <strcat> tjc: can actually set it to automatically fix them or warn on a commit, but hooks don't get cloned :(
[00:12:36] <rfw> (for let-bindings)
[00:12:40] <tjc> rfw: can you paste your code?
[00:12:46] <tjc> strcat: ah, that's unfortunate
[00:12:57] * tjc keeps forgetting to run `make tidy` all the time lately
[00:13:03] <rfw> tjc:     let ast::Exp { exp: ast::SymbolExpression(sym), lineno: _ } = parse_symbol(state);
[00:13:31] <dbaupp> rfw: are there multiple variants of the SymbolExpression enum?
[00:13:35] <rfw> dbaupp: yeah
[00:13:42] <rfw> but i'm 100% sure that parse_symbol is going to give me the correct match
[00:13:49] <bjz> pcwalton nmatsakis: https://gist.github.com/bjz/6c5e7e72fbb43d9c8361
[00:13:56] <dbaupp> rfw: that's the problem. Rustc isn't sure though
[00:13:59] <tjc> we don't have a way to express that in the type system
[00:14:02] <rfw> yeah, i realize that
[00:14:07] <tjc> you can refactor your data structures so this would work, though
[00:14:15] <bjz> pcwalton nmatsakis: I'm guessing you could macrofy those operator RHSs
[00:14:20] <dbaupp> rfw: there are no "refinement types" (yet?) which would allow this
[00:14:30] <rfw> just wondering if there was some kind of "i'm really sure, rustc" thing
[00:14:36] <tjc> nope :-)
[00:14:39] <rfw> heh :(
[00:14:42] <rfw> thanks anyway
[00:16:01] <dbaupp> strcat: for the external iterators stuff, I was thinking that a "length_hint(self) -> Option<uint>" method might be useful
[00:16:14] <dbaupp> strcat: or a "LengthIterator" trait?
[00:16:18] <strcat> tjc: cp .git/hooks/pre-commit.sample .git/hooks/pre-commit
[00:16:27] <strcat> tjc: the default sample runs a whitespace check
[00:16:33] *** Joins: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP)
[00:16:33] *** Quits: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP) (Z:lined (Open Proxy found on your host. Please visit www.blitzed.org/proxy?ip=115.68.131.49 for more information.))
[00:16:33] <strcat> strcat@thinktank i ~/projects/rust whitespace % git commit -a
[00:16:36] <strcat> src/libstd/sha1.rs:25: trailing whitespace.
[00:16:38] <strcat> +use core::str; 
[00:16:50] <strcat> gitattributes just makes that have the right settings
[00:17:22] *** Quits: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se) (Client exited)
[00:17:54] *** Quits: jorendorff (jorendorff@D0304D9F.19E0E257.EF932970.IP) (Quit: jorendorff)
[00:18:56] <strcat> could make it run tidy if you really wanted ;p
[00:19:06] *** Joins: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se)
[00:20:23] <bjz> dbaupp: did you see https://github.com/mozilla/rust/wiki/Lib-fmt that graydon linked to on the ML?
[00:22:07] <dbaupp> bjz: I hadn't seen it before he linked it
[00:22:44] <tjc> strcat: great!
[00:22:45] <bjz> also: https://gist.github.com/bjz/6c5e7e72fbb43d9c8361
[00:23:05] <bjz> dbaupp: dunno if you can think of a way of making it cleaner
[00:23:24] <dbaupp> bjz: What's the InterpolateRHS trait for?
[00:23:43] <dbaupp> (why couldn't that be part of Interpolate? ... I'm probably missing something obvious)
[00:23:55] *** Quits: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com) (Quit: Computer has gone to sleep.)
[00:23:56] <dbaupp> rusti: are you broken still?
[00:23:56] <rusti> foo.rs:5:24: 5:29 error: unknown start of token: 63
[00:23:56] <rusti> foo.rs:5          are you broken still?
[00:23:56] <rusti>                                  ^~~~~
[00:24:04] <bjz> dbaupp: so that you can use either a vec of scalar in the lerp method
[00:24:08] <bjz> *or
[00:24:08] <strcat> dbaupp: better than before now ;p
[00:24:19] <strcat> rusti: fn foo() { loop { } }; foo()
[00:24:23] <bjz> dbaupp: its a pain, but neccsary
[00:24:25] <rusti> timed out after 5 seconds
[00:24:28] <strcat> and it uses less memory...
[00:24:35] <bjz> dbaupp: same for operator overloading
[00:24:36] *** Joins: Nisstyre (wes@moz-FD86289.netflash.net)
[00:24:47] <strcat> it could fit on my armv5 server now
[00:24:49] <bjz> dbaupp: http://smallcultfollowing.com/babysteps/blog/2012/10/04/refining-traits-slash-impls/
[00:25:10] <bjz> dbaupp: at the "What if I want overloading" heading
[00:25:17] <dbaupp> bjz: ah, yes, the one-impl functional-depedency(sort-of) thing
[00:25:34] <bjz> doomlord mentioned it on the numeric bikeshed
[00:25:44] <dbaupp> strcat: nice :D
[00:25:57] <bjz> he wanted a parameter on lerp so he could do stuff like that
[00:26:28] *** Quits: acrichto (acrichto@moz-FE112B96.res.cmu.edu) (Ping timeout)
[00:26:43] <dbaupp> bjz: have you talked to jensnockert about NativeMath/rsqrt and SIMD?
[00:27:15] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Client exited)
[00:27:59] <bjz> dbaupp: I think saxyin (can't spell it) is a better fellow to talk to
[00:28:10] *** Joins: devbug (quassel@moz-E1DE087C.bchsia.telus.net)
[00:28:17] <tjc> sanxiyn
[00:28:19] <tjc> I think
[00:28:35] <Jeaye> sanx<tab> is his name
[00:28:51] <dbaupp> bjz: I was more thinking just his general opinion on it, since he seems to have a pretty good roadmap/idea about what's what :)
[00:29:31] *** aatch|bed is now known as aatch
[00:32:02] *** Joins: acrichto (acrichto@moz-FE112B96.res.cmu.edu)
[00:32:42] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[00:34:30] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[00:36:29] <Jeaye> error: mismatched types: expected `*math::vec3::veci8::Vec3i8` but found `&math::vec3::veci8::Vec3i8` (expected *-ptr but found &-ptr)
[00:36:36] <Jeaye> Shouldn't &foo coerce to *foo?
[00:37:24] <aatch> Jeaye, yep
[00:37:51] <Jeaye>   pub unsafe fn to_ptr(&self) -> *Mat4x4
[00:37:54] <Jeaye>   { self }
[00:37:58] <Jeaye> So that's incorrect? o.O
[00:38:10] <dbaupp> aatch: did you see my mailing list email + the responses?
[00:38:16] <aatch> dbaupp, yep
[00:38:20] <aatch> looks good
[00:38:29] <pcwalton> Jeaye: coercions don't happen in return values all the time, it's a bug
[00:38:31] <pcwalton> I think there's a bug on it
[00:38:37] <Jeaye> darnit
[00:38:49] <Jeaye> How can I work around, pcwalton?
[00:38:54] <pcwalton> ptr::to_unsafe_ptr will work
[00:38:59] *** Quits: acrichto (acrichto@moz-FE112B96.res.cmu.edu) (Ping timeout)
[00:39:10] <strcat> let x = y; x
[00:39:12] <strcat> ;p
[00:39:15] <Jeaye> mmk, thanks
[00:39:29] <aatch> Hey, how do I match a struct-like variant and ignore all the fields? I though {*} would work
[00:39:32] <aatch> thought*
[00:39:36] <pcwalton> aatch: { _ }
[00:39:39] <strcat> rusti: fn foo(x: &int) { x } -> *int; foo(5)
[00:39:40] <rusti> foo.rs:5:31: 5:33 error: unexpected token: `->`
[00:39:40] <rusti> foo.rs:5          fn foo(x: &int) { x } -> *int; foo(5)
[00:39:40] <rusti>                                         ^~
[00:39:53] <strcat> rusti: fn foo(x: &int) -> *int { x }; foo(&5)
[00:39:54] <rusti> more than 5 lines of output, pastebinned: http://sprunge.us/BVjV
[00:40:05] <aatch> pcwalton, thanks
[00:40:06] <strcat> rusti: fn foo(x: &int) -> *int { let y = x; y }; foo(&5)
[00:40:07] <rusti> more than 5 lines of output, pastebinned: http://sprunge.us/PWLF
[00:40:13] <strcat> heh
[00:40:22] <strcat> needs an explicit type  :(
[00:40:24] *** Quits: threecreepio (jdp@moz-DB2D70E9.cust.bredbandsbolaget.se) (Quit: threecreepio)
[00:40:31] <dbaupp> pcwalton: wasn't that suggested to be changed at some point? (Is this still wanted?)
[00:40:41] <pcwalton> dbaupp: I don't recall any suggestions to change it
[00:41:05] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[00:41:05] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/iXayCw
[00:41:05] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[00:41:09] <dbaupp> pcwalton: ah, ok... I'm probably misremembering
[00:42:33] <dbaupp> rusti: fn foo(x: &int) -> *int { core::util::id::<*int>(x) } foo(&5)
[00:42:34] <rusti> 36593424
[00:43:21] *** Joins: catpig (catpig@moz-930C30AC.dip0.t-ipconnect.de)
[00:44:07] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[00:44:07] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/I_qkcw
[00:44:07] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[00:44:09] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[00:44:09] <ghrust> 01[13rust01] 15bors pushed 5 new commits to 06auto: 02http://git.io/S0I_uQ
[00:44:09] <ghrust> 13rust/06auto 144d4cabf 15Tim Chevalier: rustpkg: Implement install command...
[00:44:09] <ghrust> 13rust/06auto 14376a552 15Tim Chevalier: tidy
[00:44:09] <ghrust> 13rust/06auto 14c42f121 15Tim Chevalier: rustpkg: Handle sysroot more correctly...
[00:44:10] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[00:45:56] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[00:46:00] <Jeaye> pcwalton: I put up a pull request for the Mac building fix on rust-opengles.
[00:46:06] <dbaupp> aatch: does your parser handle '%%'?
[00:46:12] <aatch> dbaupp, yep
[00:46:16] <pcwalton> Jeaye: checking
[00:46:17] <aatch> special cased
[00:47:29] <pcwalton> Jeaye: merged, thanks
[00:47:35] <Jeaye> Cheers
[00:48:15] *** Quits: bnicholson (bnicholson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[00:48:22] *** Quits: bnicholson_ (bnicholson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[00:48:30] *** Quits: bnicholson__ (bnicholson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[00:49:14] *** Joins: steven_is_false (quassel@moz-144077DE.bchsia.telus.net)
[00:51:22] <dbaupp> aatch: how does it work? If I'm trying to parse "foo %abc" do I split it up at the % and call Parser::new("abc", {desc}) and then .next_item(), or just pass it the whole string?
[00:51:37] <aatch> dbaupp, pass the whole string
[00:52:21] <dbaupp> aatch: ok, tahnks
[00:52:41] <cmr> So self-by-value seems to be pretty buggy. But what does self-by-reference imply? Which method does foo.bar() call, does it actually depend onif foo is a &Foo, ~Foo, etc?
[00:54:42] <aatch> You get either a Place(Holder), which is a placeholder, a Raw(~str) which is just whatever is in the string, an Error{} which is an error, or End, which is the end of the string
[00:55:02] <aatch> I'm gonna change Raw(~str) to Raw(&str) though
[00:55:45] *** Quits: josh (josh@moz-6FB23C25.hvc.res.rr.com) (Quit: josh)
[00:56:15] * aatch can't remember why he didn't do that before
[00:58:24] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[00:59:32] <dbaupp> aatch: I literally was just about to suggest that change :)
[00:59:47] <dbaupp> aatch: also, "%%a" doesn't work
[01:00:07] <aatch> dbaupp, ok, I'll add a test and fix that
[01:00:56] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[01:01:07] *** Quits: graydon (graydon@3853DDD.39EEDBB3.D758B1AA.IP) (Quit: Leaving.)
[01:02:28] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[01:02:42] <aatch> I'm probably not advancing the position. so it finds the second '%', returns "%" but doesn't skip ahead, so the next next_item() sees '%' again
[01:02:49] <dbaupp> aatch: interestingly, it looks like fmt! supports printf's %n$*f syntax
[01:03:27] <dbaupp> aatch: hmm, actually. it just parses it, it doesn't actually work
[01:03:28] <aatch> dbaupp, I know
[01:06:29] <steven_is_false> Does anyone know how servo does OpenGL? I'm reworking my 3d engine, and one of the things I'm thinking of doing is having my rendering thread in a separate thread from the SDL thread. The rendering thread would render everything, and the SDL thread would simpy copy it to the screen.
[01:06:31] <cmr> When would core::bool::all_values be useful?
[01:07:08] *** Joins: wuwei`lab (wuwei@1A513F49.818D7924.FAA9ED67.IP)
[01:07:24] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[01:08:06] *** Joins: bnicholson (bnicholson@moz-E98974C1.hsd1.ca.comcast.net)
[01:08:27] <dbaupp> cmr: tests? it does seem strange
[01:08:40] *** Joins: bnicholson_ (bnicholson@moz-E98974C1.hsd1.ca.comcast.net)
[01:08:47] *** Joins: bnicholson__ (bnicholson@moz-E98974C1.hsd1.ca.comcast.net)
[01:09:10] <cmr> The comments in bool.rs mention "the logic", which soundsweirdly abstract
[01:09:24] <cmr> well, in the docs too
[01:09:31] <cmr> "Function eq - true if truth values a and b are indistinguishable in the logic"
[01:10:22] *** Quits: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se) (Client exited)
[01:11:05] *** Joins: MrFahrenheit (RageOfThou@moz-CF7139ED.dynamic.telemach.ba)
[01:12:37] <Jeaye> bjz: Mouse capturing on Mac doesn't seem to work.
[01:13:00] <bjz> :(
[01:13:04] <Jeaye> I'm capturing the mouse, but on 10.8.3, the mouse is flying around my desktops as I move around.
[01:13:11] <bjz> yikes
[01:13:24] <bjz> so, this is rust only?
[01:13:44] <bjz> dreda has been doing work on OSX I think
[01:13:59] <bjz> something might have broken
[01:14:03] <Jeaye> Not sure. It's something I just noticed when showing some people q^3. :(
[01:14:40] <bjz> Jeaye: https://github.com/glfw/glfw/commits/master
[01:14:57] <bjz> Jeaye: https://github.com/glfw/glfw/commit/aa3364a73e4a4dab6ae387f8e85581cd694f07a3 ?
[01:15:27] <bjz> looks like its x11 though
[01:16:14] <bjz> are you on the most recent glfw?
[01:16:35] <bjz> btw, dreda is moving to the glfw/glfw repo
[01:17:05] <bjz> btw, there's #glfw on freenode
[01:17:21] <bjz> dreda hangs out there if you have any glfw-specific stuff
[01:17:32] <bjz> she's usually really quick with fixes
[01:18:10] *** Quits: bent (chatzilla@moz-932324BF.hsd1.ca.comcast.net) (Quit: ChatZilla 0.9.90-rdmsoft [XULRunner 18.0.2/20130201065344])
[01:19:49] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[01:19:49] *** ChanServ sets mode: +o dherman
[01:20:57] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[01:21:40] *** Joins: philix (philix@moz-451739D3.user.veloxzone.com.br)
[01:21:43] <strcat> cmr: remnants of type state afaik
[01:25:27] <xenocons> bjz: on the topic of HM http://www.laserpirate.com/tinyml.html
[01:25:48] <xenocons> well, not that hm is in topic now... so maybe offtopic is better
[01:26:49] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[01:28:32] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[01:30:16] *** Joins: dymk (dymk@44EEE21C.A6E21E6E.5E500FC7.IP)
[01:35:16] <aatch> hmm, is there any reason why rust would have difficulty differentiation between a struct variant and a variant containing a struct in an enum?
[01:35:23] <aatch> differentiating*
[01:36:24] *** Joins: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net)
[01:38:50] <dbaupp> aatch: https://gist.github.com/huonw/5b139340f0ec9048ab0d#file-gistfile1-txt
[01:38:55] <dbaupp> aatch: what do you mean?
[01:39:31] <dbaupp> aatch: (I really like your parser!)
[01:39:41] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[01:40:03] <aatch> Oh, in one of my tests, I'm testing for fail cases
[01:40:39] <aatch> For some reason Place(Holder) is kinda-matching Error {_}
[01:40:39] <pcwalton> hooray, a rustc that knows nothing about mutable fields except how to parse them is bootstrapping
[01:41:19] <dbaupp> aatch: kinda-matching?
[01:41:29] <aatch> If i try to get the fields, then it just fails silently when running
[01:41:40] *** Joins: acrichto (acrichto@moz-FE112B96.res.cmu.edu)
[01:42:07] <aatch> so Error {_} matches the wrong thing, and Error{msg:msg, pos:_} => debug!(msg)
[01:42:16] <aatch> just causes it fail silently
[01:42:19] <aatch> at runtime
[01:42:27] <dbaupp> aatch: :O
[01:42:42] <aatch> But, if I put in Place(holder) explicitly, it works
[01:43:28] *** Quits: acrichto (acrichto@moz-FE112B96.res.cmu.edu) (Ping timeout)
[01:44:40] <Jeaye> If a module 'use's an enum, how can it access it values?
[01:44:57] <Jeaye> I'd like to say Enum::Val, but that's not supported.
[01:45:16] <aatch> module::Value
[01:45:23] <aatch> they aren't namespaced
[01:45:44] <Jeaye> Right... what if it's not used as a module?
[01:46:06] <aatch> Jeaye, what do you mean?
[01:46:14] <dbaupp> aatch: re that gist above, the ./printf is currently just generating strings, but it wouldn't be too hard to get it to generate an ast instead
[01:46:28] <dbaupp> Jeaye: you have to use the variants also
[01:46:30] <aatch> dbaupp, that's the point :D
[01:46:31] <Jeaye> `use foo::Enum; do_thin_with(Val); // where Val is in Enum`
[01:46:44] <dbaupp> aatch: of course :D
[01:47:00] <ssbr_> Mmf, how do I rebuild rust after a git pull? git pull is saying I pulled in lots of changes, but "make" exits immediately with "Nothing to be done for `all'"
[01:47:03] <dbaupp> Jeaye: use foo::{Enum, Val}; ...
[01:47:05] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[01:47:06] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/S0I_uQ
[01:47:06] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[01:47:17] <Jeaye> dbaupp: Awww. I was hoping that'd not be required.
[01:47:27] <dbaupp> ssbr_: have you checked out the latest changes?
[01:47:35] <Jeaye> One has to use the entire enum and individually each of its values? :(
[01:47:37] <dbaupp> Jeaye: you can also do `use foo::Enum; use foo;`
[01:47:46] <ssbr_> dbaupp: oh, you have to do an additional thing after pull?
[01:47:51] <dbaupp> (or `use foo::*;`)
[01:48:00] <Jeaye> Yeah.
[01:48:12] <dbaupp> ssbr_: I don't think so, but it would explain your issue... I was just guessing
[01:48:20] <ssbr_> "git checkout" doesn't do anything, make still does nothing
[01:48:20] <dbaupp> ssbr_: what does `git status` say?
[01:48:39] <ssbr_> dbaupp: #On branch master
[01:48:45] <ssbr_> Nothing to commit (working directory clean)
[01:48:49] <aatch> Ahh..
[01:48:54] <dbaupp> ssbr_: `git checkout incoming`
[01:48:59] <aatch> Try git checkout incoming
[01:49:05] <ssbr_> What's master for?
[01:49:09] <dbaupp> (all the development happens on incoming, not master)
[01:49:21] <aatch> master is supposed to be mostly-stable
[01:49:26] <aatch> (I think)
[01:49:31] <aatch> Things keep changing.
[01:49:32] <kalenedrael> so in this one rust program, pthread_create is still returning EINVAL at runtime
[01:49:34] <ssbr_> alright, woo, git checkout incoming and git pull and now make is doing things
[01:49:36] <dbaupp> ssbr_: it was the stable branch when bors wasn't around to keep incoming mostly stable
[01:49:46] <ssbr_> dbaupp: confusing
[01:50:04] <dbaupp> ssbr_: so now there is (possibly) a plan to remove incoming and have bors merge straight into master
[01:50:05] <kalenedrael> not sure why, I checked the arguments to pthread_create and they are the same as in the corresponding call in a different program that runs fine
[01:50:06] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[01:50:06] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/CBJ6eQ
[01:50:06] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[01:50:07] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[01:50:07] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/Ho5B4A
[01:50:07] <ghrust> 13rust/06auto 14832f7b7 15Luqman Aden: librustc: Add argument to allow choosing "linker"
[01:50:07] <ghrust> 13rust/06auto 145bf7e8b 15bors: auto merge of #6198 : luqmana/rust/linker-arg, r=graydon
[01:50:08] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[01:50:22] <dbaupp> kalenedrael: a different rust program?
[01:50:43] <aatch> Hurrah '%  ' is no longer valid if ' ' is a flag
[01:50:59] *** Quits: Jesin (Jessin_@moz-A03A364F.cc.lehigh.edu) (Ping timeout)
[01:51:03] <kalenedrael> it appears to break only if I link with this external library
[01:51:03] <aatch> dbaupp, btw, would not supporting flag repetition be a good idea?
[01:51:16] <dbaupp> aatch: i.e. %--f is not valid?
[01:51:22] <aatch> dbaupp, yep
[01:51:32] <dbaupp> aatch: have it configurable?
[01:51:35] <dbaupp> I don't know
[01:51:42] <aatch> I need to check for ' ', but right now I just check for all
[01:52:43] <dbaupp> aatch: also, if we are going to do something with `!' it would seem convenient to have it appear straight after the % always?
[01:52:51] <dbaupp> aatch: i.e. it's not a normal flag
[01:53:39] <aatch> dbaupp, the flags are added in order, so we could just check for flags[0] == '!'
[01:54:02] <aatch> It would be much easier than having some start-flags thing
[01:54:19] <dbaupp> aatch: what about %!{0}s?
[01:54:55] <aatch> Ah, true.
[01:55:19] <aatch> I could make parsing {0} part of the flag parsing step
[01:55:35] <aatch> so you can have -{0}#
[01:56:09] <aatch> How about a single special_flag field
[01:56:22] <aatch> so it's super-limited
[01:56:28] <aatch> and therefore not confusing
[01:56:41] <dbaupp> aatch: yes, that is good
[01:57:02] <kalenedrael> it must be affecting the stack size limit somehow
[01:57:04] *** Quits: jack (jack@EF36212C.8FA609AD.840029BC.IP) (Ping timeout)
[01:57:21] *** Quits: Mathnerd626 (quassel@moz-195E87F.rh.uchicago.edu) (Ping timeout)
[01:57:24] *** Joins: Mathnerd626 (quassel@moz-195E87F.rh.uchicago.edu)
[01:57:39] <dbaupp> kalenedrael: how are you importing pthread_create?
[01:57:41] <aatch> kalenedrael, yeah, threads have a weird effect on rust
[01:58:12] <kalenedrael> no no, these threads are created by rust's runtime
[01:58:24] <aatch> oh.
[01:58:31] <aatch> Is there an issue about that?
[01:58:55] <dbaupp> also, you can try running the program with RUST_MIN_STACK=8000000
[01:59:46] <kalenedrael> still EINVAL
[02:00:08] <dbaupp> kalenedrael: are you actually calling `pthread_create'?
[02:00:19] <dbaupp> I didn't know that rust exposed the pthread api?
[02:00:22] <kalenedrael> I am not doing any such thing from rust, the rust runtime is
[02:00:53] <kalenedrael> let me try to isolate what causes the issue
[02:01:08] <dbaupp> kalenedrael: oh, so the pthread_create in the runtime is failing?
[02:02:19] <kalenedrael> yes
[02:03:11] *** Quits: steven_is_false (quassel@moz-144077DE.bchsia.telus.net) (Client exited)
[02:05:50] *** Joins: Thad (chatzilla@moz-C35F90AE.tx.res.rr.com)
[02:06:07] <kalenedrael> ok, it appears linking with this external library causes the issue
[02:07:00] <aatch> kalenedrael, does it export pthread_create?
[02:07:01] *** Joins: Jesin (Jessin_@moz-A03A364F.cc.lehigh.edu)
[02:07:03] <xenocons> http://codepad.org/w6vyJs0C started toying with my rust fuzzer
[02:07:07] *** Quits: SimonSapin (simon@moz-C4A83ED9.net-89-2-126.rev.numericable.fr) (Ping timeout)
[02:07:13] <kalenedrael> no
[02:07:28] <kalenedrael> it ostensibly has nothing to do with pthread_create (libigraph)
[02:07:30] <aatch> weird
[02:07:51] <kalenedrael> also, the second call to pthread_create is failing, not the first
[02:08:11] <kalenedrael> in the runtime
[02:08:14] * aatch is confused
[02:09:02] <kalenedrael> I built rust with optimizations off and looked at the arguments to pthread_create in gdb
[02:09:40] <kalenedrael> it appears the first one is being created with a stack size of 102400, which succeeds
[02:10:04] <kalenedrael> the second uses a size of 20480, which fails. this is the only difference I saw
[02:11:27] <xenocons> can lambda have a space inbetween the pipe and the function? | x |
[02:11:38] <xenocons> or must it be |x|
[02:11:42] <aatch> xenocons, it can
[02:11:47] <xenocons> ahh awesome
[02:11:54] <aatch> rust is pretty white-space neutral
[02:12:15] *** Joins: Erik (Erik-S@moz-252DBA2.hsd1.co.comcast.net)
[02:12:15] <aatch> rusti: 50 . to_str ( )
[02:12:17] <rusti> more than 5 lines of output, pastebinned: http://sprunge.us/QjYJ
[02:12:30] <aatch> rusti: 50u . to_str ( )
[02:12:31] <rusti> ~"50"
[02:13:19] <aatch> the tokenizer uses whitespace to seperate tokens, that's it.
[02:15:32] <kalenedrael> this is bizarre
[02:15:34] <dbaupp> xenocons: nice
[02:15:35] *** Quits: pcwalton (pcwalton@2557E599.66715431.D25A875A.IP) (Quit: pcwalton)
[02:17:15] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Ping timeout)
[02:17:58] <kalenedrael> http://pastebin.mozilla.org/2373315
[02:18:51] <dbaupp> kalenedrael: does setting RUST_MIN_STACK help at all?
[02:19:03] <kalenedrael> e.g. RUST_MIN_STACK=8000000 ./foo?
[02:19:12] *** Joins: mortisha (Mibbit@moz-91DB7BBE.cable.virginmedia.com)
[02:19:18] <mortisha> Hey
[02:19:35] <dbaupp> kalenedrael: yeah
[02:19:36] <kalenedrael> that does not help
[02:19:48] <dbaupp> (it might be spelt RUST_STACK_MIN, I can never remember)
[02:19:56] <mortisha> Anyone have an example of some code that uses hashmaps/linearmaps?
[02:19:59] <dbaupp> mortisha: hi!
[02:20:14] <dbaupp> mortisha: are you using 0.6?
[02:20:27] <kalenedrael> that also does not change anything
[02:20:28] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[02:20:31] <mortisha> dbaupp: yep
[02:20:57] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[02:21:07] *** Quits: Erik (Erik-S@moz-252DBA2.hsd1.co.comcast.net) (Ping timeout)
[02:21:07] *** Quits: aatch (aatch@moz-2BB0AC01.cable.telstraclear.net) (Ping timeout)
[02:21:10] <dbaupp> kalenedrael: :( ... that's all the help I can offer
[02:22:23] <dbaupp> mortisha: https://github.com/search?l=rust&q=linearmap&ref=cmdform&type=Code (maybe?)
[02:22:25] <kalenedrael> is it possible that linking with this library changes ulimits...?
[02:22:44] <kalenedrael> that would make limited sense anyway as the first call succeeds with a much larger stack size
[02:22:46] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[02:22:56] <mortisha> dbaupp: thank you very much, never knew you could use github that way
[02:23:25] <kalenedrael> I wish this said more than 'hur dur EINVAL'
[02:23:38] <dbaupp> mortisha: this looks like a reasonable example https://github.com/ericfode/draino/blob/f93de476e65a5a405a57194f3e49f939bef3a8ea/src/response.rs
[02:23:59] *** Joins: aatch (aatch@moz-2BB0AC01.cable.telstraclear.net)
[02:24:25] <mortisha> dbaupp: has hashmap supported in 0.6? or should I use linearmaps as my goto key to value map type?
[02:24:41] <aatch> mortisha, HashMap
[02:24:44] <dbaupp> mortisha: hashmap = linearmap, the only difference is the name
[02:24:58] <dbaupp> (and the name change happened after 0.6)
[02:25:00] <kalenedrael> hashmap is just hashmap::linear::LinearMap, as far as I know
[02:25:07] <strcat> LinearMap was renamed to HashMap since 0.6
[02:25:08] <mortisha> ah, cheers guys, explains a lot :P
[02:29:54] *** Quits: EXetoC (ex@moz-2DBEB1E4.customer.t3.se) (Quit: WeeChat 0.4.0)
[02:33:43] *** Quits: Jesse (jruderman@2557E599.66715431.D25A875A.IP) (Quit: Jesse)
[02:35:50] *** Joins: acrichto (acrichto@moz-FE112B96.res.cmu.edu)
[02:36:30] *** Quits: devbug (quassel@moz-E1DE087C.bchsia.telus.net) (Ping timeout)
[02:37:37] *** Quits: acrichto (acrichto@moz-FE112B96.res.cmu.edu) (Ping timeout)
[02:40:56] <aatch> dbaupp, https://github.com/Aatch/rust-fmt
[02:41:07] <aatch> So I don't have to copy-paste to gist
[02:41:50] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[02:42:59] <dbaupp> aatch: forked :D
[02:43:22] <aatch> cool
[02:43:44] <dymk> oh this is strange, when linking a module into another via extern mod, the program complains that it can't find core-0.6.dll, however I've got core-0.7-pre.dll instead. Both crates were compiled with 0.7 too. 
[02:43:50] <aatch> I've done quite a bit of refactoring, so it should be quite a bit cleaner
[02:44:00] * dbaupp looks
[02:45:22] <dbaupp> aatch: I like the string slices
[02:45:32] <dbaupp> dymk: is the compiler also compiled with 0.7?
[02:46:03] <dymk> it's compiled from the head of the incoming branch
[02:46:20] <dymk> actually, that could be the problem, I've had trouble getting rust to build all the way to stage3
[02:46:32] <dymk> however it still installs 0.7 pre files
[02:46:46] <dbaupp> dymk: in theory, you should only need stage2
[02:47:00] <dbaupp> (or actually, even just stage 1 works for me)
[02:47:05] <dymk> I see
[02:47:40] *** Quits: bblum (bblum@moz-2B41ACB5.andrew.cmu.edu) (Ping timeout)
[02:47:42] <dymk> stage1 folder is empty
[02:47:45] <dymk> as is stage3
[02:47:49] *** Quits: rntz (rntz@moz-C76A8D96.sp.cs.cmu.edu) (Ping timeout)
[02:47:58] *** Quits: rpearl (rpearl@moz-2B41ACB5.andrew.cmu.edu) (Ping timeout)
[02:48:08] <dbaupp> aatch: the do self.expect(blah) { blah } pattern is pretty cool :)
[02:48:18] <dbaupp> aatch: it's almost Haskell :D
[02:48:34] <dbaupp> dymk: no idea, sorry :(
[02:48:44] *** Quits: zz_kimundi (kimundi@moz-7EFEABB3.dip0.t-ipconnect.de) (Ping timeout)
[02:48:52] <dymk> oh that's okay, I've been wrestling with it for the past few days now
[02:49:02] <aatch> dbaupp, well I found that I was doing if self.eat(c) { stuff.. } else { error } a lot
[02:49:32] <aatch> Actually, not eat(c), just cur() == c
[02:49:39] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Quit: Leaving)
[02:50:07] <aatch> And 'stuff' was just "wrap the result in Ok and return"
[02:50:57] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[02:51:22] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Connection reset by peer)
[02:51:27] <dbaupp> aatch: so you abstracted it out and made the code amazing :)
[02:51:43] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[02:51:47] * aatch blushes
[02:52:29] *** Joins: zz_kimundi (kimundi@moz-1B78C5AF.dip0.t-ipconnect.de)
[02:52:36] <dymk> it's almost ruby-ish
[02:52:45] <dymk> looks awesome
[02:52:49] *** zz_kimundi is now known as kimundi
[02:53:27] <dbaupp> aatch: it seems like a 'munch number (&str) -> Option<int>` that parsed as much of the string as a number as possible could be a useful function?
[02:53:44] <dbaupp> (where `int' = any number)
[02:53:46] <aatch> dbaupp, probably
[02:53:55] *** Joins: rntz (rntz@moz-C76A8D96.sp.cs.cmu.edu)
[02:54:58] <aatch> Though the current implementation would probably stay here and I'd make a more general one based on it.
[02:55:49] *** Joins: bblum (bblum@moz-2B41ACB5.andrew.cmu.edu)
[02:56:05] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[02:56:05] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/Ho5B4A
[02:56:05] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[02:56:06] <aatch> But a general one would probably more more like fn<'a, T:Integer>(&'str) -> (&'a str, Option<T>)
[02:56:08] *** Joins: rpearl (rpearl@moz-2B41ACB5.andrew.cmu.edu)
[02:57:34] <dbaupp> aatch: yeah, or just (uint, Option<T>), since string slicing is (slightly) expensive
[02:57:43] <aatch> dbaupp, that works too
[02:58:25] <aatch> with that kind of method though, you could do PHP-style number conversion
[02:58:49] <aatch> in PHP (int)"99 bottle of beer" == 99
[02:59:07] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[02:59:07] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/Upp9zA
[02:59:07] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[03:00:20] <dbaupp> aatch: well, you'd have to call the prefix parser explicitly
[03:00:30] <aatch> dbaupp, well yeah
[03:01:07] <dbaupp> (made a note of this on the number<->str issue)
[03:01:44] <aatch> I do like how `atoi` in rust is 100% safe in 10 lines
[03:02:29] <dbaupp> aatch: yeah, using mutate_default works well
[03:02:36] <dbaupp> (i didn't even know they existed!)
[03:02:48] <aatch> I found that and was like "OMG! THATS EXACTLY WHAT I NEED!"
[03:02:57] * strcat added that silly function
[03:03:03] <dbaupp> aatch: Also, why is '%  f' disallowed?
[03:03:05] * aatch hugs strcat
[03:03:11] <dbaupp> strcat: you're basically a superhero
[03:03:13] <strcat> ended up mostly using .each_mut instead of mutate
[03:03:21] <strcat> dbaupp: hardly ;p
[03:03:26] <dbaupp> aatch: (that has two spaces)
[03:03:41] <aatch> dbaupp, because it makes no sense to me
[03:03:43] <strcat> I added those 2 because I thought I needed them and ended up not using them once :(
[03:04:28] <aatch> I'd rather have an error than it just happily eat all the whitespace
[03:04:40] <dbaupp> aatch: is it worth the special case?
[03:05:31] <dbaupp> (rather than either allowing it, or just making all flags only legal once, as you suggested before)
[03:05:38] <aatch> dbaupp, It's not really special-cased. Currently it just skips to Specifiers if it hits a repeated flag
[03:05:53] <aatch> Then the special case is not allowing ' ' as a conversion specifier
[03:06:19] <dbaupp> aatch: ah
[03:06:22] <dbaupp> ok
[03:06:44] <aatch> This means you can have flags and specifiers overlap, if you know what you are doing
[03:07:05] <dbaupp> (is there a reason for that? fmt!("% ", 10) == "          ", isn't entirely stupid, except for the obvious)
[03:07:49] <dbaupp> aatch: so %-+-+ would have specifier '+'
[03:07:58] <dbaupp> ?
[03:08:00] <aatch> dbaupp, yep
[03:08:08] <aatch> No
[03:08:11] <aatch> '-'
[03:08:17] <dbaupp> oh
[03:08:22] <aatch> it doesn't skip the repeated character
[03:08:33] <dbaupp> yeah
[03:08:39] <aatch> '%ll' => flags: ~['l'] specifier: 'l'
[03:09:18] <dbaupp> aatch: doesn't that stop '%llu'?
[03:09:31] <dbaupp> (assuming we want that, but it's probably not necessary)
[03:09:41] <aatch> dbaupp, yep. But that only exists because standard printf has a length field
[03:09:45] <aatch> which we do not
[03:09:59] <dbaupp> correct, strong type system == best
[03:10:06] *** Joins: acrichto (acrichto@moz-FE112B96.res.cmu.edu)
[03:10:06] <strcat> dbaupp: we talked about this before and I don't think we won't any specifiers specific to types
[03:10:18] <strcat> nothing like %d for int, don't need it
[03:10:26] <dbaupp> strcat: i.e. the ll/h/l whatever?
[03:10:32] <strcat> modern format strings use format classes
[03:10:38] <strcat> if they all get printed the same way, you only need %s
[03:10:52] <ssbr_> Is a rebuild of rust ever faster than a fresh build, or is it always the same speed?
[03:10:55] <dbaupp> strcat: did you my mailing list email? something along those lines?
[03:11:00] <ssbr_> does it just depend on what's changed?
[03:11:09] <strcat> dbaupp: I don't think I saw it
[03:11:22] <strcat> but just format classes that map to traits
[03:11:29] <dbaupp> strcat: 
[03:11:31] <dbaupp> https://mail.mozilla.org/pipermail/rust-dev/2013-May/003999.html
[03:11:35] <strcat> and they need to use Writers, no string allocations unless you're creating a string
[03:11:41] <aatch> strcat, that's pretty much the entire proposal
[03:11:44] <dbaupp> strcat: yes, basically exactly that
[03:12:27] <strcat> dbaupp: well they do need to be given meanings to be actually be useful for writing generic code
[03:12:55] <dbaupp> aatch: you could add a link to rust-fmt in the top of the gist?
[03:12:59] <dbaupp> strcat: I don't understand?
[03:13:07] <aatch> dbaupp, lol, just doing that now
[03:13:22] <strcat> dbaupp: if you give them an arbitrary name/meaning you can't write generic code with them
[03:13:26] <strcat> because they have no meaning...
[03:13:51] <dbaupp> strcat: presumably %c would (by convention) mean character-like, and %d/whatever would mean integer-like
[03:13:59] <dbaupp> (is that would you mean?)
[03:14:02] <dbaupp> *what
[03:14:03] <strcat> so wouldn't the trait be named that way?
[03:14:21] <dbaupp> strcat: yes, I guess so
[03:14:25] <strcat> %c doesn't need to exist unless there are specific formatters for characters
[03:14:42] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[03:14:42] <dbaupp> strcat: I don't think the proposal was focused on the names so much as the semantics
[03:14:44] <strcat> if there aren't specific formatters, you only need %s
[03:14:46] *** Joins: devbug (quassel@moz-E1DE087C.bchsia.telus.net)
[03:15:04] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[03:15:34] <dbaupp> strcat: so you mean anything that's char-like would just implement the '%s' formatter
[03:15:49] <strcat> sure
[03:15:59] <strcat> %s means print as a string
[03:16:06] <dbaupp> (wouldn't this lose some compile time power?)
[03:16:07] <strcat> no need for other format classes if they don't *do* anything
[03:16:10] <strcat> dbaupp: no
[03:16:23] <dbaupp> oh wait
[03:16:35] <strcat> it infers the type from the argument
[03:16:41] <strcat> you only need type-less placeholders
[03:16:46] <dbaupp> there's no modifiers for %c, so there's not point in having it separate?
[03:16:52] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[03:16:55] <strcat> dbaupp: right
[03:16:58] <strcat> fmt!("{} {} {}", "foo", 5, 2)
[03:17:01] <dbaupp> is that what you mean?
[03:17:03] <strcat> yes
[03:17:15] <dbaupp> ok, I agree
[03:17:31] <strcat> python's new format strings don't have the format classes at all
[03:17:41] <dbaupp> how would that work with width/precision etc?
[03:18:05] <strcat> dbaupp: http://docs.python.org/3.3/library/string.html#format-string-syntax
[03:18:05] <dbaupp> fmt!("{10.3}", 1.123)?
[03:18:20] <aatch> Given that I am calling them "conversion" specifiers. It still makes sense.
[03:18:45] <aatch> So '%s' would call the default string one, but then you could have '%x' for hex etc.
[03:18:57] *** Quits: seth (seth@moz-BE33DA21.fw1.sfo1.mozilla.net) (Input/output error)
[03:19:05] <strcat> aatch: yeah
[03:19:13] <dbaupp> strcat: and shouldn't fmt!("{10.3}", "string") fail?
[03:19:26] <strcat> dbaupp: yes, it wouldn't find an implementation
[03:19:55] <strcat> anyway it can keep %, that part doesn't matter
[03:20:12] <strcat> %? -> reflection based structure printing, %s -> print as string
[03:20:21] <dbaupp> strcat: so fmt! would distinguish which method/trait to use by the "contents" of the {}/% without any specifier?
[03:20:37] <strcat> if you wanted to do it that way, yes
[03:20:45] <strcat> I don't care about that part
[03:20:52] <strcat> but every letter you add to the DSL needs to have a meaning
[03:20:58] <dbaupp> strcat: I feel like we're in complete agreement :)
[03:21:00] <strcat> and there should be a good use case for it
[03:21:12] <strcat> dbaupp: yes ;p
[03:23:06] <dbaupp> strcat: fwiw 
[03:23:17] <dbaupp> "{:f}".format(1.123)
[03:23:19] <dbaupp> still works in python
[03:23:31] <aatch> Is that not essentially what we had before? With the specifiers and similar just being passed to the format trait?
[03:23:49] <strcat> aatch: why does %d exist?
[03:23:53] <strcat> it prints the same way as %s
[03:24:00] <aatch> strcat, I agree on that
[03:24:05] <xenocons> int -> IO ()
[03:24:09] <xenocons> instead of string -> IO () ?
[03:24:24] <dymk> one must put "use" declarations before "mod", correct?
[03:24:24] *** Quits: solancile (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net) (Ping timeout)
[03:24:30] <aatch> dymk, yep
[03:24:38] <dymk> and the same applies for extern mod too?
[03:24:49] <dbaupp> aatch: fmt! still does the distinguishing of the specifiers in strcat's suggestion
[03:24:52] <aatch> dymk, extern mod before use, yep
[03:25:29] <dymk> you mean use before extern mod
[03:25:35] *** Joins: catpigger (catpig@moz-269D9D6D.dip0.t-ipconnect.de)
[03:25:38] <dymk> however, compiler error then :/
[03:25:39] <dymk> both ways
[03:25:49] <dbaupp> aatch: I think (correct me if i'm wrong) strcat is just saying <trait proposal> - most of the specifiers
[03:25:59] <dbaupp> dymk: "extern mod; use; mod;"
[03:26:13] <aatch> dbaupp, ah fair enough
[03:26:23] *** Quits: acrichto (acrichto@moz-FE112B96.res.cmu.edu) (Ping timeout)
[03:26:28] <strcat> well I think we should make %s use a writer + work generically
[03:26:34] <strcat> remove all the other ones that aren't used
[03:27:00] *** Quits: catpig (catpig@moz-930C30AC.dip0.t-ipconnect.de) (Ping timeout)
[03:27:08] <mortisha> Could someone help explain how to get this get_or_default to work and explain why: http://pastebin.com/wN8TLiqs
[03:27:11] <strcat> and then add new specifiers based on a need for them
[03:27:26] <dbaupp> maybe keep %d (or similar) and convert it to take a base argument too, instead of %x/%o/%t
[03:27:37] <xenocons> %t ?
[03:27:42] <aatch> binary
[03:27:46] <xenocons> ah
[03:27:57] <xenocons> interesting choice, was %b taken ? hehe
[03:28:03] <dbaupp> xenocons: bool
[03:28:14] <mortisha> ... I think that it's something to do with &0 getting destroyed once it's finished, so fmt can't use it, but I don't know a way around it
[03:28:41] <dbaupp> mortisha: if you do let x = &0; fmt!(... .get_or_default(x)) it should work
[03:28:53] <mortisha> ah, cheers
[03:28:56] <dbaupp> (that reasoning is exactly correct)
[03:29:02] <strcat> lots of those methods shouldn't exist
[03:29:22] <xenocons> hm
[03:29:44] <strcat> get/get_or_default/while_some are bad
[03:30:12] <xenocons> is get for option types
[03:30:19] <dbaupp> aatch: another possibility: numeric flags e.g. '%<2>d' prints in base 2
[03:30:19] *** Quits: dymk (dymk@44EEE21C.A6E21E6E.5E500FC7.IP) (Connection reset by peer)
[03:31:02] <dbaupp> (it might be better to convert to moustache notation like python's format)
[03:31:04] <xenocons> i like how common lisp does format strings
[03:31:22] *** Quits: tjc (tjc@A5087023.2354C43D.D8E68FF6.IP) (Quit: Places to go, people to annoy)
[03:31:43] <dbaupp> xenocons: `(format t "~@(~{~A~^, ~}~).~%" groceries)`
[03:32:03] <xenocons> hah
[03:32:10] <xenocons> its  just so moustachy
[03:32:18] *** Joins: akashj87 (akash@DFB2B78E.20412040.35E3DDC8.IP)
[03:32:21] <aatch> I'd prefer to stick to '%'-style, just because it's more familiar
[03:32:45] *** Quits: Jesin (Jessin_@moz-A03A364F.cc.lehigh.edu) (Ping timeout)
[03:32:49] <xenocons> yeah aatch good point, i think a lot of C++\C people find it familiar
[03:33:15] <aatch> I might add in the '<' n '>' though
[03:33:33] <xenocons> and certainly F# has similar qualities to rusts format strings
[03:33:34] <dbaupp> aatch: I agree that it's familiar, but {..} is getting more common (python, various templating engines, common lisp, others?)
[03:33:50] <dbaupp> (just something to consider)
[03:34:00] <xenocons> %A and %O for %?
[03:34:29] <TD-Linux> is there any reason not to support both formats?
[03:34:40] <aatch> TD-Linux, two parsers?
[03:34:42] <TD-Linux> can't string formatting be implemented in an optional crate?
[03:34:50] <TD-Linux> I was under the impression that fmt! was a fancy macro
[03:34:55] <aatch> TD-Linux, not if it's integrated into fmt!
[03:35:04] <TD-Linux> oh, yeah that's not what I meant
[03:35:12] <TD-Linux> like have a moustache! or something if people want that?
[03:35:21] <dbaupp> aatch: or support both syntaxes in the one parser, i.e. either of % or { .. } are valid? (that seems possibly bad)
[03:35:33] <aatch> dbaupp, seems complex.
[03:35:37] <TD-Linux> I'd prefer fmt! to take C/C++ style, considering that is rust's target audience
[03:35:37] <ssbr_> {..} has the advantage that you can extend the syntax a bit more. e.g. in python "{myobject.myattribute[0]}".format(myobject=o) is valid
[03:35:53] <TD-Linux> and people who want more can use their own macros?
[03:35:54] <xenocons> TD-Linux: yeh i agree
[03:36:01] <aatch> ssbr_, that's kinda untenable in Rust
[03:36:17] <ssbr_> aatch: that particular thing is, but you get the idea
[03:36:17] <TD-Linux> it's not like fmt! is magical and it not supporting {} is going to be at all a problem
[03:36:29] *** Joins: Sodel_the_V (user@moz-853663E1.va.shawcable.net)
[03:36:30] <dbaupp> aatch: it's not that untenable
[03:36:41] *** Quits: mortisha (Mibbit@moz-91DB7BBE.cable.virginmedia.com) (Quit: http://www.mibbit.com ajax IRC Client)
[03:36:47] <aatch> dbaupp, I guess. I still prefer my format strings to be short
[03:37:01] <dbaupp> aatch: fmt! does create an ast from scratch, so it'd be possible to do the attribute access, etc.
[03:37:09] *** Joins: \n (_n@moz-C2B49FFE.hsd1.ca.comcast.net)
[03:37:17] *** Quits: Sodel_the_V (user@moz-853663E1.va.shawcable.net) (Quit: Eaten by a grue)
[03:37:19] <dbaupp> aatch: yeah, presumably it wouldn't be compulsory
[03:37:28] *** Quits: Nisstyre (wes@moz-FD86289.netflash.net) (Ping timeout)
[03:38:11] *** Joins: jack (jack@EF36212C.8FA609AD.840029BC.IP)
[03:38:23] <TD-Linux> I do expect to see a lot more / better string operations in rust, but at least the implementation of !fmt isn't "special" like printf is in practice for C compilers
[03:38:23] <aatch> Because python also has things like dictionary syntax.
[03:38:32] <kalenedrael> all right, it looks like the desired stack size passed to pthread_create is less than '__static_tls_size'
[03:38:57] <xenocons> well macros are type checked in rust, so really format strings are type checked
[03:39:02] <xenocons> that is already the basis for something good
[03:39:13] <\n> Hey does anyone know why rand::rng is an unresolved name if I'm `use core::rand` ?
[03:39:27] <kalenedrael> which pthread_create is not a fan of, so it returns EINVAL
[03:39:43] <dbaupp> kalenedrael: nice debugging! :D
[03:40:02] *** Joins: Nisstyre (wes@moz-FD86289.netflash.net)
[03:40:07] <aatch> \n, code?
[03:40:20] <dbaupp> kalenedrael: you should open an issue
[03:40:26] <dbaupp> \n: what version of rust
[03:40:33] <\n> 0.6
[03:40:42] * aatch thinks its a sub-crate thing
[03:40:44] <dbaupp> \n: it was called Rng()
[03:40:54] <aatch> Or not
[03:41:02] <dbaupp> aatch: :)
[03:41:36] <\n> `use core::rand;` then later `rand::Rng()` ???
[03:41:38] <TD-Linux> is there currently an issue for thread-less support? if not I'm going to make one
[03:42:07] <aatch> TD-Linux, that probably comes under runtime-less support
[03:42:07] <dbaupp> \n: the default docs on rust-lang.org are for the lastest master, not the most recent release. Try http://static.rust-lang.org/doc/0.6/core/index.html :)
[03:42:12] <dbaupp> \n: yes
[03:42:23] <\n> ah right, thanks
[03:42:44] <TD-Linux> aatch, sortof... but runtime-less support is pretty difficult and might not be worth it
[03:42:52] <TD-Linux> it would be more like "allow librt to be as minimal as possible"
[03:43:02] <kalenedrael> apparently this library changes __static_tls_size to something astronomical
[03:43:15] <strcat> TD-Linux: use lto
[03:43:46] <strcat> don't need to arbitrarily slice and dice the libs
[03:43:49] <kalenedrael> to 71680, up from 4160 without it. wat
[03:43:51] <TD-Linux> strcat, not familiar with that acronym? except for link time optimization?
[03:43:51] <strcat> just do the release builds with lto
[03:43:56] <strcat> TD-Linux: yes
[03:44:03] <TD-Linux> strcat, I don't see how that helps?
[03:44:12] <aatch> strcat, I think he means less code, not smaller file
[03:44:15] <strcat> because you only get the parts of the lib you use
[03:44:23] <TD-Linux> but those parts won't even compile for my platform
[03:44:31] <TD-Linux> because I don't have pthreads or i/o
[03:44:59] <TD-Linux> I plan to implement a NO_THREADING option (actually I probably want to take the GC out too)
[03:45:43] <strcat> so runtimeless support
[03:45:45] <TD-Linux> maybe I'll work on pulling librt out too... but a lot of other useful stuff breaks then, and core links with rt in a lot of places from a quick look
[03:45:48] <aatch> TD-Linux, that is pretty much all of the runtime
[03:45:51] <strcat> if you don't have i/o you can't use the existing libraries
[03:46:08] <strcat> can't use the hashmap implementation
[03:46:13] <TD-Linux> strcat, however core implements a lot of "language" features
[03:46:21] <strcat> TD-Linux: which?
[03:47:02] <TD-Linux> strcat, I thought it did vector stuff, among other things?
[03:47:04] <aatch> rt - (threads + gc) == ? (The scheduler maybe)
[03:47:36] <strcat> TD-Linux: so you have dynamic memory allocation?
[03:47:41] <TD-Linux> yes
[03:47:46] <strcat> why wouldn't gc work?
[03:47:53] <TD-Linux> I think rust would be pretty lacking without that
[03:48:52] <TD-Linux> strcat, it would work "probably", but I haven't looked much at it at all
[03:49:08] <ssbr_> What does I-ICE mean on the issue tracker?
[03:49:35] <TD-Linux> if I wanted an option to take it out, I'd have to change the language too, to ban @ when that happens
[03:49:40] <kalenedrael> ok, this static tls thing is a glibc issue
[03:50:07] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[03:50:07] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14cd59f82 to 145bf7e8b: 02http://git.io/N3iJvQ
[03:50:07] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[03:50:11] <strcat> TD-Linux: #[deny(managed-heap-memory)] in the crate
[03:50:24] <Jesse> ssbr_: probably "internal compiler error"
[03:50:31] <TD-Linux> strcat, that's already a thing? neat
[03:50:45] <ssbr_> Jesse: that makes enough sense for me to believe it. Thanks
[03:50:59] <aatch> dbaupp, could you re-use the precision field for integer bases?
[03:51:25] <aatch> Or would that be too confusing?
[03:51:32] <dbaupp> aatch: hmmmmm
[03:51:47] <dbaupp> aatch: I don't like it, but it's possible
[03:52:01] <aatch> so ("%.2", 7) = "111"
[03:52:17] <aatch> I can add in '<n>'
[03:52:39] <dbaupp> aatch: yeah
[03:52:44] <Jesse> ssbr_: i remember that because my friend mass-changed a message in her compiler from "ICE" to "Impossible" and accidentally changed her name at (the top of the file) from "Rice" to "Rimpossible"
[03:53:08] <dbaupp> Jesse: that's awesome :D
[03:53:22] <ssbr_> Jesse: a clbuttic mistake
[03:54:32] <dbaupp> aatch: do we want it so that it can be restricted to only some specifiers?
[03:54:58] <aatch> dbaupp, that could be done by fmt!, seems to finicky for the parser
[03:55:25] <aatch> given that it's fine with negative positions and similar
[03:55:43] <dbaupp> aatch: yes
[03:55:44] <aatch> I've just called it NumArg in the grammar
[03:55:50] <dbaupp> that's good!
[03:56:06] <aatch> Its a field before the specifier.
[03:56:15] <aatch> So it does have to be in a specific location
[03:56:17] <dbaupp> (I'm not very good at separating parsing from evaluating/using.)
[03:56:47] *** Quits: catpigger (catpig@moz-269D9D6D.dip0.t-ipconnect.de) (Quit: Verlassend)
[03:56:53] *** Joins: catpig (catpig@moz-269D9D6D.dip0.t-ipconnect.de)
[03:57:02] <dbaupp> aatch: i.e. '%<n>-d' not '%-<n>d'
[03:57:07] *** Quits: catpig (catpig@moz-269D9D6D.dip0.t-ipconnect.de) (Quit: Verlassend)
[03:57:08] <aatch> yep
[03:57:40] <aatch> It'll complain if it's elsewhere though. So nothing unexpected
[03:58:26] <dbaupp> non-ambiguous grammars are really useful :)
[03:59:03] <aatch> dbaupp, yeah, I'm making sure that it stays that way.
[04:00:00] <aatch> Since the grammar is specified (somewhat formally now) it shouldn't cause too many issues with people
[04:00:21] <dbaupp> aatch: yeah... it's probably even a regular language too
[04:00:37] <aatch> dbaupp, It very well may be
[04:00:48] <aatch> but Rust doesn't have a regex implementation yet
[04:00:54] <dbaupp> (not that that is relevant to easy of use though)
[04:01:06] *** Quits: akashj87 (akash@DFB2B78E.20412040.35E3DDC8.IP) (Ping timeout)
[04:01:15] <aatch> (Though when we do regex! will be useful)
[04:01:16] <dbaupp> aatch: yeah, I've thought a few times about implementing a basic matcher... but then distractions
[04:01:25] <kalenedrael> all right, I am not sure if this 'TLS comes out of requested stack size' is a bug or a feature, but the rust runtime can work around it
[04:01:50] *** Quits: \n (_n@moz-C2B49FFE.hsd1.ca.comcast.net) (Client exited)
[04:07:54] *** Joins: akashj87 (akash@470196C5.2BC2F975.35E3DDC8.IP)
[04:08:38] *** Joins: acrichto (acrichto@moz-FE112B96.res.cmu.edu)
[04:09:12] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[04:09:45] *** Joins: graham_king (graham_kin@moz-61791D81.vc.shawcable.net)
[04:11:01] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[04:11:22] <Thad> what parts of libuv are used for Rust ?
[04:12:43] *** Joins: drumond19 (drumond19@18307DA0.9A34F071.8DF84892.IP)
[04:16:44] <kalenedrael> filed a bug
[04:17:41] *** Quits: acrichto (acrichto@moz-FE112B96.res.cmu.edu) (Ping timeout)
[04:21:55] <graham_king> Is there a way to convert a ~[] to a @[] ? copying would be fine
[04:22:04] <aatch> dbaupp, just pushed support for '<n>'
[04:23:25] <aatch> graham_king, core::at_vec::from_owned
[04:23:29] <dbaupp> aatch: yay
[04:23:35] <graham_king> thanks!
[04:23:48] *** Quits: Thad (chatzilla@moz-C35F90AE.tx.res.rr.com) (Quit: ChatZilla 0.9.90 [Firefox 21.0/20130425162858])
[04:23:53] *** Quits: drumond19 (drumond19@18307DA0.9A34F071.8DF84892.IP) (Client exited)
[04:24:29] * aatch likes that none of the parser code contains fail!
[04:27:09] * dbaupp also like it
[04:29:32] *** Joins: seth (seth@moz-D840E602.dsl.static.sonic.net)
[04:31:18] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Input/output error)
[04:31:35] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[04:31:37] *** Quits: seth (seth@moz-D840E602.dsl.static.sonic.net) (Ping timeout)
[04:35:38] *** Quits: blitter (blitter@moz-7C98731E.dyn.centurytel.net) (Ping timeout)
[04:36:02] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Input/output error)
[04:36:52] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[04:42:13] *** Joins: ssbr (ssbr@A9D9D38C.B6F034AC.72A31D6.IP)
[04:42:42] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[04:42:43] <graham_king> Has math::min math::max moved? http://static.rust-lang.org/doc/core/math.html
[04:43:11] <aatch> graham_king, as in for finding the minimum/maximum of two values?
[04:43:15] <graham_king> yes
[04:43:30] <graham_king> rustc can't find core::math
[04:43:40] <dbaupp> graham_king: cmp::max
[04:43:41] <aatch> it's now in num.
[04:43:45] <aatch> and cmp
[04:44:07] <graham_king> excellent, thanks
[04:45:03] <aatch> you can do (for number) a.max(b), which returns the max of a and b
[04:45:24] <aatch> rusti: 5u.max(2u)
[04:45:25] <rusti> more than 5 lines of output, pastebinned: http://sprunge.us/QFOM
[04:45:30] <aatch> or not
[04:45:44] <aatch> rusti: 5u.max(&2u)
[04:45:45] <rusti> 5
[04:45:49] <aatch> rusti: 5u.max(&10u)
[04:45:50] <rusti> 10
[04:46:40] <aatch> rusti: 15u.clamp(&0, &10)
[04:46:41] <rusti> 10
[04:47:08] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[04:47:09] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/ouXWjA
[04:47:09] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[04:50:06] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[04:50:06] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/1hmwkA
[04:50:06] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[04:50:08] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[04:50:08] <ghrust> 01[13rust01] 15bors pushed 9 new commits to 06auto: 02http://git.io/gQxfrA
[04:50:08] <ghrust> 13rust/06auto 14601b8da 15Erick Tryzelaar: rustc: minor cleanup
[04:50:08] <ghrust> 13rust/06auto 14c8215a1 15Erick Tryzelaar: rustc: Remove ty::arg
[04:50:08] <ghrust> 13rust/06auto 14eb2d515 15Erick Tryzelaar: rustc: rename some ty_self variables to self_arg
[04:50:10] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[04:56:47] *** Quits: igl (igl@moz-54BE17CD.adsl.alicedsl.de) (Ping timeout)
[04:57:06] *** Joins: igl (igl@moz-80E26D1D.adsl.alicedsl.de)
[04:58:22] *** Quits: RMF (RMF@moz-FD7F97AA.dsl.telepac.pt) (Ping timeout)
[05:01:04] *** Quits: Noniagain (noniagain@moz-403930F.cpe.distributel.net) (Ping timeout)
[05:01:23] *** Joins: Noniagain (noniagain@moz-FCD1228.cpe.distributel.net)
[05:01:57] *** Joins: RMF (RMF@moz-90B282A.dsl.telepac.pt)
[05:03:21] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[05:05:03] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[05:08:09] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[05:08:09] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14cff9bc3 to 14821979f: 02http://git.io/N3iJvQ
[05:08:09] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[05:09:27] *** Quits: jfredett (jfredett@moz-C01C350.bstnma.fios.verizon.net) (Ping timeout)
[05:11:50] *** Quits: thou (thou@moz-1C1CA9F7.fasttrackcomm.net) (Input/output error)
[05:13:49] *** Parts: graham_king (graham_kin@moz-61791D81.vc.shawcable.net) ()
[05:19:59] *** Joins: thou (thou@moz-1C1CA9F7.fasttrackcomm.net)
[05:22:43] *** Quits: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net) (Quit: I'm sure it's perfectly safe)
[05:24:14] *** Joins: LiquidHelium (Mibbit@moz-91DB7BBE.cable.virginmedia.com)
[05:28:20] *** Joins: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net)
[05:31:34] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.0)
[05:31:54] *** Quits: Noniagain (noniagain@moz-FCD1228.cpe.distributel.net) (Ping timeout)
[05:31:56] *** Joins: jaen (jaen@moz-BD5DBE19.play-internet.pl)
[05:32:14] *** Joins: Noniagain (noniagain@moz-1B75BE40.cybersurf.com)
[05:33:13] *** Joins: Jesin (Jessin_@moz-A03A364F.cc.lehigh.edu)
[05:37:56] *** Quits: thou (thou@moz-1C1CA9F7.fasttrackcomm.net) (Ping timeout)
[05:39:33] *** Joins: thou (thou@moz-1C1CA9F7.fasttrackcomm.net)
[05:44:01] *** Joins: sdh_ (sdh@BCD0EF3B.8A554927.FD6A0EFF.IP)
[05:47:25] <TD-Linux> is it intentional for libcore to depend on librt, or is that supposed to go away?
[05:47:39] <TD-Linux> e.g. vec.rs calls allocation routines in librt
[05:53:23] *** Quits: Jesin (Jessin_@moz-A03A364F.cc.lehigh.edu) (Ping timeout)
[05:54:03] <TD-Linux> I'm a little bit confused about what the distinction is supposed to be
[05:54:20] <TD-Linux> considering that core contains wrappers around all the rt functions
[05:54:39] <dbaupp> TD-Linux: rt is written in C++
[05:57:29] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[05:58:22] <TD-Linux> dbaupp, will it forever be written in C++, though?
[05:59:13] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[06:01:44] <doomlord> is there anything explaining these, i'm running into problems with libuv (trying to get some ios support)
[06:01:56] <dbaupp> TD-Linux: there is a plan/current work that is moving parts into Rust
[06:02:46] <dbaupp> (e.g. the scheduler)
[06:03:15] <TD-Linux> I don't see anything in rt that seems like it couldn't be written in rust eventually
[06:04:06] <dbaupp> TD-Linux: I imagine so, but it takes work.
[06:04:15] <doomlord> i'm seeing a little asm code in there (i suppose you're saying rust+asm is just the same as c+asm)
[06:04:23] *** Joins: acrichto (acrichto@moz-FE112B96.res.cmu.edu)
[06:04:28] <TD-Linux> dbaupp, yup. I just want to make sure I do work in the right places
[06:04:42] <dbaupp> doomlord: there's asm!(".."), so it basically is :)
[06:04:46] <TD-Linux> and if a "rt-less" build actually means a "core"-less build
[06:05:26] <dbaupp> TD-Linux: as in, just the language, without the built-in libraries?
[06:06:55] <TD-Linux> dbaupp, yes, there was talk of skipping the rt, rust has the #[start] directive now as well to skip rt initialization
[06:07:45] <TD-Linux> but it looks like if I want any language features intact, it'd be a lot wiser just to port core and rt and possibly disable the thread apis
[06:09:01] <dbaupp> TD-Linux: it sounds attractive, but I imagine it would be tricky.. the porting sounds (slightly) more reasonable
[06:10:25] <ssbr> Man, so, I want to try my hand at moving rustc::metadata into its own crate, but, uh, I've never done that. Change is: added src/librustmeta/mod.rs , made these other changes: http://bpaste.net/show/J3ueIY9lhjHPln6JfUGm/  . But it fails to build if I add a reference to rustmeta in rustc: http://bpaste.net/show/BTBFqmJudjC1T0C88nwM/
[06:10:49] <ssbr> I'm doing something wrong, but I don't really understand the makefiles, so, I don't know what.
[06:11:06] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[06:11:06] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/I1GGOQ
[06:11:06] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[06:11:27] <dbaupp> ssbr: to import an external library you need 'extern mod'
[06:11:33] <ssbr> mannnnnnnnnn
[06:11:39] <ssbr> I am so stupid
[06:11:45] <ssbr> you're right of course.
[06:12:40] *** Joins: Jesin (Jessin_@moz-A03A364F.cc.lehigh.edu)
[06:12:42] <dbaupp> ssbr: does it work now? :)
[06:12:52] <dbaupp> (is that just a pure copy-paste move?)
[06:13:25] <ssbr> dbaupp: all I write was an identity function that I call from rustc in a useless place
[06:13:27] <ssbr> wrote*
[06:13:38] <ssbr> I didn't want to change too much at once
[06:13:51] <ssbr> I'll tell you if it worked once the build gets past the point it failed before
[06:14:07] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[06:14:07] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/vzlxTQ
[06:14:07] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[06:14:08] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[06:14:08] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/Woqhww
[06:14:08] <ghrust> 13rust/06auto 147d6dcff 15Brian Anderson: Move core::run tests of process killing into standalone run-pass tests...
[06:14:08] <ghrust> 13rust/06auto 14d621c32 15bors: auto merge of #6228 : brson/rust/run-destroy, r=catamorphism,brson...
[06:14:08] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[06:14:14] * dbaupp crosses fingers
[06:21:26] *** Joins: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net)
[06:21:35] <ssbr> well, something else failed: http://bpaste.net/show/pvu0OoG6BZuo7UOOwQsd/
[06:22:12] *** Quits: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[06:22:57] <dbaupp> ssbr: delete both of the rustc crates listed
[06:23:00] <dbaupp> (maybe)
[06:24:09] <ssbr> I'll tell you what happened in another ten minutes :(
[06:24:21] <TD-Linux> dbaupp, there is so much code in core that I'd not want to lose. Vectors, iterators, cmp, clone, bool, etc
[06:26:27] <dbaupp> ssbr: does the error happen on the first bootstrap?
[06:26:58] <ssbr> dbaupp: it didn't happen when I first built rust (before making the change)
[06:27:15] <ssbr> if that's what you mean
[06:28:53] *** Joins: boggle (boggle@moz-219C4.dip0.t-ipconnect.de)
[06:30:03] *** Joins: jensnockert (jensnocker@CC60FA7.C48F2496.6049AABB.IP)
[06:33:12] <ssbr> I guess that fixed it. It's been a while since compilation started.
[06:35:34] <ssbr> Compiling sure gives a lot of warnings. When do people clean them up?
[06:36:18] <ssbr> for example, I would've assumed that when 'deprecated_mode' was removed as a warning option, lines like "#[deny(deprecated_mode)];" would also have been removed
[06:37:56] *** Joins: jclements (jclements@moz-8314C9B1.dsl.snlo01.pacbell.net)
[06:38:32] <dbaupp> ssbr: I mean the stage0 build
[06:38:37] <dbaupp> also, yay :)
[06:38:56] *** Quits: jclements (jclements@moz-8314C9B1.dsl.snlo01.pacbell.net) (Quit: jclements)
[06:39:01] <ssbr> dbaupp: I'm not entirely sure on the build phases
[06:39:26] <ssbr> is the stage 0 compiler the one that is downloaded, or is it the one that the downloaded compiler outputs?
[06:39:57] <dbaupp> ssbr: stage0 is the phase when downloaded snapshot is compiling the source tree
[06:40:05] <ssbr> oh blah
[06:40:09] <ssbr> it did happen
[06:40:19] <ssbr> maybe I should just make clean
[06:40:44] *** Quits: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Quit: Don't tell them I was here...)
[06:41:01] <ssbr> except this time with stage1 instead of stage0. So I should definitely make clean. Phooie.
[06:41:05] <dbaupp> ssbr: the warnings get cleaned up when someone gets too annoyed with them, e.g. https://github.com/mozilla/rust/pull/6229
[06:41:34] <ssbr> dbaupp: that sounds like something I can do!
[06:42:29] <dbaupp> ssbr: yep! (however, that pull request probably removes most of the current ones)
[06:42:53] *** Joins: jviereck (Adium@moz-3268B76E.ethz.ch)
[06:43:11] <dbaupp> ssbr: e.g. https://github.com/catamorphism/rust/commit/18bf9bd55aa87d3da19e343241d1171414e2fc92#diff-2
[06:43:48] <ssbr> indeed
[06:46:36] <ssbr_> I guess I should play video games or something while this compiles
[06:46:45] <ssbr_> what a wonderful excuse to slack off
[06:47:39] *** Quits: jensnockert (jensnocker@CC60FA7.C48F2496.6049AABB.IP) (Input/output error)
[06:47:55] *** Quits: LiquidHelium (Mibbit@moz-91DB7BBE.cable.virginmedia.com) (Quit: http://www.mibbit.com ajax IRC Client)
[06:50:07] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[06:50:07] <ghrust> 01[13rust01] 15bors pushed 5 new commits to 06auto: 02http://git.io/YCld_w
[06:50:07] <ghrust> 13rust/06auto 145fb5a94 15Tim Chevalier: core: Warning police
[06:50:07] <ghrust> 13rust/06auto 1418bf9bd 15Tim Chevalier: std: Warning police
[06:50:07] <ghrust> 13rust/06auto 141a5f11a 15Tim Chevalier: syntax: Warning police
[06:50:07] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[06:51:11] <dbaupp> ssbr: http://xkcd.com/303/ etc
[06:51:36] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[06:53:27] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[06:55:52] <ssbr> Haha. I'd never worked on projects with compile times longer than a few seconds until maybe last year. It was horrifying! I still find it unbelievable that anyone deals well with this
[06:58:13] *** Joins: Andrew (Mibbit@moz-91DB7BBE.cable.virginmedia.com)
[06:59:04] <Andrew> Is there any pre-built windows rust against recent incoming builds instead of 0.6? I am having trouble compiling on windows
[07:00:24] <joshua_> ssbr: FPGAs are pretty bad like that, too.
[07:00:54] <bjz> aatch: just fyi, when we have default methods, min, max, and clamp will be moved to Ord
[07:02:27] *** Joins: jensnockert (jensnocker@CC60FA7.C48F2496.6049AABB.IP)
[07:03:49] *** Quits: jviereck (Adium@moz-3268B76E.ethz.ch) (Quit: Leaving.)
[07:08:05] *** Quits: philix (philix@moz-451739D3.user.veloxzone.com.br) (Quit: philix)
[07:09:33] *** Quits: Noniagain (noniagain@moz-1B75BE40.cybersurf.com) (Ping timeout)
[07:10:10] *** Joins: Noniagain (noniagain@moz-62EB86BE.gta.igs.net)
[07:10:17] *** Quits: Andrew (Mibbit@moz-91DB7BBE.cable.virginmedia.com) (Quit: http://www.mibbit.com ajax IRC Client)
[07:11:17] *** Joins: Cromulent (Cromulent@moz-5EAC0C2F.cable.virginmedia.com)
[07:11:28] *** Quits: a__ (a__@moz-9BBD1F27.nycmny.fios.verizon.net) (Ping timeout)
[07:11:47] *** Quits: Cromulent (Cromulent@moz-5EAC0C2F.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[07:16:37] <ssbr> WOOO
[07:16:39] <ssbr> it worked
[07:16:57] <dbaupp> ssbr: :D
[07:17:00] <ssbr> However, x86-unknown-linux-gnu/stage3 is empty. Is that supposed to be the case?
[07:17:06] <dbaupp> yes
[07:17:09] <ssbr> I'm assuming yes, since stage2 and stage3 are supposed to be identical, so why keep both around
[07:17:10] <ssbr> OK
[07:18:24] *** Quits: jensnockert (jensnocker@CC60FA7.C48F2496.6049AABB.IP) (Connection reset by peer)
[07:18:25] *** Joins: jensnockert (jensnocker@CC60FA7.C48F2496.6049AABB.IP)
[07:18:48] *** Quits: jensnockert (jensnocker@CC60FA7.C48F2496.6049AABB.IP) (Input/output error)
[07:20:14] <ssbr> unfortunately, I'm not yet done my video game. >:p
[07:20:22] <ssbr> (I thought the build would take an hour longer than it did... :<)
[07:21:39] <dbaupp> ssbr: run the testsuite
[07:21:48] <dbaupp> ssbr: that'll give you some more time
[07:22:39] *** Joins: jviereck (Adium@moz-EFC52440.hsi.kabel-badenwuerttemberg.de)
[07:22:42] *** Quits: jviereck (Adium@moz-EFC52440.hsi.kabel-badenwuerttemberg.de) (Client exited)
[07:22:47] *** Joins: jviereck (Adium@moz-BCDEF939.ethz.ch)
[07:22:52] *** Joins: victorporof (victorporo@F1213546.14EB2DE0.79933D60.IP)
[07:23:04] *** Quits: jviereck (Adium@moz-BCDEF939.ethz.ch) (Max SendQ exceeded)
[07:23:11] *** Joins: jviereck (Adium@moz-BCDEF939.ethz.ch)
[07:23:46] <ssbr> dbaupp: that is an amazing idea
[07:24:09] *** Quits: jviereck (Adium@moz-BCDEF939.ethz.ch) (Quit: Leaving.)
[07:24:57] <ssbr> Hm. Is that what "make test" is supposed to do?
[07:25:11] <ssbr> that doesn't do anything for me. I'm wondering if I broke it, or there's more I'm supposed to do.
[07:26:26] <dbaupp> ssbr: 'make check'
[07:26:45] <ssbr> dbaupp: thanks :)
[07:29:44] *** Joins: webber46 (webber46@moz-F6310FF0.lha.sgsnet.se)
[07:36:09] *** Joins: jensnockert (jensnocker@CC60FA7.C48F2496.6049AABB.IP)
[07:36:27] *** Quits: Noniagain (noniagain@moz-62EB86BE.gta.igs.net) (Quit: )
[07:36:58] *** Quits: jensnockert (jensnocker@CC60FA7.C48F2496.6049AABB.IP) (Input/output error)
[07:37:01] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[07:37:43] *** Quits: heftig (heftig@moz-311D88CA.dip0.t-ipconnect.de) (Ping timeout)
[07:38:01] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[07:39:13] *** Joins: heftig (heftig@moz-DDD67C1.dip0.t-ipconnect.de)
[07:39:48] *** Quits: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk) (Ping timeout)
[07:42:42] <dbaupp> ssbr: are you winning?
[07:44:32] <ssbr> against the rust tests? Yeah. They told me to fix the licensing, which was really cool. And now it's recompiling again or something.
[07:44:39] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Client exited)
[07:44:46] *** Quits: akashj87 (akash@470196C5.2BC2F975.35E3DDC8.IP) (Ping timeout)
[07:44:58] <ssbr> (Against the game? Well, DiRT 2 has this neat feature where if you lose, you can just rewind time and then keep winning, so yes. ;)
[07:45:00] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[07:45:35] <dbaupp> haha awesome
[07:45:43] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[07:46:44] <joshua_> hmm.  so.  I'm running some code that I wrote a few days ago, comparing figures against other implementations
[07:46:48] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Ping timeout)
[07:46:53] <joshua_> the good news is that our minheap implementation is quite good
[07:47:06] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[07:47:06] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/YCld_w
[07:47:06] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[07:47:08] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[07:47:24] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[07:47:26] <joshua_> a strange thing I am noticing is that the actual memory usage is fluctuating quite a bit, and I'm seeing ~1500 syscalls/second
[07:47:30] <joshua_> this obviously seems a little bit suboptimal
[07:48:13] <dbaupp> joshua_: are they mallocs/frees?
[07:48:52] <joshua_> I am not sure.  I'm looking at the 'SYSBSD' counter in top on OS X
[07:48:59] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Ping timeout)
[07:49:13] <dbaupp> joshua_: does `perf' work on OS X?
[07:49:23] <joshua_> I do not have a 'perf'.
[07:49:46] <dbaupp> hm, and it's homepage is at perf.wiki.kernel.org => probably linux only
[07:50:06] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[07:50:06] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/0_EUzA
[07:50:06] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[07:50:08] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[07:50:09] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/W9o8fA
[07:50:09] <ghrust> 13rust/06auto 1486efd97 15Daniel Micay: add gitattributes and fix whitespace issues
[07:50:09] <ghrust> 13rust/06auto 141f65e4a 15bors: auto merge of #6230 : thestinger/rust/whitespace, r=catamorphism...
[07:50:10] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[07:51:41] <dbaupp> joshua_: I would guess that they are malloc/frees, and so reducing the number of copies/clones would probably help... is the code somewhere online?
[07:52:23] <joshua_> this is the same thing I was mentioning the other day
[07:53:00] <joshua_> I will /msg you a link, due to still being part of the class
[07:53:09] <joshua_> others who want it are also welcome
[07:53:12] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[07:53:14] <dbaupp> joshua_: oh, right! that was you? :)
[07:53:20] <joshua_> yes
[07:53:51] <dbaupp> joshua_: do you have "Instruments"? http://stackoverflow.com/questions/11445619/profiling-c-on-mac-os-x
[07:54:38] <joshua_> I sure do, let's see what I can do with that
[07:55:38] *** Quits: dLog (anonymous@moz-8FAE8709.eastlink.ca) (Ping timeout)
[07:56:36] *** Joins: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk)
[07:58:36] *** Joins: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP)
[07:59:39] *** Joins: SimonSapin (simon@moz-C4A83ED9.net-89-2-126.rev.numericable.fr)
[08:05:06] *** Joins: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP)
[08:10:52] *** Quits: boggle (boggle@moz-219C4.dip0.t-ipconnect.de) (Ping timeout)
[08:11:14] *** Joins: boggle (boggle@moz-BCEB49E4.dip0.t-ipconnect.de)
[08:13:33] *** Joins: berak (chatzilla@CE2501BE.5E545589.16E13E53.IP)
[08:15:50] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[08:18:15] *** Parts: berak (chatzilla@CE2501BE.5E545589.16E13E53.IP) ()
[08:20:12] *** Joins: akashj87 (akash@48AB7F3B.7FACFDC5.35E3DDC8.IP)
[08:21:55] *** Joins: CarpNet (Alasdair@moz-EF831A5E.cable.virginmedia.com)
[08:23:29] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[08:25:07] *** Joins: pnkfelix|rcirc (pnkfelix@moz-43495417.fbx.proxad.net)
[08:31:24] *** Quits: devbug (quassel@moz-E1DE087C.bchsia.telus.net) (Client exited)
[08:32:34] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[08:32:42] *** Joins: jviereck (Adium@moz-8372C054.dip0.t-ipconnect.de)
[08:39:49] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[08:41:37] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[08:43:52] *** Quits: sdh_ (sdh@BCD0EF3B.8A554927.FD6A0EFF.IP) (Ping timeout)
[08:44:48] *** Joins: sdh_ (sdh@8557E3E0.AAC4A127.9105FBCF.IP)
[08:45:15] *** Quits: jviereck (Adium@moz-8372C054.dip0.t-ipconnect.de) (Quit: Leaving.)
[08:46:01] *** Joins: Cromulent (Cromulent@moz-5EAC0C2F.cable.virginmedia.com)
[08:53:05] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[08:53:05] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/W9o8fA
[08:53:05] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[08:55:59] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[08:56:35] *** Quits: z0w0 (zack@moz-CF5E62C9.lns4.woo.bigpond.net.au) (Quit: Leaving.)
[08:56:47] <engla> https://news.ycombinator.com/item?id=5653650  "Go and Rust – objects without class"
[09:15:29] <xenocons> duno if you can describe rust as OOP (really)
[09:15:50] <donri> does anyone even know what oop is?
[09:15:51] <xenocons> although im not going to get into a paradigm battle
[09:16:05] <doomlord> i'm of that school of thought too
[09:16:28] <doomlord> i know what abstraction, polymorphism,  modularity, encapsulation are... but i dont know what OOP is
[09:16:46] <doomlord> nor do i care :)
[09:17:38] <donri> the supertype relationship falls apart in python which is called OOP (you can remove methods or give them an incompatible call signature)
[09:17:43] <xenocons> CTM gives good overview of thins
[09:17:53] <donri> but maybe that's just arguing dynamic (gentleman's agreement) vs static
[09:18:10] <xenocons> http://www.info.ucl.ac.be/~pvr/paradigmsDIAGRAMeng108.jpg
[09:18:30] <donri> and maybe this is OPs point exactly (other languages don't have proper supertypes etc)
[09:18:45] <donri> but i'm not sure that's true for e.g. java...
[09:19:03] <xenocons> could also argue that haskell is the best OOP language
[09:20:15] <doomlord> classes are just annoying
[09:20:21] *** Quits: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk) (Ping timeout)
[09:20:35] <donri> inheritance is useful when it works... but it's hard to use right
[09:20:42] <doomlord> well.. its annoying when people think everything has to be in classes "or it isn't OOP"
[09:20:47] <ssbr_> xenocons: according to that thing, rust is certainly object oriented
[09:20:51] <ssbr_> since it has mutable cells and also closures
[09:21:10] <xenocons> ssbr_: id say its more about defaults though
[09:21:15] <ssbr_> and procedures
[09:21:16] <doomlord> an object is a region of storage. so is any language that deals with regions of storage OO :)
[09:21:39] <xenocons> well, my feeling anyway is that rust has OO,Imp and FP, but (*so far*) in the short time ive been using it, by default it feels functional
[09:22:16] <doomlord> what features give that feel
[09:22:25] <xenocons> let x = 5
[09:22:31] <doomlord> immutable default?, expresion-based syntax?
[09:22:33] <ssbr_> most functional languages I've tried make it a lot less fun to program imperatively than rust does, the exception being scheme
[09:22:35] <xenocons> x = 1 //error
[09:22:44] <xenocons> doomlord: mutable default
[09:22:46] <xenocons> er
[09:22:48] <xenocons> immutable default
[09:22:51] <xenocons> type inference
[09:22:54] <xenocons> closures
[09:23:02] <doomlord> ok the || sugar
[09:23:02] *** Joins: jensnockert (jensnocker@CC60FA7.C48F2496.6049AABB.IP)
[09:23:04] *** Joins: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk)
[09:23:16] <xenocons> yeah, lambda is a bit of a sorespot for me with rust atm, and the lack of currying
[09:23:22] <doomlord> sorry not || sugar
[09:23:32] <ssbr_> "closures" is a weird one. Pretty much any imperative language has those these days. even java!
[09:23:45] <xenocons> ssbr_: yeah thats probably correct
[09:23:45] <doomlord> rather the way they sugar use of blocks for things that are control flow in other languages
[09:23:58] <xenocons> ok: compile time correctness
[09:24:07] <xenocons> (on its way anyway)
[09:24:16] <ssbr_> doomlord: but isn't that best explained by the desire to use borrow pointers?
[09:24:45] <engla> I think many functional concepts (currying, composition, fmap) are much less useful in Rust. the stumbling block is different pointer types (plain value, &, @, ~) so functions are much less composable
[09:25:05] <ssbr_> the iterator style wouldn't work as well, I thought
[09:25:15] <engla> if every function just took the same kind of reference, it would be much better for functional style rust
[09:25:17] <doomlord> whatever paradigm it is i like it:) it comes across to me as genuinely multi-paradigm.
[09:25:24] <xenocons> engla: i dont know exactly how much of a  stumbling block that is, imo, currying (and hence composition) is perfectly applicable to pointer operations
[09:25:34] *** Quits: jensnockert (jensnocker@CC60FA7.C48F2496.6049AABB.IP) (Input/output error)
[09:25:40] <xenocons> i think it has just not been high on the list of priorities yet (which is perfectly fine)
[09:25:51] <aatch> engla, the reason for the multiple pointer types is to ensure memory safety while maintaining efficiency
[09:25:55] <engla> but there is no generality xenocons.. you need different combinators 
[09:25:55] <ssbr_> well
[09:26:14] <engla> aatch: I know there are good reasons. Just saying that having one single variable type would be better for composability
[09:26:21] <ssbr_> can you define a function fn foo (x : something) { x.bar } so that foo can be called on a MyStruct and a &MyStruct?
[09:26:23] *** Joins: spider-mario (spidermari@moz-EE4B8A09.rev.sfr.net)
[09:26:24] <ssbr_> my understanding is no
[09:26:24] <engla> but it would come with a cost
[09:26:36] <ssbr_> and I assume that sort of thing is what engla is talking about
[09:26:51] <xenocons> engla: hmm good point
[09:26:58] <aatch> ssbr_, but passing MyStruct and &MyStruct have different semantics
[09:27:01] <engla> ssbr_: I'm talking about function composition
[09:27:06] <ssbr_> aatch: right
[09:27:06] <engla> and other concepts
[09:27:30] <ssbr_> engla: yes, but this means that every HOF needs to be defined multiple times depending on the arguments of the functions passed/returned, and so on
[09:27:33] <doomlord> pure functional makes more sense with GC-only IMO
[09:27:43] <xenocons> i need to read this lwn post better i think
[09:27:47] <engla> right doomlord 
[09:27:53] <xenocons> you can 'fake it' though
[09:28:14] <doomlord> but you can still write functional-inspired code in c++/rust IMO
[09:28:18] *** Joins: jensnockert (jensnocker@CC60FA7.C48F2496.6049AABB.IP)
[09:28:18] <xenocons> i dont know too much about pure functional though
[09:28:21] <xenocons> doomlord: yeh exactly
[09:28:23] <doomlord> whatever you'd call it
[09:28:34] <xenocons> i do thusly in python when i am forced to use it
[09:28:39] <ssbr_> rust has more nice features from FP than most languages do <_<
[09:29:13] <xenocons> type classes, aka traits are attractive
[09:29:44] <aatch> I found myself using the same abstraction process I developed in Haskell while writing Rust code
[09:30:50] <ssbr_> Even less than that. I find it frustrating to program in python or C# without sum types :(
[09:31:00] <doomlord> i should find a wheel to re-invent in rust to learn it properly
[09:31:10] <aatch> doomlord, regex!
[09:31:16] <xenocons> ssbr_: i like itertools
[09:31:24] <ssbr_> aatch: what's the requirements for regex anyway
[09:31:35] <ssbr_> PCRE bindings, or like, a legit new regex engine?
[09:31:39] *** Quits: jensnockert (jensnocker@CC60FA7.C48F2496.6049AABB.IP) (Input/output error)
[09:31:40] <doomlord> its probably the real reason i want a new language .. excuse to indulge NIH and re-invent the wheel
[09:31:41] <dbaupp> ssbr_: pure rust
[09:31:42] <ssbr_> (JIT compiled? ;o)
[09:32:10] <ssbr_> Hmmmm. Why not bindings?
[09:32:15] <aatch> ssbr_, it seems the most efficient way is to have a "vm"
[09:32:32] <dbaupp> ssbr_: rust only is safer (i.e. goes through the rust checks) and often faster
[09:32:39] <ssbr_> okay
[09:32:57] <aatch> Also, we can have a syntax extension that compiles to rust (and therefore native) code
[09:33:02] <dbaupp> ssbr_: e.g. https://github.com/mozilla/rust/pull/6073#issuecomment-17080375
[09:33:20] <ssbr_> FWIW I've implemented two fairly full blown regex engines -- the first with submatch extraction, the second in the more CS-y style
[09:33:29] <aatch> so let r = regex!("[1-9][0-9]*")
[09:33:30] <ssbr_> it's a pet hobby of mine <_<
[09:33:33] <dbaupp> (and then a later comment on that same issue)
[09:33:45] <ssbr_> and I was going to rewrite my second regex thing in rust, and that's actually why I want rust to be able to generate C headers
[09:33:52] <dbaupp> ssbr_: you're perfectly suited to the task!
[09:33:55] <ssbr_> so that I can actually use it from other languages easily
[09:33:57] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[09:33:59] <aatch> ssbr_, Thompson DFA?
[09:34:18] <ssbr_> aatch: right. and the variation by Pike, that keeps track of submatches
[09:34:34] <aatch> ssbr_, I like Pike's submatching
[09:34:54] <ssbr_> aatch: if the rust people would welcome such a thing, I'd be glad to implement it, since I was going to anyway
[09:35:18] <aatch> ssbr_, it would be great.
[09:35:24] <ssbr_> a lot of people don't like pike/laurikari so much, because you don't get backreferences, and lookahead/lookbehind aren't trivial
[09:35:26] <dbaupp> ssbr_: https://github.com/mozilla/rust/issues/3591
[09:35:38] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[09:35:58] <aatch> ssbr_, I prefer my regular expressions regular
[09:36:17] <ssbr_> me too
[09:36:28] <ssbr_> dbaupp: I can't tell whether or not they've found something they want to use
[09:37:30] <ssbr_> aatch: some requirements would probably be helpful for figuring out a solution
[09:37:31] <ssbr_> like uh
[09:37:47] <ssbr_> a big thing is what kind of unicode support you'd want
[09:38:13] <ssbr_> everyone does it differently, after all
[09:38:51] <aatch> ssbr_, /my/ requirements are to be able to support most cases people use (so matching an email address for example) fast.
[09:39:47] <aatch> Minimum unicode support would be "don't choke on unicode"
[09:39:59] <ssbr_> that's fair
[09:40:01] <aatch> At least on the target string.
[09:40:26] <ssbr_> doing something basic like that is pretty easy
[09:40:31] <aatch> Ideally having things like \d and \w matching numeric and word characters across all of unicode would be nice
[09:40:45] <aatch> There is some precedent for the unicode classes in core already
[09:41:26] <ssbr_> maybe it'd be nice to have a module in std that lets you query the unicode database
[09:41:27] *** Quits: cdidd (cdidd@3E82BB89.271BFDAC.62D8163C.IP) (Connection reset by peer)
[09:41:28] *** Quits: bblum (bblum@moz-2B41ACB5.andrew.cmu.edu) (Ping timeout)
[09:42:06] <ssbr_> java has a bunch of string methods, python has a bunch of string methods and also http://docs.python.org/3/library/unicodedata.html
[09:42:06] *** Quits: rpearl (rpearl@moz-2B41ACB5.andrew.cmu.edu) (Ping timeout)
[09:42:17] <ssbr_> (although the unicodedata module isn't very good)
[09:44:35] <ssbr_> well anyway, that's on my todo list. I should be back to work on it in a couple of weeks. I guess I'll send an email about it to rust-dev then.
[09:45:59] *** Joins: bblum (bblum@moz-2B41ACB5.andrew.cmu.edu)
[09:46:18] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[09:46:21] *** Joins: rpearl (rpearl@moz-2B41ACB5.andrew.cmu.edu)
[09:50:50] *** Quits: Cromulent (Cromulent@moz-5EAC0C2F.cable.virginmedia.com) (Connection reset by peer)
[09:58:20] *** Quits: SimonSapin (simon@moz-C4A83ED9.net-89-2-126.rev.numericable.fr) (Ping timeout)
[09:59:37] *** Quits: thou (thou@moz-1C1CA9F7.fasttrackcomm.net) (Input/output error)
[10:01:17] <kimundi> ssbr_: graydon mentioned he'd like to se a rust binding for https://code.google.com/p/re2/
[10:02:02] <kimundi> ssbr_: So, if you want to tackle a re-implementation, maybe just use that as a guideline?
[10:02:46] <aatch> Looks like re2 do as much as is possible while not requiring backtracking
[10:02:55] <aatch> s/do/does
[10:03:00] <kimundi> jup, seems so
[10:06:25] *** Quits: sdh_ (sdh@8557E3E0.AAC4A127.9105FBCF.IP) (Ping timeout)
[10:08:05] <ssbr_> well, not as much as possible, but very close
[10:08:17] *** Joins: sdh_ (sdh@C957F273.8BDB8EF1.A76F6622.IP)
[10:08:39] <ssbr_> (it could add forward/backward lookahead with O(n^2) search. I think it's an open problem if that can be done in O(n))
[10:08:52] <aatch> ssbr_, from my research it seems like dropping backreferences is like /the/ optimization for regex though
[10:09:03] <ssbr_> yes, it's pretty sweet
[10:09:22] <aatch> since it seems to be the only thing that requires backtracking
[10:09:49] <ssbr_> russ cox (the author of RE2) pretty much reignited that entire idea. Apparently everyone forgot how to do it.
[10:10:09] <ssbr_> er, forgot how to implement backtracking-free regexps with submatch extraction
[10:10:27] <ssbr_> there's tre, RE2, and I think that's basically it for anything "production-ready" that does it this way
[10:10:28] <aatch> ssbr_, lol. I got interested in it while I was with D.
[10:10:56] <aatch> Since the regular expression library landed while I was there and there was much kerfuffle over its speed
[10:11:27] <ssbr_> Ah, does D do it with backtracking or no?
[10:11:32] <aatch> ssbr_, nope
[10:11:55] <ssbr_> nice ! I didn't realize that was another implementation :)
[10:12:00] <aatch> Uses DFA with submatch extractrion
[10:12:54] <aatch> It also has the option of compiling to native code at runtime, because D had compile-time function execution capable enough to do that.
[10:13:03] <aatch> s/had/has
[10:13:15] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[10:13:53] <aatch> It was surprising the number of people that complained about it being slow, then were told to move the compilation step out of the loop.
[10:14:02] <ssbr_> ooof :)
[10:14:26] <ssbr_> That's a super nice idea, ahving it compilable at compile time. I bet it requires that the compiler have really nice extension/macro functionality though
[10:14:47] <kimundi> ssbr_: Could be done for a rust implementation
[10:14:52] <aatch> regex!()
[10:15:21] <ssbr_> aatch: regexps require a lot of preprocessing to translate to rust code (or llvm IR or whatever)
[10:15:34] <ssbr_> one would want macros that can invoke rust code
[10:15:38] <ssbr_> uh
[10:15:39] <aatch> ssbr_, not a macro
[10:15:47] <aatch> a syntax extension
[10:15:53] <ssbr_> aatch: does rust have that now?
[10:15:54] <aatch> macro_rules! can't do fmt!
[10:15:59] <aatch> but we have fmt!
[10:16:09] <ssbr_> Sure, but isn't that special-cased in rustc itself?
[10:16:10] <kimundi> would be nice to have a regex!() se, that compiles to code if it's imput is static, and else falls back to parsing
[10:16:11] <aatch> ssbr_, always has (for a given value of always)
[10:16:14] *** Quits: acrichto (acrichto@moz-FE112B96.res.cmu.edu) (Ping timeout)
[10:16:33] <aatch> ssbr_, no more than most of the complex "macros"
[10:16:40] <kimundi> ssbr_: It's not really special cased
[10:16:49] <ssbr_> well, can a crate define its own syntax extension?
[10:16:56] <ssbr_> that's the important question :(
[10:16:59] <aatch> ssbr_, not yet
[10:17:08] <kimundi> But it wii be possible
[10:17:19] <aatch> but this would be a standard library implemention, right?
[10:18:06] *** Joins: muonz (moon@95840194.4E28F30D.2C82CA7.IP)
[10:18:10] <ssbr_> aatch: well there's things like, what if someone wants to use a different regex syntax, or what if they want to use a different regex compiler, maybe they still want it to be compiled at compile time
[10:18:13] <ssbr_> at rust compile time
[10:18:16] <aatch> ssbr_, btw, we also have file!(), line!() and asm!()
[10:18:56] <bjz> xenocons: nice diagram
[10:19:16] <aatch> ssbr_, one thing at a time. Ideally most of the cases we have at the moment would also be external to rustc
[10:19:20] <bjz> xenocons: I like how Oz is on pretty much everything :P
[10:19:20] <aatch> like proto!
[10:19:23] *** Joins: threecreepio (jdp@moz-DB2D70E9.cust.bredbandsbolaget.se)
[10:19:23] <kimundi> ssbr_: I would say have a re2-like buildin for now, and make traits/interfaces as reusable as possible.
[10:20:30] <ssbr_> I mean w.r.t. syntax extensions only being able to be defined by the builtin crates
[10:20:32] <bjz> doomlord, doomlord_: did you get that reply?
[10:20:57] <aatch> ssbr_, right now they have to be implemented in the parser
[10:20:57] <ssbr_> even if the traits are reusable, it doesn't help you get things done at compile-time, since the code you define only affects runtime. AIUI.
[10:21:14] <aatch> though they can call into other places
[10:21:25] <xenocons> bjz: oz is actually really cool
[10:21:33] <xenocons> they use Oz\Mozart for the language in the CTM book
[10:21:40] <xenocons> ive been slowly getting into it
[10:21:41] <aatch> so fmt! is defined in libsyntax, and calls into libcore
[10:21:43] <bjz> xenocons: I would like to look at it sometime
[10:21:53] <xenocons> its a great teaching language
[10:22:17] <ssbr_> ughhhh
[10:22:22] <ssbr_> you're making me want to work on regexps
[10:22:29] <aatch> good!
[10:22:32] <bjz> xenocons: is that the book that they say is a good one to go through after SICP?
[10:22:35] <ssbr_> not good!
[10:22:44] <ssbr_> or rather
[10:22:50] <xenocons> bjz: hm, not sure, but it is pretty introductory 
[10:22:57] <kimundi> ssbr_: It can always be refactored later. for now re!() could just do a re2-like thing, and later it could refactored to allow other re-modules to be used at compiletime instead
[10:22:57] <bjz> xenocons: http://www.amazon.com/Concepts-Techniques-Models-Computer-Programming/dp/0262220695/ref=wl_it_dp_o_pC_S_nC?ie=UTF8&colid=1JMEX91A8ILZ6&coliid=I27UDPKIZM5158
[10:22:57] <xenocons> at least, im only a little bit in so far
[10:23:00] <ssbr_> I'll work on regexps if you write a program that outputs C header files for a given crate / object file
[10:23:02] <xenocons> bjz: yeh
[10:23:12] <ssbr_> comparative advantage was always the basis for good trade, yes? ;)
[10:23:20] <bjz> xenocons: yeah I'm thinking of getting it
[10:23:25] <bjz> xenocons: you like?
[10:23:31] <xenocons> i really do so far
[10:23:34] <xenocons> ive got the ebook
[10:23:43] <xenocons> but ill need to get hardcover eventually
[10:23:44] <aatch> ssbr_, thats kinda tempting
[10:23:55] <aatch> but I'm working on the formatting stuff atm
[10:25:00] <ssbr_> well, I can reconsider my priorities
[10:25:16] <aatch> ssbr_, you don't have to do it right now
[10:25:29] <aatch> but I assume you have a clearly picture of requirements?
[10:25:36] <aatch> s/clearly/clearer
[10:25:41] <ssbr_> clearer
[10:25:49] <ssbr_> I'd still want to start a big honking ML thread
[10:25:54] *** Joins: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP)
[10:25:54] *** Quits: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP) (Z:lined (Open Proxy found on your host. Please visit www.blitzed.org/proxy?ip=115.68.131.49 for more information.))
[10:25:57] <aatch> my typing is crap this evening
[10:26:01] <aatch> ssbr_, of course
[10:26:11] * kimundi is also in need for a rust re lib atm.
[10:26:24] <ssbr_> hmmmm
[10:26:33] *** Quits: boggle (boggle@moz-BCEB49E4.dip0.t-ipconnect.de) (Quit: boggle)
[10:26:41] <aatch> though you may be surprised at how little resistance to "no backreferences" gets
[10:26:52] <ssbr_> comparative advantage wins this round
[10:26:58] <ssbr_> I can probably get someone else to do the other thing
[10:28:32] *** Quits: MrFahrenheit (RageOfThou@moz-CF7139ED.dynamic.telemach.ba) (Connection reset by peer)
[10:28:40] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[10:28:43] *** Joins: MrFahrenheit (RageOfThou@moz-CF7139ED.dynamic.telemach.ba)
[10:29:27] <ssbr_> As far as compiling regexps goes, why compile to rust as opposed to LLVM IR?
[10:29:57] <ssbr_> To get the sure benefit of safety?
[10:30:03] <aatch> Also easier
[10:30:32] <aatch> since syntax extensions output ast
[10:30:58] <ssbr_> Well for example, can I compile rust AST at runtime?
[10:31:28] <aatch> ssbr_, not really.
[10:31:30] <ssbr_> one desirable property might be to use the same implementation at compile / run time
[10:31:32] <muonz> hey there. going to ask a total noob question, apologies. is there a good list of rust libs anywhere? want to develop a lib to get my hands dirty. cargo-central repo on github seems outdated? thanks
[10:31:37] <aatch> brb mouse froze
[10:31:45] <aatch> muonz, it is
[10:31:53] <ssbr_> if we generate LLVM IR, then you can use the LLVM JIT compiler at runtime, or do ahead of time compilation at Rust build time with re!
[10:31:55] *** Quits: aatch (aatch@moz-2BB0AC01.cable.telstraclear.net) (Client exited)
[10:32:01] <muonz> aatch: thanks. nothing better than that list though?
[10:32:07] <ssbr_> but if one generates a rust AST, it's not as general
[10:32:51] *** Joins: boggle (boggle@moz-BCEB49E4.dip0.t-ipconnect.de)
[10:33:34] <kimundi> ssbr_: I'd say make something that 'compiles' to a datastructure that can be easily used for re parsing first, and then look into how to embedded that as rust coda at compiletime
[10:34:02] <kimundi> code*
[10:34:08] <ssbr_> kimundi: that's fair
[10:34:26] *** Joins: aatch (aatch@moz-2BB0AC01.cable.telstraclear.net)
[10:34:35] <indutny> good morning
[10:34:43] <indutny> I want to ask you for an advice
[10:34:53] <aatch> just the one?
[10:35:00] <indutny> at least for now :)
[10:35:15] <indutny> which type to choose ~[Struct] or ~[~Struct]
[10:35:27] <aatch> depends on your needs
[10:35:35] <indutny> ok, if struct is really small
[10:35:39] <indutny> choose first?
[10:35:49] <indutny> or what do you mean?
[10:36:18] <aatch> Well ~[~T] is an owned vector of owned pointers to ~T
[10:36:49] <indutny> that basically means that every entry is malloc()'ed pointer
[10:36:53] <indutny> s/entry/item/
[10:36:55] <indutny> whatever
[10:36:59] <aatch> indutny, essentially
[10:37:05] <indutny> and that's what I dislike about it
[10:37:17] <indutny> but on other hand ~[Struct] will copy each item on insertion, right?
[10:37:24] <indutny> I mean on list.push()
[10:37:26] <ssbr_> aatch: kimundi: is there actually a consensus that what's wanted is a regex library implemented entirely in rust?
[10:37:40] <aatch> indutny, list.push() appends to the vector
[10:37:50] <aatch> it will re-allocate if it runs out of space
[10:38:05] <aatch> but it reserves space (and can be told to reserve more)
[10:38:11] <ssbr_> indutny: it will copy the struct, yes
[10:38:27] <indutny> aatch: I understand how it works
[10:38:35] <indutny> just want to make sure I understand how copying works
[10:38:37] <indutny> is it a memcpy?
[10:38:41] <aatch> indutny, sorry, I misunderstood your question
[10:38:54] <aatch> indutny, for implicitly copyable values, yes
[10:38:57] <kimundi> ssbr_: Dunno. If it's just dynamic an buildin binding to re2 would probably suffice. But for real compile-time re compilation you'd need rust code I think.
[10:39:00] <aatch> or possibly memmove
[10:39:04] <indutny> ok
[10:39:31] <indutny> but can list.push(Struct { … }) be optimized to allocate space first and insert fields directly in-place?
[10:39:34] <aatch> I think it calls an llvm intrinsic, so llvm decides whats best most of the time.
[10:39:58] <indutny> because copying is a bit… excessive, you know
[10:40:00] <aatch> indutny, no idea sorry
[10:40:13] <indutny> np
[10:40:33] <aatch> Well unfortunately you either have to malloc or copy
[10:40:44] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Quit: Leaving.)
[10:40:45] <engla> dbaupp: you implemented complex in rust right? An idea, does it make sense to give it a method to cast Cplx<T> -> Cplx<U> when both T,U have NumCast?
[10:40:59] <indutny> aatch: that's what bothers me
[10:41:21] <indutny> also, it'd be good to see zone allocation mode
[10:41:26] <indutny> but that's mostly dreams
[10:42:01] <aatch> zone allocation?
[10:42:38] <kimundi> ssbr_, so, I guess in the end you'd have two kinds of functions for re-inputs that can only be determined at runtime: 'dynamic' that parses at each call, 'dynamic_compiled', where you compile to a seperate datastructure first to use that in a tight loop or similar, and as third option a syntax extension that allows optimal performance for static re-inputs because it compiles the re directly to a state machine
[10:42:49] <indutny> aatch: yeah, like specify new() and free() methods
[10:43:04] <indutny> and make all data allocate using them
[10:43:11] <indutny> very useful for jit compilers
[10:43:18] <aatch> Ahh, right.
[10:43:23] <indutny> because I can, for example, allocate big chunk of memory
[10:43:26] <aatch> Yeah, that might be a little out there
[10:43:32] <indutny> and just insert data to it and remove everything at once
[10:44:10] <aatch> though you might be able to approximate it when we have uninit()
[10:44:54] <aatch> (marking values as unitialized so you can initialize them separately without any overhead)
[10:45:02] <aatch> Obviously unsafe though
[10:45:53] *** Joins: a__ (a__@moz-B4E30208.nycmny.fios.verizon.net)
[10:47:24] *** Joins: z0w0 (zack@moz-CF5E62C9.lns4.woo.bigpond.net.au)
[10:49:18] *** Quits: jaen (jaen@moz-BD5DBE19.play-internet.pl) (Ping timeout)
[10:49:36] *** Joins: jaen (jaen@moz-BD5DBE19.play-internet.pl)
[10:49:55] *** Joins: jensnockert (jensnocker@CC60FA7.C48F2496.6049AABB.IP)
[10:52:26] <bjz> aatch: how is the awesomeness going?
[10:52:35] <aatch> bjz, pretty good
[10:52:43] <aatch> I've kinda run out of parser stuff though
[10:52:57] <aatch> so I'm wondering what I should do next
[10:53:17] <bjz> implement it for numbers?
[10:53:30] <aatch> bjz, well it's just the parser at the moment.
[10:53:36] <bjz> ahh
[10:54:43] *** Joins: quvarxa (chatzilla@moz-5DECE2C.lns20.adl2.internode.on.net)
[10:54:48] <aatch> I could start adding the traits for the printf formatter though
[10:55:00] <bjz> aatch: that would be nice
[10:55:39] <aatch> I'm thinking a submodule, so when this is integrated, it would be {core,std}::fmt::printf::<whatever>
[10:56:02] <bjz> so the num conversions would be in fmt?
[10:56:08] <bjz> https://github.com/mozilla/rust/issues/6220
[10:56:10] <aatch> just the traits
[10:56:15] <bjz> oh ok
[10:56:19] <bjz> makes sense
[10:56:37] <bjz> good thinking
[10:56:46] <indutny> why is rust generating so big binaries?
[10:56:48] <aatch> we decided on a minimum number of traits, for each "type" of conversion.
[10:56:58] <aatch> indutny, try -O2
[10:57:01] <indutny> 300 kb for 500 lines of code
[10:57:09] <indutny> aatch: yeah, it'll be 200kb :)
[10:57:12] <aatch> default is no optimizations, so no dead-code removal
[10:57:17] <indutny> I tried
[10:57:38] <aatch> indutny, oh, monomorphisation!
[10:57:40] <indutny> nm ./binary | wc -l returns 1444
[10:58:15] <aatch> we have C++'s template bloat problem
[10:58:27] <indutny> ah
[10:58:33] <indutny> also
[10:58:37] <indutny> just realized
[10:58:43] <indutny> I'm using a lot of core:: stuff
[10:58:48] <indutny> like vectors, hashmaps
[10:58:49] <indutny> nvm
[10:58:57] <indutny> but it could be less, still...
[10:59:15] <bjz> indutny: I'm sure there will be improvements on that front
[10:59:27] <aatch> indutny, yeah, the monomorphizer tries to combine identical bodies, but it's not perfect
[10:59:27] <indutny> I believe you :)
[10:59:29] <indutny> thanks
[10:59:40] <indutny> its not something I care much yet
[10:59:41] <bjz> indutny: most of the work so far has been on language syntax/semantics
[10:59:52] <indutny> but it'll be more important once I'll add more LoC
[10:59:54] <aatch> better to not combine identical bodies than accidentally combine slightly different ones
[11:00:08] <aatch> indutny, it may not scale linearly
[11:00:08] <bjz> indutny: C/C++ compilers have had decades to work on these problems
[11:00:15] <indutny> yes
[11:00:19] <indutny> I understand it
[11:01:32] <engla> funny thing from rust source, above   consts::pi... /* Archimedes' staticant */
[11:01:52] <engla> (solution: global replace const -> static)
[11:02:07] <aatch> oh yeah
[11:02:18] <aatch> that comes up a few times
[11:03:16] *** Quits: bblum (bblum@moz-2B41ACB5.andrew.cmu.edu) (Ping timeout)
[11:03:51] *** Quits: rpearl (rpearl@moz-2B41ACB5.andrew.cmu.edu) (Ping timeout)
[11:05:17] *** Quits: threecreepio (jdp@moz-DB2D70E9.cust.bredbandsbolaget.se) (Quit: threecreepio)
[11:08:02] <aatch> bjz, conversion specifiers, these are going to be "value as <whatever>". What should we have? I've got d, f, s and ?
[11:08:16] <aatch> for number, float, string and repr
[11:08:32] <aatch> The current syntax will have <n> for a base on d
[11:08:49] <aatch> so that covers binary and hex.
[11:10:03] <aatch> number => integer
[11:10:09] <aatch> (maybe)
[11:10:32] <bjz> aatch: mmk
[11:10:42] <aatch> Can you think of anything else?
[11:10:48] <bjz> yeah I'm not sire
[11:10:51] <bjz> *sure
[11:10:59] <bjz> what does brson say?
[11:11:13] <bjz> sorry
[11:11:34] <aatch> lol, s'ok
[11:11:54] <aatch> I'll stick with that for now
[11:12:22] *** Joins: noam_ (noam@F6B530A7.720527A7.416762B.IP)
[11:13:10] *** Quits: noam (noam@F6B530A7.720527A7.416762B.IP) (Ping timeout)
[11:13:13] *** Joins: bblum (bblum@moz-2B41ACB5.andrew.cmu.edu)
[11:13:31] *** Joins: noam__ (noam@F6B530A7.720527A7.416762B.IP)
[11:13:46] *** Joins: rpearl (rpearl@moz-2B41ACB5.andrew.cmu.edu)
[11:14:02] *** Quits: noam_ (noam@F6B530A7.720527A7.416762B.IP) (Ping timeout)
[11:14:51] <heftig> engla: clbuttic
[11:17:13] *** Joins: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se)
[11:18:18] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[11:21:48] *** Joins: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com)
[11:22:17] *** Quits: jensnockert (jensnocker@CC60FA7.C48F2496.6049AABB.IP) (Input/output error)
[11:23:28] *** Quits: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com) (Ping timeout)
[11:28:02] *** Joins: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com)
[11:32:15] <kimundi> ssbr_: ping
[11:32:27] <ssbr_> kimundi: pong
[11:33:21] *** Joins: jensnockert (jensnocker@CC60FA7.C48F2496.6049AABB.IP)
[11:33:27] <kimundi> ssbr_: So, I have no idea how to implement regular expression matching efficiently, but I think I found a nice design for the api. Would you like to see it?
[11:33:43] <ssbr_> kimundi: sure
[11:33:50] <dbaupp> engla: I did, and I guess that function might be useful, although a 'transform_both' function, (Complex<T>, fn(T) -> U) -> Complex<U> might be more general
[11:33:59] <ssbr_> (after all, aren't I the opposte? ;)
[11:34:00] <kimundi> ssbr_: Okay, here: https://gist.github.com/Kimundi/5517223 :)
[11:34:39] <engla> dbaupp: true, if there are any other usecases.
[11:35:15] <ssbr_> kimundi: oh, can compiler extensions put code anywhere in the file?
[11:35:33] <ssbr_> I figured they could only put code like macros can
[11:35:38] <ssbr_> I guess that'd be silly
[11:35:41] <kimundi> ssbr_: A compiler extension can expand to arbitrary rust code
[11:35:55] <dbaupp> ssbr_: I'm fairly sure they can touch the whole ast
[11:35:56] <ssbr_> kimundi: right, but here it has to add stuff elsewhere in the module, right?
[11:36:06] <ssbr_> since it has to write a struct and trait implementation
[11:36:11] <ssbr_> struct type*
[11:36:13] <kimundi> ssbr_: I think this is all possible inline
[11:36:16] <dbaupp> ssbr_: those can go anywhere
[11:36:22] <aatch> ssbr_, you can do that inline anyway
[11:36:26] <ssbr_> oh, whaaa
[11:36:37] <ssbr_> that isn't possible in haskell, is it?
[11:36:40] <dbaupp> rusti: trait A { fn foo(); } impl A for int { fn foo() {} } A::foo::<int>()
[11:36:52] <dbaupp> rusti: trait A { fn foo(); } impl A for int { fn foo() {print("int")} } A::foo::<int>()
[11:36:53] <rusti> int
[11:36:58] <ssbr_> (trying to figure out if it's just me thinking like a C programmer that makes it weird, or if it's actually weird)
[11:37:07] <aatch> ssbr_, a little of both
[11:37:17] <dbaupp> ssbr_: (that is all in the main function of some file)
[11:37:21] <aatch> it's certainly not good style most of the time.
[11:38:08] <ssbr_> hmmmm
[11:38:27] <kimundi> rusti: let v = { struct Foo;    impl ToStr for Foo {        fn to_str() -> ~str { ~"inline impl" }     }       }; v.to_str()
[11:38:27] <ssbr_> is it possible to define a type / implementation of a trait inside a function, and then return it as an object of that trait?
[11:38:29] <rusti> more than 5 lines of output, pastebinned: http://sprunge.us/dhhW
[11:38:55] <kimundi> rusti: let v = { struct Foo;    impl ToStr for Foo {        fn to_str(&self) -> ~str { ~"inline impl" }     }       }; v.to_str()
[11:38:57] <rusti> ~"()"
[11:39:11] <dbaupp> rusti: fn f() -> Foo { struct Foo; Foo } f()
[11:39:12] <ssbr_> I'm not sure if that question makes sense, I don't know much about dynamic type dispatch in rust
[11:39:12] <rusti> more than 5 lines of output, pastebinned: http://sprunge.us/PQYJ
[11:39:22] <kimundi> rusti: let v = { struct Foo;    impl ToStr for Foo {        fn to_str(&self) -> ~str { ~"inline impl" }     }    Foo   }; v.to_str()
[11:39:23] <rusti> ~"inline impl"
[11:39:31] <kimundi> jup, works
[11:39:33] <ssbr_> I was just wondering if the API kimundi linked would work with a hypothetical backend that JIT compiles regexps to C function pointers
[11:40:15] <kimundi> ssbr_: That would work in theory
[11:40:20] <dbaupp> ssbr_: any particular reason for C function pointers rather than rust ones?
[11:40:31] <ssbr_> dbaupp: eh, rust ones too
[11:40:47] <ssbr_> I didn't really mean to specify C, I was thinking the details too much :(
[11:40:59] <kimundi> ssbr_: But this way you get more compile optimisations, I think
[11:41:03] <ssbr_> kimundi: there's a bit of an explosion of methods here
[11:41:12] <kimundi> yeah
[11:41:45] <ssbr_> kimundi: consider in Python, there's three different kinds of search: match (regex has to match starting at beginning of string), fullmatch (regex has to match entire string), and search (regex has to match some substring)
[11:41:50] <kimundi> could have a flag that forces dynamic compilation if thats an issue
[11:41:54] <ssbr_> match can end anywhere
[11:42:11] <dbaupp> can re2-style DFAs even do non-greedy matching?
[11:42:22] <ssbr_> dbaupp: yes
[11:42:30] <dbaupp> (refering to kimundi's api sketch)
[11:42:31] <kimundi> dbaupp: re2 can do longest and shortest match
[11:42:39] <dbaupp> oh awesome
[11:42:39] <aatch> dbaupp, yep, the only thing you can't do is backreferences
[11:42:43] <ssbr_> dbaupp: it's easier to find the shortest or longest match than to find the PCRE-style match
[11:43:04] <ssbr_> kimundi: I'm not sure I like this API because of the explosion
[11:43:29] <dbaupp> wouldn't/couldn't the non-greediness be a property of the regex, rather than have special methods for it?
[11:43:53] <ssbr_> 3 match anchorages, times 3 disambiguation rules (shortest/longest/perl), times three return values (bool, indices, string slice) ?
[11:44:40] <ssbr_> dbaupp: tbh I'm not too clear what greedy means for a regex
[11:44:40] <kimundi> ssbr_: It would only explode for static regular expressions, and if thats an problem you could either have a flag to disable it on a case-to-case basis, or make the synax extension smarter so that it stuffs the functions unduplicated somewhere else
[11:45:17] <ssbr_> kimundi: well, what about submatch extraction?
[11:45:26] <ssbr_> kimundi: this API looks to be for regexes that don't have any capturing groups
[11:45:26] <dbaupp> ssbr_: 'a.*b'.match('abxxb') = 'abxxb' (greedy), or 'ab' (non-greedy)
[11:45:40] <ssbr_> dbaupp: right, but really we're talking about whether or not that * operator is greedy
[11:45:44] <kimundi> ssbr_: Have left that out for now, but it should be possible with generics I think
[11:45:49] <ssbr_> what does it mean for "a.*b.*c" to be greedy or nongreedy?
[11:46:13] <kimundi> ssbr_: Gimme a bit more time for the submatch stuff :)
[11:46:16] <dbaupp> ssbr_: oh. so shortest match of that could be different to both *'s being nongreedy?
[11:46:35] <dbaupp> that doesn't seem correct
[11:46:38] <aatch> dbaupp, I added some more to the format stuff. Specifically traits for formatting.
[11:46:42] <ssbr_> dbaupp: no, I think it should be the same
[11:47:21] <ssbr_> dbaupp: but I feel like greediness is a description of an operator, not a regex
[11:47:33] <dbaupp> ssbr_: so I'm saying that no shortest/longest match distinction in the API, just mark the *'s as non-greedy or not in the RE itself
[11:47:43] <aatch> '*?'
[11:47:43] <ssbr_> with that regex, either, both, or none of the * operators could be greedy, and you'd get different matches as a result
[11:47:51] <dbaupp> aatch: yeah
[11:48:18] <ssbr_> dbaupp: ohhh, in general?
[11:48:19] <ssbr_> uh, let me think
[11:48:34] <dbaupp> ssbr_: I'm talking specifically about kimundi's api proposal with the shortest_match and longest_match methods
[11:48:40] <dbaupp> saying that they aren't needed
[11:48:42] *** Quits: webber46 (webber46@moz-F6310FF0.lha.sgsnet.se) (Quit: webber46)
[11:48:57] <kimundi> ssbr_: Oh wait, do you think the re!() would duplicate the code in all methots? because that would obviously not be the case :)
[11:48:59] <dbaupp> because the match length can be controlled by the greediness of the operators
[11:49:31] <dbaupp> aatch: you're allowed to use more than one file :P
[11:49:38] <aatch> dbaupp, no!
[11:49:41] <aatch> I refuse!
[11:49:43] <ssbr_> dbaupp: well consider the choice operator |
[11:49:56] <kimundi> ssbr_: A trait implementation would compile to one function that is capable of doing all, and the methods just delegate to it.
[11:49:58] <aatch> (I'll split it later maybe)
[11:50:04] <ssbr_> dbaupp: there's no "non-greedy" variant of it that says "take the shortest path"
[11:50:38] <dbaupp> ssbr_: ah, ok, that's what I'm looking for
[11:50:52] <dbaupp> ssbr_: I agree that having both is useful
[11:50:55] <ssbr_> and aside from that, a greedy search should be able to be shorter than a nongreedy search actually
[11:51:00] <dbaupp> (now that I know that :) )
[11:51:21] <ssbr_> although I'm struggling to come up with an example
[11:51:27] <dbaupp> ssbr_: ... intuitively that seems false
[11:51:39] <ssbr_> dbaupp: then I have to come up with an example, don't I!
[11:51:42] <ssbr_> otherwise I'd look silly
[11:52:44] <ssbr_> "a*(aba|b)" on "aba", I suppose
[11:53:06] <ssbr_> but the first example was simpler
[11:53:10] <dbaupp> the greedy version is 'ab'?
[11:53:20] <dbaupp> the non greedy is 'aba'?
[11:53:26] <dbaupp> ah
[11:53:29] <aatch> dbaupp, yep
[11:53:38] <ssbr_> if * is greedy, then "a*' consumes as many as as possible, and then "aba|b" can only match "b"
[11:53:50] <dbaupp> yep, I agree
[11:53:55] <ssbr_> but if "a*" is nongreedy, then "aba|b" can only match "aba"
[11:55:06] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Quit: Leaving.)
[11:56:05] <ssbr_> kimundi: re the submatch extraction
[11:56:12] <aatch> dbaupp, anyway, am I on the right lines for the traits etc.?
[11:56:15] <ssbr_> I guess that would be a standalone impl?
[11:56:37] <ssbr_> well I guess you're working on that
[11:57:26] <kimundi> ssbr_: Probably. Need either a full seperate re_extract!() macro, or something that outputs a generic impl over a tuple.
[11:57:47] <kimundi> ssbr_: Still thinking about that, yeah :)
[11:59:21] <ssbr_> kimundi: how about a regex trait that has three kinds of match methods, and each of those returns an object with the RegexResult trait, which has methods for expanding out the result of a search?
[11:59:34] <ssbr_> this should cut the number of methods by a third
[11:59:39] <ssbr_> and is what python does, anyway
[11:59:50] <jaen> That was what I was about to suggest actually, looking at the discussion
[11:59:51] <ssbr_> s/by a /to a/
[12:00:32] <jaen> That you could either return Some(Match) from which you can extract all match data, like matched text, indices, matched groups, or None
[12:00:53] <jaen> And that would require, like, three kinds of methods, as you suggested
[12:01:03] <heftig> couldn't you make * greedy and offer *? as non-greedy?
[12:01:04] <jaen> BTW do you plan on having named groups?
[12:01:08] <kimundi> ssbr_: I'm not sure what you mean exactly, and not sure if the problem you see with the method explosion is real. It would not duplicate code in the same re!() expansion.
[12:01:42] <ssbr_> jaen: I do. named groups are awesome.
[12:01:56] <ssbr_> but I'm not really officially working on anything yet. I feel pretty inadequate
[12:02:21] <ssbr_> kimundi: well, in the API you posted there were basically two kinds of match types: longest and shortest
[12:02:28] <jaen> Yeah, I use them all the time in Ruby, was more readable than match[2]
[12:02:41] <ssbr_> I'd add a third, for PCRE-style matches (ones that look like what you get from backtracking search)
[12:02:55] <dbaupp> aatch: looks good
[12:03:08] *** Quits: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com) (Quit: Textual IRC Client: www.textualapp.com)
[12:03:17] <aatch> dbaupp, so it more-or-less matches the proposal you made?
[12:03:21] <ssbr_> kimundi: for each match type you define a match method that runs the regex on a string and gives you some kind of result. bool for whether it matches or not, tuple for bounds of the match, slice to get the actual string matched
[12:03:26] <dbaupp> aatch: r? https://github.com/Aatch/rust-fmt/pull/1 :P
[12:03:44] <dbaupp> aatch: yeah, pretty much
[12:03:52] <jaen> ssbr_: you mentioned implementing two regex engines for fun and profit if I remember correctly, I think that's plenty adequate for starters.
[12:03:54] <dbaupp> and it looks like what strcat was suggesting
[12:04:12] <ssbr_> kimundi: it's probably better to instead give an Option<RegexResult>, where RegexResult has methods for getting the bounds of the match, the match as a slice, etc.
[12:04:26] <kimundi> ssbr_: Ah, that would be possible, yeah.
[12:04:28] <ssbr_> kimundi: take a look at http://docs.python.org/2/library/re.html
[12:06:21] <dbaupp> aatch: no bors? the tree could be burning and you'll never know!
[12:06:29] <ssbr_> jaen: as long as there are people to keep me doing the Rusty thing, I can't go too badly I guess :)
[12:06:31] <aatch> dbaupp, lol
[12:06:56] <kimundi> ssbr_: Seperating longest/shortest seems like a good idea. We just need to be careful to not mix the semantic of the res to much.
[12:07:41] *** Joins: acrichto (acrichto@moz-FE112B96.res.cmu.edu)
[12:07:42] <kimundi> ssbr_: Making a version two of my draft atm.
[12:07:48] <ssbr_> kimundi: as long as the result only has information that came from executing a search, I don't think it can go too poorly
[12:07:57] <jaen> Hahaha, "do the Rusty thing", that has a nice ring to it ; d
[12:08:04] *** Quits: noam__ (noam@F6B530A7.720527A7.416762B.IP) (Ping timeout)
[12:08:22] <ssbr_> jaen: is there no existing phrase for "idiomatic and sane in Rust"? :(
[12:08:29] <ssbr_> I figured if there was one, "Rusty" would be it
[12:08:33] *** Joins: RUSTASTIC (Mibbit@moz-AB722A1C.mc.videotron.ca)
[12:08:50] <kimundi> rustic gets thrown around as well
[12:09:03] <jaen> ssbr_: frankly I'm not sure if any is set in stone, but I've seen rustic being used
[12:09:05] <aatch> ssbr_, I think we're still figuring out what is actually idiomatic in rust.
[12:09:25] <ssbr_> rustic is a good one
[12:09:39] <ssbr_> kimundi: Oh, also, there needs to be a way of passing compilation options to re!()
[12:10:06] *** Joins: zakora (NC@moz-8EAF945F.fbx.proxad.net)
[12:11:23] <ssbr_> at least flags, but maybe also keyword options?
[12:11:38] <ssbr_> (keyword options as in "setting=value" assignments)
[12:11:40] <kimundi> ssbr_: Sure, but better keep a list of those improvements, my memory is to poor to remeber it later xD
[12:12:13] *** Joins: FrozenCow (FrozenCow@moz-9DF5D010.dynamic.upc.nl)
[12:12:26] <ssbr_> kimundi: I should write the email saying I want to write a std regex module, so that we can easily discuss this on rust-dev as part of that free-form discussion thing
[12:12:53] <kimundi> ssbr_: At the moment I'm basically fleshing out an api for re2!(), really. After that I'm gonna try to generalise it more. :)
[12:13:17] <kimundi> Yeah, that'd be best
[12:14:02] <bjz> kimundi: that looks pretty neat
[12:14:37] <bjz> (just saying) :)
[12:14:46] <kimundi> thanks :)
[12:16:41] *** Quits: int3_ (int3_@moz-1692740B.subnet-248.amherst.edu) (Client exited)
[12:18:47] *** Joins: guestish (guestish@98D87E0.F0137D7B.7B0FE12A.IP)
[12:19:31] <guestish> i know this is not right channel but. i believe there may be some people can answer my question.
[12:19:43] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[12:19:49] <guestish> i installed the visual studio 2012 pro trial. compilation finished but it gives me "No rule to make target 'pgo-profile-run'. Stop." [profiledbuild] Error2. if i click firefox.exe. an eroor says "firefox can't open because pgort110.dll doesn't exist in your computer"
[12:20:08] <aatch> guestish, wrong channel
[12:20:18] <aatch> you want #firefox
[12:20:38] <guestish> aatch, yeah. they are saying me go to much more technical channel
[12:20:54] <guestish> i also asked it in #introduction
[12:21:04] <aatch> Unfortunately we're for the rust language
[12:21:10] *** Quits: dbaupp (Thunderbir@moz-91B99879.lns20.syd6.internode.on.net) (Ping timeout)
[12:21:15] <aatch> I don't even use firefox
[12:21:21] *** Joins: dbaupp (Thunderbir@moz-91B99879.lns20.syd6.internode.on.net)
[12:24:32] *** Parts: guestish (guestish@98D87E0.F0137D7B.7B0FE12A.IP) (Leaving)
[12:24:58] <aatch> dbaupp, where should the implementations for the format traits go?
[12:25:25] <aatch> in the fmt module, or str/num?
[12:26:08] <dbaupp> aatch: I'm just experimenting with them now
[12:26:19] <dbaupp> for the moment, in the fmt module, I guess
[12:26:28] <kimundi> aatch: I'd say in a own module in core
[12:26:38] <kimundi> core:format or somethiing
[12:26:51] *** Quits: boggle (boggle@moz-BCEB49E4.dip0.t-ipconnect.de) (Quit: boggle)
[12:27:09] <aatch> kimundi, well there will be core::fmt eventually.
[12:27:24] <aatch> That currently has `parse` and `printf`
[12:29:21] <kimundi> aatch: Ah wait, I misread you question, sorry :) Generally I'd say, if the trait is intended for anyone to implement, put the impls next to the type. If it's just for a specific set of types and not intended to be used by anyone else, put it next to the trait
[12:29:40] *** Joins: SimonSapin (simon@moz-C4A83ED9.net-89-2-126.rev.numericable.fr)
[12:31:01] <aatch> kimundi, that was my reasoning.
[12:31:10] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[12:31:11] <aatch> dbaupp, what are you experimenting with?
[12:31:26] <aatch> So I duplicate work
[12:31:33] <ssbr_> mmmf. Where should I look for unicode support in rust?
[12:31:38] <aatch> I /don't/ duplicate work
[12:31:42] <aatch> ssbr_, core::unicode
[12:31:45] <ssbr_> aatch: thanks
[12:31:46] <aatch> it's not in the docs
[12:31:59] <ssbr_> oh.
[12:32:04] <ssbr_> that'd explain why I still can't find it
[12:32:11] * ssbr_ browses the source tree
[12:32:35] <aatch> I figured that's why you were asking
[12:34:39] <dbaupp> aatch: impls
[12:34:56] <dbaupp> (for the core types)
[12:35:06] <aatch> dbaupp, fair enough.
[12:35:14] <dbaupp> currently I'm fighting the bit where all writers are trait objects
[12:35:15] <ssbr_> that isn't a lot of unicode support :(
[12:35:27] <ssbr_> just a transcription of the character property database?
[12:35:29] <dbaupp> and trait objects don't become &Trait easily
[12:35:50] <dbaupp> ssbr_: it's better than nothing (?)
[12:35:58] <ssbr_> It definitely is!
[12:36:10] <ssbr_> I've just never implemented the unicode algorithms I'd want, before
[12:36:13] <aatch> I might investigate what to change in fmt!
[12:36:35] <ssbr_> (normalization, case folding, etc. etc.)
[12:36:46] <ssbr_> they probably aren't that important for now anyway
[12:37:07] <aatch> ssbr_, you may be able to extend the support, it's generated from etc/unicode.py
[12:38:10] <ssbr_> well, also, I would probably want the private statics from unicode :(
[12:38:38] <kimundi> ssbr_: Well, make it public then :)
[12:38:50] <kimundi> ssbr_: Nothing in the lib is set in stone
[12:38:50] <ssbr_> kimundi: you're such a cowboy
[12:39:01] <ssbr_> fair enough
[12:39:07] <ssbr_> anyway, it has the bare minimum, that's good!
[12:39:18] <ssbr_> well, except I don't know how to do simple case folding
[12:39:25] <ssbr_> oh well
[12:39:28] <ssbr_> Thanks :)
[12:42:32] <aatch> wow extfmt is weird
[12:42:37] *** Quits: jensnockert (jensnocker@CC60FA7.C48F2496.6049AABB.IP) (Connection reset by peer)
[12:42:49] *** Joins: jensnockert (jensnocker@CC60FA7.C48F2496.6049AABB.IP)
[12:44:04] <kimundi> ssbr_: I attempted to introduce stubs for case folding recently, but it got rejected because there isn't jet a solution for these bigger complicated unicode stuff yet, and because it's not clear if that's even supposed to go in core.
[12:44:27] <ssbr_> kimundi: bigger complicated unicode stuff, like...?
[12:44:37] <kimundi> ssbr_: well, case folding
[12:44:44] <kimundi> normalisation
[12:44:46] <ssbr_> well, simple unicode case folding is easy enough
[12:44:48] <kimundi> etc
[12:44:55] <ssbr_> the other one is not so easy
[12:45:01] <ssbr_> kimundi: harrumph :(
[12:45:01] <kimundi> ssbr_: Not really
[12:45:16] <ssbr_> kimundi: no? I thought it was just a mapping from characters to characters that's defined in some text file
[12:45:21] <ssbr_> I don't know that much though
[12:45:28] <kimundi> ssbr_: 'i' != 'I' depending on locale
[12:45:40] <ssbr_> kimundi: isn't there a locale-independent version of case folding?
[12:45:56] <ssbr_> that might be wrong in certain locales?
[12:46:06] <kimundi> ssbr_: You could define a default/english locale
[12:46:21] <kimundi> ssbr_: That was my attempt at least
[12:46:39] <ssbr_> kimundi: it looks like that's what unicode does as well
[12:46:47] <aatch> dbaupp, do you have any ideas on how to handle non-static format strings?
[12:46:55] *** Joins: int3_ (int3_@moz-1692740B.subnet-248.amherst.edu)
[12:46:58] <ssbr_> actually, no, sorry
[12:46:59] <ssbr_> wrong paragraph
[12:47:01] <ssbr_> kimundi: "By contrast, case folding, which is based on the lowercase mapping, is intended to be language-neutral. Since the case folding rules do not vary by language or context, this makes them unsuitable as the basis for displaying or transforming text for human consumption."
[12:47:21] <kimundi> ssbr_: Anyway, the only case folding in rust atm is 'a'.to_ascii().eq_ignore_case('A'.to_ascii())
[12:47:28] <ssbr_> there's also a default case mapping for doing things like to_upper and to_lower
[12:47:43] <ssbr_> without respect to locale
[12:47:54] <kimundi> ssbr_: Where do you get that info
[12:48:05] <ssbr_> kimundi: http://www.unicode.org/faq/casemap_charprop.html#5
[12:49:26] <dbaupp> aatch: in fmt! I think failing would be appropriate
[12:49:27] <indutny> ok, so flate::inflate_bytes doesn't play well with zlib deflate :)
[12:49:32] <indutny> who can I bug about it?
[12:49:51] <dbaupp> indutny: probably no-one :(
[12:49:52] <aatch> dbaupp, did you see the posts on rust-dev
[12:50:06] <aatch> about localization?
[12:50:09] <indutny> haha
[12:50:13] <indutny> ok, I'll figure it out myself then
[12:50:14] <dbaupp> indutny: it's an "external" C++ library just copied into the runtime
[12:50:18] <dbaupp> aatch: yeah
[12:50:42] <dbaupp> I was thinking the localization would give static format strings
[12:50:51] <dbaupp> (well, more hoping)
[12:50:54] <indutny> ah, I see
[12:51:39] <dbaupp> indutny: https://github.com/mozilla/rust/blob/master/src/rt/miniz.cpp
[12:51:43] <indutny> I see it
[12:51:47] <indutny> thank you
[12:51:55] <aatch> dbaupp, well at the moment, it'll fail on anything that isn't a string literal
[12:52:21] <dbaupp> aatch: yes
[12:52:37] <dbaupp> but the localisation could be a syntax extension also
[12:52:46] <dbaupp> (which would give it magic powers! :D )
[12:52:54] <aatch> seems a bit too hacky
[12:53:09] *** Quits: int3_ (int3_@moz-1692740B.subnet-248.amherst.edu) (Ping timeout)
[12:53:42] <aatch> fmt! makes sense because you need variable arguments and similar
[12:54:16] *** Joins: bbrittain (ben@moz-632384CB.dr02.roch.ny.frontiernet.net)
[12:54:37] <dbaupp> aatch: langfmt!(lang, "string", foo, bar, foo, bar)?
[12:55:20] <aatch> how would that work?
[12:55:23] <dbaupp> aatch: possible with a corresponding registerlangs!(directory/name); that contains files that match the various langs
[12:55:34] <aatch> ok then
[12:55:51] <aatch> well, one thing at a time.
[12:55:53] <dbaupp> aatch: no idea... I've literally never used a gettext-style library, so I'm making it up as I go along
[12:56:05] <dbaupp> also, https://github.com/Aatch/rust-fmt/pull/2
[12:56:22] <dbaupp> (they're a bit stupid, and @Writers are a virus)
[12:56:34] <kimundi> ssbr_: Updated an issue with that link: https://github.com/mozilla/rust/issues/5820
[12:56:46] <aatch> Yeah, I just copied from the mail
[12:57:14] *** Quits: Boreeas (Boreeas@moz-F35C832D.boreeas.net) (Ping timeout)
[12:57:27] <dbaupp> I'm really looking forward to the rewrite that destroys the compulsory @'s in the io stuff
[12:57:46] <ssbr_> dbaupp: wooooo
[12:57:46] *** Quits: jensnockert (jensnocker@CC60FA7.C48F2496.6049AABB.IP) (Input/output error)
[12:57:47] <aatch> dbaupp, same.
[12:57:58] <ssbr_> being able to do a "hello world" embeddable library would be neat ;)
[12:58:13] <ssbr_> kimundi: sweet!
[12:58:55] <dbaupp> aatch: I guess the desired types are something like fn format_x<W: Writer>(&self, w: &W, s: Spec)?
[12:59:16] <dbaupp> probably &mut W, even
[12:59:38] <aatch> dbaupp, maybe.
[12:59:54] <aatch> Depends on how the io re-write turns out
[13:00:17] <aatch> I'll live with @Writer for now though
[13:00:17] *** Joins: Boreeas (Boreeas@moz-F35C832D.boreeas.net)
[13:02:08] *** Quits: KindOne (KindOne@moz-6634B660.dynamic.ip.windstream.net) (Ping timeout)
[13:02:40] <kimundi> ssbr_: I updated my api design with a sample expansion of a re!() invokation: https://gist.github.com/Kimundi/5517223 (Haven't yet seperated shoretst, longest etc, I'm slow :P)
[13:03:52] <aatch> dbaupp, oh, also. Since we want to avoid needless allocation (for printing, etc) would changing the macros to something more like printf! fprintf! and sprintf! make more sense?
[13:04:35] <aatch> (which would all delegate to one, probably fprintf, which would take a Writer)
[13:04:40] <dbaupp> yes
[13:04:43] <dbaupp> and yes
[13:05:13] *** Quits: zakora (NC@moz-8EAF945F.fbx.proxad.net) (Quit: Computer has gone to sleep.)
[13:05:26] <dbaupp> (not sure about the names, although there's probably no reason to not follow convention)
[13:05:39] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[13:05:49] <aatch> names are easy enough to change
[13:06:12] *** Joins: KindOne (KindOne@moz-AAA92C5A.dynamic.ip.windstream.net)
[13:06:27] <kimundi> I'd hate to loose fmt!() for sprintf!() :|
[13:06:34] <dbaupp> aatch: correct
[13:06:47] <dbaupp> kimundi: that was my concern too
[13:07:10] <dbaupp> those 4 extra letters are too much
[13:07:17] <dbaupp> :P
[13:07:21] <kimundi> prinf! is fine, but the basic shoul ba around fmt!(), not print
[13:07:32] <kimundi> should be*
[13:07:48] *** Quits: pnkfelix|rcirc (pnkfelix@moz-43495417.fbx.proxad.net) (Ping timeout)
[13:08:35] <aatch> kimundi, so how about the problem is trying to find decent names around fmt
[13:08:55] <aatch> dammit, forgot to delete the start of the sentence
[13:09:07] <aatch> ignore "so how about the"
[13:09:36] <kimundi> well, what functions are there?
[13:09:57] <dbaupp> kimundi: I assume 'printfmt' ? etc
[13:10:23] <aatch> Well there's only 3 main ones, one that writes to a string, one that writes to stdout and one that writes any writer
[13:10:25] <kimundi> dbaupp: Well For that I'd see printf as the better choice.
[13:10:33] <dbaupp> aatch: also, presumably fprintf would take a writer, not just a file
[13:10:36] <dbaupp> kimundi: I agree
[13:10:40] <aatch> the first two delegate to the last
[13:10:48] <kimundi> aatch: fmt!, printf!, writef!
[13:10:52] <dbaupp> aatch: so wprintf or something
[13:10:59] <dbaupp> kimundi: writef is nice
[13:11:11] <aatch> dbaupp, no reason not to have writef! take a writer
[13:11:20] <aatch> since all files /should/ be writers
[13:11:30] <dbaupp> aatch: correct, just 'fprintf' suggests files only
[13:11:39] <dbaupp> (and here we are talking about names! :P )
[13:11:46] <aatch> dbaupp, :(
[13:12:53] * aatch is looking through ext::fmt
[13:13:03] <aatch> I will be glad when this dies
[13:13:39] <dbaupp> aatch: yep
[13:14:03] <dbaupp> a lot of the ext stuff is... strange
[13:14:12] <aatch> I really don't like the "define a bunch of helper fns at the beginning of the function" patter in rustc
[13:14:15] <kimundi> I would choose fmt!, printf!, writef!, because the first one looks conceptually like the core building block. You format a string. The others are used as if they build on that functionality. The fact that writef! would be the core in the implementation is just an implementation detail
[13:14:17] <aatch> pattern*
[13:14:29] *** Joins: roselan (Mibbit@moz-F476CEA3.dclient.hispeed.ch)
[13:14:42] <aatch> kimundi, agreed. Would writef! taking a writer make sense?
[13:14:44] <dbaupp> aatch: yeah, doing it at the start makes reading it hard... I find doing it at the end isn't so bad
[13:14:55] <aatch> dbaupp, same
[13:15:03] <kimundi> aatch: writef would have to take a writes as first argument.
[13:15:58] <aatch> kimundi, yup, just ensuring that it makes sense to take a Writer instead of a file
[13:16:11] <kimundi> aatch: or maybe something like writef!("foo %d, bar: %?", 15u, Some(true) -> writer);
[13:16:28] <roselan> hi, discovering rust. the tutorial "match" tutorioal shows "1 | 2 => io::println("one or two"),"... shouldn't that be 1 || 2?
[13:16:36] <kimundi> aatch: Oh, that yes. just a generic writer, no file, way to specific. :)
[13:16:38] <aatch> roselan, nope
[13:16:51] <dbaupp> presumably we could also do C++ style iostreams 'writer << foo << "str" << blah'
[13:16:53] <doomlord> helper functions?  i made "print!(.... )"  , i found that pretty natural, just an n-ary print, maybe that can be different from *formated* print
[13:16:59] <engla> writef would just be a simple wrapper into  |w, ...| { w.write(fmt!(...)) } ?
[13:17:09] <engla> dbaupp: and repeat C++'s worst mistake? :-(((
[13:17:12] <doomlord> i was considering doing an n-ary call taking an object and method, 
[13:17:21] <dbaupp> engla: really worst mistake?
[13:17:25] <doomlord> nary!(output, print,  inputs.......)
[13:17:30] * dbaupp hasn't use C++ very much at all
[13:17:32] <engla> yes, using << for streams is up there
[13:17:41] <doomlord> C++ fail:-
[13:17:42] <kimundi> doomlord: Well print!() would conflict with regular print(), so printf!() its goung to be.
[13:17:46] <roselan> @aatch thanx
[13:17:53] <doomlord> while (stream>>value) { ..... }  <<<< can you guess what that does
[13:17:59] <aatch> doomlord, the difference is that printf! and writef! would write straight into writers
[13:18:06] <dbaupp> engla: but they're like arrows and everything ;P
[13:18:36] <engla> splitting the output that way is also useless for localization
[13:18:45] <dbaupp> (I don't know much about C++, so I'll defer to more experienced people's judgement and unsuggest using << )
[13:18:46] <kimundi> engla: writef would not use fmt!, other way round
[13:19:16] <doomlord> will you have an *unformated* print in addition to the formated versions
[13:19:27] <engla> kimundi: ok.. I didn't think about that. Would be simple to implement writef using fmt! today
[13:19:27] <kimundi> engla: No need to allocate a string if you can just  push every byte to some writer
[13:19:31] <aatch> doomlord, printf!("Only arg")
[13:19:32] <engla> true
[13:19:50] <dbaupp> engla: yes, probably
[13:20:07] <doomlord> could i suggest printn!(..) or something like that
[13:20:24] <kimundi> doomlord: I'd assume regular core::io::print() will remain unchanged.
[13:20:39] <kimundi> like wise println()
[13:20:44] <dbaupp> doomlord: is this the equivalent of printf("%? %? ... %?", a, b, ..., z)?
[13:20:54] <doomlord> are you saying print! conflicts with print - doesn't Rusts' use of ! for macros disambiguate it
[13:21:17] <aatch> doomlord, I think he means formatted vs unformatted
[13:21:18] <kimundi> doomlord: Well, tis the same identifier.
[13:21:20] <engla> it conflicts conceptually :)
[13:21:34] <kimundi> I thought it would conflict.
[13:21:54] <aatch> doesn't conflict because it's expanded at parse
[13:21:56] <doomlord> i've currently got *dbprint!* actually , but i'm not suggesting that as a default for everyone
[13:22:28] <kimundi> But even if it doesn't, having print and print! being different will be confusing
[13:22:41] <aatch> kimundi, I agree.
[13:26:09] *** Quits: bbrittain (ben@moz-632384CB.dr02.roch.ny.frontiernet.net) (Ping timeout)
[13:27:06] *** Joins: EXetoC (ex@moz-2DBEB1E4.customer.t3.se)
[13:27:51] <dbaupp> aatch: I typo'd crate as create in mod.rs
[13:28:01] <engla> :w
[13:28:03] <dbaupp> (not worth a pull request)
[13:28:35] <aatch> dbaupp, not even worth doing locally
[13:28:52] <dbaupp> aatch: it changes the behaviour of rustc
[13:29:16] <dbaupp> (in #[cr(e)ate_type..])
[13:29:21] <aatch> dbaupp, no, i mean i used github's editor
[13:29:53] <dbaupp> oh, right
[13:33:40] *** Joins: jensnockert (jensnocker@CC60FA7.C48F2496.6049AABB.IP)
[13:36:58] *** Joins: jensnock_ (jensnocker@moz-49A419C6.mobileonline.telia.com)
[13:37:50] *** Quits: jensnockert (jensnocker@CC60FA7.C48F2496.6049AABB.IP) (Ping timeout)
[13:38:42] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[13:39:53] *** Joins: hmax (hmax@moz-15514FA1.yandex.net)
[13:41:33] <doomlord> what would i call my n-ary unformated print! to avoid conceptual conflict.. printn perhaps
[13:41:52] <kimundi> doomlord: What would it do?
[13:42:34] <doomlord> printn!(1,"foo",10.0) ===>  "1 foo 10.0" 
[13:43:29] <kimundi> Ig uess it uses %? ? 
[13:43:34] <doomlord> currently in my code thats "dbprint!(..)" , i just find it handy
[13:44:12] <doomlord> its just a macro to repeatedly print each argument
[13:44:20] <kimundi> print_any!() ?
[13:44:26] <doomlord> printn(a,b,c...) = print(a) print(b) print(c) ...
[13:44:29] <aatch> print_all!
[13:44:45] <kimundi> doomlord: Ah, that's different then
[13:45:00] <kimundi> doomlord: THen it just works with strings?
[13:45:02] <doomlord> actually i've specified it slightly wrong there.. there is a seperator
[13:45:16] <doomlord> yes its purely a convinience for geting debug values out
[13:45:54] *** Joins: akashj87_ (akash@DD39A07A.BCDF8B4F.35E3DDC8.IP)
[13:45:55] <doomlord> but i was thinking of making a generalized n-ary 'apply something...' macro too
[13:46:07] <doomlord> call this function on each of these arguments..
[13:46:29] <doomlord> eg nary(print, a,b,c,...)  ===> print(a) print(b) print(c) ...
[13:46:41] <doomlord> n_ary perhaps
[13:46:51] <kimundi> print_list!("foo", 5u, true) -> {printf!("%?, ", "foo"); printf!("%?, ", 5u); printf!("%?", true); }  ?
[13:46:57] *** Quits: akashj87 (akash@48AB7F3B.7FACFDC5.35E3DDC8.IP) (Ping timeout)
[13:47:34] <kimundi> doomlord: n_ary!() sounds like a useful contribution.
[13:47:39] *** Quits: sonwow (sonwow@5AB4884B.FCC4549.14D5B978.IP) (Quit: Lost terminal)
[13:48:00] <doomlord> more uses than print alone i guess..
[13:48:42] <doomlord> i always wished the C macro system could do that sort of thing properly, (variadic templates help)
[13:49:33] <kimundi> n_ary!(|x| print(fmt!("%?, "), x) for true, 5u, "string", Some(42f32), ());
[13:50:27] <dbaupp> ssbr_: nice write-up
[13:50:40] <ssbr_> dbaupp: oh, you saw that already!
[13:50:47] <ssbr_> I'm still writing the email to Rust-Dev
[13:50:54] <kimundi> Or I guess n_ary!(|x| printf!("%?, ", x) for true, 5u, "string", Some(42f32), ());
[13:51:12] <dbaupp> ssbr_: yeah, it came up on my github front page
[13:51:19] <aatch> dbaupp, I just realized that '*' can be used as a flag/specifier
[13:51:38] <doomlord> where does the 'for' come into the syntax above out of interest, i thought i knew what the |x| does :)
[13:51:41] <aatch> because it's only inside '[' ']' otherwise
[13:51:54] <dbaupp> aatch: ooh yes
[13:52:03] <dbaupp> aatch: is there a good thing for it?
[13:52:13] <kimundi> doomlord: Well it's a macro, you can use any syntax :)
[13:52:14] <doomlord> or are you suggesting that as part of the macro
[13:52:29] <doomlord> ok thats helpful
[13:52:45] * kimundi shouldn't be a macro author. Too much freedom.
[13:52:51] <doomlord> wow you could make it read well
[13:53:33] <kimundi> n_ary!(apply |x| printf!("%?, ", x) for true, 5u, "string", Some(42f32), ()) maybe?
[13:53:36] <aatch> dbaupp, I was thinking maybe for a flag meaning "rest of the arguments as <rest of specifier>"
[13:53:48] <doomlord> yeah apply ... to  is what i had in mind
[13:54:13] <doomlord> apply!(|x|printf!(..)  to true,5u,"string",Some(42f32),())
[13:54:24] <dbaupp> doomlord:  `n_ary!(please do |x| printf!("%?, ") to these items: true, 5u, "string" and ())'
[13:54:44] <aatch> so '%*s' would just convert the rest of the arguments as strings
[13:54:56] <kimundi> dbaupp: hehe :)
[13:55:00] <dbaupp> aatch: i.e. printf!("%d %*?", 1, Some(2), None)?
[13:55:09] <aatch> dbaupp, yep
[13:55:17] <dbaupp> hm
[13:55:18] <aatch> I could see it being useful for debugging.
[13:55:25] <doomlord> apply would confuse lispers, as they have it different already , i think lisp (apply f a b c) is (f a b c), i may have missed some quotes
[13:55:41] <dbaupp> aatch: I was thinking a dump!(x, y, z) might serve that purpose
[13:55:43] *** Quits: sdh_ (sdh@C957F273.8BDB8EF1.A76F6622.IP) (Quit: Konversation terminated!)
[13:55:43] <doomlord> its more like map, but still different
[13:55:59] <kimundi> aatch: Maybe replicate the macro repitition syntax a bit?
[13:56:00] <dbaupp> (which just formats each arg as %?)
[13:56:09] <ssbr_> kimundi: dbaupp: any second now, rust-dev should be getting an email from me about adding a re module to std
[13:56:24] <dbaupp> ssbr_: yay :D
[13:57:32] <kimundi> aatch: fmt!("%*?" 1, 2, 3, 4) -> "1234";  fmt!("%*{, }?" 1, 2, 3, 4) -> "1, 2, 3, 4"; 
[13:57:54] <dbaupp> doomlord: clojure's apply is (apply f '(a b c))
[13:58:14] <doomlord> ok
[13:58:18] *** Joins: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com)
[13:58:18] *** Quits: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com) (Quit: tgt)
[13:58:19] <dbaupp> kimundi: that looks a lot like common lisps formats
[13:58:54] <dbaupp> if we are going down that line, I think moustaches would be useful, so that the specifiers and flags have more freedom
[13:58:56] *** Quits: jensnock_ (jensnocker@moz-49A419C6.mobileonline.telia.com) (Connection reset by peer)
[13:58:57] <kimundi> dbaupp: Well, I wouldn't know that :)
[13:59:09] *** Joins: jensnockert (jensnocker@moz-49A419C6.mobileonline.telia.com)
[13:59:16] <dbaupp> kimundi: (neither would I, just someone pointed me to the wiki page yesterday)
[13:59:26] <aatch> kimundi, could we change that to fmt!("%*(?, %)", 1, 2, 3) -> "1, 2, 3"
[14:00:03] <doomlord> is apply! already taken in rust-land ? would apply!(|x|foo() to a, b, c, d ,...) confuse anyone as  foo(a) foo(b) foo(c) ..
[14:00:42] <kimundi> aatch: Whatever syntax fits best to the rest I guess. But why the second '%' ?
[14:01:07] <dbaupp> ssbr_: what are the chances! someone sent an email to rust-dev about re's ;P
[14:01:21] <aatch> kimundi, well the first specifier stops at ? so you need another to match
[14:01:40] *** Joins: bbrittain (ben@moz-632384CB.dr02.roch.ny.frontiernet.net)
[14:01:48] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Ping timeout)
[14:02:14] <ssbr_> dbaupp: what a shocking coincidence
[14:02:23] <kimundi> aatch: I don't understand :(
[14:02:42] <ssbr_> they even stole my name. (is it an identity thief? wow!)
[14:03:01] <dbaupp> ssbr_: I was extremely surprised, since you'd been talking about it only a few minutes ago
[14:03:16] <dbaupp> I think you should change the password on your email
[14:03:45] <kimundi> aatch: You mean something similar to  fmt!("%*{%?, }" 1, 2, 3, 4) ?
[14:03:45] <ssbr_> oh dear me
[14:04:01] <ssbr_> kimundi: sorry, I'm just getting to your second draft now
[14:04:06] <ssbr_> I wanted to get the email out of the way
[14:04:24] <kimundi> ssbr_: Don't worry, you didn't miss much
[14:04:49] <kimundi> ssbr_: Didn't start any second draft yet, just wrote an example at the end of the first
[14:05:21] <ssbr_> Oh.
[14:05:45] <fread2281> https://gist.github.com/fread2281/5516314 help
[14:07:19] <ssbr_> kimundi: so it depends a little on what is considered the expensive part of regex compilation
[14:07:20] <dbaupp> fread2281: have you tried putting type annotations on everything?
[14:07:34] <ssbr_> hm
[14:07:42] <ssbr_> no, I guess mostly you'd care about execution
[14:07:48] <fread2281> dbaupp: yep
[14:08:02] <dbaupp> fread2281: and that's the whole output of rustc?
[14:08:14] <ssbr_> I was wondering if maybe one would want re!() to compile the regex to the bytecode that is interpreted, but not necessarily to rust code, but that's not very useful in general
[14:08:28] <fread2281> dbaupp: ues
[14:08:32] <fread2281> *yes
[14:08:33] <aatch> kimundi, the issue is that '{' and '}' aren't valid unless they are for the position of the argument. Also, the flags system isn't well-suited to having an arbitrary run of characters since it doesn't allow duplicate flags
[14:08:42] <fread2281> it should really say what value...
[14:09:16] <dbaupp> fread2281: I agree
[14:09:18] <Diablo-D3> hrm
[14:09:22] <dbaupp> fread2281: also, why do you need generic path?
[14:09:26] <Diablo-D3> okay, so, since rust uses threads internally
[14:09:36] <ssbr_> kimundi: man, objects/traits are cool :)
[14:09:40] <kimundi> aatch: Oh, I don't know how your system works in detail, I view {} () [] as interchangeable
[14:09:49] <dbaupp> fread2281: path::Path automatically points to the platform appropriate path
[14:09:51] <Diablo-D3> does this mean it has cross compiler support for thread local variables?
[14:09:55] <aatch> kimundi, so you'd have a special flag '(', which is a marker and the a specifier %) to mark the end
[14:09:57] <kimundi> ssbr_: :)
[14:09:58] <fread2281> dbaupp: oh
[14:10:25] <dbaupp> aatch: I feel like this is getting super complicated
[14:10:36] <kimundi> aatch: Ahhh... Now that I understant the syntax, allow me ts recoil in horror: URRRG!
[14:10:44] <aatch> dbaupp, it's a "this could be done"
[14:10:51] <aatch> not a "We'll do this"
[14:11:32] <aatch> kimundi, what specifically are you recoiling at?
[14:11:34] <dbaupp> aatch: maybe '%{ ... }' syntax, so that stuff inside the {} can basically do anything, so we don't require the contortions to fit the formats into single characters?
[14:11:55] <dbaupp> (possibly disallowing nesting {} to keep the parser simple)
[14:12:10] <kimundi> aatch: Could't you say 'if the flag is *, parse a following () pair and apply its inside for the rest of the input' ?
[14:12:27] <aatch> kimundi, I could, but I want the parser to be generic
[14:12:36] <aatch> I'm not a fan of the rules added already
[14:13:02] <kimundi> aatch: The part where "%(" and "%)" are seperate tokens, and not part of the same delimiter rule.
[14:13:55] <Yurume> dbaupp, for the reference, Boost.Format uses %|...| for that purpose
[14:14:02] <kimundi> aatch: Hmm. I guess at this point I simply don't mean what 'being generic' would mean here.
[14:14:12] <Yurume> cf. http://www.boost.org/doc/libs/1_53_0/libs/format/doc/format.html#syntax
[14:14:18] <dbaupp> Yurume: I was just thinking that | would work too :)
[14:14:42] <aatch> More specifically, I volunteered for it because I'm also working on a datetime library and would have needed a printf-style parser for date formatting
[14:14:51] <Yurume> so %d (legacy) == %|d| (new) == %1% (type-safe auto-infer alternative)
[14:15:30] <kimundi> aatch: %*() could be special cased as syntactic sugar in the parser, that expands to all remaning arguments
[14:16:42] <aatch> kimundi, I don't understand. the parser only knows about format strings
[14:16:55] <kimundi> Assuming there aren't N other kinds of operation where you want something similar, that sounds like not too bad.
[14:17:28] <kimundi> aatch: And %*() would be a special cased format string
[14:18:23] <aatch> kimundi, with what meaning?
[14:18:27] <fread2281> is there a version of vec::filter that doesn't move?
[14:18:41] <kimundi> aatch: I guess the confusion here is that I don't actually know with wich part of the "formatsring -> formated output" pipeline you're working with :)
[14:18:47] <aatch> fread2281, vec::filtered
[14:19:13] <kimundi> aatch: "Consume all remaining arguments and apply the contents of the () to them"
[14:19:22] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[14:19:22] <doomlord> how would you do 'list comprehension' (filter, map but presumably with opportunity to optimize..) 
[14:19:30] <aatch> kimundi, the parser just takes the "We have %d potatoes" string and gives you "We have " spec(d) " potatoes"
[14:19:37] <kimundi> doomlord: Iterators
[14:20:21] <dbaupp> doomlord: core::iterator, in fact
[14:20:59] <aatch> So there is scope for the fmt! implementation to do things
[14:21:11] <fread2281> dbaupp: https://gist.github.com/fread2281/5516314 huh?
[14:21:49] <dbaupp> fread2281: you need to set filepairs to something, i.e. let filepairs = ~[];
[14:22:06] <dbaupp> rusti: let x: ~[int]; x.push(1); x
[14:22:08] <rusti> more than 5 lines of output, pastebinned: http://sprunge.us/QgXM
[14:22:19] <dbaupp> rusti: let x: ~[int] = ~[]; x.push(1); x
[14:22:20] <rusti> more than 5 lines of output, pastebinned: http://sprunge.us/OPRf
[14:22:24] <dbaupp> rusti: let mut x: ~[int]; x.push(1); x
[14:22:26] <rusti> more than 5 lines of output, pastebinned: http://sprunge.us/gTRK
[14:22:32] <dbaupp> rusti: let mut x: ~[int] = ~[]; x.push(1); x
[14:22:32] <rusti> ~[1]
[14:23:44] <dbaupp> fread2281: you can actually use `let filepairs = do datafiles.map |datafile| { let filename = ; let filename = ; ~[*datafile, ... ] }`
[14:23:54] <dbaupp> and not have to worry about initialising and pushing yourself
[14:24:21] <kimundi> aatch: Then I guess I'm talking about extending the parser to specially expand %*(): fmt!("foo %s bar %*([%?:%?], ) baz", "hello", true, false, Some(5u), ()) ==> fmt!("foo %s bar [%?:%?], [%?:%?],  baz", "hello", true, false, Some(5u), ()) ==> ... 
[14:25:07] <dbaupp> fread2281: and,yes, you need to copy, because otherwise the ownership tree of the ~ pointer is broken (something else owns a portion of what a ~ points to, which is illegal)
[14:25:11] <kimundi> With the analogy being similar to how it's handled in macro definitions
[14:25:40] <aatch> kimundi, unfortunately, that would require the parser to know the number of arguments.
[14:26:38] <kimundi> aatch: Ah, so there is the problem. Hmm. Well it could be told in theory, no?
[14:26:42] <aatch> However, it's possible (as long as '*' isn't a flag) to have "%*(blah blah blah)" be interpreted by the fmt! processor,
[14:27:42] <aatch> Also, about the the %( and %) be separate, that is actually how lisp does it...
[14:28:19] <aatch> (format t "~{~a~^, ~}!" '(hello world))
[14:28:26] <aatch> ;; ⇒ "HELLO, WORLD!"
[14:29:34] <fread2281> dbaupp: seems inefficient :(, would doing a let (datafile, keysfile) = filepair; be better?
[14:30:23] <fread2281> wait, I canit do that :(
[14:30:52] <dbaupp> fread2281: why are you looping through all datafiles if you only need the first one?
[14:31:28] <fread2281> dbaupp: I need all of them: https://gist.github.com/fread2281/5516314
[14:32:30] <dbaupp> fread2281: hm, you can match-destructure to retrieve multiple values from the vec
[14:33:19] <dbaupp> rusti: match ~[1, 2, 3] { [a, b] => { print(fmt!("%? %?", a, b)) } _ => fail!("wrong list") }
[14:33:21] <rusti> rust: task failed at 'wrong list', foo.rs:4
[14:33:21] <rusti> rust: domain main @0x1efe1b0 root task failed
[14:33:25] <dbaupp> rusti: match ~[1, 2] { [a, b] => { print(fmt!("%? %?", a, b)) } _ => fail!("wrong list") }
[14:33:26] <rusti> 1 2
[14:34:21] <dbaupp> rusti: let x = ~[1,2]; let y = x[0], z = x[1]; (y,z)
[14:34:22] <rusti> (1, 2)
[14:34:35] <aatch> you can also use [a,..b,c] to get first and last + the middle as a slice
[14:35:02] <aatch> and any other combination as long as there is only one slice pattern
[14:39:03] <fread2281> rusti: match ~[~1, ~2] {~[foo,bar] => {print(fmt!("%?, %?", foo,bar))}, _ => fail!("nuu")}
[14:39:04] <rusti> more than 5 lines of output, pastebinned: http://sprunge.us/aHeW
[14:39:40] <aatch> rusti: match ~[~1, ~2] {[foo,bar] => {print(fmt!("%?, %?", foo,bar))}, _ => fail!("nuu")}
[14:39:41] <rusti> ~1, ~2
[14:40:05] <dbaupp> fread2281: the ~ isn't needed for vector patterns
[14:40:09] <aatch> (no need for sigils in patterns normally)
[14:40:42] <fread2281> dbaupp: dbaupp https://gist.github.com/fread2281/5516314 ?
[14:41:45] *** Quits: RUSTASTIC (Mibbit@moz-AB722A1C.mc.videotron.ca) (Quit: http://www.mibbit.com ajax IRC Client)
[14:43:03] <fread2281> error: mismatched type: expected `&~[~core::path::PosixPath]` but found vector dafaq?
[14:43:05] *** Quits: quvarxa (chatzilla@moz-5DECE2C.lns20.adl2.internode.on.net) (Ping timeout)
[14:43:33] <dbaupp> fread2281: match *filepair
[14:44:21] <fread2281> dbaupp: error: moving out of dereference of immutable & pointer
[14:44:23] <dbaupp> rusti: let x = &~[1]; match x { &[a] => true, _ => false }
[14:44:24] <rusti> more than 5 lines of output, pastebinned: http://sprunge.us/JKJP
[14:45:24] <dbaupp> fread2281: filepairs.consume
[14:45:32] <dbaupp> fread2281: file:///home/huon/rust/doc/core/vec.html#function-consume
[14:45:37] <Boreeas> I've got code like this: http://pastebin.com/MvTGAFus, but I get "error: use of partially moved value: `import`" in "let after = import.after;"
[14:45:54] <Boreeas> How do I get rid of that error? I would prefer not to copy the image
[14:46:00] <dbaupp> fread2281: (or possibly `for vec::consume(filepairs) |_, filepair|`)
[14:46:06] *** Joins: solancile (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net)
[14:46:37] <dbaupp> Boreeas: let StructName { image, after } = import_result.unwrap();
[14:46:48] <kimundi> Boreeas: Just from that snipped here, I'd say you need to take a pointer to after
[14:46:49] <dbaupp> then `image` and `after` are variables
[14:47:02] <kimundi> or what dbaupp said
[14:47:16] <dbaupp> Boreeas: destructing in let, it's pretty useful :)
[14:47:32] <dbaupp> (it's also pretty dangerous and buggy)
[14:47:50] <cmr> dbaupp: why?
[14:48:03] <dbaupp> Boreeas: so maybe `match import_result.unwrap() { StructName { image, after } => { return Ok(..) } }`
[14:48:08] <dbaupp> cmr: sec
[14:48:10] <cmr> k
[14:48:17] *** Joins: sdh_ (sdh@BCD0EF3B.8A554927.FD6A0EFF.IP)
[14:48:31] <dbaupp> cmr: https://github.com/mozilla/rust/issues/6225
[14:48:43] <jaen> Just wondering with all that fmt! talk, since Rust has macros was there any thought about doing Ruby-like string interpolation, just safely on the compile-time side of things?
[14:49:14] <aatch> jaen, ruby like?
[14:49:19] <dbaupp> cmr: and (a "real world" example) http://www.reddit.com/r/programming/comments/1dcbos/operator_overloading_in_rust/c9qmsu2?context=3
[14:49:31] *** Quits: zxcdw (r-a@moz-C7C5467B.cust.bredband2.com) (Ping timeout)
[14:49:39] <kimundi> ssbr_: Just reading you email on the ML. Nice work! You have put an order of magnitude more work in it than I 'd have :D (Wich of course just means I'm a lazy bum, but nevertheless ;) )
[14:49:43] <Boreeas> dbaupp, kimundi, thanks
[14:49:54] <jaen> As in "2 + 2 = #{2 + 2}" => "2 + 2 = 4"
[14:50:15] <fread2281> dbaupp: error: moving out of dereference of immutable & pointer
[14:50:15] <aatch> jaen, Seems unlikely to happen
[14:50:18] <fread2281> whops
[14:50:18] *** Joins: bheylin (brianheyli@E74A75A2.F993642.98C5AE08.IP)
[14:50:25] <ssbr_> kimundi: thanks! :)
[14:50:30] <aatch> I'm reluctant to throw too much more at format strings
[14:50:56] * Yurume read through past logs
[14:51:06] <ssbr_> although FWIW most of this I already knew from before, I was just collecting it all and writing it down
[14:51:16] <kimundi> aatch: Only stop if a format string is turing complete and can compile rustc! ;)
[14:51:16] <ssbr_> and figuring out what to ask/say <_<
[14:51:22] <Yurume> well, I strongly object to iteration syntax like CL's ~{ ~}.
[14:51:27] <dbaupp> fread2281: what's the code look like now?
[14:51:32] * ssbr_ is playing around with macros atm
[14:51:38] <aatch> Yurume, good, because I'm not going to do it.
[14:51:48] <Yurume> aatch, good to hear that
[14:51:52] <aatch> Plain printf-style formatting for everyone
[14:52:00] <dbaupp> Yurume: I might though :P
[14:52:02] <jaen> aatch: oh well, I more often than not find this easier to read than equivalent printf-like tacking on of expressions to the end of the format strings. But if that's not gonna happen then I'll probably could macro it out myself anyway.
[14:52:23] <kimundi> ssbr_: Note that rusts macros represent a small subset of what's possible with rusts full syntax extensions.
[14:52:33] <Yurume> I have surveyed formatting syntax (and regexp, FWIW) of many programming languages years ago
[14:52:36] <fread2281> dbaupp: https://gist.github.com/fread2281/5516314 I guess I should fix it by doing a datfiles.consume instead of map
[14:52:44] <dbaupp> fread2281: yes
[14:53:28] <ssbr_> kimundi: yes, well, it's more like "hm, I'm defining an enum, and its serialization and deserialization, all at once. Wouldn't it be more DRY to write a macro?"
[14:53:32] <Yurume> and I actually like brace-delimited syntax such as C# String.Format and Python str.format
[14:53:39] <ssbr_> and then I waste time writing a macro
[14:53:50] <Yurume> since it is extensible enough and can be concise at the same time
[14:53:57] <dbaupp> fread2281: you can actually use `.map_consume`
[14:54:21] <dbaupp> (or maybe `vec::map_consume(..)`)
[14:54:27] <kimundi> ssbr_: Hehe, actually for that specific case there is already #[deriving(Encodable, Decodable)] :)
[14:54:32] <Yurume> but if `%`-escaped syntax won't be gone for any reason, I think Boost's %|...| escape is good enough
[14:54:32] <dbaupp> (that will be better than consume)
[14:55:16] <Yurume> there are several schemes (not only CL!) that allows the iteration through the arguments
[14:55:21] * aatch is going to sleep now. Tired out by formatting discussion.
[14:55:46] <Yurume> but they seemed to go too far to wrong direction
[14:55:52] <dbaupp> aatch: dream of % and * and f and d
[14:55:58] <kimundi> aatch: Sleep well, and have '%'-less dreams!
[14:56:09] <Yurume> and in many cases ad-hoc (for example, Perl's %vd...)
[14:56:22] <ssbr_> kimundi: still have to write all those encode/decode functions by hand though, don't you?
[14:56:43] <aatch> The problem with all of these extras is that I'm not convinced they will be used that often
[14:56:54] <kimundi> ssbr_: HOnestly I don't know much more :)
[14:57:07] <ssbr_> as opposed to something like "magic!(enum Foo { Constructor(a: ~str) => ~"(" + a + ~")" } )
[14:57:18] <dbaupp> ssbr_: nope
[14:57:24] <dbaupp> it's all done
[14:57:31] <ssbr_> dbaupp: how do they know what I want it to be serialized as!
[14:57:37] <kimundi> aatch: I could see something like %*(%?) be used ofet instead of some  printn! macro.
[14:57:38] <ssbr_> (I have a specific representation in mind)
[14:57:44] <dbaupp> ssbr_: well, then you can use #[deriving] at all
[14:57:49] <dbaupp> *can't
[14:57:51] <ssbr_> right
[14:57:58] <ssbr_> so... macros, eh?
[14:57:59] *** aatch is now known as aatch|bed
[14:58:11] <dbaupp> (deriving({De,En}codable), you can use the other derivings)
[14:58:19] <dbaupp> ssbr_: is it worth the complexity?
[14:58:28] <ssbr_> dbaupp: no
[14:58:30] <kimundi> ssbr_: Ah, yeah for custom kind of (de)serial stuff, sure :)
[14:58:40] <ssbr_> however, I can make the case that I am learning, and therefore it's OK to do dumb things
[14:58:46] <kimundi> jup
[14:58:46] <dbaupp> ssbr_: well, then definitely use more macros :D
[14:59:09] <ssbr_> they're really not so bad, actually!
[14:59:23] <ssbr_> but I can see now why lisp people like S-expressions
[14:59:36] <dbaupp> ssbr_: you're not allowed functions other than main/export wrappers for a week or two
[14:59:44] <dbaupp> ssbr_: macros only :P
[14:59:51] <Yurume> kimundi on the regexp: I think longest/shortest match is a property of wildcards and not regexps
[14:59:56] <ssbr_> do you really want to see me write a regex module that way
[15:00:09] <fread2281> dbaupp: https://gist.github.com/fread2281/5516314 I guess I should fix it by doing a datfiles.consume instead of map
[15:00:13] <fread2281> whops
[15:00:14] <kimundi> Yurume: I just copied what re2 supports
[15:00:19] <dbaupp> ssbr_: i'd upvote you on reddit/hacker-news if you did
[15:00:20] <fread2281> wrong window :(
[15:00:28] *** Quits: acrichto (acrichto@moz-FE112B96.res.cmu.edu) (Ping timeout)
[15:00:33] <dbaupp> fread2281: no? this is #rust
[15:00:43] <ssbr_> Yurume: consider the regex "a*(aba|b)" on string "aba"
[15:00:54] <fread2281> dbaupp: for my up arrow+enter
[15:00:57] <ssbr_> Yurume: using a greedy operator gets you the shortest match, and using a nongreedy operator gets you the longest match
[15:01:01] <ssbr_> they are disconnected concepts
[15:01:10] <dbaupp> fread2281: oh
[15:01:29] <ssbr_> Yurume: (whereas for "a*" on "aaa", the shortest match is if * is nongreedy)
[15:01:33] <dbaupp> Yurume: (I had the same question)
[15:01:55] <Yurume> dbaupp, ah, maybe I should look through more past logs :S
[15:01:57] <fread2281> dbaupp: can I use do syntax for vec::map_consume?
[15:02:07] <dbaupp> Yurume: it was ages ago
[15:02:08] <ssbr_> Yurume: don't worry too much about it :)
[15:02:13] <ssbr_> it was indeed a while ago
[15:02:40] <dbaupp> fread2281: yes, any function or method where the last argument is a function can be used with do
[15:03:10] <fread2281> dbaupp: oh
[15:03:16] <dbaupp> fread2281: `do f(a,b) |x,y| { a }` <=> `f(a,b,|x,y| { a })`
[15:03:51] <fread2281> dbaupp: ok, thanks
[15:03:55] <Yurume> ssbr_, I guess my intended term is shortest-first wildcard and longest-first wildcard
[15:04:09] <Yurume> (or Kleene star, whatever)
[15:04:11] <ssbr_> yeah
[15:04:31] <ssbr_> Yurume: so that's how PCRE style regex engines do it -- the choices have an order, and you go left to right through the choices
[15:04:44] <ssbr_> greedy vs nongreedy is just the order in which the choice of "repeat" or "continue" is in */+
[15:04:47] <kimundi> ssbr_: Hm, but thinking about it how relates that with instead using '?' as suffix to become non-greedy. (Keep in mind that my knowledge of res currently only freshly includes re2's syntax page)
[15:05:10] <ssbr_> Yurume: shortest/longest match is an alternative where you don't care about the order, you just get the shortest possible or longest possible substring that matches the regex
[15:05:27] *** Joins: Thad (chatzilla@moz-C35F90AE.tx.res.rr.com)
[15:05:43] <ssbr_> kimundi: what's up?
[15:05:46] *** Quits: doomlord (doomlod@moz-92EDFF3A.range31-52.btcentralplus.com) (Quit: Leaving)
[15:06:20] *** Quits: sdh_ (sdh@BCD0EF3B.8A554927.FD6A0EFF.IP) (Ping timeout)
[15:06:52] <kimundi> ssbr_: I just realized that I also don't really understand why that needs to be a different mode. :) Trying to piece it together from what you're currently explaining
[15:06:57] <Yurume> hmm, so i) wildcards have a preference of shortest/longest alternative first but ii) the entire regexp engine try harder to find the globally (not limited to single wildcard) longest/shortest match?
[15:07:07] <Yurume> the entire regexp engine may try*
[15:07:41] <Yurume> and what you refer to shortest/longest really mean the latter, and the former is an option in "perl-style" matching?
[15:07:59] <dbaupp> Yurume: presumably "try harder" means "actually finds" if the methods are named 'shortest' and 'longest'
[15:08:07] <Yurume> yeah
[15:08:14] *** Quits: z0w0 (zack@moz-CF5E62C9.lns4.woo.bigpond.net.au) (Quit: Leaving.)
[15:08:27] <ssbr_> kimundi: well, why what needs to be a different mode?
[15:08:36] <ssbr_> sorry I'm not following too well :(
[15:08:52] *** Joins: sdh_ (sdh@8557E3E0.AAC4A127.9105FBCF.IP)
[15:09:27] <Yurume> I wrote in that way since it may mean that you have to search for longer/shorter match even when you already have a match until you are sure that it is indeed the longest/shortest
[15:10:39] *** Quits: sdh_ (sdh@8557E3E0.AAC4A127.9105FBCF.IP) (Quit: Konversation terminated!)
[15:10:47] <ssbr_> Yurume: wildcards only have a preference for one direction or the other if the engine lets them
[15:10:58] <ssbr_> for shortest/longest match, the engine doesn't let them, it aims at something else instead
[15:11:16] <ssbr_> It might be able to break ties using greediness?
[15:11:19] <kimundi> ssbr_: I mean why do you need "[1-9]{2,5}".longest_match() and "[1-9]{2,5}".shortest_match() instead of "[1-9]{2,5}" and "[1-9]{2,5}?". 
[15:11:19] *** Joins: zxcdw (r-a@moz-C7C5467B.cust.bredband2.com)
[15:12:12] <dbaupp> kimundi: because of 'a*(aba|b)'
[15:12:16] <ssbr_> kimundi: A) you might not control the regex, B) even if you do, greediness or nongreediness might not guarantee the shortest match
[15:12:52] <Yurume> hmm, RE2 *is* able to find the shortest/longest match without backtracking, so it is much more like having a different engine. sorry for a bit of confusion.
[15:13:14] <kimundi> So, its indeed about globally shortest instead of wildcard-local shortest?
[15:13:22] <Yurume> yes
[15:13:27] <Yurume> RE2 does find it
[15:13:32] <kimundi> okay, thanks :)
[15:13:34] <ssbr_> kimundi: right
[15:13:35] <ssbr_> well
[15:13:39] <ssbr_> yes
[15:13:48] <dbaupp> ssbr_: are you planning on using a state machine?
[15:14:01] <ssbr_> greedy search is not just about taking the locally shortest route, it's about taking the "first option" as long as you can
[15:14:01] <kimundi> Was confused because re2 allows both.
[15:14:06] <ssbr_> which doesn't always give the shortest match
[15:14:12] <ssbr_> dbaupp: yes
[15:14:48] <ssbr_> the pike vm approach is not bad at all
[15:14:53] <dbaupp> ssbr_: would you like the rusty(ic?) conventions that seem to have developed for SMs? 
[15:15:21] <ssbr_> dbaupp: it can't hurt to see them, but the state machines used in regex engines are a little unconventional, so it might not help as much as you'd hope
[15:15:25] <Yurume> I don't mind if the resulting engine doesn't support backreferences
[15:15:44] <Yurume> if I needed that I would make a proper parser instead
[15:15:48] <dbaupp> ssbr_: of course
[15:15:51] <cmr> In libcore/bool.rs, why are the Ord/TotalOrd/Eq impl's marked cfg(notest)?
[15:15:57] <Yurume> but what I mind is the lack of assertions
[15:15:57] <ssbr_> Yurume: haha, even proper parsers can't handle backreferences
[15:16:25] <ssbr_> Yurume: yes, that bugs me too
[15:16:25] <Yurume> ssbr_, context sensitive parsers (that type 1) or lexers will do it
[15:16:46] <ssbr_> Yurume: oh, yes, context sensitive parsers can do it
[15:16:53] <Yurume> except that you normally don't write context sensitive parsers ;)
[15:16:53] <ssbr_> but once you're that far up you've basically given up!
[15:18:31] <Yurume> uh, is the forward assertion in the regular language still a regular language? (i.e. A and B are RLs, then would (?=A)B be in a RL?)
[15:19:13] <Yurume> I thought it is but to be sure...
[15:19:14] *** Joins: philix (philix@moz-451739D3.user.veloxzone.com.br)
[15:19:21] <ssbr_> Yurume: I would expect so, but I never tried arguing it properly
[15:19:24] <ssbr_> or rather I did, and I did it wrong
[15:19:45] <dbaupp> ssbr_: fwiw, https://gist.github.com/huonw/4346c769db5570c6090b
[15:20:18] <Yurume> hmm, one can make a new state (a,b) from states a from a FSA for A and states b from a FSA for B
[15:20:20] *** Quits: zxcdw (r-a@moz-C7C5467B.cust.bredband2.com) (Ping timeout)
[15:20:33] <ssbr_> dbaupp: Oh, that's neat
[15:20:50] <kimundi> dbaupp: It could be nicer :)
[15:20:52] <dbaupp> (I hope I got the syntax correct...)
[15:21:04] <dbaupp> kimundi: feel free to edit/improve
[15:21:05] <ssbr_> Yurume: oh, der
[15:21:09] <Yurume> where B is actually B \Sigma^* to be sure that the final states for B extend through the final letters
[15:21:30] <ssbr_> wait, no
[15:21:31] <ssbr_> *sigh*
[15:21:45] <dbaupp> Yurume: I'm sure it is
[15:21:48] <ssbr_> it's not trivial, because you have regexes like this ((?=...)...)*
[15:22:21] <dbaupp> Yurume: the intersection of two regular languages is still regular
[15:22:24] <dbaupp> (i think)
[15:22:26] <ssbr_> it is
[15:22:35] <ssbr_> but assertions aren't quite intersection
[15:22:44] <dbaupp> ssbr_: really?
[15:22:48] <kimundi> dbaupp, ssbr_ : This is a nice example for both state machines, and "I don't know what I'm doing but it looks nice": https://github.com/mozilla/rust/blob/incoming/src/libcore/str.rs#L823 (I wrote that)
[15:22:57] <ssbr_> dbaupp: an assertion applies to the whole rest of the match
[15:23:17] <ssbr_> it's an intersection of the suffix with a regex, I guess
[15:23:19] <ssbr_> hmmmmm
[15:23:25] <dbaupp> ssbr_: yeah
[15:23:29] <ssbr_> yes, that argument works
[15:23:35] <dbaupp> kimundi: that is nice!
[15:23:38] <ssbr_> you can argue closure through regexp derivatives (repeatedly taking the suffix)
[15:24:09] <dbaupp> kimundi: I thought about rewriting that code ages ago, but never got around to it... you did a better job that I would've done :)
[15:24:24] <Yurume> ssbr_, well... it would be possible, but the number of states in the resulting FSA may exhibit exponential growth
[15:24:54] <ssbr_> Yurume: we already have FSA exponential in the size of the input string anyway
[15:25:05] <ssbr_> as soon as you add the repetition operator {N}
[15:25:27] <Yurume> isn't a whole point of Thompson NFA not having that exponential behavior?
[15:25:28] <Yurume> ah
[15:25:34] <Yurume> that evil repetition
[15:25:44] <ssbr_> e.g. the regexp ".{10}{10}{10}{10}" has 10000 states
[15:25:48] <kimundi> dbaupp, ssbr_ : More general: https://gist.github.com/Kimundi/5517804
[15:26:08] <ssbr_> Yurume: I guess there's matters of degrees
[15:26:34] <ssbr_> DFA can get _very_ bad for even nice regexes a human meant genuinely
[15:26:46] <ssbr_> it's a little harder to make things choke accidentally with the regex operators
[15:26:56] <Yurume> that may be one argument for backtracking approach? :p
[15:27:04] <dbaupp> kimundi: yup. (I was mostly just demonstrating the labelled breaks)
[15:27:11] <ssbr_> Yurume: w.r.t. implementing assertions, you can do it by running the assertion regex at every point in the string
[15:27:18] <Yurume> backtracking approach can be beneficial for many commonly occuring situations
[15:27:33] <ssbr_> Yurume: it's not pure DFA exactly, but it's O(n)
[15:27:49] <Yurume> it just doesn't work so for every case
[15:27:56] <ssbr_> it's just that you have O(nm) memory consumption, unlike O(1) for NFA
[15:28:05] <ssbr_> er, O(m) for NFA
[15:28:46] <ssbr_> kimundi: that's what I would've done if I was doing it without outside suggestions... <_<
[15:29:06] <kimundi> hehe
[15:29:24] <Yurume> ssbr_, running several DFAs as like an NFA? quite possible.
[15:30:05] * Yurume started to wonder how C++ regexp is typically implemented
[15:30:11] <ssbr_> running several NFAs like an NFA
[15:30:16] <ssbr_> where they can communicate between each other
[15:30:19] <ssbr_> um
[15:30:22] <ssbr_> it's less complicated than it sounds
[15:30:23] <ssbr_> honest
[15:31:23] <kimundi> dbaupp,  ssbr_: The nice thing with this approach is that even if the states you match on get bigger and bigger it ensures at compiletime that you handle all possible state transitions.
[15:31:59] <dbaupp> kimundi: yes, checked matches are pretty awesome
[15:35:06] <ssbr_> I miss match- (match but with no warning or error for incompleteness)
[15:35:20] *** Joins: Sodel_the_V (user@moz-853663E1.va.shawcable.net)
[15:35:54] <dbaupp> ssbr_: just _ => fail!() at the end?
[15:36:03] <kimundi> ssbr_: You could put a "_ => fail!()" as last arm?
[15:36:05] <dbaupp> (not as short, I guess)
[15:36:06] <ssbr_> dbaupp: no, _ => ()
[15:36:36] <ssbr_> well, that's what match- does
[15:36:39] <dbaupp> ssbr_: oh, so it's 'do nothing otherwise', rather than 'I know I'm in one of these states'
[15:36:44] <ssbr_> Right.
[15:37:06] <ssbr_> sort of like how if lets you not specify both arms
[15:37:19] <kimundi> Maybe there is room for a match_!() macro that does that, hmm...
[15:37:24] <fread2281> is there any way I can overload fail! so it logs to my log file?
[15:37:24] <dbaupp> you could probably macro it
[15:37:30] <dbaupp> yeah, what kimundi said
[15:37:42] <ssbr_> bah, macros ;)
[15:37:53] <dbaupp> ssbr_: no functions, remember?
[15:38:03] <dbaupp> :P
[15:38:30] <kimundi> fread2281: Not really. But you coul supervise the task and log there on task failure. Except from what I remeber frosm fai!()s implementation that doesn't actually work atm
[15:38:32] *** Joins: Kambfhase (kvirc@moz-1AEBDA53.travedsl.de)
[15:39:11] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[15:40:59] *** Joins: acrichto (acrichto@moz-FE112B96.res.cmu.edu)
[15:42:24] <dbaupp> fread2281: it's probably being changed at some point
[15:43:01] <dbaupp> (rust is really fun, because there are so many awesome features "in the future" :D )
[15:43:31] *** Quits: dcamp (dcamp@moz-930D5B64.hsd1.wa.comcast.net) (Quit: Linkinus - http://linkinus.com)
[15:43:57] <fread2281> dbaupp: :P
[15:44:43] <fread2281> are optional parameters on that list?
[15:45:32] <dbaupp> fread2281: don't know, I hope so, but there's nothing on the bugtracker
[15:45:48] <fread2281> dbaupp: right
[15:47:11] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[15:48:41] *** Joins: drguildo (drguildo@moz-D4255ABE.drguildo.com)
[15:48:56] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[15:49:14] *** Quits: Sodel_the_V (user@moz-853663E1.va.shawcable.net) (Input/output error)
[15:51:52] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[15:52:26] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[15:52:31] <doener> strcat: d7f5e437a is responsible for a few MiB of the bloat you saw
[15:52:48] *** Quits: jack (jack@EF36212C.8FA609AD.840029BC.IP) (Ping timeout)
[15:53:19] <Kambfhase> Hey, I am new to rust and I am trying to decode some JSON but failing hard. Can someone point me at an example on how to do that?
[15:54:41] <ssbr_> Kambfhase: well, did you get as far as writing some code that didn't work?
[15:54:44] <kimundi> Kambfhase: Well.... "How to do that" can mean a lot... Anything specific you have a problem with?
[15:55:07] <Kambfhase> Ok, here's the JSON: plus something I tried: https://gist.github.com/Kambfhase/e3da62428ab4b384ee7d
[15:55:14] *** Joins: jack (jack@EF36212C.8FA609AD.840029BC.IP)
[15:55:29] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[15:55:31] <doener> strcat: http://pastebin.com/pQLm3VYW
[15:55:43] <Kambfhase> Basically, I want to traverse that lists/objects.
[15:56:19] <strcat> doener: which things do those revert?
[15:56:34] <ssbr_> also, man, I can't figure out how to use the json module either :<
[15:57:24] <Kambfhase> It seems to decode fine, but how can I process the result? :/
[15:57:35] <ssbr_> Kambfhase: oh
[15:57:47] <ssbr_> Kambfhase: pattern match on the different Json variants
[15:57:48] *** Joins: pseudoku (quassel@80F08604.A8E0FD0A.C28326FD.IP)
[15:58:28] <doener> strcat: the "no-match" version reverts the changes to local_malloc()/local_free(), no-inline drops the inline(always) on those functions, no-inline-borrows looks like this: http://pastebin.com/qY0XKHbT
[15:58:54] <ssbr_> Kambfhase: for example, you expect the outermost part to be a list, so you can do "match JSON { json::List (l) => ..., _ => { error!("Unexpected JSON!"); fail!() }}
[15:59:12] <doener> strcat: tried the latter because copying the stack values into the closure looked kind of expensive in terms of code size
[15:59:18] <Kambfhase> let me try.
[15:59:20] *** Quits: akashj87_ (akash@DD39A07A.BCDF8B4F.35E3DDC8.IP) (Ping timeout)
[15:59:36] <pseudoku> what are the problems still to be solved to allow rust functions to be called from a thread created externally in a c function?
[16:00:08] <ssbr_> pseudoku: You can't do that?
[16:00:28] <dbaupp> Kambfhase: https://gist.github.com/huonw/ab508ff61bc6c22349ef
[16:00:46] <dbaupp> (I haven't actually test it though)
[16:00:51] <ssbr_> I'd assume you'd pass in an extern "C" function pointer and it'd just work, or something.
[16:00:54] <pseudoku> ssbr_: not if the rust function uses any of the runtime features 
[16:01:23] <ssbr_> pseudoku: oh! I didn't know that the threads had to be created by rust. Interesting.
[16:01:33] <ssbr_> Sorry for my ignorance, then
[16:01:38] <indutny> ok, false alert
[16:01:51] <indutny> inflate_bytes() works, it was just a zlib header that it was choking with
[16:01:52] <doener> strcat: relative changes for libsyntax are even worse: http://pastebin.com/GpaqpN0f
[16:02:19] <dbaupp> indutny: yay :)
[16:02:23] <indutny> haha
[16:02:33] <strcat> doener: were they made #[inline(always)]?
[16:02:41] *** Joins: akashj87_ (akash@DD39A07A.BCDF8B4F.35E3DDC8.IP)
[16:02:53] <indutny> I wonder if miniz can handle it in future
[16:02:55] *** Joins: zakora (NC@moz-8EAF945F.fbx.proxad.net)
[16:02:55] *** Quits: zakora (NC@moz-8EAF945F.fbx.proxad.net) (Max SendQ exceeded)
[16:03:19] *** Joins: zakora (NC@moz-8EAF945F.fbx.proxad.net)
[16:03:24] *** Quits: drguildo (drguildo@moz-D4255ABE.drguildo.com) (Quit: Leaving)
[16:03:42] *** Joins: Sodel_the_V (user@moz-853663E1.va.shawcable.net)
[16:03:51] <Kambfhase> dbaupp: that gives me an error on line 13: unresolve name: List
[16:04:06] <doener> strcat: that was changed in ce9e5ecb6c1f833eccb520b4179cf86329331fa6 which is about a month old
[16:04:29] <strcat> doener: well the 12MiB I noticed was from the past 2-3 days
[16:04:36] <dbaupp> Kambfhase: json::List
[16:04:46] <doener> strcat: the local_malloc() change itself was in that timeframe
[16:04:56] <strcat> oh
[16:05:11] *** Joins: cdidd (cdidd@moz-8C2FDB27.broadband.corbina.ru)
[16:05:14] <dbaupp> Kambfhase: err, and all the indentation is screwed up... sorry!
[16:05:36] <pseudoku> ssbr_: well technically you can call them, but the rust function can do very minimal things and not access io, pipes or anything that access the current task object
[16:05:42] <Kambfhase> dbaupp: yeah, that gives me more errors on line 11: Ok(json) The type of the value must be known in the context.
[16:05:50] <Kambfhase> dont worry about the indentation :)
[16:06:44] *** Joins: judder (maradukewa@DABDEEA3.F2C0D0AC.78E362FE.IP)
[16:07:08] <Kambfhase> ssbr_: what ever I try gives me the same errors as above.
[16:07:26] *** Quits: jensnockert (jensnocker@moz-49A419C6.mobileonline.telia.com) (Input/output error)
[16:07:28] <doener> strcat: was merged in 79aeb529 on 2013-05-03
[16:07:33] <dbaupp> Kambfhase: it's probably because of the extra 'let mut input'
[16:07:40] *** Quits: cdidd (cdidd@moz-8C2FDB27.broadband.corbina.ru) (Ping timeout)
[16:07:50] <Kambfhase> mkay
[16:07:53] <dbaupp> Kambfhase: that is shadowing the first definition of 'input'
[16:08:33] <Kambfhase> some smack me plz.
[16:08:42] <Kambfhase> +one
[16:09:16] <strcat> doener: ah
[16:10:13] *** Joins: Erik (Erik-S@moz-252DBA2.hsd1.co.comcast.net)
[16:10:49] <Kambfhase> Ok, getting closer. Where does that obj.find() method come from?
[16:11:17] <dbaupp> Kambfhase: what version of rust? 0.6?
[16:11:22] <Kambfhase> yeah
[16:11:39] <dbaupp> core::linearmap::LinearMap
[16:11:54] <dbaupp> (the json object type is represented as one of those)
[16:12:28] <dbaupp> Kambfhase: sorry, core::hashmap::linear::LinearMap
[16:12:34] <dbaupp> Kambfhase: http://static.rust-lang.org/doc/0.6/core/hashmap_linear.html
[16:12:52] <dbaupp> Kambfhase: http://static.rust-lang.org/doc/0.6/std/json.html#type-list
[16:15:03] <Kambfhase> THis is the code I am using now: https://gist.github.com/Kambfhase/e3da62428ab4b384ee7d But the compiler doesn't know about object.find() and has some other weird type error.
[16:16:43] <indutny> have you tried using .find(&"friends")?
[16:16:48] <indutny> I'm not sure if it matters :)
[16:16:53] <indutny> kind of newbie too
[16:17:11] <indutny> ah
[16:17:16] <indutny> it should be .find(~"friends")
[16:17:18] <indutny> or even
[16:17:22] <indutny> .find(&~"friends")
[16:17:38] <indutny> that's because JSON object has following type: LinearMap<~str, Json>
[16:17:47] <indutny> Kambfhase: ^
[16:17:57] <strcat> .find_equiv("friends")
[16:18:07] <strcat> or .find(&~"friends") (which you don't want, it will allocate)
[16:18:19] <strcat> find uses &T
[16:18:22] <strcat> where T is the key type
[16:19:06] <indutny> strcat: good tip!
[16:19:45] <strcat> find_equiv works with anything with the same Hash impl and an Equiv impl for comparisons with that type
[16:20:43] *** Quits: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP) (Connection reset by peer)
[16:20:47] <Kambfhase> Hm, find_equiv() still gives me `type &std::json::Json` does not implement any method in scope named 'find equiv'`
[16:21:15] <strcat> you need to match out of it
[16:21:16] <dbaupp> Kambfhase: oh
[16:21:50] <dbaupp> Kambfhase: that's still a json wrapper, so you need to retrieve the object, like the list was retrieved
[16:22:09] <Kambfhase> meh.
[16:22:17] <Kambfhase> Thanks.
[16:22:42] *** Quits: EXetoC (ex@moz-2DBEB1E4.customer.t3.se) (Quit: WeeChat 0.4.0)
[16:24:56] *** Joins: cdidd (cdidd@63A838E1.271BFDAC.62D8163C.IP)
[16:24:57] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Connection reset by peer)
[16:24:57] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Connection reset by peer)
[16:25:04] <indutny> if anyone curious, I've finished erlang's .beam file parser :)
[16:25:05] <indutny> haha
[16:25:07] <indutny> first rust program
[16:25:40] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[16:26:50] <Kambfhase> I dont know if this is smart or stupid. I am trying to compile a few coding challenges for rust beginners (me included). https://github.com/Kambfhase/rust-challenge
[16:27:20] *** Quits: toshok (toshok@moz-67C55A1F.com) (Ping timeout)
[16:28:15] <Sodel_the_V> indutny: Wow, nice!
[16:28:38] <dbaupp> indutny: is it online somewhere? :)
[16:28:45] <indutny> not yet
[16:28:46] <Sodel_the_V> Kambfhase: Sounds like a good way to get to know the language!
[16:28:48] <indutny> I'll polish it a bit
[16:28:51] <indutny> and publish soon
[16:29:11] <Kambfhase> Sodel_the_V: learnign by doing.
[16:29:26] *** Joins: thou (thou@moz-1C1CA9F7.fasttrackcomm.net)
[16:29:51] <Sodel_the_V> Kambfhase: Exactly.
[16:31:28] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Connection reset by peer)
[16:32:08] *** Joins: jviereck (Adium@moz-EFC52440.hsi.kabel-badenwuerttemberg.de)
[16:33:09] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[16:35:03] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Connection reset by peer)
[16:35:22] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[16:35:51] *** Quits: thou (thou@moz-1C1CA9F7.fasttrackcomm.net) (Input/output error)
[16:38:02] *** Joins: Blei (philipp@moz-96D25F7A.cust.bluewin.ch)
[16:39:00] *** Joins: toshok (toshok@moz-67C55A1F.com)
[16:39:54] *** Joins: steven_is_false (quassel@moz-144077DE.bchsia.telus.net)
[16:40:03] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[16:41:09] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[16:42:08] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[16:42:52] *** Joins: RUSTASTIC (Mibbit@moz-AB722A1C.mc.videotron.ca)
[16:46:02] *** Quits: Houm (Houm@moz-25669AA8.fbx.proxad.net) (Quit: )
[16:46:36] *** Quits: SimonSapin (simon@moz-C4A83ED9.net-89-2-126.rev.numericable.fr) (Ping timeout)
[16:47:11] *** Quits: jviereck (Adium@moz-EFC52440.hsi.kabel-badenwuerttemberg.de) (Quit: Leaving.)
[16:51:18] *** Joins: mzabaluev (mzabaluev@moz-91FFD755.dhcp.inet.fi)
[16:51:40] <Kambfhase> Yay, its working, thank you guys!
[16:52:31] <Kambfhase> Wow, decoding JSON is tedious and ugly. o_O
[16:53:39] <dbaupp> Kambfhase: yes, it's hard to do in a type-safe way
[16:55:03] *** Quits: mzabaluev (mzabaluev@moz-91FFD755.dhcp.inet.fi) (Ping timeout)
[16:56:07] <Kambfhase> My code is 9 indentation levels deep. 
[16:56:41] <dbaupp> Kambfhase: break it into another function?
[16:56:51] <dbaupp> (rust does seem to have that effect...)
[16:57:19] *** Joins: boggle (boggle@moz-BCEB49E4.dip0.t-ipconnect.de)
[16:57:52] <Kambfhase> I think I'll use JS to conver the JSON into something different. Might be easier. :D
[16:58:57] <steven_is_false> Is aatch|bed aatch?
[16:59:07] <dbaupp> steven_is_false: yes, but asleep
[16:59:16] <steven_is_false> dbaupp: Oh, okay.
[16:59:54] *** Quits: RUSTASTIC (Mibbit@moz-AB722A1C.mc.videotron.ca) (Quit: http://www.mibbit.com ajax IRC Client)
[17:00:17] <dbaupp> Kambfhase: depends on what format (and if your'e doing it for rust-challenge, having an example would be really useful
[17:00:27] <dbaupp> given how much we all struggled with it :) )
[17:01:26] *** Quits: doener (doener@moz-724BBC7C.unitymediagroup.de) (Quit: leaving)
[17:02:04] <Kambfhase> Originally I planned to have json as input for a graph problem, but I think "decoding JSON" might be challenge enough.
[17:02:32] <Kambfhase> Every challenge will have an example solution.
[17:02:56] *** Quits: Thad (chatzilla@moz-C35F90AE.tx.res.rr.com) (Client exited)
[17:03:07] <Kambfhase> (havent done one for Diff yet)
[17:03:09] <strcat> Kambfhase: just stop explicitly handling the other cases if you aren't doing anything but failing
[17:03:19] <strcat> you have to be assuming *something* about the structure of the json
[17:03:29] <strcat> there's no need for match unless you actually allow alternatives
[17:04:07] <dbaupp> strcat: how do you get the object out of Object without match?
[17:04:11] <strcat> I'm sure in js/python you're not writing the same code (are you running typeof and then checking if the object type is an array?)
[17:04:16] <strcat> look in the json module tests
[17:06:45] <dbaupp> strcat: are you refering to the stuff like `let v: ~[()] = Decodable::decode(&Decoder(from_str(~"[]").unwrap()));`
[17:06:55] <strcat> yes
[17:07:03] <dbaupp> ok
[17:08:01] *** Quits: hmax (hmax@moz-15514FA1.yandex.net) (Quit: ????? ? ?? ??? (xchat 2.4.5 ??? ??????))
[17:10:10] <Kambfhase> I'll have a look at that, later.
[17:10:21] *** Joins: doener (doener@moz-724BBC7C.unitymediagroup.de)
[17:11:30] *** Joins: mzabaluev (mzabaluev@moz-91FFD755.dhcp.inet.fi)
[17:13:09] *** Joins: blitter (blitter@moz-7C98731E.dyn.centurytel.net)
[17:13:13] *** Quits: Sodel_the_V (user@moz-853663E1.va.shawcable.net) (Quit: Eaten by a grue)
[17:14:33] *** Quits: doener (doener@moz-724BBC7C.unitymediagroup.de) (Quit: leaving)
[17:39:52] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[17:39:52] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[17:41:54] *** Joins: RagingDave (RagingDave@moz-3F31ACEF.pools.arcor-ip.net)
[17:44:03] <steven_is_false> Aagh! git
[17:44:11] <steven_is_false> 's interface is really annoying.
[17:44:42] <steven_is_false> Does anyone know how I can undo a commit?
[17:44:50] <Kambfhase> git revert?
[17:45:35] <dbaupp> steven_is_false: http://stackoverflow.com/questions/927358/how-to-undo-the-last-git-commit
[17:48:41] <steven_is_false> dbaupp: Unfortunately, I already pushed the changes to my fork at GitHub
[17:49:16] <steven_is_false> dbaupp: It won't let me edit history.
[17:50:19] <kimundi> steven_is_false: UNdo locally, push -f
[17:50:24] <dbaupp> steven_is_false: git push -f
[17:51:01] <kimundi> the -f flag forces a overwite in cases where the other side doesn't want to behave :)
[17:51:02] <steven_is_false> I did not know about the -f option. I should have guessed.
[17:53:22] *** Quits: JonCarlos (Jon@moz-8F3C266E.nwrknj.fios.verizon.net) (Quit: From my books surcease of sorrow, sorrow for the lost Lenore.)
[17:54:06] *** Quits: dbaupp (Thunderbir@moz-91B99879.lns20.syd6.internode.on.net) (Ping timeout)
[17:54:27] <steven_is_false> So when I make a bunch of different pull requests I should have a different branch for each request right?
[17:55:25] <fread2281> steven_is_false: yep
[17:55:57] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[17:56:42] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[17:57:17] <steven_is_false> So suppose I report an issue, and later on find out a fix for it. Do I have to make an entirely new issue (a pull request) for it?
[17:58:13] <doy> yes
[17:58:27] <steven_is_false> Okay. I think I get this stuff.
[18:01:28] <steven_is_false> So, I created a new branch for the other issue I want to solve. But I can't push it to the fork at GitHub?
[18:02:07] *** Joins: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net)
[18:04:11] <indutny> hey people
[18:04:11] <indutny> failed to find an implementation of trait core::io::Reader for <V9>
[18:04:19] <indutny> I got this
[18:04:26] <indutny> but I've impl Reader for Parser { … }
[18:05:43] <indutny> any ideas?
[18:07:11] <kimundi> bjz, ping
[18:07:57] <kimundi> steven_is_false: where do you want to push what?
[18:08:07] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[18:08:07] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/XLJw4g
[18:08:07] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[18:08:10] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[18:08:10] <ghrust> 01[13rust01] 15bors pushed 16 new commits to 06auto: 02http://git.io/WSocPw
[18:08:11] <ghrust> 13rust/06auto 14ba3d3e7 15Patrick Walton: libstd: Remove mutable fields from fileinput and net_tcp
[18:08:11] <ghrust> 13rust/06auto 143b55b29 15Patrick Walton: libstd: Remove mutable fields from flatpipes and io_util
[18:08:11] <ghrust> 13rust/06auto 143b56330 15Patrick Walton: libstd: Remove mutable fields from future and par
[18:08:14] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[18:08:46] <steven_is_false> kimundi: I want to push a branch of rust-xcb (which adds a method to create a connection form the raw pointer) to my fork at GitHub
[18:09:41] <kimundi> steven_is_false: you should modify the fork, not the original.
[18:10:14] <indutny> anyone?
[18:10:22] <Blei> indutny: code?
[18:10:33] *** Joins: EXetoC (ex@moz-2DBEB1E4.customer.t3.se)
[18:10:56] <indutny> https://gist.github.com/indutny/074494e74416713368cf#file-1-rs-L167
[18:11:01] <indutny> NOTE: that some parts of code a probably broken
[18:11:06] <indutny> after this line
[18:11:13] <indutny> because I've just rewritten it
[18:12:00] <steven_is_false> Welp thank guys for help
[18:12:01] *** Quits: steven_is_false (quassel@moz-144077DE.bchsia.telus.net) (Client exited)
[18:12:04] <kimundi> steven_is_false, original -> fork -> git clone fork -> create branch -> modify -> commit -> push branch to fork -> pull reqest
[18:12:14] <Blei> indutny: read_byte vs. read_bytes
[18:12:20] <indutny> I know read_byte
[18:12:26] <indutny> but I want to use ReaderUtil trait
[18:12:30] <fread2281> can I get fmt! to pretty-print?
[18:12:32] <Blei> ah, i see
[18:13:12] <kimundi> fread2281: Define pretty print. Expand the macro? cause that won't work, its not a macro
[18:13:33] <fread2281> kimundi: no, print my struct with indentation
[18:13:49] <fread2281> and newlines
[18:14:01] <kimundi> fread2281: Ah. Not possible afaik :(
[18:14:06] <fread2281> kimundi: oh :(
[18:14:45] <indutny> Blei: any ideas?
[18:14:55] <kimundi> At least for now. Probably want that option.
[18:15:09] <kimundi> fread2281: Feel free to open an issue about that.
[18:15:39] <indutny> strcat: yt?
[18:16:39] <Blei> indutny: huh, it works if you change &mut to &
[18:16:48] <indutny> oh gosh
[18:16:53] <Blei> &mut self, to &self 
[18:16:54] <Blei> i mean
[18:16:58] <indutny> ah
[18:16:59] <indutny> right
[18:17:01] <indutny> (*self).read_bytes
[18:17:03] <indutny> thank you
[18:17:28] <Blei> yeah, that works as well
[18:17:31] <indutny> oh god
[18:17:38] <indutny> it seems that I don't need this reader interface :)
[18:17:38] <indutny> haha
[18:17:40] <Blei> i'm surprised this doesn't happen automatically
[18:17:49] <indutny> because its immutable
[18:18:08] <indutny> I'm not sure what's the point in it if I can't mutate it
[18:19:01] <indutny> and apparently io.rs uses mut offset inside struct to handle it
[18:20:09] *** Quits: pseudoku (quassel@80F08604.A8E0FD0A.C28326FD.IP) (Client exited)
[18:22:05] <indutny> should I contribute to incoming branch?
[18:23:57] <kimundi> indutny: contributions should be written against the incmoing branch, yes
[18:26:15] <indutny> thanks
[18:26:16] <indutny> will do
[18:26:28] *** Joins: Andrew (Mibbit@moz-91DB7BBE.cable.virginmedia.com)
[18:26:33] <Andrew> Hey
[18:27:04] *** Quits: magical (magical@moz-64CF105A.hsd1.wa.comcast.net) (Quit: :qa)
[18:27:42] <indutny> ttyl
[18:30:14] *** Quits: solancile (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net) (Ping timeout)
[18:31:17] <Andrew> Anyone know why I'm getting bad_alloc errors when compiling rust on windows?
[18:32:56] *** Quits: Andrew (Mibbit@moz-91DB7BBE.cable.virginmedia.com) (Quit: http://www.mibbit.com ajax IRC Client)
[18:38:12] *** Quits: ssiloti (steve@moz-4B8C4631.oc.oc.cox.net) (Client exited)
[18:38:17] *** Joins: devbug (quassel@moz-E1DE087C.bchsia.telus.net)
[18:39:44] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[18:40:30] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[18:41:59] *** Joins: ssiloti (steve@moz-4B8C4631.oc.oc.cox.net)
[18:42:46] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[18:45:11] *** Joins: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net)
[18:48:58] *** Quits: jack (jack@EF36212C.8FA609AD.840029BC.IP) (Quit: Leaving.)
[18:49:18] *** Joins: jack (jack@EF36212C.8FA609AD.840029BC.IP)
[18:49:50] *** Quits: Erik (Erik-S@moz-252DBA2.hsd1.co.comcast.net) (Ping timeout)
[18:57:24] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[18:57:38] *** Quits: boggle (boggle@moz-BCEB49E4.dip0.t-ipconnect.de) (Quit: boggle)
[18:57:39] *** Quits: doomlord_ (servitor@moz-92EDFF3A.range31-52.btcentralplus.com) (Connection reset by peer)
[19:01:13] *** Joins: RUSTAPOPOULOS (Mibbit@moz-AB722A1C.mc.videotron.ca)
[19:05:31] *** Joins: threecreepio (jdp@moz-DB2D70E9.cust.bredbandsbolaget.se)
[19:06:29] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Ping timeout)
[19:08:57] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Client exited)
[19:13:01] *** Quits: RUSTAPOPOULOS (Mibbit@moz-AB722A1C.mc.videotron.ca) (Quit: http://www.mibbit.com ajax IRC Client)
[19:13:18] <strcat> rusti: 5
[19:13:19] <rusti> ^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C5
[19:13:23] <strcat> ;\
[19:13:26] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[19:13:59] *** Joins: Sodel_the_V (user@moz-853663E1.va.shawcable.net)
[19:16:59] <Ralith> haha
[19:17:09] <muonz> alrighty... wrote my first ever rust code today. needs some work but it's a start. https://github.com/seanmoon/rust-zlib/blob/master/zlib.rs
[19:18:49] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[19:18:58] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[19:19:12] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[19:19:25] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[19:20:35] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[19:23:36] <fread2281> rusti: 5
[19:23:37] <rusti> 5
[19:25:39] *** Quits: Blei (philipp@moz-96D25F7A.cust.bluewin.ch) (Quit: WeeChat 0.4.0)
[19:27:34] *** Joins: doener (doener@moz-724BBC7C.unitymediagroup.de)
[19:29:03] *** Quits: muonz (moon@95840194.4E28F30D.2C82CA7.IP) (Ping timeout)
[19:40:19] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[19:40:22] <kimundi> Someone here good at math and bit-fiddling? Need a way to calculate floor(log_x(n)) where n is an arbitrary unsigned integer, and x a base from 2 to 36
[19:40:29] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[19:41:21] <kimundi> using the float log functions doesn't work because a f64 can not accuratly represent a u64
[19:42:54] <cmr> log_2(n) / log_2(10) ?
[19:42:59] <cmr> that's notgoing tobe accurate though
[19:43:04] <Yurume> kimundi, do you really need that?
[19:43:16] <kimundi> So far I got      floor(log_2(n)) = bits - 1 - number_leading_zeros(n)
[19:43:20] *** Quits: akashj87_ (akash@DD39A07A.BCDF8B4F.35E3DDC8.IP) (Connection reset by peer)
[19:43:32] <Yurume> I guess you are trying to approximate the length of resulting string representation in given radix
[19:44:29] <kimundi> Yurume: More or less. Need a way to calculate the digits of a number starting from the highest one.
[19:44:57] <kimundi> Yurume: Instead of the lowest one and repeatetly dividing through the radix
[19:45:49] <Yurume> division by fixed divisor can be acomplished with one multiplication and optional (depending on radix) bit shift
[19:45:58] <Yurume> is it too slow for your task?
[19:46:06] <kimundi> cmr: The problem is that there is no no log_2(n) for integers
[19:46:15] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[19:46:33] <kimundi> Yurume: Performance is not an issue, I just need something that works.
[19:46:42] <Yurume> hm
[19:46:59] <cmr> kimundi: surethere is, 63 - ctlz(n)
[19:47:14] <kimundi> cmr: that is  floor(log_2(n))
[19:47:23] <kimundi> not log_2(n)
[19:47:31] <Yurume> kimundi, is overestimation not allowed?
[19:47:32] <cmr> Oh you want a float?
[19:47:39] <zq> infinote 
[19:47:40] <kimundi> I tried that already. Number get wrong.
[19:48:26] *** Joins: akashj87 (akash@E34E36C9.45783465.35E3DDC8.IP)
[19:48:26] <Yurume> I really can't understand why you need such precise value
[19:48:28] *** Joins: boggle (boggle@moz-BCEB49E4.dip0.t-ipconnect.de)
[19:48:46] <kimundi> Yurume: It has to be exact enough that I get the number of digits it would be if written down in a specific base.
[19:49:30] <Yurume> ...in order to write down a number in the specific base? or something else?
[19:50:00] <Yurume> you *still* should divide and take a modulo in order to convert an integer to a string
[19:50:14] <Sodel_the_V> Well, shoot, if performance isn't an issue, format the number to a string in the given base, and count the chars in the string. :P
[19:50:16] <kimundi> Yurume: Yes, I want to convert any u64 to a string of digits in a given base.
[19:50:39] <Yurume> I don't think the reversal of the resulting string is a performance burden
[19:50:51] <kimundi> Yurume: dividing and modulo works and is exact. Problem is, I can't use that.
[19:51:12] <Yurume> ...due to the trait dependence?
[19:51:33] <kimundi> Yurume: No due to wrong order of emitted digits
[19:52:09] <kimundi> Yurume: Using the divide and modulo algoritm, 12345 gets me the digits 5 4 3 2 1
[19:52:15] <Sodel_the_V> Why can't you reverse the order?
[19:52:25] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[19:52:31] <kimundi> Sodel_the_V: Because that would mean an allocation.
[19:52:56] <Sodel_the_V> kimundi: Use a mutable vector, and reverse them in place?
[19:53:03] <Yurume> then use a 64-byte stack-allocated vector
[19:53:16] <Yurume> and keep the current index to it
[19:53:36] <Sodel_the_V> Damn, that's clever!
[19:54:09] <kimundi> Sigh. That's the old solution. It works, but I'm tryng to find one that's not hardcoded.
[19:54:28] *** Quits: doener (doener@moz-724BBC7C.unitymediagroup.de) (Quit: leaving)
[19:55:48] <Yurume> let mut digits = [0u8, ..64]; let mut i = 0; assert!(n > 0); while n > 0 { let q = n/base, r = n%base; digits[i] = DIGITS[r]; n = q; } str::from_bytes(vec::reversed(digits.slice(0, i)))
[19:55:57] <kimundi> I want to write it so that it uses a writer to push each digit, which means I have to calculate them on the fly. 
[19:56:16] <kimundi> Yurume: I know, that works but is harcoded to 64 bits
[19:56:18] <Yurume> eh, `i += 1;` is missing, anywway
[19:56:29] <Yurume> kimundi, aha
[19:56:45] <Yurume> so you want it to work for any arbitrarily-sized integer?
[19:56:48] *** Joins: doener (doener@moz-724BBC7C.unitymediagroup.de)
[19:56:53] <kimundi> Yurume: Yes
[19:56:58] <Yurume> that *is* the real question
[19:57:11] <strcat> you don't need it to work for any size
[19:57:14] <Yurume> I think you should mention that first...
[19:57:18] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[19:57:18] <kimundi> It was the question from the start :(
[19:57:24] <strcat> there are only 4 sizes ;p
[19:57:26] <strcat> just use a macro
[19:57:31] <kimundi> "Someone here good at math and bit-fiddling? Need a way to calculate floor(log_x(n)) where n is an arbitrary unsigned integer, and x a base from 2 to 36"
[19:57:49] <Sodel_the_V> kimundi: You mentioned a u64, so we assumed that's what you were using.
[19:57:51] <Yurume> it is a bad question when given without a context ;)
[19:58:00] <Yurume> anyway
[19:58:12] <Yurume> what operators can we use then?
[19:58:18] <kimundi> strcat: If there is no better solution I will, but first I want to find out if I can write something that works generally.
[19:58:59] <jack> how do you iterate over a collection adding stuff to a hash? doing `let mut x = HashMap::new()` followed by a `for …` gets a borrow check error. and I can't seem to make iter::foldl work either.
[19:59:07] <kimundi> Sodel_the_V: That was one of N conterexamples to illustrate why casting to float is not a possible solution.
[19:59:38] <indutny> whoa
[19:59:39] <indutny> need help
[19:59:40] <indutny> cannot infer an appropriate lifetime due to conflicting requirements
[19:59:57] <kimundi> indutny: Codae snippet?
[20:00:05] <indutny> yeah
[20:00:06] <indutny> https://gist.github.com/indutny/ee83f4c7dcb0dc8917c0#file-1-rs-L46
[20:00:06] <Yurume> post a code somewhere (gist or pastebin) and someone may help you ;)
[20:00:09] <indutny> happens at line 46
[20:00:29] <indutny> note that I've patched Reader trait
[20:00:32] <indutny> to allow mutable self
[20:01:42] <indutny> any ideas?
[20:01:43] <strcat> kimundi: is it supposed to work for big integers too?
[20:02:08] <strcat> I don't know how you're going to have a generic log at all
[20:02:28] <strcat> if it's only supposed to work for the built-ins there's no need for it to be generic
[20:02:38] <kimundi> strcat: It's  supposed to work for them too. Wether the resulting algorithm is going to be as fast as one speciefic tailored to it is another question I admit.
[20:02:49] *** Joins: gareth0 (gareth0@moz-4CC3D42B.dynamic.dsl.as9105.com)
[20:02:54] <strcat> so what do you gain by making it generic?
[20:03:08] <indutny> added error message to gist https://gist.github.com/indutny/ee83f4c7dcb0dc8917c0
[20:03:09] <strcat> if it's going to be slower and more complex
[20:04:11] <kimundi> strcat: I don't KNOW that it's going to be slower. I'm looking for a way to make it work so that I can start to analyse if there are problems.
[20:04:32] <Yurume> kimundi, maybe binary search to the unlimited upper bound can be used in that case
[20:04:33] *** Joins: fabiand (fabiand@moz-86B8CBB0.adsl.alicedsl.de)
[20:04:51] <Yurume> it would be definitely slow, but should work
[20:05:33] <kimundi> Yurume: Hmm...
[20:05:36] <Yurume> ...wait a min
[20:05:45] <Yurume> it does find a required number of digits
[20:05:57] <Yurume> but I guess you also need base^#digits as well?
[20:06:32] <Yurume> then (a+b)/2 translates to sqrt(a * b), which can be prohibitly costly
[20:06:39] <kimundi> Yurume: hmm?
[20:06:52] <kimundi> Not sure exactly what you mean
[20:06:55] <Yurume> or you can have O(log n) table for base^1, base^2, base^4, base^8, ...
[20:06:55] *** Joins: dymk (dymk@moz-A5917301.sub-70-211-69.myvzw.com)
[20:07:01] <strcat> jack: what exactly do you want to do?
[20:07:09] *** Joins: dymk_ (dymk@44EEE21C.A6E21E6E.5E500FC7.IP)
[20:07:10] *** Quits: heftig (heftig@moz-DDD67C1.dip0.t-ipconnect.de) (Ping timeout)
[20:07:18] <Yurume> kimundi, well, so the logic is to find some number k such that base^k <= number < base^(k+1), right?
[20:07:25] *** Joins: heftig (heftig@moz-DDD67C1.dip0.t-ipconnect.de)
[20:07:49] <Yurume> then we start by checking if number < base^1 or not; if so then k < 1, so we can conclude k = 0
[20:07:50] <kimundi> Yurume: Basically, yeah
[20:08:08] <Yurume> otherwise we continue by checking if number < base^2 or not; if so then 1 <= k < 2, so k = 1
[20:08:35] <Yurume> otherwise we continue by checking if number < base^4 or not; if so then 2 <= k < 4, so we check one more time if number < base^3 or not, and so on.
[20:08:37] <kimundi> yeah, I get it, was just not sure if that was what you meant.
[20:08:44] <Yurume> the problem here is that
[20:08:46] *** Quits: dymk (dymk@moz-A5917301.sub-70-211-69.myvzw.com) (Ping timeout)
[20:08:52] <kimundi> It's slooow :)
[20:08:52] <Yurume> in order to perform binary search
[20:09:01] <Yurume> you keep a lower bound and upper bound
[20:09:06] *** Quits: lucian (lucian@moz-22A14C6A.cable.virginmedia.com) (Input/output error)
[20:09:10] <Yurume> which would be a power of base in that case
[20:09:12] *** Parts: Sodel_the_V (user@moz-853663E1.va.shawcable.net) (Killing koopas in another castle)
[20:09:23] <Yurume> and you calculate the middle point by averaging these bounds
[20:09:33] <Yurume> which would be a geometric mean (i.e. sqrt) in this case
[20:09:39] <kimundi> yeah, we just have a lower bound here. so instead of binary search, it would have to try all lineary
[20:09:41] <Yurume> which is slow like a hell
[20:09:43] <Yurume> ;)
[20:09:55] <Yurume> kimundi, that can be possible
[20:10:15] <Yurume> you'll need some redundant divisions though
[20:10:49] <Yurume> that's, 2n instead of n + log n
[20:10:49] <indutny> so can anyone please help me? :)
[20:11:09] <Yurume> indutny, I think I can reproduce your problem (with some c&p)
[20:11:10] <indutny> In this endless fight with region inference
[20:11:13] <kimundi> indutny: You might need to add lifetime annotations in places
[20:11:35] <jack> strcat: see https://gist.github.com/metajack/5518581 for an example
[20:12:08] <indutny> kimundi: what kind of annotation
[20:12:14] <indutny> like 'self var?
[20:12:29] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Leaving...)
[20:12:46] <kimundi> yeah that king. But I don't know where and if that solves your problem :)
[20:12:52] <kimundi> kind*
[20:13:17] <indutny> haha
[20:13:17] <indutny> :)
[20:13:31] *** Quits: sp3d (a@moz-17CB39F1.fidnet.com) (Ping timeout)
[20:14:39] <Yurume> > note: first, the lifetime cannot outlive unknown scope: 426.  Please report a bug....
[20:14:58] <Yurume> 0.6 release (I don't have incoming atm) issues this note...
[20:15:38] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[20:15:38] *** ChanServ sets mode: +o brson
[20:16:32] <dymk_> Would it be favorable for Rust to have some sort of "static if" system similar to D?
[20:17:14] <brson> nmatsakis: is there any trait in core that provides a blueprint for creating a borrowable container that obeys the borrowing rules correctly? I've got a number of types that 'borrow' their contents in various ways, but no common interface. Right now I'm implementing a refcounted shared pointer
[20:17:39] <indutny> hm..
[20:17:45] <indutny> lifetime trick doesn't seem to be helping
[20:17:57] <indutny> I can't figure out which object's lifetime it can't handle
[20:18:16] <Yurume> indutny, my attempt was to change `fn as_bytes_reader<A>(&mut self, f: &fn(&mut BytesReader) -> A) -> A` to `fn as_bytes_reader<'r,A>(&mut self, f: &'r fn(&'r mut BytesReader) -> A) -> A`
[20:18:22] <Yurume> which didn't work
[20:18:30] <indutny> yes, that's what I did too
[20:18:31] <strcat> brson: I have a shared ptr implementation that I think is correct ;p
[20:18:36] <strcat> other than missing #[non_owned]
[20:18:38] <indutny> it could be a rust bug, actually
[20:18:51] <strcat> brson: http://ix.io/5u5
[20:18:56] <indutny> because I've only added `mut` keywords to this code
[20:19:03] <indutny> and everything else was left unchanged
[20:19:13] <Yurume> it works without `mut` in `|mut r|`
[20:19:20] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[20:19:22] <Yurume> ah
[20:19:30] <Yurume> it compiles to the same position*
[20:19:31] <strcat> brson: could shove a & in it to make it non-owned though
[20:19:37] <Yurume> (i.e. same error)
[20:19:38] *** Joins: sp3d (a@moz-17CB39F1.fidnet.com)
[20:19:56] <indutny> Yurume: huh?
[20:20:18] <Yurume> indutny, at least the error is not due to a `mut`
[20:20:37] <indutny> oh, I got another error
[20:20:43] <indutny> note: first, the lifetime cannot outlive unknown scope: 25667.  Please report a bug....
[20:20:46] <indutny> haha
[20:20:47] <Yurume> ;)
[20:20:57] <Yurume> that's what I'm getting
[20:21:05] <indutny> yep, seems to be a bug
[20:21:13] <indutny> Yurume: are you rust contributor?
[20:21:13] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[20:21:15] <strcat> brson: missing an equivalent to a.x = 5; where a is @T though
[20:21:21] <strcat> I guess that can use a closure and check that there are no borrows
[20:21:27] <Yurume> sorta
[20:21:49] *** Quits: roselan (Mibbit@moz-F476CEA3.dclient.hispeed.ch) (Quit: zzz)
[20:21:50] <Yurume> though I don't have enough environment to hunt down that bug for now
[20:21:53] <strcat> anyway borrow_mut is fine... just not as cheap
[20:22:02] <indutny> Yurume: do you need my local patches?
[20:22:39] <Yurume> indutny, some copy editing has reproduced the error, so I think not
[20:22:48] <brson> strcat: nice
[20:22:55] <kimundi> Urrg I give up. Sad that that everyone says it shouldn't be solved generically... :(
[20:23:23] <indutny> Yurume: ok, I'm probably better return back to my stuff
[20:23:32] <indutny> seems like I failed to contribute some code to rust today :P
[20:23:55] <indutny> basically, I wanted to make Reader/Writer traits work with mutable self pointers
[20:24:06] <indutny> because that's what it already does right now (but for some fields)
[20:24:20] <Yurume> indutny, https://gist.github.com/lifthrasiir/253b4d59a945926989e3 this is my version (sorry for indents, firefox in windows somehow omits them)
[20:24:51] <Yurume> the entire Reader stuff needs redesigning ;)
[20:25:06] <indutny> yeah
[20:25:11] <indutny> Yurume: I agree
[20:25:24] <indutny> I tried using it for my struct
[20:25:31] <indutny> but it failed to work, miserably :)
[20:25:43] <Yurume> I guess virtually everyone worked with io agree on that... [citation needed]
[20:25:53] *** Quits: jaws (uid2871@moz-D8B63698.irccloud.com) (Ping timeout)
[20:25:53] *** Quits: jihyun (uid7128@moz-D8B63698.irccloud.com) (Ping timeout)
[20:25:53] *** Quits: geomyidae__ (uid214@moz-D8B63698.irccloud.com) (Ping timeout)
[20:25:53] *** Quits: wycats_ (uid79@moz-D8B63698.irccloud.com) (Ping timeout)
[20:26:04] *** Joins: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP)
[20:26:04] *** Quits: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP) (Z:lined (Open Proxy found on your host. Please visit www.blitzed.org/proxy?ip=115.68.131.49 for more information.))
[20:26:42] <strcat> brson: unique is a lot easier ofc since you can just transmute to &'self mut T and &'self T
[20:27:21] <strcat> would be good to include refcounting in the ffi tutorial once it can be made safe (via non_owned, maybe non_const is needed too)
[20:27:46] <strcat> a lot of libs use it
[20:28:57] <kimundi> Where is Writer/Reader defined?
[20:29:07] <indutny> libcore/io.rs
[20:29:20] <indutny> basically, that's what I did so far https://gist.github.com/indutny/11d5546b4dc15f71654e
[20:29:34] <indutny> please let me know if you've any comments about code style or anything
[20:29:45] <indutny> its very important for me since I've just started to learn language
[20:32:42] <Yurume> for now most Rust users have to evolve to Rust developers. ;)
[20:33:26] <doener> kimundi: http://pastebin.com/yWjvrZ4g -- inspired by http://www.facebook.com/notes/facebook-engineering/three-optimization-tips-for-c/10151361643253920
[20:33:33] <Yurume> I'm not fluent in Rust enough to judge the code style or similar, but it looks fine at the first glance
[20:33:55] <Yurume> I had to go sleep though ;)
[20:34:48] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Quit: quite sleepy)
[20:35:07] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[20:35:07] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14dea5464 to 141f65e4a: 02http://git.io/N3iJvQ
[20:35:07] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[20:35:09] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[20:35:10] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/aO0z9Q
[20:35:10] <ghrust> 13rust/06auto 14e5ca35d 15Björn Steinbrink: Reduce code bloat from managed allocations...
[20:35:10] <ghrust> 13rust/06auto 14b872900 15bors: auto merge of #6237 : dotdash/rust/reduce_bloat, r=brson...
[20:35:11] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[20:35:53] <kimundi> doener: Woha. What magic is that. xD
[20:36:29] <doener> kimundi: hm, unrolling 8 times instead of 4 still helps performance here
[20:36:40] *** Joins: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net)
[20:36:49] <doener> kimundi: guess you'll have to experiment with that if performance matters
[20:37:01] *** Quits: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[20:37:43] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[20:37:50] *** Quits: zakora (NC@moz-8EAF945F.fbx.proxad.net) (Quit: Textual IRC Client: www.textualapp.com)
[20:40:03] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[20:40:07] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[20:40:17] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[20:40:53] <kimundi> doener: Oh, interesting. So writing it with comparisons instead of div and mod can be faster?
[20:42:38] <doener> kimundi: IIRC integer division is one of the slowest things you can do (slower than float division in fact)
[20:43:01] <doener> kimundi: ah yeah, the hierarchy is even in the article
[20:44:38] <doener> kimundi: whether or not that compensates for the div/mod you need for the conversion itself, I don't now
[20:44:41] <doener> s/now/know/
[20:45:08] <kimundi> yeah...
[20:45:29] <doener> the facebook guy turned that last part into a search which is probably not (easily?) possibly for a generic impl
[20:50:01] *** Joins: SimonSapin (simon@moz-C4A83ED9.net-89-2-126.rev.numericable.fr)
[20:51:20] *** Quits: victorporof (victorporo@F1213546.14EB2DE0.79933D60.IP) (Quit: victorporof)
[20:53:40] *** Quits: gareth0 (gareth0@moz-4CC3D42B.dynamic.dsl.as9105.com) (Ping timeout)
[20:55:33] *** Joins: jviereck (Adium@moz-EFC52440.hsi.kabel-badenwuerttemberg.de)
[20:56:01] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[20:57:33] *** Joins: int3_ (int3_@moz-D0F6130A.subnet-248.amherst.edu)
[21:00:59] <doener> is there some kind of documentation on how managed allocation currently work? 
[21:01:36] <kimundi> doener: Currently @ boxes are reference counted + not working cycle collector
[21:01:48] <strcat> they're killed off when the task ends though
[21:01:54] <kimundi> doener: A tracing garbage collector is in the works.
[21:02:38] <doener> kimundi: yeah, I meant how the rc works internally. It looked like the take_glue (I guess that's the rc increment?) is called by the caller of a function taking a managed pointer, which looked weird to me
[21:03:16] <doener> but I have no experience implementing such stuff, so I'm curious why things are like that (or whether I just midread the generated assembler code)
[21:03:28] <doener> s/midread/misread/
[21:03:45] <kimundi> doener: Hmm. Don't know anything about that :)
[21:04:06] <strcat> doener: @mut is also not really finished right now in the main repo
[21:04:53] <strcat> doener: the caller has to do a refcount to copy it for a by-value parameter
[21:05:01] <strcat> so I think that's what take does
[21:05:47] <strcat> it doesn't make a great refcounted ptr because it copies implicitly instead of moving
[21:05:51] <doener> strcat: hm, is a fn foo(v: @int) expecting v to be passed by-value?
[21:05:58] <strcat> doener: yes
[21:06:01] <doener> hm, box-by-value?
[21:06:16] <strcat> doener: all parameters/assignments/returns are by-value
[21:06:22] <kimundi> doener: I think @ boxes always copy atm
[21:06:43] <kimundi> but only a dev can tell for sure
[21:07:15] <strcat> doener: if you take ~ or @ params, it's by-value
[21:07:40] <strcat> ~ acts like any type with a destructor though and moves when you do anything by-value
[21:08:01] <strcat> @ has implicit copying (increment refcount)
[21:08:11] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[21:08:26] <strcat> ofc if it was implemented sanely with a gc it wouldn't do that
[21:08:46] <strcat> doener: if you make a custom refcounted type it will move when you pass it by-value
[21:08:57] <strcat> saving a refcount
[21:09:21] <kimundi> doener: Hm, I'm unsure if the 'count_digits' function still gets the benefits of that article if base is arbitrary.
[21:11:29] <doener> kimundi: my test cases were with that small test rig, and the compiler inlined the base and did the multiplications at compile time. I guess if they happen at runtime that would be bad, yep.
[21:11:30] *** Joins: gareth0 (gareth0@moz-20C2C080.dynamic.dsl.as9105.com)
[21:12:29] <doener> strcat: so given the current implementation I'd probably be best of with & and &@ (when I might need to inc the rc later)?
[21:12:40] <kimundi> doener: The test function in that paste gets never called, maybe a miscopy?
[21:13:03] *** Quits: jviereck (Adium@moz-EFC52440.hsi.kabel-badenwuerttemberg.de) (Quit: Leaving.)
[21:13:11] <doener> kimundi: no, I used the test function initially, but switch to pure flog() for timing
[21:13:31] *** Quits: FrozenCow (FrozenCow@moz-9DF5D010.dynamic.upc.nl) (Client exited)
[21:13:33] <kimundi> ah, you time that externally, no I get it.
[21:13:36] <doener> kimundi: thinking about it, I think that's actually clog aka ceil(log(...))
[21:13:54] <doener> ... I think
[21:15:24] <kimundi> doener: shouldn't that random call be in the loop?
[21:15:33] <strcat> doener: or just pretend it's gc'ed today ;p
[21:15:52] <strcat> if it's a long-lived value you don't actually need to copy around a lot, you probably don't want the built-in @
[21:16:10] <doener> kimundi: the random call is just to stop the compiler from doing everything at compile time
[21:16:24] <kimundi> ah, I see :)
[21:16:58] *** Quits: SimonSapin (simon@moz-C4A83ED9.net-89-2-126.rev.numericable.fr) (Ping timeout)
[21:19:04] <kimundi> Hmm.... I'm way too incompetent to measure such things correctly. doener If I implement something could you help me with that?
[21:19:35] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[21:19:37] <doener> strcat: I'm still browsing through the code looking for "bloat" and basically try to figure out which parts I have to care about, and how to hack it to pretend that e.g. the @ impl is already finished
[21:21:20] *** Quits: lucian (lucian@moz-22A14C6A.cable.virginmedia.com) (Ping timeout)
[21:21:22] <doener> kimundi: I'm really bad at micro benchmarks. I only did some runs with "time" in the shell and looked at the generated asm (not that I could tell all _that_ much from that either)
[21:21:51] <strcat> doener: if it was finished copying it would be free afaik
[21:22:00] <strcat> other than the ptr copy ;p
[21:22:50] *** Joins: victorporof (victorporo@90976241.6D2FB7A4.79933D60.IP)
[21:23:03] *** Joins: victorporof_ (victorporo@90976241.6D2FB7A4.79933D60.IP)
[21:23:30] <doener> strcat: thought so, actually wondered why passing as an argument need a rc inc/dec at all. Wouldn't the caller's copy guarantee that the callee's copy stays valid? Just like with a borrowed pointer?
[21:24:14] <strcat> doener: no
[21:24:37] *** Quits: victorporof (victorporo@90976241.6D2FB7A4.79933D60.IP) (Ping timeout)
[21:25:22] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[21:25:37] <doener> Hmm... Why not?
[21:25:48] <strcat> doener: it can return it or store it somewhere
[21:26:08] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[21:26:08] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/aO0z9Q
[21:26:08] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[21:26:22] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Quit: Computer has gone to sleep.)
[21:27:28] <strcat> doener: passing by-@ is just by-value passing
[21:27:41] <doener> strcat: sure, stores in other variables would have to adjust the refcount, but arguments look like a special case to me
[21:28:52] <strcat> I guess
[21:28:56] <strcat> it will use a gc soon anyway
[21:29:21] <strcat> if you want to improve refcounting you should look at making a fast library implementation
[21:29:56] <strcat> move semantics handle doing the minimum refcounting just fine
[21:30:14] <kimundi> doener: Just noticed a problem with that loop algorithm: It doesn't handle overflow :(
[21:30:15] <Jesse> are libraries allowed to steal bits from malloc headers like @ does? ;)
[21:30:22] *** Quits: bheylin (brianheyli@E74A75A2.F993642.98C5AE08.IP) (Quit: bheylin)
[21:30:36] <strcat> Jesse: it doesn't steal anything from malloc
[21:30:50] <strcat> @u16 is 64 bytes
[21:30:58] <strcat> of allocated memory
[21:31:13] <indutny> is there any way to get unique number (i.e. pointer to i64) for an object?
[21:31:20] <indutny> s/object/poiner/
[21:31:25] <indutny> I mean standard non-hacky way
[21:31:30] <strcat> sadly non-managed ~ has those headers too
[21:31:48] *** Joins: steven_is_false (quassel@moz-144077DE.bchsia.telus.net)
[21:31:55] <kimundi> rusti: ~34i64 // indutny ^ ?
[21:31:56] <rusti> ~34
[21:32:07] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[21:32:07] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/85A10A
[21:32:07] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[21:32:10] <indutny> erm
[21:32:20] <indutny> I probably explained it wrong
[21:32:22] <kimundi> Or did you mean something different
[21:32:34] <steven_is_false> Hi I was wondering. I see a lot of library wrapping code that use the #[inline] attribute. Should I use #[inline] when wrapping libraries?
[21:32:38] <strcat> indutny: coerce & to * to uint
[21:32:39] <indutny> lets say we have function: fn id<T>(obj: @T) -> u64 {}
[21:32:46] <indutny> just to uint?
[21:32:47] <indutny> ok
[21:32:53] <indutny> will `as uint` work?
[21:33:01] <strcat> hm
[21:33:16] <strcat> rusti: let x = 5; let y: *int = &x; y as uint
[21:33:17] <rusti> 12304128
[21:33:34] <engla> indutny: you can't be sure the number is unique over time (if you don't know the GC implementation)
[21:33:38] <doener> kimundi: for base >= 2^32 you mean?
[21:33:40] <strcat> engla: you can
[21:33:50] <steven_is_false> rusti: let x : extern fn () = || { }; x as uint
[21:33:52] <rusti> more than 5 lines of output, pastebinned: http://sprunge.us/JMCI
[21:33:52] <engla> you can .. in this case?
[21:33:56] <Jesse> that seems dangerous. i'd have expected "y as uint" to auto deref y and give 5
[21:34:12] <strcat> I wouldn't
[21:34:20] <strcat> auto-deref only happens for methods
[21:34:25] <strcat> and [] indexing
[21:34:29] <strcat> and it's arguably a misfeature
[21:34:47] <steven_is_false> rusti: let x : extern fn () -> ! = util::unreachable; x as uint
[21:34:48] <rusti> more than 5 lines of output, pastebinned: http://sprunge.us/LSbC
[21:35:11] <steven_is_false> rusti: let x : extern fn () -> ! = core::util::unreachable; x as uint
[21:35:12] <rusti> error: internal compiler error: translating unsupported cast.
[21:35:19] <doener> kimundi: hm, no, happens for other bases as well, damn
[21:35:30] <steven_is_false> rusti: let x : extern fn () -> ! = core::util::unreachable; x as u64
[21:35:31] <rusti> error: internal compiler error: translating unsupported cast.
[21:35:41] <kimundi> doener: For any base in general. If the number has a value close to its maximum value, with the next power of base being over the max siz, it doesn't work.
[21:35:48] *** Quits: Kambfhase (kvirc@moz-1AEBDA53.travedsl.de) (Quit: PI is 3.)
[21:35:54] *** Quits: dymk_ (dymk@44EEE21C.A6E21E6E.5E500FC7.IP) (Connection reset by peer)
[21:36:13] <steven_is_false> Is support for casting function pointers to numbers planned? If one can cast unsafe pointers to numbers it seems reasonable to be able to cast function pointers to numbers.
[21:36:29] *** Joins: dymk (dymk@44EEE21C.A6E21E6E.5E500FC7.IP)
[21:36:42] <kimundi> doener: I could add more conditionals... But I have no idea what that would do.
[21:38:05] <indutny> thanks
[21:38:20] <indutny> engla: its non-moving
[21:38:34] <engla> ok. but it might change?
[21:38:39] <indutny> pointer - no?
[21:38:42] <indutny> err
[21:38:43] <strcat> engla: no it will always be non-moving
[21:38:44] <indutny> s/?//
[21:38:55] <engla> ok then :)
[21:39:04] <indutny> which is sad
[21:39:05] <indutny> :)
[21:39:06] <engla> (indutny: I meant the gc implementation might change)
[21:39:26] <indutny> I think rust needs so pinnable mark-compact gc
[21:39:31] <indutny> s/so/some/
[21:39:45] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[21:39:49] *** Joins: strcat1 (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[21:39:50] <indutny> i.e. mark as non-moving some regions or specific values
[21:39:51] <strcat1> ugh, wifi.
[21:39:54] <indutny> and move everything else
[21:40:17] <strcat1> indutny: & is incredibly common
[21:40:25] <strcat1> having to mark stuff would make the language slower
[21:40:27] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[21:40:31] <indutny> I didn't mean this
[21:40:37] <indutny> this should be addressed at language level
[21:40:45] <indutny> by just creating handles
[21:40:55] <indutny> and letting GC know about them
[21:40:55] <indutny> brb
[21:40:55] <strcat1> if you want speed you can just write code with ~ and &
[21:40:57] <indutny> food
[21:42:10] <steven_is_false> I tried writing code in C++ which did handles that indexed into a block of memory which could move around.
[21:42:37] <steven_is_false> In Rust it could be made safe with the whole lifetime stuff.
[21:43:14] <steven_is_false> Would it be possible to make a Handle <'r, T> type which points into a Heap <'r> ?
[21:43:30] <strcat1> @mut has to know if it is borrowed from
[21:43:34] <steven_is_false> And the place the Handle points around to could move around.
[21:43:37] <strcat1> so @mut essentially has pinning already done
[21:43:44] <strcat1> so that could use a moving gc
[21:43:52] <strcat1> a really, really restricted one
[21:44:34] <strcat1> still perfectly safe to treat ~ and & as unique object ids
[21:44:57] <gareth0> sounds kind of like arenas
[21:45:13] *** Joins: enticeing (user@40584768.29B601FE.5037098C.IP)
[21:45:39] <enticeing> is there a built-in equivalent to Option for two types?
[21:46:04] <steven_is_false> enticeing: Both Either,and Result.
[21:46:15] <enticeing> ah, Either is what i was thinking of
[21:46:20] <enticeing> it was on the tip of my tongue :P
[21:46:31] <enticeing> and can i stick an Either in an Option ?
[21:46:37] <strcat1> yes
[21:46:39] <strcat1> they're just enums
[21:46:41] <strcat1> they aren
[21:46:42] <Jeaye> rust-buildbot: 4
[21:46:43] <enticeing> okay, thanks
[21:46:43] <strcat1> aren't special*
[21:46:57] <Jeaye> strcat1: rusti is gone?
[21:47:00] *** Quits: spider-mario (spidermari@moz-EE4B8A09.rev.sfr.net) (Input/output error)
[21:47:02] <strcat1> enticeing: Option is just 'enum Option<T> { Some(T), None }
[21:47:05] *** strcat1 is now known as strcat
[21:47:08] <strcat> Jeaye: my wifi is acting up
[21:47:12] <Jeaye> :(
[21:47:12] <strcat> it just didn't reconnect yet
[21:47:13] <enticeing> yes
[21:47:29] <Jeaye> How can I cast from 0 to a C-style enum?
[21:47:29] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[21:47:33] <Jeaye> 'as' doesn't cut it.
[21:47:39] <strcat> Jeaye: not safe
[21:47:41] <Jeaye> Damnit
[21:47:52] <strcat> enums have to be restricted to their variants
[21:47:53] <steven_is_false> Jeaye: I hack around that using cast::transmute but yeah it's not safe.
[21:47:53] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[21:48:08] <Jeaye> steven_is_false: Yeah, I know of transmute. Was just hoping it could be safew.
[21:48:18] <Jeaye> Oh well. Thanks.
[21:48:20] <strcat> Jeaye: it could be done safely by wrapping the unsafe operation
[21:48:28] <strcat> it needs to check that the integer matches one of the variants
[21:48:35] <Jeaye> Yeah.
[21:48:40] <steven_is_false> Jeaye: Apparently for things like bool a match, or an if can be optimized away but I don't know about bigger enums.
[21:49:00] <strcat> you can never safely store a non-variant in a C-like enum
[21:49:01] <doener> kimundi: easy way out is to make base a u8 and unroll only 4 (u32) or 8 (u64) times. 
[21:49:21] <strcat> match is an exhaustive match for one thing that relies on that
[21:49:31] <strcat> and the compiler marks every enum discriminant load with a range assert
[21:49:56] <steven_is_false> Will match x { A => 0, B => 1, C => 2, D => 3 } be optimized like if x { 1 } else { 0 } will?
[21:50:20] <strcat> it compiles down to a switch in the IR
[21:50:32] <strcat> it will put A, B and C in the switch and D will be the default case
[21:50:49] <strcat> it's an exhaustive match, it always has to list all the possible cases
[21:51:08] <strcat> completely undef behaviour if you have a c-like enum with 1, 2, 3 and you put 5 in it
[21:51:20] <strcat> which is why you can't in safe code
[21:51:30] <steven_is_false> strcat: So for the utmost performance one would have to use cast::transmute?
[21:51:43] <strcat> steven_is_false: ?
[21:51:50] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[21:52:02] <strcat> faster than what?
[21:52:22] <steven_is_false> Someone told me that if x { 1 } else { 0 } doesn't actually generate a branch because the compiler knows that a bool will always be 1 or 0
[21:52:50] <steven_is_false> strcat: So I was wondering whether the more general case would branch.
[21:52:52] <strcat> it's not special cased
[21:53:01] <strcat> the compiler optimizations are general
[21:53:19] <strcat> bools have range asserts on the loads
[21:53:22] *** Parts: judder (maradukewa@DABDEEA3.F2C0D0AC.78E362FE.IP) ()
[21:53:23] <strcat> llvm knows they are always 0 or 1
[21:53:36] <kimundi> doener: I'm not sure how that would help. base is [2-36] anyway, and you could still get an overflow?
[21:53:38] <strcat> enum variants have range asserts on the loads too
[21:53:47] <strcat> llvm knows the range of all the variants
[21:53:49] <enticeing> hmmmm, rustc is hanging on this line
[21:54:01] <enticeing> http://ix.io/5uc
[21:54:06] <strcat> it knows enum { A, B, C } is [0, 1, 2] on every load
[21:54:15] <strcat> {0, 1, 2} *
[21:54:51] <enticeing> okay, so it doesn't like me doing Option<Either<....>>
[21:55:04] *** Quits: fabiand (fabiand@moz-86B8CBB0.adsl.alicedsl.de) (Quit: Verlassend)
[21:55:04] <steven_is_false> strcat: So an enum variant match like I described in pseudo-notation would appear to LLVM like match x is in [0, n] { 0 => 0, 1=>1, 2=>2, 3=>3, etc... } and be optimized away?
[21:55:11] <strcat> enticeing: should work fine
[21:55:17] <strcat> rusti: Some(Left(1))
[21:55:18] <rusti> foo.rs:4:17: 4:21 error: internal compiler error: Autoderef but type not derefable: [type error]
[21:55:18] <rusti> foo.rs:4     let s = fmt!("%?", {
[21:55:18] <rusti>                           ^~~~
[21:55:18] <rusti> note: in expansion of fmt!
[21:55:18] <rusti> foo.rs:4:12: 6:7 note: expansion site
[21:55:33] <strcat> rusti: let x = Some(Left(1)); fmt("%?", x)
[21:55:35] <rusti> more than 5 lines of output, pastebinned: http://sprunge.us/dMjf
[21:55:39] <doener> kimundi: how so? 255 (max u8) to the power of 8 is less than 2^64 so it fits into a u64 (same deal with 4 unrolls and u32). And after those, you have a division and start fresh from b^1. Where would you get an overflow?
[21:55:42] <strcat> rusti: let x = Some(Left(1)); fmt!("%?", x)
[21:55:43] <rusti> more than 5 lines of output, pastebinned: http://sprunge.us/RFGS
[21:55:53] * strcat shrugs
[21:56:07] <strcat> rusti: let x = Left(1); x
[21:56:07] <rusti> foo.rs:4:17: 4:21 error: internal compiler error: Autoderef but type not derefable: [type error]
[21:56:08] <rusti> foo.rs:4     let s = fmt!("%?", {
[21:56:08] <rusti>                           ^~~~
[21:56:08] <rusti> note: in expansion of fmt!
[21:56:08] <rusti> foo.rs:4:12: 6:7 note: expansion site
[21:56:19] <steven_is_false> strcat: I guess it's time for me to do some personal investigation.
[21:56:26] <enticeing> i could probably get by with just an Either<> if i needed to
[21:56:41] <strcat> steven_is_false: rustc knows the match is exhaustive and it knows the range of the variants
[21:56:44] <strcat> and it communicates it to llvm
[21:56:44] <kimundi> doener: Ah, wait...
[21:56:56] <steven_is_false> strcat: Okay.
[21:57:03] <strcat> steven_is_false: match with 4 cases will generate an LLVM switch with 3 cases and the default label for the last
[21:57:11] <strcat> steven_is_false: and it will put a range assert on the load
[21:57:17] <strcat> there's nothing you can do to make it faster
[21:57:30] <strcat> for complex cases there are pattern matching optimizations that could be done
[21:57:35] <strcat> but in the simple case there's nothing to improve
[21:57:56] <strcat> it's faster than matching an enum in C with switch.
[21:58:07] <strcat> C can't put a range assert
[21:58:17] <strcat> (well it won't actually be faster, the range assert hardly does anything most of the time ;p)
[21:58:37] <enticeing> strcat: okay, so it was hanging when i accidentaly put [Group, ..2] instead of ~[Group, ..2]
[21:58:56] <strcat> enticeing: should report it :)
[21:59:21] <enticeing> where should i?
[21:59:30] <enticeing> and i don't know too many of the details
[21:59:32] <strcat> https://github.com/mozilla/rust/issues?state=open
[21:59:39] <strcat> enticeing: if you can make a test case that fails, that's perfect
[21:59:50] <strcat> smaller is better but if you can't cut it down that's fine
[22:00:24] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Quit: Leaving)
[22:02:18] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[22:05:12] <enticeing> well, i could just put the struct in the issue?
[22:05:37] <strcat> enticeing: yeah that's fine
[22:06:19] <doener> strcat: btw, what did you mean by "making a fast library implementation"?
[22:06:57] <strcat> doener: @ will be gc'ed in the near future so reference counting will be left to library code
[22:07:16] <strcat> I think graydon is just ironing out the remaining gc bugs
[22:07:22] <doener> ah
[22:08:46] *** Quits: dymk (dymk@44EEE21C.A6E21E6E.5E500FC7.IP) (Ping timeout)
[22:08:51] <strcat> there's ARC (atomic reference counting - immutable shared memory), and there can be Rc and RcMut for local ones
[22:09:04] <kimundi> bjz: ping
[22:09:21] <bjz> kimundi: yohowdy! :)
[22:09:39] <enticeing> https://github.com/mozilla/rust/issues/6238
[22:09:55] *** Joins: dymk (dymk@44EEE21C.A6E21E6E.5E500FC7.IP)
[22:10:07] <enticeing> i broke rustc :P
[22:10:15] <kimundi> bjz: Something I noticet earlier today: WHy do the functions in num::BitCount return Self instead of uint ?
[22:10:25] <doener> guess I'll stay with digging around and getting acquainted with the language for now :-)
[22:10:31] <steven_is_false> So I don't quite understand. How are circular references with RCs going to be disallowed?
[22:10:54] <bjz> kimundi: yeah I wasn't quite sure about that
[22:11:03] <strcat> steven_is_false: T: Owned
[22:11:37] <bjz> kimundi: uint might be better
[22:11:41] <strcat> steven_is_false: dunno about ARC.
[22:11:47] <strcat> I know Rc and RcMut can be entirely safe
[22:12:00] <strcat> I could write a safe Rc in the language right now, RcMut needs #[non_owned] without abusing &
[22:12:12] <strcat> hmm
[22:12:30] <kimundi> bjz: It's a count of bits. Only way to have something with more bits than an uint can represent would be to have a value greater than pointer size. :)
[22:12:46] <kimundi> Also impossible.
[22:14:01] <strcat> nmatsakis: you around?
[22:15:20] <nmatsakis> strcat: not really. but sort of :)
[22:15:28] *** Joins: thou (thou@moz-1C1CA9F7.fasttrackcomm.net)
[22:15:57] <strcat> nmatsakis: would adding a #[non_owned] attribute just involve adding a TypeContents bit?
[22:16:58] <nmatsakis> strcat: I think so, yes.
[22:17:26] *** Quits: boggle (boggle@moz-BCEB49E4.dip0.t-ipconnect.de) (Quit: boggle)
[22:17:40] <strcat> nmatsakis: would a mutable reference counted type also need to mark itself as non-Const? I'm not sure what that would actually change
[22:18:10] <nmatsakis> strcat: I don't know what a mutable ref counted type means
[22:18:25] <nmatsakis> strcat: it means @mut minus the @?
[22:18:28] <strcat> nmatsakis: like @mut but as a library type with reference counting
[22:18:38] <strcat> only allowed T: Owned types to be contained
[22:18:40] <strcat> allowing*
[22:18:41] <nmatsakis> strcat: then yes, it would not be Const
[22:19:10] <nmatsakis> for Const, think: two threads could access this simultaneously without the possibility of data races, no matter what they do to it
[22:19:35] <strcat> for now I think I could just put Option<&()> in Rc and Option<&mut ()> in RcMut
[22:19:43] <strcat> and just set them to None...
[22:20:00] <strcat> nmatsakis: is something with &mut Const? (should it be?)
[22:21:45] <strcat> anyway I'll start with the library types and then figure out how to make those attributes
[22:22:19] <nmatsakis> strcat: sorry, ask me later (can't type now)
[22:22:26] <strcat> nmatsakis: k, no worries
[22:22:46] *** Joins: FrozenCow (FrozenCow@moz-9DF5D010.dynamic.upc.nl)
[22:24:25] *** Quits: steven_is_false (quassel@moz-144077DE.bchsia.telus.net) (Client exited)
[22:27:12] *** Quits: bleibig (bleibig@moz-58EF3B3A.rochester.res.rr.com) (Quit: bleibig)
[22:28:46] *** Joins: geomyidae__ (uid214@moz-D8B63698.irccloud.com)
[22:28:47] *** Joins: jaws (uid2871@moz-D8B63698.irccloud.com)
[22:29:00] *** Joins: boggle (boggle@moz-BCEB49E4.dip0.t-ipconnect.de)
[22:31:00] *** Quits: int3_ (int3_@moz-D0F6130A.subnet-248.amherst.edu) (Client exited)
[22:31:12] *** Joins: int3_ (int3_@moz-D0F6130A.subnet-248.amherst.edu)
[22:32:10] *** Joins: jihyun (uid7128@moz-D8B63698.irccloud.com)
[22:35:55] *** Quits: gareth0 (gareth0@moz-20C2C080.dynamic.dsl.as9105.com) (Quit: Leaving)
[22:36:14] *** Joins: solancile (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net)
[22:37:26] <brson> nmatsakis: I have a branch that registers snapshots here https://github.com/brson/rust/tree/snapshots but it crashes building rustc in stage0
[22:37:33] <Diablo-D3> http://livicons.com/#examples
[22:37:37] <Diablo-D3> completely unrelated to rust
[22:37:40] <Diablo-D3> but thats pretty clevar
[22:37:45] *** Joins: skchrko_ (sk@61A494B3.BA40E8A.AAC02D62.IP)
[22:37:54] *** Quits: cdidd (cdidd@63A838E1.271BFDAC.62D8163C.IP) (Ping timeout)
[22:38:31] <brson> nmatsakis: just fyi. still working on it
[22:39:13] *** Joins: strcat1 (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[22:39:32] *** Quits: RagingDave (RagingDave@moz-3F31ACEF.pools.arcor-ip.net) (Quit: Ex-Chat)
[22:40:07] <strcat1> heh there are so many of those condition jump depends on uninit value warnings now without suppressions
[22:40:12] *** aatch|bed is now known as aatch
[22:40:12] <strcat1> conditional*
[22:40:16] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[22:40:22] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[22:40:22] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[22:42:30] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Leaving...)
[22:43:59] *** Joins: wycats_ (uid79@moz-D8B63698.irccloud.com)
[22:44:11] *** Quits: int3_ (int3_@moz-D0F6130A.subnet-248.amherst.edu) (Client exited)
[22:45:01] *** strcat1 is now known as strcat
[22:45:14] <strcat> brson: heh that reference counted pointer was slightly buggy
[22:45:27] <strcat> I think...
[22:45:32] <strcat> or I found a bug somewhere else :(
[22:46:19] <brson> nmatsakis: oh, think i figured out that crash. should have snapshots soon!
[22:46:53] <brson> strcat: it's ok. bugs abound
[22:48:26] <strcat> brson: somehow putting ~5 in it causes a crash in the test case that usually works
[22:48:30] * strcat sighs
[22:48:51] <strcat> *** Error in `./rc': free(): invalid pointer: 0x00007f7cc0000088 ***
[22:49:06] <strcat> time to print out a bunch of pointers \o/
[22:50:08] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[22:50:08] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14611c04f to 14b872900: 02http://git.io/N3iJvQ
[22:50:08] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[22:50:32] *** Joins: goldfeld (Mibbit@74A459DB.EC2C9DB7.8DF84892.IP)
[22:50:46] <indutny> internal compiler error: calling transform_self_type_for_method on static method
[22:50:48] <indutny> just got this
[22:50:55] <indutny> in 0.6
[22:51:12] <indutny> code: https://gist.github.com/indutny/613853eac55e0ae2c171
[22:52:09] <goldfeld> hey guys, I'm trying to compile this lua bindings lib against 0.6 https://github.com/doy/rust-lua/blob/master/lua.rs but I'm getting 'unresolved name' on the 'use ptr:null' line
[22:52:33] <goldfeld> use ptr::null*
[22:52:48] *** Quits: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP) (Quit: night)
[22:53:10] <brson> goldfeld: try `use core::ptr::null`
[22:54:51] <goldfeld> thanks a bunch, I poured through the 0.6 changelog where it was mentioned a bunch of std:: stuff had become core::, but there was no mentioning ptr
[22:55:07] *** Joins: cdidd (cdidd@moz-5318450.broadband.corbina.ru)
[22:55:19] <goldfeld> I suppose use libc:: did undergo the same change?
[22:58:49] <cyndis> 'use' now requires absolute paths, ptr::null or libc didn't move
[22:58:54] <brson> goldfeld: the change is in how resulotion works with `use`. ptr and libc were in core before and are reexported from the prelude. this used to mean you could simply `use ptr`. now though all `use` statements are resolved from the crate level so you have to prefix core imports with `core`. the distinction is annoying and hard to explain. name resolution sucks
[22:59:08] <brson> probably no modules should be reexported from the prelude
[22:59:27] <strcat> brson: yeah I'm someone triggering a bug in ~ afaict...
[22:59:31] <brson> it's very odd that you can say `libc::malloc` in an expression but not in a use statement
[22:59:37] <strcat> hmm
[23:03:52] *** Quits: Jesin (Jessin_@moz-A03A364F.cc.lehigh.edu) (Ping timeout)
[23:03:52] * strcat doesn't understand at all :(
[23:03:57] <strcat> ot
[23:04:06] <strcat> it's calling free on some random memory location*
[23:04:13] <strcat> I can comment out my free call... it's not that
[23:06:07] <goldfeld> thanks brson, I had read about the change to resolving on the crate level so that makes a lot of sense actually.
[23:08:38] *** Quits: enticeing (user@40584768.29B601FE.5037098C.IP) (Client exited)
[23:09:23] *** Quits: victorporof_ (victorporo@90976241.6D2FB7A4.79933D60.IP) (Quit: victorporof_)
[23:10:29] <strcat> #7  0x00007ffff7928a5d in unstable::exchange_alloc::free::_51dce5db6c932a2::_07pre ()
[23:10:31] <strcat> yep
[23:11:21] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[23:14:37] <strcat> brson: so, it seems somehow part of the pointer is being clobbered...
[23:14:54] *** Quits: jack (jack@EF36212C.8FA609AD.840029BC.IP) (Quit: Leaving.)
[23:16:17] <kimundi> bjz: Under the new num traits, is the correct way to check for -inf this one: num.is_infinite() && num.is_negative() ?
[23:16:31] <strcat> brson: it's always 0x00007fbb00000088 ;\
[23:16:41] * strcat sighs
[23:20:28] <Luqman> \o/ success! i got a rust hello world running debian armv5tel linux
[23:23:24] <strcat> Luqman: http://ix.io/5ud does this crash for you? (compiled with rustc --test)
[23:23:57] <strcat> (when running it)
[23:25:05] <Luqman> yep (6952,0x10a21e000) malloc: *** error for object 0x5000000000000000: pointer being freed was not allocated
[23:25:15] <strcat> alright I think that's definitely a compiler bug
[23:25:17] * strcat reports
[23:25:35] <strcat> it somehow tries to free some weird block of memory
[23:25:40] <strcat> instead of the ptr
[23:26:02] <doener> I get either a dangling allocation message or a crash
[23:26:11] <strcat> oh
[23:26:19] <strcat> I know why it's doing that.
[23:26:21] <strcat> it's my fault :)
[23:26:40] *** Joins: Thad (chatzilla@moz-C35F90AE.tx.res.rr.com)
[23:26:51] <strcat> *ptr = foo; isn't initializing, it's assigning
[23:26:53] <brson> Luqman: cool! are you running it on hardware or an emulator?
[23:26:57] <strcat> so it's destroying the old one
[23:27:45] <Luqman> brson: hardware a ts-7800 i believe
[23:28:03] <Luqman> running the binary that is, i cross compile from x64 linux
[23:28:51] <Thad> hmm... backtrace... anyone have ideas about what to do about that on Cygwin ?!?!?
[23:29:16] <Thad> I thought I could fudge in __WIN32__ alternative, but seems NO.
[23:29:18] <brson> Thad: #ifdef it to a no-op. it only works on linux anyway
[23:29:28] <Thad> ah, thought so.
[23:29:33] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Client exited)
[23:30:16] <strcat> yay it works now
[23:30:34] <Thad> brson: but how will I trace with gdb against Cygwin then ?
[23:30:35] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[23:32:21] <brson> Thad: gdb backtraces work independently from the backtrace function in the runtime. gdb back traces may or may not work, but won't depend on the backtrace function working
[23:32:36] <Thad> brson: gotcha
[23:33:22] *** Joins: Jesin (Jessin_@moz-A03A364F.cc.lehigh.edu)
[23:34:43] <kimundi> Thad: btw, in case you diyn't get a reply of the mailing list yet, libuv will be important for rust.
[23:35:10] <Thad> kimundi: oh joy... woe is me. :)
[23:35:45] <goldfeld> I'm trying to compile 'rustc lua.rs --lib' and I'm getting 'cannot find -llua', tried adding -L/usr/bin/ but same error
[23:36:35] <goldfeld> sorry for being a complete nood but what could be wrong?
[23:38:10] <strcat> brson: should I put a module with task-local reference counted ptrs in core or std? (the idea being to keep deterministic rc'ing once @is gc'ed)
[23:38:20] <Thad> "" /home/Thad/rust/src/rt/rust_task.cpp:452:21: error: no member named 'backtrace'      in the global namespace  ... oh wow, can't even have the function there ?  how to politely do a no-op for that ?
[23:38:37] <engla> goldfeld: maybe it's called -llua5.2 in your setup
[23:39:28] *** Joins: strcat1 (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[23:40:00] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (NickServ (GHOST command used by strcat1))
[23:40:02] *** strcat1 is now known as strcat
[23:40:12] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[23:40:13] *** Joins: int3_ (int3_@moz-1692740B.subnet-248.amherst.edu)
[23:40:18] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[23:40:25] <brson> strcat: std for now I think
[23:40:44] <brson> strcat: while I need something similar for the runtime, I suspect that I have unique requirements
[23:40:52] <goldfeld> so how am I supposed to tell the compiler to link against -llua5.2 instead?
[23:40:58] *** kimundi is now known as zz_kimundi
[23:41:17] <brson> strcat: in particular I need to make sure that my RC type is both non-sendable but also allocated using the exchange allocator
[23:41:21] <aatch> goldfeld, you can add --link-args="-llua5.2" on the command line
[23:41:29] <strcat> brson: well this uses malloc directly and is non-sendable
[23:41:56] <strcat> brson: it contains Option<@()> right now as a workaround for not having #[non_owned] though
[23:42:02] <strcat> doesn't ever allocate one
[23:42:27] <brson> the type containing an @ will make it allocate using the local allocator
[23:42:37] <strcat> brson: right, but that can be fixed :)
[23:42:56] <strcat> brson: well it's calling malloc directly too - so I don't think it would
[23:43:03] *** Joins: jack (jack@EF36212C.8FA609AD.840029BC.IP)
[23:43:23] <aatch> strcat, out of interest, what would adding non-owned take? In terms of effort?
[23:43:35] <strcat> I think I just need to add a constant to TypeContents
[23:43:42] <strcat> it looks pretty full already though...
[23:43:57] <strcat> I guess it's not ;p
[23:44:03] <strcat> just the way the constants are formatted right now
[23:44:47] *** Quits: boggle (boggle@moz-BCEB49E4.dip0.t-ipconnect.de) (Quit: boggle)
[23:45:27] <jack> how do you get a range of the full u8 space?
[23:45:28] *** Quits: thou (thou@moz-1C1CA9F7.fasttrackcomm.net) (Input/output error)
[23:45:42] <jack> u8::range(0, 256) fails (due to wrapping)
[23:45:58] <strcat> brson: https://gist.github.com/thestinger/5519181 here's what it is right now
[23:46:12] <strcat> will make anything that contains it use the local allocator though
[23:46:14] <strcat> for now
[23:46:26] * strcat will put it in std for now anyway
[23:46:32] <strcat> until that issue is fixed at least
[23:46:56] *** Quits: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se) (Client exited)
[23:47:27] <goldfeld> aatch thanks for the help, though apparently rustc doesn't expose --link-args, I'm trying to find the syntax for putting lua5.2 as a requirement in the source code maybe under a #[cfg_attr
[23:47:40] <aatch> goldfeld, oh, right it's not in 0.6
[23:48:04] <aatch> If you can, build the latest from incoming.
[23:48:10] <brson> strcat: looks good!
[23:48:14] <goldfeld> oh, I see
[23:48:16] * aatch knows that rustc exposes --link-args, he added it
[23:48:22] <brson> jack: that's unnfortunate :( I guess you can use a wider type
[23:48:31] <goldfeld> but would you recommend that over a cfg_attr based on my environment?
[23:49:05] <jack> brson: yes, but this kind of sucks :)
[23:49:07] <aatch> brson, sounds like we might need a range_inclusive
[23:49:18] <aatch> or some other name
[23:50:05] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[23:50:05] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/xeOUnw
[23:50:05] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[23:50:28] <jack> perhaps the end param should always be a higher type? still have an issue with u64 i suppose
[23:50:34] <aatch> goldfeld, I don't know what your environment is.
[23:51:15] <goldfeld> I'm on linux mint specifically
[23:51:55] <aatch> goldfeld, well it depends on where the -llua flag is coming from.
[23:53:07] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[23:53:07] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/BE8V7g
[23:53:07] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[23:53:08] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[23:53:08] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/RASHKg
[23:53:08] <ghrust> 13rust/06auto 147ac6571 15Young-il Choi: rt: glob, globfree dummy function for android
[23:53:08] <ghrust> 13rust/06auto 14d816101 15bors: auto merge of #6234 : yichoi/rust/glob-dummy-pull, r=brson...
[23:53:08] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[23:53:13] <aatch> Given your error, I think that it's existence is the issue
[23:53:25] <aatch> (existence of the flag)
[23:55:20] <goldfeld> I'm too new to this stuff to know where it's being requested, but here's the simple file i'm trying to compile https://github.com/doy/rust-lua/blob/master/lua.rs
[23:55:52] <goldfeld> (plus some modifications I made to bring it to 6.0)
[23:56:52] <aatch> goldfeld, ok. So you altered the extern mod near the bottom?
[23:57:12] <goldfeld> right, that makes sense
[23:57:21] <goldfeld> does it need quoting?
[23:57:32] <goldfeld> assuming you mean to change it to lua5.2
[23:57:57] <aatch> goldfeld, no, the proper way is to have mod lua { extern { <foreign fns> } }
[23:58:19] <aatch> And then add #[link_name="lua5.2"] to the extern block.
[23:58:32] <brson> jack: I would be ok with an inclusive range function
[23:58:42] <aatch> Or possibly #[link_args="-llua5.2"]
[23:58:49] <aatch> I'm not sure what works and what doesn't
[23:59:06] <brson> nmatsakis: snapshots are done
[23:59:35] <Thad> brson: like this ?  http://pastebin.mozilla.org/2375552
[23:59:58] *** Quits: doener (doener@moz-724BBC7C.unitymediagroup.de) (Quit: leaving)

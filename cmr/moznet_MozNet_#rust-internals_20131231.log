[00:00:05] <dbaupp> pnkfelix is working on GC, right?
[00:00:14] <pcwalton> not sure
[00:00:18] <pcwalton> I think he was working on DST
[00:00:53] <dbaupp> ah, ok
[00:00:56] *** Quits: nrc (ncameron@moz-AD2938E.hari.cable.virginm.net) (Ping timeout)
[00:00:57] <dbaupp> must've misremembered
[00:01:54] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[00:03:18] <pcwalton> http://www.hpl.hp.com/personal/Hans_Boehm/gc/gc_source/gc_typedh.txt
[00:03:23] <pcwalton> cmr: dbaupp: ^
[00:06:01] *** Quits: benh (ben@moz-4A0366D2.org) (Ping timeout)
[00:06:22] <dbaupp> oh, we need type info... would that require compiler support to generate efficiently?
[00:07:08] <pcwalton> yup
[00:07:11] <pcwalton> that's part of the type descriptor
[00:07:33] <pcwalton> we already pass that to malloc with GC though
[00:07:41] *** Joins: benh (ben@moz-4A0366D2.org)
[00:07:48] <dbaupp> is it the appropriate format for boehm?
[00:07:51] <pcwalton> so the boehm-GC-wrapper would just yank that type info out of the type descriptor and pass it to GC_malloc_explicitly_typed
[00:07:55] <pcwalton> nah, we'd have to write that ourselves
[00:07:58] <pcwalton> shouldn't be terribly hard
[00:08:08] <pcwalton> now that we have adt
[00:08:42] <dbaupp> wouldn't that mean every allocation requires converting tydesc to boehm at runtime, or would the format be built in to the compiler?
[00:12:42] <pcwalton> built into the compiler
[00:12:48] <pcwalton> we could even just think of it as the "Boehm map" feature
[00:13:02] <pcwalton> just call it "Boehm map support for Rust"
[00:14:52] <pcwalton> we could say something like "If you wish to use the Boehm garbage collector with Rust, then the compiler has some support for automatically generating precise information for it. Just use the #[generate_boehm_gc_map] flag."
[00:20:22] *** Joins: ChristopherBurg (Christophe@moz-2C03E71B.hfc.comcastbusiness.net)
[00:36:51] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[00:36:51] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14ac485fd to 14df25bb6: 02http://git.io/N3iJvQ
[00:36:51] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[00:38:38] *** Joins: erickt1 (Adium@moz-4B000CB7.dyn.optonline.net)
[00:41:55] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[00:41:55] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/KKB5Hg
[00:41:55] <ghrust> 13rust/06auto 148562229 15Vadim Chugunov: Revert "Embed Windows application manifest."
[00:41:55] <ghrust> 13rust/06auto 14b9a566a 15bors: auto merge of #11221 : vadimcn/rust/revert-manifest, r=alexcrichton...
[00:41:55] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[00:53:23] <brson> vadimcn: since you are the unwinding guru you might consider adding a backtrace feature to std
[00:56:49] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[00:56:49] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14b9a566a to 14df25bb6: 02http://git.io/N3iJvQ
[00:56:49] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[00:56:50] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[00:56:50] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/uHCLPw
[00:56:50] <ghrust> 13rust/06auto 145b88f92 15Brian Anderson: Don't allow single-variant enums to be dereferenced. #6246...
[00:56:50] <ghrust> 13rust/06auto 14ad1fa1f 15Brian Anderson: Don't allow newtype structs to be dereferenced. #6246
[00:56:51] <ghrust> 13rust/06auto 14d102e26 15Brian Anderson: rustc: Add error about obsolete struct deref
[00:56:53] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[01:00:45] <brson> acrichto: are we getting much build parallelism out of our new crates?
[01:05:30] <sfackler> brson: how did oldrt's backtrace work?
[01:05:59] <brson> sfackler: it didn't. we did defer to the system 'backtrace' function, but it only worked on linux
[01:06:07] <sfackler> ah
[01:06:11] <brson> sfackler: I think we can pretty trivially use libunwind plus custom demangling
[01:06:18] <brson> will involve making our mangling more sensible
[01:07:07] <strcat> atm the mangling can't be reversed
[01:07:14] <strcat> sometimes uses ids
[01:09:19] *** Joins: pnkfelix (pnkfelix@moz-3DF70E54.hsd1.wa.comcast.net)
[01:09:26] *** Quits: pnkfelix (pnkfelix@moz-3DF70E54.hsd1.wa.comcast.net) (Input/output error)
[01:11:43] *** Quits: erickt1 (Adium@moz-4B000CB7.dyn.optonline.net) (Quit: Leaving.)
[01:15:21] <vadimcn> brson: libgcc has _Unwind_Backtrace function, not sure how well it works though
[01:16:47] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[01:16:47] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14420398b to 14df25bb6: 02http://git.io/N3iJvQ
[01:16:47] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[01:16:48] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[01:16:48] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/-w8F-Q
[01:16:48] <ghrust> 13rust/06auto 14c7b601c 15Edward Z. Yang: Elaborate manual on matching (dereference patterns, lvalue/rvalue matching)...
[01:16:48] <ghrust> 13rust/06auto 1418d373e 15bors: auto merge of #10892 : ezyang/rust/lvalue-match, r=brson...
[01:16:48] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[01:21:25] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Connection reset by peer)
[01:23:14] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[01:49:35] <acrichto> brson: we can build lib{green, native, extra, rustuv} in parallel, but I don't think that we gained much in build times
[01:54:25] *** Quits: dcrewi (david@moz-AB8667CE.gyrae.net) (Ping timeout)
[01:55:43] *** Joins: vfetwnuncszu (david@moz-AB8667CE.gyrae.net)
[01:55:53] *** vfetwnuncszu is now known as dcrewi
[02:11:47] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[02:11:47] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1418d373e to 14df25bb6: 02http://git.io/N3iJvQ
[02:11:47] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[02:11:50] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[02:11:50] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/iWP_og
[02:11:50] <ghrust> 13rust/06auto 1495aecc7 15Alex Crichton: Convert relevant static mutexes to Once
[02:11:50] <ghrust> 13rust/06auto 148e4eff1 15bors: auto merge of #11187 : alexcrichton/rust/once, r=brson...
[02:11:50] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[02:20:04] *** Joins: lpy (lpy@7360AA58.F09091A8.1348A864.IP)
[02:21:49] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[02:21:49] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 148e4eff1 to 14df25bb6: 02http://git.io/N3iJvQ
[02:21:49] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[02:21:50] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[02:21:50] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/gGuB_g
[02:21:50] <ghrust> 13rust/06auto 1454462a3 15Alex Crichton: Move task count bookeeping out of libstd...
[02:21:50] <ghrust> 13rust/06auto 14cd2227e 15bors: auto merge of #11212 : alexcrichton/rust/local-task-count, r=brson...
[02:21:51] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[02:56:58] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[02:56:58] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/nb6U1g
[02:56:58] <ghrust> 13rust/06auto 148562229 15Vadim Chugunov: Revert "Embed Windows application manifest."
[02:56:58] <ghrust> 13rust/06auto 14a1d3cc5 15bors: auto merge of #11221 : vadimcn/rust/revert-manifest, r=alexcrichton...
[02:56:58] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[02:56:59] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[02:56:59] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14cd2227e to 14df25bb6: 02http://git.io/N3iJvQ
[02:56:59] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[03:02:05] *** Quits: pcwalton (pcwalton@moz-C07D5168.p2p.sfo1.mozilla.com) (Quit: pcwalton)
[03:31:11] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.2)
[03:40:54] *** Quits: zz_kimundi (kimundi@moz-6166D3C8.dip0.t-ipconnect.de) (Ping timeout)
[03:42:27] *** Quits: dcrewi (david@moz-AB8667CE.gyrae.net) (Ping timeout)
[03:42:28] *** Joins: vfetwnuncszu (david@moz-AB8667CE.gyrae.net)
[03:42:41] *** vfetwnuncszu is now known as dcrewi
[03:44:05] <dbaupp> Do impls have DefIds? If so, is there an easy way to go from some_foo.some_trait_method() to the DefId of `impl SomeTrait for Foo { ... }`?
[03:44:45] *** Joins: zz_kimundi (kimundi@moz-B14500D7.dip0.t-ipconnect.de)
[03:44:46] *** zz_kimundi is now known as kimundi
[03:49:37] <dbaupp> ah, found something... now, how do I do it for static methods like `SomeTrait::bar()` to get the appropriate impl (when one exists)?
[04:06:55] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[04:06:55] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/nb6U1g
[04:06:55] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[04:11:53] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[04:11:53] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/9rV6rQ
[04:11:53] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[04:11:55] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[04:11:55] <ghrust> 01[13rust01] 15bors pushed 15 new commits to 06auto: 02http://git.io/kz3hdA
[04:11:55] <ghrust> 13rust/06auto 144825a1f 15Patrick Walton: libsyntax: Make the parser mutable
[04:11:55] <ghrust> 13rust/06auto 14dcc2cf6 15Patrick Walton: libsyntax: De-`@mut` `quote_depth` in the parser
[04:11:56] <ghrust> 13rust/06auto 14ea01e01 15Patrick Walton: libsyntax: De-`@mut` `token` in the parser
[04:11:58] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[04:13:57] *** Quits: dcrewi (david@moz-AB8667CE.gyrae.net) (Ping timeout)
[04:15:30] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[04:19:40] *** Joins: vfetwnuncszu (david@moz-AB8667CE.gyrae.net)
[04:19:52] *** vfetwnuncszu is now known as dcrewi
[04:46:51] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[04:46:51] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/xCtDlg
[04:46:51] <ghrust> 13rust/06auto 14705f472 15Brian Anderson: Add rust_fail. #11219
[04:46:51] <ghrust> 13rust/06auto 14b88138a 15bors: auto merge of #11231 : brson/rust/rust_fail, r=alexcrichton...
[04:46:51] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[04:46:53] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[04:46:53] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1418e8e4d to 14a1d3cc5: 02http://git.io/N3iJvQ
[04:46:53] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[04:49:54] *** Joins: pcwalton (pcwalton@moz-DA87EE4.hsd1.ca.comcast.net)
[04:49:54] *** ChanServ sets mode: +ao pcwalton pcwalton
[04:50:58] *** Quits: pcwalton (pcwalton@moz-DA87EE4.hsd1.ca.comcast.net) (Quit: pcwalton)
[04:53:49] <cmr> brson: klutzy looked into getting a backtrace. it only works with dynamic linking.
[04:54:02] <cmr> he has a working gist somewhere...
[04:54:06] <klutzy> cmr: huh, does it work? O_o
[04:54:16] <cmr> https://gist.github.com/klutzy/7999247
[04:54:20] <cmr> klutzy: I thought it was!
[04:54:28] <cmr> I could just be going crazy
[04:54:32] <cmr> It does happen sometimes :)
[04:54:46] <klutzy> I didn't post it fastly because it didn't work well for me
[04:55:11] <klutzy> it only shows function address, no proper function names
[04:55:28] <klutzy> except for libc stuff
[04:55:48] <klutzy> on windows it's worse that you cannot even build it on mingw :p
[04:59:22] <cmr> klutzy: that is exactly how it's supposed to work!
[04:59:29] <cmr> It can only get names from shared libs.
[04:59:29] *** Quits: ChristopherBurg (Christophe@moz-2C03E71B.hfc.comcastbusiness.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[05:01:51] <brson> cmr: why can it only get names from shared libs?
[05:02:10] <brson> i would think we could use libunwind and read the fn names from the dwarf
[05:02:19] <cmr> brson: don't know, just how it works.
[05:02:27] <cmr> probably could, implying debuginfo.
[05:02:46] <cmr> (by it, I mean glibc's backtrace function)
[05:03:05] <brson> we used the 'backtrace' function before and found it to not be that great. I think it didn't work at all on os x
[05:03:16] <cmr> nope
[05:03:36] <cmr> I actually remember this now
[05:04:09] <cmr> klutzy: https://gist.github.com/cmr/8192817
[05:05:22] <klutzy> cmr: thanks! seems that it really works with dynamic ones
[05:06:51] <cmr> typeck/infer is deep magic
[05:08:46] <dbaupp> how do I get the def_id of the impl for static methods like `SomeType::method()` or `SomeTrait::method()` (when one exists)?
[05:09:57] <cmr> The state of our python scrips makes me want to cry :(
[05:10:04] <cmr> it's like pep8 never existed.
[05:10:43] <klutzy> some lines even have semicolons!
[05:11:25] <klutzy> yeah, I recently started to add semicolons on python and pep8 complains :p
[05:11:55] <klutzy> cmr: `rustc --link-args -export-dynamic` recovered one name: std::rt::task::Task::run()
[05:12:32] <cmr> klutzy: ooh, what's that do?
[05:13:28] <klutzy> cmr: it adds all symbols to dynamic symbol table (as ld manual says)
[05:14:03] <ChrisMorgan> cmr: are you going to fix up the Python scripts?
[05:14:20] <cmr> ChrisMorgan: at least tidy and the snapshot ones, yeah.
[05:14:21] <klutzy> it's linker version of `-rdynamic` which many people suggests to use with backtrace
[05:14:25] <dbaupp> also, is it possible to tell when the implementation of some trait for some type is being used? i.e. `fn foo<T: Foo>(x: T) { ... } foo(1u) /* detect that impl Foo for uint is being used */``
[05:14:27] <cmr> I'm afraid to look atthe others.
[05:15:03] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[05:15:04] <ChrisMorgan> Seeing print(...) without `from__future__ import print_function` makes me sad, but I suppose that if you're trying to have it work even on Python 2.4â€¦
[05:17:50] * ChrisMorgan has never really had to bother about 2.4 compatibility
[05:25:58] <ChrisMorgan> Surely we're to the point, now, where these scripts should be rewritten in Rust.
[05:26:25] <cmr> meh
[05:26:31] <cmr> could be done, would be effort.
[05:28:21] <ChrisMorgan> Indeed.
[05:31:44] <dbaupp> hm, there's no way to go ty::t -> ~str, right?
[05:32:03] <dbaupp> (what I want to do is print the type of foo in foo.some_method().)
[05:32:07] <Luqman> there is afaik
[05:32:16] <Luqman> ty_to_str or something like that
[05:32:25] <cmr> it's in either ppaux or pprust
[05:32:32] <cmr> (iirc)
[05:32:44] <dbaupp> oh, ppaux
[05:32:45] <dbaupp> thanks
[05:32:56] <Luqman> also a method on Block (?) i think
[05:34:05] <sfackler> does anyone have any idea why I'd be running into this borrow error here? I think the first borrow should have fallen out of scope by the second one https://gist.github.com/sfackler/829ed45785865682f65f
[05:35:38] <cmr> sfackler: good question :(
[05:36:06] <cmr> does phase_2_... use the loaders' lifetime?
[05:36:54] <sfackler> nope, it just uses an anonymous lifetime
[05:37:03] <sfackler> and the return type has no lifetime parameters
[05:37:11] <cmr> that's unfortunate
[05:37:37] <sfackler> loader is being used as a trait object, so maybe there are some problems there
[05:46:07] <cmr> hell it's 2014 somewhere, I'm using it in the copyright headers
[05:47:03] <dbaupp> I don't think it is :P
[05:47:21] <cmr> ... no it can't be
[05:47:23] <cmr> dammit
[05:47:26] <dbaupp> heh
[05:47:35] * cmr was excited.
[05:47:42] * dbaupp can use 2014 for real in 7 hours!
[05:48:24] * sfackler shakes fist at borrow checker
[05:49:07] *** Quits: dcrewi (david@moz-AB8667CE.gyrae.net) (Ping timeout)
[05:49:22] <cmr> hm it looks like editing get-snapshot.py triggers a re-get :(
[05:49:27] * cmr has slow internet
[05:49:38] *** Joins: vfetwnuncszu (david@moz-AB8667CE.gyrae.net)
[05:49:53] *** vfetwnuncszu is now known as dcrewi
[05:50:06] <Luqman> cmr: extract snapshot locally and use the flag which i'm currently forgetting to configure
[05:50:25] <cmr> --local-rust or whatever?
[05:50:35] <Luqman> yea
[05:50:54] <cmr> oh I legitimately needed a new snapshot
[05:51:02] <cmr> apparently this workspace is a bit dusty
[05:51:11] <dbaupp> heh
[05:51:28] <cmr> double unfortunate! llvm too
[05:51:47] <dbaupp> -j# \o/
[05:51:47] <cmr> Luqman: this is your fault :P
[05:51:57] <Luqman> :P
[05:52:58] <Luqman> funny thing is i usually build 2 or 3 copies of llvm at the same time and they finish quick enough so i don't usually mind llvm updates
[05:53:28] * sfackler shakes fist at borrow checker
[05:53:28] *** Quits: lpy (lpy@7360AA58.F09091A8.1348A864.IP) (Ping timeout)
[05:53:32] <cmr> well, 5 multibuild jobs are also going off in the background
[05:53:34] <sfackler> oops
[05:53:45] <sfackler> man, I am having bad luck on accidental irc posts tonight c.c
[05:53:49] <dbaupp> sfackler: "/me shakes fist at up arrow"?
[05:53:56] <cmr> heh
[05:53:56] <sfackler> yep
[05:53:57] <dbaupp> cmr: how many cores?
[05:54:03] <cmr> dbaupp: 4 real, 8 HT
[05:54:08] <Luqman> cmr: delicious school servers to utilize :D
[05:54:57] * ChrisMorgan dreams of possessing a machine which can compile LLVM and Rust from scratch in under one minute
[05:55:16] <cmr> if that hardware exists I will be massively impressed.
[05:55:24] <Luqman> llvm, maybe :P
[05:55:36] <cmr> I'm almost tempted to do the math to see how fast the RAM would have to be, and if that's within physical limits :P
[05:55:44] <dbaupp> parallel LLVM function passes + hundreds of cores
[05:56:21] * dbaupp wonders if there's a minute of non-LLVM in our bootstrap.
[05:56:29] <cmr> wellll L1 can usually do a few hundred GB/s on modern CPUs
[05:56:37] <cmr> so maybe it's not unreasonable
[05:58:55] *** Joins: lpy_ (lpy@9A6870A6.F09091A8.1348A864.IP)
[05:59:36] <dbaupp> surely we miss L1 a lot without our wild use of pointers?
[05:59:51] <cmr> I'm imagine that all of the RAM is that fast :P
[06:01:07] <cmr> Has anyone been watching the parallel fn pass patch?
[06:06:54] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[06:06:54] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/xCtDlg
[06:06:54] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[06:19:36] <dbaupp> okay, 'nother question: how does one get the parent module of an arbitrary item?
[06:19:47] * dbaupp is currently looking through resolve
[06:20:12] <cmr> ohh I feel like I've done that one before
[06:20:14] <cmr> check the ast map?
[06:21:01] <dbaupp> node_item has a @path field
[06:21:21] <dbaupp> sounds useable... but I just need the DefId.
[06:21:58] <dbaupp> Wouldn't I have to trim the last element of the path and rerun resolve to get the DefId?
[06:24:20] <cmr> potentially.. I recall being able to just get a parent pointer somewhere
[06:26:19] <dbaupp> well, I can see 3 things returning DefId's, none of which is a parent pointer :(
[06:27:24] <cmr> I love hunting through the maze of the compiler. You *know* there needs to be a way to do it, just need to find the right combinatino of types and contexts..
[06:28:58] <dbaupp> it's not obvious that this task is necessary...
[06:29:07] <dbaupp> so I might be carving new tracks
[06:31:16] <dbaupp> oh, metadata::decoder::item_parent_item looks promising...
[06:31:43] * dbaupp worked out why his grepping was giving crappy results, and actually got some useful ones
[06:33:23] <dbaupp> eh, so looks like I can do this cross crate easily, but not locally
[06:51:26] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[06:55:09] <cmr> dbaupp: what are you working on?
[07:11:50] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[07:11:50] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/PAOV0w
[07:11:50] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[07:11:54] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[07:11:54] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/N5vpLA
[07:11:54] <ghrust> 13rust/06auto 14a60f12d 15Alan Andrade: Avoid compiler error about glob imports in getopts example
[07:11:54] <ghrust> 13rust/06auto 146bc278c 15Alan Andrade: Remove features from librustdoc
[07:11:54] <ghrust> 13rust/06auto 14ff801d6 15Alan Andrade: Fix tests
[07:11:55] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[07:18:14] *** Joins: Axord (xord@moz-C0D5F15A.lsanca.dsl-w.verizon.net)
[07:22:14] *** Joins: blank_name (blank_name@78B04CD2.66204B68.6D228269.IP)
[07:29:02] <cmr> librustc compile times are realliny bumming me out atm :(
[07:29:11] <cmr> *really
[07:30:53] <cmr> hah nailed it
[07:30:55] <brson> break up librustc into smaller crates
[07:30:57] * cmr ticks off another triage bug
[07:31:06] <brson> cmr: nice!
[07:31:17] * brson should do *a* triage bug
[07:31:22] * brson looks at list
[07:31:31] <cmr> :P
[07:31:36] <cmr> this is #3
[07:46:35] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[07:46:47] *** Joins: sanxiyn (tinuviel@B4104EBB.3CC170B1.1E14B209.IP)
[07:54:41] <brson> looks like i'm not going to get android unwinding fixed tonight :'(
[07:55:43] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Quit: leaving)
[08:12:19] *** Quits: dcrewi (david@moz-AB8667CE.gyrae.net) (Ping timeout)
[08:15:34] *** Joins: vfetwnuncszu (david@moz-AB8667CE.gyrae.net)
[08:15:49] *** vfetwnuncszu is now known as dcrewi
[08:21:51] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[08:21:51] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/N5vpLA
[08:21:51] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[08:22:40] <dbaupp> cmr: I was working on stability attributes on modules and traits and so on
[08:26:48] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[08:26:48] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/_LyEog
[08:26:48] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[08:26:54] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[08:26:54] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/pLw-dQ
[08:26:54] <ghrust> 13rust/06auto 14ae4a2b3 15Alex Crichton: Implement native UDP I/O
[08:26:54] <ghrust> 13rust/06auto 14c4d7959 15bors: auto merge of #11186 : alexcrichton/rust/native-udp, r=brson...
[08:26:55] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[08:33:45] *** Joins: bjz (bjz@moz-7290FC9E.hdqu1.vic.bigpond.net.au)
[08:48:37] *** Joins: nrc (ncameron@moz-AD2938E.hari.cable.virginm.net)
[08:50:19] *** Parts: sanxiyn (tinuviel@B4104EBB.3CC170B1.1E14B209.IP) (Leaving)
[08:55:15] *** Joins: eddyb (eddy@EE946B63.921A1753.FCAAE698.IP)
[09:06:27] *** flaper87|afk is now known as flaper87
[09:12:43] *** flaper87 is now known as flaper87|afk
[09:20:30] *** flaper87|afk is now known as flaper87
[09:25:55] <nrc> Given an ast node, can I get access to the underlying tokens?
[09:26:49] *** Quits: lpy_ (lpy@9A6870A6.F09091A8.1348A864.IP) (Client exited)
[09:28:46] <nrc> or, just the spans of individual parts of the ast tree, say the name of  a function in a fn defintion
[09:30:32] <eddyb> nrc: you can get a span for most nodes. I doubt you can get the name
[09:31:02] <eddyb> though if you're doing content generation, you can parse the function again :P
[09:31:26] <nrc> guess I need a cst, not just an ast :-(
[09:31:41] <dbaupp> what's the final goal?
[09:32:18] <nrc> to be able to highlight the function name in a fn def or fn call, and similarly for other expressions/items
[09:32:28] <nrc> I think the fn call is easy, but the fn def...
[09:32:28] <dbaupp> ah, in an IDE?
[09:32:43] <nrc> similar - cross reference tool
[09:33:09] <dbaupp> oh (have you seen the old project https://github.com/dobkeratops/rustfind ?)
[09:33:23] <dbaupp> I don't think that information is recorded, unfortunately
[09:34:08] <nrc> shame
[09:34:29] <nrc> yeah, I saw it. I'm specifically interested in extending dxr, rather than making something new
[09:34:41] <dbaupp> however, it's always fn token then fucntion name
[09:34:55] <dbaupp> i.e. the token after `fn` is always the function name
[09:35:05] <nrc> can I get access to the tokens though?
[09:35:23] <eddyb> nrc: you should be able to reparse a small bit
[09:35:27] <dbaupp> by parsing it twice, yeah
[09:35:34] <dbaupp> i.e. parse once to get all the info you need
[09:35:52] <dbaupp> and then step through the tokens highlighting things as appropriate
[09:36:03] <dbaupp> lib{syntax,rustc} aren't very good for tooling atm. :(
[09:36:23] <nrc> ha! tell me about it :-p
[09:36:38] <nrc> OK, I guess that will work
[09:36:54] <nrc> are the tokens deliberately not kept around to save mem?
[09:37:28] <eddyb> nrc: I think only macro invocations keep tokens
[09:38:16] <eddyb> and I saw a buffer of 4 tokens in the parser, I'm guessing that's for lookahead
[09:39:43] <nrc> I wonder if that is by accident or design
[09:40:50] <dbaupp> possibly both
[09:40:51] <eddyb> nrc: we have enough inefficiencies in syntax and rustc as it is :P
[09:41:11] <dbaupp> there hasn't been a need to keep the tokens, so might as well save that memory.
[09:42:00] <dbaupp> eddyb: macro invocations only keep the tokens until the expansion phase. after that there are no macros and no tokens.
[09:42:10] <eddyb> yupp
[09:43:59] *** Quits: bjz (bjz@moz-7290FC9E.hdqu1.vic.bigpond.net.au) (Ping timeout)
[09:46:51] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[09:46:51] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/XrRsQg
[09:46:51] <ghrust> 13rust/06auto 14ae4a2b3 15Alex Crichton: Implement native UDP I/O
[09:46:51] <ghrust> 13rust/06auto 14ca732c5 15bors: auto merge of #11186 : alexcrichton/rust/native-udp, r=brson...
[09:46:51] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[09:46:54] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[09:46:54] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14c4d7959 to 14d459e80: 02http://git.io/N3iJvQ
[09:46:54] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[10:33:13] <eddyb> dbaupp, cmr: do we have timings on actual LLVM passes?
[10:33:31] <eddyb> I'm curious what trans bloat is stressing the most
[10:39:18] <eddyb> https://gist.github.com/eddyb/997d93b3d814688c0db9 bleah
[10:56:05] <dbaupp> eddyb: not individual passes on IRFY, but you can get them yourself with -Z time-llvm-passes
[10:56:40] <eddyb> dbaupp: thanks :D
[10:59:25] <dbaupp> eddyb: btw, what does clang do for equivalent code?
[11:00:12] <eddyb> oh, that's a good idea
[11:00:43] <dbaupp> (fwiw, we actually have tests that compare our codegen to clangs, in src/test/codegen
[11:00:44] <dbaupp> )
[11:01:41] <eddyb> dbaupp: does it run with optimizations?
[11:01:54] <dbaupp> don't know
[11:01:58] <dbaupp> don't think so
[11:02:04] <dbaupp> you'd have to consult the driver
[11:04:41] <dbaupp> eddyb: (it's run_codegen_test in src/compiletest/common.rs)
[11:07:30] *** flaper87 is now known as flaper87|afk
[11:11:17] <eddyb> dbaupp: updated - https://gist.github.com/eddyb/997d93b3d814688c0db9
[11:11:25] <eddyb> though it's not actually fair, I just realized
[11:12:15] <eddyb> because of immutability. clang seems to do constant folding *but it still keeps variables on stack*
[11:12:39] <dbaupp> seems pretty similar?
[11:13:00] <eddyb> https://gist.github.com/eddyb/997d93b3d814688c0db9#file-trans-bloat-ll-L32-L35 I don't understand that
[11:13:20] <eddyb> why isn't it %x = i64 1; %y = i64 2; ?
[11:15:12] * dbaupp doesn't know
[11:15:26] <dbaupp> it'd be nice to have i1 bools... https://gist.github.com/eddyb/997d93b3d814688c0db9#file-trans-bloat-ll-L45-L48 
[11:15:28] <eddyb> I was expecting clang's output to look better
[11:15:28] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[11:16:17] <eddyb> dbaupp: https://github.com/mozilla/rust/issues/8106#issuecomment-30406678
[11:16:26] <dbaupp> eddyb: yup
[11:16:33] <eddyb> dbaupp: we also don't seem to have shortcircuiting o_O
[11:16:35] * dbaupp remembered that
[11:16:40] <dbaupp> what do you mean?
[11:16:43] <eddyb> or it gets lost because i8 bools
[11:16:51] <dbaupp> foo() && bar() shortcircuits?
[11:17:14] <dbaupp> rusti: { println("hi"); false } && { println("bye"); false }
[11:17:18] <eddyb> dbaupp: look at the first two examples. they should be identical
[11:17:19] -rusti- pastebinned 6 lines of output: http://ix.io/9AN
[11:17:28] <dbaupp> rusti: ({ println("hi"); false } && { println("bye"); false })
[11:17:29] -rusti- hi
[11:17:29] -rusti- false
[11:17:33] <dbaupp> rusti: ({ println("hi"); true } && { println("bye"); false })
[11:17:33] -rusti- hi
[11:17:34] -rusti- bye
[11:17:34] -rusti- false
[11:18:11] <eddyb> dbaupp: it might be LLVM optimizing the shortcircuit into an and because of non-i1 bools
[11:53:22] *** Quits: nrc (ncameron@moz-AD2938E.hari.cable.virginm.net) (Ping timeout)
[11:55:17] <eddyb> dbaupp: this is why I asked strcat. he said "everything" but basic examples look like clang, mostly
[11:55:51] <dbaupp> eddyb: find something other than a basic example then? :)
[12:06:32] *** flaper87|afk is now known as flaper87
[12:49:12] *** flaper87 is now known as flaper87|afk
[12:56:03] *** Joins: erickt1 (Adium@moz-4B000CB7.dyn.optonline.net)
[13:10:14] *** flaper87|afk is now known as flaper87
[13:19:57] *** Joins: lpy (lpy@7360AA58.F09091A8.1348A864.IP)
[13:26:19] *** Quits: erickt1 (Adium@moz-4B000CB7.dyn.optonline.net) (Quit: Leaving.)
[13:27:36] <dbaupp> https://github.com/mozilla/rust/pull/11236 r?
[13:52:52] *** Quits: eddyb (eddy@EE946B63.921A1753.FCAAE698.IP) (No route to host)
[13:56:19] *** Joins: eddyb (eddy@EE946B63.921A1753.FCAAE698.IP)
[14:20:06] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[14:27:49] *** Joins: erickt1 (Adium@moz-4B000CB7.dyn.optonline.net)
[14:37:10] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[14:41:56] *** Joins: ChristopherBurg (Christophe@moz-2C03E71B.hfc.comcastbusiness.net)
[14:42:43] *** Quits: erickt1 (Adium@moz-4B000CB7.dyn.optonline.net) (Quit: Leaving.)
[14:58:40] *** Joins: erickt1 (Adium@moz-4B000CB7.dyn.optonline.net)
[15:04:40] *** Quits: erickt1 (Adium@moz-4B000CB7.dyn.optonline.net) (Quit: Leaving.)
[15:12:04] *** Quits: lpy (lpy@7360AA58.F09091A8.1348A864.IP) (Quit: Leaving...)
[15:31:16] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[15:45:29] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[15:47:39] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[15:56:09] <dbaupp> klutzy: https://github.com/mozilla/rust/issues/11240 is b.rs meant to have crate_type="rlib"?
[15:56:51] <dbaupp> klutzy: (also the title appears to have 2 "doesn't"'s and 0 "does"'s... ?)
[15:56:51] <klutzy> ah right
[15:57:28] <klutzy> dbaupp: updated
[15:58:05] * klutzy should not make an issue while drunken
[15:58:21] <dbaupp> klutzy: oh, I guess it's liba....rlib and libb....so (rather than .so and .rlib resp) too?
[15:58:31] <dbaupp> heh :)
[15:58:36] <klutzy> oh wait.
[15:58:54] <klutzy> I swapped them :-/
[16:00:19] <klutzy> it becomes confusing when it's right for rustc to make error
[16:01:31] * eddyb is going to try running "make babies" now
[16:02:12] <dbaupp> "error: no rule to make babies"?
[16:02:16] <eddyb> hmm. neither that nor "make love" works. I remember something about an easter egg
[16:02:39] <whitequark> ruby has "make love"
[16:03:06] <klutzy> you should submit the pull req 3 month later :p
[16:04:22] <dbaupp> heh
[16:06:38] * eddyb still has no idea what happened to DSTs/SSTs
[16:07:56] <dbaupp> eddyb: difficulties + more thinking required + other things to happen first
[16:08:01] <dbaupp> + holidays, I guess.
[16:08:50] <eddyb> shelving :(
[16:33:08] *** Quits: Kxepal832 (Miranda@moz-1E4F2404.pppoe.mtu-net.ru) (Ping timeout)
[16:36:26] *** Joins: Kxepal (Miranda@moz-B7DB05D8.pppoe.mtu-net.ru)
[16:36:54] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[16:36:54] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/TCAdbw
[16:36:54] <ghrust> 13rust/06auto 14d255d4a 15Huon Wilson: std: print RUST_LOG=::help in sorted order....
[16:36:54] <ghrust> 13rust/06auto 14250ca0e 15bors: auto merge of #11236 : huonw/rust/sort-rust-log-help, r=sanxiyn...
[16:36:55] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[16:58:03] *** Quits: Yurume (Yurume@A826BD81.8A0DEF81.38747683.IP) (Ping timeout)
[16:58:11] *** flaper87 is now known as flaper87|afk
[17:23:29] *** Joins: Yurume (Yurume@A826BD81.8A0DEF81.38747683.IP)
[17:47:00] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[17:47:00] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/TCAdbw
[17:47:00] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[17:51:51] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[17:51:51] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/rPEELA
[17:51:51] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[17:51:55] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[17:51:55] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/6Tjh1Q
[17:51:55] <ghrust> 13rust/06auto 14726091f 15Alex Crichton: Convert some C functions to rust functions...
[17:51:55] <ghrust> 13rust/06auto 145ff7b28 15bors: auto merge of #11208 : alexcrichton/rust/less-c, r=cmr...
[17:51:55] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[18:40:17] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[18:40:17] *** ChanServ sets mode: +qo brson brson
[19:02:02] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[19:02:02] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/6Tjh1Q
[19:02:02] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[19:02:46] *** Quits: ChristopherBurg (Christophe@moz-2C03E71B.hfc.comcastbusiness.net) (Ping timeout)
[19:03:08] <sfackler> does anyone know why Visitor takes the "env" parameter? It seems to be set to () for every place I've seen
[19:04:13] <brson> sfackler: probably historical reasons then
[19:04:27] <brson> is the env now contained in the visitor implementation?
[19:04:45] <brson> visitor used to be closure based, and I assume it's trait-based now
[19:04:49] <sfackler> visitor is now a trait, so you can put the environment in self
[19:05:04] <sfackler> ah
[19:06:50] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[19:06:50] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/s7vmSw
[19:06:50] <ghrust> 13rust/06auto 14f96438e 15SiegeLord: Generate --dep-info earlier in the compillation.
[19:06:50] <ghrust> 13rust/06auto 147615a8c 15SiegeLord: Add a --no-analysis command line switch
[19:06:51] <ghrust> 13rust/06auto 14db7d314 15bors: auto merge of #11155 : SiegeLord/rust/early_deps, r=pcwalton...
[19:06:53] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[19:06:54] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[19:06:54] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/-SAhmg
[19:06:54] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[19:16:50] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[19:16:50] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14db7d314 to 145ff7b28: 02http://git.io/N3iJvQ
[19:16:50] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[19:16:50] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[19:16:51] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/Cb4Quw
[19:16:51] <ghrust> 13rust/06auto 1408d94c2 15Alex Crichton: Disallow LTO with a preference to dynamic linking...
[19:16:51] <ghrust> 13rust/06auto 147f0e2f7 15bors: auto merge of #11157 : alexcrichton/rust/issue-11154, r=pcwalton...
[19:16:51] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[19:39:07] *** Quits: Kxepal (Miranda@moz-B7DB05D8.pppoe.mtu-net.ru) (Ping timeout)
[19:41:43] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[19:45:01] <eddyb> strcat: oh. you're here. good
[19:45:11] <strcat> why?
[19:46:21] <eddyb> strcat: https://gist.github.com/eddyb/997d93b3d814688c0db9#file-trans-bloat-ll-L32-L35 wouldn't %x = i64 1; %y = i64 2; be better?
[19:47:45] <eddyb> it's still pretty close to clang, apart from the bool issue
[19:49:11] *** Joins: pcwalton (pcwalton@moz-C07D5168.p2p.sfo1.mozilla.com)
[19:49:11] *** ChanServ sets mode: +ao pcwalton pcwalton
[19:49:13] <eddyb> strcat: you suggested that everything was bloated, and I still think the alloca's aren't required, but I need something specific to look at :/
[19:49:49] <strcat> eddyb: ok, how about construction of structs, starting with the brace init
[19:49:55] <strcat> compare to what clang does
[19:50:07] <strcat> so, there are two sane ways
[19:50:15] <strcat> a) alloca, load/memcpy from constant
[19:50:40] <strcat> b) the SSA insertvalue
[19:51:02] <strcat> I doubt we do either
[19:51:15] <eddyb> (I'm assuming you can't take the address of %x)
[19:51:18] <strcat> (you probably want insertvalue for immediates and load/memcpy from constant for non-immediates)
[19:51:32] *** Joins: ChristopherBurg (Christophe@moz-2C03E71B.hfc.comcastbusiness.net)
[19:51:54] <strcat> eddyb: yeah, registers don't have addresses
[19:51:58] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[19:51:58] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/k7jjGQ
[19:51:58] <ghrust> 13rust/06auto 14870024a 15Alex Crichton: Disallow LTO with a preference to dynamic linking...
[19:51:58] <ghrust> 13rust/06auto 1490ab7d3 15bors: auto merge of #11157 : alexcrichton/rust/issue-11154, r=pcwalton...
[19:51:59] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[19:52:09] <strcat> you need alloca to put stuff "in-memory" so you can attach debug info
[19:53:18] <eddyb> bleah
[19:53:46] <eddyb> strcat: but that goes through *some* aliasing analysis, right?
[19:54:04] <strcat> just assume there's not really aliasing analysis
[19:54:10] <strcat> all that runs is basicaa and it's really dumb
[19:54:19] <eddyb> oh, right, I've meant to also check llvm pass timing, forgot to do that (instead I ate too much. newyears :/)
[19:54:28] <strcat> eddyb: http://llvm.org/docs/doxygen/html/BasicAliasAnalysis_8cpp_source.html
[19:54:42] <strcat> you can glance over that and have an idea of everything it knows
[19:54:46] <strcat> it's really, really dumb.
[19:55:06] <eddyb> I mean, in order to optimize some of the alloca'd locals, you need to make sure pointers aren't thrown all over the place
[19:55:28] <strcat> that's why you want a single load/memcpy from a constant
[19:55:38] <strcat> *or* SSA
[19:55:47] <strcat> as in build the value in SSA and store it
[19:56:07] <strcat> then you only have 1 aliasing store to worry about
[19:56:09] <strcat> the minimum
[19:56:14] <eddyb> hmm, could you use metadata to store types?
[19:56:14] <strcat> atm we probably index it with GEPi
[19:56:27] <strcat> eddyb: there's TBAA metadata
[19:56:32] <strcat> it's too early to worry about it for rust imo
[19:56:36] <strcat> need to massively clean up trans
[19:56:55] <eddyb> as in, define { i64, %tydesc*, i8*, i8*, i8 } somewhere instead of *everywhere*
[19:57:12] <eddyb> %tydesc looks like a metadata'd type to me, actually
[19:57:20] <strcat> that doesn't really matter
[19:57:31] <eddyb> nvm, I'm silly, we already do that %"struct.main::P" = type { i64, i64 }
[19:57:41] <strcat> LLVM just discards that, it's for humans
[19:58:06] <strcat> it makes the type printouts readable
[19:58:15] <strcat> like for a recursive type
[19:58:30] <eddyb> strcat: I would think the result is smaller if it references metadata instead of being expanded everywhere
[19:58:41] <strcat> maybe but I doubt it will matter
[19:58:53] <strcat> the time is wasted because LLVM has to optimize stuff out, not because the IR is big
[19:59:24] <strcat> building IR is really fast and it doesn't use much memory, it's that evil gvn thing that does ;p
[20:00:25] <eddyb> <stdin>:1:62: warning: use of GNU old-style field designator extension [-Wgnu-designator]
[20:00:33] * eddyb forgot how to construct structs in C
[20:02:32] <eddyb> strcat: hmm. I think we don't abuse immutability as much as we could
[20:03:01] <eddyb> clang does constant folding of its own, at -O0
[20:03:42] <eddyb> strcat: https://gist.github.com/eddyb/997d93b3d814688c0db9#file-trans-bloat-ll-L115
[20:03:42] <strcat> eddyb: it also does dead code elimination
[20:03:55] <strcat> but you should keep in mind that they do it for semantic reasons
[20:04:05] <strcat> there are warnings that aren't supposed to trigger if code is trivially dead
[20:04:52] <eddyb> and C++11 constexpr
[20:05:13] <strcat> eddyb: http://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html
[20:05:17] <strcat> error ("message")
[20:05:19] <strcat>     If this attribute is used on a function declaration and a call to such a function is not eliminated through dead code elimination or other optimizations, an error that includes message is diagnosed. This is useful for compile-time checking, especially together with __builtin_constant_p and inline functions where checking the inline function arguments is not possible through extern
[20:05:21] <strcat> char [(condition) ? 1 : -1]; tricks. While it is possible to leave the function undefined and thus invoke a link failure, when using this attribute the problem is diagnosed earlier and with exact location of the call even in presence of inline functions or when not emitting debugging information. 
[20:05:50] <strcat> for example you could use this for static array bounds checking
[20:05:52] <strcat> but...
[20:05:59] <eddyb> I've seen that trick in LLVM compile warnings
[20:06:04] <strcat> since LLVM doesn't have the ability to do this kind of thing post-optimization passes, it's not very useful
[20:06:12] <strcat> in theory you could just offload it to LLVM
[20:06:43] <strcat> I think they're reluctantly changing that
[20:06:43] <pcwalton> eddyb: feel free to add TBAA. trans adt.rs is where it belongs
[20:06:51] <eddyb> heh
[20:06:52] <pcwalton> and that code is new and good
[20:06:56] <strcat> pcwalton: it has to go on every load/store :(
[20:07:06] <pcwalton> datum.rs too :)
[20:07:11] <pcwalton> datum.rs is also new, good code
[20:07:13] <eddyb> pcwalton: you say that as if it's trivial :P (is it?)
[20:07:25] <pcwalton> I don't think it's too hard. adt.rs is quite refactored and nice.
[20:07:28] <eddyb> I'd be happy to get my current PRs through
[20:07:30] <strcat> eddyb: no, it's not easy to figure out what you want to guarantee
[20:07:34] <strcat> it's easy to output it
[20:07:40] <pcwalton> tbaa.struct is the one I really care about
[20:07:44] <pcwalton> that will eliminate a ton of code
[20:07:52] <pcwalton> because of not copying padding
[20:07:52] <strcat> I think there's basically a single function where 90% of loads/stores go through
[20:08:03] <strcat> look for where we attach load asserts to bools
[20:08:03] <pcwalton> yes, it's the various datum.rs stuff
[20:08:14] <pcwalton> niko refactored and revamped that several months ago
[20:08:24] <pcwalton> trans looks like this
[20:08:27] <strcat> the TBAA info would be similar.... but you have to build TBAA metadata trees with the aliasing guarantees
[20:08:28] <eddyb> pcwalton: I was talking about aliasing analysis *cost* in the context of alloca'd stack locals
[20:08:35] <pcwalton> AST -> a mud ball -> datum.rs/adt.rs
[20:08:51] <pcwalton> strcat is right that the mud ball is pretty messy but datum.rs/adt.rs are clean
[20:09:07] <strcat> pcwalton: well, meth.rs is what I hate ;p
[20:09:19] <pcwalton> yup, that's part of the mud ball :)
[20:09:29] <eddyb> named appropriately, too
[20:09:45] <strcat> and the stuff you'd expect in meth.rs that's in common.rs
[20:10:02] <eddyb> what on earth is h139ee37bf470f2e9ebc6d2f7ecf5011477954d80ef198e08250d250891c7ec72ah, btw?
[20:10:23] <eddyb> I may have seen explanations, but they don't apply here. I see it starts with h and ends with h
[20:10:30] *** Joins: geoffhill (geoffhill@moz-738DC0DB.org)
[20:10:34] <strcat> huh?
[20:10:42] <benh> Is that a mangled symbol?
[20:10:52] <eddyb> the part before the version
[20:11:23] <pcwalton> the base.rs/common.rs division is really bad
[20:11:34] <pcwalton> they were all extracted from one file, trans.rs
[20:11:41] <pcwalton> and never really cleaned up
[20:11:57] <pcwalton> same with meth.rs I think
[20:12:00] <eddyb> it's not a hash of function contents, is it a hash of the type? are we reserving some variance in the encoding of the types?
[20:12:28] <strcat> pcwalton: well, that stuff obviously predates monomorphization, it's a mess
[20:12:30] <eddyb> is the underlying C++ mangling not enough to represent everything in Rust?
[20:12:33] <strcat> I tried dealing with it
[20:12:59] <strcat> it demotivated me from working on librustc for now ;p
[20:13:01] <pcwalton> eddyb: I think originally there was designed to be symbol versioning support too.
[20:13:19] <eddyb> it has versioning. it's outside that nasty hash
[20:13:23] <strcat> pcwalton: it does everything based on the node id of the caller :(
[20:13:37] <strcat> and the caller node id supplies the "vtable"
[20:13:40] <strcat> ughhhhhh
[20:13:52] <eddyb> pcwalton: just look at this: define internal void @main::h139ee37bf470f2e9ebc6d2f7ecf5011477954d80ef198e08250d250891c7ec72ah::v0.0({ i64, %tydesc*, i8*, i8*, i8 }*) unnamed_addr #4 {
[20:14:03] <strcat> anyway destructors don't have an AST node id so that's the high-level reason why generic dtors don't work ;p
[20:14:24] <pcwalton> I don't recall what the hash is for, but brson may know.
[20:14:35] <pcwalton> I think that the C++-style name mangling was not felt to be sufficient for large types
[20:14:43] <pcwalton> but I don't recall if there was any specific reason beyond that
[20:14:50] <brson> eddyb: the hash helps avoid conflicts across crates if two crates have the same name and version. the hash also includes the package id, which is supposed to be a unique url
[20:15:01] <brson> the length of that hash is silly though
[20:15:08] <eddyb> base64-encode it pls
[20:15:29] <pcwalton> I think base64 has some symbols that don't play well with tools
[20:15:55] <brson> we only need like 64 bits of uniqueness to suffiently guard against collisions
[20:15:59] <brson> that looks like quite a lot more
[20:16:36] <eddyb> 64 bits = 11 base64 characters. I wouldn't mind it
[20:16:49] <strcat> I think there are places requiring an id to avoid clashes
[20:16:52] <strcat> extension methods
[20:16:57] <strcat> don't think it's fixed yet.
[20:17:02] <eddyb> pcwalton: well, symbols can have ., don't they? we just need another one
[20:17:06] <strcat> and you can't reverse them
[20:17:22] <strcat> eddyb: try out some traits and see what you get from the symbols
[20:17:49] <eddyb> why?
[20:18:35] <eddyb> I can run rabin2 -s ./x*/stage1/lib/libstd-*.so | grep FUNC
[20:18:49] <eddyb> _ZN100sync..arc..ArcData$LT$sync..mpsc_queue..State$LT$$LP$int$C$$UP$$x5bu8$x5d$RP$$C$comm..Packet$GT$$GT$10glue_visit67h1efd447de13672b395a11d4676e8d03f3cc8713d139753673367fbf28f081fcaaLE
[20:18:59] <eddyb> that doesn't look quite right :/
[20:19:22] * strcat cackles
[20:19:33] <eddyb> "glue_visit" okay
[20:19:43] <strcat> anyway that would make dynamic linking really slow in a big app
[20:19:55] <strcat> it does hash table lookups with a really bad hash
[20:20:16] <eddyb> how on earth does that make sense? is it a bunch of generics?
[20:20:18] <strcat> do we still use prefixes with the crate hash? or is that the thing at the end now
[20:20:40] <strcat> eddyb: it used to be nicer. it was brought down the lowest common denominator of ARM/android/windows
[20:20:49] <strcat> and.... not by thinking hard about it
[20:21:10] <eddyb> it's slightly nicer with c++filt sync..arc..ArcData$LT$sync..mpsc_queue..State$LT$$LP$int$C$$UP$$x5bu8$x5d$RP$$C$comm..Packet$GT$$GT$::glue_visit::h1efd447de13672b395a11d4676e8d03f3cc8713d139753673367fbf28f081fcaaL
[20:21:31] <eddyb> pcwalton: $ and . - that should be enough extra symbols for base64
[20:21:41] <pcwalton> yeah
[20:22:46] <eddyb> BASE64_BINSYM
[20:23:16] <eddyb> strcat: does it include lifetimes or something? I don't udnerstand the complexity :/
[20:23:31] <strcat> eddyb: well it used to actually output ::, <, >, etc.
[20:23:33] <strcat> now it escapes them
[20:23:39] <eddyb> $LT$ and $GT$ are obvious
[20:24:03] <eddyb> strcat: doesn't C++ mangling support templates?
[20:24:31] <strcat> sure
[20:24:41] <eddyb> it should be smaller and actually readable with c++filt
[20:25:52] <pcwalton> eddyb: yeah, I think it only got the minimum amount of mangling needed to make it semi readable and for tools to not choke
[20:25:56] <pcwalton> definitely a better job could be done
[20:26:09] <eddyb> I might fiddle with it
[20:26:21] <eddyb> pcwalton: I've heard you got demuting to bootstrap :D
[20:26:36] <pcwalton> eddyb: yup, just now removed all traces of @mut from the parser
[20:26:41] <pcwalton> needs to go out of the test suite
[20:27:03] <eddyb> (as in, @mut being invalida anymore)
[20:27:10] <pcwalton> right
[20:27:18] <pcwalton> @mut is no longer in the AST or the type grammar
[20:27:26] <pcwalton> and write guards are also removed from the borrow check
[20:27:31] <pcwalton> along with the associated lang items
[20:27:31] <eddyb> de-#[feature(managed)] will be glorious :D
[20:27:37] <eddyb> pcwalton: <3
[20:28:29] <eddyb> in my deowning Visitor PR I actually replaced some semi-related @T with T, because it was bugging me :P
[20:29:39] <pcwalton> the idea of just using Boehm for Gc<T>, and moving Gc<T> out of libstd, is really growing on me
[20:30:00] <eddyb> would that still require an auto-derived Traceable?
[20:30:52] <pcwalton> well, in hybrid mode yes, but Boehm's Traceable is exceedingly simple
[20:30:57] <pcwalton> http://www.hpl.hp.com/personal/Hans_Boehm/gc/gc_source/gc_typedh.txt
[20:31:04] <eddyb> this one is weird io::net::tcp::__extensions__::bind::anon::anon::expr_fn::aO
[20:31:05] <pcwalton> we could just generate that in adt.rs or something and stick it in the tydesc
[20:32:42] <brson> pcwalton: why move Gc<T> out of std?
[20:35:20] <pcwalton> brson: because I don't want a Boehm dependency in libstd
[20:35:33] <pcwalton> alternatively we could make GCs pluggable
[20:35:37] <eddyb> libgc
[20:35:48] <pcwalton> but I feel like libgc has other advantages too
[20:36:04] <pcwalton> in that you can just not link against it at all in kernel space, you can tell by a library's dependencies whether it uses the GC
[20:36:05] <pcwalton> and so forth
[20:36:42] <strcat> there's a lot you don't have in kernel space though
[20:36:44] <eddyb> pcwalton: I was bugging strcat about having pluggable allocators in rust-core, but there I was using core as a module in my crate (so it could "use" the allocator from a top-level module)
[20:37:00] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[20:37:05] <pcwalton> I think it is worth at least exploring making libstd usable in kernel space
[20:37:15] <brson> yes, i think std should be usable everywhere
[20:37:21] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[20:37:22] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1490ab7d3 to 145ff7b28: 02http://git.io/N3iJvQ
[20:37:22] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[20:37:22] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[20:37:22] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/0RzxQA
[20:37:22] <ghrust> 13rust/06auto 14a7a9e48 15SiegeLord: Generate --dep-info earlier in the compillation.
[20:37:22] <ghrust> 13rust/06auto 14cbe8c61 15SiegeLord: Add a --no-analysis command line switch
[20:37:23] <ghrust> 13rust/06auto 148ec03b3 15bors: auto merge of #11155 : SiegeLord/rust/early_deps, r=pcwalton...
[20:37:25] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[20:37:44] <eddyb> pcwalton: I have had a decent kernel-space allocator for two months now, just sitting there :P
[20:37:49] <pcwalton> brson: Boehm is probably better than whatever we could come up with in a short time frame anyway
[20:37:53] <brson> pcwalton: so do you want to never have GC in std?
[20:37:58] <pcwalton> it has incremental support
[20:38:09] <pcwalton> ideally no, it seems to work against embeddability
[20:38:15] <pcwalton> and RC is usually good enough
[20:38:41] <eddyb> it's just hard to get an API where you can plug your own allocator in
[20:39:02] <pcwalton> Boehm has incremental GC on Unix and also has generational GC
[20:39:07] <eddyb> without specifying it everywhere
[20:39:09] <pcwalton> which is pretty sweet
[20:39:55] <pcwalton> if you have a language like Rust which uses idiomatically GC only for a small fraction of data if it's used at all, I think Boehm may be quite suitable
[20:39:59] <brson> but GC does need to be pretty tightly coupled to the compiler, particularly the more sophisticated it gets. i am certainly in favor of not having things in std, but it seems a difficult problem
[20:40:08] <pcwalton> brson: oh, I've thought about how to get precision too
[20:40:10] <pcwalton> what we can do
[20:40:11] <brson> everybody starts writing their own GC's ...
[20:40:28] <pcwalton> is to generate Boehm-compatible pointer maps where needed and hang them off tydescs.
[20:40:39] <pcwalton> nobody ever looks at the pointer map
[20:40:46] <pcwalton> except that they hang off a field in the tydesc
[20:40:53] <pcwalton> and we hand it to Boehm
[20:40:58] <pcwalton> http://www.hpl.hp.com/personal/Hans_Boehm/gc/gc_source/gc_typedh.txt this is the API
[20:41:01] <pcwalton> it's exceedingly simple
[20:41:31] <pcwalton> this is in the Rust compiler, we can just bill it as "a feature which enables precise GC on the heap if you wish to use the Boehm GC with Rust"
[20:41:40] <pcwalton> kind of a Boehm-GC-extension for Rust
[20:41:47] <pcwalton> we don't have to standardize it or anything
[20:42:37] <pcwalton> the only remaining thing at that point is precise-on-the-stack GC.
[20:42:47] <pcwalton> or write barriers
[20:43:48] <eddyb> with Traceable I could see those maps being generated by CTFE'd code which specializes the trait. that maybe sounds complicated
[20:44:19] <pcwalton> eddyb: we're doing that in Servo
[20:44:41] <pcwalton> but in Servo it's way easier because the JS engine actually calls a *function* to trace
[20:44:47] <pcwalton> which means that #[deriving] can easily generate it
[20:45:04] <pcwalton> in fact, you could even abuse Encodable to generate it, by treating the tracer as a "serializer" :P
[20:45:10] <pcwalton> which is something I realized a couple of weeks ago
[20:45:36] <pcwalton> oh hey, the Boehm GC supports incremental/generational write barriers http://www.hpl.hp.com/personal/Hans_Boehm/gc/gc_source/gch.txt
[20:45:50] <eddyb> pcwalton: that and the repr visitor should maybe get merged
[20:46:06] <pcwalton> wow
[20:46:12] <pcwalton> really the only thing Boehm doesn't do is precise stack maps
[20:46:20] <pcwalton> which is something that is a long way off because LLVM is not up to the task at the moment
[20:46:47] <eddyb> Encodable and Decodable should just be Visitable<EncoderVisitor> and Visitable<DecoderVisitor>
[20:46:49] <pcwalton> oh, I should check to see what support Boehm has for not stopping the world
[20:47:02] <eddyb> maybe I'm exaggerating right now
[20:47:50] <pcwalton>  The Linux/HPUX/OSF1 and Irix implementations sends signals to individual Pthreads and has them wait in the signal handler. 
[20:47:52] <pcwalton> >:(
[20:47:54] <pcwalton> (to stop the world)
[20:48:24] * strcat actually found out how to cause spurious wakeups
[20:48:27] <strcat> send signals ;p
[20:48:41] <pcwalton> oh wait
[20:48:42] <pcwalton>  In its default configuration, the Boehm-Demers-Weiser garbage collector is not thread-safe. It can be made thread-safe for a number of environments by building the collector with the appropriate -DXXX-THREADS compilation flag.
[20:48:44] <pcwalton> aha!
[20:48:49] <pcwalton> we just compile Boehm in non-thread-safe mode
[20:48:50] <pcwalton> done
[20:49:03] <pcwalton> oh, well, hmm
[20:49:05] <pcwalton> it also uses globals
[20:49:05] <pcwalton> doh
[20:51:04] <eddyb> strcat: oooh, I finally found the mangling function (in rustc::back::link), and $UP$ means Uniq
[20:52:44] *** Joins: jdm (jdm@moz-3FFA85CA.dsl.teksavvy.com)
[20:52:46] <pcwalton> ok, we'd have to hack it to get it to "halfway thread safe", where it does locking to allocate but single threaded mark/sweep, although I bet it wouldn't be that hard
[20:53:51] <brson> that's a little surprising that it's not designed to be thread safe. i guess they never expected gc to be non-global
[20:54:37] <pcwalton> brson: no, it's thread safe
[20:54:38] <eddyb> oi, mangle is pretty dumb when it comes to nesting
[20:54:41] <pcwalton> it's just too thread safe
[20:54:55] <pcwalton> if you compile with thread safety on it stops all threads by sending them unix signals :(
[20:55:14] <pcwalton> because it assumes there may be cross thread references
[20:55:21] <pcwalton> like in most other non-Erlang languages
[20:55:27] <pcwalton> but not so in Rust
[20:56:30] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[21:00:32] <eddyb> haha, I only have to implement the truncated_hash_result function - right now it just gets a hex string
[21:03:25] <eddyb> pcwalton: is - symbol-safe?
[21:04:01] <eddyb> UrlSafe uses - and _
[21:10:30] <Yurume> https://en.wikipedia.org/wiki/Base64#Implementations_and_history
[21:10:45] <Yurume> I'm not sure what symbol-safe exactly means though
[21:10:59] <cmr> eddyb: the ARM toolchain is very picky. Get an arm-linux-gnueabi toolchain and try to build with it
[21:11:56] <eddyb> this is what I'll do     // Replace - with . and = with $ to be symbol-safe.
[21:12:51] <eddyb> would encoded.chars().map(|c| match c {...}).collect() work?
[21:20:43] <eddyb> strcat: interesting, sanitization gets one path element. I guess whatever generates those symbols is to blame
[21:22:00] <eddyb> hmm, can paths have actual generic params? I know AST ones can, but I'm not sure on the ones back::link gets
[21:31:10] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[21:45:25] <eddyb> oh, it actually builds. I wasn't expecting that to work, heh
[21:46:29] <eddyb> io::Reader::push_bytes::hScNTWeAMsR0$ab::v0.9.pre
[21:46:39] <eddyb> cmr, pcwalton, strcat: ^^
[21:47:03] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[21:47:04] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/0RzxQA
[21:47:04] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[21:47:27] <eddyb> haha, I should hurry, I don't want to update the copyright header (2014 here in 13min)
[21:52:05] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[21:52:05] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/i8ZdbA
[21:52:05] <ghrust> 13rust/06auto 14870024a 15Alex Crichton: Disallow LTO with a preference to dynamic linking...
[21:52:05] <ghrust> 13rust/06auto 14bd52e6a 15bors: auto merge of #11157 : alexcrichton/rust/issue-11154, r=pcwalton...
[21:52:06] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[21:59:17] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[22:03:00] *** Quits: jdm (jdm@moz-3FFA85CA.dsl.teksavvy.com) (Ping timeout)
[22:03:03] <eddyb> acrichto: you're fast >_>. I thought of using base64 instead of hex would make it smaller *before* truncating it
[22:03:39] <eddyb> also, past midnight here, and I'm incoherent already
[22:03:49] <acrichto> eddyb: we already have a lot of canonicalization logic in order to strip out certain characters from symbols, and it just makes me sad to see more logic poured in :(
[22:06:38] <eddyb> removing ~ and @ would actually make the type system quite compatible with C++ mangling
[22:07:44] <eddyb> and even now, ~T => $U<T> or $Uniq<T> would look decent
[22:08:57] <cmr> the symbols we use aren't why our mangling isn't great, it's the weird extra crap we throw into the symbol names.
[22:09:51] <acrichto> eddyb: I did some work awhile ago cleaning up our symbols, and there's only a few cases where symbols aren't what you expect
[22:09:55] <acrichto> 1. glue generated functions
[22:09:56] <acrichto> 2. anonymous functions
[22:10:08] <acrichto> 3. impls of traits for primitive types (__extensions__ shows up)
[22:10:19] <acrichto> but all other symbols *should* be pretty in the sense that they're generally readable
[22:10:45] <acrichto> we use C++ name mangling exactly actually, except for all the types that C++ name mangling has in it
[22:10:59] <acrichto> glue generated functions are a special case that havne't been updated
[22:11:02] <eddyb> acrichto: should sanitize "parse" the string or should I go through the trouble to provide the proper info for things like glue generated fns?
[22:11:17] <eddyb> oh, I see
[22:11:31] <acrichto> I think glue may take an entirely different path
[22:11:37] <acrichto> or glue just doesn't follow the same conventions as the rest of the code
[22:11:40] <acrichto> (hence .. vs ::)
[22:11:55] <eddyb> acrichto: the entire type is flattened into a string
[22:12:24] <eddyb> that being the first element of the path. the second is the glue fn name
[22:12:44] <eddyb> acrichto: I don't see C++ templates being used where we have generics
[22:12:44] <pcwalton> it's a little concerning that half the test suite is testing @ pointers
[22:12:49] <pcwalton> when they are not going to last
[22:12:56] <eddyb> hah
[22:12:58] <pcwalton> and isn't representative of most rust code
[22:13:14] <eddyb> if it's testing trait stuff, replace with ~
[22:13:20] <acrichto> eddyb: huh I didn't even know that C++ name mangling had support for templates
[22:13:24] <acrichto> we certainly don't use that
[22:13:27] <pcwalton> half of the test suite is testing destructors and uses @mut :P
[22:13:27] <eddyb> hehe
[22:13:31] <pcwalton> to read out results
[22:13:38] <pcwalton> acrichto: yeah, it does
[22:13:42] <pcwalton> it has full support for them
[22:13:54] <acrichto> we should probably be using that then!
[22:14:01] <acrichto> last time I looked I couldn't find good documentation for it
[22:14:11] <acrichto> I think I remember finding things for sutff like foo<double, int>
[22:14:15] <acrichto> but nothing for foo<bar, baz>
[22:14:19] <pcwalton> it's also concerning how much of the test suite depends on *prompt deallocation* for @
[22:14:22] <pcwalton> and is therefore incompatible with GC
[22:14:35] <pcwalton> a huge amount of it assumes that dtors for @ run immediately
[22:14:46] <acrichto> wow iterating from 7 to 0 is not exactly pretty
[22:14:56] <acrichto> for i in iter::range_step_inclusive(7, 0, -1) { ... }
[22:15:01] <cmr> acrichto: range(0, 7).invert()
[22:15:06] <acrichto> whoops, nvmd
[22:15:12] <eddyb> std::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> >::_S_copy_chars(wchar_t*, __gnu_cxx::__normal_iterator<wchar_t const*, std::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> > >, __gnu_cxx::__normal_iterator<wchar_t const*, std::basic_string<wchar_t, std::char_traits<wchar_t>, std::allocator<wchar_t> > >)
[22:15:13] <cmr> 0, 8, actually
[22:15:34] <pcwalton> eddyb: oh, I meant to ask, have you given thought to using typedefs for allocators
[22:15:53] <pcwalton> struct AHashMap<K,V,A> { allocator: A, â€¦ } type HashMap<K,V> = AHashMap<K,V,A>;
[22:15:55] <pcwalton> err
[22:15:57] <pcwalton> struct AHashMap<K,V,A> { allocator: A, â€¦ } type HashMap<K,V> = AHashMap<K,V,Heap>;
[22:16:04] <eddyb> pcwalton: it's ugly and harder to get working
[22:16:08] <pcwalton> and then hacking resolve to make HashMap::new() work
[22:16:21] <pcwalton> uglier than optional type parameters?
[22:16:23] <acrichto> I really don't want our ~str type to look like that
[22:16:23] <pcwalton> I'm not sure
[22:16:31] <brson> Does box (Gc) work yet? does box (Anythingelse)?
[22:16:37] <pcwalton> brson: no, the pr bounced
[22:16:46] <brson> box plain 'box' works for ~?
[22:16:48] <pcwalton> yes
[22:17:03] <pcwalton> I worry about optional type parameters leading us down too much complexity if we can do the same thing with other methods
[22:17:06] <brson> maybe i won't bother mentioning 'box' in the relnotes
[22:17:17] <pcwalton> acrichto: why not?
[22:17:45] <pcwalton> I'm not really opposed to optional type parameters on any grounds other than "it duplicates functionality you can do in other ways" and I'd be receptive to arguments that we need them but I want to hear some :)
[22:18:02] <acrichto> pcwalton: when debugging if I see 10 lines of type parameter instantiations I have no idea what I'm looking at
[22:18:17] <acrichto> expected ~str got std::basic<A, B, C, D, E, F, G>
[22:18:29] <pcwalton> acrichto: can't we fix that with better error messages though?
[22:18:41] <eddyb> with type aliases, hardly
[22:18:45] <pcwalton> why not?
[22:18:52] <acrichto> indeed, I think that optinoal type parameters will be necessary, but I really don't want our error messages to suffer
[22:19:30] <pcwalton> I want to hear some concrete reasons, this isn't convincing so far
[22:20:00] <eddyb> pcwalton: oh, btw, you can fake non-self impls with a module. but I'm not helping *myself* :P
[22:20:03] <brson> it seems like the new `use {foo, bar}` is not equivalent to the old `use foo, bar` since afaik inside the braces you can only have a single path element
[22:20:05] <sfackler> acrichto: how gross do you think it is to use the driver::session::Session's CStore for syntax phase crates and then reset it to empty for the link time crates?
[22:20:33] <pcwalton> I mean, we should fix resolve so that HashMap::new() works
[22:20:36] <acrichto> brson: I thought we decided that use foo, bar; should juse be 'use foo; use bar' anyway?
[22:20:50] <pcwalton> acrichto: if we have optional type parameters then that we will have to do some error message work to avoid that anyway
[22:21:04] <acrichto> sfackler: I like the idea in theory b/c that makes sense, it may not be easy though
[22:21:06] <pcwalton> if we don't do SOMETHING then we'll end up with HashMap<int,~str,Heap>
[22:21:17] <acrichto> pcwalton: yeah that's what I'm afraid of
[22:21:24] <pcwalton> even with optional type parameters
[22:21:31] <acrichto> I should never see HashMap with Heap
[22:21:35] <eddyb> pcwalton: with optional type params, you get better inference
[22:21:36] <pcwalton> without optional parameters it'll be AHashMap<int,~str,Heap>
[22:21:41] <pcwalton> how so?
[22:22:02] <cmr> Better error messages are simple, just gotta check if the typaram is the default.
[22:22:04] <acrichto> well AHashMap is terrible as a default, HashMap is much better, and everything using HashMap should only see errors related to HashMap
[22:22:36] <pcwalton> I'm just really worried about becoming Scala/D/C++ here, "we just need one more feature" related to generics
[22:23:07] <acrichto> yeah :(
[22:23:19] <pcwalton> I think we DO need allocators
[22:23:22] <pcwalton> in the standard library
[22:24:03] <eddyb> pcwalton: it doesn't help that it just became 2014 - i.e. late. I'm also not the most convincing person
[22:24:20] <eddyb> pcwalton: if you want to write generic Vec code, do you want to type AVec everywhere?
[22:24:22] <pcwalton> like I said I'm not really opposed, just want to see whether we can do it in other ways. cmr's argument is the most convincing
[22:24:34] <cmr> I don't see any reason type aliases can't provide the same behavior.
[22:24:37] <cmr> pcwalton: which argument? :p
[22:24:48] <pcwalton> that it is easier to give good error messages with optional type parameters
[22:24:55] <pcwalton> because you can easily check if it is the default
[22:24:55] <cmr> yeah
[22:25:06] <pcwalton> also having two names is slightly inconvenient yes
[22:25:16] <eddyb> oh, right, I didn't think you can actually not print it when it's the same, that's nice :D
[22:25:37] <cmr> Optional typarams also feel less hacky to me
[22:25:48] <pcwalton> well, I like hackiness actually
[22:25:57] <pcwalton> let's get as much mileage as we can out of the features we've got
[22:25:58] <eddyb> pcwalton: as opposed to magic :P?
[22:26:08] <cmr> But if we need to extend type aliases anyway, I don't see why not just try it.
[22:26:17] <cmr> (and I think we do need to extend them)
[22:26:49] <pcwalton> sure, I'm on board I guess.
[22:27:44] <eddyb> impl<T, A: Default = Heap> Vec<T, A> {fn new() -> Vec<T, A> {Vec {alloc: Default::default(), ptr: 0, len: 0, cap: 0}}}
[22:27:46] <pcwalton> let's just remove some feature at the same time we add this. :P
[22:28:34] <eddyb> pcwalton: we're removing @mut, aren't we :)?
[22:28:36] <cmr> loss of univariant enum deref was a nice win
[22:28:37] <pcwalton> yeah
[22:29:14] <eddyb> oh, I see what you mean about resolve
[22:29:17] <pcwalton> it'll need to be talked over at the meeting but I'm on board.
[22:29:41] <eddyb> pcwalton: that would be useful for things like type RcMut<T> = Rc<RefCell<T>>;, I guess
[22:29:55] <pcwalton> yeah, although I think we shouldn't necessarily encourage that
[22:30:01] <pcwalton> you should RefCell individual fields
[22:30:26] <pcwalton> also we really need a Deref trait for ref cells, like yikes.
[22:30:33] <pcwalton> although it's more important to get Niko's lifetime changes
[22:30:47] <pcwalton> where the lifetime of temporaries in a series of method calls is extended to the whole statement
[22:30:57] <pcwalton> that will eliminate a gazillion temporaries that ruined my holidays.
[22:31:00] <pcwalton> (kidding)
[22:31:01] <eddyb> is that pending o_O?
[22:31:04] <pcwalton> he's working n it.
[22:31:06] <pcwalton> on it
[22:31:16] <eddyb> hope++
[22:34:19] *** Joins: jdm (jdm@moz-3FFA85CA.dsl.teksavvy.com)
[22:36:16] <eddyb> rusti: ::std::option<int>::Some(5)
[22:36:23] -rusti- pastebinned 13 lines of output: http://ix.io/9Bc
[22:36:27] <eddyb> rusti: ::std::option::<int>::Some(5)
[22:36:29] -rusti- pastebinned 10 lines of output: http://ix.io/9Bd
[22:37:12] <eddyb> it's a bit silly how those kinds of checks and the actual expansion are decoupled
[22:38:49] *** Quits: jdm (jdm@moz-3FFA85CA.dsl.teksavvy.com) (Quit: Lost terminal)
[22:39:47] <eddyb> pcwalton: I'll be happy to see nmatsakis around, maybe we can start discussing variadics again
[22:40:26] <eddyb> it's sad rust risks missing those in 1.0 mostly because of my leg accident
[22:40:31] <brson> acrichto: was it 0.9 where we turned on the new format! macro?
[22:40:50] <cmr> brson: nah, fmt! was just removed.
[22:40:58] <cmr> it was already around for 0.8
[22:41:01] <cmr> (format!)
[22:44:01] <brson> I added headers for major topics of the detailed relnotes: https://github.com/mozilla/rust/wiki/Doc-detailed-release-notes
[22:44:14] <brson> Please write useful stuff there if you have the know-how
[22:45:24] <pcwalton> there are like 10 tests that all test whether trivial @mut cycles get cleaned up
[22:45:37] <pcwalton> or have turned into that because they're forgotten what they're supposed to be testing
[22:46:06] <eddyb> move into run-pass-alzheimer
[22:46:20] <cmr> heh
[22:46:47] <pcwalton> // Tests that shapes respect linearize_ty_params().
[22:46:49] <pcwalton> yeahâ€¦ that's old
[22:46:53] <pcwalton> I'm just going to put that test out of its misery
[22:47:02] <eddyb> what's a shape? and what's linearize?
[22:47:22] <eddyb> pcwalton: would it make sense to s/region/lifetime/ in rustc?
[22:47:23] <cmr> hahah
[22:47:27] <pcwalton> eddyb: yes
[22:47:35] <eddyb> the current code is mixed and really confusing
[22:47:42] <pcwalton> what we had before visitors and before monomorphization
[22:47:53] <pcwalton> and when log was a magic thing builtin to the language and written in c++
[22:48:06] <eddyb> I don't think I want to know
[22:48:08] <cmr> well there's still __log
[22:48:20] <eddyb> soon it will be a loadable extension <3
[22:48:51] <brson> cmr: does rustdoc actually load plugins dynamically?
[22:48:59] <cmr> brson: yes.
[22:48:59] *** Quits: flaper87|afk (flaper87@moz-107AD163.redhat.com) (Ping timeout)
[22:49:11] <eddyb> (or is it just a macro anyway? I'm not sure. crates need to export macros)
[22:49:22] <pcwalton> does anyone care if I just remove the 15th test that checks whether @mut cycles work?
[22:49:25] <pcwalton> I have found another one
[22:49:34] <eddyb> nope
[22:49:39] <pcwalton> this one wants to call `rustrt::gc`
[22:49:41] <pcwalton> to check whether cycles work
[22:50:02] <brson> cmr: like what?
[22:50:55] <eddyb> acrichto: could we have a #[prelude] on a mod kinda like how #[boot] works now in crates?
[22:50:58] <cmr> brson: well we don't ship any plugins, since they're all just hardcoded atm.
[22:51:11] <acrichto> eddyb: funny I was just talking about that with wycats this morning
[22:51:15] <cmr> brson: plugins.rs is the implementation. all of the passes in passes.rs could be plugins.
[22:51:36] <acrichto> eddyb: I would like to have a method of a "user defined prelude", but I haven't thought of a good way to do it just yet
[22:51:56] <strcat> acrichto: the prelude isn't a good thing imo
[22:52:15] <pcwalton> you'd rather import Option::None,Some?
[22:52:22] <acrichto> sure beats writing 'use vec::{Trait1, Trait2, Trait3, Trait4}' everywhere
[22:52:28] *** Quits: Axord (xord@moz-C0D5F15A.lsanca.dsl-w.verizon.net) (Ping timeout)
[22:52:36] <pcwalton> we tried that in rust 0.1 ;)
[22:52:38] <acrichto> there are often utility traits as well which are super nice to have imported by default
[22:52:41] *** Joins: flaper87|afk (flaper87@moz-107AD163.redhat.com)
[22:52:41] *** Joins: Axord (xord@moz-C0D5F15A.lsanca.dsl-w.verizon.net)
[22:52:46] <acrichto> (not in stdlib)
[22:52:52] <strcat> acrichto: so remove those traits? use utility functions
[22:53:05] <strcat> if we're going to do everything with one use traits, why do we need free functions?
[22:53:10] <acrichto> strcat: then you have to import the utility functions, it's just nice to have things imported by default
[22:53:17] <pcwalton> .iter() has to be a trait
[22:53:19] <strcat> you don't need to import a function to use it
[22:53:30] <acrichto> ah, you mean method
[22:53:50] <acrichto> things like a borrow trait/deref trait, the list goes on about how useful default imports are
[22:54:07] <acrichto> there are lots of cases where you don't need these one off traits (like all the primitive types), but that is not the reason that the prelude exists
[22:54:18] <acrichto> or rather it's not the only reason
[22:54:47] <strcat> acrichto: operator overloads don't need to be available only when the trait is in scope
[22:54:51] <strcat> they are lang items, it can't conflict
[22:55:15] <acrichto> again, that's not the only use case of the prelude
[22:55:19] <strcat> Iterator will be a lang item too when for loops are sane, you'd only need to import it to call adaptors
[22:55:19] <eddyb> about lang items, can we have a magical top module where they're exported?
[22:55:23] <acrichto> Iterator/CloneableIterator/MutableIterator, etc
[22:55:39] <pcwalton> Clone
[22:55:46] <pcwalton> I don't want to have to import Clone
[22:55:47] <pcwalton> and that has to be a trait
[22:56:08] <acrichto> Reader/Writer are *super nice* to not have to import
[22:56:15] <acrichto> Option/Result
[22:56:24] <acrichto> port/chan/spawn (all very nice)
[22:56:47] <eddyb> that way you can use them from deriving/macros/etc, ::__lang_items::Eq instead of ::std::ops::Eq
[22:57:12] <pcwalton> eddyb: they should just be hygienic
[22:57:18] <pcwalton> so the macros and deriving can "use std"
[22:57:24] <pcwalton> and it'll go to the right place
[22:57:32] <pcwalton> regardless of where the client crate used std
[22:57:46] <eddyb> pcwalton: it actually doesn't have that problem
[22:57:54] <strcat> the bigger problem with deriving is it choking because of auto-deref ;p
[22:58:19] <eddyb> pcwalton: but you can't auto-derive in a kernel using rust-core
[22:58:33] <eddyb> and why have lang items when only the std implements them?
[22:58:45] *** Joins: tikue_ (tkuehn@moz-C55F9DFF.hsd1.pa.comcast.net)
[22:59:13] <eddyb> though I have a lot of mixing in my feelings about all those things
[22:59:19] <pcwalton> deriving should be part of std, not built into the compiler
[22:59:40] <acrichto> user-defined deriving traits are going to be something that many people want
[23:00:04] <cmr> and sfackler's work is going to enable it
[23:00:10] <strcat> eddyb: you can use deriving with rust-core
[23:00:19] <strcat> you have to use the same hack libstd uses
[23:00:20] *** Quits: sfackler (sfackler@moz-AEECCEBA.com) (Ping timeout)
[23:00:22] <cmr> (well, is a huge step towards it)
[23:00:24] <strcat> it defines 'mod std { ]' inside itself
[23:00:32] <eddyb> strcat: but I don't want that :/
[23:00:42] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[23:01:01] <eddyb> I just thought that a special module containing all lang items was a good idea
[23:01:03] <pcwalton> we just need exportable macros and then to move deriving to it
[23:01:07] *** Joins: sfackler (sfackler@moz-AEECCEBA.com)
[23:01:11] <strcat> eddyb: well it could be called std instead ;p
[23:01:13] <pcwalton> to the library
[23:02:16] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[23:02:17] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/i8ZdbA
[23:02:17] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[23:02:19] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[23:02:27] <tikue_> will unboxed closures be the preferred default when they land?
[23:02:40] <tikue_> or in other words, what are the pros/cons of boxed vs unboxed?
[23:03:03] <strcat> same as concrete types via generics via trait objects
[23:03:06] <strcat> er
[23:03:08] <strcat> vs. trait objects
[23:03:40] <strcat> and yes they should be preferred - not at an API level, but a local closure should start as unboxed
[23:03:45] <tikue_> ok
[23:04:32] <strcat> hard to say what you want for most APIs
[23:04:34] <eddyb> acrichto: I guess you're not waiting for a sanitize rewrite - but that would be nastier, not worth waiting on (I renamed to PR to reflect the single commit)
[23:04:43] <eddyb> acrichto: and thanks btw :)
[23:04:57] <acrichto> eddyb: np! I look forward to actually understanding glue symbols :P
[23:05:08] <strcat> imo it'd be best if they could take function-like objects generically, and then by boxing in the caller you could avoid creating more than 1 instantiation
[23:05:23] <strcat> but it'd need good syntax
[23:06:56] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[23:06:56] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/zaMjOw
[23:06:56] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[23:06:57] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[23:06:57] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/Xa5tXA
[23:06:57] <ghrust> 13rust/06auto 14f98f83a 15Peter Zotov: Implement volatile_load and volatile_store intrinsics.
[23:06:57] <ghrust> 13rust/06auto 141dcc986 15bors: auto merge of #11173 : whitequark/rust/master, r=thestinger...
[23:06:58] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[23:07:21] <eddyb> acrichto: oh, it's not insane: mangle_internal_name_by_type_and_seq(ccx, t, (~"glue_" + name))
[23:08:10] <eddyb> acrichto: it uses ppaux::ty_to_str(ccx.tcx, t). I just need to replace that with a custom C++-like mangling
[23:09:06] <eddyb> hehe, free_glue and drop_glue?
[23:09:53] <tikue_> has the decision to default to 1:1 scheduling officially been made, or is it still being considered?
[23:11:14] <strcat> eddyb: you could replace free glue with drop glue if you tried hard enough
[23:11:16] <strcat> it's pointless
[23:11:26] <eddyb> where is it called from?
[23:13:15] <eddyb> trans::closure::make_opaque_cbox_drop_glue
[23:13:33] <eddyb> strcat: lol, it's used for procs
[23:13:46] <eddyb> is that sane?
[23:14:02] <strcat> eddyb: it's used to separate the ~/@ handling into two parts
[23:14:04] <strcat> it's pointless
[23:14:08] <strcat> you could move it into the drop glue
[23:14:19] <strcat> well, maybe for @ it's needed
[23:14:21] * strcat shrugs
[23:14:29] <eddyb> strcat: only procs use the free glue
[23:14:35] <strcat> eddyb: ~ does
[23:14:37] <strcat> and ~[T]
[23:14:39] <strcat> afaik
[23:14:47] <strcat> eddyb: trans::uniq
[23:14:50] <strcat> if it's still there
[23:14:56] <eddyb> nope
[23:15:15] <strcat> eddyb: so you're telling me that in glue.rs, the uniq glue no longer calls it?
[23:15:36] <strcat> it still has paths for them ;\
[23:15:40] <eddyb> wait, wait, glue functions call free_ty. let me look some more
[23:15:59] <strcat> afaik drop glue calls it after destroying the contained thing
[23:16:04] <strcat> I don't know why it's separate
[23:16:28] <eddyb> hmm, it's also called from decr_refcnt_maybe_free
[23:17:27] <strcat>       ty::ty_evec(_, ty::vstore_uniq) | ty::ty_estr(ty::vstore_uniq) => {
[23:17:30] <strcat>         free_ty(bcx, v0, t)
[23:17:32] <strcat>       }
[23:17:40] <strcat> eddyb: anyway I never understood why it was this way, *shrug*
[23:17:58] <strcat> eddyb: also free_ty/free_ty_immediate is an entry point afaik
[23:18:03] <strcat> called in datum.rs or somewhere
[23:18:39] <eddyb> it's only called from trans::closure (outside of trans::glue)
[23:19:59] <eddyb> this code is so hard to visualize. especially without knowing the codegen infrastructure
[23:20:31] <strcat> eddyb: the cleanup code enters the call_ functions at certain points
[23:20:42] <strcat> the glue is lazily generated in theory, but tydescs force it all to get generated afaik
[23:21:15] <strcat> closures have a tydesc
[23:21:41] <strcat> could be removed if we didn't care about managed ptrs
[23:22:11] <strcat> borrowed closures don't need one, procs need destructor pointers
[23:22:27] <strcat> well it could just be 1 fn ptr with static calls inside
[23:23:01] <strcat> if we had a real gc, I'm sure the metadata could just be passed to it as necessary
[23:23:11] <strcat> atm it's a real pain.
[23:23:24] <strcat> supporting an imaginary gc is really annoying
[23:23:28] <eddyb> I'm still trying to figure out the relationships. at least it's fun
[23:25:18] <eddyb> strcat: uniq has only one function. it actually calls glue::drop_ty
[23:25:20] <cmr> eddyb: when you figure it out let the rest of us know :p
[23:25:42] <eddyb> ping me when you get IDE support, that will make the second half easier
[23:27:29] <eddyb> we need to (free, exchange_free) => (free_local, free)
[23:28:25] <dbaupp> eddyb: do it?
[23:28:38] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Connection reset by peer)
[23:29:36] <eddyb> strcat: tydesc doesn't force glue to be generated AFAICT
[23:29:43] <pcwalton> ideally malloc_local and free_local should just vanish
[23:29:53] <pcwalton> GC should be a library and it should have no free function (because it's a GC) :)
[23:30:40] <eddyb> do we need take_glue?
[23:30:47] <strcat> eddyb: it's for @
[23:30:58] <strcat> eddyb: it's for the refcounts
[23:31:02] <eddyb> I hate ~@T right now
[23:31:03] <strcat> anything containing @
[23:31:07] <eddyb> hate it so much
[23:31:10] <strcat> like struct Foo(@5) has take glue
[23:31:23] <strcat> eddyb: I made those special cases! ;p
[23:31:31] <strcat> it used to all be the ~@T repr
[23:31:37] <pcwalton> eddyb: take glue will also not be needed once we move to a real GC
[23:31:49] <eddyb> ~Trait containing @T is why take glue exists at all, right?
[23:31:57] <strcat> pcwalton: could we just have a really dumb fully conservative gc ASAP to drop this stuff?
[23:32:11] <pcwalton> yes, and that's why I'm suggesting boehm
[23:32:31] <cmr> I think we're goingto have to try hard to *top* boehm :p
[23:32:33] <eddyb> and we can't break those because rustc
[23:32:40] <pcwalton> cmr: my point exactly
[23:32:46] <pcwalton> the work is done for us and it's honestly not bad for the constraints
[23:32:53] <pcwalton> everyone hates on Boehm because of Mono and GCC but those were abuses
[23:33:04] <pcwalton> our use case is perfect
[23:33:15] <pcwalton> (well, nearly -- we should eliminate the thread synchronization
[23:33:17] <pcwalton> )
[23:33:20] <eddyb> you know what? we should rename the types. they really suck for reading the code
[23:33:28] <eddyb> what does "e" in evec even mean?
[23:33:36] <strcat> pcwalton: elinks was great
[23:33:43] <eddyb> and "box" for @T gets confusing fast
[23:33:46] <strcat> pcwalton: spidermonkey + boehm in the same process!
[23:33:47] <pcwalton> did elinks use Boehm?
[23:33:50] <pcwalton> heh :)
[23:34:00] <pcwalton> there was an XPCOM-GC experiment that did the same with firefox
[23:34:01] <strcat> it might not anymore, haven't looked for a long time
[23:34:12] <strcat> I just remember elinks using more memory than firefox over time
[23:34:25] <cmr> heh
[23:34:37] <strcat> I think they had weird cycles between the GC heaps...
[23:34:41] * strcat shrugs
[23:34:47] <pcwalton> that's what all browsers end up with
[23:34:56] <pcwalton> unless they just GC the DOM objects
[23:35:03] <pcwalton> or have a cycle collector
[23:35:07] <pcwalton> it's a tricky problem
[23:35:32] <pcwalton> what Blink is doing with Oilpan makes sense, but I still predict sadness due to stop the world GC in C++
[23:35:42] <pcwalton> stop-all-threads multithreaded GC
[23:35:51] <eddyb> why do we have ty_closure and ty_opaque_closure_ptr?
[23:36:05] <pcwalton> I forget
[23:36:07] <pcwalton> I knew at one point
[23:36:19] <strcat> eddyb: the opaque stuff was used for monomorphization afaik
[23:36:30] <eddyb> ty::ty_box(_) | ty::ty_opaque_box | ty::ty_evec(_, ty::vstore_box) | ty::ty_estr(ty::vstore_box) // EWW
[23:36:37] <eddyb> strcat: "was"?
[23:36:55] <strcat> I removed it, it was like a 0.1% size win at the expense of breaking a lot of stuff
[23:37:04] <strcat> and mergefunc will cover it
[23:37:16] <strcat> eddyb: could probably remove opaque_box
[23:37:29] <strcat> just the pain of dealing with whatever uses it to consolidate paths
[23:37:39] *** Quits: tikue_ (tkuehn@moz-C55F9DFF.hsd1.pa.comcast.net) (Quit: tikue_)
[23:37:43] <eddyb> I'll start doing that now. in the middle of the night. just so I can read the glue code
[23:37:44] <strcat> eddyb: it'd turn @mut and @ into opaque_box
[23:38:02] <strcat> so it wouldn't need to monomorphize as much
[23:38:17] <eddyb> huh? how does that make sense?
[23:38:18] <pcwalton> the one thing that concerns me a little about losing take glue is write barriers
[23:38:20] <pcwalton> but meh
[23:38:30] <pcwalton> I think it's quite possible that the generational hypothesis does NOT hold for @ boxes in Rust
[23:38:53] <pcwalton> you still need it to maintain the tricolor invariant but â€¦ eh
[23:39:06] <pcwalton> we might be able to add it back without take glue anyhow
[23:40:25] <eddyb> / "Fake" types, used for trans purposes
[23:40:38] <eddyb> yeah, well, fake => dead
[23:41:10] <eddyb> why do we use ty_evec when ty_vec is not taken?
[23:42:48] <eddyb> acrichto: my bad, I forgot to push the last commit (I was missing an import), r?
[23:42:53] <brson> eddyb: historical reasons. there have been a lot of different vecs. ty_vec -> ty_ivec -> ty_evec
[23:43:09] <eddyb> newyears cleanup time
[23:43:14] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[23:44:26] *** Joins: ion- (ion@moz-5285E875.hsd1.va.comcast.net)
[23:44:31] <strcat> eddyb: iirc graydon told me `e` stood for 'explicit' because all vectors used to be heap allocated + refcounted
[23:44:43] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[23:45:13] <strcat> it's somewhere in my weechat logs...
[23:56:50] <eddyb>     ty_opaque_box, // used by monomorphizer to represent any @ box
[23:59:00] <eddyb> @Trait drop glue does decr_refcnt_maybe_free(bcx, llbox, Some(llbox_ptr), ty::mk_opaque_box(ccx.tcx))

[00:04:33] <nrc> Man, it sucks that name resolution has to work on metadata as well as source - we should really save this tuff rather than the AST
[00:08:03] *** Joins: Rym (y@moz-vsu.f6d.55.31.IP)
[00:13:04] *** Quits: Rym (y@moz-vsu.f6d.55.31.IP) (Ping timeout: 121 seconds)
[00:15:02] <cmr> ty::ctxt::trait_impls goes from trait -> impls, but which map goes from impl -> trait?
[00:15:11] *** Joins: Rym (y@moz-vsu.f6d.55.31.IP)
[00:16:09] <cmr> impl_trait_refs?
[00:47:27] *** Quits: bleibig (bleibig@moz-kn8mvj.ca.comcast.net) (Connection closed)
[00:48:03] *** Joins: bleibig (bleibig@moz-kn8mvj.ca.comcast.net)
[00:50:47] *** Joins: Rym_ (y@moz-vsu.f6d.55.31.IP)
[00:50:52] *** Quits: Rym (y@moz-vsu.f6d.55.31.IP) (Ping timeout: 121 seconds)
[01:01:28] *** Quits: Rym_ (y@moz-vsu.f6d.55.31.IP) (Connection closed)
[01:14:38] *** Joins: Rym (y@moz-vsu.f6d.55.31.IP)
[01:27:13] *** Joins: brson (brson@moz-cfhap5.mtv2.mozilla.com)
[01:27:13] *** ChanServ sets mode: +qo brson brson
[01:52:21] *** Quits: c74d (c74d3a4ebb6@moz-0ersgu.oc.cox.net) (Ping timeout: 121 seconds)
[01:52:44] *** Joins: c74d3 (c74d3a4ebb6@moz-b2tjn2.mggc.hibn.4404.2002.IP)
[01:55:37] *** Quits: reem (reem@moz-2icmmi.ca.comcast.net) (Connection closed)
[02:12:53] *** Quits: zz_kimundi (kimundi@moz-jjo3eb.dip0.t-ipconnect.de) (Ping timeout: 121 seconds)
[02:15:25] *** Joins: zz_kimundi (kimundi@moz-9boq3l.dip0.t-ipconnect.de)
[02:15:26] *** zz_kimundi is now known as kimundi
[02:32:30] *** Quits: c74d3 (c74d3a4ebb6@moz-b2tjn2.mggc.hibn.4404.2002.IP) (Connection closed)
[02:33:55] *** Joins: c74d (c74d3a4ebb6@moz-b2tjn2.mggc.hibn.4404.2002.IP)
[02:35:42] *** Quits: Rym (y@moz-vsu.f6d.55.31.IP) (Ping timeout: 121 seconds)
[02:48:10] *** Joins: reem (reem@moz-vqnf7c.coob.q2h1.0009.2601.IP)
[02:49:25] *** Joins: Rym (y@moz-vsu.f6d.55.31.IP)
[02:54:34] *** Quits: reem (reem@moz-vqnf7c.coob.q2h1.0009.2601.IP) (Connection closed)
[02:58:15] *** Quits: brson (brson@moz-cfhap5.mtv2.mozilla.com) (Quit: leaving)
[03:00:52] <cmr> ah, ty::trait_id_of_impl
[03:01:09] <cmr> everything I ever want is in ty I can just never find it through the huge pile of everything else
[03:02:23] *** Quits: c74d (c74d3a4ebb6@moz-b2tjn2.mggc.hibn.4404.2002.IP) (Ping timeout: 121 seconds)
[03:03:17] *** Joins: c74d3 (c74d3a4ebb6@moz-0ersgu.oc.cox.net)
[03:06:58] <cmr> oh that's not what I want, I wanted from an impl item -> the impl... feh, this lint visitor is annoying.
[03:08:10] *** Joins: reem (reem@moz-2icmmi.ca.comcast.net)
[03:14:43] <huon> cmr: what are you trying to do?
[03:15:04] <huon> get the defid of the Trait in `impl Trait for ...`?
[03:15:48] <cmr> huon: I think I figured out how to restructure it, but originally I wanted to go from fn foo() { } in an `impl` to the impl itself.
[03:17:20] <huon> oh
[03:17:45] <huon> (I think the unconditional recursion lint does something like that if you need any inspiration, although it's pretty hacky too)
[03:18:09] <cmr> which usually you wouldn't have to do, since you visit the impl first, but LintPass doesn't let you stop the descent into the ast
[04:39:33] *** Quits: reem (reem@moz-2icmmi.ca.comcast.net) (Connection closed)
[04:43:07] *** Quits: Rym (y@moz-vsu.f6d.55.31.IP) (Ping timeout: 121 seconds)
[04:45:04] *** Joins: Rym (y@moz-vsu.f6d.55.31.IP)
[04:45:49] *** Joins: reem (reem@moz-2icmmi.ca.comcast.net)
[04:47:23] *** Quits: reem (reem@moz-2icmmi.ca.comcast.net) (Connection closed)
[05:16:40] *** Joins: reem (reem@moz-2icmmi.ca.comcast.net)
[05:18:44] * nrc rages at resolve a little more....
[05:26:29] *** Quits: bleibig (bleibig@moz-kn8mvj.ca.comcast.net) (Connection closed)
[05:28:33] *** Quits: acharles (acharles@moz-ulbdcn.ca.comcast.net) (Ping timeout: 121 seconds)
[05:31:47] *** Joins: bleibig (bleibig@moz-kn8mvj.ca.comcast.net)
[05:36:16] *** Joins: acharles (acharles@moz-ulbdcn.ca.comcast.net)
[05:54:45] *** Quits: Rym (y@moz-vsu.f6d.55.31.IP) (Ping timeout: 121 seconds)
[06:10:43] *** Joins: eddyb (eddyb@moz-lt3.fmm.166.109.IP)
[06:13:14] <eddyb> nmatsakis, nrc: idea for nicer types in error messages: per-crate "exported nominal types" and picking the "most specific" one
[06:15:05] <eddyb> example: core::result::Result<T, E>, std::result::Result<T, F> and std::io::Result<T> all map to a ty_enum with the same DefId
[06:16:19] <eddyb> if core is not accessible in the current crate, ignore the first. if the error type matches io::Error, use the last one because it's more specific/less generic
[06:22:00] <eddyb> might be a bit too costly to do unification every time and building a decision tree does not sound like fun
[06:22:02] *** Joins: Rym (y@moz-vsu.f6d.55.31.IP)
[06:22:07] <eddyb> but YMMV
[06:26:10] *** Quits: Rym (y@moz-vsu.f6d.55.31.IP) (Ping timeout: 121 seconds)
[06:27:36] *** Quits: eddyb (eddyb@moz-lt3.fmm.166.109.IP) (Ping timeout: 121 seconds)
[07:16:01] *** Joins: Rym (y@moz-vsu.f6d.55.31.IP)
[07:20:19] *** Quits: Rym (y@moz-vsu.f6d.55.31.IP) (Ping timeout: 121 seconds)
[07:57:15] *** Quits: reem (reem@moz-2icmmi.ca.comcast.net) (Connection closed)
[07:58:56] *** Joins: reem (reem@moz-o8hgs0.coob.q2h1.0009.2601.IP)
[08:10:12] *** Joins: Rym (y@moz-vsu.f6d.55.31.IP)
[08:14:28] *** Quits: Rym (y@moz-vsu.f6d.55.31.IP) (Ping timeout: 121 seconds)
[09:04:22] *** Joins: Rym (y@moz-vsu.f6d.55.31.IP)
[09:08:38] *** Quits: Rym (y@moz-vsu.f6d.55.31.IP) (Ping timeout: 121 seconds)
[09:38:24] *** Quits: nrc (nrc@moz-4bhi2i.xtra.co.nz) (Ping timeout: 121 seconds)
[09:58:32] *** Joins: Rym (y@moz-vsu.f6d.55.31.IP)
[10:03:55] *** Quits: Rym (y@moz-vsu.f6d.55.31.IP) (Ping timeout: 121 seconds)
[10:27:28] *** Quits: reem (reem@moz-o8hgs0.coob.q2h1.0009.2601.IP) (Connection closed)
[10:33:49] *** Joins: simukis (nagisa@moz-8t068g.static.zebra.lt)
[10:40:15] *** Quits: simukis (nagisa@moz-8t068g.static.zebra.lt) (Connection closed)
[10:42:10] *** Joins: pnkfelix (pnkfelix@moz-6v5.3nd.202.89.IP)
[10:42:10] *** ChanServ sets mode: +o pnkfelix
[10:54:29] *** Joins: Rym (y@moz-vsu.f6d.55.31.IP)
[10:58:45] *** Quits: Rym (y@moz-vsu.f6d.55.31.IP) (Ping timeout: 121 seconds)
[11:44:46] *** Joins: simukis (nagisa@moz-8t068g.static.zebra.lt)
[11:48:36] *** Joins: Rym (y@moz-vsu.f6d.55.31.IP)
[11:52:54] *** Quits: Rym (y@moz-vsu.f6d.55.31.IP) (Ping timeout: 121 seconds)
[12:42:46] *** Joins: Rym (y@moz-vsu.f6d.55.31.IP)
[12:47:04] *** Quits: Rym (y@moz-vsu.f6d.55.31.IP) (Ping timeout: 121 seconds)
[12:58:29] *** Joins: joel2 (joel@moz-6ampnk.gtri.gatech.edu)
[13:28:15] *** Joins: reem (reem@moz-2icmmi.ca.comcast.net)
[13:32:23] *** Quits: reem (reem@moz-2icmmi.ca.comcast.net) (Ping timeout: 121 seconds)
[13:36:57] *** Joins: Rym (y@moz-vsu.f6d.55.31.IP)
[13:41:13] *** Quits: Rym (y@moz-vsu.f6d.55.31.IP) (Ping timeout: 121 seconds)
[14:31:05] *** Joins: Rym (y@moz-vsu.f6d.55.31.IP)
[14:35:23] *** Quits: Rym (y@moz-vsu.f6d.55.31.IP) (Ping timeout: 121 seconds)
[15:25:14] *** Joins: Rym (y@moz-vsu.f6d.55.31.IP)
[15:29:32] *** Quits: Rym (y@moz-vsu.f6d.55.31.IP) (Ping timeout: 121 seconds)
[16:19:23] *** Joins: Rym (y@moz-vsu.f6d.55.31.IP)
[16:31:40] *** Joins: eddyb (eddyb@moz-ar9.ad3.27.188.IP)
[17:32:58] *** Quits: pnkfelix (pnkfelix@moz-6v5.3nd.202.89.IP) (Quit: rcirc on GNU Emacs 24.3.92.1)
[17:45:47] *** Quits: Rym (y@moz-vsu.f6d.55.31.IP) (Ping timeout: 121 seconds)
[18:11:40] *** Joins: sigma (sigma@moz-ohog4c.range86-135.btcentralplus.com)
[18:15:49] *** Joins: Rym (y@moz-vsu.f6d.55.31.IP)
[18:35:42] *** Joins: brson (brson@moz-0k6.crj.56.172.IP)
[18:35:42] *** ChanServ sets mode: +qo brson brson
[18:35:52] *** Quits: sigma (sigma@moz-ohog4c.range86-135.btcentralplus.com) (Ping timeout: 121 seconds)
[18:50:39] <doener> hrm, I suppose I'm messing something up really bad. Getting the same pointer from je_mallocx twice
[18:51:19] <eddyb> doener: without it being freed in between?
[18:51:23] <doener> eddyb: yup
[18:51:24] <eddyb> doener: and size != 0?
[18:51:40] <doener> eddyb: right. It's messing up a String
[18:51:58] <doener> eddyb: guess I'm messing up some bits that jemalloc is using?
[18:52:48] <eddyb> heap invalidation is alway fun :(
[18:53:03] <doener> time to reach for valgrind
[19:03:39] *** Quits: simukis (nagisa@moz-8t068g.static.zebra.lt) (A TLS packet with unexpected length was received.)
[19:03:53] *** Joins: simukis (nagisa@moz-8t068g.static.zebra.lt)
[19:18:07] *** Joins: nrc (nrc@moz-4bhi2i.xtra.co.nz)
[19:18:08] *** ChanServ sets mode: +qo nrc nrc
[19:52:20] *** Joins: Rym_ (y@moz-vsu.f6d.55.31.IP)
[19:52:27] *** Quits: Rym (y@moz-vsu.f6d.55.31.IP) (Connection closed)
[20:04:23] *** Quits: simukis (nagisa@moz-8t068g.static.zebra.lt) (Connection closed)
[20:25:20] *** Quits: brson (brson@moz-0k6.crj.56.172.IP) (Ping timeout: 121 seconds)
[20:38:00] *** Joins: brson (brson@moz-0k6.crj.56.172.IP)
[20:38:00] *** ChanServ sets mode: +qo brson brson
[20:50:42] *** Joins: reem (reem@moz-2icmmi.ca.comcast.net)
[20:58:07] *** Quits: reem (reem@moz-2icmmi.ca.comcast.net) (Connection closed)
[21:07:27] *** Quits: joel2 (joel@moz-6ampnk.gtri.gatech.edu) (Ping timeout: 121 seconds)
[21:13:12] *** Joins: simukis (nagisa@moz-8t068g.static.zebra.lt)
[21:33:07] *** Joins: reem (reem@moz-2icmmi.ca.comcast.net)
[21:34:09] *** Quits: reem (reem@moz-2icmmi.ca.comcast.net) (Connection closed)
[21:34:10] *** Joins: reem (reem@moz-2icmmi.ca.comcast.net)
[21:49:36] *** Joins: popinman322 (Mibbit@moz-79ak9q.res.rr.com)
[21:50:19] <popinman322> What's the format for the SPEC portion of the cfg flag?
[21:52:04] <cmr> popinman322: it roughly corresponds to the syntax of #[cfg]
[21:53:12] <popinman322> How roughly? Are there any solid docs?
[21:53:26] <cmr> I don't think it's documented.
[21:53:34] <cmr> I think it's the full #[cfg] syntax but I'm  not sure
[21:54:34] <cmr> ie, --cfg foo --cfg bar=baz --cfg a(b,c)
[21:55:16] <popinman322> --cfg not(foo) ?
[21:55:35] <eddyb> popinman322: no, that's a predicate
[21:55:36] <cmr> while that technicall parses, it's not what you want.
[21:55:50] <cmr> #[cfg(not(foo))] would only query for --cfg foo
[21:55:59] <popinman322> How do I disable an option with cfg?
[21:56:03] <eddyb> you can't
[21:56:33] <popinman322> I love it when I can't do things
[21:57:18] <cmr> What specifically are you trying to do? Most cfg variables that are exposes are the result of some other state, and don't themselves change compiler state.
[21:57:27] <cmr> (or passed from cargo etc)
[21:57:33] <cmr> In fact, not most, all.
[21:57:38] <popinman322> I'm trying to compile liballoc and libcollections for a severely restricted ARM platform (not bare metal, no threads, glitchy libc, etc.)
[22:00:01] <cmr> Ok. What cfg do you want to effect? I think all but debug_assertions are controlled from the target specification: http://doc.rust-lang.org/rustc_back/target/index.html
[22:01:01] <cmr> (or passed from Cargo)
[22:01:33] <popinman322> Rust is mistaking the platform to be unix (which causes problems with liblibc)
[22:02:44] * popinman322 is checking
[22:02:46] <cmr> Yeah, right now #[cfg(unix)] is tied quite heavily to how rustc invokes the linker. Our support for "fringe" usecases is quite poor.
[22:03:12] <cmr> I think it's just the inverse of TargetOptions::is_like_windows
[22:04:34] <popinman322> cmr: What do you mean by that?
[22:07:55] <popinman322> Are you suggesting a plan of action or commenting on the situation?
[22:08:22] <cmr> popinman322: #[cfg(unix)] is set if is_like_windows is false, and controls certain things about linking such as what file paths it looks for libraries.
[22:08:26] <cmr> commenting on the situatino.
[22:08:28] <cmr> *situation
[22:09:31] <popinman322> So I'd have to resort to heavy coercion of liblibc to get the desired effect?
[22:10:31] <cmr> Yeah
[22:11:23] * popinman322 rolls up his sleeves
[22:11:29] <popinman322> Thanks
[22:11:42] *** Quits: popinman322 (Mibbit@moz-79ak9q.res.rr.com) (Quit: http://www.mibbit.com ajax IRC Client)
[22:16:51] <eddyb> cmr: sorry
[22:17:13] <cmr> if we're going to have different channels, might as well use them
[22:17:29] <nrc> eddyb: so, I'm trying to encode an unqualified ref to an assoc type
[22:17:37] <nrc> so the ast::TyPath has no QSelf
[22:17:45] <nrc> but I can figure that out in resolve
[22:17:52] <nrc> but now I have nowhere to put it
[22:17:54] <eddyb> can you be more specific?
[22:18:06] <nrc> impl C for T {
[22:18:07] <eddyb> what are you working on?
[22:18:12] <nrc> type Foo = i32;
[22:18:16] <eddyb> impl T for C?
[22:18:27] <nrc> fn bar(x: Foo) {}
[22:18:29] <nrc> }
[22:18:31] <nrc> er, yes
[22:18:38] <nrc> (I always get that the wrong weay round
[22:18:48] <nrc> so the Foo is shorthand for <C as T>::Foo
[22:19:18] <eddyb> riiight
[22:19:19] <nrc> I was hoiping I could just roll all this up into the PathResolution and it'll all come out in the wash in ast_conv/collect
[22:19:30] <eddyb> so, hmm
[22:19:32] <nrc> but it looks like it won't be so easy
[22:19:56] <nrc> (also thinking about trying to make it easy to move Self::Foo shorthand here, rather than libsyntax)
[22:19:58] <eddyb> the only way you can encode it is as <>::Foo
[22:20:14] <eddyb> so base_def would be Self
[22:20:38] <eddyb> with one associated type
[22:20:59] <nrc> that is how I do it for traits
[22:21:02] <nrc> and it works nicelt
[22:21:04] <nrc> nicely
[22:21:11] <eddyb> but you don't have Self in impls?
[22:21:18] <nrc> we don't
[22:21:24] <eddyb> right, that's what you need to fix
[22:21:25] <nrc> it should be easy for trait impls
[22:21:37] <nrc> but for inherant impls - I don't have a trait at all
[22:22:00] <nrc> I guess it should be possible
[22:22:12] <nrc> currently DefSelf takes a NodeIs
[22:22:14] <nrc> NodeId
[22:22:28] <nrc> I guess I make that an Option<DefId> and let type checking sort it out
[22:22:35] <eddyb> is that a NodeId of the trait?
[22:22:38] <nrc> yes
[22:22:47] <eddyb> how about you make it a NodeId of the encosing item?
[22:22:52] <eddyb> trait or impl
[22:23:30] <eddyb> then typeck should be able to resolve it for impls to some concrete type
[22:23:41] <nrc> for the impl Foo as Bar case, having the trait id is easier than having the impl id
[22:24:03] <eddyb> but it makes resolving Self harder
[22:24:18] <eddyb> because you need to keep track of the context some other way
[22:24:24] <eddyb> I guess it's not the end of the world
[22:24:33] <nrc> there is already machinery to do that though, aiui any way
[22:24:44] <eddyb> is the DefId even useful at all?
[22:24:56] <eddyb> I mean, other than hacks
[22:25:04] <nrc> which DefId?
[22:25:11] <eddyb> the one for Self inside a trait
[22:25:19] <eddyb> I don't recall it being used for anything interesting
[22:25:19] <nrc> oh right
[22:25:33] <nrc> perhaps not? I'll look...
[22:26:15] <nrc> er, maybe not, we don't actually use it when we're finalising assoc types at least
[22:26:22] <nrc> I'm not sure where it is actually used
[22:26:30] <eddyb> try to get rid of it then :D
[22:26:39] * eddyb does a quick search to confirm
[22:26:43] <eddyb> for `impl T for C`, you most likely want to treat it as a `C: T` predicate
[22:27:03] <eddyb> I recall nmatsakis implementing some T::Foo shorthand support using predicates
[22:27:49] <nrc> it seems to only be used in collect::is_param
[22:29:21] <nrc> that is weird
[22:30:15] <eddyb> oh, nested trait items
[22:30:54] <nrc> hmm?
[22:31:32] <eddyb> or not...
[22:33:00] <eddyb> ensure_super_predicates_step uses it
[22:33:11] <eddyb> (passing the trait's ID as param_id)
[22:36:16] <eddyb> and astconv::associated_path_def_to_ty ends up calling it, indirectly
[22:37:16] <eddyb> nrc: I think is_param should take Option<DefId> or SelfParam | TypeParam(DefId)
[22:41:49] <nrc> I don't see ensure_super_predicates_step using either DefSelfTy or is_param
[22:41:58] <nrc> I'm not sure what you mean 
[22:42:07] <eddyb> nrc: they use it indirectly
[22:42:17] <eddyb> through get_type_parameter_bounds
[22:42:34] <eddyb> right now they pass a trait ID
[22:42:35] <eddyb> OH
[22:42:37] <eddyb> cmr: ahahahahaha
[22:42:43] <eddyb> cmr: I think this causes a bug you're seeing
[22:42:59] <eddyb> nrc: there is no way there could be a Self in there from a different trait
[22:43:26] <eddyb> nrc: instead, I'm pretty sure this break legitimate uses, where supertraits are involved
[22:43:30] <eddyb> *this can break
[22:43:49] <eddyb> nrc: because you'll end up with a few DefSelfTy with different DefId's
[22:43:51] <nrc> why can't there be nested impls?
[22:44:16] <eddyb> nrc: you can't reference a Self type from a different trait
[22:45:05] <eddyb> or are you thinking of how you would do astconv for nested impls?
[22:45:09] <nrc> right, because resolve should work
[22:46:07] <nrc> that is what I was thinking of, yes
[22:48:31] <eddyb> nrc: okay, then the impl item ID would be useful
[22:48:46] <eddyb> nrc: because of write_ty_to_tcx(tcx, it.id, selfty);
[22:49:14] *** kimundi is now known as zz_kimundi
[22:49:20] <eddyb> also             tcx.predicates.borrow_mut().insert(local_def(it.id), ty_predicates.clone());
[22:50:52] <eddyb> nrc: so by time you look at associated types or methods inside an impl, Self should be resolvable, if you know the impl item ID
[22:53:06] <eddyb> nrc: type ascription is wasting my time, really, there's no easy way to handle that situation
[22:53:10] <nrc> that is encouraging
[22:53:32] <nrc> obvs that was a response to the previous comment
[22:53:44] <eddyb> I was hoping I could get away with a 5-min patch on top of a rebase
[22:54:06] <eddyb> nrc: ;)
[22:54:11] <nrc> I didn't think it would be *that* easy
[22:55:00] <eddyb> technically... I could "just" add a wrapper for the demand::eqtype version
[22:55:21] <nrc> but it seems that whether you are in a reference context is a fairly simple property of the syntax, no? 
[22:55:43] <eddyb> nrc: I want to integrate it with the existing code without coming up with yet another abstraction
[22:56:52] <eddyb> nrc: it might be precisely this https://github.com/rust-lang/rust/pull/23119/files
[22:57:19] <eddyb> which is... just two places. odd
[22:58:27] <eddyb> ah, &x doesn't enforce anything on x
[23:29:51] <eddyb> nrc: x.f and x[i] are reference contexts (for x)
[23:30:42] <eddyb> because of autoref coercions
[23:31:18] <eddyb> nrc: it's impossible to argue about this stuff before typeck finishes :(
[23:31:28] *** Quits: Rym_ (y@moz-vsu.f6d.55.31.IP) (Ping timeout: 121 seconds)
[23:32:02] <eddyb> however... can we run EUV just before writeback?
[23:32:28] <nrc> EUV?
[23:32:33] <eddyb> ExprUseVisitor
[23:32:51] <eddyb> I think that can tell you whether something is borrowed
[23:33:02] *** Joins: Rym_ (y@moz-vsu.f6d.55.31.IP)
[23:33:08] <eddyb> s/something/an expression
[23:33:50] <nrc> What about not checking for type ascription in ref context until EUV runs and erroring then if we had previously coerced?
[23:34:12] <eddyb> in which case, you can enforce that the type is equal
[23:34:27] <eddyb> nrc: yupp, but you don't need to outright error
[23:34:52] <nrc> no?
[23:34:59] <eddyb> hmm
[23:35:23] <eddyb> nrc: for some reason I prefer type mismatch errors to some specific ascription error
[23:38:29] <nrc> oh sure, you could do that, I don't care particularly about the exact error
[23:38:38] <nrc> we might be able to give a helpful note in this case
[23:39:07] <nrc> but I was imagining we do domething equivalent to demand::ty_eq
[23:39:19] *** nrc is now known as nrc|afk
[23:39:33] <nrc|afk> going afk for a bit...
[23:39:46] <eddyb> I don't think I'll poke at it more, it's pretty late here
[23:48:27] *** Joins: WindowsBunny1 (Peter@moz-ubruqj.east.verizon.net)
[23:49:21] *** Quits: WindowsBunny (Peter@moz-7f2st1.east.verizon.net) (Ping timeout: 121 seconds)
[23:53:27] *** Quits: simukis (nagisa@moz-8t068g.static.zebra.lt) (Client exited)

[00:00:11] <jeaye> We'd need a spec first. :P
[00:00:15] <strcat> it's defined by the individual iterator objects, none of which have been introduced
[00:00:20] <sfackler> oh, right
[00:00:45] <strcat> it needs to be 2 sentences and that's all
[00:01:28] <strcat> imo no one is ever really going to need to call next() multiple times in a situation where they don't know their iterator pipeline
[00:01:47] <strcat> it doesn't deserve coverage in the tutorial beyond "don't do this unless the iterator specifically says you can"
[00:02:34] <Eridius> strcat: I disagree. I think a reasonably common impulse will be to call .next() again after a for loop to see if you had reached the end
[00:03:51] *** Joins: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP)
[00:04:18] <strcat> it doesn't need to be defined this way
[00:04:31] <strcat> zip, take and chain can just say they will use next() to determine if they are at the end
[00:04:39] <joelteon> how do you mark macros public?
[00:05:04] <kimundi> joelteon: that doesn't really work right now
[00:05:05] <strcat> python doesn't devote any part of their tutorials to these
[00:05:15] <joelteon> how do they do it with fmt!?
[00:05:36] <Eridius> strcat: ok I'm leaning towards accepting your more loosely-defined wording in the tutorial (e.g. "should not be called again"), and being more explicit in the Iterator docs
[00:05:49] <strcat> but I'm not sure that's the right wording
[00:05:51] <Eridius> joelteon: fmt!() and the other built-in macros are provided as if they were defined at the top of your crate
[00:05:53] <strcat> it's totally fine to do it in most cases
[00:05:58] <joelteon> oh
[00:06:02] <kimundi> joelteon: buildin in the compiler, every source file gets it appended
[00:06:04] <joelteon> I see
[00:06:16] <joelteon> rats
[00:06:17] <sfackler> macro export is on the todo list
[00:06:34] <sfackler> i think
[00:06:49] <Eridius> strcat: "In general, you cannot rely on the behavior of the `next()` method after it has returned `None`. Some iterators may return `None` forever. Others may behave differently."
[00:07:09] *** Joins: lkuper (lkuper@74941BE4.A402E718.C082B7DC.IP)
[00:07:23] <strcat> I'm not entirely convinced about this whole issue tbh
[00:07:26] <Eridius> or maybe "Most iterators will ..."
[00:07:33] *** Quits: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com) (Ping timeout)
[00:07:51] <Eridius> strcat: I was inspired to deal with this now because we have an outstanding PR that ran afoul of this exact issue
[00:07:57] <Eridius> (the glob one)
[00:08:16] <engla> I can see this becoming a problem for I/O iterators
[00:08:17] <Eridius> it very explicitly assumes that if an iterator returns None once it will return None forever
[00:08:31] <strcat> certain iterator adaptors stop early, and check whether they've stopped by calling next()
[00:08:34] <strcat> that's the issue
[00:08:50] <strcat> all iterators currently do keep returning None forever
[00:09:04] <strcat> as they do in python
[00:09:06] <Eridius> strcat: at least one iterator adaptor leaves the "have I stopped?" up to the user-supplied closure, but always calls .next() first
[00:09:18] <Eridius> strcat: the user-supplied closure could decide to return None once, and then go back to returning values
[00:09:27] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[00:09:30] <strcat> okay so it's up to the user-defined closure to implement the protocol the same way - the issue here is side effects underlying the adaptors like zip
[00:09:49] <Eridius> side-effects are why I'm not happy leaving this up to "the closure must conform to the protocol"
[00:09:55] <strcat> I'm just not convinced we need to make this awkward definition of the protocol for an edge case only existing with chain/zip
[00:10:18] <strcat> rather than explaining the edge case
[00:10:20] <Eridius> strcat: it exists with scan too, even if the closure conforms to the protocol
[00:10:28] *** Quits: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP) (Ping timeout)
[00:10:39] <strcat> it can stop early?
[00:10:46] <Eridius> if we don't define this now, I'm afraid that future built-in, and user-supplied iterators will make differeing assumptions
[00:10:51] <Eridius> strcat: scan returns Option<B>
[00:10:55] <strcat> and None stops
[00:10:56] *** Quits: dew (Instantbir@moz-8A63B53.dhcp.stls.mo.charter.com) (Ping timeout)
[00:10:56] <Eridius> rather the closure does
[00:10:58] <engla> rusti: let v = ~[Some(1), Some(2), None, Some(4)]; let mut it = v.consume_iter().scan((), |_, x| x); (it.next(), it.next(), it.next(), it.next())
[00:10:59] -rusti- (Some(1), Some(2), None, Some(4))
[00:11:04] <engla> there's an example with scan
[00:11:15] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[00:11:22] <Eridius> strcat: the implementation is literally just self.it.next().chain(|x| f(&mut self, x))
[00:11:49] <Eridius> so it will always call .next() on the underlying iterator, but the user-supplied closure may or may not stop early. And if the user-supplied closure behaves perfectly, it still can't prevent the side-effect case
[00:12:36] <strcat> zip already needs to clearly define what it does
[00:12:39] <strcat> whether it short-circuits
[00:12:42] <strcat> as does chain
[00:12:57] <strcat> I'm not really seeing how it impacts the protocol as a whole
[00:13:00] <Eridius> my concern is that if we don't explicitly define this now, people absolutely will assume that a) an iterator that returns None once will return None forever, and b) an iterator that returns None once won't trigger side-effects on future calls to .next()
[00:13:01] <strcat> that scan implementation is incorrect
[00:13:06] <strcat> if you think that's too easy, we'll remove scan
[00:13:10] *** Quits: pupoque (Adium@3CBC96CB.41993F96.4329AE1A.IP) (Quit: Leaving.)
[00:13:32] <Eridius> strcat: I think you're too focused on the set of iterators we provide today. Anyone writing a new iterator will possibly break any implicit assumptions that we haven't codified
[00:13:37] <strcat> it should return None forever though, they all do unless you implement them wrong
[00:13:56] <strcat> I don't see a real use case for not returning None forever
[00:13:58] <Eridius> strcat: I can see use-cases for iterators that don't return None forever
[00:14:05] <Eridius> trivial example: non-blocking I/O
[00:14:08] <engla> it sounds like that should be the defined protocol, to return None forever
[00:14:24] <engla> Eridius: ah, mapping a channel to an iterator too
[00:14:30] <Eridius> engla: yep, that too
[00:14:35] <engla> just let try_recv be .next()
[00:14:44] <strcat> that doesn't make sense as an iterator
[00:14:45] <Eridius> my feeling is that it's too useful to have iterators that behave like this
[00:14:47] <strcat> an iterator would block
[00:14:59] <strcat> when you start changing the protocol like that, it stops making sense as an iterator
[00:15:13] <Eridius> strcat: but I'm not changing the protocol, since the protocol doesn't define that it returns None forever
[00:15:23] <engla> resetting on .next() sounds tricky
[00:15:23] <strcat> it does right now
[00:15:28] <strcat> it's what I intended, and how it's implemented
[00:15:32] <Eridius> right now it's undefined
[00:15:36] <strcat> it doesn't define that side effects do not happen
[00:15:40] <strcat> when you call next()
[00:15:40] <engla> as in, too surprising
[00:15:44] <strcat> and you passed things with side effects
[00:15:55] <Eridius> I'm also unhappy with the position that user-supplied closures to iterator adaptors (e.g. scan) need to explicitly implement the iterator protocol
[00:16:11] <jeaye> If I can't move out of a &mut then how can I move anything in a method?
[00:16:14] <strcat> I don't mind removing that iterator as it is right now then
[00:16:23] <engla> why not patch Scan
[00:16:25] <steven_is_false> jeaye: can you swap instead?
[00:16:49] <engla> do the hard work (keep track of the end) for the user
[00:16:50] <Eridius> engla: patching scan doesn't fix the side-effect case
[00:16:59] <Eridius> which hits a number of different iterator adaptors
[00:17:12] <jeaye> steven_is_false: I'm moving a couple of ~[] through a channel to another task.
[00:17:14] <engla> it fixes it for Scan right?
[00:17:18] <Eridius> yes
[00:17:30] <Eridius> fixing scan will indeed fix scan
[00:17:50] <strcat> Eridius: the None thing won't change whether or not side effects are visible from implementation details of zip/chain
[00:17:53] <steven_is_false> Okay then.
[00:18:02] <Eridius> strcat: what do you mean?
[00:18:04] <strcat> does zip call next on both at once, or short-circuit?
[00:18:07] <strcat> that's visible too
[00:18:12] <strcat> I don't see this as a protocol issue
[00:18:15] <strcat> at all
[00:18:26] <engla> why not call on both with zip? that can't hurt
[00:18:29] <strcat> and I think using it for non-blocking I/O like that would be very confusing
[00:18:33] <Eridius> I'm not sure why short-circuiting affects this discussion
[00:18:48] <jeaye> I want to send some owned boxes to a task, manipulate them, then have the task send them back. I don't think swapping can do this steven_is_false.
[00:18:57] <Eridius> engla: at the moment zip calls on both. I'm changing it to short-circuit at strcat's suggestion because that matches python behavior
[00:19:02] <strcat> Eridius: okay so you have a problem with side effects caused by adaptors like zip and chain not using a bool, but instead calling next()
[00:19:09] <strcat> that's the *cause*
[00:19:29] <strcat> and that's where we can define what happenbs
[00:19:32] <Eridius> strcat: my problem is with the idea that .next() should return None forever if it returns None once, but should _not_ be idempotent
[00:19:40] <engla> Eridius: true, but python allows zipping an iterator with itself. That's hard to do here
[00:19:49] <Eridius> I think that either .next() cannot be guaranteed to return None forever at the protocol level, or it _must_ be idempotent once it's returned None once
[00:20:01] <Eridius> engla: it's easy if you can clone the iterator
[00:20:16] <engla> if you clone it, you have two different iterators
[00:20:21] <strcat> it doesn't have to do with None
[00:20:23] <Eridius> the idempotency issue is my problem with side-effects
[00:20:23] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[00:20:26] <engla> so you don't need to short-circuit, they should be individually valid
[00:20:40] <Eridius> engla: short-circuiting only matters for side-effects
[00:20:45] <strcat> Eridius: so what about ones like len() causing side effects but not if they're specialized for random-access iterators?
[00:21:00] <strcat> you just plain can't depend on side effects from iterators happening or not happening
[00:21:02] <Eridius> strcat: what's len()?
[00:21:08] <strcat> adding side effects to the pipeline and depending on them is wrong
[00:21:16] <Eridius> and I'm not trying to define side-effects in general
[00:21:21] <Eridius> I'm only concerned with idempotency of .next()
[00:21:33] <strcat> that's not an issue
[00:22:17] <strcat> TreeMap and HashMap don't define how many times they call Eq/Ord implementations which may have side effects
[00:22:34] <strcat> but they do define clear semantics
[00:22:37] <strcat> unrelated to that
[00:23:31] <strcat> I'm perfectly happy doing the same thing as python
[00:23:35] <Eridius> I'm not concerned with what side-effects various implementations may trigger. Eq/Ord really shouldn't have side-effects to begin with
[00:23:48] <Eridius> but sticking side-effects into iterator pipelines is going to be tempting, and people will do it
[00:23:52] <strcat> okay, and things you pass to the iterator pipeline shouldn't have side effects you depend on
[00:24:11] <Eridius> furthermore, people consuming iterators will make the reasonable assumption that once .next() has returned None once, calling .next() again will be idempotent
[00:24:35] <tikue> Eridius: can't you have both
[00:24:47] <Eridius> tikue: both what?
[00:25:07] <tikue> Eridius: both the consistency of knowing None will keep being returned, and idempotence
[00:25:25] <tikue> Eridius: isn't it just up to the iterator implementer to do it properly
[00:25:26] <Eridius> tikue: well yes, if .next() is idempotent once None has been returned, then it must always return None afterwards.
[00:25:29] <strcat> Eridius: so what are you going to do about next() being replaced to call to forward(5) in some cases?
[00:25:41] <strcat> what about len() being special-cased for random-access iterators?
[00:25:45] <Eridius> but every single iterator and iterator adaptor must take care to enforce this, even in the presence of user-supplied closures
[00:25:48] <strcat> instead of calling next() N times, it will just return an integer
[00:25:54] <jeaye> Here's a quick mockup of what I'd like to do: https://gist.github.com/Jeaye/acc12b916dbc58ac3f1d Is it possible (strcat, perhaps)? Right now I'm just stuck on moving the members out of &mut self.
[00:26:18] <engla> strcat: changing whether an iterator is consumed or not is more than a side effect I think
[00:26:22] <Eridius> strcat: what do you mean? I haven't stated any position at all on what would happen if you provided alternatives that have the semantic meaning of calling next() N times without actually doing it
[00:26:25] <joelteon> if I have a hashmap of ~str => ~str, I have to use get(&~"string literal")
[00:26:30] <Eridius> I'm _only_ concerned with the behavior of .next() itself
[00:26:35] <joelteon> that seems like a lot of indirection to me. am I doing it wrong?
[00:26:42] *** Parts: steven_is_false (user@C5B76363.1FF1EBF8.1ECA502.IP) (ERC Version 5.3 (IRC client for Emacs))
[00:26:43] <strcat> Eridius: and I'm talking about next too
[00:26:51] <Eridius> joelteon: check out the *_equiv functions
[00:27:08] <joelteon> where are they?
[00:27:15] <engla> joelteon: .find_equiv exists for this
[00:27:19] <tikue> presumably in std::hashmap
[00:27:22] <Eridius> strcat: if we have a .forward(n: int) function that defaults to calling next() n times, but can be overridden on a concrete implementation (e.g. VecIterator) to do something more efficient
[00:27:26] <Eridius> then I have no problem with that
[00:27:32] <joelteon> oh, ok
[00:27:42] <strcat> Eridius: adaptors don't define how many times they call next()
[00:28:01] <strcat> Eridius: Zip doesn't have to call next() an extra time if the iterator provides an exact length
[00:28:02] <Eridius> strcat: in general that's true, although it's pretty obvious how most of them behave
[00:28:13] <Eridius> but I don't see why you're bringing this up
[00:28:17] <Eridius> because that's not relevant to my position
[00:28:20] <strcat> because it is the same issue
[00:28:31] <joelteon> but there's no get_equiv
[00:28:33] <strcat> your issue is caused by zip
[00:28:37] <Eridius> I am exclusively concerned with idempotency of next(). You keep bringing up ways to avoid calling .next(), and that doesn't matter to me
[00:28:50] <strcat> I don't understand why it matters and other side effects don't
[00:29:17] <strcat> you don't care how many times next() is called, whether or not it's avoided
[00:29:26] <Eridius> strcat: because it's a lot harder to define precise semantics for other mechanisms in the face of side-effects, and it's a lot less likely that someone will make an assumption about it
[00:29:38] <Eridius> however, making an assumption about the behavior of .next() is going to be very common
[00:29:53] <tikue> joelteon: seems like a hole in the methods. just use find_equiv.get()
[00:29:56] <Eridius> and specifically, assuming that once .next() returns None you can keep calling it and keep getting None is going to be quite common
[00:30:02] *** Quits: jyyou (jyyou@moz-47B052FA.cs.nctu.edu.tw) (Input/output error)
[00:30:04] <strcat> Eridius: and I am telling you that next on Zip may or may not call the underlying next implementations
[00:30:11] <Eridius> which goes hand-in-hand with assuming that once it returns None, calling it a second time won't have unexpected consequences
[00:30:20] <Eridius> strcat: why do you keep bringing up Zip? I'm not talking about Zip
[00:30:24] <strcat> yes you are
[00:30:29] <strcat> your issue is caused by zip/chain
[00:30:40] <strcat> it doesn't happen with adaptors recording a bool for this
[00:30:56] <Eridius> strcat: you seem to be assuming that I care whether .next() is called in a scenario where it returns None
[00:31:08] <Eridius> if you can avoid calling .next() and getting None back, because you know the precise bounds, that's fine. I don't care
[00:31:12] <strcat> you care whether the *adaptor* calls next() or not
[00:31:13] <engla> I think chain is fine, it has a flag
[00:31:19] <strcat> engla: not for next_back
[00:31:31] <engla> aha, didn't look there 
[00:31:37] <joelteon> actually, I don't think find_equiv does what I want...I still have to pass a &~str to it
[00:31:42] <Eridius> strcat: users too, not just adaptors
[00:31:51] <Eridius> joelteon: no you pass &str
[00:31:51] <strcat> I don't see how it's relevant to users
[00:31:54] <engla> joelteon: try pass &str
[00:31:54] <Eridius> joelteon: that's the Equiv part
[00:31:56] <joelteon> hmm
[00:31:57] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[00:31:57] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14799f02b to 1418e3db7: 02http://git.io/N3iJvQ
[00:31:57] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[00:31:58] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[00:31:58] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/iq2xnQ
[00:31:58] <ghrust> 13rust/06auto 143c9e393 15Brian Anderson: std::rt: Run local storage cleanup and the box annihilator inside the try/catch...
[00:31:58] <ghrust> 13rust/06auto 1440cab70 15bors: auto merge of #8269 : brson/rust/fix-task-cleanup, r=brson...
[00:31:59] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[00:32:00] <geomyidae> :( have their been syntax changes that chrismorgans http srever isn't updated for?
[00:32:05] <strcat> whether or not zip calls next() in certain cases is relevant to them
[00:32:11] <tikue> joelteon: have you tried?
[00:32:13] <strcat> whether it short circuits
[00:32:21] <Eridius> strcat: because users will call .next(), get None back, and assume that they can call .next() again later and get None back again (and, though they probably didn't think about this, that the second call won't change the state of the world, i.e. won't have side-effects)
[00:32:23] <strcat> whether it continues to call next() after it receives a None from either iterator
[00:32:32] <strcat> it's not a protocol issue, it's a zip issue
[00:32:40] <strcat> zip can choose to take care of it or not
[00:32:40] <geomyidae> foreach is gone?
[00:32:47] <strcat> will be
[00:32:49] <Eridius> so either we need to fix this case such that .next() is idempotent once it returns None, or we need to document that the iterator protocol leaves this undefined
[00:32:56] <strcat> no, we don't
[00:32:59] <geomyidae> I'm using brson/io
[00:33:01] <joelteon> error: mismatched types: expected `&<V11>` but found `&str` (expected &-ptr but found &str)
[00:33:07] <Eridius> strcat: please please PLEASE stop focusing on zip. I don't understand your fixation with it
[00:33:09] <strcat> the iterator protocol doesn't leave this undefined
[00:33:10] <joelteon> is &str not a &-ptr?
[00:33:18] <strcat> Eridius: because it's one of the few adaptors with this issue
[00:33:19] <engla> joelteon: it's not
[00:33:23] <tikue> rusti: use std::hashmap::HashMap; my_map = HashMap::new(); my_map.insert(~"hi", ~"bob"); my_map.find_equiv("hi")
[00:33:24] -rusti- pastebinned 11 lines of output: http://sprunge.us/BVXY
[00:33:35] <tikue> rusti: use std::hashmap::HashMap; let my_map = HashMap::new(); my_map.insert(~"hi", ~"bob"); my_map.find_equiv("hi")
[00:33:36] -rusti- pastebinned 7 lines of output: http://sprunge.us/NEVF
[00:33:51] <tikue> rusti: use std::hashmap::HashMap; let my_map = HashMap::new(); my_map.insert(~"hi", ~"bob"); my_map.find_equiv(~"hi")
[00:33:52] -rusti- pastebinned 7 lines of output: http://sprunge.us/agef
[00:34:22] <tikue> i dunno lol
[00:34:43] <tikue> rusti: use std::hashmap::HashMap; let my_map = HashMap::new(); my_map.insert("hi", "bob"); my_map.find_equiv("hi")
[00:34:44] -rusti- pastebinned 7 lines of output: http://sprunge.us/FFEe
[00:34:53] <joelteon> engla: why did you tell me to pass &str?
[00:34:56] <engla> rusti: use std::hashmap::HashMap; let my_map = HashMap::new(); my_map.insert(~"hi", ~"bob"); my_map.find_equiv(&"hi")
[00:34:57] -rusti- pastebinned 7 lines of output: http://sprunge.us/aQGK
[00:35:47] <sam113101> where's DuplexStream now?
[00:36:45] <engla> joelteon: either way, it's ugly. it's either &~str or & &str
[00:36:57] <joelteon> ok close enough
[00:37:20] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[00:37:45] <engla> but you can pass a slice if you pass it as  find_equiv(& &"hi")
[00:38:11] <tikue> rusti: use std::hashmap::HashMap; let my_map = HashMap::new(); my_map.insert(~"hi", ~"bob"); my_map.find_equiv(&&"hi")
[00:38:11] -rusti- <anon>:5:113: 5:115 error: unexpected token: `&&`
[00:38:11] -rusti- <anon>:5          use std::hashmap::HashMap; let my_map = HashMap::new(); my_map.insert(~"hi", ~"bob"); my_map.find_equiv(&&"hi")
[00:38:11] -rusti-                                                                                                                           ^~
[00:38:12] -rusti- application terminated with error code 101
[00:38:17] <joelteon> heh, I'll just go with &~
[00:38:28] <tikue> rusti: use std::hashmap::HashMap; let my_map = HashMap::new(); my_map.insert(~"hi", ~"bob"); my_map.find_equiv(&~"hi")
[00:38:29] -rusti- pastebinned 19 lines of output: http://sprunge.us/eSiS
[00:38:41] <strcat> Eridius: next() can be well defined as continuing to return None without being disallowed from having side effects
[00:38:42] <tikue> rusti: use std::hashmap::HashMap; let mut my_map = HashMap::new(); my_map.insert(~"hi", ~"bob"); my_map.find_equiv(&~"hi")
[00:38:43] -rusti- pastebinned 16 lines of output: http://sprunge.us/JXDf
[00:38:48] <engla> tikue: the space is needed in & &"hi"   x_x
[00:38:55] <strcat> Eridius: without purity we can't do that
[00:38:59] <tikue> engla: â€¦ah. thanks :) weird
[00:38:59] <strcat> I wouldn't mind tagging this all as pure
[00:39:03] <strcat> if we still had it
[00:39:43] *** Joins: lmandel (lmandel@moz-81980698.dsl.bell.ca)
[00:39:53] <engla> strcat: what do you think about Repeat, do we need RepeatRef to own the value, and have both? I don't like to have all these extra & and * (just look at that find_equiv thing)
[00:40:15] <strcat> you don't need &&"foo" for find_equiv
[00:40:26] <strcat> one of them is eaten
[00:40:38] <strcat> rusti: "foo".cmp(& &"foo")
[00:40:38] -rusti- Equal
[00:40:43] <strcat> rusti: "foo".cmp(& ("foo"))
[00:40:43] -rusti- Equal
[00:40:50] <strcat> rusti: "foo".cmp(& "foo")
[00:40:51] -rusti- <anon>:5:19: 5:26 error: mismatched types: expected `&&str` but found `&str` (expected &-ptr but found &str)
[00:40:51] -rusti- <anon>:5          "foo".cmp(& "foo")
[00:40:51] -rusti-                             ^~~~~~~
[00:40:51] -rusti- error: aborting due to previous error
[00:40:51] -rusti- application terminated with error code 101
[00:40:54] <joelteon> ack
[00:40:55] <engla> right
[00:40:57] <joelteon> where's exit?
[00:41:03] <joelteon> the exit() function, I mean
[00:41:05] <engla> that's & &str
[00:41:35] <strcat> I don't think &"foo" should be the same type as "foo", it's weird
[00:42:45] <tikue> strcat: hm, so you think "foo" should just be &str, and &"foo" would be & &str?
[00:42:55] <strcat> yes
[00:43:02] <kimundi> joelteon: Don't really have one. Let control flow return from main
[00:43:05] <joelteon> ok
[00:43:31] <kimundi> there is os::set_exitâ€¦code() if you need it
[00:43:44] <kimundi> but that won't exit
[00:44:15] <joelteon> wait, so you really can't just exit from within a function?
[00:44:23] <jeaye> return
[00:44:34] <Eridius> strcat: https://gist.github.com/kballard/6148568
[00:44:35] <jeaye> And set state for everything else to return. :P
[00:44:41] <geomyidae> so what should I do instead of foreach?
[00:44:56] <Eridius> strcat: with the definitions in the above gist, you seem to be advocating for #2, which is the worst option IMO
[00:44:59] <jeaye> Here's a quick mockup of what I'd like to do: https://gist.github.com/Jeaye/acc12b916dbc58ac3f1d Is it possible? Right now I'm just stuck on moving the members out of &mut self.
[00:44:59] <joelteon> i feel like that's going to become more and more of an issue as people start writing larger apps
[00:45:11] <strcat> Eridius: can you post it to the mailing list
[00:45:14] <geomyidae> " foreach next_branch in branch.children.mut_iter() { " -> "?"
[00:45:21] <strcat> geomyidae: s/foreach/for/
[00:45:22] <Eridius> strcat: ok
[00:45:30] *** Joins: alisdair (textual@moz-EA60A466.dedicated.allstream.net)
[00:45:33] <jeaye> joelteon: Larger scale apps shouldn't just hard exit all the time, but cleanup state and exit cleanly.
[00:45:33] <tikue> joelteon: servo is ~20,000 lines and hasn't needed exit
[00:45:34] <strcat> geomyidae: it landed
[00:45:54] <strcat> Eridius: I am just not capable of making a decision on it. it all seems pretty bad to me
[00:45:58] <brson> it's always possible to call libc::exit. making the runtime exit cleanly from an arbitrary poitn would be non-trivial
[00:46:03] *** Quits: lmandel (lmandel@moz-81980698.dsl.bell.ca) (Ping timeout)
[00:46:03] <joelteon> ok
[00:46:05] <geomyidae> strcat: I'm guessing I'll have to wait until brson pulls that
[00:46:11] <Eridius> strcat: I'll post it shortly, after I finish updating my PR to reflect the concerns you raised about the tutorial (so I have an accurate PR to demonstrate for #3)
[00:46:23] <brson> geomyidae: pulls what?
[00:46:38] <jeaye> brson: Any idea about my link?
[00:46:45] <geomyidae> idk, the s/foreach/for didn't work, to put it one way
[00:46:45] <doener> github down?
[00:47:15] <jeaye> doener: Not in SF
[00:47:21] <engla> strcat: btw, RepeatRef doesn't really work.. (I think, after 2 minutes of experimenting). The iterator owns the object but we can't give it the correct lifetime in .next()
[00:47:30] <doener> ah, DoS attack
[00:47:34] <strcat> engla: ah
[00:47:50] <strcat> geomyidae: so you're not up-to-date
[00:48:08] <strcat> 'for' is the same as 'foreach' in stage1/stage2
[00:48:19] <strcat> and is about to be the same in stage0 when the snapshot lands
[00:49:18] <brson> jeaye: is it not working?
[00:49:34] *** Quits: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP) (Quit: Konversation terminated!)
[00:50:07] *** Joins: maikklein (maik@moz-835049A2.dip0.t-ipconnect.de)
[00:50:09] <brson> jeaye: it looks reasonable. map_states and visible voxels will need to be Option or Cell
[00:50:19] *** Quits: dim-an (ermolovd@moz-FE167E47.nationalcablenetworks.ru) (Quit: dim-an)
[00:50:20] <brson> so you can move out of them and leave them empty
[00:50:34] *** Joins: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP)
[00:50:38] <jeaye> brson: Errors here https://gist.github.com/Jeaye/acc12b916dbc58ac3f1d
[00:51:18] *** Quits: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP) (Client exited)
[00:51:19] <jeaye> brson: Ohh, I need to make them Option or Cell, eh? I s'pose that makes sense.
[00:52:12] <jeaye> I try that. Thanks. :)
[00:52:45] *** Joins: lmandel (lmandel@279FD858.EFF8FC7B.ADB88A9.IP)
[00:52:55] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[00:52:55] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[00:52:55] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1440cab70 to 1418e3db7: 02http://git.io/N3iJvQ
[00:52:55] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[00:52:58] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[00:52:58] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/cuhq3A
[00:52:58] <ghrust> 13rust/06auto 142f3e171 15Dmitry Ermolov: Additional check in treemap iterator test.
[00:52:58] <ghrust> 13rust/06auto 1460af4fd 15Dmitry Ermolov: Remove redundant print.
[00:52:58] <ghrust> 13rust/06auto 14114f753 15Dmitry Ermolov: Implemented TreeMap::{lower_bound_iter,upper_bound_iter}...
[00:53:00] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[00:53:25] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[00:53:25] *** ChanServ sets mode: +o brson
[00:54:35] *** Joins: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP)
[00:54:55] <engla> bors failed on connection issues
[00:54:58] <geomyidae> So am I wrong to use rustc from stage2 dir?
[00:54:58] * strcat sighs
[00:55:01] <strcat> another conflict
[00:55:18] <engla> (not bors, the builder)
[00:55:20] <strcat> geomyidae: rustc from the stage2 directory has 'for' equivalent to 'foreach'
[00:55:29] <strcat> if it doesn't your build isn't up-to-date
[00:55:57] <geomyidae> interesting, I just pulled all this within the last hour :S
[00:56:42] <strcat> rusti: for x in range(0, 10) { printfln("%d", x) }
[00:56:43] -rusti- <anon>:5:33: 5:41 error: unresolved name `printfln`.
[00:56:43] -rusti- <anon>:5          for x in range(0, 10) { printfln("%d", x) }
[00:56:43] -rusti-                                           ^~~~~~~~
[00:56:43] -rusti- error: aborting due to previous error
[00:56:43] -rusti- application terminated with error code 101
[00:56:46] <strcat> rusti: for x in range(0, 10) { printfln!("%d", x) }
[00:56:47] -rusti- pastebinned 11 lines of output: http://sprunge.us/WcOD
[00:56:52] <strcat> https://github.com/mozilla/rust/commit/b41d04763e97b36f667bf3dc58c991cce781118b
[00:57:02] <strcat> has definitely landed, rusti uses an automated daily build
[00:57:16] <geomyidae> I don't not believe you, but I'm on brson/io, that's why I was wondering if it was merged in that branch, I'm looking at it right now
[00:57:58] <strcat> likely not merged in that
[00:58:04] <strcat> it's in master
[00:59:23] <brson> geomyidae: brson/io is old
[00:59:27] <brson> everything's on master now
[00:59:30] <strcat> hm what happened to bors?
[00:59:32] <brson> i'll delete that branch
[00:59:46] <geomyidae> brson: doh, so instead I should be fixing this code to not use extra::net::url::Url?
[00:59:47] *** Quits: lkuper (lkuper@74941BE4.A402E718.C082B7DC.IP) (Quit: lkuper)
[01:00:16] <brson> geomyidae: I'm not up to speed on what you are doing. Can you remind me?
[01:00:18] <strcat> brson: any idea why run-pass/core-rt-smoke.rs and run-pass/rt-start-main-thread.rs sometimes fail?
[01:00:31] <geomyidae> brson: sorry, I'm just trying to build ChrisMorgan's http server right now.
[01:00:34] * strcat has seen it a few times
[01:00:40] <brson> strcat: probably https://github.com/mozilla/rust/pull/8254
[01:01:04] <geomyidae> brson: I should be on master for that?
[01:01:09] <brson> geomyidae: yes
[01:01:10] <strcat> I'll just merge the vim one, a .vim edit didn't make that mac test fail ;p
[01:01:22] <geomyidae> brson: I see. Good use of my last 20 minutes :)
[01:01:26] <brson> geomyidae: sorry
[01:01:35] <geomyidae> haha, not your fault at all, not what I meant
[01:02:08] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[01:02:08] <ghrust> 01[13rust01] 15thestinger pushed 3 new commits to 06master: 02http://git.io/TBpc3w
[01:02:08] <ghrust> 13rust/06master 1444cb1c3 15Chris Morgan: Highlight sigils and operators in Vim....
[01:02:08] <ghrust> 13rust/06master 14ceb6516 15Chris Morgan: Vim highlighting: remove `foreach` keyword
[01:02:08] <ghrust> 13rust/06master 148ce9533 15Daniel Micay: Merge pull request #8251 from chris-morgan/vim-sigil-highlighting...
[01:02:10] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[01:02:22] <jeaye> brson: So then does my ~[u32] become Option<~[u32]> or ~Option<[u32]> or just Option<[u32]>?
[01:02:45] <brson> jeaye: Option<~[u32]>
[01:02:57] <jeaye> And I send the option through the channel?
[01:03:47] <brson> jeaye: call .take() on it to remove the vector, leaving the option equal to None, then send the vector
[01:03:50] <jeaye> what I don't get then is how to use the field in normal use. Since .get() on the option will move it out anyway, right?
[01:04:06] <jeaye> hmm
[01:04:11] <kimundi> gat_ref
[01:04:15] <brson> or get_mut_ref
[01:04:17] <kimundi> get_ref
[01:04:33] <jeaye> Ah, get_mut_ref was what I wanted.
[01:04:41] <jeaye> Ok, got it.
[01:04:47] <jeaye> Thanks. :)
[01:04:54] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[01:04:54] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1485a01cc to 148ce9533: 02http://git.io/N3iJvQ
[01:04:54] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[01:04:55] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[01:04:56] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/KuIYSQ
[01:04:56] <ghrust> 13rust/06auto 142f3e171 15Dmitry Ermolov: Additional check in treemap iterator test.
[01:04:56] <ghrust> 13rust/06auto 1460af4fd 15Dmitry Ermolov: Remove redundant print.
[01:04:56] <ghrust> 13rust/06auto 14114f753 15Dmitry Ermolov: Implemented TreeMap::{lower_bound_iter,upper_bound_iter}...
[01:04:57] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[01:05:06] <tikue> where is rust.vim stored
[01:05:13] <strcat> src/etc/vim
[01:05:17] <tikue> thx
[01:05:32] <strcat> the dirs need to be dropped in ~/.vim or /usr/share/vim/vimfiles/ (if you use a package manager for it)
[01:06:04] <strcat> ugh I need that to land with the snapshot
[01:06:52] <jeaye> rusti: let o = Some(42); o.take()
[01:06:53] -rusti- <anon>:5:27: 5:28 error: cannot borrow immutable local variable as mutable
[01:06:53] -rusti- <anon>:5          let o = Some(42); o.take()
[01:06:53] -rusti-                                     ^
[01:06:53] -rusti- error: aborting due to previous error
[01:06:53] -rusti- application terminated with error code 101
[01:06:58] <jeaye> rusti: let mut o = Some(42); o.take()
[01:06:59] -rusti- Some(42)
[01:07:07] <kimundi> brson: Btw, I'm preparing an less invasive get -> unwrap PR (unifing the current dual get/unwrap naming on unwrap), would that be ok?
[01:07:11] <jeaye> rusti: let mut o = Some(42); o.take_unwrap()
[01:07:12] -rusti- 42
[01:07:24] <brson> jeaye: oh, didn't realize take returned another Option
[01:07:30] <jeaye> Yeah. :P
[01:07:34] <jeaye> rusti: let mut o = Some(42); (o.take_unwrap(), o)
[01:07:35] -rusti- (42, None)
[01:07:37] *** Quits: doy (doy@moz-5FE28A32.akrasiac.org) (Quit: WeeChat 0.3.8)
[01:07:37] <tikue> should `in` go on the same line as `for` in the rust.vim file
[01:08:42] <tikue> bblum: ^
[01:08:57] *** Joins: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP)
[01:09:49] <brson> kimundi: yes
[01:10:14] <brson> kimundi: in favor of unwrap?
[01:10:21] <strcat> tikue: it's just defining them as keywords so it's okay to have them in any order
[01:10:34] <tikue> strcat: ok thanks
[01:10:35] <brson> i think unwrap is the least controversial atm since that's always been the move out method
[01:10:42] <kimundi> brson: yeah
[01:10:47] <brson> ok
[01:10:54] <strcat> tikue: I just merged the PR updating the vim file for them though
[01:10:57] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[01:10:57] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 149c62fc5 to 148ce9533: 02http://git.io/N3iJvQ
[01:10:57] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[01:10:59] *** Quits: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP) (Ping timeout)
[01:11:00] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[01:11:00] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/C6FZpA
[01:11:00] <ghrust> 13rust/06auto 143c9e393 15Brian Anderson: std::rt: Run local storage cleanup and the box annihilator inside the try/catch...
[01:11:00] <ghrust> 13rust/06auto 14aa53140 15bors: auto merge of #8269 : brson/rust/fix-task-cleanup, r=brson...
[01:11:01] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[01:11:01] <tikue> strcat: oh thank you
[01:11:16] <strcat> github is failing to clone on some bots ;\
[01:11:23] <strcat> going to have to retry them all
[01:12:08] <erickt> kimundi: I also have a get -> unwrap PR in the works...
[01:12:34] <kimundi> erickt: hm
[01:13:00] <erickt> how far along are you on it?
[01:13:14] <kimundi> just finished rustc
[01:13:23] <erickt> ok
[01:13:26] <jeaye> rusti: let a = ~mut [1, 2];
[01:13:28] <kimundi> currently looking for fallout in the tests
[01:13:29] -rusti- pastebinned 7 lines of output: http://sprunge.us/jDJY
[01:13:32] <strcat> 19 PRs with failed tests :|
[01:13:45] <miloshadzic> strcat: I think github is down due to DoS https://status.github.com/messages?cache=burst
[01:14:19] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[01:14:24] <jeaye> brson: Within my closure, the ~[] is mutated, but that errors on cannot borrow immutable captured outer variable as mutable
[01:15:21] <erickt> kimundi: I can push my code up somewhere
[01:15:43] <jeaye> From extra::comm::DuplexStream<(~[u32], ~[u32]), (~[u32], ~[u32])>, is there something I'm supposed to specify to make them mutable?
[01:15:51] <brson> jeaye: yeah, that's a pain atm. captures are always immutable. what you can do here is put the vector in a Cell (which is internally mutable) then, in the closure, call vec_cell.take() to move the vector into a mutable local, then mutate it
[01:16:05] <brson> mutable captures are coming eventually
[01:16:19] <kimundi> erickt: how far arlong are you?
[01:16:41] <jeaye> brson: So I want a Cell and not Option, or a Option<Cell<~[u32]>>?
[01:16:55] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[01:16:55] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14aa53140 to 148ce9533: 02http://git.io/N3iJvQ
[01:16:55] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[01:16:56] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[01:16:56] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/0CzIzw
[01:16:56] <ghrust> 13rust/06auto 149f74217 15Daniel Micay: register snapshots
[01:16:56] <ghrust> 13rust/06auto 141bac560 15Daniel Micay: remove obsolete `foreach` keyword...
[01:16:56] <ghrust> 13rust/06auto 142f1527f 15bors: auto merge of #8264 : thestinger/rust/snapshot, r=huonw
[01:16:58] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[01:18:29] *** Joins: doy (doy@moz-AB28F0A5.members.linode.com)
[01:18:37] <Eridius> strcat: ok, email sent
[01:19:03] *** Joins: pcwalton (pcwalton@moz-481A040C.hsd1.ca.comcast.net)
[01:19:03] *** ChanServ sets mode: +o pcwalton
[01:19:33] <brson> jeaye: use an Option for the struct field and just use the Cell for moving things into closures, like `let vec_cell = Cell(vec); do spawn { let mut vec = vec_cell.take(); ... }`
[01:19:48] <brson> that's almost the only thing Cell is used for - writing that exact pattern
[01:20:36] <brson> 8Cell::new(vec)
[01:20:39] <brson> **
[01:21:40] *** Quits: goffrie (goffrie@moz-E9EC021C.dsl.ncf.ca) (Quit: Lost terminal)
[01:22:54] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[01:22:54] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 142f1527f to 148ce9533: 02http://git.io/N3iJvQ
[01:22:54] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[01:22:56] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[01:22:56] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/r-xJ1Q
[01:22:56] <ghrust> 13rust/06auto 140504d7e 15blake2-ppc: std: Speed up str::is_utf8...
[01:22:56] <ghrust> 13rust/06auto 14c669223 15bors: auto merge of #8237 : blake2-ppc/rust/faster-utf8, r=brson...
[01:22:57] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[01:24:33] <engla> next PR to the slaughter
[01:24:51] *** Quits: alisdair (textual@moz-EA60A466.dedicated.allstream.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[01:27:12] <joelteon> can I break out of loop?
[01:27:29] <strcat> 'break' and 'loop' work in loop/for
[01:27:31] <strcat> and while
[01:27:41] *** Quits: doener (doener@moz-121949B3.unitymediagroup.de) (Ping timeout)
[01:28:56] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[01:28:56] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14c669223 to 148ce9533: 02http://git.io/N3iJvQ
[01:28:56] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[01:29:41] <erickt> kimundi: the latest is https://github.com/erickt/rust/tree/result-map4
[01:30:37] <engla> rust even has labeled breaks/loops
[01:30:40] <engla> though I've never used it
[01:31:13] <erickt> kimundi: It's part of a request that changed map to consume self, which I was changing to add a map_move
[01:31:20] <erickt> kimundi: so I haven't pushed it up yet
[01:31:25] *** Quits: vosen (vosen@moz-266BA656.icpnet.pl) (Quit: Leaving)
[01:31:52] <kimundi> erickt: thx
[01:32:22] *** Quits: vk (chatzilla@moz-389FEE13.hsd1.ca.comcast.net) (Ping timeout)
[01:32:35] <jeaye> brson: Alright, kickass. Thanks!
[01:32:49] *** Joins: vk (chatzilla@moz-389FEE13.hsd1.ca.comcast.net)
[01:33:23] <joelteon> does rust have exceptions?
[01:34:19] <kimundi> erickt: wait, you're also adding get -> &T ?
[01:34:57] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[01:34:57] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 141f90c7f to 148ce9533: 02http://git.io/N3iJvQ
[01:34:57] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[01:34:58] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[01:34:58] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/EAStvQ
[01:34:58] <ghrust> 13rust/06auto 143c9e393 15Brian Anderson: std::rt: Run local storage cleanup and the box annihilator inside the try/catch...
[01:34:58] <ghrust> 13rust/06auto 14971062a 15bors: auto merge of #8269 : brson/rust/fix-task-cleanup, r=brson...
[01:34:59] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[01:35:05] <erickt> kimundi: yeah. I was in the middle of reviving an old branch
[01:35:12] <kimundi> hmm
[01:35:30] <Eridius> joelteon: no, but it does have task failure
[01:35:36] <erickt> kimundi: I hadn't decided what to do with the branch yet
[01:35:40] *** Quits: lmandel (lmandel@279FD858.EFF8FC7B.ADB88A9.IP) (Quit: lmandel)
[01:36:42] <kimundi> erickt: right now I'm rooving anything in result, option, either that is get() and replace it with pure moving unwrap(). for refering, I'm keeping get_ref() right now
[01:37:17] <erickt> kimundi: sounds fine to me for now
[01:38:35] <erickt> kimundi: rooving?
[01:38:41] <joelteon> Eridius: how do I fail inside a task?
[01:38:42] <kimundi> removing
[01:38:46] <Eridius> joelteon: fail!() is a good way
[01:38:53] <joelteon> maybe so
[01:38:53] <erickt> kimundi: ok
[01:40:55] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[01:40:56] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14971062a to 148ce9533: 02http://git.io/N3iJvQ
[01:40:56] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[01:40:57] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[01:40:57] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/Ms8XMA
[01:40:57] <ghrust> 13rust/06auto 149f74217 15Daniel Micay: register snapshots
[01:40:57] <ghrust> 13rust/06auto 141bac560 15Daniel Micay: remove obsolete `foreach` keyword...
[01:40:57] <ghrust> 13rust/06auto 140e30e4f 15bors: auto merge of #8264 : thestinger/rust/snapshot, r=huonw
[01:40:59] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[01:46:50] <pcwalton> brson: your removal of PlatformThread broke SDL and I think the simplest way to get it back is to have an attribute that makes Rust omit main() entirely
[01:46:56] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[01:46:56] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 140e30e4f to 148ce9533: 02http://git.io/N3iJvQ
[01:46:56] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[01:46:57] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[01:46:58] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/edBfVQ
[01:46:58] <ghrust> 13rust/06auto 149f74217 15Daniel Micay: register snapshots
[01:46:58] <ghrust> 13rust/06auto 141bac560 15Daniel Micay: remove obsolete `foreach` keyword...
[01:46:58] <ghrust> 13rust/06auto 143afee7b 15bors: auto merge of #8264 : thestinger/rust/snapshot, r=huonw
[01:46:59] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[01:47:00] <pcwalton> would you be OK with a patch that does that? I have a patch that does this
[01:47:47] <brson> pcwalton: we have an attribute that does that, called #[start]
[01:47:58] <pcwalton> it still generates main() though
[01:48:01] <pcwalton> from the disasm
[01:48:15] <brson> pcwalton: what do you mean? there has to be an entrypoint of some kind
[01:48:33] <pcwalton> that's the problem here... the way SDL works is that it places main() in a library
[01:48:35] <pcwalton> libSDLmain.a
[01:48:46] <pcwalton> I have horrible hacks that route around this but I would like to stop doing it
[01:48:57] <pcwalton> so I need to rename rust's main() to SDL_main
[01:49:10] <pcwalton> (SDL normally does this with CPP macros)
[01:49:36] <pcwalton> I was thinking I could just write rust's main() in rust
[01:49:37] <aatch> pcwalton, fwiw, there is a similar problem with android, so it might be possible to kill two birds with one stone.
[01:49:58] <brson> this is pretty beside the point about PlatformThread. None of this is going to make it possible to get a task onto the main thread
[01:50:11] <pcwalton> brson: well, here's what it did before
[01:50:43] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[01:50:46] <pcwalton> the rust-sdl makefiles pull apart libSDLmain.a, rename the main symbol to SDLX_main, and then reassemble the library
[01:50:50] <pcwalton> and then rust starts
[01:50:55] <pcwalton> it immediately switches to the platform thread
[01:51:00] <pcwalton> and then calls SDLX_main
[01:51:07] <pcwalton> rust-sdl exposes an SDL_main symbol
[01:51:12] <pcwalton> which SDLX_main calls
[01:51:17] <pcwalton> and then it jumps to rust main()
[01:51:19] <pcwalton> this is all horrible
[01:51:27] <pcwalton> and removing PlatformThread broke the dance
[01:51:44] <brson> how does SDL (god-damn SDL) expect this to work
[01:51:46] <brson> this is so brain-dead
[01:52:01] <brson> how can main be in a library?
[01:52:07] <pcwalton> ld accepts it :)
[01:52:28] <aatch> it's the framework vs library problem.
[01:52:52] <SiegeLord> It's an OSX problem... this hackery is necessary because of it :P
[01:52:55] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[01:52:55] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/V7Taow
[01:52:55] <ghrust> 13rust/06auto 149046516 15Stepan Koltsov: Rename IpAddr -> SocketAddr, extract IpAddr from SocketAddr...
[01:52:55] <ghrust> 13rust/06auto 14935f285 15bors: auto merge of #8243 : stepancheg/rust/ipv, r=brson...
[01:52:56] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[01:53:02] <pcwalton> SiegeLord: actually it's not really
[01:53:14] <SiegeLord> It is in Allegro which uses a similar trick
[01:53:15] <pcwalton> there is a way to keep real main() in the application on OS X
[01:53:19] <pcwalton> which is what GLUT uses
[01:53:20] <brson> so it expects is to create an executable without an entry point, but to export a function called 'SDL_main'. then the linker will magically run 'main' from the library, at which point it calls our 'main'?
[01:53:22] <pcwalton> and GLFW
[01:53:23] <SiegeLord> The trick is only necessary on OXS
[01:53:40] <pcwalton> it's just that the trick is kind of hairy and involves underdocumented APIs to make the resulting app feel right
[01:53:49] <pcwalton> so it's not surprising that SDL and Allegro don't do it
[01:54:08] <pcwalton> brson: right.
[01:54:38] <brson> pcwalton: so at that point, once we're running SDL_main are we free to start the runtime by calling std::rt::start?
[01:54:41] <pcwalton> yes
[01:55:00] <pcwalton> although I'll try not to in sprocketnes just because sprocketnes has no need for the rust runtime (it uses pthreads)
[01:55:15] <pcwalton> but yes I believe std::rt::start would be fine to call after SDL_main
[01:55:26] <SiegeLord> That's interesting... I wasn't aware of any workabout
[01:55:38] <pcwalton> SiegeLord: yeah, look at GLFW's code
[01:55:44] <pcwalton> or the open source GLUT.framework code
[01:56:00] <SiegeLord> Wonder if it also works on iOS
[01:56:12] <pcwalton> dunno
[01:56:18] <SiegeLord> What I'd like from the runtime is the ability to attach to existing threads
[01:56:35] <SiegeLord> So you could spawn a platform thread and then register it with the runtime
[01:56:50] <brson> pcwalton: what's your proposal?
[01:57:06] <pcwalton> brson: well, what I was going to try is to have a #[no_main]; crate level attribute which makes Rust not emit any entry point at all
[01:57:15] <pcwalton> coupled with #[no_mangle] this would allow us to make an SDL_main written in rust
[01:57:23] <pcwalton> which then starts the runtime if it wants
[01:58:02] <brson> ok, the problem you are going to run into here is that main currently has magic in it to pass the crate_map to `start`, and the runtime really would like to have that crate map. I think there's an issue open to address this
[01:58:11] <brson> basically I think we should have a crate_map!() macro
[01:58:19] <pcwalton> is the crate_map a C level global?
[01:58:32] <pcwalton> we can access those
[01:58:34] <brson> pcwalton: it's a static variable emitted by trans into every crate
[01:58:55] <pcwalton> oh, it has internal linkage?
[01:58:56] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[01:58:56] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14935f285 to 148ce9533: 02http://git.io/N3iJvQ
[01:58:56] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[01:58:56] <brson> the language doesn't have any visibility into the crate map currently
[01:58:58] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[01:58:58] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/ti1Uiw
[01:58:58] <ghrust> 13rust/06auto 149f74217 15Daniel Micay: register snapshots
[01:58:58] <ghrust> 13rust/06auto 141bac560 15Daniel Micay: remove obsolete `foreach` keyword...
[01:58:58] <ghrust> 13rust/06auto 14ad403b9 15bors: auto merge of #8264 : thestinger/rust/snapshot, r=huonw
[01:58:59] <brson> it's trans magic
[01:59:00] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[01:59:13] <brson> every binary and every lib has a crate map
[01:59:20] <brson> and main just has a pointer to it
[01:59:38] <pcwalton> how does it find the library crate maps?
[02:00:08] <brson> i believe they are exported and have a known name
[02:00:17] <brson> so maybe an extern const could find the local one ...
[02:00:28] <brson> like __rust_crate_map or something
[02:00:47] <brson> although, those would collide if they were exported
[02:00:53] <brson> maybe their name is in the metadata
[02:01:11] <bjz> pcwalton: so 'as' binds tighter now?
[02:02:07] <brson> pcwalton: though still none of this makes PlatformThread work again, unless you opt-in to the new runtime by calling std::rt::start_on_main_thread
[02:02:56] <pcwalton> bjz: one level tighter, yes
[02:03:17] <bjz> pcwalton: awesome - that makes more sense
[02:03:44] <pcwalton> brson: I'm confused, if each library has a crate map but main only passes in one crate map, how does the runtime find the library crate maps?
[02:03:54] <brson> pcwalton: they form a tree
[02:04:07] <pcwalton> oh, so all you really need is the executable crate map
[02:04:09] <brson> yes
[02:04:16] <pcwalton> since there is only one executable could we make that have a known name?
[02:04:23] <pcwalton> with C linkage
[02:04:35] <pcwalton> then we could just stick it in an extern "C" { ... } block on the Rust side
[02:04:38] <pcwalton> and then off we go
[02:05:01] <bblum> tikue: just alphabetize it
[02:05:40] <brson> pcwalton: possibly, yes. the code in trans is in decl_crate_map. it mangles the crate map with library metadata. in the exe case we could give it an obvious name
[02:05:40] *** Quits: thomaslee (thomaslee@moz-306D3DF4.hsd1.or.comcast.net) (Connection reset by peer)
[02:05:50] <pcwalton> let me try
[02:05:52] *** Joins: thomaslee (thomaslee@moz-306D3DF4.hsd1.or.comcast.net)
[02:06:10] <brson> oh, actually, it already does this
[02:06:17] <brson> _rust_crate_map_toplevel
[02:06:19] <pcwalton> yeah, it's called _rus...right
[02:06:22] <bjz> pcwalton: btw, re: glfw smooth scrolling, it was fixed recently
[02:06:23] <pcwalton> cool
[02:06:26] <pcwalton> bjz: yay!
[02:06:59] <bjz> pcwalton: https://github.com/glfw/glfw/pull/95 https://github.com/glfw/glfw/pull/102
[02:07:05] <brson> would be great if this works and we can get rid of #[start] and the before-main stub that rustc emits
[02:07:15] <bjz> pcwalton: still needs to filter down to servo though
[02:07:49] <brson> still probably want to put it behind a macro - setting up an extern is pretty clunky
[02:07:52] <cmr> http://seld.be/rustdoc/master/std/u64/generated/enum.Range.html
[02:07:55] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[02:07:55] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14ad403b9 to 148ce9533: 02http://git.io/N3iJvQ
[02:07:55] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[02:07:57] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[02:07:57] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/169Mqw
[02:07:57] <ghrust> 13rust/06auto 149f74217 15Daniel Micay: register snapshots
[02:07:57] <ghrust> 13rust/06auto 141bac560 15Daniel Micay: remove obsolete `foreach` keyword...
[02:07:57] <ghrust> 13rust/06auto 14b67bf6d 15bors: auto merge of #8264 : thestinger/rust/snapshot, r=huonw
[02:07:58] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[02:08:00] <cmr> rustdoc_ng works just fine with macro-generated code!
[02:08:04] * cmr happy
[02:08:31] <bjz> :)
[02:09:02] <SiegeLord> You know... for all the desire not to duplicate github functionality, you guys still will have to make a source code viewer for the sake of the code examples :P
[02:09:26] *** Joins: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP)
[02:09:58] <acrichto> cmr: nice!
[02:10:01] <cmr> not my frontend, I delegate that job ;P
[02:10:09] <bjz> pcwalton: so how does all this affect glfw? seeing as it is more 'libby' it would be awesome if the fix would be less 'invasive'. but I have no idea about any of the details on this RT stuff
[02:10:11] <cmr> Besides we can shell out to pygments for that
[02:10:24] <pcwalton> bjz: about the main stuff? it shouldn't affect glfw
[02:10:34] <pcwalton> unless you're using PlatformThread
[02:10:43] <bjz> pcwalton: I am using PlatformThread
[02:10:46] <strcat> SiegeLord: hm?
[02:10:57] <pcwalton> bjz: you'll have to start the runtime then
[02:11:06] <SiegeLord> strcat: It was re rustdoc
[02:11:09] <pcwalton> define main() yourself and start GLFW, which starts the runtime
[02:11:20] *** Quits: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP) (Ping timeout)
[02:11:43] * strcat wonders why it's the same 3 bots with the connection error each time
[02:11:53] <brson> strcat: which bots?
[02:12:00] <bjz> pcwalton: what is the advantage of structuring the rt like this?
[02:12:10] <pcwalton> bjz: it allows runtimeless operation far more easily
[02:12:17] <pcwalton> and makes rust more embeddable
[02:12:31] <pcwalton> you could for example start the runtime from a C app
[02:12:35] <bjz> pcwalton: would there also be a way of allowing folks to do there own runtime start up with glfw?
[02:12:37] <strcat> brson: bsd, linux-32-nopt, win32-opt - I guess they might be running on different slaves though...
[02:12:41] <pcwalton> yes
[02:12:49] <pcwalton> that's what I'm doing with SDL, if you want the runtime start it yourself...
[02:12:53] <pcwalton> sprocketnes doesn't
[02:13:04] <pcwalton> it's easy to start the runtime, std::rt::start
[02:13:13] <bjz> pcwalton: ok
[02:13:22] <strcat> brson: nope always linux1
[02:13:33] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[02:13:33] *** ChanServ sets mode: +o dherman
[02:13:56] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[02:13:56] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14b67bf6d to 148ce9533: 02http://git.io/N3iJvQ
[02:13:56] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[02:13:58] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[02:13:58] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/qqbRgQ
[02:13:58] <ghrust> 13rust/06auto 149f74217 15Daniel Micay: register snapshots
[02:13:58] <ghrust> 13rust/06auto 141bac560 15Daniel Micay: remove obsolete `foreach` keyword...
[02:13:58] <ghrust> 13rust/06auto 1449c006f 15bors: auto merge of #8264 : thestinger/rust/snapshot, r=huonw
[02:14:00] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[02:14:10] <strcat> fatal: read error: Connection reset by peer
[02:14:12] <strcat> ;\
[02:14:16] <bjz> pcwalton: jack was also sujjesting I move to this: https://gist.github.com/metajack/5982180
[02:14:33] <engla> strcat: I get that locally here too, but only sometimes
[02:14:50] <bjz> pcwalton: not sure how that fits in with the new design
[02:14:50] <engla> the probability of all buildbots getting a connection to github is low
[02:14:58] <strcat> but it's the same few failing
[02:15:04] <strcat> the others making it to configure
[02:15:14] <strcat> through configure*
[02:15:41] <cmr> r? https://github.com/mozilla/rust/pull/8278
[02:15:43] <pcwalton> bjz: so ultimately there is this problem that has always been true with any graphics/windowing system bindings for Rust
[02:16:04] <pcwalton> namely, that the windowing system wants its own event loop, which is a problem because the scheduler also wants an event loop
[02:16:11] <bjz> hehe
[02:16:13] <pcwalton> this is a problem when you have to for example select on a pipe and windowing events simultaneously
[02:16:29] <pcwalton> the ultimate goal here is to have the event loop abstraction of the scheduler to be pluggable
[02:16:38] <pcwalton> so that GLFW could have a scheduler backend, and SDL could too
[02:17:16] *** Quits: maikklein (maik@moz-835049A2.dip0.t-ipconnect.de) (Ping timeout)
[02:17:19] <pcwalton> until then if you want to support this use case (selecting on a pipe and reading messages) what you need to do is to have an adapter that changes pipe messages into native event loop messages
[02:17:24] <pcwalton> I looked into this for GLFW
[02:17:30] <kimundi> erick: Gotta go now, could you hold of on making a PR for your opton::get changes for at least the next day?
[02:17:42] <pcwalton> I don't think there is a cross platform way to push messages into GLFW's queue from another thread, which is what you want
[02:17:53] <bjz> mm
[02:18:55] <bjz> pcwalton: could that be fixed on the glfw end? or would it be  pretty invasive change?
[02:19:57] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[02:19:57] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1449c006f to 148ce9533: 02http://git.io/N3iJvQ
[02:19:57] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[02:20:00] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[02:20:00] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/XdGuUw
[02:20:00] <ghrust> 13rust/06auto 149f74217 15Daniel Micay: register snapshots
[02:20:00] <ghrust> 13rust/06auto 141bac560 15Daniel Micay: remove obsolete `foreach` keyword...
[02:20:00] <ghrust> 13rust/06auto 14afa4899 15bors: auto merge of #8264 : thestinger/rust/snapshot, r=huonw
[02:20:02] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[02:20:07] <pcwalton> you have to get the HWND and shove messages into the queue
[02:20:15] <pcwalton> bjz: I think it would be easy, they just have to add an API to allow that to happen
[02:21:05] <bjz> pcwalton: could certainly have a chat to them, or open up an issue
[02:21:32] <SiegeLord> So I'm curious... can you force a new thread for a new task with the current/new runtime?
[02:21:57] <pcwalton> SiegeLord: yes in both
[02:22:32] <SiegeLord> Ok, good
[02:22:56] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[02:22:56] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14afa4899 to 148ce9533: 02http://git.io/N3iJvQ
[02:22:56] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[02:22:57] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[02:22:57] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/NYK1CQ
[02:22:57] <ghrust> 13rust/06auto 149f74217 15Daniel Micay: register snapshots
[02:22:57] <ghrust> 13rust/06auto 141bac560 15Daniel Micay: remove obsolete `foreach` keyword...
[02:22:57] <ghrust> 13rust/06auto 143816aae 15bors: auto merge of #8264 : thestinger/rust/snapshot, r=huonw
[02:22:59] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[02:23:06] <bjz> pcwalton: I just wouldn't know what I'd be asking for :P
[02:23:34] <pcwalton> bjz: ability to send messages to the GLFW event loop from another thread
[02:23:40] <pcwalton> custom messages
[02:24:24] <pcwalton> it would still mean that the GLFW thread itself would not have full access to the Rust runtime
[02:24:42] <pcwalton> but it could fully integrate with *other* Rust threads
[02:25:46] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[02:26:07] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[02:26:38] <bjz> pcwalton: so is that something for glfw-rs or glfw itself?
[02:26:54] <pcwalton> GLFW itself
[02:27:12] <bjz> I'm asking on #glfw
[02:27:13] <pcwalton> to be clear, GLFW needs nothing unless you want to select on a Rust pipe
[02:27:17] <pcwalton> from the GLFW thread
[02:27:30] <pcwalton> but this is important if you want GLFW to interoperate with other threads
[02:27:34] <pcwalton> this isn't a Rust problem per se even
[02:27:51] <pcwalton> this is just "I have another thread, I want it to talk to the GLFW thread without having the GLFW thread spin and burn CPU"
[02:27:54] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[02:28:19] <bjz> pcwalton: I asked, "dreda_: is it possible to send custom messages to the GLFW event loop from another thread?"
[02:28:33] <pcwalton> if there's a current way to do it then I'm all ears :)
[02:28:45] <pcwalton> yeah, that's the question I have
[02:29:03] <bjz> would it have to be a big api?
[02:29:09] <pcwalton> nah, I was thinking something small
[02:29:13] <bjz> cool
[02:29:14] <pcwalton> glfw is callback based right?
[02:29:18] <bjz> yeah
[02:29:23] <pcwalton> glfwCustomEventFunc(my_callback)
[02:29:33] <pcwalton> my_callback has signature void customEventFunc(void *cookie)
[02:29:39] <pcwalton> and then glfwSendCustomEvent(void *cookie)
[02:29:41] <pcwalton> that's all I need
[02:30:12] <pcwalton> glfwSendCustomEvent can be called from any thread and calls glfwCustomEventFunc on the main thread with the cookie parameter
[02:30:22] *** kimundi is now known as zz_kimundi
[02:30:35] <pcwalton> err, calls my_callback
[02:30:41] <pcwalton> whatever callback was registered with glfwCustomEventFunc
[02:30:45] <bjz> dreda is usually very responsive, if this is something you want, maybe you should post an issue
[02:30:53] <pcwalton> yeah, I should do that
[02:30:59] <bjz> might be better than me garbling it
[02:31:21] <pcwalton> now if we wanted full rust scheduler integration we would probably need file descriptor support or something
[02:31:30] <pcwalton> which would be a big API and possibly out of scope of GLFW
[02:31:39] <pcwalton> perhaps this custom event func solution is the best for upstream GLFW
[02:31:47] <bjz> probably. glfw is meant to be small
[02:31:58] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[02:31:58] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 143816aae to 148ce9533: 02http://git.io/N3iJvQ
[02:31:58] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[02:32:00] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[02:32:00] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/8os1cQ
[02:32:00] <ghrust> 13rust/06auto 148f9c172 15Brian Anderson: Suppress a libuv leak on mac...
[02:32:00] <ghrust> 13rust/06auto 1432ac535 15bors: auto merge of #8254 : brson/rust/libuv-mac-supp, r=pcwalton...
[02:32:00] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[02:32:02] <pcwalton> it means that the GLFW thread will never be a full Rust scheduler thread
[02:32:06] <pcwalton> but this is possibly fine
[02:32:21] <pcwalton> if we design the API right this won't be too annoying
[02:32:25] <pcwalton> I/O will be slower in GLFW apps but usually they aren't I/O bound anyway
[02:32:48] <pcwalton> I should say, I/O will be slower if you aren't aware of this in GLFW apps
[02:32:59] <pcwalton> it won't affect Servo because the GLFW thread does no I/O anyhow
[02:33:06] *** Quits: thomaslee (thomaslee@moz-306D3DF4.hsd1.or.comcast.net) (Connection reset by peer)
[02:33:07] <bjz> pcwalton: yep. ultimately for it to be a plausible addition to glfw it should be small and non-invasive
[02:33:19] <bjz> libby
[02:33:56] <pcwalton> this would help Servo a lot, as currently Servo burns CPU
[02:34:04] <bjz> awesome
[02:34:13] <pcwalton> since it has to select on a Rust pipe from the renderer thread while it's still processing compositor events
[02:35:03] <sfackler> is there an as_c_str_array function anywhere? this is the only way I could think of doing it, and it's awful and doesn't compile: https://gist.github.com/sfackler/be5e005ff8e6d134b72d
[02:36:25] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[02:37:57] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[02:37:57] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1432ac535 to 148ce9533: 02http://git.io/N3iJvQ
[02:37:57] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[02:38:00] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[02:38:00] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/-6DinQ
[02:38:00] <ghrust> 13rust/06auto 14c1ad16d 15OGINO Masanori: Fix building problems in extra::unicode....
[02:38:00] <ghrust> 13rust/06auto 14a6825e3 15bors: auto merge of #8260 : omasanori/rust/fix-extra-unicode, r=pcwalton...
[02:38:01] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[02:38:11] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[02:43:05] <pcwalton> brson: does "fatal runtime error: runtime tls key not initialized" mean that I tried to do something that needs the runtime without setting it up?
[02:43:22] *** Quits: zz_kimundi (kimundi@moz-3109E9F9.dip0.t-ipconnect.de) (Ping timeout)
[02:43:57] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[02:43:57] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14a6825e3 to 148ce9533: 02http://git.io/N3iJvQ
[02:43:57] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[02:44:56] *** Joins: thomaslee (thomaslee@moz-306D3DF4.hsd1.or.comcast.net)
[02:45:27] <Luqman> pcwalton: newrt? you might have forgotten RUST_NEWRT=1
[02:45:37] <pcwalton> Luqman: nah, I'm doing very magical things here :)
[02:45:37] <brson> pcwalton: yes
[02:45:40] <pcwalton> brson: ok
[02:45:45] <pcwalton> yeah, I asked for os::args
[02:45:46] <pcwalton> bad me
[02:45:46] <sam113101> what's the point of borrowed pointers, really? is it just to accept both @ and ~ arguments in functions?
[02:45:47] <pcwalton> fixing
[02:45:53] <cmr> sam113101: No
[02:45:57] <pcwalton> sam113101: also stack values
[02:46:12] <strcat> they are references, otherwise you would pass by-value
[02:46:13] <cmr> sam113101: It's for not taking ownership, having a memory-safe reference to something
[02:46:32] *** Joins: zz_kimundi (kimundi@moz-2E255F2E.dip0.t-ipconnect.de)
[02:46:33] <aatch> sam113101, it's to allow for lifetime-bounded references to data. That can be statically checked
[02:47:01] *** zz_kimundi is now known as kimundi
[02:48:31] <pcwalton> sfackler: I'm not a huge fan of the callback-based approach
[02:48:43] <pcwalton> just return *c_char IMHO
[02:48:45] <pcwalton> it's unsafe
[02:49:07] <cmr> pcwalton: just because it's unsafe doesn't mean you should make it easier to misuse, imo
[02:49:16] <pcwalton> yeah, but I hate the rightward drift
[02:49:18] <strcat> it's not easier to misuse, it's just annoying because closures are a pain
[02:49:27] <cmr> yeah
[02:50:05] <brson> still hunting down bugs in SingleThreaded :-/
[02:50:30] <strcat> 50 pull requests :|
[02:50:37] <pcwalton> yay, sprocketnes is runtimeless!
[02:50:53] <pcwalton> also compiles about 10x faster than before
[02:51:06] <strcat> pcwalton: is the take glue issue fixed now?
[02:51:11] <pcwalton> strcat: looks like it
[02:51:19] <pcwalton> LLVM passes take 2 s rather than 60 :)
[02:52:11] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[02:52:11] <ghrust> 01[13rust01] 15thestinger 04force-pushed 06try from 1455fcf79 to 141008945: 02http://git.io/k471pw
[02:52:11] <ghrust> 13rust/06try 149f74217 15Daniel Micay: register snapshots
[02:52:11] <ghrust> 13rust/06try 141008945 15Daniel Micay: remove obsolete `foreach` keyword...
[02:52:11] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[02:52:20] <sfackler> pcwalton: returning the *c_char is the clearer way to do it, but it'll break horribly if the string isn't null terminated, and i'd prefer to avoid relying on the current behavior
[02:52:59] <pcwalton> oh I see, so you have to reallocate, blah
[02:53:10] <strcat> or push \0
[02:53:13] <pcwalton> maybe a tuple of a unique blob and then pointers into that blob?
[02:53:19] *** Quits: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net) (Quit: tikue)
[02:53:26] <pcwalton> in general we should have a discussion about how to combat rightward drift with string interop
[02:53:34] <pcwalton> and unnecessary closureification
[02:53:40] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[02:53:53] <strcat> I think you should just push \0 or put an explicit \0 in a constant, and then s.to_ptr()
[02:54:00] <strcat> and that's all it needs to be
[02:54:57] <sfackler> that'd work, yeah
[02:55:26] <pcwalton> runtimeless sprocketnes makes me inordinately happy for some reason
[02:55:29] <sfackler> would it be worth adding to std::str or std::str::raw? it seems to be a decently common thing in C interop
[02:55:43] <pcwalton> if we had static linking and then dead code stripping there would presumably be no runtime at all in the resulting binary
[02:55:46] <sam113101> I wonder if there are things impossible to do without managed pointers?
[02:55:50] <strcat> sfackler: well you can already push it in safe code, and to_ptr exists afaik
[02:56:00] <pcwalton> sam113101: there are things impossible to do without managed pointers or unsafe code
[02:56:04] <pcwalton> for example, doubly linked lists
[02:56:06] <cmr> sam113101: cyclical data structures
[02:56:16] *** Joins: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net)
[02:56:26] <pcwalton> but basically all large C programs use reference counting too so I don't see that as a big concern
[02:56:43] <pcwalton> reference counting is a tried and true method, it's not evil, it's just not the first thing you should reach for
[02:58:09] * brson dinner
[02:58:40] *** Quits: barosl (barosl@E287D94F.C81E10FB.7544CABF.IP) (Quit: ëžœë¤ì€ ì‡ í‡´í–ˆìŠµë‹ˆë‹¤.)
[02:59:19] <sfackler> strcat: being forced to take a mut array is a bit of a bummer though
[03:00:16] <strcat> avoid C strings? ;p
[03:00:28] *** Quits: lahwran (lahwran@lahwran.net) (Ping timeout)
[03:00:34] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[03:00:38] *** Joins: maikklein (maik@moz-835049A2.dip0.t-ipconnect.de)
[03:01:21] *** Joins: lahwran (lahwran@lahwran.net)
[03:01:42] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[03:02:00] <sfackler> avoid C libraries isn't a super reasonable option :P
[03:02:07] <strcat> not 'avoid C libraries'
[03:02:23] <strcat> C string implies not unicode
[03:02:29] <strcat> only thing really using them are file paths
[03:02:39] <strcat> and Path can enforce that guarantee as part of the type
[03:02:48] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[03:03:24] <cmr> rusti: ~[1, 2, 3]
[03:03:26] *** Joins: dew (Instantbir@moz-8A63B53.dhcp.stls.mo.charter.com)
[03:03:28] -rusti- ~[1, 2, 3]
[03:03:33] <strcat> well, not *all* unicode
[03:03:34] <cmr> rusti: ~([1, 2, 3])
[03:03:34] -rusti- ~[1, 2, 3]
[03:03:35] <strcat> it can be a subset ;p
[03:03:37] <shachaf> s
[03:03:39] <shachaf> Er.
[03:05:24] <pcwalton> sprocketnes is 122k stripped
[03:05:43] <cmr> nice!
[03:06:24] <pcwalton> nothing that big in the result
[03:06:29] <pcwalton> biggest function is
[03:06:37] <pcwalton> 14K __ZN3cpu14__extensions__9step_611416_3c2e8b5f06127637_0
[03:06:39] <pcwalton> but that's expected
[03:07:35] <erickt> pcwalton: (skimming over the history) are you using SDL 1.2 or 1.3? I thought 1.3 supported not owning main
[03:07:44] <pcwalton> oh, interesting
[03:07:47] <pcwalton> I'm probably using 1.2
[03:08:05] <pcwalton> cpu::step is just the deeply optimized CPU interpreter loop
[03:08:12] <pcwalton> which is nice and compact and all inlines into one function
[03:08:39] <erickt> pcwalton: also, have you considered sfml? I've never used it, but I've heard rather good things about it.
[03:08:50] <strcat> that's C++
[03:09:02] <erickt> strcat: they have C bindings
[03:09:15] <pcwalton> the core dispatch-and-jump is 11 instructions
[03:09:20] <pcwalton> decode-and-dispatch rather
[03:09:23] <sam113101> if I do let crayons = [0, 2]; is its size fixed or not?
[03:09:37] <erickt> sam113101: fixed
[03:09:38] <cmr> sam113101: fixed size
[03:09:53] *** Joins: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP)
[03:10:03] <mihneadb> is there no continue statement in rust?
[03:10:09] <sp3d> "loop"
[03:10:28] <mihneadb> sp3d: with the quotes?
[03:10:30] <sam113101> what about let crayons = ~[0, 2]; ?
[03:10:30] <pcwalton> for some reason it's doing "cmp al,0xff; jmp label;" instead of folding that into the jump table
[03:10:43] <cmr> sam113101: dynamically expanding vector
[03:10:44] <pcwalton> sam113101: that's heap allocated, so not fixed size
[03:10:48] <sp3d> mihneadb: without
[03:10:52] <pcwalton> ~ means "heap allocate"
[03:10:55] <pcwalton> it's like "new"
[03:11:02] <mihneadb> sp3d: but that's the loop forever stament. does it have two purposes?
[03:11:06] <cmr> mihneadb: yes
[03:11:09] <sp3d> yes, a few keywords in rust do
[03:11:10] <mihneadb> wait what..
[03:11:17] <mihneadb> wow
[03:11:17] <mihneadb> ok
[03:11:26] <erickt> pcwalton / strcat: ooh neat, we already have a rust binding to sfml: https://github.com/JeremyLetang/rust-sfml
[03:11:27] <mihneadb> what's the reason?
[03:11:31] <mihneadb> sp3d: cmr^
[03:11:34] <pcwalton> saves a keyword
[03:11:36] <cmr> mihneadb: it's short and doesn't need another keyword
[03:11:45] <sp3d> e.g. "in" is being considered to do both "for foo in bar" and "x in y" as placement new
[03:11:53] <mihneadb> hm, is adding a keyword that complicated? :S
[03:11:58] *** Quits: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP) (Ping timeout)
[03:12:02] <strcat> it reserves a word
[03:12:06] <cmr> it's not complicated, it's just another ident that no program can ever use
[03:12:07] <sam113101> if IÂ do let crayons: ~[int, ..3] = ~[0, 1, 2]; is it fixed?
[03:12:16] <strcat> sam113101: won't compile
[03:12:29] <strcat> ~[0, 1, 2] is ~[int], that's a dynamic array
[03:12:31] <sam113101> strcat: why? what does the ..3 do actually?
[03:12:36] <mihneadb> cmr: strcat: everybody started programming in something other than rust. I am pretty sure they will not try using continue as an identifier
[03:12:41] <mihneadb> but ok, thanks for explaining
[03:12:51] <strcat> sam113101: it's the type, it says it's a fixed size array of 3 ints in a unique box
[03:13:35] <cmr> mihneadb: I don't personally agree it, it's just the way it is
[03:13:39] <strcat> but ~[0, 1, 2] is a dynamic array
[03:13:41] <mihneadb> cmr: right
[03:13:56] <strcat> ~([1, 2, 3]) is a fixed-size array
[03:13:59] <sam113101> it HAS to be on the stack in order to be fixed?
[03:14:03] <strcat> sam113101: no
[03:14:10] <strcat> it's a value, it can be put anywhere
[03:14:27] <strcat> [int, ..3] is a fixed-size array, ~[int] is a dynamic array
[03:15:01] <strcat> one is a big value, the other is a pointer to a dynamically sized block of memory
[03:16:03] <sp3d> how hard would it be to implement a type! that returns a string representation of the type of its argument? (or does something like that exist?)
[03:16:12] <cmr> sp3d: impossible
[03:16:18] <sp3d> with compiler help?
[03:16:18] <cmr> macros run way before typechecking
[03:16:23] <jeaye> Does Rust have a flat set?
[03:16:32] <strcat> jeaye: flat?
[03:16:39] <cmr> syntax extensions in general, not just macros
[03:16:47] <sp3d> mm
[03:16:58] <jeaye> Not a tree, but contiguous. like boost::flat_set or boost::flat_map
[03:17:09] <sp3d> I'm just trying to think how rusti might be able to implement a :t operation
[03:17:31] <sp3d> maybe rustc could have a "type-annotate all/some expressions" pretty-print mode?
[03:17:33] <cmr> sp3d: compile the program, analyze the outputted crate
[03:17:39] <sp3d> ah
[03:17:52] <jeaye> strcat: flat_set is similar to std::set but it's implemented like an ordered vector.
[03:17:56] <cmr> rustdoc_ng basically does exactly this
[03:18:03] <cmr> minus some of the pretty printing
[03:18:04] <sp3d> alright, cool
[03:20:45] *** Quits: thomaslee (thomaslee@moz-306D3DF4.hsd1.or.comcast.net) (Connection reset by peer)
[03:21:53] *** Joins: jyyou (jyyou@moz-F09996FC.hinet-ip.hinet.net)
[03:22:03] <jeaye> Is there a Rustic way to kill a task blocked on a recv when the app is closing?
[03:22:22] <engla> jeaye: smallintmap is a flat map, but only with integer keys
[03:22:37] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[03:23:59] <jeaye> Yeah, just lookin' for a flat set. No worries if it's not there yet. :)
[03:24:22] <sfackler> BitvSet is one for uint
[03:24:39] <jeaye> For arbitrary types, ideally.
[03:28:41] *** Quits: pcwalton (pcwalton@moz-481A040C.hsd1.ca.comcast.net) (Quit: pcwalton)
[03:29:47] <maikklein> has anyone here some experience with machine learning/ neural networks and can recommend me a good book?
[03:30:22] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Connection reset by peer)
[03:31:13] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[03:31:16] <vk> Hey, I'm trying to update an out of date project as a learning project and wondering what does this error means: "error: mismatched types: expected `~std::io::Reader:Send` but found `@std::io::Reader:'static` (trait storage differs: expected ~ but found @)". It errors on this code: " Ok(rdr) => self.compile_reader(rdr),".  Tried to update this line "fn compile_reader(rdr: io::Reader) ->...
[03:31:18] <vk> ...Template {" to this "fn compile_reader(&self, rdr: ~Reader) -> Template {".
[03:32:22] <mihneadb> are you not allowed to define something (i.e. "let x = 3") inside a block? i.e. inside a loop {} 
[03:32:39] <cmr> mihneadb: you are
[03:32:41] <mihneadb> oh. nvm, in is a keyword
[03:32:46] <mihneadb> I was doing let in
[03:32:51] <mihneadb> haha
[03:32:57] <mihneadb> in rust for rubyists there's a "in" variable
[03:33:02] <mihneadb> but the new rust has in as a keyword
[03:33:06] <mihneadb> cmr: thanks
[03:33:42] <cmr> RfR is written for 0.6
[03:33:46] <mihneadb> yes, it is
[03:34:01] <mihneadb> not complaining
[03:35:31] <aatch> Grrr, stupid C++ patterns not having a decent Rust equivalent.
[03:35:33] <dbaupp> vk: `rdr: @Reader`
[03:36:42] <vk> dbaupp: got this now: "error: mismatched types: expected `~std::io::Reader:Send` but found `@~std::io::Reader:Send` (expected trait std::io::Reader but found @-ptr)"
[03:36:44] <maikklein> aatch, for example?
[03:37:03] <aatch> specifically the `template <typename T> class Klass : T { ... }` pattern.
[03:37:15] <dbaupp> vk: code?
[03:37:37] <maikklein> okay that I don't know :)
[03:37:52] <dbaupp> rusti: trait Foo<T: A> : A { }
[03:37:53] <vk> dbaupp: https://github.com/vkorapaty/rust-mustache/blob/0.8pre-update/mustache.rc, line 74
[03:37:54] -rusti- pastebinned 8 lines of output: http://sprunge.us/XIYE
[03:38:57] <vk> got similar errors on lines 97, 104, 111, 131, and 148, basically where rdr shows up. Should probably reread the tutorial section on generics, didn't sink in the first time.
[03:39:07] *** Quits: aatch (aatch@moz-2BB0AC01.cable.telstraclear.net) (Ping timeout)
[03:39:07] <maikklein> vk, we don't use .rc anymore
[03:39:15] <dbaupp> vk: you need to change the definition of the CompileContext struct too
[03:39:25] <jeaye> Can I kill a task from outside of it?
[03:39:25] *** Joins: aatch (aatch@moz-2BB0AC01.cable.telstraclear.net)
[03:39:33] <cmr> jeaye: nope
[03:39:42] <cmr> not without linked failure, at least
[03:40:03] <jeaye> So I have to send it something to get it to cleanly exit?
[03:40:11] <cmr> yes
[03:40:11] <maikklein> cmr, can't you just send sth and then execute a kill function?
[03:40:20] <cmr> maikklein: that's not killing from the outside though
[03:40:28] <vk> dbaupp: tutorial still mentions .rc in the crates section, was curious about that. Change CompileContext how?
[03:41:15] *** Joins: thomaslee (thomaslee@moz-306D3DF4.hsd1.or.comcast.net)
[03:43:14] <maikklein> do we only use the in keyword with the for expression like for x in v?
[03:43:25] <maikklein> or does it has other usecases aswell?
[03:43:48] <aatch> maikklein, it's planned for allocation expressions.
[03:44:12] <aatch> so `let a = <expr> in <location_expression>` or something like that.
[03:44:32] <maikklein> ok
[03:44:40] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[03:44:57] <sam113101> my brain is going to explode
[03:45:30] <jmgrosen> hey, because a friend is asking: how do tasks compare to WebWorkers?
[03:45:34] <maikklein> sam113101, whats the problem?
[03:45:57] <sam113101> nothing, rust is the first compiled language IÂ learn
[03:46:00] <cmr> jmgrosen: they are similarly shared-nothing
[03:46:06] <cmr> sam113101: yeah, it's a lot of details :(
[03:46:16] <cmr> jmgrosen: using message passing
[03:46:58] <jmgrosen> cmr, disregarding speed of native-ness, how would, e.g., using tasks in rust compare to webworkers in node?
[03:47:05] <sam113101> hopefully IÂ will become good at it
[03:47:51] *** Quits: thomaslee (thomaslee@moz-306D3DF4.hsd1.or.comcast.net) (Client exited)
[03:48:23] *** Quits: boredomist (user@moz-63CF9F31.res-cmts.sesp.ptd.net) (Ping timeout)
[03:48:41] <cmr> jmgrosen: should map cleanly 1:1, besides the fact that some rust objects aren't sendable, and we have capability for a much richer communication model than webworkers do (I think.. chans/ports etc are all library concepts and flexible, rather than the specifically mandated webworker api)
[03:49:30] *** Joins: goffrie (goffrie@moz-E9EC021C.dsl.ncf.ca)
[03:55:06] <mihneadb> is there a way to see the type of an expression in rusti?
[03:55:19] <cmr> mihneadb: not yet
[03:55:38] <mihneadb> cmr: ok
[03:55:55] <mihneadb> cmr: when I do "hello"[0] in rusti I get back a number
[03:55:59] <mihneadb> the ascii value of h
[03:56:03] <mihneadb> is that type int?
[03:56:05] *** Joins: chmanchester (chmanchest@moz-BE33DA21.fw1.sfo1.mozilla.net)
[03:56:15] <cmr> u8 I think
[03:56:27] <cmr> string indexing is bytewise
[03:56:30] <mihneadb> cmr: u8 as in uint8?
[03:56:40] <mihneadb> I see 'h' is accepted by rusti
[03:56:44] <mihneadb> so it knows about chars
[03:56:45] <dbaupp> vk: I don't know how you need to change it; but the error seems to be about mismatched types with `rdr`.
[03:56:48] <cmr> u8 as in u8
[03:56:50] <jmgrosen> mihneadb, it's a char, not a u8
[03:56:58] <strcat> a char is a unicode code point
[03:57:03] <aatch> yes, indexing a string gets you a `u8` type, (an 8-bit unsigned integer)
[03:57:05] <strcat> strings are utf-8
[03:57:17] <strcat> hm
[03:57:24] <mihneadb> so..
[03:57:26] <strcat> I can't tell if expr_fn_block is just to support the old `for`
[03:57:36] <jmgrosen> aatch, really?
[03:57:41] <cmr> jmgrosen: really
[03:57:42] <aatch> rusti: (std::sys::size_of::<u8>(), std::sys::size_of::<char>())
[03:57:43] -rusti- (1, 4)
[03:57:46] <cmr> it's unfortunate imo
[03:57:51] <mihneadb> if strings are utf-8 and chars are unicode code points, why does indexing a string gives back an 8 bit int?
[03:57:53] <cmr> but it is what you want most of the time
[03:57:57] <strcat> guess it's not
[03:58:16] <strcat> mihneadb: they're utf-8, and they return you the byte in the utf-8 representation
[03:58:16] <jmgrosen> rusti: "Ã¼"[0]
[03:58:16] <cmr> mihneadb: because codepoints aren't that useful and they're O(n) to index by
[03:58:17] -rusti- 195
[03:58:17] <aatch> jmgrosen, it's utf-8, so an index that returned 'char' would be O(n)
[03:58:36] <strcat> char_at
[03:58:41] <mihneadb> aha, ok
[03:58:45] <aatch> Which is unlike every other indexing operation.
[03:58:46] <strcat> char_at is kinda weird though
[03:58:47] <mihneadb> rusti: "hello".char_at(0)
[03:58:48] -rusti- 'h'
[03:58:55] <engla> there is no method to do char indexing
[03:59:02] <dbaupp> strcat: what aboud do for expr_fn_block? (/me doesn't actually no.)
[03:59:08] <jmgrosen> aatch, yeah, but that's a big enough reason to disregard other languages with foreign characters?
[03:59:13] <dbaupp> engla: you can use .iter().nth(x)
[03:59:20] <strcat> jmgrosen: nothing to do with that
[03:59:22] <engla> dbaupp: that's nice.
[03:59:25] <dbaupp> jmgrosen: we don't
[03:59:32] <strcat> jmgrosen: code points != actual visible characters
[03:59:39] <mihneadb> dbaupp: isn't that a lot of work to do char indexing?
[03:59:46] <dbaupp> jmgrosen: just having a surprise O(n) operation is bad
[04:00:00] <jmgrosen> dbaupp, hm, tough decision, i suppose
[04:00:03] <strcat> a visible character can be N code points
[04:00:16] <dbaupp> mihneadb: it is(/should be) rare to actually index by codepoints
[04:00:21] <strcat> there's almost no use in code points for an application - they are useful for a library to implement high-level unicode support
[04:00:38] <aatch> jmgrosen, the issue is that people will do stuff like while i < len { string[i] } (Look ma, O(n^2))
[04:00:54] <mihneadb> dbaupp: so then if I have an ascii string and wat to check against a character (i.e. == 'x'), the idiomatic way is to use .char_at?
[04:01:06] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Ping timeout)
[04:01:07] <cmr> mihneadb: the idiomatic way is to use Ascii, not str
[04:01:08] <strcat> aatch: and also because it's not the unit you want anyway
[04:01:17] <cmr> str is explicitly unicode
[04:01:20] <dbaupp> mihneadb: depends what you're doing
[04:01:22] <mihneadb> cmr: is Ascii a different type?
[04:01:22] <jmgrosen> aatch, yeah, i suppose, it just makes me feel a little bad is all
[04:01:25] <cmr> mihneadb: yes
[04:01:26] <mihneadb> cmr: is it in the docs?
[04:01:29] <dbaupp> mihneadb: (char_at takes a byte offset.)
[04:01:34] <strcat> jmgrosen: what use are code points for an application?
[04:01:35] <mihneadb> oh
[04:01:44] <aatch> jmgrosen, I know, I went through all this with D when I was over there.
[04:01:51] <strcat> jmgrosen: they don't tell you string length, visible characters, and so on
[04:02:02] <cmr> mihneadb: std::str::ascii is the module
[04:02:08] <mihneadb> cmr: thank you
[04:02:20] <mihneadb> I guess I was expecting something like in python. i.e. "str" is ascii, u"str" is unicode
[04:02:22] <jmgrosen> non-english is quite a hard problem >.<
[04:02:23] <mihneadb> (different literals)
[04:02:23] <aatch> It gets confusing because there's byte-length, character-length, codepoint-length and grapheme length.
[04:02:36] <vk> dbaupp: appreciate the help, I'll figure something out.
[04:02:52] <cmr> mihneadb: we do have byte string literals
[04:02:54] <cmr> kinda...
[04:02:59] <cmr> rusti: bytes!("foo")
[04:02:59] -rusti- &[102, 111, 111]
[04:03:05] <cmr> rusti: bytes!("foo", true, 123)
[04:03:05] -rusti- <anon>:5:9: 6:5 error: Unsupported literal in bytes!
[04:03:05] -rusti- <anon>:5          bytes!("foo", true, 123)
[04:03:05] -rusti- <anon>:6     };
[04:03:06] -rusti- error: aborting due to previous error
[04:03:06] -rusti- application terminated with error code 101
[04:03:09] <cmr> aw no bools
[04:03:13] <cmr> rusti: bytes!("foo", 123)
[04:03:14] -rusti- &[102, 111, 111, 123]
[04:03:15] <aatch> rusti: bytes!(123)
[04:03:16] -rusti- &[123]
[04:03:29] <aatch> rusti: bytes!(123456)
[04:03:29] -rusti- <anon>:5:9: 6:5 error: Too large integer literal in bytes!
[04:03:29] <sp3d> rusti: bytes!(true as u8)
[04:03:29] -rusti- <anon>:5          bytes!(123456)
[04:03:29] -rusti- <anon>:6     };
[04:03:29] -rusti- error: aborting due to previous error
[04:03:30] -rusti- application terminated with error code 101
[04:03:30] -rusti- <anon>:5:9: 6:5 error: Non-literal in bytes!
[04:03:31] -rusti- <anon>:5          bytes!(true as u8)
[04:03:33] -rusti- <anon>:6     };
[04:03:35] -rusti- error: aborting due to previous error
[04:03:35] *** concrete.mozilla.org sets mode: +M 
[04:03:37] -rusti- application terminated with error code 101
[04:03:38] <strcat> jmgrosen: http://ix.io/739 4 single-width characters, 93 code points, 182 bytes
[04:03:39] <aatch> :(
[04:03:44] <strcat> but there's no upper bound
[04:03:57] *** Joins: tautologico (shung@74BFD9C3.5A3A7952.7B974E06.IP)
[04:03:58] <strcat> and double-width characters exist
[04:04:02] <bjz> rusti: bytes!(3.14)
[04:04:03] -rusti- <anon>:5:9: 6:5 error: Unsupported literal in bytes!
[04:04:03] -rusti- <anon>:5          bytes!(3.14)
[04:04:03] -rusti- <anon>:6     };
[04:04:03] -rusti- error: aborting due to previous error
[04:04:03] -rusti- application terminated with error code 101
[04:04:11] <mihneadb> I can't find any docs on how to use str::ascii
[04:04:39] <mihneadb> oh
[04:04:41] <mihneadb> it's std::ascii
[04:04:44] <mihneadb> http://static.rust-lang.org/doc/std/ascii.html
[04:04:50] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[04:04:53] <cmr> oh sorry :(
[04:05:01] <cmr> it's str/ascii.rs in the source, I assumed
[04:05:06] <mihneadb> so..
[04:05:12] <mihneadb> how do I use it if we have no literals
[04:05:14] <mihneadb> feels kind of awkward
[04:05:43] <mihneadb> AsciiStr is a trait
[04:05:45] <mihneadb> who implements it?
[04:06:11] <aatch> mihneadb, regular strings, i believe.
[04:06:31] <aatch> basically it just has a bunch of checks to ensure that it is, in fact, ascii.
[04:06:39] <mihneadb> so it's slow
[04:06:39] <mihneadb> ?
[04:06:42] <cmr> &[Ascii] and ~[Ascii] do
[04:06:50] <cmr> Well, just &[Ascii]
[04:07:04] <cmr> aatch: nope
[04:07:31] <aatch> Oh right. 
[04:07:46] <mihneadb> cmr: let me come up with a concrete example. I want to count the frequencies of the chars in a string. I know it's an ascii string.
[04:07:52] <mihneadb> what's the idiomatic way?
[04:08:05] *** brson sets mode: -M 
[04:08:13] *** Joins: hjr3 (hradtke@moz-842BF853.hsd1.ca.comcast.net)
[04:08:19] <aatch> mihneadb, will it always be a ascii string/does it have to be an ascii string?
[04:08:42] <mihneadb> aatch: sure
[04:08:43] <cmr> rusti: "foo".to_ascii()
[04:08:44] -rusti- &[{chr: 102}, {chr: 111}, {chr: 111}]
[04:08:54] <cmr> rusti: "fâ˜ƒoo".to_ascii()
[04:08:55] -rusti- rust: task failed at 'assertion failed: self.is_ascii()', /build/rust-git/src/rust/src/libstd/str/ascii.rs:107
[04:08:55] -rusti- rust: domain main @0x1970100 root task failed
[04:08:55] -rusti- application terminated with error code 101
[04:08:57] <strcat> counting characters isn't a simple problem if you want to support unicode
[04:09:11] <mihneadb> strcat: what about if it's ascii only?
[04:09:27] <mihneadb> is the idiomatic way to use asciistring.iter() ?
[04:09:43] <strcat> if you're explicitly not support unicode then use Ascii
[04:10:26] *** Joins: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP)
[04:10:26] <mihneadb> strcat: I don't know how to make an ascii str
[04:10:27] <aatch> mihneadb, `for char in input_str.to_ascii().iter() { ... }`
[04:10:35] <mihneadb> aha
[04:10:35] <mihneadb> ok
[04:10:41] <mihneadb> thanks
[04:10:52] <aatch> to_ascii will fail if it's not ascii though.
[04:10:59] <mihneadb> right
[04:11:01] <mihneadb> but
[04:11:07] <mihneadb> isn't this extra transformation costly?
[04:11:18] <cmr> it's not as cheap as not doing it
[04:11:22] <cmr> but it's not really a transformation
[04:11:36] <cmr> it checks that it's an ascii string and then does an unsafe cast
[04:11:40] <mihneadb> rusti: for char in "hello" { printfln!("%?", char) }
[04:11:41] -rusti- <anon>:5:9: 6:5 error: type `&mut &'static str` does not implement any method in scope named `next`
[04:11:41] -rusti- <anon>:5          for char in "hello" { printfln!("%?", char) }
[04:11:41] -rusti- <anon>:6     };
[04:11:41] -rusti- error: aborting due to previous error
[04:11:42] -rusti- application terminated with error code 101
[04:11:46] <cmr> no copies etc
[04:11:47] <mihneadb> rusti: for char in "hello".iter() { printfln!("%?", char) }
[04:11:48] -rusti- pastebinned 6 lines of output: http://sprunge.us/SFJE
[04:11:53] <strcat> either you can operate on u8 and u8 vectors or use Ascii, if you really do want only ascii support
[04:12:06] <strcat> if you use u8, you're on your own when it comes to checking if it's valid
[04:12:14] <mihneadb> strcat: you mean valid ascii
[04:12:17] <aatch> It really should be renamed to `as_ascii` to be idiomatic.
[04:12:28] *** Quits: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP) (Ping timeout)
[04:12:46] <cmr> aatch: well the method is fn to_ascii(&self) -> T
[04:12:51] <cmr> it's just how it's implement on &str
[04:13:11] <aatch> cmr, true.
[04:13:50] <aatch> stupid dynamically sized types
[04:14:09] *** Joins: pcwalton (pcwalton@moz-481A040C.hsd1.ca.comcast.net)
[04:14:09] *** ChanServ sets mode: +o pcwalton
[04:14:14] <mihneadb> yeah
[04:14:24] <mihneadb> any plans for map literals?
[04:14:36] <aatch> mihneadb, nope
[04:14:39] <cmr> no but it can be implemented with macros
[04:14:49] <cmr> (and has been, by erickt I think)
[04:15:04] <aatch> cmr, bjz also did a good one.
[04:15:13] <sp3d> cmr: would that defer the construction to runtime or perform the logic in the macro expansion?
[04:15:14] <tautologico> does rust have exit() ?
[04:15:16] <mihneadb> ok, thanks
[04:15:21] <cmr> sp3d: macro expansion
[04:15:24] <bjz> ?
[04:15:27] <sp3d> fancy
[04:15:52] <aatch> tautologico, what do you want it for?
[04:15:54] *** Quits: pcwalton (pcwalton@moz-481A040C.hsd1.ca.comcast.net) (Quit: .)
[04:16:05] <bjz> aatch: ?
[04:16:06] <tautologico> to exit early from a program
[04:16:20] <aatch> bjz, was it you that did a map literal macro?
[04:16:21] <cmr> tautologico: no, that operation isn't safe
[04:16:32] <bjz> aatch: oh yeah
[04:16:45] <tautologico> cmr: I seeâ€¦ I was thinking about C/C++
[04:16:51] <aatch> tautologico, no. as cmr said, it's unsafe. You can use fail!() to cause an unwind.
[04:16:58] <cmr> It's not safe in C/C++ either
[04:17:04] <tautologico> I know
[04:17:09] <strcat> cmr: it's not 'unsafe'
[04:17:11] <strcat> to exit early
[04:17:20] <tautologico> but lots of stuff are not safe in C/C++ :)
[04:17:21] <strcat> by rust's view of what unsafe means
[04:17:37] <cmr> strcat: it causes tasks to terminate without unwinding and at arbitrary points in their execution
[04:17:43] <strcat> so does going out-of-memory
[04:17:48] <strcat> it's not unsafe
[04:17:55] <cmr> what's the proper word?
[04:18:01] <strcat> unidiomatic
[04:18:05] <strcat> bad practice?
[04:18:05] <aatch> "bad"
[04:18:20] <strcat> hardcoding an exit in a task, bringing down the whole process without running destructors
[04:18:20] <cmr> I think unsafe is the correct word for it
[04:18:24] <strcat> cmr: it's not unsafe.
[04:18:25] <erickt> cmr: map literals? I haven't worked on it
[04:18:33] <cmr> erickt: maybe it was just bjz's then
[04:18:51] <strcat> rusti: ~[0, ..10000000];
[04:18:52] -rusti- ()
[04:18:54] <strcat> rusti: ~[0, ..100000000];
[04:18:54] -rusti- application terminated abnormally with signal 9 (Killed)
[04:18:57] <strcat> is that unsafe?
[04:19:02] <strcat> because if exit is, allocating memory is
[04:19:02] <cmr> no, that's just buggy :p
[04:19:07] <strcat> so why is exit unsafe?
[04:19:33] <cmr> Early program termination in any instance is unsafe
[04:19:36] <strcat> it's not
[04:19:39] <cmr> why?
[04:19:42] <mihneadb> I m trying to instantiate a hashmap
[04:19:44] <mihneadb> an empty one
[04:19:47] <mihneadb> can't seem to do it
[04:19:49] <mihneadb> any help please
[04:19:51] <strcat> cmr: because it's totally safe to exit at any time
[04:19:51] <cmr> mihneadb: HashMap::new()
[04:19:56] <sp3d> what does safety actually guarantee?
[04:19:58] <strcat> it's not insecure, it won't corrupt memory
[04:20:06] <aatch> cmr, in rust terminology, safety refers to memory safety.
[04:20:22] <mihneadb> cmr: I thought that's called automatically when you do something like HashMap { } ?
[04:20:25] <cmr> mihneadb: no
[04:20:27] <strcat> exiting can't be viewed as unsafe or dynamic memory allocation at all is unsafe
[04:20:33] <strcat> it doesn't make sense to view it that way
[04:20:42] <cmr> improper, how about that?
[04:20:48] <strcat> sure
[04:20:51] <engla> it would be nice if rust did fail!() on malloc failure
[04:20:56] <aatch> So dereferencing a bad pointer, accessing memory after it's been freed, concurrent writes to data, inconsistent state.
[04:21:00] <strcat> aatch: fail!() allocates
[04:21:02] <strcat> engla: *
[04:21:04] <cmr> engla: destructors can allocate
[04:21:06] <aatch> engla, but fail!() allocates.
[04:21:06] <strcat> as do segmented stacks
[04:21:25] <strcat> rust's I/O allocates too so you couldn't report an error
[04:21:35] <engla> I'm sure they allocate less than ~[0, ..100000000]
[04:21:53] <bjz> aatch: https://gist.github.com/bjz/821a6d00b2ef6d5450e7
[04:21:56] <engla> well, what Rust does today doesn't matter, it can be fixed
[04:21:57] <aatch> engla, but you don't know how much memory you _do_ have in an OOM situation.
[04:22:15] <strcat> engla: it can't be fixed retroactively
[04:22:27] * aatch is going to stop before we repeat the same discussion from a few weeks ago
[04:22:28] <cmr> Disallowing destructors to allocate would be very restrictive
[04:22:42] <cmr> it could be expressed with bblum's effect system though
[04:22:49] <aatch> All of the bikeshedding!
[04:22:50] <strcat> it's essentially a guideline for C++ libraries to not allocate in destructors themselves
[04:23:03] <strcat> or they can't handle out-of-memory
[04:23:11] <strcat> not that anyone cares enough about handling OOM to implement it properly
[04:23:18] <cmr> except lua
[04:23:23] <engla> you can't seriously call such a difficult issue a bikeshed
[04:23:46] <enix> Is there any rule against left shifting by a negative value?
[04:23:55] <aatch> engla, no, but it always decends into a bikeshed.
[04:24:04] <mihneadb> cmr: is there a way to pass in <int, int> to the new function to avoid a long line like "rusti> let x: hashmap::HashMap<int, int> = hashmap::HashMap::new();" ?
[04:24:15] <cmr> mihneadb: you don't need the type hint
[04:24:17] <cmr> it will be infered
[04:24:21] <engla> I don't think so, that's not what it means
[04:24:22] <mihneadb> tried
[04:24:29] <mihneadb> cmr: did not work without it
[04:24:34] <aatch> engla, it's complicated, most people don't understand the issue well enough to have an informed opinion (like myself) so they glom onto smaller things
[04:24:36] <cmr> well, it failed in rusti because rusti kinda sucks
[04:24:38] <mihneadb> https://gist.github.com/anonymous/e4e806a917500b7625ba
[04:24:40] <mihneadb> cmr: ^
[04:24:52] <mihneadb> oh lol
[04:25:08] <mihneadb> cmr: but how does it know what I'll put in the hashmap? 
[04:25:17] <cmr> mihneadb: Hindley-Milner type inference
[04:25:24] <cmr> (aka, magic, at least to me)
[04:25:34] <mihneadb> cmr: wait so it changes the type later?
[04:25:36] <strcat> mihneadb: no
[04:25:41] <cmr> It doesn't change the type
[04:25:43] <strcat> if you use the type in a way that tells it the type, it knows the type
[04:25:51] <strcat> it doesn't just look at the right-hand side expression
[04:25:59] <cmr> And if it's ambiguous it's a compile failure
[04:26:02] <mihneadb> oh so you run H-M at compile tyme
[04:26:08] <mihneadb> ok
[04:26:09] <mihneadb> got it
[04:26:14] <mihneadb> cool!
[04:26:20] <strcat> rusti: let mut xs = ~[];
[04:26:21] -rusti- <anon>:5:17: 5:25 error: cannot determine a type for this local variable: unconstrained type
[04:26:21] -rusti- <anon>:5          let mut xs = ~[];
[04:26:21] -rusti-                           ^~~~~~~~
[04:26:21] -rusti- error: aborting due to previous error
[04:26:21] -rusti- application terminated with error code 101
[04:26:24] <strcat> rusti: let mut xs = ~[]; xs.push(5);
[04:26:25] -rusti- ()
[04:26:38] <joelteon> is task.try sync or async?
[04:26:39] <bjz> mihneadb: http://en.wikipedia.org/wiki/Hindley-Milner
[04:26:45] <aatch> cmr, it's actually pretty simple. Collect all the type constraints, look at the types that match the contraints, if you have 1, good, if you have 0, contradiction, if you have > 1, ambiguity
[04:26:56] <mihneadb> bjz: thanks :) I read about it when I was studying scala
[04:27:00] <mihneadb> just didn't know you guys used it
[04:27:08] * strcat is *actually* removing for loops from the compiler now
[04:27:14] <cmr> aatch: that is pretty simple!
[04:27:23] <joelteon> i see that spawn and spawn_with don't return anything
[04:27:25] <aatch> (so something like `a : int` has a constraint of `= int`)
[04:27:32] <strcat> they are well hidden
[04:27:34] <joelteon> so is try like spawn but also returns the result of the task?
[04:27:38] <strcat> the support code
[04:27:39] <aatch> and only `int` can match it.
[04:27:42] <bjz> mihneadb: <3 HM
[04:27:46] <cmr> joelteon: It waits for the task to fail or return a result
[04:27:53] <cmr> joelteon: ie, synchronous, but yielding
[04:28:04] <joelteon> uh, ok
[04:28:20] <joelteon> can I create a task and get a future back?
[04:28:31] <cmr> dunno, ask olsonjeffery
[04:28:40] <cmr> there might not be a high level wrapper for that
[04:28:44] <cmr> but it's possible
[04:28:44] <joelteon> hi olsonjeffery 
[04:28:54] <cmr> I know there's a Future type in extra
[04:29:03] <aatch> We also use a modified version for region inference, that handles intersections and stuff though, so it's more complicated/
[04:29:55] <bjz> mihneadb: https://github.com/mozilla/rust/blob/master/src/librustc/middle/typeck/infer/doc.rs
[04:30:15] <mihneadb> bjz: thanks
[04:30:17] <enix> are shifts by negative values legal? If they are, I think i've found a compiler bug, but I don't want to open an issue for it if they aren't legal to begin with
[04:30:33] <mihneadb> bjz: will read. I only know about its usage in haskell
[04:30:37] <cmr> enix: isn't a shift by a negative value a shift in the opposite direction?
[04:30:50] <aatch> enix, yes and no. I'm pretty sure shift is on uint
[04:30:59] *** Joins: Havvy (Havvy@moz-4FE57F72.hsd1.wa.comcast.net)
[04:31:07] <aatch> rusti: 8 << -1
[04:31:07] -rusti- 0
[04:31:17] <aatch> rusti: 8 << (-1i)
[04:31:17] <strcat> it's not undefined behaviour
[04:31:17] -rusti- 0
[04:31:23] <strcat> but the result is unspecified
[04:31:25] <enix> cmr: I don't really know. StackOverflow says it just uses the bottom 5 bits. regardless, depending on the optimization level and #[inline], i'm getting different results
[04:31:33] <strcat> I think it's not necessarily zero
[04:31:54] <Havvy> brson: Re: Directory named ~ (See the QDB), I ended up doing the same thing myself. Except tha the directory named ~ was not in my home directory, but rather in quite a bunch of random places.
[04:31:59] <enix> honestly, i don't know why its useful
[04:32:00] <aatch> rusti: 16 << (-1)
[04:32:01] -rusti- 0
[04:32:08] <joelteon> i want to take a list of functions, spawn them all, and wait for them all to finish, then collect the results
[04:32:10] <aatch> rusti: 15 << (-1)
[04:32:10] -rusti- 0
[04:32:13] <enix> but, is it a bug that it can produce different results when inlined vs when not inlined?
[04:32:22] <cmr> joelteon: I think there might be stuff for that in extra::par
[04:32:35] <joelteon> ok I will look at it
[04:32:46] <aatch> enix, not sure. I don't think it's a bug per se, more just undocumented behaviour.
[04:32:59] <strcat> enix: it's not really a bug
[04:33:07] <strcat> the result is unspecified if you shift by more than the number of bits
[04:33:09] <joelteon> but I also want to possibly *not* wait for some of them
[04:33:19] <strcat> This instruction always performs a logical shift right operation. The most significant bits of the result will be filled with zero bits after the shift. If op2 is (statically or dynamically) equal to or larger than the number of bits in op1, the result is undefined. If the arguments are vectors, each vector element of op1 is shifted by the corresponding shift amount in op2.
[04:33:24] <aatch> rusti: 5 << 72
[04:33:25] -rusti- 0
[04:33:37] <cmr> joelteon: this can all be expressed with rust's task system, it's just a matter of there being wrappers for it
[04:33:48] <joelteon> ok
[04:33:53] <joelteon> I guess I won't worry about the second case for now
[04:33:54] <strcat> shl:
[04:33:56] <strcat> The value produced is op1 * 2op2 mod 2n, where n is the width of the result. If op2 is (statically or dynamically) negative or equal to or larger than the number of bits in op1, the result is undefined. If the arguments are vectors, each vector element of op1 is shifted by the corresponding shift amount in op2.
[04:34:30] <aatch> cmr, we do need unsafe code for a decent fork-join interface though.
[04:34:36] <strcat> essentially, it's a biased random number generator if you shift by more than the # of bits.
[04:34:46] <strcat> completely arbitrary what you get
[04:34:53] <strcat> non-deterministic too
[04:35:03] <cmr> aatch: nmatsakis had some ideas on that, and I think it involved new language features
[04:35:16] <aatch> cmr, yeah, `proc` stuff an all that.
[04:35:16] <strcat> you can wrap it into a higher-level operation
[04:35:51] <enix> ok, cool. i was just surprised it did different things at --opt-level 3 vs --opt-level 0. thanks! i will not open up an issue.
[04:36:30] <bjz> mihneadb: was originally implemented for ML
[04:36:30] <aatch> but it's just that there is very little you can do to handle the fact that tasks can, at a generic level, last arbitrarily long.
[04:36:47] <bjz> everybody forgets ML :(
[04:37:02] <mihneadb> bjz: yeah, I think my programming paradigms teacher was more of the haskell guys
[04:37:03] <cmr> All I know about ML is that graydon really likes it and rust draws from it a lot
[04:37:09] <mihneadb> bjz: but he always pointed out the differences
[04:37:26] <aatch> rust-boot (the first rust compiler) was written in OCaml
[04:37:38] <bjz> mihneadb: yeah, Haskell kind of obscures all of the history
[04:37:44] <tautologico> half of the Rust tutorial I was just thinking "that's cool, just like ML!" 
[04:38:24] <tautologico> it stopped when the pointer / ownership / etc started
[04:38:31] <aatch> tautologico, now you know why.
[04:38:40] <jeaye> bjz: ping
[04:38:41] <strcat> enix: it's debatable whether rust should expose the low-level operation as the actual shift operators, but I think it's okay
[04:38:44] <aatch> tautologico, yeah, that's where the "systems" part comes in.
[04:38:48] <bjz> jeaye: yoho
[04:38:50] <enix> cool, thanks
[04:39:05] * strcat thought there was a closed RFC but can't find it :(
[04:39:40] <jeaye> bjz: Still having troubles with Rust?
[04:39:54] <jeaye> bjz: The shared context bit is working pretty well.
[04:40:00] <jeaye> We should get it into master.
[04:40:00] <bjz> jeaye: yeah, it will be a while yet
[04:40:04] <jeaye> Ah
[04:40:07] <bjz> send me a PR
[04:40:12] <enix> my other question: i noticed that if you have a function with asm!() where the assembly uses labels, the compiler will produce an error if it tries to inline it more than once. Should it be possible to inline such a function? Should the compiler not attempt to inline it?
[04:40:13] <bjz> I will merge it
[04:40:36] <bjz> jeaye: but it'll still be broken on Rust master
[04:40:38] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[04:40:46] <strcat> enix: I think asm is fairly broken atm :)
[04:41:01] <jeaye> Ok. There is one more change that's required, bjz. I'm getting crashes on closing because it's trying to destroy the shared context (and I believe a shared one is not destroyed -- haven't yet tried it).
[04:41:02] <strcat> not sure if that's a bug or intended though
[04:41:16] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[04:41:23] <bjz> jeaye: yep
[04:41:23] <strcat> enix: you could use #[inline(never)] if you don't want it to
[04:41:25] <jeaye> My PR will also include that change, which will add a bool to Window saying whether or not it's shared. Sound alright?
[04:41:49] <enix> Yeah, that works around the issue just fine
[04:41:50] <aatch> enix, LLVM isn't very bright when it comes to inline assembly (for good reason)
[04:42:02] <aatch> enix, it just treats it like a black-box.
[04:42:18] <enix> I just didn't know if there should be a bug for that
[04:42:38] <enix> in general, for smaller bits of assembly, asm!() seems to more or less work for me
[04:42:40] <Luqman> enix: gcc has the same behaviour
[04:42:52] <mihneadb> so.. there is an impl for Container on HashMap, but nothing about Iterator
[04:42:54] <bjz> jeaye: sounds reasonable
[04:43:00] <mihneadb> does that mean there's no iter() on hashmap?
[04:43:04] <strcat> mihneadb: it has a few iterators
[04:43:06] <cmr> mihneadb: it is there
[04:43:16] <strcat> at least it has a regular iterator + one for mutating values
[04:43:28] <mihneadb> oh
[04:43:29] <mihneadb> it is
[04:43:31] <cmr> iter() isn't part of Iterator
[04:43:38] <cmr> it's a helper to return an iterator over an object
[04:43:40] <mihneadb> Iterator for HashMapIterator
[04:43:42] <mihneadb> but not for HashMap
[04:43:43] <enix> ah, ok, thanks again!
[04:43:45] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[04:43:47] <bjz> jeaye: should the shared contexts share callbacks? or is it just the gl context?
[04:43:47] <jeaye> bjz: Alright. I'll try it now; if it works, I'll put up a PR right off. Let me know when Rust master is working for you again. I've been holding off on the upgrade. :P
[04:43:56] <jeaye> bjz: Just the context.
[04:44:00] <strcat> rusti: let mut map = std::hashmap::HashMap::new(); xs.insert(5, "foo"); xs.insert(243253253, "bar"); for (k, v) in map.iter() { printfln!("%d %s", *k, *v) }
[04:44:01] -rusti- pastebinned 8 lines of output: http://sprunge.us/CELT
[04:44:13] <cmr> CELT
[04:44:14] <jeaye> bjz: It's a separate window in its own right (I'm just hiding it)
[04:44:15] <cmr> surely a sign
[04:44:16] <strcat> rusti: let mut map = std::hashmap::HashMap::new(); map.insert(5, "foo"); map.insert(243253253, "bar"); for (k, v) in map.iter() { printfln!("%d %s", *k, *v) }
[04:44:17] <bjz> jeaye: make sure it deletes the window data
[04:44:17] -rusti- 243253253 bar
[04:44:18] -rusti- 5 foo
[04:44:18] -rusti- ()
[04:44:44] <mihneadb> strcat: sweet, thanks
[04:45:04] <mihneadb> strcat: is rusti here diferent than rusti the one that you build?
[04:45:04] <strcat> alright lambdas are indeed expr_fn_block
[04:45:11] <strcat> mihneadb: rusti here is really rustc
[04:45:11] <cmr> mihneadb: yes
[04:45:15] <mihneadb> heh
[04:45:17] <strcat> in a sandbox
[04:45:19] <mihneadb> that's confusing
[04:45:25] <mihneadb> but it makes sense
[04:45:28] <bjz> jeaye: wait, I need to push some changes to the private api
[04:45:29] <strcat> well one day it might be rusti
[04:45:34] <strcat> I intend to do that
[04:45:39] <strcat> but rusti doesn't work well enough yet
[04:45:40] <bjz> jeaye: shouldn't affect you though
[04:45:49] <mihneadb> strcat: I noticed, I understand
[04:45:51] *** Quits: heftig (heftig@8DB4145A.5C7D981D.FEC4A986.IP) (Quit: Quitting)
[04:46:14] * strcat thinks there *must* be more code to implement the old `for` somewhere
[04:46:16] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[04:46:29] <strcat> Showing 20 changed files with 15 additions and 323 deletions. 
[04:46:31] <strcat> not enough ;p
[04:46:58] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[04:46:58] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14f893354 to 148ce9533: 02http://git.io/N3iJvQ
[04:46:58] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[04:46:59] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[04:46:59] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/bs-y5g
[04:46:59] <ghrust> 13rust/06auto 143c9e393 15Brian Anderson: std::rt: Run local storage cleanup and the box annihilator inside the try/catch...
[04:46:59] <ghrust> 13rust/06auto 1493432a2 15bors: auto merge of #8269 : brson/rust/fix-task-cleanup, r=brson...
[04:47:00] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[04:47:06] <mihneadb> btw, do you guys have a set point after which you will not break backwards compatibility?
[04:47:07] <mihneadb> like 1.0?
[04:47:26] <strcat> at least no more than a language like python/ruby breaks compatibility
[04:47:30] <strcat> but yeah, 1.0
[04:47:31] <aatch> mihneadb, there's a backwards compatible milestone.
[04:47:32] <cmr> Milestone #3
[04:47:32] <mihneadb> right, like that
[04:47:41] <cmr> #2 sorry
[04:47:44] <cmr> mihneadb: https://github.com/mozilla/rust/issues/milestones
[04:47:49] <bjz> jeaye: done
[04:47:55] <jeaye> mmk
[04:47:57] <cmr> It's not much of a promise until 1.0 though
[04:47:58] <mihneadb> nice, thanks
[04:48:06] <cmr> 1.0 might not be until quite a bit into well-covered
[04:48:22] <bjz> jeaye: also, servo uses glfw, so they will be pushing a fix once they upgrade
[04:48:34] <jeaye> Well, that takes a while. :P
[04:48:56] <bjz> jeaye: yep. but we won't be forgotton.
[04:48:58] *** Joins: mark_edward (quassel@981AA104.E81F12CD.76F66111.IP)
[04:49:42] <strcat> aatch: https://github.com/mozilla/rust/pull/8264 r? just the last commit
[04:49:44] <jeaye> I've basically abandoned hope with rust-opengles and rust-stb-image (both servo) because I just branch too far away from them implementing my own functions and updating with Rust master.
[04:49:59] <jeaye> Hopefully glfw-rs doesn't end up like that. :(
[04:50:01] <bjz> jeaye: pcwalton was talking about how to work with the new run time earlier today
[04:50:03] * cmr impatiently awaits gl-rs
[04:50:08] <bjz> jeaye: definitely not
[04:50:11] *** Quits: eevee (eevee@moz-58058235.evrt.wa.frontiernet.net) (Ping timeout)
[04:50:14] <bjz> cmr: aye
[04:50:23] <jeaye> cmr: Who's writing that?
[04:50:28] <cmr> jeaye: it's already written
[04:50:32] <bjz> me
[04:50:35] <jeaye> Just bitrotted?
[04:50:37] <cmr> compiler bug
[04:50:40] <jeaye> ah
[04:50:49] <jeaye> bjz: Link? :P
[04:51:08] <bjz> jeaye: I need to redo it though, to ue static muts
[04:51:28] <bjz> https://github.com/bjz/gl-rs
[04:51:37] <bjz> when I did it we didn't have them
[04:51:44] <aatch> bjz, oh, is that the "can't function call a constant" stuff?
[04:52:02] <bjz> aatch: yes, but also the extern fn thing
[04:52:13] <bjz> this uses a struct to hold the function pointers
[04:52:40] <bjz> if we used static muts, you would be able to call the functions just like normal
[04:53:07] <strcat> need to retry all the failed PRs from those net issues
[04:53:15] <jeaye> 4.x would be nice. My biggest changes to rust-opengles have just been adding non-ES items. :P
[04:54:20] <jeaye> bjz: Let me know when this is back in business. I think q3 might be switching to it. :)
[04:54:26] <cmr> it'd be nice if gl-rs did automatic extension loading if a new enough core profile isn't available
[04:54:35] *** Joins: eevee (eevee@moz-58058235.evrt.wa.frontiernet.net)
[04:54:44] <joelteon> can I auto
[04:54:48] <bjz> cmr: yeah? what would that look like?
[04:54:49] <joelteon> auto-implement Clone
[04:54:55] <cmr> bjz: no idea! but it'd be cool
[04:55:00] *** Parts: chmanchester (chmanchest@moz-BE33DA21.fw1.sfo1.mozilla.net) ()
[04:55:01] <jeaye> #[deriving(Clone)] ?
[04:55:01] <cmr> joelteon: #[deriving(Clone)]
[04:55:04] <bjz> joelteon: #[deriving(Clone)]
[04:55:06] <bjz> haha
[04:55:08] <jeaye> Muahah!
[04:55:36] <joelteon> oh
[04:55:39] <joelteon> [close]
[04:55:41] <joelteon> clone I mean
[04:55:45] <joelteon> wow I can type really good!!
[04:55:53] <joelteon> ok neat, thanks guys
[04:56:07] <cmr> joelteon: sometimes it doesn't work and complains about finding a &-ptr
[04:56:23] <cmr> in those cases I do --pretty expanded, copy the automatically derived implementation, and change the field to (*foo).clone()
[04:56:36] <jeaye> hah
[04:56:38] <bjz> cmr: if we wanted that it might be better to do the generation ourselves, seeing as there is an xml spec now
[04:56:55] <cmr> bjz: for the extensions too?
[04:56:58] <bjz> cmr: gl load gen is a little tricky
[04:57:16] <bjz> cmr: https://github.com/bjz/gl-rs/issues/1
[04:57:24] <cmr> The reason I desire this is because Mesa implements everything up to 3.3 except geometry shaders
[04:57:32] <cmr> and it'd be nice to be able to use the features with 0 extra work ;p
[04:57:46] <bjz> joelteon: you can also derive things like Eq and Zero
[04:57:51] <bjz> cmr: aye
[04:57:57] *** Quits: tautologico (shung@74BFD9C3.5A3A7952.7B974E06.IP) (Quit: tautologico)
[04:58:21] <cmr> bjz: oh nice
[04:58:29] <cmr> it'd be really cool to use RustyXML
[04:59:03] <bjz> cmr: if you're interested in helping out, it would be appreaciated
[04:59:04] <cmr> dogfood all around
[04:59:13] <cmr> bjz: sure, once I'm done this huge pile of other stuff :P
[04:59:28] <bjz> cmr: coolies :) always so much to do
[04:59:49] <cmr> upside: never bored
[04:59:49] * bjz now needs to try to fix lmath for maikklein
[04:59:52] <cmr> downside: always busy
[05:02:24] <joelteon> eek
[05:02:27] <joelteon> you can't clone a ~fn?
[05:02:47] <strcat> nope, it could contain non-clonable captures
[05:02:57] <cmr> ~fn:Clone maybe?
[05:02:59] <strcat> no
[05:03:02] <cmr> Or maybe the stuff after the : is only kinds
[05:03:13] <strcat> yeah and Copy isn't a kind anymore ;]
[05:03:37] <joelteon> I don't see why I'd *need* to clone a function, but I dunno how they're implemented exactly anyway
[05:03:55] <cmr> joelteon: they are implemented as a pair of pointers, pointer to environment, and function pointer
[05:03:56] <strcat> joelteon: &fn/~fn/@fn aren't functions, they're an environment + a function (closures)
[05:04:03] <cmr> the environment is passed to the function
[05:04:17] <cmr> the bounds/sigil specifiy attributes about the environment
[05:04:22] <cmr> so ~fn the environment is owned
[05:04:41] <strcat> 'extern fn' is a plan old function
[05:04:47] *** Joins: z0w0 (zack@moz-E12708D5.lns6.woo.bigpond.net.au)
[05:04:54] <strcat> (it can be safely cloned)
[05:05:14] <joelteon> oh
[05:05:18] <joelteon> oh that's why it's a problem
[05:05:46] <strcat> plain old*, silly typos
[05:08:10] *** Joins: jgilbert (jgilbert@986623D2.9083A694.9CA62458.IP)
[05:08:22] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[05:08:22] *** Quits: Diamond (dick@moz-C01E1CD1.ks.ks.cox.net) (Connection reset by peer)
[05:09:48] * strcat will be so happy when this finally lands :)
[05:10:03] <bjz> strcat: <3 new loop protocol
[05:10:12] <bjz> ^_^
[05:10:31] <strcat> bjz: :D
[05:10:53] *** Joins: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP)
[05:11:10] *** Joins: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net)
[05:11:43] <bjz> strcat: can we remove the ranges from the integer modules?
[05:12:47] <jeaye> bjz: I don't see a way in glfw-rs to set the current context to nothing.
[05:12:48] <strcat> bjz: I removed range() already
[05:12:55] <strcat> bjz: but the others are harder to replace with a proper generic one
[05:12:58] *** Quits: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP) (Ping timeout)
[05:12:58] <strcat> rather than codegen
[05:13:13] <strcat> bjz: we really need checked int operations, like add_check -> Option<T>
[05:13:14] <jeaye> And not doing it on my background thread is causing a segfault.
[05:13:17] <strcat> where it returns None on overflow
[05:13:33] <strcat> it's too hard to write a generic range working on all kinds of integers (including efficiently on bigints) atm :[
[05:13:42] <bjz> strcat: ok
[05:13:53] <bjz> jeaye: will look
[05:14:24] <strcat> rusti: for (x, y) in range(0, 4).zip(range(10, 20)) { printfln!("%d %d", x, y) }
[05:14:28] -rusti- 0 10
[05:14:28] -rusti- 1 11
[05:14:28] -rusti- 2 12
[05:14:28] -rusti- 3 13
[05:14:28] -rusti- ()
[05:14:29] * strcat likes having that at least
[05:14:38] <strcat> LLVM likes it too ;p
[05:14:44] <bjz> jeaye: detach_current_context?
[05:15:00] <jeaye> hmmm, that's just glfw::detach_current_context?
[05:15:04] <joelteon> ugh, why does par::map want the function to be clonable
[05:15:07] <bjz> ya
[05:15:12] <jeaye> Ohh, will try that.
[05:15:14] <joelteon> that's what I want to know
[05:15:37] <joelteon> what other environment besides the arguments does this function need to know about?
[05:15:42] <cmr> joelteon: so it can clone it to send it to all the tasks to run in parallel, I imagine
[05:15:52] <joelteon> i guess so
[05:16:04] *** Quits: n0v (n0v@moz-690FFF9D.org) (Ping timeout)
[05:16:21] <mihneadb> is there a better way to interact with a key in a map that might not exist other than contains_key_equiv?
[05:16:21] <jeaye> bjz: Perfect! Thanks.
[05:16:28] <joelteon> but why does it need to clone it to send it to all the tasks?
[05:16:39] <cmr> joelteon: because you can't send something twice
[05:16:44] <mihneadb> I found find_or_insert but that would make me use two insertions in the end
[05:16:59] <joelteon> so basically I can't parmap a list of functions and apply them all to a certain input
[05:17:02] <bjz> jeaye: np, the reason is that make_context_current is a method on window
[05:17:03] <joelteon> as far as I can tell...
[05:17:16] *** Joins: steven_is_false (user@C5B76363.1FF1EBF8.1ECA502.IP)
[05:17:22] <jeaye> yeah
[05:17:31] * mihneadb was hoping for an Option return value for get
[05:17:35] * jeaye was just looking in the wrong place.
[05:17:36] <bjz> jeaye: not sure if that's the best way
[05:17:47] <cmr> mihneadb: find returns an Option
[05:17:52] <bjz> jeaye: or to have a free floating function that takes an option
[05:18:01] <steven_is_false> Rust boxed traits do the header information style thing like HLVM at http://www.ffconsultancy.com/ocaml/hlvm/ right?
[05:18:08] <jeaye> bjz: I prefer the option approach.
[05:18:09] <mihneadb> cmr: wait where's find. I only found get and contains_key_equiv
[05:18:14] <jeaye> It's more consistent.
[05:18:14] <mihneadb> looking at http://static.rust-lang.org/doc/std/hashmap.html
[05:18:26] <bjz> jeaye: yeah, and consistent with the api
[05:18:31] <cmr> mihneadb: ctrl-f it
[05:18:31] <jeaye> aye
[05:18:35] <mihneadb> cmr: yeah, found with ctrl f
[05:18:36] <mihneadb> but..
[05:18:37] *** Joins: n0v (n0v@moz-690FFF9D.org)
[05:18:38] <cmr> it's the Map trait
[05:18:41] <mihneadb> if I did not know about it
[05:18:44] <cmr> mihneadb: the docs are a mess, I know
[05:18:47] <mihneadb> I find the docs hard to parse
[05:18:49] <mihneadb> ok
[05:18:49] <cmr> I'm working on th e new rustdoc right now
[05:18:55] <joelteon> can I parmap a list of functions and apply them all to the same input, and collect the results? since you can't clone functions
[05:19:03] <mihneadb> cmr: that's awesome, nice!
[05:19:04] <cmr> http://seld.be/rustdoc/std/index.html for a prototype
[05:19:11] <cmr> (Frontend by Seldaek)
[05:19:16] <mihneadb> heh it also looks nicer
[05:19:19] <strcat> bjz: vector iterators are also faster in master now.
[05:19:24] <strcat> but there is more room for improvement
[05:19:26] <cmr> basically all it's missing right now is traits and some polish
[05:19:44] <joelteon> jesus christ, a search function
[05:20:04] <cmr> joelteon: will also integrate hoogle-like functionality :)
[05:20:10] <mihneadb> cmr: just a suggestion. Could you do something like when you go to a struct, have a listing of all the method it has?
[05:20:18] <mihneadb> i.e. so you could find "find" on HashMap
[05:20:20] <cmr> mihneadb: Yes, most certainly, is planned
[05:20:26] <cmr> https://github.com/mozilla/rust/wiki/Bikeshed-rustdoc
[05:20:27] <mihneadb> ok, cool
[05:21:03] <joelteon> I'm not sure about that new header font
[05:21:10] <joelteon> it looks odd with the double colons
[05:21:28] <joelteon> oh well, what do I know?
[05:21:28] <mihneadb> joelteon: ++
[05:21:32] <joelteon> I can't even parmap a bunch of functions
[05:22:04] <joelteon> I'd like a monospace font for headers honestly
[05:22:19] <cmr> steven_is_false: "fat references"?
[05:23:03] <steven_is_false> cmr: Yeah, I'm sort of interested in how they have a visit function for every reference.
[05:23:42] <steven_is_false> cmr: As I understand it the GC that's being made uses some sort of metadata stored elsewhere.
[05:24:31] <steven_is_false> That's because we don't want an overly conservative GC right?
[05:24:32] <maikklein> rusti: 1.0f/2
[05:24:35] -rusti- <anon>:5:14: 5:15 error: mismatched types: expected `float` but found `<VI0>` (expected float but found integral variable)
[05:24:35] -rusti- <anon>:5          1.0f/2
[05:24:35] -rusti-                        ^
[05:24:35] -rusti- error: aborting due to previous error
[05:24:35] -rusti- application terminated with error code 101
[05:24:46] <maikklein> why doesn't this work?
[05:24:59] <steven_is_false> Five seconds, make check just finished succesfully.
[05:25:31] <cmr> steven_is_false: I think so, not positive.
[05:25:39] <cmr> for example see the visit glue
[05:25:58] *** Quits: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net) (Input/output error)
[05:26:06] <maikklein> how do I cast an uint to float?
[05:26:18] <steven_is_false> rusti: 4 as f32
[05:26:19] -rusti- 4
[05:26:23] *** Joins: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net)
[05:26:41] <sfackler> cmr: does the new rustdoc handle default method impls in a reasonable way yet?
[05:26:42] *** Quits: KindOne (KindOne@moz-23830D44.dynamic.ip.windstream.net) (Ping timeout)
[05:26:54] <cmr> sfackler: what do you consider reasonable?
[05:26:56] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[05:27:00] <sfackler> e.g. there's no reference to insert anywhere in HashMap's documentation
[05:27:01] <maikklein> rusti: 1.0f/(2 as float)
[05:27:02] -rusti- 0.5
[05:27:30] *** Joins: maikklein2 (maik@moz-B6A68264.dip0.t-ipconnect.de)
[05:27:42] <cmr> sfackler: they don't handle them in any way yet, but things will have lists of all their methods and traits they implement
[05:27:47] <sfackler> cool
[05:28:07] *** Quits: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net) (Ping timeout)
[05:28:08] *** Joins: mihneadb_ (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net)
[05:28:20] <jeaye> bjz: PR's been made
[05:28:41] *** Quits: maikklein (maik@moz-835049A2.dip0.t-ipconnect.de) (Ping timeout)
[05:28:45] <cmr> rusti: let x: ::Option<uint> = None;
[05:28:45] -rusti- <anon>:5:16: 5:30 error: use of undeclared type name `Option`
[05:28:45] -rusti- <anon>:5          let x: ::Option<uint> = None;
[05:28:45] -rusti-                          ^~~~~~~~~~~~~~
[05:28:45] -rusti- error: aborting due to previous error
[05:28:46] -rusti- application terminated with error code 101
[05:29:08] <sfackler> something in the style of Javadoc's "methods inherited from X" list?
[05:29:45] <cmr> sorta
[05:30:06] <bjz> jeaye: one issue is, what if the original context is dropped before the shared context?
[05:30:08] <cmr> more along the lines of haddock
[05:30:50] *** Joins: KindOne (KindOne@moz-B6AF9A13.dynamic.ip.windstream.net)
[05:30:59] <mihneadb_> rusti: foreach char in "h" { printfln("%?", char) }
[05:31:00] -rusti- <anon>:5:31: 5:39 error: unresolved name `printfln`.
[05:31:00] -rusti- <anon>:5          foreach char in "h" { printfln("%?", char) }
[05:31:00] -rusti-                                         ^~~~~~~~
[05:31:00] -rusti- error: aborting due to previous error
[05:31:00] -rusti- application terminated with error code 101
[05:31:08] <mihneadb_> rusti: foreach char in "h" { printfln!("%?", char) }
[05:31:09] -rusti- <anon>:5:9: 6:5 error: type `&mut &'static str` does not implement any method in scope named `next`
[05:31:09] -rusti- <anon>:5          foreach char in "h" { printfln!("%?", char) }
[05:31:09] -rusti- <anon>:6     };
[05:31:09] -rusti- error: aborting due to previous error
[05:31:09] -rusti- application terminated with error code 101
[05:31:17] <mihneadb_> rusti: foreach char in "h".iter() { printfln!("%?", char) }
[05:31:18] -rusti- 'h'
[05:31:18] -rusti- ()
[05:31:27] <mihneadb_> rusti: foreach char in "h".to_ascii().iter() { printfln!("%?", char) }
[05:31:28] -rusti- &{chr: 104}
[05:31:28] -rusti- ()
[05:31:33] <mihneadb_> hm
[05:31:36] <mihneadb_> to me this is confusing
[05:31:40] <mihneadb_> first I get a value
[05:31:45] <mihneadb_> 2nd time I get a reference
[05:31:50] <mihneadb_> what happens?
[05:32:18] <bjz> "h".to_ascii()
[05:32:22] <bjz> rusti: "h".to_ascii()
[05:32:23] -rusti- &[{chr: 104}]
[05:32:50] <bjz> rusti: "h"[0]
[05:32:50] -rusti- 104
[05:32:57] <mihneadb_> bjz: can you do foreach &char ?
[05:33:02] <maikklein2> how do I declare a mutable parameter like fn sum(f: mut float) ?
[05:33:10] <cmr> rusti: let x = 'h'; printfln!("%?", &x);
[05:33:11] -rusti- &'h'
[05:33:11] -rusti- ()
[05:33:18] <cmr> maikklein2: mut f: float
[05:33:23] <mihneadb_> rusti: foreach &char in "h".to_ascii().iter() { printfln!("%?", char.chr) }
[05:33:25] -rusti- pastebinned 9 lines of output: http://sprunge.us/RQBf
[05:33:35] <mihneadb_> rusti: foreach char in "h".to_ascii().iter() { printfln!("%?", char.chr) }
[05:33:36] -rusti- pastebinned 9 lines of output: http://sprunge.us/OFDB
[05:33:57] <mihneadb_> so how do I get to the character?
[05:34:01] <cmr> mihneadb_: call to_byte or to_char on it
[05:34:08] <cmr> it's an opaque value
[05:34:14] <mihneadb_> rusti: foreach char in "h".to_ascii().iter() { printfln!("%?", char.to_char()) }
[05:34:15] -rusti- 'h'
[05:34:15] -rusti- ()
[05:34:32] <mihneadb_> I feel like I'm jumping through so many hoops
[05:34:34] <cmr> don't use foreach btw, you can just use for
[05:34:51] <cmr> mihneadb_: Yes, this is how using ascii is supposed to feel ;p
[05:34:51] <mihneadb_> cmr: I guess I have to git pull :)
[05:34:51] *** Quits: steven_is_false (user@C5B76363.1FF1EBF8.1ECA502.IP) (Client exited)
[05:34:59] *** Quits: jyyou (jyyou@moz-F09996FC.hinet-ip.hinet.net) (Quit: leaving)
[05:35:23] <mihneadb_> cmr: so then I should use unicode and hope there's only ascii in there?
[05:35:24] *** Joins: jyyou (jyyou@moz-47B052FA.cs.nctu.edu.tw)
[05:35:43] <cmr> mihneadb_: no, you should use ascii, and just deal with the extra verbosity of second-class types
[05:35:51] <cmr> "second-class"
[05:37:01] <mihneadb_> cmr: could I do something like for &char in ... ?
[05:37:06] <cmr> mihneadb_: yes
[05:37:07] <mihneadb_> so that i don't have to dereference later
[05:37:50] <bjz> maikklein2: just surious, are you using lmath at the moment?
[05:37:56] <bjz> *curious
[05:37:57] <mihneadb_> cmr: http://pastebin.mozilla.org/2777285
[05:38:16] <cmr> rusti: let char = 5;
[05:38:16] -rusti- <anon>:5:13: 5:17 warning: unused variable: `char` [-W unused-variable (default)]
[05:38:17] -rusti- <anon>:5          let char = 5;
[05:38:17] -rusti-                       ^~~~
[05:38:17] <bjz> (apart from the fact it's currently broked)
[05:38:17] -rusti- ()
[05:38:39] <cmr> mihneadb_: is str an AsciiStr or a Str?
[05:38:55] <mihneadb_> cmr: let str = "Hello, world"
[05:38:59] <mihneadb_> so Str
[05:39:13] <cmr> mihneadb_: str's .iter() method returns an Iterator<char>
[05:39:20] <cmr> can't dereference that in a pattern
[05:39:24] <mihneadb_> ah
[05:40:34] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[05:43:09] <mihneadb_> cmr: http://pastebin.mozilla.org/2777319
[05:43:22] <mihneadb_> it complains that it does not know the type of x
[05:43:27] <mihneadb_> which I can see why happens
[05:43:40] <mihneadb_> what's the solution? specifying the type of the map explicitly?
[05:44:23] <cmr> hm
[05:44:31] <cmr> I would have thought that it would be bounded at that point
[05:44:36] <cmr> because of the insert
[05:44:37] <cmr> but yeah
[05:44:47] <mihneadb_> cmr: the insert which would make it obvious
[05:44:50] <mihneadb_> is on the next line
[05:44:51] <cmr> also, use std::hashmap::HashMap
[05:45:05] <cmr> mihneadb_: right but it looks forward to infer types
[05:45:07] <cmr> or, should
[05:45:09] <mihneadb_> exactly
[05:45:12] <mihneadb_> that's why I m confused
[05:45:14] <mihneadb_> maybe a bug?
[05:45:15] <cmr> I think this might be a bug, report it
[05:45:22] <mihneadb_> bjz: you are the HM fan
[05:45:25] <mihneadb_> what do you think
[05:45:45] <bjz> ?
[05:45:55] <mihneadb_> bjz: http://pastebin.mozilla.org/2777319
[05:46:09] <mihneadb_> ount_chars.rs:11:41: 11:42 error: the type of this value must be known in this context
[05:46:10] <mihneadb_> count_chars.rs:11             Some(&x) => map.insert(char, x + 1),
[05:46:31] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[05:46:36] <strcat> isn't that after another error?
[05:46:41] <mihneadb_> strcat: no
[05:46:44] <mihneadb_> that's all there is
[05:46:50] <bjz> rust's type inference has bugs in it
[05:47:09] <mihneadb_> I'm on rust 2a7be1c9e4d5a
[05:47:18] <cmr> (I tested it with master)
[05:47:24] <mihneadb_> bjz: should I open an issue about this or is it a known bug?
[05:47:33] <maikklein2> rusti: printfln("hello");
[05:47:34] -rusti- <anon>:5:9: 5:17 error: unresolved name `printfln`.
[05:47:34] -rusti- <anon>:5          printfln("hello");
[05:47:34] -rusti-                   ^~~~~~~~
[05:47:34] -rusti- error: aborting due to previous error
[05:47:34] -rusti- application terminated with error code 101
[05:47:48] <mihneadb_> maikklein2: printfln! (with !)
[05:47:51] <bjz> maikklein2: printfln!
[05:47:54] <maikklein2> ah right :x
[05:47:55] <maikklein2> thanks
[05:47:58] <bjz> mihneadb_: I have no idea
[05:48:04] <bjz> mihneadb_: sorry :(
[05:48:08] <cmr> (and don't use it for constant strings, yuck)
[05:48:16] <mihneadb_> bjz: then I ll open it and if it's known someone will hate me and close it
[05:48:28] <mihneadb_> you guys use github issues, not bugzilla,  rust?
[05:48:33] <cmr> yes, github issues
[05:48:38] <bjz> mihneadb_: I would just make the issue, then somebody who knows more can link it
[05:48:38] <bjz> ya
[05:48:44] <mihneadb_> ok
[05:48:52] <bjz> mihneadb_: thanks!
[05:48:54] *** Joins: heftig (heftig@1103CD12.9A77AED9.3663C14F.IP)
[05:49:00] <mihneadb_> sure, np
[05:49:11] <bjz> inference bugs are super annoying
[05:49:20] <mihneadb_> but for now
[05:49:24] <mihneadb_> I could specify the type, right?
[05:49:26] <cmr> yes
[05:49:46] <bjz>     let mut map = hashmap::HashMap::new::<Key, Value>();
[05:49:48] <mihneadb_> cmr: can I use the ::type trick on the new call?
[05:49:49] <mihneadb_> ah
[05:49:50] <mihneadb_> sweet
[05:50:08] <mihneadb_> 1,371 issues
[05:50:10] <mihneadb_> heh
[05:50:22] <bjz> cmr: keeps track of the churn
[05:50:33] <cmr> twir tomorrow I promise
[05:50:33] <bjz> apparently the trend is down
[05:50:41] <bjz> there is a ton of churn
[05:50:43] <cmr> bjz: I'm not sure it's accurate
[05:50:58] <cmr> I think github might be taking closed pr's into account
[05:51:03] <bjz> ahh
[05:51:09] <strcat> we have 50 open PRs
[05:51:13] <bjz> yeah, that would make sense
[05:51:14] <strcat> 51 now
[05:52:48] *** Joins: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP)
[05:53:12] <cmr> Anyone know how to get a fully qualified name out of a NodeId?
[05:53:33] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[05:53:38] <bjz> jeaye: before I push this, could you check this works? https://gist.github.com/bjz/56ae5942de5674b1be83
[05:54:03] <mihneadb_> ok, filed https://github.com/mozilla/rust/issues/8280
[05:54:20] <bjz> jeaye: I also changed the make_context_current method to call: make_context_current(Some(self));
[05:55:27] <cmr> rusti: struct Foo; let x = Foo; x.clone()
[05:55:28] -rusti- <anon>:5:34: 6:5 error: type `main::Foo` does not implement any method in scope named `clone`
[05:55:28] -rusti- <anon>:5          struct Foo; let x = Foo; x.clone()
[05:55:28] -rusti- <anon>:6     };
[05:55:28] -rusti- error: aborting due to previous error
[05:55:28] -rusti- application terminated with error code 101
[05:55:36] <kemurphy> man, the enum patch is gonna *suck* to merge
[05:55:55] <bjz> rusti: #[deriving(Clone)] struct Foo; let x = Foo; x.clone()
[05:55:56] -rusti- <anon>:5:53: 6:5 error: type `main::Foo` does not implement any method in scope named `clone`
[05:55:56] -rusti- <anon>:5          #[deriving(Clone)] struct Foo; let x = Foo; x.clone()
[05:55:56] -rusti- <anon>:6     };
[05:55:56] -rusti- error: aborting due to previous error
[05:55:56] -rusti- application terminated with error code 101
[05:56:22] <bjz> can't do attributes inside a fn?
[05:56:29] <cmr> bjz: no
[05:56:34] <cmr> my point was to see the error message though
[05:56:38] <bjz> ah
[05:56:42] <cmr> to see which codepath rustc takes to get main::Foo out of that :p
[05:57:08] * cmr trying to figure out how to get a fully qualified path
[05:58:05] <bjz> :P
[05:59:23] <sfackler> Has anyone run into an error building the docs after upgrading texlive? "/var/lib/texmf/web2c/pdftex/pdflatex.fmt doesn't match pdftex.pool"
[05:59:38] <sfackler> rerunning ./configure doesn't seem to help
[06:00:02] <mihneadb_> what's wrong with this? http://pastebin.mozilla.org/2777419
[06:00:07] <mihneadb_> I cannot understand the error
[06:00:30] <mihneadb_> I mean I cannot understand what causes it, and where
[06:00:48] <cmr> mihneadb_: return value from the arms of the match
[06:01:04] <cmr> ...maybe?
[06:01:13] <mihneadb_> cmr: so I should add ";" ?
[06:01:16] <mihneadb_> or how do I do this?
[06:01:32] <cmr> semicolon after the match yeah
[06:01:40] <mihneadb_> cmr: after the whole match
[06:01:42] <mihneadb_> ?
[06:01:43] <cmr> yes
[06:01:46] <mihneadb_> or after every arm
[06:01:46] <mihneadb_> ok
[06:02:06] <sfackler> you'll run into an immutable borrow issue after fixing that though
[06:02:10] <mihneadb_> cannot borrow map as mutable because it's also borrowd as immutable
[06:02:11] <mihneadb_> wat
[06:02:14] <mihneadb_> sfackler: nice
[06:02:15] <mihneadb_> why
[06:02:37] <sfackler> I think you want to use HashMap.mangle
[06:02:52] <mihneadb_> uh, can you also tell me why please
[06:02:55] <sfackler> basically, you've been given a reference to something inside the map (count)
[06:03:10] <sfackler> and if you insert something into the map, that reference could become invalid
[06:03:11] <acrichto> mihneadb_: `count` is a borrowed variable from `map`, so if you attempt to access it after calling `map.insert` it could possibly have been invalidated by the call to insert
[06:03:13] <sfackler> e.g. if the map resizes
[06:03:18] <cmr> it freezes the map when you borrow it
[06:03:22] <cmr> (as immutable)
[06:03:30] <mihneadb_> oh
[06:03:31] <mihneadb_> I see
[06:03:38] <mihneadb_> so how would I do this properly
[06:03:52] <mihneadb_> what's the rust way of solving the problem I m trying to solve
[06:03:57] <acrichto> your value is implicitly copyable so you could use find_copy()
[06:04:13] <mihneadb_> ok
[06:04:34] <cmr> acrichto: eh? hashmap is generic, there can't be implicit copies. does it use clone?
[06:04:46] <acrichto> cmr: oh yes, it calls clone() for find_copy()
[06:05:01] <acrichto> mihneadb_: yeah cmr is right, it's b/c the values implement Clone you can implement find_copy
[06:05:21] <mihneadb_> ok
[06:05:53] <mihneadb_> so now it works
[06:05:53] <Luqman> acrichto: i'm pretty sure i found which llvm commit introduced the bug (~2 other commits left to bisect but this seems the most relevant)
[06:05:56] <acrichto> mihneadb_: another thing you could possibly do is perform the insert in a separate scope from the borrow, something like `let to_insert = { ... borrow as immutable ... }; map.insert(key, to_insert)`
[06:06:10] <acrichto> Luqman: you are a champion
[06:06:13] <mihneadb_> acrichto: ah, so it unfreezes it
[06:06:22] <acrichto> mihneadb_: exactly :)
[06:06:25] <mihneadb_> I see
[06:06:26] <Luqman> acrichto: https://github.com/llvm-mirror/llvm/commit/50125482d399ae58223a7f39a1c001fdb635508a
[06:06:28] <cmr> thaw, is the rust term
[06:06:33] <mihneadb_> cmr: thanks
[06:06:51] <mihneadb_> I feel like I'm fighting an uphill battle. is there an easier way to get a map with the counts of the chars in a string?
[06:06:57] <acrichto> Luqman: I'd believe it
[06:07:02] <acrichto> mainly b/c it has to do with idiv
[06:07:05] <sfackler> acrichto: speaking of this kind of thing, think it's worth moving mangle, find_or_insert, etc into MutableMap?
[06:07:28] <Luqman> acrichto: yep
[06:07:50] <acrichto> sfackler: it probably couldn't hurt, if it could have a default implementation it would be even better (although everything could probably optimize it more)
[06:08:07] <cmr> mihneadb_: the code is pretty straightforward
[06:08:11] <cmr> (imo)
[06:08:14] <acrichto> sfackler: I'm not particularly a fan of having MutableMap and Map, but if we have them I'd be ok with moving them into MutableMap
[06:08:15] <mihneadb_> cmr: ok
[06:08:57] <acrichto> Luqman: so I'd want to get this fixed in upstream and then use the fix, but there's other bugs in LLVM (I haven't investigated) which prevent us from using the head of llvm currently
[06:09:02] <cmr> mihneadb_: adding histograms to extra::stat would be cool if you feel up for it :)
[06:09:14] <mihneadb_> cmr: would a more functional way be better? I.e. filter the string for every char, check the length, map the lengths together?
[06:09:30] <acrichto> Luqman: the symptoms is that stage1 libstd takes an absurd amount of time and then it dies on the verification pass afterwards (on the head llvm from a few days ago)
[06:09:31] <Luqman> acrichto: i guess we could submit patch upstream as well but backport it for now
[06:09:38] <mihneadb_> cmr: I'll actually check it out, thanks. Is there a bug open?
[06:09:39] <acrichto> Luqman: yeah that would work too
[06:09:41] <mihneadb_> cmr: sorry, I mean issue
[06:09:41] <cmr> mihneadb_: I don't feel comfortable answering that. To me the imperative way is more straightforward
[06:09:50] <cmr> mihneadb_: not that I know of
[06:10:06] <sfackler> acrichto: looks like all of those methods are based off of mangle, which should (?) have a pretty straightforward default impl based off of find_mut
[06:10:32] <mihneadb_> cmr: would you mind opening one so I can have a place to start? maybe some reqs
[06:10:34] <cmr> sure
[06:10:37] <acrichto> sfackler: if it works and if someone else agrees with my, I'd definitely r+ a default implementation b/c then everything gets it for free!
[06:10:38] <mihneadb_> thanks
[06:11:08] <cmr> Is histogram the right term? Maybe frequency count or something is better, since it's not actually a plot?
[06:11:23] <acrichto> Luqman: I saw you talked to LLVM guys about this, so are they aware of this issue in a bug-tracking sense or just a "there may be a bug" sense?
[06:11:23] <mihneadb_> I didn't even know extra::star existed
[06:11:24] <mihneadb_> so
[06:11:55] <mihneadb_> frequency count, distribution..
[06:11:58] <mihneadb_> something like that
[06:13:00] <n0v> Is there an equiv to sleep(3) I'm missing somewhere? 
[06:13:00] <joelteon> can I parmap a list of functions and apply them all to the same input, and collect the results? since you can't clone functions
[06:13:09] <cmr> n0v: libc::sleep
[06:13:12] <cmr> n0v: it's unsafe
[06:13:14] <n0v> Ah, thanks!
[06:13:20] <cmr> or, requires unsafe code
[06:13:28] <cmr> it blocks all tasks though!
[06:13:34] <Luqman> acrichto: they just confirmed my guess that it was a bug in llvm. i'm not sure if it's in their bug tracker
[06:13:36] <cmr> I think there are timers in std::rt::io now
[06:13:42] <cmr> dunno how to use them though
[06:13:44] <cmr> but they'd be the proper way
[06:13:53] <acrichto> Luqman: oh ok, no wirries
[06:13:59] <n0v> Ah, well I'm up for adventure. Thanks!
[06:14:20] <maikklein2> rusti: if(0.0f < 0.1f && 10.0f < 0.1f){print("test");}
[06:14:20] -rusti- ()
[06:14:39] <maikklein2> rusti: if(0.0f < 0.1f && 0.0f < 0.1f){print("test");}
[06:14:39] -rusti- test()
[06:15:13] <acrichto> Luqman: I think you also found that it was attempting to emit one instruction, but it was actually emitted by another, so this may have been "introduced" by that commit but it actually lies somewhere else
[06:15:16] *** Joins: doener (doener@moz-121949B3.unitymediagroup.de)
[06:15:50] <Luqman> acrichto: no it probably is this. i might not have explained that bit properly.
[06:16:07] <acrichto> Luqman: oh I've barely read that commit, so it may well be in that commit
[06:16:30] *** Joins: Diamond (dick@moz-C01E1CD1.ks.ks.cox.net)
[06:16:35] <cmr> mihneadb_: https://github.com/mozilla/rust/issues/8281
[06:17:17] <Luqman> acrichto: the assembler output was mov %ah, (%r8) which is what you want to do but is not actually valid assembly. the the reason is because the machine code for that is actually a different instruction mov %spl, (%r8).
[06:17:26] <Luqman> acrichto: "The architecture enforces this limitation by changing high-byte references (AH, BH, CH, DH) to low byte references (BPL, SPL, DIL, SIL: the low 8 bits for RBP, RSP, RDI and RSI) for instructions using a REX prefix."
[06:17:51] <acrichto> Luqman: so "mov %ah, (%r8)" just isn't a valid instruction no matter how you do it?
[06:18:16] <Luqman> acrichto: yes. try assembling that with nasm or something and it will error out
[06:18:24] <acrichto> wow that sucks
[06:18:30] <acrichto> yay x86!
[06:18:40] <mihneadb_> cmr: thank you
[06:18:51] *** Quits: mihneadb_ (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net) (Input/output error)
[06:18:53] <Luqman> acrichto: llvm's assembler doesn't catch that (see FIXME @ http://llvm.org/docs/doxygen/html/X86AsmParser_8cpp_source.html#l01059 ) :P
[06:18:58] *** Quits: hjr3 (hradtke@moz-842BF853.hsd1.ca.comcast.net) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[06:19:17] *** Joins: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net)
[06:19:27] <acrichto> Luqman: ah, well that would explain it
[06:19:40] <acrichto> Luqman: man you are definitely a champion!
[06:19:45] <Luqman> acrichto: though i suppose the codegen shouldn't be emitting that in the first place
[06:20:26] <Luqman> no, jj2baile helped me quite a lot (he's much more well versed in x86 assembly than me)
[06:20:40] <acrichto> jj2baile: you are also a chapion!
[06:20:44] *** Quits: vilonis (jared@moz-B2CBB8FC.static.snlo.ca.charter.com) (Quit: WeeChat 0.3.8)
[06:20:48] <acrichto> you guys are fantastic
[06:21:01] *** Quits: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net) (Ping timeout)
[06:21:13] <cmr> mihneadb: no, thank *you*! and welcome to rust
[06:21:36] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[06:22:11] <acrichto> Luqman: I'm not super-familiar with llvm, but does that problem-patch run after register allocation such that we could catch cases like this and fall back onto the old behavior (whatever that was?)
[06:22:28] <strcat> please land silly snapshot ;p
[06:22:47] * strcat hopes it doesn't segfault like the last...
[06:22:56] *** Quits: maikklein2 (maik@moz-B6A68264.dip0.t-ipconnect.de) (Connection reset by peer)
[06:22:58] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[06:22:58] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/bs-y5g
[06:22:58] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[06:23:29] <acrichto> strcat: did you find the cause of the segfault?
[06:23:51] <strcat> acrichto: no, but I suspect it has to do with it being built on OS X 10.7 and run on 10.6
[06:24:04] <strcat> so this one will be fine if that's the case
[06:24:09] <acrichto> strcat: oh that's anti-climactic
[06:24:17] *** Joins: robertknight (robertknig@moz-AB0E96D7.range86-162.btcentralplus.com)
[06:24:20] <strcat> acrichto: it works on some bots and not others (the old snapshot)
[06:24:29] <Luqman> acrichto: the patch teaches FastISel how to handle div/idiv instead of falling back to the (presumably) slower ISelDAGToDAG which has the correct behaviour we want
[06:24:43] <strcat> acrichto: anyway I removed more traces of the old `for` in the meantime ;p
[06:25:09] <strcat> Luqman: so it's from one of our patches?
[06:25:23] <Luqman> strcat: no
[06:25:59] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[06:25:59] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/WZnkbA
[06:25:59] <ghrust> 13rust/06auto 14e7bb33a 15Daniel Micay: rm obsolete `for` support from the compiler
[06:25:59] <ghrust> 13rust/06auto 14fbeeeeb 15bors: auto merge of #8264 : thestinger/rust/snapshot, r=Aatch
[06:25:59] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[06:26:33] <Luqman> acrichto: yep, bisect done. definitely that commit
[06:26:42] <acrichto> Luqman: so it cleanly reverts, let me test if that works for us
[06:27:32] <strcat> that ghrust bot is a bit weird. there are 4 commits
[06:27:33] * strcat shrugs
[06:28:08] <cmr> strcat: I've found github to be many things, but bug-free is not among them
[06:28:13] *** Joins: jensnockert (jensnocker@moz-61E1062F.tbcn.telia.com)
[06:29:30] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[06:32:58] <acrichto> cmr: re a fully qualified path, have you looked at the each_path function?
[06:33:09] <cmr> acrichto: didn't know it existed
[06:33:19] <jj2baile> Heh Yeah. I hope to learn more about rust, but been busy with other things recently
[06:33:21] <acrichto> cmr: I believe that'll work for external crates, just not the local crate
[06:33:28] <cmr> acrichto: in metadata?
[06:33:37] <acrichto> cmr: yeah, resolve uses it as well
[06:33:47] <acrichto> jj2baile: Luqman: again, you two are champions!
[06:34:00] *** Joins: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl)
[06:34:01] <acrichto> tracking down bugs in LLVM is definitely *not* easy
[06:34:05] <cmr> acrichto: there's one in csearch and decoder, which do I look at?
[06:34:16] * cmr is unfamiliar with metadata
[06:34:20] <acrichto> cmr: one just calls the other, I think csearch has the "nicer" interface
[06:34:31] <acrichto> cmr: check out resolve.rs for an example usage
[06:34:55] <acrichto> cmr: but it basically yields *all* fully qualified paths in the external crate and what they refer to
[06:35:01] <cmr> "Iterates over all the paths in the given crate."
[06:35:09] <cmr> acrichto: Ok, this seems to be halfway there
[06:35:09] *** Joins: sebcrozet (sebcrozet@moz-2517AE39.w80-13.abo.wanadoo.fr)
[06:35:11] *** Joins: orshem (orshem@C5E06B1E.A5B6B765.E3D28531.IP)
[06:35:25] <cmr> How do I figure out which one is the path I want though?
[06:35:36] <acrichto> cmr: also, this is apparently the pain point for small crates in why compiling small crates is super slow
[06:35:39] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[06:36:08] <acrichto> cmr: use the def_like thing to get a def_id to get a node_id and compare
[06:36:19] <cmr> oh look at that!
[06:36:24] <cmr> acrichto: Thanks!
[06:36:53] <acrichto> cmr: np :), be warned though that I think pcwalton wants this function to die so the interface may change, it works for now though and the functionality will probably stick around in one way or another
[06:39:19] <cmr> acrichto: Hopefully I can get rustdoc_ng into the tree by then, and then it's his problem ;)
[06:39:43] <strcat> acrichto: seems to have made it past the initial hurdle this time.
[06:39:44] <acrichto> cmr: sounds like a good plan lol
[06:39:53] <acrichto> strcat: \o/
[06:40:17] <strcat> https://github.com/mozilla/rust/pull/8264/files yay deletions ;p
[06:40:41] <strcat> I suspect there's more code I overlooked that I could have removed though
[06:40:45] <acrichto> Luqman: I'm going to re-r+ the commit, see if it gets past the bots this time
[06:40:56] <acrichto> strcat: I'm hijacking your r+ again for the llvm-upgrades
[06:41:02] <strcat> acrichto: that's fine ;]
[06:41:19] <acrichto> strcat: man that's a lot of changes
[06:41:28] <strcat> acrichto: mostly sed s/for/foreach/
[06:41:28] <strcat> er
[06:41:30] <strcat> the other way
[06:41:31] <acrichto> you made github not show changes at the bottom
[06:41:32] <strcat> ;p
[06:41:38] <acrichto> "1 additions, 1 deletions not shown"
[06:41:55] <strcat> heh
[06:42:03] <cmr> More deletions than additions, even better!
[06:42:10] <strcat> cmr: yeah from removing the `for` code.
[06:42:11] * cmr loves when code is removed
[06:42:24] <strcat> there are ~1500 foreach loops being migrated to for
[06:42:25] <acrichto> negative patches always get an r+
[06:42:28] <strcat> and then ~400 deletions
[06:42:48] <strcat> and before this, I had to actually migrate *to* foreach
[06:42:50] <strcat> that was harder.
[06:42:55] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[06:42:59] <strcat> although sed still did ~1100 or 1200
[06:43:09] <strcat> magic
[06:43:45] <strcat> I'm sure there are 'for` bugs we could close but github search is useless
[06:43:52] <strcat> can't search 3 letter words or only search in titles
[06:44:59] <Luqman> acrichto: *fingers crossed*
[06:45:07] <strcat> acrichto: is this updating to 3.3 or HEAD?
[06:45:20] <acrichto> strcat: 3.3 + our patches + one revert
[06:45:24] <strcat> ah
[06:45:24] *** Joins: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net)
[06:45:34] <strcat> it'd be really awesome to catch up to them
[06:45:38] <acrichto> https://github.com/alexcrichton/llvm/tree/llvm-33-with-revert
[06:45:49] <strcat> but I guess there are more issues to deal with ;p
[06:46:16] <acrichto> I may try again in like a week to upgrade llvm
[06:46:19] <joelteon> so it's not possible to clone a function at all...
[06:46:26] <strcat> joelteon: extern fn can be cloned
[06:46:27] <acrichto> if I continually rebase the only problem at that point is waiting for the builds to finish
[06:46:31] <joelteon> but not a non-extern fn
[06:46:39] <joelteon> so you can't send the same fn to two different tasks?
[06:46:47] <strcat> joelteon: an extern fn, yes
[06:46:53] <strcat> closures have an environment
[06:47:10] <joelteon> guess I better go look at extern
[06:47:17] <strcat> and rust won't let you share memory like that (it won't even let you clone them, because not all types can be cloned and the types they capture are not part of their actual type)
[06:47:38] <strcat> rusti: fn foo() {} let x = foo; let y = x.clone();
[06:47:39] -rusti- <anon>:5:38: 5:39 warning: unused variable: `y` [-W unused-variable (default)]
[06:47:40] -rusti- <anon>:5          fn foo() {} let x = foo; let y = x.clone();
[06:47:40] -rusti-                                                ^
[06:47:40] -rusti- ()
[06:47:47] <strcat> rusti: fn foo() {} let x: extern fn() = foo; let y = x.clone();
[06:47:48] -rusti- <anon>:5:51: 5:52 warning: unused variable: `y` [-W unused-variable (default)]
[06:47:48] -rusti- <anon>:5          fn foo() {} let x: extern fn() = foo; let y = x.clone();
[06:47:48] -rusti-                                                             ^
[06:47:48] -rusti- ()
[06:47:51] <Luqman> acrichto: i wonder if i can make clang exhibit the same bug
[06:48:00] <joelteon> oooh
[06:48:10] <joelteon> so you can make an ordinary function an extern fn under some circumstances?
[06:48:25] <acrichto> Luqman: well we can generate an llvm IR which when linked to libstd would reproduce the bug
[06:48:34] <acrichto> Luqman: although the "linking to our libstd" part is bad :(
[06:48:40] <strcat> joelteon: all functions are extern fn - functions can be coerced to closures with no env
[06:48:48] <strcat> &fn/~fn/@fn are closures
[06:48:53] <joelteon> oh
[06:48:56] <joelteon> I see
[06:49:08] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[06:49:24] <strcat> joelteon: in theory ~fn could allow cloning by having a Clone kind but Clone is entirely a library feature so it doesn't exist
[06:49:32] <Luqman> acrichto: yea, that is annoying
[06:49:58] <bblum> http://cppwisdom.quora.com/Yet-another-gcc-bug oh my goodness
[06:50:29] <acrichto> compiler bugs for everyone!
[06:51:12] *** Quits: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net) (Quit: tikue)
[06:51:35] <strcat> bblum: I actually find plenty of bugs in clang
[06:51:40] <strcat> rustc isn't actually that bad ;]
[06:51:58] <acrichto> strcat: well we have at least as many bugs as llvm :P
[06:52:02] <strcat> I always seem to find ways to make clang's name mangling segfault
[06:52:24] <bblum> this one in particular is something close to home
[06:52:35] <strcat> acrichto: pfft, that's what closing things as UPSTREAM is for ;]
[06:52:46] <bblum> a closure that takes a reference to a polymorphic object adds a second destructor call to it
[06:55:48] <acrichto> Luqman: a build just passed locally on check-stage2-std so it may seem that removing that has fixed the issue!
[06:56:00] <acrichto> well "fixed" the issue
[06:56:52] *** Joins: jviereck (Adium@moz-DB8AC6A2.ethz.ch)
[06:56:54] *** Quits: sully (sully@moz-45967CBE.emarhavil.com) (Client exited)
[06:57:23] *** Quits: jensnockert (jensnocker@moz-61E1062F.tbcn.telia.com) (Input/output error)
[06:57:43] <Luqman> acrichto: i may have a patch that doesn't give up FastISel for all div's
[06:58:06] <acrichto> Luqman: oh excellent
[06:58:30] *** Quits: joshua_ (joshua@moz-45967CBE.emarhavil.com) (Ping timeout)
[06:58:42] *** Joins: jviereck1 (Adium@moz-DB8AC6A2.ethz.ch)
[06:58:42] *** Quits: jviereck (Adium@moz-DB8AC6A2.ethz.ch) (Connection reset by peer)
[07:04:15] <joelteon> is there shorthand for [1,2,...,10]
[07:04:29] <Luqman> acrichto: success!
[07:06:27] <strcat> joelteon: not really for a fixed-size array, but yes for a dynamically sized one
[07:06:32] <strcat> range(0, 11).to_owned_vec()
[07:07:40] *** Quits: jviereck1 (Adium@moz-DB8AC6A2.ethz.ch) (Quit: Leaving.)
[07:10:54] <Luqman> acrichto: https://github.com/luqmana/llvm/commit/40b21fbacba7d32c34223d8a98549abfb09c332d
[07:12:36] *** Joins: jviereck (Adium@moz-DB8AC6A2.ethz.ch)
[07:13:02] *** Joins: jensnockert (jensnocker@moz-61E1062F.tbcn.telia.com)
[07:14:56] *** Quits: jviereck (Adium@moz-DB8AC6A2.ethz.ch) (Quit: Leaving.)
[07:15:15] <joelteon> strcat: i can't find range
[07:15:45] <joelteon> oh found it
[07:15:45] <strcat> well in master it's in scope already
[07:16:07] <strcat> rusti: range(0, 10).to_owned_vec()
[07:16:08] -rusti- ~[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[07:16:23] <strcat> rusti: range(0, 10).cycle().take(20).to_owned_vec()
[07:16:23] -rusti- <anon>:5:9: 5:39 error: type `std::iterator::Cycle<std::iterator::Range<int>>` does not implement any method in scope named `take`
[07:16:23] -rusti- <anon>:5          range(0, 10).cycle().take(20).to_owned_vec()
[07:16:23] -rusti-                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[07:16:24] -rusti- error: aborting due to previous error
[07:16:24] -rusti- application terminated with error code 101
[07:16:32] <strcat> rusti: range(0, 10).cycle().take_(20).to_owned_vec()
[07:16:32] <joelteon> never mind, still can't find it.
[07:16:32] -rusti- ~[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[07:17:12] <strcat> it didn't exist in 0.7
[07:17:45] <acrichto> Luqman: oh excellent! let me cherry-pick that in and see if we can commit that insted
[07:18:36] <heftig> strcat: is there a shuffling iterator?
[07:19:01] <strcat> heftig: as in randomly shuffling them? no
[07:19:33] <strcat> cycle doesn't actually build an intermediate data structure, it just clones the iterator state
[07:19:47] <heftig> strcat: wasn't there something like RandomAccessIterator?
[07:19:49] <orshem> heftig: there's shuffle and shuffle_mut
[07:19:54] <orshem> you can call iter() on them
[07:19:59] <strcat> heftig: yeah, but not a mutable version yet with swap
[07:20:19] <heftig> strcat: a RandomAccessIterator has a defined size, right?
[07:20:24] <strcat> heftig: yeah
[07:20:36] <strcat> they can be longer than a uint can represent though
[07:21:00] <heftig> hrm
[07:21:02] <joelteon> hmm
[07:21:09] <strcat> rusti: let xs = [1, 2, 3]; let ys = [4, 5, 6]; let it = xs.iter().chain_(ys.iter()); it.idx(3)
[07:21:10] -rusti- line longer than 150 columns, pastebinned 5 lines of output: http://sprunge.us/ENLA
[07:21:12] <heftig> i thought you could probably build a permutation iterator on that, which has a permutation of that size as its state
[07:21:14] <joelteon> so I understand why the compiler doesn't want me to do this...
[07:21:20] <strcat> rusti: let xs = [1, 2, 3]; let ys = [4, 5, 6]; let it = xs.iter().chain_(ys.iter()); printfln!("%?", it.idx(3))
[07:21:21] -rusti- pastebinned 9 lines of output: http://sprunge.us/UOAO
[07:21:39] <strcat> rusti: use std::iterator::*; let xs = [1, 2, 3]; let ys = [4, 5, 6]; let it = xs.iter().chain_(ys.iter()); printfln!("%?", it.idx(3))
[07:21:39] <heftig> and make a method which creates a "permutation iterator" with a random permutation
[07:21:39] -rusti- Some(&4)
[07:21:39] -rusti- ()
[07:21:44] <acrichto> Luqman: integrated into my llvm-upgrades branch, now it's up to bors
[07:22:02] <strcat> heftig: yeah I think you could do stuff like that with random access iterators, it's just tricky to deal with &mut
[07:22:23] <strcat> random access iterators are pretty immature atm
[07:22:31] <Eridius> who was it that was going to implement reservoir sampling for iterators?
[07:22:32] <strcat> just a token implementation
[07:22:38] <strcat> Eridius: dbaupp, I think
[07:22:41] <heftig> hm, how so? the permutation iterator just creates a bijection
[07:22:54] <heftig> because the size can change?
[07:23:10] <strcat> heftig: because it won't actually let you take two &mut to the same vec
[07:23:27] <strcat> although
[07:23:32] <strcat> I guess you mean layered on top of random access
[07:23:36] <strcat> so that would work.
[07:23:41] <heftig> yes.
[07:24:09] *** Quits: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net) (Ping timeout)
[07:26:47] <Luqman> acrichto: looking at llvm head it seems like it's fixed, so we can just revert my patch once we upgrade to head
[07:27:18] <acrichto> Luqman: do you know the commit on llvm-head which fixed it?
[07:30:47] *** Joins: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP)
[07:30:53] *** Joins: jviereck (Adium@moz-DB8AC6A2.ethz.ch)
[07:31:49] <Luqman> acrichto: https://github.com/llvm-mirror/llvm/commit/cc64dc66e740c0d78ecaca39c33c81b4062edd2e
[07:33:07] <doener> hm, type checking on generics is about 10 times slower than on non-generics
[07:33:20] *** Quits: jgilbert (jgilbert@986623D2.9083A694.9CA62458.IP) (Ping timeout)
[07:34:46] *** Quits: sebcrozet (sebcrozet@moz-2517AE39.w80-13.abo.wanadoo.fr) (No route to host)
[07:34:48] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[07:34:58] *** Joins: anshin (anshin@CD85F10D.F21429E2.354459FA.IP)
[07:35:32] *** Quits: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net) (Input/output error)
[07:36:00] *** Joins: sebcrozet (sebcrozet@moz-C27D92D8.w193-252.abo.wanadoo.fr)
[07:36:51] <anshin> I'm trying to implement sieve of Eratosthenes. How can I initialize a fixed-size vector with e.g. 20,000 booleans (aside from writing true 20k times)?
[07:37:19] <orshem> hi. is there a method like transform that modify the original vec instead
[07:37:24] <orshem> ?
[07:37:43] <doener> anshin: [true, ..20000]
[07:38:02] <acrichto> Luqman: awesome
[07:38:04] <doener> anshin: gives you a fixed-size vector with 20k elements set to true
[07:39:09] *** Quits: jviereck (Adium@moz-DB8AC6A2.ethz.ch) (Quit: Leaving.)
[07:39:10] *** Joins: sully (sully@moz-45967CBE.emarhavil.com)
[07:39:24] <Luqman> acrichto: a bit sad though since we were hitting something that'd already been fixed upstream
[07:39:47] <acrichto> Luqman: hmm.. I'll re-attempt locally to build on an upstream commit
[07:40:02] <strcat> doener: orshem: alternatively you can use extra::bitv, which will be 1/8 as large but slower to access
[07:41:16] <anshin> doener: I tried [true, ..limit], but that didn't work. Can I use a variable that way?
[07:41:44] <Eridius> anshin: no
[07:41:46] <vk> How can the following function be brought up to date?
[07:41:47] <vk> fn render< T: Encodable<Encoder> >(data: &T) -> ~str {
[07:41:49] <vk>   let encoder = Encoder::new();
[07:41:49] <doener> anshin: no, only constants. The bitv works with a variable size, as does std::vec::from_elem(20000, true)
[07:41:50] <vk>   data.encode(&encoder);
[07:41:52] <vk>   self.render_data(encoder.data.take())
[07:41:53] <vk> }
[07:41:55] <vk>  Getting this error, "error: failed to find an implementation of trait extra::serialize::Encoder for Encoder" for the "data.encode(&encoder);" bit.
[07:42:00] <Eridius> anshin: fixed-size vectors requires the size to be known at compile-time.
[07:42:06] <anshin> doener, Eridius: thanks
[07:42:07] <doener> anshin: ... I might have swapped the argument order there
[07:42:10] <Eridius> anshin: if you want the size to be known at runtime, use an owned vector, e.g. ~[]
[07:42:35] <Eridius> anshin: and you can use std::vec::from_elem() to produce an owned vector of a given size with all elements initialized to a given value
[07:42:44] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[07:42:45] *** ChanServ sets mode: +o brson
[07:43:51] <anshin> Exactly what I needed to know. Thanks again
[07:44:15] <orshem> sorry for nagging, but is there a way to do this: let a = [1, 2]; a.iter().map_mut(|x|  x ^= 2); ?
[07:45:17] <strcat> rusti: let mut xs = [1, 2]; for x in xs.mut_iter() { *x += 2 } xs
[07:45:18] -rusti- [3, 4]
[07:45:56] *** Quits: robertknight (robertknig@moz-AB0E96D7.range86-162.btcentralplus.com) (Ping timeout)
[07:46:46] *** Quits: anshin (anshin@CD85F10D.F21429E2.354459FA.IP) (Quit: leaving)
[07:48:10] <orshem> strcat: thanks!
[07:48:17] <strcat> np
[07:49:43] *** Joins: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP)
[07:52:39] *** Joins: webber46 (webber46@moz-717E9C5B.cust.bredband2.com)
[07:54:03] *** Joins: maikklein (maik@moz-B6A68264.dip0.t-ipconnect.de)
[07:54:37] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[07:54:37] <ghrust> 01[13rust01] 15brson 04force-pushed 06try from 141008945 to 143800755: 02http://git.io/k471pw
[07:54:37] <ghrust> 13rust/06try 14a841c97 15Brian Anderson: std::rt: Improve the error message when the thread-local ptr is null...
[07:54:37] <ghrust> 13rust/06try 1436c7d3a 15Brian Anderson: std::rt: Run the tests for Local in a bare thread...
[07:54:37] <ghrust> 13rust/06try 14269edb6 15Brian Anderson: std::rt: 3MB stacks!...
[07:54:38] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[07:55:10] <Luqman> acrichto: applying that patch locally fixes it for me
[07:55:25] *** Quits: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl) (Client exited)
[08:02:25] *** Joins: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net)
[08:02:36] *** Quits: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net) (Quit: eholk)
[08:02:45] *** Joins: jamil_1 (quassel@moz-2FB0F793.wateen.net)
[08:05:03] *** Quits: jamil_1 (quassel@moz-2FB0F793.wateen.net) (Ping timeout)
[08:05:20] *** Joins: jamil_1 (quassel@moz-2FB0F793.wateen.net)
[08:06:02] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Quit: leaving)
[08:07:58] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[08:07:58] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/WZnkbA
[08:07:58] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[08:10:09] *** Quits: maikklein (maik@moz-B6A68264.dip0.t-ipconnect.de) (Ping timeout)
[08:10:56] *** Joins: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com)
[08:10:57] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[08:10:57] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/OXQr5g
[08:10:57] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[08:10:58] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[08:10:58] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/_KTqBg
[08:10:58] <ghrust> 13rust/06auto 14ea84c1f 15Brian Anderson: std: Remove gc and stackwalk...
[08:10:58] <ghrust> 13rust/06auto 14fa5a803 15bors: auto merge of #8218 : brson/rust/nogc, r=brson...
[08:10:58] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[08:10:59] *** Quits: jamil_1 (quassel@moz-2FB0F793.wateen.net) (Ping timeout)
[08:14:32] <jensnockert> \o/ Managed to get some sort of only partially fail build system working \o/
[08:16:35] <acrichto> Luqman: "Attribute 'builtin' can only be used in a call to a function with the 'nobuiltin' attribute"
[08:16:45] *** Quits: jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Quit: zzz)
[08:17:15] <acrichto> Luqman: failure when rebasing patches on llvm-head (8a7f9de9d42)
[08:17:38] <Luqman> acrichto: oh, you're trying to update to head?
[08:17:50] <acrichto> locally yeah
[08:17:51] *** Joins: maikklein (maik@moz-B6A68264.dip0.t-ipconnect.de)
[08:17:54] <acrichto> just to see what happens
[08:19:16] *** Quits: max (Maxdamantu@moz-18510.jetstream.xtra.co.nz) (Ping timeout)
[08:19:53] <acrichto> Luqman: nvmd, it's fast_ffi, forgot to update a constant
[08:21:06] *** Quits: maikklein (maik@moz-B6A68264.dip0.t-ipconnect.de) (Ping timeout)
[08:21:10] <acrichto> FixedStackSegment is probably something that should be upstreamed
[08:22:46] <Luqman> acrichto: did you apply the upstream patch for bors?
[08:23:39] <acrichto> Luqman: not yet, but libstd stage1 just built which hasn't happened before
[08:23:54] <Luqman> oh, with head?
[08:24:24] <acrichto> yeah
[08:24:25] *** Quits: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk) (Ping timeout)
[08:24:29] <acrichto> https://github.com/alexcrichton/llvm/tree/rust-llvm-2013-08-04
[08:24:34] <acrichto> that's the llvm tip that I'm using
[08:24:54] <acrichto> which is all our patches on top of llvm 7 hours ago
[08:25:13] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[08:25:15] <acrichto> oh man this might actually work
[08:25:20] <acrichto> that would be awesome
[08:27:13] <Luqman> \o/
[08:30:04] *** Joins: joshua_ (joshua@moz-45967CBE.emarhavil.com)
[08:31:16] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.1)
[08:34:20] <acrichto> Luqman: ok it made it past stage2 as well, so I'll give it bors and see what happens, I can just peel off the commit if it fails and then try that in bors if so
[08:36:13] <acrichto> anyway, it'll take awhile for bors to get around to it, so I'll check up on it in the morning, thanks again for finding those llvm bugs!
[08:37:20] *** Quits: ab (alex@BC9D99CC.37C1012D.FE617B51.IP) (Ping timeout)
[08:42:57] *** Joins: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk)
[08:43:49] *** Joins: thomaslee (thomaslee@moz-306D3DF4.hsd1.or.comcast.net)
[08:43:59] *** Quits: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP) (Ping timeout)
[08:44:56] *** Joins: Ms2ger (Ms2ger@EDC982F3.6890FC55.187A1082.IP)
[08:47:27] *** Joins: ab (alex@BC9D99CC.37C1012D.FE617B51.IP)
[08:48:11] *** Quits: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net) (Ping timeout)
[08:52:27] *** Joins: dim-an (ermolovd@moz-FE167E47.nationalcablenetworks.ru)
[08:55:09] *** Quits: dim-an (ermolovd@moz-FE167E47.nationalcablenetworks.ru) (Quit: dim-an)
[08:56:04] *** Joins: dim-an (ermolovd@moz-FE167E47.nationalcablenetworks.ru)
[09:00:50] *** Quits: orshem (orshem@C5E06B1E.A5B6B765.E3D28531.IP) (Quit: Leaving)
[09:06:21] *** Quits: Earnestly (earnest@CAE8D902.48DC5685.39C00A7A.IP) (Ping timeout)
[09:07:25] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[09:09:45] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[09:15:14] *** Quits: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk) (Quit: Ex-Chat)
[09:20:35] *** Parts: dim-an (ermolovd@moz-FE167E47.nationalcablenetworks.ru) ()
[09:23:22] *** Joins: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk)
[09:24:29] *** Quits: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk) (Quit: Ex-Chat)
[09:28:52] *** Quits: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net) (Ping timeout)
[09:30:49] *** Joins: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk)
[09:31:38] *** Quits: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk) (Quit: Ex-Chat)
[09:33:08] *** Quits: webber46 (webber46@moz-717E9C5B.cust.bredband2.com) (Quit: webber46)
[09:36:32] *** Joins: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk)
[09:37:27] *** Quits: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk) (Quit: Ex-Chat)
[09:37:57] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[09:37:57] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14fa5a803 to 14fbeeeeb: 02http://git.io/N3iJvQ
[09:37:57] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[09:37:59] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[09:37:59] <ghrust> 01[13rust01] 15bors pushed 8 new commits to 06auto: 02http://git.io/J0ju3g
[09:37:59] <ghrust> 13rust/06auto 14a99c80c 15Brian Anderson: Try to fix a periodic windows build failure due to broken rwildcard macro
[09:37:59] <ghrust> 13rust/06auto 14d786cea 15Alex Crichton: Update LLVM
[09:37:59] <ghrust> 13rust/06auto 14c353cd1 15Alex Crichton: Fix build issues once LLVM has been upgraded...
[09:38:01] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[09:39:23] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Ping timeout)
[09:39:29] *** Joins: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk)
[09:39:41] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[09:40:15] <dbaupp> erickt: ping
[09:42:35] *** Quits: jensnockert (jensnocker@moz-61E1062F.tbcn.telia.com) (Input/output error)
[09:44:26] *** Quits: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk) (Quit: Ex-Chat)
[09:45:33] *** Joins: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net)
[09:48:09] *** Joins: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk)
[09:51:24] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[09:53:21] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[09:54:27] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[10:04:58] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[10:04:58] <ghrust> 01[13rust01] 15bors pushed 1 new commit to 06auto: 02http://git.io/zzBC-w
[10:04:58] <ghrust> 13rust/06auto 14ca3b337 15bors: auto merge of #8282 : brson/rust/more-newsched-fixes, r=brson
[10:04:58] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[10:04:58] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[10:04:58] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14e82fc0b to 14fbeeeeb: 02http://git.io/N3iJvQ
[10:04:58] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[10:09:59] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[10:12:11] *** Quits: RMF (RMF@moz-79BD8246.dsl.telepac.pt) (Ping timeout)
[10:15:50] *** Joins: RMF (RMF@moz-713EF9F4.dsl.telepac.pt)
[10:16:25] *** Quits: tcr (tcr@moz-1C4F4144.hsd1.ma.comcast.net) (Client exited)
[10:29:34] *** Joins: mike (Mibbit@moz-11F9F15.red-83-37-58.dynamicip.rima-tde.net)
[10:29:53] *** Joins: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net)
[10:30:14] <mike> Hi, I need to have      g++ 4.4 or clang++ 3.x     python 2.6 or later (but not 3.x)     perl 5.0 or later     gnu make 3.81 or later     curl to use Rust if I use the windows installer?
[10:31:22] <mike> ?
[10:32:38] <mike> Can anybody answer me?
[10:33:00] <klutzy> using exe installer?
[10:33:05] <klutzy> you need mingw runtime
[10:33:19] <mike> That's all?
[10:33:27] <klutzy> including gcc runtime dll
[10:33:48] <mike> I have codeblocks which installed me Mingw, but I don't know if I have GCC
[10:34:13] <klutzy> it's safe to install msys installer indicated in readme/install doc
[10:34:18] <klutzy> since version may matter
[10:34:58] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[10:34:58] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/QgX2UQ
[10:34:58] <ghrust> 13rust/06auto 14044fa35 15Brian Anderson: rt: Fix a corner-case in unwinding that leads to stack overflow...
[10:34:58] <ghrust> 13rust/06auto 1491b7118 15bors: auto merge of #8217 : brson/rust/reset_stack_limit, r=pcwalton...
[10:34:59] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[10:36:04] *** Quits: mike (Mibbit@moz-11F9F15.red-83-37-58.dynamicip.rima-tde.net) (Quit: http://www.mibbit.com ajax IRC Client)
[10:40:10] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[10:42:20] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[10:44:21] *** Quits: aatch (aatch@moz-2BB0AC01.cable.telstraclear.net) (Quit: Leaving)
[10:46:02] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Ping timeout)
[10:46:16] *** Quits: igl (igl@moz-B96098E6.adsl.alicedsl.de) (Connection reset by peer)
[10:46:43] *** Joins: tcr (tcr@moz-1C4F4144.hsd1.ma.comcast.net)
[10:48:15] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[10:48:26] *** Joins: igl (igl@moz-2E21DE9C.adsl.alicedsl.de)
[10:50:01] <nielsle> In rust you can use fold() to implement sum(). Is there a similar method that allows you to implement cumsum?
[10:50:30] <spider-mario> scan
[10:51:07] <nielsle> Thanks
[10:51:33] *** Joins: orshem (orshem@C5E06B1E.A5B6B765.E3D28531.IP)
[10:52:34] *** Quits: tcr (tcr@moz-1C4F4144.hsd1.ma.comcast.net) (Ping timeout)
[10:57:29] *** Quits: thomaslee (thomaslee@moz-306D3DF4.hsd1.or.comcast.net) (Client exited)
[11:02:57] *** Quits: z0w0 (zack@moz-E12708D5.lns6.woo.bigpond.net.au) (Client exited)
[11:04:14] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[11:06:14] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[11:07:13] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[11:14:52] *** Quits: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net) (Ping timeout)
[11:21:05] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[11:21:07] *** Joins: pupoque (Adium@A31D68F2.552507D8.DA3BB407.IP)
[11:26:28] <dbaupp> orshem: pong
[11:27:17] <orshem> dbaupp: hi, you wrote rand in the standard library... right?
[11:27:31] <dbaupp> orshem: some of it
[11:27:43] <dbaupp> and I've got a proper big rewrite in progress... why? :)
[11:28:16] <orshem> i wanted to prevail on you to change shuffle_mut to return the vector :) so it could be chained
[11:28:37] <orshem> unless you have reasons not to do this
[11:29:29] <dbaupp> I don't have any problems, but it may make lifetimes act strangely... not sure how the borrows would interact.
[11:29:37] <dbaupp> feel free to submit a pull request :)
[11:30:34] <orshem> thanks! even if i add a lifetime variable to chain it all to the original lifetime?
[11:31:13] <engla> the borrow checker doesn't always accept even trivial things like   self.mutator(self.len() + 1)
[11:31:54] <dbaupp> well, the lifetime is required: I could feasibly see that it extends the borrow for too long, and make it awkward to use in general. (I'm not sure; and this is a general problem, not something specific to rand.)
[11:32:05] <dbaupp> engla: just a bug though ;)
[11:32:27] <engla> yes
[11:32:46] <engla> I don't complain, the new borrow checker is much better than the old :)
[11:33:29] <orshem> rusti: use std::rand; fn main() { if 1 != 2  || rand::random() { printfln!("now it works"); } }
[11:33:31] -rusti- ()
[11:33:31] * dbaupp agrees
[11:33:54] <orshem> rusti: use std::rand; fn main() { if | rand::random() || 1 != 2 { printfln!("now it doesn't"); } }
[11:33:55] -rusti- <anon>:5:56: 5:58 error: expected `,` but found `||`
[11:33:55] -rusti- <anon>:5          use std::rand; fn main() { if | rand::random() || 1 != 2 { printfln!("now it doesn't"); } }
[11:33:55] -rusti-                                                                  ^~
[11:33:55] -rusti- application terminated with error code 101
[11:34:04] <orshem> rusti: use std::rand; fn main() { if rand::random() || 1 != 2 { printfln!("now it doesn't"); } }
[11:34:05] -rusti- pastebinned 7 lines of output: http://sprunge.us/OSFj
[11:34:23] <dbaupp> rusti: use std::rand; fn main() { if rand::random::<bool>() || 1 != 2 { printfln!("now it doesn't"); } }
[11:34:23] -rusti- ()
[11:34:50] <orshem> dbaupp: is it a bug in the type inference?
[11:35:01] <dbaupp> it's because type inference only happens left-to-right on operators... and clearly `||` is special-cased to only take bool
[11:35:31] <dbaupp> *isn't
[11:36:12] <orshem> dbaupp, shouldn't it?
[11:36:22] <orshem> only take bools i mean
[11:36:23] <dbaupp> that is, operators need to know the type of their left argument to work out which overloaded implementation to call (and this gives their second argument)
[11:36:29] <dbaupp> orshem: yes
[11:36:51] <dbaupp> *gives the type of their second argument (which is why the first version works.)
[11:37:35] <orshem> so it's not a bug, just a limitation of the system..
[11:38:48] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[11:39:47] <dbaupp> I guess
[11:39:54] <dbaupp> but it's regarded as a bug
[11:40:10] <dbaupp> (and especially so for ||, since it's not overloadable.)
[11:41:00] *** Joins: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net)
[11:41:04] <orshem>  there's already a bug on github?
[11:41:16] * dbaupp doesn't know
[11:41:23] * orshem tried to search couldn't find
[11:42:21] *** Quits: mcclurmc (mcclurmc@moz-8D61EFD1.cable.virginmedia.com) (Quit: Leaving.)
[11:46:02] *** Joins: Earnestly (earnest@CAE8D902.48DC5685.39C00A7A.IP)
[11:51:48] *** Joins: tcr (tcr@moz-1C4F4144.hsd1.ma.comcast.net)
[11:52:15] *** Joins: jensnockert (jensnocker@moz-61E1062F.tbcn.telia.com)
[11:52:59] <SiegeLord> Yeah, so looks like glfw doesn't really solve the issue of OSX requiring event handling on the main thread... I think pcwalton is wrong :P
[11:54:58] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[11:57:39] *** Quits: tcr (tcr@moz-1C4F4144.hsd1.ma.comcast.net) (Ping timeout)
[12:00:54] <dbaupp> https://github.com/mozilla/rust/pull/8284 r?
[12:03:32] *** Joins: rob (Mibbit@moz-11F9F15.red-83-37-58.dynamicip.rima-tde.net)
[12:04:23] <rob> Hi, I have a problem, when I do the example of the Hello? the console appears and disappears
[12:04:50] <kimundi> rob: Which example
[12:05:16] <rob> fn main() {     println("hello?"); }
[12:05:55] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Ping timeout)
[12:06:23] <kimundi> rob: are you compiling the program, running it, and getting a console that appears and dissapears?
[12:06:31] <rob> Yes
[12:06:50] <rob> But only once, is like the program finish and the console dissapears
[12:08:17] <kimundi> rob: well, I know that on windows, if you run a command line program, it opens a console, prints the output, and closes the console again if it finished running
[12:08:37] <rob> how can I avoid this?
[12:08:56] *** Quits: busylizzy (lisa@85228838.12D0DC84.211374C4.IP) (Ping timeout)
[12:09:02] <kimundi> rob: open a console manually, and run the executable from inside that
[12:09:25] *** Quits: heftig (heftig@1103CD12.9A77AED9.3663C14F.IP) (Ping timeout)
[12:09:27] <rob> cool
[12:09:30] <rob> Thanks
[12:09:57] *** Joins: heftig (heftig@327C8F30.EBDCAFC6.FEC4A986.IP)
[12:11:44] *** Quits: rob (Mibbit@moz-11F9F15.red-83-37-58.dynamicip.rima-tde.net) (Quit: http://www.mibbit.com ajax IRC Client)
[12:11:56] *** Joins: busylizzy (lisa@85228838.12D0DC84.211374C4.IP)
[12:12:09] *** Quits: cyndis (cyndis@moz-939B4D35.dy.asm.fi) (Client exited)
[12:12:17] <SiegeLord> And probably the way to disable it would be to do: --linker-args "subsystem windows"
[12:17:00] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[12:17:00] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/QgX2UQ
[12:17:00] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[12:19:59] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[12:20:00] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/aa4GaA
[12:20:00] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[12:20:07] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[12:20:07] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/cuNXvg
[12:20:07] <ghrust> 13rust/06auto 149046516 15Stepan Koltsov: Rename IpAddr -> SocketAddr, extract IpAddr from SocketAddr...
[12:20:07] <ghrust> 13rust/06auto 14f825771 15bors: auto merge of #8243 : stepancheg/rust/ipv, r=brson...
[12:20:08] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[12:26:03] *** Quits: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net) (Ping timeout)
[12:26:37] *** Joins: mcclurmc (mcclurmc@moz-2DBF768A.in-addr.btopenworld.com)
[12:28:59] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[12:28:59] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14f825771 to 1491b7118: 02http://git.io/N3iJvQ
[12:28:59] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[12:29:00] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[12:29:00] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/NogH2A
[12:29:00] <ghrust> 13rust/06auto 148f9c172 15Brian Anderson: Suppress a libuv leak on mac...
[12:29:00] <ghrust> 13rust/06auto 145cf69d5 15bors: auto merge of #8254 : brson/rust/libuv-mac-supp, r=pcwalton...
[12:29:01] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[12:29:04] *** Quits: pupoque (Adium@A31D68F2.552507D8.DA3BB407.IP) (Quit: Leaving.)
[12:37:54] *** Joins: mr_pants (Mibbit@18F3C6F3.8762FF1A.520CDC98.IP)
[12:38:57] <ChrisMorgan> bors seems to be powering through the queue, failing everything (e.g. http://buildbot.rust-lang.org/builders/auto-win-32-opt/builds/747/steps/compile/logs/stdio: g++ not found?). Looks like the build servers are borked?
[12:40:11] <dbaupp> ChrisMorgan: oh, are they all failing with that?
[12:40:24] <ChrisMorgan> Well, that's the IpAddr -> SocketAddr one...
[12:40:33] <dbaupp> yup, and the one before that passed
[12:40:45] <engla> "bash.exe: warning: could not find /tmp, please create!"
[12:40:59] <engla> sounds broken
[12:41:11] <mr_pants> Hi all, i'm trying out the ffi in rust master. i'm using link_args="-lole32", but still get undefined reference error...
[12:41:39] <ChrisMorgan> OK, I didn't look back further... just observed it had been mighty quick with the last few.
[12:42:05] <dbaupp> mr_pants: code?
[12:43:28] <mr_pants> http://mibpaste.com/tBUYLn 
[12:44:39] <mr_pants> HRESULT is type int and IID is [char, ..16]
[12:45:27] <dbaupp> rusti: std::ptr::null::()
[12:45:28] -rusti- pastebinned 6 lines of output: http://sprunge.us/fcFg
[12:45:41] <dbaupp> rusti: std::ptr::null::() as *u8
[12:45:41] -rusti- <anon>:5:9: 5:30 error: cannot determine a type for this expression: unconstrained type
[12:45:42] -rusti- <anon>:5          std::ptr::null::() as *u8
[12:45:42] -rusti-                   ^~~~~~~~~~~~~~~~~~~~~
[12:45:42] -rusti- error: aborting due to previous error
[12:45:42] -rusti- application terminated with error code 101
[12:46:19] * jensnockert hugs mr_pants.
[12:46:45] *** Joins: pupoque (Adium@297D6F99.EF706C30.C0C64AB3.IP)
[12:46:48] <mr_pants> jensockert, thanks but why?
[12:47:17] <jensnockert> You'll need it, working with COM and all.
[12:47:24] <orshem> what is 'Nil' in Rust?
[12:48:13] <mr_pants> jensnockert: thanks, but i get paid for it and also VS makes it bearable
[12:48:14] <Ms2ger> (), Unit
[12:49:34] <engla> () is nil
[12:49:41] <doomlord> "unit" would confuse me because it looks like a typo of "uint"  :)
[12:50:03] <Ms2ger> doomlord, you mean Nat? :)
[12:50:35] *** Joins: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net)
[12:50:36] <dbaupp> Ms2ger: but it's not... because uint is Nat mod 2^64 ;P
[12:50:56] <jensnockert> mr_pants: I'll show you the land of the free (ObjC) sometime <3.
[12:51:03] <Ms2ger> dbaupp, yay, overflow :)
[12:51:49] <orshem> Ms2ger: what is it for? it's not a keyword, but i'm seeing it in Kate rust.xml keyword list
[12:52:11] <Ms2ger> orshem, it's a type with one value, ()
[12:52:12] <jensnockert> mr_pants: But COM is probably as non-bad as you can get in old C++.
[12:52:22] <Ms2ger> orshem, somewhat like 'void' in C
[12:52:23] <jensnockert> (If you want those features)
[12:52:32] <dbaupp> jensnockert: mr_pants has already found the land of the free; they're using Rust. :P
[12:52:35] <mr_pants> jensnockert: ObjC syntax is scary...but i haven't tried any thing serious with it...
[12:52:52] <jensnockert> dbaupp: Rusties like us are slaves to the compiler!
[12:53:07] <jensnockert> dbaupp: It'll beat you down if you get out of line.
[12:53:15] <mr_pants> dbaupp: :) i love rust....thanks guys, for creating such a beautiful language
[12:53:22] * dbaupp <3 rustc
[12:53:56] <orshem> Ms2ger: so usually when i'm writing fn fun() {} it is implied fn fun() -> Nil {}?
[12:54:07] <dbaupp> Ms2ger: fn fun() -> () {}
[12:54:09] <engla> orshem: () is a zero-sized type with only one value, (). It's the return type when you don't specify a return type.
[12:54:11] <dbaupp> *orshem
[12:54:28] <mr_pants> I tried deleting the link_args attribute, still get the same error....i guess gcc is not able to locate the library at all?
[12:54:46] <dbaupp> mr_pants: quite probably
[12:55:01] <dbaupp> orshem: it looks like a bug that `Nil` is in the kate syntax file
[12:55:29] <dbaupp> hm, maybe not
[12:55:48] <engla> Cons Nil  are both in the vim syntax file too
[12:55:50] <mr_pants> http://mibpaste.com/9KuJh1 can someone verify if the order of the args are correct for gcc
[12:55:51] <dbaupp> but is it really worth highlighting extra::list::{Cons,Nil}
[12:55:53] <dbaupp> ?
[12:55:57] <engla> probably
[12:56:14] <dbaupp> ... oh it seems vim and gedit do it too.
[12:56:18] <engla> err, I don't think so. It's probably for extra::list right
[12:56:28] <dbaupp> yeah
[12:56:43] <engla> extra::list is unloved
[12:56:49] *** Joins: tcr (tcr@moz-1C4F4144.hsd1.ma.comcast.net)
[12:57:17] <dbaupp> fwiw, I think they should just be highlighted how emacs does it: anything starting with a capital is a constant/enum variant.
[12:57:23] <engla> I don't see the need to highlight enum variants that are not in the prelude
[12:57:44] <dbaupp> explicitly highlight, you mean?
[12:57:51] <engla> yes
[12:58:29] *** Quits: tcr (tcr@moz-1C4F4144.hsd1.ma.comcast.net) (Ping timeout)
[12:58:46] <orshem> i see. thanks dbaupp engla Ms2ger 
[12:58:54] <orshem> it's an enum const
[12:59:22] <dbaupp> again, fwiw, the emacs mode doesn't even mention Some/None explicitly; seems to be all done by the is-first-letter-caps rule.
[13:00:05] <engla> so it highlights them the same as types then
[13:00:27] <dbaupp> yeah, specifically: ;; CamelCase Means Type Or Constructor
[13:00:27] <dbaupp> (,(rust-re-grabword rust-re-CamelCase) 1 font-lock-type-face)
[13:01:16] <dbaupp> (heh, even the comment is camel-cased.)
[13:01:53] *** Quits: heftig (heftig@327C8F30.EBDCAFC6.FEC4A986.IP) (Ping timeout)
[13:02:18] *** Joins: heftig (heftig@327C8F30.EBDCAFC6.FEC4A986.IP)
[13:03:10] <dbaupp> it seems that buildbot g++ failure was a transient thing (or something to do with that pr); windows passed on the most recent one.
[13:03:15] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Connection reset by peer)
[13:03:36] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[13:03:38] *** Quits: sebcrozet (sebcrozet@moz-C27D92D8.w193-252.abo.wanadoo.fr) (Client exited)
[13:09:07] <ChrisMorgan> Yeah, I'm not sure about that in Vim. I think having at least some things highlighted specially (e.g. Add, Sub, Mul, Some, None, Option, Result, Ok, Err) is nice, but having a general starts-with-a-capital thing isn't necessarily a bad idea.
[13:09:36] <ChrisMorgan> I toyed with what in the Vim syntax is the commented out rustCapsIdent, but didn't switch it on permanently.
[13:10:03] <ChrisMorgan> Then too, that sort of thing will tend to be latin only, but Rust identifiers can be anything. Even small caps ;-)
[13:10:36] <dbaupp> depends on the regex engine
[13:10:45] <dbaupp> e.g. the regex emacs is using is `"[[:upper:]][[:word:][:multibyte:]_[:digit:]]*"`
[13:11:31] <ChrisMorgan> That's a little tricky in Vim, because [[:upper:]] matches lowercase too if 'ignorecase' is set.
[13:11:56] <dbaupp> ah
[13:12:21] <dbaupp> (in any case: [[:upper:]] isn't unicode by default: Ã–aÃ„o; OaAo; highlight differently.)
[13:15:45] <ChrisMorgan> Actually, I'd need to check if that's true. That's what the docs say, but it could be different in a syntax block.
[13:17:49] <ChrisMorgan> Hmm, seems like that doesn't holdâ€”and Vim's [[:upper:]] *is* Unicode.
[13:18:01] <ChrisMorgan> That's good. I can use [[:upper:]] meaningfully.
[13:19:48] <dbaupp> hm... I'm confused, running that regex manually matches both the unicode and ascii idents.
[13:24:03] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[13:24:24] *** Quits: mcclurmc (mcclurmc@moz-2DBF768A.in-addr.btopenworld.com) (Ping timeout)
[13:24:32] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[13:26:14] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[13:28:36] <ChrisMorgan> Can't really help you on emacs configuration... but for Vim it has things like `syn case match` or `syn case ignore` as the equivalent of 'ignorecase', there's probably some similar switch there to indicate that this mode needs to use Unicode matching. It might not by default on account of it being slower.
[13:29:55] <mr_pants> what is the link_name attibute for? can it be used in ffi?
[13:31:01] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[13:32:35] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[13:34:06] *** Joins: mcclurmc (mcclurmc@moz-8D61EFD1.cable.virginmedia.com)
[13:39:33] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[13:41:32] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[13:41:35] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[13:43:58] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Client exited)
[13:57:09] *** Joins: tcr (tcr@moz-1C4F4144.hsd1.ma.comcast.net)
[13:58:34] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[14:02:52] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[14:04:01] *** Joins: thpickert (thpickert@moz-34341F25.dynamic.dsl.tng.de)
[14:04:49] *** Joins: km (quassel@moz-777F24DE.kevinmehall.com)
[14:07:47] *** Joins: azita (Azita@C828EC68.8E67A50A.508D426F.IP)
[14:07:58] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[14:07:59] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/NogH2A
[14:07:59] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[14:08:50] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[14:10:57] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[14:10:57] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/cZ6BAA
[14:10:57] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[14:10:59] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[14:10:59] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/YlBIIA
[14:10:59] <ghrust> 13rust/06auto 140504d7e 15blake2-ppc: std: Speed up str::is_utf8...
[14:10:59] <ghrust> 13rust/06auto 14f7c4359 15bors: auto merge of #8237 : blake2-ppc/rust/faster-utf8, r=brson...
[14:11:00] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[14:17:18] *** Quits: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net) (Ping timeout)
[14:17:40] *** Quits: Earnestly (earnest@CAE8D902.48DC5685.39C00A7A.IP) (Input/output error)
[14:19:40] *** Joins: Earnestly (earnest@CAE8D902.48DC5685.39C00A7A.IP)
[14:24:41] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[14:31:15] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[14:35:15] *** Joins: sebcrozet (sebcrozet@moz-87D51607.w80-13.abo.wanadoo.fr)
[14:36:26] *** Quits: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net) (Ping timeout)
[14:38:55] *** Joins: eagen (eagen@moz-92A457CB.hsd1.mn.comcast.net)
[14:39:33] <SiegeLord> So what's the replacement for the old for foo.advance |(blah,blah)| ?
[14:40:14] <doener> for (blah,blah) in foo
[14:40:15] <kimundi> SiegeLord: for (blah, blah) in foo
[14:40:32] <SiegeLord> k, thanks
[14:40:43] *** Joins: DoomBoom (DoomBoom@6B14631A.ACEC7723.5D1D3FEF.IP)
[14:42:18] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[14:43:40] *** Joins: Nisstyre (wes@moz-FD86289.netflash.net)
[14:48:35] *** Quits: azita (Azita@C828EC68.8E67A50A.508D426F.IP) (Quit: azita)
[14:55:56] *** Quits: sully (sully@moz-45967CBE.emarhavil.com) (Ping timeout)
[14:56:20] *** Joins: sully (sully@moz-45967CBE.emarhavil.com)
[15:00:31] <mr_pants> can i access the io functions when using runtime-less rust. i want to be able to log debug messages
[15:00:35] <mr_pants> ?
[15:02:18] <jensnockert> mr_pants: You should be able to use the Writer implemented on fd_t.
[15:02:59] <jensnockert> Or FILE.
[15:04:53] <SiegeLord> error: found value name used as a type: def_mod({crate: 0, node: 2330}) :?
[15:04:56] <SiegeLord> That's new...
[15:05:58] *** Quits: doener (doener@moz-121949B3.unitymediagroup.de) (Quit: leaving)
[15:07:15] <SiegeLord> https://gist.github.com/SiegeLord/6150614
[15:07:19] <SiegeLord> Is this a bug?
[15:07:38] <mr_pants> jensockert: thanks, any idea if rust decorates name of foreign functions based on calling conventions (http://en.wikipedia.org/wiki/Name_mangling#C_name_decoration_in_Microsoft_Windows). ?
[15:08:28] <mr_pants> I had to use the link_name attribute to tell gcc to emit CoCreateInstance@20 instead of just CoCreateInstance
[15:08:43] <mr_pants> is this the desired behaviour?
[15:09:27] <mr_pants> *rust not gcc
[15:09:50] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[15:10:20] *** Quits: eagen (eagen@moz-92A457CB.hsd1.mn.comcast.net) (Ping timeout)
[15:13:06] <jensnockert> mr_pants: I think the desired behaviour should be that you wouldn't have to add the link_name attribute.
[15:13:19] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[15:13:33] <klutzy> mr_pants: I didn't had to add such options
[15:13:47] <klutzy> mr_pants: https://github.com/klutzy/win32-rust/blob/develop/ll/all.rs
[15:13:48] <jensnockert> But cdecl doesn't have any sigils, so that works at leastâ€¦
[15:14:05] <kimundi> SiegeLord: Bug
[15:14:07] <klutzy> extern "stdcall" is the magic you may want
[15:14:43] *** Quits: tcr (tcr@moz-1C4F4144.hsd1.ma.comcast.net) (Client exited)
[15:14:48] <SiegeLord> This was added recently... I wonder how easy it would be to bisect it
[15:15:55] <SiegeLord> Is there a way to know which revision git was on before I did git pull? :P
[15:17:15] <engla> SiegeLord: git should print something like  A..B  with the commit hashes before and after
[15:17:24] <engla> SiegeLord: or check the reflog for that branch
[15:17:31] <SiegeLord> I think reflog shows what I want
[15:18:27] <SiegeLord> Let me double check that this is not submitted yet...
[15:19:28] *** Joins: tcr (tcr@moz-1C4F4144.hsd1.ma.comcast.net)
[15:20:29] *** Joins: bytewise (bytewise@moz-4A801D04.unitymediagroup.de)
[15:20:56] *** Joins: robertknight (robertknig@moz-AB0E96D7.range86-162.btcentralplus.com)
[15:21:59] *** Quits: tcr (tcr@moz-1C4F4144.hsd1.ma.comcast.net) (Ping timeout)
[15:23:02] <jensnockert> Am I confused, or is the "impl Reader for @Reader { â€¦ }" implementation in io.rs that just calls the same methods on self totally useless, or am I not understanding something? (https://github.com/mozilla/rust/blob/master/src/libstd/io.rs#L189-L205)
[15:23:50] <kimundi> jensnockert: It allows you to pass a @Writer to functions that a generic over T: Writer
[15:24:10] <jensnockert> Ohâ€¦
[15:24:24] <kimundi> A smartponiter doesn't automatically implement the trait of the type it contains
[15:24:26] <jensnockert> So it is a workaround.
[15:24:47] *** Joins: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net)
[15:24:49] <engla> @Reader is a Trait-object
[15:24:56] <jensnockert> ^
[15:25:14] <kimundi> Rgiht meant trait objects
[15:25:30] *** Joins: nano (nano@moz-972880B.superkabel.de)
[15:25:34] <jensnockert> I'll just assume that there is a good reason for that.
[15:26:03] <SiegeLord> A naive implementation is buggy, a non-buggy implementation is complex
[15:26:17] <engla> jensnockert: I think the example is  @Eq as trait object,   (@1 as @Eq).eq(@"hi" as @Eq)  wouldn't make much sense
[15:26:39] <jensnockert> Why not?
[15:26:56] *** Quits: veddan (viktor@moz-C79BC80B.csbnet.se) (Client exited)
[15:26:57] <kimundi> cause you're calling eq with a string and a integer
[15:27:16] <kimundi> something wich neither side has an impl for
[15:27:20] <engla> the respective impl of Eq is written for equal types
[15:28:00] <jensnockert> I agree that it should throw some sort of error, but it makes sense in some way.
[15:28:16] <engla> Will the new rt::io also use @Reader/@Writer objects or does the paradigm change completely (to using generic functions?)
[15:28:17] <jensnockert> But I get the point.
[15:28:34] <kimundi> the problem is basically with any trait function that uses the Self type anywhere else then it's explicit self
[15:28:50] <SiegeLord> Have there been changes with the IO? My old code isn't quite working anymore...
[15:29:05] <kimundi> engla: there's something new that doesn't need traitobjects afaik
[15:29:08] <SiegeLord> let file = io::file_writer(&Path(filename), [io::Create]).get(); gives failed to find an implementation of trait std::clone::Clone for @std::io::Writer:'static
[15:30:00] <engla> SiegeLord: probably the .get() method is the problem. Use unwrap?
[15:30:13] <jensnockert> Yes, change to unwrap.
[15:30:44] <SiegeLord> Ok
[15:31:02] <SiegeLord> And now a whole bunch of borrowcheck errors XD
[15:32:12] <bct> i've just started playing with concurrency - can someone comment on this function? https://gist.github.com/bct/6150669
[15:32:35] <bct> i'm trying to figure out the best way to have the search tasks exit when one of them has found the target
[15:32:35] <SiegeLord> Oh, no... not quite... it's a non-copyable stack closure thing
[15:32:56] <SiegeLord> Is the only solution to use a new closure?
[15:33:27] <engla> SiegeLord: there is some info here https://github.com/mozilla/rust/wiki/Doc-under-construction-FAQ#noncopyable-stack-closures
[15:33:58] *** Quits: heftig (heftig@327C8F30.EBDCAFC6.FEC4A986.IP) (Quit: Quitting)
[15:34:11] <SiegeLord> I see... thanks
[15:39:59] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[15:40:02] <miloshadzic> where is the code for the layout of  the std lib docs?
[15:41:25] <SiegeLord> Hmm... Iterator is not clone-able?
[15:42:39] <kimundi> SiegeLord: Depends on the Iterator
[15:42:51] <kimundi> SiegeLord: Iterator is just the trait
[15:43:04] <SiegeLord> It doesn't derive from Clone, apparently
[15:43:31] <kimundi> There are Iterator adapters than explicitly use clonable iterators
[15:43:49] <engla> at the moment, the closure-using adaptors can't be clonable
[15:43:58] <kimundi> SiegeLord: Well, it's no requisite for a Iterator to be cloneble
[15:44:18] <SiegeLord> Yeah, I guess
[15:44:24] <engla> (i'd like the capture free map, filter etc adaptors to be clonable)
[15:44:42] <SiegeLord> Will the implicit copy come back?
[15:44:51] <engla> also, mut iterators can't be clonable
[15:45:12] <kimundi> SiegeLord, it's still there, just not for generic functions
[15:45:48] <kimundi> no Copy kind that allows you to implicit copy anyway
[15:45:51] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Ping timeout)
[15:46:18] <SiegeLord> It'd be an implicit clone naturally
[15:46:37] <SiegeLord> And I immediately run into the uncloneable map iterator XD
[15:46:52] <SiegeLord> Damn, wonder what's the cleanest way to fix this...
[15:46:56] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[15:46:56] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/YlBIIA
[15:46:56] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[15:47:14] <engla> SiegeLord: if you implement your own map iterator adaptor using extern "Rust" fn you can clone it
[15:47:54] <kimundi> rusti: fn foo() {}; let x: extern "Rust" fn() = foo;
[15:47:55] -rusti- <anon>:5:26: 5:27 warning: unused variable: `x` [-W unused-variable (default)]
[15:47:56] -rusti- <anon>:5          fn foo() {}; let x: extern "Rust" fn() = foo;
[15:47:56] -rusti-                                    ^
[15:47:56] -rusti- ()
[15:48:01] <kimundi> rusti: fn foo() {}; let x: extern "Rust" fn() = foo; x
[15:48:10] <SiegeLord> I guess I'll just convert these iterators to vectors
[15:48:12] <kimundi> rusti: fn foo() {}; let x: extern "Rust" fn() = foo; (x, ())
[15:48:12] -rusti- (, ())
[15:48:19] <kimundi> rusti: fn foo() {}; let x: extern "Rust" fn() = foo; (x.clone(), ())
[15:48:20] -rusti- (, ())
[15:48:23] <kimundi> okay
[15:48:46] <kimundi> Is it possible to make MapIterator generic over the function type?
[15:49:07] <kimundi> so that you can pass in either &fn() or exter "Rust" fn() ?
[15:49:16] <engla> kimundi: I've tried! it needs type hints
[15:49:20] <kimundi> could then have a clone impl for those
[15:49:22] <engla> so it's not worth it I think
[15:49:48] <kimundi> why not?
[15:49:57] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[15:49:57] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/u2QMrw
[15:49:57] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[15:49:57] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[15:49:57] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/SMs80Q
[15:49:57] <ghrust> 13rust/06auto 149046516 15Stepan Koltsov: Rename IpAddr -> SocketAddr, extract IpAddr from SocketAddr...
[15:49:57] <ghrust> 13rust/06auto 1422f9ce4 15bors: auto merge of #8243 : stepancheg/rust/ipv, r=brson...
[15:49:58] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[15:50:09] <engla> because it makes the use of the Map much more inconvenient for the normal case
[15:50:20] <kimundi> how that?
[15:50:33] <engla> because it will need type hints for each closure
[15:50:44] <engla> .transform(|&x: &char| x)
[15:50:48] <engla> etc
[15:50:57] <strcat> and the return value?
[15:51:16] <engla> don't know
[15:52:27] *** Joins: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net)
[15:53:06] <engla> I think all you need to clone &'static fn is just to copy it as POD
[15:54:42] <SiegeLord> What is the preferred way to make a vector from an iterator?
[15:55:14] <SiegeLord> let xs: ~[int] = FromIterator::from_iterator(&mut it); seems a bit stuttery
[15:55:37] <kimundi> SiegeLord: .collect() or .to_owned_vec
[15:55:57] <kimundi> rusti: range(0, 11).to_owned_vec()
[15:55:58] -rusti- ~[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
[15:56:11] <kimundi> rusti: range(0, 11).collect::<~[int]>()
[15:56:12] -rusti- ~[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
[15:56:32] <engla> rusti: range(0, 11).collect::<~[u8]>()
[15:56:33] -rusti- pastebinned 26 lines of output: http://sprunge.us/HIPc
[15:56:45] <engla> just checking 
[15:57:52] *** Quits: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu) (Quit: Leaving)
[15:58:25] <kimundi> rusti: let mut x = ~[0, ..5]; x.extend(range(0, 11)); x
[15:58:25] -rusti- <anon>:5:32: 5:55 error: type `~[<VI1>]` does not implement any method in scope named `extend`
[15:58:25] -rusti- <anon>:5          let mut x = ~[0, ..5]; x.extend(range(0, 11)); x
[15:58:25] -rusti-                                          ^~~~~~~~~~~~~~~~~~~~~~~
[15:58:25] -rusti- error: aborting due to previous error
[15:58:26] -rusti- application terminated with error code 101
[15:58:34] <kimundi> rusti: let mut x = ~[0, ..5]; x.expand(range(0, 11)); x
[15:58:35] -rusti- <anon>:5:32: 5:55 error: type `~[<VI1>]` does not implement any method in scope named `expand`
[15:58:35] -rusti- <anon>:5          let mut x = ~[0, ..5]; x.expand(range(0, 11)); x
[15:58:35] -rusti-                                          ^~~~~~~~~~~~~~~~~~~~~~~
[15:58:35] -rusti- error: aborting due to previous error
[15:58:35] -rusti- application terminated with error code 101
[15:58:58] <SiegeLord> Oh, hmm... somehow I do get implicit cloning
[15:59:01] <kimundi> rusti: use std::iterator::Extand; let mut x = ~[0, ..5]; x.extend(range(0, 11)); x
[15:59:02] -rusti- pastebinned 8 lines of output: http://sprunge.us/fRIS
[15:59:08] <kimundi> rusti: use std::iterator::Extend; let mut x = ~[0, ..5]; x.extend(range(0, 11)); x
[15:59:08] -rusti- pastebinned 8 lines of output: http://sprunge.us/YHRZ
[15:59:12] <SiegeLord> I guess I just changed the type of the iterator in the process of my changes...
[15:59:13] <kimundi> ah, whatever
[15:59:34] <engla> SiegeLord: implicit copies
[16:00:01] <SiegeLord> Will those continue to work in the future?
[16:00:24] <kimundi> the itarator adapters? yeah
[16:00:27] *** Joins: lopal (xnila@moz-B4413CFD.rabatp1-99-57-137-41.wanamaroc.com)
[16:00:42] <engla> I guess so. Implicit copies are kind of expected for  let x = 1; they work the same for let x = range(0, 10);
[16:01:02] <SiegeLord> Great
[16:02:02] <SiegeLord> And one day we'll have Iterable so there'll be no need for .iter()'s everywhere?
[16:02:21] *** Joins: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu)
[16:04:02] *** lopal is now known as _ssl
[16:04:35] <olsonjeffery> rusti: let f = unsafe { 1 }; f
[16:04:36] -rusti- <anon>:5:17: 5:29 warning: unnecessary `unsafe` block [-W unused-unsafe (default)]
[16:04:36] -rusti- <anon>:5          let f = unsafe { 1 }; f
[16:04:36] -rusti-                           ^~~~~~~~~~~~
[16:04:36] -rusti- 1
[16:04:37] <kimundi> SiegeLord: Yeah, thought omitting the iter() for the for loop will still be tricky. But that's an implementation detail
[16:06:43] *** Joins: tautologico (shung@74BFD9C3.5A3A7952.7B974E06.IP)
[16:06:55] *** Parts: _ssl (xnila@moz-B4413CFD.rabatp1-99-57-137-41.wanamaroc.com) (3Back to home 15,1Â‹ 0drissnet 15,1Â‹)
[16:07:24] <tautologico> what's ops::Drop ?
[16:08:41] *** Joins: maikklein (maik@moz-B6A68264.dip0.t-ipconnect.de)
[16:10:02] <olsonjeffery> tautologico: if your type impls the Drop trait, then drop(&self) is when just before an instance of it "deleted" 
[16:10:21] <tautologico> like a finalizer
[16:10:28] <olsonjeffery> dtor, finalizer, yeah
[16:10:38] <tautologico> ok thanks
[16:11:23] *** Quits: jfbk (textual@moz-EEA9CFB3.nyc.res.rr.com) (Ping timeout)
[16:11:50] *** Quits: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net) (Client exited)
[16:12:09] *** Quits: maikklein (maik@moz-B6A68264.dip0.t-ipconnect.de) (Ping timeout)
[16:12:24] *** Joins: samx (sami@moz-48EC0983.dyn.optonline.net)
[16:12:55] *** Joins: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net)
[16:13:34] *** Quits: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu) (Quit: Leaving)
[16:15:11] <mark_edward> why arre types with destructors non-copyable?
[16:17:17] <olsonjeffery> mark_edward: dtors are often used in places where some kind of unsafe teardown/free operation is needed.. for example, in libuv, Drop is impl'd for all of the types that wrap libuv handles
[16:17:35] <olsonjeffery> in this case, if we allowed copying, then a libuv handle would be released twice (which would be bad)
[16:17:44] <olsonjeffery> so tl;dr: double frees are bad
[16:17:58] <mark_edward> olsonjeffery: right i know, but you should be able to choose if a type is copyable or not
[16:18:03] <mark_edward> you can dothis in C++
[16:18:08] <kimundi> mark_edward: Generally, if you have a construtcor, it means you have to do some custom cleanup logic. Making the type non copiable if you impl Drop ensures that bugs that can happen from that don't appear
[16:18:22] <kimundi> mark_edward: Can still do it
[16:18:22] <mark_edward> fstreams are noncopyable but vectors are
[16:18:31] <kimundi> mark_edward: Just implement Clone
[16:18:31] <mark_edward> kimundi: what do you mean?
[16:18:36] <samx> trying to get rust-sdl to compile with master, but getting: error: failed to resolve import `std::task::PlatformThread`.. Anyone know what to replace that with?
[16:18:38] <olsonjeffery> mark_edward: the way you choose is how you implement your type's decl/logic
[16:19:07] <mark_edward> why did we get rid of the copy/ move keywords, btw?
[16:19:17] <kimundi> mark_edward: Unnecessary
[16:19:28] <kimundi> mark_edward: exverything moves per default
[16:19:33] <olsonjeffery> mark_edward: if you want to copy, impl the Clone trait, otherwise moves by default
[16:19:58] <kimundi> mark_edward: and implicit copyable things copy per default
[16:20:12] <mark_edward> but like, copy x is fewer keystrokes than x.clone(), and making it a keyword  makes what's happening more obvious
[16:20:33] <mark_edward> the optimal to me would be everything moves by default, and you can use the copy keyword on things implementing clone
[16:20:39] <mark_edward> if you need a copy
[16:20:53] <mark_edward> semantics would be 100% clear and simpler
[16:20:54] <kimundi> mark_edward: clone will be renamed to copy
[16:21:16] <mark_edward> but nothing should copy implicitly IMO
[16:21:24] <kimundi> foo.copy() vs copy foo ... two keystrokes more, but much better integrated
[16:21:45] <kimundi> mark_edward: You need implicit copies
[16:21:51] <mark_edward> kimundi: what for?
[16:22:12] <strcat> mark_edward: every type in rust can be shallowly copied by-value
[16:22:14] <kimundi> let mut x = 5; let y += x.clone() * x.clone()
[16:22:26] <strcat> for types with destructors, it moves ownership
[16:23:04] <mark_edward> strcat: that isn't copying the
[16:23:07] <mark_edward> *then
[16:23:10] <samx> hmm, DefaultScheduler will do for now I guess
[16:23:25] <strcat> mark_edward: it is copying, it performs a shallow copy from one location to the other
[16:23:33] <strcat> every single type supports it
[16:23:40] <kimundi> mark_edward: implicit copies are just sugar for types where it will not make a differnce 
[16:23:50] <mark_edward> strcat: that seems like exactly what move constructors in C++ does
[16:24:05] *** Joins: igl1 (igl@moz-26DABC9F.adsl.alicedsl.de)
[16:24:11] <mark_edward> strcat: if ownership is moved, then you can't use the original, then it isn't copying
[16:24:16] *** Quits: igl (igl@moz-2E21DE9C.adsl.alicedsl.de) (Ping timeout)
[16:24:19] <strcat> mark_edward: ok look
[16:24:27] <strcat> by-value assignment, passing, etc. is always a shallow copy
[16:24:33] <strcat> if the type has no destructor, you can still use it
[16:24:39] <strcat> if it does, you can't use the source anymore
[16:24:48] <strcat> that's the entire set of rules - there's nothing else to know
[16:25:05] <strcat> well, except that &mut also moves
[16:25:25] <strcat> but that could just be implemented with an empty destructor for any type
[16:26:40] <mark_edward> rusti: struct Point {x: int, y: int} let p = Point {x:1, y:2}; let p2 = p; p
[16:26:40] -rusti- <anon>:5:69: 5:71 warning: unused variable: `p2` [-W unused-variable (default)]
[16:26:41] -rusti- <anon>:5          struct Point {x: int, y: int} let p = Point {x:1, y:2}; let p2 = p; p
[16:26:41] -rusti-                                                                               ^~
[16:26:41] -rusti- {x: 1, y: 2}
[16:27:25] <mark_edward> rusti: struct Point {x: int, y: int} let p = Point {x:1, y:2}; let p2 = p; fmt!{"p: %? \n p2: %?"}
[16:27:25] -rusti- <anon>:5:81: 5:82 error: expected ident, found `{`
[16:27:25] -rusti- <anon>:5          struct Point {x: int, y: int} let p = Point {x:1, y:2}; let p2 = p; fmt!{"p: %? \n p2: %?"}
[16:27:25] -rusti-                                                                                           ^
[16:27:25] -rusti- application terminated with error code 101
[16:27:35] *** Joins: maikklein (maik@moz-B6A68264.dip0.t-ipconnect.de)
[16:27:38] <mark_edward> rusti: struct Point {x: int, y: int} let p = Point {x:1, y:2}; let p2 = p; fmt!("p: %? \n p2: %?")
[16:27:38] -rusti- <anon>:5:77: 6:5 error: not enough arguments to fmt! for the given format string
[16:27:39] -rusti- <anon>:5          struct Point {x: int, y: int} let p = Point {x:1, y:2}; let p2 = p; fmt!("p: %? \n p2: %?")
[16:27:39] -rusti- <anon>:6     };
[16:27:39] -rusti- application terminated with error code 101
[16:27:45] <mark_edward> rusti: struct Point {x: int, y: int} let p = Point {x:1, y:2}; let p2 = p; fmt!("p: %? \n p2: %?", p, p2)
[16:27:46] -rusti- ~"p: {x: 1, y: 2} \n p2: {x: 1, y: 2}"
[16:28:12] <mark_edward> so that was a copy then. i thought things in Rust move by default
[16:28:29] <strcat> mark_edward: it's not really a 'default'
[16:28:32] <strcat> by-value -> shallow copy
[16:28:39] <strcat> that's the only rule, there is no override
[16:29:08] <kimundi> mark_edward: things with destructors move, thnigs without destructors implicit copy
[16:29:12] <strcat> there's no overloading or any trait associated with it, it's automatically implemented for every single type
[16:29:15] <strcat> kimundi: move == copy
[16:29:22] <strcat> you just can't use the source
[16:29:45] <mark_edward> strcat: that's not a copy then! that's not what copy means in any other language i've ever heard of
[16:29:48] <strcat> x = y is a shallow copy for *every single type*
[16:29:58] <kimundi> strcat: implicit copy == copy that leaves source accessible; move == copy that makes source innaccesible
[16:30:02] <strcat> it copies from y into x
[16:30:28] <mark_edward> if you can't use y anymore it moves from y into x
[16:31:22] <strcat> a 'move' is a shallow copy that steals ownership
[16:31:23] <engla> just need to make a difference between conceptual copy and move in Rust, and what happens in the implementation
[16:31:31] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[16:31:39] <strcat> it's still semantically a copy though
[16:32:08] <engla> That's an implementation detail
[16:32:15] <strcat> it's not
[16:32:21] <strcat> it semantically copies from one location to another
[16:32:27] <strcat> it's very visible in the language semantics
[16:32:38] <mark_edward> no it semantically moves from one location to another.
[16:33:05] <mark_edward> you're explanation sems really counter to most other languages, and at least to my intuition
[16:33:16] *** Joins: alisdair (textual@FAD454DC.CDDF2711.C4CBE0CB.IP)
[16:34:14] <mark_edward> that moving say, a vector implies copying some pointer to memory seems like an implementation detail, and semantically what's happeneing is really a move
[16:34:57] <mark_edward> the shallow copy stuff seems to just be confusing the concept
[16:35:00] <engla> Rust the language defines copy semantics and move semantics. Don't introduce a different meaning for 'copy semantics' into the discussion without differentiating it clearly.
[16:35:14] <strcat> it's not a new meaning for it
[16:35:35] <strcat> rust does a shallow copy of an ownership tree - that's the only form of by-value anything built into the language
[16:35:42] *** Joins: Elvis (Mibbit@9E2582D1.203F4B85.BC0068E5.IP)
[16:35:44] <strcat> if the ownership tree has a type with a destructor or &mut, ownership was stolen
[16:35:53] <strcat> rusti: let mut x = ~5; let y = x; x = ~10; (x, y)
[16:35:54] -rusti- (~10, ~5)
[16:36:13] <strcat> you can make it fairly obvious by putting @ into types
[16:37:20] <strcat> rusti: struct Foo { x: @mut int, y: int } let a = Foo { x: @mut 10, y: 3 }; let b = a; *a.x = 15; b
[16:37:21] -rusti- {x: @mut 15, y: 3}
[16:37:22] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[16:37:22] *** ChanServ sets mode: +o dherman
[16:37:47] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[16:37:51] <strcat> rusti: struct Foo { x: @mut int, y: ~int } let p = @mut 10; let a = Foo { x: p, y: ~3 }; let b = a; *p = 15; b
[16:37:52] -rusti- {x: @mut 15, y: ~3}
[16:37:58] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[16:38:18] <Elvis> hello, for uint::range(0,10) | i | { println(i); } can't compile, expected 'in' but found '|',what's wrong??
[16:38:39] <strcat> the old deprecated for loop was replaced
[16:38:46] <strcat> it's 'for pattern in iterator {}' now
[16:38:58] <strcat> rusti: for x in range(0, 10) { printfln!("%d", x) }
[16:38:59] -rusti- pastebinned 11 lines of output: http://sprunge.us/ODRG
[16:39:10] <Elvis> where's the latest docs?
[16:39:18] <strcat> http://static.rust-lang.org/doc/tutorial-container.html#iterators
[16:39:35] <Elvis> thank you!
[16:42:44] <Elvis> also, rust-sdl can't compile in " for uint::range(0,channels as uint) | ch | ", expected ',' but found 'as'
[16:43:30] <Elvis> as is deprecated?
[16:43:41] <strcat> no, but that's not the `for` syntax
[16:43:42] <engla> Elvis: it's the same thing as the previous one
[16:43:44] <strcat> and uint:;range is gone
[16:43:45] <engla> as is not involved
[16:44:13] <Elvis> okay, i see
[16:44:37] <strcat> it's treating that as a pattern so it thinks uint::range is a tuple struct name and wonders why there's "as" instead of a comma
[16:44:41] <mark_edward> rusti: for x in range(0u, 10) { printf!("%u ", x); }
[16:44:41] -rusti- 0 1 2 3 4 5 6 7 8 9 ()
[16:44:54] *** Quits: Earnestly (earnest@CAE8D902.48DC5685.39C00A7A.IP) (Input/output error)
[16:44:56] *** Joins: Earnestly (earnest@CAE8D902.48DC5685.39C00A7A.IP)
[16:45:49] <strcat> anyway going to rewrite/expand the iterator tutorial quite a bit
[16:46:35] *** Joins: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl)
[16:47:34] *** Quits: orshem (orshem@C5E06B1E.A5B6B765.E3D28531.IP) (Quit: Leaving)
[16:47:40] *** Joins: orshem (orshem@C5E06B1E.A5B6B765.E3D28531.IP)
[16:50:11] *** Joins: vilonis (jared@moz-B2CBB8FC.static.snlo.ca.charter.com)
[16:51:20] <benh> Where did the uint:: in uint::range go?
[16:52:14] <engla> std::uint::range is removed, range in the prelude is std::iterator::range
[16:52:15] <mark_edward> benh: i don't think it's tbere anymore.
[16:52:25] <benh> ah
[16:53:16] *** Quits: samx (sami@moz-48EC0983.dyn.optonline.net) (Quit: This computer has gone to sleep)
[16:53:31] <Elvis> I want to play around rust through sprocketnes which is said to show off various rust idioms with a clean codebase, however, I even can't compile rust-sdl it depends, and both said to be compatible with Master branch, really frustrated..
[16:54:00] <benh> >  Keep in mind that this requires a patch to rustc (the no-main patch) and a patched SDL (which I haven't yet submitted upstream because it depends on the Rust patch). So don't expect this to compile quite yet.
[16:54:07] <benh> from pcwalton on reddit
[16:55:08] <orshem> does unsafe rust supports goto?
[16:55:17] <strcat> orshem: no
[16:55:36] <benh> Could you build goto with a macro?
[16:55:39] <strcat> unsafe rust can dereference raw pointers and call functions marked unsafe
[16:55:43] <strcat> benh: you can't
[16:56:01] <strcat> rust could support goto but it would be incredibly hard to analyze in liveness/borrowck
[16:56:05] <benh> oh, right
[16:56:13] <orshem> strcat: that
[16:56:14] <strcat> there *are* labelled breaks
[16:56:19] <strcat> from loops
[16:56:27] <orshem> 's why i thought unsafe would support it
[16:56:39] <strcat> unsafe doesn't have any language features beyond deref of unsafe ptrs
[16:57:02] <strcat> and likely won't have anything else beyond something like placement new
[17:00:11] <sp3d> is there a summary of the current/future behavior/guarantees of &str and ~str w/r/t nul-termination? obviously &str doesn't guarantee it w/ slices, but I thought there was some bits in the implementation of ~str and I'd like to refresh my memory
[17:00:23] *** Quits: StarLight (StarLight@moz-24311389.dynamic.avangarddsl.ru) (Ping timeout)
[17:00:31] <strcat> sp3d: they aren't going to have \0 in the future
[17:00:43] <strcat> if you want it, you'll have to push it yourself or include it in the literal
[17:00:56] <SiegeLord> 5 rustc compiles left in the bisect >_<
[17:00:57] <sp3d> i.e.: right now they always do, but it's not a guarantee for the future
[17:00:58] <sp3d> ?
[17:01:21] <strcat> sp3d: right now ~str tries to keep \0 at the end but it's not necessarily always there
[17:01:27] <sp3d> ah
[17:01:36] <strcat> there are a *lot* of string functions and I'm sure some get that guarantee "wrong"
[17:01:42] <sp3d> makes sense
[17:01:46] *** Joins: mib_tqme6j (Mibbit@moz-E5485A39.dsl.pltn13.sbcglobal.net)
[17:02:08] <strcat> you should assume it's not there though because it will get removed
[17:02:18] <sp3d> thinking about whether a non-allocating str::from_char would be doable, it seems like it might if you take the char by reference and return a &str w/ its lifetime?
[17:02:21] *** Joins: samx (sami@moz-48EC0983.dyn.optonline.net)
[17:02:32] <sp3d> oh, I guess not since ucs32 != utf8
[17:02:39] <sp3d> nuts
[17:02:56] <SiegeLord> Can you have an immovable type?
[17:02:58] <strcat> ideally 90% of the \0-terminated strings you'll be using are going to be Path, and that's going to have to use u8 anyway
[17:03:00] <strcat> SiegeLord: no
[17:03:18] <strcat> every type in rust supports by-value assignment, passing and returning and there's no way to override the behaviour
[17:03:31] <sp3d> yeah, path handling can be a little ugly/tricky in implicitly-utf8 environments like GLib
[17:03:37] <engla> sp3d: a utf-8 encoding of ~[char] will fit inside the space of the vector so I guess it could be possible
[17:03:38] <sp3d> nice to see Rust handling it sanely
[17:03:55] <sp3d> engla: if you consume, yeah
[17:04:07] <strcat> sp3d: the tricky thing about \0 is that it's a valid internal character in unicode strings
[17:04:11] <engla> and do some ugly hacks
[17:04:15] <strcat> so any API using it doesn't support unicode, only a subset
[17:04:31] *** Joins: StarLight (StarLight@moz-2BB01424.dynamic.avangarddsl.ru)
[17:04:33] *** Quits: maikklein (maik@moz-B6A68264.dip0.t-ipconnect.de) (Ping timeout)
[17:04:34] <strcat> that's why ideally you're only using it for paths, since they actually semantically have no interior nul
[17:04:37] <sp3d> strcat: GLib is \0-terminated UTF-8 /everywhere/ :(
[17:04:39] <engla> strcat: that's a pretty minor worry
[17:04:43] <strcat> sp3d: it's not utf-8 :)
[17:04:47] <strcat> they might call it that
[17:04:48] *** Quits: samx (sami@moz-48EC0983.dyn.optonline.net) (Quit: This computer has gone to sleep)
[17:04:56] <sp3d> what else can I call it? :P
[17:05:02] <strcat> engla: it's a nice way to have security holes
[17:05:05] <engla> strcat: linux paths are not utf-8
[17:05:06] <sp3d> gutf8 :P
[17:05:08] <strcat> engla: I know
[17:05:13] <strcat> 13:02:58       strcat | ideally 90% of the \0-terminated strings you'll be using are going to be Path, and that's going to have to use u8
[17:05:29] <strcat> 13:04:34       strcat | that's why ideally you're only using it for paths, since they actually semantically have no interior nul
[17:06:13] <strcat> sp3d: the fun way to turn it into an exploit is to find some code doing something like strcmp
[17:06:19] <strcat> sp3d: so it's only comparing *part* of a string
[17:06:49] <engla> ah, "it" is not ~str
[17:07:05] *** Quits: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl) (Client exited)
[17:07:09] <sp3d> that seems like it would only be exploitable if you mix utf8-proper and \0-terminated-utf8 APIs
[17:07:19] <sp3d> but I'm sure that happens plenty :)
[17:07:25] <strcat> sp3d: it does ;]
[17:07:33] *** Joins: maikklein (maik@moz-B6A68264.dip0.t-ipconnect.de)
[17:07:38] <engla> utf-8 is only an encoding. what is a string is a different concept
[17:07:41] <strcat> for example, C++ strings support interior nul
[17:07:52] <strcat> but they also are always nul-terminated, for compatibility with C
[17:08:15] <mr_pants> is there a way to represent pointers to extern functions in rust?
[17:08:19] *** Quits: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP) (Client exited)
[17:08:22] <strcat> mr_pants: extern "C" fn
[17:08:29] <engla> by the way, golang doesn't think surrogate halves are valid in utf-8
[17:08:43] *** Quits: Earnestly (earnest@CAE8D902.48DC5685.39C00A7A.IP) (Input/output error)
[17:08:45] <engla> it's probably fine to just reject them
[17:08:46] *** Joins: Earnestly (earnest@CAE8D902.48DC5685.39C00A7A.IP)
[17:08:53] <strcat> engla: yeah, we should be as strict as they are about it
[17:09:08] <mr_pants> strcat: I have a *c_void, how do i call the C funtion it points to ?
[17:09:35] <strcat> I don't know if extern "C" fns are callable
[17:10:08] *** Joins: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP)
[17:10:11] <mr_pants> strcat: so unless I know the name of the function, i can't invoke it from rust?
[17:10:20] <engla> if I understand correctly golang doesn't have a specified encoding for their strings. It's just a byte buffer
[17:10:32] <engla> with some functions to work with it as utf8 if you want
[17:10:52] *** Joins: nano (nano@moz-972880B.superkabel.de)
[17:10:59] <strcat> engla: it's guaranteed to be utf-8
[17:11:18] <strcat> they have byte slices for other stuff
[17:11:20] <engla> http://golang.org/pkg/builtin/#string
[17:11:25] <engla> no :(
[17:11:41] <strcat> odd
[17:11:56] *** Joins: boredomist (user@moz-63CF9F31.res-cmts.sesp.ptd.net)
[17:12:04] <strcat> but yet they reject surrogates ;p
[17:12:39] <engla> not in the string type. only in the function called Valid
[17:12:56] <strcat> ah
[17:13:01] *** Quits: busylizzy (lisa@85228838.12D0DC84.211374C4.IP) (Ping timeout)
[17:13:01] <goffrie> that's super weird. imo.
[17:13:07] <engla> http://golang.org/pkg/unicode/utf8/#Valid
[17:13:45] <engla> what I know of their behavior was checked in their nice code runnner ther
[17:14:43] *** Joins: busylizzy (lisa@85228838.12D0DC84.211374C4.IP)
[17:15:16] *** Quits: tautologico (shung@74BFD9C3.5A3A7952.7B974E06.IP) (Connection reset by peer)
[17:18:24] <maikklein> rusti: let mut temp_theta0 =  0.0f;
[17:18:27] -rusti- pastebinned 7 lines of output: http://sprunge.us/VFQX
[17:20:38] <maikklein> these warning are bugs right? https://gist.github.com/MaikKlein/6151057
[17:21:42] <acrichto> maikklein: those are valid b/c you initialize it with 0 which isn't necessary (it's rewritten in both branches of the `if`)
[17:22:00] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[17:23:35] *** Quits: vilonis (jared@moz-B2CBB8FC.static.snlo.ca.charter.com) (Ping timeout)
[17:25:12] <cmr> http://www.youtube.com/watch?v=kPRA0W1kECg
[17:25:40] *** Quits: Elvis (Mibbit@9E2582D1.203F4B85.BC0068E5.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[17:25:53] *** Quits: Houm (Houm@moz-25669AA8.fbx.proxad.net) (Ping timeout)
[17:28:54] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[17:28:54] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/SMs80Q
[17:28:54] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[17:29:06] <mark_edward> acrichto: how good is the thingamajig that doesnt hat analysis? what if you had tons of nesting and branches, would it still pick up on that/?
[17:29:08] <engla> cool cmr 
[17:29:36] <cmr> mark_edward: it is pretty good
[17:29:52] <mark_edward> cmr: cool to know
[17:29:59] <cmr> not perfect yet, but pretty good
[17:30:18] <mark_edward> cmr: is it possible for it to be perfect?
[17:30:52] <acrichto> mark_edward: nmatsakis wrote it I believe, and I have no reason to believe that it's flaky on particularly complicated situations
[17:31:11] <cmr> mark_edward: not sure
[17:31:16] <acrichto> mark_edward: it turns out analyses like that are actually fairly simple, you could probably write out all the rules by hand
[17:31:28] *** Joins: eagen (eagen@moz-92A457CB.hsd1.mn.comcast.net)
[17:31:54] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[17:31:54] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/9x2N_A
[17:31:54] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[17:31:55] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[17:31:55] <ghrust> 01[13rust01] 15bors pushed 8 new commits to 06auto: 02http://git.io/5imE9w
[17:31:55] <ghrust> 13rust/06auto 14a99c80c 15Brian Anderson: Try to fix a periodic windows build failure due to broken rwildcard macro
[17:31:55] <ghrust> 13rust/06auto 14d786cea 15Alex Crichton: Update LLVM
[17:31:55] <ghrust> 13rust/06auto 14c353cd1 15Alex Crichton: Fix build issues once LLVM has been upgraded...
[17:31:57] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[17:32:02] * acrichto crosses fingers
[17:32:22] <strcat> acrichto: oh nice, you got it to work with HEAD?
[17:32:24] <strcat> at least locally
[17:32:31] <acrichto> yeah
[17:32:33] <strcat> awesome
[17:32:51] <strcat> acrichto: hm what happened to simplify-libcalls?
[17:32:51] <acrichto> I'm hopeful :)
[17:33:00] <acrichto> I think llvm removed it?
[17:33:08] <acrichto> I was getting warnings awhile back about it not being a pass
[17:33:13] <strcat> ah
[17:33:18] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[17:33:18] *** ChanServ sets mode: +o dherman
[17:33:19] <strcat> yeah they did
[17:33:27] <strcat> acrichto: I'll update our passes to match clang from HEAD again assuming it lands
[17:33:33] <acrichto> cool
[17:33:37] <strcat> acrichto: SLP vectorize at -O3 and loop-vectorize at -O2 ;]
[17:33:41] <strcat> acrichto: http://permalink.gmane.org/gmane.comp.compilers.llvm.cvs/149330 there it is
[17:34:04] *** Joins: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl)
[17:34:37] *** Joins: azita (Azita@C828EC68.8E67A50A.508D426F.IP)
[17:34:43] <cmr> llvm got updated?
[17:34:53] <acrichto> strcat: oh man our code will be super vecotorized now :P
[17:34:54] <cmr> our llvm that is
[17:34:58] <acrichto> cmr: hopefully soon :)
[17:35:00] <cmr> :D
[17:35:03] <acrichto> it's currently on bors
[17:35:08] <strcat> acrichto: well, not quite yet
[17:35:19] <strcat> acrichto: need to tweak the vector iterator a bit more
[17:35:23] <strcat> and we don't have TBAA yet
[17:35:32] <acrichto> what would get us that?
[17:35:44] <strcat> we need to actually start outputting TBAA metadata nodes
[17:36:02] <strcat> and write ourselves an LLVM pass (it can dynamically load it) to do alias analysis with that metadata 
[17:36:07] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[17:36:18] <strcat> it hands the pass a pair of points and it has to respond NoAlias, MustAlias, MayAlias or PartialAlias
[17:36:18] <acrichto> that'd actually be pretty intense
[17:36:28] <strcat> the pass itself will basically be a stub
[17:36:34] <strcat> it just has to go down a list of rules like...
[17:36:37] <strcat> ~T doesn't alias @T
[17:36:44] <strcat> er
[17:36:48] <strcat> ~T doesn't alias @U ;p
[17:36:55] <strcat> &mut don't alias each other
[17:37:02] <strcat> &mut doesn't alias &
[17:37:15] <strcat> &T where T: Freeze doesn't alias other T: Freeze &T
[17:37:16] <mark_edward> cmr: did you get to look at that code the other day?
[17:37:24] <strcat> acrichto: lots of things like that ;p
[17:37:32] <cmr> mark_edward: I looked at it briefly and went to bed
[17:37:41] <acrichto> strcat: that sounds like the analysis was made for rust yeah
[17:37:45] <mark_edward> cmr: any insights
[17:37:50] <cmr> mark_edward: no, sorry :(
[17:37:59] <acrichto> strcat: whenever you hear that strongly typed languages can be better optimized I think stuff like this is why!
[17:38:02] <strcat> acrichto: http://llvm.org/docs/AliasAnalysis.html yeah
[17:38:11] <mark_edward> cmr: no prob. i just am really conused
[17:38:33] <vladimir-lu> mark_edward: can you describe what being conused feels like? ;p
[17:38:53] <strcat> acrichto: one thing we already do is mark ~T/~[T] parameters as noalias, since that's a parameter attribute
[17:39:06] <strcat> but.... it can only be applied to the pointer passed as the parameter, not ones contained in it
[17:39:14] <strcat> not very powerful.
[17:39:25] <mark_edward> vladimir-lu: not knowing what to do, not even knowing what/where the problem is. could be in padding, could be in the squeezing section, don't know..
[17:39:27] <strcat> also, noalias isn't something we can say about &mut since it aliases @mut and &const ;[
[17:39:32] <strcat> we need actual TBAA
[17:39:37] <acrichto> strcat: yeah it'd be ideal if it just came back to us and said if two types alias
[17:41:19] *** Joins: MiguelD (MiguelD@2ACDA535.A137FB69.46937063.IP)
[17:41:27] <strcat> acrichto: yeah that's what it can do.
[17:41:55] <strcat> acrichto: atm we just have basicaa layered on top of no-aa.
[17:42:15] <strcat> http://llvm.org/docs/AliasAnalysis.html#the-basicaa-pass
[17:42:24] <strcat> anyway that'll be a big win
[17:42:28] <strcat> once vectorizing is on by default
[17:43:18] <strcat> it'd be nice to have some kind of purity mapping to what LLVM wants. it could be *much* more flexible than the awful old pure
[17:43:41] <strcat> it could allow you to modify &mut, @mut, etc. through parameters. that's part of the type signature
[17:43:43] *** Joins: snadon (chatzilla@moz-2C07697A.mc.videotron.ca)
[17:43:58] <strcat> pure fn(x: &mut int) { *x = 10; } // would be totally fine
[17:44:11] <acrichto> strcat: I wonder how much of that could be inferred
[17:44:12] <strcat> just couldn't call non-pure functions (TLS, I/O)
[17:44:27] <strcat> acrichto: the issue with inferring it is that you can't export the knowledge past crate boundaries
[17:44:35] <strcat> because then purity would implicitly be part of your ABI
[17:44:50] <strcat> unless it considered a change in purity to be a change in the ABI
[17:44:51] <acrichto> strcat: it's not a piece of metadata you could calculate and shove into the crate metadata section?
[17:45:04] <strcat> acrichto: no because then a patch level update can change the ABI
[17:45:10] <strcat> if inferred purity changes
[17:45:17] <strcat> I mean... it could be opt-in
[17:45:27] <strcat> --no-stable-abi or --stable-abi
[17:45:31] * strcat shrugs
[17:45:40] <cmr> I'd be quite happy with a --no-stable-abi
[17:45:44] <cmr> That could turn on global inference ;p
[17:45:47] <acrichto> it'd also be nice to have static linking
[17:45:58] <strcat> acrichto: static linking won't actually help analysis
[17:46:09] <strcat> whole program linking would, as in outputting the entire AST of a crate ;p
[17:46:16] <acrichto> it would help abi changes though :P
[17:46:20] <strcat> and then you can mark every function internal
[17:46:23] <strcat> acrichto: yeah ;p
[17:46:31] <strcat> acrichto: but at least it'd be an explicit opt-in
[17:46:37] <acrichto> that I like the sound of
[17:46:49] <strcat> acrichto: LLVM actually has built-in knowledge about most the C functions we use
[17:47:00] <strcat> however we wrap them behind non-inlinable opaque layers
[17:47:05] <strcat> so from the bottom up, rust is opaque to LLVM
[17:47:11] *** Joins: fabiand (fabiand@moz-CE290A87.adsl.alicedsl.de)
[17:47:13] <acrichto> that's sad
[17:47:17] <acrichto> why is that?
[17:47:19] <strcat> segmented stacks
[17:47:32] <strcat> as usual
[17:47:33] <acrichto> b/c we're generating wrappers for the c functions?
[17:47:37] <strcat> acrichto: yes
[17:47:54] <acrichto> I guess there's not a way to say "this function == libc function X"
[17:48:06] <strcat> acrichto: in gcc, yes to some extent
[17:48:08] <strcat> but not llvm
[17:48:15] <strcat> acrichto: but also, it's not really the C function
[17:48:21] <strcat> since it has that built-in segmented stack handling
[17:48:49] <acrichto> btw I've always been curious, where does the segmented stack stuff get initialized?
[17:49:02] <acrichto> like when is the limit of the stack initially shoved into one of the registers
[17:49:13] <strcat> acrichto: every function has a prelude
[17:49:29] <acrichto> yeah but they're comparing against %fs:0xXXX
[17:49:34] <acrichto> where was that initialized
[17:49:45] <strcat> acrichto: __morestack?
[17:49:56] <acrichto> sure one you hit the limit, but the first one?
[17:50:07] <strcat> acrichto: the first task is really a pthread
[17:50:12] <strcat> you have no choice
[17:50:18] <strcat> the OS hands you a regular thread
[17:50:32] <acrichto> oh so pthreads sets it up for you?
[17:50:34] <strcat> the scheduler uses it though afaik
[17:50:42] <strcat> acrichto: well, technically pthread isn't involved
[17:50:54] <strcat> but... the OS just hands you your initial process with an existing stack
[17:50:59] <strcat> it can't be segmented
[17:51:09] <acrichto> strcat: yeah but does it create a magic section of memory which has the stack limit?
[17:51:30] <strcat> acrichto: it doesn't know how big it is
[17:51:46] <strcat> and you can't find out ;p
[17:51:48] <acrichto> but then the first few calls in rust are doing some wild comparison
[17:52:15] <strcat> acrichto: I'm sure it gets initialized to some dummy value
[17:52:31] <acrichto> but by whom?
[17:52:35] <strcat> acrichto: https://github.com/mozilla/rust/issues/1226
[17:52:37] <mark_edward> vectorize?
[17:52:53] <acrichto> strcat: ooooooooooh
[17:52:54] <mark_edward> what sort of stuff is supposed to get autovvectorized?
[17:53:05] <maikklein> any idea how I can write this in a more functional way? https://gist.github.com/MaikKlein/6151190
[17:53:08] <strcat> acrichto: it has a hack to avoid the first one, and then it inits it
[17:53:14] <acrichto> that makes sense
[17:53:25] *** Quits: snadon (chatzilla@moz-2C07697A.mc.videotron.ca) (Client exited)
[17:53:26] <maikklein> looks kinda ugly :(
[17:53:26] <strcat> mark_edward: http://llvm.org/docs/Vectorizers.html
[17:53:38] <strcat> mark_edward: atm rust only has loop-vectorize enabled at --opt-level=3
[17:53:41] <acrichto> noooo llvm
[17:53:47] <strcat> ;[
[17:54:44] <acrichto> gonna try peeling back the update to HEAD
[17:54:56] <cmr> acrichto: I'm having some difficulty with each_path. It works fine, but none of the defs I get from it match the def I'm looking for
[17:55:06] <strcat> mark_edward: it supports SSE{2,3,4.1,4.2}, AVX, ARM NEON, and so on
[17:55:11] <strcat> it's really terrible at NEON though ;p
[17:55:13] <acrichto> cmr: what's the kind of def you're looking for?
[17:55:26] <mark_edward> strcat: cool! what sort of stuff can be vectorized?
[17:55:53] <strcat> mark_edward: there are a bunch of examples on that page
[17:55:55] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[17:55:55] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 149cec403 to 1422f9ce4: 02http://git.io/N3iJvQ
[17:55:55] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[17:55:56] <strcat> of code it can vectorize
[17:55:56] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[17:55:56] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/SCeVww
[17:55:56] <ghrust> 13rust/06auto 14a51e3e4 15BjÃ¶rn Steinbrink: trans_arg_expr: Omit extra copies for rvalues...
[17:55:56] <ghrust> 13rust/06auto 148495ee5 15bors: auto merge of #8262 : dotdash/rust/no_rval_copies, r=pcwalton...
[17:55:57] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[17:56:05] <cmr> acrichto: https://github.com/cmr/rustdoc_ng/blob/wip/clean.rs#L777 is the code
[17:56:18] <mark_edward> strcat: do you think it could get this? https://github.com/MarkJr94/rust-keccak/blob/master/reference.rs#L23-L27
[17:56:29] <cmr> (CRATE_NODE_ID is the current crate)
[17:56:35] <mark_edward> strcat: here is the index macro https://github.com/MarkJr94/rust-keccak/blob/master/reference.rs#L7-L11
[17:56:36] <strcat> mark_edward: no, because rust doesn't tell it that &mut is non-aliasing
[17:56:54] <mark_edward> strcat: will rust eventually do that>
[17:56:58] <strcat> mark_edward: yes
[17:56:59] <mark_edward> *?
[17:57:06] <strcat> although LLVM might be able to figure it out in that *specific* case
[17:57:08] <mark_edward> strcat: how soon is that planned?
[17:57:21] <strcat> mark_edward: it's not on a timetable, there are no plans to implement it
[17:57:32] <strcat> it's a reported issue and it will get done eventually
[17:57:46] <acrichto> cmr: each_path only works for external items, not local crate items, is that what you're wondering?
[17:57:47] *** Quits: brendanc (brendan@moz-CA4BEC19.cs.ubc.ca) (Connection reset by peer)
[17:57:57] <mark_edward> it seems l1ike a pretty good optimization oppor1tunity, i think it'll be really cool wen it comes. isn't it one of the big benefits offered by tHe type system?
[17:58:02] <mark_edward> easy al1ias analysis?
[17:58:10] <strcat> it's not really easy
[17:58:18] <strcat> rust offers a lot of information TBAA can use
[17:58:21] <mark_edward> &mut can't alias right?
[17:58:25] *** Joins: brendanc (brendan@moz-CA4BEC19.cs.ubc.ca)
[17:58:30] <strcat> it doesn't exactly work that way
[17:58:38] <mark_edward> also what's TBAA?
[17:58:49] <cmr> acrichto: No, I'm only using it for external items, but the NodeId in any of the defs it gives doesn't match what I'm loking for
[17:58:51] <mark_edward> and how does it work
[17:58:53] <strcat> type-based alias analysis (TBAA) works by handing you pairs of pointers with the metadata your frontend output
[17:59:04] <strcat> you have to response NoAlias/MayAlias/MustAlias/PartialAlias
[17:59:05] <cmr> https://github.com/cmr/rustdoc_ng/blob/wip/clean.rs#L833 that branch is never taken
[17:59:27] <strcat> where NoAlias means a write to one pointer will not be visible through the other pointer (*or*, both are immutable)
[17:59:46] <strcat> &mut can alias &const (about to be removed) and @mut
[17:59:56] <strcat> simple enough to respond correctly
[18:00:04] <strcat> hard to output the actual metadata.
[18:00:10] *** Joins: steven_is_false (user@C5B76363.1FF1EBF8.1ECA502.IP)
[18:00:11] <mark_edward> strcat: does Rust have enough info to provide that in all cases?
[18:00:18] <mark_edward> (not counting unsafe code*
[18:00:20] <acrichto> cmr: I think it's b/c you're breaking out after the first node, why are you returning `false` a the end?
[18:00:20] <strcat> it doesn't have to provide info 'in all cases'
[18:00:27] <strcat> LLVM will pass it 2 pairs of pointers
[18:00:27] <cmr> acrichto: Oh oops!
[18:00:29] *** Quits: eagen (eagen@moz-92A457CB.hsd1.mn.comcast.net) (Ping timeout)
[18:00:33] <strcat> it can respond MayAlias *every single time*
[18:00:34] *** Joins: hjr3 (hradtke@moz-842BF853.hsd1.ca.comcast.net)
[18:00:36] <strcat> it will be a no-op pass
[18:01:04] <strcat> if it gets passed @T and ~U, it can say NoAlias
[18:01:09] <strcat> or &mut and &mut, & and &mut
[18:01:14] <strcat> and so on.
[18:01:25] *** Joins: moslemsry (dasdasd@6F35388A.4ACDC99D.521C0519.IP)
[18:01:27] *** Quits: moslemsry (dasdasd@6F35388A.4ACDC99D.521C0519.IP) (User has been banned from Mozilla (no spamming here))
[18:01:30] <strcat> mark_edward: it won't vectorize a loop like that because it uses uint::range
[18:01:49] <strcat> uint::range has a huge non-inlined portion
[18:02:18] <strcat> the new range optimizes very well
[18:02:29] <mark_edward> strcat: really? isn't basically a for loop abstraction? and it hought that the iterators often compiled down to simple state machines
[18:02:36] <mark_edward> strcat: oh, just got the last message
[18:02:39] <strcat> mark_edward: uint::range isn't an iterator ;p
[18:02:49] <mark_edward> right!!! i forgot
[18:03:09] <strcat> http://ix.io/73U the new range
[18:03:25] <strcat> LLVM will optimize it as well as for (size_t i = 0; i < n; i++) { } in C
[18:03:56] <cmr> Lack of early return in do-blocks is cramping my style
[18:04:02] <strcat> mark_edward: http://ix.io/73V the old range
[18:04:10] <strcat> cmr: stop using internal iterators ;]
[18:04:15] <cmr> strcat: not my code :p
[18:04:26] <strcat> mark_edward: it's not #[inline] so it's entirely opaque in external crates. *entirely*
[18:04:30] <mark_edward> strcat: that's cool to hear! will there be a RangeStep sort of iterator? that may be useful
[18:04:39] <strcat> LLVM can't reason about what it does, because rust doesn't have purity in the language
[18:04:43] <strcat> mark_edward: eventually, it can't be written atm
[18:04:47] <mark_edward> opaqueness is not good for iterators as far as i know
[18:04:54] <strcat> but really
[18:04:58] <strcat> here's what the old range does:
[18:04:58] <mark_edward> what's holding it back now?
[18:05:18] <strcat> mark_edward: lack of an ability to write a generic range_step because we don't have checked overflow traits
[18:05:29] <strcat> the old ranges were not generic
[18:05:38] <strcat> they were hardcoded for built-in types by generating code with macros.
[18:05:58] <mark_edward> ah i see. thanks for sharing all this information. i don't know if yoU get tired of explaining higns to noobs all the time
[18:06:19] <strcat> it's a 38-line function compiling to a chain of 6 branches with 4 possible loops
[18:06:40] <strcat> and inside those innermost loops, it calls a function through a function pointer (essentially a virtual function call)
[18:06:45] <strcat> it's terrible ;]
[18:07:10] <mark_edward> yeah i see how that isn't good for the poor optimizer
[18:07:24] <strcat> mark_edward: well the optimizer can't do anything because it's external
[18:07:30] <maikklein> rusti: ~[1,2,3,4].iter().fold(0,|a,&b| a+b)
[18:07:34] -rusti- pastebinned 11 lines of output: http://sprunge.us/PCaX
[18:07:38] <cmr> acrichto: Alright it works! Except the path it gives me doesn't include the crate name
[18:07:41] <strcat> it sees an external function call, rust doesn't mark it readonly/readnone since we don't have purity, and that's it - it can't do anything
[18:07:47] <cmr> so I'm getting like option::Option rather than std::option::Option
[18:07:51] <maikklein> rusti: let v = ~[1,2,3,4]; v.iter().fold(0,|a,&b| a+b)
[18:07:52] -rusti- 10
[18:07:58] <acrichto> cmr: you have the crate number, so you should be able to look it up via that
[18:08:02] <cmr> I think that's an easy fix though, just made the CrateNum to name
[18:08:04] <cmr> yeah
[18:08:10] <acrichto> cmr: althoug if you do "extern mod std2(name = 'std')"
[18:08:15] <acrichto> I'm not sure what it would give you
[18:08:24] <acrichto> probably std2
[18:09:13] <cmr> the crate_dep has the name, version, and hash in it, as well as the crate num
[18:09:36] <acrichto> oh then that's probably the true name
[18:09:38] <cmr> It seems all of the decoder functions want a buffer of the metadata though
[18:09:41] <mark_edward> is rust supposed to have purity eventually, or is that not planned?
[18:09:51] <cmr> mark_edward: https://github.com/mozilla/rust/wiki/Proposal-for-effects
[18:09:54] <steven_is_false> The nice thing about external iterators is that they let one write in an FRP sort of style http://gitorious.org/p-x/p-x/blobs/master/src/core/engine/simulator.rs#line125
[18:10:01] <acrichto> cmr: I think the csearch function is the "more usable" interface
[18:10:12] <cmr> acrichto: which csearch function?
[18:10:16] * cmr didn't see anything obvious
[18:10:38] *** Parts: steven_is_false (user@C5B76363.1FF1EBF8.1ECA502.IP) (ERC Version 5.3 (IRC client for Emacs))
[18:10:40] <acrichto> cmr: oh it may not exist, I've normally interfaced with csearch instead of decoder directly
[18:11:21] <cmr> Oh hm, I think I want cstore::get_crate_data
[18:12:46] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[18:13:30] <doomlord> i was trying to figure out resolving of method calls myself
[18:14:54] <doomlord> wasn't sure if the relevant info was cached all the way out into ctxt_ .. i saw some other places that might have it
[18:15:05] <acrichto> engla: I was looking at #8265, and could the iterators returned in bitv.rs be typedef'd to be used elsewhere possibly?
[18:17:27] <mark_edward> Rust code is so pretty to look at
[18:17:36] <mark_edward> i bet that was a major design goal :P
[18:18:20] <doomlord> grep-ability also means good for syntax highligting :)
[18:18:33] <strcat> mark_edward: oh range_step_core is actually #[inline]
[18:18:40] <strcat> anyway
[18:19:27] <strcat> http://ix.io/73W
[18:19:31] <mark_edward> doomlord: how's your work with jumping to definitions goign?
[18:20:12] <engla> acrichto: these are internal methods, but yes, they probably want to be type aliased if they are used further
[18:20:12] <doomlord> got something working but at the minute grep is still ore useful, lol. my code handles function-calls and struct defs, but not method calls ...
[18:20:27] <doomlord> ... i needed to dig further to figure out how to resolve the types for those
[18:20:45] <engla> acrichto: there are other methods in bitv to convert, but these were actually used and needed to be converted to drop old for
[18:21:07] <acrichto> engla: oh maybe that could happen at another time then
[18:21:22] <mark_edward> doomlord: that's still absolutely great progress! what's harder about methodd calls? and maybe you could get someone more familiar with the compiler to help you?
[18:21:28] <mark_edward> this seems liek a very worthy project
[18:21:32] <doomlord> basically the methods in the  "ctxt_" object have some 'transformed_self_type", i can't figure out how those relate to the type in the method calls in the AST
[18:21:56] <mark_edward> i see
[18:22:11] <mark_edward> acrichto: would you be able to help doomlord?
[18:22:12] <doomlord> its something to do with generic-type substitutions
[18:22:45] <acrichto> doomlord: so what are you looking at?
[18:23:05] <doomlord> i'm trying to make a 'jump to definition' tool using libsyntax. functions / structs work fine
[18:23:34] <doomlord> i can't resolve method calls  - getting from the receiver type to the 'transformed_self_type' in the method info in ctxt_
[18:23:54] <doomlord> let me check my comments... i had a break from this when i ran into that, after some random digging... 
[18:24:08] <acrichto> doomlord: wouldn't you need to run resolve to figure out the definition point?
[18:24:40] <doomlord> i presume so, i cut-paste a starting point from 'rustdoc_ng' code, which seems to run the compiler and return a "ctxt_"
[18:25:09] *** Joins: veddan (viktor@moz-C79BC80B.csbnet.se)
[18:25:13] <acrichto> doomlord: where is this "transformed_self_type" ? I'm not seeing it in rust at all
[18:25:35] <doomlord> 1min while i find my comments... struct Method or something like that
[18:26:11] <acrichto> doomlord: ah transformed_self_ty
[18:26:17] <doomlord> sorry yes
[18:26:20] <engla> acrichto: now or later, either is fine. I just wanted to remove that MapE abomination (cutely replaced with Repeat)
[18:26:32] <doomlord> something to do with generic type params it seems
[18:27:17] <acrichto> doomlord: so you're having trouble taking a Method and finding the point of definition?
[18:27:23] <doomlord> correct
[18:27:43] <acrichto> doomlord: so taking the def_id and looking it up in the ast_map to get the span isn't working?
[18:27:55] *** Joins: rust-noob (Mibbit@moz-72A1FE21.hiway.at)
[18:27:58] <doomlord> https://github.com/dobkeratops/rustfind <<< here's my code, 
[18:28:29] <doomlord> I'm not sure i got a def_id from it, perhaps there's something obvious i didnt' try
[18:28:49] <acrichto> oh do you not have the actual Method struct?
[18:29:05] <rust-noob> hi! I just compiled Rust (trunk) and started playing around with it. But I can't find out how to do the following: print the numbers from 1 to 100
[18:29:20] <rust-noob> I know this is trivial, but I really can't get it to work :/
[18:29:28] <mark_edward> rusti: for x in range(0, 100) { printf!("%u ", x); }
[18:29:28] -rusti- pastebinned 9 lines of output: http://sprunge.us/bHLH
[18:29:33] *** Quits: dw (dmw@5D5650A6.59C24325.3C3EAB72.IP) (Quit: leaving)
[18:29:38] <rust-noob> thanks ;)
[18:29:45] <mark_edward> rusti: for x in range(0, 100) { printf!("%d ", x); }
[18:29:46] -rusti- line longer than 150 columns, pastebinned 1 lines of output: http://sprunge.us/TJUJ
[18:29:50] <doomlord> yes, i'm not sure i can even get to a  Method struct..  from a "expr_method_call" node
[18:29:57] <mark_edward> rust-noob: the second one is correcty
[18:30:01] <mark_edward> *correct
[18:30:19] <acrichto> doomlord: oh if all you have is an expr_method_call then you'll want to look up the node in some resolve table
[18:30:22] <doomlord> in my rustfind.rs in that github repsitory, the attempts are at line 327
[18:30:47] <acrichto> doomlord: I believe that resolve figures out what's calling what by shoving it in some map
[18:30:48] <doomlord> yes , i even wondered if ctxt_ has what i need ("resolve table", i seemed to find other intermediates .. "CrateCtxt" etc
[18:31:10] <mark_edward> how would i subscribe to the rust mailing list, btw?
[18:31:45] *** Quits: hjr3 (hradtke@moz-842BF853.hsd1.ca.comcast.net) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[18:31:59] <acrichto> doomlord: oh wait have you checked callee_id?
[18:32:15] <doomlord> https://github.com/dobkeratops/rustfind/blob/master/rustfind.rs#310 << line 297 fn lookup_def_of_node_in_tree
[18:32:28] <bytewise> mark_edward, https://mail.mozilla.org/listinfo/rust-dev
[18:32:38] <mark_edward> bytewise: thanks :)
[18:32:48] <rust-noob> ah ok!
[18:33:01] <doomlord> "node_in_tree" is an array holding the requested node and all its parents (my universal node type, enum AstNode...)
[18:33:16] <doomlord> DocContext holds a ctxt_ , session .. ?
[18:33:55] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[18:34:19] <acrichto> doomlord: what you want is the typeck::method_map
[18:34:25] <doomlord> whats "callee_id"
[18:34:28] <acrichto> doomlord: that's filled in with (expr.id) => Method
[18:34:48] <acrichto> doomlord: the first parameter of an expr_method_call variant is the callee_id, although I'm not entirely sure what it's used for
[18:35:56] <doomlord> expr_method_call(callee_id , .... ) =>   ?
[18:36:06] <jensnockert> Is there any way I can convert a [u8, ..4] to a &[u8] ?
[18:36:12] <doomlord> method_map.find(callee_id ) ... ?
[18:36:15] <acrichto> doomlord: yeah, but what you want is the method_map table generated by typeck
[18:36:24] *** Quits: rust-noob (Mibbit@moz-72A1FE21.hiway.at) (Quit: http://www.mibbit.com ajax IRC Client)
[18:36:25] <jensnockert> Preferably without any copies.
[18:36:52] <acrichto> doomlord: no, I think it's expr.id
[18:37:04] <doomlord> ok
[18:37:09] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[18:37:15] <acrichto> doomlord: https://github.com/mozilla/rust/blob/master/src/librustc/middle/typeck/check/mod.rs#L1402
[18:37:19] <acrichto> that may be of interest to you
[18:37:22] <acrichto> to see how things are done
[18:37:40] <acrichto> doomlord: I gotta run for a bit, but I'll be back in about a half hour
[18:38:10] <doomlord> ok its a case of how to get a "method_map" then. i have a "ctxt_", "Session", ....
[18:38:51] <doomlord> rg method_map
[18:38:53] <doomlord> oops
[18:38:56] *** Quits: azita (Azita@C828EC68.8E67A50A.508D426F.IP) (Quit: azita)
[18:39:31] <joelteon> where are the "serial" and "pod" modules?
[18:39:39] <joelteon> flatpipes says to use the constructors found there to make pipes
[18:40:10] *** Joins: q66_ (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[18:41:07] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Ping timeout)
[18:42:03] <doomlord> "FnCtxt" ... seems to have a method_map aswell.. do i need one of those..
[18:42:25] <mark_edward> doomlord: i hope you and arichto can solve your problem together, i want to see you make progress
[18:43:13] <doomlord> yes i'd like this too, navigation tools count for a lot
[18:43:29] <maikklein> do you think this would be useful someone? https://github.com/MaikKlein/RustMachineLearning
[18:43:38] *** Quits: q66_ (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Ping timeout)
[18:44:00] <vk> Hey all, could someone explain this error to me? "error: failed to find an implementation of trait extra::serialize::Encoder for Encoder", it's happening on this bit of code:
[18:44:01] <vk>     fn render< T: Encodable<Encoder> >(&self, data: &T) -> ~str {
[18:44:03] <vk>         let encoder = Encoder::new();
[18:44:04] <vk>         data.encode(&encoder);
[18:44:06] <vk>         self.render_data(encoder.data.take())
[18:44:07] <vk>     }
[18:44:09] <vk> on the "data.encode(&encoder);" line.
[18:45:06] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[18:45:50] *** Joins: hjr3 (hradtke@moz-842BF853.hsd1.ca.comcast.net)
[18:47:32] <joelteon> no, seriously, how do you make a FlatPipe
[18:47:45] <joelteon> ohh, flatpipes::pod
[18:47:47] <joelteon> of course.
[18:50:28] *** Quits: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net) (Ping timeout)
[18:50:55] *** Joins: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net)
[18:53:09] *** Joins: gareth0 (gareth0@moz-2AD95705.dynamic.dsl.as9105.com)
[18:54:54] <engla> vk: Encoder is just a trait, not a type(?)
[18:55:08] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[18:58:17] <acrichto> doomlord: were you able to find the method_map?
[18:58:36] <vk> engla: So it seems, not entirely sure how to work with traits. Updating https://github.com/erickt/rust-mustache as a project to learn Rust.
[18:58:37] <doomlord> i can see it in source code, i certainly dont have a method map myself
[18:58:54] <doomlord> I'm seeing a "FnCtxt" containing the 'method_map'
[18:58:58] *** Joins: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch)
[18:59:12] <acrichto> doomlord: up to what point are you invoking rustc?
[18:59:31] *** Quits: maikklein (maik@moz-B6A68264.dip0.t-ipconnect.de) (Ping timeout)
[18:59:48] <doomlord> i get a "ctxt_ from calling "driver::driver::compile_upto(... cu_no_trans...)
[19:00:19] <acrichto> you must be on an older version of the compiler I think, currently phase_3_run_analysis_passes will return the method_map
[19:00:29] <acrichto> it's inside of astencode::Maps
[19:00:58] *** Parts: pupoque (Adium@297D6F99.EF706C30.C0C64AB3.IP) ()
[19:00:59] <doomlord> ok i'll need to update....
[19:01:05] *** Quits: mib_tqme6j (Mibbit@moz-E5485A39.dsl.pltn13.sbcglobal.net) (Quit: http://www.mibbit.com ajax IRC Client)
[19:01:39] <engla> vk: to create a new encoder you need a concrete type
[19:01:54] <doomlord> i dont find any "phase_3_run_analysis_passes" when i grep
[19:02:25] <acrichto> doomlord: what version are you currently on?
[19:02:32] <acrichto> sfackler: is there an open issue for to/from hex?
[19:02:42] <doomlord> rustc 0.8-pre
[19:02:58] <acrichto> doomlord: have you updated to master recently?
[19:03:12] <doomlord> no.. i dont think i've updated in weeks at least
[19:03:18] <doomlord> so here goes, update..
[19:03:19] <acrichto> yeah it's a fairly recent thing
[19:04:42] <doomlord> will that get the new for too :)
[19:05:06] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[19:05:06] *** ChanServ sets mode: +o dherman
[19:05:44] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Ping timeout)
[19:05:44] *** Quits: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk) (Client exited)
[19:07:37] *** Quits: mark_edward (quassel@981AA104.E81F12CD.76F66111.IP) (Ping timeout)
[19:12:51] *** Quits: mr_pants (Mibbit@18F3C6F3.8762FF1A.520CDC98.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[19:12:52] *** Joins: pupoque (Adium@297D6F99.EF706C30.C0C64AB3.IP)
[19:13:41] <joelteon> where's the definition of the Send trait
[19:14:33] <acrichto> joelteon: it's a built-in trait I believe, but you can find it in src/libstd/kinds.rs
[19:15:09] <joelteon> can I automatically derive Send?
[19:15:34] <acrichto> type analysis is run to determine whether your type ascribes to Send
[19:15:49] <acrichto> if it's something like a struct then it should be Send if all constituent fields are also Send
[19:15:56] <acrichto> (at least that's how I think it works)
[19:16:03] <joelteon> ok
[19:16:08] <joelteon> and to be Send, it has to be all owned?
[19:16:36] <acrichto> I believe so yes
[19:16:52] <acrichto> I think the trait's life cycle has been Send => Owned => Send
[19:16:54] <acrichto> naming-wise
[19:17:17] <joelteon> ok
[19:17:21] <joelteon> this doesn't make any sense
[19:17:42] <joelteon> I want to send a PipeChan to multiple tasks at once so they can all write to it
[19:17:55] <joelteon> but apparently you can't do that
[19:20:53] *** Quits: gareth0 (gareth0@moz-2AD95705.dynamic.dsl.as9105.com) (Quit: Leaving)
[19:21:03] *** Joins: gareth0 (gareth0@moz-2AD95705.dynamic.dsl.as9105.com)
[19:21:04] <strcat> acrichto: Owned didn't really make sense though
[19:21:11] <strcat> arcs are non-owned and yet are sendable
[19:21:29] <acrichto> seems like Send is a more proper name then :)
[19:21:33] <joelteon> I guess that's why, for par::map, they have to be Clone + Send
[19:21:35] *** Joins: jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net)
[19:21:35] <strcat> @/@mut and Rc/RcMut are non-sendable, so ownership is correlated with it
[19:21:35] *** Quits: gareth0 (gareth0@moz-2AD95705.dynamic.dsl.as9105.com) (Quit: Leaving)
[19:21:46] <joelteon> I feel like it would make sense that a PipeChan would be clonable
[19:21:58] <joelteon> then messages sent to that chan would all go to the same endpoint
[19:22:49] <strcat> acrichto: I guess you'll have to bisect that LLVM issue ;\
[19:23:14] <strcat> or maybe there's more than one
[19:23:37] <doomlord> still rebuilding here ..
[19:23:53] *** Joins: gareth0 (gareth0@moz-2AD95705.dynamic.dsl.as9105.com)
[19:24:09] *** Quits: gareth0 (gareth0@moz-2AD95705.dynamic.dsl.as9105.com) (Quit: Leaving)
[19:24:12] <acrichto> strcat: it'll be kinda difficult yeah b/c it's bisecing LLVM but each commit to bisect also has to have our patches added on top
[19:24:17] *** Joins: gareth0 (gareth0@moz-2AD95705.dynamic.dsl.as9105.com)
[19:24:34] <acrichto> it may just be something that's better to just try every week or so and see if LLVM has fixed it :P
[19:24:36] <joelteon> but hey
[19:24:43] <joelteon> if PipeChan isn't clonable right now
[19:24:44] <strcat> acrichto: I don't really think so
[19:24:45] <joelteon> I can't do this
[19:24:52] <strcat> acrichto: we'll fall further behind and it will be harder to catch up
[19:24:54] <strcat> it might be *our* bug
[19:25:12] <acrichto> true, I'll try to look into it once 3.3 lands
[19:25:15] <acrichto> if it lands...
[19:25:18] <strcat> heh
[19:26:00] <joelteon> is there any data structure that is designed to receive input from multiple threads at once?
[19:26:04] <joelteon> like, can I make an actor in Rust?
[19:27:09] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[19:28:20] *** Quits: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl) (Client exited)
[19:28:43] <doomlord> ok rebuilt, and i have a "phase_3_run_analysis_passes" function in my rust sourcetree now
[19:29:27] <doomlord> (session,crate)->CrateAnalysis, nice
[19:31:09] <doomlord> CrateAnalysis.maps.method_map, i guess thats what i'm after, so i'll rework my code to use this..
[19:32:12] *** Quits: n0v (n0v@moz-690FFF9D.org) (Quit: ZNC - http://znc.in)
[19:34:30] *** Joins: mark_edward (quassel@moz-9631ECE3.public.wayport.net)
[19:34:43] *** Joins: n0v (n0v@moz-690FFF9D.org)
[19:35:19] <mark_edward> rusti: for x in [1,2,3,4,5,6,7,8,9].mut_iter() { printf!("%d ", x); }
[19:35:20] -rusti- pastebinned 9 lines of output: http://sprunge.us/eOVH
[19:35:36] <mark_edward> rusti: for x in [1,2,3,4,5,6,7,8,9].mut_iter() { printf!("%d ", *x); }
[19:35:37] -rusti- pastebinned 11 lines of output: http://sprunge.us/VORe
[19:36:18] <mark_edward> rusti: let xs = ~[1,2,3,4,5,6,7,8,9]; for x in xs.mut_iter() { printf!("%d ", *x); }
[19:36:19] -rusti- <anon>:5:49: 5:51 error: cannot borrow immutable vec content as mutable
[19:36:19] -rusti- <anon>:5          let xs = ~[1,2,3,4,5,6,7,8,9]; for x in xs.mut_iter() { printf!("%d ", *x); }
[19:36:19] -rusti-                                                           ^~
[19:36:19] -rusti- error: aborting due to previous error
[19:36:19] -rusti- application terminated with error code 101
[19:36:29] <mark_edward> rusti: let mut xs = ~[1,2,3,4,5,6,7,8,9]; for x in xs.mut_iter() { printf!("%d ", *x); }
[19:36:30] -rusti- 1 2 3 4 5 6 7 8 9 ()
[19:36:56] <mark_edward> doomlord: how is it goign? been having connection problems wiht my VPN
[19:37:09] <orshem> hi, can somebody take a look if what i'm trying is even possible: https://gist.github.com/dovreshef/6151620
[19:38:42] *** Quits: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch) (Quit: Leaving.)
[19:38:46] <kimundi> Urk, okay this is bad
[19:39:02] <kimundi> half the codebase uses Option::get()
[19:39:10] *** Joins: Desk (Sohbet@DD8C86D1.D6CCDCB.782529C2.IP)
[19:39:11] <kimundi> the other half Option::unwrap()
[19:39:25] <mark_edward> kimundi: what codebaese?
[19:39:32] <sfackler> rusti: let mut s = ~""; unsafe { std::str::raw::push_byte(&mut s, 97); } s
[19:39:32] -rusti- ~"\x00"
[19:39:34] <kimundi> mark_edward: rust
[19:39:38] <Seldaek> we're getting closer to the new docs.. now extra and std are there: http://seld.be/rustdoc/master/
[19:39:41] <sfackler> am I crazy, or is push_byte totally broken?
[19:40:01] <engla> kimundi: because they were different before Copy was removed
[19:40:14] <doomlord> i've had some useful advice, i needed to update and now i'm reworking code,some fixes for the updated rustc.. (new for)
[19:40:15] <mark_edward> orshem: try changing the root function to fn root<'self>
[19:40:17] <kimundi> engla: Sure, but now they're not, and the result is bad :P
[19:40:28] <doomlord> there's a new structure that contains what i need.. 
[19:40:37] <acrichto> sfackler: looks like a bug in push_byte
[19:40:43] <acrichto> sfackler: (looking at the push_byte code)
[19:40:44] <Eridius> sfackler: it appears to be broken
[19:40:59] <engla> kimundi: I hope .unwrap() stays because .get is a very generic name
[19:41:00] <Eridius> sfackler: specifically, it overwrites the new null byte at the end of the increased capacity string, because of how as_mut_buf works
[19:41:14] *** Joins: samx (sami@moz-48EC0983.dyn.optonline.net)
[19:41:26] <kimundi> Anyway... I hope I'm not annoying anyone to much with this, but I just opened a second pull request that renames all get() to unwrap()
[19:41:41] <kimundi> (The first one does the opposite)
[19:42:08] <mark_edward> doomlord: that's cool!
[19:42:10] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (No route to host)
[19:42:22] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[19:42:38] <doomlord> there's a load of renaming cleanups to deal with (crate-> Crate node_id->NodeId etc :) .. all for the best i know, more consistent..)
[19:44:00] <erickt> vk: thanks for updating rust-mustache!
[19:44:09] <erickt> vk: let me know if you need help
[19:44:13] *** Joins: Jesse (jruderman@moz-104CC309.mv.mozilla.com)
[19:44:18] <mark_edward> i see. well i hope all goes well\
[19:44:19] <doomlord> heh easy refactoring, for anyone all who doubts the value of type-inference..
[19:44:21] <orshem> mark_edward: i get "error: illegal lifetime parameter name: `'self`"
[19:45:14] <vk> erickt: hey, was just about to send you an email actually. Still stuck on the issue from earlier, about "fn render< T: Encodable<Encoder> >(&self, data: &T) -> ~str {".
[19:45:28] <mark_edward> orshem: try  fn root<'r>(&mut self) -> &mut Tree<'r>
[19:45:49] <erickt> vk: can you repeat the problem you're seeing?
[19:45:52] <mark_edward> orshem: and this too: fn root<'r>(&'r mut self) -> &mut Tree<'r>
[19:46:02] <vk> erickt: sure, sec
[19:46:56] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[19:46:56] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/SCeVww
[19:46:56] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[19:47:22] <vk> erickt:
[19:47:23] <vk>     fn render< T: Encodable<Encoder> >(&self, data: &T) -> ~str {
[19:47:25] <vk>         let encoder = Encoder::new();
[19:47:26] <vk>         data.encode(&encoder);
[19:47:28] <vk>         self.render_data(encoder.data.take())
[19:47:29] <vk>     }  
[19:47:30] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[19:47:31] <vk> error: failed to find an implementation of trait extra::serialize::Encoder for Encoder
[19:47:32] <vk> " data.encode(&encoder);"
[19:47:56] <orshem> mark_edward, loads more errors :( i feel like i'm casting some spell where i have to get the incantation right :)
[19:48:30] <engla> strcat: did you have any more comments on my iterator fixes PR?
[19:48:31] <vk> erickt: engla mentioned needing a concrete type, trying to figure out how to go about that.
[19:48:37] <mark_edward> im not sure how to help... what you want to do is possible, i just an't remember exactly how
[19:48:38] <strcat> engla: sec
[19:48:46] *** Quits: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net) (Client exited)
[19:48:52] <mark_edward> orshem: what are the errors you get with my second suggesgtion
[19:48:55] <orshem> mark_edward: thanks anyway
[19:49:16] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[19:49:16] <ghrust> 01[13rust01] 15thestinger pushed 2 new commits to 06master: 02http://git.io/4u4aCg
[19:49:16] <ghrust> 13rust/06master 14cdad7f6 15Huon Wilson: etc: add the `in` keyword to the emacs mode.
[19:49:16] <ghrust> 13rust/06master 14b49d026 15Daniel Micay: Merge pull request #8284 from huonw/emacs-in-kw...
[19:49:17] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[19:49:18] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[19:49:39] <orshem> mark_edward: i gotta go, supper! i'll ping you later
[19:49:42] <doomlord> visitor seems to have changed since i updated - i see "oldvisit::Visitor", i'm hoping that'll keep my old code working?
[19:49:48] *** Quits: orshem (orshem@C5E06B1E.A5B6B765.E3D28531.IP) (Quit: Leaving)
[19:49:55] <mark_edward> okay cool
[19:49:55] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[19:49:55] <ghrust> 01[13rust01] 15bors merged 06master into 06auto: 02http://git.io/4u4aCg
[19:49:55] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[19:49:55] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[19:49:56] <ghrust> 01[13rust01] 15bors pushed 7 new commits to 06auto: 02http://git.io/GiXdTw
[19:49:56] <ghrust> 13rust/06auto 149ae0658 15Brian Anderson: Try to fix a periodic windows build failure due to broken rwildcard macro
[19:49:56] <ghrust> 13rust/06auto 141d06aaa 15Alex Crichton: Update LLVM
[19:49:56] <ghrust> 13rust/06auto 148d29367 15Alex Crichton: Fix build issues once LLVM has been upgraded...
[19:49:57] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[19:50:38] <strcat> acrichto: hopefully it lands...
[19:51:38] <erickt> vk: can you push your work up to a repository so I can check it out?
[19:52:01] <vk> erickt: https://github.com/vkorapaty/rust-mustache/blob/0.8pre-update/mustache.rs
[19:52:12] <doomlord> anyone know what "ty_method" became
[19:52:37] <erickt> vk: thanks
[19:54:25] *** Quits: Ms2ger (Ms2ger@EDC982F3.6890FC55.187A1082.IP) (Quit: nn)
[19:55:49] <erickt> vk: this line, https://github.com/vkorapaty/rust-mustache/blob/0.8pre-update/mustache.rs#L175, should be `impl serialize::Encoder for Encoder`
[19:56:42] *** Quits: fabiand (fabiand@moz-CE290A87.adsl.alicedsl.de) (Quit: Verlassend)
[19:56:44] <erickt> might be best to change `use extra::serialize::*;` to `use extra::serialize` and use the full serialize::Foo paths to avoid name collision
[19:57:43] <vk> erickt: aye, giving that a try.
[20:00:04] *** Joins: SeRaaP`19 (eun@521FE5BA.DF9153E9.37339E3A.IP)
[20:00:04] *** Joins: herkuI (uvb@521FE5BA.DF9153E9.37339E3A.IP)
[20:00:04] *** Joins: holy-girl (tnc@521FE5BA.DF9153E9.37339E3A.IP)
[20:00:04] *** Joins: kiraIik (fmnn@9EB6DBF6.49BA3049.49CEED6B.IP)
[20:00:04] *** Joins: fiLiz- (gqphu@9EB6DBF6.49BA3049.49CEED6B.IP)
[20:00:04] *** Joins: banu_cuk (qjagb@9EB6DBF6.49BA3049.49CEED6B.IP)
[20:00:04] *** Joins: S_e_L_i_N (dxo@moz-77042182.hsd1.ga.comcast.net)
[20:00:04] *** Joins: bIueman (uxe@moz-77042182.hsd1.ga.comcast.net)
[20:00:04] *** concrete.mozilla.org sets mode: +R 
[20:00:06] *** Quits: holy-girl (tnc@521FE5BA.DF9153E9.37339E3A.IP) (User has been banned from Mozilla (no spamming here))
[20:00:06] *** Quits: SeRaaP`19 (eun@521FE5BA.DF9153E9.37339E3A.IP) (User has been banned from Mozilla (no spamming here))
[20:00:06] *** Quits: herkuI (uvb@521FE5BA.DF9153E9.37339E3A.IP) (User has been banned from Mozilla (no spamming here))
[20:00:06] *** Quits: fiLiz- (gqphu@9EB6DBF6.49BA3049.49CEED6B.IP) (User has been banned from Mozilla (no spamming here))
[20:00:06] *** Quits: kiraIik (fmnn@9EB6DBF6.49BA3049.49CEED6B.IP) (User has been banned from Mozilla (no spamming here))
[20:00:06] *** Quits: banu_cuk (qjagb@9EB6DBF6.49BA3049.49CEED6B.IP) (User has been banned from Mozilla (no spamming here))
[20:00:06] *** Quits: S_e_L_i_N (dxo@moz-77042182.hsd1.ga.comcast.net) (User has been banned from Mozilla (no spamming here))
[20:00:06] *** Quits: bIueman (uxe@moz-77042182.hsd1.ga.comcast.net) (User has been banned from Mozilla (no spamming here))
[20:00:06] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[20:00:06] *** ChanServ sets mode: +o dherman
[20:00:58] *** Quits: Desk (Sohbet@DD8C86D1.D6CCDCB.782529C2.IP) (Quit: )
[20:01:02] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[20:02:18] <vk> erickt: getting "error: unresolved name `Encoder::new`" on "let encoder = Encoder::new()" after updating things.
[20:02:18] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Connection reset by peer)
[20:02:22] *** Quits: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP) (Quit: victorporof)
[20:03:37] *** Quits: paulproteus (quassel@rose.makesad.us) (Ping timeout)
[20:04:58] *** Quits: hjr3 (hradtke@moz-842BF853.hsd1.ca.comcast.net) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[20:05:02] *** concrete.mozilla.org sets mode: -R 
[20:05:16] *** Joins: paulproteus (quassel@moz-E86A3B42.makesad.us)
[20:07:58] <engla> vk: you need to 'use super::*' or something similar inside the tests module; it doesn't have access by default
[20:08:12] <engla> for example to the method new which is private
[20:08:17] *** Joins: kud1ing (Mibbit@moz-EEC1DBE2.pools.arcor-ip.net)
[20:09:10] <kud1ing> i have a rustpkg question
[20:09:57] <kud1ing> there is a `src/sqlite/lib.rs` containing a `#[crate_type = "lib"];`
[20:10:17] <kud1ing> a `rustpkg build sqlite` gives `error: main function not found`
[20:10:28] *** Quits: samx (sami@moz-48EC0983.dyn.optonline.net) (Quit: This computer has gone to sleep)
[20:10:32] <kud1ing> am i missing something?
[20:10:43] <kud1ing> or is this a bug?
[20:12:06] <thpickert> Maybe it's rustpkg build --lib sqlite?
[20:12:20] <thpickert> kud1ing: ^
[20:12:35] <kud1ing> nope
[20:12:36] <thpickert> If it's not that, I'm already out of my depth. \o/
[20:12:44] <vk> engla: where can I find more info on super?
[20:12:51] <SiegeLord> kud1ing: Do you have a lib.rs?
[20:13:00] <SiegeLord> Hmm, you do...
[20:13:02] <kud1ing> rustpkg is expecting main.rs and lib.rs to disinguish between exectuable and libraries
[20:13:14] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[20:13:28] <kud1ing> thanks anyway :)
[20:13:59] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[20:16:03] <kud1ing> i have opened #8290
[20:17:37] *** Quits: kud1ing (Mibbit@moz-EEC1DBE2.pools.arcor-ip.net) (Quit: http://www.mibbit.com ajax IRC Client)
[20:18:14] <engla> vk: not sure! It's not in the module. In 0.6 release notes we have ""The super and self can be used in paths to refer to parent modules and the current module, respectively.""
[20:18:38] <engla> *It's not in the _manual_
[20:19:47] <vk> engla: aye, tried finding it there, had no luck. I'm guessing there are some examples of its use in the rust repo somewhere?
[20:20:03] *** Quits: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP) (Connection reset by peer)
[20:20:38] *** Joins: hjr3 (hradtke@moz-842BF853.hsd1.ca.comcast.net)
[20:20:41] <engla> yes, you'll find  use super::* in a lot of tests modules
[20:20:52] <engla> across libstd and other places
[20:21:05] *** Joins: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP)
[20:21:10] <vk> engla: I'll take a look at those.
[20:21:23] *** Joins: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP)
[20:32:28] *** Joins: ChemicalHarm (Mibbit@moz-A9F37238.hsd1.md.comcast.net)
[20:32:30] *** Joins: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP)
[20:33:58] *** Joins: maikklein (maik@moz-E6B4E665.dip0.t-ipconnect.de)
[20:34:18] *** Quits: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP) (Ping timeout)
[20:36:05] *** Quits: vladimir-lu (vladimir-l@moz-428433D9.cable.virginmedia.com) (Quit: WeeChat 0.4.0)
[20:37:13] *** Quits: hjr3 (hradtke@moz-842BF853.hsd1.ca.comcast.net) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[20:39:30] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[20:40:25] *** Joins: tikue (tkuehn@moz-CF8BEBEF.dia.static.qwest.net)
[20:41:14] *** Quits: jensnockert (jensnocker@moz-61E1062F.tbcn.telia.com) (Input/output error)
[20:41:44] *** Joins: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net)
[20:42:12] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[20:46:36] <mark_edward> doomlord: wazzap
[20:46:46] <mark_edward> updated code o work with master?
[20:47:05] <doomlord> i've reworked it yes, at least it still does what it did before...
[20:47:27] *** Quits: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net) (Quit: eholk)
[20:47:30] *** Joins: steven_is_false (user@C5B76363.1FF1EBF8.1ECA502.IP)
[20:47:33] <doomlord> ... now i'm trying out the new info .. "CrateAnalysis::method_map"  ... seems to be what i'm after..
[20:48:10] <steven_is_false> The current binding to OpenGL ES from Servo is kind of incomplete.
[20:48:18] *** Quits: alisdair (textual@FAD454DC.CDDF2711.C4CBE0CB.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[20:48:22] <steven_is_false> I've been looking at different options.
[20:49:22] <doomlord> i spat out my own desktop gl bindings using the original function names.. i felt more comfortable with gl coding looking exactly the same as c
[20:49:40] <doomlord> ^original function names, enums.. glBlahBlah instead of gl::blah_blah etc
[20:49:40] *** Joins: samx (sami@moz-48EC0983.dyn.optonline.net)
[20:49:51] <steven_is_false> doomlord: I plan on writing my own high level wrapper around them anyways.
[20:50:08] <doomlord> something that could wrap gl/d3d ? that sort of level ?
[20:50:20] <doomlord> i guess it would make more sense to have that idiomatically rust-like
[20:50:31] <steven_is_false> doomlord: Lower level than that. Basically, a type safe wrapper around OpenGL.
[20:50:47] <steven_is_false> Which is extremely difficult so I need to use advanced techniques like phantom types.
[20:51:01] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Ping timeout)
[20:51:06] <doomlord> fair enough. i think i want a gl/d3d wrapper, and which can look the same called from C++ and rust ... some subset of c++
[20:51:34] <doomlord> i sort of have a layer like that in my c++ engine, i'm doing a c++ binding generator.. but haven't tried it out on real code yet :)
[20:51:52] <steven_is_false> doomlord: Are you using Clang to parse it?
[20:52:04] <steven_is_false> Here's my high level binding http://gitorious.org/p-x/p-x/blobs/master/src/core/engine/gl.rs
[20:52:05] <doomlord> yes 
[20:52:07] *** Joins: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net)
[20:52:23] <mark_edward> doomlord: if u get a C++ binding engine working youll be my hero
[20:52:35] <doomlord> i dont want to promise too much there :)
[20:53:04] <doomlord> it can make some sort of sense of templated collection classes, but i certainly wouldn't say "it handles templates!!"
[20:53:46] <mark_edward> still though that's really impressive
[20:53:52] <doomlord> eg C++ side    class  Foo { Vector<Vertex> vertices; }   ===>.  rust side    struct Foo { Vector<Vertex> vertices; }
[20:54:12] <steven_is_false> doomlord: How do templates work?
[20:54:40] <doomlord>  if you want to take a look its on my github https://github.com/dobkeratops/cpp2rust
[20:54:52] <steven_is_false> doomlord: Thanks.
[20:55:19] <doomlord> so, I'm only aiming at handling a subset of templates to represent *collection classes* and *smartpointers* - i figured thats really useful for exchanging data represented in c++
[20:55:37] <Seldaek> any clue how to sort this one out (using master)? 
[20:55:38] <Seldaek> printenv/printenv.rs:61:12: 61:28 error: mismatched types: expected `&(~str,~str)` but found tuple (types differ)
[20:55:39] <doomlord> i make a rust view of those, by pretty printing what clang sees
[20:55:41] <Seldaek> printenv/printenv.rs:61         for (env_var, value) in vars.iter() {
[20:55:46] *** Quits: Jesse (jruderman@moz-104CC309.mv.mozilla.com) (Quit: Jesse)
[20:56:40] <doomlord> as you can guess there's a lot it *doesn't* handle, and some roough edges, its spitting out "struct Typename" in some places i just want "Typename", i dont think i have mut/const sorted yet..
[20:57:16] <doomlord> but its writing out C++ -> C method wrappers and "impls" for c++ member functoins, and  those impl's call the C method wrappers
[20:57:51] <doomlord> i should have looked into swig really, i'm re-inventing a subset of  that , but figured going directly from c++/clang->rust might be useful for me
[20:57:56] <mark_edward> doomlord: that's still rally sweet, even what you  ave so far. are you  using textual analuysis? or something like clang?
[20:58:03] <doomlord> clang
[20:58:08] <mark_edward> nice]
[20:58:50] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[20:59:24] <doomlord> i figure i can re-work my own c++ code to the limits of this tool :) 
[20:59:43] <doomlord> i'm not about to try and spit out Qt bindings for rust or anything..
[21:00:17] <mark_edward> doomlord: think you could spit out Ogre3D bindings? :P
[21:00:49] <doomlord> does it use overloading.. or default parameters.. or templated functions ... 
[21:01:02] <doomlord> if the answer is "yes" .. the answer is certainly "no" :)
[21:01:03] <goffrie> Seldaek: you may want `for &(~ref env_var, ~ref value) in vars.iter()`
[21:01:31] *** Quits: samx (sami@moz-48EC0983.dyn.optonline.net) (Quit: This computer has gone to sleep)
[21:01:42] <goffrie> actually not sure about the ~ref
[21:01:54] <doomlord> i might try some hacks for overloading like postfixing argument count, _types.. assuming the first method it finds is 'default'..
[21:02:26] <Seldaek> goffrie: I tried with &, didn't help, but let's see with those ~ref
[21:02:54] <goffrie> Seldaek: looks like it won't work, oops. what's the error if you put just &(env_var, value)?
[21:03:01] <doomlord> i had a bash at adding something similar to rust-bindgen, but found myself struggling more with their ast construction
[21:03:04] *** Joins: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP)
[21:03:30] <mark_edward> maybe you could handle overloading with auomatic function renaming???
[21:03:42] <Seldaek> goffrie: no indeed it doesn't, with &(env_var, value) I get: error: cannot move out of dereference of & pointer
[21:03:57] <goffrie> Seldaek: ah, most likely you want &(ref env_var, ref value), so env_var and value are &~str (then they should auto-slice to &str when used)
[21:04:05] <doomlord> yes something should be possible
[21:04:29] <doomlord> someone else said they've already tried making one big tupple of all the arguments.. and it doesn't work ..
[21:04:40] <Seldaek> goffrie: that yields error: mismatched types: expected `&str` but found `&~str` (expected &str but found &-ptr)
[21:04:51] <mark_edward> doomlord: that sounds cool
[21:05:15] <Seldaek> goffrie: it was working fine in 0.7 with &(a, b)  as the arg of the for loop closure, but now it's confusing me to death :)
[21:05:22] <goffrie> Seldaek: ok, then you may have to use `env_var.as_slice()` instead of `env_var` :)
[21:05:55] *** Quits: sebcrozet (sebcrozet@moz-87D51607.w80-13.abo.wanadoo.fr) (Client exited)
[21:06:05] <Seldaek> goffrie: I guess you mean that on the vars.as_slice().iter()?
[21:06:22] <Seldaek> because on env_var, it's not even syntaxically correct
[21:06:50] <goffrie> Seldaek: sorry, I mean when you _use_ env_var inside the loop
[21:07:32] *** Quits: gareth0 (gareth0@moz-2AD95705.dynamic.dsl.as9105.com) (Ping timeout)
[21:07:32] <Seldaek> goffrie: oh, let's see
[21:08:42] <Seldaek> goffrie: nope still doesn't help.. that's the complete code https://gist.github.com/Seldaek/6151963
[21:09:08] *** Quits: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP) (Ping timeout)
[21:09:26] <strcat> Seldaek: you're trying to move out of a reference you don't own
[21:09:38] <strcat> take ()
[21:09:41] <strcat> not &()
[21:10:03] <strcat> if you have &T and T is non-copyable, you can't deref and move out a value
[21:10:06] <goffrie> rusti: let vars = std::os::env(); for &(ref env_var, ref value) in vars.iter() { printfln!("%s=%s", env_var.as_slice(), value.as_slice()); }
[21:10:08] -rusti- pastebinned 6 lines of output: http://sprunge.us/YHaR
[21:10:14] <joelteon> rust-lang.org says rust supports the actor pattern. are there any examples of that yet?
[21:10:41] <Seldaek> strcat: I tried that (and everything I could think of really), getting mismatched types: expected `&(~str,~str)` but found tuple (types differ)
[21:10:59] <strcat> Seldaek: you need &(ref x, ref y) then
[21:11:03] <goffrie> Seldaek: ^ that works, or if you don't need vars anywhere else you can use `for (env_var, value) in vars.consume_iter()`
[21:11:06] <strcat> if they are both ~str
[21:11:57] <jeaye> Is there an analogous __LINE__ and __FILE__?
[21:11:58] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[21:11:58] *** ChanServ sets mode: +o dherman
[21:12:10] <goffrie> strcat: if we had DST, would it be possible to use `for &(~ref a, ~ref b) in ...` ?
[21:12:49] <Seldaek> goffrie: hm ok, consume_iter is indeed the easiest, thanks
[21:13:07] <Seldaek> strcat: &(ref x, ref y) also failed, but goffrie's solution works
[21:13:35] <strcat> his solution was &(ref x, ref y)
[21:13:40] <strcat> deref the tuple, but don't move out
[21:14:02] <strcat> since you can't move out of a reference, you can only a) copy out or b) take another ref
[21:14:17] <engla> jeaye: yes, line!() and file!()
[21:15:07] <jeaye> engla: Are there any others like it?
[21:15:17] *** Joins: Florob (Florob@moz-39532932.de)
[21:15:26] <kimundi> rusti: line!()
[21:15:27] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[21:15:27] -rusti- 5
[21:15:27] <Seldaek> strcat: yes, but his solution requires as_slice() too.. does that "copy out"? 
[21:15:33] <kimundi> rusti: file!()
[21:15:34] -rusti- "<anon>"
[21:15:39] <engla> rusti: col!()
[21:15:39] -rusti- 9
[21:15:50] <engla> there is col!() :)  don't know others
[21:16:00] <strcat> Seldaek: no, it doesn't
[21:16:06] <strcat> it coerces ~str to &str
[21:16:19] <Seldaek> ah so it remains a ref
[21:16:27] <strcat> you have &~str from that pattern
[21:16:30] <strcat> and then you need &str
[21:16:47] <jeaye> engla: Thanks
[21:16:48] <strcat> and auto-deref + auto-slice won't work together for whatever reason/bug
[21:18:00] <Seldaek> strcat: ok so this shouldn't be that hard ideally
[21:18:22] <strcat> Seldaek: well it would be the same thing
[21:18:30] <strcat> I don't think more sugar would make it easier to understand what's going on
[21:19:22] *** Joins: jaen (jaen@moz-44F908F5.play-internet.pl)
[21:19:43] <Seldaek> strcat: yeah I guess the issue isj ust that I don't have a full understanding of this stuff yet..
[21:20:14] <Seldaek> but the compiler output isn't always as useful as it could be if you don't know what you're doing 
[21:20:18] *** Parts: pupoque (Adium@297D6F99.EF706C30.C0C64AB3.IP) ()
[21:21:09] *** Joins: mib_3b4q28 (Mibbit@moz-72A1FE21.hiway.at)
[21:21:57] <mib_3b4q28> hey! I'm new to rust (it's my first day! :D ) and I wondered how I could get a random number?
[21:22:55] <jeaye> bjz: ping
[21:23:04] <mib_3b4q28> pong
[21:24:02] <Seldaek> rusti: println(fmt!("%?", std::rand::random::<u64>()));
[21:24:03] -rusti- 4869343700718421747
[21:24:03] -rusti- ()
[21:24:11] <Seldaek> mib_3b4q28: this should work
[21:24:30] *** Joins: experimenter (Mibbit@moz-A6BB0F96.dsl.austtx.swbell.net)
[21:24:58] <mib_3b4q28> ok, thank you very much!!
[21:25:06] <engla> std::rand is the module
[21:25:58] <engla> the Rng has some useful methods too, you need to grab the task's rng object for that:
[21:26:03] <engla> rusti: use std::rand::RngUtil; std::rand::task_rng().gen_uint_range(0, 25)
[21:26:04] -rusti- 8
[21:29:13] *** Quits: thpickert (thpickert@moz-34341F25.dynamic.dsl.tng.de) (Quit: thpickert)
[21:30:51] *** Quits: mib_3b4q28 (Mibbit@moz-72A1FE21.hiway.at) (Quit: http://www.mibbit.com ajax IRC Client)
[21:32:37] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[21:33:18] <joelteon> can you connect multiple Chans to the same Port?
[21:33:54] <experimenter> Pardon the newbie question, but why does extra::dlist::DList use stack space as you add elements? If I add 100,000,000 ints, I get "rust: task d6bfb0 ran out of stack". Is there a way to utilize the heap for storage?
[21:34:06] <goffrie> joelteon: is SharedChan what you want?
[21:34:21] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[21:34:26] <steven_is_false> experimenter: That sort of sounds like a bug.
[21:34:26] <joelteon> where is that?
[21:34:27] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[21:34:35] <mark_edward> experimenter: i think it's a bug/bad error messag
[21:34:58] <joelteon> goffrie: where is that?
[21:35:04] <goffrie> joelteon: std::comm::SharedChan
[21:35:16] *** Joins: aatch (aatch@moz-B437F499.pocketrent.com)
[21:35:17] <joelteon> oh, THAT's what I wanted
[21:35:23] <joelteon> jesus, all this time I thought I wanted flatpipes
[21:35:33] *** Joins: pupoque (Adium@297D6F99.EF706C30.C0C64AB3.IP)
[21:36:10] <strcat> experimenter: you're compiling with optimizations, right? rust uses a lot of stack space without it
[21:37:14] <experimenter>  Thanks for the answers. I didn't realize optimizations would make a difference here. Without optimizations would it leak memory?
[21:37:23] <strcat> no, it won't leak memory
[21:37:39] <strcat> dlist could be implemented incorrectly
[21:38:00] <strcat> or it might just use recursion somewhere
[21:38:36] *** Quits: robertknight (robertknig@moz-AB0E96D7.range86-162.btcentralplus.com) (Ping timeout)
[21:38:41] <strcat> or maybe you just went out-of-memory
[21:38:47] <strcat> and it couldn't expand the stack by a segment
[21:38:52] <strcat> that's a lot of integers
[21:38:53] <experimenter> If the recursion was that deep, then I'd be getting horrible performance.
[21:39:27] <strcat>     priv next: Link<T>,
[21:39:29] <strcat>     priv prev: Rawlink<Node<T>>,
[21:39:31] <strcat>     priv value: T,
[21:39:33] <strcat> that's a dlist node
[21:39:36] <experimenter> I've got 32GB RAM though, and I have no problem allocating ten times that many ints in a vector.
[21:39:38] <strcat> so for int, it's 24 bytes
[21:39:55] <strcat> rounded up to 32 by malloc
[21:40:45] <strcat> + the overhead of the allocator impl
[21:40:56] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[21:40:56] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/GiXdTw
[21:40:56] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[21:41:03] <strcat> anyway most likely dlist isn't implemented right
[21:41:45] *** Quits: anri (solancile@moz-E49E7C4B.hsd1.wa.comcast.net) (Ping timeout)
[21:42:14] <engla> do you have some certain suspicion strcat?
[21:42:19] <engla> what might be wrong with dlist
[21:43:21] <strcat> dunno, a little mistake in one of the utility functions he might be using or something
[21:43:44] <experimenter> I'm using the very latest from the repository, BTW, and I have a trivial code sample. I can share it if you want to try.
[21:43:46] <engla> experimenter: which version of rust is this?
[21:43:47] <engla> ok
[21:43:52] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[21:43:53] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/NCqe_A
[21:43:53] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[21:43:53] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[21:43:53] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/W_rQAg
[21:43:53] <ghrust> 13rust/06auto 14c1ad16d 15OGINO Masanori: Fix building problems in extra::unicode....
[21:43:53] <ghrust> 13rust/06auto 14d6f2364 15bors: auto merge of #8260 : omasanori/rust/fix-extra-unicode, r=pcwalton...
[21:43:54] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[21:43:55] <engla> please share the code
[21:44:04] <joelteon> I'm getting "cannot move out of captured outer variable in a heap closure" here: https://gist.github.com/joelteon/6152073#file-damn-rs-L93-L94
[21:44:16] <joelteon> and I don't understand the error.
[21:44:54] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[21:44:56] *** Joins: orshem (orshem@C5E06B1E.A5B6B765.E3D28531.IP)
[21:45:22] <joelteon> no wait, not there.
[21:45:29] *** Quits: maikklein (maik@moz-E6B4E665.dip0.t-ipconnect.de) (Ping timeout)
[21:45:29] <joelteon> it's on line 96, and pipe and pk are highlighted
[21:45:30] <bblum> joelteon: https://github.com/mozilla/rust/wiki/Doc-under-construction-FAQ#once-functions
[21:45:43] <joelteon> A cell...
[21:45:45] <joelteon> ok
[21:46:35] <experimenter> https://gist.github.com/jjwhitney/10cc5ed40e1d2d88b7d6
[21:46:48] <engla> I don't even think there are any recursive functions in dlist
[21:47:04] <experimenter> There's the code. Am I doing something stupid?
[21:47:21] <joelteon> thank you bblum 
[21:48:08] <orshem> mark_edward: ping
[21:48:19] <mark_edward> orshem: pong
[21:48:36] <orshem> take a look at the beautiful all new errors :) https://gist.github.com/dovreshef/6151620
[21:49:07] <orshem> rust gets increasingly ugly when you try to force it to do unsafe things
[21:49:26] <orshem> or just lifetime self generic things :D
[21:50:08] *** Joins: rob (Mibbit@moz-11F9F15.red-83-37-58.dynamicip.rima-tde.net)
[21:50:10] *** Quits: DoomBoom (DoomBoom@6B14631A.ACEC7723.5D1D3FEF.IP) (Quit: Leaving)
[21:50:40] <mark_edward> anyone else have any advice for orshem? i ffeel like what he'sdoing is possible, i just can't exactly think of what it should be right now
[21:51:24] <rob> Are there any tutorials besides the official tutorial?
[21:51:39] <engla> experimenter: ok same behavior here
[21:51:43] <strcat> rob: well there's more than 1 tutorial on rust-lang.org
[21:51:53] <mark_edward> rob: check here https://github.com/mozilla/rust/wiki/Docs
[21:51:54] <strcat> there's the tutorial, the container/iterator one, the borrowed pointer one, the FFI one
[21:52:21] <engla> experimenter: could just be atrocious memory use from 100M mallocs
[21:52:41] <experimenter> engla: Thanks for confirming that. 17M is enough to cause it to fail here, actually.
[21:53:42] <mark_edward> orshem: try changing fn root<'r>(&'r mut self) -> &'r mut Tree<'r>  to fn root<'r>(&'r mut self) -> &'r Tree {
[21:54:18] <joelteon> is there a library function that returns all the Some results of a list of Options?
[21:54:36] <orshem> mark_edward: one sec, i'm trying
[21:54:45] <orshem> thanks for persevering
[21:55:02] <mark_edward> orshem: no prob, i'll stay until we fix it
[21:55:11] <engla> experimenter: once it gets over 2GB resident it runs out here, at around 35M nodes
[21:55:20] <experimenter> @engla: Checking "top" shows only around 1% of total system memory being used.
[21:56:28] <Seldaek> is the new io stuff already std::io in master or is it somewhere else?
[21:56:59] <mark_edward> rusti: let xs = ~[Some(1i), None]; let ys: ~[Option<int>] = xs.iter().filter(|x| !x.is_none()).collect(); ys
[21:57:00] -rusti- pastebinned 7 lines of output: http://sprunge.us/HKAT
[21:57:28] *** Quits: rob (Mibbit@moz-11F9F15.red-83-37-58.dynamicip.rima-tde.net) (Quit: http://www.mibbit.com ajax IRC Client)
[21:57:44] <joelteon> oh, I found it
[21:57:52] <joelteon> I'm using consume_iter().filter_map(|x|x).collect()
[21:58:14] <orshem> mark_edward, down to 2 errors: https://gist.github.com/dovreshef/6151620
[21:59:17] <experimenter> engla: Aha... It actually completes the allocation, but crashes sometime after that. So I guess there's a problem with the deallocation?
[21:59:37] <mark_edward> orshem: try changing    fn root<'r>(&'r mut self) -> &'r Tree to     fn root<'r>(&'r self) -> &'r Tree {
[21:59:56] <mark_edward> orshem: comment out reparent for now
[22:00:08] <mark_edward> just making sure we cna get the regions right
[22:00:40] <experimenter> Check this out: https://gist.github.com/jjwhitney/274cc5f742ee7138b0d2
[22:00:53] <engla> experimenter: that's a good point. That's basically implicitly recursive
[22:01:34] <mark_edward> engla: how so? also does pushing that many thins into a vector work?
[22:01:59] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[22:02:32] <jeaye> rusti: struct T { i: i32 } T { i: if true { 0 } else { 1 } }
[22:02:32] -rusti- {i: 0}
[22:02:35] <engla> mark_edward: DList is a linked list, not a vector
[22:03:01] <mark_edward> engla: i know but just wondering about the ability of rust to handle large vectors
[22:03:07] <engla> experimenter: nice. We should report a bug
[22:03:16] <engla> mark_edward: it should be fine
[22:03:47] <experimenter> Thanks for finding that. I'm just learning Rust, so it didn't jump out at me.
[22:03:55] <goffrie> orshem: signature should be fn(&'self self) -> &'self Tree<'self>
[22:04:02] <goffrie> or something like that
[22:04:39] *** Quits: Florob (Florob@moz-39532932.de) (Client exited)
[22:04:49] <jeaye> rusti: env!("RUST_LOG")
[22:04:49] -rusti- ""
[22:04:50] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[22:04:58] <jeaye> rusti: env!("PATH")
[22:04:59] -rusti- "/usr/local/bin:/usr/bin:/bin"
[22:05:37] <orshem> mark_edward, back to 4 errors. :( 
[22:06:20] <engla> experimenter: I implemented DList but I didn't consider this issue
[22:06:24] <goffrie> orshem: the way you have it, reparent() is impossible, since parent is Option<&> and not Option<&mut>, but &mut is also kind of impossible since that implies exclusivity of mutableness
[22:06:45] <mark_edward> goffrie: i asked him to commen out reparen for now
[22:06:50] <goffrie> ah right
[22:06:58] <goffrie> in any case it works for me if I change the signature to     fn root(&'self self) -> &'self Tree<'self> {
[22:07:05] <mark_edward> orshem: do that
[22:07:34] *** Joins: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP)
[22:07:39] <orshem> mark_edward, goffrie: yes it works!!!!!!!!!
[22:07:45] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[22:07:57] <orshem> but that means that what i'm trying to do is not possible safely
[22:08:49] <orshem> thanks a lot, anyway!
[22:08:53] <experimenter> engla: So is it necessary for me to report the bug?
[22:09:02] <experimenter> (Officially, that is.)
[22:09:27] <mark_edward> orshem: there may be a way to do what you're doing. i'll try, let me see if i can. i'll ping you if i succeed
[22:09:28] <engla> experimenter: it would be nice if you did
[22:09:38] *** Quits: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP) (Ping timeout)
[22:10:22] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[22:10:22] *** ChanServ sets mode: +o brson
[22:11:36] <engla> experimenter: it is partly a bug in dlist. dlist has the datastructure to make a nonrecursive freeing of it possible
[22:12:32] <Seldaek> strcat: how is it with the new iterator syntax, is the for body still a function in terms of calling returns breaking it or do you have to call break|continue?
[22:12:46] <strcat> no, it's not a function
[22:12:52] <strcat> it's syntactic sugar for
[22:12:56] <brson> acrichto: congrats on that llvm upgrade
[22:13:19] <strcat> let it = &mut iterator; loop { match it.next() { Some(pattern) => { body } None => break } }
[22:13:26] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[22:13:28] <strcat> for pattern in iterator {} just desugars to that
[22:13:31] <acrichto> brson: oh I just realized it passed, yay!
[22:14:11] <Seldaek> strcat: I see, so it's not possible to continue to the next iteration right?
[22:14:25] <experimenter> engla: OK. Got to run now, but I'll report it later today. Thanks for the help!
[22:14:28] <strcat> Seldaek: it is, it's just the same as loop {}
[22:14:32] <strcat> 'break' and 'loop'
[22:14:40] <Seldaek> strcat: ah ok, loop was the keyword I was looking for :)
[22:14:42] <brson> acrichto: what does this upgrade include?
[22:14:49] <engla> strcat: do you agree with this conclusion? DList is basically a recursive type with deep nesting (~Node -> ~Node -> ~Node) so it runs out of stack when it's dropped. I'm thinking I need to implement a destructor that drops it all nonrecursively
[22:15:00] <strcat> engla: ah that makes sense
[22:15:10] <acrichto> brson: 3.3 mainly, and I think some jit fixes as well
[22:15:10] <strcat> engla: I don't think you should worry about it
[22:15:23] <strcat> engla: with optimization, sibling call optimization will likely happen
[22:15:31] <strcat> could check
[22:15:36] *** Quits: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP) (Quit: night)
[22:15:38] <strcat> if it doesn't we can fix glue_drop until it does
[22:15:46] <engla> it's the same with optimization
[22:16:03] *** Quits: jaen (jaen@moz-44F908F5.play-internet.pl) (Ping timeout)
[22:19:23] <strcat> rusti: fn foo() { loop; }
[22:19:24] -rusti- <anon>:5:24: 5:25 error: `again` outside of loop
[22:19:25] -rusti- <anon>:5          fn foo() { loop; }
[22:19:25] -rusti-                                  ^
[22:19:25] -rusti- error: aborting due to previous error
[22:19:25] -rusti- application terminated with error code 101
[22:19:48] <strcat> `loop` outside of loop sounds pretty weird ;p
[22:19:51] <strcat> oh well
[22:20:04] *** Joins: samx (sami@moz-48EC0983.dyn.optonline.net)
[22:20:39] <brson> acrichto: did you pick up erickt's patch to fix the .ll reader for fixedstacksegment?
[22:20:46] <brson> and luqman's arm patches, etc
[22:20:48] <acrichto> brson: I belive so yeah
[22:20:59] <erickt1> woot
[22:21:02] <brson> awesome, thanks
[22:21:28] <acrichto> next up is attempting 3.4
[22:21:39] <Seldaek> is it possible to read from stdin() some user input that happens after the process started? I mean for an interactive CLI prompt for example. Reading from stdin() doesn't seem to yield anything.
[22:21:57] *** Joins: maikklein (maik@moz-E6B4E665.dip0.t-ipconnect.de)
[22:22:27] <goffrie> Seldaek: reading from stdin interactively seems to work for me
[22:22:57] <brson> two people unsubscribed from rust-dev this weekend :-( maybe we've peeked
[22:23:17] <mark_edward> i've subbed, if someone will approve me
[22:23:30] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[22:23:44] <strcat> brson: https://github.com/mozilla/rust/pull/8292 r?
[22:23:44] <jeaye> brson: Maybe they got sick of people debating Java/.NET conventions. -_-
[22:23:50] <Eridius> brson: I changed my subscribed address, I hope that doesn't muck up your s tats
[22:23:53] <Eridius> *stats
[22:23:59] <Eridius> (I didn't unsub/resub though, I edited my subscription options)
[22:24:16] <jeaye> Can I have a variadic function (not macro)?
[22:24:41] <brson> Eridius: lol, it doesn't really matter; i was jk. in fact more people subbed than unsubbed this weekend
[22:24:54] <mark_edward> yay, im approved!
[22:24:54] <goffrie> jeaye: not really, as I understand it
[22:25:09] <steven_is_false> brson: I just subbed right now.
[22:25:12] <Seldaek> goffrie: how did you do it? If I read from stdin() in a loop and output back to stdout, it only works if I do: `echo "foo" | program`, not if I run program and then type stuff
[22:25:35] <Eridius> brson: any particular reason http://mail.mozilla.org/listinfo/ doesn't list rust-dev (but does list rust-commits)?
[22:25:52] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[22:25:57] <mark_edward> if a struct has a member that is a &T, and you have such a struct in a mutable slot, does the member become &mut T?
[22:26:04] <cmr> mark_edward: no
[22:26:06] <goffrie> Seldaek: http://sprunge.us/VYSF
[22:26:21] <cmr> mark_edward: inherited mutability only extends the first level down the ownership tree
[22:26:21] <goffrie> Seldaek: this works for me if I type stuff into it
[22:26:26] <cmr> The struct doesn't own the &T
[22:27:09] <Seldaek> goffrie: oh maybe the problem is I'm doing a read_bytes(100000),  but obviously that blocks forever since stdin never gets to EOF
[22:27:38] *** Parts: steven_is_false (user@C5B76363.1FF1EBF8.1ECA502.IP) (ERC Version 5.3 (IRC client for Emacs))
[22:27:38] <goffrie> Seldaek: ah, (ctrl-D causes eof)
[22:28:06] <Seldaek> yes indeed
[22:28:10] <Seldaek> that works 
[22:28:15] <Seldaek> all makes sense then
[22:28:25] *** Quits: samx (sami@moz-48EC0983.dyn.optonline.net) (Quit: This computer has gone to sleep)
[22:28:52] <orshem> does rust | servo have examples of tree like structures using only unique pointers + references?
[22:29:29] *** Joins: samx (sami@moz-48EC0983.dyn.optonline.net)
[22:29:47] <brson> Eridius: i've often wondered that myself. as with so many orgs, mozilla's infrastructure is kind of a mysterious hodgepodge
[22:32:14] *** Quits: pupoque (Adium@297D6F99.EF706C30.C0C64AB3.IP) (Quit: Leaving.)
[22:32:23] <brson> orshem: extra::treemap is probably an easy read
[22:32:38] *** Joins: sebcrozet (sebcrozet@moz-7FB6C00B.w193-252.abo.wanadoo.fr)
[22:33:40] *** Quits: samx (sami@moz-48EC0983.dyn.optonline.net) (Quit: This computer has gone to sleep)
[22:33:54] <orshem> brson: thanks
[22:34:05] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[22:35:07] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Leaving...)
[22:36:03] *** Quits: maikklein (maik@moz-E6B4E665.dip0.t-ipconnect.de) (Ping timeout)
[22:36:04] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[22:36:21] <strcat> orshem: also std::trie
[22:37:23] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[22:41:10] *** Joins: samx (sami@moz-48EC0983.dyn.optonline.net)
[22:47:13] <doomlord> ( some progress, my find tool seems to find method definitions  now :) )
[22:48:11] *** Quits: samx (sami@moz-48EC0983.dyn.optonline.net) (Quit: This computer has gone to sleep)
[22:48:15] <cmr> doomlord: nice!
[22:49:10] <doomlord> i need to clean up the code before i progress
[22:49:38] <jeaye> I `export FOO=bar` but env!("FOO") comes back empty. Ideas?
[22:49:46] <orshem> strcat, brson: thanks a lot!
[22:50:28] <cmr> jeaye: it works for me
[22:50:34] <cmr> jeaye: you know it's for compiletime inclusion, right?
[22:50:41] <orshem> mark_edward: based on treemap and trie code i've got something that compile, and seems to me that it'll work though it's a bit fragile
[22:51:00] <jeaye> cmr: Woops. I want runtime. ^_^ Is there one for runtime?
[22:51:02] <orshem> https://gist.github.com/dovreshef/6151620
[22:51:09] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Ping timeout)
[22:51:21] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[22:51:36] <cmr> jeaye: os::getenv
[22:51:47] <jeaye> Thanks, mate
[22:54:29] *** Quits: eevee (eevee@moz-58058235.evrt.wa.frontiernet.net) (Connection reset by peer)
[22:54:37] *** Quits: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net) (Input/output error)
[23:00:11] <sfackler> rusti: trait Foo {} trait Bar { fn bar<'a>(&'a self) -> ~Foo<'a>; }
[23:00:12] -rusti- <anon>:5:59: 5:66 error: no region bound is allowed on `main::Foo`, which is not declared as containing region pointers
[23:00:12] -rusti- <anon>:5          trait Foo {} trait Bar { fn bar<'a>(&'a self) -> ~Foo<'a>; }
[23:00:12] -rusti-                                                                     ^~~~~~~
[23:00:12] -rusti- error: aborting due to previous error
[23:00:13] -rusti- application terminated with error code 101
[23:00:17] <sfackler> is there any way to do that?
[23:00:47] <cmr> sfackler: no, lifetime parameterization is always explicit
[23:00:49] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[23:01:00] <cmr> rusti: trait Foo<'a> {}
[23:01:05] -rusti- timeout triggered!
[23:01:10] <cmr> rusti: trait Foo<'a> {}
[23:01:10] -rusti- ()
[23:01:59] <sfackler> hmm
[23:02:26] *** Joins: Sergio965 (sergiobz@7BC29AAF.C3A89135.3A99D594.IP)
[23:03:29] <sfackler> If the functionality of Foo depends on the instance of Bar it was creating from being alive, would I just have to use managed boxes then?
[23:03:39] *** Quits: mark_edward (quassel@moz-9631ECE3.public.wayport.net) (Ping timeout)
[23:03:39] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[23:03:39] *** ChanServ sets mode: +o brson
[23:04:21] *** Joins: mark_edward (quassel@moz-9631ECE3.public.wayport.net)
[23:05:47] <engla> ~Foo:'a  would be a trait objects with contents' lifetime being 'a. Probably only supports 'static though
[23:06:07] <sfackler> oh yeah, i actually meant
[23:06:28] <sfackler> rusti: trait Foo {} trait Bar<F: Foo> { fn bar<'a>(&'a self) -> ~F<'a> }
[23:06:29] -rusti- <anon>:5:73: 5:74 error: expected `;` or `}` but found `}`
[23:06:29] -rusti- <anon>:5          trait Foo {} trait Bar<F: Foo> { fn bar<'a>(&'a self) -> ~F<'a> }
[23:06:29] -rusti-                                                                                   ^
[23:06:29] -rusti- application terminated with error code 101
[23:07:19] <sfackler> so bar returns a unique box containing a struct implementing Foo whose lifetime is bound to that of the Bar instance
[23:08:03] *** Joins: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP)
[23:09:07] <engla> sfackler: with no type parameters on F, there's no way to put an object with a lifetime into F.. if I understand this correctly
[23:09:25] <sfackler> use case: if you have a SQL connection c, calling c.prepare("SELECT *....") should return a prepared statement object that can't live longer than c
[23:09:41] <strcat> make it borrow a reference to c
[23:09:56] <sfackler> yeah
[23:10:08] *** Quits: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP) (Ping timeout)
[23:10:22] <sfackler> that works fine in concrete implementations, but I can't get a trait version of that to work properly
[23:10:30] <cmr> A lot of breaking changes this week, but most of it was removing stuff in preparation for the new runtime
[23:10:37] <strcat> cmr: for!
[23:10:39] <strcat> ;p
[23:10:44] <cmr> strcat: that's only one bullet point :
[23:10:46] <cmr> :p
[23:18:16] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[23:18:44] *** Quits: tikue (tkuehn@moz-CF8BEBEF.dia.static.qwest.net) (Ping timeout)
[23:19:06] <sfackler> engla: yeah, that only supports 'static
[23:19:24] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[23:19:24] *** ChanServ sets mode: +o brson
[23:19:31] *** Joins: tikue (tkuehn@moz-CF8BEBEF.dia.static.qwest.net)
[23:22:56] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[23:22:57] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/W_rQAg
[23:22:57] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[23:25:57] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[23:25:57] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/AfXdWQ
[23:25:57] <ghrust> 13rust/06auto 14ea84c1f 15Brian Anderson: std: Remove gc and stackwalk...
[23:25:57] <ghrust> 13rust/06auto 1477bc6c5 15bors: auto merge of #8218 : brson/rust/nogc, r=brson...
[23:25:58] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[23:26:21] <cmr> brson: awesome, I'd wondered what the heck those were there for
[23:26:34] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[23:26:34] *** Joins: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net)
[23:26:51] <jeaye> Anyone know the functional equivalent of this string deletion (C++)? https://ideone.com/7x7eKx
[23:26:58] *** Joins: samx (sami@moz-48EC0983.dyn.optonline.net)
[23:28:03] <Sergio965> How do I iterate through the bytes of a string in Rust 0.7? I've tried "for string.bytes_iter().advance |c| { }", but that's no go.
[23:29:28] <sfackler> no go how?
[23:30:30] <jeaye> rusti: let s = "foo"; for s.byte_iter().advance |b| { }
[23:30:31] -rusti- <anon>:5:29: 5:30 error: expected `in`, found `.`
[23:30:31] -rusti- <anon>:5          let s = "foo"; for s.byte_iter().advance |b| { }
[23:30:31] -rusti-                                       ^
[23:30:31] -rusti- application terminated with error code 101
[23:30:38] <cmr> rusti: range(0, 10).collect::<~str>()
[23:30:40] -rusti- pastebinned 26 lines of output: http://sprunge.us/HjCS
[23:31:02] <cmr> strcat: engla: whoa that is weird ^
[23:31:09] <cmr> 8 of the same message :\
[23:31:43] <mark_edward> rusti: let s = "foo" for b in s.byte_iter() { printf!("%? ", b); }
[23:31:43] -rusti- <anon>:5:23: 5:26 error: expected `;` but found `for`
[23:31:44] -rusti- <anon>:5          let s = "foo" for b in s.byte_iter() { printf!("%? ", b); }
[23:31:44] -rusti-                                 ^~~
[23:31:44] -rusti- application terminated with error code 101
[23:31:52] <mark_edward> rusti: let s = "foo"; for b in s.byte_iter() { printf!("%? ", b); }
[23:31:53] -rusti- 102 111 111 ()
[23:32:10] <Sergio965> That's not Rust 0.7.
[23:32:17] <mark_edward> Sergio965: rright
[23:32:22] <jeaye> Sergio965: What I posted is.
[23:32:33] <engla> rusti: range(0i, 10).collect::<~str>()
[23:32:34] -rusti- pastebinned 26 lines of output: http://sprunge.us/bJYU
[23:32:42] <jeaye> Should be, anyway.
[23:33:13] <Sergio965> jeaye: You posted the same thing I said didn't work...
[23:33:20] <erickt1> kimundi: ping
[23:33:25] <jeaye> Sergio965: No I didn't.
[23:33:32] <Sergio965> Yes, you did.
[23:33:48] <jeaye> Sergio965: You said "bytes_iter"; I did not.
[23:33:56] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[23:33:58] *** Joins: gcarter (Greg_Carte@moz-DAA5D15C.san.res.rr.com)
[23:34:24] <Sergio965> There is no "byte_iter".
[23:34:30] <Sergio965> I assumed you made a type.
[23:34:32] <Sergio965> typo*
[23:34:34] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[23:34:34] <ghrust> 01[13rust01] 15brson 04force-pushed 06try from 143800755 to 14bcdde2b: 02http://git.io/k471pw
[23:34:34] <ghrust> 13rust/06try 14835e963 15Brian Anderson: std::rt: Improve the error message when the thread-local ptr is null...
[23:34:34] <ghrust> 13rust/06try 1475734a9 15Brian Anderson: std::rt: Run the tests for Local in a bare thread...
[23:34:34] <ghrust> 13rust/06try 14f0f7e1b 15Brian Anderson: std::rt: 3MB stacks!...
[23:34:35] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[23:34:47] <jeaye> http://static.rust-lang.org/doc/std/str.html#type-byteiterator
[23:34:48] <engla> bytes_iter was the old name
[23:34:58] <jeaye> engla: ah
[23:35:05] <engla> changed name July 27
[23:35:22] <Sergio965> engla: â€¦ There is no byte_iter.
[23:35:27] <Sergio965> There is a bytes_iter.
[23:35:44] <Sergio965> Which I have tried and get: type `std::str::StrBytesIterator<>` does not implement any method in scope named `advance'.
[23:35:48] <engla> Sergio965: if you have a version after July 27 there is
[23:35:53] <jeaye> Well, if your code is older than July 27th there is
[23:35:57] <Sergio965> ...
[23:35:59] <cmr> Sergio965: is IteratorUtil in scope?
[23:36:01] <Sergio965> I said Rust 0.7.
[23:36:09] <kimundi> erickt1: pong
[23:36:15] <erickt1> brson: ping
[23:36:18] <dbaupp> erickt1: I did some sketches of the restricted-goto-in-matches: https://gist.github.com/huonw/6145412
[23:36:20] <engla> Sergio965: I know
[23:36:23] <erickt1> oh hey kimundi
[23:36:36] <Sergio965> cmr: In the scope of where I call string.bytes_iter?
[23:36:49] <cmr> Sergio965: Where you call advance
[23:36:57] <cmr> advance is a method on IteratorUtil
[23:36:59] <erickt1> kimundi: I was just reading through https://github.com/mozilla/rust/pull/8288, it looks pretty good to me. Have you heard any other feedback from it though? I know brson had some reservations about #8268
[23:37:07] <erickt1> dbaupp: !
[23:37:53] <Sergio965> cmr: It wasn't. That fixed it.
[23:38:06] <erickt1> dbaupp: why match instead of continue?
[23:38:13] <Sergio965> That's really odd.
[23:38:14] <kimundi> erickt1: I asked brson yesterday if renaming get to unwrap would be fine, he said yes. But maybe he'd be of an different opinion if he saw that this also touches ~800 lines of code
[23:38:23] <cmr> Sergio965: Why is it odd?
[23:38:26] <cmr> acrichto: ping
[23:38:41] <Sergio965> Shouldn't it be enough to use the string module?
[23:38:44] <engla> Rust 0.7 was a snapshot release, no release planning behind it
[23:38:44] <dbaupp> erickt1: to avoid adding a new keyword
[23:38:50] <erickt1> kimundi: hehe :)
[23:38:53] <dbaupp> erickt1: (obviously it can be changed :) )
[23:38:55] <Sergio965> Since the string module uses the IteratorUtil module?
[23:38:57] <engla> well, not so much for the end user
[23:39:03] <cmr> Sergio965: No, that's not how imports work
[23:39:20] <cmr> If you import str you don't get everything str imports into your own scop
[23:39:22] <cmr> e
[23:39:35] <erickt1> kimundi: I was just about to do a PR for my result.map_move code. I did include a couple .get() -> .unwrap() as well. Not sure if I got them all though
[23:39:46] <jeaye> Any fellow C++ers know the functional equivalent of this string deletion? https://ideone.com/7x7eKx
[23:39:50] <jeaye> str seems lacking in this regard
[23:40:01] <dbaupp> erickt1: (if it's not clear, they are disjoint proposals, so, in theory, only one of them would be supported.)
[23:40:22] <kimundi> erickt1: From experience I can now tell you that both get() ANY unwrap() are used EVERYWHERE :P
[23:40:31] <erickt1> they are!
[23:40:36] <erickt1> it's nuts
[23:40:52] <dbaupp> jeaye: let i = s.find_str("src").unwrap(); s.slice_from(i + 4)
[23:41:12] <erickt1> kimundi: I also finished my patch that changes option/result .get() to return a reference
[23:41:16] <brson> erickt1: pong
[23:41:37] <jeaye> dbaupp: Oh, that's pretty lovely. Thanks, mate.
[23:42:13] <kimundi> erickt1: Seeing how I refactored the Option, Result and Either modules in general, maybe it would best to base those map changes on top of that?
[23:42:16] <acrichto> cmr: pong
[23:42:28] <erickt1> brson: I was thinking about giving https://github.com/mozilla/rust/pull/8288 a r+, which swaps .get() to .unwrap() in a lot of places. I saw you had some reservations on the related PR https://github.com/mozilla/rust/pull/8268, and I wanted to check in with you first before I reviewed it
[23:42:29] <engla> note, slice_chars is safer. str::slice will fail if you try to slice the middle of an utf-8 encoded character
[23:42:44] <dbaupp> engla: it's fine for this case
[23:42:46] <cmr> acrichto: Do you mind explaining https://github.com/mozilla/rust/pull/8185 some? Including it in TWiR, but I don't really understand the bug or what the fix does.
[23:42:50] <erickt1> kimundi: yeah, I'm trying to get your stuff landed now :)
[23:42:58] <kimundi> :)
[23:43:03] <dbaupp> engla: (in fact, only slice will work, sinee find_str returns a byte index.)
[23:43:14] <engla> right
[23:43:24] <brson> erickt1: that's fine
[23:43:28] <acrichto> cmr: it basically makes cross-crate conditions work
[23:43:40] <erickt1> brson: woot, thanks
[23:44:51] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Connection reset by peer)
[23:46:56] <erickt1> kimundi: yeah, this is a loong commit. r+-ed
[23:47:05] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[23:49:43] *** Quits: samx (sami@moz-48EC0983.dyn.optonline.net) (Quit: This computer has gone to sleep)
[23:50:48] <erickt1> dbaupp: did you consider using `loop 'a` for jumping to the next state?
[23:51:50] <erickt1> dbaupp: second, is there a typo in the `computed.rs` example? Should line 11 be `'bar => { blah(); 'baz }`?
[23:52:17] <dbaupp> erickt1: vaguely... I was more interested in the bit after the `continue/match/loop` keyword
[23:53:00] <dbaupp> erickt1: and no, you still need the jump-to-next-state keyword, it's just the "value" of the keyword is an expression
[23:53:15] <dbaupp> erickt1: (otherwise you couldn't exit from the `match`, I think)
[23:53:16] <erickt1> dbaupp: regarding `pattern_matching.rs`, I like it on one level, but I don't think we could support state-machines in state-machines
[23:53:37] *** Quits: orshem (orshem@C5E06B1E.A5B6B765.E3D28531.IP) (Quit: Leaving)
[23:53:40] <dbaupp> erickt1: in what way?
[23:54:06] <dbaupp> (also, I've got to go; could you leave the comments on the gist itself? thanks :) )
[23:54:09] *** Joins: jeff (jeff@moz-FC89C5BA.nycmny.east.verizon.net)
[23:54:10] <erickt1> ooh, I missed the `match if some_thing { 'bar â€¦` in `computed.rs`. Ok it makes sense why it's computed now :)
[23:54:17] <erickt1> Ok
[23:58:21] <cmr> Anyone have a project they'd like included in TWiR?
[23:58:34] <cmr> It doesn't need to be a new project; any update to it since it was last included is acceptable.
[23:59:41] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[23:59:41] *** ChanServ sets mode: +o dherman

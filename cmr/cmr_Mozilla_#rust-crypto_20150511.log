[00:00:14] <kmc> yeah, I think OpenSSL is a good call for AES-GCM
[00:00:16] *** Joins: Asandari (Asandari@moz-emp96u.cable.teksavvy.com)
[00:00:24] <kmc> and AES generally, but especially AES-GCM
[00:00:33] <kmc> and I'm not that interested in pre-1.2 ciphersuites
[00:25:23] *** Quits: panicbit (panicbit@moz-r4ks4s.dip0.t-ipconnect.de) (Ping timeout: 121 seconds)
[00:29:34] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[00:33:43] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[00:48:04] <bascule> klutzy: I wish OpenSSL would split into separate *projects* for libcrypto and libssl
[00:51:21] *** Quits: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua) (Ping timeout: 121 seconds)
[01:02:48] *** Quits: atomic (atomic@moz-u4m4lu.rev.poneytelecom.eu) (Connection closed)
[01:05:09] *** Joins: atomic (atomic@moz-n4lvbv.enn.lu)
[01:12:38] *** Joins: blank_name (blank_name@moz-hks8er.gdrpmi.sbcglobal.net)
[01:15:27] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[01:17:40] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[01:19:36] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[01:28:47] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[02:41:40] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[02:47:15] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[02:47:41] *** Quits: c74d (c74d3a4ebb6@moz-0ersgu.oc.cox.net) (Client exited)
[02:48:44] *** Joins: c74d (c74d3a4ebb6@moz-0ersgu.oc.cox.net)
[02:54:28] <kmc> Ilari: do you have a link about firefox disablilng RC4?
[03:05:22] <Ilari> kmc: I think it was planned for FF39...
[03:11:35] *** Quits: blank_name (blank_name@moz-hks8er.gdrpmi.sbcglobal.net) (Quit: leaving)
[04:17:02] *** Joins: yourabi (yourabi@moz-q8dqtg.ca.comcast.net)
[04:17:39] *** Quits: yourabi (yourabi@moz-q8dqtg.ca.comcast.net) (Quit: Textual IRC Client: www.textualapp.com)
[04:36:12] <eternaleye> I wonder how nettle matches up, re libcrypto
[04:36:29] <eternaleye> Might be another decent option - it's already got gnutls as a TLS user of nettle
[05:53:25] <Ilari> I think libnettle is thought to have nicer interface than gcrypt or something...
[05:58:02] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[05:59:53] <Ilari> Does Nettle have AES-GCM? Does it pass CT check without hardware acceleration?
[06:02:50] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[06:08:13] <eternaleye> Ilari: It does have AES-GCM
[06:08:30] <eternaleye> Ilari: It also has ChaCha-Poly1305
[06:10:12] <eternaleye> Ilari: And nmav claimed that nettle is constant-time
[06:10:28] <eternaleye> https://www.ietf.org/mail-archive/web/tls/current/msg11905.html
[06:18:07] <Ilari> And the docs claim that ECC ops (even on NIST curves) are constant time... Tho I really don't like what the docs say about Curve25519...
[06:20:17] <eternaleye> Ilari: The "implementation idiosyncrasy" note re: the twist?
[06:20:22] <Ilari> Yeah.
[06:20:52] <eternaleye> I'm pretty sure that's a paper tiger.
[06:21:19] <eternaleye> If that actually happened, it'd get rolled back right quick because I have zero doubt current code has started relying on it
[06:22:04] <Ilari> Yeah, how would one even do that change within current API, without introducing nasty vulns?
[06:23:57] <eternaleye> Ilari: Um, it's just saying that you need to check the retval of ecc_point_set, even though the current impl of mul_g will work regardless
[06:24:10] <eternaleye> >> Check that the given coordinates represent a point on the curve. If so, the coordinates are copied and converted to internal representation, and the function returns 1. Otherwise, it returns 0. Currently, the infinity point (or zero point, with additive notation) is not allowed. 
[06:25:24] <Ilari> Except Curve25519 has two functions, neither of which returns any error codes.
[06:25:49] <eternaleye> Ilari: Ah, I see
[06:25:52] <eternaleye> Mm, yeah
[06:26:25] <eternaleye> yeah, that really marks it a paper tiger
[06:27:04] <eternaleye> Incidentally, I _really_ dislike output parameters.
[06:27:43] <eternaleye> IMO, much better to pass in ownership of the buffer, and then return Result<FilledBuffer,Error<EmptyBuffer>>
[06:28:42] <eternaleye> Then you get a nice pattern-match guard against using a buffer after failure.
[06:34:09] <Ilari> Returning buffer back in either case? Isn't that pretty much same as mutably borrowing it?
[07:05:13] *** Joins: Tobba (Tobba@moz-6oh.7ki.21.217.IP)
[07:19:09] *** Tobba is now known as Tobba|Laptop
[07:57:41] *** Joins: Tobba (Tobba@moz-6oh.7ki.21.217.IP)
[07:57:45] *** Quits: Tobba (Tobba@moz-6oh.7ki.21.217.IP) (Connection closed)
[09:35:34] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[09:40:19] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[09:45:40] *** Joins: panicbit (panicbit@moz-r4ks4s.dip0.t-ipconnect.de)
[09:54:14] *** Joins: Tobba (Tobba@moz-6oh.7ki.21.217.IP)
[09:55:12] *** Quits: Tobba|Laptop (Tobba@moz-6oh.7ki.21.217.IP) (Ping timeout: 121 seconds)
[10:38:31] *** Quits: panicbit (panicbit@moz-r4ks4s.dip0.t-ipconnect.de) (Ping timeout: 121 seconds)
[10:38:56] *** Joins: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua)
[12:14:05] *** Quits: Tobba (Tobba@moz-6oh.7ki.21.217.IP) (Ping timeout: 121 seconds)
[12:44:43] *** Joins: panicbit (panicbit@moz-7vfoab.itmc.tu-dortmund.de)
[13:13:05] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[13:17:50] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[13:24:50] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[13:47:58] *** Quits: panicbit (panicbit@moz-7vfoab.itmc.tu-dortmund.de) (Ping timeout: 121 seconds)
[14:09:53] <eternaleye> Ilari: Technically yes, meaningfully no
[14:10:33] <eternaleye> Ilari: In that with the former, you have to *choose to use an error*, but with the latter you might merely *fail to check for an error*
[14:10:59] <eternaleye> Ilari: It makes poor usage of the API require choice, not just forgetfulness.
[14:11:44] <eternaleye> Ilari: It's a subtle distinction, but (I feel) an important one
[14:15:09] <Ilari> How would you write this (not introducing any memory allocations): pub fn decrypt_aead(out: &mut [u8], input: &[u8], key: &Key, nonce: &Nonce, data: &[u8]) -> Result<(), ()> ?
[14:21:31] <eternaleye> pub fn decrypt_aead<T: Buffer>(input: &[u8], key: &Key, nonce: &Nonce, buf: T) -> Result<Buf,(DecryptionError, Buf)> // the error type might be some more carefully designed type than a tuple
[14:21:46] <eternaleye> er, Buf in the result should be T
[14:23:13] <eternaleye> That way, "not checking for errors" is .unwrap() - which makes it very clear that errors are being ignored.
[14:24:07] <eternaleye> But "failed to check the return value" is a bug that in my opinion can only happen with a poorly-designed API.
[14:24:50] <eternaleye> If the return value is important enough the user _should_ care about it, then it should carry the data the user cares about so that they _have_ to look.
[14:25:53] <eternaleye> It's one of the reason I love Rust's move semantics so much
[14:27:49] <kmc> mhm
[14:27:55] <Ilari> Well, even with the original, just ignnoring the return value IIRC causes a warning.
[14:29:42] <Ilari> eternaleye: And the definition of Buffer? It has to be something one can borrow mutable slice out of (for writing the result to it)?
[14:37:37] <eternaleye> Ilari: There's a difference between "the compiler gives a warning" (people *still* do unsafe pointer casts in C, despite every compiler warning about it) and "If you want your data, you need to unpack the return value"
[14:38:05] <eternaleye> Ilari: And I was figuring something more like carllerche's Bytes crate stuff
[14:38:23] <eternaleye> Ilari: Which can be preallocated, but can also be grown, etc.
[14:39:43] <eternaleye> Ilari: With AEAD, if you preallocate the size of the encrypted message, you can never go over the allocation, but you might have trailing garbage. The bytes crate prevents access to that too.
[14:43:29] <Ilari> Unsafe pointer cast warnings? I thought most of those are either errors or "this is not going to work at all"...
[14:43:50] *** Joins: panicbit (panicbit@moz-7vfoab.itmc.tu-dortmund.de)
[14:44:12] <Ilari> And yes, C does let one do absolutely crazy casts that cause all kinds of trouble.
[14:44:58] <eternaleye> Ilari: I mean stuff like (on ILP32) casting * to I, which does succeed with a warning, but is a horrendous hazard for LP64/LLP64 porting.
[14:45:14] <eternaleye> Ilari: Or L, which is a hazard for LLP64
[14:45:46] <eternaleye> Ilari: But my point is that warnings don't do all that much. People tend to ignore them by default unless they've taught themselves to care.
[14:46:52] <eternaleye> Ilari: But by making the data they care about inaccessible unless they handle the potential for error, then they *handle the potential for error*
[14:48:01] <Ilari> And with that function I gave, if you ignore the error, it is going to break at runtime.
[14:48:25] <eternaleye> Ilari: Yes? But the way it breaks may be security relevant, and it's as easy as forgetting to check something.
[14:48:47] <eternaleye> Ilari: Whereas if the data is behind the error, they have to *choose* to pull something out of an error and use it.
[14:48:52] <eternaleye> Ilari: It's about mindfulness.
[14:49:38] <eternaleye> Ilari: Requiring explicit action to do a stupid thing is vastly superior to "stupid thing is the default but yells at you; you must take extra steps to avoid it"
[14:51:31] <eternaleye> Ilari: With a return value that they *can* avoid checking, then the path of least resistance is to forget. With the return value encapsulating the data they need, they fall into the correctness hole.
[14:52:10] <Ilari> Genuinely bad APIs are loads worse than even "get it wrong and it breaks at runtime".
[14:52:22] <eternaleye> "bad" is not binary.
[14:52:34] <eternaleye> It's the sum of all the ways someone using it can have their code misbehave.
[14:52:58] <eternaleye> And a *really* good API inspires the calling code to be more correct than it otherwise might be.
[14:53:16] <eternaleye> It's like misuse-resistant AEAD.
[14:53:30] <eternaleye> In an ideal world, it wouldn't matter, because nobody would misuse AEAD.
[14:53:58] <eternaleye> In the real world, misuse-resistant AEAD makes it that much less likely that a minor screwup amplifies into a major issue.
[14:54:24] <eternaleye> Alternately, it's about aligning the incentives.
[14:54:52] <eternaleye> The API designer wants the return value checked (or they wouldn't have marked it must use); the user just wants their data.
[14:55:15] <eternaleye> By hiding the data in the return value, then the user's incentives change such that the API designer's goals are fulfilled.
[14:56:03] <Ilari> I do have *_ret variants of functions, but those do involve memory allocation. 
[14:56:18] <eternaleye> They don't have to, though
[14:56:49] <eternaleye> Personally, I'd use bytes::Buffer or whatever its name is. If the caller wants no allocation, it can give the buffer a capacity before calling down
[14:57:09] <eternaleye> Safe in all cases, and can be made allocation-free.
[14:58:40] <Ilari> Except what does the code do with the returned in error buffer?
[14:59:00] <Ilari> ... The object itself.
[15:01:28] <eternaleye> Ilari: The returned error buffer still has a capacity, but should have its length set to 0 by the callee, making access to its contents impossible
[15:01:53] <eternaleye> Ilari: So it should be safe to use in a retry, or allow it to fall away and be returned to an allocation pool like carllerche's other crate
[15:02:27] <eternaleye> Ilari: The reason to return it is for exactly the "do not allocate" case
[15:10:38] <Ilari> "Read correct mailing list thread and you get it right"... And that's not the bottom...
[15:11:46] <Ilari> (The bottom is "impossible to get right".)
[15:12:19] <Ilari> And that's unfortunately not an unarchiveable platonic ideal... :-/
[15:14:08] <eternaleye> Ilari: Meanwhile the top is fn dwim(); :P
[15:29:53] *** Quits: panicbit (panicbit@moz-7vfoab.itmc.tu-dortmund.de) (Ping timeout: 121 seconds)
[15:52:19] *** Joins: erickt (erickt@moz-4hh.6p3.217.74.IP)
[15:52:21] *** Joins: panicbit (panicbit@moz-7vfoab.itmc.tu-dortmund.de)
[15:56:52] *** Quits: panicbit (panicbit@moz-7vfoab.itmc.tu-dortmund.de) (Ping timeout: 121 seconds)
[16:44:09] <kmc> hey, the OpenSSL Dual_EC_DRBG API turned out to be actually impossible to use
[16:44:12] <kmc> and that was a good thing ;)
[16:44:33] <kmc> it was broken in a very specific way that caused it to still pass the test suite
[16:50:51] *** Joins: brson (brson@moz-qjbkeh.mtv2.mozilla.com)
[16:52:04] <Ilari> kmc: Also, haha at FIPS validation not catching breakage of that magnitude...
[16:53:37] <kmc> yeah
[16:54:52] <kmc> what a farce
[17:05:42] *** Joins: jtdowney (jtdowney@moz-gh1isj.static.twtelecom.net)
[17:06:07] <Ilari> Yet they carefully checked that the NSA backdoor was present... :-)
[17:14:21] <kmc> the authors of the Extended Random TLS extension that makes Dual_EC much easier to exploit:
[17:14:36] <kmc> Margaret Salter, technical director of the Fusion, Analysis and Mitigations Group of the Information Assurance Directorate (IAD) of the NSA
[17:14:39] <kmc> and mozilla's own ekr@rtfm.com
[17:14:40] <kmc> o_O
[17:16:45] *** Joins: panicbit (panicbit@moz-r4ks4s.dip0.t-ipconnect.de)
[17:17:39] <kmc> https://www.ietf.org/archive/id/draft-rescorla-tls-opaque-prf-input-00.txt is possibly another backdoor attempt?
[17:20:10] <Ilari> kmc: Yeah, that definitely looks like something to make Dual-EC easier to exploit... Or bad RNGs in general...
[17:22:17] <kmc> yeah
[17:24:08] <kmc> i wonder how the shareholders of EMC Corporation feel about their security division selling out customers for a paltry $10M in government money
[17:24:34] <kmc> unfortunately governments tend to give you a choice between the easy way and the hard way
[17:45:21] *** Joins: brson_ (brson@moz-cfhap5.mtv2.mozilla.com)
[17:45:29] *** Quits: brson (brson@moz-qjbkeh.mtv2.mozilla.com) (Ping timeout: 121 seconds)
[17:47:37] *** Quits: brson_ (brson@moz-cfhap5.mtv2.mozilla.com) (Quit: leaving)
[17:47:46] *** Joins: brson (brson@moz-cfhap5.mtv2.mozilla.com)
[17:53:47] *** Joins: jtdowney_ (jtdowney@moz-gh1isj.static.twtelecom.net)
[17:56:26] *** Quits: jtdowney (jtdowney@moz-gh1isj.static.twtelecom.net) (Ping timeout: 121 seconds)
[18:02:55] *** Joins: gsingh93 (gulshan@moz-qnbukr.mi.comcast.net)
[18:05:48] *** Quits: brson (brson@moz-cfhap5.mtv2.mozilla.com) (Ping timeout: 121 seconds)
[18:19:31] *** Joins: brson (brson@moz-cfhap5.mtv2.mozilla.com)
[19:31:18] *** Quits: panicbit (panicbit@moz-r4ks4s.dip0.t-ipconnect.de) (Ping timeout: 121 seconds)
[19:31:57] <Ilari> Ryan Sleevi supporting TLS clients trying to interpret crap certificate chains.
[19:31:59] <Ilari> *?
[19:33:59] *** Quits: erickt (erickt@moz-4hh.6p3.217.74.IP) (Ping timeout: 121 seconds)
[19:39:02] <Ilari> Also, is it just me, or is that "path building" Ryan advocated behind that Qualsys SSL Labs forum thread about EV cert not working right?
[20:45:30] *** Joins: erickt (erickt@moz-4hh.6p3.217.74.IP)
[20:50:15] *** Quits: erickt (erickt@moz-4hh.6p3.217.74.IP) (Ping timeout: 121 seconds)
[21:05:54] *** Joins: erickt (erickt@moz-4hh.6p3.217.74.IP)
[21:27:55] *** Quits: gsingh93 (gulshan@moz-qnbukr.mi.comcast.net) (Ping timeout: 121 seconds)
[22:04:07] *** Joins: gsingh93 (gulshan@moz-qnbukr.mi.comcast.net)
[22:08:18] *** Joins: blank_name (blank_name@moz-th6.t75.79.172.IP)
[22:12:07] *** Quits: gsingh93 (gulshan@moz-qnbukr.mi.comcast.net) (Ping timeout: 121 seconds)
[22:21:47] *** Quits: jtdowney_ (jtdowney@moz-gh1isj.static.twtelecom.net) (Quit: )
[22:40:05] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[22:48:37] *** Quits: erickt (erickt@moz-4hh.6p3.217.74.IP) (Ping timeout: 121 seconds)
[22:49:53] *** Joins: panicbit (panicbit@moz-r4ks4s.dip0.t-ipconnect.de)
[22:51:42] *** Joins: erickt (erickt@moz-4hh.6p3.217.74.IP)
[23:05:14] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[23:18:28] *** Joins: gsingh93 (gulshan@moz-qnbukr.mi.comcast.net)
[23:28:37] *** Quits: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua) (Ping timeout: 121 seconds)
[23:30:45] *** Joins: jtdowney (jtdowney@moz-obnifk.il.comcast.net)
[23:48:51] <bascule> Ilari: yes
[23:49:15] <bascule> Ilari: I think he wants a path forward for legacy clients
[23:49:24] <bascule> or something
[23:50:08] <bascule> e.g. if you have clients that only support SHA1 but would like to use SHA256 certificates too, or something?
[23:50:23] <bascule> we're actually in that particular boat at the moment at Square. Thanks Android!
[23:54:21] *** Joins: dreid (sid22634@moz-o1lt0a.charlton.irccloud.com)
[23:56:22] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)

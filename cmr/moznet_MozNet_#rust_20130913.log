[00:00:29] *** Quits: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net) (Client exited)
[00:00:50] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[00:00:50] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14c0e92b6 to 14761ae00: 02http://git.io/N3iJvQ
[00:00:50] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[00:00:50] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[00:00:50] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/NOqdUw
[00:00:50] <ghrust> 13rust/06auto 1487a959b 15Tim Chevalier: rustpkg: Search RUST_PATH properly for dependencies, and add a test for recursive dependencies...
[00:00:50] <ghrust> 13rust/06auto 14d8a4cea 15bors: auto merge of #9132 : catamorphism/rust/rustpkg-recursive-deps, r=catamorphism,metajack...
[00:00:51] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[00:02:09] *** Quits: hoverbear (andrew@EBFA78B5.F19E5E7B.E74D50F2.IP) (Quit: hoverbear)
[00:02:10] <mark_edward> tikue: yeah, this is hard...
[00:02:58] *** Quits: jdm (jdm@moz-BBE3ABD.mv.mozilla.com) (Quit: Lost terminal)
[00:03:01] <tikue> mark_edward: the inelegant solution is instead of matching on right and left, do `if root.right.is_some() { â€¦ } else { â€¦ }`
[00:03:41] *** Joins: hoverbear (andrew@EBFA78B5.F19E5E7B.E74D50F2.IP)
[00:04:08] *** Quits: hoverbear (andrew@EBFA78B5.F19E5E7B.E74D50F2.IP) (Quit: hoverbear)
[00:04:21] *** Quits: jclements (jclements@moz-644F0E77.wireless.calpoly.edu) (Quit: jclements)
[00:04:43] *** Joins: SiegeLord (sl@moz-1DF56822.twcny.res.rr.com)
[00:05:37] *** Joins: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net)
[00:06:36] *** Quits: vosen (vosen@moz-266BA656.icpnet.pl) (Quit: Leaving)
[00:07:34] *** Joins: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP)
[00:08:10] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[00:09:55] *** Quits: sebcrozet (sebcrozet@moz-2517AE39.w80-13.abo.wanadoo.fr) (Quit: Gone)
[00:10:24] *** Quits: ww (Mibbit@moz-DFAED48A.lightspeed.sntcca.sbcglobal.net) (Quit: http://www.mibbit.com ajax IRC Client)
[00:11:23] *** Joins: NewGuy (Mibbit@moz-C18B8936.laptops.usf.edu)
[00:11:32] <NewGuy> Howdy, guys. Just a real quick question
[00:12:02] <NewGuy> Can a for loop return a value, similar to how an if or match can?
[00:12:06] <strcat> no
[00:12:12] <sfackler> no, but you can do something like
[00:12:22] <sfackler> let foo; loop { if thing { foo = bar; break }}
[00:12:54] <strcat> won't work with a for loop
[00:13:02] *** Joins: busylizzy (lisa@85228838.12D0DC84.211374C4.IP)
[00:14:09] <NewGuy> Yeah, I was just wanting to do something like http://mibpaste.com/03wk6Q
[00:14:15] <tikue> NewGuy: in many cases if you want the loop to return a value there are iterator methods that help
[00:14:27] <tikue> mark_edward: there was an email about this problem on the mailing list recently. about "leaving holes" in structs temporarily
[00:14:50] <tikue> NewGuy: you want to return true if any element is true?
[00:15:00] <NewGuy> But yeah, just thought it would be a cool - definitely toher ways to do it
[00:15:01] <tikue> NewGuy: use iter().any(|el| el == condition)
[00:15:15] <strcat> NewGuy: what happens if there is nothing in the iterator?
[00:15:17] <strcat> undefined read
[00:15:29] *** Quits: busylizzy (lisa@85228838.12D0DC84.211374C4.IP) (Ping timeout)
[00:15:30] <NewGuy> tikue: Oh, that's perfect.
[00:15:41] *** Quits: lmandel (lmandel@13F2CEC5.7672369.D8E68FF6.IP) (Quit: lmandel)
[00:15:54] <NewGuy> strcat: Didn't even think about hta.
[00:16:34] *** Joins: kseo (kseo@338DE5BC.4166765B.485A6DF.IP)
[00:16:41] <doomlord> is there anything like the rust lightweight task switching runtime for c++
[00:17:02] <doomlord> (eg for comparison..)
[00:18:08] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[00:18:45] <strcat> doomlord: there are green threads, but I don't know of any multiplexed onto OS threads
[00:20:17] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[00:20:38] *** Joins: samx (sami@moz-D9DA5773.dyn.optonline.net)
[00:20:47] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[00:20:47] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14d8a4cea to 14761ae00: 02http://git.io/N3iJvQ
[00:20:47] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[00:20:48] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[00:20:48] <ghrust> 01[13rust01] 15bors pushed 6 new commits to 06auto: 02http://git.io/Keq8Hw
[00:20:48] <ghrust> 13rust/06auto 146ab21d4 15Corey Richardson: Add rustdoc_ng
[00:20:48] <ghrust> 13rust/06auto 145d42966 15Felix S. Klock II: Finish addition of rustdoc_ng to Makefiles.
[00:20:48] <ghrust> 13rust/06auto 141e65b03 15Corey Richardson: Update rustdoc_ng to new ast naming
[00:20:50] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[00:22:23] *** Joins: kelvin (kelvin@moz-3D989EF4.hsd1.va.comcast.net)
[00:26:07] *** Joins: ww (Mibbit@moz-9D1D3E.public.wayport.net)
[00:26:22] *** Quits: NewGuy (Mibbit@moz-C18B8936.laptops.usf.edu) (Quit: http://www.mibbit.com ajax IRC Client)
[00:27:41] <strcat> acrichto: it's possible it has to do with fn pointers not being tagged with sret.
[00:28:40] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[00:29:57] *** Joins: busylizzy (lisa@85228838.12D0DC84.211374C4.IP)
[00:30:05] *** Joins: aatch (aatch@moz-B437F499.pocketrent.com)
[00:30:54] <strcat> yeah
[00:35:50] *** Joins: adu (alt@moz-BF2B1AE4.washdc.fios.verizon.net)
[00:35:55] <strcat> pcwalton: *finally* narrowed this down
[00:36:03] <pcwalton> oh?
[00:36:10] <strcat> function pointers don't get tagged with attributes
[00:36:26] <strcat> at least this is *a* problem, and hopefully why x86 segfaults ;p
[00:37:05] *** Joins: hoverbear (andrew@moz-86FCBF4B.gv.shawcable.net)
[00:37:31] <strcat> so the calling convention was a bit wrong
[00:37:56] *** Quits: echristo (echristo@DCF57675.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[00:38:36] *** Quits: ozten (ozten@moz-DD3B00B4.hsd1.wa.comcast.net) (Quit: ozten)
[00:39:11] <strcat> this also applies to C function pointers
[00:39:17] <strcat> because C ABIs often have sret
[00:40:01] * tikue just realized that if rust ever got better support for currying it'd screw up the `do` syntax
[00:41:03] <ww> any chance to improve the for-loop semantic?
[00:41:16] <strcat> ww: improve it in what way?
[00:41:20] <tikue> ww: in what sense? getting rid of the requirement for .iter() ?
[00:41:28] <ww> currently for can't loop over vec without using iter()
[00:41:32] <ww> yeah
[00:41:51] *** Quits: hoverbear (andrew@moz-86FCBF4B.gv.shawcable.net) (Quit: hoverbear)
[00:41:57] <ww> also the lifetime of the iterated over vec is kind of werid
[00:42:02] <tikue> there's a mythic "iterable" trait that gets tossed around but it's presently non-existent
[00:42:07] <tikue> ww: how so?
[00:42:12] <ww> e.g. for i in [1,2,3].iter() { } this won't work
[00:42:18] <tikue> ww: that's a bug 
[00:42:21] <strcat> that's just a general issue with rvalues in rust
[00:42:24] <ww> oh, ok :)
[00:42:24] <strcat> not a bug
[00:42:31] <tikue> it's a bug in my bok
[00:42:33] <tikue> book
[00:42:48] <strcat> it works as defined
[00:42:57] <tikue> it should change
[00:43:06] <strcat> yes, it should, but it's not a bug
[00:43:12] <doomlord> .iter() is ok , given you can slot other things in there
[00:43:18] *** Quits: ceninan (ceninan@moz-6BD43586.a370.priv.bahnhof.se) (Ping timeout)
[00:43:22] <sfackler> here's the RFC issue discussing the lifetime thing https://github.com/mozilla/rust/issues/3511
[00:43:25] <tikue> strcat: you could call it an issue if you want :)
[00:43:31] <strcat> it could be implemented a long time from now, it would be backwards compatible
[00:43:41] <ww> newcomers to the language will complain about simple things are complicate
[00:44:06] <ww> a simple thing like, for i in vec { } should just work
[00:44:17] <strcat> for loops iterate over iterators, and vectors have many iterators
[00:44:25] <ww> anyway, just my feedback about using it for a while
[00:44:32] <strcat> iter(), mut_iter(), split_iter()
[00:44:45] <ww> yeah, but pick a default one for the simple case
[00:44:53] <tikue> strcat: the iterable trait would use iter() by convention (if it existed)
[00:45:08] <strcat> it requires implementing for loops in librustc
[00:45:19] <benh> wasn't that desirable for a few other reasons already
[00:45:21] <tikue> strcat: they should be though
[00:45:28] <benh> like better error messages or something, i forget
[00:45:35] *** Joins: ceninan (ceninan@moz-6BD43586.a370.priv.bahnhof.se)
[00:45:43] <strcat> benh: yeah it's desirable for other reasons
[00:45:45] <strcat> but it's not easy...
[00:45:46] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[00:45:47] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14d70d5fc to 14761ae00: 02http://git.io/N3iJvQ
[00:45:47] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[00:45:47] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[00:45:47] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/LTE94g
[00:45:47] <ghrust> 13rust/06auto 1491e64d0 15Tim Chevalier: rustpkg: Search RUST_PATH properly for dependencies, and add a test for recursive dependencies...
[00:45:47] <ghrust> 13rust/06auto 1419c0735 15bors: auto merge of #9132 : catamorphism/rust/rustpkg-recursive-deps, r=catamorphism,metajack...
[00:45:48] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[00:45:59] <benh> yeah, didn't mean to suggest that it was
[00:46:01] <doomlord> if it inserted .iter() .. would it create inconsistencies (eg nested iteraotrs ? could you make somehting thats already an iterator have a .iter(){self} ? 
[00:46:27] <tikue> doomlord: i asked that once but don't remember the answer
[00:46:33] <ww> i can hear rubyists or pythonists snickering about how complicate the syntax it is. :)
[00:46:38] <benh> it'd make the regular .iter() privileged over .mut_iter() etc i suppose
[00:46:38] <strcat> it would have to have an order of precedence
[00:46:55] <doomlord> inconsistency with collections of collections for example
[00:47:23] <ww> anyway, just feedback in the alpha stage.  so far things look great.  it's already very usable.  i was able to build a project using it.
[00:47:24] <strcat> you'd need to check if the thing was an Iterator, and then fall back to Iterable
[00:47:27] <tikue> benh: type inference could fix that perhaps?
[00:47:29] <strcat> or the other way around
[00:47:41] <strcat> ww: yeah I'd like to make `for` support Iterables
[00:47:53] <strcat> but I don't know how feasible it is to resolve the ambiguity + actually implement it any time soon
[00:48:02] <benh> I don't get why making iterators idempotently iterables wouldn't work
[00:48:14] <Luqman> strcat: by implementing in librustc do you mean that as in it not being sugar for a loop and match?
[00:48:20] <tikue> strcat: any thoughts on the feasibility of inferring the correct iter method to call?
[00:48:24] <strcat> benh: because to iterate an iterator, you mutate it
[00:48:29] <benh> tikue: that seems magic :(
[00:48:32] <strcat> tikue: not feasible
[00:48:41] <doomlord> once you see how consistent it is to slot in .iter() or rev_iter() or whatever its easy to accept
[00:48:41] <strcat> Luqman: yes
[00:48:53] <strcat> Luqman: so it can avoid freezing lvalues during the loop body, mostly
[00:49:19] <benh> maybe we could appease the rubyists somewhat by renaming .iter() to .each()
[00:49:20] <ww> how about making a default for frequently used case?  make freq used things simple and let the coders deal with more complicate case, like iterating over mutable case, etc.
[00:49:34] <tikue> benh: let's not do that :(
[00:49:59] <ww> lol
[00:50:15] <strcat> for loops need to be implemented in librustc before we can really investigate the problems
[00:50:16] <ww> for each i in vec?
[00:50:20] *** Quits: maik (maik@moz-3F2CDB33.dip0.t-ipconnect.de) (Ping timeout)
[00:50:27] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[00:50:34] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[00:50:39] <tikue> ww: what's wrong with the current syntax? no reason to bikeshed for bikeshedding's sake imo
[00:50:49] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Connection reset by peer)
[00:51:03] <tikue> there was a decent amount of discussion about the syntax before `for pat in it` was chosen
[00:51:04] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[00:51:17] <ww> tikue, i was j/k
[00:51:20] <tikue> oh lol
[00:51:25] *** Quits: heftig (heftig@moz-843B77E4.dip0.t-ipconnect.de) (Ping timeout)
[00:51:56] <ww> if we can get to for i in vec {} for simple case, that would be great.
[00:52:02] <pnkfelix> ww: it wasn't clear to me either, FYI
[00:52:05] <benh> for each i in vec where i ... limit 5 { }
[00:52:14] <tikue> pnkfelix: what wasn't clear?
[00:52:23] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[00:52:23] *** ChanServ sets mode: +ao dherman dherman
[00:53:18] *** Quits: Ralith (ralith@A8995AA9.62B6AF6A.922221DB.IP) (Ping timeout)
[00:53:37] <pnkfelix> tikue: the implicit "j/k" in ww's comment.  I basically agreed with your assertion that there's no reason to bikeshed for bikeshedding's sake, which is what I thought was going on from the earlier comments.
[00:54:15] <tikue> pnkfelix: ahh, ok
[00:54:21] *** Quits: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[00:54:54] <tikue> well, anyway, i'll be really happy if/when we reach the point where we can do `for x in [1, 2, 3] { .. }` -- basically changing/fixing rvalues, implement for loops in rustc, and iterable trait
[00:55:43] <tikue> http://tinyurl.com/pv33d85
[00:55:47] <engla> I'm a bit concerned we can't write iterators that use    fn next<'a>(&'a mut self) -> Option<&'a T>;  i.e. each yielded element is a ref *into* the iterator. Not sure if it would work well with the iterator API in general
[00:56:08] <engla> As far as I understand it, it's not possible to write a trait that allows it
[00:56:24] <strcat> it's possible to write a trait allowing it
[00:56:35] <strcat> it's not possible for Iterator to support the use case, while also working for what it does now
[00:56:51] <engla> ok, do you mind elaborating what that would look like? I haven't managed
[00:56:52] *** Joins: infynyxx_ (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[00:57:08] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Connection reset by peer)
[00:58:19] <strcat> sec
[00:58:24] *** Joins: mrordinaire (Mibbit@1143DEE0.A607747.FD383126.IP)
[00:58:27] *** Joins: ChrisOei (Adium@moz-BE33DA21.fw1.sfo1.mozilla.net)
[00:58:28] *** Joins: Transformer (Transforme@moz-83357A1F.dyn.optonline.net)
[00:59:53] <engla> my try looks like this. The commented out normal method has my expected behavior, the   uncommented trait impl does not compile. https://gist.github.com/anonymous/450c6c1c0445cadbd174
[00:59:54] *** Quits: kelvin (kelvin@moz-3D989EF4.hsd1.va.comcast.net) (Ping timeout)
[01:00:00] *** Joins: heftig (heftig@moz-A00845E7.dip0.t-ipconnect.de)
[01:00:58] <strcat> engla: I'll brb a bit later
[01:01:00] *** Quits: strcat (strcat@moz-61B073BC.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.1)
[01:01:49] *** Parts: Transformer (Transforme@moz-83357A1F.dyn.optonline.net) ()
[01:03:46] <engla> ok, don't worry
[01:06:38] *** Quits: rusti (rusti@moz-61B073BC.cpe.net.cable.rogers.com) (Ping timeout)
[01:07:23] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[01:08:11] *** kimundi is now known as zz_kimundi
[01:08:29] *** Joins: Larry (larryfox@moz-8D6C9B2A.nycmny.fios.verizon.net)
[01:09:04] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Ping timeout)
[01:09:47] *** nrc is now known as nrc|lunch
[01:09:53] *** Quits: SiegeLord (sl@moz-1DF56822.twcny.res.rr.com) (Quit: Leaving)
[01:10:46] <pnkfelix> engla: I have a fix for you, though it might just represent a bug in the borrow-checker
[01:10:47] *** Quits: Thad (chatzilla@moz-C35F90AE.tx.res.rr.com) (Quit: ChatZilla 0.9.90.1 [Firefox 24.0/20130905180733])
[01:11:26] <pnkfelix> engla: try this signature instead for the PermutationsDuckTyped impl of next: 
[01:11:30] <pnkfelix> engla: fn next<'a>(&'a mut self) -> Option<&'self [T]> { â€¦ }
[01:11:32] *** zz_kimundi is now known as kimundi
[01:11:38] <tikue> erickt: how about option.take_iter()
[01:11:43] <cmr> pnkfelix: tjc: re-r? https://github.com/mozilla/rust/pull/8540
[01:11:47] <engla> yes that compiles pnkfelix but it passes through the soundness hole
[01:12:19] <tjc> cmr: r+'ed, thanks!
[01:12:26] <pnkfelix> engla: right, I did say it might represent bug in borrow checker.
[01:12:27] <engla> pnkfelix: https://github.com/mozilla/rust/issues/9069
[01:12:33] <engla> ah ok I get it
[01:12:42] <engla> pnkfelix: I don't know this very well
[01:12:54] *** Quits: infynyxx_ (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[01:13:22] <pnkfelix> engla: how about this instead: fn next(&mut self) -> Option<&'self [T]> { â€¦ }
[01:13:25] <pnkfelix> engla:  (same body)
[01:14:48] <pnkfelix> engla: this probably represents yet another (or perhaps the same) bug in borrowck's handling of 'self
[01:14:56] <engla> I think so
[01:15:50] <pnkfelix> engla: but I'm not clear on what you're trying to accomplish with `fn next<'a>`, because the lifetime bound there is just attached to `&'a mut self`, so it sounds to me like you might as well be talking about 'self ...
[01:16:30] <pnkfelix> engla: I.e. why not: `trait Iter<A> { fn next(&mut self) -> Option<A>; }` ?
[01:17:18] <pnkfelix> engla: but then again, your original statement to strcat said you wanted to return Option<&'a A>; that would be a different story, I guess.
[01:18:47] <engla> yes, to enable   next<'a>(&'a mut self) -> Option<&'a [T]>     (or &'a T)
[01:19:12] <engla> which you need if the iterator is to own the origin of the slice or the origin
[01:19:44] <engla> the implementation in point is the permtuation iterator, that could be efficient (no full vector clones) if it could provide a vec slice per iteration
[01:20:17] <ww> is method overload ever going to be supported?
[01:20:31] <cmr> ww: it hasn't been rejected afaik
[01:20:48] <engla> Another example, a string line iterator from a Reader  that keeps a backing buffer and yields the next line as a slice each iteration
[01:20:50] <cmr> it's backwards compatible though
[01:21:05] <engla> so it doesn't need to copy each line (caller can do it if needed)
[01:21:22] <ww> ok thx
[01:21:50] <engla> (A reservation: iterators with more complicated lifetime relations than currently allowed might not be easy to use with all adaptors)
[01:24:38] *** Quits: jstevans (Instantbir@moz-735D8260.washdc.fios.verizon.net) (Ping timeout)
[01:24:45] *** Quits: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net) (Client exited)
[01:24:46] *** Quits: ceninan (ceninan@moz-6BD43586.a370.priv.bahnhof.se) (Ping timeout)
[01:25:06] *** Joins: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net)
[01:25:37] *** Joins: maik (maik@moz-3F2CDB33.dip0.t-ipconnect.de)
[01:25:41] *** Quits: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net) (Connection reset by peer)
[01:25:59] *** Joins: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net)
[01:26:48] <cmr> bjz: https://github.com/bjz/sax-rs/pull/1
[01:27:39] *** Quits: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net) (Ping timeout)
[01:28:19] <pnkfelix> engla: there's still some problems in your desirata that I don't think are related to lifetime or iterators.
[01:28:43] <pnkfelix> engla: Namely, you originally said to strcat that you wanted `fn next<'a>(&'a mut self) -> Option<&'a A>;`
[01:29:12] <pnkfelix> engla: but if I try to make that work out with your example, I end up with `trait Iter<A> { fn next<'a>(&'a mut self) -> Option<&'a A>; }`
[01:29:37] <engla> right, I can't express it as a trait
[01:29:46] <nmatsakis> pnkfelix: to achieve that signature (what engla first suggested) requires something like higher-kinded types...
[01:29:56] <pnkfelix> engla: and then we can't plug in `[T]` for A (because we don't have DST https://github.com/mozilla/rust/issues/6308
[01:30:02] <nmatsakis> ...it is a common request though, it's something I have vaguely in mind as a later extension
[01:30:16] <nmatsakis> (that is, to achieve it without modifying the trait)
[01:30:19] <tikue> nmatsakis: i like the sound of that...
[01:30:25] <pnkfelix> nmatsakis: is this not something that would be resolved via DST ?
[01:30:52] <nmatsakis> pnkfelix: well, the way you wrote the Iter trait, yes, but the actual iterator trait is `trait Iterator<A> { fn next(&mut self) -> Option<A>; }`
[01:31:19] <nmatsakis> and here the problem is that the lifetime 'a that would be declared on `next` is not in scope for values of the type parameter A
[01:31:33] <pnkfelix> nmatsakis: oh i see
[01:31:45] <nmatsakis> you'd need something like trait Iterator<A<'a>> { fn next<'a>(&'a mut self) -> Option<A<'a>>; }
[01:31:53] <pnkfelix> nmatsakis: you're thinking instead the trait gets a higer-order type constructor that takes a lifetime and returns a type
[01:32:11] *** Quits: lbergstrom (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[01:32:31] <engla> I'm not sure that my "request" is suitable for the general iterator trait. It's just an urge, to create some iterators that don't need to copy
[01:32:37] *** Quits: adu (alt@moz-BF2B1AE4.washdc.fios.verizon.net) (Quit: adu)
[01:33:33] <nmatsakis> engla: well, this comes up in other situations -- conditions, chunked iterators
[01:33:35] <engla> (and in that way are equivalent to internal iterators)
[01:33:42] <nmatsakis> I've actually not really been following the whole thread
[01:33:47] <nmatsakis> I just jumped in on the last few comments :)
[01:34:32] *** Quits: doomlord (doomlod@moz-DEFFB365.range81-147.btcentralplus.com) (Ping timeout)
[01:35:13] <nmatsakis> however, what pnkfelix said is correct (at least until DST is implemented) if you define the trait the way he did...
[01:35:22] *** Quits: ChrisOei (Adium@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: Leaving.)
[01:35:23] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Connection reset by peer)
[01:35:26] <tikue> i think repr is broken for doubly linked lists
[01:35:53] *** Quits: carllerche (carllerche@1E2EB9E3.186539A3.965084DF.IP) (Quit: carllerche)
[01:36:05] <pnkfelix> nmatsakis: I suspect engla's use case is more in line with what you are talking about; his code was i think just an attempt to find some approximation of what he wanted to express
[01:37:03] <engla> the old internal iterators (std::vec::each_permutation, now removed) they can set up a permutation, pass a slice to it to a callback, then continue working with the same buffer. that's the thing we'd maybe want to express
[01:37:46] <tikue> https://gist.github.com/tikue/6c69f3f0862627c3df74
[01:37:49] <tikue> is there an issue for that ^
[01:37:50] <engla> And you can, I think, if you separate the buffer into one object and the iterator into another
[01:38:23] <engla> (or maybe that was my old workaround that uses the borrowck hole)
[01:39:08] <engla> tikue: I think it's kind of expected?
[01:39:13] <pnkfelix> tikue: cycles?  No way we handle cycles yet.  There is an issue for it, give me a sec
[01:39:25] <tikue> engla: bus error is expected behavior? @_@
[01:39:43] <tikue> for repr?
[01:39:57] <pnkfelix> tikue: We lost stack growth checking with the switch to the new runtime
[01:40:15] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[01:40:18] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[01:40:25] <pnkfelix> tikue: so it depends on what you're talking about, what you expected to happen.
[01:40:32] <tikue> pnkfelix: even without that, is there something repr can do to avoid the problem?
[01:40:47] <pnkfelix> tikue: so, here's at least one issue for this : https://github.com/mozilla/rust/issues/6180
[01:41:14] <tikue> repr should print something usable for doubly linked data structures -- would there be a way it could check for it?
[01:41:30] <tikue> pnkfelix: oh great, thanks
[01:41:50] <pnkfelix> tikue: sure, there are plenty of techniques for this.  i put some notes on it on #3768
[01:42:12] <tikue> pnkfelix: cool thanks, just wanted to make sure it was on the radar :)
[01:44:54] *** Joins: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP)
[01:45:52] <Infiltrator> bjz: Well; thank you.
[01:46:23] <strcat> hm
[01:46:36] <strcat> I need to figure out how to set sret on calls to fn ptrs...
[01:47:04] <nmatsakis> strcat: you mean extern fn ptrs?
[01:47:17] <nmatsakis> strcat: or closures?
[01:47:27] <strcat> nmatsakis: both :) (using sret in rust fns)
[01:47:43] <strcat> not for the boring ABI reasons, but because of the optimizations it enables
[01:47:54] * strcat kind of wants to teach LLVM to do those *without* sret but this is good for now
[01:48:03] <nmatsakis> strcat: we should already do it for extern fns
[01:48:13] <strcat> nmatsakis: I mean extern "Rust" fns though
[01:48:24] <strcat> we already set it on C ones
[01:48:26] <strcat> I think...
[01:48:28] <nmatsakis> strcat: oh, ok. yeah those are called through a separate path
[01:48:33] <nmatsakis> I believe we do for C fns
[01:49:21] <strcat> also I think we could potentially just not use ret ptrs for our native API - LLVM knows how to "demote" to sret
[01:49:26] <strcat> need to investigate that later
[01:50:08] *** Joins: lbergstrom (Adium@moz-7D905691.avante-wifi.mozilla.hq)
[01:50:14] <strcat> although I don't think it has the optimization knowledge clang does about when to cross over :(
[01:50:52] <tikue> what happened to <->
[01:50:53] *** Joins: jstevans (Instantbir@moz-735D8260.washdc.fios.verizon.net)
[01:51:00] <strcat> swap(&mut a, &mut b)
[01:51:06] <strcat> it should be in prelude imo
[01:51:16] <strcat> it's in util
[01:51:23] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[01:52:06] <tikue> strcat: sorry that was an ambiguous question -- i know about swap, I never knew until 2 min ago that <-> used to exist. what was it there for and why was it removed?
[01:52:12] <Luqman> tikue: swap
[01:52:25] <strcat> <- was the move operator
[01:52:37] <cmr> brson: ping
[01:52:39] <strcat> it was replaced with the 'move' keyword, since that worked in more places
[01:52:57] <strcat> and then moves simply became the default, for types containing destructors/&fn/&mut
[01:53:04] <strcat> <-> was the swap operator
[01:53:22] <tikue> sometimes i miss the ability to do multiple assignments on the same line
[01:53:25] *** Quits: jstevans (Instantbir@moz-735D8260.washdc.fios.verizon.net) (Connection reset by peer)
[01:53:26] *** Joins: jstevans1 (Instantbir@moz-735D8260.washdc.fios.verizon.net)
[01:53:39] <tikue> a, b = b, a + b; being the canonical case
[01:53:40] <cmr> You can still do it
[01:53:40] <Luqman> though, <-> worked in some places where util::swap doesn't
[01:53:42] <cmr> Just not mutable.
[01:53:48] <cmr> let (a, b) = (b, a + b);
[01:54:03] <tikue> cmr: it won't work if they're fields of a struct
[01:54:04] <strcat> Luqman: well, <-> was also slow because it checked if the ptrs were equal
[01:54:22] *** Joins: adu (alt@moz-BF2B1AE4.washdc.fios.verizon.net)
[01:54:31] <cmr> tikue: Hm, can you give an example?
[01:54:33] <tikue> cmr: or if anything has a reference to them
[01:54:35] <nmatsakis> Luqman: where did <-> work that swap doesn't? I guess for swapping indices of a vector?
[01:54:36] <cmr> Like, s.a, s.b = ...?
[01:54:41] <tikue> cmr: yeah
[01:54:44] <cmr> Ah
[01:54:47] <strcat> nmatsakis: it allowed the locations to alias
[01:54:49] <strcat> since it checked
[01:54:57] <Luqman> nmatsakis: yea
[01:55:03] <cmr> let Struct { a, b } = ..., perhaps?
[01:55:15] <nmatsakis> between swap and the swap_indices method, I guess it's all covered though
[01:55:20] <strcat> yeah
[01:55:21] <cmr> That might only be destructuring though
[01:55:28] <tikue> cmr: from earlier, someone was doing something like this https://gist.github.com/tikue/02cf64e8c26e3e0a4202
[01:55:45] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[01:55:45] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/LTE94g
[01:55:45] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[01:55:49] <strcat> nmatsakis: I remember a time when 'let mut x = 5; x <-> x;' would segfault :)
[01:56:18] <cmr> rusti: let mut x = ~5; x = x; x
[01:56:20] -rusti- application terminated abnormally with signal 11 (Segmentation fault)
[01:56:24] <cmr> *cough*
[01:56:45] <nmatsakis> I still can't believe that fails, I feel like I fixed that bug 2 or 3 times
[01:56:50] * nmatsakis sighs
[01:57:02] <cmr> Did you add a test? :P
[01:57:14] *** Quits: lbergstrom (Adium@moz-7D905691.avante-wifi.mozilla.hq) (Quit: Leaving.)
[01:57:26] <nmatsakis> apparently not!
[01:57:27] <nmatsakis> :)
[01:57:36] <brson> cmr: pong
[01:57:45] <nmatsakis> maybe I just *thought about* fixing it 2 or 3 times ;)
[01:58:01] <cmr> brson: How can I dial into and listen to the weekly meetings each week?
[01:58:10] <strcat> nmatsakis: nope we call extern "C" fns wrong
[01:58:46] <strcat> hrm
[01:58:48] <strcat> or do we
[01:59:52] <strcat> nmatsakis: http://ix.io/812 here
[02:00:27] <strcat> nmatsakis: http://ix.io/814 from this
[02:00:29] <tikue> cmr: yeah i'd like to know as well heh
[02:00:38] <strcat> nmatsakis: the `call` there actually needs to specify sret
[02:00:42] <strcat> because LLVM doesn't know
[02:00:49] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[02:00:49] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/IGPqcA
[02:00:49] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[02:00:50] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[02:00:50] <ghrust> 01[13rust01] 15bors pushed 7 new commits to 06auto: 02http://git.io/dggrTQ
[02:00:50] <ghrust> 13rust/06auto 146ab21d4 15Corey Richardson: Add rustdoc_ng
[02:00:50] <ghrust> 13rust/06auto 145d42966 15Felix S. Klock II: Finish addition of rustdoc_ng to Makefiles.
[02:00:50] <ghrust> 13rust/06auto 141e65b03 15Corey Richardson: Update rustdoc_ng to new ast naming
[02:00:51] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[02:00:59] <ww> i got a weird problem with trait inheritance
[02:01:10] <ww> the wrong method in the base trait is being called
[02:01:11] <strcat> nmatsakis: http://ix.io/816 a clang example
[02:01:17] <strcat> nmatsakis: anyway, I haven't figured out how to do it yet :)
[02:03:36] <pnkfelix> tikue: in that example, couldn't you just assign to *self ?
[02:03:43] <ww> trait t1 { m1(); m2() }   trait t2 : t1 { m3(); }   imp t1 for s1 {}   imp t2 for s1 {}     then calling s1.m2() could call s1.m1().  seems like the dispatching is messed up.
[02:04:19] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[02:04:37] <pnkfelix> rusti: struct S {a:int, b:int} impl S { fn next(&mut self) { *self = S { a: 3, b: 4 } } } let mut s = S {a:7,b:8}; s.next(); s
[02:04:37] -rusti- main::S{a: 3, b: 4}
[02:04:44] <ww> sorry^ should be calling t2.m2() ends up calling m1()
[02:05:19] <tikue> pnkfelix: like this?     *self = FibStream { first: self.second, second: self.first + self.second };
[02:05:35] <tikue> i'm not sure that's more readable than using a temp variable
[02:05:38] <pnkfelix> tikue: right.  Also see the thing I just sent to rusti
[02:05:46] <nmatsakis> strcat: oh, there's an extra attribute on the *call* itself?
[02:05:49] <nmatsakis> strcat: no, we don't set that
[02:06:00] <strcat> nmatsakis: yeah, because it doesn't know the type of the fn ptr except what you do at the call
[02:06:04] <tikue> it's certainly not awful
[02:06:12] <strcat> nmatsakis: since it doesn't know where it came from
[02:06:29] <tikue> pnkfelix: and i suppose for more complex structs you can do a functional update
[02:06:32] <strcat> nmatsakis: pretty sure it causes the wonderful segfault I'm running into  :)
[02:06:50] <strcat> although, it's because I added it to rust functions and we have a lot of those ;p
[02:07:07] <strcat> unlikely that there's a single C function ptr call where it returns via sret in the codebase...
[02:07:49] <strcat> nmatsakis: absolutely no idea how to set it though
[02:07:53] <strcat> going to have to copy clang...
[02:07:56] <strcat> maybe it's not exposed
[02:09:24] <tikue> pnkfelix: actually, if you had a simple loop it wouldn't work in that case. `let mut (a, b) = (0, 1); loop { /* now what? */ }`
[02:09:41] <erickt1> dbaupp / kimundi / pnkfelix: r? https://github.com/mozilla/rust/pull/9115
[02:09:45] *** Quits: riley (riley@8BA43816.9AA11D69.65DDFA89.IP) (Client exited)
[02:10:00] <nmatsakis> strcat: interesting
[02:11:08] <brson> cmr: thinking
[02:12:41] <pnkfelix> tikue: not pretty, but: ...
[02:12:46] <pnkfelix> rusti: let mut state = (0,1); loop { let (a,b) = state; if b > 10 { break; }; state = (b+a, a); }; state
[02:12:47] -rusti- (21, 13)
[02:13:32] <pnkfelix> tikue: but I'll admit at this point we're not comparing apples and oranges.
[02:13:52] *** Joins: carter (carter@moz-F3C2A2D8.nycmny.fios.verizon.net)
[02:14:45] <tikue> pnkfelix: though you could do state = (state.second(), state.first() + state.second()) :P
[02:15:02] <tikue> anyway, i don't know, i don't think it comes up often, but it's always a bummer when it does
[02:15:41] <pnkfelix> i think we're better off, all things considered.  I was in the mtg where they decided to remove multiple assignments.
[02:15:46] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Quit: Gone to save the world!)
[02:15:50] *** Quits: jstevans1 (Instantbir@moz-735D8260.washdc.fios.verizon.net) (Ping timeout)
[02:16:00] <pnkfelix> (i mostly listened, I didn't have an opinion on it)
[02:16:33] <tikue> after sitting in on the research meetings, i have no doubt the reasons were good onesâ€¦though i'm interested to know what they were
[02:18:31] <maik> do we have rpc's or rmi's in Rust?
[02:18:44] <strcat> nmatsakis: you also need to set things like zeroext, signext, noreturn, etc. - pretty annoying that it's separate from the fn type
[02:19:06] * strcat can't tell if this is where clang sets it for calls
[02:19:07] *** Quits: mark_edward (quassel@moz-97E995A.hsd1.in.comcast.net) (Connection reset by peer)
[02:19:13] <cmr> maik: those being?
[02:19:20] <cmr> Oh
[02:19:24] <cmr> maik: not built into the language.
[02:19:48] <tikue> fib2.rs:3:0: 8:1 error: cannot provide an extension implementation for a trait not defined in this crate
[02:19:48] <tikue> fib2.rs:3 impl Iterator<int> for (int, int) {
[02:19:50] <tikue> what does this mean?
[02:20:01] <tikue> what trait?
[02:20:04] <cmr> tikue: Iterator
[02:20:13] <strcat> neither the trait or the type is defined in your crate
[02:20:22] <cmr> You can't implement Iterator for types that aren't your own, since you don't own Iterator
[02:20:30] <tikue> interesting
[02:20:42] *** Quits: azakai (alon@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[02:22:10] <pnkfelix> tikue: I think the decision was from https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-05-14
[02:22:35] <pnkfelix> tikue: (for removing let binding of multiple comma-separated patterns)
[02:23:05] <tikue> pnkfelix: was there ever a point where it wasn't just let bindings? because you can still do let (foo, bar) = (1, 2) which seems functionally equivalent to me
[02:24:19] <ww> has trait composition been implemented in 0.8-pre?
[02:24:29] <ww> trait mixin
[02:24:38] <cmr> ww: What do you mean?
[02:24:55] <ww> trait t1 : t2 {}
[02:24:58] <pnkfelix> tikue: I think at the time it allowed you to say `let mut a = 3, b = 4; b = 5`
[02:25:14] <strcat> ww: well trait inheritance works
[02:25:15] <tikue> oh ok
[02:25:15] <ww> trait inheritance/composistion
[02:25:31] <strcat> the stdlib uses it
[02:25:44] *** Joins: jstevans (Instantbir@moz-735D8260.washdc.fios.verizon.net)
[02:25:48] <strcat> and default methods'
[02:25:53] <pnkfelix> tikue: (the nature of which might explain why we removed this)
[02:26:02] <tikue> pnkfelix: yes heh
[02:26:31] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[02:26:59] <ww> strcat: ok, may be i hit a bug then.  i got dispatching to the wrong base trait method when calling another base method
[02:27:45] <ww> calling t2.method1_in_t1() ends up calling method2_in_t1
[02:27:48] <strcat> ww: are you using static dispatch or trait objects?
[02:27:56] <ww> trait objects
[02:28:00] <strcat> default methods and inheritance don't really work with trait objects
[02:28:07] <strcat> sometimes they do...
[02:28:11] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[02:28:15] <strcat> regular usage of traits is solid
[02:28:43] <ww> i casted the implementing struct to t2, and then calling t1's methods through t2
[02:29:06] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[02:29:16] <strcat> trait objects are known to be flaky
[02:29:20] *** Joins: fyolnish (fyolnish@moz-BE2BAE5B.miinet.jp)
[02:29:22] <ww> ok
[02:29:36] <cmr> And we don't have a sully to fix them anymore :(
[02:29:41] <ww> i'll avoid it for now, and do composition myself
[02:29:43] <cmr> sully: unless we do? :)
[02:29:50] <strcat> trait Foo { ... } trait Bar: Foo { ... } fn f<T: Bar>(x: T) { ... } will work fine
[02:29:59] *** Quits: kseo (kseo@338DE5BC.4166765B.485A6DF.IP) (Ping timeout)
[02:30:04] <strcat> ww: do you really need trait objects for your use case? you can't use generics or enums?
[02:30:05] *** Quits: kimundi (kimundi@moz-49A81A98.dip0.t-ipconnect.de) (Ping timeout)
[02:30:31] <ww> i need to wrap a stateful connection with an interface
[02:30:48] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[02:30:48] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1458c0b87 to 1419c0735: 02http://git.io/N3iJvQ
[02:30:48] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[02:30:52] <ww> the TclStream needs to be mutable and stateful
[02:30:55] *** Joins: Ralith (ralith@114DA04D.CD83ED0A.BCDF04A6.IP)
[02:31:09] <strcat> ww: well that's not what you need to do, it's how you're doing it
[02:31:15] <ww> i want to return an interface to the user rather than returning a struct
[02:31:25] <strcat> why?
[02:31:38] *** nrc|lunch is now known as nrc
[02:31:46] <strcat> rustic code would return the struct, and let the user decide if they want static or dynamic dispatch
[02:31:48] <ww> because i have multiple implementations of the same interface
[02:32:07] <strcat> ww: so you have one function returning one of N possible implementations?
[02:32:20] <ww> depending on how the user initiates it, he will get a differet implemenation but the same interface
[02:32:28] <ww> yes
[02:32:37] <strcat> and you don't know the precise set of possible implementations?
[02:32:55] <ww> i don't want the user to have to change their code just because i have multiple implementation
[02:33:04] <strcat> the user doesn't have to change their code
[02:33:14] <ww> the implementations are different but the interface is the same
[02:33:17] *** Joins: kimundi (kimundi@moz-AAB55991.dip0.t-ipconnect.de)
[02:33:28] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[02:33:29] <strcat> okay, but if you know the full set of implementations you don't need a trait object - it's just an option
[02:33:58] <strcat> you can return an enum implementing the trait, and trait inheritance will work + it doesn't need to be boxed
[02:34:12] <strcat> at some crossover point, an indirect call will become faster than a type switch
[02:34:32] <strcat> but it's unlikely most people will ever have to worry about the performance tradeoff
[02:34:56] <ww> ok
[02:35:13] <ww> i'll look into whether enum implementing trait would work
[02:35:40] *** Quits: busylizzy (lisa@85228838.12D0DC84.211374C4.IP) (Ping timeout)
[02:36:04] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[02:36:51] *** Joins: busylizzy (lisa@85228838.12D0DC84.211374C4.IP)
[02:37:02] <cmr> http://buildbot.rust-lang.org/builders/auto-win-32-opt/builds/1435/steps/compile/logs/stdio
[02:37:05] <cmr> Is that failure my fault?
[02:37:15] <cmr> I never touch anything related to SetLastError
[02:37:47] <cmr> Ohhh I use std::unstable::dynamic_lib  which *does* use SetLastError
[02:37:50] <cmr> but that's in libstd
[02:37:56] *** kimundi is now known as zz_kimundi
[02:37:58] <cmr> I imagine std.dll would link to what it needs for that symbol?
[02:38:24] *** Quits: bbouvier (bnjbouv@moz-63AFAFBF.gagahome.fr) (Ping timeout)
[02:40:15] <cmr> bjz: ping
[02:41:40] *** Joins: etw (john@moz-D871A25B.nyc.res.rr.com)
[02:41:46] *** Joins: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net)
[02:42:47] *** Joins: hoverbear (andrew@moz-86FCBF4B.gv.shawcable.net)
[02:43:02] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[02:44:10] *** Joins: ChrisMorgan (chris@moz-2DEFC48E.its.monash.edu.au)
[02:44:51] *** zz_kimundi is now known as kimundi
[02:49:51] *** Quits: jstevans (Instantbir@moz-735D8260.washdc.fios.verizon.net) (Ping timeout)
[02:52:13] *** Quits: jorendorff_away (jorendorff@moz-C5535E6C.compute-1.amazonaws.com) (Quit: eaten by grue)
[02:53:44] *** Quits: mihneadb (Mihnea@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: Leaving)
[02:59:36] *** Joins: mihneadb (Mihnea@moz-BE33DA21.fw1.sfo1.mozilla.net)
[03:00:15] *** Joins: jorendorff_away (jorendorff@moz-C5535E6C.compute-1.amazonaws.com)
[03:00:57] *** Quits: samx (sami@moz-D9DA5773.dyn.optonline.net) (Quit: This computer has gone to sleep)
[03:01:06] *** Quits: adu (alt@moz-BF2B1AE4.washdc.fios.verizon.net) (Ping timeout)
[03:02:00] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[03:02:37] *** Quits: mihneadb (Mihnea@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: Leaving)
[03:06:23] <strcat> nmatsakis: figured it out :)
[03:06:35] <strcat> nmatsakis: http://llvm.org/docs/doxygen/html/group__LLVMCCoreValueInstructionCall.html simple after all
[03:06:40] <strcat> you just set the attributes on the call inst itself
[03:06:50] * strcat was trying to figure out how to set it on the fn ptr...
[03:07:13] <strcat> acrichto: I found the issue btw
[03:07:15] *** Joins: kelvin (kelvin@moz-3D989EF4.hsd1.va.comcast.net)
[03:07:23] <acrichto> strcat: oooh where at?
[03:07:36] <strcat> acrichto: it also means I discovered a bug in our handling of foreign fn ptrs
[03:07:49] <strcat> acrichto: so, you need to set sret on the call instruction for an indirect call.
[03:07:52] <strcat> as in a function ptr
[03:07:56] <strcat> because it doesn't know the type
[03:08:12] <acrichto> wait don't we know the type of the function pointer?
[03:08:15] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[03:08:50] <strcat> acrichto: you know the type, but no the attributes
[03:08:53] <strcat> for example
[03:09:12] <etw> if I have a circular reference in two structures, is there a way to create a forward declaration?
[03:09:14] *** Joins: adu (alt@moz-BF2B1AE4.washdc.fios.verizon.net)
[03:09:15] <strcat> lets say you have an i1 parameter
[03:09:21] <brson> cmr: can you ping me again monday about that?
[03:09:24] <strcat> you probably mark it as 'zeroext'
[03:09:29] <cmr> brson: sure
[03:09:35] <acrichto> strcat: aaah, nice catch :)
[03:09:36] *** Quits: mrordinaire (Mibbit@1143DEE0.A607747.FD383126.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[03:09:36] <strcat> but the actual function type object doesn't include zeroext
[03:09:46] <strcat> acrichto: yeah
[03:09:47] <acrichto> that's tricky
[03:09:57] <strcat> acrichto: I looked at the IR of std.ll
[03:09:59] *** Joins: MrOrdinaire (Mibbit@1143DEE0.A607747.FD383126.IP)
[03:10:02] <strcat> couldn't figure out what was going wrong
[03:10:09] <strcat> then I looked at a bunch of C++ examples with clang
[03:10:14] <strcat> noticed they set sret on the call inst...
[03:10:25] <acrichto> tjc: ping
[03:10:26] *** Quits: busylizzy (lisa@85228838.12D0DC84.211374C4.IP) (Ping timeout)
[03:10:31] <tjc> acrichto: pong
[03:10:34] <acrichto> strcat: yeah that'd do it I'd imagine
[03:10:38] <strcat> also - they return all values under 2 words in size directly
[03:10:39] <acrichto> tjc: mind if I p=1 on https://github.com/mozilla/rust/pull/9141 ?
[03:10:45] <engla> etw: I don't think you need a forward decl
[03:10:51] <tjc> acrichto: Sure, go ahead
[03:10:55] <acrichto> tjc: I'm tired of seeing all these fileinput failures and I'm hoping that this'll help fix them
[03:10:56] <strcat> so I might try changing how immediates work.... would be nice to ignore types and just use the actual size
[03:11:11] <strcat> not sure if they use 2 words everywhere or just x86_64
[03:11:11] <tjc> acrichto: I was trying to get my rustpkg pull requests in because it's the servo work week and I was hoping to do some work with Jack on porting servo to rustpkg...
[03:11:13] <etw> engla: I think I might, at least because they're in different files
[03:11:19] <tjc> but at this point stuff will just build overnight anyway :-)
[03:11:31] <engla> etw: go ahead and try :)
[03:11:35] <acrichto> tjc: awesome! feel free to cut in line ahead
[03:11:46] *** Quits: paulproteus (quassel@rose.makesad.us) (Ping timeout)
[03:12:00] *** Joins: busylizzy (lisa@85228838.12D0DC84.211374C4.IP)
[03:12:17] <acrichto> strcat: do you mean that we don't need sret b/c we no longer have outptrs?
[03:12:30] *** Joins: paulproteus (quassel@moz-E86A3B42.makesad.us)
[03:12:36] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[03:12:37] <strcat> acrichto: we only use out pointers on non-immediates
[03:12:44] <strcat>  but how we decide a type is immediate isn't very good
[03:12:52] <klutzy> is there a good way to define static BigInt in a platform-independent way?
[03:13:01] <strcat> klutzy: no
[03:13:55] <acrichto> strcat: so in theory we don't even need that logic, right?
[03:13:59] <acrichto> llvm should just do it all for us?
[03:14:03] <klutzy> ah, strings may help but I feel it's sort of workaround
[03:14:24] <engla> the representation of BigInt needs an allocation anyway (~[u32]) so it can't be static
[03:14:25] <strcat> acrichto: it should, but I don't think it is solid enough
[03:14:34] <strcat> it will lower by-value returns to sret
[03:14:42] <etw> engla: no luck with the circular use, I think I'll stick to putting them in one file for now
[03:14:46] *** Joins: jstevans (Instantbir@moz-735D8260.washdc.fios.verizon.net)
[03:14:49] <acrichto> strcat: yeah that's what I'd expect
[03:14:58] <klutzy> acrichto: on rt io: I built std with --cfg rtdebug but it didn't produced any useful info I remember
[03:14:59] <strcat> acrichto: I don't know when it will lower them
[03:15:04] <strcat> acrichto: need to do a bunch of testing ;]
[03:15:20] <strcat> acrichto: the code to lower them is definitely *there* but it might not be as fine tuned as clang's choice (2 words)
[03:15:24] <strcat> it might do it at 50 or something...
[03:15:40] <strcat> it *should* be possible to not do out pointers ourselves though, except for foreign calls
[03:15:49] <acrichto> klutzy: I was mostly curious what the "unknown error code" was coming from libuv
[03:16:23] <acrichto> strcat: yeah that's a bit unfortunate about foreign calls
[03:16:34] <acrichto> strcat: that's an ABI issue right to make sure that it's lowered correctly?
[03:16:41] <strcat> acrichto: well that's why clang does it in the frontend - ABI concerns
[03:16:44] <acrichto> strcat: it seems like we could just label the foreign fn with the right abi
[03:16:53] <strcat> for example, the x86_64 ABI has a special rule for C99 complex numbers
[03:17:02] <strcat> a completely special return rule, yay
[03:17:04] <acrichto> I was reading that
[03:17:06] <acrichto> it's scary
[03:17:16] *** Quits: jstevans (Instantbir@moz-735D8260.washdc.fios.verizon.net) (Ping timeout)
[03:17:19] <strcat> anyway for now I will fix this sret issue
[03:17:30] <strcat> later, it would be nice to add noalias to the return value for ~T fn ptrs
[03:17:35] <klutzy> acrichto: aha, I'll try it.
[03:17:38] <strcat> but it's such an edge case that I don't care enough to make this code generic
[03:18:00] * strcat makes an issue
[03:18:02] <klutzy> I'm building std-@#$.dll at ~/tmp and test exe linked with it
[03:18:03] <acrichto> klutzy: rt/uv/mod.rs:264
[03:19:12] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[03:19:34] <klutzy> acrichto: self_fd.write() err: rt::uv::UvError(-4094i32)
[03:19:45] <klutzy> where err is input of uv_error_to_io_error
[03:20:10] <acrichto> what in the world is 4094
[03:20:33] *** Joins: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP)
[03:20:34] *** Quits: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP) (Z:lined (Open Proxy found on your host. Please visit www.blitzed.org/proxy?ip=115.68.131.49 for more information.))
[03:20:44] *** Quits: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com) (Quit: pcwalton)
[03:20:46] <klutzy> when I try to read a file, it emits -4093i32
[03:21:20] <klutzy> ah, which translated into permission error. I don't know why though
[03:21:24] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: zzzzzzzzzz)
[03:21:55] <acrichto> permission error?
[03:21:57] <acrichto> that's weird
[03:22:05] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[03:22:08] <acrichto> oh
[03:22:16] <acrichto> #define UV__UNKNOWN (-4094)
[03:22:20] <acrichto> that's unfortunate...
[03:22:26] <acrichto> # define UV__EACCES (-4093)
[03:22:37] <klutzy> yep
[03:22:59] <acrichto> klutzy: I wonder, is this because a path is separated with / and not \
[03:23:03] <klutzy> so I have to dive into uv >:)
[03:23:19] *** Joins: lkuper_ (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[03:23:35] <klutzy> acrichto: even for Path("readme")? (you mean Path tranlsates it to "/"-encoded str?)
[03:24:04] <acrichto> oh that probably wouldn't cause problems
[03:24:11] <acrichto> what flags are you opening it with?
[03:24:16] <acrichto> mode/access that is
[03:25:22] <elly> it sounds like strace might be in order
[03:25:38] <acrichto> does strace exist on windows?
[03:25:40] *** Quits: busylizzy (lisa@85228838.12D0DC84.211374C4.IP) (Ping timeout)
[03:25:46] <klutzy> let mut f = file::open(&Path("readme"), io::Create, io::Read).unwrap(); oh wait.. io::Create is strange
[03:25:49] <acrichto> or some equivalent
[03:26:01] <klutzy> I copy-pasted it from write test. fixing
[03:26:01] <acrichto> klutzy: try Create/Write
[03:26:08] <ww> got a ToJson problem, i have a func defined as: set_json<T: ToJson>(data: &T).  set_json(100) works, but set_json("abc") doesn't, and set_json(~"abc") doesn't.
[03:26:13] <acrichto> reading and creating at the same time doesn't quite make sense...
[03:26:32] <klutzy> acrichto: Create/Write raises UV__UNKNOWN
[03:26:35] <strcat> acrichto: there are equivalents to strace
[03:26:43] *** Quits: Jesin (Jessin_@moz-679F0D97.cc.lehigh.edu) (Quit: Leaving)
[03:26:44] <strcat> anyway you can run win32 rust in wine
[03:26:46] <strcat> ;p
[03:26:52] <strcat> but you'll get linux syscalls...
[03:26:53] <acrichto> oh dear
[03:26:58] <ww> got unconstrained type error
[03:27:00] <acrichto> that sounds terrifying
[03:27:00] <klutzy> (with nonexistent file)
[03:27:00] <bjz> cmr: pong
[03:27:21] <strcat> acrichto: lots of people use wine to debug windows programs because windows has no valgrind tool suite
[03:27:41] <strcat> there are alternatives to valgrind itself, but not anything as good as all the stuff it has
[03:27:45] * strcat shrugs
[03:27:49] <ww> i thought ToJson has been implemented for ~str
[03:28:03] <klutzy> acrichto: Open/Read also leads permission error
[03:28:08] <acrichto> ww: looks like it is, also @~str
[03:28:14] <cmr> bjz: so gl-rs
[03:28:15] <acrichto> klutzy: and the file exists?
[03:28:19] <klutzy> yep
[03:28:30] <strcat> um
[03:28:34] <strcat> that did not work as planned ;[
[03:28:35] <strcat>   call sret void %1(%struct.Foo* %__llret)
[03:28:40] <strcat> it's supposed to be on the arg...
[03:28:55] <acrichto> it has the same meaning though, right?
[03:29:00] <strcat> no
[03:29:03] <strcat> Broken module found, compilation aborted!
[03:29:06] <cmr> bjz: 1. why don't you use extra::getopts
[03:29:06] <acrichto> ah
[03:29:19] <strcat> acrichto: it's undocumented what the index param does
[03:29:21] <strcat> I used '0'
[03:29:24] <strcat> maybe '1' is the first param
[03:29:30] <strcat> oh wait sorry
[03:29:33] <ww> acrichto: yep, @~str implements ToJson as well.  don't know whether it's a bug or it's my problem.
[03:29:33] <klutzy> acrichto: when I move the test file, it fails with "no such file" correctly.
[03:29:34] <strcat> '0' is the return value....
[03:29:41] * strcat feels dumb
[03:29:47] <cmr> bjz: 2. what needs to be done for glx/wgl and why would it be desirable to generate bindings for them?
[03:29:51] <klutzy> so it opens, but cannot reads
[03:29:56] <klutzy> for existing file
[03:30:17] <acrichto> klutzy: interesting
[03:30:23] <acrichto> it's UV__UNKNOWN for the reads?
[03:31:09] <klutzy> no, unknown for write, permission for read
[03:31:33] * klutzy goes for lunch
[03:31:36] *** Quits: robn (robn@moz-76B0302C.static.internode.on.net) (Ping timeout)
[03:31:38] <strcat> acrichto: this is the kind of thing I'd love IR tests for
[03:31:48] <acrichto> strcat: in what sense?
[03:31:51] *** Joins: kseo (kseo@338DE5BC.4166765B.485A6DF.IP)
[03:31:52] <acrichto> as in testing for what?
[03:32:01] *** Quits: Sorella (queen@9D963F5D.DF5D8AE7.54BCAB54.IP) (Quit: G'night everynyan~!)
[03:32:11] <cmr> bjz: What's the difference between the ptr and struct generator modes? I don't really understand, but I haven't looked all that deeply yet.
[03:32:12] *** Joins: robn (robn@moz-76B0302C.static.internode.on.net)
[03:32:43] <cmr> bjz: 4. For the cfgs, would it just be #[cfg(name_of_extension)] ?
[03:33:03] <cmr> Or would the generator just not generate them, rather than generating a single gl.rs that can do-it-all
[03:33:11] <cmr> Probably the second.,
[03:33:22] <strcat> acrichto: https://github.com/llvm-mirror/clang/blob/master/test/CodeGen/sret.c look at clang's tests
[03:33:31] *** Quits: kseo (kseo@338DE5BC.4166765B.485A6DF.IP) (Ping timeout)
[03:33:31] <strcat> we need that.
[03:33:56] <strcat> makes it much harder to break stuff silently
[03:34:10] <acrichto> oh I see
[03:34:45] <cmr> strcat: yes, that'd be a very nice form of codegen tests
[03:34:55] <strcat>   call void %1(%struct.Foo* sret %__llret)
[03:34:58] <strcat> fixed!
[03:35:00] <strcat> well
[03:35:08] <strcat> I fixed the problem we already have with foreign fn ptrs
[03:35:13] <strcat> now to fix it for what I added ;p
[03:35:32] <strcat> luckily there's rebase to pretend I fixed this problem... and *then* added working noalias+sret for rust returns ;p
[03:35:49] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[03:35:49] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/cKbgPg
[03:35:49] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[03:36:05] <acrichto> wooo
[03:36:16] <acrichto> strcat: I'm actual very curious to see how this affects the build/test time
[03:36:34] <strcat> acrichto: well there are going to be a bunch more calls into LLVM for correctness now
[03:36:36] <strcat> so... :s
[03:36:53] <acrichto> calls into llvm?
[03:37:12] <strcat> well we are now going to call LLVMAddInstrAttribute every time we generate a call instruction with sret
[03:37:32] <strcat> I don't know how expensive that will be compared to the perf gains from writing directly to the out param
[03:37:53] <acrichto> it's just one function call
[03:37:56] <acrichto> that shouldn't be too bad
[03:38:00] <acrichto> I don't think...
[03:38:09] <strcat> well it's like 50000 calls of this function ;p
[03:38:11] * strcat shrugs
[03:38:14] *** Quits: jyasskin_w (jyasskin@DAF66858.C60FE7DC.4065847B.IP) (Ping timeout)
[03:38:15] <strcat> for something like libstd
[03:38:18] <strcat> probably not bad
[03:38:24] <sfackler> has anyone ever run into an assertation failure on trans/callee.rs:385?
[03:39:04] <acrichto> sfackler: that looks disturbing
[03:39:10] <sfackler> yeah
[03:39:18] <sfackler> it's off of a super small diff from working code too
[03:39:48] <acrichto> monomorphizing a external-crate fn might be kinda difficult
[03:39:51] <ww> sfackler: what's the error?  i might hit by it yesterday
[03:39:53] <sfackler> here's the diff http://sprunge.us/OWei
[03:40:04] <acrichto> sfackler: visit that link
[03:40:09] <sfackler> ww: task <unnamed> failed at 'assertion failed: `(left == right) && (right == left)` (left: `1`, right: `0`)', /build/rust-git/src/rust/src/librustc/middle/trans/callee.rs:385
[03:40:20] <sfackler> oops
[03:40:29] <ww> yes, i got it, too, yesterday
[03:40:50] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[03:40:50] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/aj_n3g
[03:40:50] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[03:41:17] <sfackler> here we go http://sprunge.us/JWUc
[03:41:35] <acrichto> sfackler: oh dear you're not working on the compiler
[03:41:37] *** Joins: jyasskin_w (jyasskin@DAF66858.C60FE7DC.4065847B.IP)
[03:41:42] <sfackler> nope
[03:41:47] <sfackler> :(
[03:42:35] <ww> i got it whenever I used std::rt::io::BufferedStream.  I ended up removing the call to it.
[03:43:51] <sfackler> hmm, did you know if BufferedReader or BufferedWriter work?
[03:44:08] *** Joins: aeqwa (aeqwa@moz-A162D8C8.dsl.tropolys.de)
[03:44:35] <ww> BufferedReader and BufferedWriter work
[03:45:03] <ww> but the problem is they are one-way call, i need bi-directional call.  BufferedStream is the way to go
[03:45:11] <sfackler> yeah
[03:45:15] *** Joins: naq (naq@D5C2D2DF.E4265FCD.E481B5B.IP)
[03:45:34] <ww> i ended up reverting back to the slow TcpStream.
[03:46:15] *** Quits: StarLight (StarLight@moz-BDEDADC1.dynamic.avangarddsl.ru) (Ping timeout)
[03:47:43] *** Joins: busylizzy (lisa@85228838.12D0DC84.211374C4.IP)
[03:47:58] <sfackler> are parameterized newtypes well supported?
[03:48:10] <sfackler> that's the only weird thing I can think of with BufferedStream
[03:48:14] <cmr> struct Foo<T>(T) ?
[03:48:34] <sfackler> well, struct BufferedStream<S>(BufferedReader<InternalBufferedWriter<S>>);
[03:48:57] <sfackler> and
[03:49:03] <sfackler> struct InternalBufferedWriter<W>(BufferedWriter<W>);
[03:50:42] *** Joins: StarLight (StarLight@moz-255C3272.dynamic.avangarddsl.ru)
[03:52:58] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[03:54:19] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[03:58:46] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[04:00:39] <engla> sfackler: there used to be bugs around cross-crate use of newtype
[04:00:42] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[04:00:51] <engla> I think they were basically unusable in public API
[04:00:52] <dbaupp> engla: still are
[04:01:13] <dbaupp> engla: I think generic ones don't work properly
[04:01:20] <engla> aha
[04:01:55] <dbaupp> rusti: let f: ~fn() = || { println("hi, tiffany"); }; f()
[04:01:58] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[04:01:58] -rusti- hi, tiffany
[04:01:58] -rusti- ()
[04:02:13] <strcat> acrichto: decided to make it generic after all.
[04:02:28] <tiffany> huh
[04:02:37] <dbaupp> rusti: let f = || {}; (spawn, spawn(f))
[04:02:38] -rusti- <anon>:5:38: 5:39 error: mismatched types: expected `~fn:Send()` but found `&fn<no-bounds>()` (expected ~ closure, found & closure)
[04:02:38] -rusti- <anon>:5          let f = || {}; (spawn, spawn(f))
[04:02:38] -rusti-                                                ^
[04:02:38] -rusti- error: aborting due to previous error
[04:02:38] -rusti- application terminated with error code 101
[04:02:51] <dbaupp> hm, type inference doesn't work very well
[04:03:09] <dbaupp> but, I'm trying to demonstrate that spawn takes `~fn()`
[04:03:35] <dbaupp> strcat: do you reckon you could add rusti to #rust-gamedev? :)
[04:03:47] <strcat> on this server?
[04:03:51] <dbaupp> yeah
[04:03:57] <strcat> probably
[04:04:03] <strcat> need to figure out how to tell it to join 2 channels
[04:04:07] <strcat> ;p
[04:04:09] <dbaupp> don't bother then :)
[04:04:12] <strcat> too late
[04:04:16] <strcat> it's in my head now
[04:04:17] <adu> lol
[04:05:38] *** Quits: lkuper_ (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Quit: lkuper_)
[04:05:44] <sfackler> yep, looks like it's generic newtypes are totally broken cross-crate https://github.com/mozilla/rust/issues/9155
[04:05:56] <strcat> acrichto: anyway I added  attributes: &[(uint, lib::llvm::Attribute)] to the Call/CallWithConv fns... so this should work now
[04:06:01] <strcat> + it will handle any future needs
[04:06:05] <strcat> like noalias
[04:06:10] <dbaupp> sfackler: https://github.com/mozilla/rust/issues/7899 :P
[04:06:35] <tiffany> rusti: || {"foo"}
[04:06:36] -rusti- fn() -> &'static str
[04:06:44] <tiffany> rusti: ~|| {"foo"}
[04:06:45] -rusti- ~fn() -> &'static str
[04:06:47] <sfackler> dbaupp: different bug, looks like
[04:06:51] <dbaupp> sfackler: really?
[04:06:57] <sfackler> yeah, this is an ICE
[04:06:59] <adu> I thought noalias was discouraged 
[04:07:03] <tiffany> I wonder why rustc was complaining that ~|| is a &~fn
[04:07:05] <dbaupp> sfackler: right
[04:07:26] <sfackler> I ran into 7899 trying to construct Foo without the new method, though
[04:07:27] <acrichto> strcat: nice
[04:07:31] <dbaupp> tiffany: it's printing it weirdly, or something, because I believe ~|| {} == ~(~fn())
[04:07:42] <dbaupp> sfackler: aha, ok
[04:07:58] <dbaupp> tiffany: (or some other internal closure type, I don't know how the inference works)
[04:08:08] <dbaupp> rusti: spawn(~|| {})
[04:08:08] -rusti- <anon>:5:15: 5:21 error: mismatched types: expected `~fn:Send()` but found `~&fn<no-bounds>()` (expected fn but found ~-ptr)
[04:08:08] -rusti- <anon>:5          spawn(~|| {})
[04:08:09] -rusti-                         ^~~~~~
[04:08:09] -rusti- error: aborting due to previous error
[04:08:09] -rusti- application terminated with error code 101
[04:08:11] <adu> http://www.lysator.liu.se/c/dmr-on-noalias.html#noalias
[04:08:15] <dbaupp> rusti: spawn(|| {})
[04:08:16] -rusti- ()
[04:08:25] <strcat> adu: that's not what LLVM's noalias is
[04:08:35] <adu> oh ok n/m
[04:08:38] <strcat> ~T parameter or return value -> can be tagged as noalias
[04:08:41] <strcat> no work from users required
[04:08:45] <dbaupp> tiffany: hm, it appears that closures always require explicit types (either in a let, or being passed directly to a function)
[04:08:59] <strcat> adu: LLVM's noalias is C's restricts, but it also works on return values
[04:09:04] <strcat> C's restrict*
[04:09:12] <tiffany> how do you give it an explicit type as a function argument?
[04:09:28] <adu> restrict is a modernized version of noalias
[04:09:52] <dbaupp> tiffany: i.e. the function has `fn foo(f: ~fn())` and so that's the explicit type there
[04:10:00] *** Joins: jstevans (Instantbir@moz-735D8260.washdc.fios.verizon.net)
[04:10:05] <strcat> adu: LLVM's alias analysis passes have NoAlias/MayAlias/MustAlias/PartialAlias as responses
[04:10:15] <tiffany> ah
[04:10:18] <dbaupp> tiffany: (so it's not really an explicit type, sorry)
[04:10:19] <strcat> and then `noalias` is a simple version to tag parameters and return values without running a whole pass
[04:10:19] <tiffany> what about for an enum type?
[04:10:40] <strcat> adu: it's unrelated to what may have been thought up for C with that keyword
[04:11:01] *** Joins: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net)
[04:11:06] <dbaupp> tiffany: you mean `enum Foo { Variant(~fn())` and constructing it via `Variant(|| { ... })` ?
[04:11:11] <adu> strcat: ok
[04:11:18] <strcat> clang translates 'restrict' on parameters to 'noalias', sets the return value of __attribute__((malloc)) functions as noalias and also the implicit out pointer
[04:11:22] <tiffany> yeah
[04:11:42] <dbaupp> tiffany: that should be fine, variant constructors are actually just plain functions
[04:12:02] <dbaupp> rusti: enum Foo { Variant(~fn()) } (Variant, Variant(|| {}))
[04:12:02] -rusti- (fn(~fn:Send()) -> main::Foo, Variant(fn()))
[04:12:16] <dbaupp> strcat: <3 useful function printing
[04:12:32] <tiffany> oh right
[04:12:36] <tiffany> closures can't be cloned
[04:12:42] <tiffany> is that going to be changed anytime soon?
[04:12:46] <dbaupp> rusti: struct Foo { f: ~fn() } Foo { f: || {} }
[04:12:47] -rusti- main::Foo{f: fn()}
[04:13:04] <dbaupp> (the type inference works in structs too)
[04:13:32] <dbaupp> tiffany: maybe? but it sounds like just using `extern "Rust" fn` is fine for you at the moment :)
[04:13:42] <dbaupp> (has the advantage of being clonable etc)
[04:13:52] <tiffany> I'm using extern fn right now
[04:14:08] <dbaupp> yup
[04:15:27] *** Joins: jgilbert (jgilbert@E3D90E00.12EE5EA8.C0D9FBB9.IP)
[04:16:18] <strcat> acrichto: ofc, github is ordering the commits totally wrong
[04:16:19] <strcat> yay
[04:16:28] <strcat> anyway, just going to test a few samples before I'm ready...
[04:16:59] <acrichto> I still don't understand why github refuses to change the order
[04:17:06] <dbaupp> acrichto: was there a PR for the format_args stuff? do you want me have a look?
[04:17:13] <acrichto> dbaupp: sure!
[04:17:20] <acrichto> https://github.com/mozilla/rust/pull/9153
[04:19:05] <dbaupp> acrichto: drat! all the extra docs mean the diffstat is still positive :P
[04:19:13] <acrichto> :(
[04:19:23] <acrichto> that'd be awesome if you could get diff - dox
[04:20:19] <acrichto> actually github resolved that moved file pretty well
[04:20:38] <acrichto> local git diff just shows a massive removal and then an adidtion
[04:20:40] <strcat> alright
[04:20:46] <strcat> extern "C" function calls - fixed.
[04:20:53] <strcat>   call void %1(%struct.Foo* sret %__llret)
[04:20:53] *** Parts: kelvin (kelvin@moz-3D989EF4.hsd1.va.comcast.net) ()
[04:20:54] <engla> git diff requires some flags to be smart
[04:21:01] <acrichto> strcat: woohoo
[04:21:18] <strcat> writing directly to the out ptr still works
[04:21:30] *** Quits: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[04:21:57] <strcat> calling rust function pointers now works with sret set
[04:21:59] <strcat>   call void %2(%struct.Foo* sret %__llret2)
[04:22:01] <strcat> :)
[04:22:45] <dbaupp> can it bootstrap?
[04:22:51] <strcat> yes
[04:23:06] <strcat> as a bonus fix I'll add noalias to ~T function ptr call instructions
[04:23:10] <strcat> since I generalized it
[04:23:46] <dbaupp> ~T return values?
[04:23:50] <strcat> yes
[04:23:57] <strcat> they are already noalias on normal calls
[04:24:09] <dbaupp> yup
[04:24:10] <strcat> but call instructions need attributes set separately
[04:24:19] <strcat> for function ptr calls
[04:25:31] *** Joins: zeuxcg (zeuxcg@moz-80D1F912.hsd1.ca.comcast.net)
[04:26:25] <acrichto> haha fixing fileinput tests failed because of fileinput tests 
[04:26:26] <acrichto> :(
[04:27:20] <strcat> acrichto: https://github.com/mozilla/rust/pull/9109 r?
[04:27:45] <strcat> closes 5 bugs!
[04:27:46] <strcat> ;p
[04:28:22] *** Quits: tikue (tkuehn@E5ACE5E7.28336FB0.689607DE.IP) (Quit: tikue)
[04:28:27] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[04:29:03] <bjz> cmr: the second one
[04:29:41] <bjz> cmr: ie. at the generation stage
[04:30:25] <bjz> cmr: the struct one loads it into a big struct as opposed to a global
[04:30:27] *** Joins: wilma (Mibbit@7C71104E.56A70E04.FC355C3F.IP)
[04:30:51] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[04:30:51] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14c54658f to 14c7657b7: 02http://git.io/N3iJvQ
[04:30:51] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[04:30:51] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[04:30:51] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/962BAA
[04:30:51] <ghrust> 13rust/06auto 140c89183 15Brian Anderson: rustc: Fix cstack lint for default methods. Closes #8753
[04:30:51] <ghrust> 13rust/06auto 142bdf4af 15bors: auto merge of #8796 : brson/rust/cstack, r=pnkfelix
[04:30:52] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[04:31:06] <wilma> do rust functions do move returns?
[04:31:49] *** Quits: sk (sk@61A494B3.BA40E8A.AAC02D62.IP) (Quit: Leaving)
[04:32:00] *** Quits: maik (maik@moz-3F2CDB33.dip0.t-ipconnect.de) (Ping timeout)
[04:32:17] <strcat> wilma: rust doesn't have copy constructors
[04:32:36] <strcat> assignment, passing and returning are done via a shallow memcpy
[04:32:50] <bjz> wilma: rust moves by default
[04:32:54] <strcat> acrichto: ugh an unnecessary unsafe block
[04:33:07] <acrichto> strcat: don't re-push just yet
[04:33:17] <strcat> acrichto: k
[04:33:18] <bjz> wilma: you need to be explicit when cloning
[04:34:37] <wilma> makes sense thanks
[04:34:51] <strcat> acrichto: just going to fix that whitespace issue in a separate commit
[04:35:00] <acrichto> why not amend?
[04:35:10] <strcat> acrichto: because the function is formatted in a bad way as a whole
[04:35:20] <strcat> it doesn't need early `return`
[04:36:22] <acrichto> eh ok
[04:36:46] *** Quits: wilma (Mibbit@7C71104E.56A70E04.FC355C3F.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[04:37:08] * strcat doesn't *really* care, but seeing `return` makes me think "early return" after coding rust as much as I have ;p
[04:37:30] <dbaupp> strcat: only 5 bugs?! nmatsakis closed 7 with https://github.com/mozilla/rust/pull/9088 :P
[04:39:31] <acrichto> strcat: why is sret on 1 an noalias on 0 ?
[04:39:39] <acrichto> oh wait, nvmd
[04:41:15] <acrichto> wrappee
[04:41:28] <strcat> hm?
[04:41:36] <acrichto> just an amusing word
[04:41:50] <strcat> oh that weird foreign.rs stuff
[04:41:55] * strcat shudders
[04:42:55] <acrichto> strcat: in general, there seems like a lot of register_*_fn functions
[04:43:03] *** Quits: ww (Mibbit@moz-9D1D3E.public.wayport.net) (Quit: http://www.mibbit.com ajax IRC Client)
[04:43:07] <acrichto> would you mind giving them all small dox saying what they're used for?
[04:43:25] * strcat doesn't really know
[04:43:27] <strcat> they make a symbol
[04:43:27] <acrichto> for the JNI thing,  I was thinking that one fn was for rust fns and one was for extern fns
[04:43:32] <dbaupp> strcat: do we need `~~~ {.rust}` for code blocks to get syntax highlighting still?
[04:43:33] <acrichto> strcat: oh, then nvmd
[04:43:53] <strcat> acrichto: basically, I changed register_fn to be for rust 
[04:44:01] <strcat> I will mark register_fn_llvmty with a comment
[04:44:03] <strcat> like I did with the others
[04:44:35] <acrichto> strcat: yeah if you understand what any of them are for dox is always good :)
[04:44:44] <strcat> I know what they do but not why they exist really
[04:44:46] <strcat> or what that hack is
[04:45:02] <acrichto> yeah don't feel compelled to document what you don't know
[04:45:04] <strcat> like, I don't know why we need register_fn when we have a separate code path
[04:45:10] <strcat> but I know what both paths do now ;p
[04:45:22] * strcat shrugs
[04:46:07] <strcat> acrichto: is it okay if I force push now?
[04:46:10] *** Joins: mib_xsnkf1 (Mibbit@7C71104E.56A70E04.FC355C3F.IP)
[04:46:16] <acrichto> strcat: yeah feel free
[04:46:48] *** Joins: tikue (tkuehn@E5ACE5E7.28336FB0.689607DE.IP)
[04:46:54] <strcat> acrichto: and yeah I'll document the attribute stuff
[04:48:09] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[04:48:09] *** ChanServ sets mode: +ao dherman dherman
[04:48:52] <acrichto> dbaupp: do you know how to look at the markdown output?
[04:49:08] *** Joins: SingingBoyo (Brandon@DAC9C672.CE76D40F.4F048BDC.IP)
[04:49:16] <strcat> acrichto: pushed again
[04:49:31] <acrichto> strcat: I'll look at it again in a bit, brb for a sec
[04:50:11] <sfackler> r? https://github.com/mozilla/rust/pull/9156
[04:50:17] <dbaupp> acrichto: um, run rustdoc on std I guess?
[04:50:27] <dbaupp> acrichto: make docs might do it for you?
[04:50:54] <dbaupp> sfackler: nice https://github.com/mozilla/rust/pull/9156/files#L0R251
[04:51:20] <acrichto> self.inner.inner.inner.inner
[04:51:21] <acrichto> what
[04:51:29] *** Quits: SingingBoyo (Brandon@DAC9C672.CE76D40F.4F048BDC.IP) (Quit: Leaving)
[04:51:31] <sfackler> all inners, all the time
[04:51:41] *** Quits: aeqwa (aeqwa@moz-A162D8C8.dsl.tropolys.de) (Quit: Lost terminal)
[04:52:03] <sfackler> I can rename those fields to not all but the same thing if anyone feels strongly :P
[04:52:07] <sfackler> *be
[04:52:25] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[04:54:01] <dbaupp> sfackler: hm, actually, maybe calling the writer one writer and the reader one reader might make it nicer?
[04:54:26] <dbaupp> (i don't feel strongly either way)
[04:56:02] <mib_xsnkf1> if you reassign a variable to an owned box, the destructor is called on the previous box correct?
[04:56:12] <dbaupp> acrichto: (hope you're ok with me playing copy-editor :) )
[04:56:46] <dbaupp> mib_xsnkf1: you mean, `let mut x = ~1; x = ~2;` ? yes, ~1 gets destructed
[04:56:48] <tikue> does anyone have a link to the rustpkg docs?
[04:57:08] <mib_xsnkf1> db yup
[04:57:12] *** Joins: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP)
[04:57:44] <tikue> nvm found it
[04:57:55] <dbaupp> rusti: struct Foo(int); impl Drop for Foo { fn drop(&self) { println!("dropped {}", **self); } } let mut x = Foo(1); x = Foo(2); println("between")
[04:58:01] -rusti- pastebinned 10 lines of output: http://ix.io/81f
[04:58:05] *** Joins: kseo (kseo@338DE5BC.4166765B.485A6DF.IP)
[04:58:19] <tikue> actually i'm not sure if this is the right one. anyone have a current link to the rustpkg documentation?
[04:58:25] <dbaupp> rusti: struct Foo(int); impl Drop for Foo { fn drop(&self) { println!("dropped {}", **self); } } let mut x = Foo(1); x = Foo(2); println("between"); **x
[04:58:26] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[04:58:27] -rusti- pastebinned 5 lines of output: http://ix.io/81g
[04:58:35] <dbaupp> rusti: struct Foo(int); impl Drop for Foo { fn drop(&self) { println!("dropped {}", **self); } } let mut x = Foo(1); x = Foo(2); println("between"); *x
[04:58:37] -rusti- pastebinned 7 lines of output: http://ix.io/81h
[04:58:55] <dbaupp> mib_xsnkf1: the first and last ones demonstrate it
[04:59:13] <dbaupp> tikue: http://static.rust-lang.org/doc/rustpkg.html maybe?
[04:59:36] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[04:59:36] *** Quits: KindOne (KindOne@moz-B2A9793.dynamic.ip.windstream.net) (Ping timeout)
[04:59:50] *** Quits: adu (alt@moz-BF2B1AE4.washdc.fios.verizon.net) (Quit: adu)
[05:00:37] <tikue> dbaupp: ah ok ,that's what i've got too
[05:00:41] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[05:00:41] *** ChanServ sets mode: +ao brson brson
[05:01:39] <sfackler> dbaupp: it doesn't end up too much better:  self.reader.reader.writer.write(buf)
[05:01:57] <sfackler> and (!) self.writer.writer.read(buf)
[05:02:16] *** Joins: SingingBoyo (brandon@DAC9C672.CE76D40F.4F048BDC.IP)
[05:02:17] *** Quits: Earnestly (earnest@moz-BE290A2B.dyn.plus.net) (Ping timeout)
[05:02:20] <mib_xsnkf1> db why do you need the **?
[05:02:48] *** Joins: frau (frau@moz-C616DA0A.hsd1.ca.comcast.net)
[05:02:57] <dbaupp> sfackler: ah, leave it then.
[05:03:56] *** Joins: KindOne (KindOne@9800CDDF.7E8839F4.34F73994.IP)
[05:04:00] <dbaupp> mib_xsnkf1: because &self is of type &Foo (i.e. a reference to Foo), so the first * is to get a plain Foo; then, you can "derefence" a newtype struct (i.e. struct Foo(x) with one type there) to get the internal type, which results in an `int`.
[05:04:23] <dbaupp> mib_xsnkf1: (that is to say, fn drop(&self) means that `self` is of type &Foo.)
[05:05:05] *** Joins: ww (Mibbit@moz-DFAED48A.lightspeed.sntcca.sbcglobal.net)
[05:05:08] <mib_xsnkf1> newtype? does rust not have inheritance?
[05:05:39] <dbaupp> not like Java/C++
[05:06:11] <dbaupp> newtype is just what we call `struct Foo(x)`, since it acts as a cost-less wrapper around `x`, to allow you to give it different behaviours
[05:06:12] <tikue> what kind of inference are we talking?
[05:06:30] <dbaupp> tikue: s/fere/herita/
[05:06:34] <mib_xsnkf1> its weird that you can dereference a struct...wtf
[05:06:44] <tikue> dbaupp: oh thanks i was very confused
[05:06:49] <tikue> must be tired
[05:06:58] <tikue> mib_xsnkf1: only newtype structs, because they only have one field
[05:07:01] <tikue> so it's never ambiguous
[05:07:12] <sfackler> ww: https://github.com/mozilla/rust/pull/9156 should fix BufferedStream
[05:07:21] <dbaupp> mib_xsnkf1: it could be `struct Foo { x: int }` .. `println!("dropped {}", self.x)` if that's less weird :)
[05:07:38] <dbaupp> sfackler: re-r+ :)
[05:08:02] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[05:08:11] <ww> thx sfackler
[05:08:36] <tikue> mib_xsnkf1: rust also has default methods, which cover a lot of similar ground as inheritance
[05:08:51] <mib_xsnkf1> how can newtype struct be costless with dynamic dispatch
[05:09:00] <dbaupp> it's not dynamic dispatch
[05:09:01] <heftig> mib_xsnkf1: it's not dynamic
[05:09:42] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Ping timeout)
[05:09:46] <strcat> rust functions/methods use static dispatch and struct/enums are unboxed values
[05:10:04] <strcat> generic functions are static dispatch to methods defined by traits
[05:10:05] <heftig> boxed traits use vtables
[05:10:17] <strcat> yeah, you can *also* use a trait as an object
[05:10:21] <strcat> but usually they are used as a type bound
[05:10:57] <heftig> if you want to have a heterogeneous collection, you need boxed traits
[05:11:10] <strcat> or enums
[05:11:13] <heftig> or enums.
[05:11:21] <tikue> or x
[05:11:24] <strcat> depends on whether you know all the types in advance
[05:11:34] <tikue> it should always be x. everything needs to be x, that's key
[05:11:43] <strcat> and enums are more convenient in some ways and less convenient in others
[05:11:45] <mib_xsnkf1> strange to me
[05:11:51] <strcat> mib_xsnkf1: what does?
[05:11:55] <strcat> newtype structs?
[05:12:08] <mib_xsnkf1> the object model 
[05:12:31] *** Joins: sk (sk@273FD846.E993C7C3.78DD174B.IP)
[05:12:42] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[05:13:11] <strcat> structs are aggregates, enums are sum types, traits == type classes (inheritance, default methods) with the twist of also being usable for dynamic dispatch
[05:13:28] <heftig> like interfaces.
[05:14:04] <strcat> yep, as objects they are like java interfaces, and as type bounds they are like type classes
[05:14:27] <strcat> (you could probably remove "like" from that sentence ;p)
[05:14:53] <mib_xsnkf1> whoever made rust really likes type theory
[05:15:21] <bjz> strcat: well 'like' insofar as they can also be implemented in an ad-hoc way
[05:15:33] <bjz> strcat: not where the type is defined
[05:15:35] <dbaupp> mib_xsnkf1: psh, we're not even close to Haskell/dependent types :P
[05:16:09] <engla> mib_xsnkf1: each concept is pretty simple by itself. For example the traits
[05:16:27] <bjz> dbaupp: or GADTs :)
[05:16:35] <dbaupp> bjz: that's the Haskell :P
[05:17:03] <bjz> dbaupp: Haskell only has GADTs via an extension though
[05:17:14] <strcat> bjz: haskell only has most things via ghc extensions ;p
[05:17:16] <mib_xsnkf1> so you can declare a variable type as a trait type or struct etc?
[05:17:20] <bjz> heh
[05:17:23] <dbaupp> bjz: <3 GHC extensions
[05:17:47] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[05:17:51] <strcat> mib_xsnkf1: yes, although you'll rarely actually declare a type on a local or use a trait object
[05:19:57] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[05:20:51] <bjz> aatch: ping
[05:20:59] <aatch> bjz, pong
[05:21:26] <mib_xsnkf1> if rust accepts immutable unboxed params why does it bother doing a copy/move? why not automatically use pointers
[05:21:40] <bjz> aatch: do you know much the inmplementation of enums and statics?
[05:22:04] <aatch> bjz, a little. Depends on which part of the implementation you're talking about.
[05:22:20] <strcat> mib_xsnkf1: there's a big semantic/performance difference between a local you can mutate and an immutable reference
[05:22:27] <acrichto> strcat: if register_fn_llvmty is only used for foreign fns, then it doesn't need the create_entry_wrapper business, right?
[05:22:35] <acrichto> dbaupp: oh no, I definitely need a copy editor
[05:22:38] <strcat> acrichto: that's a foreign fn
[05:22:41] <acrichto> I'm so bad
[05:22:44] <strcat> it has a C API
[05:22:46] <strcat> er
[05:22:48] <strcat> ABI
[05:22:55] <acrichto> #[start] on a C fn?
[05:23:01] <acrichto> I guess that makes sense
[05:23:07] <bjz> rusti: enum A { A0, A1 } static AA: A = A0; match { AA => "hi", A1 => "yo" }
[05:23:08] -rusti- <anon>:5:57: 5:59 error: expected one of `; }` but found `=>`
[05:23:08] -rusti- <anon>:5          enum A { A0, A1 } static AA: A = A0; match { AA => "hi", A1 => "yo" }
[05:23:08] -rusti-                                                                   ^~
[05:23:08] -rusti- application terminated with error code 101
[05:23:17] <strcat> acrichto: I am pretty sure it wraps it for you... not entirely sure but I don't want to tackle something else atm ;p
[05:23:23] <bjz> rusti: enum A { A0, A1 } static AA: A = A0; let a = A0; match a { AA => "hi", A1 => "yo" }
[05:23:23] -rusti- <anon>:5:42: 5:44 error: Non-constant path in constant expr
[05:23:23] -rusti- <anon>:5          enum A { A0, A1 } static AA: A = A0; let a = A0; match a { AA => "hi", A1 => "yo" }
[05:23:24] -rusti-                                                    ^~
[05:23:24] -rusti- application terminated with error code 101
[05:23:40] <bjz> aatch: ^
[05:23:48] <acrichto> strcat: oh this would just be deleting relevant lines in register_fn_llvmty
[05:23:50] <mib_xsnkf1> strcat i thought params were immutable
[05:24:00] <strcat> mib_xsnkf1: they are immutable by default
[05:24:00] <bjz> rusti: enum A { A0 = 0, A1 = 1 } static AA: A = A0; let a = A0; match a { AA => "hi", A1 => "yo" }
[05:24:01] -rusti- error: internal compiler error: unexpected failure
[05:24:01] -rusti- note: the compiler hit an unexpected failure path. this is a bug
[05:24:01] -rusti- note: try running with RUST_LOG=rustc=1 to get further details and report the results to github.com/mozilla/rust/issues
[05:24:01] -rusti- application terminated with error code 101
[05:24:06] <bjz> aatch: ^
[05:24:27] <strcat> mib_xsnkf1: a type can be mutated if you store it in a mutable location
[05:24:36] <mib_xsnkf1> strcat so why not automatically make the immutable ones references
[05:24:46] <strcat> mib_xsnkf1: they are not inherently mutable/immutable
[05:24:47] <mib_xsnkf1> oh
[05:24:56] <strcat> mib_xsnkf1: you can move out of an immutable value
[05:25:05] <strcat> you can't move out of a reference, you don't own the source
[05:25:12] <aatch> bjz, ah. Seems like it's a bug in the const-expr detection.
[05:25:26] <strcat> mib_xsnkf1: lightweight references (as in just a pointer at runtime - no overhead) require compile-time restrictions
[05:25:32] <strcat> since rust provides memory safety
[05:25:43] <dbaupp> bjz: there's a bug about it
[05:26:10] * dbaupp had closed it incorrectly, fortunately someone caught it and reopened it :S
[05:26:20] <bjz> aatch: we need it for glfw
[05:26:42] <aatch> So enum variants aren't considered constant. The second one is probably because it knows it has a constant value, so it gets further/down a different path and hits something.
[05:26:50] <bjz> mm
[05:26:55] <mib_xsnkf1> so borrowed pointers aren't mutable
[05:27:14] <bjz> aatch: mainly we need the second one for glfw-rs
[05:27:15] <dbaupp> bjz: https://github.com/mozilla/rust/issues/5873 is one issue, but it doesn't appear to be an ICE
[05:27:17] <tikue> rusti: 1+_0__0_+7
[05:27:17] -rusti- <anon>:5:11: 5:17 error: unresolved name `_0__0_`.
[05:27:17] -rusti- <anon>:5          1+_0__0_+7
[05:27:17] -rusti-                     ^~~~~~
[05:27:18] -rusti- error: aborting due to previous error
[05:27:18] -rusti- application terminated with error code 101
[05:27:27] <strcat> acrichto: well, it means something else possibly failing a test ;p
[05:27:28] <tikue> rusti: 1+0__0+7
[05:27:29] -rusti- 8
[05:27:42] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[05:27:59] <acrichto> strcat: but that jni stuff probably isn't going away any time soon...
[05:28:10] <acrichto> and I highly doubt that there's #[start] or #[main] on extern fns righ tnow
[05:28:22] <strcat> acrichto: the entry point is always a C ABI though
[05:28:33] <strcat> acrichto: I plan on killing this stuff off in a separate PR soon
[05:28:38] <acrichto> oh if you do extern "C" fn it calls the llvmty one?
[05:28:41] <strcat> to end the dual main fns we end up with
[05:28:51] <strcat> acrichto: yes
[05:28:56] <strcat> acrichto: well
[05:29:16] <strcat> acrichto: actually if you do 'extern "C" fn', it makes a rust function and then wraps it with a C ABI one
[05:29:22] <strcat> so the one it will register is the C ABI one
[05:29:23] <acrichto> strcat: eh, if you're going to continue work in this area, I'm fine with this
[05:29:25] <strcat> assuming it's public
[05:29:36] <acrichto> ah yes
[05:29:46] <acrichto> wait no
[05:29:47] <strcat> acrichto: but I think the entry point code is hardcoded
[05:29:56] <acrichto> oh are you talking only about main?
[05:30:01] <acrichto> not c functions in general?
[05:30:11] <strcat> well, I'm talking about rust fns with a "C" ABI
[05:30:13] <strcat> as in
[05:30:18] <acrichto> those don't generate wrappers, right?
[05:30:19] <strcat> extern "C" fn foo() { ... }
[05:30:25] <strcat> acrichto: they do get a wrapper
[05:30:32] <strcat> it probably gets inlined
[05:30:39] <strcat> I was looking at this stuff with optimization off
[05:30:41] <acrichto> wasn't that niko's giant pull request?
[05:30:45] <acrichto> to stop creating wrappers?
[05:30:46] *** Quits: jstevans (Instantbir@moz-735D8260.washdc.fios.verizon.net) (Ping timeout)
[05:30:56] <strcat> acrichto: no, he removed wrappers being made around extern { ... } functions by default
[05:30:59] <strcat> as in, real C functionms
[05:31:10] <strcat> extern "C" fn foo() { } is a rust function masquerading as C
[05:31:20] <frau> how do you tell rustpkg to install in ~/.rust?
[05:31:47] *** Joins: clements (clements@moz-BEE8D50A.dsl.snlo01.pacbell.net)
[05:32:08] <acrichto> strcat: oh how does that work?
[05:32:22] <acrichto> strcat: there's a C fn exposed (which is the value of the function), and a rust fn under the hood?
[05:32:27] <acrichto> possibly dealing with stack switching?
[05:32:42] <strcat> acrichto: I think eventually it will run on the C stack
[05:32:48] <strcat> I don't know
[05:33:01] <strcat> ask brson or nmatsakis about that stuff ;p
[05:33:02] <dbaupp> frau: it's possibly not implemented yet
[05:33:09] <strcat> I just know about the low-level LLVM bits now
[05:33:14] <acrichto> huh ok
[05:33:15] <strcat> not the high-level parts like the runtime
[05:33:45] <acrichto> well the stack situation is a bit undefined right now I thought seeing how the runtime doesn't do segmented stacks
[05:33:52] <frau> dbaupp: how do people normally compose multiple packages then? I've noticed git submodules... does everyone set up RUST_PATHs to everything or something?
[05:33:56] <dbaupp> frau: it might be in here (https://github.com/mozilla/rust/wiki/Rustpkg-schedule) somewhere, bug I can't see it
[05:34:07] <acrichto> we need node for docs? weird..
[05:34:22] <dbaupp> frau: I don't quite understand the question, but rustpkg is still very incomplete
[05:34:36] <dbaupp> oh, cool, "#6403 - building c libs - 9/30/2013 (medium)" only 2 weeks!
[05:35:09] *** Quits: KindOne (KindOne@9800CDDF.7E8839F4.34F73994.IP) (Ping timeout)
[05:35:48] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[05:35:48] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/962BAA
[05:35:48] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[05:35:51] <dbaupp> frau: that said, I *think* rustpkg handles something like `extern mod foo;` in bar (if you have src/{bar, foo}/*.rs as you dir structure, i.e. 2 crates)
[05:36:23] <dbaupp> frau: and it is designed (and does) handle `extern mod foo = "http://github.com/frau/your_repo"` to fetch external dependencies
[05:36:43] * dbaupp hasn't used either of these features yet, so take his word with large grains of salt
[05:37:16] <acrichto> I'm excited for rustpkg to be all working
[05:37:25] <acrichto> then we can start having libraries pop up all over the place
[05:37:34] <acrichto> and then fall out of date as the language changes :(
[05:37:42] <heftig> mib_xsnkf1: they can be made mutable
[05:37:53] <heftig> er, declared, that is
[05:38:12] <dbaupp> acrichto++
[05:38:34] <frau> dbaupp: ah I see, thank you
[05:38:58] *** Joins: KindOne (KindOne@F8BBCE07.DFA916E1.34F73994.IP)
[05:39:00] <acrichto> make doc why you always fail for me
[05:40:01] <acrichto> do you need llnextgen to generate docs?
[05:40:09] <strcat> no
[05:40:19] <strcat> you need pandoc for rustdoc
[05:40:20] <acrichto> make doc refuses to actually do anything
[05:40:26] <strcat> to generate the tutorials, you need node.js
[05:40:27] <acrichto> just installed pandoc/node
[05:40:37] <mib_xsnkf1> are borrowed pointers costless?
[05:40:47] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[05:40:47] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/AvZ9tA
[05:40:47] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[05:40:50] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[05:40:50] <ghrust> 01[13rust01] 15bors pushed 10 new commits to 06auto: 02http://git.io/1KChqA
[05:40:50] <ghrust> 13rust/06auto 148ecd53d 15Daniel Micay: fix handling of function attributes...
[05:40:50] <ghrust> 13rust/06auto 14be69791 15Daniel Micay: set sret attribute as needed on call instructions...
[05:40:51] <ghrust> 13rust/06auto 14b0c8220 15Daniel Micay: add sret + noalias to the out pointer parameter...
[05:40:53] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[05:40:55] <strcat> mib_xsnkf1: at runtime they are no different than raw C pointers
[05:41:01] <dbaupp> mib_xsnkf1: costless compared to what? they're pointers, so they have the same runtime cos s as * in C
[05:41:03] <dbaupp> *cost
[05:41:39] <strcat> acrichto: lets hope I actually fixed the x86 issue and not just a bunch of other ones ;p
[05:41:55] <mib_xsnkf1> ok so they are not comparable to c++ by reference?
[05:42:10] <strcat> mib_xsnkf1: they are comparable to a C++ reference, but they are real first-class objects
[05:42:14] <strcat> you can store them in a container, etc.
[05:43:00] <mib_xsnkf1> doesn't c++ by reference elide the runtime pointer?
[05:43:05] <heftig> no
[05:43:24] <strcat> C++ references are restricted C pointers
[05:44:05] <dbaupp> do C++ compilers have the freedom to pass (e.g.) `const int&` by value?
[05:44:08] <strcat> they aren't a first-class value like pointers, but otherwise they are identical
[05:44:21] <strcat> dbaupp: only in internal functions
[05:44:35] <strcat> const int * and const int &
[05:44:39] <strcat> same codegen
[05:44:46] *** Joins: jstevans (Instantbir@moz-735D8260.washdc.fios.verizon.net)
[05:44:52] <mib_xsnkf1> oh i thought all references were replaced elided at runtime
[05:45:11] <mib_xsnkf1> sorry i mean replaced at compile time
[05:45:28] <strcat> LLVM has an argpromotion pass to change passing by-reference to by-value when only the value is used
[05:45:33] <strcat> but it only applies to internal functions
[05:45:34] <heftig> if it's inlined or templated, i guess, the compiler may do that in the optimization
[05:45:38] <strcat> and it's only run with clang -O3, not -O2
[05:45:51] <strcat> rust runs the same passes as clang
[05:46:15] <heftig> strcat: internal = static?
[05:46:17] <strcat> yes
[05:46:25] <strcat> or non-pub, in rust
[05:46:36] <heftig> that's what i meant, stuff that can't be called from outside the compilation unit
[05:46:46] <strcat> heftig: yeah
[05:47:06] *** Quits: voxpopuli (fanservice@moz-FE161659.wv.cc.cmu.edu) (Ping timeout)
[05:47:12] <strcat> if it's inlined, it's pretty much guaranteed that by-ref vs by-value will become the same code
[05:47:27] <strcat> or at least close
[05:47:43] *** Joins: bheylin_ (brianheyli@moz-8255E94E.adsl.online.nl)
[05:49:13] <frau> what's the convention to represent opaque C struct pointers? type c_struct = c_void;?
[05:49:30] <eevee> yeah
[05:49:53] <strcat> frau: or 'enum Opaque {}'
[05:50:05] <frau> ooh.
[05:50:19] <engla> a new, separate type is better yes, "type" is just a name alias
[05:50:21] <strcat> that's what c_void is defined as, but if you use an alias if c_void it won't catch basic mistakes
[05:50:39] <strcat> alias of*
[05:50:42] <heftig> newtype struct around c_void?
[05:51:35] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[05:51:39] <jeaye> Can I get a foo& from a ~[foo]
[05:51:46] <jeaye> ?^
[05:52:11] <dbaupp> jeaye: in rust syntax, please? :P
[05:52:24] <dbaupp> do you want a & to the first element?
[05:52:28] <jeaye> dbaupp: It's so hard! I wrote vec<foo> first. -_-
[05:52:33] <dbaupp> jeaye: heh :)
[05:52:43] <jeaye> No, not the first element.
[05:52:50] <jeaye> I think my syntax is proper.
[05:52:56] <strcat> you can take references into vectors
[05:53:05] <heftig> rusti: let x = ~[1,2,3,4u]; let y = &x[3]; fmt!("%?", y)
[05:53:06] <dbaupp> jeaye: `&foo`?
[05:53:06] -rusti- ~"&4u"
[05:53:17] <jeaye> I have a ~[foo] and I want to get a &foo out of it
[05:53:18] <dbaupp> jeaye: (i.e. that's the type)
[05:53:21] <strcat> and iter() yields references
[05:53:37] <jeaye> dbaupp: foo&, &foo, :P
[05:54:07] <dbaupp> jeaye: the `i`th element? `&vec[i]` as heftig demonstrates.
[05:54:16] *** Quits: bheylin_ (brianheyli@moz-8255E94E.adsl.online.nl) (Quit: bheylin_)
[05:54:30] <jeaye> Didn't know if that'd reference the rvalue instead of the element in the vec
[05:54:55] <heftig> so you think it'll copy out the rvalue and then reference that?
[05:54:58] *** Joins: victorporof (victorporo@FBDAE982.F9BD9D78.9B1E38F4.IP)
[05:55:01] <heftig> er
[05:55:06] <heftig> copy out the element from the vec
[05:55:08] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[05:55:14] <dbaupp> no, there's some magic
[05:55:27] <dbaupp> it's the vec internal pointer
[05:55:31] <jeaye> I wanted to make sure it didn't. Because... you know, the syntax kind of looks like it.
[05:55:50] <jeaye> dbaupp: Magic is a fair enough answer. :)
[05:56:16] <acrichto> strcat: same segfault :(
[05:56:22] <strcat> acrichto: noooooooooooooooooooooooooooooo
[05:56:26] <dbaupp> rusti: use std::cast::transmute; let x = ~[1,2,3,4]; (transmute::<&int, uint>(&x[0]), transmute::<~[int], uint>(x))
[05:56:33] -rusti- pastebinned 8 lines of output: http://ix.io/81i
[05:56:40] <strcat> acrichto: I really don't understand why, then
[05:56:41] <jeaye> rusti: let mut v = ~[1, 2, 3]; let two = &mut v[1]; two = 4; v
[05:56:42] -rusti- <anon>:5:60: 5:61 error: mismatched types: expected `&mut <VI2>` but found `<VI4>` (expected &-ptr but found integral variable)
[05:56:42] -rusti- <anon>:5          let mut v = ~[1, 2, 3]; let two = &mut v[1]; two = 4; v
[05:56:42] -rusti-                                                                      ^
[05:56:42] -rusti- error: aborting due to previous error
[05:56:42] -rusti- application terminated with error code 101
[05:56:47] <dbaupp> rusti: use std::cast::transmute; let x = ~[1,2,3,4];  unsafe { (transmute::<&int, uint>(&x[0]), transmute::<~[int], uint>(x)) }
[05:56:47] -rusti- (140271501308080u, 140271501308064u)
[05:56:52] <jeaye> rusti: let mut v = ~[1, 2, 3]; let two = &mut v[1]; *two = 4; v
[05:56:54] -rusti- pastebinned 8 lines of output: http://ix.io/81j
[05:57:02] <glyc> Q: who is working on rusti at the moment. I'd like to see what I can do to help there.
[05:57:14] <acrichto> glyc: rusti-the-bot or rusti-the-repl?
[05:57:16] <dbaupp> glyc: MrOrdinaire
[05:57:16] <strcat> acrichto: annoying that all these fixes for unrelated stuff depend on this stupid x86 error being fixed ;p
[05:57:22] <glyc> rusti the repl
[05:57:32] <acrichto> glyc: then dbaupp is correct
[05:57:35] <glyc> acrichto: is rusti-the-bot different?
[05:57:38] <heftig> rusti: let mut v = ~[1, 2, 3]; { let two = &mut v[1]; *two = 4 }; v
[05:57:39] -rusti- ~[1, 4, 3]
[05:57:42] <acrichto> glyc: yeah strcat maintains that
[05:57:52] <acrichto> strcat: :(
[05:58:00] *** Quits: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net) (Input/output error)
[05:58:01] <glyc> acrichto: same code?
[05:58:04] <dbaupp> glyc: yeah, writes the input into `fn main { ... }` and runs it through normal rustc
[05:58:05] <jeaye> rusti: let mut v = ~[1, 2, 3]; { let two = &mut v[1]; *two = 4; } v // dbaupp -- perfect
[05:58:05] -rusti- ~[1, 4, 3]
[05:58:12] <jeaye> Thanks
[05:58:12] <dbaupp> glyc: (rusti the bot)
[05:58:20] <glyc> dbaupp: ok
[05:58:25] <dbaupp> jeaye: yup; magic \o/
[05:58:35] <glyc> dbaupp: so the two are very different, yes?
[05:58:39] <dbaupp> glyc: yes
[05:58:50] <glyc> dbaupp: got it. thanks
[05:59:00] <glyc> who wrote rusti-the-repl originally?
[05:59:08] <strcat> acrichto: well this is annoying...
[05:59:17] <dbaupp> glyc: rusti is entirely stateless and is basically jsut `fn main() { let r = { <input> }; printfln!(r); }`
[05:59:28] * strcat sighs
[05:59:28] <dbaupp> glyc: the current version is acrichto's baby
[05:59:33] <glyc> Idbaupp: rusti-the repl?
[05:59:55] <glyc> dbaupp: cool. I'll write acrichto a quick email
[06:00:21] <glyc> dbaupp: I got in touch with MrOrdinaire
[06:00:22] <acrichto> emails! emails! emails!
[06:00:36] <glyc> acrichto: :-)
[06:00:38] <acrichto> dbaupp: you're right, the bulleted list looks awful
[06:00:40] <tikue> glyc: rusti needs lots and lots of help
[06:00:41] <strcat> acrichto: I might split out the extern "C" fix
[06:00:53] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[06:00:53] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 148dff19f to 142bdf4af: 02http://git.io/N3iJvQ
[06:00:53] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[06:00:55] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[06:00:55] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/HndFIw
[06:00:55] <ghrust> 13rust/06auto 14b0e13e0 15Florian Hahn: Add HashSet::with_capacity_and_keys() function...
[06:00:55] <ghrust> 13rust/06auto 142b5f4b5 15Florian Hahn: Convert rust_crate_map.cpp to Rust...
[06:00:56] <ghrust> 13rust/06auto 14323e8f0 15bors: auto merge of #9087 : fhahn/rust/rust_crate_map, r=brson...
[06:00:57] <glyc> tikue: ok
[06:00:58] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[06:01:17] <acrichto> strcat: r=me if it's just splitting things out
[06:01:29] *** Quits: ChrisMorgan (chris@moz-2DEFC48E.its.monash.edu.au) (Ping timeout)
[06:01:38] <acrichto> also argh `make doc/std/index.html` will rebuild everything if you modify the crate.... 
[06:01:40] * acrichto modifies the makefile
[06:02:08] <SingingBoyo> who would've thought I'd ever write a mini-essay in a comment on a PR
[06:02:19] <dbaupp> SingingBoyo: I did
[06:02:27] * SingingBoyo thinks his json changes need more tests to clarify what works/doesn't work
[06:02:31] * dbaupp is possibly lying
[06:02:55] * SingingBoyo is not sure but thinks dbaupp may be semi-crazy
[06:03:06] <strcat> acrichto: yeah. split that out
[06:03:29] * strcat doesn't know what pull --rebase will do
[06:03:33] <strcat> after it lands
[06:03:44] <acrichto> markdown makes \ => \\ in html :(((
[06:03:45] *** Quits: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net) (Ping timeout)
[06:04:17] *** Joins: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net)
[06:04:23] <dbaupp> SingingBoyo: "semi"? you are too polite!
[06:04:39] <strcat> acrichto: not supposed to
[06:04:45] <strcat> \ escapes the next character
[06:04:50] <strcat> \\ becomes \
[06:05:17] <SingingBoyo> dbaupp: my definition of crazy is warped after writing the mini-essay
[06:05:26] <acrichto> strcat: http://www.contrib.andrew.cmu.edu/~acrichto/std/fmt.html#print
[06:05:36] <mib_xsnkf1> vec[i] is an lvalue anyway, right?
[06:05:38] <acrichto> that was with \\ in the source, \ in the source became \\
[06:05:57] <strcat> acrichto: keep in mind that we run it through this terrible node.js preprocessing step
[06:05:59] *** Quits: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca) (Quit: Leaving)
[06:06:02] <strcat> and the old rustdoc is bad too :s
[06:06:13] <acrichto> I'll just not have it in there for now
[06:06:26] <strcat> strcat@thinktank i ~ master % cat foo
[06:06:28] <strcat> foo \\
[06:06:28] <acrichto> strcat: http://www.contrib.andrew.cmu.edu/~acrichto/std/fmt.html#escaping is just downright wrong
[06:06:30] <strcat> strcat@thinktank i ~ master % pandoc foo
[06:06:32] <strcat> <p>foo \</p>
[06:06:32] <SingingBoyo> dbaupp: I'm not even sure it makes sense
[06:07:05] <acrichto> cmr: ping
[06:07:20] *** Quits: zeuxcg (zeuxcg@moz-80D1F912.hsd1.ca.comcast.net) (Ping timeout)
[06:07:27] <acrichto> dbaupp: http://www.contrib.andrew.cmu.edu/~acrichto/std/fmt.html#related-macros looks much better than the bulleted list
[06:07:36] <strcat> mib_xsnkf1: well, vec[i] will only work if the vector has implicitly copyable types in it
[06:07:48] <dbaupp> acrichto: that's with ####, right?
[06:07:49] <strcat> as in
[06:07:51] <strcat> let a = vec[i];
[06:07:55] *** Quits: carter (carter@moz-F3C2A2D8.nycmny.fios.verizon.net) (Quit: Textual IRC Client: www.textualapp.com)
[06:07:57] <acrichto> dbaupp: yeah, and with {.rust}
[06:07:58] <strcat> vec[i] = foo; will work with anything
[06:08:07] <dbaupp> acrichto: awesome! looks good
[06:08:18] <strcat> it's actually annoying that they're treated as lvalues because strings shouldn't allow index-assign :(
[06:09:05] <engla> is it possible to remove the indexing of str from the compiler and reimplement it with Index?
[06:09:22] <dbaupp> strcat: we can implement vec indexing entirely in libs, can't we? so once we have working Index* we can strip that stuff from the compiler?
[06:09:26] <mib_xsnkf1> so rust won't automatically move from a vector?
[06:09:29] <strcat> dbaupp: sure
[06:09:32] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[06:09:40] <strcat> mib_xsnkf1: no, because then you couldn't use the vector anymore
[06:09:45] <dbaupp> strcat: I guess that's the easiest solution?
[06:09:57] <strcat> it could be implemented
[06:10:03] <strcat> but it wouldn't be very useful
[06:10:09] <strcat> dbaupp: maybe
[06:10:13] <acrichto> rusti: format!()
[06:10:13] -rusti- <anon>:5:9: 6:5 error: requires at least a format string argument
[06:10:13] -rusti- <anon>:5          format!()
[06:10:13] -rusti- <anon>:6     };
[06:10:14] -rusti- error: aborting due to previous error
[06:10:14] -rusti- application terminated with error code 101
[06:10:25] <dbaupp> rusti: format_args!()
[06:10:26] -rusti- <anon>:5:9: 5:20 error: macro undefined: 'format_args'
[06:10:27] -rusti- <anon>:5          format_args!()
[06:10:27] -rusti-                   ^~~~~~~~~~~
[06:10:27] -rusti- application terminated with error code 101
[06:10:29] <acrichto> rusti: format!("a" b)
[06:10:30] -rusti- <anon>:5:9: 6:5 error: expected token: `,`
[06:10:30] -rusti- <anon>:5          format!("a" b)
[06:10:30] -rusti- <anon>:6     };
[06:10:30] -rusti- error: aborting due to previous error
[06:10:30] <mib_xsnkf1> library is how Scala does it
[06:10:32] -rusti- application terminated with error code 101
[06:10:34] *** Quits: MrOrdinaire (Mibbit@1143DEE0.A607747.FD383126.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[06:10:37] *** Quits: valenting (Thunderbir@7658A01E.84D5EFD5.FB866788.IP) (Ping timeout)
[06:10:39] <strcat> dbaupp: but consider constexprs
[06:10:41] <acrichto> dbaupp: oh you're right, those are actually good error messages
[06:10:46] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[06:11:08] <dbaupp> strcat: ah! :(
[06:11:24] <mib_xsnkf1> so the vector owns its contents?
[06:11:31] <strcat> mib_xsnkf1: yes
[06:11:44] <strcat> you can store &T in a vector, if you want
[06:11:56] *** Quits: Larry (larryfox@moz-8D6C9B2A.nycmny.fios.verizon.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[06:13:56] *** Quits: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net) (Ping timeout)
[06:14:00] <dbaupp> SingingBoyo: on the topic of comment-essays: https://github.com/mozilla/rust/issues/6393#issuecomment-24307095 :P
[06:14:26] <mib_xsnkf1> so you can't move from something unless it is the root of is ownership tree?
[06:14:43] <strcat> mib_xsnkf1: no
[06:14:48] <strcat> you can move from inside an ownership tree
[06:14:57] <strcat> but now that ownership tree is moved from, and can no longer be used
[06:15:23] <acrichto> x86_64-apple-darwin is in the .gitignore, but not i686-apple-darwin...
[06:15:26] <strcat> it's just not implemented for vectors
[06:15:37] <mib_xsnkf1> so the compiler doesn't do it implicitly in that case?
[06:15:52] <strcat> mib_xsnkf1: yeah, vectors just don't implement moving from them
[06:15:53] <SingingBoyo> dbaupp: well, that's got my comment here (https://github.com/mozilla/rust/pull/9142#issuecomment-24374869) beaten by a long shot.
[06:16:04] *** Quits: Infiltrator (Infiltrato@4669028E.25A9890C.4B4F1E7A.IP) (Quit: leaving)
[06:16:07] *** Joins: fabiand (fabiand@moz-B584E7F8.adsl.alicedsl.de)
[06:16:37] <strcat> mib_xsnkf1: it's common to move from a struct field (making it unusable) or destructure it into pieces (moving more than one field out)
[06:17:07] <dbaupp> SingingBoyo: I'm expecting better from you next time!
[06:17:22] <SingingBoyo> dbaupp: then again, I just had one PR to talk about, he had lexical scoping combined with borrowed pointers
[06:17:31] <dbaupp> SingingBoyo: details! :P
[06:17:35] <SingingBoyo> dbaupp: yes master :(
[06:17:36] *** Quits: jgilbert (jgilbert@E3D90E00.12EE5EA8.C0D9FBB9.IP) (Ping timeout)
[06:17:54] * SingingBoyo  is not sure he ever wants to do that again though
[06:19:35] <mib_xsnkf1> is .clone on an owned box x the same thing as ~*x
[06:19:36] *** Joins: jaen (jaen@moz-B736C889.neoplus.adsl.tpnet.pl)
[06:20:10] *** Joins: ross (ross@moz-5EA04060.br.br.cox.net)
[06:20:16] <strcat> mib_xsnkf1: no, it clones x
[06:20:23] <strcat> x might not be implicitly copyable
[06:20:33] <glyc> acrichto: sent you email, just like to get the lay of the land w.r.t. rusti
[06:20:58] <strcat> language value semantics -> a shallow copy (moves ownership if it has a dtor), Clone -> as shallow as possible from a reference
[06:21:03] <acrichto> dbaupp: r? https://github.com/mozilla/rust/pull/9160
[06:21:09] <acrichto> glyc: cool, will respond
[06:21:27] <strcat> so Clone is the same action as an implicit copy, but also works for non-implicitly-copyable types
[06:21:42] <dbaupp> mib_xsnkf1: it's the same as `~((*x).clone())` though
[06:22:31] <strcat> acrichto: I'm at a total loss as to what is left to fix...
[06:23:22] <acrichto> strcat: yeah... I dunno
[06:23:44] <acrichto> strcat: I'll try rebuilding soon and seeing where it dies again
[06:23:46] <acrichto> hopefully not the same spot
[06:24:26] <strcat> I bet it does die in the same spot
[06:24:35] <SingingBoyo> acrichto: that commit in the PR you linked happened 'In 3 minutes'.  Stop time-travelling!
[06:24:42] <acrichto> dbaupp: so about the bad spans, I think you're right in that the correct issue for this is 5794, I fixed a few things (using * instead of + in the macros), so every possible error is generated from the ext/format code. Right now it just appears that the parser over the token tree given is just terrible at emitting spans
[06:24:44] <strcat> I found these issues via playing with clang rather than any luck debugging that ;[
[06:24:50] <acrichto> SingingBoyo: what lol
[06:25:03] <acrichto> whoa that's awesome
[06:25:06] <mib_xsnkf1> oh so ~*x could be a move strcat?
[06:25:14] <dbaupp> SingingBoyo: my r+ appears before the commit for me
[06:25:17] <strcat> mib_xsnkf1: yes
[06:25:18] <acrichto> oh jeez that server is 4 minutes ahead
[06:25:47] <dbaupp> acrichto: ah, ok; but does it give the location that `format!`/`write!`/etc was called for an error?
[06:26:03] <strcat> mib_xsnkf1: although there's a bug where you have to do 'let ~x = y' to move from ~T instead of *x being able to move (not sure if it's fixed yet)
[06:26:04] <acrichto> dbaupp: yeah, which are now all <std-macros>:264:8: 264:50 error: requires at least a format string argument
[06:26:16] <acrichto> dbaupp: which is terrible
[06:26:22] <strcat> rusti: let a = ~5; let ~b = a; b
[06:26:22] -rusti- 5
[06:26:28] <strcat> rusti: let a = ~5; let b = *a; b
[06:26:28] <dbaupp> rusti: let x = ~~1; let y = *x; (y, x)
[06:26:33] -rusti- 5
[06:26:33] -rusti- pastebinned 8 lines of output: http://ix.io/81k
[06:26:34] <acrichto> dbaupp: but it's honestly legitimately 5794 all the way
[06:26:38] <SingingBoyo> acrichto, dbaupp: so much for general relativity and all modern knowledgy about time.
[06:26:43] <dbaupp> acrichto: yeah
[06:26:47] <strcat> meh silly me
[06:26:50] * acrichto googles osx ntp command line
[06:26:57] <strcat> didn't use a non-implicitly-copyable type ;p
[06:27:52] <dbaupp> acrichto: I'm undecided about whether it's worth releasing code that will be impossible to debug, even if it's "just" a problem due to another bug
[06:27:55] <acrichto> weird, it's using a ntp server, but it just wasn't synced..
[06:28:14] <dbaupp> acrichto: especially since format!/... will be getting a lot of use
[06:28:31] <acrichto> dbaupp: hmm... it's a good point, this really is a nice way of defining these macros though
[06:28:31] <mib_xsnkf1> if i just write the pointless expression *x within a block, it could move?
[06:28:42] <dbaupp> acrichto: (debug == "work out what the compiler is complaining about")
[06:28:44] <dbaupp> acrichto: yeah
[06:28:51] *** Quits: noam (noam@F6B530A7.720527A7.416762B.IP) (Ping timeout)
[06:29:03] <strcat> mib_xsnkf1: no
[06:29:10] <strcat> mib_xsnkf1: only if you assigned/passed/returned from it
[06:29:21] <dbaupp> acrichto: I think doing the "expansion" in ext::format won't be too bad, i.e. 10 or 20 lines with a macro
[06:29:24] <acrichto> dbaupp: ok I'm going to re-push to get the updates, but I'll ping some folks on irc tomorrow to see if anyone knows a halfway good fix for that
[06:29:31] <strcat> and only after that's implemented for ~T ;p, for now you have to pattern match out with 'let ~x = y'
[06:29:32] <mib_xsnkf1> k
[06:30:03] <dbaupp> rusti: let x = ~~1; { *x; } x
[06:30:05] -rusti- pastebinned 8 lines of output: http://ix.io/81l
[06:30:06] *** Quits: jeaye (Jeaye@moz-34FEF2BB.hsd1.ca.comcast.net) (Quit: zzz)
[06:31:08] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[06:33:34] *** Quits: clements (clements@moz-BEE8D50A.dsl.snlo01.pacbell.net) (Ping timeout)
[06:33:56] *** Joins: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net)
[06:39:45] *** flaper87|afk is now known as flaper87
[06:40:38] *** Joins: pyrac (pyrac@moz-C411EA77.math.u-bordeaux1.fr)
[06:41:16] <strcat> dbaupp: oh it does work now
[06:41:25] *** Quits: Amaranth (travis@moz-F81BB56A.cpe.cableone.net) (Ping timeout)
[06:41:26] * strcat wonders when that happened
[06:41:36] <strcat> rusti: let x = ~~1; { *x; }
[06:41:37] -rusti- ()
[06:41:43] <strcat> rusti: let x = ~~1; *x
[06:41:44] -rusti- ~1
[06:41:52] <strcat> still buggy though
[06:42:05] <dbaupp> rusti: let mut x = ~1; x = x;
[06:42:05] -rusti- <anon>:5:25: 5:26 warning: value assigned to `x` is never read [-W dead-assignment (default)]
[06:42:05] -rusti- <anon>:5          let mut x = ~1; x = x;
[06:42:06] -rusti-                                   ^
[06:42:06] -rusti- ()
[06:42:09] <dbaupp> rusti: let mut x = ~1; x = x; x
[06:42:10] -rusti- application terminated abnormally with signal 11 (Segmentation fault)
[06:42:15] <strcat> rusti: struct Foo { x: ~int } let a = Foo { x: ~5 }; { a.x }; a
[06:42:15] *** Joins: squiddy (squiddy@moz-D37EFEA9.adsl.alicedsl.de)
[06:42:25] -rusti- pastebinned 8 lines of output: http://ix.io/81m
[06:42:34] * strcat thinks that's a bug
[06:42:41] <strcat> rusti: struct Foo { x: ~int } let a = Foo { x: ~5 }; { &a.x }; a
[06:42:41] -rusti- main::Foo{x: ~5}
[06:42:48] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[06:44:34] *** Joins: eholk (eholk@moz-F70D5031.hsd1.in.comcast.net)
[06:44:35] *** Joins: Amaranth (travis@moz-F81BB56A.cpe.cableone.net)
[06:47:40] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[06:49:10] *** Joins: sammykim (Mibbit@B4104EBB.3CC170B1.1E14B209.IP)
[06:49:35] *** Quits: eholk (eholk@moz-F70D5031.hsd1.in.comcast.net) (Quit: eholk)
[06:50:12] *** Joins: tgummerer (tgummerer@51D3B54.FEF996EA.EA6FEF3D.IP)
[06:52:07] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Client exited)
[06:52:31] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[06:53:05] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Quit: leaving)
[06:54:12] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[06:56:48] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[07:00:54] *** Quits: mib_xsnkf1 (Mibbit@7C71104E.56A70E04.FC355C3F.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[07:01:46] *** Joins: rumpler (Mibbit@7C71104E.56A70E04.FC355C3F.IP)
[07:02:30] <rumpler> is &*x the same as &x when x is ~3 ?
[07:02:47] <dbaupp> no
[07:02:54] <acrichto> rusti: let a = ~3; let b = 3; (&*a, &b)
[07:02:59] <dbaupp> &x has type &~int, &*x has type &int
[07:03:03] -rusti- pastebinned 30 lines of output: http://ix.io/81n
[07:03:25] <dbaupp> rusti: let a = ~3; let b = 3; printfln!((&*a, &b))
[07:03:26] -rusti- (&3, &3)
[07:03:26] -rusti- ()
[07:03:26] <acrichto> rusti: let a = ~3; let b = 3; format!("{:?}", (&*a, &b))
[07:03:27] -rusti- ~"(&3, &3)"
[07:03:35] <acrichto> yay
[07:03:39] <dbaupp> rusti: let a = ~3; printfln!((&*a, &a))
[07:03:40] -rusti- (&3, &~3)
[07:03:40] -rusti- ()
[07:03:54] * dbaupp likes the emoticon in new-fmt
[07:04:06] <acrichto> :?
[07:04:29] <acrichto> rusti: format!("{:x}", -2u64)
[07:04:29] -rusti- ~"fffffffffffffffe"
[07:04:34] <acrichto> that still makes me happy :P
[07:05:18] * dbaupp hugs acrichto 
[07:05:40] <sfackler> rusti: format!("{:3}", 1.5f32)
[07:05:41] -rusti- ~"1.5"
[07:05:51] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[07:05:51] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/HndFIw
[07:05:51] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[07:05:52] <dbaupp> rusti: format!("{:10.5}", 1.5f32)
[07:05:53] -rusti- ~"   1.50000"
[07:05:59] <dbaupp> rusti: format!("{:<10.5}", 1.5f32)
[07:05:59] -rusti- ~"1.50000   "
[07:06:03] <dbaupp> rusti: format!("{:^10.5}", 1.5f32)
[07:06:04] -rusti- <anon>:5:17: 5:27 error: unterminated format string
[07:06:04] -rusti- <anon>:5          format!("{:^10.5}", 1.5f32)
[07:06:04] -rusti-                           ^~~~~~~~~~
[07:06:04] -rusti- error: aborting due to previous error
[07:06:04] -rusti- application terminated with error code 101
[07:06:12] <strcat> dbaupp: what was that channel for rusti to join again?
[07:06:18] <dbaupp> strcat: #rust-gamedev
[07:06:26] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[07:06:31] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[07:06:40] <dbaupp> acrichto: is there centred format?
[07:07:02] <acrichto> dbaupp: I specifically didn't add that b/c I thought it'd be a pain, but there's not really a reason we couldn't add one now
[07:07:09] <dbaupp> acrichto: yup, just checking
[07:07:23] <dbaupp> acrichto: also, &that error message is not very useful?
[07:07:25] <acrichto> rusti: (format!("{:>10s}", "a"), format!("{:<10s}", "b"))
[07:07:26] -rusti- (~"         a", ~"b         ")
[07:07:31] <dbaupp> s/&/^/
[07:07:52] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[07:07:53] <acrichto> dbaupp: yeah the error messages aren't great
[07:07:57] *** Quits: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net) (Quit: gavinb)
[07:08:01] <acrichto> dbaupp: I'd love to have spans on characters, not on the whole string
[07:08:21] <acrichto> error messages could definitely improve though
[07:08:24] <dbaupp> acrichto: yeah, I imagine that requires managing the spans yourself though?
[07:08:30] <acrichto> yeah :(
[07:08:50] <acrichto> I think that that's interpreting {: and then every next rule skips ^ and then it looks for }, finding ^, and bails
[07:08:50] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.1)
[07:09:00] <dbaupp> ah
[07:09:19] <acrichto> although that could check, and say something like "at character X I couldn't progress"
[07:09:22] <acrichto> or something smart like that
[07:09:36] <rumpler> strcat left without saying bye
[07:09:39] <dbaupp> rusti: format!("{:âˆ«}", 1)
[07:09:39] -rusti- <anon>:5:17: 5:22 error: unterminated format string
[07:09:39] -rusti- <anon>:5          format!("{:âˆ«}", 1)
[07:09:39] -rusti-                           ^~~~~
[07:09:39] -rusti- error: aborting due to previous error
[07:09:39] -rusti- application terminated with error code 101
[07:09:45] <dbaupp> heh
[07:10:01] <dbaupp> acrichto: yeah, "unrecognised character <..>" or something, even.
[07:10:16] <dbaupp> rusti: format!("{:)}", 1)
[07:10:17] -rusti- <anon>:5:17: 5:23 error: unterminated format string
[07:10:17] -rusti- <anon>:5          format!("{:)}", 1)
[07:10:17] -rusti-                           ^~~~~~
[07:10:17] -rusti- error: aborting due to previous error
[07:10:17] -rusti- application terminated with error code 101
[07:10:21] <dbaupp> rusti: format!("{:(}", 1)
[07:10:22] -rusti- <anon>:5:17: 5:23 error: unterminated format string
[07:10:22] -rusti- <anon>:5          format!("{:(}", 1)
[07:10:22] -rusti-                           ^~~~~~
[07:10:23] -rusti- error: aborting due to previous error
[07:10:25] -rusti- application terminated with error code 101
[07:10:29] <acrichto> dbaupp: that should totally be a format âˆ«
[07:10:29] <dbaupp> rusti: format!("{:D}", D=1)
[07:10:31] *** Joins: zeuxcg (zeuxcg@moz-80D1F912.hsd1.ca.comcast.net)
[07:10:39] <acrichto> âˆ« takes an tuple of what to integrate
[07:10:42] <dbaupp> rusti: format!("{:P}", P=1)
[07:10:49] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[07:10:49] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/Vg049w
[07:10:49] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[07:10:50] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[07:10:50] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/WD5mpg
[07:10:50] <ghrust> 13rust/06auto 145c76033 15Daniel Micay: set sret attribute as needed on call instructions...
[07:10:50] <ghrust> 13rust/06auto 148099fab 15bors: auto merge of #9158 : thestinger/rust/extern, r=alexcritchton...
[07:10:50] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[07:10:56] <acrichto> rusti: format!("{D}", D=1)
[07:11:05] <acrichto> you killed rusti, how could you
[07:11:07] -rusti- pastebinned 8 lines of output: http://ix.io/81o
[07:11:07] -rusti- pastebinned 8 lines of output: http://ix.io/81p
[07:11:07] -rusti- ~"1"
[07:11:22] <dbaupp> fine! I'll do backwards emoticons! :P
[07:11:32] <dbaupp> rusti: format!("{D:}", D=1)
[07:11:33] -rusti- ~"1"
[07:11:37] <acrichto> haha
[07:11:40] <acrichto> you're sad
[07:11:46] <dbaupp> rusti: format!("{d:}", d=1)
[07:11:47] -rusti- ~"1"
[07:11:55] <acrichto> that's like almost backwards :p
[07:11:57] <dbaupp> rusti: format!("{I:}", I=1)
[07:11:58] -rusti- ~"1"
[07:12:00] <acrichto> mirrored...
[07:12:06] <dbaupp> rusti: format!("{q:}", q=1)
[07:12:07] -rusti- ~"1"
[07:12:11] <dbaupp> rusti: format!("{v:}", v=1)
[07:12:12] -rusti- ~"1"
[07:12:21] <dbaupp> yup, this is workable
[07:12:27] <acrichto> rusti: format!("{âˆ«}", âˆ«=2)
[07:12:27] -rusti- <anon>:5:23: 5:23 error: unknown start of token: \u222b
[07:12:27] -rusti- <anon>:5          format!("{âˆ«}", âˆ«=2)
[07:12:27] -rusti-                                 ^
[07:12:27] -rusti- application terminated with error code 101
[07:12:30] <acrichto> aww
[07:12:31] <dbaupp> haha :(
[07:12:45] <acrichto> rusti: format!("{â˜ƒ}", â˜ƒ=2)
[07:12:46] -rusti- <anon>:5:23: 5:23 error: unknown start of token: \u2603
[07:12:48] -rusti- <anon>:5          format!("{â˜ƒ}", â˜ƒ=2)
[07:12:49] <engla> format!("{Î±} + {Î²} = {Î£}", Î±=2, Î²=3, Î£=5)
[07:12:50] -rusti-                                 ^
[07:12:51] <dbaupp> I reckon that we should tokenise all characters to macros can use things like that
[07:12:52] -rusti- application terminated with error code 101
[07:12:53] <acrichto> yeah I'm changing that
[07:12:55] <acrichto> :P
[07:12:59] <rumpler> if i have an owned box how do i get a & the actual memory location of the value the box stores?
[07:13:13] <dbaupp> rumpler: `&*x` should work
[07:13:17] <engla> rusti: format!("{Î±} + {Î²} = {Î£}", Î±=2, Î²=3, Î£=5)
[07:13:18] -rusti- ~"2 + 3 = 5"
[07:13:20] <rumpler> of the*
[07:13:22] <acrichto> rusti: let a = ~3; let b: &int = a; println!("{:?}", b)
[07:13:23] -rusti- &3
[07:13:23] -rusti- ()
[07:13:25] <dbaupp> rumpler: (and it will autoborrow to & in most instances)
[07:13:28] <dbaupp> engla: \o/
[07:13:32] <acrichto> engla: yay XID_continue!
[07:13:35] <acrichto> or start
[07:13:39] <engla> yup I saw that
[07:13:42] <acrichto> engla: actually that's awesome
[07:13:44] <engla> only consistent
[07:13:50] <dbaupp> rusti: format!("{_}", _=1)
[07:13:50] -rusti- <anon>:5:24: 5:25 error: unexpected token: `_`
[07:13:50] -rusti- <anon>:5          format!("{_}", _=1)
[07:13:50] -rusti-                                  ^
[07:13:50] -rusti- application terminated with error code 101
[07:14:05] <dbaupp> I guess _ isn't in XID_Start
[07:14:10] <flaper87> how does the { escape works ?
[07:14:20] <acrichto> flaper87: in format!
[07:14:25] <flaper87> In python you'd use double {
[07:14:28] <flaper87> acrichto: yeah
[07:14:28] <acrichto> dbaupp: maybe? that should in theory work
[07:14:35] <acrichto> flaper87: it's a sad, sad story
[07:14:40] <flaper87> :)
[07:14:44] <acrichto> rusti: println!("\\\\")
[07:14:45] -rusti- \
[07:14:45] -rusti- ()
[07:14:50] <flaper87> o.0
[07:14:50] <engla> flaper87: you use \
[07:14:51] <acrichto> that's just downright depressing
[07:15:10] <engla> eh don't exaggerate it too much
[07:15:10] <dbaupp> rusti: format!("{âˆ°}", âˆ°=1) // me is desperately hoping that this isn't like âˆ«
[07:15:10] -rusti- <anon>:5:23: 5:23 error: unknown start of token: \u2230
[07:15:11] -rusti- <anon>:5          format!("{âˆ°}", âˆ°=1) // me is desperately hoping that this isn't like âˆ«
[07:15:11] -rusti-                                 ^
[07:15:11] -rusti- application terminated with error code 101
[07:15:13] <rumpler> db doesn't &*x create a new temporary though?
[07:15:17] <acrichto> the reason is that \\ becomes \ in rust strings, so the format-string parser actually receives `\\` which is the correct escape for \
[07:15:27] <acrichto> dbaupp: what in the world did you just do
[07:15:38] <dbaupp> rumpler: no, there's some compiler magic that means it's just converting to &
[07:15:55] <dbaupp> acrichto: the last one https://en.wikipedia.org/wiki/Integral_sign#Extensions_of_the_symbol
[07:15:58] <acrichto> dbaupp: oh _ isn't an ident
[07:16:14] <acrichto> if lookahead(2) == EQUALS { parse_ident(), parse_equals, parse_exp() }
[07:16:26] <dbaupp> hm?
[07:16:33] <acrichto> that's the code for parsing a=b
[07:16:37] <dbaupp> also, LL(2)? :(
[07:16:42] <acrichto> and I think that parse_ident() fails on "_"
[07:16:46] <pnkfelix> acrichto: out of curiosity, why aren't we doing the python form of using "{{" ?
[07:17:07] <pnkfelix> acrichto: (I don't have a horse in this race, just honestly curious what the trade-off was)
[07:17:08] <acrichto> rusti: format!("{0, select, other{this is why :(}}", "test")
[07:17:09] -rusti- ~"this is why :("
[07:17:16] <flaper87> TBH, double { is quite ugly
[07:17:26] <flaper87> but it works for python
[07:17:29] <acrichto> pnkfelix: nested format specifiers (internationalization functions) actually have {{ and }} come up normally
[07:17:31] <engla> pnkfelix: it's used in the features.  http://static.rust-lang.org/doc/std/fmt.html
[07:17:43] <acrichto> flaper87: it's way better than \\\\
[07:17:49] <flaper87> acrichto: agreed
[07:17:53] <flaper87> no doubt on that
[07:17:56] <flaper87> :D
[07:17:57] *** Joins: nkoep (nik@moz-CEF4E4E7.pool.mediaways.net)
[07:18:00] <acrichto> pnkfelix flaper87: currently the best idea for a workaround is %{ and %}
[07:18:01] <dbaupp> rusti: format!("\\{")
[07:18:01] -rusti- ~"{"
[07:18:08] <dbaupp> acrichto: ^ isn't too bad for { ?
[07:18:14] <acrichto> dbaupp: still pretty bad
[07:18:20] <acrichto> way worse than %{
[07:18:23] <dbaupp> acrichto: yeah
[07:18:28] *** Quits: jstevans (Instantbir@moz-735D8260.washdc.fios.verizon.net) (Ping timeout)
[07:18:29] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[07:18:29] <pnkfelix> engla: "Its used in the features" ?
[07:18:41] *** Joins: bent (chatzilla@FC9FC902.ED95B50E.EDDC15BA.IP)
[07:18:43] <engla> of format
[07:18:47] <acrichto> pnkfelix: http://static.rust-lang.org/doc/std/fmt.html#plural
[07:19:06] <acrichto> pnkfelix: }} just naturally appears in terms of "terminating the enclosing block", so it can't be used as an escape
[07:19:19] <pnkfelix> acrichto: yes, I understood that explanation
[07:19:49] <acrichto> flaper87 pnkfelix: out of curiousity, what's y'alls opinion on %{ %} %# and %% ?
[07:19:50] <pnkfelix> engla: okay, at this point I have inferred that you were pointing me at the occurrence of "}}" in the documentation
[07:19:55] *** Joins: jstevans (Instantbir@moz-735D8260.washdc.fios.verizon.net)
[07:20:39] <flaper87> acrichto: I'd preffer it to be consistent in terms of, both % inside { or both outside
[07:20:47] <engla> I should have said it's used in the syntax, due to some of the features of format
[07:20:49] <flaper87> but it looks good 
[07:20:57] <engla> with it being both {{ and }}
[07:20:57] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[07:21:11] <flaper87> acrichto: I didn't see an example of %# and %%
[07:21:19] <flaper87> acrichto: would that just replace %{ ?
[07:21:43] <acrichto> flaper87: no %# is needed to escape the '#' character, and %% would be to escape the '%' character
[07:21:54] <acrichto> rusti: format!("{0, select, other{#}}", "test")
[07:21:55] -rusti- ~"test"
[07:22:05] <acrichto> '#' is a back-reference to what's being selected or pluralized
[07:22:06] <flaper87> ah, right right. Stupid question!
[07:22:14] <flaper87> acrichto: yeah, sounds good
[07:22:18] <acrichto> rusti: format!("{0, plural, other{#}}", 100)
[07:22:19] -rusti- ~"100"
[07:22:27] <acrichto> rusti: format!("{0, plural, =100{kudos} other{#}}", 100)
[07:22:27] -rusti- ~"kudos"
[07:22:58] <dbaupp> rusti: format!("{0, plural, =100{kudos} other{#}}", "other")
[07:23:03] <engla> the plural selector has five keywords and then you can use literal cases
[07:23:09] -rusti- pastebinned 7 lines of output: http://ix.io/81q
[07:23:11] *** Quits: aatch (aatch@moz-B437F499.pocketrent.com) (Client exited)
[07:23:12] * pnkfelix had assumed that the only true ambiguity was in distinguishing the escaped { as "{{" from a nested pair of "{â€¦"
[07:23:59] *** Quits: naq (naq@D5C2D2DF.E4265FCD.E481B5B.IP) (Quit: leaving)
[07:24:17] <dbaupp> `format!("{0, plural, other{#}} }}", "other")` which is the closing pair?
[07:24:27] *** Joins: naq (naq@D5C2D2DF.E4265FCD.E481B5B.IP)
[07:25:08] <pnkfelix> dbaupp: Okay, I clearly shouldn't be speaking on this topic since I *still* haven't read this doc
[07:25:22] <dbaupp> pnkfelix: :)
[07:26:29] * dbaupp just confused by what this "reoffice" library was in his list of installed packages
[07:26:35] <dbaupp> *got confused
[07:27:05] <rumpler> db are you sure *x is an lvalue?http://static.rust-lang.org/doc/rust.html#TOC does not mention dereferenced as an lvalue
[07:27:28] <dbaupp> rusti: let mut x = ~1; *x = 2; x
[07:27:29] -rusti- ~2
[07:27:32] <rumpler> under lvalue vs rvalue section
[07:28:44] <rumpler> Path, field and index expressions are lvalues. All other expressions are rvalues.
[07:28:47] <dbaupp> rumpler: the manual isn't even close to a specfication
[07:28:52] <dbaupp> it's very wrong in parts
[07:29:08] <dbaupp> e.g. "move expression, and both operands of a swap expression" neither of those exist any more
[07:29:18] <rumpler> so including that part then?
[07:29:50] <dbaupp> yeah, the lvalue part should include derefences (at least!)
[07:30:19] <dbaupp> ("binary move" is gone too, btw)
[07:31:36] *** Quits: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net) (Ping timeout)
[07:34:38] <acrichto> rusti: format!("{:k}", 3)
[07:34:39] -rusti- <anon>:5:25: 5:26 error: unknown format trait `k`
[07:34:39] -rusti- <anon>:5          format!("{:k}", 3)
[07:34:39] -rusti-                                   ^
[07:34:39] -rusti- error: aborting due to previous error
[07:34:39] -rusti- application terminated with error code 101
[07:34:46] <acrichto> rusti: format!("{:^}", 3)
[07:34:46] -rusti- <anon>:5:17: 5:23 error: unterminated format string
[07:34:47] -rusti- <anon>:5          format!("{:^}", 3)
[07:34:47] -rusti-                           ^~~~~~
[07:34:47] -rusti- error: aborting due to previous error
[07:34:47] -rusti- application terminated with error code 101
[07:35:44] <rumpler> db is a dereferenced box a slot? 
[07:35:49] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[07:35:49] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 148099fab to 14323e8f0: 02http://git.io/N3iJvQ
[07:35:49] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[07:35:50] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[07:35:50] <ghrust> 01[13rust01] 15bors pushed 20 new commits to 06auto: 02http://git.io/0T1lXg
[07:35:51] <ghrust> 13rust/06auto 1445c62c0 15Erick Tryzelaar: std: rename Option::unwrap_or_default() to unwrap_or()
[07:35:51] <ghrust> 13rust/06auto 14653400a 15Erick Tryzelaar: std: add default implementations to HashMap
[07:35:51] <ghrust> 13rust/06auto 144a73c8e 15Erick Tryzelaar: std: add default implementations to Option
[07:35:53] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[07:35:58] <dbaupp> rusti: error2!("{}", "a" + "Ã¥".repeat(100000))
[07:36:00] <acrichto> haha the format parser is calling fmt that makes no sense :P
[07:36:02] -rusti- pastebinned 2 lines of output: http://ix.io/7T3
[07:36:10] <dbaupp> acrichto: unsafety^ \o/
[07:36:18] *** Quits: busylizzy (lisa@85228838.12D0DC84.211374C4.IP) (Ping timeout)
[07:36:29] <dbaupp> acrichto: (i think that's a problem in the implementation of log, though, not fmt)
[07:36:40] <acrichto> dbaupp: whoa
[07:36:49] <acrichto> dbaupp: oh yeah that is
[07:36:54] *** Joins: busylizzy (lisa@85228838.12D0DC84.211374C4.IP)
[07:36:55] <acrichto> std::rt::logging
[07:36:56] <dbaupp> acrichto: specifically it does a byte-slice at 2000 bytes or something
[07:36:59] <acrichto> I yep
[07:37:12] <acrichto> I have a pull request to fix that, but it's ICE-ing when compiling stage1
[07:37:21] <acrichto> but it makes logging/failing 0-allocations
[07:37:30] <acrichto> which kinda makes sense for failing when you think about it...
[07:37:44] <dbaupp> yeah
[07:37:56] <dbaupp> avoid a nested fail if the alloc fails
[07:37:59] <dbaupp> (?)
[07:38:11] <dbaupp> rumpler: I don't know what a "slot" is in this instance
[07:38:22] <acrichto> yeah, also allocating may not be working if you're failing
[07:40:51] <acrichto> did we have a convention on error messages for "exepected but found"
[07:41:03] <dbaupp> rusti: let x: ~str = 1;
[07:41:03] -rusti- <anon>:5:23: 5:24 error: mismatched types: expected `~str` but found `<VI0>` (expected ~str but found integral variable)
[07:41:04] -rusti- <anon>:5          let x: ~str = 1;
[07:41:04] -rusti-                                 ^
[07:41:04] -rusti- error: aborting due to previous error
[07:41:04] -rusti- application terminated with error code 101
[07:41:08] <dbaupp> that ^ 
[07:41:10] <dbaupp> ?
[07:42:05] *** Quits: jstevans (Instantbir@moz-735D8260.washdc.fios.verizon.net) (Ping timeout)
[07:42:32] *** Quits: rumpler (Mibbit@7C71104E.56A70E04.FC355C3F.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[07:42:34] <engla> acrichto: 0 allocations for fail is great
[07:43:26] <engla> ah, even if it's just the output functions themselves it's a start
[07:44:47] <acrichto> sadly inner statics in function is super-untested so first I had to fix a bunch of bugs (mostly symbol naming), and now there's another that I have no idea how it's triggered
[07:44:54] *** Quits: victorporof (victorporo@FBDAE982.F9BD9D78.9B1E38F4.IP) (Ping timeout)
[07:44:56] <acrichto> error: internal compiler error: encode_symbol: id not found 126443
[07:44:58] <acrichto> what
[07:45:40] <acrichto> I fixed a bunch of those errors, but not all of them apparently
[07:45:48] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[07:45:48] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 142548bcf to 14323e8f0: 02http://git.io/N3iJvQ
[07:45:48] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[07:45:49] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[07:45:49] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/xO2UIg
[07:45:49] <ghrust> 13rust/06auto 14d06595c 15Alex Crichton: Backport an LLVM fix to close #9117
[07:45:49] <ghrust> 13rust/06auto 14e159fd0 15bors: auto merge of #9118 : alexcrichton/rust/llvm-fix, r=sanxiyn...
[07:45:49] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[07:45:52] <dbaupp> default methods + inner functions is broken too
[07:45:54] <klutzy> acrichto: I've got such error when I defined fn inside trait default method
[07:46:16] <acrichto> klutzy: hm yeah I just had the bright idea of actually searching in the issue tracker and I found https://github.com/mozilla/rust/issues/9123
[07:46:28] *** Joins: victorporof (victorporo@FBDAE982.F9BD9D78.9B1E38F4.IP)
[07:46:34] <acrichto> oh hm maybe this is related to that...
[07:48:19] <acrichto> bingo!
[07:48:40] * acrichto will investigate
[07:49:21] *** Joins: bbouvier (bnjbouv@moz-63AFAFBF.gagahome.fr)
[07:53:07] *** Quits: ross (ross@moz-5EA04060.br.br.cox.net) (Quit: )
[07:53:14] <frau> how do I unsafely get the byte array in a str as a C string (null termination not needed)... s.as_bytes() as c_char* is OK?
[07:54:17] <engla> frau: there are methods .as_imm_buf, .as_mut_buf to get an *u8 pointer
[07:54:41] *** Quits: tikue (tkuehn@E5ACE5E7.28336FB0.689607DE.IP) (Quit: tikue)
[07:55:03] <frau> engla: ah, thanks!
[07:55:38] <engla> and the as_mut_buf docs say  /// The caller must make sure any mutations to this buffer keep the string /// valid UTF-8!
[07:58:29] *** Quits: nkoep (nik@moz-CEF4E4E7.pool.mediaways.net) (Ping timeout)
[08:00:52] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[08:00:52] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14e159fd0 to 14323e8f0: 02http://git.io/N3iJvQ
[08:00:52] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[08:00:53] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[08:00:53] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/XsNByg
[08:00:53] <ghrust> 13rust/06auto 143d14e82 15Jakub: Fix rustpkg install for git repositories
[08:00:53] <ghrust> 13rust/06auto 14fd39bd1 15bors: auto merge of #9148 : jakub-/rust/rustpkg-install-mkdir-p, r=catamorphism...
[08:00:53] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[08:04:04] *** Quits: zeuxcg (zeuxcg@moz-80D1F912.hsd1.ca.comcast.net) (Ping timeout)
[08:05:08] <klutzy> acrichto: I finally made a fix for newrt file. you'll be stunned why it has been broken
[08:05:14] *** Quits: tgummerer (tgummerer@51D3B54.FEF996EA.EA6FEF3D.IP) (Ping timeout)
[08:05:30] <dbaupp> klutzy: ?
[08:05:40] * flaper87 wants to be stunned
[08:06:30] <klutzy> at libuv/include/uv-unix.h: typedef struct {char* base;size_t len;} uv_buf_t;
[08:06:36] <klutzy> at libuv/include/uv-win.h: typedef struct uv_buf_t {ULONG len;char* base;} uv_buf_t;
[08:07:00] <klutzy> so on win32 buf goes to len, len goes to base
[08:07:28] <klutzy> and it tries to write nonsense-bytes to file where the buffer is at 0x4
[08:07:40] <flaper87> o.0
[08:07:51] <dbaupp> ;O
[08:07:54] <dbaupp> *:O
[08:08:05] <dbaupp> why is libuv even like that?
[08:08:13] <klutzy> no idea
[08:08:17] <klutzy> they even duplicated Makefiles
[08:08:20] <acrichto> klutzy: what
[08:08:26] <acrichto> klutzy: oh god that's terrifying
[08:08:30] <flaper87> holymoly
[08:08:32] <acrichto> klutzy: but \o/
[08:08:36] <acrichto> nice catch :)
[08:08:37] * flaper87 plop
[08:08:42] <acrichto> I will r+ that in a second
[08:09:09] * dbaupp would do it in a millisecond
[08:09:24] * flaper87 can't do that, yet (?)
[08:09:25] <acrichto> maybe libuv wanted to expose cross-arch bugs so they deliberately messed with us :P
[08:09:33] <flaper87> acrichto: LOL
[08:09:54] <acrichto> I'm sad though, https://github.com/mozilla/rust/pull/9141 didn't fix anything :(
[08:10:56] <dbaupp> acrichto: oh :(
[08:11:04] <acrichto> huh, you can't close a rt::io::file::FileStream
[08:11:23] <klutzy> I'll make a pr after trying to enabling io tests
[08:11:43] <acrichto> klutzy: you are awesome
[08:12:29] <klutzy> I've erased all ignore(cfg(windows)), but I think some of them can still fail if there may be other funny bugs :)
[08:12:57] <acrichto> I wish there were a way for us to test against something like this happening :(
[08:13:06] <acrichto> other than cross-arch tests in general
[08:13:30] <flaper87> klutzy: on all modules?
[08:14:03] *** Joins: nkoep (nik@moz-9D530F50.vpn.rwth-aachen.de)
[08:14:08] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[08:14:09] <klutzy> flaper87: eh.. file.rs only. maybe I have to check others
[08:14:26] <flaper87> klutzy: kk, no hurries, I was just curious
[08:14:32] <flaper87> one step at a time
[08:14:39] <acrichto> git grep item_trait src/librustc/middle/trans
[08:14:41] <acrichto> no hits
[08:14:48] <acrichto> that's kinda terrifying
[08:15:06] <engla> acrichto: Don't they just close in Drop?
[08:15:14] <acrichto> engla: they should, which is what confuses me
[08:15:20] <flaper87> damn, I had this "PR" ready that I haven't submitted, will do that today! ETOOMANYTHINGS
[08:15:31] <flaper87> I have*
[08:15:33] <acrichto> engla: b/c the tests are failing when the files don't exist, which is weird b/c you just created them...
[08:15:37] * flaper87 can't english today
[08:15:58] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Client exited)
[08:16:19] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[08:18:00] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[08:23:44] *** Quits: frau (frau@moz-C616DA0A.hsd1.ca.comcast.net) (Quit: out)
[08:24:55] *** Quits: pyrac (pyrac@moz-C411EA77.math.u-bordeaux1.fr) (Quit: pyrac)
[08:25:16] *** Joins: pyrac (pyrac@moz-C411EA77.math.u-bordeaux1.fr)
[08:25:49] *** Joins: ghcv8yefgqv817tg (hvbeuveigv@92B511DE.53B2A2B0.DB9D6342.IP)
[08:27:05] *** Quits: ghcv8yefgqv817tg (hvbeuveigv@92B511DE.53B2A2B0.DB9D6342.IP) (Excess Flood)
[08:28:36] <pnkfelix> can someone remind me how one increases the stack size since we don't have segmented stacks in the new runtime?  Is there an environment variable for it?
[08:29:58] <klutzy> RUST_MIN_STACK?
[08:30:29] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[08:31:01] *** Joins: huseby (huseby@moz-633A76FB.static.cust.telenor.com)
[08:31:51] *** Quits: nkoep (nik@moz-9D530F50.vpn.rwth-aachen.de) (Client exited)
[08:32:22] <pnkfelix> klutzy: thx will try that
[08:32:45] *** Quits: ab (alex@BC9D99CC.37C1012D.FE617B51.IP) (Ping timeout)
[08:33:06] *** Joins: tikue (tkuehn@moz-FEADCD38.hsd1.pa.comcast.net)
[08:34:23] *** Joins: ab (alex@BC9D99CC.37C1012D.FE617B51.IP)
[08:34:23] *** Quits: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP) (Quit: Konversation terminated!)
[08:39:46] *** Joins: sebcrozet (sebcrozet@moz-3CE49532.lrde.epita.fr)
[08:40:51] <Amaranth> Hmm, is it possible to have something public to other files in my crate but not in general?
[08:41:26] <Amaranth> I have some functions that I'm going to need in two files but don't want to be a part of the public API
[08:43:08] *** Joins: mib_c4rvd3 (Mibbit@moz-F3755E99.emplot.net)
[08:43:14] <Amaranth> Oh, alright, this is odd
[08:43:22] <mib_c4rvd3> how do rust assures protection from buffer overflow? 
[08:43:47] <Amaranth> Looks like I need to put them in a public module separate from things I want to be in the API and then not expose it in my main crate file
[08:44:03] <pnkfelix> mib_c4rvd3: by eschewing pointer arithmetic ?
[08:44:51] <dbaupp> mib_c4rvd3: and bounds checks by default for array indexes
[08:44:52] *** Quits: KindOne (KindOne@F8BBCE07.DFA916E1.34F73994.IP) (Ping timeout)
[08:45:11] *** Joins: lessless (lessless@moz-F3755E99.emplot.net)
[08:45:23] <Amaranth> I'm guessing optimizing out unneeded bounds checking is still an active project :)
[08:45:29] <Amaranth> Mostly because it always is
[08:45:38] <engla> using iterators is the easiest way Amaranth 
[08:46:21] <Amaranth> Sure and you should use them anyway because no only are you more clearly expressing your intent to the compiler you're doing so to future programmers who work on your code
[08:46:30] <Amaranth> But I meant besides that
[08:46:54] <engla> rusti: let mut v = ~[@1]; v.reserve(-1); v.push(@2)
[08:46:54] *** Joins: donri (donri@moz-9BB61102.tbcn.telia.com)
[08:46:55] -rusti- application terminated abnormally with signal 11 (Segmentation fault)
[08:47:04] <engla> we also didn't plug all holes yet :)
[08:47:07] <Amaranth> :D
[08:47:24] <myname> what
[08:47:44] <dbaupp> rusti: -1u
[08:47:45] -rusti- 18446744073709551615u
[08:48:02] <dbaupp> it's trying to reserve space for that many elements
[08:48:06] <mib_c4rvd3> thank you
[08:48:42] *** Joins: KindOne (KindOne@F8BBCE07.DFA916E1.34F73994.IP)
[08:50:41] <dbaupp> https://github.com/mozilla/rust/pulls "All Requests 23 ... acrichto 7"
[08:54:47] <Amaranth> Okay I guess I don't know how to do this after all
[08:55:02] <Amaranth> I've got a new file called "wrappers" with some pub functions in it
[08:55:19] <Amaranth> I want things in my crate to use it but for it to not be a part of the API
[08:55:35] <Amaranth> wrappers.rs for the file name rather
[08:56:36] <Amaranth> I tried sticking use wrappers; in my other files but they can't find it. Tried adding a mod wrappers; but they can't find that either. When I add it to my main crate file along with the other modules I want to be public that works
[08:56:49] <Amaranth> But that makes it public just like everything else and ruins the point
[08:56:50] *** Quits: mib_c4rvd3 (Mibbit@moz-F3755E99.emplot.net) (Quit: http://www.mibbit.com ajax IRC Client)
[08:58:19] <SingingBoyo> Amaranth: not sure, but I don't think what you want is possible. 
[08:58:31] *** Joins: diverse (diverse@moz-ED94B8D.oc.oc.cox.net)
[08:58:51] <Amaranth> Starting to think the same thing :(
[09:00:10] <Amaranth> I might just have to copy/paste them around
[09:00:18] <Amaranth> Because making them public to users of the library is not a good idea
[09:00:19] <SingingBoyo> Amaranth: Is there any way to move the functions into their own crate?  Or would that create a cycle in the dependencies between wrapper and your main crate?
[09:00:56] <Amaranth> Wouldn't that make a separate .so people could use just as easily as I do?
[09:01:10] <Amaranth> Also yeah I depend on things in this crate
[09:01:25] <Amaranth> In C I'd just not include these functions in the public headers
[09:03:06] <SingingBoyo> Amaranth: yeah you might want to see if there's an issue for something like that, that's a pretty important feature imo
[09:03:32] <Amaranth> It seems like the only file that can reference this one is my main crate file which can only either expose it publicly or use it within that one file
[09:07:54] <dbaupp> Amaranth: https://mail.mozilla.org/pipermail/rust-dev/2013-July/005044.html (https://mail.mozilla.org/pipermail/rust-dev/2013-July/thread.html#5044 for the overview)
[09:11:18] <SingingBoyo> Amaranth: https://github.com/mozilla/rust/issues/8215 specifically the suggestion that we end up with "pub items in a non-pub mod are visible to the rest of the crate, but not visible to users outside the crate"
[09:11:31] *** Joins: doomlord (doomlod@moz-DEFFB365.range81-147.btcentralplus.com)
[09:11:39] <SingingBoyo> Amaranth: in short, it doesn't work now, but hopefully will in the future
[09:12:21] *** Quits: jaen (jaen@moz-B736C889.neoplus.adsl.tpnet.pl) (Ping timeout)
[09:14:40] <Amaranth> hrm, bummer
[09:15:21] *** Joins: ceninan (ceninan@moz-6BD43586.a370.priv.bahnhof.se)
[09:17:25] *** Quits: SingingBoyo (brandon@DAC9C672.CE76D40F.4F048BDC.IP) (Ping timeout)
[09:17:27] <Amaranth> Alright I think for now I'll actually just leave the functions public and accept that making them private later will be one of many ABI breaks in this binding library
[09:20:52] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[09:20:52] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/XsNByg
[09:20:52] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[09:22:30] <dbaupp> glyc: re https://github.com/mozilla/rust/issues/9163, static linking doesn't work very well at all, so it's unlikely that statically linking std would work even if it could build (assuming this is what you're attempting?)
[09:23:01] <dbaupp> glyc: (but don't close the issue, it's still a bug)
[09:23:14] *** Quits: KindOne (KindOne@F8BBCE07.DFA916E1.34F73994.IP) (Ping timeout)
[09:24:24] *** Quits: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net) (Ping timeout)
[09:25:51] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[09:25:51] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/HK71Gg
[09:25:51] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[09:25:52] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[09:25:52] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/snfWtw
[09:25:52] <ghrust> 13rust/06auto 1468a9137 15Alex Crichton: Rewrite fileinput tests to use std::rt::io...
[09:25:53] <ghrust> 13rust/06auto 147c8f503 15bors: auto merge of #9141 : alexcrichton/rust/ignore-fileinput, r=catamorphism...
[09:25:53] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[09:26:14] *** Joins: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net)
[09:27:16] *** Joins: KindOne (KindOne@moz-79A66DC5.dynamic.ip.windstream.net)
[09:35:58] *** Joins: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP)
[09:36:30] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[09:42:45] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[09:43:59] *** Quits: pyrac (pyrac@moz-C411EA77.math.u-bordeaux1.fr) (Quit: pyrac)
[09:43:59] *** Quits: ww (Mibbit@moz-DFAED48A.lightspeed.sntcca.sbcglobal.net) (Quit: http://www.mibbit.com ajax IRC Client)
[09:50:04] *** Joins: mindcat (mindcat@5C1E3272.FBBDCC14.1A8D6442.IP)
[09:59:40] <mindcat> how to use "std::
[10:00:04] <jzelinskie> do you guys recommend using rust 0.7 (whatever is in brew) or should I just use tip?
[10:00:36] *** AutomatedTester is now known as AutomatedTester|away
[10:00:55] <mindcat> how to use "std::run", execute process and read output or write input?
[10:01:19] <Amaranth> jzelinskie: I believe the current idea is you should pretty much always be using latest master
[10:01:22] <Amaranth> Or close to it
[10:01:38] <jzelinskie> ok
[10:01:41] <mindcat> jzelinskie: master version right.
[10:03:32] <mindcat> oh, my fault. I just found how to use.
[10:03:48] <jzelinskie> where's the best place to read modern docs?
[10:04:02] <jzelinskie> I found this: http://static.rust-lang.org/doc/tutorial.html but it seems a little old
[10:04:21] <jzelinskie> actually maybe it isn't
[10:04:35] <mindcat> jzelinskie: http://seld.be/rustdoc/master/
[10:04:41] <jzelinskie> thanks
[10:08:33] <dbaupp> jzelinskie: note that seld.be is a few weeks behind master right now
[10:08:42] <engla> jzelinskie: rust-lang.org has the doc links to the left
[10:08:59] <engla> http://www.rust-lang.org/
[10:09:49] *** Quits: indutny (indutny@moz-49D42D15.c.ircrelay.com) (Quit: IRCRelay - http://ircrelay.com)
[10:09:49] <engla> so yes, that's the correct tutorial URL
[10:12:36] *** Quits: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP) (Ping timeout)
[10:13:24] *** Quits: sebcrozet (sebcrozet@moz-3CE49532.lrde.epita.fr) (Quit: Konversation terminated!)
[10:13:44] <engla> The tutorial will be updated for new the formatting macros soon I think
[10:15:07] <jzelinskie> is there an up-to-date github repo that has the vim plugins, so i can use it with pathogen/vundle?
[10:15:26] <jzelinskie> actually, i suppose i could point it directly to rust
[10:15:50] <jzelinskie> duno if i want to clone the whole thing though
[10:15:55] <jzelinskie> another time for vim that is
[10:16:33] <jzelinskie> https://github.com/wting/rust.vim
[10:16:36] <jzelinskie> that looks fairly up to date
[10:16:51] <dbaupp> "It is synchronized daily to the vim support code in mozilla/rust's master branch via cronjob."
[10:17:44] <jzelinskie> fairly might be an understatement :P
[10:21:49] *** Quits: KindOne (KindOne@moz-79A66DC5.dynamic.ip.windstream.net) (Ping timeout)
[10:22:09] *** Quits: nsf (nsf@moz-EEF3238A.convex.ru) (Quit: WeeChat 0.4.1)
[10:24:02] *** Joins: lenstr (lenstr@E0E80B8D.ED45D46B.DFEAE789.IP)
[10:25:51] *** Joins: KindOne (KindOne@moz-79A66DC5.dynamic.ip.windstream.net)
[10:26:39] *** Quits: tikue (tkuehn@moz-FEADCD38.hsd1.pa.comcast.net) (Quit: tikue)
[10:26:43] *** Joins: nkoep (nik@moz-CEF4E4E7.pool.mediaways.net)
[10:27:18] *** Joins: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au)
[10:27:40] <klutzy> achin: dbaupp: https://github.com/mozilla/rust/pull/9165
[10:28:18] <klutzy> enabling tests are not included; local test died at unrelated one, but I have to see it later
[10:28:25] * klutzy goes for dinner
[10:28:41] *** Joins: tikue (tkuehn@moz-FEADCD38.hsd1.pa.comcast.net)
[10:29:19] *** Quits: fyolnish (fyolnish@moz-BE2BAE5B.miinet.jp) (Ping timeout)
[10:34:34] *** Quits: lenstr (lenstr@E0E80B8D.ED45D46B.DFEAE789.IP) (Client exited)
[10:35:52] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[10:35:52] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/snfWtw
[10:35:52] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[10:36:00] *** Quits: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au) (Quit: gavinb)
[10:37:23] *** Quits: lessless (lessless@moz-F3755E99.emplot.net) (Ping timeout)
[10:40:52] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[10:40:52] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/77Bfuw
[10:40:52] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[10:40:53] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[10:40:53] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/A8ZpEw
[10:40:53] <ghrust> 13rust/06auto 142617cd0 15Tim Chevalier: rustpkg: Cleanup
[10:40:53] <ghrust> 13rust/06auto 14db56cc1 15bors: auto merge of #9150 : catamorphism/rust/rustpkg-cleanup, r=catamorphism...
[10:40:53] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[10:43:12] *** Joins: Earnestly (earnest@moz-BE290A2B.dyn.plus.net)
[10:49:43] *** Quits: bent (chatzilla@FC9FC902.ED95B50E.EDDC15BA.IP) (Ping timeout)
[10:59:45] *** Joins: lessless (lessless@moz-F3755E99.emplot.net)
[10:59:48] *** Joins: lenstr (lenstr@E0E80B8D.ED45D46B.DFEAE789.IP)
[10:59:54] <jzelinskie> heh, when you guys say the interpreter is experimental, you aren't joking :)
[11:02:02] *** Quits: dew (Instantbir@moz-D2FA52B6.static.stls.mo.charter.com) (Ping timeout)
[11:02:11] *** Joins: dew (Instantbir@moz-D2FA52B6.static.stls.mo.charter.com)
[11:05:52] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[11:05:52] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/LOdOfg
[11:05:52] <ghrust> 13rust/06auto 14ef964a1 15Steven Fackler: Stop using newtypes in rt::io::buffered...
[11:05:52] <ghrust> 13rust/06auto 149a88e4d 15bors: auto merge of #9156 : sfackler/rust/buffered-fix, r=huonw...
[11:05:52] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[11:07:00] <kimundi> jzelinskie: Haha, yeah
[11:07:42] <kimundi> jzelinskie: You can pm the rusti bot here in the channel, though. That one is actually rustc in disguise, and works usually.
[11:08:10] <kimundi> rusti: "Say hello".slice(4,11)
[11:08:11] -rusti- task <unnamed> failed at 'index out of bounds: the len is 9 but the index is 11', <anon>:1
[11:08:11] -rusti- application terminated with error code 101
[11:08:13] <pnkfelix> RINR: rusti is not rusti
[11:08:16] <kimundi> rusti: "Say hello".slice(4,9)
[11:08:17] -rusti- "hello"
[11:09:14] <kimundi> RTRINRTB: rusti the repl is not rusti the bot
[11:09:57] *** Quits: lenstr (lenstr@E0E80B8D.ED45D46B.DFEAE789.IP) (Client exited)
[11:11:01] <jzelinskie> sounds like a good time to rename the bot...
[11:12:37] <kimundi> rusti: for pre in "rusti the repl is not rusti the bot".word_iter().map(|s| s.slice(0, 1)) { print(s); }
[11:12:38] -rusti- <anon>:5:101: 5:102 error: unresolved name `s`. Did you mean `i`?
[11:12:38] -rusti- <anon>:5          for pre in "rusti the repl is not rusti the bot".word_iter().map(|s| s.slice(0, 1)) { print(s); }
[11:12:38] -rusti-                                                                                                               ^
[11:12:38] -rusti- error: aborting due to previous error
[11:12:39] -rusti- application terminated with error code 101
[11:12:39] *** Joins: z0w0 (zack@moz-61B3764E.qcl9.cha.bigpond.net.au)
[11:12:44] <kimundi> rusti: for pre in "rusti the repl is not rusti the bot".word_iter().map(|s| s.slice(0, 1)) { print(pre); }
[11:12:45] -rusti- rtrinrtb()
[11:14:44] <kimundi> rusti: "rusti the repl is not rusti the bot".word_iter().map(|s| s.char_at(0).to_ascii().to_upper().to_char()).collect::<~str>()
[11:14:45] -rusti- ~"RTRINRTB"
[11:15:10] *** Joins: jaen (jaen@FB01674D.56B727FE.4B52F012.IP)
[11:17:28] *** AutomatedTester|away is now known as AutomatedTester
[11:18:40] <pnkfelix> maybe we should indeed have strcat rename it to rustb or rbot or somesuch
[11:19:19] <mindcat> xRustI
[11:19:27] <kimundi> let's call it rusty :)
[11:19:36] <jzelinskie> +1
[11:22:39] <engla> yeah
[11:24:57] *** jorendorff_away is now known as jorendorff
[11:25:10] *** Joins: pyrac (pyrac@moz-C411EA77.math.u-bordeaux1.fr)
[11:25:13] *** Quits: tikue (tkuehn@moz-FEADCD38.hsd1.pa.comcast.net) (Quit: tikue)
[11:28:43] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[11:32:53] *** AutomatedTester is now known as AutomatedTester|away
[11:35:05] *** Joins: jfbk (jfbk@moz-EEA9CFB3.nyc.res.rr.com)
[11:37:13] *** Parts: kkris (kkris@moz-CB70009.yourvserver.net) (QUIT :Leaving.)
[11:40:20] *** Joins: gkreytebrjk (hvbeuveigv@92B511DE.53B2A2B0.DB9D6342.IP)
[11:41:37] *** Quits: gkreytebrjk (hvbeuveigv@92B511DE.53B2A2B0.DB9D6342.IP) (Excess Flood)
[11:42:56] *** Joins: fyolnish (fyolnish@moz-A2FCAB7C.uqwimax.jp)
[11:45:10] *** Joins: lenstr (lenstr@E0E80B8D.ED45D46B.DFEAE789.IP)
[11:52:50] *** Quits: huseby (huseby@moz-633A76FB.static.cust.telenor.com) (Quit: Leaving)
[11:55:12] *** Joins: bent (chatzilla@FC9FC902.ED95B50E.EDDC15BA.IP)
[11:55:55] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[11:55:55] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 149a88e4d to 147c8f503: 02http://git.io/N3iJvQ
[11:55:55] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[11:56:51] *** Quits: lenstr (lenstr@E0E80B8D.ED45D46B.DFEAE789.IP) (Client exited)
[11:57:36] *** jorendorff is now known as jorendorff_away
[11:58:01] *** Quits: bent (chatzilla@FC9FC902.ED95B50E.EDDC15BA.IP) (Quit: ChatZilla 0.9.90.1-rdmsoft [XULRunner 22.0/20130619132145])
[11:58:44] *** Quits: lazyden (lazyden@47A36AC9.35CBBBD0.F246D1AF.IP) (Quit: lazyden)
[12:03:35] *** Joins: nsf (nsf@moz-EEF3238A.convex.ru)
[12:06:06] *** Quits: sk (sk@273FD846.E993C7C3.78DD174B.IP) (Ping timeout)
[12:10:42] *** Joins: sk (sk@A7A9ED26.751D8A43.78DD174B.IP)
[12:15:36] <kimundi> erickt: Seems your Option PR failed in the os module, there are a few functions that are platform specific and use Option methods - I had the same problem too when I last touched Options ;)
[12:16:56] *** Quits: _1126 (1126@moz-83D60E55.lileth.net) (Quit: leaving)
[12:17:02] *** Joins: _1126 (1126@moz-83D60E55.lileth.net)
[12:18:31] *** Quits: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP) (Ping timeout)
[12:20:11] *** Quits: pyrac (pyrac@moz-C411EA77.math.u-bordeaux1.fr) (Quit: pyrac)
[12:22:56] <dbaupp> :( .with_c_str is so easy to misuse
[12:23:18] * dbaupp wonders how many segfaults will be due to `str.with_c_str(|ptr| ptr)`
[12:23:24] <dbaupp> (or equivalent)
[12:23:50] <kimundi> There should be a warn lint for that
[12:24:16] <kimundi> For situations where you let an unsafe pointer escape from inside an closure call
[12:24:29] <dbaupp> yeah
[12:24:43] <dbaupp> (it'd be convenient if unsafe pointers could have lifetimes.)
[12:24:49] *** Joins: pyrac (pyrac@moz-C411EA77.math.u-bordeaux1.fr)
[12:25:21] <kimundi> Meh, if they had you might as well use &
[12:25:53] <kimundi> +- mutability of course
[12:26:39] <dbaupp> maybe
[12:26:52] <dbaupp> not quite as flexible, but I take your point
[12:28:11] <mindcat> rusti: extern mod std; std::str::from::bytes([10u8])
[12:28:11] -rusti- <anon>:5:9: 5:24 error: "extern mod" declarations are not allowed here
[12:28:11] -rusti- <anon>:5          extern mod std; std::str::from::bytes([10u8])
[12:28:12] -rusti-                   ^~~~~~~~~~~~~~~
[12:28:12] -rusti- error: aborting due to previous error
[12:28:12] -rusti- application terminated with error code 101
[12:29:20] <mindcat> rusti: use std::str; print(str::from_bytes([10u8]));"Oh!"
[12:29:20] -rusti- <anon>:5:29: 5:44 error: unresolved name `str::from_bytes`.
[12:29:20] -rusti- <anon>:5          use std::str; print(str::from_bytes([10u8]));"Oh!"
[12:29:21] -rusti-                                       ^~~~~~~~~~~~~~~
[12:29:21] -rusti- error: aborting due to previous error
[12:29:21] -rusti- application terminated with error code 101
[12:29:31] <kimundi> mindcat: 1.) Every crate has an implicit 'extern mod std' already, so it wouldn't be neccessary here. 2.) You can't currently put an extern mod; into a function body, which is what happens here with rusti.
[12:30:14] <kimundi> The use std::str; str::from_... is correct, but the function got renamed to from_utf8 ;)
[12:30:32] <mindcat> kimundi: what...
[12:30:46] <kimundi> rusti: use std::str; print(str::from_utf8([10u8]));"Oh!"
[12:30:47] -rusti- "Oh!"
[12:31:09] <kimundi> rusti: print(::std::str::from_utf8([10u8]));"Oh!"
[12:31:10] -rusti- "Oh!"
[12:31:27] <mindcat> rusti: use std::str; print(str::from_bytes([93u8,10]))
[12:31:27] -rusti- <anon>:5:29: 5:44 error: unresolved name `str::from_bytes`.
[12:31:27] -rusti- <anon>:5          use std::str; print(str::from_bytes([93u8,10]))
[12:31:28] -rusti-                                       ^~~~~~~~~~~~~~~
[12:31:28] -rusti- error: aborting due to previous error
[12:31:28] -rusti- application terminated with error code 101
[12:31:36] <mindcat> rusti: use std::str; print(str::from_utf8([93u8,10]))
[12:31:36] -rusti- ]
[12:31:37] -rusti- ()
[12:31:51] *** jorendorff_away is now known as jorendorff
[12:32:14] <mindcat> rusti: use std::str; print(str::is_utf8([93u8,10]))
[12:32:15] -rusti- <anon>:5:29: 5:53 error: mismatched types: expected `&str` but found `bool` (expected &str but found bool)
[12:32:15] -rusti- <anon>:5          use std::str; print(str::is_utf8([93u8,10]))
[12:32:15] -rusti-                                       ^~~~~~~~~~~~~~~~~~~~~~~~
[12:32:15] -rusti- error: aborting due to previous error
[12:32:15] -rusti- application terminated with error code 101
[12:32:24] <kimundi> rusti: println(::std::str::from_utf8([93u8]));"Oh!"
[12:32:24] -rusti- ]
[12:32:25] -rusti- "Oh!"
[12:32:35] <mindcat> rusti: use std::str; str::is_utf8([93u8,10])
[12:32:36] -rusti- true
[12:32:46] <mindcat> rusti: use std::str; str::is_utf8([10u8])
[12:32:47] -rusti- true
[12:33:27] <kimundi> 0-127 is ascii is valid utf8, but I think 10 is not a printable character :)
[12:34:11] *** AutomatedTester|away is now known as AutomatedTester
[12:34:26] <mindcat> kimundi: that is newline character
[12:34:38] <kimundi> oh, hmm
[12:34:43] <mindcat> rusti: use std::str; str::from_utf8([10u8,10,10])
[12:34:43] -rusti- ~"\n\n\n"
[12:34:47] <bstrie> rusti: print("\n")
[12:34:48] -rusti- ()
[12:34:54] <bstrie> rusti might eat newlines
[12:35:02] <kimundi> yeah, it does apparently
[12:35:13] <kimundi> rusti: ::std::str::from_utf8([10u8])
[12:35:14] -rusti- ~"\n"
[12:35:27] <bstrie> rusti: print("\r")
[12:35:27] -rusti- ()
[12:35:29] <mindcat> rusti: ::str::from_utf8([10u8,10,10])
[12:35:37] -rusti- pastebinned 11 lines of output: http://ix.io/81z
[12:35:54] <mindcat> rusti: use std::str; print(str::from_utf8([10u8,10,10]))
[12:35:55] -rusti- ()
[12:36:03] <mindcat> it eats
[12:36:08] <kimundi> mindcat: leading :: in an expression means strat looking from crate root instead of from what is locally imported with 'use'
[12:36:32] <bstrie> another artifact of rusti
[12:37:01] <kimundi> ::std::str::from_utf8([10u8])  ==  use std::str::from_utf8; from_utf8([10u8])
[12:37:15] <mindcat> kimundi: that is convenient :D
[12:40:33] <cmr> acrichto: pong
[12:41:47] * dbaupp is extremely unhappy that transmute has such a bad span
[12:42:01] <dbaupp> rusti: std::cast::transmute::<u64, u8>(1)
[12:42:02] -rusti- <anon>:5:9: 6:5 error: call to unsafe function requires unsafe function or block
[12:42:02] -rusti- <anon>:5          std::cast::transmute::<u64, u8>(1)
[12:42:02] -rusti- <anon>:6     };
[12:42:02] -rusti- error: aborting due to previous error
[12:42:02] -rusti- application terminated with error code 101
[12:42:10] <dbaupp> rusti: unsafe{std::cast::transmute::<u64, u8>(1)}
[12:42:11] -rusti- <anon>:1:0: 1:0 error: transmute called on types with different sizes: u64 (64 bits) to u8 (8 bits)
[12:42:11] -rusti- <anon>:1 extern mod extra;
[12:42:11] -rusti-          ^
[12:42:11] -rusti- application terminated with error code 101
[12:42:18] *** Joins: SiegeLord (sl@moz-1DF56822.twcny.res.rr.com)
[12:42:37] <kimundi> haha
[12:43:33] *** jorendorff is now known as jorendorff_away
[12:44:19] <dbaupp> cmr: git2-rs compiles with master \o/
[12:44:26] <flaper87> dbaupp: w000000t
[12:44:30] <flaper87> +1
[12:44:33] <dbaupp> flaper87: don't be happy
[12:44:40] * flaper87 is unhappy again
[12:44:40] <dbaupp> it's a horrible horrible update
[12:44:42] *** AutomatedTester is now known as AutomatedTester|away
[12:44:47] * dbaupp just applied transmute
[12:45:03] <bstrie> dbaupp: bindings?
[12:45:08] <bstrie> or did you reimplement the whole thing :P
[12:45:16] <nmatsakis> is there a range_rev or something like that?
[12:45:17] <bstrie> one of those is more exciting than the other!
[12:45:26] <dbaupp> bstrie: bindings
[12:45:34] <dbaupp> nmatsakis: range(0, 10).invert() should work
[12:45:35] <bstrie> nmatsakis: how about range(0, 10).invert()
[12:45:39] <bstrie> dammit dbaupp
[12:45:44] <cmr> dbaupp: awesome!
[12:45:58] <dbaupp> rusti: for i in range(0, 10).invert() { print!("{} ", i) }
[12:45:59] -rusti- 9 8 7 6 5 4 3 2 1 0 ()
[12:46:01] <nmatsakis> ah
[12:46:01] <nmatsakis> ok
[12:48:07] <doomlord> is there a function 'reverse' doing something different to 'invert'
[12:48:13] <bstrie> doomlord: don't think so
[12:48:41] <bstrie> rusti: for i in range(0, 10).reverse() { print!("{} ", i) }
[12:48:44] -rusti- pastebinned 11 lines of output: http://ix.io/81B
[12:48:51] <nmatsakis> I think reverse mutates the thing you are iterating over
[12:49:03] <kimundi> doomlord: reverse is a confusing name, because you can already iterate over an DoubleEndedIterator from the back
[12:49:11] <nmatsakis> I just spent some time looking for invert withou tknowing its name before swallowing my pride and asking on the channel ;)
[12:49:35] <kimundi> inverse just switches next() and next_back(), it inverts the iterator if you will
[12:49:40] * nmatsakis surprised at how out-of-touch he is with how to write Rust ;)
[12:49:44] <bstrie> so wait, does reverse exist?
[12:49:55] <nmatsakis> I saw something named reverse_()
[12:50:06] <bstrie> nmatsakis: now you can appreciate how everyone else in the world feels :)
[12:50:21] *** jorendorff_away is now known as jorendorff
[12:50:32] <doomlord> (am i imagining this?) in clojure they have an interseting tool where you submit input and output, and it tries all the functions until it finds one that does that
[12:50:49] <nmatsakis> rusti: let mut x = ~[1,2,3]; x.mut_iter().reverse_(); x
[12:50:49] -rusti- ~[3, 2, 1]
[12:50:51] <nmatsakis> bstrie: ^
[12:50:52] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[12:50:52] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 147bcb0b2 to 147c8f503: 02http://git.io/N3iJvQ
[12:50:52] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[12:50:55] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[12:50:55] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/SwzZhA
[12:50:55] <ghrust> 13rust/06auto 143924cb0 15klutzy: std::rt::io: Fix file I/O on Win32...
[12:50:55] <ghrust> 13rust/06auto 1445ba3c2 15bors: auto merge of #9165 : klutzy/rust/newrt-file-fix, r=sanxiyn...
[12:50:55] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[12:51:02] <bstrie> aha
[12:51:40] <bstrie> doomlord: haskell has a search engine where you can type in a type signature and find functions that match, is that the same thing?
[12:51:45] <doomlord> i imagine some sort of cloud based duplicate code detector.. write a function , submit it to a database and it tells you what other submissions have the same name, with what frequency (like voting on what something could be called..)
[12:52:14] <doomlord> hoogle's is smarter i think, this clojure thing was quite brute force but facititated by its literal syntax i think
[12:52:45] <bstrie> is clojure dynamically typed?
[12:52:54] <doomlord> i think the fact clojure has something quite close to json made it easy to do there ... yes its like other lisps
[12:53:00] *** Joins: Palmik (palmik@moz-CC484FDD.tmcz.cz)
[12:53:47] <doomlord> its like lisp , but with [vectors ] and { maps }  .... and has json style literals but with a concept of 'keywords' different to strings. (like unquoted keys)
[12:53:49] <bstrie> we could probably do better than brute force... if you gave such a tool an (input, output) tuple like (1, [1,2,3]), first it could narrow the search drastically by inferring the type and matching the type signature like hoogle
[12:53:57] <cmr> hoogle searches by type signature.
[12:54:11] <cmr> It'd be really easy to do with rustdoc_ng, fwiw
[12:54:19] <dbaupp> <3 hoogle
[12:54:21] <doomlord> i really like the idea of these sort of tools generally.. searchnig code is hard, whatever documentatin you have..
[12:54:25] <Amaranth> Speaking of C strings, I've got a char* (so *i8) from C that is memory I own and I have no idea how to get it into a ~str
[12:54:30] *** jorendorff is now known as jorendorff_away
[12:54:47] <dbaupp> Amaranth: str::raw::from_c_str
[12:54:49] *** jorendorff_away is now known as jorendorff
[12:54:58] <dbaupp> *std::str::raw::from_c_str
[12:54:59] <Amaranth> Oh, it's under raw
[12:55:13] <doomlord> another intresting means of search would be functoin and inverse pairs (i realise its not universally aplicable)
[12:55:13] <bstrie> wait wait wait... char in C is i8 rather than u8?
[12:55:37] <Earnestly> bstrie: The signage of char in C is implementation defined
[12:55:47] *** Joins: maik (maik@moz-3F2CDB33.dip0.t-ipconnect.de)
[12:55:52] <Earnestly> It can be unsigned or signed
[12:55:58] <kimundi> bstrie: It seems a lot of intgere-like types in the C family are signed per default
[12:56:04] <bstrie> I guess they can just ignore that sign bit, as far as ascii cares...
[12:56:25] <bstrie> Earnestly: how strange
[12:56:26] <bstrie> thanks
[12:56:30] <Amaranth> hmm, time to go look at the from_c_str implementation
[12:56:54] <Amaranth> Need to know if this is copying or not so I know what to do with the original
[12:57:06] <kimundi> It's probably copying
[12:57:07] <Earnestly> bstrie: your implementation will define it in limits.h
[12:57:38] <Earnestly> CHAR_MIN
[12:57:50] <kimundi> how... charming
[12:57:52] <Earnestly> gcc has -fsigned-char and -funsigned-char too
[12:58:01] *** Quits: Ralith (ralith@114DA04D.CD83ED0A.BCDF04A6.IP) (Ping timeout)
[12:58:22] <dbaupp> Amaranth: it is copying
[12:58:26] <Amaranth> Alright from_c_str does in fact copy so I can toss the original
[12:58:30] <Earnestly> "The implementation shall define char to have the same range, representation, and behavior as either signed char or unsigned char." -> "CHAR_MIN, defined in <limits.h>, will have one of the values 0 or SCHAR_MIN, and this can be used to distinguish the two options. Irrespective of the choice made, char is a separate type from the other two and is not compatible with either."
[12:58:31] <Amaranth> Oops too late :P
[12:59:16] <dbaupp> Amaranth: https://github.com/mozilla/rust/blob/master/src/libextra/rl.rs#L91 is an example of handling a c-str
[12:59:22] * dbaupp hopes that that's "safely"
[12:59:35] <kimundi> In short, using a char in C is a trinary decision ;)
[12:59:50] <Earnestly> heh
[13:00:59] <Amaranth> Why would you use char in C in a place where you actually care about the storage?
[13:05:33] <Amaranth> rusti: str::from_bytes(~[33])
[13:05:38] -rusti- pastebinned 11 lines of output: http://ix.io/81H
[13:05:57] <kimundi> rusti: ::std::str::from_utf8([33_u8]);
[13:05:58] -rusti- ()
[13:05:59] <kimundi> rusti: ::std::str::from_utf8([33_u8])
[13:06:00] -rusti- ~"!"
[13:06:08] <dbaupp> okaaaay, so now, how to I get git2-rs to link against libgit2? :S
[13:06:15] <Amaranth> Right so from_bytes is not a thing anymore, alright
[13:06:55] <bstrie> from_utf8 is a strange name... shouldn't it be from_codepoint or something?
[13:07:12] <bstrie> eh, I guess
[13:07:14] <kimundi> bstrie: No, why? It takes an utf8 encoded byte slice
[13:07:16] <bstrie> it's fine
[13:07:27] <kimundi> rusti: ::std::str::from_chars(['!'])
[13:07:28] -rusti- ~"!"
[13:07:42] <kimundi> that's from codepoint ;)
[13:07:54] <Amaranth> Hrm, this is tricky
[13:08:11] <kimundi> rusti: (~[33_u8]).into_str()
[13:08:11] -rusti- <anon>:5:9: 6:5 error: type `~[u8]` does not implement any method in scope named `into_str`
[13:08:12] -rusti- <anon>:5          (~[33_u8]).into_str()
[13:08:12] -rusti- <anon>:6     };
[13:08:12] -rusti- error: aborting due to previous error
[13:08:12] -rusti- application terminated with error code 101
[13:08:20] <Amaranth> I've got a [i8, ..32] in a struct and need to get a ~str
[13:08:45] <Amaranth> It started like in C as a char[32]
[13:08:50] <Amaranth> s/like/life/
[13:08:52] <kimundi> Amaranth: Slice as &[i8], call from_utf8 on it
[13:09:12] <kimundi> no wait
[13:09:15] <kimundi> wrong type
[13:09:15] *** Joins: Larry (larryfox@moz-343B6F0C.nyc.biz.rr.com)
[13:09:16] <kimundi> hmm
[13:09:30] <dbaupp> kimundi: ([, ..] autoslices too)
[13:10:05] <Amaranth> I gave up on this earlier and come up with some horrible code instead of finding some cast or function for it
[13:10:24] <kimundi> rusti: let v = [33_i8]; v.iter().map(|&b| b.to_u8().to_ascii().to_char()).collect::<~str>()
[13:10:25] -rusti- ~"!"
[13:10:46] <Amaranth> I was iterating until I found \0 and cloning the entries into a new ~[u8] I then gave to from_utf8
[13:11:02] <Amaranth> Which is basically what you did too
[13:11:12] <kimundi> rusti: let v = [33_i8, 33, 0, 0]; v.iter().map(|&b| b.to_u8().to_ascii().to_char()).collect::<~str>()
[13:11:13] -rusti- ~"!!\x00\x00"
[13:11:22] <Amaranth> Except I cannot do it on a per-byte basis, this is a utf8 string
[13:11:35] *** Quits: Larry (larryfox@moz-343B6F0C.nyc.biz.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[13:11:39] <kimundi> rusti: let v = [33_i8, 33, 0, 0]; v.iter().take_while(|&b| b != 0).map(|&b| b.to_u8().to_ascii().to_char()).collect::<~str>()
[13:11:40] -rusti- <anon>:5:66: 5:67 error: mismatched types: expected `&i8` but found `<VI3>` (expected &-ptr but found integral variable)
[13:11:40] -rusti- <anon>:5          let v = [33_i8, 33, 0, 0]; v.iter().take_while(|&b| b != 0).map(|&b| b.to_u8().to_ascii().to_char()).collect::<~str>()
[13:11:40] -rusti-                                                                            ^
[13:11:40] -rusti- error: aborting due to previous error
[13:11:41] -rusti- application terminated with error code 101
[13:11:48] *** Joins: brianm (brianm@F373E0CF.608C5766.3EA5C10B.IP)
[13:11:55] <kimundi> rusti: let v = [33_i8, 33, 0, 0]; v.iter().take_while(|&b| b != 0).map(|& &b| b.to_u8().to_ascii().to_char()).collect::<~str>()
[13:11:59] -rusti- pastebinned 8 lines of output: http://ix.io/81I
[13:12:43] <kimundi> rusti: let v = [33_i8, 33, 0, 0]; v.iter().take_while(|b| (**b) != 0i8).map(|& &b| b.to_u8().to_ascii().to_char()).collect::<~str>()
[13:12:44] -rusti- <anon>:5:81: 5:83 error: mismatched types: expected `i8` but found an &-pointer pattern
[13:12:44] -rusti- <anon>:5          let v = [33_i8, 33, 0, 0]; v.iter().take_while(|b| (**b) != 0i8).map(|& &b| b.to_u8().to_ascii().to_char()).collect::<~str>()
[13:12:44] -rusti-                                                                                           ^~
[13:12:44] -rusti- error: aborting due to previous error
[13:12:45] -rusti- application terminated with error code 101
[13:12:51] <kimundi> urg
[13:12:56] <kimundi> rusti: let v = [33_i8, 33, 0, 0]; v.iter().take_while(|b| (**b) != 0i8).map(|&b| b.to_u8().to_ascii().to_char()).collect::<~str>()
[13:12:57] -rusti- ~"!!"
[13:13:18] * kimundi got the two closures confused
[13:13:46] <kimundi> Amaranth: Is the C string utf8 orn ascii?
[13:13:54] <Amaranth> utf8
[13:14:08] <mindcat> now, I will waiting for Rust 1.0 for develop projects. :(
[13:14:13] *** Joins: Larry (larryfox@moz-343B6F0C.nyc.biz.rr.com)
[13:14:25] <kimundi> rusti: let v = [33_i8, 33, 0, 0]; v.iter().take_while(|b| (**b) != 0i8).map(|b| b.to_u8()).collect::<~str>()
[13:14:28] -rusti- pastebinned 14 lines of output: http://ix.io/81J
[13:14:34] <dbaupp> cmr: ok; it looks like this will be unworkable for now :(
[13:15:10] * kimundi wonders if there is a way to go Iterator<u8> -> str directly...
[13:15:34] <kimundi> rusti: let v = [33_i8, 33, 0, 0]; v.iter().take_while(|b| (**b) != 0i8).map(|b| b.to_u8()).collect::<~[u8]>().into_str()
[13:15:34] -rusti- <anon>:5:36: 6:5 error: type `~[u8]` does not implement any method in scope named `into_str`
[13:15:35] -rusti- <anon>:5          let v = [33_i8, 33, 0, 0]; v.iter().take_while(|b| (**b) != 0i8).map(|b| b.to_u8()).collect::<~[u8]>().into_str()
[13:15:35] -rusti- <anon>:6     };
[13:15:35] -rusti- error: aborting due to previous error
[13:15:35] -rusti- application terminated with error code 101
[13:15:47] *** Quits: jfbk (jfbk@moz-EEA9CFB3.nyc.res.rr.com) (Quit: )
[13:15:52] <kimundi> okay, Need to implement into_str for ~[u8] now :P
[13:16:01] * mindcat tarot tell him, develop minecraft server wrapper with rust will go bad.
[13:16:19] <kimundi> haha
[13:16:36] <kimundi> well, if you only wrap the input output of the java process, it might work
[13:16:53] <flaper87> oh lord
[13:16:59] <flaper87> O.O
[13:17:27] <Amaranth> mindcat: CraftBukkit, screen, cron
[13:17:31] <Amaranth> No need for a "wrapper"
[13:18:02] <dbaupp> Amaranth: I don't see any Rust in that list of software; clearly we need a wrapper. :P
[13:18:06] <mindcat> Amaranth: what about remote control?
[13:18:08] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[13:18:18] *** Joins: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP)
[13:18:19] <Amaranth> mindcat: ssh
[13:18:49] *** Quits: brianm (brianm@F373E0CF.608C5766.3EA5C10B.IP) (Quit: Linkinus - http://linkinus.com)
[13:18:51] <mindcat> Amaranth: oh yes, what about server hosting
[13:19:02] <Amaranth> mindcat: ssh
[13:19:32] <Amaranth> Don't make everyone's tool, make your tool
[13:19:44] <Amaranth> Do you run a minecraft hosting provider?
[13:20:19] *** Joins: mib_a8yiwm (Mibbit@DF2B4230.C274A490.6D7EF8AA.IP)
[13:20:24] <mindcat> Amaranth: Yes, but I am a administrator
[13:20:43] *** jorendorff is now known as jorendorff_away
[13:22:42] *** Quits: Liothen (liothen@moz-80EF0CD7.spkn.qwest.net) (Quit: Textual IRC Client: www.textualapp.com)
[13:23:24] <kimundi> rusti: [1i8].to_str()
[13:23:24] -rusti- ~"[1]"
[13:23:28] *** Quits: squiddy (squiddy@moz-D37EFEA9.adsl.alicedsl.de) (Ping timeout)
[13:24:10] <kimundi> rusti: let v = [33_i8, 33, 0, 0]; ::std::str::from_utf8_owned(v.iter().take_while(|b| (**b) != 0i8).map(|b| b.to_u8()).collect::<~[u8]>())
[13:24:10] -rusti- ~"!!"
[13:24:19] *** Joins: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[13:25:29] <Amaranth> rusti: let v = [0xf0_i8, 0xa4, 0xad, 0xa2]; ::std::str::from_utf8_owned(v.iter().take_while(|b| (**b) != 0i8).map(|b| b.to_u8()).collect::<~[u8]>())
[13:25:36] -rusti- pastebinned 5 lines of output: http://ix.io/81K
[13:25:39] <Amaranth> Oh, I forgot the trailing nul
[13:25:55] <Amaranth> rusti: let v = [0xf0_i8, 0xa4, 0xad, 0xa2, 0]; ::std::str::from_utf8_owned(v.iter().take_while(|b| (**b) != 0i8).map(|b| b.to_u8()).collect::<~[u8]>())
[13:25:57] -rusti- pastebinned 5 lines of output: http://ix.io/81L
[13:26:14] <Amaranth> Nope, apparently that isn't it
[13:26:16] <kimundi> Hm, once we get a encoding framework we need to add methods like this: [33_i8, 33].decode_as_utf8(), [33_i8, 33].decode_to_utf8(), [33_i8, 33].decode_into_utf8()
[13:27:48] <kimundi> Amaranth: your first byte is an invalid literal
[13:27:52] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[13:28:08] <kimundi> rusti: 0xfo_u8
[13:28:08] -rusti- <anon>:5:12: 5:16 error: expected one of `; }` but found `o_u8`
[13:28:09] -rusti- <anon>:5          0xfo_u8
[13:28:09] -rusti-                      ^~~~
[13:28:09] -rusti- application terminated with error code 101
[13:28:17] <kimundi> rusti: 0xf0_u8
[13:28:18] -rusti- 240u8
[13:28:23] *** Quits: mib_a8yiwm (Mibbit@DF2B4230.C274A490.6D7EF8AA.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[13:28:24] <kimundi> rusti: 0xf0_u8 as i8
[13:28:25] -rusti- -16i8
[13:28:46] <kimundi> rusti: let v = [0x-10_i8, 0xa4, 0xad, 0xa2, 0]; ::std::str::from_utf8_owned(v.iter().take_while(|b| (**b) != 0i8).map(|b| b.to_u8()).collect::<~[u8]>())
[13:28:48] -rusti- pastebinned 4 lines of output: http://ix.io/81M
[13:28:57] <kimundi> rusti: let v = [-0x10_i8, 0xa4, 0xad, 0xa2, 0]; ::std::str::from_utf8_owned(v.iter().take_while(|b| (**b) != 0i8).map(|b| b.to_u8()).collect::<~[u8]>())
[13:28:58] -rusti- ~"\U00024b62"
[13:29:21] <kimundi> rusti: let v = [-0x10_i8, 0xa4, 0xad, 0xa2, 0]; let o = ::std::str::from_utf8_owned(v.iter().take_while(|b| (**b) != 0i8).map(|b| b.to_u8()).collect::<~[u8]>()); println(o);
[13:29:22] -rusti- ð¤­¢
[13:29:22] -rusti- ()
[13:29:45] <kimundi> And the vector doesn't need to be null terminated btw
[13:30:06] <Amaranth> Hey I didn't design the API
[13:30:14] <kimundi> hm?
[13:30:24] <kimundi> which api?
[13:30:27] <Amaranth> The vector is null terminated because that's how SDL2 works
[13:30:41] <Amaranth> Or did you mean something else?
[13:31:03] <kimundi> I meant that the vector you pass to from_utf8_owned doesn't need to be null terminated
[13:31:12] <Amaranth> Ah
[13:31:50] *** Joins: c0dege3k (Mibbit@moz-5033CA39.main.ad.rit.edu)
[13:31:58] <kimundi> which, however, is irrelvant here I see :P
[13:32:22] * kimundi already forgot that he wrote the iterator chain in a way that removes all trailing nullls...
[13:33:12] <kimundi> Amaranth: Do you know if SDL just doesn't allow any interior nulls, or whether it encodes them with an overlong encoding?
[13:33:25] <Amaranth> No idea
[13:33:37] <Amaranth> Don't most things just not allow them?
[13:33:56] <kimundi> valid utf8 can contain interior nulls
[13:34:10] <kimundi> which also means it's not possible to use null termination with valid utf8
[13:34:21] <Amaranth> Do you mean it is allowed to use them or that some other characters can contain them?
[13:35:08] <kimundi> utf8 is designed in such a way that no character contains an null byte except null itself
[13:35:19] <kimundi> It is allowed to use them
[13:35:30] <kimundi> "\0\0\0" is a completely valid utf8 string
[13:35:48] <SiegeLord> UTF8 strings without nulls in them are also valid :P
[13:36:13] <Amaranth> kimundi: Right so afaik most things just don't allow them
[13:36:18] <Amaranth> Because they break null terminated strings
[13:36:33] <kimundi> Amaranth: Right, but that also means that they don't support utf8 :P
[13:36:34] <SiegeLord> So you can use null termination just fine, if you want... with the caveat that not all valid UTF8 strings are representable
[13:37:22] <Amaranth> I can't imagine a time I'd ever want a string of utf8 text and also have nulls but hey, if you can support them neat
[13:37:54] <dbaupp> there is a modification of utf8 that represents \x00 as two bytes
[13:38:16] *** Joins: steveh (Mibbit@moz-7A900440.fda.gov)
[13:38:40] <dbaupp> neither of which is 0, that form supports null termination perfectly
[13:38:59] <kimundi> You can claim to use 'modified utf8', like java - interior null bytes get encoded as two non-null bytes - but thats not normal utf8
[13:39:22] <bstrie> is \0 a valid char in ascii? so then C doesn't actually support ascii either :P
[13:39:30] <kimundi> bstrie: correct
[13:39:38] <kimundi> a c string is NOT ascii :P
[13:39:53] <kimundi> http://en.wikipedia.org/wiki/UTF-8#Modified_UTF-8
[13:41:51] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Connection reset by peer)
[13:42:02] <kimundi> http://en.wikipedia.org/wiki/Null-terminated_string
[13:42:12] <SiegeLord> Just because you can't represent every UTF8 string in a null encoded string, doesn't mean every null encoded string is not UTF8 :P
[13:42:22] *** jorendorff_away is now known as jorendorff
[13:42:31] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[13:43:07] <SiegeLord> *null terminated
[13:43:12] <kimundi> SiegeLord: Of course not, but it means the system doesn't accept every utf8 encoded string, and is therefore not fully utf8 compliant
[13:43:42] *** Quits: ged (deveiant@moz-610E9711.org) (Ping timeout)
[13:44:09] *** Joins: ahal (ahal@FCCEA34F.7672369.D8E68FF6.IP)
[13:44:17] *** Joins: ged (deveiant@moz-610E9711.org)
[13:44:24] *** Joins: bent (chatzilla@moz-6F843AD8.static.cust.telenor.com)
[13:44:28] <kimundi> My point is, you need to know what encoding exactly you're dealing with before converting to/from it
[13:45:03] <kimundi> In this case, going SDL string -> utf8 seems to be no problem. But other way round would need a check for interior nulls
[13:45:39] <Amaranth> phew
[13:46:00] <Amaranth> Well, I've got all (but one) of the SDL2 events implemented and enough API around them to poll for events and read the data from them
[13:46:10] <kimundi> nice :)
[13:46:15] <Amaranth> Now to wait for AngryLawyer to tell me everything I did wrong
[13:46:19] <SiegeLord> That also depends on the API... it could take a const char*, size_t len
[13:46:54] <Amaranth> The pain with SDL2 strings is actually because they're trying to solve the input problem for you
[13:46:58] <kimundi> Amaranth: Just curious, what is the name of the api sdl uses for the string your dealing with? Want to google how exactly they tread utf8
[13:47:09] <Amaranth> SDL 1.x just had a key event and it was up to you to figure out what to do with the key presses you got
[13:47:48] <Amaranth> SDL2's key event is used to treat the keyboard as a joystick with 100 or so buttons and has a text input event that gives strings
[13:47:57] <SiegeLord> Allegro gives you the unichar, and doesn't bother with strings :P
[13:48:03] *** Joins: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP)
[13:48:08] <Amaranth> SiegeLord: That's how SDL 1.x worked
[13:48:21] <SiegeLord> SDL 1.x supported the compose key?
[13:48:40] <Amaranth> kimundi: API? You mean http://wiki.libsdl.org/SDL_TextInputEvent ?
[13:49:02] <kimundi> Yeah, jst needed a function name :P
[13:49:14] <Amaranth> SiegeLord: Not as anything but a key, you had to put things together
[13:49:21] *** AutomatedTester|away is now known as AutomatedTester
[13:49:22] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[13:49:22] <kimundi> Or, whatever that is. Something to start of reading docs from
[13:49:31] * kimundi never used sdl
[13:49:38] <Amaranth> That's why SDL2 has the dedicated event for "here is the text they typed" instead of just seeing the keys they pressed
[13:50:11] <kimundi> Okay, "The null-terminated input text in UTF-8 encoding" is a contradiction :P
[13:50:44] *** Joins: Sorella (queen@9D963F5D.DF5D8AE7.54BCAB54.IP)
[13:50:52] *** Quits: Sorella (queen@9D963F5D.DF5D8AE7.54BCAB54.IP) (Client exited)
[13:51:23] <Amaranth> kimundi: It may not be 100% correct but it is the way people expect utf8 to work in C
[13:51:26] <pnkfelix> anyone here know off-hand what an `_mh_execute_header` is, at the top of a stack trace?  I am assuming it has something to do with executing closures ...
[13:51:55] <SiegeLord> Not necessarily... it could mean a null-terminated sequence of unicode codepoints that are then encoded as UTF8
[13:52:06] <kimundi> Amaranth: That might be, but this channel has made me a bit overzealous about correctness ;)
[13:52:38] <Amaranth> Also it's hard to complain about it when utf8 was designed to be used like that
[13:52:43] <kimundi> SiegeLord: Ha! Bet no one would expect THAT :D
[13:52:47] <bstrie> kimundi: if you were overzealous about correctness there would be a period at the end of that sentence!
[13:52:50] <dbaupp> pnkfelix: http://stackoverflow.com/questions/12654235/what-is-mh-execute-header maybe?
[13:52:59] <kimundi> bstrie: pffff
[13:53:07] <pnkfelix> dbaupp: ah, thanks, here I was thinking it would be rust specific
[13:53:15] <kimundi> Amaranth: That's not how utf8 is to be used
[13:53:26] <bstrie> dbaupp: saves the day
[13:53:48] <Amaranth> kimundi: The point of utf8 is not having to change applications to use it
[13:53:49] <kimundi> Amaranth: The correct use would be to pass a pointer to the string, a length, and allow interior nulls
[13:54:01] <Amaranth> That is why utf8 exists
[13:54:24] <Amaranth> To then complain that people are doing just that so are missing a part of utf8 basically no one cares about seems excessive
[13:55:42] <kimundi> Amaranth: It's backward compatible to ascii, and a vast subset can be used in form of a null terminated byte string. But not allowing interior still makes it _not_ pure, official utf8. This might seem silly, but if you don't take such things in account there can be subtile bugs and security issues.
[13:56:04] <kimundi> harmless_file.jpg/0.exe
[13:57:10] <kimundi> "we use utf8" or "we use modified utf8 without interior nulls" - Just a simple matter of correctly documenting it
[13:57:21] *** Quits: c0dege3k (Mibbit@moz-5033CA39.main.ad.rit.edu) (Quit: http://www.mibbit.com ajax IRC Client)
[13:57:32] <Amaranth> It seems to me considering the history the library/program that allows internal nulls should be the one yelling loudly to everyone
[13:57:57] <kimundi> Amaranth: Sure, but that is an seperate issue
[13:58:12] *** Quits: pyrac (pyrac@moz-C411EA77.math.u-bordeaux1.fr) (Quit: pyrac)
[13:58:24] <Amaranth> kimundi: Well no, you just said everyone who doesn't allow them should announce it
[13:58:47] <Amaranth> You should assume they don't allow it unless they say otherwise, especially if they also say their string is null terminated
[13:59:11] <kimundi> It's certainly a bad idea to allow interior nulls, especial BECAUSE so much software uses null termination. But utf8 is defined as allowing them, so you need to have so sort of conversion step.
[13:59:30] *** Joins: pyrac (pyrac@moz-C411EA77.math.u-bordeaux1.fr)
[14:00:25] *** Quits: bent (chatzilla@moz-6F843AD8.static.cust.telenor.com) (Quit: ChatZilla 0.9.90.1-rdmsoft [XULRunner 22.0/20130619132145])
[14:00:37] <kimundi> Amaranth: The problem is, because "null terminated utf8" is a contradiction, people can't be sure if that means null just never appears in the string, null gets encoded as overlong sequence, or null just has been ignored by the implementor.
[14:00:57] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[14:00:57] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1445ba3c2 to 147c8f503: 02http://git.io/N3iJvQ
[14:00:57] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[14:00:59] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[14:00:59] <ghrust> 01[13rust01] 15bors pushed 21 new commits to 06auto: 02http://git.io/gVP2Ag
[14:00:59] <ghrust> 13rust/06auto 1445c62c0 15Erick Tryzelaar: std: rename Option::unwrap_or_default() to unwrap_or()
[14:00:59] <ghrust> 13rust/06auto 14653400a 15Erick Tryzelaar: std: add default implementations to HashMap
[14:00:59] <ghrust> 13rust/06auto 144a73c8e 15Erick Tryzelaar: std: add default implementations to Option
[14:01:01] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[14:01:28] <Amaranth> kimundi: I honestly don't know that I've ever used anything that did the overlong sequence encoding
[14:01:36] *** Joins: lmandel (lmandel@13F2CEC5.7672369.D8E68FF6.IP)
[14:01:44] <kimundi> java does
[14:01:45] *** Quits: sk (sk@A7A9ED26.751D8A43.78DD174B.IP) (Ping timeout)
[14:02:03] <Amaranth> Java strings are UCS-2
[14:02:44] <kimundi> java uses modifierd utf8 for object serialisation
[14:03:32] <Amaranth> Ah, yet another Java case of there being several options available and Java choosing all of them :)
[14:04:19] <kimundi> indeed xD. It accepts interior nulls for utf8 reader/writer, but uses modified utf8 for object serialization.
[14:06:01] *** Joins: sk (sk@2CD9466.27A2FE54.78DD174B.IP)
[14:09:29] *** Joins: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca)
[14:09:35] *** Quits: jaen (jaen@FB01674D.56B727FE.4B52F012.IP) (Ping timeout)
[14:10:20] *** Joins: mib_cnckts (Mibbit@moz-6C393FDD.rev.numericable.fr)
[14:10:30] *** Quits: maik (maik@moz-3F2CDB33.dip0.t-ipconnect.de) (Ping timeout)
[14:10:36] <mib_cnckts> hi guys, what's the difference between function and macro?
[14:10:52] *** Joins: kvark (Mibbit@9A8A5739.49975FB2.AE2D72A6.IP)
[14:10:55] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[14:10:56] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14a6d3b27 to 147c8f503: 02http://git.io/N3iJvQ
[14:10:56] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[14:10:56] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[14:10:56] <ghrust> 01[13rust01] 15bors pushed 22 new commits to 06auto: 02http://git.io/Qme_xQ
[14:10:56] <ghrust> 13rust/06auto 1445c62c0 15Erick Tryzelaar: std: rename Option::unwrap_or_default() to unwrap_or()
[14:10:56] <ghrust> 13rust/06auto 14653400a 15Erick Tryzelaar: std: add default implementations to HashMap
[14:10:57] <ghrust> 13rust/06auto 144a73c8e 15Erick Tryzelaar: std: add default implementations to Option
[14:10:59] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[14:11:48] <kimundi> mib_cnckts: A function is macine code, a macro transorms syntax
[14:12:04] <kimundi> machine* transforms*
[14:13:16] <mib_cnckts> kimundi: a macro is a sort of preprocessor function?
[14:13:35] <Yoric> mib_cnckts: Indeed.
[14:13:46] <glyc> mib_cnckts: http://en.wikipedia.org/wiki/Macro_%28computer_science%29#Syntactic_macros
[14:13:50] <kimundi> Except it's not really a preporccessor
[14:14:02] <kimundi> we don'T just simply transform text
[14:14:34] *** Quits: ivan (ivan@moz-531C3EC9.members.linode.com) (Ping timeout)
[14:14:38] <kvark> kimundi: where is the info/documentation on available macros? (like assert!, assert_eq!, fail!, etc)
[14:15:01] <mib_cnckts> it's smarter I see it, C preprocessor doesn't take functions
[14:15:06] <mib_cnckts> damnit that's great
[14:15:53] *** Quits: wting (wting@4F978BD6.5564A9BA.9510F13D.IP) (Quit: leaving)
[14:16:01] *** Quits: glyc (Mibbit@moz-20CEEF38.hsd1.ca.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[14:17:36] <kimundi> kvark: syntax::expand, and look for a bif fat string that contains rust code...
[14:17:48] *** Joins: wting (wting@4F978BD6.5564A9BA.9510F13D.IP)
[14:17:51] *** Quits: achin (achin@moz-193F7FAD.ri.ri.cox.net) (Ping timeout)
[14:18:07] *** Quits: mib_cnckts (Mibbit@moz-6C393FDD.rev.numericable.fr) (Quit: http://www.mibbit.com ajax IRC Client)
[14:18:13] <kimundi> libsyntax/ext/expand.rs
[14:18:13] <kvark> kimundi: where is that? I was hoping for a link or something...
[14:18:14] *** Joins: jgilbert (jgilbert@40BD3B76.2AD327F9.973C8D27.IP)
[14:18:28] <kvark> oh, so it's only in the source
[14:18:36] <kimundi> right
[14:18:53] <kvark> is it possible to get a call stack from a failed assertion?
[14:19:05] <kimundi> you can look at it on github of course :)
[14:19:29] <kvark> I am looking at it, thanks for the pointer :)
[14:19:56] <pnkfelix> kvark: I think this would do the trick: gdb --ex "catch throw"
[14:20:05] *** Joins: ivan (ivan@moz-531C3EC9.members.linode.com)
[14:20:51] <dbaupp> kvark: you can break on `rust_begin_unwind` too
[14:21:26] <kvark> pnkfelix: last time I used gbd the symbols were not resolved properly. Are the symbols good now right out of the box?..
[14:21:47] <pnkfelix> kvark: depends on what you mean by "out of the box." â€¦ and also "good" ...
[14:21:55] <kvark> dbaupp: can I do that with a stock rust? (not a compiled one)
[14:22:25] <dbaupp> kvark: are you using 0.7?
[14:22:35] <pnkfelix> kvark: I mostly do it with a rustc I've built myself with â€”enable-debug.  I cannot speak for how stock builds behave.
[14:22:41] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[14:23:11] <kvark> pnkfelix: ideally, I'd like to see function names and parameter values. That would be good. And by "out of the box" I mean using the stock rust with no additional compile parameters.
[14:23:17] <dbaupp> pnkfelix: (`--enable-debug` just enabled `debug!` statements at the moment; nothing about debug symbls yet, btw.)
[14:23:26] <dbaupp> *enables
[14:23:35] *** Joins: Skif (emschwar@moz-CA025D57.ip.mcleodusa.net)
[14:23:43] <kvark> dbaupp: I'm on 0.6 and waiting to jump on 0.8 when it's out.
[14:24:01] <pnkfelix> dbaupp: â€¦ I could have sworn I've seen different behaviors in gdb with and without â€”enable-debug, but maybe I'm wrong.
[14:24:55] <flaper87> kvark: 0.6 -> 0.8 sounds like a BIG jump!
[14:25:27] <kvark> flaper87: would you advise to jump gradually?
[14:26:08] <kvark> I figured that the iterators work was still in progress, so I'd better jump on the train when it's done...
[14:26:08] <Amaranth> More work overall trying to keep up with master but easier work since you can see right when something breaks and go look at the change for an idea on how to update
[14:26:20] <dbaupp> pnkfelix: maybe it got changed since I last looked?
[14:26:43] <pnkfelix> dbaupp: or maybe i'm wrong, or there's some other platform dependence here?  (I'm on Mac OS X, dunno 'bout you)
[14:26:52] <dbaupp> pnkfelix: linux
[14:26:53] <kvark> Amaranth: oh, you are talking about keeping up with master... that's beyond my time threshold :)
[14:27:25] <dbaupp> pnkfelix: `  CFG_RUSTC_FLAGS += --cfg debug  CFG_GCCISH_CFLAGS += -DRUST_DEBUG`
[14:28:07] <dbaupp> pnkfelix: the --cfg debug flag just does `debug!` I think, so maybe it's the C/++ libraries being affected by RUST_DEBUG?
[14:28:13] *** Quits: hoverbear (andrew@moz-86FCBF4B.gv.shawcable.net) (Quit: hoverbear)
[14:28:31] <dbaupp> kvark: i believe one can break on `rust_upcall_fail` in 0.6
[14:28:49] <flaper87> kvark: not sure when 0.8 will be released. If it's not that far away I'd say yeah, wait and make that big jump. Otherwise, I'd say gradually 
[14:29:03] <dbaupp> flaper87: due at the being of october
[14:29:08] <dbaupp> *beginning
[14:29:10] <pnkfelix> dbaupp: I don't know.
[14:29:15] <flaper87> dbaupp: oh, thakns for that
[14:29:17] *** Joins: Ralith (ralith@A8995AA9.62B6AF6A.922221DB.IP)
[14:29:37] <flaper87> kvark: erm, then wait 'til october
[14:29:49] <flaper87> kvark: but, since it's almost there, you could actually start changing things now
[14:30:02] <kvark> dbaupp: hmm that's a bit late... not that I'm pushing or anything but I thought you were aiming for 1.0 still in 2013...
[14:30:25] <flaper87> are there any other breaking changes about to land for 0.8 ?
[14:30:41] * flaper87 has to catch up with triaging, bugs and stuff
[14:31:00] <dbaupp> kvark: october is in 2 weeks, right?
[14:31:23] <kvark> oh, maybe, I'm loosing track of time... still want to believe it's summer out there :)
[14:31:38] *** Quits: a__ (a__@moz-25043B93.nycmny.fios.verizon.net) (Client exited)
[14:31:47] <dbaupp> kvark: (in any case, 1.0 is pretty nebulous and I'm not even close to a core-dev, so I'm not one to be asking about milestones like that :) )
[14:31:53] *** Quits: victorporof (victorporo@FBDAE982.F9BD9D78.9B1E38F4.IP) (Ping timeout)
[14:31:55] <bstrie> I like to imagine that kvark is secretly wintering at the amundson-scott research station at the south pole
[14:31:56] <olsonjeffery> argh. the agony of setting up a new system.
[14:32:07] <olsonjeffery> have to get p4merge installed so i can deal with a merge conflict.
[14:32:19] *** Joins: victorporof (victorporo@6CCF2761.6F48C38B.3EA6AAD8.IP)
[14:32:36] <kvark> bstrie: your sense of humor is always greatly appreciated!
[14:32:51] <olsonjeffery> is there adate for a code/feature freeze or is 0.8 going to be another snapshot of master?
[14:33:00] <olsonjeffery> at some arbitrary point
[14:33:04] *** Joins: a__ (a__@moz-25043B93.nycmny.fios.verizon.net)
[14:33:28] <dbaupp> bstrie: south pole? winter now?
[14:33:32] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[14:33:39] <dbaupp> oh
[14:33:44] * dbaupp really should go to bed
[14:33:47] *** Quits: ahal (ahal@FCCEA34F.7672369.D8E68FF6.IP) (Ping timeout)
[14:34:02] <bstrie> dbaupp: actually I think it's summer there now, but sssshhh
[14:34:10] <bstrie> the joke doesn't work otherwise
[14:34:17] <olsonjeffery> would be heading into spring..iirc
[14:35:09] <dbaupp> yes, spring in the southern hemisphere atm.
[14:35:44] <kvark> as on off-topic, I've been solving Project Euler tasks as well as Matasano Crypto challenge in Rust-0.7 (using web compiler...). It's joy, I strongly recommend to anyone interested in algorithms/math and having a bit of time.
[14:36:12] <bstrie> kvark: I really really want to... but I have no idea what the crypto challenges entail
[14:36:22] <dbaupp> bstrie: then just do project euler
[14:36:32] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[14:36:35] *** Quits: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[14:37:14] <kvark> bstrie: no base knowledge required, really, and you can google terms anyway. What I like about both is that there is no time pressure. It's when the answers appear next morning after the day you've been trying to crack the problems...
[14:37:31] *** Quits: sk (sk@2CD9466.27A2FE54.78DD174B.IP) (Quit: Leaving)
[14:37:32] <pnkfelix> dbaupp: maybe I'm just satisfied that my binaries aren't stripped, so there are symbols there, even without file/line numbers?  That's actually probably the most sane answer to this dialogue.
[14:38:09] <dbaupp> pnkfelix: yeah; having no symbols would be horrible
[14:39:16] *** Joins: Scriptor (historium@moz-E06F46F0.corp.bitshelter.com)
[14:39:24] * pnkfelix has spent too many hours on other projects struggling to match debug-info with a stack trace from a stripped binary, or configuring symbol servers, etc.
[14:43:05] *** Quits: a__ (a__@moz-25043B93.nycmny.fios.verizon.net) (Client exited)
[14:43:38] *** Joins: ahal (ahal@FCCEA34F.7672369.D8E68FF6.IP)
[14:44:09] *** Joins: a__ (a__@moz-25043B93.nycmny.fios.verizon.net)
[14:47:06] *** Joins: adridu59 (Mibbit@moz-6C393FDD.rev.numericable.fr)
[14:47:25] <luisbg> morning people :)
[14:47:28] *** Joins: maik (maik@moz-3F2CDB33.dip0.t-ipconnect.de)
[14:47:33] <adridu59> anyone experienced with inline asm? I have seen an old PR about that but is it fully supported?
[14:48:12] *** Quits: pyrac (pyrac@moz-C411EA77.math.u-bordeaux1.fr) (Quit: pyrac)
[14:48:34] *** Quits: a__ (a__@moz-25043B93.nycmny.fios.verizon.net) (Client exited)
[14:49:35] *** Joins: a__ (a__@moz-25043B93.nycmny.fios.verizon.net)
[14:52:43] *** Joins: cstrahan (cstrahan@moz-71FAC30.hsd1.va.comcast.net)
[14:53:00] *** Quits: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Ping timeout)
[14:54:49] <bjz> adridu59: I think Luqman was the dude who implemented it
[14:55:52] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[14:55:53] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 140037f8f to 147c8f503: 02http://git.io/N3iJvQ
[14:55:53] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[14:56:56] *** Joins: eholk (eholk@2066C4B2.51779FFC.284344F5.IP)
[14:57:33] <adridu59> bjz: yup #5317 and #5593, it support both AT&T and Intel which is cool, I'll play around with it later
[14:58:41] *** Joins: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP)
[15:03:31] *** Quits: fyolnish (fyolnish@moz-A2FCAB7C.uqwimax.jp) (Client exited)
[15:04:06] *** Quits: eholk (eholk@2066C4B2.51779FFC.284344F5.IP) (Ping timeout)
[15:04:11] *** Joins: zeuxcg (zeuxcg@moz-80D1F912.hsd1.ca.comcast.net)
[15:05:50] *** Quits: adridu59 (Mibbit@moz-6C393FDD.rev.numericable.fr) (Quit: http://www.mibbit.com ajax IRC Client)
[15:06:26] <kimundi> Amaranth: Send an word bug report to SDL ;) - https://bugzilla.libsdl.org/show_bug.cgi?id=2097
[15:06:30] <kimundi> wordy*
[15:07:12] *** Joins: geal (geal@moz-615D228A.unhandledexpression.com)
[15:07:40] *** Joins: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net)
[15:14:55] <Amaranth> kimundi: Neat
[15:15:01] <Amaranth> Their documentation in general is terrible
[15:15:09] <Amaranth> But it is a wiki so presumably you could fix it for them
[15:15:40] *** Quits: kvark (Mibbit@9A8A5739.49975FB2.AE2D72A6.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[15:16:12] <kimundi> Amaranth: Yeah, but it's more than just an doc issue
[15:17:06] <kimundi> I have no idea how the code actually handles nulls
[15:17:33] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[15:20:22] *** sam113101 is now known as sam113101_afk
[15:20:58] *** Joins: ChrisOei (Adium@moz-2B20A8E8.partechvc.com)
[15:22:45] *** Joins: jstevans (Instantbir@moz-735D8260.washdc.fios.verizon.net)
[15:27:33] *** Joins: Kruppe (user@CAB30FBD.8F96AEA7.2D179A7D.IP)
[15:28:37] <klutzy> bors seems in a sentimental mood
[15:28:54] <klutzy> is there any known issue on it?
[15:29:37] <klutzy> -> https://github.com/mozilla/rust/issues/9074
[15:32:07] *** Quits: cstrahan (cstrahan@moz-71FAC30.hsd1.va.comcast.net) (Ping timeout)
[15:32:40] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Client exited)
[15:32:50] *** Joins: cstrahan (cstrahan@moz-71FAC30.hsd1.va.comcast.net)
[15:34:44] <steveh> Anybody can help me figure out how what's wrong with my integration ffi calls?  Trying to eventually get a Rust fn called as integrand, though not directly. https://gist.github.com/scharris/6551997
[15:35:52] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[15:35:52] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 148ae9368 to 147c8f503: 02http://git.io/N3iJvQ
[15:35:52] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[15:35:53] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[15:35:53] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/5PnRiA
[15:35:53] <ghrust> 13rust/06auto 14d0462f0 15Alex Crichton: Improve the local_data docs slightly...
[15:35:53] <ghrust> 13rust/06auto 1428ad49b 15bors: auto merge of #9160 : alexcrichton/rust/local-data-docs, r=huonw...
[15:35:53] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[15:35:54] <steveh> Gist of it is, trying to pass a rust &fn as void*, then get it back, unwrap it, and call it.
[15:36:51] <klutzy> compile error or runtime err? :o
[15:37:17] <steveh> segfault, so I'm sure I'm not packaging/unwrapping  the &fn properly
[15:37:28] *** Quits: Kruppe (user@CAB30FBD.8F96AEA7.2D179A7D.IP) (Ping timeout)
[15:37:28] <kimundi> steveh: a &fn is a fat pointer of (*function pointer, *environment)
[15:38:05] *** Quits: jstevans (Instantbir@moz-735D8260.washdc.fios.verizon.net) (Ping timeout)
[15:38:22] <steveh> I *think* I may have gotten past that, because initially transmute complained about the fn was 128 bits wide, target void* was 64.  So I added an & :)
[15:38:46] <kimundi> okay, then you're transmuting an & &fn :)
[15:39:05] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[15:40:01] <steveh> kimundi: yea, so pointer to the two pointers I think
[15:40:07] <kimundi> right
[15:40:26] <klutzy> and c routine will call the position at *&fn
[15:40:35] <klutzy> which does not indicate the real function, so it will fail
[15:40:35] *** Joins: tgummerer (tgummerer@51D3B54.FEF996EA.EA6FEF3D.IP)
[15:40:38] *** sam113101_afk is now known as sam113101
[15:40:59] <kimundi> if you want an c function pointer you can call, you can'T use &fn
[15:41:20] <kimundi> not to use extern fn
[15:41:27] <klutzy> closures cannot be used for ffis afaik
[15:41:54] <steveh> kimundi & klutz: right, so the closure is called indirectly through a trampoline extern fn
[15:42:33] <steveh> I think I'm not unwrapping it properly from void*, I used &fn when receiving
[15:43:18] <steveh> klutzy: I think your onto it about *&fn.  I think I tried it and got an "attempt to move out" type error.
[15:45:10] <klutzy> unless you've done something dependent to rust, C function will accept arg (&&fn) as C function pointer
[15:45:38] <klutzy> and it will run `call <pos of &&fn>` asm where pos is just a pointer of (*rust-fn, *env)
[15:47:12] <klutzy> if you've called `f` at `hcubature`.
[15:47:24] <steveh> klutzy: OK I am passing as &&fn, can you clarify about the unwrapping/call though?  I tried calling via *f, it didn't like it ("attempt to move out...").
[15:48:36] *** Joins: Kruppe (user@CC0122E6.8F96AEA7.2D179A7D.IP)
[15:49:05] <steveh> "cannot move out of dereference of & pointer" on the *f, when receiving argument back as &(&fn(...)->f64).
[15:49:53] <erickt> dbaupp: thanks for the comments. Do you happen to know if we have a "bottom expr" that the Default syntax extension could return instead of some arbitrary expr?
[15:49:53] <klutzy> i meant *&fn for raw pointer of data structure which contains &fn
[15:50:09] <erickt> dbaupp: returning something arbitrary seems icky :)
[15:51:13] <klutzy> which is just the raw version of &&fn.
[15:51:22] <klutzy> steveh: what's happening inside hcubature?
[15:51:30] <kimundi> erickt: I see the os module has bitten you too ;)
[15:51:42] * erickt shakes fist at windows
[15:52:00] * kimundi shakes fist at OSX
[15:52:11] * erickt also shakes fist at all operating systems
[15:52:16] <steveh> klutzy: It's doing an integration over a region, and calling back to my extern fn, passing the true rust integrand &(&fn) back as "context object".  Nice of it to include the context obj, btw.
[15:52:25] *** Joins: ozten (ozten@moz-DD3B00B4.hsd1.wa.comcast.net)
[15:53:00] <steveh> klutzy: So extern fn is trying to unrwap the &(&fn) context obj and call it.  I think my unrwapping skills are at fault.
[15:53:20] <olsonjeffery> hey id like to put out the "rust signal", if you will, on a problem im dealing with.
[15:53:25] *** Joins: pyrac (pyrac@moz-C411EA77.math.u-bordeaux1.fr)
[15:53:33] <olsonjeffery> so i need to impl seek(2) functionality for rt::io::file in pure-rust
[15:54:12] <olsonjeffery> but libuv, the current backing impl, is totally seek-ignorant.. they use "positional streams" where you explicitly tell them where you want to read/write from/to
[15:54:37] <olsonjeffery> so i was hoping that adding bindings to libuv's stat abstraction would fix that (i could then could seek et al in pure rust because id know the file's size)
[15:55:05] *** Quits: pyrac (pyrac@moz-C411EA77.math.u-bordeaux1.fr) (Ping timeout)
[15:55:16] <erickt> nmatsakis: ping
[15:55:24] <olsonjeffery> well, doesn't work (at least in linux).. it gives the file's size on disk.. which will always be at least 4096 bytes (4K)
[15:55:27] <kimundi> steveh: I _think_ a stack closure is non copyable
[15:55:50] <olsonjeffery> i need to know a file's "real size", in bytes, to make SeekEnd work
[15:55:53] <olsonjeffery> which is kind of a show-stopper.
[15:56:10] <kimundi> rusti: let f: &fn() = ||(); let x = f; let y = f; (x, y)
[15:56:11] <olsonjeffery> on unix, we can cheat and use lseek, but it appears that it breaking the rt::file::io tests on windows
[15:56:17] *** Quits: maik (maik@moz-3F2CDB33.dip0.t-ipconnect.de) (Ping timeout)
[15:56:26] -rusti- pastebinned 8 lines of output: http://ix.io/81R
[15:56:34] <olsonjeffery> anyways. kind of frustrating.. short of perhaps reading the whole file, i don't know how i could approach this.
[15:56:36] <steveh> kimundi: Is it OK to just pass the pointer to stack closure down into a C routine, and unwrap it during callback from C?  I don't think any copying would be involved?
[15:56:48] <klutzy> steveh: my guess is: &fn is roughly a tuple of (ptr-to-fn, ptr-to-env), so after borrowing &fn, (here's a guess) the 'tuple' is destrucuted after callback.
[15:57:11] <erickt> olsonjeffery: does libuv's stat work like you want on windows? could you go with lseek on linux and libuv's stat on windows?
[15:57:19] <kimundi> steveh: The problem is that you can't dereference a & ptr
[15:57:30] <klutzy> I don't know much how &fn works though
[15:57:53] *** Joins: hoverbear (andrew@moz-DB93D497.wireless.uvic.ca)
[15:57:53] <kimundi> steveh: Or rather, if you dereference you get an implicit copy. If the type is not implicit copyable, it would be an move, but you can't move through an & ptr
[15:57:59] <olsonjeffery> erickt: well graydon and brson both wanted me to get away from using lseek, period.
[15:58:09] <olsonjeffery> and do seek, tell, etc all in pure-rust
[15:58:12] <erickt> gotcha
[15:58:27] <olsonjeffery> its something i want to resolve for 0.8
[15:58:32] <kimundi> steveh: Proposal: don't use & &fn, use * &fn, that is use directly an unsafe pointer
[15:58:35] <steveh> kimundi and klutzy: ok yall are making sense.  Really wanted to be able to do integrals with closures :(
[15:58:50] <erickt> olsonjeffery: without knowing much about libuv, is this something we could fix and push upstream?
[15:59:04] <olsonjeffery> erickt: no. they don't want to support seek(2) style APIs
[15:59:08] *** Quits: hoverbear (andrew@moz-DB93D497.wireless.uvic.ca) (Quit: hoverbear)
[15:59:10] <steveh> kimundi:  Ok I'll give it a try. Thx
[15:59:10] <olsonjeffery> they are strictly "positional"
[15:59:18] <olsonjeffery> ie pwrite, pread style APIs
[15:59:30] <olsonjeffery> which are meant to never use a cursor
[16:00:13] <olsonjeffery> for them its about parallel access to the same fd
[16:00:15] *** Quits: lmandel (lmandel@13F2CEC5.7672369.D8E68FF6.IP) (Quit: lmandel)
[16:00:18] <erickt> olsonjeffery: relevant PR from libuv: https://github.com/joyent/libuv/pull/664
[16:00:42] *** Quits: alex_abreu (alex@moz-7421D6C9.mc.videotron.ca) (Client exited)
[16:01:01] <olsonjeffery> erickt: yeah. ive spoken to them about it a few times in #libuv
[16:01:14] <olsonjeffery> and ben and burt's sentiments are pretty much echo'd in that PR
[16:01:49] <cmr> olsonjeffery: I agree that using the seek functions from libc is not-good, but using the syscalls would seem to be fine.
[16:02:29] <erickt> olsonjeffery: hrm. do we guarantee that only one thread can read from a file at a time?
[16:02:38] *** Joins: jeaye (Jeaye@moz-34FEF2BB.hsd1.ca.comcast.net)
[16:02:57] <olsonjeffery> erickt: no. we don't.
[16:03:04] <erickt> olsonjeffery: if not, wouldn't we need some way to lock the file to do the seek?
[16:03:07] <olsonjeffery> multiple fd's could be opened on different schedulers
[16:03:48] <olsonjeffery> cmr: that seems even worse!
[16:04:14] <olsonjeffery> cmr: although i should qualify that with saying: "which syscalls?"
[16:04:21] <cmr> olsonjeffery: lseek64, on linux
[16:04:23] <erickt> olsonjeffery: what's the official way to get the real file size?
[16:04:23] *** Joins: jdm (jdm@moz-BBE3ABD.mv.mozilla.com)
[16:04:23] *** ChanServ sets mode: +o jdm
[16:04:24] <olsonjeffery> also: multi-platform hell. yay...
[16:04:27] <cmr> dunno about the others
[16:04:36] <cmr> yeah, doing it through libuv would be best :p
[16:04:42] <olsonjeffery> erickt: don't know! that's why im asking :)
[16:04:44] <erickt> olsonjeffery: we're already in multi-platform hell. see my most recent PR :)
[16:04:50] <erickt> ah, hehe :)
[16:04:58] <olsonjeffery> erickt: yeah. i think we'll eventually converge on a pure-rust libuv on our own
[16:05:09] <olsonjeffery> in the process of implementing the "platform-backed" versions of everything in rt::io
[16:05:48] *** Joins: lmandel (lmandel@13F2CEC5.7672369.D8E68FF6.IP)
[16:05:48] <olsonjeffery> ie the idea of subbing out the "default" IoFactory you get from the scheduler (currently UvFactory from rt::uv::uvio) for one backed with platform-specific impls
[16:06:01] <olsonjeffery> posix/bsd sockets etc on *nix, win32 calls on windows
[16:06:04] <cmr> We guarantee that only a single *task* can access a single fd though, right?
[16:06:25] *** Joins: alex-abreu (alex@moz-7421D6C9.mc.videotron.ca)
[16:06:28] *** Joins: hoverbear (andrew@moz-86FE120E.wireless.uvic.ca)
[16:06:32] *** Quits: Larry (larryfox@moz-343B6F0C.nyc.biz.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[16:06:45] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[16:06:49] *** Parts: ozten (ozten@moz-DD3B00B4.hsd1.wa.comcast.net) ()
[16:06:55] <olsonjeffery> cmr: a single fd? unless the user purposely unpacks the structs to get at the gooey unsafe pointers inside, yet
[16:06:58] <olsonjeffery> yes*
[16:07:07] <cmr> well unsafe code is out of the question anyway
[16:07:21] <cmr> erickt: isn't that the question you actually meant to ask, when asking about threads?
[16:07:24] <cmr> I don't see us needing locking
[16:07:36] <olsonjeffery> cmr: i get the impression that you're trying to push the solution towards something heavily platform-dependant
[16:07:42] <olsonjeffery> and maybe thats neccesary for getting the true file size
[16:07:58] <cmr> olsonjeffery: Well, what platform-independant APIs do we have?
[16:08:05] *** Joins: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net)
[16:08:13] <olsonjeffery> but the problem of implementing seek(2) is narrow enough that i think following the sage council of graydon/brson in terms what the ultimate solution looksl ike (pure rust) is worth adherring to
[16:08:29] <cmr> probably
[16:08:51] <olsonjeffery> so i guess, yeah. time to read up on platform-specific solutions.
[16:08:59] <erickt> olsonjeffery: can't someone extract the integer fd and pass it between tasks?
[16:09:11] *** cade is now known as cade_away
[16:09:19] *** Quits: cdidd (cdidd@moz-3C61A716.broadband.corbina.ru) (Input/output error)
[16:09:36] <olsonjeffery> erickt: that's an unsafe operation
[16:09:48] <olsonjeffery> the handle is ultimately a *c_void
[16:09:58] <olsonjeffery> so, see cmr above
[16:10:07] <olsonjeffery> i mean, really. the whole io library is vulnerable to that sort of approach
[16:10:17] <olsonjeffery> but at that point, all assumptions have broken down
[16:10:58] <erickt> cmr: I mention locking because I assume that doing `fseek(file, 0, SEEK_END)` is atomic, whereas doing `get-file-size - seek-to-position` would need a mutex to make it automic
[16:11:13] <nmatsakis> erickt: pong
[16:11:32] <erickt> olsonjeffery: unless, of course, you are internally using pread and tracking the file position yourself. then you wouldn't need a mutex
[16:11:38] * mindcat ping, pong, ping, pong...
[16:11:52] *** Quits: z0w0 (zack@moz-61B3764E.qcl9.cha.bigpond.net.au) (Client exited)
[16:11:54] *** Quits: Kruppe (user@CC0122E6.8F96AEA7.2D179A7D.IP) (Ping timeout)
[16:12:12] <olsonjeffery> yeah.
[16:12:28] <olsonjeffery> we're binding to the libuv api's in such a way that its using pread/pwrite
[16:12:32] <olsonjeffery> and its equiv in win32
[16:12:45] <erickt> nmatsakis: I wanted to confirm something dbaupp said in a PR: https://github.com/mozilla/rust/pull/9115#discussion_r6341751
[16:12:49] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[16:14:16] <olsonjeffery> anways. in conclusion: file cursors are a land of contrasts
[16:14:45] <nmatsakis> erickt: it's a bit hard for me to interpret what's going on ---
[16:14:55] <nmatsakis> erickt: is that closure constructing a new copy of the same AST each time?
[16:15:18] *** Joins: cdidd (cdidd@moz-8A617D4E.broadband.corbina.ru)
[16:15:25] <erickt> nmatsakis: it's basically generating `let x = ~[Default::default(), Default::default(), ...]`
[16:15:33] <nmatsakis> erickt: it is true that you are now permitted to share AST trees that would otherwise be identical, since the final step is to convert from a DAG into a tree (with distinct node-ids)
[16:15:40] <nmatsakis> erickt: so basically yes, he is correct
[16:15:56] <erickt> nmatsakis: awesome. I'll simplify my code. thanks!
[16:16:03] <nmatsakis> np
[16:17:45] <erickt> olsonjeffery: do you have your stat code somewhere? Theoeretically doing `let st = stat("foo")`, st.st_size should be the file size in bytes
[16:18:52] <olsonjeffery> erickt: not true. it's not the "true length" of the file, in bytes.. it's the size of the file on the filesystem
[16:18:56] <erickt> olsonjeffery: a quick and dirty way to check is look at what python does. What do you get if you do `echo hello > bar && python -c "import os; print os.stat('bar')"` in a terminal?
[16:19:01] <olsonjeffery> so like `cat foo > test.txt`
[16:19:14] <olsonjeffery> that's going to be 4096 bytes, according to stat (filesystem dependant, mind you)
[16:19:37] <olsonjeffery> because the filesystem doesn't actually create a file that is 3 bytes in size.
[16:20:00] <erickt> hrm
[16:21:09] <erickt> olsonjeffery: which linux / filesystem are you using? I just ran that shell script on a centos 6.4/ext4 and I got a st_size of 6
[16:21:29] <olsonjeffery> this was on ubuntu 64bit, using an fstat call from libuv
[16:21:35] <olsonjeffery> i recently paved my machine and am on osx, now
[16:21:47] <erickt> it's possible python isn't just using plain old fstat...
[16:22:46] * erickt looks at the source
[16:23:10] *** Joins: lbergstrom (Adium@moz-BBE3ABD.mv.mozilla.com)
[16:23:34] <olsonjeffery> http://pastebin.mozilla.org/3045368
[16:23:37] <olsonjeffery> just did that on osx
[16:24:50] <olsonjeffery> hm. well stat's actually correct there. anyways. this is what i was seeing with tests.
[16:25:07] <olsonjeffery> where id expect the st_size value to be 3 or 4, and itd be 4096
[16:25:16] *** Joins: noam (noam@F6B530A7.720527A7.416762B.IP)
[16:26:00] *** Quits: michaelgreene (michael@DA820AA2.17CD9887.F12515B4.IP) (Quit: Leaving)
[16:26:09] <acrichto> dbaupp: ping
[16:26:30] *** Quits: mindcat (mindcat@5C1E3272.FBBDCC14.1A8D6442.IP) (Quit: Lost terminal)
[16:26:57] <erickt> olsonjeffery: try doing "stat -f %z test.txt", that gets the size in bytes for me
[16:27:16] *** Quits: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net) (Quit: probably going to bed)
[16:27:28] *** Joins: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net)
[16:27:48] <olsonjeffery> erickt: yeah, it's correct. anyways, ill recreate that test and push it up to a branch if you want to check it out.
[16:27:57] <olsonjeffery> i have stat wired up in my working branch
[16:28:25] <erickt> olsonjeffery: sure
[16:28:56] *** Joins: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com)
[16:29:28] <erickt> olsonjeffery: looking at the python source, they appear to be just using the fstat api. Maybe libuv is simulating fstat?
[16:30:49] *** Quits: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net) (Quit: probably going to bed)
[16:30:58] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[16:30:58] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1428ad49b to 147c8f503: 02http://git.io/N3iJvQ
[16:30:58] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[16:30:59] *** Joins: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net)
[16:30:59] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[16:30:59] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/Hu366Q
[16:30:59] <ghrust> 13rust/06auto 143924cb0 15klutzy: std::rt::io: Fix file I/O on Win32...
[16:30:59] <ghrust> 13rust/06auto 1459203f9 15bors: auto merge of #9165 : klutzy/rust/newrt-file-fix, r=sanxiyn...
[16:31:00] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[16:31:04] <kimundi> rusti: let x = ~5u as ~ToStr; x
[16:31:05] -rusti- ~std::to_str::ToStr:Send
[16:31:42] <kimundi> rusti: let x = &5u as &ToStr; print!("{:?}", x);
[16:31:42] -rusti- &std::to_str::ToStr<no-bounds>()
[16:32:00] <erickt> olsonjeffery: looking at libuv, they appear to be using plain old fstat as well
[16:32:09] *** Joins: sinma (sinma@moz-6A11C47C.fbx.proxad.net)
[16:33:35] <olsonjeffery> erickt: yeah. its weird.
[16:34:08] <olsonjeffery> ill just get it into a test
[16:34:26] <sinma> Hello! If I have a module with a struct and an impl in it, how to use it in another file? I tried mod my_module; (compiles but I fail to use Point::new) and use my_module::*; (donâ€™t compile)
[16:34:42] *** cade_away is now known as cade
[16:35:37] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[16:35:47] *** Joins: valenting (Thunderbir@7658A01E.84D5EFD5.FB866788.IP)
[16:37:18] <cmr> sinma: you need `mod my_module;` and `use my_module::Point`
[16:37:47] *** Joins: t0asterb0t (Mibbit@D7DD000C.1D8B3FFD.1DF7F8A9.IP)
[16:37:58] <sinma> Iâ€™ve tried that: Â«main.rs:2:0: 2:19 error: `use` and `extern mod` declarations must precede items
[16:38:21] <sinma> It points the line of the use
[16:38:22] <kimundi> sinma: You have to do 'mod my_module' to make the module part of your crate, and then you can either call out directly to it: 'let x = ::my_module::Point::new()' or import it with use; 'use my_module::Point; let x = Point::new()'
[16:38:23] <acrichto> r? https://github.com/mozilla/rust/pull/9170 this should stop the fileinput tests from almost always failing
[16:38:58] <kimundi> sinma: And all 'use' line ned to be written before all other declarations (like mod, fn, struct etc)
[16:39:04] <kimundi> need*
[16:39:34] *** Joins: squiddy (squiddy@moz-D37EFEA9.adsl.alicedsl.de)
[16:39:45] <kimundi> use my_module::Point; mod my_module; fn main() { let x = Point::new(); }
[16:39:58] <sinma> kimundi: it says thereâ€™s no Â«PointÂ» in Â«my_moduleÂ»
[16:40:07] <kimundi> Is Point public?
[16:40:16] <cmr> (pub struct Point)
[16:40:22] <kimundi> pub struct Point { ... }
[16:40:25] <sinma> I put nothing before struct
[16:40:34] <kimundi> then it's private
[16:40:35] <cmr> everything is private by default
[16:40:39] <cmr> (except struct fields)
[16:40:45] <sinma> Ok, works
[16:41:01] <kimundi> (It's all in the module tutorial :P)
[16:41:01] <sinma> It seems Iâ€™ve read too fast the tuto
[16:41:07] <kimundi> haha, yeah
[16:41:20] *** Joins: miza (miza@moz-908EA8DE.home.otenet.gr)
[16:41:24] <kimundi> well, we're glad to help
[16:41:53] <sinma> Why use must be before mod?
[16:42:03] <sinma> Thatâ€™s a bit strange at first look
[16:42:17] <acrichto> sinma: use statements shadow modules
[16:42:19] *** Joins: maik (maik@moz-C5365941.dip0.t-ipconnect.de)
[16:42:25] <kimundi> Because all locall defined names shadow all definitions imported with 'use'
[16:42:28] <acrichto> or the other way around
[16:42:34] <t0asterb0t> i'm having trouble building sprocketnes: cpu.rs:709:19: 709:21 error: No rules expected the token: op
[16:42:38] <t0asterb0t> has anyone seen this before?
[16:43:04] <acrichto> t0asterb0t: pcwalton is the one who manages that, although he may not be necessarily keeping it up to date with rust
[16:43:33] <sinma> module is public by default?
[16:44:13] <acrichto> private by default except struct fields :)
[16:44:14] <erickt> acrichto: just commented on https://github.com/mozilla/rust/pull/9170. Can we instead move the glob chdir test to test/run-pass?
[16:44:17] <katis> i have a macro that tries to define a struct and implement a couple of traits for it, it stops expanding after the first definition (struct/impl). is that intended?
[16:44:26] <t0asterb0t> acrichto: thanks, I'll send him a message
[16:44:39] <acrichto> erickt: you are a clever man
[16:44:43] <erickt> :)
[16:45:07] *** Quits: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net) (Quit: probably going to bed)
[16:45:08] <sinma> Still unresolved importâ€¦
[16:45:16] *** Joins: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net)
[16:45:23] <jeaye> rusti: f32::modf(5.0, &mut 2.0)
[16:45:35] -rusti- pastebinned 11 lines of output: http://ix.io/81S
[16:45:44] <sinma> Â«error: unresolved import: could not find `Point` in `Element`.Â» But Element and Point are pub
[16:45:58] <sinma> And the Point struct & impl are in mod Element
[16:46:39] <SiegeLord> katis, It's a bug... the workaround is to put all those things into a module
[16:46:50] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[16:47:00] <katis> SiegeLord: thanks, i'll try that :)
[16:47:02] *** Joins: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[16:47:09] <kimundi> sinma: That's strange. Could you paste the code somewhere?
[16:47:11] <jeaye> Where's fmodf in Rust?
[16:47:25] *** Joins: echristo (echristo@DCF57675.D6CCE4AE.77834EAA.IP)
[16:47:40] *** Quits: cstrahan (cstrahan@moz-71FAC30.hsd1.va.comcast.net) (Ping timeout)
[16:47:46] <sinma> kimundi: ok
[16:48:36] *** Joins: cstrahan (cstrahan@moz-71FAC30.hsd1.va.comcast.net)
[16:48:53] <sinma> kimundi: https://gist.github.com/sinma/6553158
[16:48:55] <acrichto> erickt: just re-pushed
[16:48:56] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[16:49:25] <ecr> jeaye: fmodf?
[16:49:36] <ecr> I'm not familiar with that
[16:49:38] <erickt> acrichto: almost r+ :) can you re-title your PR?
[16:49:55] <acrichto> ah yes
[16:49:58] <ChrisOei> So, I'm completely new to Rust and I'd like to start playing around with it. I'm thinking of doing a simple REST interface back end for a web app, and I was wondering what's the state/maturity of the rust libraries for serving HTTP stuff. Alpha, beta, near-production?
[16:49:59] <jeaye> ecr: floating point remainder
[16:50:01] <ecr> rusti: 5.0f32 % 2.0
[16:50:02] -rusti- 1f32
[16:50:20] <cmr> rusti: 5.0f % 0.54
[16:50:21] -rusti- 0.14
[16:50:29] <ecr> jeaye: looks like it's in the % operator
[16:50:32] <jeaye> :D
[16:50:37] <kimundi> sinma: A *rs source file contains the _body_ of a module. What you have there is a situation where you have a module 'Element' inside a module 'Element', so the global path to Point would be 'Element::Element::Point'
[16:50:43] <acrichto> erickt: done
[16:50:54] <hoverbear> How can I create this Primestream without needing to hand it any args? `primes` should just be [1] to start. https://gist.github.com/Hoverbear/4f5bf45f76079fa553cc#file-gistfile1-rs-L17
[16:51:03] *** Joins: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net)
[16:51:20] <erickt> acrichto: r+
[16:51:29] <kimundi> sinma: What you want is to remove the 'mod Element { }' declaration in Element.rs, keeping only the content of that in the file.
[16:51:36] <erickt> acrichto: as someone who just got bit by this bug, thanks for fixing it :)
[16:52:01] <acrichto> ChrisOei: rust itself isn't quite alpha/beta/production ready yet, it has yet to hit the "backwards compatible" milestone as well. If you're playing around, though, there's a rust-http repository maintained by ChrisMorgan which I think is the defactor standard http library for rust right now (servo uses it as well)
[16:52:08] <acrichto> erickt: yeah I've been trying to track this down for days
[16:52:12] <ecr> hoverbear: you can make a constructor method that returns a PrimeStream with the vector initialized to ~[1]
[16:52:14] <acrichto> I hope I found it :(
[16:52:18] *** Joins: Larry (larryfox@moz-343B6F0C.nyc.biz.rr.com)
[16:52:26] <acrichto> erickt: mind if I p=1 it?
[16:52:28] <Amaranth> Dang, rust function pointers are 128 bits? So much for shoving them in the void* userdata for this callback
[16:52:32] <erickt> acrichto: already done
[16:52:36] <ecr> hoverbear: I'll write an example on the gist
[16:52:36] <acrichto> woohoo
[16:52:40] <acrichto> time for some @bors: retry
[16:52:40] <cmr> Amaranth: No, closures are 128 bits on 64-bit platforms
[16:52:43] <ChrisOei> Thanks acrichto
[16:52:47] <cmr> Amaranth: two pointers, environment ptr and fn ptr
[16:52:49] <hoverbear> ecr: Ok. Thank you so much. :)
[16:52:54] <cmr> Amaranth: function pointers are written `extern fn`
[16:52:54] <sinma> kimundi: thx!
[16:52:55] <acrichto> ChrisOei: also if you ever have any questions, #rust is more than willing to help :)
[16:52:57] <Amaranth> Odd, I didn't think I made a closure
[16:53:00] <Amaranth> Oh
[16:53:00] <cmr> Amaranth: not `&fn` and soforth
[16:53:14] <ChrisOei> :)
[16:53:15] <kimundi> Amaranth: No, a function pointer is 64 bit. A &fn is a closure though, which ARE 128 bit becuase they aare actually two pointers, one to the raw function, and one to the environment
[16:53:39] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[16:53:55] <kimundi> Function pointer : 'extern fn()', closure: '&fn()'
[16:54:01] <sinma> kimundi: you should be payed because of all your answers!
[16:54:08] <luisbg> sinma, +1
[16:54:12] <kimundi> rusti: ::std::sys::size_of::<extern fn()>()
[16:54:13] -rusti- 8u
[16:54:31] <kimundi> sinma: haha, would certainly be nice :)
[16:54:44] <ecr> hoverbear: sure :) you'll probably need to change the type of the primes field to ~[int] instead of [int]. [int] doesn't make sense by itself.
[16:54:47] <kimundi> rusti: ::std::sys::size_of::<&fn()>()
[16:54:48] -rusti- 16u
[16:55:01] <luisbg> kimundi, why does vector_of_strings.iter() return a list of &'static str ?
[16:55:02] <hoverbear> ecr: Ok, ~[int] is an owned box ya?
[16:55:12] <cmr> hoverbear: vectors
[16:55:14] *** Joins: mihneadb (Mihnea@moz-BE33DA21.fw1.sfo1.mozilla.net)
[16:55:32] <hoverbear> cmr: Ok interesting
[16:55:38] <Amaranth> Cool, callback works now
[16:55:48] <kimundi> Amaranth: nice :D
[16:56:01] <ecr> hoverbear: it's an owned vector. vectors can either be fixed size [T, ...N] or of variable size (but have to hide behind a pointer) ~[T], @[T], &[T].
[16:56:17] <hoverbear> ecr: Cool. ^.^
[16:56:37] <ecr> hoverbear: just [int] would imply the whole vector is stored there, but the compiler has no idea how big it should be.
[16:56:49] <hoverbear> ecr: Right, just like in C. Makes sense
[16:56:56] <ecr> hoverbear: yep :)
[16:57:42] *** Quits: t0asterb0t (Mibbit@D7DD000C.1D8B3FFD.1DF7F8A9.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[16:57:59] *** Joins: azakai (alon@moz-BBE3ABD.mv.mozilla.com)
[16:58:02] <steveh> In C, you can take the address of a fixed size "array" and use that as if it came from "new"
[16:58:06] <steveh> Is possible in RUst?
[16:58:32] <kimundi> steveh: depends on what you mean with 'use'
[16:58:43] <sinma> steveh: let x = &my_fixed_size_array; maybe
[16:58:54] <engla> you can take a vector slice from a vector of any kind of allocation
[16:58:58] <ecr> steveh: there's slices, which are like views into an array
[16:58:59] <steveh> Yeah would like to borrow it
[16:59:04] <kimundi> Any vector in rust can be sliced as an &[T]
[16:59:18] <steveh> ok thought I tried that but I'll try again...
[16:59:39] <kimundi> Note that just borrowing it won't directly give you a slice
[17:00:00] <acrichto> rusti: let a: [int, ..2] = [0, 0]; let a: &[int] = a; 3
[17:00:00] -rusti- <anon>:5:41: 5:42 warning: unused variable: `a` [-W unused-variable (default)]
[17:00:00] -rusti- <anon>:5          let a: [int, ..2] = [0, 0]; let a: &[int] = a; 3
[17:00:00] -rusti-                                                   ^
[17:00:01] -rusti- 3
[17:00:06] <engla> steveh: v.as_slice()  or v.slice(i, j)    also when passed as a function argument, a vector should autoconvert to a slice
[17:00:13] <hoverbear> ecr: So how would I address  it? https://gist.github.com/Hoverbear/4f5bf45f76079fa553cc#file-gistfile1-rs-L18
[17:00:15] <kimundi> let x = ~[1u8]; let y = &x; println!("{:?}", y)
[17:00:32] <steveh> engla: ok got it thx
[17:00:34] <kimundi> rusti: let x = ~[1u8]; let y = &x; println!("{:?}", y);
[17:00:35] -rusti- &~[1u8]
[17:00:35] *** Quits: cstrahan (cstrahan@moz-71FAC30.hsd1.va.comcast.net) (Ping timeout)
[17:00:35] -rusti- ()
[17:00:41] <kimundi> rusti: let x = ~[1u8]; let y = &*x; println!("{:?}", y);
[17:00:41] -rusti- <anon>:5:34: 5:36 error: type ~[u8] cannot be dereferenced
[17:00:42] -rusti- <anon>:5          let x = ~[1u8]; let y = &*x; println!("{:?}", y);
[17:00:42] -rusti-                                            ^~
[17:00:42] -rusti- error: aborting due to previous error
[17:00:42] -rusti- application terminated with error code 101
[17:01:04] <kimundi> rusti: let x = ~[1u8]; let y = x.as_slice(); println!("{:?}", y);
[17:01:04] *** Joins: bheylin_ (brianheyli@moz-8255E94E.adsl.online.nl)
[17:01:04] -rusti- &[1u8]
[17:01:05] -rusti- ()
[17:01:14] <sinma> Is it possible to inherit from a struct? Or at least to have different impl for the same struct.
[17:01:26] <kimundi> sinma: both no
[17:01:26] <ecr> hoverbear: address what in particular?
[17:01:33] <hoverbear> ecr: The value. :)
[17:01:48] <sinma> kimundi: workarounds?
[17:01:53] <hoverbear> ecr: Pardon my languageâ€¦ Coming from Javascript, we don't play with pointers.
[17:01:54] <acrichto> sinma: you could have a "phantom type" and then you could impl the struct for specific phantom types I believe
[17:02:01] <acrichto> sinma: that may not work though...
[17:02:02] <kimundi> sinma: You can include an other struct as a field in you new struct, and implement the traits as delegation to that
[17:02:15] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Ping timeout)
[17:02:17] <sinma> kimundi: seems a bit hackish
[17:02:27] <kimundi> Not really hackish, just verbose
[17:02:28] <ecr> hoverbear: ah ok, I just wasn't quite sure what you were asking. just to be clear, you want to know how you'd return the last value in the vector, right?
[17:02:36] <hoverbear> ecr: Yup, exactly.
[17:02:42] <kimundi> A syntax extension that does that for you would be nice
[17:03:07] <acrichto> rusti: struct A<T>(int); impl A<int> { fn foo(&self) -> int { 2 } } impl A<float> { fn foo(&self) -> int { 4 } }; let a = A::<int>(4); a.foo()
[17:03:13] -rusti- pastebinned 8 lines of output: http://ix.io/81T
[17:03:29] <acrichto> sinma: yeah nvmd about the phantom type
[17:04:02] <sinma> kimundi: I dev a little game, I have a base class and each ennemie should inherints this base class.
[17:04:10] *** Joins: cstrahan (cstrahan@moz-71FAC30.hsd1.va.comcast.net)
[17:04:11] <sinma> So phantom type is the way?
[17:04:31] <ecr> rusti: let v = ~[1, 2, 3]; let x: int = v.last(); x
[17:04:32] -rusti- <anon>:5:42: 5:51 error: mismatched types: expected `int` but found `&<VI2>` (expected int but found &-ptr)
[17:04:32] -rusti- <anon>:5          let v = ~[1, 2, 3]; let x: int = v.last(); x
[17:04:32] -rusti-                                                    ^~~~~~~~~
[17:04:32] -rusti- error: aborting due to previous error
[17:04:32] -rusti- application terminated with error code 101
[17:04:39] <acrichto> sinma: no looks like the compiler thinks that there's duplicate definitions
[17:04:50] <ecr> rusti: let v = ~[1, 2, 3]; let x: &int = v.last(); x
[17:04:52] -rusti- pastebinned 16 lines of output: http://ix.io/81V
[17:04:53] <sinma> arichto: damn
[17:05:09] <hoverbear> ecr: I was getting this issue: mismatched types: expected `std::option::Option<int>` but found `std::option::Option<@&int>` (expected int but found @-ptr)
[17:05:39] <hoverbear> ecr: Wait, that's a bad paste...
[17:05:39] <hoverbear> .
[17:05:51] <hoverbear> ecr: error: mismatched types: expected `std::option::Option<int>` but found `std::option::Option<&int>` (expected int but found &-ptr)
[17:05:58] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[17:06:13] *** Quits: maik (maik@moz-C5365941.dip0.t-ipconnect.de) (Ping timeout)
[17:06:13] *** Quits: cstrahan (cstrahan@moz-71FAC30.hsd1.va.comcast.net) (Ping timeout)
[17:06:34] <kimundi> hoverbear: You got a reference to the value wrappen in an Options rather than the value wrapped in an option
[17:06:41] <ecr> hoverbear: yeah, the issue is that last() returns a reference to the value instead of copying it. the compiler has to guarantee that the reference is valid for the lifetime of where you use it 
[17:06:45] <hoverbear> kimundi: Right. :)
[17:07:02] <ecr> rusti: let v = ~[1, 2, 3]; let x: int = v.last().clone(); x
[17:07:05] -rusti- pastebinned 35 lines of output: http://ix.io/81W
[17:07:09] <sinma> kimundi: doing a struct for each ennemi is a bit repetitive
[17:07:13] <kimundi> rusti: let x = [1u, 2, 3]; x.last()
[17:07:16] -rusti- pastebinned 16 lines of output: http://ix.io/81X
[17:07:29] <kimundi> rusti: let x = [1u, 2, 3]; x.last().map(|&x|x)
[17:07:32] -rusti- pastebinned 8 lines of output: http://ix.io/81Y
[17:07:44] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[17:07:44] *** ChanServ sets mode: +ao dherman dherman
[17:07:47] <kimundi> sinma: It is, but we currently support nothing better
[17:07:50] <ecr> rusti: let v = ~[1i, 2, 3]; let x: int = v.last().clone(); x
[17:07:51] -rusti- 3
[17:08:19] <hoverbear> ecr: That works. :)
[17:08:20] <kimundi> rusti: let x = [1u, 2, 3]; print!("{:?}", x.last())
[17:08:20] -rusti- &3u()
[17:08:37] <ecr> hoverbear: so if you do .clone() you'll copy the int, which isn't that big of a deal. if you don't want to copy, you'll need to figure out how lifetimes work. that might be a bit much if you're just starting out
[17:08:40] <cmr> note that the () is from the return value of print!
[17:08:41] <kimundi> rusti: let x = []; print!("{:?}", x.last())
[17:08:43] -rusti- pastebinned 8 lines of output: http://ix.io/81Z
[17:08:45] *** Quits: tgummerer (tgummerer@51D3B54.FEF996EA.EA6FEF3D.IP) (Ping timeout)
[17:09:02] *** Joins: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net)
[17:09:02] <sinma> kimundi: nothing planned? How others projects bypass this limitation?
[17:09:08] <hoverbear> ecr: Yeah. this works for me. :) Now I need to get the append working, weeâ€¦ Thanks for your help!
[17:09:16] <ecr> hoverbear: sure :)
[17:09:19] <cmr> sinma: what limitation>
[17:09:26] <cmr> ?
[17:09:30] <sinma> cmr: no inheritance on struct
[17:09:33] *** Joins: cstrahan (cstrahan@moz-71FAC30.hsd1.va.comcast.net)
[17:09:45] <hoverbear> ecr: T clarify, a vector should have the append_one method ya? http://static.rust-lang.org/doc/core/vec.html#function-append_one
[17:09:54] <sinma> If I must change every single struct for each ennemi in the game, that might no be fun at all
[17:10:00] <sinma> *ennemy
[17:10:10] <olsonjeffery> how do you disable valgrind for a single build from the cli when it was enabled in ./configure?
[17:10:13] <sinma> *enemy
[17:10:18] <olsonjeffery> CFG_ENABLE_VALGRIND=0 isn't doing it for me
[17:10:25] <kimundi> sinma: There are various discussions how to allow such patterns. We already have trait inheritance, but that won't help you here. There might be the possibility to have struct inheritance in the future and/or an convenient syntax extension that allows you to delegate trait impls to struct fields.
[17:10:44] <ecr> hoverbear: that is some really old documentation! what version of rust are you using?
[17:11:02] <hoverbear> ecr: 0.8-pre
[17:11:18] <cmr> Those docs are for like 0.2 or 0.3
[17:11:22] <hoverbear> LOL
[17:11:24] <klutzy> core is even pre-0.7
[17:11:26] <ecr> hoverbear: alright. here's the current docs: http://static.rust-lang.org/doc/std/vec.html
[17:11:26] *** Quits: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net) (Client exited)
[17:11:45] <hoverbear> ecr: Ok, awesome.
[17:11:51] <ecr> hoverbear: you want push I think
[17:11:53] <hoverbear> Thanks. xD
[17:11:54] <kimundi> Will someone delete the http://static.rust-lang.org/doc/core folder already?
[17:11:56] *** Joins: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net)
[17:11:57] <ecr> rusti: ~[1, 2].push(3)
[17:11:57] -rusti- <anon>:5:10: 6:5 error: type `[<VI1>, .. 2]` does not implement any method in scope named `push`
[17:11:58] -rusti- <anon>:5          ~[1, 2].push(3)
[17:11:58] -rusti- <anon>:6     };
[17:11:58] -rusti- error: aborting due to previous error
[17:11:58] -rusti- application terminated with error code 101
[17:11:59] <klutzy> kimundi: https://github.com/mozilla/rust/issues/7476
[17:12:10] <ecr> rusti: ~[1i, 2].push(3i)
[17:12:11] -rusti- <anon>:5:10: 6:5 error: type `[int, .. 2]` does not implement any method in scope named `push`
[17:12:11] -rusti- <anon>:5          ~[1i, 2].push(3i)
[17:12:11] -rusti- <anon>:6     };
[17:12:11] -rusti- error: aborting due to previous error
[17:12:11] -rusti- application terminated with error code 101
[17:12:12] <klutzy> I don't know who's webmaster though
[17:12:16] *** Joins: jclements (jclements@moz-644F0E77.wireless.calpoly.edu)
[17:12:27] <ecr> rusti: let x = ~[1, 2]; x.push(3)
[17:12:28] -rusti- <anon>:5:26: 5:27 error: cannot borrow immutable local variable as mutable
[17:12:28] -rusti- <anon>:5          let x = ~[1, 2]; x.push(3)
[17:12:28] -rusti-                                    ^
[17:12:28] -rusti- error: aborting due to previous error
[17:12:28] -rusti- application terminated with error code 101
[17:12:29] <cmr> it's s3
[17:12:36] <cmr> I don't know who has s3 access
[17:12:36] <ecr> let mut x = ~[1, 2]; x.push(3)
[17:12:40] <ecr> gah
[17:12:47] <ecr> rusti: let mut x = ~[1, 2]; x.push(3)
[17:12:48] -rusti- ()
[17:12:51] *** Joins: lenstr (lenstr@E0E80B8D.ED45D46B.DFEAE789.IP)
[17:12:53] <ecr> ARGH
[17:13:00] <kimundi> haha
[17:13:01] <ecr> rusti: let mut x = ~[1, 2]; x.push(3); x
[17:13:02] <klutzy> cmr: it may be Jeff Bezos
[17:13:02] -rusti- ~[1, 2, 3]
[17:13:05] <ecr> YES
[17:13:11] <ecr> hoverbear: yeah, you want push
[17:13:32] <hoverbear> ecr: Yes =D! Awesome. that seems to work
[17:13:36] *** Quits: SiegeLord (sl@moz-1DF56822.twcny.res.rr.com) (Quit: Leaving)
[17:13:40] <sinma> kimundi: the only way I can do what I want is to make a Component-entity system
[17:14:07] *** Joins: riley (riley@8BA43816.9AA11D69.65DDFA89.IP)
[17:14:27] <kimundi> sinma: Well, I hear those are better than inheritance based ones any way ;)
[17:14:31] <sinma> kimundi: keeping the same struct but using composition to define behavior
[17:15:08] <sinma> kimundi: for a big game, but for a little game itâ€™s a bit overkill I think â€” though itâ€™s not that hard
[17:15:09] <hoverbear> ecr: Is there a idiomatic way to say "Loop 10 times"? I'm using for _ in range(0,10) right now.
[17:16:29] <ecr> rusti: do 10.times { print!("hi") }
[17:16:29] -rusti- hihihihihihihihihihi()
[17:16:35] <hoverbear> Hahahah
[17:16:38] <hoverbear> Awesome
[17:17:00] <sinma> rusti: do 10.times {}
[17:17:01] -rusti- ()
[17:17:05] <sinma> oops
[17:17:09] <steveh> Smalltalk all over again!
[17:17:26] <ecr> strcat's going to have a fit that I'm promoting .times though
[17:17:34] <ecr> he doesn't like it
[17:17:35] <sinma> rusti: do 10.times { do spawn { print("Hi! "); } }
[17:17:35] -rusti- Hi! Hi! Hi! Hi! Hi! Hi! Hi! Hi! Hi! Hi! ()
[17:17:45] <kimundi> ecr: Don't worry, bstrie's gonna protect you :P
[17:17:53] <engla> hehe.  hoverbear the range loop is basically the idiomatic way
[17:17:59] <sinma> Thereâ€™s no problem of text that mix like in C?
[17:18:10] <ecr> it's my last day as an intern. if I don't cause some chaos, then I've wasted it
[17:18:23] <hoverbear> ecr: Intern at Moz Re?
[17:18:27] <ecr> hoverbear: yep
[17:18:34] <hoverbear> ecr: Sounds like a fun job.
[17:18:35] <ecr> sinma: how do you mean?
[17:18:35] <steveh> Bravo ecr and all the interns!
[17:18:41] *** Quits: alex-abreu (alex@moz-7421D6C9.mc.videotron.ca) (Client exited)
[17:18:43] <kimundi> sinma: Well, a single write to stout is atomic, so independend of order you'd see the same output
[17:18:44] <ecr> hoverbear: indeed :)
[17:18:56] <sinma> kimundi: ok
[17:18:57] <ecr> steveh: yay us!
[17:19:19] <sinma> ecr: now I remember the problem come with multiple processus
[17:19:32] *** Joins: victorporof_ (victorporo@6CCF2761.6F48C38B.3EA6AAD8.IP)
[17:19:33] <ecr> sinma: right. and this all in one task (and it's the only task)
[17:19:37] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[17:19:39] <kimundi> rusti: do 4.times { do spawn { println("Does this race?"); } }
[17:19:40] -rusti- Does this race?
[17:19:40] -rusti- Does this race?
[17:19:40] -rusti- Does this race?
[17:19:40] -rusti- Does this race?
[17:19:40] -rusti- ()
[17:20:02] <kimundi> rusti: do 100.times { do spawn { println("Does this race?"); } }
[17:20:05] <ecr> kimundi: probably. depends on how println's implemented I guess
[17:20:06] -rusti- pastebinned 101 lines of output: http://ix.io/820
[17:20:17] <sinma> haha
[17:20:19] <engla> I'm pretty sure it does kimundi 
[17:20:22] *** Quits: victorporof (victorporo@6CCF2761.6F48C38B.3EA6AAD8.IP) (Ping timeout)
[17:20:28] <kimundi> ecr: print(s); followed by print("\n")
[17:20:44] <hoverbear> rusti: for i in range(1,100) { do spawn { println(i.to_str()) } }
[17:20:49] -rusti- pastebinned 100 lines of output: http://ix.io/821
[17:20:56] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[17:20:56] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1459203f9 to 147c8f503: 02http://git.io/N3iJvQ
[17:20:56] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[17:20:59] <hoverbear> kimundi: No: http://ix.io/821
[17:21:02] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[17:21:02] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/BCEPLw
[17:21:02] <ghrust> 13rust/06auto 145c6c774 15Alex Crichton: Move glob tests to a run-pass test...
[17:21:02] <ghrust> 13rust/06auto 14caf3dcf 15bors: auto merge of #9170 : alexcrichton/rust/flaky-fileinput, r=erickt...
[17:21:02] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[17:21:07] *** Joins: tgummerer (tgummerer@51D3B54.FEF996EA.EA6FEF3D.IP)
[17:21:43] <cmr> kimundi: writes to stdout aren't actually atomic
[17:21:47] <kimundi> rusti: do 20.times { do spawn { for c in "Does this race?".iter() { print(c.to_str()) } } }
[17:21:50] -rusti- pastebinned 1 lines of output: http://ix.io/822
[17:21:51] <cmr> It depends on the size of your string
[17:22:04] <kimundi> HA
[17:22:05] *** Quits: hoverbear (andrew@moz-86FE120E.wireless.uvic.ca) (Quit: hoverbear)
[17:22:10] <kimundi> look at that paste
[17:22:42] <kimundi> cmr: needs to be shorter than 1 page size afaik
[17:22:55] <cmr> for posix-compliant systems yes
[17:23:37] <sinma> it races a bit. Just a bit. xD
[17:23:59] <cmr> That's not really a race condition, that's just interleaving execution over a shared, unlocked resource.
[17:24:19] <kimundi> rusti: for c in "Let's see what happens here, shall we?".iter() { do spawn {print(c.to_str())} }
[17:24:19] <kimundi> cmr: true
[17:24:20] -rusti- Let's see what happens here, shall we?()
[17:24:24] <kimundi> pah
[17:24:27] <kimundi> boring
[17:24:29] *** Quits: lenstr (lenstr@E0E80B8D.ED45D46B.DFEAE789.IP) (Client exited)
[17:25:09] *** Joins: ofeldt- (ofeldt@moz-B378026B.dip0.t-ipconnect.de)
[17:25:10] <kimundi> probably runs all on the same scheduler
[17:25:49] *** Quits: ofeldt (ofeldt@moz-AFA78C7E.dip0.t-ipconnect.de) (Ping timeout)
[17:26:06] <strcat> kimundi: there's nothing sensible it can do
[17:26:11] <Yurume> did ThreadPerTask SchedMode work in 0.7?
[17:26:16] <strcat> output isn't inherently line-based
[17:26:25] <cmr> rusti: for c in "Let's see what happens here, shall we?".iter() { do spawn { std::task::deschedule(); print(c.to_str())} }
[17:26:26] -rusti- Let's see what happens here, shall we?()
[17:26:28] <strcat> unless you want it to lock until it's done each str :s
[17:26:48] <cmr> Really you should only have one writer to stdout
[17:26:51] <Amaranth> cmr: You need a random chance and/or number of deschedule() calls
[17:27:08] <jdm> what is a ty_opaque_box?
[17:27:16] *** Joins: hoverbear (andrew@moz-86FE120E.wireless.uvic.ca)
[17:27:17] <cmr> Other shared resources are considered bad, why isn't stdout?
[17:27:41] <cmr> jdm: something to do with @T or @mut T depending on what T is, iirc
[17:27:51] <jack> jclements: ping
[17:27:52] <jdm> cmr: trait or concrete?
[17:27:53] <cmr> strcat: did you ever figure out what an opaque box is?
[17:27:57] <Amaranth> Sure just dump messages on a circular buffer queue for a dedicated logging task to deal with
[17:28:01] <strcat> cmr: yes
[17:28:06] <strcat> cmr: that problem is fixed
[17:28:11] <jclements> jack: pong
[17:28:13] <jack> jclements: https://gist.github.com/metajack/6553604
[17:28:17] <jack> hygienic or not?
[17:28:17] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[17:28:17] *** ChanServ sets mode: +o tjc
[17:28:46] <jack> I think your let hygiene PR broke this use case somehow.
[17:28:47] <jdm> strcat: what would be an example of a ty_opaque_box in rust code?
[17:28:58] <jclements> Does it ICE?
[17:29:02] <jack> (I make absolutely no defense of this usecase)
[17:29:05] <strcat> jdm: well ideally it shouldn't be used anymore
[17:29:12] <jack> jclements: It bus errors
[17:29:13] *** Joins: io2 (io2@moz-A6202C16.home.otenet.gr)
[17:29:14] <strcat> jdm: it's an obsolete concept
[17:29:24] <strcat> jdm: the monomorphize pass used to normalize @ and @mut to opaque boxes
[17:29:32] <strcat> in an attempt to reduce code size - but it was incorrect
[17:29:33] <jclements> jack:ooh, lovely. I don't *think* that's the expected and documented behavior, but let me check. :)
[17:29:39] *** Quits: cstrahan (cstrahan@moz-71FAC30.hsd1.va.comcast.net) (Ping timeout)
[17:29:41] <jdm> strcat: hmm. maybe we shouldn't add any debuginfo support for it, in that case.
[17:29:49] <strcat> jdm: it is still (incorrectly) used around trans but it's not a real type
[17:30:04] <kimundi> I need a link that proofs that utf8 can contain interior nulls, and that encoding it as (0xC0, 0x80) is not valid utf8. Someone in wikipedia doesn't believe it :P
[17:30:26] <Amaranth> Are you in an edit war or something?
[17:30:28] <strcat> kimundi: on which page?
[17:30:50] <kimundi> strcat: http://en.wikipedia.org/wiki/Null-terminated_string , see last two edits
[17:31:03] <engla> kimundi: unicode.org docs are very good. I'll find it
[17:31:06] <jclements> jack: was there a copy-paste error in that gist? It signals the expected error (no label named foo), but I'm ... no, I'm just confused.
[17:31:14] <jack> jclements: as a philosophical viewpoint, do you consider capturing named labels a violation of hygiene? seems like ti should be.
[17:31:34] <kimundi> I just looked at that one and the UTF-8 one and saw that they didn't match, though "might as well correct the wrong one"
[17:31:37] <jack> jclements: i'm on recent master 19c0735
[17:31:56] <jclements> jack: we could treat labels hygienically, but we currently don't. From a philosophical standpoint, I totally agree that they should be treated hygienically.
[17:32:11] <kimundi> Amaranth: It's not a war yet ;)
[17:32:12] <jclements> jack: and that exact gist causes a bus error? At compile time?
[17:32:17] <jack> yes
[17:32:22] <engla> kimundi: Table 3-4, page 40 in the chapter 3 pdf. http://www.unicode.org/faq/utf_bom.html#utf8-1
[17:32:23] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[17:32:25] *** Quits: KindOne (KindOne@moz-79A66DC5.dynamic.ip.windstream.net) (Ping timeout)
[17:32:25] *** Quits: lessless (lessless@moz-F3755E99.emplot.net) (Client exited)
[17:32:50] <jack> jclements: are you ahead of that commit or behind? i could try something else.
[17:32:54] <pnkfelix> jack: This sounds like what I've been looking at
[17:32:54] *** Quits: sinma (sinma@moz-6A11C47C.fbx.proxad.net) (Quit: Konversation terminated!)
[17:33:03] *** Joins: cstrahan (cstrahan@moz-71FAC30.hsd1.va.comcast.net)
[17:33:11] <jack> pnkfelix: did you file a bug yet? i was just about to do so.
[17:33:19] <pnkfelix> jack: https://github.com/mozilla/rust/issues/9129
[17:33:21] <jclements> jack: let me check.
[17:33:25] <pnkfelix> jack: scroll to bottom
[17:34:05] <engla> kimundi: oops, table 3-7 it is
[17:34:08] <pnkfelix> jclements: I myself only see the bus errors when I'm doing a â€”disable-optimize build
[17:34:18] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[17:34:27] <pnkfelix> jclements: (or at least, that's where its been easiest for me to replicate the bus errors/seg faults)
[17:34:37] <jclements> pnkfelix: this looks like it could *definitely* be related to a recent change I made to the representation of ExprBreak and ExprAgain.
[17:34:41] <pnkfelix> jclements: also, you may want to look at the same url, https://github.com/mozilla/rust/issues/9129
[17:34:44] *** Joins: lkuper (lkuper@moz-D862222C.dhcp-bl.indiana.edu)
[17:34:54] <jclements> pnkfelix: already there.
[17:34:57] <pnkfelix> jclements, jack: the weird thing is that this should not be causing a dynamic failure in this manner
[17:35:21] <pnkfelix> jclements: jack: it looks like either a failure on either the borrowck or upon trans, right?
[17:35:32] <engla> kimundi: Unicode allows you to encode 0 anywhere. It doesn't define how to terminate strings though
[17:36:00] <kimundi> engla: right, this is about the utf8 encoding
[17:36:30] <pnkfelix> jclements: jack: anyway its is now time for me to stop for the day before steph gets too hungry
[17:36:38] <engla> yes 0xC0 0x80 is of course invalid (see the table). But 0 is valid anywhere
[17:36:40] *** Joins: lenstr (lenstr@74DB7AA5.9FB80F19.7C973122.IP)
[17:36:41] <jclements> pnkfelix: thanks for the heads-up
[17:36:48] <engla> as far as UTF-8 is concerned
[17:36:51] *** Joins: KindOne (KindOne@moz-79A66DC5.dynamic.ip.windstream.net)
[17:37:16] <jack> jclements: I assuem this should be caught in typeck becuase there is no actual label called 'foo in this case.
[17:37:32] <jack> it doesn't matter whether a label actually exists in this case. it fails before then.
[17:37:38] <pnkfelix> jack: I think the problem is more insidious than that
[17:37:44] <jack> you might try doing things like putting it in its own scope if you can't get it to fail
[17:37:48] <pnkfelix> jack: the problem occurs even if you do define the actually labels
[17:37:49] <jack> { break 'foo; } etc
[17:37:57] <jclements> jack: I'm not reproducing your bug yet.... pnkfelix sidetracked me :). 
[17:38:04] <jack> pnkfelix: yes. in the original file this came from, the label does exist.
[17:38:28] <engla> kimundi: whether to terminate a string by a zero or not is not something Unicode defines
[17:39:26] <pnkfelix> jack: of course, I don't *know* that your segfault is the same.  You could see if the modification I noted at the end of #9129 fixes the problem for you within rustc.  :)  (Namely, pulling the Ident::new(x) subexpression out and binding it to its own variable)
[17:40:15] <kimundi> engla: I know. For some reason, the page you linked me to won't load, but as you said: utf8 may contain 0, and may not contain c080
[17:40:54] <engla> yeah
[17:41:24] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[17:41:50] *** Quits: fabiand (fabiand@moz-B584E7F8.adsl.alicedsl.de) (Quit: Verlassend)
[17:42:23] *** Joins: fabiand (fabiand@moz-B584E7F8.adsl.alicedsl.de)
[17:42:57] <jack> jclements: for me the stack trace looks like this: https://gist.github.com/metajack/6545726
[17:43:40] *** Quits: lenstr (lenstr@74DB7AA5.9FB80F19.7C973122.IP) (Client exited)
[17:43:48] *** Joins: aeqwa (aeqwa@moz-97603595.dsl.tropolys.de)
[17:44:58] *** Quits: fabiand (fabiand@moz-B584E7F8.adsl.alicedsl.de) (Quit: Verlassend)
[17:45:37] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[17:46:21] *** Quits: kimundi (kimundi@moz-AAB55991.dip0.t-ipconnect.de) (Ping timeout)
[17:46:35] <jclements> jack: hmm.... actually, I think this may *not* be my fault; I'm building my most recent merge to find out.  That'll crush my machine for about 15 minutes... :)
[17:49:07] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[17:49:29] *** Joins: kimundi (kimundi@moz-C0A90971.dip0.t-ipconnect.de)
[17:49:38] <jack> jclements: yeah. i thought of you because hygiene is one of hte things that landed and it seemed somewhat related. i'm goign to try felix's workaround here
[17:51:23] *** Quits: kimundi (kimundi@moz-C0A90971.dip0.t-ipconnect.de) (Ping timeout)
[17:51:23] <strcat> kimundi: added an official source for \0 being the encoding of 0
[17:52:07] *** Quits: cstrahan (cstrahan@moz-71FAC30.hsd1.va.comcast.net) (Ping timeout)
[17:54:43] *** Joins: zz_kimundi (kimundi@moz-F5A3C46E.dip0.t-ipconnect.de)
[17:55:00] *** zz_kimundi is now known as kimundi
[17:55:13] <strcat> kimundi: well, not actually *official* official
[17:55:15] <strcat> but they link it ;p
[17:55:55] *** Quits: jclements (jclements@moz-644F0E77.wireless.calpoly.edu) (Quit: jclements)
[17:55:58] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[17:55:58] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14caf3dcf to 147c8f503: 02http://git.io/N3iJvQ
[17:55:58] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[17:56:02] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[17:56:02] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/QS0WCg
[17:56:02] <ghrust> 13rust/06auto 1424fdb1d 15Tim Chevalier: rustc/rustpkg: Use a target-specific subdirectory in build/ and lib/...
[17:56:02] <ghrust> 13rust/06auto 147a83d53 15bors: auto merge of #9151 : catamorphism/rust/rustpkg-target-specific-subdirectory, r=brson...
[17:56:03] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[17:56:25] <tjc> erickt: ping
[17:56:31] <erickt> tjc: pong
[17:56:48] <tjc> erickt: I'm trying to figure out how to handle dependencies correctly between crates in the same package...
[17:56:49] <erickt> I saw you bumped a PR ahead of me... curse you! ;p
[17:56:51] <tjc> haha
[17:57:02] <tjc> and the way I can think of is to build a dependency graph and topologically sort it
[17:57:14] <tjc> but, that kind of seems declarative, and workcache is supposed to be about building imperatively
[17:57:23] <strcat> kimundi: there's a lot of misinformation about it floating around
[17:57:33] <tjc> erickt: So, I was wondering how fbuild does it
[17:58:05] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[17:59:04] <erickt> tjc: heh. well fbuild uses the stack to handle dependencies. So you'd write in pseudo-rust `let src = ~[...]; let objs = srcs.map(|src| cpp.build(src)).collect(); let exe = cpp.link("exe",objs);`
[18:00:13] <tjc> erickt: Hmm, I think I just debugged the error in my own thinking :-) but I'll talk it out anyway...
[18:00:26] <erickt> tjc: haha
[18:00:31] <tjc> so the problem right now is, when you build a package, rustpkg goes and recursively finds all the crates in it, and builds them, in no particular order
[18:00:44] <tjc> the example that doesn't work is https://github.com/mozilla/rust/issues/7879
[18:00:55] <tjc> so you have a top-level crate; then a subdirectory with a test crate that depends on the top-level crate
[18:01:03] <tjc> rustpkg happily builds the top-level one, and then builds the crate in the subdir
[18:01:21] <tjc> but then it sees the test crate's dependency on the top-level crate and says "okay, I will build the whole package that you depend on"
[18:01:33] <tjc> But, oops, the whole package includes the test crate itself, so you go into an infinite loop
[18:01:43] <tjc> I think my problem is actually being kind of fast and loose about packages vs. crates
[18:01:50] <erickt> heh.
[18:02:37] <erickt> tjc: are you caching the already-built crates? If not, that should break your infinite loop
[18:02:58] <tjc> erickt: I think the problem is that what I'm caching is all the inputs and outputs for a single *package*
[18:03:02] <tjc> and it should be for a single *crate*
[18:03:10] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[18:03:10] <erickt> tjc: aah
[18:03:56] <erickt> tjc: that sounds more correct. fbuild goes crazy and pretty much caches everything at every level
[18:04:38] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Quit: Gone to save the world!)
[18:04:46] *** Quits: hoverbear (andrew@moz-86FE120E.wireless.uvic.ca) (Quit: hoverbear)
[18:05:30] <tjc> erickt: Yeah, one of the things I'm still a little fuzzy on wrt workcache is *what* the functions are that are being cached
[18:05:34] <tjc> if that makes any sense
[18:05:47] *** Joins: jstevans (Instantbir@moz-735D8260.washdc.fios.verizon.net)
[18:05:48] <tjc> right now the "function names" that I'm using are actually package names (so, implicitly, I'm caching the results of building those packages)
[18:05:58] *** Quits: ahal (ahal@FCCEA34F.7672369.D8E68FF6.IP) (Ping timeout)
[18:06:02] *** Quits: aeqwa (aeqwa@moz-97603595.dsl.tropolys.de) (Quit: Lost terminal)
[18:06:30] *** Quits: paulproteus (quassel@rose.makesad.us) (Ping timeout)
[18:06:37] *** Joins: aeqwa (aeqwa@moz-97603595.dsl.tropolys.de)
[18:07:09] <erickt> tjc: that sounds correct. In fbuild the "function names" where just the fully qualified name for a python function or class method that has it's results cached
[18:07:21] <erickt> *its*
[18:07:35] *** Joins: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com)
[18:07:35] *** ChanServ sets mode: +ao pcwalton pcwalton
[18:07:47] <tjc> erickt: Ok, that's what I guessed. For some reason I had a hard time wrapping my mind around that.
[18:07:47] <doomlord> latest versiion of rust .. "libsyntax::oldvisit" -- has it been deleted
[18:08:21] <tjc> erickt: i guess the whole "the dependency graph is implicit in the actual call stack of the program you're running" thing confused me a bit. I think it's one of those things where all there is to understand is that there's nothing to understand :-)
[18:08:29] *** Joins: jclements (jclements@moz-644F0E77.wireless.calpoly.edu)
[18:08:35] <jclements> jack: ping
[18:09:31] <erickt> tjc: how zen
[18:10:12] <erickt> tjc: the way I see it fbuild/workcache are really just an optimization. builds should be able to work with or without caching, it's just slower
[18:10:47] <tjc> erickt: Yeah. I also wonder why every build system doesn't work this way -- it seems so much simpler than, say, make (not that I've looked at the internals of make)
[18:11:44] <erickt> tjc: now that I think about it, in https://github.com/mozilla/rust/issues/7879, there is not something that fbuild/workcache can do to fix it, you have a dependency loop that you need to break in a different way (which is sounds like you've come up with a strategy to do that)
[18:12:11] <erickt> tjc: that's what I wonder too :)
[18:13:00] <tjc> erickt: hmm. It did seem like a dependency loop to me at first. But there's no loop at the level of crates-within-a-package -- the test crate depends on the top-level library crate for a, but not vice versa
[18:13:37] <tjc> I guess the confusion comes from: if you have $WORKSPACE/src/foo/lib.rs , when you refer to "foo", does that mean the whole package? Or just the compiled library resulting from building lib.rs?
[18:14:13] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[18:14:55] *** Quits: ceninan (ceninan@moz-6BD43586.a370.priv.bahnhof.se) (Ping timeout)
[18:15:29] <erickt> tjc: and to be honest, some times you do need to do a topological sort. fbuild has to do that to resolve dependencies between c/c++ files
[18:15:52] <tjc> erickt: hmm, interesting. what about c/c++ necessitates that?
[18:16:36] *** Joins: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[18:17:02] <erickt> tjc: it's the link order that matters.
[18:17:24] <erickt> tjc: c compilers need objects listed in the right order to link properly
[18:17:37] <tjc> erickt: ah, yeah. fortunately we don't have that problem with rustc
[18:17:51] <erickt> because rust was smartly designed :)
[18:18:15] <acrichto> jclements: ping
[18:18:23] <jclements> acrichto: pong
[18:18:35] <erickt> tjc: here's fbuild's gcc dependency sorting: https://github.com/felix-lang/fbuild/blob/master/lib/fbuild/builders/c/gcc/__init__.py#L218
[18:18:51] <acrichto> jclements: you were working with macros/hygiene recently, right? 
[18:19:00] <acrichto> jclements: would you have any idea to the scope of https://github.com/mozilla/rust/issues/5794 ?
[18:19:09] *** Quits: aeqwa (aeqwa@moz-97603595.dsl.tropolys.de) (Quit: Lost terminal)
[18:19:12] *** Joins: nawfel (Mibbit@603FD2B6.44158387.DFAB1F33.IP)
[18:20:05] <cmr> klutzy: ping
[18:20:23] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[18:20:23] *** ChanServ sets mode: +ao brson brson
[18:21:36] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[18:21:38] <jclements> acrichto: Actually, it's amazing how little I know about this part of the macro system :).  Presumably... you want a stack of source locations?
[18:22:02] <cmr> That stack *should* exist.
[18:22:11] *** Joins: paulproteus (quassel@moz-E86A3B42.makesad.us)
[18:22:13] *** Joins: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP)
[18:22:15] <acrichto> jclements: ah oh well, I suppose though, I haven't given it too much thought just yet
[18:22:25] <erickt> tjc: are you on a good path now? I was just about to step out for lunch
[18:22:44] <cmr> I'm pretty sure the ExtCtx or something around it has the macro expansion state?
[18:23:05] <acrichto> hm maybe this would be pretty easy to fix then
[18:23:28] <cmr> I thought they did print the full stack trace.
[18:23:37] <jclements> acrichto: I can see a stack of source locations as being useful.  One other thought; it seems like it might be really helpful to provide an error message that includes the offending arguments, no?
[18:23:58] <cmr> Maybe it's only in certain contexts.
[18:24:02] <cmr> But I definitely remember seeing one.
[18:24:03] *** Joins: ahal (ahal@13F2CEC5.7672369.D8E68FF6.IP)
[18:24:05] <tjc> erickt: yup, I'm good .thanks!
[18:24:09] <jclements> acrichto: for instance, in this case, seeing the format string would probably help a *lot*.
[18:24:18] <erickt> tjc: great! let me know if you run into more trouble
[18:24:28] <tjc> erickt: will do, thanks!
[18:25:04] <pauls> jclements: acrichto: Errors ought to be printing a stack trace already...
[18:25:05] <acrichto> jclements: yeah in theory for that bug the span points to the actual string, not the macro invocation of it
[18:25:27] <acrichto> pauls: yeah I'm not sure why this isn't doing that correctly...
[18:25:37] <acrichto> I suppose that's what the bug is :P
[18:25:46] <jclements> acrichto: fwiw, pauls knows a lot more about this part of the system than I do....
[18:26:17] <acrichto> pauls: ooooh, would you have any idea to the scope of that bug?
[18:26:40] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[18:26:50] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[18:29:32] <ecr> brson: I think I finished the homing refactoring/optimization. running the stress test now, but I haven't run into any deadlocks yet (~250/1000).
[18:29:51] <pauls> acrichto: I bet that there's something missing in expand.rs.
[18:29:51] *** Quits: jclements (jclements@moz-644F0E77.wireless.calpoly.edu) (Quit: jclements)
[18:29:52] <ecr> and of course it deadlocks literally when I send that
[18:29:57] *** Joins: ercax (ercan@moz-917BB3A7.dyn.optonline.net)
[18:30:12] <brson> ecr: lol
[18:31:08] <acrichto> pauls: yeah this is different from errors-after-expansion because rather it's errors-during-expansion
[18:31:18] <nawfel> hello, how can a supervisor task know that a child task failed?
[18:32:11] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[18:32:20] <pauls> acrichto: so, the line of code that I thought might be missing is: https://github.com/mozilla/rust/blob/master/src/libsyntax/ext/expand.rs#L68
[18:32:22] <brson> nawfel: use either task::try or create a task builder with task::task() and set up the notification channel with the future_result method
[18:32:27] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[18:32:48] <pauls> The question is, why isn't the syntactic backtrace properly populated at this point.
[18:33:11] *** Joins: maik (maik@moz-C5365941.dip0.t-ipconnect.de)
[18:33:21] <acrichto> interesting...
[18:33:25] <pauls> expand.rs is a little repetitive; perhaps some kinds of invocations are missing the bt_push
[18:33:33] <olsonjeffery> ecr: what's happnin' with homing?
[18:33:40] <pauls> Probably it's my fault.
[18:34:07] <ecr> olsonjeffery: I'm trying to optimize it so that it only yields if it needs to move to a different scheduler
[18:34:18] <ecr> instead of every time
[18:34:30] <pauls> Gosh, I can't wait until my wrists are good enough to work on Rust in the evenings again!
[18:34:31] *** Quits: a__ (a__@moz-25043B93.nycmny.fios.verizon.net) (Client exited)
[18:34:34] <pauls> They're getting there!
[18:34:45] <pauls> But I also have a paper deadline soon ) :
[18:34:50] <ecr> it required some refactorings, but it actually ended up more contained that before
[18:35:12] <ecr> it's pretty much all opaque now.
[18:35:26] *** Quits: nawfel (Mibbit@603FD2B6.44158387.DFAB1F33.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[18:36:27] *** Joins: a__ (a__@moz-25043B93.nycmny.fios.verizon.net)
[18:36:31] <olsonjeffery> ecr: i look forward to the massive rebase :)
[18:37:03] <luisbg> too much work today :( not enough time to play with Rust
[18:38:06] *** Joins: brendan (brendaneic@moz-C164C484.tmi.telenormobil.no)
[18:38:55] <ecr> olsonjeffery: it shouldn't be too bad. instead of a SchedHandle you have an IOHome. the only way to construct an IOHome is IOHome::new() [it gets a SchedHandle internally]. all of the IO handles now do this as part of their own ::new() function (instead of doing it manually). HomingIO::home() returns a reference to the IOHome so it's basically the same. oh, and home_for_io_consume goes away
[18:39:42] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[18:39:47] <acrichto> pauls: actually this looks to be more of a bug in the syntax extensions than anything else
[18:39:48] <nmatsakis> is anyone else hacking on trans at the moment?
[18:40:03] <acrichto> nmatsakis: strcat was doing stuff with sret which I don't think has landed yet
[18:40:06] <nmatsakis> I've been doing some work on #3511 and it's...somewhat disruptive.
[18:40:11] <nmatsakis> ok, shouldn't conflict too badly with that
[18:40:14] <ecr> if there's a big rebase problem, it'll be replacing explicit struct construction with an assoc function call
[18:40:22] <pauls> acrichto: hm. Oh, I haven't looked at the specifics.
[18:40:31] <strcat> nmatsakis: https://github.com/mozilla/rust/pull/9158 that's the extern fn fix btw
[18:40:46] <strcat> landing it separately from the other stuff because... it still hits an x86 crash
[18:40:50] <acrichto> pauls: actually, so each of the expanders is given a Span, and I think that the Span just points to the wrong spot
[18:41:01] <pauls> But I think that expand.rs should be doing that legwork every time it hits a `!`
[18:41:20] <nmatsakis> strcat: looks good
[18:41:24] * strcat might split out more of it
[18:41:33] <nmatsakis> strcat: what else are you wokring on that hits the crash?
[18:41:35] <acrichto> pauls: hmm, will investigate  more
[18:41:51] <strcat> nmatsakis: well, I added sret to rust functions and that causes the crash
[18:41:52] *** Quits: victorporof_ (victorporo@6CCF2761.6F48C38B.3EA6AAD8.IP) (Ping timeout)
[18:42:06] <nmatsakis> strcat: ah
[18:42:09] <strcat> nmatsakis: https://github.com/mozilla/rust/pull/9109 the rest of it
[18:42:42] <strcat> LLVM special cases `sret` to mean "this points at valid, properly aligned memory" which it doesn't usually assume of a ptr
[18:43:00] <strcat> I'm really tempted to submit a patch to LLVM adding a more general way to do that
[18:43:16] <strcat> but either way, we need a nice way of setting attributes on call insts
[18:43:33] <acrichto> pauls: what if I were to say that https://github.com/mozilla/rust/blob/master/src/libsyntax/ext/expand.rs#L80 the `mac.span` span is actually the wrong span to use?
[18:43:59] *** Joins: aeqwa (aeqwa@moz-97603595.dsl.tropolys.de)
[18:45:01] <acrichto> tjc: once bors starts processing the fileinput fix, I'll "@bors: retry" your request that just failed
[18:45:22] <strcat> nmatsakis: I suspect it's something about the wrapper generation in foreign.rs
[18:45:27] <strcat> but maybe it's not...
[18:45:40] * strcat suspected it was a lot of things, but ended up just finding *different* bugs
[18:45:54] <olsonjeffery> ecr: what do you mean by "associated function call" .. can you link to an example?
[18:45:57] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[18:45:58] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 147a83d53 to 147c8f503: 02http://git.io/N3iJvQ
[18:45:58] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[18:46:02] <strcat> static method?
[18:46:04] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[18:46:04] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/IWjkWg
[18:46:04] <ghrust> 13rust/06auto 14a7215dd 15Alex Crichton: Move glob tests to a run-pass test...
[18:46:04] <ghrust> 13rust/06auto 1405bbb48 15bors: auto merge of #9170 : alexcrichton/rust/flaky-fileinput, r=erickt...
[18:46:04] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[18:46:04] <acrichto> one of these days the number of bugs will go down!
[18:46:35] <tjc> acrichto: Ok, thanks!
[18:46:53] <ecr> olsonjeffery: it's just a function on a trait that doesn't take self.
[18:46:54] <pauls> acrichto: it's using `pth.span`. Maybe it ought to be using `mac.span`?
[18:46:57] <strcat> I'm tempted to add logging to rusti to see what people query it for ;p
[18:47:15] <strcat> rusti statistics!
[18:47:30] <strcat> % of successfully compiling inputs, top errors ;p
[18:47:33] <acrichto> tjc: so I've seen some spurious rustpkg failures recently, and it looks like one of the rustpkg tests uses change_dir_locked, so that may be the cause of the problems?
[18:47:37] <ecr> olsonjeffery: Local::take/put/borrow are examples
[18:47:49] <acrichto> it alos looks like there's more change_dir_locked in the tests that should be removed...
[18:47:56] <strcat> Local::borrow is where I hit my segfault :(
[18:48:12] <tjc> acrichto: might well be -- and yeah, that can be removed if I rewrite the tests to just shell out to rustpkg
[18:48:46] <ecr> strcat: which impl was it?
[18:49:08] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[18:49:12] <strcat> it dies in the annihilator reading some field from a struct
[18:49:15] <strcat> on the ret instruction
[18:49:24] <strcat> hm
[18:49:25] * strcat looks
[18:49:45] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[18:49:45] <strcat> ecr: anyway it's possibly my fault, or I'm possibly uncovering an existing bug
[18:50:18] <strcat>     let region = do Local::borrow |task: &mut Task| {
[18:50:20] <strcat>         task.heap.boxed_region
[18:50:22] <strcat>     };
[18:50:24] <strcat> that one
[18:50:36] <ecr> hm
[18:51:13] <ecr> and you get a segfault you say?
[18:51:32] <ecr> that's.... not good
[18:51:39] <strcat> well, I slightly altered the ABI rust uses to return structs
[18:51:52] <strcat> so it's possible something is hardcoded in foreign.rs or libstd in the wrong way...
[18:52:13] <ecr> maybe you invalidated something in std::rt::local_ptr
[18:52:25] <ecr> that's how Local::borrow for Task is impled
[18:52:32] *** Quits: ercax (ercan@moz-917BB3A7.dyn.optonline.net) (Quit: WeeChat 0.4.1)
[18:52:33] <strcat> hm
[18:52:35] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[18:53:28] <ecr> would your change have impacted thread local storage somehow?
[18:53:36] <strcat> possibly
[18:53:44] <strcat> it alters the ABI of something like 20% of our functions
[18:54:07] *** Quits: Amaranth (travis@moz-F81BB56A.cpe.cableone.net) (Ping timeout)
[18:54:08] <strcat> I'd say I'm 90% sure it's an issue between rust <-> foreign code
[18:54:12] *** Quits: wting (wting@4F978BD6.5564A9BA.9510F13D.IP) (Quit: Lost terminal)
[18:54:37] <strcat> foreign code calling rust wrong through an incorrect wrapper, etc.
[18:54:56] <ecr> well local_ptr is built on rt::thread_local_storage, which is foreign. it's possible
[18:55:17] <strcat> ecr: do you know anywhere where foreign code calls rust?
[18:55:22] <strcat> rather than rust calling foreign code
[18:55:23] <ecr> I don't really know anything about that part of the runtime. you'll have to ask brson
[18:56:01] *** Joins: Amaranth (travis@moz-F81BB56A.cpe.cableone.net)
[18:56:30] <ecr> brson: sigh. no deadlock when running tests sequentially, but deadlocks when running tests in parallel. going go try to narrow it down.
[18:56:56] *** Quits: jstevans (Instantbir@moz-735D8260.washdc.fios.verizon.net) (Ping timeout)
[18:57:34] <engla> SimonSapin: for the encodings API, I think &mut ~str  as output for a decoder is too specialized? Could we use Writer there instead some way?
[18:57:51] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[18:58:26] *** Joins: sebcrozet (sebcrozet@moz-C27D92D8.w193-252.abo.wanadoo.fr)
[18:58:38] *** Joins: wting (wting@4F978BD6.5564A9BA.9510F13D.IP)
[18:59:23] <luisbg> to edit a page in the github wiki, do you have to git clone, edit, and make a pull request? (like if it was code)
[18:59:38] <strcat> you can just edit it
[18:59:50] <strcat> from the web UI
[19:00:22] <kmc> but you can also clone the wiki as a repo if you want to
[19:00:30] <kmc> (it's not part of the main repo, and I think you can push directly rather than doing a PR)
[19:00:49] *** Quits: wting (wting@4F978BD6.5564A9BA.9510F13D.IP) (Quit: leaving)
[19:02:28] <luisbg> strcat, *facepalm* I was not logged into github, and the edit button wasn't showing
[19:04:13] *** Quits: brendan (brendaneic@moz-C164C484.tmi.telenormobil.no) (Ping timeout)
[19:04:46] *** Quits: lkuper (lkuper@moz-D862222C.dhcp-bl.indiana.edu) (Ping timeout)
[19:04:58] *** Joins: wting (wting@4F978BD6.5564A9BA.9510F13D.IP)
[19:05:05] *** Joins: aeqwa_ (aeqwa@moz-97603595.dsl.tropolys.de)
[19:05:07] *** Quits: aeqwa_ (aeqwa@moz-97603595.dsl.tropolys.de) (Quit: aeqwa_)
[19:05:10] *** Quits: aeqwa (aeqwa@moz-97603595.dsl.tropolys.de) (Quit: Lost terminal)
[19:05:28] *** Quits: wting (wting@4F978BD6.5564A9BA.9510F13D.IP) (Quit: leaving)
[19:05:30] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[19:05:33] *** Joins: aeqwa (aeqwa@moz-97603595.dsl.tropolys.de)
[19:05:59] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[19:06:20] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[19:07:02] *** Joins: wting (wting@4F978BD6.5564A9BA.9510F13D.IP)
[19:07:19] *** Joins: jeff_ (jeff@moz-E6A9E8C9.hsd1.or.comcast.net)
[19:08:03] *** Joins: eholk (eholk@4AFEE832.48D4C455.51B6877.IP)
[19:09:00] *** Quits: jeff_ (jeff@moz-E6A9E8C9.hsd1.or.comcast.net) (Ping timeout)
[19:09:12] <bjz> rusti: struct A<T>; impl A<int> { fn hi { println("hi") } } A::<int>::hi()
[19:09:13] -rusti- <anon>:5:42: 5:43 error: expected `(` but found `{`
[19:09:13] -rusti- <anon>:5          struct A<T>; impl A<int> { fn hi { println("hi") } } A::<int>::hi()
[19:09:13] -rusti-                                                    ^
[19:09:13] -rusti- application terminated with error code 101
[19:09:20] <bjz> rusti: struct A<T>; impl A<int> { fn hi() { println("hi") } } A::<int>::hi()
[19:09:23] -rusti- pastebinned 8 lines of output: http://ix.io/82d
[19:09:37] <tiffany> how do you do networking in rust?
[19:09:40] *** Quits: eholk (eholk@4AFEE832.48D4C455.51B6877.IP) (Quit: eholk)
[19:09:58] *** Quits: bheylin_ (brianheyli@moz-8255E94E.adsl.online.nl) (Quit: bheylin_)
[19:10:18] <bjz> pcwalton: :S
[19:10:20] <olsonjeffery> tiffany: std::rt::io::net
[19:10:25] <ecr> std::rt::io::net
[19:10:25] <olsonjeffery> in master
[19:10:29] <bjz> rusti: struct A<T>; impl A<int> { fn hi() { println("hi") } } A::hi()
[19:10:33] -rusti- hi
[19:10:33] -rusti- ()
[19:10:46] <bjz> oh
[19:10:57] <bjz> rusti: struct A<T>; impl A<int> { fn hi() { println("hi") } } impl A<uint> { fn hi() { println("hi") } }  A::hi()
[19:11:00] -rusti- pastebinned 8 lines of output: http://ix.io/82f
[19:11:19] <bjz> hum
[19:11:53] <bjz> rusti: struct A<T>; impl<T> A<T> { fn hi() { println("hi") } } A::hi()
[19:11:53] -rusti- <anon>:5:65: 5:70 error: cannot determine a type for this expression: unconstrained type
[19:11:54] -rusti- <anon>:5          struct A<T>; impl<T> A<T> { fn hi() { println("hi") } } A::hi()
[19:11:54] -rusti-                                                                           ^~~~~
[19:11:54] -rusti- error: aborting due to previous error
[19:11:55] -rusti- application terminated with error code 101
[19:12:03] <bjz> rusti: struct A<T>; impl<T> A<T> { fn hi() { println("hi") } } A::<int>::hi()
[19:12:04] -rusti- hi
[19:12:04] -rusti- ()
[19:12:28] <bjz> rusti: struct A<T>; impl<T> A<T> { fn hi() { println("hi") } } type Ai = A<int>; Ai::hi()
[19:12:30] -rusti- pastebinned 11 lines of output: http://ix.io/82g
[19:12:40] <luisbg> tiffany, what are you doing? networking related
[19:12:42] <luisbg> tiffany, just curious
[19:12:52] <tiffany> I'm thinking of writing a simple irc bot in rust
[19:13:25] *** Quits: maik (maik@moz-C5365941.dip0.t-ipconnect.de) (Ping timeout)
[19:13:30] <jzelinskie> is the source code for rusti (the bot) on github?
[19:14:04] <kimundi> jzelinskie: ask strcat 
[19:14:14] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Quit: Leaving)
[19:14:52] *** Joins: carllerche (carllerche@1E2EB9E3.186539A3.965084DF.IP)
[19:15:54] <bjz> pcwalton: any thoughts on: struct A<T>; impl A<int> { fn hi() { println("hi") } } impl A<uint> { fn hi() { println("hi") } }  A::hi() ?
[19:16:30] <ecr> tiffany: that should be a pretty good test for the networking code
[19:16:47] <pcwalton> namespacing under types?
[19:16:53] <pcwalton> I think that might be undecidable
[19:17:17] <luisbg> tiffany, cool!
[19:17:18] <strcat> jzelinskie: kind of. the sandbox it uses is online, as is the web version of the bot
[19:17:29] <luisbg> tiffany, that is a great idea
[19:17:30] *** Quits: sebcrozet (sebcrozet@moz-C27D92D8.w193-252.abo.wanadoo.fr) (Ping timeout)
[19:17:39] <strcat> the bot script itself is quickly hacked together and has stuff like nickserv passwords in it ;p, so no
[19:17:43] <tiffany> will from_str on SocketAddr do dns lookups?
[19:17:44] *** Joins: cstrahan (cstrahan@DB1CB554.80B5DDE4.2D737EA7.IP)
[19:17:46] <strcat> https://github.com/thestinger/rust-playpen
[19:18:01] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[19:18:11] <jzelinskie> you should put them into environment variables and open it up for improvement :)
[19:19:06] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[19:19:32] *** Quits: lmandel (lmandel@13F2CEC5.7672369.D8E68FF6.IP) (Quit: lmandel)
[19:20:51] *** Joins: bheylin_ (brianheyli@moz-8255E94E.adsl.online.nl)
[19:22:14] *** Joins: victorporof (victorporo@6CCF2761.6F48C38B.3EA6AAD8.IP)
[19:22:56] *** Joins: hoverbear (andrew@moz-EA72C57C.wireless.uvic.ca)
[19:23:05] <ecr> tiffany: no. you need to use std::rt::io::net::get_host_addresses(host: &str) -> Option<~[IpAddr]>
[19:24:50] *** Parts: lbergstrom (Adium@moz-BBE3ABD.mv.mozilla.com) ()
[19:24:56] *** Joins: lbergstrom (Adium@moz-BBE3ABD.mv.mozilla.com)
[19:25:21] <bjz> pcwalton: why would it be undecidable?
[19:25:44] <luisbg> ecr, it is good that "use" can shorten that long path name
[19:25:55] <jeaye> Speaking of namespacing...
[19:25:57] <pcwalton> because of things like subtyping constraints
[19:25:59] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[19:26:01] * jeaye reignites 'enum mod'
[19:26:11] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[19:26:16] <ecr> luisbg: indeed
[19:26:20] <pcwalton> impl A<Supertype> { ... } impl A<Subtype> { ... }
[19:26:20] <luisbg> :)
[19:26:27] <pcwalton> what does A::hi() do ?
[19:26:35] <doomlord> what would enum mod do
[19:26:58] *** Quits: victorporof (victorporo@6CCF2761.6F48C38B.3EA6AAD8.IP) (Quit: victorporof)
[19:27:04] <jeaye> doomlord: What 'enum class' does in C++11
[19:27:14] *** Quits: Palmik (palmik@moz-CC484FDD.tmcz.cz) (Ping timeout)
[19:27:22] <ecr> for use non-C++ programmers, what would that be?
[19:27:22] <jeaye> enum mod Foo { Bar, Spam } is used as Foo::Bar, Foo::Spam
[19:28:01] <cmr> Most importantly you'd be able to do `use some_module::some_enum::*` to get all the variants in scope
[19:28:02] <jeaye> It'd also allow you to 'use' a whole enum instead of each of its variants.
[19:28:08] <jeaye> Gar, cmr 
[19:28:10] <cmr> Without the rest of the module.
[19:28:10] <jeaye> :P
[19:28:33] <bjz> pcwalton: I tried with A::<int>::hi(), but that doesn't seem to work.
[19:28:43] *** Joins: maik (maik@moz-C5365941.dip0.t-ipconnect.de)
[19:28:52] <pcwalton> yeah, that probably should
[19:28:58] <pcwalton> if you don't have separate methods there
[19:29:39] <bjz> tricky tricky isn't it
[19:29:42] <bjz> what do you mean by separate methods?
[19:31:08] <kmc> how do I convert an &mut T to an &T?
[19:31:28] <cmr> kmc: &*foo, perhaps?
[19:31:43] <cmr> That might not work, since the borrow will still be active.
[19:31:51] <kmc> that works, thanks. wondering if there was a more explicit way
[19:31:58] <kmc> 'as' doesn't work :/
[19:31:58] *** Joins: victorporof (victorporo@6CCF2761.6F48C38B.3EA6AAD8.IP)
[19:31:58] *** Joins: steveklabnik (steveklabn@moz-5EF6C37C.socal.res.rr.com)
[19:32:18] <pcwalton> I mean a different implementation for A<int> and A<uint>
[19:32:22] <pcwalton> that's where subtyping starts to hurt
[19:32:30] <steveklabnik> hey all! quick question about rust and linear types
[19:32:37] <pcwalton> furthermore the way resolve is implemented that's not easily doable
[19:32:41] <steveklabnik> ... are they only supported via ownership types or can you make your own linear type?
[19:32:44] <pcwalton> since resolve of all static methods happens before subtyping
[19:32:46] <pcwalton> err
[19:32:47] *** Quits: victorporof (victorporo@6CCF2761.6F48C38B.3EA6AAD8.IP) (Quit: victorporof)
[19:32:49] <pcwalton> before typechecking
[19:33:03] <cmr> steveklabnik: rust has affine types, and what do you mean by "make your own"?
[19:33:08] *** Joins: sebcrozet (sebcrozet@moz-F96421F3.w80-13.abo.wanadoo.fr)
[19:33:14] <steveklabnik> cmr: can i make my own 'consumable' type
[19:33:15] <cmr> rusti: struct Foo; let x = Foo; let y = x; x
[19:33:15] -rusti- <anon>:5:38: 5:39 warning: unused variable: `y` [-W unused-variable (default)]
[19:33:16] -rusti- <anon>:5          struct Foo; let x = Foo; let y = x; x
[19:33:16] -rusti-                                                ^
[19:33:16] -rusti- main::Foo
[19:33:32] <pcwalton> steveklabnik: you can, by embedding util::noncopyable
[19:33:34] <cmr> rusti: struct Foo; impl Drop for Foo { fn drop(&self) { println("drop") } } let x = Foo; let y = x; x
[19:33:37] -rusti- pastebinned 8 lines of output: http://ix.io/82h
[19:33:46] <pcwalton> we've talked about making it easier
[19:33:49] <pcwalton> by providing an attribute
[19:33:53] <cmr> Also implementing Drop
[19:33:58] <pcwalton> yes
[19:34:02] <steveklabnik> pcwalton: cool. cmr as well, i've been thinking about https://github.com/mozilla/rust/wiki/Lib-html
[19:34:09] <engla> steveklabnik: just implement Drop (a destructor)
[19:34:10] <steveklabnik> in rails, we basically provide an 'unescaped string' type
[19:34:23] <steveklabnik> that you need to verify to make a safe string
[19:34:28] <steveklabnik> and unsafe strings refuse to be output
[19:34:37] <steveklabnik> was thinking an approach like that could be interesting/useful
[19:34:38] <cmr> steveklabnik: I think that's a usecase for phantom types?
[19:34:41] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[19:34:43] <cmr> There was a blog post about it fairly recently.
[19:34:47] <steveklabnik> i am unfamilliar with phantom types
[19:34:50] <steveklabnik> i'll search for the blog post
[19:34:56] <steveklabnik> ha
[19:35:02] <steveklabnik> it's purple in my browser o_O
[19:35:04] <steveklabnik> http://bluishcoder.co.nz/2013/08/15/phantom_types_in_rust.html
[19:35:17] <cmr> Yup, that's the one
[19:35:33] <cmr> Hah, it even uses that as the motivating example.
[19:35:41] <steveklabnik> lmao
[19:35:42] <kmc> you don't need phantom types for that, though
[19:35:56] <kmc> you just need safe string and unsafe string to be different types
[19:36:02] <steveklabnik> right
[19:36:08] <kmc> one can be a struct wrapping the other, exported in such a way that you can only go through the safe accessors
[19:36:17] <steveklabnik> absolutely, that's how it's done in rails, basically
[19:36:20] *** Quits: hoverbear (andrew@moz-EA72C57C.wireless.uvic.ca) (Quit: hoverbear)
[19:36:28] <steveklabnik> i'd like to show ruby people how a staticly typed approach can help them
[19:36:37] <steveklabnik> if it's implemented the same way as rails, that's no fun ;)
[19:36:41] <kmc> I guess the benefit of phantom types would be writing code that's generic over both kinds of strings
[19:36:53] <kmc> sure but if it's implemented in a needlessly complicated way, that's not the best foot forward for static types ;)
[19:36:55] <cmr> steveklabnik: also re: rfr, are you going to update that for 0.8 or can I?
[19:37:13] <steveklabnik> cmr: you can. i've been looking into tooling, so i can just use pandoc
[19:37:18] <kmc> steveklabnik: well isn't it enough to say "we can do the same thing but now it's a compiler error rather than a runtime error"
[19:37:19] <steveklabnik> rather than going through dexy
[19:37:23] <cmr> ok
[19:37:36] <cmr> I tried playing with dexy to get syntax highlighting but couldn't get it going
[19:37:41] <steveklabnik> kmc: sure.
[19:37:48] <kmc> that way you're not giving the impression that static typing requires one to learn new concepts with scary names like "phantom"
[19:38:18] <steveklabnik> yeah this just might be my personality shining through
[19:39:14] <steveklabnik> cmr: you can do it at your leasure, i wont deploy again till after 0.8 is out
[19:39:39] <cmr> steveklabnik: alright cool
[19:40:00] *** Joins: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[19:40:08] <cmr> steveklabnik: I'm afraid of doing any major updates because I really like the tone and style of rfr, and I don't think I could maintain it
[19:40:12] <steveklabnik> :)
[19:40:16] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[19:40:32] <steveklabnik> it's all good. you can also open PRs and i can do that part before merging
[19:40:44] <cmr> ok
[19:40:47] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Quit: Gone to save the world!)
[19:40:54] <steveklabnik> glad you like the tone and style, i've been fantasizing about re-writing the official tutorial before 1.0 happens ;)
[19:41:00] <steveklabnik> no promises there
[19:41:44] <olsonjeffery> "Many have tried to rewrite the tutorial." "Tried and failed?" "Tried.. and DIED!"
[19:42:01] <steveklabnik> ha
[19:42:09] <steveklabnik> i just need to write more rust code first
[19:42:18] <steveklabnik> i have to find some projects where i can actually use it
[19:42:27] <steveklabnik> and not just teeny little throwaway things
[19:42:37] <olsonjeffery> write a diplomacy solver
[19:43:35] <steveklabnik> the board game?
[19:43:46] <olsonjeffery> yeah.
[19:44:18] *** jdm is now known as jdm|f00ding
[19:44:20] <olsonjeffery> like you hand it the current board state and a set of orders, and it emits a new board state
[19:44:27] <olsonjeffery> ive thought about doing it for a while.
[19:44:27] <steveklabnik> yeah, makes sense
[19:44:52] <olsonjeffery> also doing a quicky minecraft clone would be fun
[19:45:02] <olsonjeffery> and the opengl-related bindings are pretty well maintained
[19:45:03] <steveklabnik> i have a carcassonne tattoo, so I think i'd end up doing that ;)
[19:45:06] <steveklabnik> oh yeah?
[19:46:17] <olsonjeffery> im just rambling about projects that're on my mind
[19:46:26] <olsonjeffery> but working on newrt IO keeps me busy for the most part
[19:46:30] <bjz_> pcwalton: cheers, thanks for the info
[19:47:12] <bjz_> pcwalton: what do you mean when you use the term 'subtyping' here? specialisation?
[19:50:44] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[19:50:48] *** Quits: jgilbert (jgilbert@40BD3B76.2AD327F9.973C8D27.IP) (Ping timeout)
[19:50:53] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[19:51:00] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[19:51:00] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/IWjkWg
[19:51:00] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[19:52:53] *** Joins: jgilbert (jgilbert@40BD3B76.2AD327F9.973C8D27.IP)
[19:53:43] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[19:55:06] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[19:55:23] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: zzzzzzzzzz)
[19:55:57] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[19:55:57] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/Gz_bag
[19:55:57] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[19:55:58] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[19:55:58] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/xri49Q
[19:55:58] <ghrust> 13rust/06auto 1424fdb1d 15Tim Chevalier: rustc/rustpkg: Use a target-specific subdirectory in build/ and lib/...
[19:55:58] <ghrust> 13rust/06auto 14b81743e 15bors: auto merge of #9151 : catamorphism/rust/rustpkg-target-specific-subdirectory, r=brson...
[19:55:58] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[19:56:56] *** Joins: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[19:57:11] <tiffany> tiffbot.rc:10:33: 10:53 error: unresolved name `SocketAddr::from_str`.
[19:57:12] <tiffany> uhh
[19:57:40] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[19:57:56] *** Quits: maik (maik@moz-C5365941.dip0.t-ipconnect.de) (Ping timeout)
[19:58:04] <tiffany> oh
[19:58:04] *** Joins: hoverbear (andrew@moz-EA72C57C.wireless.uvic.ca)
[19:58:09] *** Joins: adridu59 (Mibbit@moz-6C393FDD.rev.numericable.fr)
[19:58:12] <tiffany> I use FromStr::from_str and it resolves which impl to use
[19:58:34] <adridu59> I have a 2d array of ints to pass to a function, what is the corresponding (mutable) type parameter?
[19:58:38] <cmr> Also note the from_str free function.
[19:58:44] <cmr> adridu59: ~[~[int]] ?
[20:00:15] <adridu59> cmr:: I must declare my 2d array with ~ then?
[20:00:24] <cmr> adridu59: What are you declaring it with now?
[20:00:40] <adridu59> uints but declaring as int
[20:01:33] <steveh> adridu59: which declaration, function parameter?
[20:02:11] <adridu59> steveh: what do you mean?
[20:02:39] <steveh> There may be an outer context which you want to own it, while the function just borrows it
[20:02:39] <strcat> adridu59: &mut [T] is a mutable slice but it's not clear exactly what you want
[20:02:59] <adridu59> I don't want to mut it in fact
[20:03:03] <adridu59> I just realized
[20:03:27] <adridu59> what do I have to pass for a non-mutable 2d array?
[20:03:49] <adridu59> I declared as: [[a,b][c,d]]
[20:03:53] *** Quits: hoverbear (andrew@moz-EA72C57C.wireless.uvic.ca) (Quit: hoverbear)
[20:04:07] *** Quits: sebcrozet (sebcrozet@moz-F96421F3.w80-13.abo.wanadoo.fr) (Ping timeout)
[20:04:18] <engla> adridu59: so the type is then [[uint, ..2], ..2] 
[20:04:56] <tiffany> I got an ICE
[20:05:10] <tiffany> task <unnamed> failed at 'assertion failed: rp.is_none()', /home/tiffany/Projects/rust/src/librustc/middle/typeck/collect.rs:1108
[20:05:19] <adridu59> engla: looks good thank you, I have another minor problem
[20:05:40] <kimundi> he
[20:05:46] <engla> adridu59: you can pass it by value, or as a slice that would be  &[[uint, ..2]]
[20:06:08] <adridu59> I have "expected uint but found int" when I try to extract a value e.g array[a][i+j] it will give warning for j, maybe needs parenthesis?
[20:06:21] <engla> indices should be uint
[20:06:56] <strcat> engla: can also pass a borrowed pointer to the outer fixed-size array if you want to enforce the size
[20:07:05] <cmr> I think Windows is 100% broken right now.
[20:07:07] * kimundi 's internet finally decided it wanted to load unicode.org after all, prepares to edit that wiki page with citations, notices strcat already did all that hours ago
[20:07:09] <cmr> We don't generate .lib's
[20:07:22] <cmr> Unless gcc does things very different from the MS toolchain
[20:07:26] <strcat> kimundi: wikipedia makes me sad
[20:07:29] <cmr> It's impossible to link against a rust library on windows?
[20:07:30] <engla> adridu59: ok maybe indices don't need to be uint hehe
[20:07:34] <strcat> I edited the UTF-8 page for accuracy ages ago
[20:07:42] <strcat> and ofc it was all reverted and even more incorrect stuff added
[20:08:04] <kimundi> strcat: :|
[20:08:11] <adridu59> engla: it does, thank you :) I forgot about the "u" suffix in my range args
[20:08:25] <Ralith> wikipedia is a lost cause
[20:08:39] <olsonjeffery> getting a "Bus Error: 10" error when running make check-stage1-std
[20:08:46] <olsonjeffery> is that a segfault.. ?
[20:08:59] <strcat> olsonjeffery: likely a stack overflow
[20:09:01] <engla> strcat: a bit sad they show the 6-byte variant in the table...
[20:09:16] <strcat> engla: the one I linked? I can find a better source...
[20:09:25] <olsonjeffery> strcat: ty.
[20:09:30] <engla> strcat: The wikipedia page for UTF-8
[20:09:33] <strcat> oh
[20:09:55] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[20:10:09] <strcat> at least it's clear that it's 4 bytes at most now
[20:10:15] <engla> yeah
[20:14:21] <adridu59> rusti: for i in range(5,0) { printf!(i); }
[20:14:53] <adridu59> is rusti offline?
[20:14:55] -rusti- ()
[20:15:02] <adridu59> can the range() function decrease?
[20:15:17] <cmr> rusti: for i in range(0, 5).invert() { printf!(i) }
[20:15:17] -rusti- 43210()
[20:15:46] <tiffany> rusti: for i in range(5, 0) {printf!(i)}
[20:15:47] -rusti- ()
[20:15:54] <tiffany> oh oops
[20:16:01] <adridu59> nice cmr
[20:18:37] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Quit: WeeChat 0.4.1)
[20:21:13] *** Quits: nsf (nsf@moz-EEF3238A.convex.ru) (Quit: WeeChat 0.4.1)
[20:23:28] <tiffany> how do you add a type constraint on a trait call?
[20:23:54] <tiffany> nevermind
[20:26:19] <kimundi> Hmmm...
[20:26:57] <tiffany> http://paste.strictfp.com/39222 uhh
[20:28:10] * kimundi thinks he is going to add a few extension methods once the encoding story is sorted out - (~[98u8,99,100]).decode_into::<Utf8>()
[20:28:25] *** Quits: heftig (heftig@moz-A00845E7.dip0.t-ipconnect.de) (Quit: Quitting)
[20:30:52] *** Quits: steveklabnik (steveklabn@moz-5EF6C37C.socal.res.rr.com) (Quit: Lost terminal)
[20:31:37] <mcpherrin> I have a foo.rs that runs fine.  Now, I take the main function out of that file and put it in test.rs along with "mod foo;".  Now it can't resolve a bunch of names like std::path::Path
[20:31:41] <mcpherrin> wtf???
[20:32:08] <mcpherrin> I really don't understand name resolution in rust.  It seems completely insane.
[20:32:27] *** Joins: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP)
[20:32:32] <mcpherrin> I'm never sure if something is a bug or just weird expected behaviour.
[20:33:21] *** Joins: Diamond (dick@moz-63AD8970.ks.ok.cox.net)
[20:33:43] <tiffany> mcpherrin: mod foo; use foo::*; I think
[20:33:53] <tiffany> well, it'd be the other way around
[20:35:16] <strcat> mcpherrin: you need 'use std;' in submodules, don't know why
[20:35:50] <strcat> acrichto: about format!() - do you see a problem with giving a list of valid escapes in string literals, and passing them through?
[20:35:54] <strcat> I don't really get it
[20:36:09] <strcat> it currently has you use \{ or \} to escape
[20:36:13] <acrichto> strcat: could you explain that a little more? I don't think I quite get it
[20:36:14] <mcpherrin> strcat: wtf, okay, that fixes it.  Not something I'd expect at all.
[20:36:20] <strcat> acrichto: I mean lets say you have
[20:36:34] <strcat> "fn main \{\n\}"
[20:36:35] <acrichto> strcat: like, format!("\{ \} \# \\") becomes "{ } # \"
[20:36:50] <strcat> so that would become
[20:36:55] <strcat> "fn main {\n}"
[20:36:58] <strcat> it would just pass-through \n
[20:37:01] <strcat> or \\
[20:37:19] <strcat> so essentially it would be an extension of the string escapes, and leave the existing ones as-is
[20:37:28] <strcat> but maybe it can't do that
[20:37:30] <acrichto> would this work in general for all strings?
[20:37:35] <strcat> acrichto: it seems like it would
[20:37:41] <strcat> as long as \{ and \} aren't ever regular escapes
[20:37:50] *** Quits: io2 (io2@moz-A6202C16.home.otenet.gr) (Quit: )
[20:38:10] <acrichto> this would not be trivial
[20:38:12] <strcat> acrichto: so if you see, \ - you only handle it if it has { or } after it
[20:38:14] <acrichto> it'd involve changing the parser
[20:38:16] <strcat> otherwise, pass it through
[20:38:32] <strcat> acrichto: but how do you currently find the \{, \}?
[20:38:41] <acrichto> it's a string literal
[20:38:43] * kimundi points mcpherrin to the recently rewritten module tutorial
[20:38:45] <acrichto> so it's been pre-parsed
[20:38:52] <strcat> acrichto: you're able to distinguish \{ from {, though
[20:38:56] <acrichto> so the string that the pparser looks at actually is "\{ \}"
[20:39:00] <strcat> even though in a regular literal they become the same thing
[20:39:12] <acrichto> as a string literal you type "\\{ \\}" though
[20:39:27] <strcat> I mean to actually write "{ }"
[20:39:28] <kimundi> strcat: wait, what? 'use std;'? Is that a recent bug?
[20:39:39] <strcat> rusti: "{ }"
[20:39:40] -rusti- "{ }"
[20:39:42] <strcat> rusti: "\{ \}"
[20:39:42] -rusti- <anon>:4:12: 4:13 error: unknown string escape: 123
[20:39:42] -rusti- <anon>:4     let r = {
[20:39:42] -rusti-                      ^
[20:39:42] -rusti- application terminated with error code 101
[20:39:55] <strcat> oh that doesn't work :s
[20:39:56] *** Quits: txdv (quassel@966F3542.3BA477DA.14C26596.IP) (Connection reset by peer)
[20:40:03] <strcat> anyway
[20:40:22] *** Joins: txdv (quassel@966F3542.3BA477DA.14C26596.IP)
[20:40:23] <strcat> acrichto: so you're saying the parser passes through \{, but it turns \n into something else?
[20:40:34] <acrichto> well there's two parsers here
[20:40:36] <acrichto> one is the rust parser
[20:40:39] <acrichto> the other is the format parser
[20:40:50] <acrichto> "\\{" => rust parser => "\{" => format parser => "{"
[20:41:01] <kimundi> mcpherrin: Were the 'std::path::Path' part of an use-path or of an expression?
[20:41:08] <strcat> acrichto: how do I escape { } in format!
[20:41:16] <strcat> show an example of that
[20:41:17] <acrichto> rusti: format!("\\{")
[20:41:18] -rusti- ~"{"
[20:41:19] <strcat> oh
[20:41:27] <acrichto> rusti: format!("\\\\")
[20:41:28] -rusti- ~"\\"
[20:41:29] <strcat> okay, I understand what you're saying now
[20:41:35] <acrichto> rusti: print!("\\\\")
[20:41:36] -rusti- \()
[20:41:43] <acrichto> it's confusing...
[20:41:48] <mcpherrin> kimundi: expression
[20:41:53] <strcat> yeah I thought you could escape it as \{
[20:42:08] <acrichto> strcat: I think if we did your thing then *rust as a language* would have "\{" be an escape sequence for "\{"
[20:42:09] <strcat> didn't realize the rust string parsing ran first, then yours, then the rust one againb
[20:42:20] <acrichto> yeah that's the reason for the double all the time
[20:42:34] <strcat> there's no way to make the rust string parsing not run first?
[20:42:59] <acrichto> I don't think so
[20:43:00] <mcpherrin> kimundi:  pub fn slurp(name: &str) -> ~[u8] { std::io::file_reader(&std::path::Path(name)).unwrap().read_whole_stream() }
[20:43:02] *** Joins: heftig (heftig@moz-A00845E7.dip0.t-ipconnect.de)
[20:43:11] <acrichto> strcat: the parser works off a token tree, and I think that a string literal is one token
[20:43:12] <kimundi> mcpherrin: Ah, that explains it. paths lookups in an expression are allways relative to what has been brough in scope. In case of fn main() in the crate root, the implicit 'extern mod std' brough std into scope, just like a regule mod foo { ...} would be in scope per default
[20:43:39] *** Joins: sao (Mibbit@moz-3D556E4B.amazon.com)
[20:43:57] <kimundi> mcpherrin: If you want to refer to something with an global path in an expression, you have to prefix it with a '::'
[20:44:22] <olsonjeffery> today's Rust Lesson: don't make a newtype wrapper of a type that's going to have identical methods-names that you'll be implementing on the newtype'd value. it's recipe for endless recursion
[20:44:23] <kimundi> mcpherrin: ::std::path::Path in an expression will work everywhere
[20:45:18] *** Quits: lenstr (lenstr@AF8EB999.6049B16A.85938D85.IP) (Client exited)
[20:45:27] <mcpherrin> kimundi: Okay, that makes sense.  I had assumed foo::bar::baz would resolve if ::foo::bar::baz would
[20:46:52] <kimundi> mcpherrin: Basically, if you use an non-global path in an expression, rustc will only look at all local definitions, followed by all names bough in scope with use.
[20:47:08] *** Joins: tikue (tkuehn@81D59667.DF8FC23A.689607DE.IP)
[20:47:13] <sao> does anybody know of any projects that I could look at that would demonstrate how protocols work?
[20:47:23] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[20:47:34] <cmr> sao: As in the proto! syntax extension?
[20:47:43] <sao> cmr: yes
[20:47:48] <olsonjeffery> protocols were removed weren't they?
[20:47:51] <cmr> I thought so yeah
[20:47:53] <olsonjeffery> due to bitrot and lack of use in newrt
[20:47:58] *** Quits: tikue (tkuehn@81D59667.DF8FC23A.689607DE.IP) (Quit: tikue)
[20:48:02] <cmr> If they weren't, they will be soon, because of dubious utility.
[20:48:07] <cmr> And significant maintenance burden.
[20:48:08] <sao> crap
[20:48:12] <olsonjeffery> sorry!
[20:48:32] <sao> is there some new replacement pattern?
[20:48:41] <olsonjeffery> they're quite novel.. the non-protocol-based port/chan impl in newrt ended up being way way faster
[20:48:52] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[20:49:05] <sao> the same one described in the tasks tutorials?
[20:49:06] <olsonjeffery> i think that was why their use was deprecated
[20:49:15] <olsonjeffery> and then they ended up not getting used, besides that..
[20:49:21] <olsonjeffery> sao: heh.
[20:49:31] <olsonjeffery> brson: ^ ?
[20:49:45] <sao> the port/chan impl
[20:50:32] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Ping timeout)
[20:50:45] *** Quits: steveh (Mibbit@moz-7A900440.fda.gov) (Quit: http://www.mibbit.com ajax IRC Client)
[20:50:48] *** Joins: maik (maik@moz-C5365941.dip0.t-ipconnect.de)
[20:52:06] <kimundi> strcat: "you need 'use std;' in submodules, don't know why" - Did my explanation clear things up? ;)
[20:52:07] *** Quits: squiddy (squiddy@moz-D37EFEA9.adsl.alicedsl.de) (Quit: Leaving)
[20:52:23] <strcat> yes
[20:52:42] <kimundi> yay ^^
[20:53:30] *** Parts: kauschovar (kauschovar@moz-471C668F.hsd1.ca.comcast.net) ()
[20:56:13] *** Quits: maik (maik@moz-C5365941.dip0.t-ipconnect.de) (Ping timeout)
[20:59:59] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[21:00:23] <SimonSapin> engla: but Writer represents bytes, right? The point of ~str is to be decoded text
[21:00:40] *** Quits: sao (Mibbit@moz-3D556E4B.amazon.com) (Quit: http://www.mibbit.com ajax IRC Client)
[21:00:40] <SimonSapin> engla: also, writing a single char in a tight loop has top be really cheap
[21:01:21] *** Quits: heftig (heftig@moz-A00845E7.dip0.t-ipconnect.de) (Quit: Quitting)
[21:01:25] <engla> SimonSapin: of course, it might need be something Writer-like. maybe "StringWriter" (something with a string api that can be backed by a Writer, or by a ~str)
[21:01:43] *** Joins: heftig (heftig@moz-A00845E7.dip0.t-ipconnect.de)
[21:01:51] <engla> isn't allocating and pushing into a ~str just an unecessary intermediate buffer in many cases?
[21:02:13] <SimonSapin> I suppose it depends on what youâ€™re doing
[21:02:39] <engla> also, if some decoders work by computing codepoints anyway, you could have a ~[char] backend for the writer and come out on performance plus too  for some combinations
[21:03:12] * kimundi thinks it would be nice if you could tread a ~[u8] through an decoder to get an ~str without allocating a new buffer in case it is correct
[21:03:16] *** Joins: lmandel (lmandel@moz-76CE9D51.cable.teksavvy.com)
[21:03:32] <strcat> you can
[21:03:36] <SimonSapin> thatâ€™s quite specialized to UTF-8
[21:03:45] <SimonSapin> it doesnâ€™t have to be part of the encoding API
[21:04:01] <kimundi> let s: ~str = (~[98u8,99,100]).decode_into::<Utf8>();
[21:04:02] <strcat> str::from_utf8_owned
[21:04:10] <kimundi> strcat: sure
[21:04:14] <kimundi> It's possible
[21:04:26] *** Quits: adridu59 (Mibbit@moz-6C393FDD.rev.numericable.fr) (Quit: http://www.mibbit.com ajax IRC Client)
[21:04:57] <kimundi> My point is just that it would be nice if the api ends up generically enough that you don't need to special case that operation :)
[21:05:08] <engla> SimonSapin: I think a Writer-like abstraction is needed. A StringWriter { fn write_char, fn write_str }  can be implemented efficiently by both ~str and Writer
[21:05:54] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[21:05:54] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/xri49Q
[21:05:54] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[21:05:56] <SimonSapin> kimundi: I think thatâ€™s too much
[21:06:16] *** Quits: miza (miza@moz-908EA8DE.home.otenet.gr) (Input/output error)
[21:06:55] <SimonSapin> engla: it could also open the door to Servo using whatever it needs to
[21:06:57] <kimundi> SimonSapin: It's more htan neccessary, I agree. But would you be opposed if a design would be found that allows it anyway?
[21:07:32] <SimonSapin> kimundi: show me one ;)
[21:07:49] <kimundi> SimonSapin: I keep thinking about it ;)
[21:08:26] <engla> SimonSapin: ok, what would it need to do there?
[21:08:39] <SimonSapin> kimundi: I think itâ€™s find to have str::from_utf8_owned that may share code with the UTF-8 decoder but is not part of the encoding API weâ€™re designing here
[21:08:56] <engla> SimonSapin: yeah a ~[u16] could implement StringWriter. It wouldn't necessarily be efficient though (not sure?)
[21:09:15] <SimonSapin> engla: JS "strings" are basically [u16], and they basically infect everything else in the browser if we want to avoid many conversions
[21:09:26] <cmr> Has anyone succesfully cross-compiled rust to i686-pc-mingw from linux?
[21:09:30] <strcat> JS strings aren't UTF-16 though
[21:09:45] <strcat> they allow things UTF-16 doesn't allow
[21:09:49] <SimonSapin> yes
[21:10:01] <cmr> I'm getting https://gist.github.com/anonymous/15b89174d8b9a912fa68
[21:10:09] <mcpherrin> JS strings are UCS-2?
[21:10:18] <SimonSapin> but decoding eg. UTF-8 to a JS string will give you a [u16] that happens to contain valid UTF-16
[21:10:32] <cmr> mcpherrin: JS strings are arrays of 16-bit unsigned bytes.
[21:10:39] <engla> SimonSapin: yep, sounds good
[21:10:44] <cmr> s/bytes/ints
[21:10:51] <strcat> acrichto: for some reason we're generating non-inbounds GEPs again...
[21:10:52] <strcat> hm
[21:10:55] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[21:10:55] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/96x7og
[21:10:55] <ghrust> 13rust/06auto 141ac37d5 15Daniel Micay: set sret attribute as needed on call instructions...
[21:10:55] <ghrust> 13rust/06auto 14150b4ff 15bors: auto merge of #9158 : thestinger/rust/extern, r=alexcrichton...
[21:10:56] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[21:10:57] <mcpherrin> cmr: gross :P
[21:11:04] <mcpherrin> (But it's JS, what isn't gross?)
[21:11:08] <SimonSapin> engla: cool. Iâ€™m sold on the StringWriter or similar API
[21:11:08] <acrichto> strcat: with sret?
[21:11:13] <strcat> acrichto: no separate issue
[21:11:16] <strcat> ptr::offset
[21:11:20] <strcat> lemme look at it
[21:11:26] <acrichto> whoa
[21:11:37] <acrichto> the rabbit hole continues..
[21:12:16] <strcat> oh um
[21:12:28] <strcat> why is it split into offset + offset_inbounds again?
[21:12:44] <strcat> simple bug
[21:13:27] <acrichto> strcat: wait offset_inbounsd shouldn't exist
[21:13:35] <strcat> right but normal offset is not using inbounds atm
[21:13:37] <acrichto> apparently it still exists in trans/intrinsics.rs by accident
[21:13:39] <strcat> it's supposed to be
[21:13:47] <acrichto> offset is inbounds
[21:13:49] <acrichto> the intrinsic
[21:13:52] <acrichto> or rather it should be
[21:13:55] <strcat> it should be, but it's not
[21:14:05] <acrichto> oh argh
[21:14:09] <acrichto> botched merge :(
[21:14:13] *** Joins: tikue (tkuehn@18398DD2.28259105.689607DE.IP)
[21:14:33] <acrichto> yeah lines 405-409 in trans/intrinsic.rs should be deleted
[21:14:38] *** Joins: brendan (brendaneic@5FC4E4D8.4EE99619.E46D6E17.IP)
[21:14:59] <strcat> acrichto: https://github.com/mozilla/rust/pull/9173 r?
[21:16:28] <strcat> anyway I can stop worrying about that now ;p
[21:16:43] <strcat> I really wish the sret thing would work
[21:18:50] *** Joins: Azdle (Azdle@moz-B334B496.hfc.comcastbusiness.net)
[21:20:17] *** Joins: lilybet (Mibbit@BA5E2E6C.F52DD833.33E9DF57.IP)
[21:20:44] *** Quits: lilybet (Mibbit@BA5E2E6C.F52DD833.33E9DF57.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[21:21:03] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[21:21:14] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[21:22:28] <SimonSapin> engla: I suppose encoders could use Writer, but all implementations other than UTF-8 in rust-encoding only ever write one byte at a time
[21:23:47] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[21:23:47] *** ChanServ sets mode: +o tjc
[21:25:11] <strcat> rusti: fn foo() -> ! {} fn bar(x: int) {} fn baz() { bar(foo()) } }
[21:25:11] -rusti- <anon>:8:0: 8:1 error: incorrect close delimiter: `}`
[21:25:11] -rusti- <anon>:8 }
[21:25:11] -rusti-          ^
[21:25:11] -rusti- application terminated with error code 101
[21:25:18] <strcat> rusti: fn foo() -> ! {} fn bar(x: int) {} fn baz() { bar(foo()) }
[21:25:18] -rusti- <anon>:5:9: 5:25 error: some control paths may return
[21:25:18] -rusti- <anon>:5          fn foo() -> ! {} fn bar(x: int) {} fn baz() { bar(foo()) }
[21:25:19] -rusti-                   ^~~~~~~~~~~~~~~~
[21:25:19] -rusti- error: aborting due to previous error
[21:25:19] -rusti- application terminated with error code 101
[21:27:02] <engla> SimonSapin: is it possible to have a method like   fn feed<W: StringWriter>(&mut self, data: &[u8], output: &mut W) -> ErrorThing   and still (optionally) use it through a trait object?
[21:27:32] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[21:27:44] *** flaper87 is now known as flaper87|afk
[21:28:36] *** Quits: ahal (ahal@13F2CEC5.7672369.D8E68FF6.IP) (Input/output error)
[21:29:37] <kimundi> strcat: does an &fn() allocate?
[21:29:49] <strcat> not on the heap
[21:29:57] <kimundi> okay
[21:29:59] <strcat> it's boxed though, and often is a performance issue
[21:30:10] *** Quits: jgilbert (jgilbert@40BD3B76.2AD327F9.973C8D27.IP) (Ping timeout)
[21:30:19] <kimundi> sure, just wanted to be sure about the heap thing
[21:31:15] *** Joins: lex (lex@moz-12347B81.bootp.virginia.edu)
[21:31:29] *** Parts: lex (lex@moz-12347B81.bootp.virginia.edu) ()
[21:33:45] <strcat> tjc: https://github.com/mozilla/rust/pull/9174 r?
[21:34:30] *** Joins: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP)
[21:34:32] <tjc> strcat: r+'ed
[21:34:39] <strcat> longest error I've made rustc spit out, btw
[21:34:50] <strcat> rusti: fn foo() -> ! {} fn bar() { foo() == foo() }
[21:34:52] -rusti- pastebinned 434 lines of output: http://ix.io/82v
[21:34:56] <strcat> rusti: fn foo() -> ! { fail!() } fn bar() { foo() == foo() }
[21:35:00] -rusti- pastebinned 434 lines of output: http://ix.io/82w
[21:35:02] <strcat> :D
[21:35:18] <strcat> because it considers every Eq impl to be valid....
[21:35:38] <strcat> I think I fixed it but I need to make sure
[21:36:00] <strcat> ah yes, because before it dispatches to traits it tries the built-in way
[21:36:30] <strcat> I'm sure this problem exists elsewhere..
[21:37:11] <strcat> rusti: fn foo() -> ! { fail!() } fn bar() { from_str(foo()) }
[21:37:12] -rusti- <anon>:5:46: 5:54 error: cannot determine a type for this bounded type parameter: unconstrained type
[21:37:12] -rusti- <anon>:5          fn foo() -> ! { fail!() } fn bar() { from_str(foo()) }
[21:37:12] -rusti-                                                        ^~~~~~~~
[21:37:12] -rusti- application terminated with error code 101
[21:37:27] <strcat> meh
[21:37:35] *** Quits: heftig (heftig@moz-A00845E7.dip0.t-ipconnect.de) (Ping timeout)
[21:38:04] <acrichto> strcat: oh man there are no __extensions__ anywhere in that huge dump
[21:38:15] <acrichto> well, not predominately
[21:38:20] *** Quits: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com) (Input/output error)
[21:38:28] *** Quits: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net) (Input/output error)
[21:39:02] <strcat> rusti: trait Foo {} impl<T> Foo for T {}
[21:39:03] -rusti- ()
[21:39:47] <strcat> rusti: trait Foo { fn foo() { } } impl<T> Foo for T {} impl<T: Send> Foo for T {} let x = @5; x.foo()
[21:39:50] -rusti- pastebinned 23 lines of output: http://ix.io/82x
[21:40:33] *** Joins: themgt (themgt@moz-F9F26397.baf.movistar.cl)
[21:40:35] *** Quits: themgt (themgt@moz-F9F26397.baf.movistar.cl) (Client exited)
[21:41:50] <strcat> acrichto: I'm guessing no luck narrowing down that segfault more? ;p
[21:41:51] *** Joins: heftig (heftig@moz-F404901C.dip0.t-ipconnect.de)
[21:42:26] *** Quits: heftig (heftig@moz-F404901C.dip0.t-ipconnect.de) (Quit: Quitting)
[21:42:34] *** Joins: heftig (heftig@moz-F404901C.dip0.t-ipconnect.de)
[21:43:01] *** Joins: steveklabnik (steveklabn@moz-E7B484F0.lsanca.fios.verizon.net)
[21:43:04] <acrichto> strcat: oh I never resumed investigation, whoops
[21:43:16] <steveklabnik> are there better docs for rustpkg than https://github.com/mozilla/rust/blob/master/doc/rustpkg.md ?
[21:43:24] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[21:43:24] <steveklabnik> is it that it so far?
[21:43:50] <kimundi> I'm getting an ICE trying to implement two different generic specializations of a trait: https://gist.github.com/Kimundi/6556458
[21:44:01] *** Joins: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com)
[21:44:04] <tjc> steveklabnik: that's it so far
[21:44:07] <kimundi> Is that a bug, or not possible in general?
[21:44:09] *** jdm|f00ding is now known as jdm
[21:44:10] <steveklabnik> tjc: cool, thanks!
[21:44:52] <strcat> unless you have some kind of brain probe for using tjc as a reference manual
[21:45:07] <steveklabnik> ha!
[21:45:17] <tjc> strcat: unfortunately, my brain uplink only operates at 28.8kbps
[21:46:17] <steveklabnik> are there any good examples of an existing package on github anywhere?
[21:46:29] <steveklabnik> i'm mostly interested in directory structures, sample config files, stuff like that
[21:46:38] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[21:46:46] <tjc> steveklabnik: there are a few, let me check my list
[21:46:57] <steveklabnik> thanks. a library one would be cool
[21:47:16] <steveklabnik> (I'd like to make a generator for rustpkg but first i have to figure out what a simple package looks like)
[21:47:20] <tjc> steveklabnik: there's https://github.com/chris-morgan/rust-http
[21:47:31] <tjc> steveklabnik: also https://github.com/cmr/rustdoc_ng
[21:47:40] <erickt> kimundi: I could be wrong, but I don't believe you can have two different generic specializations of a trait
[21:47:54] <erickt> nmatsakis: ^ is that right?
[21:48:00] <tjc> jack has converted some of the simpler servo submodules to rustpkg, but I'm not sure if any are checked in yet
[21:48:01] <cmr> steveklabnik: 0 config files are needed
[21:48:10] <steveklabnik> cool thanks
[21:48:11] <cmr> You just need a main.rs or a lib.rs and rustpkg does its thing.
[21:48:20] <erickt> kimundi: although you are hitting an ICE...
[21:48:29] <steveklabnik> cmr: word. i still want to learn about optional things... but good to know
[21:49:37] *** Quits: ecr (Thunderbir@moz-BBE3ABD.mv.mozilla.com) (Quit: ecr)
[21:50:00] <steveklabnik> this is enough to get me going, thanks tjc cmr 
[21:50:14] <tjc> steveklabnik: you're welcome
[21:51:40] <tiffany> I can't figure out this unconstrained type error
[21:51:43] *** Quits: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net) (Client exited)
[21:53:48] *** Joins: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP)
[21:55:55] *** Quits: Larry (larryfox@moz-343B6F0C.nyc.biz.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[21:56:37] <steveklabnik> okay, MEGA NOOB question: everything i type to 'rust build' just gives me error: error opening FOO
[21:57:14] <steveklabnik> i made a src/html_escape/lib.rs that does compile
[21:57:15] <kimundi> steveklabnik: step 1) replace 'rust build' with 'rustc' and see if it changes something :)
[21:57:38] <steveklabnik> ah ha
[21:57:39] *** Joins: maik (maik@moz-C5365941.dip0.t-ipconnect.de)
[21:57:57] <steveklabnik> so why rust build then?
[21:57:59] <steveklabnik> oh wow
[21:58:01] <steveklabnik> i am an idiot
[21:58:05] <steveklabnik> rust != rustpkg
[21:58:09] <steveklabnik> ........ :'(
[21:58:12] <kimundi> haha
[21:58:19] <steveklabnik> damn, one cup of coffee wasn't enough
[21:58:27] <steveklabnik> sigh. at least we should get better rustpkg docs out of this ;)
[21:58:35] <tjc> Yeah, I'm wondering whether we should combine `rust` with `rustpkg`
[21:58:37] <tjc> I'm not sure though
[21:58:40] <tjc> I also never use `rust` :-)
[21:58:54] <steveklabnik> i don't use 'rust' either, except with rust run
[21:58:56] <steveklabnik> which is nice
[21:58:57] <cmr> I also never use `rust`
[21:59:08] <kimundi> fun fact: rust pkg == rustpkg (I think)
[21:59:09] <tjc> it's not really intended for those of us who are hacking on the compiler, I realize
[21:59:10] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[21:59:11] *** Joins: Larry (larryfox@moz-343B6F0C.nyc.biz.rr.com)
[21:59:34] <cmr> I think we should remove it, since it's not really worked on and it confuses beginners, and seems to like to regularly segfault and explode in mac
[22:00:31] <kimundi> cmr: Honest opinion: The rust tool is _too simple_ to fail for obscure reasons on macs. There seems to be something different going wrong
[22:00:44] <engla> cmr: do you mean `rust`? I don't run it on mac, but how could it not work?
[22:00:56] <engla> cmr: not talking about rust sketch or so?
[22:01:05] <engla> aka rusti
[22:01:27] <kimundi> I mean, in theory 'rust' is just a hub for running any of the other executables, and shouldn't have any obscure fail cases.
[22:02:17] <kimundi> The implementation of 'rust run' and 'rust test' might be sketchy though, but those are the really useful feature of the 'rust' tool
[22:02:47] <engla> rust run and rust test are wonderful but a bit limited
[22:02:55] <kimundi> yeah
[22:03:04] *** Joins: lkuper (lkuper@moz-D862222C.dhcp-bl.indiana.edu)
[22:03:23] <cmr> engla: Yes, I mean `rust`
[22:03:44] <cmr> Just what I've seen reported in this channel, I don't use mac myself.
[22:04:14] <kimundi> Anyone with a mac here that can test right now? :P
[22:04:23] <SimonSapin> engla, kimundi: I emailed rust-dev with an updated encoding API proposal
[22:04:45] <steveklabnik> is it always idiomatic to include tests with the file they're testing in rust?
[22:06:10] <kimundi> steveklabnik: We haven't yet really decided if it is idiomatic or not. That is, you should add test, but whether they should live in the same source file or be an external test suite is an different question.
[22:06:17] *** Joins: SingingBoyo (brandon@moz-84E47EF.ubcsecure.wireless.ubc.ca)
[22:06:18] <steveklabnik> yeah
[22:06:19] <engla> SimonSapin: great
[22:06:27] <steveklabnik> cool, was just wondering what the current thoughts were
[22:06:37] <steveklabnik> i'm used to them being in other files, but it seems like that's awkward at the moment
[22:08:18] <tjc> steveklabnik: IMO, including tests in the same file is meant to make it super easy to write tests. If you want to write a separate module-of-tests, go for it
[22:08:38] <tjc> we just don't want anyone to not write tests because switching to a new file was too much context-switching :-)
[22:09:04] *** Quits: tgummerer (tgummerer@51D3B54.FEF996EA.EA6FEF3D.IP) (Ping timeout)
[22:09:40] <SimonSapin> IMO, ideally the test suite would even be a separate crate, so that big libraries do not have to be built twice
[22:09:52] <SimonSapin> steveklabnik: ^
[22:10:05] <SimonSapin> though that opinion may not be shared by others
[22:10:14] <steveklabnik> makes sense
[22:10:27] <cmr> SimonSapin: I agree that building twice really sucks
[22:10:29] <cmr> However
[22:10:32] <steveklabnik> all my opinions are filtered through languages that don't need to be compiled ;)
[22:10:52] <cmr> I don't really see why the #[test] stuff couldn't be extracted and built as a separate crate
[22:10:58] <cmr> Assuming it's not testing private things, I suppose...
[22:11:06] <cmr> Would also require injecting imports.
[22:12:07] *** Quits: saml (sam@moz-14C16814.cst.lightpath.net) (Quit: Leaving)
[22:12:58] <kimundi> rusti: static s: &'static str = "foo"; let x: &'static ToStr = s; x.to_str()
[22:13:02] -rusti- pastebinned 5 lines of output: http://ix.io/82z
[22:13:49] <kimundi> rusti: static s: &'static uint = &'static 45; let x: &'static ToStr = s; x.to_str()
[22:13:51] -rusti- pastebinned 5 lines of output: http://ix.io/82A
[22:14:20] <kimundi> rusti: static s: &'static uint = &'static 45; let x = s as &'static ToStr; x.to_str()
[22:14:22] -rusti- ~"45"
[22:14:42] *** Quits: Scriptor (historium@moz-E06F46F0.corp.bitshelter.com) (Quit: Scriptor)
[22:16:50] <kimundi> SimonSapin: Do I understand correctly that the encoding proposal is only for web-relevant encodings, and not for the general case? At least, the list of encodings on that website seems a bit short.
[22:19:14] <kimundi> (Unless that list already contains all relevant encodings in existence, and I just overestimated their amount)
[22:19:29] *** Quits: Larry (larryfox@moz-343B6F0C.nyc.biz.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[22:20:16] *** Quits: brendan (brendaneic@5FC4E4D8.4EE99619.E46D6E17.IP) (Quit: brendan)
[22:20:57] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[22:20:57] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/96x7og
[22:20:57] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[22:23:31] <kimundi> SimonSapin: Also, if the list of Encodings is already statically determined, then they could really become an enum
[22:25:19] *** Joins: xarcus (Mibbit@moz-FAE37203.superkabel.de)
[22:25:44] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[22:25:56] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[22:25:56] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/UTMv0g
[22:25:56] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[22:25:57] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[22:25:57] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/hqODRA
[22:25:57] <ghrust> 13rust/06auto 14d452a8c 15Tim Chevalier: rustpkg: Cleanup
[22:25:57] <ghrust> 13rust/06auto 141be80aa 15bors: auto merge of #9150 : catamorphism/rust/rustpkg-cleanup, r=catamorphism...
[22:25:57] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[22:27:05] *** Quits: xarcus (Mibbit@moz-FAE37203.superkabel.de) (Quit: http://www.mibbit.com ajax IRC Client)
[22:27:32] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[22:28:51] <strcat> acrichto: meh, I'll just start by landing everything but sret
[22:28:56] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[22:31:30] *** Quits: lkuper (lkuper@moz-D862222C.dhcp-bl.indiana.edu) (Ping timeout)
[22:33:28] *** Quits: tikue (tkuehn@18398DD2.28259105.689607DE.IP) (Quit: tikue)
[22:36:51] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[22:37:31] <dbaupp> acrichto: pong
[22:39:00] *** Joins: ross (ross@moz-5EA04060.br.br.cox.net)
[22:43:37] <acrichto> dbaupp: oh I was just excited that I found the fileinput bug i think
[22:43:45] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[22:43:45] *** ChanServ sets mode: +ao brson brson
[22:44:09] <dbaupp> acrichto: \o/
[22:44:24] <acrichto> although there are more tests which this affects
[22:44:31] <acrichto> and I think that this change_dir_locked function just shouldn't exist
[22:44:41] <acrichto> but that'll require a larger pull
[22:45:52] <engla> kimundi: it's a trait, it will not be statically determined
[22:46:05] <acrichto> strcat: sounds like a good plan btw
[22:46:06] <engla> kimundi: think about the libstd vs other libraries split
[22:46:09] <strcat> brson: how hard would it be to get __morestack just aborting on out-of-stack?
[22:47:08] <kimundi> engla: Well, the email uses an &'static Encoding ... That can only be statically defined?
[22:47:49] *** Joins: a_m0d|home (a_m0d@moz-1765B403.acanac.net)
[22:48:22] <engla> kimundi: inside the trait object &Encoding, there could be an impl of Encoding from your own custom crate
[22:49:02] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[22:51:02] <kimundi> engla: So, 'encoding_from_label' would give you an &'static Encoding to an constant for any of the whtwg encodings, but you can write an interface working with any &Encoding, allowing you to substitute your own?
[22:51:10] *** Quits: Skif (emschwar@moz-CA025D57.ip.mcleodusa.net) (Client exited)
[22:52:01] *** Quits: Kelet (Kelet@C253143A.824EB7CA.8245F614.IP) (Quit: Leaving)
[22:52:23] <a_m0d|home> Can anyone help me fix the lifetime errors I'm getting here: https://gist.github.com/am0d/6557084
[22:52:46] <engla> That function does indeed look like it's working with a static list of encodings kimundi  (unless it's implementing some larger machinery)
[22:52:58] <engla> I realize now you were thinking about this function in particular
[22:53:26] <engla> Anyway, the encodings API in general will not have an enum of all encodings since it will be open to 3rd party implementations
[22:54:13] *** Quits: SingingBoyo (brandon@moz-84E47EF.ubcsecure.wireless.ubc.ca) (Ping timeout)
[22:54:19] <a_m0d|home> I don't know why the lifetimes aren't happy, since I specify all of them explicitly
[22:55:03] <dbaupp> a_m0d|home: try `fn new<'a>(r: &'a Request, ...) -> TodoController<'a> { ... }`
[22:55:06] <cmr> "The EOF code point is a conceptual code point that signifies the end of a string or code point stream. "
[22:55:08] <cmr> Wat
[22:55:11] <kimundi> engla: That's what I though too, which is why I found an global function restricting it to a fixed set of constant ones weird. I guess I would be less confused if I actually knew which part of the proposal is meant to be gneral for the rust std lib, and which one specific for servo use cases
[22:55:15] <dbaupp> a_m0d|home: 'self makes things unhappy :(
[22:55:29] <strcat> cmr: unicode!
[22:55:33] <brson> strcat: it would probably take me a week or two, though someone with more focus could probably do it faster. conceptually it's just a few steps: 1) make the assembly functions for setting the stack limit available to the rust runtime; 2) for both green thread tasks and scheduler tasks, install the stack limit when they are running, uninstall when not; 3) throw an abort call in upcall_next_stack. there will probably be some subtle details though that m
[22:55:35] <dbaupp> a_m0d|home: wait; you also need ResponseWriter<'a>
[22:55:57] <steveklabnik> whats the allow test failures pragma? #[allow(failure)] does all tests
[22:56:01] <steveklabnik> i just want one
[22:56:09] <cmr> "User agents are encouraged to expose parse errors somehow"
[22:56:18] <kimundi> steveklabnik: #[should_fail]
[22:56:28] <steveklabnik> thanks
[22:56:38] <strcat> rusti: "\x04\x00\x04"
[22:56:39] -rusti- "\x04\x00\x04"
[22:56:45] <kimundi> steveklabnik: or #[xfail], depending on wether it should fail or wether you want to ignire it :)
[22:56:47] <strcat> EOF NUL EOF, totally valid string.
[22:56:55] <dbaupp> kimundi: #[ignore] surely?
[22:56:57] <strcat> throw in a cat face or two
[22:57:09] <kimundi> dbaupp: steveklabnik or #[ignore], yeah
[22:57:56] *** jorendorff is now known as jorendorff_away
[22:59:22] <a_m0d|home> dbaupp: like this?     pub fn new<'a>(r: &'a Request, rw: &mut ResponseWriter<'a>) -> TodoController<'a> {
[22:59:47] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[23:00:49] <dbaupp> a_m0d|home: yes, but with &'a mut ReponseWriter<'a> too
[23:01:09] <a_m0d|home> dbaupp: yes, just worked that out.  Thanks
[23:02:39] *** Joins: aeqwa_ (aeqwa@moz-58520269.dsl.tropolys.de)
[23:04:02] *** Quits: aeqwa (aeqwa@moz-97603595.dsl.tropolys.de) (Ping timeout)
[23:04:29] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[23:04:31] *** Quits: aeqwa_ (aeqwa@moz-58520269.dsl.tropolys.de) (Ping timeout)
[23:05:18] <strcat> acrichto: tired of debugging this thing so I'll debug another invalid IR problem instead ;p
[23:06:12] <a_m0d|home> dbaupp: Do I need to do anything special to call this constructor now?
[23:06:27] <acrichto> strcat: haha you'll never sleep until our IR is... perfect? not sure if that'll happen
[23:06:57] <a_m0d|home> This doesn't work: let mut controller = ~TodoController::new(request, response); controller.dispatch_request();
[23:07:04] <a_m0d|home> I get lifetime conflicts again ...
[23:07:13] *** Quits: steveklabnik (steveklabn@moz-E7B484F0.lsanca.fios.verizon.net) (Ping timeout)
[23:07:39] *** Joins: aeqwa (aeqwa@moz-7465E8AE.dsl.tropolys.de)
[23:07:42] *** Quits: nkoep (nik@moz-CEF4E4E7.pool.mediaways.net) (Client exited)
[23:07:45] *** Quits: aeqwa (aeqwa@moz-7465E8AE.dsl.tropolys.de) (Client exited)
[23:09:04] <dbaupp> a_m0d|home: hrm; I think it might not work, because the &'a mut ResponseWriter<'a> links the length of the mutable borrow to the lifetime of the ResponseWriter, i.e. the borrow lasts forever and you can't use response again (at a guess) :(
[23:11:41] <a_m0d|home> Is there some way around that though?  Basically I want to create the struct, and put Request / ResponseWriter into it, then call methods on the struct, rather than passing those 2 as parameters to every function
[23:13:53] *** Quits: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP) (Ping timeout)
[23:14:42] <strcat> acrichto: good news, loop-delete works on our iterators now
[23:14:51] <strcat> after offset is fixed again
[23:14:56] * acrichto googles loop-delete
[23:15:11] <acrichto> strcat: nice!
[23:15:14] <strcat> acrichto: it knows vector iterators are never infinite
[23:15:16] <strcat> basically
[23:15:29] <acrichto> oh man writing benchmarks just got harder
[23:15:34] <strcat> so if it removes the body, it can remove the loop
[23:15:54] * strcat tries vectorization
[23:15:54] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[23:15:54] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 141be80aa to 14150b4ff: 02http://git.io/N3iJvQ
[23:15:54] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[23:15:57] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[23:15:57] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/aT8sgw
[23:15:57] <ghrust> 13rust/06auto 142dec95e 15Daniel Micay: ptr: fix offset intrinsic...
[23:15:57] <ghrust> 13rust/06auto 143bcad21 15bors: auto merge of #9173 : thestinger/rust/offset, r=alexcrichton...
[23:15:57] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[23:16:22] <acrichto> build times have been incredibly stable over the past week
[23:16:28] <acrichto> spikes for llvm and that's it
[23:16:31] *** Joins: davidb (davidb@5CE9D448.F0B9EFB2.7F8758CE.IP)
[23:16:32] <strcat> I'll try to fix that ;p
[23:16:40] <acrichto> lol
[23:16:57] *** davidb is now known as docbrown
[23:17:04] <strcat> and.... our loops vectorize!
[23:17:07] <strcat> finally
[23:17:16] <strcat> it has to do with fixing that stupid ptr equality thing
[23:17:18] <strcat> can't believe it
[23:17:23] <kimundi> strcat: woho!!!
[23:17:35] <acrichto> yay!
[23:17:52] <strcat> http://ix.io/76h a little sample function
[23:17:57] <acrichto> strcat: can we add tests to test/codegen to prevent this from regressing again?
[23:18:35] <strcat> acrichto: if we had IR tests :s
[23:18:41] <strcat> http://ix.io/82D here it is targeting x86_64 (SSE2)
[23:19:11] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[23:19:20] <acrichto> that's a lot of ir
[23:19:22] *** Joins: Kelet (Kelet@C253143A.824EB7CA.8245F614.IP)
[23:19:24] <acrichto> although I imagine it's fast
[23:19:34] <acrichto> strcat: isn't that what src/test/codegen is for though?
[23:19:40] <acrichto> or rather kinda...
[23:19:45] <strcat> acrichto: that measures size
[23:19:49] <acrichto> yeah :(
[23:19:51] <acrichto> just realized that
[23:20:22] <strcat> hm, it doesn't want to generate AVX ops
[23:20:49] <engla> nice strcat
[23:20:56] <tjc> acrichto: ping
[23:21:01] <acrichto> tjc: pong
[23:21:12] <brson> tjc: r? https://github.com/mozilla/rust/pull/9176
[23:21:13] <tjc> acrichto: Don't know if you noticed, but another rustpkg patch of mine failed on a fileinput test...
[23:21:17] *** Joins: Jesin (Jessin_@moz-48B48C95.eecs.lehigh.edu)
[23:21:23] <strcat> acrichto: I don't think --target-feature works :S
[23:21:23] <acrichto> what! nooooooo
[23:21:25] <tjc> and my patch went in after your fileinput patch, so I'm scratching my head
[23:21:41] <acrichto> tjc: oh well actually there are more tests in libextra which use change_dir_locked
[23:21:48] <acrichto> let me look at the logs though
[23:21:52] <tjc> acrichto: great, thanks
[23:22:19] <tjc> brson: r+'ed -- should that have higher priority?
[23:22:28] <brson> tjc: yes please
[23:22:52] <tjc> upped it to 10
[23:23:10] <acrichto> tjc: yeah, the tempfile tests were running close to those tests, and the tempfile tests call change_dir_locked. I'm thinking about just completely removing that function for now and I don't think that we should review code to make sure tests don't change directories
[23:23:16] <tjc> acrichto: d'oh
[23:23:35] <acrichto> I'll make a pull some time later tonight or tomorrow
[23:23:36] <tjc> acrichto: do you mean you *do* think that we should review code to make sure of that, or...?
[23:24:01] <acrichto> tjc: well we should definitely do that b/c it's hard to remember that you can't change directories
[23:24:10] <acrichto> tjc: another possible-ish solution is that changing directories is unsafe
[23:24:19] <tjc> acrichto: yeah. Making it unsafe might be a good idea. I don't know, it's a little weird
[23:24:40] <acrichto> tjc: I'll see what happens when I try to remove it
[23:24:50] <strcat> acrichto: yeah, --target-feature *definitely doesn't work
[23:24:57] <acrichto> but the review aspect was more of "if it's not unsafe, we still need to prevent it from hapening"
[23:25:05] <acrichto> strcat: weird, I thought that we definitely passed that down
[23:25:16] <strcat> acrichto: so, I changed it to f32
[23:25:27] <strcat> we get <4 x float> ops even if I enable avx
[23:25:29] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[23:25:39] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[23:25:40] <strcat> clang -> <8 x float> (or <16 x float> for haswell)
[23:25:42] <acrichto> dunno how that should even affectit :(
[23:25:47] <tjc> acrichto: this might be an argument for having other effects besides just "unsafe", which is an idea we've bounced around occasionally
[23:26:02] <acrichto> tjc: yeah that would be interesting
[23:26:21] <acrichto> tjc: I'd have to learn more about that, but to safely change directories it seems like the existing system won't cover the use cases
[23:26:27] <acrichto> unless we add giant locks all over the place
[23:26:37] <tjc> acrichto: Yeah, and that would be pretty undesirable
[23:26:52] <strcat> acrichto: SSE -> 8x 128-bit registers (4 floats, or 2 doubles), AVX -> 16x 256-bit registers (8 floats, 4 doubles), AVX-512 -> 32x 512-bit (16 floats, 8 doubles)
[23:26:57] <strcat> anyway it appears to be ignored.
[23:26:59] <acrichto> strcat: ah I see
[23:27:07] <acrichto> strcat: I'll look into that tonight as well if you don't get around to it
[23:27:14] <acrichto> just making sure that we pass it around correctly
[23:27:25] <strcat> our context switching is broken with AVX anyway but I like looking at it ;p
[23:27:36] <strcat> (and runtimeless rust exists!)
[23:27:45] <acrichto> kinda...
[23:27:52] <acrichto> rust only generates segmented stacks
[23:28:03] <acrichto> anyway, i gtg now, later
[23:28:06] <strcat> \o
[23:28:28] *** Quits: ChrisOei (Adium@moz-2B20A8E8.partechvc.com) (Quit: Leaving.)
[23:29:37] *** Quits: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net) (Connection reset by peer)
[23:30:01] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[23:31:37] *** Quits: donri (donri@moz-9BB61102.tbcn.telia.com) (Client exited)
[23:32:57] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[23:33:35] <strcat> acrichto: oh, --target-cpu works...
[23:34:17] *** Joins: SiegeLord (sl@moz-1DF56822.twcny.res.rr.com)
[23:34:40] *** Joins: jstevans (Instantbir@moz-735D8260.washdc.fios.verizon.net)
[23:35:22] *** Joins: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP)
[23:41:03] *** Joins: lazyden (lazyden@47A36AC9.35CBBBD0.F246D1AF.IP)
[23:46:29] *** Quits: bheylin_ (brianheyli@moz-8255E94E.adsl.online.nl) (Quit: bheylin_)
[23:47:01] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[23:48:14] *** Quits: Ralith (ralith@A8995AA9.62B6AF6A.922221DB.IP) (Ping timeout)
[23:48:45] <strcat> heh are we actually out of -Z flags?
[23:48:50] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[23:50:21] <cmr> strcat: I think we have one left.
[23:50:30] <cmr> My segmented stacks PR obviously didn't go through
[23:50:36] <cmr> But it used the last one.
[23:50:53] * strcat got basic type-based alias analysis working but it's going to break everything ;[
[23:51:01] <strcat> just reusing the existing pass
[23:53:37] *** Quits: echristo (echristo@DCF57675.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[23:59:05] *** Quits: cstrahan (cstrahan@DB1CB554.80B5DDE4.2D737EA7.IP) (Ping timeout)

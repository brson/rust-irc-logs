[00:00:44] <engla> MaikKlein: rust will try to infer the type needed
[00:01:08] <bstrie> MaikKlein: nope, the compiler looks ahead to determine what the type is. it infers the type from use
[00:01:24] <MaikKlein> ah
[00:01:33] <bstrie> MaikKlein: we could have also said ` let mut cs: ChanSet<int> = ChanSet::new();`
[00:01:39] <erickt> steven_is_false: which library are you using to receive key presses?
[00:01:42] <bstrie> but it's easier to leave it out
[00:02:01] <engla> or let mut cs = ChanSet::new::<int>();
[00:02:13] <bstrie> right, but that form is terrible :P
[00:02:25] <engla> it's better than saying ChanSet twice!
[00:02:46] <bstrie> no way is it worse than the abomination that is ::<> !
[00:03:00] * bstrie fisticuffs
[00:03:02] <steven_is_false> erickt: SDL. Give me five minutes.
[00:03:08] <engla> I disagree, obviously
[00:03:14] <engla> ::<T> is fine
[00:03:43] *** Quits: solancile (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net) (Quit: Leaving)
[00:04:02] <bstrie> I like how we picked foo::bar over foo.bar explicitly *because* we didn't want to conflate module access with method access, and then we go and mess it up anyway by conflating module access with type hints :P
[00:04:45] <engla> I don't see that problem. There are others, but not that
[00:05:17] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[00:05:34] <sp3d> is <T> instead of ::<T> completely infeasible?
[00:06:11] <engla> Anyone else fail to build incoming from scratch? (linux x86-64)  ICE in librustc
[00:06:25] <bstrie> sp3d: it is if you want to have a grammar without infinite lookahead
[00:06:33] <erickt> bstrie: we used to have foo[int](â€¦), but we thought using the <T> syntax would be easier for c++ newbies. However, we needed to disambiguate the <T> in expressions, so we ended up with ::<T>
[00:06:48] <sp3d> rough, ok
[00:07:10] <sp3d> there aren't enough flavors of braces+brackets in the world
[00:07:21] <bstrie> erickt: right, I understand the reasoning, and I agree that <T> is better than [T]. but just because it's the less dissatisfactory option doesn't mean I have to like it :)
[00:07:25] <engla> What I understand it's always <T> when mandatory and ::<T> when optional.
[00:07:57] <bstrie> and then there's the question of type hints always having to go at the end of the path, or something?
[00:08:01] <erickt> bstrie: :) Making this syntax change was the first big thing I did on rust way back when
[00:08:10] *** Joins: seth (seth@5AAE35B2.5EFFC0B8.24454B25.IP)
[00:08:42] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[00:08:47] <erickt> bstrie: I think nmatsakis has a plan to move where those type declarations go
[00:09:02] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[00:09:12] *** Quits: bnicholson (bnicholson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[00:09:30] *** Joins: Ralith (ralith@moz-7A3D93AE.wireless.sfu.ca)
[00:10:50] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[00:11:27] *** Quits: Ralith (ralith@moz-7A3D93AE.wireless.sfu.ca) (Ping timeout)
[00:11:29] <Jeaye> What's thi talk of Rust interns?
[00:11:35] <Jeaye> s/thi/this/
[00:11:45] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[00:12:32] <steven_is_false> :%s/ thi / this /g
[00:13:20] *** Quits: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP) (Quit: eatkinson)
[00:13:32] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[00:14:02] <erickt> Jeaye: Rust is getting some of the Mozilla interns this summer
[00:14:16] <Jeaye> Ahh, to work on it?
[00:14:32] <erickt> yeah. we get a couple each summer
[00:14:38] <Jeaye> Nice.
[00:14:53] *** Quits: SimonSapin (simon@3B698CEA.45500B72.24454B25.IP) (Quit: Leaving.)
[00:15:18] *** Joins: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP)
[00:15:34] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[00:15:47] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[00:22:07] *** kimundi is now known as zz_kimundi
[00:22:36] *** Quits: lkuper (lkuper@moz-D862222C.dhcp-bl.indiana.edu) (Ping timeout)
[00:23:40] *** Quits: mschifer (Adium@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[00:24:40] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[00:24:40] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 149f00895 to 149a40c5c: 02http://git.io/N3iJvQ
[00:24:40] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[00:24:41] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[00:24:41] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/Bo8EYw
[00:24:41] <ghrust> 13rust/06auto 14f0f251e 15Luqman Aden: librustc: Always pass self ByRef.
[00:24:41] <ghrust> 13rust/06auto 147ac831e 15Luqman Aden: Add test for #5321.
[00:24:41] <ghrust> 13rust/06auto 14947a854 15Luqman Aden: librustc: Classify newtype structs Foo(T) as immediates if T is an immediate.
[00:24:42] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[00:26:05] <cmr> Luqman: so how does eg fn foo(self) work with that?
[00:26:19] *** Joins: Sorella (queen@B12A78F5.BA14766C.95C8B7C6.IP)
[00:26:22] *** Joins: jclements (jclements@moz-976D8D81.pool.starband.net)
[00:26:33] <erickt> Luqman: got some failures in your patch: http://buildbot.rust-lang.org/builders/auto-mac/builds/1416/steps/test/logs/stdio
[00:27:38] <Luqman> erickt: yea, i ran the make check locally and it passes so i had bors retry
[00:27:42] <Luqman> cmr: what do you mean?
[00:28:02] *** Joins: reyre (reyre@5AAE35B2.5EFFC0B8.24454B25.IP)
[00:28:07] <cmr> Luqman: does f0f251e change the semantics of programs at all, or just codegen?
[00:29:16] <Luqman> cmr: ah, so it makes it avoid some indirection now
[00:29:18] <caitp> is there any way for ToStr() to return an immutable reference to a static string?
[00:29:21] <caitp> to_str()
[00:29:23] <caitp> **
[00:29:32] <erickt> caitp: nope
[00:29:36] <caitp> why not :(
[00:29:57] <erickt> caitp: it's a different type from a constructed string
[00:29:59] <Luqman> cmr: see the example here https://github.com/mozilla/rust/issues/6612
[00:30:16] <dbaupp> caitp: you can always define your own to_static_str method
[00:30:24] *** Quits: mhamrick (mhamrick@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: mhamrick)
[00:30:51] <dbaupp> Luqman: out of interest, why is that limited to anonymous fields, rather than any struct with a single immediate field?
[00:31:18] <caitp> I could, but it would be preferable if it could fit the ToStr trait
[00:31:36] <caitp> but, in this case, return a specific kind of object (that would be useful for nominal enumeration types, for example)
[00:31:46] <erickt> Luqman: I'm not sure if retrying this is going to fix your error. Are you sure your commit plays well with managed pointers?
[00:32:15] <cmr> caitp: ToStr returns a ~str, there's nothing you can do about that
[00:33:13] <erickt> caitp: the problem is how to know whether or not to delete the string's pointer
[00:33:51] <caitp> do objects borrowing immutable types get to delete them?
[00:33:53] *** Quits: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net) (Ping timeout)
[00:34:00] <steven_is_false> I'm curious is anyone currently working on an XML for Rust? Parsing the provided .gir files seems like an easier task than writing a binding to Gtk+ manually.
[00:34:13] <caitp> immutable references*
[00:34:24] <dbaupp> steven_is_false: there are some expat(?) bindings around somewhere
[00:34:33] <erickt> caitp: nope, borrowing in general doesn't transfer ownership
[00:34:52] <dbaupp> steven_is_false: yep, https://github.com/pascalj/rust-expat
[00:35:08] <cmr> steven_is_false: there's already https://github.com/mzabaluev/grust for gobject introspection
[00:35:27] <caitp> right, so if to_str() could return &str rather than ~str() (and the runtime be smart enough to know the difference), then I'm not sure I see what the problem would be
[00:35:30] <steven_is_false> cmr: Nice!
[00:35:50] <erickt> caitp: but the runtime doesn't have that information
[00:36:04] <cmr> caitp: &str with what lifetime? where does it get freed?
[00:36:09] *** Joins: lerc (quassel@6174E42B.BEFA2430.788638A4.IP)
[00:36:14] <cmr> It can't be &'static, almost nothing would be able to use it
[00:36:26] *** Quits: EXetoC (ex@moz-C741B177.customer.t3.se) (Quit: WeeChat 0.4.1)
[00:36:46] <Luqman> erickt: it should afaict
[00:37:03] <dbaupp> caitp: the only way to return a borrowed pointer is to give it a concrete lifetime (i.e. &'r str), either connected to an object that already exists or 'static
[00:37:30] *** Joins: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net)
[00:38:44] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[00:39:25] <caitp> okay, to put it another way, such immutable strings would still fit into the ownership model, in that they're owned by the process
[00:39:44] <caitp> so that keeps the lifetime in check
[00:40:10] <cmr> &'static strings already exist, the ToStr trait just doesn't use them because it would be very limited.
[00:40:11] <caitp> but it seems like this doesn't quite happen this way
[00:40:38] <caitp> they shouldn't be any different from other immutable references
[00:40:57] <caitp> just with a longer-lasting owner
[00:41:43] <indutny> pcwalton: thanks
[00:42:32] *** Quits: jclements (jclements@moz-976D8D81.pool.starband.net) (Quit: jclements)
[00:43:26] *** Quits: reyre (reyre@5AAE35B2.5EFFC0B8.24454B25.IP) (Client exited)
[00:44:40] *** Joins: bytbox (s@moz-96B204E2.wireless.umd.edu)
[00:48:00] *** Quits: FrozenCow (FrozenCow@moz-9DF5D010.dynamic.upc.nl) (Client exited)
[00:51:25] *** Quits: jdm (jdm@F2D29657.F60B0462.67AC9B1.IP) (Quit: Lost terminal)
[00:52:30] <MaikKlein> wohoo first blog entry, https://maik.herokuapp.com/?p=41 I hope it is true what I wrote about deriving :)
[00:53:23] *** Joins: jclements (jclements@moz-976D8D81.pool.starband.net)
[00:53:59] <cmr> MaikKlein: not only does it generate the proper methods, it implements the named trait.
[00:54:04] <dbaupp> MaikKlein: it also gives you the `ne` method ;)
[00:54:11] <dbaupp> (deriving(Eq), that is)
[00:54:40] *** Joins: tjc (tjc@A5087023.2354C43D.D8E68FF6.IP)
[00:54:40] *** ChanServ sets mode: +o tjc
[00:54:43] <bstrie> MaikKlein: ah, but it's not just that you get to use the .eq method... you also get to use == to compare
[00:55:18] <MaikKlein> ahh okay
[00:55:25] <MaikKlein> thats pretty cool
[00:55:33] <MaikKlein> and I can also write those by myself right?
[00:55:35] <cmr> http://static.rust-lang.org/doc/core/cmp.html
[00:55:36] <bstrie> MaikKlein: yes
[00:55:40] <MaikKlein> awesome
[00:55:45] <bstrie> MaikKlein: deriving just gets rid of a lot of standard boilerplate
[00:55:54] <bstrie> MaikKlein: also if you derive Ord you get to use < and > and such
[00:55:57] *** Quits: tjc (tjc@A5087023.2354C43D.D8E68FF6.IP) (Quit: Places to go, people to annoy)
[00:56:01] <MaikKlein> never saw something similar
[00:56:16] <engla> deriving rand seems nifty
[00:56:21] <bstrie> MaikKlein: == is just sugar for .eq, which is why this works. it's operator overloading
[00:56:29] <engla> and iterbytes of course (so it's hashable)
[00:56:51] <bstrie> so deriving rand has something to do with quickcheck?
[00:58:07] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[00:58:23] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[00:58:24] <cmr> rusti: str::from_bytes([27, 91, 37, 105, 37, 112, 49, 37, 100, 59, 37, 112, 50, 37, 100, 114])
[00:58:25] -rusti- ~"\x1b[%i%p1%d;%p2%dr"
[00:58:25] *** Quits: benh (ben@moz-4A0366D2.org) (Ping timeout)
[00:58:33] *** Quits: threecreepio (jdp@moz-DB2D70E9.cust.bredbandsbolaget.se) (Ping timeout)
[00:58:33] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Ping timeout)
[00:58:33] *** Joins: benh (ben@moz-4A0366D2.org)
[00:59:06] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[00:59:26] <dbaupp> bstrie: yeah, that's what I had in mind when I implemented it
[00:59:51] *** Joins: RageOfThou (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[00:59:57] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Ping timeout)
[01:00:15] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[01:00:17] <dbaupp> rusti: #[deriving(Rand)] struct A { a: uint, b: float } rand::random::<A>()
[01:00:20] -rusti- foo.rs:5:58: 5:75 error: failed to find an implementation of trait std::rand::Rand for main::A
[01:00:20] -rusti- foo.rs:5          #[deriving(Rand)] struct A { a: uint, b: float } rand::random::<A>()
[01:00:20] -rusti-                                                                    ^~~~~~~~~~~~~~~~~
[01:00:20] -rusti- note: in expansion of fmt!
[01:00:20] -rusti- foo.rs:4:12: 6:7 note: expansion site
[01:00:23] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[01:00:25] *** Joins: engla (engla@2AD2AF06.C84525FB.186BC0CB.IP)
[01:00:33] <dbaupp> :(
[01:00:40] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[01:00:45] <bstrie> dbaupp: I demand a blog post to explain it
[01:01:09] *** Quits: RageOfThou (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Connection reset by peer)
[01:01:17] <dbaupp> bstrie: but I dunno how to type ;P
[01:01:20] *** Joins: RageOfThou (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[01:01:24] <dbaupp> and anyway it's broken
[01:01:28] * dbaupp investigates
[01:01:30] *** Quits: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net) (Quit: carllerche)
[01:01:41] *** Quits: benh (ben@moz-4A0366D2.org) (Ping timeout)
[01:01:43] *** Quits: Boreeas (Boreeas@moz-F35C832D.boreeas.net) (Ping timeout)
[01:01:52] *** Joins: Boreeas (Boreeas@moz-F35C832D.boreeas.net)
[01:02:25] *** Joins: FunkyDrummer (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[01:03:09] *** Quits: RageOfThou (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[01:03:36] *** Quits: Boreeas (Boreeas@moz-F35C832D.boreeas.net) (Ping timeout)
[01:03:44] *** Joins: a_m0d (a_m0d@moz-9F925EFA.hm.shawcable.net)
[01:03:56] *** Quits: cdidd (cdidd@moz-1CCC251B.broadband.corbina.ru) (Ping timeout)
[01:04:22] *** Quits: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP) (Quit: eatkinson)
[01:04:24] <MaikKlein> can I also derive a struct that I don't have created? for example PortSet doesn't have a clone method. Could I add it by deriving?
[01:04:25] *** Quits: snearch (snearch@moz-6DF04212.pool.mediaways.net) (Quit: Verlassend)
[01:04:33] <dbaupp> MaikKlein: no
[01:04:44] <dbaupp> deriving only works on the declaration of the type
[01:05:03] <dbaupp> hmm, well that's strange
[01:05:18] <dbaupp> it seems that deriving is no longer expanded inside blocks
[01:05:35] <dbaupp> :(
[01:05:59] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[01:06:43] *** Joins: cdidd (cdidd@moz-1CCC251B.broadband.corbina.ru)
[01:06:52] *** Joins: Boreeas (Boreeas@moz-F35C832D.boreeas.net)
[01:07:48] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[01:08:14] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[01:08:46] *** Joins: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP)
[01:08:57] *** Joins: benh (ben@moz-4A0366D2.org)
[01:09:10] *** Joins: ssiloti_ (steve@moz-4B8C4631.oc.oc.cox.net)
[01:09:45] *** Quits: ssiloti_ (steve@moz-4B8C4631.oc.oc.cox.net) (Quit: leaving)
[01:13:42] *** Joins: Ralith (ralith@moz-50F3C77.vc.shawcable.net)
[01:13:44] <MaikKlein> :(
[01:14:40] <engla> regardless MaikKlein, you can't implement "foreign" traits on foreign types.. foreign is outside current module.
[01:15:03] <cmr> crate, not module?
[01:15:40] <engla> maybe you are right
[01:15:44] *** Joins: Jesin (Jessin_@moz-48B48C95.eecs.lehigh.edu)
[01:15:51] <MaikKlein> can I somehow add functionality like clone to PortSet?
[01:15:58] <MaikKlein> or is this completely closed
[01:16:09] <cmr> MaikKlein: not from outside libstd
[01:16:13] <dbaupp> MaikKlein: you could submit a patch :)
[01:17:16] *** Quits: seth (seth@5AAE35B2.5EFFC0B8.24454B25.IP) (Ping timeout)
[01:17:20] <jclements> before I write it myself: we don't have an equal_modulo_whitespace function for strings?
[01:17:28] <MaikKlein> u mean a patch for everyone?
[01:17:59] <cmr> MaikKlein: as in, you change the code and send a pull request on github
[01:18:12] <MaikKlein> ah okay
[01:18:27] <bstrie> jclements: that's such an oddly specific function that I doubt we have anything like it :)
[01:18:42] <MaikKlein> never done something like this before, I guess it will be reviewed if the change makes sense
[01:19:03] <bstrie> MaikKlein: what's the use of deriving Eq on portset?
[01:19:16] <bstrie> under what circumstances would you want to determine if two portsets are the same?
[01:19:29] *** Joins: SimonSapin (simon@B1CE442D.7327B66B.5FA4DAFA.IP)
[01:19:29] <MaikKlein> no it was a more general question :)
[01:19:56] <jclements> bstrie: I'm writing test cases that involve the output of the pretty-printer, and I really don't want to spend too much time trying to match my expected output to the ws patterns of pretty-print.
[01:20:08] <MaikKlein> not specific to portset , I just played around and wondered if I could add functionality 
[01:20:31] <engla> MaikKlein: I don't think clone makes sense for ports
[01:20:46] <cmr> MaikKlein: extending types from other crates would cause all sorts of trouble, especially when combining separate pieces of code.
[01:20:54] *** Quits: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net) (Client exited)
[01:21:06] <engla> You can create a wrapper type
[01:21:49] <MaikKlein> with composition?
[01:22:37] <dbaupp> MaikKlein: struct WrappedPortSet<T>(PortSet<T>);
[01:23:07] <MaikKlein> Okay yeah I also thought about that too
[01:23:14] *** Quits: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP) (Quit: eatkinson)
[01:23:23] <MaikKlein> I am still adapting to Rust :)
[01:25:01] *** Joins: aatch (aatch@moz-2BB0AC01.cable.telstraclear.net)
[01:26:18] <steven_is_false> Hi! One can't do impl MyTrait { etc.. anymore. Does anyone has any recommendations for porting old code that uses it?
[01:27:37] *** Quits: bytbox (s@moz-96B204E2.wireless.umd.edu) (Input/output error)
[01:28:10] <cmr> rusti: struct foo {t: int}; impl foo { fn foo(&self) { t+1} }; foo{t:4}.foo()
[01:28:12] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/SaiN
[01:28:21] <cmr> rusti: struct foo {t: int}; impl foo { fn foo(&self) { self.t+1} }; foo{t:4}.foo()
[01:28:23] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/FUhY
[01:28:32] *** Quits: MaikKlein (maik@moz-B7C8DB21.dip0.t-ipconnect.de) (Ping timeout)
[01:28:34] <cmr> rusti: struct foo {t: int}; impl foo { fn foo(&self) ->int { self.t+1} }; foo{t:4}.foo()
[01:28:36] -rusti- 5
[01:32:57] *** Quits: jclements (jclements@moz-976D8D81.pool.starband.net) (Quit: jclements)
[01:35:28] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[01:36:10] *** Joins: mcpherri1 (mimcpher@moz-21D6B3DE.csclub.uwaterloo.ca)
[01:36:49] *** Quits: mcpherri1 (mimcpher@moz-21D6B3DE.csclub.uwaterloo.ca) (Quit: leaving)
[01:37:41] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[01:38:03] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Quit: Leaving.)
[01:38:21] <bstrie> so I'm trying to wrap lua here, and I've got a C question
[01:38:32] <aatch> bstrie, shoot
[01:38:58] <bstrie> I want to use the getglobal function, which is a macro: #define lua_getglobal(L,s)  lua_getfield(L, LUA_GLOBALSINDEX, s)
[01:39:06] <bstrie> the second parameter of getfield there is an int
[01:39:14] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[01:39:23] <bstrie> and yet that constant is #define LUA_GLOBALSINDEX    (-10002)
[01:39:37] <cmr> ints are signed in C
[01:39:42] <bstrie> really?
[01:39:46] <engla> yup
[01:39:47] <cmr> yes... they are in rust, too.
[01:39:50] <aatch> bstrie, uh, yeah...
[01:39:52] <bstrie> oh, duh
[01:39:54] <bstrie> man
[01:39:56] <aatch> -.-
[01:39:58] <bstrie> I'm dumb :P
[01:40:12] <aatch> The other option is infact /unsigned/ int
[01:40:13] <bstrie> my brain goes into panic mode when I'm forced to read C
[01:41:46] *** Quits: mflamer (Mibbit@moz-FE8B7976.dsl.pltn13.sbcglobal.net) (Quit: http://www.mibbit.com ajax IRC Client)
[01:41:51] <bstrie> I think somehow I got it into my head that there was no such thing as negative numbers in C, and that you just had to cast a block of memory as signed or unsigned as you pleased
[01:41:57] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[01:42:17] <aatch> bstrie, at some level there is no such thing as any type of data
[01:42:22] <aatch> it's all interpretation
[01:44:38] <engla> nah C does in fact have rules about aliasing and representation
[01:46:35] <aatch> engla, I was meaning more philosophically. Ultimately you're just dealing with a sequence of bits, arranging them into precise patterns and assigning meaning to those patterns
[01:47:19] <engla> fine. It's popular to use C as if the compiler doesn't care how you access memory locations.. but it does
[01:47:42] *** Joins: z0w0 (zack@moz-567152E7.qld.bigpond.net.au)
[01:49:20] <TD-Linux> by doing arithmetic you require some sort of representation
[01:49:41] <TD-Linux> bstrie, you might have thought of that because for two's complemented, addition and subtraction are the same whether signed or unsigned
[01:49:43] <bstrie> huzzah, we now have a very basic usage of luajit from rust
[01:51:02] <bstrie> TD-Linux: actually, I think I thought that because I'm a ditz :)
[01:51:34] *** Joins: cowboyd (cowboyd@moz-DD0FF83.lightspeed.austtx.sbcglobal.net)
[01:52:20] *** Joins: bytbox (s@moz-96B204E2.wireless.umd.edu)
[01:53:49] *** Joins: reyre (reyre@5AAE35B2.5EFFC0B8.24454B25.IP)
[01:55:53] *** Quits: reyre (reyre@5AAE35B2.5EFFC0B8.24454B25.IP) (Ping timeout)
[01:56:13] *** Joins: hay_guise (Mibbit@moz-BE4D5EAA.eastlink.ca)
[01:56:48] <caitp> is there any way to require a qualified name for a nominal enum value (like mod::value or typename::value)
[01:57:04] <pcwalton> no, there have been proposals
[01:57:12] <pcwalton> but nothing implemented.
[01:57:16] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[01:58:10] *** Joins: mib_ch8sqk (Mibbit@4404CE08.189575DA.8D8CF57.IP)
[01:58:10] *** Quits: mib_ch8sqk (Mibbit@4404CE08.189575DA.8D8CF57.IP) (Quit: mib_ch8sqk)
[01:58:24] <brson> acrichto: did you get you llvm change merged?
[01:58:55] *** Quits: Jesin (Jessin_@moz-48B48C95.eecs.lehigh.edu) (Ping timeout)
[01:59:01] <brson> oh, I see that they didn't pass
[01:59:46] *** Quits: thomaslee_ (thomaslee@moz-6C3931E3.static.twtelecom.net) (Client exited)
[02:00:05] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[02:01:48] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[02:03:42] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[02:03:42] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 140970dfe to 149a40c5c: 02http://git.io/N3iJvQ
[02:03:42] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[02:03:43] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[02:03:43] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/lN46pw
[02:03:43] <ghrust> 13rust/06auto 14f212543 15Olivier Saut: Remove the get function...
[02:03:43] <ghrust> 13rust/06auto 14ff28bb7 15Olivier Saut: Remove the clone function for the method
[02:03:43] <ghrust> 13rust/06auto 145f90f1c 15bors: auto merge of #6723 : osaut/rust/arc-remove-get, r=brson...
[02:03:44] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[02:03:48] <bstrie> hm, I want to implement as_c_str as a method. would I need to have an impl on all of &str ~str @str, or would &str be enough?
[02:04:11] <aatch> bstrie, is there not already such a method?
[02:04:19] <bstrie> aatch: well it's a function right now instead of a method
[02:04:37] <bstrie> str::as_c_str("asdf", |s| { ... })
[02:04:51] <bstrie> and it seems like a good candidate for methodization
[02:04:53] <aatch> I think you could do it just &str, but I'm not certain.
[02:04:54] <bstrie> but strings are weird :)
[02:05:07] <bstrie> well let's try compiling, I guess it should yell at me relatively quickly
[02:05:45] *** Joins: eholk (eholk@1527A0E8.C194AA38.4EA770CF.IP)
[02:06:52] <cmr> bstrie: re: methodization... does #6045 actually require self-by-value or does &self work, for example with "asdf".to_chars()
[02:08:50] <bstrie> cmr: because strings are weird you'd be implementing on &self, which is already a pointer, so self-by-value would be better
[02:08:56] <bstrie> at least afaik
[02:09:28] <cmr> ok how about char, which is less weird :)
[02:09:35] <bstrie> bah, illegal anonymous lifetime on `impl StrUtil for &str`
[02:11:17] <bstrie> cmr: chars are always smaller than pointers, so take them by self as well
[02:11:52] <cmr> alright, still waiting on https://github.com/mozilla/rust/issues/5321 then
[02:12:13] <cmr> Luqman: wait, did you just fix that today?
[02:12:20] <dbaupp> bstrie: impl<'self> StrUtil for &'self str { ... }
[02:12:49] <bstrie> dbaupp: right, it's running now... though I didn't know about that bug cmr just mentioned
[02:12:52] <aatch> bstrie, actually, unless Luqman's thing has landed, you'll get an LLVM assertion trying to self-by-value on a primitive
[02:12:59] <bstrie> well no, it's compiling
[02:13:05] <bstrie> but I haven't actually used it anywhere
[02:13:08] <bstrie> well, wait
[02:13:22] <bstrie> I used it to redefine the free as_c_str function
[02:13:37] <bstrie> no complaints so far
[02:13:54] <aatch> have you used the method anywhere?
[02:14:07] <cmr> it only explodes when you use it, yeah
[02:14:16] <aatch> Hang on, you're doing it on a &'self str?
[02:14:28] <bstrie> yes, I took the old as_c_str and moved its guts into the method, and then defined a new as_c_str with the same signature that does nothing but call the method on its first argument
[02:14:33] <bstrie> aatch: yes
[02:14:38] <cmr> Luqman: is https://github.com/mozilla/rust/pull/6725 the PR for it? There's a whole mess of issues you opened and closed, I can't tell which is which
[02:14:39] <aatch> Oh, that's fine then
[02:14:54] <aatch> its only on types that directly map to LLVM types.
[02:15:00] <bstrie> ah ok
[02:15:09] <aatch> because it won't let you do certain types of casts
[02:15:13] <Luqman> cmr: yea, that would be the most recent one
[02:15:44] <aatch> in fact, I think it only affects non-pointer-sized primitive types
[02:15:46] *** Joins: sankha93 (Instantbir@5AEBC581.93C78442.8B6C1D65.IP)
[02:15:59] <Luqman> cmr: sadly, seems like it breaks dlist so need to investigate that
[02:16:00] <aatch> (at least, that specific issue, there are likely other pass-by-self issues)
[02:16:47] *** Joins: seth (seth@5AAE35B2.5EFFC0B8.24454B25.IP)
[02:22:08] *** Quits: seth (seth@5AAE35B2.5EFFC0B8.24454B25.IP) (Ping timeout)
[02:23:48] <steven_is_false> Hi! Can anyone provide some feedback, and help on this pull request https://github.com/sstewartgallus/grust/pull/new/mzabaluev:master...sstewartgallus:update_to_latest_incoming ?
[02:24:21] *** Quits: SimonSapin (simon@B1CE442D.7327B66B.5FA4DAFA.IP) (Quit: Leaving.)
[02:24:29] <cmr> I think you meant to link to https://github.com/mzabaluev/grust/pull/9 :)
[02:25:45] <steven_is_false> cmr: Oops!
[02:26:07] <brson> steven_is_false: `#[link_name = "grustna"] extern { }` will do it I think. If not then `#[link_args = "-lgrustna"] extern { }`
[02:27:25] <steven_is_false> brson: Neither of those seem to work for me.
[02:27:37] *** Joins: SimonSapin (simon@B1CE442D.7327B66B.5FA4DAFA.IP)
[02:27:57] <brson> steven_is_false: what is the error message?
[02:28:23] <steven_is_false> brson: I'm not linking in any of the low level functions.
[02:28:37] *** Quits: cowboyd (cowboyd@moz-DD0FF83.lightspeed.austtx.sbcglobal.net) (Client exited)
[02:29:24] <steven_is_false> brson: Dependencies are automatically caught from the linker (or should be) right?
[02:29:53] <steven_is_false> brson: So if I link in -lgrust-2432432324-0.1 it should link in it's dependencies right?
[02:31:00] <brson> steven_is_false: I think so, but I'm not clear on how link arg propagation works
[02:31:22] <brson> steven_is_false: you can run with RUST_LOG=rustc::back::link to see how the linker is being invoked
[02:32:12] *** Joins: cowboyd (cowboyd@moz-DD0FF83.lightspeed.austtx.sbcglobal.net)
[02:32:37] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Client exited)
[02:33:27] *** Joins: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP)
[02:33:28] *** Quits: SimonSapin (simon@B1CE442D.7327B66B.5FA4DAFA.IP) (Quit: Leaving.)
[02:33:32] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Quit: leaving)
[02:34:15] <Jeaye> bjz_: ping
[02:34:58] <bjz_> Jeaye: pong
[02:35:12] <Jeaye> The mouse doesn't move anymore on Mac.
[02:35:33] <Jeaye> BUT it is still visible AND it no longer gives movement deltas
[02:35:36] <bjz_> Jeaye: yikes
[02:35:41] <Jeaye> It just sits in the middle of the screen
[02:36:01] <erickt> Luqman: any idea what caused the failures?
[02:36:07] <bjz_> let me have a try of something
[02:37:48] *** Quits: pcwalton (pcwalton@2557E599.66715431.D25A875A.IP) (Quit: pcwalton)
[02:39:04] <bjz_> Jeaye: what version of osx are you on btw?
[02:39:34] <Jeaye> bjz_: 10.8.3
[02:40:33] <bjz_> heh, that shouldn't be the problem then
[02:42:04] <bjz_> Jeaye: I'm looking through the examples/tests included with glfw to see if there's something that demonstrates GLFW_CURSOR_HIDDEN
[02:42:10] *** Joins: SimonSapin (simon@B1CE442D.7327B66B.5FA4DAFA.IP)
[02:42:12] <bjz_> so it works on linux?
[02:42:16] <Jeaye> Yeahup
[02:42:31] <Jeaye> Never had a problem on my Linux (home) system. Just at work on my Mac.
[02:43:36] <Jeaye> bjz_: Trying q3 should be easy enough. ./configure; make && ./bin/q3
[02:43:42] <Jeaye> If you want to see what I mean.
[02:44:37] *** Quits: zz_kimundi (kimundi@moz-2DA92F1A.dip0.t-ipconnect.de) (Ping timeout)
[02:44:47] <bjz_> ok, I'm just making lunch atm, will try in a bit
[02:45:27] <bjz_> I do remember seeing some known bugs about mac osx and coordinates in the glfw docs
[02:45:36] *** Quits: SimonSapin (simon@B1CE442D.7327B66B.5FA4DAFA.IP) (Ping timeout)
[02:45:38] <bjz_> (I use osx)
[02:45:45] <Jeaye> Sure thing. I'll be afk for an hour on my way home in 15min.
[02:45:51] <cmr> Are there any facilities for signal handling?
[02:46:38] *** Joins: tikue (tkuehn@moz-CF8BEBEF.dia.static.qwest.net)
[02:46:43] *** Quits: Jesse (jruderman@2557E599.66715431.D25A875A.IP) (Quit: Jesse)
[02:47:00] *** Parts: tikue (tkuehn@moz-CF8BEBEF.dia.static.qwest.net) ()
[02:47:05] *** Joins: tikue (tkuehn@moz-CF8BEBEF.dia.static.qwest.net)
[02:47:31] *** Joins: drrb (bzlandfill@moz-1D881E2B.lnse1.ken.bigpond.net.au)
[02:47:39] *** Joins: SimonSapin (simon@B1CE442D.7327B66B.5FA4DAFA.IP)
[02:47:55] *** Joins: zz_kimundi (kimundi@moz-D90FF6DB.dip0.t-ipconnect.de)
[02:48:14] *** zz_kimundi is now known as kimundi
[02:48:39] *** Joins: Jesse (jruderman@2557E599.66715431.D25A875A.IP)
[02:48:47] *** Quits: drrb (bzlandfill@moz-1D881E2B.lnse1.ken.bigpond.net.au) (Quit: CGI:IRC (EOF))
[02:51:39] *** Quits: hay_guise (Mibbit@moz-BE4D5EAA.eastlink.ca) (Quit: http://www.mibbit.com ajax IRC Client)
[02:51:45] <steven_is_false> cmr: Aren't there really big restrictions on what kind of code can run in a signal handler?
[02:52:27] <cmr> steven_is_false: well they have to be reentrant
[02:52:27] <caitp> if libsyntax's ast::ident contains 'is_mod_name' to determine if it's a module qualifier or not, how hard would it be to test if the name portion matches a typename (eg an enum name) rather than a module, in order to implement qualified enum values without needing redundant package names?
[02:53:03] *** Joins: hjr3 (hradtke@moz-AE3056B9.static.stls.mo.charter.com)
[02:53:19] *** Joins: mflamer (Mibbit@moz-C6ED16AA.hsd1.ca.comcast.net)
[02:53:21] <steven_is_false> cmr: As far as I can see there's not any such facilities.
[02:54:05] <mflamer> does anyone have a windows build of rusti 0.6 they could share? thanks
[02:54:12] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[02:55:25] *** Joins: SimonSapin1 (simon@7096B777.7327B66B.5FA4DAFA.IP)
[02:55:54] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[02:55:55] <dbaupp> mflamer: rusti was possible broken at 0.6 anyway :(
[02:56:11] <cmr> it... worked, kinda, but not really.
[02:56:34] *** Joins: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net)
[02:56:39] <mflamer> I read it was fixed a few days ago
[02:56:50] *** Quits: SimonSapin (simon@B1CE442D.7327B66B.5FA4DAFA.IP) (Ping timeout)
[02:57:21] <dbaupp> it's fixed in the development version of rust (not 0.6)
[02:57:32] *** Quits: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[02:57:42] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[02:57:42] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/lN46pw
[02:57:42] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[02:57:44] <mflamer> oh, makes sense
[02:57:55] <dbaupp> you can private message with this channel's version of rusti
[02:58:11] <dbaupp> rusti: for 3.times { println("hi") }
[02:58:12] -rusti- hi
[02:58:12] -rusti- hi
[02:58:12] -rusti- hi
[02:58:38] <engla> I can't build incoming on linux today. Is it known to be broken?
[02:58:41] <mflamer> dbaupp: how do i do that?
[02:58:48] <cmr> mflamer: /query rusti
[02:59:14] <dbaupp> engla: what hash?
[03:00:57] <engla> I think it was b5ab1012f1f5786f550e511ba1302a22c85fcd71  I did in fact rm the whole tree to clear the build
[03:01:11] <engla> it was the current incoming earlier today
[03:01:50] <engla> maybe it is actually just failing to build? Only 4G RAM here
[03:02:07] <engla> even if no messages point in that direction
[03:03:38] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[03:03:39] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/k2vv5A
[03:03:39] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[03:03:39] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[03:03:39] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/tETbwA
[03:03:39] <ghrust> 13rust/06auto 14a58bec1 15Brian Anderson: core: Reorder code in cell
[03:03:39] <ghrust> 13rust/06auto 14b8381c0 15Brian Anderson: Make Cell constructors use correct conventions, `new` and `empty` methods
[03:03:39] <ghrust> 13rust/06auto 14581c383 15bors: auto merge of #6694 : brson/rust/cell, r=brson
[03:03:42] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[03:04:51] <dbaupp> engla: yeah, it's possible just OOM, since those errors are really poorly indicated
[03:05:25] <erickt> caitp: I'm not sure, but you could possibly run into issues with when names are resolved.
[03:05:25] <cmr> throw a few gigs of swapfile at it, to check for that
[03:05:40] <mflamer> dbaupp: I don't understand, are you saying I should private message somehow to get a build of rusti? sorry for being so dense, I dont IRC much  
[03:05:40] <z0w0> i doubt that 4gb is not enough
[03:06:06] <dbaupp> mflamer: sorry, no, there is a bot called 'rusti' on this channel
[03:06:07] <erickt> caitp: nmatsakis may do a better job of answering why or why not your idea would work
[03:06:14] *** Quits: Sorella (queen@B12A78F5.BA14766C.95C8B7C6.IP) (Quit: (quit))
[03:06:17] <dbaupp> and you can give it rust and it'll evaluate it
[03:06:23] <dbaupp> (and print the result)
[03:06:31] <dbaupp> rusti: 1 + 2 + 3 * 5
[03:06:32] -rusti- 18
[03:07:12] <dbaupp> mflamer: like that ^
[03:07:21] <mflamer> nice! I'm surer you cant load modules though right?
[03:07:42] <dbaupp> mflamer: well, core and std are loaded by default
[03:07:47] <engla> cmr: it's a good idea.. even though as soon as you start swapping, you usually want to kill that process anyway..
[03:08:06] <dbaupp> mflamer: oh, and it's actually running the latest incoming, not 0.6, which may get a bit confusing :S
[03:08:20] <cmr> well, latest more-or-less
[03:08:25] <cmr> it builds daily
[03:08:33] <mflamer> ok, thanks. Thats good to know
[03:08:46] <engla> dbaupp: ok it makes sense. Do you think compiling and linking librustc is a credible place to OOM? llvm itself seemed fine
[03:08:54] <mflamer> how about multi line commands?
[03:09:24] <cmr> mflamer: not possible, but you can use semicolons
[03:09:29] <aatch> engla, there was a pretty big regression recently regarding memory usage
[03:09:35] <mflamer> got it
[03:09:55] <aatch> and it runs out of RES when trying to fork to run the linker
[03:10:09] <engla> ok
[03:10:15] <mflamer> are most of you on this channel working on the compiler?
[03:10:29] <dbaupp> yep
[03:10:36] <aatch> mflamer, depends on how you define "on the compiler"
[03:10:53] <dbaupp> a lot of people using Rust end up contributing to the compiler :)
[03:11:16] <dbaupp> (fixing bugs, adding features and improving libraries)
[03:11:20] <mflamer> I was thinking rustc and the core and std libs
[03:11:23] <aatch> most of the work goes into the libraries (std+extra), but given that the new runtime+scheduler is in std...
[03:11:33] <aatch> mflamer, in that case yes.
[03:11:50] *** Quits: eholk (eholk@1527A0E8.C194AA38.4EA770CF.IP) (Client exited)
[03:12:03] <aatch> (for example, I'm currently working on implementing basic atomic types)
[03:12:20] <mflamer> sweet
[03:12:24] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[03:12:27] <bjz_> Jeaye: Â»Â»Â» Building DEBUG Q^3 (this can take a while)
[03:12:27] <bjz_> src/ui/mod.rs:17:4: 17:7 error: error opening src/ui/ttf/mod.rs
[03:12:27] <bjz_> src/ui/mod.rs:17 mod ttf;
[03:12:27] <bjz_>                      ^~~
[03:12:50] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[03:13:49] *** Joins: eatkinson (eatkinson@moz-5CF47426.dia.static.qwest.net)
[03:13:51] <aatch> The compiler itself is difficult, especially given that most of the outstanding issues are incredibly complex or require re-writing significant portions.
[03:14:16] *** Quits: catpigger (catpig@moz-A3A1500A.dip0.t-ipconnect.de) (Quit: Verlassend)
[03:15:36] <mflamer> I'm just getting to know the basics. Read the tutorial yesterday. Trying to implement some of the patterns from Haskell for fun. Thinking of a way to partialy apply functions
[03:16:12] <mflamer> using closures or macros or something
[03:16:16] <cmr> afaik partial application isn't possible
[03:16:33] <aatch> cmr, you can emulate it.
[03:16:50] *** Joins: eholk (eholk@1527A0E8.C194AA38.4EA770CF.IP)
[03:17:12] <aatch> Actually, I'm thinking of currying
[03:17:30] <aatch> you can't really even emulate partial application
[03:17:42] <z0w0> what's the difference?
[03:18:30] <aatch> z0w0, given `fn foo(a,b,c)`, currying allows `foo(a)(b)(c)`, partial application also allows `foo(a,b)(c)`
[03:18:34] <aatch> I think
[03:18:40] <aatch> They are related/similar
[03:18:53] <mflamer> yes
[03:18:59] *** Quits: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net) (Quit: I'm sure it's perfectly safe)
[03:19:18] <z0w0> yeah i don't think it's possible to emulate that then
[03:19:24] <z0w0> bjz emulated currying using macros
[03:19:41] *** Quits: eatkinson (eatkinson@moz-5CF47426.dia.static.qwest.net) (Quit: eatkinson)
[03:20:04] <bjz_> basically just nested lambdas
[03:20:35] *** Quits: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net) (Quit: Leaving.)
[03:20:51] *** Quits: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net) (Quit: Computer has gone to sleep.)
[03:21:38] <bjz_> rusti: let f = |x||y| x * y; f(2)(3) // this probably won't work because rust's type inference will complian
[03:21:39] <dbaupp> mflamer: you can possible use traits that allow f(a,b,c) to be f.call1(a).call1(b).call1(c), or f.call2(a,b).call1(c) etc 
[03:21:39] -rusti- foo.rs:5:19: 5:21 error: expected `,` but found `||`
[03:21:40] -rusti- foo.rs:5          let f = |x||y| x * y; f(2)(3) // this probably won't work because rust's type inference will complian
[03:21:40] -rusti-                             ^~
[03:21:52] <dbaupp> (I've never got it to work though)
[03:23:11] <bjz_> https://gist.github.com/bjz/803f8da3863a1ada10c1
[03:23:18] <mflamer> dbaupp: you've tried in the past?
[03:23:41] <mflamer> bjz_: I'll take a look
[03:23:52] <dbaupp> mflamer: yeah, but half-heartedlyy
[03:23:58] <z0w0> you could probably make a macro that generates all the callable variants for a function, and then a macro that calls a variant based on the givern arguments.. but that would be ugly
[03:25:23] <cmr> and also bloat text size hugely
[03:26:31] *** Joins: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net)
[03:28:37] <engla> and like in bjz_'s cool macro, you allocate a lot of @ boxes
[03:32:47] *** Joins: reyre (reyre@5AAE35B2.5EFFC0B8.24454B25.IP)
[03:35:38] *** Quits: reyre (reyre@5AAE35B2.5EFFC0B8.24454B25.IP) (Client exited)
[03:36:00] *** Quits: cowboyd (cowboyd@moz-DD0FF83.lightspeed.austtx.sbcglobal.net) (Client exited)
[03:37:02] *** Joins: reyre (reyre@5AAE35B2.5EFFC0B8.24454B25.IP)
[03:37:58] *** Quits: Jesse (jruderman@2557E599.66715431.D25A875A.IP) (Quit: Jesse)
[03:38:41] <aatch> So a safe atomic pointer would pretty much just have swap and take, right?
[03:40:17] *** Quits: FunkyDrummer (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[03:43:13] <a_m0d> Anyone know why Rust's built in vec::swap operation is so slow?
[03:43:32] <a_m0d> As in, orders of magnitude slower than just using a temporary variable?
[03:43:43] <a_m0d> See here for a comparison: https://gist.github.com/am0d/5647807
[03:44:20] <a_m0d> Timing output at the bottom, average of 20 runs, 10000 items - this is very vec::swap heavy code, so really stresses the function
[03:44:35] <acrichto> a_m0d: have you tried building with optimizations? (-O)
[03:44:56] <a_m0d> acrichto: No, good point.  I'll try that and report back again
[03:45:17] <aatch> a_m0d, also, try using ~-ptrs
[03:45:32] <a_m0d> aatch: using ~ptrs where?
[03:45:43] <aatch> in the array
[03:46:20] <aatch> so try having ~uint or something.
[03:46:55] *** Joins: kspaans (kspaans@moz-21D6B3DE.csclub.uwaterloo.ca)
[03:47:16] <a_m0d> acrichto: you were right about the optimizations.  I didn't even think of that.
[03:47:21] *** Parts: kspaans (kspaans@moz-21D6B3DE.csclub.uwaterloo.ca) ()
[03:47:22] <a_m0d> New timing results: https://gist.github.com/am0d/5647807
[03:47:27] <a_m0d> Basically the same now
[03:48:01] <acrichto> a_m0d: ah good, so vec::swap delegates to util::swap, which has to work for any type, which is why it's implemented in a very generic fasion (unoptimized = super slow)
[03:48:11] <acrichto> thankfully LLVM knows what to do and does the right thing
[03:48:12] <a_m0d> Fair enough
[03:48:12] *** Quits: eholk (eholk@1527A0E8.C194AA38.4EA770CF.IP) (Ping timeout)
[03:48:22] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[03:48:37] <a_m0d> I guess I'll just have to remember to use -O for any real timing testing I do
[03:48:49] <aatch> there are issues with destructors running that mean you have to be careful
[03:48:56] *** Quits: sankha93 (Instantbir@5AEBC581.93C78442.8B6C1D65.IP) (Ping timeout)
[03:49:57] <aatch> I suggest than you use at least non-implicitly copyable types, since then the compiler might complain at you
[03:50:06] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[03:50:55] <a_m0d> aatch: How do you mean?  Is there something I should change in that sort code?
[03:51:35] <a_m0d> Note: I'm only really writing these sort functions to practise algorithm implementation and Rust, not because they are particularly useful ...
[03:52:07] <aatch> a_m0d, I meant when you discover situations like this one.
[03:52:42] <aatch> Often it's because the types are very simple and the implementation doesn't actually generalize
[03:53:22] *** Quits: mflamer (Mibbit@moz-C6ED16AA.hsd1.ca.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[03:53:28] <a_m0d> Okay, so you're saying if I used something other than ~[uint] here, it might have warned me?
[03:53:42] <aatch> a_m0d, possibly
[03:53:58] <a_m0d> Ok, I'll keep that in mind.  Thanks.
[03:54:15] <aatch> I would imagine that trying to get the temporary wouldn't have worked, since you aren't allowed partial moves
[03:55:29] <aatch> rusti: let mut a = ~[~1,~2,~3,~4,~5]; let mut b : ~int = a[1]; b
[03:55:30] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/SDZQ
[03:55:36] *** Quits: caitp (caitp@5AAE35B2.5EFFC0B8.24454B25.IP) (Quit: caitp)
[03:57:17] <acrichto> ls
[03:57:21] <acrichto> whoops...
[03:59:15] <a_m0d> oh, very interesting.  I guess that is a limitation that I definitely would have gotten stuck on if I had used this for something other than straight ints.
[03:59:25] <dbaupp> a_m0d: strcat is actually working on making swap faster
[03:59:49] <dbaupp> (there's information that Rust should be passing to LLVM, but isn't)
[04:00:10] *** Quits: reyre (reyre@5AAE35B2.5EFFC0B8.24454B25.IP) (Client exited)
[04:00:35] <dbaupp> a_m0d: also, there is the #[bench] attribute (like #[test]) that makes rust create a benchmarking harness
[04:00:56] <a_m0d> Really?  I was not aware of that
[04:01:03] <dbaupp> https://github.com/mozilla/rust/wiki/Doc-unit-testing#benchmarking
[04:01:43] <bstrie> cmr: here's the extent of the change that I made to turn as_c_str from a function to a method https://github.com/mozilla/rust/pull/6729/files the same process should hold for all other free functions that are to be converted
[04:02:06] *** Joins: brson (brson@E9CDE21E.991753BB.CA4D1600.IP)
[04:02:06] *** ChanServ sets mode: +o brson
[04:02:50] *** Quits: vodik (root@B8C7456C.5553E784.DC1243F8.IP) (Quit: later gator)
[04:03:15] <bstrie> cmr: by which I mean, the functions should be declared in StrUtil and then defined in the impl below
[04:03:15] <a_m0d> It looks like it does some of the same stuff that my benchmarking harness does, but mine is basically a library I've built of common code for these tests
[04:03:36] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Ping timeout)
[04:04:24] <dbaupp> cool :)
[04:05:41] <dbaupp> although, #[bench] automatically stops when it has decided it's got an accurate assessment of the time taken
[04:05:42] <aatch> a_m0d, one cool thing about the build-in benchmarking stuff is that it simply continues until the results are statistically significant.
[04:05:58] *** Quits: SimonSapin1 (simon@7096B777.7327B66B.5FA4DAFA.IP) (Ping timeout)
[04:06:01] *** Joins: SimonSapin (simon@B1CE442D.7327B66B.5FA4DAFA.IP)
[04:06:32] <bstrie> there's an easy pull request in the queue if anyone feels like reviewing :)
[04:06:54] <a_m0d> aatch: That's a good point.  I could add that to mine as well.  But mine is great for testing because I can specify how many trials I want to run, depending on whether I am confident that the sort is written correctly or not
[04:07:11] <a_m0d> the benchmarker has a post-run step to verify the sort for me
[04:07:32] <a_m0d> I do plan to add the std-deviation to the output yet as well, though
[04:08:32] <dbaupp> a_m0d: well, you can write #[test]'s for verification ;)
[04:09:12] <a_m0d> dbaupp: yup, that's true :) I guess I just like writing my own code to get a feel for it :)
[04:11:12] *** Quits: SimonSapin (simon@B1CE442D.7327B66B.5FA4DAFA.IP) (Quit: Leaving.)
[04:18:18] <aatch> Man, It's gonna take a while for me to get used to the library name changes
[04:18:25] *** Joins: SimonSapin (simon@7096B777.7327B66B.5FA4DAFA.IP)
[04:18:46] *** Joins: moon (sean@AC3C6297.B19D4423.36AE428F.IP)
[04:20:11] *** Quits: moon (sean@AC3C6297.B19D4423.36AE428F.IP) (Quit: leaving)
[04:23:05] <bjz_> Jeaye: ping
[04:23:53] <steven_is_false> I'm having trouble with the benchmarker. I can't find documentation for it in std, or extra.
[04:24:02] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke. It's all a joke.)
[04:24:52] <dbaupp> steven_is_false: #[bench] ?
[04:24:56] *** Quits: SimonSapin (simon@7096B777.7327B66B.5FA4DAFA.IP) (Quit: Leaving.)
[04:25:10] <steven_is_false> dbaupp: std::test::BenchMarker
[04:25:23] <dbaupp> steven_is_false: https://github.com/mozilla/rust/wiki/Doc-unit-testing
[04:25:46] <steven_is_false> dbaupp: I can't find it in std::test with the latest incoming.
[04:25:48] <dbaupp> steven_is_false: specifically, https://github.com/mozilla/rust/wiki/Doc-unit-testing#benchmarking
[04:25:56] <z0w0> it's probably extra::test now
[04:25:57] <dbaupp> steven_is_false: oh, extra::test
[04:26:10] <steven_is_false> dbaupp: I tried extra::test that doesn't work either.
[04:26:47] <dbaupp> steven_is_false: extra::test::bench::BenchHarness
[04:27:06] <dbaupp> (or, extra::test::BenchHarness)
[04:27:44] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[04:27:44] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14581c383 to 145f90f1c: 02http://git.io/N3iJvQ
[04:27:44] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[04:27:45] *** Quits: mcomella (mcomella@moz-B10FF54F.ri.ri.cox.net) (Connection reset by peer)
[04:27:46] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[04:27:46] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/JqTwZQ
[04:27:46] <ghrust> 13rust/06auto 14ac6c15a 15Alex Crichton: Actually filter view_items in blocks
[04:27:46] <ghrust> 13rust/06auto 140628c92 15bors: auto merge of #6726 : alexcrichton/rust/filter-blocks, r=z0w0...
[04:27:47] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[04:28:22] *** Quits: tikue (tkuehn@moz-CF8BEBEF.dia.static.qwest.net) (Quit: tikue)
[04:28:34] *** Joins: mcomella (mcomella@moz-B10FF54F.ri.ri.cox.net)
[04:28:47] <steven_is_false> What's the version of find that caches the results so it goes really fast but doesn't work on stuff that's been recently changed?
[04:30:29] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[04:30:43] <engla> steven_is_false: locate?
[04:31:50] <engla> steven_is_false: if you want a fast version of grep, the silver searcher ("ag") is cool
[04:32:13] <dbaupp> steven_is_false: 'git grep' is fast too
[04:32:38] <engla> yes. ag is good for those times it's not tracked by git
[04:32:48] <steven_is_false> engla: Strange, I thought it was locate but it wasn't installed by default so I was confused.
[04:33:13] *** Quits: hjr3 (hradtke@moz-AE3056B9.static.stls.mo.charter.com) (Ping timeout)
[04:34:00] <bjz_> Jeaye: ahh! sorry!
[04:34:16] <bjz_> Jeaye: it was glfw::CURSOR_DISABLED
[04:34:30] <bjz_> Jeaye: not glfw::CURSOR_HIDDEN
[04:37:31] *** Joins: mindginative (mindginati@moz-6882665A.dsl.dyn.ihug.co.nz)
[04:37:36] *** Parts: mindginative (mindginati@moz-6882665A.dsl.dyn.ihug.co.nz) ()
[04:37:41] <bjz_> Jeaye: could you try running the 'peter' test in the tests folder in glfw?
[04:38:22] *** Quits: dbaupp (Thunderbir@moz-55402325.lns20.syd6.internode.on.net) (Ping timeout)
[04:39:36] *** Quits: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[04:40:22] <Jeaye> bjz_: Home from work now, since it's late. I won't have the Mac until Monday, but I'll try it then.
[04:40:30] <bjz_> Jeaye: cool
[04:40:44] <Jeaye> And I'll mak3e sure CURSOR_DISABLED is working on Linux.
[04:40:48] <Jeaye> Thanks for the update
[04:40:53] <bjz_> Jeaye: I had an error building glfw
[04:40:55] <bjz_> sorry
[04:40:57] <bjz_> q3
[04:41:10] <bjz_> Â»Â»Â» Building DEBUG Q^3 (this can take a while)
[04:41:10] <bjz_> src/ui/mod.rs:17:4: 17:7 error: error opening src/ui/ttf/mod.rs
[04:41:10] <bjz_> src/ui/mod.rs:17 mod ttf;
[04:41:19] <bjz_> doing ./configure
[04:41:21] <bjz_> then make
[04:41:40] *** Joins: mr_wibble (Mibbit@moz-FDEE2005.dyn.optonline.net)
[04:41:55] <Jeaye> bjz_: $ ls src/ui/ttf
[04:42:13] *** Quits: mr_wibble (Mibbit@moz-FDEE2005.dyn.optonline.net) (Quit: http://www.mibbit.com ajax IRC Client)
[04:42:23] *** Joins: mib_jf6kds (Mibbit@moz-FDEE2005.dyn.optonline.net)
[04:42:28] <bjz_> brendan ~/dev/rust/q3
[04:42:28] <bjz_>  % ls src/ui/ttf
[04:42:28] <bjz_> ls: src/ui/ttf: No such file or directory
[04:42:29] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[04:43:17] <Jeaye> bjz_: What branch is this? checkout master and pull from origin?
[04:43:19] <bjz_> https://github.com/Jeaye/q3/tree/master/src/ui
[04:43:31] <bjz_> forget to push it?
[04:43:35] <bjz_> :P
[04:43:49] <Jeaye> maybe. :P Let's see
[04:43:55] <bjz_> master
[04:44:14] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[04:44:31] <Jeaye> ahh
[04:46:05] <Jeaye> bjz_: Fixing now, sorry
[04:46:50] <bjz_> Jeaye: the weird thing is the 'peter' test prints a float witha a several decimal places when using CURSOR_DISABLED, but when I do a test with my bindings it gives me coordinates with integer precision
[04:47:05] <Jeaye> hmm
[04:47:23] *** Quits: mib_jf6kds (Mibbit@moz-FDEE2005.dyn.optonline.net) (Quit: http://www.mibbit.com ajax IRC Client)
[04:47:31] <bjz_> oh wait
[04:47:34] <bjz_> wrong
[04:47:36] <bjz_> it does
[04:47:37] <bjz_> :P
[04:47:52] <bjz_> (you hit space to switch modes)
[04:48:38] *** Joins: hjr3 (hradtke@moz-AE3056B9.static.stls.mo.charter.com)
[04:49:35] <bjz_> so with CURSOR_DISABLED, it works both in windowed and full screen mode on osx
[04:49:53] <bjz_> but if in windowed mode it shows the cursor
[04:50:10] <bjz_> where as in the peter example it doesn't
[04:50:40] <steven_is_false> Does the benchmarker run the code inside iter in parrallel?
[04:50:44] *** Joins: dbaupp (Thunderbir@moz-47674341.lns20.syd6.internode.on.net)
[04:51:13] <steven_is_false> I get multithreading errors while trying to benchmark how fast I can setup, and tear down a window.
[04:51:48] *** Quits: a_m0d (a_m0d@moz-9F925EFA.hm.shawcable.net) (Quit: Leaving.)
[04:51:50] <Jeaye> bjz_: mind pulling and giving it another go?
[04:51:58] <bjz_> YES
[04:52:06] <bjz_> why would I do that?
[04:52:10] <bjz_> never
[04:52:55] <steven_is_false> Personally, I'm not sure that benchmarking should be multithreaded.
[04:53:25] <dbaupp> steven_is_false: i don't think it is multithreaded
[04:53:50] <dbaupp> hm, actually, maybe it is
[04:53:52] <steven_is_false> dbaupp: But then why would I be getting the multithreading sdl initialization errors?
[04:53:56] <Jeaye> bjz_: Awww >.<
[04:54:11] <bjz_> Jeaye: why does glfw build twice? once for a static lib, once for a shared?
[04:54:33] <Jeaye> yeah
[04:54:37] *** Quits: tcsc (tcsc@moz-A838B260.dhcp.nwtn.ct.charter.com) (Quit: bye!)
[04:55:58] <bjz_> Jeaye: yikes, it's I got like 1fps
[04:56:14] <bjz_> and the cursor didin't work
[04:56:17] <Jeaye> Say what?!
[04:56:23] <bjz_> and got a malloc error at the end
[04:56:31] * Jeaye looks
[04:56:41] <bjz_> Voxel map creation took 0.27890576 seconds.
[04:56:41] <bjz_> q3(7030,0x7fff70533180) malloc: *** error for object 0x7ff4b9c11610: incorrect checksum for freed object - object was probably modified after being freed.
[04:56:41] <bjz_> *** set a breakpoint in malloc_error_break to debug
[04:57:00] <aatch> the test runner starts a seperate task for each test
[04:57:04] <dbaupp> steven_is_false: I'm not sure, but it looks like only #[test]'s spawn extra threads
[04:57:05] <bjz_> (which might be my fault in glfw, I don't know)
[04:57:18] <aatch> so it can actually know about failures
[04:57:44] <aatch> I'm not sure about the bench marker though.
[04:58:12] <Jeaye> bjz_: That's likely the crash I'm getting while closing. It shits the bed every time you close the window -- it's solved by commenting out that closure callback we mentioned before.
[04:58:32] <bjz_> oh wait, it was still on cursor hidden
[04:58:35] <Jeaye> But, anyway, you voxelized in a third of a second, but you get 1fps?
[04:58:54] <Jeaye> Are you running on a phone? :P
[04:59:20] <bjz_> Voxel map creation took 0.27874589 seconds.
[04:59:20] <bjz_> Assertion failed: (box->td != NULL), function free, file /Users/brendan/dev/rust/rust/src/rt/boxed_region.cpp, line 75.
[04:59:20] <bjz_> zsh: abort      ./bin/q3
[04:59:27] <Jeaye> I get 60fps on my Mac, and 80fps on my Linux box.
[04:59:27] <bjz_> heh
[04:59:38] <bjz_> I've got 1fps again too
[04:59:50] <bjz_> 8[
[04:59:54] <Jeaye> bjz_: Yeah, that happens whenever you close. Gotta fix that callback.
[05:00:02] <Jeaye> bjz_: What gpu do you have?
[05:00:20] <bjz_> Nvidia 9400m I think
[05:00:34] <bjz_> NVIDIA GeForce 9400M
[05:00:49] <bjz_> my macbook pro is on the old side
[05:00:53] <bjz_> but still
[05:00:57] <bjz_> not horrible
[05:01:08] <Jeaye> That's insanely terrible.
[05:01:09] <bjz_>   VRAM (Total):	256 MB
[05:01:31] <bjz_> my graphics card? :P
[05:01:40] <Jeaye> I mean, you voxelize very quickly, so the cpu is not slow. But the GPU mustn't like that instance rendering.
[05:01:57] <bjz_> yeah
[05:02:01] <bjz_> strange
[05:02:22] <Jeaye> Hmm. Well, it's good to know that. Thanks for giving it a go.
[05:02:43] <bjz_> no worries
[05:02:43] <hjr3> my first PR: https://github.com/mozilla/rust/pull/6730 please be gentle ;)
[05:02:59] <bjz_> Jeaye: if you need any more help, let me know
[05:03:20] <Jeaye> bjz_: One final thing: $ make release; ./bin/q3
[05:03:38] <Jeaye> See if that speeds things up at all.
[05:03:47] <bjz_> ooh
[05:03:51] <bjz_> just a sec
[05:04:42] <bjz_> nuhu
[05:04:56] <bjz_> like, there's a zero in the top corner
[05:05:03] <bjz_> I assume that's fps?
[05:05:08] <bjz_> :P
[05:05:09] <Jeaye> hot damn, yeah
[05:05:15] <bjz_> lolwut
[05:05:20] <Jeaye> Ok. Thanks again.
[05:05:42] <bjz_> my card can't seriously be that bad
[05:06:30] <Jeaye> I'm getting 80fps right now on a legacy ATI Radeon card.
[05:06:36] <Jeaye> Are your drivers up to date?
[05:06:53] <bjz_> well, I can use opengl 3.2
[05:07:13] <bjz_> and you don't really 'update' drivers on osx
[05:07:16] <Jeaye> afk shower
[05:07:57] <bjz_> they keep everyone on the same version across all of their products.
[05:08:22] <bjz_> then when they update the opengl version some folks can't upgrade to the new OS
[05:08:53] *** Joins: SimonSapin (simon@B1CE442D.7327B66B.5FA4DAFA.IP)
[05:08:59] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Connection reset by peer)
[05:10:08] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[05:12:31] *** Quits: engla (engla@2AD2AF06.C84525FB.186BC0CB.IP) (Ping timeout)
[05:17:02] <steven_is_false> My benchmark of opening, and closing the window really fast is taking a really long time.
[05:17:58] <Jeaye> bjz_: You're rendering a 200x200x200 map resolution at 1fps. I rendered a 1000x1000x1000 map resolution on my work Mac earlier today with > 10fps; I'd seriously check for faulty/dated drivers.
[05:18:31] *** Quits: an0nymous (an0nymous@moz-A6B0CE4.tx.res.rr.com) (Ping timeout)
[05:22:35] <thomaslee> brson, thanks for that review -- figured out that I didn't need to change anything except the C++ code once the build system change landed. All tests passing, all looks great. Good times! :)
[05:23:23] <bjz_> Jeaye: I'm looking now
[05:23:35] <bjz_> Jeaye: I can run other things fine
[05:23:42] <Jeaye> bjz_: Do you game at all?
[05:23:53] <bjz_> Jeaye: I've always just rely on software update
[05:25:30] <bjz_> Jeaye: I mainly play indie games
[05:25:37] <Jeaye> hmm
[05:26:19] <bjz_> Jeaye: I can run Unity games fine
[05:26:52] <Jeaye> Yeah, it could just be that your card doesn't like the features I'm relying very heavily on.
[05:27:08] <Jeaye> Which would be a massive bummer.
[05:27:45] <steven_is_false> One can wrap a task to do something when it terminates right (and even on failure?)
[05:27:45] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[05:27:45] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/JqTwZQ
[05:27:45] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[05:28:05] <bjz_> Jeaye: that is weird
[05:29:53] <bjz_> Jeaye: I can run Minecraft, but I hear they used the old pipeline for opengl
[05:30:18] <aatch> steven_is_false, I think so.
[05:30:20] <Jeaye> Minecraft uses OpenGL 1.1
[05:30:33] <bjz_> heh, yep
[05:30:37] <bjz_> Jeaye: the Nvidia driver site only has drivers up to 10.6.8
[05:30:42] <aatch> I also think you can register functions to run when tasks end.
[05:30:43] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[05:30:43] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/uLgpTw
[05:30:43] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[05:30:44] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[05:30:44] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/3s1QWQ
[05:30:44] <ghrust> 13rust/06auto 14876ce10 15Alex Crichton: Update the linenoise library
[05:30:44] <ghrust> 13rust/06auto 14af27e17 15Alex Crichton: Set the USE_UTF8 flag for linenoise to handle utf8-input
[05:30:46] <ghrust> 13rust/06auto 14b8fbbe1 15bors: auto merge of #6728 : alexcrichton/rust/update-linenoise, r=Aatch...
[05:30:48] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[05:30:59] <bjz_> Jeaye: I think this stuff is updated in software update
[05:31:40] <bjz_> Jeaye: I know Apple was really behind in OpenGL for AGES, then bumped everyone up to 3.2 in 10.8
[05:31:46] <Jeaye> bjz_: Does glfw-rs have control over vsync?
[05:31:59] <bjz_> Jeaye: I think so
[05:32:03] <bjz_> just a sec
[05:32:21] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[05:32:33] <bjz_> glfwSwapInterval?
[05:32:58] <Jeaye> Yeah, found it. Let me try to set that for you to see if it helps.
[05:33:13] <bjz_> oh I can just alter the source
[05:33:22] <bjz_> where should I put it?
[05:33:38] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[05:33:46] <Jeaye> Line 53 of main.rs
[05:33:59] <Jeaye> After the context creation
[05:34:13] <Jeaye> Set it to 0
[05:34:16] <bjz_> how much?
[05:34:39] *** Joins: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP)
[05:34:41] <bjz_> ok
[05:35:59] <bjz_> nope, still 0fps
[05:36:23] *** Quits: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP) (Ping timeout)
[05:36:36] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[05:36:37] <bjz_> maybe we could do a search on the opengl stuff you use, with 9400m os x
[05:38:06] <Jeaye> bjz_: What OS version are you?
[05:38:17] <bjz_> 10.8.3
[05:38:23] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[05:39:46] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[05:39:46] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14b8fbbe1 to 140628c92: 02http://git.io/N3iJvQ
[05:39:46] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[05:39:53] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[05:41:13] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[05:42:47] *** Joins: drrb (drrb@moz-1D881E2B.lnse1.ken.bigpond.net.au)
[05:42:54] <acrichto> aatch: could I get another r+ for https://github.com/mozilla/rust/pull/6728 ?
[05:43:11] <acrichto> if only I could have my own personal buildbot to run builds on something other than osx...
[05:44:04] <acrichto> aatch: thanks!
[05:44:08] <aatch> acrichto, eh, it's what it's for
[05:45:12] <Jeaye> bjz_: Not sure, mate. I didn't find anything right off, and the vsync bit is the only thing I can think of. I'll put some more time into it this weekend. Thanks again for the interactive help. :)
[05:46:54] <TD-Linux> I've been out of the loop for about a month, has anything happened wrt static linking crates?
[05:47:09] <aatch> TD-Linux, not as far as I'm aware
[05:47:20] <Jeaye> Yeah, I don't think so.
[05:50:08] <TD-Linux> I'm not exactly sure how to approach it - should it be like a separte subarchitecture, since build flags are different (no PIC)
[05:51:10] <TD-Linux> would people ever want to be able to build both at the same time? the platform I'm targeting doesn't support dynamic linking
[05:51:43] <aatch> TD-Linux, you could implement it a separate target
[05:52:07] <aatch> However, maybe adding what the platforms provide would be better.
[05:52:49] <aatch> I don't know what the potential with static linking are (other than no PIC) though.
[06:00:07] *** Quits: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk) (Quit: Ex-Chat)
[06:04:19] *** Quits: aatch (aatch@moz-2BB0AC01.cable.telstraclear.net) (Client exited)
[06:05:52] *** Joins: mflamer (Mibbit@moz-C6ED16AA.hsd1.ca.comcast.net)
[06:06:57] <mflamer> rusti' fn part<T1,T2,T3,T4>(f:&fn(a:T1, b:T2, c:T3) -> T4, x:T1) -> @fn(T2, T3) -> T4 { 	|b2:T2, c2:T3| f(*x, b2, c2) }
[06:07:50] <dbaupp> rusti: fn part<T1,T2,T3,T4>(f:&fn(a:T1, b:T2, c:T3) -> T4, x:T1) -> @fn(T2, T3) -> T4 { |b2:T2, c2:T3| f(*x, b2, c2) }
[06:07:52] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/cTeZ
[06:08:22] <dbaupp> mflamer: rusti only responds to "rusti:"
[06:09:55] <mflamer> dbaupp: thanks
[06:11:01] <mflamer> rusti: fn part<T1,T2,T3,T4>(f:&fn(a:T1, b:T2, c:T3) -> T4, x:T1) -> @fn(T2, T3) -> T4 { 	|b2:T2, c2:T3| f(x, b2, c2) }
[06:11:02] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/QTEW
[06:12:28] <mflamer> there we go, the first one was wrong. That's the error I'm looking for. What does it mean?
[06:12:57] <mflamer> error: cannot move out of captured outer variable in a heap closure
[06:13:29] <bjz_> rusti: fn part<'a,T1,T2,T3,T4>(f:&'a fn(a:T1, b:T2, c:T3) -> T4, x:T1) -> &'a fn(T2, T3) -> T4 { |b2:T2, c2:T3| f(x, b2, c2) }
[06:13:30] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/KRZC
[06:14:00] <bjz_> rusti: fn part<'a,T1,T2,T3,T4>(f:&'a fn(a:T1, b:T2, c:T3) -> T4, x:T1) -> &'a fn(T2, T3) -> T4 { &'a |b2:T2, c2:T3| f(x, b2, c2) }
[06:14:01] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/PXQi
[06:14:13] <bjz_> bleh
[06:14:21] *** Quits: hjr3 (hradtke@moz-AE3056B9.static.stls.mo.charter.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[06:14:38] <bjz_> rusti: fn part<T1,T2,T3,T4>(f:@fn(a:T1, b:T2, c:T3) -> T4, x:T1) -> @fn(T2, T3) -> T4 { |b2:T2, c2:T3| f(x, b2, c2) }
[06:14:40] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/YFBa
[06:15:05] <dbaupp> rusti: fn part<T1,T2,T3,T4>(f:@fn(a:T1, b:T2, c:T3) -> T4, x: @T1) -> @fn(T2, T3) -> T4 { |b2:T2, c2:T3| f(*x, b2, c2) }
[06:15:07] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/CRPL
[06:15:19] <bjz_> rusti: fn part<T1,T2,T3,T4>(f:&'static fn(a:T1, b:T2, c:T3) -> T4, x:T1) -> &fn(T2, T3) -> T4 { |b2:T2, c2:T3| f(x, b2, c2) }
[06:15:21] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/BPfg
[06:15:30] <dbaupp> rusti: fn part<T1: 'static,T2,T3,T4>(f:@fn(a:T1, b:T2, c:T3) -> T4, x: @T1) -> @fn(T2, T3) -> T4 { |b2:T2, c2:T3| f(*x, b2, c2) }
[06:15:31] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/EaFA
[06:15:44] *** Joins: victorporof (victorporo@moz-23D6B301.info.uaic.ro)
[06:15:45] <bjz_> rusti: fn part<T1,T2,T3,T4>(f:&'static fn(a:T1, b:T2, c:T3) -> T4, x:T1) -> &'static fn(T2, T3) -> T4 { |b2:T2, c2:T3| f(x, b2, c2) }
[06:15:47] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/jNMQ
[06:15:53] <dbaupp> rusti: fn part<T1,T2,T3,T4>(f:@fn(a: &T1, b:T2, c:T3) -> T4, x: @T1) -> @fn(T2, T3) -> T4 { |b2:T2, c2:T3| f(x, b2, c2) }
[06:15:54] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/XcMF
[06:15:57] <bjz_> rusti: fn part<T1,T2,T3,T4>(f:&'static fn(a:T1, b:T2, c:T3) -> T4, x:T1) -> @fn(T2, T3) -> T4 { |b2:T2, c2:T3| f(x, b2, c2) }
[06:15:58] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/OTIU
[06:16:03] <bjz_> :P
[06:16:16] <dbaupp> rusti: fn part<T1: 'static,T2,T3,T4>(f:@fn(a: &T1, b:T2, c:T3) -> T4, x: @T1) -> @fn(T2, T3) -> T4 { |b2:T2, c2:T3| f(x, b2, c2) }
[06:17:01] <dbaupp> rusti: fn part<T1: 'static,T2,T3>(f:@fn(a: &T1, b:T2) -> T4, x: @T1) -> @fn(T2) -> T4 { |b2:T2| f(x, b2) } part(|a, b| *a + b, @1)(2)
[06:17:02] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/HOFP
[06:17:15] <dbaupp> rusti: fn part<T1: 'static,T2,T3>(f:@fn(a: &T1, b:T2) -> T4, x: @T1) -> @fn(T2) -> T3 { |b2:T2| f(x, b2) } part(|a, b| *a + b, @1)(2)
[06:17:16] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/SdbA
[06:17:27] <dbaupp> rusti: fn part<T1: 'static,T2,T3>(f:@fn(a: &T1, b:T2) -> T3, x: @T1) -> @fn(T2) -> T3 { |b2:T2| f(x, b2) } part(|a, b| *a + b, @1)(2)
[06:17:28] -rusti- 3
[06:17:42] <mflamer> :-)
[06:17:50] <dbaupp> mflamer: the problem is how long the variables live for
[06:17:52] <dbaupp> essentially
[06:18:15] <dbaupp> a heap closure live on the garbage collected heap, and lives for as long as it is referenced, somewhere
[06:18:32] <mflamer> I thought it was something like that, I dont really have a grasp on lifetime yet
[06:18:51] <dbaupp> but the outer variable can live anywhere, including on the stack, and in that case, it only lasts for the length of the function call it's defined in
[06:19:01] <mflamer> so, heap box should last as long as needed nno mater what
[06:19:21] <dbaupp> yes
[06:19:40] <dbaupp> you can get similar (non-lazy) semantics to Haskell by just using @ in front of everything
[06:19:53] <dbaupp> (i.e. make everything on the garbage collected heap)
[06:19:58] <mflamer> I get that
[06:21:12] <mflamer> but...I want the freedom like C++, So I dont want to get to lazy 
[06:21:25] <mflamer> Thanks for your help
[06:21:51] <dbaupp> np :)
[06:22:33] <dbaupp> also, the "move" part of that error message is saying that a heap closure can't take ownership of arbitrary variables
[06:22:49] *** Joins: seth (seth@5AAE35B2.5EFFC0B8.24454B25.IP)
[06:23:52] <mflamer> that  makes sense
[06:24:33] *** Quits: seth (seth@5AAE35B2.5EFFC0B8.24454B25.IP) (Ping timeout)
[06:24:34] <mflamer> what is the 'static
[06:24:48] <dbaupp> 'static is the "static lifetime"
[06:25:06] <mflamer> I understand static methods, but this is different
[06:25:07] <dbaupp> which means that any borrowed pointers in the type have to point to static data
[06:25:20] <dbaupp> i.e. global constants
[06:25:46] <dbaupp> (data types that have no borrowed pointers are considered 'static)
[06:26:54] <mflamer> is there somewhere to read about that? I haven't seen mention of it 
[06:27:07] <dbaupp> um, not sure
[06:27:21] <dbaupp> (reading what people say on IRC? :P )
[06:27:39] *** Joins: sankha93 (Instantbir@AB175D9E.DD6DC479.BE90E62C.IP)
[06:27:59] <dbaupp> mflamer: http://static.rust-lang.org/doc/rust.html#static-items a little bit
[06:28:36] <dbaupp> and then there is an example of a data type with a borrowed pointer here http://static.rust-lang.org/doc/rust.html#tuple-types
[06:30:42] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[06:30:48] *** Joins: yong (chatzilla@74DA0C97.4E87ADC2.263D9828.IP)
[06:31:05] *** Quits: SimonSapin (simon@B1CE442D.7327B66B.5FA4DAFA.IP) (Quit: Leaving.)
[06:31:29] *** Joins: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net)
[06:32:33] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[06:32:56] *** Quits: yong (chatzilla@74DA0C97.4E87ADC2.263D9828.IP) (Client exited)
[06:33:05] *** Joins: aruniiird (arun@2DD01E3A.FA52E998.FFE8C4AF.IP)
[06:33:53] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[06:33:53] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/eCNKLg
[06:33:53] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[06:35:12] *** Joins: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP)
[06:35:49] *** Joins: SimonSapin (simon@7096B777.7327B66B.5FA4DAFA.IP)
[06:36:13] <bjz_> nmatsakis: so it would be dangerous to use this? https://gist.github.com/bjz/7d8432f8b658363a0192
[06:36:49] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[06:36:49] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/85xT7g
[06:36:49] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[06:36:50] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[06:36:50] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/3CCTAw
[06:36:50] <ghrust> 13rust/06auto 14876ce10 15Alex Crichton: Update the linenoise library
[06:36:50] <ghrust> 13rust/06auto 14af27e17 15Alex Crichton: Set the USE_UTF8 flag for linenoise to handle utf8-input
[06:36:51] <ghrust> 13rust/06auto 14bf4d372 15Alex Crichton: Fix compilation errors with linenoise
[06:36:53] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[06:36:58] *** Quits: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP) (Ping timeout)
[06:39:53] *** Quits: aruniiird (arun@2DD01E3A.FA52E998.FFE8C4AF.IP) (Ping timeout)
[06:40:29] *** Quits: sankha93 (Instantbir@AB175D9E.DD6DC479.BE90E62C.IP) (Ping timeout)
[06:41:05] *** Joins: zxcdw (r-a@moz-C7C5467B.cust.bredband2.com)
[06:42:07] *** Joins: moon (sean@AC3C6297.B19D4423.36AE428F.IP)
[06:42:28] *** Joins: yong (chatzilla@74DA0C97.4E87ADC2.263D9828.IP)
[06:49:10] *** Quits: moon (sean@AC3C6297.B19D4423.36AE428F.IP) (Client exited)
[06:55:19] *** Joins: aruniiird (arun@7D87F798.A3499980.FFE8C4AF.IP)
[06:57:25] *** Quits: aruniiird (arun@7D87F798.A3499980.FFE8C4AF.IP) (Ping timeout)
[06:57:38] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[06:58:15] *** Joins: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP)
[06:58:47] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[07:04:24] *** Quits: anshin (nbs@441B8B9E.2055B963.D2A6B5.IP) (Quit: Lost terminal)
[07:06:02] *** Quits: steven_is_false (user@moz-144077DE.bchsia.telus.net) (Ping timeout)
[07:06:02] *** Joins: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP)
[07:07:15] *** Quits: mflamer (Mibbit@moz-C6ED16AA.hsd1.ca.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[07:07:46] *** Quits: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP) (Ping timeout)
[07:11:19] *** Quits: dbaupp (Thunderbir@moz-47674341.lns20.syd6.internode.on.net) (Quit: dbaupp)
[07:11:22] *** Joins: dbaupp (Thunderbir@moz-47674341.lns20.syd6.internode.on.net)
[07:12:58] *** Joins: aruniiird (arun@D8D62F6.83FAFB90.73686190.IP)
[07:17:47] *** Quits: brson (brson@E9CDE21E.991753BB.CA4D1600.IP) (Quit: leaving)
[07:19:44] <SimonSapin> rusti: error!(-1 as char)
[07:19:45] -rusti- rust: task failed at 'assertion failed: s.len() <= pad', /build/rust-incoming-git/src/rust/src/libstd/char.rs:207
[07:19:45] -rusti- rust: domain main @0x23b01b0 root task failed
[07:20:05] <SimonSapin> rusti: error!(42 as char)
[07:20:06] -rusti- rust: ~"\'*\'"
[07:20:34] <SimonSapin> rusti: error!((42 as char) as u64)
[07:20:35] -rusti- rust: ~"42"
[07:20:42] <SimonSapin> rusti: error!((-1 as char) as u64)
[07:20:43] -rusti- rust: ~"18446744073709551615"
[07:23:23] *** Joins: seth (seth@5AAE35B2.5EFFC0B8.24454B25.IP)
[07:23:35] *** Joins: victorporof_ (victorporo@moz-23D6B301.info.uaic.ro)
[07:23:47] *** Quits: victorporof (victorporo@moz-23D6B301.info.uaic.ro) (Ping timeout)
[07:24:49] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[07:25:14] *** Quits: seth (seth@5AAE35B2.5EFFC0B8.24454B25.IP) (Ping timeout)
[07:26:36] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[07:26:42] <dbaupp> bstrie: ping
[07:30:49] *** Quits: victorporof_ (victorporo@moz-23D6B301.info.uaic.ro) (Ping timeout)
[07:36:48] *** Joins: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP)
[07:37:19] *** Quits: SimonSapin (simon@7096B777.7327B66B.5FA4DAFA.IP) (Quit: Leaving.)
[07:38:27] *** Quits: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP) (Ping timeout)
[07:38:47] *** Quits: devbug (quassel@moz-E1DE087C.bchsia.telus.net) (Client exited)
[07:39:23] *** Joins: SimonSapin (simon@D8D008B7.7327B66B.5FA4DAFA.IP)
[07:42:53] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[07:42:53] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/3CCTAw
[07:42:53] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[07:45:36] *** Joins: tikue (tkuehn@moz-CF8BEBEF.dia.static.qwest.net)
[07:54:29] *** Joins: jviereck (Adium@moz-4D99BD11.zuehlke.com)
[07:56:07] *** Joins: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP)
[08:02:02] *** Joins: fabiand (fabiand@moz-FB9C03E7.adsl.alicedsl.de)
[08:03:07] <Diablo-D3> http://computationallyendowed.com/blog/2012/12/03/ifs-and-ands-and-plan-9s-source-code.html
[08:04:03] *** Joins: berak (chatzilla@D30F4F90.8B38C502.16E13E53.IP)
[08:04:08] *** Quits: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP) (Connection reset by peer)
[08:07:14] *** Quits: blitter (blitter@moz-E761A52F.dyn.centurytel.net) (Ping timeout)
[08:07:39] *** Joins: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP)
[08:09:29] *** Quits: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP) (Ping timeout)
[08:10:21] *** Quits: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Quit: zzzZZZ)
[08:11:50] *** Quits: SimonSapin (simon@D8D008B7.7327B66B.5FA4DAFA.IP) (Ping timeout)
[08:13:22] *** Joins: pyrac (pyrac@moz-D851FA22.w92-149.abo.wanadoo.fr)
[08:18:56] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[08:19:59] <dbaupp> Diablo-D3: that would be horrible in Rust, hehe
[08:20:42] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[08:24:21] *** Joins: SimonSapin (simon@7096B777.7327B66B.5FA4DAFA.IP)
[08:25:42] *** Quits: fabiand (fabiand@moz-FB9C03E7.adsl.alicedsl.de) (Quit: Verlassend)
[08:27:46] *** Joins: steven_is_false (user@1E3F14AE.29819A33.115CE8E4.IP)
[08:27:58] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[08:32:54] *** Quits: jviereck (Adium@moz-4D99BD11.zuehlke.com) (Quit: Leaving.)
[08:34:36] *** Quits: steven_is_false (user@1E3F14AE.29819A33.115CE8E4.IP) (Ping timeout)
[08:34:55] *** Quits: SimonSapin (simon@7096B777.7327B66B.5FA4DAFA.IP) (Ping timeout)
[08:37:25] *** Joins: victorporof (victorporo@moz-23D6B301.info.uaic.ro)
[08:38:25] *** Joins: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP)
[08:39:10] *** Joins: SimonSapin (simon@D8D008B7.7327B66B.5FA4DAFA.IP)
[08:40:08] *** Quits: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP) (Ping timeout)
[08:43:57] *** Quits: tikue (tkuehn@moz-CF8BEBEF.dia.static.qwest.net) (Quit: tikue)
[08:44:09] *** Quits: victorporof (victorporo@moz-23D6B301.info.uaic.ro) (Ping timeout)
[08:45:30] *** Joins: victorporof (victorporo@moz-23D6B301.info.uaic.ro)
[08:53:50] *** Joins: kud1ing (Mibbit@moz-D0EFC33D.pools.arcor-ip.net)
[08:54:54] <kud1ing> aatch: see https://github.com/Aatch/rust-datetime/pull/1
[08:56:56] *** Joins: jviereck (Adium@moz-4D99BD11.zuehlke.com)
[08:58:28] *** Quits: kud1ing (Mibbit@moz-D0EFC33D.pools.arcor-ip.net) (Quit: http://www.mibbit.com ajax IRC Client)
[09:03:46] *** Joins: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk)
[09:09:13] *** Joins: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP)
[09:11:00] *** Quits: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP) (Ping timeout)
[09:13:01] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[09:14:47] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[09:16:28] *** Joins: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP)
[09:22:31] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[09:24:36] *** Joins: seth (seth@5AAE35B2.5EFFC0B8.24454B25.IP)
[09:26:39] *** Quits: seth (seth@5AAE35B2.5EFFC0B8.24454B25.IP) (Ping timeout)
[09:29:03] *** Quits: pyrac (pyrac@moz-D851FA22.w92-149.abo.wanadoo.fr) (Quit: pyrac)
[09:29:48] *** Joins: aatch (aatch@moz-2BB0AC01.cable.telstraclear.net)
[09:29:56] <aatch> Boo!
[09:30:12] <bjz_> ooB
[09:33:53] <aatch> dbaupp, nice work on the dynamic loading
[09:34:11] *** Joins: fabiand (fabiand@moz-FB9C03E7.adsl.alicedsl.de)
[09:34:38] *** Joins: pyrac (pyrac@moz-D851FA22.w92-149.abo.wanadoo.fr)
[09:37:28] <ruediger> what do you guys use for git diff custom hunk headers? I'm currently using xfuncname = "^((fn|struct|enum|impl|trait|mod|pub mod)[^;]*)$" but not sure if this is even still correct or if there is something better (something official?!)  Maybe we could get something builtin into git.
[09:39:30] *** Quits: SimonSapin (simon@D8D008B7.7327B66B.5FA4DAFA.IP) (Quit: Leaving.)
[09:39:46] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[09:39:58] *** Joins: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP)
[09:41:45] *** Quits: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP) (Ping timeout)
[09:44:08] *** Quits: jviereck (Adium@moz-4D99BD11.zuehlke.com) (Quit: Leaving.)
[09:46:00] *** Joins: haard (fredrik@moz-6A86987C.dynamic.se.alltele.net)
[09:50:05] *** Quits: victorporof (victorporo@moz-23D6B301.info.uaic.ro) (Ping timeout)
[09:57:53] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[09:57:53] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/B71Aew
[09:57:53] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[09:57:54] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[09:57:54] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/2E27IQ
[09:57:54] <ghrust> 13rust/06auto 14e7fdeb7 15Niko Matsakis: Issue #3678: Remove wrappers and call foreign functions directly
[09:57:54] <ghrust> 13rust/06auto 1468ff762 15bors: auto merge of #6661 : nikomatsakis/rust/issue-3678-wrappers-be-gone-2, r=brson...
[09:57:54] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[09:58:41] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[09:58:45] *** Quits: fabiand (fabiand@moz-FB9C03E7.adsl.alicedsl.de) (Quit: Verlassend)
[09:59:18] <bjz_> ooh
[10:05:19] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[10:07:54] *** Joins: victorporof (victorporo@moz-23D6B301.info.uaic.ro)
[10:10:49] *** Joins: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP)
[10:12:41] *** Quits: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP) (Ping timeout)
[10:16:44] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[10:17:51] *** Joins: vosen (vosen@moz-266BA656.icpnet.pl)
[10:18:46] *** Joins: jviereck (Adium@moz-4D99BD11.zuehlke.com)
[10:20:35] *** Joins: seth (seth@5AAE35B2.5EFFC0B8.24454B25.IP)
[10:26:57] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[10:27:51] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[10:27:51] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1468ff762 to 14b238a08: 02http://git.io/N3iJvQ
[10:27:51] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[10:27:53] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[10:27:53] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/IecJ9A
[10:27:53] <ghrust> 13rust/06auto 14257192c 15Huon Wilson: Ignore the generated docs for libextra
[10:27:53] <ghrust> 13rust/06auto 146e65a3f 15bors: auto merge of #6734 : huonw/rust/gitignore, r=thestinger
[10:27:53] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[10:28:33] *** Joins: scriptdevil (scriptdevi@1E6810B.D65816C7.520CDC98.IP)
[10:29:04] <scriptdevil> Hi, There is a mistake in the landing page of rust-lang. It should be rand::rng().shuffle() and not rand::Rng().shuffle()
[10:30:53] <aatch> scriptdevil, that's not the only thing wrong with it...
[10:33:24] <scriptdevil> aatch: It compiles otherwise and runs as I expected it to.,
[10:33:45] <scriptdevil> At least on the latest github version.
[10:35:38] <aatch> well, incoming breaks it.
[10:36:04] *** Quits: pyrac (pyrac@moz-D851FA22.w92-149.abo.wanadoo.fr) (Quit: pyrac)
[10:36:04] *** Joins: spider-mario (spidermari@moz-2F72F6FF.dsl.quantic-telecom.net)
[10:36:10] <scriptdevil> aatch: Ok. What is the other change?
[10:36:25] <aatch> There's no core anymore
[10:36:39] <aatch> it's called std
[10:36:46] <aatch> and what was std, is now extra
[10:36:50] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[10:36:51] <scriptdevil> aatch: I did not know that. Thanks!
[10:38:07] *** Quits: jviereck (Adium@moz-4D99BD11.zuehlke.com) (Quit: Leaving.)
[10:38:40] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[10:41:31] <scriptdevil> bye
[10:41:36] *** Quits: scriptdevil (scriptdevi@1E6810B.D65816C7.520CDC98.IP) (Quit: leaving)
[10:41:40] *** Joins: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP)
[10:42:09] *** Quits: victorporof (victorporo@moz-23D6B301.info.uaic.ro) (Ping timeout)
[10:43:29] *** Quits: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP) (Ping timeout)
[10:45:43] *** Quits: seth (seth@5AAE35B2.5EFFC0B8.24454B25.IP) (Input/output error)
[10:46:24] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[10:50:45] *** Joins: victorporof (victorporo@moz-23D6B301.info.uaic.ro)
[10:50:57] *** Quits: haard (fredrik@moz-6A86987C.dynamic.se.alltele.net) (Ping timeout)
[10:51:46] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[10:52:54] <steven_is_false> Hi! I understand that once rustc is done there is not a lot more that can be done with the code. However, isn't possible to strip out a bit of excess gunk and lower the binary size?
[10:54:53] <strcat> you mean of the libraries?
[10:55:02] *** Joins: solancile (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net)
[10:55:13] <steven_is_false> strcat: Can't one do things like strip out excess symbols?
[10:55:17] <kimundi> steven_is_false: Well, optimise llvm and rustc more? Don't use features that increase  the binary size?
[10:55:46] <strcat> steven_is_false: yes, use strip
[10:56:08] <strcat> strip --strip-all on binaries
[10:56:15] <strcat> strip --strip-unneeded on libs
[10:56:18] <steven_is_false> strcat: Is there a way to do that as simply a linker option?
[10:56:24] <strcat> steven_is_false: pass -s, I think
[10:56:41] <steven_is_false> strcat: And that's work on the libraries too right?
[10:56:51] *** Joins: EXetoC (ex@moz-C741B177.customer.t3.se)
[10:56:55] <strcat> steven_is_false: yes seems to work
[10:56:58] <strcat> --link-args=-s
[10:59:36] <steven_is_false> strcat: Thank you.
[11:03:57] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[11:04:59] <steven_is_false> So from 600000 to 510000. That's okay but probable not worth much.
[11:07:59] <benh> strcat: You wrote libextra/rc.rs, right?
[11:08:21] <strcat> benh: yes, it needs to be switched to use ~ to allocate though
[11:08:24] <benh> oh :(
[11:08:27] <benh> I was about to ask...
[11:08:30] <benh> how do you feel about a constructor that takes ownership of an unsafe pointer? :V
[11:08:52] <strcat> sounds fine if it's marked as unsafe
[11:09:06] <benh> Well, it's not gonna be compatible with ~ allocations :)
[11:09:18] <benh> I think we ought to have some C++-smartpointer-style wrappers for malloc/free memory in libextra though
[11:09:31] <strcat> benh: you can't allow non-Owned contained objects then
[11:09:42] <strcat> std::rc allows Const which is wrong if it doesn't use ~ to allocate
[11:10:17] <strcat> because @ pointers need to be in managed locations
[11:10:34] <strcat> and @T for T: Const is Const
[11:10:56] <jensnockert> benh: How do smartpointer-style memory work? Just ref-counted pointers to (possibly shared) memory?
[11:11:19] <benh> I'm thinking of the case where a C library gives you ownership of an unsafe pointer, so you want to put it somewhere safe where you don't have to worry about calling free at the end
[11:11:21] <strcat> jensnockert: well C++ calls both std::unique_ptr and std::shared_ptr/std::weak_ptr smart pointers
[11:11:33] <strcat> unique_ptr is just based on scopes like ~, not much different than just any type with a dtor
[11:11:36] <benh> I don't think I understand all the kinds anymore :)
[11:11:54] <steven_is_false> Is stripping unneeded symbols the only improvement that can be done at link time (other than possible link time optimization?)
[11:11:56] <strcat> std::shared_ptr does refcounting, it's the same thing as std::rc::{Rc, RcMut}
[11:12:12] <strcat> but C++11's std::shared_ptr is also atomic refcounting.... but it doesn't do locking on the contained value
[11:12:21] <strcat> steven_is_false: no, there are more
[11:12:30] <strcat> steven_is_false: assuming dynamic linking, you can optimize the symbol lookup tables
[11:12:30] *** Joins: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP)
[11:12:41] <strcat> for static linking or LTO, there's nothing but stripping/LTO
[11:12:49] <strcat> -Wl,-O1 for starters
[11:12:54] <benh> Could we parameterize a container like rc.rs over an allocator maybe...
[11:13:00] <strcat> makes it spend time optimizing the hash tables for lookups in various ways
[11:13:02] <steven_is_false> strcat: I knew there was something to do with dynamic linking.
[11:13:09] <strcat> there's more than -Wl,-O1
[11:13:17] <strcat> more distros seem to use -Wl,-O1,--sort-common
[11:13:26] <strcat> but there are plenty of "unsafe" switches that can break things too
[11:13:54] <strcat> steven_is_false: and gold is a better linker than bfs (the default gnu/gcc one)
[11:13:58] <strcat> bfd*
[11:14:03] *** Parts: berak (chatzilla@D30F4F90.8B38C502.16E13E53.IP) ()
[11:14:09] <strcat> faster to link and makes better tables.
[11:14:18] *** Quits: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP) (Ping timeout)
[11:14:32] <steven_is_false> strcat: The dynamic linking stuff should be worth looking at because Rust uses dynamic linkning for everything right?
[11:14:45] *** Quits: cjh (chellmuth@moz-45C21C42.compute-1.amazonaws.com) (Ping timeout)
[11:14:53] *** Joins: cjh (chellmuth@moz-45C21C42.compute-1.amazonaws.com)
[11:14:57] <strcat> steven_is_false: yes I had a PR to pass -Wl,-O1 but the OS X linker doesn't have it
[11:15:02] <strcat> so I've been pondering about the best way to deal with it
[11:15:17] <strcat> steven_is_false: it's only a startup time optimization, so it's not that important
[11:15:23] <strcat> it doesn't do anything after startup
[11:15:38] <dbaupp> strcat: can it be disabled conditionally on OSX?
[11:15:43] <strcat> dbaupp: yes
[11:15:49] <steven_is_false> Oh fair enough.
[11:15:49] <strcat> but the thing is.... you can use bfd/gold on OS X
[11:15:55] <strcat> no one forces you to use the default terrible linker ;p
[11:16:22] <strcat> it would be nice if lld wasn't a perpetual alpha
[11:16:42] <strcat> dbaupp: https://github.com/mozilla/rust/pull/6724 got that working btw :)
[11:16:42] <steven_is_false> strcat: LDFLAGS ?= etc.. seems smart.
[11:17:12] <dbaupp> strcat: oooooh, "align 8" :)
[11:17:20] <dbaupp> very nice
[11:17:26] <steven_is_false> I've actually got a few pull requests to do now to make the libraries use passed in LDFLAGS.
[11:17:42] <strcat> dbaupp: + memset intrinsic :)
[11:18:02] <dbaupp> we didn't have memset before??
[11:18:07] <strcat> dbaupp: we had a binding to libc
[11:18:14] <strcat> dbaupp: https://github.com/thestinger/rust/commit/346fa0e6dd1cbca73442d847da8289d65292e9b2
[11:18:20] <jensnockert> strcat: Thanks.
[11:18:24] <strcat> and no test!
[11:18:29] <dbaupp> yeah, looking at it now
[11:18:49] <strcat> jensnockert: C++'s is weird since weak_ptr is used to break cycles 
[11:18:59] <strcat> jensnockert: they have a separate storage location for the refcount and the object
[11:19:04] <jensnockert> strcat: How is that weird?
[11:19:10] <strcat> jensnockert: because they have 2 refcounts
[11:19:17] <strcat> they track the # of strong references and the # of weak_ptrs
[11:19:30] <strcat> and both are atomic counters because C++ can't stop you sharing memory, so it'd be an easy trap
[11:19:33] <strcat> so it's slow as hell ;p
[11:19:45] <jensnockert> strcat: Isn't that entirely normal for weak pointers?
[11:19:46] <strcat> ofc you can just move shared_ptr or take an & ref to it
[11:19:50] <strcat> jensnockert: perhaps!
[11:20:04] <jensnockert> strcat: Also, atomics are not _that_ slow.
[11:20:18] <strcat> jensnockert: they are slow when you do them every time you pass a value
[11:20:56] <strcat> our atomic counter of exchange allocs is a significant perf hit
[11:21:49] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[11:21:49] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/IecJ9A
[11:21:49] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[11:22:04] *** Joins: Sorella (queen@B12A78F5.BA14766C.95C8B7C6.IP)
[11:22:41] <jensnockert> strcat: It should just cost as a cache-miss on most x86 systems? (Or less, in the case of uniprocessor systems)
[11:23:16] <strcat> jensnockert: I guess so, but apparently cache misses are pretty expensive
[11:23:24] <jensnockert> Sure, they are.
[11:23:44] <steven_is_false> Does gcc use gold by default if it's installed, I know clang seems to do so?
[11:23:55] <strcat> steven_is_false: no, I don't think either does by default
[11:23:57] <Diablo-D3> strcat: atomics are a magnitude faster than traditional locks, however
[11:24:03] <strcat> steven_is_false: I think they do with -flto
[11:24:13] <strcat> maybe it's a compile-time fla
[11:24:16] <strcat> g
[11:24:35] <Diablo-D3> strcat: and you REQUIRE atomics if you're writing to memory from more than one thread
[11:24:49] <strcat> steven_is_false: ah yeah seems to depend on how it was built.
[11:24:52] <Diablo-D3> and locks on most systems are a bunch of bullshit on top of locks (and still making them slower in the process)
[11:24:59] <strcat> Diablo-D3: and we shouldn't be doing that for exchange allocs
[11:25:06] <Diablo-D3> strcat: nope, you shouldnt.
[11:25:14] <strcat> we are throwing away the benefits of the thread local caches
[11:25:19] <Diablo-D3> I agree.
[11:25:24] <Diablo-D3> but thread local isnt magic either
[11:25:30] <Diablo-D3> THAT has overhead depending on how erlang implements it
[11:26:03] <Diablo-D3> er how rust implements it
[11:26:16] <Diablo-D3> (sorry, Ive been hanging out in #erlang a lot lately ;)
[11:26:19] <steven_is_false> strcat: There doesn't seem to be a linker=foo option. Am I just missing something or is that not possible?
[11:26:22] <strcat> afaik the overhead of thread-local with gcc and C++11 is an array lookup
[11:26:29] <strcat> steven_is_false: not sure.
[11:26:31] <strcat> steven_is_false: clang has one
[11:26:40] <Diablo-D3> strcat: its more complex than that
[11:26:51] <strcat> steven_is_false: linker plugin or something
[11:26:57] <Diablo-D3> I really wish it would have been implemented as a stack depth lookup
[11:27:05] <Diablo-D3> but C stacks are pretty shitty
[11:27:29] <Diablo-D3> (ie, you know its always x bytes from the start of the thread's stack)
[11:28:07] *** Joins: sk (sk@61A494B3.BA40E8A.AAC02D62.IP)
[11:28:08] <Diablo-D3> strcat: btw, whats an exchange alloc?
[11:28:16] <Diablo-D3> I think I know what it is, but Im not quite sure
[11:28:19] <strcat> Diablo-D3: an unmanaged ~
[11:28:22] <strcat> it wraps malloc/free
[11:28:24] *** Quits: drrb (drrb@moz-1D881E2B.lnse1.ken.bigpond.net.au) (Quit: drrb)
[11:28:24] <Diablo-D3> ahh.
[11:28:29] <Diablo-D3> strcat: thats REALLY hard to work with
[11:28:33] <strcat> and adds a useless atomic counter for debugging leaks and a useless 4 word header
[11:28:39] <Diablo-D3> yeah see
[11:28:41] <Diablo-D3> you're doing it wrong
[11:28:43] <Diablo-D3> what you REALLY want
[11:28:53] <Diablo-D3> and this is the way I think I was going to go with my malloc
[11:29:00] <Diablo-D3> (Ive quit working on it for awhile)
[11:29:15] <strcat> we can just rm the counter in optimized builds
[11:29:28] <Diablo-D3> is to have EVERY thread has its own malloc
[11:29:33] <strcat> the header isn't actually used, but it has to be there because there's code that checks it to distinguish managed ~ from unmanaged ~
[11:29:35] <Diablo-D3> and pages are always returned to that thread's pool
[11:29:50] <Diablo-D3> and each page header knows which pool its from
[11:29:52] <strcat> Diablo-D3: that's what tcmalloc does
[11:29:55] <Diablo-D3> strcat: yes
[11:29:59] <strcat> each thread always has a pool to itself
[11:30:10] <Diablo-D3> its also what jemalloc does
[11:30:34] <strcat> tcmalloc uses a gc to migrate memory between caches and return RES to the OS with MADV_DONTNEED
[11:30:35] <Diablo-D3> Im actually not even sure if Im going to put pool ownership in the page header
[11:30:48] <Diablo-D3> strcat: yeah, Im already suing MADV_DONTNEED in mine
[11:30:59] <Diablo-D3> basically Im trying to beat jemalloc and tcmalloc in performance
[11:31:02] <Diablo-D3> its very difficult
[11:31:10] <strcat> glibc's allocator is still stupid and uses sbrk + actually returns vm to the os
[11:31:26] <strcat> but hey, what can you expect from glibc
[11:31:29] <Diablo-D3> glibc's malloc is aiming for a different metric
[11:31:30] <Diablo-D3> thats why
[11:31:33] <strcat> it does a dozen syscalls every time you start a binary
[11:31:35] <strcat> ;p
[11:31:46] <Diablo-D3> strcat: but basically, Im trying to do NUMA-safe memory 
[11:31:50] <Diablo-D3> and its difficult as hell
[11:31:52] *** Joins: victorporof_ (victorporo@moz-23D6B301.info.uaic.ro)
[11:32:12] <Diablo-D3> so far I have multiple pools for different bucket sizes
[11:32:31] <Diablo-D3> and each size allocates from the next bigger pool that has an availible page
[11:32:36] *** Quits: victorporof (victorporo@moz-23D6B301.info.uaic.ro) (Ping timeout)
[11:32:40] <Diablo-D3> and then each thread gets a tree of those
[11:33:08] <Diablo-D3> and then each thread gets a really fucked up bst tree of sorts that just points to which sub-pool owns that page currently
[11:33:37] <Diablo-D3> (and by fucked up, I mean its more of a really strange associated array than anything)
[11:33:46] <Diablo-D3> Im trying to get cache locality to win here
[11:34:16] <Diablo-D3> so I can descend the page->pool tree as fast as possible then do the page header lookup on the pool
[11:34:34] <Diablo-D3> the only problem I havent solved is looking up pages that arent from that thread's pool
[11:35:16] <Diablo-D3> (page headers arent part of the page, so it increases cache locality for the app itself)
[11:36:13] <Diablo-D3> strcat: Im considering actually using atomics to descend the lookup tree
[11:36:25] <Diablo-D3> but I dont really want that
[11:36:41] <Diablo-D3> because then I can just use a single lookup tree that points to any subpool no matter which thread its from
[11:37:24] <Diablo-D3> and then when a foreign page is freed, its sent to an incoming queue for that subpool
[11:37:44] <Diablo-D3> so when that subpool runs gc, it reads the foreign pages into its own freed list and the does gc
[11:37:59] <Diablo-D3> (which then frees pages back up to the subpool above it, or if it is the top pool for that mmap, frees the mmap)
[11:40:36] *** Joins: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP)
[11:42:08] *** Joins: sk_ (sk@61A494B3.BA40E8A.AAC02D62.IP)
[11:42:08] <Diablo-D3> strcat: I should be able to beat jemalloc and tcmalloc
[11:42:30] <strcat> Diablo-D3: so why does glibc still use sbrk? ;p
[11:42:40] <Diablo-D3> because of embedded system
[11:42:45] <Diablo-D3> they dont want ANY memory overhead at all
[11:42:49] <Diablo-D3> which, honestly, is stupid
[11:42:50] *** Quits: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net) (Quit: eholk)
[11:43:18] *** Joins: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP)
[11:43:20] <strcat> sqlite finally has memory mapped i/o support ;p
[11:43:32] <strcat> instant 30% speedup for a random project I had around using it
[11:43:32] <Diablo-D3> yeah, thats awesome
[11:43:39] <Diablo-D3> almost makes me just want to use sqlite for everything
[11:43:45] <Diablo-D3> EVERYTHING
[11:43:53] <Diablo-D3> every single in-app storage
[11:43:58] <strcat> well I kind of like the simplicity of leveldb for most things
[11:44:11] <Diablo-D3> what license is leveldb under?
[11:44:14] <steven_is_false> strcat: ld really on has -O1, and O0?
[11:44:23] <strcat> Diablo-D3: bsd license
[11:44:24] *** Joins: jviereck (Adium@moz-4D99BD11.zuehlke.com)
[11:44:26] <Diablo-D3> hrm
[11:44:33] <strcat> steven_is_false: it only has -O0 and non-zero
[11:44:36] <Diablo-D3> strcat: sometimes I want sql-style queries though
[11:44:42] <steven_is_false> strcat: okay
[11:44:46] <strcat> Diablo-D3: well, leveldb is lower-level
[11:45:04] <Diablo-D3> yes, its a kv store
[11:45:07] *** Quits: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP) (Ping timeout)
[11:45:07] <strcat> sometimes an ordered key-value db of byte strings with custom comparators, atomics and COW snapshots is easier than dealing with sql
[11:45:11] <Diablo-D3> its a replacement for bdb more than anything
[11:45:22] * Diablo-D3 hates bdb so much
[11:45:23] <strcat> Diablo-D3: yeah and it's really fast.
[11:45:26] <Diablo-D3> throw 8gb of data in it, and it shits itself
[11:45:34] <strcat> sqlite4 is going to use the same data structure as leveldb (log-structured merge tree)
[11:45:35] <Diablo-D3> throw 8gb of data into leveldb, it shrugs and keeps going
[11:45:46] <Diablo-D3> strcat: huh, thats interesting
[11:46:15] <steven_is_false> Hmm, is --relax another one of those dangerous ld optimizations, or is it just inconvenient for debugging?
[11:46:17] <Diablo-D3> strcat: though you know whats sorta depressing?
[11:46:22] <strcat> steven_is_false: dangerous, I think
[11:46:26] <strcat> steven_is_false: I don't know if it does anything on x86
[11:46:30] <strcat> Diablo-D3: what?
[11:46:30] <Diablo-D3> everytime I think of something I'd like to use sqlite for
[11:46:30] *** Joins: seth (seth@5AAE35B2.5EFFC0B8.24454B25.IP)
[11:46:36] <Diablo-D3> pg ends up being a better fit
[11:46:48] <Diablo-D3> and now that pg has pg-xc :3
[11:47:07] <strcat> well sqlite and leveldb are both meant for a single process
[11:47:10] <steven_is_false> strcat: I guess I should ask somewhere else probable.
[11:47:23] <strcat> sqlite actually scales pretty well with threads using WAL now
[11:48:15] <Diablo-D3> strcat: its meant for a single process in the sense that you'd use async communications talking to a single process to do shit
[11:48:16] *** Quits: seth (seth@5AAE35B2.5EFFC0B8.24454B25.IP) (Ping timeout)
[11:48:28] <Diablo-D3> but Ive sorta converted to erlang now =/
[11:48:33] <strcat> steven_is_false: yeah it doesn't seem like relax does anything on x86
[11:48:41] <Diablo-D3> and they have mnesia for kv store stuff now
[11:49:20] <steven_is_false> strcat: You mean AMD-64. x86-64 never caught on I thought?
[11:49:22] *** Joins: MaikKlein (maik@moz-4A7E00D6.dip0.t-ipconnect.de)
[11:49:36] <strcat> steven_is_false: x86_64 is just intel's name for amd64
[11:49:46] <strcat> ia-64 is itanium and ia-32 is x86
[11:49:57] <steven_is_false> strcat: Oh that makes sense.
[11:50:04] <strcat> itanic * ;p
[11:50:11] <steven_is_false> ;)
[11:50:46] <strcat> itanium has an insane amount of registers ;\
[11:50:53] <Diablo-D3> I know
[11:50:56] <strcat>     128 64-bit general purpose registers
[11:50:58] <Diablo-D3> I wish I could buy an itanium
[11:50:58] <strcat>     128 82-bit floating-point registers
[11:51:00] <strcat>     64 1-bit predicate registers
[11:51:06] <Diablo-D3> BOOLEAN REGISTERS
[11:51:06] <strcat> doesn't that mean you have to swap all of those on a context switch?
[11:51:07] <Diablo-D3> YAAAAY
[11:51:11] <Diablo-D3> strcat: no
[11:51:14] <Diablo-D3> no more than you do on x86
[11:51:21] <Diablo-D3> cpu internally has a shitload of shadow registers
[11:51:30] <Diablo-D3> and itanium has instructions for register window management
[11:51:30] <EXetoC> dang
[11:51:33] <strcat> you do swap all the registers on x86 though, the shadow registers it has to deal with itself
[11:51:46] <Diablo-D3> strcat: x86 uses shadow registers for a LOT of shit
[11:51:48] <steven_is_false> strcat: Doesn't PPC have a large amount of registers too?
[11:51:50] <strcat> I guess it's better to have many real ones
[11:51:53] <Diablo-D3> including not having to move shit back in
[11:51:59] <Diablo-D3> its all cache management in the end
[11:52:06] <strcat> steven_is_false: yeah I think RISC archs often have a lot
[11:52:16] <Diablo-D3> x86 processors are free to noop as many instructions as possible and abuse caching instead
[11:52:25] <Diablo-D3> RISC archs have a lot due to their nature
[11:52:28] <jensnockert> Itanium is VLIW though, so they need a massive amount of exposed registers.
[11:52:33] <Diablo-D3> jensnockert: yup
[11:52:37] <Diablo-D3> and VLIW really is the future
[11:52:52] <jensnockert> VLIW is nice for certain applications, like signal processing.
[11:52:52] <Diablo-D3> its funny, I used to hate itanium until I started doing GPU programming
[11:53:09] <Diablo-D3> and now I wish intel would produce itaniums and not x86
[11:53:21] <Diablo-D3> just kill x86 already, its useless crap
[11:53:23] <jensnockert> But tbh, AMD gained a lot of performance in GPGPU from switching away from VLIW.
[11:53:35] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[11:53:46] <Diablo-D3> jensnockert: hate to tell you, but GCN is VLIW as well
[11:54:46] <jensnockert> Diablo-D3: In what way?
[11:54:49] <Diablo-D3> what they shifted to was each pipe now has 4 4-wide SIMD ALUs + 4 single wide ALUs and lets the compiler make kernels that operate on multiple run items to properly optimize for the hardware
[11:54:57] <Diablo-D3> but that didnt get rid of the VLIW
[11:55:08] <Diablo-D3> its largely identical to VLIW5 and VLIW4 in that respect
[11:55:43] <benh> hm :(
[11:55:50] <Diablo-D3> (VLIW5 and 4 both have problems where you simply dont have enough instruction level parallelism to make use of the hardware well)
[11:56:21] <benh> I write out a bunch of code to try to write a box parameterised over an allocator, work through my stupid errors in all possible compilation phases, and then it ICEs
[11:56:34] * jensnockert hugs benh.
[11:57:07] <Diablo-D3> (with GCN, if you never exceed 1 instruction parallelism, the compiler could do 20 items in parallel per pipe to optimize)
[11:57:10] <benh> I did use that not-really-supported Trait::function::<ImplementingType, MoreTypeParams>() syntax a few time, but who knows...
[11:57:42] <Diablo-D3> jensnockert: the way the hardware works basically requires VLIW
[11:57:51] <Diablo-D3> and its synchronized batched VLIW at that
[11:58:12] <Diablo-D3> not only is your pipe running a VLIW clause, all pipes on that CU are running that clause as well
[11:58:51] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Ping timeout)
[11:59:13] <dbaupp> benh: what's the ICE error message?
[11:59:13] <Diablo-D3> (and it inserts noops to keep branch lengths the same)
[11:59:22] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Connection reset by peer)
[11:59:23] *** Joins: jensnock_ (jensnocker@moz-8BE55278.customer.t3.se)
[11:59:26] *** Joins: kyle2000 (kyle2000@D3528B97.7E2E8376.3031298E.IP)
[11:59:32] <Diablo-D3> and its also smart enough to dump the noops (or even the entire clause) if the entire CU goes one branch and not the other
[11:59:46] <benh> I'm a bit frightened by the task of a minimal test case...
[11:59:48] <benh> hang on
[11:59:55] <Diablo-D3> GCN also adds having CUs not operate on the same kernel at the same time
[12:00:03] <jensnock_> Diablo-D3: The (OpenCL) compiler does the same on x86, but it definitely isn't VLIW.
[12:00:16] <Diablo-D3> jensnock_: yes/no, its both more complex and less complex on x86
[12:00:26] <Diablo-D3> each core is treated as an asynchronous device
[12:00:44] <Diablo-D3> on a 7970 I can operate on up to 2048 items at the same time
[12:00:58] <Diablo-D3> on a cpu I can operate on n cores at the same time as if I owned n gpus that each have 1 pipe
[12:01:16] <benh> https://gist.github.com/ben0x539/5648858 the stacktrace doesn't really mean aything to me
[12:01:20] <Diablo-D3> so, 8 core cpu = 8 items on 8 "gpus".
[12:01:29] <benh> all of this code is untested and evil :(
[12:01:37] <Diablo-D3> opencl on a cpu is pretty retarded though
[12:01:45] <Diablo-D3> not until everybody starts using llvm as their cpu backend anyways
[12:01:47] <jensnock_> Not at all.
[12:02:17] <Diablo-D3> I should be able to keep up with hand coded SSE2 by writing the identical thing in opencl using opencl's vector natives.
[12:02:25] <Diablo-D3> currently: nope.
[12:02:30] <Diablo-D3> not even close
[12:02:44] <jensnock_> Yeah, but that is an unfair comparison.
[12:02:59] <Diablo-D3> not really, llvm could probably get me 90% of that if used correctly
[12:03:16] <kyle2000> Friends, I cloned the rust incoming branch many days ago and did a build and it worked superbly. But now I have pulled in so many changes! How can I clean away the old build artifacts? Like a "make distclean" in other projects. Is there an equivalent and what is it for rust?
[12:03:31] <Diablo-D3> amd likes llvm a lot, but still isnt using it for the important shit
[12:03:50] <Diablo-D3> jensnock_: but lets face it, when you own a gpu, who cares what the cpu does
[12:04:07] <Diablo-D3> for simple highly parallel problem, you cant beat a highly parallel dsp.
[12:04:08] <jensnock_> Diablo-D3: Umâ€¦ a lot of people?
[12:04:11] <dbaupp> kyle2000: "make clean"
[12:04:18] <Diablo-D3> jensnock_: not the people I code for.
[12:04:30] <benh> kyle2000: rust supports out-of-tree builds, so you can run configure from a separate build dir, and nuke that when you don't want it anymore
[12:04:31] <jensnock_> Diablo-D3: Yeah, but the CPU has significantly different performance characteristics.
[12:04:42] <dbaupp> benh: that stracktrace doesn't mean anything to me either :S
[12:05:00] <Diablo-D3> jensnock_: I mean hell, who doesnt own a radeon 5xxx or newer, an geforce 8xxx or newer, or intel whateverHD 4xxx by now
[12:05:06] <benh> or you could use git-clean to get rid of all untracked files
[12:05:09] <benh> which sounds a bit dangerous
[12:05:14] <Diablo-D3> jensnock_: for opencl code, it DOESNT have different performance characteristics
[12:05:19] *** jensnock_ is now known as jensnockert
[12:05:25] <Diablo-D3> jensnock_: if you're writing code where it DOES make a difference, you're using the wrong language.
[12:05:34] <benh> dbaupp: yeah, I think I'm somewhat outside the supported bits of the language here, I suppose I ought to wait at least until associated items have proper syntax :)
[12:05:40] <Diablo-D3> highly branching loopy cache murdering code == cpus
[12:05:47] <Diablo-D3> highly parallel simple code == opencl
[12:05:59] <Diablo-D3> dont make opencl do something its not suited for
[12:06:03] <kyle2000> thanks dbaupp and benh. i'd tried "make clean" but it left the llvm/x86_64-unknown-linux-gnu/ directory and the x86_64-unknown-linux-gnu directory around. i'll just use a diff directory now. thanks a million guys!
[12:06:22] <dbaupp> kyle2000: do you actually need to clean it? (is it causing errors?)
[12:06:30] <benh> there's also make llvm-clean or some variation of that
[12:07:55] <benh> dbaupp: i had trouble after the core/std rename and just nuked everything and then it worked :)
[12:08:15] <Diablo-D3> kyle2000: you can just nuke those dirs
[12:08:45] <kyle2000> dbaupp: i was getting a build error but i dont have a lot of time at the moment to investigate it. so i was just going to start from scratch like benh is saying he did.
[12:09:04] <kyle2000> that has usually fixed similar problems for me in the past
[12:09:16] <Diablo-D3> kyle2000: you could have git cloned your repo locally
[12:10:00] <benh> but then your remotes are messed up ;)
[12:10:33] <benh> I'm playing around with https://github.com/git/git/blob/master/contrib/workdir/git-new-workdir to have builds for different branches at the same time now...
[12:10:46] <benh> It's kinda like a locally cloned repository!
[12:11:14] <kyle2000> benh: that sounds as sweet as glucose! i can't wait!
[12:13:06] *** Joins: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP)
[12:14:10] <kyle2000> i'm still a total beginner with rust. i've only been using it for a few months here and there. but it is totally changing my life.
[12:14:16] <kyle2000> rust is touching me in ways that no other language has touched me before.
[12:14:57] <kyle2000> go didnt touch me this way. haskell didnt touch me this way. erlang didnt touch me this way. scala kinda did but its just so big and the jvm is so bloated that it touched me in the wrong ways.
[12:15:38] <kyle2000> with rust i feel like a warrior. i control my computer. it does what i want, not what it wants. i harness the power of 16 cpus to crunch numbers and process my data.
[12:15:52] <cmr> kyle2000: have you used C or fortran before? :)
[12:16:04] <steven_is_false> Okay, so I've been looking over the flags, and there are some interesting possibilities in reducing code size. In particular, there are some options dealing with exceptions, and I think some of that information can be removed, and there are some options dealing with warnings which would be useful to make sure some of the low level libraries I'm binding to aren't screwing things up.
[12:16:09] <aatch> cmr, just thinking that.
[12:16:50] <kyle2000> i used fortran 66 back in college in the 1980s. it was not pleasant. but the computers then werent pleasant either.
[12:16:57] <strcat> cmr: rust is getting to the point where you have more control than standard ISO C (it doesn't even have packed structs!) ;p
[12:17:40] <cmr> strcat: is there an unsafe subset of rust that has near-identical semantics as C?
[12:17:40] *** Quits: victorporof_ (victorporo@moz-23D6B301.info.uaic.ro) (Quit: victorporof_)
[12:17:58] <strcat> cmr: well it essentially has the same semantics as C/C++ already
[12:18:31] <strcat> and you can escape into unsafe when it would be forbidden by borrowck or move checks
[12:19:15] <cmr> I haven't actually looked at any benchmarks for some time... where do we stand compared to clang/gcc for similar code?
[12:19:20] <strcat> if you write low-level code in rust it compiles to the same code as C, we're just missing support for unsafe mutable globals, and alias analysis
[12:19:30] <strcat> cmr: we're as good as clang/gcc for code written the same way
[12:19:37] <aatch> cmr, for some things, we are slightly faster
[12:19:46] <strcat> the perf problems are mostly with the higher-level concepts
[12:20:02] <strcat> moves are not implemented very well, ~ allocations have useless headers, etc.
[12:20:17] <strcat> there aren't many things we need to do to reach the same perf as clang though
[12:20:23] <kyle2000> that's so great to hear! rust is still such a young language compared to the big boys but its already doing so well in so many ways.
[12:20:35] <cmr> kyle2000: well a lot of that is inherited from llvm
[12:20:41] <strcat> we need TBAA, we need to mark the padding on structs, we need to fix moves and get rid of those headers
[12:21:03] <strcat> although if you want to fix our horrid compile-times, that's going to be harder
[12:21:14] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[12:21:18] <kyle2000> cmr: llvm is still young though too. it's not like gcc which has been around for decades. rust and llvm are both such fine pieces of work.
[12:21:20] <strcat> rustc outputs 100-200 instructions while clang outputs 10-15 for the same code
[12:21:28] <strcat> they're mostly just piles of casts, no-ops and labels
[12:21:37] <strcat> with optimization it turns to identical code
[12:21:42] <strcat> just takes LLVM a while to process...
[12:21:50] <aatch> TBAA doesn't look too hard, from what I looked at, just fiddly
[12:22:01] <strcat> aatch: it's easy with rust's semantics, at least
[12:22:16] <strcat> once we have that, we'll beat C/C++ on a lot of microbenchmarks
[12:22:23] <strcat> that's why fortran does well
[12:22:39] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[12:23:04] <strcat> anyway you can still get to the same place in C with restrict and gcc attributes
[12:23:26] <strcat> but no one actually uses restrict ;p
[12:23:46] *** Quits: aruniiird (arun@D8D62F6.83FAFB90.73686190.IP) (Ping timeout)
[12:24:02] <strcat> aatch: https://github.com/mozilla/rust/issues/6736 this is a neat one
[12:24:19] <strcat> it's not strictly related to TBAA
[12:24:31] <strcat> it's only marked as tbaa because it provides a way to do tbaa for fields
[12:25:03] <aatch> cool
[12:25:17] * strcat wants to do the noalias &mut params first
[12:25:29] *** Joins: victorporof (victorporo@moz-23D6B301.info.uaic.ro)
[12:26:16] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[12:28:03] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[12:30:15] <MaikKlein> is it possible to iterate though a PortSet? http://static.rust-lang.org/doc/core/comm.html#struct-portset
[12:30:38] *** Joins: aruniiird (arun@D8D62F6.83FAFB90.73686190.IP)
[12:30:38] <cmr> MaikKlein: yourportset.ports.each ?
[12:30:56] <MaikKlein> ahh right I always forget that it is public :X
[12:31:07] <steven_is_false> Are --threads, and --thread-count enabled by default in the linker?
[12:31:52] *** Quits: victorporof (victorporo@moz-23D6B301.info.uaic.ro) (Quit: victorporof)
[12:32:06] *** Joins: victorporof (victorporo@moz-23D6B301.info.uaic.ro)
[12:32:17] <cmr> steven_is_false: where do you see those documented/
[12:33:49] <cmr> oh, it's part of gold, not bfd
[12:35:03] <steven_is_false> cmr: I've just been combing over the man page looking for interesting options
[12:37:08] <strcat> rusti: core::run::run_program("rustc", [~"--version"]);
[12:37:11] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/TcMF
[12:37:21] <strcat> rusti: std::run::run_program("rustc", [~"--version"]);
[12:37:21] *** Quits: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[12:37:24] -rusti- rustc 0.6 (9a40c5c 2013-05-24 13:40:51 -0700)
[12:37:24] -rusti- host: x86_64-unknown-linux-gnu
[12:37:53] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[12:39:45] <MaikKlein> everyone is talking about ADT in Rust, what is this? Do they just mean the enums in Rust?
[12:39:58] <strcat> MaikKlein: yes
[12:40:10] <strcat> rust's enums are tagged unions
[12:40:25] <indutny> hi guys
[12:40:28] <indutny> stupid question
[12:40:38] <indutny> how to copy &[T] as ~[T]
[12:40:48] <cmr> indutny: .to_owned()
[12:40:51] <indutny> ah
[12:40:52] <indutny> thanks
[12:41:17] *** Joins: judder (maradukewa@CF01B517.FDE2B133.950D3BB5.IP)
[12:41:29] <cmr> MaikKlein: http://en.wikipedia.org/wiki/Algebraic_data_type
[12:42:12] *** Joins: pyrac (pyrac@moz-D851FA22.w92-149.abo.wanadoo.fr)
[12:44:36] *** Joins: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net)
[12:45:25] <MaikKlein> I can't have enums in enums right?
[12:45:38] *** Joins: snearch (snearch@moz-9C336E70.pool.mediaways.net)
[12:45:53] <cmr> MaikKlein: what do you mean?
[12:46:33] *** Joins: a_m0d (a_m0d@moz-9F925EFA.hm.shawcable.net)
[12:46:39] *** Quits: kyle2000 (kyle2000@D3528B97.7E2E8376.3031298E.IP) (Quit: Leaving)
[12:46:50] <strcat> MaikKlein: you can have nested enums
[12:46:57] <steven_is_false> I don't understand split stacks.
[12:47:07] <steven_is_false> Suppose I have a split stack XXXXX----XXXX
[12:47:09] <MaikKlein> enum Earthling { enum Animal{Dog,Cat}}
[12:47:15] <strcat> steven_is_false: it never splits any value across them
[12:47:16] *** Joins: seth (seth@5AAE35B2.5EFFC0B8.24454B25.IP)
[12:47:27] <steven_is_false> strcat: oh.
[12:47:35] <strcat> it knows how much stack a function needs
[12:47:49] <strcat> so if there isn't enough when it wants to call the function, it makes a segment at least as long as what it needs
[12:48:18] <strcat> the allocas in a function just add up to the amount it needs
[12:48:19] <indutny> what about "by-move pattern bindings may not occur behind @ or & bindings"
[12:48:27] <steven_is_false> strcat: that answers my question.
[12:48:30] <MaikKlein> rusti enum Earthling { enum Animal{Dog,Cat}}
[12:48:49] <indutny> nvm, its just simplier to copy it
[12:48:50] <aatch> MaikKlein, you can't have that
[12:48:52] <dbaupp> indutny: use the `ref` qualifier on the bound variables
[12:49:18] *** Quits: seth (seth@5AAE35B2.5EFFC0B8.24454B25.IP) (Ping timeout)
[12:49:22] <strcat> MaikKlein: that's just not the way the syntax works
[12:49:36] <indutny> oh, thank
[12:49:39] <indutny> thanks
[12:49:46] <indutny> dbaupp: can you explain it, please?
[12:49:59] <dbaupp> indutny: ref just gives a pointer to the inside of the data structure
[12:50:22] <strcat> rusti: enum Value { Number(f64), String(~str), Array(~[Value]) }; Array(~[Number(5.5), Number(2.2), String(~"foo")])
[12:50:24] <dbaupp> e.g. match foo { A(ref a) => ... }
[12:50:28] -rusti- Array(~[Number(5.5), Number(2.2), String(~"foo")])
[12:50:33] <strcat> MaikKlein: ^
[12:50:46] <indutny> dbaupp: and what's the difference between A(&a) and A(ref a) ?
[12:50:46] <dbaupp> indutny: means that a is a pointer to the `a` field in the `foo` object
[12:51:07] <dbaupp> indutny: &a is derefencing one layer of pointers, ref a is adding one
[12:51:07] <strcat> indutny: destructuring mirrors construction and the type signatures
[12:51:17] <strcat> indutny: (a, b) extracts a and b from a tuple
[12:51:27] <strcat> &a extracts a from behind a reference
[12:51:48] <indutny> aah
[12:51:50] <indutny> its in reverse
[12:51:51] <indutny> got it
[12:51:55] <strcat> indutny: yep :)
[12:51:56] <indutny> sorry, that was really stupid
[12:52:05] <dbaupp> indutny: so the enum is A(&int), the &a binding gives a type int, and the ref a binding gives a type &&int
[12:52:21] <dbaupp> *so if
[12:52:25] <indutny> yep
[12:52:26] <indutny> got it now
[12:52:28] <indutny> thank you very much
[12:52:31] <dbaupp> cool :)
[12:54:48] <MaikKlein> do you think I should also learn haskell if I want to learn Rust? I have absolutely no experience in functional programming.
[12:55:00] <dbaupp> MaikKlein: no
[12:55:40] <dbaupp> I wouldn't learn haskell just to learn Rust (although learning Haskell is good/fun anyway)
[12:55:41] *** Joins: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com)
[12:55:53] * strcat uses tagged unions all the time in C++
[12:55:54] <dbaupp> Rust can be your gateway drug into fp ;)
[12:56:16] <strcat> boost::variant when I'm lazy or manually rolled ones when perf matters more
[12:56:54] <strcat> no pattern matching though :(, just visiting based on the types
[12:56:56] <MaikKlein> okay then I continue with reading examples in Rust
[12:57:06] *** Quits: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net) (Quit: eholk)
[12:57:20] *** Joins: FunkyDrummer (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[12:58:25] *** Joins: FrozenCow (FrozenCow@moz-9DF5D010.dynamic.upc.nl)
[12:58:57] <MaikKlein> btw what OOP concepts are there in Rust?
[12:59:06] <cmr> MaikKlein: http://lwn.net/Articles/548560/
[12:59:12] <strcat> depends what you mean by OOP
[12:59:34] <indutny> traits are super
[12:59:38] <indutny> ;)
[12:59:44] *** Quits: victorporof (victorporo@moz-23D6B301.info.uaic.ro) (Quit: victorporof)
[12:59:46] <indutny> you can do almost everything with them
[12:59:51] <indutny> oh, btw
[12:59:54] <strcat> traits are usually used as type classes with static dispatch but... you can use them as trait objects, which are dynamic dispatch - similar-ish to what you'd do with a base class
[13:00:09] <indutny> I wonder why compiler doesn't handle this wel
[13:00:13] <indutny> map.insert(key, map.get(key))
[13:00:17] <strcat> there's trait inheritance but no inheritance for values
[13:00:25] <strcat> indutny: borrowck doesn't handle temp values yet
[13:00:35] <indutny> any plans for it?
[13:00:38] <strcat> indutny: yes
[13:00:41] <indutny> ok, good :)
[13:00:44] <strcat> indutny: for now, need a 'let' binding for the return value
[13:01:05] <strcat> although that specific case won't work because get returns a reference
[13:01:11] <strcat> but assuming you copy from it
[13:01:15] <strcat> it will work with a let binding
[13:01:42] <cmr> parm.rs:1:1: 1:36 error: expected item after attributes
[13:01:43] <cmr> parm.rs:1 /// Parameterized string evaluation
[13:01:45] <cmr>            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[13:01:50] <cmr> That... what?
[13:02:06] <dbaupp> cmr: the '///'
[13:02:15] <cmr> dbaupp: isn't /// a doc comment?
[13:02:24] <dbaupp> it's a doc string without something to attach to
[13:02:26] <cmr> oh it expands to a #[doc=" ... "]
[13:02:49] *** Joins: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP)
[13:02:49] *** Quits: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP) (Z:lined (Open Proxy found on your host. Please visit www.blitzed.org/proxy?ip=115.68.131.49 for more information.))
[13:02:57] <dbaupp> if you want internal module documentation, //! .., or /*! .. */
[13:03:03] <dbaupp> (yes)
[13:03:29] *** Joins: anshin (nbs@441B8B9E.2055B963.D2A6B5.IP)
[13:03:37] <dbaupp> that will attach to the containing item, rather than the next item
[13:04:33] *** Joins: cowboyd (cowboyd@moz-DD0FF83.lightspeed.austtx.sbcglobal.net)
[13:05:11] <cmr> dbaupp: thanks
[13:06:19] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[13:07:48] <MaikKlein> what does the compiler mean with "inner value"? https://gist.github.com/MaikKlein/5648988
[13:08:05] <strcat> MaikKlein: your type is an infinite sie
[13:08:08] <strcat> size*
[13:08:19] <strcat> Option<T> is at least as big as T
[13:08:22] <dbaupp> MaikKlein: the Expressions in the options are the inner values
[13:08:52] <strcat> MaikKlein: you can use Option<~Expression>
[13:09:13] <strcat> it's the place where ~ is actually needed semantically
[13:09:15] <pascal> MaikKlein: see: http://static.rust-lang.org/doc/tutorial.html#boxes
[13:09:47] <strcat> rusti: sys::size_of::<(int, int, int, int)>()
[13:09:53] -rusti- 32
[13:09:55] <strcat> rusti: sys::size_of::<~(int, int, int, int)>()
[13:09:56] -rusti- 8
[13:10:15] <cmr> rusti: sys::size_of::<@(int, int, int, int)>()
[13:10:17] -rusti- 8
[13:10:31] <MaikKlein> ahh
[13:11:43] *** Joins: catpig (catpig@moz-D3725275.dip0.t-ipconnect.de)
[13:12:54] <cmr> rusti: 0x81 as char
[13:12:55] -rusti- '\x81'
[13:13:20] <LimeBurst> rusti: sys::size_of::<@(int, int, int) >()
[13:13:24] -rusti- 8
[13:13:43] *** Quits: anshin (nbs@441B8B9E.2055B963.D2A6B5.IP) (Quit: leaving)
[13:13:44] *** Joins: anshin (nbs@441B8B9E.2055B963.D2A6B5.IP)
[13:14:57] <kimundi> MaikKlein: Values in rust are allways embedded directly into the type in rust. For example, the size of 'struct Foo(uint, int)' has the size of uint + the size of uint. The same is true for enums: A enum value contains a hidden tag value at it's start so that different variants can be told apart at runtime. Which means if you embedded a enum variant into itself the type would have infinite size.
[13:15:12] *** Joins: seth (seth@5AAE35B2.5EFFC0B8.24454B25.IP)
[13:16:17] <cmr> rusti: 8u7 == (8 as char)
[13:16:21] <cmr> rusti: 8u8 == (8 as char)
[13:16:24] -rusti- foo.rs:5:11: 5:12 error: expected `;` or `}` after expression but found `7`
[13:16:24] -rusti- foo.rs:5          8u7 == (8 as char)
[13:16:24] -rusti-                     ^
[13:16:24] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/MhhY
[13:16:40] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Connection reset by peer)
[13:16:44] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[13:17:06] *** Quits: cowboyd (cowboyd@moz-DD0FF83.lightspeed.austtx.sbcglobal.net) (Client exited)
[13:17:20] <kimundi> A pointer however has a fixed size, so you can use one to convert the infinite size into one layer of indirection
[13:18:23] <kimundi> rusti: 8u.to_ascii()
[13:18:27] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/QcQY
[13:18:44] <kimundi> rusti: 8u8.to_ascii()
[13:18:51] -rusti- timed out after 5 seconds
[13:18:57] <kimundi> wut?
[13:19:11] <strcat> sec
[13:19:16] <MaikKlein> okay so If I use ~ the compiler tries to figure out the size?
[13:19:19] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[13:19:31] <strcat> MaikKlein: no
[13:19:34] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[13:19:35] <cmr> MaikKlein: the size of ~Foo is always constant, since it's just a pointer
[13:19:38] <strcat> ~ is indirection behind a heap allocation
[13:19:42] <kimundi> MaikKlein: If you use a ~ the type has no longer infinite size
[13:20:05] <strcat> if you make a 32-byte type and then add a field containing itself, it's infinite size
[13:20:10] <strcat> can't have that ofc
[13:21:22] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[13:22:15] <kimundi> MaikKlein, this is the problem: 'struct Foo {tag: uint, foo: Foo}', In memony: uint uint uint uint uint uint uint ...
[13:22:59] *** Quits: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP) (Ping timeout)
[13:23:07] *** Quits: a_m0d (a_m0d@moz-9F925EFA.hm.shawcable.net) (Ping timeout)
[13:23:41] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[13:23:47] <steven_is_false> Hey does any one know of resources the output from the intel_gpu_top program? Also, does anyone know of some better chat channels for discussing this kind of GPU stuff?
[13:23:55] <MaikKlein> ah okay so you solve that my making a pointer to the same type, then the compiler counts how many times it points to itself and then it knows the size for example 32byte points to another 32byte and this 32byte points to null so the size would be 64byte  
[13:24:10] <kimundi> No
[13:24:23] <kimundi> Or wait let me read that again
[13:24:23] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[13:24:35] <cmr> struct Foo {tag: uint, foo: ~Foo}, in memory: uint, pointer
[13:24:38] <strcat> MaikKlein: a pointer is always a constant size
[13:24:41] <strcat> doesn't matter what it points at
[13:24:59] * dbaupp thinks diagrams would help
[13:25:10] <dbaupp> (diagrams always help :) )
[13:25:27] <MaikKlein> ah wait
[13:25:46] <strcat> Foo(uint, ~Foo)
[13:25:48] <strcat> is
[13:25:48] <steven_is_false> strcat: What about function pointers?
[13:25:50] <strcat> [uint|ptr]
[13:25:50] <MaikKlein> ahh okay 
[13:26:03] <MaikKlein> Foo(uint, ~Foo) would then be size of 8 or sth
[13:26:04] <strcat> [uint|ptr] -> [uint|ptr] .... forever
[13:26:09] <strcat> which you can't construct
[13:26:12] <strcat> MaikKlein: well it's 2 words
[13:26:13] <cmr> 16, on 64bit
[13:26:16] <MaikKlein> uint + pointer size
[13:26:19] <strcat> yes
[13:26:22] <steven_is_false> strcat: also, pointers to arrays carry their size with them.
[13:26:27] <kimundi> steven_is_false: A function pointer also has fixed size
[13:26:42] <strcat> steven_is_false: they're not a pointer then ;p
[13:27:21] <steven_is_false> kimundi: Sorry, tired so I got a bit confused
[13:27:37] <steven_is_false> I'm actually going to take a break.
[13:27:38] <MaikKlein> thanks for explaining 
[13:28:02] <kimundi> You're welcome :)
[13:28:04] <steven_is_false> Bye
[13:28:06] *** Parts: steven_is_false (user@moz-144077DE.bchsia.telus.net) (ERC Version 5.3 (IRC client for Emacs))
[13:28:10] <strcat> ugh our codegen is so bad
[13:28:13] <strcat> ;p
[13:33:56] <MaikKlein> https://gist.github.com/MaikKlein/5649047 is to possible to write someting like let result = Add(Number(5),Number(10))
[13:34:19] <cmr> MaikKlein: No, it needs to be Some(Number(5))
[13:34:30] <cmr> And, I think actually, Some(~Number(5))
[13:34:39] <strcat> MaikKlein: you don't need Option
[13:34:46] <strcat> well, you definitely don't want Option
[13:34:57] <MaikKlein> okay lets delete the option then
[13:35:04] <MaikKlein> but would it then be possible?
[13:35:08] <cmr> yes
[13:35:11] <MaikKlein> because Add is a struct and not a function
[13:35:16] <MaikKlein> afaik
[13:35:21] <cmr> Add isn't a struct, it's an enum variant.
[13:35:28] <strcat> enum variants are essentially structs
[13:35:28] <MaikKlein> oh
[13:35:30] <strcat> but...
[13:35:31] <strcat> it doesn't matter
[13:35:40] <strcat> you can have Foo(~Bar, ~Bar)
[13:35:42] <strcat> no reason you can't
[13:35:47] <strcat> Foo is 2 words in size
[13:35:54] <strcat> it's not infinitely recursive, Bar is another type
[13:36:04] <strcat> Bar could be Number(5) which terminates the recursion
[13:36:10] <strcat> Option is redundant
[13:36:26] <MaikKlein> yes I know I would porbably have to to a pattern matching
[13:36:35] <MaikKlein> but I have No idea how I would start
[13:36:52] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[13:36:53] <MaikKlein> impl Add{...} ?
[13:36:57] <strcat> dunno what you mean
[13:37:01] <strcat> what do you want to do?
[13:37:21] <MaikKlein> that I can write this Add(Number(5),Number(10))
[13:37:29] <MaikKlein> ahh wait
[13:37:42] <strcat> rusti: enum Expr { Int(int), Add(Expr, Expr) }; let x = Add(Add(2, 5), 5); x
[13:37:50] -rusti- timed out after 5 seconds
[13:37:56] <strcat> rusti: enum Expr { Int(int), Add(Expr, Expr) }; let x = Add(Add(2, 5), 5); x
[13:38:06] -rusti- timed out after 5 seconds
[13:38:16] <strcat> rustc now consumes too much memory for rusti to work anymore
[13:38:18] <strcat> yay?
[13:38:21] <MaikKlein> infiite recurstion
[13:38:22] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[13:38:33] <aatch> strcat, actually, that probably hits a rustc bug
[13:38:36] <strcat> MaikKlein: yes needs ~
[13:38:52] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[13:39:08] <MaikKlein> rusti: enum Expr { Int(int), Add(~Expr, ~Expr) }; let x = Add(Add(2, 5), 5); x
[13:39:14] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/SiGS
[13:39:16] <strcat> rusti: enum Expr { Int(int), Add(~Expr, ~Expr) }; let x = Add(~Add(2, 5), ~Int(5)); x
[13:39:17] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/QYEj
[13:39:32] <strcat> rusti: enum Expr { Int(int), Add(~Expr, ~Expr) }; let x = Add(~Add(Int(2), Int(5)), ~Int(5)); x
[13:39:33] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/TYbZ
[13:39:42] <strcat> rusti: enum Expr { Int(int), Add(~Expr, ~Expr) }; let x = Add(~Add(~Int(2), ~Int(5)), ~Int(5)); x
[13:39:44] * strcat sighs
[13:39:45] -rusti- Add(~Add(~Int(2), ~Int(5)), ~Int(5))
[13:39:54] <strcat> aatch: I mean in general like
[13:39:56] <strcat> rusti: 5 + 5
[13:39:57] -rusti- 10
[13:40:00] <strcat> almost went oom
[13:40:09] <cmr> where's it all going!?
[13:40:10] <aatch> Oh wow
[13:40:16] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[13:40:28] <strcat> keeping in mind that the bot is limited to 128 megs of memory...
[13:40:31] <strcat> but still
[13:40:33] <strcat> ;p
[13:40:38] <strcat> rusti: 5
[13:40:40] -rusti- 5
[13:40:56] *** Joins: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP)
[13:41:19] <MaikKlein> ah okay I think I get it 
[13:41:24] <cmr> rusti: Either<int, uint>
[13:41:25] -rusti- foo.rs:5:19: 5:20 error: expected `;` or `}` after expression but found `,`
[13:41:25] -rusti- foo.rs:5          Either<int, uint>
[13:41:25] -rusti-                             ^
[13:41:39] <MaikKlein> with let x = Add(Add(2, 5), 5);  then I can go pattern matching on x
[13:42:02] <MaikKlein> ok thanks I know now how to start
[13:42:08] <strcat> let x = Add(Add(~Int(2), ~Int(5)), ~Int(5))
[13:42:10] <kimundi> MaikKlein: Do you actually want to add the values (evaluate the expression), or just construct an expression?
[13:42:23] <MaikKlein> to add 
[13:42:31] <strcat> I imagine he wants to parse something into a tree of exprs and then evaluate it?
[13:42:37] <strcat> so this is the right way
[13:43:18] <kimundi> strcat: Wouldn't Add(Add(~Int(2), ~Int(5)), ~Int(5)) be infinite size again?
[13:43:25] <strcat> kimundi: no
[13:43:29] <strcat> why would it?
[13:43:42] <kimundi> IF Add in an enum variant?
[13:43:51] <strcat> Int is an enum variant too
[13:43:55] <strcat> it terminates the recursion
[13:44:07] <strcat> no different than Some and None except in this case None has a value
[13:44:11] <kimundi> But the second Add has no ~ in front?
[13:44:14] <dbaupp> kimundi: it's a typo, there should be an ~ in front of the inner Add
[13:44:18] <strcat> kimundi: typo
[13:44:23] <kimundi> Okay
[13:44:28] *** Quits: FunkyDrummer (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Connection reset by peer)
[13:44:31] <kimundi> Then it's all fine :P
[13:47:21] <cmr> MaikKlein: Do you see how to implement it now?
[13:48:33] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: brb)
[13:48:35] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[13:51:27] <cmr> MaikKlein: Also, if you haven't yet, consider reading SICP. It's really great.
[13:51:28] <MaikKlein> I don't know I am experimenting if I run into some issue I ask again :)
[13:51:35] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[13:51:55] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[13:51:59] <cmr> it's available for free online at http://mitpress.mit.edu/sicp/full-text/book/book.html
[13:53:14] <MaikKlein> thanks this is interesting
[13:54:57] *** Quits: dbaupp (Thunderbir@moz-47674341.lns20.syd6.internode.on.net) (Ping timeout)
[13:58:14] <strcat> awesome it can pass alignment for regular calls now too :)
[13:58:59] *** Quits: seth (seth@5AAE35B2.5EFFC0B8.24454B25.IP) (Input/output error)
[13:59:17] <anshin> it's available in pdf and mobi too https://github.com/sarabander/sicp-pdf https://github.com/twcamper/sicp-kindle
[13:59:28] <benh> (strcat: Did I get this right? extra::rc needs to switch to ~ because hiding @-pointers in opaque malloc-allocated storage breaks the tracing GC?)
[13:59:30] *** Joins: seth (seth@5AAE35B2.5EFFC0B8.24454B25.IP)
[13:59:36] <strcat> benh: yes
[13:59:57] <strcat> anyway I need to rewrite rusti
[14:00:02] <benh> which one?
[14:00:02] <strcat> lxc is broken and eats all my page cache ;\
[14:00:06] <strcat> benh: the bot
[14:00:07] <benh> ah :)
[14:00:15] <strcat> at least I think it's lxc
[14:00:27] <strcat> if I don't run into that problem with rusti off, it's rusti's fault and he's being killed and reanimated
[14:00:49] <strcat> I don't like lxc anyway, it leaves cgroups around ;\
[14:00:56] <strcat> how hard is rmdir! ;p
[14:01:11] <benh> strcat: Do you think it's reasonable that smart wrappers like rc would parameterize over where they get their storage?
[14:01:17] *** Quits: seth (seth@5AAE35B2.5EFFC0B8.24454B25.IP) (Ping timeout)
[14:01:31] <strcat> benh: I don't know
[14:01:33] <benh> or would that break because of things like hiding @ pointers that can't be expressed that generally?
[14:01:49] <strcat> benh: only rc_from_const can embed @
[14:01:56] <strcat> so you could have the allocators on an rc_from_owned_with_allocator
[14:02:21] <strcat> ~ should just be naked calls to malloc though.
[14:02:32] <strcat> the headers are a bug, the counter in non-debug builds is a bug
[14:02:49] <strcat> not a design choice, just a crappy implementation ;p
[14:02:58] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Client exited)
[14:03:20] <benh> I think it'd be neat to be able to "adopt" random pointers from C code and tie the required cleanup function into the type somehow, even if that's not the same malloc that ~ uses
[14:03:25] <benh> or free, rather
[14:03:37] <strcat> but first things first, I want rust to not have such incredibly slow moves/swaps ;p
[14:03:42] <strcat> benh: yeah that's how unique_ptr works in C++
[14:03:45] <benh> yeah
[14:04:08] <strcat> benh: look at the ffi tutorial, I added a sample reimplementation of a unique ptr there
[14:04:13] <strcat> and it uses T: Owned since it uses malloc
[14:04:24] <strcat> so you could just add a param for the allocator + destructor
[14:04:29] <strcat> or just have them pass in a ptr
[14:04:59] <benh> I tried at https://gist.github.com/ben0x539/5648858 and it explodes in my face
[14:05:19] <benh> ;)
[14:06:03] <benh> Anyway, it has time, I just hope we'll be able to ship something that makes custom types work as well as ~/@/~[]/~str etc :)
[14:06:09] <strcat> I think this latest tweak works...
[14:06:17] <strcat> lets see if it puts the proper align
[14:06:35] *** Quits: MaikKlein (maik@moz-4A7E00D6.dip0.t-ipconnect.de) (Ping timeout)
[14:09:48] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[14:09:56] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[14:14:09] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[14:29:03] *** Joins: sankha93 (Instantbir@14CE0F58.9A5EC03F.8B6C1D65.IP)
[14:36:26] *** Joins: martndemus (martndemus@moz-FAE8D24A.sshunet.nl)
[14:40:29] *** Quits: snearch (snearch@moz-9C336E70.pool.mediaways.net) (Quit: Verlassend)
[14:42:30] *** Joins: libbkmz (Mibbit@936665CB.C1485E52.EBE09E3C.IP)
[14:42:40] <libbkmz> Hi
[14:42:48] <strcat> \o
[14:42:49] <libbkmz> i can't build Rust on my PC
[14:42:56] <libbkmz> http://pastebin.com/eXBuvcZP
[14:43:11] <libbkmz> Precompiled binaries also not worked
[14:43:11] <libbkmz> https://bbs.archlinux.org/viewtopic.php?id=163874
[14:43:56] <cmr> libbkmz: how much memory do you have?
[14:44:03] <libbkmz> 2Gb
[14:44:08] <cmr> do you have swap?
[14:44:11] <libbkmz> +
[14:44:22] <libbkmz> 2g ram + 4gb swap
[14:44:34] <cmr> hm
[14:44:39] <libbkmz> i'm getting the same error on precompiled binaries
[14:45:01] <libbkmz> $: rust Segmentation fault (core dumped)
[14:45:23] <libbkmz> on bbs.archlinux i posted backtrace from gdb
[14:45:29] <libbkmz> and another logs
[14:45:50] <strcat> libbkmz: what if you build incoming instead
[14:45:58] <libbkmz> build what?
[14:46:03] <strcat> the incoming branch
[14:46:09] <strcat> clone the repo and checkout incoming
[14:46:17] <strcat> libbkmz: or here, I have a repo for arch linux
[14:46:33] <strcat> http://pkgbuild.com/~thestinger/repo/
[14:46:39] <strcat> [thestinger]
[14:46:41] <strcat> SigLevel = Optional
[14:46:43] <strcat> Server = http://pkgbuild.com/~thestinger/repo/$arch
[14:46:48] <strcat> might just be something broken in 0.6
[14:46:52] <strcat> unlikely but... possible
[14:46:57] <libbkmz> thanks
[14:47:00] <libbkmz> i'll try now
[14:47:22] <cmr> Weird that's it's dying when the linker runs :\
[14:50:08] <libbkmz> the same
[14:50:14] <libbkmz> fish: Job 1, 'rust' terminated by signal SIGSEGV (Address boundary error)
[14:50:25] <cmr> libbkmz: you installed rust-incoming-git right?
[14:50:27] <libbkmz> Program received signal SIGSEGV, Segmentation fault. 0xb7fe37f8 in open_verify () from /lib/ld-linux.so.2
[14:50:30] <libbkmz> Yeap
[14:50:38] *** Joins: tcsc (tcsc@moz-A838B260.dhcp.nwtn.ct.charter.com)
[14:50:44] <libbkmz> I have 32bit Archlinux
[14:50:53] <libbkmz> CPU only 32bit
[14:51:06] <libbkmz> maybe, it's not support lm
[14:51:30] <libbkmz> but, i think it's not a problem =\
[14:51:41] <libbkmz> lahf_lm
[14:51:44] <libbkmz> only
[14:52:35] <libbkmz> any ideas?
[14:55:55] <cmr> libbkmz: are you using glibc?
[14:56:11] <libbkmz> hmmm. =) Yes
[14:56:16] <libbkmz> how to check it?
[14:56:41] <cmr> well if you haven't gone out of your way to not use it, you're using it :)
[14:57:13] <cmr> I think it's a bug in glibc. open_verify checks that a file is valid ELF, it shouldn't ever segfault.
[14:57:20] <libbkmz> what ways i can gone of using it? any why?
[14:57:33] <libbkmz> hm...
[14:57:39] <cmr> but I don't know what the cause of it is, you'd have to build a debug copy of glibc and step through it.
[14:57:49] <libbkmz> on another machines with upstrem archlunux 32bit all working fine...
[14:58:17] <libbkmz> does archlinux have libc-dbg or anything same?
[14:58:26] <cmr> no
[14:58:35] *** Joins: mflamer (Mibbit@moz-C6ED16AA.hsd1.ca.comcast.net)
[14:58:40] <strcat> not yet because we haven't decided where to put debug packages
[14:58:44] <strcat> ;p
[14:58:46] *** Quits: jviereck (Adium@moz-4D99BD11.zuehlke.com) (Quit: Leaving.)
[14:59:20] <libbkmz> ok, i'm going to find my ac adapter, and will build glibc with some debug information
[14:59:26] <libbkmz> Any siggestions?
[14:59:26] *** Joins: Yurume_ (yurume@AC58A8CE.8A059B47.E313B915.IP)
[15:00:07] *** Quits: catpig (catpig@moz-D3725275.dip0.t-ipconnect.de) (Quit: Verlassend)
[15:00:17] <strcat> libbkmz: anything weird in pacman -Qm?
[15:00:19] <strcat> dunno
[15:01:31] <libbkmz> strcat: are u using KDE?
[15:01:36] <strcat> no
[15:01:52] *** Joins: MaikKlein (maik@moz-4A7E00D6.dip0.t-ipconnect.de)
[15:02:04] <libbkmz> what irq messanger u may recommend?
[15:02:10] <cmr> libbkmz: makepkg supports separate debug packages, I would use that.
[15:03:15] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[15:04:01] *** Quits: mflamer (Mibbit@moz-C6ED16AA.hsd1.ca.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[15:05:05] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[15:05:29] *** Quits: pyrac (pyrac@moz-D851FA22.w92-149.abo.wanadoo.fr) (Quit: pyrac)
[15:05:58] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Ping timeout)
[15:07:26] <MaikKlein> I am still struggling to get my recursive pattern matching right :x https://gist.github.com/MaikKlein/5649389 
[15:07:27] <MaikKlein> error: cannot move out of dereference of ~ pointer
[15:07:46] <MaikKlein> do I maybe have  to explicitly copy the expressions?
[15:08:28] <doener> try Add(ref x, ref y) => { eval(*(*x)) + eval(*(*y) }
[15:08:32] <kimundi> where does the error happen?
[15:09:28] <indutny> a question
[15:09:38] <indutny> why doesn't rust for loops contain `continue` syntax sugar?
[15:09:39] <libbkmz> strcat: i'm started compiling glibc with debug info
[15:09:49] <strcat> indutny: it does, 'loop'
[15:09:50] <MaikKlein> @kimundi it happens here for example Add(x,y) => {eval(*x) + eval(*y)}
[15:09:55] <indutny> aaaah
[15:09:55] <indutny> gosh
[15:09:59] <kimundi> indutny, they do, it's just called 'loop;'
[15:10:01] <strcat> indutny: :)
[15:10:04] <indutny> why not `continue`?
[15:10:10] <indutny> or
[15:10:13] <kimundi> one keyword less...
[15:10:14] <indutny> why `break` and not `unloop`
[15:10:15] <strcat> indutny: it was continue but apparently people didn't like continue
[15:10:19] <indutny> ah
[15:10:20] <indutny> well
[15:10:21] <strcat> I wasn't around for that
[15:10:25] <indutny> ok
[15:10:31] <indutny> thanks
[15:10:35] <doener> MaikKlein: added a comment
[15:10:47] <indutny> personally, I don't like context sensitive keywords
[15:10:49] <cmr> MaikKlein: https://gist.github.com/cmr/5649080 is what I came up with
[15:10:53] <indutny> it complicates stuff
[15:11:19] <strcat> mut can be in 4 places ;p
[15:11:34] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[15:12:33] <indutny> :)
[15:12:39] *** Joins: pnathan (Adium@DB849214.31A7A48D.B1142EBE.IP)
[15:12:47] <indutny> I'm not saying its really good :)
[15:12:54] <indutny> but, at least, it does pretty much the same thing
[15:12:57] <indutny> in all those places
[15:13:03] <cmr> I thought it was loop because of the character limit on keywords
[15:13:17] *** Quits: bytbox (s@moz-96B204E2.wireless.umd.edu) (Ping timeout)
[15:13:18] <indutny> ooh
[15:13:20] <cmr> I recall reading ML thread/issue about it
[15:13:22] <indutny> that's a good reason
[15:13:40] <cmr> I don't think so :)
[15:13:59] *** Parts: libbkmz (Mibbit@936665CB.C1485E52.EBE09E3C.IP) ()
[15:14:19] <MaikKlein> okay thanks @cmr didn't know that I can typecheck ~
[15:14:26] *** Joins: libbkmz (bkmz@936665CB.C1485E52.EBE09E3C.IP)
[15:14:57] <MaikKlein> i mean match not typecheck
[15:15:17] <cmr> MaikKlein: I initially tried doing what you tried but it got ugly fast :(
[15:15:55] <kimundi> MaikKlein, In theory your versionshould work I think...
[15:16:37] *** Joins: bytbox (s@moz-96B204E2.wireless.umd.edu)
[15:16:45] <kimundi> It would consume its argument instead of just reference it, but I don't see why it should error... Anyone have an idea why it does?
[15:18:19] <indutny> can I declare structs inside functions?
[15:18:25] <kimundi> yes
[15:18:28] <indutny> and enums?
[15:18:36] <kimundi> also yes
[15:18:38] <cmr> indutny: why don't you TIAS? :)
[15:18:38] <kimundi> +- bugs
[15:18:59] <indutny> what's TIAS?
[15:19:03] <cmr> try it and see
[15:19:08] <indutny> aah
[15:19:09] <indutny> well
[15:19:24] <indutny> rusti: fn func() { struct B; }
[15:19:30] <kimundi> indutny: In fact, any rusti query on this channel that declares structs, enums, etc reies on that to work ;)
[15:19:41] <indutny> kimundi: that's what I thought
[15:22:10] *** Quits: TD-Linux (TD-Linux@E338EB99.2B4F0AE0.A0A36CCE.IP) (Ping timeout)
[15:22:44] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[15:22:45] *** Joins: TD-Linux (TD-Linux@E338EB99.2B4F0AE0.A0A36CCE.IP)
[15:24:02] <MaikKlein> if I do let i = ~10; let d = *i; it is basically a copy right?
[15:24:18] <strcat> well it copies the integer out, yes
[15:24:23] <MaikKlein> ok
[15:24:44] <cmr> rusti: let i = ~10; let d = *i; d += 3; d
[15:24:50] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/dihR
[15:24:55] <cmr> rusti: let i = ~10; let d = *i; i += 3; i
[15:24:57] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/faMA
[15:26:01] <MaikKlein> let i = ~10; let mut d = *i; d += 3; d
[15:26:10] <martndemus> Short q: Does anybody know how long building rust normally takes on an macbook air?
[15:26:21] <MaikKlein> rusti: let i = ~10; let mut d = *i; d += 3; d
[15:26:23] -rusti- 13
[15:26:45] <strcat> martndemus: if you have >3GiB of ram it should take 12-20 mins after LLVM is compiled
[15:26:59] <strcat> if you have <2GiB it will probably take over an hour
[15:27:05] <strcat> since it will be swapping a lot
[15:27:09] <martndemus> it has 4gb
[15:27:21] <strcat> martndemus: well however long LLVM takes and then ~12 mins I guess
[15:27:41] <strcat> maybe ~15-20 for incoming right now since there was a big memory usage regression
[15:27:44] <martndemus>  aha
[15:28:26] <MaikKlein> ok but if * copies out then I don't understand why this doesn't work https://gist.github.com/MaikKlein/5649389
[15:28:43] <strcat> MaikKlein: because ~ isn't implicitly copyable
[15:29:07] <strcat> first, choose if you want the function to consume Expression or not
[15:29:14] <strcat> you probably don't, there's not much to gain from consuming it
[15:29:19] <strcat> so you want it to take &Expression
[15:29:20] <cmr> MaikKlein: you don't need {} surrounding the expression in match
[15:29:30] <cmr> *expressions
[15:29:44] <MaikKlein> because it is a one liner ?
[15:29:48] <cmr> yes
[15:29:59] <cmr> more generally, a single expression
[15:30:16] <kimundi> strcat: I woder about that too, why does the consuming variant not work? It seems to do the same as that one liner
[15:30:37] <strcat> kimundi: *x doesn't consume ~T
[15:30:44] <kimundi> ah, okay
[15:30:47] <strcat> it won't let you move out of *x
[15:30:50] <strcat> you have to match out like
[15:30:52] <strcat> let ~x = 5;
[15:30:57] <strcat> or ~x in the pattern
[15:30:58] <MaikKlein> what does consume even mean? do you mean move?
[15:31:03] <kimundi> would the ~x pattern work or same thing?
[15:31:06] <strcat> MaikKlein: yes, move
[15:31:08] <strcat> kimundi: it works
[15:31:45] *** Quits: bytbox (s@moz-96B204E2.wireless.umd.edu) (Ping timeout)
[15:31:56] *** Joins: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP)
[15:32:36] <kimundi> MaikKlein: Added a comment there, could you try if that works?
[15:32:43] <cmr> kimundi: I used ~foo in https://gist.github.com/cmr/5649080
[15:32:53] <strcat> kimundi: unlikely that he wants to move
[15:33:01] <kimundi> strcat: Unrelated
[15:33:33] <kimundi> strcat: Explaining why it doesn't work is also important.
[15:34:50] <kimundi> cmr: Well that pulls out the ~ completely. Also possible, but not really what I meant :)
[15:35:46] <MaikKlein> so the first comment from dotdash is the way I should do it?
[15:35:58] <kimundi> MaikKlein: Generally yes
[15:37:00] *** Quits: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com) (Quit: Computer has gone to sleep.)
[15:37:11] <kimundi> MaikKlein: IF you just want to work ON a value, take it as pointer. If you take it by value it either copies or moves into the function
[15:37:50] <MaikKlein> ah okay
[15:38:21] <MaikKlein> ah it is also explained here "Patterns that bind variables default to binding to a copy of the matched value. This can be made explicit using the copy keyword, changed to bind to a borrowed pointer by using the ref keyword, or to a mutable borrowed pointer using ref mut, or the value can be moved into the new binding using move." 
[15:38:23] <MaikKlein> Ok thanks
[15:38:28] <kimundi> MaikKlein: With 'by pointer' I mean &. Everthing else would also mean moving
[15:41:10] <MaikKlein> has Rust typedefs?
[15:41:20] <MaikKlein> so I can make a ~Number to something different?
[15:41:30] <strcat> MaikKlein: 'type'
[15:41:36] <strcat> type x = y; makes an alias
[15:41:38] <benh> That sounds wrong. It should move by default for non-implicitly copyable types now?
[15:41:41] <kimundi> you can alis a type with the 'type' keyword, and you can create a newtype wrapper
[15:41:56] <strcat> benh: yes it's fixed
[15:42:08] <strcat> benh: 0.6 docs are old ;p
[15:42:17] <benh> :)
[15:42:21] <strcat> I remember r+'ing the commit that fixed it
[15:42:32] <strcat> I assume it landed...
[15:44:00] <MaikKlein> hm how would my type look like for a ~Number? I tried this type number = ~Number;
[15:44:31] <MaikKlein> but then it tells me that it can't find Number
[15:44:33] <strcat> well Number isn't really a type, maybe it doesn't work for enum variants
[15:48:00] *** Joins: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net)
[15:48:03] <MaikKlein> it definitely works for normal structs, don't you think it should also work for enum variants too?
[15:48:10] *** Joins: int3_ (int3_@moz-B7B5F043.singnet.com.sg)
[15:48:53] <kimundi> MaikKlein: Well a struct is a type, a enum variant isn't. 
[15:49:10] <kimundi> MaikKlein: 'Expression' is an enum type
[15:49:32] <strcat> meh
[15:49:35] <strcat> it wasn't rusti's fault ;\
[15:49:41] <strcat> or was it...
[15:49:43] <kimundi> But the variants are basically just different constructors for an 'Expression' value
[15:49:45] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[15:49:56] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[15:52:14] *** Quits: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net) (Quit: eholk)
[15:52:35] <strcat> rusti: unsafe { *(0 as *int) }
[15:52:38] -rusti- /usr/local/bin/rust.sh: line 21:    13 Segmentation fault      (core dumped) ./foo
[15:53:30] <strcat> rusti: unsafe { *(0 as *int) }
[15:53:31] -rusti- /usr/local/bin/rust.sh: line 21:    13 Segmentation fault      (core dumped) ./foo
[15:53:56] *** Quits: Nisstyre (wes@moz-FD86289.netflash.net) (Quit: Leaving)
[15:55:21] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.1)
[15:55:26] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[15:56:46] *** Joins: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net)
[15:57:28] *** Joins: Nisstyre (wes@moz-FD86289.netflash.net)
[15:58:15] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[15:58:54] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[16:00:20] *** Joins: halorgium (z@moz-7A333983.spork.in)
[16:00:22] *** Quits: int3_ (int3_@moz-B7B5F043.singnet.com.sg) (Connection reset by peer)
[16:00:28] *** Joins: int3_ (int3_@moz-B7B5F043.singnet.com.sg)
[16:00:35] <halorgium> morning
[16:01:27] *** Quits: MaikKlein (maik@moz-4A7E00D6.dip0.t-ipconnect.de) (Ping timeout)
[16:03:04] *** Quits: pnathan (Adium@DB849214.31A7A48D.B1142EBE.IP) (Quit: Leaving.)
[16:03:04] *** Quits: int3_ (int3_@moz-B7B5F043.singnet.com.sg) (Connection reset by peer)
[16:03:16] *** Joins: int3_ (int3_@moz-B7B5F043.singnet.com.sg)
[16:03:39] <halorgium> erickt: i'm visiting SF until 6/11, i'm interested in rust from the perspective of building an actor framework: i help maint http://celluloid.io/
[16:11:47] *** Quits: libbkmz (bkmz@936665CB.C1485E52.EBE09E3C.IP) (Ping timeout)
[16:14:11] *** Joins: libbkmz (bkmz@936665CB.C1485E52.EBE09E3C.IP)
[16:18:28] *** Joins: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com)
[16:18:59] *** Quits: libbkmz (bkmz@936665CB.C1485E52.EBE09E3C.IP) (Ping timeout)
[16:19:19] <cmr> Is anyone familiar with the resolution code? Trying to figure out https://github.com/mozilla/rust/issues/6477
[16:20:27] *** Joins: bytbox (s@moz-96B204E2.wireless.umd.edu)
[16:21:28] *** Joins: libbkmz (bkmz@936665CB.C1485E52.EBE09E3C.IP)
[16:22:32] <libbkmz> I get error on compiling glibc
[16:22:33] <libbkmz> http://paste.org.ru/?zbenmm
[16:23:20] <libbkmz> i run it for 2 times, and it repeats 
[16:25:52] <libbkmz> maybe rust segfaults are similar to this issue?
[16:26:25] <cmr> rusti: ();
[16:27:10] <cmr> libbkmz: maybe. you'd have to take it up with the glibc devs though. you're well beyond my knowledge area now :)
[16:33:16] *** Quits: libbkmz (bkmz@936665CB.C1485E52.EBE09E3C.IP) (Ping timeout)
[16:34:32] *** Joins: victorporof (victorporo@DE2B5DEF.67CDC207.79933D60.IP)
[16:36:10] *** Quits: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[16:36:49] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[16:37:09] *** Quits: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com) (Quit: Computer has gone to sleep.)
[16:38:20] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[16:39:10] *** Joins: jaen1 (jaen@moz-B9541A9D.play-internet.pl)
[16:40:12] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[16:42:56] <strcat> rusti: 1
[16:42:58] -rusti- 1
[16:44:44] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[16:44:56] *** Quits: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net) (Quit: eholk)
[16:48:00] *** Joins: lmandel (lmandel@FE1F74.86ED00A7.971E19F6.IP)
[16:48:27] *** Quits: sankha93 (Instantbir@14CE0F58.9A5EC03F.8B6C1D65.IP) (Ping timeout)
[16:49:16] *** Quits: lmandel (lmandel@FE1F74.86ED00A7.971E19F6.IP) (Quit: lmandel)
[16:53:57] <doener> cmr: the import is likely missing because of https://github.com/mozilla/rust/blob/incoming/src/librustc/middle/resolve.rs#L2486
[16:54:28] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Client exited)
[16:54:38] <doener> at least if I followed that code correctly...
[16:54:54] *** Joins: sdh_ (sdh@DDAFE7B8.CB78C1A5.CA052C06.IP)
[16:55:05] <cmr> doener: what do you mean missing? foo::Foo shouldn't be visible, it's private. the issue is to report that it is private when using glob imports, like it does for other imports.
[16:56:02] <doener> cmr: I mean it's not known at all, so the xray flag doesn't help
[16:56:15] <cmr> ah
[16:57:19] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.1)
[16:58:23] *** Quits: aruniiird (arun@D8D62F6.83FAFB90.73686190.IP) (Ping timeout)
[16:58:29] *** Quits: flowsnake (flowsnake@moz-1918C33E.aztw.cable.virginmedia.com) (Quit: ZNC - http://znc.in)
[16:59:14] <cmr> doener: do you think adding private stuff to some list would be an acceptable solution?
[16:59:42] *** Joins: flowsnake (flowsnake@moz-1918C33E.aztw.cable.virginmedia.com)
[17:01:09] *** Joins: Jesin (Jessin_@moz-A03A364F.cc.lehigh.edu)
[17:01:23] <doener> cmr: I can't think of any other solution. But my familiarity with the code is too limited to have an opinion.
[17:01:39] <cmr> who *is* familiar with the resolution code? ;p
[17:09:09] <kimundi> The resolution code isn't something you just can get familiar with. You have to be lucky to get choosen by it, and even then it will only offer you its secrets after you've been deemed worthy.
[17:10:21] *** Joins: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net)
[17:10:49] *** Quits: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[17:11:04] *** Joins: sankha93 (Instantbir@14CE0F58.9A5EC03F.8B6C1D65.IP)
[17:11:08] *** Quits: Jesin (Jessin_@moz-A03A364F.cc.lehigh.edu) (Ping timeout)
[17:11:11] *** Joins: MaikKlein (maik@moz-4A7E00D6.dip0.t-ipconnect.de)
[17:12:10] *** Joins: Jesin (Jessin_@moz-A03A364F.cc.lehigh.edu)
[17:12:56] *** Joins: SimonSapin (simon@5AAE35B2.5EFFC0B8.24454B25.IP)
[17:14:45] *** Quits: Jesin (Jessin_@moz-A03A364F.cc.lehigh.edu) (Ping timeout)
[17:15:35] <cmr> doener: nice work with #6737
[17:15:53] <doener> thanks :-)
[17:16:26] *** Quits: SimonSapin (simon@5AAE35B2.5EFFC0B8.24454B25.IP) (Quit: Leaving.)
[17:20:21] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[17:20:26] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[17:21:32] *** Joins: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com)
[17:26:20] <MaikKlein> btw is deriving generative programming?
[17:27:07] <cmr> yes, though I've never heard that buzzword before today
[17:27:08] *** Joins: pyrac (pyrac@moz-D851FA22.w92-149.abo.wanadoo.fr)
[17:29:49] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[17:30:32] *** Joins: Jesin (Jessin_@moz-83FA8843.res.lehigh.edu)
[17:30:48] *** Joins: jclements (jclements@2557E599.66715431.D25A875A.IP)
[17:32:28] *** Quits: jclements (jclements@2557E599.66715431.D25A875A.IP) (Quit: jclements)
[17:32:33] *** Joins: libbkmz (Mibbit@936665CB.C1485E52.EBE09E3C.IP)
[17:32:39] *** Joins: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP)
[17:34:14] <libbkmz> i installed glibc with debug symbols
[17:34:23] <libbkmz> and get the backtrace of rust
[17:34:26] *** Quits: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP) (Ping timeout)
[17:34:55] <cmr> libbkmz: break in open_verify and step through it to see what line it segfaults on, if the backtrace doesn't include that information
[17:35:13] <libbkmz> http://paste.org.ru/?ptnchx
[17:35:24] <libbkmz> http://sourceware.org/git/?p=glibc.git;a=blame;f=elf/dl-load.c;h=dd182c9155acdec8e0398437ebe33c7f327548be;hb=HEAD
[17:35:27] <libbkmz> 1876 line
[17:37:36] *** Joins: aruniiird (arun@D880D76D.1A3218DE.FFE8C4AF.IP)
[17:38:07] <libbkmz> so intresting...
[17:39:29] <cmr> that's weird... I don't see any pointer dereferencing that should fail at that point, that wouldn't fail earlier
[17:39:50] <nmatsakis> bjz_: that looks better, but fundamentally those transmutes are a bit unsafe. The `'self` region in your functions appears nowhere but the fn return. This means that you [] methods are promising a pointer that lives as long as the callee wants it to, which they cannot possibly fulfill. I sent you a safe index suggestion, didn't I?
[17:41:11] <cmr> libbkmz: I'd report it on the glibc mailing list / bug tracker, and attach /usr/lib/libstd-c3ca5d77d81b46c1-0.7-pre.so, as that's what it's dying on
[17:42:03] <libbkmz> i don't understand. You will send, or I should do it?
[17:42:43] <cmr> you should do it
[17:43:20] <libbkmz> ok)
[17:43:24] <libbkmz> thx
[17:44:52] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[17:45:24] *** Joins: lmandel (lmandel@FE1F74.86ED00A7.971E19F6.IP)
[17:45:51] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[17:45:51] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/VFKTgA
[17:45:51] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[17:45:52] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[17:45:52] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/cNSHUw
[17:45:52] <ghrust> 13rust/06auto 14a4b3fa8 15Niko Matsakis: Issue #3678: Remove wrappers and call foreign functions directly
[17:45:52] <ghrust> 13rust/06auto 14124f093 15bors: auto merge of #6661 : nikomatsakis/rust/issue-3678-wrappers-be-gone-2, r=brson...
[17:45:53] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[17:47:39] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[17:47:39] *** ChanServ sets mode: +o dherman
[17:47:46] <nmatsakis> Luqman: ping
[17:48:05] *** Quits: lmandel (lmandel@FE1F74.86ED00A7.971E19F6.IP) (Quit: lmandel)
[17:48:23] *** Joins: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net)
[17:49:21] *** Quits: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net) (Quit: eholk)
[17:49:32] *** Joins: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net)
[17:52:14] *** Quits: pyrac (pyrac@moz-D851FA22.w92-149.abo.wanadoo.fr) (Quit: pyrac)
[17:53:57] <libbkmz> create ticket in bugzilla
[17:54:04] <libbkmz> http://sourceware.org/bugzilla/show_bug.cgi?id=15535
[17:54:42] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[17:56:28] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[17:56:37] *** Joins: a_m0d (a_m0d@moz-9F925EFA.hm.shawcable.net)
[17:58:17] *** Quits: Jesin (Jessin_@moz-83FA8843.res.lehigh.edu) (Quit: Leaving)
[17:58:23] *** Quits: aruniiird (arun@D880D76D.1A3218DE.FFE8C4AF.IP) (Ping timeout)
[17:58:35] *** Joins: mib_3qb05l (Mibbit@moz-FDEE2005.dyn.optonline.net)
[17:58:47] <mib_3qb05l> 3> rust
[17:58:55] <mib_3qb05l> <3*
[18:00:58] *** Quits: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP) (Ping timeout)
[18:01:24] *** Quits: libbkmz (Mibbit@936665CB.C1485E52.EBE09E3C.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[18:01:27] *** Joins: seth (seth@5AAE35B2.5EFFC0B8.24454B25.IP)
[18:02:13] *** Quits: mib_3qb05l (Mibbit@moz-FDEE2005.dyn.optonline.net) (Quit: http://www.mibbit.com ajax IRC Client)
[18:03:29] *** Quits: seth (seth@5AAE35B2.5EFFC0B8.24454B25.IP) (Ping timeout)
[18:06:49] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[18:06:49] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14124f093 to 146e65a3f: 02http://git.io/N3iJvQ
[18:06:49] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[18:06:52] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[18:06:52] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/ePZuyg
[18:06:52] <ghrust> 13rust/06auto 146c62d77 15BjÃ¶rn Steinbrink: Use an enum for keywords and intern them to improve parser performance...
[18:06:52] <ghrust> 13rust/06auto 149d37d03 15bors: auto merge of #6737 : dotdash/rust/static_keywords, r=pcwalton...
[18:06:53] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[18:07:07] *** Joins: pyrac (pyrac@moz-D851FA22.w92-149.abo.wanadoo.fr)
[18:07:36] *** Quits: MaikKlein (maik@moz-4A7E00D6.dip0.t-ipconnect.de) (Ping timeout)
[18:10:57] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[18:14:46] *** Quits: jaen1 (jaen@moz-B9541A9D.play-internet.pl) (Ping timeout)
[18:16:13] *** Joins: Sodel_the_V (user@moz-853663E1.va.shawcable.net)
[18:18:04] <indutny> yikes!
[18:18:06] <indutny> its working :)
[18:18:11] <indutny> http://blog.indutny.com/f/linearscan-big.svg
[18:18:11] <indutny> hehe
[18:18:16] <indutny> you'll need to zoom out
[18:18:41] <cmr> I don't even know how to read that
[18:18:46] <indutny> haha
[18:18:56] <indutny> on the left side there's a list of instructions
[18:19:06] <indutny> they've output, inputs and temporary operands
[18:19:26] <indutny> in following form: out = instr(inp1, inp2, â€¦) | tmp: tmp1, tmp2
[18:19:29] <doener> needs an epilepsy warning
[18:19:32] <indutny> haha
[18:19:52] <indutny> each instruction is a column in a table on the right side
[18:19:57] <indutny> each operand is a row
[18:20:17] <indutny> orange bars at rows are liveness ranges of operands
[18:20:22] *** Joins: Jesin (Jessin_@moz-83FA8843.res.lehigh.edu)
[18:20:23] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[18:20:32] <indutny> small bars are uses of operands
[18:20:51] <indutny> and arrows are jumps between blocks
[18:21:13] <indutny> given this allocator I should be able to write pretty slick erlang jit vm in rust
[18:21:28] <indutny> but it there're still things to do with it
[18:21:47] <indutny> like, it doesn't know anything about double registers
[18:21:54] <indutny> which is terrible
[18:25:37] *** Quits: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net) (Quit: eholk)
[18:31:16] *** Joins: hjr3 (hradtke@moz-AE3056B9.static.stls.mo.charter.com)
[18:32:33] *** Joins: seth (seth@5AAE35B2.5EFFC0B8.24454B25.IP)
[18:33:09] *** Joins: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP)
[18:34:20] *** Joins: jviereck (Adium@moz-340574DC.dclient.hispeed.ch)
[18:34:24] *** Quits: jviereck (Adium@moz-340574DC.dclient.hispeed.ch) (Client exited)
[18:34:50] <martndemus> Is it possible to 'inherit' a struct, or is composition the only way?
[18:34:54] *** Quits: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP) (Ping timeout)
[18:35:09] *** Quits: seth (seth@5AAE35B2.5EFFC0B8.24454B25.IP) (Ping timeout)
[18:37:00] *** Joins: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net)
[18:37:16] <nmatsakis> bjz_: ping
[18:37:41] <kimundi> martndemus: Atm only composing
[18:38:14] <kimundi> martndemus: Though there was talk about allowing struct inheritance in the future
[18:38:39] <bjz_> nmatsakis: pong
[18:39:24] <nmatsakis> bjz_: so, I've been thinking about this Index trait business. I am still preparing an example of how I thought it *should* work, though I realized it is not *quite* as smooth as I had hoped.
[18:39:29] <bjz_> nmatsakis: just saw your answer
[18:39:31] <nmatsakis> bjz_: (remember how I said it'd only take 5 minutes? :)
[18:39:36] <bjz_> hehe
[18:39:40] <nmatsakis> bjz_: however, did I send you my safe version with the existing Index triat?
[18:39:41] <nmatsakis> *trait
[18:39:46] <nmatsakis> if not, let me do that.
[18:40:15] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[18:40:33] <nmatsakis> bjz_: if you didn't have the transmute, the code you had wouldn't be type-checking...
[18:40:42] <nmatsakis> bjz_: by which I mean, the lifetimes wouldn't work out
[18:40:49] <martndemus> hmm, thanks kimundi, being used to OOP is really not helping learning rust :(
[18:40:55] <bjz_> yeah, I understand now
[18:40:59] <cmr> martndemus: http://lwn.net/Articles/548560/
[18:41:23] <nmatsakis> bjz_: there is an issue open to make a lint to give a warning for code where a named lifetime apperas only in the return type of a function,
[18:41:36] <nmatsakis> bjz_: because it's almost always not what you really wanted, and the only time it ever really type checks is with transmutes in there
[18:41:36] <bjz_> nmatsakis: this one? https://gist.github.com/nikomatsakis/5644444
[18:41:53] <bjz_> nmatsakis: yeah, that would be good
[18:42:07] <nmatsakis> bjz_: yeah, the key thing is that the 'self lifetime appears in the impl type
[18:42:26] <bjz_> nmatsakis: ahhhh
[18:42:31] <bjz_> nmatsakis: gotcha
[18:43:26] <nmatsakis> bjz_: this points at a limitation of our existing system that crops up in a few places, and which I don't completely know how to solve, short of adding a kind of higher-kindedness from haskell.
[18:43:38] <nmatsakis> bjz_: but I'll spare you the type theory for the moment I think...
[18:44:03] *** Quits: anshin (nbs@441B8B9E.2055B963.D2A6B5.IP) (Quit: Lost terminal)
[18:44:16] * bjz_ doesn't mind the type theory, but still has much to learn
[18:44:38] <bjz_> how would higher-kindedness fix it?
[18:44:44] <bjz_> or help to
[18:45:02] *** Quits: pyrac (pyrac@moz-D851FA22.w92-149.abo.wanadoo.fr) (Quit: pyrac)
[18:45:28] <nmatsakis> bjz_: let me back up a sec...
[18:45:56] *** Joins: tjc (tjc@2557E599.66715431.D25A875A.IP)
[18:45:56] *** ChanServ sets mode: +o tjc
[18:46:19] <nmatsakis> bjz_: ...in this case, the problem arises because you want the return type of the index operation to refer to the lifetime of the receiver
[18:46:51] <nmatsakis> bjz_: actually, wait a sec...let me go check something out :)
[18:47:02] <nmatsakis> bjz_: might be a somewhat nicer way to solve this than what I proposed, at least in this case.
[18:47:14] <nmatsakis> bjz_: well, ok, wait, I'll finish my sentence first,
[18:47:42] <nmatsakis> bjz_: basically you want a method like "fn index<'a>(&'a self, idx: &uint) -> &'a Row" (or whatever)
[18:47:52] <bjz_> yep
[18:47:59] <bjz_> btw: https://gist.github.com/bjz/7d8432f8b658363a0192
[18:48:03] <nmatsakis> bjz_: but the return type &'a Row must be declared in the trait header
[18:48:08] <nmatsakis> bjz_: and in the trait header, 'a is not in scope.
[18:48:31] <nmatsakis> bjz_: this is the problem I was getting at. however, I realize now, that it's probably legitimate to do this:
[18:48:53] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[18:49:09] <nmatsakis> bjz_: impl<'self> Index<uint, &'self Row> Matrix { fn index(&'self self, index: &uint) -> &'self Row { ... } }
[18:49:24] <nmatsakis> bjz_: but let me write it up in a gist because it's probably more readable that way.
[18:49:44] <bjz_> I think I tried that before
[18:49:51] *** Joins: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net)
[18:50:10] *** Joins: aruniiird (arun@D880D76D.1A3218DE.FFE8C4AF.IP)
[18:50:11] <bjz_> got some lifetime errors I think
[18:50:25] <nmatsakis> bjz_: oh, wait, yeah, sorry. that doesn't work.
[18:50:32] *** Quits: tjc (tjc@2557E599.66715431.D25A875A.IP) (Quit: zzzzzzzzzz)
[18:50:34] *** Quits: n0vember (n0vember@moz-690FFF9D.org) (Ping timeout)
[18:50:35] <nmatsakis> bjz_: the problem being that the Index trait doesn't include 'self in *its* self type
[18:50:43] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[18:50:56] <bjz_> yeah
[18:51:12] <bjz_> the signature doesn't match up
[18:51:19] <nmatsakis> bjz_: ok, so, hmm, that might be a way to fix the problems I was having with my proposal for how to *change* the index type, though
[18:51:35] <nmatsakis> bjz_: now let me look at the gist you sent, sorry
[18:51:56] *** Quits: aruniiird (arun@D880D76D.1A3218DE.FFE8C4AF.IP) (Ping timeout)
[18:52:37] <bjz_> of course `*(&*(&v)[2])[3]` kind of defeats the purpose of overloading :)
[18:54:01] *** Joins: n0vember (n0vember@moz-690FFF9D.org)
[18:54:05] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[18:54:53] <bjz_> but at least it doesn't copy
[18:55:00] <bjz_> hehe
[18:55:45] <kimundi> Would it be useful to have mulitdimensional indexing? foo[15, 65]
[18:56:01] <cmr> foo[15][65] ?
[18:56:13] <bjz_> :P
[18:56:22] <Jeaye> The same amount of characters to type. :P
[18:56:34] *** Quits: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net) (Quit: eholk)
[18:57:51] <nmatsakis> kimundi: it probably would be, I think.
[18:57:56] *** Joins: blitter (blitter@moz-E761A52F.dyn.centurytel.net)
[18:59:23] <thomaslee> kaeso, ping?
[18:59:32] <cmr> Yeah, it would be useful. Could do multidimensional access directly without having to return intermediate stuff
[18:59:40] <nmatsakis> right
[18:59:49] <bjz_> foo[(15, 65)] :D
[18:59:51] <cmr> A real slice notation would be nice too :D
[18:59:59] <nmatsakis> definitely the index trait as is is insufficient.
[19:00:22] <kimundi> foo[15, 15] could just sugar to foo[(15, 15)]  ?
[19:00:31] *** Joins: pyrac (pyrac@moz-D851FA22.w92-149.abo.wanadoo.fr)
[19:00:40] *** Joins: aruniiird (arun@D880D76D.1A3218DE.FFE8C4AF.IP)
[19:00:49] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[19:00:49] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/ePZuyg
[19:00:49] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[19:00:50] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[19:00:53] *** Quits: ssiloti (steve@moz-4B8C4631.oc.oc.cox.net) (Client exited)
[19:01:02] <nmatsakis> bjz_: only problem with that is that you cannot write an N-dimensional matrix type
[19:01:17] <nmatsakis> bjz_: whereas if you received a slice, you don't hard to hard-code in 2d or 3d etc
[19:02:06] <bjz_> yep
[19:02:19] <bjz_> (was semi-joking)
[19:02:42] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Ping timeout)
[19:03:25] <bjz_> nmatsakis: https://github.com/mozilla/rust/issues/4160
[19:04:00] *** Joins: seth (seth@5AAE35B2.5EFFC0B8.24454B25.IP)
[19:04:10] *** Joins: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP)
[19:04:45] <nmatsakis> bjz_: yes, I know, it's a related issue...
[19:05:46] *** Quits: seth (seth@5AAE35B2.5EFFC0B8.24454B25.IP) (Ping timeout)
[19:05:59] *** Quits: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP) (Ping timeout)
[19:07:24] <nmatsakis> bjz_: so, I was toying with ways to make returning an intermediate "view" on an N-dimensional matrix work out, and finding it...hard to reconcile, but I guess if we allowed you to write "a[1, 2, 3]" then having an (n-1)-dimensional view no longer needs to be a function of the index operator, which helps a lot.
[19:08:06] <nmatsakis> bjz_: but in all seriousness maybe you *should* override for a key of (uint,uint) in your matrix :)
[19:08:19] <nmatsakis> bjz_: it would certainly erase these thorny questions.
[19:08:46] *** Joins: ssiloti (steve@moz-4B8C4631.oc.oc.cox.net)
[19:08:54] <martndemus> How can I make fields mutable?
[19:09:01] <bjz_> nmatsakis: but then I can't access the columns with a single intex
[19:09:02] <nmatsakis> martndemus: store the struct in a mutable location.
[19:09:04] <bjz_> *index
[19:09:18] <nmatsakis> bjz_: yeah, you would make a "col" method or something. matrix.col(3)
[19:09:22] <cmr> martndemus: ie, let mut foo = ..., or &mut, or @mut
[19:10:30] <bjz_> nmatsakis: would the backwards-multiple overload trick work?
[19:10:47] <bjz_> nmatsakis: maybe for uint and (uint, uint)
[19:11:20] <martndemus> cmr: That does not work. http://pastebin.com/VLpSjWDs does not compile with the error assigning to immutable field
[19:11:38] <bjz_> nmatsakis: at least there are only two types
[19:11:41] <nmatsakis> bjz_: I see. Well, the thorny part is 
[19:11:42] <cmr> martndemus: &mut self
[19:11:49] *** Quits: a_m0d (a_m0d@moz-9F925EFA.hm.shawcable.net) (Quit: Leaving.)
[19:11:51] <cmr> martndemus: &-ptrs are immutable
[19:12:44] <nmatsakis> bjz_: sorry, uh, well, maybe I don't know. I really think the index trait as is will just not work for what you want, or at least not nicely.
[19:12:52] <martndemus> cmr: thanks!
[19:12:59] *** Quits: cantsin (cantsin@moz-F99612CC.members.linode.com) (Ping timeout)
[19:13:23] *** Quits: Sodel_the_V (user@moz-853663E1.va.shawcable.net) (Input/output error)
[19:13:24] <bjz_> nmatsakis: hmm ok.
[19:13:32] *** Joins: cantsin (cantsin@moz-F99612CC.members.linode.com)
[19:13:40] <bjz_> nmatsakis: maybe I might try that in the mean time
[19:13:55] *** Quits: Raynes (macro@moz-E5F01CE6.members.linode.com) (Ping timeout)
[19:14:07] <nmatsakis> bjz_: if I were you, I might just add "matrix.col(3)" and "matrix.cell(x, y)", and maybe we can sort out how the index trait should work
[19:14:14] *** Quits: jld (jld@moz-B94C75AD.xlerb.net) (Ping timeout)
[19:14:17] <nmatsakis> bjz_: but maybe that makes it really unreadable, I don't know.
[19:14:23] <bjz_> mmk
[19:14:34] <bjz_> might be better for now
[19:14:34] *** Joins: Raynes (macro@moz-E5F01CE6.members.linode.com)
[19:14:57] <nmatsakis> bjz_: at least you wont' be wrestling with lifetime errors and trying to workaround things all the time
[19:15:00] <bjz_> col, col_ref, col_mut
[19:15:09] <nmatsakis> what is col_ref?
[19:15:17] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[19:15:23] *** Joins: doomlord (doomlod@moz-B63745D8.range86-176.btcentralplus.com)
[19:15:26] *** Joins: jld (jld@moz-B94C75AD.xlerb.net)
[19:15:28] <nmatsakis> I envisioned col always returning a pointer.
[19:15:36] <nmatsakis> you probably do need a col_mut though.
[19:15:39] <bjz_> oh, yeah
[19:15:43] <nmatsakis> that was part of my ideas for a "new" index type,
[19:15:51] <nmatsakis> or rather a new Index trait,
[19:15:54] <bjz_> that's probably best
[19:15:58] <nmatsakis> that it should have distinct methods for the three ways `[]` can be used:
[19:16:08] <nmatsakis> `&x[0]`, `&mut x[0]`, and `x[0]`
[19:16:23] *** Joins: lmandel (lmandel@FE1F74.86ED00A7.971E19F6.IP)
[19:16:27] *** Joins: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net)
[19:16:38] <bjz_> that would be most nice
[19:16:43] <nmatsakis> which would return an `&T`, `&mut T`, and a `T` respectively
[19:16:44] *** Quits: mcomella (mcomella@moz-B10FF54F.ri.ri.cox.net) (Ping timeout)
[19:16:55] <nmatsakis> actually a `&'a T`, `&'a mut T`, and T, where 'a is the lifetime of the receiver
[19:17:06] <nmatsakis> that scheme would fit nicely into the compiler,
[19:17:12] <bjz_> would vectors implement these new methods?
[19:17:14] <nmatsakis> but it doesn't allow you to do x[1] to get a column view
[19:17:24] <bjz_> as opposed to that being hard-wired?
[19:17:28] <cmr> And how about foo[i] = bar?
[19:17:28] <nmatsakis> once dynamically sized types are working,
[19:17:38] <nmatsakis> cmr: yes, actually I had a method for that too.
[19:17:42] <bjz_> nmatsakis: ah dang
[19:17:56] <nmatsakis> bjz_: ...then I think vectors could not be built-in
[19:17:58] <nmatsakis> oh, wait
[19:18:07] <nmatsakis> actually my three methods were: return &, return &mut, and x[i] = v
[19:18:17] <nmatsakis> I was just doing to treat `v[i]` as `*&v[i]`
[19:18:22] <nmatsakis> *going to
[19:18:49] <nmatsakis> bjz_: if you want to support a column view,
[19:19:40] <nmatsakis> bjz_: we could maybe do that too, but you lose the guarantee that &v[i] alwyas yields an & pointer, no matter what type `v` is
[19:19:56] <nmatsakis> not sure how important that is, maybe it's not.
[19:20:10] <bjz_> sorry for the bother
[19:20:18] <nmatsakis> bjz_: not bother, we have to work these things out!
[19:20:21] *** Joins: jdm (jdm@8B24284F.1752D4EE.971E19F6.IP)
[19:20:43] <nmatsakis> bjz_: the operator overloading was kind of added hastily, imo, and we never sat down and tried to work out all the use cases..
[19:21:02] <nmatsakis> no time like the present, I guess.
[19:21:06] <bjz_> crazy users
[19:21:12] <bjz_> :)
[19:21:17] <nmatsakis> :)
[19:21:24] <bjz_> never do what you expect
[19:21:26] *** Joins: snearch (snearch@moz-9C336E70.pool.mediaways.net)
[19:21:43] <nmatsakis> bjz_: still working on that dang extern "C" patch. I'm ping-ponging between 32 and 64 bit. Each time I fix one, the other breaks. ;)
[19:21:58] <nmatsakis> bjz_: hopefully near the end of this cycle now. But the ABI compatibility code is a bit ... black magic.
[19:21:59] <doomlord> do the operators get a trait or something
[19:22:17] <bjz_> doomlord: yes
[19:22:26] <nmatsakis> doomlord: yes, some operators have an associated trait and hence can be overloaded (+, -, *, /, [])
[19:22:26] <bjz_> nmatsakis: heh
[19:22:48] <bjz_> doomlord: also the bit shift ones
[19:23:08] <bjz_> doomlord: assignment ops are still in the works
[19:23:11] <doomlord> how about overloading  bitshift for file IO (joke)
[19:23:20] *** Quits: Jesin (Jessin_@moz-83FA8843.res.lehigh.edu) (Quit: Leaving)
[19:23:21] <bjz_> :)
[19:23:32] <doomlord> who'd do a thing like that
[19:23:38] <doomlord> :)
[19:23:42] <cmr> nmatsakis: How does it behave when the key is not accessible?
[19:23:50] <bjz_> that's ridiculous!
[19:24:10] <bjz_> nmatsakis: however the user implements it
[19:24:12] <cmr> That would have to be standardized, I think? Or does <T:Index> not make sense?
[19:24:14] <bjz_> *cmr
[19:24:23] <doomlord> some sort of n-ary macro would do the same job...   n_ary(file_write : a,b,c,d,d...)  instead of   file<<a<<b<<c...
[19:24:25] *** Quits: pyrac (pyrac@moz-D851FA22.w92-149.abo.wanadoo.fr) (Quit: pyrac)
[19:24:30] <doomlord> ^could do perhaps
[19:24:45] <nmatsakis> cmr: how does what behave?
[19:24:57] <cmr> nmatsakis: foo[i] where there is no i key
[19:25:00] <nmatsakis> bjz_: you mean something like hashmap[key]? I envisioned that it would fail.
[19:25:09] <doomlord> the essence of << in c++is the easy of applying the function to a series of things but why limit it to one operator
[19:25:10] <nmatsakis> oops
[19:25:11] <nmatsakis> cmr^^
[19:25:14] *** Quits: ssiloti (steve@moz-4B8C4631.oc.oc.cox.net) (Quit: leaving)
[19:25:19] <bjz_> nmatsakis: hehe
[19:25:25] <nmatsakis> cmr: that is why I added a separate method for hashmap[key] = v
[19:25:31] <nmatsakis> cmr: so that, in this case, it would not have to fail.
[19:25:45] <sp3d> std::map's [notpresent] behavior is a crime against all that is sane
[19:25:59] <nmatsakis> yes.
[19:26:00] *** Quits: z0w0 (zack@moz-567152E7.qld.bigpond.net.au) (Quit: Leaving.)
[19:26:20] <sp3d> nice to see the cycle of violence being broken ;)
[19:26:33] <cmr> nmatsakis: having a try_get or similar that does *not* fail when the key doesn't exist would be really nice, like python's get(key, default)
[19:27:11] <cmr> I'm not sure whether this makes sense for Index though
[19:27:11] *** Joins: ssiloti (steve@moz-4B8C4631.oc.oc.cox.net)
[19:27:17] <cmr> or if it should be higher level
[19:27:40] <nmatsakis> cmr: I mean, isn't that ... hashmap.find()?
[19:27:55] <nmatsakis> cmr: after all, in python map[key] throws if key is not found.
[19:28:21] <nmatsakis> cmr: I figure hashmap[key] == hashmap.get(key)
[19:28:32] *** Joins: Jesin (Jessin_@moz-83FA8843.res.lehigh.edu)
[19:28:43] *** Quits: aruniiird (arun@D880D76D.1A3218DE.FFE8C4AF.IP) (Ping timeout)
[19:28:52] <cmr> nmatsakis: Yes, but I mean as part of the Index trait. I just think if you have an indexable thing, you should be able to reason about how it fails. If some things implementing Index don't fail for nonexistent keys and some things do, that's messy.
[19:29:03] <nmatsakis> cmr: they would *have* to fail
[19:29:07] <nmatsakis> cmr: unless they can produce a valid pointer
[19:29:13] <nmatsakis> cmr: the type system would force them to
[19:29:33] *** Quits: sankha93 (Instantbir@14CE0F58.9A5EC03F.8B6C1D65.IP) (Quit: Instantbird 1.4 -- http://www.instantbird.com)
[19:29:34] *** Parts: judder (maradukewa@CF01B517.FDE2B133.950D3BB5.IP) ()
[19:29:34] <nmatsakis> cmr: so basically yes, it would be specified, that x[k] is for cases where you can produce a memory address corresponding to `k`
[19:29:49] <cmr> nmatsakis: Ok, I'm satisfied then
[19:30:24] <nmatsakis> cmr: this might be why it's worth distinguishing []-as-lvalue (i.e., `&x[k]`) from []-as-rvalue (i.e., `x[k]`), though, because sometimes you can have types that can produce a value but not a memory address...
[19:30:36] <nmatsakis> though I'm tempted to say
[19:30:39] <nmatsakis> "don't use [], then"
[19:32:28] <nmatsakis> bjz_: oh, I think I got both 32-bit linux and 64-bit mac working now :). Have to see what bors thinks now.
[19:32:49] <bjz_> nmatsakis: hoorah, fingures crossed
[19:32:52] <cmr> Oh, that reminds me.
[19:33:01] <cmr> How well would rust support an x32 port?
[19:33:24] <cmr> target_word_size would be 32 I think (since that's the pointer size), but it still supports 64bit values.
[19:34:48] *** Joins: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP)
[19:36:01] *** Quits: Jesin (Jessin_@moz-83FA8843.res.lehigh.edu) (Quit: Leaving)
[19:36:07] <ziad> Hi all. I'm trying to spawn a future. However, writing a 'use std::future' at the top of the program results in an unresolved import.
[19:36:18] *** Quits: victorporof (victorporo@DE2B5DEF.67CDC207.79933D60.IP) (Quit: victorporof)
[19:36:20] <nmatsakis> cmr: should...work?
[19:36:22] <cmr> ziad: if you're on incoming, you want extra::future
[19:36:34] *** Quits: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP) (Ping timeout)
[19:36:56] <ziad> cmr: I'm using 0.6
[19:37:07] *** Joins: Jesin (Jessin_@moz-83FA8843.res.lehigh.edu)
[19:37:13] <nmatsakis> ziad: not recommended. :)
[19:37:25] <ziad> lol :)
[19:37:27] <cmr> ziad: do you have "extern mod std;" ?
[19:38:09] <ziad> cmr: That seems to have resolved the import issues. Thanks :)
[19:38:27] <cmr> ziad: imports just bring things into scope. extern mod actually does linking
[19:38:42] <ziad> cmr: Gotcha, thanks for clearing that out.
[19:38:56] <cmr> ziad: incoming has a better error message when you forget to add "extern mod foo"
[19:39:18] <ziad> cmr: I'll try that then :)
[19:39:49] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[19:39:49] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/LLuNJA
[19:39:49] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[19:39:51] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[19:39:51] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/5qGqvg
[19:39:51] <ghrust> 13rust/06auto 14a4b3fa8 15Niko Matsakis: Issue #3678: Remove wrappers and call foreign functions directly
[19:39:51] <ghrust> 13rust/06auto 14d3c3956 15Niko Matsakis: core => std
[19:39:51] <ghrust> 13rust/06auto 141df1356 15Niko Matsakis: Cleanup return logic for Rust fns with foreign ABIs
[19:39:53] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[19:40:52] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[19:43:01] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[19:44:49] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[19:49:50] *** Joins: a_m0d (a_m0d@moz-9F925EFA.hm.shawcable.net)
[19:49:56] <bjz_> nmatsakis: good luck!
[19:49:59] <bjz_> :)
[19:51:52] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Ping timeout)
[19:52:19] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[19:52:32] *** Joins: mzabaluev (mzabaluev@moz-91FFD755.dhcp.inet.fi)
[19:54:42] *** Joins: heftig_ (heftig@moz-AE443C71.dip0.t-ipconnect.de)
[19:54:42] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[19:54:42] *** Quits: heftig (heftig@moz-F4B82211.dip0.t-ipconnect.de) (Ping timeout)
[19:57:39] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[19:58:01] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[19:58:01] *** ChanServ sets mode: +o brson
[19:58:17] *** Quits: hjr3 (hradtke@moz-AE3056B9.static.stls.mo.charter.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[20:05:34] *** Joins: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP)
[20:07:21] *** Quits: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP) (Ping timeout)
[20:08:16] *** Quits: int3_ (int3_@moz-B7B5F043.singnet.com.sg) (Connection reset by peer)
[20:08:30] *** Joins: int3_ (int3_@moz-B7B5F043.singnet.com.sg)
[20:08:46] *** Joins: hjr3 (hradtke@moz-AE3056B9.static.stls.mo.charter.com)
[20:08:46] *** Quits: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net) (Quit: I'm sure it's perfectly safe)
[20:10:04] *** Quits: Nisstyre (wes@moz-FD86289.netflash.net) (Ping timeout)
[20:12:26] *** Joins: dylukes (dylukes@6733336F.354C4AF.B016144E.IP)
[20:12:44] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[20:16:46] *** Quits: mzabaluev (mzabaluev@moz-91FFD755.dhcp.inet.fi) (Ping timeout)
[20:17:17] *** Joins: MaikKlein (maik@moz-4A7E00D6.dip0.t-ipconnect.de)
[20:17:51] *** Joins: pyrac (pyrac@moz-D851FA22.w92-149.abo.wanadoo.fr)
[20:17:51] *** Joins: tikue (tkuehn@moz-CF8BEBEF.dia.static.qwest.net)
[20:18:06] *** Quits: dylukes (dylukes@6733336F.354C4AF.B016144E.IP) (Ping timeout)
[20:18:53] *** Joins: dylukes (dylukes@6733336F.354C4AF.B016144E.IP)
[20:20:26] *** Joins: mzabaluev (mzabaluev@moz-91FFD755.dhcp.inet.fi)
[20:20:47] <cmr> nmatsakis: might it actually land this time!?
[20:20:48] *** Joins: mib_3e1e3x (Mibbit@moz-F42EAE5D.cable.virginmedia.com)
[20:22:23] *** Quits: dylukes (dylukes@6733336F.354C4AF.B016144E.IP) (Quit: Computer has gone to sleep.)
[20:24:36] <vcl> hi
[20:25:04] <vcl> is it possible to return a borrowed reference to members of a managed box?
[20:25:14] <vcl> rusti: struct Foo { a: int};   fn bar(x:@'xx Foo) -> &'xx int { &x.a };
[20:25:15] -rusti- foo.rs:5:50: 5:51 error: expected `fn`, found `)`
[20:25:15] -rusti- foo.rs:5          struct Foo { a: int};   fn bar(x:@'xx Foo) -> &'xx int { &x.a };
[20:25:15] -rusti-                                                            ^
[20:26:03] <cmr> rusti: struct Foo { a: int};   fn bar<'xx>(x: @Foo) -> &'xx int { &x.a };
[20:26:04] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/acCH
[20:26:31] <cmr> rusti: struct Foo { a: int};   fn bar<'xx>(x: @Foo) -> &'xx int { &'xx x.a };
[20:26:33] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/DBhX
[20:26:43] *** Quits: Yurume_ (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[20:27:44] *** Joins: Nisstyre (wes@moz-FD86289.netflash.net)
[20:27:52] <cmr> rusti: struct Foo { a: int};   fn bar<'xx>(x: @'xx Foo) -> &'xx int { &'xx x.a };
[20:27:52] -rusti- foo.rs:5:56: 5:57 error: expected `fn`, found `)`
[20:27:52] -rusti- foo.rs:5          struct Foo { a: int};   fn bar<'xx>(x: @'xx Foo) -> &'xx int { &'xx x.a };
[20:27:52] -rusti-                                                                  ^
[20:27:59] <cmr> yeah, didn't think that was valid
[20:28:24] <vcl> but it should be possible, right?
[20:28:34] <cmr> I don't know. nmatsakis?
[20:28:42] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Connection reset by peer)
[20:28:48] <doener> rusti: struct Foo { a: int};   fn bar<'xx>(x: &'xx Foo) -> &'xx int { &'xx x.a }; let thing = @Foo {a:5}; bar(thing)
[20:28:49] -rusti- &5
[20:29:02] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[20:30:37] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[20:30:57] *** Joins: dherman (dherman@moz-AF20492.sub-70-197-9.myvzw.com)
[20:30:57] *** ChanServ sets mode: +o dherman
[20:31:03] <doener> hm, the automatic rooting might allow to drop the var...
[20:31:16] <doener> rusti: struct Foo { a: int};   fn bar<'xx>(x: &'xx Foo) -> &'xx int { &x.a }; bar(@Foo {a:5})
[20:31:18] -rusti- &5
[20:32:33] *** Quits: Jesin (Jessin_@moz-83FA8843.res.lehigh.edu) (Quit: Leaving)
[20:33:44] <vcl> Hmm, but why this doesn't work when Foo is passed by managed pointer?
[20:34:19] <doener> because you can't specify a lifetime on it
[20:35:12] *** Parts: mib_3e1e3x (Mibbit@moz-F42EAE5D.cable.virginmedia.com) ()
[20:35:30] <MaikKlein> what do you guys think of D?
[20:35:44] <vcl> And why's that?   Can't rust check that the caller retains a reference to Foo until &x.a goes out of scope?
[20:36:20] *** Joins: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP)
[20:36:29] *** Joins: mib_fwzyq0 (Mibbit@moz-F42EAE5D.cable.virginmedia.com)
[20:36:40] <Luqman> nmatsakis: pong
[20:37:07] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[20:37:07] <thomaslee> anybody know what tool(s) folks are being used to profile rust memory usage etc. here https://github.com/mozilla/rust/issues/6637 ? Something baked in to the runtime, or something else?
[20:37:29] <cmr> thomaslee: massif (from valgrind), mostly.
[20:38:14] *** Quits: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP) (Ping timeout)
[20:38:48] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[20:38:52] <thomaslee> cmr, cool -- thanks!
[20:40:07] *** Quits: KindOne (KindOne@moz-97FBD8C0.dynamic.ip.windstream.net) (Ping timeout)
[20:40:43] *** Joins: KindOne (KindOne@moz-97FBD8C0.dynamic.ip.windstream.net)
[20:41:16] *** Joins: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net)
[20:41:48] <doener> vcl: it only supports litetime annotations on borrowed pointers. Why do you need managed one?
[20:42:23] *** Joins: Jesin (Jessin_@moz-83FA8843.res.lehigh.edu)
[20:42:35] <cmr> thomaslee: once jemalloc is integrated (strcat was working on it), we can use its heap profiling as well.
[20:42:58] <vcl> doener: I have an existing function that takes a managed one.
[20:43:01] <nmatsakis> rusti:  struct Foo { a: int}   fn bar<'xx>(x:&'xx Foo) -> &'xx int { &x.a }
[20:43:06] <nmatsakis> vcl: ^^
[20:43:21] <nmatsakis> vcl: you can't return a borrowed reference to a managed box, only to another borrow pointer
[20:43:31] <nmatsakis> vcl: but you could call bar() with an @Foo, the compiler will borrow the box at the call site
[20:43:47] <nmatsakis> vcl: that is *how* the compiler checks that the caller has a reference
[20:44:14] *** Quits: twm (twm@moz-13417AD3.dsl.static.sonic.net) (Ping timeout)
[20:44:14] <nmatsakis> vcl: otherwise, the caller would have to know what bar() does---in general, the caller knows nothing about what its callees do, except the types in the signature
[20:46:16] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[20:46:31] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[20:46:54] <vcl> nmatsakis: but it does know: "foo(a:@'xx Foo) -> &'xx int" tells it that the return value aliases argument a...
[20:47:18] <nmatsakis> vcl: @'xx is not valid syntax.
[20:47:53] <vcl> nmatsakis: I'm ok to change it to &'xx Foo, I just see no reason @'xx Foo isn't allowed
[20:47:53] <nmatsakis> vcl: if what you're planning to say is: "I will return a pointer with the same lifetime as `a`", you write that the way I suggested.
[20:49:36] *** Quits: lmandel (lmandel@FE1F74.86ED00A7.971E19F6.IP) (Ping timeout)
[20:49:44] <vcl> nmatsakis: hypothetically, what if foo() wanted to retain a reference to argument a for some other purposes?  Would a have to be passed in twice: once by borrowed pointer and once by managed?
[20:50:22] <nmatsakis> vcl: yes.
[20:50:29] <MaikKlein> how can I force type T to have a += operator?
[20:51:10] <nmatsakis> "force"? You can overload +, but that's the only way. I don't really recommend it, += is kind of ... messed up right now. Eventually it will be a trait of its own.
[20:51:34] <MaikKlein> no I require at least that type T can be added with +
[20:51:52] <benh> fn f<T: Add<Rhs, RetType>>() {} or something...
[20:52:05] <engla> MaikKlein: the trait bound T:Add<T,T>  is the simplest
[20:52:17] <nmatsakis> bjz_: dang, windows still fails. I guess that patch will have to wait until I can get to my windows machine. :(
[20:52:20] *** Quits: pyrac (pyrac@moz-D851FA22.w92-149.abo.wanadoo.fr) (Quit: pyrac)
[20:52:51] *** Quits: geomyidae (geomyidae@9FDA6BE2.37A86C23.448B98CC.IP) (Ping timeout)
[20:53:25] *** Joins: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net)
[20:53:46] <vcl> thx
[20:53:56] *** Joins: kyle2000 (kyle2000@D3528B97.7E2E8376.3031298E.IP)
[20:54:56] *** Quits: Voomer (Voomer@moz-E97E8EB7.br.br.cox.net) (Connection reset by peer)
[20:55:40] <kyle2000> friends, does rust have any support for unix domain sockets? i find no references in the docs!
[20:55:54] <cmr> kyle2000: through libuv, yes.
[20:56:04] *** Quits: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk) (Ping timeout)
[20:58:29] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[20:59:48] *** mib_fwzyq0 is now known as zheng_li
[21:01:21] *** Joins: twm (twm@moz-13417AD3.dsl.static.sonic.net)
[21:01:53] <kyle2000> cmr: many thanks, i did not realize that libuv's "pipe" is not the pipe i was thinking it was.
[21:04:05] *** Joins: tjc (tjc@99F66265.D3786173.DD630FEE.IP)
[21:04:05] *** ChanServ sets mode: +o tjc
[21:05:02] *** Quits: hjr3 (hradtke@moz-AE3056B9.static.stls.mo.charter.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[21:05:15] *** Joins: seth (seth@5AAE35B2.5EFFC0B8.24454B25.IP)
[21:07:05] *** heftig_ is now known as heftig
[21:07:06] *** Joins: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP)
[21:07:19] *** Quits: seth (seth@5AAE35B2.5EFFC0B8.24454B25.IP) (Ping timeout)
[21:08:52] *** Quits: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP) (Ping timeout)
[21:09:18] <MaikKlein> do you know what is going on here? https://gist.github.com/MaikKlein/5650789
[21:09:22] *** Quits: sk (sk@61A494B3.BA40E8A.AAC02D62.IP) (Input/output error)
[21:09:22] *** Quits: sk_ (sk@61A494B3.BA40E8A.AAC02D62.IP) (Input/output error)
[21:10:06] <cmr> MaikKlein: "try running with RUST_LOG=rustc=1,::rt::backtrace to get further details"
[21:11:34] <jdm> in general, running rustc under gdb and showing the backtrace from rust_task_fail is more useful
[21:11:42] <jdm> the rt::backtrace logs never tell me anything useful
[21:12:11] <MaikKlein> I actually have no idea what I should do. Is this a compiler flag?
[21:12:16] <cmr> MaikKlein: environment variable
[21:13:21] *** zheng_li is now known as zhengli
[21:13:32] *** Quits: tjc (tjc@99F66265.D3786173.DD630FEE.IP) (Quit: zzzzzzzzzz)
[21:13:50] *** Parts: zhengli (Mibbit@moz-F42EAE5D.cable.virginmedia.com) ()
[21:13:56] *** Quits: jdm (jdm@8B24284F.1752D4EE.971E19F6.IP) (Quit: Lost terminal)
[21:13:59] *** Joins: steve (steve@31B68BE8.171C391.80C20C35.IP)
[21:14:05] *** steve is now known as steveklabnik
[21:14:11] <cmr> jdm: I get the same from rt::backtrace as gdb, since debug-info is broken
[21:15:16] *** Quits: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net) (Quit: eholk)
[21:15:46] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[21:15:46] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 142b14250 to 149d37d03: 02http://git.io/N3iJvQ
[21:15:46] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[21:15:47] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[21:15:47] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/AGVvrQ
[21:15:47] <ghrust> 13rust/06auto 145233604 15James Miller: Add basic atomic types
[21:15:47] <ghrust> 13rust/06auto 142706271 15bors: auto merge of #6732 : Aatch/rust/atomic-types, r=brson...
[21:15:47] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[21:15:57] <kyle2000> cmr: i am looking into libuv and i see that it has functions like uv_pipe_init and uv_pipe_bind. but i find no reference to those in the rust uv*.rs code. is my understand of it correct to be thinking that these are not yet supported by rust's libextra?
[21:16:18] *** Quits: dherman (dherman@moz-AF20492.sub-70-197-9.myvzw.com) (Ping timeout)
[21:16:38] <MaikKlein> if I do "env" in linux I should see RUST_LOG right?
[21:17:03] <cmr> MaikKlein: not unless you already exported it. RUST_LOG=rustc=1,::rt::backtrace rustc ...
[21:17:13] *** Joins: tjc (tjc@99F66265.D3786173.DD630FEE.IP)
[21:17:13] *** ChanServ sets mode: +o tjc
[21:18:49] <cmr> kyle2000: guess not.
[21:18:57] <kyle2000> okay. many thanks for you help.
[21:19:08] *** Quits: tjc (tjc@99F66265.D3786173.DD630FEE.IP) (Ping timeout)
[21:20:09] <nmatsakis> vcl: I was thinking, the way to address you other scenario is to hvae fn foo<'xx>(x: &'xx @Foo) -> &'xx int
[21:20:25] <nmatsakis> vcl: that is, the case where you want the caller to root it, but you want to take a copy as well
[21:21:10] <cmr> rusti: struct Foo { a: int};   fn bar<'xx>(x: &'xx @Foo) -> &'xx int { let a = *x; &'xx x.a };
[21:21:12] -rusti- foo.rs:5:77: 5:78 warning: unused variable: `a` [-W unused-variable (default)]
[21:21:12] -rusti- foo.rs:5          struct Foo { a: int};   fn bar<'xx>(x: &'xx @Foo) -> &'xx int { let a = *x; &'xx x.a };
[21:21:12] -rusti-                                                                                       ^
[21:21:12] -rusti- note: in expansion of fmt!
[21:21:12] -rusti- foo.rs:4:12: 6:7 note: expansion site
[21:24:36] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[21:25:47] <cmr> rusti: fail!("%s")
[21:25:48] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/TebY
[21:26:12] <cmr> rusti: fail!("%%s")
[21:26:14] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/NWKj
[21:28:22] <cmr> rusti: "'" as char
[21:28:24] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/KZDE
[21:28:39] <cmr> m
[21:28:54] <kimundi> rusti: if true { fail!("%?") }
[21:28:55] -rusti- rust: task failed at '%?', foo.rs:4
[21:28:55] -rusti- rust: domain main @0x13901b0 root task failed
[21:29:13] <MaikKlein> hm
[21:29:21] <kimundi> cmr: What are you trying to find out? :)
[21:29:33] <MaikKlein> what would be the cmd to set RUST_LOG=rustc=1,::rt::backtrace 
[21:29:33] *** Joins: tjc (tjc@moz-D53FFBC5.dsl.pltn13.pacbell.net)
[21:29:33] *** ChanServ sets mode: +o tjc
[21:29:57] <kimundi> MaikKlein: You have to set that as an shell env variable
[21:30:11] <cmr> MaikKlein: you don't need to specifically set it in the current environment, you can set it in the environment when you call rustc like `RUST_LOG=rustc=1,::rt::backtrace rustc foo.rs`
[21:30:27] <kimundi> MaikKlein: You can just do 'RUST_LOG=rustc=1,::rt::backtrace rustc ...'
[21:30:32] <MaikKlein> ho i did this
[21:30:33] <cmr> kimundi: whether fail!() would want me to provide variables for strings which are also valid fmt strings
[21:30:38] <MaikKlein> wait i try again
[21:31:10] *** Quits: FrozenCow (FrozenCow@moz-9DF5D010.dynamic.upc.nl) (Quit: Leaving)
[21:31:21] <kimundi> cmr: fail!() only invokes the fmt!() macro if you pass more than one expression
[21:31:27] <MaikKlein> ok nvm I am just stupid
[21:31:28] <MaikKlein> thanks
[21:31:38] <cmr> kimundi: which is very useful!
[21:31:40] <kimundi> rusti: fmt!("%?")
[21:31:40] -rusti- foo.rs:5:9: 6:5 error: not enough arguments to fmt! for the given format string
[21:31:40] -rusti- foo.rs:5          fmt!("%?")
[21:31:40] -rusti- foo.rs:6     });
[21:31:59] *** Joins: dylukes (dylukes@6733336F.354C4AF.B016144E.IP)
[21:32:36] <indutny> hey guys
[21:32:47] <indutny> just curious, can I run one specific test from test suite
[21:32:58] <cmr> indutny: make check TESTNAME=foo
[21:33:03] <indutny> em
[21:33:07] <indutny> not compiler
[21:33:14] <indutny> test suite which is result of rust --test
[21:33:18] <cmr> oh
[21:34:00] <MaikKlein> in which category would I post this compiler error?
[21:34:08] <indutny> ah
[21:34:09] <indutny> --test
[21:34:29] <indutny> ah
[21:34:30] <indutny> no
[21:34:32] <indutny> just test name
[21:34:35] <indutny> ok, that's awesome
[21:34:56] <cmr> MaikKlein: don't worry about it, someone will properly categorize it later
[21:35:01] <kimundi> MaikKlein: Just make an issue on github
[21:37:52] *** Joins: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP)
[21:38:06] *** Joins: zheng_li (zheng_li@moz-D6711E9E.xenplanet.org)
[21:38:28] *** Quits: dylukes (dylukes@6733336F.354C4AF.B016144E.IP) (Quit: Computer has gone to sleep.)
[21:38:50] *** Parts: zheng_li (zheng_li@moz-D6711E9E.xenplanet.org) ()
[21:39:36] *** Quits: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP) (Ping timeout)
[21:39:38] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[21:39:51] <MaikKlein> anyways do you see some bad style here? https://gist.github.com/MaikKlein/5650789
[21:40:03] <MaikKlein> something that I should avoid?
[21:40:36] <cmr> MaikKlein: you are too frugal with your whitespace
[21:40:59] *** Joins: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net)
[21:41:07] <cmr> a space after commas is the convention
[21:41:23] <cmr> additionally, lines 16-17, you don't actually need to declare the type
[21:41:50] <MaikKlein> yeah I just added that because of the compiler
[21:42:06] *** Joins: zheng_li (zheng_li@moz-D6711E9E.xenplanet.org)
[21:42:07] <MaikKlein> to see if that was the problem
[21:42:26] <MaikKlein> btw
[21:42:48] <MaikKlein> if I do fn add(&mut self,v: Vec3<T>){  and then v1.add(v2); will v2 be consumed?
[21:43:19] *** Quits: tikue (tkuehn@moz-CF8BEBEF.dia.static.qwest.net) (Quit: tikue)
[21:45:02] *** Joins: asdf (Mibbit@moz-F42EAE5D.cable.virginmedia.com)
[21:45:43] *** Parts: asdf (Mibbit@moz-F42EAE5D.cable.virginmedia.com) ()
[21:49:10] *** Joins: dylukes (dylukes@6733336F.354C4AF.B016144E.IP)
[21:53:05] *** Quits: MaikKlein (maik@moz-4A7E00D6.dip0.t-ipconnect.de) (Ping timeout)
[21:53:41] *** Quits: dylukes (dylukes@6733336F.354C4AF.B016144E.IP) (Quit: Computer has gone to sleep.)
[21:57:47] *** Joins: paupau (NEAT@moz-387F7394.lightspeed.sntcca.sbcglobal.net)
[22:01:28] *** Joins: tikue (tkuehn@moz-CF8BEBEF.dia.static.qwest.net)
[22:04:53] *** Quits: kyle2000 (kyle2000@D3528B97.7E2E8376.3031298E.IP) (Quit: Leaving)
[22:05:39] *** Quits: sdh_ (sdh@DDAFE7B8.CB78C1A5.CA052C06.IP) (Quit: Konversation terminated!)
[22:05:59] *** Joins: seth (seth@5AAE35B2.5EFFC0B8.24454B25.IP)
[22:07:51] *** Quits: seth (seth@5AAE35B2.5EFFC0B8.24454B25.IP) (Ping timeout)
[22:08:38] *** Joins: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP)
[22:09:47] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[22:09:47] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/AGVvrQ
[22:09:47] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[22:09:57] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[22:10:14] *** Quits: int3_ (int3_@moz-B7B5F043.singnet.com.sg) (Client exited)
[22:10:18] *** Quits: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP) (Ping timeout)
[22:10:58] *** Quits: spider-mario (spidermari@moz-2F72F6FF.dsl.quantic-telecom.net) (Input/output error)
[22:12:29] *** Quits: steveklabnik (steve@31B68BE8.171C391.80C20C35.IP) (Quit: leaving)
[22:12:45] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[22:12:45] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/OBB9_g
[22:12:45] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[22:14:49] *** Quits: tjc (tjc@moz-D53FFBC5.dsl.pltn13.pacbell.net) (Quit: Places to go, people to annoy)
[22:15:46] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[22:15:46] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/OBB9_g
[22:15:46] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[22:15:47] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[22:15:47] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/3hJMlQ
[22:15:47] <ghrust> 13rust/06auto 14ec8fb88 15Alex Crichton: Remove usage of the #[merge] hack with int modules
[22:15:47] <ghrust> 13rust/06auto 1403ae629 15Alex Crichton: Remove the #[merge] hack from the parser
[22:15:47] <ghrust> 13rust/06auto 14e2f8b51 15bors: auto merge of #6722 : alexcrichton/rust/issue-4219-no-merge-hack, r=brson...
[22:15:49] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[22:17:19] *** Joins: doomlord1 (walter@moz-B63745D8.range86-176.btcentralplus.com)
[22:21:13] <doomlord> is android rust plnned to use the ndk ..  would it sit at the same level as c, interfcing with jni - or would you use a c shim
[22:21:35] *** Joins: arnold (arnold@moz-72830A1C.nyc.res.rr.com)
[22:22:05] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[22:22:07] *** Quits: tikue (tkuehn@moz-CF8BEBEF.dia.static.qwest.net) (Quit: tikue)
[22:25:29] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[22:27:05] *** Joins: tikue (tkuehn@moz-CF8BEBEF.dia.static.qwest.net)
[22:27:18] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[22:37:18] *** Quits: paupau (NEAT@moz-387F7394.lightspeed.sntcca.sbcglobal.net) (Ping timeout)
[22:39:25] *** Joins: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP)
[22:39:54] <thomaslee> this seems like a noob question, but is there a way to convert an enum variant to a string, or will I need to write a function to explicitly map from my enum type to a str? (I guess even just the *name* of the variant at this point would be awesome)
[22:39:56] *** Quits: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP) (Quit: night)
[22:40:09] <Eridius> thomaslee: I just asked this yesterday. Seems fmt!("%?", foo) can do it
[22:40:24] <Eridius> although it seemed that trying to do this with None would crash ;)
[22:40:28] <Eridius> rusti: fmt!("%?", None)
[22:40:29] -rusti- error: internal compiler error: unexpected failure
[22:40:29] -rusti- note: the compiler hit an unexpected failure path. this is a bug
[22:40:29] -rusti- note: try running with RUST_LOG=rustc=1,::rt::backtrace to get further details and report the results to github.com/mozilla/rust/issues
[22:40:31] *** Joins: int3_ (int3_@moz-B7B5F043.singnet.com.sg)
[22:40:41] <Eridius> rusti: enum Foo { One, Two }; fmt!("%?", One)
[22:40:42] -rusti- ~"One"
[22:40:49] <cmr> rusti: enum Foo { X(int) }; fmt!("%?", X(2))
[22:40:51] -rusti- ~"X(2)"
[22:41:02] <cmr> Eridius: is there an issue open for the None crash?
[22:41:14] <Eridius> cmr: not that I know of. I wasn't the one who caused it to crash in the first place
[22:41:15] *** Quits: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP) (Ping timeout)
[22:41:40] <cmr> https://github.com/mozilla/rust/issues/5062
[22:42:13] <Eridius> btw, I just filed my first pull request: https://github.com/mozilla/rust/pull/6739. Did I do it correctly?
[22:42:30] <Eridius> (err, first one on this project. I've done them elsewhere before, but never in a project that has official guidelines around it)
[22:42:39] <cmr> Eridius: yup
[22:42:43] <Eridius> cmr: thanks
[22:42:59] <cmr> Eridius: you should remove the handling for the apple clang versions
[22:43:21] <Eridius> cmr: are those the 4.* ones?
[22:43:25] <cmr> Eridius: yes
[22:43:29] <Eridius> good idea
[22:43:36] *** Joins: igl1 (igl@moz-56F77DC0.adsl.alicedsl.de)
[22:43:36] <Eridius> I suppose I should just amend the existing commit?
[22:43:45] *** Quits: igl (igl@moz-3A7B7CAB.adsl.alicedsl.de) (Ping timeout)
[22:44:06] <cmr> or rebase, or just add a commit to the PR
[22:44:33] <Eridius> well, since there's been no activity, amending makes sense to me. I just want to make sure it won't confuse anything
[22:46:13] *** Quits: int3_ (int3_@moz-B7B5F043.singnet.com.sg) (Ping timeout)
[22:47:57] *** Quits: mzabaluev (mzabaluev@moz-91FFD755.dhcp.inet.fi) (Ping timeout)
[22:49:14] *** Joins: MaikKlein (maik@moz-4A7E00D6.dip0.t-ipconnect.de)
[22:50:58] *** Quits: Raynes (macro@moz-E5F01CE6.members.linode.com) (Quit: ZNC - http://znc.sourceforge.net)
[22:52:22] *** Quits: pauls_ (paul@moz-8C50DE9B.hsd1.ma.comcast.net) (Ping timeout)
[22:52:39] <indutny> rusti: fmt!("%?", [Some(1), None])
[22:52:40] -rusti- ~"[Some(1), None]"
[22:52:44] <indutny> nice
[22:53:31] <cmr> rusti: let x = Some(1); fmt!("%?", x)
[22:53:33] -rusti- ~"Some(1)"
[22:54:00] *** Quits: barosl (barosl@1E71221E.C81E10FB.7544CABF.IP) (Quit: ëžœë¤ì€ ì‡ í‡´í–ˆìŠµë‹ˆë‹¤.)
[22:55:18] <cmr> rusti: let x = Some(std::rand::random<int>()); fmt!("%?", x)
[22:55:20] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/hWUa
[22:55:42] <cmr> rusti: let x = Some(std::rand::random::<int>()); fmt!("%?", x)
[22:55:44] -rusti- ~"Some(5193447389047623594)"
[22:55:51] <cmr> what devilry is this
[22:56:14] <Eridius> what's the devilry?
[22:57:06] <cmr> enum stringification
[22:59:33] <cmr> ah it uses reflection
[23:00:08] *** Quits: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com) (Quit: Computer has gone to sleep.)
[23:02:38] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[23:04:16] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Ping timeout)
[23:04:17] <thomaslee> Eridius, oh nice -- thanks!
[23:05:21] <cmr> Is there syntax for bitwise negation?
[23:05:36] <cmr> There's not even a trait for it afaict
[23:05:49] <cmr> rusti: !10
[23:05:50] -rusti- -11
[23:05:56] <cmr> rusti: fmt!("%x", !10)
[23:05:57] -rusti- ~"fffffffffffffff5"
[23:05:59] <cmr> ah
[23:06:03] <cmr> weird
[23:06:18] <cmr> but necessary, given ~ is for owned ptr
[23:07:52] <engla> numbers don't coerce to bool so it works out fine
[23:08:05] <cmr> right, the syntax is just extremely unfamiliar
[23:08:09] <cmr> and looks... wrong
[23:08:12] <engla> yes
[23:08:52] <engla> rusti: 10.not()
[23:08:53] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/KHSI
[23:09:07] *** Quits: doomlord (doomlod@moz-B63745D8.range86-176.btcentralplus.com) (Ping timeout)
[23:09:14] <cmr> rusti: (10 as uint).not()
[23:09:16] -rusti- 18446744073709551605
[23:10:13] *** Joins: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP)
[23:10:15] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[23:12:06] *** Quits: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP) (Ping timeout)
[23:12:06] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Ping timeout)
[23:13:26] *** Quits: martndemus (martndemus@moz-FAE8D24A.sshunet.nl) (Input/output error)
[23:14:15] <MaikKlein> closures is just a different word for lambdas right?
[23:14:18] *** Quits: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net) (Quit: eholk)
[23:14:30] <cmr> MaikKlein: for what definition of lambda? :)
[23:15:02] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[23:15:07] <engla> Closure includes referencing or copying variables from the outer scope
[23:15:24] *** Quits: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[23:16:21] <MaikKlein> in c++ your can also do that and they are called lambdas. I don't know I think they are just anonymous functions that are able to capture variables by reference or copying.
[23:16:40] <MaikKlein> well in c++11
[23:17:15] <MaikKlein> yeah well okay I think they are the same :)
[23:18:20] *** Joins: Raynes (macro@moz-E5F01CE6.members.linode.com)
[23:18:47] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[23:18:47] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/3hJMlQ
[23:18:47] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[23:19:38] <aatch> A lambda is just a anonymous function. A closure specifically references the enclosing scope
[23:19:40] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[23:20:17] <engla> closures are called lambdas in C++ and in python
[23:20:18] <aatch> They are similar though, with a closure being the more general
[23:20:39] <Eridius> engla: C++ and python have language constructs called lambdas, which are also closures
[23:20:52] <engla> yes
[23:21:20] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[23:21:23] <Eridius> subtly different than saying closures are called lambdas
[23:21:35] <doener> IIRC in C++ they're lambda expression which create closures
[23:21:35] <engla> it wasn't meant any different
[23:21:45] <aatch> The only difference (from what I can tell) is that lambdas aren't assigned identifiers
[23:21:56] <Eridius> aatch: difference than.. what?
[23:21:58] <aatch> it's all just semantics mostly.
[23:22:10] <Eridius> a lambda in C++ is an instance of an anonymous class with a operator()
[23:22:26] <Eridius> with every lambda being its own unique anonymous class, and every time the code is execuetd a new instance of that anonymous class is created
[23:22:39] <Eridius> or at least, that's the simplest way to think about them
[23:23:03] <Eridius> I don't think the standard literally says they're an anonymous class. I think it just describes their behavior in a way that makes thinking of them as an anonymous class the simplest way
[23:23:10] <Eridius> e.g. the closure is implemented with the equivalent of member variables
[23:23:12] <aatch> Eridius, but from a more formal perspective, the only difference is that lambda's aren't named.
[23:23:16] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Client exited)
[23:23:23] <Eridius> aatch: again, difference than what?
[23:23:27] <Eridius> err difference from what
[23:23:33] <aatch> Eridius, between closures and lambdas
[23:23:50] <Eridius> closures don't have to be named either. The definition of closure says nothing about naming
[23:24:01] <Eridius> the only construct C++ has that represents a closure is the lambda
[23:24:10] <aatch> Eridius, true.
[23:26:11] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[23:26:46] <aatch> But there isn't really a difference between lambdas and closures in any real terms. The only thing I can see is that lambdas can't be named, as in, naming a lambda causes it to stop being a lambda, and instead is a named function that may-or-may-not be a closure.
[23:27:17] <Eridius> aatch: well in the general sense, a lambda may not be a closure
[23:27:47] <Eridius> C++ and python's lambda constructs are. But it's not required in an arbitrary language that has lambdas
[23:29:42] <aatch> The naming is a quirk of their origin. "Lambda" comes from lambda calculus, but "closure" came from a need to explicitly express that it captures the enclosing environment.
[23:30:34] <aatch> Think of javascript, you can have anonymous functions (function () {}), and named functions, (function func () {}). Both can be closures, but only one is a lambda
[23:31:20] <aatch> Rust doesn't have that, all closures are lambdas, since inner functions don't capture the environment.
[23:31:25] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Connection reset by peer)
[23:31:31] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[23:31:51] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Connection reset by peer)
[23:31:54] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[23:31:57] <aatch> Sorry, I've been distilling this while talking, so I might seem a little scatter-brained.
[23:32:16] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Connection reset by peer)
[23:33:39] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[23:34:05] <MaikKlein> do you know any blogs about Rust?
[23:34:06] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Connection reset by peer)
[23:34:31] <aatch> MaikKlein, most of the core devs have blogs, and they blog about Rust quite often
[23:34:54] <MaikKlein> really?
[23:35:03] <MaikKlein> I found two core developers and the last post was from 2011
[23:35:14] <cmr> heh, you're looking in the wrong palces :p
[23:35:16] <doener> there's also a rust subreddit 
[23:35:20] <aatch> nmatsakis blogs about Rust.
[23:35:24] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[23:35:26] <cmr> http://smallcultfollowing.com/babysteps/
[23:35:27] <aatch> Oh yeah, Reddit!
[23:35:35] * aatch doesn't use reddit
[23:35:46] <doener> http://www.reddit.com/r/rust
[23:35:51] <MaikKlein> reddit I know :)
[23:36:12] <cmr> http://nickdesaulniers.github.io/
[23:36:17] <MaikKlein> @cmr this is what I was looking for
[23:36:19] <cmr> http://pcwalton.github.io/
[23:37:01] <MaikKlein> ok it seems pcwalton has more than one blog 
[23:37:17] <MaikKlein> thanks
[23:37:28] *** Quits: vosen (vosen@moz-266BA656.icpnet.pl) (Quit: Leaving)
[23:37:36] <brson> tjc blogs a lot too, but each entry is usually small in scope http://tim.dreamwidth.org/tag/research
[23:37:46] <brson> I blog rarely http://brson.github.com/
[23:38:01] <brson> graydon blogs like once a year
[23:38:19] <cmr> He has plenty of really good posts on the ML though
[23:38:26] <cmr> which are probably deserving of copying to a blog :)
[23:38:53] *** Joins: paupau (NEAT@moz-C616DA0A.hsd1.ca.comcast.net)
[23:39:02] <heftig> did the "dynamically sized types" proposal go anywhere?
[23:39:11] <cmr> heftig: still in progress afaik
[23:39:30] <aatch> heftig, I think the proposal itself might be on niko's blog...
[23:39:40] <aatch> Or at least, some form of it.
[23:39:46] <heftig> yeah, i read that
[23:39:57] <MaikKlein> heftig?
[23:40:05] <heftig> MaikKlein: huh?
[23:40:14] <MaikKlein> oh nvm it's a user :D
[23:40:23] <MaikKlein> thought it is a project or sth
[23:40:26] <heftig> no, i'm not a robot
[23:40:28] <heftig> or a product
[23:40:42] <MaikKlein> but you are german right?
[23:40:44] <heftig> yes.
[23:40:49] <aatch> heftig, that's exactly what a robot-product would say!
[23:40:56] * heftig gasps
[23:40:59] <heftig> you found me out!
[23:41:01] *** Joins: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP)
[23:41:59] <MaikKlein> btw is this generated with rustdoc? http://static.rust-lang.org/doc/core/index.html
[23:42:41] *** Quits: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP) (Ping timeout)
[23:43:09] <heftig> yes, i think so
[23:43:24] <cmr> It is, yes.
[23:46:26] <cmr> http://www.darkcoding.net/software/rust-what-i-learnt-so-far/ claims "Rust is a big language"
[23:46:40] <aatch> cmr, I'd say that's true
[23:46:46] <cmr> aatch: What is big about it?
[23:47:00] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Quit: Leaving.)
[23:47:09] *** Joins: isaac (isaac@moz-C0CEEB7.dfw.dsl-w.verizon.net)
[23:47:14] <aatch> There is a lot you need to know in order to write Rust effectively.
[23:47:22] <MaikKlein> it already comes with some many tools
[23:47:24] <cmr> Isn't that true of all languages?
[23:47:36] <aatch> I.E., without constant compiler errors
[23:47:37] *** Joins: steve (steve@31B68BE8.171C391.80C20C35.IP)
[23:47:42] *** steve is now known as steveklabnik
[23:48:00] <cmr> I would argue that Javascript is a large language, because of all the nasty semantics hiding in some corners.
[23:48:17] <aatch> In Rust, it's very easy to write code that turns out to not work very well at all.
[23:48:18] <steveklabnik> can anyone give me a quick example of how FromStr is used, specifically with bools?
[23:48:19] <SiegeLord> As long as it's smaller than C++, then it has accomplished its goal
[23:48:37] <steveklabnik> i must be getting my 'use' statements wrong or something
[23:48:40] <cmr> SiegeLord: the only language I know of larger than C++ is D :)
[23:48:40] <brson> aatch: do you mean performance-wise?
[23:48:54] <MaikKlein> I thought D should be easier than c++
[23:49:09] <heftig> D is not as large as C++
[23:49:18] <aatch> brson, no, I mean that you can write code that works, and then needs re-writing after a simple change.
[23:49:29] <aatch> Because it suddenly won't compile
[23:49:54] <heftig> C++ certainly has big compiler errors.
[23:50:01] <aatch> Not because of any problem with the language, but because certain features interact to cause it.
[23:50:09] <SiegeLord> Anyway... it's hard to compare, you need to write a spec for Rust first and then compare the number of pages 8)
[23:50:10] <brson> hm, I find that refactoring Rust is getting nicer and nicer as the ICE's decrease. just keep following the trail of compiler errors until it works again
[23:50:36] <aatch> I'm talking about discovering that you need to switch from ~ to @
[23:50:43] <SiegeLord> cmr, Yeah, D is huge and getting larger every day!
[23:50:54] <steveklabnik> rusti: FromStr::from_str("true")
[23:50:55] -rusti- foo.rs:5:9: 5:26 error: cannot determine a type for this bounded type parameter: unconstrained type
[23:50:55] -rusti- foo.rs:5          FromStr::from_str("true")
[23:50:55] -rusti-                   ^~~~~~~~~~~~~~~~~
[23:50:55] -rusti- note: in expansion of fmt!
[23:50:55] -rusti- foo.rs:4:12: 6:7 note: expansion site
[23:51:01] <brson> aatch: i see
[23:51:04] <steveklabnik> rusti: bool::from_str("true")
[23:51:05] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/MCTA
[23:51:06] <SiegeLord> cmr, That's why I'm following Rust now ;)
[23:51:09] <heftig> aatch: is that your blog?
[23:51:26] <aatch> heftig, I don't really have a blog.
[23:51:32] <doener> rusti: FromStr::<bool>("true")
[23:51:33] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/PMQY
[23:51:37] <aatch> Well I do, but nothing relating to rust
[23:51:55] <aatch> and very little anyway
[23:51:59] <doener> rusti: FromStr::from_str::<bool>("true")
[23:52:00] -rusti- Some(true)
[23:52:05] <steveklabnik> doener: ahhhhhh
[23:52:06] <steveklabnik> thank you!
[23:52:29] <doener> rusti: let x: bool; x = FromStr::from_str("false");
[23:52:30] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/CBPB
[23:52:55] <heftig> rusti: let x: Option<bool> = FromStr::from_str("true");
[23:52:55] <steveklabnik> gotta pattern match ;)
[23:52:56] -rusti- foo.rs:5:13: 5:14 warning: unused variable: `x` [-W unused-variable (default)]
[23:52:56] -rusti- foo.rs:5          let x: Option<bool> = FromStr::from_str("true");
[23:52:56] -rusti-                       ^
[23:52:56] -rusti- note: in expansion of fmt!
[23:52:56] -rusti- foo.rs:4:12: 6:7 note: expansion site
[23:53:00] <doener> rusti: let x: bool; x = FromStr::from_str("false").unwrap(); x
[23:53:01] -rusti- false
[23:53:03] <cmr> steveklabnik: no you don't!
[23:53:11] <cmr> steveklabnik: unwrap(), expect(), etc are very useful
[23:53:14] <steveklabnik> sure
[23:53:18] <steveklabnik> but they're less safe, no?
[23:53:28] <cmr> not always
[23:53:34] <cmr> they will fail!() if you use them incorrectly
[23:53:43] <steveklabnik> cool
[23:53:47] <cmr> but that's a good thing and probably what you expect
[23:53:51] <MaikKlein> hm everyone is using github.io for their blogs
[23:53:56] <steveklabnik> working on my second sunday in a row of 'contribute to rust's docs on sunday's
[23:53:57] <aatch> steveklabnik, yeah, but with bool, you could probably just use is_some()
[23:54:04] <steveklabnik> by cheating a bit and doing half of it on saturday ;)
[23:54:05] <cmr> MaikKlein: it's simple to use and has nice version control
[23:54:10] <doener> rusti: let x: bool; x = FromStr::from_str("b0rked").get_or_default(false); x
[23:54:11] -rusti- false
[23:54:31] <steveklabnik> aatch: makes sense. i'm writing docs though, so i need that function specifically
[23:54:40] <cmr> steveklabnik: btw, I don't know if the epub for rust for rubyists is out of date or something, but you have 0.5 syntax in a bunch of places, but you claim 0.6
[23:54:43] <aatch> steveklabnik, fair enough.
[23:54:52] <MaikKlein> do you have any bad experience with wordpress?
[23:54:57] <steveklabnik> cmr: yeah, i need to fix one or two things :( I dont know how that happened, i ran through the entire book on my own
[23:55:03] <heftig> rusti: let x: Option<()> = None; x.unwrap()
[23:55:04] -rusti- rust: task failed at 'option::unwrap none', /build/rust-incoming-git/src/rust/src/libstd/option.rs:291
[23:55:04] -rusti- rust: domain main @0x22911b0 root task failed
[23:55:17] <MaikKlein> i got this working in some minutes and it does it's job I think https://maik.herokuapp.com/
[23:55:19] <steveklabnik> cmr: i'll be fixing it up Real Soon Now
[23:55:32] <cmr> steveklabnik: awesome :)
[23:55:33] <aatch> MaikKlein, other than it having more security holes than a sieve?
[23:55:35] <heftig> hm, could you write this in one expression?
[23:55:39] <cmr> steveklabnik: if you need help feel free to PM
[23:55:45] <cmr> heftig: None.unwrap()
[23:55:50] <cmr> oops
[23:55:53] <cmr> rusti: None.unwrap()
[23:55:54] -rusti- error: internal compiler error: unexpected failure
[23:55:54] -rusti- note: the compiler hit an unexpected failure path. this is a bug
[23:55:54] -rusti- note: try running with RUST_LOG=rustc=1,::rt::backtrace to get further details and report the results to github.com/mozilla/rust/issues
[23:55:58] <cmr> heh
[23:56:00] <heftig> nope, needs type info
[23:56:06] <steveklabnik> cmr: if you're bored i can just give you access to the repo ;)
[23:56:16] <cmr> steveklabnik: sure!
[23:56:32] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[23:56:33] <cmr> MaikKlein: sure, but it requires hosting. github pages is free :)
[23:56:41] <doener> rusti: let x: int = None.unwrap();
[23:56:43] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/XYaD
[23:56:45] <MaikKlein> heroku is also free :)
[23:56:54] <MaikKlein> well
[23:56:59] <steveklabnik> cmr: assuming that you're cmr on github too, you've been added. it's just ReStructured Text, go nuts :)
[23:57:04] <doener> rusti: let _: int = None.unwrap();
[23:57:05] -rusti- rust: task failed at 'option::unwrap none', /build/rust-incoming-git/src/rust/src/libstd/option.rs:291
[23:57:05] -rusti- rust: domain main @0x16ae1b0 root task failed
[23:57:16] <MaikKlein> doesn't scale infinite though
[23:57:18] <cmr> steveklabnik: yup, thanks. I'll fix up some stuff later tonight. Do you want me to open PRs or just commit dirrectly?
[23:57:48] <heftig> doener: hm, without assigning a variable?
[23:57:56] <steveklabnik> just commit directly, it's cool
[23:58:01] <cmr> alright
[23:58:05] * cmr afk
[23:58:06] <aatch> heftig, nope, need type info

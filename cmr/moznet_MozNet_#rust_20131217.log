[00:02:19] *** Quits: pao (pao@moz-AF905E87.fbx.proxad.net) (Quit: pao)
[00:02:51] *** Joins: synackse (synackse__@moz-DFB8ED3B.lightspeed.wepbfl.sbcglobal.net)
[00:05:45] *** Quits: dherman (dherman@moz-BBE3ABD.mv.mozilla.com) (Quit: dherman)
[00:06:46] *** Joins: refold (gman@moz-42D68426.a258.priv.bahnhof.se)
[00:07:15] <Jarrett> dbaupp: hey, last night you mentioned that one way to work around the lack of Trait::<for Type>::func() was to do make the function take an Option<V>; could you give a little example of that? I'm not sure how to make it specialize on V in the impls
[00:07:34] <cmr> Jarrett: Trait::func(None::<V>)
[00:07:44] <Jarrett> no, the impl declarations
[00:07:47] <Jarrett> how do I write them?
[00:07:48] *** Quits: jvns (bork@87D98E32.4046EB22.428F94DD.IP) (Ping timeout)
[00:07:49] <cmr> Option<Self>
[00:07:54] <Jarrett> oh :o
[00:08:00] <cmr> impl Foo { fn func(_: Option<Self>) }
[00:08:27] <ktt3ja> what's the difference between self and Self?
[00:08:40] <dbaupp> Jarrett: http://static.rust-lang.org/doc/master/std/num/trait.Primitive.html
[00:08:47] <Luqman> ktt3ja: Self is the type implementing the trait
[00:08:48] <cmr> ktt3ja: Self is a type, `self` is a magic parameter, the receiver of the method call.
[00:08:56] <dbaupp> ktt3ja: Self refers to the type on the RHS of `impl Foo for ... {}`
[00:09:34] <ktt3ja> ah, thanks
[00:09:52] <Jarrett> coooooool, thanks dbaupp 
[00:10:03] *** Quits: voxpopuli (fanservice@moz-FE161659.wv.cc.cmu.edu) (Ping timeout)
[00:10:45] <dbaupp> Jarrett: and then an impl for looks something like `impl Primitive for i64 { fn bits(_: Option<i64>) -> uint { 64 } ... }`
[00:11:11] <Jarrett> right :) I've got it working now
[00:23:30] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[00:23:48] *** Quits: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net) (Quit: gavinb)
[00:24:56] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[00:26:57] <cmr> http://cmr.github.io/blog/2013/12/16/this-week-in-rust/
[00:27:25] *** Joins: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net)
[00:27:27] *** Quits: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net) (Quit: gavinb)
[00:28:31] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[00:29:06] <ChrisMorgan> pcwalton: wah, you didn't add `box` to the keywords lists of the various syntax highlighters :-(
[00:29:37] <Luqman> cmr: is that really the right link for "Attempting to implement private traits no longer works"?
[00:29:51] <cmr> nope
[00:30:45] <dbaupp> cmr: "only 2 typos" :P
[00:30:47] *** Quits: tcreate (tcreate@7C181A70.200CF5B8.9D2C3D3E.IP) (Client exited)
[00:31:02] <cmr> hey, that one is a logic error, not syntax ;p
[00:31:22] *** Joins: tcreate (tcreate@7C181A70.200CF5B8.9D2C3D3E.IP)
[00:31:25] *** Quits: eholk (eholk@moz-BA312F07.crest.iu.edu) (Quit: eholk)
[00:33:04] *** Quits: tcreate (tcreate@7C181A70.200CF5B8.9D2C3D3E.IP) (Ping timeout)
[00:33:05] <ChrisMorgan> cmr: given who's reading it, I think expanding acronyms like LTO is probably a good idea
[00:33:27] <eevee> i forgot it and had to look it up  :(
[00:33:31] *** Joins: Daniel_S (Daniel_S@moz-5B58D8B7.dhcp.snlo.ca.charter.com)
[00:33:55] <ChrisMorgan> And the two examples aren't semantically identical in "Struct pattern shorthand has been improved by allowing ref/mut, like let Foo { mut x, .. } = some_foo, rather than the previous let Foo { x: mut x } = some_foo." — one has ", .." and the other doesn't.
[00:34:28] <cmr> ChrisMorgan: nice catch, and I will.
[00:34:49] <dbaupp> cmr: also `static` is a keyword and a valid lifetime
[00:35:35] <cmr> hrmph
[00:37:51] <cmr> dbaupp: no it isn't!
[00:37:57] <cmr> pub fn foo<'static> () { }
[00:38:42] <dbaupp> &'static int
[00:39:20] <dbaupp> cmr: ^
[00:42:20] <ezyang> What did the old B/&self syntax use to mean? 
[00:42:38] <dbaupp> same as &'self B now
[00:42:45] <cmr> ezyang: &'self B, I think... that's what it meant for non-self things, at least.
[00:43:00] *** Joins: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net)
[00:43:02] <dbaupp> (modulo the self lifetime being non-special now (and, indeed, illegal.))
[00:43:07] <ezyang> OK, but this was back when 'self was a special lifetime, right? 
[00:43:25] <ezyang> right 
[00:43:57] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[00:45:22] *** Quits: trecer (trecer@moz-36BEFC79.hsd1.pa.comcast.net) (Quit: Computer has gone to sleep.)
[00:45:42] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Ping timeout)
[00:46:02] *** Joins: Krymise (Nietzsche@moz-CA789EF5.nwrknj.fios.verizon.net)
[00:46:57] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[00:49:30] *** Joins: eholk (eholk@moz-F70D5031.hsd1.in.comcast.net)
[00:49:53] *** Joins: ianj (ianjneu@moz-7BA002E.hsd1.ma.comcast.net)
[00:50:11] *** Quits: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net) (Quit: gavinb)
[00:50:30] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[00:51:08] *** Quits: ktt3ja (ktt3ja@moz-54586A12.washdc.fios.verizon.net) (Quit: Leaving)
[00:53:10] *** Joins: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net)
[00:56:27] *** Quits: bytewise (bytewise@moz-6F896CFA.adsl.alicedsl.de) (Quit: Leaving)
[01:00:39] <ezyang> lol so many borrowck bugs 
[01:01:58] *** Quits: hoverbear (hoverbear@EBFA78B5.F19E5E7B.E74D50F2.IP) (Quit: Hibernating, be back soon.)
[01:03:36] *** Quits: Daniel_S (Daniel_S@moz-5B58D8B7.dhcp.snlo.ca.charter.com) (Quit: This computer has gone to sleep)
[01:04:47] *** Jarrett is now known as Jarrett|Away
[01:05:47] <strcat> ezyang: limitations aren't really bugs
[01:05:58] <strcat> could spend ages adding special cases
[01:07:05] <ezyang> Yeah, it's just like type inference in dependently typed languages 
[01:07:18] <ezyang> Except that if the borrowck says "no", you can't go back and manually annotate teh types 
[01:09:24] *** Quits: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net) (Quit: gavinb)
[01:11:51] *** Joins: tcreate (tcreate@7C181A70.200CF5B8.9D2C3D3E.IP)
[01:11:53] *** Joins: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net)
[01:12:30] *** Quits: echristo (echristo@A2012DB6.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[01:14:15] *** Joins: AvianFlu (AvianFlu@974D245D.130DDD13.67CD788C.IP)
[01:14:29] *** Quits: canhtak (canhtak@moz-258236CD.wl.t.ulaval.ca) (Quit: canhtak)
[01:16:15] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[01:18:48] *** Joins: jmgrosen (jmgrosen@C2CB60D0.5A282F70.284344F5.IP)
[01:21:04] <ezyang> Looking at some old code that has arr : &mut ~[int], and then calls 'for arr.each |j| { ... }'. How do I spell this in new Rust? 
[01:21:50] <ChrisMorgan> for j in arr.iter() { ... }
[01:21:54] *** Quits: bjustin (bjustin@moz-8FC28563.sierrabravo.net) (Quit: Textual IRC Client: www.textualapp.com)
[01:22:16] <ezyang> thanks 
[01:25:14] <ezyang> Fuh, I don't understand niko's explanation of https://github.com/mozilla/rust/issues/6613 
[01:25:45] *** Quits: jmgrosen (jmgrosen@C2CB60D0.5A282F70.284344F5.IP) (Quit: jmgrosen)
[01:26:24] <ezyang> His claim seems to imply that iter() with an empty loop body would still trigger the borrowck, but it does not 
[01:29:38] <ChrisMorgan> ezyang: iter with an empty body wouldn't trigger the error because you're not trying to take the reference outside the function.
[01:30:29] <ezyang> How does Rust determine that you are "taking a reference outside of the function"? 
[01:30:30] <ChrisMorgan> ezyang: that issue should be considered completely obsolete now, because we no longer have aliasing.
[01:30:55] <ChrisMorgan> Returning it.
[01:31:14] <ezyang> So, passing it to another function doesn't count? 
[01:31:29] <ChrisMorgan> Passing it to another function is fine, because the scope is smaller.
[01:31:35] <ezyang> ChrisMorgan: Well, the code in question still doesn't borrow-check, so I'm going to put it in my tutorial 
[01:31:40] <ezyang> ah! 
[01:31:43] *** Quits: ianj (ianjneu@moz-7BA002E.hsd1.ma.comcast.net) (Quit: leaving)
[01:31:51] <ChrisMorgan> It's all to do with what the scope of the borrow is.
[01:32:58] <ezyang> OK, I think I understand now 
[01:33:40] <ezyang> ...hang on, so why is the return &arr[j] variant ok? 
[01:33:48] *** Joins: LU324 (weechat@9AF4F288.83671C58.1B5D53D7.IP)
[01:34:24] <ezyang> is it because 'return lvalue' is privileged? 
[01:35:45] <ChrisMorgan> It can be borrowed with the lifetime 'r, whereas by writing it locally with the likes of `let p = ...` you have constrained it down to that block's scope.
[01:35:59] *** Quits: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net) (Quit: gavinb)
[01:37:21] <ezyang> So... it is different to say that "this has lifetime 'r" and "this has lifetime of the block's scope" (in this specific example?) 
[01:37:58] <ezyang> also, why isn't the relevant block just the while { ... } block? Sorry, I don't understand. 
[01:39:05] <ChrisMorgan> I'm not certain of the validity of certain of nmatsakis' points there; the language has changed somewhat since then in such areas. He would be able to give you more coherent and correct answers than I.
[01:42:35] *** Joins: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net)
[01:43:57] *** Quits: AvianFlu (AvianFlu@974D245D.130DDD13.67CD788C.IP) (Connection reset by peer)
[01:44:20] *** Joins: AvianFlu (AvianFlu@974D245D.130DDD13.67CD788C.IP)
[01:56:09] <mrmonday> is there some trick to make rust compile faster? seems to take forever to make tiny changes (one or two lines changed of stdlib and I have to wait 20 minutes before I can test :s)
[01:57:08] <dbaupp> mrmonday: `make check-stage1-std NO_REBUILD=1`
[01:57:27] <dbaupp> that will just build the libstd test runner without doing a full bootstrap
[01:58:11] <dbaupp> and you can even pass TESTNAME=foo to filter which tests are run (and NO_BENCH=1 to avoid running the benchmarks.)
[01:58:19] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Client exited)
[01:58:19] <dbaupp> https://github.com/mozilla/rust/wiki/Note-testsuite
[01:58:57] <mrmonday> what about just building the libs, no test runner?
[01:59:41] <dbaupp> if you have a recent-enough rustc, just running rustc on std's lib.rs should work
[02:00:01] <mrmonday> running on master, I'll give it a shot
[02:00:26] <mrmonday> I imagine that won't put the libs in the same place though without some flags?
[02:00:48] <dbaupp> yes, that'll just put them in the src/libstd foler
[02:00:50] <dbaupp> *folder
[02:07:12] *** Joins: pradeep (pradeep@5AB4884B.FCC4549.14D5B978.IP)
[02:14:30] *** Quits: AvianFlu (AvianFlu@974D245D.130DDD13.67CD788C.IP) (Connection reset by peer)
[02:14:39] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[02:18:01] *** Quits: TimAbraldes (quassel@125EF623.B2666F0E.66399531.IP) (Input/output error)
[02:18:17] *** Joins: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net)
[02:25:56] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[02:31:13] <rntz> are anonymous struct wrappers ("struct Wrap(T);") *supposed* to inherit their wrapped type's impls? 
[02:31:33] <rntz> because that seems to be what's happening in my code and it's making me worry.
[02:33:34] <dbaupp> rntz: they get auto-deref'ed like pointers
[02:33:53] <dbaupp> they don't actually implement the various traits
[02:34:45] <rntz> okay. so outside the module, if they're not "pub", that won't happen, because they won't be auto-derefed, right?
[02:35:06] <dbaupp> don't know
[02:35:38] <dbaupp> you can guarantee it with `struct Wrap { priv x: T }`
[02:36:53] <Yurume> rusti: struct v((uint,uint)); v((3,4))._n1()
[02:36:54] -rusti- failed to pastebin 7 lines of output
[02:37:01] <Yurume> rusti: struct v((uint,uint)); v((3,4)).n1()
[02:37:02] -rusti- 4u
[02:37:05] *** Joins: canhtak (canhtak@moz-258236CD.wl.t.ulaval.ca)
[02:37:13] <Yurume> rusti: struct v { x: (uint,uint) } v{x:(3,4)}.n1()
[02:37:13] -rusti- failed to pastebin 7 lines of output
[02:37:22] <Yurume> visibility does not matter.
[02:38:12] *** Quits: eholk (eholk@moz-F70D5031.hsd1.in.comcast.net) (Quit: eholk)
[02:38:31] *** Quits: jdm (jdm@moz-AC9499B2.cable.teksavvy.com) (Quit: Lost terminal)
[02:38:31] <rntz> hm?
[02:39:25] <Yurume> ...ah I got the question backwards
[02:39:45] *** Quits: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com) (Quit: Jesse)
[02:41:03] <Yurume> I'm not sure whether the visibility check comes after the method resolution or not, but it will cause an error in both cases
[02:43:02] *** Joins: eholk (eholk@moz-F70D5031.hsd1.in.comcast.net)
[02:44:23] *** Joins: AvianFlu (AvianFlu@974D245D.130DDD13.67CD788C.IP)
[02:47:05] <dbaupp> strcat: https://github.com/thestinger/rust-core/commit/a5262f0d2ddeafb4e96465178973ee6f6710475b#diff-6fb2ad1c3339530254ddd9f59fa3733aR63 infinite loop
[02:47:47] <dbaupp> (well, infinite recursion)
[02:47:49] <strcat> right
[02:50:52] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[02:51:41] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.2)
[02:54:00] <rntz> is there a reason rust-mode thinks "_" is a word-char?
[02:59:45] *** Joins: klutzy (th@BA61F396.8E859986.ECA1BB11.IP)
[03:00:54] *** Quits: Dessimat0r (Dessimat0r@3258E608.E588CE06.9A579328.IP) (Ping timeout)
[03:01:33] <ezyang> unwrap really ought to be called unsafe_unwrap :-( 
[03:02:50] *** Quits: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net) (Quit: gavinb)
[03:03:39] <Yurume> uh, why?
[03:03:53] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[03:03:57] <Yurume> (it safely fails, if that's your concern)
[03:03:59] <ezyang> ON things like Option, it's partial! 
[03:04:03] <Yurume> it may safely fail*
[03:04:09] <ezyang> maybe unsafe is the wrong word 
[03:04:23] *** Joins: Dessimat0r (Dessimat0r@3258E608.E588CE06.9A579328.IP)
[03:04:30] <Yurume> get_despite_warningf
[03:04:58] *** Quits: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com) (Quit: pcwalton)
[03:05:57] <rntz> ezyang: I don't think there exists a standard term in rust for "dangerous, may fail". in my admittedly-limited experience, unwrap is too useful to warrant a longer name...
[03:06:36] *** Quits: eholk (eholk@moz-F70D5031.hsd1.in.comcast.net) (Quit: eholk)
[03:06:50] * rntz hacking on a data structure which uses Option<~blah> heavily with a bunch of non-typesystem-checked invariants on when things can be None
[03:06:52] <ezyang> rntz: unwrap is pretty useful for working around borrowck. This is not the same as "it should be used, in an ideal world" 
[03:07:14] <rntz> I don't think arguments from an ideal world are applicable to rust.
[03:07:19] <Yurume> it is also useful for quick and dirty(tm) jobs
[03:07:33] <strcat> anything may abort since out-of-memory and out-of-stack will abort
[03:07:50] <rntz> (indeed, I am skeptical of them in general, but *definitely* when applied to rust. I can understand them when applied to haskell, sml, agda ,etc.)
[03:08:08] <ChrisMorgan> rntz: re. rust-mode, ask dbaupp, he uses emacs.
[03:08:30] <rntz> strcat: okay, but that's very different from "calling this function might fail my program in perfectly ordinary conditions"
[03:08:44] <strcat> you might run out of stack or memory in perfectly normal conditions
[03:08:46] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[03:09:04] <rntz> look, you know what I mean.
[03:09:09] <strcat> I don't, really
[03:09:13] <strcat> I don't see anything wrong with `get`
[03:09:22] <strcat> the compiler can't validate all possible invariants
[03:09:44] <ezyang> Well, do you agree with Hoare when he calls NULL pointers his million dollar mistake? 
[03:10:12] <strcat> ezyang: nullability where you don't want nullability is a big mistake
[03:10:22] <strcat> nullability isn't a good default
[03:10:34] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Ping timeout)
[03:10:44] <strcat> having a `get` function on an explicitly opt-in nullable type isn't a mistake
[03:10:45] <Yurume> NULL pointers are dangerous since you cannot forbid NULL picking into the pointer you expect not to contain NULL
[03:11:02] <rntz> "the compiler can't validate all possible invariants" is not an argument for not being clear about invariants! "this could always go wrong with your code" isn't an argument for not paying attention to other ways your code could go wrong.
[03:11:04] <Yurume> I think "informed" nullable pointers are fine (e.g. Sing#)
[03:11:15] <strcat> rntz: so how can you be more clear about the invariants?
[03:11:31] <ezyang> by cooperating with the type system to just not ever have a null dereference 
[03:11:31] <rntz> I'm not arguing that unwrap should be renamed - I think it shouldn't. but it's not a completely baseless argument, which is what you seem to be claiming.
[03:11:39] <rntz> strcat: "unsafe_"
[03:11:43] <strcat> it's not unsafe
[03:11:48] <strcat> it's not even bad practice
[03:11:51] <rntz> "partial_"
[03:12:02] <strcat> rntz: so lets remove vector indexing too
[03:12:07] <strcat> and slice, slice_from, slice_to
[03:12:28] <strcat> vector indexing is far more pervasive than unwrap on Option
[03:12:31] *** Quits: ziad (ziad@B20586FB.BDB3D91.6E370BFC.IP) (Quit: ziad)
[03:12:33] *** Quits: sellout (Adium@moz-AE26682A.hlrn.qwest.net) (Ping timeout)
[03:12:59] <rntz> now *that's* an actual argument.
[03:13:07] *** Joins: ziad (ziad@B20586FB.BDB3D91.6E370BFC.IP)
[03:13:15] <strcat> it's me making a strawman, I don't expect anyone to think we should remove vector indexing
[03:13:22] * strcat shrugs
[03:13:30] *** Quits: ziad (ziad@B20586FB.BDB3D91.6E370BFC.IP) (Quit: ziad)
[03:13:59] <strcat> anyway rust's type system just isn't powerful enough to provide alternatives to abort/fail in branches you know can never happen
[03:14:08] <strcat> if you make it painful to do, writing rust will be painful
[03:14:27] <strcat> try writing a tree containing types you can't clone
[03:14:37] <strcat> you need lots of swaps and unwraps
[03:14:47] <rntz> that is in fact what I am doing right now.
[03:15:02] <ezyang> I think this overstates the difficulty of abiding with the type system in common cases 
[03:15:15] <strcat> I don't think it does
[03:15:27] <rntz> ezyang: I think that depends heavily what your common cases are.
[03:15:30] <strcat> I'd like to see someone write a balanced binary search tree without a Clone bound and without dozens of unwraps/swaps
[03:15:54] <strcat> or really any recursive data structure like that
[03:16:02] <ezyang> strcat: Using owned pointers? 
[03:16:06] <strcat> yes
[03:16:07] <ezyang> I'd take up your challenge on that... 
[03:16:16] <rntz> strcat: it's not that hard to do that if you don't mind allocating all over the place, which I think is how ezyang is going to do it.
[03:16:22] <strcat> using owned pointers and without being able to clone the key/value types
[03:16:30] *** Quits: Dessimat0r (Dessimat0r@3258E608.E588CE06.9A579328.IP) (Ping timeout)
[03:16:39] *** Joins: sellout (Adium@moz-AE26682A.hlrn.qwest.net)
[03:16:40] <rntz> it's the natural way to do it if you think in a linear-logic-like way...
[03:16:54] <strcat> rntz: then he's not doing what I'm suggesting
[03:17:08] <rntz> hwat?
[03:17:08] <ezyang> rntz: What kind of extra allocations am I going to do? (I haven't worked it out far enough, but it seems like it should be possible) 
[03:17:27] <o11c> strcat: I've written trees in C++ using unique_ptr
[03:17:28] <strcat> rntz: types that can be cloned are a special case, generic containers avoid a clone bound
[03:17:41] <rntz> strcat: not copies, allocations
[03:18:06] <strcat> o11c: obviously I'm not saying you can't do it, I've written several trie/rbtree variants in rust
[03:18:07] <rntz> match node { ~Leaf(x) => ..., ~Node(l,r) => { ... ~Node(newl, newr) ... } }
[03:18:12] <strcat> with safe code, and without a Clone bound on the keys/values
[03:18:42] <ezyang> rntz: I think you ought to be able to do it via mutation too 
[03:18:46] <rntz> you just destructure the things so you own the data, and construct the new value.
[03:18:59] <ezyang> The biggest problem is the borrowck 
[03:19:06] <rntz> ezyang: without std::util::swap or std::util::replace? good luck.
[03:19:09] <rntz> yes, and the borrowck is an enormous problem.
[03:19:14] <ezyang> Oh, well, I'd use replace 
[03:19:21] <ezyang> Is there anything wrong with that? 
[03:19:35] <strcat> not very efficient
[03:19:40] <rntz> I mean, I think what strcat was claiming is you end up having to do that a bunch. maybe we are in agreement at this point?
[03:19:54] <strcat> rust's TreeMap is 3x slower than the same thing written with unsafe code
[03:20:02] <strcat> for insert/remove
[03:20:05] <ezyang> No, I don't understand, replace doesn't require a Clone trait 
[03:20:12] *** Joins: Dessimat0r (Dessimat0r@3258E608.E588CE06.9A579328.IP)
[03:20:13] <strcat> ezyang: doesn't make it fast...
[03:20:33] <Yurume> swapping is slower than doing nothing, which seems to be strcat's main point
[03:20:43] <strcat> in order to avoid the Clone bound, you'll need swap, replace or lots of unwrapping
[03:21:16] <ezyang> Why is swap() so slow? 
[03:21:31] <strcat> ezyang: it's not 'so slow'
[03:21:31] <rntz> it copies bytes
[03:21:34] <strcat> it's slower than not swapping
[03:21:45] <strcat> doing 100000 swaps is a lot slower than doing 0 swaps
[03:22:05] <strcat> the vector move iterator used to use safe code + swaps, now it uses unsafe code
[03:22:07] <ezyang> Mmm, but you were going to need to mutate anyway, right? 
[03:22:08] <strcat> and is significantly faster
[03:22:24] <strcat> ezyang: a swap is a lot more work than the mutation you actually want to do
[03:22:28] <o11c> strcat: I'm not sure exactly what the problem is with doing it safely ... when I last did it, there was very little unsafe C++ code
[03:22:54] <o11c> strcat: are you talking about a tree with parent pointers or without? I'm only familiar with writing trees *with* parent pointers
[03:22:56] <ezyang> I've been playing around with this in the simple setting of singly linked lists 
[03:23:02] <strcat> o11c: again, there isn't a problem with doing it safely
[03:23:25] <strcat> you can't say 'little unsafe C++', it doesn't enforce safely so you are free to do a lot of stuff you can't in rust
[03:23:28] <rntz> I've been writing finger trees in rust, and IME strcat seems to be right about needing lots of swaps/unwraps
[03:23:30] <strcat> moves are a lot more flexible than rust moves
[03:24:02] <ezyang> and I used a replace per actual mutation I wanted to do 
[03:24:11] <ezyang> And I'm sure you could make things more efficient by having a three-way swap 
[03:24:15] <strcat> o11c: so, from the start, what I am saying
[03:24:37] <strcat> in order to write an owned, mutable tree in rust without a Clone bound on the key/values, you need a lot of inefficient swaps/replaces/unwraps *or* you need unsafe code
[03:24:59] <o11c> I'll try to port my C++ code sometime, see how it goes
[03:25:02] <rntz> I really wish rust's borrowck was better able to check cases where you move out of a nontrivial data structure to construct its new value...
[03:25:24] <strcat> and if you make the language more opinionated around stuff like unwrap, it becomes much more painful to work in the restricted safe type system
[03:25:24] *** Quits: AvianFlu (AvianFlu@974D245D.130DDD13.67CD788C.IP) (Connection reset by peer)
[03:25:30] <strcat> because it doesn't know a lot of things you do
[03:25:39] <strcat> and it makes you write a lot of redundant operations
[03:25:40] *** Joins: AvianFlu (AvianFlu@974D245D.130DDD13.67CD788C.IP)
[03:25:57] <strcat> using unwrap is a lot faster than using a swap, and is often possible
[03:26:44] <strcat> if I wrote an rbtree/b-tree in rust again I would just use unsafe code from the start - there's no point of a slow generic container
[03:27:47] <Yurume> except when you are concerned with better average time performance
[03:27:58] <rntz> Yurume: explain?
[03:28:14] <strcat> Yurume: TreeMap written with unsafe code has 3x faster insert/remove on average
[03:28:19] <ezyang> Why does this not just mean that the optimizer needs to get better? 
[03:28:23] <rntz> ... having to use unsafe code to get good performance out of a data structure is slightly saddening. I had hoped data structures would be one of the areas Rust would be much nicer for writing things in than C.
[03:28:28] <strcat> ezyang: because compilers don't work that way
[03:28:32] <strcat> there's a limit to what it can do
[03:28:40] <Yurume> rntz: some algorithms and/or data structures may perform slower in the best case and faster in the average case due to the complexity difference
[03:28:41] <rntz> uh, be careful with assertions about how good a compiler can get
[03:28:44] <strcat> if you want it to optimize better, you need to teach it more *and* give it more information
[03:29:21] <Yurume> but that seems a bit off-topic
[03:29:25] <ezyang> ==rntz comment about needing unsafe code for good performance 
[03:29:32] <ezyang> Yurume: Yeah, I think it's off-topic here. 
[03:29:37] <strcat> ezyang: you need unsafe code for good performance in many cases
[03:29:46] <strcat> and an optimizer isn't going to make for it
[03:29:57] <strcat> 5 years from now or 10 years from now, it's not going to be able to undo the mess you've made
[03:30:10] <strcat> because the reason it can't undo it is an inability to prove that the optimizations are safe
[03:30:25] <strcat> it would have to understand the proof of an rbtree being correct
[03:30:31] <rntz> Yurume: what do you mean by "complexity difference"? aiui, you are asserting that writing your code without using the unsafe operations may result in higher best-case performance for some reason? 
[03:30:35] <Yurume> strcat: I think it's important to distinguish "good enough" performance from "good" (or rather, "close to optimal") performance
[03:30:35] <ezyang> Do you guys mind talking about a concrete case? Here is a simple "safe pop off the front element of a list": https://gist.github.com/ezyang/7999613 
[03:30:52] <strcat> Yurume: 3x slower map is not good enough for any definition of good enough
[03:30:54] *** Joins: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net)
[03:31:10] <strcat> if a generic container is that slow, no one will use it
[03:31:14] <ezyang> The two replaces correspond to the two pointer mutation you need to do (null out the tail pointer on the front cell, mutate the head of list pointer) 
[03:31:14] <rntz> strcat: uh, a compiler doesn't have to understand the full proof of correctness of your code to notice that "hm, I can optimize this copy into an in-place operation" in many cases
[03:31:16] <strcat> they will use a better implementation with unsafe code
[03:31:31] <strcat> rntz: not talking about 'many cases'
[03:31:37] <strcat> talking about a recursive tree data structure
[03:31:48] <strcat> and the specific workarounds you need in rust to prove it as safe
[03:31:56] <strcat> they are not possible for LLVM to optimize out at all
[03:31:56] <Yurume> strcat: map without a good hash function (yeah, I know Rust uses SipHash, but for the purpose of this discussion) will perform better in many cases and still perform horribly on degenerate cases
[03:32:07] <rntz> strcat: if you're making a specific assertion like that, you should have a specific example 
[03:32:10] <strcat> Yurume: not talking about hash tables here...
[03:32:18] <strcat> rntz: okay, again, example: TreeMap
[03:32:21] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[03:32:21] <strcat> 3x slower insert/remove
[03:32:25] <strcat> because of the workarounds
[03:32:31] <strcat> TrieMap is also slower
[03:32:39] <rntz> ... that is not an example of why you assert that compiler optimizations to remove copies are impossible
[03:32:43] <ezyang> strcat: The problem is, I have no idea if that's because TreeMap was written stupidly, and there's a better way of writing it 
[03:32:44] <Yurume> ah, hash table, okay, but I meant "3x slower map" may be justifiable depending on the situation
[03:32:49] <ezyang> one which uses different primitives, etc 
[03:32:57] <rntz> that is an example of rustc/llvm not doing it.
[03:32:59] <strcat> rntz: I'm not sure how it's going to be possible... pointers can alias
[03:33:07] <strcat> rntz: no, it's an example of a hard problem that's not feasible to fix
[03:33:21] <Yurume> not that I'm not advocating unsafe codes in the container implementations
[03:33:22] <ezyang> To rephrase a little bit, unsafe code will be inevitable (replace is essential, after all), but what you want is small, reusable functions which are provably correct 
[03:34:01] <rntz> you are not giving a specific example of a piece of code you think is impossible for a compiler to optimize without a significant nonlocal proof about your code.
[03:34:15] <strcat> rntz: swaps in TreeMap
[03:34:17] <ezyang> I think of 'replace' as fitting in this category, but not the update function for a red-black tree 
[03:34:26] <strcat> swap out a node, swap it back in
[03:34:28] <strcat> LLVM can't optimize it out
[03:34:48] <strcat> in a very rare few situations it can
[03:34:51] <ezyang> Rust is eventually going to grow an optimizer of its own, right? 
[03:35:08] <strcat> ezyang: doubt it, there's not much information rust has that we can't communicate to LLVM
[03:35:10] * Yurume afk
[03:35:11] <rntz> swap out a node, mutate it, swap it back in? why is it impossible to safely optimize that into an in-place operation without nonlocal knowledge?
[03:35:22] <rntz> I'm not asking whether LLVM can do it. you made a very strong claim: that *no* compiler could reasonably do it.
[03:35:26] <ezyang> isn't this swap exactly one of those cases? 
[03:35:28] <ChrisMorgan> Indeed, why would it need to?
[03:35:37] <strcat> rntz: because it has no idea which other pointers alias that node
[03:35:51] <strcat> it has no idea where unwinding might happen too, because of all these unwrap calls
[03:35:54] <ezyang> In GHC, we have lots of optimizations that cannot reasonably be done at the LLVM level, and have to be done earlier 
[03:35:57] <rntz> strcat: is it not uniquely owned?
[03:36:04] <strcat> rntz: uniquely owned != can't alias 
[03:36:19] <rntz> strcat: If I have an (x: ~T), that pointer cannot alias, no?
[03:36:27] <strcat> rntz: it can alias other pointers
[03:36:29] <strcat> plenty of ways
[03:37:01] <strcat> there's a difference between language semantic level aliasing and real aliasing
[03:37:18] <strcat> ezyang: like C, rust pretty much maps to LLVM's model already
[03:37:26] <rntz> 22:37 < strcat> there's a difference between language semantic level aliasing and real aliasing
[03:37:31] <strcat> ezyang: it doesn't have an effects system or any form of purity
[03:37:33] <rntz> isn't that just supporting
[03:37:34] <rntz> 22:35 < ezyang> In GHC, we have lots of optimizations that cannot reasonably be done at the LLVM level, and have to be done earlier
[03:37:44] <strcat> rntz: no
[03:37:46] <rntz> like, llvm can't do it because it doesn't know about aliasing, sure, but that doesn't mean it's impossible
[03:37:51] <rntz> it's because you're throwing away information.
[03:38:05] <strcat> LLVM can be told about any aliasing guarantees
[03:38:21] <strcat> it's still not going to be able to optimize this kind of thing in most cases, rust doesn't have strong enough guarantees
[03:38:39] <rntz> explain how an (x: ~T) can alias?
[03:38:50] <ezyang> strcat: Curious: is find() on safe TreeMap slower than unsafe TreeMap? 
[03:38:54] <strcat> ezyang: no
[03:39:01] <ezyang> ok, that's good to hear 
[03:39:10] <strcat> ezyang: rust is good at immutable stuff
[03:39:19] <strcat> it's with mutable stuff where the painful issues happen
[03:39:31] <strcat> since you can have any number of aliasing & ptrs
[03:39:59] <rntz> if I'm passed an (x: ~T) as an argument to my function, am I not guaranteed that are no active borrows of it when I'm called?
[03:40:11] <strcat> rntz: a parameter doesn't alias other parameters or other data
[03:40:17] <strcat> we mark ~ parameters as noalias already, though
[03:40:27] <strcat> it's more complex in the actual body of the function
[03:41:22] <ezyang> strcat: So, IIUC, skew/split are the perf killers for mutable insert 
[03:41:34] <strcat> ezyang: well and insert itself does a swap or something iirc
[03:41:36] <rntz> the body of a function is local knowledge; I don't see any theoretical obstacle to reasoning about aliasing there. again, still not seeing any fundamental reason this problem is intractable, just "Rust+LLVM can't do it"
[03:41:43] <strcat> ezyang: I rewrote it several times to minimize it though
[03:41:56] <ezyang> strcat: Nah, I'm looking at it right now and it doesn't 
[03:42:10] <strcat> rntz: well for one thing rust's version of immutability still allows mutation
[03:42:12] <rntz> I think "this can't be done without a lot of work on optimizing compilers" is a pretty strong argument, but I get slightly annoyed when people claim that something is Hard when it's merely hard.
[03:43:12] <strcat> rntz: if you start working hard at optimizing low-level bits of code by learning how the LLVM optimization passes work, your opinion on the reality of optimizing compilers will change
[03:43:25] <strcat> what they actually do in practice is *far* less than what most people seem to expect
[03:43:59] <strcat> it's very hard to deal with pointer aliasing and to do all of that pointer induction stuff
[03:44:34] <strcat> if you had infinite compile-time, you could do a lot more analysis
[03:44:44] <strcat> LLVM has really, really minimal alias analysis and memory dependency analysis
[03:44:50] <strcat> it's ridiculously bad, because it needs to be fast
[03:45:04] <strcat> even if you communicate a massive amount of aliasing data, the optimization passes destroy it all as they go
[03:45:31] <ezyang> ...that's why you do the optimizations that require aliasing data before you do the general purpose optimizations 
[03:45:51] <strcat> you can't get to the optimizations requiring other stuff before doing inlining, etc.
[03:46:17] <ezyang> Well, even in Haskell, inlining is something you have to do very early on 
[03:46:21] <strcat> ezyang: remember that rust has no purity/effects....
[03:46:32] <strcat> you learn about what the code does as you optimize
[03:46:49] <strcat> haskell has high-level information up-front, rust doesn't
[03:47:07] <strcat> the optimization passes have to piece together the high-level logic of the code
[03:47:34] <strcat> rust is like C++ in that it's library-heavy, and the language doesn't have very many guarantees at all
[03:47:36] *** Quits: Earnestly (earnest@88884C6.A3735F9C.39C00A7A.IP) (Ping timeout)
[03:47:56] <strcat> rust doesn't have a language-level concept of a sequence you can iterate over
[03:48:13] *** Joins: Jesse (jruderman@moz-9754CB0.hsd1.ca.comcast.net)
[03:48:15] <strcat> it doesn't have a concept of pure functions, 'true' immutability (beyond statics), etc.
[03:48:35] <strcat> rusti: let x = ~5; let y = x; y
[03:48:37] -rusti- ~5
[03:48:51] <strcat> `x` is immutable (at a language level) but was mutated there
[03:48:56] <strcat> although rust is moving towards analysis for that
[03:49:16] <rntz> uh, how was x mutated there?
[03:49:21] <strcat> rntz: it was zeroed
[03:49:30] <ziad> because it was borrowed out of
[03:49:31] <strcat> atm rust doesn't really track moves very well, and they are a pretty big performance issue - so yes, since moves are a language feature it can do analysis
[03:49:36] <strcat> ziad: not borrowed
[03:49:40] <ziad> moved*
[03:49:41] <ziad> :)
[03:49:49] <strcat> rntz: atm a move has to zero the source
[03:49:56] <strcat> the destructor then checks if it was zeroed
[03:49:56] <rntz> ah. you're not talking about rust, you're talking about the llvm that rust generates.
[03:50:02] <rntz> *that* x was mutated. x wasn't.
[03:50:03] <strcat> rntz: but it is about rust
[03:50:10] <strcat> rntz: rust doesn't track moves 100%
[03:50:17] <strcat> it doesn't know it can avoid a dtor call
[03:50:19] *** Joins: vk (chatzilla@moz-4F2E17BF.dsl.dynamic.sonic.net)
[03:50:22] <rntz> explain?
[03:50:24] *** vk is now known as vky
[03:50:49] <strcat> rntz: rust doesn't have a concept of whether something has been moved from and the dtor can be omitted atm
[03:51:02] <strcat> changing this requires backwards incompatible language changes
[03:51:06] <strcat> which are likely going to happen
[03:51:09] <rntz> interesting.
[03:51:19] <strcat> rntz: for example, atm you can move from something in one branch
[03:51:21] <strcat> but not in another
[03:51:38] <strcat> so rust only tracks whether something was *maybe* moved from, to prevent use-after-move
[03:52:01] <rntz> ah, and somehow dynamically determines whether it was *actually* moved from and needs a dtor called?
[03:52:03] <strcat> rntz: also atm you can write code moving from somewhere by zeroing the source, and then having the dtor run on the source
[03:52:08] <strcat> rntz: yes
[03:52:16] <strcat> destructors check if the value was moved from
[03:52:17] *** Joins: jdm (jdm@moz-AC9499B2.cable.teksavvy.com)
[03:52:17] *** ChanServ sets mode: +o jdm
[03:52:23] <strcat> so the ~T dtor checks if it is null
[03:52:27] <strcat> custom dtors add a 'drop flag'
[03:52:44] <strcat> unless you use #[unsafe_no_drop_flag] and add a check yourself (it will zero the whole thing, instead of just the drop flag)
[03:52:50] <rntz> okay. that doesn't seem like an insurmountable problem, though. surely you can determine at compiletime which branches moved out of it, and have the branches that didn't invoke the dtor.
[03:53:16] <ezyang> Wow, owned pointers sound like they're implemented really inefficiently 
[03:53:21] <strcat> rntz: it could omit a lot of these checks, but not all
[03:53:34] <strcat> and because you can't omit all, you still need drop flags making types with custom dtors larger
[03:53:34] <rntz> ezyang: ?
[03:53:37] <strcat> ezyang: they really aren't
[03:53:40] <strcat> they're implemented like C++
[03:53:52] <strcat> ~5 calls malloc and branches on null to abort on OOM
[03:53:54] <strcat> the dtor calls free
[03:53:54] <rntz> strcat: you can't omit all of them because?
[03:53:58] <strcat> moving from it zeroes it
[03:54:05] *** Joins: steveno (steveno@moz-2B2BE86F.hsd1.pa.comcast.net)
[03:54:12] <strcat> rntz: because you can do this
[03:54:23] <strcat> rusti: let x = ~5; if true { let y = x; }
[03:54:28] -rusti- out.rs:9:34: 9:35 warning: unused variable: `y`, #[warn(unused_variable)] on by default
[03:54:29] -rusti- out.rs:9         let x = ~5; if true { let y = x; }
[03:54:29] -rusti-                                            ^
[03:54:29] -rusti- timeout triggered!
[03:54:30] <strcat> where `true` is a dynamic condition
[03:54:46] <strcat> so currently, the semantics are that `x` is destroyed at the end of the scope
[03:54:49] <rntz> that's fine. the else-branch calls the dtor.
[03:54:50] <strcat> unless you move from it in that branch
[03:54:55] <rntz> fix the semantics.
[03:55:00] <strcat> rntz: that would be a backwards incompatible change
[03:55:04] *** Quits: blank_name (blank_name@8DB1FDC4.16360A46.537E532E.IP) (Quit: leaving)
[03:55:06] <ezyang> "~5 calls malloc and branches on null to abort on OOM" <-- that's a lot of overhead! 
[03:55:10] <strcat> so now you're saying 'change the language' rather than 'make the optimizer better' ;p
[03:55:15] <rntz> yes.
[03:55:16] <strcat> ezyang: not really
[03:55:19] <strcat> ezyang: what else would it do?
[03:55:24] <rntz> make the language not *wrong* :P
[03:55:26] <strcat> malloc takes 10ns for a small object
[03:55:36] <strcat> a function call is 2-3ns
[03:55:55] <ziad> strcat: that would be incompatible semantically, not a syntactically incompatible change, right?
[03:55:57] <strcat> ezyang: it'd be a lot of overhead if it had to fail, for sure, but it just aborts
[03:56:02] <strcat> ziad: yes
[03:56:06] <strcat> rntz: well we are going to do that
[03:56:17] <strcat> rntz: and moves are fully built-in to the language, you can't write a move ctor like you can in C++
[03:56:20] <rntz> strcat: bump-pointer allocation could be faster than malloc.
[03:56:50] <rntz> there are a bunch of hacks functional languages often do to get allocation to be fast because they allocate a lot.
[03:57:00] <rntz> that may be what ezyang is thinking of? don't know.
[03:57:01] <strcat> rntz: modern allocators are pretty fast
[03:57:07] <strcat> they have a thread-local cache
[03:57:15] <strcat> inside that cache are pools for each size class
[03:57:30] <ezyang> strcat: yeah, uh, you're already fucked 
[03:57:31] <strcat> there's a size class for up to 16 bytes, up to 32 bytes, up to 48 bytes, etc.
[03:57:34] <rntz> it's very hard to get faster than bumping a pointer :P
[03:57:42] <ezyang> you want to do a single pointer comparison for allocation 
[03:57:44] <rntz> I'm aware of what seglists are
[03:57:55] <strcat> rntz: they don't use free lists
[03:58:11] <strcat> at least tcmalloc and jemalloc don't, for small ones
[03:58:33] <rntz> yes, yes, sure, not a free list. I'm aware of what you're talking about even if we use different terminology for it; the size-classes thing.
[03:58:33] <strcat> ezyang: if you move the costs elsewhere...
[03:58:48] <strcat> malloc/free can be O(1)
[03:59:01] <strcat> virtual memory lets large stuff be pretty fast too
[03:59:17] <rntz> malloc/free are never O(1); they might fail :P
[03:59:24] <rntz> worst case time: infinity
[03:59:46] <strcat> rntz: calling a function can fail, you can hit the end of the stack
[03:59:53] <ezyang> The more garbage you allocate, the faster your GC runs!! 
[04:00:03] <rntz> strcat: bah, assume infinite stack space
[04:00:06] <rntz> :P
[04:00:06] *** Quits: AvianFlu (AvianFlu@974D245D.130DDD13.67CD788C.IP) (Input/output error)
[04:00:15] <strcat> ezyang: so if that approach works, why is micro-optimized haskell that looks like assembly 3x slower than C?
[04:00:31] <strcat> except in trivial examples that have been hard-wired into an optimizer
[04:00:45] <strcat> anyway, tcmalloc is faster than the JVM GC
[04:00:48] <ezyang> I would hardly call loop fusion "trivial" 
[04:01:01] <strcat> ezyang: loop fusion for a low-level language is just called loop optimizations
[04:01:13] <strcat> vectorization, rotation, unrolling, whatever
[04:01:40] <rntz> why has this degenerated into a language name-calling game? 
[04:02:22] <strcat> because I don't like hearing talking points repeated as if they are true
[04:03:05] <strcat> generational gc can only compete with tcmalloc when you have small objects with ephemeral lifetimes, and in C++ you don't have those
[04:03:10] <strcat> because they're just unboxed
[04:03:53] <strcat> if you've already sacrificed performance as a whole, then the trade offs become different
[04:04:10] <strcat> but if you want to stay in the C++ niche, you can't make huge perf sacrifices
[04:04:35] <strcat> that's why segmented stacks were a failure in rust
[04:05:09] <strcat> we're still paying an unacceptable 1-2% overhead for the prelude checks that you don't pay with gcc -fstack-check
[04:05:18] <strcat> and sometimes, it might be 50% overhead
[04:05:24] *** Joins: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net)
[04:05:27] <strcat> all it takes is it being enough to push the code out of the icache
[04:05:39] *** Quits: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net) (Ping timeout)
[04:05:50] <strcat> boxing == more pointers in cache
[04:07:54] *** Quits: maxli (maxli@moz-4D28BA20.student.cs.uwaterloo.ca) (Quit: Leaving.)
[04:07:58] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.2)
[04:08:40] *** Quits: synackse (synackse__@moz-DFB8ED3B.lightspeed.wepbfl.sbcglobal.net) (Ping timeout)
[04:10:56] *** Joins: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net)
[04:10:57] *** Joins: synackse (synackse__@moz-DFB8ED3B.lightspeed.wepbfl.sbcglobal.net)
[04:11:21] *** Quits: MrByte (Dartakio@moz-81792842.chy-wy.client.bresnan.net) (Ping timeout)
[04:14:23] *** Joins: eholk (eholk@moz-F70D5031.hsd1.in.comcast.net)
[04:20:17] *** Jarrett|Away is now known as Jarrett
[04:21:01] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[04:23:32] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Client exited)
[04:26:20] *** Quits: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net) (Quit: gavinb)
[04:29:42] *** Joins: jvns (bork@moz-DE62990.nyc.res.rr.com)
[04:32:23] *** Quits: steveno (steveno@moz-2B2BE86F.hsd1.pa.comcast.net) (Quit: Leaving)
[04:33:44] <ezyang> strcat: You're @thestinger on github, is that correct? (just trying to link identifiers) 
[04:34:43] *** Joins: lpy (lpy@7360AA58.F09091A8.1348A864.IP)
[04:34:49] *** Joins: AvianFlu (AvianFlu@974D245D.130DDD13.67CD788C.IP)
[04:36:58] *** Quits: tcreate (tcreate@7C181A70.200CF5B8.9D2C3D3E.IP) (Client exited)
[04:37:08] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[04:37:17] *** Joins: trecer (trecer@moz-36BEFC79.hsd1.pa.comcast.net)
[04:37:25] <strcat> ezyang: yes, and sorry for being on edge today
[04:37:36] *** Joins: dangets (dangets@moz-E9E4A77B.cpe.cableone.net)
[04:39:03] *** Quits: trecer (trecer@moz-36BEFC79.hsd1.pa.comcast.net) (Ping timeout)
[04:39:23] *** Quits: toshok (toshok@moz-43741342.cat) (Quit: Coyote finally caught me)
[04:39:35] <ezyang> no worries 
[04:40:07] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[04:41:29] *** Joins: tcreate (tcreate@7C181A70.200CF5B8.9D2C3D3E.IP)
[04:41:46] *** Quits: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net) (Quit: ChatZilla 0.9.90.1 [Firefox 25.0.1/20131112160018])
[04:43:16] *** Quits: tcreate (tcreate@7C181A70.200CF5B8.9D2C3D3E.IP) (Ping timeout)
[04:45:51] *** Quits: eholk (eholk@moz-F70D5031.hsd1.in.comcast.net) (Quit: eholk)
[04:48:23] *** Joins: tcreate (tcreate@7C181A70.200CF5B8.9D2C3D3E.IP)
[04:48:56] *** Joins: Blei (philipp@moz-B2F9E4BD.cust.bluewin.ch)
[04:50:08] *** Quits: tcreate (tcreate@7C181A70.200CF5B8.9D2C3D3E.IP) (Ping timeout)
[04:50:58] *** Joins: eholk (eholk@moz-F70D5031.hsd1.in.comcast.net)
[04:51:37] *** Quits: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com) (Ping timeout)
[04:54:58] *** Joins: tcreate (tcreate@7C181A70.200CF5B8.9D2C3D3E.IP)
[04:56:38] *** Quits: tcreate (tcreate@7C181A70.200CF5B8.9D2C3D3E.IP) (Ping timeout)
[04:56:45] *** Joins: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net)
[04:57:55] *** Joins: tcreate (tcreate@7C181A70.200CF5B8.9D2C3D3E.IP)
[04:59:03] *** Quits: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net) (Ping timeout)
[05:00:37] *** Quits: tcreate (tcreate@7C181A70.200CF5B8.9D2C3D3E.IP) (Client exited)
[05:01:01] *** Quits: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net) (Ping timeout)
[05:02:57] *** Quits: synackse (synackse__@moz-DFB8ED3B.lightspeed.wepbfl.sbcglobal.net) (Ping timeout)
[05:05:09] *** Joins: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net)
[05:13:20] *** Quits: jvns (bork@moz-DE62990.nyc.res.rr.com) (Ping timeout)
[05:16:32] *** Quits: AvianFlu (AvianFlu@974D245D.130DDD13.67CD788C.IP) (Connection reset by peer)
[05:18:31] *** Quits: Krymise (Nietzsche@moz-CA789EF5.nwrknj.fios.verizon.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[05:27:41] *** Joins: killerswan (kevincantu@moz-CC0DC654.hsd1.ca.comcast.net)
[05:32:33] *** Joins: alan_andrade (alan_andra@8AB4864E.75F2E118.B7838CA6.IP)
[05:42:45] <carter> i have to agree with ezyang, its absolutely feasiable to do nice things
[05:43:17] <carter> strcat: as for the 3x slower bit, thats only because ghc doesnt have decent simd yet
[05:43:46] <carter> well, 4x in the example i'm thinking of
[05:44:17] <carter> its actually really easy to write pretty direct style haskell code that generates exactly the assembly i'd expect C to generate, for bit fiddling algs
[05:44:42] <strcat> for trivial examples without data structures, etc.
[05:44:59] <carter> give me a concrete problem with data stuctures :)
[05:45:05] <carter> then lets talk
[05:46:16] <carter> i want a  fun example
[05:46:20] <carter> share one
[05:46:25] <carter> and i'm happy to figure out how to benchmark 
[05:46:28] <strcat> carter: almost all of the language benchmarks game ones
[05:46:48] <carter> no, pick one :)
[05:47:05] <strcat> http://benchmarksgame.alioth.debian.org/u64q/program.php?test=revcomp&lang=gcc&id=2 low-level C, 0.54s
[05:47:06] <carter> lets be really really really concreset
[05:47:09] *** Quits: lpy (lpy@7360AA58.F09091A8.1348A864.IP) (Ping timeout)
[05:47:12] <strcat> http://benchmarksgame.alioth.debian.org/u64q/program.php?test=revcomp&lang=ghc&id=3 low-level haskell 1.49s
[05:48:10] <strcat> simple string manipulation, and it's short lived so GC should do well
[05:49:17] <carter> hrmm, i think modern bytestring / text might fair better on this benchmark
[05:49:46] <carter> ezyang: thoughts?
[05:50:20] <strcat> I expect most of these have had a lot of work put into them for every language, so I'm sure people wrote it with every imaginable unboxed vector/pointer combination ;p
[05:51:05] <strcat> there are some unfair rules but I don't think they apply to this one
[05:51:24] <carter> i do like the higher level one thats still not to shappy http://benchmarksgame.alioth.debian.org/u64q/benchmark.php?test=revcomp&lang=ghc&id=2&data=u64q
[05:51:32] <killerswan> I like these benchmarks
[05:51:56] <killerswan> quite a while ago, I wrote chameneos and k-nucleotide benchmarks for rust
[05:52:07] <killerswan> and compared Rust vs. C/C++ vs. F#
[05:52:07] * strcat finds some of those benchmarks really dumb
[05:52:09] <strcat> like pidigits
[05:52:16] <strcat> they are all just calling gmp
[05:52:19] <carter> hehe
[05:52:26] <strcat> so it's a benchmark of... how fast you can call micro-optimized C/asm
[05:52:29] <killerswan> at the time, Rust was getting killed, but it looked waaaaay easier to read than C/C++
[05:52:46] <strcat> you can write rust as you would C
[05:52:56] <strcat> rather than doing it from scratch I like to just port the C/C++ to rust 1:1
[05:52:58] <strcat> shouldn't be any slower
[05:53:04] <killerswan> yeah, feel free
[05:53:08] <strcat> then you can see how much the safety and high-level abstractions cost
[05:53:22] <strcat> I'd like another benchmark competition actually comparing stuff like that ;\
[05:53:32] <strcat> and not arbitrarily leaving out alternate implementations of languages...
[05:53:37] <killerswan> I also liked the ~20 line F# program for one of those
[05:53:49] <ezyang> The trouble is, Rust is basically a class alone, as far as that is concerned ^^ 
[05:54:16] <ezyang> What other languages could you reasonably do 1:1 translations that way? 
[05:54:35] <strcat> ezyang: C++, Ada, Pascal, Fortran? *shrug*
[05:54:50] <killerswan> I look almost as much at the program complexity as I do the speed
[05:54:57] <carter> killerswan: agreed
[05:54:59] *** Quits: eholk (eholk@moz-F70D5031.hsd1.in.comcast.net) (Quit: eholk)
[05:55:09] <strcat> what I want to see is a 1:1 translation from C, and then a look at how much perf you lose (if any) by writing it with safe code
[05:55:20] <carter> start with the simplest thing that performs to desired level
[05:55:31] <carter> then break out hte power tools
[05:55:35] <carter> because the thing is
[05:55:46] <carter> theres a multi dimensional pareto tradeoff
[05:55:57] <killerswan> heh
[05:56:02] <strcat> ezyang: I always hate these benchmarks for not really demonstrating the performance of what people actually write...
[05:56:04] <strcat> like...
[05:56:10] <strcat> haskell, C++, rust, etc. provide efficient generics
[05:56:23] <strcat> java's won't result in code that's as good, and only the primitives are unboxed
[05:56:34] <strcat> so it can do escape analysis in a simple example... but not complex ones
[05:57:17] <strcat> anyway, would be neat to have a more broad look at this stuff
[05:57:20] <carter> yeah
[05:57:23] <carter> but hard to do 
[05:57:33] <carter> the generics shootout
[05:57:35] <ezyang> Yeah, the microoptimizing benchmarks are complete nonsense. I guess they say something about non-eliminable overhead 
[05:58:07] <carter> but in any decent language, for the tight inner loop you can always ffi out to some C with SIMD intrinsics
[05:58:09] <alan_andrade> good talks in the house
[05:58:10] <carter> or go "fuck it, time to gpu"
[05:58:23] <strcat> ezyang: and it doesn't help that it's run by someone with a lot of bias ;p
[05:58:24] <carter> granted, gpu is… a lot of work
[05:58:30] <carter> but when it works… you win
[05:58:33] <strcat> JVM gets startup time not counted, other languages are not so fortunate
[05:58:53] <strcat> and C++ is arbitrarily not allowed to just copy the C code and perhaps abstract it a bit
[05:59:08] <carter> a generics shootout would be cool
[05:59:10] <tiffany> hsa opens up the opportunity to auto-vectorize to gpu code, without needing to worry about latency or bandwidth cost
[05:59:18] <carter> hsa?
[05:59:32] <tiffany> heterogenous system's architecture, the thing amd is doing with their CPUs
[05:59:34] <strcat> and it dropped stuff like pypy...
[05:59:41] <strcat> luajit
[05:59:42] <carter> it dropped pypy?
[05:59:45] <carter> and luajin
[05:59:46] <carter> ?
[06:00:00] <strcat> carter: yeah the guy who runs the benchmarks game removed alternate language implementations
[06:00:06] <carter> lame
[06:00:28] <tiffany> oh, that's dumb
[06:00:37] <tiffany> it's not fair to do lua benchmarks if you're not including luajit
[06:00:52] <tiffany> it's like using tcc or something instead of llvm/gcc for C
[06:01:42] <killerswan> d'oh
[06:01:49] <carter> one thing is that any generics shootout should also benchmark compilation / startup time
[06:02:27] <killerswan> IIRC Alioth does save those someplace, too
[06:03:02] <carter> ezyang: isn't vector-algorithms "more inlining happy and crazy" than the analogous c++ code?
[06:04:39] <ezyang> It has certainly been observed that for certain types of vector loops, e.g. stencil computation, or when it needs to run on a GPU, it is extremely difficult to write the C++ code in a way that will run the fastest. c.f. Halide, and everyone who's doing high-level fusion (or unfusing, as the case may be) 
[06:04:55] <strcat> julia is a neat (albeit somewhat insane) way of dealing with generics, which is dynamically specializing for each set of types
[06:05:03] <strcat> s/is/has/
[06:05:13] <ezyang> This is simultaneously interesting and not interesting. 
[06:05:20] <strcat> the really naive approach to a JIT compiler ;p
[06:05:30] <ziad> carter: ping
[06:05:37] <strcat> ezyang: well, LLVM doesn't have a real JIT compiler (it's just AOT compilation) and it's LLVM-based ;p
[06:05:39] <carter> ziad: ?
[06:05:54] <strcat> MCJIT is really just AOT compilation in-memory + dynamic loading
[06:05:55] <ziad> still having the same compilation problem from earlier today 
[06:06:03] <carter> ziad: did you try enable clang?
[06:06:04] <ziad> I even port installed gcc4.8
[06:06:12] <ziad> and used your wrappers
[06:06:16] <carter> which wrappers?
[06:06:27] <ziad> now gcc, cc and g++ all point to gcc-4.8/g++4.8
[06:06:31] <carter> ok...
[06:06:33] <carter> hrmmm
[06:06:39] <carter> did you clone a fresh tree?
[06:06:47] <ziad> #!/bin/sh
[06:06:47] <ziad> gcc-mp-4.8 "$@"
[06:06:49] <ziad> yes
[06:06:53] <carter> mp?
[06:06:59] <carter> fresh tree of rust?
[06:07:03] <ziad> yes, fresh tree
[06:07:13] <ziad> I don't know what mp is, I tried to compile a c++ program, and it worked
[06:07:14] <carter> strcat: ezyang  i dislike julias idea of generics, no parametricy
[06:07:22] <ziad> I'm using mac ports 
[06:07:25] <carter> ah
[06:07:28] <ziad> port install gcc4.8
[06:07:28] <carter> mp == macports?
[06:07:32] <ziad> I guess so
[06:07:41] <strcat> ezyang: who needs a tracing JIT when you can just generate ridiculous amounts of code and have a huge startup time ;p
[06:08:01] <ezyang> \o/ 
[06:08:22] <ziad> when using gcc, should I expect to see llvm[] in the compilation output progress ?
[06:08:27] <ziad> e.g. llvm[3]: Compiling ConstantsTest.cpp for Release+Asserts build
[06:08:31] <strcat> ziad: yes, that's building LLVM
[06:08:34] <carter> its building its own copy of llvm
[06:08:35] <ziad> I see
[06:08:52] <ziad> the error was ar: fatal error in /opt/local/bin/ranlib
[06:09:03] <ziad> Assertion failed: ((unsigned)Val < Attribute::EndAttrKinds && "Attribute out of range!"), function addAttribute, file Attributes.cpp
[06:09:06] <ziad> was that the same one you were getting?
[06:09:13] <strcat> anyway LLVM really needs to get solid PGO ;p
[06:09:20] <carter> PGO?
[06:09:25] <strcat> profile-guided optimization
[06:09:27] <carter> ok
[06:09:35] <carter> you should do it1
[06:10:02] <strcat> it's ridiculous on benchmarks
[06:10:19] <strcat> with gcc, you do gcc -march=-fprofile-generate -O3 foo.c && ./a.out 1000 && gcc -march=native -fprofile-use -O3
[06:10:25] <strcat> and now run it on some bigger problem
[06:10:29] <strcat> er
[06:10:36] <carter> ?
[06:10:38] <strcat> part of that got cut out
[06:10:41] <strcat> not impotant
[06:10:44] <strcat> important*
[06:11:08] <carter> on a more fun note: sometimes high level code gets you amazing things.
[06:11:13] <carter> as ezyang  points out about fusion and stuff
[06:11:50] <ezyang> TBH, though, that sort of situation tends to be quite rare 
[06:11:55] <strcat> anyway it uses runtime instrumentation to figure out all of the hot/cold blocks/functions and so on
[06:12:08] <strcat> LLVM seems to have PGO now but you have to *somehow* produce the profiling data externally
[06:12:31] <strcat> and if it's not easy, who's going to bother? ;p
[06:13:00] <o11c> strcat: a critically important fact
[06:13:02] <killerswan> OK, so I'm running `leaks` on my program demonstrating the libstd leak on OS X (https://github.com/killerswan/meow/blob/master/src/testloop.rs), and it does show me that `DefaultMallocZone_0x10366a000` is part of my enemy
[06:13:04] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[06:13:07] *** Joins: hoverbear (hoverbear@moz-86FCBF4B.gv.shawcable.net)
[06:13:19] <killerswan> but I'm not sure where that is or what to do about it...
[06:13:51] <ezyang> OK, proper Rust question: why is there no distinction between a mutable root, and a stack location which is mutable? 
[06:14:01] <strcat> ezyang: hm?
[06:14:12] <ezyang> If I say 'let mut x = ...', I could be doing it for two reasons 
[06:14:25] <sfackler> killerswan: can you get a stack trace from the call to DefaultMallocZone_0x10366a000?
[06:14:27] <ezyang> (1) I want to do x = ... later 
[06:14:37] <strcat> ezyang: inherited mutability provides static safety for borrowed pointers
[06:14:39] <ezyang> (2) I want to mutably access something in x 
[06:15:08] <strcat> ezyang: rust doesn't really special-case variables though
[06:15:10] *** Quits: ab (alex@BC9D99CC.37C1012D.FE617B51.IP) (Quit: Konversation terminated!)
[06:15:14] <o11c> ezyang: that problem can be solved by having two implementations of every data structure ... one mutable and one not
[06:15:16] *** Joins: Jesin (Jesin@moz-63C897DA.res.lehigh.edu)
[06:15:21] <strcat> you might want to have fine-grained mutability elsewhere too, and it just doesn't provide it
[06:16:44] <ezyang> So, are you saying, the only way to sensibly have a mutable stack location is for it to also impose inherited mutability (for safety reasons)? 
[06:17:04] <strcat> ezyang: well I'm saying that the primary reason for having the mutability control at all is for safety
[06:17:17] <ezyang> Oh, I totally agree that inherited mutability is a very useful feature 
[06:17:19] <strcat> and the semantic benefits are secondary
[06:17:29] <strcat> so in general it just tries to do the simplest thing possible
[06:17:35] <ezyang> All I'm wondering is why the 'let mut ...' seems to play double-duty role 
[06:17:38] <strcat> ezyang: rust went through a lot of different phases with this stuff ;p
[06:17:42] <strcat> ezyang: it used to be separate
[06:17:49] <ezyang> Ah! 
[06:17:52] <strcat> in various weird ways
[06:18:36] <strcat> ezyang: rust used to have no inherited mutability, no borrowed pointers, argument modes, moves weren't based on types (there were move and copy keywords), etc. ;p
[06:18:46] <ezyang> One reason I'm wondering about this, is because it seems to be obstructing me from writing a loop (borrowck--) 
[06:18:58] <strcat> it basically tried everything.... and ended up dropping a fair bit of flexibility for simplicity
[06:19:14] <strcat> ezyang: probably a borrowck limitation
[06:19:17] <ezyang> Yeah, honestly I find it amazing that you guys added all that later 
[06:19:21] <killerswan> sfackler: what is the easiest way to do that?
[06:19:28] <strcat> ezyang: it should be able to statically freeze stuff without it being in an immutable binding
[06:19:44] <killerswan> i'm an lldb n00b, and there apparently isn't a brew package for gdb?
[06:19:47] <ezyang> Yes! That's what I need. 
[06:19:52] <strcat> ezyang: it even used to have structural records...
[06:20:01] <strcat> ezyang: in most cases it can statically freeze now
[06:20:06] <strcat> it's nowhere near as bad as it once was
[06:20:14] <strcat> I remember when to iterate over a container you had to move it into an immutable var
[06:20:17] <killerswan> and this program isn't linked with enough OS X core stuff to work with instruments
[06:20:19] <sfackler> killerswan: not sure, I haven't used Instruments a ton, i'll poke around
[06:20:39] <killerswan> (or at least as far as I know)
[06:20:41] <killerswan> thanks
[06:21:36] <strcat> rusti: let t = (1, 2); let (ref mut a, ref mut b) = t; *a = 5, *b = 10; t
[06:21:39] -rusti- failed to pastebin 6 lines of output
[06:21:47] <strcat> rusti: let t = (1, 2); let (ref mut a, ref mut b) = t; *a = 5, *b = 10; t
[06:21:48] -rusti- failed to pastebin 6 lines of output
[06:21:50] <strcat> ;\
[06:21:52] <dbaupp> rusti: let mut t = (1, 2); let (ref mut a, ref mut b) = t; *a = 5, *b = 10; t
[06:21:53] -rusti- failed to pastebin 6 lines of output
[06:21:57] <strcat> rusti: let t = (1, 2); { let (ref mut a, ref mut b) = t; *a = 5, *b = 10; } t
[06:21:57] -rusti- failed to pastebin 6 lines of output
[06:22:04] <dbaupp> strcat: t isn't mut
[06:22:12] <strcat> rusti: let mut t = (1, 2); { let (ref mut a, ref mut b) = t; *a = 5, *b = 10; } t
[06:22:12] -rusti- failed to pastebin 6 lines of output
[06:22:23] <strcat> rusti: let mut t = (1, 2); { let (ref mut a, ref mut b) = t; *a = 5; *b = 10; } t
[06:22:25] -rusti- (5, 10)
[06:22:28] * strcat sighs
[06:22:34] <strcat> rusti: let mut t = (1, 2); let (ref mut a, ref mut b) = t; *a = 5; *b = 10; t
[06:22:35] -rusti- (5, 10)
[06:22:48] <strcat> rusti: let mut t = (1, 2); let (ref mut a, ref b) = t; *a = 5; (t, *b)
[06:22:49] -rusti- ((5, 2), 2)
[06:22:58] * strcat is quite impressed by stuff like that working now...
[06:23:16] <strcat> it didn't used to view tuple slots as disjoint
[06:24:02] <o11c> who can make rusti stop saying -> #rust ?
[06:25:34] <strcat> o11c: do you use weechat? they added that stupid thing in an update
[06:25:40] <strcat> I think there's a way to turn it off
[06:25:53] <strcat> hm
[06:26:45] <strcat> o11c: if you /set irc.look.notice_as_pv never, it won't do it
[06:26:47] <ezyang> Huh, as far as I can tell, there are only two major borrowck problems which cause people problems right now 
[06:26:51] <strcat> don't know what the other consequences are ;p
[06:27:23] <o11c> rusti: "hello"
[06:27:23] -rusti- "hello"
[06:27:29] <o11c> still doing it
[06:27:42] *** Joins: pcwalton (pcwalton@moz-DA87EE4.hsd1.ca.comcast.net)
[06:27:42] *** ChanServ sets mode: +ao pcwalton pcwalton
[06:27:44] <strcat> hrm
[06:27:49] *** Quits: pcwalton (pcwalton@moz-DA87EE4.hsd1.ca.comcast.net) (Quit: pcwalton)
[06:28:17] <strcat> dunno :(
[06:28:23] <o11c> but you're right that it is a weechat issue, I just confirmed on another channel and network
[06:28:30] <o11c> so i'll go ask them
[06:28:34] <strcat> I know it didn't do it before
[06:28:43] <strcat> added in 0.4.1 or 0.4.2, maybe
[06:30:33] <o11c> it's definitely 0.4.2, I was using 0.4.2-pre until a couple days ago
[06:32:13] <ezyang> man, the two-level lifetime trick here is so evil https://github.com/mozilla/rust/issues/10444 
[06:33:39] <o11c> rusti: "world"
[06:33:40] -rusti- "world"
[06:34:09] <strcat> rusti, oo ooo + oo
[06:34:09] -rusti- failed to pastebin 6 lines of output
[06:34:12] <strcat> hrm
[06:34:16] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[06:34:46] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[06:34:47] <strcat> rusti, oo ooo + oo
[06:34:49] -rusti- pastebinned 6 lines of output: http://ix.io/9pe
[06:34:56] <o11c> strcat: apparently, there is no way to turn it off
[06:35:00] <strcat> guess sprunge.us doesn't like me anymore
[06:35:01] <strcat> o11c: :(
[06:35:39] <sfackler> strcat: sprunge is throwing 500 errors for me as well
[06:35:43] <strcat> o11c: perhaps with a script
[06:40:19] <geomyidae> if you were going to decode packets with rust, which sort of API would you create for users? https://gist.github.com/anonymous/73ba9e389cef04f13398 something like either of those or are there better ideas?
[06:40:42] <alan_andrade> Is anyone having problems building rust ?
[06:40:44] <alan_andrade> https://gist.github.com/alanandrade/8000989
[06:42:05] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[06:43:21] <o11c> rusti: "test3"
[06:43:22] -rusti- "test3"
[06:45:25] *** Joins: eddyb (eddy@moz-68E0B7D0.residential.rdsnet.ro)
[06:45:29] <geomyidae> I feel like option 1 would be better because it would make for a better match { } syntax to use with
[06:45:37] <geomyidae> but I'm not sure if there's a cleaner way to do it even.
[06:46:33] <sfackler> geomyidae: option 1 seems like the obvious one to me
[06:47:07] <killerswan> alan_andrade: when in doubt, and having the free time to recompile LLVM, just nuke x86_64-apple-darwin
[06:47:15] <killerswan> then run the new ./configure
[06:47:32] <ezyang> How much of this blog post is implemented? http://smallcultfollowing.com/babysteps/blog/2012/11/18/imagine-never-hearing-the-phrase-aliasable/ 
[06:47:43] <ezyang> I think the '&mut is the only way to mutate the data' is in rust 
[06:48:01] <alan_andrade> @killerswan wow, how can I nike llvm ? I use homebrew.
[06:48:11] <geomyidae> sfackler: is Hdr, and ~[u8] payload the way you would have them destructure like that?
[06:48:13] <alan_andrade> s/nike/nuke
[06:48:36] <killerswan> alan_andrade: Rust's `make` downloads source and compiles its own LLVM
[06:48:41] <geomyidae> that was the part that I was more unsure about, it doesn't seem normal to shove all of the various header values in place there rather than a struct to group them
[06:49:12] <killerswan> alan_andrade: (well, ./configure, IIRC, loads up the right version of git submodule)
[06:49:30] <killerswan> so you can ignore your system-wide LLVM from brew or wherever
[06:49:33] <sfackler> you could do something like "struct EthernetPacket { header: Header, body: ~[u8] } enum Header { IPHeader { ... }, ...  }"
[06:49:36] <alan_andrade> @killerswan oh, so If I delete the x86_64-apple-darwin directory, that will do it ?
[06:49:45] <killerswan> alan_andrade: probably :)
[06:49:53] <alan_andrade> wonderful! let me try that
[06:50:20] <o11c> sfackler: are you bitcasting your packet or willing to copy the full array?
[06:50:46] <sfackler> o11c: ?
[06:50:48] <geomyidae> o11c: that's another consideration I had in the back of my mind.
[06:50:55] <geomyidae> (sfackler was advising me)
[06:51:41] <alan_andrade> @killerswan I'm a web developer and I'm starting with Rust which a more lower level programming. I feel amazed with all the things that need to happen to get a language ready.
[06:52:42] <alan_andrade> @killerswan aha! make: llvm making...
[06:54:02] <o11c> geomyidae: well, I'd say that bitcasting, and always passing a borrowed pointer to the packet, is the way to go
[06:54:16] <killerswan> alan_andrade: yeah, there are some big machines kicking around there
[06:54:50] <o11c> struct Packet { src: i32, dst: i32, body: [u8, ..0], }
[06:55:23] <o11c> geomyidae: dealing with the bitfields will be annoying though
[06:55:34] <killerswan> alan_andrade: have you read this overview of LLVM ever? http://www.aosabook.org/en/llvm.html
[06:55:36] <geomyidae> yeah whats the smallest type I can   get in rust :o
[06:56:05] <geomyidae> some of these I was planning on shifting but that probably would mean copying
[06:56:24] <o11c> enum {} and struct {} are both size 0, as is any [T, ..0]
[06:56:56] <sfackler> o11c: you'll have to use accessor methods instead of returning a reference to a struct due to endianness issues probably
[06:57:08] <alan_andrade> @killerswan I haven't, but I am now ;)
[06:57:32] <sfackler> enums with a single variant and () are are also zero-sized
[06:57:50] *** Quits: dbaupp (Thunderbir@1D1B1F7A.D5A1DCF.37681C44.IP) (Ping timeout)
[06:58:20] <o11c> sfackler: other than the bitfield, you can just use BigEndian16 BitEndian32 etc fields ... wait, rust doesn't do implicit conversions. Nevermind.
[06:58:32] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Client exited)
[06:58:37] <tiffany> what would you want a single-variant enum for?
[06:58:47] <sfackler> not much
[06:59:06] <sfackler> I guess if you are planning on adding more variants but haven't gotten around to it :P
[06:59:09] * geomyidae groans, do I really need to worry about endian-ness? I assumed pcap would just give that shtuff to me in the platform usual order.... whatever that means :p
[06:59:27] <eevee> mmm slightly tempted to just nuke amulet and start over
[06:59:34] <o11c> geomyidae: in C, you just have to call ntohl() yourself
[07:00:02] <o11c> tiffany: in C++ it's useful for tagged constructors ...
[07:00:22] *** Quits: tiffany (kawaii@moz-FC0DB29D.dhcp.embarqhsd.net) (Ping timeout)
[07:02:37] <strcat> o11c: hm? that doesn't immediately make sense to me, what would that be?
[07:02:49] <strcat> oh I guess accessing a specific overload?
[07:02:54] *** Joins: tiffany (kawaii@moz-FC0DB29D.dhcp.embarqhsd.net)
[07:02:56] <strcat> to avoid ambiguity
[07:05:21] <o11c> strcat: in C++, my BigEndian16 class has a conversion operator to uint16_t
[07:05:23] <geomyidae> I assume the hton{l,s} and vice-versa will copy, probably not worth trying to implement them myself to avoid copying in an accessor
[07:05:38] <o11c> geomyidae: copying of an int isn't something to worry about
[07:05:40] *** Quits: heftig (heftig@moz-B3E7564.dip0.t-ipconnect.de) (Quit: Quitting)
[07:05:57] <o11c> it's copying the payload that you want to avoid
[07:06:37] *** Quits: canhtak (canhtak@moz-258236CD.wl.t.ulaval.ca) (Quit: canhtak)
[07:07:23] *** Joins: canhtak (canhtak@moz-258236CD.wl.t.ulaval.ca)
[07:07:57] * geomyidae would like "the bithub for irc" as much as he hates the "the <x> for <y>" construction for software ideas
[07:08:16] <geomyidae> actually, I'd really, really like that functionality
[07:10:21] *** Joins: anasyrma (x@moz-DE175E38.caltech.edu)
[07:10:33] *** Quits: tiffany (kawaii@moz-FC0DB29D.dhcp.embarqhsd.net) (Ping timeout)
[07:12:12] *** Joins: trecer (trecer@moz-36BEFC79.hsd1.pa.comcast.net)
[07:12:45] *** Joins: tiffany (kawaii@moz-FC0DB29D.dhcp.embarqhsd.net)
[07:13:14] *** Joins: tcreate (tcreate@7C181A70.200CF5B8.9D2C3D3E.IP)
[07:14:36] <ezyang> Is there a way to manually dispatch on a method without using the dot syntax? 
[07:21:03] <strcat> ezyang: no, but it's planned for T::bar(x) to be equivalent to x.bar()
[07:21:17] <strcat> just not implemented
[07:22:01] <ezyang> ok 
[07:23:19] *** Quits: Jarrett (chatzilla@moz-8211AC00.dhcp.nrwl.ca.charter.com) (Ping timeout)
[07:24:13] <sfackler> does --enable-debug add debug info as well?
[07:24:15] *** Joins: Jarrett (chatzilla@moz-8211AC00.dhcp.nrwl.ca.charter.com)
[07:25:06] <ChrisMorgan> sfackler: be brave! Look at the Makefile and mk/*!
[07:25:13] * ChrisMorgan would answer but has to go just now
[07:25:21] *** Quits: jdm (jdm@moz-AC9499B2.cable.teksavvy.com) (Ping timeout)
[07:26:03] <ziad> strcat: what's the point of having this equivalency?
[07:26:25] <ziad> easier generic implemenataion?
[07:26:34] <sfackler> ChrisMorgan: D:
[07:26:58] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[07:27:41] <sfackler> ziad: you wouldn't need an adapter lambda if you want to do something like foos.iter().map(T::bar)
[07:28:19] <ziad> okay
[07:29:52] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[07:30:21] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[07:35:06] *** Quits: trecer (trecer@moz-36BEFC79.hsd1.pa.comcast.net) (Quit: Computer has gone to sleep.)
[07:38:07] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Client exited)
[07:41:27] <alan_andrade> @killerswan man, Rust build just fine. Thanks for your advice.
[07:41:36] <alan_andrade> s/build/built
[07:43:44] <killerswan> cool!
[07:44:35] *** Joins: Ms2ger (Ms2ger@BB191E51.D97EE64B.F15B0BB3.IP)
[07:45:17] <alan_andrade> Does this look familiar to anyone? https://gist.github.com/alanandrade/8001446
[07:45:28] *** Quits: jeaye (Jeaye@moz-34FEF2BB.hsd1.ca.comcast.net) (Quit: zzz)
[07:46:04] <alan_andrade> metadata failed with: exit code: 1 ?
[07:46:20] <killerswan> hmm
[07:46:41] *** flaper87|afk is now known as flaper87
[07:47:53] *** Quits: o11c (ben@moz-C0FD33EF.a357.priv.bahnhof.se) (Input/output error)
[07:47:59] *** Joins: o11c (ben@moz-C0FD33EF.a357.priv.bahnhof.se)
[07:48:35] *** Quits: vky (chatzilla@moz-4F2E17BF.dsl.dynamic.sonic.net) (Quit: ChatZilla 0.9.90.1 [Firefox 27.0/20131209204824])
[07:48:35] *** Joins: jackneill (jackneill@moz-B6F27E42.pool.digikabel.hu)
[07:49:04] <alan_andrade> It's trying to compile https://github.com/uutils/coreutils/blob/master/env/env.rs
[07:49:32] *** Quits: hoverbear (hoverbear@moz-86FCBF4B.gv.shawcable.net) (Quit: Hibernating, be back soon.)
[07:49:50] <acrichto> alan_andrade: you may be linking against and old rlib
[07:50:32] <alan_andrade> that's possible since I just built Rust
[07:51:38] <alan_andrade> how can I make sure I'm not ?
[07:52:18] <acrichto> alan_andrade: if you run 'ar t' on an rlib, one of the files should be "metadata"
[07:54:20] <alan_andrade> I have two libstd-*.rlib
[07:54:35] <alan_andrade> and both have very similar metadata
[07:54:51] <acrichto> interesting, one of them should have gotten cleaned out I would have thought
[07:56:04] <alan_andrade> Oh wow, I have two of each. So it didn't clean when I rebuilt rust.
[07:56:16] <alan_andrade> Or I didn't rebuilt correctly
[07:57:13] <alan_andrade> @acrichto well, I moved those with error to *.old and now rustc is picking up the good version.
[07:57:34] <acrichto> alan_andrade: huh, good enough for me!
[07:57:43] <alan_andrade> yeah
[07:59:01] *** Quits: canhtak (canhtak@moz-258236CD.wl.t.ulaval.ca) (Quit: canhtak)
[07:59:25] *** Joins: andreypopp (andreypopp@moz-7261DC60.net)
[08:03:17] <o11c> ugh, why aren't strcat and rusti coming back?
[08:07:00] *** Joins: arrrrrrrrr (arrrrrrrrr@moz-5A85AEE3.dynamic.qsc.de)
[08:11:52] *** Joins: dbaupp (Thunderbir@moz-EB2EFE6F.lns20.syd6.internode.on.net)
[08:15:42] <ezyang> https://github.com/mozilla/rust/issues/6393 <-- I wonder if the immutable borrow in if test only applies to @mut boxes 
[08:16:00] <ezyang> because it seems to me that the lexical scope encompassing precisely the conditional should work as a lifetime, otherwise 
[08:16:21] <eddyb> wait, I just realized how fitting this is
[08:16:43] <eddyb> https://www.youtube.com/watch?v=tZ9hB9AGQZc
[08:17:00] <eddyb> (just in a different area)
[08:19:46] <eddyb> bstrie: you might like it ^_^
[08:41:12] *** Joins: pyon (user@F4DA2F11.BD7DB6F4.1C8C8CE9.IP)
[08:47:21] <arrrrrrrrr> can I define a macro inside a macro?
[08:48:32] <eddyb> pretty sure you can't
[08:48:35] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[08:48:40] <arrrrrrrrr> :(
[08:49:01] <pyon> What is the Rust analog of C++'s std::istream_iterator and std::ostream_iterator?
[08:50:01] <eddyb> pyon: what are those?
[08:50:17] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Ping timeout)
[08:50:32] <eddyb> are they generic iterators like using << / >> in a loop?
[08:51:31] <pyon> eddyb: They are templates that allow you to use opeator>> on a std::istream or operator<< on a std::ostream in an iterated fashion.
[08:52:17] <eddyb> pyon: in C++11, with a for(element : iterator) loop - does the type of the element stay constant for those iterators?
[08:52:26] <eddyb> (I'm pretty sure it has to)
[08:52:42] <pyon> eddyb: Mmm... That is not exactly what iterators are in C++. :-|
[08:53:01] <eddyb> pyon: I was asking about that use case of iterators
[08:53:32] <arrrrrrrrr> why can't I "extern mod extra" in a module?
[08:53:37] <eddyb> because that for loop was designed on top of iterators
[08:54:16] <pyon> eddyb: e.g., std::copy(std::istream_iteartor<double>(std::cin), std::istream_iterator<double>(), std::back_inserter(some_vector); reads as many doubles as possible from the standard input and insets them to a std::vector.
[08:54:34] <eddyb> okay, so the type is in the instance of the iterator
[08:54:36] <pyon> (ikr, the syntax is horrible, but it's the concept I'm after)
[08:54:42] <pyon> Yep.
[08:54:45] *** Quits: pradeep (pradeep@5AB4884B.FCC4549.14D5B978.IP) (Quit: leaving)
[08:54:48] <eddyb> pyon: it's doable in Rust, but I have no idea if it's there yet
[08:55:23] <eddyb> I mean, I'm not sure there is a proper equivalent to >> (<< is pretty much print!/write! with a "{}" and the value)
[08:55:41] <pyon> I would be willing to implement it myself, actually, but I would have to read more about Rust's existing I/O facilities.
[08:55:42] *** pmoore|away is now known as pmoore
[08:56:17] <eddyb> pyon: I think you want to look at std::io::Reader/Writer - and somewhere there is a .lines() iterator creating method
[08:56:52] <pyon> Mmm... going to check. :-)
[08:56:56] *** Quits: killerswan (kevincantu@moz-CC0DC654.hsd1.ca.comcast.net) (Quit: killerswan)
[08:57:50] *** Quits: arrrrrrrrr (arrrrrrrrr@moz-5A85AEE3.dynamic.qsc.de) (Quit: WeeChat 0.4.2)
[08:58:52] <pyon> Mmm... Problem is, while there is a trait for Readers and Writers, there seems to be no trait for values (chars, ints, strings, etc.) that can be read from Readers or written to Writers. :-(
[09:01:00] <eddyb> pyon: because it's not that simple as C++ pretends it is :P
[09:01:25] <eddyb> pyon: std::fmt has a few traits for different categories of values that can be printed
[09:01:55] <eddyb> pyon: and there's also the ToStr/FromStr conversion pair
[09:02:57] <pyon> Mmm... going to check, again. :-)
[09:03:16] <eddyb> pyon: you can probably use something that splits by whitespace and then feeds to FromStr - but you have to make sure to not consume the invalid string
[09:03:25] <eddyb> which I'm not sure you can do
[09:03:58] <pyon> Yeah, that sounds tricky.
[09:04:17] <eddyb> we don't have an equivalent to scanf, AFAIK, you could try that :P
[09:04:32] <utkarsh> Is it possible to store a closure in a struct?
[09:04:41] <eddyb> utkarsh: yes, with an explicit lifetime
[09:05:02] <eddyb> pyon: you won't be able to implement it in the library without variadic functions (which may be coming in the future)
[09:05:26] *** Joins: rca (rcatolino@moz-3ED58F2C.adsl.proxad.net)
[09:05:40] <ezyang> Hey Rusters, I wrote a thing about the two major existing borrowck bugs. Can you kind folks give it a read over before I release it for general distribution? http://blog.ezyang.com/?p=8652&shareadraft=baba8652_52b013b765f21 
[09:06:15] <eddyb> pyon: all the formatting stuff uses format_args!, which is implemented in libsyntax - so you'd have to write something similar for a string -> value matcher thing like scanf. I don't know
[09:06:44] <utkarsh> eddyb, I want something like this to work: https://gist.github.com/eb037b1f2b45e9ed59cc
[09:07:06] <pyon> eddyb: This FromStr and ToStr is rather close to what I want, actually. This would be a good starting point. :-)
[09:07:08] *** Joins: sk (sk@9E6B574B.EB2AA036.2CAF0D3B.IP)
[09:07:34] *** Quits: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz) (Quit: Busying myself...)
[09:07:36] <eddyb> pyon: also look at std::fmt::Default
[09:07:50] <eddyb> utkarsh: oh, that's a proc, not a closure
[09:08:09] <eddyb> utkarsh: you can only capture values and ~T pointers in a proc, AFAIK
[09:08:10] <pyon> eddyb: thanks for the pointer :-)
[09:09:03] <eddyb> utkarsh: you might have to consume "other" in "then"
[09:09:32] <eddyb> utkarsh: also, apply has to consume self
[09:10:16] <eddyb> utkarsh: or are you asking if you can replace the unusable proc with a closure? struct Store<'a>('a |int| -> int); should work
[09:11:10] <eddyb> utkarsh: |x| x + 1 doesn't capture anything, its lifetime is 'static, so you can put it anywhere it wants a closure
[09:12:09] <eddyb> utkarsh: not sure if "then" would work with a closure, though. you'll have to try it
[09:12:16] <utkarsh> eddyb, one sec, I tried that earlier, trying once again.
[09:12:51] <eddyb> if "then" doesn't work with a closure, then you can always make Store an enum, and I think you're implementing a subset of lambda calculus :P
[09:13:28] <eddyb> though lambda calculus is an example on the GADT haskell page, and Rust only has ADTs (atm)
[09:13:45] <utkarsh> well, my goal is to make something like Parsec from Haskell, if it's possible
[09:13:57] <utkarsh> which I'm not sure
[09:15:26] <eddyb> a 'static closure is kinda pure (if there's no calls to global state stuff like stdio)
[09:16:05] <eddyb> utkarsh: would "then"  be an operator in Haskell?
[09:16:41] <eddyb> you can abuse Index for an unary call, btw, until we have a Fn trait
[09:16:46] <eddyb> incr[10]
[09:17:10] <utkarsh> then is `>>` in Parsec (If I understood your question correctly.)
[09:17:25] <eddyb> (incr >> then)[10] might be doable right now in Rust
[09:17:31] <eddyb> s/then/dbl/
[09:17:44] <o11c> [()]
[09:17:52] <eddyb> but the overloadable operators might not play nice with stricter lifetime requirements
[09:18:16] <eddyb> o11c: imagine matrix[(), j] return a ColumnView
[09:18:39] <eddyb> which behaves like a vector, even though its elements are not successive
[09:18:55] *** Quits: alan_andrade (alan_andra@8AB4864E.75F2E118.B7838CA6.IP) (Input/output error)
[09:19:27] *** Quits: sigma (sigma@moz-6E1846A2.range86-184.btcentralplus.com) (Client exited)
[09:19:47] * eddyb also wants for ... in ... to use an Iterable trait so you can feed it vectors directly
[09:20:10] <eddyb> for x in matrix[(), j] {...}
[09:20:23] <eddyb> I mean, how cool is that?
[09:20:36] * eddyb gives up and goes to get more breakfast
[09:20:50] <utkarsh> eddyb, I'm getting "cannot infer an appropriate lifetime due to conflicting requirements ..." in the `then` fn here - http://gist.github.com/8bffd58279da33948901 
[09:20:52] *** Quits: tiffany (kawaii@moz-FC0DB29D.dhcp.embarqhsd.net) (Ping timeout)
[09:20:57] <utkarsh> eddyb, any ideas?
[09:21:10] <Yurume> eddyb: it would be rather matrix[((), j)] I think ;)
[09:21:20] <eddyb> Yurume: variadic Index ;)
[09:21:31] <eddyb> utkarsh: yes. add more lifetimes
[09:21:43] *** Joins: sigma (sigma@moz-6E1846A2.range86-184.btcentralplus.com)
[09:21:52] <eddyb> fn then<'b>(&'b self, other: &'b Store) -> Store<'b> {
[09:21:58] <eddyb> I think that could work
[09:22:06] *** Quits: spacetime (quassel@moz-CAB487E6.rishab.in) (Quit: Thanks for all the fish.)
[09:23:22] <utkarsh> eddyb, doesn't seem to be working - same error
[09:23:47] <eddyb> utkarsh: what is it pointing at?
[09:24:00] <eddyb> the spans are there for a reason
[09:24:21] <utkarsh> "cannot infer an appropriate lifetime due to conflicting requirements..." for the Store() inside then
[09:24:29] <utkarsh> I can gist the error output if you want.
[09:24:42] <eddyb> utkarsh: oh
[09:24:47] <utkarsh> and I'm running rust master from a few days ago, if that makes a difference
[09:24:53] <eddyb> utkarsh: yeah, that closure can't escape the function
[09:25:25] <eddyb> utkarsh: you want to use an enum here
[09:26:10] <eddyb> enum Lam<T> {Lam(|T| -> T), Then(&Lam, &Lam)} or something like that
[09:26:15] <utkarsh> you mean like Seq(Parser1, Parser2), etc, and call them once?
[09:26:21] <utkarsh> oh ok
[09:27:57] <eddyb> utkarsh: pattern match in apply, which will recurse through the binary tree
[09:28:10] <eddyb> name them what you want, I am bad at haskellish terminology :P
[09:28:27] <utkarsh> yep, but the implementation wouldn't be elegant :P
[09:28:32] <utkarsh> compared to haskell
[09:30:33] <Ms2ger> Haskell can be elegant? ;)
[09:30:45] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[09:33:34] <eddyb> utkarsh: well, I have another idea
[09:34:13] <eddyb> utkarsh: just use 'static - you don't need to capture anything in those closures, do you?
[09:34:32] <utkarsh> not right now
[09:34:41] <eddyb> utkarsh: and then you can have your *internal* binary tree on the heap. and construct them with operators
[09:35:24] <eddyb> what you're trying to do might be in the std lib in the future, if the Fn trait ever becomes a thing
[09:35:52] <eddyb> I think 'static closures are copiable, too
[09:37:37] <eddyb> though if you replace Store with an enum, then you have to clone it - which will be shallow if you use Rc for the recursive stuff
[09:38:17] <eddyb> if only Rc would do an implicit ownership split as needed...
[09:38:50] <eddyb> (not the crap @T does everywhere, ref counting in every scope)
[09:40:33] <utkarsh> by "internal binary tree", you meant something like https://gist.github.com/e52483dc5e3ba810d246? (It works, with the exact syntax I originally wanted for the end user)
[09:40:58] <eddyb> utkarsh: yes
[09:41:20] <eddyb> utkarsh: you don't need the crazy lifetimes if you put it on the heap
[09:41:42] <eddyb> utkarsh: and >> can't have the lifetime restrictions then has
[09:49:04] <utkarsh> eddyb, thanks for everything!
[09:49:21] <eddyb> np, glad to help :)
[09:55:24] *** Joins: z0w0 (zack@moz-7B305DFB.lnse1.woo.bigpond.net.au)
[09:57:20] *** Parts: z0w0 (zack@moz-7B305DFB.lnse1.woo.bigpond.net.au) ()
[10:01:19] *** Quits: eddyb (eddy@moz-68E0B7D0.residential.rdsnet.ro) (Ping timeout)
[10:03:30] *** Quits: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP) (Ping timeout)
[10:04:47] *** Joins: DeTeam (DeTeam@92C799C.31715274.F5F3AF2.IP)
[10:04:52] *** Joins: eternaleye (eternaleye@moz-5668AFCB.hsd1.wa.comcast.net)
[10:06:38] *** Joins: eddyb (eddy@moz-68E0B7D0.residential.rdsnet.ro)
[10:10:37] *** Quits: rca (rcatolino@moz-3ED58F2C.adsl.proxad.net) (Ping timeout)
[10:14:52] *** Joins: klaus (koz@moz-E49E7C4B.hsd1.wa.comcast.net)
[10:18:51] *** Joins: Earnestly (earnest@88884C6.A3735F9C.39C00A7A.IP)
[10:20:12] *** Quits: andreypopp (andreypopp@moz-7261DC60.net) (Quit: andreypopp)
[10:22:58] *** Parts: DeTeam (DeTeam@92C799C.31715274.F5F3AF2.IP) ()
[10:31:29] *** Joins: lpy (lpy@7360AA58.F09091A8.1348A864.IP)
[10:35:57] *** Quits: sigma (sigma@moz-6E1846A2.range86-184.btcentralplus.com) (Client exited)
[10:41:32] *** Quits: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net) (Ping timeout)
[10:43:10] *** Joins: arrrrrrrrr (arrrrrrrrr@moz-5A85AEE3.dynamic.qsc.de)
[10:44:18] <arrrrrrrrr> how about a "fail after first error" flag for rustc?
[10:45:56] <dbaupp> are you getting lots of "flow on" errors?
[10:46:48] <arrrrrrrrr> lots of macro expansions
[10:48:50] <arrrrrrrrr> but even before that get a "self does not implement X" and then further down in the same function another "Y does not implement Z"
[10:49:04] <arrrrrrrrr> I'd like it to fail after the first error
[10:49:13] <arrrrrrrrr> right now I have to pipe the output to head -15
[10:49:51] <arrrrrrrrr> and lose the pretty colors in the process :(
[10:55:03] *** Quits: klaus (koz@moz-E49E7C4B.hsd1.wa.comcast.net) (Quit: klaus)
[10:55:29] <arrrrrrrrr> I want to implement a method for ~[MyType]. Wat do?
[10:55:46] <dbaupp> that needs a trait
[10:55:55] <dbaupp> or a wrapper struct
[11:05:38] *** Joins: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP)
[11:05:50] <arrrrrrrrr> why don't stack variables cast to ~ or & when necessary?
[11:07:19] *** flaper87 is now known as flaper87|afk
[11:08:06] <dbaupp> ~ is an allocation
[11:08:22] <dbaupp> so "casting" to ~ could be very expensive
[11:08:26] <arrrrrrrrr> I know
[11:09:08] <arrrrrrrrr> but a function that takes & also takes ~
[11:09:17] <dbaupp> that's because & and ~ are both pointers
[11:09:31] <dbaupp> so "borrowing" a pointer to a different form of pointer is very cheap
[11:09:49] <arrrrrrrrr> why not implicit cast from stack variables to pointers?
[11:09:51] <arrrrrrrrr> that 's the question
[11:09:59] <dbaupp> (at runtime the borrowing operation is literally free; in the common case, ~ and & have the saem representation)
[11:10:11] <dbaupp> for ~ it is because Rust aims to not have implicit expensive operations
[11:10:19] *** Quits: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP) (Ping timeout)
[11:10:54] <dbaupp> for &, I don't really know; it seems like it would be possible without introducing any implicit expensive operations
[11:10:57] *** Joins: heftig (heftig@moz-B3E7564.dip0.t-ipconnect.de)
[11:11:22] <eddyb> dbaupp: different usage than C++ references
[11:11:33] <dbaupp> eddyb: why, though?
[11:11:35] <eddyb> but we already autoborrow for self
[11:11:41] <dbaupp> exactly
[11:12:00] <eddyb> and autoderef more than C++
[11:12:32] <dbaupp> the core team may've explicitly decided against auto-ref-ing arguments, but I'm not sure.
[11:12:40] <eddyb> (which actually doesn't do it at all)
[11:12:58] <dbaupp> https://github.com/mozilla/rust/issues/10504 fwiw
[11:13:13] *** Joins: trecer (trecer@moz-36BEFC79.hsd1.pa.comcast.net)
[11:14:54] *** Quits: trecer (trecer@moz-36BEFC79.hsd1.pa.comcast.net) (Ping timeout)
[11:16:27] <arrrrrrrrr> https://gist.github.com/anonymous/8003373
[11:16:30] <arrrrrrrrr> what's going on here
[11:17:42] <dbaupp> arrrrrrrrr: are you running that code that is calling .get() in a different module?
[11:17:51] <arrrrrrrrr> yes
[11:18:03] <dbaupp> the trait needs to be in scope
[11:18:31] <arrrrrrrrr> how do I do this?
[11:18:35] <dbaupp> `use foo::Opts;`
[11:18:52] <arrrrrrrrr> thanks
[11:19:21] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[11:19:32] *** Joins: z0w0 (zack@moz-7B305DFB.lnse1.woo.bigpond.net.au)
[11:20:23] <arrrrrrrrr> can I do something like this:
[11:20:35] <arrrrrrrrr> f().on_error(|| return Err("err"));
[11:21:05] <arrrrrrrrr> where the return refers not to the closure but the function on_error is called in
[11:21:17] <dbaupp> no
[11:22:17] <eddyb> arrrrrrrrr: there isn't an easy way to do that
[11:22:25] <eddyb> just... think about it
[11:22:29] <arrrrrrrrr> some macro trickery?
[11:23:37] <eddyb> make f return a Result and match it - if it already does that (not sure where on_error is from), yes, you can write a macro to return early
[11:24:29] <arrrrrrrrr> so like this on_error!(f(), return Err("err"))
[11:24:37] <eddyb> sure
[11:24:44] <arrrrrrrrr> good enough
[11:24:56] <dbaupp> eddyb: s/there's isn't an easy way/it's entirely impossible in general/
[11:25:01] <eddyb> (though I'd rather channel an error message)
[11:25:28] <arrrrrrrrr> eddyb: from_str doesn't return an error so there is no error to pass in my case :(
[11:25:33] <eddyb> ah, I see
[11:26:35] <eddyb> dbaupp: but then there's a chance there's a trick in some language/implementation - it's kinda like unwinding or setjmp, now that I think of it - which makes that construct possible
[11:26:59] <eddyb> so I really can't risk being decisive :P
[11:27:32] <eddyb> it might come back to bite me later, but I usually leave enough wiggle room when I'm not sure what I'm talking about
[11:27:40] <dbaupp> heh
[11:28:06] <dbaupp> I guess it might be possible as long as you aren't allowed to return those closures from the function from which they are returning
[11:28:16] *** Joins: sigma (sigma@moz-6E1846A2.range86-184.btcentralplus.com)
[11:28:40] <eddyb> dbaupp: that's the easiest part, actually :P
[11:28:48] <arrrrrrrrr> no explicit cast from "return Err("err")" to "{ return Err("err") }" ?
[11:28:52] <arrrrrrrrr> *implicit
[11:28:53] *** Quits: dangets (dangets@moz-E9E4A77B.cpe.cableone.net) (Ping timeout)
[11:28:57] <eddyb> because any captures already impose that restriction
[11:29:03] <eddyb> arrrrrrrrr: cast? what do you mean?
[11:29:14] <arrrrrrrrr> expected { but found return
[11:29:14] <eddyb> they are both expressions
[11:29:24] <eddyb> arrrrrrrrr: in what context? a macro?
[11:29:30] <arrrrrrrrr> $f:expr
[11:29:35] <arrrrrrrrr> no stop
[11:29:36] <arrrrrrrrr> $f:block
[11:29:38] <arrrrrrrrr> this
[11:29:54] <eddyb> blocks need the {...}, that's why they are blocks
[11:30:03] <arrrrrrrrr> not in match :)
[11:30:06] <eddyb> arrrrrrrrr: just make it an expr and it will work with return
[11:30:21] <eddyb> arrrrrrrrr: match doesn't use blocks
[11:30:54] <eddyb> {return Err("err")} is just return Err("err")
[11:31:16] <arrrrrrrrr> works
[11:31:31] <dbaupp> eddyb: `|| return` doesn't have any captures
[11:31:53] <eddyb> dbaupp: yes, but you can mark it non-escape-able really easy
[11:32:04] <eddyb> might involve restricting its lifetime
[11:32:13] <dbaupp> eddyb: I guess you could regard it as "capturing" the return point
[11:32:43] <eddyb> but it has the same problem C++ try/catch has that we don't want in Rust
[11:32:52] <dbaupp> I guess weird stuff happens with destructors of intermediate stack frames, and so on... it's a little like try catch
[11:32:55] <dbaupp> yeah
[11:33:09] <eddyb> it's *exactly* like try/catch
[11:33:31] <dbaupp> in any case, I really just want `return` to be able to return early from a closure itself
[11:33:48] <dbaupp> (now that the `for` loops isn't doing weird things to return there.)
[11:34:09] * eddyb wonders why nobody removed that lint already - maybe they're just busy with more important things
[11:34:17] <dbaupp> which lint?
[11:34:59] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[11:34:59] *** ChanServ sets mode: +o pnkfelix
[11:35:20] <eddyb> you can't use "return" in closures because it has something similar to a linting pass which checks if there's "return" in it, AFAIK
[11:35:27] <eddyb> (but you can't turn it off)
[11:36:03] <dbaupp> it's not just a lint, yes.
[11:36:19] <eddyb> but it's like one and you can just remove it
[11:36:56] <eddyb> dbaupp: specifically, in JS: {let token = {}; try { f().on_error(() => throw token); } catch(e) {if(e !== token) throw e; return Err("err");}}
[11:37:26] * dbaupp tries removing it
[11:37:29] *** Quits: pyon (user@F4DA2F11.BD7DB6F4.1C8C8CE9.IP) (Quit: ERC Version 5.3 (IRC client for Emacs))
[11:38:33] * dbaupp guesses we won't trans such a return properly
[11:38:52] *** Quits: eddyb (eddy@moz-68E0B7D0.residential.rdsnet.ro) (Ping timeout)
[11:41:29] *** Joins: eddyb (eddy@moz-68E0B7D0.residential.rdsnet.ro)
[11:42:07] <arrrrrrrrr> for s in [s1,s2].iter() {          <-- borrowed value does not live long enough
[11:42:10] <arrrrrrrrr> fix when?
[11:42:22] <dbaupp> eddyb: fwiw, your example only showed that you can use exceptions to implement return-from-closures, not that you can implement exceptions with return-from-closures
[11:42:37] <dbaupp> arrrrrrrrr: when #3511 gets resolved
[11:42:58] *** Joins: pyon (user@F4DA2F11.BD7DB6F4.1C8C8CE9.IP)
[11:49:24] <arrrrrrrrr> http://static.rust-lang.org/doc/master/std/iter/index.html
[11:50:19] <arrrrrrrrr> well it's all gone
[11:51:15] <dbaupp> woah
[11:51:29] <dbaupp> http://static.rust-lang.org/doc/master/std/index.html still exists
[11:51:39] <arrrrrrrrr> useful :)
[11:51:55] <dbaupp> all the subfolders are gone
[11:51:57] <dbaupp> weird.
[11:51:58] <eddyb> dbaupp: well then
[11:52:09] <dbaupp> http://static.rust-lang.org/doc/master/extra/index.html huh
[11:52:57] <eddyb> anyways, my laptop's underclocked GPU overheated because of starbound running in the background... I really need to make this work somehow
[11:53:20] <dbaupp> eddyb: sit outside?
[11:53:38] <eddyb> haha. I can't do shit with gloves on
[11:54:10] <eddyb> I have this big fan here, and tempted to try it again, but I don't remember how I had it
[11:54:36] <eddyb> I think it was sitting on a side, with the bottom facing away from me
[11:55:02] <Ms2ger> Note to self: don't read "I can't shit with gloves on"
[11:55:48] <dbaupp> arrrrrrrrr: I found it! http://static.rust-lang.org/doc/master/iter/index.html
[11:55:51] *** Quits: z0w0 (zack@moz-7B305DFB.lnse1.woo.bigpond.net.au) (Client exited)
[11:56:18] <arrrrrrrrr> wow 
[11:57:01] *** Joins: skade (skade@moz-AC7A4F7F.sys11.net)
[11:57:02] <arrrrrrrrr> so can I now search extra and std at once?
[11:57:14] <eddyb> gaaaah chrome crashed when I was almost done crashing individual tabs. is there an easy way to crash all the individual tabs' processes?
[11:57:14] <arrrrrrrrr> nope :(
[11:57:32] *** Quits: pyon (user@F4DA2F11.BD7DB6F4.1C8C8CE9.IP) (Quit: ERC Version 5.3 (IRC client for Emacs))
[11:58:15] <dbaupp> arrrrrrrrr: https://github.com/mozilla/rust/issues/11021
[11:58:17] <dbaupp> arrrrrrrrr: no, it's a bug
[11:59:10] <arrrrrrrrr> how do I generate my own dogs?
[11:59:17] <arrrrrrrrr> :p docs
[11:59:25] <Jarrett> HA
[11:59:29] <dbaupp> have you built the compiler with `make` yourself?
[11:59:34] <dbaupp> (woof)
[11:59:37] <arrrrrrrrr> nope stdcat repo
[11:59:42] <dbaupp> ah
[11:59:47] <arrrrrrrrr> strcat :p
[11:59:51] <dbaupp> give me a second
[12:00:20] <dbaupp> the "easy" way is to just clone the rust and run `make`
[12:00:27] <dbaupp> but that will take a while
[12:03:05] <dbaupp> arrrrrrrrr: the second easiest way is to wait for me to upload a copy: http://www.ug.it.usyd.edu.au/~hwil7821/rust-docs/std/index.html
[12:03:13] <dbaupp> and http://www.ug.it.usyd.edu.au/~hwil7821/rust-docs/extra/index.html
[12:03:37] <arrrrrrrrr> thanks, that works
[12:03:39] <dbaupp> (or http://www.ug.it.usyd.edu.au/~hwil7821/rust-docs/docs.zip to get a local copy of a fairly recent snapshot of them.)
[12:06:05] *** Joins: brendan (brendaneic@35E90EE3.B8B12C49.396B22AD.IP)
[12:11:12] <eddyb> operation whirlwind in progress
[12:11:23] <eddyb> I might need to wear a hat inside
[12:11:27] *** Joins: pao (pao@moz-AF905E87.fbx.proxad.net)
[12:13:53] <arrrrrrrrr> please respect middle click in the docs
[12:14:08] <eddyb> arrrrrrrrr: search is broken that way, isn't it?
[12:14:15] <arrrrrrrrr> yes
[12:14:22] <eddyb> I hate when developers try to be extra clever
[12:15:11] <eddyb> dbaupp: 46°C, never been this low in the winter :D
[12:15:43] <eddyb> 44, even. but it chills my hands :S
[12:15:56] <dbaupp> arrrrrrrrr: it works (for me, at least) if you click on the actual `foo::bar::baz` part
[12:15:59] <dbaupp> eddyb: heh
[12:16:09] <dbaupp> eddyb: wear gloves too :P
[12:16:18] <eddyb> hmpf. *okay*
[12:16:19] <dbaupp> and just flail at the keyboard
[12:16:23] <eddyb> what do I do for a silly game
[12:16:46] <arrrrrrrrr> the search doesn't work for "drop" and it doesn't work for "clone" either ...
[12:16:52] <dbaupp> arrrrrrrrr: (feel free to file a bug about it though, it is annoying)
[12:17:02] <dbaupp> yeah, it is peculiar like that sometimes :/
[12:17:09] <eddyb> drop is hidden AFAIK :D
[12:17:33] <dbaupp> "type error: myparent is undefined"
[12:17:36] <eddyb> dbaupp: I can still type, but I'm getting to the point where it's really easy to press the wrong key :S
[12:17:37] <dbaupp> when searching for clone
[12:17:47] <arrrrrrrrr> can I get an iter that automatically clones the elements?
[12:17:51] <dbaupp> no
[12:18:27] <eddyb> 41°C. this is crazy
[12:22:00] <dbaupp> arrrrrrrrr: (to be clear, by "no" I mean "there is not one in the stdlib")
[12:24:43] *** Quits: skade (skade@moz-AC7A4F7F.sys11.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[12:26:07] *** Quits: pao (pao@moz-AF905E87.fbx.proxad.net) (Quit: pao)
[12:26:17] <cmr> it.map(|x| x.clone())
[12:26:19] <cmr> done :p
[12:26:32] *** Quits: Jarrett (chatzilla@moz-8211AC00.dhcp.nrwl.ca.charter.com) (Quit: ChatZilla 0.9.88-rdmsoft [XULRunner 1.9.0.17/2009122204])
[12:28:56] <arrrrrrrrr> can I convert a macro variable to a string? like printf(a##) in C.
[12:29:16] <cmr> stringify!(...)
[12:29:23] *** Joins: skade (skade@moz-AC7A4F7F.sys11.net)
[12:29:46] <arrrrrrrrr> nice
[12:30:25] *** Quits: skade (skade@moz-AC7A4F7F.sys11.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[12:30:34] *** Joins: klaus (koz@moz-E49E7C4B.hsd1.wa.comcast.net)
[12:30:59] <dbaupp> arrrrrrrrr: thanks for noticing that docs thing, it looks like it is a fundamental bug in the code :)
[12:34:52] <arrrrrrrrr> this is getting ridiculous
[12:34:59] <arrrrrrrrr> I have three mods A, B, C
[12:35:04] <arrrrrrrrr> A uses B, B uses C
[12:35:11] <arrrrrrrrr> why do I have to write mod C; in A?
[12:35:33] <cmr> you don't *have* to.
[12:35:33] <dbaupp> you don't
[12:35:44] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[12:36:00] <arrrrrrrrr> I get unresolved import in B without it
[12:36:02] <dbaupp> `mod A { mod B { mod C {} } }` do you have something like?
[12:36:10] <arrrrrrrrr> different files
[12:36:10] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[12:36:11] <dbaupp> oh, `use`
[12:36:20] <cmr> use self::C::foo;
[12:36:35] <dbaupp> (btw, `mod foo;` and `mod foo { <contents of foo.rs> }` are exactly the same.)
[12:36:40] <arrrrrrrrr> self works
[12:36:54] <cmr> import paths are global, self/super override that.
[12:37:54] *** Quits: dsirenko (mitra@8E712A0.54C21BA0.9F317420.IP) (Ping timeout)
[12:37:54] <dbaupp> You could also write `use B::C::foo`
[12:38:18] *** Joins: adridu59 (Mibbit@moz-E7A273CD.ac-paris.fr)
[12:40:19] *** Joins: Krymise (Nietzsche@moz-CA789EF5.nwrknj.fios.verizon.net)
[12:42:26] <arrrrrrrrr> I made command line parsing pretty :)
[12:42:27] <arrrrrrrrr> https://gist.github.com/anonymous/8004322
[12:42:29] <arrrrrrrrr> any comments?
[12:49:15] <ezyang> cmr, dbaupp: Heya, if either of you have some free cycles, I finished writing up an exposition of two borrowck bugs: http://blog.ezyang.com/?p=8652&shareadraft=baba8652_52b013b765f21 
[12:50:56] <dbaupp> arrrrrrrrr: looks pretty neat :)
[12:51:05] <dbaupp> ezyang: sure, reading now.
[12:51:27] <adridu59> dbaupp: do you know how to manage doc tests that have an input?
[12:51:55] <dbaupp> adridu59: afaik, you don't
[12:51:57] <adridu59> noticeably, do you know how to write stealth code in the doc? looks like # was used before but it doesn't work now
[12:52:11] <dbaupp> what do you mean?
[12:52:20] <adridu59> https://github.com/mozilla/rust/pull/10986/files#diff-1
[12:52:31] <adridu59> if you look at the old code
[12:53:15] <dbaupp> it's still used in the tutorial, e.g. https://github.com/mozilla/rust/blob/master/doc/tutorial.md#structs
[12:53:27] <dbaupp> vs http://static.rust-lang.org/doc/master/tutorial.html#structs
[12:54:00] *** Joins: killerswan (kevincantu@moz-CC0DC654.hsd1.ca.comcast.net)
[12:54:23] <dbaupp> I think you do need a space after the #, though
[12:54:28] <arrrrrrrrr> dbaupp: thanks
[12:54:52] <adridu59> I tried using # previously in my PR and bors said "expected item but found #
[12:54:52] <adridu59> and I had spaces iirc
[12:55:27] <dbaupp> weird
[12:55:35] <dbaupp> ezyang: looks good :)
[12:55:47] <ezyang> Sweet 
[12:56:02] <cmr> ezyang: typo, "Diagnosing borrows the last too" s/the/that
[12:56:03] <adridu59> I don't know how I can find back the log
[12:56:39] <cmr> ezyang: it's great, though, thanks for writing it!
[12:57:11] <dbaupp> adridu59: http://buildbot.rust-lang.org/builders/auto-mac-64-opt/builds/2998/steps/test/logs/stdio
[12:57:16] <ezyang> cmr: Thanks, fixing 
[12:57:51] <dbaupp> adridu59: (I found that my clicking on the " bors referenced this pull request from a commit " commits, going to the second parent and looking at the build logs there.)
[12:57:52] *** Quits: brendan (brendaneic@35E90EE3.B8B12C49.396B22AD.IP) (Ping timeout)
[12:58:04] <adridu59> thnks good to know
[12:58:21] <adridu59> says: example_program_2.rs:17:0: 17:1 error: expected item but found `#`
[12:58:39] <adridu59> not sure what it means
[12:58:41] <dbaupp> looks like that was an empty line, and so it didn't necessarily have a space after the hash
[12:59:10] <adridu59> can I find back old commits on Github and/or locally
[12:59:11] <adridu59> ?
[12:59:32] <dbaupp> https://github.com/mozilla/rust/commit/dcb16eeef37687039c6c682978e07f34adcec9c9#diff-31922448784d13fe3e7a5b25208f48f8R100
[12:59:45] <dbaupp> `git reflog`
[13:00:39] <adridu59> interesting, thanks
[13:00:44] *** Joins: maxli (maxli@moz-4D28BA20.student.cs.uwaterloo.ca)
[13:00:53] <adridu59> now I need to find how to spoof my bufferedreader
[13:04:37] <adridu59> dbaupp: when you do Path::new, does it check that the file exists?
[13:04:59] *** Joins: pyon (user@F4DA2F11.BD7DB6F4.1C8C8CE9.IP)
[13:06:56] *** Joins: canhtak (canhtak@moz-258236CD.wl.t.ulaval.ca)
[13:10:16] <dbaupp> adridu59: no
[13:10:40] *** Quits: eternaleye (eternaleye@moz-5668AFCB.hsd1.wa.comcast.net) (Ping timeout)
[13:10:43] <dbaupp> adridu59: Path::new just constructs a representation of a file path, it doesn't have to correspond to the actual files on the disk at all.
[13:11:21] <ezyang> r? https://github.com/mozilla/rust/pull/11025 
[13:12:49] <adridu59> dbaupp: thanks, still I don't see how I can spoof it unless I spoof the method itself
[13:13:11] *** flaper87|afk is now known as flaper87
[13:13:17] <ezyang> man, I wish building Rust wasn't such a pain 
[13:13:42] <dbaupp> ezyang: depending one what you're building it for, there are some tricks https://github.com/mozilla/rust/wiki/Note-testsuite
[13:13:50] * dbaupp <3 NO_REBUILD=1
[13:14:30] <ezyang> Huh, so I can edit libextra and then test it using my system rust? 
[13:14:50] <dbaupp> not quite
[13:14:59] <ezyang> Aw 
[13:15:04] <dbaupp> it uses the previously built rustc in `<arch>/stage2/bin`
[13:15:27] <dbaupp> (that is, using `NO_REBUILD=1`)
[13:15:56] <dbaupp> I believe that `rustc libextra/lib.rs` can work, possibly given some extra parameters.)
[13:16:55] <ezyang> ok, I'll give it a try 
[13:18:29] <ezyang> "error: unresolved name `Chan::new`". Need some package import? 
[13:18:39] <dbaupp> I guess your local rustc is too old
[13:18:52] <ezyang> what?! it's a nightly! 
[13:18:56] * dbaupp normally just runs `make check-stage2-std NO_REBUILD=1`
[13:19:03] <dbaupp> rust moves fast :P
[13:19:23] <arrrrrrrrr> ezyang: In the first example after "Borrow scopes should not always be lexical" you write that y is dead after *y = 1. Can you explain?
[13:19:35] <dbaupp> a big change to std::comm landed a few hours ago that isn't in the nightly yet (apparently), but is in your source
[13:19:40] <dbaupp> (recent clone/fetch?)
[13:19:43] <ezyang> arrrrrrrrr: 'dead' in the sense of a classic liveness analysis 
[13:19:48] <ezyang> yeah, I just fetched 
[13:19:56] <arrrrrrrrr> ezyang: not used anymore?
[13:19:59] <ezyang> Yup 
[13:22:04] *** Joins: skade (skade@moz-AC7A4F7F.sys11.net)
[13:28:32] <KokaKiwi> Heh, just me or the doc is broken? I've "Access Denied" at http://static.rust-lang.org/doc/master/std/io/index.html
[13:28:44] <KokaKiwi> (hi chan)
[13:29:00] <ezyang> I think that path is not right 
[13:29:10] <dbaupp> KokaKiwi: https://github.com/mozilla/rust/issues/11021
[13:29:33] <ezyang> oh, nvm 
[13:29:44] <dbaupp> KokaKiwi: (substitute docs for now: http://www.ug.it.usyd.edu.au/~hwil7821/rust-docs/std/index.html (and ../extra/.. too))
[13:29:54] <adridu59> KokaKiwi: salut!
[13:29:59] <KokaKiwi> dbaupp: Oh, thanks :o
[13:31:05] <adridu59> dbaupp: I've always wondered about these uni storage spaces and emails: do you keep them when you leave the university?
[13:31:29] <ezyang> Most unis, AFAICT, don't let you keep it 
[13:31:47] <adridu59> so it's supposed to be just to communicate with your teachers?
[13:32:05] <adridu59> because I often see people using their uni email adress as main one, weird
[13:32:16] <ezyang> PhD students seem to get teh better end of the stick 
[13:32:33] <adridu59> end of the stick, what do you mean?
[13:32:35] <dbaupp> adridu59: conveniently, i got information about my graduation today, and apparently, yes, I do keep my uni email; extremely unlikely I get to keep the website stuff.
[13:33:07] <ezyang> Often, PhD webspace is hosted by CS dept, and they'll keep it around for you after you graduate 
[13:34:01] <adridu59> that's cool, I have one myself but since I never went to the uni... :p
[13:34:33] <adridu59> huh, sorry for derailing the thread
[13:35:07] <adridu59> (I have cumulative diploma)
[13:35:07] <dbaupp> adridu59: was there a thread? :P
[13:35:08] *** Quits: Krymise (Nietzsche@moz-CA789EF5.nwrknj.fios.verizon.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[13:35:29] *** Joins: sankha93 (Instantbir@484A1B28.36E1639E.EFB84E89.IP)
[13:36:06] <ezyang> I notice that in some of the standard libraries, some recursive functions are not written using 'impl'. Is there a reason for this? 
[13:36:06] *** Quits: killerswan (kevincantu@moz-CC0DC654.hsd1.ca.comcast.net) (Quit: killerswan)
[13:36:21] <dbaupp> ezyang: oh, one thing, "bugs" might be a bit strong for those two borrowck limitations
[13:36:38] <dbaupp> (i.e. it's not clear that we'll be able to resolve them completely.)
[13:37:10] <dbaupp> not that it matters much
[13:37:15] <ezyang> Oh yeah, I briefly wondered about that, and then forgot to pick a better word 
[13:37:25] <ezyang> "Bug" is snappier than "limitation" 
[13:37:31] <Ms2ger> PhDs tend to get web space from their own department here, and those tend to be less eager to throw them out
[13:37:32] <dbaupp> ezyang: example of what you mean about recursive functions?
[13:37:55] <ezyang> Looking at libextra/treemap.rs, 'insert' is implemented as a top-level function 
[13:38:30] <dbaupp> don't know
[13:38:52] <dbaupp> they are just private implementation details
[13:39:24] <dbaupp> you'd have to ask strcat, since blame seems to suggest he wrote most of it
[13:39:34] <dbaupp> (or at least, was responsible for the curren structure.)
[13:40:14] <ezyang> ok 
[13:40:43] *** Joins: jhasse (jhass_000@moz-DA053938.wlan.uni-bremen.de)
[13:41:07] <adridu59> Ms2ger: I guess that they keep your publications online through?
[13:41:32] <ezyang> Oh, I see why, because itw ouldn't actually be appropriate 
[13:41:36] <Ms2ger> I think most publications are also somewhere central
[13:41:50] <dbaupp> ezyang: in what way?
[13:42:00] <jhasse> hi! Whenever I change something in libextra and rerun make, I need to wait over an hour for everything to recompile. Is that normal?
[13:42:10] <dbaupp> ezyang: you can have private methods in impls
[13:42:50] <dbaupp> jhasse: yes
[13:42:57] <dbaupp> jhasse: you can get around it though
[13:43:19] <ezyang> The type of self is not right 
[13:43:19] <dbaupp> jhasse: e.g. `make check-stage2-extra NO_REBUILD=1` will just build the extra test runner (with your changes) and run the tests
[13:43:36] <dbaupp> ezyang: oh, right
[13:43:39] * dbaupp missed that
[13:44:29] <dbaupp> jhasse: (adding NO_BENCH=1 to that is often nice too; since the benchmarks take a while to run too.)
[13:44:31] <jhasse> dbaupp, ah okay :) Is this documented somewhere? E.g. I want to rebuild only rustc stage 2 with my new libextra. Is that possible?
[13:44:42] <dbaupp> https://github.com/mozilla/rust/wiki/Note-testsuite
[13:44:49] <dbaupp> I don't think that is possible
[13:44:59] <dbaupp> you can skip half the bootstrap with...
[13:45:25] <dbaupp> make rustc-stage1
[13:45:51] <dbaupp> which puts a compiler (with all your changes) in `<build dir>/<arch>/stage1/bin`
[13:46:17] <ezyang> is there a way to twiddle #[feature(globs)] from command line? 
[13:46:17] <jhasse> dbaupp, cool, exactly what I was looking for. Thanks!
[13:46:26] <dbaupp> ezyang: no
[13:46:27] <adridu59> dbaupp: do you know by chance if the kate highlighting file is a good as our codemirror support?
[13:46:41] <dbaupp> adridu59: literally no idea about the quality of either of them
[13:46:50] <dbaupp> (unless github is using codemirror?)
[13:46:59] <Ms2ger> Then it's pretty terrible? :)
[13:47:12] *** Quits: Reisen (Reisen@moz-253289F.xen.prgmr.com) (NickServ (GHOST command used by Reiser))
[13:47:12] <adridu59> dbaupp: GitHub uses pygments
[13:47:26] <adridu59> but I mean in terms of Rust support
[13:47:32] <dbaupp> well, github highlights rust 0.4 or something; not bad, just old. :P
[13:47:54] <dbaupp> yeah, I meant I don't have any idea of the quality of the rust support for either
[13:47:56] <adridu59> someone could just update it, it's open source repository
[13:48:15] * dbaupp tried, but it's on bitbucket, so he ran back to the safety of github ;P
[13:48:45] <dbaupp> (well, there was some other problems, I don't remember what.)
[13:49:08] <adridu59> the thing I like about bitbucket is unlimited private repos, the thing I really dislike is the terrible ergonomy
[13:49:11] *** Joins: Reisen (m@moz-A0F67AD4.org)
[13:49:58] *** Joins: eternaleye (eternaleye@moz-5668AFCB.hsd1.wa.comcast.net)
[13:50:42] * cmr doesn't like either.
[13:50:48] <cmr> gitlab is pretty nice though
[13:51:02] <adridu59> well, the Github sample for rust doesn't look really up-to-date either https://github.com/github/linguist/commit/c7a155efefb720d8abf9eae1d8d9762968436944
[13:52:23] <adridu59> through it's no big deal, just needs to differenciate rust
[13:57:44] <ezyang> oh nice, borrow checker caught a bug 
[14:01:40] <dbaupp> ezyang: \o/
[14:03:01] *** Quits: canhtak (canhtak@moz-258236CD.wl.t.ulaval.ca) (Quit: canhtak)
[14:03:20] *** Quits: skade (skade@moz-AC7A4F7F.sys11.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[14:03:59] <adridu59> is `super` a keyword?
[14:04:19] <bstrie> adridu59: it used to be, at least... might be in the process of being removed
[14:04:23] *** Joins: mihneadb (mihneadb@B3BF1920.5A83FA76.501A7953.IP)
[14:04:23] <bstrie> not entirely sure
[14:05:19] <adridu59> what is it for?
[14:05:36] <dbaupp> it is used by `use`
[14:05:39] <bstrie> adridu59: it was for importing modules from sibling scopes, or something
[14:05:53] <adridu59> I see
[14:06:04] <dbaupp> `mod foo { use super::bar; } mod bar { ... }`
[14:06:18] <dbaupp> bstrie: s/was/is/
[14:06:29] <dbaupp> (although pcwalton seems keen on removing it)
[14:06:31] <bstrie> dbaupp: isn't it being removed? that was the impression that I got from last week's meeting
[14:06:52] <bstrie> maybe we could replace it with the double dot :P
[14:06:54] <dbaupp> bstrie: yes, same
[14:07:05] <bstrie> `mod foo { use ..::bar; } mod bar { ... }`
[14:07:28] <dbaupp> we could just hvae `use /std/vec;` and then the relative imports become obvious
[14:07:57] <adridu59> I was wondering: what's the big deal with Java?
[14:08:09] <adridu59> I mean, why do people use that?
[14:08:26] <bstrie> dbaupp: as much as I prefer the look of / vs :: for modules, it would be weird to have foo/bar in use statements and foo::bar elsewhere. and I don't think we can make / unambiguous
[14:08:27] *** Joins: skade (skade@moz-AC7A4F7F.sys11.net)
[14:08:56] <bstrie> adridu59: people use java because back in the '90s it was legitimately an improvement over C++
[14:09:11] <bstrie> in terms of providing safety and sanity
[14:10:22] <bstrie> despite the fact that java made some design decisions that were questionable in retrospect, and despite how massively over-hyped it was by Sun, it *was* a step forward
[14:10:56] <adridu59> seems too verbose to me, and the no pointers thing... seems like they took the excessive opposite
[14:11:15] <bstrie> adridu59: stop looking at it that way! :)
[14:11:20] <adridu59> also, why JVM? what's the advantage of having cross-platform code when you still have to have a VM?
[14:12:00] <adridu59> I just don't understand how it can be a major language of today (well, there's Android)
[14:12:16] <adridu59> is it because virtualization brings security?
[14:12:42] <bstrie> adridu59: you're overthinking this
[14:12:59] <adridu59> bstrie: what do you mean?
[14:13:14] *** Quits: eternaleye (eternaleye@moz-5668AFCB.hsd1.wa.comcast.net) (Ping timeout)
[14:13:32] <bstrie> adridu59: people use java because it is really really really good at putting up barriers to bad programmers writing bad code
[14:13:39] <bstrie> it's not perfect at it! you can still write bad code in it
[14:13:41] <bstrie> really bad code
[14:13:44] <bstrie> but compare perl
[14:13:46] <bstrie> or C++
[14:13:50] <bstrie> anything, really
[14:13:56] <bstrie> it's top of the class
[14:14:06] <bstrie> using java is NOT a technical decision
[14:14:08] <bstrie> it's a social one
[14:15:24] <adridu59> VM itself adds overhead or not?
[14:15:29] <bstrie> yeah, sure
[14:15:35] <bstrie> but nobody who uses java cares about that
[14:15:41] <bstrie> if they did, they wouldn't be using java
[14:16:24] *** Quits: jhasse (jhass_000@moz-DA053938.wlan.uni-bremen.de) (Quit: Verlassend)
[14:16:26] <adridu59> yea, like someone writing an OS mustn't be scared about that
[14:16:30] <adridu59> but what's the advantage of running is a VM?
[14:17:14] <adridu59> also Java library seems bloated, just like C++'s
[14:18:19] <bstrie> adridu59: *theoretically*, some people think that JITs can provide faster runtime speed than natively-compiled code
[14:18:37] <adridu59> but isn't jit essentially the same as native?
[14:18:47] <bstrie> though nobody's ever written a compiler smart enough to demonstrate this. at least not without requiring like 10x the memory of AOT code
[14:19:05] <adridu59> basically if I started arguing about this it's because I came over this https://github.com/Frege/frege
[14:19:08] <bstrie> adridu59: *theoretically*, a JIT allows you to perform optimizations based on runtime information that is unavailable to AOT code
[14:19:18] <adridu59> and I thought why Haskell in JVM when you have Haskell
[14:19:19] <bstrie> again, nobody's ever demonstrated this reliably
[14:19:30] <adridu59> I see
[14:19:45] <adridu59> (besides running on unsupported platforms to Haskell)
[14:19:52] <bstrie> adridu59: haskell on the JVM specifically may just be because they people want to use libraries that are written in java, but also want to write their own code in haskell
[14:19:57] <bstrie> but, I have no idea
[14:20:02] <bstrie> maybe it's just an academic exercise
[14:22:12] <bstrie> adridu59: "Existing Java Classes and Methods can be used seamlessly from Frege." <-- this is likely the motivation
[14:22:30] <adridu59> yeah, looks like it
[14:23:06] <adridu59> would a language like Go be a better bet today for people who traditionally use Java? (if you don't consider the learning curve)
[14:23:26] <bstrie> ...that's a complicated topic :)
[14:23:42] <bstrie> Go is a great migration path from java if you are being *forced* to write java by outside pressures
[14:23:56] <bstrie> but a lot of the people who write java actually *like* the everything-is-an-object approach
[14:24:09] <adridu59> I hate that :)
[14:24:36] <bstrie> also, you'll need to find replacements for all the java libs that you're used to
[14:24:36] <adridu59> plus object-based representation doesn't follow how code is represented when compiled (in contrary to say, C)
[14:25:11] <adridu59> is object-oriented really simpler to use? in my experience it's not
[14:25:22] <adridu59> s/use/think
[14:25:45] <bstrie> adridu59: are you familiar with the structure of the US government?
[14:26:02] <adridu59> not much
[14:26:25] <bstrie> adridu59: the US government is structured, intentionally, to make passing laws a long, arduous, and grueling process
[14:26:32] <adridu59> aha
[14:26:37] <bstrie> java is structured in much the same way
[14:26:41] <bstrie> it's not about being simpler
[14:26:45] *** Quits: Blei (philipp@moz-B2F9E4BD.cust.bluewin.ch) (Quit: WeeChat 0.4.2)
[14:26:50] <adridu59> it's so that you can think more?
[14:27:10] <bstrie> the point is to force everyone who is working on a project into thinking the same way
[14:27:16] <bstrie> it's not about self-expression
[14:27:46] <adridu59> so you can oppose object-oriented to programmer-oriented?
[14:27:53] <bstrie> it's about enforcing standards by making the language not expressive enough to permit alternative solutions to problems
[14:28:13] <adridu59> wow, sounds scary
[14:28:16] <cmr> adridu59: rust is object oriented.
[14:28:26] <cmr> every time you call a method.
[14:28:40] <adridu59> how so?
[14:29:00] <bstrie> cmr: aaaaagh, don't call us that :P
[14:29:08] <bstrie> that phrase is basically meaningless
[14:29:13] <cmr> bstrie: don't misrepresent java!
[14:29:23] <adridu59> the only OO programming (I thought) I've done was implementing RSA algorithm in Java with an Object called "RSA" and actuallly it seemed counter-intuitive to implement for me
[14:29:54] <adridu59> in terms of structuring
[14:30:04] <bstrie> cmr: java was the programming language I was reared on, and I wielded it like a true shitty enterprise programmer. I'll represent it any way that I wish!!
[14:30:07] <pyon> What is the difference between std::io::file_writer and std::io::mk_file_writer?
[14:30:24] <adridu59> oh subjectivity at it's best
[14:30:26] *** Quits: adridu59 (Mibbit@moz-E7A273CD.ac-paris.fr) (Quit: http://www.mibbit.com ajax IRC Client)
[14:30:39] <cmr> pyon: both have since been removed
[14:31:09] <pyon> cmr: The alternative being?
[14:31:21] <cmr> pyon: std::io has been rewritten entirely.
[14:31:38] <cmr> std::io::fs::File is the new hotness.
[14:32:31] <dbaupp> cmr: s/fs::/
[14:32:45] <pyon> http://static.rust-lang.org/doc/master/std/io/index.html -- I get an "Access Denied" error
[14:32:51] <cmr> dbaupp: std::io::File is just a reexport
[14:33:09] <dbaupp> cmr: yes, I know
[14:33:23] <dbaupp> pyon: it's broken atm :( you can use http://www.ug.it.usyd.edu.au/~hwil7821/rust-docs/std/index.html
[14:33:31] <pyon> ty
[14:35:09] <bstrie> acrichto: so we got a speedup from using LLVM's built-in archive reading abilities? would we get another speedup from adding archive-writing abilities to llvm and using those as well?
[14:37:18] <pyon> Mmm... Apparently there is an implementation of both std::io::Reader and std::io::Writer for std::io::fs::File. If I try to use a std::io::Writer method on a file that has been opened for reading only, I get a *runtime* error, right?
[14:37:31] <cmr> pyon: correct.
[14:40:32] <pyon> Sounds like a bad thing. Even in C++ std::ifstreams and std::ofstreams are different from each other. I guess I will just have to be careful. :-(
[14:42:34] *** Quits: lpy (lpy@7360AA58.F09091A8.1348A864.IP) (Client exited)
[14:43:16] <cmr> well if you want one or the other you should probably be generic over Reader/Writer
[14:43:18] * ChrisMorgan isn't eager about it either
[14:43:30] * cmr isn't either
[14:44:07] * ChrisMorgan runs `echo 'fn main(){}' | time rustc -` on his ARM tablet
[14:45:11] * dbaupp /me
[14:45:20] <ChrisMorgan> Erk, this `time` package does indeed seem to be parbroken…
[14:45:40] <dbaupp> gnu time is weird
[14:46:15] <ChrisMorgan> Looks like it might just be broken when using pipes.
[14:46:40] * ChrisMorgan tries `time (echo 'fn main(){}' | rustc -)` instead
[14:47:11] <ChrisMorgan> There, that's more the contents I expected (rather than junk text): 19.27 seconds.
[14:48:11] <ChrisMorgan> Second measurement: 18.984 seconds. Third measurement: 19.402 seconds.
[14:48:42] *** Quits: refold (gman@moz-42D68426.a258.priv.bahnhof.se) (Quit: leaving)
[14:48:43] <dbaupp> 20 seconds o_O
[14:49:10] <cmr> ChrisMorgan: how does --parse-only fare?
[14:49:22] <dbaupp> and --no-trans
[14:49:22] <bstrie> wait wait wait, what??
[14:49:29] <bstrie> how does it take 20 seconds to compile an empty program
[14:49:40] <ChrisMorgan> cmr: just under 8 seconds
[14:49:41] <bstrie> what are you doing weird there
[14:49:49] <cmr> very ouch
[14:50:02] <ChrisMorgan> bstrie: running on a 1GHz ARM processor with very slow storage?
[14:50:10] <bstrie> ah I see
[14:50:52] <ChrisMorgan> dbaupp: --no-trans doesn't effect a noticeable reduction in the time
[14:51:00] <cmr> really?
[14:51:03] <cmr> that's impressive.
[14:51:47] * ChrisMorgan isn't certain of what --no-trans does
[14:51:59] <cmr> doesn't run trans or llvm
[14:52:24] <ChrisMorgan> `time rustc --help`: 9 seconds first time, then 5, then 2, then .2, at which it stays. Weird.
[14:53:40] <ChrisMorgan> It seems to have decided to do rustc fast now. --parse-only --no-trans has just worked its way down by degrees from 0.8 seconds to 0.11-0.13 seconds. And still --no-trans is having no effect.
[14:53:55] *** Quits: mihneadb (mihneadb@B3BF1920.5A83FA76.501A7953.IP) (Quit: Bye)
[14:54:01] <dbaupp> -Z time-passes
[14:54:03] <cmr> --no-trans should not be used with --parse-only
[14:54:16] <cmr> --parse-only stops after parsing, so not running trans is going to do nothing :p
[14:54:30] <ChrisMorgan> That's what I thought, but it's what I took dbaupp to be suggesting.
[14:55:00] <dbaupp> whoops, sorry for the confusion
[14:55:03] <ChrisMorgan> (But full compilation of the empty crate then takes 14 seconds… 10… 8.6… yeah, it's rather unpredictable.)
[14:55:37] <ChrisMorgan> --no-trans: 3.5 seconds first time, 1 second ±10% for subsequent invocations.
[14:56:32] <ChrisMorgan> So does --no-trans mean that I can check that the code is all valid and correct and won't cause errors, without having to wait the full time?
[14:57:11] * ChrisMorgan likes the sound of that for this device and must start using it
[14:57:17] <cmr> yep!
[14:57:29] <cmr> generally I leave in an unused important and know to stop when I see lints happen...
[14:57:38] * cmr ^C's like a boss
[14:57:42] <bstrie> haha
[14:57:49] <bstrie> #rustprotips
[14:58:46] <ChrisMorgan> cmr: I was wondering about that very thing yesterday—thinking that sometimes it'd be nice if the compiler would print a line "Yay, it's all good, now I'll actually make the binary/library/what you wanted for ya"
[14:59:05] <cmr> s/important/import/
[15:00:08] <bstrie> ChrisMorgan: http://news.php.net/php.internals/70691
[15:00:12] * ChrisMorgan wonders how much of a difference this metadata reading patch will improve his compilation times. One second is probably a bit much to expect?
[15:00:33] <bstrie> ChrisMorgan: it will improve it much more if you start stuffing in useless metadata
[15:00:48] <ChrisMorgan> bstrie: I saw that yesterday when you mentioned it. It is rather impressive!
[15:01:13] <bstrie> that must have been someone else, I just saw this right now
[15:01:22] <bstrie> unless I am tyler durden, and live a secret life at night
[15:01:28] <ChrisMorgan> Hmm, thought it was you.
[15:02:04] * ChrisMorgan thinks it demonstrates that when PHP was written, the developer was rather completely clueless—even a XOR-all-bytes-in-the-name would do better!
[15:02:11] <cmr> ... because using strlen and tuning your function names is totally easier than writing a super simple crappy hash :p
[15:03:34] <dbaupp> ChrisMorgan: no it wouldn't
[15:04:27] <ChrisMorgan> Talk about premature optimisation [especially in the wrong direction] biting you badly—many, many years later, tens of thousands of developers are still being bitten by the bad choices it caused.
[15:04:28] <dbaupp> well, it's not entirely obvious that it would, since ASCII doesn't cover the full 256 values uniformly
[15:04:54] <ChrisMorgan> dbaupp: and you think method names have as much variation?
[15:05:39] * ChrisMorgan thought briefly about the problem yesterday and decided XORing all bytes in the name would be the first approach he would take—knowing it to still be a fairly poor hash because of only [a-z0-9_] being used.
[15:06:10] <ChrisMorgan> s/method names/method name lengths/
[15:07:26] <dbaupp> the xor would range from 0-26
[15:07:39] <dbaupp> method lengths are more flexible than that
[15:07:48] <dbaupp> oh, wait, I didn't include _ and 0-9.
[15:07:50] *** Joins: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net)
[15:07:52] <ChrisMorgan> …!
[15:08:20] <ChrisMorgan> I don't think that even Rasmus made function names longer than 26 bytes.
[15:09:15] *** Joins: Kruppe (user@moz-90E4C5E6.net.uwaterloo.ca)
[15:09:30] <ChrisMorgan> dbaupp: actually, the XOR would range from 0 to 127, though it wouldn't be an even distribution.
[15:10:26] <dbaupp> ChrisMorgan: no, not with those bytes
[15:10:48] <ChrisMorgan> Sorry, I tell a lie again, having forgotten a detail I recalled earlier—the XOR would use the full byte size, because the eighth byte would be "is the length even?".
[15:10:55] <ChrisMorgan> (Or rather, odd.)
[15:11:29] <dbaupp> just a-z0-9_ misses: 32, 33, 34, 35, 36, 63, 96, 97, 98, 99, 100, 101, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127
[15:12:08] <dbaupp> eighth byte?
[15:12:20] <ChrisMorgan> bit
[15:12:47] *** Quits: Kruppe (user@moz-90E4C5E6.net.uwaterloo.ca) (Ping timeout)
[15:14:16] *** Quits: tcreate (tcreate@7C181A70.200CF5B8.9D2C3D3E.IP) (Ping timeout)
[15:16:12] *** Joins: trecer (trecer@moz-36BEFC79.hsd1.pa.comcast.net)
[15:17:54] *** Quits: trecer (trecer@moz-36BEFC79.hsd1.pa.comcast.net) (Ping timeout)
[15:19:23] <ChrisMorgan> Hang on… I'm not sure quite why I was thinking that about XOR. (Somehow I was thinking 0 ^ 0 = 1—I had XOR back to front in my mind.)
[15:20:09] <ChrisMorgan> dbaupp: why are we discussing the relative merits of insufficient hash functions when we should both be in bed? It's all your fault I'm still up at 2:20am now :P
[15:22:07] * Ms2ger kicks ChrisMorgan and dbaupp 
[15:23:41] *** Quits: skade (skade@moz-AC7A4F7F.sys11.net) (Connection reset by peer)
[15:23:55] *** Joins: skade (skade@moz-AC7A4F7F.sys11.net)
[15:24:26] *** Joins: metasyntax (tvenable@moz-63D9B3D.med-web.com)
[15:26:11] *** Joins: Kruppe (user@moz-253119B0.esg.uwaterloo.ca)
[15:26:42] *** Joins: bjustin (bjustin@moz-8FC28563.sierrabravo.net)
[15:28:14] *** Quits: sellout (Adium@moz-AE26682A.hlrn.qwest.net) (Quit: Leaving.)
[15:31:43] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Ping timeout)
[15:32:57] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[15:32:57] *** ChanServ sets mode: +o pnkfelix
[15:39:13] *** Joins: sellout (Adium@moz-AE26682A.hlrn.qwest.net)
[15:40:06] *** Joins: ianj (ianjneu@moz-7BA002E.hsd1.ma.comcast.net)
[15:41:44] *** Joins: lpy (lpy@12172131.F09091A8.1348A864.IP)
[15:43:44] *** Quits: Ms2ger (Ms2ger@BB191E51.D97EE64B.F15B0BB3.IP) (Input/output error)
[15:44:21] *** Quits: smarter (smarter@moz-9C03B7C7.cust.bluewin.ch) (Ping timeout)
[15:45:26] *** Joins: Ms2ger (Ms2ger@BB191E51.D97EE64B.F15B0BB3.IP)
[15:45:36] <bstrie> I think I'm done reading hacker news comments
[15:45:39] <bstrie> I can't do it anymore
[15:45:58] <bstrie> someone else needs to monitor for mentions of rust
[15:46:08] <cmr> do you do that?
[15:46:10] <cmr> why?
[15:46:13] <cmr> and how?
[15:46:18] <bstrie> because I am a masochist, apparently
[15:46:24] <bstrie> it's just... so bad
[15:46:29] <bstrie> everyone is so delusional, all the time
[15:46:31] <bstrie> and it sucks
[15:46:37] <bstrie> because sometimes really smart people are there saying really smart things
[15:46:51] <bstrie> like pcwalton has really incredible and intelligent comments there all the time
[15:46:59] <bstrie> but then it just gets swept away in a sea of shit
[15:47:11] <bstrie> cmr: there's a search function at the bottom of the page
[15:47:20] <bstrie> I search for "rust" then sort by date
[15:47:21] <cmr> fancy that
[15:48:49] *** Joins: apoelstra (username@moz-C92A9641.sw.biz.rr.com)
[15:49:50] *** Joins: rca (rcatolino@moz-3ED58F2C.adsl.proxad.net)
[15:50:12] *** Joins: tcreate (tcreate@7C181A70.200CF5B8.9D2C3D3E.IP)
[15:56:19] *** Joins: trecer (trecer@moz-36BEFC79.hsd1.pa.comcast.net)
[15:57:39] *** Quits: trecer (trecer@moz-36BEFC79.hsd1.pa.comcast.net) (Input/output error)
[15:58:09] *** Joins: bytewise (bytewise@moz-B3FA4F1E.adsl.alicedsl.de)
[16:00:37] *** Quits: tcreate (tcreate@7C181A70.200CF5B8.9D2C3D3E.IP) (Client exited)
[16:01:18] *** Joins: AvianFlu (AvianFlu@moz-723527FF.nycmny.fios.verizon.net)
[16:03:11] *** Joins: trecer (trecer@moz-36BEFC79.hsd1.pa.comcast.net)
[16:05:53] *** Joins: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net)
[16:06:27] *** Joins: andreypopp (andreypopp@moz-7261DC60.net)
[16:08:19] *** Joins: smarter (smarter@moz-9C03B7C7.cust.bluewin.ch)
[16:12:46] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[16:13:16] *** Joins: autra (augustin@A14DAE84.7F753DD1.EE2CA32B.IP)
[16:18:05] *** Joins: tcreate (tcreate@moz-1A21C25B.olin.edu)
[16:19:17] <bstrie> what is stream() called nowadays
[16:19:24] <bstrie> i.e. how do I get a port nd a chan
[16:21:23] <cmr> Chan::new
[16:22:40] <bstrie> thanks
[16:23:10] <bstrie> trying to figure out if http://joearms.github.io/2013/11/21/My-favorite-erlang-program.html is possible in rust
[16:24:49] *** Joins: jvns (bork@87D98E32.4046EB22.428F94DD.IP)
[16:26:19] *** Quits: lpy (lpy@12172131.F09091A8.1348A864.IP) (Quit: Leaving...)
[16:27:27] <bstrie> not that I know erlang at all, mind you
[16:30:27] *** Quits: sk (sk@9E6B574B.EB2AA036.2CAF0D3B.IP) (Quit: Leaving)
[16:33:30] *** Quits: xitology (xi@85437D54.5AFA3E4.CEDFC552.IP) (Quit: Ex-Chat)
[16:40:36] <jvns> the Rust docs are down? http://static.rust-lang.org/doc/master/std/vec/index.html
[16:41:02] <jvns> oh maybe that page has just disappeared
[16:41:22] <jvns> maybe they need to be regenerated?
[16:50:49] <olsonjeffery> yeah im getting the same error
[16:50:52] <olsonjeffery> the base index.html is there
[16:50:58] <olsonjeffery> but all modules in std error out
[16:52:14] *** Joins: synackse (synackse__@moz-DFB8ED3B.lightspeed.wepbfl.sbcglobal.net)
[16:52:47] <olsonjeffery> s3 access denied
[16:52:55] *** Joins: eholk (eholk@moz-BA312F07.crest.iu.edu)
[16:53:23] <cmr> https://github.com/mozilla/rust/pull/11030
[16:53:29] <cmr> someone r+ and the docs will be back :P
[16:53:42] <cmr> jack: ^
[16:53:43] *** Quits: trecer (trecer@moz-36BEFC79.hsd1.pa.comcast.net) (Quit: Computer has gone to sleep.)
[16:54:04] *** Joins: trecer (trecer@moz-36BEFC79.hsd1.pa.comcast.net)
[16:54:10] <olsonjeffery> cmr: so verifying doc generation isn't a part of the build?
[16:54:15] <cmr> olsonjeffery: I'm adding tests now
[16:54:18] <cmr> but no
[16:54:42] *** Joins: jeaye (Jeaye@moz-34FEF2BB.hsd1.ca.comcast.net)
[16:54:56] <jvns> I'm trying to call a method like this: "Vec::<u8>with_capacity(len);", but it doesn't work. What's the right way to write this?
[16:55:15] <cmr> jvns: Vec::<u8>::wi...
[16:55:20] <jvns> aaaa
[16:55:47] *** Quits: trecer (trecer@moz-36BEFC79.hsd1.pa.comcast.net) (Ping timeout)
[16:56:10] <jack> cmr: r+
[16:59:23] <jvns> cmr: thanks :)
[16:59:43] *** Joins: jdm (jdm@moz-AC9499B2.cable.teksavvy.com)
[16:59:44] *** ChanServ sets mode: +o jdm
[16:59:49] <jvns> man but why can't I index my Vec. what is a vec supposed to do but be indexed! :)
[17:04:03] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[17:05:30] <acrichto> bstrie: sadly LLVM does not have archive-writing abilities, otherwise I can imagine that it would definitely be a speedup!
[17:06:32] <mark_edward> ChrisMorgan, ping
[17:07:37] *** Joins: DeTeam (DeTeam@moz-2B3D845F.dyn.broadband.iskratelecom.ru)
[17:08:24] *** Quits: robn (robn@moz-76B0302C.static.internode.on.net) (Ping timeout)
[17:11:11] *** Joins: trecer (trecer@moz-36BEFC79.hsd1.pa.comcast.net)
[17:11:13] *** Quits: trecer (trecer@moz-36BEFC79.hsd1.pa.comcast.net) (Input/output error)
[17:11:14] *** Joins: trecer (trecer@moz-36BEFC79.hsd1.pa.comcast.net)
[17:13:08] *** Joins: hoverbear (hoverbear@EBFA78B5.F19E5E7B.E74D50F2.IP)
[17:13:17] *** flaper87 is now known as flaper87|afk
[17:14:22] *** Quits: glandium (glandium@moz-A09032B1.kimsufi.com) (Broken pipe)
[17:16:21] <jvns> I'm trying to create a new array and return it from a function here: https://gist.github.com/jvns/d5815e8b2dd7812642d3, with zero success. Do I need to copy it to return it? How can I assign to it?
[17:16:56] <benh> Don't slice it, you need to return the ~[u8]
[17:16:59] <cmr> jvns: you're allocating a vector and then trying to return a pointer to it.
[17:17:15] <benh> A &[u8] is a borrow dependent on the borrowee's lifetime, which is limited to the function
[17:17:16] <cmr> jvns: but, that vector will be freed when the function returns, leaving a dangling pointer.
[17:17:19] <jvns> cmr: yeah! I see why it's wrong, but I don't know how to make it right
[17:17:36] <cmr> return Vec<u8>
[17:17:46] <benh> oh, not ~, sorry
[17:17:56] * benh needs to look closer :(
[17:18:25] <jvns> okay amazing
[17:18:30] <jvns> how can I assign to it?
[17:18:43] <cmr> there should be an as_mut_slice
[17:18:52] <jvns> I tried "let mut digits = Vec::<u8>::with_capacity(len);"
[17:18:59] <jvns> why doesn't that work?
[17:19:35] <cmr> use as_mut_slice and assign into that
[17:19:52] <mark_edward> wait have vectors been moved into the libraries?
[17:19:58] <cmr> mark_edward: no, this is rust-core
[17:20:09] <mark_edward> cmr, oh ok, thanks
[17:20:55] <jvns> cmr: if I use as_mut_slice, I get "error: cannot borrow `digits` as immutable because it is also borrowed as mutable"
[17:21:02] *** Quits: sankha93 (Instantbir@484A1B28.36E1639E.EFB84E89.IP) (Ping timeout)
[17:21:17] <jvns> and "error: cannot move out of `digits` because it is borrowed"
[17:21:21] <jvns> when I try to return it 
[17:21:23] <cmr> jvns: oh, take the length first.
[17:21:26] <cmr> also add a scope
[17:21:28] <benh> You might need to juggle the borrows a bit and introduce an extra scope
[17:21:34] *** Joins: sbalmos (quassel@CA5677B6.576D0C1.ED2EFC1B.IP)
[17:21:36] <cmr> { ... mutate digits in here ... } return digits;
[17:21:36] <jvns> taking the length first helps
[17:21:56] <olsonjeffery> jvns: say.. if you get multiple borrow errors.. then split borrows into scopes and return the data you want access to from them
[17:22:05] <jvns> the scope works!
[17:22:11] <olsonjeffery> s/say/yeah/
[17:22:24] <benh> (rightward drift! oh no!)
[17:22:27] *** Joins: adridu59 (Mibbit@moz-E1FF077C.rev.numericable.fr)
[17:22:43] <olsonjeffery> benh: to be fair, its the lesser evil
[17:22:51] <cmr> :q
[17:22:54] <cmr> bah
[17:22:55] <olsonjeffery> because the alternative is exposing a callback that provides a mut pointer
[17:23:10] <jvns> this memory safety business is kind of hilarious because my free() function doesn't do anything =)
[17:23:15] <olsonjeffery> which is definitely in rightward drift territory
[17:23:24] <jvns> well I guess memory safety is more than preventing leaks
[17:26:07] *** Quits: trecer (trecer@moz-36BEFC79.hsd1.pa.comcast.net) (Quit: Computer has gone to sleep.)
[17:26:28] *** Joins: trecer (trecer@moz-36BEFC79.hsd1.pa.comcast.net)
[17:27:36] *** Joins: nano (nano@moz-ED77243C.superkabel.de)
[17:27:49] *** Quits: Reisen (m@moz-A0F67AD4.org) (Quit: >:o)
[17:28:12] *** Quits: trecer (trecer@moz-36BEFC79.hsd1.pa.comcast.net) (Ping timeout)
[17:28:39] <cmr> jvns: leak prevention is easy, race conditions are the hard part.
[17:28:52] <jvns> that makes sense
[17:29:04] <jvns> I reeeeally need to learn about concurrency sometime
[17:31:44] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[17:32:12] *** Joins: a_m0d|home (a_m0d@moz-3E21531B.acanac.net)
[17:32:27] *** Joins: dherman (dherman@moz-DFAA4E15.p2p.sfo1.mozilla.com)
[17:32:27] *** ChanServ sets mode: +ao dherman dherman
[17:33:08] *** Quits: carter (carter@moz-3589B90B.c.ircrelay.com) (Ping timeout)
[17:33:54] *** Joins: Reisen (m@moz-A0F67AD4.org)
[17:34:50] *** Quits: indirect (indirect@moz-3589B90B.c.ircrelay.com) (Ping timeout)
[17:34:51] *** Quits: arrrrrrrrr (arrrrrrrrr@moz-5A85AEE3.dynamic.qsc.de) (Ping timeout)
[17:35:13] *** Quits: skade (skade@moz-AC7A4F7F.sys11.net) (Quit: Textual IRC Client: www.textualapp.com)
[17:35:25] *** Joins: skade (skade@moz-AC7A4F7F.sys11.net)
[17:36:14] <a_m0d|home> Hi all - I'm getting 3 `undefined reference` errors when compiling the head of rust-master
[17:36:48] <a_m0d|home> undefined references to: LLVMRustRunRestrictionPass, LLVMRustMarkAllFunctionsNounwind, and LLVMRustLinkInExternalBitcode
[17:36:55] <a_m0d|home> any idea what's going on?
[17:36:56] <cmr> a_m0d|home: do a clean build
[17:36:59] <cmr> and re-configure
[17:37:21] <a_m0d|home> Ok, thanks.  Trying that now.
[17:38:06] *** Joins: abinader (abinader@D8B9C081.E820043D.D4C04133.IP)
[17:38:16] <acrichto> a_m0d|home: there's probably a stray librustrt.dylib lying around
[17:38:36] <a_m0d|home> Okay, I'll let you know if that fixed it in about 20 minutes time ...
[17:41:06] *** Quits: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net) (Quit: echristo)
[17:41:10] *** Joins: pcwalton (pcwalton@moz-DA87EE4.hsd1.ca.comcast.net)
[17:41:11] *** ChanServ sets mode: +ao pcwalton pcwalton
[17:50:21] *** Quits: AvianFlu (AvianFlu@moz-723527FF.nycmny.fios.verizon.net) (Input/output error)
[17:51:03] <jvns> huh interesting. I got itoa() working, and it crashes my OS now :)
[17:51:15] <jvns> (well, compiling, not working)
[17:55:08] *** Joins: carter (carter@moz-3589B90B.c.ircrelay.com)
[17:55:16] *** Quits: adridu59 (Mibbit@moz-E1FF077C.rev.numericable.fr) (Quit: http://www.mibbit.com ajax IRC Client)
[17:56:35] *** Joins: jaen (Mibbit@F4115FED.BE0D06C2.6262EFFB.IP)
[17:57:25] <bstrie> acrichto: LLVM doesn't have archive-writing abilities *yet*. I'm saying we should add them :P
[17:58:30] <acrichto> bstrie: oh man that would be so awesome
[17:58:44] <acrichto> that'd speed up LTO and rlib generation by a fair bit I would imagine
[17:59:30] <jaen> Hi, I was about to pop-in saying that master docs on the website were broken, but I can't seem to be able to connect using weechat, it says connection's closed by peer. Any clue what's up with that? Did Polandball misbehave? ; d
[17:59:35] <bstrie> acrichto: should I file a bug for it, so that one day we can assign it to a hapless intern?
[18:00:11] <bstrie> jaen: right now the channel is protected because of botnet attacks, I guess maybe some clients choke on that
[18:00:32] <cmr> no, I and many others in here are using weechat.
[18:00:46] <cmr> the doc problem is known, the PR fixing it is currently in testing
[18:01:17] <jaen> Besides I can't even connect to the irc server itself, so I wouldn't think channel moderation's the issue
[18:01:30] <jaen> Ok, good to know
[18:01:36] <acrichto> bstrie: it's not really worth that much work
[18:02:33] *** Quits: carter (carter@moz-3589B90B.c.ircrelay.com) (Ping timeout)
[18:03:35] <SiegeLord> Does this have to be in LLVM? Can it not be implemented in 'extra' or w/e?
[18:03:39] *** Quits: autra (augustin@A14DAE84.7F753DD1.EE2CA32B.IP) (Quit: by!)
[18:04:44] *** Joins: sanxiyn (tinuviel@F32F8A59.7DD15B19.A3B1F2EE.IP)
[18:04:51] *** Quits: skade (skade@moz-AC7A4F7F.sys11.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[18:05:55] *** Joins: carter (carter@moz-3589B90B.c.ircrelay.com)
[18:06:20] *** Joins: adridu59 (adrien@moz-E1FF077C.rev.numericable.fr)
[18:06:48] <jaen> Hmr, looks like there's enough difference between 0.8 and HEAD that I can't find File docs. I think I'll wait for the PR to land.
[18:07:03] <cmr> File didn't exist, yes.
[18:07:21] <cmr> there are docs up at www.ug.it.usyd.edu.au/~hwil7821/rust-docs/std/index.html
[18:08:08] <jaen> Yay, much thanks
[18:17:23] *** Quits: jaen (Mibbit@F4115FED.BE0D06C2.6262EFFB.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[18:17:47] *** Quits: dherman (dherman@moz-DFAA4E15.p2p.sfo1.mozilla.com) (Quit: dherman)
[18:18:18] *** Joins: jaen (jaen@moz-33B51319.play-internet.pl)
[18:19:14] <jaen> Ok, it seems that I shouldn't have listened to mozilla's wiki advice to use port 6697 instead of the usual 6667. That's what I get for not lurking for a month...
[18:19:21] *** Quits: sigma (sigma@moz-6E1846A2.range86-184.btcentralplus.com) (Client exited)
[18:20:12] <cmr> 6697 should be the TLS port.
[18:20:23] *** Quits: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net) (Quit: ziad)
[18:20:39] *** Joins: AvianFlu (AvianFlu@moz-723527FF.nycmny.fios.verizon.net)
[18:22:37] *** Joins: dherman (dherman@moz-DFAA4E15.p2p.sfo1.mozilla.com)
[18:22:38] *** ChanServ sets mode: +ao dherman dherman
[18:22:51] <jaen> Duh, you're right, there's a big honking checkmark in a checkbox with SSL label. What a disgrace ; d
[18:24:08] <adridu59> how do I get the type out of a var?
[18:24:14] <cmr> adridu59: hm?
[18:24:19] <adridu59> typeof?
[18:24:25] <jaen> Regarding the File struct, it doesn't seem to ahve a filesize component. That is intentional and I should just stat the file beforehand?
[18:24:30] <cmr> typeof is unimplemented.
[18:25:17] <diverse> pcwalton: `use crate` +1
[18:26:08] <adridu59> what is the type of File::open?
[18:26:15] <cmr> jaen: Path has a `stat` method.
[18:26:23] <cmr> jaen: so yes.
[18:26:35] *** Quits: AvianFlu (AvianFlu@moz-723527FF.nycmny.fios.verizon.net) (Ping timeout)
[18:26:55] <cmr> adridu59: read the docs or the source. fun trick: `let x: ()  = File::open(...)`, rustc will tell you the type.
[18:27:29] <a_m0d|home> cmr: acrichto: thanks for your help - its working now.
[18:27:59] <diverse> acrichto: go with `use crate`~
[18:28:05] <o11c> ugh, strcat and rusti are *still* gone ?
[18:28:17] <cmr> ohh meeting today.
[18:29:00] <adridu59> how can I spoof a file with local data?
[18:29:26] <cmr> adridu59: what do you mean, exactly?
[18:29:43] <adridu59> instead of File::open(path) I'd need a File kind but with hardcoded data in my program (to pass tests)
[18:30:02] <cmr> Why do you need a File? Does a Reader not work?
[18:30:19] <diverse> pcwalton: suggest `use mod`?
[18:30:19] <adridu59> I want to pass it to a bufferedreader
[18:30:30] <cmr> BufferedReader takes any Reader
[18:30:38] <adridu59> rly? sound cool
[18:30:40] <adridu59> sounds
[18:30:52] *** Joins: AvianFlu (AvianFlu@moz-723527FF.nycmny.fios.verizon.net)
[18:31:01] <jaen> cmr: thanks, I only noticed the fs::stat free function, didn't notice the method on Path
[18:31:11] <adridu59> btw, rustdoc is really really awesome
[18:31:20] <adridu59> just needs that backend bug fixed
[18:31:48] <cmr> which bug?
[18:34:18] <adridu59> the one that makes search quirky at times
[18:34:19] <adridu59> https://github.com/mozilla/rust/issues/9981
[18:34:30] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[18:34:30] *** ChanServ sets mode: +ao brson brson
[18:34:44] <adridu59> cmr: how would I declare a reader?
[18:34:51] <adridu59> std::io::reader
[18:34:56] <adridu59> s/r/R
[18:34:57] <cmr> adridu59: "declare"? it's a trait that you implement.
[18:35:27] <adridu59> cmr: I can't just do Reader::read(myStr)?
[18:35:42] <adridu59> something like that
[18:35:52] <cmr> adridu59: MemReader::new(myStr.as_bytes().to_owned())
[18:36:32] <celeron55> is jolla-fileman really lacking basic functionality like moving and copying files?
[18:37:06] <celeron55> oh fuck
[18:37:14] *** Joins: ziad (ziad@B20586FB.BDB3D91.6E370BFC.IP)
[18:37:17] <celeron55> goes to right channel --------->
[18:37:29] <brson> anybody want to implement 11035 and 11036 today?
[18:38:12] *** Joins: tiffany (kawaii@moz-FC0DB29D.dhcp.embarqhsd.net)
[18:38:26] *** Joins: jhasse (jhasse@moz-D6BBC1BB.ewe-ip-backbone.de)
[18:38:45] <cmr> I can
[18:38:57] <adridu59> cmr: thanks, and what type annotation would I use?
[18:39:03] <brson> cmr: *highfive*
[18:39:20] <cmr> adridu59: well the type is MemReader
[18:39:30] *** Joins: buster (Mibbit@moz-8EACC0CA.dip0.t-ipconnect.de)
[18:39:38] <buster> Hi
[18:39:54] <buster> I need help :)
[18:40:07] <diverse> brson: did `use crate` win?
[18:40:10] <jdm> buster: go on :)
[18:40:19] <buster> i have an enum in one .rs file. and want to use it in another
[18:40:42] <buster> buuuut, it complains not finding the name
[18:40:45] <buster> :(
[18:41:01] <cmr> buster: can you put your code on gist.github.com ?
[18:41:12] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[18:41:22] <buster> sure
[18:43:17] <adridu59> cmr: I still get not all control paths return a value
[18:43:31] <buster> https://gist.github.com/anonymous/8010380
[18:43:53] <cmr> buster: = client::LOGGEDIN;
[18:43:58] <buster> ahh
[18:44:03] <cmr> buster: you imported the type, but none of the variants.
[18:44:14] <buster> i tried ClientState:: and ClientState. and what not.. thanks  :)
[18:44:18] <cmr> you can `use client::{ClientState, LOGGEDIN};` to pull them both in.
[18:44:33] <cmr> also note that the idiomatic rust style is LoggedIn, Login, etc.
[18:44:46] <brson> diverse: 'extern crate'
[18:45:03] <buster> ok
[18:45:07] <buster> will change that 
[18:45:15] <diverse> brson: *thumbs up*
[18:46:14] <adridu59> hooray I did it!
[18:46:26] *** Quits: abinader (abinader@D8B9C081.E820043D.D4C04133.IP) (Ping timeout)
[18:49:59] *** Quits: jvns (bork@87D98E32.4046EB22.428F94DD.IP) (Connection reset by peer)
[18:50:22] *** Joins: Scriptor (anonymous@moz-E06F46F0.corp.bitshelter.com)
[18:51:05] *** Quits: buster (Mibbit@moz-8EACC0CA.dip0.t-ipconnect.de) (Quit: http://www.mibbit.com ajax IRC Client)
[18:51:13] *** Joins: buster (buster@moz-8EACC0CA.dip0.t-ipconnect.de)
[18:51:22] <jhasse> Is there something like static variables in rust?
[18:51:42] <sfackler> jhasse: "static FOO: int = 10;"
[18:51:43] <Eridius> well, there's static variables...
[18:51:55] <Eridius> jhasse: if you want something mutable, you can use `static mut`, but you need to use unsafe code to access it
[18:52:01] <Eridius> (because static mutable variables are inherently unsafe)
[18:54:00] *** Joins: abinader (abinader@FAC83DD0.505FA95.B9657DD5.IP)
[18:54:01] <jhasse> ah thx, I'm blind. I want to make some path strings globally available in my program, that's what I wanted static variables for. (Are there global variables?) How would you implement this?
[18:54:19] <Eridius> well they could just be static, if you know what they are at compile-time
[18:54:33] <bvssvni> pub static a: int = 42;
[18:54:46] <jhasse> no they are initialized on startup
[18:54:57] <bvssvni> ah
[18:54:59] <jhasse> ~/.config, executable path, etc.
[18:55:43] *** Joins: skade (skade@moz-B73EE4D5.pools.arcor-ip.net)
[18:56:14] <bvssvni> I think I would wrap them into a struct and use a function to access it
[18:57:05] <jhasse> bvssvni: And the instance of this struct I would pass around or is there something like the Singleton pattern possible in rust?
[18:57:33] <sfackler> jhasse: you can do a singleton, but it's a huge pain. I'd just pass it around
[18:59:09] <jhasse> sfackler: Okay, thanks
[19:00:00] <adridu59> how can I print ~[~str]?
[19:00:18] <cmr> how do you want them printed? one on a line?
[19:00:29] <cmr> for str in strs.iter() { println(str) }
[19:00:30] <cmr> etc
[19:00:39] <cmr> in other words, "do it yourself"
[19:00:55] <adridu59> aha sorry!
[19:01:15] <adridu59> can I raw print through?
[19:01:27] <cmr> raw print what? the vector of pointers?
[19:01:32] <adridu59> yes
[19:01:40] <adridu59> like print with the ~ markers
[19:02:04] <cmr> `print!("{:?}", strs)` will do that using reflection
[19:04:04] <adridu59> nice, I used that the other day; quite useful
[19:04:11] <adridu59> thanks!
[19:05:14] *** Quits: jhasse (jhasse@moz-D6BBC1BB.ewe-ip-backbone.de) (Quit: Verlassend)
[19:05:32] *** Quits: heftig (heftig@moz-B3E7564.dip0.t-ipconnect.de) (Ping timeout)
[19:06:06] <adridu59> can I override prelude functions?
[19:09:22] <cmr> no, but you can import functions with the same name as them.
[19:17:03] <brson> https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-12-17
[19:17:36] <brson> jack: thanks for taking meeting minutes today
[19:18:36] <jack> brson: no prob
[19:19:07] *** Joins: heftig (heftig@moz-B8F5CC82.dip0.t-ipconnect.de)
[19:19:28] <adridu59> sounds tricky
[19:19:47] <adridu59> I mean complex
[19:24:13] <sfackler> acrichto: wrt hardcoding attributes, one thing that'd be cool in the long term is to allow arbitrary attribute processing via externally loaded syntax extensions so people could e.g. write custom lints
[19:24:23] <sfackler> so avoiding locking the compiler down too much would be nice
[19:24:45] <sfackler> at the very least custom deriving modes would be great
[19:28:31] *** Quits: joone (joone@moz-8E88FB0F.jf.intel.com) (Ping timeout)
[19:28:46] *** Quits: abinader (abinader@FAC83DD0.505FA95.B9657DD5.IP) (Quit: Fui!)
[19:29:31] <diverse> brson: btw, on the change to crate_id, how about also renaming rustpkg to rustcargo?
[19:29:43] <Ms2ger> rustcult
[19:29:51] *** Quits: dherman (dherman@moz-DFAA4E15.p2p.sfo1.mozilla.com) (Quit: dherman)
[19:30:10] <diverse> Ms2ger: ...
[19:30:33] <Ms2ger> Sorry, only thing I think of when seeing cargo is cargo-culting
[19:30:42] <Ms2ger> Must've worked on Gecko for too long
[19:31:07] <diverse> I miss read 'cult' as 'religion' :P
[19:31:25] *** Joins: arrrrrrrrr (arrrrrrrrr@moz-1FE60361.dynamic.qsc.de)
[19:31:26] <diverse> *misread
[19:31:40] *** Quits: pcwalton (pcwalton@moz-DA87EE4.hsd1.ca.comcast.net) (Quit: pcwalton)
[19:31:42] *** Joins: canhtak (canhtak@moz-258236CD.wl.t.ulaval.ca)
[19:32:01] *** Joins: alan_andrade (alan_andra@8AB4864E.75F2E118.B7838CA6.IP)
[19:32:29] *** Quits: skade (skade@moz-B73EE4D5.pools.arcor-ip.net) (Quit: Textual IRC Client: www.textualapp.com)
[19:32:30] <Ms2ger> Apparently that is the source
[19:32:53] * diverse shrugs
[19:32:53] <SiegeLord> What other meaning of 'cult' is there?
[19:35:02] *** Joins: abinader (uid21713@moz-A42E5B7B.irccloud.com)
[19:36:00] <diverse> SiegeLord: don't worry about it
[19:37:04] <Ms2ger> SiegeLord, well, "cargo culting" doesn't sound like anything religious anymore :)
[19:37:37] <SiegeLord> Well... that's what that phrase means, so I'm not sure I get it :P
[19:39:35] <SiegeLord> The meeting notes are always so hard to understand... was there any conclusion about the 'extern mod -> crate' bit?
[19:40:40] <diverse> SiegeLord: 'extern mod' changed into 'extern crate'
[19:41:14] <diverse> and pkgid to crate_id
[19:41:28] *** Quits: DeTeam (DeTeam@moz-2B3D845F.dyn.broadband.iskratelecom.ru) (Quit: DeTeam)
[19:43:29] <SiegeLord> I don't really see where that's said in the notes...
[19:43:40] <SiegeLord> Did you listen in on the meeting, diverse?
[19:43:55] <diverse> yeah I was one of the 'unnamed' guys
[19:43:58] <sfackler> SiegeLord: https://github.com/mozilla/rust/issues/11035
[19:44:40] *** Quits: synackse (synackse__@moz-DFB8ED3B.lightspeed.wepbfl.sbcglobal.net) (Ping timeout)
[19:45:02] *** Quits: dario (dario@moz-8E3254C2.informatik.uni-erlangen.de) (Ping timeout)
[19:45:15] <acrichto> sfackler: yeah I don't think that we're going to take the hardcoded list route right now, the attribute system is designed to be extensible and we want to be sure to maintain that
[19:45:47] <acrichto> diverse: I think we ended up seetling on 'extern crate foo' because the declaration differs in the semantics of `use` by a fair amount
[19:46:40] <SiegeLord> Sort of unfortunate that it's so verbose... at least it's not a common construct
[19:46:45] <diverse> acrichto: that makes better sense to me
[19:47:21] <diverse> come on, it's not that verbose
[19:48:05] *** Joins: tedh (tedh@moz-F3B34318.hsd1.il.comcast.net)
[19:48:19] *** Quits: sigma1 (sigma@C91C7F36.70518F41.9D18269F.IP) (Quit: Leaving.)
[19:48:46] <acrichto> SiegeLord: you cannot import other 'use' statements, only 'pub use', and it also differs in the declaration semanatics significantly
[19:48:58] <acrichto> I can `use` arbitrary paths, so can I `use crate foo::bar::baz`? 
[19:49:10] <acrichto> semantically I would expect that, but that also doesn't make a whole lot of sense
[19:49:26] <SiegeLord> I'm not suggesting the 'use' syntax, I think it'd break the mental model of what a use is
[19:49:33] <acrichto> plus dherman/nmatsakis have good points in that use == bring something into scope and extern == do something rleated to linkage
[19:49:39] <acrichto> ah, then never mind!
[19:49:46] * acrichto needs to read more closesly
[19:51:47] <diverse> SiegeLord: you just want plain 'crate' to be the keyword for that?
[19:51:52] <bstrie> if extern only does linkage stuff, then let's just rename it to `link` :P
[19:52:19] <SiegeLord> diverse: Unforuntately I don't have an alternative... I did think it'd just be 'crate' though
[19:53:46] *** Quits: sbalmos (quassel@CA5677B6.576D0C1.ED2EFC1B.IP) (Client exited)
[19:55:03] *** Joins: jvns (bork@87D98E32.4046EB22.428F94DD.IP)
[19:55:23] <brson> maybe 'crate' is better than 'extern crate'
[19:55:41] <acrichto> brson: I do like the "linkage" concept associated with `extern` though
[19:55:57] <diverse> brson: nmatsakis did mention that 'crate' already meant 'external' in the discussion
[19:56:31] <diverse> link crate foo?
[19:57:05] *** Quits: nano (nano@moz-ED77243C.superkabel.de) (Connection reset by peer)
[19:57:50] *** Joins: robn (robn@moz-76B0302C.static.internode.on.net)
[19:57:59] <bstrie> `link crate foo` is almost TOO clear. it's like literate programming. it'll never fly
[19:58:36] <diverse> heh
[19:58:40] <sfackler> it'd also require making link a keyword (?) :/
[19:59:06] <diverse> alright, keep it simple, just `crate`
[19:59:07] <bstrie> sfackler: but we're removing `do`, so there's no net increase :P
[19:59:18] <bstrie> I'm gonna be honest here
[19:59:23] <bstrie> was never ever a fan of `extern mod`
[19:59:28] <cmr> brson: I don't like `crate`. `crate foo;` to me doesn't imply that it's bringing in something external, it looks to me like it's giving the current crate a name!
[19:59:29] <bstrie> it made sense to graydon, but not to me
[19:59:46] <bstrie> cmr: `use crate foo` vs `link crate foo`, then :)
[19:59:47] <brson> cmr: yeah that was the reason not to use just 'crate'
[19:59:52] <buster> : agreeing to cmr
[19:59:56] <cmr> `use crate` is fine with me.
[20:00:10] <SiegeLord> mod foo; doesn't imply anything either, but you get used to it :P
[20:00:27] <bstrie> I also don't like `mod foo` :P
[20:00:35] <bstrie> I mean, for declaring mods it makes sense
[20:00:39] <bstrie> `mod foo { ... }`
[20:00:43] <bstrie> but by itself it looks like a no-op
[20:00:54] <cmr> yeah
[20:00:56] <diverse> 'use mod foo;'?
[20:00:57] <cmr> that's true.
[20:00:59] <olsonjeffery> only the bikiest of sheds will do for rust
[20:01:04] <bstrie> I'd be ok with `use mod foo;`
[20:01:13] <cmr> but I'm also 100% ok with`extern mod`
[20:01:25] <SiegeLord> I'd rather not break the mental model of 'use' :P
[20:01:33] <SiegeLord> How about extern mod foo; ;)
[20:01:36] <bstrie> `use` has no mental model for me, it's all so confusing
[20:01:39] <SiegeLord> That'll be a mind bender
[20:01:54] <bstrie> I avoid ever using multiple rust source files, or even multiple mods in a source file, cause I can't keep anything straight
[20:01:58] <bstrie> it's just too much hassle
[20:02:06] <bstrie> all one namespace, done
[20:02:11] <olsonjeffery> bstrie: i agree! it took me about a week of thrashing/mistakes/things-that-compiled-but-were-actually-wrong to figure it all out
[20:02:36] <olsonjeffery> and now it's basically intuitive for me, which is kind of bad (imo it can't be easily explained)
[20:02:37] <SiegeLord> Where did vec::raw::to_mut_ptr go?
[20:02:51] <bstrie> *also*, we need to make it a compile error to have a mod that is named the same as its parent
[20:02:57] <Luqman> SiegeLord: foo.as_mut_ptr()
[20:02:57] <bstrie> i.e. `foo::foo` should be impossible
[20:03:18] <bstrie> with the crate-relative rule, anything else is just madness
[20:03:22] <olsonjeffery> also finding the "right" mod.rs in emacs is a bummer (i imagine its the case in vim as well, or any editor w/ buffer navigation)
[20:03:28] <bvssvni> bstrie: wasted a couple hours on this a few days ago
[20:03:29] <diverse> say if 'extern' did turn into 'link, will that affect extern "C"?
[20:03:41] <olsonjeffery> shades of __init__.py , which has been mentioned before
[20:03:42] <bstrie> bvssvni: I'll file a bug for it :)
[20:03:42] <cmr> diverse: doubt it
[20:03:46] <SiegeLord> Luqman: Thanks
[20:04:26] <bvssvni> bstrie: it is enough if it's the top mod
[20:05:10] <bvssvni> bstrie: a mod declared in a file with same name could give a warning
[20:05:11] <diverse> brson: what are you thoughts so far?
[20:05:52] <brson> diverse: I don't want to blanket rename 'extern' to 'link'
[20:06:05] <brson> I want the language to stop changing :(
[20:06:23] <bstrie> bvssvni: https://github.com/mozilla/rust/issues/11037
[20:06:23] <cmr> I think the module system is fine and that any changes to it at this point are superfluous
[20:06:34] <brson> has the botnet spam been getting through our +MR mode?
[20:06:41] <brson> can't tell from the comments on reddit
[20:06:50] <adridu59> I don't think so
[20:06:50] <SiegeLord> The module system could use with a concept of friends...
[20:06:51] <bstrie> cmr: I've been following this language for over two years and I still don't know how modules work. it's far from fine
[20:06:52] <cmr> brson: no, gavin accidentally turned it off though.
[20:06:56] <SiegeLord> But that's backwards compatible
[20:07:06] *** Quits: rca (rcatolino@moz-3ED58F2C.adsl.proxad.net) (Ping timeout)
[20:07:06] <cmr> bstrie: I don't think you've tried! It's quite simple.
[20:07:09] <bstrie> brson: have noticed any today
[20:07:13] <bstrie> cmr: tutorial requested plz
[20:07:22] <bstrie> brson: er, *haven't* noticed any
[20:07:30] *** Quits: AvianFlu (AvianFlu@moz-723527FF.nycmny.fios.verizon.net) (Ping timeout)
[20:07:46] <cmr> bstrie: http://static.rust-lang.org/doc/master/tutorial.html#crates-and-the-module-system
[20:07:57] <bstrie> cmr: also, are we removing `super` or not
[20:08:00] <diverse> SiegeLord: I think we should take what we can get, I'll take 'extern crate' over 'extern mod' anyday.
[20:08:12] <cmr> bstrie: I think pcwalton wants to to make `use` simpler/decidable.
[20:08:18] <SiegeLord> I'm content with 'extern crate'
[20:08:37] <SiegeLord> What does decidable mean, incidentally?
[20:08:49] <bstrie> SiegeLord: that name resolution is not potentially infinite
[20:08:50] <bstrie> I think
[20:08:57] *** Parts: adridu59 (adrien@moz-E1FF077C.rev.numericable.fr) ()
[20:08:59] <SiegeLord> As long as I get my glob imports fixed, I don't care
[20:09:07] <cmr> SiegeLord: http://en.wikipedia.org/wiki/Decidability_%28logic%29
[20:09:07] <SiegeLord> I love me some glob imports
[20:09:11] <bstrie> SiegeLord: glob imports are the main reason why name resolution is undecideable :P
[20:09:26] <SiegeLord> Things can go until glob imports are decidable!
[20:09:30] <cmr> SiegeLord: that given an import,thereis either one or no module it can refer to, afaik.
[20:09:56] <cmr> SiegeLord: I think without self/super they are, pcwalton knows more about it than anyone else.
[20:10:09] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: rcirc on GNU Emacs 24.3.1)
[20:10:18] <bstrie> cmr: pcwalton *already* completely rewrote name resolution to make it decidable, back when we instated the crate-relative-import rule
[20:10:25] <bstrie> but maybe even that didn't suffice
[20:12:20] <cmr> yeah :(
[20:12:32] <brson> acrichto: looks like your comm rewrite landed? congrats
[20:12:40] <bstrie> ooh neat
[20:12:50] <cmr> brson: no? I only saw it go into try.
[20:12:56] *** Quits: Ms2ger (Ms2ger@BB191E51.D97EE64B.F15B0BB3.IP) (Quit: nn)
[20:13:00] <brson> i don't see the pr open
[20:13:03] <olsonjeffery> ahhhh ahhhhhh ahhhh / this rustdoc's on fire!
[20:13:04] <olsonjeffery> sorry.
[20:13:26] <cmr> ! maybe it did
[20:13:26] <diverse> olsonjeffery: so hot, your eyes just burn off from reading it.
[20:13:41] <brson> looks like i need to review this *giant* runtime refactor next
[20:15:18] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[20:15:41] <brson> acrichto: is it better to review this a commit at a time or all at once?
[20:15:46] <Luqman> cmr: it has, i was wondering why comm::stream was no longer a thing :P
[20:16:07] <cmr> brson: I went through it a commit at atime.
[20:16:09] <acrichto> brson: definitely a commit at a time
[20:16:17] <cmr> brson: they're fairly well separated, and it's **WAY** to huge otherwise.
[20:16:21] <acrichto> brson: if you can do it all at once I would be seriously amazed
[20:16:47] <acrichto> brson: also, if you want me to split up anything further, I am more than willing. The bad part is that everything pretty much has to be landed all at once
[20:17:10] <acrichto> extracting libgreen turned out to be much more of a far-reaching effort than I thought
[20:17:26] <acrichto> certain parts of the patch could be landed separately, but they're all minor things which don't really deserve a pull request
[20:18:39] <bstrie> libgreen?
[20:18:57] <cmr> bstrie: M:N runtime library.
[20:19:04] *** Joins: trecer (trecer@37CFEB55.647F016C.1EE2C17C.IP)
[20:19:16] <cmr> https://github.com/mozilla/rust/pull/10965
[20:19:54] <bstrie> oooooh
[20:20:12] <bstrie> very very cool
[20:20:27] <bstrie> so we're comfortable calling these "green threads" now, I guess?
[20:21:04] <SiegeLord> Is rustdoc broken? I'm getting broken documetation generated from it...
[20:21:35] *** pmoore is now known as pmoore|away
[20:21:48] <cmr> SiegeLord: I fixed it like 4 hours ago, how old is your rustdoc?
[20:21:50] <acrichto> SiegeLord: a fix for it landed just a few hours ago, when did you last rebuild?
[20:22:06] <SiegeLord> A few hours ago...
[20:22:08] <cmr> bstrie: well they're still tasks
[20:23:06] *** Joins: lkuper (lkuper@moz-D862222C.dhcp-bl.indiana.edu)
[20:23:54] <bstrie> cmr: but we've always sort of avoided calling them green threads, and I'm not sure how our tasks are different enough from "traditional" green threads to warrant that
[20:24:26] <acrichto> bstrie: we still have the unified idea of tasks
[20:24:30] <acrichto> libstd only knows about tasks
[20:24:36] <acrichto> libgreen knows about tasks and green threads
[20:24:41] <acrichto> libnative knows about tasks and native os threads
[20:24:42] <SiegeLord> Heh, I guess I missed the commit by a few minutes >_<... well, that's in part why I bought a new CPU
[20:24:58] *** Joins: tulloch (tulloch@B7FF343D.99CFB801.475248F5.IP)
[20:25:36] <bstrie> acrichto: I'll have to take a look at the pr
[20:25:58] <bstrie> acrichto: also, you're a maniac
[20:26:08] <acrichto> bstrie: hahaha, but it needed to be done!
[20:27:22] <bstrie> cmr: quote of the week: "my little pony: inlining is magic" ~dherman
[20:27:44] <bstrie> for next week's TWiR
[20:28:12] <TeXitoi> I have a few question about shootout benchmarks in rust: there is outdated benchmarks, and knucleotide has 2 implementations (included a very old one). What are the plan? Only one implementation? multiple? remove outdated benchmarks?
[20:28:34] <bstrie> TeXitoi: is there a reason to have two?
[20:28:38] <bstrie> otherwise let's just have one
[20:28:46] <bstrie> remove the older one
[20:28:53] <bstrie> then also remove the newer one and rewrite it completely
[20:29:00] <bstrie> repeat every few months
[20:29:02] <cmr> there were two different ways of doing it.
[20:29:14] <TeXitoi> bstrie: for knucleotide, no, but it can be: one simple, one fast monocore, one fast multicore
[20:30:02] <ziad> I'm getting the following error when compiling Rust: Assertion failed: ((unsigned)Val < Attribute::EndAttrKinds && "Attribute out of range!"), function addAttribute, file Attributes.cpp, line 948.
[20:30:03] <ziad> ar: fatal error in /opt/local/bin/ranlib
[20:30:03] <ziad> any pointers?
[20:30:15] <acrichto> ziad: what version of rust are you using?
[20:30:26] <ziad> acrichto: latest master
[20:30:32] <acrichto> ziad: sha hash?
[20:30:34] <ziad> I'm compiling the compiler itself
[20:30:37] <ziad> llvm
[20:30:43] <ziad> fe85856dc945c7e5eb83e05bdbd72fe1acd6d1c0
[20:30:47] <acrichto> oh we probably just need a new snapshot then
[20:30:52] <acrichto> that problem is fixed in master
[20:30:56] <acrichto> but it's not in the snapshot just yet
[20:30:57] <ziad> It's been like this for a few days now
[20:31:22] <ziad> What do you mean? I should check out another branch
[20:31:36] <ziad> I just cloned the repo, or did git pull to get the latest
[20:32:02] <TeXitoi> bstrie: so I just delete the old bench: rm shootout-ack.rs, shootout-fib.rs and so on?
[20:32:05] *** Joins: adridu59 (adrien@moz-E1FF077C.rev.numericable.fr)
[20:32:10] <adridu59> acrichto: updated
[20:32:14] <acrichto> ziad: oh no, this just won't work at all for you right now, I'm making another snapshot right now
[20:32:23] <ziad> acrichto: okay
[20:32:27] <acrichto> ziad: sorr y:(
[20:32:29] <adridu59> (I mean answered)
[20:32:33] <ziad> no worries, thanks!
[20:33:53] <acrichto> adridu59: you also don't have to use os::args at all
[20:33:59] <acrichto> adridu59: that's not really core to the example at all
[20:36:02] <mark_edward> i was reading the meeting notes. aren't shift and unshift kinda like bit rotates where you supply the value rotated in .rot_left() and .rot_right() seem clear enough?
[20:36:17] <adridu59> acrichto: FileInput::from_args() is not about cmd args?
[20:36:29] <adridu59> oh you mean I can drop it
[20:36:36] <acrichto> adridu59: well, yes, but again, it's not the focus of the tutorial
[20:36:54] <adridu59> right
[20:37:13] <cmr> mark_edward: that's... nothing at all like rotates?
[20:37:27] <mark_edward> kinda like rotates
[20:37:28] <cmr> shift and unshift are just pop/push on the front.
[20:37:34] <mark_edward> but different
[20:37:36] <cmr> rotate puts them back on the other end
[20:37:45] <mark_edward> true
[20:37:50] <cmr> which is only reason it's a rotate and not a bit shift :p
[20:37:51] <mark_edward> nvm then
[20:38:11] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[20:38:15] *** Quits: trecer (trecer@37CFEB55.647F016C.1EE2C17C.IP) (Ping timeout)
[20:39:47] <adridu59> acrichto: or I can just drop the .expected(), it just means no error-handling for the args part (but I can mention it in a comment?)
[20:40:39] <adridu59> what's best in your opinion?
[20:41:29] <acrichto> adridu59: whatever makes the code clear to understand is fine by me
[20:44:32] *** jorendorff_away is now known as jorendorff
[20:47:32] *** Joins: dherman (dherman@moz-DFAA4E15.p2p.sfo1.mozilla.com)
[20:47:32] *** ChanServ sets mode: +ao dherman dherman
[20:47:56] *** Joins: snowp (snowp@4DE2260B.6E91F788.2CFD4520.IP)
[20:50:43] <SiegeLord> There's still no way to make a thread-safe singleton in Rust, right?
[20:51:55] <sfackler> SiegeLord: there is, but it involves some sketchy unsafe stuff
[20:52:20] <sfackler> SiegeLord: https://github.com/sfackler/rust-ssl/blob/master/lib.rs#L27
[20:52:22] <SiegeLord> Well, is it correct unsafe stuff?
[20:52:28] <sfackler> I think so
[20:52:34] <jdm> that's the rub, isn't it
[20:52:46] *** Joins: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP)
[20:54:23] <arrrrrrrrr> how can i create an anonymous gist while logged into github?
[20:54:36] <SiegeLord> I like that... is VERIFY_IDX critical to that code?
[20:54:54] <cmr> arrrrrrrrr: "Create secret gist"
[20:54:59] <sfackler> it's an unrelated thing
[20:55:10] <SiegeLord> Sweet. I'm going to borrow that pattern
[20:55:17] <sfackler> the use of MUTEXES in init and locking_function are the interesting part
[20:55:41] <arrrrrrrrr> cmr: nope
[20:55:57] <adridu59> acrichto: even if I don't use os::args(), I still get IoError: no such file or directory
[20:56:30] <cmr> arrrrrrrrr: oh, I see now.
[20:56:40] <cmr> yeah, I don't think it's possible.
[20:56:54] <arrrrrrrrr> damn, that sucks
[20:57:19] <cmr> I mean, you just just go into private browsing mode to make a gist.
[20:57:25] <adridu59> seems like Path asserts file existence?
[20:57:33] *** Quits: Jesin (Jesin@moz-63C897DA.res.lehigh.edu) (Quit: Leaving)
[20:57:45] <arrrrrrrrr> cmr: sure but that opens a new window :(
[20:58:19] <TeXitoi> bstrie: ping?
[20:58:52] *** Quits: mark_edward (mark@moz-DCB0B750.lightspeed.cicril.sbcglobal.net) (Client exited)
[21:00:50] *** Quits: andreypopp (andreypopp@moz-7261DC60.net) (Ping timeout)
[21:01:38] *** Joins: andreypopp (andreypopp@moz-7261DC60.net)
[21:02:13] *** Parts: adridu59 (adrien@moz-E1FF077C.rev.numericable.fr) ()
[21:03:42] *** Quits: eddyb (eddy@moz-68E0B7D0.residential.rdsnet.ro) (Ping timeout)
[21:04:35] <arrrrrrrrr> when I post something with "curl --data "yada" url", how can I get the response?
[21:04:52] *** Joins: AvianFlu (AvianFlu@moz-723527FF.nycmny.fios.verizon.net)
[21:04:58] *** Quits: hoverbear (hoverbear@EBFA78B5.F19E5E7B.E74D50F2.IP) (Quit: Hibernating, be back soon.)
[21:06:22] *** Quits: Kruppe (user@moz-253119B0.esg.uwaterloo.ca) (Client exited)
[21:08:39] *** Joins: Kruppe (user@moz-C963E645.net.uwaterloo.ca)
[21:10:48] <cmr> arrrrrrrrr: it's printed.
[21:11:31] <arrrrrrrrr> my mistake
[21:12:04] *** Joins: adridu59 (adrien@moz-E1FF077C.rev.numericable.fr)
[21:12:34] <adridu59> acrichto: seems like we'd have to get rid of Path to pass the tests...
[21:15:54] *** Joins: synackse (synackse__@moz-DFB8ED3B.lightspeed.wepbfl.sbcglobal.net)
[21:16:03] *** Parts: adridu59 (adrien@moz-E1FF077C.rev.numericable.fr) ()
[21:22:41] *** Quits: TobiasFar (tm@moz-A929D162.flosoft-servers.net) (Ping timeout)
[21:23:39] *** Quits: ianj (ianjneu@moz-7BA002E.hsd1.ma.comcast.net) (Quit: leaving)
[21:28:46] *** Joins: hoverbear (hoverbear@EBFA78B5.F19E5E7B.E74D50F2.IP)
[21:29:31] *** Quits: hoverbear (hoverbear@EBFA78B5.F19E5E7B.E74D50F2.IP) (Quit: Hibernating, be back soon.)
[21:30:03] <rntz> is there a way to implement a trait for, not a particular type, but any type satisfying some trait?
[21:30:13] <rntz> ie. for any type T: Foo, to implement T: Bar?
[21:30:32] <bstrie> rntz: impl<T: Foo> Bar for T {
[21:30:40] <rntz> ah, excellent.
[21:30:48] <bstrie> at least, I *think* that works :P
[21:30:50] *** Joins: pcwalton (pcwalton@moz-C07D5168.p2p.sfo1.mozilla.com)
[21:30:50] *** ChanServ sets mode: +ao pcwalton pcwalton
[21:31:24] <sfackler> it will work, but there are some coherence issues that forbid any other implementations of Bar
[21:32:01] <Luqman> you might run into https://github.com/mozilla/rust/issues/3429
[21:32:37] <bstrie> 3429 might be the worst bug that I know of
[21:32:51] <cmr> it's not a bug!
[21:32:54] <cmr> it's working perfectly.
[21:33:10] <bstrie> this is illustrating why it is the worst bug :P
[21:35:28] <Luqman> cmr: it is a bug in that it doesn't take into account the bounds on the impl
[21:35:56] <rntz> hm, the original bug report and the "minimized" test case don't seem to be the same bug at all for that...
[21:35:59] <cmr> I'd call it "overzealous" rather than "buggy"
[21:36:39] <sfackler> cmr: It's extraordinarily overzealous: https://github.com/mozilla/rust/issues/8075
[21:38:01] <rntz> sfackler: yeah, that example (8075) seems like it can be safely ruled out because you know not(int:Bar)
[21:38:29] <rntz> because there's no declaration of (int:Bar) in that crate, and that's the only place such a declaration would be legal. 
[21:40:33] <alan_andrade> Hi Rustaceans, how can I print the address instead of the value ?
[21:40:55] <bstrie> good question
[21:41:02] <bstrie> arg where's rusti
[21:41:15] *** Joins: dkeenaghan (dkeenaghan@A9F153F4.DDE28F19.986A907C.IP)
[21:41:43] <alan_andrade> Has been down since last night I think
[21:42:22] <bstrie> there used to be an addr_of function, or something
[21:43:07] <sfackler> &foo as uint might do it? I'm not sure if that cast is legal though
[21:43:08] *** Joins: valenting (Thunderbir@9A1975C1.39CE2EE.E400A05F.IP)
[21:43:38] <alan_andrade> I think is illegal, but I might be using the incorrect printing function ?
[21:44:20] <cmr> alan_andrade: println!("{:p}", foo.as_void_ptr())
[21:45:08] <alan_andrade> woot! that worked
[21:45:19] <alan_andrade> Thanks cmr.
[21:45:38] <bstrie> cmr: what the heck is the :p specifier
[21:45:43] <cmr> bstrie: pointer.
[21:45:47] <cmr> see the docs
[21:45:49] <bstrie> we have a specifier for that???
[21:45:53] <cmr> Sure do!
[21:45:59] <cmr> it's 0xhexadecimal
[21:46:06] *** Quits: tulloch (tulloch@B7FF343D.99CFB801.475248F5.IP) (Ping timeout)
[21:46:19] <alan_andrade> It's a little bit 'confusing' need to call a method on foo to get the address when it might be already an address.
[21:46:43] <cmr> alan_andrade: well, as_void_ptr gets the address to the receiver.
[21:46:50] <cmr> what specific type do you have?
[21:46:52] <alan_andrade> but I can get used to it. I'm pretty new and I'm learning on the way
[21:46:52] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[21:47:13] <alan_andrade> I don't have any @cmr, I'm experimenting to learn more about Rust.
[21:47:17] <cmr> ok
[21:48:01] <bvssvni> if rustdoc outputs nothing, is there any place I should start to check?
[21:48:53] <cmr> bvssvni: it should spit out docs into a `doc` directory. try running with RUST_LOG=rustdoc=3 to see if it's actually doing things.
[21:49:10] *** Joins: pao (pao@moz-AF905E87.fbx.proxad.net)
[21:49:54] *** Quits: buster (buster@moz-8EACC0CA.dip0.t-ipconnect.de) (Client exited)
[21:51:10] <bvssvni> is this right: rustdoc index.rs -RUST_LOG=rustdoc=3
[21:51:41] <ChrisMorgan> bvssvni: no, RUST_LOG is an environment variable
[21:51:50] <sfackler> bvssvni: "env RUST_LOG=rustdoc=3 rustdoc index.rs"
[21:51:53] <ChrisMorgan> Are you on Windows or another OS?
[21:52:14] <bvssvni> Linux
[21:52:36] <bvssvni> ah
[21:52:38] <ChrisMorgan> Then `RUSTLOG=rustdoc=3 rustdoc index.rs` will set the environment variable for that invocation..
[21:52:58] <bvssvni> I was ignoring the error
[21:53:02] <bvssvni> haha
[21:53:17] <bvssvni> I got some warnings because of unit tests
[21:53:27] <bvssvni> and I ignored the error from rustdoc at the end
[21:53:48] <bvssvni> guess I expected it to come first
[21:57:57] *** Joins: xitology (xi@85437D54.5AFA3E4.CEDFC552.IP)
[21:58:16] *** Quits: pao (pao@moz-AF905E87.fbx.proxad.net) (Quit: pao)
[22:00:19] <jvns> strcat: hey is there a better to use a subset of rust-core than editing lib.rs?
[22:00:34] <strcat> jvns: hm, why do you need to use a subset?
[22:00:52] <jvns> strcat: I want mem.rs but not any of the f32 or threading
[22:01:02] <strcat> jvns: just don't pass --cfg libc
[22:01:19] <jvns> strcat: well I need --cfg libc to get malloc
[22:02:03] <strcat> well the easiest way would be to just leave that stuff enabled and let the optimizations remove it since it's unused
[22:02:18] <strcat> you can only build with LTO anyway, since you need to disable unwinding
[22:02:59] *** Joins: eternaleye (eternaleye@moz-5668AFCB.hsd1.wa.comcast.net)
[22:03:37] *** Joins: c-a (c-a@moz-57C82A9.a163.priv.bahnhof.se)
[22:03:45] <arrrrrrrrr> how do I pass the selection (or the whole file if there is no selection) as an argument to an external command in vim?
[22:04:17] <jvns> strcat: when I try to build I get a whole bunch of linker errors
[22:04:29] <strcat> jvns: what command are you using to build?
[22:05:01] <strcat> there's the example in the README for example
[22:05:03] <strcat> rustc --cfg libc core/lib.rs --out-dir . -O -Z no-landing-pads
[22:05:05] <strcat> rustc --emit-llvm example.rs -O -Z no-landing-pads -L .
[22:05:07] <strcat> clang -O2 -flto -o example example.bc
[22:05:09] <strcat> I don't think it leaves behind any dead code
[22:05:10] <jvns> yeah that's what I'm following
[22:05:21] <jvns> hmm I took off -flto for some reason
[22:05:35] <jvns> because that wasn't working for me 
[22:05:48] <alan_andrade> How does a precompile instruction in C translates to Rust ?
[22:05:58] <strcat> jvns: well it should work
[22:06:03] <alan_andrade> like #define FOO 10
[22:06:06] <strcat> unless the LLVM you have isn't built properly
[22:06:23] <strcat> alan_andrade: just define a constant (in C too)
[22:06:41] <jvns> strcat: why is --cfg libc there, then?
[22:06:58] <strcat> jvns: because it's intended to work without relying on LTO, but LTO is required anyway atm
[22:07:09] <jvns> what's LTO?
[22:07:11] <strcat> LTO is required because rust doesn't provide a way to disable unwinding without it
[22:07:14] <strcat> jvns: link-time optimization
[22:07:24] *** Joins: echristo (echristo@A2012DB6.D6CCE4AE.77834EAA.IP)
[22:07:58] <alan_andrade> thanks \o/
[22:08:12] <jvns> hmm "clang -flto -c -O2 -o build/obj/main.o build/obj/main.bc" produces LLVM bitcode for me 
[22:08:29] <strcat> jvns: no -c
[22:08:44] *** Joins: pao (pao@moz-AF905E87.fbx.proxad.net)
[22:08:53] <strcat> jvns: shouldn't be a main.o involved though
[22:09:05] <jvns> strcat: why not?
[22:09:15] <strcat> because the build process for rust-core requires LTO
[22:09:24] <strcat> you can't build intermediate .o files
[22:09:32] <jvns> huh
[22:09:34] <jvns> it works for me
[22:09:36] <cmr> -Z lto -Z no-landing-pads
[22:09:42] <cmr> boom, unwinding gone
[22:09:50] <strcat> jvns: well you're including main twice afaict from that
[22:09:59] <jvns> I can definitely build intermediate .o files
[22:10:09] <strcat> jvns: how are you building them?
[22:10:52] <jvns> "clang -c -O2 -o build/obj/main.o build/obj/main.bc"
[22:11:46] <strcat> jvns: the build process should be compiling rust-core to an rlib with LTO and no-landing-pads (one time thing)
[22:11:56] <strcat> and then compiling your code to bytecode
[22:12:00] <jvns> strcat: yeah
[22:12:05] <jvns> and then I compile my code to a .o file
[22:12:07] <strcat> and then building that bytecode to machine code, without an intermediate step
[22:12:11] <strcat> jvns: yeah, that's going to stop LTO from working
[22:12:46] <strcat> building to a .o is making machine code, so no more optimizations are going to happen, so it can't eliminate dead calls
[22:12:55] <jvns> oh I see
[22:13:20] <strcat> the bytecode -> machine code needs to be one step via clang -flto -O2
[22:13:32] <strcat> and any other object files (external assembly, etc.) need to be passed to that cmd
[22:13:41] *** Quits: pao (pao@moz-AF905E87.fbx.proxad.net) (Quit: pao)
[22:14:05] <strcat> anyway static linking *should* work, but it quickly doesn't
[22:14:05] <jvns> so when I run "clang -flto -O2 -o build/obj/main build/obj/main.bc -v"
[22:14:16] <jvns> it talks about "-dynamic-linker /lib64/ld-linux-x86-64.so.2 "
[22:14:22] <jvns> which seems wrong to me
[22:14:39] <strcat> jvns: hm?
[22:14:47] <strcat> well maybe your distro ships a broken clang
[22:15:02] <jvns> I'm using clang 3.2
[22:15:05] <jvns> from somewhere
[22:15:13] <strcat> clang 3.2 probably isn't going to work
[22:15:16] <jvns> oh okay
[22:15:18] *** Quits: jackneill (jackneill@moz-B6F27E42.pool.digikabel.hu) (Ping timeout)
[22:15:28] <strcat> jvns: 3.3 also won't work once stuff gets non-trivial
[22:15:33] <jvns> so I want 3.4?
[22:15:36] <strcat> the IR/bytecode has changed since then
[22:15:47] <strcat> jvns: you need clang from svn near where rust is
[22:15:50] <jvns> oh
[22:15:50] <strcat> it's a pain.
[22:16:06] <strcat> to avoid this, rust needs to provide a way to disable segmented stacks and PIE
[22:16:18] *** Joins: zmthy (zmthy@moz-C2881CC3.ecs.vuw.ac.nz)
[22:17:23] <jvns> should the rust-core README say that?
[22:18:50] <strcat> jvns: well, clang 3.3 has a good chance of working
[22:19:01] <strcat> until it segfaults because it sees bytecode it doesn't understand ;]
[22:19:09] <jvns> haha okay
[22:19:22] <strcat> these are rust bugs anyway
[22:19:29] <strcat> rustc should be able to compile code itself
[22:19:38] <strcat> and it can't, if you're not using the runtime/stdlib
[22:19:58] <strcat> if it can't, we should be shipping the tooling you need to do it (clang or llc)
[22:20:04] *** Quits: eternaleye (eternaleye@moz-5668AFCB.hsd1.wa.comcast.net) (Connection reset by peer)
[22:20:13] <strcat> because checking out the same revision of LLVM and building it all again to get clang is a HUGE pain
[22:20:34] *** Quits: [o__o] (~o__o@moz-24EBFAC7.me) (Input/output error)
[22:20:38] <jvns> so "clang 3.3 should work, clang <= 3.2 will not work"?
[22:20:44] <strcat> jvns: well 3.3 *might* work
[22:20:48] *** Joins: [o__o] (~o__o@moz-24EBFAC7.me)
[22:20:49] <jvns> :)
[22:20:49] <strcat> as your code gets more complex, it'll break ;p
[22:21:06] * strcat has no good answer for this
[22:21:19] <strcat> just have to go through the pain of building clang/LLVM from source with LTO support
[22:21:47] <strcat> which means having a recent enough binutils and pointing LLVM at the dir in ./configure
[22:23:42] *** Quits: jaen (jaen@moz-33B51319.play-internet.pl) (Quit: WeeChat 0.4.2)
[22:23:50] <jvns> clang still says "/usr/bin/ld: /usr/bin/../lib/LLVMgold.so: error loading plugin" =(
[22:24:21] <strcat> jvns: well it looks like your clang/LLVM isn't built properly
[22:24:29] <jvns> yeah I think this is a distribution problem
[22:24:42] <arrrrrrrrr> in vim: how can I run a command and print the output to the status line?
[22:24:45] <jvns> maybe I should stop using ubuntu 12.04 sometime
[22:24:47] <strcat> if it's not pointed at a recent enough binutils, it cna't do LTO
[22:24:51] <strcat> can't*
[22:24:59] <cmr> arrrrrrrrr: ask one of the various vim channels, on freenode and elsewhere
[22:25:26] <ChrisMorgan> arrrrrrrrr: `:echo MyFunc()`
[22:25:35] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[22:25:48] <arrrrrrrrr> it's an external command :w !cmd
[22:27:29] *** Joins: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net)
[22:31:18] *** Quits: tcreate (tcreate@moz-1A21C25B.olin.edu) (Client exited)
[22:31:41] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[22:31:47] *** Joins: pradeep (pradeep@5AB4884B.FCC4549.14D5B978.IP)
[22:33:55] <strcat> jvns: I don't mind adding more cfg flags but it's a pain to maintain ;p
[22:34:39] *** Quits: Kruppe (user@moz-C963E645.net.uwaterloo.ca) (Ping timeout)
[22:35:57] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[22:36:27] <bvssvni> does rustdoc output an index.html?
[22:36:35] <cmr> bvssvni: yes
[22:36:37] <bvssvni> can't find it
[22:36:43] <cmr> it outputs in doc/ by default.
[22:37:04] <arrrrrrrrr> cmr: did you get lldb running on linux?
[22:37:08] <cmr> arrrrrrrrr: yes.
[22:37:10] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Connection reset by peer)
[22:37:16] *** Quits: pcwalton (pcwalton@moz-C07D5168.p2p.sfo1.mozilla.com) (Quit: pcwalton)
[22:37:18] <arrrrrrrrr> does it work with the vim plugin?
[22:37:26] <cmr> didn't bother trying
[22:37:30] <arrrrrrrrr> k
[22:37:31] <cmr> I don't use vim for much more than editing.
[22:37:39] <bvssvni> cmr: no index.html there
[22:37:47] <cmr> if I wanted a wholistic experience I'd use emacs ;P
[22:37:56] * strcat is perfectly happy with gdb
[22:38:02] <strcat> cmr: vim has better native programming plugins than emacs.
[22:38:38] <strcat> apparently C/C++ programmers don't use emacs, because it doesn't have good clang-based completion/jump-to-definition ;p
[22:38:42] <strcat> it has gdb integration though
[22:39:05] *** Joins: tcreate (tcreate@7C181A70.200CF5B8.9D2C3D3E.IP)
[22:39:25] <strcat> (but so does gvim)
[22:42:16] <bvssvni> cmr: maybe it's the warnings
[22:42:38] <cmr> bvssvni: warnings are fine.
[22:42:42] <cmr> run rustdoc and then `echo $?`
[22:42:46] <cmr> if it's not 0, something went wrong.
[22:42:50] <sfackler> bvssvni: it'll be in doc/my_crate_name/index.html
[22:42:54] <ChrisMorgan> Rust continues to ruin my ability to write in other languages… why, there I was trying to use `let` in JavaScript (without "use strict";)
[22:47:08] *** Joins: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz)
[22:49:39] *** Joins: pcwalton (pcwalton@moz-C07D5168.p2p.sfo1.mozilla.com)
[22:49:39] *** ChanServ sets mode: +ao pcwalton pcwalton
[22:51:58] <pcwalton> nmatsakis: I thought I did fix the pod thing… I'll double check
[22:52:25] <pcwalton> https://github.com/mozilla/rust/commit/36990dfa3fdaa571c283ae9c06a765d6ca45a8da
[22:52:33] <pcwalton> it's tested...
[22:53:46] *** Quits: lkuper (lkuper@moz-D862222C.dhcp-bl.indiana.edu) (Ping timeout)
[22:56:27] <bvssvni> cmr: It's because I didn't use 'pub mod'
[22:58:23] <bvssvni> cmr: the code is using namespaces wrong, so I need to change it anyway
[22:58:45] <cmr> bvssvni: yeah it doesn't output anything if there's nothing to output :)
[22:59:30] <bvssvni> cmr: :)
[23:01:28] <benh> are unsafe pointers pods?
[23:03:32] <dbaupp> yes
[23:03:57] <dbaupp> essentially anything doesn't move by defaul
[23:03:59] <dbaupp> t
[23:04:06] <dbaupp> (except for @, possibly.)
[23:12:32] *** Quits: tedh (tedh@moz-F3B34318.hsd1.il.comcast.net) (Ping timeout)
[23:13:32] *** Joins: aatch (James@moz-B437F499.pocketrent.com)
[23:15:52] <bvssvni> to test extern api, should I write unit tests in a separate crate?
[23:16:17] <cmr> bvssvni: probably a good idea, to make sure privacy etc are correct.
[23:17:16] *** Joins: Krymise (Nietzsche@moz-CA789EF5.nwrknj.fios.verizon.net)
[23:17:46] *** Quits: jdm (jdm@moz-AC9499B2.cable.teksavvy.com) (Quit: Lost terminal)
[23:19:15] *** Quits: k4nar (quassel@moz-F5EFF779.kimsufi.com) (Ping timeout)
[23:20:10] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[23:21:05] *** Joins: rntz_ (rntz@moz-E7065CE4.cmdnnj.fios.verizon.net)
[23:22:12] *** Joins: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com)
[23:22:19] <Eridius> how long does it take travis-ci.org to respond to a commit? I just set up a rust project for the first time (following Rust CI) instructions, but I'm not seeing the project appear in Travis CI
[23:22:31] <cmr> Eridius: it's usually pretty quick
[23:23:08] <Eridius> I made the mistake of pushing my .travis.yml file before turning on the hook, but I tried pushing an empty commit and waiting a few minutes, with nothing. Now I tried force-pushing back to before the .travis.yml and then pushing the .travis.yml commit again. But I'm still seeing nothing
[23:23:27] <Eridius> oh hey, I just got an email from Travis CI. But the website still doesn't show it
[23:23:37] <Eridius> ah hah, now it shows it as a 5-second old project
[23:23:37] <Eridius> \o/
[23:23:54] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[23:23:56] *** Quits: valenting (Thunderbir@9A1975C1.39CE2EE.E400A05F.IP) (Quit: valenting)
[23:23:57] <bstrie> ChrisMorgan: haha, I do that all the time too
[23:24:01] <Eridius> looks like the empty commit did work, it just doesn't want to show the project until it's attempted to actually build it
[23:24:04] <o11c> Eridius: travis sometimes has delays of up to an hour
[23:24:05] <Eridius> although the build errored for some reason
[23:24:35] <Eridius> during the clone of the repo. I wonder if the error just means it was cancelled due to the force push, or what
[23:24:58] <Eridius> oh! It failed because it tried to checkout the empty commit, which was already gone from the repo by the time it cloned
[23:25:24] <o11c> yeah, that happens sometimes
[23:25:27] <bstrie> strcat: curious how you feel about https://github.com/mozilla/rust/pull/10965
[23:25:53] <strcat> bstrie: no different than before
[23:25:57] <o11c> strcat is back!
[23:26:03] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[23:26:22] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[23:26:49] <o11c> strcat: btw, weechat has already changed the notice thing in git
[23:26:57] <strcat> o11c: heh, nice
[23:27:02] <Eridius> notice thing?
[23:28:11] *** Joins: valenting (Thunderbir@9A1975C1.39CE2EE.E400A05F.IP)
[23:28:18] <o11c> -- Notice(rusti) -> #rust: "hello"
[23:28:41] *** Joins: tedh (tedh@moz-F3B34318.hsd1.il.comcast.net)
[23:29:09] <o11c> the -> #rust was added in WeeChat 0.4.2 to avoid ambiguity with the new feature to display channel greetins (which are a notice from a bot to the user) in the channel.
[23:29:43] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[23:29:52] <o11c> WeeChat 0.4.3 will use -- Notice(rusti): "hello" and -- PvNotice(ChanServ): welcome to our cool channel blah
[23:30:39] *** Quits: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net) (Ping timeout)
[23:30:47] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[23:30:47] *** ChanServ sets mode: +ao brson brson
[23:31:00] <Eridius> I see
[23:33:42] *** Quits: eholk (eholk@moz-BA312F07.crest.iu.edu) (Quit: eholk)
[23:35:05] *** Joins: frau (frau@A432E5CC.191304CB.C579BC3E.IP)
[23:36:58] <frau> rustpkg is frustrating... it always installs into $PWD
[23:37:22] <cmr> frau: it installs into the first entry in RUST_PATH, or .rust if it's not set.
[23:37:25] *** Joins: pao (pao@moz-AF905E87.fbx.proxad.net)
[23:37:39] <o11c> frau: join the club of people wishing for better default behavior
[23:37:53] <frau> cmr: The build files end up in $PWD/.rust always... but I see that JSON file ends up in my RUST_PATH
[23:38:02] <frau> is that how it's supposed to work?
[23:38:17] <cmr> hm, no
[23:38:28] <cmr> rustpkg is pretty crazy atm
[23:38:56] <frau> Yeah... is there an alternative workflow for the interim?
[23:39:03] *** Quits: vadimcn (chatzilla@FB06B64.76F9E272.DA40C4B3.IP) (Connection reset by peer)
[23:39:21] <cmr> I just use rustc.
[23:40:12] <frau> What do you do with libraries? copy them around, or pass additional ld dirs, or something?
[23:40:22] *** Joins: vadimcn (chatzilla@FB06B64.76F9E272.DA40C4B3.IP)
[23:40:28] <cmr> copy them around, yeah :(
[23:40:48] <frau> :(
[23:41:03] <frau> is there any way I can contribute to rustpkg?
[23:41:53] *** Quits: c-a (c-a@moz-57C82A9.a163.priv.bahnhof.se) (Quit: Ex-Chat)
[23:42:12] <aatch> frau, sure, make your changes and open a pull request.
[23:42:32] <aatch> It's in the main rust repo
[23:43:12] <frau> OK, I'm looking at the issues
[23:43:34] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Client exited)
[23:44:35] *** Quits: tcreate (tcreate@7C181A70.200CF5B8.9D2C3D3E.IP) (Client exited)
[23:47:03] *** Quits: valenting (Thunderbir@9A1975C1.39CE2EE.E400A05F.IP) (Ping timeout)
[23:48:54] <frau> Is there like a high-level overview of where rustpkg wants to go?
[23:49:22] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[23:50:21] <frau> there's a manual that describes current operation, but...
[23:50:24] *** Quits: arrrrrrrrr (arrrrrrrrr@moz-1FE60361.dynamic.qsc.de) (Ping timeout)
[23:51:52] <o11c> frau: well, there are two major different opinions
[23:52:16] <o11c> there's one party that thinks of rustpkg as a way of installing dependencies in the current directory
[23:52:37] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[23:52:37] *** ChanServ sets mode: +ao brson brson
[23:52:51] <o11c> and another party that thinks it should install in a well-known location like ~/.local/lib/rust/
[23:53:27] <frau> both have their uses, right...
[23:53:44] *** Quits: pauls (pauls@moz-7140CF01.ccs.neu.edu) (Client exited)
[23:54:02] *** Parts: Scriptor (anonymous@moz-E06F46F0.corp.bitshelter.com) ()
[23:54:15] <o11c> I don't see the use for the first, since different versions of a rust package can't collide
[23:54:24] <o11c> that's the only reasons it's useful for other languages
[23:54:44] <frau> ah
[23:54:57] <o11c> but obviously other people disagree
[23:55:07] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[23:55:41] <frau> well, I have project P with two dependencies D1 and D2... and I have to do hand-fixes to D2 to make it build, so it's locally checked out and modified
[23:55:47] *** Joins: tulloch (tulloch@moz-C58CFF6D.lns7.cht.bigpond.net.au)
[23:56:03] <o11c> then you make your local changes and install them
[23:56:16] <frau> I guess I can use the git hash as the version?
[23:56:32] <o11c> it works well enough for python, and there's this thing called "symstall"
[23:57:04] <Eridius> damn, looks like I can't get Rust CI working with rust-lua. I can't figure out how to handle the fact that the lib name is different in linux vs on my machine
[23:57:25] <o11c> Eridius: #[cfg] ?
[23:57:52] <Eridius> o11c: I can't just assume that it's different on linux vs darwin. I don't actually know why it's different
[23:58:08] <Eridius> but in my homebrew-installed lua, it's liblua.5.1.5.dylib but on linux it's liblua5.1.a
[23:58:22] <Eridius> well, on darwin I want the liblua.5.1.dylib symlink. The point is, there's an extra .
[23:58:59] <Eridius> I do generate a rust file using C, so I could conceivably put the lib name in there, but pkg-config wants me to just use -llua on darwin, but I specifically want to use lua.5.1
[23:59:08] *** Joins: tomdale (sid5518@moz-31ABA2C0.irccloud.com)
[23:59:16] <Eridius> (for some reason the pkg-config package in the homebrew-installed lua is just "lua", but it's "lua5.1" on linux)
[23:59:18] <tomdale> omg hello gentle people
[23:59:30] <alan_andrade> @tomdale what's up! 
[23:59:35] <tomdale> glad to see brianloveswords here
[23:59:41] <tomdale> although still not sure why he love swords!

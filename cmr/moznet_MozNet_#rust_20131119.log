[00:00:05] <acrichto> but it's still only line buffered
[00:00:11] *** Joins: jordyd (jordyd@moz-9E2129EA.seg112.ucf.edu)
[00:00:13] <pcwalton> aha, I wonder if that's the problem with capnproto
[00:00:16] <strcat> pcwalton: we'll lose on single-threaded benchmarks just because we link to stdio
[00:00:16] *** Quits: Scriptor (anonymous@moz-E06F46F0.corp.bitshelter.com) (Quit: Scriptor)
[00:00:24] <pcwalton> should get a bug on that
[00:00:33] <acrichto> pcwalton: was was the reason that we were slower?
[00:00:36] <strcat> there are _unlocked stdio functions, but even the locked ones don't enable locking until you link to libpthread.so
[00:00:39] <acrichto> I was very curious but never sawn any analysis
[00:00:45] <strcat> er
[00:00:46] <dbaupp> pcwalton: capnproto seems to be using a custom buffered writer, form my glance at the source code
[00:00:49] <strcat> just because we link to libpthread*
[00:00:59] <pcwalton> acrichto: I haven't measured it but it feels like something is wrong in the buffering
[00:01:04] <dbaupp> acrichto: I asked "even for non-ttys" and you answered "even for ttys" ... typo?
[00:01:18] <acrichto> dbaupp: oh hm, we line-buffer always, no exceptions
[00:01:19] <pcwalton> strcat: the _unlocked didn't make much of a difference for me
[00:01:26] <pcwalton> when acrichto and I benchmarked on mac
[00:01:29] <dbaupp> acrichto: ah, ok.
[00:01:32] *** Quits: KindOne (KindOne@moz-1585F79.dynamic.ip.windstream.net) (Ping timeout)
[00:01:40] <acrichto> I should re-run that bench
[00:01:42] <pcwalton> I'm sure there must be *some* workload where it makes a difference else they wouldn't exist
[00:01:43] *** Joins: fyolnish (fyolnish@moz-4A57BC0F.uqwimax.jp)
[00:01:46] <strcat> pcwalton: well, mutexes are pretty fast so maybe it doesn't matter much
[00:01:54] <strcat> they don't do system calls until they've needed to spin for a bit
[00:01:56] <pcwalton> yeah, uncontended mutexes are super fast compared to a sys call I think
[00:02:04] <strcat> they spin a little and then wait on futex
[00:02:22] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Client exited)
[00:02:38] <strcat> condition variables are basically "free", apparently
[00:02:48] <strcat> signal == write to memory location
[00:02:53] *** Joins: tikue (tkuehn@CDCD6B77.F3E8A984.689607DE.IP)
[00:03:26] *** Quits: fyolnish (fyolnish@moz-4A57BC0F.uqwimax.jp) (Ping timeout)
[00:03:31] <pcwalton> the biggest perf problem in Rust right now is that automatically derived methods aren't marked #[inline] :)
[00:03:50] <dbaupp> it would be a two line change, if we want it.
[00:03:57] <pcwalton> Servo really wants it
[00:04:09] <dbaupp> ok, on it.
[00:04:11] <pcwalton> things like struct Au(int);
[00:04:16] <pcwalton> dbaupp: sweet, thanks
[00:04:37] <tikue> what is "automatically derived" vs. derived?
[00:04:42] *** Quits: nkoep (nik@moz-C546266B.pool.mediaways.net) (Client exited)
[00:04:44] <pcwalton> tikue: anything with #[deriving]
[00:04:48] <pcwalton> I think they mean the same thing
[00:04:50] <tikue> ah ok
[00:05:43] *** Joins: KindOne (KindOne@moz-BF6D3F72.dynamic.ip.windstream.net)
[00:09:39] <cmr> pcwalton: I think our inlining model is backwards
[00:09:50] <cmr> AST should probably *always* be emitted
[00:10:12] <strcat> well at that point you might as well just use LTO by default
[00:10:20] <cmr> that's what I'm saying ;P
[00:10:21] <strcat> it will be faster than compiling functions multiple times per crate
[00:10:28] <cmr> well
[00:10:32] <cmr> yeah
[00:10:32] *** Quits: haberman (Mibbit@moz-D730FB90.hsd1.wa.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[00:10:48] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Client exited)
[00:11:04] *** Quits: willingc (willingc@moz-B4760708.san.res.rr.com) (Client exited)
[00:11:06] *** Quits: dherman (dherman@moz-BBE3ABD.mv.mozilla.com) (Quit: dherman)
[00:11:13] <acrichto> pcwalton: strcat: we have aways to go with uvio still https://gist.github.com/alexcrichton/7537718
[00:11:57] <strcat> I'm not convinced it will ever not be slow
[00:12:12] <strcat> it's always going to have to do thread context switches
[00:12:20] <strcat> switching CPU cores is deadly
[00:12:23] *** Quits: happy4crazy (happy4craz@87D98E32.4046EB22.428F94DD.IP) (Client exited)
[00:12:27] <strcat> acrichto: what about with taskset -c 0 ./foo
[00:12:33] <dbaupp> cmr: when you fix it, you can remove the #[inline]'s :P
[00:12:34] <acrichto> this is osx
[00:12:46] <strcat> acrichto: well, I'll measure it then :)
[00:12:54] <pcwalton> acrichto: well, it's good that we're on par without uv
[00:13:09] * pcwalton fires up Instruments
[00:13:16] <acrichto> http://i.imgur.com/jtNUqT1.png
[00:13:21] <acrichto> that's the inverted profile
[00:13:32] <pcwalton> might want to flatten to boundary frames
[00:13:37] <strcat> ./foo > /dev/null  0.05s user 0.02s system 97% cpu 0.068 total
[00:13:40] <strcat> uv:
[00:13:43] <strcat> ./foo > /dev/null  0.67s user 0.54s system 124% cpu 0.974 total
[00:13:47] <strcat> (linux has faster threads that OS X :p)
[00:13:48] <acrichto> pcwalton: which option is that?
[00:14:06] <strcat> taskset -c 0 ./foo > /dev/null  0.32s user 0.40s system 99% cpu 0.718 total
[00:14:18] <strcat> not as big as I thought
[00:14:38] <strcat> but that 200ms delta is from the inherent context switches we'll always have
[00:14:55] <pcwalton> acrichto: just right click on a kernel function and say charge libsystem.dylib to callers
[00:14:57] <pcwalton> err
[00:15:10] <pcwalton> flatten libsystem.dylib to boundary frames
[00:15:40] <acrichto> hm, if I charged it shrunk, if I flattened it did not shrunk
[00:15:42] <acrichto> shrink*
[00:15:52] <pcwalton> yeah, it seems flatten is busted
[00:15:54] <pcwalton> it worked on 10.6 >:(
[00:16:07] <acrichto> man our time is literally all in uv
[00:16:09] <pcwalton> whatever, checking Hide System Libraries shows the uv calls
[00:16:13] *** Joins: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP)
[00:16:18] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Quit: hjr3)
[00:16:29] <acrichto> http://i.imgur.com/Be5zGSy.png
[00:16:35] <acrichto> pcwalton: ^ libsystem charged to callers
[00:16:38] <pcwalton> yeah
[00:17:22] <acrichto> oh malloc is still high up there
[00:17:31] <acrichto> uv fs requests have to get allocated all the time
[00:17:34] <acrichto> I should cache those...
[00:18:00] <acrichto> or the tty apis could actually work with libuv
[00:19:55] <pcwalton> a lot of it is uv synchronization
[00:19:58] <pcwalton> why does uv need a condvar?
[00:20:07] <acrichto> all fs requests go through a thread pool
[00:20:15] <acrichto> that's actually probably the worst part
[00:20:15] <pcwalton> oh right
[00:20:18] <pcwalton> :(
[00:20:22] <acrichto> piped stdio uses uv's fs apis
[00:20:25] <acrichto> it has no reason to
[00:20:32] <pcwalton> oh, it has separate APIs for stdio?
[00:20:36] <acrichto> other than that the piped usage of uv's tty apis is kinda broken
[00:20:48] <acrichto> uv has uv_tty_init and uv_stream_{read,write} (which is what the net/pipe things have)
[00:20:52] <acrichto> and that doesn't use a thread pool at all
[00:21:03] <acrichto> but it gets very sad when stdio is not actually a tty
[00:21:10] <dbaupp> acrichto: r? https://github.com/mozilla/rust/pull/10557 (slightly more than 2 lines)
[00:21:16] <dbaupp> pcwalton: ^
[00:21:25] <acrichto> pcwalton: https://github.com/mozilla/rust/blob/master/src/librustuv/tty.rs#L33
[00:21:32] <pcwalton> acrichto: does uv_tty_init get sad when it's piped to devnull?
[00:21:51] <acrichto> pcwalton: hm, now that I think about it, it's only stdin ttys
[00:21:56] * acrichto goes to change that
[00:22:00] *** Joins: lfox (lfox@moz-B8648F0F.nycmny.fios.verizon.net)
[00:22:10] <pcwalton> avoiding the thread pool will be the biggest win
[00:22:13] <dbaupp> (that marks everything except for the Decodable, Encodable and ToStr methods as #[inline].)
[00:22:20] <mark_edward> what's the fastest way to declare a whole bunch of mutable variables? translating some code. does it distribute over parentheses?
[00:22:25] <pcwalton> mark_edward: no
[00:22:39] <strcat> let (mut a, mut b) = (2, 3); does work now
[00:22:39] <dbaupp> mark_edward: let (mut a, mut b, mut c); might work.
[00:22:45] <acrichto> dbaupp: you lied, I was told this was a 2 line change!
[00:23:02] <pcwalton> acrichto: I bet that's the problem with capnproto.
[00:23:13] <dbaupp> acrichto: only because I did it properly! :P
[00:23:15] <pcwalton> all the synchronization on the thread pool.
[00:23:22] <mark_edward> ok thanks cguys
[00:23:23] <acrichto> pcwalton: that would be a sad day
[00:23:43] <acrichto> aww pcwalton beat me to it
[00:23:49] <acrichto> https://github.com/mozilla/rust/pull/10557/commits
[00:23:52] <acrichto> github changed their ui!
[00:24:03] *** Joins: tulloch (tulloch@moz-1C33A2E7.nat.csx.cam.ac.uk)
[00:24:06] <acrichto> or I'm not loading a stylesheet
[00:24:15] * dbaupp just noticed it too
[00:26:30] *** Joins: recrack (Mibbit@B4104EBB.3CC170B1.1E14B209.IP)
[00:27:00] <sp3d> has anyone done anything toward automating compilation of code samples in docs?
[00:27:53] *** Joins: carllerche (carllerche@moz-2B516F15.hsd1.or.comcast.net)
[00:27:57] <acrichto> pcwalton: https://github.com/mozilla/rust/pull/10558
[00:28:27] <pcwalton> acrichto: does that improve perf?
[00:28:39] <acrichto> hm, building to find out
[00:28:54] <sp3d> you could use some tag to mark setup/import/teardown lines to be hidden from generated docs
[00:29:12] <acrichto> pcwalton: haha yes
[00:29:31] <acrichto> pcwalton: 1.347s => 0.198s
[00:29:48] <pcwalton> how much slower than C++? 2x ,3x?
[00:29:50] <acrichto> ~2x slower than raw writes
[00:29:52] <pcwalton> ok
[00:29:57] <acrichto> 0.198s => 0.91
[00:30:01] <acrichto> 091*
[00:30:06] <brson> erickt: i bumped to 65, and there will probably be a few uninvited mozillians as well
[00:30:09] <dbaupp> sp3d: there's been no recent comments on https://github.com/mozilla/rust/issues/2925 , so I'd assume that no-one's actively working on it
[00:30:18] <erickt> brson: woot
[00:30:36] <pcwalton> acrichto: maybe LTO-ing with libuv could make up some more
[00:30:46] <sp3d> thanks
[00:30:52] <acrichto> pcwalton: maybe, LTO between a native library and a rust library could get interesting
[00:31:02] <pcwalton> we want it for jemalloc
[00:31:17] <pcwalton> I discovered in Suwon that WebKit is inlining malloc for frame constructions
[00:31:24] <pcwalton> inlining the fast path
[00:31:29] <acrichto> wow
[00:31:39] <acrichto> does lto "just work" if it's in the right format
[00:31:40] <pcwalton> now they mainly use a custom malloc for frame poisoning
[00:31:44] <pcwalton> yes I believe strcat has done it
[00:31:55] <acrichto> like if I pass it to 'ld', it'll work?
[00:32:00] <acrichto> b/c that sounds implausible
[00:32:01] <dbaupp> https://github.com/mozilla/rust/wiki/Mixed-language-link-time-optimization
[00:32:05] <pcwalton> oh no, you have to use LLVM
[00:32:09] <pcwalton> like ^
[00:32:16] <strcat> acrichto: you need a linker with LTO support (gold, lld)
[00:32:25] <acrichto> dbaupp: that's all translating rust to bitcode first
[00:32:33] <strcat> acrichto: that's what LTO does
[00:32:33] <acrichto> man we need lld
[00:32:34] <pcwalton> that's what I mean by LTO
[00:33:25] <strcat> the dumb version of whole program optimization is to make a bunch of bytecode files, llvm-link them together, llc to an object and link
[00:33:28] <strcat> actual LTO has linker support
[00:33:42] <strcat> so it can remove every external symbol that's not 'main'
[00:33:49] *** Joins: mib_upp5fm (Mibbit@C83F40FA.C3C4EFEF.4BC5EF08.IP)
[00:33:50] <strcat> because it actually knows what's needed
[00:34:00] *** Quits: mib_upp5fm (Mibbit@C83F40FA.C3C4EFEF.4BC5EF08.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[00:34:57] <pcwalton> acrichto: do you envision that #[no_uv] will be the way to get 1:1 threading?
[00:35:11] <acrichto> pcwalton: it probably needs to be a little prettier, but yes
[00:35:12] <pcwalton> so task::spawn turns into pthread create
[00:35:14] <pcwalton> ok
[00:35:22] <strcat> pcwalton: it can't really
[00:35:26] *** Quits: jordyd (jordyd@moz-9E2129EA.seg112.ucf.edu) (Ping timeout)
[00:35:27] <strcat> with pthread create you need to join
[00:35:38] <strcat> you can detach
[00:35:45] <strcat> but then main needs to call pthread_exit at the end
[00:35:55] <strcat> and your exit status will always be 0, unless you call exit somewhere
[00:36:01] *** Joins: jordyd (jordyd@moz-9E2129EA.seg112.ucf.edu)
[00:36:09] *** Quits: spott (spott@moz-9B11536C.hsd1.co.comcast.net) (Client exited)
[00:36:10] <pcwalton> hmm, maybe we should change our M:N threading model to be implementable on top of pthreads
[00:36:24] <acrichto> how does that mean that task::spawn can't be a creation of a thread?
[00:36:27] <pcwalton> our task model, that is
[00:36:28] <strcat> if you want to support the current task API you need some kind of managed global state and entry/exit points
[00:36:34] <strcat> acrichto: where does it get cleaned up?
[00:36:42] <strcat> pthread_create has to be followed by pthread_join on the thread
[00:36:43] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[00:36:46] <acrichto> there will always be a main wrapper
[00:36:47] <strcat> unless you're making detached threads
[00:36:57] <acrichto> you can't "just run" rust code
[00:36:59] <strcat> acrichto: if you call pthread_exit in main, exit status is always 0
[00:37:17] <pcwalton> is there any perf problem to just detaching?
[00:37:18] <strcat> there's no way to wait on all detached threads to finish and then exit with a certain status
[00:37:30] <strcat> pcwalton: no
[00:37:33] <pcwalton> ok
[00:37:39] <strcat> but if you use detached threads valgrind/helgrind don't work
[00:37:41] <strcat> kind of sucks.
[00:37:43] *** Quits: freezerburnv (freezerbur@moz-E25EEE31.washdc.fios.verizon.net) (Quit: freezerburnv)
[00:37:58] <strcat> pcwalton: on linux, the kernel knows how to zero a bit of memory when a thread ends
[00:38:13] <pcwalton> I see.
[00:38:16] <strcat> and glibc uses it to implement detached threads (to zero out the cache entries)
[00:38:24] <strcat> but valgrind can't understand it
[00:38:29] <pcwalton> we could change it to be like Go's model, when the main thread goes away then the process is just dead
[00:38:43] <strcat> that'd work, but it's painful ;p
[00:38:47] <pcwalton> yeah, I don't like it much
[00:38:49] <acrichto> pcwalton: I never liked that much ...
[00:38:52] <pcwalton> which is why we didn't do it that way
[00:39:04] <acrichto> I don't see a problem with having the main thread continue to be special
[00:39:05] <o11c> As much as I would like being able to pthread_exit() the main thread, there are just too many bugs with that
[00:39:12] <strcat> pcwalton: https://github.com/thestinger/rust-core/blob/master/test/thread.rs#L33 how I'm doing it right now
[00:39:17] <o11c> the main thread is special to the kernel, whether we want it or not
[00:39:33] <strcat> pcwalton: they call join in the dtor, and you can also join early to retrieve the result
[00:39:36] * strcat shrugs
[00:39:48] *** Joins: willingc (willingc@moz-B4760708.san.res.rr.com)
[00:39:57] <o11c> the question is what to expose to the higher-level API, and how to keep the main thread alive if you want to pretend it ended
[00:40:21] *** Joins: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP)
[00:40:32] <strcat> o11c: pthread_exit in main does work
[00:40:39] <strcat> it's defined to work
[00:40:42] <pcwalton> adding explicit joins adds a lot of surface to the API :(
[00:40:46] <strcat> but it's also defined to make the exit status 0
[00:41:01] <o11c> strcat: "work", but with funny stuff
[00:41:03] *** Quits: moostik (Icedove@moz-63ED7231.w82-121.abo.wanadoo.fr) (Ping timeout)
[00:41:04] <pcwalton> but I do want a good implementation on top of 1:1
[00:41:06] <pcwalton> that is an explicit goal
[00:41:12] <pcwalton> as far as I'm concerned
[00:45:54] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[00:46:40] *** Joins: moostik (Icedove@moz-63ED7231.w82-121.abo.wanadoo.fr)
[00:47:40] <pcwalton> so it seems to me there are two orthogonal design concerns here: (1) whether to detach; (2) when the process should terminate
[00:48:27] <pcwalton> pthreads likes non-detachment and immediate termination, while humans like detachment and termination
[00:48:32] <pcwalton> termination after all threads are gone
[00:48:44] <pcwalton> so I think maybe the right thing is to expose the low-level API, but to make the nice versions the default
[00:48:52] <pcwalton> so you can get a join if you ask for it, but otherwise you get detachment by default
[00:49:03] <pcwalton> and main will sleep until all threads are dead by default, unless you turn that off
[00:49:28] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[00:49:40] <pcwalton> I think both can be implemented on top of 1:1
[00:49:58] <pcwalton> the main thing can be implemented with an unsafe-mut shared counter of threads
[00:49:59] <tikue> if we want the api to be the same between 1:1 and M:N, what would happen to the runtime task model if non-detachment or immediate termination were defaults?
[00:50:31] <strcat> pcwalton: humans generally like joining afaik
[00:50:41] *** Joins: ktt3ja (Mibbit@moz-D69B60E4.hsd1.va.comcast.net)
[00:50:41] * cmr likes joining
[00:50:55] <pcwalton> tikue: immediate termination can result in the same badness as calling os::exit(), so it's not bad
[00:50:59] <pcwalton> ok, we could make that the default too
[00:51:04] <pcwalton> instead rather
[00:51:05] <pcwalton> I don't really care
[00:51:07] <strcat> pcwalton: joining == ownership, and a clear synchronization point
[00:51:11] <pcwalton> sure
[00:51:22] <strcat> detaching means the tasks aren't a tree, they're just a blob of tasks and you don't know when they overlap/end
[00:51:22] <pcwalton> tikue: it's no worse than what we already have
[00:51:43] <pcwalton> ok, I'll bring this up in the meetings
[00:52:11] <strcat> detaching is definitely easier if you're already communicating via channels and so on with a clear purpose
[00:52:14] <tikue> so would joining replace futures::spawn?
[00:52:20] <pcwalton> yeah, I think servo will use both
[00:52:37] <pcwalton> tabs and frames have very dynamic extents
[00:52:42] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[00:52:43] <strcat> you always need *some* synchronization, and join is the common case imo
[00:52:44] <pcwalton> but things like layout operations don't
[00:52:50] <strcat> pcwalton: but you still have a handle to the thread somewhere
[00:52:57] <pcwalton> tikue: that's a good point, it could.
[00:53:21] <pcwalton> strcat: well, you have a handle to a message channel to it.
[00:53:24] <strcat> detaching means you don't have to keep around a Thread, but you still have to keep around something
[00:53:33] <pcwalton> in the joining model you'd have a handle to the thread and the communications channel to it
[00:53:40] <strcat> yeah
[00:54:16] <strcat> but joining does provide an easy way to sync with the finish without adding more communication
[00:54:28] <tikue> that's a good point
[00:54:30] <pcwalton> yeah, you don't have to pass an exit channel
[00:54:30] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[00:54:32] <pcwalton> ok, so we can expose a pthread-like .join() and .detach() API
[00:54:47] <pcwalton> and then also layer an optional "sleep main until all threads are dead" system on top
[00:55:10] <strcat> pcwalton: I was thinking something like 'fn spawn(proc() -> A) -> Thread<A>' and 'fn spawn_detached(proc())'
[00:55:11] *** dew1 is now known as dew
[00:55:19] <pcwalton> we already have the concept of "task modes"
[00:55:33] <pcwalton> oh, well, whether you detached changes the return value
[00:55:36] <pcwalton> so yeah, maybe we need two methods
[00:55:50] <strcat> although when I tried to add detached threads to rust-core I couldn't figure out why it was leaking memory - turns out valgrind just can't understand it
[00:56:13] <strcat> it's painful to have valgrind thinking there is a non-deterministic leak :(
[00:56:13] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[00:56:20] <strcat> could suppress it but...
[00:56:29] <pcwalton> sounds like a valgrind bug really
[00:56:34] <pcwalton> but if we support joining you can just avoid detaching
[00:58:02] *** Quits: nsf (nsf@moz-EEF3238A.convex.ru) (Quit: WeeChat 0.4.2)
[00:59:35] *** Joins: meTaAU_ (admin@moz-EA9A703B.lns20.per2.internode.on.net)
[00:59:48] *** Quits: meTaAU (admin@moz-C8A20DFA.lns20.per1.internode.on.net) (Ping timeout)
[01:01:06] *** Quits: alisdair (textual@moz-2F3322CF.hsd1.tx.comcast.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[01:01:12] *** Joins: peterdn (chatzilla@moz-30BAAE88.as13285.net)
[01:01:57] <pcwalton> newcomers to rust sure do use macros a lot :)
[01:02:11] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[01:02:11] *** Joins: fyolnish (fyolnish@moz-ABA054A.uqwimax.jp)
[01:03:00] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[01:03:25] <tikue> i tried implementing a macro for sml-style functions but couldn't figure it out 
[01:03:53] *** Quits: fyolnish (fyolnish@moz-ABA054A.uqwimax.jp) (Ping timeout)
[01:03:53] *** Quits: lkuper (lkuper@moz-D862222C.dhcp-bl.indiana.edu) (Ping timeout)
[01:04:36] <o11c> hm ... how do you get the equivalent of __FILE__, __LINE__, and __FUNCTION__ in rust?
[01:04:42] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[01:05:06] <cmr> o11c: file!(), line!()
[01:05:11] <cmr> there's no function!() yet iirc
[01:05:15] *** Joins: happy4crazy (happy4craz@moz-C881C743.dyn.optonline.net)
[01:05:18] <cmr> though I vaguely remember someone working on it
[01:05:28] <cmr> rusti: (function!(), func!())
[01:05:29] -rusti- <anon>:9:10: 9:18 error: macro undefined: 'function'
[01:05:29] -rusti- <anon>:9          (function!(), func!())
[01:05:29] -rusti-                    ^~~~~~~~
[01:05:29] -rusti- application terminated with error code 101
[01:06:07] <o11c> rusti: (file!(), line!())
[01:06:08] -rusti- ("<anon>", 9u)
[01:06:20] <pcmattman> line 9 :)
[01:06:41] <klutzy> cmr: this? https://github.com/mozilla/rust/pull/9668
[01:06:47] <klutzy> was not merged
[01:06:52] <pcmattman> rusti: (file!(), line!())
[01:06:53] -rusti- ("<anon>", 9u)
[01:08:31] *** Joins: josh (josh@moz-6FB23C25.hvc.res.rr.com)
[01:09:18] *** Joins: meTaAU (admin@moz-B04D3546.lns20.per1.internode.on.net)
[01:09:38] *** Quits: meTaAU_ (admin@moz-EA9A703B.lns20.per2.internode.on.net) (Ping timeout)
[01:11:59] *** Quits: willingc (willingc@moz-B4760708.san.res.rr.com) (Client exited)
[01:12:21] *** Joins: fyolnish (fyolnish@moz-ABA054A.uqwimax.jp)
[01:13:35] *** Joins: sammykim (sammy.kim@5AB4884B.FCC4549.14D5B978.IP)
[01:14:05] *** Quits: fyolnish (fyolnish@moz-ABA054A.uqwimax.jp) (Ping timeout)
[01:14:11] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[01:16:45] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[01:16:59] *** Quits: thewonderidiot (mstewart@moz-E41129BA.ipnetworksinc.net) (Quit: Leaving.)
[01:18:52] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Quit: Gone to save the world!)
[01:19:59] *** Joins: Sgeo (quassel@moz-D0F30617.dyn.optonline.net)
[01:21:45] *** Joins: freezerburnv (freezerbur@moz-E25EEE31.washdc.fios.verizon.net)
[01:26:00] *** Quits: ricepuddin (graham@moz-7D68765A.cable.virginm.net) (Ping timeout)
[01:27:57] *** Joins: spott (spott@moz-9B11536C.hsd1.co.comcast.net)
[01:28:39] *** Quits: spott (spott@moz-9B11536C.hsd1.co.comcast.net) (Connection reset by peer)
[01:28:50] *** Joins: spott (spott@moz-9B11536C.hsd1.co.comcast.net)
[01:28:58] *** Joins: willingc (willingc@moz-B4760708.san.res.rr.com)
[01:32:21] *** Quits: jordyd (jordyd@moz-9E2129EA.seg112.ucf.edu) (Ping timeout)
[01:36:02] *** Quits: willingc (willingc@moz-B4760708.san.res.rr.com) (Client exited)
[01:37:01] *** Quits: eternaleye (eternaleye@moz-5668AFCB.hsd1.wa.comcast.net) (Ping timeout)
[01:37:33] <pcwalton> can someone check my Japanese in this PR
[01:37:39] <pcwalton> I'm changing the tutorial
[01:39:26] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[01:40:01] *** Joins: Shaladdle (Shaladdle@moz-424BC304.hsd1.pa.comcast.net)
[01:41:08] *** Quits: notmatt (notmatt@CC62CF7E.1E7FDFDB.A82DBDDB.IP) (Client exited)
[01:41:36] *** Quits: derek_c (chatzilla@moz-66F31E3.cit.cornell.edu) (Client exited)
[01:42:20] <pcwalton> acrichto: r? https://github.com/mozilla/rust/pull/10561
[01:42:41] *** Joins: eternaleye (eternaleye@moz-5668AFCB.hsd1.wa.comcast.net)
[01:44:45] <klutzy> pcwalton: `~` `proc` -> `proc`  https://github.com/mozilla/rust/pull/10561/files#diff-bdde545527b1dcf12d80a3ff05955a9aR3518
[01:45:18] <klutzy> ah wait
[01:45:31] *** Joins: willingc (willingc@moz-B4760708.san.res.rr.com)
[01:45:53] <dbaupp> are the .pot's even up-to-date?
[01:46:47] <klutzy> pcwalton: `~` `proc` 型  で -> `~` `proc`で
[01:46:56] <pcwalton> oh, ok
[01:46:58] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[01:46:59] <klutzy> but I think ja/po is already bitrotted
[01:47:05] <pcwalton> I don't know the kanji 型
[01:47:07] <pcwalton> thanks
[01:48:40] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[01:57:01] *** Quits: Sharp (Sharp@1710C26.8381A41.8725677B.IP) (Quit: Sharp)
[01:57:40] *** Quits: Ralith (ralith@A8995AA9.62B6AF6A.922221DB.IP) (Ping timeout)
[02:01:42] *** Quits: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com) (Quit: Jesse)
[02:01:48] *** Quits: tikue (tkuehn@CDCD6B77.F3E8A984.689607DE.IP) (Quit: tikue)
[02:03:07] *** Joins: fyolnish (fyolnish@moz-D4C64552.uqwimax.jp)
[02:04:09] *** Quits: boredomist (ruqs@8186917.CC8FA3EE.E3401B6E.IP) (Ping timeout)
[02:04:20] *** Joins: geoffhill (geoffhill@moz-738DC0DB.org)
[02:04:52] *** Quits: fyolnish (fyolnish@moz-D4C64552.uqwimax.jp) (Ping timeout)
[02:05:51] *** Quits: happy4crazy (happy4craz@moz-C881C743.dyn.optonline.net) (Quit: Leaving...)
[02:06:16] *** Quits: peterdn (chatzilla@moz-30BAAE88.as13285.net) (Ping timeout)
[02:07:32] *** Quits: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net) (Client exited)
[02:07:50] *** Quits: sammykim (sammy.kim@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[02:07:59] *** Joins: sammykim (sammy.kim@5AB4884B.FCC4549.14D5B978.IP)
[02:08:03] *** Joins: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net)
[02:09:44] *** Quits: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net) (Ping timeout)
[02:11:56] *** Joins: jordyd (jordyd@moz-F2B7909A.seg105.ucf.edu)
[02:12:49] *** Joins: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net)
[02:13:04] *** Quits: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net) (Client exited)
[02:13:04] *** Joins: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net)
[02:15:54] *** Joins: fabiand_ (fabiand@moz-44964451.adsl.alicedsl.de)
[02:16:31] *** Quits: fabiand (fabiand@moz-8144469F.adsl.alicedsl.de) (Ping timeout)
[02:18:47] *** Joins: canhtak (canhtak@moz-43EC0376.wl.t.ulaval.ca)
[02:20:46] *** Joins: thewonderidiot (mike@moz-5506A033.hsd1.ca.comcast.net)
[02:20:46] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[02:21:53] *** Quits: willingc (willingc@moz-B4760708.san.res.rr.com) (Client exited)
[02:24:39] *** Joins: fournm (Aria@moz-ABB60BA0.austin.res.rr.com)
[02:26:21] *** Joins: Jesse (jruderman@moz-9754CB0.hsd1.ca.comcast.net)
[02:27:44] *** Quits: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com) (Ping timeout)
[02:28:26] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[02:29:28] *** Quits: prooftechnique (prooftechn@moz-65B7D4EE.hsd1.vt.comcast.net) (Quit: )
[02:29:56] *** Joins: Ralith (ralith@moz-132F2FD4.sea.wa.customer.broadstripe.net)
[02:30:04] *** Joins: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com)
[02:30:14] *** Quits: azakai (alon@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[02:30:29] *** Quits: heftig (heftig@moz-4353C6FC.dip0.t-ipconnect.de) (Ping timeout)
[02:30:37] *** Quits: fabiand_ (fabiand@moz-44964451.adsl.alicedsl.de) (Ping timeout)
[02:30:43] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[02:31:02] *** Joins: heftig (heftig@moz-4353C6FC.dip0.t-ipconnect.de)
[02:31:28] <pcwalton> acrichto: updated the PR here to remove ~fn from the language https://github.com/mozilla/rust/pull/10561
[02:31:47] <acrichto> jeez you're just powering through that
[02:32:02] <pcwalton> not as fast as you've been powering through things lately ;)
[02:32:04] <pcwalton> dinner time
[02:32:07] <pcwalton> afterward, on to |A|->B
[02:33:13] *** Quits: pcwalton (pcwalton@moz-C07D5168.p2p.sfo1.mozilla.com) (Quit: pcwalton)
[02:33:17] <dbaupp> does that PR make spawn_with obselete?
[02:33:22] <dbaupp> oh, he left.
[02:34:33] *** Quits: jordyd (jordyd@moz-F2B7909A.seg105.ucf.edu) (Ping timeout)
[02:35:46] *** Joins: fyolnish (fyolnish@moz-BE2BAE5B.miinet.jp)
[02:35:47] *** Joins: glennsl (textual@moz-5D7B804F.getinternet.no)
[02:36:57] *** Quits: nejucomo (Adium@9F0867A2.BB950596.DFB232DA.IP) (Quit: Leaving.)
[02:39:09] *** Quits: fyolnish (fyolnish@moz-BE2BAE5B.miinet.jp) (Ping timeout)
[02:39:56] *** Joins: fyolnish (fyolnish@moz-BE2BAE5B.miinet.jp)
[02:40:09] *** Quits: tulloch (tulloch@moz-1C33A2E7.nat.csx.cam.ac.uk) (Ping timeout)
[02:43:51] *** Quits: carllerche (carllerche@moz-2B516F15.hsd1.or.comcast.net) (Quit: carllerche)
[02:44:39] *** Quits: fhahn (fhahn@moz-7924DB5C.vie.surfer.at) (Ping timeout)
[02:44:41] *** Joins: fhahn (fhahn@moz-7924DB5C.vie.surfer.at)
[02:44:48] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[02:45:08] *** Joins: tulloch (tulloch@moz-1C33A2E7.nat.csx.cam.ac.uk)
[02:45:32] *** Quits: jdm (jdm@moz-ED0C7AC7.hinet-ip.hinet.net) (Quit: Lost terminal)
[02:45:35] *** Joins: fabiand_ (fabiand@moz-D9C81F83.adsl.alicedsl.de)
[02:47:44] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[02:49:24] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[02:51:20] *** Joins: ianj (ianjneu@moz-7BA002E.hsd1.ma.comcast.net)
[02:51:28] *** Joins: pnathan1 (Adium@moz-5EBBDD83.tukw.qwest.net)
[02:51:35] *** Quits: KindOne (KindOne@moz-BF6D3F72.dynamic.ip.windstream.net) (Ping timeout)
[02:51:36] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[02:53:37] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[02:54:17] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Connection reset by peer)
[02:54:29] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[02:55:30] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[02:55:55] *** Joins: KindOne (KindOne@12AF4BBA.E1AE408F.34F73994.IP)
[02:59:51] *** Joins: GeneralMaximus (ankur@52FD6510.75FB07DC.8B6C1D65.IP)
[03:00:05] *** Joins: willingc (willingc@moz-B4760708.san.res.rr.com)
[03:01:32] *** Quits: jgilbert (jgilbert@moz-7B0110AD.mv.mozilla.com) (Ping timeout)
[03:04:08] *** Quits: brson (brson@6A848D32.C1B840DD.76F66111.IP) (Quit: leaving)
[03:06:21] *** Joins: jordyd (jordyd@B8DD47EA.9B8B0AD2.BB6D8913.IP)
[03:06:25] *** Joins: erickt (etryzelaar@49C4075F.3AC15C18.2321E71E.IP)
[03:08:27] *** Joins: nomadic (nomadic@moz-E01D5C49.hsd1.ga.comcast.net)
[03:09:36] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Ping timeout)
[03:13:37] *** jorendorff_away is now known as jorendorff
[03:14:01] *** Joins: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net)
[03:15:29] *** Quits: freezerburnv (freezerbur@moz-E25EEE31.washdc.fios.verizon.net) (Quit: freezerburnv)
[03:18:07] *** Quits: willingc (willingc@moz-B4760708.san.res.rr.com) (Client exited)
[03:23:32] *** Joins: willingc (willingc@moz-B4760708.san.res.rr.com)
[03:23:37] *** Joins: jdm (jdm@moz-99690620.hinet-ip.hinet.net)
[03:23:38] *** ChanServ sets mode: +o jdm
[03:25:07] *** Quits: willingc (willingc@moz-B4760708.san.res.rr.com) (Client exited)
[03:25:19] *** Quits: geoffhill (geoffhill@moz-738DC0DB.org) (Quit: )
[03:25:51] *** Joins: willingc (willingc@moz-B4760708.san.res.rr.com)
[03:26:07] *** jorendorff is now known as jorendorff_away
[03:27:28] <Eridius> cripes, rust-dev has been really popular lately
[03:28:13] *** Quits: sk (sk@61A494B3.BA40E8A.AAC02D62.IP) (Quit: Leaving)
[03:28:18] *** Quits: strcat (strcat@moz-61B073BC.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.2)
[03:30:37] *** Quits: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com) (Ping timeout)
[03:30:50] <dbaupp> Eridius: how many thousands of unread emails?
[03:33:10] *** Quits: zz_kimundi (kimundi@moz-6EA0FED4.dip0.t-ipconnect.de) (Ping timeout)
[03:33:54] *** Joins: mib_abwx6j (Mibbit@moz-E9280248.hsd1.co.comcast.net)
[03:34:14] <Eridius> dbaupp: only 50 right now
[03:34:21] <Eridius> but I'm not used to having to keep up with all this
[03:34:22] *** Quits: mib_abwx6j (Mibbit@moz-E9280248.hsd1.co.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[03:34:41] <Eridius> especially since I haven't really had any time to work on rust lately :/
[03:35:45] *** Quits: moostik (Icedove@moz-63ED7231.w82-121.abo.wanadoo.fr) (Ping timeout)
[03:36:30] *** Joins: zz_kimundi (kimundi@moz-3F7C7055.dip0.t-ipconnect.de)
[03:36:56] *** zz_kimundi is now known as kimundi
[03:37:15] <dbaupp> yeah, I haven't been reading large parts of the great justice one
[03:37:38] *** Quits: willingc (willingc@moz-B4760708.san.res.rr.com) (Client exited)
[03:37:39] <Eridius> oh god that one started back up?
[03:37:50] * Eridius eyes pcwalton
[03:38:06] <dbaupp> I've received 6 emails from that one in the last 2 hours
[03:38:09] <dbaupp> so yes
[03:40:34] *** Quits: rusti (rusti@moz-61B073BC.cpe.net.cable.rogers.com) (Ping timeout)
[03:41:58] *** Joins: willingc (willingc@moz-B4760708.san.res.rr.com)
[03:42:04] * Eridius emails the thread. :/
[03:42:28] *** Joins: carter (carter@moz-F3C2A2D8.nycmny.fios.verizon.net)
[03:43:24] *** Quits: Earnestly (earnest@38FE72A5.82423D8F.BFD1ABFD.IP) (Ping timeout)
[03:43:46] *** Joins: jaredhanson (jaredhanso@moz-B70A4AE7.lightspeed.sntcca.sbcglobal.net)
[03:43:52] *** Quits: jaredhanson (jaredhanso@moz-B70A4AE7.lightspeed.sntcca.sbcglobal.net) (Quit: jaredhanson)
[03:44:22] *** Quits: blank_name (blank_name@FAB53C88.7071B2C8.31EC03F3.IP) (Ping timeout)
[03:45:38] *** Joins: ross (ross@moz-5EA04060.br.br.cox.net)
[03:45:55] *** Quits: maxli (maxli@moz-4D28BA20.student.cs.uwaterloo.ca) (Quit: Leaving.)
[03:48:38] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[03:50:23] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[04:00:32] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[04:00:45] *** Quits: ianj (ianjneu@moz-7BA002E.hsd1.ma.comcast.net) (Input/output error)
[04:01:04] <aatch> Oh god, pointless syntax discussions.
[04:01:09] *** Joins: Paul_K (paul_k@BEF372A2.CA4A4D15.D758B1AA.IP)
[04:02:02] <aatch> I'm really not fond of the "I really like your language, I just think you should change everything about it"
[04:02:10] <aatch> posts
[04:02:38] <cmr> aatch: yeah, I just ignore
[04:03:00] <aatch> cmr, so do I mostly. But they come up in my emails so I at least end up being aware of it.
[04:03:15] <dbaupp> aatch: especially when it's "I've started reading the tutorial and ..."
[04:05:49] <aatch> I dunno... It seems to be a thing where they want <new language> to be *their* language.
[04:06:18] <aatch> Because, obviously, their use cases is the only one that matters.
[04:06:19] *** Joins: pcwalton (pcwalton@moz-DA87EE4.hsd1.ca.comcast.net)
[04:06:19] *** ChanServ sets mode: +ao pcwalton pcwalton
[04:06:25] <aatch> (bah, grammar)
[04:06:40] * cmr wants rust to be *my* language, but is already mostly-ideal
[04:07:01] *** Quits: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net) (Client exited)
[04:07:19] * dbaupp is happy to use the Rust others decide on, since the others seem to be pretty good at making good decisions
[04:07:32] *** Joins: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net)
[04:07:43] <aatch> cmr, I get that, and trying to promote decisions that you want is fine. But you also think about other use cases and other people.
[04:07:45] <dbaupp> pcwalton: does the proc() PR remove the need for task::spawn_with?
[04:07:51] <pcwalton> dbaupp: yup! \o/
[04:08:53] <aatch> My ideal language is pretty much Rust, but probably less focus on safety and more focus on expressiveness. However, I know that Rust is unlikely to sacrifice safety
[04:08:59] <aatch> so I leave it be.
[04:09:20] *** Quits: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net) (Ping timeout)
[04:09:43] <aatch> anyway, bus to catch
[04:10:06] <fournm> I've loved watching Rust because it definitely looks like (and from playing with it to a super limited amount) has been basically my ideal language
[04:12:00] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[04:15:22] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[04:16:02] *** Joins: maxli (maxli@moz-4D28BA20.student.cs.uwaterloo.ca)
[04:16:39] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[04:18:57] *** Joins: nejucomo (Adium@moz-434492BB.dsl.static.sonic.net)
[04:19:00] *** Quits: robn (robn@moz-76B0302C.static.internode.on.net) (Ping timeout)
[04:20:07] *** Joins: robn (robn@moz-76B0302C.static.internode.on.net)
[04:20:57] *** Joins: Axord (xord@moz-1B228827.lsanca.dsl-w.verizon.net)
[04:21:50] *** Quits: pnathan1 (Adium@moz-5EBBDD83.tukw.qwest.net) (Quit: Leaving.)
[04:23:52] *** Joins: tikue (tkuehn@moz-DB51A23.pitbpa.fios.verizon.net)
[04:24:32] *** Quits: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net) (Quit: Sharp)
[04:28:52] *** Quits: josh (josh@moz-6FB23C25.hvc.res.rr.com) (Quit: josh)
[04:30:32] *** Quits: jxv (jxv@moz-8FB92450.lightspeed.irvnca.sbcglobal.net) (Ping timeout)
[04:31:16] *** Quits: fhahn (fhahn@moz-7924DB5C.vie.surfer.at) (Ping timeout)
[04:31:33] *** Quits: eternaleye (eternaleye@moz-5668AFCB.hsd1.wa.comcast.net) (Ping timeout)
[04:31:50] *** Joins: fhahn (fhahn@moz-7924DB5C.vie.surfer.at)
[04:32:12] *** Joins: m_kato (m_kato@moz-C286AD9A.bitcat.net)
[04:33:18] *** Joins: eternaleye (eternaleye@moz-5668AFCB.hsd1.wa.comcast.net)
[04:35:30] *** Quits: nejucomo (Adium@moz-434492BB.dsl.static.sonic.net) (Quit: Leaving.)
[04:38:23] *** Joins: pnathan1 (Adium@moz-5EBBDD83.tukw.qwest.net)
[04:40:54] *** Quits: eternaleye (eternaleye@moz-5668AFCB.hsd1.wa.comcast.net) (Ping timeout)
[04:41:26] *** Quits: pnathan1 (Adium@moz-5EBBDD83.tukw.qwest.net) (Quit: Leaving.)
[04:42:53] *** Joins: eternaleye (eternaleye@moz-5668AFCB.hsd1.wa.comcast.net)
[04:44:11] *** Quits: quvarxa (chatzilla@moz-978E4C31.static.tpgi.com.au) (Ping timeout)
[04:45:06] *** Quits: Paul_K (paul_k@BEF372A2.CA4A4D15.D758B1AA.IP) (Client exited)
[04:45:37] *** Quits: jordyd (jordyd@B8DD47EA.9B8B0AD2.BB6D8913.IP) (Ping timeout)
[04:46:41] *** Quits: KindOne (KindOne@12AF4BBA.E1AE408F.34F73994.IP) (Ping timeout)
[04:47:50] *** Joins: pnathan1 (Adium@moz-5EBBDD83.tukw.qwest.net)
[04:48:01] *** Quits: lfox (lfox@moz-B8648F0F.nycmny.fios.verizon.net) (Quit: ZZZzzz…)
[04:49:13] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[04:50:54] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[04:53:06] *** Quits: Ralith (ralith@moz-132F2FD4.sea.wa.customer.broadstripe.net) (Ping timeout)
[04:53:06] *** Quits: tulloch (tulloch@moz-1C33A2E7.nat.csx.cam.ac.uk) (Ping timeout)
[04:53:43] *** Quits: willingc (willingc@moz-B4760708.san.res.rr.com) (Client exited)
[04:54:27] *** Joins: KindOne (KindOne@moz-37B61578.dynamic.ip.windstream.net)
[04:55:23] *** Joins: eddyb (eddy@336E3A7F.D51DAF03.FB866788.IP)
[04:56:27] *** Quits: eddyb9 (eddy@336E3A7F.D51DAF03.FB866788.IP) (Quit: Leaving)
[05:00:57] *** Quits: Kxepal (Miranda@moz-ADF2988C.pppoe.mtu-net.ru) (Quit: Kxepal)
[05:01:19] *** Joins: Kxepal (Miranda@moz-ADF2988C.pppoe.mtu-net.ru)
[05:04:08] *** Joins: alisdair (textual@moz-2F3322CF.hsd1.tx.comcast.net)
[05:05:36] *** Quits: Shaladdle (Shaladdle@moz-424BC304.hsd1.pa.comcast.net) (Client exited)
[05:05:44] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[05:06:36] *** Joins: nejucomo (Adium@moz-434492BB.dsl.static.sonic.net)
[05:06:39] *** Quits: nejucomo (Adium@moz-434492BB.dsl.static.sonic.net) (Quit: nejucomo)
[05:07:30] *** Joins: nejucomo (Adium@moz-434492BB.dsl.static.sonic.net)
[05:07:56] *** Quits: nejucomo (Adium@moz-434492BB.dsl.static.sonic.net) (Quit: Leaving.)
[05:08:34] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[05:12:11] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[05:13:01] *** Quits: q66__ (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Ping timeout)
[05:13:39] *** Joins: blank_name (blank_name@FAB53C88.7071B2C8.31EC03F3.IP)
[05:14:41] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[05:16:30] *** Quits: erickt (etryzelaar@49C4075F.3AC15C18.2321E71E.IP) (Ping timeout)
[05:17:23] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[05:19:23] <acrichto> pcwalton: ping
[05:19:32] <pcwalton> acrichto: pong
[05:19:49] <sammykim> Is there anyone knows about this error? http://pastebin.mozilla.org/3632863
[05:19:51] <acrichto> pcwalton: some of the indentation and alignment got better, some looks like it got worse, was this an automated change?
[05:20:01] <pcwalton> which got worse?
[05:20:03] <pcwalton> it wasn't automated
[05:20:13] <acrichto> result.rs:381
[05:20:23] <acrichto> vec.rs:2123
[05:20:24] <klutzy> sammykim: #[feature(managed_boxes)]?
[05:20:29] <sammykim> I am wondering why it doesn't work anymore above one ? :(
[05:20:34] <sammykim> Oh, Thanks klutzy
[05:20:34] <pcwalton> acrichto: that's the style I prefer
[05:20:43] <acrichto> pcwalton: eh ok, just curious
[05:20:49] <pcwalton> treats type parameters more like regular parameters
[05:20:49] <acrichto> r+
[05:20:55] <pcwalton> sometimes it's necessary when trait bounds get long
[05:21:00] <sammykim> Why does it happend? Is it related garbage collector so?
[05:21:08] <acrichto> I guess so yeah
[05:21:21] <pcwalton> I don't feel strongly though
[05:22:02] <acrichto> I'd rather change the syntax
[05:22:15] <pcwalton> to what?
[05:22:32] <sammykim> klutzy : Am I supposed to put it above struct Point?
[05:22:44] <acrichto> pcwalton: oh I mean land the patch
[05:22:52] <pcwalton> oh, I see
[05:23:30] <klutzy> sammykim: @-pointers will be disappeard, so we forbid any usage of `let a: @int = ...` unless #[feature] is attached
[05:23:56] <klutzy> but it seems that it's ok to use `let a = @1` without explicit type. I think this is subtle
[05:24:20] <pcwalton> usually when I indent function header I try these: (1) put it all on one line; (2) indent the -> return type only, the '-' of the arrow underneath the first regular or type parameter; (3) put every type parameter, formal parameter, and return value on a separate line, next to each other
[05:24:29] <pcwalton> those are simple enough rules for the pretty printer It hink
[05:24:30] <pcwalton> I think
[05:24:35] <pcwalton> but we could add more attempts in there
[05:24:37] *** Quits: canhtak (canhtak@moz-43EC0376.wl.t.ulaval.ca) (Quit: canhtak)
[05:27:01] <sammykim> klutzy : Even if I use #[feature(managed_boxes)], It doesn't work. It still says same error like before. 
[05:27:16] <sammykim> I put that above struct Point.
[05:27:37] <sfackler> sammykim: it needs to be placed at the crate root
[05:27:39] <klutzy> sammykim: #[feature] is crate-level attribute
[05:27:56] <sammykim> Oh Sorry
[05:28:02] <sammykim> I forgot semi colon :(
[05:28:03] <sammykim> Thanks!
[05:28:07] <klutzy> sammykim: by the way, there is rust-kr.org with webirc so you could chat with korean people ;)
[05:36:49] *** Joins: beifeng (Mibbit@284C36E7.3062CEC3.670EEFD.IP)
[05:38:05] *** Joins: boredomist (ruqs@B16F530C.DC641F2C.BCAEBB33.IP)
[05:42:30] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[05:45:51] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[05:45:51] *** ChanServ sets mode: +ao dherman dherman
[05:47:27] *** Quits: yusukesuzuki (yusukesuzu@moz-FEE44B6.net220148245.t-com.ne.jp) (Ping timeout)
[05:47:44] *** Joins: yusukesuzuki (yusukesuzu@moz-FEE44B6.net220148245.t-com.ne.jp)
[05:48:57] *** Quits: recrack (Mibbit@B4104EBB.3CC170B1.1E14B209.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[05:49:04] *** Joins: recrack (Mibbit@B4104EBB.3CC170B1.1E14B209.IP)
[05:49:59] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[05:50:36] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Ping timeout)
[05:50:43] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[05:50:59] *** Quits: jdm (jdm@moz-99690620.hinet-ip.hinet.net) (Ping timeout)
[05:51:41] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[05:53:07] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[05:53:33] *** Quits: cubic (cubic@moz-80241A3A.mc.videotron.ca) (Quit: Leaving)
[05:56:00] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[05:56:04] *** Joins: jdm (jdm@moz-99690620.hinet-ip.hinet.net)
[05:56:04] *** ChanServ sets mode: +o jdm
[05:58:24] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[05:58:29] *** Quits: spott (spott@moz-9B11536C.hsd1.co.comcast.net) (Client exited)
[06:01:50] *** Joins: axitkhurana (Adium@34C7F9C0.B32F1A35.6AA50C35.IP)
[06:02:19] *** Joins: tulloch (tulloch@moz-1C33A2E7.nat.csx.cam.ac.uk)
[06:02:33] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[06:04:08] *** Quits: tulloch (tulloch@moz-1C33A2E7.nat.csx.cam.ac.uk) (Ping timeout)
[06:04:55] *** Quits: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net) (Ping timeout)
[06:05:39] *** Joins: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net)
[06:09:10] *** Quits: anshin (anshin@CD85F10D.F21429E2.354459FA.IP) (Quit: anshin)
[06:13:02] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[06:16:29] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[06:17:32] <sam113101> 05H11E02L03L07O04?
[06:18:20] <sam113101> HELLO?
[06:19:38] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[06:19:59] * ChrisMorgan just found that Android's RenderScript also uses the .rs extension
[06:20:12] *** Joins: Ralith (ralith@moz-132F2FD4.sea.wa.customer.broadstripe.net)
[06:20:36] *** Joins: carllerche (carllerche@moz-48FA6EE9.hsd1.or.comcast.net)
[06:20:47] <sam113101> too bad rust is already more popular than renderscript
[06:20:50] <cmr> And .rst is taken, I guess that leaves .rust :p
[06:21:03] <sam113101> what about .r?
[06:21:28] <cmr> R
[06:21:29] <ChrisMorgan> sam113101: R uses that.
[06:21:35] <sam113101> shiiiiiieeeeettttttt
[06:21:46] * ChrisMorgan is certainly  not suggesting that Rust budge
[06:22:19] * ChrisMorgan is just going through https://github.com/blackducksw/ohcount/pull/26#issuecomment-28766898 and https://gist.github.com/pankajdoharey/5870f41afc40cae80511, classifying things using .rs
[06:22:25] <sam113101> so, mod is how you import modules, and use is how you import names in the current scope, right?
[06:22:36] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Ping timeout)
[06:23:10] <ChrisMorgan> Sounds about right.
[06:23:54] <cmr> happily, a bunch of those *are* rust
[06:24:26] *** Quits: cdidd (cdidd@moz-BD0F9CA8.broadband.corbina.ru) (Ping timeout)
[06:25:38] <sam113101> can you mod things multiple levels deep without doing that block thing? say, mod farm::barn; instead of mod farm { mod barn; } ?
[06:26:48] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[06:27:42] <ChrisMorgan> sam113101: no, nor can I see any reason why you'd want to.
[06:28:44] <sam113101> if I do
[06:28:56] <sam113101> mod farm; does it import everything from farm?
[06:29:36] <strcat> sam113101: what do you mean import?
[06:29:37] <ChrisMorgan> It *declares* the module farm.
[06:29:52] <strcat> mod farm; is equivalent to mod farm { /* contents of the file farm.rs */ }
[06:30:09] <sammykim> Isn't managed closure supported anymore?
[06:30:47] *** Quits: carllerche (carllerche@moz-48FA6EE9.hsd1.or.comcast.net) (Quit: carllerche)
[06:30:47] <ChrisMorgan> sammykim: I believe that is correct.
[06:30:48] *** Quits: tikue (tkuehn@moz-DB51A23.pitbpa.fios.verizon.net) (Quit: tikue)
[06:30:50] <sam113101> ok
[06:30:52] * ChrisMorgan is getting good at suggesting that scripting languages using the .rs extension change. https://github.com/AdamBrodzinski/RedScript/issues/1, now https://github.com/unvell/ReoScript/issues/5
[06:31:31] <sam113101> strcat: what's the point of doing mod mammals { mod humans; }, then? why just not mod mammals; ?
[06:31:39] *** Joins: cdidd (cdidd@moz-D1807593.broadband.corbina.ru)
[06:32:09] <dbaupp> ChrisMorgan: what happens when you hit something older than Rust?
[06:32:18] <cmr> sam113101: `mod mammals { ... }` is different than `mod mammals;`
[06:32:35] <sammykim> ChirsMorgan : Thanks, Is it related to managed box?
[06:32:36] <ChrisMorgan> dbaupp: I'm only doing it where I reckon I can successfully intimidate them and where it doesn't really matter anyway :P
[06:32:38] <cmr> sam113101: the first introduces a module which you can put items into directly, the second loads a file from the filesystem.
[06:32:55] <dbaupp> ChrisMorgan: so not filing a bug on renderscript?
[06:33:11] *** Quits: axitkhurana (Adium@34C7F9C0.B32F1A35.6AA50C35.IP) (Quit: Leaving.)
[06:33:18] <sam113101> I see
[06:33:25] <ChrisMorgan> No, I think it's too well established (though certainly not widely used) to be worthwhile doing.
[06:33:41] <dbaupp> although, it's only recent, so they are intruding on our territory. >:(
[06:33:55] *** Quits: pcwalton (pcwalton@moz-DA87EE4.hsd1.ca.comcast.net) (Quit: pcwalton)
[06:34:05] <cmr> Quick, let's get IANA registered!Q
[06:34:05] <sam113101> does anyone have a color-enabled IRC client here? I want to test something
[06:34:31] <cmr> sam113101: I'm afraid to say yes :P
[06:34:41] * dbaupp has one too
[06:34:47] <sam113101> alright: <<EOT
[06:34:51] <ChrisMorgan> dbaupp: start of 2011, Honeycomb.
[06:34:51] <sam113101> 0,5WHY 
[06:34:55] <sam113101> 2G4o8o2g3l4e 
[06:35:00] <sam113101> 2G4o8o2g3l4e 0,5WHY 
[06:35:02] <ChrisMorgan> Why not?
[06:35:06] <sam113101> 0,5WHY 2G4o8o2g3l4e 
[06:35:09] <sam113101> EOT;
[06:35:13] <dbaupp> ChrisMorgan: waaay after us
[06:35:18] <sam113101> can someone take a screenshot, please?
[06:35:33] <ChrisMorgan> I know, I know. But I doubt very much that they'll switch.
[06:35:34] *** Joins: adu (ajr@61210CE3.1C3331CA.DA1C73DD.IP)
[06:35:52] *** Joins: jstevans (Instantbir@19BF78A1.FA95BF59.B7830B68.IP)
[06:35:53] *** Joins: axitkhurana (Adium@34C7F9C0.B32F1A35.6AA50C35.IP)
[06:35:57] <dbaupp> sam113101: http://i.imgur.com/TGuBVvL.png
[06:35:57] <cmr> sam113101: http://i.imgur.com/raK5Shj.png
[06:35:59] <cmr> damn!
[06:36:10] <cmr> Slow by a subsecond :p
[06:36:28] <ChrisMorgan> sam113101: Pidgin (I know, haven't shifted to a better client yet): WHY is always white-on-magenta, Google is appropriately coloured letters on white.
[06:36:40] <ChrisMorgan> s/magenta/maroon/
[06:37:04] <jstevans> Hopefully I'm not the first one to be in here asking, but my team (Rust OS class) is working on an ARM kernel in Rust, and we're... having trouble compiling Rust to ARM assembly...
[06:37:04] <dbaupp> ChrisMorgan: we can get the *whole* rust community to boycott google until they switch
[06:37:16] <dbaupp> (I'm sure they'd definitely care about all 100 of us.)
[06:37:34] <sam113101> cmr sees what I see, I think I screwed up my 0,5WHY 
[06:37:58] <dbaupp> Luqman: ^  ( jstevans wants to compile Rust to ARM)
[06:37:59] <cmr> jstevans: rustc -S doesn't do it?
[06:38:29] <ChrisMorgan> jstevans: are you trying to compile rustc for ARM, or cross-compile a regular Rust binary to ARM?
[06:38:57] <ChrisMorgan> (I'm pretty sure it's the second, I just want to be certain.)
[06:39:01] <jstevans> ChrisMorgan: I believe I'm cross compiling? I want to take a .rs file on an x86 machine, and make an ARM assembly .S file.
[06:39:10] <sam113101> cmr: what's your client?
[06:39:16] <cmr> sam113101: weechat
[06:39:35] <dbaupp> jstevans: oh, you want the assembly itself, not just a binary?
[06:40:04] <sam113101> I use weechat too
[06:40:22] <jstevans> dbaupp: I believe I want the assembly, unless there's a good way to link a .rs file to a .s file
[06:40:39] <jstevans> dbaupp: Although, is it harder to get the intermediary assembly?
[06:40:47] <cmr> jstevans: rustc -c makes object files
[06:41:27] <ChrisMorgan> jstevans: I've gone through https://github.com/mozilla/rust/wiki/Doc-building-for-android before, just substituting arm-linux-androideabi with arm-linux-unknown-gnueabi and dropping some of the Android-specific things
[06:43:08] *** Joins: tjc (tjc@moz-6EB4E533.dsl.tsoft.com)
[06:43:08] *** ChanServ sets mode: +o tjc
[06:44:38] *** Quits: alisdair (textual@moz-2F3322CF.hsd1.tx.comcast.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[06:47:20] <ChrisMorgan> dbaupp: what do you reckon: should I file a request for RenderScript to change? What would they change *to*?
[06:48:32] <ChrisMorgan> (I would estimate the probability of such a request being granted as below 0.05.)
[06:48:44] * dbaupp agrees
[06:49:04] <dbaupp> it's probably not a productive use of time
[06:49:16] *** Joins: alonlevy (alon@moz-FED7051B.bb.netvision.net.il)
[06:49:24] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[06:50:24] *** Quits: thewonderidiot (mike@moz-5506A033.hsd1.ca.comcast.net) (Connection reset by peer)
[06:50:43] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[06:52:31] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[06:56:36] <cmr> rusti: ::;
[06:56:38] -rusti- error: internal compiler error: unexpected failure
[06:56:38] -rusti- note: the compiler hit an unexpected failure path. this is a bug
[06:56:38] -rusti- note: try running with RUST_LOG=rustc=1 to get further details and report the results to github.com/mozilla/rust/issues
[06:56:39] -rusti- application terminated with error code 101
[06:56:42] <cmr> heh
[06:56:51] <cmr> I didn't realize that was as ICE before
[06:57:16] <ChrisMorgan> Ah yes, the pamaayim nekudotayim test.
[06:57:46] * ChrisMorgan loves being exasperated by PHP
[06:57:47] <klutzy> I really thank to php for suggesting great testfile name
[06:59:35] *** Joins: r-A (r-a@BC4D85C9.B543C4DE.3933CC16.IP)
[07:08:15] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[07:09:22] *** Joins: spott (spott@moz-9B11536C.hsd1.co.comcast.net)
[07:09:30] *** Quits: carter (carter@moz-F3C2A2D8.nycmny.fios.verizon.net) (Quit: Textual IRC Client: www.textualapp.com)
[07:10:58] *** Joins: quvarxa (chatzilla@moz-978E4C31.static.tpgi.com.au)
[07:11:02] *** Quits: spott (spott@moz-9B11536C.hsd1.co.comcast.net) (Ping timeout)
[07:16:01] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[07:17:25] *** Quits: axitkhurana (Adium@34C7F9C0.B32F1A35.6AA50C35.IP) (Quit: Leaving.)
[07:20:16] *** Joins: axitkhurana (Adium@34C7F9C0.B32F1A35.6AA50C35.IP)
[07:20:22] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[07:21:31] *** Joins: Jackneill (Jackneill@moz-25A39FB3.pool.digikabel.hu)
[07:22:30] <strcat> ChrisMorgan: can you just disambiguate renderscript by looking for #pragma version(...) ?
[07:23:50] *** Joins: valenting (Thunderbir@808EE6B5.84D5EFD5.FB866788.IP)
[07:26:56] *** Quits: FreeFull (freefull@E424A224.387C8A0C.DC9D01B1.IP) (Quit: )
[07:30:12] *** Quits: valenting (Thunderbir@808EE6B5.84D5EFD5.FB866788.IP) (Ping timeout)
[07:32:52] *** Quits: pnathan1 (Adium@moz-5EBBDD83.tukw.qwest.net) (Quit: Leaving.)
[07:33:09] *** Quits: fournm (Aria@moz-ABB60BA0.austin.res.rr.com) (Quit: Leaving)
[07:34:48] *** kimundi is now known as zz_kimundi
[07:35:38] *** Joins: victorporof (victorporo@79FE7CA6.284D02A8.D111398B.IP)
[07:38:57] *** Quits: tjc (tjc@moz-6EB4E533.dsl.tsoft.com) (Quit: Textual IRC Client: www.textualapp.com)
[07:42:30] *** Quits: adu (ajr@61210CE3.1C3331CA.DA1C73DD.IP) (Quit: adu)
[07:45:47] *** Quits: jeaye (Jeaye@moz-34FEF2BB.hsd1.ca.comcast.net) (Quit: zzz)
[07:45:56] *** Joins: zakora (NC@moz-8EAF945F.fbx.proxad.net)
[07:46:15] *** Quits: engla (engla@moz-F64E1B0F.cust.bredbandsbolaget.se) (Ping timeout)
[07:51:28] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[07:53:09] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[07:56:24] *** Quits: blank_name (blank_name@FAB53C88.7071B2C8.31EC03F3.IP) (Ping timeout)
[07:56:31] *** Joins: blank_name (blank_name@FAB53C88.7071B2C8.31EC03F3.IP)
[07:58:53] <cmr> Anyone have announcements for TWiR?
[07:59:36] *** Joins: spott (spott@moz-9B11536C.hsd1.co.comcast.net)
[08:01:15] *** Joins: nsf (nsf@moz-EEF3238A.convex.ru)
[08:01:24] *** Quits: spott (spott@moz-9B11536C.hsd1.co.comcast.net) (Ping timeout)
[08:02:38] *** Quits: fyolnish (fyolnish@moz-BE2BAE5B.miinet.jp) (Client exited)
[08:02:59] *** Joins: fyolnish (fyolnish@moz-BE2BAE5B.miinet.jp)
[08:06:17] *** Quits: fyolnish (fyolnish@moz-BE2BAE5B.miinet.jp) (Ping timeout)
[08:07:27] *** Quits: anri (solancile@moz-E49E7C4B.hsd1.wa.comcast.net) (Quit: anri)
[08:13:09] <geomyidae> ChrisMorgan: you still have that portion of a bitcoin?
[08:13:09] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[08:13:51] * strcat had 5 dollars worth of bitcoins that are probably worth more now ;p
[08:14:47] <geomyidae> at least I thought someone sent him some btc on reddit, maybe I'm confusing people >_<
[08:14:52] *** Joins: [squiddy] (squiddy@moz-C6D7DCAF.adsl.alicedsl.de)
[08:15:18] <cmr> geomyidae: welcome back! haven't seen you around in a while
[08:15:41] <geomyidae> I lurk bunches, hello. :)
[08:16:35] <geomyidae> oh damn
[08:16:55] <cmr> http://cmr.github.io/blog/2013/11/19/this-week-in-rust/
[08:16:57] <strcat> someone gave me 5 dollars of bitcoins on reddit for removing 1200 of the old for loops
[08:16:59] <strcat> ;p
[08:17:03] <geomyidae> holy crap.
[08:17:14] <geomyidae> the btc I sent ... I think chris.... is now worth 440$
[08:17:21] <strcat> lol
[08:17:50] <strcat> wow I probably have 20 dollars or so in bitcoins now, still not enough for me to bother dealing with it ;p
[08:19:51] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[08:21:22] *** Quits: Jackneill (Jackneill@moz-25A39FB3.pool.digikabel.hu) (Input/output error)
[08:22:53] *** Joins: fyolnish (fyolnish@moz-BE2BAE5B.miinet.jp)
[08:23:52] *** Quits: recrack (Mibbit@B4104EBB.3CC170B1.1E14B209.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[08:24:01] <geomyidae> hm, and I want to ask about this: http://stackoverflow.com/a/17689618
[08:24:08] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[08:24:16] <geomyidae> which he wrote. What is the function of the Cell/take() pattern in that code?
[08:24:29] <cmr> geomyidae: it lets you move a value into a closure
[08:24:38] *** Quits: voxpopuli (fanservice@moz-FE161659.wv.cc.cmu.edu) (Ping timeout)
[08:24:41] <cmr> it's a hack. it is actually obsolete as of a few minutes ago
[08:24:53] <cmr> `proc`, which is a run-once closure, lets you move into it.
[08:25:17] <geomyidae> oh, the take() guarantees onceness
[08:25:21] <geomyidae> and now there's a kw for it
[08:25:21] <geomyidae> ?
[08:25:26] *** Joins: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net)
[08:25:39] <cmr> Well the `take` doesn't guarantee it: it just fails otherwise.
[08:25:52] <cmr> The typesystem won't let you call a `proc` more than once
[08:25:56] <cmr> But essentially yes
[08:26:16] <cmr> It's part of the ongoing closure reform.
[08:26:26] <geomyidae> I'm going to TIAS, but I guess I don't see immediately what would happen if it the cell stuff were just foregone.
[08:26:51] <cmr> won't compile
[08:27:55] <geomyidae> Hm, my rust install seems to be messed up, or are the io imports different too?
[08:28:04] <cmr> They are
[08:28:12] <cmr> See the most recent TWiR :P
[08:28:22] <geomyidae> oh you even linked me :P okay
[08:28:37] *** Quits: sigma (sigma@moz-23724D77.range86-160.btcentralplus.com) (Ping timeout)
[08:28:37] <cmr> Well it was a general anouncement
[08:28:37] <geomyidae> its... even the very first item. haha
[08:28:42] <cmr> Yup
[08:28:44] <cmr> !
[08:28:47] <strcat> geomyidae: a closure captures stuff and it becomes part of the environment
[08:28:57] <strcat> a call of that closure can't just move out of it, because it may still need to be there for another call
[08:29:08] <strcat> having onceness in the type system allows doing it.
[08:29:51] <strcat> although I'll be sad that we won't have once closures that aren't heap closures or heap closures that aren't once closures ;p
[08:29:58] <strcat> but I do like the trait direction it is moving
[08:30:05] *** Joins: sigma (sigma@moz-23724D77.range86-160.btcentralplus.com)
[08:30:34] *** Joins: Ms2ger (Ms2ger@moz-27A4C0A.ugent.be)
[08:31:23] <geomyidae> cmr: so will that become do spawn proc { ?
[08:31:33] *** Quits: Ms2ger (Ms2ger@moz-27A4C0A.ugent.be) (Max SendQ exceeded)
[08:31:35] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Connection reset by peer)
[08:31:39] <strcat> geomyidae: no, the syntax is no different
[08:31:48] *** Quits: jstevans (Instantbir@19BF78A1.FA95BF59.B7830B68.IP) (Connection reset by peer)
[08:31:52] *** Joins: Ms2ger (Ms2ger@moz-27A4C0A.ugent.be)
[08:32:33] <strcat> proc will replace ~fn as it is today, you won't notice a difference beyond not being able to call it more than once
[08:32:38] <strcat> and the fact that you can move out of the env now
[08:32:42] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[08:33:09] <strcat> I guess as long as you can borrow it to &fn you can still call it more than once anyway
[08:33:11] *** Quits: glennsl (textual@moz-5D7B804F.getinternet.no) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[08:33:29] <benh> cmr: thanks for twir, as usual :)
[08:33:58] *** Quits: Ms2ger (Ms2ger@moz-27A4C0A.ugent.be) (Ping timeout)
[08:34:19] *** zz_kimundi is now known as kimundi
[08:37:12] *** flaper87|afk is now known as flaper87
[08:37:18] *** Joins: sanxiyn (tinuviel@B4104EBB.3CC170B1.1E14B209.IP)
[08:37:21] *** Joins: amro (quassel@D9E34ACF.8AAAF769.FAAB0799.IP)
[08:38:12] <sanxiyn> I hate to bring this up
[08:38:16] <sanxiyn> but does https://github.com/mozilla/rust/wiki/Note-core-team need update?
[08:38:32] *** Joins: Ferreus (ferreus@moz-47A3CC18.dip0.t-ipconnect.de)
[08:38:45] *** Quits: [squiddy] (squiddy@moz-C6D7DCAF.adsl.alicedsl.de) (Quit: Leaving)
[08:39:05] *** Joins: Ms2ger (Ms2ger@moz-B4F6BCFC.ugent.be)
[08:41:40] <cmr> sanxiyn: Tim doesn't work at Mozilla anymore
[08:41:54] <sanxiyn> Yes that's what I meant
[08:42:33] *** Quits: victorporof (victorporo@79FE7CA6.284D02A8.D111398B.IP) (Quit: victorporof)
[08:43:02] * strcat doesn't think acrichto sleeps
[08:43:23] *** Quits: zakora (NC@moz-8EAF945F.fbx.proxad.net) (Quit: Computer has gone to sleep.)
[08:43:51] * dbaupp is sure acrichto doesn't sleep
[08:46:06] *** Joins: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP)
[08:46:21] * cmr sure doesn't sleep
[08:46:50] <strcat> dammit hash table
[08:46:56] <strcat> that was a waste of time.
[08:47:10] <strcat> fine grained locking < giant lock
[08:47:20] <cmr> strcat: perf-wise?
[08:47:22] <strcat> and the giant lock has the benefit of not deadlocking because my code isn't buggy
[08:47:34] <strcat> cmr: well the locks make it bigger
[08:47:46] <strcat> it gets slower whether or not I use them
[08:47:58] <cmr> Sure, I'm just wondering what you're comparing with the < there :)
[08:48:05] <strcat> ah
[08:49:30] *** Joins: moostik (Icedove@moz-63ED7231.w82-121.abo.wanadoo.fr)
[08:50:11] *** Joins: derek_c (chatzilla@moz-66F31E3.cit.cornell.edu)
[08:50:24] *** Quits: blank_name (blank_name@FAB53C88.7071B2C8.31EC03F3.IP) (Ping timeout)
[08:52:13] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[08:52:14] <Luqman> working with json was such a pain, but no longer! https://github.com/luqmana/mcchat/commit/b0ca8461cde0d92290663e5be609047684fa18dc#diff-3
[08:52:16] *** Joins: zakora (NC@moz-8EAF945F.fbx.proxad.net)
[08:52:36] *** Joins: peterdn (chatzilla@moz-30BAAE88.as13285.net)
[08:53:54] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[08:54:35] *** Quits: peterdn (chatzilla@moz-30BAAE88.as13285.net) (Quit: ChatZilla 0.9.90.1-rdmsoft [XULRunner 22.0/20130619132145])
[08:55:02] *** Joins: z0w0 (zack@moz-5E840EF3.lns3.woo.bigpond.net.au)
[08:55:45] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[08:58:18] <dbaupp> Luqman: the Index trait actually works for something :O
[08:59:03] <dbaupp> Luqman: can't https://github.com/luqmana/mcchat/commit/b0ca8461cde0d92290663e5be609047684fa18dc#diff-548b397fe37c8f17e9a23b131ddcee8bR31 just be `impl<'a> ExtraJSONIndex for &'a str { ... }` and so it works with any slice?
[08:59:38] <dbaupp> Luqman: in any case, that's pretty cool... much nicer than using extra::json directly.
[09:00:13] *** Joins: spott (spott@moz-9B11536C.hsd1.co.comcast.net)
[09:00:43] <strcat> Luqman: oh right, that Index trait we have to remove! :P
[09:01:06] <Luqman> strcat: hopefully replaced with something else :P
[09:01:31] <Luqman> dbaupp: it can! also need find_equiv for treemap so i can get rid of at least one clone
[09:01:42] <strcat> find_equiv won't work on treemap
[09:01:46] <strcat> Equiv is basically Eq
[09:01:51] <strcat> treemap uses TotalOrd
[09:01:53] *** Quits: spott (spott@moz-9B11536C.hsd1.co.comcast.net) (Ping timeout)
[09:02:00] <strcat> you need OrdEquiv, I guess
[09:02:18] <strcat> would be better to add closure-based lookups to TreeMap
[09:02:20] <strcat> at least imo.
[09:02:33] <strcat> and maybe to HashMap too, allow passing an equality closure
[09:02:36] <strcat> and just remove Equiv
[09:02:48] <Luqman> that would be nice
[09:03:24] <Luqman> hmm, i can't pass stringify! to format! ?
[09:03:52] <dbaupp> Luqman: what do you mean?
[09:04:02] <dbaupp> format!(stringify!(...) ... )?
[09:04:34] <Luqman> dbaupp: yea
[09:04:46] <Luqman> oh but it does work for a simple test
[09:04:54] <Luqman> format!(stringify!({}), 0)
[09:04:57] <dbaupp> I thought format!() expanded its format string argument
[09:05:14] <dbaupp> but that's a horrible abuse of stringify and you should feel bad :P
[09:06:01] * strcat finally feels like putting some real work into rust-core
[09:06:42] <Luqman> dbaupp: aww, but i wanted to escape escaping all those { here https://github.com/luqmana/mcchat/blob/master/conn.rs#L226
[09:07:16] <dbaupp> Luqman: oh, yeah, using stringify for json literals is acceptible
[09:07:21] <dbaupp> *acceptable
[09:07:33] * dbaupp thinks that's very cool
[09:07:39] <derek_c> Newbie question: when I do `from_str::<int>(something)`, is the from_str a function, a module, or what?
[09:08:00] <strcat> a function
[09:08:15] <strcat> you don't need to do ::<int> in most cases though as the type will be inferred
[09:08:24] <strcat> (it's less painful to put it on the variable binding)
[09:08:45] <derek_c> strcat: thanks.  so is the ::<int> the standard way to call a template a function?
[09:08:52] <derek_c> like func::<type>(args)?
[09:08:54] <strcat> derek_c: no
[09:09:02] *** Quits: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz) (Quit: Busying myself...)
[09:09:07] <derek_c> I meant a template function
[09:09:16] <strcat> the standard way to call a generic function is to just call it and have the types inferred
[09:09:28] <strcat> rusti: fn foo<T>(x: T) -> T { x } foo(5)
[09:09:30] -rusti- 5
[09:09:46] *** Quits: sammykim (sammy.kim@5AB4884B.FCC4549.14D5B978.IP) (Quit: Lost terminal)
[09:09:52] <derek_c> oh wow, that's cool
[09:09:54] <strcat> from_str *returns* the generic type and doesn't have a way to infer it from the parameters
[09:09:55] <derek_c> we got a bot
[09:10:06] <dbaupp> derek_c: but yes, if a generic function isn't inferring, the syntax is `::<...>`
[09:10:10] <derek_c> rusti: hello
[09:10:11] -rusti- <anon>:9:9: 9:14 error: unresolved name `hello`.
[09:10:11] -rusti- <anon>:9          hello
[09:10:11] -rusti-                   ^~~~~
[09:10:11] -rusti- error: aborting due to previous error
[09:10:12] -rusti- application terminated with error code 101
[09:10:19] <derek_c> rusti: 1 + 1
[09:10:19] -rusti- 2
[09:10:20] <Yurume> ::<> syntax is a full, verbose way to call the function, and shouldn't occur often.
[09:10:30] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[09:10:34] <Luqman> dbaupp: unfortunately though it seems stringify-ing json and format don't mix :(
[09:10:35] <derek_c> rusti: println("thanks guys!");
[09:10:35] -rusti- thanks guys!
[09:10:35] -rusti- ()
[09:10:43] <strcat> well it's a way to get a specific instantiation of the type
[09:10:49] <strcat> you don't necessarily have to call it
[09:10:54] <strcat> you might just want the function ptr to store
[09:10:55] <Yurume> from_str and similar things are notable exceptions, but you can still get around of ::<> syntax by: let ret: int = from_str(something);
[09:11:05] <dbaupp> Luqman: ah, stringify isn't escaping the non-formatting {}
[09:11:06] <derek_c> I see
[09:11:10] <cmr> Yurume: Option<int> :)
[09:11:14] <strcat> rusti: fn foo() -> int {} let x: fn() -> int = foo;
[09:11:15] <Yurume> oops ;)
[09:11:15] -rusti- pastebinned 6 lines of output: http://sprunge.us/UOMO
[09:11:22] <strcat> rusti: fn foo() -> int {} let x: extern fn() -> int = foo;
[09:11:22] -rusti- <anon>:9:9: 9:27 error: not all control paths return a value
[09:11:22] -rusti- <anon>:9          fn foo() -> int {} let x: extern fn() -> int = foo;
[09:11:23] -rusti-                   ^~~~~~~~~~~~~~~~~~
[09:11:23] -rusti- error: aborting due to previous error
[09:11:23] -rusti- application terminated with error code 101
[09:11:30] <strcat> rusti: fn foo() -> int { 2 } let x: extern fn() -> int = foo;
[09:11:30] -rusti- <anon>:9:35: 9:36 warning: unused variable: `x` [-W unused-variable (default)]
[09:11:31] -rusti- <anon>:9          fn foo() -> int { 2 } let x: extern fn() -> int = foo;
[09:11:31] -rusti-                                             ^
[09:11:31] -rusti- ()
[09:11:43] <dbaupp> Luqman: you can use a raw string to only need one \, btw.
[09:11:48] <strcat> rusti: fn foo<T>() -> T { fail!() } let x: extern fn() -> int = foo::<int>;
[09:11:49] <Yurume> cmr: actually I think there is an issue about changing or augmenting from_str to return (Option<Num>, uint)?
[09:11:49] -rusti- <anon>:9:42: 9:43 warning: unused variable: `x` [-W unused-variable (default)]
[09:11:49] -rusti- <anon>:9          fn foo<T>() -> T { fail!() } let x: extern fn() -> int = foo::<int>;
[09:11:49] -rusti-                                                    ^
[09:11:49] -rusti- ()
[09:12:03] <strcat> rusti: fn foo<T>() -> T { fail!() } let _x: extern fn() -> int = foo; /* should infer... */
[09:12:04] -rusti- ()
[09:12:06] <strcat> oh it does
[09:12:18] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[09:12:40] <cmr> Yurume: What would the uint there be?
[09:12:50] <dbaupp> Luqman: and! you can even use `write!(p.io[1].get_mut_ref() as &mut Writer, r"\{ ... \}", ...)` to format straight to the writer, rather than format!()-ing to a string
[09:13:08] <Yurume> cmr: e.g. from_str("31s") returns (Some(31), 2)
[09:13:24] <cmr> Ah, I see
[09:13:25] <Yurume> since "31".len() == 2
[09:13:41] <Yurume> it is quite useful for parsing
[09:13:49] <derek_c> rusti: from_str("31s")
[09:13:49] -rusti- <anon>:9:9: 9:17 error: cannot determine a type for this bounded type parameter: unconstrained type
[09:13:49] -rusti- <anon>:9          from_str("31s")
[09:13:50] -rusti-                   ^~~~~~~~
[09:13:50] -rusti- application terminated with error code 101
[09:14:02] <Yurume> rusti: from_str::<int>("31s")
[09:14:03] -rusti- None
[09:14:08] <Yurume> for now it is all or nothing
[09:14:14] <Yurume> rusti: from_str::<int>("31")
[09:14:15] -rusti- Some(31)
[09:14:22] <derek_c> why did rusti get removed?
[09:14:29] <derek_c> looks like a useful tool
[09:14:31] <Yurume> it was simply unusable ;)
[09:14:34] <cmr> derek_c: because it was broken and mostly unmaintained
[09:14:49] <klutzy> if you type 1 and enter, it segfaulted
[09:15:08] <Yurume> i.e. not that REPL (interactive environment) is not useful, but it is seriously broken so keeping it as is does not help users anyway
[09:15:18] <sanxiyn> klutzy: Not always, but rusti certainly was always in varying state of brokenness
[09:15:37] <derek_c> I see. it'd be nice to still have it though, maybe as a separate project
[09:15:46] <Yurume> agreed ;)
[09:15:50] <cmr> derek_c: *you* should start that seprate project!
[09:15:57] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[09:16:12] <derek_c> :) I need the code
[09:16:22] <sanxiyn> I think https://github.com/glycerine/rustxi was one posted on the mailing list
[09:16:26] <sanxiyn> Not sure about its status
[09:17:42] <dbaupp> derek_c: rusti was removed in 7c92435f8f93344330e47fb0cca4f79297896bd2, so `git checkout 7c92435f^` should give you the code in `src/rusti`
[09:17:59] <derek_c> kk thanks.  learning Rust by writing a REPL for it sounds like an excellent idea
[09:18:07] <derek_c> maybe I will actually do it :)
[09:18:57] <dbaupp> fwiw, that's probably a hard way to learn it... the current design of the compiler, etc, isn't amenable to a REPL.
[09:19:04] *** Quits: amro (quassel@D9E34ACF.8AAAF769.FAAB0799.IP) (Ping timeout)
[09:19:41] <derek_c> Can we just do it the silly way?  Like, just invoke the compiler to compile whatever the user inputs, and run it?
[09:19:53] <Luqman> dbaupp: awesome, totally forgot about raw strings
[09:19:54] <derek_c> of course we need to wrap it inside a main function or something
[09:20:41] <dredozubov> derek_c: it'll be stateless, not REPL-ish
[09:20:43] <cmr> derek_c: https://github.com/thestinger/rust-playpen/blob/master/bin/irc.sh
[09:21:02] *** Joins: amro (quassel@CC16DC52.8AAAF769.FAAB0799.IP)
[09:21:02] <cmr> (that is how rusti here works)
[09:21:14] *** Joins: jgilbert (jgilbert@moz-4C088FCE.hsd1.ca.comcast.net)
[09:21:24] <strcat> or rather, doesn't work (anymore)
[09:21:42] *** Joins: victorporof (victorporo@79FE7CA6.284D02A8.D111398B.IP)
[09:22:02] *** Quits: fabiand_ (fabiand@moz-D9C81F83.adsl.alicedsl.de) (Quit: Verlassend)
[09:22:05] *** Joins: fabiand (fabiand@moz-D9C81F83.adsl.alicedsl.de)
[09:22:07] <derek_c> dredozubov: how about keeping track of user input, and compile the whole history?
[09:22:17] <derek_c> except those invalid input of course
[09:22:49] <derek_c> cmr: ahaha
[09:23:30] <Yurume> derek_c: possible, but if you want to use rust-repl as like Python, then you'd have a problem...
[09:23:50] *** Quits: boredomist (ruqs@B16F530C.DC641F2C.BCAEBB33.IP) (Ping timeout)
[09:23:54] <Yurume> e.g. let x = some_long_running_function(); <return> x.sum()
[09:23:54] <derek_c> cmr: this doesn't seem to have any security measure.  Could I potentially enter something here and destroy the whole IRC server?
[09:24:01] <dredozubov> derek_c: sounds definitely better, but not for long
[09:24:07] <cmr> derek_c: it's sandboxed
[09:24:21] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[09:24:22] <Yurume> (and not all codes are idempotent, what if you have to read from stdin...)
[09:24:25] <cmr> uses https://github.com/thestinger/playpen
[09:24:44] <dbaupp> rusti: ~[0u8, 1_000_000_000]; // lets try to allocate 1GB
[09:24:45] -rusti- ()
[09:24:59] <strcat> (it has 128MiB cap)
[09:25:01] <derek_c> Yurume: good point
[09:25:01] <dbaupp> rusti: ~[0u8, .. 1_000_000_000]; // lets try to allocate 1GB .. properly
[09:25:02] <cmr> dbaupp: missed a ..
[09:25:02] -rusti- application terminated abnormally with signal 9 (Killed)
[09:25:21] <dbaupp> rusti: loop {} // let's try to use all strcat's CPU
[09:25:22] -rusti- pastebinned 13 lines of output: http://sprunge.us/VWYS
[09:25:36] <dbaupp> rusti: if true {loop {}} // let's try to use all strcat's CPU
[09:25:38] <Yurume> rusti: std::io::stdin().read_to_end() // let's try to hang rusti
[09:25:42] -rusti- timeout triggered!
[09:25:42] -rusti- <anon>:9:9: 10:5 error: type `@std::io::Reader:'static` does not implement any method in scope named `read_to_end`
[09:25:42] -rusti- <anon>:9          std::io::stdin().read_to_end() // let's try to hang rusti
[09:25:42] -rusti- <anon>:10     };
[09:25:42] -rusti- error: aborting due to previous error
[09:25:42] -rusti- application terminated with error code 101
[09:25:47] <dbaupp> (etc)
[09:25:49] <Yurume> wait?
[09:25:55] <Yurume> isn't it 0.8?
[09:25:59] <cmr> Yurume: yes
[09:26:01] <strcat> it's 0.8, yes
[09:26:03] <strcat> not master
[09:26:12] *** Quits: jgilbert (jgilbert@moz-4C088FCE.hsd1.ca.comcast.net) (Connection reset by peer)
[09:26:15] <strcat> it should be master but master doesn't have working I/O ;p
[09:26:19] <Yurume> rusti: use std::io::ReaderUtil; std::io::stdin().read_whole_stream() // second try
[09:26:24] -rusti- timeout triggered!
[09:26:27] <dredozubov> derek_c: we're kinda in the same place now, i really want to learn and maybe contribute. Reading tutorials doesn't do it for me.
[09:26:28] <Yurume> clever.
[09:26:29] <sanxiyn> Triggered!
[09:26:57] <sanxiyn> dredozubov: What are you interested in?
[09:26:57] <strcat> Yurume: https://github.com/thestinger/rust-playpen/blob/master/web.py#L20 it essentially does this
[09:27:11] <dredozubov> Guys, can i find some github issues to dive in? I'd like to learn and contribute to rust development.
[09:27:12] <Yurume> actually, good tutorials are seriously wanted; the current tutorial is actually something like a tour of major features and not really a tutorial.
[09:27:18] *** Joins: jensnockert (jensnocker@E26F71DB.81840CBC.B0E77544.IP)
[09:27:26] <strcat> Yurume: https://github.com/thestinger/playpen and there is playpen
[09:27:42] <strcat> https://github.com/thestinger/playpen/blob/master/playpen.c#L457 that error ;p
[09:27:43] <sanxiyn> dredozubov: Do you want to work on the compiler, or the standard library, or the external library?
[09:27:48] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[09:27:57] <sanxiyn> (or else)
[09:28:03] <derek_c> dredozubov: I'm learning it by writing a book
[09:28:15] <Yurume> are you writing a book about Rust? cool.
[09:28:19] <derek_c> yep yep
[09:28:20] <cmr> dredozubov: https://github.com/mozilla/rust/issues?labels=E-easy&page=1&state=open
[09:28:25] <derek_c> just finished the first chapter :)
[09:28:26] <dbaupp> dredozubov: https://wiki.mozilla.org/GNOME_Outreach_December2013#Contributions_for_Rust is a curated list of bugs tagged 'easy'
[09:29:02] *** Quits: Kxepal (Miranda@moz-ADF2988C.pppoe.mtu-net.ru) (Ping timeout)
[09:29:10] <dredozubov> derek_c: cool
[09:30:07] <dredozubov> thx, i'll give it a look
[09:30:54] <derek_c> dbaupp: thanks too. will definitely take a look
[09:32:18] *** Joins: Kxepal (Miranda@moz-E7192F22.pppoe.mtu-net.ru)
[09:32:44] <derek_c> 4:30AM on east coast.  Good night everybody :)
[09:32:53] <dbaupp> dredozubov, derek_c: if you do choose a bug, make sure to comment on it, so that someone else doesn't start on it too
[09:33:01] *** Quits: derek_c (chatzilla@moz-66F31E3.cit.cornell.edu) (Quit: ChatZilla 0.9.90.1 [Firefox 28.0a1/20131118094134])
[09:33:27] <dredozubov> dbaupp: ok, not a problem
[09:33:37] *** Quits: rofrol (rofrol@moz-8C55345C.static.ptr.magnet.ie) (Quit: WeeChat 0.4.2)
[09:33:44] *** Joins: CarpNet (ac@moz-FD24B77.sohonet.co.uk)
[09:34:47] <ktt3ja> what's the difficulty in writing a Rust REPL?
[09:35:22] <sanxiyn> ktt3ja: Keeping an environment around
[09:35:46] <cmr> ktt3ja: Rust is an AOT-compiled lowlevel language, it's hard to incrementally write *and* run a program
[09:36:13] <sanxiyn> You basically need something like gdb's evaluation feature
[09:37:02] <sanxiyn> (Actually, gdb can be considered a C REPL)
[09:37:49] <strcat> cling works very well for C++ but libclang is far better designed in terms of tooling than librustc
[09:37:58] <dredozubov> sanxiyn: wow, i never thought of it this way
[09:38:07] <amro> not really, you can't write code in gdb
[09:38:25] <sanxiyn> strcat: How does cling handle environment?
[09:38:36] <strcat> sanxiyn: dunno, all I know is that it works :P
[09:38:41] <sanxiyn> amro: Yeah no function definition
[09:38:49] <sanxiyn> Can call existing functions though
[09:39:37] <amro> eval would be nice, but accepting arbitrary expressions is a lot harder
[09:40:08] <amro> though doable if you're willing to accept differences from regular execution (as regards to linking and so on)
[09:40:28] <sanxiyn> REPL is different, even for Scheme
[09:41:35] <klutzy> sanxiyn: 29p http://llvm.org/devmtg/2010-11/Naumann-Cling.pdf
[09:44:01] <sanxiyn> klutzy: Thanks
[09:47:49] *** Quits: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP) (Ping timeout)
[09:48:06] <strcat> it made a lot of progress since those slides
[09:48:31] <strcat> but, really, I don't think it is realistic that rust is going to get a REPL of that quality
[09:48:49] <strcat> need someone with a good plan, and they need to be a full-time employee...
[09:49:12] <strcat> just think about rolling back on an error
[09:49:32] <strcat> maybe someone could write something on par with cling in a 2 month internship but I doubt it ;p
[09:49:40] <strcat> it's going to involve a lot of libsyntax/librustc improvement
[09:49:42] <sanxiyn> strcat: Can cling rollback on error?
[09:50:09] <strcat> sanxiyn: yes
[09:50:14] <sanxiyn> (You can't rollback in gdb if you make a mistake... Unless you have reverse debugging enabled, that is)
[09:50:28] <strcat> sanxiyn: it hoists out state
[09:50:54] <strcat> it is not *very good* at rolling back, but it won't lose anything if you make a typo and libclang hits an error
[09:51:07] <strcat> if you hit a segfault or exit/abort it's done
[09:51:36] <strcat> sanxiyn: http://root.cern.ch/drupal/content/validation-code-unloading-and-error-recovery
[09:51:58] <strcat> I haven't followed the progress since 2012 though
[09:52:04] <strcat> haven't had much interest in C++ :)
[09:52:41] <dbaupp> strcat: your interest in C++ rusted, did it?
[09:52:58] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Ping timeout)
[09:56:55] <cmr> Is Gaetan in IRC?
[09:57:33] *** Quits: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP) (Client exited)
[09:59:07] <strcat> dbaupp: that page on the wiki just totally broke :(
[09:59:30] <dbaupp> strcat: I just edited one sentence?
[09:59:38] <strcat> yeah I think github fucked up
[09:59:38] <dbaupp> oh, crap :S
[09:59:48] <dbaupp> :'(
[09:59:50] <strcat> fixed
[09:59:53] <strcat> just needed a no-op edit
[10:00:02] <dbaupp> not for me
[10:00:03] <strcat> that's dynamic typing for you
[10:00:11] <strcat> dbaupp: ctrl-f5 refresh?
[10:00:15] <strcat> oh it's fucked again.
[10:00:26] <strcat> it worked after coming out of the edit
[10:00:27] <dbaupp> wtf
[10:00:36] <dbaupp> yeah, that's what it looked like for me
[10:00:49] <dbaupp> fine in the preview and after the save
[10:00:51] <strcat> dbaupp: there
[10:00:57] <strcat> I had to make a non no-op change
[10:00:57] <Seldaek> strcat: idiot ranting on ~ docs here, I just read the box thing again, and it seems kind of clear to me now, but I think the issue is it doesn't address "what would jesus do when the compiler screams", so maybe more cookbook style things as was mentioned on the list. I'll try and find a bad example in my code.
[10:01:10] <dbaupp> strcat: weird.
[10:01:16] <strcat> Seldaek: well I re-wrote it very recently
[10:01:22] <strcat> I doubt it was comprehensible when you originally rea dit
[10:01:24] <strcat> read*
[10:01:31] <Seldaek> probably that has a play in it too
[10:01:35] *** Quits: LU324 (weechat@9AF4F288.83671C58.1B5D53D7.IP) (Input/output error)
[10:01:41] <Seldaek> but still I don't think it'd be enough if I had no clue about rust yet
[10:01:53] <strcat> I actually rewrote it several times ;p
[10:02:17] *** Quits: quvarxa (chatzilla@moz-978E4C31.static.tpgi.com.au) (Ping timeout)
[10:02:29] <strcat> Seldaek: well, imo it is good enough in terms of the information it conveys but not from an example/style one
[10:03:00] <Seldaek> strcat: yeah the thing is just sometimes I feel forced to add ~'s by the compiler without really understanding why I have to
[10:03:08] <strcat> but you aren't
[10:03:22] <dbaupp> strcat: the link in https://github.com/mozilla/rust/wiki/Rust-for-CXX-programmers#concurrency is old (0.6!), but I don't wanna edit it :S
[10:03:27] <strcat> perhaps you're being tricked by the implicit conversion from ~A -> &A that's not there for A -> &A
[10:03:38] *** Joins: quvarxa (chatzilla@moz-978E4C31.static.tpgi.com.au)
[10:03:46] <Seldaek> I don't know why, I'll definitely try to pay more attention next time and report it :)
[10:04:12] <Seldaek> strcat: but for example return Err(~"foo"), is this needed?
[10:04:14] <strcat> (implicit conversions and other magic are more trouble than it's worth imo)
[10:04:30] <strcat> Seldaek: ~"foo" isn't an owned box
[10:04:37] <Seldaek> ah :p
[10:04:44] <strcat> and yes, I realize that's confusing
[10:04:46] <Seldaek> see, something isn't clear :)
[10:04:52] <strcat> and I don't really like having dynamic arrays in the language
[10:05:04] <strcat> Seldaek: but at that point, afaik it hasn't mentioned dynamic vectors/strings
[10:05:13] <strcat> the dynamic vector/string section could be very clear about that
[10:05:16] <strcat> but this is way before
[10:05:34] <strcat> and I don't have much interest in explaining them properly because I want them to be removed
[10:05:39] <Seldaek> ok, might still be worth reiterating it quickly in the box one if ~"" isn't a box
[10:05:41] <strcat> people being confused by them benefits my cause
[10:05:47] <Seldaek> because people don't necessarily read docs linearly
[10:05:49] *** Quits: Ms2ger (Ms2ger@moz-B4F6BCFC.ugent.be) (Quit: Leaving)
[10:05:52] * strcat wonders if rewriting the vector/string section was a bad idea
[10:06:00] *** Joins: Ms2ger (Ms2ger@moz-B4F6BCFC.ugent.be)
[10:06:04] <strcat> Seldaek: or just drop ~[] and ~str from the language
[10:06:13] <strcat> rust-core isn't going to have them, they're just containers
[10:06:16] <Seldaek> yeah I don't know what good that would do though
[10:06:26] <strcat> because other containers don't have weird syntax with ~
[10:06:29] <strcat> only those 2 do
[10:06:37] <Seldaek> my code is littered with them so not sure if I'd miss them
[10:06:43] <Seldaek> or if I'm doing it wrong
[10:06:53] *** Joins: andre (andre@CA528A4A.45A4338E.8EE27E6.IP)
[10:07:05] <strcat> Seldaek: removing the feature from the language and having library containers for them wouldn't remove any features
[10:07:09] <strcat> it would just remove the confusing syntax
[10:07:18] <strcat> and it's ugly syntax too, imo
[10:07:33] <strcat> I don't really see what's wrong with Vec<T> and Str
[10:07:37] <Seldaek> how about this one: let data = ~HashMap::new::<~[u8], ~[u8]>();
[10:07:49] <strcat> Seldaek: no point of that ~
[10:07:59] <strcat> that's like doing
[10:08:02] <strcat> ~~[T]
[10:08:03] <Seldaek> interesting
[10:08:13] <strcat> Seldaek: you don't need ~ if you aren't writing a recursive data structure
[10:08:16] <strcat> that's basically the whole story
[10:08:16] <Seldaek> that just adds one level of indirection then
[10:08:19] <strcat> ~[T] and ~str aren't ~T
[10:08:21] <strcat> Seldaek: right
[10:08:21] *** Joins: LU324 (weechat@9AF4F288.83671C58.1B5D53D7.IP)
[10:08:32] <strcat> I realize that it's incredibly confusing that ~str and ~[T] aren't ~T
[10:08:40] <strcat> I don't think ~T alone is confusing
[10:08:47] <Seldaek> a bit yes 
[10:09:11] <Seldaek> well I would really add a big fat red line in the Boxes chapter saying that they aren't boxes
[10:09:13] <strcat> for example, no one gets confused by HashMap, TreeMap, and other containers
[10:09:17] <Seldaek> this ought to help 
[10:09:23] <strcat> if they were Vec and Str, no one would be confused
[10:09:29] <strcat> and it would be a hell of a lot easier to maintain them
[10:10:16] <Seldaek> might make docs easier too, because right now they aren't proper types per se and are still not visible in the vec/str pages I think
[10:10:28] <Seldaek> haven't checked in a while though
[10:10:33] <strcat> yeah but we should fix that
[10:11:10] <strcat> Seldaek: https://github.com/thestinger/rust-core/blob/master/core/vec.rs I find that much simpler. no confusion
[10:11:22] <strcat> it's nowhere near as mature so far ;p
[10:11:46] <strcat> if you ignore the fact that it has allocator support, adding a type param
[10:12:16] <dbaupp> do we have a proposal/RFC for default type params?
[10:12:20] <strcat> let mut xs = Vec::new(); for x in range(0, 10) { xs.push(x) }
[10:12:22] <strcat> vs
[10:12:30] <strcat> let mut xs = ~[]; for x in range(0, 10) { xs.push(x) }
[10:12:31] <strcat> or
[10:12:33] <Seldaek> strcat: on a side note, you should start by unifying github & irc nicknames, clean up your own backyard you know :p
[10:12:52] <strcat> as soon as my desired username is freed on github
[10:13:14] <strcat> it's used by some dead account, apparently they have a policy where you can liberate a name but I'm far too lazy
[10:13:44] <Seldaek> I see yes, with a very pixelated BSD/tux porn avatar :|
[10:13:47] <strcat> another benefit of Vec over ~[T] is that you can have static methods
[10:14:13] <strcat> Vec::with_capacity(n), rather than std::vec::with_capacity(n)
[10:14:21] <strcat> what's the advantage of that weird syntax? :p
[10:14:35] <strcat> I'm even tempted to say I would prefer Unique over ~
[10:14:44] <Seldaek> but so how would []/"" work with your proposal?
[10:14:57] <strcat> Seldaek: fixed-size arrays and slices would remain as they are
[10:15:00] <dbaupp> Unique would certainly discourage overuse
[10:15:08] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[10:15:42] <strcat> [T, ..n], &[T], &str would remain (although perhaps we could come up with less confusing syntax for slices)
[10:15:55] <Seldaek> strcat: oh so ~ is only needed for dynamic ones now? not sure what's dynamic about ~"foo" though
[10:16:04] <strcat> Seldaek: ~"foo" is a dynamic array
[10:16:04] <Seldaek> but that's probably just my lack of understanding of many things
[10:16:20] <strcat> Seldaek: it allocates a dynamic memory allocation it can resize
[10:16:25] <Seldaek> but it is dynamic because of the  ~ ?
[10:16:27] <strcat> if you don't need that, you don't want ~[T] or ~str
[10:16:32] <Seldaek> "foo" would be fixed size?
[10:16:42] <strcat> Seldaek: "foo" is &str
[10:16:46] <strcat> 'str' isn't a type
[10:17:14] <strcat> all these edge cases brought to you by an attempt at adding sugar over what C++ already does well
[10:17:30] <Seldaek> mkay
[10:17:42] <strcat> Seldaek: so, "foo" and ~"foo" are really totally different
[10:18:10] <strcat> &str is a pointer and a length, it's a view into some block of memory with a UTF-8 encoded string (it doesn't own it)
[10:19:09] <strcat> well I guess it's better to explain via vectors
[10:19:11] <Seldaek> and what owns it then? is it just like a const hardcoded in the process?
[10:19:23] <strcat> Seldaek: I'll explain via vectors instead
[10:19:26] <strcat> so
[10:19:34] <strcat> [u8, ..5]
[10:19:39] <strcat> like, [1, 2, 3, 4, 5]
[10:19:46] <strcat> is just an unboxed object
[10:19:53] <strcat> it contains five bytes, so it's five bytes large
[10:20:07] <strcat> [u16, ..5] is 10 bytes
[10:20:11] <Seldaek> so far so good :p
[10:20:33] <strcat> &[u8] is a view into some block of bytes - it's just (reference_to_start, length)
[10:20:36] *** Quits: victorporof (victorporo@79FE7CA6.284D02A8.D111398B.IP) (Quit: victorporof)
[10:20:53] <strcat> it's a non-owning view, the compiler prevents it from outliving what it points at (like &T, but it isn't an &T)
[10:21:01] <strcat> for example
[10:21:03] *** Quits: Ms2ger (Ms2ger@moz-B4F6BCFC.ugent.be) (Ping timeout)
[10:21:38] <strcat> let xs: [int, ..4] = [1, 2, 3, 4]; let ys: &[int] = xs /* coerces */; let zs: &[int] = ys.slice(0, 2);
[10:21:52] <strcat> both ys and zs are views into xs
[10:22:39] <strcat> ~[T] is really something completely different - it's a mutable container like a HashMap
[10:22:58] <dbaupp> strcat: Rust for C++ programmers is broken again
[10:23:02] <strcat> it owns the contents (like a fixed-size array or HashMap) and you can freely resize it
[10:23:13] <strcat> imo there's no good reason to have it as a language feature
[10:23:22] <strcat> for the same reason hash maps aren't a language feature
[10:23:26] <dbaupp> and me adding a new line at the end didn't fix it
[10:23:43] <strcat> adds needless complexity and leads to us treating other vector implementations (there are many valid representations! ropes, small vectors, etc.)
[10:23:52] <strcat> treating other vector impls as second-class*
[10:23:59] *** Quits: jensnockert (jensnocker@E26F71DB.81840CBC.B0E77544.IP) (Input/output error)
[10:24:23] <strcat> I would like to say [T, ..n] is a fixed-size array, &[T] is a slice (as in, call neither of them a 'vector')
[10:24:41] <Seldaek> strcat: mhh, I see.. coming from fully GC'd dynamic languages though, I do appreciate being able to just push stuff in a vec without having to care, but I guess I wouldn't run away screaming if I had to do let x = Vec::new(); instead of ~[] or whatever
[10:24:44] <strcat> and then, we can have std::vec with a Vec type
[10:25:18] <strcat> Seldaek: well, python/ruby have a built-in map type too ;p
[10:25:53] <strcat> python has a built-in mutable map, mutable set, mutable vector, immutable set, immutable vector
[10:26:05] <strcat> (dict, set, list, frozenset, tuple)
[10:26:19] <Seldaek> yeah sure, but the default "[]" constructs in most (all?) of those languages is dynamic sized
[10:27:09] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[10:27:25] *** Joins: Ms2ger (Ms2ger@moz-B4F6BCFC.ugent.be)
[10:27:36] *** Quits: sanxiyn (tinuviel@B4104EBB.3CC170B1.1E14B209.IP) (Quit: Leaving)
[10:28:09] <strcat> Seldaek: it never will in rust though because fixed-size arrays are the 'default'
[10:28:24] <Seldaek> strcat: I just mean it is convenient for most day to day stuff to have dynamically sized arrays, but I wouldn't find it so surprised to find the opposite in a language such as rust
[10:28:35] *** Quits: eevee (eevee@moz-7B6C48E3.evrt.wa.frontiernet.net) (Ping timeout)
[10:28:35] <Seldaek> and yes as you say it already is the case
[10:28:44] <Seldaek> there is just that ~[] tucked on top of it
[10:28:53] <strcat> and it confuses the hell out of people ;p
[10:28:57] <Seldaek> I never really realized that
[10:29:10] <strcat> Seldaek: ~([1, 2, 3]) and ~[1, 2, 3] are different types
[10:29:25] <strcat> ~[int, ..3] (fixed-size array in an owned box) vs. ~[int] (dynamic array)
[10:29:32] <strcat> they will always be different, whether or not DST lands
[10:29:50] <strcat> I think that's terrible
[10:30:01] <Seldaek> it's not great :)
[10:30:18] <strcat> people have no issues with hash tables, trees, ringbufs, etc. in rust
[10:30:23] <strcat> just vectors, because of this syntax
[10:30:51] <strcat> and it's the opposite of making the efficient, desirable cases look good and discouraging inefficiency
[10:31:08] *** Joins: ricepuddin (graham@moz-2AD4CE16.wlan.ic.ac.uk)
[10:31:26] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[10:31:32] <Yurume> strcat: so will the new syntax be something like `new Vector(1, 2, 3)` really?
[10:31:41] *** Joins: willingc (willingc@moz-B4760708.san.res.rr.com)
[10:31:41] <strcat> Yurume: no
[10:31:51] *** Quits: willingc (willingc@moz-B4760708.san.res.rr.com) (Quit: Leaving...)
[10:31:52] <strcat> 'new' would only be there if it remains a messed up built-in type ;p
[10:31:55] <Yurume> (that was what brson said in rust-dev, I think)
[10:32:12] <strcat> Yurume: it would be like HashMap, etc.
[10:32:27] <strcat> let mut xs = Vec::new(); xs.push(5); xs.len()
[10:32:39] <strcat> let mut xs = Vec::from_slice([1, 2, 3]); ...
[10:32:45] <strcat> or whatever the API is
[10:33:35] <dbaupp> that'd make moving things into a vector verbose.
[10:33:36] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Client exited)
[10:34:01] <strcat> dbaupp: hm?
[10:34:45] <Yurume> strcat: so the intention is to keep a fixed-size borrowed vector and to move everything else to the stdlib?
[10:34:47] <dbaupp> strcat: ~[~1, ~2, ~3] becomes?
[10:34:55] <strcat> dbaupp: ~int isn't useful
[10:35:06] <dbaupp> strcat: well, assume it was something else that moved
[10:35:17] <dbaupp> ~[x,y,z] where x y and z are files.
[10:35:32] * dbaupp just wants generic container literals
[10:35:39] <klutzy> I always feel ~int should not be in tutorial
[10:35:45] <klutzy> it is confusing for ~ usage
[10:36:00] <Yurume> and incidentally it collides with C/C++/etc's usage of ~
[10:36:27] <Seldaek> yeah I think overall the docs have too simplistic examples which make them confusing, but it's hard to come up with more complex stuff that is still meaningful in few lines
[10:36:36] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[10:36:38] <strcat> Seldaek: because ~ isn't very useful
[10:36:43] <Seldaek> :)
[10:36:54] <strcat> a good example is a linked list (although a linked list isn't really useful!)
[10:37:13] <strcat> I sort of started on that in the Boxes section by showing why you need ~ for a recursive type
[10:37:24] *** Quits: fyolnish (fyolnish@moz-BE2BAE5B.miinet.jp) (Client exited)
[10:37:25] <strcat> didn't follow through on writing a whole guide to implementing the rest of it
[10:37:27] *** Joins: dd (chatzilla@B61C2AE3.78BE666E.9105FBCF.IP)
[10:37:35] <strcat> wouldn't be that hard
[10:37:39] <Seldaek> yup that was nice to show when you need it, it just misses the part about how you don't need it the rest of the time  I think
[10:37:47] <Yurume> ~ is useful for some big structs, though it is better for them to be allocated to the heap by deafult
[10:38:12] <strcat> Yurume: well by default it isn't, but yes it is useful
[10:38:15] <Yurume> (you'll almost never want to allocate some kilobytes of struct to the stack anyway)
[10:38:33] <strcat> you do want to put them on the stack if you don't need to pass them around by-value
[10:38:44] <strcat> they might just be a one-time thing you pass deeper into the call stack by-ref
[10:39:05] <strcat> or more likely, you have them as part of some other data structure that's heap allocated
[10:39:38] <Yurume> heap-allocation does not hurt the common use cases though
[10:39:54] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Client exited)
[10:40:01] <strcat> Yurume: yes it does
[10:40:10] <Yurume> generic ones?
[10:40:42] <strcat> how do you handle out-of-memory from an implicit heap allocation?
[10:40:52] <strcat> and how do you actually allocate one unboxed?
[10:40:55] <Yurume> ah, no, I didn't mean an implicit heap allocation
[10:41:18] <strcat> Yurume: if you have some ctor for a very large struct, you still want to ret by-value
[10:41:27] <strcat> the caller can put it into ~ (or another place) without a copy
[10:41:35] *** kimundi is now known as zz_kimundi
[10:41:37] <Yurume> I meant that we probably make the decision whether to allocate in stack or in heap left to the library writer, not to the user
[10:41:47] <Yurume> we probably have to make*
[10:41:48] *** Quits: ricepuddin (graham@moz-2AD4CE16.wlan.ic.ac.uk) (Ping timeout)
[10:41:52] <strcat> Yurume: I don't think so
[10:42:14] <strcat> fn foo() -> [int, ..64] { [0, ..64] } ~foo()
[10:42:27] <strcat> allocates memory, passes it as the return pointer to foo, and foo writes directly into it
[10:42:39] *** Joins: donri (donri@moz-9BB61102.tbcn.telia.com)
[10:42:57] *** Quits: m_kato (m_kato@moz-C286AD9A.bitcat.net) (Quit: Leaving...)
[10:43:02] <Yurume> RVO?
[10:43:06] <Yurume> hmm, it makes some sense.
[10:43:07] <strcat> not really
[10:43:16] <strcat> RVO applies to C++ because it has move/copy ctors
[10:43:19] <strcat> rust is in the same situation as C
[10:43:35] <strcat> large values are returned by pointer (like most native ABIs)
[10:43:51] <strcat> large means >2 words for the native ABI on most platforms
[10:44:10] *** zz_kimundi is now known as kimundi
[10:44:38] <Yurume> well, it gets translated to: fn foo(ret: &mut [int, ..64]) { ret = ...; } {let mut ret = <some unallocated chunk of heap memory>; foo(ret); ret}
[10:45:00] <Yurume> I don't know the proper name of this kind of optimization, is it just an ABI quirk?
[10:45:05] <strcat> hm?
[10:45:14] <Yurume> uninitialized chunk, sorry
[10:45:16] <strcat> Yurume: well, it's just how you return large values
[10:45:21] <strcat> or pass them
[10:45:31] <strcat> I wouldn't really call it an optimization
[10:45:53] *** Joins: nano (nano@moz-74CAD1CA.superkabel.de)
[10:46:26] <strcat> you can't fit a 512-byte array into registers, ofc, so you have a choice between using an out pointer or spilling to some magical location on the stack
[10:46:35] *** Joins: w3lcome (Mibbit@moz-177EEEFC.home.otenet.gr)
[10:47:20] *** Quits: w3lcome (Mibbit@moz-177EEEFC.home.otenet.gr) (Quit: http://www.mibbit.com ajax IRC Client)
[10:47:33] *** Joins: w3lcome (Mibbit@moz-177EEEFC.home.otenet.gr)
[10:47:46] <Yurume> strcat: it is not an optimization to have a pointer for large return values, it *is* an optimization to make that pointer point to the uninitialized heap memory (eliminating redundant copying).
[10:47:52] <strcat> for example to pass (int, int, int, int)
[10:47:55] <strcat> as a parameter
[10:48:14] <strcat> by-value
[10:48:31] <strcat> the way it's done in the x86_64 ABI is to pass a pointer.
[10:48:54] <strcat> so, if the caller is still going to use it, the caller has to copy it and pass a ptr to the copy
[10:48:57] <tikue_> does hashmap support index assign?
[10:49:08] <Seldaek> meh, you have to do let addr: SocketAddr = FromStr::from_str(format!("127.0.0.1:{}", port)).expect("")? I thought one could call those trait fns on the struct itself, i.e. let addr = SocketAddr::from_str(format!("127.0.0.1:{}", port)).expect("")
[10:49:16] <strcat> tikue_: just insert
[10:49:25] <strcat> the Index trait doesn't work for most use cases
[10:49:33] <tikue_> strcat: broken by design or bug?
[10:49:37] <strcat> bug
[10:49:43] <strcat> it should be removed as it is right now
[10:50:03] <strcat> tikue_: well, broken by design in that it's not sufficient
[10:50:06] <dbaupp> tikue_: https://github.com/mozilla/rust/issues/6515
[10:50:11] <tikue_> dbaupp: thanks
[10:50:13] * strcat didn't really interpret that right
[10:50:27] <tikue_> strcat: my question was ambiguous :)
[10:50:53] <strcat> why does github want that wiki page broken
[10:51:02] <dbaupp> tikue_: and http://smallcultfollowing.com/babysteps/blog/2013/11/14/treating-vectors-like-any-other-container/ "Index operation"
[10:51:18] <tikue_> dbaupp: was just looking at that but glazed over the Index operation section
[10:51:41] <dbaupp> strcat: fwiw, github wiki has been broken for me for a while; any time I try to look at a diff it tells me "invalid diff" :/
[10:52:16] <strcat> one day I'll work on https://github.com/thestinger/wiki again ;p
[10:52:17] *** Joins: vmx (vmx@moz-9A879F12.dip0.t-ipconnect.de)
[10:52:29] <tikue_> i wonder if there'd be opposition to `foo in container -> bool` syntax like in python
[10:52:35] * tikue_ loves that
[10:52:42] <Yurume> -> bool?
[10:52:48] <tikue_> Yurume: boolean
[10:52:54] <strcat> tikue_: I don't really like it
[10:53:01] <dbaupp> strcat: you can have a wiki page called wiki for that project... `https://github.com/thestinger/wiki/wiki/wiki`
[10:53:04] <tikue_> strcat: what's the argument against it?
[10:53:07] <Yurume> ah `foo in container` syntax that returns a bool, okay.
[10:53:11] <strcat> tikue_: sugar for something that's not common
[10:53:17] <strcat> and it encourages double lookups when 1 is enough
[10:53:45] <Yurume> dbaupp: I know some gh repo named ...
[10:53:46] <tikue_> true
[10:53:57] <tikue_> yeah that's a good point
[10:54:11] <strcat> and we have pattern matching so it covers some of the use cases
[10:54:16] <tikue_> also true
[10:54:32] <strcat> perhaps we could have a macro for testing if a certain pattern matches
[10:54:47] <dbaupp> matches!(foo, Bar | Baz(*))
[10:54:54] <tikue_> i want a macro for refutable patterns in functions :O)
[10:55:10] <strcat> matches!(x, 1 | 2 | 3)
[10:55:15] <strcat> rather than
[10:55:18] <strcat> x in [1, 2, 3]
[10:55:31] <strcat> (I think that's the common use in python)
[10:55:35] <tikue_> strcat, dbaupp: I've thought about that but really you'd want to be able to have an enclosing scope right? so that you can match a refutable pattern then use it
[10:55:36] <Yurume> how's going on with importable/exportable macros? :)
[10:56:13] <cmr> Yurume: I don't think it's going to happen.
[10:56:24] <cmr> It'd require a significant amount of weirdness
[10:56:42] <cmr> Doing name resolution before parsing is finished.
[10:57:23] <tikue_> matches!(foo, [1, 2, ..tail], println!(tail))
[10:57:29] <Yurume> couldn't it be possible to stop parsing after we have `extern mod` items?
[10:57:44] <strcat> cmr: it could require that you pre-declare every macro you want to use from the crate, doesn't have to be scoped properly
[10:57:53] <Yurume> ...no wait, `extern mod` can go inside nested modules.
[10:57:55] * strcat shrugs
[10:58:03] <strcat> but yeah it's a hard problem
[10:58:05] <dbaupp> Yurume: {im,ex}portable macro items requires libsyntax reading metadata... which is not easy.
[10:58:21] <cmr> strcat: that'd work, though it's not quite what I think of when I hear importable macros
[10:58:21] <dbaupp> (at least, a sane implementation does)
[10:58:37] <dd> what denotes this line ?? f64::consts::PI * size * size; 
[10:58:40] *** Joins: ricepuddin (graham@moz-2AD4CE16.wlan.ic.ac.uk)
[10:58:47] <Yurume> I still think there are some good reasons to have macros im/exportable
[10:58:54] <strcat> cmr: for example when it saw a declaration of one it'd then look in that crate for it
[10:59:04] *** Quits: axitkhurana (Adium@34C7F9C0.B32F1A35.6AA50C35.IP) (Quit: Leaving.)
[10:59:05] <strcat> and we could force declare before use ;p
[10:59:07] <cmr> Yurume: I think they'd be great, it's just not simple.
[10:59:15] <tikue_> Yurume: I think no one would be opposed to it...what cmr said :P
[10:59:25] <Yurume> of course!
[10:59:30] <strcat> macro_load!(macro)
[10:59:34] <strcat> macro!(...)
[10:59:38] <Yurume> lol
[10:59:42] <strcat> no seriously ;p
[10:59:48] <strcat> macro_load!(crate, macro)
[10:59:52] <Ms2ger> dd, the area of a disc?
[10:59:53] <strcat> crate::macro!(...)
[11:00:02] *** Joins: axitkhurana (Adium@34C7F9C0.B32F1A35.6AA50C35.IP)
[11:00:09] <strcat> it honestly wouldn't be that bad
[11:00:14] <Yurume> strcat: macro_use! crate(macro)
[11:00:25] *** Joins: samnardoni (Mibbit@F889EF52.38924046.A86B7D63.IP)
[11:00:33] <Yurume> or should it be macro_use! macro(crate)?
[11:00:47] <strcat> macro_rules! is a syntax extension so macro_load! could be one too! ;p
[11:00:48] <cmr> dbaupp: hm
[11:01:00] <strcat> having more convenience than that, would be incredibly hard
[11:01:01] <cmr> the AST is fairly separate from the rest of libsyntax
[11:01:10] <Seldaek> is there a performance concern with letting all tasks fail on EOF vs cleanly handling reads if you write a socket server and have one task per connection? 
[11:01:11] <cmr> we could break it into its own crate,  AST + metadata only
[11:01:20] *** Joins: spott (spott@moz-9B11536C.hsd1.co.comcast.net)
[11:01:31] <samnardoni> is there any way to convert a `fn(&self) -> Option<char>` into an iterator?
[11:01:42] <tikue_> Seldaek: why would they fail on EOF/
[11:01:48] <tikue_> samnardoni: yes
[11:01:49] <dd> <ms2ger> I was thinking about triangle :( 
[11:02:00] *** Joins: nkoep (nik@moz-50882FD.pool.mediaways.net)
[11:02:05] <tikue_> samnardoni: wait i don't understand. you can turn an option into an iterator, but not a function
[11:02:18] <dd> f64::consts::PI * size * size,
[11:02:20] <cmr> tikue_: sure you can
[11:02:25] <Ms2ger> A triangular pie?
[11:02:30] <tikue_> cmr: built in?
[11:02:32] <Seldaek> tikue_: probably because I do stream.read_byte().expect("") and at some point it can't read anymore and just goes down in flames :)
[11:02:36] * tikue_ is confused
[11:02:48] <dd> why this f64:: and consts ?? 
[11:02:53] <strcat> rusti: let x = Some(5); for i in xs.move_iter { println!("{}", i) }
[11:02:53] -rusti- <anon>:9:35: 9:37 error: unresolved name `xs`. Did you mean `x`?
[11:02:54] -rusti- <anon>:9          let x = Some(5); for i in xs.move_iter { println!("{}", i) }
[11:02:54] -rusti-                                             ^~
[11:02:54] -rusti- error: aborting due to previous error
[11:02:54] -rusti- application terminated with error code 101
[11:02:58] <dbaupp> cmr: yes, that was my "plan", but extracting metadata from librustc will be tricky, I think. (although I've put literally no effort into trying that)
[11:03:01] <tikue_> Seldaek: there should be convenience methods that make that easier
[11:03:03] <strcat> rusti: let x = Some(5); for i in x.move_iter() { println!("{}", i) }
[11:03:05] *** Quits: spott (spott@moz-9B11536C.hsd1.co.comcast.net) (Ping timeout)
[11:03:05] -rusti- 5
[11:03:05] -rusti- ()
[11:03:13] <samnardoni> well, I noticed the Buffer trait has `fn read_char(&mut self) -> Option<char>`. It'd be nice to use iterator goodness with that function...
[11:03:19] <Yurume> tikue_: maybe samnardoni wants something like Python's two-argument iter, e.g. iter(lambda f: f.read_line(), '')
[11:03:33] <dd> if there have been a return type at the function level then why at the statement level ?
[11:03:40] <cmr> tikue_: I don't think there's anything builtin, but it's fairly trivial to just repeatedly call the function in the Iterator impl
[11:03:44] <Seldaek> tikue_: yes, well my code is kind of a mess too since it went through 3 different std::io APIs :p
[11:03:58] <Yurume> samnardoni: you can easily define an Iterator that accepts a function and runs it repeatedly... as like this:
[11:04:01] *** Joins: engla (engla@moz-F64E1B0F.cust.bredbandsbolaget.se)
[11:04:02] <dbaupp> strcat, Yurume: macro_use! would still require libsyntax reading the metadata (and also being able to find the crates themselves), which is the fundamental blocker.
[11:04:06] <tikue_> cmr: yeah definitely, I think I misunderstood the question
[11:04:08] <samnardoni> from_fn(x.read_char).take_while(|x| is_digit(x)) ... or something like that :)
[11:04:27] <Yurume> dbaupp: crate_to_metadata callback, perhaps?
[11:04:30] <cmr> dbaupp: metadata is so awful, rage refactoring it is my next project.
[11:04:37] <dbaupp> Yurume: eurgh
[11:04:50] <Yurume> ugly indeed :S
[11:05:01] <mmalecki> rage refactoring, the best kind of refactoring!
[11:05:02] <dbaupp> Yurume: I think cmr approach of fundamentally fixing metadata is the correct one
[11:05:08] <tikue_> Seldaek: what is the type of stream?
[11:05:31] <Seldaek> tikue_: TcpStream
[11:05:45] <samnardoni> is an iterator that runs a function repeatedly worth having in std?
[11:06:00] <Seldaek> tikue_: I think I just have to handle the None case when calling read_byte, but I was just curiou whether failing tasks is a performance issue or not
[11:06:20] <Yurume> samnardoni: struct Looping<'self,T> { func: &'self fn() -> Option<T> } impl<'self,T> Iterator<T> for Looping<'self,T> { fn next(&mut self) -> Option<T> { self.func() } }
[11:06:34] <Seldaek> let's say you have a task with loop { break }, vs one with loop { fail!(""); }, what's the overhead of the latter?
[11:06:54] <dbaupp> samnardoni: you can do something very similar with std::iter::Unfold, I imagine.
[11:07:08] <samnardoni> Yurume: cheers :)
[11:07:36] <Yurume> ah, right, you can use Unfold::new(|_ignoredstate| func())
[11:07:42] <cmr> Seldaek: failure (exceptions) limit LLVM's ability to optimize.
[11:07:56] <tikue_> Seldaek: there's definitely overhead involved in failing. I don't know exactly how much. any of these other guys might though
[11:07:57] <Yurume> Unfold::<()>::new(|_| func()) to be exact, it requires a type of state
[11:08:05] <Seldaek> cmr: so any expect() call is bad? :)
[11:09:01] <tikue_> Seldaek: it depends. if it's a use case where you want to fail then fail imo. a lot of times you can do something else though
[11:09:03] <cmr> Seldaek: It's not that big of a deal outside of hot loops afaik
[11:09:13] <Seldaek> ok 
[11:09:18] <cmr> Seldaek: profile it/compare IR I guess?
[11:09:20] <cmr> or ask strcat :P
[11:09:35] <Seldaek> the latter sounds easier :P
[11:09:55] <strcat> the stdlib is hopelessly slow in that regard anyway
[11:10:06] <strcat> Seldaek: actual unwinding is very slow
[11:10:18] <strcat> table-based unwinding is designed to be zero cost in the non-exceptional path
[11:10:23] <strcat> and *very slow* in the exceptional path
[11:10:41] *** Joins: tulloch (tulloch@moz-BC895BC5.damtp.cam.ac.uk)
[11:10:48] <Seldaek> ok, doing it when a client closes the connection is kinda harmless for the client though, but it hurts overall server perf
[11:10:52] <strcat> it's not actually zero-cost in the non-exceptional path because it adds a lot of binary bloat and makes some high-level transformations not work
[11:11:00] <strcat> but it doesn't execute any instructions there
[11:11:09] *** Quits: jdm (jdm@moz-99690620.hinet-ip.hinet.net) (Quit: Lost terminal)
[11:11:13] <Seldaek> but I guess I should fix my reads anyway:)
[11:11:17] <strcat> Seldaek: it's slow but it's not end-of-the-world slow
[11:11:18] <tikue_> Seldaek: I don't think failure is the right thing in that case
[11:11:28] <tikue_> closing a connection isn't really out of the ordinary is it?
[11:11:38] <strcat> shouldn't use failure as a control flow feature
[11:11:40] <Seldaek> no it sounds wrong, and it's only one .expect() I have to remove..
[11:12:06] <Seldaek> the others are when booting up the server, at which point it's ok to fail hard if anything goes bad 
[11:12:08] *** Quits: vmx (vmx@moz-9A879F12.dip0.t-ipconnect.de) (Connection timed out)
[11:12:13] <tikue_> Seldaek: yeah definitely
[11:12:22] <strcat> think of failure as exit() for a task (cleans up resources, but doesn't kill the process)
[11:12:35] <strcat> (exit ofc doesn't clean up resources ;])
[11:12:47] *** Joins: vmx (vmx@moz-9A879F12.dip0.t-ipconnect.de)
[11:13:19] <tikue_> Seldaek: do you spawn a task to handle each connection and want to end the task when the connection closes? 
[11:13:39] <Yurume> Seldaek: it is important that the number of read() etc. calls should be much higher than that of connection failure, which occurs at most once per the established connection.
[11:13:39] <Seldaek> tikue_: yup pretty much
[11:14:16] <tikue_> Seldaek: I'd just break out of a tight loop 
[11:14:19] *** Joins: smarter (smarter@moz-9C03B7C7.cust.bluewin.ch)
[11:14:27] <Yurume> of course it would be a main concern when you may expect a bootload of malicious connections
[11:14:37] <tikue_> loop { match client.read(buf) { Some(n) => handle_data(buf), None => break } }
[11:14:47] *** Quits: StarLight (StarLight@moz-6F3C7C83.dynamic.avangarddsl.ru) (Ping timeout)
[11:14:56] *** Joins: mib_eta3r9 (Mibbit@FFD5A27C.DBDA5624.50521DC.IP)
[11:15:21] <Seldaek> tikue_: yup I need to change my code a bit to allow for this though
[11:15:42] <dd> just making confirmation : besides basic primitive types can we return struct , enum or any datastructure ?
[11:15:57] *** Quits: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net) (Quit: Sharp)
[11:16:02] <Yurume> of course!
[11:16:19] <tikue_> imo TcpStream shouldn't have an iter() method
[11:16:27] <dd> thanks <Yurume>
[11:16:33] <Yurume> it "moves" from the function (unless it's just another borrowed pointer from outside)
[11:16:37] <tikue_> for line in stream.iter() { handle(line) }
[11:18:12] <Yurume> tikue_: what newline characters should such iter() method use anyway
[11:18:19] *** Joins: Earnestly (earnest@38FE72A5.82423D8F.BFD1ABFD.IP)
[11:18:28] *** Parts: z0w0 (zack@moz-5E840EF3.lns3.woo.bigpond.net.au) ()
[11:18:37] <Yurume> hmm, split_iter() *can* make some sense
[11:18:37] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Client exited)
[11:19:03] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[11:19:12] *** Joins: StarLight (StarLight@moz-48D2C0B3.dynamic.avangarddsl.ru)
[11:19:26] <tikue_> Yurume: it's a good question. I haven't thought much about it. Presumably it would depend on what you were doing, so yeah split_iter() would probably be the way to go
[11:20:03] <tikue_> and it should be backed by a buffer as well
[11:20:20] *** Quits: samnardoni (Mibbit@F889EF52.38924046.A86B7D63.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[11:20:23] <Yurume> an example of horrible use cases would be the IRC protocol...
[11:20:44] <Yurume> (which basically expects \r\n, but many servers can accept \r or \n)
[11:21:04] <tikue_> yeah
[11:21:09] * tikue_ looks at the mailing list
[11:21:23] <tikue_> i really like that go eliminated `while`
[11:21:30] <tikue_> overloading for makes so much sense to me
[11:21:58] <tikue_> `for i in range(5)` and `for i < 5`
[11:22:08] <tikue_> no need for a separate keyword right? it's unambiguous
[11:23:21] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Client exited)
[11:23:45] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[11:23:57] <Yurume> for needs l-value after it, while needs r-value after it, l-value and r-value overlaps but somewhat different to each other.
[11:23:59] <dbaupp> tikue_: it's not finite-lookahead unambiguous
[11:24:12] <Yurume> but is somewhat*
[11:24:21] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Ping timeout)
[11:24:23] <tikue_> dbaupp: is it more than what already exists?
[11:24:36] <dbaupp> tikue_: I don't understand what that question means?
[11:24:47] <Yurume> hmm, wait, I think `(a, b) = foo;` is now valid...
[11:24:50] <tikue_> require more lookahead than the compiler already does?
[11:25:00] *** Joins: tikue (quassel@moz-FEADCD38.hsd1.pa.comcast.net)
[11:25:56] <dbaupp> oh, yes
[11:26:00] <dbaupp> infinite
[11:26:13] <dbaupp> and the compiler doesn't do infinite (or at least, doesn't need to)
[11:26:28] <tikue> ah
[11:26:36] <tikue> wwell then that's a very good reason
[11:26:37] *** Quits: donri (donri@moz-9BB61102.tbcn.telia.com) (Client exited)
[11:26:57] <Yurume> dbaupp: how does rustc distinguish l-values from r-values? parsing an union of them and filtering later?
[11:27:22] <dbaupp> `for (a,b,c,d,e, ....as long as you want..., ref z) in foo()` vs `for (a,b,c,...z).some_method_returning_bool() {`
[11:27:34] <dbaupp> Yurume: no, it just parses the appropriate one based on context
[11:27:54] <dbaupp> Yurume: although "l-values" aren't really the concern here, just patterns
[11:28:21] <Yurume> isn't `(a,b)` in `(a,b) = foo();` a pattern?
[11:28:39] <dbaupp> it's not parsed as one, and isn't supported as an l-value
[11:29:18] <kimundi> Seldaek: Err, why are you using .expect("") ? :P That does the same as .unwrap(), but fails with a empty error message instead of "called Option::unwrap() on a None value"
[11:29:20] <dbaupp> (at least, it's currently just parsed as an expression, and isn't currently supported as an l-value)
[11:30:07] <kimundi> (Whoops, shouldn't have send just yet, I'm still reading backlog 40min in the past...)
[11:31:46] <Yurume> flush backlog! :p
[11:32:13] *** Joins: fyolnish (fyolnish@moz-4EC3BF87.uqwimax.jp)
[11:32:26] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[11:32:41] *** Joins: foo (bar@moz-9B8221B3.rivrw1.nsw.optusnet.com.au)
[11:34:47] *** Quits: nano (nano@moz-74CAD1CA.superkabel.de) (Connection reset by peer)
[11:35:11] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[11:35:34] *** Joins: dredozubov (dredozubov@2F14E2C1.F70E5FA9.F63E14E8.IP)
[11:35:40] <Seldaek> kimundi: no worries, but yeah fair enough
[11:37:10] *** Joins: sk (sk@9E6B574B.EB2AA036.2CAF0D3B.IP)
[11:37:26] <ChrisMorgan> strcat: "#pragma version" is indeed what I'm intending to check to disambiguate RenderScript.
[11:37:50] <ChrisMorgan> geomyidae: yeah, I still have that Bitcoin and have been watching the current trends vaguely with amusement.
[11:37:55] *** Quits: foo (bar@moz-9B8221B3.rivrw1.nsw.optusnet.com.au) (Connection reset by peer)
[11:37:58] *** Joins: foo (bar@moz-9B8221B3.rivrw1.nsw.optusnet.com.au)
[11:38:27] <Seldaek> ChrisMorgan: you'll soon be a millionaire
[11:39:02] <Yurume> do we need a Bitcoin implementation in Rust? :p
[11:39:18] <ChrisMorgan> It would be rather amusing if I become a millionaire because of rust-http not because of itself but because of an early Bitcoin donation...
[11:40:05] *** Joins: donri (donri@moz-9BB61102.tbcn.telia.com)
[11:40:08] <Yurume> did someone donate to rust-http at all?! :o
[11:42:22] <dd> hi puting semicolon at the end of the statement means returning nothing ?? does it is true in every situation ?
[11:42:41] <strcat> dd: it's a separator
[11:42:49] <strcat> a semicolon turns an expression into a statement
[11:42:54] <strcat> 2
[11:42:55] <strcat> an expr
[11:42:57] <strcat> 2;
[11:42:59] <strcat> a statement
[11:43:22] <strcat> at least that's how I think about it :P
[11:43:23] <dd> fn myfun()-> (){a;}
[11:43:27] <dd> this is true :(
[11:43:30] <dd> i guess :P
[11:43:46] *** Quits: arodier74 (Thunderbir@moz-527C2D95.in-addr.btopenworld.com) (Ping timeout)
[11:43:58] <strcat> dd: by using ; you're ending a statement, and if there's not an expr as the last thing in a block it returns ()
[11:44:27] <dd> okey , i git it , :) i am making it as statement but return can retuen only expression :)
[11:44:35] <dd> thnks strcat :)
[11:44:40] *** Quits: Ms2ger (Ms2ger@moz-B4F6BCFC.ugent.be) (Quit: bbiab)
[11:45:17] *** Quits: foo (bar@moz-9B8221B3.rivrw1.nsw.optusnet.com.au) (Client exited)
[11:45:38] * ChrisMorgan triumphed in his suggestion that ReoScript switch from .rs to .reo :-)
[11:47:09] <Yurume> what if Rust changes its extension from .rs to .ru or .rus? ;) (half kidding)
[11:47:31] *** Joins: arodier74 (Thunderbir@moz-C6D64CBF.in-addr.btopenworld.com)
[11:47:34] *** Quits: GeneralMaximus (ankur@52FD6510.75FB07DC.8B6C1D65.IP) (Quit: Computer has gone to sleep.)
[11:47:59] <dbaupp> we could have it change to '.r' and then just '.' ... slowly rust away.
[11:48:32] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[11:49:08] <Yurume> or .r5 or .rS
[11:49:19] *** Quits: arodier74 (Thunderbir@moz-C6D64CBF.in-addr.btopenworld.com) (Ping timeout)
[11:49:59] <ross> or .fe
[11:50:16] <dd> let y=~10; does y is an object ?? 
[11:50:29] <cmr> dd: y is a ~int
[11:50:35] <cmr> Pointer to an int on the heap
[11:50:37] <Yurume> or .oxd, since Rust is made from oxidation?
[11:50:55] <Yurume> anyway, a file extension is a finite estate (unfortunately).
[11:50:56] <ChrisMorgan> We can say that nonidiomatic code requires r11n ("rustification").
[11:51:05] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Ping timeout)
[11:51:19] <benh> Yeah, we should switch to .ru and move operations to russia, to compete with the perl masterminds in poland
[11:51:27] <dd> ~ what is use of it ?? 
[11:52:07] <dd> let mut h : int =10 ; what is difference between these two ?
[11:52:12] <dbaupp> ChrisMorgan: I hope that "nonidiomatic" incoporates code in any other language. :p
[11:52:21] <ChrisMorgan> Of course.
[11:52:25] <benh> dd: ~int is for heap allocation
[11:52:39] <benh> let h: int = 10 is on the stack
[11:53:17] *** Quits: axitkhurana (Adium@34C7F9C0.B32F1A35.6AA50C35.IP) (Quit: Leaving.)
[11:53:29] <dd> what is advantage of having it in heap ?
[11:53:44] <dd> it serves the purpose in both the cases :P
[11:53:44] *** Joins: arodier74 (Thunderbir@moz-866FC9AA.in-addr.btopenworld.com)
[11:53:45] <strcat> dd: http://static.rust-lang.org/doc/master/tutorial.html#boxes
[11:53:56] <strcat> mostly, so you can define recursive data structures
[11:54:11] <strcat> there are performance tradeoffs too
[11:54:17] *** Joins: jensnockert (jensnocker@E26F71DB.81840CBC.B0E77544.IP)
[11:55:30] <Yurume> dd: it would be unusual to have ints in the heap, of course. but it's much useful for larger structs or data structures
[11:57:13] <dd> okey but as i can read it there no matter what is the actual size of struct it [~] makes it always the size of  int pointer 
[11:57:19] <dd> is it so >
[11:57:51] <benh> the actual int or whatever still lives in the heap with its real size
[11:58:11] <strcat> dd: what it does is add indirection, ~ is itself a pointer to some dynamically allocated memory
[11:58:24] <strcat> it cleans up the memory in the destructor
[11:58:33] <Yurume> read it as std::unique_ptr(...) if you have C++ experience
[11:58:42] <Yurume> (relative modern C++ experience, that is)
[11:58:47] <Yurume> relatively*
[11:59:30] <dd> is there are some chances of address printing also possible ?
[12:00:33] <dd> and what if heap is full ? as this language has resolved the issue of null pointer and null , if i am not wrong ?? :P
[12:01:13] *** Quits: ross (ross@moz-5EA04060.br.br.cox.net) (Quit: )
[12:01:25] <strcat> the stdlib doesn't support doing anything but aborting on out-of-memory (although with overcommit out-of-memory isn't really a thing you can handle anyway)
[12:01:42] *** Quits: Liothen (liothen@moz-2D076547.spkn.qwest.net) (Ping timeout)
[12:01:57] *** Joins: spott (spott@moz-9B11536C.hsd1.co.comcast.net)
[12:02:01] <Yurume> dd: in most cases, if malloc returns NULL, what you can do is limited
[12:02:22] <strcat> you can do better than the stdlib does, though, you can unwind and call dtors if you enforce that dtors don't allocate
[12:02:30] <dd> but does rust has resolved null pointer problem ??
[12:02:40] <strcat> dd: the safe pointer types are never null
[12:02:43] <strcat> it's not possible
[12:02:51] <strcat> the initialization and allocation is one step
[12:02:57] <Yurume> it prevents you from *deferencing* null pointers.
[12:03:05] *** Quits: mimcpher (mimcpher@moz-345B5EBA.csclub.uwaterloo.ca) (Ping timeout)
[12:03:06] <strcat> rust's lightweight references (&) always point to valid (not null, not dangling) memory
[12:03:07] *** Joins: mimcpher (mimcpher@moz-345B5EBA.csclub.uwaterloo.ca)
[12:03:07] <dd> okey okey 
[12:03:11] *** Quits: jj2baile (jon@moz-345B5EBA.csclub.uwaterloo.ca) (Ping timeout)
[12:03:12] *** Joins: jj2baile (jon@moz-345B5EBA.csclub.uwaterloo.ca)
[12:03:25] *** Quits: maxli (maxli@moz-4D28BA20.student.cs.uwaterloo.ca) (Ping timeout)
[12:03:30] <strcat> making & safe is a hard problem rust solves, avoiding null in a language isn't really hard
[12:03:35] *** Joins: maxli (maxli@moz-4D28BA20.student.cs.uwaterloo.ca)
[12:03:37] *** Quits: spott (spott@moz-9B11536C.hsd1.co.comcast.net) (Ping timeout)
[12:03:46] <Yurume> you can have some unsafe code that makes a null pointer, which is not what the safe code assumes, and it can go bad ;)
[12:03:58] *** Joins: Sorella_ (quildreen@D2D1E5DD.81EFC25A.A95FAE2B.IP)
[12:04:14] <dd> okey okey , i got it :)
[12:04:15] * dbaupp wishes that syntax thread has a less inflammatory name, if it's not going to stop
[12:04:33] <tikue> lol same
[12:04:34] <tikue> :\
[12:04:39] * strcat doesn't understand what's wrong with that part of the tutorial ;(
[12:04:39] <Yurume> dbaupp: agreed, how about "bikeshed strikes again"?
[12:05:00] * tikue pats strcat
[12:05:13] <tikue> it's a hard concept. i don't think there's anything wrong with the tutorial
[12:05:19] *** Joins: hyunjunekim (Mibbit@7D74E938.F9F187B.FCFA478E.IP)
[12:05:20] <Yurume> (with a pointer to the definition of bikeshedding in the wiki)
[12:05:23] <strcat> I think it used to be bad
[12:05:31] <strcat> but imo I fixed it after a few rewrites
[12:05:37] <strcat> the coverage of & is still awful
[12:05:42] <strcat> but ~? I think it does a great job.
[12:05:57] * strcat shrugs
[12:06:21] <strcat> I'm not very motivated to write it in a style where it walks through writing a data structure if I keep hearing that it's bad (with no reasons why)
[12:06:40] <Yurume> rusti: let x = ~3; unsafe { x as uint }
[12:06:40] -rusti- <anon>:9:30: 9:39 error: non-scalar cast: `~<VI0>` as `uint`
[12:06:41] -rusti- <anon>:9          let x = ~3; unsafe { x as uint }
[12:06:41] -rusti-                                        ^~~~~~~~~
[12:06:41] -rusti- error: aborting due to previous error
[12:06:41] -rusti- application terminated with error code 101
[12:06:42] *** Quits: tulloch (tulloch@moz-BC895BC5.damtp.cam.ac.uk) (Ping timeout)
[12:06:48] <Yurume> aah, wait..
[12:06:50] <strcat> Yurume: can do &*x
[12:06:55] <strcat> and coerce to a raw ptr
[12:06:56] <Yurume> rusti: let x = ~3; unsafe { &*x as uint }
[12:06:57] -rusti- <anon>:9:30: 9:41 error: non-scalar cast: `&<VI0>` as `uint`
[12:06:57] -rusti- <anon>:9          let x = ~3; unsafe { &*x as uint }
[12:06:57] -rusti-                                        ^~~~~~~~~~~
[12:06:57] -rusti- error: aborting due to previous error
[12:06:57] -rusti- application terminated with error code 101
[12:06:57] <strcat> and cast that as int
[12:07:01] <Yurume> hm?
[12:07:14] <dbaupp> rusti: let x = ~3; &*x as *int as uint
[12:07:14] -rusti- 139863760461912u
[12:07:34] <Yurume> maybe I forgot to transmute, anyway
[12:07:51] <Yurume> dd: this is how you can print the address of the ptr, if you really want
[12:08:12] <strcat> it doesn't mean much though :P
[12:08:14] <dbaupp> rusti: println!("{}", &*(~3) as *int)
[12:08:15] -rusti- 0x7f1670026058
[12:08:15] -rusti- ()
[12:08:30] <cmr> rusti: prnitln!("{:p}", ~3i)
[12:08:31] -rusti- <anon>:9:9: 9:16 error: macro undefined: 'prnitln'
[12:08:31] -rusti- <anon>:9          prnitln!("{:p}", ~3i)
[12:08:31] -rusti-                   ^~~~~~~
[12:08:31] -rusti- application terminated with error code 101
[12:08:33] <Yurume> rusti: println!("{:?}", &*(~3) as *int)
[12:08:33] -rusti- (0x7f1680426058 as *())
[12:08:33] -rusti- ()
[12:08:36] <Yurume> or so.
[12:08:38] <cmr> rusti: println!("{:p}", ~3i)
[12:08:40] <strcat> LLVM is getting basic escape analysis soon and it would happily put that on the stack
[12:08:40] -rusti- pastebinned 10 lines of output: http://sprunge.us/JeeX
[12:08:45] <cmr> Hm
[12:09:05] <dbaupp> strcat: if we had nicer malloc calling, right?
[12:09:17] <cmr> strcat: ohh it is? sweet
[12:09:30] <strcat> dbaupp: well, segmented stacks are gone
[12:09:37] <strcat> so all that really needs to happen is fixing the libc signatures
[12:09:50] <strcat> it works fine for rust-core (dead store elimination of allocations)
[12:11:08] <strcat> so the escape analysis will work
[12:11:09] <dbaupp> strcat: you mean std::libc::malloc?
[12:11:13] <strcat> dbaupp: yes
[12:11:19] <strcat> the signature doesn't match LLVM's libcall definition
[12:11:27] *** Quits: jensnockert (jensnocker@E26F71DB.81840CBC.B0E77544.IP) (Input/output error)
[12:11:33] <strcat> it doesn't like 'enum Void {} *Void'
[12:11:37] *** Joins: jensnockert (jensnocker@E26F71DB.81840CBC.B0E77544.IP)
[12:11:38] <dbaupp> is it a 3 line change?
[12:11:45] <strcat> it has to use *u8
[12:11:48] <dbaupp> to *u8, right?
[12:12:09] <strcat> and exchange_malloc and exchange_free need to be #[inline]
[12:14:52] <dbaupp> why do we have exchange_malloc and malloc_raw?
[12:15:11] <strcat> https://github.com/thestinger/rust-core/blob/master/core/heap.rs
[12:15:42] * strcat should stop putting #[inline] on stuff in rust-core
[12:15:47] *** Joins: rofrol (rofrol@moz-8C55345C.static.ptr.magnet.ie)
[12:16:00] <cmr> strcat: habit? :p
[12:16:01] <strcat> might as well pretend only LTO exists ;p
[12:16:15] <strcat> cmr: yes
[12:16:34] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[12:16:41] <hyunjunekim> I have some question. When send managed type on fuction, Why to occer Err to be "The managed box syntax may be replaced by a library type, and a garbage collector is not yet implemented. Consider using the `std::rc` module as it performs much better as a reference counting implementation."
[12:16:43] <strcat> I feel bad about removing them all, but I don't *really* care about dynamic linking
[12:16:46] <rofrol> Hi
[12:16:51] <hyunjunekim> Hi:)
[12:17:07] <strcat> hyunjunekim: the managed pointer syntax is going to be removed, so it's behind a feature flag
[12:17:16] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[12:17:18] <strcat> the compiler printed out a note after that saying how to enable managed pointers
[12:17:19] <rofrol> I've found some mistake in doc for std::fmt: When implementing a format trait for your own time -> When implementing a format trait for your own type
[12:17:42] <dbaupp> rofrol: feel free to open a pull request :)
[12:18:24] <dbaupp> strcat: it can be i8 too right? LLVM doesn't see a difference?
[12:18:38] <strcat> dbaupp: doesn't see a difference but u8 makes more sense
[12:19:42] <strcat> u8 essentially means byte, while i8 has more implications of being used directly as an integer
[12:20:03] <strcat> (for example, treating a bit as a sign during casts)
[12:20:04] <dbaupp> I know, but converting c_char -> u8 everywhere is too much effort for now
[12:20:23] <strcat> isn't it already Void though?
[12:20:26] <strcat> so the conversions exist
[12:21:40] <dbaupp> well, I guess I can just leave everything else as c_char and use u8 for the libc symbols.
[12:23:03] <strcat> dbaupp: it should really be *mut too, but I don't really care
[12:23:08] <strcat> I did it right when I rewrote it ;p
[12:23:32] <strcat> using * when it's mutable is really bad because then you end up using & and immutable variables
[12:23:38] <strcat> and it's actually incorrect
[12:23:59] *** Quits: mib_eta3r9 (Mibbit@FFD5A27C.DBDA5624.50521DC.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[12:24:28] <strcat> I'm not sure how to even approach making the existing codebase mutability-correct so we can tell LLVM & means immutable for Freeze types
[12:24:29] <dbaupp> yeah, I am using *mut
[12:24:38] <strcat> dbaupp: well you're asking for pain if you do ;p
[12:24:43] <dbaupp> strcat: write more lints?
[12:24:44] <strcat> since it probably uses it 100 times
[12:25:21] *** Quits: jensnockert (jensnocker@E26F71DB.81840CBC.B0E77544.IP) (Input/output error)
[12:25:21] <strcat> dbaupp: the libc definitions are mostly wrong, though
[12:25:40] <strcat> it's sort of the same thing where we marked all extern functions as unsafe
[12:25:47] <strcat> I don't like it for my own code, but apparently the stdlib needs it
[12:25:53] *** Joins: jensnockert (jensnocker@E26F71DB.81840CBC.B0E77544.IP)
[12:25:53] *** Quits: ofeldt (ofeldt@moz-8B58830E.dip0.t-ipconnect.de) (Ping timeout)
[12:26:32] <strcat> https://github.com/thestinger/rust-core/blob/master/core/f32.rs this entire module is basically a workaround for not being able to mark extern fns as safe ;p
[12:26:43] <strcat> could just be using #[link_name]
[12:26:44] *** Joins: ofeldt (ofeldt@moz-E137D20E.dip0.t-ipconnect.de)
[12:27:23] <strcat> I guess I could use 'pub use', too, but the generated docs suck
[12:27:36] *** Quits: jensnockert (jensnocker@E26F71DB.81840CBC.B0E77544.IP) (Ping timeout)
[12:28:43] *** Quits: maxli (maxli@moz-4D28BA20.student.cs.uwaterloo.ca) (Quit: Leaving.)
[12:30:34] *** Joins: jensnockert (jensnocker@E26F71DB.81840CBC.B0E77544.IP)
[12:31:14] *** Quits: zakora (NC@moz-8EAF945F.fbx.proxad.net) (Input/output error)
[12:31:42] *** Quits: dd (chatzilla@B61C2AE3.78BE666E.9105FBCF.IP) (Quit: ChatZilla 0.9.90.1 [Firefox 25.0/20131028113246])
[12:32:08] *** Joins: freezerburnv (freezerbur@moz-E25EEE31.washdc.fios.verizon.net)
[12:32:48] *** Quits: Sgeo (quassel@moz-D0F30617.dyn.optonline.net) (Connection reset by peer)
[12:34:34] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[12:34:42] *** Quits: alonlevy (alon@moz-FED7051B.bb.netvision.net.il) (Ping timeout)
[12:35:09] <hyunjunekim> strcat: Thank you~ i solved~ 
[12:36:28] <eddyb> who broke this? https://github.com/mozilla/rust/wiki/Rust-for-CXX-programmers
[12:36:38] <dbaupp> eddyb: github
[12:36:57] <eddyb> .. vim: ft=rst 
[12:37:07] <eddyb> the mention of vim seems highly suspect
[12:37:10] <dbaupp> eddyb: strcat and I made single sentence edits and github was like "nope, let's break it"
[12:37:18] *** Quits: sk (sk@9E6B574B.EB2AA036.2CAF0D3B.IP) (Ping timeout)
[12:37:46] *** Quits: arodier74 (Thunderbir@moz-866FC9AA.in-addr.btopenworld.com) (Ping timeout)
[12:37:48] *** Joins: arodier74 (Thunderbir@moz-866FC9AA.in-addr.btopenworld.com)
[12:37:52] *** Quits: doomlord_ (servitor@moz-4625DF14.range86-184.btcentralplus.com) (Ping timeout)
[12:38:11] *** Joins: doomlord_ (servitor@moz-4625DF14.range86-184.btcentralplus.com)
[12:38:19] <Yurume> eddyb: preview is fine, it's just github that is broken
[12:38:58] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[12:47:07] *** Quits: quvarxa (chatzilla@moz-978E4C31.static.tpgi.com.au) (Quit: ChatZilla 0.9.90.1 [Firefox 26.0/20131114085019])
[12:47:10] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[12:47:35] <strcat> dbaupp: oh well, an opportunity to spread Vec<T>/Str propaganda
[12:47:42] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[12:47:56] *** Joins: Ms2ger (Ms2ger@moz-C1CB862F.ugent.be)
[12:48:06] <cmr> heh
[12:48:18] <dbaupp> strcat: \o/
[12:48:37] <cmr> I love stirring the pot in r/rust, it's the only time I get to have fun
[12:48:54] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[12:49:20] <dbaupp> cmr: are you saying that #rust isn't fun?
[12:49:30] * dbaupp is offended!
[12:49:48] <cmr> dbaupp: well... I mean...
[12:50:02] <cmr> bstrie is a pretty harsh slave driver
[12:50:07] * cmr slowly backs out of the room
[12:50:33] * Ms2ger tackles cmr 
[12:50:57] *** Joins: tulloch (tulloch@moz-1C33A2E7.nat.csx.cam.ac.uk)
[12:51:57] <cmr> It's always exciting to see the little envelope turn red
[12:52:45] *** Joins: sk (sk@C0394CB7.BF4CF9FF.4AC61A50.IP)
[12:52:59] * dbaupp wonders if posted-then-immediately-deleted comments appear as notifications
[12:53:23] <strcat> dbaupp: I don't think they do
[12:53:29] <dbaupp> drat
[12:53:43] * dbaupp was going to set up a script to give cmr ghost envelopes
[12:53:48] <cmr> hah
[12:53:50] <cmr> that'd be miserable
[12:55:57] <eddyb> if someone is watching you on github, you can push a commit just for them, then force-push without that commit
[12:56:15] <eddyb> I think the feed is the only way to see things like that
[12:57:00] <cmr> eddyb: and the excessive emails?
[12:57:07] <cmr> unless you mean to just some random repo
[12:57:28] <eddyb> dbaupp: oh, find a noisy issue, reference someone, then delete that comment
[12:57:55] <dbaupp> strcat: http://ix.io/94O/diff#n-139 doesn't seem to get dead-store elimination with ~ :(
[12:58:15] <dbaupp> strcat: (just below that is the exchange_malloc, etc, definitions.)
[12:58:38] * strcat shrugs
[12:58:49] *** Joins: maxli (maxli@moz-4D28BA20.student.cs.uwaterloo.ca)
[12:59:11] <strcat> dbaupp: what's your dead store example?
[12:59:27] <strcat> try something simple like 'let mut x = ~5; *x = 5;'
[12:59:32] <cmr> strcat: Why would you blight that planet with a colony ship full of /those/ people? :P
[12:59:55] <strcat> cmr: the ship will run on UEFI and Windows, it won't make it halfway there
[12:59:59] <cmr> heh
[13:00:05] <dbaupp> strcat: `fn main() { ~1; }` ?
[13:00:08] *** Quits: LU324 (weechat@9AF4F288.83671C58.1B5D53D7.IP) (Input/output error)
[13:00:09] <strcat> dbaupp: sure
[13:00:36] *** Joins: mib_fabr1p (Mibbit@moz-6671AEC9.rev.sfr.net)
[13:00:52] <eddyb> ahh, the impls libstd explain what I saw in rust-core (like the _raw suffix)
[13:01:04] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[13:01:19] <strcat> dbaupp: it works for rust-core.
[13:01:26] <strcat> fn main(_: int, _: **u8) -> int {
[13:01:28] <strcat>     let x = ~5;
[13:01:30] <strcat>     0
[13:01:32] <strcat> }
[13:01:34] <strcat> define i64 @main(i64, i8** nocapture readnone) unnamed_addr #1 {
[13:01:35] <dredozubov> just cloned rust repo, how can i run full testsuite?
[13:01:36] <strcat> top:
[13:01:38] <strcat>   ret i64 0
[13:01:40] <strcat> }
[13:01:42] <cmr> dredozubov: `make check`
[13:01:42] <strcat> make check
[13:01:44] <dbaupp> well, it's doing something, since I now see
[13:01:52] <dbaupp>  %1 = tail call i8* @malloc(i64 8)
[13:01:52] <dbaupp>   %2 = icmp eq i8* %1, null
[13:02:01] <dbaupp> rather than the huge-symbol silliness
[13:02:15] <strcat> it's supposed to remove that though :(
[13:02:23] *** Quits: mib_fabr1p (Mibbit@moz-6671AEC9.rev.sfr.net) (Quit: http://www.mibbit.com ajax IRC Client)
[13:02:25] <strcat> dbaupp: hmmm
[13:02:32] *** Joins: spott (spott@moz-9B11536C.hsd1.co.comcast.net)
[13:02:37] <strcat> dbaupp: so, what happens if you replace abort() with the rust-intrinsic abort
[13:02:46] <dbaupp> yup, even using #[start]
[13:03:45] * strcat doesn't understand why LLVM refuses to remove some of these function definitions
[13:03:49] <dbaupp> strcat: testing now... recompiles are fun.
[13:03:58] <strcat> ah they're not internal
[13:04:09] *** Quits: freezerburnv (freezerbur@moz-E25EEE31.washdc.fios.verizon.net) (Quit: freezerburnv)
[13:04:14] <strcat> acrichto made reachable suck 10x less but it still sucks
[13:04:16] *** Quits: spott (spott@moz-9B11536C.hsd1.co.comcast.net) (Ping timeout)
[13:04:35] *** kimundi is now known as zz_kimundi
[13:04:42] <strcat> very odd
[13:06:02] *** Joins: Savago (Savago@C350BE78.36A2CE1F.18DDB669.IP)
[13:06:37] <dbaupp> strcat: even http://ix.io/94P doesn't get eliminated
[13:07:07] <dbaupp> welp, just ignore the `*p = 1`... :P
[13:07:37] <dbaupp> it does make nicer IR though.
[13:08:41] *** Quits: Savago (Savago@C350BE78.36A2CE1F.18DDB669.IP) (Quit: Savago)
[13:08:45] *** Joins: blank_name (blank_name@FAB53C88.7071B2C8.31EC03F3.IP)
[13:09:07] *** Joins: Savago (Savago@D8B9C081.E820043D.D4C04133.IP)
[13:12:41] <tulloch> rust: is there any equivalent of http://clang.llvm.org/OpenProjects.html for the Rust project?  I've had some experience contributing to LLVM, etc and would like to start contributing here
[13:13:02] <strcat> tulloch: the bug tracker has a *lot* of "feature request" issues
[13:13:14] <strcat> an-interesting-project tag is one place to look
[13:14:57] *** Joins: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp)
[13:15:09] <rofrol> Why do I see markup here? https://github.com/mozilla/rust/wiki/Rust-for-CXX-programmers
[13:15:17] <strcat> github broke it
[13:15:30] <strcat> rofrol: click edit, click preview from there
[13:15:46] <strcat> I'll report it
[13:16:12] <rofrol> thx
[13:16:39] <mark_edward> why did rust decide to depend on libuv so much? S
[13:16:53] <cmr> mark_edward: because it's easy
[13:16:56] <nsf> because it's awesome
[13:16:59] <nsf> :)
[13:17:04] <cmr> mark_edward: smack a `#[no_uv];` on your crate and it goes awa
[13:17:05] <cmr> y
[13:17:16] <strcat> because different platforms don't use the same async/non-blocking/event systems
[13:17:20] <strcat> it's very hard to abstract over them
[13:17:24] <cmr> Some things are still unimplemented natively, but acrichto is slowly filling it out
[13:17:34] <strcat> so if rust wants async I/O, it probably wants something like libuv
[13:17:49] <mark_edward> but i've seen a lot of the mailing list threads and stuff and you guys seem to be constrained a lot by it. other languages like haskell and stuff have their own multiplatform runtimes?
[13:18:12] *** Joins: victorporof (victorporo@79FE7CA6.284D02A8.D111398B.IP)
[13:18:13] <strcat> there is really just one big issue with libuv
[13:18:23] <strcat> the fact that I/O can't be transferred to another thread
[13:18:35] <strcat> it's a big one but probably fixable
[13:18:43] <cmr> mark_edward: it's either use libuv, or reimplement libuv
[13:18:49] *** Joins: jfbk (jfbk@moz-EEA9CFB3.nyc.res.rr.com)
[13:19:01] <strcat> now, whether rust should be using M:N threading and implementing quasi-blocking APIs as async I/O by default is another story ;p
[13:19:11] <strcat> but async is needed, and libuv is a good way to do it
[13:19:27] <strcat> well
[13:19:36] <mark_edward> but wouldn't having your own stuff give you more room for future improvements and having the ability to make such changes on our own? how many other languages depend on such a library for critical features?
[13:19:39] <strcat> it's needed *to varying degrees* on various platforms
[13:19:41] <tulloch> strcat: thanks for the reference, will take al ook
[13:19:42] <cmr> mark_edward: It's better for everyone to use libuv and improve it than to reimplement it.
[13:19:56] <strcat> for example.... linux only really uses non-blocking sockets
[13:20:21] <mark_edward> cmr: have you guys submitted patches upstream to libuv?
[13:20:22] <strcat> linux threads are cheap/fast and blocking I/O is fast
[13:20:44] <strcat> it doesn't really have (mature/usable) async I/O
[13:20:53] <strcat> just ready-based non-blocking sockets.
[13:20:57] <dbaupp> mark_edward: yes
[13:21:48] <cmr> strcat: the limitation re threads makes sense given its origin :)
[13:21:49] <mark_edward> what do other similar languages do for threading? Nimrod?
[13:21:54] <mark_edward> D?
[13:22:04] <strcat> C++ and D use 1:1 threading
[13:22:39] *** Joins: Jackneill (Jackneill@moz-16CEF626.pool.digikabel.hu)
[13:22:41] <strcat> (and C++ doesn't have async I/O in the stdlib - there's boost::asio, as a very portable/fast high-level abstraction though)
[13:22:50] <mark_edward> D seems to have a good amount of momentum, maybe rust needs to support 1:1?
[13:23:00] <cmr> mark_edward: we already know we need to
[13:23:01] <strcat> what other languages do isn't really a good argument for anything
[13:23:05] <cmr> mark_edward: pay attention :P
[13:23:27] <mark_edward> oh yeah! i saw the big hubbub in the ML
[13:23:36] <mark_edward> have any of you guys used D before?
[13:23:58] <mark_edward> strcat, it is if you want to replace them
[13:24:06] <cmr> I played with it a bit before realizing it wasn't what I was looking for at the time
[13:24:18] *** zz_kimundi is now known as kimundi
[13:24:22] <mark_edward> the message passing in D seems a lot nicer than ours
[13:24:25] *** Quits: jensnockert (jensnocker@E26F71DB.81840CBC.B0E77544.IP) (Input/output error)
[13:24:41] <strcat> https://github.com/thestinger/rust-core/blob/master/core/concurrent.rs
[13:24:44] <strcat> I think this is fine.
[13:24:52] * strcat doesn't really think it could be better
[13:25:08] <strcat> need non-blocking versions but that's harder :P
[13:25:13] <strcat> to do quickly, at least
[13:25:28] <strcat> and you fall into the hellhole of wanting different versions specialized for single-consumer and so on
[13:25:59] <mark_edward> strcat, i wasn;'t talking about like at a technical level, i meant the way it's specified in code
[13:26:07] <strcat> I mean that too
[13:26:37] *** Joins: skal (skal@D5C2D2DF.E4265FCD.E481B5B.IP)
[13:26:51] <strcat> it's a queue object you can clone as many times as you need, it has 'fn pop(&mut self) -> T' and 'fn push(&mut self, item: T)' - what more do you need? ;P
[13:27:06] <strcat> I can't see how message passing could get any simpler
[13:27:24] <mark_edward> lol
[13:27:27] <strcat> if rustdoc worked on rust-core I would link to docs ;p
[13:27:36] *** Joins: jensnockert (jensnocker@E26F71DB.81840CBC.B0E77544.IP)
[13:27:39] <cmr> strcat: What's broken with rustdoc atm?
[13:27:47] <strcat> cmr: rust-core isn't a crate
[13:27:53] <cmr> Ah, yeah, that does it
[13:28:00] <mark_edward> but i meant like if you read this: http://www.informit.com/articles/article.aspx?p=1609144&seqNum=6 you see that in D there is no need to bother with creating ports or channels or anything like that
[13:28:07] <mark_edward> seems like a lot less boilerplate
[13:28:10] <strcat> cmr: oh and if I do make it a crate, it finds duplicate lang items?
[13:28:17] <strcat> cmr: it seems to not work with #[no_std] at all
[13:28:37] <cmr> mark_edward: We could have that too
[13:28:43] <cmr> Well, kinda
[13:28:48] <cmr> Not matching on type
[13:28:59] <cmr> But just add a send/recv to Thread
[13:29:16] <mark_edward> the matching on type would be sick
[13:29:21] <strcat> cmr: please don't though ;p
[13:29:25] <mark_edward> but that'd need compiler support though?
[13:29:25] <strcat> mark_edward: Queue<SomeEnum>
[13:29:28] <cmr> mark_edward: it's also slow
[13:29:32] <strcat> rust has sum types
[13:29:32] <cmr> (without enums)
[13:29:48] <strcat> in fact I think you'll usually use Queue<Option<T>>
[13:29:51] <pnkfelix> mark_edward: or leverage the recently added Any type in some way?
[13:29:55] <strcat> so you can send None to tell it to kill itself
[13:30:01] <pnkfelix> mark_edward: (not that I think that's a great idea...)
[13:30:16] <strcat> pnkfelix: well, with Any, you still need to know the type to do anything
[13:30:27] <cmr> kimundi wants a syntax extension so you can do like match_any! { ... } to match on types in Any
[13:30:32] <strcat> I think Any is useful in really strange library situations where something has to come from users but be opaque
[13:30:34] <mark_edward> i dunno, i think using TiDs with a send/recv is better abstraction than explicit ports/chans
[13:30:55] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[13:30:56] <pnkfelix> strcat: The impression I got was that in D you needed to know the type on both sides too …  But I'm not a D programmer, maybe I misunderstood the example.
[13:31:03] <strcat> mark_edward: is it a blocking or non-blocking queue?
[13:31:10] <strcat> it it bounded or unbounded?
[13:31:27] <strcat> D is also a language where every safely heap-allocated object is GC'ed
[13:31:45] <mark_edward> strcat, i don't know that for D or Rust, does it matter for the syntax abstraction i'm talking about?
[13:31:56] <strcat> mark_edward: you're not really asking for a syntax abstraction
[13:32:17] <strcat> you're asking for every thread to be associated with a queue, or saying we should encourage unbuffered channels
[13:32:33] <strcat> and also use reflection (like they are using) which isn't very idiomatic
[13:33:22] <strcat> what's idiomatic in another language doesn't necessarily make sense in rust
[13:33:37] <mark_edward> strcat, they need reflection? isn't that stuff known at compile time?
[13:33:46] <mark_edward> (the types in send/recv)
[13:34:18] *** pmoore|away is now known as pmoore
[13:35:08] <strcat> mark_edward: seems to be using something like an Any type
[13:35:16] <strcat> maybe not
[13:35:51] *** Joins: LU324 (weechat@9AF4F288.83671C58.1B5D53D7.IP)
[13:35:55] <cmr> It could be generating an enum if you don't use Variant
[13:36:14] <strcat> http://dlang.org/phobos/std_variant.html looks like Any to me
[13:36:32] <strcat> cmr: but they don't have language-level sum types and it doesn't look like they have them in the stdlib
[13:36:32] <eddyb> cmr: does it need to be a syntax extension?
[13:36:42] <cmr> eddyb: No, but it's ugly if it isn't
[13:36:48] <cmr> And doesn't look like match
[13:36:51] <strcat> anyway, so we have a thread, you send to it
[13:36:55] <strcat> where does it put what you sent?
[13:36:58] <strcat> a queue?
[13:37:12] <eddyb> cmr: you can use the typeid description and match on that
[13:37:14] <strcat> so each thread is going to have a Mutex, ConditionVariable and Deque
[13:37:21] <eddyb> s/description/intrinsic
[13:37:28] <eddyb> mind is not fully functional. need moar food
[13:37:34] <mark_edward> strcat, wherever you keep them in Ports right now
[13:37:47] *** Quits: Addle (quassel@moz-89E971E4.cable.teksavvy.com) (Ping timeout)
[13:37:56] *** Quits: cdidd (cdidd@moz-D1807593.broadband.corbina.ru) (Ping timeout)
[13:38:04] <strcat> mark_edward: they're kept in variables you put the ports in
[13:38:17] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[13:39:14] <strcat> that D message passing seems like an attempt at the whole worse is better thing but I don't really see how it's simpler ;\
[13:40:04] <mark_edward> no explicit chans/ports for one.
[13:40:14] <mark_edward> seems to remove some boilerplate
[13:40:20] <strcat> still need explicit chans/ports
[13:40:26] <strcat> each thread just starts with a queue
[13:40:45] <strcat> and what type is that queue?
[13:40:45] *** Quits: Ms2ger (Ms2ger@moz-C1CB862F.ugent.be) (Ping timeout)
[13:40:47] <mark_edward> not for the user
[13:41:00] <strcat> mark_edward: a user still needs explicit channels
[13:41:24] <strcat> a single queue associated with the task is not enough
[13:41:25] <eddyb> cmr: I think you can implement match_any! as a macro
[13:41:33] <strcat> and it's going to have to have a specific type
[13:41:37] <cmr> eddyb: yes, you can.
[13:41:43] <strcat> blocking? bounded? is it just Queue<~Any> ?
[13:41:45] <cmr> eddyb: macros are syntax extensions.
[13:41:59] <strcat> reflection is an extra problem to deal with compared to static typing
[13:42:14] *** Joins: alonlevy (alon@moz-92551128.red.bezeqint.net)
[13:42:19] <eddyb> cmr: oh... I thought you meant a procedural macro, i.e. libsyntax/ext
[13:42:20] <strcat> dbaupp: they fixed it
[13:42:33] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[13:42:57] <dbaupp> strcat: they == github? what was the problem?
[13:43:01] <strcat> dunno
[13:43:16] <strcat> I emailed them and they fixed it though.
[13:43:28] <dbaupp> cool
[13:43:44] <mark_edward> strcat, if you are the compiler, you can have a different struct with each Tid where it has Queue<int>, Queue<bool> for each send/recv type
[13:43:55] <cmr> mark_edward: now you're adding magic!
[13:44:02] <strcat> mark_edward: won't work
[13:44:11] <strcat> how do you know across the whole program (including other crates) which types are used
[13:44:13] <strcat> you can't
[13:44:17] <strcat> have to use reflection
[13:44:40] <strcat> if tasks are objects (like they are in rust-core, but not the stdlib) you have a handle to pass around
[13:44:54] <strcat> but the compiler cannot magically associated that handle with the specific task across the whole program
[13:44:58] <strcat> associate*
[13:47:32] <mark_edward> i see what you mean. i still hate how complex ports/chans make sending things back/forth are
[13:47:42] <strcat> mark_edward: I find it's enough in the common case that you can move into a proc started as a thread and return a value when you join - with a thread pool, you can do that efficiently
[13:47:50] <strcat> mark_edward: well, ignore whatever the stdlib does for a second
[13:47:57] <strcat> is that Queue type really complicated?
[13:48:17] <mark_edward> strcat, no, but that's not what i use in rust, i've never seen that before
[13:49:35] <dbaupp> mark_edward: they don't make it that complicated do they? `let (p, c) = stream(); do spawn { loop { p.recv(); ... } } loop { c.send(...) }`?
[13:49:38] <strcat> I plan on adding a concurrent hashmap too - it's perfectly fine to share fine-grained synchronized memory
[13:50:53] <strcat> dbaupp: but there are ChanOne, Chan and SharedChan ;p
[13:50:53] *** Quits: flowsnake (flowsnake@moz-E4E567EE.aztw.cable.virginm.net) (Ping timeout)
[13:50:58] *** Joins: flowsnake_ (flowsnake@moz-E4E567EE.aztw.cable.virginm.net)
[13:51:13] <strcat> the number of choices is intimidating
[13:51:13] <mark_edward> dbaupp, that's only one way messaging. how go i get results back? what if i need to send multiple things, it quickly starts getting silly how many ports/chans you need
[13:51:14] *** Quits: beifeng (Mibbit@284C36E7.3062CEC3.670EEFD.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[13:51:45] <strcat> mark_edward: and what do you expect with handles for tasks? they're not going to be copyable
[13:51:56] <strcat> they'll have a dtor
[13:52:11] <strcat> you'll have to put it into a mutable RWArc
[13:52:15] <strcat> and send it to other tasks
[13:52:25] *** Quits: ricepuddin (graham@moz-2AD4CE16.wlan.ic.ac.uk) (Ping timeout)
[13:52:33] <strcat> and .... I have a feeling that's going to be an easy way to deadlock
[13:52:48] <strcat> s/RWArc/MutexArc/
[13:53:26] *** Joins: Ms2ger (Ms2ger@moz-454C9175.ugent.be)
[13:53:52] <cmr> mark_edward: there's only so
[13:53:55] <cmr> erm
[13:54:12] <mark_edward> well in D's messaging for example child_tid.send(); (15 times for different types ) recv(<all the things>); result = call_my_fn_with_many_args(...); parent_tid.send(result)
[13:54:15] <strcat> (also that will add a mutex lock to every send)
[13:54:16] <cmr> mark_edward: there's only so much complexity you can hide before the sugar is worse than the thing it sugars over
[13:54:24] *** Quits: sk (sk@C0394CB7.BF4CF9FF.4AC61A50.IP) (Ping timeout)
[13:54:30] <strcat> mark_edward: wouldn't look that way in rust
[13:54:30] <mark_edward> imagine making all those ports/chans
[13:54:37] <cmr> mark_edward: you don't have to.
[13:54:38] <strcat> mark_edward: you don't need to
[13:54:41] <strcat> compare apples to apples
[13:54:45] <strcat> Queue<~Any>
[13:54:45] <cmr> mark_edward: use an enum of the types, or any
[13:54:50] <strcat> push whatever type you want
[13:54:54] <strcat> pop whatever type you want
[13:55:02] <strcat> a single Queue, 2 methods
[13:55:07] *** Quits: fyolnish (fyolnish@moz-4EC3BF87.uqwimax.jp) (Client exited)
[13:55:20] <mark_edward> it's not apples to apples, in D i don't have to use any enums or ANy types in D, that's hidden
[13:55:22] <strcat> (or an enum, that'd be better - then you can match on it too)
[13:55:32] <strcat> mark_edward: it is apples to apples
[13:55:34] <strcat> it's not hidden in D
[13:55:39] <cmr> mark_edward: it isn't really hidden though, you're matching on the type
[13:55:42] <strcat> D doesn't have sum types so they need a hack
[13:55:55] <strcat> they're using an ~Any type
[13:56:01] <strcat> that's what D's Variant is
[13:56:02] <mark_edward> but i don't see it
[13:56:23] <strcat> you see those weird receive blocks and the matching
[13:56:35] <strcat> you could do the same stuff in rust with a macro
[13:57:06] <strcat> enum Foo { A(int), B(int) } Queue<Foo>
[13:57:10] <strcat> .push(A(5))
[13:57:22] <strcat> match q.pop() { A(x) => ... }
[13:57:37] <strcat> can wrap that all behind a macro if you want, I guess
[13:58:50] *** Quits: Ms2ger (Ms2ger@moz-454C9175.ugent.be) (Ping timeout)
[13:58:52] <cmr> mark_edward: Rust likes to avoid hidden host
[13:58:54] <cmr> *cost
[13:58:56] <strcat> I really just want a bunch of nice concurrent containers
[13:59:34] <strcat> blocking/non-blocking queues, priority queues, maps
[13:59:37] <mark_edward> cmr, true
[13:59:50] <mark_edward> strcat, how hard is that stuff to write? java has a lot of that
[14:00:02] <strcat> it's easy to write blocking concurrent queues ;p
[14:00:09] <strcat> hashmap is a lot harder to do well
[14:00:16] <strcat> non-blocking containers are really, really hard to do well
[14:00:28] *** Joins: Ms2ger (Ms2ger@moz-454C9175.ugent.be)
[14:00:29] <mark_edward> can't you just port java impls?
[14:00:34] <strcat> no
[14:00:42] <strcat> that wouldn't count as done well ;p
[14:01:03] <strcat> unless they happen to be written in C++11-style atomics in non-Java code
[14:01:13] <strcat> (I doubt it)
[14:01:19] <pnkfelix> strcat: I agree they are probably not readily portable to Rust
[14:01:31] <mark_edward> strcat, what about intel's TBB? they have that stuff
[14:01:32] <pnkfelix> strcat: but I got the impression from Clojure presentations that they are performant
[14:01:50] <strcat> pnkfelix: I don't think they perform well compared to native implementations
[14:01:58] <strcat> especially clojure's ;p
[14:02:02] <strcat> java would be closer
[14:02:18] <strcat> pnkfelix: the clojure ones are also immutable, and that relies on a global GC
[14:02:25] *** Quits: Ms2ger (Ms2ger@moz-454C9175.ugent.be) (Ping timeout)
[14:02:38] <strcat> you can do low-fanout persistent trees with Arc but once you get more than a binary tree it's going to be really slow
[14:02:39] <pnkfelix> strcat: yes that is true, the need for a GC was the primary reason I was thinking they would not be readily portable to Rust
[14:03:08] *** Joins: spott (spott@moz-9B11536C.hsd1.co.comcast.net)
[14:03:20] <mark_edward> strcat, would intel's TBB stuff be copatible? it's available under a GPL license?
[14:03:26] <strcat> mark_edward: intel-tbb is the functionality I am essentially going to reproduce for rust-core
[14:03:31] <strcat> I don't really care about their implementations
[14:03:34] <strcat> just their APIs
[14:03:50] *** Joins: Ms2ger (Ms2ger@moz-454C9175.ugent.be)
[14:04:00] <strcat> they're probably not done as you would do them post-C++11/C11
[14:04:03] <mark_edward> their impl's might be really good tho. intel makes boss software IMO?
[14:04:31] <strcat> well, except that they have a bunch of competing products that cost money
[14:04:34] <strcat> ;p
[14:04:50] *** Quits: spott (spott@moz-9B11536C.hsd1.co.comcast.net) (Ping timeout)
[14:04:52] <strcat> http://software.intel.com/en-us/intel-parallel-studio-xe etc.
[14:05:01] <strcat> 2000 dollars! wooo
[14:05:26] <strcat> tbb is 500 dollars alone for commercial use though
[14:05:36] <strcat> (for a single user!)
[14:05:45] <mark_edward> it's abailable free though i think
[14:05:52] <strcat> yes it's GPL
[14:05:56] <strcat> at least, most of it is
[14:06:08] <strcat> but they have a bunch of other stuff integrated with it that's not
[14:06:38] <mark_edward> strcat, that's not the impression i got from here tho: http://www.threadingbuildingblocks.org/faq/10
[14:06:41] <strcat> I think the most interesting thing in intel-tbb would probably be their allocator
[14:07:08] <strcat> mark_edward: their parallel suite is 2k, intel-tbb is 500
[14:07:11] <strcat> so obviously there is more ;p
[14:07:35] <strcat> Intel® Math Kernel Library (Intel® MKL) and Intel® Integrated Performance Primitives (Intel® IPP) – Performance Libraries
[14:07:43] *** Joins: nano (nano@moz-74CAD1CA.superkabel.de)
[14:07:49] <strcat> Intel® Cilk™ Plus – Parallel Programming Models
[14:07:53] * strcat shrugs
[14:08:00] <strcat> Cilk is meant to be complementary to TBB
[14:08:45] <strcat> there's an open-source version though
[14:08:49] <strcat> I think they just merged it into gcc
[14:09:17] <strcat> anyway looking at their API is quite useful but in the end it's not really going to help me much
[14:09:41] <pnkfelix> someone also ported it to clang: http://cilkplus.github.io/
[14:10:02] <pnkfelix> (not finished yet though...)
[14:10:03] <Ms2ger> strcat, if they integrated gpl stuff, can't you force them to give you everything? :)
[14:10:04] <strcat> what would help me is a brain transplant from someone skilled at writing lock-free container
[14:10:06] <strcat> s
[14:10:16] <cmr> Ms2ger: they're the copyright owners
[14:10:20] <cmr> they can do what they want
[14:10:30] <Ms2ger> Aww
[14:10:32] <strcat> Ms2ger: the point is that *you* are forced to open-source your application
[14:10:35] <strcat> if you use intel-tbb
[14:10:38] <strcat> unless you pay 500 dollars for it
[14:10:45] <strcat> and if you have a team, you might have to pay more
[14:10:50] <strcat> (I guess you do)
[14:10:52] <eddyb> I just had another crazy idea
[14:11:06] <bstrie> eddyb: cut off your legs so you only have to pay intel $250 to use tbb?
[14:11:13] <eddyb> vec::new[0, 1, 2, 3, 4, 5]
[14:11:28] <eddyb> remember my variadic Index idea?
[14:11:32] <strcat> eddyb: or just Vec::new([0, 1, 2, 3, 4, 5]) like other containers ;p
[14:11:59] <eddyb> strcat: without requiring [0, 1, 2, 3, 4, 5] to work
[14:12:09] <strcat> we need fixed-size arrays though
[14:12:11] <strcat> in the language
[14:12:21] <strcat> we don't have integers in the type system
[14:12:32] *** Joins: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net)
[14:12:34] <strcat> and we don't have a way to allocate the right amount of memory, if we did
[14:12:46] <strcat> std::array in C++11 is pretty awful - it has to recursively build the definition of the data structure
[14:12:54] <strcat> goodbye compile-time ;p
[14:13:10] <strcat> (it's a struct)
[14:13:41] <strcat> mark_edward: they don't even say what algorithms they use in the docs ;\
[14:13:53] <strcat> but it does give me an idea of what I need
[14:13:56] *** Quits: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net) (Quit: Sharp)
[14:14:10] <bstrie> ...weird, what does `type foo = *();` do? is that to emulate a null pointer?
[14:14:12] <mark_edward> cool
[14:14:18] <strcat> a wrapper around an arbitrary allocator providing cache alignment, etc.
[14:14:21] <eddyb> my variadic Index trait idea requires variadic generics and someone to approve a variadic index operator
[14:14:30] <strcat> bstrie: not really anything, it's just a ptr to nothing
[14:14:39] <strcat> bstrie: enum Void {} *Void
[14:14:41] <dbaupp> bstrie: type `foo` is an alias for a raw pointer to `()`
[14:14:42] <strcat> makes a lot more sense
[14:15:00] <bstrie> dbaupp: but () is a zero-sized-type, it doesn't have an address to point to :\
[14:15:08] <bstrie> or does it?
[14:15:11] <strcat> bstrie: doesn't matter, it's still a ptr
[14:15:32] <dbaupp> bstrie: it can, you can malloc(0) (which is allowed to return null, but doesn't have to)
[14:15:33] <strcat> you receive a ptr from somewhere and give it whatever type
[14:15:40] <strcat> if it's meant to be opaque, it should really be opaque though.
[14:15:44] <strcat> *() is an anti-pattern imo
[14:15:52] <bstrie> strcat: saw it in http://blog.theincredibleholk.org/blog/2013/11/18/booting-to-rust/
[14:16:27] <strcat> for example, a FILE pointer in C
[14:16:29] <strcat> maps to
[14:16:34] <strcat> enum FILE {} *mut FILE
[14:18:22] <mark_edward> oh when were we gonna get all that nice support for allocators/pointer types?
[14:18:53] *** Joins: jdm (jdm@moz-ED0C7AC7.hinet-ip.hinet.net)
[14:18:53] *** ChanServ sets mode: +o jdm
[14:19:06] <eddyb> strcat: imagine being able to do mat[i, ()] and mat[(), j] to get row/column accessors :D
[14:19:09] <strcat> when generic dtors work, all the containers/pointers in rust-core will have allocators
[14:19:31] *** Joins: sk (sk@9E6B574B.EB2AA036.2CAF0D3B.IP)
[14:19:46] <benh> Are #[unsafe_destructor]s that broken still?
[14:20:06] <strcat> benh: it's not related to them being unsafe or not
[14:20:25] <strcat> librustc doesn't know how to handle a method call in a generic dtor on self
[14:20:37] <strcat> it doesn't make the type info it needs
[14:20:53] <strcat> because it generates the info based on method calls in the AST and dtors aren't method calls in the AST :(
[14:21:02] *** pmoore is now known as pmoore|away
[14:21:32] <mark_edward> why aren't they?
[14:21:40] <cmr> because they're magic!
[14:21:45] <eddyb> maybe they're added too late?
[14:21:46] <cmr> they aren't in the AST at all
[14:22:05] <eddyb> (or just emitted)
[14:22:07] <cmr> eddyb: they're never added
[14:22:33] <eddyb> lifetime errors are confusing :(
[14:22:46] *** Joins: ricepuddin (graham@moz-E8E84882.wlan.ic.ac.uk)
[14:23:13] <eddyb> the spans are so useless (for figuring out how to fix the error)
[14:24:34] <strcat> dtors are handled in trans, exclusively
[14:24:53] <strcat> the calls don't appear in the AST to be type checked or anything
[14:25:01] <strcat> so they miss out on the type information being generated
[14:25:27] *** Quits: w3lcome (Mibbit@moz-177EEEFC.home.otenet.gr) (Quit: http://www.mibbit.com ajax IRC Client)
[14:26:22] <eddyb> strcat: isn't the type info in the values?
[14:26:41] <strcat> the information for generics is generated based on calls in the AST
[14:26:42] <eddyb> or is it some kind of generic trait matching thing?
[14:26:53] <strcat> generics are instantiated so the information it needs is based on how they are used
[14:27:03] <strcat> but a dtor call doesn't get considered
[14:27:11] <strcat> so there's nothing for it to use
[14:27:32] <eddyb> oh, so the actual function is missing?
[14:27:35] <strcat> I guess for every time you construct a type you could output the data needed to destroy that instantiation
[14:27:36] <strcat> eddyb: no
[14:27:56] <strcat> the information needed to generate the instantiation of the function is missing
[14:29:25] <eddyb> I mean, does it end up trying to call a generic function without instantiating it, resulting in some sort of link error?
[14:29:31] <strcat> no
[14:29:41] <strcat> it can't instantiate a generic dtor that calls a method on self
[14:29:55] <strcat> because the info isn't there to do it
[14:30:00] <strcat> because it never got generated
[14:30:16] <eddyb> so what happens?
[14:31:44] <strcat> it ICEs
[14:32:08] *** Joins: exobit_ (textual@moz-E06F46F0.corp.bitshelter.com)
[14:33:26] <pnkfelix> "cleanups" are local jardon for the invocations of dtors being emitted by trans, right?
[14:33:34] *** Joins: canhtak (canhtak@moz-43EC0376.wl.t.ulaval.ca)
[14:33:45] <pnkfelix> I'm mostly double checking whether #6248 https://github.com/mozilla/rust/issues/6248 may be relevant to conversation
[14:34:51] <strcat> pnkfelix: no, I don't really think it's relevant (but yes, cleanups are what causes the invocations)
[14:34:58] <strcat> cleanups are currently done completely in trans
[14:35:00] <strcat> so it's too late
[14:35:15] *** Quits: ricepuddin (graham@moz-E8E84882.wlan.ic.ac.uk) (Ping timeout)
[14:35:31] <strcat> typeck generates the data I'm talking about (it calls them vtables, but vtable_static is just what generics need - it's not *really* a vtable)
[14:35:32] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[14:35:45] <strcat> atm, there's a base::get_res_dtor function
[14:36:09] <pnkfelix> strcat: ah, I misinterpreted what niko meant by "the cleanup generation would thus be driven off the AST"
[14:36:16] *** pmoore|away is now known as pmoore
[14:36:19] <strcat> it calls monomorphic_fn directly without vtables (there are none to use though, you can try to fetch them but it won't work since it didn't fill them out)
[14:36:21] *** Quits: Ms2ger (Ms2ger@moz-454C9175.ugent.be) (Ping timeout)
[14:36:46] <strcat> pnkfelix: well, maybe it would help
[14:36:48] <strcat> dunno
[14:36:51] *** Joins: Ms2ger (Ms2ger@moz-454C9175.ugent.be)
[14:36:54] <pnkfelix> strcat: I can't tell either, though I think you are right
[14:37:05] <strcat> if it inserted dtor calls into the AST it would fix this
[14:37:16] <pnkfelix> strcat: since niko even says in there that he would still keep the association (of cleanups with an expr id) in trans
[14:37:19] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[14:37:48] <strcat> so... I think what's needed is another table mapping to dtor vtables (or put it in the dtor table)
[14:37:51] <strcat> in tcx
[14:37:57] *** jorendorff_away is now known as jorendorff
[14:38:05] <strcat> and then typeck has to generate the dtor vtables every time a generic type is instantiated
[14:38:09] <strcat> and put it in there
[14:38:23] <strcat> but it's really opaque code, I had little luck trying to do this
[14:39:52] *** Quits: kmapped (kmapped@moz-2489C24B.compute-1.amazonaws.com) (Connection reset by peer)
[14:42:09] *** Joins: kmapped (kmapped@moz-2489C24B.compute-1.amazonaws.com)
[14:42:47] *** Joins: ricepuddin (graham@moz-E8E84882.wlan.ic.ac.uk)
[14:43:07] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[14:45:44] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[14:46:35] *** Joins: jvshahid (jvshahid@moz-53774307.nycm.ny.megapath.net)
[14:47:39] *** Quits: tulloch (tulloch@moz-1C33A2E7.nat.csx.cam.ac.uk) (Ping timeout)
[14:49:06] *** Joins: josh (josh@moz-6FB23C25.hvc.res.rr.com)
[14:49:21] *** Quits: nkoep (nik@moz-50882FD.pool.mediaways.net) (Ping timeout)
[14:55:32] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.2)
[14:56:54] *** Joins: tulloch (tulloch@moz-1C33A2E7.nat.csx.cam.ac.uk)
[14:57:12] *** Joins: jvshahid_ (jvshahid@moz-53774307.nycm.ny.megapath.net)
[14:57:15] *** Quits: jvshahid_ (jvshahid@moz-53774307.nycm.ny.megapath.net) (Quit: jvshahid_)
[14:57:20] *** Joins: pepper_chico (pepper_chi@41ABFFD4.95F7EC9A.86AA4479.IP)
[14:59:36] *** Quits: tiffany (kawaii@moz-28A8742A.dhcp.embarqhsd.net) (Input/output error)
[15:00:17] *** Quits: Ms2ger (Ms2ger@moz-454C9175.ugent.be) (Ping timeout)
[15:00:26] *** Joins: Ms2ger (Ms2ger@moz-454C9175.ugent.be)
[15:01:37] *** Quits: vmx (vmx@moz-9A879F12.dip0.t-ipconnect.de) (Ping timeout)
[15:02:25] *** Joins: mib_s6px8s (Mibbit@moz-22157C2F.mtq.gouv.qc.ca)
[15:02:41] *** Quits: mib_s6px8s (Mibbit@moz-22157C2F.mtq.gouv.qc.ca) (Quit: http://www.mibbit.com ajax IRC Client)
[15:02:44] *** Quits: pepper_chico (pepper_chi@41ABFFD4.95F7EC9A.86AA4479.IP) (Quit: Ex-Chat)
[15:03:09] *** Quits: victorporof (victorporo@79FE7CA6.284D02A8.D111398B.IP) (Quit: victorporof)
[15:03:18] *** Quits: ricepuddin (graham@moz-E8E84882.wlan.ic.ac.uk) (Ping timeout)
[15:03:47] *** Joins: spott (spott@moz-9B11536C.hsd1.co.comcast.net)
[15:04:06] *** Joins: nkoep (nik@moz-E25EFC30.vpn.rwth-aachen.de)
[15:04:28] *** Joins: vmx (vmx@moz-5B6C76B7.dip0.t-ipconnect.de)
[15:05:17] *** kimundi is now known as zz_kimundi
[15:05:30] *** Quits: spott (spott@moz-9B11536C.hsd1.co.comcast.net) (Ping timeout)
[15:08:01] *** Joins: lmandel (lmandel@13F2CEC5.7672369.D8E68FF6.IP)
[15:08:06] *** Joins: ricepuddin (graham@moz-E8E84882.wlan.ic.ac.uk)
[15:09:31] *** Quits: hyunjunekim (Mibbit@7D74E938.F9F187B.FCFA478E.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[15:11:46] *** Quits: fhahn (fhahn@moz-7924DB5C.vie.surfer.at) (Ping timeout)
[15:12:52] *** zz_kimundi is now known as kimundi
[15:13:07] <comex> "The managed box syntax will be replaced by a library type, and a garbage collector is not yet implemented. Consider using the `std::rc::Rc` type for reference counted pointers."
[15:13:18] <comex> any plans to add a rc type with weak references?
[15:13:41] <Jackneill> hey can you help me? not really rust specific though rather in general (http://blog.theincredibleholk.org/blog/2013/11/18/booting-to-rust/)
[15:14:41] <Jackneill> in this article the guy writes an uefi app in rust. the c program has uefi.h and such header files which defines the vars/functions etc so he can use them. but he didnt do anything like that in rust just defined structs etc.
[15:15:00] <Jackneill> (well i dont know rust but curious)
[15:15:12] *** Joins: eholk (eholk@moz-F70D5031.hsd1.in.comcast.net)
[15:15:43] <pnkfelix> Jackneill: eholk is the author of the post, he can probably answer your Q's best.
[15:16:04] <eholk> Jackneill: hi!
[15:16:11] *** Joins: mibbz (Mibbit@moz-169F010D.clienti.tiscali.it)
[15:16:24] <Jackneill> eholk, hey
[15:16:31] <Jackneill> great post by the way
[15:16:35] <eholk> thanks :)
[15:16:54] <Jackneill> so would you explain it?
[15:17:32] <mibbz> Hi, why is it println!("\\{") instead of println!("\{") if I want to print a curly bracket? After all, you write println("\'");
[15:17:32] <eholk> what part?
[15:18:19] <benh> mibbz: because the \' is part of the string literal syntax interpreted by the rust parser, but the \{ is part of the format string interpreted by user-level code
[15:18:27] <Jackneill> eholk, as i said #include <efi.h> #include <efilib.h> you have these in the c program to access uefi related vars/functions
[15:18:43] <benh> you can use raw strings like r"\{"
[15:18:47] *** Quits: ricepuddin (graham@moz-E8E84882.wlan.ic.ac.uk) (Ping timeout)
[15:18:53] <kimundi> rusti: ("\\{", r"\\{")
[15:18:53] -rusti- <anon>:9:18: 9:23 error: expected one of `, )` but found `"\\{"`
[15:18:54] -rusti- <anon>:9          ("\\{", r"\\{")
[15:18:54] -rusti-                            ^~~~~
[15:18:54] -rusti- application terminated with error code 101
[15:19:08] <eddyb> no raw strings in 0.8
[15:19:08] <kimundi> rusti: r"\\{"
[15:19:09] -rusti- <anon>:9:10: 9:15 error: expected one of `; }` but found `"\\{"`
[15:19:09] -rusti- <anon>:9          r"\\{"
[15:19:09] -rusti-                    ^~~~~
[15:19:09] -rusti- application terminated with error code 101
[15:19:09] <Jackneill> but in rust i havent seen anything, but pointers
[15:19:10] <eholk> Jackneill: ah, okay. I just joined the channel so I missed the earlier conversation
[15:19:13] *** Joins: fhahn (fhahn@moz-7924DB5C.vie.surfer.at)
[15:19:14] <kimundi> Oh
[15:19:30] <eholk> Jackneill: so is the question why I'm not using efi.h and efilib.h?
[15:19:37] *** Quits: sk (sk@9E6B574B.EB2AA036.2CAF0D3B.IP) (Ping timeout)
[15:19:55] <Jackneill> eholk, yes, i dont understand how can you access such things without using them
[15:20:00] <eddyb> mibbz: I guess you can compare that case with printf("\\%") - although % is actually used there
[15:20:01] <eholk> oh, I see
[15:20:10] <eddyb> eholk: I left you a comment, did you see it?
[15:20:29] <eholk> eddyb: was that the one about the fully visible path?
[15:20:34] <eddyb> eholk: yupp
[15:20:53] *** Joins: ricepuddin (graham@moz-E8E84882.wlan.ic.ac.uk)
[15:20:57] <eddyb> everything has to be pub, all the way to the function itself. and you need a recent rust (but I think you're using master anyway)
[15:21:06] <eholk> eddyb: yeah! I'm going to try that in a bit. I think that's was the problem; the uefi mod was private
[15:21:29] <eholk> eddyb: and yeah, I'm using master.. actually slightly ahead of master, since master doesn't yet support the calling convention I needed
[15:21:48] <eholk> Jackneill: those header files just define a bunch of structs and function pointer types, and maybe some convenience wrappers around them
[15:21:57] <eddyb> oh, I see, you replied. I wasn't sure I refreshed (I wish the github feed updated itself automatically)
[15:22:11] <Jackneill> eholk, oh i see
[15:22:15] <eholk> Jackneill: I looked at the UEFI spec and recreated these structs using Rust syntax
[15:22:38] <Jackneill> yeah, thanks :)
[15:22:47] <eholk> Ultimately, everything is just pointers and offsets in memory, so you just have to make sure the layout matches
[15:23:26] <comex> i was curious about that. isn't there a way to automatically generate those things from c headers?
[15:23:47] <comex> or no?
[15:24:02] <eholk> eddyb: I'm going to give rust-core a try too. I looked at it briefly but it was late at night and I wanted to get something working quickly without messing with building rust-core and integrating it. I wasn't sure what requirements rust-core had
[15:24:27] <eholk> comex: there's rust-bindgen that is supposed to automatically generate these sorts of things. I didn't try it though, since I don't mind typing
[15:24:53] <eddyb> eholk: you have to use --cfg to enable parts of rust-core that have dependencies
[15:25:06] *** Joins: victorporof (victorporo@79FE7CA6.284D02A8.D111398B.IP)
[15:26:00] <eholk> eddyb: oh, I also had to add #[no_split_stack] all over the place to keep LLVM from adding __morestack calls. This would have infected rust-core too
[15:26:16] <eholk> i don't think this will be necessary for long though
[15:28:28] <mletterle> What do we want to do? PROGRAM IN RUST! When do we want to do it? AFTER WE'RE DONE COMPILING RUST!
[15:29:06] *** kimundi is now known as zz_kimundi
[15:29:37] <eddyb> eholk: you can fake the TLS segment for it, I guess (if you have access to it)
[15:30:13] <eholk> eddyb: yeah... that'd take some assembly programming though, right?
[15:30:32] <eholk> at least, it looks like the TLS goes in a particular register
[15:30:56] <eddyb> inline assembly would do, but you need to make sure it works with UEFI
[15:31:17] <eholk> ahh, right
[15:31:52] <eholk> I guess the right thing to do is write a full-fledged bootloader and get out of the UEFI environment. Then it can do whatever it wants
[15:32:00] *** Joins: peterdn (chatzilla@moz-AAA126C8.vpn.ox.ac.uk)
[15:32:19] <eholk> speaking of inline assembly, the rustc source looks like there's some support for it. Does anyone know how to use it?
[15:32:31] <eddyb> eholk: it's almost like GCC
[15:33:14] *** Joins: lfox (lfox@moz-343B6F0C.nyc.biz.rr.com)
[15:33:45] <Ms2ger> asm!("foo"), iirc
[15:33:47] <eddyb> the TLS actually goes into the GDT as it's a segment register, and I'm afraid UEFI wouldn't like messing with that - unless it already sets the TLS up
[15:34:06] *** Joins: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net)
[15:34:17] *** Joins: autra (augustin@A14DAE84.7F753DD1.EE2CA32B.IP)
[15:34:54] *** Quits: lfox (lfox@moz-343B6F0C.nyc.biz.rr.com) (Ping timeout)
[15:35:25] <eddyb> eholk: oh, I forgot: there's a few tests with "asm" or "assembly" in their name, you can look at those
[15:35:43] *** Joins: ianj (ianjneu@moz-7140CF01.ccs.neu.edu)
[15:35:55] <eholk> ah, cool
[15:36:56] <eddyb> eholk: the actual register constraints aren't translated (like in clang), so "{ax}" is required instead of "a" for al/ax/eax/rax
[15:37:20] <eholk> good to know
[15:37:22] *** Quits: jlong (jlong@moz-6DFDE846.socal.res.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[15:37:24] *** Quits: autra (augustin@A14DAE84.7F753DD1.EE2CA32B.IP) (Ping timeout)
[15:39:12] *** Joins: Skif (emschwar@moz-CA025D57.ip.mcleodusa.net)
[15:39:19] *** Quits: Skif (emschwar@moz-CA025D57.ip.mcleodusa.net) (Client exited)
[15:39:26] *** Joins: sk (sk@6A187949.5A4EAC4.E8ACC090.IP)
[15:39:39] *** Joins: Skif (emschwar@moz-CA025D57.ip.mcleodusa.net)
[15:40:27] <comex> is there a way to prevent an (unsafe) object from being moved around in memory?
[15:41:27] <Sharp> I don't think there's a way to prevent unsafe code from doing anything.
[15:42:33] *** Joins: pnathan1 (Adium@moz-5EBBDD83.tukw.qwest.net)
[15:43:53] <comex> what i mean is that the object (well, struct instance) wants to maintain unsafe pointers to it, so i want to prevent safe code from moving it around
[15:44:02] <comex> i guess it could just be always used through ~
[15:44:25] *** Quits: ricepuddin (graham@moz-E8E84882.wlan.ic.ac.uk) (Ping timeout)
[15:45:53] <Sharp> Oh, I see.  Hm, yeah, I think ~ is probably what you want.
[15:46:03] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[15:46:07] *** Joins: cubic (cubic@moz-80241A3A.mc.videotron.ca)
[15:46:37] *** Joins: ricepuddin (graham@moz-E8E84882.wlan.ic.ac.uk)
[15:48:35] <eholk> comex: I don't think objects in Rust move, except to destroy them
[15:49:14] <eddyb> eholk: it can be copied
[15:49:26] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[15:49:33] <eholk> but the old one would still be there, right?
[15:49:51] <mark_edward> is there an unreachable!() maro?
[15:49:56] *** Quits: arodier74 (Thunderbir@moz-866FC9AA.in-addr.btopenworld.com) (Quit: arodier74)
[15:50:09] <eddyb> eholk: consider this: fn foo() -> Bar {Bar {a: 5, b: 6}}
[15:50:10] <Ms2ger> Yes
[15:50:38] <eddyb> eholk: the function returns, the stack frame is gone, so is the temporary (if you stored it in a local)
[15:51:13] <Sharp> I believe pointers can be moved, which renders them unusable.  But I don't think you can do it without ownership of the pointer.
[15:51:18] <eholk> eddyb: right, hence "except to destroy them"
[15:51:49] <eddyb> eholk: oh, I thought you were talking about dropping
[15:52:01] *** Joins: cdidd (cdidd@moz-BD30B6.broadband.corbina.ru)
[15:52:03] <eholk> ahh, yeah, i guess they're related
[15:52:58] *** Joins: Scriptor (anonymous@moz-E06F46F0.corp.bitshelter.com)
[15:53:25] *** Joins: autra (augustin@A14DAE84.7F753DD1.EE2CA32B.IP)
[15:53:42] *** Quits: cdidd (cdidd@moz-BD30B6.broadband.corbina.ru) (Ping timeout)
[15:54:45] *** Quits: Ms2ger (Ms2ger@moz-454C9175.ugent.be) (Quit: bbl)
[15:55:40] *** Joins: cdidd (cdidd@moz-BD30B6.broadband.corbina.ru)
[15:56:28] *** Quits: ricepuddin (graham@moz-E8E84882.wlan.ic.ac.uk) (Ping timeout)
[15:56:42] *** Quits: amro (quassel@CC16DC52.8AAAF769.FAAB0799.IP) (Ping timeout)
[15:56:55] *** Quits: jfbk (jfbk@moz-EEA9CFB3.nyc.res.rr.com) (Quit: )
[15:57:01] <cmr> mark_edward: yes there is
[15:57:21] <mark_edward> cmr, cool. does it take any arguments?
[15:57:26] <cmr> it just expands to fail!("unreachable") or something like that
[15:57:33] <cmr> mark_edward: it might? I don't remember exactly
[15:57:38] <cmr> You'd have to look inlibsyntax
[15:57:38] <mark_edward> ok
[15:57:45] <mark_edward> i wiill, thanks
[15:58:43] *** Joins: amro (quassel@CC16DC52.8AAAF769.FAAB0799.IP)
[16:00:42] *** Quits: jensnockert (jensnocker@E26F71DB.81840CBC.B0E77544.IP) (Input/output error)
[16:00:48] <eddyb> "error: cannot move out of dereference of & pointer" :(
[16:01:23] *** Quits: dredozubov (dredozubov@2F14E2C1.F70E5FA9.F63E14E8.IP) (Client exited)
[16:01:36] <eddyb> ah nvm I can just not use &
[16:01:46] *** Quits: moostik (Icedove@moz-63ED7231.w82-121.abo.wanadoo.fr) (Ping timeout)
[16:02:51] *** Quits: sk (sk@6A187949.5A4EAC4.E8ACC090.IP) (Quit: Leaving)
[16:03:54] *** Quits: Savago (Savago@D8B9C081.E820043D.D4C04133.IP) (Ping timeout)
[16:05:05] <eddyb> rusti: print!("{:?} ", Some(&5u))
[16:05:07] -rusti- pastebinned 23 lines of output: http://sprunge.us/FaeN
[16:05:14] <eddyb> oh you have to be kidding me
[16:06:12] <eddyb> rusti: let x = Some(&5u); print!("{:?} ", x)
[16:06:13] -rusti- pastebinned 12 lines of output: http://sprunge.us/HePZ
[16:06:17] <eddyb> NOOOOOO
[16:06:55] <eddyb> rusti: let x = Some(&5u); format!("{:?} ", x);
[16:06:57] -rusti- pastebinned 12 lines of output: http://sprunge.us/UKTi
[16:07:30] <eddyb> nmatsakis: my entire stack-using scheme doesn't work :(
[16:08:49] <nmatsakis> eddyb: oh?
[16:09:00] <eddyb> what now, make every node a different stack variable?
[16:09:13] *** Quits: mibbz (Mibbit@moz-169F010D.clienti.tiscali.it) (Quit: http://www.mibbit.com ajax IRC Client)
[16:09:28] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Connection reset by peer)
[16:09:56] *** Joins: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[16:11:01] <comex> why not use ~?
[16:11:56] <eddyb> comex: high-perf code
[16:12:00] *** Joins: edorian (Mibbit@moz-AE169D14.dynamic.qsc.de)
[16:12:14] <nmatsakis> eddyb: I don't fully understand your constraints, so it's hard to say, but an arena is high perf
[16:12:21] <nmatsakis> eddyb: and I believe it solves your particular case and then some
[16:12:31] <comex> doesn't ~ magically use the stack if possible?
[16:12:35] <eddyb> lol no
[16:12:42] <nmatsakis> eddyb: also, aren't you ... auto-generating? what do you care if you put temporary variables?
[16:12:58] <nmatsakis> comex: no, Rust isn't so much about the magic opts, more about exposing things to give you control...
[16:13:06] <nmatsakis> for better or worse
[16:13:13] <eddyb> nmatsakis: hmm, good question. I was hoping it happens automatically :(
[16:13:15] <comex> oh, i thought i had specifically heard that it did that
[16:13:21] <comex> must be thinking of something else
[16:14:06] <eddyb> rusti: let _x = Some(&Some(&5u));
[16:14:08] -rusti- pastebinned 22 lines of output: http://sprunge.us/SeQj
[16:14:18] <nmatsakis> comex: Go does something like that
[16:15:02] <eddyb> this is gunna be ugly
[16:17:26] <bstrie> what was the name of that old blog post on arcs and rwarcs
[16:17:31] <bstrie> like, the original one
[16:17:34] <bstrie> my google-fu is weak
[16:18:10] <bstrie> nm, found it
[16:19:38] *** Joins: FreeFull (freefull@E424A224.387C8A0C.DC9D01B1.IP)
[16:20:09] *** Quits: alonlevy (alon@moz-92551128.red.bezeqint.net) (Ping timeout)
[16:21:55] *** Quits: eholk (eholk@moz-F70D5031.hsd1.in.comcast.net) (Quit: eholk)
[16:23:36] *** Joins: moostik (Icedove@5A22E6A1.10715965.BCDF592F.IP)
[16:23:58] <comex> so if rust already has this way to specify regions, why isn't there a way to explicitly declare a stack region at some point?
[16:24:47] <bstrie> comex: you can
[16:24:58] *** Joins: jeaye (Jeaye@moz-34FEF2BB.hsd1.ca.comcast.net)
[16:25:02] <bstrie> comex: just wrap some code in braces, that becomes a block of its own and hence becomes a region of its own
[16:25:04] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[16:25:26] <comex> and give it a name, so that eddyb could use Some(&'r Some(&'r 5u)) or whatever
[16:25:46] *** Joins: eholk (eric@moz-F70D5031.hsd1.in.comcast.net)
[16:25:54] <eddyb> wait, what, those are regions?
[16:26:02] <comex> no idea
[16:26:22] <comex> i don't know what i'm talking about :)
[16:26:24] <eddyb> I thought regions are an old name for lifetimes
[16:26:28] <bstrie> I'm not an expert, but I think this has more to do with rvalue lifetimes than with regions
[16:26:36] <bstrie> eddyb: yeah, they are
[16:26:58] <bstrie> nmatsakis would be able to tell you if this is an rvalue lifetime problem
[16:27:07] <eddyb> for some reason I was hoping the value is alive for more than one call
[16:28:07] *** Joins: jlong (jlong@moz-6DFDE846.socal.res.rr.com)
[16:28:18] <comex> C can do that :)
[16:29:03] *** Quits: amro (quassel@CC16DC52.8AAAF769.FAAB0799.IP) (Ping timeout)
[16:30:55] *** Joins: amro (quassel@D9E34ACF.8AAAF769.FAAB0799.IP)
[16:32:29] <mark_edward> does any one know KDE Kate syntax stuff? the syntax file in the rust repo is pretty old (no continue, copy is still a keyword, etc)
[16:34:09] <eddyb> mark_edward: not only that, but there's some problems with the style (too custom) which I've fixed locally... I could start a PR, but I'm busy with trying to get this bloody mess of lifetimes work
[16:34:37] <mark_edward> eddyb, sounds bad :-( wish i could help!
[16:35:09] *** Quits: pnathan1 (Adium@moz-5EBBDD83.tukw.qwest.net) (Quit: Leaving.)
[16:35:11] *** Joins: Kruppe (user@moz-3635D059.net.uwaterloo.ca)
[16:35:33] *** Joins: sk (sk@61A494B3.BA40E8A.AAC02D62.IP)
[16:35:50] *** Joins: huseby (huseby@moz-9127FDEC.torservers.net)
[16:37:49] <eddyb> nmatsakis: I can do it with variables... but it will break temporary registers (like the ones used for swap)
[16:38:46] *** Joins: jordyd (jordyd@moz-CD151A8B.seg37.ucf.edu)
[16:39:03] *** zz_kimundi is now known as kimundi
[16:41:26] *** Joins: ricepuddin (graham@moz-EAF6B241.wlan.ic.ac.uk)
[16:41:52] *** Quits: Kruppe (user@moz-3635D059.net.uwaterloo.ca) (Ping timeout)
[16:42:20] *** Joins: w3lcome (Mibbit@moz-177EEEFC.home.otenet.gr)
[16:43:07] *** Quits: w3lcome (Mibbit@moz-177EEEFC.home.otenet.gr) (Quit: http://www.mibbit.com ajax IRC Client)
[16:43:20] *** Joins: w3lcome (Mibbit@moz-177EEEFC.home.otenet.gr)
[16:43:37] *** Joins: sanxiyn (tinuviel@B4104EBB.3CC170B1.1E14B209.IP)
[16:46:41] <sanxiyn> I found that changing BytePos from uint to u32 on x86_64 saves 40 bytes for each Expr.
[16:46:56] <sanxiyn> (from 240 bytes to 200 bytes)
[16:47:12] <cmr> sanxiyn: but we clearly must support > 4GB source files!
[16:47:24] <cmr> sanxiyn: In all seriousness, nice catch
[16:47:34] <benh> maybe we do ought to rename [u]int to [u]intptr to bias people towards the shorter u32
[16:47:52] <sanxiyn> cmr: I have a patch, but doesn't seem to improve peak memory anyway...
[16:48:05] *** Quits: ricepuddin (graham@moz-EAF6B241.wlan.ic.ac.uk) (Ping timeout)
[16:48:21] <cmr> sanxiyn: want me to make a memory usage graph for it?
[16:48:27] <sanxiyn> Yeah
[16:48:30] *** Quits: autra (augustin@A14DAE84.7F753DD1.EE2CA32B.IP) (Quit: by!)
[16:48:38] *** Joins: autra (augustin@A14DAE84.7F753DD1.EE2CA32B.IP)
[16:48:43] <sanxiyn> So... the reason that Expr has ten(10) byte positions inline is:
[16:48:59] *** Joins: ricepuddin (graham@moz-EAF6B241.wlan.ic.ac.uk)
[16:49:21] <sanxiyn> Expression can be a closure expression, which contains function declaration and block inline, and function declaration contains return type inline, and return type can contain type macro which can contain path.
[16:49:41] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[16:49:44] <sanxiyn> So expression has start/end of expression, type, macro, path, and block. That is ten positions.
[16:50:16] <sanxiyn> Does that sound reasonable or should there be an indirection somewhere
[16:50:26] <cmr> sanxiyn: we've previously had substantial wins by inserting a ~ in strategic places
[16:50:34] <sanxiyn> Yes, so question is where
[16:52:26] <cmr> Hm
[16:52:29] <cmr> That's a hairy enum
[16:53:04] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[16:53:35] <sanxiyn> That is: (only span fields annotated)
[16:53:35] <sanxiyn> Expr{node:ExprFnBlock(fn_decl{output:Ty{node:ty_mac(mac{node:mac_invoc_tt(Path{span}),span}),span}},Block{span}),span}
[16:53:43] <mark_edward> eddyb, would you let me know if you ever get around to making that PR?
[16:54:21] <nmatsakis> bstrie: eddyb: sorry, was afk
[16:54:32] <cmr> sanxiyn: maybe it should be ~fn_decl instead?
[16:54:35] *** Quits: canhtak (canhtak@moz-43EC0376.wl.t.ulaval.ca) (Ping timeout)
[16:54:51] *** Joins: dredozubov (dredozubov@6DC2507B.E308AFC8.59EB8DFD.IP)
[16:54:58] <cmr> Though it might help to have all of those Blocks be indirected too
[16:55:01] <sanxiyn> cmr: I thought fn_decl should have ~Ty
[16:55:01] <nmatsakis> comex: I do plan to implement suc a thing (a named lifetime corresponding to a block in the code), but it's not done yet
[16:55:04] <cmr> that's a fairly large struct
[16:55:46] <nmatsakis> also, I agree with bstrie that eddyb's problem is basically #3511, which is a tough nut to crack, though I have a branch working on it -- but it'll be a bit, since I've got a few other things to tidy up first
[16:55:58] <mark_edward> i am happy that rust forces you to use explicit self... reading C# code where the relevant class has 20+ instance variables is hell... the author never uses explicit this
[16:56:38] <eddyb> mark_edward: people complain about explicit this in JS :P
[16:56:50] <nmatsakis> people complain whichever way you do it,
[16:56:53] <nmatsakis> but I side with mark_edward on this
[16:56:56] <cmr> People always complain
[16:56:59] <sanxiyn> cmr: Now... What is ty_mac?!
[16:57:00] <nmatsakis> (unsurprisingly, I guess)
[16:57:02] <cmr> cmr's law
[16:57:04] <sanxiyn> It seems to be unused...
[16:57:14] <cmr> sanxiyn: ty_mac disappears early on
[16:57:26] <nmatsakis> mark_edward: I think you can see evidence for the desirability of explicit self in the everpresent naming conventions like field_ or mField
[16:57:34] <cmr> sanxiyn: or, actually
[16:57:39] <cmr> sanxiyn: it *does* appear to be unused
[16:57:42] <sanxiyn> cmr: I don't see any use whatsoever
[16:57:59] <eddyb> mac is macro, I think
[16:58:04] *** Quits: nkoep (nik@moz-E25EFC30.vpn.rwth-aachen.de) (Ping timeout)
[16:58:09] <mark_edward> nmatsakis, yeah i remember reading arguments and blogposts on that in C++, such a waste of mental energy
[16:58:13] <cmr> sanxiyn: I thought it used to be used to represent macro invocations, but apparently not
[16:58:37] <cmr> like, `let x: foo!()`
[16:58:41] *** Quits: engla (engla@moz-F64E1B0F.cust.bredbandsbolaget.se) (Ping timeout)
[16:59:00] <cmr> But if the parser isn't generating it, it should be removed probably
[16:59:28] <eddyb> grep everywhere
[17:02:09] <sanxiyn> cmr: Doesn't help at all :(
[17:02:21] *** Joins: peterdn_ (chatzilla@moz-30BAAE88.as13285.net)
[17:02:30] *** Joins: Kruppe (user@moz-472689AA.net.uwaterloo.ca)
[17:02:36] *** Quits: peterdn_ (chatzilla@moz-30BAAE88.as13285.net) (Quit: ChatZilla 0.9.90.1-rdmsoft [XULRunner 22.0/20130619132145])
[17:02:41] <sanxiyn> cmr: ast::Ty is still 96 bytes long (even without ty_mac)
[17:02:42] *** Quits: nlminhtl (ignotus@moz-BA3DE7EF.volia.net) (Quit: Konversation terminated!)
[17:02:55] <eddyb> an enum variant won't matter unless it's bigger than every other variant
[17:03:28] <sanxiyn> eddyb: Yup. ty_mac and ty_rptr tie.
[17:03:32] *** Quits: peterdn (chatzilla@moz-AAA126C8.vpn.ox.ac.uk) (Ping timeout)
[17:03:37] <sanxiyn> Because ty_rptr contains Lifetime
[17:04:43] <eddyb> but this sounds like fun - it's what I was looking at this weekend
[17:04:51] *** Joins: spott (spott@moz-9B11536C.hsd1.co.comcast.net)
[17:04:58] <sanxiyn> So... if you want to :) here is how to play
[17:05:05] <sanxiyn> extern mod syntax;
[17:05:09] <sanxiyn> use std::mem;
[17:05:15] <eddyb> hehe
[17:05:21] <SiegeLord> Iirc dmd (D's compiler) doesn't report error spans so it doesn't have to store an extra position, hehe
[17:05:28] <sanxiyn> fn main() { println!("{}", mem::size_of::<syntax::ast::Ty>()); }
[17:05:35] <cmr> SiegeLord: It also doesn't free memory :P
[17:05:39] <sanxiyn> And compile it with RUST_LOG=rustc::middle::trans::adt
[17:05:44] <sanxiyn> That gives you all variants for enums
[17:06:05] <sanxiyn> Replace ast::Ty with other types as you see fit
[17:06:11] *** Joins: nejucomo (Adium@moz-434492BB.dsl.static.sonic.net)
[17:06:14] <eddyb> wanting to implement ..T (where T is a tuple type) expansion wherever a list of types is required (a tuple, function args, generic type params)
[17:06:32] *** Quits: spott (spott@moz-9B11536C.hsd1.co.comcast.net) (Ping timeout)
[17:07:15] <eddyb> now, for generic types, it can actually work to where you can do type TupleWrap<T, U> = (U, ..T, U); and deal with it in typeck/astconv
[17:07:49] *** Joins: maxiepoo_ (Max@moz-FFD7044A.nuwlan.northwestern.edu)
[17:08:11] *** Quits: nejucomo (Adium@moz-434492BB.dsl.static.sonic.net) (Quit: Leaving.)
[17:08:15] <sanxiyn> cmr: Removing ty_mac and fixing #7743 should get us 1 word per type
[17:08:24] <sanxiyn> "easy fix" lol
[17:08:31] <eddyb> but for generic functions, you end up with a (non-AST) ty_generic, which I have to mark as "has DOTDOT before it" and either handle it later or just don't allow creating it (i.e. no generic functions expanding one of their generic type params)
[17:09:03] *** Joins: nejucomo (Adium@moz-434492BB.dsl.static.sonic.net)
[17:09:14] <eddyb> but after I finish this other mess. eh
[17:09:31] <SiegeLord> Not sure how the former approach will work
[17:09:41] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[17:09:45] *** Quits: dredozubov (dredozubov@6DC2507B.E308AFC8.59EB8DFD.IP) (Client exited)
[17:09:47] *** Joins: peterdn (chatzilla@moz-30BAAE88.as13285.net)
[17:10:02] <SiegeLord> Just saying that its expandable doesn't guarantee that it has the right contents
[17:11:38] <eddyb> rusti: trait Foo {} struct NeedsFoo<T: Foo>(T); type Alias<T> = NeedsFoo<T>;
[17:11:39] -rusti- <anon>:9:22: 9:49 error: trait bounds are not allowed in structure definitions
[17:11:39] -rusti- <anon>:9          trait Foo {} struct NeedsFoo<T: Foo>(T); type Alias<T> = NeedsFoo<T>;
[17:11:39] -rusti-                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~
[17:11:39] -rusti- error: aborting due to previous error
[17:11:39] -rusti- application terminated with error code 101
[17:11:47] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[17:11:47] *** ChanServ sets mode: +ao dherman dherman
[17:11:51] <eddyb> hmm?
[17:12:01] *** Joins: alisdair (textual@moz-2F3322CF.hsd1.tx.comcast.net)
[17:12:12] <eddyb> SiegeLord: I guess I should be fine then :P
[17:12:53] <eddyb> (I was afraid Alias would need the bound too, but nah, you can't even have them)
[17:13:44] <eddyb> with some inference, the expansion part of my variadic generics could actually be used for (limited) variadic stuff, but that's not the plan
[17:14:48] <eddyb> (it would be interesting to see, though, as this part doesn't really change the type system, just adds sugar)
[17:15:05] *** Quits: josh (josh@moz-6FB23C25.hvc.res.rr.com) (Quit: josh)
[17:15:11] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[17:16:28] *** Quits: nejucomo (Adium@moz-434492BB.dsl.static.sonic.net) (Quit: Leaving.)
[17:16:45] *** Joins: nkoep (nik@moz-50882FD.pool.mediaways.net)
[17:16:53] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Ping timeout)
[17:17:28] *** Joins: glennsl (textual@moz-5D7B804F.getinternet.no)
[17:17:40] <sanxiyn> 32-bit BytePos patch is here: https://github.com/sanxiyn/rust/commits/bytepos
[17:18:07] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[17:18:37] *** Quits: maxli (maxli@moz-4D28BA20.student.cs.uwaterloo.ca) (Quit: Leaving.)
[17:19:06] *** Joins: dredozubov (dredozubov@6DC2507B.E308AFC8.59EB8DFD.IP)
[17:21:02] *** Quits: tulloch (tulloch@moz-1C33A2E7.nat.csx.cam.ac.uk) (Ping timeout)
[17:21:39] *** Joins: Ms2ger (Ms2ger@92EF86A7.A020F168.187A1082.IP)
[17:22:29] *** Quits: sanxiyn (tinuviel@B4104EBB.3CC170B1.1E14B209.IP) (Quit: Leaving)
[17:23:55] *** Joins: arodier74 (Thunderbir@moz-866FC9AA.in-addr.btopenworld.com)
[17:27:19] *** Joins: Skif_ (emschwar@moz-CA025D57.ip.mcleodusa.net)
[17:27:41] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[17:27:58] *** Quits: Skif (emschwar@moz-CA025D57.ip.mcleodusa.net) (Ping timeout)
[17:29:01] *** Quits: Kxepal (Miranda@moz-E7192F22.pppoe.mtu-net.ru) (Ping timeout)
[17:30:19] *** Joins: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP)
[17:30:57] *** Quits: Skif_ (emschwar@moz-CA025D57.ip.mcleodusa.net) (Client exited)
[17:31:10] *** Joins: tulloch (tulloch@moz-1C33A2E7.nat.csx.cam.ac.uk)
[17:32:11] *** Joins: Skif (emschwar@moz-CA025D57.ip.mcleodusa.net)
[17:33:44] *** Quits: arodier74 (Thunderbir@moz-866FC9AA.in-addr.btopenworld.com) (Ping timeout)
[17:33:44] *** Quits: Kruppe (user@moz-472689AA.net.uwaterloo.ca) (Ping timeout)
[17:33:59] *** Quits: pauls (pauls@moz-7140CF01.ccs.neu.edu) (Ping timeout)
[17:34:53] *** Joins: pauls (pauls@moz-7140CF01.ccs.neu.edu)
[17:35:16] *** Joins: Liothen (liothen@moz-888282BD.spkn.qwest.net)
[17:35:33] *** Joins: Janko (chatzilla@D9AEFC3E.9E37BD61.9C3D12F2.IP)
[17:35:34] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[17:35:37] *** Quits: Skif (emschwar@moz-CA025D57.ip.mcleodusa.net) (Ping timeout)
[17:35:47] *** Quits: PGGB (PGGB@BD9E64E0.2702580D.85889BB1.IP) (Ping timeout)
[17:36:55] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[17:40:07] *** Joins: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net)
[17:40:07] *** ChanServ sets mode: +o tjc
[17:40:24] *** Joins: PGGB (PGGB@BD9E64E0.2702580D.85889BB1.IP)
[17:40:36] *** Quits: Jesse (jruderman@moz-9754CB0.hsd1.ca.comcast.net) (Quit: Jesse)
[17:41:23] *** Quits: edorian (Mibbit@moz-AE169D14.dynamic.qsc.de) (Quit: http://www.mibbit.com ajax IRC Client)
[17:41:27] *** Joins: arodier74 (Thunderbir@moz-866FC9AA.in-addr.btopenworld.com)
[17:43:55] *** Joins: arodier75 (Thunderbir@moz-D6235B0B.in-addr.btopenworld.com)
[17:44:50] *** Quits: arodier74 (Thunderbir@moz-866FC9AA.in-addr.btopenworld.com) (Ping timeout)
[17:44:57] *** Quits: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP) (Client exited)
[17:45:37] *** Quits: Janko (chatzilla@D9AEFC3E.9E37BD61.9C3D12F2.IP) (Client exited)
[17:45:46] *** Joins: azakai (alon@moz-BBE3ABD.mv.mozilla.com)
[17:46:00] *** Joins: ssbr (~ssbr@46FE74EC.C60FE7DC.4065847B.IP)
[17:46:13] *** Quits: dbussink (dbussink@moz-E0A5568C.bussink.me) (Quit: bye)
[17:46:34] *** Joins: dbussink (dbussink@moz-E0A5568C.bussink.me)
[17:47:43] *** Joins: d3xter (sinz@moz-13692240.adsl.highway.telekom.at)
[17:49:06] *** Joins: Janko (chatzilla@D9AEFC3E.9E37BD61.9C3D12F2.IP)
[17:49:09] *** Joins: maxli (maxli@moz-4D28BA20.student.cs.uwaterloo.ca)
[17:50:38] *** Joins: thewonderidiot (mstewart@moz-E41129BA.ipnetworksinc.net)
[17:50:43] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[17:51:42] *** Joins: anri (solancile@moz-E49E7C4B.hsd1.wa.comcast.net)
[17:52:00] *** Quits: nano (nano@moz-74CAD1CA.superkabel.de) (Connection reset by peer)
[17:52:22] *** Quits: CarpNet (ac@moz-FD24B77.sohonet.co.uk) (Quit: Leaving)
[17:52:26] <eholk> does bors automatically restart builds that failed if I push another change?
[17:52:34] *** Joins: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net)
[17:52:42] *** Quits: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net) (Client exited)
[17:52:42] *** Joins: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net)
[17:53:03] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[17:53:03] *** ChanServ sets mode: +ao brson brson
[17:53:28] *** Quits: Ferreus (ferreus@moz-47A3CC18.dip0.t-ipconnect.de) (Ping timeout)
[17:53:28] *** Quits: Ralith (ralith@moz-132F2FD4.sea.wa.customer.broadstripe.net) (Ping timeout)
[17:53:35] *** Quits: alisdair (textual@moz-2F3322CF.hsd1.tx.comcast.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[17:54:38] *** Quits: maxiepoo_ (Max@moz-FFD7044A.nuwlan.northwestern.edu) (Ping timeout)
[17:57:04] <kimundi> eholk: No, you need to get someone to put a new r+ on it
[17:57:31] <eholk> kimundi: ok, thanks.
[17:57:45] <eholk> I updated https://github.com/mozilla/rust/pull/10527 to only test the win64 calling convention on 64-bit machines
[17:57:54] <eddyb> rusti: {let foo = &5u; format!("{:?}", foo)}
[17:57:55] -rusti- ~"&5u"
[17:58:02] <eddyb> how does that work?
[17:58:06] *** Quits: azakai (alon@moz-BBE3ABD.mv.mozilla.com) (Quit: Ex-Chat)
[17:58:10] <eddyb> rusti: {let foo = Some(&5u); format!("{:?}", foo)}
[17:58:12] -rusti- pastebinned 11 lines of output: http://sprunge.us/JaJQ
[17:58:13] *** Joins: azakai (alon@moz-BBE3ABD.mv.mozilla.com)
[17:58:55] <eddyb> rusti: {let x = 5u; let y = Some(&x); format!("{:?}", foo)}
[17:58:56] -rusti- pastebinned 9 lines of output: http://sprunge.us/GTBc
[17:59:09] <eddyb> rusti: {let foo = Some(&5u); format!("{:?}", y)}
[17:59:10] -rusti- pastebinned 9 lines of output: http://sprunge.us/gJSH
[17:59:18] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[17:59:19] <eddyb> wtf is wrong with me?
[17:59:20] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[17:59:20] *** ChanServ sets mode: +ao brson brson
[17:59:26] <eddyb> rusti: {let x = 5u; let y = Some(&x); format!("{:?}", y)}
[17:59:27] -rusti- ~"Some(&5u)"
[17:59:35] <eddyb> hmpf. something like that doesn't work for me
[17:59:53] <eddyb> rusti: {let x = 5u; let y = Some(&x); format!("{:?}", Some(y))}
[17:59:54] -rusti- ~"Some(Some(&5u))"
[17:59:57] *** Quits: w3lcome (Mibbit@moz-177EEEFC.home.otenet.gr) (Quit: http://www.mibbit.com ajax IRC Client)
[18:00:13] *** Joins: maxiepoo_ (Max@moz-FFD7044A.nuwlan.northwestern.edu)
[18:00:15] <eddyb> rusti: {let x = 5u; let y = Some(&x); format!("{:?} {}", Some(y), x)}
[18:00:16] -rusti- ~"Some(Some(&5u)) 5"
[18:01:24] <kimundi> eddyb: How does what work?
[18:01:35] <kimundi> let x = &5; ?
[18:01:37] <myname> shouldn't it?
[18:01:48] *** Joins: boredomist (ruqs@8186917.CC8FA3EE.E3401B6E.IP)
[18:02:13] <eddyb> rusti: fn foo<T>(_: &T){} {let x = 5u; let y = Some(&x); foo(Some(y))}
[18:02:14] -rusti- pastebinned 5 lines of output: http://sprunge.us/HNcg
[18:02:29] <eddyb> rusti: fn foo<T>(_: T){} {let x = 5u; let y = Some(&x); foo(Some(y))}
[18:02:30] -rusti- ()
[18:02:42] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[18:02:44] *** Joins: Savago (Savago@DD39BF48.4D1F54EC.18DDB669.IP)
[18:02:46] <eddyb> well, I don't know. my more complicated example doesn't work, and I have to figure out why
[18:02:57] *** Joins: pcwalton (pcwalton@moz-C07D5168.p2p.sfo1.mozilla.com)
[18:02:57] *** ChanServ sets mode: +ao pcwalton pcwalton
[18:03:45] <kimundi> eddyb: What is strange? I don't see anything unusual here
[18:04:20] <eddyb> here, because I was trying to simply it
[18:04:26] *** Quits: Savago (Savago@DD39BF48.4D1F54EC.18DDB669.IP) (Quit: Savago)
[18:05:37] *** Joins: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com)
[18:06:02] <eddyb> kimundi: I think it's related to the lifetime of self in my case. pffft
[18:06:08] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[18:06:45] *** Joins: gandalf (zbraniecki@moz-DFAA4E15.p2p.sfo1.mozilla.com)
[18:10:21] *** Joins: lfox (lfox@moz-343B6F0C.nyc.biz.rr.com)
[18:11:30] <eddyb> rusti: fn foo<'a>(_: Option<&'a uint>) {} {let x = 5u; let y = Some(&x); foo(y)}
[18:11:30] -rusti- ()
[18:11:51] *** Joins: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP)
[18:13:42] <eddyb> rusti: struct Foo<'self>(&'self uint); impl<'self> Foo<'self> {fn bar<'a>(&self, _: Option<&'a uint>) {}} let foo = Foo(&6u); {let x = 5u; let y = Some(&x); foo.bar(y)}
[18:13:44] -rusti- pastebinned 12 lines of output: http://sprunge.us/dYQN
[18:14:25] <eddyb> rusti: struct Foo<'self>(&'self uint); impl<'self> Foo<'self> {fn bar<'a>(&self, _: Option<&'a uint>) {}} let a = 6u; let foo = Foo(&a); {let x = 5u; let y = Some(&x); foo.bar(y)}
[18:14:25] -rusti- ()
[18:14:33] <eddyb> how does that work and mine doesn't >:(?
[18:15:11] <dredozubov> can someone explain to me this syntax: `impl<K:Hash + Eq,V> Map<K, V>`?
[18:15:37] <cmr> dredozubov: It's a parametric implementation
[18:15:43] *** Quits: KindOne (KindOne@moz-37B61578.dynamic.ip.windstream.net) (Ping timeout)
[18:15:58] <cmr> That is, an implementation of the trait Map for a type K which implements Hash and Eq, and any type V
[18:16:08] <cmr> s/for/given/
[18:17:46] <dredozubov> hmmm
[18:18:12] <dredozubov> can you explain why is `K:Hash + Eq,V` matter too?
[18:18:28] <dredozubov> you can declare it without this part, no?
[18:18:35] <cmr> No, it wouldn't be the same.
[18:18:50] <cmr> By putting those there, you make the *implemenetation itself* generic over those types.
[18:18:58] <kimundi> YOu could not use the methods of Hash and Eq without those bounds
[18:19:28] *** Joins: KindOne (KindOne@moz-18AC024A.dynamic.ip.windstream.net)
[18:19:32] <dredozubov> oh, i think i'm beginning to understand
[18:19:37] <dredozubov> thx
[18:20:13] *** Joins: Savago (Savago@D8B9C081.E820043D.D4C04133.IP)
[18:20:16] *** Quits: maxiepoo_ (Max@moz-FFD7044A.nuwlan.northwestern.edu) (Quit: maxiepoo_)
[18:20:24] *** Joins: jxv (jxv@moz-8FB92450.lightspeed.irvnca.sbcglobal.net)
[18:21:32] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[18:22:04] *** Joins: infynyxx_ (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[18:22:04] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Connection reset by peer)
[18:23:16] *** Quits: BossKonaSegway (Michael@moz-2986F42D.col.wideopenwest.com) (Ping timeout)
[18:23:34] *** Joins: voxpopuli (fanservice@moz-FE161659.wv.cc.cmu.edu)
[18:23:34] *** Joins: maxiepoo_ (Max@moz-FFD7044A.nuwlan.northwestern.edu)
[18:24:02] *** Quits: autra (augustin@A14DAE84.7F753DD1.EE2CA32B.IP) (Ping timeout)
[18:24:07] *** Joins: BossKonaSegway (Michael@moz-2986F42D.col.wideopenwest.com)
[18:24:47] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[18:25:16] *** Quits: maxiepoo_ (Max@moz-FFD7044A.nuwlan.northwestern.edu) (Ping timeout)
[18:26:21] *** Quits: pcwalton (pcwalton@moz-C07D5168.p2p.sfo1.mozilla.com) (Ping timeout)
[18:26:56] *** Joins: maxiepoo_ (Max@moz-FFD7044A.nuwlan.northwestern.edu)
[18:27:54] *** Joins: alonlevy (alon@moz-EB7C9CF3.telavivmakers.org)
[18:28:25] *** Quits: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP) (Client exited)
[18:28:36] *** Joins: pcwalton (pcwalton@moz-DFAA4E15.p2p.sfo1.mozilla.com)
[18:28:36] *** ChanServ sets mode: +ao pcwalton pcwalton
[18:30:34] *** Quits: amro (quassel@D9E34ACF.8AAAF769.FAAB0799.IP) (Client exited)
[18:31:40] *** Joins: Ralith (ralith@A8995AA9.62B6AF6A.922221DB.IP)
[18:32:39] *** Joins: Palmik (palmik@moz-DEC2AB.pks.muni.cz)
[18:33:00] *** Quits: dredozubov (dredozubov@6DC2507B.E308AFC8.59EB8DFD.IP) (Client exited)
[18:33:24] <eddyb> rusti: enum L<'self>{Cons(&'self L), Nil}; impl<'self> L<'self> {fn bar<'a>(&self, _: L<'a>) {}} let a = Nil; let b = Cons(&a); {let x = Nil; let y = Cons(&x); b.bar(y)}
[18:33:26] -rusti- pastebinned 5 lines of output: http://sprunge.us/LRKN
[18:33:44] <eddyb> rusti: enum L<'self>{Cons(&'self L<'self>), Nil}; impl<'self> L<'self> {fn bar<'a>(&self, _: L<'a>) {}} let a = Nil; let b = Cons(&a); {let x = Nil; let y = Cons(&x); b.bar(y)}
[18:33:45] -rusti- ()
[18:33:48] <eddyb> oh ffs
[18:34:05] <eddyb> rusti: enum L<'self>{Cons(&'self L<'self>), Nil}; impl<'self> L<'self> {fn bar<'a>(&self, _: L<'a>) {}} let a = Nil; let b = Cons(&a); {let x = Nil; let y = Cons(&x); b.bar(Cons(&y))}
[18:34:06] -rusti- ()
[18:34:24] <eddyb> but that's pretty much what I have :(
[18:35:16] *** Joins: mcarberry_ (mcarberry@moz-BE1C9F3F.lightspeed.frokca.sbcglobal.net)
[18:35:32] <eddyb> nmatsakis: I don't want to waste your precious time, but... for some reason I can't call self.op from an inner block - with this definition: fn op<'a>(&self, stmt: Stmt<'a>);
[18:35:59] *** Quits: Savago (Savago@D8B9C081.E820043D.D4C04133.IP) (Ping timeout)
[18:36:00] <eddyb> nmatsakis: it wants the (stmt) argument to be live for the entirety of its parent function
[18:36:01] *** Quits: mcarberry_ (mcarberry@moz-BE1C9F3F.lightspeed.frokca.sbcglobal.net) (Quit: Leaving)
[18:36:03] *** Quits: tulloch (tulloch@moz-1C33A2E7.nat.csx.cam.ac.uk) (Ping timeout)
[18:39:36] *** Quits: glennsl (textual@moz-5D7B804F.getinternet.no) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[18:39:55] *** Quits: mrshankly (mrshankly@3EE34383.CE0EEBAE.806C54C8.IP) (Ping timeout)
[18:40:27] *** Joins: tulloch (tulloch@moz-6809CC86.nat.csx.cam.ac.uk)
[18:40:29] *** Joins: mrshankly (mrshankly@3EE34383.CE0EEBAE.806C54C8.IP)
[18:42:15] *** Joins: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP)
[18:42:28] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Quit: Leaving...)
[18:44:31] *** Joins: willingc (willingc@moz-B4760708.san.res.rr.com)
[18:44:44] <eddyb> wait, maybe I have to change the parent function
[18:45:09] *** Quits: lmandel (lmandel@13F2CEC5.7672369.D8E68FF6.IP) (Quit: lmandel)
[18:45:42] <kimundi> dbaupp: Err, do you also see a mess of html tags here? 10565
[18:45:49] <kimundi> https://github.com/mozilla/rust/issues/10565
[18:46:33] *** Parts: rootnode (rootnode@moz-7FAB5E8.ip1.george24.com) (Leaving)
[18:46:53] *** Quits: vmx (vmx@moz-5B6C76B7.dip0.t-ipconnect.de) (Quit: Leaving)
[18:46:58] <cmr> kimundi: no? http://i.imgur.com/r9ULY1m.png
[18:47:21] *** Joins: lmandel (lmandel@13F2CEC5.7672369.D8E68FF6.IP)
[18:47:23] *** Quits: Ms2ger (Ms2ger@92EF86A7.A020F168.187A1082.IP) (Quit: Leaving)
[18:47:44] <kimundi> hu, now it works too here
[18:47:49] <eddyb> rusti: enum L<'self>{Cons(&'self L<'self>), Nil}; impl<'self> L<'self> {fn bar<'a>(&self, _: L<'a>) {} fn baz(&self) { {let x = Nil; let y = Cons(&x); self.bar(Cons(&y))}}} let a = Nil; let b = Cons(&a); b.baz();
[18:47:50] -rusti- ()
[18:47:53] <cmr> github seems to be having some issues today
[18:48:13] <cmr> eddyb: keep in mind that rusti is running 0.8 and things *have* changed since
[18:48:14] <eddyb> that code doesn't work for me >_>
[18:48:22] <cmr> I'm pretty sure the borrow checker got more strict
[18:48:22] <eddyb> cmr: more restrictions?
[18:48:27] <eddyb> ahh dammit
[18:49:13] <eddyb> well, presume it complains about &x not being alive for the entire fn baz (because it's in an inner block) - what do I need to do?
[18:49:49] <jorendorff> Does the rust runtime really not kick off multiple threads? I thought it did a thread per cpu.
[18:50:07] <cmr> jorendorff: there are threads, but they're internal to libuv.
[18:50:20] <jorendorff> so but the main scheduler
[18:50:21] <cmr> jorendorff: It won't schedule tasks on multiple threads; you need spawn_sched for that.
[18:50:46] <cmr> eddyb: that code *does* work for me
[18:50:51] <brson> jorendorff: the scheduler creates a thread per core
[18:50:56] <cmr> eddyb: rustc 6c8b702
[18:50:59] <eddyb> cmr: crap, so it's not yet complete :(
[18:51:04] <cmr> brson: wait it does?
[18:51:11] <eddyb> what else do I need to add to make it fail :(
[18:51:13] <cmr> brson: has this changed?
[18:51:56] <eddyb> rusti: enum L<'self>{Cons(&'self L<'self>), Nil}; impl<'self> L<'self> {fn bar(&self, _x: L<'self>) {} fn baz(&self) { for i in range(0, 50) {let x = Nil; let y = Cons(&x); self.bar(Cons(&y))}}} let a = Nil; let b = Cons(&a); b.baz();
[18:51:58] -rusti- pastebinned 4 lines of output: http://sprunge.us/CNah
[18:52:17] <brson> cmr: it hasn't changed, no. by default we create a thread per core, controlled by RUST_THREADS, schedule tasks on those, and do nothing on the main thread
[18:52:28] <eddyb> cmr: ^ does that work for you? wait, I'm an idiot, I can check myself >_>
[18:52:47] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[18:52:54] <cmr> brson: hrm, so what was spawn_sched for? I feel lost now..
[18:52:59] *** Quits: jxv (jxv@moz-8FB92450.lightspeed.irvnca.sbcglobal.net) (Ping timeout)
[18:53:31] <brson> the only thing spawn_sched does now is spawn_sched(SingleThreaded), which creates a new task with its own dedicated thread
[18:53:31] *** Quits: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP) (Client exited)
[18:53:39] *** Joins: nano (nano@moz-74CAD1CA.superkabel.de)
[18:53:40] <kimundi> cmr: spawn_sched is for spawning additional threads
[18:53:57] <brson> it's not named all that well anymore
[18:54:00] <brson> it used to do lots of other stuff
[18:54:12] <cmr> yeah, that's what I remember. I suppose that was the old scheduler?
[18:54:22] <brson> yes
[18:54:25] <cmr> ok
[18:57:12] *** Quits: maxiepoo_ (Max@moz-FFD7044A.nuwlan.northwestern.edu) (Quit: maxiepoo_)
[18:57:47] <eddyb> rusti: enum L<'self>{Cons(&'self L<'self>), Nil} trait Foo<'self> {fn bar(&'self self, _: &'self L<'self>); fn baz(&'self self) { for _ in range(0, 50) {let x = Nil; let y = Cons(&x); self.bar(&Cons(&y))}}}
[18:57:48] -rusti- ()
[18:58:16] <eddyb> but... my code doesn't work >_<
[18:58:47] *** Quits: Janko (chatzilla@D9AEFC3E.9E37BD61.9C3D12F2.IP) (Quit: ChatZilla 0.9.90.1 [Firefox 28.0a1/20131119030202])
[18:58:58] <cmr> eddyb: mind gisting it? a second eye can be helpful :)
[18:59:23] *** Quits: eholk (eric@moz-F70D5031.hsd1.in.comcast.net) (Quit: Konversation terminated!)
[18:59:26] *** Quits: tulloch (tulloch@moz-6809CC86.nat.csx.cam.ac.uk) (Ping timeout)
[18:59:52] *** Joins: maxiepoo_ (Max@moz-FFD7044A.nuwlan.northwestern.edu)
[19:01:29] *** Quits: heftig (heftig@moz-4353C6FC.dip0.t-ipconnect.de) (Ping timeout)
[19:02:38] <eddyb> wait, it only fails for the second line
[19:03:26] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[19:03:42] *** Joins: heftig (heftig@moz-4994C5AA.dip0.t-ipconnect.de)
[19:04:01] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[19:04:01] *** ChanServ sets mode: +o pnkfelix
[19:04:51] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[19:05:17] <eddyb> cmr: https://gist.github.com/eddyb/7ee6cad98bb5875e5e2b#file-arch-8051-rs-L1620
[19:05:24] *** Quits: nsf (nsf@moz-EEF3238A.convex.ru) (Quit: WeeChat 0.4.2)
[19:06:49] <eddyb> cmr: it doesn't complain about the line above that one
[19:07:02] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[19:07:30] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[19:07:30] *** ChanServ sets mode: +o pnkfelix
[19:08:17] *** Joins: Skif (emschwar@moz-CA025D57.ip.mcleodusa.net)
[19:08:20] *** Joins: jxv (jxv@moz-8FB92450.lightspeed.irvnca.sbcglobal.net)
[19:08:24] <cmr> eddyb: can you generate denser lines? :P
[19:08:44] *** Joins: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP)
[19:08:52] <wycats_> acrichto: am I here?
[19:08:59] <wycats_> marco... polo...
[19:09:04] <wycats_> unsure if my internet is working
[19:09:09] <eddyb> http://www.matmartinez.net/nsfw/
[19:09:14] <eddyb> cmr: oh, I can remove all whitespace :P
[19:09:25] <eddyb> (would make it easier to for librustc to parse)
[19:09:32] <cmr> wycats_: you are here!
[19:09:34] <ofeldt> wycats_, pong.
[19:09:38] <wycats_> I AM HERE
[19:09:40] <wycats_> wheee
[19:09:44] <jorendorff> brson: If I run without setting RUST_THREADS, I don't seem to get multiple threads (no parallel speedup)
[19:10:20] *** Joins: bkircher (bkircher@5D6D2116.9EAAC4DA.BFC1059F.IP)
[19:11:51] <jorendorff> argh, i think i'm using an old rustc by accident
[19:11:55] <cmr> eddyb: hm, that seems quite weird
[19:12:09] <cmr> eddyb: I can't decipher this lifetime error either
[19:12:12] <eddyb> cmr: you're trying to compile it?
[19:12:27] <cmr> eddyb: try? there is no try: only do, or do not
[19:12:35] <cmr> Unfortunately, this was a case of "do not"
[19:12:53] <eddyb> I mean, have you seen the actual error? it sounds like you have :P
[19:12:54] *** Joins: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP)
[19:12:56] <cmr> Yes
[19:13:13] <cmr> https://gist.github.com/cmr/7e7ed5a44eace32cbd46
[19:13:17] <eddyb> why must it be valid?
[19:13:38] *** Quits: maxiepoo_ (Max@moz-FFD7044A.nuwlan.northwestern.edu) (Quit: maxiepoo_)
[19:14:08] <eddyb> cmr: hey, your error is nicer than mine
[19:14:15] <eddyb> that's what I get for not updating
[19:14:19] *** Joins: nejucomo (Adium@9F0867A2.BB950596.DFB232DA.IP)
[19:14:27] *** Joins: maxiepoo_ (Max@moz-FFD7044A.nuwlan.northwestern.edu)
[19:15:02] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[19:15:03] *** ChanServ sets mode: +ao dherman dherman
[19:15:09] *** Joins: autra (augustin@moz-BE76895F.fbx.proxad.net)
[19:15:17] <eddyb> cmr: what about fn dis<'a>(&'a self ...?
[19:15:42] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[19:15:47] <cmr> No change
[19:16:29] <cmr> I think it might be infering a bad lifetime for the Expr's you're constructing
[19:16:39] *** Quits: myname (myname@F6BC1CBC.2C5F047.A0197E77.IP) (Ping timeout)
[19:17:02] <eddyb> cmr: it doesn't even replace &'self in the error?
[19:17:07] <cmr> eddyb: no
[19:17:15] <eddyb> it must be a combination of ctx/get_ctx and op
[19:17:37] <cmr> nmatsakis might be able to scry these runes, but I cannot
[19:17:46] *** Quits: pcwalton (pcwalton@moz-DFAA4E15.p2p.sfo1.mozilla.com) (Quit: pcwalton)
[19:17:47] *** Quits: maxiepoo_ (Max@moz-FFD7044A.nuwlan.northwestern.edu) (Quit: maxiepoo_)
[19:17:53] <nmatsakis> what's up?
[19:18:08] <eddyb> because it doesn't complain on a line without RegExpr - wait, your error is different
[19:18:15] <eddyb> /o\
[19:18:15] *** Joins: pcwalton (pcwalton@moz-C07D5168.p2p.sfo1.mozilla.com)
[19:18:16] *** ChanServ sets mode: +ao pcwalton pcwalton
[19:18:29] <eddyb> nmatsakis: &'FUN
[19:18:32] <wycats_> so I'm running into some mutability issues:
[19:18:33] <wycats_> https://gist.github.com/wycats/a2677060c29aff2ce4e0#file-annotation_builder-rs-L14-L35
[19:18:46] <wycats_> this structure isn't the first thing I tried, if it horrifies you guys ;)
[19:19:39] <nmatsakis> wycats_: what's the problem?
[19:20:06] <nmatsakis> eddyb: going to need more details :) 
[19:20:13] <wycats_> https://gist.github.com/wycats/a2677060c29aff2ce4e0
[19:20:21] <wycats_> https://gist.github.com/wycats/a2677060c29aff2ce4e0#file-output-txt
[19:20:32] *** Quits: bkircher (bkircher@5D6D2116.9EAAC4DA.BFC1059F.IP) (Client exited)
[19:20:40] <cmr> nmatsakis: eddyb: I'm minimizing now
[19:20:42] <eddyb> cmr: maybe the .value(self)? it doesn't change anything over here, but I'm too outdated it seems
[19:20:55] <eddyb> cmr: you can remove a lot of stuff, one case is enough
[19:21:04] <nmatsakis> wycats_: what is def'n of trace module? I think you might be about to hit a known bug I've actually been working on fixing :)
[19:21:11] <wycats_> nmatsakis: hehe
[19:21:16] <eddyb> I could possibly do it, but I experiment by changing the generator code
[19:21:35] <wycats_> trace is big, but you just want the Annotation enum right?
[19:22:27] *** Quits: ricepuddin (graham@moz-EAF6B241.wlan.ic.ac.uk) (Ping timeout)
[19:23:18] *** Quits: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP) (Client exited)
[19:24:02] <cmr> nmatsakis: http://ix.io/95a
[19:24:11] <cmr> nmatsakis: it's... quite large, but the error should be self-contained
[19:24:27] <cmr> nmatsakis: https://gist.github.com/cmr/f86873af43b6d8282aa5
[19:24:51] *** Quits: moostik (Icedove@5A22E6A1.10715965.BCDF592F.IP) (Quit: moostik)
[19:25:04] <wycats_> nmatsakis: https://gist.github.com/wycats/a2677060c29aff2ce4e0#file-trace-rs
[19:25:30] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[19:26:15] <nmatsakis> wycats_: ah, I see, so problem is here https://gist.github.com/wycats/a2677060c29aff2ce4e0#file-annotation_builder-rs-L30 : why do you have `&mut &Annotation`?
[19:26:35] <nmatsakis> wycats_: that says "a mutable ponter to an immutable pointer" -- so you can change which pointer you are using, but not contents of the pointer
[19:26:35] *** Joins: myname (myname@F6BC1CBC.2C5F047.A0197E77.IP)
[19:26:38] <nmatsakis> cmr: ok
[19:26:51] <wycats_> nmatsakis: I tried many variations ;)
[19:26:52] <wycats_> which one is correct?
[19:26:59] * wycats_ is in "keep hacking on it" mode :( :( :(
[19:27:01] <eddyb> and mut and Annotation. inb4 rustc --pretty rap
[19:27:41] <wycats_> eddyb: I cannot parse that
[19:28:02] <nmatsakis> wycats_: you want &mut Annotation
[19:28:07] <wycats_> nmatsakis: I believe that failed
[19:28:09] <wycats_> lemme try again
[19:28:22] <nmatsakis> wycats_: nonetheless it's prob what you want, lemme know how and we'll go from there :)
[19:28:40] <wycats_> mismatched types: expected `&mut annotation_builder::skylight::Annotation` but found `&mut &annotation_builder::skylight::Annotation` (expected struct annotation_builder::skylight::Annotation but found &-ptr)
[19:28:52] <wycats_> nmatsakis: :)
[19:29:07] <nmatsakis> eddyb: it seems that you are getting an error simply because you are allocated data on the stack and then trying to return it to the caller -- I guess it depends what `op()` does
[19:29:08] <pnkfelix> cmr: when you do self.op, aren't you saying you'll pass it an argument with a lifetime of 'self (as in Disasm<'sefl> ?
[19:29:14] <nmatsakis> wycats_: where does that error occur?
[19:29:24] <pnkfelix> cmr: as in the call self.op(Mov(_1, _3));
[19:29:25] <wycats_> add_value(&mut self.annotations[index].mut_nested().last(), value);
[19:29:41] <nmatsakis> eddyb: by "return it to the caller" I mean: "invoke self.op() with the lifetime 'self" -- which says the data will live for th elifetime 'self, but that is not true
[19:29:52] <pnkfelix> cmr: while you are also feeding in arguments that only live as long as the block ?
[19:29:53] *** Joins: moostik (Icedove@5A22E6A1.10715965.BCDF592F.IP)
[19:29:53] <nmatsakis> eddyb: and that would allow e.g. self.op to store that data into a field or something that would outlive the stack frame
[19:29:58] <wycats_> mut_nested() returns a &'self mut ~[skylight::Annotation]
[19:30:09] <nmatsakis> eddyb: you probably want op to have signature of fn op<'a>(&self, Expr<'a>)
[19:30:13] <wycats_> (its body is `&mut self.nested`)
[19:30:16] <nmatsakis> pnkfelix and I are saying the same thing I think
[19:30:30] <nmatsakis> wycats_: the problem is that `last()` returns an immutable pointer
[19:30:38] <wycats_> nmatsakis: but there is no mut_last()
[19:30:45] <pnkfelix> nmatsakis: (oh did you already respond to cmr?)
[19:30:46] <wycats_> which is why I was trying to &mut
[19:30:50] <wycats_> which I guess I can't do
[19:30:54] <cmr> pnkfelix: I'm merely channeling eddyb atm
[19:31:00] <wycats_> I put &mut in front in hopes that it would become mutable :P :P :P
[19:31:01] <wycats_> silly me
[19:31:01] <eddyb> nmatsakis: already tried that, doesn't change anything :(
[19:31:04] <nmatsakis> wycats_: embarassingly we don't have a mut_last(), yes, so you can write a helper
[19:31:11] <pnkfelix> cmr: Ah I see.
[19:31:12] <nmatsakis> eddyb: I doubt htat.
[19:31:16] <wycats_> nmatsakis: what would mut_last() look like?
[19:31:20] <nmatsakis> eddyb: you presumably got a different error
[19:31:23] <eddyb> cmr: can you test that change on op?
[19:31:28] <cmr> eddyb: sure
[19:31:32] <eddyb> I really need to update
[19:31:45] <nmatsakis> wycats_: fn mut_last<'a, T>(x: &'a mut [T]) -> &'a T { &mut x[x.len() - 1] }
[19:31:47] <cmr> eddyb: and with that change it compiles!
[19:31:51] <nmatsakis> er
[19:31:51] <eddyb> nmatsakis: I've tried much more than just that change (which was the first lifetime-related thing I tried anyway :P)
[19:31:55] <cmr> Makessense, actually.
[19:31:57] <eddyb> okay, it's my old rust
[19:31:57] <nmatsakis> wycats_: fn mut_last<'a, T>(x: &'a mut [T]) -> &'a mut T { &mut x[x.len() - 1] }
[19:32:01] <cmr> guh netbook keyboard
[19:32:02] <eddyb> be back in a few hours :(
[19:32:08] <nmatsakis> eddyb: I'm not saying that alone will fix it, I'm saying that is your *immediate* problem :)
[19:32:10] <eddyb> cmr, nmatsakis: thanks a lot
[19:32:58] <eddyb> nmatsakis: I wasn't getting different errors, and I get an error for the second match case, but not for the first (like cmr), so it's just my local rusty rust
[19:32:59] <wycats_> nmatsakis: why does &mut foo[bar] work but not &mut foo.last()?
[19:33:05] * wycats_ is so bad at Rust :P
[19:33:12] <wycats_> I need to get mut straight
[19:33:18] <eddyb> (&mut foo).last() maybe?
[19:33:21] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Client exited)
[19:33:31] <eddyb> and foo shouldn't be &
[19:33:33] <nmatsakis> wycats_: &mut foo[bar] --> take address of element bar of foo
[19:33:40] <nmatsakis> wycats_: last() is equivalent to &foo[foo.len() - 1]
[19:33:46] <wycats_> so it's too late?
[19:33:46] <eddyb> ah nvm
[19:33:48] <nmatsakis> wycats_: so &mut foo.last() ==> &mut &foo[foo.len() - 1]
[19:33:57] <wycats_> so we really need mut_last
[19:34:01] <nmatsakis> yes.
[19:34:05] <eddyb> I want last<mut> :-<
[19:34:21] <eddyb> (and maybe inferrable. maybe)
[19:34:27] <nmatsakis> wycats_: we've been trying to avoid parameterizing over mutability, but it means a split in the set of methods -- last, mut_last etc
[19:34:36] <wycats_> nmatsakis: yeah it's not ideal
[19:34:42] <wycats_> it creates a combinatorial explosion
[19:34:47] *** Joins: tulloch (tulloch@moz-1C33A2E7.nat.csx.cam.ac.uk)
[19:34:48] <cmr> eddyb: & and &mut are sufficiently different that being generic over mutability restricts you very much
[19:35:11] <wycats_>  error: mismatched types: expected `&mut [<V8>]` but found `&mut ~[annotation_builder::skylight::Annotation]` (expected vector but found &-ptr)
[19:35:16] <wycats_> what is V8?
[19:35:18] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[19:35:55] *** Joins: b3kf (b3kf@moz-5C189D89.red.bezeqint.net)
[19:36:12] <nmatsakis> wycats_: that is a type inference artifact
[19:36:17] <b3kf> hi there. i think there is a problem in the documents: http://static.rust-lang.org/doc/master/tutorial.html#closures
[19:36:32] <nmatsakis> wycats_: in other words, a type we are trying to infer -- where are you getting that error?
[19:36:34] <b3kf> the do each and each examples are out of date. aren't they
[19:37:23] <b3kf> or i have to declare the each function and then it will work
[19:37:23] <wycats_> add_value(mut_last(self.annotations[index].mut_nested()), value);
[19:37:35] <wycats_> the arrow is pointing at the contents of mut_last
[19:38:42] <nmatsakis> wycats_: ah. yes, I see. The problem is that mut_nested returns a pointer to a vector, but mut_last expects a vector.  You can either change to: add_value(mut_last(*self.annotations[index].mut_nested()), value),
[19:38:49] *** Quits: pcwalton (pcwalton@moz-C07D5168.p2p.sfo1.mozilla.com) (Quit: pcwalton)
[19:39:06] <nmatsakis> wycats_: or change mut_last (since it's onyl used here) to: fn mut_last<'a,T>(x: &'a mut ~[T]) -> &'a mut T...
[19:39:42] *** Quits: barosl (barosl@3DE683B6.E551553C.7544CABF.IP) (Ping timeout)
[19:39:54] <nmatsakis> wycats_: pointers. fun. this is partly an artifact of using a standalone fn, in a method call we deref away all pointers...
[19:40:01] <eddyb> does the name "move" make sense for a method on Expr<'self> which returns an equivalent Expr<'a>, only for the variants without a reference (and either an Unknown or a failure if self is a variant with a nested reference)?
[19:40:16] <wycats_> error: mismatched types: expected `&mut ~[<V10>]` but found `~[annotation_builder::skylight::Annotation]` (expected &-ptr but found vector)
[19:40:36] <wycats_> from the contents of add_value
[19:40:48] <nmatsakis> wycats_: what'd you change? adding the `*`?
[19:40:53] <eddyb> I feel like I'm writing parts of a compiler here... and it's just the disasm of a decompiler :P
[19:41:03] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[19:42:00] <wycats_> fn mut_last<'a, T>(x: &'a mut ~[T]) -> &'a mut T { &mut x[x.len() - 1] }
[19:42:16] <kimundi> SOmeone remind me again why we don'T support fall-through in match ?
[19:42:32] <nmatsakis> kimundi: bindings?
[19:43:11] <eddyb> I wish I didn't have to compute the presence of a fall-through in my codegen :P
[19:43:27] <kimundi> Well, we already support multible bindings per pattern arm
[19:43:29] <nmatsakis> wycats_: sorry, can you gist up the relevant code? I feel like I'm confused as to what the current state is.
[19:43:33] <kimundi> match ... {}
[19:43:34] *** Joins: pcwalton (pcwalton@moz-C07D5168.p2p.sfo1.mozilla.com)
[19:43:34] *** ChanServ sets mode: +ao pcwalton pcwalton
[19:43:45] <nmatsakis> kimundi: I guess I don't know whta you mean by "fall through" -- from arm to arm?
[19:43:46] <eddyb> oh nvm, I was thinking of a different fall-through
[19:43:48] <kimundi> match ... { A(b) | B(b) | C(b) => ... }
[19:43:50] <wycats_> nmatsakis: no I changed the function
[19:43:59] *** Quits: jdm (jdm@moz-ED0C7AC7.hinet-ip.hinet.net) (Ping timeout)
[19:44:02] <wycats_> nmatsakis: sorry
[19:44:29] <kimundi> nmatsakis: yeah, though... I guess I keep forgetting that thta would be the same as jsut enumerating a number of patterns seperated by | ... :P
[19:45:37] <wycats_> nmatsakis: https://gist.github.com/5eca43df0fe71c135509
[19:45:39] *** Joins: carter (carter@moz-BDFE46F6.nyc.biz.rr.com)
[19:45:39] *** Quits: voxpopuli (fanservice@moz-FE161659.wv.cc.cmu.edu) (Ping timeout)
[19:45:44] *** Joins: Purrr (Darkstar@moz-3FB542EB.a176.priv.bahnhof.se)
[19:45:45] <kimundi> nmatsakis: Being able to define the same match arm for multible pattern guards would be nice I guess
[19:45:54] <nmatsakis> wycats_: and error?
[19:46:05] <nmatsakis> wycats_: also, what is def'n of mut_nested()?
[19:46:24] <wycats_> annotation_builder.rs:20:18: 20:65 error: mismatched types: expected `&mut annotation_builder::skylight::Annotation` but found `&mut ~annotation_builder::skylight::Annotation` (expected struct annotation_builder::skylight::Annotation but found ~-ptr)
[19:46:24] <wycats_> annotation_builder.rs:20         add_value(mut_last(self.annotations[index].mut_nested()), value);
[19:46:38] <kimundi> match foo { A if a() =v B if b() => { ... }} // With the a case calling the same block as the B case
[19:47:07] *** Joins: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP)
[19:47:10] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[19:47:12] <kimundi> (looks better on seperate lines)
[19:47:24] *** Joins: nejucomo1 (Adium@moz-B62B9944.public.monkeybrains.net)
[19:47:27] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Quit: Gone to save the world!)
[19:47:46] *** Quits: nejucomo (Adium@9F0867A2.BB950596.DFB232DA.IP) (Ping timeout)
[19:47:53] *** Joins: nejucomo (Adium@9F0867A2.BB950596.DFB232DA.IP)
[19:48:05] <eddyb> =v? that doesn't look unambiguous
[19:48:10] *** Quits: fabiand (fabiand@moz-D9C81F83.adsl.alicedsl.de) (Quit: Verlassend)
[19:48:18] *** Quits: jvshahid (jvshahid@moz-53774307.nycm.ny.megapath.net) (Ping timeout)
[19:48:36] *** Quits: PGGB (PGGB@BD9E64E0.2702580D.85889BB1.IP) (Ping timeout)
[19:48:45] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[19:49:06] *** Joins: PGGB (PGGB@BD9E64E0.2702580D.85889BB1.IP)
[19:49:08] *** Quits: nejucomo1 (Adium@moz-B62B9944.public.monkeybrains.net) (Ping timeout)
[19:49:40] <wycats_> nmatsakis: I am so confused
[19:49:40] <nmatsakis> wycats_: so, looking a bit more, I am now confused. You have: add_value(mut_last(self.annotations[index].mut_nested()), ...)
[19:49:41] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[19:49:47] <nmatsakis> wycats_: but:
[19:49:50] *** Joins: nejucomo1 (Adium@moz-B62B9944.public.monkeybrains.net)
[19:49:53] <nmatsakis> wycats_: mut_last wants a vector
[19:50:01] <nmatsakis> wycats_: self.annotations[index].mut_netsed() is not a vector
[19:50:05] <wycats_> mut_nested() returns a vector
[19:50:20] <nmatsakis> wycats_: well I don't know what the def'n of mut_netsed is,
[19:50:31] *** Quits: nejucomo1 (Adium@moz-B62B9944.public.monkeybrains.net) (Connection reset by peer)
[19:50:34] <wycats_> mut_nested returns &'self mut ~[skylight::Annotation]
[19:50:35] <nmatsakis> wycats_: ah, ok, it returns a vector?
[19:50:50] <nmatsakis> wycats_: from where? the def'n of Annotation doesn't seem to include any vectors
[19:50:55] *** Quits: nejucomo (Adium@9F0867A2.BB950596.DFB232DA.IP) (Ping timeout)
[19:51:20] <nmatsakis> wycats_: can you break that expression up? I am confused too, perhaps write it like this:
[19:51:40] <nmatsakis> wycats_: let nested: &mut ~[Annotation] = self.annotations[index].mut_nested();
[19:51:42] *** Quits: tulloch (tulloch@moz-1C33A2E7.nat.csx.cam.ac.uk) (Ping timeout)
[19:51:46] <wycats_> nmatsakis: there are two Annotations :(
[19:51:57] <nmatsakis> wycats_: let last: &mut Annotation = mut_last(nested);
[19:52:00] <wycats_> skylight::Annotation (a data structure) and trace::Annotation (an enum)
[19:52:02] <nmatsakis> wycats_: add_value(last, value)
[19:52:14] <nmatsakis> wycats_: then you will get a more precise error with the specific point where the types are mismatchd.
[19:52:23] <nmatsakis> wycats_: ah, that's part of my confusion no doubt :)
[19:52:26] <wycats_> trace::Annotation should probably be trace::AnnotationValue
[19:52:40] *** Joins: jvshahid (jvshahid@moz-53774307.nycm.ny.megapath.net)
[19:52:57] <nmatsakis> wycats_: anyway, can you break that 1 line into 3 and see what error you get then?
[19:53:17] *** Quits: eddyb (eddy@336E3A7F.D51DAF03.FB866788.IP) (Ping timeout)
[19:53:43] *** Quits: Purrr (Darkstar@moz-3FB542EB.a176.priv.bahnhof.se) (Quit: leaving)
[19:53:52] <wycats_> hm there were inconsistencies between the two match arms
[19:54:00] <wycats_> breaking it up helped me identify it
[19:54:08] <wycats_> however... there is now a different issue/annoyance
[19:54:30] <wycats_> https://gist.github.com/wycats/31f670a76defed820119#file-annotation_builder-rs-L21
[19:54:37] <wycats_> lines 21 and 27 are identical
[19:54:51] * pcwalton wonders when he'll have time to justify refactoring rustc
[19:54:56] <nmatsakis> wycats_: (also, I tend to flit between windows a lot, so if you include nmatsakis in the message I'll be more likely to notice and respond promptly)
[19:54:58] <wycats_> but I couldn't figure out how to get the mutability to be scoped across everything
[19:55:09] *** Quits: Sorella_ (quildreen@D2D1E5DD.81EFC25A.A95FAE2B.IP) (Quit: Ex-Chat)
[19:55:15] <wycats_> nmatsakis: I tried to define a top-level mutable annotation
[19:55:19] <wycats_> and then set it in the block
[19:55:22] <wycats_> but I got errors
[19:55:25] <nmatsakis> wycats_: you can easily resolve that, you can do this:
[19:55:39] <nmatsakis> wycats_: let me just add it as a comment on the gist :)
[19:56:33] *** Joins: eddyb (eddy@336E3A7F.D51DAF03.FB866788.IP)
[19:56:44] <wycats_> I got it working
[19:56:45] <wycats_> hmmm
[19:57:29] <wycats_> https://gist.github.com/99943f1d0dbe363895a2
[19:57:31] <wycats_> this worked
[19:57:38] <wycats_> so the next question is... is this sanely structured at all?
[19:57:51] <nmatsakis> wycats_: https://gist.github.com/wycats/31f670a76defed820119#comment-953427
[19:58:06] <wycats_> mmmm expressions!
[19:58:07] <nmatsakis> oh, you did the same basic thing, thought I prefer it my way ;)
[19:58:15] *** Quits: autra (augustin@moz-BE76895F.fbx.proxad.net) (Ping timeout)
[19:58:18] <wycats_> yes me too
[19:58:23] <wycats_> expressions are much nicer than what I did
[19:58:55] <nmatsakis> as for whether it's sane it looks...not unsane? I guess I'd need to understand the broader context
[19:59:00] <wycats_> so I think I'm struggling because my understanding of the various forms of mut is still weak
[20:00:06] <nmatsakis> oh? maybe; seems like we invested some energy into sorting out how many layers of indirection there were
[20:00:15] <nmatsakis> which is something that just takes some getting used to, not specific to Rust I wouldn't say
[20:00:18] <wycats_> nmatsakis: yeah
[20:00:25] *** Quits: qmx (qmx@moz-B6DBCD05.qmx.me) (Ping timeout)
[20:00:28] *** Quits: willingc (willingc@moz-B4760708.san.res.rr.com) (Client exited)
[20:00:48] *** Joins: willingc (willingc@moz-B4760708.san.res.rr.com)
[20:00:53] <wycats_> nmatsakis: I guess I wasn't sure what kinds of things I can prefix with &mut
[20:00:56] <wycats_> to make them mutable
[20:00:57] <wycats_> references?
[20:01:05] <pcwalton> it's just references
[20:01:09] <wycats_> if I have a &T it's too late to make it mutable
[20:01:12] <pcwalton> (also @mut but that will probably be gone in a week)
[20:01:12] <wycats_> but I can make a T mutable?
[20:01:15] *** Joins: qmx (qmx@moz-B6DBCD05.qmx.me)
[20:01:16] <nmatsakis> wycats_: you mean deeply mutable?
[20:01:26] <nmatsakis> wycats_: the answer is: &mut T means everything *owned* in T is mutable
[20:01:42] <nmatsakis> wycats_: in the case of &mut &U, T=&U, so the U is not owned. You were trying to mutate the U.
[20:02:06] <wycats_> so I'm making the pointer mutable?
[20:02:12] <wycats_> but not the object?
[20:02:26] <nmatsakis> yes
[20:02:27] <pcwalton> &mut &T means you can change what the pointer points to, but not the object pointed to by the pointer
[20:02:35] *** Quits: willingc (willingc@moz-B4760708.san.res.rr.com) (Ping timeout)
[20:02:44] <pcwalton> &&mut T means you can change the object pointed to by the pointer, but not what the pointer points to
[20:02:56] <pcwalton> &mut &mut T means you can change both what the pointer points to and the object pointed to by the pointer
[20:03:12] <wycats_> so if you want to mutate a struct, you gotta &mut it before it becomes a reference
[20:03:20] *** Quits: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net) (Ping timeout)
[20:03:21] <kimundi> Meanwhile, &&T is a syntax error :P
[20:03:33] <nmatsakis> wycats_: ps any time that types get confusing, I tend to just break apart things into separate variables with explicit types like I suggested -- one downside of type inference is that the compiler only detects inconsistencies, it doesn't know which of the two is *correct*, so sometimes the error is reported far away from its actual source
[20:03:38] <pcwalton> kimundi: that reminds me, we should fix that before 1.0
[20:03:46] *** Joins: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net)
[20:03:46] *** ChanServ sets mode: +o tjc
[20:03:48] <kimundi> pcwalton: Would be good :)
[20:03:54] <wycats_> nmatsakis: I've gotten burned a few times by breaking things apart :P
[20:03:56] <pcwalton> same way we allow || to work as a closure
[20:03:58] <cmr> pcwalton: Ohh, that's a bug, not a feature?
[20:03:59] <benh> &&mut T doesn't seem to let me change the T
[20:04:03] <wycats_> I am getting a noob rust aversion to local variables ;)
[20:04:05] <pcwalton> cmr: it's a bug
[20:04:06] <cmr> That makes me happy :)
[20:04:29] <pcwalton> benh: yeah, that's because of a borrow check patch
[20:04:35] <pcwalton> that is needed to fix soundness
[20:04:39] <pcwalton> you can just ignore that
[20:04:52] <nmatsakis> benh: &mut basically inherits mutability from its context
[20:04:58] <nmatsakis> benh: or should, see #10520
[20:05:03] <benh> ok! :D
[20:05:14] <nmatsakis> pcwalton: I've decided that this is not some unfortunate side effect of the rules,
[20:05:19] <nmatsakis> pcwalton: but a feature.
[20:05:24] <wycats_> nmatsakis: the context here, fwiw, is that I have some extern "C" functions that let you add annotations of various types (int, double, etc.) and I convert them at the "C" boundary into a trace::Annotation (AnnotationValue) and then pass that here to be inserted into the skylight::Annotation, which has an Option<> for each of the available types
[20:05:33] <nmatsakis> pcwalton: See #10520 for more details :) I'm working on fixing it, as an aside, since it's bugging me in some patches i'm trying to write
[20:05:58] *** Joins: voxpopuli (fanservice@moz-FE161659.wv.cc.cmu.edu)
[20:05:59] <wycats_> so a skylight::Annotation has a slot for each of i64, f64, ~str
[20:06:06] <wycats_> and a nesting
[20:06:27] <wycats_> it ends up representing JSON (that particular part was not my design)
[20:06:41] *** Quits: sk (sk@61A494B3.BA40E8A.AAC02D62.IP) (Quit: Leaving)
[20:06:58] <nmatsakis> wycats_: I...sort of see :) 
[20:07:03] <wycats_> so { foo: 1 } becomes: [skylight::Annotation{ key: Some(~"foo"), int: Some(1) }
[20:07:14] <pcwalton> wycats_: to answer your question, once something is an &, you can never mutate it as long as that & is alive
[20:07:15] <wycats_> sorry ~[skylight::Annotation{ key: Some(~"foo"), int: Some(1) }]
[20:07:34] <pcwalton> & is very strong in Rust unlike C -- as long as there is an & pointer to something that thing will never ever be mutated
[20:07:44] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Quit: Leaving)
[20:07:46] <pcwalton> not by you, not by anyone else
[20:08:03] <wycats_> pcwalton: what happens if I need to do some immutable work (work with functions that expect &T) and then some mutable work (work with functions that expect &mut T)
[20:08:07] <wycats_> do I use scopes to manage it?
[20:08:08] <pcwalton> use &mut T
[20:08:12] <pcwalton> &mut T can become &T
[20:08:15] <pcwalton> it coerces
[20:08:19] <wycats_> pcwalton: that didn't seem to work for me
[20:08:25] <wycats_> perhaps I was doing something wrong?
[20:08:31] <pcwalton> probably something else was going wrong
[20:08:33] <wycats_> ah acrichto told me there was a bug with nested expression
[20:08:35] <wycats_> expressions
[20:08:37] <wycats_> foo(bar)
[20:08:38] <pcwalton> because we use that everywhere
[20:08:47] *** Quits: voxpopuli (fanservice@moz-FE161659.wv.cc.cmu.edu) (Ping timeout)
[20:09:02] <pcwalton> hmm, I wasn't aware of any bugs there
[20:09:04] <wycats_> it was telling me something about the lifetime of the mutable loan or something, but I was able to fix it by pulling bar out
[20:09:07] <wycats_> acrichto: bug number/
[20:09:09] <wycats_> ?
[20:09:09] <eddyb> nmatsakis: wooo, compiled rust, now to fix what I broke by using temporaries everywhere :P
[20:09:44] <nmatsakis> wycats_: pcwalton: perhaps acrichto was referring to the limitation where you have &mut receiver and &mut argment
[20:09:54] <nmatsakis> i.e., self.mut_something(self.mut_something_else())
[20:10:08] <nmatsakis> https://github.com/mozilla/rust/issues/6268
[20:10:31] <nmatsakis> that's a ... limitation I'd like to lift. But I don't call it a bug.
[20:10:31] <pcwalton> huh, OK
[20:10:37] <pcwalton> I literally never hit that
[20:10:46] <nmatsakis> it happens from time to time
[20:10:55] <nmatsakis> it can also occur via:
[20:10:55] *** Quits: Amanieu (amanieu@10FEE2FD.ECEF57A4.2CFD4520.IP) (Client exited)
[20:10:58] * pcwalton has literally never been burned by the borrow checker in months
[20:11:01] <nmatsakis> self.set_foo(self.get_bar())
[20:11:05] *** Joins: Amanieu (amanieu@10FEE2FD.ECEF57A4.2CFD4520.IP)
[20:11:14] <pcwalton> maybe I just subconsciously internalized the limitations
[20:11:22] <eddyb> nmatsakis: doesn't that fit in aliased mut?
[20:11:25] <nmatsakis> pcwalton: that is the goal
[20:11:33] <nmatsakis> pcwalton: that is, to have rules that you can internalize :)
[20:11:42] <pcwalton> nmatsakis: I figured we hit it already but wycats_ is showing otherwise :(
[20:11:54] <nmatsakis> pcwalton: though of course we should make them be as painless as possible...
[20:11:56] <wycats_> nmatsakis: that may have been it?
[20:12:02] <pcwalton> anyway that's probably it
[20:12:11] <pcwalton> at least there's a bug # and a path forward
[20:12:16] <nmatsakis> eddyb: I don't know what you mean
[20:12:29] <wycats_> I think the issue that acrichto told me about was a more straight-forward bug
[20:12:35] <wycats_> something about a left-to-right compiler?
[20:12:39] <eddyb> nmatsakis: no two &mut to the same location at the same time etc.
[20:12:50] <Luqman> been doing to much rust. just wasted more than enough time in python because i forgot 'return' :(
[20:13:03] <eddyb> Luqman: <3
[20:13:22] *** Quits: andre (andre@CA528A4A.45A4338E.8EE27E6.IP) (Quit: leaving)
[20:13:38] <pcwalton> I wish we had a bug number for it because I really really really want to fix all the borrow checker bugs
[20:13:44] <nmatsakis> eddyb: yes, it falls afoul of that rule, but a more subtle analysis shows that many such expressions are safe; but formalizing that is non-trivial
[20:14:03] <nmatsakis> wycats_: I don't know, but yes if you do remember lemme know
[20:14:20] <pcwalton> and I thought they were all fixed in a practical sense except for unsafe edge cases but now it looks like they're not :(
[20:14:24] <wycats_> nmatsakis: so in this example, I would prefer to structure my code so I could make the annotation, add its value, and then push it into the annotations list
[20:14:36] <pcwalton> which is odd because I program in rust for hours every day and haven't hit borrow check issues in months
[20:14:39] <wycats_> but add_nested expects an Annotation
[20:14:50] <wycats_> not an &Annotation
[20:14:57] <wycats_> do I use *?
[20:14:58] <nmatsakis> pcwalton: be careful with the term bug please :) 
[20:15:06] <pcwalton> yeah, I guess not bug
[20:15:14] <pcwalton> I mean confusing errors I guess
[20:15:35] *** Joins: ricepuddin (graham@moz-7D68765A.cable.virginm.net)
[20:15:37] <wycats_> nmatsakis: I tend to use the term "bug" very broadly, to include user confusion ;) but that's just me
[20:15:52] <pcwalton> not all user confusion can just be fixed though
[20:16:03] <pcwalton> safe manual memory management is hard and it took us 3 years to get here
[20:16:10] <nmatsakis> There are many fine-grained categories. Without knowing what this problem is, it's hard to say which one it is
[20:16:14] <wycats_> pcwalton: it may still be a bug, even if it's not easy to fix
[20:16:15] <wycats_> nmatsakis: https://gist.github.com/wycats/2bdf0ab673fbfef79ff0
[20:16:22] <pcwalton> it may be impossible to fix, is what I'm saying
[20:16:26] <wycats_> pcwalton: confirm
[20:16:27] <pcwalton> without breaking soundness
[20:16:40] <wycats_> seems reasonable... didn't mean to rathole on "bug"
[20:16:54] <wycats_> nmatsakis: the error I get for the ^^ program is
[20:16:56] <wycats_> annotation_builder.rs:19:43: 19:54 error: cannot move out of dereference of & pointer
[20:16:56] <wycats_> annotation_builder.rs:19         self.annotations[index].add_nested(*annotation);
[20:17:04] <wycats_> pointing at *annotation
[20:17:07] *** Joins: maxiepoo_ (Max@moz-709B6FA3.lightspeed.cicril.sbcglobal.net)
[20:17:18] <pcwalton> wycats_: try using "let mut annotation = skylight::Annotation::new();"
[20:17:22] <nmatsakis> wycats_: yes, so the problem is that when you call add_nested(), it wants annotation that it owns. You have a borrowed one. You hvae to clone it.
[20:17:32] <nmatsakis> wycats_: however, it's not clear to me why you have a borrowed one to begin with
[20:17:35] <pcwalton> wycats_: at line 15
[20:17:40] <wycats_> nmatsakis: I can use mut without &
[20:17:41] <wycats_> aha!
[20:17:44] <pcwalton> what the compiler is complaining about is that it saw a hole
[20:17:50] <pcwalton> ah yes, you can make mutable locals
[20:17:52] <pcwalton> I forgot to mention that ;)
[20:17:53] <pcwalton> sorry
[20:18:04] <nmatsakis> ok, I see the gist now, I missed that.
[20:18:08] <nmatsakis> yes, what pcwalton said.
[20:18:22] <pcwalton> anyway, Rust doesn't let you move from behind an & or an &mut because that would leave a "hole" where the value used to be
[20:18:30] *** Joins: spider-mario (spidermari@moz-2F72F6FF.dsl.quantic-telecom.net)
[20:18:32] <pcwalton> and Rust abhors a vacuum
[20:18:38] <pcwalton> the one exception is that you can have uninitialized locals
[20:18:55] <pcwalton> so Rust will let you move out of a local variable, or an argument
[20:19:30] <benh> can you use util::swap to swap a dummy Annotation into your &mut Annotation to not leave a hole?
[20:19:33] <nmatsakis> wycats_: in general, mutability in Rust is labeled at the top of the ownership tree and iherited down.
[20:19:33] <wycats_> annotation_builder.rs:15:8: 15:22 warning: variable does not need to be mutable, #[warn(unused_mut)] on by default
[20:19:33] <wycats_> annotation_builder.rs:15     let mut annotation = skylight::Annotation::new();
[20:19:36] <wycats_> seems like lies
[20:19:38] <pcwalton> benh: yup
[20:19:49] <sam113101> 13R09U03S07T 12I05S 08T12H02E 09B12E06S05T
[20:19:56] <nmatsakis> wycats_: I don't think that's a lie, looking in your cod e--
[20:19:58] <pcwalton> wycats_: it's quite possible that it isn't a lie, try removing the mut
[20:20:01] <wycats_> hm it's not!
[20:20:03] <nmatsakis> wycats_: the annotation  is not mutated until you've moved it into the vector
[20:20:04] <wycats_> what is going on here
[20:20:08] <wycats_> ah
[20:20:09] <wycats_> I see
[20:20:16] <wycats_> I was making it mut as a precursor to moving the mutation up
[20:20:17] <wycats_> :P
[20:20:21] <wycats_> then I forgot why I was doing it :P
[20:20:30] <pcwalton> mutability can change in rust and this is the source of a very powerful feature: the ability to temporarily freeze
[20:20:46] <pcwalton> the canonical example being mutating a hash table and then freezing it while you operate on it in parallel
[20:21:35] <wycats_> hmmmm
[20:21:55] <wycats_> https://gist.github.com/69641e2af447319cd50f
[20:22:02] <wycats_> annotation_builder.rs:16:14: 16:24 error: mismatched types: expected `&mut annotation_builder::skylight::Annotation` but found `annotation_builder::skylight::Annotation` (expected &-ptr but found struct annotation_builder::skylight::Annotation)                                    
[20:22:02] <wycats_> annotation_builder.rs:16     add_value(annotation, value);
[20:22:05] <wycats_> pointing at annotation
[20:22:17] <wycats_> (thanks for all the help guys... I feel like I'm imposing)
[20:22:27] <pcwalton> no problem, this is very valuable for us
[20:22:30] <pcwalton> add_value(&mut annotation, value)
[20:22:35] <pcwalton> and then mark annotation as mutable again
[20:22:37] <pcwalton> (now it's not a lie)
[20:23:25] <wycats_> you'll see I added it back
[20:23:27] <sam113101> pcwalton: not sure I understand the name of sprocketnes, is it sp rocket nes?
[20:23:37] <pcwalton> it's named after the bike sprocket in the rust logo
[20:23:41] <pcwalton> admittedly pretty obscure
[20:23:41] <pcwalton> oh well
[20:23:43] *** Joins: nejucomo (Adium@9F0867A2.BB950596.DFB232DA.IP)
[20:23:52] <pcwalton> I should cover that in my talk :)
[20:24:33] <cmr> pcwalton: that's tonight right?
[20:24:44] <pcwalton> tomorrow
[20:25:02] <kimundi> Does anyone know a workaround for embeddeding a $b:block macro variable in a block with doing "if true $b else $b" ?
[20:25:10] *** Joins: nejucomo1 (Adium@moz-B62B9944.public.monkeybrains.net)
[20:25:22] <pauls> kimundi: what goes wrong?
[20:25:37] <bstrie> now that we have sprocketnes, we need a coggenesis
[20:25:40] <bstrie> cogenesis
[20:25:46] *** Joins: nejucomo2 (Adium@9F0867A2.BB950596.DFB232DA.IP)
[20:25:48] <pcwalton> genesis is a lot more work I thik
[20:25:49] <pcwalton> think
[20:25:54] <pauls> You might need to add curly braces around the `$b`s?
[20:25:56] <kimundi> ($b:block) => ( { let tmp = ... ; $b } ) does not work
[20:26:01] *** Quits: nejucomo (Adium@9F0867A2.BB950596.DFB232DA.IP) (Ping timeout)
[20:26:07] *** Quits: nejucomo1 (Adium@moz-B62B9944.public.monkeybrains.net) (Connection reset by peer)
[20:26:09] <sam113101> well I don't understand rust's logo, looks like simply a gear with an R inside it
[20:26:13] *** Joins: nejucomo (Adium@moz-B62B9944.public.monkeybrains.net)
[20:26:14] <pauls> kimundi: how does it fail?
[20:26:21] <kimundi> sec
[20:26:23] *** Quits: nejucomo2 (Adium@9F0867A2.BB950596.DFB232DA.IP) (Connection reset by peer)
[20:26:31] *** Joins: nejucomo1 (Adium@9F0867A2.BB950596.DFB232DA.IP)
[20:26:56] <bstrie> sam113101: "It is distinguished from a gear in that sprockets are never meshed together directly"
[20:26:59] <wycats_> nmatsakis: https://gist.github.com/7ca32be00ed69a5cf73a
[20:27:01] <wycats_> much nicer
[20:27:26] <wycats_> let me try to go through this line by line and you guys can correct my fuzzy understanding
[20:27:31] <pcwalton> wycats_: yup, that looks like idiomatic rust to me
[20:27:44] <pcwalton> suggestions as to how to make the error messages guide users to the right solution more easily are welcomed
[20:27:50] *** Joins: nejucomo2 (Adium@moz-B62B9944.public.monkeybrains.net)
[20:27:54] *** Quits: nejucomo (Adium@moz-B62B9944.public.monkeybrains.net) (Ping timeout)
[20:27:58] <wycats_> pcwalton: I'm sure I'll get there :)
[20:28:03] <wycats_> once I understand the right solution
[20:28:08] <sam113101> bstrie: I see
[20:28:10] <wycats_> mut threw a monkey-wrench into my understanding
[20:28:19] *** Quits: nejucomo2 (Adium@moz-B62B9944.public.monkeybrains.net) (Connection reset by peer)
[20:28:20] <wycats_> line 15 is making a mutable local variable that contains a skylight::Annotation
[20:28:25] *** Joins: nejucomo (Adium@moz-B62B9944.public.monkeybrains.net)
[20:28:27] <kimundi> pauls: okay, the macro macro_rules! foo ( ($b:block) => ({let x = 5; $b}) ) invoked in a function as foo!( { "hi" } ) gives this error:
[20:28:32] <kimundi>  error: unexpected token: `an interpolated block`
[20:28:32] <kimundi> type_match.rs:15 macro_rules! foo ( ($b:block) => ({let x = 5; $b}) )
[20:28:41] *** Joins: nejucomo2 (Adium@9F0867A2.BB950596.DFB232DA.IP)
[20:28:49] *** Joins: willingc (willingc@moz-B4760708.san.res.rr.com)
[20:28:49] *** Quits: nejucomo1 (Adium@9F0867A2.BB950596.DFB232DA.IP) (Connection reset by peer)
[20:28:53] <bstrie> pcwalton: re: bikeshedding thread, I'm fine with ~ becoming * if you're convinced that it should be sufficiently rare that typing "new" doesn't become onerous, but I do wonder how we'll distinguish unsafe pointers from owned pointers
[20:28:53] <pcwalton> acrichto: whoa, we have native file i/o now?
[20:28:59] <pcwalton> bstrie: Ptr<T>
[20:29:05] <kimundi> And the workaround for that I'm using is macro_rules! foo ( ($b:block) => ({let x = 5; if true $b else $b}) )
[20:29:06] <pcwalton> but I think most C APIs should just be using &
[20:29:07] <wycats_> ::new() returns an Annotation
[20:29:09] <wycats_> how does that work?
[20:29:24] <wycats_> why doesn't it have to be an ~Annotation?
[20:29:29] <pcwalton> wycats_: it just returns by value
[20:29:36] *** Quits: nejucomo (Adium@moz-B62B9944.public.monkeybrains.net) (Connection reset by peer)
[20:29:43] *** Joins: nejucomo (Adium@moz-B62B9944.public.monkeybrains.net)
[20:29:45] <wycats_> pcwalton: but Annotation is recursive
[20:29:51] <wycats_> I though recursive structures needed ~T
[20:29:57] <benh> Only in the recursion :)
[20:30:01] *** Joins: nejucomo1 (Adium@9F0867A2.BB950596.DFB232DA.IP)
[20:30:05] <pcwalton> wycats_: ah, they do, but the trick here is that the *first level* has static size
[20:30:10] <pcwalton> you know how big an Annotation is
[20:30:10] <wycats_> interesting
[20:30:14] <wycats_> nice
[20:30:17] <pcwalton> you don't necessarily know how big the entire data structure is
[20:30:20] <pcwalton> it's a common trick in C++
[20:30:21] *** Quits: nejucomo (Adium@moz-B62B9944.public.monkeybrains.net) (Connection reset by peer)
[20:30:22] <pcwalton> and C
[20:30:24] *** Quits: nejucomo2 (Adium@9F0867A2.BB950596.DFB232DA.IP) (Ping timeout)
[20:30:25] *** Joins: nejucomo (Adium@moz-B62B9944.public.monkeybrains.net)
[20:30:28] <wycats_> pass-by-value means it's copied?
[20:30:28] <bstrie> pcwalton: would Ptr<T> subsume both * and *mut , or would we need MutPtr<T> as well
[20:30:37] <pcwalton> wycats_: it's moved
[20:30:50] <pcwalton> internally it's actually compiled as this:
[20:31:08] <wycats_> pcwalton: ok... so this Annotation is now owned by the stack frame?
[20:31:09] *** Joins: nejucomo2 (Adium@9F0867A2.BB950596.DFB232DA.IP)
[20:31:19] <wycats_> in mutable form?
[20:31:27] <pcwalton> the caller knows how much space an Annotation takes up on the stack, so it leaves that much room, creates a hidden pointer to the uninitialized memory, and passes that pointer to Annotation::new()
[20:31:38] *** Quits: nejucomo (Adium@moz-B62B9944.public.monkeybrains.net) (Connection reset by peer)
[20:31:41] <wycats_> pcwalton: makes sense
[20:31:45] *** Joins: nejucomo (Adium@moz-B62B9944.public.monkeybrains.net)
[20:31:48] <pcwalton> Annotation::new() says "hey, thanks for the space, I'll use it" and writes the value straight into that space
[20:31:52] *** Quits: nejucomo1 (Adium@9F0867A2.BB950596.DFB232DA.IP) (Ping timeout)
[20:31:56] <pcwalton> so it's as efficient as possible
[20:32:05] *** Quits: willingc (willingc@moz-B4760708.san.res.rr.com) (Client exited)
[20:32:09] <nmatsakis> wycats_: (ps, mut_last() is dead code now)
[20:32:11] <wycats_> pcwalton: and let mut annotation means that I own it mutably?
[20:32:13] <wycats_> nmatsakis: confirm
[20:32:15] <pcwalton> right
[20:32:20] <wycats_> pcwalton: ok that's line 15
[20:32:22] <pcwalton> regarding mutability, Annotation::new() doesn't care whether its caller wants to mutate it
[20:32:26] *** Joins: willingc (willingc@moz-B4760708.san.res.rr.com)
[20:32:30] <pcwalton> it just has some space and knows that it wants to write the value there
[20:32:35] <wycats_> right... mutability is static semantics right?
[20:32:38] <pcwalton> so you can use "let" or "let mut" and it'll still work
[20:32:40] <pcwalton> yeah
[20:32:41] <bstrie> wycats_: I believe this is called return-value optimization http://en.wikipedia.org/wiki/Return_value_optimization
[20:32:47] <wycats_> so line 16
[20:32:50] *** Quits: nejucomo2 (Adium@9F0867A2.BB950596.DFB232DA.IP) (Ping timeout)
[20:32:53] <wycats_> I have an Annotation
[20:32:57] <pcwalton> bstrie: right, it is… in Rust it isn't optimization though, it's part of the language
[20:33:05] <bstrie> which is great!
[20:33:07] <wycats_> and I want to mutate it
[20:33:17] <wycats_> so add_value wants to borrow it
[20:33:20] <pcwalton> so we don't have wiggle room like C++ where they say "well, maybe the copy constructor will run, maybe it won't… the compiler can just do whatever, yolo"
[20:33:24] <wycats_> mut it still needs to borrow it mutably
[20:33:34] *** Quits: nejucomo (Adium@moz-B62B9944.public.monkeybrains.net) (Ping timeout)
[20:33:37] <bstrie> but do we have/need copy constructors?
[20:33:39] <wycats_> (in principle this seems like a coercion that should be able to be automatic?)
[20:33:42] <pcwalton> bstrie: we don't
[20:33:46] <wycats_> s/mut/but/
[20:33:51] <bstrie> good, then I won't learn what they are :)
[20:33:55] <o11c> there is .clone() though
[20:33:58] <nmatsakis> bstrie: we have clone...
[20:34:09] *** Quits: willingc (willingc@moz-B4760708.san.res.rr.com) (Ping timeout)
[20:34:14] <nmatsakis> bstrie: ...serves a similar purpose
[20:34:22] <wycats_> pcwalton: is that a correct explanation for the &mut prefix on line 16?
[20:34:31] <wycats_> we're lending a mutable version of this pointer to add_value
[20:34:32] <pcwalton> wycats_: I think of it more like "add_value wants a pointer… and because it wants to mutate it wants a mutable pointer"
[20:34:49] <pcwalton> if add_value took the annotation by value then you'd lose the original because it'd be moved away
[20:34:54] <wycats_> pcwalton: right
[20:35:01] <wycats_> I understand move vs. lend pretty well
[20:35:04] <wycats_> so nothing new here
[20:35:09] <pcwalton> right
[20:35:14] *** Joins: nejucomo (Adium@9F0867A2.BB950596.DFB232DA.IP)
[20:35:18] <wycats_> the need to &mut-prefix is an example of my inconsistency beef
[20:35:36] <pcwalton> well, if we got rid of all the coercions then you'd still have the &mut prefix
[20:35:39] *** Quits: jxv (jxv@moz-8FB92450.lightspeed.irvnca.sbcglobal.net) (Ping timeout)
[20:35:42] <pcwalton> but at least it'd be consistent
[20:36:00] <wycats_> pcwalton: yeah... I'm ok with either removing all of them or making all demotions automatic, but I prefer the latter
[20:36:03] <SiegeLord> I'm confused about the meeting notes... are we losing the &[] syntax?
[20:36:08] <pcwalton> (every time we have tried to add magic we've gotten burned… at this point I'm willing to just throw out all the magic)
[20:36:10] <wycats_> so T -> &T
[20:36:18] <wycats_> and thus mutable T -> &mut T
[20:36:23] <pcwalton> I think that will just make things worse honestly
[20:36:31] <wycats_> pcwalton: let's discuss it in person tomorrow
[20:36:32] <pcwalton> I'm very anti-magic
[20:36:36] *** Joins: jxv (jxv@moz-8FB92450.lightspeed.irvnca.sbcglobal.net)
[20:36:38] <bstrie> is the 'self parameter on wycats_'s gist still necessary? can it become 'a ?
[20:36:39] *** Joins: nejucomo1 (Adium@moz-B62B9944.public.monkeybrains.net)
[20:36:39] <pauls> kimundi: I'm afraid I don't remember the rules for interpolating blocks, so I guess I can't help. 
[20:36:40] <wycats_> I think a patchwork is the worst of all worlds
[20:36:41] <pauls> Sorry!
[20:36:44] <pcwalton> I agree with that
[20:36:47] *** Quits: nejucomo (Adium@9F0867A2.BB950596.DFB232DA.IP) (Connection reset by peer)
[20:36:52] *** Joins: nejucomo (Adium@9F0867A2.BB950596.DFB232DA.IP)
[20:37:17] <wycats_> pcwalton: my proposal has a sane mental model if done consistently, which makes the "magic" problem much less severe
[20:37:44] <pcwalton> we'll discuss it tomorrow
[20:37:47] <wycats_> "Rust will demote pointers for me automatically"
[20:37:49] <wycats_> pcwalton: confirm
[20:37:50] <pcwalton> more magic has a very high bar at this point
[20:37:50] <wycats_> we should
[20:38:00] <wycats_> pcwalton: I wouldn't think of the proposal as more magic
[20:38:11] <wycats_> I would think of it as making the existing magic less of a leaky abstraction
[20:38:17] <wycats_> removing it totally seems fine too
[20:38:21] *** Quits: nejucomo1 (Adium@moz-B62B9944.public.monkeybrains.net) (Ping timeout)
[20:38:24] *** Joins: nejucomo1 (Adium@moz-B62B9944.public.monkeybrains.net)
[20:38:35] <bstrie> [magic] O- [more magic]
[20:38:57] <wycats_> pcwalton: I think you think of the current magic as just "magic to make me type less", while I saw it as a language abstraction
[20:39:23] <wycats_> for me "if I have a ~T or a T, I can pass it to a function that expects a &T" makes sense as a langauge-level abstraction
[20:39:26] <pcwalton> well, when we start thinking about custom smart pointers I think it's quite possible the current magic won't even hold up
[20:39:27] <wycats_> also I will stop talking now :P
[20:39:35] *** Quits: nejucomo (Adium@9F0867A2.BB950596.DFB232DA.IP) (Ping timeout)
[20:39:56] <bstrie> wycats_: in https://gist.github.com/wycats/7ca32be00ed69a5cf73a , do you need the 'self lifetime on the impl on line 9? you don't use lifetimes anywhere within...
[20:40:04] *** Quits: nejucomo1 (Adium@moz-B62B9944.public.monkeybrains.net) (Ping timeout)
[20:40:22] <wycats_> bstrie: yeah, I think I did it preemptively but I don't think I need it yet
[20:40:28] <bstrie> ah ok
[20:40:38] <pcwalton> acrichto: can I use all of io native with no runtime at all?
[20:40:42] <pcwalton> so file, etc
[20:41:27] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[20:41:27] *** ChanServ sets mode: +o pnkfelix
[20:42:01] *** Joins: autra (augustin@moz-BE76895F.fbx.proxad.net)
[20:42:57] <SiegeLord> StringSlice is even more worrying...
[20:43:03] *** Joins: jstevans (Instantbir@moz-ACEF96BA.bootp.virginia.edu)
[20:43:11] <SiegeLord> Oh wait, it's Substring...
[20:43:45] <pcwalton> SiegeLord: no decision has been made yet, but in my proposal the &[T] syntax would remain
[20:43:50] <jstevans> http://blog.theincredibleholk.org/blog/2013/11/18/booting-to-rust/
[20:43:56] *** Joins: pnathan1 (Adium@moz-C4D69BD8.hfc.comcastbusiness.net)
[20:44:14] <jstevans> I'm trying to follow this tutorial, and I'm having trouble using ld on it
[20:44:47] *** Joins: spott (spott@D76D9638.B3FAD41.E7673F62.IP)
[20:45:30] <jstevans> Sorry, I'm not being super clear: when I try to do ld on basic UEFI kernel code (according to this tutorial), I get an undefined reference error for "__aeabi_unwind_cpr0" and "__aeabi_unwind_cpr1"
[20:46:28] <bstrie> jstevans: I think eholk had to patch the compiler to get a few things in that post to work, and I don't think those patches have landed yet
[20:47:03] <sfackler> jstevans: this is the PR you'll need: https://github.com/mozilla/rust/pull/10527
[20:47:03] *** Joins: voxpopuli (fanservice@moz-FE161659.wv.cc.cmu.edu)
[20:47:14] *** Quits: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net) (Ping timeout)
[20:47:22] <jstevans> This wouldn't have anything to do with me trying to cross-link to ARM, right?
[20:47:57] <pcwalton> the standard library could use a visit from the RAII Police at this point
[20:48:02] <pcwalton> we need to get rid of all with_foo functions
[20:48:16] <pcwalton> and the iterator police
[20:48:47] <pcwalton> e.g. the hangul decomposition utility should be yielding an iterator that converts 한 to ㅎㅏㄴ
[20:49:18] <eddyb> jstevans: aeabi is ARM-specific
[20:49:28] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Quit: Gone to save the world!)
[20:49:55] <jstevans> eddyb: So, it is... hrm. Do you happen to know what I'm doing wrong?
[20:50:17] <eddyb> you're trying to compile UEFI for ARM? I'm not sure if that makes sense
[20:50:37] <eddyb> pcwalton: all with_ closure functions?
[20:50:40] <pcwalton> yeah
[20:50:49] <pcwalton> they work better cuz you can move out of upvars without using Cell
[20:50:53] *** Joins: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net)
[20:50:57] <eddyb> hmm
[20:50:58] <pcwalton> also they're nicer to LLVM
[20:51:06] <pcwalton> don't require devirtualization optimizations
[20:51:11] <jstevans> eddyb: I'm trying to write a hello world kernel for UEFI ARM
[20:51:38] <eddyb> jstevans: oh, well. maybe try to disable some exception stuff in LLVM
[20:51:51] <eddyb> pcwalton: did you hear my crazy string building idea?
[20:51:56] <pcwalton> eddyb: I didn't
[20:51:57] *** Joins: Skif_ (emschwar@moz-CA025D57.ip.mcleodusa.net)
[20:52:30] <eddyb> so you have something like a rope, pieces to concatenate together into a single owned string
[20:52:39] <bstrie> what would you do with something like insert_or_update_with on hashmaps?
[20:52:42] *** Quits: voxpopuli (fanservice@moz-FE161659.wv.cc.cmu.edu) (Ping timeout)
[20:52:43] <bstrie> pcwalton: ^
[20:52:47] *** Quits: Skif_ (emschwar@moz-CA025D57.ip.mcleodusa.net) (Connection reset by peer)
[20:52:51] <pcwalton> bstrie: that's fine
[20:53:00] <pcwalton> not everything can be RAII
[20:53:00] *** Quits: jxv (jxv@moz-8FB92450.lightspeed.irvnca.sbcglobal.net) (Ping timeout)
[20:53:08] <pcwalton> but there are a lot of things that are blatantly not RAII that could be
[20:53:14] *** Joins: jxv (jxv@moz-8FB92450.lightspeed.irvnca.sbcglobal.net)
[20:53:17] *** Quits: Skif (emschwar@moz-CA025D57.ip.mcleodusa.net) (Ping timeout)
[20:53:29] <eddyb> but not all the pieces are strings - you could have various ToStr-like-implementing objects, and converting those to strings and then concatenating might be a waste of time
[20:53:29] <pcwalton> closures aren't evil, just don't abuse them
[20:53:50] <pcwalton> eddyb: we have a Formatter trait for that, no?
[20:54:49] <eddyb> recurse from left to right, summing the total length as you go down the recursion. you can use stack locals, like a fixed sized vector for stringifying a number. when you reach the end, you know the total size
[20:55:03] <pcwalton> oh, with preallocated size
[20:55:15] <pcwalton> I think we might be able to add a size hint to formatter
[20:55:24] *** Quits: infynyxx_ (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[20:55:25] <pcwalton> but really, you want the formatter trait
[20:55:32] <pcwalton> it works really well
[20:55:37] <pcwalton> if rust-core doesn't have it that's rust-core's problem
[20:55:39] <eddyb> you allocate a string of that size and return it. now, on each level of the recursion, you put the piece in the string, right to left, at the known position
[20:55:47] <pcwalton> that's what the formatter does :P
[20:55:49] <eddyb> you can keep all the stack locals
[20:55:55] <pcwalton> it does no allocations
[20:56:15] <pcwalton> ask strcat for it, we have it in the stdlib
[20:56:25] <eddyb> pcwalton: when I mentioned this earlier, people weren't sure. does it use this recursive chaining trick?
[20:56:32] <pcwalton> yes
[20:56:37] <pcwalton> it does everything stack locally
[20:57:04] <eddyb> can it do that for a compile-time-unknown format string?
[20:57:16] <pcwalton> I'm not sure
[20:57:22] <wycats_> pcwalton: let's see if my new understanding helps me get annotations done
[20:57:23] <eddyb> (assuming variadics are available)
[20:57:35] <pcwalton> but in theory you should be able to use the same machinery to make it work
[20:58:01] <eddyb> pcwalton: I know it's not very stupid, but the recursive part is important here, and I don't have a constant shape
[20:58:37] <eddyb> I was thinking of this for inspecting my DAG/Tree-like expressions
[20:58:53] <pcwalton> yeah, I think what you may want is something that uses the same machinery as the Formattable trait but isn't string formatting itself
[20:59:11] * eddyb has to look in depth at that machinery to see if it's the same thing
[21:00:49] <eddyb> pcwalton: you can do runtime chaining of arbitrary stringifiable values with this trick, but I have no idea if it's new or if it's a special/general case of some other known optimization
[21:01:07] *** Quits: nano (nano@moz-74CAD1CA.superkabel.de) (Quit: nano)
[21:03:16] *** Quits: d3xter (sinz@moz-13692240.adsl.highway.telekom.at) (Quit: WeeChat 0.4.2)
[21:05:35] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[21:06:39] *** Quits: jordyd (jordyd@moz-CD151A8B.seg37.ucf.edu) (Ping timeout)
[21:06:55] <eddyb> I'm too tired to fix the next problem
[21:07:20] *** Joins: tikue__ (tkuehn@1A16C144.CD72397.689607DE.IP)
[21:07:38] <acrichto> pcwalton: yes, you can use file I/O and standard I/O with no runtime
[21:07:48] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[21:07:52] <pcwalton> sweet, I should update sprocketnes
[21:07:56] <acrichto> pcwalton: but currently if an error happens everything will die real hard because conditions don't work without the runtime
[21:07:56] <eddyb> acrichto: you scare me a little :P
[21:08:05] <pcwalton> better than what sprocketnes was doing on error
[21:08:10] <pcwalton> ignoring libc error codes
[21:08:26] <eddyb> riiight, I also have to work on that 6502 or whatever disasm >_>
[21:08:50] <eddyb> the codegen for Rust has to be much smarter in some places :(
[21:08:53] *** Quits: qmx (qmx@moz-B6DBCD05.qmx.me) (Ping timeout)
[21:08:53] *** Quits: jesse99 (jesse99@moz-8B1E0C5D.hsd1.wa.comcast.net) (Ping timeout)
[21:08:53] *** Quits: PGGB (PGGB@BD9E64E0.2702580D.85889BB1.IP) (Ping timeout)
[21:08:55] <acrichto> pcwalton: also about the bug you and wycats were talking about, self.foo(self.bar()) is an error if both take &mut self
[21:09:19] <pcwalton> acrichto: ah yeah, that's 6268
[21:09:22] <kimundi>  wrote a primitive type_match! macro for use with Any: https://gist.github.com/Kimundi/7552622
[21:09:33] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[21:09:34] *** ChanServ sets mode: +ao brson brson
[21:09:39] *** Joins: qmx (qmx@moz-B6DBCD05.qmx.me)
[21:09:53] <kimundi> Would anyone like to see a more improved version of that in the stdlib?
[21:09:57] <pcwalton> kimundi: oh, I have a feature request for Any.
[21:10:03] *** Quits: maxiepoo_ (Max@moz-709B6FA3.lightspeed.cicril.sbcglobal.net) (Quit: maxiepoo_)
[21:10:04] <pcwalton> can we get a version that doesn't require Send?
[21:10:32] *** Quits: pnathan1 (Adium@moz-C4D69BD8.hfc.comcastbusiness.net) (Quit: Leaving.)
[21:10:35] <kimundi> rusti: let x = ~5u as ~Any:; x
[21:10:36] -rusti- <anon>:9:25: 9:29 error: use of undeclared type name `Any`
[21:10:36] -rusti- <anon>:9          let x = ~5u as ~Any:; x
[21:10:37] -rusti-                                   ^~~~
[21:10:37] -rusti- error: aborting due to previous error
[21:10:37] -rusti- application terminated with error code 101
[21:11:46] <eddyb> not in 0.8
[21:12:04] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[21:12:09] <kimundi> pcwalton: This fails to compile because of missing Send bound on current master:
[21:12:10] <kimundi>     let x = ~5 as ~Any:;
[21:12:10] <kimundi>     fn foo<T: Send>(t: T) {}
[21:12:10] <kimundi>     foo(x);
[21:12:38] <pcwalton> you need ~Any:Send
[21:12:39] *** Joins: refold (gman@moz-42D68426.a258.priv.bahnhof.se)
[21:12:42] *** Quits: dbussink (dbussink@moz-E0A5568C.bussink.me) (Ping timeout)
[21:12:44] <eddyb> kimundi: hmm, looks nice - for some reason I was thinking of using match on typeids, but nvm
[21:12:50] *** Quits: Amanieu (amanieu@10FEE2FD.ECEF57A4.2CFD4520.IP) (Connection reset by peer)
[21:12:50] *** Joins: PGGB (PGGB@BD9E64E0.2702580D.85889BB1.IP)
[21:12:51] <pcwalton> I think the constructor for Any was requiring Send or something
[21:12:53] <pcwalton> last I looked.
[21:12:59] *** Joins: Amanieu (amanieu@10FEE2FD.ECEF57A4.2CFD4520.IP)
[21:13:01] <kimundi> pcwalton: Afaik no, let me check
[21:13:49] <kimundi> pcwalton: Nope, ANy only requires the 'static bound
[21:13:49] *** Joins: dbussink (dbussink@moz-E0A5568C.bussink.me)
[21:14:00] <pcwalton> hmm, ok
[21:14:15] <kimundi> pcwalton: fail! on the other hand needs a Any + Send :P
[21:14:18] <wycats_> pcwalton: I'm seeing some compiler errors that tell me that current_module::skylight::foo doesn't match skylight::foo
[21:14:28] <wycats_> even though current_module::skylight::foo doesn't resolve
[21:14:35] <wycats_> so really the problem is that I lack leading ::
[21:14:40] <acrichto> wycats_: make sure you don't have two 'mod skylight' directives
[21:14:44] <wycats_> acrichto: I do
[21:14:50] <wycats_> I think this is an error bug
[21:14:54] <acrichto> each time you do that, it redeclares the skylight module
[21:14:56] <wycats_> it shouldn't get far enough to do type matching
[21:15:00] <acrichto> meaning there are two separate instances of it
[21:15:07] <kimundi> Anyway, I have the feeling that I need to implement type_match! as a procedural macro - I run into to many issues with declarative ones
[21:15:12] <wycats_> right but current_module::skylight::foo doesn't exist at all
[21:15:18] <acrichto> wycats_: you want to declare 'mod skylight' once, and then use it elsewhere
[21:15:35] <pcwalton> acrichto: we should warn for that
[21:15:42] <wycats_> acrichto: I can declare mod skylight in lib.rs?
[21:15:45] <wycats_> and not again in children?
[21:15:45] <acrichto> pcwalton: I agree, this has come up many times
[21:15:49] <acrichto> wycats_: correct
[21:15:55] *** Quits: eddyb (eddy@336E3A7F.D51DAF03.FB866788.IP) (Ping timeout)
[21:16:08] <kimundi> We really, _really_ need a lint for that. I'd even impement it myself, if someone tells me where and how :P
[21:16:30] <pcwalton> kimundi: should probably be done earlier than the lint pass
[21:16:48] <wycats_> what exactly are the semantics for this?
[21:16:54] <wycats_> when I say mod skylight in lib.rs
[21:16:55] <wycats_> what happens?
[21:17:03] <wycats_> I have a skylight.rs
[21:17:05] <kimundi> pcwalton: Well, I have no idea about passes :P
[21:17:12] <acrichto> it'll convert that to "mod skylight { /* contents of skylight.rs */ }
[21:17:23] <kimundi> wycats_: http://static.rust-lang.org/doc/master/tutorial.html#crates-and-the-module-system
[21:17:27] <acrichto> wycats_: and different modules at different locations in the module hierarchy are distinct
[21:18:04] *** Joins: mikezaby (mikezaby@moz-AA896205.home.otenet.gr)
[21:18:43] <wycats_> do I still need the leading ::?
[21:18:48] <wycats_> or super::?
[21:18:56] <kimundi> Before I start pouring to much into this: Can a dev tell me if a type_match! macro would even be wanted in the stdlib?
[21:19:13] <acrichto> wycats_: all paths in use imports are global paths
[21:19:18] <acrichto> meaning they're rooted in the root module
[21:19:24] <wycats_> acrichto: right, but not if I don't use
[21:19:28] <acrichto> as oppopsed to path expressions which are rooted in the current module
[21:19:32] <wycats_> right
[21:19:39] <wycats_> so outside of use, I need to prefix ::
[21:19:57] <acrichto> that'll work, you can also have a use to bring it in scope
[21:20:26] <benh> I've also seen a few people use extern mod foo; use foo::... in a non-crate-root module and get confused :(
[21:20:38] <pcwalton> benh: that one is harder to fix
[21:21:09] *** Joins: eevee (eevee@moz-7B6C48E3.evrt.wa.frontiernet.net)
[21:21:25] <benh> default lint mode for only allowing extern mod in the crate root, maybe?
[21:21:26] <kimundi> "fix"?
[21:21:36] <kimundi> extern mod is valid there
[21:21:47] *** Joins: josh (josh@DC98BC6D.96CB7DCC.284344F5.IP)
[21:21:50] <kimundi> needs to be "extern mod foo; use self::foo::..." though
[21:22:27] <benh> Is there really a use case for extern mod in a nested mod?
[21:22:32] <pcwalton> acrichto: r? https://github.com/mozilla/rust/pull/10568
[21:22:56] <pcwalton> lunchtime
[21:23:14] <benh> more bars? between all the pubs and bars in the tree at this point, it's a wonder anything gets done!
[21:23:34] <kimundi> benh: Well, it works, so why forbid it? :P
[21:24:02] <kimundi> benh: If only a submodule uses a crate, why make that visible to the whole crate
[21:24:04] <benh> kimundi: because people wrote what i said, and the error tells them that the use item can't find foo, and they're all "but it's right there!"
[21:24:06] <wycats_> things are working!
[21:24:40] <kimundi> benh: That's not a problem with extern mod, that's a problem with the error message and people nor understanding the module system :P
[21:25:00] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[21:27:09] *** Joins: Skif (emschwar@moz-CA025D57.ip.mcleodusa.net)
[21:27:49] *** Joins: willingc (willingc@moz-B4760708.san.res.rr.com)
[21:29:23] *** Joins: brson (brson@6A848D32.C1B840DD.76F66111.IP)
[21:29:23] *** ChanServ sets mode: +ao brson brson
[21:29:49] *** Quits: aatch (James@moz-B437F499.pocketrent.com) (Ping timeout)
[21:33:09] *** Joins: Skif_ (emschwar@moz-CA025D57.ip.mcleodusa.net)
[21:33:09] *** Quits: Skif (emschwar@moz-CA025D57.ip.mcleodusa.net) (Connection reset by peer)
[21:33:12] *** Quits: Skif_ (emschwar@moz-CA025D57.ip.mcleodusa.net) (Client exited)
[21:33:21] <wycats_> pcwalton, nmatsakis: any ideas on how to deal with nullable pointers from C in Rust?
[21:33:31] <wycats_> "try not to send null"?
[21:33:33] *** Joins: Skif (emschwar@moz-CA025D57.ip.mcleodusa.net)
[21:34:00] <wycats_> or is there a way to deal with a possibly-null pointer passed into Rust
[21:34:24] <bstrie> hm, does rust prevent you from storing a reference to heap-allocated data in statics?
[21:34:31] <acrichto> wycats_: do you have a corresponding struct in rust?
[21:34:50] <wycats_> yeah, the pointer is represented by an Option<> in Rust
[21:35:04] <acrichto> Option<&T> is a nullable pointer
[21:35:13] <acrichto> along with Option<~T> and Option<@T>
[21:35:27] <nmatsakis> wycats_: the traditional thing is Option (as acrichto said)
[21:35:41] <nmatsakis> wycats_: but a *T is also nullable, there's kind of some overlap
[21:36:00] <nmatsakis> wycats_: but if you use Option<> the rust type system can help you avoid null deref
[21:36:04] <wycats_> so if I have a nullable T from C, and I want to make an Option<T>
[21:36:11] <wycats_> is there a good way to cast it?
[21:36:14] *** Quits: dbussink (dbussink@moz-E0A5568C.bussink.me) (Quit: bye)
[21:36:27] <o11c> Option<T> is not the same sort of thing
[21:36:30] <o11c> it stores T by value
[21:36:36] *** Joins: tiffany (kawaii@moz-28A8742A.dhcp.embarqhsd.net)
[21:36:47] <acrichto> wycats_: *T has to_option()
[21:36:51] <wycats_> ok I want to make an Option<&T>
[21:36:54] <wycats_> acrichto: interesting
[21:37:00] <acrichto> wycats_: http://static.rust-lang.org/doc/master/std/ptr/trait.RawPtr.html#tymethod.to_option
[21:37:05] <wycats_> which does what I want?
[21:37:10] * o11c <3 that builtin types have methods
[21:37:27] <acrichto> wycats_: to_option()
[21:37:29] *** Joins: dbussink (dbussink@moz-E0A5568C.bussink.me)
[21:37:36] <wycats_> i.e. take parent: *int and do parent.to_option() "?
[21:38:13] <acrichto> yes
[21:38:17] <nmatsakis> wycats_: why not just take parent: OPtion<*int>
[21:38:18] <wycats_> :shipit:
[21:38:28] <wycats_> nmatsakis: I can't pass Option<> from C
[21:38:33] <nmatsakis> wycats_: yes you can
[21:38:35] <wycats_> nmatsakis: O_O
[21:38:36] <wycats_> how?
[21:38:39] <nmatsakis> wycats_: the representation of Option<*T> is just a ptr
[21:38:43] <nmatsakis> wycats_: NULL == None
[21:38:47] <wycats_> nmatsakis: O_O
[21:38:48] <wycats_> wheee
[21:38:55] <acrichto> nmatsakis: not Option<*T> though
[21:38:58] <acrichto> Option<&T>
[21:38:58] <nmatsakis> arguably the fact that *T is nullable is an anachronism
[21:39:02] <wycats_> can I coerce easily to Option<&T> or Option<~T>?
[21:39:04] <nmatsakis> acrichto: I don't think that's correct
[21:39:12] <nmatsakis> rusti: sizeof::<Option<*int>>()
[21:39:12] -rusti- <anon>:9:9: 9:31 error: unresolved name `sizeof`.
[21:39:12] -rusti- <anon>:9          sizeof::<Option<*int>>()
[21:39:12] -rusti-                   ^~~~~~~~~~~~~~~~~~~~~~
[21:39:12] -rusti- error: aborting due to previous error
[21:39:13] -rusti- application terminated with error code 101
[21:39:17] <nmatsakis> rusti: sys::sizeof::<Option<*int>>()
[21:39:18] <acrichto> rusti: ::std::sys::size_of::<Option<*int>>
[21:39:19] -rusti- pastebinned 11 lines of output: http://sprunge.us/fFJF
[21:39:19] -rusti- fn() -> uint
[21:39:20] <acrichto> rusti: ::std::sys::size_of::<Option<*int>>()
[21:39:21] -rusti- 16u
[21:39:28] <nmatsakis> oh hmm we should fix that
[21:39:31] <bstrie> haha
[21:39:34] <acrichto> I thought *T was nullable?
[21:39:37] <bstrie> why does size_of return a function
[21:39:37] * nmatsakis stands corrected
[21:39:51] <bstrie> ah I see
[21:39:56] <bstrie> got lost in the chevrons
[21:39:57] <nmatsakis> acrichto: it is nullable, but I don't see the point of that
[21:40:10] <nmatsakis> acrichto: now that Option<*T> can be represented as a ptr
[21:40:19] <nmatsakis> wycats_: anyway, acrichto is right, but I think it's a bug :)
[21:40:27] <wycats_> nmatsakis: so what should I do?
[21:40:38] <nmatsakis> wycats_: though you could use Option<&T> -- that should be fine, if the C is just passing a ptr
[21:41:00] *** Joins: engla (engla@moz-F64E1B0F.cust.bredbandsbolaget.se)
[21:41:12] <nmatsakis> rusti: ::std::sys::size_of::<Option<&'static int>>()
[21:41:13] -rusti- 8u
[21:41:16] * nmatsakis shew
[21:41:34] <wycats_> nmatsakis: sounds good to me
[21:41:40] <wycats_> can I also take Option<~T>?
[21:42:39] <kimundi> nmatsakis: *T being nullable and Option<*T> beign pointer sized are not mutual exclusive
[21:43:09] <kimundi> (also @ acrichto ^ )
[21:43:11] <bstrie> is it possible to have an unsafe ptr as a static?
[21:43:19] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[21:43:42] *** Quits: eternaleye (eternaleye@moz-5668AFCB.hsd1.wa.comcast.net) (Ping timeout)
[21:44:17] *** Joins: aatch (James@moz-B437F499.pocketrent.com)
[21:44:24] <nmatsakis> kimundi: I'm aware of that
[21:44:25] <SiegeLord> It'd be a bit weird for Some(NULL) to become None...
[21:44:36] <nmatsakis> wycats_: you cannot take Opiton<~T>, because that would indicate that you own the memory,
[21:44:42] <nmatsakis> wycats_: and hence rust would try to free it
[21:44:46] <nmatsakis> wycats_: well, you can do it if you want that
[21:45:08] <nmatsakis> wycats_: though I think there's (currently at least) no guarantee that our free of `~` is compatible with C malloc
[21:46:15] *** Quits: aatch (James@moz-B437F499.pocketrent.com) (Ping timeout)
[21:47:09] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[21:48:02] *** Quits: Jackneill (Jackneill@moz-16CEF626.pool.digikabel.hu) (Input/output error)
[21:48:15] *** Joins: voxpopuli (fanservice@FD256FCE.33AC841E.689607DE.IP)
[21:49:13] *** Joins: eternaleye (eternaleye@moz-5668AFCB.hsd1.wa.comcast.net)
[21:49:51] <enix> is there some way to use an Option<~int> member of a structure from a method on that structure that takes by-ref self, such as fn do_something(&mut self)? When I try something like that I get move errors when trying to match on the Option and I'm not sure if that indicates I'm doing something wrong or if I'm trying to do something thats impossible.
[21:50:13] *** Quits: Amanieu (amanieu@10FEE2FD.ECEF57A4.2CFD4520.IP) (Client exited)
[21:50:23] *** Joins: Amanieu (amanieu@10FEE2FD.ECEF57A4.2CFD4520.IP)
[21:50:40] *** Joins: nsf (nsf@moz-EEF3238A.convex.ru)
[21:50:51] *** Quits: jvshahid (jvshahid@moz-53774307.nycm.ny.megapath.net) (Quit: Lost terminal)
[21:51:48] <bstrie> how do I transmute an owned pointer to an int?
[21:51:56] <bstrie> I want to live on the wild side
[21:52:15] <kimundi> enix: match self.option_field { Some(ref x) => { /* have a &~int here */ }}
[21:52:23] <benh> get a borrowed pointer and as-cast it?
[21:52:29] *** Joins: geoffhill (geoffhill@moz-738DC0DB.org)
[21:52:35] <tikue__> i think you do &*p as *T as uint?
[21:52:37] *** Joins: pcx (pcx@C81B818B.E5A6DB9C.AE26B834.IP)
[21:52:54] <kimundi> rusti: let x = ~5; &*x as *int as uint
[21:52:55] -rusti- 140470114213976u
[21:53:00] <tikue__> rusti: let p = ~1; &*p as *int as uint
[21:53:01] -rusti- 140377617227864u
[21:53:03] <tikue__> cool
[21:53:34] *** Quits: spider-mario (spidermari@moz-2F72F6FF.dsl.quantic-telecom.net) (Input/output error)
[21:53:47] <bstrie> ok, now how do I cast it back :3
[21:53:58] <enix> kimundi: Lets say I want to destructure though. Like, if I have a Some(~int) to consume the int and change the field into a None? Is there some way to do that using a &mut self?
[21:54:09] *** Quits: moostik (Icedove@5A22E6A1.10715965.BCDF592F.IP) (Ping timeout)
[21:54:11] <tikue__> bstrie: probably can't safely
[21:54:23] <bstrie> tikue__: that's fine, I *want* to be unsafe
[21:54:24] <tikue__> rather, _definitely_ can't
[21:54:26] <benh> mayeb with .take()?
[21:54:26] <tikue__> :P
[21:54:27] <bstrie> that's the whole goal of this
[21:54:29] <tikue__> right
[21:54:30] <bstrie> in fact
[21:54:32] <tikue__> transmute?
[21:54:32] <bstrie> I am storing this uint
[21:54:34] <bstrie> in a static mut
[21:54:37] <bstrie> so it's SUPER unsafe
[21:54:46] <bstrie> I don't know how transmute works!!
[21:54:48] <bstrie> I am not an alchemist
[21:54:50] <benh> Why is it a uint again?
[21:54:53] <benh> and not a *T?
[21:54:53] <bstrie> this was my original question
[21:55:16] <kimundi> enix: let value = self.option_field.take(); // self.option_field is now None
[21:55:23] *** Quits: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com) (Quit: Jesse)
[21:55:36] *** Quits: josh (josh@DC98BC6D.96CB7DCC.284344F5.IP) (Ping timeout)
[21:55:57] *** Quits: brson (brson@6A848D32.C1B840DD.76F66111.IP) (Ping timeout)
[21:56:02] *** Quits: Palmik (palmik@moz-DEC2AB.pks.muni.cz) (Quit: Lost terminal)
[21:56:06] <tikue__> rusti: use std::cast::transmute; let p = ~1; let u = &*p as *int as uint; let p2: ~int = unsafe { transmute(u) }; p2
[21:56:06] -rusti- ~1
[21:56:07] -rusti- application terminated abnormally with signal 11 (Segmentation fault)
[21:56:12] <tikue__> lol
[21:56:16] <tikue__> good
[22:00:13] *** Joins: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com)
[22:02:28] <benh> rusti: use std::cast::{transmute, forget}; let p = ~1; let u = &*p as *int as uint; let p2: ~int = unsafe { transmute(u) }; forget(p); p2
[22:02:28] -rusti- <anon>:9:126: 9:136 error: call to unsafe function requires unsafe function or block
[22:02:28] -rusti- <anon>:9          use std::cast::{transmute, forget}; let p = ~1; let u = &*p as *int as uint; let p2: ~int = unsafe { transmute(u) }; forget(p); p2
[22:02:28] -rusti-                                                                                                                                        ^~~~~~~~~~
[22:02:29] -rusti- error: aborting due to previous error
[22:02:30] -rusti- application terminated with error code 101
[22:02:33] <benh> oh no
[22:02:49] <benh> rusti: use std::cast::{transmute, forget}; let p = ~1; let u = &*p as *int as uint; let p2: ~int = unsafe { transmute(u) }; unsafe { forget(p) }; p2
[22:02:50] -rusti- ~1
[22:03:23] *** Quits: pcx (pcx@C81B818B.E5A6DB9C.AE26B834.IP) (Ping timeout)
[22:03:39] *** Joins: pcx (pcx@C81B818B.E5A6DB9C.AE26B834.IP)
[22:04:35] *** Joins: jvshahid (jvshahid@moz-53774307.nycm.ny.megapath.net)
[22:04:57] <mark_edward> what does this mean? `writer.rs:57:25: 57:39 error: cannot implement a destructor on a structure with type parameters`
[22:06:14] *** Joins: aatch (James@moz-B437F499.pocketrent.com)
[22:07:20] <mark_edward> why do generic destructors need to be unsafe?
[22:07:57] *** Quits: voxpopuli (fanservice@FD256FCE.33AC841E.689607DE.IP) (Ping timeout)
[22:09:30] <kimundi> { is never a valid patter start, right?
[22:10:52] *** Quits: willingc (willingc@moz-B4760708.san.res.rr.com) (Client exited)
[22:11:11] *** Joins: willingc (willingc@moz-B4760708.san.res.rr.com)
[22:12:23] *** Quits: willingc (willingc@moz-B4760708.san.res.rr.com) (Client exited)
[22:12:27] *** Quits: mikezaby (mikezaby@moz-AA896205.home.otenet.gr) (Input/output error)
[22:12:44] *** Joins: willingc (willingc@moz-B4760708.san.res.rr.com)
[22:12:44] *** Quits: tikue__ (tkuehn@1A16C144.CD72397.689607DE.IP) (Quit: tikue__)
[22:12:51] <enix> kimundi: Interesting. thanks!
[22:14:27] <mark_edward> isn't 0xff_ff_ff_00 a valid i32? rustc is giving me an overflow warning
[22:14:29] *** Joins: skeet70 (skeet70@moz-697F48F2.bzm-mt.client.bresnan.net)
[22:14:31] *** Quits: joone (joone@moz-C50DC051.jf.intel.com) (Ping timeout)
[22:14:44] *** Joins: mihneadb (mihneadb@6CBB3868.3689173D.FCAAE698.IP)
[22:15:06] <kimundi> mark_edward: 0xff_ff_ff_00 is a positive integer literal
[22:15:06] <sp3d> mark_edward: the greatest i32 is 0x7f_ff_ff_ff
[22:15:12] <kimundi> mark_edward: 0xff_ff_ff_00 is a positive integer literal
[22:15:38] *** Joins: moostik (Icedove@moz-63ED7231.w82-121.abo.wanadoo.fr)
[22:15:47] <kimundi> mark_edward: whoops. anyway, it might be base 16, but that is not the same as the bit pattern of the memory :P
[22:15:50] <mark_edward> kimundi, but it's still a valid i32, it's just negative isn't it?
[22:15:58] <kimundi> mark_edward: No
[22:16:20] <kimundi> mark_edward: In the same sense as 255 is not -128 :P
[22:16:32] <mark_edward> kimundi, but isn't it?
[22:16:39] <mark_edward> bitwise i mean?
[22:16:47] <aatch> mark_edward, only bitwise though
[22:16:54] <kimundi> bitwise, but not their logical value
[22:17:07] <mark_edward> well i need that pattern of bits, but in an i32, how can i do that?
[22:17:08] <pnkfelix> rusti: 255 as i8
[22:17:09] -rusti- -1i8
[22:17:33] <mark_edward> rusti: 0xffFFff00 as i32
[22:17:34] -rusti- -256i32
[22:17:51] *** Joins: tikue__ (tkuehn@1A16C144.CD72397.689607DE.IP)
[22:17:53] *** Joins: joone (joone@moz-C50DC051.jf.intel.com)
[22:17:55] <kimundi> a u8 with bit pattern 0b11111111 has the logical value 255, and can be interpreted as a i8 with the logical value -128
[22:18:08] <o11c> kimundi: er, no
[22:18:18] <o11c> 128 as i8 is -128
[22:18:18] <pnkfelix> rusti: −128 as u8
[22:18:19] -rusti- <anon>:9:9: 9:9 error: unknown start of token: \u2212
[22:18:19] -rusti- <anon>:9          −128 as u8
[22:18:19] -rusti-                   ^
[22:18:20] -rusti- application terminated with error code 101
[22:18:29] <kimundi> rusti: (255u8, 255u8 as i8)
[22:18:30] -rusti- (255u8, -1i8)
[22:18:35] <kimundi> err, -1
[22:18:53] <aatch> kimundi, you fail at twos complement :P
[22:18:55] <o11c> rusti: !255 as i32
[22:18:55] -rusti- -256i32
[22:19:03] <kimundi> pardon me, didn't have the twos-complement in recent memory :P
[22:19:09] <o11c> mark_edward: that's what I'd do ^
[22:19:20] <o11c> well, !0xff
[22:19:31] <kimundi> rusti: 0xff_ff_ff_00_u32 as i32
[22:19:32] -rusti- -256i32
[22:19:39] <kimundi> mark_edward: ^
[22:19:53] <aatch> If you need a specific bit pattern, why do you need a signed representation?
[22:20:00] <aatch> That just seems like asking for bugs.
[22:20:37] <mark_edward> because it's being bitise-anded with an i32. i'm directly translating some C# code, and i guess the C# compiler doesn't give such warnings
[22:20:52] <o11c> just make the other side be an i32, please
[22:22:03] <aatch> o11c, I assume you mean u32?
[22:22:11] <o11c> er, yeah
[22:22:22] <o11c> those keys have no right being next to each other
[22:22:27] <mark_edward> o11c, okey dokes
[22:22:33] <o11c> s32 ftw
[22:22:47] <b3kf> i have written a benchmark but it doesn't run.
[22:22:56] <b3kf> i have written it at vec.rs file
[22:23:07] <b3kf> and compiled rustc libs.rs
[22:23:17] <b3kf> when executing ./std --bench
[22:23:28] <b3kf> it is not mentioned
[22:23:48] <kimundi> b3kf: You need to compile as rustc --test libs.rs afaik
[22:24:15] <b3kf> kimundi: i let u know how it has gone
[22:24:18] *** Quits: carter (carter@moz-BDFE46F6.nyc.biz.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[22:24:44] *** Quits: jvshahid (jvshahid@moz-53774307.nycm.ny.megapath.net) (Ping timeout)
[22:25:35] <b3kf> kimundi: you have nailed it. 10x
[22:25:45] *** Joins: voxpopuli (fanservice@FD256FCE.33AC841E.689607DE.IP)
[22:26:03] *** Quits: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp) (Quit: )
[22:28:34] *** Quits: peterdn (chatzilla@moz-30BAAE88.as13285.net) (Quit: ChatZilla 0.9.90.1-rdmsoft [XULRunner 22.0/20130619132145])
[22:28:55] <kimundi> Is it possible to test and develop procedural macros with libsyntax without recompiling the compiler everytime to check if it works?
[22:28:57] *** Quits: exobit_ (textual@moz-E06F46F0.corp.bitshelter.com) (Quit: )
[22:29:13] <pauls> kimundi:  nope
[22:29:35] <tjc> kimundi: patches welcome :-)
[22:29:54] *** Quits: tiffany (kawaii@moz-28A8742A.dhcp.embarqhsd.net) (Ping timeout)
[22:30:09] *** Joins: tiffany (kawaii@moz-28A8742A.dhcp.embarqhsd.net)
[22:30:16] <kimundi> Not even "here is a extern mod syntax; here is a string literal containing the source, try to parse it" ? 
[22:30:31] *** Joins: rofrol_home (Mibbit@moz-F40C9BE0.threembb.ie)
[22:31:13] <rofrol_home> how to read file line by line?
[22:31:20] <tjc> kimundi: it's not impossible, but it would be a major project
[22:31:38] <rofrol_home> I see there is no read_line in Reader and there is no FileInput in extra
[22:31:55] *** Joins: nejucomo (Adium@moz-FC8B8F66.hsd1.ca.comcast.net)
[22:32:47] <kimundi> tjc: Yeah... I wish I could pump a few weeks of time into it. I have a vague plan how to make dynamic loading of rust crates safe, which would enable dynamically loadable macros, which would enable such things :P
[22:32:50] <SiegeLord> Wasn't there already an attempt at this based on loading shared libraries?
[22:32:51] <Thiez> rusti: let x = ~~2; 1***x***x // the whole multiplication/pointer-deref thing remains a little weird
[22:32:51] -rusti- 4
[22:33:21] <Thiez> so I heard there might be plans to replace ~ with *, anywhere I can read more about that?
[22:33:40] *** Quits: eternaleye (eternaleye@moz-5668AFCB.hsd1.wa.comcast.net) (Ping timeout)
[22:33:56] <kimundi> tjc: Basically I want to use the same trick I use for Any: dynload is generic over any T, and it dynamically checks at runtime if the type is identical with the type in the dynamic library
[22:34:13] <kimundi> Which I think should work in theory
[22:34:42] <kimundi> Need to figure out how rustc loads and handles external crates though :P
[22:34:44] *** Joins: eternaleye (eternaleye@moz-5668AFCB.hsd1.wa.comcast.net)
[22:35:00] <tjc> kimundi: the crate handling code isn't that huge, at least; it's all under librustc/metadata
[22:35:06] <bjz_> if ~ was replaced with *, what would deref be? Part of what helped me understand pointers better in rust was the differentiation between ~ and deref (*)
[22:35:16] <kimundi> bjz: *
[22:36:04] <Thiez> bjz_: with unsafe pointers * is also used
[22:36:14] <kimundi> bjz_: *T would be the type for ~T, and *expr would still be the deref expression. The ~T allocation expression would be replaced with new expr
[22:36:29] <bjz_> are we just pandering to the minority of outsiders who keep trolling us about sigils?
[22:36:31] <SiegeLord> It'd be kind of confusing coming from C++ to have * mean something very sophisticated
[22:36:37] <kimundi> And the existing unsafe ptr would become Ptr<T>
[22:36:52] <kimundi> bjz_: Well, I'd be sad to see ~ go :P
[22:37:10] <bjz_> :(
[22:37:28] *** Joins: tulloch (tulloch@moz-1C33A2E7.nat.csx.cam.ac.uk)
[22:37:53] <o11c> I want ~ gone
[22:38:07] <Thiez> why? it's so cute
[22:38:09] <dbaupp> Unique<T> is fine by me... as long as we keep &T short
[22:38:18] <SiegeLord> I'd rather it be named to @ and the placement new become @(GC)
[22:38:25] <o11c> I'm not picky about where it goes, but there are really confusing errors for things like ~0xff when you want !0xff
[22:38:34] <o11c> no, you can't have @ change meaning
[22:38:58] <SiegeLord> I've been programming C++ for nearly a decade, and I've never used the bitwise ~ :P
[22:38:59] <bjz_> o11c: why is that confusing?
[22:39:10] *** Quits: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com) (Ping timeout)
[22:39:20] <o11c> because every other language uses ~ for bitwise not
[22:39:20] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[22:39:21] <dbaupp> o11c: @ is being removed as managed, so it is changing meaning :P
[22:39:27] <o11c> don't be different just because you can
[22:39:29] *** Joins: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com)
[22:39:42] <benh> We also have different precedence for bitwise ops iirc
[22:39:44] <o11c> because programmers *do* live in a world where they have to switch langauges
[22:39:52] <SiegeLord> Tons of languages have if(){} and for(;;) loop :P
[22:39:55] <o11c> benh: eh, we're trained to always parenthesize
[22:40:04] *** Quits: jxv (jxv@moz-8FB92450.lightspeed.irvnca.sbcglobal.net) (Quit: Leaving)
[22:40:09] <o11c> dbaupp: outright removal is fine
[22:40:52] *** Quits: Amanieu (amanieu@10FEE2FD.ECEF57A4.2CFD4520.IP) (Client exited)
[22:41:12] *** Joins: Amanieu (amanieu@10FEE2FD.ECEF57A4.2CFD4520.IP)
[22:41:12] <dbaupp> o11c: and so why is changing meaning not fine?
[22:41:25] <bjz_> so would `new` be an operator?
[22:41:45] <Thiez> what I'm afraid of is that without the nice sugar like ~, @, and autoderef, rust is going to become rather wordy
[22:41:58] <dbaupp> static types means old code is highly going unlikely to be both broken and still compile.
[22:42:05] <bjz_> Thiez: yeah :(
[22:42:09] <SiegeLord> It definitely will... Rust's syntax is already an issue... having to write even more things won't help things
[22:42:39] <bjz_> Thiez: we get folks annoying us about 'line noise', but when you actually use it it's quite nice
[22:43:01] <tjc> SiegeLord: Is there a language whose syntax isn't an issue? Not trolling, it just seems like there is no known language that makes everyone happy (syntactically)
[22:43:12] <bjz_> Thiez: but I guess part of the issue is removing magic
[22:43:13] *** Joins: Jesse_ (jruderman@moz-7B0110AD.mv.mozilla.com)
[22:43:26] <Thiez> without the &* autoborrow we'll become more line-noisy
[22:43:31] *** Quits: jstevans (Instantbir@moz-ACEF96BA.bootp.virginia.edu) (Ping timeout)
[22:43:46] <pcwalton> we're a far cry from "public static void"
[22:43:55] <pcwalton> when people think verbose they mean
[22:44:04] <Thiez> but since @ is being freed up as we speak, perhaps @ can mean &* ;)
[22:44:10] <bjz_> so: let x: ~T = ~x; -> let x: Unique<T> = new x;
[22:44:10] <pcwalton> public class HelloWorld { public static void main(String[] args) { System.out.println("Hello world!"); } }
[22:44:18] <pcwalton> let x: *T = new x;
[22:44:21] *** Quits: tulloch (tulloch@moz-1C33A2E7.nat.csx.cam.ac.uk) (Ping timeout)
[22:44:28] <pcwalton> I'm fine with leaving *
[22:44:29] <teratorn> Thiez: *without* auto-deref wot?
[22:44:37] <bjz_> and: let x: @T = @x; -> let x: Gc<T> = new x;
[22:44:39] <SiegeLord> tjc: I've not seen complaints such as these about D when I was a member of that community... instead there were praises for its beauty
[22:44:47] <SiegeLord> I don't quite see such praises made about Rust :P
[22:44:50] <Thiez> teratorn: I meant autoborrow, said it wrong :)
[22:44:51] <benh> the new stack closure syntax lets you write some weird line noise :))
[22:44:52] <tjc> SiegeLord: Ok, fair enough. I'm not familiar with D, so I can't speak to that personally
[22:44:57] <teratorn> Thiez: </panic>
[22:45:01] <pcwalton> we're also *far* less verbose than D
[22:45:06] <pcwalton> and people love D's syntax
[22:45:13] <pcwalton> note that D also has "new"
[22:45:21] <SiegeLord> But it has constructors
[22:45:27] <SiegeLord> Rust does not
[22:45:40] <SiegeLord> Rust will have new T::init(); D has new T;
[22:45:54] <SiegeLord> Rust has a: T for parameters, D has T a
[22:45:54] <ssbr> There are plenty of languages where the language's users don't usually complain about the syntax.
[22:45:56] <pcwalton> if we have to solve that problem then we can
[22:45:59] <teratorn> Thiez: eh, being more clear about your borrow-points is probably a good thing
[22:46:03] *** Joins: jdm (jdm@moz-ED0C7AC7.hinet-ip.hinet.net)
[22:46:03] *** ChanServ sets mode: +o jdm
[22:46:06] <bjz_> pcwalton: why keep *?
[22:46:12] *** Quits: Jesse_ (jruderman@moz-7B0110AD.mv.mozilla.com) (Quit: Linkinus - http://linkinus.com)
[22:46:17] <pcwalton> bjz_: because it's short
[22:46:24] <Thiez> I like * for unsafe pointers
[22:46:24] <pcwalton> also because making Unique<T> will require quite a bit more machinery
[22:46:27] <SiegeLord> D has autoref and autoderef, Rust doesn't
[22:46:30] <bjz_> pcwalton: if we are remiving the other sigils though
[22:46:38] <pcwalton> SiegeLord: where?
[22:46:43] <pcwalton> we have it on the LHS of '.'
[22:46:51] <teratorn> Thiez: Me too :-(
[22:46:55] <bjz_> pcwalton: for function parameters
[22:47:05] <teratorn> Thiez: because it actually is the same as a C/C++ *.
[22:47:06] <pcwalton> also D is not totally a fair comparison. they get their beauty from relying on a slow garbage collector for everything
[22:47:08] <Thiez> I think it makes sense for the primitive 'raw' pointer to have special syntax and for Unique to be a trait/struct-thing rather than the other way round
[22:47:10] <teratorn> so it actually makes some sense.
[22:47:10] <SiegeLord> Which is not to say there aren't valid reason for those choices... but those choices are not free of consequence
[22:47:29] <ssbr> teratorn: Oh, hello there!
[22:47:32] <bjz_> pcwalton: so min(&x, &y) -> min(x, y)
[22:47:33] <benh> I'm more afraid of "line noise" in things like generic functions with lifetime parameters and kind bounds than just putting a sigil in front of a name :/
[22:47:35] <teratorn> ssbr: hi :)
[22:47:41] <pcwalton> benh++
[22:47:46] <bjz_> benh: ++
[22:47:58] <Thiez> ++'s and cookies all around
[22:48:02] <SiegeLord> 99% of lines won't be function declarations :P
[22:48:22] <bjz_> pcwalton: how is pattern matching on pointer types going to work?
[22:48:24] <SiegeLord> Generally a function will be called more often than it's declared
[22:48:29] <Thiez> if 99% of your lines aren't function declarations you're either commenting really well or your functions are too long :p
[22:48:31] <pcwalton> bjz_: * means "all pointer types" in patterns
[22:48:31] <benh> SiegeLord: Yeah but maybe, like, 80% of lines you glance at when trying to figure out how to use someone else's code might be?
[22:48:33] <o11c> there are also structs though
[22:48:41] <pcwalton> it's a trick
[22:48:51] <pcwalton> that works because of the way we typecheck patterns
[22:49:28] <ssbr> SiegeLord: the syntax of a function declaration matters to the callers too (in that they might often read the declaration)
[22:49:30] <bjz_> pcwalton: why not just use @ for all pointer types? @ is nice because it's sort of like 'at'?
[22:49:50] <kimundi> pcwalton: I must say I have mixed feelings about the "not-doing-DST" and "changing ~ to * and new" future...
[22:49:59] <o11c> incidentally, a quick search on my C++ codebase says that 1/10th of all lines are a declaration of *some* sort (not necessarily function).
[22:50:00] <pcwalton> I know the entire rust community is against me
[22:50:07] *** Joins: dbussink_ (dbussink@moz-E0A5568C.bussink.me)
[22:50:08] <pcwalton> but after 3 years I've come to the conclusion that most people, honestly, won't accept anything other than & or *
[22:50:16] *** Quits: pcx (pcx@C81B818B.E5A6DB9C.AE26B834.IP) (Ping timeout)
[22:50:46] *** Quits: dbussink (dbussink@moz-E0A5568C.bussink.me) (Ping timeout)
[22:50:46] *** dbussink_ is now known as dbussink
[22:50:47] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[22:51:01] <Thiez> and yet the rust community seems rather large for an unnaceptable language that hasn't reached 1.0 yet
[22:51:06] <pcwalton> a lot of people program rust with "add line noise"
[22:51:12] <pcwalton> it's *not* a large community yet
[22:51:26] <pcwalton> a lot of people try "add line noise until it compiles"
[22:51:35] <pcwalton> and then get a slow program and end up frustrated with the compiler and leaving
[22:51:42] <SiegeLord> I don't think that ever works...
[22:51:50] <SiegeLord> When does adding ~ make something compile?
[22:51:51] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Ping timeout)
[22:51:53] <tjc> pcwalton: Couldn't that potentially be addressed with better lint messages?
[22:51:53] <kimundi> pcwalton: Well, switching to * would mean we _look_ like other languages. But the semantic is still somewhat unique, so I'm not sure if that would improve things
[22:51:56] <o11c> a smarter search says that 4% of non-comment lines are function declarations (or maybe definitions)
[22:52:05] <tjc> As in, "you didn't need that allocation" (which we already have, but maybe there are more that could be added)
[22:52:25] <teratorn> kimundi: exactly, the apparent semantics become a lie
[22:52:29] *** Quits: dbussink (dbussink@moz-E0A5568C.bussink.me) (Quit: bye)
[22:52:43] <teratorn> leaving * as * made sense to me :-(
[22:52:48] <pcwalton> tjc: I don't know why we should make things harder for ourselves… our error messages are still some of the best error messages in any compiler I know of
[22:52:50] *** Joins: dbussink (dbussink@moz-E0A5568C.bussink.me)
[22:52:51] <pcwalton> and yet we still confuse people
[22:52:54] <sp3d> false cognates are worse than unfamiliar symbols
[22:52:58] <o11c> I would that ~ be something like % or ^, which don't have preexisting unary meanings in C++
[22:53:07] <SiegeLord> ^ does
[22:53:11] *** Joins: tulloch (tulloch@moz-1C33A2E7.nat.csx.cam.ac.uk)
[22:53:12] <kimundi> With ~, you can at least say "This is a pointer, not negation. Adjust your worldview!" :P
[22:53:13] <benh> haha, let's steal the C++/CLI pointer sigils
[22:53:13] <tjc> pcwalton: fair enough... you probably have a better sense than I do for the reasons why people are confused (e.g., whether it's the volume of errors/warnings, or something else)
[22:53:15] <SiegeLord> In managed C++ :P
[22:53:19] <sp3d> kimundi++;
[22:53:20] <pcwalton> we tried ^
[22:53:23] <pcwalton> it looked really bad
[22:53:26] <teratorn> o11c: maaaan NOBODY uses ~, it's a GREAT symbol to steal ;)
[22:53:31] <bjz_> pcwalton: it would be nice to keep a different sigil for pointers than deref, because they are semantically different. having ~ helped me understand the difference - I was always confused before
[22:53:32] <o11c> SiegeLord: don't care about M$ extensions
[22:53:39] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[22:53:40] <SiegeLord> It's a bad association
[22:53:44] *** Joins: brson (brson@6A848D32.C1B840DD.76F66111.IP)
[22:53:44] *** ChanServ sets mode: +ao brson brson
[22:54:31] <pcwalton> appearances matter
[22:54:36] * benh can't really get worked up over changing ~expr to new expr or something
[22:54:41] <Thiez> perhaps we can use $ for pointers to appeal to the php community ;)
[22:54:58] <tikue__> it's so heated in here and the conversation is so convoluted that i can't tell who is arguing for what anymore
[22:54:59] <benh> Do we use $ for anything right now?
[22:55:04] <tikue__> benh: macros
[22:55:06] *** Quits: dbussink (dbussink@moz-E0A5568C.bussink.me) (Quit: bye)
[22:55:07] <kimundi> Also, while I see the improvement, having ~[T] and &[T] degenerate into Vec<T> and VecSlice<T> seems like a explosion of types
[22:55:08] <benh> ah, right
[22:55:32] <pcwalton> Nimrod is gaining a lot of popularity, for example, despite having a GC that isn't even thread safe (so if you share objects between threads you'll just crash)
[22:55:40] <tikue__> kimundi: how about [T] for Vec<T>
[22:55:41] <pcwalton> because it looks nice
[22:55:42] <SiegeLord> Hopefully &[T] will remain... dunno about &str though
[22:55:50] <tikue__> or [T] for Slice<T>
[22:55:53] <pcwalton> personally I'm thinking &[T] and &str could just become [T] and str
[22:55:59] <tikue__> pcwalton++
[22:55:59] <pcwalton> and then Vector and String
[22:56:08] <SiegeLord> Where would you stick the lifetime?
[22:56:09] <tikue__> i was thinking that as well
[22:56:11] <pcwalton> 'static str
[22:56:18] <bjz_> pcwalton: perhaps experienced C/C++ programmers have forgotten the wierdness of it, but for people starting out, it helps not to overload the meanings. but yeah, I agree with tikue__, emotions might be running a little high
[22:56:20] <pcwalton> that way you can verbally say "str" and "string"
[22:56:32] <tikue__> SiegeLord: 'a [T] could work right?
[22:56:32] <pcwalton> better than "and-str" and "twiddle-str" like I usually say :P
[22:56:51] <SiegeLord> tikue__: It's... a new syntax
[22:56:57] <mark_edward> task 'rustc' failed at 'vtables missing where they are needed', /build/buildd/rust-nightly-201311190805~f5f5d5a~saucy/src/libstd/option.rs:113 :-(
[22:57:02] *** Joins: alisdair (textual@moz-2F3322CF.hsd1.tx.comcast.net)
[22:57:07] <pcwalton> mark_edward: interesting, never seen that before
[22:57:09] <SiegeLord> tikue__: At that point, I'd prefer str<'a>
[22:57:19] <SiegeLord> And [T]<'a>
[22:57:20] *** Joins: dbussink (dbussink@moz-E0A5568C.bussink.me)
[22:57:24] * pcwalton has no opinion on where to put the lifetime
[22:57:27] <mark_edward> i think it has something to do with Writers...
[22:57:28] <SiegeLord> Ugly as sin, but at least consistent with everything else
[22:57:40] *** Quits: willingc (willingc@moz-B4760708.san.res.rr.com) (Client exited)
[22:57:40] <benh> SiegeLord: []<'a, T> :D
[22:57:40] <tikue__> SiegeLord: yeah that's not bad imo
[22:57:47] <tikue__> haha nooo
[22:57:50] <SiegeLord> XD
[22:57:57] <tikue__> ['a T] ? :)
[22:58:00] *** Joins: willingc (willingc@moz-B4760708.san.res.rr.com)
[22:58:06] <kimundi> Under DST, I imagined [T] to be a unsized generic type that you can wrapp in a newtype wrapper. std would contain struct str([u8]); And there could also be struct str_ascii([Ascii]) etc, with the compiler generating the neccessary stuff to make ~str and &str work as a dynamically sized type. Without that, we need Vec, VecSlice, Str, StrSlice, StrAscii, StrAsciiSlice... It worries me
[22:58:07] <bjz_> benh: yess! /jk
[22:58:37] <pcwalton> kimundi: my biggest concern with DST for those types is that there are multiple valid "vector-like" containers, for example small vectors
[22:58:43] *** Quits: Ralith (ralith@A8995AA9.62B6AF6A.922221DB.IP) (Ping timeout)
[22:59:00] <pcwalton> and it seems strange to be baking one set of semantics into the language
[22:59:15] <pcwalton> furthermore, GC<[int]> and Unique<[int]> have very different possible operations
[22:59:25] <pcwalton> it's not clear to me how to express the fact that you can push onto the latter but not the former
[22:59:26] <Thiez> kimundi: what if you had types 'Str' and 'Ascii', then you could have Slice<Str> and Slice<Ascii> and with Vec<T> you would get Slice<T> ?
[22:59:39] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[22:59:43] *** Quits: willingc (willingc@moz-B4760708.san.res.rr.com) (Ping timeout)
[22:59:44] <pcwalton> but if we did the non-DST solution then both problems become much easier
[22:59:57] <bjz_> pcwalton: I might be warming to an overloadable `new`. could reduce magic
[22:59:59] <pcwalton> incidentally, I was thinking we wouldn't need VecSlice/StrSlice/StrAsciiSlice
[23:00:03] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[23:00:16] <kimundi> Thiez: That wouldn't work
[23:00:16] <pcwalton> SiegeLord does have a good point about the verbosity of let x = new Thingy::init();
[23:00:29] *** flaper87 is now known as flaper87|afk
[23:00:44] <pcwalton> maybe we need constructors :P or at least zero-argument constructors
[23:00:52] <pcwalton> it's obvious how to implement them
[23:00:55] *** Joins: jgilbert (jgilbert@moz-BBE3ABD.mv.mozilla.com)
[23:00:58] <tikue__> pcwalton: what if there were an init trait
[23:00:59] <pcwalton> we already have a Default trait, don't we?
[23:01:01] <SiegeLord> Well, my solution is to make 'new' into a sigil, because solving it the C++ way is kind of scary
[23:01:03] <tikue__> then you could just have new Thingy
[23:01:04] <ssbr> Isn't there already a trait for zero-argument constructors?
[23:01:05] <bjz_> pcwalton: why not just keep ~ as 'new'?
[23:01:05] <kimundi> pcwalton: We have the std::Default::Default trait... :P
[23:01:13] <pcwalton> we could just hardwire Default into the compiler
[23:01:21] <Thiez> kimundi: could if Slice was a trait, but I guess people don't like that?
[23:01:22] <pcwalton> the reason why I don't want ~ is unfamiliarity, again
[23:01:42] <o11c> IMHO ~ is too small for something that does mallocation
[23:01:44] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[23:01:56] <tikue__> o11c: i think that's a very strong argument against ~
[23:01:57] <o11c> 'new' is just the right length
[23:01:58] <pcwalton> o11c: that's another good point. I was tutoring Rust to people
[23:02:04] <pcwalton> and I found that they allocated a *lot*
[23:02:07] <bjz_> pcwalton: yeah, o11c is right
[23:02:12] <SiegeLord> When I started C++, I used new alot
[23:02:14] *** Joins: Ralith (ralith@A8995AA9.62B6AF6A.922221DB.IP)
[23:02:14] <pcwalton> because ~ is just way too easy to sprinkle everywhere
[23:02:20] <SiegeLord> Because I thought new was how you made new objects
[23:02:24] <o11c> of course, the fact that in Rust you have to name your ctors is a downside
[23:02:29] <tikue__> OTOH `new` sounds like it's what you should use by default
[23:02:36] <pcwalton> maybe we can just hardwire "Default" into the compiler
[23:02:39] <bjz_> pcwalton: `new` is a good way of ergonomically discoraging allocation
[23:02:44] <Thiez> people who come from java are still going to new everything
[23:02:45] <o11c> maybe 'alloc'
[23:02:50] <o11c> or even 'unique' ?
[23:02:52] <pcwalton> I feel like you should name 1+-argument constructors from_whatever
[23:02:54] <tikue__> Thiez: yeah that's what i'm thinking
[23:02:58] <pcwalton> or with_whatever
[23:03:01] <pcwalton> Array::with_capacity(2)
[23:03:09] <bjz_> pcwalton: that
[23:03:11] <pcwalton> new Array(2) is ambiguous at first sight anyway
[23:03:21] <bjz_> *that's what I nromally do
[23:03:25] <pcwalton> does it mean [ 2 ], or [ 0, 0 ]?
[23:03:28] <mark_edward> pcwalton, the error i posted disappears if i get rid of my generic Drop impl...
[23:03:35] <benh> (let's compromise on [2, 2]!)
[23:03:36] <pcwalton> mark_edward: iiinteresting
[23:03:43] <o11c> yeah, I don't think there's a serious alternative to named ctors
[23:03:45] <pcwalton> bjz_: yeah, I've adopted that convention throughout Servo and I find it beautiful
[23:03:50] <kimundi> Oh, I just remembered a Idea for syntacic sugar that might make the Vec<T>, Slice<T> situation less verbose
[23:04:10] <pcwalton> and I am sympathetic to SiegeLord's concern about ::init()
[23:04:15] <o11c> still ... the fact that 'new' in Rust takes an expression, not a ctor name is kind of mind boggling
[23:04:25] <bjz_> pcwalton: I don't do it for my vector types though: Vector::new(1, 2, 3)
[23:04:33] <SiegeLord> Well, then it's new T::from_foo(5); vs new T(5); vs ~T::from_foo(5);
[23:04:49] <pcwalton> I think "new" looks the best of those :P
[23:04:53] <pcwalton> but that's probably my bias
[23:04:54] <kimundi> How about using the 'alloc' keyword as proposed?
[23:04:58] <sp3d> how do e.g. arena allocators play into "new"?
[23:04:59] <o11c> what about new(T(5)) ?
[23:05:09] <tikue__> i kind of like alloc!
[23:05:09] <SiegeLord> I don't know how often I even have zero-argument constructors
[23:05:10] <pcwalton> sp3d: there is a placement new form
[23:05:15] <pcwalton> new(EXPR) EXPR
[23:05:24] <sp3d> ah, so new is heap-default but works for any allocator
[23:05:31] <o11c> alloc(T(5)) ...
[23:05:32] <sp3d> that seems reasonable, as long as new doesn't mean heap
[23:05:33] <pcwalton> where EXPR is some expression that implements Allocator
[23:05:55] <SiegeLord> 'alloc' is why I suggested @... it starts with the same letter ;)
[23:06:01] <o11c> alloc(T(5), allocator) ...
[23:06:04] <pcwalton> and if you leave off the (EXPR) you get *T
[23:06:04] <kimundi> Anyway, syntatic idea: Instead of OwnVec<T> SmallVec<T> etc, somehow allow to name the type Own[T] and Small[T]
[23:06:17] <SiegeLord> Isn't that DST?
[23:06:39] <pcwalton> why not just Vec<T> and Small<T> ? :)
[23:06:42] <pcwalton> same number of letters
[23:06:45] <kimundi> Thsi would just be syntactic sugar
[23:06:45] <ssbr> alloc::<allocator>(T(5))
[23:06:51] <ChrisMorgan> SiegeLord: have "@lloc" as a keyword! :P
[23:06:59] <pcwalton> this is is actually a strong argument for keeping ~T as part of the language instead of a library actually
[23:07:00] <SiegeLord> Ehehehe
[23:07:06] <pcwalton> the fact that it's hardwired into "new"
[23:07:07] <bjz_> ChrisMorgan: atlloc?
[23:07:12] <bjz_> :P
[23:08:09] <ssbr> let's not become ATS please
[23:08:09] <Thiez> for the record, placement new is actually quite amazing and I like it
[23:08:15] <tikue__> i think [T] for VecSlice is nice, but I don't like &str as much because of the incongruence
[23:08:24] <ssbr> ("m@lloc" anyone?)
[23:08:35] <pcwalton> ssbr: do you know why they do that?
[23:08:38] <pcwalton> abst@ype
[23:08:41] <bjz_> ssbr: heh, ATS
[23:08:41] <pcwalton> it's the strangest syntax I've seen
[23:08:43] <ssbr> pcwalton: I really don't.
[23:08:56] <pcwalton> I figured there must be a reason
[23:09:09] <ssbr> The inconsistency of symbol usage and placement in ATS is frightening.
[23:09:46] <pcwalton> I suspect syntax just isn't a priority for them
[23:10:01] <tikue__> what would &mut [T] become if &[T] ==> [T]
[23:10:05] <o11c> incidentally, I think it's a mistake to not have different string classes ... in C++ I have 7 and plan another one
[23:10:05] <pcwalton> mut [T]
[23:10:25] <pcwalton> o11c: yeah. there has to be some type of string built into the compiler because "" has to mean something as a static
[23:10:30] <tikue__> oh right, because [T] would just be a value at that point
[23:10:42] <pcwalton> but beyond that I think all custom strings should just be regular ol' objects
[23:10:51] <tikue__> this all sounds very reasonable to me
[23:11:09] <Thiez> one thing I rather like about java is that everyone uses String
[23:11:17] *** Joins: valenting (Thunderbir@808EE6B5.84D5EFD5.FB866788.IP)
[23:11:27] <o11c> I use the same class for static strings and borrowed string slices
[23:11:33] <pcwalton> sadly we can't have "str" be for *everything* because it doesn't own its storage
[23:11:38] <teratorn> pcwalton: I believe you assertion about the familiarity problem of '~' is unfounded :)  if you're worried about selling C++ guys, I can say (as a C/C++ guy who would *love* to use Rust to augment our C++ codebase) that a big part of my job will be doing FFI in rust *to* C/C++ - so having Rust provide '*' as that pointer makes tons of sense. Learning ~ wasn't a big deal (at least for me)
[23:11:51] <pcwalton> I think most FFI uses of * can be &
[23:11:56] <pcwalton> that's a hypothesis of course
[23:12:02] <pcwalton> but & works just fine in your FFI
[23:12:20] *** Quits: autra (augustin@moz-BE76895F.fbx.proxad.net) (Ping timeout)
[23:12:28] <bjz_> pcwalton: could we define some goals? like: reduce non-overloadable sugar. discourage spurious allocation.
[23:12:36] *** Joins: canhtak (canhtak@moz-43EC0376.wl.t.ulaval.ca)
[23:12:47] *** Quits: lfox (lfox@moz-343B6F0C.nyc.biz.rr.com) (Quit: ZZZzzz…)
[23:12:49] <tikue__> don't forget "make it less confusing"
[23:12:57] <pcwalton> yeah, make it look familiar
[23:12:57] <teratorn> pcwalton: how does & get you an unsafe pointer?
[23:13:01] <benh> I kinda assumed it was bad form to have FFI decls with non-C-style types in them
[23:13:13] <tikue__> teratorn: cast it
[23:13:15] <pcwalton> teratorn: it doesn't, but you can put them in the declarations of your C functions
[23:13:17] <pcwalton> you don't have to cast
[23:13:21] <bjz_> pcwalton: i'm not sure 'more familiar' is always 'less confusing'
[23:13:26] <tikue__> oh ok
[23:13:34] *** Quits: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net) (Ping timeout)
[23:14:10] <kimundi> bjz++
[23:14:24] <Thiez> so what would be the ultimate 'less confusing' goal? What is a reasonable time for someone to pick up a new language, and where is rust now on that scale, and what is the goal?
[23:14:25] <SiegeLord> You'd use Option<&> when you need NULL, I assume
[23:14:32] <teratorn> pcwalton: ah well, that's just useful for exposing a Rust function *to* C?
[23:14:52] <benh> Getting rid of ptr::null() in favor of making everybody use Option<*T>/<&T> is kinda tempting :D
[23:15:08] <Thiez> are you really supposed to rely on Option<&T> to be pointer-size?
[23:15:21] <Thiez> I thought it was bad to rely on the representation of enums since that was undefined?
[23:15:25] <brson> I do not think that using &T for native interop is generally a good idea unless native pointers actually have a lifetime
[23:15:27] <SiegeLord> In this case it is
[23:15:32] <Thiez> (I know the opitimization happens, but are you allowed to rely on it?)
[23:15:43] <bjz_> pcwalton: perhaps 'take the best of the familiar' woruld be better? like & for references, * for deref are really good examples of good familiar syntax. * for rawptrs less so 
[23:15:55] <benh> for rawptrs?
[23:16:02] <kimundi> Thiez: It needs to be written down, but the optimization should always happen
[23:16:02] <pcwalton> sure
[23:16:12] <o11c> * for raw is familiar
[23:16:12] <bjz_> benh: ffi pointers
[23:16:17] <o11c> which IMO is a bad thing
[23:16:19] <benh> Seems pretty familiar
[23:16:27] <pcwalton> I think reducing the number of built-in pointers is a good goal
[23:16:30] <kimundi> Thiez: Of course, you should not cast yourself with transmute, but let a method handle the conversion :P
[23:16:32] *** Quits: rofrol_home (Mibbit@moz-F40C9BE0.threembb.ie) (Quit: http://www.mibbit.com ajax IRC Client)
[23:16:32] <pcwalton> the biggest stigma rust has is too many pointers
[23:16:36] <pcwalton> and it's not just trolls
[23:16:59] <o11c> demoting raw and gc sounds good
[23:17:04] <SiegeLord> Removing * altogether would make unsafe code a little clunky to write... I understand you want to use * occasionally
[23:17:06] <bjz_> pcwalton: yeah, reducing builtins is good
[23:17:10] <o11c> that leaves just unique and borrowed
[23:17:26] <Thiez> I think that's mostly because people don't like new things. Once you remove the different pointer types people will be complaining about 'fn' or lifetimes :p
[23:17:28] *** Joins: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net)
[23:17:29] <teratorn> o11c: how about just demoting gc? then that leaves all of TWO normal-Rust-use pointers :)
[23:17:31] <pcwalton> the nice thing about having just unique and borrowed is that it corresponds to pointers and references in C++, at least idiomatic use
[23:17:32] <benh> pcwalton: is that from people who've read the FFI tutorial, or already just from ~ and & (and @)?
[23:17:32] <bjz_> SiegeLord: I'm only talking type sigs
[23:17:46] <SiegeLord> bjz_: So * will remain outside of them?
[23:17:50] <bjz_> SiegeLord: currently you can't construct with * anyway
[23:17:51] <pcwalton> benh: I think it's &/~/@ but removing @ didn't help
[23:17:55] <pcwalton> although it's not gone from the tutorial
[23:18:13] <kimundi> pcwalton: But it's also a fact that we don't have more pointers than C++. We just offload stuff from the programmers head into different types a lot
[23:18:17] <o11c> C++ has ~ in the library, but there are good reasons to not do that
[23:18:21] <ssbr> I distinctly remember complaining about how there's ~, &, &mut, @, @mut, *, and *mut
[23:18:25] <pcwalton> kimundi: sure, but people aren't buying it
[23:18:29] <bjz_> SiegeLord: which is a confusing diffenence to ~
[23:18:29] <ssbr> (of course, there's no ~mut)
[23:18:42] <sp3d> removing mutability removes almost half our pointer types, shouldn't we just do that :|
[23:18:44] <ssbr> (For what that's worth.)
[23:18:46] <pcwalton> https://news.ycombinator.com/item?id=6742887
[23:18:47] <benh> I feel vaguely that the presence of *T in the walled-off unsafe sublanguage shouldn't scare people as much as @ vs ~ does/did
[23:18:50] <pcwalton> this is a very common reaction
[23:19:02] <SiegeLord> bjz_: That's a... current limitation. I assume you'll be able to do new(malloc) T::init()
[23:19:07] <SiegeLord> And that'll return T*
[23:19:33] *** Joins: jordyd (jordyd@9E6CE43B.4B53A366.BB6D8913.IP)
[23:20:18] <teratorn> ssbr: what is that complain founded on though? clearly the semantics for all those things still exist and you need to be aware of all of them to write different types of Rust code...
[23:20:36] <bjz_> sp3d: isn't ergonomicly discouraged mutability one of Rust's great strengths?
[23:20:44] <teratorn> ssbr: Rust just makes it nice and explicit by giving you different pointer types
[23:20:48] <Thiez> bjz_: ++
[23:20:56] <pcwalton> sp3d: can't do that without compromising soundness anyway
[23:20:57] <ssbr> teratorn: At first my complaint was just that it's ludicrous. But in fairness, they all have markedly different rules, and some are effectively superfluous (in that they don't need to be their own special syntax)
[23:21:08] <pcwalton> if you only had &mut the borrow check would be way too restrictive
[23:21:19] <ssbr> the rules for * vs *mut are different from & vs &mut are different from @ and @mut, in particular.
[23:21:29] <teratorn> ssbr: well, @ is gone for sure now isn't it? can't that be enough? ;)
[23:21:31] <Thiez> the * and *mut distinction could go away, I think I've heard that being discussed a while ago
[23:21:37] <pcwalton> I don't see people complaining about D's pointer types compared to Rust's pointer types, even though D has just as many
[23:21:42] <pcwalton> even Walter Bright complained
[23:21:43] <o11c> note sure why you need @mut
[23:21:48] <pcwalton> we don't need @mut
[23:21:57] <ssbr> teratorn: Moving @ away resolves a lot. @'s interaction with the other pointer types was confusing to me personally.
[23:22:06] <kimundi> pcwalton: Anyway, with the removal of @ as a sigil, and with not doing DST for vectors I wouldn't even mind changing ~ to * that much. Because all that's left for that sigil at that point is introducing indirection for data structures
[23:22:13] <ssbr> well, @'s relation to &, really.
[23:22:16] <pcwalton> kimundi: yup
[23:22:27] <ssbr> (IIRC there was funkiness from going from @mut to &mut?)
[23:22:28] <SiegeLord> D has... two I think?
[23:22:31] <pcwalton> in fact the only reason it would be in the language would be to justify hardwiring it to "new"
[23:22:37] <pcwalton> SiegeLord: it has unique_ptr and shared_ptr doesn't it?
[23:22:37] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[23:22:41] <SiegeLord> No, three
[23:22:46] <SiegeLord> pcwalton: Those don't count :P
[23:22:54] <SiegeLord> D has *, ref and out
[23:23:00] <pcwalton> aha, but that's exactly my point
[23:23:01] *** Joins: jstevans (Instantbir@moz-F5068E88.bootp.virginia.edu)
[23:23:01] *** Joins: jesse99 (jesse99@moz-8B1E0C5D.hsd1.wa.comcast.net)
[23:23:04] <Thiez> they should count
[23:23:06] <pcwalton> *why* doesn't it count if they're in the library as opposed to the language?
[23:23:10] <pcwalton> this is precisely my point
[23:23:22] <SiegeLord> Well, they don't count to D's fans
[23:23:24] <pcwalton> by moving them out of the language they start to "not count" in people's heads
[23:23:25] *** pmoore is now known as pmoore|away
[23:23:36] <pcwalton> and that's why I've been so interested in it
[23:23:39] <ssbr> pcwalton++
[23:23:41] <kimundi> pcwalton: I'm just skeptical about the implication of that change... That a concise-on-char notation turns into a N-char encoding of just another type, that brings with it all that <T> generic nesting syntax
[23:23:45] <benh> D has reference types as a pointer type imo
[23:23:54] *** Quits: jesse99 (jesse99@moz-8B1E0C5D.hsd1.wa.comcast.net) (Client exited)
[23:23:56] <pcwalton> http://dlang.org/phobos/std_typecons.html#.Unique
[23:24:02] * tikue__ is leaving and expects a distilled summary of the result of this conversation when he returns :P
[23:24:10] *** Joins: jesse99 (jesse99@moz-8B1E0C5D.hsd1.wa.comcast.net)
[23:24:12] <SiegeLord> Well, then it's 4 types... which is exactly as many as in Rust, hah
[23:24:17] <SiegeLord> Different 4 though
[23:24:45] <SiegeLord> * is *, ref is &, out has no Rust equivalent and the reference type on is Option<&>
[23:24:53] <kimundi> pcwalton: I'm all for making it generic, not hardcoded to a specific type... I'd just be happier if that would happen with some kind of syntax that approaches todays concise-ness
[23:25:12] <o11c> hm ... about the library. If there was a a 'Borrow' trait providing a conversion to T&, they wouldn't be inferior ...
[23:25:12] <pcwalton> SiegeLord: is out like &mut?
[23:25:25] <pcwalton> o11c: nmatsakis has a sketch of such a thing :)
[23:25:32] <SiegeLord> out is like ref, but I believe you are forced to assign to it in a function
[23:25:42] <pcwalton> ah ok
[23:25:56] <benh> pcwalton: In that case it's probably because you can write fairly idiomatic D with just regular pointers and the reference type references, which are "clearly" politically acceptable because they're all over Java/C#, while our ~ is a bunch more central to idioms than their std.somescarymodule.Unique 
[23:25:56] <o11c> I really love how C++ allows type cooercion, except for a couple of conflicts
[23:25:57] <SiegeLord> It's kind of like our implicit return pointer, but in D they are explicit and you can have several
[23:26:07] <pcwalton> hmm, D doesn't even have move semantics
[23:26:09] <pcwalton> that's strange
[23:26:24] <pcwalton> SiegeLord: I guess you don't need it as much if you can return tuples
[23:26:30] <SiegeLord> No
[23:26:42] <SiegeLord> (you don't need it as much)
[23:26:44] <bjz_> kimundi: how would you feel about ergonomically discouraging expensive operations though?
[23:26:51] <benh> "if you idiomatically allocate everything on the GC heap"? 
[23:27:05] <benh> What does idiomatic non-GC D look like?
[23:27:17] <pcwalton> I don't know, do people actually write D that way?
[23:27:24] <SiegeLord> I don't think that's idiomatic D
[23:27:25] *** Quits: jordyd (jordyd@9E6CE43B.4B53A366.BB6D8913.IP) (Ping timeout)
[23:27:28] <bjz_> benh: non-GC D isn't really ideomatic
[23:27:38] <SiegeLord> It looks kind of like C
[23:27:40] <bjz_> benh: but I suspect it's simplar to C
[23:28:00] <pcwalton> oh, so you just new and delete stuff
[23:28:01] <SiegeLord> Except you can use scope(exit) to simplify error handling
[23:28:02] <bjz_> benh: lots of unsafe stuff that is hidden
[23:28:02] <pcwalton> and don't use RAII?
[23:28:03] *** Quits: valenting (Thunderbir@808EE6B5.84D5EFD5.FB866788.IP) (Ping timeout)
[23:28:12] <pcwalton> except through scope statements
[23:28:15] <SiegeLord> I think you can use RAII... but I don't know for sure
[23:28:16] *** Quits: jlong (jlong@moz-6DFDE846.socal.res.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[23:28:18] <kimundi> bjz_: That makes sense too. I'd just like the the actual type notation, and the slice/reference part of it to be short.
[23:28:25] <benh> D does have RAII with their struct types, doesn't it?
[23:28:30] <pcwalton> it does
[23:28:30] <bjz_> kimundi: that would be nice
[23:28:32] *** Joins: valenting (Thunderbir@808EE6B5.84D5EFD5.FB866788.IP)
[23:28:42] *** Quits: tikue__ (tkuehn@1A16C144.CD72397.689607DE.IP) (Quit: tikue__)
[23:28:48] <bjz_> kimundi: I agree with that
[23:28:49] <pcwalton> I just don't know whether people use T * or use std.typecons.Unique!(T) or shared_ptr!(T)
[23:29:26] <pcwalton> I guess they just don't
[23:29:31] <bjz_> pcwalton: I doubt folks use Unique all that much
[23:29:34] <benh> I figure all the people on hn who read about D read the bits where everyone just uses GC'd class references and they internalize that D is really simple with just one pointer type, why can't we do that, etc, but maybe I'm unfair here :(
[23:29:41] <pcwalton> benh: no, I think that's true.
[23:29:43] <pcwalton> they do that in Nimrod too
[23:29:46] <bjz_> pcwalton: you could ask them on #d though
[23:29:47] <SiegeLord> Well, I haven't had to avoid GC myself... so I wouldn't know
[23:30:07] <pcwalton> (confession: for Nimrod it *slightly* annoys me because Nimrod cheats...)
[23:30:17] <Thiez> how does Nimrod cheat?
[23:30:22] <pcwalton> it's easy to have a soft real time GC if it's not thread safe :)
[23:30:29] <bjz_> pcwalton: always better to ask from the horses mouth
[23:30:29] * benh wonders whether using !() template syntax is giving D a net cuteness benefit
[23:30:29] <pcwalton> Nimrod just crashes if you share objects between threads
[23:30:30] <Thiez> ah, like that
[23:30:35] <SiegeLord> Clasically though, for non-memory resources D people tend to harp scope(exit) and not RAII
[23:30:45] <pcwalton> but that's not something you can realistically use
[23:30:57] <SiegeLord> That may be the case since RAII is historically a new invention
[23:30:59] <pcwalton> in order to make Nimrod's GC thread safe with their technique (deferred ref counting) they're going to have to stop the world
[23:31:04] <SiegeLord> (In D, that is)
[23:31:05] <pcwalton> at which point it won't be soft real time anymore
[23:31:31] <pcwalton> and because they compile to C they can't do moving GC
[23:31:42] <pcwalton> oh well. it's good marketing anyway
[23:31:43] <pcwalton> (end snark)
[23:32:09] *** Quits: alonlevy (alon@moz-EB7C9CF3.telavivmakers.org) (Ping timeout)
[23:32:11] <pcwalton> (but seriously, what Araq has done with Nimrod is honestly nothing short of amazing given that it's one person, I could never do that)
[23:32:41] <bjz_> https://etherpad.mozilla.org/x1J5klxYV0
[23:32:50] <bjz_> pcwalton: ++
[23:33:02] * pcwalton just writes silly NES emulators in his spare time
[23:33:24] <pcwalton> (speaking of which, it's ironic that my barely functional NES emulator gets the title of "*practical* systems programming in Rust")
[23:33:30] <pcwalton> but I'll do the best I can with the talk ;)
[23:33:46] <dbaupp> bjz_: is spelling syntax correctly a goal too? :P
[23:34:26] <Thiez> bjz_: is it really a goal to reduce built-in magic, or just the built-in magic unavailable to library types?
[23:34:48] <benh> Thiez: I think that ~ allocates while looking so innocent is "built-in magic"
[23:34:53] *** Quits: tulloch (tulloch@moz-1C33A2E7.nat.csx.cam.ac.uk) (Ping timeout)
[23:34:55] <bjz_> Thiez: yeah, that is a better clarification
[23:34:59] *** Quits: TeXitoi (texitoi@moz-EA958D66.texitoi.eu) (Ping timeout)
[23:35:02] <SiegeLord> I don't think that's magic, it's sugar
[23:35:15] <SiegeLord> Few people like magic... but people like sugar
[23:35:27] <teratorn> actually I remember being boggled by lack of '*' and the unfamiliar ~, & and @ in the tutorial when first learning - then it started to sink in - then later I learned that '*' was actually in the language as the unsafe pointer, and it just "clicked"
[23:35:29] <Thiez> benh: sure, but a 'fn multiply_by_two' could also do allocation
[23:35:46] <Thiez> well, that's not really a good example
[23:35:47] <benh> yeah, hence it's built-in magic that's available to library types that we might still want to get rid of :)
[23:36:00] <pcwalton> when dherman gives talks about rust he just says that "~" is the pointer type in rust at first
[23:36:10] <pcwalton> and it makes it much easier to explain
[23:36:14] <pcwalton> even though it's slightly a lie
[23:36:25] <Thiez> but you're always going to run into stuff that perform potentially expensive magic that you won't know about unless you read the source of everything
[23:36:26] *** Joins: tulloch (tulloch@moz-6809CC86.nat.csx.cam.ac.uk)
[23:36:31] <Thiez> performs*
[23:36:36] <teratorn> SiegeLord: yeah I agree. syntax is powerful, so what if malloc() hides behind it
[23:36:41] *** Quits: Ralith (ralith@A8995AA9.62B6AF6A.922221DB.IP) (Ping timeout)
[23:36:49] <teratorn> SiegeLord: it's basically the first thing you learn
[23:37:17] <SiegeLord> Also this removal of magic needs to be done carefully, otherwise we'll just make everything ugly
[23:37:23] <pcwalton> btw, those who like shorter syntax, remember that &fn is going away ;)
[23:37:35] * pcwalton is working on it right now
[23:37:52] <kimundi> pcwalton: Sure, that is a good change! :)
[23:37:59] <benh> &fn competes with "function()" in lua/js imo ;)
[23:38:00] <teratorn> pcwalton: consider making a small ffi example with * pointers the first thing in the tutorial - then I think introducing the actual Rust pointers will sink in easier ;)
[23:38:20] <pcwalton> mmm, I'd rather not introduce too many types of pointers too fast
[23:38:40] <sp3d> a C migration guide might do well to start that way though
[23:38:40] <benh> with |A|->R closures, you can write weird stuff like let x:<>||:=||(); or something like that :D
[23:39:01] <teratorn> pcwalton: heh well, I'm just trying to extract some value from my experience learning Rust so far - knowing that * existed sooner would have actually helped me I think...
[23:39:15] <pcwalton> sure, it's well taken
[23:39:15] <bjz_> teratorn: why? ffi is not really central to Rust
[23:39:33] <benh> Maybe we can just do ~T -> Box<T>, ~expr -> box(expr) and never mention the word 'pointer' ;)
[23:39:36] <pcwalton> benh: *shiver*
[23:39:42] <bjz_> teratorn: and this is coming from somebody who has done a ton of ffi work
[23:39:46] <teratorn> bjz_: because coming from C/C++ you wonder where the * went off to...
[23:39:47] <pcwalton> I remember the meme that was going around "oh great, now [](){}() is valid C++"
[23:39:54] <teratorn> bjz_: that's all
[23:40:01] <pcwalton> which isn't really fair of course, the C++ syntactic space is SO constrained
[23:40:05] *** Joins: jordyd (jordyd@moz-FEA707DF.seg163.ucf.edu)
[23:40:07] <kimundi> Quiz: Which of the following type expressions do not compile today: 1) &|| 2) 'a || 3) &'a || 4) &'a 'a ||
[23:40:14] <pcwalton> at least they don't have automatic semicolon insertion to deal with
[23:40:19] <bjz_> teratorn: it would make more sense for somebody coming from a C background, but it would be better in a specific tutorial
[23:40:31] <benh> [](){} is fairly good syntax as far as "what can we nail on top of C++" goes for a constraint, imo
[23:40:37] <pcwalton> (in javascript almost any new syntax you might want to add will not be backwards compatible because of automatic semicolon insertion, it's maddening)
[23:40:52] *** Quits: mihneadb (mihneadb@6CBB3868.3689173D.FCAAE698.IP) (Quit: Bye)
[23:40:52] <Thiez> kimundi: 1)
[23:40:59] *** Joins: Ralith (ralith@A8995AA9.62B6AF6A.922221DB.IP)
[23:41:08] <Thiez> '1)' will obviously complain about unmatched paranthesis
[23:41:10] <Thiez> :p
[23:41:19] <benh> 4?
[23:41:31] <benh> I thought the || lifetime goes into <>
[23:41:53] <kimundi> Trick question, all 4 parse and compile today! ;)
[23:42:20] <teratorn> bjz_: you wouldn't even have to give an example. just when introducing Rust pointers, you mention that * exists and what it is for (then it clicks in the C/C++ developers head "oh, ok, basically the same as raw pointers in C..."
[23:42:35] <benh> oh, i'm behind :(
[23:42:54] <pcwalton> C++ developers are actually usually the ones who are OK with multiple pointer types
[23:42:56] <SiegeLord> That said... 'new' will probably be rare in Rust anyway... my issue with 'new' is that it leads to 'init' being the zero-argument constructor
[23:42:57] <pcwalton> as they're used to them in C++
[23:43:19] <pcwalton> SiegeLord: that's well taken and I don't love "init" either.
[23:43:55] <bjz_> SiegeLord: `new` should probably be for allocation, not construction
[23:44:18] <SiegeLord> bjz_: Why do you think so?
[23:44:30] <kimundi> what'S wrong with "let x = alloc Foo::new();" ?
[23:44:31] <dbaupp> bjz_: what's the difference?
[23:44:48] <benh> kimundi++ :)
[23:45:01] <dbaupp> bjz_: smart pointers are designed to be always valid, so allocation is construction.
[23:45:06] <kimundi> Or "let x = box Foo::new();"
[23:45:18] *** Quits: valenting (Thunderbir@808EE6B5.84D5EFD5.FB866788.IP) (Ping timeout)
[23:45:25] <benh> box is probably not good in the general "weird user defined allocator" case
[23:45:27] <o11c> I definitely prefer Foo::init() over Foo::new()
[23:45:56] <benh> in my suggestion it'd just be a preluded function to make the tutorial examples easy or something ;)
[23:46:07] <pcwalton> [[Foo alloc] init]
[23:46:15] <kimundi> :P
[23:46:31] <SiegeLord> Well, what does 'init' stand for?
[23:46:32] <pcwalton> for april fool's day I will propose changing the hash map syntax to [[RSHashMap alloc] initWithObjectsAndKeys: @"hello", @"world", nil];
[23:46:39] <benh> Are those hypothetical named constructors still formally returning T
[23:46:41] <benh> ?
[23:46:43] <SiegeLord> Initialize? How can you initialize nothing :P
[23:46:45] <pcwalton> benh: yeah
[23:46:52] <acrichto> pcwalton: [RsHashMap initializeWithFactoryBeanDefaultSettings]
[23:47:02] <ChrisMorgan> We don't have the word "rust" appearing frequently enough in the language, either.
[23:47:12] <Thiez> rust doesn't have beans, it has nails
[23:47:13] <benh> In that case I think init is really weird because I'm used to all these init functions taking uninitialized malloc'd memory :)
[23:47:24] <pcwalton> acrichto: I had to google to make sure that wasn't actually an objective-c method name
[23:47:33] <acrichto> please no
[23:47:48] *** Quits: spott (spott@D76D9638.B3FAD41.E7673F62.IP) (Client exited)
[23:48:15] <benh> ChrisMorgan: pf, just declare all your top-level functions with an explicit ABI
[23:48:28] <pcwalton> when obj-c literally has initWithBitmapDataPlanes:pixelsWide:pixelsHigh:bitsPerSample:samplesPerPixel:hasAlpha:isPlanar:colorSpaceName:bitmapFormat:bytesPerRow:bitsPerPixel:
[23:48:29] <ChrisMorgan> Yeah, that's a start.
[23:48:42] *** Quits: eternaleye (eternaleye@moz-5668AFCB.hsd1.wa.comcast.net) (Ping timeout)
[23:48:48] <benh> extern mod rust = "std"
[23:48:53] <Thiez> so what would an arena alloc look like with 'new' (or 'init' or whatever)?
[23:49:03] <Eridius> pcwalton: add in newlines, and that's actually readable! Unlike a C function taking 11 arguments
[23:49:15] <pcwalton> Eridius: I do like the way Xcode lines up the colons now
[23:49:26] <kimundi> pcwalton: Is that a name, a path, a parameter list, or a code block? I have no idea how Obj-C works.
[23:49:28] <benh> something like let arena = ArenaAlloc::init(); let obj = new(arena) Object::init();
[23:49:32] *** Joins: eternaleye (eternaleye@moz-5668AFCB.hsd1.wa.comcast.net)
[23:49:35] *** Quits: jordyd (jordyd@moz-FEA707DF.seg163.ucf.edu) (Ping timeout)
[23:49:40] <pcwalton> kimundi: it's a parameter list. methods always have named parameters
[23:49:44] <Thiez> benh: but what would be the type of obj?
[23:49:52] <ChrisMorgan> pcwalton: it's really dreadful that Rust doesn't have an IDE. Just think what we could have achieved if we'd had an IDE with good completion.
[23:49:54] <Eridius> kimundi: it's effectively a method name with infix argument names
[23:49:56] <benh> gee, I dunno.
[23:50:28] <benh> Probably typeof(ArenaAlloc<Foo>::alloc(sizeof(Foo)))......
[23:50:30] <pcwalton> pradeep90 has an Emacs plugin that highlights syntax errors as you type in Rust
[23:50:35] <pcwalton> it's pretty neat and getting closer to an IDE
[23:50:42] <Eridius> kimundi: fundmanetally, the actual selector is exactly what pcwalton typed. But when writing code you say [[NSBitmapImageRep alloc] initWithBitmapDataPlanes:dataPlanesArg pixelsWide:width pixelsHigh:height bitsPerSample:bits ...]
[23:50:46] <Thiez> benh: why thankyou :p
[23:51:04] <pcwalton> Eridius: did you see my revamped rust-cocoa?
[23:51:15] <Eridius> pcwalton: no, I haven't see the original either. I haven't looked at Servo
[23:51:18] *** Quits: eternaleye (eternaleye@moz-5668AFCB.hsd1.wa.comcast.net) (Ping timeout)
[23:51:24] *** Joins: willingc (willingc@moz-B4760708.san.res.rr.com)
[23:51:26] * Eridius has been meaning to investigate the topic of rust-cocoa bridges at some point though
[23:51:27] <pcwalton> you can say "NSBitmapImageRep".send("alloc").send("initWithBitmapDataPlanes:pixelsWide:", (dataPlanes, width))
[23:51:30] <benh> Thiez: I kinda figure it ought to be just &'alloc Foo, but I somehow doubt things are that easy
[23:51:34] <Thiez> but seriously, what trait would an allocator implement to qualify as an allocator, and what should it return
[23:51:41] <kimundi> Eridius: I take that as my cue to finally go to bed, as my brain just decided to shut down after hearing that ;P
[23:51:44] <Eridius> pcwalton: interesting. Does it just assume the argument tuple uses the correct types?
[23:51:48] <pcwalton> Eridius: overloading methods on strings is kind of evil but it makes pretty bindings
[23:51:53] <pcwalton> yeah, it doesn't try to impose any types
[23:51:56] <benh> Thiez: I can see it being up to the allocator too
[23:52:01] <pcwalton> Obj-C is mostly dynamically typed and it just embraces that
[23:52:04] <pcwalton> totally unsafe but it's pretty
[23:52:15] <benh> custom smartpointers for everybody
[23:52:24] <Eridius> my eventual plan is to investigate using BridgeSupport to build a rust crate that declares shims for all known obj-c methods, which impose the correct types before falling back to dynamic dispatch
[23:52:26] *** Joins: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz)
[23:52:33] <pcwalton> Eridius: that would be awesome
[23:52:51] <pcwalton> joined with rust-cocoa that would allow convenient type-safe and convenient dynamic dispatch
[23:52:58] <Eridius> pcwalton: well, obj-c is dynamic dispatch, but the types themselves are not dynamic. objects can be queried to find out what class they are, but you can't mix passing an int and an NSNumber
[23:53:07] <Thiez> benh: so something like 'trait Allocator<T,U>{ fn alloc(t: T) -> U; } and T and U can be whatever?
[23:53:08] <pcwalton> yeah
[23:53:33] *** Joins: eternaleye (eternaleye@moz-5668AFCB.hsd1.wa.comcast.net)
[23:53:34] <SiegeLord> How does Obj-C deal with ABI?
[23:53:39] <Eridius> BridgeSupport will provide the correct types for all system frameworks. Some solution for handling other frameworks will be necessary (I think there's some facility to generate BridgeSupport files for arbitrary frameworks, but I haven't looked into it)
[23:53:50] <pcwalton> class-dump ;)
[23:53:50] <SiegeLord> I though reflection tended to throw a wrench in that idea
[23:53:51] <Eridius> SiegeLord: it usese the C ABI
[23:53:54] <benh> Thiez: ugh, except kinda the other way around because (T, Allocator) uniquely defines U, it's not an additional free variable
[23:54:16] <benh> I think that's a thing we could express if someone gets around to implementing associated types/items ;)
[23:54:22] <Eridius> it's dynamic dispatch, but not reflection (again, you can query an object for its type, but that's not used during method dispatch. Well, aside from querying the receiver to find the class for the method)
[23:54:29] * pcwalton loves class-dump
[23:54:33] *** Joins: toto (yaaic@moz-B234C23B.rev.numericable.fr)
[23:54:49] <SiegeLord> Ah, so the dynamic dispatch solves it... it throws some sort of exception if the arguments are wrong and whatnot?
[23:54:50] <Eridius> SiegeLord: an obj-c method -[Foo doBar:int] is implemented under the hood by a C function that takes arguments (id, SEL, int). 
[23:54:58] *** Joins: jordyd (jordyd@moz-FEA707DF.seg163.ucf.edu)
[23:55:19] <Eridius> and when you send -doBar: to an instance of Foo*, it's equivalent to ((void (*)(id, SEL, int))objc_msgSend)(foo, @selector(doFoo:), intVal)
[23:55:24] <Eridius> SiegeLord: no. It crashes ;)
[23:55:30] <SiegeLord> Ah... lol
[23:55:32] <SiegeLord> Awesome
[23:55:51] <Eridius> the compiler won't let you send a message to a type if it can't figure out the correct types for the method arguments
[23:56:33] <Eridius> i.e. if I have methods -[Foo doBar:int] and -[Bar doBar:NSString*], and I try to call -doBar: on a value typed `id` (which is the generic "any object" type), the compiler will complain that it sees two methods named -doBar: and doesn't know which one I want
[23:56:57] <Eridius> if I type my object as Foo* or Bar* it will work. Conversely, if both -doBar:s have compatible types then the ambiguity is fine because the same method call is generated either way
[23:57:05] *** Quits: lmandel (lmandel@13F2CEC5.7672369.D8E68FF6.IP) (Quit: lmandel)
[23:57:27] <Eridius> the basic takeaway is, if you need reflection on your arguments, every argument needs to be typed `id` to force the caller to give you arguments, and then you can implement the reflection yourself
[23:58:02] <Eridius> (C types can be boxed up in an obj-c type called NSValue, although obviously it won't work right if you have interior pointers into the boxed struct, but then again merely copying the struct would break that)
[23:59:20] <Eridius> And there's actually an api called Key-Value Coding, that provides a reflection-based mechanism to get and set properties on an object. It's even smart enough to box and unbox primitive C types (not arbitrary structs, but things like int, or a small set of known system-defined structs like CGRect)
[23:59:44] <Eridius> but that only works for property access, i.e. getting or setting a value identified by a name with no arguments.
[23:59:45] *** Quits: jordyd (jordyd@moz-FEA707DF.seg163.ucf.edu) (Ping timeout)

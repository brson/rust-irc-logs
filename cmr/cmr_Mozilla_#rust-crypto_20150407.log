[00:06:16] *** Joins: brson (brson@moz-e9i.crj.56.172.IP)
[00:23:06] *** Quits: brson (brson@moz-e9i.crj.56.172.IP) (Quit: leaving)
[00:23:54] <Ilari> Any even semi-usable transport encryption protocols? TLS v1.2 is crap, and looks like they will turn TLS v1.3 into more crap.
[00:30:16] <bascule> Ilari: QUIC? lol
[00:30:47] <bascule> Ilari: seems like Trevor Perrin and Mike Hamburg want to make Noise good, but right now it's... too abstract and ill-specified to be useful
[00:31:09] <bascule> QUIC at least has usage via Google shoving it down Chrome users' throats
[00:31:45] <eternaleye> bascule: Didn't they just recently find notable crypto issues with QUIC though?
[00:32:06] <bascule> I don't think I've seen anything come across the QUIC mailing list like that recently but I wouldn't be surprised
[00:37:25] <Ilari> eternaleye: Dunno, never actually found any working website that would document insides of QUIC crypto protocol.
[00:37:53] <Ilari> eternaleye: I think they discovered that 0RTT anti-replay is busted. But perhaps there was something else too?
[00:39:44] <eternaleye> Ilari: https://docs.google.com/document/d/1RNHkx_VvKWyWg6Lr8SZ-saqsQx7rFV-ev2jRFUoVD34/edit#heading=h.gc1pjawngdz8
[00:40:04] <eternaleye> Ilari: (for the protocol as a whole)
[00:40:11] <eternaleye> Ilari: And https://docs.google.com/document/d/1g5nIXAIkN_Y-7XJW5K45IblHd_L2f5LTaDUDwvZ5L6g/edit
[00:40:16] <eternaleye> Ilari: (for the crypto)
[00:46:34] *** Joins: adu (ajr@moz-0foa9t.md.comcast.net)
[00:52:59] <Ilari> What's wrong with proposed stuff: 1) Much more compicated than seemingly necressary. 2) Weakening of encryption.
[00:54:24] *** Quits: eternaleye (eternaleye@moz-5fh.ehi.245.50.IP) (A TLS packet with unexpected length was received.)
[01:00:33] <adu> weakening is bad
[01:00:48] <adu> but I think complicated is good
[01:01:19] <Ilari> Complicated is bad for two reasons: 1) Easy to get wrong. 2) Difficult to discover mistakes.
[01:02:02] <bascule> Ilari: I think the intent is generalization. The disadvantage is complexity :(
[01:02:06] <bascule> at least that's the case with Noise
[01:02:21] <bascule> Noise has a lot more privacy-preserving goals too
[01:02:24] <bascule> like deniable key exchange
[01:15:24] *** Joins: eternaleye (eternaleye@moz-7ps.ehi.245.50.IP)
[01:16:40] *** Quits: adu (ajr@moz-0foa9t.md.comcast.net) (Client exited)
[01:25:11] *** Quits: erickt (erickt@moz-4hh.6p3.217.74.IP) (Ping timeout: 121 seconds)
[01:41:23] <Ilari> Obviously things like supporting fixedDH certs would cause extra complexity.
[01:52:40] <Ilari> Key exchanges with authentication based on signing can't be deniable, right?
[01:53:19] <bascule> yep
[01:53:26] <bascule> that's why Noise uses an all-DH approach
[01:53:47] <bascule> but it assumes you know the pubkey in advance
[01:53:48] <bascule> somehow
[02:08:35] <Ilari> "OpenSSL's vuln rating system means that RCE in Chrome due to DTLS/WebRTC is less bad than memory leaks in Apache workers."
[02:09:45] <bascule> lolololololol
[02:09:46] <bascule> yeah
[02:09:56] <bascule> I kept saying that during the last round of OpenSSL vulns
[02:10:03] <bascule> and then they all turned out to be relatively minor
[02:10:17] <bascule> like, OpenSSL clasically *did* understate the severity of vulns
[02:10:29] <bascule> then they drummed up all this attention around relatively minor vulnerabilities
[02:32:25] *** Joins: brson (brson@moz-jbg.c9m.56.172.IP)
[02:32:39] *** Quits: brson (brson@moz-jbg.c9m.56.172.IP) (Quit: leaving)
[02:45:20] *** Joins: brson (brson@moz-jbg.c9m.56.172.IP)
[03:08:39] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[03:11:25] *** Quits: brson (brson@moz-jbg.c9m.56.172.IP) (Quit: leaving)
[03:27:37] *** Joins: adu (ajr@moz-0foa9t.md.comcast.net)
[03:53:08] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[03:54:27] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[05:08:46] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[05:12:59] <bascule> eternaleye: so if you want to save the "pam" namespace from doom, maybe you should report your concerns upstream? ;)
[05:19:36] <eternaleye> bascule: There was a loooooong fight over whether crates.io should be namespaced or flat.
[05:19:40] <eternaleye> bascule: It wound up flat.
[05:19:53] <eternaleye> bascule: I'm not jumping into THAT killbox.
[05:20:13] <bascule> hahaha yeah I know
[05:20:31] *** Quits: adu (ajr@moz-0foa9t.md.comcast.net) (Client exited)
[05:20:32] <bascule> I'd say I don't mind a flat first-come-first-serve namespace but...
[05:20:53] <eternaleye> I think github got it right, namespacing-wise.
[05:20:53] <bascule> https://github.com/thoran/HTTP/issues/1
[05:21:13] <bascule> he recently claimed https://rubygems.org/gems/http.rb
[05:21:14] <cmr> github is an entirely different usecase.
[05:21:32] <bascule> here's my library, which I branded "http.rb": https://rubygems.org/gems/http
[05:21:39] <bascule> I guess I should just rename it... again
[05:22:00] <eternaleye> cmr: It's many people publishing their code :P
[05:22:09] <eternaleye> cmr: Sounds like a pretty darn similar use case to me :P
[05:22:30] <bascule> eternaleye: perhaps you can help improve the "pam" Rust module though? ;)
[05:22:44] <eternaleye> bascule: That, I may well do.
[05:22:56] <bascule> I'd like to write PAM modules in Rust
[05:23:05] <bascule> and I'd prefer the main API not be an unsafe free function lol
[05:23:07] <eternaleye> bascule: Of course, it'd basically be a complete rewrite of the API...
[05:23:11] <bascule> yes!
[05:23:14] <bascule> do that! ;)
[05:23:22] <bascule> it's not unheard of in rust-history
[05:23:22] <eternaleye> bascule: The problem then is "Will they merge it"
[05:23:27] <bascule> *shrug*
[05:23:36] <bascule> if they don't, "pam" is doomed to suck forever
[05:23:44] <bascule> that'd be a shame
[05:23:54] <eternaleye> bascule: People doing total rewrites themselves is one thing; someone new coming over and saying "This sucks, lemme replace it"...
[05:24:05] <bascule> more like "here's how I'd do it"
[05:24:25] <eternaleye> bascule: Be honest - with _that_ API? :P
[05:24:31] <bascule> lol
[05:24:39] <bascule> well it's more like go back to the drawing board
[05:25:34] <bascule> but perhaps you can hash out a good API that doesn't involve unsafe-by-default? That'd be cool
[05:25:48] <bascule> I'd like for my PAM modules to be safe ktks
[05:27:08] <eternaleye> Honestly, the first thing would be to properly use &mut vs. &
[05:27:32] <bascule> I don't know if I know how to do that properly yet heh
[05:27:35] <eternaleye> So that the top-level function takes the context as an &mut, and the mutating methods do as well
[05:27:51] <eternaleye> Also, not defining the ffi function as taking an &...
[05:27:51] <bascule> my instinct in crypto-code is to make anything that might contain a secret &mut so I can zero it out when I'm done
[05:28:13] <eternaleye> It should take a *, and then call a Rust native function after translating
[05:28:39] <eternaleye> That lib is both way too automagic, and not magic enough.
[05:28:47] <bascule> hahaha
[05:29:01] <bascule> it seems like it's trying to abstract stuff... poorly
[05:29:29] <eternaleye> bascule: It uses a lifetimed pointer in an FFI signature, but it's & rather than &mut, and then they dangle mutators off of it!
[05:29:31] <bascule> it should probably start as a more bare-metal PAM API that wraps everything up safely
[05:29:50] <bascule> instead of having magical Rust-to-PAM type thunks!
[05:30:22] <bascule> that... don't work?
[05:30:27] <bascule> or do they?
[05:31:07] <eternaleye> bascule: He's got running code that uses the lib
[05:31:25] <eternaleye> bascule: It's just far more magic than it should be (in taking an & without using rust-level coercions)
[05:31:45] <eternaleye> bascule: And not as magic as it ought to be (in being an & that he mutates via raw PAM calls)
[05:31:59] <bascule> if I want to be beta-channel compatible, how do I replace bytes::copy_memory
[05:32:03] <bascule> which I want to do anyway
[05:32:06] <bascule> because it's a secret
[05:32:10] <bascule> and copying secrets sucks!
[05:32:23] <bascule> I'm not even zeroing it out properly yet
[05:32:39] <eternaleye> bascule: Write a C lib, bind to it, call it?
[05:32:44] <bascule> lololol
[05:32:45] <bascule> uhh
[05:32:53] <bascule> surely there's a better way!
[05:33:01] <cmr> bascule: std::ptr::copy I think
[05:33:20] <eternaleye> bascule: Well if you want zeroing, it's that or nightlies
[05:33:37] <bascule> cmr: here's the code: https://github.com/cryptosphere/rust-macaroons/blob/master/src/token.rs#L75
[05:34:03] <bascule> I feel like there should be a non-copying solution to that
[05:34:40] <bascule> especially since that's a copy of a secret from a deserialized copy of a secret
[05:34:54] <eternaleye> Yo dawg
[05:35:03] <bascule> I just can't figure out how to sate Rust's type system to convert a dynamically sized type to a fixed-sized type in that case
[05:35:18] <bascule> like here's a dynamic assertion that it's the right size: https://github.com/cryptosphere/rust-macaroons/blob/master/src/token.rs#L70
[05:35:33] <eternaleye> bascule: Well, there's the clone_from_slice....
[05:35:56] <bascule> how about not copying?
[05:35:56] <bascule> heh
[05:36:03] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[05:36:21] <eternaleye> bascule: https://doc.rust-lang.org/core/slice/trait.SliceExt.html#tymethod.clone_from_slice
[05:36:27] <cmr> yeah, there's no "unpack" operation exposed.
[05:36:46] <cmr> but you'd be copying anyway, to get it onto the stack as a value.
[05:36:56] <eternaleye> bascule: Might be able to customize the deserializer to slam the contents into the right place
[05:39:04] <bascule> I guess one thing I could do is replace this match statement with types: https://github.com/cryptosphere/rust-macaroons/blob/master/src/token.rs#L65
[05:41:04] <eternaleye> One thing that annoys me is that because integer generic parameters aren't in yet, we can't have something like Chunks that returns &[Foo; SIZE] rather than &[Foo]
[05:41:18] <bascule> yeaaaaah
[05:41:28] <bascule> that would be so nice for crypto-traits
[05:41:34] <eternaleye> Yuuuup.
[05:41:38] <bascule> that are otherwise generic around e.g. key size and nonce size
[05:41:47] <bascule> digest size for hash functions
[05:41:56] <eternaleye> Block size for block ciphers.
[05:41:59] <bascule> yah
[05:42:02] <eternaleye> 64bytes for ChaCha
[05:42:08] <Ilari> Hah, I actually run the code through custom preprocessor to have generic integer parameters (and to instantiate with multiple parameters).
[05:42:45] *** Joins: || (taryn@moz-g8toaq.vmsplic.me)
[05:43:19] <||> Are there any crates with RSA signing and verification?
[05:43:42] <||> rust-openssl doesn't seem to expose openssl_sys's interface for it
[05:44:14] <eternaleye> ||: Any particular reason you want RSA in particular?
[05:44:20] <eternaleye> er, any specific reason
[05:45:01] <||> eternaleye: yes
[05:45:02] <||> eternaleye: JWT
[05:45:04] <||> err
[05:45:08] <||> JWS
[05:45:12] <eternaleye> Ah
[05:45:28] <||> I'm planning on implementing an OpenID Connect IDP
[05:45:54] <||> wish they had add ed25519 to the spec and make it a must-implement
[05:47:14] <||> hrm
[05:48:44] <||> looks like there were binding so it but the were removed
[05:48:52] <||> or it wasn't added into master
[06:10:50] <bascule> lol
[06:10:56] <bascule> PROTIP: don't use RSA
[06:11:42] * bascule forces the thought of the entire RSA-powered infrastructure at his workplace into the corner of his mind
[06:12:17] <Ilari> Also, some JWT/JWS libs separate key data from algorithm it is for. Terrible idea, leading to signature forgery vulns.
[06:12:19] <bascule> Ilari: re: replayability
[06:12:28] <bascule> do you dislike timestamps?
[06:12:33] <bascule> they have their problems but...
[06:12:37] <Ilari> bascule: Yes.
[06:12:54] <bascule> I guess it really depends on the context
[06:13:26] <bascule> 5 second windows inside a self-managed datacenter isn't bad at all IMO ;)
[06:13:56] <bascule> keeping time securely is an unsolved problem though, of course
[06:14:54] <bascule> Jacob Appelbaum: "I'll solve this" "Never mind"
[06:15:00] <Ilari> Heck, I think that eithe the rust buildbot or this system has incorrect time (and I think I know which). And it is a few minutes off.
[06:17:34] <Ilari> (At least when I obtain third clock and vote off the bad one, it isn't this system clock that gets voten off).
[06:22:17] <Ilari> Also, I have heard of horrible VM clocks.
[06:26:38] <bascule> Ilari: there's this whole discussion of server time on the TLS list o_O
[06:27:24] <Ilari> The one VM I have seems to have fairly nice clock, even without NTP.
[06:27:32] <bascule> Ilari: Macaroons-based security is all about time-boundedness, IMO
[06:27:47] <bascule> the neat thing is you can make incredibly short-lived credentials that are verifiable in a simple way
[06:28:18] <bascule> if you can't trust time, Macaroons aren't that cool
[06:41:20] <eternaleye> bascule: Personally, I do like the scratching-off-seen-values technique QUIC uses
[06:41:38] <eternaleye> bascule: If it's a single server, mmap + msync makes it relatively easy to persist
[06:41:50] <eternaleye> bascule: And for shared stuff, there's Paxos/Raft/etc.
[06:43:05] <eternaleye> bascule: In fact, a finger tree might work really well for that...
[06:43:09] <bascule> for what now?
[06:43:27] <eternaleye> bascule: For replay-prevention of the first flight
[06:43:42] <eternaleye> bascule: It costs in storage, but storage is cheap.
[06:43:50] <bascule> using timestamps is a pretty shitty approach to replay prevention
[06:43:59] <bascule> but really convenient with a Macaroons-like credential
[06:44:47] <eternaleye> bascule: It's shitty if you can't buffer enough to tolerate significant skew
[06:45:08] <eternaleye> bascule: That's where being able to use a persistent data structure in mmapped memory is nice
[06:45:37] <bascule> for a structure like that, pure capabilities would be better than Macaroons
[06:45:42] <bascule> Macaroons are credentials
[06:45:55] <eternaleye> bascule: I think we're talking about different things
[06:46:07] <bascule> but the holder of one can say "you can carry out this action in the next 5 seconds per my wall time"
[06:46:09] <eternaleye> bascule: I'm talking about the first flight of 0rtt
[06:46:12] <bascule> eternaleye: very much so
[06:46:14] <bascule> haha
[06:46:20] <bascule> okay yes that's very different
[06:46:52] <bascule> there's a way 0-rtt can work and be not-sucky
[06:47:00] <bascule> you have an introducer who mints keys in advance
[06:47:05] <bascule> lots of keys
[06:47:08] <bascule> one for each introduction
[06:47:12] <bascule> pubkeys
[06:47:17] <bascule> ECC D-H keys
[06:47:25] <eternaleye> bascule: So, CapTP introductions :P
[06:47:28] <bascule> lol
[06:47:32] <bascule> sure something like that
[06:48:01] <bascule> you authenticate to the introducer, get some keys, and then each introduction they're burned from your perspective
[06:48:04] <bascule> single use
[06:48:27] <eternaleye> bascule: I'm not disagreeing; the problem there is the requirement that you already know an introducer valid for who you want to contact.
[06:48:37] <eternaleye> bascule: The issue there becomes scalability and discovery.
[06:48:49] <bascule> yeah, great for a managed datacenter use case
[06:48:57] <bascule> not so great for a federated use case
[06:49:17] <eternaleye> bascule: That's where the scratch-marking case is useful.
[06:49:23] <bascule> but do people really want to do openly federated 0-RTT?
[06:49:31] <eternaleye> bascule: yes, they do.
[06:49:41] <bascule> how do you get introduced?
[06:49:43] <bascule> via a DHT?
[06:49:53] <eternaleye> bascule: You're too optimistic.
[06:49:57] <bascule> heh
[06:50:11] <eternaleye> bascule: Google "leap of faith" and "sufficient"
[06:50:25] <bascule> things are a lot easier in a datacenter where theoretically there's some sort of centrally-managed order to the world
[06:50:30] <eternaleye> bascule: TOFU all the way.
[06:50:35] <bascule> lololololol
[06:50:46] <eternaleye> bascule: I find it hilarious and awful, yes.
[06:51:02] <bascule> wait
[06:51:04] <bascule> I know
[06:51:05] <bascule> blockchain
[06:51:24] <bascule> problem solved
[06:51:26] <eternaleye> bascule: The scratch-marking trick at least allows first-flight half-ephemeral, second-flight full-ephemeral, zero-rtt without replay
[06:51:35] * bascule -> exit the building
[06:51:48] <eternaleye> bascule: It just requires storage proportional to tolerance of clock skew
[06:51:53] <bascule> eternaleye: what if you burn a keypair per introduction?
[06:52:47] <bascule> I don't get what problem people are trying to solve via 0-RTT without some sort of introducer
[06:53:06] <eternaleye> bascule: Ricing.
[06:53:14] <bascule> sign a keypair, publish it somewhere, as soon as someone uses it for an introduction that keypair is burned
[06:53:43] <bascule> or you can do the Noise-style deniable triple-DH thing
[06:53:50] <bascule> "OPTLS"?
[06:53:53] <eternaleye> bascule: That's not zero RTT, it just pushes the RTT off to a third endpoint!
[06:54:02] <bascule> sure
[06:54:07] <eternaleye> (the burn-a-keypair)
[06:54:45] <bascule> it's more you have an open channel somewhere else
[06:54:58] <bascule> and you get a thing ("capability") back that lets you talk to a different peer
[06:55:02] <eternaleye> But first-flight having reduced (but not eliminated) key erasure compared to the rest, without risking replays, is entirely possible
[06:55:16] <bascule> the capability is a D-H public key
[06:55:54] <bascule> now you can use that public key to talk to that peer and immediately establish a session and negotiate a symmetric key without any sort of round trip
[06:55:57] <bascule> in theory
[06:56:10] <eternaleye> But that's just it
[06:56:27] <eternaleye> Obtaining the capability happens at the same point in the protocol as the "elided" RTT
[06:56:32] <eternaleye> It's sleight of hand
[06:56:46] <bascule> it's handoff
[06:57:03] <eternaleye> The reason people want 0rtt is to reduce application-level latency
[06:57:20] <eternaleye> Any proposal that doesn't, even with better security properties, won't get deployed :/
[06:57:21] <bascule> well there's another reason you want this
[06:57:24] <bascule> in a CapTP system
[06:57:57] <eternaleye> bascule: I agree with you. I just am pointing out people will want the less-safe kind of 0rtt regardless, because of fucky priorities.
[06:58:04] <bascule> these are the sort of round trips that Macaroons prevent
[06:58:22] <bascule> by replacing capabilities with credentials
[06:58:58] <eternaleye> Honestly, IMO the solution to the RTT issue isn't to make your connections zero-rtt, it's to amortize the RTT by sharing the asymmetric exchange between many sessions between the two endpoints.
[06:59:11] <bascule> let's say Alice wants to give Bob a capability that points to Carol. The first message is from Bob to Carol (in a CapTP system)
[06:59:19] <eternaleye> IIRC, isn't the distribution of hosts people connect to roughly Zipfian?
[06:59:39] <eternaleye> So an amortization scheme would get about as much benefit as 0rtt
[06:59:45] <bascule> Carol asks Alice to mint Bob a credential, using Alice's capability to do so
[07:00:10] <bascule> https://static.googleusercontent.com/media/research.google.com/en/us/pubs/archive/41892.pdf
[07:00:12] <eternaleye> (MinimaLT did the amortization trick)
[07:00:24] <bascule> Fig 2. Shows that as "re-minted restrictions"
[07:02:03] <bascule> this thread o_O: http://internals.rust-lang.org/t/memcpy-is-backwards/1797/9
[07:02:48] <eternaleye> From the name, my first thought is the memcpy/memmove thing
[07:03:09] <bascule> so like
[07:03:14] <bascule> if that change shipped in beta
[07:03:21] <bascule> even if it's the "wrong call"
[07:03:27] <bascule> but it made all the APIs consistent
[07:03:42] <bascule> isn't reverting really a bad idea at this point?
[07:04:43] <cmr> Yeah I don't really know
[07:05:44] <cmr> it's a terrible change regardless, I'd love to see it reverted... the plan all along has been to release updated betas, this seems like a good excuse to release a new one.
[07:06:22] <bascule> ¯\_(ツ)_/¯
[07:06:49] <eternaleye> Comex makes a good point on the github issue though:
[07:06:51] <eternaleye> >> It's too late now, but I guarantee this will confuse a large number of people coming from C and expecting a memcpy replacement. Though I suppose that bridge is already crossed by std::ptr::copy taking an element count rather than byte count - I made the error of assuming the latter when I first used (the old name of) that function.
[07:08:09] <bascule> thing is, doesn't the mutability of the arguments disambiguate the ordering via the type system?
[07:08:20] <bascule> dest is mutable
[07:08:43] <bascule> it's not like you don't have to think about the ordering
[07:09:47] <eternaleye> bascule: *mut can coerce to *const though
[07:10:14] <eternaleye> bascule: mahkoh mentioned segfaults; I suspect they were calling it with two *muts
[07:10:29] <bascule> yah :|
[07:11:10] <eternaleye> bascule: And it's not a hugely unsurprising thing either - an example might be calling an ioctl, and then copying out a subsection of it.
[07:11:26] <eternaleye> bascule: the buffer the ioctl wrote into is *mut, and the buffer you copy to is *mut
[07:11:58] <eternaleye> er, not a hugely surprising thing
[07:12:29] <eternaleye> bascule: So I think "the type system disambiguates" is a red herring here
[07:12:54] <bascule> yeah nm
[07:12:55] <eternaleye> bascule: However, I do think "consistency with rust" is more critical than 'consistency with C's memcpy'
[07:13:29] <eternaleye> bascule: I mean, if the goal is for Rust to take over - then "consistency with C" is a time-limited benefit.
[07:13:39] <eternaleye> bascule: Inconsistency with the rest of Rust is pain forever.
[07:15:29] <bascule> an internal consistency is the hobgoblin of... something something
[07:15:58] <eternaleye> Foolish consistency is the hobgoblin of small minds, yes.
[07:16:12] <eternaleye> But the only argument on either side is consistency; the only difference is with *what*
[07:19:17] <eternaleye> (And no, I'm not agreeing with achrichton just because we're both named Alex :P)
[07:20:28] <cmr> eternaleye: https://github.com/rust-lang/rust/pull/24142#issuecomment-90412801 brings up making the Rust convention the other way around
[07:21:52] <eternaleye> cmr: Yeah, looking at it now
[07:22:09] <eternaleye> cmr: I'm of two minds about it; trying to phrase a comment on the issue
[07:25:16] <eternaleye> cmr: Commented.
[07:50:09] <bascule> I guess I want something that's like "yo rustc, assert this is exactly 32 bytes and let me call that a [u8; 32] from now on"
[07:50:48] <bascule> without copying
[07:51:12] <cmr> You can't get a [u8; 32] from behind a reference without attacking.
[07:51:15] <cmr> erm, copying
[07:51:27] <cmr> (talking about a dnd session...)
[07:51:28] <bascule> but I wanna
[07:51:56] <bascule> I mean
[07:52:13] <bascule> arguably sodiumoxide should have a better API that accepts a Vec<u8>
[07:52:16] <bascule> but
[07:52:26] <bascule> I'd have to check if that works with libsodium
[07:52:49] <bascule> this is for the key
[07:53:19] <cmr> Using [u8; 32] values seems like a really bad idea because you're going to be leaving copies around every time you move/use it.
[07:53:26] <cmr> for any secret
[07:53:49] <bascule> it's a reference
[07:53:54] <cmr> ok
[07:53:54] <bascule> but
[07:53:59] <bascule> I was looking at the upstream API
[07:54:43] <bascule> it's kind of hard to figure out because it's all macroed up the wazoo
[07:54:47] <bascule> https://github.com/dnaq/sodiumoxide/blob/master/src/crypto/hmacsha256.rs
[07:55:05] <bascule> https://github.com/dnaq/sodiumoxide/blob/master/src/crypto/auth_macros.rs
[07:56:04] <bascule> so, the upstream C API looks like this:
[07:56:07] <bascule> https://github.com/jedisct1/libsodium/blob/master/src/libsodium/crypto_auth/hmacsha256/cp/hmac_hmacsha256.c#L40
[07:56:11] <bascule> note key/keylen
[07:56:21] <bascule> the key should probably be Vec<u8>
[07:58:22] <Ilari> It is not input-only parameter?
[07:58:54] <bascule> HMAC has a wacky and wild inflatable arm flaling tube man way of handling keys which don't match the digest size of the hash function
[07:59:13] <bascule> Ilari: the key? It is...
[07:59:40] <Ilari> Not &[u8] then? And handling whatever crazyness HMAC does inside the function.
[08:01:03] <bascule> it's &[u8; 32]
[08:01:49] <bascule> so, as-is, the crazyness is disallowed
[08:01:54] <bascule> which is kind of cool?
[08:02:05] <bascule> but it makes it rather inconvenient to work with
[08:03:27] *** Quits: gsingh93 (gulshan@moz-3fu4am.mi.comcast.net) (Ping timeout: 121 seconds)
[08:04:09] <Ilari> Isn't the nominal keylength of HMAC-SHA256 64 bytes (unless it is really HMAC-SHA3-256, which has nominally 136 byte keys)? :->
[08:04:20] <bascule> I should at least make my entire public-facing API Vec<u8> anyway...
[08:04:43] <bascule> umm, really? o_O
[08:05:19] <Ilari> I usually use Vec<u8> in API only if 1) It is return value, or 2) The function resizes it.
[08:05:30] <bascule> https://tools.ietf.org/html/rfc4868#section-2.1.3
[08:06:18] <bascule> where does this RFC actually talk about key lengths?
[08:06:44] <eternaleye> I swear, the vast majority of hallucinogenic drugs are probably consumed in the process of making cryptography standards.
[08:06:48] <bascule> Ilari: do you ordinarily use &[u8] or what?
[08:06:54] <bascule> eternaleye: lol
[08:07:25] <bascule> okay there's a bit chart about key length
[08:07:31] <Ilari> Yeah, if the routine does not modify it, I use &[u8].
[08:07:43] <Ilari> Or some newtype.
[08:08:40] <bascule> Ilari: so Macaroons are more like I want to store all these blobs in a struct because it's more like a floating policy or contract
[08:08:58] <bascule> there's just one special one and that's the "signature"
[08:09:45] <bascule> and all of the rest of the Macaroon is a non-secret, and when we do introduce secret parts to the Macaroon we encrypt them anyway
[08:32:54] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[08:37:02] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[10:26:11] *** Joins: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua)
[11:39:27] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[14:24:57] *** Joins: brson (brson@moz-cfhap5.mtv2.mozilla.com)
[15:02:35] <Ilari> "(at this point I wouldn't use a binary extension field for anything)"
[15:07:33] <Ilari> Lol: "Internet of Targets"
[15:41:15] *** Joins: erickt (erickt@moz-4hh.6p3.217.74.IP)
[15:59:16] *** Joins: slarti (arthi@moz-55rvi2.dclient.hispeed.ch)
[16:14:14] *** Joins: gsingh93 (gulshan@moz-3fu4am.mi.comcast.net)
[16:33:11] <Tobba> I personally like the Internet of Things, it means that if I decide to persue a career as a security researcher my job will be incredibly easy
[16:59:53] <bascule> this argument ordering thread
[16:59:54] <bascule> heh
[17:00:03] <bascule> change it back! NO, DON'T CHANGE IT BACK!
[17:17:09] <kmc> let's define a trait so you can call memcpy in either order and it will figure it out from which pointer is const and which is mut
[17:39:11] <bascule> hahahaha
[18:00:17] *** Quits: slarti (arthi@moz-55rvi2.dclient.hispeed.ch) (A TLS packet with unexpected length was received.)
[18:19:57] <sfackler> PAINT IT RED GOD DAMMIT
[18:40:31] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Connection closed)
[18:40:56] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[18:53:03] <bascule> clearly the solution is keyword arguments!
[19:54:41] <Ilari> Also, it is not just sufficient to have some actually usable protocol specs for transport encryption, one also needs secure implementation of it.
[20:00:49] *** Quits: erickt (erickt@moz-4hh.6p3.217.74.IP) (Ping timeout: 121 seconds)
[20:03:43] *** Joins: erickt (erickt@moz-4hh.6p3.217.74.IP)
[20:21:18] *** Quits: erickt (erickt@moz-4hh.6p3.217.74.IP) (Ping timeout: 121 seconds)
[20:23:54] *** Joins: erickt (erickt@moz-4hh.6p3.217.74.IP)
[20:31:45] <bascule> Ilari: like lol MinimaLT?
[20:49:01] <eternaleye> bascule: Or lol TLS :P
[20:56:30] *** Quits: erickt (erickt@moz-4hh.6p3.217.74.IP) (Ping timeout: 121 seconds)
[21:00:51] *** Joins: erickt (erickt@moz-4hh.6p3.217.74.IP)
[21:05:01] *** Quits: erickt (erickt@moz-4hh.6p3.217.74.IP) (Ping timeout: 121 seconds)
[21:30:20] *** Joins: erickt (erickt@moz-4hh.6p3.217.74.IP)
[21:38:20] <Ilari> I mean, if I want to make some secured stream type thingy and don't want to use the garbage TLS is, what other options besides homecooking one there is?
[21:58:44] *** Joins: yourabi (yourabi@moz-q8dqtg.ca.comcast.net)
[21:58:53] *** Quits: yourabi (yourabi@moz-q8dqtg.ca.comcast.net) (Quit: Textual IRC Client: www.textualapp.com)
[22:05:21] *** Quits: erickt (erickt@moz-4hh.6p3.217.74.IP) (Ping timeout: 121 seconds)
[22:06:17] *** Quits: gsingh93 (gulshan@moz-3fu4am.mi.comcast.net) (Ping timeout: 121 seconds)
[22:40:43] <bascule> https://eprint.iacr.org/2015/310.pdf
[22:47:41] <Ilari> Requires loads of memory, right?
[22:54:24] <bascule> looks like it only works on curves over binary fields?
[22:54:38] <bascule> solution: don't use those!
[22:56:43] *** Joins: erickt (erickt@moz-4hh.6p3.217.74.IP)
[23:05:05] <Ilari> BTW: What is that non-binary Kobliz stuff? Searching for it only brings up the binary stuff for me...
[23:06:08] *** Quits: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua) (Ping timeout: 121 seconds)
[23:34:29] *** Quits: erickt (erickt@moz-4hh.6p3.217.74.IP) (Ping timeout: 121 seconds)
[23:41:27] <bascule> https://github.com/openssl/openssl/commit/a2fcab9978a0905c4286051993da63329fda8a19
[23:41:30] <bascule> heh

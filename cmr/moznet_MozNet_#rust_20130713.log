[00:01:39] *** kimundi is now known as zz_kimundi
[00:02:23] *** Quits: mschifer (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[00:04:23] *** Joins: DasIch (dasich@moz-5EDA591.de)
[00:05:34] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[00:05:42] <bblum> i really wish git diff wouldn't try to save diff lines on the close braces
[00:05:52] <bblum> it makes the diff very hard to read
[00:06:26] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[00:10:15] <tikue> rusti: enum Foo { AnotherFoo(Foo), Bar }
[00:10:16] -rusti- <anon>:7:9: 7:42 error: illegal recursive enum type; wrap the inner value in a box to make it representable
[00:10:16] -rusti- <anon>:7          enum Foo { AnotherFoo(Foo), Bar }
[00:10:16] -rusti-                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[00:10:16] -rusti- error: aborting due to previous error
[00:10:16] -rusti- application terminated with error code 101
[00:10:48] <tikue> rusti: enum Foo { AnotherFoo(Cell<Foo>), Bar }
[00:10:49] -rusti- <anon>:7:31: 7:40 error: use of undeclared type name `Cell`
[00:10:49] -rusti- <anon>:7          enum Foo { AnotherFoo(Cell<Foo>), Bar }
[00:10:49] -rusti-                                         ^~~~~~~~~
[00:10:49] -rusti- error: aborting due to previous error
[00:10:49] -rusti- application terminated with error code 101
[00:10:58] <tikue> rusti: enum Foo { AnotherFoo(std::Cell<Foo>), Bar }
[00:10:59] -rusti- <anon>:7:31: 7:45 error: use of undeclared type name `std::Cell`
[00:10:59] -rusti- <anon>:7          enum Foo { AnotherFoo(std::Cell<Foo>), Bar }
[00:10:59] -rusti-                                         ^~~~~~~~~~~~~~
[00:10:59] -rusti- error: aborting due to previous error
[00:10:59] -rusti- application terminated with error code 101
[00:11:10] <tikue> rusti: enum Foo { AnotherFoo(Option<Foo>), Bar }
[00:11:10] -rusti- <anon>:7:9: 7:50 error: illegal recursive enum type; wrap the inner value in a box to make it representable
[00:11:10] -rusti- <anon>:7          enum Foo { AnotherFoo(Option<Foo>), Bar }
[00:11:11] -rusti-                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[00:11:11] -rusti- error: aborting due to previous error
[00:11:11] -rusti- application terminated with error code 101
[00:11:19] *** Joins: olleharstedt (Thunderbir@moz-80D8890F.ias.bredband.telia.com)
[00:11:27] <tikue> rusti: enum Foo { AnotherFoo(~Foo), Bar }
[00:11:28] -rusti- ()
[00:11:42] *** Joins: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP)
[00:12:16] <tikue> rusti: enum Foo { Bar(Baz) } enum Baz { Bar(Foo) }
[00:12:17] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/EAKh
[00:12:49] <tikue> rusti: enum Foo { Bar } enum Baz { Bar }
[00:12:50] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/gjAN
[00:13:14] <tikue> rusti: enum Foo { Bar(Baz) } enum Baz { Zaz(Foo) }
[00:13:15] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/XYDb
[00:17:48] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[00:18:42] <bblum> graydon: https://github.com/mozilla/rust/issues/2677 ;)
[00:19:22] <graydon> \o/
[00:19:25] *** Joins: bnicholson (bnicholson@moz-E98974C1.hsd1.ca.comcast.net)
[00:19:27] <graydon> excellent way to end a friday
[00:19:37] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[00:19:44] <bblum> except for the part where i still have 9 triage bugs left
[00:19:50] <graydon> happiness is a warm delete key
[00:19:59] <graydon> aww, don't sweat it. they were due thursday anyways :)
[00:20:04] <graydon> have a good weekend!
[00:20:11] <bblum> well, as i discovered 2 weeks ago,
[00:20:18] <bblum> if i don't do them, they get reassigned to someone else
[00:20:25] <graydon> that is correct
[00:20:34] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[00:20:36] <graydon> nobody will know! we don't keep score
[00:20:55] <tjc> we should, though
[00:20:58] <graydon> (maybe we should? gosh, I mean, we all have a lot to do; it's a thing to try..)
[00:21:02] <tjc> and have badges for the people who do the most
[00:21:09] <graydon> badges and stars!
[00:21:09] <tjc> the gamification of bug triage
[00:21:12] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[00:21:12] <tjc> I may not be serious
[00:21:30] <graydon> I am not sure either. there's a point at which simply making people feel bad for having a lot to do isn't really healthy
[00:21:34] <tjc> No
[00:21:38] <graydon> I dunno how much I like the measurability of git stats either
[00:21:45] <tjc> I mean more like making people feel good for doing a lot
[00:21:47] <graydon> (I might like it better if I was committing anything much lately)
[00:21:49] <tjc> but maybe virtue is its own reward
[00:22:10] <graydon> *shrug* all metrics are gamed. the trick is to make them so numerous and annoying to game that it's not worth it?
[00:22:26] <graydon> jeez, they don't mess around with the email address suspension
[00:22:31] <graydon> mid-thread with john, he's gone
[00:22:37] <graydon> 5PM YOU ARE TERMINATEDD
[00:22:41] <tjc> yeah, pretty much
[00:22:47] <tjc> I just saw him, though, he was going to get his bicycle
[00:22:52] <tjc> before they disabled his badge
[00:23:05] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[00:23:14] <jclements> the lights are growing dim. 
[00:23:16] <tjc> heh
[00:23:32] <toddaaro> that is weird how the boot you off the e-mail so fast
[00:23:43] <graydon> it's just LDAP policy stuff
[00:23:57] <graydon> still, I think it would be polite to give you a week of grace to come clean out your stuff
[00:23:59] <tjc> they don't want ex-employees stealing any Mozilla secrets on the way out
[00:24:07] <graydon> yeah, we have $$SECRETS$$
[00:24:07] <jclements> toddaaro: my vidyo client shut down first. I think I'll have wireless until some kind of timeout occurs.
[00:24:17] <toddaaro> it makes sense, but it is still a little weird. I'm used to academia where I got my undergrad e-mail for over a year
[00:24:30] <jclements> guys! guys! the secret isâ€¦ UUUUUGGGGGGHHHhhhhhhhhhâ€¦â€¦.
[00:24:39] <bblum> c.c;
[00:24:43] <tjc> I still have my email account for the grad school department I got kicked out of over 2 years ago :-D
[00:25:03] <tjc> and I think my email for the other grad school department I got kicked out of (10 years ago) still forwards, if you email me at cs.berkeley.edu
[00:27:19] <graydon> ok, I _think_ I have it all wired up in my workspace such that codegen-ratio tests (against clang) are ratcheted on make check.
[00:28:02] <bblum> jclements: so did you get your patch landed before they pulled the plug
[00:28:17] <jclements> bblum: still working on it. RIGHT NOW.
[00:28:29] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[00:28:29] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14f804718 to 1496453eb: 02http://git.io/N3iJvQ
[00:28:29] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[00:28:31] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[00:28:31] <ghrust> 01[13rust01] 15bors pushed 10 new commits to 06auto: 02http://git.io/vxzLLQ
[00:28:31] <ghrust> 13rust/06auto 14052c482 15Michael Sullivan: Improve the error messages for mismatched numbers of type params.
[00:28:31] <ghrust> 13rust/06auto 14a8e4301 15Michael Sullivan: Fix the handling of type params on generic static methods. Closes #7571.
[00:28:31] <ghrust> 13rust/06auto 1438dc832 15Michael Sullivan: Fix another default method ICE in type_use. Closes #7675....
[00:28:33] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[00:28:48] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[00:31:44] *** Quits: bent (chatzilla@moz-2CD73AA6.triad.res.rr.com) (Quit: ChatZilla 0.9.90-rdmsoft [XULRunner 18.0.2/20130201065344])
[00:33:36] *** Quits: ozten (ozten@moz-DD3B00B4.hsd1.wa.comcast.net) (Quit: ozten)
[00:34:58] <pcwalton> hmm, why didn't bors pick up my priority
[00:36:16] <Jeaye> Stubborn guy, bors.
[00:36:18] *** Quits: graydon (Adium@A5087023.2354C43D.D8E68FF6.IP) (Quit: Leaving.)
[00:37:27] *** Parts: jclements (jclements@moz-BBE3ABD.mv.mozilla.com) ()
[00:37:42] *** Joins: jclements (jclements@moz-BBE3ABD.mv.mozilla.com)
[00:39:31] *** Quits: azakai (alon@moz-BBE3ABD.mv.mozilla.com) (Quit: Ex-Chat)
[00:41:03] <kmc> does __morestack() do something clever with frame pointers in order to allow GDB to follow the segmented stack?
[00:43:06] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: zzzzzzzzzz)
[00:45:55] *** Quits: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com) (Ping timeout)
[00:46:34] <jasom_> Okay, rust is officially smarter than me.  Here's a simple linked list: https://gist.github.com/jasom/5988857 how does one write a function to mutate the list structure in any way (say, for example, truncate it to a length of N) without using raw pointers.
[00:47:12] *** Joins: z0w0 (zack@moz-37A98529.lnse2.woo.bigpond.net.au)
[00:49:52] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[00:51:01] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[00:51:24] *** Joins: daofma (arnold@moz-72830A1C.nyc.res.rr.com)
[00:52:21] *** Joins: azakai (alon@moz-BBE3ABD.mv.mozilla.com)
[00:52:23] <ChrisMorgan> Given enum E { V, W, X }, is V only accessible as V? E.V and E::V don't work.
[00:52:51] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[00:53:01] <bblum> jasom_: you have to store it in a mutable location. note that "mut l: &~List" only makes the borrowed pointer 'l' mutable; it does not make the thing pointed-to mutable. You'd have to write "&mut ~List" or some-such for that.
[00:53:45] <bblum> ChrisMorgan: That's true. pcwalton would be able to explain the reasoning...
[00:53:45] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[00:53:45] *** ChanServ sets mode: +o tjc
[00:54:02] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Ping timeout)
[00:54:53] <kmc> it would be weird to support E.V or E::V because E is a type and not a value or a module
[00:55:52] <engla> dbaupp: hi, do you want to review an additional PR for dlist? https://github.com/mozilla/rust/pull/7735
[00:56:27] <engla> I'm not sure. I think it would be nice to have them under E::V by default and being able to `use` to lift them out
[00:57:13] <tjc> so my rust error messages are coming out white-on-white, which I know is a known bug
[00:57:27] <tjc> but I'm enjoying seeing how often I can deduce the error message without highlighting it so I can see what the error was
[00:57:28] <tjc> just from teh code
[00:57:32] <engla> T::f is also used for functions in traits or in impls on types
[00:59:45] <strcat> pcwalton: is there a way to make LLVM only output __morestack if the space the stack frame needs is under a threshold? (say, 4K, if we had a guard page)
[00:59:54] <pcwalton> strcat: you'd have to hack LLVM
[00:59:54] *** Joins: benbangert (bbangert@moz-B1FEE9C0.org)
[00:59:55] <jasom_> bblum: sure, I know that.  But It won't let me move out of a borrowed pointer
[01:00:09] *** Parts: benbangert (bbangert@moz-B1FEE9C0.org) ()
[01:00:12] <pcwalton> ChrisMorgan: engla: the reason it's that way is to make it easier to write "class hierarchies" with enums
[01:00:18] <bblum> jasom_: that is because you have a ~-pointer in your list representation, which is non-copyable
[01:00:29] <pcwalton> there is no inheritance in Rust so you often end up using enums and it would be a pain for all subclasses to be under the superclass' namespace
[01:00:37] <pcwalton> there has been a proposal for "enum mod" to get the other behavior though
[01:00:42] <jasom_> bblum: what do you suggest I use?  I understand that @ is going away, right?
[01:00:43] <pcwalton> which I would personally be fine with
[01:01:16] <bblum> jasom_: oh, you are just trying to truncate it, ok
[01:01:18] <jasom_> bblum: someone has to own the storage, and it should probably be the cell before it
[01:01:25] <bblum> jasom_: ~ is a fine choice, i agree
[01:01:27] *** Joins: vk (vk@858480B7.B568D26C.93B001FA.IP)
[01:01:52] <bblum> jasom_: if you have it in a mutable location, you can just use let old_tail = util::replace(&mut ?????, Nil)
[01:02:50] * ChrisMorgan likes being able to use enum and match for quick and solid state machines
[01:04:11] *** Quits: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net) (Quit: carllerche)
[01:08:00] <strcat> hrm
[01:08:04] <strcat> I guess we don't support AVX?
[01:08:15] <strcat> because we're probably not saving the context
[01:09:41] <smvv_> jasom_: https://gist.github.com/smvv/5988955
[01:09:53] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[01:12:44] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Quit: Leaving.)
[01:14:18] <jensnockert> strcat: The OS should do that.
[01:14:27] <strcat> jensnockert: but we implement context switching
[01:14:32] <jensnockert> strcat: Oh wait, we're probably doing it ourselves :(
[01:14:36] * jensnockert hugs strcat.
[01:14:42] <strcat> we don't support any sse in x86
[01:14:52] <strcat> and no sse3/ssse3/sse4/avx on 64-bit
[01:15:00] <strcat> well
[01:15:03] <strcat> I guess we support sse?
[01:15:15] <strcat> dunno if they added more registers
[01:15:15] <jensnockert> I really hope we don't use x87â€¦
[01:15:23] <strcat> jensnockert: we do on x86
[01:15:25] <jensnockert> sse added registers, so did avx.
[01:15:33] <jensnockert> strcat: *facepalm*
[01:15:36] <strcat> jensnockert: but did the sse revisions do anything?
[01:15:44] *** Quits: eschweic1 (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[01:15:44] <strcat> avx doubles their size, right?
[01:15:51] <jensnockert> strcat: No, if you support SSE, you should support all versions.
[01:15:57] <strcat> jensnockert: ah okay
[01:15:59] <jensnockert> strcat: At least.
[01:16:05] <heftig> jasom_: enum List { Cons(uint,~List), Nil } fn trunc(list: &mut ~List, l: uint) { if l == 0 { *list = ~Nil; } else { match list { &~Cons(_,ref mut n) => trunc(n, l-1), &~Nil => () }; } } let mut a = ~Cons(1,~Cons(2,~Cons(3,~Cons(4,~Nil)))); trunc(&mut a,2); a
[01:16:12] <heftig> rusti: enum List { Cons(uint,~List), Nil } fn trunc(list: &mut ~List, l: uint) { if l == 0 { *list = ~Nil; } else { match list { &~Cons(_,ref mut n) => trunc(n, l-1), &~Nil => () }; } } let mut a = ~Cons(1,~Cons(2,~Cons(3,~Cons(4,~Nil)))); trunc(&mut a,2); a
[01:16:12] -rusti- ~Cons(1, ~Cons(2, ~Nil))
[01:16:13] <strcat> so we don't support sse/avx on 32-bit and we lack avx support on 64-bit
[01:16:20] *** Joins: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu)
[01:16:21] <strcat> not as bad as I thought, still bad ;p
[01:16:25] <jensnockert> strcat: Technically, there could be extensions that are wider than 256-bit, iirc.
[01:16:56] *** Quits: echristo (echristo@D423593A.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[01:17:00] *** Joins: scanlonman (scanlonman@moz-169BC238.hsd1.wa.comcast.net)
[01:17:35] <pcwalton> found more uses of "copy"
[01:17:41] <pcwalton> please stop landing things with "copy" in them if you can
[01:18:02] * jensnockert hugs pcwalton.
[01:18:37] <heftig> strcat: can you turn trunc() into a method?
[01:19:12] <strcat> heftig: yes, you could
[01:19:13] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[01:19:24] <strcat> you could do an impl on ~List, or do it another way
[01:19:54] <heftig> i tried doing it with &mut List, but that didn't work
[01:22:02] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[01:22:11] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[01:22:58] <strcat> jensnockert: hm
[01:26:22] <sully> ok, coherence_info removed
[01:28:50] *** Quits: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP) (Ping timeout)
[01:29:40] <jensnockert> strcat: I doubt that will ever be implemented though, except possibly in Xeon Phi.
[01:31:40] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[01:31:46] <ChrisMorgan> A reason I was wondering if I could have this "enum mod"-style thing is this, which won't compile at present: enum ContentCodingValueToken { Gzip, Compress, Deflate, Identity } enum TransferCodingValueToken { Chunked, Gzip, Compress, Deflate }. Pity it can't be clever about it and use the same name for it depending on type, as with untyped int literals.
[01:31:47] <jasom_> heftig: thanks
[01:31:58] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[01:32:55] <strcat> maybe we can just take the context switch implementation from boost, it's permissively licensed
[01:33:02] <strcat> hrm
[01:33:07] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[01:33:08] <jensnockert> strcat: On the other hand, random picture on the internet hints on 512-bit AVX, http://www.xbitlabs.com/picture/?src=/images/news/2013-07/intel_cpu_mic_roadmap.png
[01:33:52] <jensnockert> strcat: Oh wait, that says Haswell is going to have DDR4 memoryâ€¦
[01:34:43] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Quit: Leaving.)
[01:35:20] *** Joins: MaikKlein (maik@moz-B9C8EE03.dip0.t-ipconnect.de)
[01:36:16] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[01:36:54] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[01:37:09] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[01:37:10] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[01:38:03] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[01:38:07] <bblum> i... am completely mystified
[01:38:16] <bblum> can somebody familiar with, i dunno, trans, take a look at this ?
[01:38:32] <bblum> pcwalton?
[01:38:44] <strcat> pcwalton: it'll break again after the current one
[01:38:53] <strcat> pcwalton: https://github.com/mozilla/rust/pull/7742 I put p=1 on this so it could land after it
[01:39:24] * strcat shrugs
[01:39:25] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[01:39:31] <bjz> doener: sorry for always forgetting, but how do I do .each again? I tried vec.iter().each :/
[01:39:39] <strcat> bjz: .advance
[01:39:47] <bjz> oh - was meant for dbaupp
[01:40:02] <bjz> strcat: so iter().advance ?
[01:40:05] <strcat> yeah
[01:40:07] <strcat> bjz: https://github.com/mozilla/rust/blob/master/doc/tutorial-container.md#iterators
[01:40:15] <strcat> (for some reason the doc bot isn't updating it on the site)
[01:40:31] *** Quits: jgilbert (jgilbert@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[01:41:16] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: zzzzzzzzzz)
[01:42:41] * strcat ended up just using `next_back` for double-ended ones
[01:42:45] <strcat> makes more sense than pop
[01:43:53] *** Quits: ssbr (ssbr@moz-141F89C6.block0.gvtc.com) (Ping timeout)
[01:45:01] *** Joins: popo_ (Mibbit@moz-4B32B3A0.dhcp.spbg.sc.charter.com)
[01:45:11] *** Quits: jclements (jclements@moz-BBE3ABD.mv.mozilla.com) (Quit: jclements)
[01:45:25] <bblum> can't debug my segfault because of an internal compiler error
[01:45:30] <bblum> brilliant. -_-
[01:47:05] *** Joins: ross (ross@moz-8A84103E.br.br.cox.net)
[01:47:39] <tikue> rusti: let a = [1, 2]; let b = ["one"]; for a.iter().zip_long(b.iter()).advance |(a, b)| { println(fmt!("%?, %?", a, b)); }
[01:47:41] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/PdUM
[01:49:22] * jensnockert hugs bblum, "It will be alright"
[01:49:34] <bblum> you sure are huggy
[01:49:38] <jensnockert> \o/
[01:49:42] <jensnockert> Hugs are good for you!
[01:49:45] <bblum> trufax
[01:49:59] <tikue> is zip_long not a thing?
[01:50:13] <tikue> i've a specific use case, but perhaps there's a better way
[01:50:28] <tikue> essentially i want to search a vector, and I know there's a high probability that the thing I'm searching for is near a particular index
[01:51:00] <tikue> so I want to reverse search before that index and forward search after, but alternate between the direction i'm searching
[01:51:26] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[01:51:54] *** Quits: popo_ (Mibbit@moz-4B32B3A0.dhcp.spbg.sc.charter.com) (Quit: http://www.mibbit.com ajax IRC Client)
[01:53:07] <strcat> tikue: we could add zip_longest but I'm not sure it will be less painful than doing it by hand with next()
[01:53:12] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[01:53:16] *** Joins: glinscott (garylinsco@789A6618.53EB7C1.FFFE3AA.IP)
[01:53:19] <tikue> strcat: true
[01:53:43] <MaikKlein> is this a use case for macros? http://www.reddit.com/r/rust/comments/1i5oha/an_alternative_way_to_achieve_inheritance/cb1ks2j
[01:54:02] <MaikKlein> to implement some traits so I can avoid boilerplate code?
[01:55:11] <tikue> so something like: let (a, b) = (vec.slice(0, i), vec.slice(i, vec.len())); loop { let (forward, back) = (a.next_back(), b.next()); match (forward, back) { (None, None) => break, etc }
[01:55:56] <SiegeLord> Would making trait constructors work like ChrisMorgan suggested be a backwards-incompatible change? I had a similar issue as well recently
[01:56:15] <SiegeLord> *enum constructors
[01:56:42] <tikue> how do you get a slice of a vec?
[01:56:52] <ChrisMorgan> enum constructors? I didn't say anything about enum constructors, did I?
[01:57:21] <strcat> tikue: slice is right
[01:57:28] <tikue> ah
[01:57:28] <tikue> thx
[01:58:12] <SiegeLord> ChrisMorgan, The things in the enums are enum constructors
[01:58:18] <strcat> I wish macros could expand to multiple items
[01:58:27] <tikue> rusti: let a = [1, 2, 3, 4, 5]; let b = a.slice(0, 3);
[01:58:28] -rusti- <anon>:7:38: 7:39 warning: unused variable: `b` [-W unused-variable (default)]
[01:58:28] -rusti- <anon>:7          let a = [1, 2, 3, 4, 5]; let b = a.slice(0, 3);
[01:58:29] -rusti-                                                ^
[01:58:29] -rusti- ()
[01:58:35] <ChrisMorgan> Ah. Terminology.
[01:58:43] <tikue> rusti: let a = [1, 2, 3, 4, 5]; let b = a.slice(0, 3); b
[01:58:44] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/iQYS
[01:59:03] <tikue> rusti: let a = [1, 2, 3, 4, 5]; let b = ~a.slice(0, 3); b
[01:59:04] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/jEVg
[01:59:32] <tikue> rusti: let a = [1, 2, 3, 4, 5]; let b = a.slice(0, 3); println(fmt!("%?", b));
[01:59:33] -rusti- &[1, 2, 3]
[01:59:33] -rusti- ()
[02:00:43] <tikue> rusti: [1, 2, 3].pop()
[02:00:44] -rusti- <anon>:7:9: 8:5 error: type `[<VI2>, .. 3]` does not implement any method in scope named `pop`
[02:00:44] -rusti- <anon>:7          [1, 2, 3].pop()
[02:00:44] -rusti- <anon>:8     };
[02:00:44] -rusti- error: aborting due to previous error
[02:00:44] -rusti- application terminated with error code 101
[02:00:49] <tikue> rusti: ~[1, 2, 3].pop()
[02:00:50] -rusti- <anon>:7:10: 8:5 error: type `[<VI2>, .. 3]` does not implement any method in scope named `pop`
[02:00:50] -rusti- <anon>:7          ~[1, 2, 3].pop()
[02:00:50] -rusti- <anon>:8     };
[02:00:51] -rusti- error: aborting due to previous error
[02:00:51] *** concrete.mozilla.org sets mode: +M 
[02:00:53] -rusti- application terminated with error code 101
[02:01:02] <tikue> rusti: let mut a = ~[1, 2, 3]; a.pop()
[02:01:03] -rusti- 3
[02:01:41] <tikue> rusti: let a = [1, 2, 3]; let b = a.iter().invert();
[02:01:41] -rusti- <anon>:7:36: 7:54 error: type `std::vec::VecIterator<,<VI2>>` does not implement any method in scope named `invert`
[02:01:42] -rusti- <anon>:7          let a = [1, 2, 3]; let b = a.iter().invert();
[02:01:42] -rusti-                                              ^~~~~~~~~~~~~~~~~~
[02:01:42] -rusti- error: aborting due to previous error
[02:01:42] -rusti- application terminated with error code 101
[02:02:02] <tikue> rusti: use std::vec::*; let a = [1, 2, 3]; let b = a.iter().invert();
[02:02:03] -rusti- <anon>:7:53: 7:71 error: type `std::vec::VecIterator<,<VI2>>` does not implement any method in scope named `invert`
[02:02:03] -rusti- <anon>:7          use std::vec::*; let a = [1, 2, 3]; let b = a.iter().invert();
[02:02:03] -rusti-                                                               ^~~~~~~~~~~~~~~~~~
[02:02:03] -rusti- error: aborting due to previous error
[02:02:05] -rusti- application terminated with error code 101
[02:02:07] <tikue> gargh
[02:02:20] <strcat> tikue: DoubleEndedIterator{,Util} aren't in prelude yet
[02:02:30] <strcat> well actually they are at the tip of master
[02:02:33] <tikue> strcat: oh D:
[02:02:57] <bblum> strcat: do you know much about trans?
[02:03:03] <strcat> bblum: a bit ;p
[02:03:09] <tikue> strcat: is there a method on vecs that return an iterator over the vec in reverse?
[02:03:19] <bblum> strcat: i have a totally baffling error going on here
[02:03:21] <strcat> tikue: rev_iter
[02:03:27] <tikue> strcat: thank you!
[02:03:34] <strcat> tikue: but at the tip of master it just calls .iter().invert()
[02:03:42] <strcat> bblum: what's the error?
[02:04:41] *** Quits: zz_kimundi (kimundi@moz-72E3BB53.dip0.t-ipconnect.de) (Ping timeout)
[02:04:58] <strcat> bblum: the way I ended up dealing with errors from removing ~ headers was diff'ing the before/after IR ;p
[02:05:04] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[02:05:07] <bblum> strcat: i am refactoring a bunch of code in taskgroup stuff
[02:05:19] <bblum> and getting a segfault when trying to clone an ARC that cloned fine before
[02:05:23] <bblum> narrowed it down...
[02:05:24] <bblum> check this out
[02:05:26] <bblum> http://pastebin.mozilla.org/2625249
[02:05:33] *** Joins: ssbr (ssbr@moz-141F89C6.block0.gvtc.com)
[02:05:48] <bblum> err, http://pastebin.mozilla.org/2625250, meant to change the second 'group' to 'ancestors'
[02:05:49] *** concrete.mozilla.org sets mode: -M 
[02:06:46] <ChrisMorgan> Why exactly was there that +M?
[02:07:06] <strcat> flood protection
[02:07:14] <bblum> strcat: now, the super fishy thing that i just noticed is that it's printing out the 'me' field
[02:07:23] <ChrisMorgan> rusti: fn a() -> ~str { ::std::str::from_bytes(~[1, 2, 3]).trim() } a()
[02:07:23] <ChrisMorgan> str::from_bytes(bytes) returns ~str; str.trim() returns &'self str. How can I, without doing another allocation, return thus a ~str?
[02:07:24] <bblum> I have removed the 'me' field from the struct.
[02:07:24] -rusti- <anon>:7:26: 7:69 error: mismatched types: expected `~str` but found `&str` (str storage differs: expected ~ but found &)
[02:07:24] -rusti- <anon>:7          fn a() -> ~str { ::std::str::from_bytes(~[1, 2, 3]).trim() } a()
[02:07:24] -rusti-                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[02:07:24] -rusti- error: aborting due to previous error
[02:07:25] -rusti- application terminated with error code 101
[02:07:25] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[02:07:38] <bblum> this is running stage1-stdtest
[02:07:51] <bblum> so like......
[02:07:55] *** Quits: MaikKlein (maik@moz-B9C8EE03.dip0.t-ipconnect.de) (Ping timeout)
[02:07:55] <bblum> there's an old TCB going on here
[02:08:02] <strcat> weird
[02:08:08] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Input/output error)
[02:08:12] *** Joins: zz_kimundi (kimundi@moz-317411F.dip0.t-ipconnect.de)
[02:08:15] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[02:08:19] * strcat doesn't understand how that could happen ;\
[02:08:39] *** zz_kimundi is now known as kimundi
[02:09:48] *** Quits: olleharstedt (Thunderbir@moz-80D8890F.ias.bredband.telia.com) (Ping timeout)
[02:11:05] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[02:11:05] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/vxzLLQ
[02:11:05] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[02:11:18] <ChrisMorgan> Can I get a ~str there without doing another allocation?
[02:11:43] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[02:12:18] <strcat> ChrisMorgan: which side does trim cut it down from?
[02:12:18] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Connection reset by peer)
[02:12:20] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[02:12:21] <strcat> RHS?
[02:12:23] <ChrisMorgan> Both
[02:12:40] <Eridius> the test runner for rustpkg segfaulted when bors was testing my PR. Is this miscellaneous breakage or did I actually manage to introduce a segfault?
[02:12:42] <Eridius> http://buildbot.rust-lang.org/builders/auto-mac-all-opt/builds/377
[02:12:53] <ChrisMorgan> self.trim() <==> self.trim_left().trim_right()
[02:13:36] <strcat> ChrisMorgan: do trim_left, take the new length, shift the difference
[02:13:43] <strcat> do trim_right, take the new len, pop the difference
[02:13:45] <strcat> could be a new fn
[02:14:11] <ChrisMorgan> Mebbe I'll just alter my state machine to not put those spaces in in the first place.
[02:14:28] <bblum> strcat: ok hmm... i think rebuilding stage1 libstd.so fixed it
[02:14:37] <ChrisMorgan> State machines in Rust are delightful to write.
[02:14:41] <bblum> god, writing test cases in libstd is just as broken as it was last summer
[02:14:43] <bblum> this is horrible
[02:14:43] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[02:14:44] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/2xyaXw
[02:14:44] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[02:15:24] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[02:15:38] *** Joins: reyre (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[02:15:44] <strcat> heh strings don't have shift anyway
[02:16:07] <strcat> well
[02:16:10] <strcat> they have shift_char
[02:16:19] <strcat> but then you'd have to do n * O(n) operations
[02:16:21] <strcat> ;\
[02:16:24] <strcat> need shift_char_n
[02:16:27] *** Quits: smvv_ (sander@moz-BAEA8EB2.dynamic.upc.nl) (Ping timeout)
[02:17:04] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[02:17:04] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/1O4kEg
[02:17:04] <ghrust> 13rust/06auto 14184fa42 15Chris Morgan: Vim syntax: support lifetimes with delimitMate....
[02:17:04] <ghrust> 13rust/06auto 144f67ed5 15Chris Morgan: Fix problem with switching between Rust buffers....
[02:17:05] <ghrust> 13rust/06auto 14d2cf292 15bors: auto merge of #7742 : chris-morgan/rust/delimitmate-support, r=cmr...
[02:17:07] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[02:17:50] <strcat> now we need a snapshot so we can use default methods all over :)
[02:19:19] <ChrisMorgan> strcat: that's not n Ã— O(n), which would be O(nÂ²); that's O(mÃ—n) (where n = str.len() and m = number of chars being trimmed)
[02:19:49] <engla> I compiled a rust with default methods for Eq and Ord and it worked. But now I have to try with the newly landed default methods PR
[02:19:51] <strcat> ChrisMorgan: yeah it was a lazy/wrong description of the time complexity
[02:19:58] <strcat> that's what I get for typing out my thought process ;p
[02:20:37] <ChrisMorgan> But the answer seems to be that I can't just shift the position of the pointer in O(1).
[02:21:05] <engla> the design of ~str would have to allow it. and it probably doesn't
[02:21:25] <strcat> well it needs a pointer to the real start so it can call free on it
[02:21:34] <ChrisMorgan> OK. That's what I thought most likely, just thought it worth asking.
[02:21:35] <engla> exactly
[02:22:23] *** Joins: eatkinson (eatkinson@moz-AD233F1B.dia.static.qwest.net)
[02:23:23] *** Quits: dew (Instantbir@moz-66796D51.dhcp.stls.mo.charter.com) (Ping timeout)
[02:23:44] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[02:23:54] <engla> bblum: nice quote! "we can implement a safe convenience macro that can assert this at runtime instead of at comment-time."
[02:24:03] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[02:24:07] <Eridius> comment-time?
[02:24:18] <bblum> engla: i know right
[02:24:31] <bblum> i was proud of "comment-time"
[02:24:49] *** Quits: vk (vk@858480B7.B568D26C.93B001FA.IP) (Quit: vk)
[02:24:52] <bblum> runtime checks are worse than compile-time checks but much better than comment-time checks
[02:24:58] *** Joins: mreedell (mreedell@moz-9950CA28.hsd1.pa.comcast.net)
[02:25:48] <engla> I like it, I'm tempted to make more comment-time assertions now that I have a technical term for it
[02:25:51] <engla> ;-)
[02:28:08] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[02:29:26] <ChrisMorgan> There, I removed the need for the trim() call on my HTTP-request-header-reading state machine.
[02:29:26] *** Quits: eatkinson (eatkinson@moz-AD233F1B.dia.static.qwest.net) (Quit: eatkinson)
[02:31:01] *** Joins: sankha93 (Instantbir@FBF97D8E.5971ED35.EFB84E89.IP)
[02:33:37] *** Quits: sankha93 (Instantbir@FBF97D8E.5971ED35.EFB84E89.IP) (Ping timeout)
[02:34:09] *** Quits: azakai (alon@moz-BBE3ABD.mv.mozilla.com) (Quit: Ex-Chat)
[02:34:21] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[02:34:29] *** Joins: sankha93 (Instantbir@2EAF9EF4.C0D45E01.EFB84E89.IP)
[02:34:58] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[02:38:43] *** Quits: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com) (Ping timeout)
[02:38:58] <bblum> wow stage1 rustc is a LOT slower than stage0
[02:39:14] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[02:39:31] *** Quits: froystig (froystig@4AB93A85.352137A1.BCED17D.IP) (Quit: leaving)
[02:39:45] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[02:40:19] <strcat> bblum: there was a 300MiB mem usage regression
[02:40:40] <strcat> maybe you're swapping?
[02:40:56] <strcat> bblum: http://huonw.github.io/isrustfastyet/mem/
[02:41:02] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[02:41:34] <bblum> i have 8 gigs, a memory usage indicator that turns red if i'm above 90%, and a hard drive usage LED; i would know if i'm swapping
[02:41:43] <tikue> rusti: #[deriving(Eq)] struct Foo(uint);
[02:41:44] -rusti- ()
[02:42:04] <doener> stage1 also runs with thread-safe LLVM, that costs about 10% IIRC
[02:42:13] <bblum> doener: oh geez
[02:42:15] <strcat> the mem usage regression is really bad ;[
[02:42:24] <tikue> rusti: struct Foo(uint); Foo(1) == Foo(1);
[02:42:24] <bblum> strcat: what caused it, do you know
[02:42:25] -rusti- <anon>:7:27: 7:44 error: binary operation == cannot be applied to type `main::Foo`
[02:42:25] -rusti- <anon>:7          struct Foo(uint); Foo(1) == Foo(1);
[02:42:25] -rusti-                                     ^~~~~~~~~~~~~~~~~
[02:42:25] -rusti- error: aborting due to previous error
[02:42:25] -rusti- application terminated with error code 101
[02:42:32] <strcat> bblum: removing @ from the AST
[02:42:38] <bblum> oh damn
[02:42:40] <bblum> busted
[02:42:43] <strcat> bblum: the revert kept hitting a windows failure
[02:42:44] <tikue> rusti: #[deriving(Eq)] struct Foo(uint); Foo(1) == Foo(1)
[02:42:45] -rusti- <anon>:7:43: 8:5 error: binary operation == cannot be applied to type `main::Foo`
[02:42:45] -rusti- <anon>:7          #[deriving(Eq)] struct Foo(uint); Foo(1) == Foo(1)
[02:42:45] -rusti- <anon>:8     };
[02:42:45] -rusti- error: aborting due to previous error
[02:42:45] -rusti- application terminated with error code 101
[02:42:52] <strcat> bblum: and now the revert bitrotted
[02:42:54] <strcat> ;\
[02:42:58] <bblum> busted.
[02:43:09] <strcat> bblum: https://github.com/mozilla/rust/pull/7644
[02:43:23] <tikue> is it possible to overload == ?
[02:43:34] <engla> tikue: implement Eq
[02:43:49] <tikue> engla: this doesn't work: #[deriving(Eq)] struct Foo(uint); Foo(1) == Foo(1)
[02:44:00] <strcat> deriving might not work on unit structs
[02:44:07] <tikue> strcat: rusti doesn't complain
[02:44:10] <strcat> can still implement it by hand
[02:44:15] <tikue> rusti: #[deriving(Eq)] struct Foo(uint);
[02:44:16] -rusti- ()
[02:44:20] <strcat> tikue: deriving doesn't throw an error when it fails
[02:44:22] <engla> tikue: then it's a bug
[02:44:26] <tikue> strcat: o__o
[02:44:29] <tikue> thx lol
[02:44:36] <strcat> rusti: #[deriving(Eq)] struct Foo(uint); Foo(1) == Foo(1)
[02:44:37] -rusti- <anon>:7:43: 8:5 error: binary operation == cannot be applied to type `main::Foo`
[02:44:37] -rusti- <anon>:7          #[deriving(Eq)] struct Foo(uint); Foo(1) == Foo(1)
[02:44:37] -rusti- <anon>:8     };
[02:44:37] -rusti- error: aborting due to previous error
[02:44:37] -rusti- application terminated with error code 101
[02:44:44] <bblum> o_O
[02:44:47] <Eridius> how long does the rustpkg test take on bors? I'm asking because that one appears to fetch data from the net
[02:44:56] <Jeaye> Why would that ever work, strcat?
[02:45:06] <strcat> Jeaye: it should work
[02:45:16] <Jeaye> struct Foo(uint); Foo(1) // valid?
[02:45:19] <strcat> yes
[02:45:33] <engla> rusti: struct Foo(uint); Foo(1)
[02:45:34] -rusti- {__field__: 1}
[02:45:35] <strcat> you don't have to name the fields, it acts like a tuple that way
[02:45:39] <Jeaye> What does that even mean? It's a struct decl and a ctor?
[02:45:42] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[02:45:52] <heftig> rusti: struct Foo(uint, uint); Foo(1,2)
[02:45:53] -rusti- {__field__: 1, __field__: 2}
[02:45:55] <strcat> Jeaye: it's just like struct Foo{x:1} Foo{x:1}
[02:46:11] <strcat> without a name for the field
[02:46:12] <Jeaye> strcat: How do you access them afterward?
[02:46:13] <heftig> strcat: what's the point of tuple structs?
[02:46:17] <bblum> rusti: struct Foo(uint, uint); Foo(1,2).__field__
[02:46:18] -rusti- 1
[02:46:19] <strcat> Jeaye: destructuring
[02:46:20] <bblum> o_O
[02:46:28] <strcat> heftig: not having to name the fields
[02:46:30] <strcat> bblum: yeah, rust.
[02:46:32] <strcat> :D
[02:46:35] <bblum> good grief
[02:46:37] <engla> with one field, it's called newtype struct colloquially. It's nice for wrapping a value and implementing traits on the new type
[02:46:44] <strcat> bblum: also we make weird module names for 'extern' blocks :)
[02:46:50] <heftig> strcat: ah, and tuples can't be named?
[02:46:51] <engla> bblum: nice, didn't know that
[02:46:51] <strcat> __foreign_mod__ or something
[02:47:01] <strcat> heftig: yeah, you could think of those as named tuples
[02:47:01] <bblum> strcat: also clownshoes extensions
[02:47:05] * bblum ->
[02:47:06] <Jeaye> strcat: I'm not familiar with that term.
[02:47:06] <Eridius> does the test runner let me specify a test to skip, instead of just tests to run?
[02:47:19] <strcat> Jeaye: let (x, y) = (1, 2)
[02:47:24] <Jeaye> ahhh
[02:47:25] <strcat> let Foo(x, y) = Foo(1, 2)
[02:47:30] <Eridius> nevermind, test passed this time (it was dependent on network)
[02:47:39] <strcat> Jeaye: they're essentially a tuple with a name
[02:47:54] <Jeaye> strcat: That's very nifty, but not so intuitive.
[02:47:59] <strcat> Jeaye: enum variants can have 3 kinds too -> unit struct-like variants, tuple struct-like variants and struct-like variants
[02:48:07] <strcat> so, structs have those 3 kinds too
[02:48:15] <strcat> Jeaye: seems intuitive to me ;p
[02:48:16] <tikue> rusti: let a = [1, 2, 3]; let b = a.iter(); a.next(); a.next(); a.next(); a.next();
[02:48:17] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/QYGf
[02:48:17] <strcat> they're a tuple with a name
[02:48:23] <Jeaye> Fair enough. :P
[02:48:30] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[02:48:37] <tikue> rusti: let a = [1, 2, 3]; let b = a.iter(); b.next(); b.next(); b.next(); b.next();
[02:48:38] -rusti- <anon>:7:77: 7:78 error: unknown start of token: 28
[02:48:38] -rusti- <anon>:7          let a = [1, 2, 3]; let b = a.iter(); b.next(); b.next(); b.next(); b.next();
[02:48:38] -rusti-                                                                                       ^
[02:48:38] -rusti- application terminated with error code 101
[02:48:45] <heftig> rusti: struct Foo; Foo
[02:48:46] -rusti- {}
[02:48:54] <heftig> strcat: that's a unit struct?
[02:48:58] <strcat> yeah
[02:49:02] <strcat> 0-size
[02:49:04] <strcat> like ()
[02:49:14] <tikue> rusti: let a = [1, 2, 3]; let b = a.iter(); b.next(); b.next(); b.next(); b.next();
[02:49:16] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/ZQhj
[02:49:24] <strcat> heftig: standard C/C++ lack zero-size types so it's a neat thing to have
[02:49:31] <tikue> rusti: let a = [1, 2, 3]; let mut b = a.iter(); b.next(); b.next(); b.next(); b.next();
[02:49:32] <heftig> i see.
[02:49:32] -rusti- ()
[02:49:34] <strcat> C++ lacks them completely, but I think GNU C might allow them
[02:49:36] <strcat> not sure
[02:49:50] <tikue> rusti: let a = [1, 2, 3]; let mut b = a.iter(); b.next(); b.next(); b.next()
[02:49:50] <strcat> I know it won't work in GNU C++ though
[02:49:51] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/JEaJ
[02:50:15] <tikue> rusti: let a = [1, 2, 3]; let mut b = a.iter(); b.next(); b.next(); b.next().get()
[02:50:16] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/GJFX
[02:50:24] <strcat> tikue: it's mad that the last next() call returns &
[02:50:29] *** Quits: mreedell (mreedell@moz-9950CA28.hsd1.pa.comcast.net) (Quit: Computer has gone to sleep.)
[02:50:30] <strcat> and the block evaluates to it
[02:50:35] <strcat> that error needs another note
[02:50:41] <tikue> strcat: yeah can't remember how to unwrap an option
[02:50:43] *** Quits: slaren (slaren@moz-14DF61FB.red-95-120-34.dynamicip.rima-tde.net) (Ping timeout)
[02:50:53] <strcat> tikue: *b.next().unwrap()
[02:50:55] <tikue> rusti: let a = [1, 2, 3]; let mut b = a.iter(); b.next(); b.next(); b.next().unwrap()
[02:50:57] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/UiaU
[02:51:22] <strcat> rusti: let a = [1, 2, 3]; let mut b = a.iter(); b.next(); b.next(); *b.next().unwrap()
[02:51:23] -rusti- 3
[02:51:25] <tikue> rusti: let a = [1, 2, 3]; let mut b = a.iter(); b.next(); b.next(); *b.next().unwrap()
[02:51:26] -rusti- 3
[02:51:40] <strcat> bblum: oh and deriving doesn't work on &
[02:51:44] <strcat> bblum: because of auto-deref :(
[02:51:47] <strcat> look at this mess
[02:51:52] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[02:51:59] <strcat> rusti: let x = 5; let y = &x; let z = (&y).clone(); *z
[02:52:00] -rusti- 5
[02:52:04] <strcat> rusti: let x = 5; let y = &x; let z = y.clone(); *z
[02:52:06] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/MYNh
[02:52:11] <strcat> that's sooooooo weird
[02:52:22] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[02:52:24] <strcat> rusti: let x = 5u; let y = &x; let z = y.clone(); *z
[02:52:25] -rusti- <anon>:7:52: 7:54 error: type uint cannot be dereferenced
[02:52:25] -rusti- <anon>:7          let x = 5u; let y = &x; let z = y.clone(); *z
[02:52:25] -rusti-                                                              ^~
[02:52:25] -rusti- error: aborting due to previous error
[02:52:25] -rusti- application terminated with error code 101
[02:52:31] <strcat> y is &uint
[02:52:36] <strcat> y.clone() returns uint
[02:52:38] <strcat> :|
[02:52:40] <strcat> because it auto-derefs
[02:52:51] <strcat> but
[02:52:53] <strcat> if you clone &&uint
[02:52:56] <strcat> you get &uint
[02:53:03] * strcat hates auto-deref
[02:53:07] <strcat> at least how it is atm
[02:53:39] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[02:53:47] <strcat> if anyone wonders why immutable iterators aren't clonable ;p
[02:54:05] <engla> strcat, do you want to review my dlist PR
[02:54:09] <engla> https://github.com/mozilla/rust/pull/7735
[02:54:51] <tikue> rusti: for None.iter().advance |option| { match option { None => loop, option => (), } }
[02:54:52] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/iEJC
[02:55:17] <tikue> rusti: let a: Option<uint> = None; for a.iter().advance |option| { match option { None => loop, option => (), } }
[02:55:18] -rusti- <anon>:7:84: 7:88 error: mismatched types: expected `&uint` but found an enum or structure pattern
[02:55:18] -rusti- <anon>:7          let a: Option<uint> = None; for a.iter().advance |option| { match option { None => loop, option => (), } }
[02:55:18] -rusti-                                                                                              ^~~~
[02:55:18] -rusti- error: aborting due to previous error
[02:55:20] -rusti- application terminated with error code 101
[02:55:53] <tikue> oh
[02:55:54] <tikue> that's dumb
[02:56:18] <strcat> engla: sec
[02:57:03] <engla> ok
[02:57:59] <tikue> for Some(1).iter().advance |i| { match i { 1 => loop, _ => {} } }
[02:58:05] <tikue> rusti: for Some(1).iter().advance |i| { match i { 1 => loop, _ => {} } }
[02:58:06] -rusti- <anon>:7:52: 7:56 error: mismatched types: expected `&int` but found `<VI1>` (expected &-ptr but found integral variable)
[02:58:06] -rusti- <anon>:7          for Some(1).iter().advance |i| { match i { 1 => loop, _ => {} } }
[02:58:08] -rusti-                                                              ^~~~
[02:58:10] -rusti- error: aborting due to previous error
[02:58:12] -rusti- application terminated with error code 101
[02:58:16] <tikue> rusti: for Some(1).iter().advance |&i| { match i { 1 => loop, _ => {} } }
[02:58:17] -rusti- <anon>:7:67: 7:68 error: unknown start of token: 28
[02:58:17] -rusti- <anon>:7          for Some(1).iter().advance |&i| { match i { 1 => loop, _ => {} } }
[02:58:19] -rusti-                                                                             ^
[02:58:22] -rusti- application terminated with error code 101
[02:58:30] <strcat> rusti: `
[02:58:30] -rusti- <anon>:7:9: 7:10 error: unknown start of token: 96
[02:58:30] -rusti- <anon>:7          `
[02:58:30] -rusti-                   ^
[02:58:30] -rusti- application terminated with error code 101
[02:58:34] <strcat> rusti: ``````
[02:58:35] -rusti- <anon>:7:9: 7:10 error: unknown start of token: 96
[02:58:35] -rusti- <anon>:7          ``````
[02:58:35] -rusti-                   ^
[02:58:37] -rusti- application terminated with error code 101
[02:58:41] <strcat> rusti: < < < < < 
[02:58:41] -rusti- <anon>:7:9: 7:10 error: unexpected token: `<`
[02:58:41] -rusti- <anon>:7          < < < < < 
[02:58:43] -rusti-                   ^
[02:58:44] *** Quits: Ralith (ralith@moz-2E408D26.wireless.sfu.ca) (Ping timeout)
[02:58:44] -rusti- application terminated with error code 101
[02:58:50] <Jeaye> rusti: strcat 
[02:58:50] -rusti- <anon>:7:9: 7:15 error: unresolved name `strcat`.
[02:58:51] -rusti- <anon>:7          strcat 
[02:58:51] -rusti-                   ^~~~~~
[02:58:51] -rusti- error: aborting due to previous error
[02:58:53] -rusti- application terminated with error code 101
[02:58:57] <tikue> what does unkown start of token mean
[02:59:09] <strcat> tikue: it's mad about the ? char
[02:59:18] <strcat> don't understand why it didn't do +M there
[02:59:22] *** Joins: tjc (tjc@46B5412F.3597C859.3AF705F3.IP)
[02:59:22] *** ChanServ sets mode: +o tjc
[02:59:24] <Jeaye> It's looking to tokenize the source and the character is not a valid way to start a token
[02:59:38] <tikue> strcat: which char
[02:59:51] <Jeaye> "the ? char"
[03:00:22] <tikue> I must be blind
[03:00:24] <tikue> I didn't type a '?
[03:00:40] <engla> it's displayed as a \ with inverted text in irssi
[03:00:54] <tikue> engla: where does it occur
[03:00:54] <engla> i.e. it's some kind of nonprintable
[03:01:07] <Jeaye> Could be my own unicode failings
[03:01:16] <engla> between the = and the > where the ^ points
[03:01:40] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[03:02:03] <tikue> rusti: for Some(1).iter().advance |&i| { match i { 1 => loop, _ => {} } }
[03:02:05] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/fDcj
[03:02:27] <tikue> rusti: let a = Some(1); for a.iter().advance |&i| { match i { 1 => loop, _ => {} } }
[03:02:28] -rusti- ()
[03:06:43] *** Quits: cdidd (cdidd@moz-C5BF34D.broadband.corbina.ru) (Input/output error)
[03:08:16] <tikue> rusti: struct Foo(uint); impl<'self> Foo<'self> { fn ref(&self) -> &'self uint { &*self } }
[03:08:16] -rusti- <anon>:7:52: 7:54 error: found `ref` in ident position
[03:08:16] -rusti- <anon>:7          struct Foo(uint); impl<'self> Foo<'self> { fn ref(&self) -> &'self uint { &*self } }
[03:08:16] -rusti-                                                              ^~
[03:08:16] -rusti- error: aborting due to previous error
[03:08:16] -rusti- application terminated with error code 101
[03:09:20] <tikue> rusti: struct Foo(uint); impl Foo { fn<'a> ref(&'a self) -> &'a uint { &*self } }
[03:09:20] -rusti- <anon>:7:40: 7:41 error: expected ident, found `<`
[03:09:20] -rusti- <anon>:7          struct Foo(uint); impl Foo { fn<'a> ref(&'a self) -> &'a uint { &*self } }
[03:09:20] -rusti-                                                  ^
[03:09:21] -rusti- application terminated with error code 101
[03:09:49] <tikue> rusti: struct Foo(uint); impl Foo { fn ref<'a>(&'a self) -> &'a uint { &*self } }
[03:09:49] -rusti- <anon>:7:38: 7:40 error: found `ref` in ident position
[03:09:49] -rusti- <anon>:7          struct Foo(uint); impl Foo { fn ref<'a>(&'a self) -> &'a uint { &*self } }
[03:09:50] -rusti-                                                ^~
[03:09:50] -rusti- error: aborting due to previous error
[03:09:50] -rusti- application terminated with error code 101
[03:10:00] <tikue> rusti: struct Foo(uint); impl Foo { fn refer<'a>(&'a self) -> &'a uint { &*self } }
[03:10:01] -rusti- <anon>:7:75: 7:83 error: mismatched types: expected `&'a uint` but found `&main::Foo` (expected uint but found struct main::Foo)
[03:10:01] -rusti- <anon>:7          struct Foo(uint); impl Foo { fn refer<'a>(&'a self) -> &'a uint { &*self } }
[03:10:01] -rusti-                                                                                     ^~~~~~~~
[03:10:01] -rusti- error: aborting due to previous error
[03:10:02] -rusti- application terminated with error code 101
[03:10:40] <tikue> weird
[03:11:00] <tikue> &*newtype_struct == newtype_struct?
[03:11:05] *** Quits: bytewise (bytewise@moz-649C630D.unitymediagroup.de) (Quit: Leaving)
[03:11:15] <tikue> I guess that shouldn't be surprising
[03:11:31] *** Quits: tjc (tjc@46B5412F.3597C859.3AF705F3.IP) (Quit: zzzzzzzzzz)
[03:11:46] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[03:14:54] <engla> hm
[03:15:01] *** Quits: daofma (arnold@moz-72830A1C.nyc.res.rr.com) (Ping timeout)
[03:16:15] <engla> tikue: don't think so
[03:16:30] <tikue> engla: what does rusti's error msg mean if not that?
[03:16:48] <tikue> engla: ohh. wait...
[03:16:52] <engla> you need one more * 
[03:16:54] <engla> because of &self
[03:16:55] <tikue> rusti: struct Foo(uint); impl Foo { fn refer<'a>(&'a self) -> &'a uint { &**self } }
[03:16:55] -rusti- <anon>:7:84: 7:85 error: unknown start of token: 28
[03:16:55] -rusti- <anon>:7          struct Foo(uint); impl Foo { fn refer<'a>(&'a self) -> &'a uint { &**self } }
[03:16:55] -rusti-                                                                                              ^
[03:16:55] -rusti- application terminated with error code 101
[03:17:00] <tikue> engla:  yeah, thank you
[03:17:20] <tikue> rusti: struct Foo(uint); impl Foo { fn refer<'a>(&'a self) -> &'a uint { &**self } }
[03:17:20] -rusti- <anon>:7:84: 7:85 error: unknown start of token: 28
[03:17:20] -rusti- <anon>:7          struct Foo(uint); impl Foo { fn refer<'a>(&'a self) -> &'a uint { &**self } }
[03:17:20] -rusti-                                                                                              ^
[03:17:20] -rusti- application terminated with error code 101
[03:17:35] <engla> you've got your favourite unprintable char in there again
[03:17:43] <tikue> rusti: struct Foo(uint); impl Foo { fn refer<'a>(&'a self) -> &'a uint { &**self } }
[03:17:45] -rusti- ()
[03:17:51] <tikue> engla: it's annoying because it doesn't show up on my screen
[03:18:02] <tikue> engla: no idea why it's happening
[03:18:18] <engla> I think it's because of a modifier key + space or so
[03:18:27] <engla> since it's right after }
[03:18:30] <engla> } 
[03:18:40] <tikue> engla:  let's see
[03:18:50] <tikue> rusti: letÂ  a = 1; a
[03:18:51] -rusti- <anon>:7:12: 7:12 error: unknown start of token: 160
[03:18:52] -rusti- <anon>:7          letÂ  a = 1; a
[03:18:52] -rusti-                      ^
[03:18:52] -rusti- application terminated with error code 101
[03:18:59] <engla> ok that's a different one
[03:19:00] <tikue> ah, it's Alt + space
[03:19:02] <tikue> oh
[03:19:02] <tikue> lol
[03:19:46] <engla> I too prefer when the keyboard produces visible characters
[03:21:02] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[03:23:50] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[03:24:21] *** Quits: Sorella (queen@78575561.924F2739.95C8B7C6.IP) (Quit: (quit))
[03:25:18] <engla> thanks a lot strcat
[03:25:27] <strcat> :)
[03:25:56] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[03:26:00] <engla> I like the d-e iterators
[03:29:03] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[03:29:06] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[03:31:00] *** Quits: LU324 (stuff@moz-A17E9A7B.dyn.embarqhsd.net) (Ping timeout)
[03:32:37] *** Quits: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com) (Quit: tikue)
[03:32:52] *** Joins: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com)
[03:35:05] <tikue> rusti: let x = { if true { 1 } 2 };
[03:35:05] -rusti- <anon>:7:27: 7:32 error: mismatched types: expected `()` but found `<VI0>` (expected () but found integral variable)
[03:35:05] -rusti- <anon>:7          let x = { if true { 1 } 2 };
[03:35:05] -rusti-                                     ^~~~~
[03:35:06] -rusti- error: aborting due to previous error
[03:35:06] -rusti- application terminated with error code 101
[03:35:12] *** Joins: rajul (quassel@6FD2C126.571F2E7A.13EFE003.IP)
[03:37:27] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[03:39:48] <tikue> rusti: let mut a = ~[]; a.push(1);
[03:39:49] -rusti- ()
[03:45:32] <Eridius> wow, `make check-lite` fails horrifically if I don't use RUST_THREADS=1
[03:45:43] *** Quits: Earnestly (earnest@2AB30F53.FB5005.2BCC804A.IP) (Ping timeout)
[03:46:04] <Eridius> seen a number of failure cases, including "(libuv) Failed to create kqueue (24)", etc. The one that clued me in was "too many open files"
[03:46:19] *** Quits: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net) (Ping timeout)
[03:46:19] <Eridius> which is apparently what the 24 is, that's EMFILE
[03:46:28] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Ping timeout)
[03:47:06] *** Joins: etw (john@moz-B2936CAB.nyc.res.rr.com)
[03:47:25] *** Joins: MaikKlein (maik@moz-B9C8EE03.dip0.t-ipconnect.de)
[03:47:35] <Eridius> oh neat, I can't `make check-lite` twice in a row. check-summary.py errors out on the subsequent runs
[03:48:17] *** Joins: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net)
[03:48:24] <Eridius> ahh I think make may be skipping the actual checks, and then check-summary finds no logs
[03:50:08] *** Joins: dew (Instantbir@moz-66796D51.dhcp.stls.mo.charter.com)
[03:51:46] *** Quits: glinscott (garylinsco@789A6618.53EB7C1.FFFE3AA.IP) (Ping timeout)
[03:52:11] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[03:52:14] *** Quits: anri (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net) (Ping timeout)
[03:52:43] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[03:52:59] *** Joins: glinscott (garylinsco@789A6618.53EB7C1.FFFE3AA.IP)
[03:53:00] *** Joins: anri (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net)
[03:53:10] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[03:53:49] *** Quits: ross (ross@moz-8A84103E.br.br.cox.net) (Quit: )
[03:54:01] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[03:55:16] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[03:55:38] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[03:55:38] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/1O4kEg
[03:55:38] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[03:58:38] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[03:58:38] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/ACMHHA
[03:58:38] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[03:58:39] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[03:58:39] <ghrust> 01[13rust01] 15bors pushed 9 new commits to 06auto: 02http://git.io/0PPjhg
[03:58:39] <ghrust> 13rust/06auto 14c2d7d8f 15Patrick Walton: librustc: Add a lint mode for unnecessary `copy` and remove a bunch of them.
[03:58:39] <ghrust> 13rust/06auto 14fb15df6 15Patrick Walton: librustc: Remove all uses of "copy".
[03:58:39] <ghrust> 13rust/06auto 142869b42 15Patrick Walton: librustc: Remove `copy` expressions from the language.
[03:58:41] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[03:59:57] *** Joins: Ralith (ralith@moz-50F3C77.vc.shawcable.net)
[04:00:25] *** Quits: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com) (Quit: tikue)
[04:02:00] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Connection reset by peer)
[04:04:17] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[04:04:26] *** Quits: MaikKlein (maik@moz-B9C8EE03.dip0.t-ipconnect.de) (Ping timeout)
[04:04:57] <engla> noo I think the copy PR will fail again
[04:05:25] <engla> ah pcw saw my comment
[04:05:29] <engla> there is hope
[04:07:37] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[04:07:37] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 144a29dac to 14d2cf292: 02http://git.io/N3iJvQ
[04:07:37] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[04:07:38] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[04:07:38] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/swmc-Q
[04:07:38] <ghrust> 13rust/06auto 14d3a6bd4 15Graydon Hoare: extra: add tests for test::MetricMap, MetricDiff, ratchet.
[04:07:38] <ghrust> 13rust/06auto 143a97c88 15bors: auto merge of #7731 : graydon/rust/test-for-test-ratchet, r=cmr...
[04:07:39] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[04:09:12] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[04:14:59] *** Joins: MaikKlein (maik@moz-B9C8EE03.dip0.t-ipconnect.de)
[04:22:30] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[04:25:17] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[04:26:15] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[04:31:40] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[04:31:40] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 143a97c88 to 14d2cf292: 02http://git.io/N3iJvQ
[04:31:40] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[04:33:17] *** Quits: Raynes (macro@moz-E5F01CE6.members.linode.com) (Quit: ZNC - http://znc.sourceforge.net)
[04:35:34] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Leaving...)
[04:39:31] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[04:39:45] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[04:40:39] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[04:40:39] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/SFFBfw
[04:40:39] <ghrust> 13rust/06auto 142cd9d7b 15Alex Crichton: Expand ctypes warnings to warn about *int/*uint...
[04:40:39] <ghrust> 13rust/06auto 14d582eeb 15bors: auto merge of #7734 : alexcrichton/rust/issue-3395, r=sanxiyn...
[04:40:39] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[04:40:42] *** Joins: goffrie (goffrie@moz-A3ADCE7B.dsl.ncf.ca)
[04:41:11] <Eridius> While running the std tests, I ran out of file descriptors. I have lldb attached and paused on the abort() call
[04:41:16] <Eridius> is there anything I can do to try and figure out what happened?
[04:44:18] <sp3d> get a backtrace?
[04:44:40] <Eridius> sp3d: well the backtrace at the abort time isn't very helpful, it's aborting because it ran out of fds
[04:44:56] <Eridius> so the point where it aborted isn't actually the problem
[04:45:43] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[04:50:55] *** Joins: wrm888 (wrm@moz-563ECDC6.hsd1.pa.comcast.net)
[04:52:41] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[04:53:00] *** Quits: wrm888 (wrm@moz-563ECDC6.hsd1.pa.comcast.net) (Client exited)
[04:54:01] <goffrie> Eridius: you could take a look at what files are actually open? (`lsof -p pid`)
[04:56:25] *** Quits: MaikKlein (maik@moz-B9C8EE03.dip0.t-ipconnect.de) (Ping timeout)
[04:56:45] <Eridius> goffrie: they're mostly all PIPEs
[04:56:50] <Eridius> with nice little hex identifiers
[04:57:08] <goffrie> oh fun.
[04:57:50] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Ping timeout)
[04:58:17] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[04:59:30] <sp3d> Eridius: isn't it aborting because it can't allocate a file?
[04:59:37] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[04:59:55] <sp3d> the last allocation isn't necessarily the cause of fd exhaustion, but it presumably correlates with it over n runs ;)
[04:59:56] <Eridius> sp3d: it's trying to open("/dev/urandom") in this particular case, but why is that relevant?
[05:00:11] <Eridius> and this fd is closed shortly after (in the same function)
[05:00:31] <sp3d> someone had mentioned tasks were opening urandom on starting and failing on fd exhaustion yesterday or so IIRC?
[05:00:45] <sp3d> (hopefully it wasn't you or I'm wasting breath :P)
[05:01:29] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Ping timeout)
[05:04:03] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[05:04:53] <Eridius> sp3d: it wasn't me
[05:05:00] <Eridius> the question is, what's opening all these PIPEs
[05:05:03] <Eridius> and not closing them
[05:05:18] <sp3d> good question
[05:09:18] <acrichto> is anyone familiar with the annihilator that runs to clean up @ boxes?
[05:11:33] *** Joins: victorporof (victorporo@74A9C5E8.1745F5FA.9B1E38F4.IP)
[05:12:04] <Eridius> wow, I just caught another abort in lldb and I have 87 threads active
[05:12:07] <Eridius> that's, um, a lot
[05:21:40] <strcat> acrichto: a bit, why?
[05:23:52] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[05:24:05] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[05:25:00] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[05:26:48] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[05:27:11] <acrichto> strcat: I was curious when it actually ran, but it appears to be at the end of the task
[05:27:54] <acrichto> strcat: if you care a circular reference in jit code, then it's cleaned up when the main task exits, not when the jit task exits, which when your generated glue is in the jit code and it's dropped inbetween...
[05:27:55] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[05:28:21] <acrichto> now I'm wondering why it's not cleaned up sooner
[05:31:36] *** Joins: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net)
[05:32:14] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[05:32:14] *** ChanServ sets mode: +o dherman
[05:32:29] *** Quits: victorporof (victorporo@74A9C5E8.1745F5FA.9B1E38F4.IP) (Quit: victorporof)
[05:36:31] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[05:36:52] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[05:37:51] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Leaving...)
[05:38:41] *** Quits: sankha93 (Instantbir@2EAF9EF4.C0D45E01.EFB84E89.IP) (Ping timeout)
[05:41:17] *** Quits: RMF (RMF@moz-395E4371.dsl.telepac.pt) (Quit: Textual IRC Client: www.textualapp.com)
[05:42:54] *** Joins: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com)
[05:46:20] *** Joins: RMF (RMF@moz-395E4371.dsl.telepac.pt)
[05:47:18] *** Quits: jdm (jdm@F2D29657.F60B0462.67AC9B1.IP) (Quit: Lost terminal)
[05:48:00] *** Quits: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Quit: Don't tell them I was here...)
[05:50:50] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[05:52:06] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[05:52:51] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[05:54:00] *** Quits: lahwran (lahwran@209.236.121.166) (Ping timeout)
[05:54:09] *** Joins: lahwran (lahwran@lahwran.net)
[05:54:36] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[05:56:35] *** Joins: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net)
[05:59:10] *** Joins: Nisstyre (wes@moz-FD86289.netflash.net)
[06:08:24] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[06:14:29] *** Quits: dwhyte (dwhyte@ED9190FB.B72E355F.7BF4A4B0.IP) (Quit: Leaving.)
[06:15:50] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[06:17:38] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[06:19:12] *** Joins: richardo (Mibbit@moz-6C3A5164.dhcp.bycy.mi.charter.com)
[06:19:16] <richardo> hello
[06:19:35] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[06:19:35] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/SFFBfw
[06:19:35] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[06:20:05] <richardo> can anyone help me getting up and running with cargo, the rust package manager?
[06:22:32] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[06:22:33] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/ZtbOIw
[06:22:33] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[06:22:35] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[06:22:35] <ghrust> 01[13rust01] 15bors pushed 9 new commits to 06auto: 02http://git.io/67Z-Qg
[06:22:35] <ghrust> 13rust/06auto 14c2d7d8f 15Patrick Walton: librustc: Add a lint mode for unnecessary `copy` and remove a bunch of them.
[06:22:35] <ghrust> 13rust/06auto 14fb15df6 15Patrick Walton: librustc: Remove all uses of "copy".
[06:22:35] <ghrust> 13rust/06auto 142869b42 15Patrick Walton: librustc: Remove `copy` expressions from the language.
[06:22:37] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[06:23:32] <richardo> oh snap
[06:23:37] <richardo> rustpkg
[06:23:42] <richardo> not cargo!
[06:25:20] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[06:26:59] <richardo> hmm
[06:27:03] <richardo> rustpkg
[06:27:08] <richardo> hi erickt
[06:27:25] <richardo> i just saw your stackoverflow post regarding sockets
[06:27:29] <richardo> and cargo
[06:27:49] <richardo> is cargo still relevant? or is rustpkg the replacement?
[06:28:18] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[06:28:26] <richardo> nooooo
[06:30:44] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[06:31:54] <ChrisMorgan> rustpkg is what it is now. And it's very much a work in progress.
[06:32:06] <richardo> ah thank you
[06:32:30] <richardo> is it like npm at all? connected to an online repository? or do i need to find the packages myself?
[06:32:49] <richardo> i didnt see a search option
[06:32:54] <ChrisMorgan> As for sockets, extra::net is basically unmainitained and is being replaced by what is currently std::rt::io::net.
[06:33:17] <ChrisMorgan> It's still a work in progress. I haven't used it myself yet, but it is that sort of a tool.
[06:33:30] <richardo> gotcha
[06:33:56] *** Joins: victorporof (victorporo@moz-613026B7.info.uaic.ro)
[06:40:05] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[06:44:28] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[06:45:12] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[06:45:50] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[06:48:54] *** Joins: cdidd (cdidd@moz-35D9B688.broadband.corbina.ru)
[06:50:12] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[06:50:12] <ghrust> 01[13rust01] 15bors pushed 5 new commits to 06auto: 02http://git.io/GDae9A
[06:50:12] <ghrust> 13rust/06auto 14c6e7890 15blake2-ppc: dlist: Fix bug in DList::merge...
[06:50:12] <ghrust> 13rust/06auto 1489a0c99 15blake2-ppc: dlist: Implement DoubleEndedIterator and use for .iter() and .rev_iter()
[06:50:13] <ghrust> 13rust/06auto 14e1d5d1c 15blake2-ppc: dlist: Use DoubleEndedIterator for .consume_rev_iter()
[06:50:15] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[06:50:27] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[06:50:45] <richardo> sweet mother, i'm doing it.. i'm really doing it
[06:51:06] <richardo> i actually got some ncurses library to work
[06:51:37] <richardo> now for sockets!
[06:53:11] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[06:53:34] <richardo> std::rt::io::net is the way to go, not std::net_tcp
[06:54:54] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[06:57:09] *** Quits: etw (john@moz-B2936CAB.nyc.res.rr.com) (Quit: etw)
[07:00:24] *** Quits: victorporof (victorporo@moz-613026B7.info.uaic.ro) (Connection reset by peer)
[07:06:02] *** Joins: pyrac (pyrac@moz-F2C67F88.w83-114.abo.wanadoo.fr)
[07:09:29] <ChrisMorgan> What used to be std::net_tcp (though typically referred to as std::net::tcp) is now extra::net::tcp. And soon it'll be nowhere.
[07:09:53] <ChrisMorgan> Just don't expect std::rt::io::net stuff to work yet, necessarily.
[07:11:02] <ChrisMorgan> For me, it's compiling but failing in TcpListener::bind(), so I wrote a quick 'n dirty adapter for extra::net::tcp with the newer API, which works a little more successfully at present, though it's certainly incomplete.
[07:11:44] <ChrisMorgan> Great... and now I've got an ICE... "error: internal compiler error: duplicate LLVM symbol: _ZN17librusthttpserver7request14__extensions__5State6Normal7descrim17_ad8c937ef4dd10dc7_0$x2e0E
[07:11:44] <ChrisMorgan> leaked memory in rust main loop (1 objects)"
[07:12:12] *** Joins: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[07:12:15] <ChrisMorgan> So much for that fancy state machine (FSM ;-))
[07:12:37] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[07:14:44] <ChrisMorgan> richardo: certainly you should only be playing in rust at present if you're brave.
[07:19:03] <Eridius> git bisecting through all the changes since release-0.7 is really slow :( (trying to find what introduced the fd exhaustion while running libstd's tests)
[07:20:34] *** Quits: richardo (Mibbit@moz-6C3A5164.dhcp.bycy.mi.charter.com) (Quit: http://www.mibbit.com ajax IRC Client)
[07:22:19] <ChrisMorgan> Oh dear... this ICE doesn't want to show up in my guess of a minimal test case :-(
[07:25:11] <ChrisMorgan> Problem is certainly related to having an enum defined inside a method.
[07:26:44] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[07:29:32] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[07:30:50] *** Quits: pyrac (pyrac@moz-F2C67F88.w83-114.abo.wanadoo.fr) (Quit: pyrac)
[07:31:05] *** Joins: nano (nano@moz-972880B.superkabel.de)
[07:31:29] *** Joins: victorporof (victorporo@moz-613026B7.info.uaic.ro)
[07:36:59] *** Joins: pyrac (pyrac@moz-F2C67F88.w83-114.abo.wanadoo.fr)
[07:43:16] *** Quits: Jesin (Jessin_@moz-48B48C95.eecs.lehigh.edu) (Quit: Leaving)
[07:51:06] *** Joins: valentin (valentin@moz-FF32B246.red-80-27-103.dynamicip.rima-tde.net)
[07:51:09] <eevee> https://gist.github.com/eevee/5989881  simpler version of the problem i am bumbling into with amulet
[07:52:04] <strcat> eevee: you can't return a temporary by-reference
[07:52:21] <strcat>  fn spawn_child(&'self self) âŸ¶â€€ &'self Child {
[07:52:32] <strcat> means you're returning a pointer to something inside &self
[07:52:34] <strcat> and it's not
[07:53:07] <strcat> fn spawn_child<'r>(&'r self) -> &'r Child would be the way to do that, if you wanted to
[07:53:16] <strcat> but then Child would have to be stored in self
[07:53:27] <strcat> 'self isn't valid in that impl
[07:53:31] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[07:54:07] <strcat> if you just want the child to reference the parent, 
[07:54:21] <strcat> fn spawn_child<'r>(&'r self) -> Child<'r>
[07:54:36] <strcat> and Child can contain that self reference
[07:55:15] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[07:55:24] * strcat is tired and hopes that all made sense ;p
[07:55:32] <eevee> aha!  yes it did
[07:55:41] <eevee> Child<'r> is the clever insight that i somehow totally missed, ha
[07:55:42] <eevee> thanks!
[08:00:01] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[08:00:35] *** Quits: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net) (Quit: tikue)
[08:01:20] *** Joins: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net)
[08:02:59] <ChrisMorgan> There, I figured my ICE out. Sibling methods containing identally named enums with an identically named member.
[08:03:40] <eevee> hrm that solved one of my lifetime problems but not the other
[08:04:06] <ChrisMorgan> In my case, I had two methods each with an embedded FSM, so they each had an enum State { Normal, etc. }.
[08:04:13] <eevee> wait uhh haha.  i'm getting alternating errors on subsequent compiles
[08:06:14] <strcat> ChrisMorgan: can you report that?
[08:06:27] <strcat> I don't think it's a known one
[08:07:09] *** Joins: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP)
[08:10:59] <eevee> ah and i seem to be blocked on https://github.com/mozilla/rust/issues/5708 hm.
[08:13:08] *** Joins: AndroUser2 (androirc@moz-D298E390.dab.02.net)
[08:15:34] *** Quits: dew (Instantbir@moz-66796D51.dhcp.stls.mo.charter.com) (Connection reset by peer)
[08:17:59] *** Quits: victorporof (victorporo@moz-613026B7.info.uaic.ro) (Ping timeout)
[08:18:18] <bjz_> rusti: use std::container::*; trait Foo<Slice> { } impl<T> Foo<[T,..2]> int {} fn foo<Slice: Container, T: Foo<Slice>(t: T) -> T { t } foo(1)
[08:18:18] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/bTIJ
[08:18:35] <bjz_> rusti: use std::container::*; trait Foo<Slice> { } impl<T> Foo<[T,..2]> for int {} fn foo<Slice: Container, T: Foo<Slice>(t: T) -> T { t } foo(1)
[08:18:36] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/bSPB
[08:18:39] *** Joins: victorporof (victorporo@moz-613026B7.info.uaic.ro)
[08:18:58] <bjz_> rusti: use std::container::*; trait Foo<Slice> { } impl<T> Foo<[T,..2]> for int {} fn foo<Slice: Container, T: Foo<Slice>>(t: T) -> T { t } foo(1)
[08:19:00] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/LIYj
[08:19:24] *** Quits: _Vi (vi@527C345F.497AA854.B16B3BE6.IP) (Ping timeout)
[08:19:28] <bjz_> rusti: use std::container::*; trait Foo<Slice> { } impl<T> Foo<[int,..2]> for int {} fn foo<Slice: Container, T: Foo<Slice>>(t: T) -> T { t } foo(1)
[08:19:30] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/DMiX
[08:19:42] <bjz_> dbaupp: ^ :(
[08:19:53] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[08:20:10] <bjz_> is that the 'lack of constant params' again?
[08:22:40] *** Joins: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net)
[08:23:55] *** Quits: victorporof (victorporo@moz-613026B7.info.uaic.ro) (Ping timeout)
[08:24:03] <strcat> alright that rustpkg problem is unrelated
[08:24:06] <strcat> happened on several PRs
[08:24:40] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[08:24:40] <ghrust> 01[13rust01] 15thestinger pushed 1 new commit to 06master: 02http://git.io/dqQJqg
[08:24:40] <ghrust> 13rust/06master 14a9eb868 15Daniel Micay: Merge pull request #7735 from blake2-ppc/dlist...
[08:24:40] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[08:25:35] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[08:25:35] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 146453a97 to 14a9eb868: 02http://git.io/N3iJvQ
[08:25:35] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[08:25:36] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[08:25:36] <ghrust> 01[13rust01] 15bors pushed 5 new commits to 06auto: 02http://git.io/VYGzDQ
[08:25:36] <ghrust> 13rust/06auto 14df13bea 15Tim Chevalier: extra: Change XXX to NOTE
[08:25:36] <ghrust> 13rust/06auto 1485a6bcc 15Tim Chevalier: extra: change XXX to NOTE
[08:25:36] <ghrust> 13rust/06auto 14d0500d1 15Tim Chevalier: extra: change alloc to take &mut self, as per XXX comment
[08:25:37] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[08:25:38] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[08:26:45] <Eridius> strcat: any idea what went wrong with bors on my PR?
[08:26:45] *** Quits: pyrac (pyrac@moz-F2C67F88.w83-114.abo.wanadoo.fr) (Quit: pyrac)
[08:27:58] <dbaupp> bjz_: yes
[08:28:05] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[08:28:11] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[08:28:30] *** Quits: scanlonman (scanlonman@moz-169BC238.hsd1.wa.comcast.net) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[08:29:19] <dbaupp> tikue: the reason #[deriving] doesn't work on the stuff you were doing hours ago is (mostly) a problem with rusti, not with #[deriving], https://github.com/mozilla/rust/issues/6727
[08:29:20] *** Joins: scanlonman (scanlonman@moz-169BC238.hsd1.wa.comcast.net)
[08:29:32] <dbaupp> tikue: it will work fine at the top level *not* inside a function
[08:29:35] <tikue> dbaupp: oh! good to know. thank you :)
[08:29:47] <dbaupp> strcat: pong (for days ago)
[08:30:16] <dbaupp> strcat: I assume you were going to say something about double ended iterators? (The implementation is very nice, btw.)
[08:30:27] <bjz_> dbaupp: impl<T, LEN: uint> Container for [T,..LEN] { fn is_empty(&self) -> bool { false } fn len(&self) -> uint { LEN } }
[08:30:30] <bjz_> :P
[08:30:40] * dbaupp wishes that worked
[08:30:57] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[08:31:18] <eevee> omg omg omg amulet compiled
[08:31:19] <eevee> omg
[08:32:47] <doomlord> i did some cut/pasting for impl Arrary2 .  impl Array4 .. impl Array8 :)
[08:33:22] <dbaupp> doomlord: surely macros would work ;P
[08:33:56] <doomlord> yeah that would be better
[08:34:10] <ChrisMorgan> strcat: yes, I've reported all the problems I've found thus far which hadn't already been reported. Just had to have tea first. Now that one is https://github.com/mozilla/rust/issues/7770
[08:34:30] <bjz_> rusti: [1, 2, 3].len()
[08:34:31] -rusti- 3
[08:35:32] *** Joins: victorporof (victorporo@moz-613026B7.info.uaic.ro)
[08:39:22] *** Joins: mye (mye@moz-9B08539F.dip0.t-ipconnect.de)
[08:40:05] *** Joins: _Vi (vi@527C345F.497AA854.B16B3BE6.IP)
[08:41:04] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[08:42:28] *** Quits: _Vi (vi@527C345F.497AA854.B16B3BE6.IP) (Ping timeout)
[08:43:26] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[08:44:37] *** Joins: Ms2ger (Ms2ger@3F038EB7.1AB48F49.F15B0BB3.IP)
[08:47:49] *** Joins: SimonSapin (simon@moz-D0C2F181.zone2.bethere.co.uk)
[08:49:26] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[08:49:35] *** Joins: _Vi (vi@527C345F.497AA854.B16B3BE6.IP)
[08:51:10] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[08:52:28] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.1)
[08:53:51] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[08:54:18] *** Joins: sankha93 (Instantbir@295E2ED5.A06F18D1.EFB84E89.IP)
[08:55:32] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[08:55:32] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1411ce55b to 14a9eb868: 02http://git.io/N3iJvQ
[08:55:32] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[08:55:35] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[08:55:35] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/0jjDrg
[08:55:35] <ghrust> 13rust/06auto 144f4dfcd 15Alex Crichton: Allow non-uppercase-statics by default...
[08:55:35] <ghrust> 13rust/06auto 1491ead0e 15Alex Crichton: Clean up various warnings throughout the codebase
[08:55:36] <ghrust> 13rust/06auto 1402d142c 15Alex Crichton: Purge the last remnants of the old TLS api...
[08:55:38] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[08:55:44] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[08:59:57] *** Quits: victorporof (victorporo@moz-613026B7.info.uaic.ro) (Ping timeout)
[09:00:01] *** Joins: victorporof (victorporo@moz-613026B7.info.uaic.ro)
[09:03:33] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[09:04:01] *** Quits: victorporof (victorporo@moz-613026B7.info.uaic.ro) (Ping timeout)
[09:04:49] *** Joins: victorporof (victorporo@moz-613026B7.info.uaic.ro)
[09:05:25] *** Joins: victorporof_ (victorporo@moz-613026B7.info.uaic.ro)
[09:05:37] *** Quits: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net) (Quit: tikue)
[09:05:51] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[09:06:52] *** Quits: victorporof (victorporo@moz-613026B7.info.uaic.ro) (Ping timeout)
[09:08:16] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[09:08:51] *** Quits: nano (nano@moz-972880B.superkabel.de) (Ping timeout)
[09:09:26] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[09:12:53] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[09:13:46] <bjz_> rusti struct hi;
[09:13:55] <bjz_> rusti: struct hi;
[09:13:56] -rusti- ()
[09:14:03] <bjz_> rusti: struct hi_i;
[09:14:04] -rusti- ()
[09:14:26] <eevee> what are my options for debugging a failure
[09:19:42] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[09:24:58] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[09:25:16] <kimundi> eevee: gdb
[09:27:32] <Eridius> finally diagnosed where the test failures were coming from: https://github.com/mozilla/rust/issues/7772
[09:27:53] <Eridius> sadly, I only figured out what exposed them (bumping test threads from 4 to num_cpus*2), not what's actually causing the overuse of fds
[09:29:35] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[09:32:14] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[09:36:26] <eevee> well except that this one program inexplicably thinks my terminal is 0Ã—0 this is coming along pretty well
[09:36:43] *** Joins: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP)
[09:37:52] <eevee> wait, no, that only happens when i pipe through cat -v to catch the failure message.  so this is a quantum bug awesome
[09:37:59] <eevee> i think that means it's bedtime
[09:39:18] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[09:41:56] *** Quits: victorporof_ (victorporo@moz-613026B7.info.uaic.ro) (Quit: victorporof_)
[09:42:30] <dbaupp> Eridius: you could possibly grep for /dev/urandom in src/rt and put some diagnostics there (i.e. printf), because the scheduler random number generator gets reseeded from /dev/urandom every so often
[09:42:33] <cmr> Is bors misbehaving? The queue is empty!
[09:42:44] <dbaupp> Eridius: and it is possibly not being closed properly
[09:42:47] * dbaupp is guessing
[09:43:16] <dbaupp> cmr: impossible!
[09:43:44] <dbaupp> cmr: well, there's a lot of blue.
[09:43:56] *** Quits: scanlonman (scanlonman@moz-169BC238.hsd1.wa.comcast.net) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[09:46:53] <cmr> rusti: enum Foo {A, B, C} std::sys::size_of::<Foo>()
[09:46:54] -rusti- 8
[09:48:32] <cmr> An optimization that uses the smallest integer type needed to represent the amount of variants for c-style enums would probably be useful, re #7765
[09:49:18] <dbaupp> cmr: third value for "no comparison"?
[09:49:22] <cmr> Yes
[09:49:45] <cmr> Partial order (the Ord trait) means that the comparison does not need to be defined for all pairs of all values of a type.
[09:49:46] <dbaupp> i.e. a < b = no comparison if you can't compare a and b?
[09:49:55] <cmr> yup
[09:50:15] <dbaupp> I believe a < b is asking "is a less than b", so if they can't be compared, the answer is `false`.
[09:50:26] <cmr> it's indeterminate
[09:50:35] <dbaupp> not really
[09:50:53] <dbaupp> It depends on the semantics we want for Ord
[09:51:19] <cmr> Having Ord *and* TotalOrd doesn't make sense if that isn't the semantics for Ord, imo
[09:51:40] <cmr> I dunno
[09:51:45] <cmr> maybe I misunderstand the entire concept
[09:51:49] <dbaupp> Ord doesn't have the guarantee that `(a < b || a >= b)`
[09:51:53] <cmr> but what we have now doesn't feel wrong
[09:52:16] <cmr> erm, doesn't feel right
[09:52:29] <dbaupp> rusti: use std::float::NaN; NaN < Nan || Nan >= NaN
[09:52:31] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/ZCBW
[09:52:45] <dbaupp> rusti: use std::float::NaN; NaN < NaN || NaN >= NaN
[09:52:46] -rusti- false
[09:53:19] <dbaupp> (python does the same)
[09:53:45] <cmr> I understand that Ord works well for floats, as that is what it was designed for, but I'm not convinced that it's the correct trait for expressing all partial orders
[09:54:11] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[09:54:29] <dbaupp> the way I see it, it's essentially test for the existence of an edge in a graph
[09:54:31] <dbaupp> e.g. https://upload.wikimedia.org/wikipedia/commons/e/ea/Hasse_diagram_of_powerset_of_3.svg
[09:54:38] <dbaupp> *testing
[09:54:51] <dbaupp> and true/false is the correct answer for this
[09:55:52] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[09:56:09] <cmr> hm, that makes sense
[09:56:36] *** Joins: Earnestly (earnest@2AB30F53.FB5005.2BCC804A.IP)
[09:56:54] <dbaupp> I could imagine a more complete PartialOrd trait that has compare -> enum { Less, Equal, Greater, NoComparision }
[09:57:14] <dbaupp> but that'd make using Ord fairly awkward.
[09:57:29] <cmr> yeah
[09:58:15] <dbaupp> the default implementations do mean that Ord is a total ordering though
[09:58:42] <cmr> that was my biggest rejection of having default implementations yesterday
[09:58:49] <cmr> it means the default implementations are potentially wrong
[09:58:52] <cmr> but... not sure it's a big deal
[09:59:02] <dbaupp> yeah, but many types are totally ordered
[09:59:24] <dbaupp> (most, ignoring ones that inherit non-total ordering from a floating point member.)
[09:59:41] <cmr> Also, there should be an impl<T:TotalOrd> Ord for T, I think
[09:59:51] <cmr> if one doesn't exist
[09:59:53] <dbaupp> and so defaulting to it (which is the only possibly default) is correct
[10:00:02] <cmr> engla pointed out that today you need to implement both, which is weird
[10:00:03] <dbaupp> cmr: not possible, conflicts with everything
[10:00:16] <dbaupp> it'd be very nice though
[10:00:57] *** Joins: slaren (slaren@moz-4FB591EB.red-88-24-241.staticip.rima-tde.net)
[10:01:02] <dbaupp> do we even have TotalOrd: Ord, because TotalOrd could have a default impl in terms of Ord, and so it just needs `impl TotalOrd for MyType {}`
[10:07:47] *** Joins: victorporof (victorporo@moz-613026B7.info.uaic.ro)
[10:10:23] *** Joins: pyrac (pyrac@moz-F2C67F88.w83-114.abo.wanadoo.fr)
[10:13:48] *** Quits: txdv (quassel@966F3542.3BA477DA.14C26596.IP) (Ping timeout)
[10:13:51] *** Joins: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl)
[10:14:21] *** Joins: txdv (quassel@966F3542.3BA477DA.14C26596.IP)
[10:15:09] <cmr> dbaupp: given how stable peak memory usage was for a good chunk of time, I think it might be a problem with rustc
[10:15:45] <dbaupp> cmr: the fact that it's now like /\/\/\/\/\?
[10:15:51] <cmr> (we have benched every PR in the past two weeks!)
[10:15:57] <cmr> dbaupp: yeah
[10:16:08] <dbaupp> cmr: \o/
[10:16:08] <cmr> all of it is linker perturbations afaict
[10:16:09] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[10:16:12] <cmr> but it didn't exist before.
[10:16:20] <cmr> so I think it's a legitimate regression
[10:16:30] <dbaupp> and that's despite losing a day of benching.
[10:17:03] <dbaupp> cmr: yeah, it seems to have been caused by the aatch's ast thing, so I'd wait until that's fixed before worrying
[10:17:24] <dbaupp> (also, has aatch been around recently? I haven't seen him for a while.)
[10:17:37] <dbaupp> but it is pretty strange
[10:17:40] <cmr> I saw him before I went to bed
[10:18:42] <dbaupp> it's peculiar how it is always the same spike
[10:19:09] <dbaupp> (and that the spike is essentially entirely missing on some prs.)
[10:19:59] <cmr> dbaupp: did you see that graydon has metrics collecting and reporting now?
[10:20:12] <dbaupp> cmr: which ones?
[10:20:22] <dbaupp> for the performance rachet?
[10:20:24] <cmr> yeah
[10:20:46] <cmr> I asked him to turn it on and keep all the data, even if it isn't ratcheted yet
[10:21:02] <dbaupp> where's it get collected to?
[10:21:11] <cmr> in the buldbots' workspaces afaik
[10:21:12] <dbaupp> (also, yes, collecting as much as possible is good.)
[10:22:35] *** Joins: Archer (Archer@moz-DA478E33.bb.online.no)
[10:24:03] *** Quits: sankha93 (Instantbir@295E2ED5.A06F18D1.EFB84E89.IP) (Ping timeout)
[10:24:48] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[10:25:00] *** Quits: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl) (Client exited)
[10:31:01] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[10:33:49] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[10:34:46] *** Quits: doomlord_ (servitor@moz-13E69BC8.range86-180.btcentralplus.com) (Connection reset by peer)
[10:34:46] *** Quits: n00b6502 (kwr5y54@moz-13E69BC8.range86-180.btcentralplus.com) (Quit: Lost terminal)
[10:36:12] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[10:36:41] *** Joins: fabiand (fabiand@moz-7547B95F.adsl.alicedsl.de)
[10:50:21] *** Joins: nano (nano@moz-972880B.superkabel.de)
[10:54:32] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[10:54:35] *** Joins: olleharstedt (Thunderbir@moz-80D8890F.ias.bredband.telia.com)
[10:56:13] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[10:57:01] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[10:58:03] *** Joins: sankha93 (Instantbir@1D8D62BE.7FCF9508.EFB84E89.IP)
[10:59:28] *** Joins: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl)
[11:03:45] *** Joins: mreedell (mreedell@moz-9950CA28.hsd1.pa.comcast.net)
[11:05:25] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[11:07:34] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[11:08:46] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[11:11:06] *** Quits: victorporof (victorporo@moz-613026B7.info.uaic.ro) (Ping timeout)
[11:11:42] *** Joins: victorporof (victorporo@moz-613026B7.info.uaic.ro)
[11:12:48] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[11:13:05] *** Joins: victorporof_ (victorporo@moz-613026B7.info.uaic.ro)
[11:14:38] *** Quits: victorporof (victorporo@moz-613026B7.info.uaic.ro) (Ping timeout)
[11:18:20] *** Quits: fabiand (fabiand@moz-7547B95F.adsl.alicedsl.de) (Quit: Verlassend)
[11:19:04] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[11:30:05] <bjz_> rusti: struct Vec3 { x: bool, y: bool, z: bool } std::sys::size_of::<Vec3>()
[11:30:06] -rusti- 3
[11:31:06] <bjz_> rusti: struct Vec3<T> { x: T, y: T, z: T } (std::sys::size_of::<Vec3<bool>>(), std::sys::size_of::<Vec3<u8>>(), std::sys::size_of::<Vec3<float>>())
[11:31:07] -rusti- (3, 3, 24)
[11:31:36] <bjz_> rusti: std::sys::size_of::<(bool, bool, bool)>()
[11:31:37] -rusti- 3
[11:32:27] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[11:33:40] <leonvv> Where is "DuplexStream" located in 0.7 ?
[11:33:53] <cmr> extra::comm iirc?
[11:34:54] *** Quits: mreedell (mreedell@moz-9950CA28.hsd1.pa.comcast.net) (Quit: Computer has gone to sleep.)
[11:35:02] <cmr> rusti: 1f
[11:35:05] *** Joins: nano (nano@moz-972880B.superkabel.de)
[11:35:05] -rusti- 1
[11:35:09] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[11:35:49] <leonvv> Thanks, it works now
[11:36:54] *** Quits: pyrac (pyrac@moz-F2C67F88.w83-114.abo.wanadoo.fr) (Quit: pyrac)
[11:37:52] *** Joins: MaikKlein (maik@moz-52EA1D97.dip0.t-ipconnect.de)
[11:39:12] <bjz_> rusti: -true
[11:39:13] -rusti- <anon>:7:9: 7:14 error: cannot apply unary operator `-` to type `bool`
[11:39:13] -rusti- <anon>:7          -true
[11:39:13] -rusti-                   ^~~~~
[11:39:13] -rusti- error: aborting due to previous error
[11:39:13] -rusti- application terminated with error code 101
[11:40:13] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[11:41:54] *** Quits: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com) (Ping timeout)
[11:42:37] *** Joins: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com)
[11:43:02] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[11:44:12] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[11:47:42] <kimundi> rusti: true - true
[11:47:42] -rusti- <anon>:7:9: 7:20 error: binary operation - cannot be applied to type `bool`
[11:47:43] -rusti- <anon>:7          true - true
[11:47:43] -rusti-                   ^~~~~~~~~~~
[11:47:43] -rusti- error: aborting due to previous error
[11:47:43] -rusti- application terminated with error code 101
[11:47:48] <bjz_> :P
[11:47:51] <cmr> kimundi: true + false
[11:47:54] <cmr> erm
[11:47:57] <cmr> rusti: true + false
[11:47:58] -rusti- <anon>:7:9: 7:21 error: binary operation + cannot be applied to type `bool`
[11:47:58] -rusti- <anon>:7          true + false
[11:47:58] -rusti-                   ^~~~~~~~~~~~
[11:47:58] -rusti- error: aborting due to previous error
[11:47:58] -rusti- application terminated with error code 101
[11:48:01] <cmr> rusti: true ^ false
[11:48:02] -rusti- true
[11:48:19] <bjz_> wut
[11:48:26] <Ms2ger> xor?
[11:48:32] <cmr> why wouldn't we have boolean operations on bools? :p
[11:49:10] <bjz_> that looks like conjunction :P
[11:49:12] <kimundi> rusti: true | false
[11:49:13] -rusti- true
[11:49:20] <kimundi> rusti: true & false
[11:49:21] -rusti- false
[11:50:05] <bjz_> âˆ§âˆ¨Â¬
[11:50:20] <kimundi> rusti: Â¬true
[11:50:20] -rusti- <anon>:7:9: 7:9 error: unknown start of token: 172
[11:50:21] -rusti- <anon>:7          Â¬true
[11:50:21] -rusti-                   ^
[11:50:21] -rusti- application terminated with error code 101
[11:50:23] <bjz_> :P
[11:50:39] <cmr> leonvv: you're using rust for rubyists, right?
[11:50:45] <leonvv> Yes
[11:50:54] <cmr> I just finished converting chapter 7
[11:51:19] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[11:51:32] *** Quits: MaikKlein (maik@moz-52EA1D97.dip0.t-ipconnect.de) (Ping timeout)
[11:51:32] <leonvv> Great
[11:51:36] <kimundi> rusti: true v false
[11:51:37] -rusti- <anon>:7:14: 7:15 error: expected `;` or `}` after expression but found `v`
[11:51:37] -rusti- <anon>:7          true v false
[11:51:37] -rusti-                        ^
[11:51:37] -rusti- application terminated with error code 101
[11:51:43] <kimundi> :P
[11:51:46] <dbaupp> doener: does #7763 make --opt-level=0 faster?
[11:52:30] <dbaupp> rusti: true âˆ¨ false
[11:52:30] -rusti- <anon>:7:14: 7:14 error: unknown start of token: 8744
[11:52:30] -rusti- <anon>:7          true âˆ¨ false
[11:52:31] -rusti-                        ^
[11:52:31] -rusti- application terminated with error code 101
[11:53:27] <doener> dbaupp: just level 0 or a compiler build with level 0?
[11:53:35] <doener> I'm about to test the latter
[11:54:23] <dbaupp> doener: don't know... whatever measures the speed of some binary compiled at 0 with that pr?
[11:54:51] <leonvv> cmr: I can note down everything that dosen't work right away if you like? And then pass it to you when I'm at the end.
[11:55:10] <cmr> leonvv: I think I'll get most of them, but that'd be useful :)
[11:55:12] *** Quits: olleharstedt (Thunderbir@moz-80D8890F.ias.bredband.telia.com) (Ping timeout)
[11:55:23] <leonvv> Allright :)
[11:56:13] <cmr> Updating it to 0.7 is a lot less work than updating it to 0.6 was, so that's a good sign of language stabilisation
[11:57:00] *** Joins: pyrac (pyrac@moz-F2C67F88.w83-114.abo.wanadoo.fr)
[11:57:11] <doener> dbaupp: yes, see the new comment for details
[11:57:22] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[11:57:59] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[11:58:58] <dbaupp> doener: so, about 6% faster? nice
[11:59:10] *** Quits: victorporof_ (victorporo@moz-613026B7.info.uaic.ro) (Ping timeout)
[11:59:43] *** Quits: Earnestly (earnest@2AB30F53.FB5005.2BCC804A.IP) (Ping timeout)
[12:00:05] <doener> yeah, somewhere in that area
[12:00:23] *** Joins: thpickert (thpickert@moz-99F22CD3.dynamic.dsl.tng.de)
[12:00:41] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[12:00:58] *** Joins: LU324 (stuff@moz-A17E9A7B.dyn.embarqhsd.net)
[12:01:02] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[12:01:26] <doener> but to me it's almost more important that the IR _looks_ a lot nicer now
[12:01:48] <cmr> yes
[12:01:56] *** Quits: LU324 (stuff@moz-A17E9A7B.dyn.embarqhsd.net) (Connection reset by peer)
[12:02:05] <cmr> understandable IR is the first step on the path to fixing codegen
[12:02:09] <dbaupp> yeah, it's a huge reduction
[12:03:35] *** Quits: sankha93 (Instantbir@1D8D62BE.7FCF9508.EFB84E89.IP) (Ping timeout)
[12:03:41] *** Quits: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net) (Input/output error)
[12:03:41] <thpickert> Is it possible to cast/transform a vec value to a fixed size array value?
[12:03:57] <dbaupp> not really
[12:04:20] <doener> dbaupp: reveals awesome glue like https://gist.github.com/dotdash/f7882cbc4a303881816c
[12:04:32] <doener> that looks totally useful
[12:04:48] <dbaupp> thpickert: a fixed size array is effectively (T,T,T,T,T,...,T), but a vector is always a pointer
[12:04:56] <thpickert> Yeah.
[12:04:59] <cmr> ...lol
[12:05:24] <thpickert> That gist shows me how much I still don't know about the language.
[12:05:25] <dbaupp> doener: well, at least it's fast
[12:05:34] <dbaupp> thpickert: (that's LLVM code that rustc generates)
[12:05:36] <doener> it's not even called
[12:05:41] <thpickert> Oh!
[12:05:45] <dbaupp> thpickert: (not Rust code.)
[12:05:51] *** Joins: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net)
[12:05:56] *** Joins: Earnestly (earnest@2AB30F53.FB5005.2BCC804A.IP)
[12:06:07] <thpickert> dbaupp: Well, see how much I don't know? I can't even identify whether a snippet is in Rust or not. :p
[12:06:12] <cmr> heh
[12:06:23] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[12:06:24] <bjz_> thpickert: don't worry!
[12:06:26] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[12:06:27] <dbaupp> thpickert: I guess you could transmute a &[] to &([T, .. n]), whith some trickery, since the representations aren't the same
[12:06:42] <dbaupp> thpickert: but transmutation is a good way to hurt yourself :(
[12:06:43] <bjz_> thpickert: we all had to learn once! :)
[12:06:44] <doener> updated the gist to include the version that we currently get
[12:06:54] <cmr> (some of us twice...)
[12:06:56] *** Joins: victorporof (victorporo@moz-613026B7.info.uaic.ro)
[12:07:07] <thpickert> dbaupp: I'll give up the fixed size compiler check, and just pass vectors.
[12:07:19] <thpickert> It was awkward in other places, too, anyway.
[12:07:26] *** Joins: LU324 (stuff@moz-A17E9A7B.dyn.embarqhsd.net)
[12:07:35] <cmr> thpickert: usually you want to use a slice, &[]
[12:07:39] <dbaupp> yeah, it's annoying how fixed-sized vectors are almost useful... but not quite :(
[12:07:50] <thpickert> cmr: I'll do that.
[12:08:42] <thpickert> I've implemented aes-128/192/256 cipher/inverse cipher (because I couldn't figured FFI out :D).
[12:08:50] <cmr> heh
[12:09:06] *** Quits: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl) (Client exited)
[12:09:09] <bjz_> thpickert: I do: struct { T, T, ..., T } -> transmute -> (T, T, T, ..., T) -> transmute -> [T,..n] sometimes
[12:09:27] <thpickert> Hmmmm.
[12:09:33] <bjz_> thpickert: but I wouldn't do it from fixed vecs to n-ary vecs
[12:09:56] <thpickert> bjz_: Maybe that's what I actually wanted, but didn't know it.
[12:09:58] <dbaupp> bjz_: fixed -> &[] is always unnecessary
[12:10:13] <bjz_> thpickert: what did you want?
[12:10:17] <dbaupp> bjz_: they coerce automatically when a &[] is needed
[12:10:26] <bjz_> bjz_: yup
[12:10:32] <bjz_> * dbaupp
[12:10:51] <dbaupp> dbaupp: cool
[12:10:53] <dbaupp> ;P
[12:11:14] <thpickert> bjz_: I wanted to pass a "block" [u32, ..4] to a function.
[12:11:49] <thpickert> bjz_: That seemed nice, because I could check at compile time that I pass they right sizes.
[12:12:13] <thpickert> bjz_: But now when I want to use my implementation, it turns out I read blocks from files etc., which usually results in vectors.
[12:12:24] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Ping timeout)
[12:12:29] <thpickert> bjz_: So every time I do this awkward looping.
[12:12:47] <bjz_> rusti: as_fixed_vec<'a,T>(tuple: &'a (T, T, T)) &'a [T,..3] { unsafe { std::cast::transmute(tuple) } } as_fixed_vec(&(1, 2, 3))[2]
[12:12:48] -rusti- <anon>:7:24: 7:25 error: expected `:` but found `,`
[12:12:48] -rusti- <anon>:7          as_fixed_vec<'a,T>(tuple: &'a (T, T, T)) &'a [T,..3] { unsafe { std::cast::transmute(tuple) } } as_fixed_vec(&(1, 2, 3))[2]
[12:12:49] -rusti-                                  ^
[12:12:49] -rusti- application terminated with error code 101
[12:12:57] <bjz_> rusti: as_fixed_vec<'a,T>(tuple: &'a (T, T, T)) -> &'a [T,..3] { unsafe { std::cast::transmute(tuple) } } as_fixed_vec(&(1, 2, 3))[2]
[12:12:58] -rusti- <anon>:7:24: 7:25 error: expected `:` but found `,`
[12:12:58] -rusti- <anon>:7          as_fixed_vec<'a,T>(tuple: &'a (T, T, T)) -> &'a [T,..3] { unsafe { std::cast::transmute(tuple) } } as_fixed_vec(&(1, 2, 3))[2]
[12:12:58] -rusti-                                  ^
[12:12:58] -rusti- application terminated with error code 101
[12:13:10] <bjz_> rusti: fn as_fixed_vec<'a,T>(tuple: &'a (T, T, T)) -> &'a [T,..3] { unsafe { std::cast::transmute(tuple) } } as_fixed_vec(&(1, 2, 3))[2]
[12:13:11] -rusti- 3
[12:13:20] <bjz_> thpickert: ^
[12:13:42] <thpickert> bjz_:  <3
[12:13:47] <bjz_> rusti: fn as_fixed_vec<T>(tuple: (T, T, T)) -> [T,..3] { unsafe { std::cast::transmute(tuple) } } as_fixed_vec((1, 2, 3))[2]
[12:13:48] -rusti- 3
[12:13:56] <bjz_> thpickert: that one also works
[12:14:14] <bjz_> but the tuple is moved, so you can't use it again
[12:14:58] <thpickert> bjz_: Thanks a lot!
[12:14:59] <bjz_> rusti: fn as_fixed_vec<T>(tuple: (T, T, T)) -> [T,..3] { unsafe { std::cast::transmute(tuple) } } let foo = (1, 2, 3); let _ = as_fixed_vec(foo); foo
[12:15:00] -rusti- (1, 2, 3)
[12:15:07] <bjz_> wait
[12:15:11] * thpickert waits
[12:15:13] <bjz_> :?
[12:15:20] <dbaupp> bjz_: it's implicitly copiable
[12:15:21] <bjz_> that should have failed
[12:15:24] <bjz_> oh
[12:17:25] <dbaupp> rusti: fn as_fixed_vec<T>(tuple: (T, T, T)) -> [T,..3] { unsafe { std::cast::transmute(tuple) } } let foo = (~[1], ~[2], ~[3]); let _ = as_fixed_vec(foo); foo
[12:17:27] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/UiEg
[12:17:37] <dbaupp> bjz_: ^
[12:17:53] <bjz_> mmk
[12:19:07] <bjz_> struct Vec3<T> { x: T, y: T, z: T } fn as_fixed<T>(v: Vec3<T>) -> [T,..3] { unsafe { std::cast::transmute(v) } } let v = Vec3 { x: 1, y: 2, z: 3 }; let _ = as_fixed(v); v
[12:19:15] <bjz_> rusti: struct Vec3<T> { x: T, y: T, z: T } fn as_fixed<T>(v: Vec3<T>) -> [T,..3] { unsafe { std::cast::transmute(v) } } let v = Vec3 { x: 1, y: 2, z: 3 }; let _ = as_fixed(v); v
[12:19:15] -rusti- {x: 1, y: 2, z: 3}
[12:19:34] <bjz_> implictly copyable too, it seems
[12:20:02] *** Joins: smvv_ (sander@moz-BAEA8EB2.dynamic.upc.nl)
[12:20:24] <bjz_> thpickert: thanks, I learned something!
[12:20:47] <thpickert> bjz_: Haha, well I'm always happy to expose my ignorance in a helpful way. :D
[12:21:02] <bjz_> thpickert: questions are awesome
[12:21:10] <bjz_> thpickert: we all learn things
[12:21:17] <bjz_> so please don't stop!
[12:21:23] <dbaupp> bjz_: I think things are not implicitly copiable if they contain non-implicitly copiable types, have a destructor, or contain &mut.
[12:21:33] <dbaupp> bjz_: and otherwise they are.
[12:21:50] <thpickert> Oh, btw, I keep coming in here complaining about the docs, but I also want to say that since 0.7, it feels a lot better trying to work with the language.
[12:22:05] <dbaupp> (that's possibly not the complete list)
[12:22:07] <thpickert> It does not seem to fight me at all corners at all any more. Many things just work.
[12:22:29] <thpickert> So thanks for all the work on 0.7. ;)
[12:22:39] <dbaupp> thpickert: you were using 0.6 before? yeah, a *lot* of things got waaay better. :)
[12:23:01] <thpickert> dbaupp: Yes, I tried to, and it really was a struggle much of the time.
[12:23:16] <bjz_> dbaupp: maybe the implicit copies thing should be in the tutorial
[12:23:21] <dbaupp> haha, hopefully things continue getting slicker :)
[12:23:49] <bjz_> thpickert: oh really?
[12:23:55] <bjz_> thpickert: that's great
[12:24:05] <bjz_> thpickert: anything in particular?
[12:24:35] <dbaupp> bjz_: or at least in the manual
[12:24:39] <dbaupp> bjz_: (file a bug? :) )
[12:25:20] <bjz_> dbaupp: I'm feeling shamefully lazy this evening
[12:25:28] <thpickert> bjz_: I can't really pin it down, but I think you guys might have improved moving/ownership checks across closures *a lot*?
[12:25:31] * dbaupp files the bug
[12:25:47] <thpickert> bjz_: It's also possible that I'm a bit more familiar with the concepts by now, and just make fewer mistakes.
[12:26:14] <thpickert> But in either case, I do notice that I rarely get those hard to comprehend compiler complaints any more.
[12:26:54] <ronny> hi
[12:26:59] <bjz_> thpickert: yeah, nmatsakis and others have been doing awesome work improving the borrows/moves/lifetimes etc
[12:27:07] <bjz_> ronny: yoho
[12:27:14] <ronny> im wondering, are there any experiments on writing gui libs for rust
[12:27:22] <thpickert> Yes! borrows and lifetimes kept tripping me up, and I couldn't always tell if it was my fault.
[12:27:31] <cmr> ronny: not besides the gobject introspection lib
[12:27:45] <ronny> oh, i see
[12:27:52] <bjz_> thpickert: well, it's also important getting to grips with the concepts
[12:28:06] <bjz_> thpickert: rust can be frustrating at first
[12:28:13] <thpickert> bjz_: Sure thing. I think a bit of both might have happened.
[12:28:17] <cmr> fRUSTrating
[12:28:20] <thpickert> lol
[12:28:45] <ronny> what about libs for websockets, eventstreams and http serving?
[12:28:48] <thpickert> cmr: bjz_: I did invent a bunch of new ways to curse at my screen.
[12:28:49] <cmr> ronny: no
[12:29:02] <ronny> hmm, i see, so its going to have to be fresh made
[12:29:03] <cmr> ronny: we don't even have robust networking yet
[12:29:28] <cmr> ronny: if you're looking to be productive, rust is not the language for you (yet)
[12:29:28] <bjz_> thpickert: I do find that I am far more aware about copies now
[12:29:41] <bjz_> thpickert: and lifetimes
[12:29:59] <bjz_> thpickert: than in other languages
[12:30:05] <ronny> cmr: i'd like to do some experimenting, the target platform will be embedded
[12:30:06] <thpickert> bjz_: Oh yes, definitely.
[12:30:22] <bjz_> ronny: help to create those would be most appreaciated
[12:30:26] <dbaupp> bjz_: https://github.com/mozilla/rust/issues/7774, I'll get the credit when it gets fixed now :P
[12:30:56] <ronny> bjz_: is anyone working on protocol parsers?
[12:31:24] <bjz_> dbaupp: :P
[12:31:58] <dbaupp> bjz_: heh
[12:33:50] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[12:34:16] <ronny> bjz_: how and where would be a good place to start this?
[12:35:10] <dbaupp> ronny: which thing are you refering to with "this"?
[12:36:35] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[12:36:43] <bjz_> dbaupp: I believe ronny is referring to a thing he would like to start.
[12:37:09] * dbaupp definitely appreciates bjz_'s input
[12:37:10] <ronny> dbaupp: network protocol parsers and libs to use them
[12:37:30] <cmr> which protocols?
[12:37:44] <dbaupp> ronny: ah, well, most rust development happens on github
[12:37:57] <ronny> cmr: http + eventstreams/websockets, imap
[12:39:12] <bjz_> dbaupp: oh noes - rust went down one place in the github language rankings!
[12:39:12] <bjz_> dbaupp: https://github.com/languages/Rust
[12:39:21] <bjz_> dbaupp: I'm pretty sure we were on #44
[12:39:58] <dbaupp> bjz_: we should find that language that took Rust's spot and glare at it!
[12:40:09] <ronny> hmm, thing is what i intent to do probably needs a own repo, but then it mgiht happen that rust gets something different in the stdlib
[12:40:19] <bjz_> dbaupp: *really hard*
[12:40:56] <cmr> ronny: get in touch with brson, he coordinates all the runtime/io code afaict
[12:40:57] <dbaupp> ronny: yeah, there is more than one instance of things being developed in external repos with the intent to merge them back in (so there is precedent for that)
[12:41:05] <cmr> ecr has been working on networking
[12:41:26] <dbaupp> cmr: actual networking? or the protocol parsing stuff?
[12:41:33] <cmr> Actual networking
[12:41:39] <cmr> udp, most recently
[12:41:45] <cmr> using libuv of course
[12:41:51] <ronny> im more interested in protocol parts
[12:41:55] <dbaupp> oh, awesome
[12:42:06] <ronny> and connectionpools/stuff like that
[12:42:08] <cmr> ronny: right, but making sure it works well with the new io code is important
[12:42:09] <dbaupp> cmr: (does newrt use libuv still?)
[12:42:13] <cmr> dbaupp: (yes)
[12:42:39] <ronny> is the new io code just using reader/writer interfaces?
[12:42:56] <cmr> ronny: yes, but it's a different interface than the current one
[12:43:03] <cmr> I don't know what it is or where that code lives though..
[12:43:20] <dbaupp> ronny: well, I'm not sure anyone is particularly working on that stuff yet (I'm probably wrong though); and anyway, cross-pollination of ideas is always good
[12:43:20] <ronny> cmr: for building the protocols i need only the writer interface
[12:43:31] <dbaupp> ronny, cmr: std::rt::io
[12:43:49] <ronny> main question is how to start communication and make information easy to find for people interested in it
[12:44:03] <ronny> (i have a kinda pipedream of writing something like couchdb in rust)
[12:44:06] <dbaupp> ronny: mailing list
[12:44:08] <cmr> ronny: mailing list, http://reddit.com/r/rust
[12:44:27] <ronny> is there any wiki about different ongoing effords?
[12:44:42] <cmr> not afaik but there's a big metabug and a long ML post
[12:44:49] <ronny> (mailing-lists and reddit are not very effectve when diging newly into something and trying to figure that)
[12:44:57] <dbaupp> ronny: https://github.com/mozilla/rust/wiki/Libs
[12:45:23] <dbaupp> ronny: (none cover the lower level protocol stuff though.)
[12:46:03] <cmr> http://article.gmane.org/gmane.comp.lang.rust.devel/4234
[12:46:24] <ronny> hmm, there are some http servers tho
[12:47:00] <dbaupp> they are unlikely to work very well
[12:47:11] <dbaupp> (but I don't know)
[12:48:24] <dbaupp> ronny: and rust is so new, that there is always benefit in a new library/application, even if it seems like it's repeating a different one
[12:49:16] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[12:49:45] <ronny> k
[12:50:00] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Ping timeout)
[12:50:11] * ronny wonders if macros can be used as parser generator
[12:50:23] <cmr> ronny: or syntax extensions, definitely
[12:50:42] <cmr> there's a whole compiler syntax extentensoin for pipes
[12:50:49] <cmr> http://static.rust-lang.org/doc/std/pipes.html
[12:50:55] <dbaupp> (syntax extension = macro written in Rust, for reference)
[12:51:13] <dbaupp> cmr: and it's horribly old code :S
[12:51:18] <cmr> But it works! :P
[12:51:35] <dbaupp> does it?
[12:51:46] * dbaupp has never used it
[12:51:48] <cmr> the pingpong test still runs, at the very least
[12:52:06] <ronny> so this could be used for protocol statemachines?
[12:52:08] <dbaupp> aha, right, that's a reasonable indication that it does
[12:52:19] <cmr> ronny: exactly
[12:52:29] <cmr> (but it's for tasks sending messages, not networking)
[12:53:14] <ronny> cmr: i dont see a semantical difference between chanels and networkg streams bount to a message parser/serializer
[12:53:58] <cmr> ronny: there isn't, but there's a certain amount of efficiency you lose with the indirection, I imagine
[12:55:00] <ronny> cmr: if you go over the network, you cant help it anyway
[12:55:10] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[12:55:40] <cmr> that's a latency vs throughput thing
[12:56:52] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[12:57:29] <engla> cmr: what do we do to avoid decision block on Ord::lt? wait for authorities to chime in or just go for the libextra evidence for `lt`?
[12:58:02] <dbaupp> engla: I'd vote for just going with lt
[12:58:13] <cmr> Ditto
[12:58:15] <dbaupp> (despite me being incorrect about haskell)
[12:58:36] <engla> me too, the two data samples in libextra use lt
[12:58:46] * dbaupp has r+'d it
[12:58:48] <cmr> engla: dbaupp convinced me that Ord is a sane trait for partial ordering, as well, so I retract that comment
[12:59:13] <dbaupp> and now bors gets to do something after slacking off for hours!
[12:59:21] *** Joins: olleharstedt (Thunderbir@moz-80D8890F.ias.bredband.telia.com)
[12:59:25] <engla> ok great.. it's outside of the scope of that particular PR though
[12:59:28] <cmr> I hear servo has been keeping him busy
[12:59:49] <engla> ah queue is empty, cool
[12:59:50] <ronny> bbl
[13:00:04] <cmr> x64's large address space: http://www.reddit.com/r/rust/comments/1i3c15/experimental_actor_library_in_rust/cb1spfc
[13:00:19] <dbaupp> cmr: what do you mean? servo-bors is *clearly* no relation to bors :P
[13:00:51] <dbaupp> cmr: that relies on overcommit though
[13:01:01] <dbaupp> (well, s/though/also/)
[13:01:11] <dbaupp> not just x64's address space.
[13:01:35] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[13:01:35] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1400875a1 to 14a9eb868: 02http://git.io/N3iJvQ
[13:01:35] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[13:02:24] <engla> thanks for the review
[13:03:40] *** Joins: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net)
[13:05:15] <cmr> well yes
[13:05:26] <cmr> but there's no fundamental issue with large stacks on x64
[13:05:44] <cmr> if you're using millions of tasks of *any* size you're going to have to know what you're doing
[13:06:05] <dbaupp> yeah, I believe strcat was pushing for them by default on x64 for precisely that reason
[13:06:11] <xenocons> will Numerics trait extend so that bigint has operators instead of methods or is this considered unconventional?
[13:06:22] <dbaupp> cmr: or you have a bug.
[13:06:31] <dbaupp> xenocons: in theory, bigint has operators
[13:07:01] <dbaupp> xenocons: the infrastructure is already there https://github.com/mozilla/rust/wiki/Note-operator-overloading
[13:07:08] <xenocons> ah
[13:07:58] <dbaupp> rusti: use extra::bigint::BigInt; std::num::One::<BigInt>() + std::num::One::<BigInt>()
[13:07:59] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/ahYa
[13:08:29] <dbaupp> rusti: use extra::bigint::BigInt; use std::num::One; One::one::<BigInt>() + One::one::<BigInt>()
[13:08:30] -rusti- {sign: Plus, data: {data: ~[2]}}
[13:08:42] <xenocons> nice 
[13:09:14] <xenocons> tempted to swap this project over to rust however... hmm maybe ill wait a bit longer
[13:09:39] <xenocons> kinda want the api locked down (no future changes to it) might write the agent stuff in rust though
[13:09:51] <dbaupp> currently in ...? C++?
[13:10:28] <xenocons> a mix, C + ASM and F#
[13:10:36] <cmr> ah f#!
[13:10:46] <cmr> How do you feel rust compares?
[13:10:47] <xenocons> (im just consuming someones C+ASM, im not writing it fortunately)
[13:11:20] <xenocons> only using F# as ive got heaps of code i can copy paste
[13:11:45] <xenocons> large(ish) 'probably prime' stuff
[13:12:11] <xenocons> dbaupp: i kinda wish i knew C++, but its just too big and scarey
[13:12:20] *** Quits: StarLight (StarLight@moz-5E9078D.dynamic.avangarddsl.ru) (Ping timeout)
[13:13:00] <dbaupp> xenocons: haha, just wondering because a lot of Rust people seem to be C++ refugees :)
[13:13:08] <xenocons> yeah ive noticed
[13:13:31] <xenocons> i want rust as my metal lang
[13:14:34] <xenocons> cmr: sorry didn't see your question, umm hmm
[13:14:45] <xenocons> id say completely different language + targets
[13:15:00] <cmr> Well yes, but does Rust provide a comparable amount of abstraction?
[13:15:09] <cmr> I'm only slightly familiar with F#
[13:15:27] <xenocons> hmm, in a different sense i think, for F# you have your imperative and oop constructs (in .NET) but you also have ML abstractions
[13:15:40] <xenocons> so i feel F# is a lot more abstracted in a 'functional' sense than rust
[13:15:44] <dwrensha> Does anyone know what is the status of static linking in Rust?
[13:15:54] <cmr> dwrensha: broken and noone is working on it
[13:15:57] <dbaupp> dwrensha: doesnt work
[13:16:00] <dwrensha> In particular, I'm interested in inlining functions across crates
[13:16:07] <cmr> dwrensha: we already have cross-crate inlining
[13:16:09] <dbaupp> dwrensha: does work
[13:16:11] <dwrensha> how?
[13:16:18] <cmr> dwrensha: just attach an #[inline] attribute to the thing you want inlined
[13:16:25] <dbaupp> the #[inline] directive
[13:16:27] <xenocons> (for me that mostly means clean and concise lambda, currying and ADT's)
[13:16:31] <dwrensha> oh, so I don't need to think about it
[13:16:38] *** Joins: StarLight (StarLight@moz-C25D61F3.pppoe.avangarddsl.ru)
[13:16:58] <dwrensha> no special compiler flags or anything
[13:17:07] <dbaupp> it puts information about the function into the compiled crate, which rustc reads whenever that crate is used
[13:17:42] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[13:17:53] <dwrensha> ok, cool. I'm already using the #[inline(always)] directive
[13:18:03] <dwrensha> I just wanted to make sure that it would work across crates
[13:18:32] <dbaupp> dwrensha: be very careful with #[inline(always)], you almost always want just #[inline]
[13:18:50] <dwrensha> what are the dangers?
[13:18:51] <cmr> (LLVM is very good at its job)
[13:18:54] <dbaupp> the standard libraries have had problems with bloat and slowness caused by inline(always)
[13:19:26] <dbaupp> dwrensha: code size, mainly
[13:19:47] <dbaupp> (which has a large impact on code speed too)
[13:22:54] *** Quits: Ms2ger (Ms2ger@3F038EB7.1AB48F49.F15B0BB3.IP) (Quit: bbl)
[13:23:50] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[13:24:52] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[13:27:18] <cmr> heheh
[13:27:28] <cmr> s/static method/associated function/ in rust for rubyists
[13:28:41] *** Quits: olleharstedt (Thunderbir@moz-80D8890F.ias.bredband.telia.com) (Ping timeout)
[13:29:04] <dbaupp> is that the conventional name?
[13:29:14] <cmr> It's the only one that makes sense imo
[13:29:22] <cmr> and it jives with associated items down the road
[13:30:33] <cmr> it's not a method because it 1. can't be called on any object, 2. doesn't actually take an object
[13:30:48] <dbaupp> yes, but does anyone call them "associated function" now?
[13:30:56] <cmr> I do!
[13:31:01] <dbaupp> heh
[13:31:04] <cmr> And I got the name from someone else
[13:31:08] <cmr> I didn't come up with it myself
[13:31:12] <cmr> so at least 1 other person does :p
[13:31:46] <dbaupp> we'll be able tell who come from rust for rubyists (I guess if it's just for analytics, then it's fine :P )
[13:35:18] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[13:36:10] <kimundi> Assoziated Items: assoziated constants, assoziated functions, assoziated types. Sounds like a nice consistent terminology that we should use.
[13:37:02] *** Quits: victorporof (victorporo@moz-613026B7.info.uaic.ro) (Quit: victorporof)
[13:37:17] <kimundi> hm, I wonder if assoziated items make sense for type impls...
[13:38:02] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[13:38:51] <kimundi> struct Foo(uint); impl Foo { static ONE = Foo(1); static ZERO = Foo(0);  } ...
[13:39:04] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[13:41:29] <cmr> Aren't associated items a trait thing?
[13:42:06] <bjz_> they should be called associated functions
[13:42:16] *** Joins: etw (john@moz-B2936CAB.nyc.res.rr.com)
[13:42:20] <kimundi> yes, but structurally they also kinde fit in the type impl system imo
[13:42:30] <cmr> Probably
[13:42:33] *** Joins: victorporof (victorporo@moz-613026B7.info.uaic.ro)
[13:42:35] * cmr no idea about such thing
[13:42:44] <bjz_> well, then they are associated with a type impl
[13:43:01] <bjz_> s/type impl/type/
[13:43:58] *** Quits: victorporof (victorporo@moz-613026B7.info.uaic.ro) (Quit: victorporof)
[13:44:12] *** Joins: poiru (poiru@moz-FA10A1CD.fi)
[13:44:32] <bjz_> we'd better get people used to the name now, or it'll be confusing down the road. you know how rust is with it's inconsistent tutorials scattered all over the interwebs
[13:45:20] <kimundi> bjz: Then you should go over the tutorial and manual _right now_ ;)
[13:45:23] <bjz_> cmr: I got the name from some of the mozilla devs
[13:45:34] <bjz_> kimundi: good ideas
[13:45:38] <bjz_> *idea
[13:47:25] <cmr> rusti: let x = ~"foo"; x.to_str()
[13:47:27] -rusti- ~"foo"
[13:48:02] <dbaupp> bjz_: does this make me a bad person? http://ix.io/6D7/diff
[13:48:22] <cmr> ...hahah
[13:48:31] <bjz_> HAHAHA
[13:48:52] *** Joins: victorporof (victorporo@moz-613026B7.info.uaic.ro)
[13:49:13] <bjz_> we really need a from_int thingy
[13:49:22] <kimundi> errr xD
[13:49:26] <cmr> what we really need is https://github.com/mozilla/rust/issues/7080
[13:49:30] <cmr> and then it's `2 as Self`
[13:49:44] <dbaupp> bjz_: we have IntConvertable
[13:49:47] <bjz_> dbaupp: https://github.com/bjz/lmath-rs/blob/master/src/macros.rs#L18
[13:49:54] <bjz_> dbaupp: ick
[13:49:58] <dbaupp> but it's sorta bad
[13:50:06] <dbaupp> bjz_: heh
[13:50:21] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[13:50:35] <dbaupp> and these things don't rely on IntConvertable yet.
[13:51:00] <bjz_> https://github.com/mozilla/rust/issues/6016
[13:51:02] <bjz_> :P
[13:51:02] <dbaupp> s/rely on/inherit from/
[13:51:25] <bjz_> oh wait
[13:51:29] <bjz_> cmr commented on it
[13:51:31] <bjz_> :P
[13:51:45] <dbaupp> anyway, just thinking about it... associated constants for zero, one etc won't work, because e.g. bigint has an allocation in it.
[13:51:49] <cmr> and forgot to close it, apparently
[13:52:15] * bjz_ hates the fact we don't have ctfe :(
[13:52:32] * bjz_ waves fist
[13:52:47] <dbaupp> bjz_: with dynamic syntax extensions we can probably get arbitrarily close
[13:52:59] <dbaupp> (well, go even further.)
[13:53:44] <bjz_> it's a shame we got rid of 'pure' - would have made ctfe much easier (I think)
[13:54:16] <cmr> ctfe will come naturally with the effect system
[13:54:49] <cmr> until then we could fake it by recursively checking ctfe-ability and marking them explicitly as ctfe and writing a rust-subset evaluator
[13:55:02] <dbaupp> bjz_: I think part of the reason pure got removed was because it didn't actually help much with ctfe, but I don't know
[13:55:06] <dbaupp> rusti!
[13:55:07] <cmr> which is basically what we do for `static` and constant evaluation...
[13:55:15] <cmr> but it's *nasty*, *nasty* code atm
[13:55:20] <bjz_> well, we never had ctfe
[13:55:29] <kimundi> Something for the docs: "function declarations in a trait or impl block are called assoziated functions because they are assoziated with a type by virtue of belonging to its impl block. assoziated functions that take an self parameter are also called methods, and can be called with the method call syntax (but they don't have to)"
[13:55:32] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[13:55:49] <dbaupp> bjz_: yeah, I mean, it was a property of a function that was mostly orthogonal to suitability for ctfe
[13:55:57] <cmr> Once we have.. universal function call syntax?
[13:56:00] <cmr> is that what it's called?
[13:56:02] <dbaupp> (if it existed)
[13:56:08] <kimundi> cmr: yeah
[13:56:12] <dbaupp> cmr: "uniform", I believe
[13:56:38] <bjz_> dbaupp: that's why D has 'pure' I think, to allow for ctfe
[13:56:39] <cmr> uniform sounds right
[13:56:40] *** Quits: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP) (Connection reset by peer)
[13:57:17] <bjz_> dbaupp: maybe rust's 'pure' had different semantics
[13:57:21] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[13:57:39] <dbaupp> bjz_: yeah, right, I'm not disagreeing with you, just saying that Rust's old pure did have different/surprising/useless semantics
[13:57:45] *** Joins: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP)
[13:57:52] <dbaupp> (I'm not sure of the details, but iirc that was why it was removed.)
[13:58:02] <cmr> We don't need pure once we have an effect system though
[13:58:07] <cmr> #[effect(pure)]
[13:58:12] <cmr> (or it would be inferred)
[13:58:18] *** Quits: yong (chatzilla@74DA0C97.4E87ADC2.263D9828.IP) (Ping timeout)
[13:58:20] <bjz_> ahh nice
[13:58:29] <cmr> https://github.com/mozilla/rust/wiki/Proposal-for-effects
[13:58:30] <bjz_> would that then allow for ctfe?
[13:58:58] <cmr> I think so yeah
[13:59:03] <cmr> seems he's updated the syntax
[13:59:19] <dbaupp> bjz_: was there a particular reason that Orderable.max -> Self rather than &'a Self?
[13:59:22] <bjz_> should talk to bblum about it then
[13:59:44] * dbaupp prefers the attribute syntax
[13:59:45] <bjz_> dbaupp: that might be a better way
[14:00:06] <dbaupp> bjz_: ok, I'll move it to Ord as a default method and change it to be that.
[14:00:14] *** Joins: yong (chatzilla@89F941DF.4E87ADC2.263D9828.IP)
[14:00:22] <SiegeLord> You can have CTFE without pure...
[14:00:44] <bjz_> dbaupp: how are you doing the default methods?
[14:01:12] <bjz_> dbaupp: what is possible atm?
[14:01:21] <dbaupp> bjz_: if *self >= *other { self } else { other }, for max
[14:01:25] <dbaupp> bjz_: or something like that
[14:01:59] <SiegeLord> It could be very useful to do some file IO at compile time, for example
[14:02:24] <bjz_> dbaupp: ie. what is their status
[14:02:33] <bjz_> dbaupp: could I use them in lmath?
[14:02:38] <dbaupp> bjz_: mostly working, probably
[14:02:45] <dbaupp> bjz_: sully is a god
[14:02:47] <cmr> SiegeLord: that'd be the realm of macros/syntax extensions more than functions I'd think
[14:03:10] <SiegeLord> syntax extensions and CTFE are one and the same, in my mind
[14:03:12] *** Quits: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP) (Quit: bb2m)
[14:03:33] <SiegeLord> More specifically, the former are a superset of the latter
[14:03:38] <cmr> syntax extensions output an AST, CTFE outputs a value
[14:03:47] <SiegeLord> The AST can be a value
[14:04:14] <cmr> erm, only if you're using libsyntax
[14:04:39] <cmr> it literally rewrites the AST, replacing macro invocation with the AST... so I suppose, kinda
[14:04:43] <bjz_> dbaupp: can I constrain a <T> in a trait so I can use a trait's methods?
[14:04:56] <dbaupp> bjz_: maybe... not sure if that has been fixed yet
[14:05:01] <cmr> but ctfe is supposed to be seamless, purely an optimization, aiui
[14:05:22] <SiegeLord> I don't see the need for it to be seamless
[14:05:43] <SiegeLord> I'd be fine if it worked the same way as syntax extensions do
[14:05:49] <dbaupp> rusti: trait Foo<T: Eq> { fn foo(&self, a: T, b: T) -> bool { a == b } } impl<T: Eq> Foo<T> for uint {} 1u.foo(3i, 3i)
[14:05:50] -rusti- true
[14:05:53] <SiegeLord> It's not seamless anyway if you have to make things pure
[14:05:57] <dbaupp> bjz_: yes ^
[14:07:16] <dbaupp> cmr: it's probably possible to have a *really* heavy weight syntax extension that literally traverses the whole crate and ctfe's things that it can
[14:07:33] <SiegeLord> Also... I'm not sure why Rust needs uniform function call syntax either, given its ability to do extension methods
[14:07:42] <dbaupp> cmr: i.e. a syntax extension that loads the rustc crate for itself.
[14:07:49] <SiegeLord> Maybe I'm missing something though
[14:08:04] <dbaupp> SiegeLord: extension methods don't really work is one problem (#5898)
[14:08:34] <bjz_> dbaupp: error: internal compiler error: get_impl_id: no impl of trait for this type
[14:08:36] <bjz_> x)
[14:08:43] <dbaupp> bjz_: oh :(
[14:08:54] <dbaupp> bjz_: how old is your rustc?
[14:09:00] <SiegeLord> dbaupp: Is that issue a design flaw?
[14:09:45] <bjz_> hmm, will look
[14:10:21] <dbaupp> SiegeLord: not entirely, mostly a bug
[14:10:34] <SiegeLord> Then that's hardly a justification to add a non-orthogonal feature :P
[14:10:48] <bjz_> dbaupp: from yesterday it is
[14:10:58] <cmr> SiegeLord: Well we already have syntax extensions, CTFE would just be an optimization, and an orthogonal feature
[14:11:00] <dbaupp> SiegeLord: although there are conceiveably instances where a type impls to traits which both have an extension impl with a method of the same name
[14:11:03] <cmr> heh, we both used that phrase
[14:11:06] <cmr> anyway, bbl
[14:11:26] <bjz_> SiegeLord: CTFE allows you to call functions in static locations
[14:11:30] <bjz_> * cmr
[14:11:39] <dbaupp> SiegeLord: and, having to write `|x| x.clone()` is annoying
[14:12:09] <dbaupp> bjz_: syntax extensions would allow that too, since they get evaled before static expressions are checked.
[14:12:31] *** Quits: AndroUser2 (androirc@moz-D298E390.dab.02.net) (Ping timeout)
[14:12:52] <bjz_> dbaupp: how easy are they for folks to implement though?
[14:12:53] <dbaupp> bjz_: there were some more default methods fixes; I think they landed over night
[14:13:14] <dbaupp> bjz_: atm, impossible outside of libsyntax
[14:13:17] <bjz_> dbaupp: and would I have to duplicate code for what I've already done?
[14:13:45] <SiegeLord> dbaupp: Re multiple methods with the same name... how would UFCS solve that?
[14:14:17] <dbaupp> SiegeLord: Trait1Util::foo, Trait2Util::foo
[14:14:47] <dbaupp> bjz_: hm, probably, if the syntax extension was your function, rather than the syntax extension doing the ctfe
[14:14:49] *** Joins: yong_ (chatzilla@89F941DF.4E87ADC2.263D9828.IP)
[14:15:12] <SiegeLord> dbaupp: What are those... associated static functions?
[14:15:16] <SiegeLord> *-static
[14:15:26] <bjz_> no, methods
[14:15:49] <bjz_> so the self type would be the first arg
[14:15:52] <dbaupp> bjz_: (once external syntax extensiosn are loadable, I'd hope that someone writes a library that makes them very easy to write, for the easy case, e.g. converting the args to a "conventional" format, etc etc.)
[14:16:03] *** Quits: yong (chatzilla@89F941DF.4E87ADC2.263D9828.IP) (Ping timeout)
[14:16:08] <SiegeLord> Ok... which UFCS are we talking about
[14:16:15] *** yong_ is now known as yong
[14:16:18] <SiegeLord> Free function to method call or method call to free function?
[14:16:20] <dbaupp> SiegeLord: x.foo(a,b,c) == Trait::foo(x, a, b, c)
[14:16:25] <dbaupp> both
[14:16:30] <bjz_> SiegeLord: it's like D's UFC, but reversed
[14:16:39] <SiegeLord> You two just contradicted yourselves :P
[14:16:42] <kimundi> dbaupp: Both?
[14:16:43] <dbaupp> (well, possibly both)
[14:16:53] <bjz_> SiegeLord: no, we didn't
[14:16:55] <SiegeLord> I'm arguing against free function to method call
[14:17:05] <SiegeLord> The method call to free function is probably ok
[14:17:11] <kimundi> afaik only method -> assoziated fn, not other way round
[14:17:15] * dbaupp has no opinion on free->method
[14:17:32] <bjz_> I would argue against the other way
[14:17:42] <dbaupp> bjz_: against method -> free?
[14:17:45] <SiegeLord> D only does the free function to method, I'm pretty sure
[14:17:51] <bjz_> free -> method
[14:17:55] <bjz_> yes
[14:17:59] <kimundi> If we would asol get assoziated fn as method call, then there would be no point to explicit self anymore
[14:18:03] <dbaupp> why?
[14:18:18] <bjz_> so D: free -> method, Rust: method -> free
[14:18:29] <dbaupp> kimundi: yeah, less typing with explicit self
[14:18:46] <bjz_> D doesn't have type classes, so it can't do it the other way
[14:18:54] <bjz_> SiegeLord: make sense?
[14:18:57] <dbaupp> kimundi: no need to go `fn foo(self: MyComplicatedStruct<With,Type,Parameters>)`
[14:19:11] <SiegeLord> bjz_, D could probably do it the other way... it just doesn't
[14:19:27] <SiegeLord> Probably no point for it
[14:19:31] <kimundi> dbaupp: Well, that's not really the point
[14:19:51] <dbaupp> kimundi: sure it is, syntactic sugar is useful
[14:20:12] <bjz_> SiegeLord: the point with D's is that it can kinda emulate type classes, there would be no point to the other way
[14:20:21] <bjz_> SiegeLord: likewise with us
[14:20:29] <SiegeLord> Yeah, I guess
[14:20:34] <kimundi> It's not just syntactic sugar, it has semantic implications. explicit self: function is meant as a method.
[14:20:47] <bjz_> SiegeLord: it's a reversed situation
[14:21:30] <kimundi> If we wanted sugar, then all parameters should be able to be written as explicit self
[14:21:31] <dbaupp> kimundi: you could regard it as "function takes an argument of type Self"
[14:21:40] <bjz_> SiegeLord: and yes, I said 'can't' but yeah, I guess you're right - there's no real point
[14:21:41] <dbaupp> right, that'd be neat
[14:21:53] <SiegeLord> That said, I thought there were proposals to do <x of Foo>.blah or something
[14:22:04] <SiegeLord> I forget the syntax
[14:22:07] <dbaupp> kimundi: but the most common case is probably one Self arg, and zero-or-more other (non-Self) args
[14:22:08] *** Quits: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net) (Ping timeout)
[14:22:14] <SiegeLord> But to somehow disambiguate that case without UFCS
[14:22:19] <dbaupp> SiegeLord: syntax wasn't settled on, I don't think.
[14:22:30] *** Joins: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net)
[14:22:32] <SiegeLord> I guess UFCS is pretty clean compared to all those attempts, I think
[14:23:45] <dbaupp> kimundi: I'm actually not fussed about this at all; I just really don't want to have to write out the Self type in place of &self. (So anything that keeps that property is fine by me.)
[14:24:00] <kimundi> with UFCS all functions in traits, type impls, modules can be treated the same way, and explicit self would effectivly be reduced to a marker that enables method call syntax for that function.
[14:24:28] <kimundi> dbaupp: Oh, I never said we should remove that :P
[14:24:38] <dbaupp> kimundi: cool :)
[14:24:51] <bjz_> dbaupp: you can't pattern match on &self :(
[14:25:01] <dbaupp> bjz_: right
[14:25:35] <kimundi> dbaupp: Just that treading &self just as sugar so you don't have to write so much is the wrong way to do it.
[14:25:55] <dbaupp> bjz_: (but is a single extra line of `let (a,b,c) = self;` that bad? ... especially when you don't have to come up with a name for the temporary :P )
[14:26:07] <kimundi> &self should only be used if you decide "this should be callable as a method"
[14:27:09] <dbaupp> kimundi: well, I can't think of any reason that a function that *can* have a self parameter (i.e. takes an arg of type Self), shouldn't be callable as a method
[14:27:34] <bjz_> dbaupp: add(&self: Self, &other: T) -> T { self * other }
[14:27:48] <bjz_> woops, I meant mul
[14:28:11] <bjz_> dbaupp: mul(&self: &Self, &other: &T) -> T { self * other }
[14:28:20] <bjz_> really messed that up
[14:29:22] <dbaupp> bjz_: meh, I don't actually care about mul(a,b) vs a.mul(b)
[14:29:38] <bjz_> dbaupp: that would be a method
[14:29:38] <dbaupp> (others might... but then they should be the ones taking up the fight ;P )
[14:29:53] <bjz_> was just demonstrating a pattern matching case
[14:30:02] <dbaupp> oh, I see
[14:30:20] <bjz_> it gets more annoying when you do &self on a struct, and have to do (*self).x
[14:30:25] <dbaupp> right, yes.
[14:30:30] <kimundi> I'm trying to think of an example too... But I'm certain there are cases where a operation makes no semantic sense as "operation applied on an object"
[14:30:41] <dbaupp> bjz_: (doesn't auto-deref do it?)
[14:31:02] <bjz_> really? I thought I was getting errors
[14:31:07] <dbaupp> kimundi: methods aren't "operation applied on object", they are "operation that has some context related to object"
[14:31:15] <dbaupp> (at least, that's how I see them.)
[14:31:18] <kimundi> or that, yeah
[14:31:31] *** Joins: MaikKlein (maik@moz-52EA1D97.dip0.t-ipconnect.de)
[14:31:45] <dbaupp> bjz_: quite possibly, auto-deref seems to be strangly unreliable :/
[14:32:05] <bjz_> which might be a reason for not having it
[14:33:14] <dbaupp> yeah, or having it controllable
[14:33:19] <bjz_> https://github.com/bjz/lmath-rs/blob/master/src/geom/point.rs#L290
[14:33:30] <kimundi> 'fn report_love_triangle(a: Person, b: Person, c: Person);' Compare: 'report_love_triangle(a,b,c)' and 'a.report_love_triangle(b, c)'
[14:33:48] <dbaupp> so x.foo() doesn't deref, but x..foo() does one layer, x...foo() does two
[14:33:50] <dbaupp> etc
[14:34:02] <SiegeLord> I still don't see what free-function to method gives you :P
[14:34:09] <SiegeLord> At least the other way fixed an ambiguity
[14:34:10] *** Quits: victorporof (victorporo@moz-613026B7.info.uaic.ro) (Quit: victorporof)
[14:34:12] <dbaupp> bjz_: although that's pretty ugly
[14:34:27] <dbaupp> bjz_: yeah, that code is ugly too :(
[14:34:55] <dbaupp> kimundi: ah, the case when there's no "prefered" object...
[14:35:47] <bjz_> wait, it seems like I can get rid of the derefs
[14:36:28] <dbaupp> bjz_: yay!
[14:36:46] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[14:36:47] <bjz_> dbaupp: another issue I have is that mul(&self, &other: T) doesn't actually work - you get a move out of pattern error
[14:37:05] <bjz_> I mean mul(&self, &other: &T)
[14:37:07] <dbaupp> bjz_: yes
[14:37:08] <kimundi> I read the two call snippets differently: a.report_love_triangle(b, c) : "a reports it's relation with b and c", report_love_triangle(a, b, c) : "reports the relation between a, b and c"
[14:37:28] <dbaupp> kimundi: yeah, I agree with you on that one.
[14:37:42] <bjz_> dbaupp: it's weird it works for closures though
[14:37:52] <dbaupp> bjz_: not always
[14:37:56] <bjz_> dbaupp: like .map(|&x| x)
[14:38:03] <dbaupp> bjz_: and the rules recently changed
[14:38:08] <kimundi> of course, that argument also kinda applies the other way round with ufcs...
[14:38:15] <SiegeLord> kimundi: Nothing prevents you from making a method like that today :P
[14:38:17] <dbaupp> bjz_: matches in let and fn args used to be incorrect
[14:38:35] <dbaupp> bjz_: for that example, x is probably implicitly copyable
[14:38:38] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[14:39:03] <dbaupp> rusti: (|&x: &~[int]| x)(&~[])
[14:39:04] -rusti- <anon>:7:11: 7:13 error: cannot move out of dereference of & pointer
[14:39:04] -rusti- <anon>:7          (|&x: &~[int]| x)(&~[])
[14:39:04] -rusti-                     ^~
[14:39:04] -rusti- error: aborting due to previous error
[14:39:04] -rusti- application terminated with error code 101
[14:39:18] <dbaupp> rusti: (|&x: &int| x)(&1)
[14:39:19] -rusti- 1
[14:39:24] <kimundi> SiegeLord: Right, my point was that allowing to call assoziated functions as methods doesn't allways make sense
[14:39:57] <bjz_> rusti: fn mul<T:Num>(&x: &T, &y: &T) -> T { x * y } mul(&2, &3)
[14:39:58] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/jKIg
[14:40:00] <SiegeLord> Methods today are associated functions (with sugar) today though
[14:40:02] <kimundi> hm... vec.push(foo) vs Vector::push(vec, foo)
[14:40:05] <SiegeLord> *- today
[14:40:16] <bjz_> rusti: fn mul<T:Clone + Num>(&x: &T, &y: &T) -> T { x * y } mul(&2, &3)
[14:40:16] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/PLDS
[14:40:20] <dbaupp> bjz_: yeah, generics aren't implcitly copiable
[14:40:25] <kimundi> SiegeLord: Right, as soon as ufcs actually works
[14:40:26] <bjz_> rusti: fn mul<T:Copy + Num>(&x: &T, &y: &T) -> T { x * y } mul(&2, &3)
[14:40:27] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/cRBE
[14:40:37] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[14:40:37] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/7Y9NCw
[14:40:37] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[14:40:55] <bjz_> dbaupp: but that shouldn't be a copy though?
[14:41:00] <dbaupp> bjz_: :Copy generics used to be implicitly copyable, but this was deemed bad so pcwalton changed it
[14:41:03] *** Quits: tav (tav@moz-5ED3AF3C.range86-152.btcentralplus.com) (Quit: tav)
[14:41:04] <SiegeLord> kimundi: I'm saying it already works for associated functions :P
[14:41:08] <bjz_> like *self * *self doesn't copy?
[14:41:15] <bjz_> or does it?
[14:41:17] <kimundi> IT does?
[14:41:31] <dbaupp> bjz_: no, but that's because magic
[14:41:31] <kimundi> rusti: "foo".clone()
[14:41:32] -rusti- "foo"
[14:41:43] <kimundi> rusti: clone::clone("foo")
[14:41:44] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/BAcK
[14:41:46] <kimundi> rusti: Clone::clone("foo")
[14:41:46] -rusti- <anon>:7:9: 7:21 error: unresolved name `Clone::clone`.
[14:41:47] -rusti- <anon>:7          Clone::clone("foo")
[14:41:47] -rusti-                   ^~~~~~~~~~~~
[14:41:47] -rusti- error: aborting due to previous error
[14:41:47] -rusti- application terminated with error code 101
[14:41:56] <SiegeLord> That's the other UCFS
[14:41:57] <bjz_> rusti: fn mul<T:Copy + Num>(x: &T, y: &T) -> T { *x * *y } mul(&2, &3)
[14:41:58] -rusti- 6
[14:42:01] <bjz_> see?
[14:42:06] <dbaupp> bjz_: a * b = (&a).mul(&b), so *self * *self = (&*self).mul(&*self), and &* is essentially a noop.
[14:42:08] <kimundi> SiegeLord: I only know about that one
[14:42:23] <dbaupp> bjz_: and as far as I know, that's literally rustc's reasoning
[14:42:26] *** Quits: nano (nano@moz-972880B.superkabel.de) (Ping timeout)
[14:42:30] <bjz_> rusti: fn mul<T:Num>(x: &T, y: &T) -> T { *x * *y } mul(&2, &3)
[14:42:30] -rusti- 6
[14:43:00] <SiegeLord> kimundi: You said earlier this: "Right, my point was that allowing to call assoziated functions as methods doesn't allways make sense"
[14:43:03] <smvv_> I'm trying to use macro_rules!() but i'm not sure if i use the macro syntax correctly. The function signature is added as a comment to the macro body. https://gist.github.com/smvv/5990918
[14:43:16] <SiegeLord> kimundi: That kind of UCFS already exists
[14:43:35] <kimundi> SiegeLord: No?
[14:43:37] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[14:43:37] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/V4cmEA
[14:43:37] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[14:43:40] <dbaupp> smvv_: you need $list and $values to refere to the arguments to a macro
[14:43:40] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[14:43:40] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/lH200g
[14:43:40] <ghrust> 13rust/06auto 14948334f 15Birunthan Mohanathas: Add print! and println! macros. Closes #7653.
[14:43:40] <ghrust> 13rust/06auto 1486a14d5 15bors: auto merge of #7775 : poiru/rust/issue-7653, r=huonw...
[14:43:41] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[14:43:44] <SiegeLord> Because that's exactly what a method declaration looks like
[14:43:46] <dbaupp> *refer
[14:44:00] <kimundi> SiegeLord: I mean not:annotated-with-explicit-self assoziated functions
[14:44:14] <smvv_> dbaupp: i'm calling the macro like this: check_values!(t.keys, [Some(17), Some(26)]);
[14:44:42] <dbaupp> smvv_: right, in the body of the macro, use `$list` instead of `list` and `$values` instead of `values`
[14:45:06] <SiegeLord> kimundi: The first argument has to be the explicit self though for the call to work, no?
[14:45:07] <smvv_> ah that makes sense :)
[14:46:20] <dbaupp> smvv_: note that the substitutions are performed before the expressions are evaluated, so my_macro($x) => ($x; $x), my_macro!({ println("hello"); 1 }), will print hello twice
[14:46:40] <kimundi> SiegeLord: The situation is like this, rgiht?: trait Foo {fn a(self); fn b(s: Self)}; legal: foo.a(), Foo::a(foo), Foo::b(foo) illegal: foo.b()
[14:46:42] <dbaupp> smvv_: also, you will need double braces around the body of the macro, because they can't expand to multiple items
[14:47:05] <smvv_> dbaupp: similar as with the c preprocessor?
[14:47:08] <SiegeLord> kimundi: Just write b with a 'self' :P
[14:47:23] <SiegeLord> What exactly do you gain by making it more verbose?
[14:47:27] <dbaupp> rusti: macro_rules! foo(() => { println("a"); println("b") }) foo!()
[14:47:28] -rusti- a
[14:47:28] -rusti- ()
[14:47:42] <kimundi> SiegeLord: Err... I'm not sure whit we're arguing about here...
[14:47:54] <dbaupp> smvv_: yes, except they are AST/token tree substitutions rather than text substitutions
[14:48:10] <dbaupp> rusti: macro_rules! foo(() => {{ println("a"); println("b") }}) foo!()
[14:48:11] -rusti- a
[14:48:11] -rusti- b
[14:48:11] -rusti- ()
[14:48:14] <SiegeLord> kimundi: Is what you wrote the situation today, or situation you want to happen?
[14:48:27] * ChrisMorgan wants something along the lines of CTFE in Rust: that fancy web framework of yours, with those templates? Compile them in! (The alternative is another tool which generates code from the templates: not so nice but quite feasible.)
[14:48:33] <kimundi> The situotion thar is planned with ufcs
[14:48:38] *** Quits: SimonSapin (simon@moz-D0C2F181.zone2.bethere.co.uk) (Ping timeout)
[14:48:43] <SiegeLord> kimundi: I like that situation :)
[14:48:51] <dbaupp> smvv_: ^ note the difference between those two rusti inputs... the inner {} is just to make the whole body of the macro a single expression
[14:49:02] <kimundi> SiegeLord: Great :)
[14:49:12] <dbaupp> ChrisMorgan: syntax extensions!
[14:49:45] <smvv_> dbaupp: what would be the reason to *not* see it as a whole body by default?
[14:49:46] <ChrisMorgan> dbaupp: or that. What you'd need for such a thing is not currently in Rust, right?
[14:50:04] <SiegeLord> Incidentally, about duplicated code, you can probably factor it out into a crate... and then the code that needs to use it at runtime and the syntax extension can link to it
[14:50:10] <kimundi> ssbr: Btw, any news about the regex stuff you wanted to work on?
[14:50:28] <dbaupp> ChrisMorgan: `#[template_function_that_does_foo] fn foo() { ... } ` and the framework provides the syn-ext that creates the appropriate wrappers etc.
[14:50:43] <dbaupp> ChrisMorgan: yes, you need to be able to load synexts from external crates
[14:50:59] <smvv_> dbaupp: i'm familiar with #define a(b,c,d) do {(b)=(c)+(d)} while(0)
[14:51:10] <dbaupp> ChrisMorgan: which is hack-possible, but not do-it-right-possible
[14:51:25] <dbaupp> smvv_: a bug/not finished yet is the reaoson
[14:51:27] <dbaupp> *reason
[14:51:52] <dbaupp> smvv_: yeah, it's essentially the same thing as that, but not for the same reason
[14:51:55] <smvv_> ok. good to know that it's not permanent
[14:52:14] <dbaupp> smvv_: i.e. this one is a bug in  the macro system, not some interaction between the preprocessor and the language rules
[14:52:22] <ChrisMorgan> dbaupp: what would be inside `fn foo() { ... }`? The template, or would it be in a separate file? I guess there's probably not much point discussing it yet, anyway.
[14:52:46] <dbaupp> ChrisMorgan: don't know, whatever the framework needs foo to do.
[14:53:30] <ChrisMorgan> Well, I don't know what foo means in your example.
[14:53:54] *** Quits: MaikKlein (maik@moz-52EA1D97.dip0.t-ipconnect.de) (Ping timeout)
[14:55:51] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[14:55:53] <ChrisMorgan> I mean things like: with Django you have templates/x/y.html, which can be loaded and executedâ€”it's effectively turned into a function which can be called. But the syntax is quite different, geared for HTML/whatever with some bits of code inserted, rather than code with some bits of strings inserted. That could end up as a function call templates::x::y(context), for example.
[14:57:41] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[14:58:09] <bjz_> dbaupp: much nicer: https://github.com/bjz/lmath-rs/blob/master/src/geom/point.rs#L290
[14:58:28] <dbaupp> ChrisMorgan: right, that'd be more like `#[load_templates_from(my_dir)];  fn main() { templates::x::y:(context); }`, which would be entirely possible
[14:58:29] <ChrisMorgan> My basic primary goal with Rust is to produce a web framework which is the fastest, lightest (memory), most expressive and most thoroughly correct one in existence. I guess it'll take a few weeks yet.
[14:59:07] <dbaupp> bjz_: yes :)
[15:00:21] <bjz_> ChrisMorgan: I expect this release in three weeks time
[15:00:35] <ChrisMorgan> bjz_: nah, six to eight weeks. C'mon, gimme time.
[15:00:43] <bjz_> ChrisMorgan: 'a few'? :)
[15:01:13] <ChrisMorgan> And I expect someone else to make Rust work with Emscripten, so that we can have the entire stack being delightfully Correct.
[15:01:26] <bjz_> :)
[15:01:43] <bjz_> and asm.js ofc
[15:01:44] <ChrisMorgan> So that we can sing:â€”"And I am right, and you are right, and everything is quite correct."
[15:01:49] <ChrisMorgan> Naturally.
[15:01:50] <bjz_> for the ff users
[15:02:01] <bjz_> fffffffffff it's ffffast
[15:02:11] <ChrisMorgan> Hopefully by then everyone will support asm.js speed.
[15:02:16] <bjz_> yup
[15:02:32] <bjz_> all because rust and ChrisMorgan's web thingy
[15:02:35] <bjz_> :)
[15:02:55] <ChrisMorgan> And then somewhere along the way I become a billionaire, right?
[15:03:03] <bjz_> nope
[15:03:11] <ChrisMorgan> Meh. I'll deal with that later.
[15:03:16] <bjz_> the price of being a pioneer
[15:03:22] <ChrisMorgan> :D
[15:03:35] <bjz_> all the other folks get the monies
[15:03:40] <bjz_> :[
[15:04:53] <ChrisMorgan> Rust as a language has very much attracted for meâ€”it's the best fit I've found for my goal, with the added bonus (!) that there's very little such work done in Rust, so I don't have lots of compatibility things to sort out. e.g. in Go you'd be being forced into using net/http, in Python WSGI, Ruby Rack, Java that thingummy they have there, etc.
[15:05:13] <dbaupp> yay?
[15:05:32] <ChrisMorgan> Oh, it produces not joy unalloyed, but it leaves you more freedom.
[15:06:53] <ChrisMorgan> The possibilities of doing things *structurally* with enums and so on is delightful. Pretty much everything that exists uses strings once you get past the most absolutely fundamental things.
[15:07:09] *** Quits: rajul (quassel@6FD2C126.571F2E7A.13EFE003.IP) (Ping timeout)
[15:07:44] <dbaupp> I have a feeling that Haskell's web platforms don't
[15:07:48] <bjz_> ChrisMorgan: http://c2.com/cgi/wiki?StringlyTyped ?
[15:08:01] <ChrisMorgan> bjz_: absolutely
[15:08:13] <bjz_> <3 c2
[15:08:48] <ChrisMorgan> dbaupp: not sure, haven't ever worked with them (I should remedy that before I go much further). But Haskell is certainly the sort of language that would reject string typing.
[15:09:38] <dbaupp> ChrisMorgan: yeah, I haven't either; but I believe they do things like encoding escaped vs unescaped in the type system, and so on.
[15:09:49] <dbaupp> bjz_: you got issue 7777!
[15:09:51] * dbaupp is jealous
[15:10:01] <bjz_> :O
[15:10:09] <bjz_> I did?
[15:10:32] * bjz_ doesn't really care
[15:10:59] <dbaupp> ah, but you should! :P
[15:11:00] * bjz_ thinks that #7777 is just another number
[15:11:10] <ChrisMorgan> dbaupp: I'm talking at an even lower level than that. You want the Age header? Why are you using HashMap<~str, ~str> (or the equivalent in your language)? Connection: keep-alive or Connection: close? Why treat that as a string? Why not enum ConnectionValue { KeepAlive, Close }? And so forth.
[15:11:15] * bjz_ is attempting to rub it in dbaupp's face
[15:11:18] *** Joins: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca)
[15:11:18] <bjz_> :)
[15:11:33] <dbaupp> ChrisMorgan: ah, I see
[15:11:40] <Jesse> wake him up when #8192 is filed
[15:12:01] * ChrisMorgan frantically hunted for a bug to report when he got #7770 but couldn't find anything to report as #7777
[15:12:10] <dbaupp> ChrisMorgan: that would be neat... but possibly also unmanagable... I don't know.
[15:12:29] * dbaupp filed 3 bugs in 4 hours, so definitely deserves the milestone
[15:12:31] <dbaupp> ;P
[15:12:50] <Jesse> ChrisMorgan: gotta plan for the nice bug numbers ahead of time, like timeless and i did in the early days of gecko
[15:13:09] <dbaupp> Jesse: such as?
[15:13:48] <Jesse> see the dependency list of https://bugzilla.mozilla.org/show_bug.cgi?id=39985 which i used to file 40000
[15:14:39] <dbaupp> haha, saving up bugs for the milestone?
[15:14:56] <ChrisMorgan> dbaupp: one common convention in web servers is the CGI environment variable system, which is a nasty mess. It changes some things and munges others... but demonstrates that people can cope with such systems where what a header will be found as is inconsistent. And the alternative of a string/string map for *everything* is intolerable.
[15:15:24] <ChrisMorgan> I think much better can be done and I have some ideas up my sleeve.
[15:15:30] <Jesse> dbaupp: yes, or work that you know will find bugs
[15:15:38] <dbaupp> ChrisMorgan: looking forward to it :)
[15:16:07] * dbaupp starts collecting bugs to get 8000, 8192, 9000 and 10000
[15:16:50] * ChrisMorgan wishes it could be made such that request.header("Connection") [or whatever the final syntax] would then be illegal, with a compile-time error indicating "use request.connection() instead"
[15:16:51] *** Joins: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl)
[15:17:31] <kimundi> ChrisMorgan: Well, you can get a runtime fail :P
[15:17:40] <ChrisMorgan> Sure, but compile-time is so much nicer
[15:17:42] <Jesse> dbaupp: next step is to know who else is trying to get the bug numbers, and nerd snipe them. or wait until they're asleep, if you have enough bugs saved up.
[15:18:16] <dbaupp> Jesse: you've perfected the art?
[15:18:16] <kimundi> ChrisMorgan: request::header::<Connection>()
[15:18:17] <ChrisMorgan> My goal is rigid correctnessâ€”if it compiles, I *know* it is correct (yet without getting it to compile to be a burden, of course)
[15:18:30] <Jesse> dbaupp: i don't think i ever got that far
[15:20:03] <ChrisMorgan> Anyway, bed time now.
[15:20:14] <_Vi> Which project should be currently used as a reference for making Rust binding to C library? It should be not too big, but not too small (so structures, function pointers, callbacks, multithreading should be covered)?
[15:21:02] <kimundi> _Vi: Set of all good rust C bindings: {}
[15:21:44] <kimundi> :P
[15:21:56] <_Vi> kimundi, Is there some current guideline how to make proper, <s>rusty</s> idiomatic C bindings? Where to use "unsafe", where we can avoid it...
[15:22:40] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[15:23:27] <kimundi> Honestly, I don't know. extern functions are per default unsafe, to make them safe you need to write wrappers, structs have the same memory layout, multithreading will be a problem at the moment, function pointers seem to be a problem too.
[15:24:34] <dbaupp> _Vi: from the style guide "When writing a binding to an external library, put the raw C bindings in a module called ffi (rather than ll). Do not create high-level bindings called hl."
[15:24:44] *** Joins: jclements (jclements@moz-20AD2EFB.dsl.static.sonic.net)
[15:24:50] <dbaupp> _Vi: (that's the only thing mentioned there though.)
[15:25:16] <kimundi> dbaupp: That advice sounds highly specific and unhelpfull xD
[15:25:55] <dbaupp> kimundi: it's neither that specific, nor that unhelpful... just only helpful with module layout
[15:26:17] <dbaupp> _Vi: essentially, only use unsafe where the compiler tells you to
[15:26:33] <dbaupp> _Vi: and where you know it's definitely safe if you need more speed.
[15:26:39] * bjz_ is having a joyous time breaking default methods
[15:26:41] <kimundi> yeah, "don't name them this or that. Good luck!" :)
[15:26:45] *** Quits: smvv_ (sander@moz-BAEA8EB2.dynamic.upc.nl) (Quit: leaving)
[15:27:05] <dbaupp> kimundi: and "name it `ffi`"... it's not all negative :P
[15:27:22] <sigma> yeh, I abandoned my libxml2 bindings 
[15:27:22] <kimundi> yeah, yeah...
[15:27:30] * bjz_ is having fond memories of all the ICEs he had with trait inheritance
[15:27:41] <sigma> they'll wait until I have a firmer grasp on what idiotmatic rust should look like :)
[15:27:48] <_Vi> In particular I think about FUSE now. In simple (not low-level) mode you provide a struct with function pointers to FUSE and it calls back these functions. It can also happen to be multithreaded. Sometimes you need a thing like "reinterpret cast" to preserve your object across callbacks.
[15:27:49] *** Joins: sankha93 (Instantbir@4505BE8A.922BE1F.EFB84E89.IP)
[15:28:03] <dbaupp> bjz_: are you on today's rustc now?
[15:28:10] <SiegeLord> It'd be nice to have an example of how to pass callbacks into C
[15:28:25] <bjz_> sigma: I hacked together some in my attempt to parse the gl spec
[15:28:27] <dbaupp> there is one somewhere, I think. dunno where.
[15:28:29] <SiegeLord> Also how to deal with callbacks passed into C that are called in a different thread
[15:28:44] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[15:29:04] <dbaupp> _Vi: std::cast::transmute is Rust's magic converter.
[15:29:31] <dbaupp> _Vi: no idea how successful passing a struct of callbacks to C would be.
[15:30:24] <sigma> I've got the low level bindings done to the bits I need at the minute, so it's no longer blocking my actual project, it just requires some very ugly c-like code, but it's happily wrapped up in a few functions
[15:30:31] *** Quits: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com) (Ping timeout)
[15:30:46] <bjz_> dbaupp: there isn't much of difference when I fetched
[15:30:56] <dbaupp> bjz_: oh :(
[15:30:58] <bjz_> dbaupp: only ten commits
[15:31:30] <bjz_> dbaupp: the stuff I'm trying to do was bound to make it break though
[15:31:31] <dbaupp> bjz_: and none were 1ee54a86171d70f439b3cf77e566150b78251bc2?
[15:31:44] <bjz_> dbaupp: what was the message?
[15:31:57] <dbaupp> commit message?
[15:32:00] <bjz_> oh wait
[15:32:04] <bjz_> might have been :P
[15:32:23] <bjz_> will try rebuilding
[15:32:23] <dbaupp> bjz_: but yeah, file bugs ;P
[15:32:48] <bjz_> dbaupp: yeah, will have to move my lazy ass
[15:33:07] <dbaupp> hehe
[15:33:08] *** Joins: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com)
[15:33:10] <bjz_> dbaupp: I wanna get rid of some of my macros
[15:33:35] <bjz_> dbaupp: but yeah: impl<T> Mat<T, Vec4<T>, [T,..4], [Vec4<T>,..4]> for Mat4<T> {}
[15:33:44] <bjz_> :P
[15:33:59] <dbaupp> looks... awesome?
[15:34:07] <bjz_> pub trait Mat<T, ColVec: Dimensional<T, VecSlice>, VecSlice, MatSlice>: Dimensional<ColVec,MatSlice> { ... }
[15:34:20] * dbaupp loves massively parameterised traits
[15:34:32] <bjz_> if that wasn't going to break it, nothing was
[15:35:40] <bjz_> associated items would be a huge help there
[15:35:53] *** Joins: Sorella (queen@78575561.924F2739.95C8B7C6.IP)
[15:36:00] <bjz_> and constants in parameter lists
[15:36:49] *** Quits: valentin (valentin@moz-FF32B246.red-80-27-103.dynamicip.rima-tde.net) (Client exited)
[15:36:52] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[15:37:04] <bjz_> dbaupp: the difficulty is I have no clue how to lay them out nicely
[15:37:36] <dbaupp> yeah, and auto-indenters don't like < as an opening brace
[15:37:47] <dbaupp> (at least, the emacs one doesn't seem to.)
[15:38:03] <bjz_> parsers in general don't like <> as delimeters
[15:38:05] *** Quits: jclements (jclements@moz-20AD2EFB.dsl.static.sonic.net) (Quit: jclements)
[15:39:16] <dbaupp> right
[15:39:40] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[15:39:44] <bjz_> dbaupp: at least with C++ templates they sit nicely above
[15:39:48] *** Joins: victorporof (victorporo@moz-613026B7.info.uaic.ro)
[15:40:08] <doener> yay, another 240k lines gone from unoptimized librustc.ll
[15:40:08] <bjz_> dbaupp: but with our syntax everything is indespersed
[15:40:21] * bjz_ claps
[15:40:30] <dbaupp> doener: woah, how?
[15:40:54] <doener> dbaupp: figured out what was _actually_ wrong with the glue that broke the inlining
[15:41:15] <dbaupp> bjz_: yeah, the generics layout problem will be the hardest part of writing correct Rust code :'(
[15:41:15] <doener> dbaupp: so now glue fns have specific types again and most bitcasts go away
[15:41:28] <Jesse> "lines"? i thought obj code was measured in bytes
[15:41:30] <dbaupp> doener: like magic! :)
[15:41:40] <doener> dbaupp: basically, the original error was to cast the function instead of the argument
[15:41:50] <dbaupp> Jesse: LLVM human-readable IR
[15:41:53] <bjz_> dbaupp: one of the things I really dislike about Rust
[15:42:31] <dbaupp> doener: oh, did we cast the function to match the argument rather than vice versa?
[15:42:36] <bjz_> dbaupp: I have a feeling parametric polymorphism will always be *particularly* ugly in Rust
[15:42:56] <dbaupp> bjz_: yeah
[15:43:11] <bjz_> dbaupp: even though it almost always is in other langauges
[15:43:18] <doener> dbaupp: yeah, and llvm didn't like that
[15:43:23] <dbaupp> bjz_: except Haskell...
[15:43:33] * dbaupp wishes he could have Rust with Haskell's generics
[15:43:46] <bjz_> dbaupp: it doesn't have parametric polymorphism though?
[15:43:50] <bjz_> or does it?
[15:44:14] <doener> dbaupp: well, actually it's a bit more involved. The TyDesc is supposed to hold glue that takes i8*. So it was assumed that we always need a cast
[15:44:24] <dbaupp> doener: yup, seems like something that's surprising, and would make LLVM unhappy
[15:44:40] <dbaupp> bjz_: Haskell *invented* parametric polymorphism
[15:44:44] <dbaupp> bjz_: well, not really
[15:45:06] <dbaupp> bjz_: but Rust's typesystem is very similar to a weak Haskell
[15:45:09] <bjz_> dbaupp: I'm talking about Java/C++/D/C#/Scala style type parameters
[15:45:19] <dbaupp> right
[15:45:29] <doener> dbaupp: but actually, when we emit the glue that can be statically called, we still have the functions that take the actual type, so we don't have to cast. The cast is only required when we emit the tydesc for the dynamic calls.
[15:45:53] <dbaupp> bjz_: (Haskell) foo:: a -> a == fn foo<A>(x: A) -> A (Rust)
[15:46:11] *** Quits: victorporof (victorporo@moz-613026B7.info.uaic.ro) (Ping timeout)
[15:46:12] <bjz_> ahh
[15:46:15] <dbaupp> bjz_: (Haskell) foo:: SomeClass a => a -> a == fn foo<A: SomeTrait>(x: A) -> A (Rust)
[15:46:26] <bjz_> ok I see
[15:46:31] *** Quits: pyrac (pyrac@moz-F2C67F88.w83-114.abo.wanadoo.fr) (Quit: pyrac)
[15:46:39] *** Quits: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk) (Ping timeout)
[15:47:06] <bjz_> one of the disadvantages of C syntax
[15:47:21] <dbaupp> doener: and we used to cast for static glue calls?
[15:47:39] <dbaupp> doener: (this is the problem with the inlining, right?)
[15:47:58] * dbaupp sighs
[15:48:00] <doener> dbaupp: yep
[15:48:08] <dbaupp> default methods aren't good enough to touch std::num yet.
[15:48:12] * dbaupp wants a snapshot
[15:48:28] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[15:48:28] <bjz_> no?
[15:48:32] <bjz_> poop
[15:48:36] <bjz_> :(
[15:48:38] <SiegeLord> bjz_: x: A is not C syntax :P
[15:48:42] <dbaupp> doener: awesome! so you'll have removed 15% of our IR in a few days
[15:48:59] <dbaupp> bjz_: well, somethings making stage0 ice :(
[15:49:19] <bjz_> SiegeLord: I'm talking about types and identifiers in one line
[15:49:49] <bjz_> SiegeLord: as opposed to haskell, where you write the types optionally above
[15:49:50] * dbaupp leaves it for the night
[15:49:55] <bjz_> night
[15:50:31] <doener> dbaupp: yup. Sadly that doesn't seem to affect the runtime of the LLVM passes in any measurable way
[15:50:46] <doener> dbaupp: ... which makes me suspect that we're doing something incredibly wrong
[15:51:16] <dbaupp> doener: hahaha ... well... it'll be 15% easier to diagnose :)
[15:52:24] <bjz_> doener: that's awesome though
[15:52:35] <bjz_> doener: getting closer to the problem
[15:52:55] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[15:52:59] <bjz_> doener: "which makes me suspect that we're doing something incredibly wrong" is awesome
[15:55:38] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[15:55:38] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1486a14d5 to 14403cdd8: 02http://git.io/N3iJvQ
[15:55:38] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[15:56:57] *** Joins: Archaeopteryx (itsme@moz-9E1DCD04.cust.telecolumbus.net)
[15:58:46] *** sam113101 is now known as sam113101_afk
[15:59:33] <doener> bjz_: well, it just doesn't behave like I expect it too. Seems weird that you can remove tons of IR and see pretty much no speed impact at all. OTOH, I've started working with LLVM only about a month ago, so I'm still rather clueless
[16:02:08] *** Quits: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net) (Ping timeout)
[16:02:53] *** Joins: fabiand (fabiand@moz-7547B95F.adsl.alicedsl.de)
[16:04:32] *** Quits: Earnestly (earnest@2AB30F53.FB5005.2BCC804A.IP) (Ping timeout)
[16:05:06] *** Joins: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk)
[16:09:25] *** Quits: sankha93 (Instantbir@4505BE8A.922BE1F.EFB84E89.IP) (Ping timeout)
[16:13:17] *** Joins: Earnestly (earnest@2AB30F53.FB5005.2BCC804A.IP)
[16:14:47] *** Quits: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl) (Client exited)
[16:18:42] *** Joins: jclements (jclements@moz-20AD2EFB.dsl.static.sonic.net)
[16:25:05] *** Quits: jclements (jclements@moz-20AD2EFB.dsl.static.sonic.net) (Quit: jclements)
[16:27:39] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[16:28:27] *** Joins: jfbk (textual@moz-EEA9CFB3.nyc.res.rr.com)
[16:29:24] *** Joins: MaikKlein (maik@moz-52EA1D97.dip0.t-ipconnect.de)
[16:30:18] <steven_is_false> It occurred to me that the only reason Rust threads can have isolated garbage collection is because no two Rust garbage collected heaps, or regions can point to each other. I'm curious could there be some utility in having multiple isolated GC heaps per task?
[16:32:14] <jensnockert> steven_is_false: Not really, you could just have more tasks.
[16:32:41] <steven_is_false> jensnockert: Fair enough.
[16:33:28] <jensnockert> I am sure there could be some utility, but the borrow checker would have a harder time, I think?
[16:33:38] <steven_is_false> Probable.
[16:33:40] <jensnockert> But generally, needs moar tasks.
[16:35:29] <steven_is_false> Okay, I have a real question now. Is having a separate GC for each task faster, as fast as, or slower than having one GC for a whole application?
[16:37:19] <kimundi> one gc per task means the gcs don't need to sync in multithreading situations, smaller ivndividual heaps mean less work on each task
[16:37:52] <kimundi> so, i'd say it's faster
[16:37:54] *** Quits: MaikKlein (maik@moz-52EA1D97.dip0.t-ipconnect.de) (Ping timeout)
[16:38:00] <steven_is_false> kimundi: Okay.
[16:38:12] <jensnockert> steven_is_false: Faster, you can GC in the background.
[16:38:18] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[16:38:43] *** Joins: ross (ross@moz-8A84103E.br.br.cox.net)
[16:38:49] <steven_is_false> I read somewhere that GCs are faster when there's a bunch of free space available. If the free space is split up among the tasks won't the GCs be slower? I don't know if this makes sense.
[16:38:52] <kimundi> of course the big difference is that you can't move thinks between tasks that way, wich you could with one gc
[16:39:07] <jensnockert> steven_is_false: No, the free space is not split, only the used space.
[16:39:22] <jensnockert> steven_is_false: (Not that Rust has a proper GC yet, but in theory)
[16:39:43] <steven_is_false> Okay, there are local (caches is that the right word) though right?
[16:40:13] <steven_is_false> But that's only at the low-level jemalloc level though right?
[16:40:44] <kimundi> if jmalloc were enabled, it'd use thread loal storage as cach for mallocs
[16:41:03] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[16:41:09] <kimundi> so that for smaller allocations it wouldn't need to lock
[16:41:30] <steven_is_false> Oh right jemalloc's still kind of broken.
[16:43:29] *** Quits: z0w0 (zack@moz-37A98529.lnse2.woo.bigpond.net.au) (Client exited)
[16:44:07] <steven_is_false> Are the cache's at the OS thread level, or the Rust task level?
[16:44:33] <steven_is_false> Thread-locals work by stacks right?
[16:44:55] <steven_is_false> I mean each stack has some kind of context, or something right?
[16:45:06] <kimundi> no idea about stacks, but the jmalloc cache would be per-thread
[16:45:47] <steven_is_false> Okay. Would there be any benefit to having per task caches (there wouldn't be a need for locking anyways?)
[16:46:53] <kimundi> don't think so
[16:47:00] <steven_is_false> Okay
[16:48:03] *** Joins: Ubaion (Archer@moz-DA478E33.bb.online.no)
[16:48:11] <kimundi> seeing how only one task on a thread could run at a time, having different caches to prevent shared access would be pointless
[16:48:17] *** Quits: Archer (Archer@moz-DA478E33.bb.online.no) (Ping timeout)
[16:52:08] *** Joins: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch)
[16:52:12] <sully> bjz_: having a trait parameterize over other traits and then use them in the default methods... half works
[16:53:59] <sully> bjz_: it doesn't work in the cross crate case because I haven't made us properly export information about the resolutions of trait params on traits
[16:54:28] <sully> bjz_: this was low priority for me to fix, because I didn't think anybody actually needed this
[16:54:38] <sully> bjz_: but if you want to do this, I can make it second on my TODO list
[16:54:39] <bjz_> heh
[16:54:50] <bjz_> I have a tendency to do that
[16:55:01] <sully> first on my TODO list is fixing a really bad cross crate bug
[16:55:05] <bjz_> (with lmath at least)
[16:55:34] <sully> where if you try to inline a function calling a default method, it breaks
[16:55:53] <bjz_> ahh ok
[16:56:00] <bjz_> well yeah, no pressure
[16:56:31] <bjz_> my code works at the moment, I just want to make it more succinct
[16:56:41] <bjz_> and rely less on macros
[16:56:53] *** Quits: fabiand (fabiand@moz-7547B95F.adsl.alicedsl.de) (Quit: Verlassend)
[16:57:16] <sully> I feel pretty bad about that cross crate bug, since it is pretty blatant
[16:57:30] <sully> and of course I realize it right after I take default methods out from behind the flag
[16:57:30] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[16:57:46] <bjz_> dude, you are a brave fellow for taking on default methods
[16:58:13] <bjz_> so I wouldn't sweat it
[16:58:50] <sully> so, actually, the first thing on my TODO list, to facilitate this fix
[16:59:06] <sully> is rage refactoring all of the datastructures for the trait system
[16:59:13] <bjz_> :D
[16:59:15] <sully> and especially all of the data structures for default methods
[16:59:31] <bjz_> where are they located?
[16:59:46] <sully> EVERYWHERE
[16:59:55] <bjz_> :O
[16:59:56] <sully> I guess I probably won't mess with resolve's trait_map...
[17:00:18] <sully> but I have a patch that expunges CoherenceInfo from the world entirely
[17:00:37] <sully> both of the maps in it were basically duplicated in ty::Ctxt
[17:01:49] <sully> although the way it was duplicated for one of them was a little bogus
[17:03:26] <sully> extension_methods in CohereneceInfo and trait_impls in ty::Ctxt had more or less the same data
[17:03:36] <sully> but trait_impls stored it as a map from trait def_id's
[17:03:46] <sully> to maps from types to impls
[17:03:59] <sully> and the maps from types to impls is a pretty bogus thing to do
[17:04:07] <sully> and doesn't work at all in the presence of polymorphism
[17:04:14] <bjz_> I have no idea about much of the compiler internals, but it seems you are doing some awesome stuff
[17:04:36] <sully> and is used in exactly one place, the translation of calls to a super trait method from inside a default method
[17:04:48] <sully> which is completely broken in the presence of polymorphism as a result
[17:07:18] *** Joins: dwhyte (dwhyte@ED9190FB.B72E355F.7BF4A4B0.IP)
[17:10:29] *** Joins: sankha93 (Instantbir@DEFFDB5A.7FCF9508.EFB84E89.IP)
[17:12:08] *** Quits: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch) (Ping timeout)
[17:12:38] *** Joins: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl)
[17:19:31] <cmr> steven_is_false: Overall time spent is probrably going to be the same, global gc/per-task gc, but the thing is you get better interactivity
[17:19:41] <cmr> You basically get incremental GC for free, with task granularity
[17:19:51] *** Quits: mcclurmc (mcclurmc@moz-8D61EFD1.cable.virginmedia.com) (Ping timeout)
[17:20:05] <cmr> steven_is_false: (and only moving GC is faster with more free space, afaik. rust can't have a moving gc)
[17:21:09] <steven_is_false> Okay
[17:21:54] <steven_is_false> I wish there was a platform that was inbetween the JVM level of abstraction, and the raw level of abstraction.
[17:22:01] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[17:22:12] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[17:22:32] <steven_is_false> So one could experiment with one's own GC schemes.
[17:22:47] <cmr> Isn't that called lisp?
[17:22:49] <cmr> :p
[17:22:57] <steven_is_false> true
[17:23:17] *** Joins: dew (Instantbir@moz-66796D51.dhcp.stls.mo.charter.com)
[17:23:37] <cmr> aiui java has the best, most advanced GCs, state-of-the-art
[17:24:12] <steven_is_false> Right, but one can't have deterministic stuff.
[17:24:23] <cmr> that's true of all gc, no?
[17:24:34] <cmr> unless you severely restrict what a program can do
[17:24:35] <steven_is_false> cmr: Reference counting is a type of GC.
[17:24:50] <cmr> steven_is_false: rc+cc
[17:24:52] <steven_is_false> Even malloc, and free are basically GC. They do a lot of work behind the scenes.
[17:24:52] <cmr> can't forget the cc
[17:25:09] <steven_is_false> concurrent collector?
[17:25:11] <cmr> It's memory management for sure, but GC? hardly.
[17:25:13] <cmr> cycle collector
[17:25:29] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[17:25:58] <steven_is_false> Okay so one could experiment with one's own memory management schemes.
[17:27:36] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[17:30:59] <steven_is_false> Thanks for the conversation. Bye
[17:31:19] *** Quits: steven_is_false (user@moz-144077DE.bchsia.telus.net) (Client exited)
[17:33:38] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[17:34:34] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[17:34:34] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/H5P_nQ
[17:34:34] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[17:35:50] <nmatsakis> sully: it pleases me to see you talk about removing those maps in particular,
[17:36:08] <nmatsakis> sully: they looked pretty bogus to me when I was lsat reading that code...
[17:36:27] <sully> I also think that I can remove all of the provided methods maps
[17:37:03] <nmatsakis> good, I also disliked those. I really feel that default methods should not need additional specialized maps
[17:37:26] <sully> I'll be adding a map from impl def_ids to the impl information
[17:37:33] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[17:37:33] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/H2FgtA
[17:37:33] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[17:37:35] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[17:37:35] <ghrust> 01[13rust01] 15bors pushed 9 new commits to 06auto: 02http://git.io/9M_74A
[17:37:35] <ghrust> 13rust/06auto 141c62e45 15Patrick Walton: librustc: Add a lint mode for unnecessary `copy` and remove a bunch of them.
[17:37:35] <ghrust> 13rust/06auto 149177262 15Patrick Walton: librustc: Remove all uses of "copy".
[17:37:36] <ghrust> 13rust/06auto 14ead2bd9 15Patrick Walton: librustc: Remove `copy` expressions from the language.
[17:37:39] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[17:37:39] <sully> and adding fields to ty::Method about whether there is a default implementation
[17:37:39] <sully> I think
[17:38:00] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[17:38:05] <nmatsakis> sully: ok, that sounds potentially reasonable. 
[17:38:39] <slaren> what would be the idiomatic way of copying the raw bytes of a struct into a [u8] ?
[17:38:49] <cmr> slaren: IterBytes
[17:38:55] <slaren> at the moment I am using something like ptr::copy_nonoverlapping_memory(vec::raw::to_mut_ptr(dst), ptr::to_unsafe_ptr(&src) as *u8, sys::size_of_val(&src))
[17:39:00] <slaren> but it looks too complex
[17:39:06] <cmr> http://static.rust-lang.org/doc/std/to_bytes.html
[17:39:08] <sully> it is super silly that right now we have a mapping from impl id to a list of methods that use the default implementation
[17:39:18] <sully> but not like, a map from impl id to... a list of all the methods
[17:39:24] <nmatsakis> yes...
[17:39:46] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[17:40:23] <cmr> slaren: for most structs, you can slap a #[deriving(IterBytes)] on it, and you get IterBytes and ToBytes for free.
[17:40:42] <slaren> I'll try that, thanks
[17:41:52] <nmatsakis> slaren: what are you trying to do exactly? I'd say that memcpy'ing bytes of a struct is just sort of inherently non-idiomatic...
[17:42:25] <nmatsakis> slaren: ...iter-bytes isn't probably quite what you want. Your call above looks reasonable, if verbose. 
[17:42:32] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[17:43:04] <slaren> it is for a bindings to a C library, where an union is used
[17:43:20] <cmr> ah, in that case iterbytes probably not what you want
[17:56:32] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[17:58:14] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[17:58:47] *** Quits: Nisstyre (wes@moz-FD86289.netflash.net) (Quit: Leaving)
[18:03:51] *** Joins: Kruppe (user@moz-EE1E894A.home3.cgocable.net)
[18:07:33] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[18:07:33] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14ba1d1e0 to 1448bfb90: 02http://git.io/N3iJvQ
[18:07:33] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[18:07:35] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[18:07:35] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/XUHmhg
[18:07:35] <ghrust> 13rust/06auto 14dcd5d14 15BjÃ¶rn Steinbrink: Avoid return blocks that have only a single predecessor...
[18:07:35] <ghrust> 13rust/06auto 145df2bb1 15BjÃ¶rn Steinbrink: Avoid empty "static_allocas" blocks...
[18:07:35] <ghrust> 13rust/06auto 141d2e1a9 15BjÃ¶rn Steinbrink: Avoid empty "else" blocks...
[18:07:37] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[18:09:06] <leonvv> Does anybody know where "rand::RngUtil" is located? "std::rand::RngUtil" Gives me: "unresolved name".
[18:12:35] <ross> std::rand::RngUtil
[18:12:51] <ross> I use it and my code compiles
[18:15:33] <mark_edward> leonvv: out put of `rustcc--version`
[18:16:01] <leonvv> rustc 0.7
[18:16:01] <leonvv> host: x86_64-apple-darwin
[18:18:20] <ross> rusti: use std::rand; use std::rand::RngUtil; let mut rng = rand::rng(); let b: bool = rng.gen(); b
[18:18:21] -rusti- false
[18:18:22] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[18:21:29] <leonvv> I got it to work, thanks ross, I was using "Rng" instead of "rng".
[18:26:09] <ross> np :)
[18:29:54] *** Joins: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch)
[18:30:23] <doomlord> hacked up a little utility to show context of grep search results ( so when grepping for a rust function i can easily see surrounding module/trait/impl...)
[18:31:36] <ronny> hmm
[18:37:17] <doomlord> https://github.com/dobkeratops/unfold  .. probably many other ways of acheiving the same thing
[18:53:05] *** Quits: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net) (Ping timeout)
[18:54:41] *** Joins: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net)
[18:57:45] *** Joins: SimonSapin (simon@moz-D0C2F181.zone2.bethere.co.uk)
[19:05:02] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Ping timeout)
[19:06:54] *** Quits: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch) (Quit: Leaving.)
[19:09:16] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[19:09:20] *** Joins: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch)
[19:09:50] *** Joins: cr (anonymous@moz-3EF5FF9F.dip0.t-ipconnect.de)
[19:11:12] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[19:13:52] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[19:24:55] *** Quits: leonvv (leonvv@moz-7D83A5F1.ip.telfort.nl) (Client exited)
[19:27:55] *** Quits: SimonSapin (simon@moz-D0C2F181.zone2.bethere.co.uk) (Ping timeout)
[19:28:22] *** Quits: santiago (santiago@moz-656C5B51.hsd1.ma.comcast.net) (Quit: Computer has gone to sleep.)
[19:28:56] *** Joins: santiago (santiago@moz-656C5B51.hsd1.ma.comcast.net)
[19:29:45] *** Joins: SimonSapin (simon@moz-D0C2F181.zone2.bethere.co.uk)
[19:32:30] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[19:34:57] *** Quits: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch) (Quit: Leaving.)
[19:38:11] *** Joins: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net)
[19:38:31] *** Joins: fabiand (fabiand@moz-7547B95F.adsl.alicedsl.de)
[19:38:42] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[19:39:26] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[19:42:40] <fabiand> hey
[19:42:57] <fabiand> I read that the GC shal be removed from the language, and moved into a lib ... 
[19:43:11] <cmr> fabiand: managed pointers, not the GC
[19:43:19] <fabiand> cmr, oh okay ..
[19:43:27] <cmr> Well, maybe the GC too, but probably not
[19:43:33] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[19:43:33] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/XUHmhg
[19:43:33] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[19:43:37] <fabiand> cmr, good day ... you always seem to be around :)
[19:44:04] <fabiand> so, managed pointers, so referenc counted objects, right?
[19:44:18] <cmr> Well, we already have Rc<T> for reference counting
[19:44:27] <cmr> @T is supposed to be full tracing gc
[19:44:45] <cmr> graydon has code for it, but there are complications landing it
[19:44:55] <cmr> (rustc uses too much memory on 32-bit, can't bootstrap)
[19:44:56] <fabiand> right ...
[19:45:06] <fabiand> oops :)
[19:45:38] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Ping timeout)
[19:45:43] <mark_edward> cmr: how do you go from int -> enum type? need to do it for some C bindings
[19:46:00] <cmr> mark_edward: you can't, not safely, but it should just be a std::cast::transmute
[19:46:13] <mark_edward> ok, thanks man
[19:46:30] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[19:46:30] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/K_9lmQ
[19:46:30] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[19:46:32] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[19:46:33] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/YIlWNA
[19:46:33] <ghrust> 13rust/06auto 144f4dfcd 15Alex Crichton: Allow non-uppercase-statics by default...
[19:46:33] <ghrust> 13rust/06auto 1491ead0e 15Alex Crichton: Clean up various warnings throughout the codebase
[19:46:33] <cmr> can also have a from_int method that does a match and fails if it's invalid... safe, but tedious
[19:46:34] <ghrust> 13rust/06auto 1451afe61 15Alex Crichton: Purge the last remnants of the old TLS api...
[19:46:35] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[19:47:14] <SiegeLord> A possible candidate for a trait and #[deriving]?
[19:48:20] <cmr> SiegeLord: makes sense for me
[19:50:48] *** Quits: sankha93 (Instantbir@DEFFDB5A.7FCF9508.EFB84E89.IP) (Ping timeout)
[19:54:53] *** Joins: eatkinson (eatkinson@moz-AD233F1B.dia.static.qwest.net)
[19:54:57] *** Quits: mye (mye@moz-9B08539F.dip0.t-ipconnect.de) (Quit: mye)
[19:56:22] *** Joins: Ms2ger (Ms2ger@3F038EB7.1AB48F49.F15B0BB3.IP)
[19:56:54] *** Joins: pyrac (pyrac@moz-F2C67F88.w83-114.abo.wanadoo.fr)
[19:57:32] *** Joins: tjc (tjc@moz-CDF09112.hsd1.wa.comcast.net)
[19:57:32] *** ChanServ sets mode: +o tjc
[19:58:41] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[20:03:39] <cmr> tjc: re: matching strings from that list, I think that could be naively implemented with an attribute like #[matches_from(varname)]
[20:05:39] <tjc> cmr: I'm missing some context, I think...
[20:06:13] <cmr> https://github.com/catamorphism/rust/commit/dc6829c455d87fdc51876220c1d14af1689133fd#L9R31
[20:07:52] <Eridius> does anyone know anything about the overuse of fds? https://github.com/mozilla/rust/issues/7772
[20:07:52] <SiegeLord> It'd be nice if you could do enum { Blah = "blah" } like you can do for integers
[20:08:02] <Eridius> I can't run the test suite without specifying RUST_TEST_THREADS=4
[20:08:04] <SiegeLord> Maybe that's beyond the idea of enums though
[20:08:10] <cmr> SiegeLord: the = thing is for defining the value of the descriminant
[20:08:10] <tjc> cmr: Ah, ok
[20:08:20] <tjc> SiegeLord: What would you use that for?
[20:08:48] <SiegeLord> Well... enum { Blah="blah" }  match "blah" { Blah => }
[20:09:05] <Eridius> static Blah : &'statc str = "blah"
[20:09:58] *** Quits: eatkinson (eatkinson@moz-AD233F1B.dia.static.qwest.net) (Quit: eatkinson)
[20:10:18] *** Quits: fabiand (fabiand@moz-7547B95F.adsl.alicedsl.de) (Quit: Verlassend)
[20:10:32] <SiegeLord> rusti: static Blah : &'static str = "blah"; let a = [Blah]; a
[20:10:33] -rusti- <anon>:7:9: 7:45 warning: static constant should have an uppercase identifier [-W non-uppercase-statics (default)]
[20:10:34] -rusti- <anon>:7          static Blah : &'static str = "blah"; let a = [Blah]; a
[20:10:34] -rusti-                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[20:10:34] -rusti- ["blah"]
[20:10:44] *** Quits: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net) (Quit: echristo)
[20:10:55] <tjc> that's weird
[20:11:00] <tjc> oh, never mind
[20:11:00] <Eridius> rusti: #[allow(non_uppercase_statics)]static Blah: &'static str = "blah"; a
[20:11:01] -rusti- <anon>:7:76: 7:77 error: unresolved name `a`.
[20:11:01] -rusti- <anon>:7          #[allow(non_uppercase_statics)]static Blah: &'static str = "blah"; a
[20:11:01] -rusti-                                                                                      ^
[20:11:01] -rusti- error: aborting due to previous error
[20:11:02] -rusti- application terminated with error code 101
[20:11:04] <Eridius> rusti: #[allow(non_uppercase_statics)]static Blah: &'static str = "blah"; blah
[20:11:05] -rusti- <anon>:7:76: 7:80 error: unresolved name `blah`.
[20:11:05] -rusti- <anon>:7          #[allow(non_uppercase_statics)]static Blah: &'static str = "blah"; blah
[20:11:06] * tjc reminds self that uppercase isn't sentence case
[20:11:08] -rusti-                                                                                      ^~~~
[20:11:11] -rusti- error: aborting due to previous error
[20:11:13] -rusti- application terminated with error code 101
[20:11:14] <Eridius> bah I can't type
[20:11:16] <tedh> is bcully around?
[20:11:23] <cmr> brendanc: you've been requested!
[20:11:43] <brendanc> I happen to be here for a few minutes
[20:12:08] <tedh> had a question on the large stacks pr that was recently merged
[20:12:18] <brendanc> ok
[20:12:38] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[20:13:06] <SiegeLord> rusti: static BLAH : &'static str = "blah"; static A = [BLAH]; A
[20:13:06] -rusti- <anon>:7:55: 7:56 error: expected `:` but found `=`
[20:13:07] -rusti- <anon>:7          static BLAH : &'static str = "blah"; static A = [BLAH]; A
[20:13:07] -rusti-                                                                 ^
[20:13:07] -rusti- application terminated with error code 101
[20:13:27] <tedh> i didn't fully follow all the discussion, but i thought that it was not supposed to be a big perf hit
[20:13:35] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[20:13:35] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14f6779ae to 148d0feb5: 02http://git.io/N3iJvQ
[20:13:35] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[20:13:38] <cmr> tedh: it wasn't
[20:13:45] <cmr> at least, not for rustc
[20:13:53] <cmr> maybe other programs showed a regression?
[20:14:04] <brendanc> large stacks made something slower?
[20:14:05] <tedh> i have a task benchmark that took a big hit
[20:14:24] <tedh> 5x slower spawning 64000 tasks
[20:14:35] <cmr> Larger allocations take longer and put more pressure on the allocator
[20:14:58] <brendanc> yes, if you have a benchmark that spawns tasks that never trip morestack, it'll be worse
[20:15:06] <SiegeLord> rusti: static BLAH : &'static str = "blah"; static A : &'static [ &'static str ] = [BLAH]; A
[20:15:07] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/POff
[20:15:12] <brendanc> 5x is about right since the old small stack was 1/5 of a page
[20:15:22] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[20:15:31] <heftig> ~ uses malloc or a custom allocator?
[20:15:35] <cmr> heftig: malloc
[20:15:38] <SiegeLord> rusti: static BLAH : &'static str = "blah"; static A : &'static [ &'static str ] = &[BLAH]; A
[20:15:39] -rusti- &["blah"]
[20:15:40] <cmr> custom allocator... eventually
[20:15:41] *** Quits: Archaeopteryx (itsme@moz-9E1DCD04.cust.telecolumbus.net) (Quit: It has been this message for years.)
[20:15:45] <cmr> (hopefully)
[20:15:45] <mark_edward> what are the rules for rust identifier naming?
[20:15:46] <Eridius> oh great, the TLS rewrite failed because the compile-fail/core-tls-store-pointer.rs test wasn't updated
[20:15:51] <heftig> is it possible to change that, e.g. a slab-allocator?
[20:15:53] <Eridius> guess I'm waiting longer to get my term stuff in
[20:15:55] <cmr> heftig: yes
[20:16:07] <cmr> heftig: and we're migrating to jemalloc as soon as we can
[20:16:11] <brendanc> I suppose we ought to add the explicit initial stack size control for benchmarks like this
[20:16:19] <cmr> mark_edward: http://www.unicode.org/reports/tr31/
[20:16:45] <cmr> mark_edward: (and they can't be keywords)
[20:16:57] <heftig> if jemalloc is that good, why isn't glibc using it? licensing?
[20:17:04] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[20:17:10] <cmr> heftig: their malloc is simpler
[20:17:25] <cmr> apparently simplicity > perf for them
[20:17:27] <mark_edward> cool
[20:17:43] <cmr> but it *is* that good, 10x faster for some things
[20:17:45] <brendanc> could probably get you a 2x speedup in that benchmark by setting initial stack size to 384 bytes :)
[20:18:27] <tedh> the commit message sounded like this was not permanent, and there was some talk of smaller initial, then larger increments
[20:18:46] <cmr> tedh: it will be entirely configurable
[20:18:56] <cmr> including disabling segmented stacks altogether
[20:19:03] <brendanc> I think we currently want at least 2MB default for libc calls
[20:19:26] <cmr> brendanc: don't we do a 2MiB alloc for FFI anyway, regardless of how much free space is on the current stack?
[20:19:27] <brendanc> but anything over 4k is going to be the same cost for your particular benchmark
[20:19:28] <heftig> cmr: but segmented stacks will remain the default choice, even on 64-bit platforms?
[20:19:32] <cmr> heftig: no
[20:19:46] <cmr> heftig: opt-in on 64-bit
[20:19:55] <heftig> oh, okay.
[20:20:08] <tedh> opt-in per process or per taks?
[20:20:14] <cmr> per scheduler I think
[20:20:17] <brendanc> gotta run now, sorry
[20:20:19] <cmr> might be per-task
[20:20:20] <heftig> i suppose overcommit by the kernel will keep memory usage in line, with many tasks?
[20:20:21] <cmr> definitely not per-process
[20:20:32] <cmr> heftig: yep
[20:20:40] <tedh> ok, cool
[20:21:50] <cmr> poiru: https://github.com/mozilla/rust/pull/7775
[20:21:54] <cmr> poiru: You are my hero!
[20:22:19] * cmr been wanting to do that for awhile
[20:23:34] <Eridius> we really added macros just for println(fmt!(...))?
[20:23:44] <Jeaye> Looks like it.
[20:23:56] <cmr> Eridius: it saves three characters and a nested layer or parens
[20:24:01] * cmr thinks it's useful
[20:24:07] <Jeaye> I think it's a good idea.
[20:24:08] <Eridius> totally worth adding to the global namespace of things
[20:24:24] <cmr> Well it's not like anything else can use the name anyway
[20:24:36] <cmr> Once we have exportable macros it'll be fine
[20:24:38] <Eridius> why not? Why can't I write my own print!() in my program
[20:25:06] <cmr> rusti: macro_rules! fmt ()
[20:25:07] -rusti- <anon>:1:0: 1:0 error: Unexpected end of macro invocation
[20:25:07] -rusti- <anon>:1 #[allow(default_methods)];
[20:25:07] -rusti-          ^
[20:25:07] -rusti- application terminated with error code 101
[20:25:11] <cmr> rusti: macro_rules! fmt ();
[20:25:12] -rusti- <anon>:1:0: 1:0 error: Unexpected end of macro invocation
[20:25:12] -rusti- <anon>:1 #[allow(default_methods)];
[20:25:12] -rusti-          ^
[20:25:12] -rusti- application terminated with error code 101
[20:25:17] <cmr> rusti: macro_rules! fmt { };
[20:25:17] -rusti- <anon>:7:26: 7:27 error: expected `(` but found `{`
[20:25:17] -rusti- <anon>:7          macro_rules! fmt { };
[20:25:18] -rusti-                                    ^
[20:25:18] -rusti- application terminated with error code 101
[20:25:35] <SiegeLord> Do those macros work for 0 arguments?
[20:25:51] <Eridius> why would you call them with 0 arguments?
[20:25:54] <SiegeLord> Like println!("Hello world")
[20:26:04] <cmr> Eridius: well you could I guess, I was thinking more of libraries
[20:26:07] <cmr> SiegeLord: yes
[20:26:13] <cmr> at least, fmt does
[20:26:35] <Jeaye> Eridius: println for just a blank line
[20:26:46] *** Joins: Archaeopteryx (itsme@moz-9E1DCD04.cust.telecolumbus.net)
[20:26:48] <Eridius> no point in using the macro though when you have the function
[20:26:49] <SiegeLord> rusti: println(fmt!("Test",));
[20:26:50] -rusti- <anon>:7:28: 7:29 error: unexpected token: `<eof>`
[20:26:50] -rusti- <anon>:7          println(fmt!("Test",));
[20:26:50] -rusti-                                      ^
[20:26:50] -rusti- application terminated with error code 101
[20:26:51] <cmr> Eridius: dbg!() to insert a breakpoint
[20:27:32] <Eridius> the new print!() and println!() macros won't accept 1 argument
[20:27:37] <SiegeLord> Is that not what that println!("Test") will expand to?
[20:27:38] <Eridius> I think
[20:27:57] <Eridius> from reading the other macros, the 1-argument case is defined separately from the multi-argument case
[20:28:25] <Eridius> in fact, that's a reasonable thing to do here: make the 1-argument case print with %?
[20:28:30] <Eridius> so I could then say println!(myvec)
[20:28:38] <cmr> mm, that's very reasonable
[20:28:47] <cmr> that's what I want 99.8% of the time
[20:29:22] <SiegeLord> rusti: print(fmt!("%?", "Test"));
[20:29:24] -rusti- "Test"()
[20:29:33] <SiegeLord> I don't think that's reasonable
[20:29:59] <Eridius> SiegeLord: if you want to print a string, don't use the macro
[20:30:04] <Eridius> the macro is for printing formatted args
[20:30:12] <SiegeLord> It makes you have to write println!("%s", "Test"); which defeats the purpose of a single argument
[20:30:22] <SiegeLord> *single argument specialization
[20:30:22] <Eridius> SiegeLord: no, it makes you write println("Test") like any sane person
[20:31:00] <mark_edward> cmr: RFC:  introduced ${expr} expression that uses the ToStr trait to stringify the value of said expression
[20:31:00] *** Quits: geomyidae__ (uid214@moz-E77DEB21.irccloud.com) (Quit: Connection closed for inactivity)
[20:31:02] <SiegeLord> There's nothing sane about that
[20:31:04] <mark_edward> cmr: demo https://gist.github.com/MarkJr94/5992105
[20:31:13] <SiegeLord> In C you can use printf for formatted and non-formatted output
[20:31:19] <SiegeLord> Do you use puts in C to print strings?
[20:31:20] <Eridius> SiegeLord: there's nothign sane about using the real function instead of the macro wrapper?
[20:31:24] <Eridius> SiegeLord: are you a crazy person?
[20:31:40] <SiegeLord> Got off the wrong bed, Eridus?
[20:31:48] <SiegeLord> What's with the attitude
[20:31:48] <cmr> SiegeLord: also %? does all sorts of crazy reflection
[20:31:52] <Eridius> SiegeLord: no, I literally think you're being insane here
[20:31:54] <cmr> not what you want to be doing just for a string
[20:32:19] <tjc> folks, let's keep the "friendly, safe and welcoming environment for all" part of the code of conduct
[20:32:20] <Eridius> you're seriously advocating that people should use a macro based around fmt in order to print a simple string, instead of using the function the macro is based on
[20:32:22] <SiegeLord> You can get the reflection you want by doing println!("?", myvec);
[20:32:43] <tjc> which includes not using "sane"/"crazy" to mean "good"/"bad"; that's not welcoming of people like me who have mental health issues
[20:32:45] <SiegeLord> *"%?"
[20:33:01] <Eridius> tjc: I'm sorry
[20:33:09] <tjc> Eridius: no worries, just keep it in mind in the future
[20:33:16] <Eridius> SiegeLord: why do you think anyone would ever write println!("foo") instead of println("foo")?
[20:33:40] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[20:33:49] <cmr> Should I consider changes like https://github.com/mozilla/rust/pull/7578 breaking changes for TWiR?
[20:34:03] <SiegeLord> I do that in D all the time
[20:34:11] <SiegeLord> I use the same function for formatted and non-formatted output
[20:34:22] *** Quits: dwhyte (dwhyte@ED9190FB.B72E355F.7BF4A4B0.IP) (Client exited)
[20:34:27] <tjc> cmr: it's certainly a breaking change, but I'm not sure how often people run into it
[20:34:32] <Jeaye> Eridius: They will.
[20:34:41] <Eridius> SiegeLord: this is not equivalent to people saying printf("foo\n")
[20:34:51] *** Joins: scanlonman (scanlonman@moz-169BC238.hsd1.wa.comcast.net)
[20:35:10] <cmr> tjc: I think I'm just going to delegate it to the `libraries` section, not important enough to be at the top of the list imo...
[20:35:11] <Eridius> Jeaye: they won't do it intentionally, and they'll discover what happens if they do it by accident
[20:35:21] <Jeaye> Eridius: println!() will become the defacto line printing mechanism and println() will become an under-the-hood type function. This is simply for consistency.
[20:35:38] <Eridius> Jeaye: why do you say that? There's no reason for println!() to become a defacto line printing mechanism at all
[20:36:05] <Eridius> you can't pass a variable as the first arg of fmt!()
[20:36:16] <Jeaye> This is a problem.
[20:36:25] <Eridius> no it's not
[20:36:27] <Jeaye> With println!()
[20:36:41] <SiegeLord> Well, there's a warning in passing a variable as a first argument to printf as well
[20:36:59] <SiegeLord> Doesn't change the fact that people still do printf("");
[20:37:01] <Jeaye> I think the coexistence of println!() and prinln() should not be welcomed. We should primarily be using one or the other.
[20:37:30] <Eridius> Jeaye: println!() is just a wrapper around passing a formatted-string to println(). This does not make println() obsolete
[20:37:40] <Eridius> if you don't want a formatted string, you should not be using println!(). it's that simple
[20:38:09] <Jeaye> I know what println!() is, I'm just saying that having that distinction is unhealthy.
[20:38:17] <kimundi> println!() should simply be named printlnf!()
[20:38:24] <Jeaye> If we want them as separate things, they should be called separate things. Such is the Rust way.
[20:38:27] <Eridius> having a distinction between formatted and unformatted? Or just having multiple ways to write to stdout? Because we already have multiple ways
[20:38:35] <tjc> cmr: oh, and thanks for reviewing #7749 -- I made the changes you suggested and am rebuilding
[20:38:37] <Eridius> kimundi: that's a good idea
[20:38:40] <cmr> tjc: np
[20:38:41] <Jeaye> We don't have function overloading for this exact reason.
[20:39:02] <Eridius> printf!() and printlnf!()
[20:39:13] <cmr> I'd be ok with that too
[20:39:20] <cmr> But I honestly don't think it's worth all this bikeshedding
[20:39:32] <kimundi> then it's clear that they do more than regular print and println
[20:39:40] <Eridius> cmr: this is why I would have been against the macros from the start
[20:39:50] <Jeaye> Eridius: That's much better, and covers my argument.
[20:40:00] <Eridius> all hail kimundi, the great unifier :)
[20:40:04] <kimundi> xD
[20:41:42] * Eridius is making the change locally and testing
[20:41:53] *** Joins: paupau (posttext@moz-BFE94859.hfc.comcastbusiness.net)
[20:42:31] <SiegeLord> I don't really see how changing the name makes the default "%?" ok, but looks like it's just me :P
[20:42:46] <Eridius> SiegeLord: the new name makes it obvious that it's always formatted
[20:43:12] <Eridius> this also makes it consistent with other macros like info!()
[20:43:20] <Eridius> which treat a single arg as formatted with %?
[20:43:28] <cmr> 9 breaking changes this week, and they were all the result of cleanup or removing invalid behavior.
[20:43:33] <cmr> \o/
[20:44:01] <kimundi> rusti: fail!("foo");
[20:44:02] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/QNNC
[20:44:16] <kimundi> rusti: if true {fail!("foo");}
[20:44:17] -rusti- rust: task failed at 'foo', <anon>:7
[20:44:17] -rusti- rust: domain main @0x10151b0 root task failed
[20:44:17] <paupau> is copy fully gone now?
[20:44:17] -rusti- application terminated with error code 101
[20:44:40] <kimundi> paupau: afaik the PR for that has not landed yetf
[20:44:45] <cmr> paupau: not yet, hasn't landed
[20:44:52] <cmr> on the top of the queue, in fact
[20:45:29] <paupau> ah I see it
[20:46:05] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[20:46:32] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[20:46:32] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14897ff8b to 148d0feb5: 02http://git.io/N3iJvQ
[20:46:32] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[20:46:36] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[20:46:36] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/KNOaNQ
[20:46:36] <ghrust> 13rust/06auto 14dc6829c 15Tim Chevalier: rustpkg: Implement `uninstall` and `list` commands
[20:46:36] <ghrust> 13rust/06auto 14aae676f 15bors: auto merge of #7749 : catamorphism/rust/rustpkg-list-uninstall, r=cmr...
[20:46:36] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[20:47:05] <steven_is_false> I know heap once functions are being allowed in the standard library but they don't seem to be enabled. Is this just an oversight, or do I need to set some kind of pragma or something?
[20:47:17] <SiegeLord> Well, it's ok... once %? is gone it'll be all good anyway :P
[20:47:56] <paupau> say, in Rc<T>::drop, what does ptr::read_ptr(self.ptr); accomplish?
[20:48:21] <SiegeLord> And hopefully it's replacement will not keep the same output...
[20:48:34] <SiegeLord> *its
[20:48:48] <cmr> steven_is_false: -Z once-fns?
[20:48:53] *** Quits: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net) (Ping timeout)
[20:49:12] <paupau> rusti: print!("hello %d", 1);
[20:49:12] -rusti- <anon>:7:9: 7:14 error: macro undefined: 'print'
[20:49:12] -rusti- <anon>:7          print!("hello %d", 1);
[20:49:12] -rusti-                   ^~~~~
[20:49:12] -rusti- application terminated with error code 101
[20:49:14] <steven_is_false> cmr: right but I'm trying to use it in the extra library.
[20:49:29] <cmr> steven_is_false: ah, good luck :\
[20:49:37] <cmr> steven_is_false: could add it to the makefiles? not sure anyone would object
[20:49:42] <steven_is_false> Okay
[20:49:47] <cmr> I think #[allow(once_fns)] might do it too?
[20:51:45] <steven_is_false> cmr: I don't think it's made it into the snapshot yet.
[20:51:51] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[20:51:55] <cmr> Ah, bugger
[20:51:58] <kimundi> paupau: That's a very good question
[20:52:34] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[20:52:34] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14aae676f to 148d0feb5: 02http://git.io/N3iJvQ
[20:52:34] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[20:52:35] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[20:52:35] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/ITROZg
[20:52:35] <ghrust> 13rust/06auto 141a46afb 15Tim Chevalier: rustpkg: Implement `uninstall` and `list` commands
[20:52:35] <ghrust> 13rust/06auto 14563172a 15Tim Chevalier: rustpkg: Address review comments from cmr
[20:52:35] <ghrust> 13rust/06auto 1472385df 15bors: auto merge of #7749 : catamorphism/rust/rustpkg-list-uninstall, r=catamorphism...
[20:52:37] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[20:53:17] <kimundi> paupau: My only guess that it causes some codegen that optimizes better... But I really have no idea. Ask strcat if he gets on
[20:53:46] <paupau> kimundi: hmm ok. I don't even understand what read_ptr really accomplishes TBH
[20:54:00] <kimundi> paupau: Me neither
[20:54:17] <paupau> fn read_ptr<T>(src: *mut T) -> T
[20:54:21] <paupau> means....
[20:54:37] <paupau> raw mutable to stack object?
[20:54:45] <cmr> mutable raw pointer to anything
[20:54:49] <cmr> oh
[20:54:54] <cmr> returns a value, yes
[20:54:59] <cmr> where the value goes is up to the caller
[20:55:12] <paupau> hmm ok
[20:55:18] <cmr> (ie, it skips storing it on the stack and stores it directly in the destionation for ~read_ptr(foo), afaik)
[20:55:20] <steven_is_false> Should I use #[allow(missing_doc)] or #[warn(missing_doc)] (I know preferable I should leave it at deny but sometimes that is not possible?)
[20:55:44] <cmr> steven_is_false: imo warn, at this point
[20:55:51] <steven_is_false> cmr: Thanks.
[20:55:53] <heftig> does TLS have its own memory areas and allocators?
[20:55:54] <Eridius> just document it!
[20:55:55] <cmr> I wouldn't hold back an r+ because of that though
[20:56:00] <cmr> heftig: no
[20:56:12] <cmr> heftig: ah, actually, maybe..
[20:56:44] <kimundi> Someone here who can explain what happens here? https://github.com/mozilla/rust/blob/master/src/libstd/ptr.rs#L206
[20:57:05] <heftig> i guess that would be an optimization, if the allocator wouldn't need to worry about thread-safety
[20:57:23] <paupau> reads the pointer... I guess that makes sense.
[20:57:31] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[20:57:46] <cmr> Isn't the docs wrong though?
[20:57:51] <cmr> It definitely copies *src?
[20:58:47] <kimundi> cmr: Yeah, that's what I'm thinking
[20:59:00] <cmr> ask strcat, he knows of such deep magick :p
[20:59:10] <paupau> maybe inlining + llvm intrinsic memcpy guarantees that it's just a pointer move
[20:59:11] *** Joins: dwhyte (dwhyte@ED9190FB.B72E355F.7BF4A4B0.IP)
[20:59:12] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[20:59:13] <paupau> how roundabout
[20:59:21] <kimundi> It reads a value, copis it... And then discards it here: https://github.com/mozilla/rust/blob/master/src/libextra/rc.rs#L70
[20:59:58] <cmr> maybe it's needed to call the destructor on self.ptr, because you can't actuall call drop yourself yet?
[21:00:15] <cmr> wait not sure that makes sense...
[21:00:18] <paupau> oh, tricky
[21:00:20] <kimundi> hmmmm
[21:00:31] <cmr> iunno
[21:00:33] <kimundi> that could it be
[21:00:33] <cmr> it's confuzzling
[21:00:35] <paupau> reading it brings it into the stack and it's immediately dropped
[21:00:44] <paupau> so it can be freed
[21:00:49] <paupau> needs a comment ;P
[21:00:54] <cmr> if that's what it actually does!
[21:01:20] *** Quits: pyrac (pyrac@moz-F2C67F88.w83-114.abo.wanadoo.fr) (Quit: pyrac)
[21:01:29] <kimundi> still... the copy seems bad, somehow. But then again it's just a shallow copy, so...
[21:03:08] <kimundi> Okay, I concluded that, while it looks strange, and the doc on read_ptr is wrong/very confusing, the code itself does the right thing
[21:05:22] <paupau> cool
[21:05:30] *** Quits: steven_is_false (user@moz-144077DE.bchsia.telus.net) (Client exited)
[21:06:18] <paupau> man, the docs for std::cast read like an ancient forgotten spellbook or something
[21:07:26] *** Joins: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net)
[21:07:37] <paupau> if you were living in the Rust matrix, and were to stumble across those fns...
[21:09:38] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[21:10:08] <Eridius> cmr: https://github.com/mozilla/rust/pull/7779
[21:10:23] <paupau> fn foo() -> Foo { let foo = Foo(); unsafe { hold_onto(&foo); }; foo } will always end up with a dangling pointer right?
[21:11:12] <kimundi> what's the tdefinition of hold_onto?
[21:12:00] <paupau> kimundi: s/hold_onto(&foo)/self.list.push(&foo)/
[21:12:07] <paupau> uhh
[21:12:12] <paupau> something horribly unsafe, anyway
[21:12:22] <paupau> I'm trying to implement a weak Rc pointer
[21:13:07] <paupau> I'm trying to figure out if I can keep pointers to WeakRef{}s around using unsafe code so I can invalidate them later
[21:14:05] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[21:14:47] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Ping timeout)
[21:14:54] *** Joins: cubic_ (cubic@moz-FE5AD6C7.mc.videotron.ca)
[21:15:30] *** Quits: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca) (Ping timeout)
[21:15:35] <kimundi> paupau: well storing a stackpointer of a function that has returned is never a good idea
[21:16:57] <paupau> kimundi: hmm yeah
[21:16:57] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[21:17:37] <paupau> kimundi: I'm wondering though, if it's inlined, and I have a custom drop() for it that removes the pointer to itself from that list... maybe it could work?
[21:19:59] <cmr> glinscott: "93% faster json parsing" is truly wonderful to include in twir :)
[21:20:52] <kimundi> paupau: Uh, _what_ could work?
[21:23:19] <paupau> kimundi: weak pointers for Rc<T>. Just going to hack at it for awhile and then post it when I've got something that "works"
[21:25:03] *** Joins: pnathan (Adium@moz-BDC3EE62.tukw.qwest.net)
[21:26:11] *** Quits: cr (anonymous@moz-3EF5FF9F.dip0.t-ipconnect.de) (Ping timeout)
[21:27:46] *** Quits: dwhyte (dwhyte@ED9190FB.B72E355F.7BF4A4B0.IP) (Client exited)
[21:29:00] *** Joins: eatkinson (eatkinson@moz-AD233F1B.dia.static.qwest.net)
[21:31:56] *** Joins: pcwalton (pcwalton@moz-BBE3ABD.mv.mozilla.com)
[21:31:56] *** ChanServ sets mode: +o pcwalton
[21:32:11] <Eridius> kimundi, cmr: pcwalton just suggested printfln!(). I'm inclined to agree with him. Thoughts?
[21:32:26] <cmr> sure
[21:32:34] <cmr> I have no strong opinion on it tbh
[21:32:41] <pcwalton> does anyone know what usually causes the "application has requested the runtime to terminate it in an unusual way" errors on windows
[21:32:44] <pcwalton> on rpass
[21:32:48] <Eridius> bikeshedding at its finest :)
[21:33:06] * pcwalton is very unhappy that his patch bounced with a mysterious windows crash
[21:33:25] <Eridius> pcwalton: do you know anything about the overuse of open fds in the test suite? Most of them are PIPEs
[21:33:30] <Eridius> https://github.com/mozilla/rust/issues/7772
[21:33:31] *** Joins: echristo (echristo@2ABF3B40.D6CCE4AE.77834EAA.IP)
[21:33:50] <pcwalton> I think brson noticed it too
[21:34:00] <pcwalton> I don't really know what causes it
[21:34:05] <Eridius> I can't run the testsuite on OS X anymore without specifying RUST_TEST_THREADS or RUST_THREADS
[21:34:35] *** Quits: Ubaion (Archer@moz-DA478E33.bb.online.no) (Ping timeout)
[21:34:57] *** Quits: echristo (echristo@2ABF3B40.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[21:35:21] <jack> Eridius: just bump your max fds.
[21:35:55] <Eridius> jack: that's not a general solution
[21:37:24] *** Joins: pnathan1 (Adium@B9840254.2CD8A5F8.477B877D.IP)
[21:37:32] <jack> no, but from the amount o fdiscussoin i've seen it seems to be blocking you. so that would fix it until someone can correct whatever bug there is. `sudo sysctl -w kern.maxfiles=65536` and `sudo sysctl -w kern.maxfilesperproc=30000` or something similiar should bump up the limits.
[21:37:55] <cmr> TWiR: http://cmr.github.io/blog/2013/07/13/this-week-in-rust/
[21:38:01] <Eridius> jack: well like I said I can set RUST_TEST_THREADS=4 to restore the old behavior (it doesn't overrun the limit with only 4 threads)
[21:38:03] <cmr> Feedback before I splat it over the interwebs?
[21:38:13] *** Joins: olleharstedt (Thunderbir@moz-80D8890F.ias.bredband.telia.com)
[21:38:22] <sigma> cmr: this is my chance to ninja some reddit karma then?
[21:38:24] <Eridius> but the fact that I'm overrunning at all points at a deeper issue. there's no reason why 16 threads should use up that many fds
[21:39:24] <Eridius> cmr: the TLS cleanup isn't quite complete yet. There's another PR #7751 that does a bit more, including changing the type of Key
[21:39:37] <Eridius> just saying because your first entry suggests the cleanup is complete
[21:39:45] <glinscott> cmr: awesome :).  measuring on current master, i have 100 parses of example.json at 0.39s from string.  0.75s from file.  both were ~25.5s before any of the patches
[21:39:48] <Eridius> although hopefully #7751 will be merged today
[21:41:27] *** Quits: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net) (Ping timeout)
[21:41:36] *** Quits: pnathan (Adium@moz-BDC3EE62.tukw.qwest.net) (Quit: Leaving.)
[21:41:57] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Ping timeout)
[21:42:41] <sigma> hmm, how good a template would the approach json.rs be to writing an xml parser? I'm considering writing one as a toy project since I've never written a parser from scratch before
[21:42:47] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[21:42:51] <sp3d> cmr: typo on "deque good a cleanup"
[21:42:54] <Eridius> cmr: also, mentioning the print! and println! macros might be slightly confusing if my PR gets merged in that renames them
[21:43:00] *** Quits: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Quit: Don't tell them I was here...)
[21:43:14] <Eridius> cmr: so you may want to put in a parenthetical that links to the PR
[21:43:29] <sigma> I don't see any excessive use of @... so my "nope, don't learn from this code" warning isn't going off
[21:43:45] *** Quits: pnathan1 (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[21:44:10] <cmr> sigma: if you want to, sure
[21:44:31] <cmr> sigma: wait till I get a chance to fix it though :p
[21:45:22] <sigma> cmr: I can have a read at it and not horribly pollute my mind though, that's all I needed to know
[21:45:39] <cmr> sigma: I meant re: reddit karma
[21:45:51] <sigma> ahh, nah, that was a joke :)
[21:46:26] <cmr> json isn't... too bad
[21:47:03] <cmr> Probably not suitable for an XML parser
[21:49:08] *** Quits: heftig (heftig@moz-9E6A235D.dip0.t-ipconnect.de) (Ping timeout)
[21:51:20] <sigma> yeh, just been reading through it, I'd need a lot of nested matches. Might go for a straight up state machine... Time to work out how to represent that in the type system
[21:51:43] *** Quits: Ms2ger (Ms2ger@3F038EB7.1AB48F49.F15B0BB3.IP) (Quit: nn)
[21:52:31] <cmr> https://github.com/mozilla/rust/blob/master/src/libextra/terminfo/parm.rs is an example of a simple state machine parser/interpreter
[21:52:45] <cmr> Well, "simple" in that it's small, but still non-trivial.
[21:53:01] <sigma> oo, thanks
[21:56:05] <kimundi> sigma: Other state machine example: https://github.com/mozilla/rust/blob/master/src/libstd/str.rs#L431
[21:56:44] *** Quits: olleharstedt (Thunderbir@moz-80D8890F.ias.bredband.telia.com) (Ping timeout)
[21:57:51] <sigma> kimundi: thanks, I've got some reading to do
[21:58:52] *** Joins: heftig (heftig@moz-E3C1316C.dip0.t-ipconnect.de)
[22:02:37] *** Quits: tjc (tjc@moz-CDF09112.hsd1.wa.comcast.net) (Quit: zzzzzzzzzz)
[22:04:41] *** Quits: Archaeopteryx (itsme@moz-9E1DCD04.cust.telecolumbus.net) (Quit: It has been this message for years.)
[22:05:59] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[22:05:59] *** Quits: glinscott (garylinsco@789A6618.53EB7C1.FFFE3AA.IP) (Ping timeout)
[22:06:52] *** Joins: glinscott (garylinsco@789A6618.53EB7C1.FFFE3AA.IP)
[22:07:25] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[22:09:07] *** Quits: paupau (posttext@moz-BFE94859.hfc.comcastbusiness.net) (Ping timeout)
[22:11:52] *** Joins: tjc (tjc@moz-7341F399.tmodns.net)
[22:11:52] *** ChanServ sets mode: +o tjc
[22:13:01] *** Joins: MaikKlein (maik@moz-C7D2933.dip0.t-ipconnect.de)
[22:13:19] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[22:13:30] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[22:14:57] * jensnockert hugs cmr for doing an awesome work on 'This week in Rust'
[22:15:26] *** Quits: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net) (Input/output error)
[22:15:27] <bjz_> yay
[22:15:31] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[22:16:13] <bjz_> cmr: hopefully lmath will be finished by next week so you can add it in there
[22:16:27] * bjz_ thinks "who an I kidding"
[22:16:57] <cmr> bjz_: yourself, apparently :p
[22:17:05] <bjz_> obviously
[22:17:07] <bjz_> :)
[22:18:17] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[22:18:33] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[22:18:33] *** ChanServ sets mode: +o dherman
[22:21:14] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[22:23:17] *** Quits: MaikKlein (maik@moz-C7D2933.dip0.t-ipconnect.de) (Ping timeout)
[22:27:37] <pcwalton> bjz_: does lmath subsume the functionality of rust-geom?
[22:27:44] <pcwalton> it would be nice to just switch servo over to lmath
[22:27:51] <bjz_> pcwalton: it's getting close
[22:27:54] <pcwalton> cool
[22:28:03] *** Joins: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net)
[22:28:05] <bjz_> pcwalton: I'll also have colors soon
[22:28:20] <bjz_> pcwalton: which might be useful for CSS, I don't know
[22:28:47] <bjz_> pcwalton: but yeah, it's getting to the stage were I'm feeling better about showing it off
[22:28:57] <bjz_> it was pretty ugly for a time
[22:29:02] <pcwalton> nice :)
[22:29:21] <bjz_> there are things that could be improved with default methods
[22:29:40] <bjz_> and if we could impl on generic fixed length vecs
[22:30:00] <bjz_> like: impl<T, LEN: uint> Container for [T,..LEN]
[22:30:02] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[22:30:09] <pcwalton> yeah
[22:30:13] <pcwalton> well, default methods are mostly working now I think
[22:30:22] <bjz_> yeah I broke them
[22:30:27] <pcwalton> oh
[22:30:29] <bjz_> predictably
[22:30:30] <bjz_> :D
[22:30:31] <pcwalton> even with sully's fixes?
[22:30:44] <bjz_> sully has some fixes he needs to make
[22:30:48] <pcwalton> oh ok
[22:31:01] <bjz_> that he thought weren't going to be used much or very important
[22:31:26] <bjz_> and of course, predictably, lmath does its best to be annoying
[22:31:29] <bjz_> :)
[22:31:37] <cmr> you core developer types seem to make that incorrect assumption too often ;)
[22:31:39] * pcwalton is building rust in a win8 VM in hopes of reproducing the problem
[22:31:44] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[22:31:57] <bjz_> but it works - it's just there's quite a bit of code duplication
[22:32:00] <bjz_> cmr: :)
[22:32:03] *** Quits: dew (Instantbir@moz-66796D51.dhcp.stls.mo.charter.com) (Ping timeout)
[22:32:29] <bjz_> pcwalton: I tried doing everything with macros but that ended badly
[22:32:41] <bjz_> pcwalton: took me several weeks to untangle it :P
[22:32:49] *** Joins: echristo (echristo@2ABF3B40.D6CCE4AE.77834EAA.IP)
[22:34:23] <bjz_> pcwalton: but yeah, I would really like to battle harden it
[22:34:34] <pcwalton> ugh, autoconf is miserable on windows
[22:34:39] <bjz_> :(
[22:34:46] <cmr> it sure is!
[22:34:48] * jensnockert hugs pcwalton and the vm.
[22:35:00] <pcwalton> the whole thing depends on fork() and sh
[22:35:04] * bjz_ pats the vm on the head
[22:37:42] * bjz_ heads out for a morning coffee
[22:40:22] * kimundi heads for an evening hot chocolate
[22:41:38] <cmr> http://rustlog.octayn.net/post/55373010614/status-update, out for night, cya
[22:43:02] *** Quits: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net) (Client exited)
[22:44:55] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[22:51:57] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[22:51:58] *** Quits: tjc (tjc@moz-7341F399.tmodns.net) (Quit: zzzzzzzzzz)
[22:58:08] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[22:59:51] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[23:00:52] <bjz_> pcwalton: how goes the battle?
[23:00:59] <pcwalton> building llvm
[23:01:04] <bjz_> x]
[23:01:44] *** Joins: igl (igl@moz-95C07C6D.adsl.alicedsl.de)
[23:01:48] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[23:02:10] <pcwalton> someone should write a "mini-LLVM" that goes straight from LLVM IR to machine code in as small of a library as possible
[23:02:16] <pcwalton> exposing the LLVM C API
[23:02:28] <pcwalton> that would be fun and would let us compete with Go directly on compilation speed
[23:02:37] <bjz_> pcwalton: if we did have the ability to parameterise traits/types with constants do you reckon we'd be able to use that to implement some kind of 'units of measure' thingy?
[23:02:50] <pcwalton> well, you can already kinda do it with newtypes
[23:02:53] <pcwalton> it's not as powerful as F#
[23:02:59] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[23:03:02] <pcwalton> the F# units paper is a good read, I haven't read it in a while
[23:03:03] <bjz_> yeah, I've tried before
[23:03:14] <bjz_> I wish we could use it for the trig functions
[23:03:42] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[23:03:50] <bjz_> but doing the operations doesn't really work
[23:03:57] *** Joins: dew (Instantbir@moz-66796D51.dhcp.stls.mo.charter.com)
[23:05:08] <bjz_> measure * scalar -> measure, measure * measure -> measure^2, measure/measure -> measure ^-1, measure + measure, measure^2 + measure^2
[23:05:15] <bjz_> pcwalton: ^
[23:05:27] <pcwalton> oh, ok
[23:05:32] <pcwalton> yeah, I think you need F# style units for that
[23:05:38] <pcwalton> have you seen the F# units paper?
[23:05:50] <bjz_> no, but I know F#'s units of measure
[23:06:24] <bjz_> I also wonder if we could use constant parametrisation for mod and range types
[23:07:31] <bjz_> mod_type!(WrappedDegrees % 360)
[23:08:00] <pcwalton> http://research.microsoft.com/en-us/um/people/akenn/units/
[23:08:44] <bjz_> pcwalton: I just really hate putting 'units in radians' in doc comments
[23:08:59] <bjz_> pcwalton: I know it's a 'pet feature' though
[23:09:47] <bjz_> pcwalton: http://fsharpforfunandprofit.com/posts/units-of-measure/
[23:10:20] <bjz_> pcwalton: but I definitely think in terms of safety... that mars probe
[23:10:39] <bjz_> inches vs mm
[23:10:47] <bjz_> *facepalm*
[23:16:53] *** Quits: thpickert (thpickert@moz-99F22CD3.dynamic.dsl.tng.de) (Quit: thpickert)
[23:16:56] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[23:17:32] <SiegeLord> I don't know if that specific bug could have been prevented via this
[23:18:13] <bjz_> pcwalton: range_type!(Channelf64(float) = 0.0 - 1.0)
[23:18:29] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[23:19:01] <bjz_> pcwalton: actually, I think that might be possible today
[23:19:10] <steven_is_false> Hi! I'm still working on refactoring extra::arc, and extra::sync, and I want to export private types as publi but it doesn't seem to work.
[23:19:36] <bjz_> pcwalton: not sure how you'd do it efficiently though
[23:19:43] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[23:19:45] <pcwalton> steven_is_false: file a bug
[23:19:57] <bjz_> pcwalton: http://stackoverflow.com/questions/16160717/how-does-ada-implement-mod-and-range-types-what-are-the-performance-implica
[23:19:57] <pcwalton> there are still some weirdnesses around privacy because the resolve->privacy transition is not completed yet.
[23:20:05] <steven_is_false> pcwalton: So it's a bug that this doesn't work http://pastebin.mozilla.org/2627821 ?
[23:20:24] <pcwalton> steven_is_false: yeah, that's a bug.
[23:20:32] <steven_is_false> Thanks. I will.
[23:20:34] <SiegeLord> I think my unit related bugs were related to pixel->physical unit conversion
[23:20:35] <pcwalton> I know what the bug is too and how to fix it, just haven't had time
[23:20:42] <bjz_> pcwalton: not sure how you'd handle floating point values though
[23:20:53] <bjz_> (efficiently)
[23:20:56] <pcwalton> SiegeLord: we have a lot of those in Gecko. Servo tries to fix it by defining a newtype for page coordinates.
[23:21:44] <Luqman> is there a way to not have the build delete old libraries as it builds?
[23:25:07] <pcwalton> Luqman: no idea, IIRC pnkfelix added that.
[23:25:24] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[23:25:30] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[23:25:50] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[23:27:40] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[23:28:20] <Luqman> pcwalton: hmm maybe it'd better to add to `make clean` since sometimes it's nice not having to wait to rebuild libstd when i want to test something with stage1 rustc
[23:29:27] *** Joins: MaikKlein (maik@moz-C7D2933.dip0.t-ipconnect.de)
[23:30:25] <bjz_> jensnockert: ping
[23:30:42] <bjz_> MaikKlein: maths lib is coming along
[23:31:03] <bjz_> MaikKlein: much easier to understand now
[23:31:21] <bjz_> MaikKlein: trying to add doc comments and stuff
[23:31:21] *** Quits: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com) (Ping timeout)
[23:32:10] *** Quits: echristo (echristo@2ABF3B40.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[23:34:37] *** Joins: samx (sami@moz-48EC0983.dyn.optonline.net)
[23:35:16] *** Quits: samx (sami@moz-48EC0983.dyn.optonline.net) (Quit: Leaving)
[23:35:24] *** Joins: samx (sami@moz-48EC0983.dyn.optonline.net)
[23:36:47] *** Quits: MaikKlein (maik@moz-C7D2933.dip0.t-ipconnect.de) (Ping timeout)
[23:37:33] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[23:38:27] <bjz_> is concat_idents working yet?
[23:38:45] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[23:41:16] *** Quits: samx (sami@moz-48EC0983.dyn.optonline.net) (Quit: This computer has gone to sleep)
[23:41:57] *** Joins: olleharstedt (Thunderbir@moz-80D8890F.ias.bredband.telia.com)
[23:42:04] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Ping timeout)
[23:42:17] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[23:45:06] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[23:46:18] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[23:47:42] *** Joins: echristo (echristo@2ABF3B40.D6CCE4AE.77834EAA.IP)
[23:47:47] *** Quits: KindOne (KindOne@moz-BD665EC4.dynamic.ip.windstream.net) (Connection reset by peer)
[23:48:37] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[23:48:53] *** Joins: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net)
[23:53:25] *** Joins: KindOne (KindOne@moz-BD665EC4.dynamic.ip.windstream.net)
[23:54:27] <pcwalton> building rustc.dll -- let's see if it has enough ram
[23:54:36] *** Joins: samx (sami@moz-48EC0983.dyn.optonline.net)
[23:58:31] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[23:58:55] <Ralith> just how much does it take?

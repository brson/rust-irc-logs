[01:40:17] *** Quits: bluss (bluss@moz-ec5o68.cust.bredbandsbolaget.se) (Ping timeout: 121 seconds)
[02:42:45] *** Quits: Rym (uid91135@moz-n2i7qm.charlton.irccloud.com) (Quit: Connection closed for inactivity)
[02:51:45] *** Quits: kimundi (kimundi@moz-lav8m7.nhp5.i6et.57bc.2002.IP) (Ping timeout: 121 seconds)
[02:57:32] *** Joins: kimundi (kimundi@moz-6j1fee.ufnp.bi9d.4fe2.2002.IP)
[06:13:04] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[06:23:16] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[08:05:52] *** Joins: bluss (bluss@moz-ec5o68.cust.bredbandsbolaget.se)
[09:41:33] *** Joins: nagisa (nagisa@moz-8t068g.static.zebra.lt)
[10:05:01] *** Joins: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua)
[10:21:51] *** Quits: bluss (bluss@moz-ec5o68.cust.bredbandsbolaget.se) (Quit: Lost terminal)
[10:56:11] *** Quits: kimundi (kimundi@moz-6j1fee.ufnp.bi9d.4fe2.2002.IP) (Ping timeout: 121 seconds)
[10:56:12] *** Joins: kimundi (kimundi@moz-53kd7g.j382.7dkg.4fe2.2002.IP)
[10:57:57] *** Quits: aatch (james@moz-is4j4r.cable.telstraclear.net) (Ping timeout: 121 seconds)
[11:35:11] *** Quits: nagisa (nagisa@moz-8t068g.static.zebra.lt) (Ping timeout: 121 seconds)
[11:54:35] *** Joins: nagisa (nagisa@moz-8t068g.static.zebra.lt)
[12:22:00] *** Quits: kimundi (kimundi@moz-53kd7g.j382.7dkg.4fe2.2002.IP) (Ping timeout: 121 seconds)
[12:27:02] *** Joins: kimundi (kimundi@moz-22fjhj.o533.1q3j.4fe2.2002.IP)
[14:20:22] *** Quits: blank_name (blank_name@moz-p4egrb.mi.frontiernet.net) (Ping timeout: 121 seconds)
[14:20:32] *** Joins: blank_name (blank_name@moz-kdq.fli.183.192.IP)
[18:20:23] *** Quits: blank_name (blank_name@moz-kdq.fli.183.192.IP) (Ping timeout: 121 seconds)
[18:34:34] *** Joins: bluss (bluss@moz-ec5o68.cust.bredbandsbolaget.se)
[19:10:23] <Elaine> Gankro: When will Drain be stabilized?
[19:10:39] <Gankro> Elaine: As soon as someone submits a PR
[19:10:45] <Elaine> Oh!
[19:10:53] <Elaine> Well heck.
[19:11:02] <Elaine> All of the drains?
[19:11:24] <Gankro> Yeah, I think the trait will be unstable still
[19:11:39] <Gankro> Maybe not btreemap if it has it...
[19:11:43] <Elaine> didn't know there was a trait :P
[19:11:51] <Gankro> There's a trait for their input
[19:11:53] <Elaine> I mostly just care about Vec and VecDeque tbh
[19:12:06] <Gankro> They take like RangeArgument or some noise
[19:12:43] <Gankro> HashMap, Vec, and VecDeque are all G2G
[19:12:53] <nagisa> wasnâ€˜t drain unstable because something about performance or safety or something>.
[19:13:08] <Gankro> No?
[19:13:13] <nagisa> ok
[19:14:17] <bluss> Elaine: Gankro: I think we need another RFC to setup drain-range properly for all the collections?
[19:14:32] <Gankro> bluss: Just BTreeMap
[19:14:40] <bluss> since there was concerns about the API
[19:14:45] <bluss> and the range trait, etc
[19:15:11] <bluss> why not linked list, drain(range) makes sense there, and vec deque too
[19:15:12] <Gankro> bluss: this API was acepted as an RFC...
[19:15:21] <Gankro> VecDeque should ahve it...
[19:15:31] <bluss> vecdeque doesn't have drain(range) yet
[19:15:46] <bluss> my expectation has been to work on an rfc for the rest
[19:16:01] <Gankro> Vec and VecDeque have identical semantics
[19:16:03] <bluss> I said I was going to write it last weekend but then I had to go
[19:16:18] <Elaine> Gankro: VecDeque's Drain doesn't do a range.
[19:16:26] <Gankro> Yeah, that's a bug
[19:16:45] <Elaine> I didn't even realize drain-range was a thing... shows how much I do Rust :\
[19:16:50] <bluss> FWIW, I implemented drain when I had different expectations of the rfc process
[19:16:58] <bluss> for example that vecdeque drain(range) would need an rfc
[19:17:07] <Gankro> LinkedList... Drain doesn't make a lot of sense on
[19:17:25] <bluss> Elaine: drain range on vec is awesome, since you can finally remove a range in O(n) ish time
[19:17:29] <Gankro> Cursors are better solution probably
[19:18:42] <Gankro> O(min_index)
[19:21:07] <bluss> one open question about Vec::drain is the Rc refcount overflow question
[19:21:19] <bluss> and what Gankro and nmatsakis called leak amplification
[19:21:26] <Gankro> I disagree that there's a problem
[19:21:33] <bluss> we can solve that with implementation details though
[19:22:08] <bluss> refcount overflow seems to be a serious problem
[19:22:19] <bluss> but ok, it's not blocking the drain API
[19:22:23] <Gankro> I disagree that it's serious
[19:22:33] <Gankro> It's incredibly silly to trigger, even on 32-bit
[19:22:35] <Elaine> Err, refcount overflow leads to user-after-free?
[19:22:44] <Elaine> Yes, but...
[19:22:49] <bluss> I want safe rust to be memory safe Gankro 
[19:23:02] <Gankro> Then submit a PR to saturate the refcount...
[19:25:15] <Gankro> I agree that safe rust should be safe; but I don't feel like "can be triggered by a programmer doing something convoluted, but can't really be coerced by an attacker on a sane program" and "can be easily triggered by a sane program" should be regarded in the same way
[19:25:41] <bluss> that's something very important to decide then
[19:25:45] <Elaine> The best thing about Rust is fearlessness.
[19:26:14] <Elaine> Weakening that should not be taken lightly.
[19:26:29] <bluss> Gankro: thread::scoped as it was was really useful, and safe in almost all use. But with it we couldn't say "if it compiles, it's thread safe"
[19:27:22] <Elaine> We should do refcount saturation anyway though.
[19:27:24] <Gankro> I'm saying this mostly because everyone on the core team I've talked about Rc with is basically completely apathetic about it.
[19:27:29] <bluss> I've been thinking of setting up better tracking of memory safety issues anyway
[19:27:38] <Elaine> Since forget is safe etc
[19:27:39] <bluss> Gankro: that's very sad to hear
[19:28:17] <Elaine> Imagine debugging a use-after-free caused by a long-lived Rc and an accidental leak somewhere.
[19:28:26] <bluss> I fixed BinaryHeap the minute acrichto admitted it was broken, not the other things I used to break memory safety (catching panics)
[19:28:31] <bluss> that was another sign of apathy
[19:32:03] <Elaine> bluss: I like the idea of a better way of tracking memory safety issues.
[19:32:33] <Elaine> I'm curious what the cause for apathy is, is there a tradeoff lurking somewhere?
[19:33:11] <bluss> I'm going to do my best to work for this, but right now I feel bummed out
[19:33:22] <Elaine> r? https://github.com/rust-lang/rust/pull/26806
[19:33:31] <Elaine> bluss: anything I can do to help?
[19:33:41] <bluss> time heals
[19:34:40] <Gankro> Elaine: saturating is slower even though basically no program anyone would write needs the guard.
[19:35:19] <Elaine> Gankro: "basically no program" means "rust is conditionally safe", which is not a thing I'm willing to accept
[19:35:38] <Gankro> Elaine: A legit memory leak would prevent it too. You need to be doing something super convoluted (as in using mem::forget or storing drains in Rc cycles) to make it a problem
[19:35:57] <Gankro> I agree it should be fixed
[19:36:08] <Elaine> Yeah, leaking the Rc would be fine.
[19:38:39] <Gankro> I guess I've become kinda apathetic since there's a long list of memory safety holes and this is basically at the bottom severity-wise, along with 32-bit PAE Vec's that get the entire address space
[20:14:27] *** Joins: annodomini (lambda@moz-qgii5v.ma.comcast.net)
[20:50:45] *** Joins: blank_name (blank_name@moz-crs.fli.183.192.IP)
[20:53:37] <Elaine> carllerche: would https://github.com/cmr/ioctl be a candidate for merging into nix?
[20:54:48] <Elaine> (I just found the nix crate, unfortunately...)
[20:55:50] <carllerche> Elaine: lets see, possibly :)
[20:55:59] <carllerche> I know that nix has some ioctl support already
[20:56:12] <Elaine> Yeah, nix has some, but it's primitive.
[20:56:13] <carllerche> Elaine: https://github.com/carllerche/nix-rust/blob/master/src/sys/ioctl.rs
[20:56:20] <carllerche> I don't know much about ioctl personally, it has been contributed :)
[20:56:23] <Elaine> Ok.
[20:56:28] <carllerche> I would happily take more!
[20:57:39] <Elaine> I'm really disappointed that I didn't find nix sooner, but amusingly most of the stuff I need isn't quite exposed by nix yet :P
[21:33:15] *** Joins: brson (brson@moz-cfhap5.mtv2.mozilla.com)
[21:33:16] *** ChanServ sets mode: +qo brson brson
[22:22:29] *** Quits: annodomini (lambda@moz-qgii5v.ma.comcast.net) (Client exited)
[22:47:58] *** Quits: brson (brson@moz-cfhap5.mtv2.mozilla.com) (Quit: leaving)
[23:06:23] *** Joins: smkz (a@moz-gdd4un.fs1g.619c.a880.2604.IP)
[23:17:03] *** Joins: Rym (uid91135@moz-n2i7qm.charlton.irccloud.com)
[23:41:20] *** Quits: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua) (Ping timeout: 121 seconds)
[23:51:39] *** Quits: blank_name (blank_name@moz-crs.fli.183.192.IP) (Ping timeout: 121 seconds)
[23:51:58] *** Quits: smkz (a@moz-gdd4un.fs1g.619c.a880.2604.IP) (Quit: x)
[23:52:04] *** Joins: smkz (a@moz-gdd4un.fs1g.619c.a880.2604.IP)
[23:58:01] *** Joins: blank_name (blank_name@moz-r8p.iv2.183.192.IP)

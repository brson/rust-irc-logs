[00:02:37] *** Joins: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net)
[00:02:38] *** ChanServ sets mode: +o tjc
[00:06:30] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[00:06:30] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14f715aa4 to 146aad3bf: 02http://git.io/N3iJvQ
[00:06:30] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[00:06:35] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[00:06:35] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/EJudug
[00:06:35] <ghrust> 13rust/06auto 14fc1d655 15Adrien TÃ©tar: etc/tidy: don't check SNAP against triple
[00:06:35] <ghrust> 13rust/06auto 140ebe112 15Adrien TÃ©tar: etc: add missing license boilerplates
[00:06:35] <ghrust> 13rust/06auto 14611c7a6 15Adrien TÃ©tar: rustdoc: update deps
[00:06:37] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[00:06:54] <olsonjeffery> acrichto: so a possible libtest, as it stands, takes deps on getopts, stats, time in extra .. also treemap (headed into libcontainer), serialize and json (which can move out when libcontainer lands..)
[00:08:06] <acrichto> olsonjeffery: sounds like a mess
[00:08:13] <olsonjeffery> don't think its worth it if libtest depends on libextra
[00:08:41] <olsonjeffery> my gut feeling is that libextra should be depending on the new libsplodes, and never the other way around
[00:09:10] <acrichto> seems reasonable
[00:09:21] <acrichto> perhaps some more explosions need to happen before libtest can emerge
[00:09:58] <Eridius> acrichto: clone landed! \o/
[00:10:08] <Eridius> acrichto: did you end up going with the Arc idea? Because the merge message still says you use dup()
[00:10:18] *** Quits: zimbabao (rajaram@7C44F489.DA20CA3D.D2D1FAF0.IP) (Ping timeout)
[00:10:27] <acrichto> Eridius: argh I always forget to go back and change those
[00:10:35] <acrichto> but yeah they implement the Clone trait
[00:10:41] <acrichto> it uses Arc
[00:10:50] <Eridius> sweet
[00:11:06] <Eridius> now I no longer have an excuse to put off writing my IRC bot
[00:11:08] <Eridius> >_<
[00:12:33] <ChrisMorgan> And I can now go ahead with my rust-http rewrite â˜º
[00:12:44] <olsonjeffery> huzzah
[00:13:03] <olsonjeffery> ChrisMorgan: so in libnative can you send sockets to other threads?
[00:13:16] * ChrisMorgan defers to acrichto
[00:13:27] <acrichto> I would hope you can!
[00:13:34] <acrichto> the kernel is doing mysterious things if you can't
[00:13:39] <olsonjeffery> that would be pretty nice to see in the rust-http value proposition
[00:13:57] <ChrisMorgan> olsonjeffery: what do you get out of it?
[00:14:00] <olsonjeffery> i recall that being a pain point that you brought up early in the newrt days wrt rust-http
[00:14:23] <olsonjeffery> using main to accept connections and push the rest of the connection lifetime into work threads
[00:14:48] <ChrisMorgan> That's always been possible.
[00:15:08] <olsonjeffery> but wouldn't task pinning because of libuv preclude that?
[00:15:14] <ChrisMorgan> rust-http just didn't do it for a while with newrt because it died.
[00:15:38] <acrichto> multithreaded I/O on newrt used to die so horribly
[00:15:42] <acrichto> but then we fixed everything!
[00:15:52] <ChrisMorgan> But that was because of bugs, and when they were fixed rust-http shifted to the desired task-per-connection model.
[00:24:20] *** Joins: zimbabao (rajaram@49F8CDDC.1E78B47A.D2D1FAF0.IP)
[00:25:47] *** Joins: lpy (lpy@FA66696A.6C1907BC.E99F7FDB.IP)
[00:26:18] *** Quits: zimbabao (rajaram@49F8CDDC.1E78B47A.D2D1FAF0.IP) (Ping timeout)
[00:27:53] *** Quits: lpy (lpy@FA66696A.6C1907BC.E99F7FDB.IP) (Ping timeout)
[00:30:47] *** Quits: dherman (dherman@moz-7B0110AD.mv.mozilla.com) (Ping timeout)
[00:31:57] *** Joins: dherman (dherman@moz-BBE3ABD.mv.mozilla.com)
[00:31:57] *** ChanServ sets mode: +ao dherman dherman
[00:40:02] *** Quits: dherman (dherman@moz-BBE3ABD.mv.mozilla.com) (Quit: dherman)
[00:41:53] *** Joins: zimbabao (rajaram@8E1BA38F.84981E9D.D2D1FAF0.IP)
[00:42:16] <acrichto> r? https://github.com/mozilla/rust/pull/12054
[00:43:41] *** kimundi is now known as zz_kimundi
[00:51:21] <acrichto> nmatsakis: you might be interested in this comment https://github.com/mozilla/rust/issues/12042#issuecomment-34280866
[00:55:17] *** Quits: Kxepal (Miranda@moz-C2AD231E.pppoe.mtu-net.ru) (Quit: Kxepal)
[00:55:32] *** Joins: Kxepal (Miranda@moz-C2AD231E.pppoe.mtu-net.ru)
[00:56:20] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[00:57:47] *** Quits: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[00:58:01] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Connection reset by peer)
[00:58:03] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[01:00:27] *** Joins: vadimcn (chatzilla@FB06B64.76F9E272.DA40C4B3.IP)
[01:00:48] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[01:13:58] *** Joins: pcwalton (pcwalton@moz-DA87EE4.hsd1.ca.comcast.net)
[01:13:59] *** ChanServ sets mode: +ao pcwalton pcwalton
[01:14:13] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[01:14:13] <ghrust> 01[13rust01] 15alexcrichton 04force-pushed 06try from 1468c4f05 to 14be6c372: 02http://git.io/k471pw
[01:14:13] <ghrust> 13rust/06try 1409489ae 15chromatic: Removed prelude::* from libstd files....
[01:14:13] <ghrust> 13rust/06try 14be6c372 15chromatic: Cleaned up a lint warning.
[01:14:14] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[01:16:40] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[01:16:40] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1496e0bed to 146aad3bf: 02http://git.io/N3iJvQ
[01:16:40] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[01:21:36] *** Joins: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net)
[01:21:36] *** ChanServ sets mode: +o tjc
[01:26:32] *** Joins: lpy (lpy@FA66696A.6C1907BC.E99F7FDB.IP)
[01:26:57] <bstrie> hm, one consequence of de-preluding `println` is that now people are always going to be exposed to macros immediately
[01:27:02] <bstrie> not sure if that's a good thing or a bad thing
[01:27:33] <acrichto> bstrie: yeah I realized that the other day
[01:27:42] <acrichto> and if we make spawn! a macro, "hello world" is pure macros
[01:27:51] <acrichto> fn main { spawn! { println!("hello!"); } }
[01:28:07] <bstrie> acrichto: I propose an item-level macro that expands to main()
[01:28:18] <acrichto> rusti: hello_world!()
[01:28:18] -rusti- <anon>:10:9: 10:20 error: macro undefined: 'hello_world'
[01:28:19] -rusti- <anon>:10         hello_world!()
[01:28:19] -rusti-                   ^~~~~~~~~~~
[01:28:19] -rusti- error: aborting due to previous error
[01:28:19] -rusti- application terminated with error code 101
[01:28:21] <acrichto> aww
[01:28:22] <bstrie> main!(spawn!(println!("hello!")))
[01:28:30] <acrichto> hahaha
[01:28:33] <bstrie> dear god, we've reimplemented lisp!
[01:28:35] <bstrie> HOW DID THIS HAPPEN
[01:28:41] *** Quits: lpy (lpy@FA66696A.6C1907BC.E99F7FDB.IP) (Ping timeout)
[01:28:42] <acrichto> convergence is upon us!
[01:29:22] <bstrie> acrichto: speaking of spawn!{}, I'd really love if we could have the {} instead of () in macros :)
[01:29:36] <bstrie> not that I want to get rid of (), just as an alternative
[01:29:42] <bstrie> for macros that look like control structures
[01:30:02] <acrichto> agreed
[01:30:10] <acrichto> select! really wants it as well
[01:30:52] <kmc> i think i encountered macros about 5 min into learning Rust anyway
[01:30:57] <brson> macros could potentially accept any brace form, println!<"hi">
[01:31:04] <kmc> but I'm a seasoned PL-learner and a fan of macros :)
[01:31:06] <acrichto> bstrie: see https://github.com/mozilla/rust/issues/11892
[01:31:26] <acrichto> brson: that's an interesting though... any sort of user-specified delimiter pair
[01:31:58] <bstrie> brson: no, we couldn't use <> unless you wanted to disallow the greater-than operator within macro invocations :P
[01:32:12] <acrichto> who wants to do that anyway
[01:32:22] <bstrie> brson: in any case, I remember how we originally allowed [] in macro invocations, and everyone thought that was just a terrible idea :)
[01:32:58] <acrichto> I always thought that the macro definition said what you had to do 
[01:33:08] <bstrie> brson: btw, please consider my proposal to replace the > operator with the !<= operator. then we could change ::<> to <> :)
[01:33:08] <acrichto> macro_rules! foo( () => () ) <- requires parens
[01:33:16] <acrichto> macro_rules! foo( {} => () ) <- requires braces
[01:33:23] <brson> bstrie: lol
[01:33:24] <bstrie> acrichto: that's what I've always wanted, yes
[01:33:44] <acrichto> macro_rules! foo( !$ => () ) 
[01:34:27] <sfackler> acrichto: is that not what happens?
[01:34:53] <bstrie> sfackler: nah, right now you always need to invoke macros with ()
[01:35:03] <acrichto> unless its in an item context, then I think you can use either
[01:35:04] <bstrie> I'm not sure if you're allowed to *define* them with {}
[01:35:05] <sfackler> what about condition! {}
[01:35:12] <bstrie> sfackler: surely that doesn't work
[01:35:17] <sfackler> it does!
[01:35:20] <bstrie> no way
[01:35:27] <acrichto> rustilite: condition! { foo: int } fn main() {}
[01:35:27] -rustilite- <anon>:1:19: 1:22 error: unexpected end of macro invocation
[01:35:27] -rustilite- <anon>:1 condition! { foo: int } fn main() {}
[01:35:27] -rustilite-                            ^~~
[01:35:27] -rustilite- application terminated with error code 101
[01:35:28] <bstrie> you're pulling my leg
[01:35:33] <acrichto> rustilite: condition! { foo: int; } fn main() {}
[01:35:33] -rustilite- <anon>:1:22: 1:23 error: no rules expected the token `;`
[01:35:33] -rustilite- <anon>:1 condition! { foo: int; } fn main() {}
[01:35:33] -rustilite-                               ^
[01:35:34] -rustilite- application terminated with error code 101
[01:35:40] <acrichto> rustilite: condition! { foo: int -> int; } fn main() {}
[01:35:43] <sfackler> bstrie: https://github.com/mozilla/rust/pull/12039/files#diff-eabfb0a8fb2fa390356bbbf0517d6327L91
[01:35:53] <acrichto> rusti where u go
[01:36:11] <bstrie> !!!
[01:36:16] <bstrie> when did this happen!
[01:36:18] <acrichto> rustilite: condition! { foo: int -> int; } fn main() {}
[01:36:24] <bstrie> does it let you use condition!() ?
[01:36:31] <bstrie> because that's the second half of the idea
[01:36:36] <bstrie> to have one way to do it
[01:36:39] <acrichto> rusti: condition!( foo: int -> int; )
[01:36:41] <bstrie> per macro
[01:36:42] -rusti- pastebinned 8 lines of output: http://ix.io/alh
[01:37:05] <acrichto> what
[01:37:31] *** Joins: bytbox (s@moz-54E13927.washdc.fios.verizon.net)
[01:37:35] <bstrie> where is the definition of condition
[01:37:38] <bstrie> wait we removed conditions!
[01:38:03] <acrichto> in the process of
[01:38:05] <bstrie> dammit acrichto, you've destroyed our only chance of figuring out the mythical macro brace syntax
[01:38:26] <bstrie> it's like you found the holy grail and then sold it to a cash4gold store
[01:38:28] <acrichto> lol
[01:38:57] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Client exited)
[01:39:31] <sfackler> bstrie: https://github.com/mozilla/rust/pull/12039/files#diff-f7ad4a5ae3364771b775302f47d00063L127
[01:39:34] <bstrie> https://github.com/mozilla/rust/pull/12039/files#diff-f7ad4a5ae3364771b775302f47d00063L127
[01:39:37] <bstrie> haha
[01:39:59] <bstrie> how delightful!
[01:40:06] <bstrie> when did that get implemented? I want to thank them
[01:40:52] *** Quits: rustilite (rustilite@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[01:41:02] *** Joins: rustilite (rustilite@moz-54F7FD49.cpe.net.cable.rogers.com)
[01:42:03] *** Quits: cgaebel (clark@ADA4DDE2.290DF317.EE6E63A5.IP) (Quit: ChatZilla 0.9.90.1 [Firefox 26.0/20131206145143])
[01:44:27] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[01:45:53] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[01:45:54] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[01:51:35] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[01:51:35] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/zY4Kvg
[01:51:35] <ghrust> 13rust/06auto 14d07816d 15Alex Crichton: Make a double-write UDP test more robust...
[01:51:35] <ghrust> 13rust/06auto 148443742 15bors: auto merge of #12054 : alexcrichton/rust/less-flaky-udp, r=brson...
[01:51:36] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[01:52:26] *** Joins: cgaebel (clark@ADA4DDE2.290DF317.EE6E63A5.IP)
[01:52:45] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Quit: leaving)
[01:53:09] *** Joins: brson (brson@981AA104.E81F12CD.76F66111.IP)
[01:53:09] *** ChanServ sets mode: +qo brson brson
[02:00:34] <Eridius> aww crap. I just ran across a reference that suggests that Windows filenames can contain unpaired surrogates, which is not legally representable in UTF-8
[02:00:42] <Eridius> that's rather problematic
[02:01:13] <strcat> Eridius: yeah afaik NTFS is UCS2
[02:03:54] <Eridius> strcat: this is problematic because WindowsPath uses ~str internally
[02:04:07] <Eridius> because I _thought_ that was safe, and it made things easier
[02:06:28] <ChrisMorgan> Eridius: posix::Path already does ~[u8], so hopefully it's not too severe a change if you do it?
[02:06:59] *** Quits: cgaebel (clark@ADA4DDE2.290DF317.EE6E63A5.IP) (Ping timeout)
[02:08:32] <Eridius> ChrisMorgan: well, PosixPath can be used as a reference, but it's going to require rewriting a significant chunk of the WindowsPath code :/
[02:09:22] *** Joins: cgaebel (clark@ADA4DDE2.290DF317.EE6E63A5.IP)
[02:09:34] <ChrisMorgan> :'(
[02:11:08] <ChrisMorgan> I guess it's worse than that, actuallyâ€”we really don't have a type which can represent UCS-2 properly. Because if you encode it as UTF-8 locally, you kinda can't get it to UCS-2 for WCHARâ€¦ uh oh.
[02:11:43] * ChrisMorgan wonders whether we should whistle quietly, looking up at the ceiling, and pretend that it's UTF-16
[02:11:56] <Eridius> ChrisMorgan: hmm yeah. I mean, theoretically we could encode as utf-8 internally, but allowing for surrogate codepoints, but that basically means keeping a parallel UTF-8 impl in path
[02:12:08] <Eridius> at the moment, I just filed the issue on the issue tracker and I'm going to forget I ever saw it
[02:12:25] <kmc> that's called CESU-8
[02:12:32] * ChrisMorgan thinks that's probably best
[02:12:59] <Eridius> once we have real encoding support perhaps we can push for UCS-2 support (i.e. UTF-16 without checking for unpaired surrogates) and keep everything like that in WindowsPath... although .as_bytes() is then kinda screwed, so maybe not
[02:13:56] <Eridius> kmc: hmm, CESU-8 looks like it encodes surrogate pair codepoints in UTF-8 instead of storing the represented codepoint in UTF-8. But does this allow for unpaired surrogates?
[02:14:00] *** Quits: cgaebel (clark@ADA4DDE2.290DF317.EE6E63A5.IP) (Ping timeout)
[02:14:18] <Eridius> this is a compatibility scheme for UTF-16, not UCS2
[02:15:15] <Eridius> theoretically we could relax the str type and allow for encoding unpaired surrogates...
[02:15:21] <kmc> sorry, I thought that's what you meant
[02:15:44] *** Joins: cgaebel (clark@ADA4DDE2.290DF317.EE6E63A5.IP)
[02:15:47] *** Quits: brson (brson@981AA104.E81F12CD.76F66111.IP) (Ping timeout)
[02:15:56] *** Quits: canhtak (canhtak@moz-8A625E1D.wl.t.ulaval.ca) (Quit: canhtak)
[02:16:05] <strcat> ChrisMorgan: lots of windows APIs are UTF-16, not UCS2
[02:16:07] <strcat> it depends
[02:16:15] <ChrisMorgan> Whaâ€¦?
[02:16:17] <strcat> NTFS seems to be UCS2 though.
[02:16:29] <strcat> ChrisMorgan: as in some APIs enforce that it be valid Unicode
[02:16:38] <ChrisMorgan> *sigh*
[02:17:02] <strcat> others have backwards compatibility with pre-Unicode (16-bit UCS2 characters - rather than it being variable length UTF-16)
[02:17:50] <strcat> microsoft adopted it early and got screwed by ending up with a very bad way of supporting it
[02:17:56] <strcat> not really their fault
[02:18:24] <strcat> although it's their fault for not adding new UTF-8 APIs and deprecating (but leaving for basically eternity) the old ones
[02:18:39] <strcat> they make things so unnecessarily difficult
[02:19:03] <strcat> file/stream content will be UTF-8, but please supply all the paths in UCS2!
[02:23:53] *** Quits: Leo` (Leo@moz-83832FE2.placeholder.fr) (Ping timeout)
[02:24:46] *** Joins: Leo` (Leo@moz-83832FE2.placeholder.fr)
[02:27:17] *** Joins: lpy (lpy@FA66696A.6C1907BC.E99F7FDB.IP)
[02:29:31] *** Quits: lpy (lpy@FA66696A.6C1907BC.E99F7FDB.IP) (Ping timeout)
[02:30:49] *** Joins: canhtak (canhtak@moz-8A625E1D.wl.t.ulaval.ca)
[02:31:40] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[02:31:40] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 148443742 to 146aad3bf: 02http://git.io/N3iJvQ
[02:31:40] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[02:33:55] *** Quits: pcwalton (pcwalton@moz-DA87EE4.hsd1.ca.comcast.net) (Quit: pcwalton)
[02:34:02] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Client exited)
[02:34:28] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[02:36:15] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Ping timeout)
[02:40:46] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.2)
[02:40:51] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[02:42:32] *** Quits: gimpf (gimpf@moz-8EE4C1B0.adsl.highway.telekom.at) (Client exited)
[02:45:07] *** Joins: pcwalton (pcwalton@moz-DA87EE4.hsd1.ca.comcast.net)
[02:45:07] *** ChanServ sets mode: +ao pcwalton pcwalton
[02:51:10] <strcat> nmatsakis: tydescs are already gone from vtables btw
[02:51:22] <strcat> the only place they're used now is in proc and std::reflect
[02:51:30] <strcat> and I plan on removing both uses
[02:51:51] <strcat> well, I don't really care about reflect being efficient
[02:51:54] <strcat> but it's needlessly complex
[02:52:49] <strcat> @/proc use it to get the alignment
[02:57:01] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[02:58:59] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[03:00:12] *** Quits: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[03:12:04] <strcat> pcwalton: so I came up with a really dumb way of marking stuff as nonnull, it does work
[03:12:17] <pcwalton> what did you do?
[03:12:18] <strcat> made a nonnull attribute, and it marks it as such in the caller and the callee
[03:12:27] <strcat> so then you can insert a bunch of opaque function calls
[03:12:34] <strcat> to this magical function taking a nonnull ptr
[03:12:40] <strcat> and then at the end, you iterate over them and remove them
[03:12:46] <strcat> ;s
[03:12:52] <pcwalton> hmm
[03:12:56] <pcwalton> what optimization is this for?
[03:13:22] <strcat> pcwalton: https://github.com/mozilla/rust/issues/11751
[03:13:26] <strcat> it's a more general issue though...
[03:13:35] *** Joins: tjc (tjc@A21075EB.2D024FDB.284344F5.IP)
[03:13:35] *** ChanServ sets mode: +o tjc
[03:13:38] <strcat> fn foo(x: &int) -> bool { Some(x) == None } is the simplest case
[03:13:41] *** Quits: tjc (tjc@A21075EB.2D024FDB.284344F5.IP) (Quit: tjc)
[03:13:51] <strcat> it performs a null check at --opt-level=3, since LLVM thinks `x` can be null
[03:13:53] <strcat> and Some(x) is a no-op
[03:14:06] <strcat> anyway hurts iterators often
[03:14:12] <strcat> because they return Some(T) where T is often &T
[03:14:31] <strcat> so you get the actual check (current == end for vectors, or whatever) and a null check
[03:14:38] <pcwalton> ah
[03:14:42] <strcat> and then LLVM doesn't consider it a normal loop
[03:15:24] <strcat> maybe I should figure out how to add some kind of better pointer metadata
[03:15:26] * strcat shrugs
[03:15:37] <cgaebel> LOL. I defined HashSet<K>.contains_key_equiv in terms of HashMap<K, ()>.find... which is subtly broken because of Option<()>.
[03:15:41] <strcat> attributes are easy though
[03:15:53] <strcat> I'll submit it upstream soon anyway
[03:16:04] <strcat> they'll want it for gcc's attribute((non_null)) and returns_nonnull
[03:16:26] <strcat> s/non_null/nonnull/
[03:16:37] <strcat> cgaebel: hm, you mean Option<~()> ?
[03:16:47] <cgaebel> uhh, maybe.
[03:16:58] <cgaebel> not sure. we'll see if that fixed my subtle breakage
[03:18:52] <cgaebel> :( didn't work.
[03:19:33] * strcat is confused ;s
[03:19:43] *** Quits: zz_kimundi (kimundi@moz-47FBED98.dip0.t-ipconnect.de) (Ping timeout)
[03:19:44] <strcat> cgaebel: the fix I landed for glue just makes way for a real library fix
[03:19:51] <strcat> tbh I am still not really sure how I want to do it
[03:19:55] *** Quits: sunfish (chatzilla@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[03:20:12] <strcat> I'll play with it a bit in rust-core before making a libstd pull request to see how much the various alternatives hurt
[03:20:13] <cgaebel> strcat: alright. I do like the idea of them all pointing to the same static object.
[03:20:32] <strcat> static EMPTY: () = (); static EMPTY_PTR: *mut u8 = &EMPTY as *() as *mut u8;
[03:20:41] <strcat> then exchange_malloc returns EMPTY_PTR for 0-size
[03:20:47] <strcat> that should already work, could make it a PR
[03:20:59] <strcat> and worry about other malloc_raw/realloc_raw users later
[03:22:12] <cgaebel> that sounds good to me.
[03:22:29] <strcat> let me finishing removing TyDesc from proc first ;)
[03:22:44] <strcat> then we can remove drop glue from TyDesc, and TyDesc will only be generated by std::reflect
[03:23:16] *** Joins: zz_kimundi (kimundi@moz-388F7F53.dip0.t-ipconnect.de)
[03:23:18] *** zz_kimundi is now known as kimundi
[03:23:21] <cgaebel> strcat: ok. sounds good.
[03:25:48] <strcat> hm
[03:25:52] <strcat> changing lang items is a real pain
[03:25:55] <strcat> I forgot...
[03:26:32] <strcat> #[cfg()] doesn't work >.<
[03:26:41] <strcat> or does it...
[03:28:02] *** Joins: lpy (lpy@FA66696A.6C1907BC.E99F7FDB.IP)
[03:28:05] <ChrisMorgan> strcat: it's not that bad now. All that's left of nastiness is the matter of assigning numbers to each lang item; and for that, the stage is all set for someone to make the macro that will allow that problem to be removed also.
[03:28:40] * strcat doesn't actually mean the compiler list
[03:28:44] <strcat> that part is super sane now
[03:29:13] <ChrisMorgan> Oh, I see.
[03:30:10] *** Quits: lpy (lpy@FA66696A.6C1907BC.E99F7FDB.IP) (Ping timeout)
[03:30:21] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[03:30:21] *** ChanServ sets mode: +ao dherman dherman
[03:31:55] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Client exited)
[03:32:16] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[03:33:59] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Ping timeout)
[03:37:22] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[03:37:51] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[03:39:34] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Ping timeout)
[03:41:08] *** Quits: zimbabao (rajaram@8E1BA38F.84981E9D.D2D1FAF0.IP) (Ping timeout)
[03:41:33] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[03:41:34] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/ipRKPw
[03:41:34] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[03:46:28] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[03:46:28] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/fiFogQ
[03:46:28] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[03:46:29] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[03:46:29] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/YN7VYw
[03:46:29] <ghrust> 13rust/06auto 147b81cc0 15Alex Crichton: Make a double-write UDP test more robust...
[03:46:29] <ghrust> 13rust/06auto 1447113d9 15bors: auto merge of #12054 : alexcrichton/rust/less-flaky-udp, r=brson...
[03:46:29] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[03:52:34] *** Joins: lpy (lpy@FA66696A.6C1907BC.E99F7FDB.IP)
[03:54:59] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[03:55:48] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[03:56:41] *** Joins: zimbabao (rajaram@8DDECABC.15483BDF.D2D1FAF0.IP)
[03:58:19] *** Quits: Leo` (Leo@moz-83832FE2.placeholder.fr) (Ping timeout)
[04:00:13] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[04:06:46] *** Quits: zimbabao (rajaram@8DDECABC.15483BDF.D2D1FAF0.IP) (Ping timeout)
[04:11:27] *** Joins: Leo` (Leo@moz-83832FE2.placeholder.fr)
[04:15:30] <strcat> http://ix.io/alC/diff *shrug*
[04:15:39] <strcat> wonder if it'll work without LLVM asserts the first time
[04:16:30] *** Quits: canhtak (canhtak@moz-8A625E1D.wl.t.ulaval.ca) (Quit: canhtak)
[04:22:13] *** Joins: zimbabao (rajaram@D15572C3.977C920F.D5D59AD9.IP)
[04:24:03] *** Joins: sokomo (sokomo@8293D4FC.93FF164A.408809BB.IP)
[04:34:22] <strcat> pcwalton: close to no more TyDescs when reflection isn't used...
[04:34:38] <strcat> pretty easy change to make
[04:34:59] * strcat hopes it's something like a 10% LLVM IR size win ;p
[04:35:03] <strcat> doubt it though
[04:35:38] <pcwalton> cool
[04:36:46] <strcat> it actually compiled the first time. lucky
[04:40:12] *** Quits: lpy (lpy@FA66696A.6C1907BC.E99F7FDB.IP) (Ping timeout)
[04:41:20] *** Joins: lpy (lpy@CD0DB27D.2153E224.E99F7FDB.IP)
[04:46:31] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[04:46:31] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1447113d9 to 149a672f9: 02http://git.io/N3iJvQ
[04:46:31] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[04:46:32] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[04:46:32] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/AGuhhQ
[04:46:32] <ghrust> 13rust/06auto 1465a6c7c 15Yuri Kunde Schlesner: Add `extra::getopts::short_usage`...
[04:46:32] <ghrust> 13rust/06auto 1457550ed 15bors: auto merge of #12001 : yuriks/rust/getopts-tweaks, r=brson...
[04:46:33] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[04:49:51] *** Joins: sunfish (chatzilla@moz-8DE7F965.dsl.dynamic.sonic.net)
[04:51:29] *** Joins: canhtak (canhtak@moz-8A625E1D.wl.t.ulaval.ca)
[04:54:15] *** Quits: zimbabao (rajaram@D15572C3.977C920F.D5D59AD9.IP) (Ping timeout)
[04:56:37] <nrc|waitangiday> design question - how do I stop mut being infectious -
[04:56:39] <nrc|waitangiday> I have a struct with a Writer, I use it to write stuff which means I need to have a mut self, fair enough. But I would like to have non-mutating methods have non-mut self. But as soon as I use one in a method which also touches the writer I break the borrowing rules. SO I have to make the helper methods mut too, and then another method uses that method and another so the next method has to...
[04:56:40] <nrc|waitangiday> ...be mut and so forth- can I avoid that?
[04:57:15] *** Joins: aurynj (Eon@583ABBE5.60FA2E28.B9E25744.IP)
[04:57:29] *** Quits: aurynj (Eon@583ABBE5.60FA2E28.B9E25744.IP) (Connection reset by peer)
[04:57:51] <Eridius> nrc|waitangiday: if your helper methods are going to write to the writer, they need to be mut. Is there some reason you don't want them to be?
[04:57:54] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[04:59:42] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[05:03:12] <nrc|waitangiday> Eridius: sorry, was not clear enough - the helper methods do not write to the writer and could be non-mut, other than the fact that their callers do touch the writer
[05:03:54] <strcat> nrc|waitangiday: there are some cases where the borrow checker is just not clever
[05:03:56] <strcat> like
[05:04:04] <strcat> self.immutable_borrow(self.mutable_borrow()) won't work
[05:04:21] <strcat> let tmp = self.mutable_borrow(); self.immutable_borrow(tmp); will work
[05:07:16] <nrc|waitangiday> is it considered good practice to insert temporaries to game the borrow checker? Or better to just make everything mut and be done?
[05:07:18] *** Quits: pcwalton (pcwalton@moz-DA87EE4.hsd1.ca.comcast.net) (Quit: pcwalton)
[05:07:27] <strcat> nrc|waitangiday: well in that case it's a borrow checker bug
[05:07:31] <strcat> the temporary will optimize out anyway
[05:07:43] <strcat> should definitely use immutable borrows if they're not mutated
[05:10:01] <nrc|waitangiday> yeah. I would like as much to be immutable as possible
[05:23:25] *** Quits: lpy (lpy@CD0DB27D.2153E224.E99F7FDB.IP) (Ping timeout)
[05:23:59] *** Quits: cgaebel (clark@ADA4DDE2.290DF317.EE6E63A5.IP) (Ping timeout)
[05:24:07] *** Joins: lpy (lpy@CD0DB27D.2153E224.E99F7FDB.IP)
[05:24:31] *** Joins: cgaebel (clark@ADA4DDE2.290DF317.EE6E63A5.IP)
[05:25:19] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Client exited)
[05:26:08] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[05:26:58] *** Quits: cgaebel (clark@ADA4DDE2.290DF317.EE6E63A5.IP) (Ping timeout)
[05:27:49] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Ping timeout)
[05:29:50] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[05:29:58] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Client exited)
[05:33:36] *** Quits: blank_name (blank_name@75624DB1.E6D3F868.537E532E.IP) (Ping timeout)
[05:36:08] *** Quits: canhtak (canhtak@moz-8A625E1D.wl.t.ulaval.ca) (Ping timeout)
[05:36:14] *** Joins: blank_name (blank_name@6D7A111F.7C86004B.6D228269.IP)
[05:36:50] *** Joins: cgaebel (clark@ADA4DDE2.290DF317.EE6E63A5.IP)
[05:39:14] *** Quits: blank_name (blank_name@6D7A111F.7C86004B.6D228269.IP) (Ping timeout)
[05:43:15] *** Joins: blank_name (blank_name@9C54A110.964BADD.93A5C78C.IP)
[05:46:13] *** Quits: blank_name (blank_name@9C54A110.964BADD.93A5C78C.IP) (Ping timeout)
[05:47:41] *** Joins: zimbabao (rajaram@47769425.AE842F9B.81C3DAA1.IP)
[05:52:42] *** Quits: sunfish (chatzilla@moz-8DE7F965.dsl.dynamic.sonic.net) (Ping timeout)
[05:54:59] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[05:54:59] *** ChanServ sets mode: +ao dherman dherman
[05:55:19] *** Quits: lpy (lpy@CD0DB27D.2153E224.E99F7FDB.IP) (Ping timeout)
[05:55:54] *** Joins: lpy (lpy@CD0DB27D.2153E224.E99F7FDB.IP)
[06:01:18] *** Joins: blank_name (blank_name@973FA96D.E6D3F868.537E532E.IP)
[06:04:02] <Eridius> huh, you can't use a 'lifetime on a while loop?
[06:04:09] <cmr> Eridius: it's a label
[06:04:15] <cmr> you can say continue 'whichloop
[06:04:16] <Eridius> 'lifetime: label. yeah.
[06:04:37] <Eridius> cmr: `'outer: while foo { }` tells me expected `for` or `loop` after label
[06:04:58] <cmr> sure, only works with loop (and for, since it desugars to loop)
[06:05:07] <Eridius> that's just surprising
[06:07:16] *** Quits: jsonnull (Thunderbir@26F61E6.CFD9471D.494A0F8B.IP) (Quit: jsonnull)
[06:10:45] <cmr> acrichto: I feel like using Result/Option is going to be painful because you can't say, for example, IoError |
[06:10:50] <cmr> MyError
[06:10:55] <cmr> (accidental linebreak)
[06:11:00] <acrichto> ?
[06:11:11] <cmr> that is, "anonymous enums"
[06:11:26] <cmr> if you want to tack on an error case, you need to create a whole new type.
[06:12:17] <acrichto> it kinda makes sense that you need to canonicalize everything to one type
[06:12:28] <acrichto> it's just whatever kind of helper you need
[06:12:40] <cmr> well no it does make sense
[06:12:46] <acrichto> I've redefined if_ok!() many times personally, and I think that it may be pretty frequent
[06:12:48] <cmr> but it's annotation burden in the sense that you need to do it manually.
[06:13:10] <acrichto> I'd be surprised if we could reach a solution that had 0 burden 100% of the time
[06:13:15] <acrichto> but who knows?
[06:13:23] <cmr> Whereas saying fn foo() -> Result<T, IoError | MySpecificError>
[06:13:26] <ChrisMorgan> acrichto: if_ok! will be able to replace an identical macro in some of my own code.
[06:13:30] <cmr> Does haskell have anything like this?
[06:13:41] <cmr> I feel like they'd suffer the same troubles as us wrt error monads..
[06:13:42] <acrichto> dunno
[06:13:51] <cmr> carter: ^ ?
[06:14:22] <cmr> well they'd actually probably just use Either
[06:15:17] <ChrisMorgan> A web API: I might return an IoError, a JsonError or an ApiError, so what do I do? Yep, I write me an enum. https://github.com/chris-morgan/diffbot-rust-client/blob/master/src/diffbot/lib.rs#L233..L259
[06:15:37] *** Quits: andrew-d_w (andrew-d_w@moz-E7894907.nat.bb.dnainternet.fi) (Input/output error)
[06:15:52] <cmr> well that'd need to be IoError(IoError) :P
[06:15:53] * ChrisMorgan would prefer to have `struct ApiError { code: uint, message: ~str } type Error = IoError | json::Error | ApiError;`
[06:15:57] <cmr> (post-conditions)
[06:16:01] <ChrisMorgan> cmr: yes, now it must be changed.
[06:16:17] *** Joins: canhtak (canhtak@moz-8A625E1D.wl.t.ulaval.ca)
[06:33:04] *** Quits: fredy (fredy@moz-E7647C0E.vm.okeanos.grnet.gr) (Ping timeout)
[06:35:07] <Eridius> acrichto: I could imagine a generic macro if_ok2!(expr, ErrIO) to wrap any IoErrors in an enum constructor ErrIO
[06:35:49] <strcat> acrichto: I just killed tydescs ;)
[06:36:50] <strcat> lets see if it compiles now...
[06:36:53] <strcat> https://github.com/mozilla/rust/pull/12059
[06:37:03] *** Quits: cgaebel (clark@ADA4DDE2.290DF317.EE6E63A5.IP) (Ping timeout)
[06:38:09] <acrichto> oh boy!
[06:38:55] <strcat> acrichto: now the only real glue is visit glue!
[06:39:17] <strcat> well
[06:39:22] <strcat> drop glue is still a bit entangled
[06:39:26] <strcat> it can be cleaned up more
[06:39:33] <strcat> I hate glue.rs
[06:39:41] <strcat> never understood why it was so generic
[06:39:52] <strcat> to the point where you pass "drop" as a string
[06:40:02] <cmr> wut
[06:40:04] <cmr> really?
[06:40:07] <strcat> yes
[06:40:09] <strcat> it's not as bad now
[06:40:33] <strcat> eddyb wanted stuff to optimize so I pointed him at glue, and he killed free glue and drop glue
[06:40:38] *** Joins: fredy (fredy@moz-E7647C0E.vm.okeanos.grnet.gr)
[06:40:50] <strcat> ugh I broke something with my 2nd commit
[06:40:58] <strcat> missing a cast 
[06:41:10] <strcat> ah
[06:41:13] <strcat> I see what I did
[06:41:16] <strcat> minor issue!
[06:41:33] <ChrisMorgan> Eridius: if we had anonymous enum types then you wouldn't need an if_ok2 macro; Err(err) => Err(err) would be sufficient.
[06:41:50] <ChrisMorgan> (Err(err) => Err(err) being what if_ok does.)
[06:41:54] <strcat> forgot to fetch the glue for the simplified glue type.
[06:41:56] <strcat> hm
[06:46:36] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[06:46:36] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1457550ed to 149a672f9: 02http://git.io/N3iJvQ
[06:46:36] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[06:46:39] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[06:46:39] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/242FOw
[06:46:39] <ghrust> 13rust/06auto 147b81cc0 15Alex Crichton: Make a double-write UDP test more robust...
[06:46:39] <ghrust> 13rust/06auto 148dc0680 15bors: auto merge of #12054 : alexcrichton/rust/less-flaky-udp, r=brson...
[06:46:39] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[06:56:47] *** Joins: jsonnull (Thunderbir@26F61E6.CFD9471D.494A0F8B.IP)
[06:58:50] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[06:58:59] *** Quits: canhtak (canhtak@moz-8A625E1D.wl.t.ulaval.ca) (Quit: canhtak)
[06:59:17] *** Quits: doomlord_ (servitor@moz-858B6E73.range86-148.btcentralplus.com) (Ping timeout)
[06:59:29] *** Joins: doomlord_ (servitor@moz-858B6E73.range86-148.btcentralplus.com)
[07:00:47] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[07:01:14] <strcat> acrichto: hm.
[07:01:19] <strcat> I am somehow making duplicate drop glues
[07:01:21] * strcat ponders
[07:05:22] *** kimundi is now known as zz_kimundi
[07:07:42] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[07:11:30] <strcat> acrichto: aha, infinite recursion!
[07:11:55] <strcat> acrichto: the glue calls itself via mutual recursion and I inserted into the table after generating the body
[07:12:09] * strcat will have size numbers soon...
[07:13:18] *** Joins: andrew-d_w (andrew-d_w@4CCE6E0C.339B431B.1E537B93.IP)
[07:13:22] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[07:13:22] *** ChanServ sets mode: +ao dherman dherman
[07:25:28] *** Quits: andrew-d_w (andrew-d_w@4CCE6E0C.339B431B.1E537B93.IP) (Input/output error)
[07:25:51] *** Joins: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net)
[07:32:43] <strcat> noooo
[07:32:48] <strcat> extra::arena uses tydescs ;s
[07:33:18] <strcat> meh
[07:33:26] <strcat> so much for this...
[07:34:07] <strcat> hm
[07:39:19] *** flaper87|afk is now known as flaper87
[07:49:17] *** Joins: eddyb (eddy@moz-92B95652.residential.rdsnet.ro)
[07:51:14] <strcat> eddyb: meh
[07:51:24] <strcat> eddyb: I did https://github.com/mozilla/rust/pull/12059 and just realized that arenas use the TyDesc
[07:51:25] <strcat> ;\
[07:51:56] <strcat> doesn't look easy to fix
[07:52:05] <eddyb> strcat: remove arenas
[07:52:17] <strcat> it's used in librustc
[07:52:28] <eddyb> I know librustc uses TypedArena
[07:52:34] <strcat> which uses tydescs
[07:52:43] <strcat> I don't want to undo the work ;s
[07:52:53] <eddyb> TypedArena doesn't need the tydesc
[07:53:01] <strcat> yes it does
[07:53:02] <eddyb> the old arena did because it wasn't typed
[07:53:03] <strcat> I see it right there
[07:53:05] <strcat> in the implementation
[07:53:11] <strcat> eddyb: look at libarena/lib.rs
[07:53:20] <eddyb> or is TypedArena a misnomer?
[07:53:35] <strcat> it needs the tydesc because generic dtors don't work
[07:53:36] <strcat> :|
[07:54:13] <eddyb>     /// The type descriptor of the objects in the arena. This should not be necessary, but is until generic destructors are supported.
[07:54:17] <eddyb> pfffft
[07:54:30] <eddyb> strcat: store the individual pieces of information instead of the tydesc
[07:54:41] <strcat> there is no way to get a ptr to drop glue
[07:54:53] <strcat> unless I add an intrinsic
[07:55:03] <strcat> which is a pain, because I don't know how to make an intrinsic return a function type
[07:55:09] <strcat> function types want a node id 
[07:55:21] <eddyb> do they?
[07:55:31] <cmr> return *u8 and transmute!
[07:56:33] <eddyb> strcat: if we had &move T you could just drop it
[07:56:34] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[07:56:34] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/242FOw
[07:56:34] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[07:56:46] <eddyb> omg what happened to the bors queue?
[07:58:10] <strcat> what a pain
[07:59:28] <eddyb> the generic dtors are fixable, but not easily
[08:01:35] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[08:01:35] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/xVbMtQ
[08:01:35] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[08:01:36] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[08:01:36] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/E-ASVQ
[08:01:36] <ghrust> 13rust/06auto 1465a6c7c 15Yuri Kunde Schlesner: Add `extra::getopts::short_usage`...
[08:01:36] <ghrust> 13rust/06auto 14d8c4e78 15bors: auto merge of #12001 : yuriks/rust/getopts-tweaks, r=brson...
[08:01:37] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[08:02:48] <eddyb> find impls, filter specific ones that don't match, should be left with one or zero, get substitutions if it's generic.... but it's really a pain without a typeck context
[08:03:15] <cmr> eddyb: the tcx doesn't go anywhere?
[08:04:26] <strcat> this is really a pain
[08:04:30] <eddyb> cmr: that's a type context. I was thinking of typeck-specific contexts used during "type checking"
[08:04:35] <strcat> I can't fix it easily
[08:04:40] <strcat> just not going to land this
[08:05:01] <strcat> I'm not rewriting this arena ;s
[08:05:35] <eddyb> strcat: you should at least remove the old one
[08:05:47] <strcat> Arena?
[08:05:51] <eddyb> yeah
[08:06:08] <cmr> why?
[08:06:11] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[08:06:16] <strcat> because it uses the tydesc
[08:06:22] <strcat> tydesc is going away.
[08:06:26] <cmr> entirely?
[08:06:33] <strcat> yes, atm only visit glue gets it
[08:07:49] *** Joins: dbaupp (Thunderbir@moz-25BBAF91.lns20.syd6.internode.on.net)
[08:07:56] <cmr> oh, I forgot typeid is just a u64
[08:08:03] <eddyb> if we really need {:?}, we'll make it cleanly generic, no virtual or tydesc nonsense and we'll use it as less as possible in rustc (to prevent instantiation bloat)
[08:08:18] <eddyb> cmr: TypeId is created by an intrinsic, unrelated to TyDesc
[08:08:25] <cmr> eddyb: yes I know
[08:09:03] <dbaupp> strcat: why does arena's use of tydesc stop you from removing the tydesc from proc and @?
[08:09:15] <eddyb> dbaupp: he removed drop glue from tydesc
[08:09:21] <strcat> dbaupp: because drop_glue is not going to be part of the tydesc
[08:09:29] <strcat> I could add it back
[08:09:33] <dbaupp> strcat: couldn't you just... not remove the drop_glue for now?
[08:09:34] <dbaupp> yeah
[08:09:50] <eddyb> (and remove others things, instead :P)
[08:10:00] <strcat> sad.
[08:10:16] <dbaupp> it's an improvement
[08:11:20] *** Joins: Zr40 (zr40@EE4BB9F5.926C319A.BE2F4011.IP)
[08:11:39] <eddyb> I was hoping to rebase my ast_map fiddling branch on top of my first one, but that hasn't landed yet :(
[08:11:59] <dbaupp> eddyb: you can still do it
[08:12:10] <eddyb> I know, but it can end up in a mess
[08:12:24] <dbaupp> <3 rebase -i and --onto :P
[08:14:51] <strcat> ;[
[08:18:40] <strcat> can I use #[deprecated] in libstd if something (libarena) uses it?
[08:18:56] <strcat> guess I won't try
[08:19:16] <cmr> sure, put #[allow(deprecated)] in arena
[08:19:39] <strcat> the -D flag doesn't still override it?
[08:20:00] <cmr> no
[08:20:10] <cmr> -F (forbid) overrides allows, not -D
[08:23:00] <strcat> and rust still doesn't build in the clean build chroot
[08:23:12] <strcat> tried unsetting Makefiles, not passing --disable-docs
[08:23:24] <strcat> unsetting MAKEFLAGS*
[08:27:33] *** Quits: rustilite (rustilite@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[08:27:33] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[08:27:49] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[08:27:53] *** Joins: strcat1 (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[08:28:42] *** strcat1 is now known as strcat
[08:29:50] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[08:29:52] *** Joins: rustilite (rustilite@moz-54F7FD49.cpe.net.cable.rogers.com)
[08:30:26] <strcat> acrichto: asleep yet?
[08:30:44] <strcat> I guess it doesn't matter anyway
[08:30:48] <strcat> the queue is long ;s
[08:33:39] <flaper87> Eridius: hey, I just saw your patch! :) I'll review in a bit!
[08:34:27] <flaper87> Eridius: thanks for that!
[08:51:02] <strcat> eddyb: meh, hardly any difference for libstd
[08:51:07] <strcat> it just removes 10k tydescs
[08:51:14] * strcat shrugs
[08:51:26] <strcat> really wanted to remove the drop glue from it ;p
[08:55:33] *** Joins: rca (rcatolino@moz-312D09C6.adsl.proxad.net)
[09:00:52] *** Joins: doener (doener@moz-C68F600D.unity-media.net)
[09:01:56] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[09:04:24] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[09:11:42] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[09:11:42] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/E-ASVQ
[09:11:42] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[09:16:07] <eddyb> dbaupp: I think ::anon::expr_fn is silly. ::closure is enough
[09:16:38] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[09:16:38] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/5QR3-g
[09:16:38] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[09:16:40] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[09:16:40] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/YPMDKw
[09:16:40] <ghrust> 13rust/06auto 14844a4d0 15HeroesGrave: moved collections from libextra into libcollection
[09:16:40] <ghrust> 13rust/06auto 1479af214 15bors: auto merge of #12010 : HeroesGrave/rust/libcollection, r=alexcrichton...
[09:16:41] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[09:18:35] <eddyb> this screams of "kill me" // FIXME: clownshoes
[09:23:46] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Ping timeout)
[09:26:38] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[09:26:38] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1479af214 to 14d8c4e78: 02http://git.io/N3iJvQ
[09:26:38] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[09:26:39] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[09:26:40] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/Lie_eg
[09:26:40] <ghrust> 13rust/06auto 14065fae7 15Alex Crichton: Redesign output flags for rustc...
[09:26:40] <ghrust> 13rust/06auto 14eab605f 15bors: auto merge of #12020 : alexcrichton/rust/output-flags, r=brson...
[09:26:40] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[09:30:02] *** Joins: NiccosSystem (NiccosSyst@AB1AFDE.FC7B0C35.A7597CB6.IP)
[09:31:16] *** zz_kimundi is now known as kimundi
[09:35:13] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: sleep)
[09:40:21] *** Quits: rca (rcatolino@moz-312D09C6.adsl.proxad.net) (Ping timeout)
[09:48:38] <eddyb> nmatsakis: btw, P<T> can be an u32 index in a T-specific arena, so @T -> P<T> is still useful in that case
[09:50:30] *** Joins: rca (rcatolino@moz-312D09C6.adsl.proxad.net)
[09:50:56] *** Joins: gimpf (gimpf@moz-104459D9.adsl.highway.telekom.at)
[09:56:34] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[09:56:34] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/4TgLig
[09:56:34] <ghrust> 13rust/06auto 14f362415 15Eduard Burtescu: Removed @self and @Trait.
[09:56:34] <ghrust> 13rust/06auto 14ef3dd23 15bors: auto merge of #12030 : eddyb/rust/kill-at-self-and-trait, r=pcwalton
[09:56:35] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[09:56:38] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[09:56:38] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14eab605f to 14d8c4e78: 02http://git.io/N3iJvQ
[09:56:38] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[10:03:15] *** Quits: nrc|waitangiday (nrc@7BE24E90.A5032A01.3CFC199D.IP) (Ping timeout)
[10:04:51] <eddyb> "Waiting to hear about f362415 â€” running tests Â· Details" - I wish the details link would point to the buildbot
[10:06:23] <eddyb> what's with the force push? it still looks like it's running tests on mine
[10:16:20] <dbaupp> eddyb: can you change it to ::closure easily?
[10:16:44] <eddyb> dbaupp: yeah, "expr_fn" is a constant string in trans
[10:16:56] <eddyb> I removed anon and used "closure" instead
[10:17:04] <dbaupp> cool
[10:17:14] <eddyb> anon there does nothing to randomize the situation, so it's pointless
[10:17:28] <dbaupp> you can submit that now, right?
[10:17:45] <eddyb> it's part of my larger PR
[10:18:10] <dbaupp> "larger" == 100K lines? :P
[10:18:15] <eddyb> Node has only one-pointer-variants btw
[10:18:45] <eddyb> and I thought we could maybe handle structs as one-variant enums, to make some of this nonsense simpler
[10:22:01] <dbaupp> it's been suggested many times before
[10:22:08] <dbaupp> unify structs and enums
[10:22:52] <dbaupp> like haskell just has 'data' for everything (modulo typedefs and the improved performance of 'newtype')
[10:23:59] <eddyb> dbaupp: not syntactically, but semantically
[10:24:20] <eddyb> DRY in the compiler
[10:24:40] <dbaupp> two sides of the same coin :P
[10:24:42] <eddyb> optimize one-variant enums where applicable, but treat structs as one of those
[10:24:55] <eddyb> s/but/and
[10:25:52] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[10:26:50] <dbaupp> it does mean that single variant enums have to be laid out C-compatibly (or not  handle structs and enums completely the same)
[10:27:25] <eddyb> there was that proposal for explicitly specified enum tags
[10:27:55] <eddyb> oh, btw, metadata should be somewhat smaller, now that all tags fit in one byte
[10:28:14] <eddyb> (one byte of variable-length-integer - 0x00-0x7f)
[10:36:39] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[10:36:39] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14ef3dd23 to 14d8c4e78: 02http://git.io/N3iJvQ
[10:36:39] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[10:36:39] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[10:36:39] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/MfHF4Q
[10:36:39] <ghrust> 13rust/06auto 14ea509bd 15Alex Crichton: Remove std::condition...
[10:36:39] <ghrust> 13rust/06auto 14cd7d2cd 15bors: auto merge of #12039 : alexcrichton/rust/no-conditions, r=pcwalton...
[10:36:40] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[10:42:56] <eddyb> dbaupp: you've got to be kidding me
[10:43:10] <eddyb> how do I even run these tests manually? http://buildbot.rust-lang.org/builders/auto-linux-64-x-android-t/builds/1004/steps/test/logs/stdio/text
[10:44:29] <dbaupp> eddyb: check-stage2-doc-tutorial, iirc
[10:44:51] <eddyb> if it has that name, why does it run after everything else?
[10:45:51] <dbaupp> because they're not alphabetical?
[10:45:54] * dbaupp doesn't know
[10:46:04] <eddyb> everything else is
[10:47:25] <dbaupp> erm, not it's not?
[10:47:32] <dbaupp> pretty runs after everything
[10:47:44] <dbaupp> and runpass runs first
[10:47:46] <dbaupp> -ish
[10:48:48] <eddyb> I don't understand why the tutorial still has any mention of @
[10:48:52] <dbaupp> and the doc tests have run toward the end since forever
[10:48:57] <dbaupp> because noone has updated it
[10:49:38] <eddyb> may @ burn in a bonfire
[10:51:47] <eddyb> dbaupp: what do I do about things like src/doc/po/ja/tutorial.md.po?
[10:53:39] <dbaupp> no idea
[10:58:20] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[11:11:42] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[11:11:42] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14cd7d2cd to 14d8c4e78: 02http://git.io/N3iJvQ
[11:11:42] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[11:11:43] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[11:11:43] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/2zTtJg
[11:11:43] <ghrust> 13rust/06auto 14da45340 15Huon Wilson: Ensure an Rc isn't freed while running its own destructor....
[11:11:43] <ghrust> 13rust/06auto 149a9a70b 15bors: auto merge of #12047 : huonw/rust/cyclic-rc, r=thestinger...
[11:11:44] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[11:23:01] *** Quits: zimbabao (rajaram@47769425.AE842F9B.81C3DAA1.IP) (Ping timeout)
[11:26:47] <eddyb> dbaupp: r=pcwalton? https://github.com/mozilla/rust/pull/12030
[11:27:01] <eddyb> no shame, I'll ask until it works
[11:29:07] <dbaupp> eddyb: have you run `git grep '(@self'` to just check there's no others hiding elsewhere?
[11:29:49] <eddyb> dbaupp: good point. I wasn't grepping src/doc at all, and libstd/any.rs didn't have @self, just @Any
[11:30:27] <eddyb> I don't grep -r src because of src/llvm. unless git grep skips it, in which case I am really dumb
[11:31:31] <eddyb> dbaupp: wait wait wait. debug-info has @self
[11:32:32] <eddyb> "ignored" - because it's android?
[11:32:43] <dbaupp> git grep skips submodules
[11:32:53] <dbaupp> <3 git grep
[11:36:32] <eddyb> dbaupp: egrep '\bclone\b' src/lib{rustc,syntax} | wc -l
[11:37:35] <dbaupp> eddyb: egrep?
[11:37:40] <dbaupp> <3 git grep
[11:37:53] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[11:37:59] <eddyb> I don't like remembering all the flags to turn grep (or git grep) into real regexp
[11:38:00] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[11:38:11] <dbaupp> git grep supports \b straight out
[11:38:21] <eddyb> dbaupp: but you used ( above without escaping it
[11:38:27] <dbaupp> also, would `\.clone(` be what you mean?
[11:38:38] <eddyb> I guess that would work better
[11:38:44] <dbaupp> maybe I forgot to escape it
[11:39:17] <dbaupp> 592
[11:39:18] <dbaupp> for me
[11:39:50] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[11:40:31] <dbaupp> eh, vec::append_one((...).clone(), ...) is rather popular :(
[11:40:54] <dbaupp> well, just in ty.rs
[11:41:01] <eddyb> is that for paths?
[11:41:12] <eddyb> trans was filled with that crap
[11:41:30] <dbaupp> 126 of those clones are just the generic clones in the visitor
[11:42:22] <eddyb> which clone () most of the time
[11:43:05] <dbaupp> yeah; one of the most expensive clones around :P
[11:43:17] <dbaupp> (is there anything not using () for the env?)
[11:43:18] <eddyb> how did I break test/debug-info/basic-types-metadata.rs?
[11:43:20] * dbaupp greps
[11:43:29] <eddyb> dbaupp: a few things, that we can maybe refactor
[11:44:15] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[11:44:23] <dbaupp> 7 things
[11:47:50] <eddyb> what on earth happened? I didn't touch trans::debuginfo, at least AFAIK
[11:48:22] <eddyb> well, I turned MemberDescriptionFactory into an enum, but that shouldn't affect this weird thing
[11:50:34] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[11:50:46] * eddyb blames whoever didn't use formatting for test output, hard to spot what's going on
[11:51:00] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[11:53:18] <eddyb> static ! basic-types-metadata::_yyy(void)(void);
[12:01:22] <eddyb> dbaupp: I had to change ()() to (void)(void)... what?
[12:01:58] <eddyb> does it depend on my local version of gdb?
[12:02:59] <eddyb> dbaupp: r=pcwalton, pls https://github.com/mozilla/rust/pull/12030
[12:04:27] <eddyb> I didn't change that ()() after all, doesn't make sense
[12:10:15] <dbaupp> eddyb: the change since he reviewed is basically the tutorial, right?
[12:10:29] <eddyb> dbaupp: and removing @Trait from debug-info tests
[12:10:43] <eddyb> (thanks for making me double-check)
[12:12:13] <dbaupp> eddyb: aren't some of the debug-info tests testing (@).foo(&self) rather than (@).foo(@self)?
[12:12:22] <dbaupp> although if @ is disappearing anyway...
[12:12:25] <eddyb> yupp
[12:12:55] <eddyb> strcat was right, don't spend time fixing @T-related things, as long as you're not breaking the compiler
[12:19:43] *** Joins: zimbabao (rajaram@D3E167BB.C0113EA2.D2D1FAF0.IP)
[12:20:30] *** Quits: zimbabao (rajaram@D3E167BB.C0113EA2.D2D1FAF0.IP) (Connection reset by peer)
[12:20:44] *** Joins: zimbabao (rajaram@D3E167BB.C0113EA2.D2D1FAF0.IP)
[12:21:40] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[12:21:40] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/2zTtJg
[12:21:40] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[12:22:00] *** Quits: zimbabao (rajaram@D3E167BB.C0113EA2.D2D1FAF0.IP) (Connection reset by peer)
[12:25:26] *** Quits: lpy (lpy@CD0DB27D.2153E224.E99F7FDB.IP) (Ping timeout)
[12:26:36] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[12:26:36] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/FvZ8HA
[12:26:36] <ghrust> 13rust/06auto 14844a4d0 15HeroesGrave: moved collections from libextra into libcollection
[12:26:36] <ghrust> 13rust/06auto 14b27e9ca 15bors: auto merge of #12010 : HeroesGrave/rust/libcollection, r=alexcrichton...
[12:26:37] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[12:26:40] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[12:26:40] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/E9_W5Q
[12:26:40] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[12:27:25] *** kimundi is now known as zz_kimundi
[12:27:31] *** Joins: lpy (lpy@B3BE13AC.47A0616D.E99F7FDB.IP)
[12:36:38] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[12:36:38] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/EzheqQ
[12:36:38] <ghrust> 13rust/06auto 147e2c67b 15Eduard Burtescu: Removed @self and @Trait.
[12:36:38] <ghrust> 13rust/06auto 1402fab06 15bors: auto merge of #12030 : eddyb/rust/kill-at-self-and-trait, r=pcwalton
[12:36:38] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[12:36:42] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[12:36:42] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14b27e9ca to 149a9a70b: 02http://git.io/N3iJvQ
[12:36:42] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[12:38:31] *** Joins: zimbabao (rajaram@D3E167BB.C0113EA2.D2D1FAF0.IP)
[12:38:36] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[12:42:59] *** Joins: andrew-__ (andrew-d_w@4CCE6E0C.339B431B.1E537B93.IP)
[12:44:19] *** Quits: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net) (Ping timeout)
[12:49:49] *** Joins: jdm (jdm@9A315A00.EF4ED636.74119F78.IP)
[12:57:47] *** Quits: lpy (lpy@B3BE13AC.47A0616D.E99F7FDB.IP) (Ping timeout)
[12:58:14] *** Joins: lpy (lpy@B3BE13AC.47A0616D.E99F7FDB.IP)
[13:05:21] *** Quits: Diamond (dick@moz-80556682.ks.ks.cox.net) (Quit: Leaving.)
[13:09:54] *** Joins: Diamond (dick@moz-80556682.ks.ks.cox.net)
[13:15:16] <eddyb> debuginfo does uncanny things with paths
[13:16:29] *** zz_kimundi is now known as kimundi
[13:21:19] <jdm> tell me more
[13:21:39] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[13:21:39] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/O4skyw
[13:21:39] <ghrust> 13rust/06auto 14b653fa0 15Seo Sanghyeon: Avoid cloning ast::CrateConfig
[13:21:39] <ghrust> 13rust/06auto 14ed9ffc1 15bors: auto merge of #12048 : sanxiyn/rust/crate-config, r=alexcrichton
[13:21:39] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[13:21:42] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[13:21:42] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1402fab06 to 149a9a70b: 02http://git.io/N3iJvQ
[13:21:42] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[13:21:44] *** Joins: canhtak (canhtak@moz-8DFB5E6A.wl.t.ulaval.ca)
[13:26:42] <eddyb> I officially hate the test running order
[13:29:36] <dbaupp> heh, `echo -n '"\' | rustc -`
[13:34:14] *** Quits: gimpf (gimpf@moz-104459D9.adsl.highway.telekom.at) (Client exited)
[13:34:22] *** Joins: gimpf (gimpf@moz-104459D9.adsl.highway.telekom.at)
[13:34:51] *** Quits: gimpf (gimpf@moz-104459D9.adsl.highway.telekom.at) (Client exited)
[13:41:09] <eddyb> <3 iterators
[13:41:21] <eddyb> this might just be the last use of a path in a vector
[14:00:45] *** Quits: jdm (jdm@9A315A00.EF4ED636.74119F78.IP) (Quit: Lost terminal)
[14:02:36] *** Quits: gifnksm (gifnksm@moz-2EC7BA37.szoknt01.ap.so-net.ne.jp) (Ping timeout)
[14:03:37] *** Quits: canhtak (canhtak@moz-8DFB5E6A.wl.t.ulaval.ca) (Quit: canhtak)
[14:06:39] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[14:06:39] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14ed9ffc1 to 149a9a70b: 02http://git.io/N3iJvQ
[14:06:39] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[14:06:40] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[14:06:40] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/g9HCiQ
[14:06:40] <ghrust> 13rust/06auto 14f286859 15Luqman Aden: libstd: Add missing constants for arm/linux.
[14:06:40] <ghrust> 13rust/06auto 1427dcd87 15bors: auto merge of #12051 : luqmana/rust/arm-fix, r=alexcrichton...
[14:06:40] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[14:20:19] *** Joins: canhtak (canhtak@moz-8DFB5E6A.wl.t.ulaval.ca)
[14:21:54] <eddyb> dbaupp: one more chance? https://github.com/mozilla/rust/pull/12030
[14:31:42] <eddyb> dbaupp: thanks :). it's amazing you're still around. timezones are confusing
[14:31:52] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Ping timeout)
[14:32:07] <dbaupp> eddyb: it's "only" 1.30am here :P
[14:35:03] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Client exited)
[14:35:24] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[14:37:10] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Ping timeout)
[14:43:06] <eddyb> dbaupp: OMG this code is cloning a ~[T] *it owns*
[14:45:34] <dbaupp> just to be doubly sure it's got ownership :P
[15:04:52] <bstrie> actually, I'm really happy that Times is gone now
[15:05:09] <bstrie> because it makes for a really good demonstration of extending built-in types
[15:08:12] <bstrie> hmmm
[15:08:14] <bstrie> thinking about int
[15:08:24] <bstrie> I'm wondering what the most widely-used int size is in rustc
[15:10:13] <bstrie> because part of me thinks that "int" is just too convenient a name to get rid of, but I'm concerned that it's probably only very rarely what you want to use
[15:10:36] <nmatsakis> uint is prob the most common
[15:10:47] <nmatsakis> at least in the kind of code I write :)
[15:10:55] <bstrie> nmatsakis: well, that has the same problem :) not having a specified size...
[15:11:04] <nmatsakis> I don't see this as a problem
[15:11:07] <nmatsakis> since usually I am counting things in memory
[15:11:08] <bstrie> is the only reason that it gets used is because people don't want to think about size?
[15:11:10] <nmatsakis> in which case uint is the right size
[15:11:17] <bstrie> nmatsakis: ok, well that's fine then :)
[15:11:35] <bstrie> but I personally just use int because I don't want to think about size, and I'm wondering if that's a bad thing
[15:11:36] <nmatsakis> I maintain this is an incredibly common thing to want to do :)
[15:11:56] * nmatsakis shrugs
[15:12:07] <nmatsakis> I guess it depends on the level of reliability you expect and the kinds of inputs you expect and so on
[15:12:07] <bstrie> on the other hand I really love that floats now make me think about size
[15:12:17] <bstrie> I'm just a hypocrite :P
[15:12:40] <nmatsakis> it'd be interesting to try and really categorize
[15:12:50] <nmatsakis> I've sometimes wished we didn't have "bare" ints at all,
[15:12:53] <nmatsakis> but rather always required a unit
[15:13:02] <nmatsakis> e.g., meters, bytes, or something
[15:13:06] <nmatsakis> elements
[15:13:19] <nmatsakis> that might help to categorize what kinds of ranges it is reasonable to expect
[15:13:24] <bstrie> hm? how would you represent negative numbers?
[15:14:27] <nmatsakis> no, I mean, we'd still have the same arrangement of sizes and negative/positive
[15:14:31] <nmatsakis> it's just that u8 is not a type alone
[15:14:36] <nmatsakis> but rather something like "u8(bytes)"
[15:14:42] <nmatsakis> or maybe bytes(u8)
[15:14:44] <nmatsakis> I don't know
[15:14:52] <bstrie> just for nominal-ness?
[15:15:11] <nmatsakis> well, the main reason would be for more type safety, right -- 
[15:15:15] <nmatsakis> like, a raw integer is kind of a weird thing
[15:15:29] <nmatsakis> it almost always has a unit to make sense
[15:15:29] <bstrie> hmm
[15:15:32] <nmatsakis> except for maybe multipliers
[15:15:35] <nmatsakis> but that unit is carried in your head
[15:15:39] <nmatsakis> you can use newtypes of course 
[15:15:50] <nmatsakis> some languages (notably F#) integrate units as a first-class thing
[15:15:59] <nmatsakis> I think the main advantage of this is to get smoother stuff like
[15:16:07] <nmatsakis> 23 km / 22 sec
[15:16:14] <nmatsakis> yielding a type of (23/22) (km/sec)
[15:16:26] <nmatsakis> dimension analysis, in other words
[15:16:31] <nmatsakis> (I think that's what it's called?)
[15:16:35] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[15:16:35] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/g9HCiQ
[15:16:35] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[15:16:36] <nmatsakis> anyway, this is just idle musing.
[15:16:43] <nmatsakis> I was just thinking that it we could see what the set of units are,
[15:16:53] <nmatsakis> we would be able to validate my hypothesis that many integers count things in memory
[15:16:56] <nmatsakis> and so on
[15:17:07] *** Quits: andrew-__ (andrew-d_w@4CCE6E0C.339B431B.1E537B93.IP) (Input/output error)
[15:17:30] *** Joins: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net)
[15:18:38] <bstrie> wondering what happens if you do 20 km / 10 cm
[15:18:44] <bstrie> do the units just go away?
[15:18:55] <nmatsakis> I presume so
[15:19:03] <nmatsakis> http://msdn.microsoft.com/en-us/library/dd233243.aspx
[15:19:34] <bstrie> it's an alluring idea, but I'm afraid it would be beyond our scope
[15:20:07] <nmatsakis> as I said, just idle musing.
[15:20:14] <nmatsakis> I'm not making any serious proposals for Rust
[15:21:39] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[15:21:39] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/1NIFHw
[15:21:39] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[15:21:42] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[15:21:42] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/-CUS_Q
[15:21:42] <ghrust> 13rust/06auto 146dd4195 15Eduard Burtescu: Removed @self and @Trait.
[15:21:42] <ghrust> 13rust/06auto 14356cdb1 15bors: auto merge of #12030 : eddyb/rust/kill-at-self-and-trait, r=pcwalton
[15:21:43] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[15:25:16] *** Quits: canhtak (canhtak@moz-8DFB5E6A.wl.t.ulaval.ca) (Quit: canhtak)
[15:26:13] *** Joins: sunfish (chatzilla@moz-8DE7F965.dsl.dynamic.sonic.net)
[15:31:23] *** Quits: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net) (Input/output error)
[15:32:22] <bstrie> question
[15:33:12] <bstrie> if `Foo` is a trait, the only difference between `fn bar<T: Foo>(x: ~T)` and `fn bar(x: ~Foo)` is that the former is monomorphized and the latter uses vtables
[15:33:15] <bstrie> right?
[15:35:42] <bstrie> because if so, I'm wondering if it would be possible to optimize the latter form into monomorphization, or if there's any reason why we wouldn't want to do that
[15:37:29] <eddyb> bstrie: I have a RFC about that
[15:37:48] *** Joins: canhtak (canhtak@moz-8DFB5E6A.wl.t.ulaval.ca)
[15:38:23] <eddyb> well, it was intended to make fn bar(x: Foo) meaningful (an implicit generic), but that doesn't support pointers (because they already refer to trait objects)
[15:38:52] <eddyb> then I tried to expand it to monomorphization and I got a bunch of comments against it
[15:38:59] <bstrie> eddyb: right, that's sort of what I was thinking of, but not for rust, for my imaginary magical rust-like language :)
[15:41:03] <eddyb> bstrie: fn foo() -> Foo is one of the ways we could implement returning anonymous types (which implement certain traits)
[15:47:42] <nmatsakis> bstrie: you can certainly do it, it's bsaically a kind of inlining -- specialization
[15:48:06] <nmatsakis> bstrie: the main problem becomes this tradeoff between code size / duplication and vtable cost (which isn't necessarily that high)
[15:48:25] <nmatsakis> I haven't looked at this research in great detail, but it's a kind of aggressive code transformation,
[15:48:43] <nmatsakis> so my assumption is that it will wind up with the usual pattern for such compiler opts:
[15:48:50] <nmatsakis> works great for many programs, terrible for others, kind of a wash for many
[15:49:20] <nmatsakis> that said, fn bar<T:Foo>(x: ~T) is much more flexible in some respects,
[15:49:31] <nmatsakis> since you can write: fn bar<T:Foo>(x: ~T, y: ~T) and you know that both x and y have the same type
[15:49:36] <nmatsakis> (unlike x: ~Foo, y: ~Foo)
[15:49:56] <bstrie> nmatsakis: good point
[15:50:07] <nmatsakis> I shouldn't say more flexible
[15:50:12] <nmatsakis> rather, differently flexible
[15:50:26] <nmatsakis> you want an object type when you have a list of hetergenenous things
[15:50:33] <nmatsakis> ~[~Shape] or something
[15:51:32] *** Quits: Zr40 (zr40@EE4BB9F5.926C319A.BE2F4011.IP) (Quit: leaving)
[15:54:45] <eddyb> nmatsakis: did you have a DST task list yet?
[15:55:08] *** Quits: NiccosSystem (NiccosSyst@AB1AFDE.FC7B0C35.A7597CB6.IP) (Ping timeout)
[15:55:46] <eddyb> s/did/do/
[15:55:49] <nmatsakis> eddyb: not yet
[15:56:29] <eddyb> ping me when you do. this fiddling is exhausting
[16:02:58] *** Joins: erickt (Adium@991D7890.9C346C7F.FAA4474F.IP)
[16:05:00] *** Quits: bytbox (s@moz-54E13927.washdc.fios.verizon.net) (Ping timeout)
[16:06:35] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[16:06:35] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/unxTRw
[16:06:35] <ghrust> 13rust/06auto 14b653fa0 15Seo Sanghyeon: Avoid cloning ast::CrateConfig
[16:06:35] <ghrust> 13rust/06auto 145719ff7 15Seo Sanghyeon: Fix expansion tests
[16:06:36] <ghrust> 13rust/06auto 14f039d10 15bors: auto merge of #12048 : sanxiyn/rust/crate-config, r=alexcrichton
[16:06:38] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[16:10:06] <eddyb> :( how am I supposed to know all the check-stage1-* targets?
[16:10:31] <eddyb> and I thought the manual was so out of date that I didn't expect it to be tested *sigh*
[16:12:00] *** Joins: Tari (tari@moz-36ED7575.lug.mtu.edu)
[16:20:07] *** Quits: erickt (Adium@991D7890.9C346C7F.FAA4474F.IP) (Quit: Leaving.)
[16:21:46] *** Joins: NiccosSystem (NiccosSyst@AB1AFDE.FC7B0C35.A7597CB6.IP)
[16:24:26] *** Quits: sunfish (chatzilla@moz-8DE7F965.dsl.dynamic.sonic.net) (Client exited)
[16:28:17] *** kimundi is now known as zz_kimundi
[16:29:24] <bstrie> so is try!() just "allow me to ignore return types and fail if any of them error"?
[16:32:30] <SiegeLord> I don't think it fails
[16:33:39] <SiegeLord> I don't quite get what is the point of IoResult though
[16:34:45] <SiegeLord> And, alternatively, is that the pattern we're meant to follow in user code... i.e. make our own result type
[16:35:24] <SiegeLord> Oh, IoResult is Result... nvm
[16:38:59] *** Quits: sokomo (sokomo@8293D4FC.93FF164A.408809BB.IP) (Quit: Read error: Connection reset by peer)
[16:41:14] *** Joins: Zr40 (zr40@moz-CCFEAB92.adsl.xs4all.nl)
[16:41:15] <eddyb> dbaupp, sfackler, cmr: r=pcwalton? https://github.com/mozilla/rust/pull/12030 (I hope this is the last weird test that I trip)
[16:41:33] <eddyb> I'll be back in half an hour
[16:47:07] *** Quits: NiccosSystem (NiccosSyst@AB1AFDE.FC7B0C35.A7597CB6.IP) (Client exited)
[16:47:58] *** Joins: Kxepal832 (Miranda@moz-1E141C63.pppoe.mtu-net.ru)
[16:48:24] *** Quits: Kxepal (Miranda@moz-C2AD231E.pppoe.mtu-net.ru) (Ping timeout)
[16:52:56] *** Joins: dherman (dherman@moz-DFAA4E15.p2p.sfo1.mozilla.com)
[16:52:56] *** ChanServ sets mode: +ao dherman dherman
[16:53:10] *** Quits: lpy (lpy@B3BE13AC.47A0616D.E99F7FDB.IP) (Client exited)
[16:54:10] *** Joins: sunfish (chatzilla@moz-8DE7F965.dsl.dynamic.sonic.net)
[17:00:06] *** Quits: Kxepal832 (Miranda@moz-1E141C63.pppoe.mtu-net.ru) (Quit: Kxepal832)
[17:00:24] *** Joins: Kxepal (Miranda@moz-1E141C63.pppoe.mtu-net.ru)
[17:06:13] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[17:06:32] <flaper87> acrichto: r? https://github.com/mozilla/rust/pull/12017
[17:06:34] <flaper87> brb
[17:08:01] *** Joins: tjc (tjc@moz-6EB4E533.dsl.tsoft.com)
[17:08:01] *** ChanServ sets mode: +o tjc
[17:16:35] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[17:16:35] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/unxTRw
[17:16:35] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[17:16:57] *** Quits: canhtak (canhtak@moz-8DFB5E6A.wl.t.ulaval.ca) (Quit: canhtak)
[17:21:32] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[17:21:32] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/QEYIqQ
[17:21:32] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[17:21:33] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[17:21:34] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/wGzTtw
[17:21:34] <ghrust> 13rust/06auto 145d6bed8 15Florian Hahn: Remove reference to @str in comment
[17:21:34] <ghrust> 13rust/06auto 1466b9c35 15bors: auto merge of #12053 : fhahn/rust/remove-str-in-comment, r=alexcrichton...
[17:21:34] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[17:23:50] *** Joins: lpy (lpy@B3BE13AC.47A0616D.E99F7FDB.IP)
[17:23:58] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[17:25:25] *** Quits: lpy (lpy@B3BE13AC.47A0616D.E99F7FDB.IP) (Connection reset by peer)
[17:25:37] *** Joins: lpy (lpy@B3BE13AC.47A0616D.E99F7FDB.IP)
[17:26:53] <eddyb> cmr: "a minute ago" *I just got back*
[17:27:48] *** Quits: lpy (lpy@B3BE13AC.47A0616D.E99F7FDB.IP) (Ping timeout)
[17:28:55] *** Joins: brson (brson@moz-DFAA4E15.p2p.sfo1.mozilla.com)
[17:28:55] *** ChanServ sets mode: +qo brson brson
[17:32:33] <eddyb> cmr: turns out LinkedIn is good for something :P
[17:36:17] *** Quits: dherman (dherman@moz-DFAA4E15.p2p.sfo1.mozilla.com) (Quit: dherman)
[17:38:37] *** Joins: canhtak (canhtak@moz-8DFB5E6A.wl.t.ulaval.ca)
[17:39:26] <carter> cmr: whats this about error monads?
[17:39:29] <carter> cmr: ohhhh,
[17:39:40] <carter> cmr AFK most of thiis week
[17:39:54] <carter> BUT: ghc has a special extensible type / type class for exceptions
[17:40:03] <carter> (i forget which)
[17:46:53] *** Joins: nrc|waitangiday (nrc@7BE24E90.A5032A01.3CFC199D.IP)
[17:47:44] <eddyb> cmr: bleah, volunteering doesn't do what I wish it did :/
[17:47:52] <cmr> eddyb: hm?
[17:48:58] *** nrc|waitangiday is now known as nrc
[17:51:48] *** Quits: brson (brson@moz-DFAA4E15.p2p.sfo1.mozilla.com) (Ping timeout)
[17:55:44] <olsonjeffery> cmr: hey, how does the "from sh import rustc" mechanism work in cargo-lite?
[17:55:50] <olsonjeffery> i have rustc in my path (i do a local install)
[17:55:56] <olsonjeffery> but getting the error msg nonetheless
[17:56:21] <olsonjeffery> whoops, wrong chan. sorry..
[17:58:44] *** Joins: dherman (dherman@moz-DFAA4E15.p2p.sfo1.mozilla.com)
[17:58:44] *** ChanServ sets mode: +ao dherman dherman
[18:00:33] *** Joins: brson (brson@moz-DFAA4E15.p2p.sfo1.mozilla.com)
[18:00:33] *** ChanServ sets mode: +qo brson brson
[18:01:30] <bstrie> brson: I think it's time to remove the line "optional task-local GC" from the website
[18:01:42] <bstrie> brson: people seem to be assuming that it's "optional" in the same vein as D's is
[18:02:35] <brson> bstrie: ok
[18:02:57] <brson> i'd like to rewrite the website soonish. need a new elevator pitch
[18:03:04] <bstrie> yeah
[18:03:27] <pnkfelix> maybe "task-local memory management" would be a more general and more appropriate phrase...
[18:03:31] <bstrie> brson: I've come up with some new pitches, but they all center around emphasizing that we're as fast as C++, but I don't know if that's really broadly true yet :)
[18:04:25] <eddyb> bstrie: we can sometimes do better, but we need to empower LLVM some more to actually get there
[18:04:36] *** Joins: pcwalton (pcwalton@moz-DA87EE4.hsd1.ca.comcast.net)
[18:04:36] *** ChanServ sets mode: +ao pcwalton pcwalton
[18:19:05] <bstrie> eddyb: well it's not just enough to say it... all my pitches have also imagined that there would be links to pages with graphs of us vs C++, sort of like http://speed.pypy.org/
[18:20:26] *** Quits: sunfish (chatzilla@moz-8DE7F965.dsl.dynamic.sonic.net) (Ping timeout)
[18:26:22] *** Joins: lpy (lpy@B3BE13AC.47A0616D.E99F7FDB.IP)
[18:28:27] *** Quits: lpy (lpy@B3BE13AC.47A0616D.E99F7FDB.IP) (Ping timeout)
[18:31:34] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[18:31:34] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/wGzTtw
[18:31:34] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[18:34:07] <flaper87> acrichto: thanks for the review. I just rebased the patch and I'm running the checks locally now. I'll push a new version soon
[18:34:24] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[18:36:31] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[18:36:31] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/5zjJ1g
[18:36:31] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[18:36:33] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[18:36:33] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/UaFlSQ
[18:36:33] <ghrust> 13rust/06auto 1445463b5 15Alex Crichton: Redesign output flags for rustc...
[18:36:33] <ghrust> 13rust/06auto 14a25157d 15bors: auto merge of #12020 : alexcrichton/rust/output-flags, r=brson...
[18:36:33] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[18:37:33] *** Quits: tjc (tjc@moz-6EB4E533.dsl.tsoft.com) (Ping timeout)
[18:37:46] <bstrie> dead code elimination pass just caught a bug
[18:37:51] <bstrie> awesome
[18:53:42] <eddyb>     // For reasons I cannot fully articulate, I do so hate the AST map, and I regard each time that I use it as a personal and moral failing, but at the moment it seems like the only convenient way to extract the ABI. - ndm
[18:53:48] <bstrie> pcwalton: would structural constraints (or whatever we're calling single inheritance) have allowed us to use fields in default methods?
[18:53:52] <eddyb> am I reading ancient tumb stones?
[18:53:58] <pcwalton> yes
[18:54:30] <eddyb> pcwalton: I know how to have the fast field access through trait pointers that servo needs without forcing single inheritance - did I tell you that?
[18:54:54] <pcwalton> eddyb: hmm, how?
[18:55:51] <eddyb> pcwalton: you've seen fields-in-traits proposals that support multiple inheritance, but where virtual field access (if needed, like in servo) is costlier than the inheritance model?
[18:56:09] <pcwalton> not sure what that means
[18:56:10] *** Joins: jdm (jdm@3352147E.CB4C8069.74119F78.IP)
[18:56:13] <eddyb> it's that + optional fixed layout, inspired by cap'n-proto
[18:56:52] <eddyb> pcwalton: mkay, so, trait Node {parent: Js<Node> @ 0; next: Js<Node> @ 1; ... methods ... }
[18:57:13] <pcwalton> ah, we discussed something like that
[18:57:24] <pcwalton> we went with inheritance because it was easier to reason about but we could potentially revisit that
[18:57:27] <eddyb> the fixed field positions are optional and provide the optimization that servo would need, without restricting anything to single
[18:57:37] <eddyb> pcwalton: of course none of my ideas are original :P
[18:58:02] <eddyb> once you have single inheritance, it's hard to get rid of it or extend :/
[18:59:57] *** Joins: rca_ (rcatolino@moz-81882D6F.adsl.proxad.net)
[19:01:22] *** Quits: rca (rcatolino@moz-312D09C6.adsl.proxad.net) (Ping timeout)
[19:02:52] *** Quits: brson (brson@moz-DFAA4E15.p2p.sfo1.mozilla.com) (Ping timeout)
[19:03:50] *** zz_kimundi is now known as kimundi
[19:05:39] *** Joins: brson (brson@moz-DFAA4E15.p2p.sfo1.mozilla.com)
[19:05:39] *** ChanServ sets mode: +qo brson brson
[19:08:10] <eddyb> I'm tempted to rename "items" to "map", so that the codde makes sense
[19:08:24] <eddyb> *code. but it might as well be cod
[19:08:58] *** Joins: sunfish (chatzilla@moz-BBE3ABD.mv.mozilla.com)
[19:10:22] *** Joins: lkuper (lkuper@moz-D862222C.dhcp-bl.indiana.edu)
[19:10:44] <nrc> nmatsakis: do you have a plan for the variance stuff I could look at?
[19:12:24] <nmatsakis> nrc: I don't have a written out plan, but there is a model to follow (roughly what we do for region parameters)
[19:12:31] <nmatsakis> nrc: I can point you at the relevant bits of code
[19:12:38] <nmatsakis> nrc: essentially we already infer the variance for the type parameters,
[19:12:41] <nmatsakis> nrc: we just don't make use of it
[19:12:54] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Ping timeout)
[19:15:35] <nrc> nmatsakis: that's an interesting approach - no language has done variance well so far, I think. Is there a precedent for inferring variance?
[19:15:54] *** Quits: ggherdov_ (sid11402@moz-E77DEB21.irccloud.com) (Ping timeout)
[19:16:33] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[19:16:33] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14a25157d to 1466b9c35: 02http://git.io/N3iJvQ
[19:16:33] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[19:16:35] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[19:16:35] <ghrust> 01[13rust01] 15bors pushed 5 new commits to 06auto: 02http://git.io/ncmUdg
[19:16:35] <ghrust> 13rust/06auto 149752c63 15Arcterus: Move getopts out of extra
[19:16:35] <ghrust> 13rust/06auto 14c09ca94 15Arcterus: getopts: replaced base functions with those from group
[19:16:36] <ghrust> 13rust/06auto 142ce7019 15Arcterus: getopts: unify tests
[19:16:37] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[19:16:58] <nmatsakis> nrc: I don't know of other languages that infer variance, no. I took the algorithm from some recent research,
[19:17:10] <nmatsakis> nrc: you can find it in src/librustc/middle/typeck/variance.rs
[19:17:26] <nmatsakis> nrc: basically the plan was just to use decl site variance,
[19:17:43] <nmatsakis> nrc: though we get a *little bit* of use-site variance based on our rules that govern &T,
[19:17:52] <nmatsakis> i.e., &T <: &U if T <: U
[19:17:58] <nmatsakis> but &mut T <: &mut T
[19:17:59] *** Quits: jdm (jdm@3352147E.CB4C8069.74119F78.IP) (Ping timeout)
[19:18:11] <nmatsakis> it'd be neat to extend the subtyping rules
[19:18:15] <nmatsakis> to consider more use-site context
[19:18:23] <nmatsakis> but I hadn't planned to do that bceause it required I think too hard
[19:18:33] <nmatsakis> and it seems like something that would be strictly more permissive 
[19:18:46] <nrc> :-)
[19:18:48] <nrc> yes
[19:19:39] *** Joins: ggherdov_ (sid11402@moz-E77DEB21.irccloud.com)
[19:20:11] *** Joins: lpy (lpy@B3BE13AC.47A0616D.E99F7FDB.IP)
[19:21:16] *** Joins: jdm (jdm@1F05EAB6.1AD9726E.74119F78.IP)
[19:21:27] <nrc> Wait, there are two papers by different authors, both at PLDI '11 called Taming the Wildcards: ....
[19:21:39] <nrc> That is bizarre 
[19:22:09] <nrc> I think I might have reviewed one of them, but I can't remember which :-p
[19:22:12] <nmatsakis> nrc: yes
[19:22:14] <nmatsakis> it was confusing
[19:22:22] *** Quits: lpy (lpy@B3BE13AC.47A0616D.E99F7FDB.IP) (Ping timeout)
[19:22:42] <nrc> so second time lucky, I have the right one...
[19:22:52] <nmatsakis> nrc: are you interested in tackling that issue? we'll want to draw up some tests :) the other thing to get right is the interaction with "Vtable matching" (type class matching)
[19:23:11] <nmatsakis> that's a bit more subtle, afaik there is't much work on the intersection of subtyping and type classes,
[19:23:22] <nmatsakis> but I wrote up somewhere a description of how to explain it
[19:23:30] <nmatsakis> possibly in the code, possibly in an issue, I'd have to find it :)
[19:23:38] <nmatsakis> might make a nice paper too
[19:24:01] <nmatsakis> not rocket science
[19:24:33] <nmatsakis> I hvae to find the existing issue now
[19:25:31] *** Quits: dherman (dherman@moz-DFAA4E15.p2p.sfo1.mozilla.com) (Quit: dherman)
[19:28:12] <nrc> nmatsakis: sure, I can look at it
[19:28:29] <nrc> we only wanted to have a spec and be aware of interactions for 1.0, right?
[19:28:38] <nrc> (having meetings before breakfast is hard)
[19:29:47] <nmatsakis> nrc: we have to fix the bug in vtable matching, it allows for unsound impl matches
[19:29:58] <nmatsakis> other uses of variance are not strictly required, but I think it's only a few lines of code
[19:30:11] <nrc> ok
[19:30:15] <nmatsakis> ah, here it is https://github.com/mozilla/rust/issues/5781?source=cc
[19:31:09] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[19:31:09] <ghrust> 01[13rust01] 15alexcrichton 04force-pushed 06try from 14be6c372 to 1410db5b5: 02http://git.io/k471pw
[19:31:09] <ghrust> 13rust/06try 1410db5b5 15Alex Crichton: Upgrade LLVM...
[19:31:09] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[19:31:11] <nrc> ta
[19:31:12] <acrichto> pcwalton: ^
[19:31:21] <pcwalton> cool
[19:31:37] <acrichto> praying they didn't turn on c++11 jst yet
[19:33:26] <nrc> nmatsakis: I've been reading some blog posts too - borrow checking closures looks really good. I have some question about dst, do you have some time for them?
[19:35:28] *** Joins: bytbox (s@moz-54E13927.washdc.fios.verizon.net)
[19:37:17] <nmatsakis> nrc: sure
[19:39:40] <nrc> nmatsakis: cool, thanks. So, by fat-struct and your subtype rules, it looks like I can pass a struct with a thin pointer as the last field where the type system expects a struct with a fat pointer as the last field - is that right? Or is the struct copied?
[19:40:47] <eddyb> hang on, there was only one PR before me, now there's two :(
[19:41:03] <nmatsakis> nrc: note that those rules were *coercion* rules, if I understand you, not subtyping
[19:41:31] <nmatsakis> nrc: the distinction being that coercion (possibly) requires adapting the value
[19:41:46] <nmatsakis> nrc: whereas subtyping means the exact same memory with no changes can be treated as the subtype
[19:41:52] <nmatsakis> nrc: at least the distinction as I am using it:)
[19:41:59] <nmatsakis> nrc: in other words, the stuct is copied
[19:42:06] <eddyb> will we get trait -> supertrait coercion?
[19:42:28] <nmatsakis> that should be possible, I think, it's just a matter of swapping the vtable
[19:42:40] <eddyb> yupp. useful for traits inheriting Any
[19:42:44] <nmatsakis> (means that each vtable needs links to the super vtables)
[19:43:09] <eddyb> or you can adjust the vtable pointer to the offset of the sub-vtable
[19:43:28] <nmatsakis> there may not always be an offset
[19:43:35] <nmatsakis> if there are multiple supertraits
[19:43:44] <nmatsakis> oh, well, you can make redundant layouts
[19:43:46] <nrc> OK, that is good :-)
[19:43:47] <nmatsakis> either way
[19:43:52] <eddyb> (sub as in memory layout)
[19:44:43] <acrichto> pcwalton: http://buildbot.rust-lang.org/builders/try-win/builds/877/steps/compile/logs/stdio
[19:44:48] <acrichto> sadface
[19:44:59] <pcwalton> weird
[19:45:02] <pcwalton> any idea?
[19:45:09] <nrc> nmatsakis: how do you decide whether a coercion requires copying or not?
[19:45:28] <eddyb> the vtable layouts should be statically known
[19:45:36] <acrichto> pcwalton: I'll investigate a bit
[19:45:39] <pcwalton> ok
[19:45:49] <eddyb> nmatsakis: the main redundancy is the dtor
[19:45:52] <acrichto> pcwalton: confirmed fix for https://github.com/mozilla/rust/issues/10613 though
[19:46:01] <pcwalton> nice :)
[19:48:58] <nmatsakis> pcwalton: so I was tlaking to wycats and I had a thought about lifetime errors
[19:49:10] <nmatsakis> curious to hear your opinion
[19:49:25] <nmatsakis> basically the idea is to (1) make it an error to have an anonymous (omitted) lifetime in a return type, BUT:
[19:49:43] <nrc> nmatsakis: is the copy for non-subtyping coercions deep or shallow?
[19:49:50] <nmatsakis> (2) if the return type has the form &T, and there is a exactly one parameter of the form &U, we implicitly link their lifetimes,
[19:50:13] <pcwalton> eh, I think it's too magical unless you do it solely for the purpose of error reporting
[19:50:16] <nmatsakis> and (3) if there are multiple such, we print a targeted error suggested how the code could be changed, saying to the user they must choose a parameter to link the lifetime of the return value
[19:50:29] <nmatsakis> and (4) if there are no such inputs, it's got to be invalid.
[19:50:38] <pcwalton> for error reporting, +1 from me though
[19:50:38] <wycats> pcwalton: how is it magical?
[19:50:41] <nmatsakis> you could conflate cases 2 and 3
[19:50:42] <wycats> it's basically the opposite of magic
[19:50:48] <pcwalton> it's magical because adding a new parameter adds an error
[19:50:51] <pcwalton> results in an error
[19:50:55] <nmatsakis> I don't think that's so magical
[19:50:57] <wycats> a really easy to understand error
[19:51:00] <pcwalton> adding a new parameter should never result in an error
[19:51:00] <nmatsakis> the error says: "You must choose which parameter"
[19:51:02] <nmatsakis> before there was only one
[19:51:05] <wycats> because you have gone from unambiguous to ambiguous
[19:51:05] <nmatsakis> so why would you choose?
[19:51:23] <nmatsakis> nrc: sorry, i'm not sure I understand
[19:51:25] <pcwalton> the language shouldn't allow the ambiguity in the first place
[19:51:29] <wycats> pcwalton: there are many places where adding a parameter can produce an error ;)
[19:51:33] <wycats> pcwalton: it doesn't
[19:51:35] <pcwalton> not at the call site
[19:51:39] <pcwalton> err
[19:51:40] <pcwalton> not at the definition site
[19:51:42] <nmatsakis> pcwalton: what ambiguity?
[19:51:50] <wycats> pcwalton: the proposal is that the ambiguity is disallowed at the definition site
[19:51:54] <nmatsakis> oh, you mean which parameter it's linked to?
[19:52:12] <wycats> but that you don't have to choose if it's unambiguous
[19:52:26] <pcwalton> I find it very strange that adding a new parameter should ever result in an error at the definition site
[19:52:37] <eddyb> at this point I just want to be able to click on errors and get to the right line...
[19:53:00] <eddyb> I guess I could if I were using kdevelop's script functionality. but I add so many weird things to my commands!
[19:53:07] * eddyb is a bit tired
[19:53:13] <nmatsakis> pcwalton: I can see that, though I'm not sure it's an important principle.
[19:53:57] <pcwalton> maybe it's not, but I'm worried about violating it
[19:54:07] <pcwalton> it's the kind of thing that we've been burned by in the past
[19:54:10] <wycats> pcwalton: the mental model here is:
[19:54:24] <wycats> when you type in the first parameter, there is no ambiguity, so we pick a lifetime for you
[19:54:35] <wycats> when you type the second parameter, the error message tells you precisely what has happened
[19:54:47] <wycats> namely that you need to choose a lifetime because it is now ambiguous
[19:54:50] <pcwalton> the problem is that I don't think adding another parameter should ever result in an error
[19:54:50] <wycats> and shows you an example
[19:54:58] <pcwalton> at the definition site
[19:54:58] <wycats> but how will it practically burn someone
[19:55:23] <pcwalton> I guess I can't think of an example off the top of my head
[19:55:31] <pcwalton> it just doesn't sit well with me for some reason
[19:55:48] <nmatsakis> I think there is a bit of a judgement call; picking a default allows you to coast in ignorance of lifetime parameters a little longer
[19:55:54] <nmatsakis> this is precisely what wycats wants, I think,
[19:56:04] <pcwalton> I think you don't get to coast in ignorance of lifetime parameters when programming Rust
[19:56:18] <nmatsakis> but also something we've found to be a problem in the past
[19:56:24] <nmatsakis> note that I said *a little longer*
[19:56:28] <pcwalton> I'm pretty convinced that sweeping them under the rug just doesn't work
[19:57:19] <wycats> I think that making people type something that is obviously unnecessary as a compiler incantation early on is bad
[19:57:34] <wycats> and what we're talking about making optional *is* a compiler incantation
[19:57:34] <pcwalton> we do that all the time though; for example, type signatures
[19:57:49] <wycats> we already make explicit lifetimes optional in many cases
[19:57:52] <pcwalton> the compiler *could* figure out type signatures in many cases
[19:57:58] <wycats> yes, that's cross-function
[19:58:08] <wycats> the (very good) rule is no cross-function inference
[19:58:09] <pcwalton> but we make them type it because it makes things simpler
[19:58:16] <wycats> this doesn't add new cross-function inference
[19:58:22] <wycats> it's not just implementation simplicity
[19:58:29] <wycats> it makes the interface easy to see in code
[19:58:57] <pcwalton> I guess if you're just talking about giving a meaning to unadorned "&" in a return value where previously that was always a hard error, I won't stand in the way
[19:59:12] <pcwalton> but I will stand by my general unease :)
[19:59:29] <nmatsakis> (I would be opposed to any kind of inference in signatures, i.e., I don't want to consult the function body)
[19:59:39] <nmatsakis> (or at least very, very cautious)
[20:00:12] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[20:00:16] <wycats> nmatsakis: I think the hard rule that would require a change in current *philosophy* would be cross-function inference
[20:00:34] <wycats> like, I would feel comfortable saying in a talk that the current rule on that is intentional and for good reason
[20:00:35] <pcwalton> ok, let me articulate my concern
[20:00:38] <wycats> ok :)
[20:00:44] <pcwalton> when the compiler infers the lifetime of &
[20:00:53] <pcwalton> people are going to try to return all kinds of things incorrectly
[20:00:58] <pcwalton> & in a return type, that is
[20:01:11] <pcwalton> and the error messages will be more confusing than if we had just been up front with lifetimes
[20:01:14] <strcat> also can't infer without the source
[20:01:21] <wycats> pcwalton: how can that be
[20:01:27] <nmatsakis> strcat: what does that mean?
[20:01:38] <nmatsakis> strcat: i.e., in a binary distribution?
[20:01:41] <pcwalton> the compiler will see something like
[20:01:54] <pcwalton> fn get(x: &MyStruct) -> &int { â€¦ }
[20:01:56] <wycats> what we're saying is that fn foo(bar: &Bar) -> &Baz is just syntactic shorthand for fn foo<'a>(&'a Bar) -> &'a Baz
[20:01:58] <strcat> nmatsakis: I mean the compiler will have to output the *real* return type in the metadata
[20:02:03] <pcwalton> and say, ok, there's a lifetime linking these two things
[20:02:08] <pcwalton> then someone tries to write
[20:02:16] <pcwalton> let x = 10; return &x;
[20:02:19] <pcwalton> which people *will* write
[20:02:20] <strcat> nmatsakis: so it works... but it just seems a bit odd
[20:02:22] <nmatsakis> strcat: naturally (but actually with this rule it isn't necessary)
[20:02:28] <pcwalton> and then the compiler will complain about the lifetime not being linked to the struct
[20:02:32] <pcwalton> but people will be very confused
[20:02:32] <Eridius> huh, I didn't realize the compiler inferred a lifetime there. I thought it had to be explicit
[20:02:39] <pcwalton> Eridius: we're talking about inferring it
[20:02:42] <Eridius> ahh
[20:02:44] <pcwalton> because the struct was never mentioned anywhere!@
[20:02:45] <nmatsakis> strcat: but that's not odd, that's whta we always do -- I mean you input a textual form, we convert it to a binary one, we expand type aliases, etc
[20:02:52] <Eridius> pcwalton: I share your concern. I think the lifetime needs to be explicit
[20:02:55] <pcwalton> why is the compiler talking about the struct parameter, I never talked about it!
[20:02:57] <wycats> pcwalton: people write it today
[20:02:59] <nmatsakis> (I personally wouldn't call it inference, but rather defaulting)
[20:03:02] <wycats> I wrote it by accident this week
[20:03:14] <wycats> I don't see why we couldn't write a good error message for that case
[20:03:19] <Eridius> if a function returns a reference, it needs to be clear what the lifetime of the reference is
[20:03:35] <pcwalton> if we just forbid returning unannotated &int, then we can use the opportunity to educate people about lifetimes
[20:03:47] <Eridius> the only case where it seems to me to be useful to infer is writing methods on &self, because returning a reference to the inside of self seems reasonably common
[20:03:52] <Eridius> but special-casing that doesn't sit right with me
[20:03:54] <pcwalton> whereas if we sweep it under the rug, trying to make people not have to worry about lifetimes for "a little longer"
[20:04:02] <pcwalton> then they will *still* have to worry about lifetimes
[20:04:02] *** Quits: brson (brson@moz-DFAA4E15.p2p.sfo1.mozilla.com) (Ping timeout)
[20:04:05] <pcwalton> it'll just be worse
[20:04:15] <pcwalton> because the compiler will be inferring a lifetime where they didn't write one
[20:04:17] <nmatsakis> that's the part that's unclear, it's certainly better (in general) for people to learn in stages
[20:04:20] <strcat> nmatsakis: well, imo that's working against the existing philosophy to force people to write out the public API
[20:04:20] <nmatsakis> and not all at once
[20:04:26] <wycats> pcwalton: pedagogically front-loading lifetimes where there are right now conflates a lot of things at an inopportune point in the learning cycle
[20:04:33] <strcat> it seems a bit weird to forbid having statics get the type from the RHS etc.
[20:04:44] <pcwalton> there is no way to not pedagogically front-load them
[20:04:46] <pcwalton> when returning references
[20:04:46] <strcat> but then add more complex deduction of types/lifetimes for returns
[20:04:49] <pcwalton> you MUST know about lifetimes
[20:04:49] <wycats> I don't agree that <'a> is part of the "public API" conceptually if there is only a single borrowed parameter
[20:04:56] <wycats> pcwalton: that just isn't true
[20:04:57] <pcwalton> that's just how it is
[20:04:58] <pcwalton> no, it is
[20:04:59] <Eridius> random thought: if an undeclared lifetime shows up on a return type, and the name matches one of the parameters, maybe it should be inferred to be the same lifetime as that param? That makes things at least slightly simpler while still providing explicit lifetimes, although it may be confusing
[20:05:11] <strcat> nmatsakis: I do kind of want return type inference.... since unboxed closures are going to want it
[20:05:12] <wycats> O_O
[20:05:15] <strcat> nmatsakis: but it doesn't sit well with me
[20:05:18] <Eridius> `fn foo(&self, bar: &uint) -> (&'self int, &'bar uint)`
[20:05:28] <wycats> pcwalton: you've been using Rust for a long time
[20:05:32] <wycats> I'm telling you it isn't true
[20:05:32] <strcat> nmatsakis: because to return an unboxed closure, you can't actually give a concrete type (as each has a unique type)
[20:05:34] <nmatsakis> strcat: full return type inference is another matter. this particular proposal is a local default that can be applied withour examining the body.
[20:05:47] <strcat> nmatsakis: ah, you mean it infers from the other parameters only?
[20:05:48] <wycats> people can muddle along far longer than you would want them to
[20:05:59] * strcat missed the initial proposal
[20:06:10] <pcwalton> without lifetimes I don't see a good way to talk about why returning references to the stack is bad
[20:06:15] <nmatsakis> strcat: the precise proposal was basically "if you return &T AND you have exactly one parameter(including self) of type &T, convert both to have some fresh lifetime 'a"
[20:06:31] <Eridius> nmatsakis: surely you don't need the type T to be the same
[20:06:36] <nmatsakis> no no
[20:06:39] <Eridius> otherwise that will only work for e.g. returning subslices of a &str
[20:06:41] <nmatsakis> sorry, &T, &U respectively
[20:07:01] <nmatsakis> the other key part was to give better error messages
[20:07:10] <Eridius> I think this rule is workable, as long as error messages are very clear, but I'm still not really comfortable with it
[20:07:15] <nmatsakis> if the return type is &U and there is not exactly one 
[20:07:27] <nmatsakis> that last part seems uncontroversial ;)
[20:07:35] <nmatsakis> (actually there is someone working on this,
[20:07:39] <nmatsakis> though he's taking a more comprehensive approach)
[20:07:39] <wycats> Eridius: the way to think about it is that if there's only one borrowed argument, it is utterly unambiguous what to do
[20:07:40] <Eridius> although.. I dunno. An un-lifetimed return value isn't particularly useful at the moment, so I suppose this does give utility to that
[20:07:54] <wycats> not after doing a lot of compiler work
[20:07:55] <nmatsakis> there is basically no value to an anonymous lifetime in the return
[20:07:56] <wycats> but just, visually
[20:07:58] <strcat> are you even allowed to return & without a lifetime?
[20:08:00] <wycats> utterly unambiguous
[20:08:04] <Eridius> wycats: well, to someone who doesn't understand lifetimes the problem is it may infer something they didn't intend
[20:08:10] <wycats> it doesn't infer
[20:08:10] <Eridius> e.g. they intended to return a brand new &str, not realizing they can't do that
[20:08:11] <nmatsakis> strcat: you are but the only legal thing you could return is something with static lifetime
[20:08:19] <nmatsakis> strcat: it's basically a guaranteed compilation error
[20:08:20] <wycats> Eridius: yes, the error message should make it obvious that that has happened
[20:08:30] <strcat> nmatsakis: can we just forbid it and make a nice error message pointing to a guide?
[20:08:37] <wycats> "You can only return a reference that is linked to a parameter"
[20:08:39] <nmatsakis> there is an issue on that :)
[20:08:43] <nmatsakis> that's more or less what I'm saying
[20:08:43] <bjz> acrichto: https://github.com/bjz/sax-rs/pull/11#issuecomment-34364177
[20:08:54] <nmatsakis> except with the added rule of giving it a useful meaning in the unambiguous case
[20:09:15] <nmatsakis> there is *one* other possible thing you could return,
[20:09:17] <nmatsakis> and that is static data
[20:09:18] <bstrie> strcat: I may have already opened an issue for that
[20:09:35] <Eridius> I actually kind of like my proposal. Any function with parameters that are references, if the references do not otherwise declare a lifetime, they get a lifetime named after themselves (as long as that doesn't shadow an existing lifetime). So `fn foo(&self) -> &'self uint` would work. Less typing
[20:10:04] <Eridius> well hmm, that runs afoul of the rule that lifetimes can't have keyword names
[20:10:04] <wycats> I like that proposal too
[20:10:08] <Eridius> >_<
[20:10:10] <wycats> :(
[20:10:12] <Eridius> you can't name a lifetime 'self anymore
[20:10:14] <strcat> Eridius: parameters can't have keyword names though
[20:10:15] <nmatsakis> strcat: https://github.com/mozilla/rust/issues/2478
[20:10:18] <strcat> Eridius: except self
[20:10:19] <Eridius> strcat: self
[20:10:35] <nmatsakis> I... don't really like that proposal :)
[20:10:41] <Eridius> bah. it reduces typing
[20:10:42] <nmatsakis> though it's been proposed numerous times
[20:10:50] <Eridius> fn foo<'a>(&'a self) -> &'a uint is slightly verbose
[20:10:51] <nmatsakis> it's not the worst thing ever, I see the appeal
[20:11:01] <nmatsakis> there are all kinds of other situations though it doesn't scale to
[20:11:13] <nmatsakis> less common ones
[20:11:22] <Eridius> sure, and it's not meant to handle those, just the common case
[20:11:23] <wycats> pcwalton: I think you're overly concerned with everyone having a perfect mental model from the get-go
[20:11:30] <Eridius> but the no-keyword-lifetimes rule kind of sinks this proposal
[20:11:33] <wycats> and the proposal actually genuinely reduces unnecessary noise and typing
[20:11:42] <nmatsakis> Eridius: we could potentially drop that rule... or make an exception for self
[20:11:46] <Eridius> true
[20:11:52] <strcat> exceptions :(
[20:11:58] *** Quits: vadimcn (chatzilla@FB06B64.76F9E272.DA40C4B3.IP) (Ping timeout)
[20:12:04] <nmatsakis> Eridius: I guess it's just that it seems to introduce two ways to name lifetimes
[20:12:06] <Eridius> nmatsakis: maybe just change the rule such that you can't _declare_ a keyword lifetime, but you can use one if it exists?
[20:12:24] <nmatsakis> I guess the idea would be:
[20:12:35] *** Joins: vadimcn (chatzilla@FB06B64.76F9E272.DA40C4B3.IP)
[20:12:38] <Eridius> although personally I see no problem with just allowing keyword lifetimes
[20:12:47] <Eridius> heck, I wanted to make `'loop: loop { ... }` and couldn't
[20:12:47] <wycats> c
[20:12:56] <nmatsakis> for each parameter of the form `x: &T`, where `'x` is not already in scope, use `'x` as the name of the anonymous lifetime parameter
[20:13:03] * nmatsakis shrugs 
[20:13:10] <strcat> Eridius: well that's the loop keyword's fault for taking such a nice word ;s
[20:13:16] <wycats> nmatsakis: it's kind of nice
[20:13:32] <Eridius> nmatsakis: it's a simple rule, and really simplifies typing common function signatures. I like it
[20:13:44] <wycats> Eridius: yet you are opposed to the other simple rule ;)
[20:13:53] <Eridius> wycats: :P
[20:14:02] <strcat> wycats: imo the other one isn't simple because it's invisible
[20:14:03] <nmatsakis> it's more typing for the simplest possible case (&T -> &int)
[20:14:05] <Eridius> this rule still makes it explicit what the lifetime of the return value is
[20:14:29] <Eridius> nmatsakis: my objection to that proposal is that the lifetime of the return value is not explicit
[20:14:30] <nmatsakis> I've said this before, but I'd like to see a survey of existing lifetime parameters,
[20:14:34] <Eridius> and that adding new parameters may be confusing
[20:14:38] <wycats> Eridius: it actually is explicit
[20:14:41] <nmatsakis> to find out what patterns there are and what percentage and so on
[20:14:48] <nmatsakis> i.e., what percentage would this rule cover
[20:15:12] <acrichto> pcwalton: looks like mingw builds of llvm are just busted right now: http://lab.llvm.org:8011/builders/clang-native-mingw32-win7
[20:15:16] <Eridius> wycats: there's an unambiguous rule that specifies the lifetime, yes. But it's not explicit in the source
[20:15:26] <acrichto> pcwalton: I think we'll just have to wait for that to go green again
[20:15:27] <wycats> Eridius: depends on your definition of explicit ;)
[20:15:40] <strcat> Eridius: the problem I have with your proposal, is that it will introduce conflicting lifetime names
[20:15:52] <strcat> if you named the impl one 'a, and you have a parameter called 'a'
[20:15:54] <strcat> and use 'a
[20:15:57] <strcat> it might not do what you expect
[20:16:02] <Eridius> I'm also not happy that adding a second (reference) parameter will cause the rule to stop applying. It seems confusing. "why do I need to type lifetimes sometimes but not other times?"
[20:16:15] <wycats> Eridius: you have to type them when it's ambiguous
[20:16:25] <wycats> the error message could make this clear
[20:16:40] <strcat> so
[20:16:52] <strcat> fn foo(x: &T, y: &U) -> &T
[20:16:54] <strcat> is this
[20:17:01] <strcat> fn foo(x: &T, y: &'a U) -> &'a T
[20:17:01] <eddyb> ambiguous
[20:17:03] <strcat> er
[20:17:10] <strcat> fn foo<'a>(x: &'a T, y: &'a U) -> &'a T
[20:17:13] <strcat> so it only works with 1 parameter?
[20:17:21] <Eridius> strcat: your function foo() there does not get wycats's rule applied
[20:17:33] <Eridius> it would behave the same as it does today
[20:17:33] <strcat> so what is wycats's rule
[20:17:47] <Eridius> if there is one and only one reference parameter, that lifetime is used for the return value too
[20:17:55] <Eridius> question: does this apply to structs that take a lifetime?
[20:18:09] <strcat> is it forbidden on methods in an impl with a lifetime?
[20:20:22] <wycats> Eridius: the proposal doesn't apply to structs, unless I'm misunderstanding
[20:20:28] <wycats> strcat: why would it be?
[20:20:40] <strcat> because it's ambiguous
[20:20:55] <strcat> fn foo(&self) -> &T
[20:20:56] *** Joins: lpy (lpy@B3BE13AC.47A0616D.E99F7FDB.IP)
[20:20:57] <strcat> could be
[20:20:59] <strcat> fn foo(&self) -> &'a T
[20:21:01] <strcat> or
[20:21:07] <strcat> fn foo<'b>(&'b self) -> &'b T
[20:21:19] <strcat> where it's impl<'a> ... { }
[20:21:21] <wycats> if it's ambiguous it doesn't apply
[20:21:22] <wycats> period
[20:21:32] <wycats> the rule applies only when the syntax is unambiguous
[20:21:40] <Eridius> wycats: you just contradicted yourself.
[20:21:49] <Eridius> you said it doesn't apply to strcat's case of an impl with a lifetime, but you also said it does apply there
[20:21:51] <wycats> we don't have to worry about pedagogy in that case because the user already used <'a>
[20:21:56] <Eridius> I expect you want it to apply even though a lifetime has been declared
[20:22:03] <wycats> yeah I misunderstood his original question
[20:23:06] *** Quits: lpy (lpy@B3BE13AC.47A0616D.E99F7FDB.IP) (Ping timeout)
[20:23:08] <wycats> Eridius: in principle, perhaps but he's right that it's ambiguous
[20:23:41] <Eridius> I still like my proposal. It allows for reduction of typing, while still being explicit in the source
[20:24:18] <Eridius> the only kink is the potential ambiguity if a lifetime name is already in scope, but I don't expect that to be a real problem
[20:24:46] <nrc> +1 for Eridius's proposal, although IU am very uncomfortable about the possible clashes with already existing lifetime params
[20:24:59] <Eridius> although it would be nice to find out how many functions this proposal could apply to, and how many of them would run afoul of the no-shadowing rule
[20:25:20] * strcat prefers not adding more magic
[20:25:36] <wycats> this really isn't magic
[20:25:37] <Eridius> strcat: is this magic? It's just a default name for generic lifetimes
[20:25:43] * wycats prefers not to use loaded terms like "magic"
[20:25:54] <Eridius> I think associating the return value lifetime with a parameter without actually typing a lifetime name is slightly magic
[20:25:56] <strcat> Eridius: it's another special case making some explicit into an implicit thing
[20:25:56] <wycats> everything that isn't machine code is "magic"
[20:26:09] <strcat> alright then I will define magic as making what is explicit, implicit
[20:26:13] <wycats> auto-dropping things that come in as ~T is "magic"
[20:26:13] <strcat> like auto-ref, auto-deref, auto-slicing
[20:26:22] <strcat> yes, it is
[20:26:24] <wycats> as opposed to explicitly typing drop(thing)
[20:26:29] <strcat> and it makes it harder to see where code runs
[20:26:35] <Eridius> strcat: if everything was explicit we'd be writing binary code
[20:26:35] <wycats> which means that "magic" is meaningless
[20:26:39] <strcat> but I think it is tolerable, because it gives a *lot* back in return
[20:26:51] <strcat> Eridius: not talking about 'implicit' as in 'adds an operation'
[20:26:54] <strcat> I am talking about semantics
[20:27:23] <wycats> there is no way that implicitly linking an output reference to an input reference can be seen as adding semantics
[20:28:04] <strcat> it is like auto-deref
[20:28:22] <nmatsakis> (it's really not)
[20:28:22] <strcat> it reduces the syntactic noise a bit and makes it harder to see what is happening at a glance
[20:28:30] <strcat> well, to me it is
[20:28:33] * pcwalton doesn't care anymore
[20:28:35] <nmatsakis> I'm not 100% following here but there are deep theoretical differences, I feel.
[20:28:54] <pcwalton> all I can say is that every time we've tried to paper over lifetimes we've gotten burned
[20:28:57] <wycats> it's obvious what is happening at a glance
[20:29:06] <Eridius> strcat: I disagree. auto-deref is basically a heuristic. This is an explicit "if A, then B"
[20:29:12] <wycats> pcwalton: I think it's important to identify what we have actually done and how we have actually gotten burned
[20:29:24] <pcwalton> like I said, I don't care
[20:29:24] <strcat> Eridius: auto-deref is still 'if A, then B'
[20:29:28] <strcat> after all it's written in code
[20:29:31] <Eridius> I still don't like having a return value that doesn't declare a lifetime though. I think that people won't understand that it really does have one linked to a parameter
[20:29:41] *** Quits: sunfish (chatzilla@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[20:29:45] <strcat> fn foo(a: &T) -> Foo
[20:29:51] <strcat> where Foo is 'struct Foo<'a> {}'
[20:29:54] <strcat> does it work?
[20:30:08] <strcat> not ambiguous
[20:30:11] <Eridius> I guess a big objection is that, yes, if things fail, there will be good error messages, but when things work, there are no messages explaining why
[20:30:30] <Eridius> so someone who doesn't understand lifetimes will see `fn foo(&self) -> &uint` and not realize that the return value has the lifetime of self
[20:30:44] <Eridius> and that I think is bad, because it will confuse them later when they actually do need to understand lifetimes
[20:30:44] <strcat> fn foo(xs: &[u8]) -> Option<VecIterator>
[20:31:06] <Eridius> whereas `fn foo(&self) -> &'self uint` has an explicit lifetime on the return value, one that someone who isn't aware of the rule can still figure out is the lifetime of self
[20:31:08] <pcwalton> Eridius: you're completely correct IMHO
[20:31:12] <strcat> well in that case it doesn't work since VecIterator has another parameter
[20:31:44] <strcat> nmatsakis: I don't know, maybe I am alone in finding stuff like this to reduce readability
[20:31:49] <pcwalton> strcat: you aren't
[20:31:51] <strcat> I find that default parameters reduce readability too
[20:32:09] <pcwalton> strcat has a good point about lifetime parameters
[20:32:13] <Eridius> strcat: I agree, although default parameters are often useful enough to outweigh that
[20:32:21] <pcwalton> do you apply the rule to &'a T<'a> as well?
[20:32:21] *** Joins: sunfish (chatzilla@moz-BBE3ABD.mv.mozilla.com)
[20:32:27] <pcwalton> if not, why not?
[20:32:33] <strcat> Eridius: well, I'd argue that functional record updates and by-value-self for the builder pattern makes up for it
[20:32:38] <pcwalton> remember that a return type can have *multiple* lifetimes
[20:33:00] <strcat> ok for example, I just wrote a python script using default parameters
[20:33:02] <Eridius> strcat: that can help, but it's still a lot more typing, both in declaring the function and in calling it
[20:33:19] <strcat> I have something like...
[20:33:21] <flaper87> cmr: Do we already have support for contextualized keywords or that'd be something brand new?
[20:33:36] <pcwalton> the rule is just going to end up ad-hoc and IMHO that adds more confusion than is worth it
[20:33:37] <Eridius> flaper87: from what I understand we have no contextualized keywords, but some of us have been pushing for it
[20:33:41] <strcat> def multipart(url, fields, referer=None, cookiejar=None, agent=None)
[20:33:43] <Eridius> for example `in` could be contextual
[20:34:00] <strcat> and there's no way I'm going to type out foo=bar when I'm giving all the params
[20:34:02] <flaper87> Eridius: that's my guess and I'd personally push for it too. In fact, I'd happily work on that myself
[20:34:16] <strcat> and I've made several mistakes this way since it encouraged me to make a function with too many params
[20:34:17] * strcat shrugs
[20:34:30] <strcat> instead of...
[20:34:36] <flaper87> but I think we shouldn't hold the s/extern mod/extern crate/ patch off because of that. I'd rather let it land and then implement contextualized keywords
[20:34:36] <Eridius> strcat: I thought that if you give all params you can skip the keywords? That they're only needed when skipping a param?
[20:34:42] <flaper87> cmr: ^
[20:34:43] <Eridius> e.g. `multipart(url, fields, referrer, agent=foo)`
[20:34:50] <Eridius> flaper87: I agree
[20:34:53] <strcat> Eridius: you can also skip them when you give the first 4 parameters
[20:35:00] <strcat> and the last 2 are keyworded
[20:35:04] <strcat> it works as positional too
[20:35:08] <Eridius> right that's what I'm saying
[20:35:25] <flaper87> acrichto: I already pushed the latest version of the patch and replied to your comments. I basically just rebased it. 
[20:35:52] <Eridius> anyway, I'm going to write up my lifetime proposal as an RFC issue
[20:35:59] <wycats> "I still don't like having a return value that doesn't declare a lifetime though. I think that people won't understand that it really does have one linked to a parameter"
[20:36:06] <wycats> I think people don't initially understand anything
[20:36:15] <wycats> and that people will understand what the error messages teach them
[20:36:22] <pcwalton> what about the case with multiple lifetime parameters?
[20:36:22] <Eridius> wycats: that's the problem right there
[20:36:25] <pcwalton> in the return value
[20:36:28] <pcwalton> err, in the return type
[20:36:29] <Eridius> wycats: correct code needs to not mislead people
[20:36:35] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[20:36:35] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/ncmUdg
[20:36:35] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[20:36:38] <pcwalton> I think strcat's objection is very strong here
[20:36:43] <Eridius> wycats: someone reading through Rust source seeing `fn foo(&self) -> &uint` will not understand that the return value has the lifetime of self
[20:36:51] <wycats> Eridius: correct code "misleads" people who are new all the time
[20:36:51] <pcwalton> you have to make a policy decision and I think whatever you choose will be ad hoc
[20:36:52] <Eridius> wycats: and there are no error messages to explain that
[20:36:57] <wycats> pcwalton: can you restate it concisely?
[20:37:05] <wycats> the policy I proposed is "whenever it's unambiguous"
[20:37:10] <wycats> which doesn't sound ad-hoc to me
[20:37:12] <pcwalton> return types can have multiple lifetime parameters
[20:37:14] *** Joins: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net)
[20:37:14] *** ChanServ sets mode: +o tjc
[20:37:16] <Eridius> wycats: there's a difference between not understanding something, and giving the impression that things are very different than they really are. Such a function will teach people that return values don't need lifetimes
[20:37:19] <wycats> pcwalton: and then it's ambiguous
[20:37:34] <wycats> the current API doesn't teach people much except an incantation
[20:37:50] <wycats> for about 2 months I knew I had to type lifetime incantations but not anything about what they meant
[20:37:55] <wycats> perhaps that makes me a bad programmer
[20:38:06] <pcwalton> why not just make them all infer to the same lifetime?
[20:38:16] <wycats> pcwalton: that isn't the proposal
[20:38:20] <Eridius> wycats: you knew that lifetimes existed, even though you didn't know how to use them
[20:38:24] <wycats> the proposal is "if it's unambiguous, don't require the extra typing"
[20:38:30] <wycats> Eridius: I didn't know what a "lifetime" was
[20:38:33] <wycats> I knew the syntax
[20:38:41] <wycats> I couldn't explain to other people on my team what they were for
[20:38:46] <wycats> only when the incantation was required
[20:38:54] <pcwalton> that's still ambiguous
[20:38:54] <Eridius> wycats: my issue is that this teaches people that lifetimes are not needed, and then they'll get confused when they try and write code and get an error, because no matter how good the error message, it will directly contradict their mental model
[20:39:10] <pcwalton> you just resolved the ambiguity based on the number of parameters
[20:39:13] <pcwalton> look at it this way
[20:39:15] <wycats> they have no mental model to contradict
[20:39:16] <pcwalton> you have N lifetimes
[20:39:25] <pcwalton> you don't know which ones if any are linked
[20:39:29] <pcwalton> N lifetime parameters
[20:39:47] <wycats> there is only one case where you know for sure: you have one input ref and one output ref
[20:39:57] <pcwalton> here are two different examples of three lifetime parameters:
[20:40:13] <pcwalton> fn foo(&'a Foo) -> &'b Foo<'c>
[20:40:22] <pcwalton> fn bar(&'a Foo, &'b Foo) -> &'c Foo
[20:40:46] <wycats> all of those cases are ambiguous and require explicit lifetime parameters in the proposal nmatsakis presented above
[20:41:04] <pcwalton> why is 2 lifetimes not "ambiguous" but 3 lifetimes are "ambiguous"?
[20:41:07] <pcwalton> I guess I don't see that
[20:41:32] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[20:41:32] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/S2tx_w
[20:41:32] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[20:41:35] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[20:41:35] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/Z3vmAw
[20:41:35] <ghrust> 13rust/06auto 146e7968b 15Alex Crichton: Redesign output flags for rustc...
[20:41:35] <ghrust> 13rust/06auto 14c13a929 15bors: auto merge of #12020 : alexcrichton/rust/output-flags, r=brson...
[20:41:36] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[20:41:42] <pcwalton> it's not a question of ambiguity
[20:41:52] <pcwalton> it's a question of special casing the case in which you have exactly 2 lifetime parameters into the language
[20:41:55] <pcwalton> which seemsâ€¦ so ad hoc
[20:42:28] <wycats> pcwalton: I'm confused by your confusion
[20:42:42] <wycats> in the case of 1->1 it is unambiguous what the user must have maent
[20:42:44] <wycats> meant
[20:42:48] <wycats> in any other case, it is not
[20:43:06] <pcwalton> it's also "unambiguous" in the case of 1->2
[20:43:14] <pcwalton> in that anything else will cause an error (well, except 'static)
[20:43:27] <pcwalton> and I assume you aren't considering 'static or else everything is "ambiguous"
[20:43:38] *** Quits: rca_ (rcatolino@moz-81882D6F.adsl.proxad.net) (Ping timeout)
[20:43:59] <pcwalton> 'static is another objection, come to think of it :)
[20:44:07] <pcwalton> everything is "ambiguous" when you consider 'static as a possibility
[20:44:08] *** Quits: sunfish (chatzilla@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[20:44:14] * wycats shrugs
[20:44:29] <wycats> I encourage you to teach a Rust course to a room full of beginners fwiw
[20:44:29] <pcwalton> fn get(&'a Foo) -> &'static int
[20:44:33] <pcwalton> I have :)
[20:44:54] * strcat regularly tricks people into using rust
[20:44:57] <wycats> pcwalton: and in your experience, they don't get overwhelmed by ownership rules and <'a> is straightforward to understand early on?
[20:45:05] <strcat> you'll notice that there are an abnormally large number of arch users in #rust
[20:45:11] <pcwalton> no, they weren't
[20:45:13] <pcwalton> but here's the thing
[20:45:31] <pcwalton> I think if users are getting overwhelmed by ownership rules then that is a problem with the core language
[20:45:40] <pcwalton> not with the surface syntax
[20:45:51] <pcwalton> and if lifetimes are too hard to understand then that's a problem with Rust
[20:45:53] *** Joins: rca (rcatolino@moz-EF98FF5B.adsl.proxad.net)
[20:45:54] <pcwalton> the core of Rust
[20:46:04] <wycats> pcwalton: sure
[20:46:05] <pcwalton> I just don't think we can paper over it
[20:46:08] <wycats> but that's off the table
[20:46:12] <wycats> to discuss
[20:46:22] <wycats> I'm amazed that they weren't overwhelmed
[20:46:22] * Eridius filed https://github.com/mozilla/rust/issues/12072 with his proposal
[20:46:29] <wycats> were they C++ developers?
[20:46:31] <bstrie> strcat: I've also tricked several people into trying rust today, it's a good feeling
[20:46:32] <pcwalton> Stanford students
[20:46:47] <wycats> pcwalton: Stanford students with good knowledge of C++?
[20:46:59] <pcwalton> I don't know what their prior background was but they understood iterator invalidation so probably
[20:47:19] *** Joins: sunfish (chatzilla@moz-BBE3ABD.mv.mozilla.com)
[20:47:23] <strcat> bstrie: well, that's what I do, I have to talk about Arch, cgroups/namespaces/seccomp and systemd here, and then about rust there
[20:47:48] <strcat> and over time, the channels I'm in end up having the same people 
[20:47:55] <strcat> they converge ;p
[20:48:23] <strcat> pcwalton: well, you still have to worry about that even in python/ruby
[20:48:32] <strcat> or java
[20:48:37] <pcwalton> sure, it's not up front though so it doesn't impede learning
[20:48:44] <pcwalton> I'm not saying that Rust is wrong here, btw
[20:48:45] <wycats> pcwalton: yeah, I'm talking about people who don't understand that stuff to begin with
[20:48:48] <pcwalton> I think Rust is *right*
[20:49:01] <strcat> eventually RuntimeError: Set changed size during iteration
[20:49:02] <pcwalton> I agree that we need to do something but I would like to focus on error messages first
[20:49:43] <pcwalton> language tweaks are fine but I lean toward general solutions instead of special case sugar
[20:50:03] <bstrie> are we arguing about forcing you to annotate lifetimes on returned borrowed pointers? +1 if so
[20:50:42] <wycats> pcwalton: I'm open to any general solutions you have in mind
[20:51:00] <wycats> fwiw: I entirely skipped lifetimes in my Ruby talk
[20:51:03] <nmatsakis> fyi
[20:51:10] <nmatsakis> there is someone working on improving lifetime error messages
[20:51:15] <wycats> the net result in that nobody in my talk knows lifetimes
[20:51:18] <wycats> at all
[20:51:26] <nmatsakis> and in particular I am pushing him to show suggested rewrites of the fn sig
[20:51:34] <nmatsakis> for cases where named lifetime parameters are needed but were not included
[20:51:40] <pcwalton> nmatsakis: I want to try that first
[20:51:49] <strcat> on that note, default type parameters result in nice error messages ;)
[20:51:55] <strcat> unlike with gcc
[20:52:06] * strcat got eddyb to make it hide parameters set to the default
[20:52:19] <pcwalton> strcat: \o
[20:52:20] <pcwalton> \o/
[20:52:23] <pcwalton> for what it's worth I wasn't kidding when I said I don't care *that* much, I won't stand in the way if everyone wants to do it
[20:52:27] <eddyb> strcat: even when you have type param expansion!
[20:52:48] <pcwalton> just that I think you still have to understand lifetimes
[20:52:54] <eddyb> that is, it re-expands the definition so it can remove as many defaults as possible
[20:53:56] <pcwalton> the good news is that I think you have to understand lifetimes in C++ anyway with the temporary lifetime rules (and with "why you can't return a reference to your stack frame"), so I think Rust lifetimes aren't really a disadvantage compared to C++â€”it's more of a challenge compared to managed languages
[20:54:15] * pcwalton ->lunch
[20:55:01] <pcwalton> btw wycats I would love to hear more whenever you're around about your experiences teaching Rust to managed languages developers
[20:55:08] <pcwalton> sounds like a fascinating conversation
[20:55:32] <pcwalton> experience, rather
[20:56:26] <eddyb> "repeat after me: 'I will type my variables, sir yes sir!'"
[20:56:41] <eddyb> scratch that, too lame. I'm tired for army jokes
[20:56:54] <eddyb> *too tired
[20:58:09] <strcat> pcwalton: so removing the tydescs means 15k fewer lines in the libstd IR because it removed 15k types
[20:58:27] <eddyb> wait, what?
[20:58:28] <strcat> ~5-10% improvement in size
[20:58:47] <strcat> well I assume that it's from removing that many types
[20:58:51] <strcat> afaik they are all on one line
[20:58:53] <strcat> didn't look at the diff
[20:59:14] <strcat> eddyb: atm, you get a tydesc for any call to a destructor
[20:59:18] <strcat> whether or not it is static
[20:59:25] <strcat> eddyb: and you get a tydesc for nested dtors inside the type
[20:59:33] <strcat> so there are a lot of tydescs.
[20:59:36] <strcat> and they will all be gone!
[20:59:54] <strcat> fn main() { let x = ~5; }
[20:59:58] <strcat> makes a tydesc
[21:00:00] <strcat> atm
[21:00:11] <wycats> pcwalton: that's basically all my experience
[21:00:17] <wycats> but yes, it seems good
[21:00:18] <wycats> :)
[21:00:27] <wycats> I've taught everyone at Tilde
[21:01:30] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[21:02:47] *** Quits: canhtak (canhtak@moz-8DFB5E6A.wl.t.ulaval.ca) (Quit: canhtak)
[21:03:03] <bstrie> wycats: what are their backgrounds?
[21:03:06] *** Joins: canhtak (canhtak@moz-8DFB5E6A.wl.t.ulaval.ca)
[21:03:11] <wycats> Tom is a JS developer mostly
[21:03:23] <wycats> Tim is a Ruby guy with a lot of recent Java
[21:03:40] <wycats> Carl is an old Ruby guy with also a lot of recent Java but also a lot of native experience historically
[21:04:16] <eddyb> where's Waldo?
[21:05:44] <bstrie> wycats: how are they taking it?
[21:07:34] *** Joins: tjc_ (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net)
[21:07:37] *** Quits: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net) (Ping timeout)
[21:08:02] <bjz> pcwalton dbaupp: http://www.reddit.com/r/programming/comments/1x66zv/the_rust_repository_closed_the_second_most_number/cf8n0j0
[21:08:07] <wycats> bstrie: pretty well, actually
[21:08:14] <wycats> they universally hated lifetimes ;)
[21:08:15] <bjz> question on regarding GC
[21:08:21] <wycats> it seems really, really, incantationy
[21:11:17] <bstrie> wycats: you should have taken detailed notes of their lifetime complains, because I'm beyond the stage where I can force myself to no longer understand them :P
[21:11:51] <bstrie> I wonder if this is how haskellers feel when they hear people complaining about monads
[21:12:17] <bstrie> see, a lifetime is like an enchilada
[21:12:19] <wycats> the complaint is that they're already overloaded trying to form a mental model of ownership
[21:12:24] <kmc> there isn't nearly so much uninformed hype about lifetimes
[21:12:41] <kmc> we don't have people showing up in #rust and immediately demanding an explanation of lifetimes before they know the first thing about the language
[21:12:43] <wycats> and the syntax is really strange
[21:13:43] <wycats> at some point, if the number of new concepts keeps coming and doesn't stop
[21:13:52] <wycats> you feel like the system is too complicated to understand
[21:14:05] <wycats> "Maybe this is cool, but I'm not smart enough to understand it" is something you REALLY want to avoid
[21:14:10] <bstrie> wycats: that idea of concept overload is exactly why I'm resisting monads in rust :P
[21:14:17] <wycats> and we're very close to that right now, if not over the edge on it
[21:14:40] <kmc> I like to stress that C also has concepts of ownership, borrowing, lifetimes etc -- you just don't get any help from the compiler!
[21:14:52] <wycats> kmc: yes, and Ruby people don't write C
[21:14:57] <wycats> because they're afraid of SEGVs ;)
[21:15:00] <kmc> it also helps that our main competition is C++
[21:15:17] <eddyb> wycats: I don't write C because it's painful to abstract anything in
[21:15:31] <eddyb> in... it, I guess. weird sentence ending there
[21:15:35] <wycats> kmc: it depends how you define "cmpetition"
[21:15:49] <bstrie> wycats: it may very well be that ruby people won't write rust, either. we ain't out to be the end-all language
[21:16:02] <wycats> bstrie: don't give up so easily
[21:16:11] <wycats> I'm a Ruby person and I write Rust
[21:16:17] <wycats> Tom is a JS person and he writes Rust
[21:16:20] <bstrie> wycats: I'm a javascript person and I write rust :P
[21:16:23] <wycats> yep
[21:16:26] <wycats> so don't give up so easily
[21:16:32] <kmc> convincing applications programmers to enjoy systems programming is a challenge beyond just teaching Rust :)
[21:16:41] <kmc> Rust could be a great gateway to systems programming, though
[21:16:45] <wycats> there is absolutely accidental complexity in Rust today
[21:16:48] <eddyb> I am an ES6 person and I contribute to the compiler
[21:16:52] <bstrie> wycats: you seem to be mistaken, I'm not giving up
[21:16:55] <bstrie> I'm focusing on our audience
[21:17:01] <Eridius> kmc: my day job is as an applications programmer but I rather enjoy systems programming
[21:17:04] <wycats> bstrie: "it may very well be that ruby people won't write rust, either" <= giving up
[21:17:12] <bstrie> if ruby devs don't use rust, that's sad. if C++ devs don't use rust, then we've failed
[21:17:23] <wycats> mayb
[21:17:25] <wycats> maybe
[21:17:25] <bstrie> failing > being sad
[21:17:34] <wycats> I would like to kill C++ too
[21:18:01] <eddyb> wycats: C++ compiler writers will kill you
[21:18:04] <wycats> but it doesn't seem like we're having pedagogical issues with C++ people
[21:18:10] <strcat> kmc: convincing people to pick rust over C++11/C++14 is still going to be a challenge
[21:18:16] <wycats> so maybe focusing our pedagogical energy on HLL people is ok
[21:18:27] <wycats> strcat: perhaps
[21:18:35] <wycats> there is a wide spectrum of users
[21:18:47] <strcat> if they can use rust, they can also use C++14 with clang
[21:18:57] <wycats> they might prefer Rust
[21:19:22] <eddyb> traits rock
[21:20:05] <wycats> they do
[21:20:12] <wycats> static dispatch to trait methods rock too
[21:20:14] <strcat> traits and the borrow checker can feel a lot like shackles
[21:20:19] <bstrie> eventually C++ will evolve close to rust, but it will always be trailing 30 years of baggage behind it
[21:20:27] <kmc> Rust has traits, real macros, vastly cleaner syntax, real module system, etc.
[21:20:32] <bstrie> that baggage is the biggest deterrent to new users learning C++, imo
[21:20:32] <kmc> even setting aside static checking of lifetimes
[21:20:45] <strcat> kmc: traits are not a uniform positive
[21:20:59] <strcat> there are advantages and disadvantages to traits
[21:21:05] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[21:21:17] <strcat> and when I'm actually trying to get something done rather than making a pretty well-defined API, I find they have more disadvantages
[21:21:31] <strcat> yes, the error messages are simpler
[21:21:40] <strcat> but there is a *whole lot* of boilerplate and code isn't as generic
[21:21:41] *** Joins: lpy (lpy@B3BE13AC.47A0616D.E99F7FDB.IP)
[21:22:01] <strcat> and it's not possible to encode as much in the type system
[21:22:15] <eddyb> associated items would be nice
[21:22:18] <strcat> certainly has nice error messages
[21:22:25] <strcat> and clear API documentation just from the types
[21:22:32] <strcat> but it's also frustrating too
[21:22:39] <eddyb> fields in traits and constants in generics
[21:22:58] <strcat> the borrow checker feels the same way to me
[21:23:01] <strcat> it does catch a lot of bugs
[21:23:12] <strcat> it also prevents writing a lot of code that's correct
[21:23:15] <eddyb> we can do it, just needs a few more features
[21:23:46] *** Quits: lpy (lpy@B3BE13AC.47A0616D.E99F7FDB.IP) (Ping timeout)
[21:23:46] <bstrie> "for a few features more", a new film from sergio leone
[21:23:46] <strcat> -fsanitize=address will catch any of that class of bugs if they occur at runtime - so not all, but most
[21:24:00] <eddyb> strcat: designing a solution to work around the borrow checker safely has the advantage that you're more likely to get it right
[21:24:09] <strcat> eddyb: yes, but you can't always do that
[21:24:26] <strcat> intrusive data structures are the example I'll throw out there again
[21:24:26] <eddyb> we can do better, even if we already don't
[21:24:28] <strcat> RefCell has overhead
[21:24:47] <strcat> there are pros/cons to the choices rust makes
[21:24:55] <eddyb> for intrusive data structures we could use fields in traits
[21:25:09] <strcat> eddyb: I don't think it will work
[21:25:22] <strcat> intrusive data structures are a lack of tree-like ownership
[21:25:41] <eddyb> your multiple list problem could be solved by implementing the trait with a different type para - oh, that issue. hmpf
[21:25:51] <strcat> you can't write a doubly-linked list without unsafe code or refcounting
[21:26:01] <strcat> so I don't expect you will be able to write more complex intrusive data structures
[21:26:07] <strcat> like, lets say
[21:26:45] <eddyb> how can you make a doubly-linked list safe?
[21:26:55] <eddyb> think about the most generic safe abstraction, because I'm curious
[21:27:05] <strcat> you can expose a safe API if you don't expose nodes
[21:27:09] <strcat> but it has to be written with unsafe code
[21:27:19] <strcat> intrusive data structures are all about exposing nodes - and in fact going beyond that
[21:28:05] <eddyb> I meant, what would you design, at the language level, to allow for owned doubly-linked lists?
[21:28:22] <cmr> You'd need a GC to start with..
[21:28:25] <eddyb> how can you provide invariants?
[21:28:28] <eddyb> cmr: why?
[21:28:34] <cmr> Oh, owned.
[21:28:47] <strcat> eddyb: how can you design a type system to enable calling binary_search only on a sorted vector?
[21:28:54] <strcat> rust has a binary_search method but it doesn't do that
[21:28:58] <strcat> it doesn't mean rust is wrong
[21:29:10] <Eridius> why does &[] not implement Show?
[21:29:11] <eddyb> reminds me of typestate or whatever that was called
[21:29:28] <eddyb> Eridius: is that a follow-up? if no, I don't know
[21:29:37] <Eridius> eddyb: a follow-up?
[21:29:53] <eddyb> Eridius: nevermind
[21:29:59] <strcat> I do think rust is a much better language than C++
[21:30:13] <strcat> but I still use C++ when I want to get something done
[21:30:36] <strcat> because it is far easier to use C libraries, and there is a huge ecosystem of modern C++ libs
[21:31:31] <strcat> I can grab something like boost::disjoint_sets
[21:33:02] <pcwalton> intrusive structures should work, no?
[21:33:05] <pcwalton> I don't see why they don't.
[21:33:18] <pcwalton> (yes I know what intrusive structure means in this context)
[21:33:18] <strcat> pcwalton: well, consider say a Creature object in a game
[21:33:27] <strcat> it's in a few lists, a set, maybe some maps
[21:33:34] <pcwalton> yes, just ref count it
[21:33:38] <pcwalton> the next and pref pointers
[21:33:41] <strcat> well, that works
[21:33:46] <strcat> but it's not the same perf class
[21:33:58] <pcwalton> yes it is
[21:34:07] <pcwalton> I have yet to see ref counting in servo's profile ever
[21:34:27] <pcwalton> also I think in most cases those games are using ref counting anyway
[21:34:27] <strcat> pcwalton: doesn't mean it's not a very significant impact here
[21:34:53] <pcwalton> I am *extremely* doubtful that ref counting would ever matter for a Creature object in a game
[21:35:57] <strcat> simcity5 tried and failed to represent each sim as a real object, they had to vastly scale down the size of the maps, etc.
[21:36:10] <strcat> I think there are many cases when it does matter
[21:36:40] <strcat> in an FPS, no, it won't
[21:36:59] <pcwalton> nonatomic ref counting is practically free
[21:37:04] <cmr> Civ IV pervasively used Python, but it's also not a particularly intensive game.
[21:37:13] <strcat> pcwalton: it makes you put the objects in memory allocations though
[21:37:27] <strcat> cmr: and civ iv was really slow
[21:37:33] <cmr> sure was
[21:37:35] <strcat> the sequel dropped python
[21:37:42] <strcat> uses lua, still slow, but not as bad
[21:38:01] <pcwalton> not if you use custom allocators
[21:38:22] <pcwalton> my context is I'm looking at Servo reflowing pages 20%-30% faster than WebKit
[21:38:36] <pcwalton> even with pervasive use of RefCells and stuff
[21:38:51] <pcwalton> and I am having a very hard time squaring the assertions that Rust is slow with that
[21:39:05] <pcwalton> my context is also that I spend a lot of time micro-optimizing Servo to remove stuff like RefCells and memcpy
[21:39:09] <pcwalton> and get 1% improvement each time
[21:39:27] <pcwalton> everything I have seen points to the overhead of Rust's idioms being minuscule
[21:39:54] <pcwalton> what is slow is large C++ codebases using virtual methods everywhere
[21:40:02] <pcwalton> and not being able to inline across .cpp files
[21:40:19] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Client exited)
[21:40:20] <pcwalton> sure there are technically workarounds for these things but most C++ codebases just don't do them in practice
[21:40:27] <strcat> it inlines across C++ files if you build it like rust by passing -flto
[21:40:34] <pcwalton> again
[21:40:38] <pcwalton> most C++ codebases just don't do them in practice
[21:40:45] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[21:40:51] <pcwalton> while in Rust virtual methods are non-idiomatic and inlining across crates is super easy
[21:41:00] <strcat> but I'm comparing using C++14 with clang vs. rust
[21:41:09] <strcat> not C++03 with horrible google style guide and old compilers
[21:41:18] <pcwalton> horrible google style guide is how people write C++ in practice
[21:41:37] <strcat> then they won't use rust, because it doesn't let them follow that kind of bondage
[21:41:43] <pcwalton> yes it does
[21:42:03] <strcat> the google style guide doesn't let you use RAII
[21:42:04] <pcwalton> rust linting is incredibly strict
[21:42:17] <strcat> they are against doing work in destructors
[21:42:22] <strcat> or ctors
[21:42:27] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Ping timeout)
[21:42:27] <pcwalton> ok, then you have to change the idioms a bit
[21:42:32] <pcwalton> but that's fine
[21:43:16] <pcwalton> I really don't think that everyone loves C++14 like you claim
[21:43:26] <strcat> not saying that everyone loves it
[21:43:29] <strcat> but that's rust's competitor
[21:43:34] <Eridius> they got rid of std::optional. Of course it sucks!
[21:43:55] <strcat> it's boost::optional, there's no change for practical use of the language
[21:44:14] <strcat> rust wants to push stuff out to a package ecosystem
[21:45:13] <pcwalton> going back to intrusive data structures, I still don't see the problem -- what is the lifetime of the container?
[21:45:25] <pcwalton> if the lifetime of the container is the whole program, no sweat -- 'static it
[21:45:33] <strcat> it likely isn't
[21:45:39] <pcwalton> if the lifetime of the container is not, then put a lifetime parameter there
[21:45:43] <pcwalton> or reference count it
[21:45:44] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[21:45:49] <strcat> if the lifetime is static it doesn't need to be intrusive
[21:45:59] <strcat> can be a flat array with indexing
[21:45:59] <pcwalton> I think you are usually doing those things anyway in C++, or should be
[21:46:14] <pcwalton> certainly in browsers lifetime management is almost always one of:
[21:46:16] <pcwalton> (a) forever
[21:46:20] <pcwalton> (b) bound to a stack frame
[21:46:33] <pcwalton> (c) reference counting (or global GC like in Blink)
[21:46:44] <pcwalton> everything that isn't quickly migrates to one of those three options
[21:46:57] <pcwalton> because it just doesn't scale up to large teams/codebases otherwise
[21:47:06] <strcat> intrusive data structures are pretty easy
[21:47:34] <strcat> you don't really have containers with lifetimes
[21:47:37] <strcat> you have objects with lifetimes
[21:47:47] <pcwalton> I think you have to have some kind of container that you're placing objects into
[21:47:52] <strcat> when an object goes out of scope, the dtor on the intrusive data structure fields remove it from various containers
[21:47:58] <strcat> pcwalton: the containers are threaded through the objects
[21:48:01] <pcwalton> sure
[21:48:08] <strcat> if all the objects go out of scope there's no way to access the container
[21:48:21] <pcwalton> but what's the point of having the container if you don't iterate through it
[21:48:26] <strcat> and the container doesn't have allocations outside of the objects
[21:48:31] <strcat> pcwalton: you can iterate it from any object
[21:48:35] <pcwalton> you have to have an object to iterate though it
[21:48:46] <strcat> yes, but I think they are usually circular lists
[21:48:57] <strcat> so you do get to iterate the whole singly linked list from any object
[21:49:06] <pcwalton> or doubly linked I guess
[21:49:07] <pcwalton> hmm
[21:49:20] <pcwalton> is this incompatible with rust? I don't see immediately how it would be
[21:49:23] <strcat> the linux kernel has two data structures it really loves
[21:49:30] <strcat> intrusive singly linked lists and intrusive rbtrees
[21:49:31] <pcwalton> if you have destructors then they can just remove the objects from the lists just as in C++
[21:49:45] <strcat> pcwalton: yes it works, but I don't know how to make it work without unsafe {} everywhere
[21:49:49] <strcat> you can abstract it as well as C++
[21:49:56] <pcwalton> what requires unsafe{} ?
[21:50:05] <pcwalton> besides adding/removing the objects from the lists
[21:50:07] <pcwalton> but that can be abstracted
[21:50:27] * strcat tried and couldn't figure out how to make it fully safe
[21:50:43] <strcat> maybe macros
[21:50:44] <pcwalton> I would be quite interested in your efforts
[21:50:47] <pcwalton> I think macros may be involved
[21:50:58] <pcwalton> we're using 'em for memory safety in Servo for GC
[21:51:01] *** Quits: tjc_ (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[21:51:04] <pcwalton> hygiene can be a powerful tool for memory safety :)
[21:51:05] <strcat> it is at least as safe as boost but it's not rust safe
[21:51:15] <strcat> so then you can't really use it anywhere because it's very infectious
[21:51:20] <pcwalton> let's try, I bet we can make it safe
[21:51:22] <pcwalton> with macros
[21:51:29] <pcwalton> and perhaps a language change or two
[21:51:33] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[21:51:33] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/Z3vmAw
[21:51:33] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[21:51:54] <strcat> generic dtors would help...
[21:52:12] * strcat always hits that :(
[21:52:26] <strcat> whenever I try doing stuff like this
[21:52:41] *** Joins: dherman (dherman@moz-DFAA4E15.p2p.sfo1.mozilla.com)
[21:52:41] *** ChanServ sets mode: +ao dherman dherman
[21:53:08] <pcwalton> strcat: are you aware of an issue whereby cross crate dtors are never being inlined?
[21:53:12] <pcwalton> seems that way in servo and it hurts
[21:53:35] <cmr> pcwalton: never, even with #[inline]?
[21:53:43] <pcwalton> cmr: yeah, never even with that :(
[21:53:45] <pcwalton> might be a simple fix
[21:54:04] <pcwalton> it's costing up to 31% of selector matching perf :P
[21:56:27] <strcat> pcwalton: no, not aware of one except you mean with trait objects
[21:56:30] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[21:56:31] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/nlHOqw
[21:56:31] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[21:56:32] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[21:56:32] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/qCOYYA
[21:56:32] <ghrust> 13rust/06auto 14804689f 15Eduard Burtescu: Removed @self and @Trait.
[21:56:32] <ghrust> 13rust/06auto 141652663 15bors: auto merge of #12030 : eddyb/rust/kill-at-self-and-trait, r=pcwalton
[21:56:33] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[21:56:38] <pcwalton> hmm, ok
[21:56:46] <pcwalton> maybe I was rebuilding wrong
[21:56:47] <pcwalton> in servo
[21:57:20] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[21:57:20] <ghrust> 01[13rust01] 15alexcrichton 04force-pushed 06try from 1410db5b5 to 14742102d: 02http://git.io/k471pw
[21:57:20] <ghrust> 13rust/06try 14742102d 15chromatic: Removed prelude::* from libstd files....
[21:57:20] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[21:57:52] <strcat> pcwalton: it's possible that the tydesc indirection caused a problem but it shouldn't have
[21:57:57] *** Quits: dbaupp (Thunderbir@moz-25BBAF91.lns20.syd6.internode.on.net) (Ping timeout)
[21:58:06] <strcat> the way we called all dtors previously was extracting a tydesc field and calling it
[21:58:20] <strcat> LLVM is supposed to be smart enough to deal with that in every case
[21:58:28] <strcat> haven't seen it screw up
[21:59:55] <pcwalton> uh-oh, down to only 35 ~[T]s removed per hour
[22:00:25] <cmr> pcwalton: in what?
[22:00:32] <pcwalton> cmr: in the entire rust distribution
[22:00:52] <pcwalton> there are some 3,121 uses of ~[T] in Rust
[22:01:01] <pcwalton> I'm working on removing all of them and have a spreadsheet to track my progress
[22:01:03] <eddyb> replacing with Vec<T>?
[22:01:04] <cmr> ah
[22:01:06] <pcwalton> yeah
[22:01:06] <cmr> miserable
[22:01:14] <pcwalton> it's relaxing while I'm sick
[22:01:18] <cmr> ah I can see that
[22:01:21] <eddyb> oh dear don't touch ast_map
[22:01:34] <eddyb> I don't want to rebase this NOPE NOPE NOE
[22:01:36] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[22:02:22] *** Quits: doener (doener@moz-C68F600D.unity-media.net) (Ping timeout)
[22:02:24] *** Joins: doener (doener@moz-C68F600D.unity-media.net)
[22:02:32] <pcwalton> 2.98% complete, ETA Feb. 10, 8:36 AM
[22:02:50] <eddyb> pcwalton: leave ast_map::Path be if you haven't fiddled with it already. trust me, it's important
[22:02:52] <bstrie> strcat: I'm amused to hear you don't like google's C++ style guide. I'll have to read it
[22:03:08] <strcat> bstrie: they write a poor form of java in C++03
[22:03:14] <pcwalton> the .cc extension bothers me the most in google's style guide :)
[22:03:22] <strcat> pcwalton: I use .cc and .hh ;)
[22:03:26] <pcwalton> boo
[22:03:28] <pcwalton> .cpp forever
[22:03:35] <strcat> pcwalton: but cpp means C preprocessor ;p
[22:03:37] <bstrie> I've read their javascript and python guides and generally agree with them
[22:03:45] <Eridius> I haven't read Google's C++ style guide, but every style guide of theirs I have read has had some serious flaws
[22:03:48] <strcat> pcwalton: I'll start accidentally setting CPPFLAGS
[22:03:51] <Eridius> including the obj-c one, though I forget what was wrong with it
[22:03:54] <eddyb> strcat: I had time to think, and designed a ForwardPtr/BackPtr abstraction combo, but it's a bit too silly for just linked lists
[22:04:07] <strcat> boost uses hpp and I hate it ;p
[22:04:23] <strcat> pcwalton: I also like .C and .H but that doesn't work on windows, and neither does .c++/.h++
[22:04:24] <cmr> I much prefer .rs
[22:04:26] <pcwalton> btw, air mozilla talk going on right now on programming languages
[22:04:26] <strcat> so, .cc and .hh it is
[22:04:28] <strcat> ;p
[22:04:36] <eddyb> .cc/.h here
[22:04:37] <pcwalton> Matthew Flatt on parallelization of scheme
[22:04:41] * cmr opens
[22:04:42] <Eridius> .cplusplus anyone?
[22:04:45] <strcat> so me, .h means C header
[22:04:57] <eddyb> strcat: so you
[22:05:04] <cmr> pcwalton: I appear to not have audio, do you?
[22:05:08] <strcat> foo.cc is the C++ implementation, foo.hh is the idiomatic C++ API, foo.h is the crappy C API
[22:05:09] <cmr> oh there it is
[22:05:18] <strcat> eddyb: to me*
[22:05:20] <strcat> ;p
[22:06:20] <strcat> I write C++ as I write rust.... all types have a move constructor, types only have a copy constructor if they can make a new independent type
[22:06:30] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[22:06:30] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 141652663 to 14c13a929: 02http://git.io/N3iJvQ
[22:06:30] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[22:06:30] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[22:06:30] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/vCPoLQ
[22:06:30] <ghrust> 13rust/06auto 14e14f4aa 15Alex Crichton: Remove std::condition...
[22:06:30] <ghrust> 13rust/06auto 14304ddea 15bors: auto merge of #12039 : alexcrichton/rust/no-conditions, r=brson...
[22:06:31] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[22:06:35] <strcat> optional/either/variant to report errors, fair bit of tuples
[22:06:40] * strcat shrugs
[22:07:03] <eddyb> if the japanese tutorial is what failed this time...
[22:07:05] <strcat> if friend functions weren't so painful I wouldn't use constructors
[22:07:23] <eddyb> what is this? http://buildbot.rust-lang.org/builders/auto-linux-64-nopt-c/builds/3165/steps/compile/logs/stdio/text
[22:07:25] <strcat> maybe they could be static methods
[22:07:52] <eddyb> gaaah someone changed the driver and I didn't recompile after rebasing
[22:08:05] <eddyb> where's the table throwing emoji when you need it?
[22:09:44] <strcat> just use the pile of poo code point
[22:10:17] *** Joins: NiccosSystem (NiccosSyst@AB1AFDE.FC7B0C35.A7597CB6.IP)
[22:10:40] <eddyb> strcat: doesn't work with Qt :(
[22:10:44] <strcat> eddyb: it does work
[22:10:55] <strcat> eddyb: you need a good font http://users.teilar.gr/~g1951d/ install symbola
[22:10:57] <strcat> ;)
[22:11:02] <strcat> has all the Other/Symbol category
[22:11:07] <eddyb> well, it should work in the input box, but not in the chat log
[22:11:16] <strcat> woman with bunny ears? check. japanese goblin? check.
[22:11:34] *** Quits: Zr40 (zr40@moz-CCFEAB92.adsl.xs4all.nl) (Quit: leaving)
[22:11:35] <strcat> (unicode is weird)
[22:12:43] <strcat> ugh. pdf.js
[22:12:49] <strcat> I don't know why I don't just use evince
[22:14:19] *** Quits: rca (rcatolino@moz-EF98FF5B.adsl.proxad.net) (Ping timeout)
[22:14:31] *** Joins: ktt3ja (ktt3ja@moz-85E2770C.hsd1.va.comcast.net)
[22:15:28] <eddyb> I had to use that on my N900. not worse than okular
[22:16:17] <strcat> http://pwmt.org/projects/zathura/ might finally be usable ;p
[22:22:25] *** Joins: lpy (lpy@B3BE13AC.47A0616D.E99F7FDB.IP)
[22:24:35] *** Quits: lpy (lpy@B3BE13AC.47A0616D.E99F7FDB.IP) (Ping timeout)
[22:25:01] <eddyb> do I really have to do this?
[22:26:00] <eddyb> do I have to rewrite rustc::metadata::encoder to be generic over the (currently a closure) encode_inlined_item?
[22:26:18] <eddyb> and not just generic over encode_inlined_item's type. but encode_inlined_item has to be generic itself
[22:26:58] <eddyb> remind me again why rustc::middle::astencode is separate from rustc::metadata
[22:27:02] *** Joins: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net)
[22:27:03] *** ChanServ sets mode: +o tjc
[22:28:03] <eddyb> oh you have to be kidding me
[22:28:59] <eddyb> the path is there only for debugging purposes
[22:29:20] <eddyb> does anyone want to keep the full path for Encoding/Encoded inlined item?
[22:30:30] <eddyb> I guess I can just use the id to get a path
[22:31:16] *** Quits: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net) (Connection reset by peer)
[22:31:28] *** Joins: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net)
[22:31:28] *** ChanServ sets mode: +o tjc
[22:33:08] *** Quits: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net) (Connection reset by peer)
[22:33:25] *** Joins: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net)
[22:33:25] *** ChanServ sets mode: +o tjc
[22:39:06] <eddyb> pcwalton, cmr: r? https://github.com/mozilla/rust/pull/12030
[22:39:27] <eddyb> (had to fix after a rebase)
[22:48:32] <bjz> acrichto: I'm working the thing for libnative
[22:48:42] <bjz> acrichto: I will send a PR for your to review
[22:51:26] <eddyb> std::clone::Clone for std::iter::Map<'static,&syntax::ast_map::PathElem,syntax::ast_map::PathElem,std::vec::Items<,syntax::ast_map::PathElem>>
[22:51:34] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[22:51:34] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/8FEsOQ
[22:51:34] <ghrust> 13rust/06auto 14b2d30b7 15Eduard Burtescu: Removed @self and @Trait.
[22:51:34] <ghrust> 13rust/06auto 146d27b01 15bors: auto merge of #12030 : eddyb/rust/kill-at-self-and-trait, r=cmr
[22:51:35] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[22:51:36] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[22:51:37] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14304ddea to 14c13a929: 02http://git.io/N3iJvQ
[22:51:37] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[22:51:48] <eddyb> someone implement vec::Values *already*
[22:52:02] <eddyb> or fix 'static closures to contain :Pod
[22:52:18] <eddyb> please?
[22:52:34] <eddyb> do I have to implement vec::Values myself just for this? it's ridiculous *sigh*
[22:52:45] <eddyb> strcat: any objections?
[22:53:14] <eddyb> .vals() or .values()?
[22:53:31] <strcat> eddyb: I don't understand?
[22:53:52] <eddyb> my PR is now depending on a Pod value iterator for vectors
[22:54:16] <strcat> well I'm against adding something that's only a workaround for a fixable closure issue
[22:54:40] <eddyb> strcat: it makes for easier explicitly composed iterators
[22:54:51] <strcat> eddyb: how hard is it to fix closures?
[22:54:59] <ChrisMorgan> Is there any reason why std::io::Signum only has values for SIG{BREAK, HUP, INT, QUIT, STP, USR1, USR2, WINCH}? What about SIG{ILL, TRAP, ABRT, IOT, BUS, FPE, SEGV, PIPE, ALRM, TERM, STKFLT, CHLD, CONT, STOP, TSTP, TTIN, TTOU, URG, XCPU, XFSZ, VTALRM, PROF, IO, POLL, PWD, SYS}?
[22:55:12] <strcat> ChrisMorgan: what about windows?
[22:55:15] <eddyb> strcat: I haven't checked. it might be easy. but it requires a snapshot so I can't work with that
[22:55:32] <ChrisMorgan> strcat: ah yes, I suppose I don't know what it's got.
[22:55:38] <eddyb> strcat: it involved adding :Pod+Send+Freeze when the lifetime is 'static
[22:56:01] <strcat> if you submit a PR we can put a priority on it and I'll do a snapshot
[22:56:03] <eddyb> so Map<'static,...> would have a Pod closure. oh, and we should actually respect those bounds
[22:56:23] <eddyb> because we treat ||:Pod as &mut Trait:Pod
[22:56:38] <acrichto> bjz: I have a reservation or two about it
[22:56:49] <bjz> acrichto: yeah?
[22:56:50] <eddyb> rusti: let f: 'static||:Pod = ||{}; (f, f)
[22:56:51] <acrichto> bjz: if you don't actually start from 'int main() {}' how do you know what the main thread is?
[22:56:52] -rusti- pastebinned 8 lines of output: http://ix.io/amF
[22:57:00] <acrichto> bjz: in terms of rust didn't have any control over the startup of the process
[22:57:10] <eddyb> strcat: .iter().map(|&x| x) feels like a hack to me
[22:57:17] <eddyb> strcat: when we could say .vals() or .values()
[22:57:46] <bjz> acrichto: oh, so native::start cn be called from sub-threads?
[22:57:48] <bjz> :[
[22:57:59] <bjz> ack
[22:58:19] <strcat> eddyb: so we're going to add an extra method to every container?
[22:58:21] <strcat> please no
[22:58:22] <acrichto> bjz: it could be yeah
[22:58:30] <bjz> bugger
[22:58:31] <eddyb> strcat: just &[T]
[22:58:35] <strcat> eddyb: then super no
[22:58:36] <acrichto> bjz: also you could embed rust into another application, and you should in theory be able to use rust libraries
[22:58:39] <strcat> &[T] isn't special
[22:58:45] <strcat> it does not deserve special treatment over other containers
[22:58:53] <bjz> acrichto: this is a pain :(
[22:59:04] <acrichto> bjz: yeah :(
[22:59:04] <eddyb> okay then, containers with Pod values
[22:59:14] <strcat> eddyb: so you want to add a method + extra type for every container
[22:59:16] <strcat> I'm against that
[22:59:26] <strcat> and I'm against special-casing &[T] here
[22:59:27] <bjz> acrichto: I really think we should try to come up with a self-documenting, type based api
[22:59:36] <bjz> acrichto: but I don't know how
[22:59:41] <strcat> I don't see anything wrong with .iter().map(clone) or .iter().map(|&x| x)
[22:59:44] <bjz> acrichto: might need more thought
[22:59:50] <acrichto> bjz: what native apis need this, just graphics?
[23:00:00] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[23:00:01] <bjz> acrichto: libxml
[23:00:03] * strcat shrugs
[23:00:14] <bjz> acrichto: I'm sure there are others
[23:00:15] <acrichto> bjz: libxml?! libxml needs to be called on the main thread?!
[23:00:18] <eddyb> strcat: we could wait for nmatsakis to land the fix that would allow me to have <I: Iterator<&'a Path>>
[23:00:21] <strcat> eddyb: if you make an Iterable trait, I'd support adding it to that as a default method
[23:00:24] <acrichto> bjz: how could ou possibly require that lol
[23:00:28] *** Quits: NiccosSystem (NiccosSyst@AB1AFDE.FC7B0C35.A7597CB6.IP) (Ping timeout)
[23:00:34] <bjz> acrichto: only initParser and cleanupParser
[23:00:45] <strcat> eddyb: but I'm strongly against adding special cases for this and more method count explosion
[23:00:47] <bjz> acrichto: see the github issue I @mentioned you on
[23:00:56] <strcat> eddyb: and I'm not sure that Iterable can be implemented
[23:01:04] <bjz> acrichto: https://github.com/bjz/sax-rs/pull/11#issuecomment-34364177
[23:01:10] <strcat> implement it on both &[T] and HashSet
[23:01:14] <strcat> it is problematic.
[23:01:37] *** Joins: brson (brson@moz-DFAA4E15.p2p.sfo1.mozilla.com)
[23:01:37] *** ChanServ sets mode: +qo brson brson
[23:01:38] <eddyb> strcat: there's no closure issue for a Values<Items<...>> so I guess it would work without a snapshot
[23:01:42] <acrichto> bjz: that sounds like it's not a "main thread" problem but rather a "before everything else" and a"after everything else" problem
[23:01:52] <bjz> hmm
[23:02:00] <eddyb> strcat: and I thought I figured how to implement Iterable
[23:02:31] *** Joins: DoritosMan (brandon@moz-83B69942.txt.hfc.comcastbusiness.net)
[23:02:41] <strcat> https://github.com/mozilla/rust/issues/12068 the continued saga of floats ruining Ord
[23:02:42] <strcat> ;p
[23:03:05] <eddyb> Not in Ord(er)
[23:03:16] <sfackler> the continued saga of floats ruining everything :P
[23:04:01] <bjz> acrichto: yes, it seems like photex was wrong: http://xmlsoft.org/html/libxml-parser.html#xmlInitParser
[23:04:23] <strcat> nmatsakis: I'm curious what you think about having the floating point comparison operators use the IEEE754 total ordering, and adding separate methods for the hardware ones
[23:04:40] <strcat> nmatsakis: == and != will be as fast since they just become bitwise comparison afaik
[23:05:00] <strcat> but I think comparisons will be slower
[23:05:13] <strcat> I think <, >, etc. needs to always do what Ord does to keep the language sane though
[23:05:20] *** Quits: jdm (jdm@1F05EAB6.1AD9726E.74119F78.IP) (Ping timeout)
[23:05:40] <sfackler> imo it would be weird for rust to be the one language where NaN == NaN (unless they differ in signallingness, etc)
[23:06:02] <strcat> imo, the two sane alternatives are a) use the total ordering for float's Ord impl and the ops
[23:06:14] <strcat> b) don't provide comparison ops or Ord/Eq for floats
[23:06:31] *** Quits: DoritosMan (brandon@moz-83B69942.txt.hfc.comcastbusiness.net) (Quit: Leaving)
[23:06:36] <acrichto> bjz: I'd recommend extra::sync::one::Once for initialization and std::rt::at_exit for teardown
[23:06:38] <strcat> needing TotalEq/TotalOrd and having all code ending up using TotalOrd is horrible
[23:06:54] <eddyb> !(NaN =.= NaN) && !(NaN !.= NaN)
[23:06:55] <bjz> acrichto: ah, will look
[23:06:59] <sfackler> I wonder what happens if you insert NaN into a java HashSet
[23:07:13] <strcat> sort uses TotalOrd, HashMap needs TotalEq (it uses Eq but it's wrong), TreeMap needs TotalOrd
[23:07:18] <strcat> so what is Ord for? generic code isn't able to use it
[23:07:19] <eddyb> that dot reminds you it's impure and filthy
[23:07:27] <strcat> SML separates floating point
[23:07:33] <strcat> I think it's the best example of doing this right
[23:08:10] <acrichto> cmr: klutzy: ping
[23:08:17] <eddyb> strcat: if only we had the ability to add custom operators
[23:08:20] <strcat> but for convenience, they can use the well defined total ordering by default
[23:08:26] <strcat> eddyb: I don't like custom operators
[23:08:32] <strcat> infix call syntax would be nice
[23:08:32] <cmr> acrichto: pong
[23:08:43] <acrichto> cmr: do you know much more about https://gist.github.com/klutzy/7999247#file-trace-rs-L38 ?
[23:08:52] <strcat> eddyb: custom operators make code ridiculously hard to read due to the associativity/precedence varying
[23:08:55] <acrichto> cmr: I couldn't even find a CaptureStackBacktrace funciton anywhere on my machine
[23:08:57] <cmr> acrichto: not on the windows side of it no, unfortunately.
[23:09:12] <bjz> acrichto: btw, libsync now ;)
[23:09:16] <cmr> acrichto: http://undocumented.ntinternals.net/UserMode/Undocumented%20Functions/Debug/RtlCaptureStackBackTrace.html
[23:09:42] <acrichto> cmr: yeah -ldbghelp doesn't work at all on my vm and no library anywhere contained that symbol
[23:09:43] <cmr> it's not very undocumented though, it's in http://msdn.microsoft.com/en-us/library/windows/hardware/ff552119%28v=vs.85%29.aspx
[23:09:56] <cmr> say it's in 
[23:09:57] <acrichto> cmr: like all documentation pointed at it and then I could never get it to work :\
[23:09:58] <cmr> Ntoskrnl.lib 
[23:10:06] <acrichto> what
[23:10:11] <acrichto> welp
[23:10:13] <acrichto> that's new
[23:10:14] <acrichto> news*
[23:11:00] <acrichto> cmr: also, I'm remving your r+ from #12073, I'm gonna write up some more docs
[23:11:07] <cmr> acrichto: good!
[23:11:11] <acrichto> cmr: any other questions you'd like to have answered about libgreen/libnative?
[23:11:36] <cmr> acrichto: it'd be nice if it was documented that they're not fork-save (although libnative can be if you don't use timers afaict)
[23:11:53] <cmr> s/save/safe/
[23:12:06] <acrichto> mk
[23:12:15] <pcwalton> here's my spreadsheet if anyone is incredibly bored https://docs.google.com/spreadsheet/ccc?key=0AmYOd6rv-l1OdHpIQkEwWmlneUtqVXNCV0RJUktRamc&usp=sharing
[23:12:30] <pcwalton> tracks progress on removing ~[T]
[23:12:57] <cmr> acrichto: I think the "where are the threads" and "what parallelism is there" questions are the ones I've seen the most.
[23:13:08] *** Quits: brson (brson@moz-DFAA4E15.p2p.sfo1.mozilla.com) (Ping timeout)
[23:13:10] <acrichto> cmr: yeah those are really good questions to answer
[23:13:18] <eddyb> pcwalton: you take your vecticide seriously
[23:13:20] <cmr> acrichto: also it'd be super super amazing if you documented how to add different ios to libgreen, beyond librustuv...
[23:13:23] <pcwalton> yes
[23:13:24] <sfackler> pcwalton: that seems horrible
[23:13:35] <acrichto> cmr: hehe, I could try to add that yeah
[23:13:37] <pcwalton> someone's gotta do it
[23:14:10] <cmr> pcwalton: should we reject PRs that introduce more ~[] in favor of Vec<T>?
[23:14:10] <sfackler> so everything's moving to std::Vec and there won't be a literal syntax for some amount of time?
[23:14:17] <pcwalton> cmr: eh, I wouldn't reject them
[23:14:26] <pcwalton> sfackler: there will be literal syntax for fixed length vetcors
[23:14:26] <pcwalton> vectors
[23:14:49] <pcwalton> but yeah that's true. fortunately this won't be a problem with DST since ~[T] can be converted into Vec<T> with essentially zero overhead
[23:15:28] <pcwalton> we've survived worse, e.g. iter().advance
[23:15:37] <strcat> pcwalton: converting back will require shrink_to_fit though if we ever require passing the size to free/realloc
[23:15:52] <eddyb> pcwalton: we can replace Vec<T> with ~[T] *after* DST, in structures like the AST which are mostly frozen and benefit from any size differences, right?
[23:16:00] <pcwalton> yes
[23:16:18] * eddyb likes when decisions make sense to him
[23:16:36] *** Joins: dbaupp (Mibbit@moz-9702BA47.maths.usyd.edu.au)
[23:17:36] <eddyb> dbaupp: you missed this https://docs.google.com/spreadsheet/ccc?key=0AmYOd6rv-l1OdHpIQkEwWmlneUtqVXNCV0RJUktRamc&usp=sharing#gid=0
[23:17:52] <cmr> eddyb: http://huonw.github.io/isrustfastyet/mem/
[23:17:52] <dbaupp> wycats: (sorry to bring this up again, but...) fn f(&T) -> &U is *always* ambiguous (even outside an impl with its own lifetime): it could be fn f<'a>(&'a T) -> &'a U or fn f(&T) -> &'static U
[23:17:56] <cmr> seems to be... back to normal?
[23:18:28] <cmr> it's amazing that the bencher continues to function.
[23:18:29] <dbaupp> eddyb: I didn't actually :) i glance at the logs on the train each morning
[23:18:35] <dbaupp> pcwalton: good luck!
[23:18:37] <cmr> I cobbled it together in like 15 minutes a few months ago O_o
[23:18:50] <wycats>  Yeah I get the static argument
[23:18:50] <pcwalton> thanks
[23:18:51] <dbaupp> <3
[23:19:01] *** Joins: brson (brson@moz-DFAA4E15.p2p.sfo1.mozilla.com)
[23:19:02] *** ChanServ sets mode: +qo brson brson
[23:19:35] <dbaupp> the LLVM upgrade did an amazing job for compile times! did c-a's patch get accepted upstream?
[23:19:42] <strcat> c-a?
[23:20:16] <dbaupp> strcat: https://github.com/rust-lang/llvm/pull/3
[23:20:52] <strcat> more rust-specific patches though? :(
[23:21:04] <dbaupp> it was submitted upstream, iirc
[23:21:32] <dbaupp> oh, yes, it says so in the description: http://lists.cs.uiuc.edu/pipermail/llvm-commits/Week-of-Mon-20131223/200046.html
[23:21:48] <strcat> yeah, but we're not going to get to a patch-free LLVM if we shortcut them right to our LLVM
[23:21:54] <strcat> upstream may say "do it differently"
[23:22:03] <acrichto> bjz: https://github.com/bjz/sax-rs/pull/11#issuecomment-34386597
[23:22:16] <pcwalton> please note sunfish is very responsive to LLVM patches :)
[23:22:34] <pcwalton> we have a resident LLVM reviewer expert now :)
[23:22:38] <cmr> what's sunfish
[23:22:44] <pcwalton> Dan Gohman
[23:22:44] <dbaupp> a person
[23:22:49] <sunfish> sunfish is either a very big fish, or a very small fish
[23:22:50] <cmr> oh
[23:23:02] <cmr> a who! not a what!
[23:23:04] <cmr> fascinating
[23:23:07] <strcat> a tasty fish
[23:23:10] *** Joins: lpy (lpy@B3BE13AC.47A0616D.E99F7FDB.IP)
[23:23:42] <ChrisMorgan> Sunfish is to fish as sunflower is to flower?
[23:23:43] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[23:23:43] <ghrust> 01[13rust01] 15alexcrichton 04force-pushed 06try from 14742102d to 140ea0563: 02http://git.io/k471pw
[23:23:43] <ghrust> 13rust/06try 140ea0563 15chromatic: Removed prelude::* from libstd files....
[23:23:43] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[23:25:16] *** Quits: lpy (lpy@B3BE13AC.47A0616D.E99F7FDB.IP) (Ping timeout)
[23:30:41] *** Quits: lkuper (lkuper@moz-D862222C.dhcp-bl.indiana.edu) (Ping timeout)
[23:30:55] <eddyb> strcat: wrote my own Values wrapper for Items, thanks for the tip ;)
[23:32:15] * strcat doesn't remember giving a tip ;p
[23:32:20] * strcat confused
[23:34:13] <eddyb> strcat: a generic &T => T wrapper. well, mine is just for Items, but it could be more generic than that, modulo potential lifetime issues
[23:36:09] <strcat> acrichto: any idea why I'd be hitting /build/rust-git/src/rust/mk/docs.mk:303: *** multiple target patterns.  Stop. ?
[23:36:15] * strcat shrugs
[23:36:18] <strcat> I'll look at the git log
[23:36:42] <acrichto> strcat: hmm, did that start recently?
[23:37:08] <strcat> acrichto: yes
[23:37:09] <acrichto> looks like that happens when a dependency has a colon in it
[23:37:23] <strcat> acrichto: it only happens in a clean build chroot
[23:37:27] <strcat> not outside of one ;s
[23:37:39] <strcat> last successful rust-git build for my repo was 5 days ago
[23:39:21] *** Quits: brson (brson@moz-DFAA4E15.p2p.sfo1.mozilla.com) (Quit: leaving)
[23:39:23] <acrichto> strcat: do you know what the ./configure line looks like?
[23:39:50] *** Joins: brson (brson@6A848D32.C1B840DD.76F66111.IP)
[23:39:50] *** ChanServ sets mode: +qo brson brson
[23:39:55] <strcat> acrichto: https://github.com/thestinger/packages/blob/master/rust-git/PKGBUILD
[23:40:15] <acrichto> strcat: do you know if any unusual environment variables are set?
[23:40:24] <strcat> CFLAGS/CXXFLAGS/LDFLAGS
[23:40:29] *** kimundi is now known as zz_kimundi
[23:40:55] <acrichto> hm --disable-rpath may be doing it
[23:40:56] <strcat> and CPPFLAGS/CARCH/CHOST
[23:41:00] <acrichto> yep
[23:41:28] <acrichto> can you easily reproduce?
[23:42:02] <strcat> hm let me try --disable-rpath in my devel dir
[23:42:24] <acrichto> strcat: https://gist.github.com/anonymous/8854832
[23:42:31] <acrichto> that diff should also fix it
[23:42:36] <acrichto> just wanna confirm first
[23:42:49] <strcat> yep --disable-rpath
[23:42:51] <strcat> does it
[23:43:11] <acrichto> can you confirm that patch fixes it?
[23:43:31] <strcat> acrichto: yes
[23:43:42] <bjz> acrichto: what do you make of this? :/ http://xmlsoft.org/threads.html
[23:43:57] * strcat doesn't understand rust's build system ;\
[23:43:58] <acrichto> bjz: "main thread" == "first thread calling libxml"
[23:44:07] <bjz> acrichto: thought so
[23:44:41] <acrichto> strcat: https://github.com/mozilla/rust/pull/12076
[23:45:13] <dbaupp> why on earth would an xml parsing library have difficulty being thread-safe/require mutexes? parsing multiple docs seems like an obviously embarrassingly parallel task :'(
[23:45:30] <strcat> libxml2 and expat are awful
[23:45:31] <acrichto> C code
[23:45:34] <sfackler> I asked the same question about openssl
[23:45:34] <strcat> there is nothing better though
[23:45:39] <bjz> dbaupp: gahh - just you wait, Rust will take over the world
[23:45:49] <strcat> bjz: it's C/POSIX.
[23:45:51] <sfackler> but it turns out that openssl requires *43* global locks
[23:45:55] <strcat> readdir isn't even thread safe
[23:46:00] <dbaupp> sfackler: o_O
[23:46:05] <acrichto> dbaupp: https://github.com/joyent/libuv/commit/8bc29b6f5fff71c69987c44e3cfbb3b79b882398
[23:46:05] <sfackler> yep
[23:46:12] <acrichto> sfackler: that's terrifying
[23:46:28] <dbaupp> acrichto: yay, C! :P
[23:46:33] <acrichto> C is terrifying sometimes
[23:46:36] <dbaupp> <3 explicit `unsafe`
[23:46:38] <acrichto> "but it work"
[23:46:41] <sfackler> it also has the ability to dynamically make extra global locks as needed, which may or may not be optional
[23:47:03] <sfackler> you have to specify a locking callback to do the mutex manipulation yourself, and it defaults to a noop
[23:47:20] <acrichto> openssl, stahp
[23:47:50] <strcat> bjz: dbaupp: http://ix.io/amL the list of thread-unsafe POSIX functions
[23:48:02] <strcat> you can't use any of these in a threaded program without a global lock
[23:48:04] <strcat> woo
[23:48:19] <strcat> some don't have standard POSIX alternatives and you need GNU/BSD extensions
[23:48:41] <strcat> anyway writing thread-safe C is an active choice because of this...
[23:48:52] <dbaupp> haha, C's history is so "nice" sometimes :P
[23:49:18] <ktt3ja> is there a way to get the nearest enclosing function declaration if I have a node id of a block? :/
[23:49:32] <strcat> system, readdir, and the rand functions are pretty commonly used
[23:49:36] <eddyb> ktt3ja: there will be soon!
[23:49:38] <strcat> and the passwd db ones
[23:49:44] * dbaupp wants a parent style thing too
[23:49:46] <ktt3ja> eddyb: :o
[23:49:48] <strcat> and locales...
[23:50:02] <eddyb> ktt3ja: one of the things I'm supporting is getting the parent of any node in the ast_map
[23:50:03] <sfackler> getenv
[23:50:06] <dbaupp> eddyb: won't that require traversing a linked list of blocks?
[23:50:11] <eddyb> why?
[23:50:15] <dbaupp> eddyb: (and not cross-crate, right?)
[23:50:24] <dbaupp> eddyb: because the parent of a block can be a block
[23:50:37] <strcat> sfackler: yeah but getenv is a problem in a thread-safe language too, as there's no alternative - need a lock
[23:50:40] <dbaupp> fn foo() { { { { { /* parent fn of this block */ } } } } }
[23:50:42] <eddyb> dbaupp: I don't handle that, this parent thing was intended for paths
[23:50:49] <dbaupp> eddyb: oh, ok, cool
[23:50:53] <strcat> sfackler: most of the others only exist for backwards compat :(
[23:50:57] <strcat> so many _r functions
[23:51:01] <sfackler> :(
[23:51:16] <strcat> and then you have functions like gettimeofday that were *removed* from POSIX
[23:51:24] <strcat> but operating systems like OS X don't implement the new way
[23:51:26] <strcat> so...
[23:51:33] <eddyb> dbaupp: though I could make it work for everything, have with_path be smarter and ignore unnamed things. and even have a ParentNodeIterator
[23:51:45] <strcat> sfackler: sadly they don't consider thread unsafety to be a reason to deprecate/remove stuff
[23:51:56] <strcat> because it's more convenient in a single threaded environment
[23:52:07] <eddyb> ktt3ja: I hope this PR will be submitted by sunday
[23:52:15] <strcat> they'll only remove stuff that can't be used correctly or has a replacement that's at least as convenient
[23:52:32] <strcat> like gets and gettimeofday. which are both gone
[23:52:56] <sfackler> what was the issue with gettimeofday?
[23:53:11] <eddyb> dbaupp: cross-crate goes up until it hits a NodeInlinedParent which contains a path, a DefId, a Visibility and an AbiSet
[23:53:45] <pcwalton> oops, forgot to count the test suite
[23:53:49] <pcwalton> 636 more ~[T]s to remove :(
[23:54:08] <dbaupp> pcwalton: many of them will just be outright deletions, right?
[23:54:16] <pcwalton> dbaupp: maybe
[23:54:27] <pcwalton> I expect that will only be the case for a small fraction
[23:54:35] <pcwalton> since the tests need to be updated to stay relevant
[23:55:07] <ktt3ja> eddyb: ok, I don't need it to handle nested block, so it should work for my case, too
[23:55:27] <eddyb> ktt3ja: you can wait, I guess
[23:55:39] <eddyb> ktt3ja: what context are you in? a visitor?
[23:56:30] <strcat> heh my internet is being really sketchy
[23:56:38] <strcat> this ssh connection keeps dying
[23:58:59] <ktt3ja> eddyb: not quite sure what you mean, but I'm going to use it somewhere around here: https://github.com/mozilla/rust/blob/master/src/librustc/middle/typeck/infer/error_reporting.rs#L403

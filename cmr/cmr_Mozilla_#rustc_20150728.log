[01:45:08] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[01:59:53] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[02:02:34] *** Joins: bkoropoff (bkoropoff@moz-kthi5c.wa.comcast.net)
[02:09:45] *** Quits: brson (brson@moz-cfhap5.mtv2.mozilla.com) (Connection closed)
[02:39:42] *** Quits: kimundi (kimundi@moz-upm4u8.3d6k.qdkt.57bc.2002.IP) (Ping timeout: 121 seconds)
[02:45:51] *** Joins: kimundi (kimundi@moz-d29tad.dip0.t-ipconnect.de)
[03:53:57] *** Quits: bkoropoff (bkoropoff@moz-kthi5c.wa.comcast.net) (Client exited)
[04:42:37] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[05:43:45] *** Quits: stl (stl@moz-al5.8pf.15.176.IP) (Ping timeout: 121 seconds)
[05:46:13] *** Joins: stl (stl@moz-al5.8pf.15.176.IP)
[06:02:17] *** Quits: aatch (james@moz-i1k1ks.tlms.2o1v.e006.2406.IP) (Quit: Leaving)
[07:21:34] *** Joins: laumann (thomas@moz-3m6.3kq.109.2.IP)
[08:20:45] <eddyb> pnkfelix: so my latest box $x desugaring is... ::protocol::Boxed::write_and_fin(::protocol::BoxPlace::make(), $x)
[08:21:09] <eddyb> but I just realized that's `in ::protocol::BoxPlace::make() { $x }`
[08:21:52] <eddyb> unless we want to sepparate them for some reason
[08:22:57] <eddyb> pnkfelix: and we don't need &mut T vs *mut T, if we do the writing in each implementation
[08:24:11] <eddyb> wait, no, I confused the place in `in place { expr }`...
[08:26:24] *** Quits: eddyb (eddyb@moz-4eq.0ja.26.188.IP) (Connection closed)
[08:50:58] *** Joins: eddyb (eddyb@moz-qfi.dmj.25.188.IP)
[09:50:58] *** Joins: nagisa (nagisa@moz-8t068g.static.zebra.lt)
[11:38:39] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[13:20:14] *** Quits: nagisa (nagisa@moz-8t068g.static.zebra.lt) (Quit: Leaving.)
[14:40:29] *** Joins: nagisa (nagisa@moz-8t068g.static.zebra.lt)
[14:52:17] *** Joins: eddyb_ (eddyb@moz-kh3.eg8.166.109.IP)
[14:57:40] *** Quits: eddyb_ (eddyb@moz-kh3.eg8.166.109.IP) (Ping timeout: 121 seconds)
[16:24:53] *** Quits: laumann (thomas@moz-3m6.3kq.109.2.IP) (Ping timeout: 121 seconds)
[17:24:56] *** Joins: brson (brson@moz-cfhap5.mtv2.mozilla.com)
[17:24:57] *** ChanServ sets mode: +qo brson brson
[17:30:42] <brson> nmatsakis: do you have time tomorrow to talk about optimizing monomorphization?
[17:45:41] <huon> doener: ping
[17:47:09] <doener> huon: pong
[17:47:34] *** Joins: killercup (killercup@moz-f6o3r9.dip0.t-ipconnect.de)
[17:48:16] <huon> doener: you mentioned a while ago that one can debug LLVM asserts by finding the relevant assertion and printing the IR just before it
[17:48:22] <huon> doener: how does one print IR?
[17:48:38] <doener> can I somehow get the span for a type imported from a different crate?
[17:48:52] <doener> huon: #include <llvm/Support/Debug.h>
[17:49:03] <doener> huon: then in the code: dbgs() << *Thing << "\n";
[17:49:26] <doener> huon: remember to deref pointers (I forgot that the first few dozen times...)
[17:49:49] <doener> huon: what are you looking for?
[17:50:09] <huon> doener: some random assertion
[17:50:19] <huon> I have no idea what's happening at all, yet :P
[17:50:23] <huon> doener: thanks!
[17:50:26] <doener> heh
[17:50:29] <doener> you're welcome
[17:50:51] <nagisa> doener: asm_map re span?
[17:50:55] <nagisa> ast_map*
[17:52:12] <doener> nagisa: that crashes for imported types. I think I need to translate the span or def_id or something? But I don't know how to do that.
[17:52:50] *** Joins: laumann (thomas@moz-n9e72h.0.fullrate.dk)
[17:56:31] <nagisa> unsure then.
[17:58:44] <doener> thanks anyway
[18:00:53] <nmatsakis> brson: sure
[18:17:19] <huon> jroesch: http://is.gd/AvdTb0
[18:29:40] <eddyb> nmatsakis, pnkfelix: one of you around? https://github.com/rust-lang/rust/pull/27292 needs some love
[18:30:00] <pnkfelix> eddyb: i'll look
[18:51:24] <pnkfelix> eddyb: (very exciting stuff, BTW)
[19:01:07] <eddyb> pnkfelix: oh, the title thing, that's annoying
[19:01:36] <eddyb> pnkfelix: I'm surprised that initial description made as much sense as it did
[19:03:05] <eddyb> pnkfelix: if you look at the testcase, the box_ macro has a single expression, and the expected type doesn't propagate blindly, but can cause coercions
[19:04:16] <pnkfelix> eddyb: okay.  Maybe it wound help if you show an expression that this PR fixes?
[19:04:43] <eddyb> pnkfelix: the first example in the description compiles only after the PR
[19:04:44] <pnkfelix> (I guess the test case is meant to be that, but I meant something small in the description)
[19:05:00] <eddyb> that's the unclear part, I figure
[19:05:21] <pnkfelix> eddyb: hmm I'll look again in a bit, at lunch now)
[19:05:25] <eddyb> you used to need the workaround, but you can just write the simple form now and it will work
[19:05:44] <eddyb> that's what the odd phrasing related to the workaround was supposed to point out
[19:58:38] *** Joins: arielb1 (Ariel@moz-1hdjvc.cablep.bezeqint.net)
[20:56:14] *** Quits: laumann (thomas@moz-n9e72h.0.fullrate.dk) (Ping timeout: 121 seconds)
[21:00:45] <eddyb> pnkfelix: I entirely forgot about that issue, thanks!
[21:01:03] <pnkfelix> eddyb: yep yep, sorry i'm going so slowly on this
[21:01:31] <pnkfelix> eddyb: I'm not familiar with the coercion code so I'm basically trying to learn it on the fly
[21:01:32] <eddyb> nah, it's fine, I'm just glad it's still relatively fresh and being looked at :)
[21:01:48] <eddyb> pnkfelix: ah. most of it is really simple (but maybe a bit messy)
[21:03:13] <eddyb> the deref coercion uses the autoderef loop thingie and unsizing coercions have to juggle nested obligations to avoid false positives on everything that looks like a smart pointer
[21:04:05] <eddyb> wait
[21:04:15] <eddyb> pnkfelix: what's "Attempt to select all CoerceUnsized and Unsized obligations" in your comment about?
[21:04:42] <pnkfelix> eddyb: uh, it was a potential suggestion of how to summarize what the rest of the body is going to do?
[21:04:55] <eddyb> pnkfelix: that's what unsizing coercions do
[21:04:56] <pnkfelix> eddyb: (I was inferring based on the result type)
[21:05:03] <pnkfelix> eddyb: yeah true
[21:05:06] <eddyb> it also happens at the start of the process
[21:05:17] <pnkfelix> eddyb: so okay, that doesn't help
[21:05:41] <pnkfelix> eddyb: like I said, my main question is whether there *is* some pithy summary that one can employ here, or if that is hopeless
[21:05:52] <pnkfelix> eddyb: so I guess don't stress about it
[21:05:57] <eddyb> subtyping is the fallback for everything, maybe it should be stated in a doc comment on the function
[21:06:21] <eddyb> if no coercions apply, subtype
[21:08:03] <pnkfelix> eddyb: do you happen to know if the doc comment at the top of "coercion.rs" is still ... um, accurate?
[21:08:18] <pnkfelix> eddyb: (the fact that its examples uses syntax like `@2` made me worry)
[21:08:22] <eddyb> sheesh, I don't even know what it says
[21:08:32] * pnkfelix is still trying to play catch up here.
[21:08:33] <eddyb> yeah, I don't think I touched it when I moved the file around
[21:08:49] <eddyb> and that was ages ago
[21:09:25] <eddyb> &const T is not a thing anymore, so the part about freezing is kinda pointless
[21:09:44] <eddyb> well, no, &mut T -> &T is still "freezing" of sorts
[21:11:11] <eddyb> pnkfelix: the unresolved target type for autoborrowing is still correct, but I'm not sure the reasoning still applies
[21:11:57] <eddyb> playbot: fn pair<T>(_: T, _: T) {} pair(&0, &Box::new(0))
[21:11:58] -playbot- ()
[21:12:22] <eddyb> huh
[21:13:17] <eddyb> pnkfelix: this might be my fault, actually, some other place in typeck *really* wants to know the precise expected types of arguments
[21:13:29] <eddyb> playbot: fn pair<T>(_: T, _: T) {} pair(&Box::new(0), &0)
[21:13:30] -playbot- <anon>:9:54: 9:56 error: mismatched types:
[21:13:30] -playbot-  expected `&Box<_>`,
[21:13:30] -playbot- output truncated; full output at: http://bit.ly/1ey0wjC
[21:14:18] <eddyb> pnkfelix: I'm not even sure the manual calls to resolve the source (a), and in the fn iter/pointer cases, the target (b), do anything at all
[21:15:18] <eddyb> pnkfelix: in conclusion, the Reborrowing section can be stripped of &const T mentions, and the subtle(r) note(s) can be removed entirely
[21:16:25] <pnkfelix> eddyb: I am becoming increasingly worried that I am the wrong person to be reviewing this code.  But I will continue to try
[21:17:06] <eddyb> pnkfelix: what I am worried about is the way I pick the generalized type
[21:17:54] <eddyb> the selection should fail if multiple CoerceUnsized impls exist, that could apply
[21:18:27] <eddyb> and the only types that get through are structs and Box<T>, which admit only coercions between the same nominal type
[21:19:06] <eddyb> but what if the part that allows only Foo<T> -> Foo<U> and not Foo<T> -> Bar<U>, changes?
[21:19:59] <eddyb> I guess I would really want to do only the "collect impls that match" part of selection
[21:20:39] <eddyb> I can't just select <_ as CoerceUnsized<Box<Trait>>> because that results in ambiguity, the _ could be a projection or type parameter
[21:21:57] <eddyb> but what I want are the impls that match it. that would also handle &T and *T (as in, those have multiple applicable impls, so they will get ignored)
[21:23:24] <eddyb> also, <Box<Trait> as CoerceUnsized<Box<Trait>>> might be too narrow, but I can't think of a set of impls that would cause it to select like that and not with Self set to _
[21:24:53] <eddyb> impl CoerceUnsized<Box<Trait>> for Box<Trait> {} impl<T: Trait> CoerceUnsized<Box<Trait>> for Box<T> {}
[21:25:07] <eddyb> pnkfelix: the rubber duck strikes again!
[21:26:03] <eddyb> that's unfortunate. at least the check can be faster, as I only need to bother with impls. and I should only be looking at one impl most of the time
[21:26:29] <eddyb> (thanks to the fast_reject mechanism)
[21:29:25] <eddyb> pnkfelix: oh, hey, you found something that only made sense at 4am (I just checked the IRC logs from that night)
[21:50:28] *** Quits: killercup (killercup@moz-f6o3r9.dip0.t-ipconnect.de) (Ping timeout: 121 seconds)
[22:18:07] *** Quits: arielb1 (Ariel@moz-1hdjvc.cablep.bezeqint.net) (Quit: Ex-Chat)

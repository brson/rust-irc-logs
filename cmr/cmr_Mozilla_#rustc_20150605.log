[00:02:13] *** Joins: nrc|distracted (nrc|distrac@moz-14pjgj.xtra.co.nz)
[00:08:04] *** Quits: bluss (bluss@moz-ec5o68.cust.bredbandsbolaget.se) (Ping timeout: 121 seconds)
[01:08:11] *** Joins: aatch (james@moz-5r41gb.6pd7.20lj.e000.2406.IP)
[01:16:39] *** Quits: nrc|distracted (nrc|distrac@moz-14pjgj.xtra.co.nz) (Ping timeout: 121 seconds)
[02:01:31] *** Joins: nrc|distracted (nrc|distrac@moz-14pjgj.xtra.co.nz)
[02:05:13] <eddyb> nmatsakis: I pushed it at https://github.com/eddyb/rust/commits/calendar-driven-development
[02:05:55] <eddyb> sadly I can't demo it with the calendar, because I don't have anything that would make those method calls work (and function calls are actually ugly, turns out)
[02:50:57] *** Quits: brson (brson@moz-cfhap5.mtv2.mozilla.com) (Quit: leaving)
[02:59:22] *** Joins: kimundi_ (kimundi@moz-ghr.vgt.188.87.IP)
[03:01:54] *** Quits: kimundi (kimundi@moz-b6c.mnt.188.87.IP) (Ping timeout: 121 seconds)
[03:01:54] *** kimundi_ is now known as kimundi
[03:27:24] *** kimundi is now known as zz_kimundi
[05:01:39] *** Quits: nrc|distracted (nrc|distrac@moz-14pjgj.xtra.co.nz) (Ping timeout: 121 seconds)
[05:06:51] *** Joins: bluss (bluss@moz-ec5o68.cust.bredbandsbolaget.se)
[05:42:57] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[05:59:36] *** Quits: bluss (bluss@moz-ec5o68.cust.bredbandsbolaget.se) (Ping timeout: 121 seconds)
[06:42:25] *** Joins: Tobba (Tobba@moz-6oh.7ki.21.217.IP)
[07:12:02] *** Quits: acharles (acharles@moz-ulbdcn.ca.comcast.net) (Ping timeout: 121 seconds)
[07:49:18] *** Quits: aatch (james@moz-5r41gb.6pd7.20lj.e000.2406.IP) (Connection closed)
[08:04:39] *** Joins: aatch (james@moz-is4j4r.cable.telstraclear.net)
[08:11:06] *** Quits: c74d (c74d3a4ebb6@moz-0ersgu.oc.cox.net) (Connection closed)
[08:13:04] *** Joins: acharles (acharles@moz-ulbdcn.ca.comcast.net)
[08:17:18] *** Joins: c74d (c74d3a4ebb6@moz-0ersgu.oc.cox.net)
[08:23:22] *** Joins: simukis (nagisa@moz-8t068g.static.zebra.lt)
[08:47:21] <eddyb> nmatsakis: there's an interesting issue with anonymized return types that I haven't seen discussed
[08:48:23] <eddyb> nmatsakis: I assumed I could just parametrize them with all the type params and require annotating the lifetime params that go into the anonymized type
[08:49:30] <eddyb> nmatsakis: but that results in a 'static bound by default and annoations otherwise:
[08:49:37] <eddyb> fn format_month<'a, I: DateIterator+'a>(it: I) -> impl Iterator<Item=String>+'a
[08:57:50] *** Joins: laumann (thomas@moz-gqpfnm.science.ku.dk)
[09:00:15] <eddyb> nmatsakis: would it make sense to have impl Iterator+PhantomData(I)? should it be the default? (how can I even do that?)
[09:06:41] *** Quits: Tobba (Tobba@moz-6oh.7ki.21.217.IP) (Ping timeout: 121 seconds)
[09:11:51] *** Joins: Tobba (Tobba@moz-6oh.7ki.21.217.IP)
[09:27:09] *** Quits: aatch (james@moz-is4j4r.cable.telstraclear.net) (Ping timeout: 121 seconds)
[09:32:43] *** Quits: Tobba (Tobba@moz-6oh.7ki.21.217.IP) (Ping timeout: 121 seconds)
[10:37:32] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[10:56:09] *** Quits: laumann (thomas@moz-gqpfnm.science.ku.dk) (Ping timeout: 121 seconds)
[10:58:11] *** Joins: laumann (thomas@moz-1i4.hq0.225.130.IP)
[11:05:44] *** Joins: arielb1 (Ariel@moz-3hg.blr.66.109.IP)
[11:12:01] *** zz_kimundi is now known as kimundi
[11:19:55] *** Quits: laumann (thomas@moz-1i4.hq0.225.130.IP) (Ping timeout: 121 seconds)
[11:21:58] *** Joins: laumann (thomas@moz-gqpfnm.science.ku.dk)
[11:22:23] *** Joins: killercup (killercup@moz-8bi.bjk.170.84.IP)
[11:24:33] *** Joins: madmalik (uid13697@moz-lfin5p.brockwell.irccloud.com)
[12:13:09] <pnkfelix> Have we gotten rid of support for "// SNAP" in the tidy script?  Or have we just removed all of the occurrences of the comment form (i.e. we either haven't injected new stage-dependence, or people choose not to use it (or are unaware of it)?
[12:13:48] <eddyb> I suppose grepping the tidy script for SNAP should give results
[12:14:04] <eddyb> src/etc/tidy.py:                        report_warn("unmatched SNAP line: " + line)
[12:14:16] <eddyb> and there's also the regex above it
[12:14:26] <eddyb> pnkfelix: I sadly expect it to be the latter
[12:14:32] <pnkfelix> yeah probably
[12:14:45] <eddyb> I founds lots and lots of unmarked #[cfg(stage0)] in the last snapshot
[12:15:10] <eddyb> thankfully alloc::arc's file was duplicated to avoid a million annotations
[12:16:13] *** Quits: laumann (thomas@moz-gqpfnm.science.ku.dk) (Ping timeout: 121 seconds)
[12:20:29] *** Quits: arielb1 (Ariel@moz-3hg.blr.66.109.IP) (Ping timeout: 121 seconds)
[12:23:35] *** Joins: laumann (thomas@moz-gqpfnm.science.ku.dk)
[12:35:21] *** Joins: arielb1 (Ariel@moz-f4qsb4.red.bezeqint.net)
[12:36:47] *** Quits: killercup (killercup@moz-8bi.bjk.170.84.IP) (Connection closed)
[12:37:09] *** Joins: killercup (killercup@moz-723bo4.dip0.t-ipconnect.de)
[12:38:12] *** Quits: killercup (killercup@moz-723bo4.dip0.t-ipconnect.de) (Connection closed)
[12:38:26] *** Joins: killercup (killercup@moz-723bo4.dip0.t-ipconnect.de)
[12:39:04] <nmatsakis> eddyb: that is an interesting problem; I'm actually still working through the details on how to manage the lifetimes on plain old associated types (which are currently unsound) :) this adds a new wrinkle, but I think my plan there may offer some insight. 
[12:39:16] <nmatsakis> I've got a rather detailed writeup here https://gist.github.com/nikomatsakis/fc631c87f30d4441ad0c <-- not yet complete
[12:39:20] <nmatsakis> but that's more a catalog of explorations
[12:39:45] <nmatsakis> anyway, the key idea is that if you can show that the components of a projection (parameters of the trait ref) outlive 'a, then you know that TraitRef::Foo outlives 'a (if we make some changes)
[12:40:02] <nmatsakis> that would imply in the case of your example
[12:40:08] <nmatsakis> since impl Iterator<...>
[12:40:14] <nmatsakis> is really shorthand for a kind of associated type like
[12:40:22] <nmatsakis> FormatMonth<I'>::Output
[12:40:31] <nmatsakis> that we can assume that the Output outlives 'a if I': 'a
[12:40:36] <nmatsakis> where I' is whatever I was instantiated with
[12:40:54] <nmatsakis> (or at least, that will hold once I make some changes to make it hold :)
[12:42:52] <eddyb> nmatsakis: so I'd need some kind of hidden bound that I add to all the type params, right?
[12:43:23] <eddyb> at least right now it defaults to 'static because I'm reusing TyTrait so it should be sound
[12:47:32] <nmatsakis> eddyb: well it depends on how we stored these in the type checker; ideally they'd be represented as ty_projection's
[12:47:36] <nmatsakis> so no additional machinery is needed
[12:47:44] <nmatsakis> but working out the precise "desugaring" in terms of assoc types 
[12:47:49] <nmatsakis> is not something we have done 
[12:47:55] <eddyb> associated types do not fit IMO
[12:47:57] <nmatsakis> it seems to be the heart of the proposal :)
[12:48:18] <eddyb> unless...
[12:48:20] <nmatsakis> I think they're a perfect fit?
[12:48:35] <eddyb> it feels like a forced fit
[12:48:52] <eddyb> (outside of trait method definitions, I mean. in those, impl Trait means something different)
[12:49:27] <eddyb> nmatsakis: there's a type, the function type, I guess, but there's no trait
[12:50:32] <eddyb> I'm considering making this work: trait DoFoo<'a> { type Output: 'a; fn foo(...) -> Self::Output; } impl<T: 'a> DoFoo<'a> for T { type Output = impl Iterator<Item=...>+'a; fn foo(...) -> Self::Output {...} }
[12:50:53] <eddyb> but the instantiation limitations are interesting
[12:51:25] <eddyb> you don't want an `impl Trait` defined in an associated type to be assignable outside of that impl
[12:52:14] <eddyb> I'll probably end up using ast_map's parenting for this
[12:52:44] <eddyb> nmatsakis: I almost managed to get away without any new tables in tcx, for the initial version
[12:52:48] <nmatsakis> eddyb: well, if you generalize the notion so that you can project an associated type out of any path, it's a fine fit, but I'm fine with it being two variants on associated types, the point is, they work in very analogous ways
[12:52:52] <eddyb> s/almost/also
[12:53:25] <eddyb> nmatsakis: I wouldn't expect projections to exist for non-trait associated types
[12:53:32] <eddyb> it just resolves to a concrete type
[12:54:00] <eddyb> if we had impl Foo { type Bar = ...; }
[12:55:20] *** Quits: killercup (killercup@moz-723bo4.dip0.t-ipconnect.de) (Quit: Bye)
[12:56:24] <eddyb> nmatsakis: honestly, I was expecting to unify closures with this
[12:56:40] <eddyb> as anonymized struct types
[12:56:57] <eddyb> but the current model assumes too much
[12:59:11] <eddyb> nmatsakis: I do want to use projections for the trait version of this
[13:00:03] <nmatsakis> eddyb: I don't think you want to unify closures
[13:00:10] <nmatsakis> that would imply that e.g. the creator of the closure
[13:00:14] <nmatsakis> couldn't analyze its contents
[13:00:16] <nmatsakis> to decide if it is Send etc
[13:00:50] <eddyb> impl Fn() + Send is a thing
[13:00:54] <eddyb> but you're right
[13:01:24] <eddyb> nmatsakis: trait Foo { fn foo(self) -> impl Fn(); } impl Foo for () { fn foo(self) -> fn() { fn noop() {} noop } } impl Foo for fn(i32) { fn foo(self) -> impl Fn() { move || self(4) } }
[13:01:54] <eddyb> the example is a bit contrived but what I mean is that impls could use a concrete type or an anonymized one, where `impl Trait` is expected in the trait signature
[13:02:55] <eddyb> sugar for an associated type in the trait which can be implemented with a concrete type or an anonymized one. and if we allow the latter without `impl Trait` in the trait signature, then it's really just sugar, no new functionality
[13:04:39] <nmatsakis> I agree it's straight-up sugar for traits; I think for things that are not within traits, it's sugar for a specialized trait-definition
[13:05:04] <nmatsakis> well, not quite sugar I guess
[13:05:10] <nmatsakis> also, it's not quite sugar in a trait
[13:05:27] <nmatsakis> but if we added "abstract" associated types (that never get concretely resolved in front-end)
[13:05:30] <nmatsakis> that's the missing ingredient
[13:06:34] <eddyb> adding a ty_anon was quite straight-forward
[13:06:43] <eddyb> except for the fact that TyTrait is kind of lacking
[13:06:55] <eddyb> nmatsakis: oh and for<'a> Trait stuff is pretty odd
[13:07:05] <eddyb> what does it even parse to?
[13:07:14] <eddyb> Trait+for<'a>?
[13:08:31] *** Quits: arielb1 (Ariel@moz-f4qsb4.red.bezeqint.net) (Ping timeout: 121 seconds)
[13:08:42] <eddyb> nmatsakis: and rustdoc is pretty clueless about it, too
[13:16:32] <nmatsakis> eddyb: sorry, what does what was parse to? for<'a> Trait?
[13:16:41] <nmatsakis> and what is this Trait+For<'a>?
[13:17:28] <eddyb> nmatsakis: well, it looks like HRTBs turn into some kind of bounds
[13:17:52] *** Joins: arielb1 (Ariel@moz-f4qsb4.red.bezeqint.net)
[13:17:58] <nmatsakis> are you referring to bounds or types at this moment
[13:18:05] <nmatsakis> that is, if you have e.g.
[13:18:22] <nmatsakis> where F: for<'a> Trait<'a> or something
[13:18:30] <nmatsakis> that corresponds to a ty::Predicate
[13:18:34] <eddyb> ty_trait, sorry. that's where I've seen this
[13:18:43] <nmatsakis> ok, it's basically the same,
[13:18:49] <eddyb> syntactically the for<'a> seems to be added to a vector
[13:18:50] <nmatsakis> in that case for<'a> Trait<'a> corresponds to a ty_trait, yes
[13:18:58] <nmatsakis> in the AST yes
[13:19:04] <nmatsakis> but once you get into ty, the representation is different
[13:19:15] <nmatsakis> it uses Debruijn Indices --
[13:19:21] <nmatsakis> so there is a "binding level" (represented by a Binder<>)
[13:19:28] <eddyb> what happens if the for<'a> is at a different position in the vector?
[13:19:31] <nmatsakis> and when you have a reference to a bound lifetime (like 'a in that example)
[13:19:33] <nmatsakis> it is given a depth
[13:19:36] <nmatsakis> 1 means the innermost bounder
[13:19:40] <nmatsakis> 2 means the next binder after that
[13:19:41] <nmatsakis> and so forth
[13:19:51] <nmatsakis> (I don't know what vector you're referring to)
[13:19:57] <nmatsakis> in the AST?
[13:20:51] <nmatsakis> so if I had something like
[13:20:51] <eddyb> oh I read it wrong https://github.com/rust-lang/rust/blob/master/src/libsyntax/parse/parser.rs#L1053
[13:21:05] <nmatsakis> for<'a> Trait1<for<'b> Trait2<'a,'b>>
[13:21:05] <eddyb> for some reason I thought lifetime_defs were part of the vector
[13:21:09] <nmatsakis> you'd wind up with something like
[13:21:17] <eddyb> of all_bounds
[13:21:23] <nmatsakis> Binder(Trait1(Binder(Trait2<$2,$1>>)))
[13:21:34] <nmatsakis> where $N means "ReLateBound with depth N"
[13:21:39] <eddyb> it looks like for<'a> Trait + Sync is parsed as (for<'a> Trait) + Sync
[13:21:43] <nmatsakis> yes, that is true
[13:21:46] <eddyb> which is somewhat saner than what I read
[13:21:52] <nmatsakis> there is some weirdness about
[13:21:54] <nmatsakis> stuff like
[13:21:57] <nmatsakis> for<'a> T: Trait
[13:22:07] <eddyb> why isn't there a general "binder" in the AST?
[13:22:09] <nmatsakis> (but that all disappears once you get to the backend)
[13:22:20] * nmatsakis shrugs 
[13:22:22] <nmatsakis> might make sense to refactor it
[13:22:33] <eddyb> okay, so there isn't a *good* reason for it
[13:22:39] <nmatsakis> not really
[13:23:04] <nmatsakis> eddyb: off hand do you remember how to turn on RUST_LOG at "info" level? RUST_LOG=foo=1 ?
[13:23:28] <eddyb> maybe, but we even use anything other than debug!?
[13:24:26] <nmatsakis> well, I'm inserting some instrumentation I want to see without having to grep though all the debug
[13:24:34] <nmatsakis> anyway, I think that's it
[13:40:51] <eddyb> hahahahaha
[13:40:57] <eddyb> wait, wrong channel
[13:51:48] <pnkfelix> In syntax::ext::expand::expand_expr, should every invocation of push_compiler_expansion have a corresponding fld.cx.bt_pop() ?
[13:52:27] *** Joins: bluss (bluss@moz-ec5o68.cust.bredbandsbolaget.se)
[13:52:29] <pnkfelix> (double checking now, I thought I saw a case that was missing it)
[13:53:07] <pnkfelix> (no, I think I was wrong; they all have matching bt_pops I think)
[13:53:35] <eddyb> yeah, that's really bad if they're missing, maybe it should use a closure
[13:54:13] <pnkfelix> what is the initial push for the ast::ExprMac case/  I only see a pop on that one
[13:55:24] <pnkfelix> ah I guess it comes from expand_mac_invoc.  Boy that seems like a potential footgun
[13:55:34] <eddyb> also, certain expansions recurse even though they could loop
[13:55:42] <eddyb> pnkfelix: ouch
[13:56:07] <pnkfelix> eddyb: do you know offhand if we at least check that the bt stack depth is zero at the end of expansion?
[13:58:29] <eddyb> no clue
[13:58:59] <eddyb> https://github.com/rust-lang/rust/blob/master/src/libsyntax/ext/expand.rs#L1528
[13:59:14] <eddyb> doesn't look like it
[14:27:49] <arielb1> eddyb: 26023 needs a re-r+
[14:29:29] <arielb1> thanks
[15:02:44] <pnkfelix> hmm, does push_compiler_expansion actually not allow expanding into uses of unstable features?  Do I need to make sure I pass in dummy spans or something to get access to unstable stuff in the code I am generating?
[15:03:04] * pnkfelix goes to go review other callers of push_compiler_expansion
[15:08:43] <eddyb> pnkfelix: depends how the feature is checked
[15:08:56] <eddyb> pnkfelix: if you wrote a custom feature check, check out nmatsakis's const_fn call gating
[15:09:35] <pnkfelix> no, this is just calls to methods associated with the core feature...
[15:09:41] <pnkfelix> (and alloc)
[15:11:17] <pnkfelix> (I'm looking the debug! instrumentation now to see if that explains the behavior I'm seeing)
[16:00:26] *** Quits: laumann (thomas@moz-gqpfnm.science.ku.dk) (Quit: leaving)
[16:48:36] <pnkfelix> the interaction of the ExpnInfo recording and the built-in compiler macros seems pretty wonky
[16:49:39] <pnkfelix> I am assuming that the backtrace maintenance covers somethings (perhaps producing nicer errors when expansion goes awry), but AFAICT it cannot possibly deal with allow_internal_unstable in general
[17:27:41] <sfackler> pnkfelix: you have to tweak the span a bit: https://github.com/rust-lang/rust/blob/master/src/libsyntax/ext/deriving/show.rs#L70
[17:52:22] *** Joins: brson (brson@moz-cfhap5.mtv2.mozilla.com)
[17:52:22] *** ChanServ sets mode: +qo brson brson
[18:54:06] *** Quits: vadimcn (uid46608@moz-0d43u8.highgate.irccloud.com) (Connection closed)
[19:14:32] <pnkfelix> sfackler: thanks for the pointer
[19:34:28] *** Joins: laumann (thomas@moz-n9e72h.0.fullrate.dk)
[20:18:18] *** Joins: killercup (killercup@moz-0pf6i8.dip0.t-ipconnect.de)
[20:18:38] *** Quits: nmatsakis (nmatsakis@moz-no0.93r.245.63.IP) (Connection closed)
[20:18:59] *** Joins: nmatsakis (nmatsakis@moz-no0.93r.245.63.IP)
[20:18:59] *** ChanServ sets mode: +o nmatsakis
[20:56:54] *** Joins: SilverKey (SilverKey@moz-b7q751.biz.rr.com)
[20:57:57] *** Joins: WindowsBunny1 (Peter@moz-vlal7g.east.verizon.net)
[20:59:35] *** Quits: WindowsBunny (Peter@moz-vlal7g.east.verizon.net) (Ping timeout: 121 seconds)
[20:59:49] *** Joins: vadimcn (uid46608@moz-0d43u8.highgate.irccloud.com)
[21:04:16] *** Quits: SilverKey (SilverKey@moz-b7q751.biz.rr.com) (Quit: Cheerio!)
[21:57:53] *** Quits: killercup (killercup@moz-0pf6i8.dip0.t-ipconnect.de) (Quit: Bye)
[22:27:46] *** Quits: brson (brson@moz-cfhap5.mtv2.mozilla.com) (Quit: leaving)
[22:29:47] *** Quits: bluss (bluss@moz-ec5o68.cust.bredbandsbolaget.se) (Ping timeout: 121 seconds)
[23:25:01] *** Quits: simukis (nagisa@moz-8t068g.static.zebra.lt) (Ping timeout: 121 seconds)
[23:25:45] *** Quits: arielb1 (Ariel@moz-f4qsb4.red.bezeqint.net) (Quit: Ex-Chat)

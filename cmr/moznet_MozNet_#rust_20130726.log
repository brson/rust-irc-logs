[00:00:07] <graydon> brendanc: ok. I'll see if it works without it
[00:00:08] <cmr> graydon, well, that's different
[00:00:11] <graydon> go for your bus
[00:00:12] <graydon> :)
[00:00:13] <brendanc> :)
[00:00:41] <graydon> thanks
[00:00:49] *** Joins: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP)
[00:01:52] *** Quits: yonran (yonran@moz-962F33EB.acuitus.com) (Ping timeout)
[00:02:18] *** Quits: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP) (Quit: buildmaster reconfigured: bot disconnecting)
[00:02:32] *** Quits: tristram (tristram@moz-C498CC41.eu) (Ping timeout)
[00:02:45] *** Quits: SimonSapin (simon@moz-9A1FE870.exyr.org) (Ping timeout)
[00:03:02] *** Quits: dju (dju@moz-83BD5EC.dmz.me) (Ping timeout)
[00:03:03] *** Quits: Khady (Khady@moz-31F9D77E.khady.info) (Ping timeout)
[00:03:07] *** Quits: pnkfelix|rcirc (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Ping timeout)
[00:03:16] *** Joins: dju (dju@moz-83BD5EC.dmz.me)
[00:03:21] *** Joins: Khady (Khady@moz-31F9D77E.khady.info)
[00:03:21] *** Joins: tristram (tristram@moz-C498CC41.eu)
[00:03:38] *** Joins: SimonSapin (simon@moz-9A1FE870.exyr.org)
[00:04:10] <brendanc> you know how python is though, you'll never know there's anything wrong until you have to interrupt a build again :)
[00:04:36] <cmr> graydon, otoh, async/await is really a wonderful API
[00:04:37] *** Joins: lkuper (lkuper@B422129.A402E718.C082B7DC.IP)
[00:04:56] *** Joins: steven_is_false (user@C5B76363.1FF1EBF8.1ECA502.IP)
[00:05:19] *** Joins: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP)
[00:05:24] <graydon> brendanc: yeah. I think I'll do manual builds for the next while
[00:05:36] <graydon> well ..
[00:05:38] <graydon> http://buildbot.rust-lang.org/console?refresh=15
[00:05:40] <steven_is_false> How do I test out the new runtime? I know it's an environment variable that needs to be set to 1 but I can't remember what it's called.
[00:05:44] <graydon> it's _running_ at least :)
[00:05:47] <cmr> steven_is_false, RUST_NEWRT=1
[00:05:54] <steven_is_false> cmr: Thanks
[00:06:08] <cmr> steven_is_false, I think it doesn't do anything unless you spawn tasks or use code from std::rt though..
[00:06:11] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[00:06:22] *** Joins: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net)
[00:06:29] *** Quits: vosen (vosen@moz-266BA656.icpnet.pl) (Quit: Leaving)
[00:06:35] <steven_is_false> cmr: Yeah, I was testing out std::rt::io::Timer.
[00:06:39] *** Joins: tchoma (tchoma@moz-E58E29CC.dsl.static.sonic.net)
[00:06:50] <brendanc> web.Server Traceback (most recent call last):
[00:06:50] <brendanc> exceptions.TypeError: macro 'step_box' takes no keyword argument 'stepinfo' 
[00:07:23] *** Parts: steven_is_false (user@C5B76363.1FF1EBF8.1ECA502.IP) (ERC Version 5.3 (IRC client for Emacs))
[00:09:09] *** Quits: ecr (Thunderbir@moz-19C7F72B.uoregon.edu) (Quit: ecr)
[00:10:14] *** Parts: judder (maradukewa@3226AE5F.7C541960.78E362FE.IP) ()
[00:10:56] <sully> hm, is there a meta issue for rewriting the runtime in rust?
[00:11:45] *** Quits: lkuper (lkuper@B422129.A402E718.C082B7DC.IP) (Quit: lkuper)
[00:12:04] <doomlord> just checking.... have i got this right - a:&B  ...a is a ptr, &a:&B - a  is matched as value B (loaded from the pointer?)?  ... but impl { foo(self) .. thats a value? foo(&self) .. thats a pointer? self is special syntax which uses & differently ?
[00:12:36] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[00:12:40] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[00:13:45] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[00:13:52] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[00:14:10] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[00:17:00] <Luqman> sully: there's https://github.com/mozilla/rust/issues/4812
[00:19:26] *** Quits: lmandel (lmandel@moz-76CE9D51.cable.teksavvy.com) (Ping timeout)
[00:20:35] *** Quits: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com) (Ping timeout)
[00:22:03] *** Quits: slaren (slaren@moz-89461CF2.red-83-38-70.dynamicip.rima-tde.net) (Ping timeout)
[00:22:26] *** Joins: slaren (slaren@moz-89461CF2.red-83-38-70.dynamicip.rima-tde.net)
[00:23:20] <graydon> I'm going to drive bors manually tonight to ... very gently monitor the state of the buildbot
[00:23:27] <graydon> hope that's ok
[00:23:29] <graydon> it'll be slow
[00:23:35] <engla> doomlord_: no pattern matching on self 
[00:23:39] <graydon> but it will avoid the dreaded runaway-bors-destroying-the-queue phenomenon
[00:23:41] <graydon> if something goes wrong
[00:23:50] <graydon> buildbot: dance
[00:24:02] <graydon> rust-buildbot: dance
[00:24:03] <rust-buildbot> <(^.^<)
[00:24:04] <rust-buildbot> <(^.^)>
[00:24:05] <rust-buildbot> (>^.^)>
[00:24:05] <rust-buildbot> (7^.^)7
[00:24:07] <rust-buildbot> (>^.^<)
[00:24:15] <graydon> alright. 0.8.8 can still dance. good.
[00:24:15] <engla> \o/
[00:24:26] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[00:24:26] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/-1nXiA
[00:24:26] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[00:24:26] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[00:24:26] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/Xjr31Q
[00:24:26] <ghrust> 13rust/06auto 147c1c4be 15Michael Sullivan: Improve the camel case warning a bit.
[00:24:26] <ghrust> 13rust/06auto 14b8b17e1 15Michael Sullivan: Eliminate unused variable warnings.
[00:24:27] <ghrust> 13rust/06auto 143ba8ceb 15Michael Sullivan: Register snapshots.
[00:24:28] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[00:28:16] *** Quits: slaren (slaren@moz-89461CF2.red-83-38-70.dynamicip.rima-tde.net) (Ping timeout)
[00:28:18] *** Quits: eholk (eholk@moz-E654C98C.uconnect.utah.edu) (Quit: eholk)
[00:28:45] *** Quits: tchoma (tchoma@moz-E58E29CC.dsl.static.sonic.net) (Quit: My MacBook has gone to sleep. ZZZzzz‚Ä¶)
[00:29:04] *** Joins: jaen (jaen@moz-CE30FE6E.play-internet.pl)
[00:31:54] *** Joins: slaren (slaren@moz-89461CF2.red-83-38-70.dynamicip.rima-tde.net)
[00:32:54] *** Joins: tjc (tjc@moz-8DCE981F.hsd1.ca.comcast.net)
[00:32:54] *** ChanServ sets mode: +o tjc
[00:32:54] *** Joins: Jesin (Jessin_@moz-1B1307FF.eecs.lehigh.edu)
[00:33:21] <graydon> sully: bad news. the snapshot doesn't work on mac.
[00:33:33] <sully> oh, hm
[00:33:34] *** Quits: slaren (slaren@moz-89461CF2.red-83-38-70.dynamicip.rima-tde.net) (Ping timeout)
[00:33:35] <sully> what goes wrong
[00:33:38] <sully> did I just screw up the paste?
[00:33:47] <graydon> segfault
[00:33:48] <graydon> dunno
[00:33:56] *** Joins: tchoma (tchoma@moz-E58E29CC.dsl.static.sonic.net)
[00:33:58] <sully> ... weird.
[00:34:03] *** Quits: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net) (Client exited)
[00:34:41] <sully> wait, did you just find this out running it, or what?
[00:34:47] <sully> because bors hasn't picked it up yet
[00:35:03] <sully> oh, bors isn't running right now
[00:35:15] <graydon> buildbot ran it
[00:35:17] <graydon> and it segfaulted
[00:35:23] <graydon> http://buildbot.rust-lang.org/builders/auto-mac-all-opt/builds/572/steps/compile/logs/stdio
[00:35:40] <graydon> http://buildbot.rust-lang.org/builders/auto-mac-64-nopt/builds/576/steps/compile/logs/stdio
[00:35:41] <graydon> etc.
[00:36:03] *** Joins: slaren (slaren@moz-89461CF2.red-83-38-70.dynamicip.rima-tde.net)
[00:36:09] <graydon> I gotta head out. will do more manual driving later (like midnight-y)
[00:36:09] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Quit: Leaving.)
[00:36:10] <sully> ... ok, weird
[00:36:59] <dbaupp> sully: you probably have to remove the cfg(stage0) stuff (if you haven't already done so)
[00:37:16] <sully> ok, so, everything worked fine on my machine, though
[00:37:37] * dbaupp shurgs
[00:37:41] <dbaupp> *shrugs
[00:37:41] *** kimundi is now known as zz_kimundi
[00:37:44] <graydon> did you run it with --cfg stage0?
[00:37:55] <graydon> that's what happens to it once it's run as a snapshot
[00:38:15] <graydon> I don't know, gotta go
[00:38:17] <sully> no, but I tested the commit that registered the snapshot
[00:38:18] *** Quits: sigma (sigma@2AE71BC1.DC5B0862.37339E3A.IP) (Ping timeout)
[00:38:26] <graydon> did you test it on a mac? :)
[00:38:33] *** Quits: slaren (slaren@moz-89461CF2.red-83-38-70.dynamicip.rima-tde.net) (Ping timeout)
[00:38:34] <sully> no
[00:38:34] *** Quits: graydon (Adium@A5087023.2354C43D.D8E68FF6.IP) (Quit: Leaving.)
[00:38:38] <sully> I don't have a mac
[00:38:38] *** Joins: slaren (slaren@moz-89461CF2.red-83-38-70.dynamicip.rima-tde.net)
[00:39:15] *** Quits: Guest (textual@moz-E64A54F3.nyc.res.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzz‚Ä¶)
[00:39:37] *** Joins: pcwalton (pcwalton@9B0BC9DC.71128241.F9E1BAE1.IP)
[00:39:37] *** ChanServ sets mode: +o pcwalton
[00:39:58] *** Quits: BitPuffin (quassel@moz-4DE4682C.mobile.tre.se) (Ping timeout)
[00:42:03] *** Quits: eagen (eagen@moz-92A457CB.hsd1.mn.comcast.net) (Quit: Leaving)
[00:42:49] *** Quits: slaren (slaren@moz-89461CF2.red-83-38-70.dynamicip.rima-tde.net) (Ping timeout)
[00:42:50] *** Joins: slrn_ (slaren@moz-89461CF2.red-83-38-70.dynamicip.rima-tde.net)
[00:43:34] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[00:43:45] *** Joins: Nisstyre (wes@moz-FD86289.netflash.net)
[00:44:03] *** Quits: tchoma (tchoma@moz-E58E29CC.dsl.static.sonic.net) (Quit: My MacBook has gone to sleep. ZZZzzz‚Ä¶)
[00:45:20] *** Quits: slrn_ (slaren@moz-89461CF2.red-83-38-70.dynamicip.rima-tde.net) (Ping timeout)
[00:47:14] *** Quits: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net) (Ping timeout)
[00:47:24] *** Quits: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net) (Quit: carllerche)
[00:48:55] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[00:49:02] *** Joins: slaren (slaren@moz-89461CF2.red-83-38-70.dynamicip.rima-tde.net)
[00:49:29] <olsonjeffery> cmr: so do you have lots of experience w/ c# 5.0?
[00:49:41] <cmr> olsonjeffery, almost none!
[00:49:45] <cmr> olsonjeffery, just using it now
[00:49:52] <olsonjeffery> are you a .net dev?
[00:49:53] <cmr> no
[00:49:56] <cmr> well, I will be
[00:49:59] <cmr> but I'm not right now
[00:50:10] <olsonjeffery> in a professional capacity? or you're just using to get comfortable with the api?
[00:50:20] <cmr> writing a game using unity, and also some utils and libraries for interacting with a game server
[00:50:32] <olsonjeffery> unity ships w/ c# 5.0?
[00:50:38] <olsonjeffery> as part of mono?
[00:51:04] <cmr> unfortunately not, but I am targeting more than just unity's mono with the utilities
[00:51:13] <olsonjeffery> yeah.. was gonna say
[00:51:14] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[00:51:25] <olsonjeffery> im pretty mainline mono has had 4.5 framework/c# 5.0 for some time
[00:51:32] <olsonjeffery> but unity lags quite a bit, from what ive gathered
[00:51:32] *** Joins: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net)
[00:51:36] <olsonjeffery> and they're using a heavily modified runtime
[00:51:37] <cmr> mainline mono does, yes.
[00:51:45] <olsonjeffery> yeah, i do c# in my day job
[00:51:48] <cmr> unity is a fork of mono 2.6 I think
[00:51:50] <olsonjeffery> but i haven't used the 5.0 stuff, yet
[00:51:52] <cmr> which is ancient
[00:52:02] <olsonjeffery> really, it seems way too magical, tbh
[00:52:07] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[00:52:11] <olsonjeffery> especially when used as an inspiration from over here in rust land
[00:52:27] <cmr> What does? async/await?
[00:52:32] <olsonjeffery> yes.
[00:52:40] <cmr> Yes, it is, and that is exactly why I like it :p
[00:52:56] <cmr> (I haven't *used* C# much before, and not C# 5.0, but I've been following it and .net closely)
[00:53:56] *** Joins: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net)
[00:55:42] <cmr> olsonjeffery, I don't think async/await is fully suitable for Rust, but a similar model ("just do it, I don't care how or with what") that is easy to interact with directly with "normal" rust would be cool
[00:55:49] <cmr> maybe could be implemented as a syntax ext, dunno.
[00:56:02] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[00:56:08] <olsonjeffery> async/await is pretty invasive
[00:56:47] <cmr> it does automatic CPS yeah?
[00:57:00] *** Joins: etw (john@moz-B2936CAB.nyc.res.rr.com)
[00:57:24] <olsonjeffery> when you use the `await` keyword as part of an expressive, the enclosing function returns the Task<T> in its signature immediately and its pushed onto an fuzzily defined execution pool which may be "the main loop" as we'd understand it in libuv/single-threading world
[00:57:31] <olsonjeffery> or a thread pool, as is the case in asp.net
[00:57:39] <olsonjeffery> s/expressive/expression/
[00:57:41] <dbaupp> cmr: the bencher seems to be solely a time machine atm?
[00:57:45] <olsonjeffery> so it kind of takes over your whole workflow
[00:57:53] <cmr> dbaupp, it's not on right now, I'm in windows for some stuff
[00:58:05] <dbaupp> cmr: oh, ok, that'd explain it!
[00:58:05] <olsonjeffery> anyways.. id like to revisit the semantics of Future<t>.. that's a big part of it for us
[00:58:33] <olsonjeffery> having finer grained control.. like the Future<T> implies a uv_async_t handle or something
[00:58:53] <olsonjeffery> and the .get() is resolved when uv_async_send is called
[00:58:57] *** Quits: pcwalton (pcwalton@9B0BC9DC.71128241.F9E1BAE1.IP) (Ping timeout)
[00:59:11] <olsonjeffery> brson has some ideas about it
[00:59:24] <olsonjeffery> im gonna try to make it to portland tomorrow and hopefully he'll be there and will to humor me
[00:59:29] <olsonjeffery> willing
[01:01:29] <olsonjeffery> anyways.. right now the future is a spawn and port/chan. maybe we can do better. std::rt::io::future or something. but i need to know more.
[01:01:50] *** Joins: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net)
[01:02:00] *** Quits: mschifer (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[01:02:07] <olsonjeffery> figuring that out is the major blocker for #6165
[01:02:24] *** Quits: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net) (Client exited)
[01:03:24] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[01:06:09] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[01:07:40] *** Joins: tchoma (tchoma@moz-E58E29CC.dsl.static.sonic.net)
[01:09:33] *** Quits: dormiens (dormiens@2F2DB458.B767B9B7.2675F9C0.IP) (Quit: ZNC - http://znc.in)
[01:10:03] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[01:10:26] *** Quits: bnicholson (bnicholson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[01:18:53] *** Quits: henrikhodne (henrikhodn@moz-87E975F1.dsl.static.sonic.net) (Ping timeout)
[01:24:29] *** Joins: dormiens (dormiens@2F2DB458.B767B9B7.2675F9C0.IP)
[01:27:09] <cmr> So in his compiler speed article Walter Bright said he "designed D to be compiled quickly". What does that mean, exactly?
[01:27:15] <cmr> SiegeLord, you might be able to comment on that
[01:27:33] <cmr> Go, for example, was designed to compile as fast as possible, iirc
[01:28:11] <cmr> And is there anything in Rust that would preclude "compiling quickly"?
[01:28:25] <cmr> Only thing I can really think of is the borrow checker, which no other language in this space has.
[01:28:34] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[01:29:08] <strcat> powerful type inference, generics, borrow checking, liveness checking
[01:29:25] <strcat> crates
[01:30:02] <strcat> you can throw in deriving, macros and syntax exts too
[01:30:17] <cmr> ah yes, macros and deriving.
[01:30:39] <dbaupp> (those should be pretty quick, not quite sure why they're so slow atm.)
[01:30:45] *** Quits: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: Leaving)
[01:31:05] <cmr> dbaupp, no matter how fast something is, doing it is always more expensive than not doing it :p
[01:31:24] <dbaupp> cmr: lies! time travel. :P
[01:31:41] <strcat> cmr: I think we should see what graydon has to say about https://github.com/mozilla/rust/pull/8035 before it lands
[01:31:48] <strcat> I think it's pretty important that those use the local allocator
[01:31:53] <strcat> but I don't know
[01:31:58] <cmr> ok
[01:32:03] <cmr> retracting r+ for now then
[01:32:19] <strcat> afaik they have to use the local allocator because they root the allocations
[01:33:37] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[01:37:19] *** Quits: bent (chatzilla@moz-2CD73AA6.triad.res.rr.com) (Quit: ChatZilla 0.9.90.1-rdmsoft [XULRunner 22.0/20130619132145])
[01:38:07] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[01:39:02] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[01:42:54] <SiegeLord> cmr: He means primarily context-free grammar and no headers
[01:43:28] <cmr> SiegeLord, isn't DMD's CTFE quite slow?
[01:43:37] <SiegeLord> It doesn't actually compile that quickly... e.g. if you compare LDC to DMD
[01:43:46] <cmr> heh
[01:43:58] <SiegeLord> You'll note that using LLVM instead of DMD's backend slows down the compillation significantly
[01:44:15] <SiegeLord> And if you look at DMC (Walter's C++ compiler) it's also lightning fast
[01:44:22] <SiegeLord> Not quite as fast as DMD though
[01:44:37] <SiegeLord> Anyway, I hope they're not claiming it compiles faster than Go :P
[01:44:43] <cmr> no, it didn't claim that
[01:45:03] *** Joins: tav (tav@moz-C9F0879A.range86-145.btcentralplus.com)
[01:45:04] <SiegeLord> They did at one point... they compiled the standard library and then did LOC/sec
[01:45:04] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[01:45:09] *** Quits: heftig (heftig@8D5076D2.6FC4DE2F.FEC4A986.IP) (Quit: Quitting)
[01:45:23] <SiegeLord> And it was faster than Go... which is all nice and good until you realize that D's standard library is mostly templates
[01:45:40] <SiegeLord> So in fact they generated very little code in that "compillation"
[01:46:52] <SiegeLord> And yes, CTFE is somewhat slow
[01:47:41] *** Joins: steven_is_false (user@C5B76363.1FF1EBF8.1ECA502.IP)
[01:48:35] *** Joins: doomrobo (doomrobo@EC9C662A.161AAEB2.58B1C2DD.IP)
[01:48:58] <steven_is_false> Hi! I may have found a new bug but probable have not. Does anyone know if this bug has already been found? The code at http://pastebin.mozilla.org/2711900 results in the error error: internal compiler error: drop_ty_immediate: non-box ty.
[01:49:54] <doomrobo> hey peoplez. I'm trying "use std::str::split_iter" and I'm getting "failed to resolve import". I'm using 0.8-pre. What's the problem?
[01:49:58] <SiegeLord> Also need to note that D doesn't do typechecking etc on uninstantiated templates, just like in C++
[01:50:16] <engla> doomrobo: it's a method on str
[01:50:19] <cmr> doomlord_, split_iter is a method, not a function.
[01:50:22] <cmr> erm, doomrobo
[01:50:35] <doomrobo> stupid me
[01:50:36] <doomrobo> thansk
[01:50:38] <doomrobo> *thanks
[01:52:10] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[01:52:59] <engla> it's easy to feel stupid when things change so fast. I'm sure it was a function just some weeks ago
[01:53:23] <doomrobo> well I'm new so I don't have that excuse :P
[01:53:46] <engla> just go with it ^^
[01:54:36] <doomrobo> oh, yeah. I've been developing exclusively for Rust for a while now, you know backend optimization with bytecode concurrent assembly compilation and what not. Must have slipped my mind
[01:54:37] <doomrobo> better?
[01:56:33] <engla> great. is your doomrobot built with Rust, i.e. the actual new overlords are powered by Rust?
[01:57:05] *** Quits: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com) (Quit: tikue)
[01:57:16] <doomrobo> For sure, but every once in a while they start yelling words like "alias" and "match" for some reason
[01:58:35] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[01:58:48] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[01:59:15] <SiegeLord> http://www.drdobbs.com/cpp/c-compilation-speed/228701711
[01:59:36] <bjz> dbaupp erickt sebcrozet: https://github.com/mozilla/rust/pull/8049#issuecomment-21594753
[01:59:40] <SiegeLord> So Walter probably fixed all those in D
[01:59:52] <bjz> dbaupp erickt sebcrozet: opinions?
[01:59:55] <SiegeLord> But Rust solves them too, so there you go ;)
[02:00:58] <dbaupp> bjz: seems alright
[02:01:23] <doomrobo> I'm trying to write a function that iterates through the result of split_iter and returns a vector. What exactly should the return type of the function be? [str], ~[str], ~[~str]?
[02:01:49] <cmr> ~[~str]
[02:01:52] <cmr> you don't need to though
[02:02:03] <doomrobo> ?
[02:02:06] <cmr> foo.split_iter().collect::<~[~str]>()
[02:02:26] <doomrobo> DOCS ARE AN IMPORTANT THING
[02:02:32] <cmr> The docs are there
[02:02:34] <cmr> in std::iterator
[02:02:43] <dbaupp> doomrobo: we know
[02:02:49] <cmr> but yeah
[02:02:51] <cmr> I'm working on it
[02:02:57] * doomrobo is just ranting :)
[02:02:58] <dbaupp> doomrobo: the problem with docs is they go out of date really fast with Rust
[02:03:04] <dbaupp> it just moves too fast.
[02:04:29] <doomrobo> cmr where? because I'm looking at http://static.rust-lang.org/doc/std/iterator.html and it just looks terrible. I can't see a concise list of methods
[02:04:45] <cmr> doomlord_, the ToC is incomplete and misleading.
[02:04:53] <cmr> You need to actually go through the traits for the methods.
[02:05:08] <cmr> http://static.rust-lang.org/doc/std/iterator.html#trait-iteratorutil
[02:05:11] <cmr> "Method collect"
[02:05:42] <doomrobo> ah, ok
[02:06:05] <cmr> accurate and linkable ToCs is one of the more important goals of rustdoc_ng
[02:07:29] <dbaupp> (you can view-source or use `#method-<methodname>` to a get a link to methods, e.g. http://static.rust-lang.org/doc/std/iterator.html#method-collect, btw.)
[02:08:03] <cmr> dbaupp, it's frequently incorrect though.
[02:08:21] <dbaupp> cmr: yup
[02:08:48] *** Joins: Sodel_the_V (user@moz-853663E1.va.shawcable.net)
[02:09:06] <doomrobo> cmr you're personally working on it?
[02:09:12] <cmr> doomrobo, yes
[02:10:28] <engla> oh so iterator has .to_owned_vec() now? I missed that one
[02:11:01] <cmr> engla, landed this week yeah
[02:11:11] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[02:11:14] <engla> ok
[02:11:46] <engla> it's useful
[02:13:27] <dbaupp> did strcat complain/notice that?
[02:15:01] *** Joins: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net)
[02:15:13] <engla> don't know, it was part of sully's trait and method fixes PR
[02:16:40] <engla> trading that method for being able to remove all dummy type parameters
[02:16:54] <engla> strcat's going to come out very positive ;-)
[02:16:55] <doomrobo> I ended up having to do string.split_iter().transform(|i| i.to_owned()).to_owned_vec(); to transform a &str iterator to ~[~str]
[02:16:57] *** Quits: sebcrozet (sebcrozet@moz-A855F6C0.w82-127.abo.wanadoo.fr) (Ping timeout)
[02:17:12] <dbaupp> yes
[02:17:26] <dbaupp> engla: haha
[02:17:35] <doomrobo> woohoo! I did something right~
[02:17:37] *** Quits: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net) (Ping timeout)
[02:17:41] <doomrobo> *!
[02:17:47] <dbaupp> :D
[02:18:04] <doomrobo> what is the best way of printing a vector?
[02:18:44] <engla> println(v.to_str())  for now
[02:18:48] *** Quits: jgilbert (jgilbert@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[02:19:32] <dbaupp> or fmt!("%?", v)
[02:19:43] <dbaupp> well, printfln!("%?", v)
[02:19:50] <doomrobo> great
[02:19:56] <engla> yeah. the latter always works but is more of a raw representation
[02:20:18] <engla> oh that reminds me..
[02:22:27] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[02:26:38] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[02:30:34] *** Parts: Sodel_the_V (user@moz-853663E1.va.shawcable.net) (Killing koopas in another castle)
[02:31:09] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[02:35:18] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Quit: Textual IRC Client: www.textualapp.com)
[02:36:53] <doomrobo> why can't I import std::vec::filter?
[02:36:58] <doomrobo> and this one *is* a function
[02:37:36] <engla> doesn't exist in the current version
[02:38:06] <doomrobo> are there 0.8 docs?
[02:38:24] <dbaupp> http://static.rust-lang.org/doc/std/vec.html
[02:38:31] <dbaupp> (it's a method on iterators, btw)
[02:38:45] <dbaupp> v.iter().filter(filter_func). ...
[02:39:02] <dbaupp> http://static.rust-lang.org/doc/std/iterator.html#method-filter
[02:40:11] <doomrobo> actually this works better. Now I can chain all my transformations together
[02:40:30] *** Joins: dew (Instantbir@moz-8A63B53.dhcp.stls.mo.charter.com)
[02:40:58] <dbaupp> yep, that's precisely what they're designed for
[02:41:01] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[02:41:15] <dbaupp> (well, one neat thing that they allow.)
[02:43:07] <doomrobo> I can't terminate a line on a period, can I? how do I break up the iterator chaining over multiple lines?
[02:43:21] <eatkinson> is there a good way to get something like this to compile:
[02:43:23] <eatkinson> https://gist.github.com/eric93/6085682
[02:43:40] <strcat> eatkinson: give a type hint
[02:43:45] <aatch> doomrobo, rust is whitespace insensitive
[02:43:45] <strcat> foo::<T>()
[02:43:49] <strcat> let x: T = foo();
[02:44:28] <aatch> doomrobo, so this: foo . method() is the same as foo.method() is the same as foo . <newline> method <newline> ()
[02:44:36] <doomrobo> nice
[02:44:38] <engla> doomrobo: it's normal to split the iterator pipeline before the dots
[02:44:44] <dbaupp> eatkinson: you've got an extra `;` in do_create
[02:44:46] *** Joins: henrikhodne (henrikhodn@moz-F3A92B1C.hsd1.ca.comcast.net)
[02:45:13] <eatkinson> dbaupp: true, but i can't even get it to typecheck
[02:45:21] <dbaupp> eatkinson: what's the error?
[02:45:30] <eatkinson> test.rs:18:4: 18:18 error: cannot determine a type for this bounded type parameter: unconstrained type
[02:45:31] <eatkinson> test.rs:18     Create::create(0);
[02:45:47] <engla> eatkinson: that semicolon there is wrong
[02:45:54] <engla> you suppress the return value
[02:46:05] <dbaupp> right, drop the `;`, then it'll get inferred from the `-> T` of the function
[02:46:23] <engla> and later, add the type hint that was hinted about
[02:46:32] <engla> to do_create()
[02:46:44] <eatkinson> engla, dbaupp: i see, that error is really confusing
[02:47:39] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[02:49:34] *** Quits: seth (seth@moz-D840E602.dsl.static.sonic.net) (Input/output error)
[02:51:43] *** Joins: erickt2 (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[02:51:43] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Connection reset by peer)
[02:52:00] *** Joins: vk (chatzilla@66D44E2E.B568D26C.93B001FA.IP)
[02:52:06] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[02:53:14] *** Joins: z0w0 (zack@moz-E12708D5.lns6.woo.bigpond.net.au)
[02:54:01] *** Quits: zz_kimundi (kimundi@moz-E839B363.dip0.t-ipconnect.de) (Ping timeout)
[02:54:34] <doomrobo> what's the difference between shift and pop?
[02:54:39] <doomrobo> (for vectors)
[02:54:57] <strcat> pop is an O(1) removal from the end, shift is moving everything over to the left
[02:55:03] <dbaupp> front / back respectively
[02:55:05] *** Quits: tchoma (tchoma@moz-E58E29CC.dsl.static.sonic.net) (Quit: My MacBook has gone to sleep. ZZZzzz‚Ä¶)
[02:55:11] <dbaupp> (shift is O(n))
[02:56:22] <doomrobo> ok
[02:57:08] *** Joins: zz_kimundi (kimundi@moz-320FAC37.dip0.t-ipconnect.de)
[02:57:24] *** zz_kimundi is now known as kimundi
[03:03:24] *** Quits: geomyidae (cole@DD6F7E3A.21468E9A.30200F38.IP) (Ping timeout)
[03:04:49] *** Joins: jfbk (textual@moz-EEA9CFB3.nyc.res.rr.com)
[03:08:03] <strcat> dbaupp: s3 certainly takes a long time to update ;p
[03:08:06] <strcat> dbaupp: http://static.rust-lang.org/doc/tutorial-container.html#random-access-iterators :)
[03:08:35] <dbaupp> awesome!
[03:09:02] <dbaupp> can we have .swap() on them?
[03:09:24] <strcat> dbaupp: on a mutable trait inheriting from it
[03:09:48] <dbaupp> cool.
[03:15:57] <engla> dbaupp: I don't have anything to add to lib-fmt, the writer/string writer issue seems to be mostly tangential and rather minor. I have nothing to add to the format string design
[03:16:19] <dbaupp> engla: ok
[03:16:33] <engla> dbaupp: that said, I want to experiment with just passing down a writer in ToStr trait instead. That shouldn't overlap very much (?)
[03:16:55] <dbaupp> yeah, sounds good.
[03:17:06] <dbaupp> (it'll have to happen some time anyway.)
[03:17:13] <dbaupp> might as well be now! :)
[03:18:25] <cmr> So trait ToStr<T: Writer<~str>> { fn to_str(&self, writer: T) { ... } } ?
[03:19:07] <doomrobo> why is there no str::is_numeric? only is_alphanumeric
[03:20:14] <dbaupp> doomrobo: because not-implemented-yet :P
[03:20:20] *** Joins: steve (Steve@AD5BB60D.88ADF168.89D37B92.IP)
[03:20:48] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: sleep)
[03:21:33] <dbaupp> doomrobo: there's char::is_digit
[03:21:53] <doomrobo> THEN WHY DOES NOBODY?I'LL DO IT
[03:21:55] <dbaupp> so string.iter().all(char::is_digit) works
[03:22:02] <engla> cmr: WIP is    fn write_str<W: StringWriter>(&self, &mut W)  as the second method. Just a convenient way to ease this in while developing. Will bench for the difference
[03:22:13] <cmr> ok
[03:22:17] <dbaupp> <3 #[bench]
[03:22:41] <cmr> doomrobo, because it's of extremely minor importance?
[03:22:53] <cmr> nobody has needed it, so nobody has added it
[03:23:27] <doomrobo> well I need it right now. Could I actually put in a pull request for that?
[03:23:35] <cmr> yes
[03:23:56] <cmr> Actually
[03:24:02] <cmr> Why does str::is_alphanumeric exist?
[03:24:10] <cmr> Those operations should only exist for Ascii right now
[03:25:18] <doomrobo> "I don't know bro, I just work here". wait, *you're* the one who can actually say that
[03:25:19] <dbaupp> it's unicode is_alphanumeric
[03:25:30] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[03:25:31] <cmr> oh ok
[03:25:35] <dbaupp> dammit, rusti's not here and strcat just left.
[03:25:37] <cmr> are they all in some range or something?
[03:25:59] <cmr> doomrobo, I think you overestimate rust's level of maturity.
[03:25:59] <engla> tables are in unicode.rs, it has all the general categories. long lists of ranges
[03:26:08] <dbaupp> `rusti> "√∂√§√•".is_alphanumeric() >>> true`
[03:26:11] <doomrobo> cmr no, I'm just good at complaining :P
[03:26:29] <dbaupp> doomrobo: well, stop! and fix it! :P
[03:26:49] *** Parts: steve (Steve@AD5BB60D.88ADF168.89D37B92.IP) ()
[03:27:27] <steven_is_false> rusti: "ŒªŒºŒ∑Œ£Œ†‚à´".is_alphanumeric()
[03:27:27] -rusti- false
[03:27:30] *** Quits: jfbk (textual@moz-EEA9CFB3.nyc.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzz‚Ä¶)
[03:27:31] <steven_is_false> rusti: "ŒªŒºŒ∑Œ£Œ†".is_alphanumeric()
[03:27:32] -rusti- true
[03:28:37] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[03:28:38] <dbaupp> oh, rusti is here... why did it tab-complete :/
[03:28:42] <dbaupp> *didn't
[03:29:57] <doomrobo> dbaupp just wrote it, I'll fork and submit a pull request now
[03:30:02] *** Quits: echristo (echristo@60A74940.D6CCE4AE.77834EAA.IP) (Ping timeout)
[03:30:35] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[03:30:59] <doomrobo> steven_is_false how is that possible?!
[03:31:07] <dbaupp> rusti: std::char::is_digit('‚Ö°')
[03:31:08] -rusti- true
[03:31:08] *** Joins: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net)
[03:31:21] <dbaupp> doomrobo: ^ it probably doesn't do what you want it to do.
[03:31:22] <steven_is_false> doomrobo: How is what possible?
[03:31:34] *** Joins: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net)
[03:32:21] <doomrobo> steven_is_false you just ran the same thing twice and got different results
[03:32:34] <steven_is_false> doomrobo: I omitted the integral sign in the second one.
[03:32:45] <steven_is_false> The integral sign isn't actual greek.
[03:32:46] <dbaupp> rusti: "‚ÜÜ‚Üà‚Öù‚ÜÄ".iter().transform(std::char::is_digit).to_owned_vec()
[03:32:46] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/eKJD
[03:33:01] <dbaupp> rusti: "‚ÜÜ‚Üà‚Öù‚ÜÄ".iter().transform(std::char::is_digit).collect::<~[bool]>()
[03:33:01] -rusti- ~[true, true, true, true]
[03:33:18] * ChrisMorgan just went to look at the logs for some context, but it's full of ? symbols
[03:33:24] <doomrobo> dbaupp WTF
[03:33:40] <dbaupp> rusti: std::char::is_digit('êÖÖ')
[03:33:40] -rusti- true
[03:33:45] *** Quits: mye (mye@moz-5743385C.dip0.t-ipconnect.de) (Ping timeout)
[03:34:02] <klutzy> unicode is funky
[03:34:06] <ChrisMorgan> And why does nothing rusti says appear in the log?
[03:34:11] <doomrobo> I don't think that's a unicode thing
[03:34:18] <doomrobo> dbaupp is that a bug or intended?
[03:34:27] <dbaupp> doomrobo: unicode: http://en.wikipedia.org/wiki/Ancient_Greek_Numbers_%28Unicode_block%29
[03:34:37] <cmr> ChrisMorgan, doesn't log notices apparently.
[03:34:38] <engla> ChrisMorgan: rusti says everything in announce mode
[03:34:46] <doomrobo> dbaupp whatever you wrote did not show up in my IRC client
[03:34:47] <klutzy> doomrobo: python actually do in a similar way.
[03:34:49] <dbaupp> doomrobo: http://en.wikipedia.org/wiki/Number_Forms_%28Unicode_block%29
[03:34:51] <doomrobo> it looked like you wrote ""
[03:34:55] *** Joins: mye (mye@moz-FFDA3A47.dip0.t-ipconnect.de)
[03:34:58] <doomrobo> rather ''
[03:35:06] <ChrisMorgan> Why would rusti use announce mode?
[03:35:10] <dbaupp> doomrobo: well, I didn't, it was one of the ones from Ancient Greek Numbers
[03:35:23] <dbaupp> ChrisMorgan: because that's what bots are supposed to sue
[03:35:24] <dbaupp> *use
[03:35:25] <doomrobo> oh, ok. I'm good with that
[03:35:31] <cmr> ChrisMorgan, http://tools.ietf.org/html/rfc2812#section-3.3.2
[03:35:48] <dbaupp> ChrisMorgan: https://botbot.me/mozilla/rust/ shows rusti's output
[03:35:52] <cmr> "announce mode" is incorrect.
[03:35:55] <cmr> they are just NOTICEs
[03:36:50] <ChrisMorgan> Hmm. Don't like irclog.gr, then.
[03:37:09] <dbaupp> doomrobo: fwiw, I'd disagree with a string.is_numeric() using std::char::is_digit, because it definitely doesn't do what most people are expecting
[03:37:34] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[03:37:40] <cmr> dbaupp, what most people are expecting is ascii
[03:37:44] <dbaupp> doomrobo: it could be called string.is_decimal() and just check '0' to '9'
[03:37:51] <dbaupp> cmr: exactly
[03:38:17] <steven_is_false> rusti: "01321".iter().all(|x| x.is_digit())
[03:38:18] -rusti- true
[03:38:58] <doomrobo> ok
[03:39:01] <dbaupp> rusti: let s = "‚ÜÜ‚Üà‚Öù‚ÜÄ"; (s.char_len(), s.iter().all(|c| c.is_digit())
[03:39:01] -rusti- <anon>:8:4: 8:5 error: incorrect close delimiter: `}`
[03:39:02] -rusti- <anon>:8     };
[03:39:02] -rusti-              ^
[03:39:02] -rusti- application terminated with error code 101
[03:39:02] <steven_is_false> rusti: let val = "01321"; val.head() != 0 && val.iter().all(|x| x.is_digit())
[03:39:03] -rusti- <anon>:7:28: 7:41 error: type `&'static str` does not implement any method in scope named `head`
[03:39:03] -rusti- <anon>:7          let val = "01321"; val.head() != 0 && val.iter().all(|x| x.is_digit())
[03:39:05] -rusti-                                      ^~~~~~~~~~~~~
[03:39:06] <dbaupp> rusti: let s = "‚ÜÜ‚Üà‚Öù‚ÜÄ"; (s.char_len(), s.iter().all(|c| c.is_digit()))
[03:39:06] *** concrete.mozilla.org sets mode: +M 
[03:39:07] -rusti- error: aborting due to previous error
[03:39:09] -rusti- application terminated with error code 101
[03:39:10] -rusti- (4, true)
[03:39:48] <ChrisMorgan> OK, attempting "trait X: Send" is absolutely broken. :-(
[03:40:41] <tjc> ChrisMorgan: Yes, it is - https://github.com/mozilla/rust/issues/3984
[03:41:05] <ChrisMorgan> I'd been thinking it was only mostly broken, but I confirmed now that it's entirely broken.
[03:41:29] <cmr> sully, maybe you want to take a look at that?
[03:41:33] *** Quits: tjc (tjc@moz-8DCE981F.hsd1.ca.comcast.net) (Quit: Places to go, people to annoy)
[03:41:46] <cmr> he just fixed a bunch of trait inheritance bugs
[03:41:46] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[03:42:40] *** Quits: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net) (Ping timeout)
[03:43:15] *** Joins: seth (seth@moz-D840E602.dsl.static.sonic.net)
[03:43:31] *** Joins: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP)
[03:43:36] <ChrisMorgan> Well, it was all related to https://github.com/mozilla/rust/issues/7661 for me.
[03:44:10] *** concrete.mozilla.org sets mode: -M 
[03:44:24] <ChrisMorgan> Wah... upgraded to Ubuntu 13.10 but my HTTP server perf is still mysteriously around 800 rps rather than the 2400 I had been getting two reboots ago :-(
[03:44:55] <cmr> ChrisMorgan, what rustc are you using? sully fixed https://github.com/mozilla/rust/issues/7661
[03:45:02] <cmr> you commented on it.
[03:45:06] <cmr> *oh, you..
[03:45:18] <doomrobo> how would I filter characters out of a string?
[03:49:24] <ChrisMorgan> rusti: "1x2x3".iter().filter(|&c| c != 'x').collect::<~[char]>()
[03:49:24] -rusti- ~['1', '2', '3']
[03:49:26] <doomrobo> ah, collect should work
[03:50:03] * shachaf wonders what's with the +M
[03:50:13] <doomrobo> rusti: "1x2x3".iter().filter(|&c| c != 'x').collect::<~str>()
[03:50:14] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/bDXa
[03:50:18] <cmr> shachaf, flood prevention.
[03:50:24] <shachaf> Hmm.
[03:50:28] <shachaf> Maybe I should register.
[03:50:48] <shachaf> Eh. I could just not talk instead.
[03:51:40] <ChrisMorgan> In such a char iterator, how can you turn it into a string?
[03:51:49] *** Quits: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP) (Ping timeout)
[03:52:01] <doomrobo> I'm curious why it didn't work when I just gave it ~str
[03:52:11] <dbaupp> rusti: let mut s = ~""; for "1x2x3".iter().filter(|&c| c != 'x').advance |c| { s.push_char(c); } s
[03:52:12] -rusti- ~"123"
[03:52:13] *** Joins: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP)
[03:52:27] <doomrobo> that's cheating
[03:52:30] <dbaupp> FromIterator<char> isn't implemented for str (yet)
[03:52:35] <cmr> not really? anything else would do the same thing.
[03:52:44] <doomrobo> but not nearly as pretty :P
[03:53:33] * ChrisMorgan was hoping it wasn't that way
[03:53:43] <cmr> dbaupp, hmm, is string allocation growth the same as vector allocation growth?
[03:53:51] <cmr> I could see that potentially consuming a *lot* of memory
[03:53:58] <dbaupp> cmr: yup
[03:54:02] <cmr> yikes
[03:54:07] <cmr> I bet fixing that would help on 32 bit
[03:54:08] <dbaupp> cmr: in what way? it gets deallocated
[03:54:09] <cmr> (for rustc)
[03:54:17] <cmr> dbaupp, not in the AST or codemap!
[03:54:19] <dbaupp> (the old ones get deallocated)
[03:54:29] <cmr> yes, but it is still doubling in size.
[03:54:33] <dbaupp> ... we don't .push_char very much?
[03:54:40] <dbaupp> only when it needs too
[03:54:52] <dbaupp> so we're using *at most* 2x as much as we need
[03:55:25] <cmr> So other string creation doesn't take the growing codepath, it allocates exactly?
[03:55:40] <dbaupp> some of it does, yes.
[03:56:04] <dbaupp> .to_owned()/.to_managed() uses .reverse rather than .reserve_at_least
[03:56:20] <eevee> haha.  reading libextra for inspiration on fixing my amulet pointer problem, and i see dlist cheats and uses * for the backwards pointers
[03:56:25] <dbaupp> (well, actually, with_capacity, which does over allocate)
[03:56:42] <dbaupp> nope. it doesn't
[03:56:47] * dbaupp remembered wrong
[03:57:29] <cmr> eevee, nothing wrong with cheating if you know it's correct :)
[03:57:37] <cmr> (not that I'm saying dlist is correct, I don't know)
[03:57:58] <eevee> i think i'm just stuck enforcing that Terminal is always @
[03:57:58] <dbaupp> it was recently rewritten, so it's probably fairly correct.
[03:58:12] <dbaupp> (rewritten and tested, that is.)
[03:58:51] <engla> I wrote it, the logic shouldn't be that difficult
[03:59:11] <cmr> Hm we should have a code review process similar to bug triage
[03:59:15] *** Quits: LU324_ (stuff@moz-A17E9A7B.dyn.embarqhsd.net) (Ping timeout)
[03:59:21] <cmr> Everyone gets a function or two that hasn't been touched in a while.
[03:59:29] <dbaupp> cmr: that'd be cool
[03:59:31] <cmr> Verify that it's idiomatic/necessary/etc
[03:59:40] <dbaupp> cmr: we should start with ones with `unsafe {}` blocks though
[04:00:06] <dbaupp> *we could
[04:00:13] <bjz> dbaupp: what must you implement for iterators?
[04:00:22] <cmr> bjz, std::iterator::Iterator<T>
[04:00:29] <dbaupp> bjz: Iterator<type that gets yielded>
[04:00:38] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[04:00:39] <engla> bjz: just one method, .next()
[04:00:46] <dbaupp> and that requires fn next(&mut self) -> Option<T>
[04:00:52] <cmr> and size_hint if you care (there's a default impl)
[04:01:00] <bjz> can we do default methods with them yet?
[04:01:08] <cmr> bjz, with what? iterators?
[04:01:11] <bjz> aye
[04:01:19] <cmr> default method for next doesn't really make sense
[04:01:48] <bjz> I thought that there was a problem with default methods making things more verbose
[04:02:19] <cmr> there is, you need to use .iter() on containers that could, in theory, implement an Iterable trait that makes them directly itarable
[04:04:30] <bjz> dbaupp: how would I efficiently impl an iterator for a Vec3<T> { x: T, y: T, z: T }?
[04:04:50] <bjz> dbaupp: transmute to a [T,..3] then call next?
[04:05:06] <cmr> (Iterators aren't implemented for [T,..n])
[04:05:12] <bjz> s;iofja;isjf;ljsd;ifj;osdfj
[04:05:12] *** Quits: ahui (Mibbit@3624352C.AD379810.85518BE6.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[04:05:20] <bjz> goddamnit
[04:05:48] <bjz> cmr: are they impled for low-dimensioned tuples?
[04:05:55] <cmr> bjz, not afaik
[04:06:43] <bjz> cmr: I want to do vectorised zipping and adding etc
[04:06:49] <cmr> bjz, the easiest thing would probably be conjuring a &[T] and using an iterator on that
[04:08:14] *** Quits: timm (timm@moz-37B954AF.superkabel.de) (Input/output error)
[04:09:21] <bjz> dbaupp: it would be cool if there was a deriving(Iterator) for packed, homogeneous types
[04:10:58] <engla> bjz: you can reuse std::vec::VecIterator for that for sure
[04:11:30] <engla> step 1. make a macro 2. use raw pointers 3. win?
[04:13:05] *** Quits: doomrobo (doomrobo@EC9C662A.161AAEB2.58B1C2DD.IP) (Quit: Leaving)
[04:13:05] *** Joins: dherman (dherman@moz-F35A8539.hsd1.or.comcast.net)
[04:13:05] *** ChanServ sets mode: +o dherman
[04:14:23] <dbaupp> bjz: you should be able to transmute to a [T,..n], call iter() (which borrows it to a &[T]) and it'll just work.
[04:16:43] <bjz> oh so I can't do trait VectorSpace<T>: Iterator<T>
[04:16:53] <bjz> dbaupp: do I need another struct?
[04:17:09] <bjz> dbaupp: or do I have an iter method?
[04:17:12] *** Quits: qmx (qmx@moz-D6C3C2E6.qmx.me) (Ping timeout)
[04:18:41] <dbaupp> you'll need a struct that records the state of the iterator (even if it's just storing the vector one.)
[04:20:01] <engla> if you just return the VecIterator you don't need a new type
[04:20:07] <bjz> dbaupp: https://gist.github.com/bjz/f46dbbb0397d5e443754
[04:20:09] *** Joins: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net)
[04:20:45] <dbaupp> bjz: strictly speaking `Eq` shouldn't be there :P
[04:20:53] <bjz> yeah?
[04:21:02] <dbaupp> and Iterator only makes sense for some Vector spaces
[04:21:11] <bjz> dbaupp: ok
[04:21:12] *** Joins: qmx (qmx@moz-D6C3C2E6.qmx.me)
[04:21:40] <bjz> dbaupp: yep
[04:21:55] <dbaupp> (although, I could imagine that keeping Iterator has advantages that outweight the disadvantages.)
[04:22:21] <bjz> dbaupp: I want a way of impling things enmass
[04:22:50] <dbaupp> default methods?
[04:22:55] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Quit: WeeChat 0.4.1)
[04:23:01] <bjz> dbaupp: aye
[04:23:26] <dbaupp> in any case, as erickt says on that bug, it might be better to leave Vector out of std for now, so you can just use your own Vector trait.
[04:23:42] <bjz> I'm not adding it to std
[04:23:45] <dbaupp> right
[04:23:48] <bjz> just for lmath
[04:24:04] <dbaupp> yeah, well, keep Eq and Iterator then :)
[04:25:15] <bjz> I'm thinking I should have som macros to test the algebraic properties :)
[04:25:16] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[04:26:52] <bjz> dbaupp: so how would I do the iterators for those types?
[04:27:13] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Ping timeout)
[04:28:08] *** Quits: mye (mye@moz-FFDA3A47.dip0.t-ipconnect.de) (Quit: mye)
[04:28:29] <dbaupp> bjz: the transmutation should work.
[04:28:52] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[04:28:55] <engla> rusti: struct V {x:int, y:int, z:int}; unsafe { let v: [int,..3] = std::cast::transmute(V{x:1,y:2, z:3}); let it =v.iter(); it.transform(|&x| x).collect::<~[int]>().to_str() }
[04:28:55] -rusti- ~"[1, 2, 3]"
[04:29:03] <engla> see, it works ^^
[04:29:11] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[04:30:17] *** Quits: dherman (dherman@moz-F35A8539.hsd1.or.comcast.net) (Quit: dherman)
[04:30:17] <bjz> dbaupp: but would I need my own iteratoir stuct
[04:30:27] <bjz> I want to collect into my vectors
[04:30:54] *** Joins: recrack (Mibbit@B4104EBB.3CC170B1.1E14B209.IP)
[04:31:04] <dbaupp> bjz: in theory you can return the std::vec::VecIterator directly
[04:31:11] <engla> bjz: that's a separate thing
[04:31:30] <engla> bjz: FromIterator (.collect()) works with any kind of iterator
[04:31:35] <bjz> e
[04:31:41] <bjz> engla: oh coolies
[04:31:47] <dbaupp> i.e. impl Vec2<T> { ... fn iter<'a>(&'a self) -> VecIterator<'a, T> { transmute(*self).iter() } or something
[04:32:54] *** Quits: vk (chatzilla@66D44E2E.B568D26C.93B001FA.IP) (Quit: ChatZilla 0.9.90.1 [Firefox 23.0/20130722172257])
[04:33:50] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[04:33:53] <bjz> engla: any way of super-efficiently trannsmuting the iterator into the struct again from the returned iterator?
[04:34:01] <bjz> ie. for FromIterator
[04:34:04] <dbaupp> nope
[04:34:30] <dbaupp> (for FromIterator, the iterator could be anything.)
[04:34:48] <bjz> dbaupp
[04:34:51] <bjz> woops
[04:34:53] <dbaupp> bjz
[04:34:54] <bjz> hit enter
[04:34:56] <dbaupp> :P
[04:34:57] <bjz> :)
[04:35:07] <bjz> dbaupp: so any ideas?
[04:35:12] <bjz> make my own?
[04:35:34] <bjz> or just not use iterators?
[04:35:51] <dbaupp> I guess Vec3 { x: it.next().unwrap(),  y: it.next().unwrap(),  z: it.next().unwrap() } will optimise very well for e.g. VecIterator
[04:36:06] <dbaupp> (emphasising the guess.)
[04:36:23] <bjz> where would I put that?
[04:36:38] <dbaupp> in the FromIterator impl for Vec3
[04:36:39] <bjz> (really sorry for being so stupid)
[04:36:45] <bjz> ohhh
[04:36:47] <bjz> nice
[04:37:01] <engla> bjz: the efficient way to implement FromIterator would be to hardcode it for each vector size and fail!() if it's the wrong size. but probably still not very efficient
[04:37:22] <engla> ah, see the thing dbaupp said
[04:37:26] <dbaupp> (but iterators aren't designed for a super efficient Vec3 -> Iterator -> Vec3 round trip: they're much better at actually iterating.)
[04:37:33] <engla> hehe
[04:38:19] *** Joins: eatkinson (eatkinson@moz-AD233F1B.dia.static.qwest.net)
[04:38:40] *** Joins: timm (timm@moz-37B954AF.superkabel.de)
[04:38:46] * bjz doesn't know what to do
[04:39:08] * engla doesn't know what you want to do
[04:39:19] * dbaupp doesn't have any more advice
[04:40:44] <bjz> engla: I want to be able to generalise Vec3 { x: self.x + other.x, y: self.y + other.y, z: self.z + other.z }
[04:41:05] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[04:41:22] <dbaupp> bjz: there's no way you can do the final -> Vec3 step with a transmute
[04:42:08] <bjz> engla: or self.x * other.x + self.y * other.y + self.z * other.z
[04:42:13] <dbaupp> bjz: (I have a feeling trying Iterators and seeing how well they optimise.)
[04:42:58] <bjz> dbaupp: mmk
[04:43:54] <engla> bjz: I'd implement a map function, I have one to show
[04:44:31] *** Quits: timm (timm@moz-37B954AF.superkabel.de) (Ping timeout)
[04:44:37] <engla> bjz: https://gist.github.com/anonymous/af374c5599cb48908f93  implement this once for each size
[04:44:51] *** Quits: Earnestly (earnest@2AB30F53.FB5005.2BCC804A.IP) (Ping timeout)
[04:47:05] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[04:48:55] *** Quits: eatkinson (eatkinson@moz-AD233F1B.dia.static.qwest.net) (Quit: eatkinson)
[04:54:17] *** Quits: RMF (RMF@moz-6AD5ED61.dsl.telepac.pt) (Quit: Textual IRC Client: www.textualapp.com)
[04:55:47] <sp3d> wow, %? is a lot of overhead on tiny-tiny programs
[04:56:08] <Jeaye> compile time or runtime?
[04:56:14] *** Joins: tjc (tjc@moz-6EB4E533.dsl.tsoft.com)
[04:56:14] *** ChanServ sets mode: +o tjc
[04:56:17] <sp3d> .43s to compile a program using println vs. .71s to compile with %?
[04:56:30] <cmr> sp3d, it expands to a lot of code.
[04:56:42] <sp3d> yeah, I noticed this because I wanted to look at match codegen :)
[04:56:42] <Jeaye> Jeeze, you might need to upgrade your system for that.
[04:57:11] * Jeaye forgot he's in an on-topic channel, sorry.
[04:58:21] <cmr> Jeaye, like every channel in existence that I know of, it's only on-topic when it's busy:p
[04:58:38] <dbaupp> (and not always that :P )
[05:01:35] <Jeaye> ^_^
[05:05:04] *** Joins: sebcrozet (sebcrozet@moz-7FB6C00B.w193-252.abo.wanadoo.fr)
[05:06:24] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[05:07:18] *** Quits: erickt2 (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[05:07:45] *** Joins: pnathan (Adium@moz-BDC3EE62.tukw.qwest.net)
[05:11:08] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz‚Ä¶)
[05:12:24] *** Joins: pcwalton (pcwalton@moz-A746ED0D.hfc.comcastbusiness.net)
[05:12:24] *** ChanServ sets mode: +o pcwalton
[05:13:06] *** Parts: pnathan (Adium@moz-BDC3EE62.tukw.qwest.net) ()
[05:13:12] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[05:15:29] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[05:17:02] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[05:24:31] *** Quits: seth (seth@moz-D840E602.dsl.static.sonic.net) (Input/output error)
[05:27:36] <ChrisMorgan> Given a [u8, ..N], can I get, from it without allocation, a &[u8] of the first M bytes?
[05:28:17] <jensnockert> ChrisMorgan: Probably not.
[05:28:22] <dbaupp> ChrisMorgan: v.slice_to(M)
[05:28:22] <cmr> ChrisMorgan, not without some sort of alloc no
[05:28:28] <dbaupp> (or .slice(0, M))
[05:28:29] <cmr> (either heap or stack)
[05:28:34] <cmr> you need space for the pointer + length
[05:28:41] <ChrisMorgan> That's what I expected.
[05:28:42] <cmr> but yes
[05:28:58] <engla> maybe the compiler puts your slice into registers
[05:29:15] <engla> as in, no stack used
[05:29:21] <cmr> engla, &[T] isn't an immediate I don't think?
[05:29:21] *** Joins: ab (alex@BC9D99CC.37C1012D.FE617B51.IP)
[05:29:22] <dbaupp> ChrisMorgan: are you counting stack-allocating 2 words as an allocation?
[05:29:24] <cmr> not positive
[05:29:45] <ChrisMorgan> dbaupp: when I said "without allocation" I guess I should have said "without copy".
[05:29:57] <dbaupp> cmr: it can still be put in registers (or entirely eliminated) by LLVM.
[05:30:08] <dbaupp> ChrisMorgan: right. slices are your friends :P
[05:30:08] <engla> cmr: I'm not familiar with llvm unfortunately
[05:30:20] *** Quits: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net) (Client exited)
[05:30:55] <engla> just saying in C, even if you write   int v[16];  that might not be a stack allocation at all
[05:31:14] <engla> the compiler is always free to transform your code
[05:31:27] *** Quits: jaen (jaen@moz-CE30FE6E.play-internet.pl) (Ping timeout)
[05:31:36] <Jeaye> As long as it's contiguous, it doesn't matter much to the programmer.
[05:32:02] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[05:32:38] * cmr off to bed
[05:32:53] <dbaupp> cmr: (start the bencher please! :) )
[05:33:42] *** Quits: pcwalton (pcwalton@moz-A746ED0D.hfc.comcastbusiness.net) (Quit: pcwalton)
[05:35:37] <mark_edward> cmr: i saw looking at backlogs that some trait inheritance things had been fixed...
[05:36:16] <cmr> dbaupp: yeah just came back to do that :)
[05:36:24] <cmr> mark_edward: not for trait objects yet, unfortunately.
[05:36:38] <mark_edward> cmr:  okey-dokey
[05:36:40] <cmr> mark_edward: but regular trait inheritance works now! (except for the kinds (Send etc))
[05:36:55] <cmr> dbaupp: I'm going to force-retry the ones with the CPU usage that is really weird.
[05:37:04] <dbaupp> cmr: sounds good.
[05:37:16] <mark_edward> cmr: Cool!
[05:37:24] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[05:37:28] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[05:37:30] <dbaupp> cmr: (could you put the file with their hashes on the web too, just so I can delete those folders?)
[05:38:03] <cmr> dbaupp: ah, do you lazily fetch bench data?
[05:38:27] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzz‚Ä¶)
[05:38:28] <dbaupp> cmr: well, I essentially mirror your directory structure
[05:38:49] <dbaupp> cmr: and I only download things that aren't in the history file (and don't delete ones that are removed from it.)
[05:39:14] <cmr> dbaupp: well it's going to update the files in the folders for the given hash; will you automatically pull in the updates is what I'm asking
[05:39:22] <dbaupp> no
[05:39:30] <cmr> ok
[05:39:37] <Jeaye> Where did as_c_str go?
[05:39:51] <dbaupp> cmr: (if you just rsync the force .txt file, I'll clear out those folders, and it'll just work.)
[05:39:55] <dbaupp> Jeaye: it should be a method now
[05:39:59] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[05:40:00] <dbaupp> (maybe?)
[05:40:19] *** Joins: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net)
[05:40:39] <dbaupp> rusti: "x".as_c_str(|p| p)
[05:40:39] -rusti- 4238347
[05:41:25] <cmr> dbaupp: the history.txt has been updated
[05:41:36] <cmr> the folders still exist with the old data though though
[05:41:42] <cmr> oh you wanted the force .txt file
[05:41:47] * cmr knows how to read, he swears
[05:42:14] <cmr> dbaupp: bench-override.txt
[05:42:30] <dbaupp> cmr: thanks
[05:42:40] *** Parts: steven_is_false (user@C5B76363.1FF1EBF8.1ECA502.IP) (ERC Version 5.3 (IRC client for Emacs))
[05:42:40] * dbaupp deletes those folders
[05:43:04] <true_droid> does this have to be this fancy? https://github.com/mozilla/rust/blob/master/src/libextra/crypto/sha1.rs#L60
[05:43:11] <true_droid> why not use a single u64 variable for length?
[05:43:55] <cmr> dbaupp: maybe with some magic stats one could identify "suspicious" commits and flag them for re-benchmarking under more controlled conditions
[05:44:06] <dbaupp> cmr: yeah
[05:44:21] <cmr> true_droid: no, it doesn't, I don't think.
[05:44:24] <dbaupp> cmr: I was thinking of doing some instrumentation like that at some point
[05:44:57] <cmr> true_droid: the author of that code is sometimes in irc as DaGenix
[05:44:59] <bjz> dbaupp: https://gist.github.com/bjz/f46dbbb0397d5e443754
[05:45:11] <bjz> engla:^
[05:45:27] <dbaupp> cmr: aren't they enix on IRC?
[05:45:42] <cmr> dbaupp: maybe?
[05:45:50] <cmr> I thought it was DaGenix
[05:46:09] <cmr> guess not, grepping my logs
[05:46:14] <cmr> it is enix
[05:46:25] <cmr> dbaupp: you're always catching my mistakes, I need to get one of you to carry around in my bag
[05:46:36] <dbaupp> haha :)
[05:47:00] <dbaupp> cmr: anyway, that data's cleared out now, so it should update appropriately
[05:47:22] <ChrisMorgan> I'm implementing a trivial BufferedWriter for a Writer; clearly it needs to flush before being destroyed. Is this correct: impl<'self,T:Writer> Drop for BufferedWriter<'self,T>{fn drop(&self){self.flush();}}
[05:47:52] <cmr> ChrisMorgan: looks /write/ to me
[05:47:57] <cmr> (too bad of a pun?)
[05:48:00] <ChrisMorgan> Yes.
[05:48:10] <dbaupp> ChrisMorgan: yes, although you'll need #[unsafe_destructor] because of the generic.
[05:48:22] <ChrisMorgan> What does #[unsafe_destructor] do?
[05:48:23] <dbaupp> cmr: you spelled 'right' wrong. just fyi.
[05:48:34] <dbaupp> ChrisMorgan: stop the compiler complaining about generics in Drop impls
[05:48:36] <cmr> dbaupp: I'm going to leave my desktop mostly-idle for the next dayish, I have other duties to attend to, so the data should be noise-free
[05:48:41] <cmr> dbaupp: that's the joke!
[05:48:43] <dbaupp> cmr: coolio
[05:48:46] <cmr> good night
[05:48:51] * dbaupp got the joke
[05:48:57] <ChrisMorgan> Why would rustc complain about generics in Drop?
[05:49:11] <dbaupp> because it can do bad things
[05:49:19] * dbaupp doesn't know what
[05:49:51] <engla> self.flush() looks like an operation that requires &mut self
[05:49:52] <dbaupp> ChrisMorgan: https://github.com/mozilla/rust/issues/6971 for one
[05:50:00] <aatch> monomorphising can do strange things.
[05:50:01] <engla> but I know the traits haven't reached that far yet
[05:50:30] <mark_edward> true_droid: It's probably neccessary to the algorith maybe? I've seen a few that need things like that
[05:50:42] <mark_edward> true_droid: could also be 32 bit function
[05:50:56] *** Joins: dherman (dherman@moz-F35A8539.hsd1.or.comcast.net)
[05:50:56] *** ChanServ sets mode: +o dherman
[05:51:06] <true_droid> mark_edward: I've just found the reference implementation http://wasd.vsm.com.au/SRC/HTTPD/sha1.c. I think it uses 32-bit max for portability
[05:51:18] <true_droid> but if Rust guarantees u64 to exist, it should be used
[05:51:21] <engla> bjz: does it work?
[05:51:26] <dbaupp> true_droid: yes
[05:51:33] <bjz> engla: seems to
[05:51:48] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[05:52:20] <bjz> engla: I need to make a macro that generates tests for the algebraic properties
[05:52:24] <engla> I think you don't need .map_s, you can just use .map
[05:52:36] *** Quits: recrack (Mibbit@B4104EBB.3CC170B1.1E14B209.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[05:52:53] <bjz> oh true
[05:53:51] <bjz> duh
[05:53:55] <engla> also for Zero you can use #[deriving(Zero)]
[05:54:01] <bjz> oooh
[05:54:08] <engla> not sure what the derived version of is_zero looks like
[05:54:16] <dbaupp> engla: it calls .is_zero() on each field
[05:54:16] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[05:54:41] <engla> ok
[05:54:44] <jensnockert> bjz: It is not trivial to test for algebraic properties though ;)
[05:54:49] <engla> of course
[05:54:54] <dbaupp> (btw, you can check what #[deriving] does with `rustc --pretty expanded ...`.)
[05:55:03] <bjz> jensnockert: aye
[05:55:15] <bjz> jensnockert: I have the ones I need in the comment
[05:55:50] <bjz> engla: much better https://gist.github.com/bjz/f46dbbb0397d5e443754
[05:55:53] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[05:55:56] <mark_edward> dbaupp: does Rust guarantee u64 to exist?
[05:56:03] <dbaupp> mark_edward: I believe so
[05:56:14] <mark_edward> cool
[05:56:47] <dbaupp> mark_edward: (LLVM will automatically convert 64-bit instructions to operations the platform supports.)
[05:56:58] <mark_edward> dbaupp: ah, that's cool
[05:57:11] <mark_edward> dbaupp: can it do the same for larger SIMD type thingies?
[05:57:17] <dbaupp> I think so
[05:57:21] <true_droid> at least the manual says it does http://static.rust-lang.org/doc/rust.html#machine-types
[05:57:27] <jensnockert> bjz: Why would it be a good idea to check them btw? Except uN, which types would fulfil them? 
[05:57:29] <jensnockert> mark_edward: Yes.
[05:57:46] <kemurphy> rusti: enum Pet { Cat { meow: uint, kitty: uint }, Dog { bark: uint, puppy: uint } }; let kitty = Cat { meow: 15, kitty: 42 }; let cat = Cat { kitty: 0, ..kitty };
[05:57:48] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/KQON
[05:57:51] *** Quits: flowsnake (flowsnake@moz-1918C33E.aztw.cable.virginmedia.com) (Ping timeout)
[05:57:51] <engla> bjz: now add dot product and norm and distance and cross product :)
[05:58:12] <kemurphy> is that a known ICE?
[05:58:13] <bjz> engla: would that be an InnerProductSpace?
[05:58:22] <dbaupp> kemurphy: nice ICE
[05:58:26] <dbaupp> bjz: yes
[05:58:43] <jensnockert> dbaupp, engla: No.
[05:58:44] <mark_edward> jensnockert: cool! so if i run around using SIMD<u32, ...8>'s i don't have to worry about portability?
[05:58:51] <jensnockert> mark_edward: No.
[05:58:52] <dbaupp> bjz: (although, normed space is slightly weaker than inner product space?)
[05:58:54] <mark_edward> jensnockert: is there a performance penalty?
[05:59:02] <dbaupp> jensnockert: how so?
[05:59:09] <dbaupp> (well, except for cross-product.)
[05:59:20] <bjz> dbaupp: what properties does a NormedSpace need?
[05:59:24] <dbaupp> bjz: just norm
[05:59:34] <dbaupp> bjz: one can get a norm from an inner product
[05:59:34] <jensnockert> mark_edward: Depends on how big the vectors are, they should fit in the registers, or they get spilled to stack.
[05:59:48] <jensnockert> dbaupp: I was thinking about the cross-product.
[05:59:54] <kemurphy> dbaupp: making good progress on the tuple stuff
[06:00:01] <dbaupp> bjz: v.inner(v).sqrt() == v.norm()
[06:00:03] <mark_edward> jensnockert: ok. thanks for the explanations!
[06:00:05] <kemurphy> /home/kemurphy/rust/src/libstd/bool.rs:197:23: 197:34 error: expected function but found `option::Option<<V2>>`
[06:00:07] <kemurphy> /home/kemurphy/rust/src/libstd/bool.rs:197             "true"  => Some(true),
[06:00:08] <jensnockert> mark_edward: So if it fits in 2 registers, then it is fine, if it requires 8, probably not.
[06:00:12] <bjz> dbaupp: yup
[06:00:12] <dbaupp> bjz: (i.e. it satisfies the definition of norm.)
[06:00:27] <engla> jensnockert: what did the no mean?
[06:00:27] <dbaupp> jensnockert: oh right.
[06:00:31] <dbaupp> kemurphy: nice!
[06:00:53] <dbaupp> kemurphy: that ICE is because of enums not being real structs, I guess.
[06:01:03] <jensnockert> engla: Cross product isn't a sane trait, it is only defined for three-component vectors.
[06:01:10] <dbaupp> jensnockert: and 7
[06:01:24] <engla> still a sane trait. I'm not proposing anything for libstd here
[06:01:29] <engla> just for bjz plaything
[06:01:48] <engla> bjz's
[06:02:00] <dbaupp> jensnockert: you can have multiple representations of a 3d vector, hence a trait thing, I guess?
[06:02:05] <kemurphy> dbaupp: yeah, i figured. i mean, i wouldn't expect it to work anyway, but i'd expect an error along the lines of "you can't do that because that enum might be a different variant"
[06:02:06] <bjz> engla: by distance do you mean magnititude?
[06:02:17] <engla> distance is just the norm of x - y
[06:02:20] <dbaupp> kemurphy: yeah, I would too
[06:02:29] <jensnockert> dbaupp: Yeah, you could I guess.
[06:02:48] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[06:04:25] <dbaupp> kemurphy: there doesn't appear to be an issue about that... file it! :)
[06:04:43] * aatch is raging at C++
[06:05:07] <aatch> I have a reproducable memory corruption bug.
[06:05:10] <dbaupp> aatch: hiphop still?
[06:05:15] <aatch> dbaupp, yep
[06:05:26] <dbaupp> oh, bug in the compiler/stdlib?
[06:05:49] <aatch> dbaupp, not sure. As far as I can tell, what I'm getting is impossible.
[06:05:58] <bjz> engla: is cross only for Vec3?
[06:06:29] <engla> yes
[06:06:30] <dbaupp> aatch: you should tell the universe that it's impossible more forcefully, it seems to've forgotten. :P
[06:06:36] <dbaupp> bjz: (and Vec7)
[06:06:46] <bjz> 8[
[06:06:56] <bjz> (maths is weird)
[06:07:01] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[06:07:07] <dbaupp> bjz: http://en.wikipedia.org/wiki/Seven-dimensional_cross_product
[06:07:18] <sebcrozet> bjz: cross product can be generalized for any dimension using matrices.
[06:07:24] <dbaupp> bjz: feel free to just ignore it though.
[06:07:27] <engla> it can be useful to calculate cross of vec2 too, treating the last component as 0
[06:07:32] <bjz> holy fuck that's wierd
[06:07:52] <dbaupp> "only other non-trivial bilinear product of two vectors that is vector valued, anticommutative and orthogonal" is the key point.
[06:08:33] <engla> anyway regarding that real discussion on Num traits, I mostly agree with erickt's comment. Also no traits without usecases
[06:09:06] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[06:09:14] <engla> and, hard to motivate to use trait Vector when we have ~[] called vector
[06:09:19] <engla> not that I like the latter
[06:09:44] <sebcrozet> engla: I would really like traits without use case.
[06:09:53] <sebcrozet> engla: As long as their impl come for free.
[06:09:57] *** Quits: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP) (Quit: Lost terminal)
[06:10:12] <sebcrozet> engla: like all the group-related stuff. Some people could find a use case some day.
[06:10:24] <engla> it's very easy to write your own traits
[06:10:34] <bjz> engla: I'm not adding Vectors to std
[06:10:37] <engla> traits make Rust fantastic
[06:10:59] <bjz> engla: it is useful to have it in the standard heirachy though
[06:11:28] <engla> it's going to be more of a trait forest than a nice hierarchy
[06:11:43] <bjz> this it true
[06:11:46] <dbaupp> engla: yeah, if they're used for things later in the hierarchy then it's nice. (although Vector doesn't satisfy this.)
[06:11:47] <sebcrozet> engla: but, for example, if we add some traits like Fields without introducing Ring, anybody who want to "fill the hole" is stuck.
[06:11:49] *** Joins: flowsnake (flowsnake@moz-1918C33E.aztw.cable.virginmedia.com)
[06:12:02] *** Quits: tjc (tjc@moz-6EB4E533.dsl.tsoft.com) (Quit: Places to go, people to annoy)
[06:12:16] <dbaupp> and we should try to use the weakest bounds possibly in the standard lib, to make it as flexible as possible.
[06:12:17] <sebcrozet> engla: so at least we have to add all the math structures up to the most specific one.
[06:12:38] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[06:12:49] *** Quits: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net) (Client exited)
[06:13:13] <dbaupp> rusti: let _a = [0, .. 1 as uint];
[06:13:14] -rusti- ()
[06:13:55] <sebcrozet> bjz: Why "Identity" instead of "One" ?
[06:13:56] <engla> sebcrozet: I'm not so sure it's that way that you are stuck
[06:14:42] <bjz> sebcrozet: well, I would have AddIdent and MulIdent
[06:15:13] <sebcrozet> engla: Today, we only have a Num thait, which we might identify as the DivisionRing trait.
[06:15:32] <sebcrozet> engla: if people want to do arithmetic with vectors, they need Ring.
[06:15:38] <bjz> sebcrozet: https://github.com/mozilla/rust/pull/8049
[06:16:05] <sebcrozet> engla: If they write Ring themselves, the inheritence Num: Ring wont exist.
[06:16:15] <sebcrozet> engla: That is where they are stuck.
[06:17:11] <sebcrozet> bjz: yep. I was about to answer this. But since we are discussing it here‚Ä¶
[06:17:31] <bjz> sebcrozet: it is important to have it in writing
[06:17:41] <bjz> sebcrozet: not everybody is online
[06:17:46] <sebcrozet> bjz: ok
[06:18:09] <bjz> IRC is great, but you need things in writing so it doesn't get lost
[06:18:10] <dbaupp> sebcrozet: (just btw, mathematically, integers aren't a division ring.)
[06:18:12] <engla> why do you need that inheritance? I think I just don't get it
[06:18:16] <dbaupp> bjz: logs! :P
[06:18:30] <bjz> dbaupp: nobody reads logs :D
[06:18:34] * dbaupp reads logs
[06:18:38] <bjz> (sorry [o__o])
[06:19:00] <dbaupp> bjz: (at least, one can link to logs)
[06:21:41] <sebcrozet> engla: If you have two methods: a<T: DivisionRing> and b<T: Ring>, the inheritence is useful to pass b`s argument to `a`.
[06:22:36] <sebcrozet> engla, dbaupp: and, yes, Num is not the same as DivisionRing. The analogy was just for the explanation.
[06:23:27] <dbaupp> sebcrozet: good good, just making sure :)
[06:24:22] <dbaupp> engla: (it's partly so that functions can take the minimum-required-bounds without having to write Add<T,T> + Mul<T,T> + One + Zero + ..., instead, just Ring.)
[06:24:37] <engla> right, it's mostly an alias for a group of traits
[06:25:30] <sebcrozet> yes.
[06:25:37] <bjz> engla dbaupp: so norm != normal
[06:25:55] <engla> yeah
[06:27:32] <sebcrozet> bjz: And there can be a lot of different norms. A single Norm trait is not sufficient.
[06:28:10] <bjz> sebcrozet: heh
[06:28:12] <sebcrozet> bjz: Or having Norm<Ln, V, N> where Ln is a useless type indicating the kind of norm we want.
[06:28:28] <sebcrozet> bjz: (L1, L2, etc, L-infinite)
[06:29:03] <bjz> sebcrozet: do you use the different normals much in physics/collision stuff?
[06:29:33] <sebcrozet> bjz: only the L2 norm.
[06:30:39] <sebcrozet> bjz: L1 and L-infinite could be useful too (but I did not use them atm).
[06:31:44] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[06:32:41] <dbaupp> (there's norms other than Ln ;P )
[06:33:54] <dbaupp> bjz: your comment about Haskell numerics is that they are insufficiently flexible, right?
[06:34:09] *** Joins: Houm (Houm@moz-25669AA8.fbx.proxad.net)
[06:34:54] *** Quits: qmx (qmx@moz-D6C3C2E6.qmx.me) (Ping timeout)
[06:35:36] <bjz> dbaupp: well they have an entirely different numeric prelude
[06:35:55] <jmgrosen> bjz: how do you get OpenGL ES working with GLFW? I have it working with 3.2, but whenever I try to set it to use ES, it crashes when I try to create the window
[06:35:58] *** Joins: bnicholson (bnicholson@moz-E98974C1.hsd1.ca.comcast.net)
[06:36:29] <ChrisMorgan> Just came up with a problem with that Drop matter; self.flush() uses &mut self, but drop() uses &self. Can I do something about this?
[06:36:42] <bjz> dbaupp: http://www.haskell.org/haskellwiki/Numeric_Prelude
[06:37:00] <bjz> jmgrosen: I'm not sure tbh, I would ask Jeaye
[06:37:16] <jmgrosen> bjz: hm ok
[06:37:26] <Jeaye> jmgrosen: What OS are you running?
[06:37:28] <dbaupp> ChrisMorgan: transmute
[06:37:32] <Jeaye> Sounds like OS X. :P
[06:37:36] <bjz> jmgrosen: servo and Jeaye's q3 both use opengl es, so I think you can look at them
[06:37:39] <jmgrosen> Jeaye: ‚Ä¶yes, OS X
[06:37:54] <ChrisMorgan> Ah! I finally need to learn what transmute is for! I wondered.
[06:37:56] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[06:38:10] <Jeaye> jmgrosen: OS X is very very picky with the GL context. 
[06:38:25] <bjz> aye
[06:38:27] <Jeaye> jmgrosen: I've not been able to get it working with anything but this exact configuration: https://github.com/Jeaye/q3/blob/master/src/main.rs#L54
[06:38:42] <Jeaye> jmgrosen: Just those three lines.
[06:38:49] <Jeaye> Let me know if that does it for you.
[06:39:00] <jmgrosen> Jeaye: so does that end up being ES? those lines are what i'm currently using
[06:39:11] <bjz> jmgrosen: they put off updating GL for AGES, but when they did they didn't implement the stuff deprecated between 2.1 - 3.2 (I think)
[06:39:20] *** Joins: qmx (qmx@moz-D6C3C2E6.qmx.me)
[06:39:51] <Jeaye> jmgrosen: If you limit yourself to ES functions, yes. Right not rust-opengles supports a *bit* more than ES, but such additions are marked appropriately in the source.
[06:39:55] <dbaupp> ChrisMorgan: transmute is to allow you to be a horrible person.
[06:39:59] <Jeaye> s/not/now/
[06:40:06] <jmgrosen> Jeaye: huh, ok
[06:40:29] <jmgrosen> if you're interested in my code (although it's notoriously hard to build): https://github.com/jmgrosen/light-sculpture/tree/master/simulator
[06:40:31] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[06:40:49] <ChrisMorgan> dbaupp: I don't need transmute for _that_.
[06:40:49] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz‚Ä¶)
[06:41:18] *** Joins: bheylin (brianheyli@837B6557.E7BADBF1.B0C2132F.IP)
[06:41:23] <dbaupp> ChrisMorgan: true, but it's a very helpful tool for it.
[06:41:25] *** Quits: qmx (qmx@moz-D6C3C2E6.qmx.me) (Ping timeout)
[06:41:58] <Jeaye> jmgrosen: Nice check macro. ;)
[06:42:06] <dbaupp> ChrisMorgan: (it's actually just a -> b for any types a and b that have the same size, so you can turn a & into an &mut, for example.)
[06:42:08] <Jeaye> Looks familiar. haha
[06:42:13] <jmgrosen> Jeaye: hmm‚Ä¶ wonder where I got the inspiration/actual code...
[06:42:26] <Jeaye> ^_^
[06:42:43] <jmgrosen> Jeaye: I'll credit you in the code now :3
[06:43:51] *** Joins: qmx (qmx@moz-D6C3C2E6.qmx.me)
[06:43:53] <Jeaye> Appreciated!
[06:44:09] *** Quits: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net) (Ping timeout)
[06:44:10] <ChrisMorgan> What style should I use? `unsafe { transmute_mut(self) }.flush();`?
[06:44:14] *** Joins: sebcrozet_ (sebcrozet@moz-7FB6C00B.w193-252.abo.wanadoo.fr)
[06:44:15] *** Quits: sebcrozet (sebcrozet@moz-7FB6C00B.w193-252.abo.wanadoo.fr) (Ping timeout)
[06:44:23] <dbaupp> ChrisMorgan: that's fine.
[06:44:30] <dbaupp> "fine"
[06:45:08] <ChrisMorgan> What would you do?
[06:45:58] *** Quits: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Quit: zzzZZZzzz)
[06:46:04] <dbaupp> something like that, while crying about having to write such an abomination.
[06:47:14] <dbaupp> (the "'s where just referring to being forced to transmute some mut.)
[06:48:32] <Luqman> so i think there was talk of either changing drop to take self or &mut self
[06:48:47] <dbaupp> yeah
[06:49:31] *** sebcrozet_ is now known as sebcrozet
[06:49:43] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[06:49:43] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14f074caa to 140012b50: 02http://git.io/N3iJvQ
[06:49:43] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[06:49:44] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[06:49:44] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/3HjNkg
[06:49:44] <ghrust> 13rust/06auto 1409e49a8 15Alex Crichton: Allow linking against crates with #[no_std]...
[06:49:44] <ghrust> 13rust/06auto 145109ce6 15bors: auto merge of #7924 : alexcrichton/rust/opt-lang-xcrate2, r=thestinger...
[06:49:45] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[06:50:15] <sebcrozet> I rustpkg usable now?
[06:50:59] <sebcrozet> (or supposed to be usable)
[06:51:34] <dbaupp> sebcrozet: I think it's slightly useable for basic stuff
[06:52:03] <dbaupp> but I don't think there's much documentation about getting it set up.
[06:54:13] <sebcrozet> dbaupp: mmh, looks like the dependencies resolution does not work yet :(
[06:54:18] <dbaupp> :(
[06:54:20] * ChrisMorgan heard that one should never use "I" in a /me statement... then the I key cap fell off his keyboard
[06:57:20] *** Quits: bheylin (brianheyli@837B6557.E7BADBF1.B0C2132F.IP) (Quit: bheylin)
[07:00:10] *** Joins: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net)
[07:02:11] *** Quits: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net) (Quit: Leaving)
[07:03:39] *** Joins: jaen (jaen@moz-2F83E2BC.play-internet.pl)
[07:04:26] *** Joins: geomyidae (cole@DD6F7E3A.21468E9A.30200F38.IP)
[07:04:27] *** Quits: aatch (aatch@moz-B437F499.pocketrent.com) (Connection reset by peer)
[07:05:24] *** Joins: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net)
[07:06:31] <mihneadb> hi - is this a known issue ? http://pastebin.mozilla.org/2713681
[07:06:35] <mihneadb> on mac 
[07:06:41] <mihneadb> installed with brew
[07:07:11] <klutzy> i think i've seen rust segfaulting here
[07:07:31] <dbaupp> mihneadb: yes
[07:07:52] <dbaupp> mihneadb: https://github.com/mozilla/rust/issues/7617
[07:08:19] <mihneadb> dbaupp: ty
[07:10:28] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[07:13:22] *** Quits: jaen (jaen@moz-2F83E2BC.play-internet.pl) (Ping timeout)
[07:13:25] *** Joins: victorporof (victorporo@AF497F7E.60E0D239.9B1E38F4.IP)
[07:13:29] *** Joins: igl1 (igl@moz-31E38142.adsl.alicedsl.de)
[07:13:30] <ChrisMorgan> What, if any, is the difference between these two?
[07:13:30] <ChrisMorgan> impl<'self> X<'self> { pub fn new(y: &'self Y) -> X<'self> { ... } }
[07:13:30] <ChrisMorgan> impl<'self> X<'self> { pub fn new<'a>(y: &'a Y) -> X<'a> { ... } }
[07:13:32] *** Quits: igl (igl@moz-7CEFF82C.adsl.alicedsl.de) (Ping timeout)
[07:13:48] <dbaupp> ChrisMorgan: something, because the compiler doesn't like the first one (right?)
[07:13:55] <dbaupp> at least, it seems to cause problems
[07:16:27] *** Quits: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net) (Quit: Leaving)
[07:18:20] <ChrisMorgan> dbaupp: the compiler is quite content with the first one. What problems do you refer to?
[07:18:51] <dbaupp> ChrisMorgan: I think, in some situations, when you use it, it makes it explode with lifetime errors.
[07:18:54] * dbaupp might be wrong
[07:19:04] <ChrisMorgan> rusti: struct Y; struct X<'self> { y: &'self Y } impl<'self> X<'self> { pub fn new(y: &'self Y) -> X<'self> { X { y: y } } }X::new(&Y)
[07:19:04] -rusti- {y: &{}}
[07:19:09] <dbaupp> (incorrect lifetime errors.)
[07:19:16] <dbaupp> yeah... in some situations :P
[07:19:24] <ChrisMorgan> rusti: struct Y; struct X<'self> { y: &'self Y } impl<'self> X<'self> { pub fn new<'a>(y: &'a Y) -> X<'a> { X { y: y } } }X::new(&Y)
[07:19:25] -rusti- {y: &{}}
[07:19:38] <ChrisMorgan> Same result from both there at least.
[07:19:42] <dbaupp> yeah
[07:19:50] <dbaupp> maybe there is no difference.
[07:20:11] <Luqman> i don't those 2 should be any different
[07:20:43] <dbaupp> (I'm pretty sure if there are any differences, they are bugs)
[07:20:58] *** Joins: xraycat (Adium@moz-97690522.pool.mediaways.net)
[07:21:27] *** Quits: robn (robn@moz-76B0302C.static.internode.on.net) (Ping timeout)
[07:23:12] *** Joins: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net)
[07:27:25] *** Quits: tcr (tcr@moz-EE576D3C.hsd1.ma.comcast.net) (Ping timeout)
[07:27:51] *** Joins: robn (robn@moz-76B0302C.static.internode.on.net)
[07:29:59] *** Quits: KindOne (KindOne@moz-112B4553.dynamic.ip.windstream.net) (Ping timeout)
[07:30:09] * ChrisMorgan just got an ICE: "vtables missing where they are needed"
[07:31:17] <ChrisMorgan> Problem is, my Rust build is probably unsupported as it had -Z debug-info.
[07:32:00] <dbaupp> ChrisMorgan: code?
[07:32:38] <ChrisMorgan> dbaupp: tip of rusthttpserver
[07:33:11] <dbaupp> it's up-to-date on your website?
[07:33:17] <ChrisMorgan> Yep.
[07:33:29] <dbaupp> haha, 79 seconds from now 	Chris Morgan 	Use a BufferedWriter. Currently ICEs
[07:34:01] <dbaupp> now... how do I clone a hg repo?
[07:34:08] *** Joins: KindOne (KindOne@moz-ADD405A9.dynamic.ip.windstream.net)
[07:36:10] <dbaupp> ChrisMorgan: I get the same error and I don't have -Z debug-info
[07:36:23] *** Quits: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net) (Quit: gavinb)
[07:36:25] <Luqman> dbaupp: hg clone :P
[07:36:27] <dbaupp> (and, fwiw, my rust does include sully's changes, so that didn't fixe them)
[07:36:58] <dbaupp> Luqman: yeah, I mean the url... but it seems that just pasting the normal http:// one works
[07:36:58] *** Quits: victorporof (victorporo@AF497F7E.60E0D239.9B1E38F4.IP) (Quit: victorporof)
[07:38:07] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Client exited)
[07:38:11] *** Joins: victorporof (victorporo@AF497F7E.60E0D239.9B1E38F4.IP)
[07:38:28] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[07:38:28] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[07:40:09] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Ping timeout)
[07:40:16] *** Quits: KindOne (KindOne@moz-ADD405A9.dynamic.ip.windstream.net) (Ping timeout)
[07:40:58] *** Quits: Jesin (Jessin_@moz-1B1307FF.eecs.lehigh.edu) (Ping timeout)
[07:41:08] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[07:43:01] *** Joins: jaen (jaen@moz-8D59F623.neoplus.adsl.tpnet.pl)
[07:43:01] *** Quits: jaen (jaen@moz-8D59F623.neoplus.adsl.tpnet.pl) (Quit: jaen)
[07:43:02] *** Joins: jaen (jaen@moz-8D59F623.neoplus.adsl.tpnet.pl)
[07:44:10] <ChrisMorgan> My Rust build was made last night. But then too today I upgraded from Ubuntu 13.04 to 13.10.
[07:45:16] *** Joins: thpickert (thpickert@moz-24816453.tng.de)
[07:45:30] * ChrisMorgan remembers waiting a few weeks after the release of 10.04 before updating with unnecessary trepidation for the first time... now he upgrades a month or three before the release
[07:45:50] * dbaupp just uses a roll-release distro and gets upgrades all the time
[07:46:07] <dbaupp> *rolling
[07:46:32] *** Joins: doomrobo (doomrobo@EC9C662A.161AAEB2.58B1C2DD.IP)
[07:46:42] *** Quits: doomrobo (doomrobo@EC9C662A.161AAEB2.58B1C2DD.IP) (Quit: Leaving)
[07:47:18] *** Joins: doener (bs@moz-AA189A5A.unitymedia.biz)
[07:53:21] <ChrisMorgan> dbaupp: it's the latest changeset which has introduced the ICE, that BufferedWriter stuff
[07:53:43] <dbaupp> ChrisMorgan: how do I look at a hg diff?
[07:53:52] <dbaupp> hg diff HEAD^!?
[07:53:59] <ChrisMorgan> hg tip -p
[07:54:11] <ChrisMorgan> That's the easiest way for the last changeset
[07:56:05] <dbaupp> ChrisMorgan: commenting out the Drop makes it work
[07:56:07] *** Joins: doomrobo (doomrobo@EC9C662A.161AAEB2.58B1C2DD.IP)
[07:56:17] <ChrisMorgan> Or `hg log -pr tip`, or `hg diff -r -2:-1` (-p being "show patch", -1 being HEAD and -2 being HEAD^).
[07:56:59] <dbaupp> thanks :)
[07:57:27] <dbaupp> (how come there's no colour? :( )
[07:59:03] <ChrisMorgan> Add to ~/.hgrc: [extensions]\ncolor =
[07:59:17] <ChrisMorgan> (c.f. `hg help color`)
[08:01:04] <dbaupp> awesome
[08:01:26] *** Quits: bnicholson (bnicholson@moz-E98974C1.hsd1.ca.comcast.net) (Ping timeout)
[08:03:33] <doomrobo> why does iterator::advance need a boolean function?
[08:03:36] <true_droid> shouldn't this be a warning? https://github.com/mozilla/rust/blob/master/src/libextra/crypto/sha1.rs#L237
[08:03:36] *** Quits: geomyidae (cole@DD6F7E3A.21468E9A.30200F38.IP) (Quit: Konversation terminated!)
[08:03:41] <true_droid> or does it return a unit?
[08:03:54] <doomrobo> I just wanna iterate over every character in a string and perform a stateful operation
[08:03:58] <dbaupp> doomrobo: because that's how the `for` sugar works
[08:04:32] <dbaupp> rusti: let s = "Abcd"; let mut i = 0; for s.iter().advance |c| { if c != "b" { i += 1 } } i
[08:04:32] -rusti- <anon>:7:75: 7:78 error: mismatched types: expected `char` but found `&'static str` (expected char but found &'static str)
[08:04:32] -rusti- <anon>:7          let s = "Abcd"; let mut i = 0; for s.iter().advance |c| { if c != "b" { i += 1 } } i
[08:04:32] -rusti-                                                                                     ^~~
[08:04:33] -rusti- error: aborting due to previous error
[08:04:34] -rusti- application terminated with error code 101
[08:04:50] <dbaupp> rusti: let s = "Abcd"; let mut i = 0; for s.iter().advance |c| { if c != 'b' { i += 1 } } i
[08:04:50] -rusti- 3
[08:05:09] <dbaupp> rusti: let s = "Abcd"; let mut i = 0; s.iter().advance(|c| { if c != 'b' { i += 1 }; true}) i
[08:05:09] -rusti- <anon>:7:94: 7:95 error: expected `;` or `}` after expression but found `i`
[08:05:09] -rusti- <anon>:7          let s = "Abcd"; let mut i = 0; s.iter().advance(|c| { if c != 'b' { i += 1 }; true}) i
[08:05:09] -rusti-                                                                                                        ^
[08:05:09] -rusti- application terminated with error code 101
[08:05:15] <dbaupp> rusti: let s = "Abcd"; let mut i = 0; s.iter().advance(|c| { if c != 'b' { i += 1 }; true}); i
[08:05:15] -rusti- 3
[08:05:32] <dbaupp> true_droid: that is strange
[08:06:00] <dbaupp> true_droid: but, yes, `mk_result` and `result` both return ()
[08:06:25] <true_droid> dbaupp: good to know, thanks
[08:07:09] <dbaupp> true_droid: it's something you could file a bug about; a new lint: "unnecessary `return foo()` because foo returns ()".
[08:07:40] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[08:08:05] <true_droid> dbaupp: ok, I will
[08:08:37] <doomrobo> dbaupp why doesn't this work?      string.iter().advance( |c| {if (c == '.') {num_points += 1;};true;});
[08:08:54] <dbaupp> doomrobo: extra `;`
[08:09:03] <dbaupp> doomrobo: you should just use `for`
[08:09:24] <dbaupp> these functions are exactly just what it is designed for
[08:09:31] <dbaupp> (it = for)
[08:09:36] <doomrobo> I've seen no docs on how to use "for"
[08:09:42] <doomrobo> huh?
[08:10:10] <dbaupp> yeah, it's just `for some_iter.advance |x| { do something }`
[08:10:28] <dbaupp> it's changing soon, so that's why the docs have been removed
[08:10:43] *** Quits: dherman (dherman@moz-F35A8539.hsd1.or.comcast.net) (Quit: dherman)
[08:10:59] <dbaupp> doomrobo: wait, there's some here: http://static.rust-lang.org/doc/tutorial-container.html#for-loops
[08:11:15] <ChrisMorgan> Good, I've finally constructed a icy example that's not ridiculously long.
[08:11:33] <dbaupp> ChrisMorgan: oh? i couldn't get one to work :(
[08:12:31] <dbaupp> doomrobo: that said, many stateful iterator things can be done with `.fold` or some of the other higher order functions on iterators, what are you trying to do?
[08:12:40] <ChrisMorgan> dbaupp: my first attempt didn't work, but then I tried actually having an instance of the ResponseWriter (dummy fn that takes a &mut TcpStream and contains `~RequestWriter(...)`) and it ICEd up.
[08:13:09] <dbaupp> ChrisMorgan: aha, so it actually have to be used in the code somewhere?
[08:13:13] <ChrisMorgan> Yep
[08:14:42] <dbaupp> cool, mine's icy too now
[08:14:59] <dbaupp> you should file a bug, if you haven't done it already :)
[08:15:46] *** Joins: eatkinson (eatkinson@moz-AD233F1B.dia.static.qwest.net)
[08:17:56] <ChrisMorgan> Just whittling it down as far as I can before filing it.
[08:19:12] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[08:24:10] <dbaupp> rusti: struct Foo<T>(T);trait Bar{fn x(&self){}}impl Bar for uint;#[unsafe_destructor]impl<T:Bar>Drop for Foo<T>{fn drop(&self){(**self).x()}}let _ = Foo(1u);
[08:24:11] -rusti- error: internal compiler error: unexpected failure
[08:24:11] -rusti- note: the compiler hit an unexpected failure path. this is a bug
[08:24:11] -rusti- note: try running with RUST_LOG=rustc=1,::rt::backtrace to get further details and report the results to github.com/mozilla/rust/issues
[08:24:11] -rusti- application terminated with error code 101
[08:24:22] <dbaupp> ChrisMorgan: I believe that's the ice
[08:25:20] <kemurphy> ok, i need help with something
[08:25:26] <kemurphy> surely there's a better way to do https://gist.github.com/kemurphy/6087201
[08:25:45] <dbaupp> kemurphy: ahahahaha
[08:25:54] * dbaupp loves Rust pyramids
[08:26:00] <ChrisMorgan> dbaupp: yep, you just beat me to it; thanks.
[08:26:05] <kemurphy> that's one of the worst i've seen
[08:26:11] <ChrisMorgan> Except I was calling the Foo "EyeDropper" ;-)
[08:26:14] <dbaupp> ChrisMorgan: you can still file it ;P
[08:26:36] <dbaupp> kemurphy: I have a feeling an early return thing would help
[08:26:44] <dbaupp> maybe
[08:27:55] <ChrisMorgan> dbaupp: concerning the (**self), it's also icy with (*self) and self
[08:27:59] <xraycat> or a monad :-)
[08:28:27] <dbaupp> ChrisMorgan: oh
[08:28:37] <ChrisMorgan> self would be &Foo, *self would be Foo and **self would be T, right?
[08:28:41] *** Joins: vk (chatzilla@moz-389FEE13.hsd1.ca.comcast.net)
[08:28:44] <dbaupp> ChrisMorgan: yup
[08:28:57] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[08:30:27] <dbaupp> kemurphy: you could save some indentation by using `=> match f.node { ... },` and `=> match dm.find(&f.id) { ... },`
[08:30:48] <dbaupp> (that doesn't solve the fundamental problem though.)
[08:31:43] <kemurphy> https://gist.github.com/kemurphy/6087201 takes up less space
[08:31:46] <kemurphy> still yuck
[08:31:51] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[08:31:51] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/3HjNkg
[08:31:51] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[08:32:25] <kemurphy> and, i even screwed it up
[08:32:41] <dbaupp> kemurphy: you could use `let mut f = None; f = Some(expr_struct( ... ))` and the => None arms would be => {}
[08:33:01] <dbaupp> (also, that compact one is argueably worse.)
[08:33:41] <dbaupp> I guess you could do something similar using xraycat's monad suggestion, but without the nice sugar
[08:33:46] <kemurphy> dbaupp: right, i'm not a fan of get_or_default
[08:34:10] <dbaupp> hmm, actually, the `args` would make it hard to thread through
[08:34:11] <dbaupp> :(
[08:34:49] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[08:34:49] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/RBPxqA
[08:34:49] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[08:34:50] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[08:34:50] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/Gqf2FA
[08:34:50] <ghrust> 13rust/06auto 147fd23e4 15Alex Crichton: Convert uses of transmute which don't need it
[08:34:50] <ghrust> 13rust/06auto 14319e7e3 15Alex Crichton: Consolidate raw representations of rust values...
[08:34:50] <ghrust> 13rust/06auto 147dc5c7b 15bors: auto merge of #7986 : alexcrichton/rust/raw-repr, r=brson...
[08:34:52] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[08:35:33] <doomrobo> was int::from_str deprecated?
[08:36:20] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[08:37:50] <Luqman> rusti: let x: int = FromStr::from_str("21").unwrap(); x
[08:37:51] -rusti- 21
[08:37:55] <Luqman> doomrobo: ^
[08:37:55] <dbaupp> kemurphy: https://gist.github.com/huonw/6087269 but that's not much better
[08:38:40] <doomrobo> What happens when you try to unwrap a None?
[08:38:58] <dbaupp> rusti: None::<int>.unwrap()
[08:38:59] -rusti- rust: task failed at 'option::unwrap none', /build/rust-git/src/rust/src/libstd/option.rs:310
[08:38:59] -rusti- rust: domain main @0x20bd110 root task failed
[08:39:00] -rusti- application terminated with error code 101
[08:39:04] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[08:39:25] <doomrobo> rusti: let x : int = FromStr::from_str("Not an int").unwrap(); x
[08:39:26] -rusti- rust: task failed at 'option::unwrap none', /build/rust-git/src/rust/src/libstd/option.rs:310
[08:39:26] -rusti- rust: domain main @0x1673110 root task failed
[08:39:26] -rusti- application terminated with error code 101
[08:39:33] <doomrobo> yeah
[08:39:53] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[08:41:00] *** Quits: vk (chatzilla@moz-389FEE13.hsd1.ca.comcast.net) (Quit: ChatZilla 0.9.90.1 [Firefox 23.0/20130722172257])
[08:41:42] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[08:42:45] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[08:43:00] <thpickert> rusti: let x: int = match FromStr::from_str("21") { Some(i) => i, None => fail!("controlled failure") }; println(fmt!("%?", x); let y: int = match FromStr::from_str("not an int") { Some(i) => i, None => fail!("controlled failure") }; println(fmt!("%?", y); 
[08:43:00] -rusti- <anon>:8:4: 8:5 error: incorrect close delimiter: `}`
[08:43:00] -rusti- <anon>:8     };
[08:43:00] -rusti-              ^
[08:43:00] -rusti- application terminated with error code 101
[08:44:50] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[08:45:36] <dbaupp> rusti: let x: int = match FromStr::from_str("21") { Some(i) => i, None => fail!("controlled failure") }; println(fmt!("%?", x)); let y: int = match FromStr::from_str("not an int") { Some(i) => i, None => fail!("controlled failure") }; println(fmt!("%?", y));
[08:45:37] -rusti- 21
[08:45:38] -rusti- rust: task failed at 'controlled failure', <anon>:7
[08:45:38] -rusti- rust: domain main @0x11ad110 root task failed
[08:45:38] -rusti- application terminated with error code 101
[08:46:17] <dbaupp> rusti: let x: int = FromStr::from_str("21").expect("controlled failure"); println(fmt!("%?", x)); let y: int = match FromStr::from_str("not an int").expect("controlled failure"); println(fmt!("%?", y));
[08:46:18] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/LFBe
[08:46:18] <thpickert> dbaupp: Thanks, just found the missing parens. :)
[08:46:46] <dbaupp> rusti: let x: int = FromStr::from_str("21").expect("controlled failure"); println(fmt!("%?", x)); let y: int = FromStr::from_str("not an int").expect("controlled failure"); println(fmt!("%?", y));
[08:46:46] -rusti- 21
[08:46:47] -rusti- rust: task failed at 'controlled failure', /build/rust-git/src/rust/src/libstd/option.rs:340
[08:46:47] -rusti- rust: domain main @0x1b04110 root task failed
[08:46:47] -rusti- application terminated with error code 101
[08:47:32] <thpickert> rusti: let x: int = FromStr::from_str("21").expect(21); println(fmt!("%?", x)); let y: int = FromStr::from_str("not an int").expect("controlled failure"); println(fmt!("%?", y));
[08:47:33] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/NKJS
[08:48:05] <thpickert> Oh, weird.
[08:48:21] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[08:48:39] <thpickert> dbaupp: Where does expect() come from? It's probably a trait, but from where?
[08:48:48] *** Quits: eatkinson (eatkinson@moz-AD233F1B.dia.static.qwest.net) (Quit: eatkinson)
[08:48:49] <dbaupp> thpickert: it's just a method on Option
[08:49:01] <dbaupp> thpickert: http://static.rust-lang.org/doc/std/option.html#method-expect
[08:49:02] <thpickert> Oh, Option. Did not expect that. :D
[08:50:17] <dbaupp> yeah, there could be an `Unwrap` trait, that provides unwrap/expect on Result & Option etc. but there isn't (yet)
[08:50:28] *** Joins: eatkinson (eatkinson@moz-AD233F1B.dia.static.qwest.net)
[08:50:35] <thpickert> Ah, ok, I see. expect() prints a message when a None is encountered.
[08:51:07] <thpickert> So it's like a shortcut for the match expression.
[08:51:11] <dbaupp> yup
[08:51:27] <thpickert> (if all you do in the None-branch is to print a message)
[08:52:21] <engla> it's like unwrap() with a message
[08:52:50] <thpickert> That's probably most accurate. :D
[08:53:18] <thpickert> The implementation is probably exactly the earlier match construct.
[08:53:20] <xraycat> kemurphy: just spitballing, I have no experience with rust: would a macro maybe help? http://static.rust-lang.org/doc/tutorial-macros.html the first example doesn't seem to be too far off.
[08:55:08] <dbaupp> thpickert: yep https://github.com/mozilla/rust/blob/master/src/libstd/option.rs#L338-L352
[08:56:02] *** Quits: anri (solancile@moz-E49E7C4B.hsd1.wa.comcast.net) (Quit: anri)
[08:56:17] <thpickert> dbaupp: \o/ Feels really good when actual library code looks similar to what I was trying in my stumbling attempts. :D
[08:56:29] <dbaupp> :D
[08:56:53] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[08:57:03] *** Joins: anri (solancile@moz-E49E7C4B.hsd1.wa.comcast.net)
[08:57:31] *** Quits: qmx (qmx@moz-D6C3C2E6.qmx.me) (Ping timeout)
[08:58:22] <kemurphy> i feel so dirty
[08:58:24] <kemurphy> https://gist.github.com/kemurphy/6087201
[08:59:41] <kemurphy> dbaupp: ^
[09:01:07] <dbaupp> kemurphy: that's not... too bad
[09:01:31] <dbaupp> kemurphy: (although, if you returned Option<ast::expr_>, then you wouldn't need the loop.
[09:01:32] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[09:01:32] <dbaupp> )
[09:04:29] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[09:04:52] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[09:04:52] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 147dc5c7b to 145109ce6: 02http://git.io/N3iJvQ
[09:04:52] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[09:04:52] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[09:04:52] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/DaWWiQ
[09:04:52] <ghrust> 13rust/06auto 14581b3db 15Graydon Hoare: rewrite rust-mode to use font-lock-mode and emacs builtin syntax analysis
[09:04:52] <ghrust> 13rust/06auto 144c4cf00 15bors: auto merge of #8031 : graydon/rust/emacs-mode-rewrite, r=catamorphism...
[09:04:53] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[09:05:37] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[09:05:43] *** Joins: qmx (qmx@moz-D6C3C2E6.qmx.me)
[09:10:01] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[09:10:26] *** Joins: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[09:10:26] *** Quits: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP) (Input/output error)
[09:10:28] *** Joins: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[09:11:15] <kemurphy> dbaupp: https://gist.github.com/kemurphy/6087201
[09:13:11] <dbaupp> kemurphy: that appears to have different behaviour... maybe it should be `(match f { None => noop_fold(s, fld), Some(f) => f }, s)`?
[09:13:27] <dbaupp> (but that looks nicer than any of the other solutions :) )
[09:13:50] <dbaupp> *noop_fold(e, fld)
[09:13:58] <kemurphy> oh, yeah you're totally right
[09:14:07] <kemurphy> cool, thanks!
[09:19:45] *** Quits: qmx (qmx@moz-D6C3C2E6.qmx.me) (Ping timeout)
[09:21:15] *** Quits: doomrobo (doomrobo@EC9C662A.161AAEB2.58B1C2DD.IP) (Quit: This computer has gone to sleep)
[09:21:58] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Quit: Leaving.)
[09:23:39] *** Joins: qmx (qmx@moz-D6C3C2E6.qmx.me)
[09:30:00] *** Quits: eatkinson (eatkinson@moz-AD233F1B.dia.static.qwest.net) (Quit: eatkinson)
[09:30:11] <sebcrozet> How does the #[bench] pragma work?
[09:30:48] <nmatsakis> sebcrozet: label the test with #[bench], write it, compile with --test, then run the resulting executable with --bench, I think
[09:31:02] <nmatsakis> sebcrozet: grep around for an example to see how to write it
[09:31:56] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[09:32:52] <sebcrozet> nmatsakis: --bench does not seem to do anything.
[09:33:31] <kemurphy> ah, that's better
[09:33:32] <sebcrozet> nmatsakis: (it just runs #[test]s)
[09:33:33] <kemurphy> /home/kemurphy/rust/src/libstd/num/float.rs:164:42: 164:59 error: internal compiler error: structure constructor does not name a structure type
[09:33:35] <kemurphy> /home/kemurphy/rust/src/libstd/num/float.rs:164         num, 10u, true, strconv::SignNeg, strconv::DigExact(digits));
[09:35:35] <nmatsakis> sebcrozet: uh...works for me
[09:36:28] <nmatsakis> sebcrozet: maybe use "script foo" to capture exactly what steps you are taking and gist/pastebin it?
[09:39:01] <nmatsakis> sebcrozet: http://www.pastebin.mozilla.org/2714354
[09:39:20] *** Quits: henrikhodne (henrikhodn@moz-F3A92B1C.hsd1.ca.comcast.net) (Ping timeout)
[09:39:26] <nmatsakis> if you can look past the ANSI codes
[09:39:35] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[09:40:05] *** Quits: qmx (qmx@moz-D6C3C2E6.qmx.me) (Ping timeout)
[09:40:36] *** Joins: qmx (qmx@moz-D6C3C2E6.qmx.me)
[09:41:22] <nmatsakis> (updated to remove them)
[09:41:42] *** Quits: jaen (jaen@moz-8D59F623.neoplus.adsl.tpnet.pl) (Ping timeout)
[09:42:07] <sebcrozet> nmatsakis: mmmh, I‚Äôm doing this: https://gist.github.com/sebcrozet/6087620
[09:42:11] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[09:42:32] <sebcrozet> nmatsakis: and ./test --bench
[09:43:22] <nmatsakis> sebcrozet: your bench function is not right. as I said, look at an example (you can look at the psatebin I just sent for such an example)
[09:43:35] <sebcrozet> nmatsakis: The '&mut BenchHarness' is mandatory?
[09:43:40] <nmatsakis> or wait, one sec
[09:43:42] <nmatsakis> yes
[09:43:52] *** Joins: jaen (jaen@moz-8D59F623.neoplus.adsl.tpnet.pl)
[09:44:04] <nmatsakis> sebcrozet: http://www.pastebin.mozilla.org/2714365
[09:44:05] <nmatsakis> more readable
[09:44:21] <nmatsakis> I think there is an open issue on the fact that you get no warning if you do it wrong
[09:44:49] <nmatsakis> sebcrozet: you must also call bh.iter
[09:45:20] <sebcrozet> nmatsakis: ok, it works.
[09:45:31] <sebcrozet> nmatsakis: thx
[09:45:39] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[09:45:45] <sebcrozet> nmatsakis: It‚Äôs weird that the `test` module is not documented.
[09:46:10] <nmatsakis> suboptimal, clearly.
[09:47:10] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[09:47:38] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[09:49:39] *** Joins: BitPuffin (quassel@moz-4DE4682C.mobile.tre.se)
[09:50:27] *** Quits: qmx (qmx@moz-D6C3C2E6.qmx.me) (Ping timeout)
[09:52:45] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Client exited)
[09:54:07] *** Joins: qmx (qmx@moz-D6C3C2E6.qmx.me)
[10:00:51] *** Joins: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com)
[10:01:03] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[10:03:23] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[10:08:37] <kemurphy> is there any way that i can check that a value is a certain discriminant without destructuring it?
[10:08:52] <kemurphy> like, if (e == expr_call)
[10:09:34] *** Joins: doomrobo (doomrobo@EC9C662A.161AAEB2.58B1C2DD.IP)
[10:10:03] <doomrobo> how do I instantiate a hashmap? Do I import std::map or std::hashmap and where is the `new` function in hashmap?
[10:13:02] *** Joins: mvalzelli (mvalzelli@moz-9E064543.ip2.fastwebnet.it)
[10:13:14] *** Quits: qmx (qmx@moz-D6C3C2E6.qmx.me) (Ping timeout)
[10:14:38] *** Joins: qmx (qmx@moz-D6C3C2E6.qmx.me)
[10:14:45] <sebcrozet> doomrobo: use std::hashmap::HashMap; HashMap::new() ?
[10:15:36] <doomrobo> there is no function `new` here http://static.rust-lang.org/doc/std/hashmap.html
[10:16:34] <xraycat> fn new() -> HashMap<K, V>
[10:16:57] <doomrobo> my god I have to get my eyes checked
[10:17:12] <xraycat> or use strg + f? :-)
[10:17:24] *** Joins: vosen (vosen@moz-266BA656.icpnet.pl)
[10:17:26] <xraycat> ctrl...
[10:17:27] <doomrobo> I was searching for " new "
[10:17:33] <doomrobo> note the spaces
[10:17:36] <xraycat> :-)
[10:18:10] <doomrobo> also, what does it mean when something "fails"? Can I catch it?
[10:18:34] <doomrobo> Like this says it fails: http://static.rust-lang.org/doc/std/hashmap.html#method-get
[10:19:19] <xraycat> why is that function partial anyway?
[10:20:08] <doomrobo> ?
[10:20:42] <xraycat> would have expected Option<V>
[10:20:51] <doomrobo> as would I
[10:21:03] <doomrobo> so if it fails is there anything I can do about that?
[10:23:39] <doomrobo> xraycat apparently the `find` method does that
[10:24:13] <ChrisMorgan> dbaupp: filed that generic destructor method invocation ICE, https://github.com/mozilla/rust/issues/8059
[10:25:01] <xraycat> doomrobo: I don't know how fail works, just found: fail_: Abort the program with an error. 
[10:26:49] <rntz> failure can't be caught AFAIK in rust, except at task boundaries
[10:27:16] *** Parts: mvalzelli (mvalzelli@moz-9E064543.ip2.fastwebnet.it) (Quitting)
[10:27:21] <rntz> that is, as I understand it, failure always ends the current task, and may or may not propagate to the parent task depending on how the current task was spawned
[10:27:59] <rntz> suggest not using get unless you know the key is present
[10:28:36] <ChrisMorgan> I just had an interesting idea for advanced checking: annotate items with things like #[issue(open="https://github.com/mozilla/rust/issues/8059")] and warn if the issue is closed (i.e. an active TODO). Naturally not enabled by default as it'll be slow to check. Good for when something is blocked on something else or when something depends on some other temporary behaviour.
[10:30:56] <doomrobo> I'm trying to create a constructor (a `new` method) and I want to take a parent object as an optional parameter, so it looks like: fn new(parent: Option<@My_Struct>) {?} but the compiler complains
[10:31:43] <doomrobo> it's saying "this type cannot be instantiated without an instance of iteself"
[10:31:49] <doomrobo> *itself
[10:31:58] <ChrisMorgan> More complete code?
[10:32:11] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[10:32:32] <doomrobo> sure
[10:33:40] <doomrobo> is there a decent paste bin with syntax highlighting for Rust?
[10:34:04] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[10:34:16] <kimundi> doomrobo: github gist kind has that
[10:34:17] <xraycat> would be great to have links to the actual implementation in the docs (similar to hackage)
[10:35:08] <ChrisMorgan> xraycat: rustdoc_ng (in progress) provides that and the frontend that's being worked on is doing that, I believe
[10:35:29] <xraycat> ChrisMorgan: ah, great, I'll take a look
[10:36:18] <doomrobo> https://gist.github.com/doomrobo/952222c47d207030931c
[10:36:50] <ChrisMorgan> doomrobo: "parent: ~Context" doesn't make sense
[10:37:02] <ChrisMorgan> An X can't own a pointer to an X.
[10:37:07] <doomrobo> good point. I was thinking in C
[10:37:17] <doomrobo> parent: Option<~Context>?
[10:37:27] <ChrisMorgan> Not sure. Try it and see if it works.
[10:37:51] <doomrobo> rather, Option<@Context>
[10:38:03] <doomrobo> yeah, error gone
[10:38:22] <ChrisMorgan> Option<~Context> works.
[10:38:36] <ChrisMorgan> But given the name parent, I presume you wouldn't be wanting it to be owned.
[10:39:11] <kimundi> doomrobo: (btw, to actually enable the syntax higlining on gist, you have to either select Rust in the dropdown menu or, much easier: give your gist a .rs ending in the name)
[10:39:34] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[10:39:47] <doomrobo> I did select Rust
[10:39:59] <kimundi> hu...
[10:40:08] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[10:40:47] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[10:42:45] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[10:42:45] <kimundi> (It's not the sligtest bit important, but that gist is definitly just text ;) It would show 'Rust' on the top right side of the bar of the textbox otherwise.)
[10:46:01] <doomrobo> It's weird. I specifically selected "Rust" in the dropdown menu and then it just made it plaintext
[10:47:30] <mark_edward> does Rust have bit rotation stuff?
[10:47:44] <mark_edward> some sort of intrinsics module?
[10:49:33] <mark_edward> i feel like <<< and >>> should mean rotation...
[10:49:41] <kimundi> doomrobo: strange.... but I also remember struggling with it. I just allways give my rust gists a .rs file ending now to force the language.
[10:49:57] <mark_edward> doomrobo: are you related to doomlord?
[10:50:12] <doomrobo> mark_edward we fight about our nicks. No I am not
[10:50:13] <doomlord> no
[10:50:30] <doomrobo> kimundi could you help with this? https://gist.github.com/doomrobo/83b5704fa6563b834cc8
[10:50:31] <doomlord> :) tab complete is an endless source of conflict
[10:50:53] <mark_edward> doomlord: I know right!!! do you guys know if Rust has any bit rotation intrinsics?
[10:51:54] <doomrobo> mark_edward I'd venture to say that it does not
[10:51:57] <doomlord> i dont know myself, would be nice,
[10:52:22] <doomrobo> it has bit shifting so with a bit of hackery you can make your own rotation
[10:52:32] <mark_edward> doomlord: what you you think about my <<< and >>> proposal? It wouldn't intefere with anything right?
[10:52:35] <doomlord> i'd guess llvm might be able to optimize shifts-masks to do rotation
[10:53:04] <kimundi> doomrobo: Wrote a comment under the gist
[10:53:07] <doomrobo> mark_edward you're right but it's more of a question of cleanness and necessity
[10:53:41] <mark_edward> can you use inline LLVM IR in rust? it'd be a could use for making standard ror and rol functions
[10:53:47] <doomrobo> kimundi why does self have to have that lifetime?
[10:54:13] <kimundi> doomrobo: the reference to self is like any other reference
[10:54:14] <doomlord> its possible they'd say bit rotation is rare ebough not to need a symbol - i'd be happy  to write  value.rol(2)   value.ror(3) personally .. bit manipulation trait
[10:54:52] <kimundi> doomlord: You can see '&self' as sugar for 'self: &Self'
[10:55:00] <kimundi> doomrobo, even
[10:55:10] <doomrobo> kimundi I mean why do I have to annotate self with a lifetime if it's only a reference that I want to return?
[10:55:27] <doomlord> ok thats fair enough. thats what i was assuming, but i realised it wasn't quite what everything else did
[10:56:08] <sebcrozet> doomrobo: to tell that the reference you return lives as long as the reference to `self` lives.
[10:56:10] <mark_edward> doomlord: do you know about inline asm?
[10:56:14] <kimundi> doomrobo: Explicit lifetimes are for annotating how long something life by _linking_ the lifetimes of different things together
[10:56:40] *** doomlord is now known as _doomlord
[10:56:56] *** Quits: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net) (Client exited)
[10:57:40] <_doomlord> i havent looked into inline asm here. i know they do have mapping to simd types
[10:57:44] <kimundi> In this case it means: "I get a reference to self, that has a lifetime 'a. Return a reference to something that has the same lifetime (because it's something from inside self)"
[10:58:16] <doomrobo> kimundi that actually makes more sense than any explanation I've heard so far. Thanks!
[10:58:30] <_doomlord> i think they seemed to favour allowing the compiler to figure out simd instructions from patterns of rust operations
[10:58:45] <mark_edward> I see
[10:58:52] <kimundi> Haha, thx :)
[10:58:59] <mark_edward> kimundi: do you know about inline asm in Rust?
[10:59:03] <kimundi> nope
[10:59:16] <_doomlord> they seemed quite confident its possible, although i was skeptical about all the permutes
[10:59:21] <kimundi> well... I know ABOUT it, but that's it :P
[10:59:24] *** Joins: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net)
[11:00:06] <_doomlord> thats somethign to check... can rust generate good simd code for transposing a 4x4 matrix (4x 4xf32)
[11:00:55] <_doomlord> perhaps they split the work with llvm on that..
[11:01:36] <mark_edward> kimundi: asm stuff https://github.com/mozilla/rust/pull/5317
[11:02:09] <mark_edward> i think inline LLVM IR could be useful too...
[11:02:14] <doomrobo> is there a way to check if an option type is None or Some without having to match it?
[11:02:25] *** Joins: Earnestly (earnest@2AB30F53.FB5005.2BCC804A.IP)
[11:02:50] <kimundi> mark_edward: (I meant that I know  that it exists, but not how to use it. Sorry for the confusion.)
[11:02:54] <sebcrozet> doomrobo: is_none() / is_some()
[11:03:02] <mark_edward> kimundi: no worries
[11:03:19] <doomrobo> great
[11:03:29] <kimundi> rusti: None::<uint>.is_none()
[11:03:29] -rusti- true
[11:06:07] <_doomlord> trying to improve the gtksourceview syntax highlighting but running out of their predetermined styles .. 
[11:06:43] *** Joins: dherman (dherman@moz-F35A8539.hsd1.or.comcast.net)
[11:06:43] *** ChanServ sets mode: +o dherman
[11:08:39] <kimundi> _doomlord: Add new ones! Patch the source! ;)
[11:08:43] <doomrobo> kimundi I wrote return self.parent.unwrap().get(key) and I'm getting an error
[11:08:51] <doomrobo> it says "cannot root managed value long enough"
[11:09:11] <_doomlord> i've got it highlighting the types and generic type args in function signatures ,and a few other thing
[11:10:14] <kimundi> doomrobo: I think you have to put the result of unwrap() into a local variable first
[11:11:00] <doomrobo> say what? why?
[11:11:02] <kimundi> doomrobo: Also, are you sure you want unwrap there? It consumes the parent field, wich in turn consumes the whole struct
[11:11:11] <kimundi> doomrobo: bug I'd say
[11:11:11] <sebcrozet> doomrobo: can you update your gist?
[11:11:52] <doomrobo> sure
[11:12:20] <doomrobo> oh, and making a temporary variable doesn't work kimundi
[11:14:04] <doomrobo> updated https://gist.github.com/doomrobo/83b5704fa6563b834cc8
[11:14:23] <nielsle_> Does rust guarantee that elements of a struct are instantiated in a given order? Vector { x: file.read(u32), y : file.read(u32), z : file.read(u32)}
[11:14:32] *** Joins: mye (mye@moz-FFDA3A47.dip0.t-ipconnect.de)
[11:14:49] <sebcrozet> doomrobo: thx, I take a look at it.
[11:14:52] <nielsle_> Hmm that should probably be file.read_u32() 
[11:15:22] <kimundi> nielsle_: I don't think it's written down somewhere, but the rule is left to right I think. might also be struct declaration order.
[11:15:47] <nielsle_> Thanks
[11:16:23] <cmr> nielsle_: Yeah, struct construction subexpression evluation isn't specified right now
[11:16:58] <nielsle_> So it is better style to create some interediate variables?
[11:17:00] <cmr> If it were, it'd be in http://static.rust-lang.org/doc/rust.html#structure-expressions
[11:17:09] <nielsle_> Thanks
[11:17:09] <cmr> nielsle_: no, probably just an oversight.
[11:17:15] <kimundi> doomrobo: Hm, thinking about it more, I don't think you need to return a Option<&@LiteralType>, a Option<@LiteralType> should be enough
[11:17:24] <sebcrozet> doomrobo: mmh, this looks tricky.
[11:17:57] *** Quits: reyre (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Client exited)
[11:17:58] <doomrobo> kimundi find() returns a reference to the type inside the hashmap. @LiteralType is what's inside, so find() will return &@Literaltype
[11:18:24] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[11:19:29] <kimundi> doomrobo: Right, you need to make a copy of tham managed pointer
[11:19:40] <sebcrozet> doomrobo: I commented something which compiles.
[11:19:54] <sebcrozet> doomrobo: it returns an Option<@Literaltype>
[11:21:00] <doomrobo> kimundi why?
[11:21:09] <sebcrozet> doomrobo: I‚Äôm not even sure you can manage to return a &'r @LiteralType since you dont have the lifetime of the parent.
[11:22:03] <doomrobo> sebcrozet why are you using get?
[11:22:19] <doomrobo> that will fail if the key doesn't exist in the parent
[11:22:29] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[11:22:50] *** Joins: Blei (philipp@moz-650B9C6A.cust.bluewin.ch)
[11:23:59] <kimundi> And as explanation how to get it from the Option<&@Literaltype> a Option<@Literaltype>: "Some(*val.unwrap())" means "take val=Option<&@Literaltype>, unwrap it: &@Literaltype, dereference it wich makes a copy of the managed smartpointer (not the data in it), and final wrap it as a Option again"
[11:24:23] <cmr> I don't think that's true.
[11:24:26] <doomrobo> I understand what sebcrozet did, I'm just not happy that it has to be so ugly
[11:24:31] <cmr> I think it's a move unless you have a .clone()
[11:24:51] <doomrobo> could you explain exactly what's wrong with the code as it stands? I'm really in the dark
[11:25:02] <kimundi> cmr: It's a & ptr. You can't move out of them, it would mean ownership transfer
[11:25:34] <cmr> kimundi: exactly, so you can't make a Some() from the dereference of it I thought
[11:25:45] <kimundi> It only works if the type behind the reference is implicit copyable
[11:26:07] <cmr> rusti: let x = @42; let y = &x; let z = Some(*y); printfln!("%?", z);
[11:26:08] -rusti- Some(@42)
[11:26:08] -rusti- ()
[11:26:12] <kimundi> Correct, but you can make an implicit copy of the dereference
[11:26:15] <cmr> well how about that!
[11:26:20] <kimundi> wich is what happens here
[11:26:27] <cmr> silly implicit copy
[11:26:38] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[11:26:48] <kimundi> cmr: replace the int by something with a destructor and if should fail
[11:27:34] <doomrobo> the code works without the last clone()
[11:28:23] <kimundi> doomrobo: Because a @ ptr is already implicit copyable I think
[11:28:34] <kimundi> So it's the same either way
[11:28:59] <sebcrozet> doomrobo: yes, and I dont think the first `if` clause should return None (my mistake).
[11:29:24] <doomrobo> (yeah, I didn't point out the logic mistakes, cuz they ain't important now)
[11:29:54] <doomrobo> kimundi but I'm not passing a @, I'm passing an Option<@> so Option types are copyable or does that recursively go back to checking whether @s are copyable?
[11:30:04] <kimundi> (If it's not clear yet: clone() in rust does NOT mean "make a deep copy", we have DeepClone for that. It's for making a shallow copy)
[11:30:31] <kimundi> doomrobo: Yes, such things are inherited through the type
[11:30:54] <kimundi> I think...
[11:31:16] <kimundi> rusti: let x = Some(42u); x
[11:31:17] -rusti- Some(42)
[11:31:21] <kimundi> rusti: let x = Some(42u); (x, x)
[11:31:22] -rusti- (Some(42), Some(42))
[11:31:27] <kimundi> rusti: let x = Some(~42u); (x, x)
[11:31:28] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/PgIG
[11:31:42] <kimundi> yeah
[11:36:18] <mark_edward> Luqman: ping
[11:36:59] <sebcrozet> doomrobo: I can‚Äôt find anything less uggly :(
[11:37:30] <kimundi> sebcrozet, doomrobo: I wrore sobmething shorter as ea comment
[11:38:17] <kimundi> wait, forgot half of the stuff to make it shorter...
[11:39:44] <kimundi> ... Okay my cosde is garbage, but that's becaus I don't understand whad sebcrozet is supposed to do xD
[11:40:41] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[11:40:42] *** Joins: bheylin (brianheyli@moz-3D24C757.static.chello.nl)
[11:43:12] *** Quits: dherman (dherman@moz-F35A8539.hsd1.or.comcast.net) (Quit: dherman)
[11:43:18] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[11:43:30] <sebcrozet> kimundi: My code is not equivalent to the original one.
[11:43:39] <kimundi> ah
[11:44:23] <sebcrozet> kimundi: I added whit you meant to do.
[11:44:47] <sebcrozet> kimundi: which should be equivalent to doomrobo initial code.
[11:46:19] *** Joins: mvalzelli (mvalzelli@moz-9E064543.ip2.fastwebnet.it)
[11:46:49] <sebcrozet> doomrobo: btw, dont use `return` unless you are obliged to.
[11:48:38] *** Quits: jaen (jaen@moz-8D59F623.neoplus.adsl.tpnet.pl) (Ping timeout)
[11:50:15] *** Quits: nyx114 (nyx114@337D90A6.170C4318.709ED47B.IP) (Ping timeout)
[11:50:40] *** Joins: nyx114 (nyx114@337D90A6.170C4318.709ED47B.IP)
[11:53:37] *** Joins: dherman (dherman@moz-F35A8539.hsd1.or.comcast.net)
[11:53:37] *** ChanServ sets mode: +o dherman
[11:54:49] *** Quits: dherman (dherman@moz-F35A8539.hsd1.or.comcast.net) (Quit: dherman)
[11:55:52] *** Joins: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net)
[11:56:24] <doomrobo> is there a way of denoting a function as a type in Rust without specifying the number of arguments, type, or return type? I'm guessing no...
[11:56:44] <dbaupp> doomrobo: nope
[11:57:20] <kimundi> doomrobo: Not really, unless you start using unsafe code
[11:57:33] <kimundi> whad do you need it for?
[11:57:46] <dbaupp> cmr: it's still pretty noisy :(
[11:58:25] *** Joins: jaen (jaen@moz-8D59F623.neoplus.adsl.tpnet.pl)
[11:58:28] *** Joins: sigma (sigma@moz-BE11A887.range109-151.btcentralplus.com)
[11:58:58] <cmr> dbaupp: I'll force the still-noisy ones again
[11:59:05] <cmr> it's half as many as last time though
[11:59:14] <cmr> Maybe I should turn off turbo?
[11:59:36] <dbaupp> yeah?
[12:00:00] <dbaupp> might make it more even? (although that would make some builds faster, right?)
[12:00:01] <cmr> turbo caused significant variance when I was benching individual PRs
[12:00:08] *** Quits: sigma (sigma@moz-BE11A887.range109-151.btcentralplus.com) (Ping timeout)
[12:00:14] <dbaupp> yup, sounds good.
[12:00:14] <cmr> It should make them uniformly slow.
[12:01:38] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[12:02:42] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[12:04:32] *** Joins: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au)
[12:04:54] *** Joins: LU324_ (stuff@moz-A17E9A7B.dyn.embarqhsd.net)
[12:06:03] <dbaupp> cmr: does bench-override update on the website?
[12:06:21] <cmr> dbaupp: it should..
[12:06:54] <cmr> it does
[12:06:58] <cmr> it is correctly empty
[12:07:34] <cmr> Ok, here's what I'm going to do.
[12:07:49] <cmr> I'm going to modify the auto-bench script to install every revision of rustc into its own prefix
[12:08:04] <cmr> archived_rusts/$HASH or something
[12:08:21] <cmr> and from there I'll do all the benchmarking..
[12:08:31] <doomrobo> kimundi I needed it for being lazy. I'm almost done with this. I might be able to get a working interpreter by tomorrow
[12:08:53] <dbaupp> cmr: your disk is going to rust to bits :P
[12:09:09] <dbaupp> cmr: (that will allow you to re-run them more easily, right?)
[12:09:35] <cmr> dbaupp: (yes, and also faster and can update with new benchmarks easily)
[12:10:51] <dbaupp> cmr: awesome
[12:10:55] <cmr> dbaupp: I'll put it in my spare 387.5GiB swap partition, plenty of space
[12:11:16] <doomrobo> is there a way to check if a variable is a particular subtype of an enum without matching?
[12:11:23] <cmr> (this was before I found that you can turn overcommit always-on rather than being swap + percentage of ram...)
[12:11:32] <cmr> doomrobo: no
[12:11:46] <cmr> doomrobo: rust has very very little subtyping
[12:12:00] <doomrobo> I don't think I said what I meant
[12:12:26] <cmr> you can't test for which enum variant in any way except `match` afaik
[12:12:28] <cmr> or unsafe code
[12:12:40] <doomrobo> suppose I have enum Shape {Circle(Point), Rect(~[Point])?}
[12:12:50] <doomrobo> oh, ok
[12:13:24] <doomrobo> and is there a way to match vectors as in, more than one element at a time?
[12:13:27] <dbaupp> cmr: that's swap o_O
[12:13:41] <cmr> dbaupp: yeah... it was a questionable period of my life ;p
[12:13:56] <dbaupp> cmr: ... maybe you should turn it into something sensible
[12:14:01] <dbaupp> like fat32
[12:14:03] <cmr> I am! Rust storage.
[12:14:13] <dbaupp> haha :)
[12:14:22] <cmr> oh no it got reformatted as ext4, don't worry :p
[12:15:17] <dbaupp> dammit use a proper filesystem :P
[12:15:43] <cmr> such as fat32? :)
[12:16:27] <bstrie> we need some sqlite bindings :)
[12:16:36] <cmr> bstrie: there are some old ones somewhere
[12:16:41] <cmr> I don't know if they were updated for 0.7
[12:16:47] *** Joins: sigma (sigma@2AE71BC1.DC5B0862.37339E3A.IP)
[12:17:12] <bstrie> doomrobo: do you know about vector destructuring?
[12:17:16] <mark_edward> Luqman: pong
[12:17:26] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[12:17:54] <dbaupp> cmr: totally :P
[12:18:00] <bstrie> doomrobo: match [1,2,3.4] { [first, ..middle, last] => ..., _ => ... }
[12:19:56] <dbaupp> <3 vector destructuring
[12:20:03] <bstrie> rusti: std::FromStr::from_str::<uint>("6")
[12:20:04] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/LBEG
[12:20:25] <bstrie> rusti: std::from_str::FromStr::from_str::<uint>("6")
[12:20:26] -rusti- Some(6)
[12:20:33] <bstrie> a bit repetitive
[12:21:14] <dbaupp> rusti: FromStr::from_str::<uint>("6")
[12:21:15] -rusti- Some(6)
[12:21:22] <bstrie> well that's nice
[12:21:22] <dbaupp> bstrie: FromStr is in the prelude
[12:21:46] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[12:24:32] <bstrie> maybe we can rename FromStr's `from_str` method to `to`, so that it looks like `FromStr::to::<uint>("6")`
[12:24:58] <cmr> bstrie: then implementors of FromStr have to reserve such a nice method name for it.
[12:25:00] <dbaupp> haha, that's nice
[12:25:21] <dbaupp> cmr: why? it's always in the FromStr namespace as a static method
[12:25:27] <cmr> rusti: use x = FromStr::from_str; from_str::<uint>("6")
[12:25:28] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/UjKM
[12:25:35] <dbaupp> *associated function.
[12:25:42] <bstrie> you can't just import static methods
[12:25:44] <bstrie> afaik
[12:25:46] <cmr> rusti: use x = std::from_str::FromStr::from_str; from_str::<uint>("6")
[12:25:47] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/TPgb
[12:25:54] <cmr> figured it was worth the shot
[12:25:57] <bstrie> have to qualify them with a trait
[12:27:17] <cmr> rusti: struct Foo; impl Foo { pub fn from_str(&self, a: &str) -> Foo { Foo } } impl FromStr for Foo { pub fn from_str(a: &str) -> Foo { Foo } }
[12:27:19] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/fUBe
[12:27:31] <cmr> rusti: struct Foo; impl Foo { pub fn from_str(&self, a: &str) -> Foo { Foo } } impl FromStr for Foo { pub fn from_str(a: &str) -> Option<Foo> { Some(Foo) } }
[12:27:33] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/IfUG
[12:27:39] <dbaupp> rusti: use FS = std::from_str::FromStr; FS::from_str::<uint>("6")
[12:27:40] <cmr> dbaupp: huh!
[12:27:40] -rusti- Some(6)
[12:28:00] <dbaupp> cmr: functions and methods are different namespaces
[12:29:26] <dbaupp> (and static methods are literally just placed in a mod with the same name as the type.)
[12:29:51] <dbaupp> rusti: mod Foo {} struct Foo; impl Foo { fn x() { } }
[12:29:53] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/WhZL
[12:30:04] <bstrie> dbaupp: can you think of any other static methods that also have the form FooBar::foo_bar?
[12:30:13] <dbaupp> bstrie: One::one, Zero::zero
[12:30:18] <bstrie> hm
[12:30:25] <dbaupp> (in a non-underscorey way)
[12:30:27] <bstrie> what does One::one do?
[12:30:32] <cmr> Should One be Identity instead?
[12:30:48] <dbaupp> rusti: (One::one::<uint>(),  One::one::<float>())
[12:30:51] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/gQIA
[12:31:01] <dbaupp> rusti: use std::num::One; (One::one::<uint>(),  One::one::<float>())
[12:31:02] -rusti- (1, 1)
[12:31:22] <bstrie> how about One::of::<uint>() instead :P
[12:31:43] <doomrobo> alright, I'm calling it a night. On second through I might not have this interpreter ready by tomorrow
[12:31:57] <bstrie> doomrobo: unacceptable! see yourself to the whipping chamber
[12:32:06] <doomrobo> again, thank you very much everyone for putting up with me. I think I might be getting the hang of this
[12:32:12] <bstrie> night :)
[12:32:13] <_doomlord> doomrobo how do you like rust so far
[12:32:15] <dbaupp> bstrie: Zero::of::<uint>() too
[12:32:20] <doomrobo> ?or I've become so sleep deprived that I think I'm good at this
[12:32:59] *** Joins: jfbk (textual@moz-EEA9CFB3.nyc.res.rr.com)
[12:33:06] <doomrobo> _doomlord it's definitely something totally new. The typing and evaluation is remeniscent of OCaml but damn the pointer aspect of the type system is brand new for me
[12:33:14] <doomrobo> I'm liking it. And I'll be back for more
[12:33:16] <doomrobo> nighty night
[12:33:19] <_doomlord> good stuff
[12:33:21] *** Quits: doomrobo (doomrobo@EC9C662A.161AAEB2.58B1C2DD.IP) (Quit: later)
[12:33:38] <cmr> bstrie: I'm not sure I like the clever names
[12:33:50] *** _doomlord is now known as doomlord
[12:33:51] <dbaupp> bstrie: Rand::rand
[12:33:54] <cmr> They're nice to use, but defining them seems quite weird :\
[12:34:12] *** Joins: timm (timm@moz-84C7E862.web.vodafone.de)
[12:34:28] <dbaupp> Decodable::decode
[12:34:45] <dbaupp> Decode::out_of(some_decoder)
[12:35:10] <dbaupp> Rand::om_value_created_with(rng)
[12:36:12] <bstrie> dbaupp: I only care about names that are identical, because it means there's been no thought given to them
[12:36:38] <dbaupp> bstrie: yeah, but in most cases, there's nothing else to call them without making them too cute
[12:36:50] <bstrie> bah, the war on cuteness continues apace
[12:36:57] <cmr> heh
[12:37:06] * bstrie clings to 10.times
[12:37:16] * dbaupp likes .times
[12:37:58] <cmr> I don't see why times couldn't be an external iterator
[12:38:12] <dbaupp> `do 10.times { .. }` reads even better than `for 10.times { ... }` anyway
[12:38:22] <cmr> you think so?
[12:38:28] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[12:38:36] <bstrie> I do
[12:38:56] <bstrie> cmr: what does it gain from being an external iterator? just seems less efficient that way
[12:39:08] <dbaupp> bstrie: it's break/return able
[12:39:10] <cmr> bstrie: less efficient? it's the same thing sans closure call
[12:39:19] <bstrie> not if you have to construct an iterator object
[12:39:27] <dbaupp> bstrie: they get optimised away
[12:39:40] <cmr> constructing an iterator object is no different than setting up internal variables to control calling the closure
[12:39:59] <cmr> (and they do get optimized very well; our closures don't get optimized as awesome yet)
[12:40:16] <bstrie> in any case, I stand by my assertion that if you're breaking out of a `10.times` loop, that's a violation of the implicit contract :P
[12:40:33] * dbaupp still wants do 10.times { ... }
[12:40:35] <bstrie> it not `10.times_or_possibly_fewer`
[12:40:54] <bstrie> use something more clever if you want clever control flow
[12:41:15] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[12:41:15] * cmr waves his cane, "you kids and your flow control"
[12:41:28] *** Quits: timm (timm@moz-84C7E862.web.vodafone.de) (Ping timeout)
[12:41:40] <cmr> "When I was your age all we had was jmp, AND WE LIKED IT!"
[12:41:48] <doomlord> do forever {}  ..    do 10.times{...} makes sense to me
[12:42:11] *** Joins: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[12:42:31] <bstrie> bah, we have `loop {}` for that first case :P
[12:42:34] <dbaupp> doomlord: `do forever { }` == loop
[12:42:40] *** Joins: novabyte (Instantbir@moz-3E0F9699.cable.virginmedia.com)
[12:42:46] <doomlord> free up the keyword :)
[12:42:52] <dbaupp> cmr: that's a total lie :P
[12:42:55] <bstrie> doomlord: we still use `loop` as `continue`
[12:43:27] <cmr> If we didn't have `loop`, how would one construct this `forever` function?
[12:43:38] <doomlord> while true
[12:43:40] <cmr> right
[12:43:42] <dbaupp> whil true! recursion!
[12:43:42] <cmr> duh
[12:43:45] <bstrie> doomlord: in any case, you can do labeled break on `loop` (since it's just sugar for `while`), but you can't break from `do` at all
[12:43:51] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[12:43:52] * cmr goes to the dunce turner
[12:43:54] <cmr> *corner
[12:43:56] <dbaupp> hahaha
[12:44:01] <cmr> I forgot about while loops, I never use them in rust
[12:44:12] <bstrie> I used one yesterday!
[12:44:19] <cmr> ... except I do, when expressing state machines
[12:44:25] <cmr> so there goes that excuse
[12:44:35] <bstrie> also I used one a year ago when I wrote `10.times` :)
[12:44:42] *** Joins: timm (timm@moz-84C7E862.web.vodafone.de)
[12:44:44] <doomlord> between while intrinsic loop and do sugar you can do a lot, it seems
[12:44:47] <bstrie> so that's two that I've used, ever :P
[12:45:09] * dbaupp removed a pile of while loops from that benchmark thingo
[12:45:35] <bstrie> I could take or leave the `loop` sugar for `while true`. it seems harmless enough, since we're using that keyword elsewhere
[12:46:11] <dbaupp> rusti: loop {} 1
[12:46:12] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/SPdL
[12:46:12] <bstrie> the only reason it exists is because typestate needed a way to confirm that you meant to have an infinite loop
[12:46:20] <bstrie> but we don't have typestate any more :P
[12:46:45] <dbaupp> rusti: while true {} 1
[12:46:45] <gavinb> Is there a way in rust to display the inferred type of something? Like :t in ghci?
[12:46:47] <Blei> what's the syntax for extern global variables? `extern { static foo: int; }` doesn't seem to work (anymore?)
[12:46:51] -rusti- <anon>:7:9: 7:22 warning: denote infinite loops with loop { ... } [-W while-true (default)]
[12:46:51] -rusti- <anon>:7          while true {} 1
[12:46:51] -rusti-                   ^~~~~~~~~~~~~
[12:46:51] -rusti- timeout triggered!
[12:46:56] <dbaupp> gavinb: not really
[12:46:58] <bstrie> gavinb: rustc --pretty types
[12:47:07] <bstrie> or maybe --pretty typed
[12:47:13] <dbaupp> gavinb: `let _: () = your_expression();` works too
[12:47:15] <bstrie> that will print out your code with all the types written in
[12:47:28] <gavinb> ah cool, thanks
[12:47:34] <doomlord> wow.
[12:47:46] <doomlord> you can dump the source with types annotaed?
[12:47:50] <bstrie> yeah
[12:47:53] <bstrie> via the pretty printer
[12:48:08] <bstrie> which has the unfortunate side effect of running your code through the pretty printer :P
[12:48:09] <doomlord> some idiot elsewhere (who will remain nameless) is saying 'type inference is bad because you can't see the types'
[12:48:24] <dbaupp> doomlord: lpapp again? :P
[12:48:54] <bstrie> doomlord: "who cares if you can see the types as long as the compiler can" :)
[12:49:05] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[12:49:11] <doomlord> this idiot is in a position to ban 'auto' in his c++ project. i tried to explain to him just about every IDE can show them in popup boxes
[12:49:41] <Blei> i agree to a certain extent, when you are in the middle of a big function in a codebase you're not familiar with, it can be intimidating
[12:49:53] <cmr> I also agree.
[12:49:54] <Blei> especially if you don't have a good IDE
[12:50:07] <cmr> But the benefits far outweigh that downside.
[12:50:12] <Blei> definitely
[12:50:26] <doomlord> my argument is you can be more descriptive with names if you ahve to write them out manually less
[12:50:31] *** Quits: timm (timm@moz-84C7E862.web.vodafone.de) (Ping timeout)
[12:50:55] <doomlord> ... and you're not discouraged from breaking up complex expressons either
[12:51:03] <cmr> doomlord: and C++ has named constructors anyway, so you'll always be seeing the type as the constructor name, right?
[12:51:42] <doomlord> yes. and there's other reasons to lookup the functions .. to see arguments. you have all sorts of other hidden stuff going on with conversions..
[12:52:13] *** Quits: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Ping timeout)
[12:53:19] <Blei> ah, found the problem. `pub extern` doesn't work anymore and the error span was wrong
[12:53:30] <bstrie> rusti: let x: uint = FromStr::from_str("6"); x
[12:53:30] <doomlord> i think infered types also ease refactoring
[12:53:31] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/ggCT
[12:53:44] <bstrie> fg
[12:53:46] <bstrie> sigh
[12:53:55] <bstrie> rusti: let x: Option(uint) = FromStr::from_str("6"); x
[12:53:55] -rusti- <anon>:7:22: 7:23 error: expected `;` but found `(`
[12:53:55] -rusti- <anon>:7          let x: Option(uint) = FromStr::from_str("6"); x
[12:53:55] -rusti-                                ^
[12:53:55] -rusti- application terminated with error code 101
[12:54:08] <bstrie> rusti: let x: Option<uint> = FromStr::from_str("6"); x
[12:54:09] -rusti- Some(6)
[12:54:28] <bstrie> right, that means my plan to change it to FromStr::to is a bad idea :P
[12:55:04] <bstrie> let's not try to improve readability by mandating the hideous type hints
[12:55:42] <dbaupp> pcwalton was proposing using : for type hints, btw.
[12:55:51] *** Joins: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[12:55:57] <cmr> dbaupp: not in paths I thought
[12:55:59] <bstrie> but not in all contexts
[12:56:05] <dbaupp> cmr: on expressions, yes
[12:56:05] <cmr> I thought it was for bounding subexpressions
[12:56:09] <bstrie> though it would help alleviate the type hint burden
[12:56:46] *** Joins: timm (timm@moz-84C7E862.web.vodafone.de)
[12:56:47] *** Quits: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net) (Ping timeout)
[12:57:41] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[12:58:24] <gavinb> rusti: let file_writer = io::file_writer("/tmp/test.txt", [io::Create]).get();
[12:58:25] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/jWHA
[12:58:27] *** Quits: timm (timm@moz-84C7E862.web.vodafone.de) (Ping timeout)
[12:58:40] <dbaupp> rusti: use std::io; let file_writer = io::file_writer("/tmp/test.txt", [io::Create]).get();
[12:58:42] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/NXRF
[12:59:00] <dbaupp> rusti: use std::io; let file_writer = io::file_writer(&Path("/tmp/test.txt"), [io::Create]).unwrap();
[12:59:01] -rusti- <anon>:7:26: 7:37 warning: unused variable: `file_writer` [-W unused-variable (default)]
[12:59:01] -rusti- <anon>:7          use std::io; let file_writer = io::file_writer(&Path("/tmp/test.txt"), [io::Create]).unwrap();
[12:59:01] -rusti-                                    ^~~~~~~~~~~
[12:59:01] -rusti- ()
[12:59:21] <gavinb> dbaupp: Thanks for fixing!
[12:59:50] <gavinb> I get this though: error: failed to find an implementation of trait std::clone::Clone for @std::io::Writer:'static
[13:00:19] <ChrisMorgan> What exactly is a #[x(y="z")] thing called, and what does it actually _do_?
[13:00:24] <cmr> ChrisMorgan: attribute
[13:00:37] <cmr> ChrisMorgan: adds metadata at compiletime, end effect depends on attribute
[13:00:51] *** Joins: timm (timm@moz-84C7E862.web.vodafone.de)
[13:01:55] *** Joins: goffrie_ (goffrie@moz-1A2DE2C4.dsl.ncf.ca)
[13:02:09] <dbaupp> ChrisMorgan: e.g. #[link(name="foo")] at the top if a crate is interpreted as the name of that crate, #[link_section="foo"] on a fn/static puts it into that section of the binary, #[deriving(Eq)] on a type is interpreted by the macro-expander to make an impl of Eq for that type.
[13:02:28] <ChrisMorgan> I was mildly surprised to discover arbitrary attributes can be added and the compiler doesn't say "hey, I don't know this attribute type".
[13:02:32] *** Quits: goffrie (goffrie@moz-8764A29A.dsl.ncf.ca) (Ping timeout)
[13:02:39] <cmr> Yeah, that needs to be improved.
[13:02:48] <cmr> A central registry of recognized attributes
[13:03:05] *** Quits: etw (john@moz-B2936CAB.nyc.res.rr.com) (Quit: etw)
[13:03:07] <cmr> Plus a unified attribute handling interface that lets it reject invalid attributes
[13:03:10] <dbaupp> ChrisMorgan: it's tricky, because things just directly query the ast for the attributes of a thing
[13:03:24] <bstrie> I don't think it should be more than a lint. attributes are ideally just metadata, for use with tools other than the compiler
[13:03:25] <dbaupp> (and this happens throughout the whole compiler.)
[13:03:40] <dbaupp> bstrie+=1
[13:03:53] <cmr> bstrie: sure
[13:03:57] <ChrisMorgan> But some like cfg() affect whether code is compiled or not.
[13:04:07] <bstrie> indeed
[13:04:20] <dbaupp> ChrisMorgan: yes
[13:04:33] <dbaupp> ChrisMorgan: (what are you getting at with that?)
[13:04:45] *** Joins: reyre (reyre@F2D29657.F60B0462.67AC9B1.IP)
[13:04:45] <ChrisMorgan> That's metadata that the compiler is then using, not "a tool other than the compiler"
[13:04:59] <dbaupp> ChrisMorgan: right, there's lots of stuff the compiler actually uses
[13:05:16] <ChrisMorgan> So you can have bad Rust code inside a non-compiled part, so long as it parses.
[13:05:17] <dbaupp> bstrie is just saying that users might want to put their own attributes on, for tools they've written themselves
[13:05:22] *** Quits: timm (timm@moz-84C7E862.web.vodafone.de) (Ping timeout)
[13:05:23] <dbaupp> right... ?
[13:05:38] <cmr> yes
[13:05:54] <dbaupp> (the right was questioning ChrisMorgan's statement.)
[13:05:57] <ChrisMorgan> "I don't think it should be more than a lint." I took that as excluding things like cfg(), test, &c.
[13:06:20] <dbaupp> bstrie was saying that the check for invalid attributes shouldn't be more than a lint.
[13:06:26] <cmr> (oh)
[13:06:33] <bstrie> right, I'm saying that the compiler shouldn't forbid unknown attributes as compilation errors. someone was suggesting that a while ago, I forget who
[13:06:34] <dbaupp> ChrisMorgan: i.e. it's disableable
[13:06:34] <ChrisMorgan> Oh, I see. That makes sense then.
[13:07:04] <cmr> ChrisMorgan: I agree that cfg'd off code is a problem, but it is very hard to solve
[13:07:05] <ChrisMorgan> But at present it makes no murmur.
[13:07:12] <ChrisMorgan> Sure.
[13:07:16] <cmr> If you don't have tests for that configuration, it doesn't work anyway :p
[13:07:34] <dbaupp> cmr: there's murmurs of having `#[cfg(off)] mod x;` not even try to open the file
[13:08:51] <ChrisMorgan> Someone, I think it was dbaupp, was suggesting that code generation through attributes could be a way of solving compile-time template compilation, like a glorified fmt! macro. That would be depending on some form of CTFE, which I believe not to be implemented at present. How would that work? Will it work?
[13:09:05] <dbaupp> ChrisMorgan: (it was a total joke.)
[13:09:16] <ChrisMorgan> dbaupp: you were playing on my credulity :-(
[13:09:30] <dbaupp> ChrisMorgan: haha, sorry :(
[13:09:36] *** Joins: dherman (dherman@1A20C896.96FE09F3.3002A442.IP)
[13:09:36] *** ChanServ sets mode: +o dherman
[13:10:05] <ChrisMorgan> Some form of CTFE would manage it. The alternative is adding a previous step to the compilation which generates Rust code‚Äînot quite so nice.
[13:10:07] <dbaupp> ChrisMorgan: (it was just a thought experiment to see how much one needed to change the cfg-stripper to make it turing complete. :P )
[13:10:08] *** Joins: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP)
[13:10:35] * ChrisMorgan wishes one could define something like fmt! in one's own code
[13:10:36] <dbaupp> because, turing complete conditional compilation is fun?
[13:10:44] <dbaupp> ChrisMorgan: it's planned
[13:11:08] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[13:11:08] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/DaWWiQ
[13:11:08] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[13:11:26] <dbaupp> ChrisMorgan: https://github.com/mozilla/rust/issues/1762
[13:12:12] <bstrie> ChrisMorgan: that's planned
[13:13:41] *** Joins: Guest (textual@moz-E64A54F3.nyc.res.rr.com)
[13:13:55] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[13:13:55] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/SU33rg
[13:13:55] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[13:13:56] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[13:13:56] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/jkneBg
[13:13:56] <ghrust> 13rust/06auto 14c3417b8 15Graydon Hoare: syntax: Fix #6416 by aborting on errors after test parse.
[13:13:56] <ghrust> 13rust/06auto 14382b037 15bors: auto merge of #8037 : graydon/rust/issue-6416, r=cmr...
[13:13:56] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[13:16:35] *** Joins: Sergio965 (sergiobz@moz-BB21156B.dynamic.csail.mit.edu)
[13:17:16] <Sergio965> Is there any way to cast a memory address directly to a borrowed pointer?
[13:17:36] *** Quits: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au) (Quit: gavinb)
[13:17:40] <cmr> Sergio965: std::cast::transmute
[13:18:02] <cmr> there's also a transmute_region or something similar that lets you set the lifetime
[13:19:11] *** Quits: jfbk (textual@moz-EEA9CFB3.nyc.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzz‚Ä¶)
[13:19:23] <ChrisMorgan> `transmute` certainly does seem very flexible.
[13:19:40] <bstrie> it's too flexible, that's the problem :)
[13:19:53] <bstrie> we need to figure out what the main uses are for it and split them out into separate functions
[13:20:59] <Sergio965> cmr: Thanks!
[13:21:31] <Sergio965> It seems that using a borrowed pointer as a field in a struct requires the explicit declaration of a lifetime. I imagine this is what the 'self lifetime is for. Is there somewhere I can read about this?
[13:22:23] <bstrie> Sergio965: http://static.rust-lang.org/doc/tutorial-borrowed-ptr.html might have something
[13:22:47] <Sergio965> bstrie: I've read through that, but unfortunately it doesn't talk about when I can or cannot use anonymous lifetimes.
[13:23:06] <cmr> Sergio965: You can only use anonymous lifetimes when the lifetime can safely be inferred
[13:23:17] <cmr> For structs, that's not possible.
[13:23:45] <Sergio965> I see.
[13:23:53] <Sergio965> Honestly, I'm having trouble understanding lifetimes.
[13:24:13] <Sergio965> I don't think the current literature does a good job of explaining it.
[13:24:36] <cmr> no, it's not adequate yet
[13:24:42] <dbaupp> (there's nothing special about the 'self lifetime btw, it's just the only name allowed in type definitions.)
[13:25:05] <Sergio965> dbaupp: Ah, I see. I was curious about that.
[13:25:06] <dbaupp> Sergio965: you can only use anonymous lifetimes in function *arguments* and on local variables
[13:26:07] <dbaupp> (well, I think you can use anonymous lifetimes as return values too, but one can't actually return anything that will make this region-/type-check.)
[13:26:17] <dbaupp> rusti: fn foo() -> &int { &1 }
[13:26:18] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/QGZa
[13:26:29] *** Joins: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP)
[13:26:35] <dbaupp> rusti: static x: int = 1; fn foo() -> &int { &x }
[13:26:36] -rusti- ()
[13:26:38] <cmr> rusti: fn foo(i: &int) -> &int { i }
[13:26:39] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/QXAW
[13:26:46] <dbaupp> oh, no, they do work.
[13:26:54] <dbaupp> I guess every region is a subregion of 'static.
[13:29:42] *** Quits: Guest (textual@moz-E64A54F3.nyc.res.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzz‚Ä¶)
[13:29:43] <Sergio965> I think one place the documentation could be readily improved is in its presentation of code examples. Many times some function is defined but it's never used. Thus, I don't even know the syntax for how to call functions making use of lifetimes.
[13:30:03] <dbaupp> just call them normally :)
[13:30:11] <Sergio965> Are they inferred?
[13:30:11] *** Joins: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au)
[13:30:13] <dbaupp> yup
[13:30:55] <Sergio965> http://static.rust-lang.org/doc/tutorial-borrowed-ptr.html#named-lifetimes
[13:31:08] <dbaupp> lifetimes only have to be explicit on definitions of functions/types etc, but the compiler can reason about them (normally) when you're just using them
[13:31:15] <Sergio965> The select function, for example, I have no idea why lifetimes are necessary.
[13:31:35] <Sergio965> Or what "This function takes three borrowed pointers and assigns each the same lifetime r." means.
[13:32:04] *** Quits: z0w0 (zack@moz-E12708D5.lns6.woo.bigpond.net.au) (Client exited)
[13:32:06] <Sergio965> (Specifically, what does it mean to assign the borrowed pointers the same lifetime? Are things re-arranged in memory as a result, or is it just a tag to ensure non-null pointers?)
[13:32:13] <dbaupp> no
[13:32:20] <dbaupp> it's purely compile-time
[13:32:29] <cmr> Sergio965: It's a compile-time assertion that they all live for at least as long as 'r
[13:32:51] <dbaupp> it's just a gaurantee to the compiler that says that the return value is valid for the same length of time as the other things labelled with 'r
[13:32:54] <Sergio965> So in that case, that they all live as long as the shortest variable passed in?
[13:33:11] <dbaupp> yeah, the intersection of the periods-of-validity of the variables passed in
[13:37:23] <Sergio965> I see.
[13:37:34] <Sergio965> Okay, I think I understand in relation to functions and function calls.
[13:38:06] <Sergio965> I don't quite understand why I have to explicitly tell the compiler, though. Why would it be able to figure it out without the explicit declarations?
[13:38:16] <Sergio965> wouldn't(
[13:38:18] <Sergio965> wouldn't*
[13:38:46] <cmr> Sergio965: for select, it would.
[13:38:49] <cmr> it's a silly example.
[13:39:03] <dbaupp> as in, it should be able to look at the function body and infer the lifetimes?
[13:39:09] *** jyeo is now known as jyeo_away
[13:39:16] <cmr> Well, except the return lifetime
[13:39:39] <Sergio965> dbaupp: Isn't it always conservative to take the intersection of the lifetimes of all borrowed pointers?
[13:39:47] <dbaupp> Sergio965: too restrictive
[13:39:57] <kimundi> Sergio965: Depending on situation you might want different ways the lifetimes are linked
[13:40:01] <Sergio965> I can't think of an example where I don't want that.
[13:40:03] <ChrisMorgan> What we need is a good, simple, realistic, interactive example.
[13:40:25] <Sergio965> I guess I keep asking myself: "What do lifetimes let me do that I couldn't do before?"
[13:40:41] <cmr> Sergio965: memory safe references without GC
[13:41:05] <kimundi> Sergio965: "write lifetime linkage assertions to allow things wich would otherwise have to be forbidden due to safety"
[13:41:06] <dbaupp> Sergio965: I believe it used to be all unannotated &'s had the same lifetime (i.e. intersection of all the borrowed pointers), and this was removed
[13:41:30] <nmatsakis> Sergio965: it is not always conservative. 
[13:41:47] <nmatsakis> the defaults are the way they are because they accept the widest set of inputs
[13:41:47] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[13:41:48] <Sergio965> nmatsakis: Can you give me an example?
[13:42:21] <nmatsakis> fn foo(x: &mut &T, y: &T)
[13:42:41] <nmatsakis> the examples are fairly involved, but it always has to do with variance,
[13:42:45] <nmatsakis> which typically has to do with mutability
[13:43:06] <Sergio965> nmatsakis: So here, I'd need to do fn foo(x: &'r mut &'r T, y: &'r T)?
[13:43:14] <Sergio965> and foo<'r>
[13:43:16] <nmatsakis> well it depends on what you want
[13:43:25] <nmatsakis> if you wanted to do `*x = y`
[13:43:27] <nmatsakis> you would need:
[13:43:35] <nmatsakis> fn foo<'r>(x: &mut &'r T, y: &'r T)
[13:43:41] <nmatsakis> note that the lifetime of `x` itself is irrelevant
[13:43:53] <nmatsakis> fn foo<'r,'s>(x: &'s mut &'r T, y: &'r T) { *x = y } more explicitly
[13:44:22] <nmatsakis> it is not necessary that x lives as long as the things it points at, in other words
[13:44:26] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[13:44:43] <Sergio965> I see.
[13:44:56] <Sergio965> But in this example, taking the intersection of all lifetimes would work.
[13:45:08] <nmatsakis> which example are you referring to?
[13:45:12] <nmatsakis> the one I just gave?
[13:45:13] <nmatsakis> or select
[13:45:13] <Sergio965> Yeah.
[13:45:22] <Sergio965> No, the one you just gave.
[13:45:24] <nmatsakis> what do you mean by "would work"
[13:45:55] <nmatsakis> in the old system, any unlabeled lifetime was equivalent to a single defualt parameter,
[13:46:03] <Sergio965> I mean, if the same lifetime was, by default, assigned to all borrowed pointers in a function declaration, any usage of the borrowed pointers in the function body would be safe.
[13:46:09] <nmatsakis> so fn foo(x: &mut &T, y: &T) --> fn foo<'r>(x: &'r mut &'r T, y: &'r T)
[13:46:23] <nmatsakis> yes, the body would type check,
[13:46:27] <nmatsakis> but legitimate calls to the function would not
[13:46:33] <nmatsakis> e.g.,
[13:46:37] <Sergio965> Right, it's too restrictive, I agree.
[13:46:46] <Sergio965> But it also saves me from writing a lot of code in the common case.
[13:46:51] <Sergio965> Or, you know, a lot of 's.
[13:46:56] * nmatsakis shrugs
[13:47:01] <nmatsakis> I don't know, I don't find I write very many?
[13:47:05] <nmatsakis> that was tthe original idea,
[13:47:12] <cmr> Sergio965: in the common case you don't need to write any?
[13:47:14] <nmatsakis> but we found that in practice it was both confusing and not as helpful as we thought
[13:47:19] <nmatsakis> for example,
[13:47:25] <Sergio965> cmr: Well, in the common case of needing to use multiple borrowed pointers.
[13:47:48] <cmr> Sergio965: I don't think that that is the common case at all
[13:48:00] <cmr> fn foo(&self, f: &T)
[13:48:02] <dbaupp> Sergio965: (and with familiarity, writing a few 's isn't a huge burden since it's fairly "obvious" where they have to go.)
[13:48:17] <cmr> f shouldn't need to live as long as self, or vice versa
[13:48:22] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[13:48:23] <nmatsakis> Sergio965: besides, I like seeing the 's written out, because it tells me: this return pointer is derived from this/these inputs
[13:48:27] <Sergio965> cmr: Perhaps not. But it just seems to me whenever I want to do something involved with Rust, I have to stop and read quite a bit to know what's happening and it almost always comes back to lifetimes.
[13:48:41] <cmr> Sergio965: Are you writing data structures?
[13:48:52] <nmatsakis> whereas if I don't write any 'a, I know "this is only used"
[13:48:57] <Sergio965> dbaupp: I can imagine. I'm not very familiar with Rust yet, and lifetimes are giving me issues.
[13:48:58] <Sergio965> cmr: Yes.
[13:49:07] <cmr> Sergio965: Data structures are extremely difficult to write in rust
[13:49:10] <dbaupp> Sergio965: (once you "click", lifetimes are actually really simple, it's just grokking them that's tricky :) )
[13:49:22] <cmr> (because it's extremely difficult to write memory-safe, efficient data structures)
[13:49:38] <nmatsakis> many data structures rely on complex invariants
[13:49:41] <Sergio965> cmr: Yeah, I've noticed. I can't figure out how to write a structure with a borrowed pointer at the moment.
[13:49:46] <nmatsakis> that are hard to understand for a human, much less the compiler :)
[13:50:14] <cmr> Sergio965: structs are a bit limited right now in that you can't have two borrowed references of different lifetime in them atm
[13:50:16] <Sergio965> Looking at the compiler code, the code is full of 's <'s> and such.
[13:50:37] <ChrisMorgan> I've scarcely worked in C/C++ but had a solid understanding of the concepts of pointers. Borrowed pointers and lifetimes were a little difficult to get started with, but after a couple of weeks in Rust, I'm fairly comfortable with owned and borrowed pointers.
[13:50:46] <Sergio965> For example, I don't understand what implementing a trait for a &'r something means.
[13:50:49] <ChrisMorgan> Stick at it and you'll get it.
[13:51:08] <cmr> impl<'r> Foo for &'r T { ... }
[13:51:20] <cmr> Sergio965: you can now return borrowed pointers which last as long as the value
[13:51:22] <Sergio965> ChrisMorgan: That's just the thing. I have a very solid understanding of C and everything C, but Rust's lifetimes (and rather, their usage" doesn't quite click.
[13:51:33] <dbaupp> cmr: ('self is the only lifetime allowed there, btw.)
[13:51:37] <dbaupp> (well, and 'static)
[13:51:37] <Sergio965> I understand the difference in the pointers, managed, borrowed, owned, and they make sense.
[13:51:41] <nmatsakis> cmr: (temporarily)
[13:51:58] <Sergio965> cmr: But what does it mean to implement something for a borrowed pointer with lifetime r?
[13:52:04] <Sergio965> Or a borrowed pointer, at that?
[13:52:32] <Sergio965> I found no documentation about this.
[13:52:37] <dbaupp> Sergio965: nothing, it's the same as implementing it for ~T or @T or Foo<T> or Bar, just the type is &T
[13:52:41] <dbaupp> *nothing special
[13:53:00] <Sergio965> dbaupp: I don't understand what it means to implement for any of those types, actually.
[13:53:10] <Sergio965> Why don't they just "exist" when I implement T?
[13:53:19] <dbaupp> Sergio965: oh, so the problem is how traits work?
[13:53:32] <Sergio965> dbaupp: Perchance. I mean, I understand what traits are.
[13:53:40] <Sergio965> But perhaps I don't understand how they work?
[13:54:00] <dbaupp> impl Foo for SomeType { ... } basically says SomeType has the Foo "behaviour"
[13:54:07] <Sergio965> Right, I got that part.
[13:54:29] <dbaupp> and so impl Foo for &T { ... } says that borrowed pointers are Foo-ish
[13:54:43] <Sergio965> I guess, why would I need a: impl Foo for SomeType and a impl Foo<'r> for &'r SomeType?
[13:54:54] <Sergio965> But does that follow?
[13:54:56] <Sergio965> doesn't*
[13:55:04] <Sergio965> From having implemented it for the actual type?
[13:55:22] <dbaupp> oh, normally the &'self SomeType impls don't have a corresponding SomeType impl. i.e. the Foo-ishness is only for the borrowed pointer version of SomeType
[13:55:39] <Sergio965> Oh.
[13:55:45] <Sergio965> Interesting.
[13:55:46] <ChrisMorgan> Whoa... I just tried playing with managed pointers and I managed to do something which is clearly REALLY bad. Fortunately, the computer didn't quite crash.
[13:55:52] <ChrisMorgan> rusti: struct X { prev: Option<@X>, next: Option<@X>, tag: ~str }let a=@mut X{prev:None,next:None,tag:~"a"};let b=@X{prev:Some(unsafe{::std::cast::transmute(a)}), next:None,tag:~"b"};a.next=Some(b);(a,b)
[13:55:53] -rusti- application terminated abnormally with signal 9 (Killed)
[13:55:59] <dbaupp> for &str and &[] it's because `str` and `[]` aren't standalone types.
[13:56:04] <dbaupp> ChrisMorgan: yeah? cycles?
[13:56:42] <ChrisMorgan> Yeah. Cycles. Ain't the managed pointers supposed to be able to cope with that? Is that any excuse for it immediately guzzling all the memory it can lay its mitts on?
[13:56:49] <dbaupp> ChrisMorgan: also, once you start using transmute, it's you're own fault.
[13:56:52] <Sergio965> So what I'm trying to do now is have a structure with a borrowed pointer in it.
[13:56:55] <ChrisMorgan> Sure, I used transmute. That's part of the fun!
[13:57:03] <dbaupp> ChrisMorgan: (the memory guzzling is trying to print it.)
[13:57:10] <Sergio965> But, when I tried to do that the way I thought it would work, it told me I couldn't use anonymous lifetimes.
[13:57:22] <dbaupp> rusti: struct X { prev: Option<@X>, next: Option<@X>, tag: ~str }let a=@mut X{prev:None,next:None,tag:~"a"};let b=@X{prev:Some(unsafe{::std::cast::transmute(a)}), next:None,tag:~"b"};a.next=Some(b); print("don't print a cycle");
[13:57:23] -rusti- don't print a cycle()
[13:57:26] <ChrisMorgan> Ah! Of course. Note to self: don't use fmt! for a recursive structure!
[13:57:36] <dbaupp> *cyclic structure
[13:57:42] * ChrisMorgan was just about to correct that
[13:57:59] <dbaupp> Sergio965: yes, you need to have the <'self> { ... &'self type ... } lifetime
[13:58:05] <Sergio965> So I tried doing like struct Thing<'self> { some: 0xDEADBEEF as &'self somethingelse }.
[13:58:12] <ChrisMorgan> Ah well, that rather rapid stack exhaustion freed up some memory by shifting it into swap.
[13:58:27] <dbaupp> Sergio965: in the struct definition?
[13:58:31] <Sergio965> Yeah
[13:58:36] <Sergio965> Is that not right?
[13:58:39] <dbaupp> with the constant?
[13:58:44] <Sergio965> Yeah.
[13:58:46] <dbaupp> and the cast?
[13:58:47] <Sergio965> Well, a different one.
[13:58:49] <Sergio965> Yes!
[13:58:51] <Sergio965> Lol
[13:59:17] <dbaupp> you're declaring a type, not constructing a value of that type, so it's just types that go in the `struct Thing<'self> { some: &'self somethingelse }`
[13:59:28] <dbaupp> (i.e. what I just wrote.)
[13:59:30] <Sergio965> Oh
[13:59:33] <Sergio965> Sorry, no constant.
[13:59:34] <Sergio965> My bad.
[13:59:38] <dbaupp> then, when you construct a thing of type Thing
[13:59:39] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[13:59:53] <Sergio965> I did struct Thing<'self> { some: &'self somethingelse }
[13:59:56] *** Quits: yong (chatzilla@89F941DF.4E87ADC2.263D9828.IP) (Ping timeout)
[14:00:06] <Sergio965> Now I don't know how to implement it.
[14:00:14] <dbaupp> you can write `Thing { some: some_borrowed_pointer }` and the compiler will automatically connect the lifetime of that value to the lifetime of `some_borrowed_pointer`
[14:00:17] <dbaupp> "implement it"?
[14:00:18] *** Joins: yong (chatzilla@89F941DF.4E87ADC2.263D9828.IP)
[14:00:20] <Sergio965> impl<'self> &'self Thing?
[14:00:26] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[14:00:32] <dbaupp> nope, `impl<'self> Thing<'self>`
[14:00:32] <ChrisMorgan> Sergio965: one example I have is http://hg.chrismorgan.info/rusthttpserver/file/a889c24b3f84/src/librusthttpserver/response.rs#l23
[14:00:46] <ChrisMorgan> There the ResponseWriter has a &'self Response
[14:00:56] <Sergio965> Interesting.
[14:01:12] <Sergio965> dbaupp: Why on both the impl and the Thing?
[14:01:25] <dbaupp> the <'self> is just declaring the lifetime
[14:01:34] <jedestep> it would work similar with a generic
[14:01:40] <jedestep> `impl<T> Thing<T>`
[14:01:43] <dbaupp> just like generics have to be declared for impl<T> Foo<T>
[14:02:02] <ChrisMorgan> Frankly, the <'self> stuff feels like it should be culled and allowed as implicit.
[14:02:13] <dbaupp> ChrisMorgan: 'self shouldn't be "self"
[14:02:28] <ChrisMorgan> dbaupp: ?
[14:02:36] <dbaupp> it's a bug that it can only be called "self", and we need multiple lifetime parameters anyway
[14:02:47] <Sergio965> dbaupp: Ah, that makes sense.
[14:02:50] <dbaupp> (and sometime you want to use the 'self in the functions of the impl)
[14:02:54] <dbaupp> *sometimes
[14:02:57] *** Quits: thpickert (thpickert@moz-24816453.tng.de) (Ping timeout)
[14:03:02] <jedestep> so you should be able to do `impl<'a> Foo<'a>`?
[14:03:06] <dbaupp> yeah
[14:03:13] <jedestep> that would be quite nice
[14:03:26] <dbaupp> or impl<'a, 'b> Foo<'a, 'b> { .. } if Foo has multiple borrowed pointers
[14:03:37] <ChrisMorgan> Note also by contrast http://hg.chrismorgan.info/rusthttpserver/file/a889c24b3f84/src/librusthttpserver/request.rs#l22 which in its new method _doesn't_ use 'self but instead 'a
[14:03:47] <jedestep> that I think would actually solve some issues I ran into long ago
[14:03:58] *** Quits: bheylin (brianheyli@moz-3D24C757.static.chello.nl) (Quit: bheylin)
[14:04:02] *** Quits: Blei (philipp@moz-650B9C6A.cust.bluewin.ch) (Quit: WeeChat 0.4.1)
[14:04:06] <nmatsakis> I hope to fix that very soon
[14:04:11] <jedestep> much better flexibility
[14:04:12] <nmatsakis> the "special" treatment of 'self
[14:04:18] <jedestep> :D
[14:04:20] <dbaupp> nmatsakis: awesome!
[14:04:21] <ChrisMorgan> That latter may be ideologically better... but it makes the whole 'self thing on the impl block seem an utter waste of time.
[14:04:26] <Sergio965> Why don't you need to do something like struct<'self> Thing<'self>?
[14:04:40] <dbaupp> ChrisMorgan: in what way?
[14:04:59] <ChrisMorgan> dbaupp: impl<'self> Foo<'self> { ... never refer to 'self again ... }
[14:05:09] <nmatsakis> Sergio965: you do need that, if Thing contains borrowed pointers...
[14:05:19] <dbaupp> nmatsakis: no you don't
[14:05:29] <nmatsakis> dbaupp: you...should
[14:05:32] <dbaupp> nmatsakis: not on the struct declaration itself?
[14:05:37] <nmatsakis> oh, you're right
[14:05:44] <nmatsakis> you need to declare struct thing<'self> tho
[14:06:01] <dbaupp> ChrisMorgan: that'd be too special case-y, I guess.
[14:06:18] * dbaupp doesn't really know, or particularly care about writing a few extra lifetimes
[14:06:18] *** Quits: BitPuffin (quassel@moz-4DE4682C.mobile.tre.se) (Ping timeout)
[14:06:19] <nmatsakis> Sergio965: the reason you need the parameters on the *impl* is because it's the impl that is parameterized, the type is a type reference, vs in the struct, it's a type def'n
[14:06:38] <nmatsakis> for example, if you wrote:
[14:06:43] <nmatsakis> impl Foo<'static> { ... }
[14:06:52] <nmatsakis> is that a reference to the static lifetime, or equivalent to:
[14:06:56] <nmatsakis> impl<'static> Foo<'static> { ... }
[14:07:07] <nmatsakis> a bit artificial, granted, but that's the motivation---
[14:07:19] <nmatsakis> I guess given that you can't declare named lifetimes in global scope,
[14:07:29] *** Joins: Guest (textual@BBE7C46A.B4F11D08.8612FA94.IP)
[14:07:38] <nmatsakis> we could just say that there is implicit parameterization
[14:07:48] <ChrisMorgan> I really don't see why we _need_ the 'self on the impl block, when you may then not use it at all and instead specify them at the fn level.
[14:07:50] <dbaupp> rusti: struct Foo<'self>(&'self int); impl<'static> Foo<'static> { fn x(&self) {} } let y = 1; let foo = Foo(&y); foo.x()
[14:07:51] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/XHiX
[14:08:30] <Sergio965> nmatsakis: That seems like a silly reason...
[14:08:55] <nmatsakis> Sergio965: in general, we wanted the rule you must declare every named lifetime somewhere.
[14:09:07] <nmatsakis> Sergio965: and the impl is the logical place to declare it, just like a named type parameter.
[14:09:16] <Sergio965> nmatsakis: But why not do it for struct<'s> too?
[14:09:21] <nmatsakis> Sergio965: that IS a declaration
[14:09:34] <nmatsakis> Sergio965: think of struct Foo<T> { .. .}
[14:09:45] <nmatsakis> Sergio965: impl Foo<T> { ... } 
[14:09:48] <nmatsakis> is T a type or not?
[14:10:02] <nmatsakis> that is, a concrete type or a type parameter
[14:10:12] <nmatsakis> lifetime and type parametesr are completely analogous
[14:10:15] <dbaupp> ChrisMorgan: you realise that sometimes you do (have to) use the 'self in the impl functions, right? (just checking :) )
[14:10:22] <dbaupp> ChrisMorgan: e.g. https://github.com/mozilla/rust/blob/master/src/libstd/str.rs#L972-L979
[14:11:35] <ChrisMorgan> I hadn't thought of that, actually. Makes sense.
[14:12:27] <dbaupp> more examples, if you want them https://github.com/mozilla/rust/blob/master/src/libstd/str.rs#L1131-L1195
[14:12:58] <ChrisMorgan> Returning to my earlier point of `fn new<a>(...) -> &'a X` vs. `fn new(...) -> &'self X`, it seems to me that once you have impl<'self> X<'self>, it makes sense to use 'self rather than defining that new 'a‚Äîif indeed the two are equivalent.
[14:13:00] <cmr> Sergio965: you're parameterizing the implementation, is hopw I think of it.
[14:13:06] <cmr> *how
[14:13:06] <dbaupp> most of those can actually be converted to <'a>(&'a self) -> &'a str locally, but then "region inference" blows up when you actually try to use them :(
[14:13:31] <Sergio965> cmr: I think that's the way to think of it, yeah.
[14:13:43] <nmatsakis> (that is precisely what you're doing)
[14:14:05] *** Quits: jaen (jaen@moz-8D59F623.neoplus.adsl.tpnet.pl) (Ping timeout)
[14:14:22] <Sergio965> Wasn't there a var keyword before?
[14:14:31] <Sergio965> Or am I just imagining things?
[14:14:55] <dbaupp> nmatsakis: is 'a ever not a subregion of 'self in `impl &'self T { fn foo<'a>(&'a self) -> &'a U }`?
[14:15:22] <dbaupp> (or T<'self>, whatever.)
[14:15:28] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[14:15:29] <Sergio965> Also, why is the type of a character in a string u8 and not char?
[14:15:40] <cmr> Sergio965: that isn't the type of a character
[14:15:49] <cmr> Strings are sequences of utf-8 codepoints.
[14:16:10] <dbaupp> Sergio965: are you meaning when you write foo[x]?
[14:16:18] <Sergio965> Yeah
[14:16:31] <cmr> that's a byte index, not a codepoint index
[14:16:42] <dbaupp> yeah, that's just leaking the abstraction that str is a vector of u8 in the background
[14:16:58] <dbaupp> if you want to handle characters, you have to call some methods
[14:17:21] <Sergio965> Oh.
[14:17:31] <dbaupp> e.g. char_at(bytes_index)
[14:17:39] <Sergio965> So Rust took the opposite approach that Go took? :P
[14:17:50] *** jyeo_away is now known as jyeo
[14:17:56] <dbaupp> what's Go do for foo[x]?
[14:18:03] <cmr> rune I think
[14:18:03] <bstrie> Sergio965: `char` in rust is u32
[14:18:15] <Sergio965> Yeah, rune.
[14:18:20] <cmr> Someone brought to my attention that codepoint indexing isn't very useful
[14:18:23] <cmr> which is a good point
[14:18:28] <Sergio965> bstrie: Thanks, that clears a couple of things up.
[14:18:31] <cmr> You almost never want to be manipulating a string yourself
[14:18:42] <cmr> Sergio965: (UCS-4 codepoint, to be specific)
[14:18:54] <bstrie> do we actually enforce that chars are unicode?
[14:18:57] <dbaupp> Sergio965: that's a O(n) operation, btw.
[14:19:00] <dbaupp> bstrie: nope
[14:19:03] <cmr> bstrie: in some contexts
[14:19:09] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[14:19:09] <cmr> But that's the intent
[14:19:10] <dbaupp> bstrie: it's another one of strcat's pet hates
[14:19:13] <Sergio965> dbaupp: What is? Getting the next codepoint?
[14:19:24] <dbaupp> rusti: 0x2000000 as char
[14:19:26] -rusti- '\U02000000'
[14:19:29] <engla> Sergio965: .iter() will iterate over the char in the string
[14:19:38] <cmr> Sergio965: no, char_at
[14:19:40] <dbaupp> Sergio965: yeah, indexing by code point is O(n) with utf8
[14:19:40] <Sergio965> engla: I don't have access to the rust library.
[14:19:50] <strcat> chars are broken just like bools
[14:19:50] <Sergio965> cmr: dbaupp: Yeah, makes sense.
[14:20:05] <dbaupp> strcat: perfectly timed :P
[14:20:06] <Sergio965> Variable width encodings are no fun.
[14:20:17] <strcat> Sergio965: all unicode is variable-width
[14:20:24] <Sergio965> strcat: They're all no fun.
[14:20:24] <engla> Sergio965: without a library, str is just another name for [u8].
[14:20:28] <strcat> utf32 is too - code points are a variable width encoding of graphemes
[14:21:14] <Sergio965> Why not just have a 32-bit character encoding?
[14:21:14] <strcat> Sergio965: well if you made a 64-bit fixed-width encoding maybe it would work ;p
[14:21:20] <strcat> Sergio965: because 32-bit isn't enough
[14:21:23] <Sergio965> 2^32 characters seems like enough...
[14:21:27] <strcat> Sergio965: it's not.
[14:21:30] <Sergio965> No?
[14:21:33] <strcat> combining characters can be mixed with anything
[14:21:36] <cmr> Sergio965: what about the combinatorial explosion of combining characters?
[14:21:50] <strcat> well it's actually an infinite explosion
[14:21:53] <strcat> since you can use N
[14:21:59] <strcat> but you could make an encoding with an upper bound
[14:22:01] <dbaupp> strcat: I'm pretty sure 64bits isn't enough, cause you can just keep throwing arbitrarily many combining characters at it
[14:22:03] <Sergio965> Who combines characters?
[14:22:07] <dbaupp> yeah, you just said that
[14:22:10] <bstrie> strcat: how are bools broken, beyond being u8 rather than u1?
[14:22:13] <strcat> Sergio965: people who use languages you need to support
[14:22:17] <strcat> in a universal encoding
[14:22:19] <Sergio965> strcat: Lol.
[14:22:20] <Sergio965> Yeah.
[14:22:31] <cmr> bstrie: non-canonical bools
[14:22:33] <Sergio965> Alright, 128 bits!
[14:22:37] <bstrie> cmr: ?
[14:22:40] <cmr> rusti: let x = 5 as bool; (x, x == true)
[14:22:41] -rusti- (true, false)
[14:22:48] <strcat> dbaupp: because it's i8
[14:22:49] <dbaupp> Sergio965: there's an infinite number of characters possible
[14:22:51] <strcat> err
[14:22:53] <strcat> bstrie: 
[14:22:53] <dbaupp> strcat: ?
[14:22:56] <dbaupp> oh
[14:23:01] <Sergio965> dbaupp: There can't be more than 2^128 that are actually useful!
[14:23:08] <strcat> bstrie: it's supposed to be *stored* as i8 and treated as i1 after loading
[14:23:08] <cmr> Sergio965: useful to who!
[14:23:09] <dbaupp> Sergio965: doesn't matter
[14:23:14] <bstrie> ok
[14:23:16] <dbaupp> Sergio965: they're still valid
[14:23:28] <cmr> Sergio965: unicode's purpose is to be universal
[14:23:32] <strcat> I think we could even treat char as i21
[14:23:36] <cmr> if you don't want that... use ascii
[14:23:52] <bstrie> strcat: does llvm have a i21 type?
[14:24:07] <strcat> bstrie: it has arbitrarily sized integer types
[14:24:16] <bstrie> nifty
[14:24:39] <strcat> anyway char shouldn't have add, sub, etc.
[14:24:55] <dbaupp> Sergio965: there's approximately 240 combining characters
[14:25:02] *** Quits: yong (chatzilla@89F941DF.4E87ADC2.263D9828.IP) (Connection reset by peer)
[14:25:10] <dbaupp> so 2^240 subsets of those characters
[14:25:24] *** Joins: yong (chatzilla@89F941DF.4E87ADC2.263D9828.IP)
[14:25:26] <Sergio965> So, 256 bits?
[14:25:27] <bstrie> strcat: I'd approve a PR that removed add, sub, etc from chars :)
[14:25:33] <Sergio965> :D
[14:25:42] <strcat> dbaupp: but you can add each one N times
[14:25:44] <dbaupp> Sergio965: and that's not counting for having multiple of one combining character on a single thing
[14:25:47] <dbaupp> strcat: yes
[14:25:55] <strcat> there's no upper bound on how many times you can add it
[14:25:59] <dbaupp> yes
[14:26:12] <strcat> Sergio965: http://eeemo.net/ this just uses a bunch of combining chars
[14:26:49] <Sergio965> That's insane.
[14:27:00] *** Quits: yong (chatzilla@89F941DF.4E87ADC2.263D9828.IP) (Connection reset by peer)
[14:27:10] <dbaupp> <3 unicode
[14:27:12] <cmr> I agree. Silly non-english speakers and their sillyness.
[14:27:22] *** Joins: yong (chatzilla@89F941DF.4E87ADC2.263D9828.IP)
[14:27:27] <Sergio965> I mean, insane as in cool.
[14:27:32] <Sergio965> Not as in mentally challenged...
[14:27:39] <cmr> But what would we do without http://www.fileformat.info/info/unicode/char/1f4a9/index.htm ?
[14:27:40] * dbaupp wh√§cks cmr
[14:27:43] <bstrie> you've never seen zalgo before?
[14:27:48] <Sergio965> I've not.
[14:28:25] <engla> cmr: don't be na√Øve
[14:28:51] <cmr> I ammend my statement: stupid non-my-subset-of-english
[14:28:55] <bstrie> Sergio965: see the first answer on http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags
[14:30:34] <Sergio965> That's fantastic.
[14:32:46] *** Joins: nano (nano@moz-972880B.superkabel.de)
[14:35:12] <Sergio965> What is the new TY_Vistory stuff in Rust?
[14:35:14] <Sergio965> Visitor*
[14:36:16] <strcat> TyVisitor just walks types at runtime, it's reflection
[14:36:20] <strcat> fmt!'s %? uses it
[14:37:24] *** Parts: mvalzelli (mvalzelli@moz-9E064543.ip2.fastwebnet.it) (Quitting)
[14:37:31] *** Quits: dherman (dherman@1A20C896.96FE09F3.3002A442.IP) (Quit: dherman)
[14:38:25] *** Quits: StarLight (StarLight@moz-5295E00D.dynamic.avangarddsl.ru) (Ping timeout)
[14:40:54] *** Joins: thpickert (thpickert@moz-34341F25.dynamic.dsl.tng.de)
[14:41:22] *** Joins: yong_ (chatzilla@89F941DF.4E87ADC2.263D9828.IP)
[14:41:30] *** Quits: yong (chatzilla@89F941DF.4E87ADC2.263D9828.IP) (Ping timeout)
[14:41:34] *** yong_ is now known as yong
[14:42:20] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[14:42:37] *** Joins: StarLight (StarLight@moz-6063D8AE.pppoe.avangarddsl.ru)
[14:44:07] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[14:45:32] *** Joins: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP)
[14:49:06] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[14:51:54] *** Joins: echristo_ (echristo@60A74940.D6CCE4AE.77834EAA.IP)
[14:51:57] *** Joins: lmandel (lmandel@94C96733.C1F57925.ADB88A9.IP)
[14:52:19] *** Quits: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net) (Ping timeout)
[14:52:19] *** echristo_ is now known as echristo
[14:52:20] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[14:53:57] <bstrie> rusti: let (mut x, mut y) = (1,2); x = 3; x
[14:53:58] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/jUUK
[14:54:12] <bstrie> rusti: let mut (x, y) = (1,2); x = 3; x
[14:54:13] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/Mdci
[14:54:25] <kimundi> bstrie: Neither is possible atm :(
[14:54:39] <bstrie> bleh
[14:54:48] *** Quits: Guest (textual@BBE7C46A.B4F11D08.8612FA94.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz‚Ä¶)
[14:55:19] <bstrie> really makes it a hassle to assign values from this function that returns a tuple
[14:55:26] *** Quits: tav (tav@moz-C9F0879A.range86-145.btcentralplus.com) (Quit: tav)
[14:55:29] <bstrie> I have to match and then manually assign
[14:55:40] <kimundi> yeah, but the first one will hopefull work soon
[14:55:50] <bstrie> how soon is soon? :)
[14:56:06] * bstrie checks the bors queue
[14:56:08] <cmr> before 0.8? :)
[14:56:14] <kimundi> prior to the 1.0 release?
[14:56:17] <kimundi> :P
[14:56:35] <kimundi> wrong choice of words on my side
[14:57:09] *** Joins: kesserich (Mibbit@moz-ACED0D3F.phlapa.fios.verizon.net)
[14:57:55] <kesserich> hey, i have a general questions.  Is there any technical reason why only owned vectors can have indefinite size and allow you to push/pop elements?
[14:58:13] <strcat> because fixed-size vectors are in a fixed-size slot on the stack
[14:58:20] <strcat> and managed vectors have multiple owners
[14:58:20] <kimundi> kesserich: Two different issues
[14:58:21] <Sergio965> Do managed vectors not let you?
[14:58:26] <strcat> they don't
[14:58:34] <cmr> sigma: @[] is immutable
[14:58:36] <strcat> a reallocation will likely change the location of the data
[14:58:42] <strcat> @mut [] can't support push
[14:58:51] <strcat> you need @mut ~[T]
[14:59:00] *** Quits: doener (bs@moz-AA189A5A.unitymedia.biz) (Quit: leaving)
[14:59:04] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[14:59:04] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/jkneBg
[14:59:04] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[14:59:37] <cmr> erm, Sergio965
[14:59:50] * kimundi thinks it's interesting how rust gives you building blocks for things that are primitve datatypes in other languages
[15:00:15] *** Quits: sebcrozet (sebcrozet@moz-7FB6C00B.w193-252.abo.wanadoo.fr) (Ping timeout)
[15:00:43] <Sergio965> cmr: How about @mut []?
[15:00:44] <kimundi> javas T[] == Rusts @mut~[T]
[15:01:09] <kimundi> Sergio965: allows you to mutate the content, but not change the size
[15:01:34] <strcat> Sergio965: if you pushed an element to @mut [T] and it had to reallocate, all but one pointer would now be dangling
[15:01:46] <kesserich> strcat: managed vectors may have multiple owners but they are restricted to one task right?  You can't concurrently have multiple tasks access the same managed vector right?
[15:01:53] <kesserich> because you can't send managed vectors to other tasks
[15:01:57] <strcat> right
[15:02:02] <cmr> kesserich: but you can still have other references to it.
[15:02:08] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[15:02:08] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/sfDdJw
[15:02:08] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[15:02:09] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[15:02:09] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/LTnOSQ
[15:02:09] <ghrust> 13rust/06auto 147cc8f4b 15G√°bor Horv√°th: Added some more atomic operations.
[15:02:09] <ghrust> 13rust/06auto 1415ab6fd 15bors: auto merge of #8039 : Xazax-hun/rust/master, r=brson...
[15:02:10] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[15:02:23] *** Joins: yonran (yonran@moz-962F33EB.acuitus.com)
[15:03:33] *** Quits: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au) (Quit: gavinb)
[15:03:39] *** Joins: sebcrozet (sebcrozet@moz-6DA639AF.w80-13.abo.wanadoo.fr)
[15:05:26] *** Joins: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com)
[15:06:13] *** Joins: msingle1 (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[15:06:21] *** Quits: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Ping timeout)
[15:07:42] *** Joins: jaen (jaen@moz-D81D6E4C.play-internet.pl)
[15:08:33] <kesserich> cmr: oh, and those references may become invalidated because resizing the vector may cause the entire struct to be reallocated to another address?
[15:08:57] <kimundi> kesserich, yes
[15:09:40] <kesserich> gotcha. thanks :)
[15:09:47] *** Joins: tchoma (tchoma@moz-E58E29CC.dsl.static.sonic.net)
[15:10:04] <cmr> kesserich: which is a flaw in ~[] and @mut [], IMO. I would imagine it'd be struct VecRepr<T> { fill: uint, alloc: uint, data: *T }
[15:10:15] <cmr> but it's a weird unsized thing
[15:10:36] <dbaupp> rusti: @mut [1,2]
[15:10:37] <kimundi> cmr: Define flaw
[15:10:37] -rusti- @mut [1, 2]
[15:10:52] <cmr> kimundi: "less than ideal thing"
[15:10:55] *** Joins: libertas (libertas@moz-6F68A62F.net.novis.pt)
[15:11:31] <kimundi> well, I'd argue it's better than not having them :P "inconvenient" - yes
[15:11:47] <cmr> I'm not saying we shouldn't have them
[15:12:05] <cmr> it's just not the choice I would have made for semantics and implementation
[15:12:28] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[15:12:55] *** Joins: Guest (textual@BBE7C46A.B4F11D08.8612FA94.IP)
[15:13:01] <cmr> downside of pointer-to-allocation is double indirection
[15:14:24] <kimundi> Yeah. I really like that we don't have that unsized thing, though. It just needs to get properly integrated in the type system somehow.
[15:15:02] <kimundi> don't have that double indirection*
[15:15:03] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[15:15:24] <Sergio965> Compiling Rust with -j 8 makes my macbook fans go crazy.
[15:15:35] <cmr> Sergio965: are you building LLVM?
[15:15:36] *** Quits: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net) (Ping timeout)
[15:15:43] *** Joins: tjc (tjc@moz-F1AF44B2.tmodns.net)
[15:15:43] *** ChanServ sets mode: +o tjc
[15:15:50] <Sergio965> It builds it automatically, no?
[15:15:52] <kimundi> Sergio965: That's funny, seeing how -j doesn't do anything for Rust ;)
[15:16:01] <cmr> if it needs to
[15:16:04] <Sergio965> kimundi: I imagine it's LLVM.
[15:16:17] <kimundi> (The c++ llvm build on the other hand...)
[15:17:06] <jedestep> I don't suppose there's a function somewhere (in std::os maybe?) to return the current PID
[15:17:48] <cmr> jedestep: not cross-platform yet no
[15:17:56] <jedestep> :(
[15:18:02] <cmr> rusti: std::libc::getpid()
[15:18:02] -rusti- <anon>:7:9: 8:5 error: call to unsafe function requires unsafe function or block
[15:18:02] -rusti- <anon>:7          std::libc::getpid()
[15:18:03] -rusti- <anon>:8     };
[15:18:03] -rusti- error: aborting due to previous error
[15:18:03] -rusti- application terminated with error code 101
[15:18:07] <cmr> rusti: unsafe { std::libc::getpid() }
[15:18:09] -rusti- 1
[15:18:16] <jedestep> close enough
[15:18:17] <cmr> strcat: heh, is that a result of namespacing?
[15:18:24] <cmr> PID namespacing that is
[15:18:59] <doomlord> did you consider alternative symbols for ' for lifetimes ... (confuses existing tools that know c-like syntax with string/char literals ) .. not a killer but .. :)
[15:19:24] *** Quits: Sergio965 (sergiobz@moz-BB21156B.dynamic.csail.mit.edu) (Ping timeout)
[15:19:31] *** Joins: Sergio965 (sergiobz@moz-8D70E596.wireless.csail.mit.edu)
[15:19:52] <doomlord> probably too hard to change now
[15:20:05] <kimundi> doomlord: There was a big bikeshedding for that
[15:20:31] <kimundi> doomlord: For context: Before it was like ', but with / instead
[15:20:40] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[15:21:08] <doomlord> my argument would have been that youwant to leverage as much off the shelf  source manipulation tools as possible, but i'm sure you had a good reason
[15:21:15] <kimundi> doomlord: One big contender was putting them in {}, like: &{a} Foo. Sadly that was not agreeable with the grammar
[15:21:16] <doomlord> did it simplify the gramar in other ways perhaps
[15:22:42] <kimundi> doomlord: It came down to the problem that rust has more annotable things than suitable ascii symbols
[15:23:34] <cmr> (And the ML-like syntax is aesthetically pleasing IMO)
[15:23:41] *** Joins: bheylin (brianheyli@837B6557.E7BADBF1.B0C2132F.IP)
[15:23:44] <engla> &{a} is really hard to type, happy it didn't turn out that way
[15:24:00] *** Quits: qmx (qmx@moz-D6C3C2E6.qmx.me) (Ping timeout)
[15:24:52] <kimundi> Maybe the backtick could have been used...: &`a Foo
[15:25:01] <kimundi> but.. meh
[15:25:05] <bstrie> no backticks
[15:25:06] <kimundi> It's fine as it is
[15:25:18] <cmr> no backticks
[15:25:21] <bstrie> makes it impossible to embed in markdown, and it's indistinguishable from apostrophes
[15:25:21] <cmr> needed for markdown
[15:25:40] <bstrie> the latter point is why python3 dropped backticks from the grammar
[15:26:02] <kimundi> So, no let x = 14 `xor` 23; ? )
[15:26:07] <kimundi> ;)
[15:26:12] <doomlord> not so keen on that in haskell
[15:26:29] <bstrie> I presume that haskell doesn't use apostrophes anywhere?
[15:26:34] <engla> bstrie: and ` is not easily accessible on some keyboard layouts
[15:26:39] <bstrie> like, I can't imagine they would have a use for char literals
[15:26:43] <cmr> engla: like ~ is :p
[15:26:46] <sp3d> Haskell uses 'a' for char literals still
[15:26:46] <engla> right
[15:26:56] <bstrie> weird
[15:27:00] *** Quits: msingle1 (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Client exited)
[15:27:04] <engla> haskell allows ' in identifiers
[15:27:06] <kimundi> People just need to swich to sensible keyboard layouts :P
[15:27:09] <sp3d> ah, that too
[15:27:11] <doomlord> i think i tried to assume in my 'unfold' tool that char literals were one or 2 characters , anything longer is sourcecode...
[15:27:21] <cmr> SiegeLord pointed out that to do "user defined operators" they use expr /expr/ expr
[15:27:40] <cmr> So like 1 /xor/ 3
[15:27:48] <engla> so infix functions
[15:27:54] <doomlord> 'x' is a char literal, '\z' is a char literal, any other use of ' is a lifetime
[15:27:56] *** Quits: Guest (textual@BBE7C46A.B4F11D08.8612FA94.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz‚Ä¶)
[15:28:07] <cmr> xor being some weird static that overloads division operator and returns another thing which overloads division which results in the end result
[15:28:10] *** Joins: qmx (qmx@moz-D6C3C2E6.qmx.me)
[15:28:14] <bstrie> doomlord: '\u0020' is a char literal
[15:28:19] <sp3d> '\x and \u and \U are also... yeah
[15:28:19] <cmr> rusti: '\x20'
[15:28:20] -rusti- ' '
[15:28:24] <doomlord> right i'm sure i still hve edge case bugs from it
[15:28:48] <cmr> it's an easy fix; if it's 1 character or starts with \ it's a char literal
[15:28:50] <doomlord> ok, 'x' is a char literal, '\....' is a char literal , that'll fix it
[15:28:59] <doomlord> ok sure
[15:29:08] <bstrie> rusti: '\u0097'
[15:29:08] -rusti- '\x97'
[15:29:19] <bstrie> is \x just for ascii?
[15:29:43] <sp3d> rusti: '\xff'
[15:29:44] <engla> probably not?
[15:29:44] -rusti- '\xff'
[15:29:45] <doomlord> its only javascript where they can use '....' for strings as well s char literals i guess
[15:29:57] <bstrie> doomlord: and python
[15:30:05] <doomlord> ok 2 evil cases
[15:30:07] <bstrie> in perl and bash and php they have slightly different semantics
[15:30:13] <bstrie> which imo is even worse :)
[15:30:27] <bstrie> I can never remember which one does which
[15:30:49] <sp3d> languages should always use double quotes for strings, because you need more lines to hold more characters ;)
[15:31:37] <bstrie> rusti: 'a'.to_str()
[15:31:37] -rusti- <anon>:7:9: 8:5 error: type `char` does not implement any method in scope named `to_str`
[15:31:37] -rusti- <anon>:7          'a'.to_str()
[15:31:37] -rusti- <anon>:8     };
[15:31:38] -rusti- error: aborting due to previous error
[15:31:38] -rusti- application terminated with error code 101
[15:32:02] <bstrie> rusti: [1].to_str()
[15:32:03] -rusti- ~"[1]"
[15:32:17] <bstrie> rusti: printfln!([1].to_str());
[15:32:18] -rusti- ~"[1]"
[15:32:18] -rusti- ()
[15:32:25] <bstrie> rusti: printfln!([1]);
[15:32:26] -rusti- [1]
[15:32:26] -rusti- ()
[15:32:44] <bstrie> so it's using %?
[15:32:45] <doomlord> so i 'm guessing & couldnt be follows by any other  symbol to keep the gramr simple, thats the bigger win overall
[15:32:46] <bstrie> that seems bad
[15:32:56] *** Quits: qmx (qmx@moz-D6C3C2E6.qmx.me) (Ping timeout)
[15:33:03] <bstrie> unless it's actually calling to_str(), maybe
[15:33:07] <bstrie> rusti: printfln!('a');
[15:33:08] -rusti- 'a'
[15:33:08] -rusti- ()
[15:33:15] <cmr> doomlord: &mut
[15:33:17] <cmr> &const
[15:33:19] <cmr> &T
[15:33:22] <kimundi> The rules for char literals are easy:
[15:33:31] <cmr> oh unless by symbol you mean like, character symbo
[15:33:33] <cmr> l
[15:33:38] <bstrie> doomlord: &~T
[15:33:45] <kimundi> "One unicode code point, either embedded as utf8 ore encoded as escaped string"
[15:33:52] <bstrie> &[foo]
[15:33:55] <kimundi> rusti: 'œÄ'
[15:33:56] -rusti- '\u03c0'
[15:33:59] <bstrie> &(1,2)
[15:34:07] <doomlord> right character symbol. like &-lifetime my_object
[15:34:09] <bstrie> &{1}
[15:35:05] <engla> and even &|| 
[15:35:52] <doomlord> ok i can fix my unfold tool  for any length escaped literals, and it will only break with JS source that puts braces in 'strings'
[15:36:15] <doomlord> which i for one never do :)
[15:36:26] <strcat> cmr: yes
[15:36:30] <strcat> cmr: it has a pid namespace so it's pid 1
[15:36:31] *** Quits: bheylin (brianheyli@837B6557.E7BADBF1.B0C2132F.IP) (Quit: bheylin)
[15:36:41] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[15:36:42] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[15:37:11] *** Joins: qmx (qmx@moz-D6C3C2E6.qmx.me)
[15:37:13] <strcat> cmr: /proc can lie however it pleases ;p
[15:37:13] *** Quits: tchoma (tchoma@moz-E58E29CC.dsl.static.sonic.net) (Quit: My MacBook has gone to sleep. ZZZzzz‚Ä¶)
[15:37:19] <strcat> although it's not really a lie
[15:37:26] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[15:37:58] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[15:38:11] <strcat> cmr: also has a new ipc, mount, hostname and net namespace though
[15:38:23] <strcat> mount namespaces were first so that's called CLONE_NEWNS
[15:38:29] *** Joins: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net)
[15:38:33] <strcat> might be a plan9-ism, dunno
[15:39:23] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[15:39:37] <Sergio965> 30 minutes to compile rust. :(
[15:39:51] <Sergio965> 18*
[15:39:52] <cmr> Sergio965: if that's including LLVM, that's a quite impressive time.
[15:39:59] <Sergio965> Really?
[15:40:03] <Sergio965> 18 minutes is impressive? :P
[15:40:05] <cmr> yes.
[15:40:12] <cmr> LLVM takes 40 minutes by itself usually.
[15:40:27] <Sergio965> About 25 minutes total.
[15:40:42] <cmr> ccache?
[15:40:47] <Sergio965> Nope.
[15:40:48] <bstrie> for me, 12 minutes for rustc and 6 minutes for llvm last I checked
[15:40:56] *** Quits: jaen (jaen@moz-D81D6E4C.play-internet.pl) (Ping timeout)
[15:40:56] <Sergio965> bstrie: What are you running?
[15:41:06] <bstrie> building with make -j8
[15:41:10] <Sergio965> I mean, CPU.
[15:41:14] <Sergio965> Ivy?
[15:41:16] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[15:41:17] <bstrie> which uses literally 5GB of mem
[15:41:25] <bstrie> Sergio965: i7 2700K
[15:41:54] <Sergio965> Sandy Bridge, indeed. I'm on a MacBook.
[15:41:55] <cmr> bstrie: 6 minutes of a clean LLVM build?
[15:41:59] <strcat> bstrie: chrt -b 0 make -j24
[15:42:01] <strcat> ;p
[15:42:21] <strcat> you'll run out of memory though
[15:42:31] <bstrie> cmr: yeah, I get basically 800% cpu utilization at all times
[15:42:36] <bstrie> it parallelizes really really well
[15:42:47] <Sergio965> bstrie: make does?
[15:42:54] <bstrie> llvm does
[15:42:54] <cmr> Sergio965: the llvm build does
[15:43:07] <Sergio965> I see. I very rarely had 8 processes running.
[15:43:36] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[15:44:00] *** Joins: ozten (ozten@moz-DD3B00B4.hsd1.wa.comcast.net)
[15:44:04] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[15:46:26] *** Quits: qmx (qmx@moz-D6C3C2E6.qmx.me) (Ping timeout)
[15:46:52] *** Quits: tjc (tjc@moz-F1AF44B2.tmodns.net) (Ping timeout)
[15:46:56] *** Quits: sk (sk@61A494B3.BA40E8A.AAC02D62.IP) (Quit: Leaving)
[15:48:00] *** Quits: nyx114 (nyx114@337D90A6.170C4318.709ED47B.IP) (Ping timeout)
[15:49:04] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[15:49:30] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[15:49:35] *** Joins: nyx114 (nyx114@337D90A6.170C4318.709ED47B.IP)
[15:49:36] *** Joins: tjc (tjc@moz-F1AF44B2.tmodns.net)
[15:49:36] *** ChanServ sets mode: +o tjc
[15:49:48] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Connection reset by peer)
[15:50:13] *** Joins: tchoma (tchoma@moz-E58E29CC.dsl.static.sonic.net)
[15:50:30] *** Joins: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net)
[15:50:31] <cmr> bstrie: huh
[15:50:39] <cmr> chrt -b 0 make -j16 got me a 5 minute build
[15:50:43] *** Joins: qmx (qmx@moz-D6C3C2E6.qmx.me)
[15:51:03] <cmr> I suppose with -j1 or on windows is where it's /really/ slow
[15:51:20] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[15:51:52] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Connection reset by peer)
[15:53:56] *** Joins: mib_4y4rh3 (Mibbit@moz-C48D29C4.cable.teksavvy.com)
[15:53:58] *** Parts: mib_4y4rh3 (Mibbit@moz-C48D29C4.cable.teksavvy.com) ()
[15:54:09] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[15:54:50] *** Joins: int3__ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[15:54:50] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Connection reset by peer)
[15:54:53] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[15:55:01] *** Quits: int3__ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Connection reset by peer)
[15:55:11] <bstrie> cmr: what was it previously?
[15:55:19] <cmr> bstrie: LLVM? no idea
[15:55:31] <cmr> it's like a half hour + on windows on this box
[15:55:32] <bstrie> does chrt -b 0 actually help?
[15:55:51] <cmr> let me measure
[15:56:01] *** Joins: jaen (jaen@moz-D81D6E4C.play-internet.pl)
[15:56:14] <cmr> ...later
[15:56:16] * cmr playing KSP
[15:56:18] <bstrie> also, does it bascially freeze all interactivity for 5 minutes? I'm not certain what "batch mode" implies
[15:56:36] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[15:57:03] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Connection reset by peer)
[15:57:26] *** Quits: noam (noam@F6B530A7.720527A7.416762B.IP) (Ping timeout)
[15:57:41] *** Joins: noam (noam@F6B530A7.720527A7.416762B.IP)
[15:58:35] *** Quits: tchoma (tchoma@moz-E58E29CC.dsl.static.sonic.net) (Quit: My MacBook has gone to sleep. ZZZzzz‚Ä¶)
[15:58:36] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[15:59:01] <strcat> bstrie: no it just tells it those specific processes don't need low latency
[15:59:01] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Connection reset by peer)
[15:59:15] <bstrie> ok
[15:59:15] <strcat> so they get longer time slices when competing with each other
[15:59:31] <strcat> so you can add an extra one or two to make up for I/O wait
[16:00:20] *** Joins: tchoma (tchoma@moz-E58E29CC.dsl.static.sonic.net)
[16:00:36] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[16:00:50] *** Quits: tchoma (tchoma@moz-E58E29CC.dsl.static.sonic.net) (Client exited)
[16:01:24] *** Quits: tjc (tjc@moz-F1AF44B2.tmodns.net) (Quit: zzzzzzzzzz)
[16:01:25] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Connection reset by peer)
[16:01:27] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Connection reset by peer)
[16:02:01] *** Quits: Voomer (Voomer@moz-CC05FF5E.hsd1.wa.comcast.net) (Connection reset by peer)
[16:02:37] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[16:03:17] *** Quits: nyx114 (nyx114@337D90A6.170C4318.709ED47B.IP) (Ping timeout)
[16:03:17] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Connection reset by peer)
[16:03:18] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[16:03:27] *** Joins: nyx114 (nyx114@337D90A6.170C4318.709ED47B.IP)
[16:04:37] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[16:05:27] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Connection reset by peer)
[16:05:41] *** Quits: jaen (jaen@moz-D81D6E4C.play-internet.pl) (Ping timeout)
[16:07:09] *** Joins: Guest (textual@BBE7C46A.B4F11D08.8612FA94.IP)
[16:07:26] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[16:07:53] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Connection reset by peer)
[16:08:21] *** Quits: qmx (qmx@moz-D6C3C2E6.qmx.me) (Ping timeout)
[16:10:14] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[16:11:12] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Connection reset by peer)
[16:11:44] *** Joins: qmx (qmx@moz-D6C3C2E6.qmx.me)
[16:12:14] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[16:13:12] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Connection reset by peer)
[16:14:15] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[16:14:24] *** Joins: pcwalton (pcwalton@moz-A746ED0D.hfc.comcastbusiness.net)
[16:14:24] *** ChanServ sets mode: +o pcwalton
[16:14:59] <toddaaro> I'm looking at the "atomics.rs" file and it looks like each atomic is implemented using an intrinsic in intrinsics.rs, but there don't appear to be implementations in intrinsics.rs, just an extern block and a pile of signatures
[16:15:06] <toddaaro> where are the actual intrinsics pulled from?
[16:15:07] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Connection reset by peer)
[16:15:21] <cmr> toddaaro: llvm
[16:15:28] <cmr> aiui
[16:15:30] <toddaaro> cmr: how are they looked up?
[16:15:39] <toddaaro> do you just "get the name right" and they are located?
[16:15:44] <cmr> toddaaro: pretty sure
[16:15:47] <cmr> not 100% positive
[16:15:51] <toddaaro> that is actually pretty easy sounding
[16:15:53] *** Quits: qmx (qmx@moz-D6C3C2E6.qmx.me) (Ping timeout)
[16:16:12] <toddaaro> this intrinsics.rs file also has a pub trait TyVisitor and I have no idea what that is doing
[16:16:15] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[16:16:45] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[16:16:45] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Connection reset by peer)
[16:17:18] <engla> reflection
[16:17:37] <bstrie> what did .as_bytes_with_null_consume turn into recently?
[16:17:46] *** Joins: qmx (qmx@moz-D6C3C2E6.qmx.me)
[16:17:53] <kimundi> to_byten_with_null
[16:18:01] <kimundi> bytes*
[16:18:06] <bstrie> ok
[16:18:17] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[16:18:48] *** Quits: kesserich (Mibbit@moz-ACED0D3F.phlapa.fios.verizon.net) (Quit: http://www.mibbit.com ajax IRC Client)
[16:18:48] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Connection reset by peer)
[16:19:22] <toddaaro> hm Aatch isn't around
[16:19:26] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[16:19:29] <strcat> toddaaro: they're implemented in the compiler
[16:19:38] <toddaaro> strcat: the intrinsics?
[16:19:40] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[16:19:42] <strcat> yes
[16:20:13] <strcat> librustc/middle/trans/foreign.rs
[16:20:42] <toddaaro> ok, so to add a new one I would edit the same files as Aatch's PR?
[16:20:50] <strcat> don't know which PR that is
[16:21:14] <toddaaro> he has a PR with "all the remaining atomics" but I can't find a memory fence / barrier / thingy anywhere
[16:21:15] <cmr> Oh wow was I wrong
[16:21:32] <cmr> I even knew about that massive table in trans_intrinsic too
[16:22:09] <strcat> intrinsics are basically just a way to expose arbitrary stuff from trans as functions
[16:22:19] <erickt> nmatsakis: glad to hear we're getting rid of the need for the double dispatch for overloading. Is there an issue that's tracking that feature?
[16:23:31] <engla> ok so some of them are simple llvm intrinsics and others are "rust" intrinsics. like  "sqrtf64" => simple_llvm_intrinsic(bcx, "llvm.sqrt.f64", 1)
[16:23:31] <toddaaro> strcat: ok, I'll keep that in mind
[16:23:40] *** Joins: eholk (eholk@moz-E654C98C.uconnect.utah.edu)
[16:23:40] *** Quits: eholk (eholk@moz-E654C98C.uconnect.utah.edu) (Quit: eholk)
[16:24:59] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[16:25:10] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[16:25:25] *** Joins: eholk (eholk@moz-E654C98C.uconnect.utah.edu)
[16:25:39] <toddaaro> looks like what I want is "llvm.memory.barrier"
[16:26:09] *** Joins: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net)
[16:26:50] *** Joins: bnicholson (bnicholson@moz-E98974C1.hsd1.ca.comcast.net)
[16:29:37] *** Joins: tchoma (tchoma@moz-BE33DA21.fw1.sfo1.mozilla.net)
[16:30:53] *** Joins: henrikhodne (henrikhodn@moz-87E975F1.dsl.static.sonic.net)
[16:32:59] <toddaaro> oh, it looks like they changed the name to fence in llvm 3.0, and that does show up quite often under grep
[16:33:16] <toddaaro> it just isn't in the intrinsics.rs file
[16:34:10] *** Joins: jclements (jclements@DA70AF72.E0F991B7.62E7C518.IP)
[16:34:12] <toddaaro> oh but only in the llvm submodule
[16:34:13] <toddaaro> sigh
[16:34:47] *** Joins: tjc (tjc@moz-BE33DA21.fw1.sfo1.mozilla.net)
[16:34:47] *** ChanServ sets mode: +o tjc
[16:35:45] *** Quits: tjc (tjc@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: zzzzzzzzzz)
[16:36:02] *** Quits: qmx (qmx@moz-D6C3C2E6.qmx.me) (Ping timeout)
[16:38:05] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[16:39:27] *** Joins: qmx (qmx@moz-D6C3C2E6.qmx.me)
[16:40:13] <erickt> hey all, does anyone know if there is something special about the 'self region, beyond us requiring 'self to be the only region as part of a type declaration?
[16:40:34] *** Joins: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP)
[16:41:18] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[16:41:34] <erickt> At least for traits, it appears that `trait Foo { fn foo<'a>(&'a self) -> &'a int }` is identical to `trait Foo<'self> { fn foo(&self) -> &'self int }`
[16:42:37] <strcat> erickt: the second example isn't working
[16:42:47] <strcat> 'self isn't implicitly on &self
[16:42:56] <strcat> it's just a no-op
[16:43:24] <strcat> it has to be part of the type you're implementing on to gain meaning
[16:43:25] <erickt> err, `trait Foo<'self> { fn foo(&'self self) -> &'self int }` :)
[16:43:36] <strcat> erickt: ah yeah, there it's just the same
[16:43:42] <strcat> erickt: but I think we should forbid that
[16:43:44] *** Joins: tjc (tjc@moz-BE33DA21.fw1.sfo1.mozilla.net)
[16:43:44] *** ChanServ sets mode: +o tjc
[16:43:48] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[16:43:48] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/LTnOSQ
[16:43:48] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[16:43:50] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[16:43:57] <strcat> erickt: I think it might currently be unsound
[16:44:02] <strcat> because it doesn't force the impl to match
[16:44:30] *** Joins: Nefzaoui (chatzilla@429AD06F.4FBEB140.D9343D67.IP)
[16:44:32] <strcat> it should probably only be allowed on an impl and only if 'self is part of the type definition
[16:46:17] *** Joins: RMF (RMF@moz-6AD5ED61.dsl.telepac.pt)
[16:46:50] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[16:46:50] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/kjHkSA
[16:46:50] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[16:46:52] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[16:46:52] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/hbzYTA
[16:46:52] <ghrust> 13rust/06auto 1475a0862 15Bj√∂rn Steinbrink: Add a function to check whether a ValueRef is a constant
[16:46:52] <ghrust> 13rust/06auto 14e0685e2 15Bj√∂rn Steinbrink: Make omission of impossible if-else branches work with constants...
[16:46:53] <ghrust> 13rust/06auto 147078ab7 15Bj√∂rn Steinbrink: Generate branchless code when "if" can be evaluated at compile time...
[16:46:55] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[16:47:15] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[16:47:56] *** Quits: qmx (qmx@moz-D6C3C2E6.qmx.me) (Ping timeout)
[16:48:20] *** Joins: qmx (qmx@moz-D6C3C2E6.qmx.me)
[16:48:57] *** Joins: rlbaker (rlbaker@moz-C8EE266C.hfc.comcastbusiness.net)
[16:49:29] *** Quits: novabyte (Instantbir@moz-3E0F9699.cable.virginmedia.com) (Quit: bye bye)
[16:49:53] *** Quits: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP) (Ping timeout)
[16:50:57] *** Quits: qmx (qmx@moz-D6C3C2E6.qmx.me) (Ping timeout)
[16:51:03] *** Joins: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP)
[16:53:10] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[16:55:16] *** Joins: qmx (qmx@moz-D6C3C2E6.qmx.me)
[16:55:56] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[16:56:15] *** Joins: devinus (devinus@DAEC7122.372FE49C.29F95E0F.IP)
[16:56:23] <nmatsakis> erickt: those two traits are not identical, and we should not forbid it
[16:56:26] *** Quits: tjc (tjc@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: zzzzzzzzzz)
[16:56:37] <erickt> strcat: yeah, this just seems weird: https://gist.github.com/erickt/6090440
[16:56:40] <nmatsakis> however, they are very similar
[16:56:56] *** Quits: qmx (qmx@moz-D6C3C2E6.qmx.me) (Ping timeout)
[16:57:10] <erickt> good morning nmatsakis :)
[16:57:38] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[16:58:02] <nmatsakis> sometimes it's useful to have a lifetime associated with the trait,
[16:58:12] <nmatsakis> but usually not,
[16:58:23] <nmatsakis> it depends if the things that can implement the trait may have borrowed pointers within them
[16:58:27] <olsonjeffery> i wonder: is the mongodb rust driver building against master?
[16:58:41] <nmatsakis> in particular borrowed pointers whose lifetime is independent from the thing itself
[16:58:45] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[17:00:04] <doomlord> are rust and haskell the only langauges with type inference that works forwards and backwards
[17:00:26] <erickt> nmatsakis: I'm guessing this is just a quirk of the region system. This came up because I saw option.rs use a lot of `<'a>` regions on the methods instead of declaring 'self on the impl and it just felt odd
[17:00:32] <rntz> doomlord: what does forwards and backwards mean?
[17:00:45] <rntz> (the answer to your question is probably "no", but I can't be sure without understanding the question)
[17:00:57] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[17:00:59] *** Joins: qmx (qmx@moz-D6C3C2E6.qmx.me)
[17:01:00] <erickt> nmatsakis: two different ways to accomplish the same thing. I couldn't decide which was best :)
[17:01:01] <nmatsakis> erickt: it's better to put it on the method if you can, I would say
[17:01:15] <bstrie> olsonjeffery: I think it builds against 0.7 for now
[17:01:22] *** Joins: mschifer (Adium@moz-BBE3ABD.mv.mozilla.com)
[17:01:24] <doomlord> c++ can only infer types 'forwards' , rust can infer backwards eg starting with the functoin return value it can figure out types for locals
[17:01:25] <nmatsakis> erickt: for one thing, it leads to more reusable traits, though the traits in option are often kind of special purpose
[17:01:31] <erickt> nmatsakis: `&'a self` does look better than `&'self self`
[17:01:38] <nmatsakis> doomlord: ml
[17:02:03] <doomlord> perhaps f# copies that ability too
[17:02:05] <rntz> doomlord: yeah, in that case any language with a hindley-milner type system suffices. so, in particular, all the ML languages (OCaml, Standard ML)
[17:02:05] <nmatsakis> and numerous other less popular languages that use HM-based inference
[17:02:09] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[17:02:19] <rntz> s/with a hindley-milner type system/with hindley-milner type inference/
[17:02:35] *** Quits: mye (mye@moz-FFDA3A47.dip0.t-ipconnect.de) (Quit: mye)
[17:03:07] *** Joins: nano (nano@moz-972880B.superkabel.de)
[17:03:18] <cmr> (including F#, which is basically IronOCaml)
[17:03:34] <rntz> I thought F# lacked any sort of module system?
[17:03:50] <erickt> nmatsakis / strcat: What do the both of you think about adding a lint pass to complain if you're using the 'self region in an impl on a type that doesn't contain 'self pointers?
[17:03:57] <rntz> (by module system I mean the SML notion of a module system, not mere namespacing a la Java)
[17:04:11] <strcat> erickt: you might not have a choice if the trait does, I guess
[17:04:17] <cmr> rntz: I have no idea
[17:04:35] <erickt> strcat: we could also check if traits are using 'self and complain then too
[17:05:20] *** Joins: lkuper (lkuper@5188CCE.A402E718.C082B7DC.IP)
[17:05:27] *** Quits: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP) (Client exited)
[17:08:40] *** Joins: mvalzelli (mvalzelli@moz-36091CB9.ip217.fastwebnet.it)
[17:09:13] *** Parts: mvalzelli (mvalzelli@moz-36091CB9.ip217.fastwebnet.it) (Quitting)
[17:09:27] *** Quits: qmx (qmx@moz-D6C3C2E6.qmx.me) (Ping timeout)
[17:09:52] *** Joins: qmx (qmx@moz-D6C3C2E6.qmx.me)
[17:11:03] *** Joins: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net)
[17:12:10] <sully> argh, people talking about vtable problems, and they aren't in channel anymore
[17:12:35] *** Quits: qmx (qmx@moz-D6C3C2E6.qmx.me) (Quit: ZNC - http://znc.in)
[17:17:31] *** Joins: KindOne (KindOne@moz-43947C0.dynamic.ip.windstream.net)
[17:18:07] *** Quits: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com) (Ping timeout)
[17:18:30] *** Joins: doener (doener@moz-121949B3.unitymediagroup.de)
[17:20:22] *** Joins: qmx (qmx@moz-B6DBCD05.qmx.me)
[17:20:40] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[17:20:40] <toddaaro> how do you define a struct with a fixed length vector inside?
[17:20:48] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[17:20:56] <cmr> rusti: struct Foo { f: [int, ..4] }
[17:20:58] -rusti- ()
[17:20:58] <kimundi> struct Foo{ bar: [uint, ..4] }
[17:21:01] <toddaaro> there is nothing in the tutorial, and the closest I see in the language reference is ]0,..128];
[17:21:12] *** Joins: tjc (tjc@moz-BE33DA21.fw1.sfo1.mozilla.net)
[17:21:12] *** ChanServ sets mode: +o tjc
[17:21:12] <toddaaro> ok, so I put the type there?
[17:21:15] <cmr> yes
[17:21:19] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[17:21:20] <toddaaro> cool, thanks
[17:21:21] <cmr> the type is [T, ..n]
[17:21:26] <toddaaro> that should probably end up in the tutorial someday
[17:21:34] <Sergio965> toddaaro: It's in the tutorial.
[17:21:39] <toddaaro> Sergio965: where? I couldn't find it
[17:21:58] <toddaaro> oh ok, there it is
[17:21:59] <Sergio965> http://static.rust-lang.org/doc/0.7/tutorial.html#vectors-and-strings
[17:22:10] <Sergio965> It's in the first example for vectors.
[17:23:30] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[17:23:38] *** Joins: graydon (graydon@moz-F14EE0DB.cable.teksavvy.com)
[17:23:38] *** ChanServ sets mode: +qo graydon graydon
[17:25:05] *** Quits: paulproteus (quassel@rose.makesad.us) (Ping timeout)
[17:26:11] <Sergio965> Is there a way to include a standard path for modules?
[17:26:31] <cmr> Sergio965: I think there's something near RUST_PATH or similar
[17:26:39] <cmr> Wait, what do you mean?
[17:26:45] <cmr> mod foo { mod bar; mod baz; }
[17:26:51] *** Quits: xraycat (Adium@moz-97690522.pool.mediaways.net) (Quit: Leaving.)
[17:26:51] <cmr> wil load foo/bar.rs and foo/baz.rs
[17:26:54] <Sergio965> Right now I have a module dev in a parent directory ../dev, so I do #[path="..dev/"] mod dev.
[17:27:10] <Sergio965> But it's a in a parent directory.
[17:27:10] *** Joins: paulproteus (quassel@moz-E86A3B42.makesad.us)
[17:27:22] <tjc> Sergio965: in the future you'll be able to set RUST_PATH=../dev -- except it'll have to be an absolute path
[17:27:24] <tjc> in the environment
[17:27:31] <tjc> but it's not implemented right now -- it's what I'm working on right now
[17:27:40] <cmr> doing #[path=."./dev"] mod dev { mod ... } should do the right thing?
[17:27:43] <Sergio965> Ah, alrighty. So no way to do that right now?
[17:28:01] <Sergio965> cmr: It does, but it's cumbersome if I load up multiple modules in parent directories.
[17:28:12] <tjc> yeah, for now, #[path=whatever] is the best thing to do
[17:28:19] <Sergio965> Or if I load up the same module in different files.
[17:28:28] <cmr> tjc: you shouldn't be loading the same module in different files.
[17:28:34] <cmr> Erm, @Sergio965
[17:28:40] <Sergio965> No?...
[17:28:41] *** Quits: pcwalton (pcwalton@moz-A746ED0D.hfc.comcastbusiness.net) (Quit: pcwalton)
[17:28:47] <cmr> Sergio965: `mod` opens the file and creates a *new module* in the module tree.
[17:28:50] <Sergio965> What if I need to use the str module?
[17:28:52] <cmr> It doesn't reference already loaded ones.
[17:29:03] <Sergio965> Aren't I suppose to do mod str?
[17:29:06] <cmr> No.
[17:29:09] <Sergio965> Bah.
[17:29:09] <cmr> `use str`
[17:29:14] <cmr> or `use std::str` rather
[17:29:34] <engla> `mod` is used to define a module
[17:29:36] <cmr> All of your `mod` statements should be in the crate file, or in "module files" in subdirectories.
[17:29:39] <kimundi> We need a lint that cathes that :P
[17:29:40] <graydon> 'mod foo' means "compile a copy of foo into this location in the module tree for the crate"
[17:29:50] <cmr> And you `use` them to bring them into scope
[17:30:15] <Sergio965> So only the crate should have mod statements?
[17:30:34] <cmr> Sergio965: because you don't want to have multiple copies of a given module in different places in the module tree
[17:30:51] <Sergio965> So mod is like include?
[17:30:52] <cmr> A common pattern though, for example in std.rs, is #[path="num/mod.rs"] mod num;
[17:30:57] <strcat> you can have mod statements anywhere, but it's very unlikely you would want to include a file as 2 different modules in the tree
[17:31:13] <strcat> Sergio965: not really
[17:31:16] <cmr> Sergio965: sorta kinda not really
[17:31:16] <strcat> it defines a module
[17:31:19] <strcat> mod foo {}
[17:31:22] <strcat> or you can define one from a file
[17:31:29] <Sergio965> What.
[17:31:37] <cmr> https://github.com/mozilla/rust/blob/master/src/libstd/std.rs
[17:31:38] <Sergio965> I'd donate to have better documentation for Rust.
[17:31:47] <cmr> Sergio965: donate your time and write some ;P
[17:31:56] <Sergio965> cmr: I would if I understood it enough to write it. :P
[17:31:57] <kimundi> mod foo; is suger for mod foo { /* insert foo.rs content here */ }
[17:32:00] <cmr> I think the module system is the least documented, most confusing part of rust atm..
[17:32:02] <Sergio965> But as is clear, I don't.
[17:32:31] <cmr> in the 2 dimensional space of (documentation, confusingness) at least :p
[17:32:38] <bjz> erickt: did you get any more info re the double-dispatch overloads?
[17:32:45] <toddaaro> new vector question: how do I make an array of uninitialized pointers?
[17:32:49] <Sergio965> So‚Ä¶what does mod do?
[17:32:54] <Sergio965> And what does extern mod do?
[17:33:00] <Sergio965> And when do I use 'use'?‚Ä¶ :|
[17:33:12] <cmr> Sergio965: Are you familiar with .NET?
[17:33:18] <Sergio965> I'm not.
[17:33:27] *** Quits: lkuper (lkuper@5188CCE.A402E718.C082B7DC.IP) (Quit: lkuper)
[17:33:33] <bstrie> toddaaro: you mean an array of null pointers?
[17:33:36] <cmr> Ok, there goes that. I'm not familiar with anything else to make an analogy..
[17:33:54] <cmr> Sergio965: `use` is what is used for imports; it brings a name into scope.
[17:34:03] <toddaaro> bstrie: yes, whatever a contiguous block of null pointers is
[17:34:13] <cmr> Sergio965: `mod` is for constructing the module tree, essentially creating namespaces.
[17:34:16] <toddaaro> (null AtomicPtr in this case if that makes a difference)
[17:34:17] <kimundi> Sergio965: 'mod' for including a source file, 'extern mod' for linking to an other libriry, 'use' to bring names in from the first two in scope without needing to give the full path all the time
[17:34:23] <cmr> For that purpose there are two uses of mod:
[17:34:31] <cmr> `mod ident;` which loads the module from a file.
[17:34:45] <cmr> and `mod ident { ... }`, in which case the body of the module is given in the block
[17:34:45] <bstrie> toddaaro: rust doesn't have null pointers, you'd probably have to use some unsafe C type for that
[17:35:03] <cmr> toddaaro: there's also like util::uninit or something like that
[17:35:36] <cmr> intrinsics::uninit()
[17:35:37] <Sergio965> cmr: In a crate file, can I use 'use'?
[17:35:52] <cmr> Sergio965: you can use `use` (almost) everywhere\
[17:35:55] <Sergio965> I get 'use' and 'extern mod' declaration must precede items...
[17:36:06] <cmr> Sergio965: yeah, order is a bit wonky.
[17:36:10] <toddaaro> cmr: that sounds like what I want
[17:36:18] *** Joins: bz (bzbarsky@moz-C5CDDB53.tukw.qwest.net)
[17:36:19] <cmr> You have to put all `use` before `mod`
[17:36:21] <bz> pcwalton: piung
[17:36:23] <bz> er, ping
[17:36:23] <cmr> But order doesn't matter
[17:36:27] <Sergio965> :|
[17:36:32] <Sergio965> What.
[17:36:33] <bz> hmmm... not here
[17:36:38] <Sergio965> That is unintuitive.
[17:36:48] <Sergio965> I'd guess the other way around.
[17:36:48] <cmr> Sergio965: yes it is, but it's what it is
[17:37:01] <Sergio965> Given that you were saying 'mod' brings in the module to the module tree.
[17:37:06] <cmr> module loading happens before name resolution.
[17:38:00] <strcat> the order of stuff in the file doesn't matter
[17:38:05] <strcat> afaik the restriction on order is arbitrary
[17:38:28] <cmr> pretty sure it is.
[17:38:30] *** Joins: mye (mye@moz-FFDA3A47.dip0.t-ipconnect.de)
[17:39:00] <cmr> someone else would need to verify but I think if the order weren't restricted, `use` from later on in a scope would be visible everywhere in the scope
[17:39:17] <cmr> bz: he's at OSCON iirc
[17:39:50] <cmr> Which is even more counterintuitive
[17:40:06] <cmr> but fixing that would be invasive and not really worth it
[17:40:16] *** Quits: libertas (libertas@moz-6F68A62F.net.novis.pt) (Ping timeout)
[17:41:02] <brendanc> graydon: btw I took a look at making the interruptor compatible with 0.8.7p1 last night. there were a couple things that had to be changed
[17:41:10] <cmr> graydon: ping
[17:41:26] <cmr> Sergio965: I'll try and write some in-depth documentation of the module system this weekend
[17:41:38] <Sergio965> cmr: Yeah, that'd be great.
[17:41:47] <pnkfelix> graydon: r? https://github.com/mozilla/rust/pull/7820
[17:41:52] <Sergio965> cmr: kimundi brief explanation of the differences helped a lot.
[17:41:57] <graydon> brendanc: ok. I think the main thing to do is to use SIGTERM not SIGKILL
[17:42:02] <graydon> cmr: pong
[17:42:12] *** Joins: libertas (libertas@moz-6F68A62F.net.novis.pt)
[17:42:18] <cmr> graydon: do you have any update on https://github.com/mozilla/rust/pull/8009? Could it land in the interim?
[17:42:24] <brendanc> graydon: I didn't have any signalling in there
[17:42:31] <brendanc> but there were buildbot interface changes
[17:42:35] <Sergio965> So 'extern mod' is to bring in other crates, is that correct?
[17:42:44] <kimundi> yes
[17:42:47] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Quit: Computer has gone to sleep.)
[17:42:48] <cmr> Sergio965: when it's `extern mod ident;` yes.
[17:42:49] *** Parts: bz (bzbarsky@moz-C5CDDB53.tukw.qwest.net) ()
[17:42:50] <graydon> brendanc: there's a way to indicate kill-with-TERM, I will get to it, don't worry
[17:43:06] <graydon> cmr: no, I haven't found the branch yet. too many workspaces / machines. remind me again during the day. I will keep looking.
[17:43:08] <kimundi> cmr: There is no other exter mod afaik
[17:43:15] <cmr> graydon: when is the day?
[17:43:18] <brendanc> graydon: https://bitbucket.org/brendan/buildbot-unitedwefall/commits/8a49f7d371c3c633d2a73bc5c722e37a0dab2c79
[17:43:22] <cmr> kimundi: there isn't `extern mod foo { ... }` anymore?
[17:43:23] <graydon> cmr: today :)
[17:43:29] <brendanc> that's the other stuff that needed changing
[17:43:30] *** sam113101 is now known as sam113101_afk
[17:43:39] <kimundi> rusti: extern mod foo { ... }
[17:43:39] <cmr> graydon: ok :)
[17:43:40] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/AQVb
[17:43:47] <graydon> brendanc: gosh. ok. I'll try to land those, thanks.
[17:43:49] <cmr> kimundi: aha!
[17:43:50] <kimundi> nope
[17:43:57] <cmr> Sergio965: never mind then :)
[17:44:04] <strcat> graydon: so I was thinking about killing off rust_builtin.cpp, but there are some MSVC++ defines and I don't know what to do with those
[17:44:23] <strcat> any idea if those are defined by mingw? `#if defined(_MSC_VER) && (_MSC_VER >= 1400)`
[17:44:27] *** Joins: lkuper (lkuper@5188CCE.A402E718.C082B7DC.IP)
[17:44:31] <graydon> strcat: they are, I think
[17:44:35] <graydon> actually I'm not sure
[17:44:43] <strcat> http://ix.io/6SZ it's hard for me to tell what exactly this does
[17:44:44] <graydon> what were you going to do with the contents of rust_builtin?
[17:44:46] <strcat> it seems very wrong
[17:45:02] <strcat> graydon: port it to rust, so it will still be calling into C but we won't need all this supporting C++
[17:45:22] <graydon> it's tricky since you often need to move C macros to rust in the process
[17:45:23] <strcat> it tries to use the thread-safe functions but falls back to thread-unsafe ones
[17:45:25] <strcat> without locks :|
[17:45:28] <graydon> but many things can move, yes
[17:45:36] <graydon> pnkfelix: sec
[17:46:23] *** Quits: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP) (Client exited)
[17:46:31] <strcat> graydon: ugh, mingw has no gmtime_s *or* gmtime_r
[17:46:38] <strcat> so I think our time stuff is just racy on windows atm
[17:46:38] *** sam113101_afk is now known as sam113101
[17:47:01] <Sergio965> Say I have an extern block extern "hi" { pub fn somefn(); } in some file, then I pub mod that_file. Why is it that I can't do that_file::somefn()?
[17:47:20] <strcat> I guess it needs a global mutex
[17:47:35] <Sergio965> I get an "unresolved name" error.
[17:47:41] <doomlord> paths are relative to crate origin
[17:47:41] <Sergio965> Which sounds like it's just not finding it.
[17:47:44] <graydon> pnkfelix: r+ sorry for the delay
[17:47:55] <doomlord> i always run into that myself, 
[17:48:28] <Sergio965> I'm using other things from that file, though.
[17:48:28] <doomlord> paths are relative to the origin, not the source file you're usng it  from
[17:48:32] <Sergio965> Just not the extern stuff.
[17:48:38] <doomlord> oh
[17:48:41] <graydon> unless you use it.
[17:48:50] <graydon> cmr: I would like to cooperate some on developing module-system docs
[17:49:10] <graydon> cmr: I am trying to find a suitable diagram editor, I feel like diagrams would help
[17:49:15] <cmr> Sergio965: https://gist.github.com/cmr/f5c4e210df59a1d3f9f7 wfm
[17:49:23] <cmr> graydon: http://www.asciiflow.com/#Draw is my favorite ;)
[17:49:32] <cmr> elsewise I just fake it in inkscape, or use graphviz
[17:49:54] <graydon> graphviz is terrible for technical drawings
[17:49:57] <cmr> Yes it is
[17:50:08] <graydon> I've been poking at kite9.com
[17:50:19] <cmr> ohh that looks nice
[17:50:22] <Sergio965> cmr: Hmm. So I have a crate where I do mod foo, mod bar, and then I have another file, bar, where I do use foo. I then try to do somefn(), and it doesn't work.
[17:50:39] <cmr> Sergio965: `foo::somefn()`?
[17:50:52] <doomlord> use foo::*
[17:50:54] <pnkfelix> graydon: np, thx
[17:50:55] <cmr> Or that
[17:51:15] <doomlord> i'm lazy, i just use foo::*
[17:51:44] <cmr> graydon: I think the best way to *start* the tutorial is by taking a look at existing module/include systems, like C++ namespaces + headers or whatever Java does, what hte flaws are, and why Rust does what it does.
[17:51:55] <Sergio965> cmr: Indeed.
[17:51:55] <cmr> (aiui rust and .net's module systems are quite similar?)
[17:51:55] <graydon> huh, maybe
[17:52:05] <graydon> I don't think so, no
[17:52:19] <olsonjeffery> the api's are similar'ish
[17:52:36] <bstrie> I don't agree that modules are the right thing to start off the tutorial with
[17:52:43] *** Joins: paupau (textual@417F0514.289B9BF9.F20F0C5A.IP)
[17:52:52] <cmr> graydon: And then, once the problem space of "what a module system needs to accomplish" and "what other modules systems lack" is sufficiently enumerated, it can go on to demonstrate what Rust's module system looks like, how to use it, etc.
[17:52:58] <bstrie> though maybe modules really impress C++ folks? I dunno
[17:52:59] <cmr> bstrie: not the tutorial, the module system tutorial
[17:53:00] <graydon> rust's module system is as much as possible like a unix filesystem. 'extern mod' is mount. use is symlink.
[17:53:04] <bstrie> ah ok
[17:53:26] <doomlord> lack of header files is 50% of my reason for being here
[17:53:26] <Sergio965> What is mod?
[17:53:28] <graydon> .. is super, . is self, / is ::
[17:53:37] *** Quits: jclements (jclements@DA70AF72.E0F991B7.62E7C518.IP) (Quit: jclements)
[17:53:39] <Sergio965> (in the Unix FS analogy)
[17:53:45] <kimundi> Sergio965: The actual file
[17:53:48] <cmr> Sergio965: a file or directory
[17:53:52] <cmr> probably directory
[17:53:56] <cmr> and the "files" would be items
[17:53:57] <graydon> a link from one dir to the next, or to a file
[17:54:02] <graydon> like a dirent
[17:54:07] <kimundi> Sergio965: Multiple mods for the same thing are hardlinks :P
[17:54:14] <Sergio965> Ah yeah.
[17:54:15] <Sergio965> I like that.
[17:54:18] <cmr> kimundi: Except not
[17:54:18] <doomlord> so you could say modules are an impressive  feature ... they shouldn't be :)
[17:54:20] <Sergio965> mods are hard links.
[17:54:23] <Sergio965> Or not.
[17:54:32] <graydon> well, like full separate copies
[17:54:39] <cmr> `mod foo; mod bar { #[path="foo.rs"] mod foo; }`
[17:54:41] <Sergio965> And a crate is the file system?
[17:54:53] <graydon> a crate is a filesystem, yes. you can mount it in another one at any point you like.
[17:54:55] <cmr> Identically named types in foo and bar::foo will be considered different iirc
[17:54:57] <kimundi> cmr: they contain the same data, but acording to the filesystem they are different files, no?
[17:55:08] <graydon> but it's a self-contained "namespace", no global names across crates.
[17:55:17] <cmr> kimundi: they don't contain the same data in rust though
[17:55:21] <sully> hey, graydon, do you have any idea what was up with that segfault?
[17:55:27] <doomlord> The thing i always ran into was expecting it would be like the simpler module systems where a sourcefile just says "import... [as ..]", you just have to explain that paths are crate relative somewhere early in the docs IMO to avoid that confusion. 
[17:55:33] <graydon> sully: none at all. but it was pretty pervasive.
[17:56:02] <kimundi> cmr: Sure they do, they just refer to seperate copies that aren't interchangeable
[17:56:21] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[17:56:23] *** Joins: jclements (jclements@moz-18551D9B.ngn.east.myfairpoint.net)
[17:56:28] <cmr> kimundi: I... guess? The analogy is a bit stretched I think :p
[17:56:37] <kimundi> yeah it is xD
[17:56:59] <cmr> graydon: kite9 feels a bit sluggish but it's quite pretty and seems easy to use
[17:57:13] <Sergio965> I like the file system anology.
[17:57:15] <sully> graydon: oh, hm, it looks like only mac failed due to that crash
[17:57:16] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[17:57:19] <Sergio965> Sort of.
[17:57:29] <sully> graydon: the rest failed because I changed a diagnostic message and didn't update the test
[17:58:07] <Sergio965> The thing that's confusing, or was, is that you have to first use 'mod' to 'include' the file, and then use 'use' to bring it into the namespace.
[17:58:11] <doomlord> there was the idea of making the error messages teach you that paths are crate relative
[17:58:17] <doomlord> i think that would help newcomers
[17:58:20] <graydon> it's a stretched analogy, but it's the best one I can offer; module systems aren't _quite_ like filesystems, but several of the intuitions (canonical paths, unambiguous absolute vs. relative paths, all names relative to a fs/crate root, symbolic links, etc.) are similar
[17:58:41] <cmr> graydon: I think it's quite apt, except the hardlinks part
[17:58:41] <graydon> doomlord 'use' paths are crate-relative; paths in exprs are mod-relative.
[17:59:03] <graydon> I think that difference is a major stumbling point. I'd want to make it clear early in any tutorial.
[17:59:10] <doomlord> someone suggested writing root::foo or use ::foo to clarify that
[17:59:12] <Sergio965> Which difference?
[17:59:18] <Sergio965> Oh, path relativity.
[17:59:21] <graydon> yeah
[17:59:29] <Sergio965> I guess the way I think of it is that everything is anchored on the crate.
[17:59:34] <Sergio965> IE, the crate /is/ the program.
[17:59:35] <kimundi> right
[17:59:55] <graydon> except in an expr you need to write ::foo::bar to get an absolute reference
[18:00:03] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[18:00:14] <graydon> foo::bar is local module-relative in an expr (or anywhere other than a use)
[18:00:18] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[18:00:19] <graydon> use is crate relative for a reason
[18:00:21] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[18:00:23] <graydon> it's an unfortunate one
[18:00:30] <graydon> the resolution algorithm is incoherent otherwise
[18:00:34] <doomlord> so might it make sense to make the use symetrical with that... use ::foo::bar;
[18:00:40] <graydon> it used to be mod relative
[18:00:43] <Sergio965> And like modules are part of a crate.
[18:00:48] <Sergio965> Is that fair to say?
[18:00:52] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[18:00:53] <Sergio965> Modules are "in" a crate?
[18:01:01] <Sergio965> Or a "part of" a crate?
[18:01:03] <kimundi> Sergio965: yup
[18:01:06] <graydon> Sergio965: it would make more sense, but we'd be writing ::foo::bar in every use directive
[18:01:15] <graydon> since we do not permit relative paths at all in use directives
[18:01:27] <graydon> (they make the resolution algorithm fall apart due to globbing and re-exporting)
[18:01:31] <cmr> Sergio965: a crate consists of a root module, plus anything else that module includes using `mod`
[18:01:51] <Sergio965> cmr: The crate itself is the root module?
[18:02:18] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[18:02:30] <toddaaro> is there a reason AtomicOption doesn't have a put?
[18:02:31] <kimundi> graydon: I think the idea was to make use self::... the default. 
[18:02:50] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[18:03:02] <kimundi> But.. not sure what the problem with that is
[18:03:08] <Sergio965> Great, now the crate/mod/use/extern mod stuff makes sense.
[18:03:18] <Sergio965> If only we could write this conversation down in a cohesive manner.
[18:03:45] <kimundi> rusti: use self::foo::bar; pub mod foo{pub mod bar{}}; 
[18:03:46] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/PZNJ
[18:03:48] <Sergio965> Actually, so extern mod is like a regular mod if the crate you're extern modding was a module?
[18:04:16] <graydon> extern mod says "link another crate in here". it's "mount" in the filesystem analogy.
[18:04:32] <Sergio965> Right. But is it fair to think of it as a mod for crates?
[18:04:34] <kimundi> Sergio965: yeah, you can see it as mounting the root module of the extern crate somewhere into your crates module tree
[18:04:44] <sully> graydon: ok, so, I am going to fix the test that I broke, then resubmit it for build
[18:04:52] <Sergio965> kimundi: Great, that makes sense.
[18:04:57] <sully> graydon: in the hopes that the osx crash was a fluke?
[18:05:46] <Sergio965> We need a "tryrust.com" like website.
[18:05:56] <Sergio965> With interactive tutorials where users can break things.
[18:06:11] <cmr> strcat: hear that? ;p
[18:06:20] <Sergio965> And then have it says, "Oops! You didn't include the "bla" module. use "mod" to bla bla bla. Modules are bla bla." Etc.
[18:06:25] <Sergio965> say*
[18:06:25] <graydon> sully: I don't think so. they all crashed.
[18:06:32] <graydon> sully: I think you need to get a mac to debug it.
[18:06:33] *** Quits: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net) (Client exited)
[18:06:41] <strcat> cmr: it probably needs a dedicated machine though
[18:06:42] <Sergio965> sully: You should get a Mac regardless. They're great.
[18:06:43] <strcat> but sure
[18:06:48] <doomlord> just put that tuition in the compiler error messages :)
[18:06:52] <strcat> I'd love to make all of the code samples in the tutorials editable/runnable
[18:06:55] <strcat> it's totally possible
[18:06:56] <sully> graydon: oh, was there more than one mac the build segfaulted on?
[18:07:02] <graydon> yes
[18:07:04] <graydon> all of them
[18:07:15] <sully> ah
[18:07:18] <strcat> cmr: you need 128MiB for each concurrent user
[18:07:25] <Sergio965> strcat: But a full site dedicated to getting people up to speed, especially with foreign concepts such as the different types of pointers and lifetimes, would be fantastic.
[18:07:36] *** Joins: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net)
[18:07:40] <sully> ok, well, how do I go about getting access to a mac to debug this on?
[18:07:50] <cmr> strcat: grr, why isn't rustc perfect yet.
[18:07:51] *** Quits: echristo (echristo@60A74940.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[18:07:58] <cmr> Perfection can't be *that* hard to achieve
[18:08:01] <strcat> cmr: it'll always need a bunch of memory though
[18:08:04] <doomlord> "error "foo" not found , but its in ::yada::foo, did you mean use yada::foo (use paths are crate relative)"
[18:08:10] <strcat> it's better than it used to be
[18:08:49] <graydon> sully: I can give you ssh access to one of the buildslaves. otherwise borrow someone's laptop / mini?
[18:09:05] <strcat> "borrow"
[18:09:09] <sully> ssh access to a buildslave probably works best?
[18:10:00] <kimundi> what would be cool if each code sample in the tutorial would show a 'short' version of the code (like it does right now), thet can be expanded to see a fully compiling rust program, and that can be loaded on the fly into a web-rusti sandbox
[18:10:14] <Sergio965> kimundi: Yeah.
[18:10:27] <Sergio965> I would like a challenge-like website.
[18:10:43] <strcat> kimundi: well it's all possible if there was a dedicated machine with a bunch of memory
[18:11:15] <Sergio965> For example, for lifetimes, I'd like to have a few example of things that can only be safely implemented using named lifetimes, and then have a challenge example asking to implement a function or whatever that has to use lifetimes to be correct.
[18:11:17] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[18:11:23] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[18:11:23] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[18:11:26] <strcat> rusti: 2 + 2
[18:11:27] -rusti- 4
[18:11:27] -rusti- 64724KiB
[18:11:31] <kimundi> quick, someone superglue a few thousand ddr3 modules together!
[18:11:32] <strcat> worse than it used to be
[18:11:43] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[18:11:44] <Sergio965> What's the 64724KiB?
[18:11:52] <cmr> Sergio965: memory usage
[18:12:00] <Sergio965> 64MB of memory usage? :|
[18:12:02] <kimundi> rusti: [0, ..10000000]
[18:12:03] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/fLjc
[18:12:04] <strcat> rusti: let mut x = std::hashmap::HashSet::new(); x.insert(5); x.len()
[18:12:05] -rusti- 1
[18:12:05] -rusti- 71696KiB
[18:12:12] <Sergio965> What.
[18:12:13] <strcat> rusti: let mut x = std::hashmap::HashMap::new(); x.insert(5, "foo"); x.len()
[18:12:14] -rusti- 1
[18:12:14] -rusti- 71612KiB
[18:12:28] <strcat> rusti: ~[0, ..1000000];
[18:12:29] -rusti- ()
[18:12:29] -rusti- 64696KiB
[18:12:31] <strcat> rusti: ~[0, ..10000000];
[18:12:32] -rusti- ()
[18:12:32] -rusti- 81568KiB
[18:12:36] <strcat> rusti: ~[0, ..100000000];
[18:12:37] -rusti- application terminated abnormally with signal 9 (Killed)
[18:12:37] -rusti- 131072KiB
[18:12:42] <Sergio965> Where does it all go?
[18:12:47] <strcat> hm?
[18:12:56] <strcat> rustc uses a lot of memory
[18:13:01] <strcat> all kinds of tables, the AST, etc.
[18:13:11] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[18:13:11] *** ChanServ sets mode: +o dherman
[18:13:18] <Sergio965> But it's 2 + 2.
[18:13:19] <strcat> maybe it's the AST regression resulting in the 5MiB increase over what it was before
[18:13:37] <dherman> someone should explain how to freeze a map here: http://stackoverflow.com/questions/17887065/sharing-mutable-variables-between-threads-in-rust
[18:13:37] <cmr> rusti: 2+2
[18:13:38] -rusti- 4
[18:13:38] -rusti- 64652KiB
[18:13:45] <kimundi> strcat: the numbers are for rustc, not the resulting executable, right?
[18:13:52] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[18:13:58] <Sergio965> Is there a good codebase to look at when looking for "good" idiomatic Rust code?
[18:14:01] <Sergio965> Is Servo a good example?
[18:14:06] <kimundi> (having both would be interesting)
[18:14:11] <strcat> kimundi: it's both
[18:14:17] <strcat> it's just the peak of the container
[18:14:35] <kimundi> Sergio965: There are one, two modules in std that would qualify... :|
[18:14:39] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[18:14:47] <Sergio965> Which ones?
[18:14:49] <strcat> rusti: struct Foo { x: [Foo, ..2] }
[18:14:49] -rusti- ()
[18:14:50] -rusti- 64796KiB
[18:14:51] <kimundi> ITerators
[18:14:59] <strcat> rusti: struct Foo { x: [Foo, ..2] } let x: Option<Foo> = None;
[18:15:01] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/GfWd
[18:15:09] <bstrie> is it possible to mutate self when passed by-value rather than by-reference?
[18:15:09] <strcat> rusti: struct Foo { x: [Foo, ..2] } let _x: Option<Foo> = None;
[18:15:10] -rusti- Killed
[18:15:10] -rusti- application terminated with error code 137
[18:15:10] -rusti- 131072KiB
[18:15:21] <cmr> bstrie: yes
[18:15:21] <strcat> bstrie: yes, let mut self = self
[18:15:25] <strcat> well
[18:15:28] <strcat> maybe self is a keyword now
[18:15:31] <strcat> but that's the idea anyway
[18:15:47] <cmr> rusti: struct Foo; impl Foo { fn foo(mut self) { } }
[18:15:48] <bstrie> ah, I tried putting `mut self` as the function parameter, since that works elsewhere
[18:15:48] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/FfVY
[18:15:59] <cmr> Guess 'self' is special
[18:16:03] <cmr> extra-special, that is
[18:16:21] <cmr> dherman: ping
[18:16:47] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[18:16:49] <cmr> rusti: let x = Some(~5u); match x { None => 0, Some(n) => n * 2 }
[18:16:50] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[18:16:58] <strcat> rusti: 2
[18:16:59] -rusti- 2
[18:17:09] <cmr> rusti: let x = Some(~5u); match x { None => 0, Some(n) => n * 2 }
[18:17:09] -rusti- <anon>:7:60: 7:65 error: binary operation * cannot be applied to type `~uint`
[18:17:10] -rusti- <anon>:7          let x = Some(~5u); match x { None => 0, Some(n) => n * 2 }
[18:17:10] -rusti-                                                                      ^~~~~
[18:17:10] -rusti- error: aborting due to previous error
[18:17:10] -rusti- application terminated with error code 101
[18:17:25] <strcat> kimundi: http://ix.io/6T0 I just added those 5 lines ;p
[18:17:25] <cmr> dherman: unping
[18:17:38] <cmr> dherman: nice slides though :)
[18:17:41] <dherman> thx
[18:17:52] <dherman> cmr: wanna answer this SO question?
[18:17:57] <dherman> it looks easy
[18:17:59] <dherman> http://stackoverflow.com/questions/17887065/sharing-mutable-variables-between-threads-in-rust
[18:18:06] <cmr> sure
[18:18:49] <Sergio965> If Rust did away with braces and semicolons, I'd be happy.
[18:18:57] <strcat> dherman: well you can't really share memory in the core language, just with ARCs
[18:19:18] <bblum> i just did
[18:19:19] <bblum> c.c
[18:19:21] <bstrie> dherman: on one of your slides, your typesetting software turned the apostrophes in your lifetime notations into smart quotes :)
[18:19:24] <bstrie> it looks a little strange
[18:19:25] <kimundi> Sergio965: Do you have ANY idea how hard it would be to rebalance the syntax? xD
[18:19:28] <cmr> bblum: heh, thanks :)
[18:19:36] <strcat> bblum: counting 'unsafe' as not part of that at least ;p
[18:19:58] <doomlord> Sergio965 what languages are you coming from
[18:20:02] <bblum> strcat: yeah, telling newcomers that unsafe is how you get anything done in the language: good  plan
[18:20:04] <Sergio965> doomlord: I've worked with many.
[18:20:17] * Sergio965 pulls up Resume.
[18:20:32] <erickt> bjz: I have not yet
[18:20:42] <Sergio965> Python, Go, C, Objective‚ÄìC, Java, Ruby, JavaScript, RISC/x86 Assembly
[18:20:48] <doomlord> whats are your"favourites"
[18:21:04] <bstrie> Sergio965: too late to change it! very sorry :)
[18:21:04] <Sergio965> Those are the ones I've pretty good at.
[18:21:09] <Sergio965> I'm*
[18:21:30] <doomlord> i'm just (8bit BASIC)->asm->C->C++ and hve only done trivial things elsewhere
[18:21:41] <Sergio965> bstrie: Nooo.
[18:21:53] <Sergio965> Really though, the braces make it look less elegant.
[18:22:02] <bstrie> fwiw, python is my next-favorite language and I don't mind the braces and semis
[18:22:09] <cmr> I've never really associated lack of braces with inelegance.
[18:22:13] <Sergio965> I don't mind the semicolons.
[18:22:17] <cmr> *elegance
[18:22:33] <Sergio965> But I do believe it would look cleaner (and save lines) without the semiclons.
[18:22:37] <Sergio965> er, the braces.
[18:22:37] <tiffany> rust expresses return values using a lack of braces
[18:22:40] <tiffany> er, lack of semicolons
[18:22:44] <bstrie> haha
[18:22:45] <dherman> bstrie: y, fighting smart quotes is like whack-a-mole
[18:22:46] <bstrie> so much confusion
[18:22:48] <Sergio965> I'm jiggy with the semicolons.
[18:22:52] <Sergio965> Haha, yeah.
[18:22:58] <doomlord> i understand why significant whitespace fans think as they do, its less un-necassery information, but i'm just used to braces
[18:23:09] <Sergio965> I'm very used to braces.
[18:23:13] <tiffany> I'm also used to braces
[18:23:15] <Sergio965> I've written so much C-like code.
[18:23:23] <Sergio965> But when I write Python, and don't use braces, it's nice./
[18:23:26] <Sergio965> nice*
[18:23:30] <tiffany> I've been writing almost exclusively in C for over a year
[18:23:39] <cmr> I don't really notice braces and semicolons or lack thereof anymore
[18:23:46] <dherman> bblum: see Rule #1 on slide 49
[18:23:52] <doomlord> i hae not written enough python or haskell to become a"significant whitespace fan"
[18:24:03] <Sergio965> I've been meaning to learn Haskell.
[18:24:06] <bstrie> well haskell has optional whitespace
[18:24:08] <tjc> significant whitespace in Haskell is nice, but I don't miss it in particular
[18:24:30] <Sergio965> How is the parser written for Rust?
[18:24:36] *** mihneadb is now known as mihneadb|lunch
[18:24:38] <Sergio965> Does it use a parser generator?
[18:24:45] <cmr> Sergio965: nope, hand rolled, written in rustc
[18:24:47] <cmr> *rust
[18:24:56] <cmr> src/libsyntax/parse/parser.rs
[18:24:58] <Sergio965> Would it really be that hard to get rid of braces?
[18:25:05] <Sergio965> Rather, make them optional?
[18:25:15] <doomlord> i doubt they can change that now
[18:25:17] <bstrie> dherman: also on some slides it took me a minute to tell whether the code was rust or C++. at one point I was like, "did anyone tell dherman that rust doesn't have a union keyword?"
[18:25:19] <cmr> Sergio965: remove braces where
[18:25:21] <cmr> ?
[18:25:24] <Sergio965> Everywhere.
[18:25:26] <cmr> Sergio965: just flow control? On structs too?
[18:25:29] <Sergio965> Use indentation.
[18:25:38] <bstrie> dherman: other than that it looked good. is there a video available?
[18:25:39] <Sergio965> Well, keep it for structs.
[18:25:48] <tiffany> it's a syntax trivialty
[18:25:49] <dherman> bstrie: I don't really make my slidfes to be self-contained. they are supplemental to the talk, not vice versa
[18:25:50] <Sergio965> That would be part of the constructor syntax.
[18:25:58] <bstrie> dherman: right, I am spoiled :)
[18:26:01] <strcat> tjc: haskell makes it a *lot* more flexible than python though
[18:26:05] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[18:26:05] <Sergio965> But doing something like:
[18:26:16] <doomlord> Doesn't python need the : to do various things
[18:26:23] <strcat> doomlord: that's arbitrary
[18:26:24] *** Joins: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net)
[18:26:25] <bstrie> doomlord: doesn't necessarily need it
[18:26:29] <bstrie> it's just there for readability
[18:26:30] <strcat> it was added because they thought it looked good
[18:26:32] <Sergio965> fn add(x: int, y:int) -> int (\n\t) x + y
[18:26:33] <Sergio965> Would be nice.
[18:26:43] <doomlord> but they can do one-liners with the : to separate?
[18:26:55] <Sergio965> Is that a colon or semicolon?
[18:26:55] <cmr> doomlord: no, but they have semicolons for oneliners
[18:27:05] <doomlord> ok
[18:27:06] <Sergio965> You can use a semicolon to seperator lines.
[18:27:20] <strcat> python has a distinction between statements and expressions
[18:27:21] <Sergio965> Oh, the colon is for blocks.
[18:27:27] <strcat> statements use significant whitespace for blocks
[18:27:33] <Sergio965> Like, for i in range(10):
[18:27:38] <Sergio965> or, def hi(name):
[18:27:39] <strcat> let x = if cond { 5 } else { 10 };
[18:27:56] <doomlord> oh significant whitespace means battle on spaces vs tabs
[18:28:01] <kimundi> Sergio965: Let's just say it so: YOU can fork and change the rust syntax like that. But WE won't. ;)
[18:28:06] <strcat> python's significant whitespace semantics won't work for rust
[18:28:10] <doomlord> no significant whitespace please :)
[18:28:10] <strcat> because many things are expressions
[18:28:14] <Sergio965> kimundi: I'll do it an submit a pull request.
[18:28:17] <cmr> Sergio965: anyway looking through, token::LBRACE and token::RBRACE are ubiquitous, but I don't know how hard it would be to change it
[18:28:18] <strcat> the fact that there is closures is already a deal breaker
[18:28:19] <Sergio965> kimundi: And have it never be approved.
[18:28:22] <strcat> you could do it more like haskell
[18:28:29] <kimundi> Sounds like a plan! :)
[18:28:30] <strcat> there are closures*
[18:28:34] <Sergio965> :(
[18:28:40] <Sergio965> Brace-free languages are the future!
[18:28:49] <strcat> Sergio965: so how do you deal with closures?
[18:28:51] <kimundi> LISPs are the future!
[18:28:58] <strcat> they are an expression, but also need a block
[18:29:07] <strcat> or if/match expressions
[18:29:14] <strcat> they evaluate to something
[18:29:21] <Sergio965> Indentation?
[18:29:23] <strcat> foo(closure, match expression)
[18:29:31] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[18:29:35] <strcat> Sergio965: okay, so what kind of indentation is required there, within the closure?
[18:29:36] <doomlord> the lack of lisp popularity would suggest my idea wouldn't catch on... language defined as an AST, and syntax is an optional tool.. part of editors
[18:29:42] <Sergio965> strcat: Where?
[18:29:47] <Sergio965> Give me an example.
[18:30:00] <tiffany> I like that idea doomlord
[18:30:12] <Sergio965> doomlord: it's great, but then you end up with a bunch of DSLs.
[18:30:19] <strcat> foo(|x, y| { do stuff with x and y, with multiple statements }, |a| { do stuff with a, as before })
[18:30:20] <cmr> doomlord: you can feed the rust compiler any ast you want through librustc
[18:30:21] <doomlord> so do i, but the question has to be asked why didn't lisp get that
[18:30:30] <tiffany> there's very few people who are trying it though, which is pretty odd given how complex IDEs have become in their tools that operate on the language itself
[18:30:37] <paupau> doomlord: I'm trying to do that 
[18:30:37] <tiffany> refactoring tools and such
[18:30:46] <doomlord> oh nice, i'm not completely insane
[18:30:56] <kimundi> doomlord: I thnik that could work in theory, but the problem is that you still need a specific semantic for the AST. So in the end, the different syntax skins won't look all that different to each other
[18:31:13] <strcat> Sergio965: python restricts lambdas to 1 expression for exactly this reason, but rust's match/if hit the same issue
[18:31:18] <doomlord> i'm sat here wondering how much commonality there could be between C++ ASST and Rust AST aswell. imagine having a universal AST and some subset compiles to either langauge..
[18:31:29] <tiffany> nobody said everyone had to use the same AST though kimundi
[18:31:38] <Sergio965> strcat: I don't see the issue with using match/if.
[18:31:43] <strcat> Sergio965: they are expressions
[18:31:48] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[18:31:48] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/hbzYTA
[18:31:49] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[18:31:55] <paupau> tiffany: IDEs have a lot of artificial complexity since they have to lens back-and-forth through denormalized text
[18:32:01] <strcat> foo(match expression with blocks, if-else expression with blocks)
[18:32:01] <kimundi> tiffany: I thought that was the premisse to what doomlord said?
[18:32:17] <tiffany> I don't know about doomlord, but the reason I'd want to do that is to simplify the construction of programming tools
[18:32:29] <tiffany> AST editors instead of text editors
[18:32:58] <Sergio965> https://gist.github.com/anonymous/6091167
[18:33:11] <strcat> Sergio965: in the example I gave, with a fn call
[18:33:25] <kimundi> A generic pluggable system witha a N to M mapping between syntax and AST variants...
[18:33:31] <strcat> Sergio965: with nested closures and/or match/if
[18:33:39] <paupau> tiffany: really is the future of programming IMO
[18:34:11] <tiffany> syntax completion, highlighting, preventing typoes, refactoring utilties, stylizing, etc. get a hell of a lot easier when you're operating on an AST
[18:34:21] <doomlord> halfway house between that and reality, i wondered if a general purpose programmers editor could benefit from grammar based plugins
[18:34:31] <Sergio965> https://gist.github.com/anonymous/6091178
[18:34:32] <doomlord> like grammar driven syntax highlighting
[18:34:48] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[18:34:48] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/3gPW_A
[18:34:48] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[18:34:49] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[18:34:49] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/UxgyEQ
[18:34:49] <ghrust> 13rust/06auto 14534dd62 15Felix S. Klock II: Add dependence arc from running rustc to its libraries....
[18:34:49] <ghrust> 13rust/06auto 1444808fc 15bors: auto merge of #7820 : pnkfelix/rust/fill-in-some-missing-rustc-lib-dependences, r=graydon...
[18:34:49] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[18:34:55] <cmr> Sergio965: and that's better than braces?
[18:35:03] <paupau> tiffany: exactly! those are artificial problems due to denormalization
[18:35:09] <Sergio965> cmr: No, that's probably a place where you'd like to use braces.
[18:35:12] <doomlord> but the right syntax is actually compression compared to an AST it seems
[18:35:15] <Sergio965> I'm saying they should be optional.
[18:35:28] *** Quits: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP) (Ping timeout)
[18:36:01] <tiffany> that doesn't really have any benefit though sergio, you're just complicating the parser and encouraging different programming styles that look ugly when combined
[18:36:25] <doomlord> you cuold make a text editor hide the braces and force indendation perhaps :)
[18:36:40] <Sergio965> tiffany: I'd mostly like it for control fow.
[18:36:42] <Sergio965> flow*
[18:36:49] <Sergio965> fn, do, while, for.
[18:36:55] <cmr> doomlord: tiffany: paupau: and you see tools like this being used for current languages?
[18:37:10] <cmr> What would using one "feel"/look like?
[18:37:16] <tiffany> it still has no objective benefit, it just serves your own fixation on syntax rather than semantics
[18:37:20] <cmr> You've piqued my interest :p
[18:37:31] <tiffany> cmr: I would love to use one regardless of language
[18:37:33] <doomlord> well in my variant - the text editor is actually a pretty-printer / parser.
[18:37:36] <tiffany> I've considered writing one for C
[18:37:37] <paupau> cmr: it would be a structure editor, but essentially feel like a text-editor
[18:38:04] <cmr> One thing I've always really wanted is a program execution visualizer
[18:38:06] <doomlord> my variant doesn't work with languages that are too hard to parse :)
[18:38:17] <cmr> You can can watch statements and expressions interact and touch memory and stuff
[18:38:17] <Sergio965> tiffany: In my humble opinion, it would certainly aid in making Rust code look cleaner. Further, I believe it would attract newcomers.
[18:38:35] <doomlord> is "light table" like that
[18:38:35] <paupau> cmr: code would not be stored in text, but in serialized program graphs
[18:38:37] <strcat> the grammar is exposed to users via macros
[18:38:52] <tiffany> cleanliness is highly subjective, and I believe rust's target audience is closer to C++ than python
[18:38:55] <cmr> doomlord: dunno, haven't used it.
[18:39:09] <tiffany> all the higher level language users I've introduced to rust just get scared off by the complex type system
[18:39:28] <doomlord> thats what happens with go users.
[18:39:36] <Sergio965> Go users are scared by the type system?
[18:39:52] <strcat> tiffany: "higher level language", like haskell or rust? ;p
[18:39:53] <tiffany> most users of languages like python feel that they don't need a powerful type system to be able to code sufficiently
[18:39:53] <Sergio965> The generics part, I guess.
[18:39:54] <doomlord> go was supposed to be a c/c++ replacement, but it gets used by python people more, hence go users hate rust, because its too close to C++
[18:39:57] <tiffany> well
[18:40:03] <tiffany> rust is considered a system's language, isn't it?
[18:40:08] <engla> tiffany: what do they think about C++?
[18:40:09] <tiffany> I had languages like python in mind
[18:40:32] <cmr> tiffany: I use lots of languages like python and I constantly wish for a better type system
[18:40:36] <tiffany> when I program in C it always makes me wish I had a better type system, better macro system, and type safety to work with, and all of those things are in rust
[18:40:37] <cmr> (here I am...)
[18:40:38] <strcat> tiffany: it has higher-level concepts than python
[18:40:40] <kimundi> It's hard to attract peaople if your language has 1.54e32 pointer types
[18:40:43] <doomlord> i would love a langauge that can do the job of C++ but which also had a bigger useful  interpretable subset..
[18:40:49] <kimundi> ;)
[18:40:51] <strcat> it's not really a binary distinction between low and high level
[18:41:01] <tiffany> "fast as C++ but without segfaults" is pretty attractive to C/C++ users
[18:41:02] <Sergio965> tiffany: Yeah, but Rust makes certain things overly complicated, in my opinion.
[18:41:06] <strcat> doomlord: you can interpret C++
[18:41:07] <doomlord> so the same language could be used for compiled & interpreted code & interpreted plugins
[18:41:11] <strcat> cling exists, it's better than rusti ;p
[18:41:31] <kimundi> Sergio965: I'd like to politely differ.
[18:41:42] <tiffany> rust is not overly complicated
[18:41:46] <doomlord> i haven't tried that, i have to admit i find it difficult to beleive it would be useful
[18:41:51] <bstrie> Sergio965: that all depends on your use case
[18:41:52] <cmr> Sergio965: I think rust does exactly what it needs to to get zero-overhead safety, and no more.
[18:42:07] <cmr> (well, plus fancy features like pattern matching and such)
[18:42:08] *** Joins: Altazimuth (Max@50582DF4.892388C2.9C6A40AF.IP)
[18:42:11] <tiffany> it is complicated by necessity, nearly all of the features of rust are things you eventually find yourself imlpementing manually in C
[18:42:13] <tiffany> or at least I do
[18:42:13] <Sergio965> tiffany: Isn't it, though? I tried creating a struct with a borrowed pointer and I had to spend a lot of time learning about lifetimes to implement it.
[18:42:16] <engla> don't know if it matters how many pointers you have, languages like Haskell and Python only have one single way of passing values and that's nice
[18:42:23] <kimundi> Sergio965: What do you see as overly complicated, apart from your wish for a non-C -like syntax?
[18:42:25] <Sergio965> tiffany: And it was a rather simply structure.
[18:42:31] <Sergio965> simple*
[18:42:36] <bstrie> Sergio965: ok, now trying doing that in C++ safely :)
[18:42:37] <tiffany> sergio: you tried creating a poitner to a struct in C and had to spend a lot of time learning about malloc() and how memory management works
[18:42:46] <doomlord> i wondered if HKTs could express pointer differences. even lifetimes..
[18:42:52] <Sergio965> bstrie: it was a very simple structure, and I did in C++ rather easily.
[18:43:06] <strcat> Sergio965: you still had to think about the lifetime in the same way in C++
[18:43:08] <strcat> if it was correct
[18:43:31] <kimundi> Sergio965: But the amount of effort you needed in rust prevented a whole class of bugs with your struct that could happen in C
[18:43:38] <bblum> dherman: ?
[18:43:41] <bblum> dherman: what slides?
[18:43:49] <Sergio965> strcat: Indeed, but only conceptually. I wasn't thinking, "this and that have to have the same lifetime, let me give them this name, declare it as a type,‚Ä¶", etc.
[18:43:52] <cmr> bblum: https://speakerdeck.com/dherman/rust-low-level-programming-without-the-segfaults
[18:43:55] <cmr> (http://www.reddit.com/r/rust/comments/1j3i2n/slides_from_david_hermans_presentation_at_oscon/)
[18:44:01] <tiffany> everything you need to know to use rust are things that you'll need to know to use C at a non-beginner level
[18:44:06] <doomlord> fn DoSomething<'a, 'b,A,B>(a:&'a A, b:&'b  B) ..  ----->     fn DoSomething<PA,PB,A,B>( a:PA<A>,b PB<B>) ...
[18:44:07] <Sergio965> I just thought, "Make sure this doesn't go null while i need it."
[18:44:15] <strcat> Sergio965: doesn't have to do with null
[18:44:18] <strcat> has to do with dangling pointers
[18:44:23] <tiffany> dangling pointers are much worse than nulls
[18:44:26] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[18:44:27] <Sergio965> I meant dangling pointer.
[18:44:32] <strcat> nullable pointers are pretty harmless in userland
[18:44:39] <strcat> they're just a segfault if you deref them
[18:44:42] <Sergio965> That's not the point...
[18:44:46] <tiffany> in rust, the type system forces you to think about how long you need an object
[18:44:54] *** Quits: sigma (sigma@2AE71BC1.DC5B0862.37339E3A.IP) (Ping timeout)
[18:44:57] <Sergio965> I made an error with my phrasing, I meant to say that it should be dangling.
[18:44:59] <tiffany> you get an informative compile error instead of a segfault
[18:45:13] <Sergio965> shouldn't*
[18:45:15] <strcat> tiffany: well with a dangling pointer you usually just get silent memory corruption
[18:45:19] <cmr> Sergio965: And the only thing making your C++ implementation safe is faith ;)
[18:45:28] <strcat> and you won't catch it without -fsanitize=address + the luck to catch a case hitting the flaw
[18:45:29] <doomlord> fn DoSomething..(a:&'a A, b:'a A,...)-> &'a A   ---->   fn DoSomethign<PA,A,B>( a:PA<A>,b:PA<A>, ...)-> PA<A> ...
[18:45:36] <Sergio965> cmr: Or the fact that I can read the code, understand what it does, and assure myself it's safe.
[18:45:37] <tiffany> would you rather spend 3 days looking for a segfault on the border between two different programming languages in a complex piece of software like a game engine, or just have an easy to fix compile-time error?
[18:45:45] *** Joins: sigma (sigma@2AE71BC1.DC5B0862.37339E3A.IP)
[18:45:58] <jedestep> how can I have rustpkg successfully link to a .dylib file I provide?
[18:46:00] <bblum> dherman: yes, rule number 1 on slide 49
[18:46:01] <cmr> Sergio965: That's faith. You're trusting nothing breaks your invariants, that you can understand every use, etc.
[18:46:12] <bblum> dherman: also i don't see slide numbers on that presentation so i have to count in my head
[18:46:18] <cmr> It's not *statically verified safety*
[18:46:19] <tiffany> nontrivial software will always escape your own understanding
[18:46:20] <Sergio965> I'm not saying I don't appreciate the compile-time guarantees provided by Rust - they're fantastic, all I'm saying, and my original argument was, that Rust makes it overly-complicated to use.
[18:46:20] <jedestep> it wants me to drop it in /usr/local/lib but then it doesn't find it if I put it there :I
[18:46:22] <cmr> So yes, Rust is more complex in this regard.
[18:46:26] <tiffany> you can never guarantee that you are a perfect programmer
[18:46:41] <bblum> oh i see them, you have to hover
[18:46:43] <strcat> well and the things that are undef behaviour in C++ will escape the understanding of most people
[18:46:47] <cmr> But it's not overly-complicated, it's just what it has to be to be safe.
[18:46:50] <doomlord> more compile time checks = less time writing tests
[18:47:05] <Sergio965> cmr: Perhaps it's simply not explained well enough in the documentation, and that was my issue.
[18:47:06] <strcat> template<typename T> struct foo { std::vector<foo<T>> children; }
[18:47:10] <tiffany> sure, rust may be more complex to write a calculator toy in, but it's better for you once you get past 1kloc of code
[18:47:11] <strcat> undefined behaviour
[18:47:28] <cmr> Sergio965: Sure, the documentation isn't the greatest.
[18:47:34] <paupau> try debugging a pointer corruption bug in a 1m video game codebase :)
[18:47:37] <doomlord> haskell is remarkable in how programs tend to  "just work" .. if you can get them to compile :)
[18:47:44] <kimundi> Sergio965: "complicated" - yes compared to other languages. "overly complicated" - That I wouldn't say. The devs try very hard to not include unnecessary things
[18:47:45] <tiffany> exactly paupau
[18:47:47] <Sergio965> cmr: Honestly, 90% of the issue was "what do I type to use this?"
[18:47:55] <cmr> And you basically need to know the whole type system in order to write a good Rust program
[18:47:57] <strcat> paupau: try figuring out whether you have one in the first place :)
[18:47:59] <tiffany> my own game engine is a bit over 10K of C and I've had some pretty nasty memory issues
[18:48:08] <strcat> paupau: you'll probably just get an isolated single bug report and never hear about it again
[18:48:10] <strcat> ;p
[18:48:13] <paupau> strcat: ;_;
[18:48:45] <strcat> try running -fsanitize=undefined or -fsanitize=address on a large program with clang
[18:49:06] <strcat> they hit heap corruption all the time - cairo, freetype, firefox, chromium, you name it
[18:49:09] <tjc> "segfault is a safety feature which prevents worse problems and tells you that you screwed up. There is no specific behavior that it would be better to replace segfault with, the whole problem is that the programmer has failed to specify something and the solution is necessarily that the programmer has to specify it."
[18:49:10] <tjc> lol reddit
[18:49:14] <kimundi> Sergio965: Your completly right that actually GETTING to the knowledge about how rust works and why it does certain things is very hard right now :)
[18:49:22] <Sergio965> kimundi: I suppose I'm of the belief that simple things should be simply to implement, and it's okay for complex things to have complex implementations. But I feel that in Rust, even simple things require a whole understanding of the system.
[18:49:31] <Sergio965> simple*
[18:49:42] <Sergio965> And that's okay.
[18:49:44] <tiffany> you can't just subvert the type system
[18:49:47] <cmr> Sergio965: Well it is simple.
[18:49:47] <tiffany> it breaks safety guarantees
[18:49:49] <bstrie> tjc: don't read reddit, it's poison for your brain
[18:49:51] <cmr> Sergio965: just use @ everywhere :)
[18:49:54] <tjc> bstrie: I try not to
[18:49:54] <tiffany> if you want a simple language, go user lua or something
[18:49:54] <Sergio965> Lol
[18:49:56] <kimundi> All simple things that don't have complex conseqenzes are simple in rust, I'd say
[18:50:00] <jedestep> how can I get rustpkg to successfully link to a library file that I provide?
[18:50:13] <cmr> tjc: ^
[18:50:17] <strcat> rent a tjc 
[18:50:20] <Sergio965> tiffany: Sorry, I don't mean to offend you, nor the language in itself. As a new user, these are similar my observations and feelings.
[18:50:35] <tjc> jedestep: rustpkg should be able to guess it automatically from `extern mod` directives, but if you want to put it someplace arbitrary, you need a patch that I haven't finished yet :-)
[18:50:38] <doomlord> +1, if rust wants to replace c++, it can't be much simpler,  it can do some of the same things more elegantly.
[18:50:46] <Sergio965> tiffany: I've worked with everything from assembly to Python, I've worked with the gamut of languages.
[18:51:01] <jedestep> tjc: should it be in the root directory? it asks me to put it in /usr/local/lib but putting it there solves nothing
[18:51:09] <jedestep> *project root directory
[18:51:13] <doomlord> there is un-necasery complexity IMO in c++ due to headerfiles, that can be cleaned up, and the class OOP system  is just terrible.
[18:51:17] <strcat> your /usr/local/lib might not be in your linker path
[18:51:19] <strcat> depends on the OS
[18:51:27] <doomlord> but complexity in memory/pointers has to stay
[18:51:38] <doomlord> as that is why the language exists
[18:51:40] <tjc> jedestep: hmm, 1 sec
[18:51:47] <toddaaro> bblum: pastebin.com/BCvBK4Uj
[18:52:00] <tiffany> you can't simplify the rust memory model because if you try to do that you get a language with java, which only allows heap allocation
[18:52:08] <tiffany> language like java*
[18:52:18] <strcat> well with escape analysis you can do simple cases of stack allocation
[18:52:26] <strcat> but you either have values on the stack or stuff managed by gc
[18:52:31] <doomlord> this is a gap which is why rust is interesting.
[18:52:59] <doomlord> a language with the precise control over memory c++ gives, but some orthogonal problems fixed
[18:53:12] <tiffany> yeah
[18:53:15] <kimundi> rust should remain as it is simply for the reason that it's kinda unique right now.
[18:53:15] <doomlord> cleaner syntaax, better organization etc
[18:54:09] *** Quits: libertas (libertas@moz-6F68A62F.net.novis.pt) (Ping timeout)
[18:55:05] *** Quits: tchoma (tchoma@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: My MacBook has gone to sleep. ZZZzzz‚Ä¶)
[18:55:11] <doomlord> go fills the 'simple' niche ( native code/gc )
[18:55:22] <tiffany> well, D also fills that niche
[18:55:42] <tiffany> or at least tries to
[18:56:02] <tjc> jedestep: this is all stuff I'm working on right now -- for now, probably do what strcat suggested (adjusting your linker path). sorry, it happens to be a time when stuff is in flux!
[18:56:27] <strcat> if it's because /usr/local/lib/ isn't in the linker path you can add it to /etc/ld.so.conf
[18:56:32] <jedestep> hmm ok
[18:56:37] <strcat> also... note that you need to run 'ldconfig' after adding a library to the linker path
[18:57:02] <strcat> it really just reads /etc/ld.so.cache
[18:57:18] <strcat> package managers hide all of this from you
[18:57:35] <strcat> because if they install a library or update the soname they will regenerate that cache
[18:57:49] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[18:59:56] <doomlord> r.e. compile times, does the cleaner syntax make some sort of progressive compiler theoretically possible (thinking of templates).. eg parse individual sources, figure  out dependancies, work on chunks of the ast up to a certain level..
[18:59:59] *** Joins: tchoma (tchoma@moz-BE33DA21.fw1.sfo1.mozilla.net)
[19:00:20] <cmr> doomlord: I think it does
[19:01:01] <cmr> doomlord: and that's basically what incremental compilation is going to do
[19:01:10] <cmr> (incremental compilation is planned)
[19:02:19] <doomlord> funny how in C++ you can sometimes get 'unity builds' faster than a build all with seperated object files
[19:02:39] <strcat> doomlord: well that's probably true in most languages
[19:02:42] <Sergio965> Hooray for unity builds!
[19:02:55] <strcat> splitting stuff up will increase the *overall* compile time
[19:03:01] <strcat> but you get incremental builds in exchange
[19:03:19] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[19:03:55] <strcat> 1 massive file vs. everything with LTO is essentially the same result, but LTO is going to take longer
[19:04:00] <jedestep> so naturally, because I'm on MacOS there is no ld.so.cache and dyld has no equivalent
[19:04:03] <jedestep> thanks apple
[19:04:10] <cmr> jedestep: LD_LIBRARY_PATH ?
[19:04:12] <strcat> jedestep: maybe it's not cached then
[19:04:16] * strcat shrugs
[19:04:17] <jedestep> cmr: didn't work :S
[19:04:25] <jedestep> neither did DYLD_LIBRARY_PATH
[19:04:40] <jedestep> oh well. hooray for makefiles
[19:04:53] *** Quits: paupau (textual@417F0514.289B9BF9.F20F0C5A.IP) (Ping timeout)
[19:05:29] <strcat> I should really switch my rust package to building stage3
[19:05:36] <strcat> and share the matching host/target libs
[19:05:47] <strcat> Installed Size : 96373.00 KiB
[19:05:50] <strcat> Installed Size : 75106.00 KiB
[19:05:57] <strcat> that's from replacing the second LLVM with a symlink
[19:06:33] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[19:08:32] <sam113101> "Single-statement, unbraced bodies are not allowed." ‚Äî Why is this?
[19:08:49] *** Quits: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net) (Quit: carllerche)
[19:08:51] <cmr> sam113101: if expr expr
[19:08:53] <bstrie> sam113101: because we don't require parens around the if/while conditions
[19:08:56] <cmr> sam113101: if expr { expr }
[19:09:00] <cmr> One is ambiguous, one is not :)
[19:09:16] <strcat> that's why C requires parentheses around those
[19:09:30] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[19:10:04] <sam113101> and why choose mandatory brackets over mandatory parentheses?
[19:10:17] <cmr> YOu always pay for parens
[19:10:29] <cmr> You only pay for the extra backets sometimes
[19:10:32] <bstrie> sam113101: because mandatory brackets is less error prone and optional parens are more often applicable
[19:10:51] <sam113101> makes sense
[19:11:49] <Luqman> mark_edward: pong
[19:12:14] *** Quits: lkuper (lkuper@5188CCE.A402E718.C082B7DC.IP) (Quit: lkuper)
[19:12:45] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Ping timeout)
[19:14:09] *** Quits: mye (mye@moz-FFDA3A47.dip0.t-ipconnect.de) (Quit: mye)
[19:17:03] <toddaaro> graydon: is there a flag to not run bench tests on make check?
[19:17:14] <graydon> not an easy one
[19:17:17] <graydon> why
[19:17:18] <graydon> ?
[19:17:39] <toddaaro> quickly running tests is a fair bit harder as it now quickly runs tests then churns through benches for a few minutes
[19:17:52] <graydon> ???
[19:18:04] <graydon> minutes?
[19:18:17] <engla> benches are much slower per item than tests at least
[19:18:28] <toddaaro> something like "make check-stage1-std"
[19:18:39] <toddaaro> oh, I'm building without optimize on the benches
[19:19:00] <engla> toddaaro: you can use TESTNAME=key  to only run tests that match key though
[19:19:07] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[19:19:29] <toddaaro> engla: I might be able to finagle the tests I want that way
[19:19:29] * strcat doesn't bother going through 'make' for that
[19:19:46] <strcat> you can compile the libstd test harness by itself
[19:20:03] *** Joins: BitPuffin (quassel@moz-49828767.cust.tele2.se)
[19:20:09] <strcat> unnecessary to build stage0 libstd/libextra/librustc
[19:20:13] <graydon> they should run for a maximum of 3 seconds each, unless the inner loop is implausibly long (too long for the benchmark runner to calibrate)
[19:20:31] <graydon> but I would recommend testing just the test you want with TESTNAME=test, yes
[19:20:42] <toddaaro> looks like 17 benches + test runs are 1m12s
[19:20:43] <graydon> if you run the test runner manually you can pass --test alone which disables bench
[19:20:49] *** Quits: Ralith (ralith@moz-50F3C77.vc.shawcable.net) (Ping timeout)
[19:20:51] <graydon> or --bench alone, which disables the non-bench tests
[19:21:11] <graydon> if you mention either --test or --bench it runs just the one you mention. if you mention neither it runs both.
[19:22:24] <strcat> if we had adequate tests it would take longer to run than it does now ;p
[19:22:44] <graydon> if you want to add Yet Another Make Var to control disabling the benchmarks within a make target, I guess we'll take that too
[19:23:06] *** Quits: Altazimuth (Max@50582DF4.892388C2.9C6A40AF.IP) (Quit: Leaving)
[19:23:22] *** Joins: seth (seth@moz-BE33DA21.fw1.sfo1.mozilla.net)
[19:24:13] <strcat> hrm, it's not obvious to me where fixed-size glue code is generated from
[19:24:18] <strcat> maybe we treat them as structs
[19:24:24] <strcat> fixed-size array*
[19:24:44] <mitsuhiko> hmm. yield in rust is going to be a bit tricky :(
[19:24:57] <strcat> mitsuhiko: well C# paved a way to do it
[19:25:10] <strcat> mitsuhiko: they have a state machine generator
[19:25:14] <bstrie> we just have to make sure it isn't patented
[19:25:21] <mitsuhiko> strcat: that's what i was looking at
[19:25:22] <Sergio965> Is there no way to create a struct and fill in the fields later?
[19:25:37] <toddaaro> graydon: would that just be an environment variable checked inside the makefile?
[19:25:38] <Sergio965> Like, let c: my_struct; c.field = 1; c.field2 = 3; etc?
[19:25:40] <cmr> Sergio965: no, no partially constructed values are allowed.
[19:25:42] <toddaaro> if so I could try a PR for that today
[19:25:43] <mitsuhiko> but that one is quite goto based :)
[19:25:46] *** Joins: HollyRain (HollyRain@moz-50A83091.dyn.user.ono.com)
[19:25:49] <Sergio965> Is there a reason for thsi?
[19:25:50] <Sergio965> this*
[19:25:52] <doomlord> reworking code such that things are always initialized is for safety
[19:25:52] <strcat> mitsuhiko: I'm happy we have the foundation of a nice iterator library at least :)
[19:25:54] <bstrie> mitsuhiko: we have labeled break, which is almost goto :P
[19:25:57] <doomlord> its the point of rust :)
[19:26:00] <cmr> Sergio965: because partially constructed values are invalud values.
[19:26:06] <strcat> I think if we added yield it would be a language feature
[19:26:10] <mitsuhiko> strcat: yep. awesome work!
[19:26:15] <strcat> mitsuhiko: thanks :)
[19:26:16] <cmr> Sergio965: you can fill in a default, constructed value, and then set the fields.
[19:26:19] <strcat> it'd be fairly impossible with a syntax ext
[19:26:22] <strcat> since it involves types
[19:26:26] <Sergio965> cmr: I see.
[19:26:29] <graydon> toddaaro: no, more like how TESTNAME is handled in mk/tests.mk
[19:26:36] <doomlord> modifying things is error prone
[19:26:36] <strcat> and if you wanted sane errors you would want to special case it in liveness/borrowck
[19:26:38] <strcat> it's a big project
[19:26:41] <bstrie> mitsuhiko: https://github.com/mozilla/rust/issues/7746
[19:26:55] <strcat> like, you can move from local variables
[19:27:01] <strcat> because they are persistent state
[19:27:11] <graydon> toddaaro: if you see below that, valgrind being set turns off CTEST_BENCH
[19:27:26] <graydon> you could add another thing like NO_BENCH for manually forcing it
[19:28:11] <mitsuhiko> bstrie: it's a lot more complex in rust though than in c# due to ownerships and stuff
[19:29:33] <HollyRain> since last release there have been more than 500 commits, it's awesome, is there a new Mozilla's full-time developer working on it?
[19:29:35] <mitsuhiko> graydon: btw wrt patents: don't look for them
[19:29:45] <mitsuhiko> that's the advise i got from people that know better than me
[19:29:45] <bstrie> HollyRain: interns!
[19:29:51] <cmr> HollyRain: since 0.7?
[19:30:01] <HollyRain> cmr, yes
[19:30:27] <cmr> There were 2854 commits between 0.6 and 0.7
[19:30:38] <cmr> 889 between 0.7 and now
[19:30:50] <cmr> it's almost been a month
[19:30:53] <cmr> 3 months between releases
[19:30:55] <cmr> seems about right :)
[19:32:04] <bstrie> when you put it that way it makes it seem like we're slacking
[19:32:07] * bstrie cracks the whip
[19:32:46] <strcat> mitsuhiko: well too late, but afaict they don't have the interesting parts patented
[19:32:55] <strcat> just a debugging process and an optimization process
[19:33:16] <tjc> graydon: re-r? https://github.com/mozilla/rust/pull/8032 -- addressed your comment
[19:33:42] <bstrie> strcat: excellent, that means we can patent it ourselves
[19:34:07] <HollyRain> I started to writing a book about Rust using asiicdoc but I've no more spare time for it, and I'm not enough motivated since I'm very busy debeloping stuff
[19:34:09] <strcat> bstrie: well it shouldn't, since there's plenty of prior art and it's obvious and it's math
[19:34:11] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[19:34:15] <strcat> but the patent offices aren't competent so...
[19:34:16] <HollyRain> so if somebody is interested I could upload it to github after of clean it
[19:34:54] <bstrie> HollyRain: what kind of book?
[19:35:11] <HollyRain> to learn to use Rust
[19:35:14] <strcat> https://www.google.com/patents/US7937694?dq=C#+yield+from&ei=9M7yUeanIoGJqQHg5IC4Dw my eyes glaze over trying to read this
[19:36:17] <strcat> don't even want to know why they have a few paragraphs explaining a view on what OOP is
[19:36:59] <bstrie> "A computer-readable storage medium storing computer-executable instructions for causing a computer system programmed thereby to perform a method comprising..."
[19:37:01] <strcat> anyway afaik it would likely be LLVM violating this patent
[19:38:16] *** Joins: pcwalton (pcwalton@9B0BC9DC.71128241.F9E1BAE1.IP)
[19:38:16] *** ChanServ sets mode: +o pcwalton
[19:38:28] <cmr> pcwalton: bz was looking for you earlier
[19:38:38] <strcat> bstrie: keep looking down that list
[19:38:50] <bstrie> one of these days graydon and anders heljsberg will have to have a fancy dinner and talk about state machine patents
[19:39:00] <strcat> The computer-readable storage medium of claim 1, ...
[19:39:04] <graydon> bstrie: oh god :(
[19:39:05] <strcat> The computer-readable storage medium of claim 2, ...
[19:39:29] <strcat> can't they just define the term "file" and get on with it
[19:39:36] <bstrie> hahaha
[19:40:03] <mitsuhiko> interestingly enough the transformation that is described here: http://blogs.msdn.com/b/oldnewthing/archive/2008/08/12/8849519.aspx is different from the one in the language spec
[19:40:10] <strcat> anyway I don't think I was built with the concentration level to read this
[19:40:18] <mitsuhiko> though the language spec just defines what should happen and leaves it up for how to implement it
[19:40:48] <toddaaro> bblum: pastebin.mozilla.org/2717383
[19:41:06] <strcat> The storage 840 may be removable or non-removable, and includes magnetic disks, magnetic tapes or cassettes, CD-ROMs, CD-RWs, DVDs, or any other medium which can be used to store information and which can be accessed within the computing environment
[19:41:20] <cmr> carrier pigeons!
[19:41:30] <graydon> tjc: r+
[19:41:36] <tjc> graydon: thx
[19:41:37] <strcat> I wonder why they're talking about input devices at all
[19:41:42] <strcat> it seems completely irrelevant
[19:41:54] <strcat> I think they're describing what a computer is
[19:41:58] <mitsuhiko> strcat: probably company policy: file n patents per year, minimum length m words
[19:42:11] <strcat> A computing environment may have additional features. For example, the computing environment 800 includes storage 840, one or more input devices 850, one or more output devices 860, and one or more communication connections 870. An interconnection mechanism (not shown) such as a bus, controller, or network interconnects the components of the computing environment 800. Typically, operating system
[19:42:13] <strcat> software ...
[19:42:15] <strcat> blah blah
[19:42:17] <kimundi> "If you wish to specify a patent from scratch, you first have to define the universe."
[19:42:30] <mitsuhiko> (i recommend filing "method or aparatus to fuck yourself" in different forms in that situation)
[19:42:35] <strcat> ;p
[19:42:45] <toddaaro> "let mut x: Option<~T> = None;" and then later x = STUFF is giving a -D dead-assignment lint error, how do I get rid of that?
[19:42:47] <strcat> mitsuhiko: probably patented in several forms already
[19:42:58] <toddaaro> x set in a few places and returned
[19:43:02] <kimundi> toddaaro: Remove the = None
[19:43:14] <toddaaro> kimundi: oh, that is valid rust syntax? easy then
[19:43:19] <strcat> mitsuhiko: they also have a patent on... hashing
[19:43:54] <mitsuhiko> when did #rust start becoming a patent circlejerk? :)
[19:44:17] *** Joins: mye (mye@moz-FFDA3A47.dip0.t-ipconnect.de)
[19:44:20] <strcat> mitsuhiko: since 10 minutes ago :)
[19:44:51] *** Quits: tjc (tjc@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: zzzzzzzzzz)
[19:44:52] <strcat> but anyway my brain is mush now so there will be no more looking at google's patent search
[19:45:08] <sam113101> rustc takes a long time to compile
[19:45:25] <bstrie> sam113101: are you also compiling llvm?
[19:45:42] <sam113101> yes
[19:45:58] <cmr> Are you on Windows?
[19:46:01] <sam113101> even though I'm not sure what it is
[19:46:03] <kimundi> mitsuhiko: You started it. Good job! ;)
[19:46:05] <sam113101> ubuntu
[19:46:18] <cmr> sam113101: run `make -jX`, where X is how many cores your CPU has
[19:46:23] <mitsuhiko> kimundi: i'm already regretting it
[19:46:23] <mitsuhiko> :)
[19:46:41] <sam113101> cmr: I¬†should have done that earlier
[19:46:44] <sam113101> ;(
[19:46:49] * strcat is back on the search for this elusive take glue
[19:46:49] <cmr> sam113101: ctrl-c and do it again
[19:46:51] <kimundi> sam113101: llvm will allways take long. but unlike the rest of the compiler you usually just need to compile it once
[19:47:01] *** Quits: reyre (reyre@F2D29657.F60B0462.67AC9B1.IP) (Client exited)
[19:47:03] <cmr> sam113101: if you're in the llvm part you won't lose much if any time
[19:47:06] <sam113101> cmr: will it start where it left?
[19:47:08] <toddaaro> is there a way to make a struct generic over types that are the size of a pointer on the architecture?
[19:47:25] <cmr> toddaaro: no, the type system cannot do anything like that.
[19:47:29] <kimundi> toddaaro: You can make them generic over any types
[19:47:36] <sam113101> I'm compiling rust code right now
[19:47:40] <sam113101> so I think I'm past that
[19:47:41] <toddaaro> cmr: oh well
[19:47:42] <cmr> sam113101: ok, then too late
[19:48:02] <strcat> ugh
[19:48:08] <strcat> I think we treat fixed-size arrays as structs.
[19:48:12] <toddaaro> kimundi: the problem is to guarentee certain sizes so atomics work
[19:48:17] <strcat> so it just iterates over the elements as fields
[19:48:23] <strcat> and calls the take glue for each "field"
[19:48:26] *** Joins: echristo (echristo@DCF57675.D6CCE4AE.77834EAA.IP)
[19:48:39] <kimundi> toddaaro: That sounds like special atomic types/attributes to meec
[19:48:43] <strcat> probably just need to specialize it
[19:48:56] <toddaaro> kimundi: yea, I could just require T:Atomical or something
[19:49:12] *** Joins: TD-Linux (TD-Linux@E338EB99.2B4F0AE0.A0A36CCE.IP)
[19:49:32] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[19:49:33] *** Quits: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP) (Quit: Lost terminal)
[19:49:44] <toddaaro> could rust derrive an "atomicable" trait for anything of the correct size?
[19:49:55] <strcat> it would have to be a kind
[19:50:13] <strcat> and wouldn't we want something like what C++11 has?
[19:50:21] <bstrie> rusti: 255u8.to_i8()
[19:50:22] -rusti- -1
[19:50:38] <bstrie> rusti: 256u8.to_i8()
[19:50:39] -rusti- <anon>:7:9: 7:14 error: literal out of range for its type
[19:50:39] -rusti- <anon>:7          256u8.to_i8()
[19:50:39] -rusti-                   ^~~~~
[19:50:39] -rusti- error: aborting due to previous error
[19:50:39] -rusti- application terminated with error code 101
[19:50:49] <cmr> bstrie: where does that method come from? :s
[19:50:59] <toddaaro> we already have the c++11 atomic primitives, but it would be nice to make a data structure that is generic over things you can do atomics with, so ints, units, pointers
[19:50:59] <strcat> almost any type in C++ can be used with atomic<>
[19:51:10] <strcat> it's just specialized for certain types
[19:51:14] <toddaaro> yes - it is just a matter of specifying the interface
[19:51:15] <Sergio965> I broke it. :( Instructions.cpp:281: void llvm::CallInst::init(llvm::Value*, llvm::ArrayRef<llvm::Value*>, const llvm::Twine&): Assertion `(i >= FTy->getNumParams() || FTy->getParamType(i) == Args[i]->getType()) && "Calling a function with a bad signature!"' failed
[19:51:16] <bstrie> cmr: the int and uint files, I think. and I think they all just call `as i32` or whatever
[19:51:20] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[19:51:20] *** Joins: reyre (reyre@F2D29657.F60B0462.67AC9B1.IP)
[19:51:25] <strcat> toddaaro: the only requirement in C++ is TriviallyCopyable though
[19:51:27] <strcat> no size req
[19:51:28] <cmr> bstrie: how silly :\
[19:51:48] *** Quits: doener (doener@moz-121949B3.unitymediagroup.de) (Quit: leaving)
[19:52:00] <strcat> primitives are trivially copyable and then any aggregate without an explicit copy constructor is too
[19:52:07] <toddaaro> strcat: I guess I don't want that then, you can put anything in if you indirect to it with a pointer, but I would like the "type the size of a pointer" case to not indirect
[19:52:07] *** Joins: nano (nano@moz-972880B.superkabel.de)
[19:52:37] <strcat> toddaaro: I don't think it will, they probably use enable_if
[19:52:40] *** Quits: seth (seth@moz-BE33DA21.fw1.sfo1.mozilla.net) (Input/output error)
[19:52:51] <toddaaro> strcat: where enable_if checks the size?
[19:52:55] <strcat> yes
[19:53:05] <toddaaro> ok, that sounds about right
[19:54:04] <strcat> in rust you could make an intrinsic
[19:54:10] <strcat> atomic_sized::<T>()
[19:54:14] <strcat> and just branch on it?
[19:54:24] *** Joins: seth (seth@moz-BE33DA21.fw1.sfo1.mozilla.net)
[19:54:26] <strcat> but you won't be able to restrict types
[19:54:30] <strcat> you'd have to have a fallback
[19:54:43] <cmr> I thought LLVM did this all for you?
[19:55:00] <strcat> cmr: in C++11, clang/llvm do all of it for you
[19:55:03] <cmr> ah
[19:55:29] <strcat> struct foo { int x; int y; double z; } std::atomic<foo>
[19:55:32] <strcat> it'll be fine with that
[19:55:44] <toddaaro> we do have the C++11 style llvm primitives though, so what exactly are we missing?
[19:56:06] <toddaaro> is it just this "atomic_sized" intrinsic?
[19:56:29] <strcat> I guess, I don't know exactly how they handle large types though
[19:56:45] <strcat> and their solution generates better IR before optimization, not that it really matters
[19:58:42] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[19:59:36] <mitsuhiko> strcat: wrt yield. Would you make it auto generate the struct?
[19:59:42] <mitsuhiko> and just leave off the return value?
[20:00:00] <strcat> mitsuhiko: yeah, it would generate a struct with a next method in the impl
[20:00:10] <mitsuhiko> what about size_hint?
[20:00:19] <strcat> mitsuhiko: just the default
[20:00:29] <kimundi> mitsuhiko: I personally would say that you'd have a special fn signature that includes the struct name definition
[20:00:47] <mitsuhiko> kimundi: and the struct then appears next to the method automatically?
[20:00:54] <kimundi> yield fn foo() -> struct FooIterator { ... }
[20:00:58] <kimundi> yeah
[20:01:10] <kimundi> like a macro that expands to multible items
[20:01:24] <kimundi> pub yield fn foo() -> priv struct FooIterator { ... }
[20:01:28] <strcat> it wouldn't be a syntax ext though
[20:01:50] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[20:02:11] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[20:02:12] <kimundi> strcat: same thing, one ast node that expands to a rewritten fn and a struct definition
[20:02:31] <kimundi> it wouldn't work as a se, that is true
[20:02:39] <strcat> it has to run after typechecking
[20:03:05] *** Joins: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net)
[20:03:52] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Ping timeout)
[20:04:01] <strcat> I think you would have pretty unreadable errors otherwise
[20:05:11] <Sergio965> Is there a way to get stabs or dwarf debug data in the resulting binary?
[20:05:37] <cmr> Sergio965: dwarf via -Z debug-info
[20:05:41] <pcwalton> just FYI, I am kicking around a strawman proposal for compile time function evaluation
[20:05:52] <cmr> You probably want -Z extra-debug-info, but not everything is implemented
[20:06:05] <bblum> pcwalton: as in, you don't really want CTFE? or you do?
[20:06:11] <pcwalton> not fleshed out yet, it's based on Scheme and Template Haskell, dherman thinks it works
[20:06:19] <toddaaro> pcwalton: so just do some abstract interpretation when you can?
[20:06:25] <pcwalton> but we haven't really discussed
[20:06:37] <pcwalton> bblum: we do want CTFE probably in Rust 2.0 or something
[20:06:41] <strcat> pcwalton: does it basically let you define a syntax extension inline with the other code?
[20:06:43] <pcwalton> but it should be principled
[20:06:49] <bblum> pcwalton: ok good, yes, agreed
[20:06:50] <kimundi> strcat: What I meant is, both macros that expand to multible items and a yield fn would have to be implented as the same kind of flat grouping in the ast
[20:07:04] <pcwalton> strcat: yes, also allowing macros to eval and typecheck their arguments
[20:07:15] <Sergio965> cmr: Thanks.
[20:07:21] <pcwalton> and "uneval" (Lift) the result back into an AST
[20:07:21] *** Joins: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP)
[20:07:33] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[20:08:08] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[20:08:28] <pcwalton> integrating it into the macro system makes me happy because (a) this is how scheme does it and is fairly well studied (see the 'partial evaluation' literature, although I don't propose anything nearly that complex); (b) you can define custom syntax for your CTFE functions, which is more powerful than C++11 or D
[20:08:34] <pcwalton> (c) it's fewer moving parts
[20:08:47] <cmr> Custom syntax?
[20:08:53] <cmr> Like, DSLs? Metaprogramming?
[20:08:59] <sam113101> sam@fievel:~% rust run test.rs
[20:09:01] <pcwalton> yeah, that's an example
[20:09:01] <sam113101> zsh: command not found: rust
[20:09:03] <sam113101> dammit
[20:09:04] <pauls> cmr: yes, yes!
[20:09:10] <cmr> sweeeeeet
[20:09:17] <cmr> sam113101: `make install`?
[20:09:39] <pauls> cmr: macros are just embedded DSLs with awesome integration into the host language.
[20:09:44] <strcat> pcwalton: and you can clearly see what runs at compile-time from the !
[20:09:48] <pcwalton> yes
[20:09:50] <sam113101> cmr: I¬†did that
[20:09:54] <strcat> in C++ it's not really clear
[20:09:55] <pcwalton> the staging problems are solved
[20:10:03] <pcwalton> brb
[20:10:24] <jclements> pauls: apropos: make check now (finally, ugh) succeeds for macros with hygiene on let-vars. Now I just need to enter rebase hell....
[20:10:35] <pauls> jclements: YES!
[20:10:36] <kmc> sam113101: perhaps /usr/local/bin is not in your PATH
[20:10:44] <pauls> HYGIENE!
[20:11:34] <sam113101> kmc: there's nothing rust-related there
[20:11:42] *** Quits: pcwalton (pcwalton@9B0BC9DC.71128241.F9E1BAE1.IP) (Ping timeout)
[20:12:13] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[20:12:15] <kimundi> jclements: What exactly does it do in the end? Replace all let names with not conflicting ones?
[20:12:41] <sam113101> ok I¬†had to run it as root as the guide states
[20:13:15] <sam113101> OH MY GOD, MY FIRST RUST PROGRAM
[20:13:25] <jclements> kimundi: short answer: read MTWT (Macros that Work Together), or dybvig. Hinty slightly longer one: all bindings are renamed as they're encountered; macro-introduced bindings don't conflict with those from the caller's environment, unless the introduced reference is to an actual shared variable.
[20:14:26] <cmr> graydon: I'm pestering you about https://github.com/mozilla/rust/pull/8009
[20:14:37] <mitsuhiko> strcat: one of the problems i see with yield in rust is that the iterator might be generic
[20:15:14] <mitsuhiko> if yield fn enumerate<B, U: Iterator<B>>(iter: U) -> EnumerateIterator { ‚Ä¶ } is all you define
[20:15:20] <graydon> cmr: thanks for the reminder~
[20:15:34] <mitsuhiko> then it would expand to fn enumerate<B, U: Iterator<B>>(iter: U) -> EnumerateIterator<U>
[20:15:38] <mitsuhiko> which would be very odd
[20:15:44] <graydon> cmr: it'll be after lunch but I will try. still fixing buildslaves.
[20:16:06] <kimundi> mitsuhiko: I imagine a compiler error that tells you to specify the necessary type params yourself
[20:16:31] <mitsuhiko> kimundi: but how does the user which ones?
[20:16:34] <kimundi> yield fn enumerate<B, U: Iterator<B>>(iter: U) -> struct EnumerateIterator<U> { ‚Ä¶ }
[20:16:40] <mitsuhiko> note how B for instance is not on the enumerate iterator
[20:16:50] *** Quits: reyre (reyre@F2D29657.F60B0462.67AC9B1.IP) (Client exited)
[20:17:06] <pauls> kimundi: more philosophical answer: it ensures that, if you choose different names while writing code, you'll still get the same results.
[20:17:35] <kimundi> pauls: Yeah, I think I get it :)
[20:18:06] <graydon> bors is disabled for the next little bit; restarting the slaves
[20:18:14] <mitsuhiko> the other issue i see is that local scope can be things that a struct member cannot do
[20:18:18] <mitsuhiko> for instance being uninitialized
[20:18:29] <mitsuhiko> s/can be/can do
[20:18:31] <pauls> (that answer was sort of a lie, but it has its heart in the right place)
[20:19:39] *** Quits: metasyntax (tvenable@moz-63D9B3D.med-web.com) (Quit: Leaving)
[20:19:41] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[20:19:45] <kimundi> mitsuhiko: I'm not sure if there is a better system other than 'let the user try to figure it out on his own based on the iterator code he wrote, and yell at him it compiletime if he got it wrong'
[20:20:25] <mitsuhiko> c# gets away with it because it never needs to expose the type. It'a s random Enumerator subclass and dynamic dispatch does the rest
[20:20:31] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[20:22:27] <engla> regarding that, maybe the iterator adaptors can be renamed to drop the 'Iterator' suffix. We have namespaces, and when using them it's nicer to use  Map<Filter<A, B, Enumerate<T>>>
[20:22:32] <kimundi> mitsuhiko: about scope... I'd guess that the fn gets checked like it is a regular one, but instead of accessing variables on the stack, they access private variables in the struct
[20:22:57] <mitsuhiko> kimundi: not possible because the one scope gets broken up into separate ones
[20:23:20] <kimundi> break the struct scope into an enum then :P
[20:23:23] <strcat> mitsuhiko: yeah but it can deal with turning those into fields
[20:23:29] <strcat> the fields don't actually need names
[20:23:32] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[20:23:37] <mitsuhiko> strcat: i don't see how that would work in all cases
[20:23:42] <mitsuhiko> at least not with the c# transformation
[20:23:45] *** Quits: HollyRain (HollyRain@moz-50A83091.dyn.user.ono.com) (Quit: bye, bye)
[20:23:51] <mitsuhiko> c# pre initializes all variables, so that's fine.
[20:23:52] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[20:24:05] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[20:24:08] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[20:24:22] <toddaaro> rusti: [0, ..3]
[20:24:23] -rusti- [0, 0, 0]
[20:24:39] <mitsuhiko> it's perfectly valid in rust to just write "let x" and then set x later
[20:24:50] *** Joins: mib_opy018 (Mibbit@2180800B.21468E9A.30200F38.IP)
[20:24:58] <mitsuhiko> if that later is after a state change however ...
[20:25:08] <kimundi> mitsuhiko: wich means you'd get a struct with an uninit field x that gets init later
[20:25:12] <strcat> mitsuhiko: well you'd need different typechecking rules
[20:25:14] <strcat> for generators
[20:25:20] <strcat> mitsuhiko: for example, you can't move from a local
[20:25:24] <strcat> because it's really a struct field
[20:25:36] *** Quits: mib_opy018 (Mibbit@2180800B.21468E9A.30200F38.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[20:25:47] <kimundi> mitsuhiko: Alterantive: break the iterator state up into enum members thet each only contain init values
[20:26:06] <mitsuhiko> i think what i'm thinking is that yield fn will look very different than fn
[20:26:29] <mitsuhiko> if it does not for the user, then at least it will for the compiler
[20:26:48] <kimundi> sure, the compiler will have to do a lot of magic
[20:27:12] <strcat> mitsuhiko: yeah I agree
[20:27:20] <strcat> it can't just be implemented as sugar
[20:27:30] <mitsuhiko> the whole beauty of the c# style transformation is that it's sugar with very simple rules
[20:27:34] <kimundi> strcat: I wonder if it'd be possible to specifiy a double ended iterator with a yield fn...
[20:27:38] <mitsuhiko> i don't think we get that luxury
[20:27:56] <strcat> kimundi: not really, you wouldn't want to
[20:28:00] <kimundi> mitsuhiko: got a link to what c# does?
[20:28:14] <mitsuhiko> kimundi: the nicest explanation is this one: http://blogs.msdn.com/b/oldnewthing/archive/2008/08/12/8849519.aspx
[20:29:03] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[20:29:22] *** Joins: lkuper (lkuper@E0D3ECD7.A402E718.C082B7DC.IP)
[20:29:37] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.1)
[20:31:01] *** Joins: steven_is_false (user@C5B76363.1FF1EBF8.1ECA502.IP)
[20:31:11] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[20:34:35] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[20:34:49] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[20:36:11] <kmc> i have to 'use' a trait by name to bring its methods into scope?
[20:36:25] <cmr> kmc: yes.
[20:37:45] <kmc> ok
[20:40:08] *** mihneadb|lunch is now known as mihneadb
[20:43:40] *** Joins: pcwalton (pcwalton@9B0BC9DC.71128241.F9E1BAE1.IP)
[20:43:40] *** ChanServ sets mode: +o pcwalton
[20:45:19] *** Quits: igl1 (igl@moz-31E38142.adsl.alicedsl.de) (Connection reset by peer)
[20:46:52] *** Parts: Earnestly (earnest@2AB30F53.FB5005.2BCC804A.IP) (WeeChat 0.4.2-dev)
[20:47:35] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[20:48:20] *** Quits: robarnold (rob@BD56354E.DB510C09.6E370BFC.IP) (Ping timeout)
[20:50:29] <bstrie> rusti: str::with_capacity(10)
[20:50:31] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/iHWR
[20:50:43] <bstrie> rusti: std::str::with_capacity(10)
[20:50:43] -rusti- ~""
[20:50:50] <doomlord> could you theoretically have an option to compile rust with unsafe stack for direct linking to c/c++ with no shim (thinking of mixed language projects) .. of course the reverse would also be nice.. compile C++ in a directly rust-compatible way
[20:51:23] <steven_is_false> you mean runtimeless rust?
[20:51:27] *** Quits: sebcrozet (sebcrozet@moz-6DA639AF.w80-13.abo.wanadoo.fr) (Quit: Gone)
[20:51:53] *** Quits: pcwalton (pcwalton@9B0BC9DC.71128241.F9E1BAE1.IP) (Quit: pcwalton)
[20:51:53] <doomlord> not sure what the implication of that is for the runtime, but possibly 
[20:52:14] <doomlord> (oh,it would need an entire unsafe stack runtime too)
[20:52:26] <doomlord> (so possibly .. yes runtimeless subset)
[20:52:36] <steven_is_false> There was a post about calling rust from ruby
[20:53:01] *** Joins: ecr (Thunderbir@moz-F724119C.uoregon.edu)
[20:53:16] <bstrie> rusti: let mut s = "f"; s.push("f"); s
[20:53:16] -rusti- <anon>:7:26: 7:38 error: type `&'static str` does not implement any method in scope named `push`
[20:53:17] -rusti- <anon>:7          let mut s = "f"; s.push("f"); s
[20:53:17] -rusti-                                    ^~~~~~~~~~~~
[20:53:17] -rusti- error: aborting due to previous error
[20:53:17] -rusti- application terminated with error code 101
[20:53:33] <bstrie> rusti: let mut s = "f"; s.append("f"); s
[20:53:34] -rusti- <anon>:7:26: 7:40 error: type `&'static str` does not implement any method in scope named `append`
[20:53:34] -rusti- <anon>:7          let mut s = "f"; s.append("f"); s
[20:53:34] -rusti-                                    ^~~~~~~~~~~~~~
[20:53:34] -rusti- error: aborting due to previous error
[20:53:34] -rusti- application terminated with error code 101
[20:53:45] <bstrie> what's the appropriate way to build a long string efficiently
[20:53:47] *** Quits: flowsnake (flowsnake@moz-1918C33E.aztw.cable.virginmedia.com) (Quit: ZNC - http://znc.in)
[20:54:14] <kimundi> bstrie: with_capacity, and then lots of pushes
[20:54:19] <bstrie> push doesn't exist
[20:54:28] <engla> .push_str and .push_char
[20:54:33] *** Joins: pcwalton (pcwalton@33605CA4.9F929CFD.F9E1BAE1.IP)
[20:54:33] *** ChanServ sets mode: +o pcwalton
[20:54:33] <bstrie> aha
[20:54:35] <bstrie> thankee
[20:54:48] *** Joins: flowsnake (flowsnake@moz-1918C33E.aztw.cable.virginmedia.com)
[20:55:18] <kimundi> rusti: let mut x = ~""; x.push_str("foo"); x.push_char('œÄ'); x
[20:55:19] -rusti- ~"foo\u03c0"
[20:55:58] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[20:57:46] <steven_is_false> I was thinking of using a ramdisk to speed up Rust compile times. Has anyone tried this yet?
[20:57:55] <cmr> steven_is_false: wouldn't help
[20:58:05] <cmr> almost no time is spent in IO
[20:58:10] <steven_is_false> dang.
[20:58:24] <steven_is_false> Is most of the the time spent in Rust, or LLVM?
[20:58:29] <doomlord> help them write incrental build :)
[20:58:34] <cmr> depends on the size of the program
[20:58:38] <cmr> for rustc it's mostly llvm
[20:58:43] <cmr> See http://huonw.github.io/isrustfastyet/mem/
[20:58:50] <steven_is_false> doomlord: That will only help rebuilds not complete builds.
[20:58:54] <cmr> (You can select a commit and check "passes" to see the -Z time-passes information)
[20:59:03] *** Quits: flowsnake (flowsnake@moz-1918C33E.aztw.cable.virginmedia.com) (Ping timeout)
[20:59:41] *** Quits: Nefzaoui (chatzilla@429AD06F.4FBEB140.D9343D67.IP) (Quit: ChatZilla 0.9.90.1 [Firefox 22.0/20130618035212])
[20:59:47] <cmr> steven_is_false: Generating less IR is basically the only thing that will bring down LLVM time
[20:59:52] <cmr> gives their optimizers an easier job
[21:00:10] <cmr> we do generate unnecessary IR, especially around transmute
[21:00:14] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[21:00:20] <cmr> `match` codegen seems to be problematic too
[21:01:00] <steven_is_false> cmr: Hold up, there are two parts to the chain. SOURCE -> TOKEN STREAM -> AST -> LLVM IR -> MACHINE CODE
[21:01:01] *** Joins: tjc (tjc@moz-BE33DA21.fw1.sfo1.mozilla.net)
[21:01:01] *** ChanServ sets mode: +o tjc
[21:01:23] <cmr> steven_is_false: yes?
[21:01:35] <doomlord> i imagine the middle is the most complex part.. type inference, templates,etc..?
[21:01:50] <doomlord> stages between AST and LLVM IR
[21:01:55] *** Quits: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP) (Quit: buildmaster reconfigured: bot disconnecting)
[21:02:02] <steven_is_false> cmr: It may be more appropriate to reduce the size of the generated AST rather than the LLVM IR.
[21:02:12] <cmr> Look for yourself: http://huonw.github.io/isrustfastyet/mem/#766eb95
[21:02:15] <cmr> steven_is_false: our AST is fine.
[21:02:18] <steven_is_false> Maybe all the low hanging fruit have been picked there already though.
[21:02:20] <saati> cmr: what's the lower graph?
[21:02:28] <cmr> saati: memory/time for the selected commits
[21:02:42] <saati> ah
[21:02:45] *** Joins: paupau (textual@417F0514.289B9BF9.F20F0C5A.IP)
[21:02:53] <cmr> Select the "passes" checkbox in the card on the right to view pass timing information
[21:03:03] <cmr> steven_is_false: well, the data our AST represents is fine
[21:03:06] <kimundi> cmr: btw what happend to the old data?
[21:03:12] <cmr> steven_is_false: the AST representation itself could use some work
[21:03:15] <cmr> kimundi: new benchmarker
[21:03:22] <cmr> kimundi: it's still there: http://huonw.github.io/isrustfastyet/mem/#766eb95
[21:03:24] *** Joins: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP)
[21:03:34] *** Quits: ssbr (ssbr@moz-141F89C6.block0.gvtc.com) (Ping timeout)
[21:03:45] <kimundi> ah, I see
[21:03:48] <steven_is_false> I wonder if it'd be possible to compile LLVM IR in parallel?
[21:03:53] <kimundi> rust-buildbot: dance
[21:03:54] <rust-buildbot> <(^.^<)
[21:03:55] <rust-buildbot> <(^.^)>
[21:03:56] <rust-buildbot> (>^.^)>
[21:03:56] <rust-buildbot> (7^.^)7
[21:03:58] <rust-buildbot> (>^.^<)
[21:04:05] <cmr> steven_is_false: dunno... acrichto enabled multithreaded llvm
[21:04:21] <cmr> maybe function optimization can happen in parallel?
[21:04:26] <cmr> before whole-program optimization?
[21:04:30] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[21:05:15] <cmr> you'd have to ask llvm people or maybe strcat :)
[21:05:33] <cmr> steven_is_false: parallelization doesn't fix the problem though, it just puts a bandaid on it
[21:05:45] *** Joins: ssbr (ssbr@moz-141F89C6.block0.gvtc.com)
[21:06:23] <steven_is_false> Yup
[21:06:24] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[21:06:39] <acrichto> right now the way we use LLVM prohibits us from using it in parallel intra-crate, what I did was to enable inter-crate parallelism (two crates compiling at the same time in different tasks)
[21:06:57] *** Joins: flowsnake (flowsnake@moz-1918C33E.aztw.cable.virginmedia.com)
[21:07:07] *** Quits: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com) (Input/output error)
[21:07:14] <acrichto> in llvm you're basically serialized inside of an LLVMContext, so if you have two LLVMContexts you can parallelize, otherwise you're stuck using LLVM serially within a context (at least from what I understand)
[21:07:15] <cmr> acrichto: we can compile multiple crates at a time?
[21:07:32] <acrichto> cmr: yes, that's what something like rusti unit tests do
[21:07:39] <acrichto> and possibly the rustpkg ones as well
[21:07:41] *** Quits: petermanser (petermanse@moz-9F810B0F.yourvserver.net) (Ping timeout)
[21:08:07] <acrichto> like you could always compile multiple crates in separate processes, but a threadsafe llvm allows you to do it all within the same process
[21:08:21] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[21:09:40] <graydon> PHEW all buildslaves updaed
[21:09:42] <graydon> updated even
[21:09:50] <graydon> that was tedious
[21:10:51] <steven_is_false> I think one thing that will speed up compiles is when rust pkg gets good enough to be used with Rust. Then it will be a lot easier to parallelize at the coarse level.
[21:11:02] <cmr> steven_is_false: not really?
[21:11:08] <steven_is_false> As I understand it make -j4 isn't very goo right now.
[21:11:23] <steven_is_false> Maybe I'm wrong though.
[21:11:25] <cmr> steven_is_false: it's not very good because rustc's dependencies are serial until after librustc
[21:11:39] *** Joins: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com)
[21:11:41] <cmr> you can't build anything in parallel because the dependencies for a chain
[21:11:42] <steven_is_false> Okay
[21:11:54] <cmr> std -> extra -> syntax -> rustc -> {rusti, rustdoc, rustpkg, ...}
[21:12:49] <kmc> in passing I got "error: Do-block body must return bool, but returns () here"
[21:12:55] <kmc> is it actually true that do-block bodies return bool?
[21:13:20] <cmr> rusti: fn foo(f: &fn()) { f(); } do foo { 3; }
[21:13:21] -rusti- ()
[21:13:24] <cmr> rusti: fn foo(f: &fn()) { f(); } do foo { true }
[21:13:25] -rusti- <anon>:7:42: 7:50 error: mismatched types: expected `()` but found `bool` (expected () but found bool)
[21:13:25] -rusti- <anon>:7          fn foo(f: &fn()) { f(); } do foo { true }
[21:13:25] -rusti-                                                    ^~~~~~~~
[21:13:25] -rusti- error: aborting due to previous error
[21:13:25] -rusti- application terminated with error code 101
[21:13:25] <steven_is_false> kmc: The error message is unclear.
[21:13:31] *** Joins: jgilbert (jgilbert@moz-BBE3ABD.mv.mozilla.com)
[21:13:37] <steven_is_false> It should really be fixed.
[21:13:41] <cmr> rusti: fn foo(f: &fn() -> bool ) { f(); } do foo { true }
[21:13:41] -rusti- ()
[21:13:44] <cmr> rusti: fn foo(f: &fn() -> bool ) { f(); } do foo { 5 }
[21:13:44] -rusti- <anon>:7:51: 7:56 error: mismatched types: expected `bool` but found `<VI0>` (expected bool but found integral variable)
[21:13:45] -rusti- <anon>:7          fn foo(f: &fn() -> bool ) { f(); } do foo { 5 }
[21:13:45] -rusti-                                                             ^~~~~
[21:13:45] -rusti- error: aborting due to previous error
[21:13:45] -rusti- application terminated with error code 101
[21:14:04] <cmr> steven_is_false: is it refering to the for-loop protocol?
[21:14:36] <steven_is_false> cmr: Here is what the compiler is trying to say.
[21:14:40] <kimundi> kmc: Did you perhaps mean 'for'?
[21:15:05] <steven_is_false> One is doing something like do foo { bar() }
[21:15:17] <steven_is_false> the result of foo is bool
[21:15:46] <cmr> rusti: fn foo(f: &fn() -> bool ) -> bool { f(); } do foo { 5 }
[21:15:47] -rusti- <anon>:7:59: 7:64 error: mismatched types: expected `bool` but found `<VI0>` (expected bool but found integral variable)
[21:15:47] -rusti- <anon>:7          fn foo(f: &fn() -> bool ) -> bool { f(); } do foo { 5 }
[21:15:47] -rusti-                                                                     ^~~~~
[21:15:47] -rusti- error: aborting due to previous error
[21:15:47] -rusti- application terminated with error code 101
[21:15:49] <steven_is_false> But because the do foo { bar() } stuff needs a ; to ignore the result
[21:15:58] <steven_is_false> there is an error.
[21:16:04] *** Joins: robarnold (rob@BD56354E.DB510C09.6E370BFC.IP)
[21:16:07] <cmr> steven_is_false: kmc: what code reproduces it?
[21:16:31] *** Quits: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net) (Input/output error)
[21:16:47] <erickt> tjc: ping
[21:16:55] <steven_is_false> rusti: for [0u, 1, 2].iter().advance |x| { println(x.to_str()) }
[21:16:56] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/TgiY
[21:16:57] <tjc> erickt: pong
[21:16:58] <steven_is_false> rusti: do [0u, 1, 2].iter().advance |x| { println(x.to_str()) }
[21:16:59] -rusti- <anon>:7:42: 7:65 error: Do-block body must return bool, but returns () here. Perhaps you meant to write a `for`-loop?
[21:16:59] -rusti- <anon>:7          do [0u, 1, 2].iter().advance |x| { println(x.to_str()) }
[21:16:59] -rusti-                                                    ^~~~~~~~~~~~~~~~~~~~~~~
[21:16:59] -rusti- error: aborting due to previous error
[21:16:59] -rusti- application terminated with error code 101
[21:17:32] *** Joins: Ralith (ralith@moz-93655DD2.wireless.sfu.ca)
[21:17:37] <kimundi> well, that seems like a nice error messige
[21:17:38] <erickt> tjc: hey there! I stumbled upon a go packaging link on HN this morning you might find interesting: http://nathany.com/go-packages/
[21:18:15] <tjc> erickt: thanks; graydon based a lot of the design for rustpkg on go, but I haven't seen that particular link
[21:18:24] <erickt> tjc: I believe it's from the go package community talking about what they feel their package management system is missing
[21:18:33] <tjc> erickt: cool, bookmarking it
[21:18:36] *** Joins: tikue (tkuehn@moz-BE33DA21.fw1.sfo1.mozilla.net)
[21:18:58] <erickt> tjc: great, I hope it's useful :)
[21:19:09] *** Quits: jclements (jclements@moz-18551D9B.ngn.east.myfairpoint.net) (Quit: jclements)
[21:19:18] <steven_is_false> Do we compile LLVM with -O3, or -O2, and can we enable extra options to make things faster?
[21:19:19] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Quit: WeeChat 0.4.1)
[21:19:54] <cmr> steven_is_false: any improvement is going to be marginal compared to the speeded that could happen with some work in trans
[21:20:25] <steven_is_false> cmr: Yeah but adding in one extra flag to get an instant speed boost would be pretty nice.
[21:21:53] *** Quits: rlbaker (rlbaker@moz-C8EE266C.hfc.comcastbusiness.net) (Quit: Leaving)
[21:22:26] <graydon> erickt tjc: I'd caution about taking that document as guidance. it's stuck with problems of the go symbol format (non-versioned, non-hash-manged) which makes it difficult to combine 2 "different" copies of a package in a single binary. we specifically designed rust's linkage rules to avoid that restriction, permit that use-case.
[21:23:00] *** Joins: brson (brson@C0559334.C30B3942.8DDCAE07.IP)
[21:23:00] *** ChanServ sets mode: +o brson
[21:23:00] *** Joins: jmgrosen (jmgrosen@moz-A3814C08.sd.sd.cox.net)
[21:25:30] <graydon> naturally there are some use-cases where we can't save you from yourself (use of static globals that, even if symbol-safe from collision, you expect there to only be one of in a program) but in theory and I believe even practice the simple cases of extern mod'ing foo#1.0 in one place and foo#2.0 in another ought to work.
[21:25:56] *** Quits: Sergio965 (sergiobz@moz-8D70E596.wireless.csail.mit.edu) (Quit: My MacBook Pro has gone to sleep. ZZZzzz‚Ä¶)
[21:27:05] <erickt> graydon tjc: roger that. I'm not saying we should do what they suggest, but it's always interesting hearing a community talk about the limitations about their approach
[21:27:14] <graydon> certainly
[21:34:24] *** Quits: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP) (Quit: buildmaster reconfigured: bot disconnecting)
[21:34:24] *** Joins: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP)
[21:35:26] <brson> toddaaro: can you rebase #7951 and reenable the commented-out tests?
[21:37:06] <toddaaro> brson: which is 7951?
[21:37:21] <toddaaro> my PR is almost merged with bblum's code but still not quite there
[21:38:20] <toddaaro> brson: oh 7915, yea, we are working on it
[21:38:40] <brson> ok
[21:38:51] <mark_edward> Luqman: ping
[21:38:52] <bblum> brson: https://github.com/mozilla/rust/pull/8008
[21:38:52] *** Joins: aatch (aatch@moz-2BB0AC01.cable.telstraclear.net)
[21:39:08] <brson> bblum: thanks
[21:39:52] *** Joins: mihneadb_ (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net)
[21:42:24] <steven_is_false> Ugh, Can anyone help me with this problem? Compiling a hello world program withrustc hello.rs --link-args  -Wl,-O1,--sort-common,--as-needed,--hash-style=gnu works but it doesn't work with my more complicated project, and gives the error note: /usr/bin/ld: invalid hash style `--library=gcc' when trying to compile rust-sdl with rustc --opt-level=3 -Z debug-info "--link-args=-Wl,-O1,--sort-common,--as-needed,--hash-style=gnu"
[21:42:24] <steven_is_false> /home/steven/mine/documents/public/programming/projects/src/pX-x/rust-sdl/src/sdl.rc -o libsdl.dummy
[21:42:24] <steven_is_false>  
[21:42:39] <Luqman> mark_edward: pong
[21:43:05] <mark_edward> Luqman: hey! I noticed that you wrote the inline asm!() macro for rust, right?
[21:43:24] <Luqman> mark_edward: yes
[21:43:56] <mark_edward> Luqman: I figured you'd know this best: Is it possible to have an analogous inline LLVM IR feature?
[21:45:00] <steven_is_false> NVM it's a problem with quotations.
[21:45:05] *** Joins: reyre (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[21:45:09] <Luqman> mark_edward: i think it'd be possible
[21:45:26] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[21:45:40] <aatch> Luqman, you sure? LLVM doesn't have direct support for that kind of thing as far as I am aware.
[21:46:15] <doomlord> i wonder if they could do anything equivalent to intrinsics 
[21:46:30] <Luqman> aatch: i remember looking and thinking it was possible
[21:46:44] <doomlord> (eg simd intrinsics .. but they seemed keener on getting the compiler to generate things from a rust description)
[21:46:50] <sully> ok, so, is the plan for everything in rustrt to get moved to libstd?
[21:46:52] <sully> or what?
[21:47:04] <sully> and if I wanted to help murder the C++ rt, is there any good place to help?
[21:47:25] <aatch> sully, more of less. Though the rt stuff might still be in a separate library anyway.
[21:47:31] *** Joins: heftig (heftig@6835D69C.6FC4DE2F.FEC4A986.IP)
[21:47:36] <aatch> sully, and ask brson
[21:47:38] <mark_edward> Luqman: how hard do you think it'd be to do? Would it be similar to your asm! implementation? Could i help?
[21:47:57] <aatch> mark_edward, there's also the question of actually wanting to have it.
[21:48:08] <cmr> aatch: I think it'd be useful
[21:48:12] <Luqman> sully: one easy win might be getting rid of the mostly useless wrappers around the uv calls, though i think there were linker issues around it
[21:48:13] <cmr> Imagine:
[21:48:27] <cmr> non_rust_but_compiles_to_llvm_language! { ...... }
[21:48:50] <mark_edward> aatch: I know. I'd like to try putting it together. think about simple things being implemented in a std::iintrinsics module, bit rotation, shuffling, etc.
[21:49:02] <mark_edward> and cmr's brilliant idea
[21:49:08] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[21:49:34] <aatch> cmr, I disagree. LLVM IR is just that, an IR.
[21:49:39] *** Quits: Nisstyre (wes@moz-FD86289.netflash.net) (Quit: Leaving)
[21:50:08] <aatch> I'm really against hoisting that up into a language feature.
[21:50:10] <mark_edward> aatch: but it's an IR that's pretty easy to read compared to a lot of ISA's
[21:50:38] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[21:50:52] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[21:50:57] <cmr> aatch: I can't think of a legitimate use for it
[21:51:05] <cmr> but on "cool factor" it's definitely ranking up t here
[21:51:14] <doomlord> intrinsics are an interesting alternative to inline asm
[21:51:16] <aatch> mark_edward, it also has very, very limited use cases. LLVM codegen still relies on a variety of external settings.
[21:51:27] <mark_edward> aatch: what do you mean?
[21:51:28] <aatch> inline asm is far more useful.
[21:51:32] <brson> sully: my current intent is to remove all the scheduler related code from rustrt, port everything left that can be to rust, port the remaining glue from C++ to C, remove the C++ dependency, then statically link rustrt to std
[21:51:36] *** Quits: pcwalton (pcwalton@33605CA4.9F929CFD.F9E1BAE1.IP) (Quit: pcwalton)
[21:52:30] <brson> sully: the highest-impact project, besides deleting the scheduler, would be to create native rust bindings for mutexes, replacing lock_and_signal, then port all the little bits of glue that uses global mutexes in rust_builtin.cpp to rust
[21:52:47] <brson> that will entail redefining the platform-specific mutex structures in rust
[21:53:21] <brson> rust mutexes though don't rely on the 'and_signal' aspect of our C++ locks, so we just need the mutex bindings, not the cond vars
[21:53:48] <aatch> mark_edward, ASM is used because there are things you legitimately can't express in a higher-level language.
[21:54:07] <aatch> mark_edward, like the syscall ABI for example.
[21:54:18] <aatch> mark_edward, but you can't express that in LLVM either.
[21:54:22] <mark_edward> aatch: like bit rotation and shuffles? SIMD?
[21:54:51] <doomlord> ^those things can be expressed in intrinsics usefully and they're more useable that way
[21:54:53] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[21:55:04] <bblum> brson: 'native rust bindings for mutexes'? you mean bindings against libpthread?
[21:55:25] <bblum> wait, i thought we used _and_signal to block schedulers when there's no work left
[21:55:28] <doomlord> you've always got the option of writing real asm 
[21:55:37] <mark_edward> doomlord: still sounds wicked cool, and more portable...
[21:55:48] <aatch> mark_edward, in most cases, code that does stuff like that will be optimized down to a single instruction anyway.
[21:56:13] <Luqman> mark_edward: so if you did want to do it i imagine it'd be hooking up to llvm::ParseAssemblyString
[21:56:37] <mark_edward> Luqman: i see
[21:57:13] <aatch> GCC will turn this: "(NUM << AMOUNT) | (NUM >> (32 - AMOUNT))" into a single `roll` instruction.
[21:57:23] <aatch> I imagine clang will do the same.
[21:58:14] <aatch> bit manipulation that can be expressed in single instructions normally will be.
[21:58:24] <mark_edward> Luqman: where is the llvm rust code located?
[21:58:49] <strcat> in theory you can express loops in ways it will always optimize to SIMD
[21:59:00] <strcat> if you take ~[] by-value it gets marked as noalias
[21:59:01] <doomlord> i guess the compiler needs to be adept at that sort of thing to get the most out of arm s shift..
[21:59:36] <strcat> fn foo(xs: ~[T], ys: ~[U]) -> (~[T], ~[U]) { /* read from ys, write to xs, return them */ }
[21:59:42] <strcat> it could vectorize that
[21:59:50] <strcat> silly &const and @mut really ruin it
[21:59:52] <Luqman> mark_edward: there's src/rustllvm/ which wraps some of the c++ apis and src/librustc/lib/llvm.rs
[21:59:52] <jmgrosen> are we going to be able to build static binaries using the stdlib (e.g. not zero.rs) anytime soon?
[22:00:16] <cmr> jmgrosen: nobody is working on it afaik
[22:00:19] <aatch> jmgrosen, there's a (probably broken) -Z option for static libraries.
[22:00:30] <aatch> try that and report back?
[22:00:32] <brson> bblum: yes, pthread mutexes and windows. the old scheduler uses cond vars but no rust code using lock_and_signal does (the rust bindings to lock_and_signal don't even expose them)
[22:00:52] <bblum> oh that's right
[22:01:05] <bblum> and the new scheduler uses uv to block
[22:01:12] <bblum> (although i'm not convinced it's correct)
[22:01:20] <kmc> aatch: did you see the example where clang compiles isspace() into a lookup table expressed as a 64-bit immediate? seriously impressive
[22:01:39] <jmgrosen> cmr, aatch, "can't find crate for `std`"
[22:01:43] <aatch> kmc, no, but I agree, very impressive.
[22:01:51] <cmr> jmgrosen: you need a static copy of libstd first
[22:02:01] <jmgrosen> cmr: i should have guessed that >.<
[22:02:01] *** Joins: sebcrozet (sebcrozet@moz-87D51607.w80-13.abo.wanadoo.fr)
[22:02:10] <aatch> Ohh, that's gonna be interesting.
[22:03:14] <cmr> http://talks.golang.org/2013/oscon-dl.slide#1
[22:04:09] *** Joins: pcwalton (pcwalton@33605CA4.9F929CFD.F9E1BAE1.IP)
[22:04:09] *** ChanServ sets mode: +o pcwalton
[22:05:57] <mark_edward> Luqman: doe sit have anything to do with this http://llvm.org/docs/LangRef.html#inline-assembler-expressions
[22:06:09] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[22:06:20] <steven_is_false> How would I add --host-triples, and --target-triples to my configure to test out -mcpu=native -march=native for LLVM?
[22:06:41] <pcwalton> brson: ping
[22:07:03] <brson> pcwalton: pong
[22:07:43] *** Joins: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au)
[22:07:46] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[22:08:51] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[22:09:48] <jmgrosen> aatch: ok, got libstd statically compiled (have `std.o`), but it doesn't seem to be recognized even when i put it in the library path with -L
[22:10:00] <cmr> jmgrosen: you need to make a libstd.a with `ar`
[22:10:13] <jmgrosen> cmr: >.< sorry, haven't done much low-level dev work :P
[22:10:15] <cmr> jmgrosen: cc should be able to do it for you
[22:10:18] <cmr> I don't know how..
[22:10:30] <aatch> jmgrosen, use cc -static (I think)
[22:10:33] <cmr> cc -static -o libstd.a std.o I think?
[22:10:38] <aatch> jmgrosen, linking is hard.
[22:10:50] <aatch> jmgrosen, so don't worry about not knowing what to do.
[22:10:51] <cmr> Shouldn't need PIC or anything since it didn't make the code
[22:10:53] <jmgrosen> aatch: i know that from experience‚Ä¶ :3
[22:11:35] <jmgrosen> aatch: "ld: library not found for -lcrt0.o" ?
[22:12:14] <aatch> jmgrosen, hm... that's odd. crt0 is the entry point code.
[22:12:32] <aatch> (As in the code that actually gets called before even `main` on C)
[22:13:00] <aatch> jmgrosen, it shouldn't be trying to link to it.
[22:13:02] <kmc> unusual to include an extension with -l, wouldn't it be just -lcrt0
[22:13:12] <aatch> kmc, good point.
[22:13:13] <cmr> yes, it shouldn't be -l anything
[22:13:17] <kmc> but that would only work if there's crt0.a or crt0.so, and I think crt0.o is usually linked as a bare object file
[22:13:26] <cmr> it'd just include crt0.o directly
[22:13:26] *** Quits: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com) (Quit: Leaving)
[22:13:32] *** Quits: pcwalton (pcwalton@33605CA4.9F929CFD.F9E1BAE1.IP) (Ping timeout)
[22:13:32] <cmr> Why would libstd want it?
[22:13:35] <kmc> I'm not sure about using cc to produce .a files either, although maybe it works
[22:13:38] <cmr> Does libstd have an entry point?
[22:13:44] <aatch> cmr, nope
[22:13:45] <kmc> typically one uses 'ar' directly
[22:14:27] *** Quits: paupau (textual@417F0514.289B9BF9.F20F0C5A.IP) (Ping timeout)
[22:15:35] <kmc> on my Linux system I don't have crt0.o, only crt1.o and crti.o and crtn.o
[22:15:39] <kmc> the former has the entry point _start
[22:15:49] <cmr> yeah, I don't think I've seen crt0
[22:15:57] <cmr> probably shouldn't be using cc to link :p
[22:16:09] <kmc> I think I have seen it, but I'm not sure where or why
[22:16:23] <kmc> ime using cc / gcc for linking is usually the less painful route
[22:17:10] *** Joins: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com)
[22:18:39] *** Quits: sebcrozet (sebcrozet@moz-87D51607.w80-13.abo.wanadoo.fr) (Ping timeout)
[22:20:08] *** Quits: jmgrosen (jmgrosen@moz-A3814C08.sd.sd.cox.net) (Quit: jmgrosen)
[22:20:50] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[22:21:04] *** Quits: echristo (echristo@DCF57675.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[22:21:04] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Connection reset by peer)
[22:21:30] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[22:23:03] <kemurphy> is there a way to do what i'm trying to do with https://gist.github.com/kemurphy/6092653
[22:23:50] <kemurphy> (that gives me a "cannot move out of dereference of @ ptr" and a "cannot assign to immutable field")
[22:24:11] <acrichto> kemurphy: mutability stops at @ boundaries, so even though 'i' is mut, the contents are not mutable, all you an do is say 'i = ...'
[22:24:46] *** Quits: saml (sam@moz-14C16814.cst.lightpath.net) (Quit: Leaving)
[22:24:47] <kemurphy> acrichto: i see, so @ doesn't follow the typical inherited mutability scheme
[22:24:56] <bblum> right, mutability inherits through owned paths only
[22:25:00] <bblum> you can also not ever move out of an @ pointer
[22:25:04] <acrichto> kemurphy: that's what '@mut' is for
[22:25:08] <bblum> unless you have an option that you can replace with none, or some such
[22:25:38] <kemurphy> what about https://gist.github.com/kemurphy/6092665
[22:25:54] <kemurphy> also the move-out-of-@-box error with that
[22:26:35] <kmc> presumably you could move out of an @-box if you were willing to accept a runtime failure in the case where the refcount is not 1
[22:26:40] <kmc> but a) bleh b) not really compatible with GC
[22:26:52] <cmr> kmc: again, that's what @mut is
[22:27:07] <kmc> how so?
[22:27:17] <acrichto> kemurphy: your catch-all "n => n" is actually moving out of 'i.node' which isn't allowed
[22:27:20] <bblum> cmr: even @mut does not let you do that
[22:27:20] <cmr> @mut allows mutation at the cost of dynamic failure
[22:27:32] <kmc> it doesn't allow moving out, though, does it?
[22:27:35] <bblum> kmc: no
[22:27:37] <acrichto> kemurphy: I've run into this a lot and I would *love* if the compiler pointed to that for you
[22:27:45] <bblum> kmc: i mean, correct
[22:27:54] <kmc> I think what @mut gives you is different from my hypothetical (and inadvisable) feature
[22:27:55] <bblum> acrichto: file a bug?
[22:27:59] <engla> you would have to use util::swap() to get a value out of a @mut
[22:28:08] <acrichto> bblum: I think one already existed?
[22:28:11] * acrichto checks
[22:28:11] <cmr> ok, yes
[22:28:15] *** Quits: Guest (textual@BBE7C46A.B4F11D08.8612FA94.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz‚Ä¶)
[22:28:19] * cmr was only half payig attention
[22:28:56] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[22:29:04] <kemurphy> is there any way to turn @ into @mut?
[22:29:14] <cmr> kemurphy: not without copying
[22:29:16] <cmr> it'd be unsafe
[22:29:22] <kemurphy> figured
[22:29:33] <kemurphy> hm, so is there any way to do what i'm trying to accomplish here?
[22:29:52] *** Quits: brson (brson@C0559334.C30B3942.8DDCAE07.IP) (Ping timeout)
[22:30:12] <acrichto> kemurphy: each case could returned the mapped version of 'i' so the catch-all is "_ => i"
[22:32:08] <acrichto> wait kemurphy, with the catch-all of "n => n" what's the error message?
[22:32:23] *** Joins: paupau (textual@417F0514.289B9BF9.F20F0C5A.IP)
[22:32:28] <acrichto> kemurphy: oh, nevermind
[22:32:52] <acrichto> bblum: ah this was an issue and it was fixed, but only for ~ boxes, it seems @ boxes need some love in this respect
[22:33:22] <kemurphy> acrichto: http://pastebin.mozilla.org/2718275
[22:33:44] <kemurphy> so, i can work around the match i.node bit
[22:33:52] <acrichto> kemurphy: cool that's what I expected
[22:33:59] *** Quits: thpickert (thpickert@moz-34341F25.dynamic.dsl.tng.de) (Quit: thpickert)
[22:34:10] <kemurphy> but i can't mutate i.node, nor can i use the .. *i syntax when building a new struct
[22:34:14] <acrichto> kemurphy: it should be something like http://pastebin.mozilla.org/2718276
[22:34:20] <acrichto> (the error message)
[22:35:07] <kemurphy> acrichto: ref n => *n is also no good though, right?
[22:35:21] <acrichto> kemurphy: no, then you're moving out of an immutable '&' pointer
[22:35:24] <cmr> do a clone
[22:35:25] <kemurphy> right
[22:35:29] <kemurphy> :(
[22:35:32] <cmr> unless you actually need to be mutating
[22:35:34] <paupau> how do I prettyprint a libsyntax::ast::Crate?
[22:35:37] <cmr> in which case you're out of luck.
[22:35:37] *** Joins: brson (brson@C0559334.C30B3942.8DDCAE07.IP)
[22:35:37] *** ChanServ sets mode: +o brson
[22:35:38] <kemurphy> i don't need to
[22:35:47] <kemurphy> so yeah, .. copy *i?
[22:35:56] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[22:35:59] <cmr> i.clone()
[22:36:13] <cmr> or (*i).clone() depending on whether I know how auto-deref works or not
[22:36:18] <kemurphy> oh, right
[22:36:33] <strcat> you have to try extra hard to get &T -> &T
[22:36:35] <strcat> from clone
[22:36:47] <acrichto> kemurphy: bblum: https://github.com/mozilla/rust/issues/8064
[22:37:31] <bblum> acrichto: you are doing god's work
[22:38:06] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[22:38:09] <kmc> strcat: how do you do it?
[22:38:53] *** Joins: doener (doener@moz-121949B3.unitymediagroup.de)
[22:41:54] <strcat> kmc: clone &T?
[22:41:58] <bblum> strcat: what's the new way to do 'timesi'?
[22:42:07] <strcat> bblum: what was timesi? ;p
[22:42:15] <bblum> for 10.timesi |i| { ... }
[22:42:20] <strcat> there's still uint::range/int::range for the moment
[22:42:28] <strcat> there's just iterator::Counter for now
[22:42:30] <strcat> need a Range one
[22:42:36] <bblum> i'm happy with counter
[22:42:40] <kmc> strcat: yeah
[22:42:42] <bblum> what's the name?
[22:42:47] <bblum> incantation i mea
[22:42:47] <bblum> n
[22:42:57] <strcat> rusti: std::iterator::Counter::new(0, 1)
[22:42:58] -rusti- {state: 0, step: 1}
[22:43:04] <strcat> it could just be count()...
[22:43:15] <strcat> ::new is kind of annoying in this case
[22:43:44] <engla> Just like I guess the Range one should be  fn range()
[22:45:16] <engla> bblum: not sure if you will be happy with counter since it's infinite (needs limiting with .take_())
[22:45:47] <bblum> oic
[22:45:50] <bblum> i'll just use range
[22:45:54] *** Quits: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au) (Quit: gavinb)
[22:46:31] <engla> strcat: I'm think Range + float + Double-ended iterators will be a headache
[22:46:58] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Quit: Leaving.)
[22:47:57] <xenocons> nice, oscon had  a ruxtalk
[22:48:00] <xenocons> rust*
[22:48:05] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[22:48:14] <xenocons> i know what im doing today!
[22:48:51] <xenocons> oh :( no vids?
[22:49:35] <tjc> xenocons: it'll be posted, just keep watching the site
[22:49:45] *** Joins: Nisstyre (wes@moz-FD86289.netflash.net)
[22:49:46] <xenocons> will do,ty
[22:51:57] <xenocons> by watch you mean... for 5000.times {VK_F5}
[22:52:22] <strcat> engla: floats are a headache overall ;p
[22:52:40] <kmc> i love how that statement works for Rust and Servo both
[22:52:49] *** Quits: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP) (Quit: buildmaster reconfigured: bot disconnecting)
[22:52:49] *** Joins: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP)
[22:53:35] <strcat> rusti: let x = 0.0 / 0.0; let mut map = std::hashmap::HashMap::new(); map.insert(x, 5); map.contains_key(&x)
[22:53:36] -rusti- false
[22:53:46] <xenocons> ‚ÄúNothing brings fear to my heart more than a floating point number.‚Äù ‚Äî Gerald Jay Sussman
[22:53:52] <strcat> rusti: let x = 0.0 / 0.0; let mut map = std::hashmap::HashMap::new(); for 2000.times { map.insert(x, 5) }; map.contains_key(&x)
[22:53:52] -rusti- <anon>:7:87: 7:107 error: A for-loop body must return (), but it returns bool here. Perhaps you meant to write a `do`-block?
[22:53:53] -rusti- <anon>:7          let x = 0.0 / 0.0; let mut map = std::hashmap::HashMap::new(); for 2000.times { map.insert(x, 5) }; map.contains_key(&x)
[22:53:53] -rusti-                                                                                                 ^~~~~~~~~~~~~~~~~~~~
[22:53:53] -rusti- error: aborting due to previous error
[22:53:54] -rusti- application terminated with error code 101
[22:53:58] <strcat> rusti: let x = 0.0 / 0.0; let mut map = std::hashmap::HashMap::new(); for 2000.times { map.insert(x, 5); } map.contains_key(&x)
[22:53:59] -rusti- false
[22:54:04] <strcat> rusti: let x = 0.0 / 0.0; let mut map = std::hashmap::HashMap::new(); for 2000.times { map.insert(x, 5); } map.len()
[22:54:05] -rusti- 2000
[22:54:10] * strcat hates floats
[22:54:13] <xenocons> lol
[22:54:36] <strcat> it should really be using TotalEq
[22:54:40] <strcat> but it's a good example anyway ;p
[22:54:48] <xenocons> rusti: let x = 0.0 ./ 0.0;
[22:54:48] -rusti- <anon>:7:22: 7:23 error: unexpected token: `/`
[22:54:48] -rusti- <anon>:7          let x = 0.0 ./ 0.0;
[22:54:48] -rusti-                                ^
[22:54:48] -rusti- application terminated with error code 101
[22:54:54] <xenocons> rusti: let x = 0.0 / 0.0;
[22:54:55] -rusti- <anon>:7:13: 7:14 warning: unused variable: `x` [-W unused-variable (default)]
[22:54:55] -rusti- <anon>:7          let x = 0.0 / 0.0;
[22:54:55] -rusti-                       ^
[22:54:55] -rusti- ()
[22:54:59] <strcat> rusti: let x = 0.0 / 0.0; x.hash_keyed(0, 0)
[22:54:59] -rusti- 955957291796131225
[22:55:01] <strcat> rusti: let x = 0.0 / 0.0; x.hash_keyed(0, 0)
[22:55:01] -rusti- 955957291796131225
[22:55:08] <xenocons> isnt 0.0 / 0.0 NaN?
[22:55:10] <strcat> they all collide to the same bucket too
[22:55:12] <strcat> xenocons: yes
[22:55:25] <strcat> rusti: 0.0 / 0.0
[22:55:25] -rusti- NaN
[22:55:29] <xenocons> oh right derp
[22:55:38] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[22:55:41] <strcat> rusti: 0.0 / 0.0 == 0.0 / 0.0
[22:55:42] -rusti- false
[22:55:44] <strcat> rusti: 0.0 / 0.0 != 0.0 / 0.0
[22:55:45] -rusti- true
[22:55:49] <strcat> huh
[22:55:50] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[22:55:50] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/UxgyEQ
[22:55:50] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[22:55:54] <strcat> oh, yeah
[22:55:56] * strcat is silly
[22:56:07] <sfackler> strcat: NaN != any float including NaN
[22:56:08] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[22:56:17] <doener> we need transreal arithmetic
[22:56:20] <strcat> sfackler: yeah I know, that's why I did it :)
[22:56:27] *** Joins: Klaufir_ (admin@94E7A28F.E28D9BD4.349F3CD5.IP)
[22:56:29] <strcat> sfackler: but my brain interpreted the result wrong
[22:56:45] <sfackler> ah :)
[22:57:32] <Klaufir_> "A collection of poorly written scripts, and badly authored HTML, which collates data from several (well, 2) sources and turns it into graphs"
[22:57:38] <Klaufir_> well, thats helpful
[22:57:41] <kemurphy> acrichto: https://gist.github.com/kemurphy/6092653#file-workaround-rs seems to do the trick
[22:57:59] <bblum> aargh missing pubs all over the place
[22:58:03] <xenocons> i know its not possible to give projections, but whats the goal for rust non alpha? 1.0?
[22:58:07] *** Joins: pcwalton (pcwalton@moz-F35A8539.hsd1.or.comcast.net)
[22:58:07] *** ChanServ sets mode: +o pcwalton
[22:58:12] <cmr> Klaufir_: it's incredibly helpful!
[22:58:16] <xenocons> i wont hold you to your words :)
[22:58:26] *** Quits: vladimir-lu (vladimir-l@moz-428433D9.cable.virginmedia.com) (Quit: WeeChat 0.4.0)
[22:58:28] <strcat> xenocons: it could go 0.8, 0.9, 0.10 though ;p
[22:58:39] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[22:58:39] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/f-iZfA
[22:58:39] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[22:58:42] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[22:58:42] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/ALDuSQ
[22:58:42] <ghrust> 13rust/06auto 14c221235 15Michael Sullivan: Improve the camel case warning a bit.
[22:58:42] <ghrust> 13rust/06auto 14bb4a7c6 15Michael Sullivan: Eliminate unused variable warnings.
[22:58:42] <ghrust> 13rust/06auto 148d42642 15Michael Sullivan: Register snapshots.
[22:58:43] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[22:58:48] <acrichto> kemurphy: yeah, although it's unfortunate that a clone() had to be introduced :(
[22:58:59] <xenocons> strcat: backstory: i got some people interested in rust at work, who are interested in looking into it as a new syslang
[22:59:10] <xenocons> but obviously i cant say its ready right now for production
[22:59:20] <Klaufir_> oh, it profiles rustc. awesome
[22:59:27] <engla> xenocons: there are a lot of "answers" on the milestone page https://github.com/mozilla/rust/issues/milestones
[22:59:39] <xenocons> ill have a read
[22:59:43] <aatch> xenocons, well we haven't even hit "well defined" yet.
[22:59:54] <xenocons> aatch: yeah 
[22:59:59] <xenocons> im just impatient
[23:00:08] <aatch> xenocons, I get it. So am I.
[23:00:16] <cmr> So am I
[23:00:23] <cmr> Why isn't rust approaching perfection at the speed of light!
[23:00:27] <xenocons> there is an opening on that team, but they currently use C heh
[23:00:30] <xenocons> cmr: exactly!
[23:00:31] <xenocons> haha
[23:00:37] <aatch> I'm amusing myself in the mean time by doing an ad-hoc implementation of libc.
[23:00:45] <aatch> (In rust)
[23:01:25] *** Quits: paupau (textual@417F0514.289B9BF9.F20F0C5A.IP) (Ping timeout)
[23:01:25] <xenocons> nice
[23:02:15] <pcwalton> aatch: awesome
[23:02:19] <pcwalton> I'm really curious how that goes!
[23:02:32] <aatch> pcwalton, well it's currently part of a different project.
[23:02:42] <aatch> pcwalton, but it should be easy to break out.
[23:02:49] *** Joins: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au)
[23:02:52] <aatch> And it's 64bit linux only right now.
[23:03:21] <strcat> aatch: you could make a shim using an interrupt instead of syscall and support x86 pretty easily though
[23:03:33] <aatch> pcwalton, it's kinda cool seeing how the various functions are implemented though
[23:03:40] <aatch> strcat, yeah, that's kinda the plan.
[23:04:18] *** Joins: Voomer (Voomer@moz-CC05FF5E.hsd1.wa.comcast.net)
[23:04:23] <strcat> aatch: do you actually have the calling convention encoded? or do you have to do each manually?
[23:04:44] <aatch> strcat, well I have a bunch of `syscalln` functions
[23:05:04] <aatch> do I'd just need to do target_arch=... configs over them.
[23:05:09] <kemurphy> man, resolve really needs to be a fold instead of a visitor
[23:05:13] *** Joins: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net)
[23:05:14] <strcat> I still have to figure out how to deal with libseccomp's awful vararg stuff ;p
[23:05:28] <strcat> they don't even expose a va_list one
[23:05:35] <cmr> aw
[23:05:50] <strcat> I guess I could send them a patch but... sourceforge ;)
[23:06:09] <strcat> surprisingly not a dead project
[23:06:43] <strcat> anyway seccomp is annoying because... there's really no upper bound on the # you might want to pass
[23:06:46] <aatch> x86 syscall ABI gets weird after syscall4
[23:06:56] *** Quits: reyre (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Quit: )
[23:07:05] <strcat> I guess there's a reasonable upper bound on how many rules you could come up with for 1 syscall
[23:07:13] *** Joins: reyre (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[23:07:42] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[23:07:42] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14d584e43 to 1444808fc: 02http://git.io/N3iJvQ
[23:07:42] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[23:07:44] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[23:07:44] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/9S-8pw
[23:07:44] <ghrust> 13rust/06auto 148f1adef 15Brian Anderson: std::rt: Add start_on_main_thread function...
[23:07:44] <ghrust> 13rust/06auto 148ac860f 15bors: auto merge of #7864 : brson/rust/start-on-main-thread, r=brson...
[23:07:45] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[23:07:48] <bblum> hmmm, actually, i'm not even sure how to write a test case for this embarrassing bug
[23:08:10] *** Quits: reyre (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Client exited)
[23:08:23] <strcat> aatch: where does it put them?
[23:08:26] <aatch> strcat, well libc doesn't seem to define it above syscall6
[23:08:38] <strcat> float registers? ;p
[23:08:45] *** Joins: reyre (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[23:08:48] <strcat> (as in sse)
[23:08:51] <aatch> strcat, on the stack, but it also does something weird to the stack pointer. I haven't quite figured it out.
[23:09:10] <strcat> oh so maybe it puts them on the stack and sets the pointer to it?
[23:09:11] <cmr> aatch: surely it's in the kernel documentation?
[23:09:28] *** Quits: mihneadb_ (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net) (Connection reset by peer)
[23:09:29] <aatch> cmr, probably. I'm just going by the musl source atm (picked at random)
[23:09:39] *** Joins: mihneadb_ (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net)
[23:09:44] <strcat> obviously the solution is to not use those syscalls ;p
[23:10:05] <aatch> strcat, well they are pretty uncommon.
[23:10:20] <aatch> I actually only have syscalls 0-4 implemented atm.
[23:11:13] <strcat> the iovec ones
[23:11:28] <aatch> strcat, yeah, and I think some memory ones.
[23:11:41] <strcat> right, mmap
[23:12:12] *** Quits: mihneadb_ (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net) (Input/output error)
[23:12:23] *** Joins: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net)
[23:12:44] *** Quits: tchoma (tchoma@moz-BE33DA21.fw1.sfo1.mozilla.net) (Ping timeout)
[23:13:11] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[23:13:52] <doener> aatch: http://vserver.13thfloor.at/Experimental/SYSCALL/syscall_shiny18.h -- might be useful
[23:14:12] <doener> aatch: documents the syscall calling conventions for various archs
[23:14:59] <graydon> aatch: hey, it's you!
[23:15:13] <aatch> doener, cool
[23:15:17] <aatch> graydon, yes...
[23:15:20] <aatch> What did I do?
[23:15:22] <graydon> I was going to ask if I can do something to help landing the ty-de-sharing thing
[23:15:28] <graydon> debug something on windows, or .. ?
[23:15:33] <graydon> I don't understand how it could be platform-specific
[23:15:44] <aatch> graydon, getting more info out of that windows bot would be a start.
[23:16:11] *** Quits: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au) (Quit: gavinb)
[23:16:14] <aatch> graydon, I don't get it either. Hence why it was retried a few times, just seemed like a spurious failure.
[23:16:18] <graydon> I am sitting in front of a laptop that's perfectly happy to do windows, plus I can bring up any number of windows VMs. what happened, it just crashed?
[23:16:22] <aatch> however, 3 in a row is not spurious.
[23:16:32] <graydon> indeed not
[23:16:57] <aatch> graydon, yep "Application requested to terminate in an unknown way" or something like that.
[23:17:01] <graydon> right
[23:17:34] *** Quits: tjc (tjc@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: zzzzzzzzzz)
[23:17:53] <aatch> I can't remember if it fails in stage 1 or 2 though
[23:18:42] *** Joins: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au)
[23:20:03] <graydon> ok. if I un-bitrot it and debug it and land it, is that a good use of my time?
[23:20:08] <graydon> I would really like to fix it up
[23:20:29] <aatch> graydon, well I think it's like 300M of memory usage, so probably.
[23:20:38] <graydon> yeah
[23:20:39] <graydon> ok
[23:20:45] <graydon> I mean .. you are busy with other stuff
[23:20:47] *** Joins: bent (chatzilla@moz-932324BF.hsd1.ca.comcast.net)
[23:20:48] *** Joins: mihneadb_ (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net)
[23:20:54] *** Quits: mihneadb_ (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net) (Input/output error)
[23:20:56] <acrichto> aatch: I noticed that pcwalton got that when doing something on windows and it ended up being allocations > 4GB
[23:21:15] <pcwalton> acrichto: aatch: yeah, I was thinking it might be the same bug.
[23:21:19] <pcwalton> it might be fixed now.
[23:21:49] *** Quits: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: Leaving)
[23:22:51] <aatch> pcwalton, well then it should just be a matter of un-bitrotting it.
[23:24:18] *** Parts: steven_is_false (user@C5B76363.1FF1EBF8.1ECA502.IP) (ERC Version 5.3 (IRC client for Emacs))
[23:25:47] *** Quits: lkuper (lkuper@E0D3ECD7.A402E718.C082B7DC.IP) (Quit: lkuper)
[23:28:36] <bblum> strcat: can i reverse an iterator without calling .rev_iter
[23:28:45] <bblum> i want to write iter().take(index).reverse()
[23:28:45] <strcat> bblum: if it's double-ended, .invert()
[23:28:51] <strcat> bblum: not with take
[23:28:58] <strcat> maybe it could work on some
[23:29:01] <doomlord> theoretically, could there be any common parts between a c++ and rust compiler's middle  (eg.. common generic/template implemenation with features disabled, type-inference only running one way for c++ ...). or would that just be overcomplex & unmanageable
[23:29:01] <bblum> the alternative is like
[23:29:09] <bblum> rev_iter().skip(x.len() - index - 1)
[23:29:12] <bblum> which is illegible
[23:29:41] <bblum> it's just an array
[23:29:53] *** Quits: tikue (tkuehn@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: tikue)
[23:30:00] <bblum> i feel like you might need HKT to allow take to return the most flexible iterator possible
[23:30:02] <strcat> bblum: well, you need skip_back_n
[23:30:08] <strcat> which we can make
[23:30:14] <strcat> there's next_back()
[23:30:20] <bblum> skip_back_to() maybe
[23:30:29] <strcat> just need a version you don't have to loop
[23:31:47] <strcat> bblum: or just slice first if it's an array
[23:31:55] <bblum> strcat: how?
[23:31:58] <bblum> oh slice
[23:31:59] <bblum> i see
[23:32:03] <strcat> slice_to
[23:32:08] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Quit: Leaving.)
[23:32:32] <strcat> double-ended ones aren't very mature yet though
[23:32:35] <strcat> iterators
[23:32:43] <bblum> will slice_to(0) return empty or singleton
[23:32:53] * strcat shrugs
[23:33:02] <strcat> rusti: let xs = [1, 2, 3]; xs.slice_to(0).to_owned()
[23:33:03] -rusti- ~[]
[23:33:06] <bblum> thanks
[23:33:12] <strcat> rusti: let xs = [1, 2, 3]; xs.slice_to(2).to_owned()
[23:33:13] -rusti- ~[1, 2]
[23:33:39] <bblum> there, this is much prettier
[23:33:42] <bblum> "for ports.slice_to(ready_index).mut_rev_iter().enumerate().advance"
[23:35:01] <strcat> maybe if something is a RandomAccessIterator, take() could be double-ended...
[23:35:10] <strcat> you need to know how long the remaining part is
[23:35:39] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[23:36:32] <bblum> why is there no mut slice to
[23:36:41] <bblum> sigh, i need a mut iter on the result
[23:37:10] <bblum> mut_slice huh
[23:37:15] *** Joins: etw (john@moz-B2936CAB.nyc.res.rr.com)
[23:38:25] *** Joins: tjc (tjc@moz-BE33DA21.fw1.sfo1.mozilla.net)
[23:38:25] *** ChanServ sets mode: +o tjc
[23:39:45] *** Quits: homa_rano (edre@moz-223EA699.csail.mit.edu) (Ping timeout)
[23:40:33] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Ping timeout)
[23:40:33] <xenocons> eww strtok
[23:40:44] <strcat> I love strtok_r ;p
[23:40:46] * xenocons hyperventilates
[23:41:00] <pcwalton> this lint code makes no sense
[23:41:05] * pcwalton grumbles
[23:41:12] <pcwalton> this is extremely confusing code
[23:41:28] <aatch> pcwalton, yep.
[23:41:42] <aatch> It's far too clever.
[23:41:43] <pcwalton> is there any way to make it simpler 
[23:41:46] *** Quits: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net) (Ping timeout)
[23:41:50] <strcat> pcwalton: I looked into the fixed-size vector glue btw, and it's a mess because we pretend they are structs
[23:41:58] <pcwalton> strcat: that's really bad
[23:42:02] <xenocons> rusti: split("test cat",(|| == ' '))
[23:42:02] -rusti- <anon>:7:30: 7:32 error: unexpected token: `==`
[23:42:02] -rusti- <anon>:7          split("test cat",(|| == ' '))
[23:42:03] -rusti-                                        ^~
[23:42:03] -rusti- application terminated with error code 101
[23:42:05] <strcat> probably just need a special case path for them
[23:42:08] <pcwalton> I'm trying to refactor it and it keeps ICE-ing with unprocessed lints
[23:42:13] <xenocons> rusti: split("test cat",(== ' '))
[23:42:13] -rusti- <anon>:7:27: 7:29 error: unexpected token: `==`
[23:42:13] -rusti- <anon>:7          split("test cat",(== ' '))
[23:42:13] -rusti-                                     ^~
[23:42:14] -rusti- application terminated with error code 101
[23:42:25] <xenocons> (forgot already how s-expr like functions work in rust)
[23:42:30] <aatch> pcwalton, probably. Ask dbaupp.
[23:42:45] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Quit: My MacBook has gone to sleep. ZZZzzz‚Ä¶)
[23:42:46] <aatch> |x| x == ' '
[23:43:12] <xenocons> ah
[23:43:15] <xenocons> because == isnt a function right
[23:43:23] <xenocons> rusti: split("test cat",(|x| x == ' '))
[23:43:23] -rusti- <anon>:7:9: 7:14 error: unresolved name `split`.
[23:43:23] -rusti- <anon>:7          split("test cat",(|x| x == ' '))
[23:43:24] -rusti-                   ^~~~~
[23:43:24] -rusti- error: aborting due to previous error
[23:43:24] -rusti- application terminated with error code 101
[23:43:28] <xenocons> derp
[23:43:32] <xenocons> must be in str::
[23:43:54] <cmr> xenocons: uhh, wut
[23:43:55] <xenocons> ah there is split_char too
[23:43:58] <xenocons> thats easier
[23:44:00] <cmr> what sexpr-like functions?
[23:44:36] <xenocons> cmr: never mind, rust doesnt really do it
[23:44:39] <strcat> rusti: "foo bar baz".split_iter(' ').to_owned_vec()
[23:44:40] -rusti- ~["foo", "bar", "baz"]
[23:44:57] <strcat> rusti: "foo bar baz".split_iter(' ').fold(~"", |a, b| a + b)
[23:44:58] -rusti- ~"foobarbaz"
[23:45:19] * strcat doesn't see a join function anywhere
[23:45:25] <xenocons> rusti: str::split_char("test cat", ' ') 
[23:45:25] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/IiZU
[23:45:29] <strcat> oh connect
[23:45:33] *** Joins: homa_rano (edre@moz-223EA699.csail.mit.edu)
[23:45:40] <xenocons> is everything a method now?
[23:45:52] <xenocons> rusti: "test cat".split_char(' ')
[23:45:52] -rusti- <anon>:7:9: 8:5 error: type `&'static str` does not implement any method in scope named `split_char`
[23:45:52] -rusti- <anon>:7          "test cat".split_char(' ')
[23:45:52] <ozten> Howdy! I'm having trouble compiling with libc constants (which you need for os::mkdir)
[23:45:53] -rusti- <anon>:8     };
[23:45:53] -rusti- error: aborting due to previous error
[23:45:53] -rusti- application terminated with error code 101
[23:45:53] <ozten> https://gist.github.com/ozten/6092986
[23:46:02] <strcat> xenocons: some things aren't converted yet
[23:46:07] <xenocons> k
[23:46:08] <ozten> Code and compile error at the bottom of that gist ^
[23:46:24] <ozten> I've tried exterm mod libc as well as #[nolink]
[23:46:32] <engla> ozten: you shouldn't need to use the specific "posix88" etc modules
[23:46:55] <aatch> ozten, just `use std::libc::{CONST1, CONST2}`
[23:47:30] *** Quits: vosen (vosen@moz-266BA656.icpnet.pl) (Connection reset by peer)
[23:47:54] <ozten> engla, aatch: ah thanks! 
[23:49:03] <xenocons> "foo bar baz".split_iter(' ').to_owned_vec().map(|x| x[0])
[23:49:14] <xenocons> rusti: "foo bar baz".split_iter(' ').to_owned_vec().map(|x| x[0])D
[23:49:14] -rusti- <anon>:7:67: 7:68 error: expected `;` or `}` after expression but found `D`
[23:49:14] -rusti- <anon>:7          "foo bar baz".split_iter(' ').to_owned_vec().map(|x| x[0])D
[23:49:14] -rusti-                                                                             ^
[23:49:15] -rusti- application terminated with error code 101
[23:49:19] <xenocons> derp
[23:49:21] <xenocons> rusti: "foo bar baz".split_iter(' ').to_owned_vec().map(|x| x[0])
[23:49:22] -rusti- ~[102, 98, 98]
[23:49:28] <xenocons> erm
[23:49:39] <strcat> xenocons: you probably don't want to_owned_vec in there
[23:49:44] <strcat> since it allocates a needless vec
[23:49:50] <xenocons> rusti: "foo bar baz".split_iter(' ').map(|x| x[0])
[23:49:51] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/hRdT
[23:49:52] <aatch> rusti: "foo bar baz".split_iter(' ').transform(|x| x[0]).to_owned_vec()
[23:49:53] -rusti- ~[102, 98, 98]
[23:50:08] <xenocons> i expected it to output chars
[23:50:11] <xenocons> incorrect assumption?
[23:50:13] <strcat> those probably are chars
[23:50:16] <strcat> rusti: 'c'
[23:50:16] -rusti- 'c'
[23:50:19] <strcat> hm
[23:50:23] <aatch> rusti: "foo bar baz".split_iter(' ').transform(|x| x[0] as char).to_owned_vec()
[23:50:23] <strcat> rusti: ~['c']
[23:50:24] -rusti- ~['f', 'b', 'b']
[23:50:24] -rusti- ~['c']
[23:50:26] <strcat> oh wait no they're u8
[23:50:27] <engla> xenocons: yes, indexing str you get bytes
[23:50:36] <xenocons> ah
[23:50:47] <xenocons> rusti: "foo bar baz".split_iter(' ').map(|x| x[0] as char)
[23:50:48] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/bIKK
[23:50:53] *** Parts: jyeo (uid12229@moz-E77DEB21.irccloud.com) ()
[23:51:11] *** Joins: lkuper (lkuper@E0D3ECD7.A402E718.C082B7DC.IP)
[23:51:15] <xenocons> rusti: "foo bar baz".split_iter(' ').to_owned_vec().map(|x| x[0] as char)
[23:51:16] -rusti- ~['f', 'b', 'b']
[23:51:29] <xenocons> now we can boogie
[23:51:31] <engla> I don't even know if there's a method to get the nth char
[23:51:36] <strcat> also you can pass split_iter a fn ;p
[23:51:39] <kimundi> xenocons: It's probably better to use something like char_range_at(0) or so rather than casting it
[23:51:46] <engla> (.char_at does something different)
[23:52:02] <xenocons> "On peut etre Napoleon sans etre son ami, mes enfants!".split_iter(' ').to_owned_vec().map(|x| x[0] as char)
[23:52:09] <strcat> rusti: "foo bar\nbaz".split_iter(|x: char| x == ' ' || x == '\n')
[23:52:09] -rusti- {string: "foo bar\nbaz", position: 0, sep: , count: 11, allow_trailing_empty: true, finished: false, only_ascii: false}
[23:52:17] <strcat> rusti: "foo bar\nbaz".split_iter(|x: char| x == ' ' || x == '\n').to_owned_vec()
[23:52:18] -rusti- ~["foo", "bar", "baz"]
[23:52:26] <xenocons> rusti: "On peut etre Napoleon sans etre son ami, mes enfants!".split_iter(' ').to_owned_vec().map(|x| x[0] as char)
[23:52:26] -rusti- ~['O', 'p', 'e', 'N', 's', 'e', 's', 'a', 'm', 'e']
[23:52:30] <xenocons> victory
[23:52:41] <kimundi> xenocons: :(
[23:52:47] <xenocons> kimundi: heh
[23:52:49] <strcat> xenocons: allocating a temporary though ;p
[23:53:06] <kimundi> It's nort unicode compatible!
[23:53:11] <strcat> and it'll split a char into invalid chars
[23:53:11] <engla> you want .char_at(0) for the first char
[23:53:12] <xenocons> yeah, i would imagine its doing all sorts of bad things
[23:53:26] <xenocons> engla: right, to get rid of the cast
[23:53:39] <engla> more than the cast.. it handles the encoding correctly
[23:53:44] <aatch> rusti: "On peut etre Napoleon sans etre son ami, mes enfants!".split_iter(' ').transform(|x| x.char_at(0)).to_owned_vec()
[23:53:45] -rusti- ~['O', 'p', 'e', 'N', 's', 'e', 's', 'a', 'm', 'e']
[23:53:49] <kimundi> rusti: "È©ö„ÅÑ„ÅüÂΩº„ÅØÈÅì„ÇíËµ∞„Å£„Å¶„ÅÑ„Å£„Åü„ÄÇ".split_iter(' ').to_owned_vec().map(|x| x[0] as char)
[23:53:50] -rusti- ~['\xe9']
[23:54:23] <xenocons> still, its easier than p=strtok(str," "), while (p) { printf("%c",p);p=strtok(NULL," "); }
[23:54:24] <kimundi> rusti: "È©ö„ÅÑ„Åü ÂΩº„ÅØÈÅì„Çí Ëµ∞„Å£„Å¶„ÅÑ „Å£„Åü„ÄÇ"".split_iter(' ').transform(|x| x.char_at(0)).to_owned_vec()
[23:54:24] -rusti- <anon>:9:19: 9:20 error: unknown start of token: 63
[23:54:24] -rusti- <anon>:9     println(fmt!("%?", r))
[23:54:24] -rusti-                             ^
[23:54:24] -rusti- application terminated with error code 101
[23:54:32] <xenocons> aha!
[23:54:34] <xenocons> its print! now right?
[23:54:36] <kimundi> rusti: "È©ö„ÅÑ„Åü ÂΩº„ÅØÈÅì„Çí Ëµ∞„Å£„Å¶„ÅÑ „Å£„Åü„ÄÇ".split_iter(' ').transform(|x| x.char_at(0)).to_owned_vec()
[23:54:37] -rusti- ~['\u9a5a', '\u5f7c', '\u8d70', '\u3063']
[23:54:37] <strcat> xenocons: need strtok_r ;p
[23:54:43] <strcat> strtok is really broken
[23:54:46] <xenocons> strcat: i hadn't even heard of strtok_r
[23:54:53] <strcat> uses a static local so you can't nest them and it's not thread-safe
[23:55:02] <strcat> xenocons: strtok_s in the windows world
[23:55:07] <xenocons> strcat: strtok is infact, one of the worst C functions ever
[23:55:29] <aatch> rusti: unsafe { std::cast::transmute::<~[u8],~str>("On peut etre Napoleon sans etre son ami, mes enfants!".split_iter(' ').transform(|x| x.char_at(0)).to_owned_vec()) }
[23:55:30] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/NKaN
[23:55:40] * strcat likes boost's tokenizer iterators
[23:55:46] <aatch> rusti: unsafe { std::cast::transmute::<~[u8],~str>("On peut etre Napoleon sans etre son ami, mes enfants!".split_iter(' ').transform(|x| x[0]).to_owned_vec()) }
[23:55:46] -rusti- ~"OpeNsesam"
[23:55:50] * xenocons doesnt like boost due to size + complexity
[23:55:55] <strcat> our split iter is much like the boost one
[23:56:04] <aatch> NOTE: ^^^ Do not do that
[23:56:19] <cmr> graydon: I'm pestering you about https://github.com/mozilla/rust/pull/8009
[23:56:26] <graydon> thanks!
[23:56:33] <graydon> I will get to it, but possibly not till evening
[23:56:44] <cmr> it just keeps getting pushed back farther and farther ;P
[23:56:46] <strcat> I don't mind strtok_r though ;p
[23:57:05] <strcat> the incantation is burned into my mind though
[23:57:16] <xenocons> like a spell?
[23:57:53] <xenocons> "To those friends considering it is always news, but all filled ciphers disturb happiness with varied answers!" same as before except n+1 instead of [0] ;)
[23:57:58] <strcat> for (char *ptr = string, *save; ; ptr = nullptr) { const char *token = strtok_r(ptr, "characters", &save); }
[23:58:03] * strcat can't remember what they all are
[23:58:13] <strcat> silly C and the lack of slices :)
[23:58:45] <strcat> 'save' is just the internal state... with strtok it's a static
[23:59:10] *** Joins: kyle2000 (kyle2000@6EDB4D7A.341FCD98.3031298E.IP)
[23:59:26] <cmr> Is the general consensus that splitting libstd back into a libcore would be useful? (just bare-bones stuff that could be usefully used with zero.rs)
[23:59:34] <xenocons> ez in F#: "test cat".Split ' ' returrns [|"test";"cat"|]
[23:59:41] <cmr> and libstd would contain io/scheduler/etc

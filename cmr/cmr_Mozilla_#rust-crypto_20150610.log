[00:00:11] *** Joins: dpc (dpc@moz-t6gr4b.ca.comcast.net)
[00:45:07] <zeiris> http://saw.galois.com just got open sourced for non-commercial use. Equivalence checking of stuff on LLVM bitcode. :D
[00:45:43] <eddyb> I wanted that!
[00:45:48] <eddyb> now what did I want it for?
[00:46:36] <zeiris> Verifying ridiculous optimizations actually work? :D
[00:47:11] <eddyb> it was something specific...
[00:47:39] <eddyb> zeiris: oh, wait, it was a language-agnostic semantic representation
[00:47:51] <eddyb> something you could use to loosely convert between languages
[00:48:05] <eddyb> somewhat related, but I'm not sure SAW is immediately useful
[00:50:05] <zeiris> cryptol's sort of supposed to be that, and SAW's the bit that does cross-language equivalence checking.
[00:50:25] <zeiris> Dunno about actual convertions especially since practically you'd want a bunch of optimizations applied.
[00:55:46] <eddyb> zeiris: yeah, it would be user-assisted in any way. the hard part is representing semantics in a common way so you can have a bulk baseline conversion
[00:55:55] <eddyb> (which may not even compile at first)
[00:59:11] <eternaleye> One thing I'd love is if someone adds a machine-level language to SAW. Any such. RISC-V might be a good option.
[00:59:40] <eternaleye> Then add Rust support, and pass the entire testsuite through.
[00:59:53] <eddyb> why not LLVM IR?
[00:59:56] <zeiris> eddyb: Looking at public (ie confident enough to submit to independant verification) efforts, the equivalence checking's the hard part.
[00:59:59] <eddyb> would work for a whole bunch of languages
[01:00:17] <eternaleye> eddyb: RISC-V is a hell of a lot smaller
[01:00:22] <zeiris> eternaleye: it works on LLVM IR, and writing a lifter from 8051 or MSP430 to that is now high on my TODO stack :D
[01:00:26] <eternaleye> Mm
[01:00:33] <eddyb> zeiris: oh
[01:00:45] <eddyb> 8051 you say
[01:00:50] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[01:00:54] <eddyb> I have a half-assed lifter for it
[01:00:58] <eternaleye> eddyb: Also, that doesn't test the machine lowering passes...
[01:01:05] <eddyb> actually, I might have all the instructions
[01:01:19] <eternaleye> eddyb: I'd love to be able to SAW in between Rust and the hardware, to replicate seL4
[01:01:43] <eddyb> https://github.com/eddyb/wiREd/blob/master/disasm/8051.js
[01:01:56] <eddyb> a few ones are wrong
[01:02:04] <bascule> SAW does look great, except what about Rust :|
[01:02:22] <eternaleye> bascule: That's why it having been open-sourced is nice!
[01:02:27] <eddyb> I need to handle register windows correctly and handle global aliasing
[01:02:37] <eddyb> in an analyzer
[01:02:47] <eddyb> the ES6 version of that project is scrapped anyways
[01:02:52] <eternaleye> bascule: Can probably use the existing formal model of transitively-safe Rust, and use the C model as a basis to extend it to unsafe Rust.
[01:03:04] <zeiris> bascule: Rust runs on LLVM :D You can do an equivalence proof between Rust embedded impl, Verilog FPGA impl, and Java added-it-for-business-reasons impl!
[01:03:31] <eternaleye> zeiris: Um, that doesn't prove the translation from Rust to LLVM IR though
[01:03:42] <eternaleye> zeiris: Which is certainly one of the things that interests me...
[01:04:09] <eddyb> it proves that the result of the translation is correct
[01:04:11] <zeiris> Oh, that sounds hard. Are there well-defined semantics for what Rust code does? (And how static are they?)
[01:04:22] <eddyb> zeiris: there's a patina thing and a redex model
[01:04:24] <zeiris> Oh yeah, if the result is right then who cares :D
[01:04:43] <eternaleye> zeiris: Patina proves some properties on transitively-safe rust (no unsafe anywhere)
[01:05:10] <eternaleye> eddyb: Oh, link for the redex model?
[01:05:16] <zeiris> Also, for 8051, register windows don't get used much in practice. When they do it's RTOS code or something that you can compartmentalize from "userland".
[01:05:32] <eddyb> zeiris: yupp
[01:05:57] <eddyb> zeiris: which means that if nothing changes the window, the analyzer will constant fold it
[01:06:34] <eddyb> so much nice stuff to port to Rust and I haven't started in the 1.5 years I've been screwing around with Rust
[01:06:44] <eddyb> https://github.com/nikomatsakis/rust-redex
[01:06:56] <eddyb> this might be behind. and it's certainly kind of old Rust
[01:07:17] <eternaleye> eddyb: Cool, thanks!
[01:30:58] <zeiris> eddyb: what's defining the Register16/Mem8/etc stuff in your 8051 lifter?
[01:31:40] <eddyb> zeiris: that's just an "arch file"
[01:31:57] <eddyb> zeiris: https://github.com/eddyb/wiREd/blob/master/disasm/codegen-js-base.js
[01:32:16] <eddyb> zeiris: generated bundle: https://github.com/eddyb/wiREd/blob/master/disasm/arch-8051.js
[01:32:36] <eddyb> most of it is runtime crap, but at the end you can see the switch tables
[01:32:52] <eddyb> https://github.com/eddyb/wiREd/blob/master/disasm/arch-8051.js#L3096
[01:37:51] <zeiris> Nifty use of string templates for generating code :p How hard is it wrap the whole thing into a command line binary blob -> IR file tool?
[01:38:43] <eddyb> zeiris: it already is
[01:38:54] <zeiris> Oh. I'm bad at JS :(
[01:38:58] <eddyb> not that though
[01:39:24] <eddyb> zeiris: this drives the whole thing https://github.com/eddyb/wiREd/blob/master/analyzer.js
[01:41:11] <eddyb> it's very hacky but it can handle nested allocas while tracking the stack pointer correctly and `ret` is just `pop eip` (on x86) so if the return pointer isn't at the top of the stack, it's going to do something other than return from the function :P
[01:41:36] <eddyb> (good luck using a dumb tool like IDA on ARM code which doesn't have a `ret` instruction)
[01:41:55] <zeiris> Heh, that's why it's called an *interactive* disassembler :p
[01:41:57] <eddyb> zeiris: anyways, it's been years :(
[01:42:14] <eddyb> (since I wrote something more capable than IDA in my spare time)
[01:42:43] <eddyb> I am trying to get myself to write some binary parsing tools in Rust for object file formats
[01:42:54] <eddyb> I was using radare2 bindings in that analyzer
[01:43:52] <zeiris> I used to dream about writing something more capable than IDA, then realized exactly how much work it'd be to support all its architectures. Rather than going for faithful emulation of a ton of target architectures I'll settle for using IDA for identifying basic blocks, then external tools to further aid IDA use.
[01:44:10] <eddyb> IDA is so shit though. and it costs money
[01:44:26] <eddyb> I would be embarassed to ask money for an app like IDA
[01:44:49] <eddyb> zeiris: https://github.com/eddyb/wiREd/blob/master/disasm/x86.js#L195
[01:45:02] <eddyb> zeiris: this was written in a few days using the intel manuals
[01:45:04] <zeiris> It is so shit. And very expensive. But it works for large RE projects better than any alternatives.
[01:46:03] <eddyb> 8051 is even there because xvilka (a radare dev who's also a russian RE professional. i.e. employed... by an AV company? I'm not sure)
[01:46:24] <eddyb> asked me to, more or less seriously. there's firmware on these darn things and the tools aren't great
[01:48:01] <zeiris> I wouldn't trust an x86 lifter without some kind of test suite for equivalence, or a ton of eyeball time. Simpler/saner instruction sets are a good testbed, though.
[01:48:38] <zeiris> McSema looks like a high-effort x86 attempt, but by itself is just a building block. Idk for what.
[01:51:16] <zeiris> Verification's sort of a subset of RE - instead of checking for equivalence vs a reference, you're checking for equivalence vs a mental model. Abstract interpretation to ID common primitives or check equivalence vs quickly written specs would be a sweet goal.
[01:51:57] <zeiris> ... Which is pretty far from the bascule ambition of writing all our crypto in rust, but not completely unrelated ;)
[01:55:07] <bascule> lolololol
[01:56:01] <bascule> I'm still waiting for these posts to hit Metzdowd
[01:56:02] <Tobba> eddyb: 8051?!?
[01:56:03] <Tobba> crikey
[01:56:12] <bascule> about the Blockchainiac ECC Schnorr variant based on secp256k1
[01:56:17] <Tobba> I forgot those still exist
[01:56:18] <bascule> I already responded
[01:56:50] <zeiris> That is not dead which can eternal lie.
[01:57:02] <bascule> https://gist.github.com/tarcieri/0dd4e3f847745f45be44
[01:57:57] <Tobba> eddyb: apparently, 8051s are used in... cars, among other things, I guess basically everywhere
[01:58:30] <bascule> Bitcoin really makes me sad
[01:58:46] <bascule> it's not just Dunning-Kreugerands, it's crypto dunning-kruger too
[01:59:02] <bascule> people who don't know what they're doing are doing terrible things and calling it "crypto"
[01:59:26] <bascule> like foregoing the OS RNG and grabbing some "random" numbers off some random server on the Internet over http://
[01:59:28] *** Joins: esclear_ (esclear@moz-b16fol.dip0.t-ipconnect.de)
[01:59:53] <Tobba> bascule: it didn't forgoe it, it actually just added more entropy
[02:00:08] <Tobba> the problem was that some dolt coded it so that it didn't abort immedietely on /dev/random being unavailable
[02:00:11] <eddyb> Tobba: 8051 is on motherboards
[02:00:23] <Tobba> eddyb: power control, I guess?
[02:00:38] <Tobba> intel have some really fucky firmware in the PCH that I'm not sure if anyone even knows exists
[02:00:51] <Tobba> there *should* be firmware inside of intel NICs; the offloading engine is just too complex to hold in HW sanely
[02:00:59] <Tobba> but I can't find anything even mentioning that
[02:02:09] *** Quits: esclear (esclear@moz-l91j8b.dip0.t-ipconnect.de) (Ping timeout: 121 seconds)
[02:02:31] <zeiris> Some of that firmware is easier to identify by finding and dumping 8-pin eeprom chips than from software.
[02:02:52] <Tobba> zeiris: isn't it always, I'd suspect that flash would be built-in though
[02:03:03] <Tobba> I had a BIOS upgrade lead to ridiculously better AHCI performance
[02:03:09] <Tobba> even though  not even SMM should have anything to do with that
[02:03:26] <Tobba> so I suspect it updated the PCH firmware somehow, but I can't find anything related to that even in the BIOS
[02:04:38] <zeiris> I have no idea how those binary blobs dissect, or even where to start :\ If counting all the cores on a phone is hard nowadays, what does that say about a PC?
[02:05:00] <eddyb> I tried to RE the N900 telephony blob
[02:05:14] <eddyb> the headers looked like they meant something but they were fucking with my head
[02:05:25] <eddyb> they *almost* fit a pattern
[02:05:32] <eddyb> and then the contents were whacko
[02:05:50] <zeiris> When in doubt, hope it's little-endian ARM? :p
[02:05:50] <eddyb> not arbitrary enough to be encrypted, but just not what I wanted
[02:06:00] <eddyb> some of it was valid ARM some wasn't
[02:06:08] <Tobba> zeiris: I'd guess most cores that get dumped in everywhere are 8051-like
[02:06:09] <bascule> if EdDSA is Schnorr for Edwards curves, what do you call Schnorr for Koblitz curves?
[02:06:10] <eddyb> nothing made sense, on a large scale
[02:06:13] <bascule> KobDSA?
[02:06:16] <Tobba> i.e a few thousand transistors and super tiny
[02:06:25] <Tobba> I'm just suprised people are using that 35 year old shitheap instead of a redesign
[02:06:39] <Tobba> which would probably take a day of drunken verilog programming
[02:07:34] <zeiris> Nowadays all microprocessors are "small", so it's a mix of whatever. 8051 definitely still gets used, though. I guess the IP exists, and is free, so why not?
[02:08:21] <Tobba> I didn't know it was free actually, so I guess
[02:08:46] <bascule> how much do they cost?
[02:09:25] <zeiris> In silicon, nothing. In a package, sub-$1
[02:09:37] <Tobba> oh wait, I'm mixing the 8051 up with another design
[02:09:41] <Tobba> the 8051 is incredibly "standard"
[02:09:52] <Tobba> so yeah why not use it I guess, other than a few warts
[02:09:53] <bascule> I mean, we use(d) MSP430s...
[02:10:04] <Tobba> zeiris: it's probably sub-1c
[02:10:15] <Tobba> you'll be paying more for the damn packaging
[02:10:38] <zeiris> Yeah :D Although on modern processes that goes for all low-memory processors.
[02:10:55] <Tobba> heh, built-in memory is all the cost
[02:12:20] <zeiris> I'd realy like Rust on MSP430. Like them more than any of the ARMs around.
[02:12:22] <bascule> is there a good reason to use an 8051 over an MSP430?
[02:13:06] <zeiris> Depends on whether "our 50 year old chief engineer can use them in his sleep" counts.
[02:13:08] <bascule> I guess the whole "it's free" from an IP perspective bit?
[02:13:18] <bascule> hahaha
[02:13:25] <Tobba> I'd say the MSP430 is nicer to work with
[02:13:32] <zeiris> Technology choices that aren't driven by software, in domains where software isn't the hardest problem, get weird :p
[02:14:05] <bascule> http://opencores.org/project,openmsp430
[02:14:09] <bascule> heh
[02:15:09] <Tobba> the 8051 is 8-bit and has a slightly convoluted instruction set
[02:15:14] <Tobba> I'd guess the MSP430 is a better choice all around
[02:16:24] <eddyb> doesn't LLVM have a MSP backend? or am I confusing things?
[02:16:32] <zeiris> In the very near future I'm seeing a crypto library containing Rust code targeting firmware/OS, assembly optimizations of specific targets, and Cryptol that compiles down to efficient iCE40 bitstreams. All of it verified equivalent using LLVM as the common denominator :D:D
[02:16:33] <Tobba> I think it actually does?
[02:16:46] <Tobba> I'm not sure if I'd rely on LLVM to generate tiny code, but it might be nice for tinier things
[02:17:02] <Tobba> zeiris: :D
[02:17:12] <bascule> zeiris: that's a future I want to live in
[02:17:14] <zeiris> It does, and it kinda works, but apparently 16-bit architectures aren't the happy case. So afaik rust doesn't target it, and clang may or may not.
[02:17:21] <Tobba> zeiris: with constexprs you can define a pure subset of rust
[02:17:32] <Tobba> which should be way easier to verify
[02:17:41] <zeiris> Let me get a bunch of projects out of the way and I'll tackle the FPGA one.
[02:18:26] <Tobba> zeiris: well, we thankfully didn't go the road of having uint be the default
[02:18:34] <Tobba> sadly we did make u32 the default, which probably fucks perf
[02:18:40] <Tobba> but if you avoid that it should be fine?
[02:18:53] <eddyb> http://me.bios.io/Main_Page
[02:18:56] <zeiris> Where we're going, stdlibs don't fit! :D
[02:19:23] <eddyb> Tobba: i32
[02:19:37] <Tobba> zeiris: just easier to mess things up by accident, iterators, crypto libs etc
[02:19:39] <eddyb> not sure where it's actually used that would matter
[02:19:47] <Tobba> although LLVM should knock it down to smaller sizes where possible
[02:20:04] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[02:20:04] <eddyb> Tobba: there's the range-analysis project which could do that
[02:20:12] <eddyb> but LLVM by itself doesn't
[02:20:16] <zeiris> True, but you get hardware isolation and a reallly small attack surface. So, lose some gain some.
[02:20:22] <Tobba> eddyb: I kinda wish we had a rust alternative to LLVM
[02:20:33] <Tobba> well, an alternative backend, that could possibly output (better) LLVM code after shitloads of analysis
[02:20:46] <Tobba> rustc could output ranged integers for enums for example, and further things could be deduced from those
[02:20:56] <eddyb> Tobba: already done
[02:21:09] <eddyb> that's how far LLVM "range analysis" goes :P
[02:21:23] <Tobba> eddyb: well yeah, but rustc outputting ranged integers where possible
[02:21:26] <eddyb> (there's range metadata on loads)
[02:21:36] <Tobba> there's lots of fun analysis outside of range, where metadata from rustc could help loads
[02:21:39] <zeiris> Practically targeting ARM effectively gives you a ton of flexibility by itself. And that's 32 bits + has plenty of high-memory options.
[02:21:42] <eddyb> apparently the ME stuff is ARC not 8051
[02:21:43] <Tobba> for example "this value will only have values from this set"
[02:21:56] <zeiris> I think some ARC, some newer ones ARM?
[02:22:23] <Tobba> eddyb: for example, my ABI declares all pointers in the range 0-4095 to be invalid
[02:22:26] <eddyb> http://me.bios.io/ME:About
[02:22:28] <Tobba> nullability on crack
[02:23:30] <eddyb> Tobba: oh, this is what I was looking for http://me.bios.io/images/5/5e/Intelme.png
[02:24:00] *** Joins: atomic (atomic@moz-4gk6rj.torservers.net)
[02:24:26] <Tobba> it's not really suprising we can't count the cores anymore
[02:24:34] <Tobba> but it's scary that we can't count what can access main memory anymore
[02:25:16] <zeiris> Yup. I've long since abandoned the general purpose computer ship and only care about securing embedded devices :)
[02:25:48] <bascule> Tobba: SGX can solve that problem... "solve", maybe
[02:26:19] <zeiris> Get an application/network stack right. And probably OS to keep the thing in check as it grows complex. Then port it to minimal hardware once it becomes available.
[02:26:50] <eddyb> the Mill might be good
[02:27:02] <eddyb> but you'd still have all the crap around it on a regular PC
[02:27:21] <Tobba> zeiris: I'll have to achieve world domination with my Rust OS
[02:27:29] <Tobba> just need to get the overhead of the µKernel low enough...
[02:28:01] <zeiris> Put that OS in a giant robot, it can fight mine + the seL4 + the Galois ones when it's done :)
[02:28:09] <Tobba> (it cheats by lots of stuff in kernel space, which should be fine thanks to rust)
[02:28:21] <Tobba> by running lots of stuff in kernel space*
[02:28:40] <Tobba> on something like a Mill where context switches aren't hideously expensive you can go full µKernel though
[02:29:38] <zeiris> Hah. I guess having a big kernel in a safe but still performant language is kind of novel. Ada doesn't seem that performant when it's safe.
[02:30:14] <Tobba> the kernel should only be roughly 128kb when it's done
[02:30:23] <zeiris> Targeting x86?
[02:30:29] <Tobba> everything else is in other modules, only thing I'm worried about perf wise is task creation and IPC
[02:30:31] <Tobba> yep
[02:30:42] <zeiris> How are you handling the crappy-driver problem?
[02:31:04] <Tobba> anything that can run in kernel space can also be punted down to user space
[02:31:18] <Tobba> there are wrapper routines for doing I/O
[02:31:34] <Tobba> and if you don't use those it'll emulate them in the fault handlers for trying to do I/O in user mode, because fuck you
[02:31:57] <Tobba> (and then the performance is down the toilet, but that's another matter)
[02:32:25] <zeiris> hahaha
[02:32:44] <Tobba> but those wrapper routines also means that every driver is testable, even if it accesses hardware directly
[02:32:50] <Tobba> since they can be run in user mode against virtual hardware
[02:33:04] <Tobba> :D
[02:33:10] <zeiris> That's kind of hot. 
[02:33:36] <zeiris> Testing stuff that interacts with hardware vs a software simulation of that hardware is, like, working with hardware effectively 101. But is surprisingly uncommon despite that.
[02:33:49] <Tobba> yep
[02:34:12] <Tobba> next challenge: write the emulators so well they can also be integrated with QEMU
[02:34:34] <Tobba> ... or write emulators for QEMUs emulation, which is suprisingly crappy for some things like e1000 NICs
[02:34:45] <Tobba> (for example, the reset function which is meant to reset all registers does nothing)
[02:35:16] <Tobba> it just happens that the PXE driver won't screw anything up beyond what the drivers for linux and windows restore
[02:35:45] <zeiris> So driver dev process involves booting the OS in QEMU with a device simulator hooked up to it?
[02:36:02] <Tobba> nah, they can run under linux as well
[02:36:44] <Tobba> it'll need a few other services to talk to, but it shouldn't be too tricky to emulate them / just run those as well
[02:37:13] <Tobba> since all it relies on the kernel for is task switching and IPC, which is done by linking to a thin runtime
[02:37:30] <Tobba> you can write a runtime that just plumbs all of this through POSIX instead
[02:39:22] <Tobba> (there are a few areas around CoW memory that might get a bit quirky, but it should be solvable, and for testing purposes the performance doesn't really matter anyways)
[02:39:37] <zeiris> Neat!
[02:40:06] <Tobba> I'll admit to only having written half of that component so far, the interface to the runtime is in a bit of too much flux atm
[02:40:46] <Tobba> atm I'm toying with the kernel running a very RTOS like scheduler -- run the task with the highest priority. and then having a task that monitors the time each task under its control uses and fiddles with their priorities
[02:41:50] <Tobba> I can change the model to something more traditional if that gets finnicky though
[02:42:14] <Tobba> specifically, you probably want to prioritise the next task using the same address space as the one you're currently in, to avoid TLB flushes
[02:42:18] <zeiris> Schedulers are a religious choice, anyway. It'll be bad for someone's use case no matter what.
[02:42:56] <Tobba> I just found that the RTOS choice was neat around interrupts and various cases that require good timing
[02:44:16] <Tobba> using priority inheritance might also be a poor idea, I'll have to see about that
[02:45:50] <Tobba> slightly worried about ending up in a middle ground between modern monolithic OSes and RTOSes where everything just sucks
[02:45:57] <Tobba> OTOH I might land in a sweet spot, will have to try it really
[02:46:20] *** Quits: dpc (dpc@moz-t6gr4b.ca.comcast.net) (Ping timeout: 121 seconds)
[02:50:03] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[02:56:33] <eternaleye> zeiris: re "on something like a Mill where context switches aren't hideously expensive you can go full µKernel though", have you seen the "From L3 to seL4" paper?
[02:57:10] <eternaleye> zeiris: Context switches really _aren't_ hideously expensive except on pathological architectures (*cough*NetBurst/P4*cough*)
[02:57:55] <Tobba> eternaleye: the switches themselves? no
[02:58:04] <Tobba> it's the TLB/cache flushing that kills it
[02:58:10] <eternaleye> Tobba: They measured one-way IPC
[02:58:20] <eternaleye> Tobba: Not pure context switch
[02:58:23] <eternaleye> Tobba: So....
[02:58:32] <Tobba> interesting
[02:58:50] <eternaleye> Tobba: IIRC, it was... 300cycles on HSW?
[02:58:50] <Tobba> nonetheless, getting the TLB flushed in the middle of your workload may not be ideal
[02:59:08] <Tobba> that's quite affordable
[02:59:11] <eternaleye> Tobba: Doesn't have to, though.
[02:59:20] <eternaleye> Tobba: Lots of stuff supports ASIDs these days.
[02:59:28] <Tobba> true, even x86
[02:59:33] <Tobba> I need to add support for that, actually
[03:01:21] <Tobba> let me read that paper
[03:02:33] <eternaleye> Tobba: http://flint.cs.yale.edu/cs428/doc/L3toseL4.pdf
[03:02:53] <Tobba> can't connect, but I found another copy
[03:06:43] *** Joins: c74d3 (c74d3a4ebb6@moz-u3bdim.mggc.hibn.4404.2002.IP)
[03:06:44] <eternaleye> Anyway, Pentium 4 is _hilariously_ bad (2000 cycles, wtf), but the next two _worst_ are ARM Cortex A9 (316) and Haswell (301)
[03:07:14] <eternaleye> So yeah, context switches don't have to be slow by any stretch
[03:08:17] *** Quits: c74d (c74d3a4ebb6@moz-0ersgu.oc.cox.net) (Ping timeout: 121 seconds)
[03:08:39] *** c74d3 is now known as c74d
[03:09:20] <Ilari> Wonder how long it would take to switch address spaces inside system call and return to new address space (saving and restoring registers)...
[03:10:05] <eternaleye> Ilari: Well, on RISC-V it'd be one instruction if the new ASID is already in a register...
[03:10:16] <eternaleye> Ilari: (swap the new ASID with the old ASID)
[03:10:22] <eternaleye> Then use ERET to return back
[03:10:43] <eternaleye> Ah, no, saving and restoring
[03:10:56] <eternaleye> Add 32 stores and loads to that :P
[03:11:09] <eternaleye> Well, 31
[03:11:17] <eternaleye> x0 is a hardwired zero register
[03:16:13] <Ilari> That kind of operation (execute far call into another address space and return from such call) shows a fair bit in one of my odd ideas about sandboxing.
[03:33:14] <eternaleye> Ilari: Oh, in that case I'd skip register saving.
[03:33:30] <eternaleye> Ilari: I mean, if you treat it as a function call, you already have caller-saved/callee-saved/etc
[03:34:04] <eternaleye> Ilari: Then it becomes "map from function cap target to ASID, set ASID, return into target.
[03:34:06] <eternaleye> :
[03:34:07] <eternaleye> *"
[03:35:11] <eternaleye> Which is, um, pretty similar to how seL4 does messages.
[03:41:55] <Ilari> Except caller has to be able to set callee registers in arbitrary way (that is legal for userspace).
[03:44:49] <eternaleye> Ilari: No, the return just behaves the same as the call.
[03:44:50] <eternaleye> Ilari: You set your own registers, and on return they too are left intact by the kernel.
[03:44:51] <eternaleye> Ilari: You know, like how an actual function call does it inside an address space :P
[03:45:02] <eternaleye> Ilari: CHERI may be of interest to you
[03:45:17] <eternaleye> Ilari: Hardware capabilities, used in pretty much exactly that manner
[03:48:30] <Ilari> Also, return can be in response to hardware fault (such as SIGSEGV), and the code control is returned to gets to first deal with the fault (it needs fault info).
[04:03:38] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[04:06:51] *** Joins: dpc (dpc@moz-t6gr4b.ca.comcast.net)
[04:23:30] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[04:24:47] <bascule> kmc: have you given any thought to how hard it would be to add dependent constants to Rust? seems Ilari needs them badly
[04:25:00] <bascule> kmc: I mean, I saw your slides on dependent types in Rust
[04:25:08] <bascule> should probably watch the video of the launch night
[04:25:22] <bascule> I was in Japan... kind of thought about showing up to Rust Samurai
[04:36:27] <eternaleye> Ilari: In my kernel, I'm tempted to make SEGV simply insta kill the thread, with the thread-handle carrying an exit cause of "died to segv" or similar.
[04:36:58] <eternaleye> Ilari: So whoever spawned it (or whoever they passed the handle off to) can handle that.
[04:37:13] <eternaleye> Ilari: (which might even include resuming execution somewhere)
[04:37:49] <eternaleye> Ilari: Since my thread-spawning API will likely be along the lines of "In this address space, start executing with this stack pointer and this PC value"
[05:20:08] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[05:44:25] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[06:01:59] *** Joins: skeuomorf (skeuomorf@moz-3l1.21q.32.197.IP)
[07:18:48] *** Quits: c74d (c74d3a4ebb6@moz-u3bdim.mggc.hibn.4404.2002.IP) (Ping timeout: 121 seconds)
[07:19:40] *** Joins: c74d (c74d3a4ebb6@moz-0ersgu.oc.cox.net)
[07:29:12] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[07:33:40] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[08:25:26] *** Joins: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua)
[09:21:53] *** Quits: dpc (dpc@moz-t6gr4b.ca.comcast.net) (Ping timeout: 121 seconds)
[11:06:27] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[11:11:12] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[13:08:05] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[13:12:45] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[13:24:57] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[13:45:28] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[14:02:11] *** Joins: erickt_ (erickt@moz-njt.vqi.14.76.IP)
[14:04:40] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[14:25:29] *** Quits: erickt_ (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[16:06:50] *** Joins: eddyb_ (eddyb@moz-vpa.2f0.121.86.IP)
[16:09:34] *** Quits: eddyb (eddyb@moz-7uq.hlc.26.188.IP) (Ping timeout: 121 seconds)
[16:13:07] *** eddyb_ is now known as eddyb
[16:57:41] *** Joins: brson (brson@moz-cfhap5.mtv2.mozilla.com)
[17:31:21] *** Joins: erickt (erickt@moz-4hh.6p3.217.74.IP)
[17:41:42] <Ilari> Okay, got some test code written (but didn't dump annotations yet). At least some basic tests pass (on both curves).
[17:49:01] <bascule> Ilari: for Ed448DSA or whatever you're calling it?
[17:49:04] <bascule> (and Ed25519)
[17:49:42] <bascule> someone on the TLS list talking about a Noise-like handshake with Curve25519 again
[17:54:09] <Tobba> why would you use a 128-bit curve
[17:54:18] <Tobba> I thought 256-bit ones were fast enough nowadays
[17:59:25] <Tobba> oh wait, it's a 256-bit curve with 128-bits of security, that makes more sense
[18:04:34] <bascule> Tobba: Curve25519 is, yes...
[18:04:51] <bascule> Ed448-Goldilocks is closer to 224-bits
[18:05:01] <bascule> a.k.a. "spinal tap grade" security
[18:06:23] <Tobba> I like the sound of that
[18:06:37] <Tobba> I'm assuming it goes to 11
[18:10:08] <bascule> of course!
[18:10:36] <Tobba> but why not just make 10 more secure?
[18:12:20] <bascule> lolol
[18:20:58] <Ilari> Not quite "stratospheric". :-)
[18:31:31] <Ilari> Sheesh, this thing has an (pretty much banana) attack I would like to address, but I need to think of the best way to do that... :-/
[18:43:45] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Connection closed)
[18:44:31] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[19:00:04] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[19:00:27] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[19:09:06] *** Quits: erickt (erickt@moz-4hh.6p3.217.74.IP) (Ping timeout: 121 seconds)
[19:26:17] *** Quits: blank_na1e (blank_name@moz-p4egrb.mi.frontiernet.net) (Quit: leaving)
[19:30:12] *** Joins: blank_name (blank_name@moz-p4egrb.mi.frontiernet.net)
[19:37:58] *** Quits: atomic (atomic@moz-4gk6rj.torservers.net) (Ping timeout: 121 seconds)
[19:38:07] *** Quits: irobevjodu (ident@moz-5bq.k90.254.5.IP) (Ping timeout: 121 seconds)
[19:38:54] *** Joins: atomic (atomic@moz-h065j7.torservers.net)
[19:42:15] *** Joins: irobevjodu (ident@moz-3vi4l0.static-ro.twistednetworks.net)
[19:43:56] *** Joins: irobevjod (ident@moz-3vi4l0.static-ro.twistednetworks.net)
[19:44:13] *** Quits: irobevjodu (ident@moz-3vi4l0.static-ro.twistednetworks.net) (Connection closed)
[19:44:42] *** Joins: irobevjodu (ident@moz-3vi4l0.static-ro.twistednetworks.net)
[19:45:01] *** Joins: irobevjod2 (ident@moz-3vi4l0.static-ro.twistednetworks.net)
[19:48:28] *** Quits: irobevjod (ident@moz-3vi4l0.static-ro.twistednetworks.net) (Ping timeout: 121 seconds)
[19:49:18] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Connection closed)
[19:49:48] *** Quits: irobevjod2 (ident@moz-3vi4l0.static-ro.twistednetworks.net) (Connection closed)
[19:49:48] *** Quits: irobevjodu (ident@moz-3vi4l0.static-ro.twistednetworks.net) (Connection closed)
[19:50:21] *** Joins: irobevjodu (ident@moz-3vi4l0.static-ro.twistednetworks.net)
[19:50:41] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[19:59:17] *** Joins: Tuba (Tobba@moz-o13d22.bredband.telia.com)
[20:02:13] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[20:08:07] *** Tuba is now known as Tobba
[20:13:04] *** Quits: irobevjodu (ident@moz-3vi4l0.static-ro.twistednetworks.net) (Quit: No Ping reply in 180 seconds.)
[20:14:15] *** Joins: irobevjodu (ident@moz-3vi4l0.static-ro.twistednetworks.net)
[20:16:12] *** Joins: erickt (erickt@moz-4hh.6p3.217.74.IP)
[20:19:57] *** Joins: dpc (dpc@moz-t6gr4b.ca.comcast.net)
[20:53:59] <eternaleye> bascule: Did you see Michael StJohns' newest post on the tls list?
[20:55:40] <eternaleye> bascule: He wants cert formats for curve25519 static ECDH. Rolling his own way of attesting to ephemeral keys with them. Instead of, you know, EdDSA. Or even saying "ECDH using TripleDH"
[21:18:55] <bascule> eternaleye: yes
[21:19:38] <bascule> see also some random person on the Noise list like "I homebrewed my own key exchange, now what?"
[21:55:32] *** Quits: eddyb (eddyb@moz-vpa.2f0.121.86.IP) (Ping timeout: 121 seconds)
[22:06:16] *** Quits: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua) (Ping timeout: 121 seconds)
[22:24:01] *** Quits: skeuomorf (skeuomorf@moz-3l1.21q.32.197.IP) (Ping timeout: 121 seconds)
[22:27:47] <Ilari> Heh, reminds me that I did homebrew my own key exchange back in 2011... :-)
[22:38:46] <Ilari> Certainly not as bad track record as precessor of that protocol: That took me about a week to break in a nasty way (with hacky workarounds). Oh, I didn't homebrew that one...
[22:42:37] *** Quits: irobevjodu (ident@moz-3vi4l0.static-ro.twistednetworks.net) (Ping timeout: 121 seconds)
[23:55:52] *** Joins: irobevjodu (ident@moz-5bq.k90.254.5.IP)

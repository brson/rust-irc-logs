[00:01:40] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[00:01:40] *** Joins: pcwalton (pcwalton@moz-481A040C.hsd1.ca.comcast.net)
[00:01:40] *** ChanServ sets mode: +o pcwalton
[00:02:22] <doener> wth is valgrind doing? 3 hours for something that usually takes 8 seconds?!
[00:02:53] * doener is desperate
[00:03:03] <aatch> doener, valgrind essentially acts as an interpreter
[00:03:38] <pcwalton> I'm going to talk to brson and graydon about cycle time
[00:03:39] <doener> yeah, but it's usually said to slow things down by a factor of 20-30 for memcheck, not 1300
[00:03:48] <pcwalton> I'd be fine with turning off Valgrind and no-opt
[00:04:07] <doener> pcwalton: this is a local valgrind run on my box, compiling libextra
[00:04:09] <pcwalton> oh
[00:04:12] <pcwalton> well, still
[00:04:13] <aatch> doener, it also serializes threads.
[00:04:45] <aatch> doener, so it hits multi-threaded code even harder
[00:04:45] *** Quits: Earnestea (earnest@2A2BF8F5.321FA5E6.BFD1ABFD.IP) (Ping timeout)
[00:05:20] <doener> aatch: hm, I'm actually running a pretty hacked rustc by now. Hard "return" after the translation pass, which was completed after 3 minutes, the current run clocks in at 39 minutes now
[00:05:42] * pcwalton laughs at the 16x JSON parsing speedup in the queue
[00:05:51] <aatch> pcwalton, yeah...
[00:06:05] <aatch> pcwalton, it's either laugh or cry
[00:06:17] <pcwalton> we need to newsched-ify IO
[00:08:29] *** Joins: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net)
[00:09:56] <glinscott> pcwalton: read_chars is still about 27% of the benchmark, unicode::general_category is another 26%, so still good room for improvement :)
[00:10:02] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[00:10:13] <pcwalton> yikes @ unicode
[00:10:30] <glinscott> to be fair, this file is a unicode stress test it appears
[00:10:52] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[00:10:55] <dbaupp> glinscott: you are amazing! :)
[00:12:09] *** Joins: dualhbridge (dad@moz-9FEE6D3B.maine.res.rr.com)
[00:12:12] <aatch> ok, 4 AST types with `@` removed
[00:12:37] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[00:12:41] <dbaupp> aatch: are you camel-casing them while you're at it? ;)
[00:12:48] *** Parts: dualhbridge (dad@moz-9FEE6D3B.maine.res.rr.com) ()
[00:12:51] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[00:12:56] <aatch> dbaupp, -.-
[00:13:14] *** Joins: igl1 (igl@moz-43716F86.adsl.alicedsl.de)
[00:13:16] <dbaupp> I take that as a yes, cool!
[00:13:20] <dbaupp> ;P
[00:13:32] *** Quits: igl (igl@moz-DB2E5F2B.adsl.alicedsl.de) (Ping timeout)
[00:13:47] <strcat> pcwalton: https://github.com/mozilla/rust/pull/7605 my progress so far on removing the headers btw, I really can't figure out the glue issue though
[00:13:51] <aatch> fortunately this is much easier because they aren't @mut, so in a lot of cases I can just change the @ to a & and it 'just works'
[00:14:11] <strcat> pcwalton: I think it's just still treating ~[] and ~T somewhere
[00:14:40] <glinscott> dbaupp: hehe, yay for buffering reads :)  ReaderUtil::read_char could use some love, but adding a buffer to all io readers would be overkill probably
[00:15:26] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[00:15:35] <dbaupp> glinscott: well, the current std::io is going to be entirely deleted (waaaay too much `@`), so the new one will hopefully have a better read_char :)
[00:15:44] <strcat> I don't think json should do buffering
[00:15:52] <pcwalton> strcat: I saw the PR
[00:15:56] <strcat> there are times you don't want buffering
[00:15:56] <pcwalton> yeah, I suspect so
[00:16:05] <strcat> strings can be readers/writers
[00:16:07] <aatch> strcat, well it should be working from a Reader
[00:16:38] <strcat> silly glue >.<
[00:17:04] <glinscott> strcat: the current code still calls read_chars, which is exactly what read_char does.  so the worst case should be the same
[00:17:34] <strcat> does read_char really use a 64k buffer though?
[00:17:49] <strcat> always
[00:18:09] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Quit: Leaving.)
[00:18:10] <strcat> for example I should be able to mmap a file and parse it, without any buffering
[00:19:17] <glinscott> strcat: a json file?  it's not a streaming interface, you get the object back at the end
[00:19:40] <strcat> glinscott: yes, a json file
[00:19:48] <strcat> buffering should be entirely up to the Reader/Writer
[00:20:03] <strcat> you don't want buffering when reading from a string or mapped memory
[00:20:32] <strcat> it makes one case look better at the expense of others and memory usage
[00:20:39] <glinscott> strcat: again, if parsing json to return an object, you need the entire string
[00:20:57] <strcat> glinscott: sure, and you don't need buffering to read it from a string or mapped memory
[00:21:32] <strcat> it will only be slower
[00:21:44] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[00:22:30] <strcat> I just think we should be fixing the real issues
[00:22:56] <dbaupp> strcat: fixing the real issue is done by waiting for the new runtime/io
[00:23:37] <strcat> or we could just remove json, rope, arena, etc. and everything else that's not written well
[00:23:51] <strcat> set a high bar for including something in the stdlib instead
[00:24:15] <strcat> json happens to be blocking fixing strings
[00:24:23] <dbaupp> how so?
[00:24:25] *** Joins: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net)
[00:24:29] <strcat> it puts invalid utf-8 in them
[00:24:36] <strcat> I don't know why
[00:24:48] *** Quits: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com) (Quit: webber46)
[00:24:54] <strcat> I've wanted to fix strings for a while
[00:27:00] <strcat> or I could just fix strings and turn off broken tests from it
[00:27:05] <aatch> ugh, I had to make a function take a & &[T]
[00:28:02] <dbaupp> strcat: the latter is reasonable
[00:28:41] <glinscott> strcat: yes, string parsing should be done as a special case.  mmap though - that still needs to convert bytes to unicode
[00:29:12] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[00:29:14] <strcat> glinscott: str is utf-8, and the bytes you read in will be utf-8 - so it shouldn't need to copy afaik
[00:29:19] <strcat> just needs to verify
[00:29:29] <glinscott> strcat: yes - i agree
[00:29:42] *** Quits: vk (vk@2AAA6DD0.B568D26C.93B001FA.IP) (Quit: vk)
[00:30:06] *** Quits: jyyou (jyyou@moz-47B052FA.cs.nctu.edu.tw) (Input/output error)
[00:30:08] <glinscott> strcat: actually, verify the utf-8?  i'm assuming if you get a string object, you can assume it's safe?
[00:30:25] <strcat> glinscott: well if strings were sound ;p
[00:30:35] <strcat> glinscott: our file apis are all wrong though
[00:30:39] <strcat> they abuse str when they really mean u8
[00:30:57] <strcat> anyway I think I'll just fix strings and xfail anything that breaks
[00:30:58] <dbaupp> (not just the file ones.)
[00:31:25] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[00:32:48] <glinscott> strcat: ah, unfortunate.  well, assuming that's fixed, the string version would be very simple :)
[00:36:43] *** Joins: Nisstyre (wes@moz-FD86289.netflash.net)
[00:39:38] <aatch> dbaupp, whats the link for IRSY again?
[00:40:52] <doener> http://huonw.github.io/isrustfastyet/
[00:41:06] <doener> and http://huonw.github.io/isrustfastyet/mem/
[00:41:06] <aatch> doener, no, the new one
[00:41:22] <aatch> ah, thank you
[00:42:03] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[00:42:15] <doener> IRSY ~ is rust slow yet
[00:42:31] <dbaupp> "yes"
[00:42:57] <doener> "right"
[00:43:22] <aatch> Hmm, If I can make these changes, I think I can make it at least drop the AST after translation
[00:44:35] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[00:44:52] <aatch> I mean, peak memory usage won't change much, but at least it's something
[00:45:22] <aatch> the next step would be trying to get trans to actually _consume_ the AST, so the memory gets freed as you go along.
[00:45:28] <aatch> that's harder though
[00:46:29] <strcat> bstrie: you convinced me to report 100 bugs today
[00:46:32] <strcat> ;p
[00:46:35] <strcat> and fix some
[00:46:42] *** Joins: jviereck (Adium@moz-FC72D7C5.pool.mediaways.net)
[00:48:19] *** Joins: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[00:49:08] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[00:50:03] *** Quits: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Ping timeout)
[00:52:45] *** Joins: mat1 (mat@579C1D31.DC7A989C.7F8AB798.IP)
[00:54:14] <mat1> im having some issues getting rust to compile.  i can't seem to get the llvm portion downloaded with rust to work correctly.  
[00:54:42] <mat1> to try to fix it, i downloaded llvm with my distro package manager. 
[00:55:22] <mat1> should i be able to use that llvm instead of the one downloaded with rust?
[00:55:29] <strcat> no
[00:55:34] <strcat> rust has llvm patches
[00:57:31] <dbaupp> cmr: ping
[00:57:51] <mat1> strcat: oh thanks
[00:58:22] <mat1> strcat: im having problems compiling rust's llvm though.  any suggestions?
[00:58:32] *** Quits: doener (doener@moz-121949B3.unitymediagroup.de) (Quit: leaving)
[00:58:37] <strcat> I don't know what you mean by problems
[00:58:38] <strcat> what error?
[00:59:17] *** Joins: paupau (textual@moz-42F29B71.hsd1.ca.comcast.net)
[00:59:19] <mat1> i got a 'File truncated' error.  but it's scrolled off my screen.  let me see if i can reproduce it. 
[01:00:40] <dbaupp> mat1: are you just running Rust's `make`?
[01:01:52] <mat1> dbaupp: yup
[01:02:10] <strcat> mat1: can you try cloning rust's repo again? maybe something went wrong with the submodules
[01:02:42] <mat1> strcat: ok i will try that, before i just downloaded the tar.gz file from front page
[01:02:59] <strcat> mat1: oh well that should work
[01:03:09] <strcat> I built the arch linux packages from 0.7 from that so I know it does
[01:03:32] <Luqman> Makefiles :(
[01:03:35] <mat1> strcat: let me check again
[01:03:47] <mat1> strcat: is the correct way to clean everything 'make clean'?
[01:03:51] *** Joins: BitPuffin (quassel@moz-B986D630.cust.tele2.se)
[01:04:30] <strcat> and make clean-llvm
[01:04:37] <mat1> strcat: i made sure to check the file integrity with gpg after i downloaded, so im pretty sure the downloaded file is okay, but perhaps 'make' mesed up for me
[01:04:47] <mat1> strcat: ok i will try that
[01:04:48] <strcat> mat1: you did ./configure && make, right?
[01:04:55] <mat1> strcat: yup
[01:05:07] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[01:05:13] <aatch> Ugh, the amount of places where something so clearly doesn't need to be @ that most places it's used are done a foo(@arg) is a very bad thing
[01:05:41] <strcat> aatch: we need an escape analysis lint for @ and ~
[01:05:54] <strcat> if it's never passed outside the function as @ or ~, it can be &
[01:06:39] <aatch> strcat, I can imagine the 10000 warnings when hitting our codebase...
[01:07:14] <paupau> wait something can be allocated as &?
[01:07:16] *** Quits: tiffnya (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Connection reset by peer)
[01:07:36] <paupau> oh you're talking about parameter types
[01:07:37] <aatch> paupau, no, but it can be allocated somewhere and then passed around as &
[01:07:45] <paupau> right
[01:07:45] <aatch> which almost always what you want
[01:07:47] <paupau> yeah
[01:08:01] <aatch> and often it can be allocated on the stack
[01:08:04] <paupau> :)
[01:08:14] <paupau> rustc is going to be so fast one day
[01:08:16] <strcat> paupau: if it doesn't escape it can warn you about using ~/@
[01:08:23] *** Quits: glinscott (garylinsco@789A6618.53EB7C1.FFFE3AA.IP) (Quit: glinscott)
[01:08:34] <paupau> thanks, gotta go
[01:08:35] *** Quits: paupau (textual@moz-42F29B71.hsd1.ca.comcast.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[01:08:37] <strcat> dbaupp: https://github.com/mozilla/rust/pull/7612 r?
[01:08:38] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[01:11:44] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Input/output error)
[01:11:51] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[01:12:27] <aatch> slowly getting there. some matching patterns have every single binding by-ref now
[01:12:47] *** Quits: dolphinling (andrew@moz-80A1E448.uvm.edu) (Ping timeout)
[01:12:48] *** Joins: vk (vk@moz-389FEE13.hsd1.ca.comcast.net)
[01:12:55] *** Joins: dolphinling (andrew@moz-80A1E448.uvm.edu)
[01:18:04] *** Joins: Thad (chatzilla@moz-C35F90AE.tx.res.rr.com)
[01:22:01] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[01:22:04] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[01:22:05] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[01:22:37] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[01:23:53] *** Joins: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[01:25:45] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[01:28:09] *** Quits: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net) (Quit: carllerche)
[01:29:10] *** Quits: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Ping timeout)
[01:31:45] <aatch> dbaupp, heh, I just noticed that IRSY uses the commit hash for the highlight color
[01:32:06] <dbaupp> aatch: first 6 letters = rgb yes
[01:32:11] <dbaupp> oh
[01:32:19] * dbaupp just thought of a better way to do it
[01:36:19] <aatch> it's funny, I always seem to break 1 thing in metadata
[01:36:37] <aatch> only one thing, and not always the same thing
[01:37:25] <Jeaye> Still no color output when compiling my own code... but I get it when compiling others' code.
[01:38:05] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[01:40:36] <bjz> rusti: trait Foo { fn foo(&self) -> int; } impl Foo for (int, int, int) { fn foo(&self @ (x, y, z)) -> int { x * y * z } } (1i, 2i, 3i).foo()
[01:40:39] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/QEbX
[01:41:10] <bjz> is there a way of destructuring the self arg?
[01:41:15] <aatch> bjz, no
[01:41:19] <bjz> :(
[01:41:37] <bjz> that's a pain
[01:42:50] <bjz> rusti: fn foo(&x: &int) -> int { x } foo(&1)
[01:42:52] -rusti- 1
[01:43:02] <bjz> I like the fact you can do that now :)
[01:43:24] <bjz> (now that modes are gone)
[01:44:19] <strcat> defining Iterable runs into stupid rvalue lifetime issues
[01:45:29] *** Quits: jviereck (Adium@moz-FC72D7C5.pool.mediaways.net) (Quit: Leaving.)
[01:47:28] <Jeaye> bjz: Woah, what does that do?
[01:47:33] <Jeaye> The &x
[01:47:56] * Jeaye is such a Rust noob.
[01:48:05] <strcat> it's just a pattern
[01:48:06] <bjz> Jeaye: destructures the argument
[01:48:12] <aatch> Jeaye, it destructures it
[01:48:15] <aatch> same as in a match
[01:48:33] <bjz> Jeaye: that's what happens when you do .map(|&x| ...)
[01:48:55] * dbaupp scolds bjz for not using .transform
[01:48:57] <dbaupp> :P
[01:49:10] <bjz> dbaupp: eh, I like the succinctness
[01:49:31] <bjz> rusti: fn foo((x, y, z): (int, int, int)) -> int { x * y * z } foo((1, 2, 3))
[01:49:32] -rusti- 6
[01:49:32] * dbaupp wants 5898 to be fixed already
[01:49:57] <Eridius> so fix it!
[01:50:57] * dbaupp looked at resolve
[01:51:01] * dbaupp ran away
[01:51:22] <aatch> "I have stared into the void and the void stared back"
[01:51:51] <dbaupp> (it wasn't quite as scary as trans)
[01:52:19] <aatch> dbaupp, that's more "I have seen the enemy and he is us"
[01:52:29] <dbaupp> heh
[01:52:42] <dbaupp> (it's improving, right? ;) )
[01:53:11] <aatch> dbaupp, not right now. I'm having a stab at libsyntax at the moment.
[01:53:20] <bjz> Jeaye: does that make sense?
[01:53:29] <dbaupp> yeah, making asg into ast :D
[01:53:46] <bjz> Jeaye: basically means you don't have to dereference it later
[01:54:32] <aatch> dbaupp, yeah, right now I'm actually making it slightly worse in places, but that's because there are places where I should be able to consume the argument, but the argument is @
[01:54:35] <bjz> Jeaye: oh btw, is glfw still weird on osx? if so, have you thought of maing an issue on the repo?
[01:54:53] <bjz> *making
[01:54:59] <aatch> So I have to copy
[01:55:16] <dbaupp> bjz, Jeaye: it's worth noting that currently matches in let and function arguments are currently unsound, and you can use it to copy things that can't normally be copied.
[01:55:57] <dbaupp> rusti: struct A; impl Drop for A { fn drop(&self) { println("dropped"); } let a = A; let &_b = &A;
[01:56:04] -rusti- <anon>:10:0: 10:1 error: file ended with unbalanced delimiters
[01:56:04] -rusti- <anon>:10 }
[01:56:04] -rusti-           ^
[01:56:04] -rusti- application terminated with error code 101
[01:56:17] <dbaupp> rusti: struct A; impl Drop for A { fn drop(&self) { println("dropped"); } } let a = A; let &_b = &A;
[01:56:20] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/eiOZ
[01:56:31] <dbaupp> o_O three times
[01:56:45] <dbaupp> rusti: struct A; impl Drop for A { fn drop(&self) { println("dropped"); } } let a = A; let &_b = &a;
[01:57:05] -rusti- dropped
[01:57:05] -rusti- dropped
[01:57:06] -rusti- ()
[01:59:59] *** Joins: paupau (textual@moz-B04700CD.hsd1.ca.comcast.net)
[02:00:10] *** Quits: Ralith (ralith@moz-4D9F8DC3.wireless.sfu.ca) (Ping timeout)
[02:00:26] <aatch> Ok, some of the code I'm working with here is so old it predates method calls being their own syntax
[02:00:44] <dbaupp> deletable?
[02:00:50] <Jeaye> bjz: I think it's still busted. I've been on vacation for the past week, so I haven't been tinkering too much. I'll pull again later this weekend and if it's still broken  I'll make an issue on Github for them.
[02:00:56] <dbaupp> aatch: or is it still used?
[02:01:00] <aatch> dbaupp, nope, unless you don't want conditional compilation
[02:01:19] <dbaupp> meh, it's not like we use it ever; kill it. :P
[02:01:50] <aatch> but theres a bit of code that casts the self argument to a trait object then calls a method on it
[02:01:58] <aatch> because there is a field with the same name
[02:02:43] <aatch> (I have of course changed that)
[02:03:54] *** Joins: dcamp (dcamp@moz-930D5B64.hsd1.wa.comcast.net)
[02:04:29] <dbaupp> wait, seriously?
[02:04:34] <dbaupp> (where?)
[02:04:43] <aatch> dbaupp, in fold.rs
[02:04:53] <aatch> (it's not nice code)
[02:05:26] <dbaupp> no
[02:05:46] * dbaupp thinks a trait based visitor wouldn't go amiss
[02:05:48] <dbaupp> ;)
[02:06:01] <aatch> dbaupp, cmr's using the one I made in rustdoc
[02:06:07] <dbaupp> yeah, I saw
[02:06:12] <dbaupp> (is it working ok?)
[02:06:20] <aatch> dbaupp, I assume so.
[02:06:33] <dbaupp> he hasn't complained too much?
[02:06:46] <aatch> dbaupp, not that I've noticed
[02:06:55] <dbaupp> always a good sign
[02:08:06] <paupau> Can I have borrow something into a struct indefinitely?
[02:08:16] <aatch> paupau, what do you mean?
[02:08:39] <paupau> I can store a borrowed pointer into a struct with a lifetime annotation right
[02:08:50] <aatch> paupau, yes
[02:08:58] <paupau> how long could I make that lifetimeâ€¦ only as long as a stack record?
[02:09:13] <paupau> could I link it to the lifetime of some other owned object?'
[02:09:17] <aatch> paupau, lifetimes don't really work like that
[02:09:35] <aatch> you can't use lifetime annotations to change the lifetimes of objects
[02:09:51] <paupau> only to please the checker, huh.
[02:09:57] <aatch> paupau, correct
[02:10:04] <mat1> strcat: not sure if you are still here, but looks like everything worked out okay after the 'make clean && make clean-llvm'.  thx for the help. 
[02:10:16] <darkf> there isn't currently something like python's StringIO that implements Reader on, say, ~[u8], is there?
[02:10:27] <dbaupp> yeah, lifetime annotations are so only that Rust can reason about them, and enforce them
[02:10:38] <aatch> darkf, there is kinda
[02:10:38] <dbaupp> darkf: io::with_{bytes,str}_reader
[02:10:40] <paupau> aatch: so the lifetimes it'll accept areâ€¦ compiler-figured-out regionsâ€¦ and 'staticâ€¦ for now?
[02:11:10] <aatch> paupau, sort-of
[02:11:15] <dbaupp> paupau: the compiler doesn't really compute regions, it just checks the ones you've written are valid
[02:11:24] <darkf> dbaupp: ah, so just no version that returns an object :-) thanks, that will do
[02:11:27] <aatch> dbaupp, well it does compute regions too
[02:11:37] *** Quits: Thad (chatzilla@moz-C35F90AE.tx.res.rr.com) (Quit: ChatZilla 0.9.90 [Firefox 23.0/20130701144430])
[02:11:39] <dbaupp> aatch: right, but it doesn't reason globally about them
[02:11:43] <aatch> it's just really basic about it
[02:12:02] *** Parts: mat1 (mat@579C1D31.DC7A989C.7F8AB798.IP) (good bye!)
[02:12:34] <paupau> aatch: I guess you could propagate a region around a bunch by annotating 'r everywhere right
[02:12:48] <paupau> and by propagating I mean requiring
[02:12:54] *** Joins: z0w0 (zack@E2E93C1.54F16452.2CE63F58.IP)
[02:13:15] <dbaupp> paupau: yes
[02:13:22] <aatch> paupau, yep, if you allocate an object high in the stack, you can pass it around as &'r T anywhere below there
[02:13:23] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[02:13:37] <aatch> as long as everything is annotated properly
[02:13:50] <aatch> you have to watch out for overlapping borrows though
[02:14:13] <aatch> so it's not quite as simple as just throwing & everywhere
[02:14:27] *** Joins: wilfred (uid159@moz-5F4AA75A.irccloud.com)
[02:14:29] <aatch> as if you want to change the object, you need a &mut and that needs a little more care
[02:14:49] *** Joins: geomyidae__ (uid214@moz-A42E5B7B.irccloud.com)
[02:14:51] <paupau> great!
[02:15:20] <paupau> ah I see, lifetime parameters are implicit in call sites
[02:15:23] <paupau> attached to their variables
[02:15:29] <aatch> paupau, but properly-written Rust code should, in theory, never need a copy unless absolutely needed.
[02:15:57] <aatch> paupau, yes, regions are also inferred, so you only need the annotations on function declarationsa
[02:16:16] <aatch> Rust, to some extent, treats regions and types in a very similar way
[02:16:39] <dbaupp> paupau: (to be clear, with &mut, the care is only in getting the code to compile; except for compiler bugs, code that compiles won't access invalid memory, or mutate an object it shouldn't.)
[02:16:44] <aatch> hence why lifetime parameters are in the <>
[02:17:13] <aatch> dbaupp, which is why I love properly-written Rust so much
[02:17:28] <dbaupp> aatch: right
[02:17:40] <paupau> so good
[02:17:43] <dbaupp> aatch: it's the best bits of Haskell and C
[02:17:54] <aatch> If I was running a project written in Rust, I'd have the @-allocation lint turned to deny
[02:18:00] <paupau> duhuhu
[02:18:08] <dbaupp> aatch: (except for io :/ )
[02:18:19] <strcat> dbaupp: you can just use stdio directly
[02:18:31] <aatch> so people would have to justify their usage of @ and mark it with allow
[02:18:42] <dbaupp> strcat: i.e. import puts etc?
[02:19:06] <strcat> dbaupp: well, not actually puts
[02:19:11] <aatch> re-write stdio in rust! (actually quite feasible)
[02:19:19] <paupau> Yeah, specifying ownership is so good. Beats the pants off of manual lifetime management in globally GC'd languages.
[02:19:45] <paupau> Objective-C with ARC is close...
[02:20:02] <paupau> what other languages have thisâ€¦ Clean, maybe?
[02:20:16] <aatch> paupau, I think Cyclone does
[02:20:21] <dbaupp> aatch: I assume syscalls are blocked on asm! being reasonable, which is blocked on platform management being reasonable, which is currently "blocked" on asg -> ast?
[02:20:47] <paupau> neat
[02:21:17] <aatch> dbaupp, hmm, well syscalls are perfectly possible, it's just that the asm isn't very nice.
[02:21:30] <aatch> the ast being made sane is me getting distracted
[02:21:54] <paupau> in which ways do we have an abstract syntax graph right now?
[02:22:08] <aatch> paupau, because of the usage of @ everywhere
[02:22:21] <Eridius> what is cond!() 
[02:22:29] <Eridius> is this like a proto-match?
[02:22:34] *** Quits: BitPuffin (quassel@moz-B986D630.cust.tele2.se) (Ping timeout)
[02:22:45] <paupau> aatch: ah, so in practice it may be a tree but who knows?
[02:22:48] <aatch> to be fair, I'm pretty sure it's actually a dag, so that's not so bad
[02:22:57] <paupau> dag is good
[02:23:08] <aatch> I don't think there are any cycles, but I haven't looked
[02:23:12] <paupau> I'd prefer that var bindings point to the original var definition
[02:23:16] <dbaupp> Eridius: no, it's a neater way to write if foo { } else if bar  { } else if baz { } ...  else { }
[02:23:19] <paupau> but I guess that's post-AST?
[02:23:31] <aatch> paupau, that's part of resolve
[02:23:34] <dbaupp> Eridius: cond!((foo) { } (bar) { } (baz) {  } _ { })
[02:23:49] <paupau> aatch: how does that info get stored? a different tree? lookup table?
[02:24:02] <aatch> the AST doesn't, and shouldn't, know about those links
[02:24:18] <aatch> paupau, and yes, there are a number of maps and tables for storing the information
[02:24:26] <Eridius> dbaupp: I see
[02:24:56] <aatch> which is why the AST using @ is so annoying, since it really doesn't need to
[02:25:05] <aatch> and adds unecessary overhead
[02:25:06] <paupau> aatch: I see. Is it easy to get at resolve's output? Pretty essential for lint
[02:25:12] <aatch> like the 32-byte header
[02:25:26] <aatch> paupau, yeah
[02:25:28] <paupau> that'll be huge for memory footprint, cool!
[02:25:48] <aatch> I'll be curious to see what it does to the memory actually.
[02:26:13] <jmgrosen> why would i be getting "can't find crate for `std`"?
[02:26:47] <paupau> aatch, I'm curious, why do you feel that the AST shouldn't know about bindings' destinations? for tree-ness?
[02:27:01] <aatch> paupau, those links aren't part of the syntax
[02:27:18] <paupau> aatch: ah, I see
[02:27:35] <aatch> in the same way your name 'paupau' isn't part of the syntax of english
[02:27:55] <aatch> but it has semantic meaning as an identifier
[02:27:58] <dbaupp> jmgrosen: what's the full error message?
[02:28:12] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[02:28:28] *** Joins: mye (mye@moz-B464BB1C.dip0.t-ipconnect.de)
[02:28:31] <aatch> but you could, in theory, define a language that uses Rust's syntax, but has completely different semantics.
[02:28:47] *** Joins: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net)
[02:29:03] <jmgrosen> dbaupp: "main.rs:1:0: 1:0 error: can't find crate for `std`" then a caret to a blank line
[02:29:32] <dbaupp> jmgrosen: :(
[02:29:34] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Ping timeout)
[02:29:46] <aatch> jmgrosen, then you probably have the installation messed up.
[02:29:50] *** Quits: ssbr (ssbr@moz-141F89C6.block0.gvtc.com) (Ping timeout)
[02:30:17] <aatch> like using one version of rustc, but having a different version libstd
[02:30:21] <jmgrosen> aatch: hmmâ€¦ a simple hello world works fine
[02:30:38] <aatch> jmgrosen, odd. No idea then.
[02:30:43] <jmgrosen> aatch: it seems to only have problems when i use an "extern mod" with -L
[02:30:53] *** Quits: paulproteus (quassel@rose.makesad.us) (Ping timeout)
[02:31:06] <aatch> jmgrosen, what's the extern mod?
[02:31:20] <dbaupp> jmgrosen: what version/hash of rust?
[02:31:24] *** Joins: paulproteus (quassel@moz-E86A3B42.makesad.us)
[02:31:39] <Jeaye> jmgrosen: I have to say -L/opt/local/lib on Mac to have it find the binaries.
[02:32:31] <Jeaye> At least... I did when I started supporting Mac. I still have it though.
[02:33:15] <jmgrosen> aatch: glfw
[02:33:41] <jmgrosen> jmgrosen: but it worked just fine with an older version
[02:33:53] *** Quits: vk (vk@moz-389FEE13.hsd1.ca.comcast.net) (Quit: vk)
[02:34:11] <jmgrosen> dbaupp: erm, how can i get the hash? it's a couple hours old
[02:34:40] <dbaupp> jmgrosen: rustc --version
[02:35:02] <ross> jmgrosen maybe you have multiple copies of std? some in the dir you're doing -L to? although that usually gives an error message about multiple matching crates, rather than not being able to find it
[02:35:21] <ross> I usually get errors like that after building a new version
[02:35:32] <jmgrosen> dbaupp: that only reports 0.7, and i'm using master from a couple hours ago
[02:36:01] <dbaupp> jmgrosen: I get output like 'rustc 0.7 (1c481ec 2013-07-03 16:36:13 +1000)' and the 1c481ec is the hash
[02:36:04] <dbaupp> (fwiw)
[02:36:40] <jmgrosen> ah, i'm an idiot
[02:36:48] <jmgrosen> i had compiled the library with an older version :P
[02:36:57] <jmgrosen> sorry for bothering you all :3
[02:37:09] *** Quits: bytewise (bytewise@moz-649C630D.unitymediagroup.de) (Quit: Leaving)
[02:37:10] <Jeaye> Lucky you didn't get an ICE.
[02:37:25] <Jeaye> There's incompatibility between such binaries, I believe.
[02:37:27] <dbaupp> jmgrosen: not really... rust handles that case really poorly :)
[02:37:58] <dbaupp> Jeaye: sort of, it reads them fine, but doesn't actually check they contain what it expects; and so kaboom.
[02:38:22] <Jeaye> ahh
[02:38:42] <dbaupp> (it could, relatively easily, print a proper error message; but the current structure of the crate reader is pretty bad.)
[02:39:01] <dbaupp> (so "relatively easily" isn't actually true.)
[02:41:37] <bjz> jmgrosen: don't worry about bothering us!
[02:42:25] <jmgrosen> bjz: ok :P
[02:42:48] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Bye!)
[02:42:53] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[02:44:33] *** Quits: zz_kimundi (kimundi@moz-2AE0A3D9.dip0.t-ipconnect.de) (Ping timeout)
[02:44:34] *** Joins: cowboyd (cowboyd@moz-DD0FF83.lightspeed.austtx.sbcglobal.net)
[02:47:06] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[02:47:06] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 148b6b661 to 1458eb70a: 02http://git.io/N3iJvQ
[02:47:06] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[02:47:20] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[02:47:21] <ghrust> 01[13rust01] 15bors pushed 20 new commits to 06auto: 02http://git.io/tdSrkg
[02:47:21] <ghrust> 13rust/06auto 142f11e69 15Niko Matsakis: Update existing tests to account for stricter, more correct handling of irrefutable patterns
[02:47:21] <ghrust> 13rust/06auto 1422c3695 15Niko Matsakis: Add new tests for irrefutable patterns used in various tricky ways
[02:47:21] <ghrust> 13rust/06auto 1471f2b57 15Niko Matsakis: update ptr intrinsics and rewrite vec routines to be more correct....
[02:47:23] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[02:47:37] *** Joins: zz_kimundi (kimundi@moz-179808A0.dip0.t-ipconnect.de)
[02:48:00] *** zz_kimundi is now known as kimundi
[02:48:55] *** Joins: vk (vk@moz-389FEE13.hsd1.ca.comcast.net)
[02:49:24] <jmgrosen> ok, now i'm still confused: my `extern mod extra; use extra::arc;` isn't working :(
[02:50:26] *** Quits: aatch (aatch@moz-2BB0AC01.cable.telstraclear.net) (Client exited)
[02:51:20] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[02:52:07] <dbaupp> jmgrosen: is the extern mod at the top of the crate?
[02:52:41] <jmgrosen> dbaupp: well, second line, right below another extern mod
[02:52:52] <dbaupp> oh
[02:52:57] <dbaupp> what's the error message?
[02:53:19] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[02:53:51] <jmgrosen> https://gist.github.com/jmgrosen/5938439
[02:53:59] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[02:54:36] *** Quits: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Client exited)
[02:54:49] <Jeaye> task failed at 'option::get none', /Users/jeaye/projects/rust/src/libstd/option.rs:331
[02:54:57] *** Joins: aatch (aatch@moz-2BB0AC01.cable.telstraclear.net)
[02:55:06] <dbaupp> jmgrosen: what happens if you use `use self::extra::arc`?
[02:55:06] <Jeaye> How can I trace that down? gdb doesn't help, since the task just exists.
[02:55:17] <dbaupp> Jeaye: RUST_LOG=::rt::backtrace might help
[02:55:31] <Jeaye> Ahh, alright.
[02:55:32] <dbaupp> Jeaye: also, using .expect("Some message")
[02:55:34] <Jeaye> Thanks. :)
[02:55:47] <Jeaye> dbaupp: What do you mean by expact?
[02:55:47] <dbaupp> Jeaye: (instead of .get())
[02:55:52] <jmgrosen> dbaupp: that workedâ€¦ but why?
[02:56:13] <dbaupp> jmgrosen: you're not running rustc on camera.rs, right?
[02:56:16] <aatch> jmgrosen, is the extern mod in the top-leve crate?
[02:56:36] <aatch> top-level mod rather
[02:56:37] <jmgrosen> extern mod is not in the top-level crate
[02:56:46] <dbaupp> Jeaye: http://static.rust-lang.org/doc/std/option.html#method-expect
[02:56:48] <jmgrosen> is that where i should put it?
[02:56:59] <aatch> jmgrosen, normally, yes
[02:57:19] <dbaupp> jmgrosen: btw, crate = compilation unit (and the top of the crate is the file that you actually run rustc on)
[02:57:20] <Jeaye> dbaupp: Yeah, I don't know where it is though.
[02:57:22] <jmgrosen> aatch: ok, still getting a hang of the semantics
[02:57:31] <Jeaye> So I'll backtrace.
[02:57:31] <aatch> basically, it adds 'extra' to the current module
[02:58:00] <dbaupp> Jeaye: well, you could replace all .get()'s with .expect(fmt!("%? %?, file!(), line!())) for now
[02:58:01] *** Quits: cowboyd (cowboyd@moz-DD0FF83.lightspeed.austtx.sbcglobal.net) (Client exited)
[02:58:54] <dbaupp> Jeaye: (also, .unwrap() extracts the value as a move, rather than a copy (which .get does), just btw.)
[02:59:13] <Jeaye> dbaupp: Aye. Also, RUST_LOG=::rt::backtrace didn't seem to do anything.
[02:59:24] <dbaupp> Jeaye: what platform?
[02:59:31] <Jeaye> OS X
[03:01:08] <strcat> probably only works on linux
[03:01:54] <Jeaye> I'll just run it on my Linux box then!
[03:02:04] <Jeaye> heh
[03:04:17] <jmgrosen> using RWARCs seems to segfault for me :/
[03:04:50] *** Quits: indirect (indirect_m@moz-22FDA25B.hsd1.ca.comcast.net) (Ping timeout)
[03:05:43] <jmgrosen> any way to debug a segfault like that?
[03:06:45] <strcat> valgrind/helgrind
[03:06:58] <jmgrosen> alright
[03:09:23] *** Quits: tedh (tedh@moz-38ABF348.central.biz.rr.com) (Ping timeout)
[03:09:23] *** Joins: ssbr (ssbr@moz-141F89C6.block0.gvtc.com)
[03:10:37] *** Quits: alex_abreu (alex@moz-7421D6C9.mc.videotron.ca) (Ping timeout)
[03:12:19] *** Joins: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[03:14:30] <jmgrosen> is this a proper way to write to a RWARC? "do aspect_arc.write |_| { (width as f32) / (height as f32) };"
[03:14:40] *** Joins: Ralith (ralith@moz-50F3C77.vc.shawcable.net)
[03:18:23] *** Quits: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Ping timeout)
[03:20:24] <Eridius> is bors ok? Tests for my size_hint commit failed with what looks like a buildbot error, not a test failure
[03:20:28] <Eridius> http://buildbot.rust-lang.org/builders/auto-linux-64-opt-vg/builds/289/steps/test/logs/stdio
[03:20:30] <Eridius> command timed out: 3600 seconds without output, attempting to kill
[03:21:07] <engla> bors is not ok
[03:21:42] *** Quits: ssbr (ssbr@moz-141F89C6.block0.gvtc.com) (Quit: Application borked.)
[03:22:02] <jmgrosen> anyone have any experience with RWARCs?
[03:22:31] <bblum> i have a bunch of experience with them
[03:22:37] <bblum> what would you like to do
[03:23:11] <jmgrosen> well, first of all, does this look correct? do aspect_arc.write |_| { (width as f32) / (height as f32) };
[03:23:25] *** Quits: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[03:25:46] <bblum> jmgrosen: that's not going to store the result of the division in the arc
[03:26:01] <bblum> the return value of the closure is propagated as the return value of the write call
[03:26:11] <jmgrosen> bblum: oh, then how do i store something?
[03:26:19] <bblum> look at the argument to the closure
[03:26:40] <jmgrosen> oh, so i just write to that?
[03:26:43] <bblum> yeah
[03:26:48] <jmgrosen> ok
[03:27:28] *** Joins: jyyou (jyyou@moz-F09996FC.hinet-ip.hinet.net)
[03:28:36] <bblum> otherwise looks good
[03:29:49] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[03:29:56] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[03:31:32] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Connection reset by peer)
[03:32:08] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[03:32:08] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/0qKtdw
[03:32:08] <ghrust> 13rust/06auto 148552a74 15Alex Crichton: Bring compiletest/rustpkg/driver up to date on std vs core
[03:32:08] <ghrust> 13rust/06auto 140c84b4d 15bors: auto merge of #7520 : alexcrichton/rust/update-compiletest, r=pcwalton...
[03:32:09] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[03:34:48] *** Quits: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net) (Ping timeout)
[03:35:21] <mark_edward> strcat: should smallintset have a rev iterator? and it shouldnt have mut iterators now?
[03:35:32] <mark_edward> *right?
[03:35:37] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[03:35:57] <strcat> mark_edward: it should have a mutable value iterator
[03:36:00] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[03:36:02] <strcat> like hashmap already does
[03:36:07] *** Quits: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net) (Quit: Jesse)
[03:36:07] <strcat> and reverse iterators because it's ordered
[03:36:25] <jmgrosen> bblum: that still didn't work :(
[03:36:41] <jmgrosen> bblum: the first time, it made my whole OS crash (my dad says "that crappy OS X!")
[03:36:55] <jmgrosen> bblum: and the second time (and on), it segfaults :(
[03:36:57] <mark_edward> strcat: hashmapset only has a single forward non-mutable iterator
[03:37:08] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[03:39:20] <strcat> mark_edward: it has a mutable value iterator
[03:39:24] <strcat> hashmap is unordered
[03:39:29] <strcat> so it doesn't have reverse iterators
[03:39:40] <strcat> it doesn't have a mutable iterator because you can't be allowed to mutate the keys
[03:40:26] <mark_edward> strcat: i'm looking agt the source and hashmapset doesn't have a mutable iterator
[03:40:44] *** Joins: heftig_ (heftig@moz-D52CF73C.dip0.t-ipconnect.de)
[03:41:06] <strcat>     pub fn mut_iter<'a>(&'a mut self) -> HashMapMutIterator<'a, K, V> {
[03:41:18] <strcat> mark_edward: sets don't
[03:41:20] <mark_edward> i'm talkibg about hashmap*set*
[03:41:22] <strcat> because sets only have keys
[03:41:32] <strcat> and you can't be allowed to mutate the keys
[03:41:33] <mark_edward> ok, that's what i was getting at
[03:41:36] *** Quits: heftig (heftig@moz-FA34310B.dip0.t-ipconnect.de) (Ping timeout)
[03:41:51] <strcat> oh I didn't realize you were talking about sets, sorry
[03:42:22] <mark_edward> np. i was just wondering what iterators smallintmapset needed. so immutable forward and immutable reverse
[03:42:53] <strcat> yeah
[03:43:02] *** Quits: taylanub (taylanub@moz-4942D212.dip0.t-ipconnect.de) (Ping timeout)
[03:45:45] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[03:46:12] <paupau> cloning rust
[03:46:25] <paupau> I assume "submodule update" is pulling in LLVM and stuff?
[03:46:57] <strcat> paupau: yes
[03:47:15] <aatch> Ok, @Ty gone from libsyntax
[03:47:24] <aatch> now to fix it in the compiler
[03:50:15] *** Quits: vk (vk@moz-389FEE13.hsd1.ca.comcast.net) (Quit: vk)
[03:50:58] *** Joins: vk (vk@moz-389FEE13.hsd1.ca.comcast.net)
[03:54:07] <enix> hi strcat: I'm continueing to work on my AES implementation; but, based on your feedback i've changed how i'm attacking the problem
[03:54:36] <enix> my original plan was to come up with a functional, somewhat fast software version and leave issues like side channel attacks for a later date
[03:54:59] <enix> now, i've changed direct and am focusing on an implementatio that prevents timing attacks
[03:55:32] <dbaupp> aatch: \o/
[03:55:45] <enix> specicially, i'm planning on implementing 3 versions -  a software one thats resistant to timing attacks; a faster software one thats not resistent to such attacks, and an AES-NI version that should be fast and resistent to such attacks, but only works on newer x86
[03:55:58] <strcat> enix: that sounds good
[03:55:58] *** Quits: mye (mye@moz-B464BB1C.dip0.t-ipconnect.de) (Ping timeout)
[03:56:00] <bblum> jmgrosen: can you paste your code
[03:56:05] <aatch> dbaupp, yeah, I had to add in a few copies, but most of them were in the pipes compiler, which is barely used
[03:56:08] <bblum> it, uh, should not crash your  whole os
[03:56:15] <bblum> but let me see the segfault, for sure
[03:56:23] <dbaupp> aatch: that code is so strange
[03:56:26] <strcat> enix: you could probably make both use AES-NI when available
[03:56:28] <enix> i'm working on creating a mechanism to pick an implementation at runtime; default to the slow software version unless AES-NI is available; make the fast software one optional and clear that it has issues
[03:56:42] <aatch> dbaupp, yeah, I'm never sure what to make of it.
[03:56:45] *** Joins: mye (mye@moz-DCE005F1.dip0.t-ipconnect.de)
[03:57:05] <aatch> it also does weird things like build a source string then parse that string...
[03:58:14] <enix> yeah, i'll default to AES-NI whenever possible
[03:58:43] <enix> i'll leave hardware implementations for ARM and other architectures for a later date
[03:58:59] <enix> just trying to doublecheck that this sounds like a reasonable path
[03:59:14] *** heftig_ is now known as heftig
[03:59:26] *** Quits: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca) (Quit: Leaving)
[03:59:39] *** Quits: Sorella (queen@78575561.924F2739.95C8B7C6.IP) (Quit: (quit))
[03:59:40] <aatch> enix, well you should just be able to use #[cfg(target_arch = "x86")] (and another for x86_64) to split it off 
[03:59:56] <strcat> aatch: AES-NI is only on really recent cpus
[04:00:03] <aatch> strcat, oh, dammit
[04:00:03] <engla> from sandy bridge
[04:00:22] <enix> i also have to detect if its available; i've implemented a cpuid function to do that
[04:00:48] <enix> is there someone in the standard libraries where a x86 function like cpuid would make sense?
[04:01:25] <dbaupp> enix: fwiw, I'd find a cpuid library function useful
[04:03:32] <enix> i'll include it in the eventual pull request, i'm just not sure where to put it
[04:03:46] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[04:03:59] <aatch> enix, either sys or os.
[04:04:43] <aatch> I kinda want to overhaul a lot of that stuff anyway, so it can always be moved.
[04:04:55] <enix> ok, cool
[04:04:57] <enix> thanks
[04:06:02] <aatch> enix, yeah, first step is improving target support. Eventually I want to be able to allow people to do conditional compilation based on target features
[04:08:25] <paupau> no way to rename a use declaration's imported name huh
[04:08:34] <aatch> paupau, there is
[04:08:41] <aatch> use ident = path;
[04:08:42] <enix> we'd still need the ability to dynamically select at runtime, though, right? since like a debian package probably won't just target sandybridge and later
[04:08:48] <paupau> aatch: sweet thanks!
[04:09:09] <aatch> enix, oh yeah. I wasn't saying that you'd necessarily use it.
[04:09:16] <aatch> for this specific case
[04:09:29] <enix> ah, ok, cool
[04:09:34] <aatch> but it's a theoretical use case at any rate
[04:11:27] <aatch> paupau, the standard library actually uses it in some places.
[04:14:10] <enix> if I want a function to only be compiled if the target isn't x86 or x86_64, do i use: #[cfg(not(target_arch = "x86"), not(target_arch = "x86_64"))]
[04:14:22] <aatch> enix, yep
[04:14:27] <enix> cool
[04:21:27] <enix> if I do something like: match val { SomeVal(x) => ... do something ... }. is "x" an alias for the original object, or does it do a copy?
[04:21:57] <aatch> enix, it does a move, unless it's implicitly copyable
[04:22:42] <aatch> if you want a  reference, you have to use `ref`
[04:22:48] <aatch> so SomeVal(ref x)
[04:23:06] <enix> if I do "ref x" is there some way to make x mutable as well?
[04:23:15] <enix> outside of using some unsafe code?
[04:23:24] <aatch> enix, `mut ref x`
[04:23:29] <aatch> Or maybe `ref mut x`
[04:23:36] <aatch> but yes
[04:24:09] <enix> ah, ok, i had tried one variation on that and it didn't compile
[04:24:13] <enix> but, i tried the other and it did
[04:24:16] *** Quits: sankha93 (Instantbir@86B78288.EA57944B.8B6C1D65.IP) (Quit: Instantbird 1.4 -- http://www.instantbird.com)
[04:24:20] <enix> thanks for the help
[04:24:49] *** Quits: aatch (aatch@moz-2BB0AC01.cable.telstraclear.net) (Client exited)
[04:26:44] *** Joins: aatch (aatch@moz-2BB0AC01.cable.telstraclear.net)
[04:30:11] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[04:33:04] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.1)
[04:33:41] *** Quits: roo (jesse.rudo@moz-B7585E4C.dynamic.ip.windstream.net) (Ping timeout)
[04:34:54] <jmgrosen> bblum: https://gist.github.com/jmgrosen/070f600e9b4f1bc03cb3 please turn your eyes away from the spaghetti :P the relevant stuff is in Camera::new and Camera.resize
[04:35:10] <Eridius> rusti: for 4u16.iter_bytes(true) |x| { println(fmt!("%?", x)) }
[04:35:14] -rusti- &[4, 0]
[04:35:14] -rusti- ()
[04:35:28] <Eridius> oh it takes a buffer
[04:35:48] <Eridius> rusti: for 4u16.iter_bytes(false) |x| { println(fmt!("%?", x)) }
[04:35:49] -rusti- &[0, 4]
[04:35:49] -rusti- ()
[04:39:35] <Eridius> rusti: for [4u16, ..2].iter_bytes(false) |x| { println(fmt!("%?", x)) }
[04:39:36] -rusti- &[0, 4]
[04:39:37] -rusti- &[0, 4]
[04:39:37] -rusti- ()
[04:42:17] <Jeaye> `use foo = super;` is not legal?
[04:42:49] <Jeaye> But `use foo = super::bar;` would be?
[04:49:02] *** Joins: graydon (graydon@moz-9918B407.vc.shawcable.net)
[04:49:02] *** ChanServ sets mode: +qo graydon graydon
[04:49:08] <graydon> hrm
[04:49:17] <graydon> rusti tests are causing a lot of stuff to bounce
[04:49:27] <graydon> stuff that's otherwise good
[04:49:33] <graydon> I think rusti doesn't work yet
[04:50:51] <aatch> woo, finally!
[04:51:40] <aatch> Finally got my @Ty changes to compile
[04:55:04] *** Joins: sankha93 (Instantbir@9276287F.8CAC2DA9.D2D1FAF0.IP)
[04:55:06] <Eridius> rusti: for [1u16, 2u16].iter_bytes(false) |x| { println(fmt!("%?", x)) }
[04:55:07] -rusti- &[0, 1]
[04:55:07] -rusti- &[0, 2]
[04:55:07] -rusti- ()
[04:55:12] <Eridius> rusti: for [1u16, 2u16].iter_bytes(true) |x| { println(fmt!("%?", x)) }
[04:55:13] -rusti- &[1, 0]
[04:55:13] -rusti- &[2, 0]
[04:55:13] -rusti- ()
[05:00:52] *** Joins: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[05:01:45] *** Quits: pcwalton (pcwalton@moz-481A040C.hsd1.ca.comcast.net) (Quit: pcwalton)
[05:03:04] *** Joins: jpf (jan@moz-A8C26A15.org)
[05:05:44] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[05:06:00] *** Joins: glinscott (garylinsco@789A6618.53EB7C1.FFFE3AA.IP)
[05:06:45] *** Quits: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Ping timeout)
[05:06:47] <acrichto1> graydon: I think that the llvm jit got a lot better in 3.3, so it's probably worth ignoring all the tests until the llvm upgrades can get pushed through
[05:07:01] <mark_edward> made my first pull request! hope i did it right...
[05:07:44] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[05:08:05] <graydon> acrichto1: what's blocking those, do you know?
[05:12:08] *** Joins: hjr3 (hradtke@moz-842BF853.hsd1.ca.comcast.net)
[05:13:47] <acrichto1> graydon: something is corrupting the stack
[05:14:29] <acrichto1> graydon: that's about as far as I've gotten :(, first it was windows during object emission, and then once I removed a lot of fast_ffi calls (not understand their true purpose), it changed enough code to make linux segfault instead
[05:15:39] <graydon> bleh
[05:15:44] <dbaupp> mark_edward: looks good! although you could squash the commits to make the history cleaner :)
[05:16:29] <dbaupp> mark_edward: `git rebase -i master` and then `git push -f origin name-of-branch` :)
[05:16:43] <mark_edward> dbaupp: how could I do that?
[05:16:46] <mark_edward> oh ok thanks!
[05:17:13] *** Joins: tedh (tedh@moz-38ABF348.central.biz.rr.com)
[05:17:35] <dbaupp> mark_edward: (also, it doesn't merge cleanly, so you'll also need to rebase on top of the latest master.)
[05:17:36] *** Quits: paupau (textual@moz-B04700CD.hsd1.ca.comcast.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[05:17:44] <mark_edward> ok thanks
[05:18:00] *** Quits: hjr3 (hradtke@moz-842BF853.hsd1.ca.comcast.net) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[05:22:43] <mark_edward> dbaupp: how about now?
[05:23:22] <dbaupp> mark_edward: much cleaner!  ... but still doesn't merge into master properly
[05:23:35] *** Joins: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net)
[05:24:04] <mark_edward> dbaupp: how come? i did git rebase -i master like you said
[05:24:25] <dbaupp> mark_edward: oh, you local master branch is probably behind upstream/master
[05:24:46] <dbaupp> mark_edward: `git fetch upstream` `git rebase upstream/master` :)
[05:25:08] <mark_edward> ok
[05:25:41] <aatch> dbaupp, you can also do `git pull --rebase upstream master`
[05:28:25] <mark_edward> how do i know if it merges cleanly
[05:29:15] <aatch> mark_edward, it says on the PR
[05:31:00] <mark_edward> i don't see anything about how it merges here: https://github.com/mozilla/rust/pull/7614
[05:31:54] <jmgrosen> bblum: https://gist.github.com/jmgrosen/070f600e9b4f1bc03cb3 please turn your eyes away from the spaghetti  the relevant stuff is in Camera::new and Camera.resize
[05:32:05] <aatch> mark_edward, maybe only people with commit access see it
[05:32:12] <aatch> mark_edward, at any rate, it merges fine now.
[05:32:32] *** Quits: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net) (Ping timeout)
[05:32:37] <mark_edward> cool! how long will it take until the PR is merged?
[05:32:58] <aatch> mark_edward, at the current rate?
[05:33:01] <aatch> a few days
[05:33:44] <mark_edward> i await it eagerly. will i have to make any changes, like rebasing, if a lot of changes happen between now and then?
[05:34:22] <aatch> mark_edward, if they conflict, yes
[05:34:33] <aatch> However, it is unlikely that yours will
[05:34:50] <aatch> mark_edward, since it is entirely additions in a single file
[05:35:22] <mark_edward> ah i see. how can check if these conflicts come up?
[05:35:23] <aatch> me on the other hand... my current change touches most of libsyntax and librustc
[05:36:44] *** Joins: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net)
[05:37:12] <dbaupp> aatch: does that rebase the current branch on upstream/master? neat.
[05:37:29] <aatch> dbaupp, yep, it also will only give one conflict
[05:38:23] <aatch> dbaupp, you can thank strcat for that gem
[05:40:42] <dbaupp> mark_edward: by rebasing on top of master just before submitting a pr :)
[05:40:49] <jmgrosen> how can i convert a &[T, ..length] to just a &[T]?
[05:40:53] <dbaupp> (and/or asking someone on here.)
[05:41:22] <aatch> jmgrosen, it'll coerce
[05:41:26] <dbaupp> jmgrosen: [T, .. length] should automatically coerce to &[T] if you use it in a function that needs one
[05:41:40] <jmgrosen> error: mismatched types: expected `&[f32]` but found `&[f32, .. 16]` (expected vector but found &-ptr)
[05:41:44] <dbaupp> jmgrosen: so function(*foo) or just foo.method()
[05:41:48] *** Quits: KindOne (KindOne@7D0DB6F0.E114B4AE.EC6A1518.IP) (Ping timeout)
[05:42:25] <jmgrosen> aatch, dbaupp, what's up with that error? :(
[05:43:12] <aatch> jmgrosen, hmm, maybe it doesn't.
[05:44:25] <engla> did you pass it as *foo
[05:45:24] <aatch> Hmm, I might leave my syntaxing alone for the moment.
[05:45:36] *** Joins: KindOne (KindOne@moz-A3E70241.dynamic.ip.windstream.net)
[05:46:00] *** Joins: mib_mgy96r (Mibbit@moz-7A6F602F.nycm.ny.dynamic.megapath.net)
[05:46:14] *** Quits: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net) (Quit: tikue)
[05:46:15] *** Quits: santiago (santiago@320E3E2A.D15AA1B4.A535BD55.IP) (Connection reset by peer)
[05:46:15] <mib_mgy96r> apparently "copy" is in the works to be removed from rust...?
[05:46:32] <jmgrosen> engla: ah, that fixed itâ€¦ hmâ€¦ if it's already an &-ptr, why do you need to dereference it?
[05:46:58] <aatch> jmgrosen, because what you have is a pointer to a [T,..n], what you want is a slice
[05:47:05] <aatch> &[] != &T
[05:47:14] *** Joins: Archer (Archer@moz-DA478E33.bb.online.no)
[05:47:26] <aatch> jmgrosen, it's an unfortunate consequence of the current type system.
[05:47:43] <jmgrosen> aatch: hmmâ€¦ confusing :'(
[05:47:59] <dbaupp> jmgrosen: yeah, [T, .. n] coerces to &[T], but &([T, .. n]) doesn't, because it's not a vector.
[05:48:18] <aatch> that traits, vectors and strings with the sigil are a type in-and-of themselves.
[05:49:25] <aatch> There is a proposal for unsized types, but it causes some issues regarding the fact that the simple implementation would require putting Sized bounds on pretty much everything
[05:49:58] <aatch> so the common case would become very unweildly.
[05:51:21] *** Joins: santiago (santiago@320E3E2A.D15AA1B4.A535BD55.IP)
[05:51:21] <mib_mgy96r> if copy's going to leave the language (presumably to be replaced purely by clone) when's that projected to happen?
[05:51:58] <aatch> mib_mgy96r, no idea, it's not even set in stone that it /will/ be removed
[05:51:59] <cmr> mib_mgy96r: any day now
[05:52:07] <cmr> pcwalton is almost done
[05:52:11] <aatch> cmr, really?
[05:52:14] <cmr> dbaupp: pong
[05:52:18] <cmr> aatch: yup!
[05:52:20] <aatch> cmr, oh, since you'
[05:52:26] <mib_mgy96r> ahaha cmr ok thanks
[05:52:36] <mib_mgy96r> I saw the email from pcwalton, but just thought I'd check
[05:52:46] <aatch> re here, I'm about to open a PR that I'd be interested in seeing the benchmarks for.
[05:52:51] <darkf> how do I destructure this Some? doesn't want to move it for some reason http://paste.pm/860.txt
[05:52:54] <cmr> aatch: sure
[05:52:57] <mib_mgy96r> they [will] have the same functionality?
[05:53:20] <cmr> mib_mgy96r: Clone is replacing it
[05:53:35] <mib_mgy96r> ok, nothing tricky then
[05:53:36] * darkf is probably misusing ~ pointers again
[05:53:41] <engla> darkf: you can't move it because you only have &self
[05:54:08] <engla> darkf: but you can clone it
[05:54:25] <darkf> ah so I have to copy self.name?
[05:54:32] <engla> Some(ref s) => s.clone()
[05:54:47] <darkf> huh, nifty
[05:55:09] *** Joins: BitPuffin (quassel@moz-B986D630.cust.tele2.se)
[05:55:09] <engla> it's an owned string so if you'd return it you couldn't hold onto it yourself
[05:55:13] <cmr> darkf: or!
[05:55:20] <cmr> wait nevermind
[05:55:23] <cmr> you're implementing ToStr
[05:55:38] <engla> the ToStr trait forces you to allocate
[05:56:02] <cmr> I was going to say you could have fn to_str<'a>(&'a self) -> &'a self { ... { Some(ref s) => s, ... } }
[05:56:04] <cmr> but yeah
[05:56:12] <darkf> man
[05:56:28] <darkf> what is the &' sigil for anyway?
[05:57:02] <cmr> explicit lifetime
[05:57:07] <cmr> http://static.rust-lang.org/doc/tutorial-borrowed-ptr.html#named-lifetimes
[05:57:41] <darkf> awesome
[05:57:45] <cmr> It means it takes a pointer to self with lifetime a, and returns a pointer with the same lifetime
[05:57:53] <cmr> also that return type should be -> &'a str
[05:57:59] <engla>   f<'a>(&'a self) -> &'a str    is easy to read.. the return value has the same lifetime as the self value
[05:58:13] *** Joins: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net)
[05:58:30] *** Quits: BitPuffin (quassel@moz-B986D630.cust.tele2.se) (Ping timeout)
[05:59:32] <bblum> jmgrosen: do you think you can make a more minimal program that also segfaults?
[05:59:43] <aatch> cmr, https://github.com/mozilla/rust/pull/7615
[05:59:43] <jmgrosen> bblum: i'll try
[05:59:52] <cmr> aatch: wow you got @Ty!
[05:59:57] <cmr> that's dedication
[06:00:01] <aatch> cmr, yep, wasn't easy
[06:00:08] <aatch> which is why I'm stopping for the moment
[06:01:03] <aatch> hopefully it passes the tests (I'm running them now)
[06:01:22] <bblum> also which function call makes it crash
[06:01:41] <bblum> oh just new and resize
[06:01:44] *** Quits: queos (Mibbit@moz-1ADE39B3.hsd1.ca.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[06:03:02] <bblum> jmgrosen: it looks to me like aspect_arc is somehow getting copied in the size_callback
[06:03:29] <jmgrosen> bblum: how should i do it instead, then?
[06:03:29] <bblum> while of course should be illegal, since it's already been moved into camera
[06:03:43] <bblum> well, can you tell me about set_size_callback?
[06:04:06] <bblum> arc handles should be noncopyable, so i think we're looking at a rust bug
[06:04:07] *** Quits: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk) (Connection reset by peer)
[06:04:34] <aatch> bblum, is it being pattern-matched in let?
[06:04:46] <aatch> because that allows copies for non-copyables
[06:04:50] <bblum> aatch: that was my initial guess
[06:05:01] <bblum> but it seems it is being put in a struct, and later captured
[06:05:12] <jmgrosen> bblum: https://github.com/bjz/glfw-rs/blob/master/src/glfw.rs#L662
[06:05:22] *** Joins: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk)
[06:06:20] *** Joins: igl (igl@moz-83576651.adsl.alicedsl.de)
[06:06:20] *** Quits: santiago (santiago@320E3E2A.D15AA1B4.A535BD55.IP) (Connection reset by peer)
[06:06:39] *** Quits: igl1 (igl@moz-43716F86.adsl.alicedsl.de) (Ping timeout)
[06:06:43] *** Joins: santiago (santiago@320E3E2A.D15AA1B4.A535BD55.IP)
[06:06:43] <dbaupp> cmr: http://hnn.mrsd.org/~cmr/history.txt the last one (well, two), the directory doesn't exist
[06:06:57] <bblum> jmgrosen: try changing line 43, "aspect: aspect_arc," to "aspect: aspect_arc.clone(),"
[06:07:27] <cmr> dbaupp: grr, thought I removed them from history
[06:07:37] <cmr> fixed
[06:08:19] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Connection reset by peer)
[06:08:36] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[06:09:10] <jmgrosen> bblum: it segfaults, but somewhere elseâ€¦ before Camera::new is even called
[06:10:07] <bblum> before camera new is even called?? o_O
[06:10:08] *** Quits: vk (vk@moz-389FEE13.hsd1.ca.comcast.net) (Quit: vk)
[06:10:18] <bblum> well, i have a minimized test case, i think
[06:12:11] <cmr> aatch: I'm running it on the same machine that does the rest of the benchmarks as its results seem to be a lot more consistent than on my desktop
[06:12:17] <cmr> but, it's slow
[06:12:37] <jmgrosen> bblum: it seems to segfault in the calling of glfw::spawn -- Â¯\_(ãƒ„)_/Â¯
[06:12:47] <aatch> cmr, really? ugh
[06:13:15] <jmgrosen> bblum: glfw::spawn is in my main rs file, though
[06:13:18] <cmr> fine, I'll run it on my desktop too :p
[06:13:24] <jmgrosen> (well, where i call it)
[06:13:31] <aatch> cmr, oh, wait, the benchmark itself is slow?
[06:13:39] <cmr> aatch: yes
[06:13:39] <aatch> I thought you meant the changes
[06:13:42] <cmr> no
[06:13:44] <cmr> heh
[06:13:47] <aatch> I'm not bothered about that
[06:13:51] <cmr> ok
[06:14:09] <bblum> this bug is shocking, honestly
[06:14:15] <bblum> that we haven't noticed it by now
[06:14:34] <aatch> bblum, because Rust's parallel appeal is a damn lie?
[06:14:52] <bblum> huh?
[06:15:00] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Ping timeout)
[06:15:14] <aatch> Well isn't the bug in RWARC?
[06:15:21] <aatch> or am I misinterpreting?
[06:15:32] <bblum> bug not in rwarc
[06:15:35] <bblum> not at all
[06:15:52] <jmgrosen> ooh, i feel special :P
[06:15:53] <aatch> bblum, ok, I'll shut up now then
[06:16:13] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[06:16:33] <jmgrosen> bblum: what's your small test case? i'm curious
[06:16:36] <bblum> https://github.com/mozilla/rust/issues/7619
[06:17:23] <jmgrosen> woah
[06:17:27] <jmgrosen> o_O
[06:17:36] <bblum> woah is right.
[06:19:02] *** Quits: mib_mgy96r (Mibbit@moz-7A6F602F.nycm.ny.dynamic.megapath.net) (Quit: http://www.mibbit.com ajax IRC Client)
[06:19:35] <aatch> Hah, looks like the liveness checker has some flow-sensitivity issues.
[06:19:37] *** Quits: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net) (Quit: tikue)
[06:19:41] <cmr> Why don't we have an A-soundness or an A-coherency
[06:19:48] <bblum> we used to have I-linearity
[06:19:53] <bblum> it was for precisely this kind of bug
[06:19:57] <bblum> i don't know who removed it
[06:20:28] *** Quits: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Ping timeout)
[06:20:31] <aatch> bblum, graydon?
[06:20:50] <graydon> not me!
[06:21:10] <cmr> whoa TJ Holowaychuk commented on one of the PRs
[06:21:15] <bblum> check out that bug graydon 
[06:21:16] <cmr> Is he a rust contributor?
[06:21:31] <aatch> cmr, who?
[06:21:39] <engla> bblum: I gave this testcase to you already
[06:21:41] <graydon> does it crash, or make a copy?
[06:21:52] <bblum> it crashes
[06:21:56] <graydon> presumably crash
[06:21:56] <graydon> yeah
[06:21:57] <bblum> engla: you did?
[06:22:01] <cmr> aatch: one of the nodejs people, visionmedia on github
[06:22:02] <graydon> well, that there is a bug, yup
[06:22:11] <aatch> cmr, ahh
[06:22:22] <engla> bblum: it's very similar. about two heap closures both capturing the same value by move
[06:22:30] <engla> and crash
[06:22:46] <bblum> i see, did you already file it?
[06:22:47] <aatch> cmr, probably interested because of libuv
[06:23:11] <engla> I'm not sure if I filed an issue but I definitely gave you the testcase
[06:23:32] <bblum> ah, well, sorry i forgot
[06:24:11] <bblum> and consider the bug filed :P
[06:24:13] <engla> here it is https://github.com/mozilla/rust/issues/7444
[06:24:23] <engla> sorry I don't understand github filters
[06:25:45] <bblum> np
[06:31:26] <aatch> graydon, you may be somewhat interested in https://github.com/mozilla/rust/pull/7615 , since it should help a bit with GC memory pressure
[06:35:11] <aatch> glinscott, nice catch
[06:35:48] <glinscott> aatch: thanks, just working through the profile hotspots :)
[06:39:03] <aatch> glinscott, 0.16s => 0.11s is like a 30% improvement
[06:39:45] <glinscott> yup, it was spending a lot of time checking for whitespace!
[06:40:27] <Eridius> "be" is a keyword? what is it?
[06:41:02] <mark_edward> aatch: how far along do oyu think you are on making the AST completely sendable? just out of curiosity
[06:42:54] *** Joins: mzabaluev (mzabaluev@moz-91FFD755.dhcp.inet.fi)
[06:43:04] <aatch> mark_edward, not very far.
[06:44:10] <mark_edward> cool. maybe when i figure out the compiler better i could contribute something along those lines. im now looking for something else in A-libs to do
[06:44:14] <aatch> for one, to be truly sendable, the interner needs re-factoring so it can be used cross-task
[06:45:34] <aatch> Hell, I wouldn't be against putting it in a static mut.
[06:45:43] <aatch> protecting it with a RWARC
[06:46:01] *** Joins: roo (jesse.rudo@moz-B7585E4C.dynamic.ip.windstream.net)
[06:47:08] <mark_edward> thatg sounds cool
[06:48:14] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[06:49:26] *** Joins: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[06:50:35] <Eridius> can I not say `pub use foo::*; mod foo;` ?
[06:53:46] <aatch> Eridius, you can sometimes.
[06:54:18] <aatch> But glob imports cause weird resolve errors
[06:54:34] <aatch> and glob re-exports make it worse
[06:54:55] <Eridius> aatch: bleh. Too much code to put into one file, so I wanted to break it out into separate modules that were re-exported from a central one
[06:55:25] <engla> will bors get back to order?
[06:55:34] <aatch> engla, what do you mean?
[06:55:35] *** Quits: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Ping timeout)
[06:55:44] <aatch> engla, there's actually nothing wrong with bors atm
[06:55:48] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[06:56:10] <Eridius> aatch: ok trying `pub use foo::foo; mod foo;` also doesn't work
[06:56:16] <Eridius> it can't resolve the import
[06:56:27] <aatch> Eridius, try pub mod foo;
[06:56:34] <engla> aatch: when was the last time it merged something?
[06:56:42] <Eridius> aatch: if it makes a difference, this isn't the root module
[06:56:47] <Eridius> and no, `pub mod foo` doesn't work
[06:57:04] <aatch> Eridius, no idea, re-exports do work sometimes though
[06:57:40] <aatch> engla, a while, but builds keep failing
[06:58:06] <engla> right. that's what I mean with bors not being in order
[06:58:20] <aatch> engla, but bors is just the integration bot
[06:58:26] <Eridius> aatch: hmm, using `pub use myname::foo::{foo, Bar}` almost works, it doesn't complain about foo anymore, but it does complain about Bar
[06:58:36] <engla> what I have seen the failures have been spurious
[06:58:41] <engla> not related to the changes tested
[06:58:44] <engla> that's frustrating
[06:58:45] <aatch> engla, yes, but again, nothing to do with bors
[06:59:05] <Eridius> ok solved Bar too
[06:59:05] <engla> well you probably know what I mean
[06:59:29] <aatch> engla, the builders will get sorted, I think we restarted testing rusti too soon
[06:59:36] *** aatch is now known as aatch|food
[06:59:48] <aatch|food> anyway, going for a bit
[06:59:48] *** Quits: igl (igl@moz-83576651.adsl.alicedsl.de) (Ping timeout)
[07:00:00] *** Joins: igl (igl@moz-EDE5D569.adsl.alicedsl.de)
[07:00:33] <sfackler> rusti: let f: ~[int] = [1i].iter().filter_map(|&i| {Some(i)}).collect(); f
[07:00:33] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/eRcQ
[07:00:47] <sfackler> does anyone know why i'm getting lifetime issues trying to do that?
[07:01:06] <engla> yes. put this thing: [1i]  in a variable
[07:01:51] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Leaving...)
[07:03:30] <sfackler> oh yeah, it's just #3511, thanks
[07:03:33] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[07:04:18] *** Quits: tedh (tedh@moz-38ABF348.central.biz.rr.com) (Client exited)
[07:05:25] <Eridius> if I `use` an enum, do I not pull in the variant names?
[07:05:46] <cmr> Eridius: nope
[07:05:52] <Eridius> blah. this is going to be a long `use` statement
[07:05:56] <cmr> yup :(
[07:07:09] <Eridius> error: illegal lifetime parameter name: `'self`
[07:07:16] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[07:09:56] *** Quits: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net) (Quit: echristo)
[07:10:11] *** Quits: igl (igl@moz-EDE5D569.adsl.alicedsl.de) (Ping timeout)
[07:10:12] *** Joins: igl (igl@moz-4745C1B6.adsl.alicedsl.de)
[07:12:37] <mzabaluev> Is there a non-ugly way to use future_result on TaskBuilder?
[07:13:16] <cmr> aatch|food: http://i.imgur.com/dLO0irf.png :(
[07:13:19] <mzabaluev> The only thing I can come up with is to assign the closure argument to a captured mutable variable. But that has to be initialized first
[07:13:22] <cmr> aatch|food: did you add a copy or few?
[07:13:35] <cmr> wait that's the wrong image
[07:14:02] <cmr> http://i.imgur.com/L1JSXqN.png
[07:14:04] <cmr> there we go
[07:14:37] <cmr> aatch|food: easily attributed to the borrow checker working harder, I think?
[07:18:29] <cmr> graydon: is bors healthy?
[07:18:52] <graydon> I believe so, what makes you think it's not?
[07:18:59] <cmr> lots of red and @bors: retry
[07:19:16] <graydon> the rusti tests are locking up and crashing too much, it seems
[07:19:22] <cmr> silly rusti
[07:19:51] <graydon> look at say:
[07:19:52] <graydon> http://buildbot.rust-lang.org/tgrid?branch=auto&refresh=15&length=20
[07:20:06] <graydon> if you check the reds in the last dozen lines near the bottom, they're almost all rusti failing
[07:20:32] <graydon> acrichto1 suggested turning off the rusti tests until we can get llvm upgraded
[07:21:08] <graydon> I'm ok with that if y'all are. I don't use rusti heavily, I just don't want to see it bitrot again.
[07:21:27] <cmr> I'm fine with that
[07:21:50] <graydon> need to land a change that disables it then
[07:23:29] *** Joins: Voomer__ (Voomer@moz-E97E8EB7.br.br.cox.net)
[07:23:29] *** Quits: Voomer_ (Voomer@moz-E97E8EB7.br.br.cox.net) (Connection reset by peer)
[07:27:08] <dbaupp> glinscott: ping
[07:27:18] <graydon> I have a basic sketch of changes to compiletest to make it run foo.rs and foo.cc through rust and clang respectively, and extract and disassemble the bitcode of the test function in each for comparison
[07:27:50] <graydon> then, I guess, compare their sizes? I haven't added a performance-ratchet to compiletest yet (or to any of the testers)
[07:27:56] <graydon> hm. baby steps.
[07:28:42] *** aatch|food is now known as aatch
[07:28:51] <aatch> ugh, left != right
[07:30:28] <aatch> cmr, what's weird is that's all /after/ LLVM passes
[07:31:22] *** Joins: ssbr (ssbr@moz-141F89C6.block0.gvtc.com)
[07:38:18] <Eridius> rusti: let x = [0, ..2]; let s = x.slice(0, 2); s.len()
[07:38:19] -rusti- 2
[07:38:34] <Eridius> huh, I'm getting "the lifetime cannot outlive the method call", pointing at the slice call
[07:41:52] *** Joins: thpickert (thpickert@moz-99F22CD3.dynamic.dsl.tng.de)
[07:44:24] <aatch> Eridius, a fixed-length vector like that is auto-borrowed, so the slice only lasts for as long as that borrow
[07:44:46] <Eridius> aatch: I was trying to call .slice() because using Some(x) didn't seem to auto-borrow
[07:45:00] <Eridius> rusti: let x = [0, ..2]; let s : &[int] = x; s.len()
[07:45:01] -rusti- 2
[07:45:52] <Eridius> hmm nope, still doesn't work, although the error now points at Some(s) instead of at the call to .slice
[07:46:22] * Eridius is passing this in as the first param to cond.raise_default(), so there might be something going on with that
[07:46:40] <Eridius> ok now what the hell does this mean? https://gist.github.com/kballard/18bd31dcba08e76f2b70
[07:46:46] <Eridius> error: cannot determine a type for this bounded type parameter: unconstrained type
[07:47:36] <mark_edward> assign it to a variable with a type annotation, and use that in the assert_eq!
[07:47:50] *** Joins: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr)
[07:47:51] <mark_edward> type deduction doesn't seem to work right with collect() yet
[07:48:33] <Eridius> `let it = utf16be.encodeChars(a);` alone throw this error
[07:49:13] *** Joins: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com)
[07:49:18] *** Quits: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com) (Quit: doomlord)
[07:50:53] <Eridius> yeah, if I use utf16be.encode(someIter) it also fails
[07:52:09] <thpickert> I forgotâ€¦ Is the compiler source considered good documentation for rust usage?
[07:52:18] <Eridius> hrm, I think the problem might be the trait has a bunch of type parameters, but only half are used for the encode() call, so it bails on the other half
[07:52:21] <Eridius> thpickert: no
[07:52:28] <aatch> thpickert, dear god no
[07:52:30] <cmr> aatch: llvm perf isn't always the same either
[07:52:34] <cmr> thpickert: quite the opposite
[07:52:37] <thpickert> I do remember that the documentation is not good documentation, either. :D
[07:52:46] <cmr> there is no good documentation
[07:53:32] <thpickert> That's tremendously discouraging.
[07:54:12] <aatch> thpickert, however, we strive to be very helpful
[07:54:16] *** Joins: SimonSapin (simon@moz-D0C2F181.zone2.bethere.co.uk)
[07:54:33] <dbaupp> thpickert: the compiler source tells you what not to do
[07:54:36] <thpickert> I appreciate that, for sure.
[07:54:48] <cmr> thpickert: servo is usually decent code
[07:54:57] <thpickert> Cool!
[07:55:01] <thpickert> So what's servo?
[07:55:14] <cmr> Mozilla's research browser engine, written in rust
[07:55:20] <cmr> https://github.com/mozilla/servo/
[07:55:38] <aatch> It's a sibling project to Rust
[07:55:43] <thpickert> Sweet
[07:56:15] <thpickert> Hopefully they use a Counter iterator somewhere.
[07:56:31] <thpickert> I'm already lost trying to instantiate one.
[07:56:39] <aatch> thpickert, heh, probably not
[07:56:59] <cmr> rusti: for Counter::new(5, 3).take(5).advance |x| { print(fmt!("%?", x)) }
[07:56:59] <aatch> One thing with Servo is that it isn't always up-to-date with the latest Rust
[07:57:01] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/SUhH
[07:57:16] <cmr> rusti: for std::iterator::Counter::new(5, 3).take(5).advance |x| { print(fmt!("%?", x)) }
[07:57:17] -rusti- <anon>:7:13: 7:55 error: type `std::iterator::Counter<<VI1>>` does not implement any method in scope named `take`
[07:57:17] -rusti- <anon>:7          for std::iterator::Counter::new(5, 3).take(5).advance |x| { print(fmt!("%?", x)) }
[07:57:17] -rusti-                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[07:57:17] -rusti- error: aborting due to previous error
[07:57:18] -rusti- application terminated with error code 101
[07:57:35] <cmr> rusti: for std::iterator::Counter::new(5, 3).take_(5).advance |x| { print(fmt!("%?", x)) }
[07:57:37] -rusti- 58111417()
[07:57:40] <cmr> heh
[07:57:42] <cmr> rusti: for std::iterator::Counter::new(5, 3).take_(5).advance |x| { print(fmt!("%? ", x)) }
[07:57:44] -rusti- 5 8 11 14 17 ()
[07:58:58] <thpickert> That seems awfully straightforward.
[07:59:06] <cmr> It is pretty straightforward
[07:59:12] <cmr> the docs are really bad, sorry :(
[07:59:22] <thpickert> Yeah, they are.
[07:59:28] <cmr> I'm working on a new rustdoc
[07:59:35] <cmr> fingers crossed!
[07:59:47] <thpickert> I will sing songs upon your name.
[08:00:05] <cmr> graydon: What do you think about the documented unit being the "type", which is a struct/enum plus any impls on it
[08:00:38] <cmr> I'm probably going to end up presenting it like that anyway, but I don't know about the "type" name.
[08:00:39] <graydon> I don't have strong opinions on docs, tbh
[08:00:53] <dbaupp> cmr: have you looked at how haddock handles it? (it's essentially that, type with a list of instances/impls)
[08:01:16] <cmr> dbaupp: I don't know enough haskell to make sense out of what haddock does
[08:01:57] <dbaupp> cmr: http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Tree.html
[08:02:18] <dbaupp> cmr: the "instances" heading below `data Tree a` is the list of impls
[08:02:27] <dbaupp> (of typeclasses/traits)
[08:02:43] <dbaupp> so that approach is very reasonable :)
[08:02:57] <cmr> that's encouraging at least
[08:06:23] *** Quits: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net) (Connection reset by peer)
[08:06:23] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[08:07:53] <Eridius> grr. if a method in my trait doesn't rely on all the type parameters, I get unbounded type errors
[08:08:13] <Eridius> sure, you can't deduce the right parameter, because the parameter isn't used! It should realize that and ignore that parameter
[08:08:24] <cmr> Eridius: help the inferer along with type hints?
[08:08:31] <aatch> Eridius, yep, you can add dummy type params to help
[08:08:35] <Eridius> how?
[08:08:40] <cmr> what are you doing?
[08:08:48] <Eridius> cmr: implementing string encodings
[08:08:53] <dbaupp> Eridius: but the bodies of the methods might change behaviour depending on that type
[08:08:56] <cmr> well I mean code-wise, do you have a gist?
[08:09:02] <dbaupp> (so it can't be ignored.)
[08:09:07] <Eridius> cmr: well it's not small
[08:09:15] <cmr> Eridius: that's fine
[08:09:28] *** Joins: sawrubh (uid6719@moz-5F4AA75A.irccloud.com)
[08:10:18] <Eridius> cmr: https://github.com/kballard/rust/commit/3a386b9e53b6c13225bdea61734704136118d15c
[08:10:42] <Eridius> I had one Encoding trait that had both encode and decode, and I just split it in two because only half the parameters were used for a given method
[08:10:50] <Eridius> but my encodeChars and decodeChars convenience methods are having the same problem
[08:12:29] <Eridius> the T parameter on both has only one possible value it can be
[08:12:32] <graydon> anyone else happen to know how to convince emacs to actually treat lifetime names right? the code in rust-mode.el looks reasonable...
[08:12:34] <Eridius> but I can't tell that to the type system
[08:13:01] <Eridius> graydon: btw if you're interested, https://github.com/kballard/rust/commit/3a386b9e53b6c13225bdea61734704136118d15c is my first pass at string encodings
[08:13:21] <cmr> "encoding/mod.rs:83:20: 83:31 error: type `&[char]` does not implement any method in scope named `iter`
[08:13:31] *** Joins: mnemotic (niko@8FFD1BD2.9D81E74C.53DF0002.IP)
[08:13:44] <Eridius> cmr: well I'm using `rustc std.rs --teset --cfg stage2` right now
[08:13:47] <Eridius> *test
[08:13:56] <Eridius> I'll deal with other stages later
[08:14:08] <cmr> Oh, that's staged?
[08:14:19] <cmr> so it is
[08:14:22] <graydon> that looks pretty rad
[08:14:32] <Eridius> graydon: if only it compiled
[08:14:33] *** Joins: findow (Mibbit@moz-8871012E.range86-135.btcentralplus.com)
[08:14:34] <graydon> you might want to grab the test vectors from the utf16 module we have in there already
[08:15:02] <Eridius> where is that?
[08:15:26] <cmr> extra I think?
[08:15:30] * cmr doesn't remember
[08:15:36] <graydon> str::test::test_utf16
[08:15:52] <Eridius> ah
[08:16:02] <graydon> it's not a lot but it hits surrogate pairs and stuff
[08:16:07] <graydon> (IIRC)
[08:16:16] *** Quits: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk) (Quit: reboot)
[08:16:23] <Eridius> I'll have to remember to try that once I get this compiling
[08:16:36] <graydon> I haven't the faintest memory of where I got them from
[08:17:02] <cmr> Eridius: So the problem, I think, is that it doesn't know which Iterator you want from encodeChars
[08:17:04] <Eridius> I have one surrogate pair test already, using random chars I found in the SMP
[08:17:15] <Eridius> cmr: exactly. there's only one Iterator it can possibly use
[08:17:29] <cmr> Eridius: Which?
[08:17:52] <Eridius> err, the result of src.iter().transform(). It's something like MapIterator<'a, &u8, u8, VecIterator<'self, u8>>
[08:18:13] <graydon> http://www.i18nguy.com/unicode/plane1-utf-16.html probably
[08:18:18] *** Joins: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk)
[08:18:31] <Eridius> ooh Etruscan
[08:18:33] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[08:18:55] <cmr> Eridius: Not quite. the result of .collect has to be a ~[u8], but the iterator returned from encodeChars is correctly unbounded, I think
[08:19:08] <cmr> you'd have to ask nmatsakis or someone who knows all the details of it
[08:19:19] <Eridius> cmr: not sure what .collect has anything to do with it. I can't call .encodeChars(), period
[08:19:45] *** Joins: victorporof (victorporo@74A9C5E8.1745F5FA.9B1E38F4.IP)
[08:20:09] *** Joins: ggherdov_ (uid11402@moz-A42E5B7B.irccloud.com)
[08:21:27] <Eridius> I think I'm just gonna delete encodeChars() for now. Meh.
[08:21:37] <aatch> Ugh, looks like the next thing worth attacking is the diagnostics system.
[08:21:49] <cmr> Eridius: utf16be.encodeChars is unbounded, it could return *any* iterator
[08:22:00] <cmr> any Iterator<u8> that is
[08:22:11] *** Joins: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net)
[08:22:29] *** Joins: jyeo (uid12229@moz-E77DEB21.irccloud.com)
[08:22:59] <aatch> This is not going to be fun...
[08:23:40] <dbaupp> aatch: at least you'll know when you screw up: there'll be no error messages at all.
[08:24:02] *** Quits: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[08:24:10] <aatch> dbaupp, It's fairly obvious that most of this code hasn't been touched in a long time
[08:24:27] <dbaupp> yep
[08:24:48] <dbaupp> but every second file is that way
[08:25:00] <dbaupp> (yay technical debt!)
[08:25:29] <cmr> Eridius: it's not obvious to me what the type hint should be, but it'd be something like utf16be.encodeChars(a).collect::<WhateverIterator, ~[u8]>() I think
[08:25:32] <aatch> Ah, screw it, I'm on a roll with this AST stuff at the moment.
[08:25:57] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[08:26:28] <graydon> aatch: yeah, don't burn yourself out. whatever you got time for is grand.
[08:26:41] <Eridius> cmr: again, the problem occurs without .collect
[08:26:45] <graydon> untangling @-use is extremely frustrating, you're a saint for even trying it
[08:26:54] <cmr> Eridius: I know, but it's the same problem
[08:26:56] <aatch> graydon, yeah, I've tried a few times before
[08:27:10] <cmr> aatch: easy win: ~str instead of @str in FileMap
[08:27:27] <cmr> I have a commit that does it on my syntax_cleanup branch if you want to cherry pick it
[08:27:31] <aatch> graydon, I found the trick is to figure out when you're going down a rabbit hole and fail early
[08:27:34] <cmr> 87b23f6
[08:27:38] <graydon> aatch: yeah
[08:28:00] <cmr> aatch: also a lot of stuff can be #[deriving] in ast.rs, as well as dummy_sp() being a static item
[08:28:03] <Eridius> cmr: typing out the type annotation for .encodeChars would be a mess, and defeats the whole purpose of the convenience method
[08:28:23] <cmr> aatch: e923e30 and 1bfc96d respectively
[08:28:23] <dbaupp> cmr: what's that a "win" at? (I would've thought that there wasn't much gain from ~str -> @str, compared to de-@-ing the actual ast items.)
[08:28:28] <cmr> dbaupp: Less copying
[08:28:40] <dbaupp> cmr: but a @str copy is *really* cheap?
[08:28:44] <cmr> dbaupp: the IO function returns a ~str, it's just calling .to_managed() to stash it into the FileMap
[08:28:56] <dbaupp> cmr: right
[08:29:13] <cmr> dbaupp: I don't know why it's a win, but it's a 33% memory win during codemap creation for libstd
[08:29:43] <dbaupp> cmr: how bigs the codemap?
[08:30:03] <cmr> dbaupp: not small, let me find the issue...
[08:30:14] <cmr> https://github.com/mozilla/rust/issues/2319
[08:30:15] *** Joins: Aetherspawn_BNC (uid6924@moz-31ABA2C0.irccloud.com)
[08:30:35] <cmr> looks like it was more like 1/4 - 1/5 rather than 1/3
[08:30:42] <cmr> oh wait that's librustc
[08:31:03] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[08:32:12] <dbaupp> (I have a feeling that the 20 kb reduction isn't rustc biggest memory problem atm ;P )
[08:33:09] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[08:33:20] <cmr> Eridius: I agree
[08:33:21] *** Quits: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk) (Connection reset by peer)
[08:34:16] <aatch> cmr, 3 commits, 4 conflicts...
[08:34:21] *** Joins: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk)
[08:34:27] <cmr> aatch: whee!
[08:34:52] <aatch> cmr, for the three commits I cherry-picked, 4 files conflicted
[08:34:52] <dbaupp> Eridius: it may be better to have Self be : Iterator<u8>, so it
[08:34:58] *** Joins: jviereck (Adium@moz-61C463B0.pool.mediaways.net)
[08:35:03] <cmr> aatch: might be best to just use the trusty old eyeball patch applier?
[08:35:20] <dbaupp> Eridius: ... 's some_byte_vector.decode(encoding_config) -> some_char_iterator
[08:35:23] <aatch> cmr, nah, they aren't big conflicts
[08:35:35] <dbaupp> Eridius: but that might be equally hard
[08:35:54] <dbaupp> Eridius: well, some_byte_vector.iter().decode(encoding_config)
[08:36:00] <Eridius> hmm
[08:36:07] *** Joins: gazoombo (uid6629@moz-E77DEB21.irccloud.com)
[08:36:08] <aatch> cmr, is spanned supposed to derive IterBytes?
[08:36:11] <dbaupp> that's how Python handles it
[08:36:20] <Eridius> although one problem is I want to work on Iterator<u8> and Iterator<char> so it's actually .iter().transform(|&x| x) which is garbage
[08:36:29] <dbaupp> right
[08:36:37] <dbaupp> hm
[08:36:38] <Eridius> I definitely think we need an .iter_copy() that does that for you
[08:36:46] <dbaupp> *iter_clone() ;P
[08:36:48] <Eridius> heh
[08:36:56] <cmr> aatch: I don't know, but it already does on master
[08:37:16] <aatch> cmr, I figured it was a change that your commit wasn't up-to-date on
[08:37:22] <cmr> ah
[08:37:30] <cmr> whatever's in master is probably right
[08:37:35] <aatch> it's just because it's really close to your change
[08:37:51] <dbaupp> Eridius: hm, thinking about it, I feel like the type system isn't quite up-to-scratch yet.
[08:38:02] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[08:39:19] <Eridius> hrm, is lint telling me that statics should be called FOO, not Foo?
[08:39:45] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[08:39:50] <dbaupp> Eridius: yes
[08:39:56] <Eridius> :/
[08:40:05] <Eridius> screw that, char::ReplacementCharacter is correct!
[08:40:30] <dbaupp> rusti: static a: int = 1; let a = 1;
[08:40:30] -rusti- <anon>:7:32: 7:33 error: only refutable patterns allowed here
[08:40:31] -rusti- <anon>:7          static a: int = 1; let a = 1;
[08:40:31] -rusti-                                          ^
[08:40:31] -rusti- error: aborting due to previous error
[08:40:31] -rusti- application terminated with error code 101
[08:40:38] <dbaupp> Eridius: that's why ^
[08:40:47] <dbaupp> a *really* confusing error message
[08:40:50] <Eridius> wacky
[08:41:10] <dbaupp> #[allow(non_uppercase_statics)] should work
[08:41:24] <Eridius> yeah
[08:43:13] *** Joins: drrb (drrb@1890AB83.D0F4B50F.670D5E6B.IP)
[08:43:17] <aatch> cmr, I'm guessing you never tried building rustc with your changes?
[08:43:20] <Eridius> bah, lint doesn't like utf16/utf16be/utf16le
[08:43:39] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Connection reset by peer)
[08:43:53] <cmr> aatch: the *branch* builds rustc, but my codemap cleanup introduces incorrectness
[08:43:56] <Eridius> ack it doesn't like UTF16_BE either
[08:44:04] <Eridius> sigh. this is crap naming. I can't CameCase this
[08:44:05] <cmr> aatch: so, for those commits, probably not, sorry :(
[08:44:08] <Eridius> Utf16Be? lol
[08:44:09] <aatch> cmr, oh well.
[08:44:23] <Eridius> screw it going back to the old names and just linting it
[08:44:42] <dbaupp> Eridius: it actually just checks that it starts with an uppercase letter, and contains no underscores (except for the beginning or end)
[08:44:51] <dbaupp> Eridius: so Utf8be works
[08:44:58] <aatch> cmr, search-replace to the rescue
[08:44:59] <Eridius> UTF16BE is still an ugly name
[08:45:35] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[08:45:47] <dbaupp> Eridius: right, but it doesn't need to be entirely capitalised
[08:46:45] <dbaupp> Eridius: (fwiw, the convention seems to be acronyms have only the first letter uppercase, e.g. Arc, Rc, Json)
[08:47:05] <Eridius> Utf16 is ugly
[08:47:08] <Eridius> nobody types that
[08:47:14] <Eridius> also I see people say RWARC all the time
[08:47:41] <dbaupp> hm, wait, it seems to be ARC now, yeah
[08:47:54] <dbaupp> gah! why's Rust so inconsistent? :(
[08:47:56] <Eridius> how do I tell the test runner to disable parallelism? I wanna see the colors
[08:48:08] <Eridius> and for some reason it doesn't emit colors when it's running tests in parallel
[08:48:30] <dbaupp> RUST_THREAD=1
[08:48:31] <Eridius> it also didn't give me the actual failure message, just said my test failed
[08:48:36] <aatch> dbaupp, it's an open issue around ARC and bblum is stubborn
[08:48:45] <Eridius> dbaupp: as an env var? didn't do anything
[08:48:49] <cmr> Eridius: gotta scroll up for the actual error message
[08:48:52] <cmr> and it's RUST_THREADS
[08:48:55] <dbaupp> sorry, RUST_THREADS=1
[08:49:05] <dbaupp> aatch: changing it to Arc
[08:49:06] <dbaupp> ?
[08:49:08] <Eridius> ah
[08:49:22] <Eridius> hah, endian issues!
[08:49:33] <bblum> Arc would be fine too
[08:49:59] <dbaupp> Eridius: (you can also filter the tests that are run with TESTNAME=foo (Rust's make files), or ./test-runner foo (a normal binary).)
[08:50:03] <bblum> i just think it's important that the names be short and snappy instead of long-winded and pandering like AtomicReferenceCountedSharedThreadsafeState
[08:50:21] <Eridius> yeah I do test filtering often too
[08:50:30] <bblum> fwiw, i also don't like Rc or Json
[08:50:31] <dbaupp> cool, just checking :)
[08:50:37] *** Quits: jyyou (jyyou@moz-F09996FC.hinet-ip.hinet.net) (Quit: leaving)
[08:51:21] <Eridius> rusti: for 74u16.iter_bytes(false) |b| { println(fmt!("%?", b)) }
[08:51:22] -rusti- &[0, 74]
[08:51:23] -rusti- ()
[08:51:33] *** Joins: jyyou (jyyou@moz-F09996FC.hinet-ip.hinet.net)
[08:52:05] <cmr> rusti: for 74u16.iter_bytes(true) |b| { println(fmt!("%?", b)) }
[08:52:06] -rusti- &[74, 0]
[08:52:06] -rusti- ()
[08:52:17] *** Quits: jyyou (jyyou@moz-F09996FC.hinet-ip.hinet.net) (Quit: leaving)
[08:52:27] <cmr> rusti: for 74u32.iter_bytes(true) |b| { println(fmt!("%?", b)) }
[08:52:28] -rusti- &[74, 0, 0, 0]
[08:52:28] -rusti- ()
[08:53:38] *** Quits: jviereck (Adium@moz-61C463B0.pool.mediaways.net) (Quit: Leaving.)
[08:54:44] *** Joins: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com)
[08:55:49] *** Quits: sankha93 (Instantbir@9276287F.8CAC2DA9.D2D1FAF0.IP) (Ping timeout)
[08:56:03] <cmr> rusti: struct Foo; let x = Foo; x
[08:56:04] -rusti- {}
[08:56:30] * dbaupp loves how the pretty printer handles structs
[08:57:57] *** Joins: jyyou (jyyou@moz-47B052FA.cs.nctu.edu.tw)
[08:59:17] *** Joins: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com)
[08:59:28] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[08:59:51] <cmr> rusti: struct Foo(uint); let x = Foo(12); x
[08:59:53] -rusti- {__field__: 12}
[09:00:53] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[09:01:01] <cmr> it's probably going to byte me in the ass that I'm being sloppy with rustdoc_ng
[09:01:19] <cmr> but if someone takes this prototype code and commits it into the tree I'm going to break their fingers :p
[09:02:57] <Eridius> cripes it's 2am already?
[09:03:08] <Eridius> woo! My tests pass!
[09:03:14] <cmr> Eridius: :shipit:
[09:08:12] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[09:08:13] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[09:08:16] <aatch> heh, realized I missed the easiest ast item to de-@
[09:08:21] <aatch> ast::crate
[09:12:00] <drrb> Hi everyone! I just upgraded to 0.7, and I'm finally compiling: just fixing my tests now. I was using str.to_lower() in 0.6, which I switched to str.to_ascii().to_lower().to_str_ascii() during the upgrade. Unfortunately, some of my strings have non-ascii characters. Is there a replacement for str.to_lower()?
[09:12:30] <cmr> drrb: unfortunately not, we don't have any robust unicode handling yet (that is why it was removed; it was incorrect)
[09:12:40] *** Joins: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net)
[09:13:07] <drrb> Ok, thanks. I'll make do.
[09:13:25] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[09:15:05] <dbaupp> cmr: does your benchmarker happen to be running anything atm? (it'd be neat if it was. ;) )
[09:15:19] * dbaupp has a furious appetite for data
[09:15:21] <cmr> dbaupp: there's nothing to benchmark, bors hasn't passed anything
[09:15:30] <dbaupp> cmr: historical things?
[09:15:34] <cmr> Want me to fix it up and run it on some older commits
[09:15:38] <cmr> yeah
[09:15:40] <cmr> sure, sec
[09:16:02] <dbaupp> (also, seriously? is it the rusti thing graydon sent an email about?)
[09:16:16] <cmr> yeah, it's unfortunate :(
[09:16:33] <cmr> that's two days I've waken up and nothing landed overnight!
[09:16:59] <dbaupp> oh... I love waking up and seeing what new awesomeness is in the tree
[09:17:19] * dbaupp has the advantage of being on the other side of the world
[09:17:24] <aatch> I like my stuff landing _before_ I forget I did it.
[09:17:33] <aatch> dbaupp, it is a nice advantage
[09:17:38] * dbaupp also has the disadvantage of being on the other side of the world
[09:17:55] <aatch> dbaupp, missing emails is one for me
[09:18:09] *** Quits: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr) (Quit: pyrac)
[09:18:19] <dbaupp> aatch: yeah, there's been a few times when I've got a pile of emails from bors on a pr I've forgotten about
[09:18:21] <aatch> since I wake up and suddenly conversation
[09:18:25] <graydon> ok, let's .. just turn off rusti tests :(
[09:19:39] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[09:19:39] <ghrust> 01[13rust01] 15graydon pushed 1 new commit to 06master: 02http://git.io/t-5aXA
[09:19:39] <ghrust> 13rust/06master 14f115944 15Graydon Hoare: Update tests.mk...
[09:19:39] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[09:19:58] <graydon> it's the weekend, bors should be getting stuff done! catching up etc.
[09:20:14] *** Joins: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr)
[09:20:20] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[09:20:20] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 140c84b4d to 14f115944: 02http://git.io/N3iJvQ
[09:20:20] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[09:20:23] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[09:20:23] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/cfbvOg
[09:20:23] <ghrust> 13rust/06auto 148552a74 15Alex Crichton: Bring compiletest/rustpkg/driver up to date on std vs core
[09:20:23] <ghrust> 13rust/06auto 146595c42 15bors: auto merge of #7520 : alexcrichton/rust/update-compiletest, r=pcwalton...
[09:20:23] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[09:20:28] <dbaupp> gogogogo bors
[09:21:44] *** Quits: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr) (Quit: pyrac)
[09:22:04] <cmr> "rt: Release big stacks immediately after use to avoid holding on to them through yields"
[09:22:07] <cmr> I hadn't realized that landed
[09:22:56] <dbaupp> Eridius: just thinking about it (and in light of your email), it might be better to have .clone_each() on Iterators (rather than iter_clone() on vectors), used as `v.iter().clone_each()`
[09:23:02] <cmr> dbaupp: Got a nice stack of 20 PRs to test :)
[09:23:19] <dbaupp> Eridius: since vectors aren't the only thing that returns &T
[09:23:29] <dbaupp> cmr: cool! how far back?
[09:23:38] <aatch> graydon, you mentioned a while back about the way most compilers implement interners
[09:23:39] <cmr> 22408d9 is the oldest
[09:24:02] <aatch> graydon, any references I can look at?
[09:24:13] <dbaupp> cmr: ok
[09:24:26] * dbaupp prepares for an information feast
[09:24:29] <cmr> so, not very :p
[09:24:43] <graydon> aatch: um, no, not tonight. gist is just "mmap files and keep pointers into them, never copy strings"
[09:25:02] <cmr> want me to go for "sparse but wide range" rather than "dense but only the past week or so"?
[09:25:03] <graydon> look for StringRef in clang, for example
[09:25:23] <dbaupp> cmr: yeah, that'd probably be more interesting for now
[09:25:32] <dbaupp> cmr: (how long does each bench take?)
[09:25:53] <cmr> dbaupp: like ~30 minutes iirc
[09:25:59] <dbaupp> oh, not too long
[09:26:13] <dbaupp> so it won't fall behind bors, cool.
[09:26:23] <dbaupp> is it automated yet?
[09:26:44] <aatch> graydon, how do you handle the identity stuff?
[09:26:44] <cmr> nope! :p I keep it next to the irc window so I see when it finishes though
[09:26:56] <cmr> actually, let me fix it so it can be automated
[09:27:30] <graydon> aatch: oh, maybe they keep an interner of those slices..
[09:27:40] <graydon> aatch: sorry, it's too late for me to think straight, gotta head to bed
[09:27:47] <aatch> graydon, that's fine
[09:27:58] <dbaupp> cmr: it'd be really neat if it polled github every so often, and benched the merge(s) (if there is one), or benched some random commit in the past
[09:28:01] <aatch> I'll take a look at Clang
[09:28:32] <cmr> dbaupp: that'd take, like, effort
[09:28:42] <dbaupp> cmr: (presumably some random commit would be better to be next on a list of "interesting commits", or if it just worked it's way backwards ;P )
[09:28:43] * aatch is worryingly familiar with the clang source now
[09:28:57] <dbaupp> cmr: I'd be happy to have a go at implementing it, if you want
[09:29:06] <cmr> dbaupp: sure
[09:29:11] *** Quits: graydon (graydon@moz-9918B407.vc.shawcable.net) (Quit: Leaving.)
[09:29:29] <cmr> dbaupp: basically you just gotta run "benchit.py <commit>" and it does its thing
[09:30:01] <dbaupp> cmr: ok, awesome. dinner time now... it can be tonight's task.
[09:31:10] <cmr> Got a nice stack of 20 commits going back 7 weeks now
[09:32:28] *** Joins: Ms2ger (Ms2ger@moz-E9883900.access.telenet.be)
[09:36:17] <cmr> Eridius: How are you going to handle when there isn't enough u8 to make a char?
[09:38:04] *** Joins: mib_xrijvo (Mibbit@moz-A66A161.static.tpgi.com.au)
[09:40:55] *** Quits: SimonSapin (simon@moz-D0C2F181.zone2.bethere.co.uk) (Ping timeout)
[09:43:08] *** Quits: mib_xrijvo (Mibbit@moz-A66A161.static.tpgi.com.au) (Quit: http://www.mibbit.com ajax IRC Client)
[09:45:24] <aatch> indutny, ping
[09:48:41] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[09:53:50] *** Joins: sebcrozet (Mibbit@moz-3CE49532.lrde.epita.fr)
[09:55:04] *** Joins: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP)
[09:57:28] <sebcrozet> Hi.
[09:57:36] <aatch> sebcrozet, heyo
[09:58:03] <sebcrozet> When trying to compile rust 0.7 on mac os I get 'unrecognized command line option "-Wno-maybe-uninitialized"
[09:58:24] <sebcrozet> Any idea about what causes this?
[09:58:35] <aatch> sebcrozet, you probably need to update your C compiler
[09:58:56] <aatch> since that's a C compiler option
[09:59:11] <sebcrozet> aatch: I use macportâ€™s gcc-mt-4.8
[09:59:30] <sebcrozet> aatch: s/mt/mp
[10:00:14] <sebcrozet> aatch: weirdly I managed to compile the version 0.6 without error.
[10:00:52] <aatch> sebcrozet, I can't really help, I use linux and clang 3.3
[10:01:02] <cmr> sebcrozet: what stage of compilation does it fail in?
[10:01:04] <cmr> llvm?
[10:01:10] <sebcrozet> yep
[10:01:57] <sebcrozet> A fiew seconds after the configure ends.
[10:02:51] <roo> rusti: let i = ~[1,2,3,4].iter(); i.nth(1); i.nth(1)
[10:02:52] -rusti- <anon>:7:36: 7:45 error: failed to find an implementation of trait std::iterator::Iterator<<V8>> for ~std::vec::VecIterator<,int>
[10:02:52] -rusti- <anon>:7          let i = ~[1,2,3,4].iter(); i.nth(1); i.nth(1)
[10:02:52] -rusti-                                              ^~~~~~~~~
[10:02:52] -rusti- application terminated with error code 101
[10:03:04] <roo> blah
[10:03:21] <sebcrozet> cmr: In fact it does not seem to take in account my CC environment variable to find the compiler
[10:03:47] <sebcrozet> cmr: so it might be using an older version
[10:04:34] <cmr> sebcrozet: I'm don't really know how the build system works and fits together, but you should be able to edit config.mk in the build directory and set the path to gcc directly
[10:07:37] <roo> rusti: let i = (~[1,2,3,4]).iter(); i.nth(1); i.nth(1)
[10:07:39] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/RHRB
[10:09:33] *** Quits: taruti (taruti@moz-60D35041.violetti.org) (Quit: leaving)
[10:09:40] <aatch> Ok, wish me luck, I'm going to try to get rid of the '@' on expr
[10:10:19] *** Joins: nano (nano@moz-972880B.superkabel.de)
[10:14:54] <sebcrozet> cmr: Ok, it works.
[10:14:57] <sebcrozet> cmr: thanks.
[10:15:59] *** Quits: sebcrozet (Mibbit@moz-3CE49532.lrde.epita.fr) (Quit: http://www.mibbit.com ajax IRC Client)
[10:16:53] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[10:17:39] <cmr> aatch: you are a saint
[10:18:41] <aatch> cmr, this is already proving to be insane, and I've only just started on the parser
[10:18:45] <indutny> aatch: pong
[10:18:49] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[10:18:56] *** Joins: feduser (feduser@D2ACAA82.1E16A669.799BF54A.IP)
[10:18:58] <aatch> indutny, I was gonna ask about the MemoryMap stuff
[10:19:03] <indutny> ah, well
[10:19:06] <indutny> I was a bit busy
[10:19:07] <aatch> indutny, but decided to do something else instead
[10:19:11] <indutny> haha
[10:19:12] <indutny> ok
[10:19:24] <aatch> indutny, unrelated to your absence
[10:23:44] <aatch> ok, lets see how many type errors I get
[10:23:53] <cmr> one beeeelion
[10:24:07] <cmr> main.rs:57:23: 57:27 error: unused variable: `amap` [-D unused-variable (default)]
[10:24:13] <cmr> I've been waiting a long time to see that error!
[10:24:31] <aatch> cmr, I got 1
[10:24:42] <aatch> "core dumped"
[10:24:46] <cmr> hahahah
[10:25:03] <aatch> bloody infinite-sized structs
[10:26:01] *** Joins: jviereck (Adium@moz-61C463B0.pool.mediaways.net)
[10:27:40] *** Quits: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net) (Quit: Jesse)
[10:29:45] *** Quits: jviereck (Adium@moz-61C463B0.pool.mediaways.net) (Quit: Leaving.)
[10:31:23] *** Quits: busylizzy (lisa@85228838.12D0DC84.211374C4.IP) (Ping timeout)
[10:32:48] <cmr> 0x00007ffff782ea2f in repr..ReprVisitor::_43d76a21af51a93::glue_drop_10235 () from /home/cmr/.local/lib/rustc/x86_64-unknown-linux-gnu/lib/libstd-6c65cf4b443341b1-0.7.so
[10:32:52] <cmr> 0x00007ffff78c3aa7 in repr::__extensions__::meth_22071::visit_ptr_inner::_86a47f25bb1f1538::_07 () from /home/cmr/.local/lib/rustc/x86_64-unknown-linux-gnu/lib/libstd-6c65cf4b443341b1-0.7.so
[10:33:03] *** Joins: busylizzy (lisa@85228838.12D0DC84.211374C4.IP)
[10:33:04] <cmr> Why are there seemingly two different name mangling schemes?
[10:35:04] *** Quits: mnemotic (niko@8FFD1BD2.9D81E74C.53DF0002.IP) (Ping timeout)
[10:39:01] *** Joins: doener (doener@moz-121949B3.unitymediagroup.de)
[10:39:55] <cmr> and we have struct docs \o/ 
[10:41:12] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[10:41:43] <aatch> ok, found one cause of infinite size
[10:41:51] *** Joins: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca)
[10:42:12] <dbaupp> cmr: because consistency if for losers?
[10:42:14] <dbaupp> :P
[10:42:28] <roo> is it normal for llvm & libuv to rebuild after every pull?
[10:42:28] <aatch> dbaupp, then rustc must win at everything
[10:42:34] <aatch> roo, no
[10:42:36] <cmr> roo: not at all
[10:42:42] <roo> must be a mingw thing
[10:42:52] <roo> or i have somehow screwed something up
[10:42:54] <cmr> although recently there have been some llvm updates, so
[10:42:56] <dbaupp> cmr: (do you reckon you could gist me benchit.py, so I don't have to keep pestering you about its behaviour? :) )
[10:43:17] <dbaupp> aatch: of course!
[10:43:29] <cmr> dbaupp: will do it in as soon as it finishes the current benching run (making sure it actually works)
[10:43:37] <cmr> due in... ~4 minutes
[10:43:51] <dbaupp> cmr: ok
[10:44:15] <cmr> dbaupp: https://github.com/cmr/rust-bench/blob/master/benchit.py is the gist of it
[10:44:16] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Connection reset by peer)
[10:44:23] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[10:44:36] *** Quits: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com) (Quit: webber46)
[10:44:38] <dbaupp> cmr: (also "expected int but found ~int in `~4 minutes`", :P )
[10:44:38] <cmr> that's an old version though
[10:44:41] <cmr> so nevermind
[10:45:38] <aatch> ok, so I have "internal compiler error: no type for node 40021: unknown node (id=40021) in fcx 7fc7496a9ce0" number of type errors
[10:45:40] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[10:45:55] <doener> heh
[10:46:08] <aatch> that's all kinds of special right there.
[10:46:33] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Connection reset by peer)
[10:46:33] *** Joins: maxli1 (maxli@B5559308.9C54E60.2FA4EA88.IP)
[10:47:07] <mark_edward> hey, there's an issue open for pointer arithmetic, that i wanna work on. 
[10:47:17] <cmr> mark_edward: what issue?
[10:47:35] <mark_edward> https://github.com/mozilla/rust/issues/2122
[10:47:49] *** Joins: Sindwiller (quassel@moz-743130B2.dynamic.hispeed.ch)
[10:47:56] <mark_edward> do you wanna be able to add pointers together or is this for pointers and say, uints?
[10:48:17] <aatch> mark_edward, it's more for doing ptr + 1
[10:48:44] <aatch> and having it taking the type size into account
[10:48:54] <cmr> I'm not sure this bug is possible to do with the current system
[10:49:05] <mark_edward> ah okay, so it'd be impl<T> Add<int,*T> for *T right?
[10:49:42] <aatch> cmr, I'm pretty sure it's fine
[10:49:48] <aatch> mark_edward, yep
[10:50:06] <cmr> we already have pointer arithmetic though, it just uses bytes rather than the size of the type
[10:50:17] <aatch> cmr, you sure?
[10:50:22] <cmr> aatch: 100%
[10:50:30] <mark_edward> cool
[10:50:47] <aatch> rusti: let a = 0 as *u8; a + 1
[10:50:48] -rusti- <anon>:7:27: 7:32 error: binary operation + cannot be applied to type `*u8`
[10:50:48] -rusti- <anon>:7          let a = 0 as *u8; a + 1
[10:50:48] -rusti-                                     ^~~~~
[10:50:48] -rusti- error: aborting due to previous error
[10:50:48] -rusti- application terminated with error code 101
[10:51:09] <aatch> cmr, you want to revise that percentage?
[10:51:19] <cmr> aatch: it's a... 3-bit float :p
[10:51:44] <cmr> I *swore* that worked
[10:51:57] <aatch> cmr, no, you can just cast to uint
[10:52:01] <aatch> and back
[10:52:18] <cmr> mark_edward: carry on!
[10:52:25] * cmr goes to sit in the shame corner
[10:52:35] <mark_edward> cool!
[10:52:35] <aatch> cmr, trust me, if it worked, strcat would've used it in the vec iterator
[10:52:49] *** maxli1 is now known as maxli
[10:52:58] <mark_edward> so it should not be bytewise, but size of type wise, right?
[10:53:04] <aatch> mark_edward, correct
[10:53:11] <aatch> like C
[10:53:12] <dbaupp> mark_edward: it should be a wrapper for .offset
[10:53:12] <cmr> just like C pointer arith
[10:53:16] <mark_edward> like how you'd go through an array in C (
[10:53:26] <dbaupp> so ptr.offset(1) == ptr + 1
[10:53:31] *** Quits: findow (Mibbit@moz-8871012E.range86-135.btcentralplus.com) (Quit: http://www.mibbit.com ajax IRC Client)
[10:53:34] <mark_edward> cool
[10:53:51] <cmr> dbaupp: https://github.com/cmr/rust-bench/blob/master/benchit.py updated
[10:54:05] <dbaupp> cmr: ok, thanks
[10:54:08] <cmr> the commented out part usually isn't commented out :p
[10:54:27] <dbaupp> cmr: what happens if the build fails, btw?
[10:54:29] <mark_edward> should it only work with ints or uints? maybe just uints and have the Sub trait
[10:54:40] <cmr> dbaupp: it bails out, clean failure
[10:54:52] <dbaupp> cmr: returns non-0 to the shell?
[10:55:15] <cmr> dbaupp: yes
[10:55:22] <aatch> grr, stupid recursive types making it hard to figure out how to properly write the pattern binding.
[10:55:25] <dbaupp> cmr: ok, cool. easy! :)
[10:55:40] <cmr> dbaupp: it does *not* fail cleanly if os.system fails though
[10:55:58] <aatch> sometimes its just `ref a`, sometimes its `~ref a`
[10:56:00] * cmr fixes that
[10:56:47] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[10:57:08] *** Quits: mzabaluev (mzabaluev@moz-91FFD755.dhcp.inet.fi) (Ping timeout)
[10:57:09] <dbaupp> cmr: ok, I'll work under the assumption that a commit built/tested correctly if and only if benchit returns 0
[10:58:29] <aatch> (that said, the fact that I /can/ write `~ref a` is pretty awesome)
[10:59:17] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[10:59:17] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/cfbvOg
[10:59:17] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[10:59:25] <aatch> Yay!
[10:59:30] <aatch> something passed!
[10:59:52] <aatch> rust-buildbot, dance
[10:59:54] <rust-buildbot> <(^.^<)
[10:59:55] <rust-buildbot> <(^.^)>
[10:59:59] <rust-buildbot> (>^.^)>
[10:59:59] <rust-buildbot> (7^.^)7
[10:59:59] <rust-buildbot> (>^.^<)
[11:01:06] *** Joins: robert (robertknig@moz-B6DD6E0B.range86-166.btcentralplus.com)
[11:02:17] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[11:02:17] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/UbdVEw
[11:02:17] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[11:02:20] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[11:02:20] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/4JPwyQ
[11:02:20] <ghrust> 13rust/06auto 14f80d6dc 15Graydon Hoare: rustc: improve -Z trans-stats to report per-fn LLVM instruction counts and translation timing
[11:02:20] <ghrust> 13rust/06auto 1451743fb 15bors: auto merge of #7456 : graydon/rust/better-trans-stats, r=cmr...
[11:02:20] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[11:02:53] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[11:03:46] <mark_edward> that's a cute buildbot
[11:04:07] <aatch> mark_edward, not that rust-buildbot actually does anything anymore.
[11:04:10] <mark_edward> problem though: error: cannot provide an extension implementation for a trait not defined in this crate
[11:04:16] <aatch> rust-buildbot: botsnack
[11:04:26] <mark_edward> when trying to do Add for *T
[11:04:43] <aatch> mark_edward, are you implementing it in std?
[11:04:46] <mark_edward> yes
[11:05:07] <cmr> mark_edward: try implementing it wherever Add is defined (ops.rs I think)
[11:05:29] <aatch> mark_edward, yeah, builtin types are weird
[11:05:30] <mark_edward> isn't that a bad idea? doens't it belong in std::[tr
[11:05:31] *** Joins: SimonSapin (simon@moz-D0C2F181.zone2.bethere.co.uk)
[11:05:36] <mark_edward> *std::ptr
[11:05:55] <cmr> ideally, but if you can't do it, you can't do it
[11:07:27] <cmr> Hrm, think I found a bug
[11:07:45] <cmr> rusti: struct Foo; let x = ~[Foo, Foo, Foo]; println(fmt!("%?", x));
[11:07:52] -rusti- timeout triggered!
[11:08:02] <aatch> cmr hahahaha
[11:08:04] <cmr> but it will pretty-print a single unit struct just fine
[11:08:09] <mark_edward> cmr: true
[11:08:23] <dbaupp> mark_edward: in theory, `impl<T> Add<uint, *T> for *T { fn add(&self, shit: int) -> *T { self.offset(shift as uint) } }` would work
[11:08:27] <dbaupp> err, *shift
[11:08:33] <aatch> cmr, we don't actually /have/ log expressions anymore
[11:08:34] <dbaupp> (well, should owkr)
[11:08:48] <dbaupp> *work
[11:08:50] <mark_edward> dbaupp: yeah, i thiink i was compiling wrong
[11:08:58] <cmr> aatch: eh?
[11:09:00] * dbaupp is godo at tpying
[11:09:02] <mark_edward> it's working now
[11:09:09] <dbaupp> mark_edward: cool
[11:09:33] <dbaupp> (I wonder why .offset takes a uint rather than an int...)
[11:09:39] <aatch> cmr, I think I typed before my brain finished the sentence.
[11:09:40] <mark_edward> so for pointer you just want add and sub right? no need for pointer multplication...
[11:09:47] <cmr> aatch: lol
[11:09:54] <dbaupp> mark_edward: yes
[11:10:00] <mark_edward> dbaupp: me too! should my add trait do that, because i don't see any reason for it
[11:10:06] <aatch> I meant (to everybody), we don't actually have log expressions anymore, right?
[11:10:17] <cmr> no, we do not
[11:10:21] <dbaupp> rusti: __log "A";
[11:10:21] -rusti- <anon>:7:15: 7:18 error: expected `(` but found `"A"`
[11:10:21] -rusti- <anon>:7          __log "A";
[11:10:22] -rusti-                         ^~~
[11:10:22] -rusti- application terminated with error code 101
[11:10:35] <aatch> DIE OBSOLETE CODE
[11:10:35] <dbaupp> rusti: __log("A");
[11:10:35] -rusti- <anon>:7:18: 7:19 error: expected `,` but found `)`
[11:10:35] -rusti- <anon>:7          __log("A");
[11:10:35] -rusti-                            ^
[11:10:35] -rusti- application terminated with error code 101
[11:10:48] <dbaupp> rusti: __log(1, "A");
[11:10:50] -rusti- rust: "A"
[11:10:50] -rusti- ()
[11:11:06] <aatch> dbaupp, isn't __log a function?
[11:11:07] <cmr> well __log is a function in the runtime isn't it?
[11:11:14] <dbaupp> aatch: apparently not
[11:11:15] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[11:11:25] <dbaupp> aatch: well, not properly
[11:11:33] <aatch> Urg
[11:11:34] <mark_edward> should pointer addition take ints?
[11:11:46] <dbaupp> aatch: "error: expected `,` but found `)`"
[11:11:47] <cmr> mark_edward: I think so
[11:11:47] <mark_edward> or uints? i can't see any reaso for limiting it to ints
[11:12:01] <mark_edward> *limiting it to uints
[11:12:01] <dbaupp> aatch: that's not a normal function error
[11:12:08] <aatch> dbaupp, I know
[11:12:14] <aatch> I just noticed that
[11:12:18] <mark_edward> it's an easy fix anyway, i'll do ints for now
[11:12:26] *** Joins: Earnestly (earnest@2A2BF8F5.321FA5E6.BFD1ABFD.IP)
[11:12:26] <aatch> -.-
[11:12:55] <aatch> mark_edward, brson mentioned a while back that he needed it at some point
[11:12:58] <dbaupp> are they "log expressions" ?
[11:13:05] <aatch> dbaupp, yes
[11:13:14] <mark_edward> aatch: so you're saying i should do ints for now?
[11:13:41] <aatch> mark_edward, yes, like you said, you can always change later if it becomes an issue
[11:13:54] <mark_edward> cool
[11:14:02] <aatch> but taking an int is somewhat more general.
[11:14:12] <dbaupp> mark_edward: you could possibly do impl<T, I: Int> Add<I, *T> for *T { ... }, and then you can add with any of the primitive ints
[11:14:32] <mark_edward> the problem there is the pointer conversion
[11:14:38] <dbaupp> i.e. ptr + 1u8 and ptr + (-1i64) would both work
[11:14:47] <mark_edward> it has to be converted to a uint or int
[11:15:00] <dbaupp> mark_edward: right
[11:15:02] <mark_edward> and wouldn't converting it to a signed type change the addition result
[11:15:16] <mark_edward> or would it. don't remember two's complement that well
[11:15:28] <dbaupp> nope, that's the beauty of 2's complement
[11:15:29] <cmr> no it wouldn't
[11:15:49] <aatch> mark_edward, twos complement is why this works
[11:16:06] <mark_edward> cool! then i'll take dbaupp's advice
[11:16:09] <dbaupp> mark_edward: (although, the Int trait doesn't provide any way to convert to an int)
[11:16:23] <dbaupp> mark_edward: however, IntConvertible does
[11:16:32] <cmr> dbaupp: I'm going to point the bencher at this stack of commits and go back to bed
[11:16:54] <mark_edward> it's odd that this issue is 11 months old. i'd figure you guys would really want it for your own use
[11:16:54] <cmr> if it explodes blame aatch
[11:17:05] <dbaupp> cmr: ok, I'll get this thing "working", and then throw it at you sometime :)
[11:17:27] <cmr> mark_edward: pointer arith is fairly rare, and offset() works well enough, just not pretty
[11:17:37] <dbaupp> mark_edward: there's not been that much pointer manipulation
[11:17:40] <mark_edward> true
[11:17:41] <aatch> rusti: -1u == std::uint::max_value
[11:17:42] -rusti- true
[11:18:02] <dbaupp> mark_edward: (essentially, only in std::vec and presumably the new runtime)
[11:18:23] <cmr> mark_edward: it's a nice-to-have, but low priority
[11:18:42] <aatch> Also, gotta have something for the newbies to do.
[11:18:52] <aatch> can't take all the easy issues for ourselves
[11:18:52] <aatch> :P
[11:18:55] <mark_edward> aatch: praise be for that
[11:19:48] <dbaupp> aatch: I reckon we should use them as cannon fodder against trans :P
[11:19:55] <aatch> Ok, so I'm now at "internal compiler error: no type for node 40044: unknown node (id=40044) in fcx 7f49996c5240" errors, I'd that thats an improvement
[11:20:28] <aatch> dbaupp, I think that might violate international law
[11:20:32] <dbaupp> aatch: it's almost like you have useful error messages.
[11:21:02] <dbaupp> aatch: the ones that survive would be hardened Rust veterans
[11:21:05] <aatch> Something about "cruel and unusual" punishment
[11:21:41] <dbaupp> it certainly has both of those
[11:22:35] <aatch> dbaupp, I live in a strange world where I take a break from trans by removing shared pointers from libsyntax
[11:23:01] <dbaupp> punishment is relative
[11:23:14] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[11:23:16] <dbaupp> (and you're just waaaay off the scale)
[11:24:30] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[11:24:43] *** Joins: Blei (philipp@moz-650B9C6A.cust.bluewin.ch)
[11:30:16] * dbaupp is javascripting well
[11:30:17] <dbaupp> http://i.imgur.com/wmDXtDm.png
[11:30:41] <aatch> dbaupp, you are clearly the best at javascript
[11:30:55] <dbaupp> aatch: uploading the improvements now
[11:31:07] * dbaupp wants to share the awesome with the world
[11:31:31] <dbaupp> (seriously though, I'm really bad at d3.)
[11:33:05] *** Joins: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net)
[11:33:12] *** Joins: Ubaion (Archer@moz-DA478E33.bb.online.no)
[11:33:33] *** Quits: Archer (Archer@moz-DA478E33.bb.online.no) (Ping timeout)
[11:33:42] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[11:35:24] <mark_edward> can you get rustc to dump llvm IR?
[11:35:32] <aatch> mark_edward, yes
[11:35:40] <aatch> --emit-llvm -S
[11:35:53] <aatch> will get you the LLVM IR Assembly
[11:35:56] <mark_edward> cool. it seems easier on the eyes the x86 assembly
[11:36:08] <mark_edward> and i like looking at assembly on occassion
[11:36:14] <mark_edward> it gives me a sick thrill
[11:36:52] * dbaupp prefers machine code
[11:37:15] <dbaupp> long strings of hex are much easier on the eye
[11:37:24] <dbaupp> ;P
[11:37:34] <aatch> do you think it would be wrong of me to make the change to stop parsing ~mut ?
[11:37:45] <doener> depends on what I'm looking at. For the unoptimized code, IR is easier IMHO, for the optimized code, asm is more compact
[11:37:55] *** Joins: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr)
[11:38:24] <Ms2ger> dbaupp, hex? Why not binary? :)
[11:38:43] <aatch> Ms2ger, line-length limits on his C64
[11:38:49] <Ms2ger> Zing
[11:39:06] *** Quits: robert (robertknig@moz-B6DD6E0B.range86-166.btcentralplus.com) (Connection reset by peer)
[11:39:19] <dbaupp> aatch: it's wrong because it's taken so long to do it?
[11:39:21] <aatch> screw it, bye-bye ~mut
[11:39:36] <dbaupp> rusti: ~mut 1
[11:39:38] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/IFca
[11:39:38] <aatch> rusti: let a = ~mut 1; a
[11:39:39] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/ZTUH
[11:39:49] * dbaupp was faster
[11:39:54] <aatch> it's an error anyway
[11:40:12] <dbaupp> (why is that error message suggesting using @mut? :/ )
[11:40:26] <dbaupp> doener: almost got zoom working
[11:40:30] *** Joins: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com)
[11:40:47] <dbaupp> doener: it's currently a little broken... http://i.imgur.com/wmDXtDm.png ;P
[11:40:47] <aatch> dbaupp, because it was ok at the time?
[11:40:55] <dbaupp> aatch: I guess
[11:42:02] *** Quits: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com) (Quit: webber46)
[11:42:43] *** Joins: robert (robertknig@moz-B6DD6E0B.range86-166.btcentralplus.com)
[11:42:58] <engla> dbaupp: just to list all possibilities?
[11:43:12] <doener> dbaupp: at least it kinda looks like a gaussian distribution of samples
[11:43:34] <dbaupp> doener: heh
[11:43:36] *** Quits: robert (robertknig@moz-B6DD6E0B.range86-166.btcentralplus.com) (Connection reset by peer)
[11:43:47] <dbaupp> doener: that's something, I guess?
[11:44:31] *** Quits: mye (mye@moz-DCE005F1.dip0.t-ipconnect.de) (Quit: mye)
[11:46:14] <aatch> now I'm at "internal compiler error: no type for node 37880: unknown node (id=37880) in fcx 7f9b9d6e2390" errors
[11:46:19] *** Joins: robert (robertknig@moz-B6DD6E0B.range86-166.btcentralplus.com)
[11:46:48] <dbaupp> aatch: the number's smaller... must be a good sign
[11:47:14] <aatch> dbaupp, I got no idea...
[11:47:30] <aatch> I'm just hoping it'll go away once I fix all the errors I do see
[11:50:24] <aatch> I'm hoping it's the pretty-printing having a spaz
[11:51:41] <mark_edward> what's that weird syntfaxx ive seen you guys use with vectors. something with elllipses?
[11:51:58] <aatch> rusti: [1,..16]
[11:51:59] -rusti- [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[11:52:09] <mark_edward> ah! thanks.
[11:52:17] <aatch> mark_edward, vector initialization syntax
[11:52:18] <mark_edward> it needs <T: Copy> right?
[11:52:24] <aatch> mark_edward, yes
[11:52:29] <mark_edward> cool
[11:54:36] <mark_edward> does rust have c style for loops? i've never seen them
[11:54:43] <aatch> mark_edward, no
[11:54:50] <mark_edward> while loops?
[11:54:56] <aatch> mark_edward, yes
[11:54:58] <mark_edward> cool
[11:55:01] <aatch> while cond { ... }
[11:55:19] <aatch> also, in infinite loop can be written as just loop { .. }
[11:55:37] <doener> the famous loop loop
[11:55:49] <aatch> well, it doesn't _have_ to be infinite, you can still return/break
[11:55:59] <aatch> loop { loop; } <- valid 
[11:56:06] <aatch> (also, no-op)
[11:56:21] <doener> 'loop: loop { loop 'loop }
[11:56:35] <aatch> doener, ah
[11:57:09] <aatch> I'm not sure what's worse, what you wrote, or the fact that I immediately understood it.
[11:57:35] <roo> what is the type inferencing bug that leads to the requirement extra type parameters in iterator.rs?
[11:57:35] <mark_edward> what...
[11:58:01] <mark_edward> is there are trait that you need to implement for += to work?
[11:58:10] <engla> mark_edward: can't do it at the moment
[11:58:17] <mark_edward> oh ok
[11:58:23] <aatch> roo, the type checker doesn't really take notice of what's in trait bounds during inference
[11:58:38] <roo> oh, i see
[11:58:56] *** Joins: mvalzelli (mvalzelli@moz-36091CB9.ip217.fastwebnet.it)
[11:58:59] <aatch> so if you have <A, T:Iterator<A>>, it doesn't infer the connection between the two 'A's
[11:59:03] <kimundi> mark_edward: There will be AddAssign, SubAssign etc in the future
[11:59:09] <roo> gotcha
[11:59:26] *** Parts: mvalzelli (mvalzelli@moz-36091CB9.ip217.fastwebnet.it) (Quitting)
[11:59:37] <mark_edward> why don't you just implement for all types implementing Add
[11:59:44] <mark_edward> sort of like how IteratorUtil works
[12:00:02] <aatch> mark_edward, because it doesn't work for all types implementing Add
[12:00:13] <mark_edward> what else does it need?
[12:00:16] <aatch> we already had that, but it's too heavy-handed.
[12:00:49] <aatch> mark_edward, well, for example, if you have += on a vector, you want it to be 'append'
[12:01:05] <kimundi> For some types, a += b can be implemented as a = a + b. For others thats a totally bonkers thing to do.
[12:01:15] <mark_edward> i see.
[12:01:25] <doomlord_> i really hope this language gains traction, it is a joy to work with once you get over the hurdle of relearning basics
[12:01:54] *** Quits: Ubaion (Archer@moz-DA478E33.bb.online.no) (Ping timeout)
[12:02:01] *** Joins: Archer (Archer@moz-DA478E33.bb.online.no)
[12:02:13] *** Joins: sge (Mibbit@moz-571DD666.range86-135.btcentralplus.com)
[12:02:32] <aatch> Yay! "aborting due to 174 previous errors"
[12:02:44] <dbaupp> it's sensible \o/
[12:03:01] <kimundi> Order has returned!
[12:04:05] * aatch is happy he doesn't have to hunt down the cause of an obscure bug
[12:04:24] <engla> not sure if vec is a good example for +=. Concat could have its own operator
[12:04:52] <mark_edward> yeah
[12:04:55] <mark_edward> like ~=
[12:04:57] <kimundi> Well a lot could have it's own operator :P
[12:05:01] <mark_edward> i forget which language does that
[12:05:05] <aatch> mark_edward, D
[12:05:11] <engla> ~=  is not eq in lua
[12:05:14] <kimundi> ~= is != in lua
[12:05:21] * aatch was a D contributor
[12:05:32] <dbaupp> ~= == != in lua
[12:05:43] * mark_edward aatch can contribute ~= in Rust! 
[12:05:44] <dbaupp> ~= != ==
[12:05:48] <engla> I'm thinking more like Monoids everywhere like in haskell. And ++ or <> to concat
[12:05:48] <doomlord_> haskell uses ++ for concatenation  ? one of the many things that initially makes it look hostile...
[12:06:02] <kimundi> ~= == != == <>
[12:06:26] <mark_edward> looks like either a sperm cell or a lamed bacteriophage
[12:06:30] <engla> ++ is benign compared to .. all the other stuff
[12:06:32] <doomlord_> can you just use named functions
[12:06:41] <doomlord_> .concat(...).conact(...) ..
[12:06:45] <mark_edward> thatt's properterous
[12:06:58] <kimundi> a `concat` b ftw!
[12:07:00] <mark_edward> programming is math, so we should just use symbols for everything
[12:07:02] <doomlord_> instead of using asccii art
[12:07:21] <doomlord_> yeah but programming is limited by a keyboard
[12:07:35] <doomlord_> you cant move a pen above/below so much to create more meaning
[12:07:48] <aatch> doomlord_, clearly you haven't seen my full unicode keyboard
[12:07:49] <mark_edward> i have alt+shift set up to give me a greek symbols keyboard
[12:07:52] <mark_edward> i'm ready
[12:08:11] <kimundi> MÎµ Ï„Î¿Î¿!
[12:08:21] <doomlord_> how about using named words, and you use a text editor with something like emacs "pretty-mode"
[12:08:35] <mark_edward> ...
[12:08:54] <doomlord_> display "concat" as whatever meaningful squiggle takes your fancy
[12:09:48] <mark_edward> i don't like that idea. then my code will look less clever and be easier for people to comprehend as a glance
[12:09:50] <doomlord_> good point what is the rust policy on unicode
[12:10:07] <mark_edward> they need to take a long time to really comprehend the beauty and elegance
[12:10:17] <aatch> ðŸ’©
[12:10:40] <kimundi> doomlord_: identifiers can contain a subset of uncode charactrs
[12:10:41] <aatch> doomlord_, what do you mean?
[12:10:58] <doomlord_> is there support for unicode symbol names / is it desired... etc
[12:11:02] <kimundi> rusti: let Ï€ = 3.14f; Ï€
[12:11:04] -rusti- 3.14
[12:11:23] <aatch> We use the XID_Start/XID_Continue character classes for identifiers
[12:11:24] <kimundi> rusti: let Ï€ = 3.14f; let Ï„ = 2 * Ï€; Ï„
[12:11:25] -rusti- <anon>:7:34: 7:34 error: mismatched types: expected `<VI0>` but found `float` (expected integral variable but found float)
[12:11:25] -rusti- <anon>:7          let Ï€ = 3.14f; let Ï„ = 2 * Ï€; Ï„
[12:11:25] -rusti-                                            ^
[12:11:25] -rusti- error: aborting due to previous error
[12:11:25] -rusti- application terminated with error code 101
[12:11:31] <aatch> with a few extras
[12:11:45] <dbaupp> (e.g. underscores)
[12:12:01] <kimundi> rusti: let Ï€ = 3.14f; let Ï„ = 2f * Ï€; Ï„
[12:12:02] -rusti- 6.28
[12:12:04] <engla> basically letters from any script
[12:12:35] <dbaupp> rusti: let âˆ« = 1; âˆ«
[12:12:35] *** Quits: robert (robertknig@moz-B6DD6E0B.range86-166.btcentralplus.com) (Connection reset by peer)
[12:12:36] -rusti- <anon>:7:13: 7:13 error: unknown start of token: 8747
[12:12:36] -rusti- <anon>:7          let âˆ« = 1; âˆ«
[12:12:36] -rusti-                       ^
[12:12:36] -rusti- application terminated with error code 101
[12:12:40] <dbaupp> :(
[12:12:52] <aatch> dbaupp, integral sign != letter
[12:12:57] <doomlord_> i suppose more bracket types would make language syntax easier..
[12:13:02] * dbaupp wanted to write a maths library where the api is only unicode symbols
[12:13:13] <dbaupp> aatch: I lived in hope
[12:13:15] <doomlord_> (disambiguating templates .. block syntax .. )
[12:13:18] <engla> rusti: let á‰ = 0; á‰
[12:13:18] -rusti- 0
[12:13:32] <kimundi> rusti: let âˆš = |x: float| x.sqrt(); âˆš(16f)
[12:13:32] -rusti- <anon>:7:13: 7:13 error: unknown start of token: 8730
[12:13:33] -rusti- <anon>:7          let âˆš = |x: float| x.sqrt(); âˆš(16f)
[12:13:33] -rusti-                       ^
[12:13:33] -rusti- application terminated with error code 101
[12:13:36] <dbaupp> doomlord_: hard to type
[12:13:37] <kimundi> :(
[12:13:49] <heftig> engla: wtf cherokee
[12:13:53] <doomlord_> ok back to the limit of the keyboard itself
[12:14:03] *** Joins: cr (anonymous@moz-5E05F028.dip0.t-ipconnect.de)
[12:14:05] <engla> yeah it looks really cool, except the terminal font does not support it well
[12:14:09] <engla> that's a problem
[12:14:23] <kimundi> fn fooâŸ¨a, b, câŸ©(...)
[12:14:35] <aatch> kimundi, heh
[12:14:39] <darkf> awesome
[12:14:41] <darkf> er
[12:15:02] <doomlord_> darkf, from #programming?
[12:15:03] <dbaupp> doomlord_: (essentially anything that's not ascii is hard for someone to type, and even some things that are ascii are hard on some keyboards)
[12:15:06] <aatch> I would like to make '?' a valid identifier character
[12:15:08] *** Joins: robert (robertknig@moz-B6DD6E0B.range86-166.btcentralplus.com)
[12:15:10] * kimundi wants a screenshot, because HIS irc client doesn't display those chars
[12:15:12] <darkf> doomlord_: hey, you.
[12:15:26] <darkf> this is an awesome and irrelevant error
[12:15:38] <engla> hte angle brackets look fine
[12:15:41] <dbaupp> aatch: i'd be neat if it was at least tokenised properly, for syntax extensions
[12:15:42] <roo> aatch: yeah, for predicates!
[12:16:08] <aatch> dbaupp, _should_ be ok
[12:16:14] <sge> how could i have a dlist of mutable uncopyable owned pointers, is it not possible?
[12:16:16] <doomlord_> darkf, it looks like rust could well be the answer to my c++ rants.
[12:16:17] <dbaupp> aatch: I tried it once
[12:16:17] <aatch> since that's the only place they're used
[12:16:31] <dbaupp> aatch: I was clearly doing something wrong, because the compile exploded
[12:16:37] <darkf> doomlord_: probably. I wrote 600 lines of it the past couple days and I am enjoying it so far.
[12:16:40] <dbaupp> (and not the libsyntax one.)
[12:17:05] <kimundi> I'm not sure if empty? is better than is_empty. Sure standalone it looks nicer, but as a methoed call: foo().empty?() ... Might be to much symbol noise, idk
[12:17:19] <doomlord_> my stockholm syndrome is pretty strong.. but once i get over the humiliation of having to read to find out basic things, the rest is a real joy
[12:17:23] <dbaupp> sge: a mutable owned pointer is created by having the owner mutable
[12:17:36] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[12:17:40] <aatch> doomlord_, make up for it by reading the source to find out basic things
[12:17:44] <doomlord_> no header files! no retarded classes!!!
[12:17:47] <darkf> although there are some stumbling blocks, like right now I can't figure out how to instantiate a hashmap, since (a) std::hashmap::HashMap is unresolved, (b) there is an irrelevant error for: let a = std::hashmap::HashMap<int, ~str>; say
[12:18:04] <aatch> doomlord_, no, we have buggy trait objects instead!
[12:18:19] <darkf> rusti: let a = std::hashmap::HashMap<int, ~str>;
[12:18:20] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/HLFd
[12:18:33] <darkf> that is just silly
[12:18:37] <darkf> but how do I instantiate a hashmap?
[12:18:44] <aatch> darkf, two ways
[12:18:55] *** Joins: Ghost (Ice@E8A7525.6332494E.D0DDB18B.IP)
[12:19:06] <dbaupp> sge: so, e.g. you'd have DList<~MyType>, and then (basically) you're forced to use .each_node
[12:19:24] *** Joins: mye (mye@moz-DCE005F1.dip0.t-ipconnect.de)
[12:19:25] <aatch> rusti: std::hashmap::HashMap::new::<int, ~str>()
[12:19:27] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/YJeV
[12:19:37] <aatch> (heh)
[12:19:41] <darkf> ahh, did not notice a new()! :)
[12:19:54] <darkf> (funny, the output of that looks more like Erlang structures ;))
[12:20:08] <dbaupp> sge: (well, to be clear, you have to manipulate the nodes directly, because you need the compiler to know that you're getting the owned pointer from a mutable owner, specifically the @mut DListNode)
[12:20:27] <aatch> rusti: let a = std::hashmap::HashMap<int, ~str> = std::hashmap::HashMap::new(); a.is_empty()
[12:20:28] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/QRgH
[12:20:43] <dbaupp> rusti: let a: std::hashmap::HashMap<int, ~str> = std::hashmap::HashMap::new(); a.is_empty()
[12:20:45] -rusti- true
[12:20:59] *** Joins: BitPuffin (quassel@moz-B986D630.cust.tele2.se)
[12:21:01] * aatch typo'd
[12:21:09] <dbaupp> rusti: let a = std::hashmap::HashMap::new(); a.insert(1i, ~"foo"); a.is_empty()
[12:21:09] -rusti- <anon>:7:47: 7:48 error: cannot borrow immutable local variable as mutable
[12:21:09] -rusti- <anon>:7          let a = std::hashmap::HashMap::new(); a.insert(1i, ~"foo"); a.is_empty()
[12:21:10] -rusti-                                                         ^
[12:21:10] -rusti- error: aborting due to previous error
[12:21:10] -rusti- application terminated with error code 101
[12:21:11] <sge> thanks dbaupp
[12:21:19] <dbaupp> rusti: let mut a = std::hashmap::HashMap::new(); a.insert(1i, ~"foo"); a.is_empty()
[12:21:20] -rusti- false
[12:21:23] <aatch> darkf, normally you don't need to provide type hints like that
[12:21:35] <aatch> as dbaupp helpfully demonstrated
[12:21:56] <darkf> that's why I am in love with type inference (although I can see why you can't do global inference unfortunately :()
[12:22:09] <dbaupp> sge: unfortunately dlist is a slightly abandoned area of the libraries (like much of the rest of libextra), so don't be surprised if things don't work very well. :(
[12:22:19] *** Quits: Houm (Houm@moz-25669AA8.fbx.proxad.net) (Ping timeout)
[12:23:37] <aatch> 168 errors now
[12:23:58] <aatch> with what appears to be ~120 in fold.rs
[12:24:25] *** Quits: Ghost (Ice@E8A7525.6332494E.D0DDB18B.IP) (Quit: Bring Me To Life...)
[12:24:52] <mark_edward> i'm trying to rebase to upstream/master but there's somehow a merge error in a file id idn't change
[12:24:55] <mark_edward> how could this happen!
[12:25:15] <aatch> mark_edward, bad luck
[12:25:29] <mark_edward> what should i do?
[12:26:07] <aatch> mark_edward, fix the conflict
[12:26:11] *** Quits: sge (Mibbit@moz-571DD666.range86-135.btcentralplus.com) (Quit: http://www.mibbit.com ajax IRC Client)
[12:26:56] <doener> mark_edward: what does "git diff upstream/master...$your_branch path/to/file" say?
[12:26:57] <mark_edward> isn't it something that's been fixed already though??? this is confusing... how can i have a merge error when any changes in other files must have already been merged in to be in master... right?
[12:26:58] <dbaupp> aatch: make a snapshot and delete fold.rs?
[12:27:08] *** Quits: robert (robertknig@moz-B6DD6E0B.range86-166.btcentralplus.com) (Connection reset by peer)
[12:27:22] <dbaupp> aatch: because *clearly* migrating all the visitors to the trait one will be more efficient ;P
[12:27:30] <doener> mark_edward: (that's three dots, not two)
[12:27:47] <doomlord_> suggestion for docs:- Show an example of "pub self::<modname> .." in http://static.rust-lang.org/doc/tutorial.html#modules-and-crates  .. i trip up on that whenever i started
[12:28:09] <mark_edward> dbaupp: it says a lot. there are a lot of changes in vec.rs
[12:28:36] *** Quits: Sindwiller (quassel@moz-743130B2.dynamic.hispeed.ch) (Connection reset by peer)
[12:28:40] * dbaupp is sorry
[12:28:56] * dbaupp probably did most of those changes
[12:28:57] <doener> mark_edward: well, that diff shows the changes that you made on that branch since you forked from upstream
[12:29:14] <mark_edward> but i didn't make any changes in vec.rs
[12:29:20] *** Joins: robert (robertknig@moz-B6DD6E0B.range86-166.btcentralplus.com)
[12:29:33] <doener> mark_edward: are you sure you used three dots?
[12:29:59] <mark_edward> yes
[12:30:12] <engla> mark_edward: you might be trying to rebase more than your changes
[12:30:12] <doener> mark_edward: is upstream/master up to date? Try "git fetch upstream", then diff again
[12:30:27] <dbaupp> mark_edward: what does `git diff --stat upstream/master...$your_branch` say?
[12:31:28] <mark_edward> dbaupp: a lot of stuff changed besides mine
[12:31:28] *** Quits: robert (robertknig@moz-B6DD6E0B.range86-166.btcentralplus.com) (Connection reset by peer)
[12:31:37] <aatch> down to 118 errors
[12:31:45] <aatch> most are still in fold.rs
[12:31:50] <dbaupp> mark_edward: does the rebase complain about all of them
[12:31:54] <doener> mark_edward: even after the fetch?
[12:31:55] <dbaupp> ?
[12:32:10] <mark_edward> nope, just about vec.rs
[12:32:26] <aatch> mark_edward, have you aborted the rebase?
[12:33:00] <mark_edward> yes
[12:33:28] <aatch> ok, run "git remote update upstream && git rebase -i upstream/master"
[12:33:28] <dbaupp> mark_edward: this is your smallintmap one, right?
[12:33:38] <mark_edward> yes
[12:34:15] <aatch> mark_edward, if rebase -i shows more than your commits, delete them
[12:34:33] <darkf> oh dear oh my, is there a way to max() on non-pointer values, like I'm trying to do 0u.max(v.len()-1) which is ugly in of itself but :)
[12:34:52] <mark_edward> ok
[12:34:57] *** Joins: robert (robertknig@moz-B6DD6E0B.range86-166.btcentralplus.com)
[12:35:30] *** Joins: Houm (Houm@moz-25669AA8.fbx.proxad.net)
[12:35:32] <darkf> well I mean min(
[12:35:46] <darkf> might as well just write this
[12:35:48] <dbaupp> darkf: min(&0u, &(v.len() - 1))?
[12:36:10] <engla> darkf: uint::max for example
[12:36:44] <mark_edward> aatch: okay that worked...
[12:37:52] <darkf> engla: uint::max doesn't exist (it doesn't seem to implement Orderable from what the docs say. ackh.)
[12:38:29] <engla> rusti: std::uint::max(3, 4)
[12:38:30] -rusti- 4
[12:39:11] <doomlord> use std::uint::* ?
[12:39:36] <darkf> okay, I blame the docs :) thanks
[12:39:51] <dbaupp> we appear to have a conflict :S https://github.com/mozilla/rust/pull/7624
[12:39:55] <dbaupp> mark_edward: ^
[12:40:21] <mark_edward> who did this?
[12:40:33] <mark_edward> and what should i do about that?
[12:41:34] <dbaupp> mark_edward: well, you opened yours first, but I guess you could comment politely on it.
[12:42:04] <mark_edward> what's standard practice in this situation?
[12:42:50] * dbaupp thinks it's funny that he may've actually met that person IRL, in a completely different context & on a different continent
[12:43:35] <aatch> dbaupp, has mark's thing been approved yet?
[12:43:51] <aatch> (there's no r+ on it)
[12:44:04] <dbaupp> aatch: don't think so
[12:44:19] <dbaupp> aatch: it wasn't mergeable last time I looked at it
[12:44:40] <aatch> dbaupp, would saying its already approved be lying?
[12:45:17] *** Joins: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[12:45:33] <dbaupp> aatch: well, sorta
[12:45:53] *** Quits: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net) (Ping timeout)
[12:46:31] <mark_edward> https://github.com/mozilla/rust/pull/7614 i have somehow reversed time
[12:46:53] <mark_edward> my last commit... i was just removing the use std::vec; which was unnecessary
[12:47:06] <dbaupp> mark_edward: um, you appear to have broken something...
[12:47:33] <engla> github doesn't use the topological order
[12:47:36] <mark_edward> yupp. now it seems like my change is in the older commit.
[12:47:40] <engla> only date order of commits :-(
[12:47:52] <mark_edward> dbaupp: what did i break
[12:48:14] <mark_edward> and how can i unbreak it
[12:48:20] <aatch> AHH
[12:48:41] <mark_edward> you okay aatch
[12:48:43] <dbaupp> mark_edward: I see 2 copies of the relevant commit
[12:48:55] <dbaupp> mark_edward: and a bors merge commit
[12:49:01] <aatch> mark_edward, you have several other people commits
[12:49:02] <dbaupp> mark_edward: hm
[12:49:08] <mark_edward> dbaupp: yup. but there is a one line difference in one of them'
[12:49:11] <dbaupp> mark_edward: maybe:
[12:49:19] <dbaupp> checkout master
[12:49:23] <doener> and a merge with a very weird commit message
[12:49:36] <dbaupp> checkout -b some_branch_name
[12:49:57] <aatch> doener, nah, that's fairly normal
[12:50:08] <dbaupp> cherry-pick 1cd11ba
[12:50:34] <mark_edward> dbaupp: how do i do that?
[12:50:36] <dbaupp> git reset --hard smallintmap_enum HEAD
[12:50:47] <dbaupp> mark_edward: (all of those should have git prefixed)
[12:50:48] <doener> aatch: hu? https://github.com/MarkJr94/rust/commit/c3b9892e89b6b28cd45a2e508c469a4a9c4edfe8 -- that one is normal?
[12:51:10] <aatch> doener, it's what you get from squashing commits together
[12:51:22] <dbaupp> mark_edward: (and you want that hash to be the commit that you want to merge into master)
[12:51:23] <engla> needs a better commit log
[12:51:26] *** Quits: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Ping timeout)
[12:51:40] <doener> aatch: that's a regular merge though
[12:51:46] <mark_edward> dbaupp: git reset --hard smallintmap_enum HEADdidn't work
[12:51:57] <mark_edward> said it needed a path
[12:51:58] <dbaupp> mark_edward: what'd it say
[12:52:15] <mark_edward> dbaupp: fatal: Cannot do hard reset with paths.
[12:52:45] <dbaupp> mark_edward: oh, um, `git branch -D smallintmap_enum` `git branch -m smallintmap_enum`
[12:52:48] * doener misses the commit messages from git.git
[12:52:55] <dbaupp> mark_edward: (delete the old one, rename the current one)
[12:53:22] *** Joins: sigma1 (sigma@moz-294FA516.range86-128.btcentralplus.com)
[12:53:39] * dbaupp hopes he hasn't broken mark_edward's rust repo
[12:53:55] <mark_edward> i've done that. so now i try and.. push?
[12:55:07] <aatch> 99 errors
[12:55:33] <mark_edward> dbaupp: should i? i'm so scared now...
[12:55:49] <dbaupp> mark_edward: what's git log say
[12:56:07] <dbaupp> mark_edward: it should have your commit and then one by bors immediately below it
[12:56:17] <mark_edward> yup!
[12:56:30] <dbaupp> cool! yep, push it
[12:56:39] <aatch> dbaupp, huh?
[12:56:47] <aatch> oh, right
[12:56:51] <dbaupp> aatch: ?
[12:57:04] <aatch> I was thinking of the wrong thing
[12:57:22] <mark_edward> NOOOOOOOOOOOOOOOOOOOOOOOOOOO
[12:57:34] <mark_edward> rejected as non fast forward
[12:57:37] <dbaupp> mark_edward: you might need `push -f`to force it
[12:57:38] <mark_edward> force-push?
[12:57:40] <mark_edward> ok
[12:57:41] <aatch> mark_edward, git push -f
[12:57:43] <dbaupp> yep
[12:58:03] <dbaupp> mark_edward: there we go, looks good!
[12:58:22] <aatch> dbaupp, good remote gitting there
[12:58:31] <dbaupp> :)
[12:58:34] <mark_edward> dbaupp: yeah you are a git pro
[12:58:42] <dbaupp> I'm really not...
[12:58:42] <mark_edward> basically Linus Torvalds
[12:59:02] <dbaupp> push/pull/rebase/checkout are the only things I know
[12:59:11] <dbaupp> (ok, and cherry-pick.)
[12:59:17] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[12:59:17] <ghrust> 01[13rust01] 15bors pushed 5 new commits to 06auto: 02http://git.io/eWqkmQ
[12:59:17] <ghrust> 13rust/06auto 14cd0c25e 15Fedor Indutny: libc: add _SC_* consts for non-mips linux too...
[12:59:17] <ghrust> 13rust/06auto 14b959ba9 15Fedor Indutny: libc: VirtualAlloc and FileMapping bindings
[12:59:18] <ghrust> 13rust/06auto 140a39c8c 15Fedor Indutny: libc: add errno values
[12:59:19] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[12:59:20] *** Joins: Sorella (queen@78575561.924F2739.95C8B7C6.IP)
[12:59:38] <mark_edward> so what happened to all of bors comments?
[13:00:01] <dbaupp> hm?
[13:00:31] <mark_edward> i don't see them on the PR or issue anymore
[13:00:41] <dbaupp> on your PR?
[13:00:47] <doener> they were on the commits, since the commits are gone, the comments are gone as well
[13:01:00] <mark_edward> yup. oh i see. man i royally screwed that up.
[13:01:06] <mark_edward> gonna buy an ebook on git tomorrow
[13:01:21] *** Joins: bytewise (bytewise@moz-649C630D.unitymediagroup.de)
[13:01:38] <doener> mark_edward: that's just the usual workflow with github :-/
[13:02:02] <aatch> 82 errors
[13:02:03] <mark_edward> that seemd really unusual to me. i did something weird with my commits
[13:02:13] <mark_edward> aatch: making sweet prog  bro
[13:02:27] <dbaupp> mark_edward: http://try.github.io/ & http://pcottle.github.io/learnGitBranching/ might be fun/helpful :)
[13:02:55] <doener> mark_edward: gerrit does a better job at keeping the history of an evolving merge request, but fails at supporting multiple commits per merge request
[13:05:58] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[13:06:38] <mark_edward> i see
[13:07:12] <dbaupp> oops
[13:07:21] <dbaupp> no wonder IRFY wasn't updating
[13:07:26] <dbaupp> the disk was full :/
[13:08:16] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[13:08:16] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14592fc27 to 146595c42: 02http://git.io/N3iJvQ
[13:08:16] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[13:08:17] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[13:08:17] <ghrust> 01[13rust01] 15bors pushed 9 new commits to 06auto: 02http://git.io/atOwMA
[13:08:17] <ghrust> 13rust/06auto 14c7463a5 15James Miller: Stop allocating view_items with @
[13:08:17] <ghrust> 13rust/06auto 14bf1bc00 15James Miller: De-managed ast::Path
[13:08:17] <ghrust> 13rust/06auto 142e4d0e1 15James Miller: De-manage Lifetime
[13:08:18] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[13:09:23] <aatch> woo
[13:10:47] <aatch> I must admit, I like the weird bump thing after parsing
[13:11:15] <aatch> I'm pretty sure its the config stripping
[13:11:29] *** Joins: BizarreCake (BizarreCak@51AA6B33.6D202491.34A7550B.IP)
[13:12:25] <aatch> 75 errors now, none in fold.rs
[13:12:37] <aatch> mostly in ext/build.rs
[13:13:04] <dbaupp> aatch: which bump?
[13:13:33] <aatch> dbaupp, https://a248.e.akamai.net/camo.github.com/44830f25c895a4039f6b744a62dfd0caea5fd106/687474703a2f2f692e696d6775722e636f6d2f4c314a5358714e2e706e67 after the first slope
[13:13:42] <aatch> there's a flatter bit
[13:14:04] <aatch> memory usage ends up the same overall
[13:14:06] <dbaupp> my shiny new zoomy version of IRSY says that it's in resolution
[13:14:18] <dbaupp> (well, implies, for that graph)
[13:14:49] <dbaupp> the first slope goes all the way to "maybe building test harness"
[13:15:23] <aatch> dbaupp, hm interesting
[13:15:25] <dbaupp> actually, it's possibly in typeck
[13:18:07] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[13:20:39] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[13:21:32] <mark_edward> dbaupp: are you huonw
[13:21:42] <dbaupp> mark_edward: yup
[13:21:53] <mark_edward> oh ok. just wondering
[13:28:23] <aatch> ugh, I fixed ext/build.rs and broke the rest of ext/*
[13:28:46] <aatch> time call it a night methinks
[13:30:07] <aatch> Who would have thought that a programming language would be so reliant on expressions.
[13:30:16] <aatch>  /s
[13:30:26] *** aatch is now known as aatch|expression
[13:32:14] <darkf> rusti: let mut a = ~[1]; for a.iter().advance |_| { a[0] = 2; }
[13:32:15] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/BAWV
[13:32:28] <dbaupp> aatch|expression: (there's probably several places in ext/deriving that are actually incorrect, fwiw.)
[13:32:33] <darkf> how do I do this? I seem to be failing with borrowed pointers :)
[13:32:58] <dbaupp> rusti: let mut a = ~[1]; for a.mut_iter().advance |elem| { *elem = 2; } a
[13:32:59] -rusti- ~[2]
[13:33:10] <darkf> ooh
[13:33:14] <dbaupp> but that's not necessarily what you're trying to do?
[13:33:28] <darkf> it is, but why doesn't indexing it work as well?
[13:33:57] <engla> mutable pointers are exclusive, so when you borrow any other reference to a it is "locked"
[13:34:06] <dbaupp> because you've borrowed `a` as an immutable variable (via .iter()) and once you do this, you aren't allowed to mutate it until the immutable borrow ends
[13:34:09] <kimundi> because there can only be at most one mutable reference to a value
[13:34:15] <dbaupp> this is required for memory safety
[13:34:18] <darkf> ah, I see :)
[13:34:22] <darkf> thank you all
[13:37:18] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[13:38:04] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[13:40:32] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[13:42:01] *** Quits: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com) (Ping timeout)
[13:44:37] <SiegeLord> Do trait objects implement the relevant traits?
[13:44:47] <SiegeLord> That is, the traits they are associated with?
[13:44:58] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[13:45:41] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[13:46:10] *** Quits: BitPuffin (quassel@moz-B986D630.cust.tele2.se) (Ping timeout)
[13:46:17] <mark_edward> rusti: let x = ~1; let t = x as ~ToStr; t
[13:46:38] <engla> don't think so SiegeLord
[13:46:53] <SiegeLord> I think they should, it'd provide an amazingly clean way to avoid template bloat
[13:47:13] <mark_edward> what happened to rusti?
[13:47:25] <engla> it's alive mark_edward 
[13:47:32] <engla> rusti: "hi"
[13:47:33] -rusti- "hi"
[13:47:37] <engla> rusti: botsnack
[13:47:38] -rusti- <anon>:7:9: 7:17 error: unresolved name `botsnack`.
[13:47:38] -rusti- <anon>:7          botsnack
[13:47:38] -rusti-                   ^~~~~~~~
[13:47:38] -rusti- error: aborting due to previous error
[13:47:38] -rusti- application terminated with error code 101
[13:47:44] <engla> oh no
[13:47:45] <SiegeLord> :o
[13:47:48] <mark_edward> rusti: let x = ~1; x.to_str()
[13:47:50] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/UZSO
[13:47:52] <SiegeLord> It's grumpy
[13:48:12] <mark_edward> rusti: let x = ~1i; x.to_str()
[13:48:12] -rusti- ~"1"
[13:48:31] <mark_edward> rusti: let x = ~1i; let t = x as ~ToStr; t.to_str()
[13:48:32] -rusti- ~"1"
[13:48:37] <mark_edward> rusti: let x = ~1i; let t = x as ~ToStr; t
[13:48:51] <mark_edward> whatt's happening there?
[13:50:17] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[13:50:17] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14b3cb1f8 to 146595c42: 02http://git.io/N3iJvQ
[13:50:17] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[13:50:18] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[13:50:18] <ghrust> 01[13rust01] 15bors pushed 6 new commits to 06auto: 02http://git.io/9fyKPA
[13:50:18] <ghrust> 13rust/06auto 14c9b9462 15Seo Sanghyeon: Remove visit_struct_method
[13:50:18] <ghrust> 13rust/06auto 142e65782 15Seo Sanghyeon: Do not rely on newtype enum dereference
[13:50:19] <ghrust> 13rust/06auto 142045889 15Seo Sanghyeon: vim: Highlight 0i as number
[13:50:21] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[13:50:53] <thomas_adam> Hmm.  So I rather like Rust from what I've used it for---but I'm curious to know why there's this distinction between owned boxes and managed boxes.  It seems to me like you can go down one route and be more like C and fuck it up, or go down the other, and be more like Java and not have to care.  Yet I'm not clear on why there's such a fine-grained distinction.
[13:51:09] <mark_edward> thomas_adam: you're misunderstanding it then
[13:51:58] <SiegeLord> Owned boxes provide determinism... and the type system makes them safe
[13:52:09] <engla> thomas_adam: the language needs to give you the choice for performance
[13:52:53] <cmr> thomas_adam: Owned boxes aren't like C at all, they are impossible to fuck up, the compiler statically verifies they are used correctly
[13:52:54] <mark_edward> thomas_adam: see here http://static.rust-lang.org/doc/tutorial.html#ownership
[13:52:57] <thomas_adam> mark_edward: No, I do understand, but am curious as to _why_.
[13:53:06] <thomas_adam> engla: cmr OK.
[13:53:25] *** Quits: Ms2ger (Ms2ger@moz-E9883900.access.telenet.be) (Ping timeout)
[13:53:30] <mark_edward> you don't you can't fuck up. and they aren't reference counted or garbage collected. their use is statically verified by the compiler
[13:53:46] <cmr> dbaupp: did it explode?
[13:53:57] <dbaupp> cmr: it?
[13:54:02] <cmr> dbaupp: the data
[13:54:06] <dbaupp> cmr: oh, no I don't think so
[13:54:16] <mark_edward> rusti: let x = ~1i; let t = x as ~ToStr; t
[13:54:24] <mark_edward> what's happening here?
[13:54:56] <kimundi> mark_edward: I have an idea
[13:55:03] <mark_edward> what is it?
[13:55:12] <kimundi> rusti: fmt!("%?", 5)
[13:55:13] -rusti- ~"5"
[13:55:17] <cmr> rusti: 5
[13:55:18] -rusti- 5
[13:55:20] <kimundi> rusti: fmt!("%?", ||())
[13:55:21] -rusti- ~""
[13:55:49] <dbaupp> cmr: github pages is being really slow though... my updater apparently pushed some new 30 minutes ago, but it apparently hasn't appear yet :/
[13:55:50] <kimundi> rusti: let f: ~ToStr = ~5i as ~ToStr; fmt!("%?", f)
[13:55:51] -rusti- ~""
[13:55:54] <kimundi> jup
[13:56:09] <cmr> rusti: let x = ~1i; let t = x as ~ToStr; t.to_str()
[13:56:10] -rusti- ~"1"
[13:56:20] <cmr> pretty printer doesn't like vtables I guess
[13:56:23] <kimundi> reflaxion printer emmitts empty string for closures and trait objects
[13:56:33] <dbaupp> rusti: || {}
[13:56:46] <dbaupp> rusti: (|| {}, ) 
[13:56:47] -rusti- (,)
[13:56:47] *** Quits: drrb (drrb@1890AB83.D0F4B50F.670D5E6B.IP) (Quit: drrb)
[13:57:07] <kimundi> rusti: (||(),||()) 
[13:57:07] -rusti- (, )
[13:57:08] *** Joins: jviereck (Adium@moz-AA038B02.dynamic.eduroam.mwn.de)
[13:57:16] <cmr> dbaupp: yeah, I haven't been that impressed by github pages response time recently either :\
[13:57:37] <dbaupp> cmr: It used to update in seconds :'(
[14:00:28] *** Quits: robert (robertknig@moz-B6DD6E0B.range86-166.btcentralplus.com) (Ping timeout)
[14:04:14] *** Joins: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net)
[14:05:27] *** Quits: Archer (Archer@moz-DA478E33.bb.online.no) (Ping timeout)
[14:06:51] <dbaupp> cmr: http://i.imgur.com/85eKPLc.png
[14:06:53] <dbaupp> o_O
[14:07:27] <cmr> hoho
[14:07:28] <dbaupp> (the black one is the oldest commit)
[14:07:47] *** Quits: z0w0 (zack@E2E93C1.54F16452.2CE63F58.IP) (Client exited)
[14:07:55] <cmr> I think that's before the opt pass rework
[14:08:05] <kimundi> it seems we improved quite a bit in the last 2 months ;)
[14:08:54] *** Quits: mye (mye@moz-DCE005F1.dip0.t-ipconnect.de) (Quit: mye)
[14:09:07] <doener> cpu time looks awful for the last week though
[14:09:26] <cmr> dbaupp: going to need to have a zoom+pan thingy
[14:09:38] <dbaupp> cmr: done!
[14:09:41] <dbaupp> uploading it now
[14:09:46] <cmr> brilliant
[14:09:56] * dbaupp thinks it'll be full of bugs
[14:09:57] <kimundi> Oouuh, and a 3D view!
[14:10:03] <SiegeLord> Wait, what https://github.com/mozilla/rust/issues/5087
[14:10:24] <dbaupp> kimundi: I thought of doing that... I couldn't find any decent javascript plotting libraries
[14:10:36] <dbaupp> and I don't really want to learn webgl for this :/
[14:10:44] <dbaupp> *3d plotting
[14:10:52] <cmr> SiegeLord: hm?
[14:11:18] <dbaupp> wow, that was fast
[14:11:30] <dbaupp> http://huonw.github.io/isrustfastyet/mem/#58eb70a,3a323c1
[14:11:41] <dbaupp> (zoom by scrolling on the graphs)
[14:12:15] <kimundi> no  zoom happening here
[14:12:28] <SiegeLord> cmr: I don't understand the code example... and I'm disheartened that the feature was removed
[14:12:33] <mark_edward> do docs go before or after the #[inline] directive
[14:12:40] <SiegeLord> And I don't get the workaround XD
[14:12:45] <doener> cmr: 
[14:12:48] <doener> http://i.imgur.com/1dxrnjA.png
[14:12:54] <doener> close enough
[14:13:04] <cmr> mark_edward: doesn't matter, but before is the convention
[14:13:10] <doener> oh wait, that was kimundi asking for it
[14:13:12] <cmr> well, I don't /think/ it matters
[14:13:37] *** Quits: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr) (Quit: pyrac)
[14:13:43] <mark_edward> do you think the pointer addition/subtraaction methods nee documentation
[14:13:52] <cmr> Everything needs documentation
[14:13:57] <cmr> don't skimp :p
[14:14:04] <dbaupp> (it doesn't matter, you could probably even put the #[inline] directive insiide the documentation.)
[14:14:06] <kimundi> doener: lol
[14:14:24] <cmr> dbaupp: no zooming happening here either
[14:14:35] <dbaupp> cmr: browser?
[14:14:42] <cmr> firefox whatever'slatest
[14:14:47] <dbaupp> cmr: (also, screenshot?)
[14:14:48] <kimundi> chrome
[14:14:59] <cmr> and don't say clear your cache, because I'm looking at it in the js ;p
[14:15:18] <dbaupp> gah don't look at the js... your eyes'll bleed
[14:15:28] <dbaupp> (i think you should clear your cache ;P )
[14:15:37] <cmr> http://i.imgur.com/oRmRRv3.png
[14:15:58] <dbaupp> hm
[14:16:30] <dbaupp> (it works here in firefox nightly and chrome-something :/ )
[14:16:51] <kimundi> no zoom in chrome here
[14:17:03] <dbaupp> kimundi: platform?
[14:17:12] <kimundi> win7x64
[14:17:21] <cmr> no zoom in chromium here either
[14:17:32] <dbaupp> cmr: you're windows too, right?
[14:17:36] <doener> no zoom in iceweasel/firefox 22 on debian sid here either
[14:17:37] <cmr> linux x64
[14:17:43] <dbaupp> :(
[14:17:53] <dbaupp> why is it working for me...
[14:18:08] <Blei> zoom happening, latest firefox, linux x64
[14:18:53] <dbaupp> cmr, doener, kimundi: could you open the console and scroll around on the graphs?
[14:19:06] <cmr> dbaupp: doesn't say anthing
[14:19:15] * dbaupp sighs
[14:19:21] <cmr> oh hey it works in chromium now
[14:19:28] <dbaupp> \o/
[14:19:33] * kimundi doesn't know how to do that :P
[14:19:35] <cmr> And firefox!
[14:19:39] <engla> my updated Deque changes need review. https://github.com/mozilla/rust/pull/7562 
[14:19:43] <cmr> that was weird :\
[14:19:58] <dbaupp> kimundi: try ctrl-shift-r, maybe?
[14:20:00] *** Quits: jviereck (Adium@moz-AA038B02.dynamic.eduroam.mwn.de) (Quit: Leaving.)
[14:20:10] <dbaupp> (for a forece reload, not a console)
[14:20:31] <dbaupp> it *should* start with a week of data.
[14:20:36] <doener> works now, after a browser restart (cache clear did not help)
[14:20:45] <dbaupp> how peculiar
[14:20:53] <kimundi> after clearing the cach a second time, now it works :P
[14:21:09] <dbaupp> hm, maybe it should actually start showing the commits selected below.
[14:21:19] * dbaupp implements it
[14:21:42] <kimundi> a reset-zoom button might also be usefull ;)
[14:21:48] <cmr> it has one
[14:22:00] <dbaupp> kimundi: bottom right
[14:22:08] <engla> zoom is strange in the bottom graph. it zooms in around the cursor but zooms out from the middle.. something like that
[14:22:39] <dbaupp> engla: yeah, I noticed something like that...
[14:22:48] <dbaupp> don't know what's happening
[14:22:58] <engla> maybe the middle is the center for both in/out zoom
[14:22:58] <dbaupp> haven't debugged it yet
[14:23:03] *** Quits: SimonSapin (simon@moz-D0C2F181.zone2.bethere.co.uk) (Ping timeout)
[14:23:15] <engla> hm nope
[14:24:36] *** Quits: ssbr (ssbr@moz-141F89C6.block0.gvtc.com) (Ping timeout)
[14:24:37] <dbaupp> it's possibly because I've capped it so that you can't go below 0
[14:24:48] <dbaupp> and I'm doing it wrong
[14:24:51] * dbaupp removes that
[14:25:33] <doener> hm, I wonder why "maybe building test harness" allocates 100MB, I'd expect something around 0
[14:26:00] <cmr> doener: if you're looking at the graphs, they may not be perfectly accurate
[14:26:33] <doener> ok
[14:27:26] <cmr> although it looks like the skew doesn't matter for that one
[14:28:43] <mark_edward> for my pointer arithmetic, im getting `error: cannot provide an extension implementation for a trait not defined in this crate`
[14:28:53] <mark_edward> but std.rs is the relevant crate, right?
[14:29:04] <mark_edward> and ops and ptr are in the same crate right?
[14:29:40] <dbaupp> yes
[14:30:01] <dbaupp> how are you importing ops::Add?
[14:30:17] <mark_edward> use ops::{Add,Sub};
[14:30:31] <dbaupp> and it's complaining about Add?
[14:30:37] <mark_edward> yup
[14:31:44] <kimundi> Hm, only remaining probleme with irfy is that my screen is a ~100 pixel to narrow
[14:32:01] <dbaupp> kimundi: how wide?
[14:32:09] <kimundi> 1280
[14:32:27] <cmr> it's miserable on my netbook too, but not worth complaining about that
[14:32:37] <dbaupp> sorry :(
[14:33:02] <kimundi> don't worry :)
[14:33:11] <dbaupp> I was planning to make the sidebar move above/between/below the graphs on narrow screens... but that's tricky
[14:33:52] *** Joins: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[14:33:54] <cmr> d161e63 dc4560d d084d9e 0d7f8f7 c989b79 1ba6fa4 6c45160 8761b1f 3fc0524 c5fea4a 96f6f29 682afca e946b4f f254d11 are the next commits that will be benched, whoever's interested
[14:34:42] * dbaupp is
[14:35:16] <dbaupp> cmr: did you fix the thing with LLVM not building right?
[14:35:21] <cmr> dbaupp: yes
[14:35:25] <cmr> by running make twice
[14:35:33] <dbaupp> heh
[14:35:54] <cmr> Does #[deriving(Clone)] on a struct Foo<T> only implement it for T:Clone?
[14:36:33] <SiegeLord> rusti: #[deriving_self(owned)] trait T { fn test(); }
[14:36:34] -rusti- ()
[14:36:45] <SiegeLord> rusti: #[abracadabra(owned)] trait T { fn test(); }
[14:36:46] -rusti- ()
[14:36:53] <engla> not sure how it is exactly. Does that even allow you to make a Foo without clonable T?
[14:36:57] <kimundi> dbaupp:  how about making the size of the two diagrams adjustable? Then anyone who has a problem with the default size can just fix it manually :)
[14:37:00] <SiegeLord> Err... I guess it doesn't care for invalid attributes?
[14:37:04] <cmr> SiegeLord: nope
[14:37:21] <SiegeLord> That's... worrying
[14:37:23] <dbaupp> kimundi: neat
[14:37:32] <dbaupp> kimundi: might be tricky though
[14:37:38] <cmr> engla: well it'd be impl<T: Clone> Clone for Foo<T>
[14:38:00] <dbaupp> kimundi: I could just trim off a few pixels though too... could you give me screenshot? :)
[14:38:21] <cmr> #[doc = "Automatically derived."]
[14:38:23] <cmr> pub impl <T: ::std::clone::Clone> ::std::clone::Clone for Foo<T> {
[14:38:25] <cmr> yes
[14:39:04] <engla> cmr: it does derive it for just T: Clone
[14:39:29] <kimundi> dbaupp: Meh, don't bother fixing it just for me. It's not like I use irfy in any way :P
[14:39:50] <dbaupp> kimundi: no!
[14:40:02] <dbaupp> kimundi: ~10% of visitors are on a 1280 screen :)
[14:40:03] *** Quits: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Ping timeout)
[14:40:15] <kimundi> okay then xD
[14:40:36] <engla> are you checking screen size or window size?
[14:40:37] <cmr> dbaupp: firefox has a "responsive mode" that lets you set the res of the viewport
[14:41:09] <dbaupp> engla: dunno, whatever the analytics thing does automatically
[14:41:21] <dbaupp> engla: screen, apparently
[14:41:56] <dbaupp> cmr: oh, right! forgot about that
[14:42:21] <dbaupp> it looks like trimming like 50px of would make it nicer.
[14:42:25] <engla> cmr: thanks for reviewing!
[14:42:51] <cmr> engla: np
[14:43:05] <kimundi> Apparently to late, but anyway: http://imgur.com/8udjANr
[14:43:17] <cmr> engla: thanks for including benchmarks <3
[14:43:57] <engla> the bench runner is mostly awesome
[14:47:12] *** Joins: sankha93 (Instantbir@E1916E3C.9A5EC03F.8B6C1D65.IP)
[14:48:09] <dbaupp> kimundi: not too late :)
[14:48:32] <dbaupp> (I wanted to make sure what I was seeing matched what a user sees :) )
[14:50:00] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Connection reset by peer)
[14:50:04] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[14:56:26] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[14:57:38] <cmr> reading C code sets me on edge now
[14:57:52] <cmr> thanks, rust :p
[15:10:21] <dbaupp> rusti: struct Foo; std::sys::size_of::<Foo>();
[15:10:22] -rusti- ()
[15:10:29] <cmr> semicolon
[15:10:30] <dbaupp> rusti: struct Foo; std::sys::size_of::<Foo>()
[15:10:31] -rusti- 0
[15:10:38] <dbaupp> I think that's the problem
[15:12:27] <dbaupp> rusti: struct Foo; std::sys::nonzero_size_of::<Foo>()
[15:12:28] -rusti- 1
[15:14:16] *** Joins: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr)
[15:14:30] <cmr> nonzero_size_of seems dubiously useful
[15:15:31] <dbaupp> it's required for certain things
[15:16:17] <engla> it's used by vec
[15:16:25] *** Joins: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[15:16:34] <glinscott> dbaupp: pong
[15:18:25] <dbaupp> glinscott: I was just going to suggest that you could put your two performance patches into the one pr, so that they land faster :)
[15:18:51] *** Joins: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[15:19:04] <glinscott> dbaupp: oh, sure thing.  one commit or two?
[15:19:07] <dbaupp> cmr: aatch's ast stuff bounced :( he forgot the tests in libsyntax
[15:19:13] <dbaupp> glinscott: two's probably better
[15:20:08] <dbaupp> glinscott: (e.g. just putting the space one in with the JSON one.)
[15:20:32] <glinscott> dbaupp: ok, sure.  when pushing now, should i rebase against master?
[15:21:06] *** Quits: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Client exited)
[15:21:06] <dbaupp> glinscott: probably not much point
[15:21:20] <mark_edward> dbaupp: i seem to have a weird problem
[15:21:30] <dbaupp> mark_edward: yup
[15:21:33] <dbaupp> ?
[15:21:50] <mark_edward> im writing the pointer offset stuff, and i think what's happening is that when i do make check-stage1-std
[15:22:23] <mark_edward> the compiler that's compiling has the Add and Sub traits for pointers in its version of std
[15:22:50] <mark_edward> and is trying to compile std again with the implementation of Add and Sub
[15:22:59] <dbaupp> yup, you have to put them behind a #[cfg(not(test))] flag
[15:23:09] <mark_edward> and that's also why it's saying that it can't reimplement the traits
[15:23:20] <dbaupp> (look how str and vec do it, grep for `mod traits`)
[15:23:20] <mark_edward> oh tthanks! what does that do?
[15:23:25] *** Quits: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net) (Ping timeout)
[15:23:57] <glinscott> dbaupp: ok, thanks.  pull requests merged
[15:23:59] *** Joins: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com)
[15:24:22] <dbaupp> mark_edward: it is a conditional compilation instruction, and so it removes whatever it's attached to if `not(test)` isn't true (i.e. if it's being build as a test-suite.)
[15:24:51] <dbaupp> glinscott: cool!
[15:25:26] <mark_edward> i thought cfg directives conditionally enabled what they're applied to
[15:25:32] <dbaupp> glinscott: (re-r'd if for you)
[15:25:42] <dbaupp> mark_edward: yep, that's a better way to say it
[15:25:57] * dbaupp had too many double negatives
[15:26:28] <glinscott> dbaupp: thanks :)  still some nice wins to have there, should have another pull request soon
[15:26:40] <dbaupp> yay!
[15:26:40] <mark_edward> oh, i get it now. thanks dbaupp! first you save my life with that git stuff, and now more help
[15:27:11] <dbaupp> glinscott: on json, you mean?
[15:27:16] <dbaupp> mark_edward: heh :)
[15:28:37] <glinscott> dbaupp: yes, json, and unicode parsing.  right now the range binary search code is not optimized for ascii
[15:29:01] *** Joins: relistan (relistan@moz-2DE8112B.cable.virginmedia.com)
[15:29:10] <dbaupp> awesome!
[15:29:12] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[15:29:12] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/9fyKPA
[15:29:12] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[15:30:02] <dbaupp> (if you're editing unicode.rs, you should do it via etc/unicode.py, btw;)
[15:30:11] <dbaupp> s/;//
[15:30:57] <dbaupp> (well, at least, when you commit the changes, make sure they're also there.)
[15:32:11] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[15:32:11] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/Ag0KDw
[15:32:11] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[15:32:13] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[15:32:13] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/YpiO-w
[15:32:13] <ghrust> 13rust/06auto 14bc6848d 15Jens Nockert: Adds conditional byteswapping intrinsics...
[15:32:13] <ghrust> 13rust/06auto 143e933b1 15bors: auto merge of #7194 : jensnockert/rust/endian, r=cmr...
[15:32:13] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[15:32:20] <cmr> slow down bors
[15:32:44] <dbaupp> at least he's being sane now
[15:32:55] <cmr> this is true
[15:33:15] *** Joins: Ms2ger (Ms2ger@moz-E9883900.access.telenet.be)
[15:33:32] <dbaupp> there was a half a day where he decided to test tens of pull requests at once
[15:33:35] <dbaupp> that was fun.
[15:33:38] <cmr> O_o
[15:34:15] <relistan> Rust newbie here looking for some help with the foreign function interface on 0.6 if anyone has a sec. Would be much appreciated.
[15:34:28] <cmr> relistan: why are you using 0.6?
[15:34:52] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[15:34:53] <dbaupp> cmr: well, it was more 3 pull requests, many times each.
[15:34:57] <relistan> no homebrew for 0.7 yet on OSX and just started playing with it last week before 0.7 came out
[15:35:04] *** Joins: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net)
[15:35:16] <relistan> but if that's a non-starter, I'll go get that working instead
[15:35:52] <dbaupp> I don't think the FFI changed a lot, so we can probably still help you :)
[15:35:54] *** Quits: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca) (Connection reset by peer)
[15:36:31] <cmr> 0.7 is much improved in countless ways, less pain overall, but the ffi is pretty much the same, yes
[15:36:50] <relistan> Ok, thanks much appreciated.  I know I'm doing a few things wrong here, but the specific thing that isn't working right now is that I can't seem to get a uint back from a C function
[15:37:03] <relistan> always seems to be 1
[15:37:07] <cmr> do you have code somewhere?
[15:37:15] <cmr> also, you want to be using libc::c_uint, not just uint
[15:37:18] <relistan> yeah, getting link :)
[15:37:22] <relistan> one sec
[15:38:47] <relistan> oh man, you know I spent a couple of hours on this and I go to link the code and I see what I've done wrong
[15:38:56] <relistan> thanks :)
[15:39:04] *** Quits: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com) (Quit: webber46)
[15:39:19] <dbaupp> heh, #rust is an amazing rubber duck :)
[15:39:27] <relistan> I do have a second question though
[15:39:31] <relistan> https://bitbucket.org/relistan/cryptorust/src/3f5b0e0b9be7fb2e4eefed8770993aa9ad26592b/crypto.rs?at=master#cl-45
[15:39:47] <relistan> What should I be doing here to pre-allocate  buffer to pass to the C function?
[15:40:07] <relistan> what I'm doing there is nasty
[15:40:10] <cmr> rusti: bytes!("0123456789012345678901234567890123456789")
[15:40:12] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/cCWK
[15:40:59] <relistan> ideally I just want an empty buffer of 40 bytes that I can put stuff into from the C function
[15:41:04] <cmr> Oh
[15:41:11] <dbaupp> relistan: digest = vec::from_elem(40, 0)
[15:41:21] <Ms2ger> relistan, out of interest, what did you do wrong?
[15:41:41] <relistan> ah OK, that looks better
[15:41:42] <cmr> You can use vec::with_capacity::<u8>(40) and vec::raw::to_ptr if you don't need it to be initialized
[15:42:06] <relistan> ms2ger: didn't link the right version of my c shared lib :(
[15:42:23] <relistan> dbaupp, car: thanks
[15:42:26] <relistan> cmr even
[15:42:40] <dbaupp> relistan, cmr: that requires using vec::raw::set_len(v, len) afterward too.
[15:42:47] <cmr> Ah, righty!
[15:43:56] <relistan> I'll give those a shot, thanks for that!
[15:48:23] *** Joins: BitPuffin (quassel@moz-911FB3CE.cust.tele2.se)
[15:50:23] <SiegeLord> Hmm... https://gist.github.com/SiegeLord/5940286
[15:50:38] <SiegeLord> I don't quite get that error
[15:51:03] <cmr> SiegeLord: so the rule for trait impls is you can only impl 1. Traits in your crate for any type, 2. Any trait for a type in your crate
[15:51:15] <cmr> This is so when you combine multiple crates, there are no conflicts.
[15:51:24] <cmr> (called "coherency")
[15:52:11] <SiegeLord> Hmm... so it's really hard to get these trait objects to work well then within the current rules...
[15:52:46] <cmr> I don't see why you'd need to do that though...
[15:53:00] <cmr> rusti: let x = ~1u; x (as ~ToStr).to_str()
[15:53:01] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/KKTD
[15:53:05] <SiegeLord> Most Rust code uses trait bounds
[15:53:08] <cmr> rusti: let x = ~1u; (x as ~ToStr).to_str()
[15:53:09] -rusti- ~"1"
[15:53:19] <SiegeLord> As soon as you get a trait object, you can't use most Rust code
[15:53:52] *** Joins: indirect (indirect_m@moz-22FDA25B.hsd1.ca.comcast.net)
[15:54:12] <cmr> you should talk to nmatsakis or bblum about it, they seem to be the type system afficionados
[15:54:42] <SiegeLord> I'm composing an email about it... I'm just making sure I'm not saying something horribly stupid
[15:54:58] <SiegeLord> I was going to suggest a caller-side solution, and now it's clear to me that it's incoherent:P
[15:55:35] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[16:02:55] *** Joins: tedh (tedh@moz-38ABF348.central.biz.rr.com)
[16:03:03] *** Quits: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Ping timeout)
[16:07:15] <mark_edward> have you guys thought of a convert trait?
[16:07:25] <cmr> mark_edward: that does what?
[16:07:35] <SiegeLord> rusti: let a = (1,); a.first()
[16:07:35] <cmr> trhere's https://github.com/mozilla/rust/issues/7080 if that's what you mean
[16:07:36] -rusti- <anon>:7:23: 8:5 error: type `(<VI0>)` does not implement any method in scope named `first`
[16:07:36] -rusti- <anon>:7          let a = (1,); a.first()
[16:07:36] -rusti- <anon>:8     };
[16:07:36] -rusti- error: aborting due to previous error
[16:07:37] -rusti- application terminated with error code 101
[16:08:12] <mark_edward> trait Convert<T> { fn convert(&self) -> T }
[16:08:58] <mark_edward> and then say type X implements Convert<Y>. then you can say let x: X = Y::new(); and the compiler will see that the convert trait is there
[16:09:01] <mark_edward> and do the conversion
[16:09:23] <doener> implicit conversions? ugh
[16:09:33] <cmr> Yeah implicit conversion isn't going to happen
[16:09:40] <mark_edward> it's not that implicit. 
[16:09:50] <mark_edward> you have to implement a trait for it
[16:10:07] <roo> unless someone else has already done that for you
[16:10:14] <doener> which is pretty much exactly what scala calls implicit conversion
[16:11:13] <doener> the "implicit" part is about the compiler implicitly calling that function
[16:11:22] <mark_edward> how about something more explicit.
[16:11:38] <cmr> the more explicit is Y::new().convert::<X>()
[16:11:40] <mark_edward> like having the convert trait saying how the "as" operator is used
[16:11:53] <mark_edward> that seems both convenient and explicit
[16:12:00] <cmr> That's #7080
[16:12:06] <mark_edward> let x: X = Y::new() as X;
[16:12:18] <mark_edward> there's a thing for this?
[16:12:29] <doomlord_> ::<X> ... thats a disambiguous thing right, compared to c++ 
[16:12:44] <cmr> doomlord_: yes, it's a type hint
[16:12:53] <SiegeLord> How would I get this to work:
[16:12:57] <SiegeLord> struct A(~int); let a = A(~5); let c = &a; let A(b) = *c; b
[16:13:03] <SiegeLord> rusti: struct A(~int); let a = A(~5); let c = &a; let A(b) = *c; b
[16:13:04] -rusti- <anon>:7:63: 7:65 error: cannot move out of dereference of & pointer
[16:13:04] -rusti- <anon>:7          struct A(~int); let a = A(~5); let c = &a; let A(b) = *c; b
[16:13:04] -rusti-                                                                         ^~
[16:13:04] -rusti- error: aborting due to previous error
[16:13:04] -rusti- application terminated with error code 101
[16:13:08] <engla> it's  ::<X>  where it's optional and stick to ident Type<X> when mandatory
[16:13:42] <roo>  rusti: struct A(~int); let a = A(~5); let c = &a; let A(ref b) = *c; b
[16:14:00] <roo> rusti: struct A(~int); let a = A(~5); let c = &a; let A(ref b) = *c; b
[16:14:01] -rusti- <anon>:7:67: 7:69 error: cannot move out of dereference of & pointer
[16:14:01] -rusti- <anon>:7          struct A(~int); let a = A(~5); let c = &a; let A(ref b) = *c; b
[16:14:01] -rusti-                                                                             ^~
[16:14:01] -rusti- error: aborting due to previous error
[16:14:02] -rusti- application terminated with error code 101
[16:14:08] <roo> oh, bleh
[16:15:04] <cmr> SiegeLord: it's not possible, and it'd break the type system to move out of a &T, it'd invalidate other pointers to that T
[16:15:14] <mark_edward> that issue seems complex
[16:15:39] <SiegeLord> cmr, so the contents of a are completely inaccessible through c?
[16:16:08] <engla> you can pattern match just like in match.   let A(ref b) = *c
[16:16:18] <engla> I don't know if the let pattern match was fixed yet
[16:16:22] <engla> if it wasn't, use match
[16:16:42] <roo> rusti: struct A(~int);let a = A(~5);let c = &a; let &A(ref b) = c; b
[16:16:44] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/dDQH
[16:16:47] <roo> :D
[16:17:02] <engla> yeah probably not
[16:17:10] <SiegeLord> Oh I see, it's a bug
[16:17:12] <engla> SiegeLord: if you have a &T, you can access the contents by ref
[16:17:21] <SiegeLord> I tried let, but not match
[16:17:26] <mark_edward> why not two traits, a Cast and Transform. Transform is for say the ~str -> ~u8 case, where you consum the input
[16:17:42] <cmr> rusti: struct A(~int); let a = A(~5); let c = &a; let b = copy *c; *b
[16:17:43] -rusti- ~5
[16:17:59] <cmr> SiegeLord: the only way to move out of it is to copy
[16:18:00] <mark_edward> cmr: could the compiler figure out which is needed? seems similar to figuring out if you can move or copy
[16:18:08] <cmr> rusti: struct A(~int); let a = A(~5); let c = &a; let b = &*c; b
[16:18:09] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/UPfb
[16:18:24] <SiegeLord> So I guess you could create a syntax extension that takes a trait and creates a new type struct that implements that trait for a trait object
[16:18:24] <cmr> rusti: struct A(~int); let a = A(~5); let c = &a; let b = &*c; println(fmt!("%?", b))
[16:18:26] -rusti- &{__field__: ~5}
[16:18:26] -rusti- ()
[16:18:42] <SiegeLord> Kind of awkward though
[16:20:02] <cmr> yeah
[16:21:26] <SiegeLord> Although... I wonder if this works
[16:21:43] <SiegeLord> rusti: || { struct A(int); A(0) }
[16:21:55] <SiegeLord> rusti: (|| { struct A(int); A(0) })()
[16:21:56] -rusti- {__field__: 0}
[16:22:12] <SiegeLord> rusti: (|| { struct A{a : int}; A{a : 0} })()
[16:22:13] -rusti- {a: 0}
[16:22:24] *** Joins: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[16:22:24] <SiegeLord> So you can create a type inside a closure and return it
[16:22:32] <SiegeLord> One of those stupid voldermort types
[16:23:08] <roo> lol
[16:23:56] <cmr> rusti:  (|| { struct A{a : int}; A{a : 0} })().a
[16:23:57] -rusti- 0
[16:24:00] <cmr> huh
[16:24:18] <roo> its handy if you are working with trait objects. You create the type, impl it for the trait, and return a trait object. idk about otherwise.
[16:25:55] <SiegeLord> roo: You mean you've done it before?
[16:26:00] <SiegeLord> It's literally what I'm doing now
[16:26:13] <roo> yes, i do this with my trait-object closure stuff
[16:26:15] <engla> it was like that for the Sha1 code
[16:26:21] *** Joins: SimonSapin (simon@moz-D0C2F181.zone2.bethere.co.uk)
[16:26:42] <SiegeLord> Well, that's an okay solution... because this can be wrapped in a self-contained macro
[16:27:01] <roo> yep
[16:28:14] <SiegeLord> Like... trait_bound_fn(trait_obj_trait!(x : Trait))
[16:28:18] <SiegeLord> Or something like that
[16:28:25] *** Quits: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Ping timeout)
[16:28:28] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[16:28:41] <SiegeLord> It probably generates lots of duplicate trait implementations though... but maybe llvm can clean those up?
[16:28:57] *** Quits: relistan (relistan@moz-2DE8112B.cable.virginmedia.com) (Quit: relistan)
[16:29:06] <cmr> don't rely on llvm too heavily with closures
[16:29:18] <cmr> closure codegen is awful
[16:29:58] <roo> https://github.com/jessopher/rust-goodies/blob/master/once_closures.rs i am implementing my own closures with them, if that wasnt clear 
[16:30:16] <roo> not using rust closures
[16:30:30] <engla> nice
[16:31:15] <engla> I've got one like that too, but no macros for syntax
[16:31:40] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[16:32:02] <roo> yeah, the macro doesn't do anything to magical, composing them is still really verbose
[16:32:50] *** Joins: roo_ (jesse.rudo@moz-B7585E4C.dynamic.ip.windstream.net)
[16:33:51] *** Quits: roo (jesse.rudo@moz-B7585E4C.dynamic.ip.windstream.net) (Ping timeout)
[16:33:59] <SiegeLord> I guess I still would want to have borrowed trait objects working before this becomes useful
[16:34:41] <SiegeLord> Otherwise you're replacing template bloat with a heap allocation... out the pan and into the fire
[16:34:44] *** Quits: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr) (Quit: pyrac)
[16:35:42] *** roo_ is now known as roo
[16:36:10] <cmr> Before 1.0 I'd like to bring back the feature whereby trait bounds can be compiled to use trait objects rather than static dispatch
[16:36:20] <cmr> way too early for that though
[16:38:28] <SiegeLord> That'd work too
[16:39:00] <dbaupp> cmr: https://gist.github.com/huonw/5940437
[16:39:51] <cmr> dbaupp: pull mozilla master, l21
[16:40:35] <cmr> dbaupp: ideally it would only select bors merges.
[16:41:20] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[16:41:22] *** Joins: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr)
[16:41:22] *** sam113101 is now known as sam113101_afk
[16:42:49] <cmr> random commits between bors merges aren't always winners
[16:43:05] <dbaupp> I believe it's tracking the master branch
[16:43:35] *** Joins: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca)
[16:43:47] <dbaupp> so it's essentially only bors commits + things people push directly to master
[16:44:19] <cmr> oh hm, ~ is parent commit right?
[16:44:36] <dbaupp> right, ~n = nth parent commit
[16:45:14] <dbaupp> I can make it use `git log --author=bors -n=1 something something`, if you want? :)
[16:45:31] <cmr> no, you're right
[16:45:39] <cmr> I was just confused how it actually worked
[16:45:51] <cmr> thanks <3
[16:46:25] *** Quits: Earnestly (earnest@2A2BF8F5.321FA5E6.BFD1ABFD.IP) (Ping timeout)
[16:46:26] <dbaupp> (there are some commits on master that don't build, but in theory it shouldn't get stuck in an infinite loop of failed builds. hopefully L50 is enough to stop it.)
[16:46:30] <dbaupp> np :)
[16:46:36] * dbaupp wants moar data
[16:46:52] <cmr> dbaupp: it's doing some merges that were when we used jemalloc
[16:46:56] <cmr> so that should be exciting
[16:47:17] <dbaupp> it was normally the test-suite that failed, right?
[16:47:23] <cmr> yup
[16:47:32] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[16:47:44] *** Joins: Earnestly (earnest@2A2BF8F5.321FA5E6.BFD1ABFD.IP)
[16:48:49] *** Joins: robert (robertknig@moz-B6DD6E0B.range86-166.btcentralplus.com)
[16:51:43] <dbaupp> cmr: feel free to modify (or not) as much as you need... I'm off to sleep.
[16:54:20] <cmr> 'night
[16:57:44] <cmr> doener: you checking out the anagram regression?
[16:58:04] <doomlord_> trait objects are buggy ... but enums can implement runtime polymorphism with match, and that is stable ?
[16:58:29] <cmr> doomlord_: yup
[17:00:47] <doomlord_> the work in games i've done has avoided vtables anyway :) .. sort by type
[17:00:59] <doomlord_> 'data-oriented programming' 
[17:01:29] *** Quits: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net) (Ping timeout)
[17:01:36] <doomlord_> but i think gui frameworks like vtables
[17:02:15] *** Quits: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca) (Ping timeout)
[17:05:37] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[17:07:38] <cmr> doomlord_: you have much more experience than I, is there anything important I missed in https://github.com/mozilla/rust/issues/7532 ?
[17:08:32] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[17:09:41] <doomlord_> recently its seemed that performance is more about whole program issues... but i can see you need to stress individual features
[17:10:25] <cmr> whole-program issues are important, but we have no quantification of rust performance right now..
[17:10:38] <doomlord_> i would personally be most interested in the ability to show rust can generate code similar to what a C/C++ programmer is used to ; i've heard talk of that here
[17:10:44] <doomlord_> ok
[17:10:51] <cmr> yeah, graydon is working on IR tests for that
[17:10:54] <doomlord_> to give you an example:
[17:11:13] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[17:11:13] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/YpiO-w
[17:11:13] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[17:11:14] <doomlord_> ^^yeah that sounds perfect, and will go a long way to convincing skeptics that C/C++ can be matched
[17:11:44] <doomlord_> a C/C++ programmer feels that performance is in his hands, not the compilers
[17:11:57] <doomlord_> if the program is slow its because of his selection of techniques
[17:12:01] <doomlord_> and he can fix it
[17:12:30] <doomlord_> to give you an example of why i was slightly reserved about isolation tests:-
[17:12:48] <doomlord_> i've seen people benchmark virtual functioin calls in C++ , then conclude "virtual  function calls are fast"
[17:12:57] <doomlord_> then they go on to architect a program around virtuals...
[17:13:11] <doomlord_> ... and the program is slow, due to cache misses / pipeline stalls
[17:13:16] <cmr> right
[17:13:47] <doomlord_> of course you need these isolation tests to verify the compiler is doing the right thing.. not emiting dead code..
[17:14:10] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[17:14:10] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/UTzHOQ
[17:14:10] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[17:14:11] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[17:14:11] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/xmi4zA
[17:14:11] <ghrust> 13rust/06auto 14866a5b1 15Michael Woerister: Added support for struct-like enum variants in middle::ty::enum_variants().
[17:14:11] <ghrust> 13rust/06auto 14b6a2364 15bors: auto merge of #7557 : michaelwoerister/rust/enum_structs, r=pcwalton...
[17:14:12] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[17:14:45] <doomlord_> I suspect a lot of this will come down to how much inlining it can do ... (and then how good the compiler is at deciding when to inline)
[17:14:55] <doomlord_> special cases for pattern matching..
[17:15:22] <cmr> can always #[inline(never)] to defeat that
[17:17:15] <doomlord_> the performance stuff i've done has been pretty well controlled tbh..
[17:17:51] <doomlord_> eg simplifying code out alot, with the assumption "dynamic memory allocation is slow (dont do it in time-critical code)" etc ..
[17:17:57] <doomlord_> on previous generation consoles :)
[17:18:04] <doomlord_> 360/ps3 with their inline processors
[17:18:09] <doomlord_> in-order processors sorry
[17:18:47] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[17:19:00] <doomlord_> "Data structure manipulation (vec benchmarks etc, similar to what core-map and friends do)" <<< a game engine wouldn't have done anything so complex probably
[17:19:22] <doomlord_> game optimization was about preconditioning data to make the runtime as simple as possible
[17:19:36] <cmr> sounds tedious
[17:19:38] *** Quits: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net) (Ping timeout)
[17:20:41] <doomlord_> i enjoyed the low level detail, when in the context of graphics (how much can you do in a video frame) .. when it was visible
[17:21:04] <doomlord_> funny what can make software interesting or not
[17:21:32] *** Quits: BitPuffin (quassel@moz-911FB3CE.cust.tele2.se) (Ping timeout)
[17:21:34] *** Joins: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net)
[17:21:45] *** Quits: Houm (Houm@moz-25669AA8.fbx.proxad.net) (Ping timeout)
[17:22:00] <doomlord_> http://gamedev.stackexchange.com/questions/8024/how-to-apply-data-oriented-design-with-object-oriented-programming
[17:22:14] <doomlord_> ^^^ C++ is  basically a set of red herrings for game programming , lol.
[17:22:32] <doomlord_> but its classes are good for low level types like maths
[17:22:48] *** Joins: Houm (Houm@moz-25669AA8.fbx.proxad.net)
[17:27:03] *** Joins: posco (oscarboyki@moz-4CC6D00A.hsd1.ca.comcast.net)
[17:32:41] *** Quits: feduser (feduser@D2ACAA82.1E16A669.799BF54A.IP) (Ping timeout)
[17:34:12] *** Quits: txdv (quassel@966F3542.3BA477DA.14C26596.IP) (Ping timeout)
[17:34:33] *** Joins: txdv (quassel@966F3542.3BA477DA.14C26596.IP)
[17:34:56] *** Joins: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com)
[17:38:44] *** Quits: SimonSapin (simon@moz-D0C2F181.zone2.bethere.co.uk) (Ping timeout)
[17:45:41] *** Joins: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com)
[17:48:44] *** Quits: Blei (philipp@moz-650B9C6A.cust.bluewin.ch) (Quit: WeeChat 0.4.1)
[17:53:45] *** Quits: indirect (indirect_m@moz-22FDA25B.hsd1.ca.comcast.net) (Ping timeout)
[17:56:57] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[17:57:07] *** Joins: indirect (indirect_m@moz-22FDA25B.hsd1.ca.comcast.net)
[17:57:21] <ross> that stackexchange question is funny
[17:57:38] *** Joins: SimonSapin (simon@moz-D0C2F181.zone2.bethere.co.uk)
[18:00:27] *** Joins: relistan (relistan@moz-2DE8112B.cable.virginmedia.com)
[18:10:19] *** Quits: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr) (Quit: pyrac)
[18:10:32] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[18:11:01] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[18:17:20] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[18:20:45] <km> I'm calling a C function with two args, a pointer and an i32, from Rust. When I break on the C function in GDB, I see that the pointer I passed from Rust is now in the second argument, and there's another address as the first argument. Any ideas how that could happen?
[18:21:45] <km> http://hastebin.com/vodexosodo.rs
[18:24:11] *** Quits: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com) (Quit: webber46)
[18:26:39] *** Quits: robert (robertknig@moz-B6DD6E0B.range86-166.btcentralplus.com) (Ping timeout)
[18:27:36] *** Quits: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com) (Ping timeout)
[18:28:15] *** Joins: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net)
[18:28:18] <cmr> km: rust 0.7?
[18:28:33] <km> cmr: yeah
[18:31:28] *** Joins: askalski (akuda@224DEFBE.C5119786.49D09143.IP)
[18:31:55] <bblum> are our heap pointers guaranteed to have some alignment?
[18:32:10] <cmr> bblum: 16-byte, as guaranteed by malloc
[18:32:16] <bblum> all platforms?
[18:32:22] <cmr> dunno about that
[18:32:38] <cmr> km: it's working correctly for me on master
[18:34:16] <cmr> km: only way I could see that happening is if it were calling the extern fn as a closure, and passing an environment in the first arg... but that shouldn't happen, it'd be a huge bug
[18:35:40] *** sam113101_afk is now known as sam113101
[18:36:51] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[18:37:11] <engla> malloc alignment depends on the platform, it's 8 bytes on some
[18:37:40] <cmr> http://www.gnu.org/software/libc/manual/html_node/Aligned-Memory-Blocks.html
[18:37:52] <cmr> seems it's 8 bytes on 32bit, 16 on 64bit, for glibc
[18:38:00] *** Joins: ski (md9slj@moz-B0548857.ce.chalmers.se)
[18:38:18] <ross> I had a problem where I was passing a u32 to a C library function (as a uint32_t or whatever is in libc) and it was being shifted over by 8 bits. but I didn't use any tooling to 100% verify it. it's still on my todo list
[18:38:31] <cmr> "malloc is guaranteed to return memory that's aligned on a boundary that's suitable for storing any object that could fit in the amount of memory that's allocated" is all windows says about it, http://msdn.microsoft.com/en-us/library/vstudio/ycsb6wwf.aspx
[18:38:45] <SiegeLord> cmr, Just curious, are you an intern at Mozilla or just a concerned hacker?
[18:38:54] <cmr> SiegeLord: concerned hacker
[18:39:00] <cmr> interns don't work on weekends :p
[18:39:11] <SiegeLord> Maybe you're extra dedicated ;)
[18:39:41] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[18:40:25] *** Quits: askalski (akuda@224DEFBE.C5119786.49D09143.IP) (Input/output error)
[18:41:17] *** Quits: [o__o] (~o__o@moz-24EBFAC7.me) (Ping timeout)
[18:43:16] *** Joins: vilonis (vilonis@moz-EE5D17ED.ph.ph.cox.net)
[18:43:41] *** Joins: [o__o] (~o__o@moz-24EBFAC7.me)
[18:44:56] *** Quits: Sorella (queen@78575561.924F2739.95C8B7C6.IP) (Quit: (quit))
[18:46:23] *** Joins: vk (vk@2AAA6DD0.B568D26C.93B001FA.IP)
[18:48:57] *** Quits: vk (vk@2AAA6DD0.B568D26C.93B001FA.IP) (Quit: vk)
[18:49:08] *** Joins: vk (vk@2AAA6DD0.B568D26C.93B001FA.IP)
[18:51:53] *** Joins: krdln (Mibbit@moz-6F8A8560.dynamic.chello.pl)
[18:53:01] *** Joins: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr)
[18:53:28] *** Joins: untitaker (yaaic@moz-D515021E.adsl.highway.telekom.at)
[18:53:55] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[18:53:55] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Connection reset by peer)
[18:54:09] <untitaker> hello, is there a way to convert ~str to &str, or something that is accepted by DuplexStream.send?
[18:54:37] <cmr> rusti: let x = ~"foobar"; x.as_slice()
[18:54:39] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/bNWi
[18:54:44] <cmr> rusti: let x = ~"foobar"; println(fmt!("%?", x.as_slice()))
[18:54:46] -rusti- "foobar"
[18:54:46] -rusti- ()
[18:54:51] <cmr> untitaker: ^ that
[18:55:06] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[18:55:11] <cmr> DuplexStream shouldn't be accepting &str though
[18:55:40] <untitaker> ill check on the messages again
[18:55:57] <untitaker> yeah it does :S
[18:56:08] <cmr> what's the code and the error message?
[18:56:11] <cmr> (also, rust 0.7?)
[18:56:19] <untitaker> yes 0.7
[18:56:38] <untitaker> im on the phone please be patient :S
[18:56:47] <cmr> it's ok :)
[18:57:17] <untitaker> expected `&'static str` but found `&str`
[18:58:05] <untitaker> when doing pipe.send(to_str(123))
[18:58:17] <cmr> Ok, so &str and &'static str are different. &'static str is a constant string, it's the type of a string literal. &str is a slice into an existing string.
[18:58:29] <untitaker> mhm ok
[18:58:30] <cmr> you can call the to_owned() method to get a ~str from a &str
[18:58:43] <cmr> (~str are sendable across tasks, &str aren't except &'static str)
[18:59:29] <untitaker> hmm that's kinda contradicting my tale so far
[18:59:44] <untitaker> well
[19:00:02] <untitaker> at least i can't deref ~
[19:00:27] <cmr> you cannot deref ~str, no
[19:00:40] <cmr> you can't deref &str either though, I think
[19:00:49] <untitaker> no idea
[19:00:56] <cmr> rusti: let x = "foo"; *x
[19:00:57] -rusti- <anon>:7:24: 7:26 error: type &'static str cannot be dereferenced
[19:00:57] -rusti- <anon>:7          let x = "foo"; *x
[19:00:57] -rusti-                                  ^~
[19:00:57] -rusti- error: aborting due to previous error
[19:00:58] -rusti- application terminated with error code 101
[19:01:38] <untitaker> rusti: println("i am dumb")
[19:01:39] -rusti- i am dumb
[19:01:39] -rusti- ()
[19:01:57] <untitaker> ok
[19:03:19] <untitaker> uhm, so .send doesn't accept owned pointers...?
[19:03:24] <cmr> It should
[19:03:31] <cmr> Can you pastebin all of your code?
[19:03:37] <untitaker> ugh
[19:03:41] <untitaker> yeah hang on
[19:04:02] <untitaker> i have network problems on that laply
[19:04:18] *** Joins: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[19:05:20] *** Quits: ross (ross@moz-8A84103E.br.br.cox.net) (Quit: )
[19:05:47] <untitaker> http://sprunge.us/FPXS
[19:06:03] <untitaker> fizzbuzz on roflscale
[19:07:17] <untitaker> line 21
[19:07:17] <cmr> Ah, it's because you're using DuplexStream<&str, &str>
[19:07:31] <cmr> And the only Sendable &str is &'static str
[19:07:37] <untitaker> i'd have used str if it allowed me
[19:07:40] <cmr> which isn't useful because you're using to_str
[19:07:42] <cmr> use ~str
[19:07:47] <untitaker> ok
[19:08:06] <cmr> but you need to use ~"FizzBuzz" and such
[19:08:14] <cmr> (also, use value.to_str(), not the to_str function)
[19:09:07] *** Quits: BizarreCake (BizarreCak@51AA6B33.6D202491.34A7550B.IP) (Client exited)
[19:09:33] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[19:09:53] <untitaker> lol
[19:09:57] <untitaker> works
[19:10:07] <untitaker> thanks!
[19:10:10] <cmr> np
[19:10:39] <untitaker> so what is the exact diff between these two pointer types?
[19:11:16] <cmr> ~T is owned, if you have and use a ~T you can be certain you have the only pointer to that object.
[19:11:31] <cmr> &T is borrowed, there can be multiple pointers to the object, but all of them are immutable
[19:11:32] *** Joins: cowboyd (cowboyd@moz-216282E7.sw.biz.rr.com)
[19:11:37] <cmr> it's part of the memory safety story
[19:12:30] <untitaker> cmr: what would the certainity of having the only pointer help?
[19:12:52] <cmr> untitaker: it means you can mutate it, delete it, etc, without causing corruption elsewhere
[19:13:09] <untitaker> (btw i only learn rust because smarter people told me so, not because i write concurrent code)
[19:13:54] <cmr> untitaker: Rust's type system entirely eliminates data races
[19:14:02] *** Quits: dju (dju@moz-83BD5EC.dmz.me) (Quit: ZNC - http://znc.in)
[19:14:21] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Client exited)
[19:14:38] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[19:14:53] <untitaker> cwr: And sending a pointer through DuplexStream copies the pointer, right?
[19:14:58] <cmr> untitaker: nope
[19:16:28] <untitaker> I think i don't even get pointers in C
[19:16:37] <AutomatedTester> are there any plans for compilations to show all errors in a file
[19:16:57] <cmr> AutomatedTester: not generally possible
[19:16:59] *** Joins: dwhyte (dwhyte@ED9190FB.B72E355F.7BF4A4B0.IP)
[19:17:26] <AutomatedTester> cmr: fair enough
[19:17:32] <engla> untitaker: i guess you'll learn with time.. I always need time to learn new abstractions
[19:17:42] <cmr> there are a few bugs in this area, but for the most part, rust bails out early rather than attempting to continue but give potentially *wrong* error messages
[19:18:37] <untitaker> in C... if i have a func that looks like lel(&str foo), that does mean that the pointer is copied?
[19:18:52] <untitaker> or not even there...?
[19:19:02] <cmr> untitaker: well what do you mean by "the pointer is copied"?
[19:19:19] <untitaker> cwr: in memory
[19:19:20] <AutomatedTester> cmr: I am not complaining since my koans that I am building its perfect since each issue needs to be fixed as part of the koan
[19:19:42] <cmr> untitaker: yes, then
[19:19:51] <untitaker> cwr: so the memory address for the string gets saved multiple times
[19:20:00] <cmr> yes
[19:20:11] <untitaker> cwr: What would be the equiv of this in rust?
[19:20:14] *** Joins: dylukes (dylukes@moz-13611DF9.hsd1.ma.comcast.net)
[19:20:32] <cmr> untitaker: lel(foo: &str)
[19:20:45] <cmr> it's different than the C lel(char *foo), though
[19:20:50] *** Joins: dju (dju@moz-83BD5EC.dmz.me)
[19:21:00] <cmr> in Rust you cannot mutate or modify the value that is pointed to
[19:21:44] <cmr> If you want that, you can use lel(foo: &mut str), but then it is guaranteed that when you pass a pointer to lel, it is the only pointer to that value.
[19:21:54] <cmr> so it can safely mutate it
[19:22:12] <untitaker> hmm i think my C func sig above should've looked like lel(str &foo)
[19:22:25] <cmr> no, C doesn't have & in function signatures
[19:22:30] <cmr> nor a str type
[19:22:40] <untitaker> ahaha fuck me
[19:25:07] <untitaker> ok since there's only chars in C let's try with single ints
[19:25:19] <untitaker> without arrays etc
[19:25:27] <cmr> ok
[19:25:38] <untitaker> i want to have a func that takes a pointer to an int
[19:25:41] <cmr> right
[19:25:50] <untitaker> C: lel(int *foo)
[19:25:51] <untitaker> ?
[19:25:53] <cmr> yes
[19:26:14] <untitaker> rust: lel(foo: &int) ?
[19:26:27] <AutomatedTester> is a vector map analogous to list comprehensions in python?
[19:26:32] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[19:26:41] <engla> partly
[19:26:52] <cmr> list comprehensions are a lot more powerful and concise though
[19:27:21] <cmr> untitaker: yes, but once again, it's an immutable pointer, you cannot mutate the pointed-at value
[19:27:37] <cmr> (in C, *foo += 1 is valid, in rust, *foo += 1 would be invalid)
[19:27:51] <untitaker> cmr: yeah, i meant &/~
[19:28:00] <engla> yes it should be &mut int   to match the C
[19:28:04] <engla> C is mutable by default
[19:28:33] <cmr> there's not really a point to ~int, it'd be useless indirection
[19:30:02] <engla> and the boxed ints are huge :)
[19:30:38] <engla> AutomatedTester: most of the higher order functions (similar to map) have moved to iterators
[19:31:21] <AutomatedTester> engla: ok cool
[19:32:57] <kimundi> untitaker: It's probably a bit confusing to think of ~ and & as "just two pointers", they really have quite different reason for existance.
[19:33:33] <untitaker> kimundi they can be unboxed the same way :S
[19:34:24] <cmr> untitaker: not true, you can do a lot more with a ~ than a &
[19:34:36] <cmr> like move out of it
[19:34:52] <kimundi> A ~T is basically a handle to some heap allocated memory, (compared to a bare T, wich lives on the stack). Because of this, there can only ever be one ~-ptr to the same memory location, because the ~ ptr is responsible for cleaning up the memory when it goes out of scope
[19:36:13] <kimundi> Basically, a ~ is for "I want to create and store this object somewhere that can survive the current function."
[19:36:30] <untitaker> and & uses some sort of gc?
[19:36:35] <cmr> no, it doesn't use anything
[19:36:39] <kimundi> A & on the other hand does ONLD reference memory
[19:36:50] <cmr> it's statically verified to be correct
[19:36:54] <cmr> @ uses GC
[19:37:05] <cmr> (the mystical 3rd pointer type)
[19:37:07] <kimundi> It has NO influence about what happens with the memory it points at
[19:37:08] *** Quits: dylukes (dylukes@moz-13611DF9.hsd1.ma.comcast.net) (Quit: Computer has gone to sleep.)
[19:37:29] <untitaker> kimundi: when does the value get deleted then?
[19:37:39] <cmr> untitaker: who knows
[19:37:43] <cmr> untitaker: depends on what it points to
[19:37:55] <cmr> if it's a borrow of a @-ptr, it gets deleted when the GC decides it's ready
[19:37:57] *** Joins: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com)
[19:37:57] <untitaker> so i could manage to leak memory with it?
[19:37:59] <cmr> no
[19:38:06] <kimundi> if you have a &T, you know the memory it points at will exist, and only get cleaned up somewhere after you don't have the &T anymore
[19:38:22] <cmr> yeah that's a better explanation
[19:38:31] <cmr> untitaker: (you cannot leak unreachable memory in rust)
[19:39:02] <kimundi> A rust program wil only compile if it can prove that the memory a & points at is valid while the & exists
[19:39:04] <untitaker> cmr that sounds very much like a gc to me
[19:39:30] <untitaker> eg if i delete all muh variables in python the objects dont leak either
[19:39:53] <kimundi> This also means that a & has zero runtime overhead: No gc, no smart logic, no nothing. AT runtime, it is just a regular dumb pointer, like in C.
[19:40:23] <untitaker> kimundi: So the compiler will insert deletion instructions for the variable at the place where the last pointer gets deleted?
[19:40:33] <untitaker> *for the value
[19:40:47] <Ms2ger> At the end of the scope that the ~T lives in, yes
[19:40:51] <kimundi> no, a & has no influence on when memory gets deleted
[19:40:57] <cmr> untitaker: it's not a gc though
[19:41:02] <kimundi> IN case of a ~: Yes
[19:41:12] <cmr> untitaker: the compiler inserts malloc/free pairs where needed
[19:41:18] <cmr> untitaker: it provides the same guarantees as a gc
[19:41:25] <cmr> but it's all compile time
[19:42:05] <doomlord> anyone taken the name "thrust" for a rust project. (thrust engine :) )
[19:42:17] <cmr> doomlord: all yours
[19:42:30] *** Joins: dylukes (dylukes@moz-13611DF9.hsd1.ma.comcast.net)
[19:42:40] <doener> cmr: yeah, got distracted though and took a nap in the meantime, back at it now (the anagram thing)
[19:42:43] <doomlord> thRust of course it'll have to be
[19:43:36] <kimundi> rusti: fn foo(n: &int) { print(n.to_str()) }; let x = ~5; {let y = ~98; foo(x) }
[19:43:37] -rusti- <anon>:7:65: 7:66 warning: unused variable: `y` [-W unused-variable (default)]
[19:43:37] -rusti- <anon>:7          fn foo(n: &int) { print(n.to_str()) }; let x = ~5; {let y = ~98; foo(x) }
[19:43:37] -rusti-                                                                           ^
[19:43:37] -rusti- 5()
[19:43:39] <cmr> doomlord: writing a game engine?
[19:43:49] <doomlord> well its in C++ at the minute, slight snag :)
[19:44:04] <doomlord> ios/android etc
[19:44:08] <kimundi> rusti: fn foo(n: &int) { println(n.to_str()) }; let x = ~5; {let y = ~98; foo(x) }; x // <- untitaker 
[19:44:09] -rusti- <anon>:7:67: 7:68 warning: unused variable: `y` [-W unused-variable (default)]
[19:44:09] -rusti- <anon>:7          fn foo(n: &int) { println(n.to_str()) }; let x = ~5; {let y = ~98; foo(x) }; x // <- untitaker 
[19:44:09] -rusti-                                                                             ^
[19:44:09] -rusti- 5
[19:44:11] -rusti- ~5
[19:44:13] <doomlord> hence my procastination about migrating to rust..
[19:44:22] <kimundi> whoops, wait
[19:44:27] <kimundi> rusti: fn foo(n: &int) { println(n.to_str()) }; let x = ~5; {let y = ~98; foo(y) }; x // <- untitaker 
[19:44:28] -rusti- 98
[19:44:29] -rusti- ~5
[19:44:31] <kimundi> there
[19:45:31] <kimundi> when it initialises y, it allocates memory for an int and stores an handle to that int as a ~int in y
[19:45:55] <doomlord> lol. this very minute, someone is asking on #opengl about a cuda library called 'thrust' 
[19:46:10] <kimundi> it then calls foo() with that ~int, wich gets autoborrowed to an &int
[19:46:48] <kimundi> because y is alive while it calls foo(), the program compiles
[19:47:23] <kimundi> because y is alive, the &int in foo()s body points at valid memory and can be used
[19:48:03] <kimundi> then foo() returns, the block in wich y got delared ends, and the compiler frees the ~int in y.
[19:48:39] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[19:49:47] <kimundi> The important thing here is that this does not cause any runtime overhead, its all determined at compile time by the way the code is structured 
[19:50:13] <untitaker> kimundi can i make this program crash by putting the function call into a new task and delay it while the val gets deleted?
[19:50:21] <cmr> untitaker: no
[19:50:34] <cmr> untitaker: two tasks can't have borrowed pointers to the same memory
[19:50:40] <kimundi> untitaker: No, you can only move data between tasks
[19:50:52] <kimundi> data that is Send able, that is
[19:51:46] <kimundi> Wich would be ~T (only one owner, so can safely send it back and forth between tasks), but not &T 
[19:52:06] <Eridius> cmr: not having enough u8 is why invalid_byte takes an Option. None means the bytestream ended early. Although another option would be to just give it the truncated sequence
[19:53:57] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Ping timeout)
[19:54:42] *** Quits: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr) (Quit: pyrac)
[19:54:48] <kimundi> untitaker: Basically, in rust you explicitld specify "who owns this data"
[19:55:50] <kimundi> where "owns" == "Is responsible for cleaning up and data integrity"
[19:56:46] *** Joins: offline (offline@moz-6823FA9D.dip0.t-ipconnect.de)
[19:56:52] <kimundi> ~T : only one owner. Can therefore decide to mutate its content or not, give the ownership away, etc
[19:57:07] *** Quits: dylukes (dylukes@moz-13611DF9.hsd1.ma.comcast.net) (Quit: ["Textual IRC Client: www.textualapp.com"])
[19:57:39] <kimundi> let x = ~6; // <- Here the local variable x is the owner of the ~int
[19:58:36] <km> cmr: I compiled master (3e933b1), and I'm still seeing a pointer added as the first argument in the C function
[19:58:54] <cmr> km: OS and arch?
[19:58:57] <km> Even removing all the other code and just doing `libusb_set_debug(10 as *mut libusb_context, 4);`.
[19:58:57] <km> and GDB says `Breakpoint 1, libusb_set_debug (ctx=0x804e738, level=10) at core.c:1600`
[19:59:08] <km> fedora 18, 32-bit
[19:59:22] <kimundi> &T : No ownership. You don't own the data it points at, therefore you can't delete or move it, only read from it, or in the case of &mut, write to it
[19:59:30] <km> rustc 0.7 (3e933b1 2013-07-06 08:32:10 -0700)
[19:59:30] <km> host: i686-unknown-linux-gnu
[19:59:36] *** Joins: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[20:00:44] <km> should I submit a bug report? any other debugging steps?
[20:01:13] <cmr> humm, maybe it's a 32-bit thing. what is std::sys::size_of::<*mut libusb_context>() and std::sys::size_of::<c_uint>()?
[20:01:33] <kimundi> @T : shared ownership/ownership by the garbage collector. You can have multible @T that point at the same data, and it will get cleaned up somewhere after nothing references  it anymore.
[20:04:34] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[20:04:43] <km> cmr: both 4
[20:05:07] <cmr> km: very odd, open an issue, https://github.com/mozilla/rust/issues
[20:05:47] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[20:05:56] *** Quits: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Ping timeout)
[20:05:57] *** Joins: Earnestea (earnest@2A2BF8F5.321FA5E6.BFD1ABFD.IP)
[20:06:45] *** Quits: Earnestly (earnest@2A2BF8F5.321FA5E6.BFD1ABFD.IP) (Ping timeout)
[20:06:59] <steven_is_false> What would be the overhead of switching to a special thread to execute C functions as opposed to the scheme as it is now?
[20:07:39] <cmr> steven_is_false: every task having its own FFI thread, or a few FFI threads?
[20:07:55] <steven_is_false> cmr: I was thinking about a few FFI threads.
[20:07:59] <cmr> steven_is_false: right now we just need an allocation, that would need some form of resource sharing.
[20:08:58] <steven_is_false> cmr: If every task had it's own FFI thread that'd be kind of pointless right?
[20:09:02] <cmr> steven_is_false: yup
[20:09:43] <steven_is_false> I know Rust is aiming towards mobile development. How much address space do mobile devices have?
[20:09:56] <cmr> 32bit usually
[20:10:18] <steven_is_false> Crud, then one can't do the over commit strategy.
[20:10:47] <steven_is_false> If every thread had it's own address space then wouldn't that work?
[20:10:49] <cmr> the proposed solutions to the problem are adequate
[20:10:56] <cmr> steven_is_false: that's called a process, not a thread
[20:11:18] <steven_is_false> cmr: On Linux there's supposed to be a way to have isolated threads.
[20:11:33] <steven_is_false> Which is lighterweight than a whole process I think.
[20:11:35] <cmr> steven_is_false: on linux there's no conceptual difference between a thread and process, they're all tasks
[20:11:47] <steven_is_false> Oh, okay then.
[20:11:56] <cmr> all created with the clone syscall
[20:12:55] <steven_is_false> cmr: So what about that then? If every thread was a process wouldn't they not waste each others address space?
[20:13:12] <cmr> steven_is_false: then we wouldn't have lightweight tasks, and that'd remove the benefit
[20:13:43] *** Joins: blaphmat (Mibbit@moz-C207C5B5.range86-145.btcentralplus.com)
[20:14:11] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[20:14:12] <steven_is_false> cmr: Sorry, I meant every os-level thread. One would still multiplex lightweight tasks across the threads.
[20:15:26] <cmr> steven_is_false: perhaps. it'd be complex, though, and would be more work than just having opt-in segmented stacks
[20:16:01] <steven_is_false> cmr: fair enough.
[20:16:16] <steven_is_false> cmr: And Rust wants to be Rusty, and not a research project.
[20:16:42] <SiegeLord> I forget, why not have segmented stacks on 32 bits and overcommiting on 64 bits?
[20:16:50] <cmr> SiegeLord: that's the plan
[20:17:00] <steven_is_false> It's just I got the idea from Google's Chrome browser, and how some of the Mac's had 64 bit OS, and 32 bit userland.
[20:18:48] <cmr> What's the word when an algorithm performs very poorly in certain cases. Degenerate case?
[20:19:01] <steven_is_false> Worst Case.
[20:19:03] *** Quits: roo (jesse.rudo@moz-B7585E4C.dynamic.ip.windstream.net) (Ping timeout)
[20:19:16] *** Joins: tiffany (kawaii@moz-28A8742A.dhcp.embarqhsd.net)
[20:20:19] <steven_is_false> Thank you for the discussion cmr.
[20:20:30] <cmr> np
[20:20:38] <cmr> did you figure out the rwarc stuff?
[20:20:51] *** Joins: roo (jesse.rudo@moz-B7585E4C.dynamic.ip.windstream.net)
[20:21:05] <steven_is_false> cmr: I'm still having problems with it but I'm planning on discussing it with bblum sometime.
[20:21:28] <steven_is_false> The only problem is that our schedules don't really sync up.
[20:21:53] <doener> cmr: segmented stacks, again...
[20:22:01] <steven_is_false> We have a concurrency problem with communication that prevents us from fixing a concurrency problem in the library.
[20:22:15] *** Quits: tiffany (kawaii@moz-28A8742A.dhcp.embarqhsd.net) (Input/output error)
[20:22:16] *** Quits: Ms2ger (Ms2ger@moz-E9883900.access.telenet.be) (Quit: nn)
[20:22:22] *** Joins: tiffany (kawaii@moz-28A8742A.dhcp.embarqhsd.net)
[20:22:30] <steven_is_false> Okay bye
[20:22:52] *** Joins: sander (sander@moz-BAEA8EB2.dynamic.upc.nl)
[20:22:57] *** Parts: steven_is_false (user@moz-144077DE.bchsia.telus.net) (ERC Version 5.3 (IRC client for Emacs))
[20:23:10] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[20:23:10] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14b6a2364 to 143e933b1: 02http://git.io/N3iJvQ
[20:23:10] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[20:23:14] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[20:23:14] <ghrust> 01[13rust01] 15bors pushed 12 new commits to 06auto: 02http://git.io/UPxMbA
[20:23:14] <ghrust> 13rust/06auto 145a37cf8 15blake2-ppc: deque: Fix grow condition in add_front...
[20:23:14] <ghrust> 13rust/06auto 1481933ed 15blake2-ppc: deque: Add tests and bench tests...
[20:23:14] <ghrust> 13rust/06auto 1440ce0b7 15blake2-ppc: deque: Speed up deque growth by a lot...
[20:23:16] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[20:23:53] *** Joins: robert (robertknig@moz-B6DD6E0B.range86-166.btcentralplus.com)
[20:23:57] <robert> Are there any tools/libs/language facilities for introspection with Rust?
[20:24:51] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[20:24:57] <cmr> robert: there's some reflection stuff in std::reflect, but it's deep magic
[20:26:16] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[20:26:29] *** sander is now known as smvv_
[20:26:40] <cmr> fmt!("%?", foo) is implemented with reflection
[20:26:49] <cmr> so using it as an example would probably be good
[20:27:29] <kimundi> but not to much of an example, seeing how we recently realised that fmt!("%?") is unsafe ;)
[20:28:00] <cmr> well reflection isn't safe to begin with I don't think
[20:29:03] <engla> but %? is only unsafe if you leave invalid values around. is that unavoidable?
[20:29:35] <Eridius> engla: if your data structure is implemented with unsafe{}, then your priv fields might be unsafe
[20:29:42] <Eridius> (or if it's implemented using another unsafe data structure)
[20:30:12] <kimundi> We'd need a clear guideline that says "Don't permanenly store invalid data in your struct fields"
[20:30:22] <engla> Yeah we need to know the rules
[20:30:24] <cmr> Pathlogical, that's the word I was looking for
[20:30:31] <robert> cmr: Do you know where the impl of that is?
[20:30:38] <engla> I've heard different takes on whether it's ok to store invalid elements in a vec or not
[20:30:40] <cmr> robert: somewhere in libsyntax
[20:30:42] <SiegeLord> You probably could have a safe subset of reflection
[20:30:49] <SiegeLord> That only walks public fields
[20:31:01] <cmr> SiegeLord: Is that information encoded at runtime?
[20:31:07] *** Quits: cdidd (cdidd@C8FD756B.6E9B9CA2.62D8163C.IP) (Input/output error)
[20:31:11] <kimundi> THat and/or a way to mark fields as unsafe
[20:31:23] <robert> The use case here is accessing Rust objects from scripting languages, so yes - no need for access to private fields
[20:31:25] <SiegeLord> cmr, I don't know how it works today
[20:31:32] <cmr> me neither
[20:31:34] <SiegeLord> And if not, maybe it could be
[20:32:23] <robert> I assume that something like this is needed for JS access to the DOM in servo?
[20:32:23] *** Joins: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com)
[20:32:47] <cmr> robert: you'd have to ask someone who works on servo but I'd imagine not
[20:33:10] *** Quits: Mowah (Mowah@moz-78DFE185.cust.bredbandsbolaget.se) (Ping timeout)
[20:33:12] <cmr> (#servo)
[20:33:20] *** Joins: cdidd (cdidd@moz-8345BD1.broadband.corbina.ru)
[20:33:31] <kimundi> There are other ways than refleciton to achieve that
[20:34:09] <kimundi> like macros/syntax extension that automatically generate an api for accessing the data
[20:34:09] <AutomatedTester> https://twitter.com/AutomatedTester/status/353611153789837312
[20:34:22] <AutomatedTester> nothing more than a vanity metric but still...
[20:37:16] <jmgrosen> bblum: so got any ideas of how to use a RWARC inside a @fn?
[20:38:22] <strcat> kimundi: reading private fields is automatically unsafe
[20:38:32] <strcat> so reflect.rs and %? is unsafe
[20:38:45] <strcat> would be easy enough to tag it all as unsafe
[20:38:49] <kimundi> well, it can be safe
[20:38:52] <strcat> no, it can't be
[20:39:12] <strcat> there's no guarantees about stuff in private fields, and even if there was breaking the privacy rules is unsafe
[20:39:21] <strcat> the compiler can assume private fields can't be accessed outside the module.
[20:39:29] *** Quits: smvv_ (sander@moz-BAEA8EB2.dynamic.upc.nl) (Quit: leaving)
[20:40:12] <Eridius> strcat: incidentally, condition uses %? in raise()
[20:40:18] <strcat> sure, so conditions are unsafe
[20:40:22] <strcat> in fact conditions are already unsafe
[20:40:30] <strcat> so is TLS
[20:40:39] <strcat> lets stop pretending unsafe APIs are safe, it's lazy
[20:40:51] <kimundi> But what if you want to read them inside your module? ;) But yeah your right, defaulting it to unsafe is the only sensible thing to do
[20:41:05] <strcat> kimundi: reading them inside the module is well defined
[20:41:20] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[20:42:06] *** Quits: cowboyd (cowboyd@moz-216282E7.sw.biz.rr.com) (Client exited)
[20:42:19] *** Joins: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr)
[20:42:30] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[20:43:11] <kimundi> btw, what exactly is the difference api-wise between static mut and TLS? Aren't they both kinde the same thing, except static mut is global, and TLS task-global?
[20:43:46] <strcat> static mut has data races
[20:43:51] <strcat> TLS is only unsafe because our API is broken
[20:44:03] <strcat> but it shouldn't be marked as safe
[20:44:08] *** Joins: cowboyd (cowboyd@moz-216282E7.sw.biz.rr.com)
[20:44:09] <strcat> unless someone remakes it to be safe
[20:44:31] <strcat> right now we sort of have a thing where we have stuff that *could* be safe, so we mark it as safe, even though making it safe would change the API
[20:44:52] *** Joins: achim (achim@moz-723A4A5A.pools.arcor-ip.net)
[20:44:58] <strcat> it would be inconvenient to mark the unsafe APIs as unsafe, but it would be saner
[20:46:38] *** Quits: cowboyd (cowboyd@moz-216282E7.sw.biz.rr.com) (Client exited)
[20:46:43] <engla> but you don't want to have to use unsafe in every module
[20:47:06] <strcat> so don't use the unsafe APIs
[20:47:08] <engla> maybe that's a later problem.. to make the safe language powerful enough
[20:48:25] *** Quits: txdv (quassel@966F3542.3BA477DA.14C26596.IP) (Ping timeout)
[20:48:45] *** Quits: krdln (Mibbit@moz-6F8A8560.dynamic.chello.pl) (Quit: http://www.mibbit.com ajax IRC Client)
[20:49:06] <SiegeLord> It seems more productive to fix the API, rather than just mark it unsafe
[20:49:16] <cmr> We have a volunteer!
[20:49:18] <strcat> SiegeLord: they can't easily be fixed
[20:49:18] <cmr> :P
[20:49:41] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[20:50:13] <strcat> I finally decided to start fixing str even though it means json is broken
[20:51:36] <SiegeLord> I don't think there's any expectation that safe code today is actually safe
[20:51:45] <strcat> I have that expectation
[20:51:53] <strcat> if it doesn't work it shouldn't be in the stdlib
[20:52:02] <cmr> if it's not safe it's a bug
[20:52:02] <SiegeLord> It's demonstrably false, given compiler bugs
[20:52:12] <strcat> SiegeLord: bugs != fundamentally unsafe APIs
[20:52:22] <strcat> codegen bugs can be fixed
[20:52:31] <SiegeLord> Well, so can the APIs :P
[20:52:34] <strcat> no, they can't
[20:52:40] <strcat> once stuff uses them it's too hard to fix
[20:52:54] <kimundi> What I actually meant with my question was: "I don't know how how TLS works, or how you use it, but it represents task local storage, wich is similar to static mut, wich repersents global storage. I wonder if/why the apis are different"
[20:53:13] *** Joins: lygaret (Mibbit@E9219860.BB950596.DFB232DA.IP)
[20:53:30] <strcat> soundness bugs in the language/libraries are huge problems
[20:53:35] <strcat> because fixing them breaks lots of code
[20:53:35] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[20:53:42] <SiegeLord> Well, is it easier to verify that the code that uses the unsafe API does so safely?
[20:53:50] <SiegeLord> Rather than fix the API to be safe?
[20:54:09] <kimundi> In short : Could someone explain TLS to me? ;)
[20:54:13] <SiegeLord> One of the two has to be done, or we have to make everything up the chain unsafe too
[20:54:22] <strcat> SiegeLord: we don't have to fix up the chain
[20:54:23] <strcat> it's the stdlib
[20:54:31] <strcat> the stdlib needs to be safe if it says it's safe
[20:54:37] <strcat> if it's not safe, it should be marked unsafe
[20:54:39] <strcat> simple
[20:54:51] <SiegeLord> Who uses the TLS API then?
[20:54:56] <lygaret> hey, has anyone had any luck with inline asm?
[20:55:05] <strcat> SiegeLord: no one yet?
[20:55:13] <strcat> thus it being a good idea to mark it unsafe or remove it before people do
[20:55:14] <cmr> lygaret: yes.
[20:55:15] <lygaret> I'm having some trouble with "couldn't allocate input reg for constrait 'a'"
[20:55:24] <cmr> lygaret: the syntax is different than every other compiler, but it does work
[20:55:37] <lygaret> and I don't know enough about llvm to diagnose that myself
[20:55:42] <SiegeLord> If nothing is using it, then it should be marked unsafe
[20:55:57] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[20:55:57] <strcat> it should still be marked unsafe if it's unsafe and something uses it...
[20:56:00] <lygaret> cmr, is there somewhere the syntax is laid out other than the pull request?
[20:56:02] <strcat> it doesn't matter if something uses it
[20:56:08] <lygaret> my googlefu is failing me
[20:56:14] <cmr> lygaret: nope
[20:56:24] <SiegeLord> You need to do more than just mark it unsafe it somebody's using it
[20:56:28] <cmr> lygaret: aatch|expression knows how it works, ask him when he's awake ;)
[20:56:35] <strcat> SiegeLord: what do I need to do?
[20:56:36] *** Joins: txdv (quassel@966F3542.3BA477DA.14C26596.IP)
[20:56:39] *** Quits: cdidd (cdidd@moz-8345BD1.broadband.corbina.ru) (Quit: Leaving)
[20:56:42] <strcat> if it's unsafe, I'll mark it as such to make it correct
[20:56:43] <lygaret> :) hah deal
[20:56:54] <SiegeLord> Make sure the code that uses it does it safely, or that code should be marked unsafe too
[20:57:42] <SiegeLord> Unsafe usage of "unsafe" is unsafe
[20:57:44] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Ping timeout)
[20:57:57] <strcat> it doesn't matter, APIs are the problem
[20:58:26] <strcat> if it's a public API and it says it's safe, it *needs* to possible to implement safely
[20:58:29] <lygaret> cmr, do you know enough to take a look at an invocation and tell me if there's something wrong I'm not seeing?
[20:58:34] <strcat> it's a backwards compatibility issue
[20:58:36] <lygaret> if not, it's cool, I'm just stuck
[20:58:37] <cmr> lygaret: maybe, paste your code
[20:58:39] <SiegeLord> Yes, and if an API uses an unsafe API within it, then it's also unsafe
[20:58:40] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[20:58:46] <SiegeLord> Unless it does so safely
[20:58:57] <strcat> SiegeLord: I don't care about that unless the API can't be implemented safely
[20:59:05] <strcat> anyway we can just git rm things like rope.rs and arena.rs
[20:59:13] <lygaret> cmr: http://pastebin.com/SY3PRK03
[20:59:17] <strcat> they can be readded to the standard library as sane rewrites
[20:59:19] <lygaret> it should be really simple
[20:59:30] <lygaret> I think I'm mixing up types, but I'm getting myself confused
[20:59:35] <lygaret> any help would be awesome, thanks :)
[20:59:57] <strcat> we should really require map keys to be Freeze
[21:00:15] <strcat> but how exactly am I supposed to do that?
[21:00:19] <strcat> rewrite librustc myself?
[21:00:49] <strcat> no - I'll probably just copy-paste the map into librustc and it can use the old broken one, that's realism
[21:01:13] <strcat> it's not a black and white BROKEN|PERFECT
[21:01:33] <cmr> lygaret: using ra and rNd works for the constraints
[21:01:37] <strcat> the public APIs should be marked properly because that's a backwards compat issue
[21:01:46] <cmr> lygaret: but there are other problems than that and I have no idea how it's supposed to work
[21:01:47] <strcat> internal implementation details are fixable without huge pain
[21:01:53] <lygaret> *nod*
[21:02:19] <lygaret> well, that's a lot further than I was before, thanks!
[21:02:36] <lygaret> what's the r mean? (or, where in the code should I look for what it means?)
[21:02:43] <cmr> register I think
[21:02:45] <cmr> dunno
[21:03:03] <lygaret> right on
[21:03:03] <cmr> src/libsyntax/ext/asm.rs is where this is implemented
[21:03:11] <lygaret> awesome, thanks!
[21:05:13] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[21:05:21] <doomlord> do any llvm languages have anything along the lines of "inline assembly" for llvm ir , analogous to real inline asm in gcc or whatever 
[21:05:31] <achim> hi all - apologies for a (probably noobish) installation question:
[21:05:32] *** Quits: untitaker (yaaic@moz-D515021E.adsl.highway.telekom.at) (Quit: Yaaic - Yet another Android IRC client - http://www.yaaic.org)
[21:05:41] <achim> after building from source (tried 0.7 and trunk) on OS X, i get a "rust(42535,0x10b6c9000) malloc: *** mmap(size=7522747388523884544) failed (error code=12)" upon calling rust. should this worry me? rustc/i seem to work, make check yields 0 failed tests.
[21:05:59] <cmr> achim: known problem
[21:06:07] *** Quits: vilonis (vilonis@moz-EE5D17ED.ph.ph.cox.net) (Quit: irc2go)
[21:06:29] *** Joins: jared (jared@moz-EE5D17ED.ph.ph.cox.net)
[21:06:53] <achim> cmr: good to know, thanks
[21:07:16] <cmr> doomlord: it's implemented as metadata, http://llvm.org/docs/LangRef.html#inline-assembler-expressions
[21:07:26] <engla> Eridius: is the size_hint PR yours? it's got a one-line conflict with the PR currently simmering with bors.
[21:08:45] <Eridius> engla: d'oh
[21:09:01] <engla> just telling so you can fix it. this line in particular https://github.com/kballard/rust/commit/770c9f957cdac7678c8f6411e539db6ec08079d2#L0R188
[21:09:07] <engla> so we can try to fix it
[21:09:15] <engla> without changing line 188 it merges fine
[21:10:01] <Eridius> engla: I can re-push my PR without it, but I'll need a new r+
[21:10:06] *** Joins: cdidd (cdidd@moz-EC454021.broadband.corbina.ru)
[21:10:10] <cmr> which pr?
[21:10:18] <Eridius> https://github.com/mozilla/rust/pull/7570
[21:10:44] <cmr> rebase whenever
[21:11:12] <Eridius> ok, re-pushed
[21:11:28] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[21:11:57] <engla> the new version merges fine with auto
[21:12:24] *** Joins: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net)
[21:12:37] <engla> wait no...
[21:12:41] * engla makes a mess
[21:13:25] *** Quits: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net) (Quit: tikue)
[21:14:02] <engla> the size_hint impl for deque is no longer correct that way
[21:14:09] *** Joins: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net)
[21:14:25] <Eridius> bleh. I'll rip out deque for the moment then
[21:14:33] <engla> do it
[21:15:06] <Eridius> ok, re-pushed
[21:17:01] *** Quits: achim (achim@moz-723A4A5A.pools.arcor-ip.net) (Quit: Computer has gone to sleep.)
[21:18:09] <cmr> Does anyone want to write a paragraph/two about this weeks meeting (https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-07-02 )? It goes right over my head unfortunately
[21:18:34] <cmr> (For TWiR, that is)
[21:18:50] <engla> ok Eridius sorry for the mess, hope both of these integrate now
[21:19:49] <Eridius> engla: thanks for catching it before bors could reject it again
[21:31:20] *** Joins: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca)
[21:35:27] *** Quits: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr) (Quit: pyrac)
[21:36:21] *** Quits: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net) (Quit: tikue)
[21:42:04] <cmr> http://cmr.github.io/blog/2013/07/06/this-week-in-rust/
[21:42:15] <cmr> feedback before I post it to the ML+Reddit?
[21:43:26] <Flibo> ooh, something for newbies (me)
[21:43:32] <strcat> cmr: s/cleaning up/removing/ ;p
[21:43:54] <strcat> cmr: https://github.com/mozilla/rust/pull/7605 if I was motivated to finish it, but I'm not
[21:44:00] <strcat> way too much trouble
[21:44:12] <strcat> they're now fully unused though.
[21:46:01] <cmr> strcat: fixed, thanks
[21:46:46] <sfackler> cmr: you're missing a ` at the end of the Breaking Changes section
[21:47:00] <cmr> sfackler: oops, thanks
[21:47:06] <cmr> that explains why all my syntax highlighting broke.
[21:48:07] *** Joins: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[21:49:30] *** Joins: mreedell (mreedell@moz-9950CA28.hsd1.pa.comcast.net)
[21:54:00] *** Joins: krdln (Mibbit@moz-6F8A8560.dynamic.chello.pl)
[21:54:23] *** Quits: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Ping timeout)
[21:55:24] *** Joins: BitPuffin (quassel@moz-911FB3CE.cust.tele2.se)
[21:56:09] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[21:56:10] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/UPxMbA
[21:56:10] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[21:56:13] <glinscott> str::from_bytes appears to first check if it's valid utf-8, then directly copies the u8 array into the str?  so if i have multi-byte unicode characters, i can't index into the string directly?
[21:56:55] <strcat> what do you mean directly?
[21:57:07] <cmr> rusti: let x = "fâ˜ƒoo"; x[2]
[21:57:09] -rusti- 152
[21:57:09] <strcat> str lets you index and iterate over char, but it stores it as utf-8
[21:57:17] <strcat> keep in mind that a grapheme != a code point
[21:57:24] <strcat> it's unlikely you care about code points
[21:57:45] <strcat> except to build strings
[21:57:57] <glinscott> right, yes, i'm working on building strings :)
[21:58:02] *** Quits: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net) (Input/output error)
[21:58:08] <glinscott> so i'm trying to understand more of their internals
[21:58:34] *** Quits: thpickert (thpickert@moz-99F22CD3.dynamic.dsl.tng.de) (Quit: thpickert)
[21:58:52] <glinscott> hm..  x[2] = 152, that doesn't seem right?
[21:59:14] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[21:59:14] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/L6ETOw
[21:59:14] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[21:59:58] <cmr> rusti: let x = "fâ˜ƒoo"; x.iter().nth(2)
[21:59:58] -rusti- Some('o')
[22:00:05] <cmr> rusti: let x = "fâ˜ƒoo"; x.iter().nth(1)
[22:00:07] -rusti- Some('\u2603')
[22:00:21] <cmr> rusti: let x = "fâ˜ƒoo"; x.iter_bytes().nth(2)
[22:00:22] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/iYfT
[22:00:32] <glinscott> ok, so direct indexing on str is really on the underlying bytes - while the iterator converts to chars
[22:00:52] <glinscott> and char is 32 bit?
[22:00:54] <cmr> rusti: let x = "fâ˜ƒoo"; x.bytes_iter().nth(2)
[22:00:55] -rusti- Some(152)
[22:01:01] <cmr> glinscott: ucs-4, yes
[22:01:44] *** Quits: relistan (relistan@moz-2DE8112B.cable.virginmedia.com) (Quit: relistan)
[22:01:56] <glinscott> cmr: thanks!
[22:09:03] <strcat> glinscott: well it's really 21-bit and stored as 4 bytes
[22:09:14] <strcat> but the implementation is unsound and allows out-of-range values
[22:09:19] *** Quits: pauls_ (paul@moz-9B39917C.c3-0.smr-ubr2.sbo-smr.ma.cable.rcn.com) (Ping timeout)
[22:09:19] <strcat> but bools are unsound in the same way currently
[22:10:12] *** Joins: Sergio965 (sergiobz@moz-986B8AEA.dyn.mit.edu)
[22:10:23] <glinscott> strcat: ok, thanks
[22:10:40] <strcat> it's kind of funny
[22:10:49] <strcat> rusti: let b = 5 as bool; (b, b == true)
[22:10:50] -rusti- (true, false)
[22:11:06] <cmr> "non-canonical bools" still cracks me up
[22:11:26] <strcat> it's really terrible
[22:11:34] <strcat> it's really a codegen level issue though
[22:12:23] *** Joins: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net)
[22:13:00] <Eridius> cmr: you should darken the text on your blog a little. The contrast is kinda low with the background
[22:13:33] <cmr> I wonder if we could ditch the built-in types and do like struct char(std::unstable::builtin_char) to work around https://github.com/mozilla/rust/issues/6065
[22:14:16] <cmr> Eridius: It looks fine on my monitor, I'll do so, thanks
[22:14:55] *** Parts: offline (offline@moz-6823FA9D.dip0.t-ipconnect.de) ()
[22:15:07] <strcat> cmr: newtypes are really broken
[22:15:21] <strcat> we could just fix coherence to consider them declared in libstd
[22:16:22] <cmr> Eridius: does rgb(90, 90, 90) look good to you?
[22:17:18] <engla> cmr: you could remove the char type and just use char(u32) ?
[22:17:41] <Eridius> cmr: how about #333
[22:17:44] <cmr> engla: well it's a problem with all the types, char was just the one I picked
[22:17:59] <cmr> Eridius: sure, thanks!
[22:18:04] <strcat> engla: that would let you construct invalid chars, like now
[22:18:08] * cmr away for dinner
[22:18:17] <strcat> since newtypes can't have the interior type as a private detail yet
[22:18:41] <engla> strcat: yeah I really don't mean that's the specific wrapper
[22:18:49] <engla> chars have other problems you can divide char / char
[22:18:59] <strcat> they shouldn't implement +, /, -, etc.
[22:19:03] <engla> right
[22:19:15] <engla> so it can be an encapsulated number just like Ascii
[22:19:24] <strcat> 'c' is a char literal though
[22:19:35] <strcat> maybe a lang item is enough
[22:19:46] * strcat could try doing that
[22:20:12] <strcat> #[lang = 'char'] struct char { priv value: u32 } and just remove it from the language itself
[22:20:15] *** Quits: lygaret (Mibbit@E9219860.BB950596.DFB232DA.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[22:21:12] *** Quits: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net) (Quit: echristo)
[22:24:37] *** aatch|expression is now known as aatch
[22:25:47] <aatch> boo, I got a test failure
[22:27:36] <engla> strcat: will you look at overlong encodings too (utf-8) since you touched the other parts
[22:27:36] <doener> YES! The scope cleanup finally builds!
[22:29:37] <doener> and it seems to improve inlining behaviour. The anagram bench goes from 5.6s to 1.5s :-D
[22:30:33] <aatch> doener, sweet
[22:30:40] <aatch> presumably it's less code
[22:31:35] <doener> aatch: yeah, I guess the jumps get eliminated too late, so the inline cost is considered too high
[22:32:15] <doener> I just hope that it survives the test suite as well, then I can go and turn it into PR-worthy form tomorrow
[22:32:38] <doener> or rather, later today, already past midnight again
[22:32:52] <aatch> doener, heh.
[22:33:15] <aatch> doener, inlinecost is pretty early, so yeah
[22:33:24] <doener> I hope this also helps noopt, should save two jumps per function call
[22:33:38] <doener> and another one here and there
[22:33:44] <aatch> doener, nice, that should help a lot
[22:34:12] *** Joins: sander (sander@moz-BAEA8EB2.dynamic.upc.nl)
[22:34:20] *** sander is now known as smvv_
[22:34:38] * doener has a huge smile on his face
[22:34:51] <aatch> should speed the passes up too, since I think jump-threading is quadratic
[22:35:27] <doener> didn't look like it when stage2 was built, but I'll measure again when I have a build of the upstream version this is based on
[22:36:03] <aatch> doener, if you push your changes to a branch, you could probably ask cmr to do a benchmark
[22:36:19] <cmr> you have to ask reeeal nice though
[22:36:21] * cmr bats eyes
[22:36:44] <strcat> doener: it's really terrible that segmented stacks cause a 5x perf hit though
[22:37:02] <doener> strcat: yeah, that's awful.
[22:37:27] * strcat really wants tasks to not use them by default
[22:37:32] <strcat> I wonder how much rustc would be sped up
[22:37:37] <doener> strcat: btw, how do they work? Do they shrink immediately when returning from the frame that grew them?
[22:37:55] <strcat> doener: there's a bunch of overly clever caching magic
[22:38:07] <strcat> I think they do shrink immediately though (by segments, they never reallocate)
[22:38:30] <strcat> but they *really* should not be used by default
[22:38:32] <strcat> on any platform
[22:38:36] <strcat> it's ridiculously slow
[22:38:57] *** Quits: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP) (Quit: night)
[22:39:20] <doener> ok, so the hashmap stuff in that bench probably ends up with a malloc for every other call
[22:40:24] <strcat> doener: worse than that, afaik it hits synchronization for the caching too
[22:40:31] <strcat> it's going to be more than 5x if you did it in parallel
[22:40:32] <doener> perf says that 45% of the newstack calls are from uint::iterate(?!), and 55% from hashmap::find, so yeah, bad
[22:40:52] *** Quits: txdv (quassel@966F3542.3BA477DA.14C26596.IP) (Ping timeout)
[22:41:01] <strcat> doener: anyway the first task you're given should have a big stack
[22:41:06] <strcat> and task::spawn should use a big stack
[22:41:18] *** Joins: txdv (quassel@966F3542.3BA477DA.14C26596.IP)
[22:41:28] <aatch> strcat, I definitely like your stance of not using them (or not really using them anyway) by default, and having to pick smaller ones if you know that you don't want/need a big stack
[22:41:31] <strcat> the silly segmented stacks should be opt-in because the 1-task-per-client server use case is an edge case
[22:41:47] <strcat> aatch: well I want rust to be a viable systems language
[22:41:49] <strcat> right now it isn't
[22:41:56] <aatch> How about we leave Go for that case
[22:42:13] <strcat> rust can handle that case, you'll just have to use a different task spawn function
[22:42:18] <doener> aatch: jump threading doesn't matter for the blocks that get removed, they should always have only one predecessor and one successor
[22:42:26] <strcat> and we can allow passing it an initial estimate for the first segment
[22:42:47] <doener> cmr: http://cmr.github.io/blog/2013/07/06/this-week-in-rust/
[22:42:50] <doener> oops
[22:42:54] <doener> cmr: https://github.com/dotdash/rust/tree/scopes-mess
[22:43:05] * doener blinks eyes
[22:43:06] *** Quits: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net) (Ping timeout)
[22:43:17] <aatch> strcat, sure, but I don't think we should _focus_ on that use case
[22:43:20] <doener> cmr: would you kindly benchmark that branch?
[22:43:24] <cmr> doener: sure thing!
[22:43:32] <strcat> aatch: right, we shouldn't have overly clever ffi caching
[22:43:34] <strcat> like fast_ffi
[22:43:51] <strcat> if you do FFI from a small stack, you should just pay for the allocation as you would with a rust function needing a 2MiB stack
[22:44:21] <strcat> right now we don't have a good solution for either general purpose code or scaling to a high # of I/O requests
[22:44:27] <doener> cmr: wait
[22:44:37] <strcat> rust is slow and uses tons of memory for cached segments
[22:44:42] <strcat> don't see what we've gained
[22:44:45] <strcat> ;p
[22:45:05] <doener> cmr: now it's fine. I had accidently squashed my changes into the merge commit from origin/master
[22:45:14] <cmr> ok
[22:45:29] <doener> yay, test suite passed \o/
[22:45:43] <strcat> say goodbye to ropes
[22:45:45] <strcat> ;p
[22:46:27] <aatch> strcat, yeah, I would like the scheduler stuff to be more separate too. I'm not too keen on having so much of basic functionality rely on the scheduler existing.
[22:47:41] *** Joins: kyle2000 (kyle2000@6EDB4D7A.341FCD98.3031298E.IP)
[22:47:51] <cmr> doener: I'll talk to dbaupp about having a separate section on irfy for pull-requests
[22:47:53] *** Quits: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com) (Quit: webber46)
[22:48:09] <cmr> he wrote me a fancy auto-bench script that checks if there's anything new on master, and if not benches stuff from the history
[22:48:29] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[22:48:32] <cmr> could easily extend it to check for 'benchthis' in PR comments, and do those too
[22:49:36] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[22:51:26] <strcat> doener: for something more sad, treemap is 3x slower than C++ with both using glibc malloc, and 10-15x slower with jemalloc :(
[22:51:40] <strcat> yay terrible support for recursion thanks to segmented stacks + exchange alloc headers
[22:51:47] <kyle2000> strcat: that is very sad. that is not the rust way at all.
[22:52:12] <strcat> and we can't even use jemalloc thanks to segmented stacks because it doesn't run in the red zone
[22:53:13] *** Joins: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com)
[22:54:21] *** Joins: Earnestly (earnest@2A2BF8F5.321FA5E6.BFD1ABFD.IP)
[22:54:47] <strcat> I could write it procedurally with ~[] if only our vectors weren't so slow too
[22:54:49] <kyle2000> what about tcmalloc?
[22:54:58] <cmr> who cares about tcmalloc
[22:55:09] <strcat> kyle2000: it needs a lot of stack space like jemalloc too
[22:55:13] <strcat> they are similar implementations
[22:55:15] <kyle2000> what about openbsd malloc?
[22:55:22] <strcat> kyle2000: not good
[22:55:33] <kyle2000> why is it not good?
[22:55:39] *** Quits: Earnestea (earnest@2A2BF8F5.321FA5E6.BFD1ABFD.IP) (Ping timeout)
[22:55:42] <strcat> because they didn't spend any time optimizing it? I don't know
[22:55:47] <strcat> it's very slow
[22:55:56] <strcat> glibc's allocator isn't that bad
[22:56:11] <strcat> but it's not great for trees because it doesn't optimize as well for small allocations
[22:56:41] <strcat> and it doesn't scale as well as jemalloc/tcmalloc or prevent fragmentation as well because they use sbrk
[22:56:54] *** Quits: SimonSapin (simon@moz-D0C2F181.zone2.bethere.co.uk) (Ping timeout)
[22:57:27] <kyle2000> i'm so dumb about memory allocation. i'm just so dumb.
[22:57:27] <doener> aatch: seems to be about 1.5% faster for librustc
[22:57:45] <cmr> kyle2000: lack of knowledge is not stupidity
[22:58:03] <strcat> jemalloc performs about the same as glibc for single-threaded stuff
[22:58:06] <doener> kyle2000: computer science offers a thousand possibilities per second to feel dumb :-)
[22:59:08] <aatch> kyle2000, for every thing I learn, I find 100 things I don't understand
[22:59:13] <doener> kyle2000: knowing that one has no clue is already better than most
[22:59:48] * doener had no idea about jump threading until 15 minutes ago
[22:59:57] * cmr still has no idea about jump threading
[23:00:02] <kyle2000> i wish i was as smart as you rust guys. your knowledge is rusty in a good way. my knowledge is rusty like in a piece of old metal covered in rust and tetanus.
[23:00:07] <doener> http://llvm.org/docs/Passes.html#jump-threading-jump-threading
[23:00:33] <strcat> doener: yeah it's enabled by default now since I redid our passes to match clang's
[23:00:36] <kyle2000> the llvm developers make me feel like i am as dumb as a peach. they are gods among the gods.
[23:00:39] <cmr> that's fancy
[23:00:46] <aatch> strcat, I thought it was before
[23:01:11] * strcat looks
[23:01:31] <strcat> aatch: oh it was
[23:01:45] <aatch> strcat, I didn't think I'd miss out something like that
[23:01:50] <strcat> 2bdc88b6526f806156a6342ae75a80d99ea6e378 is that commit btw
[23:03:56] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[23:04:05] *** Joins: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net)
[23:04:21] *** Quits: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com) (Quit: webber46)
[23:06:20] <dbaupp> cmr: did anything explode?
[23:06:25] <cmr> dbaupp: nope
[23:06:37] <cmr> dbaupp: Although I haven't actually ran the script yet :P
[23:06:48] *** Joins: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net)
[23:07:05] <dbaupp> oh... dammit, I wanna see some explosions! :P
[23:07:21] <cmr> dbaupp: I want to modify it to scan github PRs for a comment like "benchthis", and then benchmark that data. Is there a way you could add a separate section to IRSY specifically for comparing benched PRs to other commits?
[23:07:27] <cmr> They woul;dn't be in the main timeline
[23:08:13] <dbaupp> erm, yeah, shouldn't be tooooo hard.
[23:08:35] <dbaupp> (it'd be entirely separate, right?)
[23:08:43] <cmr> I can do all the stuff on my end
[23:08:44] <cmr> yeah
[23:08:46] <cmr> well
[23:08:50] <cmr> it'd still be in ~/benches
[23:08:57] <cmr> probably ~/benches/pullreqs
[23:09:48] <dbaupp> right, but it'd go into a different history.txt
[23:09:52] <cmr> right
[23:10:01] <dbaupp> cool
[23:10:54] <cmr> I have one cooking for doener right now, so you'll have something to work with soonlike
[23:11:06] <dbaupp> We could possibly rig isrustfastyet to handle it. (i.e. https://github.com/isrustfastyet)
[23:11:24] <dbaupp> e.g. `@isrustfastyet: bench this` or something
[23:11:26] <strcat> aatch: going to play around with ~T header removal a bit again
[23:11:31] <cmr> Nah
[23:11:34] <cmr> just @isrustfastyet?
[23:11:42] <aatch> strcat, cool
[23:12:07] <dbaupp> cmr: but then we can't mention it in general conversation without it sweeping in and doing things.
[23:12:10] * strcat is getting close
[23:12:24] <doener> strcat: did you figure out the Store failure?
[23:12:25] <cmr> dbaupp: but it looks so cool and declarative :(
[23:12:26] <dbaupp> cmr: (I guess I'll need to give you access to the notifications.)
[23:12:34] <strcat> doener: nope but I fixed some other issues
[23:12:49] <doener> strcat: I spent an hour or so looking into it, but it seems really weird
[23:13:03] <cmr> dbaupp: I dunno, are mentions listed in the public rss feed?
[23:13:03] <dbaupp> cmr: well, maybe if it was '@isrustfastyet?' at the beginning of the comment or something
[23:13:09] <strcat> doener: well ~T with non-managed unique is now *T
[23:13:12] <strcat> instead of *Box<T>
[23:13:19] <strcat> so I think it's messed up somewhere
[23:13:23] <cmr> Yeah that'd be fine, s.startswith('@isrustfastyet?')
[23:13:26] <strcat> and treating managed-unique as unique
[23:13:28] <strcat> or the other way around
[23:13:37] <strcat> also, unique vectors are still all *Box<T>
[23:13:57] <strcat> doener: I'm slowly expanding a file of things that definitely work
[23:14:06] <strcat> since I can use the stage1 compiler
[23:14:39] *** Quits: robert (robertknig@moz-B6DD6E0B.range86-166.btcentralplus.com) (Ping timeout)
[23:15:08] <dbaupp> cmr: you'll presumably want to get it to say comments, so you'll need access anyway.
[23:15:24] <cmr> yeah
[23:15:32] *** Quits: naq (naq@D5C2D2DF.E4265FCD.E481B5B.IP) (Ping timeout)
[23:15:36] <cmr> I can setup an oauth thinger if you want to do it the right way
[23:16:19] <dbaupp> ok
[23:16:39] * dbaupp was just going to give you user/pass.
[23:16:42] <cmr> (not tonight; I'm off to bed soonish and I want to finish json output for structs)
[23:16:46] <cmr> yeah that'd work too :p
[23:17:17] <dbaupp> that's fine
[23:17:31] <cmr> wow the visvalign algorithm is really quite elegant
[23:17:39] <cmr> visvalingam
[23:17:45] <dbaupp> for line simplification?
[23:17:47] <cmr> yeah
[23:18:04] <dbaupp> (are you reading more of my code? :S )
[23:18:05] <cmr> I originally tried pasing that function name as visibility vertical align ?????
[23:18:07] <cmr> (yes :p)
[23:18:14] <cmr> s/pasing/parsing/
[23:18:26] <dbaupp> heh
[23:18:29] <strcat> doener: but yeah, this is really hard to debug :(
[23:18:46] * strcat has just been blindly editing based on greps
[23:18:47] *** Joins: naq (naq@D5C2D2DF.E4265FCD.E481B5B.IP)
[23:18:49] * dbaupp quite likes his implementation of visvalignam
[23:19:59] <cmr> dbaupp: https://github.com/huonw/isrustfastyet/blob/gh-pages/mem/line_simplify.rs#L41 should be 'inconceivable!'
[23:20:21] <doener> impossibru?
[23:20:34] * strcat just uses "nope"
[23:21:00] <dbaupp> I was thinking of "lies!"
[23:21:31] <strcat> rusti: let x = 5 as bool; if x != true && x != false { fail!("nope") }
[23:21:32] -rusti- rust: task failed at 'nope', <anon>:7
[23:21:32] -rusti- rust: domain main @0x7281b0 root task failed
[23:21:32] -rusti- application terminated with error code 101
[23:21:55] <strcat> I'll almost be sad when we fix that
[23:24:41] *** Quits: sankha93 (Instantbir@E1916E3C.9A5EC03F.8B6C1D65.IP) (Ping timeout)
[23:26:07] <dcolish> what does x == in that case?
[23:26:18] <aatch> dcolish, 5
[23:26:21] <strcat> not really
[23:26:24] <dcolish> trioolean logic?
[23:26:26] <aatch> but also, true
[23:26:29] <strcat> 5 is stored there in memory
[23:26:31] <aatch> but also not
[23:26:34] <strcat> but it's undefined behaviour
[23:26:43] <strcat> we have range asserts on loads so it's completely invalid
[23:26:57] <dcolish> if you print it does 5 print out?
[23:27:07] <strcat> no
[23:27:08] <aatch> rusti: (0xff as bool, 0xff00 as bool)
[23:27:08] <dbaupp> rusti: 5 as bool
[23:27:09] <strcat> it's not an int
[23:27:10] -rusti- (true, false)
[23:27:10] -rusti- true
[23:28:05] <dcolish> does the value 5 get thrown away before the assignment?
[23:28:08] <cmr> nope
[23:28:31] <doener> dcolish: some code paths in the compiler assume that bool is either 0 or 1, some don't
[23:28:35] <strcat> we incorrectly compile bools to i8
[23:28:42] <dcolish> ah
[23:28:44] <strcat> instead of i1, and storing them as i8
[23:28:56] <cmr> https://github.com/mozilla/rust/blob/master/src/libextra/json.rs#L33
[23:29:01] <strcat> so u8 -> bool doesn't do anything
[23:29:05] <cmr> Is List and Object duplicated there?
[23:29:10] <cmr> ie, exists in the namespace twice?
[23:29:22] <strcat> looks like it
[23:29:31] <cmr> why is that allowed to be compiled
[23:29:35] <doener> dcolish: so _sometimes_ you end up with a "cmp $1, %al", but sometimes with "test %al,%al"
[23:29:37] <cmr> and which one am I going to get :\
[23:29:43] <dbaupp> cmr: no, because one is a type and one is a variant
[23:29:44] <jmgrosen> um, what? "error: mismatched types: expected `&<V17>` but found `&str` (expected &-ptr but found &str)"
[23:29:53] <dbaupp> cmr: (i.e. a value)
[23:29:54] <strcat> jmgrosen: &str isn't &T
[23:30:00] <strcat> &str and &[] are slices
[23:30:05] * jmgrosen sighs
[23:30:08] <jmgrosen> right
[23:30:58] <cmr> dbaupp: so, if I use extra::json::Object, which do I get?
[23:31:09] <dbaupp> cmr: depends where you use it
[23:31:13] * cmr cries
[23:31:22] <dbaupp> cmr: let x: extra::json:Object; // type
[23:31:27] *** Quits: vk (vk@2AAA6DD0.B568D26C.93B001FA.IP) (Quit: vk)
[23:31:44] <dcolish> doener: thats pretty tricky
[23:31:45] *** Quits: sp3d (a@moz-49806493.dhcp.stls.mo.charter.com) (Ping timeout)
[23:31:46] <dbaupp> cmr: let x = extra::json::Object(some_hashmap); // variant
[23:31:56] <dcolish> the behavior is kind of fun although
[23:32:00] <cmr> dbaupp: makes sense, not obvious at the outset.. thanks!
[23:32:23] <doener> dcolish: this is really hard to debug :(
[23:32:23] <doener> 01:18:46  * strcat has just been blindly editing based on greps
[23:32:23] <doener> 01:18:47 -!- naq has joined #rust
[23:32:23] <doener> 01:18:49  * dbaupp quite likes his implementation of visvalignam
[23:32:39] <doener> gosh, what's wrong with my clipboard?!
[23:32:46] <doener> dcolish: http://markshroyer.com/2012/06/c-both-true-and-false/
[23:32:50] <jmgrosen> strcat: that's honestly one of the most confusing parts of the language to me
[23:32:51] <dcolish> doener: yeah, I can imagine
[23:32:56] <kyle2000> doener: at least there aren't naked men in it
[23:33:20] <kyle2000> how is the new io module work going?
[23:33:35] <strcat> jmgrosen: we could just not have sugar for slices ;\
[23:33:44] <dcolish> not surprising C has the same issues with type widening
[23:34:03] <jmgrosen> strcat: then what would they look like? StrSlice?
[23:34:18] <strcat> jmgrosen: I guess
[23:34:25] <strcat> StrSlice<int>
[23:34:28] <strcat> instead of &[int]
[23:34:43] <strcat> &[int] wouldn't be a valid type
[23:34:54] <cmr> Slice<int> you mean?
[23:35:07] <strcat> well vectors would be using Slice
[23:35:31] <strcat> anyway I don't mind it as it is
[23:35:57] <aatch> it's a wart, I agree, but I think it pays itself off.
[23:36:09] *** Quits: sigma1 (sigma@moz-294FA516.range86-128.btcentralplus.com) (Ping timeout)
[23:36:17] <cmr> it is very useful, just sometimes weird
[23:36:40] *** Joins: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[23:37:53] <aatch> I'm really tempted to get rust to stop tokenizing <- and <->
[23:38:02] <cmr> do it
[23:38:13] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[23:38:13] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/jfbOVg
[23:38:13] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[23:38:20] <aatch> I think it's been long enough
[23:38:54] <dbaupp> aatch: tokenising <- would be need for Haskell do-notation ;P
[23:38:57] *** Quits: vegai (vegai@moz-84E87CA5.kapsi.fi) (Ping timeout)
[23:39:11] <dbaupp> rusti: stringify!(<-)
[23:39:12] -rusti- "<-"
[23:39:20] <dbaupp> rusti: stringify!(< -)
[23:39:21] -rusti- "< -"
[23:39:39] <aatch> dbaupp, fine, then I'll just get rid of the places it parses.
[23:40:01] <dbaupp> aatch: it's probably better to remove it
[23:40:05] <dbaupp> rusti: 1 <-2
[23:40:06] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/dURF
[23:40:36] <aatch> I love how it suggests also-invalid syntax
[23:41:04] <cmr> heh
[23:41:07] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[23:41:07] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/tHOwrA
[23:41:07] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[23:41:23] <aatch> rusti: let a = 1; let b = move a; b
[23:41:23] -rusti- <anon>:7:33: 7:34 error: expected `;` but found `a`
[23:41:24] -rusti- <anon>:7          let a = 1; let b = move a; b
[23:41:24] -rusti-                                           ^
[23:41:24] -rusti- application terminated with error code 101
[23:41:25] <dcolish> move isnt a keyword anymore is it?
[23:41:31] <cmr> nope
[23:41:31] <aatch> dcolish, nope
[23:41:37] <strcat> soon 'copy' won't be either
[23:41:40] <aatch> Rust is move-by-default
[23:41:41] <Sergio965> Is there a proposed "final" syntax for external and internal iterators?
[23:41:43] <dbaupp> rusti: let move = 1; move
[23:41:44] -rusti- 1
[23:41:49] <cmr> Sergio965: no
[23:41:55] <strcat> Sergio965: there won't be language/library support for internal iterators
[23:42:02] <Sergio965> They're going away completely?
[23:42:06] <strcat> in the stdlib
[23:42:08] <strcat> yes
[23:42:12] <Sergio965> :o
[23:42:34] <Sergio965> I thought the decision (last week?) was to keep both around?
[23:42:42] <strcat> no
[23:42:50] *** Joins: vegai (vegai@moz-84E87CA5.kapsi.fi)
[23:43:06] <cmr> they could be reimplemented with less magic using do-notation or a syntax extension
[23:43:11] <cmr> I think
[23:43:15] <strcat> there's no point of keeping around internal iterators in the stdlib
[23:43:18] <cmr> but they're really very marginally useful
[23:43:24] <dbaupp> Sergio965: internal iterators are nothing special, just a higher order function, so they can't really be removed.
[23:43:24] <Sergio965> Is "do" sticking around?
[23:43:26] <strcat> external iterators provide a superset of the functionality
[23:43:29] <cmr> Sergio965: yes
[23:43:33] <strcat> Sergio965: yes, "do" isn't a loop protocol though
[23:43:41] * dbaupp wonders how IterBytes will work with external iterators
[23:44:02] <engla> it doesn't need to switch
[23:44:04] <Sergio965> dbaupp: Right, but "for" gave nice syntax for them.
[23:44:16] <strcat> Sergio965: confusing syntax
[23:44:21] <strcat> break and return in the current for loop don't work
[23:44:42] <strcat> they're please-break and please-break-and-let-me-return
[23:44:42] <dbaupp> Sergio965:  correct, there may be some associated changes that make `do` "support" internal iterators better
[23:44:52] <dbaupp> Sergio965: e.g. allowing return in closures
[23:45:05] <dcolish> Which ones are internal iterators and which ones are external again?
[23:45:08] <engla> It's not worth it to have to think about closure captures just for a for loop
[23:45:10] <strcat> I don't know why anyone would want internal iterators though
[23:45:46] <dcolish> ah std::iter vs std::iterator
[23:45:46] <doener> aatch: yeah, noopt is a bit more impressed by the change, librustc builds 9% faster
[23:45:49] <dbaupp> dcolish: internal = passing a function into another function which calls the function, external = creating an object that you can call .next() on to get the next element
[23:45:49] <engla> easier to implement
[23:45:56] <strcat> dcolish: std::iter is dead now
[23:45:58] <strcat> engla: not actually true
[23:46:03] <strcat> they're only easier for recursive traversals
[23:46:19] <Sergio965> dcolish: Internal = pass in a closure to a function that iterates and call your function. External = You iterate over some "iterator" that gives you the values and you call your own function over them. In other words, internal = they do they iteration for you, external = you iterate over their values.
[23:46:23] <dcolish> strcat: right, i had read that earlier
[23:46:36] <strcat> and I'm fine with writing external iterators for the trees in the stdlib, in fact TreeMap had the first external iterator
[23:46:58] <aatch> doener, thats... something, I guess
[23:46:59] <dcolish> I dont think i used internal ones anyway
[23:47:13] <strcat> dcolish: if you're using for loops, you are
[23:47:21] <dcolish> i try not to
[23:47:23] <strcat> because it currently uses internal iterators
[23:48:03] <Sergio965> strcat: Internal iterators can allow for high-order function composition. External iterators cannot.
[23:48:16] <strcat> Sergio965: not at all true
[23:48:33] <strcat> in rust, internal iterators don't compose at all and can't be generic - they can't be mapped to traits
[23:48:43] <Sergio965> I meant in general.
[23:48:47] <engla> External Iterators are much trickier because there is no stack that hangs around to stick your temporaries to
[23:48:52] <strcat> in general, external iterators are more general and composable
[23:48:52] <Sergio965> Given that you pass a closure.
[23:49:02] <strcat> Sergio965: that's less composable
[23:49:04] <strcat> especially in rust
[23:49:12] <strcat> where closures are very restricted
[23:49:30] <strcat> Sergio965: compare std::iterator to the mess you get when trying to write internal iterator adaptors
[23:49:48] <Sergio965> Fair enough. What I mean to say is that the composition is hidden from the user.
[23:49:57] <strcat> Sergio965: it is with external ones
[23:50:00] <strcat> it's not hidden with internal
[23:50:11] <dcolish> external itors feel much more like a functional language
[23:50:12] <engla> each iterator adaptor is very simple
[23:50:13] <strcat> foo().skip(2).map(
[23:50:25] <strcat> foo().skip(2).map(|x| x * 2).fold(0, |a, b| a + b)
[23:50:30] <strcat> that's with external iterators
[23:50:37] <strcat> now try internal ones
[23:50:39] <dbaupp> dcolish: yeah, it's nice!
[23:51:04] <dcolish> i personally like the chaining syntax, esp since all exprs return their last value
[23:51:13] *** Quits: cr (anonymous@moz-5E05F028.dip0.t-ipconnect.de) (Ping timeout)
[23:51:15] <Sergio965> strcat: Uhâ€¦ fold(map(skip(foo())))...
[23:51:20] <strcat> fold(0, |f| map(|x| x * 2, |f| skip(2, |f| foo(f), f)
[23:51:25] <strcat> the same thing with internal iterators in rust
[23:51:31] <strcat> Sergio965: doesn't work that way
[23:51:36] <strcat> Sergio965: rust doesn't have variadic functions
[23:51:45] *** Quits: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Ping timeout)
[23:52:03] <Sergio965> strcat: Right, we had this discussion the other day. I'm speaking in general.
[23:52:12] <cmr> We're in #rust thoughg
[23:52:18] <strcat> Sergio965: in general, internal iterators don't compose as well because they can't be represented with a type class
[23:52:24] <Sergio965> Just to be clear, I'm not arguing for internal iterators.
[23:52:26] <strcat> they can't be extended with default methods or extension treaits
[23:52:29] <strcat> traits*
[23:52:41] <strcat> Sergio965: so what's the internal iterator type class? if they're so composable
[23:52:52] <strcat> how do you write zip, merge or union between two internal iterators?
[23:52:57] <strcat> you can't
[23:53:02] <aatch> Rust != Haskell with C-style syntax
[23:53:15] <cmr> http://rustlog.octayn.net/post/54787186308/status-update, 'night all
[23:53:25] *** Joins: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com)
[23:53:57] <strcat> haskell has laziness so the concepts from there don't map to rust
[23:54:01] <dcolish> aatch: i'd compare it to Ocaml before haskell :)
[23:54:03] <Sergio965> strcat: I agree that external iterators are more composable. I mispoke in my original statement. What I was trying to convey was that, by passing a closure, the internal iterator is free to do with it what they want. In this sense, it can "compose" upon my function as it likes.
[23:54:19] <strcat> Sergio965: it can't though because it can't store the state
[23:54:28] <strcat> it can't zip your iterator with another
[23:54:32] * strcat shrugs
[23:54:46] <strcat> Sergio965: everything an internal iterator can do, an external iterator can do - because it can accept a closure
[23:54:58] <strcat> that's how they have to deal with 'for' right now, the advance method
[23:55:09] *** Joins: sigma1 (sigma@51C589B3.EF2694B5.DFAC6AA7.IP)
[23:55:18] <engla> you can convert an internal iterator to an external if you do it like go.. run the int. iterator in one task, send the elements in a buffered channel.
[23:55:38] <Sergio965> strcat: In any case, I think it's fair to say internal iterators are generally easier to implement.
[23:55:51] <strcat> Sergio965: for recursive traversal, sure
[23:55:59] <Sergio965> strcat: Specifically because you don't have to worry about state.
[23:56:06] <strcat>         match (self.a.next(), self.b.next()) {
[23:56:08] <strcat>             (Some(x), Some(y)) => Some((x, y)),
[23:56:10] <strcat>             _ => None
[23:56:12] <strcat>         }
[23:56:14] <strcat> that's the zip implementation, pretty trivial
[23:57:02] <Sergio965> strcat: Rust does a good job here.
[23:57:13] <strcat> I don't think it's actually any harder to put your local variables in a struct
[23:57:29] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[23:57:38] <strcat> the lifetime issues you get from the internal iterator closure are much more painfu;l
[23:57:51] *** Quits: sigma1 (sigma@51C589B3.EF2694B5.DFAC6AA7.IP) (Quit: Leaving.)
[23:58:04] <Sergio965> strcat: What if you're doing DFS on a tree? Now you have to keep a stack.
[23:58:13] <strcat> Sergio965: sure, a recursive traversal
[23:58:21] <strcat> and rust will eventually support 'yield'
[23:59:04] <strcat> currently bad language support for external iterators doesn't mean they are harder to use
[23:59:25] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[23:59:25] <strcat> f(value) -> yield value, done
[23:59:28] <Sergio965> I simply believe there are use cases for both internal and external iterators.
[23:59:36] <strcat> Sergio965: what's the use case for an internal iterator then?
[23:59:43] <Sergio965> The one I just mentioned.
[23:59:50] <strcat> Sergio965: I don't see that
[23:59:59] <strcat> how is it easier than language support for external iterators?

[00:00:00] <jvns> Eridius: okay, thanks!
[00:00:01] <Eridius> jvns: the closest you can come is `use stdio::*` but that pulls in *everything*, and also is feature-gated
[00:00:11] <jvns> yeah I saw that
[00:00:32] <mitsuhiko> Eridius: wouldn't that defeat the purpose? the moment you wildcard import names you have no idea where a name came from
[00:00:41] <halp39250> mitsuhiko: It's an entirely fresh source tree straight from github. :/. I could make clean it, but I'd be out another few hours time and I don't think it'd change anything.
[00:00:46] <mitsuhiko> the alternative is to scope the enum fields under the enum name obviously
[00:01:07] <mitsuhiko> halp39250: what platform are you on?
[00:01:13] <Eridius> mitsuhiko: it would be nice if you could say something like `use stdio::Color(..)` to pull in all variants of stdio::Color
[00:01:19] <halp39250> x86_64 OSX 10.9
[00:01:35] <mitsuhiko> Eridius: sure, but that's no better than ::*
[00:01:36] <halp39250> cross compiling for i686 generic linux
[00:01:44] <halp39250> (in theory)
[00:02:02] <mitsuhiko> halp39250: why gcc and not clang?
[00:02:16] <mitsuhiko> i did not know rust compiles anything with gc
[00:02:17] <mitsuhiko> *gcc
[00:02:22] <Seldaek> Eridius: yup something for enum variants would be nice, or at least if you could import the enum and refer to the variants with Color.Red for example (can you?)
[00:02:44] <Seldaek> it'd remove the *-like ambiguity 
[00:02:48] <Eridius> Seldaek: I would also accept accessing variants scoped under the enum name. But you can't do that now
[00:02:49] <mitsuhiko> any sort of wildcard import will make it hard to figure out where a symbol came from, so it sounds a bit pointless
[00:03:03] <halp39250> I'm not sure, honestly. I let configure do its thing. Rust shouldn't use clang for its actual builds, but llvm seems to have wanted to use gcc
[00:03:10] <Eridius> incidentally, extra::term has a sub-module ::color precisely for this purpose, so you can `use extra::term::color` and then use `color::RED` in your code
[00:03:12] <dbaupp> mitsuhiko, Eridius, Seldaek: https://github.com/mozilla/rust/issues/10090
[00:03:14] <halp39250> er, poor wording
[00:03:26] <halp39250> rust shouldn't need clang to build itself
[00:03:36] <Seldaek> Eridius: I think Enum.Variant would also be clearer for newcomers, having variants as standalone entities in the code still trips me up :p
[00:03:57] <halp39250> I could make clean & try clang, I suppose
[00:04:08] <Seldaek> it's a great thing though, but feels like it's breaking some law of physics  
[00:04:17] <Eridius> dbaupp: hmm. I trust the last code example in "The possible solution" was supposed to say `pub enum mod Sigil`?
[00:04:30] <SiegeLord> It's consistent with how sum types work in other langauges
[00:04:53] <mitsuhiko> dbaupp: +1 on the scoping down, but you should be able to use and reexport them
[00:04:57] <dbaupp> Eridius: "Sigil"?
[00:04:58] <mitsuhiko> otherwise None and Some() will be annoying
[00:05:11] <dbaupp> oh, right
[00:05:22] *** Quits: Jesin (Jesin@moz-27916D21.washdc.fios.verizon.net) (Ping timeout)
[00:05:24] <halp39250> side question: what happened to managed closures?
[00:05:32] <mitsuhiko> but that's fine if you can do something like "use Option::Some";
[00:05:35] <dbaupp> Eridius: I guess so (it's kimundi 's proposal.)
[00:05:42] <cmr> halp39250: way of the dinosaur, with managed boxes.
[00:05:50] <kimundi> hm?
[00:06:08] <halp39250> cmr: GC is going away?
[00:06:14] <Eridius> GC is going into the stdlib
[00:06:18] <cmr> halp39250: it's being liberated as a language concept.
[00:06:22] <Eridius> instead of @T you'll have Gc<T>
[00:06:31] <halp39250> hmm.
[00:06:43] * ChrisMorgan is pretty much going to use enum mod in certain places in rust-http whether it's a language feature or not
[00:07:01] <cmr> See pcwalton's blog, any of the recent meetings, etc
[00:08:42] *** Quits: geomyidae (quassel@DD6F7E3A.21468E9A.30200F38.IP) (Client exited)
[00:09:26] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[00:10:58] *** Quits: halp39250 (Mibbit@27A93EB4.DF4637DA.62D74A69.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[00:11:09] *** Joins: mib_1suiy5 (Mibbit@27A93EB4.DF4637DA.62D74A69.IP)
[00:11:48] <mib_1suiy5> would it be possible to turn @ into sugar for Gc<T>?
[00:11:51] <sfackler> ChrisMorgan: I hope that enum mod gets pulled into the language for rustdoc sanity more than anything else
[00:12:31] <Eridius> mib_1suiy5: there were proposals to do that a while ago. I think it's probably unlikely, but possible
[00:12:31] *** Quits: mib_1suiy5 (Mibbit@27A93EB4.DF4637DA.62D74A69.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[00:13:37] <ChrisMorgan> What would the expected syntax be? `box(Gc) foo`, `box foo in Gc`, something else?
[00:13:51] <Eridius> probably box(Gc) foo
[00:13:57] *** Joins: halp2934 (Mibbit@27A93EB4.DF4637DA.62D74A69.IP)
[00:14:07] <ChrisMorgan> (The latter would preclude the addition of an `in` operator to the language without significant pain.)
[00:14:21] <benh> box seems like a pretty cool keyword
[00:14:22] * Eridius still likes ~>Gc foo, but it sounds like Patrick et al don't want to keep ~
[00:14:34] <ChrisMorgan> So then it'd be `box() (1 + 2)`?
[00:14:43] * ChrisMorgan likes his ~ also
[00:14:44] <Eridius> probably. Which looks nasty to me, but oh well
[00:15:12] <Seldaek> ChrisMorgan: is this a real use case though?
[00:15:13] *** Quits: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com) (Ping timeout)
[00:15:32] <Eridius> Seldaek: ~(1+2) is perfectly valid today
[00:15:40] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[00:15:41] <ChrisMorgan> Seldaek: sure, though not with number literals
[00:16:07] <ChrisMorgan> Seldaek: you might have `set | another_set`, for example.
[00:17:00] <Seldaek> Eridius: valid is one thing, I wonder if one does need such constructs regularly, but I can't say I followed the whole thing so I'm not even sure what box() means at this point
[00:17:08] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[00:17:30] <ChrisMorgan> " Why is Rust interesting?" - https://news.ycombinator.com/item?id=6830192
[00:17:37] <ChrisMorgan> Whoa!
[00:18:27] <Seldaek> courageously posted as anon too
[00:18:56] * ChrisMorgan tries to decide whether to vote it down or not. Decides not to.
[00:19:19] <Seldaek> a smart answer beats a downvote :)
[00:20:18] <ChrisMorgan> Then someone will respond to *that* with something about feeding the trolls...
[00:20:25] <ChrisMorgan> s/.../…/
[00:20:58] * ChrisMorgan likes his Unicode fanciness ☺
[00:22:24] <halp2934> is the GC currently written in rust?
[00:22:54] <cmr> Eridius: I've always wanted a spermy operator..
[00:22:58] *** Joins: Jesin (Jesin@moz-27916D21.washdc.fios.verizon.net)
[00:23:31] <halp2934> cmr: you'd like haskell
[00:23:48] <cmr> (it was a joke, someone else made it in here before)
[00:23:54] <cmr> halp2934: thereis no GC right now
[00:24:03] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[00:24:13] <benh> ChrisMorgan: I like unicode, but the unicode ellipsis just looks wrong in monospace :(
[00:24:25] <halp2934> cmr: with 0.8, what happens when I attach an '@' sigil to something?
[00:24:39] <cmr> halp2934: @T is poorly-implemented reference counting.
[00:24:45] <cmr> With no cycle collector.
[00:24:57] <halp2934> cmr: Oh.
[00:25:03] <halp2934> Ouch.
[00:25:04] <mitsuhiko> i still hope @ sticks around as syntax for custom pointer types
[00:25:15] <sfackler> cycles are collected when the task exits, iirc
[00:25:26] <cmr> well, *all* @-boxes are freed at task exit
[00:25:41] <tiffany> is @GC T really any better than GC<T>?
[00:25:53] *** Joins: geomyidae (quassel@DD6F7E3A.21468E9A.30200F38.IP)
[00:25:59] <mitsuhiko> tiffany: not for declarations, but for operations with the pointers
[00:26:09] <mitsuhiko> without syntax support it will get super annoying if you need to start nesting closures
[00:26:16] *** Joins: lfox (lfox@moz-8631D08.nycmny.east.verizon.net)
[00:27:10] <halp2934> mitsuhiko: Ew. Angle brackets are already painful syntax imo.
[00:27:56] <strcat> halp2934: @ is feature gated now, not part of the stable language definition
[00:28:19] <strcat> mitsuhiko: well it's basically too late for that ;p
[00:28:27] <mitsuhiko> strcat: too late for what, syntax support?
[00:28:47] <strcat> as in it the decisions around this were made and it just has to be implemented now
[00:29:08] <tiffany> howcome @T and RC<T> have separate implementations?
[00:29:21] <tiffany> also, is GC<T> implemented?
[00:29:26] <mitsuhiko> Gc<T> exists
[00:29:27] <strcat> tiffany: Rc isn't slow
[00:29:39] <strcat> @ is slow and doesn't free memory promptly at all
[00:29:46] <cmr> it's also not compiler magic.
[00:30:08] <strcat> let x = @5; foo(x /* by-value */)
[00:30:13] <mitsuhiko> strcat: well, nothing is lost yet because both Rc and Gc are immutable, right?
[00:30:21] <strcat> the `x` variable has a refcount and it doesn't go away until `x` goes out of scope
[00:30:32] <strcat> mitsuhiko: there's Cell/RefCell for dynamic mutability
[00:30:44] <strcat> @mut T becomes Gc<RefCell<T>> atm
[00:31:12] <mitsuhiko> do i have to do x.borror_mut { … } or something of that sort with them?
[00:31:23] <strcat> mitsuhiko: no, there will be deref overloading for Gc/Rc
[00:31:30] <strcat> and RefCell uses RAII reference wrappers
[00:31:35] <halp2934> is mut being entirely replaced by cell/refcell, then?
[00:31:36] <strcat> so yes it's more painfukl
[00:31:38] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[00:31:41] <cmr> halp2934: no?
[00:31:43] <mitsuhiko> strcat: how does deref overloading work?
[00:31:45] <strcat> but it's also clearer that it's a possible dynamic failure
[00:31:47] <cmr> *what* mut
[00:31:49] <strcat> mitsuhiko: it will just be a trait
[00:31:49] <mitsuhiko> if it does not wrap in a closure
[00:32:01] <strcat> mitsuhiko: it doesn't return a ref, it returns a reference wrapper
[00:32:03] <strcat> with a dtor
[00:32:07] <mitsuhiko> ah
[00:32:29] <strcat> and the reference wrapper can have deref overloaded too
[00:32:41] <mitsuhiko> compile time++ ?
[00:32:44] <strcat> mmalecki: there will be a trait to overload the * operator and auto-deref will just work
[00:32:51] <strcat> no it won't really increase compile time
[00:33:04] <strcat> if anything it will decrease it if we drop take glue by removing the weird @ refcounting
[00:33:13] <mitsuhiko> that sounds not too bad then
[00:33:21] <mitsuhiko> i can live with the Foo<T> for declaring it
[00:33:35] <mitsuhiko> but if i would have to have closures everywhere i want to work with mutable boxes it would be hell
[00:33:41] <mitsuhiko> I never liked Arcs because of that
[00:34:15] <strcat> mitsuhiko: well we are getting rid of those closures in favour of RAII
[00:34:36] <mitsuhiko> will this affect (rw)arc too?
[00:34:48] <strcat> mitsuhiko: not sure
[00:35:08] <strcat> you could return an RAII reference object
[00:35:21] <halp2934> ^ what does that mean?
[00:35:39] <strcat> like a C++11 style mutex lock
[00:35:42] <mitsuhiko> strcat: and then just force people to make a scope to keep the lock time down?
[00:35:55] * benh wonders if we can come up with a less storied term than RAII
[00:35:58] <strcat> mitsuhiko: you could ignore(x) it too
[00:36:07] <mitsuhiko> strcat: ah. that would be nice
[00:36:10] <mitsuhiko> i thought that would not work
[00:36:17] <strcat> where ignore is just 'fn ignore<T>(_: T)'
[00:36:21] <strcat> there's util::ignore
[00:36:28] <strcat> mitsuhiko: well it will just move into ignore and drop it
[00:36:37] <strcat> ofc it gets inlined and just becomes a dtor call
[00:36:41] *** Joins: twb (textual@moz-5DE8950B.hsd1.ga.comcast.net)
[00:36:48] <mitsuhiko> benh: scoped
[00:37:00] <strcat> let _lock = mutex.lock();
[00:37:04] <strcat> and it releases in the dtor
[00:37:12] * strcat thinks that's a good example
[00:37:20] <strcat> http://en.cppreference.com/w/cpp/thread/lock_guard
[00:37:32] <mitsuhiko> i really like where this whole thing is going :)
[00:37:51] <halp2934> .. seems like one might just write c++
[00:37:59] <sfackler> strcat: I seem to remember that at some point "let _ = foo" was equivalent to "util::ignore(foo)". is that/was that ever the case?
[00:38:02] <mitsuhiko> strcat: can you do let _ = mutex.lock() or does that immediately unlock?
[00:38:23] <strcat> mitsuhiko: I think it was decided that _ will act like _x
[00:38:33] <strcat> but atm it doesn't (and is broken in funny ways too)
[00:38:50] <mitsuhiko> sounds like you could easily build a d like scope() statement with macros then
[00:39:39] <strcat> halp2934: taking good ideas from D and C++ doesn't make rust into those languages
[00:39:42] <sfackler> you almost can without macros at all, except for the lack of once stack closures
[00:39:49] <strcat> a major difference from C++ in regards to ownership is that rust moves by default
[00:39:53] <strcat> it doesn't have copy ctors
[00:39:57] *** Quits: jvns (bork@87D98E32.4046EB22.428F94DD.IP) (Ping timeout)
[00:40:04] <strcat> C++ copies by default, moves are explicit and you can easily get it wrong
[00:40:11] <mitsuhiko> strcat: just don't start doubting :)
[00:40:30] <mitsuhiko> there are lots of peopel that love where rust is heading and there is no reason to apologize for looking a bit like c++
[00:40:43] <strcat> it's supposed to look like C++ :p
[00:40:56] <mitsuhiko> and i'm greatful for that :)
[00:43:27] <strcat> closures are nice but they don't really play well with ownership, and using them excessively like the stdlib does leads to lots and lots of nested blocks
[00:44:40] <halp2934> yeah, I'm sorry; I got a caught up for a second in the c++-resemblance. I really appreciate the ways rust sets itself apart from c++. enums and pattern matching alone are enough to win me over.
[00:44:58] <strcat> safe references/iterators are a big thing
[00:45:17] <strcat> no iterator invalidation (although if you use Rc/Gc + RefCell you get something similar)
[00:45:40] *** Quits: lfox (lfox@moz-8631D08.nycmny.east.verizon.net) (Ping timeout)
[00:45:56] *** Quits: barosl (barosl@3DE683B6.E551553C.7544CABF.IP) (Quit: 랜덤은 쇠퇴했습니다.)
[00:46:00] *** Joins: derek_c (derek@moz-E72F174.cit.cornell.edu)
[00:46:17] <derek_c> Given a number N, what's the idiomatic way to loop N times?
[00:46:32] <halp2934> are you looping over a structure?
[00:47:24] *** Quits: glennsl (textual@moz-5D7B804F.getinternet.no) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[00:47:28] <derek_c> halp2934: 
[00:47:30] <derek_c> halp2934: no
[00:47:35] <dbaupp> derek_c: `for _ in range(0, N) { ... }`
[00:47:44] <sfackler> I've been using "for _ in range(0, N)", there's also "N.times(|| {...})"
[00:47:45] <derek_c> dbaupp: thanks :)
[00:48:07] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[00:49:08] <halp2934> how does rust make iterators safe?
[00:49:49] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[00:50:01] <halp2934> move semantics?
[00:50:27] <cmr> no, the borrowing rules.
[00:50:35] * cmr has to run  though
[00:50:41] <halp2934> ah
[00:50:59] <halp2934> oh, and with refcells ..
[00:51:18] <dbaupp> just borrowing rules
[00:51:28] <mitsuhiko> yeah, borrorwing rules
[00:51:29] <strcat> mutability is inherited from the owner, and rust knows about the owner so it can statically prevent reference/iterator invalidation
[00:51:31] <halp2934> it seems refcells circumvent the rules
[00:51:40] <mitsuhiko> (the latter being a verb)
[00:51:44] <strcat> but with Rc and Gc, you don't have a single owner to inherit mutability from
[00:51:46] <strcat> so they are immutable
[00:51:50] <jmgrosen> hey, is there anyway to start the runtime from a call to an extern "C" fn? I asked this a while ago, but want to know if the situation has changed
[00:51:59] <strcat> and RefCell is a non-Freeze type, which means it doesn't inherit mutability
[00:52:03] <dbaupp> jmgrosen: yes
[00:52:06] <strcat> is is always mutable, and does dynamic freezing
[00:52:09] *** Joins: zslayton (Mibbit@moz-4806B979.nyc.res.rr.com)
[00:52:16] <dbaupp> jmgrosen: std::rt::start(...) or something like that
[00:52:26] <dbaupp> jmgrosen: you may have to consult the source to be sure
[00:52:42] <jmgrosen> dbaupp: I tried that a while ago... I'll try it again, thanks
[00:53:03] <dbaupp> jmgrosen: and there is some subtlety about getting crate maps and IO generators set up correctly; I believe it works much more smoothly with some recent work from acrichto though.
[00:53:08] <derek_c> rusti: let bytes: ~[u8] = [];
[00:53:08] -rusti- <anon>:9:28: 9:30 error: mismatched types: expected `~[u8]` but found `[<V7>, .. 0]` ([] storage differs: expected ~ but found 0)
[00:53:08] -rusti- <anon>:9          let bytes: ~[u8] = [];
[00:53:08] -rusti-                                      ^~
[00:53:08] -rusti- error: aborting due to previous error
[00:53:09] -rusti- application terminated with error code 101
[00:53:14] <halp2934> jmgrosen: you could manually link it ;P
[00:53:14] <derek_c> what's wrong with this code?
[00:53:18] <derek_c> let bytes: ~[u8] = [];
[00:53:20] <dbaupp> jmgrosen: (I don't know the subtlety.)
[00:53:26] <dbaupp> derek_c: ~[]
[00:53:40] <ChrisMorgan> A comment I just made about rust-http and its strong typing discipline for headers (in the "Scala—1 star" article it criticised Spray for doing much what I do with rust-http). https://news.ycombinator.com/item?id=6830384
[00:53:41] <jmgrosen> dbaupp: perhaps the recent static linking could also help
[00:53:56] <strcat> halp2934: RefCell just enforces the reference rules dynamically by allowing N immutable borrows or 1 mutable borrow
[00:54:09] <dbaupp> jmgrosen: probably, but I don't think that was the most fundamental issue
[00:54:22] <dbaupp> ChrisMorgan: "felt strongly about the typing" hah
[00:54:23] <derek_c> dbaupp: thanks
[00:54:25] <strcat> it has a borrow state (a count of borrows or whether it is a single mutable borrow)
[00:54:26] <jmgrosen> dbaupp: yeah, I think last time I tried it there was an issue with the crate map
[00:54:46] <strcat> same thing the compiler does statically for regular inherited mutability
[00:55:03] <ChrisMorgan> dbaupp: yeah, you can't help punning with such a topic.
[00:55:26] <dbaupp> jmgrosen: you'll have to take to acrichto for more info
[00:55:39] *** Joins: foobar (Mibbit@moz-7559582E.hsd1.ca.comcast.net)
[00:55:59] *** Joins: earlzlap (earlz@moz-483E1E31.neo.res.rr.com)
[00:56:06] <foobar> Hello
[00:56:09] <foobar> I have a question
[00:56:27] <foobar> Why should I learn Rust instead of Elixir/Erlang ?
[00:56:36] *** Quits: Axord (xord@moz-C0D5F15A.lsanca.dsl-w.verizon.net) (Quit: I'm sure it's perfectly safe)
[00:56:52] <halp2934> rust and erlang seem like they're for very different things
[00:57:08] *** Joins: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com)
[00:57:15] <foobar> Why did you jumped into Rust ?
[00:57:53] <halp2934> it's a lower-level language that has some of the cool features I've come to appreciate in higher-level languages
[00:58:00] <ChrisMorgan> foobar: performance is one important thing with Rust.
[00:59:03] <ChrisMorgan> Erlang is known for comparatively poor performance, while performance comparable with C is one of Rust's design goals.
[00:59:25] <halp2934> type inference, pattern matching, disjoint unions, safety with good performance
[00:59:48] <halp2934> erlang has poor performance in certain domains.. I wouldn't say it's poor on the whole
[00:59:50] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Ping timeout)
[01:00:19] <halp2934> but I'm not an erlang expert
[01:01:02] <foobar> Very compelling points. What's your take on the organization behind each language ?
[01:01:04] <ChrisMorgan> foobar: Rust looks like often being a more _practical_ language than Erlang
[01:01:17] <ChrisMorgan> Mozilla: can do no evil (just like Google :P)
[01:01:20] <mitsuhiko> it's easier to train people on rust than erlang :D
[01:01:26] <mitsuhiko> which says a lot
[01:01:49] <mark_edward> but Mozilla is paid by google
[01:02:03] <benh> Is it fair to call erlang less practical?
[01:02:07] <halp2934> erlang has some odd warts .. it was originally built in prolog and has odd string handling
[01:02:09] <mark_edward> which means Rust is a 90% google funded lnaguage
[01:02:18] *** Joins: ww (Mibbit@moz-185C323F.public.wayport.net)
[01:02:23] <halp2934> on the other hand, erlang is way more mature ..
[01:02:57] <mitsuhiko> halp2934: by odd string handling you mean no string handling :P
[01:03:17] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[01:03:39] *** Joins: Sharp (Sharp@moz-780FECDA.washdc.fios.verizon.net)
[01:03:57] <ww> what is the best way to do mix-in in rust?  i have some common method implementation in a trait.  can i just include those in other structs to pick up the common methods?
[01:04:04] <tiffany> mozilla sees the need for a type-safe memory-safe system's language in a world of 0days and ever more important software systems, which is why we have rust
[01:04:28] <tiffany> erlang is not in the same domain as C++ or C, whereas rust is
[01:04:34] <strcat> ww: hm?
[01:04:42] <halp2934> tiffany: that's the key point
[01:04:48] <halp2934> apples and oranges
[01:04:52] <ww> strcat: hm?
[01:04:57] <mitsuhiko> ww: not quite sure what you mean, but you can extend traits with more methods
[01:04:58] <ww> what about hm?
[01:05:00] <strcat> ww: you have trait inheritance, default methods and generic impls to leverage
[01:05:03] *** Quits: Sharp (Sharp@moz-780FECDA.washdc.fios.verizon.net) (Quit: Sharp)
[01:05:11] <snerd> next up, firefox rewrite in rust
[01:05:21] <halp2934> snerd: good luck with that O.o
[01:05:29] <ww> ok, i'll look into default methods and generic impl
[01:05:31] <tiffany> firefox wouldn't be rewritten in rust
[01:05:40] <foobar> What about Rust maturity ? When do you guys think people could launch production ready systems ?
[01:05:41] <snerd> halp2934: it's probably just a weekend's work. easy.
[01:05:44] <tiffany> there is servo, however
[01:05:52] *** Joins: lpy (lpy@12172131.F09091A8.1348A864.IP)
[01:06:00] <strcat> firefox could *use* runtimeless rust, or libraries written in it
[01:06:23] <mitsuhiko> dom and javascript for a start
[01:06:48] *** Joins: Sharp (Sharp@moz-780FECDA.washdc.fios.verizon.net)
[01:07:00] <halp2934> foobar: rust is nowhere near ready for production anything
[01:07:23] <strcat> the language is pretty solid now
[01:07:31] <SiegeLord> Some people use it in production :p
[01:07:35] <mark_edward> solid != stable
[01:07:46] *** Quits: lpy (lpy@12172131.F09091A8.1348A864.IP) (Client exited)
[01:07:48] <SiegeLord> You just have to make allowances for the language changing every few days
[01:07:50] <mark_edward> i can run 5 year old C++ code safely. not rus
[01:07:58] <mark_edward> s/rus/rust
[01:08:06] <strcat> mark_edward: I doubt the C++ code is correct, though
[01:08:07] <Earnestly> s/rus/&t
[01:08:09] <strcat> probably memory unsafe ;p
[01:09:06] <mitsuhiko> mark_edward: you also can't run 5 year old go code
[01:09:07] <mark_edward> strcat, not neccesarily... it'shard but i built plenety of safe container and such in C++ pre C++11. don''t know how safe they weer
[01:09:09] <mitsuhiko> :P
[01:09:15] <mark_edward> mitsuhiko, true\
[01:09:36] <strcat> mark_edward: C++11 isn't more memory safe than C++98
[01:09:41] <mythmon> I still don't understand how to convince the compiler about lifetimes. https://pastebin.mozilla.org/3702410
[01:09:57] <strcat> the improvements around ownership add more ways to get stuff wrong for the sake of performanc
[01:09:59] <strcat> e
[01:10:10] <strcat> now you don't just have lvalues/rvalues anymore
[01:10:45] <mark_edward> strcat, std::unique_ptr<T> = ~T
[01:10:51] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[01:10:53] <strcat> and?
[01:11:06] <strcat> that's not part of what makes rust safe, other languages have dtors
[01:11:35] <mark_edward> strcat, how many other languages have deterministic destructors? can't think of any? Not Java, not C#, not Go, not D,
[01:11:47] <strcat> D has deterministic dtors
[01:11:55] <mark_edward> object destrucition is non-deterministic thanks to the Garbage collectioon
[01:11:55] <SiegeLord> D has them for structs allocated on the stack
[01:12:07] <mark_edward> but not by default for things
[01:12:11] <strcat> mark_edward: you can write a garbage collector for some class of C++ objects too
[01:12:19] <mark_edward> which is what C++ and Rust have
[01:12:22] <ChrisMorgan> (BTW, mark_edward: pong for 24¾ hours ago)
[01:12:25] <mitsuhiko> … and people do that. microsoft's new c++ is barely c++ any more
[01:12:36] <Earnestly> mitsuhiko: link?
[01:12:36] <mitsuhiko> it's garbage collection left and right
[01:12:45] <mletterle> Eh... ChrisMorgan saw your comment on HN re: scala blog post.. thought of rust-http as well.
[01:12:46] <strcat> mitsuhiko: I mean without a language extension though
[01:12:46] <halp2934> boehm, anyone?
[01:12:52] <mark_edward> ChrisMorgan, how can we integrate cookies into rust-http? cookie andling would make OAuth much easier
[01:13:00] <strcat> mitsuhiko: C++11 even added really crappy gc support
[01:13:04] <strcat> to make them less conservative
[01:13:06] <ChrisMorgan> mark_edward: it just needs doing; it's not particularly difficult.
[01:13:10] <mark_edward> mletterle, can u llink this comment
[01:13:10] <halp2934> shared_ptrs are GC
[01:13:19] <mitsuhiko> microsoft is all over garbage collected c++ now. all of their winrt stuff is full of it.
[01:13:36] <mark_edward> but garbage collection makes destruction non deterministic
[01:13:38] <mletterle> mark_edward: Here's the whole thread: https://news.ycombinator.com/item?id=6829725
[01:13:46] <halp2934> shared_ptrs are nondeterministic
[01:13:51] <mark_edward> and by Default D objects are not deterministic, you have to make them so
[01:13:51] <strcat> halp2934: no they aren't
[01:14:04] <strcat> shared_ptr is based on destructors
[01:14:18] <strcat> just like rust's Rc
[01:14:18] <mitsuhiko> Earnestly: just look at the winrt examples on msdn
[01:14:26] *** Quits: Jesin (Jesin@moz-27916D21.washdc.fios.verizon.net) (Ping timeout)
[01:14:27] <halp2934> you never know how many other shared_ptrs depend on any given shared_ptr
[01:14:36] <strcat> halp2934: which isn't non-deterministic
[01:14:47] <foobar> @halp2934 what would a newbie to Rust could help with ? 
[01:15:04] *** Quits: tiffany (kawaii@moz-FC0DB29D.dhcp.embarqhsd.net) (Input/output error)
[01:15:15] <halp2934> you never know how long it's going to take to free everything when a given shared_ptr goes out of scope
[01:15:28] <strcat> halp2934: it's not non-deterministic though
[01:15:36] <strcat> it's still stack discipline
[01:15:40] <halp2934> well it isn't deterministic
[01:15:42] <strcat> just with more than 1 reference to go out of scope
[01:15:46] <strcat> it is deterministic
[01:16:01] <mark_edward> shared_ptr is deterministc just harder to igure out
[01:16:05] <bascule> "Why is Rust interesting?" https://news.ycombinator.com/item?id=6830192
[01:16:31] <mitsuhiko> strcat: well yeah, microsoft made tons of language extensions for it
[01:16:46] <strcat> https://github.com/thestinger/rust-core/blob/master/core/arc.rs this is the same thing as shared_ptr
[01:16:46] <mitsuhiko> but if you do any windows / xbox one development you will be forced to use all of that stuff
[01:16:48] <halp2934> foobar: not sure what you mean
[01:16:50] <strcat> atomic refcounting based on dtors
[01:16:57] <mythmon> Can someone tell me what's wrong here? I know I need to say something about lifetimes, but everything I tried doesn't work: https://pastebin.mozilla.org/3702410
[01:17:05] <strcat> it's still completely deterministic because dtors are
[01:17:09] <mark_edward> mitsuhiko, i hate Microsoft C++ extensions
[01:17:13] <mark_edward> it's no longer C++
[01:17:18] <mark_edward> stupid hat operator
[01:17:23] <SiegeLord> Who's the steward for rustdoc these days? I want to have a placeholder text added to the search bar
[01:17:52] <ChrisMorgan> SiegeLord: what would you add?
[01:18:01] <SiegeLord> "Search documentation..."
[01:18:44] <halp2934> strcat: I still don't understand. If I have, say, a linked list based on shared_ptrs, then when the last list reference goes out of scope, I could have to free arbitrarily many list nodes before the program continues
[01:19:13] <strcat> huh?
[01:19:31] <strcat> and if you have a list built on unique ptrs, when it goes out of scope, you could have to free arbitrarily many list nodes
[01:19:34] <strcat> neither is non-deterministic
[01:20:07] <halp2934> you wouldn't be able to determine how long a function would pause before continuing
[01:20:12] *** Quits: sk (sk@61A494B3.BA40E8A.AAC02D62.IP) (Quit: Leaving)
[01:20:16] <mythmon> strcat: are you talking about determinism as in *when* the dtor would run? or how long it would take?
[01:20:18] <zslayton> foobar: The Rust repository on GitHub maintains a list of open tasks that are considered to be easy: https://github.com/mozilla/rust/issues?labels=E-easy&page=1&state=open
[01:20:29] <strcat> mythmon: both, neither is non-deterministic with shared_ptr
[01:20:34] <mythmon> ok
[01:21:17] <halp2934> how could you know how long the program would have to pause to free a list of shared_ptrs?
[01:21:22] <mark_edward> both are deterministic jhust dificult to determine
[01:21:37] *** Joins: MrOrdinaire (Mibbit@16850B5C.682C98F1.FD383126.IP)
[01:21:37] <ChrisMorgan> foobar: but E-easy does *not* necessarily mean easy for an outsider; it means something closer to straightforward than easy.
[01:21:43] <strcat> halp2934: how could you know how long the program would have to pause to free a list of unique_ptr?
[01:21:47] <strcat> it's not a different question
[01:21:53] <strcat> neither is *non-deterministic*
[01:21:57] <foobar> I can see that.
[01:21:59] <mark_edward> the movment of billiard balls when you break is deterministc, but not necessarily easy to determine
[01:22:09] *** Joins: glennsl (textual@moz-5D7B804F.getinternet.no)
[01:22:17] <strcat> if you write a single-threaded, simple program that's deterministic (same series of instructions on every execution) and then add heavy usage of std::shared_ptr it's still going to be deterministic
[01:22:22] *** Joins: Skif (emschwar@moz-4C5BB5A8.beyondbb.com)
[01:22:23] <strcat> it will still do the same thing every time
[01:22:23] <zslayton> ChrisMorgan: Ah, thanks for clarifying that.
[01:22:33] <foobar> Thank you all for your interest in passing your opinion. Definitely I can feel rust-ers are more than passionate.
[01:22:48] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[01:22:50] <mark_edward> i prefer the term, rustaceans
[01:22:55] <ChrisMorgan> Rustics.
[01:23:04] <halp2934> strcat: is gc deterministic then?
[01:23:05] <ChrisMorgan> Rustaceans isn't too bad, though.
[01:23:13] <strcat> halp2934: most aren't
[01:23:20] <strcat> you can write a deterministic gc implementation
[01:23:20] <foobar> rust[ceans|ics|ers] thank you very much! :D
[01:23:23] <Eridius> mark_edward: haven't heard that one before. That's cute
[01:23:25] <dbaupp> SiegeLord: just open a PR?
[01:23:36] *** Joins: jvns (bork@87D98E32.4046EB22.428F94DD.IP)
[01:23:38] <mletterle> ooh Rustaceans.. *makes note for next good morning messages"
[01:23:46] <SiegeLord> dbaupp: More efficient of my time to test waters before rebuilding Rust :P
[01:23:49] *** Quits: jvns (bork@87D98E32.4046EB22.428F94DD.IP) (Quit: Ex-Chat)
[01:23:51] <strcat> halp2934: gc usually isn't deterministic because it will run cycles based on time/synchronization and your program will do different stuff every time
[01:24:00] *** Joins: jvns (bork@87D98E32.4046EB22.428F94DD.IP)
[01:24:05] *** Quits: Skif (emschwar@moz-4C5BB5A8.beyondbb.com) (Ping timeout)
[01:24:06] *** Joins: amphibulus (Mibbit@moz-D26F0273.protectedgroup.com)
[01:24:16] *** Quits: amphibulus (Mibbit@moz-D26F0273.protectedgroup.com) (User has been banned from Mozilla (no spamming here))
[01:24:28] <halp2934> strcat: what if I allocate shared_ptrs based on time and allocate differently every time?
[01:24:33] <ChrisMorgan> foobar: you're welcome! Join in the fun of working with a developing language; it really is good fun, even if you get the occasional frustration of having to fix code to match language/standard library changes rather than writing new code.
[01:24:38] *** Quits: MrOrdinaire (Mibbit@16850B5C.682C98F1.FD383126.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[01:24:46] <strcat> halp2934: if you allocate unique_ptr like that it will be the same
[01:24:49] <strcat> it doesn't make sense to do that
[01:24:58] <dbaupp> SiegeLord: if you're just editing rustdoc the rebuild should be pretty short (since nothing depends on rustdoc, and so doesn't need the full bootstrap)
[01:25:13] *** Quits: twb (textual@moz-5DE8950B.hsd1.ga.comcast.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[01:25:26] <halp2934> strcat: can you point me to any reading on shared_ptrs and determinism?
[01:25:41] <strcat> no, I can't, but if you know how it's implemented it should be obvious that it's deterministic
[01:25:49] <strcat> it's just a normal type implemented via a dtor
[01:25:50] <mark_edward> halp2934, deductively reason it
[01:25:55] <strcat> it's not supported at a language level
[01:25:58] <foobar> @ChrisMorgan I appreciate it. I'll be around
[01:25:59] <mark_edward> what srcat said
[01:26:10] <mark_edward> it just has a refcount, like std::rc::RC
[01:26:18] <halp2934> I get that you know when a reference will be decremented
[01:26:19] <mark_edward> but he refcount can be determinte
[01:26:21] <strcat> halp2934: https://github.com/thestinger/rust-core/blob/master/core/rc.rs there's nothing non-deterministic here
[01:26:30] <strcat> halp2934: you also know when it's incremented
[01:26:32] <halp2934> but you don't know how many other shared_ptrs depend on any given other shared_ptr
[01:26:44] <mark_edward> halp2934, you do
[01:26:44] <strcat> you don't know how many items are in a std::vector
[01:26:48] <strcat> doesn't make it non-deterministic
[01:26:57] <strcat> if by "don't know" you mean "determined at runtime"
[01:27:00] *** Quits: nsf (nsf@moz-EEF3238A.convex.ru) (Quit: WeeChat 0.4.2)
[01:27:01] <strcat> which doesn't mean non-determinism
[01:27:05] <ChrisMorgan> We need a formal mailing list thread some month (but NOT yet!) about what nouns to use for persons using Rust. Rustics, Rustaceans, Rusters, Rusty folks, &c. (Python tends to have "Pythonistas". It's tragic "snake charmers" wasn't adopted.)
[01:27:45] <halp2934> I would take deterministic to mean you're able to predict how it will run before you run it.
[01:27:48] *** Joins: aatch (James@moz-B437F499.pocketrent.com)
[01:27:49] <bjz> strcat: what would a better name for GenericPort::recv_iter be?
[01:28:21] <bjz> strcat: seeing as we are moving away from the `_iter` suffix
[01:28:36] *** Joins: Sorella (quildreen@9D963F5D.DF5D8AE7.54BCAB54.IP)
[01:28:44] <strcat> halp2934: if you're talking about deterministic code execution or algorithms, it means with the same inputs the program will run the same series of instructions
[01:28:47] <dbaupp> bjz: I wouldn't worry too much
[01:28:58] <Eridius> halp2934: deterministic typically means if you run it multiple times (with the same input each time) it will behave the same each time
[01:29:02] <dbaupp> bjz: recv_iter is fine in that instance, imho
[01:29:17] <bjz> <3 <3 recv_iter
[01:29:19] <strcat> (behave as in the internal execution is the same too)
[01:29:29] <halp2934> ah
[01:29:33] <bjz> (yes, I know, I made it)
[01:29:35] <Eridius> strcat: well, observable behavior is th same
[01:29:37] <Eridius> *the
[01:29:40] *** Joins: Ralith (ralith@moz-132F2FD4.sea.wa.customer.broadstripe.net)
[01:29:48] <strcat> if you run a deterministic program with some input and print out the exact series of instructions it executes, it will be the same for every run
[01:29:55] *** Joins: twb (textual@moz-5DE8950B.hsd1.ga.comcast.net)
[01:30:02] <strcat> and shared_ptr definitely qualifies as deterministic
[01:30:03] <halp2934> yeah, I see how shared_ptrs are deterministic in that respect
[01:30:07] <Eridius> strcat: well by that definition every multithreaded program is nondeterministic
[01:30:15] <halp2934> yeah
[01:30:18] <strcat> Eridius: they are ;p
[01:30:28] <Eridius> if their observable behavior is the same, they're deterministic
[01:30:32] <strcat> Eridius: no
[01:30:43] <strcat> randomized quicksort has the same deterministic behaviour every time
[01:30:46] <strcat> it sorts
[01:30:50] <strcat> it's not a deterministic algorithm
[01:30:54] <strcat> it's not what it means
[01:31:00] <strcat> the internal state is relevant
[01:31:08] <Eridius> i.e. spawn a second task, do a few things, wait for that task to complete, read its result. It doesn't matter how execution of that task is interleved with execution of the original task, if all possible interleavings have the same observable behavior (which they do in this case if the tasks don't share memory or I/O)
[01:31:17] <strcat> Eridius: it's not deterministic
[01:31:25] <strcat> unless you qualify it as saying 'the behaviour of each thread is deterministic'
[01:31:35] <Eridius> strcat: randomized quicksort is not deterministic because the performance difference can be measured
[01:31:36] <strcat> which yes, you can say, but it's not true of most multithreaded programs
[01:31:49] <Eridius> s/can be measured/is observable/
[01:31:55] <strcat> Eridius: it doesn't matter
[01:31:57] <halp2934> even then, the sum of deterministic threads isn't necessarily deterministic
[01:32:02] *** Joins: Jesin (Jesin@moz-27916D21.washdc.fios.verizon.net)
[01:32:10] <strcat> not what deterministic means in regards to code/algorithms
[01:32:15] <Eridius> halp2934: true, but in the particular example I gave it should be
[01:32:18] <strcat> CPUs aren't 'deterministic' really
[01:32:54] <halp2934> I feel this conversation taking a philosophical turn
[01:33:03] <Eridius> you have to draw the line somewhere. Defining 'deterministic' to automatically exclude all multithreaded programs seems unnecessarily limiting
[01:33:08] <mletterle> Wow.. wasn't expecting TWiR to get that many upvotes on HN.. nice.
[01:33:17] <strcat> Eridius: it doesn't exclude them
[01:33:18] <Eridius> I see no point in trying to include unobservable details in the definition of 'deterministic'
[01:33:24] <strcat> the behaviour of the process as a whole isn't deterministic
[01:33:34] <Eridius> strcat: it does, because you've defined unobservable details, i.e. how the thread scheduler allocates CPU slices, to affect determinisim
[01:33:41] *** Quits: jstevans1 (Instantbir@moz-8DBF3BC4.washdc.fios.verizon.net) (Ping timeout)
[01:33:43] <halp2934> eridius: I think it's important from the perspective of language design.. just because you don't get caught doing it doesn't mean it doesn't matter
[01:33:46] <strcat> Eridius: we are ignoring the CPU here because in that case no code is deterministic
[01:33:56] <strcat> (and ignoring kernels)
[01:34:14] <halp2934> .. the illusive triple-negative
[01:34:20] <strcat> anyway I'm not sure what you're trying to say if you're saying that the internal states don't matter
[01:34:30] <strcat> by that definition, referential transparency == deterministic
[01:34:45] *** Quits: foobar (Mibbit@moz-7559582E.hsd1.ca.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[01:34:46] <ww> can default method in a trait access the fields of the struct impls the trait?
[01:35:04] <geomyidae> so if I have a *u8 and a length from C, whats the idiomatic way of convertign that to a slice. And would that be common to do at a rust-c barrier to make it a bit nicer?
[01:35:13] <strcat> ww: no, the trait doesn't know which struct is going to implement it
[01:35:26] <strcat> it can call other trait methods or methods defined by traits the trait inherits from
[01:35:27] <Eridius> strcat: well no, referential transparency doesn't necessarily mean that all observable aspects of a program are unchanged when replacing an expression with its value
[01:35:32] <ww> bummer, then it's not that useful.  can't do mix-in with it.
[01:35:47] <strcat> Eridius: observing has nothing to do with it
[01:35:53] <halp2934> ww: you could if you place another trait constraint on the type
[01:35:55] <strcat> Eridius: you can observe the instructions that execute
[01:36:06] *** Joins: frogmella (Mibbit@moz-EAEA4C52.dsl.frs2ca.sbcglobal.net)
[01:36:24] <strcat> I'm not sure where you're getting that definition from because I've never heard it before.
[01:36:34] *** Quits: frogmella (Mibbit@moz-EAEA4C52.dsl.frs2ca.sbcglobal.net) (Quit: http://www.mibbit.com ajax IRC Client)
[01:36:48] <Eridius> strcat: if you're talking about observing executing instructions, then again, nothing is deterministic on a multithreaded OS (or, really, any OS at all because of interrupts)
[01:36:49] <strcat> a program is basically a state machine
[01:36:52] *** Joins: lpy (lpy@7360AA58.F09091A8.1348A864.IP)
[01:36:57] <strcat> if the transitions between states are the same every time, it's deterministic
[01:36:59] <strcat> that's what it means
[01:37:23] <strcat> Eridius: and again, deterministic means the state transitions are the same every time
[01:37:30] <strcat> I have never seen a definition of it related to things you can observe
[01:37:31] <halp2934> suppose you factor out a state transition so that it looks the same every time, but in the middle of one of the transitions, some weird stuff happens
[01:37:32] <Eridius> strcat: that's not the definition you used earlier
[01:37:38] <strcat> Eridius: it is
[01:37:42] <strcat> instructions == state transitions
[01:37:47] <strcat> the instruction ptr is state
[01:37:47] <Eridius> strcat: no, earlier you said that the instruction sequence that's executed has to be identical
[01:37:51] <strcat> yes
[01:37:55] <strcat> the series of state transitions
[01:38:08] <Eridius> which completely excludes determinisim when multiple threads are considered
[01:38:16] <strcat> it excludes it for the process as a whole
[01:38:24] <strcat> you can still talk about it in terms of individual ones
[01:38:24] <Eridius> which is unnecessarily limiting
[01:38:38] <ww> halp: that means the other trait needs to access the fields of the struct, which i need to i implement the accessors over and over again for all the structs mix-in the trait.
[01:38:47] *** Quits: blank_name (blank_name@FAB53C88.7071B2C8.31EC03F3.IP) (Ping timeout)
[01:38:52] <strcat> no, it's not unnecessarily limiting, it's why people talk about deterministic threading (as in the threads themselves have deterministic behaviour due to the communication protocols)
[01:38:55] <Eridius> with the state machine definition (which is perfectly reasonable), all you have to do is have a per-thread state (because that's what a program really does), and then for determinism purposes only care about where those per-thread state machines talk to each other
[01:39:10] <halp2934> ww: well at some point you need to access the struct fields
[01:39:29] <geomyidae> std::vec::from_buf is the answer to my question I think?
[01:39:33] <Eridius> strcat: with deterministic threading, the instruction sequence executed by the CPU isn't the same every time. Determinism is created via how the thread synchronize
[01:39:39] <halp2934> ww: maybe you should rethink how you've built your structs if you have so many you need to implement a trait for
[01:39:41] <Eridius> which is what I've been talking about
[01:39:51] <halp2934> ww: either that or consider a macro?
[01:40:05] <strcat> Eridius: the instructions executed by the individual threads are the same
[01:40:07] <ww> halp: i am hoping to have some way to implement common methods that can access "well known" fields of some structs.  the structs can pick up the implementation by just impl the trait
[01:40:22] *** Joins: jlong (jlong@moz-6DFDE846.socal.res.rr.com)
[01:40:28] <strcat> Eridius: and you can have a deterministic scheduler
[01:40:37] *** Joins: sp3d (s@6361F3B1.19CD1E54.8354FB35.IP)
[01:40:43] <Eridius> you don't need a deterministic scheduler in order to have determinism
[01:40:43] <strcat> not on a consumer CPU, sure ;p
[01:40:49] <Eridius> you just need to have deterministic thread synchronization
[01:41:15] <strcat> nevermind then, not getting across
[01:41:23] <halp2934> ww: do you have an example?
[01:41:34] <ww> halp: i have different struts that have the same fields over and over again, like the timestamp fields.  i want some common methods to operate on them that i can pick up on the structs.
[01:41:54] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.2)
[01:42:33] <ww> i could just have a util methods outside and pass those fields in, but then the methods are not together with the structs in one place
[01:42:45] <halp2934> ww: could you make a timestamp struct and then build your other structs around that?
[01:43:32] <geomyidae> rusti: let x = fn(s: ~str) {}
[01:43:34] -rusti- pastebinned 7 lines of output: http://sprunge.us/fjeH
[01:43:56] <ww> halp: sure i could.  i'm hoping rust supports the notion of mix-in to allow including common methods easily
[01:43:58] <geomyidae> is that not something I can do in rust? or am I just not finding the syntax?
[01:44:48] <geomyidae> never mind, I'm dumb
[01:45:45] <halp2934> ww: rust does support mixins but I don't think quite in that way.. you could probably get around it with a macro or by factoring out the timestamp part of the struct
[01:46:39] *** Quits: canhtak (canhtak@moz-A13A68C3.wl.t.ulaval.ca) (Ping timeout)
[01:47:18] <ww> halp: as i understood it, i can do default method as mixin but default method can't access the struct's fields, which make it not very useful.
[01:48:23] <halp2934> ww: I mean, you can't just pull a field out of nothing.. all you know is that you have a generic type
[01:48:50] <ww> but the type information is known when the trait is impl'ed by the struct
[01:48:52] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[01:49:42] <ww> the default methods of a trait should not be resolved at its compilation time.  it should be resovled when it's "used" (impl'ed)
[01:50:18] <halp2934> ww: but then what happens if you try to use a trait method on something that clearly doesn't implement it?
[01:50:33] <ww> then the compile would fail
[01:50:35] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[01:50:47] <halp2934> ww: but we wouldn't know that at compilation time; we'd only know that at runtime
[01:51:06] <halp2934> ww: rust is statically typed
[01:51:49] <ww> halp: when impl trait1 for struct1, the compilation of that can check the type.
[01:52:18] <halp2934> you'd have to check every possible place that trait method may be called .. that'd be like solving the halting problem
[01:52:49] <ww> hmm?  i don't get that.  
[01:53:12] <ww> there are two parts being compiled: the trait definition itself, and where the trait is being used in a struct
[01:53:12] *** Joins: canhtak (canhtak@moz-A13A68C3.wl.t.ulaval.ca)
[01:53:44] <ww> the compilation of the struct impl'ing the trait has all the type info to check
[01:54:09] <ww> the problem now is that the compilation of the trait itself requires all the type info upfront.
[01:54:50] <halp2934> the trait has to know that for any type it can be applied to that it's valid
[01:56:00] <ww> yes, when the trait is being applied to a struct, we can check.  the struct's field type info is available at that time.
[01:56:08] <halp2934> in a language like haskell, I'd get around it with a rank-2 type constraint, but I dunno that rust does that..
[01:56:19] <aatch> ww, functions, no matter where they are, have to be valid based only on information immediately available to the function.
[01:57:14] <ww> aatch: i think that's a problem.  a trait is like a template.  its compilation and type checking should be done when it's instantiated, i.e. when a struct is using it.
[01:57:28] <aatch> ww, but a trait is not like a template at all.
[01:58:00] <ww> aatch: i know.  i'm just saying it's kind of limited for the trait usage in rsut
[01:58:07] <halp2934> also, consider that it's trivial to upset your trait by adding a struct that breaks the trait
[01:58:11] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Ping timeout)
[01:58:12] <ww> like we can't do mix-in with trait
[01:58:50] <aatch> ww, that's not really what traits are intended for. They're closer to interfaces.
[01:58:51] <ww> halp: it's ok.  the compilation of the struct would fail.  just like a template being supplied the wrong type and its compiled fails
[01:59:28] <ww> aatch: well, trait was somehow billed as generic for rust
[01:59:41] <aatch> ww, it's *part* of generics, yes.
[02:00:16] <ww> aatch: ok, it's not the full support of generics but we need something better or extra to support those notions
[02:00:31] <halp2934> I'd like to see higher-rank types in rust
[02:00:36] <aatch> Also, doing typechecking like that would mean default methods would be type-checked entirely differently to every other function.
[02:00:51] <halp2934> aatch: not necessarily
[02:00:56] *** Quits: jlong (jlong@moz-6DFDE846.socal.res.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[02:01:10] <ww> aatch: that's fine.  let the compiler type-checked differently for different struct
[02:01:24] <aatch> halp2934, default methods are typechecked as if they were generic functions with the self argument bounded by the trait.
[02:01:42] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[02:01:57] <aatch> We don't do any typechecking based on implementation.
[02:02:38] <ww> but if we do typechecking at implementation time, then default method usage can be expanded greatly
[02:02:59] <halp2934> .. at the cost of breaking when anyone else tries to use your code
[02:03:08] <ww> anyway, just some feedback from field usage of rust :)
[02:03:45] <ww> halp: i don't understand why would it break anyone using my code?
[02:04:05] <halp2934> what if someone tries to link against your code and has a weird struct that can't implement your trait?
[02:04:13] <ww> e.g. trait t1 { fn add1(&self) {  self.sum +=1 } }
[02:04:32] <aatch> ww, part of the point of rust is to try to get away from obscure non-local errors that pop up in C++.
[02:04:37] <ww> struct s1 { sum }
[02:04:46] <ww> impl trait1 for s1
[02:05:06] <halp2934> suddenly every struct must have a sum method or your trait is invalid
[02:05:07] <ww> if i have struct s2 { no sum defined }
[02:05:20] <ww> impl trait1 for s2  would fail at compile time
[02:05:34] <halp2934> every type, full stop, must have a sum implementation :/
[02:05:38] <ww> that's ok.  that's the requirement to use the trait
[02:05:51] <aatch> So for generic functions, it ensures that all possible instantiations of that generic function are valid.
[02:05:55] <halp2934> what's the timestamp of false?
[02:05:59] <ww> just like a trait defines a method and requires all structs to impl that methods
[02:06:18] <halp2934> or bool
[02:06:19] <halp2934> w/e
[02:06:23] <ww> only the type that impl my trait needs to have sum
[02:06:45] <aatch> ww, but that isn't checkable based only on signatures.
[02:06:55] <ww> that's how trait is being used anyway.  whatever it defines, it requres the implementation to implement it
[02:07:11] <aatch> we only do local checking, so we can't peer into function bodies.
[02:07:27] <ww> aatch: that's true.  i don't know the detail of the compiler to see if it's possible
[02:07:59] <aatch> ww, it's got nothing to do with what is possible. It's because of the design principles.
[02:08:54] <ww> aatch: if that's not possible, then rust needs to support inheritance somehow
[02:09:04] <aatch> ww, that's in the works.
[02:09:13] <ww> oh, really?!!
[02:09:25] <aatch> ww, however, traits support some inheritance already.
[02:09:35] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[02:09:48] <ww> ok, then may be mix-in can be supported via inheritance
[02:09:51] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[02:10:20] <aatch> ww, remember that Rust is used for big software, there's rustc itself and the Servo browser engine.
[02:10:23] *** kimundi is now known as zz_kimundi
[02:11:20] <halp2934> aatch: hmm?
[02:11:34] <ww> aatch: yeah? :)  waiting for your thought
[02:12:25] *** Joins: vky (chatzilla@moz-4F2E17BF.dsl.dynamic.sonic.net)
[02:12:32] <bascule> https://github.com/mozilla/rust/issues/3429
[02:12:33] <bascule> hroom
[02:12:52] <aatch> Oh, I was just pointing out that there are large software projects written in Rust, so many of these issues have been encountered and discussed.
[02:13:50] <ww> aatch: ok.  i'm just reporting from the field use of it as well.
[02:13:52] <aatch> like, it turns out that traits + algebraic data types cover quite a lot of ground in terms of polymorphism.
[02:14:54] <halp2934> ^ see haskell
[02:14:58] *** Quits: twb (textual@moz-5DE8950B.hsd1.ga.comcast.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[02:15:11] *** Quits: maxli (maxli@moz-4D28BA20.student.cs.uwaterloo.ca) (Input/output error)
[02:15:33] <aatch> bascule, ah yes. That's a tricky case. It's got a lot to do with general coherence rules.
[02:15:45] <dbaupp> ww: the current plan is single inheritance of structs only http://smallcultfollowing.com/babysteps/blog/2013/10/24/single-inheritance/
[02:16:12] <ww> aatch: ok.  what's the best way to handle the case i encounter?  i have common fields in multiple structs that i want to have common methods to operation on them?
[02:16:36] <aatch> ww, split the common fields out to their own struct.
[02:17:08] <ww> ok, if that's the only way
[02:17:12] <halp2934> ww: composition vs inheritence
[02:17:44] <halp2934> ww: you should be able to spit out a one-liner / macro for anything containing your struct
[02:18:38] <heftig_> what does go do again? composition and letting you call methods meant for a field on the struct itself?
[02:19:08] <halp2934> you could also use a genericized function instead of a trait
[02:19:09] <aatch> heftig_, some hell-spawned hybrid.
[02:19:09] <ww> i'm providing an api on the structs for others to use.  i'm hoping to keep the methods simple by group all of them in one place, but anyway, whatever gets it work
[02:19:18] *** heftig_ is now known as heftig
[02:19:22] <dbaupp> heftig_: you can inline a struct into another struct or something
[02:19:25] *** Quits: sprang (sprang@moz-920A95C4.hsd1.ca.comcast.net) (Quit: sprang)
[02:20:05] <halp2934> kinda flip the types around
[02:20:32] <heftig> dbaupp: i think memory-layout-wise there's no difference between struct inheritance and composition without boxing?
[02:20:40] <halp2934> also, what about a struct tuple?
[02:21:05] <halp2934> can those have generic parts?
[02:21:45] <halp2934> you could pattern match on that trivially
[02:21:46] <dbaupp> heftig: yes, I think so; and composition gives the user more control over the actual layout (e.g. putting the sub-struct at the start/end/in the middle of the parent)
[02:23:34] <geomyidae> what's the best community driven docs for rust these days?
[02:24:06] <geomyidae>  I'd like to start aggregating stuff that I forget frequently. Like how to cast between different uint types, for example. I'm sure it's easy, but I have to think and look it up
[02:25:29] <dbaupp> geomyidae: https://github.com/adridu59/rust-tuts maybe?
[02:25:40] <dbaupp> but not really.
[02:26:11] *** Quits: brendan (brendaneic@moz-D5E1B4C6.w193-248.abo.wanadoo.fr) (Quit: brendan)
[02:27:46] *** Quits: earlzlap (earlz@moz-483E1E31.neo.res.rr.com) (Ping timeout)
[02:28:17] *** Joins: jdm (jdm@CAB30FBD.8F96AEA7.2D179A7D.IP)
[02:28:17] *** ChanServ sets mode: +o jdm
[02:29:12] <halp2934> ww: what if you did something like this: https://pastebin.mozilla.org/3702888  
[02:30:28] <geomyidae> Seeking help with a "cannot determine a type for this expression: unconstrained type" error. https://github.com/colemickens/rustpcapsample/blob/master/rustpcap.rs#L102
[02:31:18] *** Quits: lpy (lpy@7360AA58.F09091A8.1348A864.IP) (Ping timeout)
[02:32:03] *** Quits: Sorella (quildreen@9D963F5D.DF5D8AE7.54BCAB54.IP) (Quit: Ex-Chat)
[02:32:33] *** Joins: sprang (sprang@moz-920A95C4.hsd1.ca.comcast.net)
[02:33:04] <halp2934> which expression?
[02:33:34] *** Joins: lpy (lpy@52067FC0.F09091A8.1348A864.IP)
[02:33:54] <dbaupp> geomyidae: `&wrapped_ctx as *loop_context as *u8` should work
[02:34:06] <dbaupp> (I assume it's because the transmute can't work out what it's result type is supposed to be
[02:34:24] <geomyidae> sorry, it's actually currently upset about handler_wrapper
[02:34:28] <jdm> right
[02:34:29] <aatch> dbaupp, that's what I thought, but I think it's actually the callback
[02:34:31] <geomyidae> rustpcap.rs:102             pcap_loop(s, -1, handler_wrapper, cast::transmute(ptr::to_unsafe_ptr(&wrapped_ctx)));
[02:34:31] <geomyidae>                                              ^~~~~~~~~~~~~~~
[02:34:31] <geomyidae> error: aborting due to previous error
[02:34:33] <jdm> extern generics aren't good
[02:34:34] <jdm> don't work
[02:34:42] <geomyidae> well, that didn't work. jdm, I worried that was going to be it.
[02:35:13] <geomyidae> jdm, is there any way to do what I'm trying at? If you can tell, I've created a "2" variant of the loop that wraps the context so the user doesn't have to transmute back themselves in the end.
[02:35:39] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[02:35:41] <geomyidae> it seems like if the developer can do it, it can be specified at compile time and thus should be possible for me to accomplish somehow, but maybe not.
[02:35:49] *** Quits: derek_c (derek@moz-E72F174.cit.cornell.edu) (Ping timeout)
[02:35:51] *** Quits: nkoep (nik@moz-4CC1A50B.pool.mediaways.net) (Client exited)
[02:36:31] <dbaupp> geomyidae: try handler_wrapper::<SomeType>
[02:36:41] <dbaupp> where SomeType is the one you want C to be
[02:36:45] *** Joins: earlzlap (earlz@moz-483E1E31.neo.res.rr.com)
[02:37:17] <halp2934> does rust allow phantom types?
[02:37:28] <geomyidae> well, I put .. C? in there... and it seems to have got me to a new set of errors at least. :)
[02:37:45] *** Joins: derek_c (derek@moz-E72F174.cit.cornell.edu)
[02:37:46] <aatch> halp2934, kinda.
[02:38:03] <halp2934> kinda?
[02:38:36] <aatch> (assuming I remember what phantom types are) you can make a type that can't be constructed.
[02:39:13] <halp2934> kinda
[02:39:32] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[02:39:32] *** ChanServ sets mode: +ao dherman dherman
[02:40:09] <halp2934> it's where you attach an extra type to something
[02:40:30] <halp2934> like I could wrap a void ptr in a struct that gives it an extra type that it doesn't technically have for safety purposes
[02:40:44] <halp2934> .. or a c function ptr
[02:41:01] <halp2934> to help with type inferencing
[02:41:58] <halp2934> and it seems you can do that
[02:42:00] *** Quits: halp2934 (Mibbit@27A93EB4.DF4637DA.62D74A69.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[02:42:45] *** Quits: sprang (sprang@moz-920A95C4.hsd1.ca.comcast.net) (Quit: sprang)
[02:43:18] *** Quits: derek_c (derek@moz-E72F174.cit.cornell.edu) (Ping timeout)
[02:46:03] *** Quits: lpy (lpy@52067FC0.F09091A8.1348A864.IP) (Ping timeout)
[02:46:34] *** Joins: lpy (lpy@52067FC0.F09091A8.1348A864.IP)
[02:48:05] <geomyidae> haha I finally got to a compiler error. :P
[02:49:37] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[02:49:51] *** Quits: canhtak (canhtak@moz-A13A68C3.wl.t.ulaval.ca) (Quit: canhtak)
[02:51:17] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[02:51:40] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[02:53:50] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[02:54:56] <jdavis> I work on postgres, and postgres internally uses a region-based memory allocator. So, you do allocations within some context (e.g. the per-transaction context), and if there's a rollback, it can just wipe out the entire memory context at once. How should I handle a similar problem in rust?
[02:58:10] <Eridius> jdavis: possibly with extra::arena::Arena? Though I haven't used that
[02:58:11] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Client exited)
[02:58:35] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[02:59:01] <jdavis> I'll check that out.
[02:59:25] *** Joins: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net)
[02:59:57] <Eridius> sounds like it suits your purpose. You create an Arena object, and it provides a way to allocate values in the arena. Then when the arena itself is dropped, it destructs all values that were allocated in it
[03:00:16] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[03:00:40] <jdavis> Basically, using C I'm accustomed to a lot of control over memory, so I'm trying to figure out how I accomplish similar goals in rust without the memory tricks.
[03:00:50] <Eridius> although if you need to allocate mutable values you'll probably need to stuff Cells in there (from std::cell)
[03:02:31] *** Joins: derek_c (derek@moz-FB4F1795.cit.cornell.edu)
[03:04:13] <jdavis> From the signature, extra::arena::Arena looks like what I need, but there's not a lot of documentation (and I don't know rust well enough to be sure I'm reading the signature properly).
[03:04:35] <sfackler> Won't owned pointers work just as well in this case?
[03:05:16] <Eridius> jdavis: is there some particular reason you think you need an arena allocator?
[03:05:19] <jdavis> sfackler, I think, essentially, yes. When rolling back a transaction, the pointers will go out of scope and be freed.
[03:05:39] <jdavis> sfackler, but it might cause a bunch of deallocation effort.
[03:05:47] <Eridius> heck, if all your values are the same type, you could even just use a ~[T] if you want to drop them all at once
[03:05:58] <sfackler> ah, that makes sense
[03:06:06] *** Quits: dcrewi (david@moz-AB8667CE.gyrae.net) (Ping timeout)
[03:06:29] <jdavis> That may work perfectly fine, but I'm used to knowing what happens, and I'd be giving up some of that.
[03:06:56] <jdavis> In postgres, if you do MemoryContextReset, that is a fast way to blow away a lot of garbage you don't need any more.
[03:08:13] <jdavis> And it tends to avoid fragmentation issues, because you allocate things based on their lifetime.
[03:09:10] <jdavis> So two things that are both related to a transaction are also laid out near eachother, and when you deallocate, you get a larger free region.
[03:09:49] <Eridius> well, extra::arena is specifically for arena allocation, which sounds like what you're talking about
[03:09:56] <jdavis> Another benefit is that you can find the size you are actually using, so if you do a bunch of allocations, you can query the context to get the size.
[03:10:04] <jdavis> Yup.
[03:10:24] <Eridius> as I said before, though, it gives back &T values, which are of course immutable. So if you need to mutate the values after allocating them, you probably need to use std::cell::RefCell values (which let you do dynamic mutability)
[03:10:56] <Eridius> or, ya know, use unsafe code and transmute them to mutable if you really want to ;)
[03:10:59] <sfackler> arena seems like it should do what you want, though I have no idea why alloc takes a closure instead of the value
[03:11:02] <jdavis> Can you explain a little more? What is a RefCell?
[03:11:02] *** Joins: Skif (emschwar@moz-4C5BB5A8.beyondbb.com)
[03:11:17] <Eridius> sfackler: presumably so return-value-elision can let the value be constructed in the arena directly
[03:11:24] <Eridius> jdavis: http://static.rust-lang.org/doc/master/std/cell/index.html
[03:11:30] <Eridius> dynamic mutability, checked at runtime
[03:11:35] *** Joins: canhtak (canhtak@moz-A13A68C3.wl.t.ulaval.ca)
[03:11:49] <Eridius> notably, std::cell::RefCell lets you mutate the contained value without requiring a `mut` pointer
[03:12:06] <jdavis> But I guess it means you lose compile-time safety?
[03:12:11] *** Joins: vfetwnuncszu (david@moz-AB8667CE.gyrae.net)
[03:12:15] <jdavis> And get an exception if you break things?
[03:12:19] <Eridius> yes, if you try to reborrow a borrowed value it will fail the task
[03:12:23] *** vfetwnuncszu is now known as dcrewi
[03:12:46] *** Quits: Skif (emschwar@moz-4C5BB5A8.beyondbb.com) (Ping timeout)
[03:13:23] <sfackler> Eridius: it seems like using a closure instead of the raw value wouldn't help unless alloc & co get monomorphized for each distinct closure
[03:13:33] <sfackler> or fully inlined
[03:13:35] <jdavis> OK, that looks good so far. Thank you both.
[03:13:44] * jdavis isn't quite following sfackler
[03:13:54] <Eridius> sfackler: alloc() is #[inline]
[03:14:45] <Eridius> presumably this will eventually move to placement-new (or perhaps it will be called placement-box)
[03:14:56] <sfackler> right, but if alloc and alloc_nonpod all get inlined into the invocation point, I would think that that optimizer can construct in place if it takes a closure or a value
[03:15:25] <jdavis> I will work with RefCell and Arena a bit. That should give me plenty to think about for now. Thanks again.
[03:15:29] <sfackler> yeah, placement new should make Arena way less weird
[03:16:11] <geomyidae> error: transmute called on types with different sizes: u32 (32 bits) to uint (64 bits)
[03:16:12] <Eridius> sfackler: eh, maybe. I prefer not to second-guess the optimizer. Even if it doesn't get inlined, the copy-on-return optimization will let the closure approach allocate it in the correct spot
[03:16:15] <geomyidae> isn't that a safe conversion?
[03:16:16] <Eridius> but the argument approach would force a move
[03:16:33] <Eridius> geomyidae: how is it safe? They have different sizes.
[03:16:46] <dbaupp> geomyidae: use `as` for that
[03:16:48] <Eridius> geomyidae: where are the extra 32 bits in the result type going to come from?
[03:17:07] <Eridius> geomyidae: remember, transmute attempts to reinterpret the value as a different type, rather than coercing it to a different type
[03:17:07] <geomyidae> hm, ok,
[03:17:11] <Eridius> (which is why it's unsafe)
[03:17:16] *** Quits: zz_kimundi (kimundi@moz-BA49E2B1.dip0.t-ipconnect.de) (Ping timeout)
[03:17:41] <Eridius> rusti: unsafe { std::cast::transmute::<[u64, ..1], [u32, ..2]>([12345u64]) }
[03:17:41] -rusti- [12345u32, 0u32]
[03:17:54] <Eridius> rusti: unsafe { std::cast::transmute::<[u64, ..1], [u8, ..8]>([12345u64]) }
[03:17:55] -rusti- [57u8, 48u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8]
[03:18:11] <Eridius> rusti: unsafe { std::cast::transmute::<[u64, ..1], [u8, ..8]>([-1]) }
[03:18:12] -rusti- [255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8, 255u8]
[03:20:29] *** Joins: zz_kimundi (kimundi@moz-9888D3CE.dip0.t-ipconnect.de)
[03:20:45] *** zz_kimundi is now known as kimundi
[03:20:48] <geomyidae> thank you both btw
[03:21:55] *** Quits: lpy (lpy@52067FC0.F09091A8.1348A864.IP) (Client exited)
[03:21:55] <geomyidae> wow, I had to cut the genericy bit for now, but it sorta works. I guess what it's doing now isn't terribly interesting per se.
[03:22:09] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[03:23:51] *** Joins: blank_name (blank_name@FAB53C88.7071B2C8.31EC03F3.IP)
[03:24:18] *** Quits: Earnestly (earnest@38FE72A5.82423D8F.BFD1ABFD.IP) (Ping timeout)
[03:25:36] *** Quits: jvns (bork@87D98E32.4046EB22.428F94DD.IP) (Ping timeout)
[03:30:09] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[03:30:30] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Client exited)
[03:30:31] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[03:31:43] *** Quits: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net) (Quit: ChatZilla 0.9.90.1 [Firefox 25.0.1/20131112160018])
[03:35:50] *** Quits: ricepuddin (graham@moz-7D68765A.cable.virginm.net) (Ping timeout)
[03:38:42] *** Quits: mark_edward (mark@moz-DCB0B750.lightspeed.cicril.sbcglobal.net) (Quit: Leaving)
[03:40:21] *** Joins: twb (textual@moz-5DE8950B.hsd1.ga.comcast.net)
[03:42:07] *** Joins: kphelps (kphelps@moz-8B098CA5.hsd1.ma.comcast.net)
[03:42:43] *** Quits: derek_c (derek@moz-FB4F1795.cit.cornell.edu) (Quit: Leaving)
[03:43:27] *** Parts: diverse (diverse@moz-ED94B8D.oc.oc.cox.net) (WeeChat 0.4.2)
[03:43:40] *** Joins: lfox (lfox@moz-99E1A397.nycmny.east.verizon.net)
[03:45:38] <geomyidae> sorry to ramble, but its quiet anyway I guess. https://github.com/colemickens/rustpcapsample/blob/master/rustpcap.rs#L113 I'm getting this:
[03:45:42] <geomyidae> rustpcap.rs:113:26: 113:41 error: cannot move out of dereference of * pointer
[03:45:42] <geomyidae> rustpcap.rs:113         ((*ctx).callback)((*ctx).user_ctx, hdr_, pkt);
[03:45:42] <geomyidae>                                           ^~~~~~~~~~~~~~~
[03:47:19] *** Quits: jstevans (Instantbir@moz-8DBF3BC4.washdc.fios.verizon.net) (Ping timeout)
[03:49:10] <sfackler> when a function takes a ~C, it's taking ownership of that argument
[03:49:30] <sfackler> since ctx is a raw pointer, Rust doesn't trust that the code there actually ownes that version of user_ctx
[03:49:51] <sfackler> you probably want to change the function decalration to take a &C or maybe &mut C instead of ~C
[03:50:22] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[03:50:22] <geomyidae> sfackler: so that's what I thought when thinking through it. The ownership of the context would remain in the calling code and I would get a borrowed reference.
[03:51:03] *** Quits: vky (chatzilla@moz-4F2E17BF.dsl.dynamic.sonic.net) (Ping timeout)
[03:51:17] <geomyidae> But that's not how the original author wrote the code to handle the context parameter, and in fact, I'm not really sure I understand where the ownership of the ctx works here: https://github.com/jfager/d3cap/blob/master/rustpcap.rs#L53
[03:51:25] <geomyidae> (that's the original I forked from)
[03:51:26] *** Quits: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com) (Ping timeout)
[03:51:33] *** Joins: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com)
[03:52:06] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[03:52:13] <geomyidae> because that do_Capture_loop_dev has taken ownership of the ctx (~C), but then passes it as an unsafe ptr to some C lib
[03:52:22] <geomyidae> is it ... "defined" what happens after the function exit?
[03:52:30] *** Quits: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP) (Ping timeout)
[03:52:34] *** Joins: carter (carter@moz-F3C2A2D8.nycmny.fios.verizon.net)
[03:53:00] <sfackler> so after it's transmuted from a ~C to a *C, Rust forgets about it
[03:53:02] <sfackler> so it won't be freed
[03:53:14] <sfackler> until, I guess, it's transmuted back to a ~C and dropped
[03:53:19] *** Joins: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP)
[03:53:26] *** Quits: jdm (jdm@CAB30FBD.8F96AEA7.2D179A7D.IP) (Quit: Lost terminal)
[03:53:35] <aatch> It's generally a bad idea to transmute `~T`.
[03:53:42] <geomyidae> sfackler: mhm, so is that leaking in this case? because AFAIK there's nothing in pcap that would track or cleanup these user contexts.
[03:53:56] <geomyidae> Just trying to make sure I'm reasoning about this correctly
[03:54:21] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[03:54:36] <sfackler> yeah, it'd probably leak in this case
[03:54:42] <geomyidae> aatch: why is that? is it because it causes compiler crashes? heh
[03:54:51] <sfackler> but if pcap is designed to run until the program terminates, that's fine
[03:54:58] <aatch> geomyidae, it just makes things difficult to reason about.
[03:55:20] <sfackler> you have to do it a fair amount when interfacing with C libs, though
[03:55:33] <geomyidae> ah, well, in my case, in that else block, if I attempt to mutate make to a loop_context with an owned ~C, the compiler crashes :(
[03:55:48] <aatch> sfackler, not really, you should be taking &T and trasmuting *that*
[03:55:56] <aatch> (I think it might even coerce)
[03:56:22] <sfackler> but in a lot of cases, you're semantically giving ownership of that value to the C library
[03:56:39] <sfackler> you may even also be giving the C library a function to handle freeing the data
[03:56:42] <geomyidae> yeah, so wouldn't I need to transfer ownership back to rust so it'll free it when it goes out of scope or w/e
[03:56:49] <sfackler> which would just transmute back to ~Foo
[03:56:59] <aatch> sfackler, it happens, yes, but it's not *that* common.
[03:57:45] <aatch> most C APIs I've seen either manage their own memory (plus provide a `free` function for the user) or require the user to allocate all the memory themselves.
[03:57:53] <geomyidae> aatch: so you're saying if I want, I can retain ownership of the object in rust, mutate back and forth with a borrowed pointer and it will be tracked and freed appropriately?
[03:58:05] <geomyidae> that's kinda my next attempt I think
[03:58:54] <geomyidae> oh right, that's because it wants me to specify lifetimes when I try to do that :(
[03:59:31] <aatch> geomyidae, I don't know the pcap API, so I don't know whats best.
[03:59:37] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[04:01:37] *** Quits: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com) (Ping timeout)
[04:02:01] <aatch> I'm just saying that most C libraries that take ownership of a piece of data have normally provided that data themselves to start with.
[04:02:06] *** Joins: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com)
[04:02:14] <aatch> The LLVM C bindings are like that.
[04:02:14] <geomyidae> ah
[04:03:30] *** Joins: dew1 (Instantbir@moz-E4452B8F.static.stls.mo.charter.com)
[04:03:46] <aatch> Basically it's a "don't use it and don't free it, I'll take care of that" deal. Since the only other safe way is (as sfackler said) to take a `free` function that frees the pointer you give.
[04:03:59] *** Quits: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com) (Ping timeout)
[04:04:00] <aatch> Which I've only seen in ZMQ.
[04:04:39] <geomyidae> honestly, I think this is just a pointer that gets passed transparently through to the callback function and thats it
[04:04:46] <geomyidae> it's why I feel like I'm over complicating it
[04:05:59] <aatch> geomyidae, is this that `user` argument I saw?
[04:06:03] <geomyidae> yes
[04:07:05] <aatch> geomyidae, then yes, it almost certainly is just passed straight through.
[04:07:37] <geomyidae> aatch: yeah, can you advise on whether I'm missing a more obvious way of dealing with this then?
[04:08:48] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[04:11:01] <ChrisMorgan> It's interesting seeing what the responses have been about rust-http's strong typing discipline for header at https://news.ycombinator.com/item?id=6830384.\
[04:12:09] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Client exited)
[04:12:31] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[04:12:47] <aatch> geomyidae, ok, so I'm just familiarising myself with the libpcap API
[04:13:13] *** Quits: earlzlap (earlz@moz-483E1E31.neo.res.rr.com) (Ping timeout)
[04:14:18] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[04:14:21] <geomyidae> I wonder if there's even a huge amount of value in even doing this on top of pcap_loop and instead just writing the bits for pcap_next and letting people do the "loop" themselves.
[04:14:42] <aatch> geomyidae, well you could wrap it in an iterator.
[04:15:12] <geomyidae> In fact, my Golang version of the app that uses pcap uses pcap_next rather than loop
[04:16:28] <geomyidae> okay, that should be interesting, I'll try that. Now I really want to know what "the point" of pcap_loop is, given that pcap_next exists.
[04:16:53] *** Quits: zslayton (Mibbit@moz-4806B979.nyc.res.rr.com) (Quit: http://www.mibbit.com ajax IRC Client)
[04:17:00] <aatch> geomyidae, either simplicity or efficiency, depending on how it's implemented.
[04:17:58] *** Joins: squiggy (Mibbit@27A93EB4.DF4637DA.62D74A69.IP)
[04:18:06] <squiggy> are tuples boxed?
[04:18:11] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[04:18:29] <dbaupp> squiggy: nothing is boxed without a ~ or @ (or &)
[04:18:33] <aatch> squiggy, no, they are just laid out in memory the same as structs
[04:18:40] <squiggy> ah, ok
[04:18:41] <squiggy> thanks
[04:19:15] *** Quits: squiggy (Mibbit@27A93EB4.DF4637DA.62D74A69.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[04:19:40] <geomyidae> well, in that case maybe i'll come back to the loop later and see if I can make this work. It's very appealing to me that rust will let me just throw a random context into my surface api and then just pull it out at the end (in theory) and just <C> pipe it through all the way.
[04:20:17] <geomyidae> <3, but I love the strong (and I like to think of it as semantic) typing as ChrisMorgan calls out in that interesting disco
[04:20:34] <ChrisMorgan> geomyidae: semantic it certainly is.
[04:20:35] <aatch> geomyidae, libpcap seems to use the fairly common object-oriented pattern of having a central context object
[04:20:41] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[04:21:15] <ChrisMorgan> Well, I think I'll write up a long blog post on the topic. I *do* want more feedback on the concept. I'm convinced it's superior, but there are still some niggly points with it.
[04:21:55] <doublec> ChrisMorgan: it's superior in terms of making sure the web app doesn't generate invalid headers and making sure it correctly uses data from headers
[04:22:15] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[04:22:26] <doublec> ChrisMorgan: it's not though when it comes to dealing with clients that send bad headers or needing to send special headers for some reason
[04:22:35] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Client exited)
[04:22:36] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[04:22:43] <geomyidae> yeah, bad headers from the client would be weird
[04:22:45] <doublec> ChrisMorgan: if there's some way the framework allows that then it's good
[04:22:55] <ChrisMorgan> doublec: and I would expect that to be <0.1% of cases, but it's still essential.
[04:23:06] *** Joins: lenstr (lenstr@CD7D5ABA.83A99F98.85938D85.IP)
[04:23:07] <ChrisMorgan> (Given Rust's position, I mean.)
[04:23:17] <doublec> ChrisMorgan: its the 0.1% of the cases that are often deal breakers for frameworks
[04:23:51] <doublec> "I used framework X and our app was going swimmingly but then we hit an edge case it can't handle and that's the end of using that framework"
[04:24:05] <aatch> ChrisMorgan, as a writer of a framework, custom headers are mostly non-optional.
[04:24:13] *** Joins: maxiepoo (Max@moz-6F50ADE.hsd1.il.comcast.net)
[04:24:41] <ChrisMorgan> aatch: extension headers are fine; the difficulty is incorrect standard headers.
[04:24:44] <doublec> In my use of Ur/Web I've often hit "I don't want the framework to deal with that edge case because its bad" so I've had to resort to C FFI for example.
[04:25:00] <ChrisMorgan> Have you used Ur/Web much?
[04:25:00] <aatch> ChrisMorgan, oh, in that case it's fine.
[04:25:43] <doublec> ChrisMorgan: I've used it in long running live sites but I wouldn't say I use all the features of it.
[04:25:43] <ChrisMorgan> Ur/Web, some Haskell frameworks and Spray are the main things I've found with significant amount in common with my vision.
[04:25:45] *** Joins: earlzlap (earlz@moz-483E1E31.neo.res.rr.com)
[04:25:59] <ChrisMorgan> But I haven't actually learned to use any of them yet.
[04:26:14] *** Joins: lpy (lpy@7360AA58.F09091A8.1348A864.IP)
[04:27:35] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[04:28:47] *** Quits: KindOne (KindOne@moz-1F6A65EB.dynamic.ip.windstream.net) (Ping timeout)
[04:29:06] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[04:29:19] <aatch> ChrisMorgan, looks like most of the complainers are just hypothesising.
[04:29:45] <ChrisMorgan> aatch: yes, I see that. But I do want to assuage concerns if they're not valid.
[04:29:58] *** Quits: lenstr (lenstr@CD7D5ABA.83A99F98.85938D85.IP) (Quit: Leaving...)
[04:30:30] *** Joins: mib_bp968z (Mibbit@27A93EB4.DF4637DA.62D74A69.IP)
[04:30:31] <doublec> ChrisMorgan: I'll give you an example from the browser
[04:30:46] <mib_bp968z> does rustc do tco?
[04:30:51] <doublec> ChrisMorgan: In our Firefox media support we were strongly making sure that correct mime types were used in the content-type header
[04:30:52] <aatch> mib_bp968z, no
[04:31:00] *** Quits: vodik (simon@moz-FD4ADBC6.cable.teksavvy.com) (Ping timeout)
[04:31:02] <mib_bp968z> plans to support tco?
[04:31:06] <aatch> mib_bp968z, no
[04:31:11] *** Joins: vodik (simon@moz-FD4ADBC6.cable.teksavvy.com)
[04:31:11] <mib_bp968z> :(
[04:31:15] <aatch> (why do people keep asking this?)
[04:31:15] <doublec> ChrisMorgan: but sites were requesting 'audio/mpeg' content with a 'codecs' parameter of 'mp3'
[04:31:21] <doublec> ChrisMorgan: this is invalid per spec so we rejected it
[04:31:29] <ChrisMorgan> What, `audio/mpeg;codecs=mp3`?
[04:31:30] <doublec> ChrisMorgan: but it meant we couldn't play a lot of mp3 content 
[04:31:34] <doublec> ChrisMorgan:  So we buckled
[04:31:42] <doublec> ChrisMorgan: right
[04:31:45] <dbaupp> mib_bp968z: certain tail calls are removed by LLVM, but we don't have guaranteed TCO, because the trade offs are too big
[04:31:56] <aatch> mib_bp968z, we have an optimization that *looks* like TCO, but for a variety of technical reasons we cannot guarentee it.
[04:32:08] <ChrisMorgan> mib_bp968z: https://github.com/mozilla/rust/issues/217
[04:32:18] *** Joins: KindOne (KindOne@moz-1F6A65EB.dynamic.ip.windstream.net)
[04:32:26] * aatch will one day be able to spell 'guarantee'
[04:32:38] <dbaupp> aatch: do you garuantee that?
[04:32:46] <ChrisMorgan> aatch: it took me quite some time to teach my fingers not to type it guarrantee.
[04:33:05] <aatch> dbaupp, I goryntay it
[04:33:13] <dbaupp> mib_bp968z: specifically, https://mail.mozilla.org/pipermail/rust-dev/2013-April/003557.html is the "nail in the coffin"
[04:33:21] <mib_bp968z> could rustc support tail recursion if not full tco?
[04:33:44] *** Joins: ricepuddin (graham@moz-7D68765A.cable.virginm.net)
[04:34:10] <doublec> ChrisMorgan: see for example https://bugzilla.mozilla.org/show_bug.cgi?id=899748#c12
[04:34:13] <dbaupp> mib_bp968z: with optimisations on, http://llvm.org/docs/CodeGenerator.html#sibling-call-optimization kicks in, so things like a basic tail recursive factorial (and more advanced ones too) get optimised
[04:34:15] <aatch> mib_bp968z, well tail recursion is just recursing at the end of the function.
[04:34:30] *** Quits: ww (Mibbit@moz-185C323F.public.wayport.net) (Quit: http://www.mibbit.com ajax IRC Client)
[04:35:24] <mib_bp968z> hmm.. it seems like a bad idea to rely on a compiler flag to not kill your program
[04:35:28] <mib_bp968z> oh well
[04:35:28] <aatch> so "supporting tail recursion" is "supporting function calls". However, what most people mean by "do you support tco?" is "can I write infinitely recursive functions?"
[04:35:38] <aatch> In which case, the answer is no.
[04:35:54] <mib_bp968z> aatch, I mean can I make a large number of tail calls without blowing the stack
[04:36:02] <aatch> mib_bp968z, same difference
[04:36:18] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[04:36:18] *** ChanServ sets mode: +ao dherman dherman
[04:37:46] *** Joins: mib_6y8f5n (Mibbit@EF7E0C19.8A581DF0.4555788E.IP)
[04:38:04] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[04:39:42] <mib_bp968z> aatch: to be fair, continuations are cool
[04:39:48] <aatch> As you said, you can't rely on the optimization for safety. If we could guarantee it, then you could write an infinitely recursive function.
[04:39:56] *** Joins: vky (chatzilla@moz-4F2E17BF.dsl.dynamic.sonic.net)
[04:40:12] <mib_bp968z> yeah
[04:40:21] <mib_bp968z> for now, manual loops
[04:40:29] *** Quits: mib_bp968z (Mibbit@27A93EB4.DF4637DA.62D74A69.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[04:40:42] <aatch> -.-
[04:40:51] <aatch> I shouldn't get grumpy at that question...
[04:41:30] <aatch> I think it's the sideways nature of it. That they aren't asking the question they want answered.
[04:41:53] *** Quits: kphelps (kphelps@moz-8B098CA5.hsd1.ma.comcast.net) (Ping timeout)
[04:41:57] <doublec> how so?
[04:42:28] *** Joins: mark_edward (mark@moz-DCB0B750.lightspeed.cicril.sbcglobal.net)
[04:42:45] <doublec> is it the fact they're not saying tco instead of tail calls?
[04:42:52] <aatch> doublec, it's always "do you support tco", to which the honest, direct answer is "yes". In the same way we support scalar replacement of aggregates.
[04:43:05] *** Quits: carter (carter@moz-F3C2A2D8.nycmny.fios.verizon.net) (Quit: Textual IRC Client: www.textualapp.com)
[04:43:44] <aatch> But what they want to know is "can I convert this Haskell/Scheme/Erlang straight to Rust?".
[04:44:44] *** Quits: mib_6y8f5n (Mibbit@EF7E0C19.8A581DF0.4555788E.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[04:44:52] <aatch> Because they don't care if we support the optimisation itself, they care if we support the implication of that optimization.
[04:45:10] <dbaupp> fwiw, I don't think Haskell has TCO as part of the language; just a compiler optimisation.
[04:45:31] <aatch> Which is being able to write code that is incredibly recursive.
[04:45:33] <dbaupp> (but then its design means deep recursion is fine anyway.)
[04:45:57] <aatch> dbaupp, also, little-to-no mutable state.
[04:47:07] *** Quits: Jesin (Jesin@moz-27916D21.washdc.fios.verizon.net) (Quit: Leaving)
[04:47:17] <ChrisMorgan> doublec: that's the sort of case where it's just clear you need to be following practice, not specification, or the looser of the two.
[04:48:29] *** Quits: twb (textual@moz-5DE8950B.hsd1.ga.comcast.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[04:48:33] <doublec> writing functions in haskell that relies on tco is often not done due to using haskell's laziness
[04:48:49] *** Joins: jstevans (Instantbir@moz-8DBF3BC4.washdc.fios.verizon.net)
[04:48:58] <aatch> I'm just not sure why the question comes up at all.
[04:49:06] *** Joins: mib_e5n8y6 (Mibbit@27A93EB4.DF4637DA.62D74A69.IP)
[04:49:07] <doublec> for example, many functions will return x :: (recursive call) which is not tail recursive.
[04:49:11] <dbaupp> aatch: buzzwords?
[04:49:30] *** Joins: nsf (nsf@moz-EEF3238A.convex.ru)
[04:49:35] <aatch> It's not like people come in talking about inter-procedural constant propagation
[04:50:27] <doublec> this thread has a good discussion btw http://www.haskell.org/pipermail/haskell-cafe/2009-March/058839.html
[04:50:29] <aatch> or jump-threading.
[04:50:40] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Ping timeout)
[04:50:55] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[04:51:07] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[04:51:29] <doublec> ChrisMorgan: right. often though frameworks are written where edge cases exist due to 'practice' rather than 'spec' that the framework auther isn't aware of.
[04:51:31] *** Quits: mye (mye@moz-BC8CA0A3.dip0.t-ipconnect.de) (Ping timeout)
[04:52:03] *** Joins: brson (brson@981AA104.E81F12CD.76F66111.IP)
[04:52:04] *** ChanServ sets mode: +ao brson brson
[04:52:14] <doublec> ChrisMorgan: as long as the framework is kept up to date for these, and it's easy for users of it to change or update, then there's less of an issue
[04:52:36] *** Joins: mye (mye@moz-FD24DF07.dip0.t-ipconnect.de)
[04:52:55] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[04:53:01] <mib_e5n8y6> aatch: tail recursion is something many users run into fairly easily in the course of writing a program .. support for it directly and drastically shapes how you can write a program. Those other topics are less pertinent to me personally.
[04:53:44] <brson> cmr: gj getting twir on hn today \(^0^)/
[04:54:20] *** Quits: Sharp (Sharp@moz-780FECDA.washdc.fios.verizon.net) (Quit: Sharp)
[04:54:28] <aatch> mib_e5n8y6, I suppose. But the same can be said for dead-code elimination. Which Rust does guarantee in some cases.
[04:54:41] <aatch> (specifically, branching on a constant value)
[04:55:03] <mib_e5n8y6> that's great, but dead code doesn't cause me program to overflow the stack and crash
[04:55:06] <mib_e5n8y6> my*
[04:55:27] *** Quits: glennsl (textual@moz-5D7B804F.getinternet.no) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[04:55:28] <aatch> mib_e5n8y6, not *strictly* true, but I see your point.
[04:56:37] *** Quits: mib_e5n8y6 (Mibbit@27A93EB4.DF4637DA.62D74A69.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[04:59:50] *** Joins: Skif (emschwar@moz-4C5BB5A8.beyondbb.com)
[05:00:10] *** Joins: Sharp (Sharp@moz-780FECDA.washdc.fios.verizon.net)
[05:01:12] *** Quits: lfox (lfox@moz-99E1A397.nycmny.east.verizon.net) (Quit: ZZZzzz…)
[05:01:31] *** Quits: Skif (emschwar@moz-4C5BB5A8.beyondbb.com) (Ping timeout)
[05:02:02] *** Joins: twb (textual@moz-5DE8950B.hsd1.ga.comcast.net)
[05:09:12] *** Joins: sprang (sprang@moz-920A95C4.hsd1.ca.comcast.net)
[05:09:30] *** Joins: m_kato (m_kato@moz-C286AD9A.bitcat.net)
[05:15:26] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Client exited)
[05:15:46] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[05:16:20] *** Quits: Diamond (dick@moz-80556682.ks.ks.cox.net) (Quit: Leaving.)
[05:17:27] *** Joins: pradeep (pradeep@5AB4884B.FCC4549.14D5B978.IP)
[05:17:33] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[05:17:38] *** Quits: maxiepoo (Max@moz-6F50ADE.hsd1.il.comcast.net) (Quit: maxiepoo)
[05:18:32] *** Joins: beifeng (Mibbit@284C36E7.3062CEC3.670EEFD.IP)
[05:20:04] *** Quits: Sharp (Sharp@moz-780FECDA.washdc.fios.verizon.net) (Quit: Sharp)
[05:21:28] *** Quits: ricepuddin (graham@moz-7D68765A.cable.virginm.net) (Ping timeout)
[05:21:58] *** Joins: Sharp (Sharp@moz-780FECDA.washdc.fios.verizon.net)
[05:22:12] *** Quits: Sharp (Sharp@moz-780FECDA.washdc.fios.verizon.net) (Quit: Sharp)
[05:22:49] *** Joins: Sharp (Sharp@moz-780FECDA.washdc.fios.verizon.net)
[05:27:56] *** Quits: Sharp (Sharp@moz-780FECDA.washdc.fios.verizon.net) (Quit: Sharp)
[05:28:43] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[05:30:28] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Ping timeout)
[05:34:38] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[05:36:08] *** Joins: Sharp (Sharp@moz-780FECDA.washdc.fios.verizon.net)
[05:43:01] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[05:43:58] *** Quits: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[05:50:21] *** Quits: canhtak (canhtak@moz-A13A68C3.wl.t.ulaval.ca) (Quit: canhtak)
[05:51:51] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[05:52:45] *** Joins: GeneralMaximus (ankur@704E18E2.13A5FC81.D5D59AD9.IP)
[05:53:16] *** Quits: earlzlap (earlz@moz-483E1E31.neo.res.rr.com) (Ping timeout)
[05:53:23] *** Quits: GeneralMaximus (ankur@704E18E2.13A5FC81.D5D59AD9.IP) (Quit: Computer has gone to sleep.)
[05:53:39] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[05:56:58] *** Joins: japaric (japaric@93AE996A.11BD0214.95AFB88D.IP)
[05:58:12] *** Joins: pcwalton (pcwalton@moz-DA87EE4.hsd1.ca.comcast.net)
[05:58:12] *** ChanServ sets mode: +ao pcwalton pcwalton
[05:58:13] *** Joins: thewonderidiot (mike@moz-5506A033.hsd1.ca.comcast.net)
[05:58:15] *** Quits: pcwalton (pcwalton@moz-DA87EE4.hsd1.ca.comcast.net) (Quit: pcwalton)
[05:58:33] *** Quits: thewonderidiot (mike@moz-5506A033.hsd1.ca.comcast.net) (Quit: Leaving.)
[05:58:53] *** Quits: jstevans (Instantbir@moz-8DBF3BC4.washdc.fios.verizon.net) (Ping timeout)
[06:01:35] *** Quits: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com) (Ping timeout)
[06:02:00] *** Joins: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com)
[06:03:01] *** Joins: recrack (Mibbit@5AB4884B.FCC4549.14D5B978.IP)
[06:03:23] *** Quits: brson (brson@981AA104.E81F12CD.76F66111.IP) (Ping timeout)
[06:09:38] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[06:14:54] *** Parts: killerswan (kevincantu@moz-CC0DC654.hsd1.ca.comcast.net) ()
[06:17:06] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[06:18:27] *** Quits: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net) (Ping timeout)
[06:18:58] *** Joins: brson (brson@6A848D32.C1B840DD.76F66111.IP)
[06:18:58] *** ChanServ sets mode: +ao brson brson
[06:29:37] *** Joins: victorporof (victorporo@FB8E2A00.483E5FE1.9B1E38F4.IP)
[06:32:24] *** Quits: Sharp (Sharp@moz-780FECDA.washdc.fios.verizon.net) (Quit: Sharp)
[06:32:39] *** Joins: Sharp (Sharp@moz-780FECDA.washdc.fios.verizon.net)
[06:35:50] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[06:36:09] *** Quits: cubic (cubic@moz-80241A3A.mc.videotron.ca) (Quit: Leaving)
[06:39:14] *** Quits: dbaupp (Thunderbir@348FADA7.D5A1DCF.37681C44.IP) (Ping timeout)
[06:43:12] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[06:43:16] *** Quits: twb (textual@moz-5DE8950B.hsd1.ga.comcast.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[06:47:48] *** Joins: crystalzelda (Mibbit@moz-B6D11F70.socal.res.rr.com)
[06:48:32] *** Joins: Skif (emschwar@moz-4C5BB5A8.beyondbb.com)
[06:48:42] *** Quits: crystalzelda (Mibbit@moz-B6D11F70.socal.res.rr.com) (Quit: http://www.mibbit.com ajax IRC Client)
[06:48:55] *** Quits: pradeep (pradeep@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[06:50:07] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Client exited)
[06:50:08] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[06:50:15] *** Quits: Skif (emschwar@moz-4C5BB5A8.beyondbb.com) (Ping timeout)
[06:52:36] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[06:52:49] *** Joins: fabiand (fabiand@moz-376ED57B.adsl.alicedsl.de)
[06:54:21] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[06:56:32] *** Joins: jdm (jdm@moz-AC9499B2.cable.teksavvy.com)
[06:56:33] *** ChanServ sets mode: +o jdm
[06:56:54] *** Quits: brson (brson@6A848D32.C1B840DD.76F66111.IP) (Quit: leaving)
[06:57:55] *** Quits: Sharp (Sharp@moz-780FECDA.washdc.fios.verizon.net) (Quit: Sharp)
[06:58:47] <geomyidae> what if I want to differentiate between different err types with Result?
[06:58:51] <geomyidae> Is there an idiomatic way of doing that?
[06:59:07] *** Joins: Sharp (Sharp@moz-780FECDA.washdc.fios.verizon.net)
[07:00:31] *** Quits: Sharp (Sharp@moz-780FECDA.washdc.fios.verizon.net) (Quit: Sharp)
[07:01:06] *** Joins: Sharp (Sharp@moz-780FECDA.washdc.fios.verizon.net)
[07:08:44] *** Joins: alonlevy (alon@moz-DCBA91C6.bb.netvision.net.il)
[07:12:02] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[07:12:05] *** Quits: FreeFull (freefull@moz-76C0CBA3.as13285.net) (Quit: )
[07:12:38] <geomyidae> is it idiomatic to use Option<ErrEnum> and have None be the success case?
[07:13:52] *** Joins: gavinb (gavinb@103ECFE0.E4C45B11.3DEFE92B.IP)
[07:15:24] <heftig> geomyidae: Result
[07:15:43] <geomyidae> Do I use None for the non error result then?
[07:16:09] <heftig> Result<(), ErrEnum>
[07:16:12] <klutzy> if it returns nothing, Result<(), MyErr> would be good
[07:16:41] <klutzy> or just enum MyResult { MyOk, MyErr1, ... } if it fits better
[07:16:41] <geomyidae> thx
[07:19:38] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Client exited)
[07:20:08] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[07:20:58] *** Joins: Ms2ger (Ms2ger@C91975CB.3387515C.187A1082.IP)
[07:21:58] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[07:29:36] *** Quits: alonlevy (alon@moz-DCBA91C6.bb.netvision.net.il) (Ping timeout)
[07:30:17] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[07:30:37] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Client exited)
[07:30:37] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[07:32:04] <gavinb> Is there a good example of how to write a struct with a constructor and destructor, which has a reference to another struct? Trying to do something fairly simple, and keep getting tripped up by Send, Drop and lifetimes... :/
[07:33:18] *** Joins: ww (Mibbit@moz-DFAED48A.lightspeed.sntcca.sbcglobal.net)
[07:33:46] <ww> how do you look at the last char in a str?  (i know i feel like lazy)
[07:33:59] <gavinb> The setup is more or less: a WindowController has a reference to a Window. I need the WindowController constructor to take a reference to the Window. But it's not clear how to set up the lifetime spec, esp since it already has 'self in the impl.
[07:34:16] *** Quits: mye (mye@moz-FD24DF07.dip0.t-ipconnect.de) (Quit: mye)
[07:35:14] <Yurume> rusti: let s = "hello, world!☃"; s.char_at_reverse(
[07:35:14] -rusti- <anon>:10:4: 10:5 error: incorrect close delimiter: `}`
[07:35:14] -rusti- <anon>:10     };
[07:35:15] -rusti-               ^
[07:35:15] -rusti- application terminated with error code 101
[07:35:20] <Yurume> rusti: let s = "hello, world!☃"; s.char_at_reverse(s.len())
[07:35:21] -rusti- '\u2603'
[07:35:32] <Yurume> ww: here it is.
[07:35:49] <ww> thanks!
[07:36:14] *** Joins: brendan (brendaneic@moz-D5E1B4C6.w193-248.abo.wanadoo.fr)
[07:36:16] <ww> so there's no last_index_of or get_at(s.len() - 1)?
[07:36:59] <gavinb> That's weird - I would not have expected the indexing to work like that.
[07:37:07] *** Quits: brendan (brendaneic@moz-D5E1B4C6.w193-248.abo.wanadoo.fr) (Quit: brendan)
[07:37:39] <gavinb> Surely s.char_at() is counting from left, and s.char_at_reverse() counts from the right?
[07:37:50] <gavinb> In which case, wouldn't it be s.char_at_reverse(0)?
[07:38:19] <gavinb> rusti: let s = "ABCDZ"; s.char_at(s.len()-1)
[07:38:20] -rusti- 'Z'
[07:38:29] <Yurume> ww: I think so. that's a side effect of having UTF-8 string ;)
[07:38:30] <ww> cool. thanks!
[07:38:43] <gavinb> rusti: let s = "ABCDZ"; s.char_at_reverse(0)
[07:38:43] -rusti- 'A'
[07:38:44] <Yurume> gavinb: no, that wouldn't work when the last character is not in ASCII.
[07:38:47] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[07:38:58] <Yurume> rusti: let s = "hello, world!☃"; s.char_at(s.len()-1)
[07:38:59] -rusti- task <unnamed> failed at 'assertion failed: (w != 0)', /build/rust/src/rust-0.8/src/libstd/str.rs:2052
[07:38:59] -rusti- application terminated with error code 101
[07:39:13] <Ms2ger> That's a nice and clear message, too
[07:39:20] <Yurume> haha
[07:39:31] <Yurume> dealing with byte offset needs some love... but anyway.
[07:40:01] <ww> yeah, utf-8 complicates thing
[07:40:04] <gavinb> Ah, rereading the docs: "Plucks the character ending at the ith byte of a string". Ok, the method name is a bit misleading then. It doesn't reverse the string nor does it reverse the indexing.
[07:40:12] *** Quits: jeaye (Jeaye@moz-34FEF2BB.hsd1.ca.comcast.net) (Quit: zzz)
[07:40:33] <gavinb> IMHO a better name would be char_ending_at()
[07:40:33] <Yurume> perhaps char_starting_at() and char_ending_at()?
[07:40:36] <ww> it should be char_from_end
[07:40:52] <gavinb> Yurume: yes indeed
[07:44:11] *** Quits: gavinb (gavinb@103ECFE0.E4C45B11.3DEFE92B.IP) (Connection reset by peer)
[07:44:50] *** Quits: bjz (bjz@moz-DD4A2A91.lnse2.cha.bigpond.net.au) (Ping timeout)
[07:47:59] *** Joins: dbaupp (Thunderbir@moz-3BE4086E.lns20.syd6.internode.on.net)
[07:52:58] <geomyidae> I'm guessing that std::vec::from_buf doesnt copy?
[07:53:21] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[07:53:26] *** Joins: brendan (brendaneic@moz-D5E1B4C6.w193-248.abo.wanadoo.fr)
[07:55:07] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[07:55:49] *** Joins: eddyb (eddy@moz-68E0B7D0.residential.rdsnet.ro)
[07:55:51] *** Joins: mye (mye@moz-FD24DF07.dip0.t-ipconnect.de)
[07:57:24] <cmr> nope, that's why it's unsafe.
[07:57:51] <cmr> actually yes it does
[07:58:02] <cmr> that isn't what I expected
[07:58:10] * cmr looks for the one that doesn't coppy
[07:58:57] <eddyb> cmr: woo http://huonw.github.io/isrustfastyet/mem/#c470184,b2aa00b
[07:59:16] <cmr> I guess the only non-copying ones are slices
[07:59:27] <eddyb> been waiting all day yesterday for that :P
[07:59:28] <cmr> Which kinda makessense, since you don't know which allocator a given raw ptr came from
[07:59:42] <cmr> eddyb: funny, I was in a car all yesterday travelling :p
[08:00:27] <klutzy> eddyb: \o/
[08:02:10] <eddyb> uhm, it looks like ast indexing doesn't allocate memory anymore
[08:02:33] <eddyb> at least nothing visible
[08:03:41] <cmr> eddyb: so, do you want to fix the post-trans leak now? :D
[08:04:11] <eddyb> since it's not @ that's leaking...
[08:04:21] <cmr> it is
[08:04:28] <eddyb> cmr: have you seen the comparisons for removing jemalloc?
[08:04:43] <cmr> I have in the past but I don't remember them.
[08:05:07] <eddyb> LLVM actually allocates memory. with jemalloc, there was no post-trans leak
[08:05:28] <cmr> that's not what I mean
[08:05:31] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[08:05:42] <cmr> I mean everything rustc allocates before trans is finished can be free'd after it finishes
[08:05:50] <cmr> And none/very little of it is
[08:05:52] <eddyb> it is freed
[08:05:55] <cmr> no it isn't
[08:06:15] <eddyb> right now LLVM is reusing the heap space, without those pages ever getting unmapped
[08:07:22] <eddyb> jemalloc was smarter, it was unmapping that space, and you could see LLVM allocating memory from a low baseline up to the flat line that it always sits at now
[08:07:31] <cmr> That doesn't really explain http://i.imgur.com/arm3Xbu.png
[08:07:43] <cmr> I will make a graph with jemalloc though
[08:08:50] <eddyb> a solution (without switching back to jemalloc) would be custom arenas *behind* Rc that can be garbage-collected manually
[08:09:33] <eddyb> but we need those smart pointer improvements again
[08:11:35] *** Joins: pradeep (pradeep@5AB4884B.FCC4549.14D5B978.IP)
[08:13:09] *** Joins: GeneralMaximus (ankur@704E18E2.13A5FC81.D5D59AD9.IP)
[08:15:08] *** flaper87|afk is now known as flaper87
[08:17:05] *** Joins: Jackneill (Jackneill@moz-C693862A.pool.digikabel.hu)
[08:17:21] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[08:19:36] *** Joins: victorporof_ (victorporo@FB8E2A00.483E5FE1.9B1E38F4.IP)
[08:20:41] *** Quits: victorporof (victorporo@FB8E2A00.483E5FE1.9B1E38F4.IP) (Ping timeout)
[08:23:12] *** Joins: Axord (xord@moz-C0D5F15A.lsanca.dsl-w.verizon.net)
[08:23:14] *** pmoore|away is now known as pmoore
[08:25:00] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[08:25:17] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[08:29:51] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[08:32:05] *** Joins: Ferreus (ferreus@moz-686897F4.dip0.t-ipconnect.de)
[08:36:03] <geomyidae> yay, basically rewrote the pcap bindings from scratch, have a simple app working. Still a question or two though. https://github.com/colemickens/pcapfe/blob/master/rustpcap.rs#L56
[08:36:07] <geomyidae> Bug due to early return?
[08:36:58] <dbaupp> geomyidae: you need to acutally use `return ...` for early return
[08:37:00] <dbaupp> *actually
[08:37:16] *** Joins: Skif (emschwar@moz-4C5BB5A8.beyondbb.com)
[08:37:24] <geomyidae> weird, I thought I'd tried that.
[08:37:39] <geomyidae> Ah! it looked like the same case as like 91, but now I see that it's not.
[08:37:49] <eddyb> rusti: let x: VecIterator;
[08:37:58] <yichoi> current build is working ?
[08:38:28] <yichoi> i found that "test result: FAILED. 1324 passed; 3 failed; 54 ignored; 0 measured"
[08:38:43] <dbaupp> which tests?
[08:38:55] <yichoi> failures:
[08:38:55] <yichoi>     [run-pass] run-pass/float-literal-inference.rs
[08:38:55] <yichoi>     [run-pass] run-pass/intrinsics-math.rs
[08:38:57] *** Quits: Skif (emschwar@moz-4C5BB5A8.beyondbb.com) (Ping timeout)
[08:38:57] <yichoi>     [run-pass] run-pass/issue-2214.rs
[08:38:59] <yichoi> test result: FAILED. 1324 passed; 3 failed; 54 ignored; 0 measured
[08:39:01] <yichoi> task '<main>' failed at 'Some tests failed', /home/yichoi/rust_latest/src/compiletest/compiletest.rs:243
[08:39:21] *** Joins: alonlevy (alon@FEE13654.66334A3F.AB64B967.IP)
[08:39:23] <dbaupp> what platform?
[08:39:26] <yichoi> using metrics ratcher: tmp/check-stage2-T-x86_64-unknown-linux-gnu-H-x86_64-unknown-linux-gnu-rpass-metrics.json
[08:40:29] <dbaupp> is it windows?
[08:40:37] <kimundi> yichoi: Hm, the intrinsics are part of llvm. Have you tried reconfiguring and rebuilding?
[08:40:52] <cmr> Why would float type inference be failing though>
[08:41:19] <yichoi> kimundi: I removed build directory and reconfigured
[08:41:38] <dbaupp> oh, it's linux. hm.
[08:41:45] <klutzy> task '[run-pass] run-pass/float-literal-inference.rs' failed at 'explicit failure', /home/lime/src/rust-vanilla/src/compiletest/runtest.rs:892
[08:41:56] <klutzy> wow. I'm getting similar result; x64 debian.
[08:42:17] <klutzy> note: /usr/bin/ld: x86_64-unknown-linux-gnu/test/run-pass/issue-2214.o: undefined reference to symbol 'lgamma_r@@GLIBC_2.2.5'
[08:42:29] <cmr> ohh
[08:42:41] <yichoi> same as klutzy mentioned
[08:43:34] <yichoi> it could be noisy though,
[08:43:38] <yichoi> stderr:
[08:43:38] <yichoi> ------------------------------------------
[08:43:38] <yichoi> error: linking with `cc` failed: exit code: 1
[08:43:40] <yichoi> note: cc arguments: '-m64' '-L/home/yichoi/rust_latest/build/x86_64-unknown-linux-gnu/stage2/lib/rustc/x86_64-unknown-linux-gnu/lib' '-o' 'x86_64-unknown-linux-gnu/test/run-pass/issue-2214.stage2-x86_64-unknown-linux-gnu' 'x86_64-unknown-linux-gnu/test/run-pass/issue-2214.o' '-Wl,--as-needed' '-Wl,-O1' '-L/home/yichoi/rust_latest/build/x86_64-unknown-linux-gnu/stage2/lib/rustc/x86_64-unknown-linux-gnu/lib' '-lstd-6425b930ca146ae9-0.
[08:43:42] <yichoi> 9-pre' '-L/home/yichoi/rust_latest/build/x86_64-unknown-linux-gnu/stage2/lib/rustc/x86_64-unknown-linux-gnu/lib' '-lrustuv-a13edc95d75df17-0.9-pre' '-Lx86_64-unknown-linux-gnu/test/run-pass' '-Lx86_64-unknown-linux-gnu/test/run-pass/issue-2214.stage2-x86_64-unknown-linux-gnu.libaux' '-L/home/yichoi/rust_latest/build/.rust' '-L/home/yichoi/rust_latest/build' '-lmorestack' '-Wl,-rpath,$ORIGIN/../../stage2/lib/rustc/x86_64-unknown-linu
[08:43:44] <yichoi> x-gnu/lib' '-Wl,-rpath,/home/yichoi/rust_latest/build/x86_64-unknown-linux-gnu/stage2/lib/rustc/x86_64-unknown-linux-gnu/lib' '-Wl,-rpath,/usr/local/lib/rustc/x86_64-unknown-linux-gnu/lib'
[08:43:47] <yichoi> note: /usr/bin/ld: x86_64-unknown-linux-gnu/test/run-pass/issue-2214.o: undefined reference to symbol 'lgamma_r@@GLIBC_2.2.5'
[08:43:49] <yichoi> /lib/x86_64-linux-gnu/libm.so.6: error adding symbols: DSO missing from command line
[08:43:51] <yichoi> collect2: error: ld returned 1 exit status
[08:44:49] <yichoi> Is there anyone who has posted this to issue tracker ?
[08:47:53] *** Quits: Ms2ger (Ms2ger@C91975CB.3387515C.187A1082.IP) (Quit: bbl)
[08:51:07] *** Joins: peterdn (chatzilla@moz-14D19651.as13285.net)
[08:56:07] *** Quits: moostik (Icedove@moz-C2FFB694.w82-121.abo.wanadoo.fr) (Ping timeout)
[08:57:44] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[08:58:15] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[08:58:15] *** ChanServ sets mode: +o pnkfelix
[08:59:30] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[08:59:30] *** Joins: moostik (Icedove@moz-5159DC42.w92-151.abo.wanadoo.fr)
[09:02:43] *** Quits: alonlevy (alon@FEE13654.66334A3F.AB64B967.IP) (Ping timeout)
[09:03:32] <klutzy> seems like -lm is missing
[09:03:50] <klutzy> `rustc intrinsics-math.rs -Z prefer-dynamic --link-args "-lm" && ./intrinsics-math` works
[09:05:55] *** Joins: autra (augustin@A14DAE84.7F753DD1.EE2CA32B.IP)
[09:07:09] *** Quits: m_kato (m_kato@moz-C286AD9A.bitcat.net) (Quit: Leaving...)
[09:08:35] *** Quits: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com) (Quit: csherratt)
[09:09:08] *** Quits: lpy (lpy@7360AA58.F09091A8.1348A864.IP) (Ping timeout)
[09:10:06] <eddyb> error: failed to find an implementation of trait std::iter::Iterator<<V789>> for ~std::vec::VecIterator<,*middle::ty::t_opaque>
[09:10:25] <eddyb> hmmm, why would that be?
[09:10:35] <cmr> eddyb: http://i.imgur.com/FdEPBUa.png jemalloc  does nothing.
[09:10:55] <cmr> (or, nothing to the "leak" I'm talking about)
[09:11:11] <eddyb> cmr: that's not the graph I saw, let me search for it
[09:12:17] *** Joins: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net)
[09:14:01] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Client exited)
[09:16:06] <eddyb> cmr: hmm, it's not as much as I remember though http://huonw.github.io/isrustfastyet/mem/#6b07d88,df187a0
[09:16:26] *** Quits: pradeep (pradeep@5AB4884B.FCC4549.14D5B978.IP) (Quit: leaving)
[09:16:51] <klutzy> yichoi: so I think the error is #2510 again
[09:16:59] *** Joins: amro (quassel@D9E34ACF.8AAAF769.FAAB0799.IP)
[09:17:38] <geomyidae> there a decimal lib?
[09:17:45] <cmr> eddyb: there's still a 600MB "leak" there
[09:17:45] *** Joins: derek_c (derek@moz-FB4F1795.cit.cornell.edu)
[09:18:26] <eddyb> cmr: but my assumption about @ always leaking was bogus. the AST is Freeze now, there's no way it can have cycles
[09:18:33] <derek_c> is there some documentation that explains the difference between the 3 optimization levels?
[09:18:46] <cmr> derek_c: not really
[09:18:56] <cmr> it's the same as clang's opt levels
[09:19:05] <cmr> they're progressively more aggressive
[09:19:08] <klutzy> `rustc empty.rs -Z print-link-args` shows "-lrt -ldl -lm` but `-Z prefer-dynamic` doesn't
[09:19:12] *** Quits: jdm (jdm@moz-AC9499B2.cable.teksavvy.com) (Quit: Lost terminal)
[09:19:44] <derek_c> cmr: I was wondering why -O stands for opt-level 2, rather than 3?
[09:19:57] <cmr> derek_c: 3 has dubious utility
[09:20:06] <kimundi> eddyb: If a type T implements a trait, that doesn'T automatic mean that ~T implements that trait
[09:20:09] <cmr> it takes longer and sometimes (although not very often) misoptimizes
[09:20:18] <derek_c> cmr: interesting
[09:20:41] <eddyb> kimundi: but... that would mean constructs which I've seen before won't work
[09:21:12] <kimundi> which ones?
[09:21:14] <cmr> eddyb: the Session_ holds on to very large structures.
[09:21:28] *** Quits: geomyidae (quassel@DD6F7E3A.21468E9A.30200F38.IP) (Client exited)
[09:21:36] <kimundi> It is possible to generically implement a trait in a way that ~T will just pass through the trait impld to the T
[09:21:42] <eddyb> kimundi: flat_map with the inner closure returning .iter()
[09:21:48] <cmr> eddyb: we don't need the session at all after trans, that is the root cause of the leak afaik
[09:22:08] <kimundi> eddyb: Hu, and what is starnge with that?
[09:22:09] <cmr> kimundi: I don't think that is true... not exactly sure.
[09:22:21] <kimundi> cmr: Which part?
[09:22:27] <cmr> Trait *objects* don't implementtheir respective trait, but I thought ~T did.
[09:22:45] <kimundi> Pretty sure they don't
[09:22:50] *** Quits: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[09:22:52] <eddyb> cmr: the solution here would be to drop the session or parts of it. it should be easy ^_^
[09:23:00] <kimundi> because of autoderef/autoref you can usually call trait methods on them though
[09:23:10] <eddyb> kimundi: I am doing the same thing. .iter >_< NEVERMIND
[09:23:14] <cmr> eddyb: yes, now go do it :p
[09:23:16] *** Joins: geomyidae (quassel@DD6F7E3A.21468E9A.30200F38.IP)
[09:23:21] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Ping timeout)
[09:23:43] <kimundi> eddyb: Now I'm confused too :)
[09:23:46] <eddyb> kimundi: I had ~[foo, bar].iter(). guess what that did
[09:23:50] *** Joins: banananana (ba@E7E2A35D.6F99A8B0.2AADDDA7.IP)
[09:23:55] <eddyb> ~([foo, bar].iter())
[09:24:05] <kimundi> yep, thats a ugly gotcha :P
[09:24:11] *** Quits: derek_c (derek@moz-FB4F1795.cit.cornell.edu) (Quit: Leaving)
[09:24:28] *** Joins: lpy (lpy@7360AA58.F09091A8.1348A864.IP)
[09:25:00] <eddyb> I wanted to use iterators so there's less useless allocations
[09:25:00] <cmr> eddyb: basically you just need to split out the things phase 5 and 6 need from the Session, and then you should be able to run them in a separate task... might need to do some unsafe jiggery to get the llvm context out of phase 4 though
[09:25:03] * kimundi still thinks those unary operators have to high precendcy
[09:26:21] <eddyb> maybe the SmallVec in syntax::util could have a cheap flat_map :D
[09:26:37] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Client exited)
[09:26:58] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[09:27:43] *** Joins: arodier74 (Thunderbir@5901C3C8.B6144566.D3B9122.IP)
[09:28:45] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[09:29:16] *** Joins: alonlevy (alon@moz-F53E4C49.redhat.com)
[09:30:04] <eddyb> context: I'm trying to make (A, ..(B, ..(C, D))) => (A, B, C, D) work in astconv
[09:30:58] <eddyb> pffft, iterators won't work. at least not like this
[09:33:22] *** Quits: Kxepal (Miranda@moz-B3E59235.pppoe.mtu-net.ru) (Ping timeout)
[09:34:46] *** Quits: sigma (sigma@moz-A17EB325.range86-184.btcentralplus.com) (Client exited)
[09:35:28] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Ping timeout)
[09:35:59] *** Joins: Kxepal (Miranda@moz-BFDF5C72.pppoe.mtu-net.ru)
[09:36:27] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[09:39:47] *** Quits: b (b@moz-55CA322E.org) (Ping timeout)
[09:43:59] *** Joins: b (b@moz-55CA322E.org)
[09:45:52] *** Joins: Ms2ger (Ms2ger@moz-313707C8.ugent.be)
[09:46:18] *** Joins: Earnestly (earnest@38FE72A5.82423D8F.BFD1ABFD.IP)
[09:48:19] *** Joins: sigma (sigma@moz-A17EB325.range86-184.btcentralplus.com)
[09:48:33] *** Quits: ww (Mibbit@moz-DFAED48A.lightspeed.sntcca.sbcglobal.net) (Quit: http://www.mibbit.com ajax IRC Client)
[09:49:19] *** Quits: mye (mye@moz-FD24DF07.dip0.t-ipconnect.de) (Quit: mye)
[09:52:56] *** Quits: eddyb (eddy@moz-68E0B7D0.residential.rdsnet.ro) (Ping timeout)
[09:54:42] *** Joins: eddyb (eddy@moz-68E0B7D0.residential.rdsnet.ro)
[09:56:35] *** Quits: eddyb (eddy@moz-68E0B7D0.residential.rdsnet.ro) (Ping timeout)
[09:57:07] *** Joins: jlong (jlong@moz-6DFDE846.socal.res.rr.com)
[09:58:22] *** Joins: eddyb (eddy@moz-68E0B7D0.residential.rdsnet.ro)
[10:01:43] *** Joins: sk (sk@61A494B3.BA40E8A.AAC02D62.IP)
[10:02:58] *** Quits: Ferreus (ferreus@moz-686897F4.dip0.t-ipconnect.de) (Ping timeout)
[10:08:03] *** Quits: mcarberry (mcarberry@moz-BE1C9F3F.lightspeed.frokca.sbcglobal.net) (Ping timeout)
[10:08:54] *** Quits: heftig (heftig@moz-64703EED.dip0.t-ipconnect.de) (Quit: Quitting)
[10:09:16] *** Quits: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz) (Quit: Busying myself...)
[10:10:47] *** Joins: andre_ (andre@CA528A4A.45A4338E.8EE27E6.IP)
[10:12:22] *** Joins: lenstr (lenstr@4B2BB55F.66633156.B69CD7C4.IP)
[10:13:25] *** Quits: lenstr (lenstr@4B2BB55F.66633156.B69CD7C4.IP) (Quit: Leaving...)
[10:13:40] *** Joins: Blei (philipp@moz-B2F9E4BD.cust.bluewin.ch)
[10:14:11] *** Joins: shmoo (Mibbit@811BE065.AFFD1D85.98D1B9A9.IP)
[10:17:41] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[10:18:30] <eddyb> <3 https://gist.github.com/eddyb/fa60028cea6787437d8f
[10:18:44] *** Joins: nkoep (nik@moz-5F3B1C42.pool.mediaways.net)
[10:19:50] <cmr> eddyb: the span shouldn't cover the .. I don't think
[10:21:57] <eddyb> cmr: okay, that's easy to fix
[10:22:11] *** Quits: ssbr_ (~ssbr@46FE74EC.C60FE7DC.4065847B.IP) (Ping timeout)
[10:22:47] <cmr> yup!
[10:22:54] <eddyb> test.rs:7:19: 7:22 error: cannot expand non-tuple type: &middle::ty::t_box_{sty: ty_param(middle::ty::param_ty{idx: 1u, def_id: syntax::ast::DefId{crate: 0u32, node: 66u32}}), id: 28u, flags: 1u}
[10:23:04] <eddyb> I was so afraid of this :(
[10:23:22] *** Joins: mcarberry (mcarberry@moz-BE1C9F3F.lightspeed.frokca.sbcglobal.net)
[10:24:28] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[10:24:45] *** Joins: Ferreus (ferreus@moz-686897F4.dip0.t-ipconnect.de)
[10:25:07] <cmr> use util::ppaux::ty_to_str ?
[10:26:08] <eddyb> cmr: nah, not that. basically something like type Foo<T> = (..T);
[10:26:21] *** Joins: Skif (emschwar@moz-4C5BB5A8.beyondbb.com)
[10:26:50] <eddyb> I was hoping I can get away without changing middle::ty
[10:27:09] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Ping timeout)
[10:28:07] *** Quits: Skif (emschwar@moz-4C5BB5A8.beyondbb.com) (Ping timeout)
[10:29:15] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[10:29:41] *** Quits: amro (quassel@D9E34ACF.8AAAF769.FAAB0799.IP) (Ping timeout)
[10:30:37] *** Quits: isaacd (me@moz-6902374D.dhcp.oxfr.ma.charter.com) (Ping timeout)
[10:30:46] *** Joins: amro (quassel@D9E34ACF.8AAAF769.FAAB0799.IP)
[10:30:58] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[10:33:19] *** Joins: ssbr_ (~ssbr@46FE74EC.C60FE7DC.4065847B.IP)
[10:33:48] *** Joins: isaacd (me@moz-6902374D.dhcp.oxfr.ma.charter.com)
[10:34:49] *** Quits: lpy (lpy@7360AA58.F09091A8.1348A864.IP) (Ping timeout)
[10:36:18] *** Quits: vky (chatzilla@moz-4F2E17BF.dsl.dynamic.sonic.net) (Ping timeout)
[10:38:53] *** Quits: isaacd (me@moz-6902374D.dhcp.oxfr.ma.charter.com) (Ping timeout)
[10:43:01] *** Quits: peterdn (chatzilla@moz-14D19651.as13285.net) (Ping timeout)
[10:44:31] *** Quits: Ferreus (ferreus@moz-686897F4.dip0.t-ipconnect.de) (Ping timeout)
[10:45:42] *** Joins: isaacd (me@moz-6902374D.dhcp.oxfr.ma.charter.com)
[10:50:35] *** Quits: arodier74 (Thunderbir@5901C3C8.B6144566.D3B9122.IP) (Ping timeout)
[10:55:02] *** Joins: lpy (lpy@7360AA58.F09091A8.1348A864.IP)
[10:55:48] *** Joins: arodier74 (Thunderbir@5901C3C8.B6144566.D3B9122.IP)
[10:56:32] *** Joins: bjz (bjz@moz-DD4A2A91.lnse2.cha.bigpond.net.au)
[10:57:53] *** Quits: arodier74 (Thunderbir@5901C3C8.B6144566.D3B9122.IP) (Connection reset by peer)
[10:59:26] *** Quits: Sgeo (quassel@moz-D0F30617.dyn.optonline.net) (Ping timeout)
[10:59:34] *** Joins: Sgeo (quassel@moz-D0F30617.dyn.optonline.net)
[11:00:48] *** Joins: oberstet (quassel@moz-920A8A63.dynamic.mnet-online.de)
[11:02:07] *** Joins: arodier74 (Thunderbir@5901C3C8.B6144566.D3B9122.IP)
[11:05:05] *** Joins: Kauhsa (kauhsa@moz-A78B2D1A.fi)
[11:08:40] *** Joins: heftig (heftig@moz-E8E2034C.inf.fh-bonn-rhein-sieg.de)
[11:13:13] *** Quits: ssbr_ (~ssbr@46FE74EC.C60FE7DC.4065847B.IP) (Ping timeout)
[11:14:36] <aph> anyone else having -lrustrt not found errors lately? >_>
[11:15:21] <cmr> aph: rustrt is now statically linked to libstd.
[11:16:28] *** Quits: dew1 (Instantbir@moz-E4452B8F.static.stls.mo.charter.com) (Ping timeout)
[11:16:36] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Quit: Gone to save the world!)
[11:16:41] *** Joins: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com)
[11:17:05] <aph> cmr: thanks... i guess i have somehow mixed up my rustc version
[11:18:28] *** Quits: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com) (Ping timeout)
[11:20:14] *** Joins: ssbr_ (~ssbr@46FE74EC.C60FE7DC.4065847B.IP)
[11:20:25] *** Joins: skade (skade@30BBD5E6.505237C9.CAE22B62.IP)
[11:20:57] <dbaupp> cmr: is that new with alex's recent PRs?
[11:21:10] *** Quits: shmoo (Mibbit@811BE065.AFFD1D85.98D1B9A9.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[11:21:49] <cmr> dbaupp: yeah
[11:21:53] <cmr> static linking landed!
[11:24:56] *** Quits: brendan (brendaneic@moz-D5E1B4C6.w193-248.abo.wanadoo.fr) (Quit: brendan)
[11:27:11] <jix> so what exactly did I do wrong when I get those -lrustrt not found errors?
[11:27:22] *** Joins: mib_zff9bz (Mibbit@811BE065.AFFD1D85.98D1B9A9.IP)
[11:27:32] *** Quits: mib_zff9bz (Mibbit@811BE065.AFFD1D85.98D1B9A9.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[11:27:33] *** Quits: blank_name (blank_name@FAB53C88.7071B2C8.31EC03F3.IP) (Ping timeout)
[11:27:41] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[11:27:43] <aph> jix: you didn't wish for static linking hard enough :)
[11:29:24] <cmr> We don't even ship librustrt anymore.
[11:29:26] *** Quits: isaacd (me@moz-6902374D.dhcp.oxfr.ma.charter.com) (Ping timeout)
[11:30:04] <jix> but somehow -lrustrt is still passed to the linker here
[11:30:09] <cmr> Where? By what?
[11:30:22] <jix> I'm trying to figure that out
[11:30:51] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[11:30:56] <cmr> Oh hm I get it too now.
[11:31:02] * cmr just updated rustc
[11:31:06] <cmr> acrichto: you broke everything!
[11:31:12] <cmr> aph: jix: using the arch packages?
[11:31:21] <jix> yeah I am
[11:31:23] <aph> cmr: git master
[11:31:26] <cmr> ok
[11:31:47] <aph> cmr: couldn't make install until this morning 'cos #10753
[11:32:17] *** Joins: isaacd (me@moz-6902374D.dhcp.oxfr.ma.charter.com)
[11:32:20] <aph> cmr: so i assumed i had just messed up my PATH or something
[11:32:37] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[11:32:56] *** Joins: Heather (Heather@19663F6.F53BAACC.9C17E900.IP)
[11:33:02] <Heather> hey
[11:33:06] <Heather> how to add one list to another
[11:33:25] <cmr> ok, rustrt libs are built, but not installed.
[11:33:38] <eddyb> Heather: vector or list?
[11:33:50] <Heather> eddyb em.... array
[11:33:50] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[11:33:57] <Heather> eddyb [] thing
[11:33:59] <eddyb> Heather: + should work
[11:34:06] <Heather> wow...
[11:34:12] <Ms2ger> And +=? :)
[11:34:20] <eddyb> .push_all, too
[11:34:26] <jix> are the arch packages of the last days online somwhere?
[11:34:36] <cmr> jix: no
[11:34:42] <Heather> and how to add one list ( without first 2 arguments ) to another ? :)
[11:34:42] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[11:34:47] <cmr> they'rein your pacman cache though
[11:34:53] <Heather> remove 2 first arguments first?
[11:34:59] <eddyb> Heather: just .slice
[11:35:06] <Heather> slice?
[11:35:20] <jix> cmr: yeah, but then I have to go back a bit more than just a day or two.... but not too big of a problem right now
[11:35:43] *** Joins: Sorella (quildreen@D2D1E5DD.81EFC25A.A95FAE2B.IP)
[11:35:44] <cmr> Heather: any particular reason you can't use iterators?
[11:35:56] <cmr> s.iter().skip(2).zip(other_iterator)
[11:36:10] <eddyb> zip? you mean chain?
[11:36:21] <cmr> yes
[11:36:23] <cmr> I do
[11:36:26] <Heather> hm
[11:36:30] <Heather> how chain works?
[11:36:42] <cmr> http://static.rust-lang.org/doc/master/src/std/home/rustbuild/src/rust-buildbot/slave/doc/build/src/libstd/iter.rs.html#977-981
[11:36:53] <eddyb> Heather: after the first iterator finishes, it starts from the second one
[11:37:05] *** Joins: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net)
[11:37:09] <eddyb> a.iter().chain(b.iter()).collect() is pretty much a+b
[11:37:43] <Heather> so I need 07 01a.iter().chain(b.skip(2).iter()).collect()01 ? :)
[11:37:55] <cmr> b.iter().skip(2)
[11:38:01] <Heather> ye
[11:38:21] <cmr> You don't need the collect unless you absolutely need the data. Just using the iterator is more efficient.
[11:38:49] <cmr> aph: jix: copying librustrt.* to /usr/local/lib fixes the problem.
[11:38:50] <cmr> acrichto: ^
[11:38:55] *** Joins: donri (donri@moz-9BB61102.tbcn.telia.com)
[11:39:13] <kimundi> (Note that iter() yields you references to the values in the vector)
[11:40:09] <Heather> I need data to unify another function input
[11:40:14] <Heather> I think...
[11:40:43] <aph> cmr: librustrt.a from stage2 or..?
[11:41:08] <cmr> aph: from stage2 yeah
[11:41:14] <cmr> (also librustrt.so)
[11:41:35] <cmr> I *thought* it was statically linked to libstd, but maybe not?
[11:42:31] *** Joins: Ferreus (ferreus@moz-686897F4.dip0.t-ipconnect.de)
[11:42:54] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[11:44:44] *** Quits: isaacd (me@moz-6902374D.dhcp.oxfr.ma.charter.com) (Ping timeout)
[11:45:02] <aph> cmr: thanks; for reference, `cp ./x86_64-apple-darwin/stage2/lib/rustc/x86_64-apple-darwin/lib/librustrt.a /usr/local/lib/rustc/x86_64-apple-darwin/lib/` fixed it for me
[11:45:17] *** Quits: Ms2ger (Ms2ger@moz-313707C8.ugent.be) (Quit: bbl)
[11:45:51] *** Joins: CarpNet (ac@moz-FD24B77.sohonet.co.uk)
[11:46:48] *** Joins: isaacd (me@moz-6902374D.dhcp.oxfr.ma.charter.com)
[11:48:24] <aph> cmr: (there was no .dylib built)
[11:48:36] *** Quits: isaacd (me@moz-6902374D.dhcp.oxfr.ma.charter.com) (Ping timeout)
[11:55:05] <geomyidae> is some/any proc documentation incoming?
[11:57:25] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Input/output error)
[11:57:30] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[12:00:23] *** Quits: Sorella (quildreen@D2D1E5DD.81EFC25A.A95FAE2B.IP) (Client exited)
[12:00:54] *** Joins: isaacd (me@moz-6902374D.dhcp.oxfr.ma.charter.com)
[12:02:40] *** Joins: Sorella (quildreen@2392D500.600E39D3.1ED99692.IP)
[12:05:01] *** Joins: tiffany (kawaii@moz-FC0DB29D.dhcp.embarqhsd.net)
[12:07:05] *** Joins: kphelps (kphelps@moz-8B098CA5.hsd1.ma.comcast.net)
[12:07:15] <Heather> chain gives me error: failed to find an implementation of trait std::iter::FromIterator<&&str> for &[&str]
[12:07:51] <dbaupp> You'll need to .map(|s| *s)
[12:08:01] <eddyb> or .move_iter, maybe
[12:08:02] <dbaupp> and also .collect() to a ~[]
[12:08:18] <dbaupp> e.g. .collect::<~[&str]>(), or just .to_owned_vec()
[12:08:27] <Heather> :S
[12:09:23] *** Quits: moostik (Icedove@moz-5159DC42.w92-151.abo.wanadoo.fr) (Ping timeout)
[12:10:00] <Heather> failed to find an implementation of trait std::iter::FromIterator<&str> for &[&str]
[12:10:15] <dbaupp> you're not collecting to a ~[]
[12:10:24] <eddyb> Heather: you're still trying to create a &[]
[12:11:03] <Heather> eddyb yes...
[12:11:21] <eddyb> you can't. you have to collect to a ~[]
[12:11:33] <dbaupp> (it's probably inferring that it only needs a &[] because the result is being used in a function that takes &[], in those cases one has to manually override it, since ~[] is the only vector that is manually extendable (as is required for this).)
[12:11:51] <dbaupp> s/manually extendable/dynamically extendable/
[12:11:52] <mark_edward> what was the point of the change to do notation? all it seems to do is break code
[12:12:12] <cmr> mark_edward: it removed closure inference.
[12:12:31] <dbaupp> Heather: https://www.nuget.org/packages/Rust/ ! very cool :)
[12:12:41] <Heather> dbaupp thanks
[12:12:42] <mark_edward> cmr, but what does inference have to do with do notation?
[12:12:57] <cmr> mark_edward: do X { ... } inferred the type of the closure it needed to be.
[12:12:58] <dbaupp> mark_edward: `do` used to be able to infer it's argument as &fn, ~fn or @fn
[12:13:04] <cmr> Now it doesn't infer, it's always a proc.
[12:13:07] <pnkfelix> mark_edward: see http://smallcultfollowing.com/babysteps/blog/2013/10/10/fn-types-in-rust/
[12:13:23] <pnkfelix> mark_edward: I think that provides at least some (tho' not all) background
[12:13:28] <dbaupp> mark_edward: one concern was that this was a concealed allocation for the ~fn and @fn case.
[12:13:35] <mark_edward> couldn't it just let you tell it which one it was?
[12:13:50] <geomyidae> seems a somewhat weird use of nuget. is it vying to be that sort of a package manager? I guess it fits into dev, not seen it used for packages outside the .NET ecosystem them
[12:14:02] <cmr> mark_edward: anyway, the lack of do will hopefully lead to a better future in the same way removing internal iteration did.
[12:14:19] <mark_edward> cmr, in what way?
[12:14:19] <dbaupp> (now that is always allocates it's not as concealed... but I reckon we should just nuke `do` and revisit it when we're not trying to squeeze things into the old `for`-derived design.)
[12:14:46] *** Joins: Skif (emschwar@moz-4C5BB5A8.beyondbb.com)
[12:15:38] <dbaupp> Heather: to be clear, that package is a nightly build on windows which users can install with a single command to get a working 'master' compiler, right?
[12:16:31] *** Quits: Skif (emschwar@moz-4C5BB5A8.beyondbb.com) (Ping timeout)
[12:16:45] <dbaupp> mark_edward: closures are less flexible than using RAII (and do encourages closures)
[12:17:05] <mark_edward> dbaupp, what on earth do closures and RAII have to do with each other?
[12:17:52] *** Quits: isaacd (me@moz-6902374D.dhcp.oxfr.ma.charter.com) (Ping timeout)
[12:18:07] <dbaupp> mark_edward: `do mutex.with_locked { foo() }` vs `let _lock = mutex.lock(); foo() /* `mutex` automatically unlocked in the dtor of `_lock` */`
[12:19:13] <mark_edward> i mean... you can just tell people to use RAII. it seems completely orthogonal to me
[12:19:25] <eddyb> the with_ pattern is *precisely* about RAII :P
[12:19:27] <dbaupp> you can just tell people lots of things
[12:19:33] <dbaupp> doesn't mean they'll do them
[12:19:48] <mark_edward> eddyb, the with pattern had little to do with my closure use. mostly iterators
[12:20:04] <eddyb> iterators + do?
[12:20:11] <dbaupp> http://dev.unhandledexpression.com/slides/rust-scalaio/#13.0 eh, doesn't typecheck
[12:20:13] <mark_edward> no, just map, filter, etc
[12:20:30] <cmr> you don't need do to use htose
[12:20:39] * cmr never used do for them
[12:20:40] <eddyb> mark_edward: I mean, were you using do on those iterator adaptors?
[12:20:47] <mark_edward> eddyb, no
[12:20:55] <dbaupp> http://dev.unhandledexpression.com/slides/rust-scalaio/#17.0 eh, old for!
[12:20:57] <cmr> So what'sthe problem?
[12:21:02] <cmr> dbaupp: when are tehse from?
[12:21:09] <mark_edward> eddyb, and what is the replacement for the with_pattern, with say  &T.as_imm_buf? it seems to be the only reasonable
[12:21:12] <pnkfelix> mark_edward: The `do` notation is used to feed a closure into another function.  It seems like a common use case for this was for feeding into functions that called the closure exactly once, so-called "once functions"
[12:21:37] <cmr> 25 october..
[12:21:43] <dbaupp> cmr: dunno, just found a link on twitter (looks like a "scala io" conference or something)
[12:21:51] <dbaupp> cmr: ("current version 0.8" though)
[12:22:18] *** Joins: peterdn (chatzilla@moz-14D19651.as13285.net)
[12:22:20] <mark_edward> pnkfelix, i see. 
[12:22:21] *** Quits: peterdn (chatzilla@moz-14D19651.as13285.net) (Quit: peterdn)
[12:22:26] <Heather> dbaupp what I do is &[&""] + a.iter().map(|s| *s) .skip(2)  .to_owned_vec() <- It works
[12:22:46] <eddyb> Heather: LOL
[12:22:47] <Heather> dbaupp not sure if I can make same with chain
[12:22:57] <Heather> eddyb what do you mean but LOL ?
[12:22:58] <mark_edward> all of a sudden my  code won't link... complaining about -lrustrt
[12:23:11] <Heather> eddyb do you remember my self folder detecting inter ?
[12:23:32] <Heather> eddyb self_exe_path()                             .map(|p| p.as_str()                             .map(|s| s.to_owned()))                             .unwrap().unwrap()
[12:23:41] <eddyb> Heather: a.iter().map(|s| *s).skip(2).to_owned_vec() is a crazy way to say a.slice_from(2) (not sure on the exact function name and parameters)
[12:23:53] <Heather> >_<
[12:23:57] <dbaupp> eddyb: that's correct
[12:23:58] <Heather> rly
[12:24:01] <Heather> lemme try
[12:24:12] *** Joins: peterdn (chatzilla@moz-14D19651.as13285.net)
[12:24:15] <eddyb> I did say slice the first time :P
[12:24:35] <Heather> eddyb no but I asked "slice?" after you did first
[12:24:37] <eddyb> I think .iter().map(|s| *s) is .move_iter()
[12:24:43] <pnkfelix> mark_edward: While deciding how to balance features (once fn's, ~fn, &fn, etc), it was decided the way forward is: `|A| -> B` to denote what was formerly `&fn` and using `proc` to denote `~once fn` (i think).  And then along with that it was decided that `do` would be dedicated to `proc.  Again, see http://smallcultfollowing.com/babysteps/blog/2013/10/10/fn-types-in-rust/ for the full story.
[12:24:58] <kimundi> eddyb: Not exactly, but both yield by value
[12:25:06] <eddyb> Heather: yeah, sorry about that, I wasn't sure what to tell you. I should have the docs handy ^_^
[12:25:07] <pnkfelix> (well, not the full story.  you'd have to go over mtg minutes and more blog posts/ mailing list ports etc)
[12:25:13] <Heather> wow... it works
[12:25:24] <Heather> thanks
[12:26:21] <mark_edward> pnkfelix, ok thanks for the explanation!
[12:26:34] <mark_edward> now i am getting linking errors for -lrustrt
[12:26:41] * pnkfelix would probably care more about the loss of do for &fn's, except he was never all that enamored with it in the first place.
[12:26:43] <mark_edward> anyone know what's causing that?
[12:26:50] *** Quits: six600110 (six600110@moz-C663577C.hsd1.il.comcast.net) (Client exited)
[12:26:57] <pnkfelix> mark_edward: perhaps old installation confusing things?
[12:26:58] <dbaupp> eddyb: .move_iter() is different
[12:27:08] <cmr> mark_edward: acrichto broke make install. cp librustrt.* from stage2 to your $prefix/lib
[12:27:11] <pnkfelix> oh wait, maybe my buiild today is failing too
[12:27:18] <dbaupp> eddyb: a.move_iter() consumes `a` while a.iter().map(|s| *s) doesn't
[12:27:20] <mark_edward> cmr, im using the Ubuntu repo
[12:27:29] <cmr> mark_edward: well, out of luck then :( downgrade
[12:27:34] <eddyb> dbaupp: but the latter doesn't work with everything?
[12:27:36] <dbaupp> eddyb: (the latter requires s not move by default.)
[12:28:11] <eddyb> will try to remember that :D
[12:28:23] <dbaupp> eddyb: yes but .move_iter() is only rarely desirable (it's significantly more expensive than .iter()... and also more expensive than .move_rev_iter  funnily enough.)
[12:28:24] <mark_edward> don't you have test-bots or something?
[12:28:36] *** Joins: mh (Mibbit@moz-EC44B29B.hsd1.dc.comcast.net)
[12:28:38] <cmr> yes, but the test suite doesn't exercise `make install`
[12:28:58] <dbaupp> we should be able to fix that, right?
[12:29:15] <mark_edward> cmr, it's not just that, I can't compile anything anymore. 
[12:29:18] <cmr> could probably have smoke tests that catch baisc things.
[12:29:22] <dbaupp> add a `make install` `rustc hello-world.rs` step on the linux build bots?
[12:29:33] <Heather> how to convert ~[] to &[] ?
[12:29:39] <cmr> mark_edward: it is just that, though.
[12:29:41] <cmr> Heather: .as_slice()
[12:29:41] <pnkfelix> yeah I'm getting build problems on "mac" at stage1
[12:29:41] <dbaupp> Heather: it will borrow automatically
[12:29:42] <eddyb> Heather: .as_slice()
[12:29:45] <pnkfelix> cmr: ^
[12:29:51] * dbaupp says .as_slice() too
[12:29:53] <Heather> ah right ) thanks
[12:29:54] <mark_edward> cmr, what do you mean?
[12:29:56] <cmr> pnkfelix: hm? it doesn't even build?
[12:30:04] <pnkfelix> cmr: I'm double-checking now
[12:30:17] *** Quits: recrack (Mibbit@5AB4884B.FCC4549.14D5B978.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[12:30:21] <pnkfelix> cmr: I need to make sure there wasn't a mistake (e.g. previous build artifacts)
[12:30:33] <cmr> mark_edward: adding librustrt will fix it.
[12:30:56] *** Joins: canhtak (canhtak@moz-A53E1151.wl.t.ulaval.ca)
[12:31:28] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[12:32:10] *** Quits: canhtak (canhtak@moz-A53E1151.wl.t.ulaval.ca) (Quit: canhtak)
[12:33:30] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[12:33:34] <Heather> I did it !
[12:33:40] <Heather> I transfer arguments...
[12:33:56] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[12:34:46] <kimundi> Hehe
[12:34:56] <kimundi> Heather: Don'T worry, that stuff gets easier over time :)
[12:35:14] <Heather> kimundi you will wonder how https://github.com/Heather/Mirana/commit/17bf27a2850a8dc2eb34f6b4f3a68fbe0392cbea
[12:35:42] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[12:36:32] *** Quits: heftig (heftig@moz-E8E2034C.inf.fh-bonn-rhein-sieg.de) (Ping timeout)
[12:38:35] <Heather> rusti: let r = (|u:|s:|t:|||||{u(|t:|||{t()})})(|s:|t:||||{s(||{()})}));
[12:39:38] <Heather> rust got really fancy closures =)
[12:39:43] <mark_edward> why is rust distributed with llvm instead of having it as a dependency? do you guys make some patches?
[12:39:47] <dbaupp> Heather: (rusti is currently version 0.8, so that syntax won't work.)
[12:39:48] <dbaupp> mark_edward: yes
[12:40:13] <mark_edward> dbaupp, are they planned to eventually be upstreamed?
[12:40:15] <dbaupp> https://github.com/mozilla/rust/issues/4259 is devoted to upstreaming them so that we can just use the normal system LLVM
[12:40:18] <dbaupp> ^
[12:40:59] <dbaupp> (with the removal of segmented stacks the task is likely easier, since we don't need to push the custom patches handling that up.)
[12:43:05] *** Joins: heftig (heftig@77B1EA81.41660100.172227A7.IP)
[12:44:02] *** Joins: isaacd (me@moz-6902374D.dhcp.oxfr.ma.charter.com)
[12:44:09] *** Quits: autra (augustin@A14DAE84.7F753DD1.EE2CA32B.IP) (Quit: by!)
[12:44:59] <eddyb> mark_edward: are you working on OpenSUSE packages? or was it someone else?
[12:45:11] <mark_edward> eddyb, no, Ubuntu packages
[12:45:23] <eddyb> okay, then it was someone else. should grep my logs
[12:49:09] <Heather> I've got some gentoo ebuilds...
[12:49:35] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[12:55:43] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[12:55:46] *** kimundi is now known as zz_kimundi
[12:57:26] *** Quits: mh (Mibbit@moz-EC44B29B.hsd1.dc.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[12:58:55] *** Joins: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com)
[12:59:18] *** Quits: Heather (Heather@19663F6.F53BAACC.9C17E900.IP) (Quit: ~ Trillian - www.trillian.im ~)
[13:00:19] *** Quits: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com) (Quit: csherratt)
[13:00:29] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[13:01:02] *** Joins: zaphod_b (ford_p@moz-CCE57F2F.eblcom.ch)
[13:03:54] *** Joins: morphevs (Adium@moz-58E25D61.uzh.ch)
[13:05:38] *** Joins: canhtak (canhtak@moz-A53E1151.wl.t.ulaval.ca)
[13:07:17] *** Quits: morphevs (Adium@moz-58E25D61.uzh.ch) (Quit: Leaving.)
[13:08:12] *** Joins: Ms2ger (Ms2ger@C91975CB.3387515C.187A1082.IP)
[13:10:05] <mark_edward> what, now i can't even build rust from the git repo?
[13:10:15] <Ms2ger> I dunno, can you?
[13:10:20] <mark_edward> i can't
[13:10:22] <mark_edward> linker complain
[13:10:28] *** Joins: vky (chatzilla@moz-4F2E17BF.dsl.dynamic.sonic.net)
[13:10:39] <mark_edward> i don't get it, isn't each commit at least tested to build
[13:10:53] <cmr> the full test suite is run on every PR before merge
[13:11:01] <cmr> I just built master fine, though
[13:11:12] *** Quits: zaphod_b (ford_p@moz-CCE57F2F.eblcom.ch) (Ping timeout)
[13:11:12] <cmr> I wonder if it's only broken for clean builds...
[13:11:20] <mark_edward> but why am I getting undefined reference to rust_swap_registers and etc.
[13:11:30] <cmr> rustrt must be missing
[13:11:42] <mark_edward> can i do something
[13:11:46] <cmr> dunno
[13:13:04] <bstrie> so, we always say that rust's unique pointers are linear types (really affine types but w/e)
[13:13:07] <bstrie> BUT
[13:13:29] <bstrie> all the resources I've seen use "linear" and "affine" to refer to the number of times that the value is used, rather than the number of owners it has
[13:13:35] <bstrie> so is our terminology really correct?
[13:13:43] *** Quits: vky (chatzilla@moz-4F2E17BF.dsl.dynamic.sonic.net) (Ping timeout)
[13:13:44] <bstrie> maybe nmatsakis is the only one who can answer this question
[13:14:05] <cmr> bstrie: once you move it, it's gone.
[13:14:08] <cmr> borrows don't really count.
[13:14:16] <bstrie> cmr: but how do you define "use"
[13:14:16] <Ms2ger> Isn't that the same thing, really? :)
[13:14:19] *** Joins: vmx (vmx@moz-9193A9CB.dip0.t-ipconnect.de)
[13:14:22] <cmr> I said move, not use
[13:14:30] <bstrie> right, and I never said move :P
[13:15:08] *** Joins: zaphod_b (ford_p@moz-CCE57F2F.eblcom.ch)
[13:18:38] <pnkfelix> cmr: okay, I was now able to do a build from a clean build dir
[13:18:46] <pnkfelix> cmr: so my previous comment was a false alarm
[13:19:06] <cmr> pnkfelix: that's comforting
[13:19:19] <cmr> the build seems overly fragile right now though
[13:19:23] <benh> Or maybe our build system is nondeterministic
[13:20:10] *** Quits: zaphod_b (ford_p@moz-CCE57F2F.eblcom.ch) (Ping timeout)
[13:20:17] <Ms2ger> Probably
[13:20:23] <Ms2ger> It uses make, doesn't it?
[13:20:41] <Ms2ger> That's the main source of entropy in the universe
[13:24:09] *** Joins: refold (gman@moz-42D68426.a258.priv.bahnhof.se)
[13:24:56] *** Joins: zaphod_b (ford_p@moz-CCE57F2F.eblcom.ch)
[13:31:19] *** Quits: Sgeo (quassel@moz-D0F30617.dyn.optonline.net) (Connection reset by peer)
[13:32:56] *** Joins: Savago (Savago@D8B9C081.E820043D.D4C04133.IP)
[13:33:03] *** Quits: Sorella (quildreen@2392D500.600E39D3.1ED99692.IP) (Ping timeout)
[13:33:08] *** Quits: dsirenko (mitra@8E712A0.54C21BA0.9F317420.IP) (Quit: Konversation terminated!)
[13:33:49] *** Joins: dsirenko (mitra@8E712A0.54C21BA0.9F317420.IP)
[13:33:50] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[13:34:48] *** Joins: zslayton (Mibbit@moz-4806B979.nyc.res.rr.com)
[13:35:01] *** Quits: isaacd (me@moz-6902374D.dhcp.oxfr.ma.charter.com) (Ping timeout)
[13:35:33] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[13:35:49] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[13:36:47] *** Joins: Sorella (quildreen@D2D1E5DD.81EFC25A.A95FAE2B.IP)
[13:39:05] *** Joins: isaacd (me@moz-6902374D.dhcp.oxfr.ma.charter.com)
[13:40:04] *** Joins: [squiddy] (squiddy@moz-53C4D352.adsl.alicedsl.de)
[13:40:35] *** Quits: Sorella (quildreen@D2D1E5DD.81EFC25A.A95FAE2B.IP) (Ping timeout)
[13:40:47] *** Joins: sanxiyn (tinuviel@B4104EBB.3CC170B1.1E14B209.IP)
[13:40:59] *** Joins: Sorella (quildreen@D2D1E5DD.81EFC25A.A95FAE2B.IP)
[13:41:40] *** Quits: Sorella (quildreen@D2D1E5DD.81EFC25A.A95FAE2B.IP) (Quit: Ex-Chat)
[13:41:53] *** Joins: Sorella (quildreen@D2D1E5DD.81EFC25A.A95FAE2B.IP)
[13:43:10] *** Quits: heftig (heftig@77B1EA81.41660100.172227A7.IP) (Ping timeout)
[13:43:23] <sanxiyn> I am still reading "do" thread... can anyone summarize?
[13:44:47] <Ms2ger> do now uses procs
[13:44:52] *** Quits: [squiddy] (squiddy@moz-53C4D352.adsl.alicedsl.de) (Quit: Leaving)
[13:44:56] <Ms2ger> I think that's about it
[13:46:19] <sanxiyn> Well I know how do changed... (I actually have PR in queue fixing its aftermath) Thread is apparently about discussing the change.
[13:46:39] <Ms2ger> Ah
[13:46:57] <sanxiyn> It is a thread on rust-dev literally titled "do".
[13:46:59] <Ms2ger> I haven't read the thread, but I think it can be summarized as:
[13:47:03] <Ms2ger> "It's a good change"
[13:47:04] <Ms2ger> and
[13:47:06] <Ms2ger> "It's a bad change"
[13:47:10] <sanxiyn> ...
[13:47:30] <klutzy> Ms2ger: it's a good and bad summary!
[13:47:36] <Ms2ger> :D
[13:47:54] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[13:47:59] <Ms2ger> Ooh, better, it's syntax
[13:48:56] <sanxiyn> One point raised that do expression uses |args| {} syntax, but only works with procs, not the type using |args| syntax.
[13:50:14] <bstrie> sanxiyn: as a counterpoint, the purpose of `do` may just be to make it so that procs can be used with the nice closure syntax without being ambiguous :)
[13:51:29] <sanxiyn> I must confess I find all |args|-related syntax completely strange, unnecessary, and off-putting.
[13:51:45] <Ms2ger> Prefer (args) => {}?
[13:51:52] <sanxiyn> So "nice closure syntax" is an oxymoron to me.
[13:52:36] <sanxiyn> Ms2ger: (args) is at least better (although I also do not like double arrow)
[13:52:54] <Ms2ger> Sorry, I should not talk syntax in here, that never ends well :)
[13:52:56] <bstrie> nah (args) is gross :P
[13:53:02] *** Quits: isaacd (me@moz-6902374D.dhcp.oxfr.ma.charter.com) (Ping timeout)
[13:53:04] <bstrie> paren overload!
[13:53:15] <bstrie> get your lisp out of my programming language!
[13:53:22] <sanxiyn> I always thought || syntax in Ruby extremely ugly :( So I always wonder why people like it
[13:53:27] *** Joins: isaacd (me@moz-6902374D.dhcp.oxfr.ma.charter.com)
[13:53:32] <sanxiyn> It seems to be the case that people like it, so I want to understand that, but I can't
[13:53:40] *** Joins: heftig (heftig@77B1EA81.41660100.172227A7.IP)
[13:53:45] <Ms2ger> (closure (args) body)
[13:53:55] <sanxiyn> I want to make a popular programming language in the futue, so this needs study
[13:53:57] <bstrie> sanxiyn: there's no accounting for taste :)
[13:54:24] <mletterle> it would be nice if || was optional
[13:54:35] <sanxiyn> It would be nice if we get rid of || sugar.
[13:54:52] <bstrie> sanxiyn: || isn't sugar, that's how closures are written. they're a type all their own
[13:55:05] <mletterle> I don't mind |a, b| { blah, blah, do stuff with a and b }
[13:55:20] <mletterle> just that if there are no args, then empty || should be assumed.
[13:55:24] <sanxiyn> bstrie: Well the type wasn't written that way, like, months or two in the past!
[13:55:29] *** Quits: Sorella (quildreen@D2D1E5DD.81EFC25A.A95FAE2B.IP) (Ping timeout)
[13:55:29] <bstrie> mletterle: that's impossible to make unambiguous
[13:55:38] *** Joins: lfox (lfox@moz-343B6F0C.nyc.biz.rr.com)
[13:55:42] <mletterle> bstrie: probably, it still would be nice :)
[13:55:56] <sanxiyn> bstrie: I actually prefer fn(args) to |args|.
[13:55:58] *** Quits: isaacd (me@moz-6902374D.dhcp.oxfr.ma.charter.com) (Ping timeout)
[13:56:02] *** Joins: Sorella (quildreen@D2D1E5DD.81EFC25A.A95FAE2B.IP)
[13:56:10] <Ms2ger> bstrie, embrace the ambiguity! :)
[13:56:20] *** Quits: zslayton (Mibbit@moz-4806B979.nyc.res.rr.com) (Quit: http://www.mibbit.com ajax IRC Client)
[13:56:46] <bstrie> Ms2ger: hey, I've embraced ambiguity, I'm the one who still wants to turn ::<> into <> even if it means conflating parsing with typeck :P
[13:57:23] *** Quits: eddyb (eddy@moz-68E0B7D0.residential.rdsnet.ro) (Ping timeout)
[13:58:16] *** Quits: Sorella (quildreen@D2D1E5DD.81EFC25A.A95FAE2B.IP) (Client exited)
[13:58:24] <Kauhsa> a bit confused with lifetimes - is there a way to make this work http://pastebin.com/wfS6ze4a without lifetime being static?
[13:58:25] *** Joins: Sorella (quildreen@D2D1E5DD.81EFC25A.A95FAE2B.IP)
[13:58:44] <sanxiyn> bstrie: In general, I don't like having separate syntax for closures different from functions.
[13:58:45] *** Quits: beifeng (Mibbit@284C36E7.3062CEC3.670EEFD.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[13:58:47] <mletterle> Maybe only optional in places like where a function is taking it.. so if I have a signature like fn takes_a_block(blk: ||) then when I call it, it would be nice to do takes_a_block({ blah blah })
[13:58:51] <mletterle> or whatevs
[13:59:26] <sanxiyn> (In case of Rust, since Rust needs a way to denote lifetime of closed variables, some difference is necessary, but completely new way to write things?)
[13:59:34] <bstrie> sanxiyn: either way we're going to have to have functions that are *not* closures. and I'm not even talking about items, we already have nested function definitions that do not close over their environments. best to visually distinguish these IMO
[13:59:37] *** Joins: isaacd (me@moz-6902374D.dhcp.oxfr.ma.charter.com)
[13:59:43] <pnkfelix> or we could even write it as `do takes_a_block { blah blah }` … oh wait.
[13:59:45] * pnkfelix ducks
[13:59:51] <mletterle> pnkfelix: >.>
[14:00:05] <sanxiyn> bstrie: I guess my point is best not to distinguish those...
[14:00:25] <Kauhsa> it doesn't let me to not specify lifetime, fn print_test<'l, Iter: Iterator<&'l u8>> gives me ICE
[14:00:41] <bstrie> sanxiyn: then you're prioritizing implicitness over explicitness, which is what we are trying to avoid :)
[14:01:29] <cmr> kuuranne: rust version?
[14:01:29] <Ms2ger> Kauhsa, ICE? File an issue :)
[14:01:53] *** Joins: eddyb (eddy@moz-68E0B7D0.residential.rdsnet.ro)
[14:01:57] <Kauhsa> Ms2ger, it's reported already. I was just wondering if I'm even trying to do the right thing
[14:02:56] <Kauhsa> cmr, me? rustc 0.9-pre (61443dc 2013-12-01 15:36:58 -0800)
[14:03:01] <Kauhsa> using arch repository
[14:03:07] <cmr> yes, sorry.
[14:03:11] <cmr> File an issue please! :)
[14:03:31] *** Joins: Skif (emschwar@moz-4C5BB5A8.beyondbb.com)
[14:04:17] <mark_edward> hey i have a question
[14:04:18] *** Quits: tedh (tedh@moz-A5D1CAB7.public.wayport.net) (Ping timeout)
[14:04:30] <mark_edward> i'm writing a port of LZ4 to rust,
[14:04:31] <Kauhsa> cmr, I think it's this https://github.com/mozilla/rust/issues/10391
[14:05:04] <eddyb> mark_edward: I somehow doubt you're the first
[14:05:10] <mark_edward> should I implement the magic numbers/header at the beggining/end of stuff
[14:05:15] *** Quits: Skif (emschwar@moz-4C5BB5A8.beyondbb.com) (Ping timeout)
[14:05:19] <mark_edward> eddyb, i'm not, it's more academic at this point
[14:05:21] <cmr> mark_edward: the wrapper format?
[14:05:33] <mark_edward> cmr, yeah i think so.
[14:05:38] <eddyb> mark_edward: nevermind then :)
[14:05:56] <mark_edward> eddyb, what do you mean? what weere you gonna say?
[14:07:27] <eddyb> mark_edward: someone mentioned LZ4 wasn't much better than DEFLATE for metadata, on the ML. and I remember something about a rust library for compression algorithms. but if you don't have any specific plans for it, ignore me :P
[14:07:36] *** Quits: isaacd (me@moz-6902374D.dhcp.oxfr.ma.charter.com) (Ping timeout)
[14:07:51] <sanxiyn> Kauhsa: Yup, fix for #10391 is in queue, but not landed yet because of various problems
[14:07:54] <sanxiyn> Will be there soon
[14:08:07] <sanxiyn> Sorry for inconvinience
[14:08:14] *** Quits: canhtak (canhtak@moz-A53E1151.wl.t.ulaval.ca) (Quit: canhtak)
[14:08:21] *** Joins: morphevs (Adium@moz-A57EB56D.uzh.ch)
[14:08:29] <cmr> eddyb: I said it
[14:08:37] <cmr> But "better" is a multidimensional statement.
[14:08:43] <cmr> It's not an obvious win.
[14:08:56] *** Joins: isaacd (me@moz-6902374D.dhcp.oxfr.ma.charter.com)
[14:09:17] <sanxiyn> I note that https://github.com/alexcrichton/rust-compress has LZ4 implementation in Rust
[14:10:01] *** Joins: matthewhammer (Mibbit@moz-167627F4.wireless.umd.edu)
[14:10:11] <bstrie> could we just generate less metadata, so that we don't have to compress it? :)
[14:10:21] <cmr> bstrie: that would be ideal!
[14:10:53] <bstrie> really, is the problem just that the stdlib itself has so much metadata?
[14:10:56] <Kauhsa> sanxiyn, okay. the code that gives ICE is the "correct" way to do what I'm trying to do, even if does not work right now? :)
[14:11:04] <bstrie> what with all the #[inlines] and all?
[14:11:10] <sanxiyn> Kauhsa: Yes, I think so.
[14:11:22] <cmr> bstrie: well...
[14:11:32] <Kauhsa> sanxiyn, alright. thank you!
[14:11:32] *** Quits: isaacd (me@moz-6902374D.dhcp.oxfr.ma.charter.com) (Ping timeout)
[14:12:19] <nmatsakis> bstrie: I would say that affine is the right term for ~T
[14:12:38] <cmr> bstrie: the std metadata is only 4MB
[14:12:41] <cmr> "only"
[14:13:01] <cmr> that's 2/3
[14:13:03] <bstrie> cmr: compressed or uncompressed?
[14:13:07] <cmr> compressed
[14:13:11] *** Joins: tedh (tedh@moz-A5D1CAB7.public.wayport.net)
[14:13:22] * mletterle please be uncompressed, please be uncompressed... shit.
[14:13:26] <bstrie> nmatsakis: I guess I'm just not sure at what point an affine type is considered to be "used"
[14:13:43] <bstrie> as in the statement "an affine type may be used zero or one times"
[14:14:00] <cmr> I have no idea what actually goes in metadata, or how much of it there is. AST, and maybe something else?
[14:14:03] * cmr shrugs
[14:14:25] <sanxiyn> bstrie: For some value of "used", I guess
[14:14:31] <sanxiyn> (Also called "consumed")
[14:15:14] <pnkfelix> bstrie: yeah I think if you `sed -e `s/use/consume/` you might have an easier time?
[14:15:17] *** Joins: isaacd (me@moz-6902374D.dhcp.oxfr.ma.charter.com)
[14:15:41] <pnkfelix> bstrie: (and allow for the borrow operator as a way to take a reference without consumption)
[14:15:50] <bstrie> pnkfelix: but at what point is it "consumed", even? we never completely consume a variable, we just pass it on down the line until someone stops passing it
[14:16:21] <bstrie> and you can "consume" it more than once. `let a = ~5; let b = a; let c = b;` there, I just consumed that value twice
[14:17:02] <sanxiyn> bstrie: When you buy something, you are consuming the money, even if coins do not evaporate
[14:17:18] <sanxiyn> You can consume same money multiple times
[14:17:28] *** Joins: madjar (uid18432@moz-A42E5B7B.irccloud.com)
[14:17:28] <nmatsakis> bstrie: it depends on where you draw the line:
[14:17:37] <nmatsakis> bstrie: you might say that we are linear, and the only consumer is the drop glue that the compiler inserts
[14:17:43] <nmatsakis> bstrie: in that sense, every value is (at some point) dropped
[14:17:44] <pnkfelix> sanxiyn: well, maybe the word "consume" is not quite right.
[14:17:57] <bstrie> I guess I internally just think of "consumption" as intrinsically altering what is consumed
[14:17:59] <pnkfelix> sanxiyn: I would say that wooden logs are consumed when they burn...
[14:18:02] <nmatsakis> bstrie: alternatively, you might say that there are functions -- like send() -- that can be considered *using* the value,
[14:18:07] <bstrie> nmatsakis: that's an interesting way of thinking about it (the linear thing)
[14:18:09] <nmatsakis> bstrie: for a suitable layer of abstraction,
[14:18:21] <nmatsakis> bstrie: in which case we are *affine*, because every value is eventually sent or dropped
[14:18:51] <nmatsakis> bstrie: (note that all linear systems include *some* mechanism for sharing an affine/linear value temporary a la borrowed ptrs, so that's fine)
[14:19:15] <nmatsakis> bstrie: anyway, I think you can make a plausible case for either, but I guess that linear with drop being the only consumer is the best fit
[14:19:33] <bstrie> I like that way of thinking about it
[14:19:42] <bstrie> also "linear" is a less intimidating word than "affine" :)
[14:19:55] <sanxiyn> Both are kind of substructural system :)
[14:20:10] <sanxiyn> Not sure which metaphor is the best
[14:21:03] *** Joins: heftig_ (heftig@moz-64703EED.dip0.t-ipconnect.de)
[14:21:03] *** Quits: heftig (heftig@77B1EA81.41660100.172227A7.IP) (Quit: Quitting)
[14:21:32] *** Quits: lfox (lfox@moz-343B6F0C.nyc.biz.rr.com) (Ping timeout)
[14:22:07] *** Joins: jensnockert (jensnocker@moz-96B9881.wireless.lu.se)
[14:22:28] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[14:22:59] <benh> Can we rename util::ignore to util::drop? :/
[14:23:02] <sanxiyn> pnkfelix: I guess I am not a native English speaker to understand "... I think of consumption as intrinsically altering what is consumed"
[14:23:15] <sanxiyn> Really, to me, most English words are just technical terms
[14:23:41] <sanxiyn> So its "usual" meaning mostly does not confuse me
[14:24:05] <sanxiyn> Really hard to get those kinds of nuances
[14:24:08] <cmr> benh: or destroy or something, yeah.
[14:24:09] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[14:24:35] <pnkfelix> benh: I think pcwalton proposed doing so.  not sure whether we agreed or not
[14:24:39] *** Joins: canhtak (canhtak@moz-A53E1151.wl.t.ulaval.ca)
[14:24:41] <benh> I think `ignore` is too close to the unsafe `forget` in cast or somewhere which does the opposite :) 
[14:25:39] <cmr> bstrie: hm, I don't actually know if this metadata is uncompressed or not.
[14:25:54] <sanxiyn> bstrie: Also, "linear" is as intimidating as "affine" :)
[14:26:21] <bstrie> sanxiyn: but people at least will recognize linear as being a word that they have *heard of* before :)
[14:26:38] <sanxiyn> cmr: Indeed. Did we revert #8745?
[14:26:48] <sanxiyn> Indeed we did.
[14:27:11] <bstrie> but "unique type" is probably the best intuitive explanation
[14:27:17] <Ms2ger> bstrie, well, affine is a word I've heard before...
[14:27:21] <Ms2ger> bstrie, then again, I'm a math major
[14:27:32] <sanxiyn> bstrie: I found "heard of before" mostly useless to understand technical terms
[14:27:46] <sanxiyn> In math, you should check definition. There is no other meaning to mathematical terms.
[14:28:29] <sanxiyn> (As written in Alice, it means exactly what I said it means!)
[14:29:02] <sanxiyn> I am ranting, but I mostly found English-focused discussion in open source community offputting.
[14:29:35] *** Joins: ricepuddin (graham@moz-7D68765A.cable.virginm.net)
[14:29:45] <bstrie> sanxiyn: speaking from experience, when you start dropping into unfamiliar-words-as-jargon my eyes glaze over and I just stop listening. at least with "linear" we have a chance of explaining what it means before their brain slips into a coma :P
[14:29:58] *** Joins: bynaryshef (bynaryshef@moz-65BC52B3.mem.bellsouth.net)
[14:30:22] <Blei> the first time i heard of linear types, i thought of arrays
[14:30:48] <Blei> as "they are kind of a line of values" was what my brain told me
[14:30:49] *** Quits: alonlevy (alon@moz-F53E4C49.redhat.com) (Ping timeout)
[14:30:56] <sanxiyn> bstrie: I guess that is the difference. All words are unfamiliar words to me, so I find this kind of discussion annoying at worst.
[14:31:05] <bstrie> sanxiyn: I'll stop discussing it then :)
[14:31:11] <sanxiyn> bstrie: Because "chance of explaining" etc only applies to English speakers
[14:31:13] <Blei> not sure if that's better than affine which is not associated with anything in the context of programming languages (at least for me)
[14:31:15] <sanxiyn> At least I feel that way
[14:31:23] <vmx> is current master broken or is it my system?
[14:31:27] <cmr> vmx: broken
[14:31:33] <vmx> cheers
[14:31:36] <bstrie> why is master broken :(
[14:31:41] <cmr> bstrie: acrichto broke it!
[14:31:42] <Ms2ger> cmr, it's always broken somehow, surely :)
[14:31:49] * cmr points fingers
[14:31:59] <cmr> `make install` is borked, it's forgetting about librustrt
[14:32:16] <vmx> for me "make check" has linking issues
[14:32:18] <cmr> either that or acrichto forgot to remove rustc's linking to librustrt
[14:32:51] <Blei> vmx: me as well, libm is missing sometimes
[14:33:03] <vmx> Blei: yes, looks like it
[14:33:18] *** Quits: jensnockert (jensnocker@moz-96B9881.wireless.lu.se) (Input/output error)
[14:33:38] <cmr> make check also fails for me, but with librustrt problems, not libm problems.
[14:34:01] *** Joins: jensnockert (jensnocker@moz-96B9881.wireless.lu.se)
[14:34:07] <sanxiyn> I am all for discussing "best way to explain things", but when it goes into metaphors which doesn't exactly work in other languages, I feel like, "that shouldn't be discussed here, doesn't that belong in English-localization discussion list or something?"
[14:34:11] <Yurume> https://travis-ci.org/lifthrasiir/rust-encoding/builds/14667277 what happened with -lrustrt in the recent rust-nightly?
[14:34:21] <sanxiyn> Like, Korean-localization discussion is usually done in separate list
[14:34:35] <cmr> Yurume: makefile is broken
[14:34:43] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[14:34:56] <sanxiyn> By the way, Debian does have debian-l10n-en. I like that.
[14:35:03] <sanxiyn> English nitpicking goes there.
[14:35:18] <Blei> sanxiyn: you can't completely separate programming language syntax from the meaning of the underlying words
[14:35:20] <cmr> sanxiyn: I think it's more important than just localisation.
[14:35:24] *** Joins: jensnock_ (jensnocker@moz-96B9881.wireless.lu.se)
[14:35:26] *** Quits: jensnockert (jensnocker@moz-96B9881.wireless.lu.se) (Connection reset by peer)
[14:35:32] <cmr> We don't even have a coherent vocabulary for rust's concepts yet.
[14:35:35] <Blei> i.e. if, for, while etc. were chosen for their meaning in english
[14:35:40] <bstrie> Blei: we're not even talking about the underlying words, just how they're described in the manual
[14:35:46] <sanxiyn> Blei: What I am saying is "while" is a symbol, not an English-word-while.
[14:35:56] <bstrie> the word "linear" does not appear anywhere in the syntax, and never will
[14:36:22] <cmr> but I agree that it is annoying
[14:36:28] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[14:36:45] <Blei> hmm, ok, i see the difference
[14:36:45] <sanxiyn> Blei: Better example is "or". Natural language often uses "or" to mean exclusive or, but that is not the case in most PLs.
[14:36:48] *** Quits: jensnock_ (jensnocker@moz-96B9881.wireless.lu.se) (Input/output error)
[14:37:05] <bstrie> sanxiyn: this whole discussion was only for my own edification, I was not attempting to impose vocabulary on you :)
[14:37:05] <sanxiyn> I think not all, but some of such discussion belong in English localization list
[14:37:14] <sanxiyn> Which should not be the general list.
[14:37:20] *** Joins: jensnockert (jensnocker@moz-96B9881.wireless.lu.se)
[14:38:24] *** Quits: jfbk (jfbk@moz-EEA9CFB3.nyc.res.rr.com) (Quit: )
[14:38:59] <sanxiyn> bstrie: Yeah sorry about that. I am just venting my, like, 10 years old steam.
[14:39:01] *** Quits: jensnockert (jensnocker@moz-96B9881.wireless.lu.se) (Ping timeout)
[14:39:26] <sanxiyn> I participated in open source world, using English, for last 10 years, and I got some angers.
[14:39:59] <benh> bstrie: maybe we could make #[linear] the NonCopyable attribute :D
[14:40:34] * Ms2ger whacks benh with a wet fish
[14:41:14] <bstrie> sanxiyn: the problem is that you speak english so well that I always forget that you're a non-native speaker :P
[14:41:54] <Ms2ger> There's non-native speakers hiding among us! :)
[14:41:58] <bstrie> same for a few other people on this channel...
[14:42:04] * bstrie looks at kimundi
[14:42:33] <sanxiyn> bstrie: Yeeah, I can get the meaning across, but "consumption intrinsically altering what is consumed" is beyond me
[14:42:43] <sanxiyn> Even if now I remember that, I guess I will never feel the same way
[14:43:26] *** Joins: summerlight_ (summerligh@327FC32B.2C956A45.501EFF44.IP)
[14:43:28] <bstrie> sanxiyn: I'm not trying to say that the meaning of the word has lots of nuance, just that I think of "consumption" in the sense of eating food. economists might feel differently
[14:44:19] <bstrie> or like the sun turning into a red giant star and "consuming" the earth
[14:44:31] <bstrie> in both those cases, the food and the earth are destroyed :)
[14:44:38] *** Quits: summerlight_ (summerligh@327FC32B.2C956A45.501EFF44.IP) (Quit: 전 이만 갑니다.)
[14:44:53] *** Joins: bjustin (bjustin@moz-8FC28563.sierrabravo.net)
[14:45:01] <sanxiyn> I guess most people, when using the native language, associate the word with its most common usage. But for foreign speakers, their most common usage of some word can be different from its most common usage in its native setting.
[14:45:08] <sanxiyn> The vivid example I remember is this:
[14:45:11] <sanxiyn> I know what "bloat" is.
[14:45:18] <sanxiyn> I found it is pretty rare word.
[14:45:22] <sanxiyn> Also "shard".
[14:45:24] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[14:45:38] <sanxiyn> That is, I once took a vocabulary test ordered by frequency in its native corpus.
[14:46:00] <sanxiyn> I got all words above some frequency, and beyond that I got all words wrong, except "bloat" and "shard".
[14:47:16] <bstrie> sanxiyn: well it was not my intention to be culturally imperialistic, and I apologize
[14:47:18] <sanxiyn> bstrie: When I consume food, I don't use English :) So I guess that's why I associate that word with meaning in economics.
[14:47:33] <sp3d> sanxiyn: haha, brilliant
[14:47:43] <sanxiyn> sp3d: Eh... what is brilliant?
[14:48:03] <sp3d> the frequency cutoff thing, it just struck me as really amusing
[14:48:12] <sanxiyn> sp3d: Yeah it is
[14:48:15] <sp3d> reminds me of my vocabulary in some languages :x
[14:48:16] <benh> a 'shard' is what they call MMO servers going all the way back to the Ultima Online plot, right? :D
[14:48:45] <sanxiyn> benh: Yeah, but more usual meaning is broken pieces of glass
[14:48:57] <sp3d> I had the impression it came from database sharding which was from the glass metaphor
[14:49:03] <sanxiyn> Of course, I learned what shard is from reading about MMO servers :)
[14:49:10] <sanxiyn> sp3d: Yup
[14:49:14] *** Joins: lfox (lfox@moz-343B6F0C.nyc.biz.rr.com)
[14:49:16] <bstrie> sp3d: I feel like ultima online *has* to predate database sharding...
[14:49:42] *** Joins: alonlevy (alon@moz-87959726.redhat.com)
[14:49:56] <bstrie> back then, rather than sharding I feel like you'd just have a mainframe
[14:50:01] <benh> presumably, but the plot in UO is that someone shattered a gemstone with power over the whole world, and each... you know... shard of the gem then contained one of the servers you could play on
[14:50:17] <benh> maybe a database programmer came up with the plot and thought he was being really funny
[14:50:23] <sanxiyn> benh: Heh
[14:50:26] <sanxiyn> Didn't know that
[14:50:27] *** Joins: sbalmos (quassel@CA5677B6.576D0C1.ED2EFC1B.IP)
[14:52:32] <bstrie> http://www.quora.com/Ultima-Online/Is-Ultima-Online-the-origin-of-the-word-shard-in-distributed-systems
[14:52:43] <bstrie> so I think it is indeed that "sharding" was derived from ultima
[14:52:45] *** Joins: jensnockert (jensnocker@moz-96B9881.wireless.lu.se)
[14:53:21] <Yurume> cmr, I thought you meant my (rust-encoding's) makefile is broken, and after some frantic searching, I realized it's rustc's makefile which is broken. d'oh!
[14:53:36] <cmr> Yurume: yeah, sorry :)
[14:53:41] <Yurume> haha
[14:53:51] <bstrie> Yurume: we still blame you!!
[14:54:03] <Yurume> so the Travis breakage would be temporary, hopefully
[14:55:47] *** Quits: jensnockert (jensnocker@moz-96B9881.wireless.lu.se) (Input/output error)
[14:56:18] *** Quits: lpy (lpy@7360AA58.F09091A8.1348A864.IP) (Ping timeout)
[14:57:15] <sanxiyn> By the way, here is vocabulary test! In case you want to take it...
[14:57:16] <sanxiyn> http://testyourvocab.com/
[14:57:34] <sanxiyn> (It's fairly good, and based on sound research)
[14:58:02] <Blei> huh
[14:58:11] <Blei> pub fn debug_enabled() -> bool { cfg!(not(ndebug)) && log_enabled(4) }
[14:58:20] <Blei> error: unexpected token: `&&`
[14:58:33] <sanxiyn> !
[14:59:13] *** Quits: zaphod_b (ford_p@moz-CCE57F2F.eblcom.ch) (Client exited)
[15:00:31] <vmx> should i leave a comment if i have the same "make check" issue, or is that considered bad style https://github.com/mozilla/rust/issues/10762
[15:01:06] <bstrie> "oneiromancy" I know that one!!
[15:01:16] <bstrie> thanks, role-playing games
[15:03:08] <mark_edward> dangit
[15:03:17] <benh> mhm there's a lot of words in the 2/3 list that i wouldn't hesitate to use myself but couldn't give a definition for
[15:03:32] <mark_edward> no struct with anny members [T, ..N] can derive anything it seems
[15:03:36] *** Quits: Savago (Savago@D8B9C081.E820043D.D4C04133.IP) (Quit: Savago)
[15:03:40] <benh> language is hard :(
[15:04:15] <mark_edward> i'm not implementing encodable myself, the struct has like 25 members
[15:04:16] *** Joins: dew (Instantbir@moz-E4452B8F.static.stls.mo.charter.com)
[15:04:18] *** Joins: jstevans (Instantbir@E6085082.10591AD7.DDE5D3F6.IP)
[15:04:44] <Blei> hmm, but it work like this: if cfg!(not(ndebug)) { log_enabled(4) } else { false }
[15:04:55] <Blei> parser bug?
[15:06:05] <mark_edward> i'd really like a __FUNCTION__ macro
[15:06:06] *** Quits: Sharp (Sharp@moz-780FECDA.washdc.fios.verizon.net) (Quit: Sharp)
[15:06:16] <mark_edward> necessary for proper printf debugging
[15:07:10] *** Joins: cubic (cubic@moz-80241A3A.mc.videotron.ca)
[15:08:33] <sanxiyn> mark_edward: We already have "line!", so I think that would be a good addition
[15:10:15] *** Quits: isaacd (me@moz-6902374D.dhcp.oxfr.ma.charter.com) (Ping timeout)
[15:11:09] *** Joins: deggert (deggert@moz-2C16B246.host.de.colt.net)
[15:11:55] <deggert> Where would I find a guide / example on how to link C/C++ code and Rust code?
[15:12:35] *** Joins: avsej (avsej@DF1824D5.EFF97412.48F984E6.IP)
[15:12:52] *** Joins: isaacd (me@moz-6902374D.dhcp.oxfr.ma.charter.com)
[15:13:36] *** Joins: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net)
[15:16:30] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[15:16:32] *** Joins: maxiepoo (Max@moz-6F50ADE.hsd1.il.comcast.net)
[15:16:42] *** Quits: celeron55 (perttu@moz-D552F2C7.netplaza.fi) (Ping timeout)
[15:17:31] *** Joins: nejucomo (Adium@moz-DD573110.hsd1.co.comcast.net)
[15:18:43] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[15:19:38] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[15:20:22] *** Quits: itdnhr (it@moz-7FAAAB8D.bstnma.fios.verizon.net) (Ping timeout)
[15:21:42] *** Joins: celeron55 (perttu@moz-D552F2C7.netplaza.fi)
[15:23:33] <Blei> deggert: http://static.rust-lang.org/doc/master/tutorial-ffi.html
[15:26:02] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[15:26:21] <deggert> Thanks!
[15:30:47] <mark_edward> i need help debugging. is there any way to find out what function changes a variable to a specific value programmaticallyt?
[15:35:31] <Yurume> how about using gdb for watch commands after compiling with -Z debug-info option?
[15:35:37] *** Joins: jensnockert (jensnocker@moz-96B9881.wireless.lu.se)
[15:35:57] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[15:36:02] *** Quits: alonlevy (alon@moz-87959726.redhat.com) (Ping timeout)
[15:36:13] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[15:36:32] *** Quits: jensnockert (jensnocker@moz-96B9881.wireless.lu.se) (Input/output error)
[15:37:18] *** Joins: nano (nano@moz-74CAD1CA.superkabel.de)
[15:38:23] <mark_edward> Yurume, but the watchpoints keep getting deleted due to losing scope or something
[15:40:20] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[15:40:33] *** Quits: nejucomo (Adium@moz-DD573110.hsd1.co.comcast.net) (Quit: Leaving.)
[15:40:35] <eddyb> oh, I missed this: https://github.com/mozilla/rust/issues/10124#issuecomment-29605843 - does anyone have a good counterargument?
[15:41:22] <eddyb> there has to be something with consistency, parsing, prior work - but I don't want to be vague
[15:42:41] *** Joins: jvshahid (jvshahid@BE83DFD.50866E69.CA2DF2C0.IP)
[15:43:07] <SiegeLord> .. is getting somewhat overloaded I suppose...
[15:44:38] *** Joins: Skif (emschwar@moz-CA025D57.ip.mcleodusa.net)
[15:47:42] *** Joins: lpy (lpy@12172131.F09091A8.1348A864.IP)
[15:48:01] *** Joins: awidegreen (Mibbit@moz-3FE0A1F.a357.priv.bahnhof.se)
[15:48:14] *** Quits: arodier74 (Thunderbir@5901C3C8.B6144566.D3B9122.IP) (Ping timeout)
[15:48:14] *** Quits: lfox (lfox@moz-343B6F0C.nyc.biz.rr.com) (Ping timeout)
[15:48:23] *** Quits: bynaryshef (bynaryshef@moz-65BC52B3.mem.bellsouth.net) (Quit: This computer has gone to sleep)
[15:52:41] *** Joins: arodier74 (Thunderbir@5901C3C8.B6144566.D3B9122.IP)
[15:53:01] <eddyb> SiegeLord: I'm hoping that .. in list (tuple, tuple-like struct or enum variant) patterns will be just an alias for .._, where ..x captures multiple elements in a tuple x. actually, I don't think you care :P
[15:53:32] *** Quits: isaacd (me@moz-6902374D.dhcp.oxfr.ma.charter.com) (Ping timeout)
[15:53:59] <SiegeLord> Is that not what it does today?
[15:55:08] <eddyb> SiegeLord: * has just been replaced with .. - but there's no ..x version (the capturing part)
[15:55:31] <SiegeLord> Ah
[15:55:32] *** Joins: isaacd (me@moz-6902374D.dhcp.oxfr.ma.charter.com)
[15:55:35] *** Joins: tikue (quassel@moz-FEADCD38.hsd1.pa.comcast.net)
[15:55:45] <SiegeLord> Either way, that's not quite what ..T does in your proposal, is it?
[15:56:00] <SiegeLord> It's most similar to ..foo in the functional record update
[15:56:09] <SiegeLord> Which is the consistency I thought you were going for
[15:56:42] *** Quits: tikue (quassel@moz-FEADCD38.hsd1.pa.comcast.net) (Connection reset by peer)
[15:56:56] <eddyb> SiegeLord: pattern matching is symmetric from value creation :P
[15:57:13] *** Quits: isaacd (me@moz-6902374D.dhcp.oxfr.ma.charter.com) (Ping timeout)
[15:57:16] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[15:57:25] <awidegreen> I recently started with rust. I'm currently playing with Rust's ffi feature, interfacing pulseaudio - but I got stuck in how to cast and dereference raw: *mut c_void and a assigning another value to it .... see http://pastebin.com/yivmTd5A 
[15:57:41] <SiegeLord> I see, that's a fair argument I guess
[15:57:49] <SiegeLord> Just say that then
[15:58:22] *** Joins: jvns (bork@87D98E32.4046EB22.428F94DD.IP)
[15:58:34] *** Joins: tikue (quassel@moz-FEADCD38.hsd1.pa.comcast.net)
[15:58:49] <awidegreen> anyone an idea how to do that?
[15:58:54] *** Joins: beifeng (Mibbit@B5497CF4.FA7FF645.C7DB8B78.IP)
[15:59:01] *** Quits: maxiepoo (Max@moz-6F50ADE.hsd1.il.comcast.net) (Quit: maxiepoo)
[15:59:25] *** Joins: jensnockert (jensnocker@moz-96B9881.wireless.lu.se)
[15:59:36] <Blei> wouldn't you have to do `as *mut ffi::pa_context_state` ?
[15:59:52] *** Quits: matthewhammer (Mibbit@moz-167627F4.wireless.umd.edu) (Quit: http://www.mibbit.com ajax IRC Client)
[15:59:56] *** Joins: isaacd (me@moz-6902374D.dhcp.oxfr.ma.charter.com)
[15:59:58] <Blei> anyways, transmute will cast from whatever to whatever you want :)
[16:00:16] <awidegreen> right ... 
[16:00:36] <awidegreen> but how to do the assignment?
[16:00:51] *** Joins: itdnhr (it@F8C11080.200CF5B8.9D2C3D3E.IP)
[16:01:08] <Blei> so you could do `let state = transmute::<*mut c_void, *mut ffi::pa_context_state>(raw);`
[16:01:15] <awidegreen> damn never mind, that worked :) 
[16:01:56] <awidegreen> ok thanks.
[16:02:29] <eddyb> SiegeLord: the only places using ..foo are vector pattern-matching (I think) and the record update, that's for precedent within the language. thanks, but I was hoping for something more solid :/
[16:02:47] <eddyb> I guess I'll think about it while I implement more of it :P
[16:04:25] <sbalmos> Hrm, looks like the trunk's tutorial still refers to @ without defining a managed box, since we're moving to Rc
[16:07:38] *** heftig_ is now known as heftig
[16:07:43] *** Quits: isaacd (me@moz-6902374D.dhcp.oxfr.ma.charter.com) (Ping timeout)
[16:07:43] *** Quits: morphevs (Adium@moz-A57EB56D.uzh.ch) (Ping timeout)
[16:08:32] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Ping timeout)
[16:08:39] *** Joins: isaacd (me@moz-6902374D.dhcp.oxfr.ma.charter.com)
[16:08:50] <sp3d> eddyb: [T, ..N] and [V, ..N] aren't patterns, right?
[16:09:04] *** pmoore is now known as pmoore|tea
[16:09:19] *** Joins: nejucomo (Adium@moz-2D7C0F4C.hlrn.qwest.net)
[16:09:28] <eddyb> sp3d: but ..N means a different thing there (a number, not a tuple or a vector)
[16:09:31] *** Quits: nejucomo (Adium@moz-2D7C0F4C.hlrn.qwest.net) (Quit: Leaving.)
[16:09:32] <sp3d> or did you mean '$ident' by foo rather
[16:09:42] <sp3d> yeah, ok
[16:09:54] *** Quits: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net) (Ping timeout)
[16:09:54] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Ping timeout)
[16:09:55] *** Quits: sanxiyn (tinuviel@B4104EBB.3CC170B1.1E14B209.IP) (Quit: Leaving)
[16:10:00] <sp3d> I guess it's more a value than an ident anyhow...
[16:11:33] *** Joins: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com)
[16:11:56] *** Joins: twb (textual@moz-C0B32516.lawn.gatech.edu)
[16:12:02] *** Quits: mcarberry (mcarberry@moz-BE1C9F3F.lightspeed.frokca.sbcglobal.net) (Ping timeout)
[16:12:34] *** Joins: zaphod_b (ford_p@moz-CCE57F2F.eblcom.ch)
[16:13:15] *** Joins: mcarberry (mcarberry@moz-BE1C9F3F.lightspeed.frokca.sbcglobal.net)
[16:13:24] <jvns> hey rusti isn't around. is it possible to make it come back?
[16:14:20] *** Joins: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net)
[16:14:54] *** Joins: mye (mye@moz-FD24DF07.dip0.t-ipconnect.de)
[16:16:22] <Blei> oh wow, variance on type parameters and lifetimes? so many heads will explode
[16:16:37] *** pmoore|tea is now known as pmoore
[16:17:22] <Blei> i kind of understand scala's +T and -T but I'm not sure how much more complicated the same thing with lifetimes will be
[16:17:28] *** Quits: isaacd (me@moz-6902374D.dhcp.oxfr.ma.charter.com) (Ping timeout)
[16:17:47] <bstrie> jvns: rusti is only around while strcat's laptop is open :P
[16:17:59] <jvns> haha
[16:18:19] <jvns> that's sad -- it's the only REPL I know about :)
[16:18:22] * jvns hunts for the rusti source
[16:18:39] <SiegeLord> It's not really a repl...
[16:18:59] * jvns knows
[16:19:15] <jvns> but it's still super useful
[16:19:22] <sp3d> there's various iterations of rlwrap-on-rustc floating around: http://sprunge.us/ahcH
[16:20:59] <jvns> what's rustci? I can't find it anywhere
[16:21:15] <jvns> (that script complains "Cannot execute rustci: No such file or directory")
[16:21:19] <bstrie> SiegeLord: I think it's a repl... it reads your input, evals it, prints the output, the waits for your next input :P
[16:21:26] <sp3d> it's supposed to be named rustci
[16:21:30] <sp3d> it runs itself
[16:22:18] *** Joins: isaacd (me@moz-6902374D.dhcp.oxfr.ma.charter.com)
[16:22:19] <jvns> oh 
[16:22:21] <Blei> how about `exec rlwrap "$0"`
[16:23:09] <sp3d> should work
[16:23:12] <jvns> works!
[16:23:51] *** Joins: jeaye (Jeaye@moz-34FEF2BB.hsd1.ca.comcast.net)
[16:24:39] <Blei> cool script
[16:24:53] <jvns> yeah this is amazing
[16:24:59] *** Quits: Liothen (liothen@96625EAC.566451EE.31191230.IP) (Ping timeout)
[16:25:39] *** Joins: josh (josh@moz-F7F087E3.mpls.qwest.net)
[16:25:44] *** Quits: isaacd (me@moz-6902374D.dhcp.oxfr.ma.charter.com) (Ping timeout)
[16:26:38] *** Joins: isaacd (me@moz-6902374D.dhcp.oxfr.ma.charter.com)
[16:27:29] *** Quits: avsej (avsej@DF1824D5.EFF97412.48F984E6.IP) (Client exited)
[16:28:49] *** Joins: Skif_ (emschwar@moz-CA025D57.ip.mcleodusa.net)
[16:28:57] <jvns> man the rust compiler is confusing
[16:29:17] <jvns> if I create a function f, it tells me the type of '~f' is '~fn()'
[16:29:19] <Blei> bors is idle!
[16:29:32] *** Quits: Skif (emschwar@moz-CA025D57.ip.mcleodusa.net) (Ping timeout)
[16:29:33] <Blei> heh, quite unbelieveable when thinking back to this summer
[16:29:33] <jvns> but if I put `~fn()` in a function signature it says that's not a type
[16:29:40] *** Quits: josh (josh@moz-F7F087E3.mpls.qwest.net) (Quit: josh)
[16:29:44] *** Joins: josh (josh@moz-F7F087E3.mpls.qwest.net)
[16:30:04] <Blei> hmm, try ~(fn())
[16:30:57] <jvns> that gives me "<anon>:4:27: 4:28 error: expected `{` but found `;`"
[16:31:06] <jvns> "fn g(a: ~(fn()));"
[16:31:16] *** Joins: morphevs (Adium@moz-A57EB56D.uzh.ch)
[16:31:22] <jvns> oh wait
[16:31:25] <jvns> sec
[16:31:44] <jvns> yeah that works!
[16:31:46] *** Quits: isaacd (me@moz-6902374D.dhcp.oxfr.ma.charter.com) (Ping timeout)
[16:31:58] *** Joins: dherman (dherman@moz-B31C6965.dsl.pltn13.sbcglobal.net)
[16:31:58] *** ChanServ sets mode: +ao dherman dherman
[16:32:16] <jvns> so ~fn() is a type, except in a function signature you have to write it ~(fn()) because of something about closures
[16:32:54] <bstrie> jvns: what version are you using
[16:33:09] <jvns> bstrie, the nightly from a few days ago, I think
[16:33:31] <bstrie> jvns: function types have changed a lot very recently...
[16:33:40] <jvns> in the last few days?
[16:33:54] *** pmoore is now known as pmoore|away
[16:34:01] <bstrie> in the last few weeks, at least
[16:34:18] <bstrie> but ~fn() should not be a type, aiui
[16:34:50] <Blei> it's not anymore :)
[16:35:26] *** Joins: six600110 (six600110@moz-C663577C.hsd1.il.comcast.net)
[16:35:51] <jvns> with my version I can get an error "mismatched types: expected `()` but found `~fn()`" from  "fn f() {}; let x: () = ~f;"
[16:36:07] *** Joins: isaacd (me@moz-6902374D.dhcp.oxfr.ma.charter.com)
[16:36:32] *** Joins: alonlevy (alon@BA688CD1.57E8CAEB.4966A68C.IP)
[16:36:34] <jvns> but it's from a couple of days ago, so maybe ~fn() isn't a type anymore
[16:36:46] *** Joins: lfox (lfox@moz-861E573F.nyc.biz.rr.com)
[16:37:43] *** Joins: maxiepoo (mnew@moz-6F50ADE.hsd1.il.comcast.net)
[16:37:58] *** Joins: thewonderidiot (mstewart@moz-E41129BA.ipnetworksinc.net)
[16:38:15] *** Quits: jensnockert (jensnocker@moz-96B9881.wireless.lu.se) (Connection reset by peer)
[16:38:26] <jvns> blei: I can still get the error "expected `()` but found `~fn()`" with the most recent nightly
[16:38:37] *** Joins: jensnockert (jensnocker@moz-96B9881.wireless.lu.se)
[16:38:41] *** Quits: alonlevy (alon@BA688CD1.57E8CAEB.4966A68C.IP) (No route to host)
[16:38:48] <bstrie> jvns: can you file a bug report?
[16:38:55] <jvns> sure! =D
[16:39:05] <bstrie> hooray!
[16:39:44] <jvns> is "~fn() should not be a type" an appropriate error?
[16:39:49] <jvns> er title
[16:40:01] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[16:40:31] <bstrie> jvns: I think something like "error message prints a type that does not exist" or something
[16:40:40] <jvns> thanks!
[16:40:48] <bstrie> jvns: granted, I don't *know* that this is a bug, but not many people have enough experience with the new system to be able to tell for sure
[16:41:00] <jvns> we will see!
[16:41:46] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[16:43:06] <jvns> wooo filed https://github.com/mozilla/rust/issues/10767
[16:44:23] *** Quits: banananana (ba@E7E2A35D.6F99A8B0.2AADDDA7.IP) (Quit: Verlassend)
[16:45:08] *** Joins: lmandel (lmandel@13F2CEC5.7672369.D8E68FF6.IP)
[16:45:28] <celeron55> is there a way to get the current file or module or crate name as a string?
[16:45:31] <jvns> so if I say "let x = 2", does x have a specific type by the time the program runs?
[16:46:02] <jvns> I can get an error "expected `()` but found `<VI0>` (expected () but found integral variable)", which seems like it has something-which-is-not-quite-a-type during type inference
[16:46:04] <sp3d> celeron55: file!()
[16:46:23] <benh> jvns: yeah. if it can't decide on one it'll go with int or maybe complain, i forgot
[16:46:37] <benh> jvns: <VIn> are not-yet-inferred literal types afaik
[16:46:48] *** Joins: alan (alan@moz-FE02DD30.sat6.rackspace.com)
[16:47:10] <jvns> is there any way to get it to tell me a more specific type?
[16:47:24] <benh> it doesn't know it yet and it's aborting compilation before getting there, I assume
[16:47:32] <benh> you could make your x a more specific kind of 2
[16:47:49] <benh> like let x: int = 2; or let x = 2i;
[16:48:11] <jvns> yup
[16:48:45] *** jorendorff_away is now known as jorendorff
[16:49:45] <jvns> I'm trying to make a list of "things that are types"
[16:50:06] <benh> I'm not sure that ~fn() thing is a bug btw
[16:50:28] <benh> ok, it is. but maybe it doesn't have to be in the future. argh :)
[16:50:59] <benh> we used to have ~fn() as a closure type where the closure environment lived in the ~-heap
[16:50:59] <zaphod_b> hello, i have a question: let number = io::stdin().read_line() give me a string, how can i make convert the number to a int ? sorry about my english skill ;) 
[16:51:23] <benh> now we have proc() which is like a ~fn that can only be called once
[16:51:25] *** Quits: lfox (lfox@moz-861E573F.nyc.biz.rr.com) (Ping timeout)
[16:51:25] <jvns> yeah I saw it had something to do with closures
[16:51:36] <celeron55> sp3d: works, thanks
[16:51:52] <benh> since fn isn't part of the closure syntax anymore, regular old function( pointer)s are just of type fn(Args) -> Ret
[16:51:59] *** Joins: lfox (lfox@moz-343B6F0C.nyc.biz.rr.com)
[16:52:20] <Blei> zaphod_b: let a: int = from_str(my_number_str).unwrap();
[16:52:21] <benh> so in theory the error message is correct in that you have a funtion pointer stored in an ~-box when you wanted a ()
[16:52:36] <benh> but the parser won't let you write that type because it thinks you're still trying to use ye olde ~fn() closures
[16:52:38] <zaphod_b> Blei, cool a lot of thanks :) 
[16:52:42] <benh> ~(fn()) is a type though and parses
[16:52:52] <jvns> oh I see
[16:52:52] <benh> and let x: ~(fn()) = ~f; compiles too
[16:53:04] <jvns> so the error message should say ~(fn())
[16:53:15] <benh> Or the parser should be fixed to parse ~fn() as that
[16:53:21] <jvns> right
[16:53:31] <jvns> that would be more consistent 
[16:54:10] <jvns> so for any T, ~T is a type, except for functions where you have to add parens?
[16:54:28] <benh> this is surely going to change :/
[16:54:33] <benh> but yeah. mostly.
[16:54:33] <jvns> :)
[16:54:36] <jvns> mostly :(
[16:54:45] <jvns> why mostly?
[16:54:50] <benh> except that if you start with ~str, it's not really ~T with T=str
[16:55:01] <jvns> right
[16:55:02] <benh> (and ~[U] isn't ~T with T=[U])
[16:55:16] <jvns> but [U] and str aren't types
[16:55:18] <jvns> so it's okay
[16:55:26] <jvns> like ~~str would be a type?
[16:55:28] <benh> That was gonna be looked at in one way or the other (see recent posts on http://smallcultfollowing.com/babysteps/blog/categories/rust/)
[16:55:28] <pnkfelix> jvns: You probably should have said "so for any T where T is a type"
[16:55:36] <benh> yeah, ~~str would be a type
[16:55:54] <benh> jvns: Yeah, I just wanted to be more than technically precise :)
[16:55:55] <jvns> yeah I meant for any T where T is a type
[16:56:01] <jvns> for example ~panda isn't a type
[16:56:02] <jvns> :)
[16:56:30] *** Quits: vmx (vmx@moz-9193A9CB.dip0.t-ipconnect.de) (Quit: Leaving)
[16:56:35] <Blei> struct panda { bamboos: ~[BambooTree] }
[16:56:50] * jvns has made it through the brambles of "str isn't a type"
[16:57:13] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[16:57:14] <Blei> impl panda { fn fight_against_extinction(&self) { /* TODO */ } }
[16:57:36] *** Joins: abinader (abinader@D8B9C081.E820043D.D4C04133.IP)
[16:57:43] *** Quits: isaacd (me@moz-6902374D.dhcp.oxfr.ma.charter.com) (Ping timeout)
[16:59:06] <benh> but anyway those <VIn> bits aren't really a type or anything you can interact with outside of seeing them in errors before literals have been fully inferred
[16:59:28] *** Joins: vky (chatzilla@moz-4F2E17BF.dsl.dynamic.sonic.net)
[17:00:36] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[17:00:37] <jvns> that makes sense
[17:00:54] <jvns> I'm using these errors as a way to find types of things, so it's good to know that they won't answer me all the time
[17:01:23] <benh> it's probably the most supported way of getting the compiler to name types
[17:01:24] *** Joins: isaacd (me@moz-6902374D.dhcp.oxfr.ma.charter.com)
[17:01:37] <benh> there might be some reflection bits hiding under std::unstable:: or something, I'm not sure
[17:01:38] *** Quits: itdnhr (it@F8C11080.200CF5B8.9D2C3D3E.IP) (Ping timeout)
[17:02:04] *** Quits: eddyb (eddy@moz-68E0B7D0.residential.rdsnet.ro) (Ping timeout)
[17:03:48] *** Joins: eddyb (eddy@moz-68E0B7D0.residential.rdsnet.ro)
[17:04:02] *** Quits: skade (skade@30BBD5E6.505237C9.CAE22B62.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[17:04:26] <bstrie> idea
[17:04:32] <bstrie> let's implement crypto in rust
[17:04:33] <bstrie> BUT
[17:04:37] <bstrie> mark every function as unsafe
[17:04:48] <bstrie> so that you have to drop into unsafe mode to use it
[17:04:54] <bstrie> good plan??
[17:04:58] <benh> that sounds like a terrible plan!
[17:05:03] <bstrie> hooray! let's do it
[17:05:24] *** Joins: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com)
[17:05:45] <benh> the upside of doing crypto in rust would hopefully be that you can't ruin your crypto with undefined behavior, you *clearly* really want a new unsafe-like block/function attribute like... "insecure"
[17:06:04] *** Quits: canhtak (canhtak@moz-A53E1151.wl.t.ulaval.ca) (Quit: canhtak)
[17:06:33] <myname> what should insecure do
[17:06:46] <bstrie> lull you into a false sense of security, obviously
[17:07:02] <bstrie> "only this code down here is insecure, so everything else is bulletproof!"
[17:07:15] <bstrie> unlike safety, we can enforce security at the language level :P
[17:07:41] *** Joins: docbrown (docbrown@5CE9D448.F0B9EFB2.7F8758CE.IP)
[17:07:57] *** Quits: lpy (lpy@12172131.F09091A8.1348A864.IP) (Client exited)
[17:08:01] *** Quits: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com) (Quit: csherratt)
[17:08:13] <bstrie> er, can't
[17:08:14] <benh> myname: it has to make you think "hm, i have to write `insecure` here, i better hope i'm an expert at implementing cryptosystems"
[17:08:18] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[17:08:22] <bstrie> terrible sentence-inverting typo
[17:08:34] *** Quits: awidegreen (Mibbit@moz-3FE0A1F.a357.priv.bahnhof.se) (Quit: http://www.mibbit.com ajax IRC Client)
[17:08:44] *** Joins: moostik (Icedove@5A22E6A1.10715965.BCDF592F.IP)
[17:09:24] <bstrie> benh: rather, it has to make you think "hm, I better hope I'm willing to put up with being pwned on account of using code written by someone who's not an expert at implementing cryptosystems"
[17:09:31] <myname> i'm secure
[17:09:43] * bstrie hacks myname
[17:10:05] *** Quits: jvns (bork@87D98E32.4046EB22.428F94DD.IP) (Ping timeout)
[17:10:11] <myname> but i am using double rot-13?!?
[17:10:42] *** Joins: hoverbear (hoverbear@EBFA78B5.F19E5E7B.E74D50F2.IP)
[17:11:12] <bstrie> here's the PHP code that I use to encrypt passwords in the DB:
[17:11:20] <bstrie> strtolower($str) ^ strtoupper($str) ^ $str
[17:11:33] <bstrie> 100% bulletproof
[17:11:42] <hoverbear> bstrie: That otta do.
[17:11:55] *** Quits: BossKonaSegway (Michael@moz-2986F42D.col.wideopenwest.com) (Ping timeout)
[17:11:57] <bstrie> look at all those bitwise operations
[17:12:02] <bstrie> surely the result is inscrutable
[17:12:03] <myname> lmao
[17:13:14] <Ms2ger> ... wat
[17:13:42] *** Quits: lfox (lfox@moz-343B6F0C.nyc.biz.rr.com) (Quit: ZZZzzz…)
[17:14:17] <hoverbear> bstrie: That's as bad as using this as a checksum on a toy TCP reimplementation: https://gist.github.com/Hoverbear/db64dfb9322a5a9aef68
[17:14:25] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[17:15:00] *** Joins: glennsl (textual@moz-5D7B804F.getinternet.no)
[17:15:02] <hoverbear> "checksum"
[17:15:22] *** Quits: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net) (Ping timeout)
[17:15:51] *** Joins: g3orge (g3orge@moz-369F78A7.access.hol.gr)
[17:15:55] *** Quits: g3orge (g3orge@moz-369F78A7.access.hol.gr) (Quit: g3orge)
[17:16:11] *** Joins: BossKonaSegway (Michael@moz-2986F42D.col.wideopenwest.com)
[17:20:18] *** Quits: six600110 (six600110@moz-C663577C.hsd1.il.comcast.net) (Ping timeout)
[17:20:51] *** Quits: morphevs (Adium@moz-A57EB56D.uzh.ch) (Quit: Leaving.)
[17:21:11] <docbrown> What's the "rust way" to implement properties? Say, for example, I have a field which can be changed within my module, but API consumers can only read it. Is there a language feature for that, or do I just make the field private and have a public get_*() method?
[17:21:27] <Ms2ger> The latter
[17:21:30] <cmr> docbrown: no language feature, do it manually
[17:22:04] <docbrown> Alright, that's what I figured. Thanks!
[17:22:55] *** Joins: mikezaby (mikezaby@moz-57E43765.home.otenet.gr)
[17:23:11] *** Parts: mikezaby (mikezaby@moz-57E43765.home.otenet.gr) ()
[17:23:41] <myname> tbh i wish it were a language feature
[17:24:02] <myname> writing getters and setters is one of the more annoying things in java
[17:24:29] <cmr> well it can be an attribute, doesn't need to be a language feature.
[17:24:51] *** Joins: repsio (repsio@moz-2D2E33A2.eaw.com.pl)
[17:24:54] <cmr> Some have suggested we call it #[deriving(bstrie)]
[17:24:57] <myname> something like that'd be great
[17:24:57] <bstrie> getters and setters are bad and you should feel bad
[17:25:05] <bstrie> dammit cmr beat me to it
[17:25:12] <myname> i totally agree
[17:25:15] *** Quits: jensnockert (jensnocker@moz-96B9881.wireless.lu.se) (Ping timeout)
[17:25:28] <bstrie> getters and setters are a code smell
[17:25:33] <bstrie> just make the damn field public!
[17:25:34] *** Quits: repsio (repsio@moz-2D2E33A2.eaw.com.pl) (Quit: )
[17:25:47] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Ping timeout)
[17:25:51] <cmr> But invariants!
[17:25:55] <myname> i agree to some point
[17:26:01] <myname> i like the ruby way
[17:26:08] *** Joins: notmatt (notmatt@75AC61E6.68FFFFA3.47C41102.IP)
[17:26:10] *** Joins: itdnhr (it@66796279.4683C875.9D2C3D3E.IP)
[17:26:23] <myname> where you just can hava obj.attr = foo as public attribute
[17:26:38] <myname> or obj.attr = foo as a method call
[17:26:46] *** Joins: krdln (Mibbit@moz-6F8A8560.dynamic.chello.pl)
[17:27:15] <myname> that way you CAN actually make stuff public and can change your decission later if you want to
[17:27:38] <Seldaek> yeah optionally overriding public property access with getters/setters is the best way to avoid having to normalize on all-getters/setters if you want a consistent API
[17:27:59] <bstrie> f that, break the API when things change!
[17:28:09] <cmr> I really like transparent properties, but they're not very rustic.
[17:28:13] <cmr> They are a hidden cost.
[17:28:19] *** Quits: Ferreus (ferreus@moz-686897F4.dip0.t-ipconnect.de) (Ping timeout)
[17:28:21] <krdln> Hi, with new static linking is it possible to take ordinary .rs file and produce totally standalone executable?
[17:28:33] <bstrie> krdln: I hope so! that would be cool
[17:28:36] <cmr> krdln: it still depends on system libraries.
[17:28:47] <cmr> libstdc++, libgcc_s on linux/mingw
[17:28:55] <krdln> cmr: That's acceptable
[17:28:58] <cmr> then yes
[17:28:58] <bstrie> cmr: but are we exactly as standalone as go executables are
[17:29:04] <cmr> bstrie: are we?
[17:29:08] <myname> there is new static linking?
[17:29:08] <bstrie> I don't know!
[17:29:13] <cmr> myname: yes.
[17:29:15] <bstrie> allegedly!
[17:29:19] <cmr> myname: read TWiR :P
[17:29:22] <krdln> cmr: But how? I was unable to find proper documentation.
[17:29:23] <acrichto> bstrie: krdln: sadly that is not possible right now, once you use libstd you'll always pull in -lrt -ldl -lm etc
[17:29:25] <myname> great!
[17:29:31] <Seldaek> cmr: what do you mean hidden cost of transparent properties?
[17:29:38] <pnkfelix> acrichto: do you have a mac?
[17:29:44] <acrichto> pnkfelix: I do indeed
[17:29:50] <cmr> Seldaek: it's calling a method, not offsetting a pointer.
[17:29:53] <pnkfelix> acrichto: What version of OS X and Xcode do you use ?
[17:30:10] <acrichto> pnkfelix: 10.9 and 5.0.2
[17:30:14] <Seldaek> cmr: oh so there are standard hidden setters/getters backing public properties?
[17:30:15] *** Quits: twb (textual@moz-C0B32516.lawn.gatech.edu) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[17:30:19] <pnkfelix> acrichto:  (I am seeing `make check` failures on run-make/c-static-dylib, due to clang -Werror'ing on an unused -L… argument)
[17:30:34] <bstrie> Seldaek: not in rust!
[17:30:35] <cmr> Seldaek: ..no?
[17:30:44] <acrichto> pnkfelix: argh I hate that about clang, that just needs -Qunused-arguments or something like that on the command line
[17:30:46] <bstrie> Seldaek: in ruby there are
[17:30:48] <Seldaek> cmr: ok, then you lost me somewhere :)
[17:30:50] <acrichto> pnkfelix: that has come up so many times with me...
[17:30:53] <krdln> acrichto: So usage of rt destroys this possibility?
[17:31:00] <cmr> Seldaek: What I'm saying is "foo.bar", with properties, can be calling a method. Otherwise, it's just adding an offset to a pointer.
[17:31:13] <cmr> That method call is a hidden cost.
[17:31:17] <Seldaek> yes sure
[17:31:19] <cmr> You can't tell by looking at the source what is going on
[17:31:21] *** Quits: abinader (abinader@D8B9C081.E820043D.D4C04133.IP) (Ping timeout)
[17:31:23] <benh> just inline it }:D
[17:31:33] <acrichto> krdln: right now it's usage of libstd makes it not possible, but it's a tricky question because LLVM will emit calls to functions it expects to be defined in libraries like libm and libc
[17:31:44] <cmr> bstrie: no, go is fully static, no dynamic deps at all.
[17:31:53] <Seldaek> cmr: but having to write foo.getBar() and foo.setBar() and define those for the entire rest of times is also not ideal
[17:31:53] <acrichto> krdln: in theory you shouldn't depend on -lrt if you don't use any features from it, but we don't have that kind of pruning working just yet
[17:31:59] <bstrie> benh: what if calling the method initiates a network request?! what if you secretly call it 200 million times in a hot loop???
[17:32:04] *** Quits: itdnhr (it@66796279.4683C875.9D2C3D3E.IP) (Ping timeout)
[17:32:16] <benh> bstrie: inline the remote host :(
[17:32:17] *** Quits: GeneralMaximus (ankur@704E18E2.13A5FC81.D5D59AD9.IP) (Ping timeout)
[17:32:20] <bstrie> hahaha
[17:32:41] <Seldaek> that'd make for slow compilation process "inlining the internet.."
[17:32:53] *** Joins: willingc (willingc@moz-B4760708.san.res.rr.com)
[17:32:58] <bstrie> acrichto: are we planning on having "fully standalone" rust executables one day?
[17:33:14] <Seldaek> bstrie: I think there are plans to one day have every amazing thing
[17:33:16] *** Joins: twb (textual@moz-C0B32516.lawn.gatech.edu)
[17:33:21] <Seldaek> if you can think of it, there are plans
[17:33:26] <bstrie> Seldaek: not properties!
[17:33:29] <Seldaek> :(
[17:33:45] <docbrown> In my case, making the field public probably isn't a big deal. I'm just so used to writing things in C# and Java where I can ensure users don't change things that they shouldn't. But I guess it's their own fault if they do that.
[17:34:05] *** Quits: vodik (simon@moz-FD4ADBC6.cable.teksavvy.com) (Quit: WeeChat 0.4.3-dev)
[17:34:05] <Seldaek> bstrie: at least in rust you can write a macro prop!(foo) that would define the getter and setter
[17:34:07] *** Quits: isaacd (me@moz-6902374D.dhcp.oxfr.ma.charter.com) (Ping timeout)
[17:34:10] <pnkfelix> acrichto: oh, should I just add that someone to the c-static-dylib/Makefile ?
[17:34:17] <acrichto> bstrie: that is not currently on the roadmap in my mind at least, it be a very tricky thing to have. In theory if you use only a subset of libstd you can create a "standalone executable" but that subset would be unreasonably small. Do we want to reimplement libpthread, libm, libc, librt, etc?
[17:34:31] <acrichto> pnkfelix: no I think this should be a configure thing
[17:34:42] <acrichto> pnkfelix: wait hm, something isn't be propagated correctly now that I think about it
[17:34:50] <cmr> acrichto: there's an issue open for reimplementing libm
[17:34:53] <bstrie> acrichto: I dunno, how does Go manage it? :)
[17:34:56] <pnkfelix> acrichto: (s/someone/somehow).   Yeah, okay, -Qunused-arguments should not be hard-coded there in the Makefile.
[17:34:58] <cmr> something about it slow/imprecise/system unknown.
[17:35:02] <cmr> bstrie: they rewrite everything.
[17:35:03] *** Joins: abinader (abinader@496D17B0.2513D022.AD91B79.IP)
[17:35:06] <bstrie> haha
[17:35:06] <acrichto> pnkfelix: see https://github.com/mozilla/rust/blob/master/configure#L889
[17:35:28] <acrichto> bstrie: the go guys did some amazing work and rewrote all of libc/libm/whatnot in go, so they can actually live with 0 dependencies
[17:35:31] *** Quits: Kingsley (kingsley@9B172CBE.BEA5C56D.DF4B730F.IP) (Quit: Leaving.)
[17:35:38] <bstrie> neat
[17:35:41] <bstrie> and hilarious
[17:35:47] <cmr> Why is it hilarious?
[17:35:50] <acrichto> it's really impressive, but I'm not sure if it's worth it for us
[17:35:51] * cmr thinks its perfectly sane
[17:35:52] <bstrie> because it is absurd
[17:36:00] <acrichto> it's super nice to be able to cross-compile to easily though
[17:36:02] *** Joins: GeneralMaximus (ankur@704E18E2.13A5FC81.D5D59AD9.IP)
[17:36:07] <bstrie> reimplement ALL THE THINGS
[17:36:23] <pnkfelix> acrichto: that's funny
[17:36:27] <cmr> it's not really that absurd, there's really not a lot of things that we don't already have.
[17:36:29] <acrichto> pnkfelix: it could just be that with '--enable-clang' on the rust configure line we add -Qunused-arguments to the clang inovcation
[17:36:32] <pnkfelix> acrichto:  that's only applied to "ccache clang", not "clang" ?
[17:36:39] <acrichto> pnkfelix: I'm not entirely sure why it doesn't error on my system and it errors on yours though
[17:36:41] *** Joins: Kruppe (user@moz-32580BA8.net.uwaterloo.ca)
[17:36:43] <bstrie> cmr: I expect libm_ng by christmas, then
[17:36:49] <pnkfelix> acrichto: do you use ccache ?
[17:36:50] <cmr> bstrie: actually that's on my todo list :p
[17:36:54] <bstrie> haha
[17:36:56] <acrichto> pnkfelix: haha good point
[17:36:58] <acrichto> I do
[17:37:01] *** Joins: alonlevy (alon@moz-61A0AD83.red.bezeqint.net)
[17:37:02] <Seldaek> acrichto: on the other hand, I now see the heka guys use sandboxed Lua for things because it's faster than the go code hosting it.. rewriting it all in go isn't necessarily good :p
[17:37:07] <pnkfelix> acrichto: actually, I thought I used ccache too ...
[17:37:30] *** Joins: itdnhr (it@66796279.4683C875.9D2C3D3E.IP)
[17:38:21] <pnkfelix> acrichto: ah, I have ccache commented out from my configure driver script for rust
[17:38:23] *** Joins: isaacd (me@moz-6902374D.dhcp.oxfr.ma.charter.com)
[17:38:26] <pnkfelix> acrichto: so that explains that.
[17:38:43] <acrichto> pnkfelix: I think we should just always run with -Qunused-argument, it's really just annoying otherwise
[17:38:59] <pnkfelix> acrichto: so let me see about generalizing the configure thing you pointed me at
[17:39:28] <acrichto> pnkfelix: in the meantime, you can run 'make foo CC=gcc'
[17:40:12] *** Quits: isaacd (me@moz-6902374D.dhcp.oxfr.ma.charter.com) (Ping timeout)
[17:42:45] <krdln> Discussion went to full indepence, but I still don't know wheter it is possible to compile program that uses std and extra to an executable without any rustic dependencies?
[17:43:26] <cmr> krdln: yes, it is possible.
[17:43:37] <cmr> I did it a few hours ago
[17:43:51] <krdln> but how? I don't see where are docs for linkage
[17:44:09] <krdln> and #[link] attribut
[17:44:15] <cmr> std and extra are automatically statically linked.
[17:44:17] *** Joins: isaacd (me@moz-6902374D.dhcp.oxfr.ma.charter.com)
[17:44:19] <cmr> sec
[17:44:35] <cmr> https://github.com/mozilla/rust/pull/10742 has the docs.
[17:44:36] <krdln> cmr: oh, didn't know it
[17:44:51] <SimonSapin> rusti: 129.to_str_radix(16)
[17:46:21] *** Joins: lfox (lfox@moz-861E573F.nyc.biz.rr.com)
[17:46:26] <Seldaek> anyone has a clue who matthieum (on reddit) is and how I can get in touch?
[17:46:38] <cmr> nope
[17:46:46] <Seldaek> oh you can message on reddit
[17:46:54] <Seldaek> never saw that link in their cluttered ui :p
[17:47:17] *** Joins: icebattle (icebattle@8A14A542.EBE2EE2B.C7CEC4ED.IP)
[17:47:28] <mletterle> if you're going to use reddit for any length of time, it behooves you to get RES
[17:47:56] <Seldaek> I make do with hoverzoom so far 
[17:48:04] * aph adds behooves to the list of words to use more often
[17:48:04] <Seldaek> but I don't really use it much
[17:48:49] *** Quits: vky (chatzilla@moz-4F2E17BF.dsl.dynamic.sonic.net) (Ping timeout)
[17:48:53] <cmr> I don't use any extensions, I find it a pleasant experience.
[17:49:23] <mletterle> "pleasant".. that made me chuckle for some reason...
[17:50:40] *** Quits: deggert (deggert@moz-2C16B246.host.de.colt.net) (Quit: deggert)
[17:53:03] *** Quits: alonlevy (alon@moz-61A0AD83.red.bezeqint.net) (Ping timeout)
[17:53:21] *** Joins: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net)
[17:53:34] *** Quits: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net) (Client exited)
[17:53:34] *** Joins: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net)
[17:53:54] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[17:55:23] *** Quits: jstevans (Instantbir@E6085082.10591AD7.DDE5D3F6.IP) (Ping timeout)
[17:55:41] *** Joins: froystig (froystig@moz-5AA1643.stanford.edu)
[17:55:42] *** Quits: Skif_ (emschwar@moz-CA025D57.ip.mcleodusa.net) (Client exited)
[17:55:42] *** Quits: Ralith (ralith@moz-132F2FD4.sea.wa.customer.broadstripe.net) (Ping timeout)
[17:56:03] *** Joins: Skif (emschwar@moz-CA025D57.ip.mcleodusa.net)
[17:58:01] *** zz_kimundi is now known as kimundi
[17:59:19] *** Joins: echristo (echristo@24D1937F.D6CCE4AE.77834EAA.IP)
[17:59:21] *** Joins: jstevans (Instantbir@E6085082.10591AD7.DDE5D3F6.IP)
[18:00:09] *** Quits: isaacd (me@moz-6902374D.dhcp.oxfr.ma.charter.com) (Ping timeout)
[18:00:37] *** Joins: isaacd (me@moz-6902374D.dhcp.oxfr.ma.charter.com)
[18:01:49] *** Quits: beifeng (Mibbit@B5497CF4.FA7FF645.C7DB8B78.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[18:02:11] *** Joins: Savago (Savago@D8B9C081.E820043D.D4C04133.IP)
[18:02:13] *** Joins: beifeng (Mibbit@B5497CF4.FA7FF645.C7DB8B78.IP)
[18:03:56] *** Joins: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP)
[18:05:49] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[18:06:38] *** Quits: efnysien (efnysien@moz-50AD4325.res.cmu.edu) (Ping timeout)
[18:06:58] *** Joins: skade (skade@moz-A586637D.pools.arcor-ip.net)
[18:07:57] *** Quits: jvshahid (jvshahid@BE83DFD.50866E69.CA2DF2C0.IP) (Ping timeout)
[18:08:01] *** Joins: avsej (avsej@D9A610B8.4841F515.FB33447D.IP)
[18:08:31] *** Joins: jvshahid (jvshahid@BE83DFD.50866E69.CA2DF2C0.IP)
[18:10:12] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[18:10:51] *** Quits: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com) (Ping timeout)
[18:13:54] *** Joins: deggert (deggert@moz-2C16B246.host.de.colt.net)
[18:13:58] *** Quits: lfox (lfox@moz-861E573F.nyc.biz.rr.com) (Ping timeout)
[18:14:31] *** Quits: krdln (Mibbit@moz-6F8A8560.dynamic.chello.pl) (Quit: http://www.mibbit.com ajax IRC Client)
[18:17:29] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Input/output error)
[18:18:14] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[18:18:25] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[18:18:40] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[18:18:50] *** Joins: vodik (simon@moz-1D946D75.net.uwaterloo.ca)
[18:19:52] *** Joins: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP)
[18:25:42] *** Joins: jvns (bork@87D98E32.4046EB22.428F94DD.IP)
[18:25:46] *** Joins: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com)
[18:27:33] *** Quits: nkoep (nik@moz-5F3B1C42.pool.mediaways.net) (Ping timeout)
[18:28:51] *** Quits: yota (sdouche@moz-7D878FB8.securactive.net) (Ping timeout)
[18:30:52] *** Joins: exobit_ (textual@moz-E06F46F0.corp.bitshelter.com)
[18:31:15] *** Joins: Sharp (Sharp@moz-780FECDA.washdc.fios.verizon.net)
[18:35:16] *** Quits: itdnhr (it@66796279.4683C875.9D2C3D3E.IP) (Ping timeout)
[18:35:48] *** Joins: jensnockert (jensnocker@moz-C6DA4C3D.wireless.lu.se)
[18:36:06] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[18:36:55] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Quit: Gone to save the world!)
[18:39:06] *** Joins: maxiepoo_ (Max@moz-FFD7044A.nuwlan.northwestern.edu)
[18:39:12] *** Quits: twb (textual@moz-C0B32516.lawn.gatech.edu) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[18:39:17] *** Quits: moostik (Icedove@5A22E6A1.10715965.BCDF592F.IP) (Quit: moostik)
[18:39:41] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[18:41:22] *** Joins: itdnhr (it@66796279.4683C875.9D2C3D3E.IP)
[18:41:24] *** Joins: moostik (Icedove@5A22E6A1.10715965.BCDF592F.IP)
[18:42:00] *** Joins: nkoep (nik@moz-BACD3DC4.vpn.rwth-aachen.de)
[18:44:28] *** Quits: josh (josh@moz-F7F087E3.mpls.qwest.net) (Quit: josh)
[18:44:49] *** Joins: FreeFull (freefull@moz-672577F6.as13285.net)
[18:44:51] *** Quits: Savago (Savago@D8B9C081.E820043D.D4C04133.IP) (Quit: Savago)
[18:45:51] *** Quits: jstevans (Instantbir@E6085082.10591AD7.DDE5D3F6.IP) (Ping timeout)
[18:45:59] *** Joins: notmatt_ (notmatt@moz-9FB2565E.vc.shawcable.net)
[18:46:04] *** Joins: voxpopuli (fanservice@moz-FE161659.wv.cc.cmu.edu)
[18:46:28] *** Joins: Ferreus (ferreus@moz-CA3CA275.pools.arcor-ip.net)
[18:47:02] *** Quits: notmatt (notmatt@75AC61E6.68FFFFA3.47C41102.IP) (Ping timeout)
[18:48:19] *** Quits: moostik (Icedove@5A22E6A1.10715965.BCDF592F.IP) (Ping timeout)
[18:49:16] *** Joins: zslayton (Mibbit@81EB2473.5F4BC84E.66C78B76.IP)
[18:49:38] *** Quits: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP) (Client exited)
[18:51:27] *** Quits: maxiepoo_ (Max@moz-FFD7044A.nuwlan.northwestern.edu) (Quit: maxiepoo_)
[18:52:15] <jvns> If I have a string "Hello", how do I get the second character out of it?  (and not the second byte)
[18:52:41] <cmr> jvns: .char_at(1) iirc
[18:52:56] <cmr> hm no
[18:53:12] *** Quits: mye (mye@moz-FD24DF07.dip0.t-ipconnect.de) (Quit: mye)
[18:53:19] <cmr> s.chars().nth(2) :P
[18:54:06] <jvns> .char_at works for me
[18:54:10] *** Quits: beifeng (Mibbit@B5497CF4.FA7FF645.C7DB8B78.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[18:54:16] <cmr> but it's not the second character
[18:54:20] <cmr> it's the character starting at the second byte.
[18:54:26] <jvns> oh ack
[18:54:44] <jvns> okay that *definitely* should be in the tutorial
[18:54:55] * jvns is making a pull request for real this time
[18:55:25] <jvns> oh but that's not actually a char
[18:55:36] <jvns> it's an Option<char> 
[18:55:45] <jvns> or however you write that
[18:56:02] *** Quits: Sharp (Sharp@moz-780FECDA.washdc.fios.verizon.net) (Quit: Sharp)
[18:56:27] <cmr> yes
[18:56:36] <cmr> because there might *not* be a character at that bytes.
[18:56:37] <jvns> cmr: how do I find the documentation for str? http://static.rust-lang.org/doc/master/std/str/index.html doesn't have char_at or chars listed
[18:56:40] <cmr> *byte
[18:56:45] *** Quits: japaric (japaric@93AE996A.11BD0214.95AFB88D.IP) (Ping timeout)
[18:56:49] <cmr> jvns: use the search, or look at the traits.
[18:56:52] <cmr> StrSlice is the one.
[18:57:19] *** Joins: maxiepoo_ (Max@moz-FFD7044A.nuwlan.northwestern.edu)
[18:57:47] *** Joins: josh (josh@moz-36DB7B08.mpls.qwest.net)
[18:57:48] <cmr> jvns: it's https://github.com/mozilla/rust/issues/10114
[18:58:10] <jvns> :)
[18:58:19] *** Quits: Kruppe (user@moz-32580BA8.net.uwaterloo.ca) (Ping timeout)
[18:58:21] <jvns> so
[18:58:54] <jvns> if I did .char_at(100) to "hello", I'd get a runtime error
[18:59:07] <Ms2ger> Yes
[18:59:08] <jvns> but .chars().nth(2) returns an Option
[18:59:10] <jvns> why?
[18:59:25] <jvns> (why isn't the interface the same?)
[18:59:43] <cmr> oh right
[18:59:48] <cmr> char_at is dumb.
[18:59:53] <cmr> chars.nth(2) is an iterator thing.
[19:00:05] <cmr> eg, the iterator could be exhausted.
[19:00:12] <cmr> the iterator api doesn't have any failure.
[19:00:21] *** Joins: japaric (japaric@CCE774CC.E90D5F40.F29ED47E.IP)
[19:01:13] <jvns> I don't see when I would want to use char_at actually
[19:01:22] <jvns> it seems not safe
[19:01:50] *** Quits: vodik (simon@moz-1D946D75.net.uwaterloo.ca) (Quit: brb)
[19:02:16] <jvns> so getting a character from a string requires iterating through the whole string?
[19:02:23] <jvns> I guess that makes sense
[19:02:37] *** Quits: heftig (heftig@moz-64703EED.dip0.t-ipconnect.de) (Ping timeout)
[19:02:53] *** Quits: willingc (willingc@moz-B4760708.san.res.rr.com) (Client exited)
[19:06:37] *** Joins: jstevans (Instantbir@F9C38261.6CF13040.DDE5D3F6.IP)
[19:09:15] *** Joins: vodik (simon@57FAA519.F44F49AA.D02BABA9.IP)
[19:10:02] *** Quits: maxiepoo_ (Max@moz-FFD7044A.nuwlan.northwestern.edu) (Quit: maxiepoo_)
[19:10:47] *** Quits: hoverbear (hoverbear@EBFA78B5.F19E5E7B.E74D50F2.IP) (Quit: Textual IRC Client: www.textualapp.com)
[19:11:08] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[19:12:13] *** Joins: heftig (heftig@moz-DBCCD3CC.dip0.t-ipconnect.de)
[19:12:28] <kimundi> Now that we have iterators and stuff, maybe CharRange and char_at should just disappear, at least from the public API
[19:13:11] *** Joins: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP)
[19:13:21] *** Quits: paulproteus (quassel@199.199.210.158) (Ping timeout)
[19:13:35] <Eridius> kimundi: if I already know the byte position where I expect a character to start, using an iterator to get back there is extremely wasteful
[19:13:47] <kimundi> Eridius: Oh, that's true
[19:13:52] *** Joins: paulproteus (quassel@458FE134.3EC36C88.CBDCF1DC.IP)
[19:14:30] <kimundi> I was thinking of char_range_at I think
[19:15:53] *** Quits: isaacd (me@moz-6902374D.dhcp.oxfr.ma.charter.com) (Ping timeout)
[19:16:49] *** Joins: isaacd (me@moz-6902374D.dhcp.oxfr.ma.charter.com)
[19:17:22] <jvns> so if I make pull requests on the manual, are they likely to be accepted?
[19:17:36] <jvns> for example "closure types" is not in the type section of the manual
[19:18:19] <benh> My first few, successful pull requests were on the manual and docs :)
[19:18:51] <jvns> :)
[19:19:19] <jvns> I just wrote up an explanation of types for myself to read =D https://gist.github.com/jvns/7751946
[19:21:01] *** Joins: willingc (willingc@moz-B4760708.san.res.rr.com)
[19:24:23] *** Joins: lenstr (lenstr@78927A57.6C60037D.28B5BA55.IP)
[19:25:21] *** Quits: GeneralMaximus (ankur@704E18E2.13A5FC81.D5D59AD9.IP) (Ping timeout)
[19:26:13] *** Quits: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[19:26:42] *** Joins: alonlevy (alon@moz-EB7C9CF3.telavivmakers.org)
[19:27:05] *** Quits: amro (quassel@D9E34ACF.8AAAF769.FAAB0799.IP) (Client exited)
[19:27:36] *** Quits: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP) (Client exited)
[19:28:41] *** Joins: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP)
[19:30:55] *** Joins: lfox (lfox@moz-343B6F0C.nyc.biz.rr.com)
[19:31:05] *** Joins: jvshahid_ (jvshahid@BE83DFD.50866E69.CA2DF2C0.IP)
[19:31:45] *** Quits: jvshahid (jvshahid@BE83DFD.50866E69.CA2DF2C0.IP) (Ping timeout)
[19:32:06] <jvns> hmm I'm trying to make a closure return a value, but I'm getting an error "error: `return` in a closure"
[19:32:13] <jvns> the code: http://sprunge.us/gUXR 
[19:32:25] *** Quits: oberstet (quassel@moz-920A8A63.dynamic.mnet-online.de) (Connection reset by peer)
[19:32:35] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[19:33:31] <jvns> but if I don't put a 'return', then the type is just |int| instead of |int| -> int
[19:34:15] <kimundi> jvns: return doesn't work inside closures - you need to use the control flow for getting the right return values
[19:34:19] <sfackler> jvns: make the last line of the closure just "arg"
[19:34:26] <sfackler> (no semicolon)
[19:34:34] <jvns> oh man
[19:34:37] <jvns> no semicoon
[19:34:45] <jvns> okay yeah that works
[19:35:28] <jvns> what does "error: use of moved value: `closure_no_args`" mean?
[19:35:31] *** Joins: GeneralMaximus (ankur@B4DF73F6.7D84F5AD.260B031E.IP)
[19:35:38] <TeXitoi> kimundi: do you know why return doesn't work in closures?
[19:35:44] <jvns> ah ha 
[19:36:00] <jvns> figured it out
[19:37:56] <kimundi> TeXitoi: The original reason was when the `for` iteration syntax was working with closures - return was allowed in them, and would return from the outer function (provided the iteration function was implemented right) - now that we don't have that anymore, it could in theory be allowed to use return in a closure for returning a value , but it doesn't work right now because of legacy
[19:38:22] *** Joins: six600110 (six600110@moz-C663577C.hsd1.il.comcast.net)
[19:40:29] *** Quits: nsf (nsf@moz-EEF3238A.convex.ru) (Quit: WeeChat 0.4.2)
[19:41:16] *** Joins: mye (mye@moz-FD24DF07.dip0.t-ipconnect.de)
[19:41:59] *** Quits: andre_ (andre@CA528A4A.45A4338E.8EE27E6.IP) (Quit: leaving)
[19:42:46] <TeXitoi> kimundi: thanks
[19:43:01] <kmc> jvns: you moved the value out of the let-variable closure_no_args into the variable foo, so you can't use the former variable after that
[19:43:26] <jvns> kmc, yeah, thanks! I worked it out :)
[19:43:37] <kmc> cool :)
[19:46:25] *** Quits: glennsl (textual@moz-5D7B804F.getinternet.no) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[19:50:02] *** Quits: willingc (willingc@moz-B4760708.san.res.rr.com) (Client exited)
[19:53:08] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[19:53:15] *** Quits: nkoep (nik@moz-BACD3DC4.vpn.rwth-aachen.de) (Ping timeout)
[19:53:27] *** Quits: itdnhr (it@66796279.4683C875.9D2C3D3E.IP) (Ping timeout)
[19:53:46] *** Quits: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP) (Client exited)
[19:57:25] *** Joins: tikue_ (tkuehn@D4F78F0D.F3E8A984.689607DE.IP)
[19:58:01] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Quit: leaving)
[19:58:54] *** Joins: tcr (tcr@7C181A70.200CF5B8.9D2C3D3E.IP)
[19:59:23] *** Joins: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP)
[19:59:39] *** Quits: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP) (Client exited)
[19:59:40] *** Joins: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP)
[20:01:01] <Ms2ger> For y'all: http://qdb.us/267960
[20:02:31] *** Joins: Liothen (liothen@96625EAC.566451EE.31191230.IP)
[20:02:31] *** Quits: exobit_ (textual@moz-E06F46F0.corp.bitshelter.com) (Ping timeout)
[20:02:54] *** Joins: maxli (maxli@moz-4D28BA20.student.cs.uwaterloo.ca)
[20:03:16] *** Quits: victorporof_ (victorporo@FB8E2A00.483E5FE1.9B1E38F4.IP) (Quit: victorporof_)
[20:04:19] *** Joins: vodik_ (simon@moz-71CA52F2.net.uwaterloo.ca)
[20:04:46] *** Quits: vodik (simon@57FAA519.F44F49AA.D02BABA9.IP) (Ping timeout)
[20:05:07] *** Joins: blank_name (blank_name@FAB53C88.7071B2C8.31EC03F3.IP)
[20:05:19] *** Joins: maxiepoo_ (Max@moz-FFD7044A.nuwlan.northwestern.edu)
[20:05:41] *** Quits: Sorella (quildreen@D2D1E5DD.81EFC25A.A95FAE2B.IP) (Quit: Ex-Chat)
[20:06:31] *** Joins: willingc (willingc@moz-B4760708.san.res.rr.com)
[20:06:59] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[20:07:43] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Ping timeout)
[20:07:53] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[20:09:21] *** Joins: logicalparadox (logicalpar@moz-C73156AE.dr01.wlbr.pa.frontiernet.net)
[20:10:32] *** Joins: Ralith (ralith@A8995AA9.62B6AF6A.922221DB.IP)
[20:10:58] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[20:11:51] *** Joins: nkoep (nik@moz-5F3B1C42.pool.mediaways.net)
[20:13:26] *** Quits: eddyb (eddy@moz-68E0B7D0.residential.rdsnet.ro) (Ping timeout)
[20:13:29] *** Quits: jvshahid_ (jvshahid@BE83DFD.50866E69.CA2DF2C0.IP) (Quit: Lost terminal)
[20:17:27] *** Joins: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP)
[20:17:35] *** Quits: tcr (tcr@7C181A70.200CF5B8.9D2C3D3E.IP) (Client exited)
[20:18:06] *** Joins: tcr (tcr@7C181A70.200CF5B8.9D2C3D3E.IP)
[20:18:58] *** Parts: kangz (kangz@moz-61F34019.kimsufi.com) (.)
[20:19:20] *** Joins: jmgrosen (jmgrosen@moz-A3814C08.sd.sd.cox.net)
[20:19:54] *** Quits: tcr (tcr@7C181A70.200CF5B8.9D2C3D3E.IP) (Ping timeout)
[20:19:58] *** Joins: mikezaby (mikezaby@moz-57E43765.home.otenet.gr)
[20:20:05] *** Parts: mikezaby (mikezaby@moz-57E43765.home.otenet.gr) ()
[20:24:59] *** Quits: tikue_ (tkuehn@D4F78F0D.F3E8A984.689607DE.IP) (Quit: tikue_)
[20:25:40] *** Quits: skade (skade@moz-A586637D.pools.arcor-ip.net) (Quit: Textual IRC Client: www.textualapp.com)
[20:25:48] *** Quits: nkoep (nik@moz-5F3B1C42.pool.mediaways.net) (Ping timeout)
[20:25:54] *** Quits: vodik_ (simon@moz-71CA52F2.net.uwaterloo.ca) (Quit: WeeChat 0.4.3-dev)
[20:26:48] <cmr> jvns: I've only seen a few PRs rejected ever
[20:27:20] <cmr> jvns: You get heaps of love for doc work though <3
[20:28:38] <docbrown> Is it possible to bind to variadic C functions?
[20:29:03] *** Joins: jvshahid (jvshahid@BE83DFD.50866E69.CA2DF2C0.IP)
[20:29:24] <cmr> docbrown: yes.
[20:29:56] <cmr> extern { fn printf(fmt: *libc::char, ...); }
[20:30:14] *** Joins: tcr (tcr@moz-1A21C25B.olin.edu)
[20:31:01] *** Joins: canhtak (canhtak@moz-EF153D0F.wl.t.ulaval.ca)
[20:31:03] <docbrown> Oh good!
[20:31:35] *** pmoore|away is now known as pmoore
[20:32:33] <jensnockert> Hurray, dueboot is updated for modern Rust \o/
[20:32:37] *** Quits: mye (mye@moz-FD24DF07.dip0.t-ipconnect.de) (Quit: mye)
[20:33:32] *** Joins: itdnhr (it@F8C11080.200CF5B8.9D2C3D3E.IP)
[20:35:28] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Client exited)
[20:36:17] *** Joins: vky (chatzilla@moz-4F2E17BF.dsl.dynamic.sonic.net)
[20:36:53] *** Quits: lenstr (lenstr@78927A57.6C60037D.28B5BA55.IP) (Client exited)
[20:38:01] *** Joins: lenstr (lenstr@78927A57.6C60037D.28B5BA55.IP)
[20:39:35] <jensnockert> Now I just need to wait on team Tesla Coil.
[20:40:19] *** Joins: nkoep (nik@moz-8ACD51D8.vpn.rwth-aachen.de)
[20:41:36] *** Joins: tikue_ (tkuehn@4B0537EF.48F908A.689607DE.IP)
[20:43:40] *** Quits: fabiand (fabiand@moz-376ED57B.adsl.alicedsl.de) (Quit: Verlassend)
[20:45:24] *** Quits: jmgrosen (jmgrosen@moz-A3814C08.sd.sd.cox.net) (Quit: jmgrosen)
[20:46:31] *** Joins: jviereck (Adium@moz-FC52FD58.dip0.t-ipconnect.de)
[20:47:10] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[20:47:37] *** Quits: isaacd (me@moz-6902374D.dhcp.oxfr.ma.charter.com) (Ping timeout)
[20:47:58] *** Joins: jmgrosen (jmgrosen@moz-A3814C08.sd.sd.cox.net)
[20:48:52] <tiffany> is there any ABI difference between * and &?
[20:48:56] <cmr> tiffany: no
[20:49:18] <tiffany> could you do extern { fn printf(fmt: &libc::char, ...); }, then?
[20:49:23] <cmr> yes
[20:49:34] <tiffany> interesting
[20:49:36] *** Joins: isaacd (me@moz-6902374D.dhcp.oxfr.ma.charter.com)
[20:49:41] <cmr> You can even use lifetimes!
[20:50:04] *** Joins: aes (Mibbit@moz-3ECBFF82.access.telenet.be)
[20:50:05] <tiffany> it'd be cool if you could assign "transformers" to parameters to C functiosn
[20:50:13] <tiffany> like one to convert rust string to C strings
[20:50:33] *** Quits: aes (Mibbit@moz-3ECBFF82.access.telenet.be) (Quit: http://www.mibbit.com ajax IRC Client)
[20:50:55] *** Joins: moostik (Icedove@5A22E6A1.10715965.BCDF592F.IP)
[20:51:12] <tiffany> it'd be much safer than implicit conversions like luajit ffi, but still just as (if not more) useful
[20:52:17] *** Quits: isaacd (me@moz-6902374D.dhcp.oxfr.ma.charter.com) (Ping timeout)
[20:52:45] *** Joins: isaacd (me@moz-6902374D.dhcp.oxfr.ma.charter.com)
[20:52:59] *** Quits: joone (joone@2678A73.2160464A.A34EC3BB.IP) (Ping timeout)
[20:53:35] *** Joins: polyfractal (polyfracta@moz-4C5426D6.hsd1.sc.comcast.net)
[20:54:00] *** Joins: joone (joone@moz-8E88FB0F.jf.intel.com)
[20:55:00] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[20:55:41] <TeXitoi> tiffany: that's not so simple because of memory management of the c string. You can see std::c_str
[20:56:05] *** Quits: jensnockert (jensnocker@moz-C6DA4C3D.wireless.lu.se) (Input/output error)
[20:56:17] *** Quits: nkoep (nik@moz-8ACD51D8.vpn.rwth-aachen.de) (Ping timeout)
[20:56:28] <docbrown> How do I get the underlying file descriptor from a std::io::fs::File?
[20:56:30] <tiffany> well, transformers could have a function to do the transformation, and then clean up afterwards
[20:56:33] *** Joins: jensnockert (jensnocker@moz-C6DA4C3D.wireless.lu.se)
[20:57:02] <cmr> docbrown: that's not a good idea. use std::io::native::file
[20:57:38] <docbrown> Ok. I looked there, but the docs said it shouldn't be used directly.
[20:58:20] *** Quits: jensnockert (jensnocker@moz-C6DA4C3D.wireless.lu.se) (Ping timeout)
[20:58:32] <cmr> thing is, std::io::fs is all libuv stuff.
[20:58:56] *** Joins: Kingsley (kingsley@9B172CBE.BEA5C56D.DF4B730F.IP)
[20:59:59] <docbrown> cmr: Oh, I see. I'm trying to issue IOCTLs, so I guess std::io::native does make more sense.
[21:00:19] <cmr> (it's also generic over implementations, so the "File" might not actually be something with an fd)
[21:01:33] *** Quits: vky (chatzilla@moz-4F2E17BF.dsl.dynamic.sonic.net) (Ping timeout)
[21:01:47] *** Joins: victorporof (victorporo@FB8E2A00.483E5FE1.9B1E38F4.IP)
[21:02:59] *** Joins: devbug (quassel@2D4E172D.4C8B6099.9B57EA59.IP)
[21:03:06] *** Joins: jensnockert (jensnocker@moz-C6DA4C3D.wireless.lu.se)
[21:03:14] *** Quits: jviereck (Adium@moz-FC52FD58.dip0.t-ipconnect.de) (Quit: Leaving.)
[21:03:15] *** Joins: jviereck (Adium@moz-89E0389E.ethz.ch)
[21:04:04] *** Quits: victorporof (victorporo@FB8E2A00.483E5FE1.9B1E38F4.IP) (Quit: victorporof)
[21:05:00] *** Quits: jensnockert (jensnocker@moz-C6DA4C3D.wireless.lu.se) (Ping timeout)
[21:05:11] *** Quits: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP) (Client exited)
[21:07:13] *** Joins: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP)
[21:08:22] *** Quits: Kxepal (Miranda@moz-BFDF5C72.pppoe.mtu-net.ru) (Quit: Kxepal)
[21:08:47] *** Joins: Kxepal (Miranda@moz-BFDF5C72.pppoe.mtu-net.ru)
[21:09:51] *** Quits: josh (josh@moz-36DB7B08.mpls.qwest.net) (Quit: josh)
[21:10:33] *** Quits: Blei (philipp@moz-B2F9E4BD.cust.bluewin.ch) (Quit: WeeChat 0.4.2)
[21:10:57] *** Joins: mye (mye@moz-FD24DF07.dip0.t-ipconnect.de)
[21:12:13] <kmc> yeah, & for FFI is good because it prevents the common mistake of  some_c_function(x.with_c_str(|s| s))
[21:12:18] <kmc> (aiui; haven't tried it)
[21:12:21] <kmc> which has bit me multiple times
[21:12:28] <cmr> yeah
[21:13:41] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[21:13:54] *** Joins: jordyd (jordyd@7DAC4ACE.77F880E0.D9401097.IP)
[21:14:19] <tiffany> I think there's like 1 place in my entire game engine in which a parameter consumes its argument rather than modifying or just reading i
[21:14:56] *** Joins: nkoep (nik@moz-5F3B1C42.pool.mediaways.net)
[21:15:18] *** kimundi is now known as zz_kimundi
[21:16:30] *** Quits: maxiepoo_ (Max@moz-FFD7044A.nuwlan.northwestern.edu) (Quit: maxiepoo_)
[21:17:13] *** Joins: jensnockert (jensnocker@moz-C6DA4C3D.wireless.lu.se)
[21:17:28] *** Quits: nano (nano@moz-74CAD1CA.superkabel.de) (Connection reset by peer)
[21:17:50] *** Quits: noam (noam@F6B530A7.720527A7.416762B.IP) (Connection reset by peer)
[21:18:02] *** Joins: noam (noam@F6B530A7.720527A7.416762B.IP)
[21:19:16] *** Quits: jordyd (jordyd@7DAC4ACE.77F880E0.D9401097.IP) (Quit: Leaving)
[21:19:34] *** Quits: dbaupp (Thunderbir@moz-3BE4086E.lns20.syd6.internode.on.net) (Ping timeout)
[21:19:55] *** Quits: Ms2ger (Ms2ger@C91975CB.3387515C.187A1082.IP) (Quit: nn)
[21:21:03] <SiegeLord> What's with the tests failing randomly/
[21:21:05] <SiegeLord> ?
[21:21:09] *** Joins: noam_ (noam@F6B530A7.720527A7.416762B.IP)
[21:21:24] *** Joins: maxiepoo_ (Max@moz-FFD7044A.nuwlan.northwestern.edu)
[21:21:36] *** Quits: noam (noam@F6B530A7.720527A7.416762B.IP) (Ping timeout)
[21:22:01] *** Quits: alonlevy (alon@moz-EB7C9CF3.telavivmakers.org) (Ping timeout)
[21:24:41] *** Quits: tikue_ (tkuehn@4B0537EF.48F908A.689607DE.IP) (Quit: tikue_)
[21:25:43] *** Joins: nsf (nsf@moz-EEF3238A.convex.ru)
[21:29:44] <bstrie> SiegeLord: must be those random number generation tests
[21:30:20] <SiegeLord> They should boost the p value
[21:30:31] <SiegeLord> *alpha value
[21:30:42] <bstrie> yes. but, they should boost it randomly
[21:33:53] *** Parts: echristo (echristo@24D1937F.D6CCE4AE.77834EAA.IP) ()
[21:34:02] *** Joins: noam (noam@F6B530A7.720527A7.416762B.IP)
[21:34:03] *** Quits: noam_ (noam@F6B530A7.720527A7.416762B.IP) (Ping timeout)
[21:36:40] *** Quits: blank_name (blank_name@FAB53C88.7071B2C8.31EC03F3.IP) (Connection reset by peer)
[21:36:52] <bstrie> oh, weird. instead of having generational garbage collection, python has refcounting with generational cycle collection
[21:37:27] *** Joins: blank_name (blank_name@FAB53C88.7071B2C8.31EC03F3.IP)
[21:38:35] *** Quits: moostik (Icedove@5A22E6A1.10715965.BCDF592F.IP) (Ping timeout)
[21:40:53] *** Quits: lmandel (lmandel@13F2CEC5.7672369.D8E68FF6.IP) (Quit: lmandel)
[21:41:45] *** Joins: tikue_ (tkuehn@622204DD.28259105.689607DE.IP)
[21:41:52] *** Joins: shammancer (dannick@moz-CB791883.uws.ualberta.ca)
[21:42:40] <shammancer> I am wanting to fool around with internal unix sockets could you guys suggest any libraries
[21:43:21] <cmr> shammancer: std::io::net::unix
[21:44:36] <shammancer> is it in 0.8?
[21:45:00] <bstrie> shammancer: nothing is in 0.8. we retroactively erased all copies of 0.8 from every computer in the world
[21:45:08] *** Quits: japaric (japaric@CCE774CC.E90D5F40.F29ED47E.IP) (Ping timeout)
[21:45:14] <bstrie> go ahead, try to compile. "rustc not found", right?
[21:45:28] *** Quits: tiffany (kawaii@moz-FC0DB29D.dhcp.embarqhsd.net) (Ping timeout)
[21:45:43] *** Joins: tiffany (kawaii@moz-FC0DB29D.dhcp.embarqhsd.net)
[21:46:08] *** Joins: jdm (jdm@moz-AC9499B2.cable.teksavvy.com)
[21:46:08] *** ChanServ sets mode: +o jdm
[21:47:36] *** Quits: itdnhr (it@F8C11080.200CF5B8.9D2C3D3E.IP) (Ping timeout)
[21:47:40] *** Quits: jmgrosen (jmgrosen@moz-A3814C08.sd.sd.cox.net) (Quit: jmgrosen)
[21:48:23] *** Quits: lenstr (lenstr@78927A57.6C60037D.28B5BA55.IP) (Client exited)
[21:48:41] <jensnockert> I think the chances for a Rust-controlled tesla coil today just died. :(
[21:49:12] *** Joins: ofeldt (ofeldt@moz-7169CC85.dip0.t-ipconnect.de)
[21:49:37] <shammancer> Anyways thanks cmr
[21:49:59] *** Quits: ofeldt- (ofeldt@moz-BFEABB47.dip0.t-ipconnect.de) (Ping timeout)
[21:50:38] *** Joins: japaric (japaric@38C6A13.CBA91732.95AFB88D.IP)
[21:50:40] <jvns> is using 0.8 not recommended?
[21:50:44] <cmr> no
[21:50:45] <bstrie> jensnockert: ??
[21:51:00] <jensnockert> bstrie: We were trying to build a Rust-controlled tesla coil.
[21:51:06] <jensnockert> But we just blew the capacitors :(
[21:51:11] <cmr> releases are unsupported and far less stable than master
[21:51:17] <bstrie> jensnockert: was it rust's fault??
[21:51:22] <jensnockert> bstrie: Nope.
[21:51:26] *** Joins: jordyd (jordyd@7DAC4ACE.77F880E0.D9401097.IP)
[21:51:29] <jensnockert> bstrie: Some wiring, probably.
[21:51:39] <sbalmos> Rusty wiring is never good
[21:51:45] <jensnockert> Oh, true…
[21:51:46] *** Joins: mib_mgfsdx (Mibbit@27A93EB4.DF4637DA.62D74A69.IP)
[21:51:48] <kmc> code which controls hardware exceeding 10,000 volts must be enclosed in unsafe { ... }
[21:51:57] <sbalmos> kmc: Ooo nice
[21:51:58] <jensnockert> It was enclosed in unsafe :(
[21:52:32] <bstrie> jensnockert: that was your problem, try enclosing the coil in deux safes for maximum safety
[21:52:32] <jensnockert> All I/O in my Arduino library is unsafe (like a boss)
[21:52:58] <mib_mgfsdx> is there a way to do pointer arithmetic?
[21:53:04] <benh> std::ptr::offset
[21:53:06] <sbalmos> kmc: Usage of @TeslaGenerator is not recommended. User-level garbage collectors are limited to 24 volts and below.
[21:53:10] <bstrie> mib_mgfsdx: yes, but you must, dammit benh
[21:53:10] <jensnockert> bstrie: I'll keep that in mind.
[21:53:39] <benh> tho don't ask me if the parameter is in bytes or sizeof(T) units
[21:53:53] <bstrie> benh: listen, when people ask to do things, you can't just tell them the answer! you have to come up with long and convoluted responses that leave them no better off than when they started
[21:53:57] <jensnockert> What am I going to present at Rust Skåne tomorrow now /o\
[21:54:19] <cmr> How is Skåne pronounced, anyhow?
[21:54:28] *** Quits: dherman (dherman@moz-B31C6965.dsl.pltn13.sbcglobal.net) (Quit: dherman)
[21:54:32] <cmr> Wait
[21:54:35] <cmr> I looked this up before
[21:54:35] <bstrie> jensnockert: have you ever seen the movie "Ocean's Eleven"
[21:54:36] <sbalmos> Pointer arithmetic's bad, m'kay?
[21:54:37] <mib_mgfsdx> bstrie: right, I might accomplish something ;p
[21:54:46] <jensnockert> bstrie: Nope.
[21:54:51] <benh> bstrie: but to minmax my stackoverflow karma, i gotta shoot off a "hm, this might actually do it" answer first and then slowly expand it until it subsumes two wikipedia articles while raking in upvotes. it's a hard habit to break!
[21:55:02] *** Quits: tikue_ (tkuehn@622204DD.28259105.689607DE.IP) (Ping timeout)
[21:55:07] <jensnockert> http://upload.wikimedia.org/wikipedia/commons/6/6d/Sv-Sk%C3%A5ne.ogg
[21:55:16] <sbalmos> benh: Too late, it's been marked as unconstructive. :)
[21:55:21] <bstrie> jensnockert: ok, well first go watch the movie. it's pretty good. then find a nearby university and sneak off with their tesla coils
[21:55:35] <benh> welp, back to f5'ing the tag page
[21:55:45] <jensnockert> I'm at a University, trying to sneak off with one of their tesla coils.
[21:55:49] <jensnockert> But it isn't working /o\
[21:55:50] <bstrie> mib_mgfsdx: that's the last thing we want!!
[21:56:05] *** Quits: refold (gman@moz-42D68426.a258.priv.bahnhof.se) (Quit: leaving)
[21:56:48] <bstrie> jensnockert: ok, new plan. have you ever seen the movie "Ocean's Twelve"
[21:56:59] <mib_mgfsdx> unrelated question: is there a more substantial reference for macros than the page linked from the tutorial?
[21:57:24] <bstrie> mib_mgfsdx: pauls is the more substantial reference for macros
[21:57:28] <jensnockert> bstrie: No.
[21:57:35] <benh> that's not how you do induction proofs!
[21:58:10] <bstrie> jensnockert: ok. don't bother watching it because it's not as good as the first one. but when you're done not watching it, go find an art gallery with tesla coils on display, and then use a fake-pregnant julia robers lookalike to sneak out their tesla coils
[21:58:27] <jensnockert> Oh, ok.
[21:58:34] <pnkfelix> bstrie: and do some crazy french martial arts/gymnastics, too, right?
[21:58:35] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[21:58:40] <mib_mgfsdx> hmm
[21:58:45] <jensnockert> French martial arts?
[21:58:46] <bstrie> pnkfelix: only after that plan fails when bruce willis shows up
[21:58:55] <jensnockert> Brb, going home from the physics department.
[21:58:57] <bstrie> in an unexpected cameo
[21:59:18] *** Quits: jensnockert (jensnocker@moz-C6DA4C3D.wireless.lu.se) (Input/output error)
[21:59:33] *** Joins: Sorella (quildreen@9D963F5D.DF5D8AE7.54BCAB54.IP)
[21:59:47] *** Joins: jensnockert (jensnocker@moz-C6DA4C3D.wireless.lu.se)
[21:59:51] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[22:00:39] *** Quits: abinader (abinader@496D17B0.2513D022.AD91B79.IP) (Quit: abinader)
[22:00:57] <pauls> mib_mgfsdx: there's also a macro section in the main reference, which is more reference-y.
[22:00:58] *** Joins: penguin_dan (dan_johnsi@6902762D.11B071D.FB9A45AF.IP)
[22:01:35] *** Quits: jensnockert (jensnocker@moz-C6DA4C3D.wireless.lu.se) (Ping timeout)
[22:02:04] <mib_mgfsdx> pauls: oh wow. thanks. I don't know how I missed that the first time around.
[22:02:11] *** Joins: tikue_ (tkuehn@622204DD.28259105.689607DE.IP)
[22:02:53] *** Joins: itdnhr (it@F8C11080.200CF5B8.9D2C3D3E.IP)
[22:04:38] *** Quits: tcr (tcr@moz-1A21C25B.olin.edu) (Client exited)
[22:04:59] *** Joins: tcr (tcr@moz-1A21C25B.olin.edu)
[22:05:02] *** Quits: jviereck (Adium@moz-89E0389E.ethz.ch) (Ping timeout)
[22:06:05] <mark_edward> wait what do we need DST for?
[22:06:26] <mark_edward> what if we took a page from C++, allowed integrals in type params, and used that for size info
[22:06:40] *** Quits: tcr (tcr@moz-1A21C25B.olin.edu) (Ping timeout)
[22:07:14] <o11c> personally, I think that *every* constant value should be usable as a type
[22:07:36] *** Joins: jviereck (Adium@moz-FC52FD58.dip0.t-ipconnect.de)
[22:07:42] <shammancer> Are there any examples small examples of the net library
[22:07:52] *** Quits: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP) (Client exited)
[22:08:04] <cmr> shammancer: https://github.com/cmr/rust-examples/blob/master/, though it's a bit out of date.
[22:09:25] <mib_mgfsdx> o11c: and type-level functions
[22:09:44] <pnkfelix> mark_edward: that only gives you static expansion into each case.  That actually was one of the scenario's niko described,  though i think it was an accident that he arrived there
[22:10:23] <mark_edward> pnkfelix, what are the problems with it? what do we really need DST itself for? C++ doesn't seem to need it
[22:10:36] *** Joins: twb (textual@moz-C0B32516.lawn.gatech.edu)
[22:10:51] <strcat> rust isn't c++
[22:11:18] <sbalmos> strcat: When'd you slip in here today?
[22:11:41] *** Quits: avsej (avsej@D9A610B8.4841F515.FB33447D.IP) (Ping timeout)
[22:11:46] <strcat> C++ uses metaprogramming to make C arrays mean new[]/delete[] for std::unique_ptr (and soon, shared_ptr)
[22:11:48] <mark_edward> strcat, true, but what did we need DST for? removing vectors from the language seems to fix a lot of the problems
[22:11:53] *** Joins: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz)
[22:12:13] <shammancer> Does it still compile?
[22:12:18] <strcat> you don't *need* DST for slices
[22:12:45] <mark_edward> what do you need it for?
[22:12:47] <strcat> C++ doesn't *need* std::unique_ptr<T[]> and std::shared_ptr<T[]> specializations
[22:13:19] <strcat> not every feature exists to make something possible that wasn't possible before
[22:13:31] <strcat> rust doesn't need for loops either
[22:13:46] <mib_mgfsdx> rust isn't brainfuck
[22:13:49] <o11c> what is DST in this context?
[22:14:03] <strcat> so we have a type, &[T}
[22:14:05] <strcat> er
[22:14:07] <strcat> &[T]
[22:14:10] <strcat> which is a slice (ptr and a len)
[22:14:25] <strcat> [T] alone isn't currently a type, it can't be
[22:14:25] <bblum> actually how would dst and slices work
[22:14:42] <bblum> if [T] were a DST it would imply that a length is stored inside the buffer somewhere
[22:14:51] <bblum> so it seems hard to create a &[T] to the middle of a ~[T]
[22:14:57] <pnkfelix> mark_edward: you may want to look over niko's posts if you havent already, starting from: http://www.smallcultfollowing.com/babysteps/blog/2013/04/30/dynamically-sized-types/
[22:14:57] <strcat> bblum: ~[T] wouldn
[22:14:59] <mib_mgfsdx> o11c: dynamically sized type, I believe
[22:14:59] <o11c> "dynamic sized type" or something?
[22:15:02] <strcat> wouldn't mean what it does atm*
[22:15:14] <bblum> strcat: what would it mean
[22:15:25] *** Quits: shammancer (dannick@moz-CB791883.uws.ualberta.ca) (Ping timeout)
[22:15:27] <tikue_> fixed size allocated on the heap i believe
[22:15:31] <strcat> no
[22:15:36] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[22:15:37] <strcat> bblum: it would be represented as &[T] but would own the memory
[22:15:54] <tikue_> oh but not necessarily heap allocated?
[22:15:57] <strcat> and Rc<[T]> and Gc<[T]> could be the same kind of thing
[22:16:10] <bblum> strcat: wouldn't that break the symmetry of ~<something> being one word?
[22:16:14] <strcat> tikue_: nothing is necessarily heap allocated, those are implementation details
[22:16:27] <strcat> bblum: ~Trait isn't 1 word
[22:16:30] <strcat> &[T] isn't 1 word
[22:16:48] <tikue_> strcat: ~T stores T on the heap 
[22:16:51] <bblum> well  but i thought the point of dst was to restore symmetry so you could be like
[22:16:56] <strcat> tikue_: no, not necessarily
[22:17:02] <bblum> foo<unsized T>(x: ~T)
[22:17:17] <tikue_> strcat: doesn't the tutorial describe it in those terms?
[22:17:18] *** Quits: jstevans (Instantbir@F9C38261.6CF13040.DDE5D3F6.IP) (Ping timeout)
[22:17:23] <strcat> I don't think so
[22:17:31] <tikue_> "shared heap" or something
[22:17:31] <strcat> I think it describes ~T as providing the invariant of being pointer-size
[22:17:33] <tikue_> unless that changed
[22:17:35] <strcat> tikue_: no
[22:17:37] <strcat> that never made sense
[22:17:45] <tikue_> ah ok, fair enough
[22:18:25] <mib_mgfsdx> "An owned box (~) is a uniquely owned allocation on the heap..."
[22:18:27] *** Joins: shammancer (dannick@moz-CB791883.uws.ualberta.ca)
[22:18:46] <tikue_> maybe that should change then
[22:19:54] <strcat> bblum: but ~Trait won't ever be 1 word
[22:20:15] <strcat> you can make ~T work for ~Trait without that
[22:20:18] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[22:20:57] <strcat> how ~T is dealt with is an implementation detail, rust doesn't guarantee it will call malloc/free and return a pointer to the allocation and in fact it doesn't always do that
[22:21:26] <strcat> ~Foo where Foo contains a managed pointer isn't represented as a ptr to a Foo
[22:21:36] <mib_mgfsdx> .. managed or owned?
[22:21:43] <strcat> and ~T where T is no larger than a pointer doesn't need to allocate to uphold the same guarantees
[22:21:45] *** Joins: jstevans (Instantbir@F9C38261.6CF13040.DDE5D3F6.IP)
[22:21:56] <strcat> it currently does, but it doesn't have to
[22:25:16] *** Joins: alonlevy (alon@moz-DCBA91C6.bb.netvision.net.il)
[22:26:17] <jensnockert> bstrie: But at least I got a modern rust running on the Arduino again.
[22:26:55] <sbalmos> strcat: BTW, don't know if anyone's noticed, the master tutorial still has references to @ managed boxes in sections 11 & 12, but never defines a managed box (since things are being switched to Rc<T> & Gc<T>)
[22:26:57] <jensnockert> Even if it wasn't Hollywood-level special effects.
[22:27:03] <strcat> sbalmos: I know
[22:27:07] <sbalmos> ok
[22:27:33] <strcat> I have a PR open rewriting part of the tutorial and don't plan on doing any more until I know that will be accepted
[22:28:11] <sbalmos> Did the channel protocol proto! stuff die by the wayside?
[22:28:29] <sfackler> that's been gone for a while
[22:29:01] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[22:29:02] <mark_edward> pnkfelix, i have been, and i just don't see what's the point. Move vectors into the language, make slices another type, introduce literal syntax for convenience
[22:29:02] <mib_mgfsdx> oh, I was wondering about that after seeing it in the reference
[22:29:31] <sbalmos> same here. Remotely interesting, though clunky. I remember reading about its inspiration back in the Singularity days.
[22:30:12] <mark_edward> also ~Trait can be made uniformly sized, other languages do it
[22:30:16] <mark_edward> so what's the issue
[22:30:20] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[22:30:20] *** ChanServ sets mode: +ao dherman dherman
[22:30:22] <mark_edward> that necessitates DST
[22:31:15] <bstrie> mark_edward: bring it up with nmatsakis :)
[22:31:34] *** Joins: lmandel (lmandel@moz-76CE9D51.cable.teksavvy.com)
[22:31:48] <mark_edward> nmatsakis, ping
[22:32:33] *** Joins: ktt3ja (Mibbit@moz-D69B60E4.hsd1.va.comcast.net)
[22:32:54] *** Joins: g3xzh (g3xzh@moz-85224D43.red.bezeqint.net)
[22:33:26] <nmatsakis> mark_edward: pong
[22:33:46] *** Quits: polyfractal (polyfracta@moz-4C5426D6.hsd1.sc.comcast.net) (No route to host)
[22:34:41] *** Quits: tikue_ (tkuehn@622204DD.28259105.689607DE.IP) (Ping timeout)
[22:34:55] *** Joins: tikue_ (tkuehn@622204DD.28259105.689607DE.IP)
[22:34:59] <mark_edward> nmatsakis, i'm confused as to what purpose DST is to ultimately solve. ~Trait objects can be made uniformly sized through boxing. vectors can be moved out of the language and replaced with Vec<T> and Slice<T>. fixed size arrays can be kept for literatals
[22:35:05] <mark_edward> what problem does DST solve?
[22:35:14] <mark_edward> i've read your blog posts, btw
[22:35:33] <nmatsakis> the problems all arise if we try to integrate user-defined smart ptrs
[22:35:47] *** Joins: polyfractal (polyfracta@moz-4C5426D6.hsd1.sc.comcast.net)
[22:36:03] <nmatsakis> which is what I am trying to do
[22:36:17] <nmatsakis> it's clear that ~Trait can be made uniformly sized
[22:36:39] <nmatsakis> (and in fact it IS uniformly sized, under any interpretation)
[22:36:54] <nmatsakis> the more interesting question is:
[22:37:47] <nmatsakis> 1. can we support things like `RC<Trait>` in a similar fashion to how it works today? (packaging up a vtable with an existing ptr)
[22:37:56] *** Quits: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com) (Ping timeout)
[22:38:10] *** Joins: samnardoni (samnardoni@FC9A45BE.3393236F.BFD1ABFD.IP)
[22:38:12] <nmatsakis> 2. can we make things like "Trait" or "[T]", which today are not types on their own, behave more like types? This can make for useful impls
[22:38:36] *** Quits: Ferreus (ferreus@moz-CA3CA275.pools.arcor-ip.net) (Quit: WeeChat 0.4.2)
[22:38:40] *** Quits: Jackneill (Jackneill@moz-C693862A.pool.digikabel.hu) (Input/output error)
[22:38:54] *** Quits: jviereck (Adium@moz-FC52FD58.dip0.t-ipconnect.de) (Quit: Leaving.)
[22:38:56] <nmatsakis> it can also help to avoid extra levels of indirection like ~~Trait or &&[T] that often arise when applying traits to types like `~Trait` or `&[T]`
[22:39:36] *** pmoore is now known as pmoore|away
[22:39:39] <AutomatedTester> dherman: you want to be on the TAG?
[22:40:23] <nathan7> nmatsakis: What's DST in this context?
[22:40:26] <dherman> AutomatedTester: well, "want" is a strong word ;-P
[22:40:35] *** Joins: jviereck (Adium@moz-FC52FD58.dip0.t-ipconnect.de)
[22:40:38] <dherman> AutomatedTester: I think it's a good opportunity for me to get involved with cross-cutting design questions
[22:40:48] *** Joins: tcr (tcr@7C181A70.200CF5B8.9D2C3D3E.IP)
[22:40:49] <dherman> AutomatedTester: the web needs people who care about API design
[22:40:59] <dherman> AutomatedTester: not just logically fulfilling use cases
[22:41:07] <sfackler> nathan7: dynamically sized types
[22:41:19] <AutomatedTester> dherman: fair enough... /me goes and votes for you
[22:41:31] <dherman> AutomatedTester: :D
[22:41:55] <AutomatedTester> dherman: just one thing, does the potential amount of travel bother you?
[22:42:15] <docbrown> Why don't macros follow the same export rules as all other items?
[22:42:20] <AutomatedTester> seeing how annevk seems to hate it 
[22:42:40] <dherman> AutomatedTester: I already do a bunch of travel for mozilla, and this is only 4 meetings
[22:42:44] <pauls> docbrown: macros can expand to modules...
[22:42:47] <nathan7> sfackler: ah
[22:42:50] <cmr> What's the TAG?
[22:42:51] <AutomatedTester> dherman: ok cool :)
[22:42:59] <cmr> Technology Advancement Group is the best I can come up with...
[22:43:09] <AutomatedTester> cmr: Technical Architects Group of the W3C
[22:43:15] <cmr> Ah
[22:43:25] <AutomatedTester> cmr: you have to become hipster to fit in
[22:43:38] <sbalmos> groan
[22:43:40] <AutomatedTester> cmr: I am sure dherman is up for the challenge ;)
[22:43:40] <docbrown> pauls: So how do I ensure that my macro won't collide with another?
[22:43:59] <nathan7> We can buy dherman a fixie that secretly has multiple gears
[22:44:12] <nathan7> and a self-adhesive mustache
[22:44:13] <cmr> dherman: why aren't you in #rust-internals? :)
[22:44:25] <sbalmos> AutomatedTester: Does membership include the requisite oddly-rimmed glasses, satchel, and track jacket / slim jeans uniform? :P
[22:46:00] <mib_mgfsdx> pauls: can I extract a generic type parameter with a macro?
[22:46:08] <dherman> cmr: because reason?
[22:46:41] *** Joins: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net)
[22:46:50] <mark_edward> nmatsakis, thanks for the explanation. but as far is a understand, a trait object is uniformly sized, right?
[22:46:54] <pauls> mib_mgfsdx: what do you mean "extract"?
[22:47:19] <strcat> mark_edward: a ~Trait is uniformly sized, it's a ptr to a vtable and a ptr to a dynamically sized thing
[22:47:28] <strcat> now lets say we want to support Rc<Trait> and Gc<Trait>
[22:47:50] <strcat> atm, Rc allocates an RcBox<T> which is { T, count }
[22:47:54] <pauls> mib_mgfsdx: the type parameter system isn't syntactic, like C++'s.
[22:48:03] <strcat> so it uses sizeof::<RcBox>() and allocates that much
[22:48:07] <mark_edward> strcat, can't it be a pointer to struct containing a vtable ptr and a ptr to a dynamically suzed thing?
[22:48:57] <strcat> mark_edward: that's just double-indirection, which you can already do
[22:48:59] <strcat> Rc<~Trait>
[22:49:04] <mib_mgfsdx> pauls: hmm.. I suppose that doesn't really make sense then
[22:49:08] <cmr> nmatsakis: is DST backwards compat? (It seems to be)
[22:49:10] *** Quits: tikue_ (tkuehn@622204DD.28259105.689607DE.IP) (Quit: tikue_)
[22:49:23] <mark_edward> strcat, so whats the problem?
[22:49:27] <nmatsakis> cmr: I guess that depends on what "DST" is :) which is what we're trying to figure out
[22:49:33] <nmatsakis> gotta go, dinner time here
[22:49:45] *** Joins: dbaupp (Thunderbir@A192CB9D.D5A1DCF.37681C44.IP)
[22:49:48] <strcat> mark_edward: well if you don't see double indirection as a problem, then this isn't an interesting topic
[22:49:49] *** Quits: jviereck (Adium@moz-FC52FD58.dip0.t-ipconnect.de) (Quit: Leaving.)
[22:50:07] <mark_edward> strcat, well how does C++ support Virtual objects?
[22:50:19] <strcat> C++ doesn't have traits or trait objects
[22:50:40] <pnkfelix> mark_edward: object's carry vtables in C++
[22:50:53] <strcat> and it doesn't provide memory safety for virtual inheritance
[22:51:00] <strcat> there is object slicing
[22:52:20] *** Quits: eternaleye (eternaleye@moz-5668AFCB.hsd1.wa.comcast.net) (Ping timeout)
[22:52:25] <strcat> if you tried to provide inheritance in rust you would struggle with object slicing afaik
[22:52:32] <mark_edward> can people just implement their pointer types in terms of T, and ~Trait?
[22:52:45] <mark_edward> i mean, it seems like a reasonable amount of specialization to ask for
[22:53:01] <strcat> the problem is double indirection for trait objects
[22:53:39] <strcat> ~T doesn't support allocators, either
[22:53:52] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[22:54:02] *** Joins: eternaleye (eternaleye@moz-5668AFCB.hsd1.wa.comcast.net)
[22:54:13] <mark_edward> strcat, so right now, ~Trait is essentially (vtable_ptr, struct_ptr) correct?
[22:54:23] <strcat> yes, where struct_ptr is an ~ ptr
[22:54:38] <strcat> trait objects are currently a very unappealing language feature for freestanding usage of rust - they force you to use ~
[22:55:01] <cmr> acrichto: ist here any "nice way" to fail before the runtime is initialized?
[22:55:04] <cmr> (context: servo)
[22:55:21] <strcat> cmr: abort?
[22:55:23] <erickt> cmr: there's an abort
[22:55:26] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[22:55:36] <mark_edward> so what if, when you implement a pointer type, say RC<T> for T:Trait, a trait object becomes RC<Trait> =  (vtable_rcptr, struct_rcptr)
[22:55:40] <acrichto> cmr: sadly no, but the fail!() macro will still work in that it will still print something, but it then aborts the program
[22:55:49] <cmr> yeah but it rtaborts which spews nastily.
[22:55:54] <strcat> mark_edward: Trait isn't currently a type
[22:55:57] <acrichto> cmr: I guess if by "nice" you mean "unwinds to a boundary", then no
[22:55:59] <strcat> ~Trait is a type, Trait is not
[22:56:08] <strcat> all types in rust currently have a known, static size
[22:56:15] <cmr> by nice I really just mean "doesn't trigger assertion failure with lovecraftian sprawl"
[22:57:17] *** Quits: donri (donri@moz-9BB61102.tbcn.telia.com) (Client exited)
[22:57:27] <strcat> this is why D has value types and gc'ed reference types
[22:57:43] <strcat> limiting trait objects to certain built-in pointers is not much better
[22:57:49] <mark_edward> why don't we just make the trait type Trait: (MyPtr<vtable>, MyPtr<struct>)?
[22:58:08] <strcat> it doesn't solve it
[22:58:13] <mark_edward> how so?
[22:58:28] <strcat> trait objects exist because they're able to erase the differences between types
[22:58:40] <strcat> a trait object has a single type, but can hold objects of many different types
[22:58:42] *** Quits: devbug (quassel@2D4E172D.4C8B6099.9B57EA59.IP) (Ping timeout)
[22:59:05] <strcat> there's no point of trait objects if they have different types based on what they contain
[23:00:12] <mark_edward> strcat, but current trait objects erase this, even though they use ~T to store the struct right?
[23:00:25] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Input/output error)
[23:00:38] *** flaper87 is now known as flaper87|afk
[23:01:27] <mark_edward> so current ~Trait is essentially (~Vtable, ~void) right?
[23:01:58] <tiffany> how stable is rust's ABI?
[23:02:03] <cmr> tiffany: entirely unstable
[23:02:09] <cmr> I mean, practically it doesn't change often
[23:02:11] <tiffany> well I mean in relation to the language
[23:02:16] <strcat> mark_edward: (&'static vtable, ~T)
[23:02:23] <strcat> tiffany: the language is rock solid, then
[23:02:27] <cmr> We won't have ABI compat for 1.0
[23:02:30] <tiffany> oh, geez
[23:02:32] *** Joins: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com)
[23:02:41] <strcat> we can't have ABI stability in the current design of the stdlib
[23:02:58] <strcat> it exposes std::reflect and std::repr - there is no form of ABI stability possible.
[23:03:01] <mark_edward> strcat, so trait objects, still have to erase the type somehow, even though they contain ~T, right?
[23:03:03] <tiffany> uhh.. I mean like, the layout of trait objects and stuff
[23:03:07] <tiffany> and ~[T]
[23:03:14] <tiffany> how often do those change?
[23:03:33] <strcat> tiffany: ~[T] should be removed as it is now
[23:03:37] <strcat> it's a mess
[23:03:42] <strcat> slices changed since 0.8
[23:03:58] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[23:04:01] <strcat> trait objects should change, at least for #[no_std] where you don't want RTTI for GC support
[23:04:24] <strcat> functions currently take an env pointer as the first parameter and that may change
[23:04:35] <tiffany> what I really want to know is how crazy do I have to be handing rust types back and forth from C
[23:04:37] <strcat> the ABI for parameter passing and returns changes frequently
[23:05:14] <cmr> tiffany: fairly crazy.
[23:05:18] <strcat> tiffany: stick to primitive types (integers, floats, slices) and structs
[23:05:38] <mark_edward> strcat, so what's so difficult about changing trait objects form (&'static vtable, MyPtr<T>) ? i mean ~ is defined as a lang iterm, right?
[23:05:43] <tiffany> like, array slices?
[23:05:46] <tiffany> I guess that's fine
[23:05:58] <strcat> mark_edward: so now you're asking 'what is so difficult about supporting dynamically sized types'
[23:06:18] <strcat> so we want Rc<Trait>
[23:06:30] <strcat> this means Rc needs to be able to manage something of dynamic size
[23:06:32] <mark_edward> strcat, how so? ~T isn't dynamically sized. how is RC<T>?
[23:07:00] <strcat> have you read niko's series of posts about it?
[23:07:07] <mark_edward> whatever makes ~T work in tha tplace, should be able to make RC<T> work. and yes i ahve
[23:07:10] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[23:07:16] <strcat> ~T is hard-wired into the compiler
[23:07:25] <strcat> ~Trait is hard-wired into the compiler to support trait objects of ~T
[23:07:55] <AutomatedTester> sbalmos: have you seen Alex Russell? That should answer your question
[23:08:25] <strcat> so how do we support trait objects for library smart pointer types?
[23:08:41] <strcat> look at the implementation of Rc
[23:08:43] *** Joins: azita (Azita@moz-BBE3ABD.mv.mozilla.com)
[23:08:58] <mark_edward> i think i wasn't clear I am saying, when you have ~Trait, which can be thought of as Unique<Trait> that = (&'static vtable, Unique<T>), so RC<Trait> can be (&'static vtable, RC<T>)?
[23:09:31] <mib_mgfsdx> recursive typing.. nice
[23:09:42] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[23:09:45] <strcat> mark_edward: so think about the destructor for Rc<Trait>
[23:10:07] * strcat shrugs
[23:10:28] *** Quits: mib_mgfsdx (Mibbit@27A93EB4.DF4637DA.62D74A69.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[23:10:35] <mark_edward> strcat, what would be the problem? Maybe i'm not thinking it through enough
[23:10:53] <strcat> mark_edward: Trait isn't a type, you can't currently have Rc<Trait>
[23:11:11] <mark_edward> well the point of what i was just doing was to make it one
[23:11:21] <strcat> mark_edward: ok so lets say Trait is a type
[23:11:32] <strcat> you can't do size_of::<Trait>()
[23:11:38] <strcat> the size is statically known
[23:11:45] <strcat> you can be passing around an unboxed trait - it won't work
[23:12:04] <strcat> so what is different about this type in regards to all the others that makes it remain sound?
[23:12:09] <mark_edward> a type which is a typedef for (&'static vtable, Ptr<T>). that is statically sized, depending on the size of Ptr<T>?
[23:12:14] <mark_edward> isn't it?
[23:12:37] <strcat> mark_edward: trait objects exist to erase the differences between types
[23:12:59] <strcat> the type T is not known based on the trait object type
[23:13:28] <mark_edward> i know that, but clearly rthe type is erased when you have (&'static vtable, Unique<T>), currently known as (&'static vtable, ~T)
[23:13:45] <strcat> because it's hard-wired into the compiler that way
[23:13:51] <strcat> we don't have a generic way for a library type to do that
[23:15:05] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[23:15:09] <mark_edward> strcat, so why couldnt the compiler do that for (&'static vtable, U<T>) where U:Ptr/Alloc
[23:15:24] <strcat> so then we need some language support for this
[23:15:29] <strcat> which is what dynamically sized types is about
[23:15:30] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[23:15:30] *** Quits: willingc (willingc@moz-B4760708.san.res.rr.com) (Client exited)
[23:15:39] <strcat> it's the language support required to support this
[23:15:54] <mark_edward> i mean the compiler has to tell (~) to allocate memory at some point right?
[23:16:18] <strcat> mark_edward: a trait object isn't represented in the compiler as (&'static vtable, ~T)
[23:16:46] <mark_edward> I've been working under the assumption it was, based on your earlier statements
[23:16:47] <strcat> the compiler has special code paths for trait objects
[23:16:55] <strcat> mark_edward: I was talking about the in-memory representation
[23:17:00] <strcat> at runtime
[23:17:13] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[23:17:55] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[23:19:29] *** Quits: jvshahid (jvshahid@BE83DFD.50866E69.CA2DF2C0.IP) (Ping timeout)
[23:20:09] <mark_edward> well everything is bits right? so the compiler just says, i have here Trait object, (&'static vtable, Ptr<T>) get the correct function from vtable, and pass the memory at Ptr<T> to the function if needed
[23:20:15] <mark_edward> hypothetically
[23:20:57] <strcat> it's not about what is possible at a machine code level
[23:21:03] <dbaupp> jvns: ping
[23:21:14] <jvns> dbaupp: pong
[23:21:24] <strcat> anyway nevermind
[23:21:33] <dbaupp> jvns: kinda off topic, but http://jvns.ca/blog/2013/12/02/types-in-rust/ "Day 35"?
[23:21:36] <strcat> if you think it's possible to implement a trait object with Rc right now, then demonstrate that
[23:21:42] <strcat> as in working code
[23:21:49] <jvns> dbaupp, oh, it's day 35 of hacker school
[23:21:50] *** Joins: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com)
[23:22:10] <dbaupp> jvns: ah, I see
[23:22:13] <jvns> the "day 35" is orthogonal to Rust :)
[23:22:25] <mark_edward> strcat, well i'm no compiler hacker, i'm trying to get you to tell me what is infeasible, since i figured you'd know
[23:22:36] <strcat> but you don't believe me
[23:22:54] *** zz_kimundi is now known as kimundi
[23:23:46] <mark_edward> strcat, you haven't explained you, you just keep saying we need DST, Trait isn't a type
[23:23:52] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[23:24:19] <strcat> I made my best attempt at explaining why Rc relies on knowing the fixed size of an object
[23:24:27] <strcat> and it has a destructor, which needs to free the object
[23:24:34] <strcat> traits are there to erase the differences between types
[23:24:39] <strcat> it still needs to be able to destroy it
[23:26:18] <strcat> jvns: you can get the name of a type from the compiler
[23:26:30] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[23:27:05] *** Quits: jvns (bork@87D98E32.4046EB22.428F94DD.IP) (Ping timeout)
[23:27:09] *** Quits: tcr (tcr@7C181A70.200CF5B8.9D2C3D3E.IP) (Client exited)
[23:27:40] *** Joins: tcr (tcr@7C181A70.200CF5B8.9D2C3D3E.IP)
[23:28:14] <mark_edward> strcat, i see. does ~ "not" rely on knowing the fixed size of an object?
[23:28:40] <strcat> ~Trait isn't ~T
[23:28:50] <strcat> it's a separate code path in the compiler
[23:29:01] <mark_edward> but ~Trait needs ~T, right?
[23:29:13] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[23:29:13] *** ChanServ sets mode: +ao dherman dherman
[23:29:15] <strcat> it's not implemented on top of ~t
[23:29:18] <strcat> ~T
[23:29:27] *** Quits: tcr (tcr@7C181A70.200CF5B8.9D2C3D3E.IP) (Ping timeout)
[23:29:41] <mark_edward> strcat, really! then how does it store things?
[23:29:46] <strcat> the memory representation looks like (&'static vtable, ~T) but that's not how it's implemented (it can't be implemented that way)
[23:29:50] <strcat> mark_edward: it's a completely separate type
[23:29:56] <strcat> it is a different code path in the compiler
[23:30:07] <mark_edward> strcat, is it a type representable as a Rust type?
[23:30:11] <strcat> no
[23:30:23] *** Joins: tikue_ (tkuehn@622204DD.28259105.689607DE.IP)
[23:30:30] <mark_edward> ah i see the dilemma now
[23:30:39] *** Quits: notmatt_ (notmatt@moz-9FB2565E.vc.shawcable.net) (Client exited)
[23:30:48] *** Joins: jvshahid (jvshahid@BE83DFD.50866E69.CA2DF2C0.IP)
[23:31:09] <mark_edward> strcat, thanks for taking the time to explain, i know it must have been frustrating. but i've learned a lot in this channel thanks to people like you
[23:32:26] *** Joins: tcsc (tcsc@moz-ADC0ED45.hsd1.ct.comcast.net)
[23:32:49] *** Quits: santiago (santiago@moz-8ADE82B4.socal.res.rr.com) (Ping timeout)
[23:32:56] *** Joins: tcr (tcr@7C181A70.200CF5B8.9D2C3D3E.IP)
[23:34:11] *** Quits: g3xzh (g3xzh@moz-85224D43.red.bezeqint.net) (Ping timeout)
[23:34:46] *** Quits: Ralith (ralith@A8995AA9.62B6AF6A.922221DB.IP) (Ping timeout)
[23:37:06] *** Quits: shammancer (dannick@moz-CB791883.uws.ualberta.ca) (Ping timeout)
[23:37:52] *** Quits: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP) (Quit: Textual IRC Client: www.textualapp.com)
[23:40:28] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[23:40:58] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Max SendQ exceeded)
[23:41:15] *** Joins: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP)
[23:43:11] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[23:43:45] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Max SendQ exceeded)
[23:45:31] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[23:45:37] *** Quits: lfox (lfox@moz-343B6F0C.nyc.biz.rr.com) (Quit: ZZZzzz…)
[23:46:15] *** Quits: zslayton (Mibbit@81EB2473.5F4BC84E.66C78B76.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[23:46:48] *** Quits: Kingsley (kingsley@9B172CBE.BEA5C56D.DF4B730F.IP) (Ping timeout)
[23:47:15] *** Joins: Kingsley (kingsley@9B172CBE.BEA5C56D.DF4B730F.IP)
[23:48:34] *** kimundi is now known as zz_kimundi
[23:50:59] *** Quits: jvshahid (jvshahid@BE83DFD.50866E69.CA2DF2C0.IP) (Ping timeout)
[23:52:48] *** Quits: azita (Azita@moz-BBE3ABD.mv.mozilla.com) (Quit: azita)
[23:53:30] *** Quits: johns (johns@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[23:55:08] *** Quits: mye (mye@moz-FD24DF07.dip0.t-ipconnect.de) (Quit: mye)
[23:57:46] *** Quits: zaphod_b (ford_p@moz-CCE57F2F.eblcom.ch) (Client exited)
[23:57:49] *** Joins: mye (mye@moz-FD24DF07.dip0.t-ipconnect.de)
[23:58:12] *** Quits: tcr (tcr@7C181A70.200CF5B8.9D2C3D3E.IP) (Ping timeout)
[23:58:34] *** Joins: Sgeo (quassel@moz-D0F30617.dyn.optonline.net)
[23:59:40] *** Joins: fournm (Aria@moz-ABB60BA0.austin.res.rr.com)

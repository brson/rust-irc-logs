[00:00:05] <erickt> graydon: We would make a zero-sized `struct UnsafePtr<T>;`. Classic unsafe pointers with unknown lifetimes are `&'static UnsafePtr<T>`, whereas for an interior buffer for a str would be `&'self UnsafePtr<c_char>`
[00:00:34] <strcat> how could it be zero-size?
[00:00:44] <graydon> presumably containing only ()
[00:01:04] * strcat doesn't really get it
[00:01:18] <strcat> but it contains the object
[00:01:21] *** Joins: Lovot (root@AE31FB56.8153C3BF.F3C9A2D9.IP)
[00:01:40] <erickt> I believe empty structs, as in `struct Foo;` have no size
[00:01:53] <erickt> just like the unit type () has no size
[00:01:55] <strcat> yeah, they're zero-size, but I mean then you can't use the pointer
[00:02:09] <graydon> yeah
[00:02:12] <graydon> that part I don't get :)
[00:02:27] <Lovot> ow do I get glfw to work with rust, I installed the version located in mozilla servo
[00:02:44] <cmr> Lovot: https://github.com/bjz/glfw-rs/ is the upstream version
[00:02:48] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[00:02:51] <cmr> I don't know how up-to-date servo's fork is
[00:02:54] <graydon> (also I think it's likely a non-starter to tell people to write strstr(needle: UnsafePtr<c_char>, haystack: UnsafePtr<c_char>))
[00:02:57] <cmr> in fact, I thought they just used a submodule now
[00:03:00] *** Joins: jfbk (textual@moz-EEA9CFB3.nyc.res.rr.com)
[00:03:01] <erickt> libc::c_void is currently `enum c_void {}`. I know we can take a pointer to that
[00:03:23] <graydon> we can, but the pointer has a size.
[00:03:28] <graydon> the structure doesn't
[00:03:29] <Lovot> cmr: I already tried that, it trew a bunch of errors when I tried to make it
[00:03:38] <cmr> Lovot: What version of Rust are you using?
[00:03:45] <graydon> UnsafePtr<>, if it corresponded to the pointer, should have a size
[00:03:49] <graydon> (to store an address in, presumably!)
[00:03:59] <Lovot> cmr: .7
[00:04:01] <erickt> graydon: then how about `enum UnsafePtr<T> {}` :) this of course assumes we can add unused tyvars toy types 
[00:04:08] <graydon> or, oh, you'd do &UnsafePtr<>{}
[00:04:12] *** Quits: brianm (brianm@D2D642B9.79695EE7.489C5759.IP) (Quit: Linkinus - http://linkinus.com)
[00:04:15] <strcat> I think *c_void actually becomes *i8
[00:04:17] <cmr> Lovot: glfw-rs is targeted against master, not 0.7
[00:04:17] <erickt> graydon: yeah, sorry
[00:04:25] <erickt> &UnsafePtr<T>
[00:04:26] <cmr> Lovot: you'll need to either downgrade glfw-rs, or upgrade rust
[00:04:27] <graydon> that reads as a double indirection to me. I don't really .. um .. why is this not just &T?
[00:04:42] <strcat> I don't entirely understand LLVM's pointer rules yet
[00:04:51] <strcat> the dependency rules are very confusing
[00:04:56] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[00:05:02] <Lovot> cmr: I'll check the AUR
[00:05:16] <erickt> graydon: we can also add in some sugar to be able to write `*T`, but it just compiles down to the library code
[00:05:22] <cmr> Lovot: strcat here has nightly packages
[00:05:32] <cmr> Server = http://pkgbuild.com/~thestinger/repo/$arch
[00:06:08] <strcat> they're now almost 1/2 the size as before too ;p
[00:06:32] <strcat> smaller than the deltas :S
[00:06:39] <graydon> erickt: what's the benefit? that more thorough cases can use the full type?
[00:06:46] *** Quits: dew (Instantbir@moz-8A63B53.dhcp.stls.mo.charter.com) (Connection reset by peer)
[00:06:57] <erickt> graydon: the main advantage of this is just like the whole built-in-managed-ptrs-vs-done-in-library is we can clean out a bunch of codepaths in the compiler
[00:07:22] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[00:07:22] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/D1n4YA
[00:07:22] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[00:07:45] <strcat> I don't really think it can be done in a library
[00:07:51] <strcat> it would have to use intrinsics
[00:08:04] <erickt> strcat: yeah it'd be a library calling out to intrinsics
[00:08:06] <graydon> erickt: I dunno. I would prefer to just shrink the API surface of * and fix the temporary rules. I think * is little more than int-you-can-dereference.
[00:08:17] <strcat> graydon: it's more than that though ;p
[00:08:18] <graydon> I'm not sure the compiler does a whole lot with *
[00:08:30] <strcat> because LLVM pointers have more rules than just an integer you can deref
[00:08:41] <olsonjeffery> im getting deja vu
[00:08:53] <strcat> they are kind of a virtual concept of a pointer
[00:09:25] <Lovot> cmr: the AUR has rust-git, it's installing now
[00:09:39] <cmr> Lovot: why bother when you can filch strcat's prebuilt ones? :p
[00:09:41] *** Quits: carllerche (carllerche@A01051A9.6F669779.3D1CA460.IP) (Quit: carllerche)
[00:09:42] <strcat> there are daily builds of rust-git on arch's build server
[00:09:53] <strcat> and the rust-git pkg in the aur is missing some things
[00:10:05] <sully> ok, does uh
[00:10:10] <sully> anybody understand the pattern match code
[00:10:13] <olsonjeffery> im considering switching to arch just for daily rust bins, heh
[00:10:20] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[00:10:20] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/4VSC-A
[00:10:20] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[00:10:22] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[00:10:22] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/vtm0bg
[00:10:22] <ghrust> 13rust/06auto 14b6ea053 15Brendan Zabarauskas: Add some missing method wrappers to std::num
[00:10:22] <ghrust> 13rust/06auto 144f65fc7 15Brendan Zabarauskas: Improve std::num module description, and fix some formatting
[00:10:22] <ghrust> 13rust/06auto 146534b4d 15bors: auto merge of #8115 : bjz/rust/num-traits, r=brson...
[00:10:24] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[00:10:26] *** Quits: bytewise (bytewise@moz-649C630D.unitymediagroup.de) (Quit: Leaving)
[00:10:28] <cmr> olsonjeffery: what are you using now? the package would probably work on it
[00:10:46] <olsonjeffery> ubuntu 12.10 still
[00:10:51] *** Quits: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[00:11:19] <erickt> graydon: I just worry that this is going to lead to bugs that the compiler could have prevented without that much pain.
[00:11:54] <graydon> strcat: sure, we have to translate them correctly. I appreciate what you're doing there. But in the sense of rust semantics, they're not substantially more than ints. rust at least lets you do whatever you like with them. and I think they're there specifically for C programmers to avoid dropping to C to do weird tricks.
[00:12:25] <strcat> graydon: C pointers are actually pretty strict
[00:12:28] <graydon> erickt: I think the "lifetime" guarantee just doesn't buy you anything
[00:12:38] <strcat> undef behaviour to index outside of an object (except one byte past the end)
[00:12:48] <strcat> like, actually doing pointer arith outside of it is undef
[00:12:54] <strcat> whether or not you deref
[00:13:00] <strcat> clang compiles all pointer arith to inbounds GEP
[00:13:01] <graydon> strcat: you can cast any number you like to a pointer and dereference it. people do all the time.
[00:13:15] <graydon> whether it's well defined, it's part of what people _do_
[00:13:18] <strcat> graydon: you can't actually though, there are very strict rules
[00:13:35] <strcat> C just likes to take the easy route and say if you do that, it's not C :)
[00:13:52] <Lovot> cmr: I will probably add the repo, it will auto update unlike the AUR version
[00:13:59] <graydon> it's something done by programs fed into C compilers
[00:14:10] <graydon> and people who pay people who write C compilers expect it to work
[00:14:19] <erickt> graydon: it protects you from easy mistakes. For example, having regions on vec.as_imm_buf() would turn this into a compile time error: `getenv("foo".to_vec().to_ptr())`
[00:15:00] <graydon> erickt: but that's a temporary lifetime error
[00:15:04] <strcat> I think those should just use &
[00:15:18] <strcat> let xs = ~[]; let p = xs.to_ptr();
[00:15:28] <graydon> erickt: that's what I'm getting at. the "easy" errors are just that we're doing temporary lifetimes wrong. the non-easy errors are contrived.
[00:15:30] <strcat> could just return &'self T
[00:15:35] <strcat> it will coerce to *T
[00:15:45] <graydon> it doesn't even need to
[00:15:59] <graydon> the temporaries inside that expr should live as long as the outer expr
[00:16:03] <erickt> strcat: that won't fix it. look at this gist that does that: https://gist.github.com/erickt/5967320
[00:16:16] <graydon> this is a normal issue in C++ and it's what bug 3511 is about
[00:16:31] <strcat> erickt: if you make to_ptr return &'self it won't let you do that
[00:16:43] <strcat> it knows it's non-null and valid, it doesn't really need to use *
[00:16:44] <erickt> strcat: look at the gist, it has that
[00:16:58] * strcat doesn't get it then
[00:17:18] <strcat> do rvalues really work like they do in C++, and go away at the end of an expr?
[00:17:39] <graydon> that question is what 3511 is about
[00:17:56] <strcat> I think almost any code using unsafe {} is suspect
[00:18:06] <erickt> strcat: as_ref is returning a &'self u8. What's happening is that at line 26 rust is making an implicit cast from `&'self u8` to `*u8`. Then the Cstr2 is dropped, leaving the dangling reference passed to baz
[00:18:07] <graydon> both of you please go weigh in about lifetimes-of-temporaries there! it's a real bug. milestone #1. we don't have it well-defined.
[00:18:22] <graydon> its non-well-definedness is a source of a whole host of problems
[00:18:47] <erickt> graydon: will do
[00:19:18] <graydon> plead with nmatsakis for some time and get it nailed down and make sure we're actually doing what we spec'ed and _then_ I'm happy to talk about whether * accidentally escapes a temporary. IMO it never should, and you'd need to do something very contrived to make it.
[00:19:20] *** Joins: dew (Instantbir@moz-8A63B53.dhcp.stls.mo.charter.com)
[00:19:28] <graydon> ugh, sorry
[00:19:30] <graydon> that's terrible tone
[00:19:32] <graydon> I'm yelling
[00:19:37] <graydon> I just feel sorry for our pointer types
[00:19:41] <graydon> someone tries to kill one of them every day
[00:19:44] <graydon> :(
[00:19:59] <graydon> sorry. it's a reasonable idea I just think it's the wrong place to spend the related effort.
[00:20:35] <erickt> :) no offense taken. I didn't feel you were yelling.
[00:21:24] <erickt> I just found what I thought was a happy union of features that I haven't seen in other languages that at least would make going from rust->C much safer
[00:21:31] <graydon> I did. I could tell that I had the eyes-bugging-out feeling when I type too fast.
[00:21:43] <graydon> yeah. it would certainly work for just that case.
[00:22:00] <strcat> erickt: I feel like we could just be using & more
[00:22:04] <graydon> I think that it would also make C signatures scarier and plausibly less honest, and wouldn't defend against nullable or pointer arithmetic
[00:22:12] <strcat> whenever you can express a lifetime borrowck can understand
[00:22:55] <erickt> strcat: I totally agree that we should be using & more in the FFIs
[00:23:06] <strcat> if it compiles correctly, don't know if it does
[00:23:43] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[00:23:50] <strcat> for example, strcmp
[00:24:02] <strcat> it's undef behaviour to pass a null
[00:24:30] <strcat> so you might as well say 'fn strcmp(s1: &c_char, s2: &c_char) -> c_int'
[00:24:34] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[00:24:52] <strcat> it's when C hands *you* a pointer that you would often need *
[00:25:23] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[00:26:35] <erickt> graydon: regarding making C signatures less honest, I completely buy that argument. This patch is annotating those C functions with regions purely to inform the rust compiler about the lifetimes of those pointers
[00:27:09] *** Joins: lkuper (lkuper@A386B130.A402E718.C082B7DC.IP)
[00:27:57] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[00:29:23] <erickt> graydon: one way to avoid this problem is we could hide the extern FFI functions, and expose low level rust function calls. So we implement memcpy as `memcpy(dst: &mut T, src: &T, len: uint) { intrinsics::memcpy(dst, src, len) }` where intrinsics::memcpy takes *T
[00:30:28] <graydon> unsafe fn memcpy(...) but yeah
[00:30:30] <graydon> it's possible
[00:30:39] <graydon> again, I think the temporary-lifetimes thing handles much of the risk
[00:30:40] <Lovot> cmr: I used the repo (compiling was going to take too much time), and glfw-rs installed correctly, do I merge ./lib with /usr/lib
[00:30:41] <graydon> but that would also help
[00:30:52] <erickt> graydon: totally agree about the temporary-lifetimes
[00:32:06] <cmr> Lovot: you can, yes. I usually shove stuff in ~/.local/lib though
[00:32:21] <bjz_> Lovot: hoy hoy, I do glfw-rs
[00:32:37] *** Joins: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net)
[00:33:20] <bjz_> Lovot: my makefile is pretty naive
[00:33:35] <bjz_> Lovot: I'm waiting for rustpkg really
[00:33:52] <gavinb> rusti: use std::num::FromStrRadix; let a = FromStrRadix::from_str_radix("123", 16);
[00:33:52] -rusti- <anon>:5:45: 5:73 error: cannot determine a type for this bounded type parameter: unconstrained type
[00:33:53] -rusti- <anon>:5          use std::num::FromStrRadix; let a = FromStrRadix::from_str_radix("123", 16);
[00:33:53] -rusti-                                                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
[00:33:53] -rusti- application terminated with error code 101
[00:34:29] <Lovot> cmr: I forgot I can place everything in /usr/local
[00:34:35] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[00:34:42] <erickt> graydon: and just to confirm, you feel the risk of someone doing `let x = foo.map(â€¦).to_ptr(); call_c_function(x)` is not a big enough to address?
[00:34:59] <gavinb> This error is confusing, especially as it looks like it works in https://github.com/mozilla/rust/pull/8040/files/ ip.rs
[00:35:32] <Lovot> bjz: Any tips on using glfw
[00:35:34] <gavinb> Can anyone shed any light on this? :/
[00:35:47] <graydon> erick: I think that's .. a bit contrived, yeah. I think when someone's making a pointer to pass to a C function they generally stop to think "how do I make this live as long as I think C will want it for", which involves thinking more than just stack lifetimes.
[00:35:56] <strcat> erickt: I think C function params could generally use & though
[00:35:57] <bjz_> Lovot: what are you trying to use it for
[00:36:08] <strcat> raw pointers are needed when you venture outside of things lifetimes can represent
[00:36:09] <bjz_> Lovot: there are examples in the examples folder
[00:36:11] *** Quits: bent (chatzilla@moz-932324BF.hsd1.ca.comcast.net) (Quit: ChatZilla 0.9.90.1-rdmsoft [XULRunner 22.0/20130619132145])
[00:36:17] <graydon> and they arrange to write, for example, "let m = foo.map(); call_c_function(m.to_ptr());"
[00:36:24] <graydon> for just this reason
[00:36:41] <strcat> and that could still be wrong depending on how long the function expects it to live
[00:36:46] <graydon> yup
[00:36:54] <graydon> lots of C functions will just randomly hold on to your pointers :(
[00:37:02] <graydon> put them in static globals or something
[00:37:09] <bjz_> Lovot: glfw aims to be stripped down and simple. Not much bloat. Basically it allows for input handling and context setup
[00:37:32] <graydon> (or, well, take ownership is the more common case, like passing a *char to some function that assumes you're passing owhership.)
[00:37:37] <bjz_> Lovot: Jeaye's q3 uses it: https://github.com/Jeaye/q3
[00:37:43] <bjz_> Lovot: so does servo
[00:37:57] <Jeaye> hmmm? :)
[00:38:39] <erickt> graydon: I should have too, but I didn't and it took me a bit to track down this issue with temporaries :) Anyway thanks for your input. I'll close my pull request, talk to nmatsakis about lifetimes, and start investigating making low-level rust wrappers to protect against people returning interior pointers to temporaries
[00:38:41] <Lovot> bjz_: I plan to use glfw for many things in the future, but right now I just need to display a 2d image drawn from commands as well as text
[00:38:51] <jmgrosen> Lovot: my light sculpture uses it too! https://github.com/jmgrosen/light-sculpture
[00:38:52] <bjz_> Jeaye: Lovot is asking for tips on how to use glfw
[00:38:59] <bjz_> jmgrosen: wut
[00:39:14] <bjz_> jmgrosen: I will have to add you to the examples list
[00:39:14] <jmgrosen> bjz_: sorry, meant light sculpture simulator :P
[00:39:54] <graydon> erickt: I would also be amenable to the argument that *-derived-from-& extends the lifetime of the & to as long as the * lives within the frame, or some such more-local cleanup. I just don't think trying to wire it into the named-lifetimes-that-we-promise-to-be-addressable scheme is ever going to make it safe.
[00:40:03] <jmgrosen> bjz_: it won't build out of that directory, some changes to rust-opengles are needed, so don't try to build it :P
[00:40:13] <jmgrosen> it also needs an older version of rust with extra::net
[00:40:16] <bjz_> jmgrosen: np
[00:40:24] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[00:40:24] *** ChanServ sets mode: +o dherman
[00:40:32] <bjz_> jmgrosen: still cool, glad I could help!
[00:40:39] <erickt> graydon: I'll add that to 3511
[00:40:48] <Lovot> Thanks for the help, If I can figure out how to use the tools, I may make something cool
[00:41:05] <jmgrosen> bjz_: yeah, thanks! the only change i ask for is to remove @s, but oh well
[00:41:14] <graydon> but .. hm. I dunno. maybe I'm just being reactionary and this would help. it's hard to say. I wish someone else had a strong opinion. I feel like I'm arguing a case out of conservatism and sloth, a desire to stop changing things more than a heartfelt conviction.
[00:41:18] <bjz_> jmgrosen: yeah :(
[00:41:42] <bjz_> jmgrosen: I need to move to messaging internally
[00:42:12] <bjz_> jmgrosen: https://github.com/bjz/glfw-rs/issues/23
[00:43:11] <jmgrosen> bjz_: interesting, i'm afraid i don't know much about glfw so i'm wouldn't know much about the interop
[00:43:33] <erickt> graydon: So far I haven't quite convinced anyone else yet :) Would you be okay if I hold off closing this ticket until tomorrow when I can get nmatsakis's opinion about it?
[00:44:17] <graydon> erickt: certainly. he's been very busy (at a PJS workweek in paris) so it might take a little while, but I wouldn't insist you close it or anything. I don't feel super strong. it just .. "feels a bit wrong" to me.
[00:44:18] <erickt> I haven't had much of a chance to talk to him about it
[00:44:21] <graydon> sure sure
[00:44:26] *** Joins: eatkinson (eatkinson@moz-AD233F1B.dia.static.qwest.net)
[00:45:24] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[00:45:25] <erickt> graydon: I totally buy it. It does seem to imply a contract that C won't necessarily enforce
[00:45:30] <graydon> rustc can't run under RUST_NEWRT=1 yet, right?
[00:46:49] <strcat>             let p = to_unsafe_ptr(&((**repr).data.data));
[00:46:51] <strcat>             let p = to_unsafe_ptr(&((**repr).data));
[00:46:52] <brson> graydon: no, it runs out of stack. I have a patch enqueued that bumps the stack size
[00:46:53] <strcat> wat
[00:47:10] <erickt> thanks for your input graydon :)
[00:47:26] <graydon> erickt: np. sorry it's not more constructive
[00:47:50] <erickt> I found it to be really helpful
[00:47:58] <graydon> brson: in a way I can't effect with RUST_MIN_STACK or such?
[00:48:30] <graydon> brson: I'm not in any hurry, just checking out that Fresh New Runtime Smell
[00:49:14] <brson> graydon: change the MIN_STACK_SIZE constant in rt/task.rs
[00:49:21] <brson> 2MB should be enough
[00:51:03] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[00:52:26] <graydon> aha. no worries.
[00:54:14] <bblum> does #[macro_escape] let a macro out into the rest of the crate, or into the rest of any crate that links with it too?
[00:54:17] <brson> toddaaro: logging seems to not work with your refactoring patches because try_unsafe_borrow isn't implemented for Task
[00:54:21] <pcwalton> ugh, this lint pass
[00:54:24] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[00:54:34] <pcwalton> I still don't understand how the visitors work after 3 days
[00:55:02] <Jeaye> Lovot: I'd just check with the example code; that's where all almost 100% of my code came from.
[00:56:15] <acrichto> pcwalton: which lint pass?
[00:56:23] <pcwalton> acrichto: the whole lint.rs in general
[00:56:26] <pcwalton> it's exceedingly confusing
[00:56:30] <pcwalton> I'm trying to port it to the new visitor
[00:56:38] <acrichto> yeah sorry about that :(
[00:57:08] <acrichto> pcwalton: is the new visitor a trait based one with default implementations to recurse?
[00:57:11] <pcwalton> yes
[00:57:20] <pcwalton> well, no default methods yet but I will add them later
[00:57:27] <acrichto> are you giving each lint a different struct to implement the trait on?
[00:57:33] *** Quits: tchoma (tchoma@moz-E58E29CC.dsl.static.sonic.net) (Ping timeout)
[00:57:34] <pcwalton> I will be
[00:57:40] <pcwalton> but right now I'm just leaving the old visitor alone
[00:57:40] <pcwalton> a
[00:57:41] <pcwalton> n
[00:57:41] <pcwalton> d 
[00:57:49] <pcwalton> and making only the id_visitor the new visitor
[00:58:05] <pcwalton> the id_visitor is used by "lint_session"
[00:58:06] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[00:58:14] <acrichto> at least it's progress :)
[00:58:24] <pcwalton> and I keep missing lints and/or not recreating the item_stopping_visitor logic right
[00:58:50] <acrichto> yeah it was tricky getting everything just right the first time, and that's why it's a bit confusing I think...
[00:59:27] <acrichto> pcwalton: if you want to just completely ignore lint.rs I could try taking a stab at it after the new visitor has landed
[00:59:34] <pcwalton> the tuples of visitors thing is just too confusing
[01:02:17] *** Quits: lkuper (lkuper@A386B130.A402E718.C082B7DC.IP) (Quit: lkuper)
[01:03:05] *** Quits: igl (igl@moz-66ACF6D6.adsl.alicedsl.de) (Ping timeout)
[01:03:13] <graydon> foreach loops seem to work
[01:03:14] <graydon> https://gist.github.com/anonymous/1299e530260289aeab88
[01:03:18] <graydon> strcat: ^^
[01:03:31] *** Joins: igl (igl@moz-11AB8F32.adsl.alicedsl.de)
[01:04:08] <graydon> ("foreach" is temporary there until a snapshot etc.)
[01:06:28] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: zzzzzzzzzz)
[01:06:36] <engla> I have a question.  let mut iter = v.iter();  foreach x in iter {  iter.next(); // can I modify it here? }
[01:06:51] <engla> it's not super-important since you can write it out with loop/match anyway
[01:07:26] <Luqman> engla: use mut_iter
[01:07:40] <engla> no, that's different
[01:07:51] <engla> I mean accessing the `iter` variable
[01:07:57] <Luqman> oh
[01:08:01] <graydon> you mean change the iter? no, the loop desugars to take ownership of the iter expression in a local binding.
[01:08:09] <engla> right that's the question. ok
[01:08:17] <graydon> I .. don't think I can see another way to do it
[01:08:30] <strcat> graydon: yay \o/
[01:08:52] <engla> I don't know about the sugar. but we can manually write a loop that allows it,  loop { match iter.next() {   /* I can modify `iter` here */ }
[01:09:15] <pcwalton> acrichto: I'm going to xfail the couple of failing tests, if you can fix them up
[01:09:35] <strcat> engla: doesn't next() freeze it for that scope?
[01:09:48] <engla> no
[01:10:14] <engla> as we discussed yesterday, the iterator value doesn't freeze
[01:10:27] *** Joins: brendan (brendaneic@moz-FB09EACF.public.wayport.net)
[01:10:56] <graydon> engla: it's not that; it's that the desugaring assumes you are passing an expression-that-evaluates-to-an-iterator in the loop-head, not an iterator-lval. so it forms a new mutable lval and evaluates the expr into it, and advances that.
[01:11:27] <engla> graydon: so the iterator is useless even if you break?
[01:11:53] <graydon> the iterator is invisible
[01:11:57] <graydon> foreach x in foo() { ... }
[01:12:00] <graydon> what's the iterator's name?
[01:12:09] <graydon> it's not x. x is what the next() value gets destructured into
[01:12:10] <engla> foreach x in iter { .. break; }    // can't continue on iter
[01:12:13] *** Quits: brendan (brendaneic@moz-FB09EACF.public.wayport.net) (Ping timeout)
[01:12:18] <engla> yes I understand
[01:12:25] *** Joins: henrikhodne (henrikhodn@moz-F3A92B1C.hsd1.ca.comcast.net)
[01:12:39] <graydon> if you want an iter you named yourself, I think you have to write the loop yourself
[01:12:45] <graydon> otherwise I'm not sure how the compiler would guess which to do
[01:12:46] *** Quits: thomaslee (thomaslee@moz-6C3931E3.static.twtelecom.net) (Client exited)
[01:12:55] <engla> ok. you can partially iterate something with  .advance() today
[01:12:57] <graydon> I guess we could check to see if the expr is an lval
[01:13:06] <graydon> starts to feel pretty clever though
[01:13:09] <engla> right
[01:14:12] <engla> in python this pattern appears, you iterate something with for, you break from that loop, new for loop continues that iteration
[01:14:34] <graydon> python is duck-typed :)
[01:14:47] <engla> that's ad-snakinem
[01:15:02] <ChrisMorgan> I'd say that doing that in Python is very rare.
[01:15:09] <ChrisMorgan> (But not unknown.)
[01:15:09] <graydon> https://twitter.com/campoy83/statuses/358075536704163840
[01:15:16] <graydon> ad-snakinem?
[01:15:30] <graydon> snack? or snake?
[01:15:32] <engla> adhominen towards pythons
[01:15:43] <graydon> oh no some of my best friends are ducks
[01:15:53] <graydon> (technically: cats dressed as ducks)
[01:16:02] <graydon> (looking like snakes)
[01:16:04] <engla> ack you can't argue with this guy, chewbacca defense all the way
[01:16:17] <engla> hehe
[01:16:29] <graydon> I'm sorry, I just .. don't know what we'd do aside from essentially duck-typing on the AST
[01:16:48] <graydon> as in "you pass us an lval, we'll advance it; pass us anything else and we'll form our own lval"
[01:17:00] <graydon> is that what you would prefer?
[01:17:19] <engla> ok we can forget the first thing (mutate iterator inside the loop) and focus on the second
[01:17:27] <graydon> sure
[01:17:30] <engla> the sugar takes a &mut to the iterator, advances it
[01:17:43] <engla> we do want to be able to take &mut from temporaries anyway
[01:17:59] <graydon> that would require everyone to write "let mut x = foo.iter(); for i in x { ... }" no?
[01:18:16] <engla> I guess.. that's what we need right now too
[01:18:23] *** Quits: mhordecki (mhordecki@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: mhordecki)
[01:18:28] <graydon> or do you mean, you want the expression-as-a-whole to return the iter when it's finished?
[01:18:30] <graydon> that would be plausible
[01:18:42] <engla> not the latter
[01:19:05] <graydon> but you'd prohibit "for (&k,&v) in hashmap.iter() { ... }" ?
[01:19:21] <engla> why would that be
[01:19:28] <graydon> because you'd need to write
[01:19:46] <graydon> "let mut x = hashmap.iter(); for (&k,&v) in x { ... }"
[01:20:03] <engla> no no, that's what I meant with saying we want to be able to take &mut of temporaries
[01:20:10] <graydon> I'm just pointing out that the main use case of this is to put the iteratee in the expression.
[01:20:15] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[01:20:16] <engla> yes I agree
[01:20:16] <graydon> ok, then I don't understand.
[01:20:34] <graydon> what's the desugaring?
[01:20:49] <graydon> I have "let <pat> in <expr> <block>"
[01:20:53] <graydon> what do I generate?
[01:21:23] <engla> let it = &mut hashmap.iter(); loop { match it.next() { ...
[01:21:25] *** Joins: mhordecki (mhordecki@moz-BE33DA21.fw1.sfo1.mozilla.net)
[01:21:30] <graydon> currently it's "{ let mut <tmp> = <expr>; loop { match <tmp>.next() { None => break, Some(<pat>) => <block> } } }"
[01:21:49] <mihneadb> rusti: 2 + 2
[01:21:50] -rusti- 4
[01:22:23] <graydon> oh I see. mutably borrow the <expr> rather than take ownership of it.
[01:22:28] <graydon> that's plausible
[01:22:31] <engla> "that's what I meant with saying we want to be able to take &mut of temporaries"   
[01:22:34] <engla> yes
[01:22:35] <graydon> do we support that presently?
[01:22:41] <engla> I don't think so
[01:22:44] <graydon> oh :(
[01:22:52] <graydon> well, it seems like it'll be backwards compatible when we do. mostly.
[01:22:55] <engla> I expressed that I *think* that we want to be able to do that
[01:23:03] <graydon> mhm
[01:23:18] <graydon> I would open a sub-bug on the matter and nominate it. it's interesting and potentially useful.
[01:23:25] <mihneadb> rusti: [1, 2, 3].advance |&i| { print("%d ", i) }
[01:23:26] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/BMEE
[01:23:28] <graydon> I didn't mean to snark about it being a bad idea, just didn't see how it'd work.
[01:23:34] <goffrie> rusti: fn f() -> int { 5 } let x = &mut f(); *x = 6; *x
[01:23:34] -rusti- 6
[01:23:35] *** Quits: Vert (quassel@8A83479C.391ACC8C.CAF63861.IP) (Ping timeout)
[01:24:03] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[01:24:46] <goffrie> we would have to be able to mutably borrow temporaries or else the whole .iter().advance business wouldn't work, no?
[01:24:50] <engla> it's not the simplest scheme. If it can't be supported at reasonable cost it's a bad idea
[01:25:06] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[01:25:06] *** ChanServ sets mode: +o tjc
[01:25:31] <graydon> engla: goffrie makes a valid point. it seems to wkr?
[01:25:33] <graydon> work?
[01:25:43] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[01:26:08] <engla> ok maybe it does
[01:26:43] <bblum> brson: how does the rt::rust_<builtin...> stuff get resolved in all the task code? i can't make it resolve in unstable/sync
[01:27:06] *** Quits: eholk (eholk@moz-A00ECF4B.uconnect.utah.edu) (Quit: eholk)
[01:27:36] <graydon> engla: I'll see if I can whip up that translation now. might as well.
[01:28:10] <bblum> oh, gross, there's a task::rt
[01:30:14] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[01:32:09] <engla> translated to a macro it seems to work. But the tradeoff is there, the required mut
[01:32:17] *** Joins: chii (Mibbit@moz-831A0571.nycm.ny.dynamic.megapath.net)
[01:32:45] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[01:32:51] <engla> hm but that's a minor case, the major case is just   v.iter()
[01:32:58] *** Joins: maikklein (maik@moz-A63342D5.dip0.t-ipconnect.de)
[01:33:33] <strcat> graydon: you can borrow rvalues as &mut btw
[01:33:46] <graydon> engla: what's the tradeoff?
[01:33:47] <strcat> so you could just always borrow it as &mut like advance does atm
[01:33:52] <graydon> yeah, that's what I'm doing
[01:33:54] <strcat> oh
[01:33:54] <graydon> (about to try)
[01:34:26] <engla> graydon: just the requirement of 'mut' on iterating local variables   let mut iter;  foreach x in iter 
[01:34:31] <goffrie> although I think it wouldn't work if you had a 'let it = v.iter(); foreach x in it { ... }' but having an immutable iterator is just asking for pain, so bleh
[01:34:35] <engla> but then I realized the major case is iterating a temporary value
[01:34:45] <goffrie> yeah what engla said. :p
[01:36:43] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[01:37:07] *** Quits: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com) (Quit: tikue)
[01:37:53] *** Joins: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com)
[01:38:04] *** Quits: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net) (Ping timeout)
[01:38:52] *** Joins: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net)
[01:39:42] *** Quits: miloshadzic (miloshadzi@5E9C7FE4.FA4D0618.449B8A48.IP) (Quit: Textual IRC Client: www.textualapp.com)
[01:39:58] <bblum> brson: oh shoot, i didn't notice you r+ed select already and piggybacked two minor other commits on it -- mind taking a look at those?
[01:40:52] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[01:41:25] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Quit: Gone to save the world!)
[01:42:30] <brson> toddaaro: there are a number of places in the runtime now that call schedule_task and don't handle the case where it returns Some, then drop the scheduler
[01:42:45] *** Quits: azakai (alon@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[01:42:58] <brson> toddaaro: i mean, after your refactoring, which I am working off of
[01:43:08] <brson> i'll make a note in the pr
[01:44:42] *** Quits: cdidd (cdidd@moz-8DE79444.broadband.corbina.ru) (Input/output error)
[01:44:45] <toddaaro> brson: really? ok, I'll look into them
[01:45:39] <mihneadb> I m trying to do something like [1, 2, 3].each(function), like.. in one line, in rusti
[01:45:41] <mihneadb> how would I do it ?
[01:45:42] <graydon> engla: sure enough, with &mut this works: https://gist.github.com/graydon/f0e2b40f0d709a184368
[01:45:43] <engla> foreach by-move and by-mut-ref as macros https://gist.github.com/anonymous/3fb393b2ab7c29bf29bd     the by-move version has surprising (to me) behavior on line 31; the iterator is implicitly copied
[01:46:00] <engla> cool
[01:46:00] <mihneadb> for [1, 2, 3].iter().advance |&i| { print(fmt!("%d ", i)) } does not seem to work
[01:46:02] <graydon> engla: thanks for the suggestion! it's nice to be able to add
[01:46:43] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Client exited)
[01:47:18] <engla> I'm just thrilled for a for .. in loop
[01:47:50] <bblum> 'for a for .. in'? what crazy syntax is that?
[01:48:01] *** Joins: cdidd (cdidd@moz-A628B9BE.broadband.corbina.ru)
[01:48:16] <engla> hehe
[01:48:29] *** Quits: echristo (echristo@DCF57675.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[01:48:47] <brson> bblum: please put unrelated features into different pull requests in the future
[01:49:24] <bblum> brson: sure thing, sorry
[01:51:00] <bblum> i wonder if i rebased them away and pushed -f it would bors take it >_>
[01:51:34] <strcat> bblum: bors won't care as long as the new child commit has an r+
[01:51:42] <bblum> nice, i'll just do that then
[01:51:54] <bblum> brson: noted about task name mutability; not a hard change
[01:52:25] *** Joins: maikklein2 (maik@moz-CB1EB375.dip0.t-ipconnect.de)
[01:53:01] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[01:53:26] *** Quits: maikklein (maik@moz-A63342D5.dip0.t-ipconnect.de) (Ping timeout)
[01:53:26] *** Joins: maikklein3 (maik@moz-C3D98781.dip0.t-ipconnect.de)
[01:54:15] <acrichto> pcwalton: I can try to yeah
[01:54:26] *** Quits: maikklein2 (maik@moz-CB1EB375.dip0.t-ipconnect.de) (Ping timeout)
[01:55:21] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[01:55:22] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/vtm0bg
[01:55:22] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[01:56:44] <brson> bblum: thanks
[01:58:19] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[01:58:19] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/NVQ42A
[01:58:19] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[01:58:40] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Quit: leaving)
[01:59:08] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: Places to go, people to annoy)
[02:02:11] *** Quits: Uther (Instantbir@moz-1B244B05.hfc.dyn.abo.bbox.fr) (Ping timeout)
[02:02:25] *** Quits: heftig (heftig@6835D69C.6FC4DE2F.FEC4A986.IP) (Quit: Quitting)
[02:03:02] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[02:04:44] *** Joins: recrack (Mibbit@B4104EBB.3CC170B1.1E14B209.IP)
[02:05:43] *** Joins: alisdair (textual@FAD454DC.CDDF2711.C4CBE0CB.IP)
[02:07:31] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[02:08:30] *** Quits: alisdair (textual@FAD454DC.CDDF2711.C4CBE0CB.IP) (Ping timeout)
[02:08:30] *** Quits: eatkinson (eatkinson@moz-AD233F1B.dia.static.qwest.net) (Quit: eatkinson)
[02:09:05] *** Joins: alisdair (textual@FAD454DC.CDDF2711.C4CBE0CB.IP)
[02:09:34] <graydon> https://github.com/mozilla/rust/pull/8141 r? anyone
[02:10:19] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Quit: WeeChat 0.4.1)
[02:10:59] *** Joins: eatkinson (eatkinson@moz-AD233F1B.dia.static.qwest.net)
[02:11:37] *** Quits: alisdair (textual@FAD454DC.CDDF2711.C4CBE0CB.IP) (Ping timeout)
[02:12:33] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[02:13:00] *** Quits: chii (Mibbit@moz-831A0571.nycm.ny.dynamic.megapath.net) (Quit: http://www.mibbit.com ajax IRC Client)
[02:13:25] *** Joins: pnathan (Adium@moz-BDC3EE62.tukw.qwest.net)
[02:13:58] <engla> graydon.. if the for expression is just rewritten like this.. rust will be duck-typed too!! :-)
[02:14:13] * engla hides
[02:14:16] <graydon> well, we have inference, but there _is_ a typechecker
[02:14:25] <graydon> presumably the typechecker can tell your duck is just a cat in a duck suit
[02:14:41] <graydon> unless it convinces itself that that's the definition of "duck"
[02:14:44] *** Quits: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com) (Quit: tikue)
[02:15:48] <engla> does it check that the expression implements Iterator?
[02:15:55] <goffrie> engla: I think you meant "/me ducks"
[02:16:07] <goffrie> (or maybe I meant that? :P)
[02:16:20] <engla> I think graydon ducks
[02:16:22] * engla ducks
[02:16:47] *** Quits: sebcrozet (sebcrozet@moz-C27D92D8.w193-252.abo.wanadoo.fr) (Ping timeout)
[02:17:01] <recrack> hi, i have some question about macro.
[02:17:14] <recrack> https://github.com/mozilla-servo/rust-css/pull/22
[02:17:43] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[02:17:53] <recrack>  How to make indent $name string 'lowercase to uppercase' ?
[02:18:30] <goffrie> recrack: I suspect it's not possible with just a macro right now :/
[02:18:48] <graydon> engla: no, I guess it doesn't. It just calls .next()
[02:18:59] <engla> that's what I meant. just having fun
[02:19:16] <graydon> engla: I could explicitly type the binding, but it'd be an additional 50 lines of code to generate the AST and I want to go home.
[02:19:18] <graydon> patches welcome :)
[02:19:35] <graydon> (cue: "if only this was lisp" sad trombone)
[02:22:08] <recrack> goffrie: Thanks for your answer. I understand now, macro is not possible. It is so sad :(.
[02:23:04] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[02:23:06] <goffrie> recrack: perhaps you could get away with not uppercasing it, but putting it in a module?
[02:23:35] *** Joins: alisdair (textual@moz-CC0607B5.eng.wind.ca)
[02:24:23] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[02:25:34] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[02:26:01] *** Quits: mhordecki (mhordecki@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: mhordecki)
[02:26:03] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[02:27:23] *** Quits: jfbk (textual@moz-EEA9CFB3.nyc.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[02:28:55] * ChrisMorgan wrote a simple Python script to generate Rust code when he ran into something needing to be expanded in multiple places
[02:29:04] <ChrisMorgan> (And rewritten in different cases.)
[02:29:54] <doomlord> anyone know off hand how to compare s1:@str and s2:&str... i tried *s1==*s2, doesn't like derefing,  tried s2.eq(1s)   s1.eq(s2), says its wanting &&str
[02:30:08] <goffrie> doomlord: .equiv?
[02:30:32] <goffrie> wait, I might be remembering wrong
[02:30:37] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[02:30:54] <engla> doomlord: s2 == s1   should work
[02:31:03] <engla> rusti: "hi" == @"hi"
[02:31:04] -rusti- <anon>:5:17: 5:22 warning: unnecessary allocation, the sigil can be removed [-W unnecessary-allocation (default)]
[02:31:04] -rusti- <anon>:5          "hi" == @"hi"
[02:31:04] -rusti-                           ^~~~~
[02:31:04] -rusti- true
[02:31:05] <ChrisMorgan> Is it possible to get the output of an expanded macro? I've got a recursive macro which I'll want to look at the code of.
[02:31:35] <engla> I like rust's stern lints
[02:31:41] <engla> ChrisMorgan: rustc --pretty expanded
[02:31:50] * ChrisMorgan does too
[02:31:53] <ChrisMorgan> Thanks, engla!
[02:31:59] <doomlord> thanks, lol i tried s1==s2 but not s2=s1, i only did both ways round for .eq
[02:32:30] <engla> you have to know the right combination
[02:34:21] <ChrisMorgan> That's bad. That's *really* bad.
[02:34:52] *** Quits: graydon (Adium@A5087023.2354C43D.D8E68FF6.IP) (Quit: Leaving.)
[02:34:55] <ChrisMorgan> a == b => b == a. There's a reason why assert_eq!(a, b) does (a == b) && (b == a)...
[02:36:45] <engla> the problem is to get it to borrow the @str correctly so the types match  up and it can be compared
[02:37:32] <engla> (@"a").eq("b")  // there is no way to coerce "b" into a @str
[02:38:15] <strcat> ChrisMorgan: "foo" == @"foo" isn't doing &str == @str
[02:38:18] <strcat> it's doing &str == &str
[02:38:44] <strcat> it just picks up the type from the first parameter, and then makes sure the 2nd type is the same
[02:38:51] <strcat> except we have a weird slice auto-borrow rule
[02:38:59] <strcat> so @str/~str will coerce to &str
[02:39:29] <ChrisMorgan> (Given that it doesn't compile, I'm not so worried about the failure of equivalence, but it's still nasty.)
[02:40:11] <strcat> there's a price to pay for all the implicit magic
[02:40:17] <strcat> auto-ref, auto-deref, auto-borrow to slices
[02:40:21] <strcat> it all has a cognitive overhead
[02:40:30] <strcat> fixing this one case won't fix it in general
[02:40:32] *** Joins: tautologico (shung@9F01D096.92EA1F6.C27E1635.IP)
[02:40:36] <strcat> there are more weird issues.
[02:40:49] <engla> everything is better than copy constructors
[02:42:28] <strcat> Clone is a copy constructor ;p
[02:43:33] <engla> and it is explicit
[02:43:39] <engla> crisis averted
[02:47:36] *** Joins: steven_is_false (user@C5B76363.1FF1EBF8.1ECA502.IP)
[02:47:49] *** Quits: maikklein3 (maik@moz-C3D98781.dip0.t-ipconnect.de) (Ping timeout)
[02:47:50] *** Joins: chii (Mibbit@moz-77F78854.nycm.ny.dynamic.megapath.net)
[02:48:09] *** Quits: zz_kimundi (kimundi@moz-78A866D7.dip0.t-ipconnect.de) (Ping timeout)
[02:49:46] *** Quits: geomyidae (cole@DD6F7E3A.21468E9A.30200F38.IP) (Client exited)
[02:51:08] *** Joins: geomyidae (cole@DD6F7E3A.21468E9A.30200F38.IP)
[02:51:30] *** Joins: zz_kimundi (kimundi@moz-D3F44D32.dip0.t-ipconnect.de)
[02:51:50] *** zz_kimundi is now known as kimundi
[02:54:07] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[02:56:56] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[02:59:02] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[03:00:24] <chii> is there any way to make sleep (using global_loop) and explicit failures play together nicely?
[03:00:56] <chii> I tend to get "void upcall_call_shim_on_rust_stack(void*, void*): Assertion `false && "Rust task failed after reentering the Rust stack"' failed." at the end...
[03:01:16] <chii> of a program like http://mibpaste.com/19H2Gw 
[03:01:35] <chii> or segfaults
[03:02:47] <gavinb> "rust --foo" segfaults on my Mac with yesterday's master - file a bug?
[03:03:00] <mark_edward> how do we do bitwise complement ( `~` in C)?
[03:03:10] <mark_edward> rusti: ~1
[03:03:12] -rusti- ~1
[03:03:18] <chii> rusti: !1
[03:03:19] -rusti- -2
[03:03:27] <chii> flips bits and adds 1
[03:03:33] <mark_edward> chii: thanks chii
[03:03:35] <chii> so I guess subtract 1/
[03:03:40] <chii> no problem
[03:03:42] <engla> it just flips the bits
[03:03:44] <mark_edward> chii: what why does it add one?
[03:03:50] <chii> 2's complement?
[03:04:02] <engla> it's the negation that flips the bits and adds one
[03:04:05] <engla> !1 + 1
[03:04:08] <mark_edward> rusti: !0
[03:04:09] -rusti- -1
[03:04:10] <engla> rusti: !1 + 1
[03:04:11] -rusti- -1
[03:04:18] <mark_edward> rusti: !0u
[03:04:19] -rusti- 18446744073709551615
[03:04:41] <chii> any ideas on why explicit failures and global_loop sleeping together create failed assertions or segfaults?
[03:04:49] <chii> a la http://mibpaste.com/kpExgg 
[03:04:52] *** Joins: max (Maxdamantu@moz-18510.jetstream.xtra.co.nz)
[03:05:00] <mark_edward> rusti: !1 + 1
[03:05:01] -rusti- -1
[03:05:16] <chii> (also is there any way to suppress the "task failed at explicit failure" message?)
[03:05:18] <mark_edward> that means it just flips the bits, right?
[03:05:21] *** Parts: steven_is_false (user@C5B76363.1FF1EBF8.1ECA502.IP) (ERC Version 5.3 (IRC client for Emacs))
[03:05:29] <engla> mark_edward: yes, ! is just like ~ in C
[03:05:41] <mark_edward> engla: thanks
[03:05:42] <chii> thanks for the clarification engla!
[03:05:47] <chii> wasn't sure myself
[03:06:03] <engla> I'm confused all the time, so I understand
[03:06:38] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[03:06:50] <chii> on a different topic, is there something funky with global_loop::get? and/or how sleep works? not sure why explicitly failing
[03:07:00] <chii> would cause segfaults or failures on reentering the stack...
[03:08:17] <chii> this is 0.7 by the way
[03:08:39] <olsonjeffery> that whole codebase has been removed on master
[03:09:05] <chii> right, is that because there was a bug with sleep or global_loop? 
[03:09:12] <chii> just trying to understand olsonjeffrey
[03:09:28] *** Quits: alisdair (textual@moz-CC0607B5.eng.wind.ca) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[03:09:29] <chii> *olsonjeffery apologies!
[03:10:11] <chii> basically, is this a bug that master has fixed?
[03:10:18] <chii> or am I misusing sleep/fail/global_loop?
[03:10:31] *** Quits: LU324_ (stuff@moz-A17E9A7B.dyn.embarqhsd.net) (Ping timeout)
[03:10:33] <aatch> chii, you're using the uv bindings?
[03:10:42] <chii> yes, I think so...
[03:10:53] <chii> http://mibpaste.com/pEk22i for reference, if that helps any!
[03:11:15] <aatch> chii, well I think they have been removed now from master...
[03:11:33] <chii> right, but is that due to bugginess, or just cleaner api?
[03:11:36] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[03:11:36] *** ChanServ sets mode: +o brson
[03:11:50] <chii> I want to know if I'm doing something stupid/awful in this code :P
[03:11:52] <aatch> At any rate, they are planned to be as the new scheduler uses UV behind the scenes and should be providing an API there.
[03:12:22] <chii> in other words that basically wraps the &global_loop::get() bit?
[03:13:05] <chii> then what's causing the segfaults (if the loop happens 2.times and the failure happens at j == 1) or failed assertions? :(
[03:14:16] <ChrisMorgan> chii: extra::uv is no more; it's replaced with what is currently in std::rt and which must be run with RUST_NEWRT=1 or it will die.
[03:14:31] <chii> was that true in 0.7 ChrisMorgan?
[03:15:05] <ChrisMorgan> chii: it has been removed since 0.7. Both exist in 0.7, though more std::rt things will die badly in 0.7 than in the current state of things
[03:15:31] <chii> ChrisMorgan: thanks. I'm working off of 0.7, and the code I mibpasted runs correctly, only doing bad things on exit
[03:15:35] <chii> it seems
[03:16:06] <chii> so I'm just worried the problem is with how *I'm* combining them
[03:16:11] <ChrisMorgan> There may well be something to do what you want in std::rt::uv::timer. I'm not sure of the intent of that code, whether it's staying or going, and I'm not *certain* it's there in 0.7.
[03:16:29] <ChrisMorgan> I wouldn't be worrying about thatâ€”it's on the way out anyway, not worth worrying too much about.
[03:16:54] <chii> the intent of the code is just to demonstrate segfaulting/failure on reentry to stack behavior
[03:17:04] <chii> with some code that I'd have thought is reasonable...
[03:17:38] <chii> I understand that this code has been removed in master, but it's still compilable/runnable in 0.7 and I just want to make sure it's not that I'm misusing them
[03:17:51] <chii> hope that clarifies
[03:19:01] <ChrisMorgan> I don't know whether you are or not and I doubt that you'll manage to get a straight answerâ€”as it's gone, people are unlikely to spend any time trying to help you with it.
[03:19:17] <chii> so it seems
[03:19:22] <chii> thanks for responding in any case ChrisMorgan
[03:19:42] <chii> another (definitely quick) question: any way to suppress "task failed on explicit failure" messages...?
[03:20:04] * ChrisMorgan doesn't know
[03:20:10] <chii> ah cool
[03:20:13] <chii> thanks though!
[03:20:32] <ChrisMorgan> But do hang around and see if someone else does.
[03:20:34] <brson> chii: std::logging::console_off() will suppress them, but it's sort of a hack
[03:20:41] <brson> rustc uses it
[03:20:52] <chii> brson thanks!
[03:21:07] <brson> logging in rust is not so robust at the moment
[03:22:01] <chii> that's fine, this works!
[03:24:05] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[03:24:30] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[03:24:43] *** Joins: infynyxx_ (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[03:25:45] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[03:26:23] *** Quits: infynyxx_ (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[03:28:43] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[03:35:49] <ChrisMorgan> rusti: macro_rules! x(($($($i:ident)* =>),*) => ()) x!(A B =>);
[03:35:49] -rusti- <anon>:5:61: 5:63 error: Local ambiguity: multiple parsing options: built-in NTs ident ('i') or 1 other options.
[03:35:49] -rusti- <anon>:5          macro_rules! x(($($($i:ident)* =>),*) => ()) x!(A B =>);
[03:35:49] -rusti-                                                                       ^~
[03:35:50] -rusti- application terminated with error code 101
[03:35:59] <ChrisMorgan> How is that => ambiguous? It isn't an ident.
[03:37:43] <ChrisMorgan> rusti: macro_rules! x(($($i:ident)* /) => ()) x!(/);  // Simpler version
[03:37:43] -rusti- <anon>:5:51: 5:52 error: Local ambiguity: multiple parsing options: built-in NTs ident ('i') or 1 other options.
[03:37:43] -rusti- <anon>:5          macro_rules! x(($($i:ident)* /) => ()) x!(/);  // Simpler version
[03:37:43] -rusti-                                                             ^
[03:37:43] -rusti- application terminated with error code 101
[03:40:03] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[03:40:39] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Ping timeout)
[03:42:11] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[03:42:19] *** Joins: mrordinaire (Mibbit@8487BAED.E79832F4.8BC4C3B1.IP)
[03:42:49] <mrordinaire> hi, I'm having problems with the following code
[03:43:09] <mrordinaire> rusti: pub fn unescape_url(escaped_url: ~str) -> ~str {         do escaped_url.as_c_str |c_url| {             unsafe {                 let mut len: c_int;                 let unescaped = curl_easy_unescape(self.raw, c_url, 0, to_unsafe_ptr(&len));                 from_c_str_len(unescaped, len)             }         }     }
[03:43:10] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/cBdS
[03:43:20] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[03:43:20] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/dKEDww
[03:43:20] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[03:43:25] <mrordinaire> could anyone help me fix it?
[03:43:47] <mrordinaire> a
[03:44:33] <mrordinaire> http://mibpaste.com/wpQ1CA 
[03:45:02] <mrordinaire> rusti: http://mibpaste.com/wpQ1CA 
[03:45:02] -rusti- <anon>:5:13: 5:14 error: expected `;` or `}` after expression but found `:`
[03:45:02] -rusti- <anon>:5          http://mibpaste.com/wpQ1CA 
[03:45:03] -rusti-                       ^
[03:45:03] -rusti- application terminated with error code 101
[03:46:09] <chii> mrordinaire not sure about the others, but you can't use "self.raw" unless self is passed as an arg
[03:46:13] *** Quits: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net) (Connection reset by peer)
[03:46:20] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[03:46:20] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/7xRXCw
[03:46:20] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[03:46:20] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[03:46:20] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/kt4WVw
[03:46:20] <ghrust> 13rust/06auto 14ac2cd14 15Brian Anderson: mk: Rename CTEST_BENCH to TEST_BENCH...
[03:46:20] <ghrust> 13rust/06auto 14ceba95c 15Brian Anderson: mk: Add NO_BENCH variable for turning off the --bench flag
[03:46:21] <ghrust> 13rust/06auto 1438d62fe 15bors: auto merge of #8111 : brson/rust/no-bench, r=graydon
[03:46:23] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[03:46:30] <ChrisMorgan> mrordinaire: there ain't enough code there to see what the problem is.
[03:46:31] *** Joins: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net)
[03:47:02] *** Quits: igl (igl@moz-11AB8F32.adsl.alicedsl.de) (Ping timeout)
[03:48:19] <mrordinaire> ChrisMorgan: http://mibpaste.com/28Lpui 
[03:48:28] <mrordinaire> ChrisMorgan: here's the whole file
[03:49:20] *** Joins: mhordecki (mhordecki@moz-329F29A3.lightspeed.sntcca.sbcglobal.net)
[03:49:28] *** Joins: igl (igl@moz-D82ABDB9.adsl.alicedsl.de)
[03:49:41] *** Quits: recrack (Mibbit@B4104EBB.3CC170B1.1E14B209.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[03:50:01] <ChrisMorgan> mrordinaire: you didn't specify `&self` in the arguments to unescape_url
[03:50:20] <mrordinaire> ChrisMorgan: ooooh
[03:50:23] <mrordinaire> ChrisMorgan: missed that
[03:50:28] <mrordinaire> ChrisMorgan: silly me
[03:50:33] <mrordinaire> ChrisMorgan: thanks a bunch
[03:53:53] <brson> toddaaro: with your branch and my patch to implement SingleThreaded `make` makes it all the way through the build. we're getting close
[03:54:05] <ChrisMorgan> Is anyone able to help me with the macro "local ambiguity" problem that I showed earlier?
[03:54:20] <brson> oh wait. heh I actually have to turn on the new runtime. duh
[03:54:29] <brson> let me try a little harder
[03:55:05] *** Quits: mrordinaire (Mibbit@8487BAED.E79832F4.8BC4C3B1.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[03:56:25] <doomlord> anyone know the path for uint "from_str" , i'm trying num::from_str::<uint>(some_str) and other variations to no avail
[03:56:58] <doomlord> let x:Option<uint>= from_str(some_str); etc..
[03:57:20] <brson> ChrisMorgan: not I. pauls and jbclements are your best bets for understanding macros
[03:57:48] <ChrisMorgan> As far as I can tell, it's got to be a bug, as such a thing as / doesn't match ident.
[03:57:54] <brson> doomlord: FromStr::from_str
[03:58:01] <brson> which is lame
[04:00:20] <doomlord> thanks
[04:00:53] *** Quits: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net) (Input/output error)
[04:02:00] <ChrisMorgan> At present, functions in a trait do *not* get put inside the implementing class as methods do, so you have to call it on the trait, possibly specifying the generic, as FromStr::from_str::<T>(...).
[04:02:46] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[04:04:04] *** Quits: mhordecki (mhordecki@moz-329F29A3.lightspeed.sntcca.sbcglobal.net) (Quit: mhordecki)
[04:04:36] *** Joins: mhordecki (mhordecki@moz-329F29A3.lightspeed.sntcca.sbcglobal.net)
[04:05:27] *** Quits: Earnestly (earnest@CAE8D902.48DC5685.39C00A7A.IP) (Ping timeout)
[04:07:39] *** Quits: sp3d (a@moz-49806493.dhcp.stls.mo.charter.com) (Ping timeout)
[04:09:46] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[04:09:46] <ChrisMorgan> Well, I tried something else briefly and that suggests that the approach I was using won't work anyway; I can't tack something onto the end of an identifier with no space in between, by the looks of it. That suggests that I'm going to need to generate Rust code rather than use Rust macros. :-(
[04:10:11] <strcat> rusti: let ab = 5; concat_idents!(a, b)
[04:10:13] -rusti- 5
[04:10:39] *** Quits: mhordecki (mhordecki@moz-329F29A3.lightspeed.sntcca.sbcglobal.net) (Quit: mhordecki)
[04:11:26] <ChrisMorgan> Oh!
[04:11:51] <brson> damn, strcat. you know it all
[04:12:00] <strcat> just about the only thing I know about macros ;p
[04:12:40] *** Quits: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net) (Quit: gavinb)
[04:13:01] <ChrisMorgan> Now all I need is for that spurious ambiguity to be fixed up...
[04:13:23] <strcat> rusti: let ab = 5; let x = concat_idents!(a, b); x
[04:13:24] -rusti- 5
[04:13:27] <strcat> oh that works now
[04:13:41] <strcat> if only I remembered what I needed it for :)
[04:13:48] <ChrisMorgan> rusti: stringify!(concat_idents!(a, b))
[04:13:49] -rusti- "concat_idents ! ( a , b )"
[04:13:50] <ChrisMorgan> :-(
[04:14:14] <strcat> huh.
[04:14:16] *** Joins: sp3d (a@moz-49806493.dhcp.stls.mo.charter.com)
[04:14:41] <ChrisMorgan> And if that be the case, then I can't use it after all :-(
[04:15:45] <ChrisMorgan> Macros are not evaluated inside a macro's arguments. They're passed as tokens.
[04:16:05] *** Joins: sw17ch (sw17ch@moz-7B9AAF7A.static.aldl.mi.charter.com)
[04:16:06] *** Quits: jgilbert (jgilbert@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[04:16:25] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[04:18:39] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[04:19:15] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[04:20:30] *** Quits: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Quit: zzzz)
[04:21:14] *** Joins: steven_is_false (user@C5B76363.1FF1EBF8.1ECA502.IP)
[04:21:46] *** Quits: tautologico (shung@9F01D096.92EA1F6.C27E1635.IP) (Quit: tautologico)
[04:22:50] *** Joins: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net)
[04:23:55] <steven_is_false> The code here http://gitorious.org/p-x/p-x/blobs/master/src/gl.rs#line465 where I find the offset from the beginning of a struct to it's member is ugly. Does Rust have a pointer to a member feature?
[04:24:33] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[04:24:51] <steven_is_false> I know C++ has pointers to members.
[04:25:03] *** Joins: infynyxx_ (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[04:25:15] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[04:26:13] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[04:26:43] *** Quits: infynyxx_ (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[04:27:43] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[04:28:30] *** Joins: tautologico (shung@9F01D096.92EA1F6.C27E1635.IP)
[04:29:45] *** Parts: pnathan (Adium@moz-BDC3EE62.tukw.qwest.net) ()
[04:31:23] <steven_is_false> Pointers to members are kind of ugly though.
[04:31:58] <strcat> rusti: let x = 5 as bool; (x, x)
[04:32:00] -rusti- (true, true)
[04:32:02] <strcat> rusti: let x = 5 as bool; (x, x == true)
[04:32:03] -rusti- (true, false)
[04:32:47] <steven_is_false> strcat: I thought enums were checked to see if they fit inside bounds?
[04:33:02] <strcat> bool isn't an enum
[04:33:36] <steven_is_false> bool isn't an enum!
[04:33:58] <steven_is_false> Shouldn't bool just be enum bool { true, false }?
[04:34:31] <engla> then it would be 8 bytes right now :)
[04:34:51] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[04:35:14] <steven_is_false> Oh, okay.
[04:35:24] <engla> it's not an argument
[04:35:34] <engla> rusti: enum Bool { True, False }; std::sys::size_of::<Bool>()
[04:35:35] -rusti- 8
[04:35:58] <engla> just a fact
[04:35:59] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[04:36:38] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[04:39:28] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[04:43:00] *** Quits: tautologico (shung@9F01D096.92EA1F6.C27E1635.IP) (Quit: tautologico)
[04:45:01] *** Joins: maikklein3 (maik@moz-C3D98781.dip0.t-ipconnect.de)
[04:45:40] *** Quits: chii (Mibbit@moz-77F78854.nycm.ny.dynamic.megapath.net) (Quit: http://www.mibbit.com ajax IRC Client)
[04:45:56] *** Parts: steven_is_false (user@C5B76363.1FF1EBF8.1ECA502.IP) (ERC Version 5.3 (IRC client for Emacs))
[04:46:45] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[04:48:24] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[04:48:24] *** ChanServ sets mode: +o brson
[04:48:25] *** Joins: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net)
[04:49:52] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[04:51:55] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[04:53:43] *** Quits: maikklein3 (maik@moz-C3D98781.dip0.t-ipconnect.de) (Ping timeout)
[04:53:58] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[04:58:40] *** Quits: mschifer (Adium@moz-42254FB1.hfc.comcastbusiness.net) (Quit: Leaving.)
[04:59:00] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[05:00:00] *** Quits: lmandel (lmandel@moz-AEAD2F61.dsl.bell.ca) (Quit: lmandel)
[05:00:08] *** Joins: maikklein3 (maik@moz-C3D98781.dip0.t-ipconnect.de)
[05:00:13] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[05:02:01] *** Quits: maikklein3 (maik@moz-C3D98781.dip0.t-ipconnect.de) (Ping timeout)
[05:03:19] *** Joins: paupau (textual@FFAF02D4.F5573215.F20F0C5A.IP)
[05:03:46] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[05:05:01] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[05:05:36] <mark_edward> rusti: #[deriving(ToStr] enum Test { Foo, Bar, Baz }; let x = Foo; x
[05:05:36] -rusti- <anon>:5:25: 5:26 error: incorrect close delimiter: `]`
[05:05:36] -rusti- <anon>:5          #[deriving(ToStr] enum Test { Foo, Bar, Baz }; let x = Foo; x
[05:05:36] -rusti-                                   ^
[05:05:36] -rusti- application terminated with error code 101
[05:05:44] <mark_edward> rusti: #[deriving(ToStr)] enum Test { Foo, Bar, Baz }; let x = Foo; x
[05:05:45] -rusti- Foo
[05:05:54] <mark_edward> rusti: #[deriving(ToStr)] enum Test { Foo, Bar, Baz }; let x = 5 as Test; x
[05:05:55] -rusti- <anon>:5:65: 5:74 error: non-scalar cast: `<VI0>` as `main::Test`
[05:05:55] -rusti- <anon>:5          #[deriving(ToStr)] enum Test { Foo, Bar, Baz }; let x = 5 as Test; x
[05:05:55] -rusti-                                                                           ^~~~~~~~~
[05:05:55] -rusti- error: aborting due to previous error
[05:05:56] -rusti- application terminated with error code 101
[05:06:20] <mark_edward> rusti: #[deriving(ToStr)] enum Test { Foo, Bar, Baz }; let x = unsafe{ 5 as Test}; x
[05:06:21] -rusti- <anon>:5:73: 5:82 error: non-scalar cast: `<VI0>` as `main::Test`
[05:06:21] -rusti- <anon>:5          #[deriving(ToStr)] enum Test { Foo, Bar, Baz }; let x = unsafe{ 5 as Test}; x
[05:06:21] -rusti-                                                                                   ^~~~~~~~~
[05:06:21] -rusti- error: aborting due to previous error
[05:06:22] -rusti- application terminated with error code 101
[05:06:53] <mark_edward> rusti: #[deriving(ToStr)] enum Test { Foo, Bar, Baz }; let x = unsafe{ 5u as Test}; x
[05:06:54] -rusti- <anon>:5:73: 5:83 error: non-scalar cast: `uint` as `main::Test`
[05:06:54] -rusti- <anon>:5          #[deriving(ToStr)] enum Test { Foo, Bar, Baz }; let x = unsafe{ 5u as Test}; x
[05:06:54] -rusti-                                                                                   ^~~~~~~~~~
[05:06:54] -rusti- error: aborting due to previous error
[05:06:55] -rusti- application terminated with error code 101
[05:07:26] <mark_edward> rusti: #[deriving(ToStr)] enum Test { Foo, Bar, Baz }; let x: Test = std::cast::transmute(5u); x
[05:07:27] -rusti- <anon>:5:71: 5:96 error: call to unsafe function requires unsafe function or block
[05:07:27] -rusti- <anon>:5          #[deriving(ToStr)] enum Test { Foo, Bar, Baz }; let x: Test = std::cast::transmute(5u); x
[05:07:27] -rusti-                                                                                 ^~~~~~~~~~~~~~~~~~~~~~~~~
[05:07:27] -rusti- error: aborting due to previous error
[05:07:28] -rusti- application terminated with error code 101
[05:07:41] <mark_edward> rusti: #[deriving(ToStr)] enum Test { Foo, Bar, Baz }; let x: Test = unsafe { std::cast::transmute(5u)} ; x
[05:07:42] -rusti- rust: task failed at 'enum value matched no variant', /build/rust-git/src/rust/src/libstd/repr.rs:520
[05:07:42] -rusti- rust: domain main @0xa99100 root task failed
[05:07:42] -rusti- application terminated with error code 101
[05:07:43] <brson> toddaaro: my patches for SingleThreaded on top of your branch does build all the way through 'make'. joy
[05:08:06] <brson> er, with newrt
[05:08:28] <brson> just a handful of test cases left to sort out before nuking the C++ rt
[05:09:28] <brson> I think the next thing to do is delete PortSet
[05:09:36] <brson> a lot of tests are blocked on it
[05:10:03] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[05:10:59] <toddaaro> brson: !!
[05:11:12] <toddaaro> brson: what did you do to run in main thread? or is that one of the blockers
[05:12:24] <brson> toddaaro: oh, I was just running 'make', which previously deadlocked generatic docs, not the test suite yet. that's one of the blockers still
[05:12:30] <brson> *generating
[05:12:39] <toddaaro> ah ok
[05:12:53] <brson> I have 14 run-pass tests that fail, excluding rt-start-on-main on your branch
[05:13:03] <brson> then there are probably a few benchmarks that rely on pipec
[05:13:09] <brson> pretty close though
[05:13:13] <toddaaro> yea, this is wonderful
[05:13:32] <toddaaro> I should be able to get that start-main issue figured out tomorrow
[05:13:58] <toddaaro> the current problem is that a task is being dropped without being destroyed
[05:14:17] <toddaaro> your comment about failing to deal with the Some(sched) return sounds like the problem actually
[05:14:31] <brson> i was hitting similar problems and handling that return value fixed it
[05:15:17] <ChrisMorgan> Given a mut value ~x, how do I get &mut x? &mut *x looks to be correctâ€”is it?
[05:16:24] <brson> ChrisMorgan: yes, assuming that x is stored in a mutable location
[05:16:36] <brson> ChrisMorgan: do you have any http client code yet?
[05:16:37] <toddaaro> brson: sounds promising, I'll focus on that tomorrow then
[05:16:38] <ChrisMorgan> What's the idea with &mut ~x vs. &mut x?
[05:16:40] <mark_edward> does Rust's >> and << behave any differently than C?
[05:16:49] <ChrisMorgan> brson: haven't tried it, but it'd be fairly easy to do at present
[05:17:19] <brson> ChrisMorgan: in the next couple weeks I'm going to want to rewrite servo's http handling and we're going to need a new http client based on rt::io
[05:17:42] <brson> probably I'm going to merge the new runtiem, delete the old runtime, port servo, then start working on destroying the old std::io
[05:18:11] <jmgrosen> any hope for file IO in the new runtime anytime soon?
[05:18:57] <brson> jmgrosen: yes. it's a priority. a lot of work still though, but it's part of replacing std::io
[05:19:07] <jmgrosen> brson, ok, great
[05:23:22] <ChrisMorgan> brson: Servo has been using joyent's HTTP parser; I've been working on my own instead of using that plus bindings as I *think* I can make it work better and faster in the long run, and more certainly more maintainable and simpler to compile, being all in Rust.
[05:23:44] <jmgrosen> ChrisMorgan, code?
[05:23:48] <ChrisMorgan> Also mine is designed in a way more amenable to the SPDY and HTTP/2.0 way of doing things, such as I have seen it.
[05:23:58] <ChrisMorgan> jmgrosen: at present, http://hg.chrismorgan.info/rusthttpserver
[05:24:04] <jmgrosen> thanks
[05:24:30] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[05:24:50] <paupau> wow, faster than joyent's? I thought they tuned the hell out of that, impressive
[05:25:00] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[05:25:23] *** Joins: infynyxx_ (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[05:25:27] <ChrisMorgan> paupau: it certainly isn't yet, but I think it can be
[05:26:01] <paupau> ChrisMorgan: now that I recall, they were more optimizing for RAM usage weren't they
[05:26:01] * ChrisMorgan has been enjoying experimenting today with an artistic masterpiece: http://sprunge.us/bOaS
[05:26:18] <paupau> ChrisMorgan: oh gosh
[05:26:39] *** Quits: bnicholson (bnicholson@moz-835D504A.rcmdva.fios.verizon.net) (Connection reset by peer)
[05:26:40] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[05:26:55] <ChrisMorgan> Not sure if that approach can end up faster or not. So experiment!
[05:26:59] <brson> ChrisMorgan: glad you're thinking about HTTP/2.0. we're interested in pushing on that
[05:27:01] <doomlord> anyone know off hand how to run the compiler without displaying any output (no warnigs) -   calling librustc from a tool - i've tried passing a nulled out 'emit'to driver::build_session_. i looked at sessopts, but that seems to relate to code generation
[05:27:03] *** Quits: infynyxx_ (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[05:27:47] * brson home
[05:27:48] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Quit: leaving)
[05:28:36] <ChrisMorgan> I had hoped to replace that masterpiece with the likes of http://sprunge.us/FRed, but have discovered that Rust macros aren't capable of turning that into what I need, at present.
[05:29:11] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.1)
[05:29:44] <ChrisMorgan> Specifically, they can't concatenate multiple identifiers (e.g. C and O) and then stringify them.
[05:29:54] <doomlord> i finally  have my 'libsyntax' based jump to definitoin tool working :)  .. but it runs the compiler and gets all the compile output .. i just want to see the definition i emit
[05:30:27] <ChrisMorgan> So I'm going back to code generation instead.
[05:30:45] <paupau> wouldn't it be faster to compare 32 or 64 bits at a time?
[05:31:23] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[05:31:23] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/kt4WVw
[05:31:23] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[05:31:31] <ChrisMorgan> paupau: hadn't thought of that. Prolliably.
[05:32:10] <ChrisMorgan> Really, I should just stop thinking about performance at present and get on with making a good HTTP server/client.
[05:34:21] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[05:34:21] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/DfLfkg
[05:34:21] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[05:34:22] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[05:34:22] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/EWrv2A
[05:34:22] <ghrust> 13rust/06auto 140ed8713 15Dmitry Ermolov: Modify test to expose issue #6492.
[05:34:22] <ghrust> 13rust/06auto 14ed0f014 15Dmitry Ermolov: Fix opts_str....
[05:34:22] <ghrust> 13rust/06auto 14ef7e945 15Dmitry Ermolov: Fix comment.
[05:34:23] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[05:39:26] *** Joins: tautologico (shung@9F01D096.92EA1F6.C27E1635.IP)
[05:39:57] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[05:40:50] <jmgrosen> what's wrong with this code? https://gist.github.com/jmgrosen/6119593
[05:42:56] <ChrisMorgan> jmgrosen: in that case, just use ~fn instead of &'a fn.
[05:43:51] <jmgrosen> ChrisMorgan, but then my data has to fulfill `Send`â€¦ which may be possible but is not ideal -- there's no way to get &'a fn working?
[05:44:39] <ChrisMorgan> True, true... and &Thing doesn't satisfy Send. Not sure about &'a fn, the message doesn't seem to make much sense to me.
[05:44:51] *** Quits: sw17ch (sw17ch@moz-7B9AAF7A.static.aldl.mi.charter.com) (Quit: sw17ch)
[05:45:06] <ChrisMorgan> rusti: struct Thing; fn f<'a>(thing: &'a Thing) -> &'a fn() { let cloned_thing = thing.clone(); || { let cloned_cloned_thing = cloned_thing.clone(); } }
[05:45:07] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/YVMN
[05:45:16] <ChrisMorgan> (That's the code you gave; for reference.)
[05:45:35] <jmgrosen> yeah
[05:45:35] *** Quits: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[05:45:36] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[05:46:21] <jmgrosen> is a ~fn sendable?
[05:46:37] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[05:47:04] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[05:47:27] <ChrisMorgan> I believe it is, provided the captured variables are.
[05:47:29] <jmgrosen> rusti: fn blah(f: ~fn()) -> g: ~fn() { || f() }
[05:47:29] -rusti- <anon>:5:33: 5:34 error: expected `{` but found `~`
[05:47:29] -rusti- <anon>:5          fn blah(f: ~fn()) -> g: ~fn() { || f() }
[05:47:30] -rusti-                                           ^
[05:47:30] -rusti- application terminated with error code 101
[05:47:43] <jmgrosen> oh
[05:47:53] <jmgrosen> fn (f: ~fn()) -> g: ~fn() { || f() }
[05:47:59] <jmgrosen> rusti: fn(f: ~fn()) -> g: ~fn() { || f() }
[05:47:59] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/iEhj
[05:48:01] <jmgrosen> ack
[05:48:12] <jmgrosen> rusti: fn blah(f: ~fn()) -> g: ~fn() { || f() }
[05:48:12] -rusti- <anon>:5:33: 5:34 error: expected `{` but found `~`
[05:48:13] -rusti- <anon>:5          fn blah(f: ~fn()) -> g: ~fn() { || f() }
[05:48:13] -rusti-                                           ^
[05:48:13] -rusti- application terminated with error code 101
[05:48:24] <jmgrosen> oh, derp
[05:48:30] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[05:48:32] <jmgrosen> rusti: fn blah(f: ~fn()) -> ~fn() { || f() }
[05:48:32] -rusti- ()
[05:48:34] <jmgrosen> ok
[05:49:31] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Quit: WeeChat 0.4.1)
[05:49:40] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[05:49:44] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[05:49:44] *** ChanServ sets mode: +o dherman
[05:50:04] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Quit: WeeChat 0.4.1)
[05:50:10] *** Quits: tautologico (shung@9F01D096.92EA1F6.C27E1635.IP) (Quit: tautologico)
[05:50:19] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[05:50:24] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Quit: james4k)
[05:54:18] *** Joins: tautologico (shung@9F01D096.92EA1F6.C27E1635.IP)
[05:54:42] *** Quits: pcwalton (pcwalton@moz-481A040C.hsd1.ca.comcast.net) (Quit: pcwalton)
[05:55:01] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[05:55:05] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Quit: james4k)
[05:55:46] *** Quits: tautologico (shung@9F01D096.92EA1F6.C27E1635.IP) (Quit: tautologico)
[05:57:02] *** Joins: jfbk (textual@moz-EEA9CFB3.nyc.res.rr.com)
[05:57:04] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[05:57:07] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Quit: james4k)
[05:58:51] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[05:59:22] <jensnockert> bjz: Was it you I discussed WAV with earlier?
[06:00:06] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[06:01:28] <jmgrosen> hm, how can i get Option<Foo> to Option<&'a Foo>â€¦ hmm...
[06:01:36] <jmgrosen> can anyone help?
[06:01:56] *** Joins: bheylin (brianheyli@moz-8255E94E.adsl.online.nl)
[06:02:14] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[06:03:37] *** Quits: bheylin (brianheyli@moz-8255E94E.adsl.online.nl) (Ping timeout)
[06:04:55] *** Quits: paupau (textual@FFAF02D4.F5573215.F20F0C5A.IP) (Ping timeout)
[06:11:33] <nmatsakis> pauls: ping
[06:11:58] <dbaupp> jmgrosen: what do you need it for?
[06:12:17] <dbaupp> jensnockert: you have discusssed wav with me at some point...
[06:12:48] <jensnockert> dbaupp: Just wanted to point out that my WAV mux/demux is available at https://github.com/jensnockert/aurora.rs
[06:13:01] <jensnockert> The PCM decoder isn't up though, since the interface isn't ready yet.
[06:14:37] *** Quits: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca) (Connection reset by peer)
[06:15:44] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[06:15:56] <dbaupp> jensnockert: awesome! (you're writing your thesis with rust?)
[06:16:04] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[06:16:08] <jensnockert> dbaupp: I wasn't, but since last week I amâ€¦
[06:16:25] <jensnockert> F*&k Python!
[06:16:26] <dbaupp> heh
[06:16:38] <Luqman> nmatsakis: what is the first def_id of typeck::method_trait ?
[06:16:57] <jmgrosen> jensnockert: i like python :(
[06:17:17] <nmatsakis> Luqman: the def-id of the method, I believe.
[06:17:37] <jmgrosen> dbaupp: i have a function that returns a Option<&'a Foo> and sometimes needs to call a function that returns a Option<Foo> and then return it
[06:17:51] <jensnockert> jmgrosen: I didn't hate Python before, but lately I have hit so many silly issues in SciPy / the Python stdlib that I would have to rewrite half of it anyhow.
[06:18:01] <dbaupp> jmgrosen: that's probably impossible
[06:18:11] <jmgrosen> dbaupp: oh :(
[06:18:27] <jmgrosen> jensnockert: well, frankly, rust is probably only going to be worse in terms of bugs
[06:18:28] *** Quits: KindOne (KindOne@F65A5124.5D2364C3.EC6A1518.IP) (Ping timeout)
[06:18:29] <dbaupp> jmgrosen: if 'a is the lifetime of one of the parameters passed in, then you can't magically make this new Foo last as long as it
[06:18:35] <jmgrosen> dbaupp: ok
[06:18:58] <dbaupp> jmgrosen: (it doesn't have the library bugs... because it doesn't have the libraries.)
[06:19:01] <jensnockert> jmgrosen: Yeah, but there I'll have to write everything myself, so I can at least blame my self.
[06:19:13] <jmgrosen> but compiler bugs D:
[06:19:31] <jensnockert> jmgrosen: Yeah, but there is also some novelty value.
[06:19:38] *** Quits: eatkinson (eatkinson@moz-AD233F1B.dia.static.qwest.net) (Quit: eatkinson)
[06:19:47] <jmgrosen> jensnockert: true, and the language is pretty cool
[06:20:13] <Luqman> nmatsakis: then I'm not sure how check::method::enforce_drop_trait_limitations works. since it seems like we use the def_id of struct as a key but it uses then it goes around and checks with the method's def_id ?
[06:20:24] *** Joins: doener (doener@moz-121949B3.unitymediagroup.de)
[06:20:44] *** Quits: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net) (Ping timeout)
[06:21:13] <tikue> rusti: let a = @mut 1; let b = Some(a); let c = b.clone(); let d = c.get(); *d += 1; a
[06:21:14] -rusti- @2
[06:21:20] <jensnockert> jmgrosen: And C interop is easier.
[06:21:33] <jmgrosen> jensnockert: really? i've found cffi to be awesome
[06:21:44] <jensnockert> jmgrosen: Than Rust?
[06:21:58] <jmgrosen> jensnockert: yeah, you just pass in the header, and you're off
[06:22:01] *** Quits: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk) (Ping timeout)
[06:22:06] <Luqman> nmatsakis: to be clear, i mean as a key in tcx.destructor_for_type
[06:22:19] *** Joins: bnicholson (bnicholson@moz-835D504A.rcmdva.fios.verizon.net)
[06:22:19] <jensnockert> (Well, cffi is pretty easy, but not when combined with SciPy)
[06:22:31] <jmgrosen> jensnockert: ah, i've only done a little scipy work
[06:22:59] *** Quits: dwhyte (dwhyte@1922756A.EDC594B0.7BF4A4B0.IP) (Quit: Leaving.)
[06:23:07] <nmatsakis> Luqman: I am confused. I imagine the key to that table is the def-id of the type def'n, but I'm not sure what thta has to do with method_trait
[06:23:17] <nmatsakis> Luqman: oh, wait,
[06:23:42] <jensnockert> jmgrosen: Numpy / Scipy is the only reason why I use Python, otherwise I would use Ruby for everything.
[06:23:54] <nmatsakis> Luqman: I'm sorry, *method_trait* ... in that csae, the def-id will be the def-id of the trait
[06:24:00] <nmatsakis> Luqman: that is used when the receive ris an object like @Trait
[06:24:12] <jmgrosen> jensnockert: interesting, i've always found python to be better, but to every person his own, i suppose
[06:24:34] *** Joins: eatkinson (eatkinson@moz-AD233F1B.dia.static.qwest.net)
[06:24:45] <jensnockert> jmgrosen: I think there are two camps, if you like Python, you dislike Ruby, and the reverse.
[06:24:45] *** Joins: KindOne (KindOne@F65A5124.5D2364C3.EC6A1518.IP)
[06:25:30] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[06:25:33] <jmgrosen> jensnockert: i suppose :P
[06:25:38] *** Joins: sebcrozet (sebcrozet@moz-F96421F3.w80-13.abo.wanadoo.fr)
[06:25:43] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[06:26:31] <Luqman> nmatsakis: so why bother checking that case in enforce_drop_trait_limitations ? since that'd def_id can't possibly be in the table then
[06:26:53] *** Quits: KindOne (KindOne@F65A5124.5D2364C3.EC6A1518.IP) (Ping timeout)
[06:27:10] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[06:27:23] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[06:27:31] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[06:27:49] <tikue> rusti: let a = @mut 1; let b = a.clone(); printfln!("%?", b);
[06:27:50] -rusti- @1
[06:27:50] -rusti- ()
[06:27:56] <sam113101> ruby is teh best
[06:27:56] <tikue> hey guys
[06:28:16] <tikue> does (@mut thing).clone() always give back the original ptr
[06:30:02] <nmatsakis> Luqman: I imagine one concern is @Drop, though I don't think that checking in that table would prevent that,
[06:30:15] <nmatsakis> Luqman: basically I agree it doesn't make sense
[06:31:22] <dbaupp> tikue: yes
[06:31:28] *** Joins: KindOne (KindOne@F65A5124.5D2364C3.EC6A1518.IP)
[06:31:41] <tikue> dbaupp: so if I want to copy the struct, I need to do (*thing).clone(), is that right?
[06:31:50] <dbaupp> tikue: yes
[06:31:54] <tikue> great, thank you :)
[06:33:56] <sebcrozet> tikue: If what you want is a deep copy, you can do: thing.deep_clone().
[06:34:29] <tikue> sebcrozet: I think I'll have to implement it myself. I need a specific clone that copies certain @mut ptrs and deep copies others :P
[06:36:04] *** Joins: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk)
[06:36:20] *** Joins: vosvos (vosvos@moz-9B8AD3A8.vinita.lt)
[06:36:28] <Luqman> nmatsakis: hmm, but how does that check even work? cause seemingly the def_id's it's checking for in the table wouldn't be there yet it does catch trying to call dro directly
[06:37:59] <ChrisMorgan> What is the difference between &~X and &X, and &mut ~X and &mut X?
[06:39:44] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[06:39:50] <doener> one points directly to an X, the other points to a unique pointer to an X
[06:41:07] <doener> &~X is pretty pointless. &mut ~X is useful when X is a string or vector type, because it lets you modify the size of the vector.
[06:41:45] <doener> e.g. with vec: &mut ~[int], you can add/remove elements, which you can't do with &mut [int]
[06:42:50] <doener> for other types like int, structs or really anything put str and vectors (which are special), &mut ~T is just as pointless as &~T
[06:43:12] *** Quits: eatkinson (eatkinson@moz-AD233F1B.dia.static.qwest.net) (Quit: eatkinson)
[06:45:55] <doener> hm, or maybe &mut ~T which T being a large struct to provide a move semantics in a callee that takes such an argument. Not 100% sure, too early in the morning
[06:48:24] <sebcrozet> Is there a function to get the size of a file?
[06:49:03] <ChrisMorgan> I was just struggling for some time with a tree structure, finally got it figured with &mut ~Branch having a children: ~[~Branch] argument; then it became apparent that &mut Branch would work after all and I was able to get rid of the ~ everywhere. All happy now, and I understand what I was doing wrong :-)
[07:01:14] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[07:04:02] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Connection reset by peer)
[07:05:14] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[07:08:02] *** Joins: heftig (heftig@327C8F30.EBDCAFC6.FEC4A986.IP)
[07:13:05] *** Quits: henrikhodne (henrikhodn@moz-F3A92B1C.hsd1.ca.comcast.net) (Ping timeout)
[07:13:27] *** Joins: Uther (Instantbir@moz-1B244B05.hfc.dyn.abo.bbox.fr)
[07:19:25] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[07:19:25] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/EWrv2A
[07:19:25] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[07:19:28] <ChrisMorgan> I want a macro to turn something like { A => B, C => D } into [("A", "B"), ("C", "D")], but as far as I can tell it can't be done in macros, as one needs a recursive part, but a macro can only return one thing. Is there any workaround? (e.g. a cons-style vector literal)
[07:19:39] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[07:22:22] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[07:22:22] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/rV625Q
[07:22:22] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[07:22:23] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[07:22:23] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/4rPXnw
[07:22:23] <ghrust> 13rust/06auto 14de0092c 15Gareth Smith: No longer treat \ as a path separator on posix systems.
[07:22:24] <ghrust> 13rust/06auto 148a737b5 15bors: auto merge of #8138 : Dretch/rust/posix-path-push, r=pcwalton...
[07:22:24] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[07:23:01] <dbaupp> rusti: macro_rules! foo(($(a:expr => $b:expr),*) => { [$( ($a, $b) ),*] }) foo!(1 => 2, 3 => 4)
[07:23:02] -rusti- <anon>:5:82: 5:83 error: No rules expected the token: 1
[07:23:02] -rusti- <anon>:5          macro_rules! foo(($(a:expr => $b:expr),*) => { [$( ($a, $b) ),*] }) foo!(1 => 2, 3 => 4)
[07:23:02] -rusti-                                                                                            ^
[07:23:02] -rusti- application terminated with error code 101
[07:23:59] * ChrisMorgan was clearly not thinking properly
[07:24:01] <ChrisMorgan> Thanks, dbaupp
[07:25:07] *** Joins: huseby (huseby@moz-4E8C421A.husebyhome.com)
[07:25:30] *** Joins: Ms2ger (Ms2ger@moz-BA3429A8.adsl-dyn.isp.belgacom.be)
[07:25:58] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[07:26:03] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[07:27:39] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[07:27:44] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[07:28:42] *** Quits: robarnold (rob@BD56354E.DB510C09.6E370BFC.IP) (Ping timeout)
[07:32:39] <ChrisMorgan> Good, that's all working now. I decided that, needing to generate code (macros not being up to the task) I would this time generate the code with Rust rather than Python.
[07:32:47] *** Joins: bheylin (brianheyli@moz-3D24C757.static.chello.nl)
[07:33:14] *** Quits: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net) (Quit: eholk)
[07:36:27] <ChrisMorgan> How would one create a string with N spaces in it? My attempt:
[07:36:27] <ChrisMorgan> rusti: std::str::from_chars(std::vec::from_elem(4, 'x'))
[07:36:28] -rusti- ~"xxxx"
[07:37:15] <dbaupp> rusti: " ".repeat(4)
[07:37:15] -rusti- ~"    "
[07:37:25] <dbaupp> ChrisMorgan: ^
[07:37:33] <ChrisMorgan> There, I knew there would be a way :-)
[07:38:33] *** Quits: bheylin (brianheyli@moz-3D24C757.static.chello.nl) (Quit: bheylin)
[07:39:11] <mark_edward> are there any timer modules in Rust? i heard someone was working on them?
[07:39:21] <dbaupp> mark_edward: "timer"?
[07:39:31] *** Quits: Jesin (Jessin_@moz-1B1307FF.eecs.lehigh.edu) (Quit: Leaving)
[07:39:59] <mark_edward> dbaupp: like a timer say with a period of 10 secs, i was think it'd be really cool coupled with iterators. 
[07:40:02] *** Joins: henrikhodne (henrikhodn@moz-F3A92B1C.hsd1.ca.comcast.net)
[07:40:25] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[07:40:34] <Eridius> mark_edward: unless you plan on having the .next() function sleep the task if the timer hasn't gone off yet, I'm not sure how you'd integrate timers with iterators
[07:40:52] <mark_edward> Eridius: yup, that's what i was thinking
[07:41:12] <Eridius> mark_edward: it would make sense to have the timer send a value to a port every time it fires
[07:41:22] <dbaupp> mark_edward: given `sleep` it's pretty easy to write your own.
[07:41:30] <Eridius> which is basically how Go's timers work (although they don't send a second value if you haven't consumed the first)
[07:41:34] <dbaupp> (and there's sleep in newrt, not in the old one.)
[07:42:20] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[07:42:20] <mark_edward> let t = Timer::new(60000); for t.iter().advance | i| { printfln!("I started %u sseconds ago", i/1000); }
[07:42:27] <mark_edward> that sounds cool
[07:43:16] <mark_edward> i did math wrong, but that's the basic idea
[07:43:33] <mark_edward> dbaupp: does newrt fully replace oldrt yet?
[07:43:36] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[07:43:44] <ChrisMorgan> File I/O still ain't there.
[07:44:06] <mark_edward> ChrisMorgan: anything else missing?
[07:44:06] <Eridius> pfft, who needs that?
[07:44:11] * ChrisMorgan doesn't know
[07:44:39] <dbaupp> mark_edward: apparently it just recently got good enough to run the whole bootstrap (or something... I'm not sure how they got around the lack of file-io)
[07:44:53] <dbaupp> mark_edward: and is getting very close to replacing oldrt
[07:44:56] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[07:45:07] <mark_edward> dbaupp: nice! will it be in for 0.8?
[07:45:18] <dbaupp> mark_edward: presumably
[07:45:29] * dbaupp doesn't actually know
[07:49:06] <doener> wasn't there a lint that warns about ~"Foo" that could be "Foo"?
[07:49:52] <dbaupp> doener: for some cases, yes
[07:50:21] <dbaupp> rusti: fn foo(_: &str) {} foo(~"foo)
[07:50:21] -rusti- <anon>:7:19: 7:20 error: unknown start of token: 63
[07:50:21] -rusti- <anon>:7     println(fmt!("%?", r))
[07:50:22] -rusti-                             ^
[07:50:22] -rusti- application terminated with error code 101
[07:50:59] <dbaupp> rusti: fn foo(_: &str) {} foo(~"foo")
[07:50:59] -rusti- <anon>:5:32: 5:38 warning: unnecessary allocation, the sigil can be removed [-W unnecessary-allocation (default)]
[07:50:59] -rusti- <anon>:5          fn foo(_: &str) {} foo(~"foo")
[07:51:00] -rusti-                                          ^~~~~~
[07:51:00] -rusti- ()
[07:54:26] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[07:56:35] <doener> dbaupp: wondered because it doesn't seem to warn for ~"foo" + "bar"
[07:57:02] <dbaupp> doener: yeah, I think that the initial ~ used to be required, but now it's not.
[07:57:14] <dbaupp> rusti: "foo" + "bar"
[07:57:15] -rusti- ~"foobar"
[07:59:05] <doener> dbaupp: removing that from _only_ the assert! expansion strips 3% of the lines from libstd.ll (unoptimized)
[07:59:07] *** Joins: z0w0 (zack@moz-E12708D5.lns6.woo.bigpond.net.au)
[07:59:20] <doener> 410459 => 397264
[07:59:30] <dbaupp> doener: is there a + in assert?
[07:59:43] *** Quits: barosl (barosl@E287D94F.C81E10FB.7544CABF.IP) (Quit: ëžœë¤ì€ ì‡ í‡´í–ˆìŠµë‹ˆë‹¤.)
[07:59:57] <dbaupp> oh, so there is
[07:59:59] <doener> dbaupp: for assert!s that don't provide a message
[08:00:16] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[08:00:39] <dbaupp> there's a whole pile of `~"..." +`'s, fwiw
[08:00:53] <dbaupp> doener: (but that's a pretty nice fix!)
[08:01:02] <doener> yeah, most aren't as "critical" though
[08:01:10] *** Quits: henrikhodne (henrikhodn@moz-F3A92B1C.hsd1.ca.comcast.net) (Ping timeout)
[08:01:17] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[08:01:19] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[08:01:34] <doener> i.e. they don't spread but just cause one small local annoyance
[08:01:38] <dbaupp> yeah
[08:02:36] <doener> heh, much less assertions in librustc, just .5% removed
[08:03:21] <doener> d'oh... I tested with an old version that completely strips the prefix
[08:03:26] <doener> so the numbers are off
[08:08:22] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[08:15:15] <doener> not much though, 399907 lines after
[08:15:31] <nmatsakis> Luqman: I don't think that check would work for @Drop, no, but I am not 100% sure, I havne't read into the code in that table very closely
[08:15:41] <nmatsakis> Luqman: that is I am not 100% sure the table's contents are
[08:15:58] <Luqman> nmatsakis: i don't mean for @Drop, i mean in general
[08:17:20] <Luqman> because the only place we insert into the table it's something like ty_struct(def_id, _) => { // insert def_id into table ... }
[08:17:56] <doener> dbaupp: r? https://github.com/mozilla/rust/pull/8150
[08:18:00] <dbaupp> doener: do you reckon you could add 93 lines?
[08:18:04] *** Joins: Egbert9e9 (Egbert9e9@moz-366B5D68.inter.net.il)
[08:18:47] *** Quits: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net) (Quit: tikue)
[08:19:10] <dbaupp> doener: we really need `expand_inside!(concat_strings!("...", stringify!(...)))`, or something, because that string is purely compile-time.
[08:19:23] <doener> dbaupp: they'd be gone soon. I'll finish my general retptr alloca removal PR this evening, and will follow up with one that directly inlines functions that do nothing but return a constant
[08:19:55] <doener> dbaupp: yeah, compile time evaluation for string concat would be awesome. Like C's "foo" "bar"
[08:20:09] <doener> ... which gets translated the same as "foobar"
[08:20:12] <dbaupp> yeah
[08:20:22] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[08:20:24] * dbaupp considers implementing it
[08:20:41] * dbaupp needs to focus on his current work
[08:20:52] <doener> I'd really prefer that to be done for plain + instead of requiring a macro
[08:21:01] *** Joins: azita (Azita@35897086.4DC28F20.FAF22AF7.IP)
[08:21:19] <dbaupp> yeah, it'd be much nicer: add it to const_eval?
[08:21:42] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[08:21:55] <dbaupp> rusti: static foo: &'static str = "foo" + "bar";
[08:21:56] -rusti- <anon>:5:36: 5:49 error: mismatched types: expected `&'static str` but found `~str` (str storage differs: expected &'static  but found ~)
[08:21:56] -rusti- <anon>:5          static foo: &'static str = "foo" + "bar";
[08:21:56] -rusti-                                              ^~~~~~~~~~~~~
[08:21:57] -rusti- error: aborting due to previous error
[08:21:57] -rusti- application terminated with error code 101
[08:23:35] *** Joins: barosl (barosl@E287D94F.C81E10FB.7544CABF.IP)
[08:26:23] *** Joins: scott (scott@moz-9B0C6BE2.ss.shawcable.net)
[08:26:24] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[08:26:26] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[08:27:54] *** Joins: relrod (relrod@moz-AABB5D31.redhat.com)
[08:28:04] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[08:28:06] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[08:29:42] *** Joins: ldunn (username@moz-94CB0FA.cyberius.net)
[08:30:59] *** Joins: CarpNet (ac@moz-FD24B77.sohonet.co.uk)
[08:31:31] *** Quits: azita (Azita@35897086.4DC28F20.FAF22AF7.IP) (Quit: azita)
[08:34:14] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[08:35:14] <ChrisMorgan> rusti: let x = || { x() };  // No recursive closures? :-(
[08:35:14] -rusti- <anon>:5:22: 5:23 error: unresolved name `x`.
[08:35:15] -rusti- <anon>:5          let x = || { x() };  // No recursive closures? :-(
[08:35:15] -rusti-                                ^
[08:35:15] -rusti- error: aborting due to previous error
[08:35:15] -rusti- application terminated with error code 101
[08:36:20] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[08:36:37] *** Quits: mcclurmc (mcclurmc@moz-8D61EFD1.cable.virginmedia.com) (Ping timeout)
[08:37:50] <dbaupp> ChrisMorgan: http://smallcultfollowing.com/babysteps/blog/2013/04/30/the-case-of-the-recurring-closure/
[08:38:03] *** Joins: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk)
[08:38:08] <dbaupp> ChrisMorgan: (that code is never valid: the name introduced by `let` only "exists" after the let.)
[08:38:20] *** Joins: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[08:38:32] *** Joins: pyrac (pyrac@moz-F28B7CAD.w90-55.abo.wanadoo.fr)
[08:39:20] <dbaupp> rusti: let mut x = @mut None; *x = Some(|| x.unwrap()()); x.unwrap()()
[08:39:21] -rusti- <anon>:5:45: 5:56 error: the type of this value must be known in this context
[08:39:21] -rusti- <anon>:5          let mut x = @mut None; *x = Some(|| x.unwrap()()); x.unwrap()()
[08:39:21] -rusti-                                                       ^~~~~~~~~~~
[08:39:21] -rusti- error: aborting due to previous error
[08:39:22] -rusti- application terminated with error code 101
[08:39:34] <dbaupp> rusti: let mut x: @mut Option<@fn()> = @mut None; *x = Some(|| x.unwrap()()); x.unwrap()()
[08:39:35] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/KhOT
[08:40:12] *** Quits: pyrac (pyrac@moz-F28B7CAD.w90-55.abo.wanadoo.fr) (Ping timeout)
[08:40:23] <dbaupp> rusti: let x: @mut Option<@fn()> = @mut None; let y: @fn() = || x.unwrap()(); *x = Some(y); x.unwrap()()
[08:40:24] -rusti- application terminated abnormally with signal 9 (Killed)
[08:40:46] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[08:41:02] <dbaupp> rusti: let x: @mut Option<@fn()> = @mut None; let y: @fn() = || { print("."); x.unwrap()() }; *x = Some(y); x.unwrap()()
[08:41:05] -rusti- line longer than 10000 characters, bailing out
[08:41:05] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[08:44:21] *** Joins: pyrac (pyrac@moz-F28B7CAD.w90-55.abo.wanadoo.fr)
[08:45:34] <Thiez> bblum: in the 'global little-locks (change_dir_lock,global_args_lock) are sloppy and wrong' issue, you suggest lazy initialization for locks
[08:47:51] <Thiez> I wonder if that is really worth it? Are the so-called little-locks not so little after all, and do we have types where the lock (although present) is never used is most program executions?
[08:50:03] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[08:52:51] <Thiez> (also you leak memory when your compare_and_swap fails)
[08:53:30] *** Joins: azita (Azita@87C1F78E.1DE10CA8.D8E68FF6.IP)
[09:05:09] *** Quits: scott (scott@moz-9B0C6BE2.ss.shawcable.net) (Quit: Leaving)
[09:07:28] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[09:07:28] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/4rPXnw
[09:07:28] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[09:08:20] *** Quits: pyrac (pyrac@moz-F28B7CAD.w90-55.abo.wanadoo.fr) (Quit: pyrac)
[09:10:25] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[09:10:25] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/1T_vxw
[09:10:25] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[09:10:28] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[09:10:28] <ghrust> 01[13rust01] 15bors pushed 10 new commits to 06auto: 02http://git.io/9D9fnw
[09:10:28] <ghrust> 13rust/06auto 147265cc6 15Brian Anderson: std::rt: Use 2MB stacks...
[09:10:28] <ghrust> 13rust/06auto 140144c83 15Brian Anderson: std::rt: Change Thread interface to require an explicit join...
[09:10:28] <ghrust> 13rust/06auto 14cb9ee7f 15Brian Anderson: std: Remove ManualThreads spawn mode
[09:10:30] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[09:18:51] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[09:26:27] *** Quits: busylizzy (lisa@85228838.12D0DC84.211374C4.IP) (Ping timeout)
[09:26:43] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[09:26:55] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[09:27:41] *** Joins: busylizzy (lisa@85228838.12D0DC84.211374C4.IP)
[09:28:23] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[09:28:37] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[09:32:20] *** Joins: pyrac (pyrac@moz-F28B7CAD.w90-55.abo.wanadoo.fr)
[09:33:21] *** Joins: BitPuffin (quassel@moz-49828767.cust.tele2.se)
[09:38:48] *** Quits: azita (Azita@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: azita)
[09:40:15] <cmr> bjz: rustpkg is quite usable now, although I find its  workspace concept really weird
[09:45:57] *** Joins: azita (Azita@87C1F78E.1DE10CA8.D8E68FF6.IP)
[09:47:22] <klutzy> I'm curious if anyone is using rustpkg workspace structure in git repo
[09:47:47] <cmr> klutzy: workspace is where packages go, not the structure of individual packages.
[09:48:27] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[09:48:57] <cmr> (although it can be both)
[09:51:14] <klutzy> cmr: so it's sufficient to have $GIT_DIR/lib.rs? I think I've got wrong between "package structure" and "workspace structure"
[09:52:15] <cmr> klutzy: yes.
[09:52:23] <cmr> As long as $GIT_DIR is in a workspace
[09:54:26] *** Quits: BitPuffin (quassel@moz-49828767.cust.tele2.se) (Ping timeout)
[09:57:09] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[09:57:35] *** Quits: heftig (heftig@327C8F30.EBDCAFC6.FEC4A986.IP) (Ping timeout)
[09:58:11] *** Joins: heftig (heftig@6835D69C.6FC4DE2F.FEC4A986.IP)
[09:58:38] *** Quits: igl (igl@moz-D82ABDB9.adsl.alicedsl.de) (Ping timeout)
[09:59:15] *** Joins: igl (igl@moz-6DEF9A2D.adsl.alicedsl.de)
[09:59:34] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[10:00:46] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[10:00:59] *** Joins: BitPuffin (quassel@moz-49828767.cust.tele2.se)
[10:01:28] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[10:06:22] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[10:09:47] <doomlord> cmr i got something working for a jump to def tool... doesn't handle much yet, but seems to get function & struct defs ok
[10:10:31] <cmr> doomlord: btw I meant to ask: can it be used to generate accurate ctags files?
[10:10:44] <doomlord> i should look into that for sure
[10:11:04] <cmr> our current ctags is hackish based on regex, would be cool to have real ctags :)
[10:11:22] <doomlord> what doesn't yet work is defs outside of the crate , and struct members , frustratingly dont work either,
[10:11:41] <doomlord> i need to look how the node-ids work there
[10:13:16] <doomlord> i have something i can  call from gedit that works like my grep hacks,  a json dump of the node spans table , and a limited interactive mode..  now you mention it a ctags generator is probably a good thing to add
[10:13:54] <doomlord> i also need to figure out how to get references outside of the current crate, someone gave me an example that might help
[10:14:37] <cmr> I wonder if you could reconstruct the source from debuginfo and actually jump to it
[10:15:02] <cmr> that's wandering into IDE land... probably usefful as an eclipse plugin or something
[10:15:03] <doomlord> i am wondering how much i can pretty print from the ast -
[10:15:04] *** Quits: Uther (Instantbir@moz-1B244B05.hfc.dyn.abo.bbox.fr) (Ping timeout)
[10:15:19] <cmr> in theory you can perfectly reconstruct source from the ast
[10:15:36] <doomlord> something else i'd be curious to try - but might be  a bigger task - is one of those hyperlinked html generators
[10:15:43] <cmr> that is how --pretty=expanded
[10:15:54] <cmr> yeah, like the linux kernel crose-reference thing?
[10:16:01] <cmr> *cross
[10:16:32] <doomlord> i think so, the one i just found for c++ was 'woboq code browser' ..
[10:16:46] <doomlord> i wondered how much that would overlap with what's planned for rustdoc
[10:18:21] <cmr> I don't plan for anything like it, although maybe the intermediate json could be used for it
[10:18:26] <cmr> http://lxr.linux.no/#linux+v3.10.4/arch/x86/kernel/audit_64.c is what I was thinking of
[10:18:33] <cmr> Comparing to http://code.woboq.org/linux/linux/arch/x86/kernel/audit_64.c.html, weboq is much better
[10:18:42] <doomlord> https://github.com/dobkeratops/rustfind << my current code is on github
[10:19:34] <doomlord> i've chromocoded the hell out of my text editor (gedit), its pleasing how much the syntax lets you do , it has made looking at rust source more pleasant..
[10:19:55] <cmr> Screenshot? :D
[10:20:06] <doomlord> lets see
[10:20:22] <doomlord> 1min
[10:20:33] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[10:21:47] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[10:22:16] *** Quits: heftig (heftig@6835D69C.6FC4DE2F.FEC4A986.IP) (Ping timeout)
[10:22:34] *** Joins: heftig (heftig@327C8F30.EBDCAFC6.FEC4A986.IP)
[10:24:35] *** Quits: heftig (heftig@327C8F30.EBDCAFC6.FEC4A986.IP) (Ping timeout)
[10:27:03] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[10:27:37] <doomlord> http://i.imgur.com/TsHPFvp.jpg
[10:27:41] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[10:28:01] <cmr> wow, very nice
[10:28:21] <doomlord> recognizes type params , types after : ....  , and thanks to struct/trait/impl/fn, nice bold major headings
[10:28:43] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[10:28:45] <doomlord> an html pretty print based on the ast could go further (and have less bugs :) )
[10:29:21] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[10:32:30] *** Joins: Earnestly (earnest@CAE8D902.48DC5685.39C00A7A.IP)
[10:36:23] *** Quits: barosl (barosl@E287D94F.C81E10FB.7544CABF.IP) (Quit: ëžœë¤ì€ ì‡ í‡´í–ˆìŠµë‹ˆë‹¤.)
[10:39:29] *** Joins: sk (sk@25B0E51B.DB3C9D.78DD174B.IP)
[10:40:19] <cmr> doomlord: do you think that with some polish this tool could be included as `rust find`?
[10:40:21] *** Joins: recrack (Mibbit@B4104EBB.3CC170B1.1E14B209.IP)
[10:41:16] <ChrisMorgan> doomlord: sounds like you've made your syntax highlighting almost as good as the Vim stuff. ;-)
[10:41:23] <doomlord> yeah there's lots of polish remaining , i only just got it workable
[10:41:47] <doomlord> heh i just can't do vim sadly
[10:42:33] <doomlord> 10+ years of microsoft style bindigs.. it permanently burned in 
[10:42:50] *** Quits: StarLight (StarLight@moz-3C7847AE.dynamic.avangarddsl.ru) (Ping timeout)
[10:43:05] <cmr> I've been quite pleased with recent visual studio's keybindings
[10:43:10] <cmr> customizable, with chords
[10:43:20] <cmr> the text editors pales in comparison to vim, but who uses VS for the text editor? :)
[10:43:40] *** Quits: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk) (Ping timeout)
[10:43:58] <doomlord> is vim seriously better than VS - what are the features that set it apart
[10:43:59] <ChrisMorgan> I'm probably just up to 10 years of Vim, and that by the age of 21. I was fortunate enough to grow up with it.
[10:44:52] *** Joins: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk)
[10:45:01] <ChrisMorgan> doomlord: things like IntelliSense are pretty good; Vim doesn't have anything as good as that really. Vim isn't an IDE; this is by design.
[10:45:57] <ChrisMorgan> But when it comes to editing text, Vim is absolutely unparalleledâ€”by far the most efficient text editor you'll find (emacs is more powerful, but fairly verbose)
[10:46:54] <cmr> modal editing, undo tree, easy plugins, awesome regexps, easy automation are my biggies
[10:46:56] <ChrisMorgan> But it really does take *years* to be a Vim master, and even then you'll still find new things occasionally. (I would consider myself to be in that category of Vim master.)
[10:47:16] *** Joins: StarLight (StarLight@moz-2FCDA2C1.dynamic.avangarddsl.ru)
[10:47:16] <doomlord> i've put quite a bit of time into emacs - it can do a lot i really like (eg tiled windowing with focus follows mouse).. but ultimately a couple of irritating bindings always make me uncomfortable. i end up going to something simple like gedit just because its got ctrl-xcv all the way through
[10:48:01] <doomlord> i do like the idea of both emacs & vi though. i *want* to like them
[10:49:09] <ChrisMorgan> cmr: interesting you should mention the undo tree. Note that I haven't used anything like Gundo or undotree, but I don't tend to feel that it would be that useful to me in general.
[10:49:23] <cmr> ChrisMorgan: I make lots of mistakes :)
[10:50:22] * ChrisMorgan wishes (mostly) Vim used PCRE rather than its own brand of regular expressions
[10:50:24] <doomlord> its neat that the likes of VS can show you types under the cursor with auto. 
[10:50:34] <cmr> yeah
[10:50:40] <cmr> I've been eying eclim
[10:50:44] <cmr> it integrates vim with eclipse
[10:51:31] <ChrisMorgan> Something that must be remembered in such cases is that most editors could do things like that if only the language tooling and integration is there. Vim can actually do a tolerable job of that sort of thing.
[10:51:37] <cmr> but most of the time where I want an IDE is with large projects that don't have an IDE project file anyway
[10:51:44] <cmr> and ctags gets me by most of the time
[10:55:25] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[10:55:25] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/9D9fnw
[10:55:25] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[10:58:24] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[10:58:25] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/KqNgwQ
[10:58:25] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[10:58:25] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[10:58:25] <ghrust> 01[13rust01] 15bors pushed 7 new commits to 06auto: 02http://git.io/WLping
[10:58:25] <ghrust> 13rust/06auto 14a8840d7 15Graydon Hoare: syntax: add 'in' keyword
[10:58:25] <ghrust> 13rust/06auto 149a2d183 15Graydon Hoare: syntax: add temporary 'foreach' keyword.
[10:58:25] <ghrust> 13rust/06auto 14c29e9fb 15Graydon Hoare: syntax: implement foreach .. in .. { .. } via desugaring.
[10:58:26] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[11:00:53] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[11:03:01] *** Quits: Earnestly (earnest@CAE8D902.48DC5685.39C00A7A.IP) (Ping timeout)
[11:03:06] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[11:07:05] <Ms2ger> Hear, hear
[11:08:20] <ChrisMorgan> cmr: do you know how ctags is used with Rust? Have you linked it up with Vim?
[11:08:25] *** Joins: Earnestly (earnest@CAE8D902.48DC5685.39C00A7A.IP)
[11:08:35] <cmr> ChrisMorgan: https://github.com/mozilla/rust/blob/master/src/etc/ctags.rust
[11:08:46] <cmr> generates a tags file as usual
[11:08:47] <ChrisMorgan> cmr: alas, that doesn't explain to me how it's used
[11:08:55] * ChrisMorgan hasn't actually ever used ctags directly
[11:09:46] <SimonSapin> Are bounds checks optimized away when indexing a vector of size 256 with an u8?
[11:09:57] <dbaupp> SimonSapin: unlikely
[11:10:02] <cmr> SimonSapin: you'd have to check the optimized IR
[11:10:06] * dbaupp checks
[11:10:11] <cmr> I don't think llvm does range analysis though
[11:10:22] *** Joins: sanxiyn (tinuviel@858F408C.B797260D.EF43EC08.IP)
[11:10:26] <SimonSapin> dbaupp: how do you check?
[11:10:43] <sanxiyn> #8039 (Add some more atomic operations) broke ARM build
[11:10:48] <sanxiyn> https://github.com/mozilla/rust/pull/8151
[11:10:51] <sanxiyn> (fix)
[11:10:56] <cmr> ChrisMorgan: I don't remember... there's some option you give ctags to use that ctags.rust file, and it does its thing with it
[11:11:02] *** Quits: azita (Azita@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: azita)
[11:11:33] <ChrisMorgan> Bah, std::rt::io::stdio is all just dummy stuff with fail! everywhere.
[11:12:06] <cmr> sanxiyn: do you intend to add them back in?
[11:13:07] <sanxiyn> cmr: No, not until there are real uses (even then, I'd like LLVM to be able to lower these instead of asserting when building for architectures without atomic instructions)
[11:13:20] <dbaupp> SimonSapin: by writing a function (e.g. fn f(i: u8) -> int { let a = [0, .. 256]; a[i] }) and compiling it with `-O --lib --emit-llvm -S`
[11:13:30] <dbaupp> SimonSapin: (and looking at the .ll file that creates.)
[11:13:56] <sanxiyn> That is, atomicrmw add is ok. If the architecture supports atomics, LLVM uses that. If the architecture doesn't, LLVM uses compiler runtime function which is less efficient, but it still builds.
[11:14:15] <sanxiyn> But atomicrmw max is different from atomicrmw add. LLVM asserts when there is no atomics support
[11:14:41] <sanxiyn> (By the way, atomicrmw add *is* currently used in the new runtime)
[11:16:28] <dbaupp> SimonSapin: in any case it seems that it does, [0, ..255] has a call to `fail_bounds_check`, [0, .. 256] doesn't.
[11:16:41] <SimonSapin> cool
[11:16:55] <SimonSapin> although itâ€™s probably premature for me to worry about this
[11:17:09] <cmr> It's never too early to prematurely optimize!
[11:17:15] *** Joins: sw17ch (sw17ch@moz-7B9AAF7A.static.aldl.mi.charter.com)
[11:17:52] <dbaupp> yeah, the bounds checks get branch-predicted reasonably well in loops, so they aren't entirely horrible.
[11:20:19] <doomlord> i wonder if you could  handle some cases of indexing safely with a sort of iterator or lazy result that references an original collectoin with indices
[11:21:09] <doomlord> eg, "somearray.filter(predicate) -> (&somearray,~[int] /* its known these indices are safe..*/  )
[11:21:33] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[11:21:35] <cmr> doomlord: how does that improve on bounds checks?
[11:22:06] <dbaupp> doomlord: like the iterators we currently have?
[11:22:39] <doomlord> the cases of indexing i've encountered in graphics are often static datastructures - could those sorts of things be bounds checked on creation..
[11:23:39] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[11:24:18] <ChrisMorgan> Question: would it be welcome for me make std::rt::io::stdio actually work, using std::io::{stdin, stdout, stderr}?
[11:24:39] <doomlord> the classic case is an array of vertices with polygon indices... its a resource, not changing perhaps one could setsomething up.. create an immutable index-array for another array of immutable length..
[11:24:54] <cmr> ChrisMorgan: you'd have to ask brson but my response is "yuck, no"
[11:25:00] *** Joins: jclements (jclements@moz-9933A8FC.ngn.east.myfairpoint.net)
[11:25:24] <sanxiyn> doomlord: Not sure how to implement that...
[11:25:25] <doomlord> i realise the iterators eliminate the need for indexing for most dynamic cases..
[11:25:25] <ChrisMorgan> cmr: it allows people to start *using* it, that's my only point with it.
[11:25:42] <cmr> ChrisMorgan: right, but it'd be implemented on top of the old rt that brson is desparately trying to remove
[11:25:45] <cde> does rust support immutable fast vectors like clojure?
[11:26:03] <jclements> anyone here have experience using amazon EC2 *windows* instances to compile rust?
[11:26:06] <ChrisMorgan> As it is, it's all just stubs, and bad stubs at thatâ€”e.g. fn stderr() -> StdReader
[11:26:07] <sanxiyn> doomlord: Seems to need some sort of ranged integer type?
[11:26:31] *** Quits: _1126 (1126@moz-83D60E55.lileth.net) (Ping timeout)
[11:26:39] <cmr> jclements: I can't imagine it's that different than using a real windows box?
[11:26:41] <dbaupp> jclements: doesn't the try branch work? (I *think* pushing to it will automatically start up the builders.)
[11:26:53] <doomlord> maybe. seems like the borrow checker might help,ie. 'create this index buffer that borrows a pointer to the associated vertex buffer **which is now frozen..**'
[11:26:54] <cmr> dbaupp: no, and it's been broken for windows for quite some time
[11:27:04] <dbaupp> cmr: oh :(
[11:27:07] <ChrisMorgan> cmr: I think it's reasonable to say that std::io::std* won't be going away until std::rt::io::stdio is ready!
[11:27:11] <jclements> dbaupp: well, I'm trying to diagnose a specific build failure.
[11:27:15] <cmr> ChrisMorgan: this is true
[11:27:42] <dbaupp> jclements: yeah, the one with the ident->name and the hygiene pull requests?
[11:27:50] <sanxiyn> doomlord: Eh... weren't we talking about indices, not pointers? Not sure how borrow checker helps there.
[11:27:52] <doomlord> i realize one can just fallback to C++ style techniques and wrap them , i'd be perfectly happy to use a named accessor for unsafe indexing
[11:27:59] <jclements> dbaupp: yes.  It's got strange things going on that I don't understand.
[11:28:09] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[11:28:20] <doomlord> sanxiyn , i'm suggeting an *array of indices* that comes packaged with one pointer to the array it indexes into
[11:28:38] <dbaupp> jclements: yeah, that minimal testcase is extremely peculiar.
[11:29:06] <doomlord> struct IndexBuffer<T> {  data:&[T], indices:[int] }
[11:29:18] <sanxiyn> Hm
[11:29:25] <sanxiyn> doomlord: And how do you index that?
[11:29:30] <jclements> dbaupp: I'm still... the testcase as written won't compile on any machine; it has free-floating types. I guess I should get a bit more clarification from graydon.
[11:29:49] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[11:30:04] <doomlord> impl IndexBuffer  {    get(i)->t  {  unsafe {  data.unsafe_array_acessor( indices[i] ) } /* various iterators probably for more efficient/convineit use...*/ }
[11:30:37] <cmr> doomlord: don't you still needs a bounds check on indices?
[11:30:50] <cmr> *some* assertion that you're not reading  past the end?
[11:31:03] <sanxiyn> cmr: Well you can also use unsafe there
[11:31:12] <sanxiyn> I think the idea is interface is safe
[11:31:30] <doomlord> *on creation* yes, but the point is if the object is immutable, and the [T] is frozen, the checks could be done once, and then acessed many times without checks
[11:31:36] <SimonSapin> In Python, `a < b < c` is `a < b && b < c` rather than `(a < b) < c`. Has this been proposed for Rust before?
[11:31:39] <jclements> Holy Glorba! installing on Windows is an almighty pain. Do we actually *have* any Windows users?
[11:31:41] <cmr> SimonSapin: yes
[11:31:47] <doomlord> eg game load level..do checks that assets are sound.. then per frame, no checks
[11:31:51] <SimonSapin> cmr: and rejected?
[11:32:00] <sanxiyn> doomlord: Yes, now I understand
[11:32:03] <cmr> SimonSapin: I don't think it was really decided
[11:32:08] <cmr> SimonSapin: I proposed it, though I wasn't the first
[11:32:18] <cmr> jclements: we do! Did you see https://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust ?
[11:32:46] <jclements> cmr: yes... it's really well-written and detailed.  But... there are a *lot* of steps there...
[11:32:47] <sanxiyn> cmr: Do you know any specific Windows user?
[11:32:57] <cmr> sanxiyn: thad guidry, me
[11:33:31] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[11:33:36] * Ms2ger would probably prefer disallowing a < b < c
[11:33:52] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Connection reset by peer)
[11:34:08] <SimonSapin> Can I use #[cfg(test)] on a statement? The closest I get is an inline function with a no-op implementation for #[cfg(not(test))]
[11:34:20] <SimonSapin> Ms2ger: why
[11:34:23] <SimonSapin> ?
[11:34:28] <cmr> SimonSapin: no, attributes can only be applied to items
[11:34:35] <doener> ChrisMorgan: if you have no other ctags config, just symlink ~/.ctags to ctags.rust
[11:34:39] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[11:34:45] <doener> ChrisMorgan: otherwise, copy the contents
[11:34:58] <jclements> SimonSapin: I don't see how to do a < b < c in a nice portable way.  Do you do it at parse time, or as a rewriting step later?
[11:35:15] <SimonSapin> cmr: I mean something equivalent. Maybe cfg(test) as a bool expression?
[11:35:26] <Ms2ger> SimonSapin, every time I see it in python, I have to go test it to convince that it does actually mean a < b && b < c
[11:35:29] <dbaupp> SimonSapin: https://github.com/mozilla/rust/issues/8130
[11:35:30] <SimonSapin> jclements: parse time
[11:37:07] <ChrisMorgan> Concerning the expansion of `a < b < c` in Python, note that b is evaluated once only.
[11:37:23] <jclements> SimonSapin: It's a matter of taste, but as a Scheme/Racket person, that sounds icky and complicated to me.  Not extensible. Also, there seems to be a rodent in my ceiling right now, clearly an omen that this is a bad idea.
[11:37:55] <cmr> why does a < b < c < d do?
[11:38:03] <cmr> *what
[11:38:08] <ChrisMorgan> a < b and b < c and c < d
[11:38:21] <cmr> Well yes, but in terms of evaluation
[11:38:25] <cmr> are the inners still evaluated once?
[11:38:27] <ChrisMorgan> Yes.
[11:40:26] *** Joins: orshem (orshem@C5E06B1E.A5B6B765.E3D28531.IP)
[11:40:38] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[11:41:08] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[11:41:23] <ChrisMorgan> Note that it does lead to some surprising behaviour for the unwary: for example, 1 < 2 < 4 > 3 is true.
[11:41:36] <ChrisMorgan> And 1 < 2 == 2
[11:41:45] <ChrisMorgan> (I mean, that is True.)
[11:46:25] <ChrisMorgan> Put in pure Python terms, `1 < 2 == 2` evaluates to `True`, but `1 < 2 == 2 is True` evaluates to `False`, as it is effectively `1 < 2 and 2 == 2 and 2 is True`. One would need `(1 < 2 == 2) is True` for it to be True.
[11:48:36] *** Quits: TD-Linux (TD-Linux@E338EB99.2B4F0AE0.A0A36CCE.IP) (Ping timeout)
[11:50:17] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[11:50:17] *** ChanServ sets mode: +o dherman
[11:51:45] *** Joins: Florob (Florob@moz-39532932.de)
[11:51:48] <ChrisMorgan> I think operator chaining like that would be a good thing to have. Those weirdnesses of combining different operators will be much less likely to catch people in Rust than in Python on account of its type strictness in comparisons.
[11:54:07] *** Quits: BitPuffin (quassel@moz-49828767.cust.tele2.se) (Ping timeout)
[11:54:53] <jensnockert> ChrisMorgan: Yeah, `0.0 < x < 1.0' is one of the few good things about Python, and with strict typing, there is very few edge-cases.
[11:55:26] <ChrisMorgan> I say "Indeed" about it being a good thing about Python, but I would object strongly to its being one of the _few_ good things about Python.
[11:55:36] <dbaupp> jclements: I'm not sure I understand "Processing the cfgs before doing macro expansion makes this a bit harder" in https://github.com/mozilla/rust/issues/8130#issuecomment-21856455
[11:55:51] <dbaupp> jclements: we currently run cfg stripping before and after expansion
[11:55:53] <jensnockert> ChrisMorgan: My hate for Python is currently irrational.
[11:56:08] <ChrisMorgan> Any hate for Python must inevitably be ;-)
[11:56:59] <jensnockert> But Python has a lot of silly syntactic sugar.
[11:57:16] <jclements> dbaupp: in that case, I may well be wrong; it might be easier just to write a macro that expands into an in-place module... you know, actually, the thing I wrote might be simpler than that.
[11:57:36] <dbaupp> jclements: yeah, debug_assert! is currently written exactly like that
[11:57:48] <jclements> dbaupp: hmm... apparently, you're not @dbaupp on github?
[11:57:53] <dbaupp> jclements: huonw
[11:57:54] <cmr> is huonw
[11:58:04] <ChrisMorgan> jensnockert: a lot of silly syntactic sugar?
[11:58:17] <jclements> dbaupp: ah! the two of you are the same person.  Well, that simplifies things.
[11:58:22] <dbaupp> jclements: heh :)
[11:58:54] <jensnockert> ChrisMorgan: Yes. But I'm a Ruby person.
[11:59:03] <madmoose> COBOLs expression are even more... expressive than python's
[11:59:06] <dbaupp> jclements: (for reference, https://github.com/mozilla/rust/blob/master/src/libsyntax/ext/expand.rs#L500-L514)
[11:59:09] <ChrisMorgan> Ah, Ruby! A language which can't be parsed!
[11:59:25] <jensnockert> ChrisMorgan: And it still has a lot less syntax than Python ;)
[11:59:37] <Florob> Are Ruby programmers even legally allowed to complain about syntactic sugar?
[11:59:43] <ChrisMorgan> No.
[12:00:19] <dbaupp> cmr: (is the benchmarker off, or are my scripts failing again?)
[12:00:22] <jensnockert> Florob: Ruby programmers doesn't usually even use speshul syntax for loops.
[12:00:29] <madmoose> IF B GREATER THAN A AND LESS THAN C THEN ...
[12:00:38] * jensnockert hugs madmoose.
[12:00:39] <cmr> dbaupp: probably failing, let me check if there's a bum json
[12:00:42] <ChrisMorgan> Ruby's lack of significant syntax and ease of making DSLs has the result that it's excruciatingly difficult to reason about Ruby codeâ€”it's not Ruby code, it's whatever-library-or-fashion-you-prefer code. Whereas Python code is just about always Python flavoured.
[12:01:19] <jclements> dbaupp: silly me.  It looks like this completely resolves https://github.com/mozilla/rust/issues/8130 , no?
[12:01:27] <jensnockert> ChrisMorgan: Yes, but considering it was designed by a LISPer, it isn't really surprising.
[12:01:50] <dbaupp> cmr: they're not "properly" failing... it appears that there is a large number of empty mem.jsons
[12:01:55] <cmr> dbaupp: should be corrected
[12:01:58] <cmr> a large number!
[12:02:01] <cmr> that doesn't sound good :(
[12:02:49] <cmr> it seems to be rapidly deteriorating
[12:02:54] <cmr> rewrite time
[12:03:07] <madmoose> jensnockert: Please squeeze my knowledge of COBOL away...
[12:03:10] <dbaupp> jclements: yeah, it does, but unless there's some argument against it, I think that making `if_cfg!(...)` would be the "proper" solution, rather than having special cases for test/bench/debug/whatever.
[12:03:17] *** Quits: sanxiyn (tinuviel@858F408C.B797260D.EF43EC08.IP) (Input/output error)
[12:03:33] * jensnockert patpat madmoose: I had to write FORTRAN 90 for a while.
[12:03:42] <jensnockert> Oh wait, noâ€¦ it was 77+.
[12:03:50] <jensnockert> It just had a few features of FORTRAN 90.
[12:04:35] <dbaupp> jclements: (presumably it'd have to be a syntax extension, since I don't think macros can handle attributes/meta-items at the moment.)
[12:04:39] <jensnockert> Like SELECT â€¦ CASE, or whatever you would call it.
[12:04:58] <jclements> dbaupp: right.
[12:06:17] <cmr> erickt1: ping
[12:06:21] <dbaupp> jclements: also, while you're around, is my idea on https://github.com/mozilla/rust/issues/7727 silly?
[12:08:40] *** Joins: LU324_ (stuff@moz-A17E9A7B.dyn.embarqhsd.net)
[12:09:48] <jclements> dbaupp: I think that introducing a very simple kind of new AST node is probably the right solution to allowing macros to expand into multiple things--this is what Racket does, with "top-level begin". Unless I'm misunderstanding you, though, it seems like it would make more sense to make this its own AST node rather than overloading the quoted-syntax one, though.
[12:10:43] <kimundi> ChrisMorgan: I thnik that operator chaining can be implemented as a macro
[12:11:11] <dbaupp> jclements: do you mean multiple things as in a macro can expand into types or expressions or idents, or multiple things as in one macro invocation can expand to 3 `fn` declarations? (I'm meaning the former.)
[12:11:38] <jclements> dbaupp: ah! I knew I was misreading you somehow. Hang on...
[12:12:21] <kimundi> opchain!(a < b < c) => {let (_a, _b, _c) = (&a, &b, &c); _a < _b && _b < _c}
[12:13:28] <kimundi> 'fi opch!(0.0 < x < 1.0) { ... }'
[12:13:37] <engla> nice kimundi
[12:13:54] <kimundi> no idea if it works though
[12:14:15] <ChrisMorgan> kimundi: unfortunately, making it as general as in Python (mixing operators) is impossible
[12:14:23] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[12:14:25] <kimundi> Sure about that?
[12:14:59] <kimundi> If not possible as a macro, just implement it as a syntax extension
[12:15:24] <ChrisMorgan> No support for "< or > or <= or >=", etc., so you'd need an infinite number of rules.
[12:15:36] *** Quits: sw17ch (sw17ch@moz-7B9AAF7A.static.aldl.mi.charter.com) (Quit: sw17ch)
[12:15:46] <kimundi> What do you mean with 'no support'?
[12:15:58] <engla> macros have overloading
[12:16:06] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Ping timeout)
[12:16:15] <engla> so it can support variations like 1 <= x < 2
[12:16:24] <kimundi> exactly
[12:16:51] <cde> does rust have support from native complex numbers?
[12:16:52] <dbaupp> rusti: struct Foo; trait Bar { fn bar(&self); } impl Bar for Foo { fn bar(&self) {} fn bar(&self) {} }
[12:16:53] -rusti- ()
[12:16:59] <kimundi> I mean, if could get complicated to implement as a normal macro, but with a syntax extension it would be possible for sure
[12:17:03] <ChrisMorgan> engla: but to make it support arbitrarily long chaining you'd need an infinite number of rules
[12:17:14] <dbaupp> does anyone know if that ^ (two definitions of a trait method) is a known issue?
[12:17:31] <dbaupp> cde: extra::complex; (very basic at the moment)
[12:17:39] <cde> thx bro
[12:17:46] <dbaupp> cde: http://static.rust-lang.org/doc/extra/complex.html
[12:17:46] <kimundi> ChrisMorgan: Either you can express it as macro recursion, or again as syntax extension
[12:17:56] <dbaupp> ChrisMorgan: I don't think that's true
[12:18:08] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[12:18:13] <dbaupp> ChrisMorgan: as kimundi says, recursion.
[12:18:36] <kimundi> "consume first binop, chain with recursive expansion of macrto on remaining ones"
[12:18:38] <jclements> dbaupp: I'm probably still misunderstanding you, but it seems to me that there are two problems here, and that the one you're referring to is already addressed by the MRAny variant of the MacResult enum.  It seems that the not-done part is putting holes in the parser so that it allows macros in more places.
[12:19:16] <ChrisMorgan> Bear with me, I believe I'm right in spite of recursion. Your recursive macro still needs to define the permitted syntax, with rules like ($a:expr < $b:expr $( $op:[<|>|<=|>=|...] $c:expr )*), but you can't do that $op bit
[12:19:41] <dbaupp> jclements: yeah, that is the problem: and it would require adding a Macro variant to everything (I think); so might as well do it one place.
[12:20:18] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[12:20:46] <dbaupp> ChrisMorgan: in theory there is `tt`, which doesn't get parsed at all, and so you can pass it straight to the recursive call.
[12:21:07] <ChrisMorgan> Oh, I wasn't aware of tt. What does it mean?
[12:21:11] <engla> anyway, the macro won't parse   $A:expr < $B:expr  because that's an expression in itself
[12:21:12] <dbaupp> token-tree
[12:21:38] <ChrisMorgan> Any type which could evaluate to an operator, any operator?
[12:22:23] <jclements> dbaupp: yikes! I think I understand what you're saying now; completely redesign the AST so that they're all parameterized variants of a single type. Interesting! 
[12:22:36] <dbaupp> ChrisMorgan: token tree == "stream" of rust tokens, so anything that can get through the tokeniser
[12:22:52] <dbaupp> jclements: yeah, it's almost that at the moment, with `spanned`
[12:22:55] <ChrisMorgan> In this case we want just a single token.
[12:23:10] <jclements> dbaupp: yes, I see the parallel.
[12:23:30] <dbaupp> ChrisMorgan: well, you just take the whole trailing section of the invocation and pass that straight to the recursive call: it can perform the validation/parsing itself
[12:23:35] <jclements> dbaupp: some recent commits get rid of a whole bunch of spanned....
[12:23:56] <dbaupp> ChrisMorgan: (however, this is pointless, since as engla points out, a < b get's parsed as an expression)
[12:23:58] <dbaupp> jclements: yeah, I know
[12:24:17] <ChrisMorgan> True, I had forgotten that... local ambiguity.
[12:24:34] <dbaupp> jclements: "we appear to be moving away from the spanned wrappers too, so this pattern may be deprecated." ;)
[12:24:55] *** Joins: heftig (heftig@1103CD12.9A77AED9.3663C14F.IP)
[12:25:18] <jclements> dbaupp: yep, I see that.
[12:26:03] <jclements> dbaupp: also, there would still be quite a bit of work to do in updating the parser; I don't think our current syntax makes the macro invocation pattern "fit" neatly into all parser nonterminal slots.
[12:26:21] <dbaupp> jclements: ah, that wouldn't be so fun.
[12:26:56] <dbaupp> jclements: I would imagine it could be phased in, with the parser just outputting Plain(thing) always, and then someone can come and update it for macros later.
[12:27:20] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[12:27:45] <dbaupp> jclements: (it would be nice if there was a solution that didn't "dirty" the ast for downstream consumers of it as much, though.)
[12:28:00] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[12:28:39] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[12:29:40] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[12:30:19] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[12:31:26] <dbaupp> cmr: one just worked then! did you poke and prod something?
[12:32:32] *** Quits: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu) (Client exited)
[12:32:50] <cmr> dbaupp: yes, I created the cgroup
[12:32:52] * cmr embarassed
[12:32:59] *** Joins: _1126 (1126@moz-83D60E55.lileth.net)
[12:33:17] <cmr> It seems to not be *using* cached builds, but it is caching the builds
[12:33:37] <cmr> so, when I write it to use celery (or maybe rust-zmq!), I'll rerun them all
[12:34:11] *** Joins: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[12:36:09] <dbaupp> cmr: awesome!
[12:40:38] *** Quits: z0w0 (zack@moz-E12708D5.lns6.woo.bigpond.net.au) (Client exited)
[12:41:41] *** Joins: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu)
[12:42:42] *** Quits: The_third_man (ripault@moz-3CE49532.lrde.epita.fr) (Quit: leaving)
[12:43:25] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[12:43:25] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/WLping
[12:43:25] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[12:43:37] *** Quits: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu) (Client exited)
[12:44:16] *** Joins: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu)
[12:44:17] <dbaupp> \o/ a new for loop
[12:44:30] <mark_edward> dbaupp: when did this happen
[12:44:31] <engla> whee!  foreach _ in std::iterator::Counter::new(1,1) { println("it begins") }
[12:44:36] <cmr> mark_edward: literally just now
[12:44:49] <dbaupp> markluffel: that message from ghrust is it landing
[12:44:58] <dbaupp> *mark_edward
[12:45:02] <dbaupp> (sorry!)
[12:45:09] <mark_edward> why is it foreach instead of for!
[12:45:20] <mark_edward> backward compat?
[12:45:20] <engla> transitional name
[12:45:23] <mark_edward> ah i see
[12:45:56] * dbaupp builds himself a new rustc
[12:46:16] * engla did that from auto
[12:46:23] <engla> it's a race
[12:46:23] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[12:46:23] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/mBSdvQ
[12:46:23] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[12:46:24] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[12:46:24] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/8t29MA
[12:46:24] <ghrust> 13rust/06auto 1491f1ab4 15Brian Anderson: rt: Use the correct global change_dir lock
[12:46:24] <ghrust> 13rust/06auto 145d409cc 15bors: auto merge of #8143 : brson/rust/change-dir-lock, r=luqmana
[12:46:24] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[12:48:15] *** Quits: jfbk (textual@moz-EEA9CFB3.nyc.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[12:51:21] <ChrisMorgan> Now everyone wants their new for-loop.
[12:52:26] * ChrisMorgan wonders whether using the macro rule pattern ($($x:tt)*), because you're just passing it all on to something else (e.g. fmt!) later, would be considered cheating
[12:53:31] <dbaupp> ChrisMorgan: not really, although the error messages will be better if you restrict it
[12:53:45] <ChrisMorgan> I think it's weird the way you get `mut x: ~Y` vs. `x: &mut Y`.
[12:53:53] *** Quits: flowsnake (flowsnake@moz-1918C33E.aztw.cable.virginmedia.com) (Ping timeout)
[12:54:11] <cmr> ChrisMorgan: mut x and x: &mut do very different things
[12:54:15] <cmr> you can have mut x: &mut Y
[12:54:36] <ChrisMorgan> I know, but for the purposes of altering the contents of an object those are what you need, right?
[12:55:05] <cmr> rusti: fn x(x: ~int) { *x = 5 }
[12:55:06] -rusti- <anon>:5:25: 5:27 error: cannot assign to immutable dereference of ~ pointer
[12:55:06] -rusti- <anon>:5          fn x(x: ~int) { *x = 5 }
[12:55:06] -rusti-                                   ^~
[12:55:06] -rusti- error: aborting due to previous error
[12:55:06] -rusti- application terminated with error code 101
[12:55:13] <cmr> rusti: fn x(mut x: ~int) { *x = 5 }
[12:55:14] -rusti- ()
[12:55:15] <cmr> yes
[12:55:25] *** Quits: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu) (Ping timeout)
[12:55:39] <cmr> rusti: fn x(mut x: &mut int) { x = &mut 5 }
[12:55:41] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/aKfh
[12:55:48] <ChrisMorgan> rusti: fn x(x: &mut int) { *x = 5 }
[12:55:48] -rusti- ()
[12:55:52] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[12:55:55] <cmr> rusti: fn x(mut x: &mut int) { let y = 5; x = &mut y; }
[12:55:56] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/MiPE
[12:56:12] <cmr> feh
[12:56:15] <cmr> but that's the gist of it
[12:56:21] <cmr> `mut x` gives you a mutable slot
[12:57:03] *** Joins: jbaldwin (Mibbit@moz-1DA260CB.hsd1.co.comcast.net)
[12:57:45] *** Joins: flowsnake (flowsnake@moz-1918C33E.aztw.cable.virginmedia.com)
[12:58:08] <ChrisMorgan> `mut x` allows you to set x to something else, or to change a field of the value at x for a type X or ~X. Whereas with `x: &mut Y` you don't need x to be mut to change a field.
[12:59:36] *** Joins: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu)
[12:59:57] <dbaupp> ChrisMorgan: right, `mut x` allows you to modify everything that `x` owns, `&mut Y` allows you to modifiy anything that `Y` owns
[13:01:25] <ChrisMorgan> My objection is purely that it isn't immediately obvious how/why you need to put mut in a different place for &X (answer: `x: &mut X`) to X or ~X (answer: `mut x: X` or `mut x: ~X`).
[13:01:44] <ChrisMorgan> I presume @ would be the same as & in that regards.
[13:02:58] <dbaupp> yes; it's all to do with ownership
[13:03:19] *** Parts: Egbert9e9 (Egbert9e9@moz-366B5D68.inter.net.il) ()
[13:03:40] <engla> ok so now for the new for loop how do we organize ourselves to make all changes necessary
[13:03:53] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[13:04:28] <dbaupp> ChrisMorgan: for x: @Foo, and x: &Foo, `x` doesn't own the Foo (so it can't modify it, even for `mut x`), where as for `x: Foo` and `x: ~Foo`, `x` does own the Foo (so it can modify the Foo)
[13:05:30] <ChrisMorgan> dbaupp: I do know all that and understand it, but I don't like it; it's going to be non-obvious to newcomers. (Thus saith the one who hath been using Rust for two and a half weeks.)
[13:05:55] <dbaupp> ChrisMorgan: there's no way to get around it and maintain the memory-safe semantics
[13:06:51] <cmr> engla: convert everything to foreach
[13:06:56] <ChrisMorgan> I agree with you that it's semantically correct.
[13:07:09] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[13:07:22] <mark_edward> is it using an iterable trait yet?
[13:07:39] <dbaupp> mark_edward: no
[13:07:51] <engla> cmr: yeah but all the things necessary. reimplement range, change Times trait etc
[13:08:00] <engla> cmr: change IterBytes
[13:08:02] <engla> etc
[13:08:03] <dbaupp> cmr, engla: we'll need a snapshot for that
[13:08:07] <engla> of course
[13:08:13] <engla> but we can prepare a lot in libstd
[13:08:29] <engla> Times is migrating to do 3.times { }  I think
[13:08:44] <bstrie> that's my proposal
[13:08:47] <bstrie> as the Timeslord
[13:08:48] <dbaupp> engla: IterBytes can stay as an internal iterator for now I think
[13:09:11] <engla> it can. I think it should probably be reimplemented with a Writer later.
[13:09:22] * dbaupp has a compiler with foreach!
[13:09:44] <engla> let's go out and do wonderful things with foreach
[13:09:47] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Ping timeout)
[13:12:53] <ChrisMorgan> dbaupp: what, all this new fanciness is a macro? ;-)
[13:13:05] <cmr> it could be
[13:13:10] <cmr> someone made macros for it
[13:13:16] <dbaupp> ChrisMorgan: it essentially is, in fact :P
[13:13:28] <dbaupp> (it gets desugared in the macro expansion pass.)
[13:13:44] <ChrisMorgan> I know. Macros are still quite good, even if they haven't been up to a few of the cases I wanted them for.
[13:13:45] <engla> yeah. --pretty expanded  desugars it
[13:14:08] <engla> it is also duck typed, anything with a .next() method will work!
[13:14:16] <ChrisMorgan> Ooh!
[13:14:22] <engla> graydon will kill me
[13:14:29] <dbaupp> next returning Option<T>
[13:14:45] <ChrisMorgan> engla: he won't do it himself, he'll get the cat to do it
[13:14:52] <ChrisMorgan> Does it deal with both Iterator and Iterable?
[13:15:20] <ChrisMorgan> Is it being desugared in the macro expansion pass short term or long term? (Will --pretty expanded always expand it or only for the moment?)
[13:16:21] <ChrisMorgan> Python's approach with regards to that is essentially to have on the iterator `def iter(self): return self`
[13:16:39] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[13:17:06] *** Joins: kertap (kertap@moz-ED81D7FF.b-ras3.mvw.galway.eircom.net)
[13:17:33] <dbaupp> there is no Iterable yet
[13:18:37] <dbaupp> ChrisMorgan: (and I think it's too early to be able to answer the other questions)
[13:19:04] <ChrisMorgan> Well, call it something with next() -> Option<T>, then.
[13:19:06] *** Quits: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu) (Connection reset by peer)
[13:19:21] <kertap> I created a function to count some characters in a string and it uses a map. From what I can tell the map doesn't get destroyed between function calls. Any idea what I could be doing wrong?
[13:19:29] <cmr> that's Iterator though
[13:19:29] <engla> the change was called "Foreach in sketch"  so it's just the first step
[13:20:06] <bstrie> kertap: how can you tell it isn't getting destroyed?
[13:20:20] <ChrisMorgan> Sorry, I meant having `iter() -> Iterable`
[13:20:40] * ChrisMorgan ponders why `rust run [x/]y.rs` leaves `y~` in the working directory and comesâ€”againâ€”to no conclusion
[13:21:04] <cmr> ChrisMorgan: because it doesn't clean up after itself
[13:21:10] <cmr> ideally it'd use the JIT
[13:21:10] <bstrie> ChrisMorgan: because the rust tool hasn't been touched for a year :P
[13:21:14] <bstrie> it was before its time
[13:21:28] <bstrie> we just didn't have enough good tools to stuff into it to make it worth using and polishing
[13:21:28] <ChrisMorgan> cmr: it waits until it finishes, so it *could* clean up after itself
[13:21:31] <engla> rust run is nice though
[13:21:45] *** Joins: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca)
[13:21:56] *** Joins: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu)
[13:22:09] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[13:22:51] <dbaupp> ChrisMorgan: the rust tool needs a clean up (e.g. parsing arguments more unifiedly/at all.)
[13:23:10] <cmr> extra::getopt could use some love too
[13:23:25] *** Joins: jeff (jeff@moz-F81F6C4E.nyc.biz.rr.com)
[13:23:28] <kertap> bstrie: sorry, my mistake. i was looking at the wring thing.
[13:23:40] <bstrie> np :)
[13:24:48] * ChrisMorgan gets around newrt not having file I/O with good ol' stdin+</stdout+>
[13:27:10] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[13:28:20] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[13:28:21] *** Quits: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Ping timeout)
[13:28:29] <kimundi> ChrisMorgan: Honestly, when I wrote the rust tool I just didn't think those things through :) I think my thinking for not cleaning up was a mix of 'not knowing if it works properly cross platform' and 'if you want to rerun the artifact, you don't need to recompile it'
[13:28:35] *** Quits: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu) (Ping timeout)
[13:29:06] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[13:29:16] <ChrisMorgan> kimundi: in the latter case I'd just omit the -o altogether rather than "hiding" it in $PWD/basename~...
[13:30:00] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[13:30:03] <kimundi> Something should  be changed, no argument there :P
[13:30:12] <engla> dbaupp: do you think we can convert iter_bytes to `do`?
[13:30:46] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[13:30:50] <cmr> could it be reworked and renamed to bytes_iter() and be an iterator?
[13:31:11] <dbaupp> engla: yeah, should be relatively easy... but I'm sure there'll be exactly one user of it that makes it really awkward to convert.
[13:31:28] <dbaupp> cmr: it depends: it currently passes &[u8], which isn't possible to express with an iterator
[13:31:35] <engla> cmr: That would be harder, since a lot of iterators are needed
[13:32:03] <dbaupp> cmr: so we'd have to redesign it to be one-byte-at-a-time (and what engla says.)
[13:32:08] <cmr> yeah
[13:32:40] <engla> cmr: as in separate implementations, VecIterbytesIter, StrIterbytesIter etc
[13:33:12] <engla> I'll try to convert it to `do` now
[13:34:30] <dbaupp> engla: just converting everywhere that uses it with `for` to use `do` instead, right?
[13:35:12] <engla> yeah and removing the bool return I thought
[13:35:26] <dbaupp> that's required for composing them
[13:35:43] <engla> it's required for being able to break out early
[13:35:53] <dbaupp> oh, the inner one?
[13:35:55] <engla> not for composition by itself
[13:36:21] *** Quits: dbp (user@moz-72A193C2.ri.ri.cox.net) (Ping timeout)
[13:36:29] * ChrisMorgan suddenly contemplates using include!
[13:36:43] *** Quits: jclements (jclements@moz-9933A8FC.ngn.east.myfairpoint.net) (Quit: jclements)
[13:37:00] <dbaupp> engla: i.e. iter_bytes(..., &fn(..) -> /* this one */ bool) -> bool ?
[13:37:17] <engla> yeah that one. and as a consequence, the second one as well
[13:38:01] <dbaupp> yeah, well, that will break things that require/want breaking early... I'd vote for just keeping them
[13:38:05] *** Quits: slaren (slaren@moz-BF3399F5.red-95-120-40.dynamicip.rima-tde.net) (Quit: )
[13:39:09] <engla> ok either will work
[13:39:31] <engla> do blocks don't support 'break' though, so you'd pass true/false manually
[13:39:36] <dbaupp> yeah
[13:40:02] <dbaupp> hmmm, it appears that rust has regressed 5-10% in terms of generated code speed. :(
[13:40:12] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[13:40:25] <engla> iterbytes is a derivable trait though :-|
[13:40:30] <dbaupp> (in the last 6 days; for my particular task.)
[13:40:37] <engla> that's definitely a vote for not changing the signature!
[13:40:40] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[13:40:41] <dbaupp> yup
[13:41:13] * cmr hasn't had to manually write an IterBytes implementation yet
[13:41:22] *** Joins: BitPuffin (quassel@moz-49828767.cust.tele2.se)
[13:44:43] *** Joins: lmandel (lmandel@moz-AEAD2F61.dsl.bell.ca)
[13:47:22] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[13:47:26] <ChrisMorgan> How exactly does one write to a file? A way that works, i.e. old RT
[13:48:17] *** Joins: mark_edward (quassel@moz-4A5B1251.wisolt4.epbfi.com)
[13:48:29] <dbaupp> ChrisMorgan: io::file_writer(path, [flags...])
[13:49:06] <ChrisMorgan> Thanks. Now why was I unable to find that myself? I hunted for just on ten minutes and several of those were in io...
[13:49:10] <engla> something like this should find for loops (except .advance loops) to examine
[13:49:10] <engla> git grep -E -e '^\s*for .*\|.*\|.*\{' --and --not -e advance
[13:51:31] <dbaupp> ChrisMorgan: not enough use of grep? :P
[13:51:51] <ChrisMorgan> Searching for not *quite* the right thing.
[13:56:38] *** Quits: mark_edward (quassel@moz-4A5B1251.wisolt4.epbfi.com) (Client exited)
[13:57:34] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[13:57:55] *** Quits: jbaldwin (Mibbit@moz-1DA260CB.hsd1.co.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[13:58:29] <ChrisMorgan> Eek! Rust has no octal literals? :-(
[13:58:49] <cmr> No
[13:59:05] <dbaupp> ChrisMorgan: what for? file modes?
[13:59:12] <ChrisMorgan> dbaupp: you guessed it!
[13:59:15] <kimundi> ChrisMorgan: It doesn't even have 'do {...} while', what do you expect :P
[13:59:15] <cmr> Reason: they are only useful in exactly one place, and can be accomplished with a macro
[13:59:30] <ChrisMorgan> cmr: is there such a macro?
[13:59:41] <cmr> ChrisMorgan: not in the stdlib no
[13:59:57] *** Joins: pcwalton (pcwalton@moz-481A040C.hsd1.ca.comcast.net)
[13:59:57] *** ChanServ sets mode: +o pcwalton
[13:59:57] <dbaupp> you can do it with a function too
[14:00:07] <ChrisMorgan> dbaupp: eek! Runtime overhead!
[14:00:08] <Florob> I would also argue that the binary representation is more readable anyway ;)
[14:00:13] <cmr> yeah but that's stringly typed
[14:00:42] <ChrisMorgan> I actually rather enjoyed using every type of literal in my Java DES implementation last semester: binary, octal, decimal, hexadecimal. If they had base-4 numbers I'd have used them like a shot too.
[14:00:45] <engla> what about not using magic constants for file modes
[14:00:57] <dbaupp> cmr: no, `dec_lit_is_actually_oct(777) == 511`
[14:01:05] <cmr> Ah
[14:01:26] <dbaupp> (it's still slightly stringly typed, since 787 would be an error.)
[14:02:10] <Florob> 0b110_110_100
[14:02:37] <ChrisMorgan> rw-rw-r--
[14:02:41] <cmr> dbaupp: I bet llvm would even constant-fold the hell out of it
[14:02:54] <dbaupp> cmr: it'd be a pretty complicated loop, but maybe
[14:03:11] <ChrisMorgan> Now using r, w, x and - is a form that would *really* be handy.
[14:03:31] <dbaupp> cmr: (LLVM might be more inclined to if it was hardcoded for three digits only.)
[14:03:43] *** Joins: mark_edward (quassel@moz-4A5B1251.wisolt4.epbfi.com)
[14:04:22] <ChrisMorgan> fmode!(rw-rw-r--)... I wonder what compile performance would be like, assuming you hardcoded all the values in the macro rules (512 rules)?
[14:05:03] <cmr> ChrisMorgan: don't forget the sticky bit
[14:05:42] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[14:07:22] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Ping timeout)
[14:08:02] <ChrisMorgan> cmr: true, true... count setuid/setgid in too and that'll be 4096 rules...
[14:08:33] <kimundi> ChrisMorgan: ... Or implement it as syntax extension and onld have ~10 lines of code
[14:08:45] <cmr> kimundi: insanity!
[14:08:47] <ChrisMorgan> kimundi: don't spoil the fun!
[14:08:52] <kimundi> xD
[14:09:15] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Connection reset by peer)
[14:09:16] <kimundi> rusti: stringify!(rw-rw-r--)
[14:09:17] -rusti- "rw - rw - r - -"
[14:09:27] <dbaupp> rusti: let (r,w,x,rw,wx,rwx) = (1,1,1,1,1,1); rw-rw-r--
[14:09:28] -rusti- <anon>:6:4: 6:5 error: unexpected token: `}`
[14:09:28] -rusti- <anon>:6     };
[14:09:28] -rusti-              ^
[14:09:28] -rusti- application terminated with error code 101
[14:09:32] <dbaupp> rusti: let (r,w,x,rw,wx,rwx) = (1,1,1,1,1,1); rw-rw-r--r
[14:09:34] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/XXIW
[14:09:46] <ChrisMorgan> dbaupp: ... give up!
[14:10:00] <dbaupp> ChrisMorgan: you could do it with operator overloading!
[14:10:23] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[14:11:19] <ChrisMorgan> dbaupp: and how will that cope with e-x?
[14:11:38] <dbaupp> ChrisMorgan: more constants!
[14:14:08] *** Quits: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net) (Ping timeout)
[14:14:32] *** Joins: chii (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP)
[14:15:20] *** Quits: Houm (Houm@moz-25669AA8.fbx.proxad.net) (Input/output error)
[14:18:13] <ChrisMorgan> Actually, we need to cope with both s and t for setuid/setgid/sticky... make that 8192 rules.
[14:18:41] <cmr> and don't forget extended attributes
[14:18:52] <ChrisMorgan> (I would not support mixing s and t...)
[14:19:08] <ChrisMorgan> cmr: this is simple modes we're talking about. No extended attributes there, right?
[14:19:18] <cmr> ChrisMorgan: true
[14:20:36] *** Joins: fabiand (fabiand@moz-F19FC30D.adsl.alicedsl.de)
[14:21:55] *** Joins: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[14:24:11] <ChrisMorgan> Wow. Who'd 'a thought it? rustc doesn't cope so very well with http://sprunge.us/gDbG 
[14:24:19] *** Joins: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP)
[14:24:26] <ChrisMorgan> Someone try it and tell me how long it takes them to compile it!
[14:24:56] <jensnockert> ChrisMorgan: Throw it at rusti?
[14:25:43] *** Joins: Sergio965 (sergiobz@moz-BB21156B.dynamic.csail.mit.edu)
[14:26:19] <ChrisMorgan> jensnockert: eh, IRC doesn't tend to let 270KB lines through.
[14:26:29] <jensnockert> Silly IRCâ€¦
[14:26:35] <Seldaek> ChrisMorgan: I'll run it give me a sec
[14:27:00] <ChrisMorgan> My computer is still trying to compile it three minutes later...
[14:27:08] <ChrisMorgan> But mine is quite slow.
[14:27:52] *** Joins: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP)
[14:28:25] <Seldaek> holy crap :)
[14:28:40] *** Joins: infynyxx_ (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[14:29:37] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[14:29:47] <ChrisMorgan> Wow! It finished!
[14:30:07] <ChrisMorgan> Something tells me that macro_rules! wasn't supposed to be used with 8192 patterns.
[14:30:11] <Seldaek> I wonder why this is so slow
[14:30:20] *** Quits: infynyxx_ (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[14:30:25] <cmr> Me too
[14:30:38] <cmr> I can't imagine it being worse than a linear search with a strcmp on each of them
[14:30:46] <cmr> pauls: perhaps you can comment on this?
[14:31:13] <cmr> time: 145.222 Seldaek expansion
[14:31:16] <cmr> Guh
[14:31:17] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[14:31:19] <cmr> My client does it too
[14:31:25] <Seldaek> what:)
[14:31:25] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[14:31:25] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/8t29MA
[14:31:25] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[14:31:32] *** Joins: Houm (Houm@moz-25669AA8.fbx.proxad.net)
[14:31:35] <cmr> When you paste input with s<TAB>, it does autocompletion
[14:31:39] <Seldaek> real    3m8.732s
[14:31:45] * ChrisMorgan is a troublemaker :-)
[14:31:56] <cmr>  2:26.49 total
[14:31:58] <cmr> Hah!
[14:32:01] <ChrisMorgan> Mine took 5-6 minutes.
[14:32:51] <ChrisMorgan> Maybe I shouldn't implement fmode! this way just yet :P
[14:32:58] <Seldaek> hehe
[14:33:47] <kimundi> ChrisMorgan: It would be an EXCELENT way to force the devs to concentrate or the macro system though ;)
[14:33:53] * ChrisMorgan just thought of an alternative: lots of constants and use _ instead of -, e.g. r_xr_xr_S (1554)
[14:34:09] *** Joins: azita (Azita@87C1F78E.1DE10CA8.D8E68FF6.IP)
[14:34:11] <cmr> there's an idea
[14:34:13] <ChrisMorgan> "Hey Rust devs! I did something silly and it's slow! Fix the macros!"
[14:34:14] <engla> ChrisMorgan: can you split it in three parts?
[14:34:23] <cmr> std::io::modes::r_xr_xr_S
[14:34:26] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[14:34:26] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/6RGEnA
[14:34:26] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[14:34:28] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[14:34:28] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/0nHxcg
[14:34:28] <ghrust> 13rust/06auto 1411fc1fd 15Brian Anderson: test: Use a test extern in various foreign fn tests
[14:34:28] <ghrust> 13rust/06auto 140a87589 15Brian Anderson: test: Remove a test of the oldsched runtime api
[14:34:29] <ghrust> 13rust/06auto 149e85745 15bors: auto merge of #8145 : brson/rust/rttestfixes, r=pcwalton...
[14:34:31] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[14:35:01] <kimundi> rusti: let __ = 5; __
[14:35:02] -rusti- 5
[14:35:11] <ChrisMorgan> Would people seriously put 4096 constants into it like that? (I presume the unused ones wouldn't be compiled in.)
[14:35:22] <cmr> Sure why not
[14:35:30] <kimundi> urk
[14:35:33] <cmr> engla's idea of splitting it into 3 parts isn't bad either
[14:35:46] <ChrisMorgan> I don't like using _ for two things there.
[14:35:54] <cmr> rwx + r_x + rwx + S
[14:35:54] <kimundi> Well it's a nice workaround, but that's it
[14:36:05] <cmr> (all of those being variants of enums that override Add)
[14:36:17] <ChrisMorgan> *shudder*
[14:36:46] <ChrisMorgan> Actually, S at the end there meant "sticky bit set, everyone execute bit not set".
[14:36:59] <engla> fmode!(rwx, r--, r--);
[14:37:06] <cmr> heh, or that
[14:37:13] <engla> it's just a reduction by a small factor though
[14:37:47] *** Quits: pcwalton (pcwalton@moz-481A040C.hsd1.ca.comcast.net) (Quit: pcwalton)
[14:38:33] <ChrisMorgan> engla: aww... but that'd be so few rules!
[14:39:48] <engla> I think your macro is a good argument for not trying to invent fancy names for a simple octal number... i'm defeated
[14:43:57] <kimundi> would something like base!("0o731") be to cumbersome?
[14:44:12] <cmr> I was think oct!(731) originally
[14:44:31] <cmr> for that I'd want base!(1532, 8)
[14:44:40] <cmr> And *all* the bases, not just up to puny 36 ;p
[14:44:49] <kimundi> cmr: Has to ba a string, though
[14:45:02] *** Quits: BitPuffin (quassel@moz-49828767.cust.tele2.se) (Ping timeout)
[14:45:31] <kimundi> Or else base!(255, 8) == base!(0xff, 8)
[14:45:38] <Seldaek> maybe it'd just be better to have octals in the language since that's what anyone would expect? :p
[14:45:50] <cmr> Seldaek: octals with which syntax?
[14:46:09] <cmr> Also I think octal literals are silly
[14:46:12] <kimundi> Seldaek: I think "only one use case" is reason enough to not embedded it into the grammar
[14:46:36] <kimundi> base!("020120", 3)
[14:46:57] <ChrisMorgan> Ooh! Then let's go to more exotic schemes like balanced ternary!
[14:46:58] <Sergio965> How does one make multiple bindings mutable?
[14:47:08] <Sergio965> let (mut x, mut y) = bla doesn't seem to work.
[14:47:09] <ChrisMorgan> Sergio965: can't, must rebind
[14:47:14] <cmr> Sergio965: you can't, not yet.
[14:47:14] <Sergio965> Oh.
[14:47:16] <kimundi> radix!(3, "020120")
[14:47:23] <ChrisMorgan> let (x, y) = ...; let mut x = x; let mut y = y
[14:47:27] <Sergio965> :(
[14:47:44] <kimundi> Sergio965: Will work in the future
[14:48:13] <Sergio965> Will that be the syntax? let (mut x, mut y)?
[14:48:17] <cmr> yes
[14:48:28] <Sergio965> Cool. Thanks!
[14:49:13] <engla> rusti: std::uint::from_str_radix("641", 8)
[14:49:14] -rusti- Some(417)
[14:49:37] <Seldaek> cmr: I'd suggest a 0 prefix because that works well for file modes, but maybe it's just messed up php bias in my head - see http://php.net/manual/en/language.types.integer.php
[14:49:38] <kimundi> wich word would be more appropiate... "radix" or "base"
[14:49:44] *** Parts: azita (Azita@87C1F78E.1DE10CA8.D8E68FF6.IP) ()
[14:49:46] <cmr> Seldaek: Definitely messed up bias.
[14:49:56] <Seldaek> :)
[14:49:58] <kimundi> Seldaek: No single 0 prefix D:
[14:50:00] <cmr> Seldaek: Leading zeros should never be significant!
[14:50:03] * ChrisMorgan just realised there were lots of redundant rules thereâ€”8096 reduced to 7678
[14:50:13] <kimundi> 0o is the only sane thing
[14:50:23] <Seldaek> ChrisMorgan: that'll shave a whole 10 seconds of compiel time :p
[14:50:25] <Sergio965> Why is it that in struct definitions type parameters need not be declared before-hand?
[14:50:34] <Seldaek> kimundi: radix 
[14:50:50] <cmr> Sergio965: What do you mean?
[14:50:54] <kimundi> Sergio965: What do you mean?
[14:51:02] <kimundi> :|
[14:51:17] * kimundi puts on tinfoil hat
[14:51:27] <engla> just use the runtime randix convert function
[14:51:32] <engla> radix
[14:51:51] <Sergio965> That is, to use some type parameter T for a struct, I do: struct MyList<T> { x: ~[T] }, but to implement it, I do: impl <T> MyList<T> { â€¦ }
[14:52:18] <kimundi> I could add a radix!(n, "...") syntax extension
[14:52:19] <cmr> How is that not declared before-hand?
[14:52:43] <Sergio965> In the implementation, I had to declare <T> explicitly before using it, but in the struct declaration, I simply used it.
[14:52:48] <engla> Sergio965: don't know, structs don't use trait bounds so it would be useless
[14:52:54] <cmr> You declared it with MyList<T>
[14:53:06] <cmr> There's a difference between parameterized structs and parameterized impls
[14:53:11] <cmr> you can have impl MyList<int>
[14:53:13] <engla> cmr: I think he means why is it not  struct<T> MyList<T> 
[14:53:25] <Sergio965> engla: Exactly.
[14:53:26] <cmr> Putting parameters directly on impl makes the impl parametric
[14:53:31] <kimundi> Sergio965: That's not what that means. 'impl <T> ...' == "implement for all types T ..."
[14:53:42] <Sergio965> kimundi: â€¦ That's exactly what the means.
[14:53:48] <Sergio965> <T> declared T as a type parameter.
[14:54:18] <kimundi> That's not a declaration
[14:54:26] <Sergio965> cmr: I see. So I can implement it for different types specifically?
[14:54:31] <Sergio965> kimundi: No? What is it then?
[14:54:52] <cmr> Sergio965: Yes, although if you have an impl<T> MyStruct<T>, you will have coherence problems (multiple implementations)
[14:55:06] <cmr> That is a bug in resolve I think
[14:55:13] <cmr> it's supposed to use the most specific I think
[14:56:23] <Sergio965> kimundi: http://static.rust-lang.org/doc/rust.html#generic-functions
[14:57:01] <Sergio965> cmr: I see. Something like struct MyList<int> is non-sensical.
[14:57:20] <Sergio965> So MyList<anything> declares `anything` as a type parameter.
[14:57:26] <Sergio965> Is that right?
[14:57:32] <cmr> Yes
[14:57:42] <Sergio965> Neat.
[14:57:46] <kimundi> Okay, that IS a declaration
[14:58:41] <Sergio965> Thanks for clearing that up. My confusion lied in not knowing I could implement for a specific type like impl MyList<int>.
[14:58:57] *** Quits: pyrac (pyrac@moz-F28B7CAD.w90-55.abo.wanadoo.fr) (Quit: pyrac)
[14:59:06] <Sergio965> We really need a Rust book.
[14:59:12] <Sergio965> Or, you know, complete reference manual.
[14:59:42] <kimundi> For which, you know, we need a complete language
[14:59:43] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[14:59:45] <kimundi> ;)
[14:59:46] <ChrisMorgan> Well, here's one using a whole heap of static uints like rwsr_xr__: http://sprunge.us/PaVA
[15:00:18] <kimundi> ChrisMorgan: How long does that take?
[15:00:24] *** Joins: jorendorff (jorendorff@moz-1747FB68.hsd1.tn.comcast.net)
[15:01:09] *** Quits: vosvos (vosvos@moz-9B8AD3A8.vinita.lt) (Client exited)
[15:01:24] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[15:01:33] <Seldaek> that compiles instantly here
[15:01:55] <ChrisMorgan> I've discovered Vim to be behaving *really* badly with these things, corrupting data and hangingâ€”really weird, wonder if it's anything to do with the way I crashed the Unity panel earlier and some GTK things are not quite working correctly...
[15:02:07] <kimundi> But anyway, I think we could totally write both radix!() and fmode!() right now... Just needs to be a syntax extension build in libsyntax for now, until those become dynamically loadable
[15:02:56] <ChrisMorgan> Turns 0.57s to 1.11s (usr) on my machine.
[15:03:32] <cde> kimundi: can any language be ever considered complete?
[15:03:41] <cde> like life on earth, languages must evolve
[15:03:47] <cde> or perish
[15:03:51] <ChrisMorgan> (Comparing it with fn main(){printfln!(r_x_ws__S);} tacked on the end, the short version having only that one static defined.)
[15:03:57] <cmr> cde: Ok, s/complete/well-defined/
[15:04:07] <kimundi> cde: Sure, but we should at least aim for "productior ready"
[15:04:32] <Sergio965> Productior ready. :)
[15:04:42] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Connection reset by peer)
[15:04:44] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[15:04:58] <kimundi> pfff, r, n only a small dash difference
[15:06:05] <bstrie> what's the point of ever marking something as #[cfg(not(test))] ?
[15:06:05] <engla> ChrisMorgan: I think you should just use a runtime function for conversion. compared to doing IO, the cost is zero
[15:06:40] <ChrisMorgan> engla: this is largely just a fun exercise.
[15:07:07] <kimundi> bstrie: identical but empty twin definiton with  #[cfg(test))]?
[15:07:20] <engla> ChrisMorgan: Doesn't seem like rustc sees it that way :)
[15:07:34] <ChrisMorgan> engla: not the macro version, anyway!
[15:08:21] <kimundi> engla: The point is that rusts macro system is powerful enough that something like this shouldn't need a runtime conversion
[15:09:36] *** Joins: azita (Azita@87C1F78E.1DE10CA8.D8E68FF6.IP)
[15:10:10] * ChrisMorgan suddenly realises that he has been distracted from writing a file.
[15:10:27] *** Quits: recrack (Mibbit@B4104EBB.3CC170B1.1E14B209.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[15:14:42] <engla> hm
[15:15:30] <engla> it's not really powerful as in doing computation. Evidently not as look up table either
[15:17:13] <bstrie> engla has inspired me to alias "fg" to "hm" on all my systems, so that when I accidentally type it into IRC twice a day I can plausibly claim to be thinking
[15:17:32] <cmr> hahah
[15:17:33] *** Joins: paupau (textual@FFAF02D4.F5573215.F20F0C5A.IP)
[15:20:17] <engla> great idea
[15:21:06] *** Joins: nano (nano@moz-972880B.superkabel.de)
[15:22:44] *** Joins: BitPuffin (quassel@moz-49828767.cust.tele2.se)
[15:23:26] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[15:28:25] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[15:29:51] *** Quits: sk (sk@25B0E51B.DB3C9D.78DD174B.IP) (Quit: Leaving)
[15:31:06] *** Quits: orshem (orshem@C5E06B1E.A5B6B765.E3D28531.IP) (Quit: Leaving)
[15:31:25] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Quit: Leaving.)
[15:34:05] *** Joins: yegor (primate@moz-7DA865BF.yandex.net)
[15:34:09] *** Parts: yegor (primate@moz-7DA865BF.yandex.net) ()
[15:34:50] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Quit: Leaving.)
[15:36:40] *** Joins: jbaldwin (Mibbit@EF784383.FC9BECD6.A8DE49A2.IP)
[15:37:37] *** Quits: mark_edward (quassel@moz-4A5B1251.wisolt4.epbfi.com) (Ping timeout)
[15:38:33] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[15:39:11] *** Joins: yonran (yonran@moz-962F33EB.acuitus.com)
[15:39:15] *** Quits: paupau (textual@FFAF02D4.F5573215.F20F0C5A.IP) (Ping timeout)
[15:39:29] <Sergio965> A free-standing Rust library would be awesome.
[15:39:32] <Sergio965> No>?
[15:39:35] <Sergio965> No?*
[15:39:52] <pauls> cmr: I'd say that if a macro is not human-readably small, it's not going to be human-waitably fast to expand.
[15:40:01] <Sergio965> (Working on one now, actually.)
[15:40:26] <cmr> Sergio965: free-standing as in zero.rs?
[15:40:35] <Sergio965> Yeah, but zero.rs isn't a library.
[15:40:39] <cmr> right
[15:40:42] <Sergio965> It's also out of date.
[15:40:46] <Sergio965> (Though I've fixed that.)
[15:40:55] <cmr> dbaupp has a newer one in his malloc library
[15:41:02] <Sergio965> I've got a newer one, too. :P
[15:41:15] <cmr> Anyway, the goal is to have a #[cfg(freestanding)] that you can give to libstd to make a freestanding stdlib
[15:41:19] <Sergio965> Thought I think a real free-standing library is the way to do.
[15:41:19] <pauls> cmr: (the inverse is not true, however. eholk's lambda calculus interpreter is quite small and can take quite a long time to expand)
[15:41:44] <cmr> pauls: that's a very nice turn of phrase
[15:41:45] <Sergio965> So I'm working on one now.
[15:42:40] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Ping timeout)
[15:42:54] *** Quits: BitPuffin (quassel@moz-49828767.cust.tele2.se) (Ping timeout)
[15:43:28] <engla> do you think the internal iterator pattern will live on very much longer? If so, I think it should use a separate enum return value and not bool
[15:43:30] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[15:43:55] <Sergio965> I'm pretty sure it was decided that all iterators would be external.
[15:45:08] <jedestep> how can I declare a &fn with the 'static lifetime?
[15:45:15] <jedestep> (the obvious &'static fn doesn't seem tow ork)
[15:45:27] <engla> &'static fn()  exists
[15:45:51] <jedestep> static f: &'static fn(&char) -> bool = |c| ...
[15:46:00] <engla> should be fine
[15:46:06] <jedestep> says it expected &'static fn but found &fn
[15:46:12] <engla> oh as a static
[15:46:16] <jedestep> yeah
[15:46:18] <kimundi> rusti: static f: &'static fn(&char) -> bool = |c| false;
[15:46:19] -rusti- error: internal compiler error: unexpected failure
[15:46:19] -rusti- note: the compiler hit an unexpected failure path. this is a bug
[15:46:19] -rusti- note: try running with RUST_LOG=rustc=1,::rt::backtrace to get further details and report the results to github.com/mozilla/rust/issues
[15:46:19] -rusti- application terminated with error code 101
[15:46:26] <jedestep> o.o
[15:46:46] <engla> does it make sense to use lambda expressions in file scope?
[15:47:09] <engla> jedestep: try converting from a function.  static f: .. =  functionname
[15:47:17] <jedestep> yeah, I am testing some code that uses a lot of iterator::filter
[15:47:32] <jedestep> hmm ok
[15:47:41] <cmr> rusti: static f: &'static fn(&char) -> bool = |c: &char| -> bool { false };
[15:47:42] -rusti- <anon>:5:46: 5:76 error: constant contains unimplemented expression type
[15:47:42] -rusti- <anon>:5          static f: &'static fn(&char) -> bool = |c: &char| -> bool { false };
[15:47:42] -rusti-                                                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[15:47:42] -rusti- error: aborting due to previous error
[15:47:43] -rusti- application terminated with error code 101
[15:47:44] <jedestep> forgot I can do that
[15:48:27] <engla> jedestep: you can pass a function directly to the .filter()
[15:48:38] <jedestep> yeah
[15:48:48] <jedestep> thanks :)
[15:49:26] <Sergio965> What is the 'core' module?
[15:49:30] <Sergio965> Does it exist?
[15:49:49] *** Joins: Kruppe (user@moz-4DDA8AB8.uwaterloo.ca)
[15:50:03] <jedestep> std used to be called core
[15:50:13] <jedestep> and extra used to be called std
[15:51:02] *** Quits: azita (Azita@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: azita)
[15:52:27] *** Joins: ozten (ozten@moz-DD3B00B4.hsd1.wa.comcast.net)
[15:52:50] <Sergio965> Ah I see.
[15:53:37] *** Joins: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net)
[15:54:12] *** Joins: mark_edward (quassel@moz-4A5B1251.wisolt4.epbfi.com)
[15:55:15] <cde> you might want to avoid std to avoid confusion with c++
[15:55:42] <cmr> cde: that's not a very good reason
[15:55:59] <kimundi> "standart library" is hardly a c++ specific concept
[15:56:08] *** Joins: robarnold (rob@BD56354E.DB510C09.6E370BFC.IP)
[15:56:19] <cde> it's so vague, it's basically useless as a name
[15:56:23] *** Joins: pcwalton (pcwalton@moz-481A040C.hsd1.ca.comcast.net)
[15:56:23] *** ChanServ sets mode: +o pcwalton
[15:57:01] <cmr> It contains all language items needed for any rust program as well as the runtime and dealing with the built-in types
[15:57:02] <kimundi> cde: what would you call the standart library?
[15:57:20] <cde> don't call it anything. remove the std:: everything, saves typing, code is easier to read
[15:57:33] <cmr> And make it a magic builtin?
[15:57:51] <cde> why not (just suggesting)
[15:57:58] *** Joins: webber46 (webber46@moz-717E9C5B.cust.bredband2.com)
[15:58:02] <cmr> What about programs which don't use the standard library?
[15:58:11] <mark_edward> maybe he just measn liek we would type use vec::*; use iterator::*; and etc
[15:58:21] <cde> yes precisely
[15:58:25] <kimundi> cde: That would make it imposssible to exclude the std lib in, eg, embedded szenarios
[15:58:32] <mark_edward> it doesn't seem that outrageous to me. i don't really care though
[15:58:36] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[15:58:39] <cmr> it used to be like that
[15:58:56] <cmr> the prelude reexported every module in core
[15:59:13] <kimundi> or rather, core WAS the prelude
[15:59:16] <bstrie> cmr: not true, it used to be like that because we didn't use to require imports to be crate-relative
[15:59:38] <cmr> bstrie: I don't think that's untrue, but we also reexported everything at one point.
[16:00:07] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[16:00:10] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[16:00:11] <bstrie> I remember having this argument at the time with graydon, when I echoed cde's opinion :)
[16:00:29] <cde> bstrie: what did he say?
[16:00:30] <bstrie> to compensate for the new name resolution rules we greatly expanded the list of things in the prelude
[16:01:07] <bstrie> this is the reason why you can nowadays write "println" rather than "io::println" (which would have had to become "core::io::println")
[16:01:50] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[16:01:52] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[16:02:03] <bstrie> cde: we wanted to see how onerous it was in practice. I think a lot of people are fine with having a `use std::{vec, iterator}` at the top of their files in order to import those namespaces
[16:02:27] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[16:02:35] <cde> yes, it's not that bad
[16:02:50] <bstrie> basically my suggestion was to break up every module in std (nee core) into separate crates
[16:02:56] <bstrie> which is admittedly very extreme
[16:03:04] <cmr> bstrie: why O_o
[16:03:22] <bstrie> cmr: so that you wouldn't have to have `std::` on the front of names :)
[16:03:27] <bstrie> but I'm ok with the current situation
[16:03:46] <bstrie> a single `use` line will suffice for most programs, and it's nicely self-documenting
[16:04:08] <engla> it's much cleaner to have all of the language std library inside std::
[16:04:09] <bstrie> and our new willingness to expand the prelude relieves a lot of the pressure of very common functions and types
[16:04:34] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[16:05:00] *** Quits: lmandel (lmandel@moz-AEAD2F61.dsl.bell.ca) (Quit: lmandel)
[16:05:02] *** Quits: jeff (jeff@moz-F81F6C4E.nyc.biz.rr.com) (Quit: jeff)
[16:05:14] <kimundi> And since we can exclude the prelude with #[no_prolude]; now, the problem of reserving global names is also solved
[16:05:29] <kimundi> #[no_prelude]; even
[16:05:40] <Seldaek> is there already a linter or even better a formatter for rust code?
[16:05:48] <Seldaek> (Ã  la go fmt)
[16:05:54] *** Joins: lmandel (lmandel@moz-AEAD2F61.dsl.bell.ca)
[16:06:03] <cmr> Seldaek: rustc does linting
[16:06:03] <kimundi> Seldaek: runtc includes a pretty printer
[16:06:18] <cmr> rustc -W help
[16:06:22] <cmr> for a list of all the available lints
[16:06:26] <cmr> (most of them are warn by default)
[16:06:27] <kimundi> but the pretty printer is not that good afaik
[16:06:30] <bstrie> putting every top-level module into the prelude, as per cde's suggestion, may or may not be a bad idea. it could sometimes require people to realize exactly where this namespace-out-of-thin-air originates from (and thus more-or-less requires one to memorize the list of top-level modules in libstd)
[16:06:41] <Seldaek> ah I see
[16:06:49] <bstrie> on the other hand, perhaps one could argue that if a module isn't important enough to import by default, it should be in extra rather than std
[16:07:15] <cmr> bstrie: I'd buy that argument
[16:07:16] <kimundi> bstrie: All module exports have been removed from the prelude recently
[16:07:52] <kimundi> since it lead to people being able to access foo::bar, but not to 'use foo::bar'
[16:08:17] <bstrie> true
[16:08:38] <bstrie> that was another of the rationales for my "make every module into a crate" proposal :)
[16:09:07] <cmr> That'd be a crazy explosion of crates though
[16:09:23] <cmr> Having that many shared libraries as the standard library is a sin
[16:09:34] <cmr> It's a language problem requiring a language solution.
[16:09:58] <bstrie> well, to put it that way, it's actually a name resolution problem that has no solution :)
[16:10:09] *** Joins: nano (nano@moz-972880B.superkabel.de)
[16:11:13] <bstrie> I really want pcwalton to write a blog post about his travials in trying to make name resolution sane
[16:11:26] <cmr> yeaj
[16:11:29] <cmr> *yeah
[16:11:37] <bstrie> he may very well now be one of the world's most preeminent experts on the tradeoffs of name resolution
[16:11:42] *** Joins: bent (chatzilla@moz-BE33DA21.fw1.sfo1.mozilla.net)
[16:11:43] <cmr> there's a thin line between we have now and making it undecidable, I think
[16:12:16] *** Joins: jaen (jaen@moz-8AF0BE71.neoplus.adsl.tpnet.pl)
[16:14:38] *** Quits: bnicholson (bnicholson@moz-835D504A.rcmdva.fios.verizon.net) (Ping timeout)
[16:16:18] *** Joins: tchoma (tchoma@moz-E58E29CC.dsl.static.sonic.net)
[16:16:29] *** Joins: bnicholson (bnicholson@moz-835D504A.rcmdva.fios.verizon.net)
[16:16:33] <pcwalton> heh, I wouldn't say that... the people who have been working on the JS modules proposal are more familiar with it than I
[16:17:22] <cmr> pcwalton: don't they have the benefit of not *having* to do name resolution, just property lookups?
[16:17:33] <pcwalton> the modules system for ES6 is totally static
[16:17:33] * cmr not familiar with the proposal, hasn't been keeping up with JS/ES
[16:17:39] <cmr> Oh, very cool
[16:17:43] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[16:17:56] <pcwalton> had a lot of the same decidability problems that we had
[16:18:05] *** Joins: brianm (brianm@D2D642B9.79695EE7.489C5759.IP)
[16:18:11] <bstrie> then you and dherman can write a research paper together :)
[16:19:00] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[16:19:01] <pcwalton> nmatsakis: you might be interested in jonathan shapiro's opinions on Rust's typeclasses/regions/unique pointers http://www.coyotos.org/pipermail/bitc-dev/2013-July/thread.html
[16:19:12] <pcwalton> not sure what we can take from it -- he's fairly critical of everything
[16:19:13] *** Quits: Ralith (ralith@moz-50F3C77.vc.shawcable.net) (Ping timeout)
[16:19:19] <pcwalton> but it's worth reading for sure
[16:19:20] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[16:19:20] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/0nHxcg
[16:19:20] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[16:19:46] *** Quits: jaen (jaen@moz-8AF0BE71.neoplus.adsl.tpnet.pl) (Ping timeout)
[16:19:56] <cmr> Who is Ben Kloosterman?
[16:20:13] <cmr> Also that's a huge thread
[16:21:29] <pcwalton> back in a bit
[16:21:33] *** Quits: chii (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[16:21:35] *** Joins: paupau (textual@FFAF02D4.F5573215.F20F0C5A.IP)
[16:21:51] <bblum> Thiez: re: lazy init for little locks -- It is definitely slower, considering what you'd do in C/C++ is write static lock = LOCK_STATIC_INITIALIZER;, however, we don't have CTFE for rust so you can't call LittleLock::new() (and the initializer functions may not even be CTFE-able anyway)
[16:22:23] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[16:22:24] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/Fwylig
[16:22:24] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[16:22:37] <bstrie> I thought shapiro walked away from bitc years ago, how is that mailing list still going
[16:22:39] <bblum> Thiez: however once it's initialized, you've only got a fast null-check (which doesn't even cause cacheline conflicts 'cause it's a read) for overhead
[16:22:53] <bblum> Thiez: if the compare and swap fails you would just call rust_destroy_little_lock.
[16:24:11] *** Joins: true_droid (Adium@E3D4334F.209E8896.EBC99ECD.IP)
[16:24:18] <pcwalton> I do think that he's overstating the problem of overlapping instances in Haskell (the argument that nobody has ever written any large program in Haskell is somewhat weak tea IMHO)
[16:24:28] <pcwalton> but the unique pointers stuff is well taken
[16:24:40] *** Joins: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net)
[16:24:54] *** Joins: brianm_ (brianm@D2D642B9.79695EE7.489C5759.IP)
[16:24:54] *** Quits: brianm (brianm@D2D642B9.79695EE7.489C5759.IP) (Connection reset by peer)
[16:24:54] <pcwalton> I don't really think we had much of a choice re. unique pointers though, everything else would either not work for servo or would be way too researchy
[16:25:23] <bblum> researchy pointer ownership sounds miserable
[16:25:31] *** Joins: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net)
[16:26:56] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[16:27:46] <bblum> pcwalton: what does he even mean by "shifting this burden to the compiler" when talking about keywords?
[16:27:47] *** Joins: henrikhodne (henrikhodn@moz-F3A92B1C.hsd1.ca.comcast.net)
[16:27:52] *** Quits: bent (chatzilla@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: ChatZilla 0.9.90.1-rdmsoft [XULRunner 22.0/20130619132145])
[16:29:46] <bblum> "a half-assed region system" translation: "a region system designed differently than what i'm familiar with" ?
[16:30:35] *** Quits: Florob (Florob@moz-39532932.de) (Client exited)
[16:32:28] *** Quits: paupau (textual@FFAF02D4.F5573215.F20F0C5A.IP) (Ping timeout)
[16:32:36] <bblum> pcwalton: you could point out to him the advantage of runtimeless rust without GC
[16:33:20] <bstrie> we no longer require #[no_std] projects to provide every single lang item, right? does this dramatically simplify zero.rs?
[16:33:23] <nmatsakis> pcwalton: thanks that does sound interesting
[16:33:29] <cmr> bstrie: correct.
[16:33:56] <cmr> bstrie: https://github.com/huonw/rust-malloc/blob/master/zero.rs is close to the most-minimal zero.rs, I think
[16:33:57] <bstrie> so would a new zero.rs just be malloc/, free, etc wrappers?
[16:34:04] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[16:36:20] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[16:37:50] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[16:38:15] *** Joins: chii (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP)
[16:39:01] *** Joins: paupau (textual@FFAF02D4.F5573215.F20F0C5A.IP)
[16:39:05] <erickt> hey nmatsakis, can I borrow your ear for a few moments to talk about unsafe region pointers? graydon and I had a long talk last night about them and he remained unconvinced. However he did say he was worried he was being too conservative. Have you had any time to form an opinion about it?
[16:39:11] *** Quits: jbaldwin (Mibbit@EF784383.FC9BECD6.A8DE49A2.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[16:39:16] *** Joins: bent (chatzilla@moz-BE33DA21.fw1.sfo1.mozilla.net)
[16:39:47] <cmr> erickt: ping
[16:39:52] <erickt> hey there cmr
[16:40:20] <cmr> erickt: what's the current status of rust-zmq. It doesn't build because of some recent changes, but is it generally safe + stable igoring library churn?
[16:40:23] *** Joins: vosen (vosen@moz-266BA656.icpnet.pl)
[16:41:03] <erickt> cmr: yep. it even kind of supports zero-copy too
[16:41:23] <erickt> cmr: or at least it did at one point...
[16:42:08] <cmr> erickt: cool, I'll give it a spin then
[16:42:50] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[16:44:09] <erickt> cmr: once I rebuild the latest rust I'll try to get rust-zmq compiling on HEAD again
[16:44:13] *** Joins: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP)
[16:44:22] <cmr> erickt: I'm already working on it
[16:44:26] *** Joins: Ralith (ralith@moz-DEBA35B4.wireless.sfu.ca)
[16:44:29] <erickt> cmr: woot
[16:44:57] * erickt sighs. someday I'll claw my way back up into my third party libraries...
[16:45:35] *** Quits: goffrie (goffrie@moz-1A2DE2C4.dsl.ncf.ca) (Ping timeout)
[16:45:46] *** Quits: pcwalton (pcwalton@moz-481A040C.hsd1.ca.comcast.net) (Ping timeout)
[16:46:33] *** Joins: goffrie (goffrie@moz-54FA0270.dsl.ncf.ca)
[16:48:42] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[16:51:00] <bblum> nmatsakis: check out the discussion on https://github.com/mozilla/rust/issues/8124
[16:51:22] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[16:51:50] <bblum> nmatsakis: i think this guy is suggesting bringing back a limited form of purity inference to be more permissive in some cases
[16:51:55] *** Joins: jaen (jaen@moz-8A90FFCC.play-internet.pl)
[16:52:03] *** Joins: eholk (eholk@moz-3EBC7183.uconnect.utah.edu)
[16:52:32] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[16:53:21] *** Quits: mark_edward (quassel@moz-4A5B1251.wisolt4.epbfi.com) (Ping timeout)
[16:56:19] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[16:58:24] *** Joins: ecr (Thunderbir@moz-F724119C.uoregon.edu)
[17:00:03] *** Quits: bent (chatzilla@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: ChatZilla 0.9.90.1-rdmsoft [XULRunner 22.0/20130619132145])
[17:00:15] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[17:02:16] *** Joins: thomaslee (thomaslee@moz-6C3931E3.static.twtelecom.net)
[17:05:57] *** Joins: bent (chatzilla@moz-BE33DA21.fw1.sfo1.mozilla.net)
[17:08:49] *** Joins: BitPuffin (quassel@moz-49828767.cust.tele2.se)
[17:09:34] *** Joins: Vert (quassel@8A83479C.391ACC8C.CAF63861.IP)
[17:12:15] <Thiez> bblum: thanks for the reaction
[17:12:30] *** Joins: infynyxx_ (infynyxx@moz-E95B370B.nyc.res.rr.com)
[17:13:30] <bblum> Thiez: np
[17:14:10] *** Quits: infynyxx_ (infynyxx@moz-E95B370B.nyc.res.rr.com) (Ping timeout)
[17:16:05] *** Joins: azakai (alon@moz-BBE3ABD.mv.mozilla.com)
[17:19:42] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[17:20:46] *** Quits: Ralith (ralith@moz-DEBA35B4.wireless.sfu.ca) (Ping timeout)
[17:22:38] *** Quits: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk) (Client exited)
[17:23:31] *** Joins: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com)
[17:23:31] *** ChanServ sets mode: +o pcwalton
[17:23:56] <SimonSapin> so, extra::json has `impl<A:ToJson,B:ToJson> ToJson for (A, B)`. Can I have my more specifi `impl ToJson for (Foo, Bar)` be used instead? (Foo and Bar are concrete types)
[17:24:59] *** Joins: Florob (Florob@moz-39532932.de)
[17:25:13] *** Quits: jaen (jaen@moz-8A90FFCC.play-internet.pl) (Ping timeout)
[17:25:30] <pcwalton> SimonSapin: that's not supported unfortunately
[17:25:43] <pcwalton> you can make a struct instead of a tuple and impl ToJson manually on your struct
[17:25:51] *** Quits: true_droid (Adium@E3D4334F.209E8896.EBC99ECD.IP) (Quit: Leaving.)
[17:26:16] *** Quits: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP) (Input/output error)
[17:26:58] *** Joins: true_droid (Adium@E3D4334F.209E8896.EBC99ECD.IP)
[17:27:09] <bstrie> nmatsakis: ping
[17:27:12] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[17:27:12] <SimonSapin> that would make everything else in the code more awkward, and I only use JSON in my tests :/
[17:27:25] <SimonSapin> but thanks pcwalton 
[17:27:29] *** Joins: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net)
[17:29:03] *** Quits: CarpNet (ac@moz-FD24B77.sohonet.co.uk) (Quit: Leaving)
[17:29:29] <bstrie> does anyone know how much of http://smallcultfollowing.com/babysteps/blog/2013/01/17/destructors-and-finalizers-in-rust/ was implemented?
[17:29:39] <bstrie> I know we did something to restrict destructors, but I'm not clear on the details
[17:30:40] *** Joins: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch)
[17:30:46] *** Joins: barosl (barosl@E287D94F.C81E10FB.7544CABF.IP)
[17:30:52] <pcwalton> I think it's not really implemented
[17:31:03] *** Joins: mihneadb_ (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net)
[17:31:12] *** Quits: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net) (Connection reset by peer)
[17:31:17] <bstrie> pcwalton: specifically I was curious if the restriction "can't implement destructors on types that contain borrowed pointers" was implemented, or is planned to
[17:31:33] <pcwalton> that was implemented I believe
[17:31:33] *** Quits: mihneadb_ (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net) (Input/output error)
[17:31:45] *** Joins: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net)
[17:32:41] <bstrie> pcwalton: I ask because all the examples in there deal with managed pointers rather than borrowed ones, so I'm not sure what problems would be applicable
[17:32:58] <bstrie> also I was curious if the new borrow checker would obviate the need for that restriction
[17:33:04] *** Quits: kertap (kertap@moz-ED81D7FF.b-ras3.mvw.galway.eircom.net) (Quit: kertap)
[17:33:55] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Quit: Computer has gone to sleep.)
[17:34:53] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[17:35:03] *** Quits: true_droid (Adium@E3D4334F.209E8896.EBC99ECD.IP) (Quit: Leaving.)
[17:35:37] *** Joins: sw17ch (sw17ch@moz-6206F951.dia.static.qwest.net)
[17:36:33] *** Quits: barosl (barosl@E287D94F.C81E10FB.7544CABF.IP) (Quit: ëžœë¤ì€ ì‡ í‡´í–ˆìŠµë‹ˆë‹¤.)
[17:36:49] *** Joins: steven_is_false (user@4728DAC8.6ECAE21.F39A8AA1.IP)
[17:38:04] <steven_is_false> Hi. In https://github.com/mozilla/rust/issues/8140 it was brought to attention that I probable wrote some incorrect code. Would the error state for dynamic libraries be task local on all Rust tasks?
[17:38:52] <steven_is_false> Basically, what I want to know is how does thread local storage implemented in other libraries interact with Rust's task system?
[17:39:22] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[17:39:29] <cmr> steven_is_false: I found another bug in dynamic_lib
[17:39:43] <cmr> https://github.com/cmr/rustdoc_ng/blob/master/plugins.rs#L37
[17:39:51] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[17:39:54] <cmr> The destructor is called there, which makes the subsequent call to .symbol segfault
[17:40:01] <bblum> steven_is_false: i think the use of atomically is actually correct there
[17:40:31] <bblum> steven_is_false: errno is CPU-local, so all we need around errno accesses is to make sure we don't reschedule another task on the same cpu
[17:40:31] <steven_is_false> bblum: Well that's good then.
[17:40:53] <bblum> steven_is_false: just keep in mind that atomically() is just an assertion, not any sort of enforcement mechanism
[17:41:11] <steven_is_false> bblum: Oh, I misinterpreted it then.
[17:41:24] <steven_is_false> It should really be named assert_atomically then.
[17:41:35] *** Quits: henrikhodne (henrikhodn@moz-F3A92B1C.hsd1.ca.comcast.net) (Ping timeout)
[17:41:44] <steven_is_false> cmr: Give me a bit of time to mentally parse, and interpret the code.
[17:41:44] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[17:41:45] *** ChanServ sets mode: +o dherman
[17:41:46] <bblum> yeah it is not meant for use outside std::unstable though
[17:41:53] <bblum> so i chose the 'more cute' name
[17:42:01] <steven_is_false> bblum: Fair enough.
[17:42:25] <joelteon> it appears that my OSX installation of rust has no libcore.so
[17:42:29] <steven_is_false> bblum: Isn't there an issue about making a critical_section! macro anyways though?
[17:42:44] <cmr> joelteon: core doesn't exist anymore
[17:43:17] <joelteon> wat
[17:43:20] <bblum> steven_is_false: is there? that seems like it couldn't possibly work
[17:43:22] <cmr> It was renamed to std
[17:43:27] <joelteon> oh
[17:43:42] <steven_is_false> bblum: It's supposed to use static mutable variables for that.
[17:44:06] <bblum> ah, "globally lock this with a mutex"
[17:44:18] <bblum> perhaps
[17:44:22] *** Joins: nano (nano@moz-972880B.superkabel.de)
[17:44:47] <bblum> in general it doesn't make sense to say "this is an atomic critical section" without saying "...with respect to..." or without specifying how contending threads will wait to get the lock
[17:45:10] <bblum> so such a macro would have to be very carefully named :P
[17:45:24] <Thiez> if I were to have a void pointer to a rust type, would there be any way to discover the type of what it points to and cast back to a pointer of the correct type?
[17:46:03] <cmr> Thiez: at runtime? not just using the pointer
[17:46:12] <olsonjeffery> Thiez: discover? no. cast? yes.
[17:46:13] <Thiez> and more importantly, would it be possible if the pointer was to a trait instance instead?
[17:46:23] <joelteon> aaaack, stop moving the standard library around
[17:46:32] <steven_is_false> bblum: Anyways, thanks for bringing the atomically stuff to my attention. I'll make an issue so it doesn't get forgotten, and later come up with a better implementation.
[17:47:09] <acrichto> Thiez: if you want some ideas on how to do something like that, take a look at local_data_priv.rs, there a common storage holds elements of a ~Trait type but it's possible to extract the element based on its actual type
[17:47:43] <acrichto> Thiez: basically it's incredibly unsafe and difficult to do, it normally requires more mechanisms in place
[17:47:47] <Thiez> acrichto: ah, a use case like that was actually what I had in mind, so it seems someone got ahead of me :D
[17:47:56] <SimonSapin> adding 'ref' and '&' and '*' at random until the compiler is happy
[17:47:57] *** Joins: graydon (Adium@A5087023.2354C43D.D8E68FF6.IP)
[17:47:58] *** ChanServ sets mode: +qo graydon graydon
[17:48:34] <cmr> joelteon: you're two months late to the "nooo not libcore" party :p
[17:48:45] *** Joins: pyrac (pyrac@moz-F28B7CAD.w90-55.abo.wanadoo.fr)
[17:48:52] <olsonjeffery> just wait till newsched lands~!
[17:49:38] <joelteon> cmr: I haven't used rust in awhile :<
[17:50:11] *** Joins: Ralith (ralith@moz-50F3C77.vc.shawcable.net)
[17:50:35] <paupau> is there an eta on newsched?
[17:51:48] <cmr> paupau: the biggest pieces missing from my POV are file io and standard stream (stdin/stdout/stderr) io
[17:51:58] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[17:52:02] <cmr> I'm sure there's a bunch of other complex async or synchronization things that are above me
[17:52:08] <paupau> hmm those *do* sound important
[17:52:39] <paupau> is newsched separate from newrt?
[17:52:45] <cmr> same thing
[17:52:50] <jmgrosen> what's the best way to go from a chariterator to a new string?
[17:53:02] <olsonjeffery> cmr: im flushing async, right now
[17:53:07] <olsonjeffery> but sync io is the critical path
[17:53:13] <paupau> I guess there really isn't much else other than the scheduler in the rt, eh?
[17:53:17] <olsonjeffery> fleshing out async, i should say
[17:53:40] * paupau fflush();
[17:54:40] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[17:54:41] <olsonjeffery> paupau: newsched's impl is in std::rt, as well as the new io APIs built atop newsched and their underlying, default impl in libuv
[17:54:43] *** Joins: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu)
[17:54:56] <olsonjeffery> it will have "landed" when everything moves out of std::rt and into the root of the crate
[17:55:04] <olsonjeffery> displacing the existing std::io and oldsched
[17:55:25] <paupau> olsonjeffery: oh, that's a cool transition :)
[17:56:05] <paupau> libuv is a huge winâ€¦ has that been easy to integrate?
[17:56:09] <olsonjeffery> i can't say about the timeline besides "on or before 0.8", probably
[17:56:12] <engla> jmgrosen: .collect(), it's implemented now
[17:56:53] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[17:56:58] <jmgrosen> engla, and then how from ~[char] to ~str?
[17:57:04] <engla> jmgrosen: an Iterator<char> can be .collect()'ed into a ~str. Or also you can use  let mut s = ~""; s.extend(iterator)
[17:57:13] <jmgrosen> engla, ah, thanks
[17:57:22] <engla> jmgrosen: there's a function for that named from_chars or so
[17:57:56] <olsonjeffery> there's also some language level stuff that needs to happen (~object), before the default libuv impl can be disentangled from the ostenisbly-scheduler-impl-agnostic APIs in std::rt::{io,aio}
[17:58:31] <olsonjeffery> at that point, people can schedulers atop nss, glib, etc
[17:58:40] <paupau> what's ~object?
[17:58:41] <steven_is_false> cmr: Okay, I can talk about the error you wanted talk about now.
[17:58:58] <cmr> steven_is_false: I don't know why it happens, or how to fix it, only that it happens :)
[17:59:02] <steven_is_false> So, apparently the destructor of DynamicLibrary is being called early?
[17:59:05] <cmr> Yes
[17:59:12] <jmgrosen> rusti: 'a' + 'b'
[17:59:13] -rusti- '\xc3'
[17:59:21] <jmgrosen> rusti: 'a' + 26
[17:59:22] -rusti- <anon>:5:15: 5:17 error: mismatched types: expected `char` but found `<VI0>` (expected an integral type but found char)
[17:59:22] -rusti- <anon>:5          'a' + 26
[17:59:22] -rusti-                         ^~
[17:59:22] -rusti- error: aborting due to previous error
[17:59:22] -rusti- application terminated with error code 101
[17:59:34] <steven_is_false> cmr: I have a suspicion I know what the error is.
[17:59:37] *** Joins: lkuper (lkuper@FBBF6446.A402E718.C082B7DC.IP)
[17:59:45] <olsonjeffery> paupau: https://github.com/mozilla/rust/issues/5192
[18:00:05] <steven_is_false> Nope, I don't know the error.
[18:00:13] <paupau> olsonjeffery: thanks
[18:00:25] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[18:00:37] <olsonjeffery> basically.. you can't take a unique box to some object instance as its trait..
[18:00:39] *** Joins: brianm (brianm@D2D642B9.79695EE7.489C5759.IP)
[18:00:39] *** Quits: brianm_ (brianm@D2D642B9.79695EE7.489C5759.IP) (Connection reset by peer)
[18:00:47] <olsonjeffery> so if you have a type named Foo that impls trait Bar
[18:00:54] <olsonjeffery> you can't take a ptr to Foo as ~Bar
[18:01:04] <olsonjeffery> even though you could pass it by val/ref that way..
[18:01:18] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[18:01:19] <olsonjeffery> so its a blocker to the decoupling.
[18:01:37] <paupau> olsonjeffery: ah I see
[18:01:37] <steven_is_false> cmr: I can try to think about the error a bit but it may need more eyes to figure out the bug. Can you create an issue with a test case?
[18:02:39] <cmr> steven_is_false: sure
[18:02:53] <steven_is_false> cmr: Thanks.
[18:03:05] *** Quits: Kruppe (user@moz-4DDA8AB8.uwaterloo.ca) (Ping timeout)
[18:03:33] *** Parts: steven_is_false (user@4728DAC8.6ECAE21.F39A8AA1.IP) (ERC Version 5.3 (IRC client for Emacs))
[18:03:40] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[18:03:41] <olsonjeffery> huh. the issue is closed, too. i wonder if we can de-cluster that situation, then.
[18:04:39] <Thiez> rusti: trait T { fn hello(&self) { println("Hello");} } impl T for int{} let y = ~3 as ~T; y.hello()
[18:04:40] -rusti- Hello
[18:04:40] -rusti- ()
[18:05:56] *** Joins: brson (brson@8ECA0B87.AD77F8DE.D1E74241.IP)
[18:05:56] *** ChanServ sets mode: +o brson
[18:05:58] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[18:07:14] <Thiez> ah, but sadly this one explodes:
[18:07:16] <Thiez> rusti: trait T { fn hello(&self) { println("Hello");} } impl T for () {} let (a,b,c) = (&() as &T, ~() as ~T, @() as @T); a.hello(); b.hello(); c.hello();
[18:07:17] -rusti- error: internal compiler error: Cannot encode region variables
[18:07:17] -rusti- application terminated with error code 101
[18:07:23] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[18:07:24] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/FTtS1w
[18:07:24] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[18:07:25] <Thiez> known issue?
[18:08:34] <olsonjeffery> rusti: struct Foo(int);
[18:08:34] -rusti- ()
[18:09:22] *** Joins: jeff (jeff@moz-F81F6C4E.nyc.biz.rr.com)
[18:09:23] <olsonjeffery> rusti: struct Foo(int); impl Bar { fn baz(); } impl Bar for Foo { pub fn baz() {} }
[18:09:23] -rusti- <anon>:5:45: 5:46 error: expected `{` but found `;`
[18:09:23] -rusti- <anon>:5          struct Foo(int); impl Bar { fn baz(); } impl Bar for Foo { pub fn baz() {} }
[18:09:24] -rusti-                                                       ^
[18:09:24] -rusti- application terminated with error code 101
[18:09:38] <olsonjeffery> rusti: struct Foo(int); trait Bar { fn baz(); } impl Bar for Foo { pub fn baz() {} }
[18:09:38] -rusti- ()
[18:10:10] <olsonjeffery> rusti: struct Foo(int); trait Bar { fn baz(); } impl Bar for Foo { pub fn baz() {} } let f = Foo(1);
[18:10:10] -rusti- <anon>:5:91: 5:92 warning: unused variable: `f` [-W unused-variable (default)]
[18:10:11] -rusti- <anon>:5          struct Foo(int); trait Bar { fn baz(); } impl Bar for Foo { pub fn baz() {} } let f = Foo(1);
[18:10:11] -rusti-                                                                                                     ^
[18:10:11] -rusti- ()
[18:10:19] <olsonjeffery> sorry.
[18:10:21] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[18:10:21] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/b4qylg
[18:10:21] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[18:10:22] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[18:10:22] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/A1iyUw
[18:10:23] <ghrust> 13rust/06auto 1402f7f72 15BjÃ¶rn Steinbrink: Provide a "configure" option to disable LLVM assertions...
[18:10:23] <ghrust> 13rust/06auto 14e07e49e 15bors: auto merge of #8147 : dotdash/rust/assertion_option, r=pcwalton...
[18:10:23] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[18:10:29] <olsonjeffery> rusti: struct Foo(int); trait Bar { fn baz(); } impl Bar for Foo { pub fn baz() {} } let f = Foo(1); let p: ~Bar = ~f;
[18:10:29] -rusti- <anon>:5:117: 5:119 error: mismatched types: expected `~main::Bar:Send` but found `~main::Foo` (expected trait main::Bar but found ~-ptr)
[18:10:29] -rusti- <anon>:5          struct Foo(int); trait Bar { fn baz(); } impl Bar for Foo { pub fn baz() {} } let f = Foo(1); let p: ~Bar = ~f;
[18:10:29] -rusti-                                                                                                                               ^~
[18:10:30] -rusti- error: aborting due to previous error
[18:10:31] -rusti- application terminated with error code 101
[18:11:48] <jmgrosen> rusti: use std::str::StrSlice; impl<T: StrSlice> T {}
[18:11:48] -rusti- <anon>:5:41: 5:49 error: Illegal anonymous lifetime: anonymous lifetimes are not permitted here
[18:11:48] -rusti- <anon>:5          use std::str::StrSlice; impl<T: StrSlice> T {}
[18:11:48] -rusti-                                                   ^~~~~~~~
[18:11:49] -rusti- error: aborting due to previous error
[18:11:49] -rusti- application terminated with error code 101
[18:11:51] <jmgrosen> ?
[18:12:17] <cmr> jmgrosen: StrSlice is lifetime parameterized
[18:12:18] <jmgrosen> what's wrong with that?
[18:12:20] <jmgrosen> oh
[18:12:23] <jmgrosen> ok
[18:12:57] <jmgrosen> docs don't say that >.<
[18:13:54] *** Joins: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP)
[18:14:15] <joelteon> "extern mod extra" is right, isn't it?
[18:14:19] <olsonjeffery> huh. looks like impls aren't accepted in rusti
[18:14:24] <olsonjeffery> or it just ignores them
[18:14:27] <bstrie> joelteon: yep
[18:14:29] <jmgrosen> rusti: impl Foo {}
[18:14:29] <cmr> rusti the bot?
[18:14:30] -rusti- <anon>:5:14: 5:17 error: found value name used as a type: def_mod({crate: 0, node: 7})
[18:14:30] -rusti- <anon>:5          impl Foo {}
[18:14:30] -rusti-                        ^~~
[18:14:30] -rusti- application terminated with error code 101
[18:14:34] <joelteon> because I can't use extra::net_tcp::*;
[18:14:38] <joelteon> is there a syntax change I'm missing
[18:14:39] <olsonjeffery> cmr: well i was sick of spamming of the channel
[18:14:45] <cmr> joelteon: net_tcp doesn't exist
[18:14:46] <olsonjeffery> so i did it on my own rusti
[18:14:47] *** Quits: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch) (Quit: Leaving.)
[18:14:49] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[18:14:51] <joelteon> the docs say it does
[18:14:53] <joelteon> :(
[18:14:54] <cmr> olsonjeffery: rusti-the-bot isn't rusti-the-program
[18:14:54] <bstrie> joelteon: I think we removed that lib :P
[18:15:00] <cmr> joelteon: what docs?
[18:15:00] <bstrie> joelteon: we have a new net lib somewhere
[18:15:08] <jmgrosen> great, ICE D:
[18:15:09] <joelteon> static.rust-lang.org/doc/0.7/extra/net_tcp.html
[18:15:18] <bstrie> are you using 0.7?
[18:15:19] <olsonjeffery> rusti: struct Foo(int); trait Bar { fn baz(); } impl Bar for Foo { pub fn baz() {} } let f = Foo(1); f.baz();
[18:15:19] -rusti- <anon>:5:103: 5:111 error: type `main::Foo` does not implement any method in scope named `baz`
[18:15:19] -rusti- <anon>:5          struct Foo(int); trait Bar { fn baz(); } impl Bar for Foo { pub fn baz() {} } let f = Foo(1); f.baz();
[18:15:19] -rusti-                                                                                                                 ^~~~~~~~
[18:15:19] -rusti- error: aborting due to previous error
[18:15:20] <jmgrosen> joelteon, are you on 0.7 or master?
[18:15:21] -rusti- application terminated with error code 101
[18:15:26] <olsonjeffery> cmr: ^
[18:15:30] <joelteon> I'm on 0.7
[18:15:33] <joelteon> as far as I know
[18:15:37] *** Quits: paulproteus (quassel@rose.makesad.us) (Ping timeout)
[18:15:39] <bstrie> can you do a rustc -v
[18:15:40] <bstrie> ?
[18:15:46] <joelteon> rustc 0.7
[18:15:46] <jmgrosen> joelteon, then it's extra::net::tcp not extra::net_tcp
[18:16:04] <jmgrosen> but master doesn't have extra::net, so don't expect to use it at 0.8
[18:16:07] <joelteon> ok, that's also an unresolved import
[18:16:18] <bstrie> weird
[18:16:23] <bstrie> no idea then, sorry
[18:16:31] *** Joins: paulproteus (quassel@moz-E86A3B42.makesad.us)
[18:16:37] <bstrie> the old net lib is pretty bad to begin with, you're not missing out on much :)
[18:16:43] <jmgrosen> joelteon, is extra::net unresolved?
[18:16:44] <joelteon> https://gist.github.com/joelteon/6124616
[18:17:02] <cmr> joelteon: you don't need `extern mod std`
[18:17:06] <cmr> Or `use std::result::*`
[18:17:08] <joelteon> jmgrosen: yes
[18:17:18] <joelteon> cmr: old code :p
[18:17:20] <joelteon> I've removed it
[18:17:20] <cmr> `extern mod std` is injected automatically and Result is in the prelude
[18:17:30] <cmr> `std::net_tcp::TcpSocketBuf`
[18:17:39] <jmgrosen> joelteon, you want sock: TcpSocketBuf not std::net_tcp::TcpSocketBuf
[18:17:41] <cmr> `uv::global_loop::get`
[18:17:46] <jedestep> joelteon: one thing to note on 0.7 is that the new rt doesn't really work well enough to rely on std::rt::io::net
[18:17:46] <cmr> Erm, std::uv...
[18:17:48] <cmr> Both wrong
[18:17:58] <joelteon> right
[18:18:04] <joelteon> well, the error isn't there, it's at line 3
[18:18:04] <jmgrosen> it's extra::uv_global_loop
[18:18:08] <joelteon> use extra::net::*;
[18:18:13] <joelteon> which is an unresolved import now
[18:18:22] <jmgrosen> could you post the actual source?
[18:18:23] <jedestep> try use extra::net::tcp
[18:18:30] <joelteon> jmgrosen: that is the actual source
[18:18:34] * kimundi wonders why we even bother releasing git snapshots as pre-alpha versions
[18:18:39] <cmr> It definitely exists in 0.7
[18:18:40] <joelteon> i've updated the gist
[18:18:54] *** Quits: Vert (quassel@8A83479C.391ACC8C.CAF63861.IP) (Ping timeout)
[18:19:04] <joelteon> I downloaded it from dist/rust-0.7.tar.gz, I think that's rust 0.7 :P
[18:19:25] <joelteon> jedestep: that is also unresolved
[18:19:33] <jedestep> ?_?
[18:19:37] *** Joins: kertap (kertap@moz-ED81D7FF.b-ras3.mvw.galway.eircom.net)
[18:19:44] <jmgrosen> kimundi, me too, it ends up just confusing people
[18:19:54] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[18:20:22] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[18:20:33] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[18:21:10] <jmgrosen> any help with this ICE? https://gist.github.com/jmgrosen/2c44e12ee9a8ae64681f
[18:22:03] <jmgrosen> hm, guess it's a known bug: https://github.com/mozilla/rust/issues/7905
[18:22:49] *** Quits: jeff (jeff@moz-F81F6C4E.nyc.biz.rr.com) (Ping timeout)
[18:23:07] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[18:23:08] *** ChanServ sets mode: +o tjc
[18:23:10] *** Quits: brianm (brianm@D2D642B9.79695EE7.489C5759.IP) (Quit: Leaving...)
[18:23:13] <joelteon> heeeelp
[18:23:15] *** Quits: kertap (kertap@moz-ED81D7FF.b-ras3.mvw.galway.eircom.net) (Quit: kertap)
[18:23:20] <olsonjeffery> cmr: ah. my trait/impl syntax was off..
[18:23:33] <olsonjeffery> rusti: struct Foo(int); trait Bar { fn baz(&self); } impl Bar for Foo { pub fn baz(&self) {} } let f = Foo(1); f.baz();
[18:23:34] -rusti- ()
[18:23:49] <olsonjeffery> rusti: struct Foo(int); trait Bar { fn baz(&self); } impl Bar for Foo { pub fn baz(&self) {} } let f = Foo(1); let b: ~Bar = ~f;
[18:23:50] -rusti- <anon>:5:127: 5:129 error: mismatched types: expected `~main::Bar:Send` but found `~main::Foo` (expected trait main::Bar but found ~-ptr)
[18:23:50] -rusti- <anon>:5          struct Foo(int); trait Bar { fn baz(&self); } impl Bar for Foo { pub fn baz(&self) {} } let f = Foo(1); let b: ~Bar = ~f;
[18:23:50] -rusti-                                                                                                                                         ^~
[18:23:50] -rusti- error: aborting due to previous error
[18:23:52] -rusti- application terminated with error code 101
[18:24:05] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[18:24:07] <joelteon> https://gist.github.com/joelteon/de314b2d3f990b22c640 terminal output, https://gist.github.com/joelteon/6124616 the source
[18:24:10] *** Joins: bheylin (brianheyli@moz-8255E94E.adsl.online.nl)
[18:24:29] <engla> jmgrosen: does it compile if you take the slice by value?  as_uppercase(self) ?
[18:24:45] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[18:24:50] <olsonjeffery> rusti: struct Foo(int); trait Bar { fn baz(&self); } impl Bar for Foo { pub fn baz(&self) {} } let f: Bar = Foo(1);
[18:24:50] -rusti- <anon>:5:104: 5:107 error: reference to trait `Bar` where a type is expected; try `@Bar`, `~Bar`, or `&Bar`
[18:24:51] -rusti- <anon>:5          struct Foo(int); trait Bar { fn baz(&self); } impl Bar for Foo { pub fn baz(&self) {} } let f: Bar = Foo(1);
[18:24:51] -rusti-                                                                                                                  ^~~
[18:24:51] -rusti- error: aborting due to previous error
[18:24:52] -rusti- application terminated with error code 101
[18:25:18] <olsonjeffery> rusti: struct Foo(int); trait Bar { fn baz(&self); } impl Bar for Foo { pub fn baz(&self) {} } let f = Foo(1); let b: &Bar = &f;
[18:25:18] -rusti- <anon>:5:127: 5:129 error: mismatched types: expected `&main::Bar<no-bounds>` but found `&main::Foo` (expected trait main::Bar but found &-ptr)
[18:25:18] -rusti- <anon>:5          struct Foo(int); trait Bar { fn baz(&self); } impl Bar for Foo { pub fn baz(&self) {} } let f = Foo(1); let b: &Bar = &f;
[18:25:19] -rusti-                                                                                                                                         ^~
[18:25:19] -rusti- error: aborting due to previous error
[18:25:20] -rusti- application terminated with error code 101
[18:25:58] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[18:26:03] <engla> olsonjeffery: you need to cast it,, let b = &f as &Bar.
[18:26:07] *** Joins: jeff (jeff@moz-F81F6C4E.nyc.biz.rr.com)
[18:26:17] <olsonjeffery> rusti: struct Foo(int); trait Bar { fn baz(&self); } impl Bar for Foo { pub fn baz(&self) {} } let f = Foo(1); let b: &Bar = &f as &Bar;
[18:26:18] -rusti- <anon>:5:117: 5:118 warning: unused variable: `b` [-W unused-variable (default)]
[18:26:19] -rusti- <anon>:5          struct Foo(int); trait Bar { fn baz(&self); } impl Bar for Foo { pub fn baz(&self) {} } let f = Foo(1); let b: &Bar = &f as &Bar;
[18:26:19] -rusti-                                                                                                                               ^
[18:26:19] -rusti- ()
[18:26:22] <engla> that's the syntax at least. no idea if the object works
[18:26:32] <olsonjeffery> rusti: struct Foo(int); trait Bar { fn baz(&self); } impl Bar for Foo { pub fn baz(&self) {} } let f = Foo(1); let b: &Bar = &f as &Bar; b.baz();
[18:26:33] -rusti- ()
[18:26:44] <olsonjeffery> rusti: struct Foo(int); trait Bar { fn baz(&self); } impl Bar for Foo { pub fn baz(&self) {} } let f = Foo(1); let b: ~Bar = ~f as ~Bar; b.baz();
[18:26:45] -rusti- ()
[18:26:48] *** Joins: mcclurmc (mcclurmc@moz-8D61EFD1.cable.virginmedia.com)
[18:26:50] <olsonjeffery> brson: ping
[18:27:23] <kimundi> joelteon: That is strange
[18:27:28] *** Joins: Vert (quassel@8A83479C.391ACC8C.CAF63861.IP)
[18:27:42] <brson> olsonjeffery: pong!
[18:28:08] <olsonjeffery> brson: so it looks like 5192/~object is fixed on master ... so could we do that work to get rid of RtioFooTraitObject et al?
[18:28:09] <engla> the std::gc module, is it a fossil?
[18:28:11] <graydon> pcwalton: are you and pnkfelix working on separate or related Visitors?
[18:28:18] <pcwalton> graydon: separate. I'm nearly done with mine.
[18:28:31] <graydon> huh. that's .. weird. have you coordinated at all?
[18:28:41] <graydon> or is it just an accidental duplication
[18:29:20] <pcwalton> it's mostly accidental duplication
[18:29:30] <pcwalton> mine was a prerequisite for eliminating @fn
[18:30:07] <brson> olsonjeffery: yes! that would be fabulous
[18:30:35] <olsonjeffery> ok.. i guess ill put that on the list of things to do..
[18:30:37] <graydon> anyone mind if I run a snap?
[18:30:52] <olsonjeffery> aio is coming together nicely
[18:31:23] <joelteon> kimundi: yes, it is
[18:31:27] <olsonjeffery> i plan on doing the PR when i complete TcpStreamAsync and TcpListenerAsync
[18:31:33] <joelteon> if I install from HEAD is there still a TCP library?
[18:31:39] <cmr> joelteon: in std::rt::io::net
[18:31:46] <joelteon> ok, I might as well try that
[18:31:46] <cmr> http://hg.chrismorgan.info/rusthttpserver/ uses it
[18:32:14] <joelteon> no doc for thaht yet?
[18:32:25] <kimundi> joelteon: try replacing 'use extra::net::*;' with 'use extra::net::tcp::*;', 'use extra::net::ip::*;', 'use extra::net::url::*;'
[18:32:42] <cmr> kimundi: that didn't happen before 0.7
[18:32:45] <cmr> that was like last week
[18:32:49] <joelteon> kimundi: it's still an unresolved import
[18:33:00] <kimundi> cmr: the 0.7 tag on github says otherwise
[18:33:09] <kimundi> https://github.com/mozilla/rust/blob/release-0.7/src/libextra/net.rs
[18:33:12] <joelteon> updated the gist; i'm just using the first replacement
[18:33:21] <joelteon> because I only need TcpSocketBuf
[18:33:28] *** Joins: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net)
[18:33:29] <cmr> kimundi: I mean the remobal
[18:33:41] <cmr> https://github.com/mozilla/rust/blob/release-0.7/src/libextra/extra.rs#L43
[18:34:42] <kimundi> cmr: I'm... nort sure what you're trying to say? It might not exist today anymore, but this was about making the code worw with 0.7
[18:35:00] <cmr> kimundi: in 0.7 the primary way was net_tcp etc
[18:35:02] *** Joins: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP)
[18:35:20] <kimundi> cmr: which is also aliased as net::tcp
[18:35:23] <kimundi> in 0.7
[18:35:25] <cmr> Right
[18:35:32] <cmr> but using that instead isn't going to change the failure
[18:35:35] <olsonjeffery> brson: i did a lazy pull of extra::future into std:: and am using future::spawn, right now.. but when i add promises, we won't need to spawn a task because we can push the promise and its fulfillment into the async callback in the uvaio impl
[18:36:09] <graydon> brson nmatsakis pcwalton tjc anyone mind if I run a snap?
[18:36:12] *** Quits: jeff (jeff@moz-F81F6C4E.nyc.biz.rr.com) (Ping timeout)
[18:36:12] <olsonjeffery> i envision a sort of std::future::stream(); call that returns (Future<T>, Promise<T>), ala the (chan, port) convention
[18:36:13] <brson> graydon: no
[18:36:16] <tjc> graydon: please do!
[18:36:18] <pcwalton> graydon: +1
[18:36:25] <kimundi> cmr: what failure de you mean? I was just trying to guess where the error was :P
[18:36:33] <pcwalton> more default method fixes getting into stage0 makes my life easier
[18:36:39] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[18:36:41] <olsonjeffery> fun fun fun
[18:36:45] <cmr> kimundi: his import failure
[18:36:47] <sam113101> graydon: are you Graydon Hoare?
[18:36:50] <brson> olsonjeffery: ok, can you put it in std::unstable, which is where I currently prefer api's that I am not ready to commit to?
[18:36:52] <engla> I'm working on the low hanging fruits regarding removing  for + old iterator function  from std/extra
[18:36:54] <sam113101> the creator
[18:37:12] <graydon> sam113101: yup
[18:37:13] <olsonjeffery> brson: no problem
[18:37:20] <sam113101> cool
[18:37:22] * graydon uses THE CREATOR booming voice
[18:37:37] <Seldaek> graydon: you definitely need a tshirt with that name on it
[18:37:40] <kimundi> joelteon: Hm, I lot track... Deos it work now?
[18:37:44] <kimundi> lost*
[18:37:45] <graydon> (official belief: nobody creates anything; creativity is a myth, etc. etc.)
[18:38:14] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[18:38:14] <ghrust> 01[13rust01] 15graydon merged 06master into 06snap-stage3: 02http://git.io/tSBIeA
[18:38:14] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[18:38:18] <Seldaek> graydon: the initiator sounds less holy.
[18:38:19] *** Quits: lucian (lucian@moz-22A14C6A.cable.virginmedia.com) (Ping timeout)
[18:38:26] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[18:38:48] <cde> hi graydon 
[18:38:57] <graydon> cde: hello
[18:38:57] <paupau> rust is a platonic truth?
[18:39:18] <graydon> it's a family of pathogenic fungi. close though.
[18:39:21] <graydon> I can see how one would get them confused.
[18:39:28] <cde> graydon: considering the security issues that plague Linux; is it realist to considering writing a kernel in Rust?
[18:39:34] <cmr> cde: yes
[18:39:40] <cde> elaborate.
[18:39:44] <cmr> https://github.com/charliesome/rustboot and https://github.com/jmgrosen/shorai/
[18:39:47] <bblum> brson: https://github.com/mozilla/rust/pull/8158
[18:39:50] <kimundi> graydon: Hm... "That guy who initiated the causality chain that resulted in the current state of the language called Rust" doesn't have the same ring to it though ;)
[18:39:51] <cmr> I elaborate with source :p
[18:39:58] <cde> I see that. thanks
[18:40:14] <brson> bblum: thanks
[18:40:28] <graydon> depends what you mean by realistic. linux is several million lines of code. it strikes me as at least ... quite an immense amount of work to produce a kernel. realistic if you want to spend decades at it?
[18:40:30] <paupau> I need a rusty rock to contemplate stoically
[18:40:54] *** Quits: igl (igl@moz-6DEF9A2D.adsl.alicedsl.de) (Ping timeout)
[18:40:55] <cde> graydon: most of the code, I think, relates to unused drivers/filsystems/etc.
[18:41:06] <tjc> graydon: now that Linux has been written, though, rewriting it better shouldn't take as long :-)
[18:41:16] *** Joins: igl (igl@moz-6DEF9A2D.adsl.alicedsl.de)
[18:41:16] <olsonjeffery> tjc: famous last words!
[18:41:23] * kimundi is amused about how many people use three-char nicknames. 
[18:41:27] <sam113101> you should write Hurd in rust
[18:41:39] <graydon> yeah I think the unix idea has been written quite a number of times and it seems to get _harder_ each time, for some reason
[18:41:53] <tjc> But it's a fact that it's realistic to consider writing a kernel in Rust with less yelling and profanity than was involved in Linux ;-)
[18:42:08] <cde> sam113101: I had plans to write an operating systems, then realised had to move away from C, then started to design a language, realized it was exceedingly hard
[18:42:09] *** Joins: io2 (io2@moz-537A0266.home.otenet.gr)
[18:42:21] <olsonjeffery> tjc: is that why linus is the way he is? because of C?
[18:42:23] <sam113101> kimundi: told myself the same thing, "looks like #rust is a haven for 3-chars nicknames"
[18:42:26] <paupau> kimundi: I have two middle names, soâ€¦ :)
[18:42:29] <tjc> olsonjeffery: I wouldn't dare speculate
[18:42:30] <Seldaek> kimundi: if by amusing you mean confusing as hell, sure :p
[18:42:35] <paupau> kimundi: oh wait, wrong nick, disregard
[18:42:43] <bstrie> io2: hello there :)
[18:42:46] <tjc> I was more thinking of community norms :-)
[18:43:15] <olsonjeffery> something something social relativism
[18:43:17] *** Joins: jeff (jeff@moz-F81F6C4E.nyc.biz.rr.com)
[18:43:18] <doomlord> heh. 3 char nicks, 3char keywords..
[18:43:20] <io2> hello bstrie
[18:43:31] <graydon> unix 2046 will be incredibly complex. but it will still contain references to teletype model 33 ASRs.
[18:43:55] * kimundi dares anyone here to change his nick to 'mut'
[18:44:00] *** cmr is now known as mut
[18:44:01] <paupau> theoretically you could write a C->unsafe{Rust} converter and then begin the great kernel transitionâ€¦ good luck with all those macros though
[18:44:16] <mut> paupau: A lot of it is GCC-isms too
[18:44:34] *** Quits: Earnestly (earnest@CAE8D902.48DC5685.39C00A7A.IP) (Quit: WeeChat 0.4.2-dev)
[18:44:35] *** Joins: Earnestly (earnest@CAE8D902.48DC5685.39C00A7A.IP)
[18:44:36] <sp3d> container_of sounds like great fun
[18:44:37] <bblum> kimundi: or her nick
[18:44:37] <kimundi> mut: Keep it up for a day and count how often you get accidentally pinged :D
[18:44:47] <kimundi> bblum: sure, sure
[18:45:03] <doomlord> heh. imagine trrying to write something to factor out things like x-macros and turn them into reflection
[18:45:08] *** Quits: webber46 (webber46@moz-717E9C5B.cust.bredband2.com) (Quit: webber46)
[18:45:10] <doomlord> i'll pass on that
[18:45:12] <bstrie> I feel so bad for mut on github
[18:45:13] <brson> have a lot of pull requests to review today
[18:45:13] <bstrie> and mut on twitter
[18:45:29] *** mut is now known as cmr
[18:45:38] <tjc> heh
[18:45:43] <cmr> "NickServ (services@mozilla.org): This nick is owned by someone else.  Please choose another."
[18:45:45] <cmr> :(
[18:45:49] <kimundi> haha
[18:45:50] *** paupau is now known as fn
[18:46:09] <bstrie> cmr: as you can see, rust has very strict ownership policies on mutable data
[18:46:12] <Seldaek> makes me think.. why isn't the fn keyword fun? :/
[18:46:26] <tjc> I have a lot of fun not typing 'u', personally
[18:46:30] <bstrie> Seldaek: becase rust is a Serious Language and fun is a distraction
[18:46:31] <cmr> me too
[18:46:37] <fn> Seldaek: maybe it should be f'n :)
[18:46:40] <kimundi> Seldaek: Who needs vowels :P
[18:46:47] *** Quits: brson (brson@8ECA0B87.AD77F8DE.D1E74241.IP) (Quit: Lost terminal)
[18:46:48] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Ping timeout)
[18:46:51] <kmc> the grammar should allow anything matching fu+n
[18:47:04] <Seldaek> haha
[18:47:13] <kmc> and provide the number of 'u's as an attribute
[18:47:15] <sp3d> f.*n
[18:47:17] <sam113101> f(unction)+
[18:47:34] <bstrie> functionunction
[18:47:41] <doomlord> function  func  fun  fn  defn  defun  def fn  .. which is best..
[18:47:47] *** Joins: brson (brson@8ECA0B87.AD77F8DE.D1E74241.IP)
[18:47:48] *** ChanServ sets mode: +o brson
[18:47:51] <Seldaek> kimundi: yeah, pb md { pb fn prntln() {} }, that's the io mod, but you can't see it!
[18:47:53] <cmr> "void"
[18:47:54] <sam113101> fn obviously
[18:48:01] <tjc> someone's nick is fn, apparently
[18:48:04] <fn> halp
[18:48:06] <tjc> heh
[18:48:09] <kimundi> funny little memory doodad Foo(&uint) -> bool
[18:48:25] <fn> maybe one of those ligature-y Fs
[18:48:37] *** Joins: barosl (barosl@E287D94F.C81E10FB.7544CABF.IP)
[18:48:38] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[18:48:38] *** ChanServ sets mode: +o dherman
[18:48:42] <kimundi> Å¿n Foo()
[18:49:12] <kimundi> wait, that's an S
[18:49:38] <bstrie> I also don't think it would make sense unless it were `sÅ¿n foo()`
[18:49:46] <Seldaek> it's good that this channel/community is still small enough to allow for nonsensical discussions. we should +i the chan before it gets too serious :p
[18:49:52] <cmr> heh
[18:50:14] <brson> struct UUID or struct Uuid? I've been pushing for the Uuid style and will probably ask it to be renamed to not use all caps. We really need documented coding conventions
[18:50:16] <sp3d> "fn" is used in code, "fun" is limited to the IRC channel
[18:50:22] <bstrie> brson: I like Uuid
[18:50:30] <tjc> Seldaek: IME, nonsensical discussions are directly correlated with channel size :-)
[18:50:33] <kmc> fun fact 0 = 1
[18:50:35] <cmr> brson: https://github.com/mozilla/rust/wiki/Note-style-guide
[18:50:38] <kimundi> "You need at least two http://quotes.burntelectrons.org/ to be allowed to talk in the main #rust channel"
[18:50:48] <bstrie> brson: didn't we also recently rename ARC to Arc?
[18:50:49] <brson> cmr: yeah, I wrote most of those, and they are lacking
[18:50:50] *** Quits: heftig (heftig@1103CD12.9A77AED9.3663C14F.IP) (Ping timeout)
[18:50:50] * graydon dreams of the day I can write the FAQ entry: "Q: why is $syntax written using $form rather than $equivalent, A: because of a horrible mistake that is now set in stone as the syntax is frozen."
[18:51:20] <kmc> only two kinds of languages: those people complain about and those nobody uses
[18:51:26] <bstrie> graydon: that would be heaven
[18:51:30] *** Quits: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net) (Ping timeout)
[18:51:45] *** Joins: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net)
[18:51:48] <bstrie> graydon: in the meantime let me bug you about ::<> again... :)
[18:51:51] <kimundi> graydon: You mean as opposed to the horrible situation now where people still see a chanch of actually changing them?
[18:51:56] <graydon> it's unfair. sometimes those things do result in improvements.
[18:52:03] <graydon> just gets tiring.
[18:52:07] <kimundi> :)
[18:52:12] <graydon> bstrie: what about ::<>? do you have a new solution for it?
[18:52:23] <brson> lol
[18:52:25] <cmr> pcwalton had one
[18:52:26] <bstrie> graydon: absolutely not
[18:52:34] <cmr> using foo::<'a, T>::bar::<C>()
[18:52:34] <kimundi> âŸ¨âŸ© ftw!
[18:52:45] <cmr> instead of tacking them all on the end
[18:52:51] <cmr> maybe that was nmatsakis
[18:52:51] <bstrie> I'm just here to register my disapproval in an unconstructive way!
[18:52:54] <brson> poor graydon
[18:52:59] <graydon> ah ok. registered!
[18:53:03] <cde> :)
[18:53:09] <bstrie> I am mollified
[18:53:43] <pcwalton> we discussed the foo::<T>::bar thing in vancouver, I should add that to my board
[18:53:56] <kmc> clearly rust needs the 'typename' keyword
[18:54:09] <bstrie> graydon: also I think from experience with other BDFLs (whether or not you consider yourself one) people expect you to promptly stomp on discussions that aren't to your liking, so leniency is interpreted as approval
[18:54:29] <doomlord> you need to write ::<T> to disambiguate that unlike c++ templates, right? but in most situations you dont, because the pat:type disambiguates? it seems ::<T> is a lesser evil that hardly ever surfaces with the type inference
[18:54:49] <kimundi> pcwalton: Imo it makes more sense to have those annotations next to the path element where they are introduced, rather than all at the end.
[18:54:59] <pcwalton> yes
[18:55:00] <bstrie> doomlord: you only need the ::<T> when the type is ambiguous, true
[18:55:02] <kmc> agreed
[18:55:43] <doomlord> i would actually accept some dumb rules about where you can use < and > aswell if it came down to it.
[18:55:57] <cmr> What did vec::as_const_buf run off to?
[18:56:00] <cmr> *where
[18:56:05] <doomlord> or maybe "operator ?> and ?<" as disambiguating alternatives for gt/lt tests perhaps..
[18:56:17] <bstrie> doomlord: I think pcwalton had a proposal for expanded type ascription syntax that would make the ::<T> even less necessary
[18:56:40] *** Joins: brianm (brianm@moz-804E164A.hsd1.ca.comcast.net)
[18:56:47] <bstrie> doomlord: my own proposal was to eliminate the less-than operator, because it's logically equivalent to !>= :)
[18:57:11] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[18:57:20] *** ozten is now known as ozten|afk
[18:57:36] <doomlord> maybe you could use .< >  , but its asymetrical with the rest of the path stuff
[18:57:37] <cmr> Ah, it died, in favor of as_imm_buf
[18:57:53] <doomlord> foo.<T>
[18:57:58] <bstrie> doomlord: honestly messing with the lt and gt operators is probably language suicide for people coming from a C background
[18:58:06] <bstrie> same for changing `&&` to `and` and so on
[18:58:22] <bblum> what's wrong with ::<T>?
[18:58:25] <bblum> it's just ugly?
[18:58:31] <bstrie> bblum: yeah, just ugly
[18:58:33] <kimundi> bblum: That's about it
[18:58:37] <doomlord> "error: < is ambiguous . disambiguate with .< or ?<"
[18:59:02] <doomlord> "or by wrapping in parentheses to seperate from potential match with >"
[18:59:04] <bstrie> doomlord: eh, ?<T> is also pretty ugly :)
[18:59:09] <bblum> we should use # obviously
[18:59:10] <kmc> it would be really odd for Rust to ditch < > && || and yet keep curly braces even though it's expression-oriented
[18:59:28] * bstrie hugs the curly braces
[18:59:35] <doomlord> a?<b for tests ... . foo.<T> for templates ..
[18:59:47] * bstrie throws tomatoes at doomlord
[19:00:02] <kimundi> Gcâ‡Tâ‡’
[19:00:04] <tjc> a islessthan b
[19:00:14] <bblum> tjc: andalso
[19:00:15] * kimundi prepares to dodge tomatoes as well
[19:00:16] <doomlord> hehe is now the time to mention ?= instead of ==
[19:00:20] <tjc> bblum: That was what inspired me, yes
[19:00:31] <Reisen> Hey, was just reading pcwalton's mailing list post on overloaded *, the Gc<T> example got me wondering though
[19:00:34] <bblum> tjc: foo instantiatedat <T>
[19:00:39] <engla> GcÂ«TÂ»
[19:00:42] <Reisen> If there will be custom smart pointers, who will functions taking &T as an argument work?
[19:00:49] *** Joins: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com)
[19:00:55] <Reisen> how*
[19:00:59] <tjc> bblum: foo instantiatedwiththefollowingtypeparametersplease <T, U, V>
[19:01:01] <pcwalton> custom smart pointers can be borrowed to references
[19:01:09] <bstrie> Reisen: we plan to have magic traits that allow you to autoborrow types that implement them, same as current pointers
[19:01:20] <pcwalton> bstrie: the idea was that Deref would be that magic trait
[19:01:21] <bblum> tjc: foo instantiatedwiththefollowingtypeparameterspleasesorryifitsinconvenientforyou <T, U, V>
[19:01:25] <tjc> haha
[19:01:25] <bstrie> ah ok
[19:01:32] <pcwalton> and they're held alive as long as the borrow lasts
[19:01:32] <Reisen> I see, so anything implementing a certain trait can be passed to something as &T? I did understand that right?
[19:01:44] <doomlord> foo<:T:>  /* configure your text editor to display it as unicode alternative..
[19:01:47] <tjc> foo instantiatedwiththefollowingtypeparametersifyoudontmindbutifyoudoilljustsitherebeingmonomorphicitsokay <T, U. V>
[19:01:54] <pcwalton> I didn't consider the autoborrow case but I guess Deref could work there too.
[19:02:15] <kimundi> Hehe: Gcâ‰¤Tâ‰¥
[19:02:17] *** Joins: heftig (heftig@8DB4145A.5C7D981D.FEC4A986.IP)
[19:02:29] <bstrie> pcwalton: you mention that servo is growing its own smart pointers, are these things that would be useful in std or extra?
[19:02:31] <bblum> kimundi: good one
[19:02:38] <pcwalton> not really for the most part
[19:02:42] <pcwalton> they're things like JsManaged
[19:02:46] <kmc> engla: no don't take Â«Â», I use those to quote code within natural language
[19:02:53] *** Quits: brianm (brianm@moz-804E164A.hsd1.ca.comcast.net) (Ping timeout)
[19:03:05] *** Joins: brianm (brianm@moz-804E164A.hsd1.ca.comcast.net)
[19:03:12] <kmc> bstrie: Servo will definitely have some specialized ones, like "pointer to object managed by SpiderMonkey GC"
[19:03:16] <kmc> may also have some general ones
[19:03:21] <doomlord> foo<|T|>
[19:03:45] <cmr> doomlord: Hm, I don't mind that and <:T:> at all
[19:03:50] <bblum> kmc: natural language code huh? fn main() { println(fmt!("%s", Â«find a proof of the collatz conjectureÂ»)); }
[19:03:51] <bstrie> pcwalton: I would read a blog post describing the custom smart pointers in servo, and why this demands that a language should treat library-defined pointers as first-class
[19:03:59] *** Quits: fn (textual@FFAF02D4.F5573215.F20F0C5A.IP) (Quit: out)
[19:04:05] <kmc> bblum: haha, that's inside out from what I meant ;)
[19:04:15] <kimundi> GcâŒˆTâŒ‹
[19:04:21] <engla> kmc: I'm assuming all the suggested syntaxes were jokes
[19:04:25] <kmc> me too
[19:04:28] <bblum> kmc: but better
[19:04:50] <pcwalton> bstrie: I wouldn't say "a language" -- not every language needs to be designed for Servo -- but why Rust does, certainly
[19:04:58] <pcwalton> I was thinking about writing one about how Rust's unique pointers aren't so unique
[19:05:04] <pcwalton> C++11 started the trend, we're just followers
[19:05:22] <bstrie> yes, I saw that tweet
[19:05:25] <kmc> I think smart pointers are a compelling feature for anything in the C++ niche, since they're one of the best features of C++
[19:05:30] <bblum> pcwalton: but on the other hand our borrowed pointers are not borrowed, because we came up with those ourselves
[19:05:42] <kmc> and there just isn't a lot of language diversity in that niche to say that no, we have some alternative to smart pointers
[19:05:50] <doomlord> How about disambiguating with the variable names: single-letter uppercase is only allowed as generic params, and nothing else..
[19:05:51] <bstrie> bblum: well we stole them from the literature, so are they stolen pointers?
[19:05:59] <kmc> they should be cited pointers
[19:06:01] <bblum> bstrie: that could be
[19:06:24] <pcwalton> http://dlang.org/phobos/std_typecons.html#.Unique
[19:06:26] <pcwalton> D has them too
[19:06:42] <kimundi> Hm... cited pointers
[19:06:48] <kimundi> Gcâ‚
[19:06:54] <kimundi> (1: T)
[19:06:56] *** Quits: brianm (brianm@moz-804E164A.hsd1.ca.comcast.net) (Ping timeout)
[19:07:55] <cmr> zmq.rc:201:8: 216:9 error: failed to find an implementation of trait std::clone::Clone for SocketType
[19:07:57] <kimundi> "All generic type parameters need to be noted in the footnote section of your sourcefile"
[19:07:57] <cmr> zmq.rc:201         do getsockopt_int(self.sock, constants::ZMQ_TYPE).map |&ty| {
[19:08:08] <cmr> That error in especially bad
[19:08:11] <tjc> bstrie: good artists copy, great artists steal
[19:08:21] <cmr> Completely non-obvious why it is being raised
[19:09:25] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Ping timeout)
[19:10:00] <bblum> aatch: ping
[19:10:46] <cmr> rusti: "aâ‰¥b".len()
[19:10:48] -rusti- 5
[19:10:50] *** Quits: busylizzy (lisa@85228838.12D0DC84.211374C4.IP) (Ping timeout)
[19:11:32] <doomlord> Foo<T,>
[19:11:49] <doomlord> Foo<A,B>  Foo<A,> Foo<A,B,C>
[19:12:00] *** Joins: busylizzy (lisa@85228838.12D0DC84.211374C4.IP)
[19:12:44] <doomlord> Foo<A> "error ambiguous syntax. Write Foo<T,> to disambiguate"
[19:13:30] <brson> is `from_foo` currently the accepted way to name a constructor that is a conversion? do we not prefer `new_from_foo`?
[19:13:35] <cmr> doomlord: that's not bad either
[19:14:02] <bstrie> doomlord: I think that still requires unbounded lookahead, which is what we're trying to avoid
[19:14:31] <joelteon> does TcpSocketBuf exist in HEAD?
[19:14:38] * brson going to write this stuff down in the style guide
[19:14:43] <doomlord> personally i'm happy with it the way it is, seeing the unambiguous syntax makes me happy
[19:15:03] <bstrie> yes, honestly after seeing all these joke proposals I finally understand just how bad it *could be*
[19:15:11] <bstrie> so I retract my denigration for the moment
[19:15:33] <cmr> Personally I don't mind ::<T>
[19:15:34] <brson> it does seem to be the case that we have different conventions for constructors and for converting constructors
[19:15:47] <kmc> kimundi: huh in all seriousness, superscripts for lifetimes would be pretty cool (if we used rich text editing for code)
[19:15:54] <Seldaek> bstrie: indeed, it's really not awful, and as I understand it you can also fix it by setting a pattern on whatever receives the value of the call to help the compiler, if you really hate ::<T>
[19:15:59] <bstrie> brson: you mean like https://github.com/mozilla/rust/issues/7087 ?
[19:16:16] <brson> bstrie: nice
[19:16:18] <kimundi> kmc: A lot of cool things could be done if we used unicode for programm code
[19:16:22] <joelteon> there aren't any docs for std::rt::io :(
[19:16:36] <doomlord> could you just have 2 completely different syntaxes for standard and extended character sets
[19:16:46] <kmc> well Rust source is Unicode, it's just a pain to enter most Unicode characters for most people
[19:17:06] <kimundi> joelteon: In general the docs are useless, look in the source or ask here :)
[19:17:11] <kmc> Agda uses non-ASCII characters pervasively and has its own fancy Emacs mode for entering them (but also, they want the fancy Emacs mode for interactive proofs anyway, so it's more justified?)
[19:17:15] <joelteon> ok
[19:17:42] <pauls> doomlord: x-macros work in Rust!
[19:17:46] <tikue> hey strcat is there an interleave method for iterators? iterA.interleave(iterB) ==> ABABABABAB
[19:17:56] <kmc> GHC allows non-ASCII substitutions for some syntax (e.g. â†’ for ->, âˆ€ for forall) but it's more of a party trick than anything else 
[19:18:08] <jack> strcat: is there something like cycle() but that cycles among several iterators until exhaustion of all instead of from elements infinitely?
[19:18:34] <jack> strcat: and if not, are there objections to adding such a thing?
[19:18:40] <kimundi> jack: chain?
[19:18:55] *** sam113101 is now known as sam113101_afk
[19:18:55] <tikue> kimundi: chain does one until exhaustion, then the next
[19:19:02] <jack> kimundi: i want them interleaved.
[19:19:07] <kimundi> ah
[19:19:14] <tikue> kimundi: jack and I are looking for something that does one from each, until all are exhausted
[19:19:18] <engla> strcat: I'm working on removing  for + internal iteration from std and extra. Exception being  range() and .advance
[19:19:46] *** sam113101_afk is now known as sam113101
[19:20:08] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[19:21:41] *** Quits: io2 (io2@moz-537A0266.home.otenet.gr) (Quit: )
[19:22:34] <toddaaro> brson: test passed finally! It looks like comm.rs not checking the return of schedule_task was in fact the problem
[19:22:43] <brson> toddaaro: woo!
[19:22:51] <toddaaro> brson: I'm going to clean up that path and write a higher-level interface for use outside sched.rs
[19:23:04] <toddaaro> so PR soonish
[19:24:25] <doomlord> is a restriction on variable names just evil?   all typeparams= uppercase, single char,and nothing else can use those
[19:24:45] <cmr> doomlord: I find style restrictions like that repulsive
[19:25:26] <kmc> I dislike the general idea that type variables should only be one letter even if you have 10 of them
[19:25:27] <doomlord> flipside is, single letter idents are only really good for locals.. and they're usually used for type-params, which are also locals really
[19:25:43] <kmc> doomlord: I don't really see them as "locals"
[19:25:52] <doomlord> arguments rather
[19:26:02] <kmc> impl Foo<A,B,C> { ... 10 methods and 1000 lines of code ... }
[19:26:03] <engla> what's the reason to restrict them to 1 letter?
[19:26:05] <doomlord> ... and in rust they've got traits to further qualify them
[19:26:06] <kmc> not very local
[19:26:15] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Textual IRC Client: www.textualapp.com)
[19:26:21] <kmc> one thing that pisses me off about Haskell is the obsession with 1-letter variable names
[19:26:28] <kmc> I blame the mathematicians ;)
[19:26:53] <kmc> who also produced this travesty http://en.wikipedia.org/wiki/Mathematical_Alphanumeric_Symbols
[19:27:10] <doomlord> my suggestion was to use the type-param-names to disambiguate the syntax - by dissalowing single-upper-case ident names everywhere else
[19:27:37] <kmc> I think an impl of Map<Key, Val> which can refer to Key and Val is more readable than if it can only use K and V
[19:27:58] *** Joins: jgilbert (jgilbert@moz-BBE3ABD.mv.mozilla.com)
[19:28:15] <kmc> and there are plenty of more exotic generic things with parameters not nearly as obvious as K and V
[19:28:48] <jack> kmc: like NR ? :)
[19:28:51] <kmc> :D
[19:29:05] <jack> it's funny because i'm review your PR right now and noticed that immediately. 
[19:29:23] <strcat> tikue: not really atm, there could be
[19:29:26] <jack> i think associated items will fix those type sigs.
[19:29:32] <kmc> perhaps
[19:29:50] <jack> strcat: naming suggestions? do you like interleave()?
[19:30:08] <strcat> not sure
[19:30:10] <mark_edward> kmc: or like T and U ! what does this do: fn i_do_things<T,U>(t: T) -> U
[19:30:14] <strcat> btw about the cycle thing, is chain what you want?
[19:30:16] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: zzzzzzzzzz)
[19:30:41] *** Quits: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP) (Quit: ChatZilla 0.9.90.1 [Firefox 24.0a2/20130726004002])
[19:30:50] <jack> strcat: given iterators A, B, C, i want ABCABCABABBBBB, not AAAABBBBBBBBCC
[19:31:10] <bstrie> doomlord: enforcing single-character anything isn't going to work, because we allow unicode identifiers
[19:31:14] <engla> mark_edward: what's wrong with T and U? Without bounds they are clearly generic type parameters
[19:31:27] <strcat> jack: ah
[19:31:31] *** Quits: sebcrozet (sebcrozet@moz-F96421F3.w80-13.abo.wanadoo.fr) (Client exited)
[19:31:47] <jack> strcat: so it's like chain, except for the ordering
[19:31:48] <bstrie> jack: what do other languages name this?
[19:31:55] <bstrie> or is this entirely idiosyncratic?
[19:32:06] <bstrie> like, does python itertools have a term for this?
[19:32:14] <sp3d> "mingle"?
[19:32:17] <mark_edward> engla: nothing in very general cases like ~[T]. but when i'm  staring at huge C++ programs with template<class T> everywhere and constraints hidden in the code
[19:32:22] <mark_edward> it's not too good
[19:32:23] <doomlord> ok well from what i've seen, i'm happy with it the way it is with HashMap::<Key,Val.> so you cant go wrong whatever you do else.. imo its a non issue with the type inference being so good
[19:32:45] <bstrie> doomlord: yeah, with type inference it's really not so bad
[19:33:36] *** ozten|afk is now known as ozten|burritofied
[19:33:40] *** ozten|burritofied is now known as ozten
[19:33:50] <doomlord> is it possible to disambiguate it infront,  :HashMap<Key,Value>   ... ":"means type follows...
[19:33:59] *** Joins: bstrie|unicode (Mibbit@moz-D5A1D0F5.members.linode.com)
[19:34:07] <bstrie|unicode> kmc: ð–†ð–ˆð–™ð–šð–†ð–‘ð–‘ð–ž, ð•´ ð–™ð–ð–Žð–“ð– ð–™ð–ð–Šð–˜ð–Š ð–†ð–—ð–Š ð–Œð–—ð–Šð–†ð–™
[19:34:29] <doomlord> oh it could be generic functions too perhaps
[19:34:36] *** Quits: bstrie|unicode (Mibbit@moz-D5A1D0F5.members.linode.com) (Quit: http://www.mibbit.com ajax IRC Client)
[19:34:59] <doomlord> HashMap<:Key,:Value>
[19:35:11] <doomlord> HashMap<K,V>
[19:35:26] <tikue> strcat: is there a way to return a generic iterator from a function without exposing implementation details
[19:35:32] <doomlord> silly edgecase rules probably
[19:35:41] <strcat> tikue: define a type
[19:35:45] <cmr> tikue: fn foo<T>() -> Iterator<T> ?
[19:35:55] <cmr> wait no
[19:35:55] <strcat> you can't do that
[19:35:57] <kimundi> bstrie: I see a bunch of boxes. From that I infer that you're writing in math letters?
[19:36:04] <strcat> you can define a type with a private field
[19:36:05] <cmr> tikue: fn foo<T, U: Iterator<T>>() -> U?
[19:36:07] <tikue> strcat: define a type?
[19:36:09] <kmc> GNU Screen doesn't support non-BMP characters :(
[19:36:19] <engla> strcat: does the type even have to be public?
[19:36:30] <tikue> cmr: well I don't mean that it's actually generic
[19:36:32] <strcat> engla: well it would be inconvenient if it wasn't
[19:36:43] <tikue> cmr: I mean that I want Iterator<Foo> 
[19:36:56] <tikue> cmr: but I have a type mismatch because I'm returning ChainIterator<Blahblahblah>
[19:36:58] <strcat> tikue: define a struct
[19:37:04] <bstrie> kimundi: you're just not mathematical enough to perceive them
[19:37:07] <bstrie> sry :(
[19:37:19] <tikue> strcat: but how do I get from chain iterator to the struct?
[19:37:22] <engla> tikue: to erase the type you need a Trait object, for example ~Iterator<T>
[19:37:30] <strcat> tikue: put it in the struct?
[19:37:45] <tikue> strcat: I'm sorry, I don't follow
[19:38:07] <strcat> struct Foo { priv field: implementation_details }
[19:38:19] <tikue> strcat: and just change that whenever the implementation changes?
[19:38:25] <strcat> yes, it's private
[19:38:38] <sully> ok, _match.rs
[19:38:41] <sully> I am afraid
[19:38:44] <tikue> strcat: then I'd have to define next() and everything on that struct?
[19:39:03] <strcat> just next()
[19:39:15] <tikue> ok
[19:39:16] *** Quits: Florob (Florob@moz-39532932.de) (Client exited)
[19:39:17] <strcat> and you would just be calling the one inside
[19:39:30] *** Joins: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch)
[19:39:31] <doomlord> heh. hell, maybe you could actually allow optional header files to disambiguate the template symbols :)
[19:39:39] *** Quits: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch) (Connection reset by peer)
[19:39:50] *** Joins: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch)
[19:39:51] <strcat> what do headers have to do with it?
[19:39:56] <tikue> strcat: right. for my own enlightenmentâ€¦what makes it difficult to simply return ~Iterator<MyFoo>
[19:40:05] *** Joins: sebcrozet (sebcrozet@moz-7FB6C00B.w193-252.abo.wanadoo.fr)
[19:40:16] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[19:40:19] <strcat> tikue: nothing makes that difficult, if you're okay with each step of iteration being a virtual method call then do that
[19:40:20] <doomlord> dont headers  tell it if a symbol is a template or not in C++
[19:40:34] <strcat> tikue: it will be several orders of magnitude slower
[19:40:40] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[19:40:43] <tikue> strcat: oh, I see
[19:40:44] <strcat> 100x, 1000x, 10000x
[19:40:51] <tikue> haha
[19:41:11] <doomlord> so basically thats the tradeoff, c++ caan sometimes make simpler looking syntax, at the expense of needing headers
[19:41:11] <strcat> without a trait object the size is exposed
[19:41:18] <strcat> so it needs to know a real type
[19:43:46] <strcat> doomlord: templates are still symbols
[19:44:15] <strcat> you can export instantiations from a translation unit
[19:45:12] *** Joins: rustyPipe (Mibbit@moz-5949C51B.dllstx.fios.verizon.net)
[19:45:53] *** Quits: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu) (Ping timeout)
[19:46:20] <rustyPipe> Could someone explain the difference between enum variants that have parameters and enum variants that are structs?
[19:46:50] <bblum> rustyPipe: the latter is a newer feature and more likely to have bugs
[19:47:03] <bblum> apart from that they are functionally equivalent; the structs let you name the fields
[19:47:11] <kimundi> rustyPipe: Do you mean tuple like enums and struct like enums?
[19:47:25] <cmr> kimundi: variants, not enums
[19:47:32] *** Quits: pyrac (pyrac@moz-F28B7CAD.w90-55.abo.wanadoo.fr) (Quit: pyrac)
[19:47:42] <kimundi> cmr: That's what I mean
[19:47:48] <cmr> Well SWYM :P
[19:47:54] <rustyPipe> Is there any advantage with having the ability to name fields?
[19:48:14] <cmr> rustyPipe: enum Foo { Bar(uint, uint, uint, int, int, ~str) }
[19:49:00] <bstrie> rustyPipe: you have to `match` to get data out of tuples, but you can get data out of structs with `foo.bar`
[19:50:45] *** Quits: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch) (Ping timeout)
[19:50:53] *** Joins: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch)
[19:51:12] *** Quits: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch) (Max SendQ exceeded)
[19:51:17] <rustyPipe> Oh, so when pattern matching, you don't need to mention the types of specific fields, as the compiler can reuse the field name as the binding name, right?
[19:51:45] *** Joins: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch)
[19:53:20] <cmr> rustyPipe: yup
[19:54:12] <tedh> whats the foreach equivalent of `for uint::range(0u, n) |i|' ?
[19:54:30] *** Quits: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch) (Connection reset by peer)
[19:54:53] <Sergio965> foreach?
[19:55:26] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[19:55:26] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/A1iyUw
[19:55:26] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[19:55:43] <tedh> Sergio965: https://github.com/mozilla/rust/commit/6296dc0d73527301f18ef55b5f2d07c3241b8a00
[19:55:49] <kimundi> Sergio965: He means external iterators
[19:56:11] *** Joins: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch)
[19:56:57] <Sergio965> Now there's a "foreach"? Bah.
[19:57:17] <bblum> Sergio965: it's transitional
[19:57:47] <tedh> foreach is temporary as we transition to for moving to external iterators
[19:57:54] <bstrie> Sergio965: http://www.reddit.com/r/rust/comments/1jf1mt/foreach_in_a_basic_sketch_of_the_new_forloop/cbe09g3
[19:58:23] <Sergio965> I see.
[19:58:24] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[19:58:24] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/1Me86Q
[19:58:24] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[19:58:25] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[19:58:25] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/XEt4AQ
[19:58:25] <ghrust> 13rust/06auto 14c725926 15BjÃ¶rn Steinbrink: Reduce code bloat from assert!()...
[19:58:25] <ghrust> 13rust/06auto 1466a0b58 15bors: auto merge of #8150 : dotdash/rust/assert_bloat, r=huonw...
[19:58:26] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[19:58:43] <Sergio965> So "foreach" encapsulates the new external iterator syntax that will be used in "for"?
[19:58:59] <tedh> yes
[19:59:09] <Sergio965> Sounds good.
[20:00:12] *** Joins: dim-an (ermolovd@moz-FE167E47.nationalcablenetworks.ru)
[20:00:49] <cmr> Lack of hygiene in C macros is obnoxious
[20:00:52] *** Joins: pyrac (pyrac@moz-F28B7CAD.w90-55.abo.wanadoo.fr)
[20:00:52] * cmr misses rust
[20:01:18] *** Quits: Ms2ger (Ms2ger@moz-BA3429A8.adsl-dyn.isp.belgacom.be) (Quit: nn)
[20:01:20] <Sergio965> Man.
[20:01:21] <Sergio965> C is amazing.
[20:01:55] *** Quits: ecr (Thunderbir@moz-F724119C.uoregon.edu) (Quit: ecr)
[20:02:23] *** Quits: lkuper (lkuper@FBBF6446.A402E718.C082B7DC.IP) (Quit: lkuper)
[20:02:38] <doomlord_> c was the right hack at the right time
[20:02:55] *** Joins: LU324 (quassel@9AF4F288.83671C58.1B5D53D7.IP)
[20:03:13] <engla> tedh: no range() iterator exists so far
[20:03:15] *** Joins: seth (seth@moz-BE33DA21.fw1.sfo1.mozilla.net)
[20:03:26] *** Quits: LU324_ (stuff@moz-A17E9A7B.dyn.embarqhsd.net) (Quit: LU324_)
[20:03:42] <tedh> ok, thanks
[20:03:50] <engla> it's easy to make
[20:04:48] <joelteon> how do I create an empty mutable vector?
[20:04:54] <cmr> joelteon: ~[]
[20:06:04] <graydon> https://github.com/mozilla/rust/issues/8161 for anyone in a light hearted mood
[20:06:23] <graydon> Sergio965: 'foreach' is transient. when we finish rewriting we'll switch the name back to 'for'
[20:06:27] <graydon> Sergio965: self-hosting :(
[20:06:31] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[20:07:30] <joelteon> cmr: of course...
[20:07:37] <joelteon> cmr: I was just writing my assignment wrong, heh
[20:07:41] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Quit: WeeChat 0.4.1)
[20:07:43] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[20:07:52] <joelteon> next question! does uv::global_loop::get() still exist somewhere? I can't find it
[20:08:44] *** Quits: fabiand (fabiand@moz-F19FC30D.adsl.alicedsl.de) (Quit: Verlassend)
[20:08:49] <joelteon> or do I just create a new loop of my own?
[20:09:16] <bstrie> graydon: I propose "rustc wtf" for the disapproval case
[20:09:40] <joelteon> actually, I should probably walk up my question dependency tree a bit
[20:09:54] <joelteon> std::net_ip::get_addr used to require a UV loop, but I can't even find that function now
[20:10:00] <joelteon> it's not in std::rt::io::net::ip4
[20:10:01] <bstrie> joelteon: still on 0.7?
[20:10:02] <joelteon> ip*
[20:10:04] <joelteon> no, I'm on HEAD now
[20:10:15] <bstrie> joelteon: you'll have to ask brson, he's completely rewriting all of that
[20:10:17] <joelteon> I need to programmatically find the IP address of a hostname
[20:10:19] <joelteon> ok
[20:10:21] <joelteon> brson: sup
[20:10:31] <bstrie> joelteon: you're quite bold to attempt net stuff in rust
[20:10:37] <bstrie> our libraries are
[20:10:38] <joelteon> I am indeed
[20:10:40] <strcat> graydon: I guess at some point we'll want to connect for to Iterator with a lang item
[20:10:45] <bstrie> well, mostly we just don't have them
[20:10:49] <strcat> not a big deal though
[20:11:37] <bstrie> graydon: alternatively, "rustc fuuuu", where the number of 'u's determines the degree of displeasure
[20:12:03] <bblum> rustc botsnack
[20:12:05] <bblum> rustc botsmack
[20:12:16] <cmr> rust-buildbot: dance
[20:12:17] <rust-buildbot> <(^.^<)
[20:12:18] <rust-buildbot> <(^.^)>
[20:12:19] <rust-buildbot> (>^.^)>
[20:12:20] <rust-buildbot> (7^.^)7
[20:12:21] <rust-buildbot> (>^.^<)
[20:12:30] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[20:12:36] <strcat> rusti: 2
[20:12:37] -rusti- 2
[20:13:34] <toddaaro> can I have a rust function and a rust method with the same name? Foo::bar(baz) and foo.bar(baz) for example
[20:13:55] <toddaaro> the argument lists are different, so would overloading make this work?
[20:14:07] <graydon> strcat: ping
[20:14:09] *** Joins: happy4crazy (happy4craz@63686BC7.F689A8C9.EB438161.IP)
[20:14:13] <strcat> graydon: pong
[20:14:20] *** Quits: happy4crazy (happy4craz@63686BC7.F689A8C9.EB438161.IP) (Client exited)
[20:14:21] *** Joins: happy4crazy (happy4craz@63686BC7.F689A8C9.EB438161.IP)
[20:14:26] <graydon> oh
[20:14:37] <graydon> strcat: I was about to ask you if you thought https://github.com/mozilla/rust/pull/8159 was on the right track
[20:14:39] <graydon> seems so!
[20:15:21] <graydon> gr another rustpkg failure when snapshotting
[20:15:33] <strcat> snapshotting foreach? :)
[20:15:33] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[20:15:48] *** Joins: echristo (echristo@DCF57675.D6CCE4AE.77834EAA.IP)
[20:15:58] <graydon> yes
[20:16:18] <engla> thanks strcat. If the snapshot lands so early, feel free to add more changes to my PR
[20:17:05] <kimundi> toddaaro: Technically the answer is yes, if Foo is something different than what provides foo.bar() and also not in scope
[20:17:08] <doener> I wonder how smart out frontend should be. I have a branch where I've gone wild and implemented retval alloca removal, early inlining for trivial functions (returning a constant), and constant propagation in some places. Unoptimized code shrinks quite a bit, but compile times are pretty much unchanged.
[20:17:28] <graydon> doener: does memory use drop?
[20:17:44] <toddaaro> kimundi: I guess not then, I was hoping to have Foo be what provides foo.bar()
[20:18:13] <toddaaro> kimundi: I'm trying to overload a function based on context, so the naming is a dilemma
[20:18:14] <kimundi> toddaaro: yeah, then no. one function name, one signature
[20:18:16] <graydon> doener: if codegen is down and/or memory use is down, I'm interested!
[20:18:21] <doener> graydon: nothing I could measure. The early memory fragmentation leaves enough holes that later usage doesn't matter. That's why we have that long flat line in the mem profile
[20:18:34] <graydon> doener: mhm
[20:18:36] <doener> graydon: that's why I produced the broken retval freeing PR
[20:18:42] <engla> hi
[20:18:55] <kimundi> toddaaro: you will be able to call foo.bar(...) as Foo::bar(foo, ...) somewhere in the future though
[20:18:55] <doener> graydon: I'll try manually adding scopes in phase_2_...
[20:18:55] *** Quits: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net) (Quit: tikue)
[20:19:03] <doener> graydon: should have the same effect
[20:19:31] <toddaaro> kimundi: oh interesting, so when that happens I'll be super happy, but I see why it would break this naming hack of mine
[20:20:35] *** Joins: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net)
[20:21:00] *** Quits: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net) (Quit: tikue)
[20:22:18] <doener> graydon: librustc.ll is from 3000764 to 2874647 lines
[20:22:28] <graydon> !
[20:22:39] <graydon> nice nice
[20:23:16] <graydon> is it really invasive? I think it's kinda a balancing act
[20:23:30] <doener> I can upload the WIP version
[20:23:30] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[20:26:18] <doener> graydon: https://github.com/dotdash/rust/commits/ret_alloca_elim -- first tmp does retval alloca elimination (copied from clang), second does a the trivial inlining (and is really ugly atm), third is from a different PR, fourth is the scoping for memory usage, last is operand propagation for immediates (also ugly right now)
[20:26:34] *** Quits: rustyPipe (Mibbit@moz-5949C51B.dllstx.fios.verizon.net) (Quit: http://www.mibbit.com ajax IRC Client)
[20:26:39] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[20:27:28] <brson> joelteon: hi
[20:28:15] <bstrie> brson: they were wondering if the get_uv_global_loop stuff was still around in trunk
[20:28:33] <brson> joelteon bstrie: no the uv_global_loop is no more
[20:28:44] *** Quits: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch) (Ping timeout)
[20:29:14] <joelteon> brson: is it still possible to get an ip address from a hostname?
[20:29:15] <bstrie> I'm happy about that, but only because I was disgruntled at the old timer::sleep interface :)
[20:29:16] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[20:29:16] <toddaaro> pcwalton: why doesn't rust have function overloading? I asked bblum about it and he suggested I ask you
[20:29:40] <pcwalton> because it was felt unnecessary with traits
[20:29:40] <bblum> oh sure blame me in public
[20:29:42] <bblum> (:P)
[20:29:47] <toddaaro> pcwalton: what do you mean by that?
[20:30:12] <strcat> you can 'overload' based on properties of traits
[20:30:17] <pcwalton> you can use typeclasses to get some degree of overloading, and we were cautious about adding more
[20:30:25] <toddaaro> we currently have an orgy of "generic programming by different names" in the scheduler and I'm trying to stamp it out, but I'm failing on every front I try
[20:30:27] <pcwalton> it's possible in the future if it's really needed
[20:30:32] <cmr> erick: Sent rust-zmq PR to upgrading to newer things
[20:30:42] <cmr> erickt: it seems it uses deprecated functions, so that's next on my list
[20:30:55] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Quit: Leaving.)
[20:30:57] <toddaaro> pcwalton: why the caution about overloading? does it do bad things someplace?
[20:31:04] <strcat> overloading gets you into SFINAE territory
[20:31:13] <brson> joelteon: temporarily, no. it will be at least a week or two until the new scheduler is on by default and dns code is re-added. sorry for the inconvenience
[20:31:21] <strcat> and if you can't represent it as traits, the functions probably aren't doing the same thing
[20:31:27] <strcat> so it's odd to give them the same name
[20:31:35] <pcwalton> just for code clarity concerns and not wanting to have too many features
[20:31:39] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[20:31:39] <joelteon> that's ok brson, this isn't time sensitive
[20:31:46] <pcwalton> nothing particularly principled
[20:31:46] <joelteon> thanks for responding :d
[20:31:54] <toddaaro> my usecase is something like "resume_task_immediately(task)" where task can be either a ~Task or a BlockedTask, right now we have two functions and it is frustrating to look at
[20:32:09] <cmr> toddaaro: Either<~Task, BlockedTask>
[20:32:18] <strcat> cmr: taking parameters that way is weird
[20:32:26] <kimundi> toddaaro: trait ResumableTask
[20:32:28] <toddaaro> cmr: yea, it just gets hideous
[20:33:01] *** Joins: tjc (tjc@moz-BBE3ABD.mv.mozilla.com)
[20:33:01] *** ChanServ sets mode: +o tjc
[20:33:02] <kimundi> implemenet by ~Task and BlockedTask?
[20:33:04] <strcat> cmr: unless there's really a use-case for having either outside of params
[20:33:17] <toddaaro> kimundi: seems like it would work, does that introduce any performance overhead?
[20:33:30] <strcat> yes
[20:33:44] <kimundi> toddaaro: Nope, afaik not
[20:33:48] <strcat> well
[20:33:51] <strcat> depends how you pass stuff
[20:33:59] <strcat> no overhead for using generic functions
[20:34:00] <kimundi> static dispatch
[20:34:10] <bblum> fg
[20:34:12] <bblum> oops.
[20:34:27] *** Joins: DoomBoom (DoomBoom@6B14631A.ACEC7723.5D1D3FEF.IP)
[20:34:27] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[20:34:29] *** strcat is now known as fg
[20:34:33] <fg> no current job
[20:34:36] <kimundi> fn resume_task_immediately<T: ResumableTask>(task: T) {...}
[20:34:36] *** fg is now known as strcat
[20:34:49] <bblum> strcat: 'fg: current: no such job'
[20:34:52] <bblum> but thakns
[20:35:06] <toddaaro> kimundi: that seems like it would work nicely, I'll have to consider this and maybe traitify a few other things
[20:35:08] <strcat> bblum: zsh doesn't say 'current' ;p
[20:35:27] <toddaaro> brson: do you have any thoughts? you have worked with function-swarm a fair bit already
[20:35:42] <bblum> FUNCTION SWARM
[20:36:07] <kimundi> Oh no! Look out they're coming!!!
[20:36:12] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[20:36:12] <kimundi> FN FN FN FN FN FN FN FN FN FN FN FN 
[20:36:47] <bblum> Swarm Traits: A swarm has no clear front or back and no discernable anatomy, so it is not subject to critical hits or flanking. A swarm made up of Tiny creatures takes half damage from slashing and piercing weapons. A swarm composed of Fine or Diminutive creatures is immune to all weapon damage.
[20:37:11] <graydon> doener: what objects get early-disposed in the { ... } scope wrappers?
[20:37:23] <cmr> A swarm of anything larger than tiny would be frightening
[20:37:30] <cmr> Halfing swarm
[20:37:32] <cmr> *shudder*
[20:37:40] <doener> graydon: the returned @Crates
[20:37:44] <jaen> bblum: sounds like a DnD manual quote
[20:37:45] *** Quits: jgilbert (jgilbert@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[20:37:53] <bblum> jaen: in fact!
[20:37:55] <graydon> doener: they get stored into 'crate' though
[20:37:56] <doener> graydon: the returned box has refcount 1, the assignment increments it to 2
[20:38:09] <strcat> use Rc ;p
[20:38:10] <graydon> ah. so this just keeps it down at 1.
[20:38:13] <graydon> dropping the temporary
[20:38:15] <doener> so when the next assignment happens, it gets decremented to 1 and not freed
[20:38:20] <kimundi> Now I really wish rust function keyword would be 'fun'... Would make this relevant: https://www.youtube.com/watch?v=zusLgd9L04Y
[20:38:25] <doener> with the scope, it's freed on the next assignment
[20:38:28] <graydon> I see. yeah, this is what your other patch was about.
[20:38:33] <strcat> doener: I think anything relying on @ to use refcounting isn't really correct
[20:38:36] <graydon> I wonder how many times we're doing this elsewhere in the compiler.
[20:38:44] <graydon> nmatsakis: ping
[20:38:56] <doener> strcat: Agreed, it's just an experiment / stop-gap solution
[20:39:01] <strcat> graydon: well @ is really inappropriate for reference counting
[20:39:04] <strcat> you really want move semantics
[20:39:08] *** Parts: bheylin (brianheyli@moz-8255E94E.adsl.online.nl) ()
[20:39:47] <strcat> there's no use-case for it atm beyond lacking deref overloading for Rc
[20:39:51] <doener> graydon: @mut Blocks do that all over the place
[20:40:02] <graydon> @mut blocks?
[20:40:30] <strcat> as in bcx?
[20:40:46] <brson> toddaaro: I would probably not favor the Either solution, would start by creating two functions and try to factor out the bodies, and resort to parameterizing the entire function last. Which use cases are the non-BlockedTask for?
[20:40:50] <doener> graydon: bcx, block context... They're often re-assigned because a terminator instruction was/could have been added
[20:40:52] <graydon> presumably when the outer scope exits it does still drop, no?
[20:41:10] <graydon> we just keep the bcx alive in the function a bit too long
[20:41:16] <strcat> graydon: yes but @ will live way longer than you want them too
[20:41:21] <strcat> to*
[20:41:31] <graydon> until the function exits
[20:41:39] <graydon> (or, um, enclosing { of the decl)
[20:41:42] <graydon> }
[20:41:45] <strcat> graydon: but you can pass them deep into a call stack, and they won't get freed when you're done with them like Rc
[20:41:55] <strcat> it has to wait until the whole thing winds back up
[20:41:59] <graydon> fair enough
[20:41:59] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Quit: Leaving.)
[20:42:06] <strcat> I'm sure it contributes to our memory usage issues
[20:42:15] <graydon> Rc is move eh? you have to do .clone() to get a ++ ?
[20:42:19] <strcat> graydon: yeah
[20:42:23] <graydon> makes sense
[20:42:51] <doomlord_> http://pastebin.com/PUjM31Li <<< just experimenting with how the ast node visit works, could anyone answer my q on what @self and (@a).blah.. are doing.. 
[20:42:55] <strcat> so you only pay for refcounts when ownership branches
[20:42:55] <toddaaro> brson: in this case we have "resume_task_immediately" which is the old function, it is two lines just calling change_task_context with sched_task storage as the cleanup. resume_blocked_task_immediately is used in many cases coming from task context, and it includes a match blocked_task.wake() { ... } that either calls resume_task_immediatly or just puts the sched back
[20:42:59] <doener> trans allocates about 300M
[20:43:29] <strcat> doener: I think expanding intrinsics in-place would be a big win
[20:43:32] <strcat> like size_of
[20:43:34] <graydon> doener: none of these appear to be terribly invasive. it might be nice to try to move them to nicer-named subfunctions or possibly put in comments about what they're doing, but the effort/payoff balance seems like they're worth it.
[20:43:35] <graydon> (to me)
[20:43:40] <toddaaro> brson: it seems like most of the scheduler functions are just the same 3-4 pieces composed slightly differently, but I'm not sure how to structure the code that way
[20:43:53] *** Joins: jgilbert (jgilbert@moz-7B0110AD.mv.mozilla.com)
[20:44:34] *** Quits: jorendorff (jorendorff@moz-1747FB68.hsd1.tn.comcast.net) (Ping timeout)
[20:46:17] <strcat> rusti: let copy = 5;
[20:46:18] -rusti- <anon>:5:9: 5:12 error: found `copy` in ident position
[20:46:18] -rusti- <anon>:5          let copy = 5;
[20:46:18] -rusti-                   ^~~
[20:46:18] -rusti- error: aborting due to previous error
[20:46:18] -rusti- application terminated with error code 101
[20:46:21] <doener> strcat: a big win in terms of memory usage?
[20:46:40] <strcat> doener: no, just compile-time
[20:47:35] *** Joins: mark_edward (quassel@moz-9631ECE3.public.wayport.net)
[20:47:50] <strcat> rusti: let x = 5; let y = copy x; y
[20:47:52] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/ACBW
[20:48:00] <strcat> heh
[20:48:05] <strcat> I guess it's just still reserved
[20:48:16] <strcat> rusti: trait Copy {}
[20:48:17] -rusti- ()
[20:48:18] <brson> toddaaro: ok, it sounds like it's not so much a general code-duplication problem, but one that is somewhat specific to the structure of the scheduler. I don't really have any suggestions since it would require taking a close look at the code. Which branch should I look at?
[20:48:40] *** Quits: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP) (Quit: Lost terminal)
[20:48:41] *** Joins: jorendorff (jorendorff@moz-1747FB68.hsd1.tn.comcast.net)
[20:48:55] *** Quits: pyrac (pyrac@moz-F28B7CAD.w90-55.abo.wanadoo.fr) (Quit: pyrac)
[20:49:00] <toddaaro> brson: I'll confirm what I have compiles and push it in a sec
[20:49:44] <cmr> What runtime overhead do conditions impose?
[20:50:06] <strcat> TLS
[20:50:11] <doener> strcat: I'm not sure about that. We spend a huge about of time in the target specific parts, only comparatively little time in inlining.
[20:50:15] <cmr> Would they be appropriate for a highish level zmq binding, instead of using Result<..., Error> everywhere?
[20:50:16] <strcat> tls is basically a lookup table
[20:50:35] <bblum> is it preferred for top-of-file overall design documentation to be in a doc-comment or a normal comment?
[20:50:36] <acrichto> cmr: strcat: TLS is an unsorted vector so lookup is O(n)
[20:50:40] <doener> strcat: and my branch already directly inlines a bunch of intrinsics, like size_of or contains_managed that translate to a constant
[20:50:50] <graydon> it is now but it could change to a hashmap at this point
[20:50:50] <strcat> cmr: you shouldn't use a condition if there's not a sensible way they can handle the error with it
[20:50:58] <bblum> brson: ^ ?
[20:51:04] <cmr> strcat: Ok, no conditions then :p
[20:51:10] <doener> S/huge about/huge amount/
[20:51:16] <graydon> cmr: wait, what's the error case?
[20:51:34] <strcat> probably lots?
[20:51:44] <brson> bblum: for private modules like those in rt I prefer doc comments, for public modules I prefer not to document the internals as public doc comments
[20:51:52] <bblum> ok thanks
[20:51:54] <strcat> network failures and other things you can expect
[20:52:15] <cmr> graydon: stuff like "the context specified was terminated" or "the open socket limit has been reached"
[20:52:19] <graydon> sure. if "retry|ignore|fail" is a reasonable set of ways someone will handle them, then conditions may work well
[20:52:43] <strcat> graydon: but then you're restricted to that set of error handling methods
[20:52:48] <toddaaro> brson: ok, I pushed to tls-tk-pr-pre
[20:52:54] <strcat> you couldn't do something like "try a different server"
[20:53:09] <strcat> unless you used a task to catch the failure, and you can't know which failure you caught atm
[20:53:20] <graydon> strcat: then add |reconnect(other) to the set of reasonable recoveries
[20:53:32] <toddaaro> brson: this should actually be perfectly adequate in the short term, but I want to stamp out the scheduler function bloat before it gets out of hand
[20:53:42] *** Quits: happy4crazy (happy4craz@63686BC7.F689A8C9.EB438161.IP) (Client exited)
[20:53:52] *** Joins: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com)
[20:53:59] <graydon> the question should be about "can you figure out a way for each error site to express a request-for-help such that it could fix the error if given an answer"
[20:54:41] <strcat> the caller might want to handle it in a way the callee didn't explicitly add support for
[20:54:55] <cmr> Wait is this like the common lisp condition/restart system?
[20:54:58] <graydon> then generalize the interface
[20:55:04] <strcat> cmr: yes
[20:55:13] <cmr> aha
[20:55:19] <graydon> as in, pass the relevant parts of self and get replacement values to continue with
[20:55:44] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[20:56:01] <graydon> you don't have to use an enum. you can just pass "all the state I think a caller might want to inspect" and accept "replacements for everything a caller might want to replace"
[20:56:31] <strcat> I just find it simpler to use the return value if there's not internal state you'd lose by returning
[20:57:39] *** Quits: sw17ch (sw17ch@moz-6206F951.dia.static.qwest.net) (Quit: sw17ch)
[20:57:52] <toddaaro> brson: bleh, I broke this branch somehow undoing my src/rt debug tweaks from yesterday, working on that now
[20:58:00] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[20:58:00] *** Joins: dandroid (Mibbit@moz-D5E3B1CA.dia.static.qwest.net)
[20:58:11] <jmgrosen> is there a good explanation of conditions anywhere?
[20:58:29] <graydon> ok. I will just register my vote as usual in opposition to this. I don't like that our APIs are covered in option<> and result<>
[20:58:45] <graydon> I know conditions are a bit broken right now so I will only object so much
[20:58:53] <strcat> I don't like Result
[20:59:21] <cmr> Result makes for ugly success case, or unhandled failure
[20:59:33] <strcat> I'm not suggesting the way we do things now by returning Result<Good, ~str> is useful
[20:59:42] <strcat> cmr: the success case is perfectly clean if it's well-designed
[20:59:45] <strcat> .get() isn't painful
[20:59:51] <brson> I like the idea of using option and exposing the details out-of-band using conditions
[20:59:52] <graydon> jmgrosen: not a good one. there are examples in std::condition::test
[20:59:54] <strcat> if you only care about success
[20:59:55] <cmr> .get() is unhandled failure
[21:00:13] <jmgrosen> gray don, thanks
[21:00:23] <jmgrosen> *graydon, sorry, autocorrect
[21:00:30] <kimundi> cmr: get() is 'promote to task failure'
[21:00:38] <strcat> brson: imo the only reason that seems good is because we lack proper error handling types
[21:00:42] <kimundi> wouldn't call that unhandled...
[21:01:05] <bblum> graydon: sorry about that tail recursion issue; i meant it as a note to myself
[21:01:07] <graydon> strcat: what would you consider proper?
[21:01:18] <strcat> graydon: being able to match on the failure reason
[21:01:21] <strcat> instead of awful strings
[21:01:26] *** ozten is now known as ozten|meeting
[21:01:32] <graydon> bblum: ok. wasn't sure if it was just that.
[21:01:36] <bblum> graydon: incidentally, do we have tail recursion guarantees for closures of the same type?
[21:01:41] <strcat> the error type for open() shouldn't be the same type as another function
[21:01:44] <bblum> a ~fn() calling a ~fn()
[21:01:51] <graydon> strcat: how would we express reasons in this case?
[21:01:56] <graydon> bblum: no
[21:02:07] <strcat> graydon: the possible error codes translated to an enum
[21:02:15] <graydon> bblum: 	we have no tail recursion guarantees for anything. when it happens it's LLVM being magic.
[21:02:16] <strcat> enum Foo { NOT_FOUND, ... }
[21:02:23] <bblum> i see.
[21:02:24] <bblum> hmm
[21:02:27] <sfackler> graydon: speaking of conditions, how does condition! use {} instead of () like all other macros? Is it special cased?
[21:02:45] <graydon> sfackler: no, you can do that with other macros.
[21:02:49] <cmr> sfackler: macro_rules! foo { ... }
[21:03:08] <graydon> strcat: so you'd say Result<Thing,ErrorEnum> ?
[21:03:09] <sfackler> oh, cool. I thought i saw something in the macro tutorial about requiring ()
[21:03:16] <pcwalton> does anyone know why the times are so random on http://huonw.github.io/isrustfastyet/mem/ ?
[21:03:27] <strcat> graydon: yes, and if you didn't want to handle it .get() and it would generate an error message based on the error
[21:03:31] <cmr> pcwalton: I don't
[21:03:42] * pauls thought that macros required `()` also... but this has gone back and forth enough that he's not surprised he forgot.
[21:03:45] <cmr> pcwalton: best to ignore the obvious spikes
[21:03:56] *** Quits: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Ping timeout)
[21:03:56] *** Quits: jld (jld@moz-B94C75AD.xlerb.net) (Quit: upgrades!)
[21:03:58] <graydon> strcat: perhaps via deriving(ToStr) on the error enum?
[21:04:12] <cmr> pcwalton: I'm rewriting my benchmarking infrastructure to be more repeatable.
[21:04:15] <kimundi> pauls: Last I heard the opinion was kinda 'make both work'
[21:04:26] <cmr> graydon: That is how the high level mmap interface works
[21:04:35] <strcat> graydon: well something like strerror_r, if it was a system error
[21:04:37] <pcwalton> ok
[21:05:13] <cmr> https://github.com/mozilla/rust/blob/master/src/libstd/os.rs#L1350
[21:05:22] <graydon> ok. that's certainly an improvement for Result; I'd like to fix up condition and try using it more widely still, but for the time being I wouldn't object if someone wanted to tackle fixing Result to work that way.
[21:05:27] <cmr> Specifically https://github.com/mozilla/rust/blob/master/src/libstd/os.rs#L1389 and https://github.com/mozilla/rust/blob/master/src/libstd/os.rs#L1412
[21:05:31] <dandroid> hello. quick question about net modules for tcp/udp in the master branch. are they usable atm, are they being actively changed?
[21:05:48] <cmr> dandroid: kinda, and yes
[21:05:54] *** Quits: DoomBoom (DoomBoom@6B14631A.ACEC7723.5D1D3FEF.IP) (Quit: Leaving)
[21:06:00] <cmr> dandroid: extra::net has been removed, all that exists is std::rt::io::net atm
[21:06:03] <strcat> graydon: I think Result should require the T: ToStr for the error basically
[21:06:05] <cmr> and it's very WIP
[21:06:28] <dandroid> ok, ty
[21:06:45] <graydon> strcat: yeah, I get it. that would help, indeed.
[21:06:58] *** Joins: jld (jld@moz-B94C75AD.xlerb.net)
[21:07:05] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Quit: Gone to save the world!)
[21:07:08] <toddaaro> brson: oh, disregard, the branch is fine I just had to rebuild more stuff
[21:08:22] *** Quits: dandroid (Mibbit@moz-D5E3B1CA.dia.static.qwest.net) (Quit: http://www.mibbit.com ajax IRC Client)
[21:08:30] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[21:10:04] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[21:10:48] <dim-an> hi, question: imagine I have a generic struct Foo<T>, what is the best way to create a static constant of type Option<Foo<T>> (that is equal to None) ?
[21:11:05] <kimundi> strcat: Do you think it would make sense to predefine a bunch of common error enums in std::result, or should every function that uses Result define their own?
[21:11:11] <cmr> rusti: struct Foo<T> { x: T }; static x: Option<Foo<int>> = None;
[21:11:13] -rusti- ()
[21:11:16] <cmr> dim-an: ^
[21:11:24] <strcat> kimundi: I think we should have at least as much as C++11 does
[21:11:40] <kimundi> strcat: No idea what they have :)
[21:12:03] <strcat> well they have a cross-platform enum of system errors, and a bunch of error categories
[21:12:08] <strcat> http://en.cppreference.com/w/cpp/error/errc
[21:12:13] <doomlord_> http://pastebin.com/2R90g3QG <<  now i seem to want to try and completely rework how my ast is represented, remembering how i worked with clang..
[21:12:16] <kimundi> But this Result thing sounds like a nice thing to churn away at.
[21:12:31] <dim-an> cmr: thank you
[21:12:36] <brson> bblum: I'm seeing run-pass/issue-3168 run-pass/lots-a-fail failing non-deterministically under the new runtime. maybe you can give them a look. They can be run with `make check-stage1-rpass TESTARGS="--newrt lots-a-fail"
[21:13:05] <bblum> brson: alrighty
[21:13:10] *** Quits: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net) (Input/output error)
[21:13:12] <dim-an> cmr: but if I want this constant to be defined for all possible T
[21:13:13] <strcat> kimundi: http://en.cppreference.com/w/cpp/error/error_condition
[21:13:20] <cmr> dim-an: not possible
[21:14:12] <strcat> python has this really awful exception hierarchy with platform dependent information scattered throughout so... ;p
[21:15:04] <dim-an> cmr: that is sad, but thank you anyway
[21:15:37] <cmr> dim-an: it would require a separate static for every possible T
[21:15:45] <cmr> dim-an: and if it's a pub static, every possible T that *other* crates use
[21:15:59] <cmr> (which isn't possible to do)
[21:16:07] <dim-an> dim-an, it's private static
[21:16:16] <strcat> rusti: fn foo<T: copy>() {}
[21:16:17] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/dZih
[21:16:27] <strcat> heh
[21:16:29] <strcat> note: the `send`, `copy`, `const`, and `owned` kinds are represented as traits now, and should be camel cased
[21:16:31] <strcat> I wonder how old that is
[21:16:49] <strcat> rusti: fn foo<T: foo>() {}
[21:16:49] -rusti- <anon>:5:19: 5:22 error: attempt to bound type parameter with a nonexistent trait `foo`
[21:16:50] -rusti- <anon>:5          fn foo<T: foo>() {}
[21:16:50] -rusti-                             ^~~
[21:16:50] -rusti- error: aborting due to previous error
[21:16:50] -rusti- application terminated with error code 101
[21:17:03] <kmc> will .clone() on Option<T> clone the T? under which circumstances?
[21:17:11] <bblum> yes, all
[21:17:22] <kmc> ok
[21:17:22] <bblum> i mean, obviously not in the None case
[21:17:26] <kmc> sure :)
[21:17:30] <cmr> Is there any way to mark an extern fn safe? (as in an extern block for FFI)
[21:17:37] <strcat> cmr: no
[21:17:49] <kmc> so Clone clones a whole ownership tree, but stops at @-boxes, and DeepClone clones those too?
[21:17:54] <strcat> we could have #[safe] for the rare few valid for all inputs
[21:18:11] <strcat> kmc: yes, DeepClone traverses through @/Rc
[21:18:23] <cmr> It's a function that cannot fail, and takes no input, so requiring unsafe seems a bit heavy-handed to me
[21:18:25] <strcat> it's only implemented for types known to be non-cyclic though.
[21:18:29] <cmr> (zmq_ctx_new)
[21:18:33] *** Joins: mortisha (Mibbit@moz-22C32803.cust.bredbandsbolaget.se)
[21:18:42] <strcat> if you implemented a potentially cyclic one you'd have to implement DeepClone yourself, handling that case however you want
[21:18:46] <cmr> Super minor api woe though
[21:18:53] <kmc> ok
[21:19:36] <strcat> huh, where do we actually reserve keywords like 'copy'
[21:19:43] *** Joins: ecr (Thunderbir@moz-F724119C.uoregon.edu)
[21:20:04] <cmr> I recall seeing a huge interner table intialization in libsyntax/parse
[21:20:12] <bblum> brson: haven't seen issue-3168 crash yet, do you have a failure mode or stack trace?
[21:20:18] <strcat> yeah I removed it there but that doesn't seem like where it reserves anything
[21:20:19] <bblum> lots-a-fail definitely does crash though
[21:20:21] <dim-an> cmr: I have no idea about binary representation of Rust code, but I want private static, that will be sometimes used in generic method
[21:20:51] <strcat> rusti: let copy = 5;
[21:20:52] -rusti- <anon>:5:9: 5:12 error: found `copy` in ident position
[21:20:52] -rusti- <anon>:5          let copy = 5;
[21:20:52] -rusti-                   ^~~
[21:20:52] -rusti- error: aborting due to previous error
[21:20:52] -rusti- application terminated with error code 101
[21:20:54] <strcat> hm
[21:21:02] <cmr> dim-an: right, and it'd be technically feasible to allow it for private statics in some cases, but the asymetry with pub static would be very weird
[21:21:08] *** Quits: mortisha (Mibbit@moz-22C32803.cust.bredbandsbolaget.se) (Quit: http://www.mibbit.com ajax IRC Client)
[21:23:30] <cmr> strcat: maybe it's also hardcoded in the parser or lexer somewhere?
[21:24:38] <strcat> seems like it...
[21:24:47] <sfackler> dim-an: you can always make a generic function that returns the value and toss an #[inline(always)] on it
[21:25:05] *** Quits: doener (doener@moz-121949B3.unitymediagroup.de) (Quit: bedtime)
[21:25:26] <zxcdw> how does rust support dynamic binding?
[21:25:35] <strcat> cmr: ah I see why
[21:25:38] <strcat> it uses a range of numbers
[21:25:41] <strcat> this is really awful
[21:25:51] <strcat> we have hardcoded integers to refer to keywords... not constants
[21:25:53] <strcat> :|
[21:26:05] <strcat>             8 | 27 | 32 .. 64 => true,
[21:26:07] <strcat>             _ => false,
[21:26:09] <strcat> is_strict_keyword
[21:26:11] <strcat> yay
[21:26:15] <kimundi> strcat: change it to an enum! :P
[21:26:39] <strcat> there actually is an enum, it's just missing defined integers
[21:29:04] <strcat> there's a similar table for lang items
[21:29:17] *** Joins: int3_ (int3_@moz-6C584174.ipnetworksinc.net)
[21:29:51] <dim-an> sfackler: yes, but looks, like it doesn't work for my case. I want to pass &'r~None of type &'r~Option<Foo<T>> to some function, and I don't understand how I can get None with required lifetime.
[21:30:41] *** Quits: int3_ (int3_@moz-6C584174.ipnetworksinc.net) (Client exited)
[21:31:09] <bblum> brson: ok yep, this is a cute but easy bug in lots-a-fail
[21:31:15] *** Joins: orshem (orshem@C5E06B1E.A5B6B765.E3D28531.IP)
[21:31:40] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[21:31:43] *** Joins: int3_ (int3_@moz-6C584174.ipnetworksinc.net)
[21:31:53] <brson> bblum: ok, you repro'd? it's hard to do reliably
[21:32:16] <bblum> lots-a-fail was easy to repro, assuming the bug is "terminate called after throwing ... Aborted"
[21:32:35] <bblum> i've got issue-3168 running in a loop and it hasn't crashed yet
[21:33:35] <bblum> in lots-a-fail, a task is receiving a kill signal outside of where the task.unwinder is try()ing; all the kill.rs cleanup code is very careful to be unkillable around its blocking sections, but there's a spot in taskgroup cleanup (outside of the try) where i make a clone of a kill handle and drop it without being unkillable
[21:33:38] <brson> yeah, issue-3168 is confounding. i've seen it fail a few times but can't make it happen reliably
[21:33:38] *** Quits: int3_ (int3_@moz-6C584174.ipnetworksinc.net) (Connection reset by peer)
[21:33:56] <bblum> it could well be the same bug; is it the same 'terminate called after throwing'?
[21:34:13] <brson> bblum: not sure
[21:34:23] <bblum> got logs?
[21:34:36] <brson> nope!
[21:34:39] *** Joins: int3_ (int3_@moz-6C584174.ipnetworksinc.net)
[21:34:45] <brson> ah, it failed
[21:35:18] <brson> bblum: this is the output https://gist.github.com/brson/6126402
[21:35:20] <bblum> (dropping a UnsafeArc involves its own unkillable section, but since the task is not already unkillable, it has to check for a kill signal before becoming unkillable, and so it dies there)
[21:35:40] <bblum> task home of none, huh?
[21:35:45] *** Joins: pupoque (Adium@297D6F99.EF706C30.C0C64AB3.IP)
[21:36:03] <brson> bblum: maybe solved by toddaaro's patches
[21:36:29] <bblum> argh, there are 4 different places where rtabort's message is "task home of None"
[21:36:34] *** Quits: int3_ (int3_@moz-6C584174.ipnetworksinc.net) (Ping timeout)
[21:36:48] <toddaaro> bblum: oh what are you doing?
[21:36:57] <toddaaro> brson: just pushed my current code, all tests passing
[21:37:38] <brson> toddaaro: which branch? is https://github.com/mozilla/rust/pull/7915 still valid?
[21:37:45] *** Quits: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com) (Quit: tikue)
[21:37:49] *** Joins: jdm (jdm@CAB30FBD.8F96AEA7.2D179A7D.IP)
[21:38:03] *** Joins: int3_ (int3_@moz-6C584174.ipnetworksinc.net)
[21:38:06] <strcat> rusti: let __log = 5; 
[21:38:08] -rusti- <anon>:5:9: 5:12 error: found `__log` in ident position
[21:38:08] -rusti- <anon>:5          let __log = 5; 
[21:38:08] -rusti-                   ^~~
[21:38:08] -rusti- error: aborting due to previous error
[21:38:08] -rusti- application terminated with error code 101
[21:38:18] <bblum> strcat: o_O
[21:38:18] *** Joins: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com)
[21:38:27] <strcat> rusti: let pure = 5; 
[21:38:27] -rusti- <anon>:5:9: 5:12 error: found `pure` in ident position
[21:38:28] -rusti- <anon>:5          let pure = 5; 
[21:38:28] -rusti-                   ^~~
[21:38:28] -rusti- error: aborting due to previous error
[21:38:28] -rusti- application terminated with error code 101
[21:38:31] <strcat> hehe
[21:38:47] <strcat> graydon: do we actually still want 'pure' reserved?
[21:39:05] <graydon> I think someone in the future is likely to want to experiment with it
[21:39:20] <toddaaro> brson: https://github.com/mozilla/rust/pull/8116 now, and it should be ready to go
[21:39:23] <strcat> weird, what is __log
[21:39:50] <strcat> rusti: error!("foo")
[21:39:51] *** Quits: int3_ (int3_@moz-6C584174.ipnetworksinc.net) (Ping timeout)
[21:39:51] -rusti- rust: ~"\"foo\""
[21:39:52] -rusti- ()
[21:40:02] <strcat> uh
[21:40:03] <jedestep> I'm matching an ident in a macro, is there any way I can use that ident as though it were a string
[21:40:04] <pcwalton>  ok, another nearly 4KLOC PR submitted
[21:40:15] <graydon> if you can code in js avoiding 'interface', 'class' and 'enum', I'm ok keeping our reserved words list relatively far-reaching.
[21:40:25] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[21:40:28] *** Joins: int3_ (int3_@moz-6C584174.ipnetworksinc.net)
[21:40:29] <strcat> http://ix.io/6YM :|
[21:40:35] <graydon> keywords become impossible to add after 1.0 :(
[21:40:40] <bblum> brson: regarding lots-a-fail, find "// FIXME(#7544): Get rid of this clone by passing by-ref." in task/spawn.rs; fixing that would automatically fix the bug too, but i will have to hack around it in the meantime
[21:40:50] <jack> strcat: is there a better wya to do `iter().transform(|&x| x).chain_(..)`?
[21:40:50] <brson> toddaaro: thanks a bunch
[21:40:59] <graydon> strcat: __log will go away
[21:41:07] <strcat> jack: not really
[21:41:16] <strcat> jack: it will become .map(|&x| x) though, not as ugly
[21:41:16] <graydon> pcwalton: visitor?
[21:41:18] <toddaaro> brson: I'm taking a look at that test bblum is perplexed by now
[21:41:20] <pcwalton> yeah
[21:41:32] <pcwalton> incomplete but I figured 4KLOC is enough to want it in ASAP
[21:41:41] <jack> strcat: what's that blocked on?
[21:41:50] *** Joins: msingle (Thunderbir@moz-20675462.nrflva.fios.verizon.net)
[21:42:05] <strcat> jack: method resolve handling generic impls correctly
[21:42:07] <tikue> strcat: I thought there was a vec.owned_iter()
[21:42:22] <strcat> there are iter, mut_iter and consume_iter
[21:42:35] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[21:42:44] *** ozten|meeting is now known as ozten
[21:42:59] <strcat> no need for any others that aren't doing something like tokenizing
[21:42:59] <graydon> pcwalton: you're sure this should go ahead of pnkfelix's thing? will there be any reuse?
[21:43:15] <pcwalton> how much of his is done?
[21:43:35] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[21:43:35] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/XEt4AQ
[21:43:35] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[21:43:49] <strcat> graydon: I guess we might as well reserve 'yield' then
[21:44:31] <graydon> pcwalton: https://github.com/pnkfelix/rust/commits/fsk-issue7081-visitor-refactoring-21jul
[21:44:57] <graydon> pcwalton: I dunno, I don't mind either, just want to get it fixed
[21:45:22] <cmr> Is there an issue open for C-like enum representation being user-definable?
[21:45:22] <bblum> anybody here know how to script gdb? i wish to keep running a program until it terminates abnormally.
[21:45:28] <pcwalton> graydon: it like we basically made the same API so I would expect reuse
[21:45:28] <bblum> without hitting up enter up enter up enter
[21:45:29] <cmr> (ie, enum Foo : i32 { ... })
[21:45:39] *** Quits: int3_ (int3_@moz-6C584174.ipnetworksinc.net) (Ping timeout)
[21:46:00] <cmr> bblum: you should just be able to hit enter, by default it re-runs the previous command
[21:46:01] <graydon> pcwalton: r+
[21:46:07] <cmr> bblum: (not a real solution, though)
[21:46:16] <bblum> cmr: okay so i should tape down my enter key or what
[21:46:28] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[21:46:28] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/bcDrNw
[21:46:28] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[21:46:47] <pauls> jedestep: `stringify!(...)`
[21:47:04] <strcat> rusti: let be = 5;
[21:47:05] -rusti- <anon>:5:13: 5:15 error: `be` is a reserved keyword
[21:47:05] -rusti- <anon>:5          let be = 5;
[21:47:05] -rusti-                       ^~
[21:47:05] -rusti- application terminated with error code 101
[21:47:13] <jedestep> pauls: thank you :)
[21:47:39] <pauls> It works for any expression. Which, oddly, makes it more forgetable for this purpose.
[21:48:29] *** Quits: msingle (Thunderbir@moz-20675462.nrflva.fios.verizon.net) (Ping timeout)
[21:48:49] <pcwalton> nmatsakis: bblum: what is the status of DST?
[21:48:49] <pcwalton> "
[21:49:13] <bblum> pcwalton: i haven't touched it since the original 'audit'
[21:49:16] <strcat> graydon: 'in' should be treated as a keyword now, right?
[21:49:25] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[21:49:25] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/bcDrNw
[21:49:25] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[21:49:26] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[21:49:26] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/QfIMiw
[21:49:26] <ghrust> 13rust/06auto 146cff279 15Patrick Walton: librustc: Remove `pub extern` and `priv extern` from the language....
[21:49:26] <ghrust> 13rust/06auto 14a094788 15Patrick Walton: librustc: Introduce a new visitor type based on traits and port syntax to it....
[21:49:27] <ghrust> 13rust/06auto 1461c1cb2 15bors: auto merge of #8163 : pcwalton/rust/new-visitor, r=graydon...
[21:49:29] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[21:49:50] <bblum> pcwalton: did we decide on <unsized T> ?
[21:50:08] <pcwalton> bblum: I wanted to bring that up at the meeting
[21:50:16] <pcwalton> but I wasn't sure what the status was
[21:50:21] <sp3d> bblum: you can use "while...end", "set $foo=expr" and some other constructs in gdb scripts
[21:50:36] <graydon> strcat: yes
[21:51:16] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[21:53:36] *** Joins: paupau (textual@FFAF02D4.F5573215.F20F0C5A.IP)
[21:54:14] <toddaaro> eatkinson: pastebin.mozilla.org/2753923
[21:54:26] <toddaaro> eatkinson: just nuke the destructor/clone functions and it should compile
[21:54:39] <toddaaro> eatkinson: oh and import paths are likely different for your location in the code
[21:55:12] <kmc> you can also script GDB with Python these days
[21:55:31] <kmc> don't know much about that though
[21:56:20] <echristo> pcwalton: nice debunking.
[21:58:21] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[21:58:22] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1461c1cb2 to 1466a0b58: 02http://git.io/N3iJvQ
[21:58:22] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[21:58:23] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[21:58:23] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/yCTRYg
[21:58:23] <ghrust> 13rust/06auto 14428ea7d 15Seo Sanghyeon: Revert atomicrmw {max, min, umax, umin}
[21:58:23] <ghrust> 13rust/06auto 14ef87e2c 15bors: auto merge of #8151 : sanxiyn/rust/atomicrmw, r=cmr...
[21:58:23] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[21:59:00] *** Quits: doomlord_ (servitor@moz-13E69BC8.range86-180.btcentralplus.com) (Ping timeout)
[22:00:04] <Sergio965> Is the fail! macro built in? Where can I see its source?
[22:00:33] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[22:00:41] <Sergio965> Found it in expand.rs
[22:00:51] *** Quits: dim-an (ermolovd@moz-FE167E47.nationalcablenetworks.ru) (Quit: dim-an)
[22:01:41] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[22:03:32] <graydon> pcwalton: compilation _crashed_ :((
[22:04:22] *** Quits: vodik (simon@moz-CBE4BB13.cable.teksavvy.com) (Ping timeout)
[22:05:20] <cde> almost always a bad sign
[22:05:38] *** Joins: jclements (jclements@F47764B0.E212572A.4B322BB7.IP)
[22:06:06] <brson> graydon: master has the fix to make rustc work with RUST_NEWRT=1 now
[22:06:10] <graydon> jclements: just who I was about to look for!
[22:06:14] <graydon> brson: I saw it, thanks
[22:06:20] <jclements> graydon: what's up?
[22:06:30] <pcwalton> hmmmm
[22:06:33] <graydon> jclements: was hoping you'd be able to tell me :)
[22:06:40] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[22:06:47] <brson> pcwalton: r? https://github.com/mozilla/rust/pull/8164
[22:07:10] <jclements> graydon: are you wondering where I am with this bug that you isolated?
[22:07:17] <graydon> yeah
[22:07:44] <jclements> graydon: I have one question, and one answer, but not a lot of progress.
[22:07:48] <jclements> First, the question.
[22:08:03] *** Quits: jeff (jeff@moz-F81F6C4E.nyc.biz.rr.com) (Ping timeout)
[22:09:10] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[22:09:49] *** Joins: jeff (jeff@moz-F81F6C4E.nyc.biz.rr.com)
[22:10:10] *** Joins: Florob (Florob@moz-39532932.de)
[22:10:10] <jclements> graydon: the code snippet that you sent me... (it appears in https://github.com/mozilla/rust/pull/8016 ) ... it's not quite complete, right?
[22:10:34] *** Joins: dim-an (ermolovd@moz-FE167E47.nationalcablenetworks.ru)
[22:10:36] <jclements> graydon: you have to... well, it's not legal on the mac either, right?
[22:11:35] <graydon> jclements: appears in .. where?
[22:11:44] <graydon> in PR 8016?
[22:12:16] <cmr> Is there currently churn with the lint interface? I've seen pcwalton and acrichto and aatch mention it, wondering if I should hold off on https://github.com/mozilla/rust/issues/6600
[22:12:20] <jclements> graydon: yes. I'm not presenting this clearly.  Just to add pressure, I'm about to get yanked away from the keyboard.
[22:12:21] *** Joins: Uther (Instantbir@moz-1B244B05.hfc.dyn.abo.bbox.fr)
[22:12:31] <graydon> jclements: do you mean the testcase I sent?
[22:12:34] <graydon> ok, ttyl
[22:12:37] <graydon> I'll keep trying to debug
[22:12:40] <brson> toddaaro: needs another merge https://github.com/mozilla/rust/pull/8116
[22:12:45] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[22:13:16] <toddaaro> brson: alright, with master or with something else?
[22:13:42] <jclements> graydon: it's worth noting that @lilac (in the PR referenced) tried to do some cleanup that I suggested, and ran into a similar-looking failure. I'm interested in this because it doesn't share any code with my PR, which leads me to believe this might not be my fault :).
[22:13:47] <brson> toddaaro: master
[22:13:57] *** Quits: RMF (RMF@76B3729C.4FA74685.8D19547B.IP) (Ping timeout)
[22:14:05] <strcat> graydon: sadly I think we break the inbounds GEP with ptr::offset in many places :(
[22:14:09] <strcat> quite a horrible crash.
[22:14:30] <graydon> strcat: which are you referring to?
[22:14:33] <strcat> I know zero-size types in vectors do but it's not from that
[22:14:51] <strcat> graydon: investigating using inbounds GEP instead of just GEP for offset
[22:15:04] *** Quits: dim-an (ermolovd@moz-FE167E47.nationalcablenetworks.ru) (Ping timeout)
[22:15:04] <aatch> cmr, probably not. The lint system does some exceedingly "clever" things with visitors so will need something close to a complete re-write to make it work with a better visitor interface.
[22:15:10] <strcat> although it'd make offset an `unsafe fn`
[22:15:17] <strcat> LLVM isn't happy though ;p
[22:15:28] <graydon> jclements: possibly. it's mucking around in the same code though, so I think it's .. something in the frontend!
[22:15:50] <strcat> graydon: zero-size types do some odd things
[22:16:00] <aatch> cmr, so if you wait, you may be waiting for a long time...
[22:16:12] <strcat> rusti: std::sys::size_of::<[(), ..10]>()
[22:16:13] -rusti- 0
[22:16:17] <strcat> so that's zero-size but...
[22:16:27] <jclements> graydon: how hard is it to spin up an EC2 windows instance to diagnose this? The stacktrace suggested a problem with clone on a deeply nested type.  I thought it might have been an out-of-memory issue associated with the resolve-table that I added in my PR, but that clearly can't be quite right, especially if you can reproduce it with a five-line example.
[22:16:28] <strcat> all the vector methods use non-zero size_of
[22:17:03] <brson> do we really need zero-size ()?
[22:17:14] <brson> it's a pretty surprising thing that it sometimes has size and sometimes doesn't
[22:17:30] <cmr> Zero-size types kinda blow my mind. You can't access them in any way, so why have them
[22:17:33] <toddaaro> brson: is it fine to rebase all my minor commits together, or do you have stuff depending on that history
[22:17:36] <graydon> jclements: debugging on windows is pretty hopeless. the debugger has no symbols and there's no valgrind.
[22:17:38] <cmr> They don't even communicate information
[22:17:43] <brson> toddaaro: that's fine
[22:17:46] <aatch> They are useful for generic types.
[22:17:46] <graydon> jclements: a backtrace is about all you can get. or logging.
[22:17:54] *** Joins: RMF (RMF@moz-F27ACC15.dsl.telepac.pt)
[22:18:03] <engla> it's nice to have a dummy type that actually completely disappears
[22:18:08] <aatch> Like implementing a Set as a map with `()` values
[22:18:13] <jclements> graydon: just to make sure I understand the issue... can you send me a version of the test case that compiles correctly on the mac?
[22:18:15] <graydon> I think () should remain 0-size, yeah.
[22:18:17] <aatch> with no overhead.
[22:18:32] <engla> strcat: I don't think vector needs to use nonzero sizeof
[22:18:33] <aatch> Also, unit structs are useful as type tags
[22:18:35] <graydon> jclements: why wouldn't it compile on a mac?
[22:18:51] <engla> the usecase for nonzero_size_of should be for allocations, not single elements
[22:18:57] <strcat> engla: what about vector iterators though? it uses pointers
[22:19:10] <strcat> it checks if it's done with a pointer comparison
[22:19:38] *** Quits: bnicholson (bnicholson@moz-835D504A.rcmdva.fios.verizon.net) (Ping timeout)
[22:19:42] <engla> right, advancing 0 bytes would be bad. What does it point to if you iterate [()]?
[22:19:51] <jclements> graydon : here's a gist: https://gist.github.com/jbclements/6126704
[22:20:03] <jclements> graydon: I'm sure I'm being stupid in some obvious way....
[22:20:04] <toddaaro> brson: ok, did the rebase and pushed optimisitically, the conflicts were completely trivial so I *think* everything is fine, starting the test suite now
[22:20:11] <strcat> engla: it points to the start of the data
[22:20:12] <jclements> okay, walking away from the keyboard... now...
[22:20:16] <aatch> All i can think of it special-casing zero-sized types in vector iterators.
[22:20:21] <strcat> and if they were zero size, end would point to the same place
[22:20:33] <graydon> jclements: oh yeah, weird. huh. I _thought_ that was the right testcase. lemme switch over to a windows host.
[22:20:41] <graydon> guh, this will .. actually take hours.
[22:21:19] <graydon> I'll bring up a public windows ec2 machine, sure.
[22:21:19] <strcat> brson: heh both you and pcwalton r+'ed that PR but it turns out there are a few more uses of "in" needing to be fixed
[22:22:16] * strcat hopes it works now
[22:22:31] <strcat> brson: we use this same awful pattern for lang items too :(
[22:23:11] <strcat> if you remove one you have the fun of updating a list of integers in 2 places
[22:23:30] * graydon mutters something about iota!()
[22:23:30] <strcat> and 2 array sizes
[22:23:43] <bblum> iota!?
[22:24:06] <strcat> bblum: http://golang.org/ref/spec#Iota
[22:24:22] <bblum> strcat: IOTA!??
[22:24:25] <strcat> ;p
[22:24:41] <strcat> I think we could just be defining enum values for these and casting from them, to reduce mistakes at least a bit...
[22:24:44] <graydon> bblum: woah calm down fellow
[22:24:47] <graydon> what's the big deal?
[22:24:55] <bblum> graydon: iota!!
[22:25:25] <pauls> bblum: Î¹
[22:25:31] <bblum> i take back all i ever said last summer about # being better for macros than !, assuming i have not taken it back already
[22:25:39] <tjc> whaaaaa
[22:25:39] <graydon> https://github.com/mozilla/rust/issues/7104 we don't have such a thing yet. we got stuck trying to pick a cromulent name for it.
[22:25:50] <brendanc> iotaâ€½
[22:25:50] * cmr still thinks iota is an awful name
[22:25:56] <cmr> but bad name is better than no name
[22:26:16] <graydon> I assume there's some pun about iota-with-an-exclamation-point that I am not getting?
[22:26:40] <bblum> graydon: i'm just excited about how much our macro rules!
[22:26:48] <graydon> heh
[22:26:55] <graydon> I do wish someone would rename it to macro!()
[22:27:13] <bblum> macros_rule!()
[22:27:52] <engla> sounds like a good idea
[22:27:55] <pauls> How about `different_number!()`?
[22:28:02] <cmr> Is there a table kept in trans somewhere that associates a node_id with the translated type? (or the other way around)
[22:28:12] <strcat> graydon: what should 'fn in()' in std::condition be called? input?
[22:28:34] <bblum> It was the dawn of the Third Age. The beginning of the Macro's Rule. A time of prosperity.
[22:28:51] *** Joins: sigma-pc (sigma@moz-BE11A887.range109-151.btcentralplus.com)
[22:28:55] <strcat> I don't think anything actually calls it
[22:28:56] *** Joins: dwhyte (dwhyte@1922756A.EDC594B0.7BF4A4B0.IP)
[22:29:10] *** Quits: chii (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[22:30:13] <graydon> strcat: oh. it's part of sugar for 'cond.trap(handler).in(body)'
[22:30:16] <graydon> strcat: the tests do
[22:30:24] <strcat> ah
[22:30:25] <graydon> strcat: nobody uses conditions outside that presently
[22:31:00] <cmr> rustpkg does
[22:31:16] <brson> rt::io does, but it's a bit underbaked
[22:31:19] <graydon> strcat: maybe .inside or .during
[22:31:41] <brson> bblum: some of the arc tests in extra deadlock with RUST_NEWRT=1. i'm getting a list, but so far it includes test_mutex_arc_condvar and test_arc_condvar_poison. maybe you can look at that next?
[22:31:42] <toddaaro> brson: PR passed tests, ready for r+
[22:31:55] <bblum> brson: yep, on it
[22:32:04] <cmr> graydon: I think the "well covered" milestone should come before "backwards compatible". I'd be very uncomfortable comitting to backwards compatability until there are tests for things.
[22:32:14] <brson> thanks
[22:32:33] *** Quits: jorendorff (jorendorff@moz-1747FB68.hsd1.tn.comcast.net) (Quit: jorendorff)
[22:33:00] <Florob> iota should clearly be called shroom!(), because 1up</badjokes>
[22:33:12] <graydon> cmr: well-defined is the milestone for defining compatibility. it includes any mechanisms needed to measure the things we're committing to the compatibility-of
[22:33:26] *** Quits: jeff (jeff@moz-F81F6C4E.nyc.biz.rr.com) (Quit: jeff)
[22:33:35] <graydon> cmr: conversely, anything not measured by well-defined is _not_ something committed-to by saying we're "backwards compatible"
[22:33:52] <graydon> well-covered is the same milestone wrt. production-readiness
[22:34:22] <cmr> ok
[22:34:25] <cmr> that makes more sense
[22:34:46] *** Joins: jgilbert_ (jgilbert@moz-7B0110AD.mv.mozilla.com)
[22:34:48] *** Quits: jgilbert (jgilbert@moz-7B0110AD.mv.mozilla.com) (Ping timeout)
[22:35:23] *** Quits: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com) (Quit: pcwalton)
[22:36:11] <bblum> brson: does the use of comm automatically switch to rt::comm with RUST_NEWRT=1?
[22:36:36] <brson> bblum: yes
[22:36:37] <strcat> rusti: let xs = [1, 2, 3]; foreach &x in xs.iter() { printfln!("%d", x) }
[22:36:37] -rusti- <anon>:5:40: 5:42 error: expected `;` or `}` after expression but found `in`
[22:36:37] -rusti- <anon>:5          let xs = [1, 2, 3]; foreach &x in xs.iter() { printfln!("%d", x) }
[22:36:37] -rusti-                                                  ^~
[22:36:37] -rusti- application terminated with error code 101
[22:36:44] <strcat> rusti: let xs = [1, 2, 3]; foreach &x in xs.iter() { printfln!("%d", x) }
[22:36:45] -rusti- 1
[22:36:45] -rusti- 2
[22:36:45] -rusti- 3
[22:36:45] -rusti- ()
[22:36:46] <cmr> Answer to my question: ccx.tydescs
[22:36:46] *** concrete.mozilla.org sets mode: +M 
[22:36:53] <strcat> ugh
[22:36:57] * strcat hates flood protection
[22:37:54] *** brson sets mode: -M 
[22:39:01] <brson> does dotdash hang out on irc?
[22:39:12] <strcat> brson: doener, I think
[22:39:23] <strcat> (yes)
[22:39:25] <cmr> yes
[22:39:42] <brson> ok, good to know, thanks
[22:40:28] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[22:40:39] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[22:40:53] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[22:43:15] <bblum> oh hm, i did get issue 3168 to fail
[22:43:25] <bblum> assertion failed: (*this.packet()).payload.is_none()
[22:43:43] <bblum> i had the RUST_NEWRT=1 in the wrong place on my script
[22:45:07] <toddaaro> brson: when this lands, would you like me to work on some of the old-rt stripping or should I start on workstealing?
[22:45:21] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[22:45:36] <bblum> brson: not seeing any deadlocks yet; i did get a self.unkillable != 0 which i think is the same bug as from lots-a-fail
[22:45:51] <bblum> are you sure it's mutex_arc_condvar
[22:46:12] <bblum> ah, there's task home of None in issue-3168
[22:46:17] <brson> toddaaro: I'd like you to start restructuring the scheduler for work stealing, implement the algo with naive locking queues first, then proceed to the lock-free stuff
[22:46:28] <toddaaro> brson: k, will do that
[22:46:51] <brson> bblum: hm, i was definitely seeing deadlocks. let me try again
[22:46:57] <brson> bblum: and every time too
[22:47:32] <bblum> i definitely don't have deadlocks every time
[22:47:43] <brson> i was running with RUST_THREADS=1 
[22:47:46] <bblum> oh
[22:47:50] <brson> maybe that could have something to do with it
[22:47:57] <bblum> that may change things
[22:48:14] <bblum> yes
[22:48:48] *** Quits: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com) (Ping timeout)
[22:51:08] <Sergio965> I'm getting a very strange error from the compiler. Has anyone seen this before? rustc: Instructions.cpp:549: void llvm::InvokeInst::init(llvm::Value*, llvm::BasicBlock*, llvm::BasicBlock*, llvm::ArrayRef<llvm::Value*>, const llvm::Twine&): Assertion `(i >= FTy->getNumParams() || FTy->getParamType(i) == Args[i]->getType()) && "Invoking a function with a bad signature!"' failed. Aborted (core dumped)
[22:51:58] <cmr> graydon: ping
[22:52:06] <graydon> cmr: pong
[22:52:23] <cde> houston, contact is established
[22:52:28] <cmr> uh
[22:52:30] <cmr> premature ping, sorry
[22:52:32] <cmr> :p
[22:52:42] <cmr> I was going to ask about the changes to the driver
[22:52:46] <cde> abort, I repeat, abort
[22:52:48] <cmr> I think you moved the location lints are run
[22:52:50] <Sergio965> Any help would be greatly appreciated.
[22:53:20] <Luqman> Sergio965: paste the code somewhere
[22:53:23] <cmr> bah, I won't be using the regular lint infrastructure anyway
[22:53:26] <tjc> Sergio965: It means you found a bug in the compiler, please file a bug report at https://github.com/mozilla/rust/issues , thanks!
[22:53:27] <cmr> graydon: full "nevermind" :p
[22:53:28] *** Quits: Earnestly (earnest@CAE8D902.48DC5685.39C00A7A.IP) (Ping timeout)
[22:53:50] <Sergio965> Luqman: I'm trying to compile a freestanding version of the standard library.
[22:53:54] *** kimundi is now known as zz_kimundi
[22:54:49] *** Quits: Florob (Florob@moz-39532932.de) (Client exited)
[22:54:57] <Sergio965> But after resolving all dependencies (I think) I got that. :(
[22:55:31] <bblum> brson: yes hm, send() reschedules on the new runtime, doesn't it?
[22:55:44] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[22:55:53] <orshem> sorry for spamming, but can anybody help me with these errors: https://gist.github.com/DovReshef/6116690
[22:56:00] <Sergio965> tjc: Is there a guide for how to debug errors like this?
[22:56:37] <strcat> Sergio965: it's an LLVM assert, you can get a traceback with gdb
[22:56:45] <tjc> Sergio965: There's not really a guide; if you file an issue, one of us will try to fix it, but if you want to try to get into hacking the compiler, the first step is to run the same command line in gdb and look at the backtrace
[22:56:46] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[22:56:56] <tjc> to see which function in trans (the back end of rustc) invoked an LLVm function incorrectly
[22:57:09] *** Joins: azita (Azita@CEC12B30.1624830.FAF22AF7.IP)
[22:57:15] <bblum> brson: i'm bad; this should have tripped assert_may_sleep (the atomically check) but i didn't actually put a call to assert_may_sleep anywhere
[22:57:49] <Sergio965> How would I attach GDB to rustc?
[22:57:58] <bblum> to fix i will need to send() outside of the exclusive in the condvar implementation
[22:58:15] <Sergio965> orshem: Try add pub to the Outer struct.
[22:58:18] <Sergio965> adding(
[22:58:19] <Sergio965> *
[22:58:19] *** Joins: bnicholson (bnicholson@moz-3492C575.rcmdva.fios.verizon.net)
[22:58:20] <strcat> Sergio965: `gdb rustc`
[22:58:24] <strcat> run foo.rs
[22:58:26] <strcat> bt
[22:58:39] <Sergio965> I'm compiling a library though.
[22:58:49] <strcat> which?
[22:58:50] <brson> bblum: yes, send may reschedule
[22:58:58] <eschweic> iter().any stops as soon as the predicate is true, correct?
[22:59:13] <strcat> eschweic: yes, you can look in iterator.rs to see how they're defined
[22:59:15] <Sergio965> A freestanding version of the standard library I'm working on.
[22:59:21] <strcat> any/all are just 2 lines
[22:59:24] *** Joins: tautologico (lymph@9F01D096.92EA1F6.C27E1635.IP)
[22:59:30] <eschweic> strcat: okay, thank you
[22:59:31] *** Quits: azita (Azita@CEC12B30.1624830.FAF22AF7.IP) (Quit: azita)
[22:59:35] <orshem> Sergio965: but i shouldn't have to since child module have access to their ancestors' privates. the thing is i'm not sure if it's a bug or something i'm failing to understand
[22:59:35] <bblum> toddaaro: please find a good place to put a call to assert_may_sleep() in your revised context switchers
[22:59:48] <jdm> /home/jdm/sdb/servo/src/components/script/dom/element.rs:143:16: 143:48 error: unresolved name `HTMLHeadElementBinding`.
[22:59:51] <jdm> /home/jdm/sdb/servo/src/components/script/dom/element.rs:143                 concat_idents!($name, Binding)::Wrap(cx, scope, self, &mut unused)
[22:59:54] <jdm> use dom::bindings::codegen::HTMLHeadElementBinding;
[22:59:58] <jdm> something doesn't add up here?
[23:00:02] <bblum> toddaaro: task.death.assert_may_sleep()
[23:00:21] <Sergio965> orshem: You at least have to make inner pub and then do use inner::*.
[23:00:22] <Luqman> Sergio965: that's ok,  just run `gdb --args rustc libstd/std.rs`
[23:00:27] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Client exited)
[23:00:47] *** Quits: Nisstyre (wes@moz-FD86289.netflash.net) (Quit: Leaving)
[23:00:54] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[23:01:00] <toddaaro> bblum: what is that assert for?
[23:01:16] <bblum> toddaaro: it should be called every context switch
[23:01:26] <bblum> it is for atomically()
[23:01:40] <strcat> to weed out the tasks up past their bed time
[23:01:44] <toddaaro> every every? could put it in change_task_context
[23:01:54] <toddaaro> or is this only on GreenTasks
[23:02:10] *** Joins: Earnestly (earnest@CAE8D902.48DC5685.39C00A7A.IP)
[23:02:16] <bblum> if a scheduler task is a Task then it will have a death too, so it may as well check
[23:02:23] <bblum> because schedulers do access exclusives
[23:02:29] <Sergio965> Ah, nice.
[23:02:36] <Sergio965> Seems like: #10 0xb6d098c4 in middle::trans::build::Invoke::_acb7824fa820953::_0$x2e7 ()
[23:02:51] <bblum> (the assertion is just checking a task-local flag; it's not expensive or anything)
[23:03:02] <jdm> pauls: ping
[23:03:08] <jdm> or anybody else who understands macros
[23:03:23] <orshem> Sergio965: that wasn't what i understood here: https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-07-30#visibility-in-module-system
[23:03:45] <Sergio965> orshem: Yes, but I'm referring to the test.
[23:03:55] <bblum> brson: ok, i will probably have fixes for these two bugs ready tomorrow
[23:04:09] <orshem> Sergio965, but the test is part of the parent module, no?
[23:04:19] <Sergio965> orshem: The function is in the module inner, so you'll need to do inner::run_from_outside.
[23:04:22] <toddaaro> bblum: in that case it will be trivial to add, I'll put up a PR once the current one lands
[23:04:31] <bblum> toddaaro: great, thx
[23:04:34] <brson> bblum: awesome
[23:05:04] *** Joins: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net)
[23:05:12] <toddaaro> bblum: you want this on the task we are swapping away from, correct?
[23:05:19] <bblum> toddaaro: yeah
[23:05:43] <bblum> it does not do much good to prevent pthread mutex deadlocks if your assert will only trip after the deadlock is somehow magically resolved
[23:05:43] <strcat> wow xdelta3 actually made a 9.8MiB delta today
[23:05:46] <bblum> c.c
[23:05:47] <strcat> it's a miracle
[23:06:04] <toddaaro> bblum: if you want it now for debugging put it right after Local::take::<Task>(); in change_task_context, line 536 for sched.rs in my PR
[23:06:15] <bblum> OK
[23:07:41] <paupau> what's the use of uuid!()?
[23:07:44] <jdm> wow, we really don't use concat_idents in the compiler anywhere
[23:08:27] <orshem> Sergio965: brson told me that yesterday, but it doesn't work either: https://gist.github.com/DovReshef/6127037
[23:08:35] <strcat> rusti: let concat_idents!(j, d, m) = 5; jdm
[23:08:35] -rusti- <anon>:5:26: 5:27 error: expected `;` but found `!`
[23:08:35] -rusti- <anon>:5          let concat_idents!(j, d, m) = 5; jdm
[23:08:36] -rusti-                                    ^
[23:08:36] -rusti- application terminated with error code 101
[23:08:48] * strcat cries
[23:09:07] <jdm> /home/jdm/sdb/servo/src/components/script/dom/element.rs:143:16: 143:53 error: concat_idents! expecting comma.
[23:09:09] <strcat> now I remember where I wanted to use that for, and can't ;p
[23:09:10] <jdm> /home/jdm/sdb/servo/src/components/script/dom/element.rs:143                 concat_idents!($name, Binding::Wrap)(cx, scope, self, &mut unused)
[23:09:13] <jdm> wat
[23:09:59] <jdm> why does concat_idents taunt me so
[23:10:55] <Sergio965> orshem: It works if you make it pub.
[23:11:08] <cmr> So, how large is large, for https://github.com/mozilla/rust/issues/6600
[23:11:51] <jdm> why does concat_idents taunt me so
[23:11:52] <jdm> er
[23:12:05] <engla> I don't think it works
[23:12:17] <orshem> Sergio965, yes i know but it should also work while private according to brson graydon pcwalton et al, which means i'm missing something
[23:12:18] <Sergio965> orshem: Your run_from_outside function.
[23:12:26] <orshem> thanks for helping me anyhow
[23:12:30] <strcat> rusti: let ab = 5; concat_idents!(a, b)
[23:12:31] -rusti- 5
[23:12:54] <Sergio965> orshem: Are you using Outer should be private?
[23:13:02] <Sergio965> IE, Outer should be able to be used by Inner?
[23:13:06] <strcat> rusti: let ab = 5; concat_idents!(a, c, ,)
[23:13:06] <Sergio965> Even if it's private?
[23:13:06] -rusti- <anon>:5:21: 6:5 error: concat_idents! requires ident args.
[23:13:06] -rusti- <anon>:5          let ab = 5; concat_idents!(a, c, ,)
[23:13:07] -rusti- <anon>:6     };
[23:13:07] -rusti- application terminated with error code 101
[23:13:17] <strcat> rusti: let ab = 5; concat_idents!(a c)
[23:13:18] -rusti- <anon>:5:21: 6:5 error: concat_idents! expecting comma.
[23:13:18] -rusti- <anon>:5          let ab = 5; concat_idents!(a c)
[23:13:18] -rusti- <anon>:6     };
[23:13:18] -rusti- application terminated with error code 101
[23:13:39] <orshem> Sergio965, since Outer is part of the parent module inner should have access to it even while private
[23:13:49] <strcat> jdm: I think foo::bar is two idents
[23:14:08] <strcat> and it's not happy about the ::
[23:14:13] <orshem> symmetrically run_from_outside should be available to the parent module 
[23:14:16] <jdm> rusti: mod barfoo { fn foo() {} }; concat_idents!(bar, foo)::foo()
[23:14:17] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/bcQD
[23:14:29] <strcat> wat
[23:14:35] <jdm> strcat: exactly my reaction
[23:14:52] <strcat> where... does the :: go? ;p
[23:14:57] <dbaupp> cmr: some number?
[23:15:08] * jdm files
[23:15:14] <cmr> dbaupp: what do you mean?
[23:15:40] <dbaupp> cmr: the value of "large" isn't fixed
[23:15:43] <cmr> right
[23:15:50] <cmr> but I need one for the lint
[23:16:01] *** Quits: paupau (textual@FFAF02D4.F5573215.F20F0C5A.IP) (Ping timeout)
[23:16:08] <cmr> and you can't pass parameters to a lint in a unified way (yet), so I'd rather just not go down that road
[23:16:13] <graydon> bblum: you've been working on select, yes? do you have comments on https://github.com/mozilla/rust/issues/5160 ? is it worth keeping as a separate bug?
[23:16:17] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Ping timeout)
[23:16:55] <graydon> nmatsakis: the plan is to make @ not-able to have &, correct?
[23:17:01] <graydon> (not-able to own)
[23:17:09] <dbaupp> cmr: what size does LLVM switch to calling memcpy rather than emitting the movs itself?
[23:17:20] <cmr> dbaupp: good question!
[23:17:21] <Sergio965> orshem: I'm not sure what the exact semantics are, but as of 0.7, Outer certainly needs to be public. The notes you pointed to seem to suggest that this is a known issue and that the behavior you're hoping for is in fact the desired behavior and in enroute.
[23:17:29] <cmr> strcat: do you know the answer to that off the top of your head?
[23:17:33] <dbaupp> cmr: (just using that as an arbitrary point seems reasonable.)
[23:17:44] <bblum> graydon: funny thing, i just opened https://github.com/mozilla/rust/issues/8168 like five seconds ago
[23:17:56] <strcat> cmr: totally depends on the target
[23:18:06] <dbaupp> cmr: (not even bothering with platform differences... just test on one.)
[23:18:09] <strcat> also it won't necessarily use mov, it can use sse/avx
[23:18:12] <cmr> strcat: is it queryable at runtime?
[23:18:18] <cmr> at compiletime, that is
[23:18:23] <cmr> runtime for llvm :p
[23:18:32] <strcat> I don't think it's going to be a single tipping point
[23:18:40] <strcat> it depends on whether it wants to optimize for size there
[23:18:50] <strcat> if it doesn't, it will probably never use a memcpy call
[23:19:08] <bblum> graydon: yes it is, it's an easy cleanup bug
[23:19:12] <cmr>  /o\
[23:19:15] <cmr> someone just pick a number!
[23:19:17] * dbaupp thinks just choosing some number is better than bothering with optimising the number at the moment
[23:19:18] <strcat> they lift things up to a memcpy intrinsic where possible, and then lower the memcpy intrinsic down to good code
[23:19:26] <jdm> what kind of macro argument can accept something like foo::bar?
[23:19:27] * cmr was thinking 8 words
[23:19:28] <orshem> Sergio965: ok so it's a bug :) that's great! (better than me losing my mind) i'll open an issue
[23:19:30] <jdm> not ident, not expr
[23:19:31] <strcat> dbaupp: where do you need to choose?
[23:19:37] <dbaupp> jdm: path
[23:19:39] <cmr> strcat: I'm writing a lint for https://github.com/mozilla/rust/issues/6600
[23:19:42] <jdm> /home/jdm/sdb/servo/src/components/script/dom/element.rs:156:45: 156:73 error: unresolved name
[23:19:43] <orshem> Sergio965: thanks 
[23:19:45] <jdm> /home/jdm/sdb/servo/src/components/script/dom/element.rs:156 generate_cacheable_wrapper!(HTMLHtmlElement, HTMLHtmlElementBinding::Wrap)
[23:19:48] <jdm> aha, thanks
[23:20:05] *** jgilbert_ is now known as jgilbert
[23:20:22] <strcat> dbaupp: the memcpy intrisic we emit is lowered as part of codegen afaik
[23:20:29] <strcat> not during passes
[23:21:15] <brson> graydon: how do codegen tests work? what are they comparing?
[23:22:05] <dbaupp> strcat: I see a memcpy@PLT in the asm when compiling with -O for `let x = [1i, .. 100]; let y = x;`
[23:22:21] <graydon> brson: you make two tests with same basename, foo.cc and foo.rs
[23:22:40] <cmr> dbaupp: how about ..16 ?
[23:22:47] <graydon> brson: in each, make a non-mangled (#[no_mangle] or extern "C" in C++) function called 'test'
[23:22:50] <brson> dbaupp: that's alarming
[23:22:52] <dbaupp> cmr: nope
[23:22:56] <graydon> brson: make them do the same thing in each, logically
[23:23:14] <graydon> brson: it then reports the ratio of LLVM code generated for the rust 'test' function vs. the C++ 'test' function
[23:23:24] <brson> i wish llvm wouldn't insert arbitrary calls to libc behind our backs
[23:23:49] <dbaupp> cmr: it appears that the boundary is 30; <= 30 = series of movs, >= 31 = memcpy@PLT
[23:24:03] <dbaupp> (on x86-64 linux.)
[23:24:17] <strcat> brson: it does it for quite a few things
[23:24:39] <strcat> fmod, memcpy, memmove, memset, memcmp at least
[23:25:06] <brson> graydon: what ratio makes the tests fail?
[23:25:23] <dbaupp> can we register our own "intrinsics" that LLVM emits instead of the libc ones?
[23:25:42] <graydon> brson: nothing. only a regression in the ratio from the previous run.
[23:25:45] <bblum> brson: hmm, actually, this send-rescheduling thing is not a trivial problem to solve at all.
[23:25:51] <graydon> brson: it can be arbitrarily bad, just not get worse.
[23:26:31] *** Quits: Sergio965 (sergiobz@moz-BB21156B.dynamic.csail.mit.edu) (Ping timeout)
[23:26:33] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[23:26:37] <bblum> brson: what would you think of a send variant that pops the current task off the sched workqueue, pushes the woken receiving task, and then pushes the current task back on in front, thus guaranteeing no reschedule?
[23:26:43] <bblum> it could be unsafe or whatever
[23:27:02] <toddaaro> bblum: catch me up - why is send rescheduling bad?
[23:27:08] <bblum> toddaaro: while holding a pthread mutex
[23:27:12] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[23:27:21] <toddaaro> what would be holding a mutex while sending?
[23:27:51] <bblum> the semaphore and condvar implementations have a waitqueue (== Stream<ChanOne<()>>) and a uint counter inside of an Exclusive
[23:28:55] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[23:29:10] <bblum> it is very careful never to recv() inside the exclusive but it needs to send() to be properly atomic
[23:29:22] <toddaaro> bblum: yea, just implement asyncSend that doesn't reschedule
[23:29:25] <toddaaro> that should be trivial to do
[23:30:13] <toddaaro> bblum: you shouldn't need to do any popping, just push the woken task onto the queue
[23:30:18] <toddaaro> and then continue
[23:30:22] <dbaupp> cmr: which lint are you implementing, btw?
[23:30:25] <brson> i don't want to make this a public part of the interface. are there alternatives?
[23:30:29] <bblum> toddaaro: ah hm, perhaps
[23:30:30] <toddaaro> Scheduler::run_task_later should do the trick
[23:30:51] <brson> is there another private data type that is easy to build that could do this?
[23:30:51] <bblum> toddaaro: 'send_atomic'! That name will not confuse anybody, for sure.
[23:31:00] <toddaaro> bblum: for sure
[23:31:05] <cmr> dbaupp: just warn on large types
[23:31:08] <brson> this seems only important for libraries implementing concurrency primitives
[23:31:17] <bblum> yes, that is the only place it is important :P
[23:31:24] <cmr> dbaupp: it can't actually be a lint though :\
[23:31:37] <bblum> brson: I think I had an idea for doing semaphores without an exclusive, but it might not work for condvars... trying to remember...
[23:31:40] <dbaupp> cmr: yeah, it needs to run after/during trans
[23:31:48] <cmr> dbaupp: during, the ccx is tossed after trans
[23:32:04] <strcat> dbaupp: I don't really think so
[23:32:13] <strcat> you can provide your own memcpy if you don't link to libc ;s
[23:32:27] <cmr> And none of the lint infrastructure can be used outside of lint, it seems
[23:32:27] <dbaupp> cmr: (well, you could modify it to keep the ccx for "trans-lints".)
[23:32:28] <toddaaro> brson: maybe, async_send might actually be useful in more places though
[23:32:53] <strcat> but really we don't want to write our own memcpy, etc.
[23:32:53] <toddaaro> brson: it gives a pleasing level of control over scheduling behavior in a surprisingly intuitive way
[23:32:57] <dbaupp> strcat: so we need to reimplement libc... :(
[23:33:11] <toddaaro> brson: though it should certainly be outside the "top" level interface for a normal user, they should never think about this. ever.
[23:33:14] <cmr> graydon: ping (for real this time)
[23:33:26] <bblum> toddaaro: +1, i could see there being cases where the caller knows that the receiver will just go right back to sleep again after receiving one packet, and so wants to send multiple before switching over
[23:33:52] <strcat> dbaupp: well it would mean forbidding linking against libc
[23:33:58] <graydon> cmr: pong, though only got about a half hour
[23:34:00] <kmc> I think the cutoff for inline memcpy may depend on the cpu -march / -mtune options as well; at least GCC will produce some fancy unrolled loops with prefetching
[23:34:01] <strcat> either that or rustc can lower copies itself afaik
[23:34:13] <strcat> kmc: it does
[23:34:23] <strcat> it will use avx, etc.
[23:34:40] <cmr> graydon: Would you be opposed to returning the ccx from trans_crate, and me adding another pass for trans-lints?
[23:34:56] <kmc> fun fact: on Ivy Bridge the fastest memcpy is the lowly REP MOVSB... as long as the buffers don't overlap even when addresses are truncated to 12 least significant bits
[23:35:15] <cmr> kmc: that is a fun fact
[23:35:25] <acrichto> cmr: if you're just ignoring lints you could also have a `-Z no-lint` type option
[23:35:46] <cmr> acrichto: we only have 32 -Z options, I'd rather not add another
[23:35:52] *** Joins: lkuper (lkuper@FBBF6446.A402E718.C082B7DC.IP)
[23:36:13] *** Joins: bytewise (bytewise@moz-649C630D.unitymediagroup.de)
[23:36:20] <sully> sigh, there is zero debug spew in pattern compilation
[23:36:23] <graydon> cmr: what kind of lints?
[23:36:32] <cmr> graydon: specifically, right now, https://github.com/mozilla/rust/issues/6600
[23:36:33] <acrichto> cmr: well, we don't have to have 32 options. there's a u64 and beyond that we could even have a bit vector :)
[23:37:06] <bblum> brson: it might work with an UnsafeArc of a MegaPipe and an AtomicInt but it would most likely be considerably slower
[23:37:06] <dbaupp> acrichto: *should have an EnumSet
[23:37:14] <bblum> (MEGAPIPE)
[23:37:21] <acrichto> dbaupp: ah yes, you are correct
[23:38:08] <dbaupp> strcat: do you know how feasible it would be to patch LLVM to change it's behaviour wrt emitting libc calls?
[23:38:13] *** Joins: Rosti (Mibbit@moz-C995772.netcologne.de)
[23:38:20] <acrichto> cmr: also oh I understand what you're doing now, you can disregard me
[23:38:42] <cmr> acrichto: ok
[23:38:45] <cmr> :)
[23:38:46] <toddaaro> how do I interpret the build-bot's "build waterfall" page?
[23:39:03] <toddaaro> looking at it the build slaves almost all seem idle, is that common?
[23:39:32] <graydon> cmr: I guess. it's a lot to return, but I don't see much harm if you drop it soon thereafter.
[23:39:54] <graydon> toddaaro: interpret it as waiting for bors to move auto in the next 3-6 minutes.
[23:39:58] <brson> bblum: ok, please add a new trait for async_send. the 'i could see there being cases ...' argument doesn't necessarily convince me - I want to kill features that don't have real users - but you have a real use case now, and this is the most obvious way to solve it
[23:39:59] <cmr> graydon: it can be dropped before phase_4_run_whatever completes I think
[23:40:03] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[23:40:14] *** Quits: yonran (yonran@moz-962F33EB.acuitus.com) (Ping timeout)
[23:40:28] <bblum> brson: will do, thanks
[23:40:31] <graydon> toddaaro: or, well, in this case bors isn't doing anything because it's waiting for auto-mac-all-opt
[23:40:36] *** Quits: jdm (jdm@CAB30FBD.8F96AEA7.2D179A7D.IP) (Quit: Lost terminal)
[23:40:57] <graydon> toddaaro: it won't move auto until it's seen either a failure, or all-pass
[23:41:11] <bblum> also we need a better name than async_send, because our current send is already async
[23:41:15] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[23:41:26] <toddaaro> graydon: interesting, so the slowest build bottlenecks, I guess that makes sense
[23:41:28] <bblum> and SendNoResched has maximum clunk
[23:41:41] <graydon> toddaaro: yup. ideally they should all be similar-time. also ponies.
[23:42:02] <toddaaro> bblum: async_async_send
[23:42:05] <bblum> good one
[23:42:10] <strcat> dbaupp: I don't think it's going to fun to do that, at least
[23:42:11] <graydon> toddaaro: in reality the non-opt and the all (multilib) builds take a while
[23:42:21] <toddaaro> bblum: the SO questions would be hilarious
[23:43:29] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[23:43:29] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/yCTRYg
[23:43:29] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[23:43:34] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[23:44:28] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Quit: WeeChat 0.4.1)
[23:45:20] <strcat> dbaupp: I think it's more feasible to just do segmented stacks differently... stick a guard page at the end, grow on a fault
[23:45:34] <strcat> if someone wants to go through the horrible pain of signals + sigaltstack
[23:46:12] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[23:46:17] <strcat> and teach LLVM to only emit __morestack on calls allocating more than that guard size (can't be that hard)
[23:46:26] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[23:46:26] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/xDo0PA
[23:46:26] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[23:46:29] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[23:46:29] <ghrust> 01[13rust01] 15bors pushed 6 new commits to 06auto: 02http://git.io/2eREDQ
[23:46:29] <ghrust> 13rust/06auto 145910834 15toddaaro: A major refactoring that changes the way the runtime uses TLS. In the...
[23:46:29] <ghrust> 13rust/06auto 14f1d909c 15Ben Blum: Have linked failure tests run on the new scheduler instead of requiring RUST_NEWRT to test.
[23:46:29] <ghrust> 13rust/06auto 1485d8552 15toddaaro: Fixed a race where a scheduler configured to only run tasks pinned to it would "bounch" a regular task in and out of the work queue without allowing a different scheduler to run it.
[23:46:32] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[23:46:41] <strcat> and.... just hope C functions don't allocate more than 4K without initializing it? ;p
[23:46:43] * strcat shrugs
[23:46:50] <brson> surely llvm has the ability to not call into libc. are all languages required to stub out these libc functions?
[23:47:02] <strcat> brson: freestanding means you provide your own memcpy, memcmp, etc.
[23:47:04] <cmr> graydon: I think the instruction accounting reporting could also be a lint after I'm done this work
[23:47:22] <strcat> brson: even in a kernel you have to provide them for it
[23:47:33] *** sam113101 is now known as sam113101_afk
[23:47:39] *** Quits: bent (chatzilla@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: ChatZilla 0.9.90.1-rdmsoft [XULRunner 22.0/20130619132145])
[23:47:43] *** Quits: Vert (quassel@8A83479C.391ACC8C.CAF63861.IP) (Client exited)
[23:47:43] <brson> strcat: maybe we can provide a .a file that calls into std
[23:47:55] <brson> or just provides the implementations
[23:48:15] *** sam113101_afk is now known as sam113101
[23:48:31] <brson> actually, they would need to call std. not all the fns llvm generates calls to fit into the red zone
[23:50:06] <dbaupp> cmr: btw, for those lints, the most useful lint would be the one that warns on large implicit copies.
[23:50:31] <strcat> brson: stuff like the loop-idiom pass is hardcoded to not optimize memcpy itself to a memcpy
[23:50:31] <cmr> dbaupp: we don't have implicit copies anymore?
[23:50:39] <strcat> brson: so it's really all a hack ;p
[23:51:10] <dbaupp> cmr: yeah we do; it's explicit copies that we're missing.
[23:51:26] <cmr> dbaupp: we have .clone for that I thought, and all other implicit copies were removed
[23:51:32] <strcat> they make assumptions based on symbol names too
[23:51:37] <dbaupp> rusti: let x = [1, .. 10000]; let implicit_copy = x;
[23:51:39] -rusti- <anon>:5:36: 5:49 warning: unused variable: `implicit_copy` [-W unused-variable (default)]
[23:51:39] -rusti- <anon>:5          let x = [1, .. 10000]; let implicit_copy = x;
[23:51:39] -rusti-                                              ^~~~~~~~~~~~~
[23:51:39] -rusti- ()
[23:51:46] <cmr> I see
[23:51:50] *** Quits: orshem (orshem@C5E06B1E.A5B6B765.E3D28531.IP) (Quit: Leaving)
[23:51:55] <strcat> dbaupp: what about in generic code?
[23:51:57] <strcat> how will you warn?
[23:52:05] <strcat> I guess you won't warn on clone()
[23:52:08] <cmr> Implicit copies aren't allowed for generics
[23:52:16] <dbaupp> strcat: yeah, just implicit copies.
[23:52:17] <cmr> (I think *that* is what I was confused about)
[23:52:28] <kmc> in what circumstances do implicit copies still exist?
[23:52:51] <strcat> kmc: objects without &mut, destructors or &fn are implicitly copyable
[23:53:06] *** Joins: msingle (Thunderbir@moz-20675462.nrflva.fios.verizon.net)
[23:53:09] <strcat> all other objects move
[23:53:13] <kmc> ok
[23:53:17] *** Quits: msingle (Thunderbir@moz-20675462.nrflva.fios.verizon.net) (Quit: msingle)
[23:53:21] <kmc> so the copy will happen e.g. when I call a function which takes that object by value?
[23:53:25] <kmc> or just do let y = x
[23:53:30] <strcat> either
[23:53:32] <kmc> right
[23:53:36] <Seldaek> is there something in std/extra to help write parsers? lexer generator or something?
[23:53:41] <strcat> a move is just an implicit copy stealing ownership too
[23:53:45] <kmc> and for other objects, both of these things are allowed, but x will be dead after and the typechecker will yell at me if I use it?
[23:53:49] <dbaupp> Seldaek: nope
[23:53:52] <strcat> kmc: yes
[23:54:15] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[23:54:34] <Seldaek> dbaupp: sad, finite state machine neither hu?
[23:54:45] <dbaupp> Seldaek: nope
[23:54:57] *** Joins: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net)
[23:55:07] *** Quits: vosen (vosen@moz-266BA656.icpnet.pl) (Quit: Leaving)
[23:55:08] *** Quits: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com) (Client exited)
[23:55:18] <dbaupp> Seldaek: although there is https://mail.mozilla.org/pipermail/rust-dev/2013-February/003179.html
[23:55:30] *** Joins: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com)
[23:55:36] <strcat> I think it needs to be rewritten
[23:55:40] <strcat> for labelled breaks
[23:56:17] <dbaupp> yeah, and general breakage presumably.
[23:56:30] <Seldaek> yup but still cool
[23:56:56] <dbaupp> strcat: https://github.com/erickt/ragel/commit/8d8b110be54d93878c9c106f0f06dbaf52190e31 btw
[23:57:11] *** Quits: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com) (Ping timeout)
[23:57:47] *** Quits: eholk (eholk@moz-3EBC7183.uconnect.utah.edu) (Quit: eholk)
[23:59:16] <sully> ok emacs has suddenly decided that rust should be indented at 8 space tabs and I don't know why
[23:59:47] <jack> c-basic-offset probably get reset or the way it's read changed?

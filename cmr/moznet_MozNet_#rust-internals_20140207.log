[00:01:36] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[00:01:36] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/8FEsOQ
[00:01:36] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[00:02:02] <acrichto> eddyb: \o/
[00:02:19] <eddyb> finally!
[00:02:32] <eddyb> now I can fix my weird lifetime error
[00:04:05] <strcat> acrichto: hm, do you mind if I put a priority on the tydesc one so I can snapshot it?
[00:04:24] <strcat> probably too late anyway
[00:04:25] <strcat> ;p
[00:04:48] <strcat> if only snapshots didn't take 3 hours...
[00:05:05] <acrichto> strcat: I relinquish my spot
[00:05:09] <strcat> \o/
[00:05:40] <strcat> luckily bors is really slow
[00:06:02] <strcat> ugh wait
[00:06:04] <strcat> it's on the wrong one
[00:06:17] <strcat> github...
[00:06:21] <strcat> fixed
[00:06:33] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[00:06:33] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/Xxg5UQ
[00:06:33] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[00:06:34] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[00:06:34] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/B52ZBQ
[00:06:34] <ghrust> 13rust/06auto 1457d65da 15Ben Noordhuis: Support weak/common/private/etc. symbol linkage....
[00:06:34] <ghrust> 13rust/06auto 14ffb7d35 15Ben Noordhuis: Link weakly to __pthread_get_minstack()....
[00:06:35] <ghrust> 13rust/06auto 140ca7002 15bors: auto merge of #11978 : bnoordhuis/rust/weak-symbol-support, r=alexcrichton...
[00:06:37] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[00:06:40] * strcat cries ;p
[00:06:41] <acrichto> strcat: ho well :(
[00:06:44] <acrichto> oh*
[00:07:05] <acrichto> dbaupp: btw std::fmt overhaul looks really nice! I wanna take another quick look over it when comments are in there, but otherwise it should be good to go
[00:07:06] <strcat> https://github.com/mozilla/rust/pull/12059 beautiful ordering github. beautiful.
[00:07:09] *** Quits: xales (xales@moz-7DEA692E.forevernothing.com) (NickServ (GHOST command used by xales1))
[00:07:23] *** Joins: xales1 (xales@moz-7DEA692E.forevernothing.com)
[00:07:31] <strcat> it actually put them in the reverse order
[00:07:41] <acrichto> go github
[00:07:41] <flaper87> bah, I need to rebase the crate patch again, I guess I'll just wait until we decide what to do with it.
[00:07:46] <strcat> and it put those 2 comments on one before and the final one after
[00:08:14] <dbaupp> acrichto: cool; I'm away from my rust dev computer atm (currently using mibbit :'( ), so it'll be several hours before I can address them
[00:08:16] <strcat> oh well
[00:08:36] <acrichto> dbaupp: no rush of course
[00:08:43] *** Joins: xales (xales@moz-2499F5A4.naveria.com)
[00:08:45] <strcat> guess this means it'll land around 9pm and then the snapshot will be there at maybe 11pm or 12am
[00:08:48] <strcat> so I will likely still be awake...
[00:09:09] <strcat> it'll probably fail to snapshot 3 times, ofc
[00:10:26] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[00:10:26] <ghrust> 01[13rust01] 15alexcrichton 04force-pushed 06try from 140ea0563 to 14f95f0f2: 02http://git.io/k471pw
[00:10:26] <ghrust> 13rust/06try 14e9320c0 15chromatic: Removed prelude::* from libstd files....
[00:10:26] <ghrust> 13rust/06try 14f95f0f2 15chromatic: Cleaned up imports per coding standards....
[00:10:27] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[00:10:42] <brson> acrichto: did you resolve the type system question with the weak linkage patch?
[00:11:06] <acrichto> brson: not yet, I figured that the need for it was more pressing, but we could also cancel
[00:11:52] <acrichto> brson: it would probably need a good deal more work because you'd probably want the first-class type of the foreign symbol to be Option<T> instead of T
[00:12:02] <brson> acrichto: indeed i'm not comfortable adding a feature that intentionally breaks the type system
[00:12:07] <eddyb> how come the lifetimes worked in my previous PR, but not this one? it's really weird
[00:12:12] <acrichto> brson: wanna cancel?
[00:12:13] <strcat> btw what's the use case for the weak linkage pull?
[00:12:16] <strcat> weak linkage is kinda weird
[00:12:27] <brson> acrichto: yes please
[00:12:29] <acrichto> strcat: finding __pthread_get_minstack() on various glibc versions
[00:12:45] <acrichto> brson: cool
[00:12:49] <strcat> could it just be marked unsafe?
[00:13:26] <strcat> you know what's sad...
[00:13:42] <strcat> I think at least 20 of these performance related issues are caused by not being able to mark ptrs as valid
[00:13:54] *** Joins: brson_ (brson@moz-DFAA4E15.p2p.sfo1.mozilla.com)
[00:14:08] <strcat> bounds checks not being eliminated, iterators not always optimizing all the way, etc.
[00:14:32] <dbaupp> does your nonnull patch address it?
[00:14:40] <strcat> https://github.com/mozilla/rust/issues/11015 this one too
[00:14:48] <strcat> dbaupp: no, it helps but it doesn't help enough
[00:15:01] *** Quits: brson (brson@6A848D32.C1B840DD.76F66111.IP) (Ping timeout)
[00:15:04] <strcat> a nonnull attribute only allows marking the outer pointer in parameter or return value
[00:15:12] <dbaupp> ah, not in structs
[00:15:20] <strcat> right
[00:15:21] <dbaupp> and so not in slices...
[00:15:24] <strcat> yep...
[00:15:36] *** Joins: cgaebel (clark@ADA4DDE2.290DF317.EE6E63A5.IP)
[00:17:03] *** Quits: xales1 (xales@moz-7DEA692E.forevernothing.com) (Quit: Derp)
[00:17:29] <dbaupp> wasn't there some hack possible with a noop function taking a parameter marked nonnull?
[00:17:39] <acrichto> strcat: how confident are you that the glue patch will pass tests?
[00:17:48] <strcat> well it passes locally
[00:17:56] <strcat> but I had to do a very minor rebase
[00:18:03] <acrichto> eh, good enough, I'll merge auto into snap-stage3 when it gets pushed
[00:18:24] <strcat> if librustc builds in stage1 then I'm confident it will land
[00:18:29] * strcat will try locally
[00:18:48] <strcat> eddyb's removal of @Trait touched glue.rs
[00:21:35] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[00:21:35] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 140ca7002 to 146d27b01: 02http://git.io/N3iJvQ
[00:21:35] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[00:21:35] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[00:21:35] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/sOMbUA
[00:21:35] <ghrust> 13rust/06auto 140059065 15Daniel Micay: remove type descriptors from proc and @T...
[00:21:35] <ghrust> 13rust/06auto 14ba947e2 15Daniel Micay: allow generating drop glue without the TyDesc...
[00:21:36] <ghrust> 13rust/06auto 14efa88b1 15Daniel Micay: rm out-of-date comment from std::unstable::raw
[00:21:38] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[00:22:02] <strcat> acrichto: seems like it'll work
[00:22:31] *** Quits: brson_ (brson@moz-DFAA4E15.p2p.sfo1.mozilla.com) (Ping timeout)
[00:23:11] <dbaupp> strcat: does it make much difference to the size of an (optimised) libstd?
[00:23:14] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[00:23:14] <ghrust> 01[13rust01] 15alexcrichton merged 06auto into 06snap-stage3: 02http://git.io/V-9e2A
[00:23:14] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[00:23:21] <strcat> dbaupp: 5-10%
[00:23:26] <strcat> in LLVM IR
[00:23:32] <strcat> it doesn't change the compiled size
[00:23:52] <strcat> dbaupp: atm, let x = ~5; generates a tydesc for ~int
[00:23:55] *** Joins: lpy (lpy@B3BE13AC.47A0616D.E99F7FDB.IP)
[00:23:59] <strcat> dbaupp: and you get these tydescs recursively
[00:24:17] <strcat> and with the changeset, you *only* get tydescs from get_tydesc
[00:24:29] <strcat> which is what std::reflect does
[00:24:38] <strcat> get_tydesc and then visit_tydesc, iirc
[00:25:17] <dbaupp> much nicer
[00:25:17] <strcat> dunno how much it helps compile-time.
[00:25:39] <strcat> just chipping away at thinks I think hurt the compile-time
[00:25:43] <strcat> things*
[00:25:45] *** Quits: pcwalton (pcwalton@moz-DA87EE4.hsd1.ca.comcast.net) (Quit: pcwalton)
[00:26:00] *** Quits: lpy (lpy@B3BE13AC.47A0616D.E99F7FDB.IP) (Ping timeout)
[00:26:24] <strcat> acrichto: yep made it to stage2
[00:26:38] <strcat> (locally ;p)
[00:27:17] *** flaper87 is now known as flaper87|afk
[00:27:55] *** Joins: brson (brson@moz-DFAA4E15.p2p.sfo1.mozilla.com)
[00:27:55] *** ChanServ sets mode: +qo brson brson
[00:29:26] <acrichto> rusti: version
[00:29:28] -rusti- "rustc 0.10-pre (4cd555d 2014-01-24 03:28:15 -0500)"
[00:30:15] <strcat> acrichto: cmr's change to switch the driver to native never landed
[00:30:22] <cgaebel> how much overhead does an option have? 32-bits?
[00:30:34] <strcat> cgaebel: not a specific overhead
[00:30:37] <sfackler> as little as possible
[00:30:44] <sfackler> Option<~Foo> is the same size as ~Foo
[00:30:47] <strcat> cgaebel: Option<NonNullablePtr> is the same size as NonNullablePtr
[00:30:57] <strcat> Option<bool> is 2x the size of bool
[00:31:00] <cgaebel> what about Option<u32>?
[00:31:02] <strcat> Option<u32> is 2x the size of u32
[00:31:10] <cgaebel> ok
[00:31:11] <strcat> cgaebel: it needs a byte for a tag, and then there is padding
[00:31:17] <cgaebel> Option<u64>?
[00:31:20] <cgaebel> 128?
[00:31:21] <strcat> cgaebel: 2x u64
[00:31:23] <cgaebel> ok.
[00:31:25] <strcat> align of u64 is 8
[00:31:32] <cgaebel> I see
[00:31:37] <strcat> and it has to preserve that in [T, ..n]
[00:31:44] <strcat> the 2nd type starts at an aligned boundary
[00:31:50] <strcat> so it pads to the alignment multiple
[00:31:54] <strcat> like C
[00:31:56] <cgaebel> makes sense.
[00:32:16] <strcat> acrichto: hehe, I think the rustdoc fix isn't 100%
[00:32:22] <strcat> /bin/sh: --cfg: command not found
[00:32:24] <strcat> /bin/sh: --cfg: command not found
[00:32:40] <acrichto> argh
[00:33:10] <strcat> makefiles.
[00:33:21] <acrichto> well at least it's a trivial fix
[00:36:27] *** Quits: dherman (dherman@moz-DFAA4E15.p2p.sfo1.mozilla.com) (Quit: dherman)
[00:37:33] <ChrisMorgan> rusti: macro_rules! s(($($t:ty)*)=>(($((std::mem::size_of::<Option<$t>>(), std::mem::size_of::<$t>())),*))) s!(bool u8 u16 u32 u64)  // ‚Üê cgaebel
[00:37:34] -rusti- ((2u, 1u), (2u, 1u), (4u, 2u), (8u, 4u), (16u, 8u))
[00:40:21] <eddyb> I just killed mk_fake_ident_interner
[00:40:31] <dbaupp> eddyb: murderer!
[00:43:54] <eddyb> why does ext::quote pretty-print *then* parse?
[00:44:10] <eddyb> can't it... oooh. because it needs tokens
[00:44:31] <eddyb> though that's odd
[00:44:54] <eddyb> I guess it doesn't interpolate *sigh
[00:49:52] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: rcirc on GNU Emacs 24.3.50.1)
[00:52:02] *** Joins: pcwalton (pcwalton@moz-DA87EE4.hsd1.ca.comcast.net)
[00:52:02] *** ChanServ sets mode: +ao pcwalton pcwalton
[00:52:16] *** Quits: doener (doener@moz-C68F600D.unity-media.net) (Quit: leaving)
[00:52:27] *** Quits: pcwalton (pcwalton@moz-DA87EE4.hsd1.ca.comcast.net) (Quit: pcwalton)
[00:56:53] <bjz> acrichto: can I use a port to return a result from a Once::do_it call?
[00:57:09] <bjz> acrichto: or is that a nono
[00:57:17] <dbaupp> bjz: you should be able to just assign a variable?
[00:57:27] <acrichto> bjz: the doit closure is executed once and only once
[00:57:28] <dbaupp> let mut x = 1; doit(|| x = 2) ?
[00:57:39] <acrichto> that also works
[01:00:01] <nrc> in resolve, what is a rib?
[01:00:34] <eddyb> resolve in bounds?
[01:00:41] * eddyb has no idea, just made that up
[01:01:10] *** Joins: doomlord__ (servitor@moz-858B6E73.range86-148.btcentralplus.com)
[01:01:16] <nrc> heh
[01:01:17] <bjz> nrc: it is a boney part protecting the type system
[01:01:30] <bjz> rust is all about safety
[01:03:05] <eddyb> bjz: took me too long to get that
[01:03:42] <ChrisMorgan> Ah, good fun. Ribs, homing missiles‚Äîwe need a welder somewhere in Arc.
[01:07:40] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[01:08:24] <acrichto> nrc: pcwalton would know
[01:08:37] <acrichto> nrc: but I think it's baiscally an introduction of new names in a scope
[01:08:47] <acrichto> nrc: they're pushed/popped as you go in/out of scopes (I think)
[01:10:52] <nrc> thanks
[01:11:34] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[01:11:34] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 142f43a4b to 146d27b01: 02http://git.io/N3iJvQ
[01:11:34] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[01:11:36] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[01:11:36] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/pfOdwA
[01:11:36] <ghrust> 13rust/06auto 14454882d 15Alex Crichton: Remove std::condition...
[01:11:36] <ghrust> 13rust/06auto 1487fe3cc 15bors: auto merge of #12039 : alexcrichton/rust/no-conditions, r=brson...
[01:11:36] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[01:12:04] <Eridius> anyone want to review utf-8 parsing? https://github.com/mozilla/rust/pull/12062
[01:12:57] *** Joins: sokomo (sokomo@8293D4FC.93FF164A.408809BB.IP)
[01:17:35] <strcat> acrichto: debug-info failed ;(
[01:17:44] <strcat> I always cancel it after run-pass...
[01:17:49] * strcat sighs
[01:20:23] <eddyb> InternedString::new("attempt to compare values of type type")),
[01:20:29] <eddyb> what is this smoking?
[01:20:42] <acrichto> everything
[01:21:12] <eddyb> it's talking about ty_type, i.e. TyDesc - strcat: I hope you will remove that evil thing
[01:21:46] <eddyb> but why is it interning an error string???
[01:21:54] *** bstrie is now known as bstrie_test
[01:23:04] <eddyb> it calls fail_?
[01:23:09] <sfackler> eddyb: InternedString replaced @str iirc
[01:23:45] <dbaupp> and it was done mechanically
[01:23:56] <eddyb> I guess that makes slightly more sense
[01:23:57] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[01:24:12] *** bstrie_test is now known as bstrie
[01:24:40] *** Joins: lpy (lpy@B3BE13AC.47A0616D.E99F7FDB.IP)
[01:25:00] <eddyb> why is it causing a runtime failure?
[01:26:47] *** Quits: lpy (lpy@B3BE13AC.47A0616D.E99F7FDB.IP) (Ping timeout)
[01:26:54] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[01:27:02] <eddyb>  // Used only for creating scalar comparison glue.
[01:27:10] <eddyb> can we stop inhaling so much glue?
[01:30:30] <eddyb> why can we fail at runtime with "scrutinizing value that can't exist"?
[01:30:49] *** Quits: xales (xales@moz-2499F5A4.naveria.com) (Ping timeout)
[01:31:01] <eddyb> the code looks ancient so maybe it's the old dynamic match failure
[01:32:41] <Eridius> oh how I wish NO_REBUILD=1 worked for more make targets (such as check-stage2-doc-std)
[01:35:16] <eddyb> rusti: match () {}
[01:35:20] -rusti- pastebinned 8 lines of output: http://ix.io/aaw
[01:35:48] <eddyb> oh come on
[01:35:53] <eddyb> rusti: match () {}; 4
[01:35:57] -rusti- pastebinned 8 lines of output: http://ix.io/aaw
[01:36:03] <cgaebel> nice url
[01:36:22] <eddyb> rustilite: fn main() {match () {}}
[01:36:22] -rustilite- <anon>:1:12: 1:23 error: non-exhaustive patterns: type () is non-empty
[01:36:23] -rustilite- <anon>:1 fn main() {match () {}}
[01:36:23] -rustilite-                     ^~~~~~~~~~~
[01:36:23] -rustilite- error: aborting due to previous error
[01:36:23] -rustilite- application terminated with error code 101
[01:37:01] <dbaupp> rusti: enum Foo {}  fn foo(x: Foo) { match x {} } foo(unsafe {std::cast::transmute(())})
[01:37:02] -rusti- task '<main>' failed at 'scrutinizing value that can't exist', <anon>:10
[01:37:03] -rusti- application terminated with error code 101
[01:37:14] <eddyb> dbaupp: whaa
[01:37:23] * eddyb *blinks*
[01:37:25] <Eridius> nice error
[01:37:34] <dbaupp> surely that... should just emit an empty match?
[01:37:48] <eddyb> dbaupp: no, it should error like for ()
[01:37:55] <dbaupp> Why?
[01:38:00] <Eridius> eddyb: why? () has one value. Foo has zero
[01:38:04] <dbaupp> there's no variants so no possible arms
[01:38:06] <eddyb> _
[01:38:20] <Eridius> does Bottom even exist for an enum with no variants?
[01:38:22] <dbaupp> (maybe the failure could only be present in debugging builds.)
[01:38:39] <eddyb> I think I'll make this a trans-time failure, not a runtime one
[01:38:47] <eddyb> though it's a tiny bit out of scope
[01:38:58] <dbaupp> that seems weird
[01:39:10] <dbaupp> why not just handle it uniformly?
[01:39:36] <dbaupp> (if you do change it, make sure it's in a separate commit)
[01:39:44] <Eridius> dbaupp: it seems correct to me that std::cast::transmute::<(),Foo>(()) should fail, though it should fail at compile-time because there's no value it can possibly transmute to
[01:40:07] <eddyb> so we have zero-sized and... non-existent-at-all?
[01:40:20] <Eridius> the size of () is irrelevant
[01:40:44] <eddyb> and ! which has an unreachable poison effect
[01:41:01] <eddyb> I guess *! could be our void* :P
[01:41:15] <dbaupp> Eridius: maybe, but `match`ing on an enum with no variants should be ok
[01:41:15] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[01:41:18] <dbaupp> imo
[01:41:27] <eddyb> dbaupp: it should be a noop then
[01:41:30] <Eridius> eddyb: I would be leery about allowing a cast from *! to *T
[01:41:37] <Eridius> eddyb: using an uninhabited type seems correct to me
[01:41:38] <dbaupp> eddyb: yes
[01:41:44] <dbaupp> and _ => would be invalid
[01:41:51] <dbaupp> since it can never match anything
[01:41:57] <Eridius> dbaupp: sure, match on Foo should compile, as long as there are zero arms
[01:42:46] <eddyb> rusti: enum Foo {} fn foo(x: Foo) { match x {_ => {}} } 5
[01:42:50] -rusti- pastebinned 7 lines of output: http://ix.io/amS
[01:43:14] <eddyb> rusti: enum Foo {} fn foo(x: !) { match x {_ => {}} } 5
[01:43:15] -rusti- <anon>:10:31: 10:32 error: expected type, found token NOT
[01:43:15] -rusti- <anon>:10         enum Foo {} fn foo(x: !) { match x {_ => {}} } 5
[01:43:15] -rusti-                                         ^
[01:43:15] -rusti- application terminated with error code 101
[01:43:48] <eddyb> why allow a match when it can't do anything?
[01:43:55] <dbaupp> uniformity
[01:43:58] <dbaupp> why disallow it?
[01:44:01] <eddyb> riiight
[01:44:39] <ChrisMorgan> And don't forget size_of () or an empty enum‚Äîboth yield the http://ix.io/a6T ICE (at least it's not a runtime failure)
[01:45:16] <eddyb> ChrisMorgan: that's the silly block ICE
[01:45:22] <eddyb> how come nobody fixed it?
[01:45:40] <eddyb> the assert might as well be wrong
[01:46:42] <bjz> why are all the feilds in semver::Version private?
[01:48:03] * bjz wants to use it in glfw
[01:50:58] *** Quits: brson (brson@moz-DFAA4E15.p2p.sfo1.mozilla.com) (Quit: leaving)
[01:52:55] *** Joins: pcwalton (pcwalton@moz-DA87EE4.hsd1.ca.comcast.net)
[01:52:55] *** ChanServ sets mode: +ao pcwalton pcwalton
[01:53:30] <ChrisMorgan> bjz: it doesn't make sense to me either. It's like it was *meant* to be opaque!
[01:54:18] <dbaupp> bjz: possibly by accident
[01:54:45] <bjz> do you recon I can un-private them?
[01:55:25] <dbaupp> not sure, do you have a delete key? :P
[01:56:00] <dbaupp> rusti: enum Foo {} (std::mem::size_of::<Foo>(), std::mem::size_of::<()>())
[01:56:02] -rusti- (0u, 0u)
[01:56:09] * bjz searches
[01:56:12] <dbaupp> ChrisMorgan: that ICE is if you have a trailing ;
[01:56:25] <bjz> dbaupp: is it the one that says `delete`?
[01:57:01] <dbaupp> bjz: not sure; google might know.
[01:57:07] <dbaupp> if not, file a bug
[01:57:10] <bjz> hmm, ok
[01:57:38] *** Joins: xales (xales@moz-2499F5A4.naveria.com)
[02:02:24] * ChrisMorgan sighs and repents in sackcloth and ashes
[02:05:47] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Connection reset by peer)
[02:08:04] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[02:11:43] *** Quits: eddyb (eddy@moz-92B95652.residential.rdsnet.ro) (Ping timeout)
[02:25:25] *** Joins: lpy (lpy@B3BE13AC.47A0616D.E99F7FDB.IP)
[02:26:32] <cgaebel> oh wow I just passed a make check. compiler dev is scary. I still barely believe it works.
[02:26:34] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[02:26:34] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/pfOdwA
[02:26:34] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[02:27:32] *** Quits: lpy (lpy@B3BE13AC.47A0616D.E99F7FDB.IP) (Ping timeout)
[02:27:58] <cgaebel> strcat: would you like to do a review of my new hashmap? https://github.com/mozilla/rust/pull/12081
[02:28:16] <cgaebel> I'm not really sure who to ask, but you've been the most helpful to me!
[02:29:53] <dbaupp> cgaebel: \o/
[02:30:16] <cgaebel> I hope it makes a noticeable dent in isrustfastyet
[02:31:34] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[02:31:34] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/amjs-w
[02:31:34] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[02:32:42] *** Quits: canhtak (canhtak@moz-8DFB5E6A.wl.t.ulaval.ca) (Quit: canhtak)
[02:33:37] <cgaebel> heeey removal of std::condition landed!
[02:36:36] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[02:36:36] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/mT4Hug
[02:36:36] <ghrust> 13rust/06auto 1478de81b 15Michael Darakananda: Removed num::Orderable
[02:36:36] <ghrust> 13rust/06auto 14d533303 15bors: auto merge of #12061 : pongad/rust/delorderable, r=cmr...
[02:36:36] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[02:38:08] *** Quits: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz‚Ä¶)
[02:39:37] <bjz> cmr: why the r+ on that? ^
[02:39:56] <bjz> He should have done it in the same PR
[02:40:08] <bjz> D:
[02:40:17] <acrichto> bjz: want me to cancel it?
[02:40:31] <bjz> I dunno, I think it needs more dicussion
[02:40:37] <bjz> is all
[02:40:49] <acrichto> I'll cancel it
[02:41:32] <bjz> it would have also been helpful if he'd at least linked his issue to the PR
[02:43:21] *** Quits: sunfish (chatzilla@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[02:46:30] <cmr> bjz: https://github.com/mozilla/rust/issues/12068
[02:46:36] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[02:46:37] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14d533303 to 1487fe3cc: 02http://git.io/N3iJvQ
[02:46:37] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[02:46:39] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[02:46:39] <ghrust> 01[13rust01] 15bors pushed 6 new commits to 06auto: 02http://git.io/aZ8bVA
[02:46:39] <ghrust> 13rust/06auto 1479ff710 15mr.Shu: Fixed error messages in librustc/back/link.rs
[02:46:39] <ghrust> 13rust/06auto 14fb70a8a 15mr.Shu: Error messages cleaned in librustc/middle
[02:46:41] <ghrust> 13rust/06auto 14975d1ee 15mr.Shu: Error messages cleaned in libsyntax
[02:46:42] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[02:47:09] <bjz> ah, *facepalm*
[02:47:17] <bjz> new github issue formatting
[02:47:25] <bjz> didn't notice the linked issue
[02:47:50] <bjz> hiding here: https://github.com/mozilla/rust/pull/12061#ref-issue-27071739
[02:48:03] <cmr> yup
[02:48:14] <bjz> sorry for the freak out -_-#
[02:49:18] <bjz> good to see you were discussing it
[02:49:22] <cmr> bjz: I gave it an r+ because they weren't using fmin/fmax anyway...
[02:49:28] <bjz> yeah
[02:49:58] <bjz> that was probably my stupidity
[02:55:23] <dbaupp> cgaebel: looks cool (i've done a quick scroll through, no review of the core insertion/searching/deletion parts of it yet)
[02:56:46] <cgaebel> dbaupp: thanks for the comments
[02:56:49] <cgaebel> fixing a bunch of them now
[02:56:55] <dbaupp> thanks for the hashmap <3
[02:57:00] <cgaebel> haha np. was fun.
[02:57:09] <cgaebel> surprisingly difficult to get perfect, though.
[02:57:09] *** Quits: aatch (James@moz-B437F499.pocketrent.com) (Client exited)
[02:57:20] <cgaebel> i.e. proper bootstrap with no bugs
[02:57:41] <cgaebel> even the tiniest bugs blow everything up
[02:58:09] <dbaupp> haha, yup
[03:01:48] <ChrisMorgan> Consistent indentation of "=>" in pattern matching, values in object literals, and other such not-at-the-start-of-the-line things. Seems to me that the style has traditionally been not to indent but that we've got a few people around who are preferring to indent things. Should we enforce one style or the other? Thoughts?
[03:02:24] <dbaupp> indent for alignment, you mean?
[03:02:30] <ChrisMorgan> Yes.
[03:02:36] <ChrisMorgan> s/indentation/alignment/
[03:05:51] <bjz> cmr: I r=cmred it
[03:08:57] *** Joins: dbaupp_ (Mibbit@moz-9702BA47.maths.usyd.edu.au)
[03:12:06] *** Quits: dbaupp (Mibbit@moz-9702BA47.maths.usyd.edu.au) (Quit: http://www.mibbit.com ajax IRC Client)
[03:13:18] <ChrisMorgan> cgaebel: "FIXME: I don't know why I need to transmute the mutable value, but I do! There's likely a bug here." - what's the error without the transmute? Lifetime mismatch?
[03:14:02] <cgaebel> ChrisMorgan: I'll check. One second.
[03:15:43] <ChrisMorgan> (I can't see what's wrong.)
[03:16:34] <ChrisMorgan> BTW, if you ever do need to do unsafe things, minimise the scope of unsafety, e.g. `let v: &'a mut V = unsafe { transmute(get_vec_mut_ref(self.vals, i)) };`
[03:16:37] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[03:16:37] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14cf764b3 to 1487fe3cc: 02http://git.io/N3iJvQ
[03:16:37] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[03:16:39] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[03:16:39] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/4s_UPg
[03:16:39] <ghrust> 13rust/06auto 1480920da 15Alex Crichton: Don't include rpath lines in dependency lists...
[03:16:39] <ghrust> 13rust/06auto 14a27934c 15bors: auto merge of #12076 : alexcrichton/rust/rpath-makefile-dep, r=thestinger...
[03:16:40] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[03:16:59] <strcat> acrichto: hm, should we cancel that? or did you update it
[03:17:42] <cgaebel> ChrisMorgan: Okay. I'll keep that in mind next time
[03:17:47] <acrichto> strcat: I updated it
[03:17:53] <strcat> ah
[03:18:08] *** Quits: zz_kimundi (kimundi@moz-388F7F53.dip0.t-ipconnect.de) (Ping timeout)
[03:18:28] <acrichto> man macros are awesome
[03:18:58] * ChrisMorgan agrees
[03:20:51] *** Joins: Jesse (jruderman@moz-9754CB0.hsd1.ca.comcast.net)
[03:22:37] *** Joins: zz_kimundi (kimundi@moz-D22EACF1.dip0.t-ipconnect.de)
[03:22:38] *** zz_kimundi is now known as kimundi
[03:24:32] <ChrisMorgan> Is it OK for std tests to depend on extra?
[03:24:44] <dbaupp_> ChrisMorgan: it's compulsory?
[03:24:55] <dbaupp_> benchmarks need extra::test::BenchHarness, at least
[03:24:59] * ChrisMorgan blinks and recalls
[03:24:59] <acrichto> ChrisMorgan: I got some really weird behavior last time I did that
[03:25:08] <acrichto> oh hm, maybe I was just doin git wrong
[03:26:10] *** Joins: lpy (lpy@B3BE13AC.47A0616D.E99F7FDB.IP)
[03:26:27] <cgaebel> wtf:
[03:26:46] <cgaebel>  /home/clark/development/rust/rust/src/libstd/hashmap.rs:1292:18: 1292:36 error: failed to find an implementation of trait to_bytes::IterBytes for K
[03:26:48] <cgaebel> /home/clark/development/rust/rust/src/libstd/hashmap.rs:1292         for _ in self.move_iter() {}
[03:26:49] <cgaebel>                                                                               ^~~~~~~~~~~~~~~~~~
[03:27:17] <cgaebel> can I not do for _ in self.move_iter()?
[03:27:41] <dbaupp_> ah does move_iter() require IterBytes for K?
[03:28:05] <strcat> cgaebel: add an IterBytes bound to the destructor
[03:28:14] *** Quits: lpy (lpy@B3BE13AC.47A0616D.E99F7FDB.IP) (Ping timeout)
[03:28:17] <strcat> or whatever that is
[03:28:27] <dbaupp_> or, move all the functions that don't actually use IterBytes into a separate impl<K, V> HashMap<K, V>
[03:28:44] <strcat> technically move_iter doesn't require IterBytes but having multiple implementations is overly complex
[03:28:51] <strcat> since it is always required to insert a key
[03:29:09] <cgaebel> whoa it is?
[03:29:14] <cgaebel> I thought it just needed Hash?
[03:29:24] *** Joins: lpy (lpy@B3BE13AC.47A0616D.E99F7FDB.IP)
[03:29:31] <cgaebel> why would the destructor need IterBytes?
[03:31:53] <dbaupp_> because it thinks .move_iter needs iterbytes
[03:32:39] *** Quits: jsonnull (Thunderbir@26F61E6.CFD9471D.494A0F8B.IP) (Ping timeout)
[03:32:57] <cgaebel> why?
[03:34:57] <dbaupp_> because it's in an `impl<K: IterBytes, V> HashMap<K,V> { ... }`
[03:36:01] *** Joins: jsonnull (Thunderbir@26F61E6.CFD9471D.494A0F8B.IP)
[03:38:10] <cgaebel> impl<K: Hash + Eq, V> HashMap<K, V> {
[03:39:36] <dbaupp_> oh, yeah
[03:39:49] <dbaupp_> the IterBytes is inherited through Hahs
[03:39:52] <dbaupp_> *Hash
[03:43:32] * pcwalton likes the idiom ".move_iter().collect()" for converting an old vector to a Vec
[03:48:06] *** Joins: tjc (tjc@F92596F.2DEF7520.EF7679FA.IP)
[03:48:06] *** ChanServ sets mode: +o tjc
[03:54:15] <cgaebel> ChrisMorgan: finally got that error message for you: error: lifetime of `self` is too short to guarantee its contents can be safely reborrowed
[03:54:29] <cgaebel> for my transmute(get_vec_mut_ref(self.vals, i))
[03:54:47] * ChrisMorgan hasn't come across that one before
[03:55:05] <dbaupp_> that's weird
[03:55:22] <cgaebel> yup.
[03:56:51] <ChrisMorgan> cgaebel: oh, good, my initial guess (which I made a mess of the proof of concept of) was right: you do just need to specify &'a mut self rather than &mut self.
[03:57:20] <cgaebel> oh neat. okay I'll try that out.
[03:57:29] <dbaupp_> ChrisMorgan: in an Iterator .next impl?
[03:57:35] <ChrisMorgan> Yes.
[03:57:41] <dbaupp_> won't work
[03:57:52] <ChrisMorgan> dbaupp_: huh?
[03:58:00] <dbaupp_> can't put new constraints on a trait method
[03:58:11] <cgaebel> aaah yup.
[03:58:13] <ChrisMorgan> Ohhhh. Yeah.
[03:58:14] <cgaebel> dbaupp_'s got it.
[03:58:20] *** Parts: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) ()
[03:58:24] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[03:58:26] <cgaebel> but at least I have a real reason now.
[03:58:35] <dbaupp_> not really :P
[03:58:36] <cgaebel> instead of "idk what's happening, but it works"
[03:58:40] <ChrisMorgan> So write it in and it'll be clear.
[03:58:44] <dbaupp_> as in... it's weird that it doesn't work
[03:58:56] <dbaupp_> why isn't using self.vals valid?
[03:59:05] <dbaupp_> *without the transmute
[03:59:32] <cgaebel> already borrowing self with self.keys?
[03:59:36] <ChrisMorgan> dbaupp_: the problem is that self's lifetime is only the method body, not the caller
[03:59:46] <cgaebel> oh
[03:59:49] <ChrisMorgan> The error is completely in order, Rust is right.
[04:00:17] <dbaupp_> so... ? self.vals is a reference
[04:00:27] <ChrisMorgan> As it is, it's basically fn next<'b>(&'b mut self) -> ...<'a> { ... }
[04:00:29] <dbaupp_> so the lifetime of something out of it should be attached to the vals reference
[04:00:32] <dbaupp_> not self
[04:01:37] *** Quits: zimbabao (rajaram@D3E167BB.C0113EA2.D2D1FAF0.IP) (Ping timeout)
[04:02:25] <ChrisMorgan> dbaupp_: the lifetime of the vals reference must not be greater than that of self.
[04:02:44] <dbaupp_> other way around
[04:03:35] <dbaupp_> it's MutEntries<'a, T> { vals: &'a mut Vec<T> }
[04:03:43] <dbaupp_> i.e. vals is external to self
[04:03:48] <ChrisMorgan> OK, I take that back and head from a different angle. In the definition, the lifetimes are the same. For a self<'a>, self.vals is 'a.
[04:04:06] <ChrisMorgan> Thus, given &'b mut self, the return value would only be 'b, right?
[04:04:31] <dbaupp_> self.vals is not 'a
[04:04:41] <dbaupp_> wait
[04:04:58] <dbaupp_> I think I misinterpreted what you meant by self<'a>
[04:05:33] <dbaupp_> why is the return value 'b? the return value is completely divorced from the lifetime of the &mut self reference passed to `next`
[04:05:47] <ChrisMorgan> Why?
[04:06:11] <dbaupp_> trait Iterator<A> { fn next(&mut self) -> Option<A>; }
[04:06:21] <dbaupp_> A isn't linked to the self at all
[04:06:34] <dbaupp_> and *cannot* ever be linked
[04:06:43] <dbaupp_> since there's no lifetimes on the trait definition
[04:07:06] <dbaupp_> in any case, I thought of something that may resolve this: https://github.com/mozilla/rust/pull/12081#discussion_r9529493
[04:10:01] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[04:14:33] <cgaebel> lolwut: error: unresolved name `forget`. Did you mean `hashes`?
[04:14:41] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[04:14:42] *** ChanServ sets mode: +ao dherman dherman
[04:20:31] *** Quits: tjc (tjc@F92596F.2DEF7520.EF7679FA.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz‚Ä¶)
[04:21:21] <Yurume> cgaebel: `hashes` contains `e` in the same position as `forget`, so it is indeed the closest (though useless) alternative. :p
[04:21:34] <Yurume> (since it has an edit distance of 5)
[04:22:19] *** Joins: tjc (tjc@F92596F.2DEF7520.EF7679FA.IP)
[04:22:19] *** ChanServ sets mode: +o tjc
[04:24:14] *** Joins: cryptorust (Mibbit@moz-316F6936.cpe.cableone.net)
[04:24:16] <Eridius> Yurume: we need to lower the allowed edit distance on suggestions
[04:24:23] <cmr> *lower*?
[04:24:31] <cmr> It just needs some smarter heuristics
[04:24:33] <Eridius> that too
[04:24:48] <Eridius> and it needs to consider more names. Doesn't it basically only consider local variables?
[04:24:55] <dbaupp_> yes
[04:24:56] <cmr> yeah
[04:25:04] <strcat> Eridius: yeah it needs to consider more
[04:25:11] *** Quits: vadimcn (chatzilla@FB06B64.76F9E272.DA40C4B3.IP) (Ping timeout)
[04:25:25] <strcat> it could penalize things that aren't local variables but it shouldn't just resort to finding the least bad local
[04:25:40] *** Joins: vadimcn (chatzilla@FB06B64.76F9E272.DA40C4B3.IP)
[04:26:10] <Eridius> who wants to review my PR? I want to start using from_utf8_lossy in my own code https://github.com/mozilla/rust/pull/12062
[04:26:31] <Yurume> cmr: it is not quite easy. for example, if `handle_request` does not exist but `handle_req` exists then the edit distance almost does not matter (it involves some kind of grouping edits); same for `process_request`.
[04:26:32] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[04:26:32] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/4s_UPg
[04:26:32] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[04:26:34] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[04:27:03] <Eridius> Yurume: perhaps some sort of adjusted distance that considers deleting any number of adjacent letters to be a single edit?
[04:27:11] <strcat> acrichto: your patch managed to land before the aurora nightly build on that server finished... so I didn't need to add that patch to the PKGBUILD >.<
[04:27:16] <strcat> silly cron load average queues
[04:27:26] <Yurume> Eridius: then it would consider an edit distance between `forget` and `hashes` as 2, which is not good.
[04:27:35] <strcat> it's more fun for everything to just contend for the same cores!
[04:27:55] <Yurume> so it is a matter of... balancing act. :S
[04:28:02] *** Joins: sunfish (chatzilla@moz-8DE7F965.dsl.dynamic.sonic.net)
[04:28:04] <pcwalton> my spreadsheet predicts that the final de-~[T] patch will be 30,697 lines
[04:28:09] <Eridius> Yurume: eh, I was thinking just deletions, not character replacements. But my proposal doesn't help with matching `handle_request` when you type `handle_req`
[04:28:12] <Eridius> so meh
[04:28:28] <Yurume> Eridius: so does process_request/handle_request :)
[04:28:36] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[04:28:57] <strcat> pcwalton: do you know if it has any speed benefit yet?
[04:29:02] <pcwalton> nope
[04:29:12] <pcwalton> I'm not even running trans in stage0
[04:29:20] <pcwalton> it's pass lint, abort, on to more
[04:29:20] <strcat> I know it's faster it's a microbenchmark, but I wonder if we depend on Vec perf much
[04:29:28] <Eridius> Yurume: maybe add some weighting by the length of the longest common substring, or somesuch?
[04:29:31] * strcat somewhat doubts we do
[04:29:31] <pcwalton> it didn't help that much in servo
[04:29:40] <pcwalton> when I switched to SmallVec0 in various places
[04:29:42] <pcwalton> which is vec:ng
[04:29:43] <pcwalton> vec_ng
[04:29:51] <pcwalton> still it makes the asm better
[04:30:20] <Yurume> Eridius: not sure. do we have a training set?
[04:30:35] <Yurume> (as like spell correction...)
[04:31:37] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[04:31:37] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/GQTOJA
[04:31:37] <ghrust> 13rust/06auto 1471b7da3 15HeroesGrave: moved collections from libextra into libcollections
[04:31:37] <ghrust> 13rust/06auto 14d9c1912 15bors: auto merge of #12010 : HeroesGrave/rust/libcollection, r=alexcrichton...
[04:31:37] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[04:31:46] <Eridius> Yurume: not that I know of
[04:31:50] <pcwalton> in general algorithmic improvements beat any micro-optimizations for Rust code these days
[04:32:05] <pcwalton> rarely does inlining and switching vector representations offer more than 10% or so
[04:32:10] <strcat> improving the hash table and hash performance should help
[04:32:11] <pcwalton> IME anyway
[04:32:18] <strcat> at least in rustc
[04:32:20] <strcat> maybe not servo
[04:32:53] <strcat> librustc is mostly slow because it does too much work though
[04:33:00] <pcwalton> too much work?
[04:33:12] <pcwalton> like generating too much code?
[04:33:34] <strcat> pcwalton: as in stuff like sizing_type_of queries LLVM too much
[04:33:37] <strcat> I think there are a lot of potential improvements
[04:33:44] <pcwalton> isn't that cached?
[04:33:46] *** Quits: lpy (lpy@B3BE13AC.47A0616D.E99F7FDB.IP) (Ping timeout)
[04:33:56] <strcat> pcwalton: yes
[04:34:04] * pcwalton doesn't expect big improvements then
[04:35:40] <pcwalton> putting everything associated with a node_id into a big Sema structure like clang does instead of hitting hash tables all the time is the biggest improvement I can think of
[04:36:01] *** Quits: Kxepal (Miranda@moz-1E141C63.pppoe.mtu-net.ru) (Connection reset by peer)
[04:36:20] *** Joins: Kxepal (Miranda@moz-1E141C63.pppoe.mtu-net.ru)
[04:36:28] * strcat is curious why it calls malloc so much
[04:36:52] <strcat> meh, I guess the AST stuff
[04:38:03] <Eridius> why is ptr::offset (and RawPtr.offset) unsafe? It produces a new pointer
[04:38:27] <dbaupp_> undefined behaviour to index outside the object it comes from
[04:38:31] <Eridius> ah
[04:38:37] <dbaupp_> (except for one byte past the end)
[04:38:49] *** Joins: lpy (lpy@57DDED08.1B5A1487.7CEBAF5A.IP)
[04:39:02] <Eridius> yeah, I forgot about that. Still seems odd to me that merely producing a new pointer value can be considered undefined, even if you never do anything with it, but w/e
[04:39:16] <Eridius> I suppose that lets the compiler assume that any pointers derived from a valid pointer are also valid, in case that helps
[04:39:31] <dbaupp_> I think that's exactly it
[04:40:02] <strcat> Eridius: LLVM has a getelementptr instruction, and using inbounds on it is optional
[04:40:04] <dbaupp_> e.g. the  iterator from .iter() on ~[] is faster than one from .iter() on &[] because ~[] does an offset
[04:40:14] <strcat> Eridius: without inbounds, it can go out-of-bounds and has two's complement wrapping
[04:40:22] <Eridius> dbaupp_: really? how curious
[04:40:35] <strcat> Eridius: but it's kind of pointless as there are still the same aliasing rules and so on for dereferencing
[04:40:37] <Eridius> strcat: I feel like I should learn about this LLVM stuff
[04:40:48] <strcat> Eridius: C always outputs inbounds pointer arithmetic
[04:40:53] <strcat> and it does communicate a lot to LLVM
[04:40:55] <dbaupp_> Eridius: https://github.com/mozilla/rust/issues/11751
[04:41:03] <strcat> it's possible that non-inbounds GEP could be less bad
[04:41:12] <strcat> but as clang never outputs one, it is not optimized well
[04:41:57] <Eridius> dbaupp_: I wish I knew how to read that LLVM code
[04:42:52] <strcat> Eridius: it's simpler than you thin
[04:42:54] <strcat> think*
[04:43:20] <strcat> %foo is just an immutable (single-assignment) register, and you can have any number of them
[04:43:28] <Eridius> %s.sroa.0.0.idx
[04:43:35] <dbaupp_> just a weird name
[04:43:51] <strcat> Eridius: sroa (scalar replacement of aggregates) splits up aggregates and gives them names like that
[04:43:56] <strcat> won't see that pre-optimization
[04:44:06] <Eridius> ah
[04:44:10] <strcat> it's just to try to give you an idea where it came from
[04:44:37] <Eridius> so I assume `getelementptr inbounds { i64*, i64 }* %1, i64 0, i32 0 means that { i64*, i64 }* is the type of %1, i64 is the type of 0, etc
[04:44:37] <strcat> Eridius: x * 2 + y
[04:44:40] <strcat> would basically become
[04:44:49] <strcat> %1 = %x * 2
[04:44:56] <strcat> %2 = %1 + y
[04:45:20] <strcat> Eridius: getelementptr is pointer arithmetic
[04:45:30] <strcat> Eridius: the list of numbers after is a list of offsets
[04:45:44] <strcat> Eridius: it doesn't dereference, just does the offsetr
[04:45:51] <strcat> so for example if you have
[04:45:52] <strcat> *Foo
[04:46:01] <strcat> where Foo is say... struct Foo { x: int, y: int }
[04:46:10] <strcat> getelementptr 0 0 will get to the field `x`
[04:46:17] <strcat> getelementptr 0 1 will get to the field `y`
[04:46:29] <Eridius> huh
[04:46:29] <strcat> and they'll turn *Foo into *i64 (or whatever)
[04:46:50] <dbaupp_> and gep 1 0 would get to the field x of the next Foo in a Foo* array
[04:47:00] <Eridius> I see
[04:47:05] <Eridius> so where do you actually learn this stuff?
[04:47:16] <strcat> Eridius: http://llvm.org/docs/LangRef.html
[04:47:26] <Eridius> ah
[04:47:29] <dbaupp_> read the output of rustc and consult the langref
[04:47:37] <strcat> Eridius: you probably have a good grasp of the concepts already... just need to become familiar with having a bunch of single assignment registers
[04:47:50] <Eridius> strcat: I already read up the other day on SSA
[04:47:56] <Eridius> well, wikipedia's idea of it at least ;)
[04:48:03] <strcat> a mutable variable becomes an alloca, which basically represents some memory on the stack and gives you a pointer
[04:48:29] <strcat> to get the contained value you use load (*x) and store to write (*x = 5)
[04:49:04] <strcat> load/store are just the general way to read/set memory
[04:49:07] <Eridius> right
[04:49:57] <strcat> LLVM IR wouldn't be that hard to write by hand
[04:50:15] <strcat> it's a real pain to edit because it uses numbered registers in general instead of names
[04:50:26] <strcat> and it won't let you skip a number ;s
[04:50:57] <strcat> but by hand you could name them all...
[04:51:06] <strcat> except params
[04:52:01] <Eridius> heh
[04:52:04] <dbaupp_> Eridius: there's http://llvm.lyngvig.org/Articles/Mapping-High-Level-Constructs-to-LLVM-IR too
[04:52:46] <dbaupp_> which suggests you can name params (e.g. main in http://llvm.lyngvig.org/Articles/Mapping-High-Level-Constructs-to-LLVM-IR#14 )
[04:53:28] <strcat> ah I forgot you could name them
[04:53:43] <strcat> rust should really do that more
[04:53:56] <Eridius> dbaupp_: thanks
[04:54:01] <pcwalton> keep in mind chris lattner told us not to except in debug mode
[04:54:05] <pcwalton> because of compile time concerns
[04:54:12] <strcat> pcwalton: ah, we do name a lot though
[04:54:16] <pcwalton> yes
[04:54:20] <pcwalton> we shouldn't so much
[04:54:35] <dbaupp_> file a bug?
[04:54:36] <strcat> could have -Z name-registers
[04:58:40] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[05:00:32] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Ping timeout)
[05:00:55] *** Joins: zimbabao (rajaram@47769425.AE842F9B.81C3DAA1.IP)
[05:02:22] *** Quits: tjc (tjc@F92596F.2DEF7520.EF7679FA.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz‚Ä¶)
[05:05:53] *** Quits: lpy (lpy@57DDED08.1B5A1487.7CEBAF5A.IP) (Ping timeout)
[05:07:19] *** Joins: lpy (lpy@57DDED08.1B5A1487.7CEBAF5A.IP)
[05:11:39] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[05:11:39] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14d9c1912 to 14a27934c: 02http://git.io/N3iJvQ
[05:11:39] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[05:11:40] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[05:11:40] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/MLy8NQ
[05:11:40] <ghrust> 13rust/06auto 144352a8d 15Cole Mickens: Fix a dead URL
[05:11:40] <ghrust> 13rust/06auto 14396ef93 15bors: auto merge of #12077 : colemickens/rust/patch-1, r=alexcrichton
[05:11:40] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[05:12:06] *** Joins: aurynj (Eon@583ABBE5.60FA2E28.B9E25744.IP)
[05:12:43] <strcat> whew, the nightly finally built
[05:12:55] <cmr> what the heck was wrong with it
[05:13:02] <strcat> upstream bug
[05:13:06] <strcat> makefile issue
[05:13:13] <strcat> anyway x86_64 is still building
[05:13:27] <strcat> cmr: https://github.com/mozilla/rust/pull/12076
[05:13:35] <cmr> ah
[05:14:02] <strcat> takes a while since it has to build all of llvm ;p
[05:14:19] <strcat> and someone is busy rebuilding part of kde
[05:15:26] *** Quits: lpy (lpy@57DDED08.1B5A1487.7CEBAF5A.IP) (Ping timeout)
[05:19:36] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[05:19:46] <strcat> cmr: stage2 ;p
[05:20:04] <cgaebel> where can I watch the buildbot?
[05:20:11] <cgaebel> nvm read the topic
[05:20:40] * strcat meant the nightly build
[05:20:46] <strcat> the arch pkg
[05:20:55] <cgaebel> oh
[05:22:25] <Eridius> how strange, if foo is a ~[u8], then foo.push_all(v) is significantly slower than vec::bytes::push_bytes(foo, v)
[05:22:34] <Eridius> I would have expected the former to be optimized into the latter
[05:23:14] *** Joins: lpy (lpy@9B3042FA.F60EBA9.E99F7FDB.IP)
[05:23:21] <Yurume> ah, I didn't know Eridius is kballard on Github. :p
[05:23:37] <Eridius> hi
[05:23:39] <Yurume> hi
[05:23:44] <Yurume> I'm lifthrasiir on Github :)
[05:23:47] <Eridius> ah
[05:24:16] * Yurume is infamous for having multiple (10+) active nicks
[05:24:55] <cmr> I'm... cmr
[05:25:02] *** Quits: cryptorust (Mibbit@moz-316F6936.cpe.cableone.net) (Quit: http://www.mibbit.com ajax IRC Client)
[05:25:06] <cmr> (so original!)
[05:26:00] <Yurume> cmr: how did you get that name in Github? it's so short that it should've been registered for long time
[05:26:19] <cmr> Yurume: there was a person with 0 activity who had it
[05:26:24] <cmr> I emailed github and they gave it to me :)
[05:26:28] <Yurume> oh
[05:26:39] <Yurume> that wouldn't happen in Twitter though :)
[05:26:42] <cmr> nope
[05:26:46] <Diamond> Awesome? Awesome.
[05:26:50] <cmr> I'm @cmrx64
[05:26:52] <Yurume> (I personally know a person with two-letter nick in Twitter...)
[05:26:58] <cmr> nice!
[05:27:15] * dbaupp_ wonders if he should get GH to give him "huon"
[05:27:16] <Eridius> I know people who work at Twitter
[05:27:20] <Eridius> it's possible to reclaim names, just hard
[05:27:28] <dbaupp_> ... is it worth the name change?
[05:27:38] *** Quits: lpy (lpy@9B3042FA.F60EBA9.E99F7FDB.IP) (Ping timeout)
[05:27:56] <cmr> dbaupp_: or you could use dbaupp? :P
[05:28:11] <Eridius> dbaupp_: how strange, I changed from_utf8_lossy to create a ~[u8] instead of ~str and use vec::bytes::push_bytes(), and that slightly sped up the first two benchmarks (of valid chars) but the benchmark of invalid chars slowed down
[05:28:27] <Eridius> I didn't actually expect anything to change, because the previous str-manipulation methods all operated by calling as_owned_vec() first
[05:28:48] *** Joins: lpy (lpy@9B3042FA.F60EBA9.E99F7FDB.IP)
[05:30:20] <dbaupp_> cmr: using my real name would be weird :P
[05:30:37] <cmr> .b 16
[05:30:39] <cmr> ugh
[05:30:58] <pcwalton> ugh, the quasiquoter
[05:31:02] <pcwalton> making the transition very hard
[05:31:07] <pcwalton> I have to remove a bunch of uses of it
[05:31:26] <dbaupp_> yup, it's horrible to make AST changes with the quoting the way it is.
[05:32:10] * Yurume wonders if rust-encoding's UTF-8 decoder is faster or slower than new from_utf8_lossy
[05:32:37] <Eridius> Yurume: good question. You should test ;)
[05:32:48] <sfackler> strcat: \o/
[05:32:49] *** Joins: zv (zv@moz-955F83E9.hsd1.ca.comcast.net)
[05:33:05] <Yurume> personally I haven't tested rust-encoding for benchs, but I tried to avoid a costly code whenever possible
[05:33:59] <strcat> cmr: well, now the super long namcap/xz/xdelta3 part...
[05:34:15] <strcat> xdelta3 is such a waste of time ;s
[05:37:29] <cmr> yeah
[05:37:38] <cmr> are the deltas still larger than the actual packages?
[05:39:10] <strcat> cmr: well when they are they get discarded
[05:39:12] <strcat> they usually are
[05:39:47] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[05:39:58] <Eridius> dbaupp_: this is extremely bizarre. The simple change of making `res` into a ~[u8] instead of ~str, and using vec::bytes::push_bytes() directly instead of str::raw::push_bytes(), speeds up the valid string cases a bit but drastically slows down the strings that require replacements
[05:40:21] <dbaupp_> Eridius: sounds very weird
[05:40:24] <Eridius> e.g. vec::from_elem(100, 0xF5), which should turn into 100 copies of U+FFFD, takes 315ns in the version as-submitted but 588 in the modified version
[05:40:41] <Eridius> yeah str::raw::push_bytes() is literally as_owned_vec(s).push_bytes(v)
[05:41:38] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[05:41:38] *** ChanServ sets mode: +ao dherman dherman
[05:47:21] *** Joins: canhtak (canhtak@moz-8DFB5E6A.wl.t.ulaval.ca)
[06:09:01] <Eridius> dbaupp_: gah! I just tried rewriting it to count the necessary space first (and use .to_owned() if there are no invalid bytes), and then use unchecked pushing when doing replacements, and it's slower across the board!
[06:10:46] <Eridius> I think I'm just going to push the minor changes (e.g. `while`) and otherwise leave the algorithm alone
[06:12:30] *** Joins: NiccosSystem (NiccosSyst@AB1AFDE.FC7B0C35.A7597CB6.IP)
[06:13:57] <Eridius> dbaupp_: pushed: https://github.com/mozilla/rust/pull/12062
[06:21:38] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[06:21:38] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/MLy8NQ
[06:21:38] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[06:22:05] <bjz> r? https://github.com/mozilla/rust/pull/12083
[06:22:15] <bjz> regarding those semver feilds
[06:25:59] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Client exited)
[06:26:20] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[06:26:32] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[06:26:32] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/MlCTfg
[06:26:32] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[06:26:53] <Eridius> bjz: I just made one comment about Show. I don't know anything about semver though so I can't really evaluate the rest of your changes
[06:27:03] <bjz> Eridius: cheers
[06:27:05] * Eridius idles
[06:28:12] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Ping timeout)
[06:28:42] <bjz> Eridius: is the other Show ok?
[06:29:07] <ChrisMorgan> bjz: it's interesting seeing the pattern you've used of `write!(...).and_then(|()| { ... })`; I would have written `if_ok!(write!(...)); ...`.
[06:29:31] <bjz> oh, didn't know that macro
[06:29:41] <bjz> any documentation for it?
[06:29:51] <bjz> or just look at syntax::expand?
[06:29:59] <strcat> ugh
[06:30:02] <strcat> getting a weird error
[06:30:09] <strcat> x86_64-unknown-linux-gnu/stage2/bin/compiletest: symbol lookup error: x86_64-unknown-linux-gnu/stage2/bin/compiletest: undefined symbol: _ZN2rt9local_ptr8compiled10RT_TLS_PTR19hdc9a58880b8e9059ap9v0.10.preE
[06:30:11] <strcat> ;s
[06:30:29] <ChrisMorgan> bjz: if_ok!(x) is `match x { Ok(y) => y, Err(z) => return z }`
[06:30:37] <ChrisMorgan> s/return z/return Err(z)/
[06:30:50] <ChrisMorgan> unwrap-or-return
[06:31:11] <bjz> why do you need a macro for that?
[06:31:14] * ChrisMorgan wonders whether the two approaches end up with identical performance or not
[06:31:29] <ChrisMorgan> bjz: functions can't trigger a return from the caller
[06:31:38] <bjz> ah
[06:31:39] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[06:31:39] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/MlCTfg
[06:31:39] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[06:31:43] <bjz> oh I see!
[06:32:53] <sfackler> bjz: macros are in libstd/macros.rs now
[06:34:06] <ChrisMorgan> Luqman: ‚òπ armhf build: "A newer kernel is required to run this binary. (__kernel_cmpxchg64 helper)"
[06:34:51] <bjz> updated: https://github.com/mozilla/rust/pull/12083
[06:35:01] * ChrisMorgan is desolate
[06:35:07] <Luqman> ChrisMorgan: :( i built on 3.2.0-4-amd64
[06:35:21] <bjz> I impled ToStr using format!("{}", *self) as well
[06:35:22] <ChrisMorgan> And I'm operating on a 2.6 kernel which I cannot upgrade.
[06:38:14] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[06:44:10] *** Quits: canhtak (canhtak@moz-8DFB5E6A.wl.t.ulaval.ca) (Quit: canhtak)
[06:44:59] *** Quits: lpy (lpy@9B3042FA.F60EBA9.E99F7FDB.IP) (Ping timeout)
[06:45:27] *** Joins: lpy (lpy@9B3042FA.F60EBA9.E99F7FDB.IP)
[06:49:22] *** Joins: dbaupp (Mibbit@moz-9702BA47.maths.usyd.edu.au)
[06:50:19] <dbaupp> Eridius: I'm just double checking your tests now, btw
[06:53:51] *** Quits: dbaupp_ (Mibbit@moz-9702BA47.maths.usyd.edu.au) (Quit: http://www.mibbit.com ajax IRC Client)
[06:57:10] <bjz> dbaupp: updated: https://github.com/mozilla/rust/pull/12083
[06:57:35] <bjz> specifically: https://github.com/mozilla/rust/pull/12083/files#diff-3e72a093e268c50b5639fd79c8976a36R98
[06:57:58] <bjz> yeah I was a little lazy when it came to that part :P
[06:58:20] <bjz> (ugh, imperative loopiness)
[06:59:59] <dbaupp> bjz: commented
[07:00:32] <Yurume> dbaupp: on https://github.com/mozilla/rust/pull/12062#issuecomment-34408564 --- I was thinking of a PR with replacing SendStr with OptOwnedStr (SendStr becomes a type defn) and adding OptOwnedVec, but couldn't find much justification for the change. would that justify this change?
[07:03:07] <dbaupp> Ah, SendStr would be OptOwnedStr<'static> ?
[07:03:22] <Yurume> right
[07:03:41] <bjz> dbaupp: fixed
[07:03:42] <Yurume> not sure about the naming
[07:06:34] <dbaupp> Yurume: generalising SendStr like that would be an r+ from me
[07:06:44] *** Quits: lpy (lpy@9B3042FA.F60EBA9.E99F7FDB.IP) (Ping timeout)
[07:07:21] <Yurume> time to checkout the master then :)
[07:07:43] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Ping timeout)
[07:09:52] *** Quits: pcwalton (pcwalton@moz-DA87EE4.hsd1.ca.comcast.net) (Quit: pcwalton)
[07:10:11] *** Joins: lpy (lpy@F678EAE1.B31F127E.E99F7FDB.IP)
[07:14:02] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[07:15:01] <Yurume> dbaupp: a reason not to send a PR was that... SendStr seemed to be underused (last time I've searched it for Github yielded no result except for libstd, I had used my own implementation for OptOwnedStr though) and I cannot see much use of such generalized type.
[07:15:13] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Quit: Leaving...)
[07:15:30] <Yurume> Github search might not be a good indicator ;)
[07:17:17] <dbaupp> git grep says it's used a little
[07:21:09] *** Joins: dbaupp1 (Thunderbir@2702835C.D5A1DCF.37681C44.IP)
[07:26:03] *** Quits: lpy (lpy@F678EAE1.B31F127E.E99F7FDB.IP) (Ping timeout)
[07:27:18] *** Quits: nielsle (nielsle@moz-C46DA772.boa.fiberby.dk) (Ping timeout)
[07:28:42] *** Joins: lpy (lpy@F678EAE1.B31F127E.E99F7FDB.IP)
[07:29:35] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Client exited)
[07:29:56] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[07:31:40] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Ping timeout)
[07:41:34] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[07:41:34] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/NM1bYQ
[07:41:34] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[07:43:17] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[07:46:37] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[07:46:37] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/OzMlsQ
[07:46:37] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[07:49:54] *** Quits: aurynj (Eon@583ABBE5.60FA2E28.B9E25744.IP) (Quit: Leaving)
[07:50:18] <Eridius> dbaupp: thanks for reviewing from_utf8_lossy. I'm going ahead with the "last good character" version.
[07:50:29] <Eridius> MaybeOwned can be explored later, although it won't work for the one spot I'm already using it (in path::Display)
[07:55:04] *** Quits: lpy (lpy@F678EAE1.B31F127E.E99F7FDB.IP) (Ping timeout)
[07:56:02] <dbaupp> yup, as can the iterator solution
[07:58:22] *** Quits: zimbabao (rajaram@47769425.AE842F9B.81C3DAA1.IP) (Ping timeout)
[08:03:07] *** Joins: lpy (lpy@F678EAE1.B31F127E.E99F7FDB.IP)
[08:03:40] *** Quits: jsonnull (Thunderbir@26F61E6.CFD9471D.494A0F8B.IP) (Ping timeout)
[08:05:15] *** Quits: dbaupp (Mibbit@moz-9702BA47.maths.usyd.edu.au) (Quit: http://www.mibbit.com ajax IRC Client)
[08:06:28] *** Quits: ktt3ja (ktt3ja@moz-85E2770C.hsd1.va.comcast.net) (Quit: Leaving)
[08:06:53] *** Quits: dbaupp1 (Thunderbir@2702835C.D5A1DCF.37681C44.IP) (Ping timeout)
[08:07:29] *** Joins: jsonnull (Thunderbir@26F61E6.CFD9471D.494A0F8B.IP)
[08:09:03] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[08:09:21] *** Quits: rustilite (rustilite@moz-54F7FD49.cpe.net.cable.rogers.com) (Connection reset by peer)
[08:09:21] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Connection reset by peer)
[08:09:48] *** Joins: rustilite (rustilite@moz-54F7FD49.cpe.net.cable.rogers.com)
[08:09:54] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[08:12:09] *** flaper87|afk is now known as flaper87
[08:13:25] *** Joins: zimbabao (rajaram@47769425.AE842F9B.81C3DAA1.IP)
[08:15:58] *** Quits: lpy (lpy@F678EAE1.B31F127E.E99F7FDB.IP) (Ping timeout)
[08:16:26] *** Joins: lpy (lpy@F678EAE1.B31F127E.E99F7FDB.IP)
[08:25:20] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[08:35:38] *** Joins: eddyb (eddy@moz-92B95652.residential.rdsnet.ro)
[08:36:41] *** Quits: lpy (lpy@F678EAE1.B31F127E.E99F7FDB.IP) (Ping timeout)
[08:39:42] *** Joins: lpy (lpy@A249AC5C.4439B922.7CEBAF5A.IP)
[08:44:01] <flaper87> cmr: ping
[08:45:02] <cmr> flaper87: pong
[08:45:05] <cmr> what's up?
[08:45:23] <flaper87> cmr: re the s/mod/crate/ PR, I really think we should get it in and then start working on contextualized keywords. The introduction of crate as a keyword has a backwards compatibile impact whereas implementing contextual keywrods could be done later
[08:45:51] <flaper87> cmr: not sure if you read my comment so, I wanted to discuss that w/ you a bit
[08:47:16] <cmr> flaper87: I'm not in favor of landing a new keyword without waiting even a few days to decide if it can be contextual or not.
[08:47:32] <cmr> I don't want to introduce another keyword, especially one which is such a common word as "crate"
[08:47:40] <cmr> it's a very unusual keyword
[08:48:02] <cmr> and it's going to be a pain for any tool that deals with rust code...
[08:48:30] <flaper87> cmr: I couldn't agree more, it was a real pain to replace all crate usages in Rust itself
[08:49:30] <eddyb> the comment on InternedString sounds wrong, the current implementation looks safe
[08:50:05] <flaper87> If contextual keywords are not planned for 1.0 and renaming mod is still something we want, then we should let it land.
[08:50:15] <flaper87> or we could find another keyword not so common
[08:50:29] <cmr> flaper87: the meeting is on tuesday, so it's not like we're waiting forever for feedback.
[08:50:58] <flaper87> cmr: I know, I'm ok with waiting, I just wanted to discuss it with you and get your general thoughts
[08:51:22] <flaper87> I'm even ok with dropping the patch if it is decided not to introduce the keyword
[08:51:24] <cmr> those are my thoughts. I agree that we should let it land, but if we can have contextual keywords *now* it'd minimize the impact.
[08:51:37] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[08:51:37] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/pS4qmw
[08:51:37] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[08:51:39] <cmr> I'm in favor of the syntax change.
[08:52:36] <flaper87> cmr: ok thanks
[08:54:10] *** kimundi is now known as zz_kimundi
[08:54:14] <eddyb> hmpf, StrInterner is probably identical to Interner<RcStr> by now
[08:56:04] <eddyb> and it doesn't need @ anymore
[08:56:32] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[08:56:32] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/_HI2lQ
[08:56:32] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[08:56:33] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[08:56:33] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/EKWsVg
[08:56:33] <ghrust> 13rust/06auto 14b0b89a5 15Kevin Ballard: Add new function str::from_utf8_lossy()...
[08:56:33] <ghrust> 13rust/06auto 14544cb42 15Kevin Ballard: Hoist path::Display on top of from_utf8_lossy()
[08:56:33] <ghrust> 13rust/06auto 1436f1b38 15bors: auto merge of #12062 : kballard/rust/from_utf8_lossy, r=huonw...
[08:56:35] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[08:59:15] <flaper87> Eridius: \o/
[09:02:01] *** Joins: dbaupp (Thunderbir@moz-25BBAF91.lns20.syd6.internode.on.net)
[09:04:47] *** Quits: lpy (lpy@A249AC5C.4439B922.7CEBAF5A.IP) (Ping timeout)
[09:06:06] *** Joins: lpy (lpy@2012DE4D.4439B922.7CEBAF5A.IP)
[09:06:38] *** Joins: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net)
[09:09:35] *** Quits: sokomo (sokomo@8293D4FC.93FF164A.408809BB.IP) (Ping timeout)
[09:10:28] *** Joins: sokomo (sokomo@8293D4FC.93FF164A.408809BB.IP)
[09:18:47] <eddyb> oooh, gensym is cool, it gives you an unique Name using the same RcStr
[09:24:15] <eddyb> I so wish task-local data with libnative uses TLS
[09:24:48] *** Joins: doener (bs@moz-AA189A5A.unitymedia.biz)
[09:25:40] <eddyb> I guess a HashMap wouldn't be bad if it... didn't hash. the key is an unique pointer
[09:26:35] <cmr> A hash map that doesn't hash
[09:26:42] <cmr> Beautiful :P
[09:26:53] <cmr> Also known as an associative array, or just a map...
[09:28:37] <eddyb> cmr: well... it keeps the buckets
[09:28:38] *** Quits: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP) (Ping timeout)
[09:30:04] *** Joins: rca (rcatolino@moz-EF98FF5B.adsl.proxad.net)
[09:30:10] *** Quits: lpy (lpy@2012DE4D.4439B922.7CEBAF5A.IP) (Ping timeout)
[09:31:43] *** Joins: lpy (lpy@2012DE4D.4439B922.7CEBAF5A.IP)
[09:35:40] *** Quits: lpy (lpy@2012DE4D.4439B922.7CEBAF5A.IP) (Ping timeout)
[09:38:07] <dbaupp> we (theoretically) could have the compiler compute a perfect hash of the keys for TLS; right?
[09:38:39] <eddyb> dbaupp: TLS doesn't need keys, it uses offsets
[09:39:04] <eddyb> dbaupp: the HashMap I was referring to is the one in thread-local data
[09:39:11] <dbaupp> eddyb: "key" is a general thing
[09:39:19] <dbaupp> the key into the map
[09:39:33] <dbaupp> doesn't have to be a hashed key or anything
[09:39:48] <dbaupp> (and local data uses a vector atm, doesn't it?)
[09:40:29] <eddyb> it uses a HashMap keyed by unique pointers to zero-sized static keys
[09:40:53] <dbaupp> no, it doesn't
[09:41:01] <dbaupp> pub type Map = ~[Option<(*u8, TLSValue, LoanState)>];
[09:41:06] <eddyb> how can it us. wait, what?
[09:41:20] <eddyb> when was it changed, then?
[09:41:27] *** Joins: lpy (lpy@525CC761.F930CE91.65042015.IP)
[09:41:38] <dbaupp> it's always been that
[09:41:48] <eddyb> are we looking at the same thing?
[09:42:19] <dbaupp> libstd/local_data.rs
[09:42:58] * eddyb found rt::thread_local_storage. cool, no compiler dependencies
[09:43:54] <eddyb> dbaupp: I could've sworn.... maybe someone misled me to think it's a HashMap
[09:44:27] <eddyb>  // Casting 'Arcane Sight' reveals an overwhelming aura of Transmutation magic.
[09:45:26] *** Quits: NiccosSystem (NiccosSyst@AB1AFDE.FC7B0C35.A7597CB6.IP) (Ping timeout)
[09:46:43] <eddyb> dbaupp: it's worse than a HashMap with a noop hash :/
[09:46:56] <dbaupp> eddyb: depends how many elements there are
[09:47:21] <dbaupp> if it's normally, like, 3 or 4, then a straight linear scan will be pretty fast
[09:49:12] *** Joins: nielsle (nielsle@moz-C46DA772.boa.fiberby.dk)
[09:49:13] <eddyb> so many branches X_X
[09:49:16] *** Quits: lpy (lpy@525CC761.F930CE91.65042015.IP) (Ping timeout)
[09:50:23] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[09:51:15] <Yurume> dbaupp: so that the compiler collects TLS offsets across the crates and replaces them with precomputed perfect hashes compatible to the runtime?
[09:51:21] <Yurume> sounds too magic
[09:54:07] <dbaupp> Yurume: yeah... black black magic :P
[09:54:27] <dbaupp> eddyb: you, mean, like 4?
[09:55:00] *** Joins: lpy (lpy@6DD29BEF.89E1F3DB.65042015.IP)
[09:55:13] <eddyb> Yurume: TLS does it, there's no reason why we can't do the same for TLD
[10:06:32] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[10:06:32] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/EKWsVg
[10:06:32] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[10:10:44] *** Joins: lpy_ (lpy@50A083B3.500BCFC5.E99F7FDB.IP)
[10:11:20] *** Quits: lpy (lpy@6DD29BEF.89E1F3DB.65042015.IP) (Ping timeout)
[10:11:33] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[10:11:33] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/934_oA
[10:11:33] <ghrust> 13rust/06auto 1478cb1e2 15Brendan Zabarauskas: Make semver::Version fields public
[10:11:33] <ghrust> 13rust/06auto 14aa829c2 15Brendan Zabarauskas: Implement std::fmt::Show for semver::{Identifier, Version}
[10:11:33] <ghrust> 13rust/06auto 1414cb4be 15bors: auto merge of #12083 : bjz/rust/semver, r=huonw
[10:11:35] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[10:16:03] *** Quits: jsonnull (Thunderbir@26F61E6.CFD9471D.494A0F8B.IP) (Ping timeout)
[10:18:44] *** Quits: lpy_ (lpy@50A083B3.500BCFC5.E99F7FDB.IP) (Ping timeout)
[10:19:24] *** Joins: lpy (lpy@50A083B3.500BCFC5.E99F7FDB.IP)
[10:19:25] *** Joins: jsonnull (Thunderbir@26F61E6.CFD9471D.494A0F8B.IP)
[10:22:22] *** Joins: sigma (sigma@moz-B2E77065.range86-184.btcentralplus.com)
[10:23:58] *** Joins: gimpf (gimpf@moz-5D24646B.adsl.highway.telekom.at)
[10:24:49] *** Joins: NiccosSystem (NiccosSyst@AB1AFDE.FC7B0C35.A7597CB6.IP)
[10:25:55] *** Joins: lpy_ (lpy@E222256A.B31F127E.E99F7FDB.IP)
[10:26:22] *** Quits: lpy (lpy@50A083B3.500BCFC5.E99F7FDB.IP) (Connection reset by peer)
[10:39:25] <eddyb> why do we impl Str for RcStr but not InternedString?
[10:39:59] <eddyb> there's an unsettling difference in their APIs
[10:40:28] <eddyb> oh and I should impl Index for StringInterner :P
[10:42:27] <dbaupp> how often is string interner used directly? rather than via the higher level functions in token?
[10:43:04] <eddyb> dbaupp: the problem is that the higher level functions go through TLD
[10:43:21] <eddyb> and some pieces of code keep an interner, though that might not be required at all
[10:48:24] <mrmonday> how do I get rust to stop linking to libuv? I've tried #[no_uv]; but that doesn't seem to have worked
[10:48:47] <eddyb> mrmonday: you have to use libnative yourself, the default is libgreen
[10:50:12] <dbaupp> eddyb: why is that a problem? are interner accesses showing up on a rustc profile?
[10:50:35] <eddyb> dbaupp: it's actually mainly used in debug!
[10:50:42] <eddyb> okay, it's going down. hard
[10:50:54] <dbaupp> ?
[10:51:26] <eddyb> though it seems like such a waste. I won't refactor it out of the pretty printer, meh
[10:51:46] <dbaupp> r? https://github.com/mozilla/rust/pull/12086
[10:52:07] <mrmonday> actually, different question, is it possible to compile librustuv as a static library rather than a .so? (and then link to the static version rather than the dynamic version)
[10:53:02] <eddyb> we don't do that?
[10:53:08] <mrmonday> I'm trying to replace some libuv functions for the testsuite, and I believe I can only do that if I'm linking against a static library, otherwise I get multiple definition errors (I could be wrong there)
[10:55:05] <mrmonday> doesn't look like it
[10:55:40] <mrmonday> back shortly
[10:57:32] *** lpy_ is now known as lpy
[11:04:03] <dbaupp> heh, checking out a different branch midcompile is a good way to get weird error messages
[11:07:23] <eddyb> dbaupp: if you time it just right, you can do it while it's still loading files and parsing them
[11:08:34] <dbaupp> hahaha
[11:09:20] <eddyb> not sure if you can do it after it opens the file, but modules aren't loaded instantly AFAIK
[11:11:27] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[11:14:07] *** Joins: sanxiyn (tinuviel@B4104EBB.3CC170B1.1E14B209.IP)
[11:16:19] *** zz_kimundi is now known as kimundi
[11:18:24] *** Quits: sanxiyn (tinuviel@B4104EBB.3CC170B1.1E14B209.IP) (Quit: Leaving)
[11:20:47] *** Quits: rca (rcatolino@moz-EF98FF5B.adsl.proxad.net) (Ping timeout)
[11:21:34] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[11:21:34] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/934_oA
[11:21:34] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[11:26:34] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[11:26:34] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/gUgsUA
[11:26:34] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[11:26:35] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[11:26:36] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/ie-cHw
[11:26:36] <ghrust> 13rust/06auto 14104002b 15Seo Sanghyeon: Span debugger
[11:26:36] <ghrust> 13rust/06auto 145109d1a 15Seo Sanghyeon: Correct span for ExprFnBlock, ExprMethodCall, ExprParen
[11:26:36] <ghrust> 13rust/06auto 14e5463b9 15Seo Sanghyeon: Add comments to span debugger
[11:26:37] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[11:32:55] *** kimundi is now known as zz_kimundi
[11:34:05] *** Quits: Jesse (jruderman@moz-9754CB0.hsd1.ca.comcast.net) (Quit: Jesse)
[11:46:21] *** Joins: rca (rcatolino@moz-EF98FF5B.adsl.proxad.net)
[12:08:45] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[12:10:44] *** Quits: zimbabao (rajaram@47769425.AE842F9B.81C3DAA1.IP) (Ping timeout)
[12:12:20] *** Quits: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net) (Input/output error)
[12:12:40] *** Joins: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net)
[12:16:00] *** Joins: andrew-__ (andrew-d_w@4CCE6E0C.339B431B.1E537B93.IP)
[12:17:00] *** Quits: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net) (Ping timeout)
[12:18:02] *** Joins: lpy_ (lpy@DE46E67C.1B5A1487.7CEBAF5A.IP)
[12:18:12] *** Quits: lpy (lpy@E222256A.B31F127E.E99F7FDB.IP) (Ping timeout)
[12:23:30] <dbaupp> "error: only `u8` can be cast as `char`, not `u8`" :'(
[12:25:09] <eddyb> teeeeheee
[12:30:17] <dbaupp> rusti: let v = &[64u8]; let a = *v.get(0).unwrap_or(&0xff); a as char
[12:30:17] -rusti- <anon>:10:62: 10:71 error: only `u8` can be cast as `char`, not `u8`
[12:30:17] -rusti- <anon>:10         let v = &[64u8]; let a = *v.get(0).unwrap_or(&0xff); a as char
[12:30:20] -rusti-                                                                        ^~~~~~~~~
[12:30:23] -rusti- error: aborting due to previous error
[12:30:25] -rusti- application terminated with error code 101
[12:31:32] <eddyb> dbaupp: that's an lvalue, right?
[12:31:45] <eddyb> well, you put into a local...
[12:31:53] <eddyb> rusti: let v = &[64u8]; let a: u8 = *v.get(0).unwrap_or(&0xff); a as char
[12:31:54] -rusti- '@'
[12:31:56] <dbaupp> the problem is inference, I think
[12:31:59] <eddyb> HAH
[12:32:13] <dbaupp> i.e. one part of the compiler knows about the type (the diagnostics)
[12:32:16] <eddyb> rusti: let v = &[64u8]; let a = *v.get(0).unwrap_or(&0xff); let () = a; 1
[12:32:17] -rusti- <anon>:10:66: 10:68 error: mismatched types: expected `u8` but found `()` (expected integral variable but found ())
[12:32:17] -rusti- <anon>:10         let v = &[64u8]; let a = *v.get(0).unwrap_or(&0xff); let () = a; 1
[12:32:17] -rusti-                                                                            ^~
[12:32:17] <dbaupp> but the other part doesn't
[12:32:17] -rusti- error: aborting due to previous error
[12:32:19] -rusti- application terminated with error code 101
[12:32:29] <dbaupp> (the bit checking for valid char casts.)
[12:32:33] <eddyb> dbaupp: so the check runs before inference?
[12:32:37] <dbaupp> after
[12:32:52] <dbaupp> since the type is printed as u8
[12:32:52] <eddyb> if it runs after, the types should be replaced
[12:32:55] <dbaupp> not ty_infer
[12:33:21] <eddyb> the errors can be printed waaay after they were emitted
[12:36:31] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[12:36:31] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/ie-cHw
[12:36:31] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[12:39:55] <dbaupp> the error emitter calls .resolve_type_vars_if_possible, which seems to do some sort of limited inference
[12:40:35] <mrmonday> is output from run-make makefiles suppressed somehow?
[12:40:42] <mrmonday> if so, how can I get around that?
[12:51:17] <eddyb> dbaupp: so it does run too early :P
[12:51:57] <eddyb> dbaupp: ooh and I think I know why. "as" is one of those things that would complain "the type of this value must be known in this context"
[12:52:32] <eddyb> I'm pretty sure we can relax the initial requirements and ensure the rules later
[12:52:56] <eddyb> rusti: let f = |x| (x as u16); f(0u8)
[12:52:57] -rusti- <anon>:10:22: 10:23 error: the type of this value must be known in this context
[12:52:57] -rusti- <anon>:10         let f = |x| (x as u16); f(0u8)
[12:52:57] -rusti-                                ^
[12:52:57] -rusti- error: aborting due to previous error
[12:52:57] -rusti- application terminated with error code 101
[12:53:22] <eddyb> that should be valid IMO
[12:54:04] <eddyb> also, I wish that error were 2 lines instead of 5
[13:06:05] *** Joins: zimbabao (rajaram@D3E167BB.C0113EA2.D2D1FAF0.IP)
[13:08:57] <eddyb> 99 -> 67 cx\.items\b. and I thought I was almost done *sigh*
[13:20:49] *** Quits: andrew-__ (andrew-d_w@4CCE6E0C.339B431B.1E537B93.IP) (Input/output error)
[13:21:11] *** Joins: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net)
[13:42:00] *** Joins: canhtak (canhtak@moz-8DFB5E6A.wl.t.ulaval.ca)
[13:49:27] *** Quits: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net) (Input/output error)
[13:51:33] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[14:13:33] *** Quits: gimpf (gimpf@moz-5D24646B.adsl.highway.telekom.at) (Client exited)
[14:21:21] *** Quits: sokomo (sokomo@8293D4FC.93FF164A.408809BB.IP) (Quit: Read error: Connection reset by peer)
[14:42:08] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[15:07:40] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[15:20:56] *** Quits: canhtak (canhtak@moz-8DFB5E6A.wl.t.ulaval.ca) (Quit: canhtak)
[15:25:02] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[15:37:59] *** Joins: canhtak (canhtak@moz-8DFB5E6A.wl.t.ulaval.ca)
[15:42:43] <dbaupp> flaper87: ping
[15:42:49] <flaper87> dbaupp: pong
[15:43:20] <dbaupp> flaper87: for https://github.com/mozilla/rust/issues/11709 , I'm fairly sure the fix is just "delete the assertion"
[15:43:40] <dbaupp> i.e. the author wrote it with an invalid assumption
[15:45:00] <flaper87> dbaupp: do you have the commit where it was added handy? I can get it otherwise, I'd like to see under which context it was added. But yes, that was also my impression when I started debugging that issue and after reading eddyb comment it made more sense.
[15:46:24] <dbaupp> flaper87: git blame is your friend
[15:46:41] <flaper87> dbaupp: yup, I thought you had it handy :D
[15:46:47] <flaper87> I'm on it
[15:47:03] <dbaupp> in any case, people keep hitting that, so I would implore you to prioritise it over other rust work :)
[15:48:47] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Client exited)
[15:49:08] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[15:50:21] <flaper87> dbaupp: count on it!
[15:50:51] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Ping timeout)
[16:06:50] *** zz_kimundi is now known as kimundi
[16:08:16] *** Quits: doener (bs@moz-AA189A5A.unitymedia.biz) (Quit: leaving)
[16:18:48] *** Joins: hein (hein@DBB44EEF.62843A9.3B82F87E.IP)
[16:19:02] <hein> what happens if there's not enough memory for a ~[] allocation?
[16:29:06] *** Quits: japaric (japaric@FDCA8EB5.4F37C8B4.BFC118EE.IP) (Ping timeout)
[16:33:44] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[16:33:44] *** ChanServ sets mode: +ao dherman dherman
[16:36:06] *** Quits: canhtak (canhtak@moz-8DFB5E6A.wl.t.ulaval.ca) (Quit: canhtak)
[16:47:10] *** Joins: canhtak (canhtak@moz-8DFB5E6A.wl.t.ulaval.ca)
[16:48:06] *** Quits: Kxepal (Miranda@moz-1E141C63.pppoe.mtu-net.ru) (Ping timeout)
[16:48:18] <olsonjeffery> acrichto: im interested in 12082
[16:48:40] <olsonjeffery> how do expect to expose setgid/uid and detached? in ProcessConfig ?
[16:51:16] *** Joins: Kxepal (Miranda@moz-D41D50F.pppoe.mtu-net.ru)
[16:52:21] *** Quits: angdev (uid7041@moz-E77DEB21.irccloud.com) (Ping timeout)
[16:59:20] <eddyb> hein: ~[] allocates two words on the stack
[16:59:48] <eddyb> err, heap
[16:59:52] *** Joins: angdev (uid7041@moz-E77DEB21.irccloud.com)
[17:00:11] <eddyb> the new Vec<T> only uses the heap for elements, an empty one doesn't allocate anything
[17:00:11] <olsonjeffery> acrichto: nm you already did it, heh.
[17:00:50] <olsonjeffery> how're you gonna say "marking E-Mentor" and then turn-around do it yourself? :P
[17:02:39] <hein> eddyb: well, my question was of a more general nature, what happens if there's not enough memory for a vector allocation, such as with_capacity(123)
[17:02:54] <eddyb> hein: the abort intrinsic is called
[17:03:06] <eddyb> hein: that's true for all heap allocations
[17:05:25] <hein> eddyb: mh. low level language.. shouldn't you be able to try to recover from OOM conditions?
[17:07:36] <acrichto> olsonjeffery: yeah sorry about that :(
[17:07:56] *** Quits: eddyb (eddy@moz-92B95652.residential.rdsnet.ro) (Ping timeout)
[17:08:32] *** Joins: eddyb (eddy@moz-92B95652.residential.rdsnet.ro)
[17:08:59] <olsonjeffery> low-hanging fruit
[17:09:36] <eddyb> hein: well, you can't fail because failure requires allocation. you could have a custom allocator that does something smarter, I guess
[17:14:20] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: rcirc on GNU Emacs 24.3.1)
[17:17:41] <hein> eddyb: couldn't this be handled by conditions?
[17:17:49] <eddyb> conditions are gone :P
[17:18:04] <eddyb> unless you mean a custom solution, which is entirely possible
[17:18:49] <hein> conditions are gone :o
[17:23:02] <bstrie> http://www.drdobbs.com/open-source/nimrod-a-new-systems-programming-languag/240165321
[17:23:41] <bstrie> "Procs that return a value have an implicitly declared result variable that represents the return value, so there is no need to write return result. result is Nimrod's way to guarantee what is called return value optimization in C++."
[17:23:58] <bstrie> gets me to wondering, how do we manage to gurantee RVO?
[17:25:17] *** Joins: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com)
[17:25:17] *** ChanServ sets mode: +ao pcwalton pcwalton
[17:31:14] *** lpy_ is now known as lpy
[17:31:48] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[17:33:29] <eddyb> bstrie: anything larger than a word gets "RVO" - a pointer to the stack is passed as the first argument, and the return value is constructed in place
[17:34:50] <bstrie> eddyb: wait, so you're saying that we *still* have a hidden first argument to all functions?
[17:35:11] <bstrie> I thought the env was the only one :P
[17:36:01] <eddyb> no, not all functions, just those with a return type that doesn't fit in a register
[17:36:28] <bstrie> ah yes
[17:37:34] <bstrie> eddyb: I have to ask then, do we have any other hidden arguments floating around? :)
[17:39:23] <eddyb> all closures still have the end argument
[17:40:50] <eddyb> *env
[17:42:05] <hein> I don't think you can have closures without the env argument
[17:42:45] <hein> eddyb: does that mean that passing and returning large datatypes is optimized in rust?
[17:45:49] <eddyb> it's hard to return something larger than a register ;)
[17:46:25] <eddyb> so it's not just for optimization. I guess passing arguments larger than a register by reference (as opposed to placing their entire body on the stack) is an optimization
[17:46:34] *** Quits: lpy (lpy@DE46E67C.1B5A1487.7CEBAF5A.IP) (Client exited)
[17:46:54] <bstrie> hein: it means that your functions can return things "by-value" when in reality that value has already been constructed in the caller's stack frame, so doesn't require a copy to return
[17:46:55] <eddyb> if LLVM knows enough, it will optimize more than what language-level semantics allows for
[17:47:14] <bstrie> (aiui)
[17:47:34] <eddyb> ~Foo::new() can be very well optimized to an in-place construction
[17:48:24] <eddyb> well, to make it clearer: let a = Foo::new(); let b = ~a; can be optimized to an in-place construction of b
[17:48:46] <eddyb> without any rust-specific semantics
[17:49:43] <eddyb> "box" is less about emplace and more about parametrized allocation
[17:51:49] *** Quits: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com) (Quit: pcwalton)
[17:54:10] *** Joins: lkuper (lkuper@moz-D862222C.dhcp-bl.indiana.edu)
[17:54:24] *** Joins: jdm (jdm@2F1C87B2.CB89F2A8.6AA50C35.IP)
[17:55:34] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[17:55:48] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[18:03:44] <sfackler> the lifetimes tutorial still talks about @-boxes pretty extensively
[18:04:02] *** Quits: zimbabao (rajaram@D3E167BB.C0113EA2.D2D1FAF0.IP) (Ping timeout)
[18:04:13] *** Joins: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com)
[18:04:14] *** ChanServ sets mode: +ao pcwalton pcwalton
[18:11:06] *** Joins: lpy (lpy@DE46E67C.1B5A1487.7CEBAF5A.IP)
[18:11:32] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[18:11:32] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/tWi4Ug
[18:11:32] <ghrust> 13rust/06auto 14813886b 15chromatic: Removed prelude::* from libstd files....
[18:11:32] <ghrust> 13rust/06auto 14b91b6a7 15chromatic: Cleaned up imports per coding standards....
[18:11:33] <ghrust> 13rust/06auto 14ca40da8 15bors: auto merge of #12075 : chromatic/rust/gh_11983_deglob_std, r=alexcrichton...
[18:11:35] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[18:11:36] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[18:11:36] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/RDibCA
[18:11:36] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[18:13:04] <hein> 0 commits? that's not much
[18:13:13] <Eridius> sweet
[18:21:40] <nmatsakis>   static constexpr size_t size = sizeof(simd_type) / sizeof(value_type);
[18:30:04] *** lpy is now known as lpy|afk
[18:31:22] *** Quits: NiccosSystem (NiccosSyst@AB1AFDE.FC7B0C35.A7597CB6.IP) (Ping timeout)
[18:31:22] *** Quits: lpy|afk (lpy@DE46E67C.1B5A1487.7CEBAF5A.IP) (Client exited)
[18:31:36] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[18:43:55] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[18:44:18] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[18:46:28] *** Joins: Zr40 (zr40@moz-CCFEAB92.adsl.xs4all.nl)
[18:57:01] *** Quits: sunfish (chatzilla@moz-8DE7F965.dsl.dynamic.sonic.net) (Ping timeout)
[19:01:26] *** Quits: acrichto (acrichto@moz-B63D64BD.res.cmu.edu) (Connection reset by peer)
[19:01:30] *** Joins: acrichto (acrichto@moz-B63D64BD.res.cmu.edu)
[19:01:31] *** ChanServ sets mode: +o acrichto
[19:01:35] *** Quits: SimonSapin (simon@moz-9A1FE870.exyr.org) (Ping timeout)
[19:01:35] *** Quits: rca (rcatolino@moz-EF98FF5B.adsl.proxad.net) (Ping timeout)
[19:01:37] *** Joins: rca (rcatolino@moz-EF98FF5B.adsl.proxad.net)
[19:02:04] *** Joins: SimonSapin (simon@moz-9A1FE870.exyr.org)
[19:02:15] *** Quits: cluelessperson (cluelesspe@moz-617B0E16.tx.res.rr.com) (Ping timeout)
[19:02:15] *** Quits: yuriks (yuriks@14F330CC.3D924459.5419EADB.IP) (Ping timeout)
[19:02:26] *** Joins: cluelessperson (cluelesspe@moz-617B0E16.tx.res.rr.com)
[19:06:20] *** Joins: yuriks (yuriks@14F330CC.3D924459.5419EADB.IP)
[19:19:52] *** Joins: lpy|afk (lpy@DE46E67C.1B5A1487.7CEBAF5A.IP)
[19:19:56] *** Quits: lkuper (lkuper@moz-D862222C.dhcp-bl.indiana.edu) (Ping timeout)
[19:21:38] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[19:21:38] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/tWi4Ug
[19:21:38] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[19:21:58] *** Quits: lpy|afk (lpy@DE46E67C.1B5A1487.7CEBAF5A.IP) (Ping timeout)
[19:26:30] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[19:26:30] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/GriCZQ
[19:26:30] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[19:26:34] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[19:26:34] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/wrOcTA
[19:26:34] <ghrust> 13rust/06auto 14730bdb6 15Derek Guenther: Added tests to make tidy
[19:26:34] <ghrust> 13rust/06auto 1456565eb 15bors: auto merge of #12055 : dguenther/rust/tidy_test, r=alexcrichton...
[19:26:35] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[19:29:49] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[19:37:32] *** Joins: lkuper (lkuper@95CE63D8.D3FA0837.51B6877.IP)
[19:42:37] *** Quits: jdm (jdm@2F1C87B2.CB89F2A8.6AA50C35.IP) (Ping timeout)
[19:42:55] *** Joins: jdm (jdm@2F1C87B2.CB89F2A8.6AA50C35.IP)
[19:45:04] *** Quits: lkuper (lkuper@95CE63D8.D3FA0837.51B6877.IP) (Ping timeout)
[19:51:47] *** Joins: lkuper (lkuper@95CE63D8.D3FA0837.51B6877.IP)
[19:53:05] *** Quits: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com) (Quit: pcwalton)
[19:53:37] *** Quits: lkuper (lkuper@95CE63D8.D3FA0837.51B6877.IP) (Ping timeout)
[19:53:37] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[19:54:47] *** Joins: lkuper (lkuper@95CE63D8.D3FA0837.51B6877.IP)
[20:00:02] *** Joins: NiccosSystem (NiccosSyst@AB1AFDE.FC7B0C35.A7597CB6.IP)
[20:01:12] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[20:02:15] *** Quits: lkuper (lkuper@95CE63D8.D3FA0837.51B6877.IP) (Ping timeout)
[20:02:53] *** Quits: jdm (jdm@2F1C87B2.CB89F2A8.6AA50C35.IP) (Ping timeout)
[20:02:59] *** Joins: jdm (jdm@2F1C87B2.CB89F2A8.6AA50C35.IP)
[20:04:29] *** Joins: lkuper (lkuper@moz-D862222C.dhcp-bl.indiana.edu)
[20:08:01] *** Joins: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net)
[20:08:01] *** ChanServ sets mode: +o tjc
[20:11:13] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[20:12:49] *** Joins: glaebhoerl (glaebhoerl@moz-B5B88D72.catv.broadband.hu)
[20:16:30] *** Quits: eddyb (eddy@moz-92B95652.residential.rdsnet.ro) (Ping timeout)
[20:20:35] *** Joins: lpy|afk (lpy@DE46E67C.1B5A1487.7CEBAF5A.IP)
[20:22:42] *** Quits: lpy|afk (lpy@DE46E67C.1B5A1487.7CEBAF5A.IP) (Ping timeout)
[20:25:01] *** Joins: Jesse (jruderman@moz-9754CB0.hsd1.ca.comcast.net)
[20:26:47] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[20:34:15] *** Joins: eddyb (eddy@moz-92B95652.residential.rdsnet.ro)
[20:36:37] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[20:36:38] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/wrOcTA
[20:36:38] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[20:41:37] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[20:41:37] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/Lw011g
[20:41:37] <ghrust> 13rust/06auto 141508b6e 15Alex Crichton: Add some doc examples to lib{green,native}...
[20:41:37] <ghrust> 13rust/06auto 147d7a060 15bors: auto merge of #12073 : alexcrichton/rust/doc-examples, r=cmr...
[20:41:38] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[20:44:00] *** Quits: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz‚Ä¶)
[20:46:39] *** Joins: rca_ (rcatolino@moz-B966CD48.adsl.proxad.net)
[20:47:25] *** Quits: rca (rcatolino@moz-EF98FF5B.adsl.proxad.net) (Ping timeout)
[20:48:18] *** Joins: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP)
[20:50:56] *** Quits: hein (hein@DBB44EEF.62843A9.3B82F87E.IP) (Ping timeout)
[20:55:18] *** Joins: hein (hein@moz-31DF7C86.wlan.hu-berlin.de)
[21:03:36] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Client exited)
[21:03:44] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[21:03:44] *** ChanServ sets mode: +ao dherman dherman
[21:04:03] *** Quits: eddyb (eddy@moz-92B95652.residential.rdsnet.ro) (Ping timeout)
[21:06:05] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[21:09:32] <flaper87> nmatsakis: shouldn't the conditional loop be marked as terminating as well? https://github.com/nikomatsakis/rust/blob/issue-6801-borrowck-closures/src/librustc/middle/region.rs#L531
[21:10:31] <nmatsakis> flaper87: the condition of the loop, is that what you mean?
[21:11:05] <flaper87> nmatsakis: yeah
[21:11:29] <flaper87> I guess the same rules that apply for `while` should apply for `ExprForLoop`
[21:11:41] <flaper87> which is not in that match
[21:11:43] <nmatsakis> flaper87: you don't have to wait about for loop, since it's expanded into a loop
[21:11:52] <nmatsakis> essentially it's a macro
[21:12:01] <nmatsakis> flaper87: but you could add an assertion that you never see it
[21:12:17] <nmatsakis> (I think, I forget if it remains in the tree in some form)
[21:12:56] <flaper87> oh, mmh, understood. That explains why it is not there
[21:15:01] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[21:15:30] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[21:17:16] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[21:17:52] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[21:17:52] *** ChanServ sets mode: +qo brson brson
[21:18:16] *** Joins: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com)
[21:18:16] *** ChanServ sets mode: +ao pcwalton pcwalton
[21:19:13] *** Joins: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net)
[21:19:13] *** ChanServ sets mode: +o tjc
[21:21:20] *** Joins: lpy|afk (lpy@DE46E67C.1B5A1487.7CEBAF5A.IP)
[21:23:28] *** Quits: lpy|afk (lpy@DE46E67C.1B5A1487.7CEBAF5A.IP) (Ping timeout)
[21:24:42] *** Joins: eddyb (eddy@moz-92B95652.residential.rdsnet.ro)
[21:25:50] <kimundi> Do you think it would make sense for Option to implement container traits, for being usable as a one-element container?
[21:26:55] <bstrie> kimundi: what do you want to do with it?
[21:27:03] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[21:27:08] <bstrie> like, what container traits are there
[21:28:23] <kimundi> bstrie: Well, its motivated by this comment: https://github.com/huonw/rust/commit/4b8e38a4ab79c17bfa8c88b5469ae0648f307fe7#src-libextra-json-rs-P70
[21:28:59] <kimundi> That function basically is option.contains(&c)
[21:29:37] *** Joins: sunfish (chatzilla@moz-BBE3ABD.mv.mozilla.com)
[21:29:37] <bstrie> ....wha?
[21:29:54] <bstrie> why is that not just `if self.ch.unwrap() == '\n'` or something
[21:30:16] <bstrie> if self_ch is an option, why is that even an if and not a match
[21:30:18] <kimundi> bstrie: well, unwrap would fail is its none
[21:30:31] <bstrie> then use a match
[21:31:09] <kimundi> why? that would be more verbose? besides I'm not the author of this code :P
[21:31:23] <bstrie> no, because you wouldn't need a helper function
[21:31:28] *** Joins: ecr (chatzilla@moz-B30F97C9.dhcp4.washington.edu)
[21:31:38] <bstrie> it looks like self.ch used to just be a char, now it's an Option<char>
[21:31:45] <bstrie> so it makes sense to convert that from an if to a match
[21:32:34] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[21:32:55] <bstrie> even having a helper function there seems weird since you could just do `if self.ch == Some('\n')`
[21:32:58] <kimundi> It just got me thinking that that helper function is basically "contains" if Option is viewed as a one-elemnt container, and I also remember from prior recherches that Option ty√ºpes in other languages generally implement container interfaces.
[21:33:05] <bstrie> if you really wanted to avoid a match
[21:33:08] <bstrie> which you shouldn't
[21:33:15] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[21:33:28] <bstrie> I think this is an anti-pattern
[21:33:42] <bstrie> I'm not against implementing container traits on option, but this isn't a compelling argument
[21:34:07] <kimundi> Well, I never meant for it to be one :P
[21:34:32] <bstrie> if we wanted options to be usable in generic functions that take T: Container, then that would be a better reason
[21:34:40] <bstrie> but I don't know if we have any functions like that
[21:34:46] <eddyb> Container is pretty bad
[21:34:55] <eddyb> Iterable, on the other hand...
[21:35:41] <glaebhoerl> if we had things like Haskell's Functor/Foldable/Traversable, those would be great examples
[21:36:05] <eddyb> pretty sure we can do Iterable without HKT
[21:36:14] * kimundi just wants to know whether he should actually put up his PR :P
[21:37:01] <eddyb> what I'm not sure about is whether we need nmatsakis' upcoming fixes for lifetimes in generic bounds and whatnot, to make it work
[21:37:55] *** Quits: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com) (Ping timeout)
[21:45:10] <flaper87> I'm not sure about implementing Container for Option either. I proposed `is` in that PR because I clearly didn't come up with something better
[21:45:39] *** Joins: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com)
[21:45:39] *** ChanServ sets mode: +ao pcwalton pcwalton
[21:45:42] <flaper87> and I'm not happy with that helper method
[21:46:32] <flaper87> but this sounds like something that could be useful when you just want to know if Option's value `is` something.
[21:46:35] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[21:46:35] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/Lw011g
[21:46:35] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[21:46:42] <flaper87> `is` made some sense because we already have `is_some`
[21:47:10] <flaper87> kimundi: ^
[21:49:28] <kimundi> Well, for what it's worth, if one where to implement the container traits for Option, it would look like this: https://github.com/Kimundi/rust/compare/option_container?expand=1 :P
[21:50:07] <flaper87> kimundi: LOL
[21:51:17] <kimundi> Now whether that's actually useful to have in libstd is what I'm trying to find out before making a PR with it ;)
[21:51:31] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[21:51:31] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/CglLaQ
[21:51:31] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[21:51:34] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[21:51:34] <ghrust> 01[13rust01] 15bors pushed 7 new commits to 06auto: 02http://git.io/DGnVbQ
[21:51:34] <ghrust> 13rust/06auto 1479ff710 15mr.Shu: Fixed error messages in librustc/back/link.rs
[21:51:34] <ghrust> 13rust/06auto 14fb70a8a 15mr.Shu: Error messages cleaned in librustc/middle
[21:51:34] <ghrust> 13rust/06auto 14975d1ee 15mr.Shu: Error messages cleaned in libsyntax
[21:51:36] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[21:54:36] *** Quits: Zr40 (zr40@moz-CCFEAB92.adsl.xs4all.nl) (Quit: leaving)
[22:02:54] *** Quits: rca_ (rcatolino@moz-B966CD48.adsl.proxad.net) (Ping timeout)
[22:04:10] <dbaupp> nmatsakis: r? https://github.com/mozilla/rust/pull/12095
[22:04:28] <dbaupp> (blame implies you wrote that code originally)
[22:05:18] <bstrie> kimundi: I'm not a huge fan of it. I think it's useful to know when something is an Option, specifically, rather than looking at a piece of code and just seeing a generic container
[22:05:39] <eddyb> bstrie: but std::algorithm!
[22:05:48] * eddyb ducks and runs
[22:05:59] <bstrie> eddyb: what is happening
[22:06:04] <bstrie> explain this in-joke immediately
[22:06:04] <kimundi> bstrie: Well, sure. But its not like this would make an Option not an option :P
[22:06:19] <bstrie> kimundi: I'd rather people treat option like the option that it is, is what I'm saying
[22:07:20] <bstrie> if you have a specific use case in mind, and it actually makes code nicer and clearer, that's one thing
[22:07:28] <dbaupp> bstrie: but being *able* to treat it as a no-alloc 0-or-1 container is nice, sometimes
[22:07:44] <bstrie> this seems more like "some people might find this useful someday"
[22:07:48] <kimundi> yeah I get that - no adding code just because :P
[22:08:04] <eddyb> dbaupp: TinyVec?
[22:08:05] <bstrie> dbaupp: when do you need a 0 or 1 container?
[22:08:33] <eddyb> SmallVec is basically Option<T> | Vec<T>
[22:09:14] <eddyb> bstrie: std::algorithm, if I didn't get it wrong, is a C++ STL namespace. or at least there's the <algorithm> header
[22:09:44] <dbaupp> bstrie: a unary tree
[22:09:45] <eddyb> it has frequently used algorithms, written as generic as possible, with templates
[22:09:52] * dbaupp can't think of an instance right now
[22:09:54] <eddyb> dbaupp: hahaha
[22:10:03] * eddyb looks it up
[22:10:05] <bstrie> haha
[22:10:18] <dbaupp> bstrie: well, yeah, it's useful in generic code
[22:11:25] <eddyb> because of the lack of value iterators, I find myself doing Some(value).move_iter() these days
[22:11:28] * kimundi suddenly has the desire to write a FromIterator impl for Option as well, to complete the circle of unnecessarity
[22:11:29] <bstrie> I'll accept that answer if someone will actually come up with some generic code that wants to use options like this
[22:12:22] <eddyb> bstrie: iterators cover most uses, which makes it harder to come up with good examples
[22:12:25] <dbaupp> eddyb: why to do we even have .move_iter()?
[22:12:39] <kimundi> eddyb: Urg, yeah I have to use that trick regulary too.
[22:12:40] <eddyb> s/to//?
[22:12:41] <dbaupp> shouldn't it just be Option<A>.iter() -> Iterator<A>
[22:12:51] <eddyb> dbaupp: no, .iter() yields a reference
[22:12:54] <dbaupp> with .as_ref().iter() for reference
[22:13:03] <dbaupp> like the entirety of the rest of the module
[22:13:05] <eddyb> might as well change that IMO
[22:13:23] <eddyb> if it were me, I'd almost impl Iterator<T> for Option<T>
[22:13:40] *** Quits: jsonnull (Thunderbir@26F61E6.CFD9471D.494A0F8B.IP) (Connection reset by peer)
[22:13:57] <kimundi> dbaupp: When I did the last big refactoring of Option, I basically left the iter constructors alone because I was unsure about future plans with an Iterable trait.
[22:13:57] <eddyb> you don't need anything more than the Option itself :)
[22:14:00] <dbaupp> sounds good to me
[22:14:14] <dbaupp> we can have .iter() be a noop
[22:14:24] <dbaupp> option.iter().iter().iter()
[22:14:26] <eddyb> for Iterable, sure
[22:14:35] <dbaupp> if you want to be damn sure you're iterating
[22:14:54] <eddyb> cmr: ^^ are you writing these down?
[22:15:33] <cmr> no
[22:15:34] <kimundi> eddyb, dbaupp I write the patch for that if you provide the justification as comments under the PR :P
[22:15:34] <eddyb> .as_ref() makes a new Option, and immutability-by-default should guard against accidents
[22:16:38] *** Quits: NiccosSystem (NiccosSyst@AB1AFDE.FC7B0C35.A7597CB6.IP) (Ping timeout)
[22:16:58] *** Quits: hein (hein@moz-31DF7C86.wlan.hu-berlin.de) (Ping timeout)
[22:16:59] <eddyb> kimundi: composing iterators sometimes requires a... I forgot the monadic term :/. the simplest iterator, one element
[22:17:41] <kimundi> eddyb: I know. Do you mean the Option iterator "Item"?
[22:17:54] <dbaupp> eddyb: you mean Haskell's `return`?
[22:18:02] <eddyb> dbaupp: I guess...
[22:18:46] <bstrie> Go entirely reimplemented libc and statically links it into every program, right?
[22:18:59] <dbaupp> yes
[22:19:19] <bstrie> would it be a bad idea for us to statically link libc ourselves? :P
[22:19:33] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[22:19:34] <dbaupp> it's hard work
[22:19:35] <acrichto> it wouldn't really gain us a whole lot
[22:19:41] * bstrie is looking at the question on reddit about binary portability
[22:19:46] <eddyb> only if it's highly portable
[22:19:47] <dbaupp> e.g. I don't think glibc can be statically linked (right?)
[22:19:51] <acrichto> that wouldn't really get us binary portability though
[22:19:53] <eddyb> it can be
[22:19:56] <acrichto> you'd still need the entire toolchain locally
[22:20:19] <eddyb> I say it's not worth it without LTO
[22:20:39] <bstrie> acrichto: basically I'm just curious what exactly go does to be as portable as their binaries are. I'm not saying I want that for rust, just inquisitive
[22:20:52] <eddyb> kimundi: move_iter is required for vectors because of their weight. most of the Option API, like dbaupp mentioned, is value-based, .as_ref() is too easy to do and you don't actually need to create an iterator to iterate in the first place
[22:21:07] <eddyb> kimundi: .iter() -> .as_ref(); .move_iter() ->
[22:21:16] <kimundi> eddyb: Yes,  know
[22:21:25] <acrichto> bstrie: yeah go reimplemented everything, they only do static linking, and they have their own linker for go programs, and you can't cross compile when using cgo as well
[22:21:33] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[22:21:33] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/7efhAA
[22:21:33] <ghrust> 13rust/06auto 14cebe5e8 15Zach Kamsler: Reduced allocations in merge_sort for short vectors...
[22:21:33] <ghrust> 13rust/06auto 141fd2d77 15bors: auto merge of #12029 : zkamsler/rust/merge-sort-allocations, r=huonw...
[22:21:33] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[22:21:37] <bstrie> acrichto: ok
[22:21:37] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[22:21:37] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14b80b9db to 147d7a060: 02http://git.io/N3iJvQ
[22:21:37] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[22:21:43] <acrichto> bstrie: so the major blockers for us would be the linker + native FFI interface
[22:22:02] <acrichto> FFI isn't so bad, but we would have to make the entire stdlib not use native code at all
[22:22:04] <eddyb> kimundi: thought you wanted some kind of.... ohhhh. you wanted us to publicly voice our support for such a change. silly me
[22:22:04] *** Joins: lpy|afk (lpy@DE46E67C.1B5A1487.7CEBAF5A.IP)
[22:22:12] <kimundi> eddyb: Yeah :)
[22:22:14] <eddyb> kimundi: I was going to say "don't expect anything original from me at this hour"
[22:22:23] <kimundi> haha
[22:22:24] <acrichto> bstrie: but yeah it'd be awesome if I could say "RUST_OS=linux rustc foo.rs" and it "just works"
[22:22:29] <acrichto> that's one thing I love about Go
[22:22:43] <eddyb> RUST_OS=rustic
[22:23:06] <kimundi> eddyb: So, removed iter and mut_iter, changed move_iter to iter, and made the option iterator a type alias for an Option. lets see what breaks down :)
[22:23:17] *** Joins: doener (doener@moz-C68F600D.unity-media.net)
[22:24:08] *** Quits: lpy|afk (lpy@DE46E67C.1B5A1487.7CEBAF5A.IP) (Ping timeout)
[22:24:20] <eddyb> kimundi: if you have time, grep for .move_iter() and replace some of the eyesores
[22:24:42] <kimundi> well, have to do that anyway
[22:24:47] <eddyb> riiight
[22:25:06] <eddyb> kimundi: #[deprecated] on the iter method might get you some results
[22:25:55] <kimundi> eddyb: As in, catch uneccessary iter calls?
[22:26:05] <eddyb> and those that expect references
[22:28:47] <dbaupp> you could also just delete the them and see the errors :P
[22:28:51] <kimundi> hum, in theory I could get rid of iter() completly this way
[22:29:06] <kimundi> dbaupp: That's what I did
[22:29:33] <eddyb> we can always add it later for Iterable
[22:29:37] <kimundi> yeah
[22:29:47] <eddyb> <3 API cleanup
[22:30:27] <eddyb> kimundi: thank you for doing this :). I'm abusing Option in my ast_map::Path refactoring, because of its now-iterator-based nature
[22:31:24] <kimundi> eddyb: Well, for some reason I like changing stuff about core types that are used through the whole codebase xD
[22:31:37] <kimundi> lol
[22:32:11] <eddyb> I like changing stuff used throughout the compiler. I just renamed tcx.items to tcx.map
[22:32:19] <kimundi> I removed all iter constructors of Option, changed two lines in std::iter, and libstd compiled
[22:32:35] <eddyb> STL!
[22:33:01] <eddyb> kimundi: at least you don't have to fix doc tests
[22:33:11] <bstrie> ugh, do we allow iteration over options
[22:33:52] <bstrie> is that what this is about
[22:34:10] <eddyb> it's an useful primitive. a for loop is silly since a match does it more justice, but it's awesome with chained iterators
[22:34:25] *** Quits: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net) (Input/output error)
[22:34:28] <kimundi> bstrie: Well, you did not like treading an Option as a container, so we shifted to treading Option as an iterator to spite you :P
[22:34:37] <eddyb> bstrie: and soon, you'll be able to do Some(a).chain(b).chain(Some(c))
[22:34:53] <bstrie> eddyb: I don't know what that means!
[22:34:58] <ecr> whut
[22:35:24] <eddyb> bstrie: an iterator that produces a, all elements from the iterator that b is, and then c
[22:35:30] *** Joins: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net)
[22:35:30] *** ChanServ sets mode: +o tjc
[22:35:49] <bstrie> eddyb: does the iterator give me Some(a) or a
[22:35:59] <eddyb> bstrie: a
[22:36:16] <bstrie> ugh
[22:36:20] <bstrie> I don't like it :P
[22:36:25] <eddyb> why?
[22:36:33] <eddyb> None is empty, Some(x) gives you x
[22:36:34] <bstrie> I can't think of how that's useful
[22:36:37] <kimundi> woah, this is the first time I worked on the libraries since we started to to split them up. This is _much_ faster to iterate on now :D
[22:37:21] *** Quits: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net) (Ping timeout)
[22:38:05] *** Joins: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net)
[22:38:05] *** ChanServ sets mode: +o tjc
[22:38:31] <ecr> eddyb: sounds like you're trying to get around the lack of Applicative and Monad through iterators
[22:38:39] <kimundi> Fun fact: treemap uses iterating over an Option - as in, it literally called options as_mut_iter :P
[22:39:43] <eddyb> ecr: you do realize iterators are so much easier to grasp and use and what the heck is Applicative?
[22:39:50] <bstrie> eddyb: right, what ecr said. take that junk back to haskell!!
[22:40:26] <eddyb> did you swap us, or am reading that wrong?
[22:40:45] <bstrie> I'm just busting chops
[22:40:46] * eddyb is not used to RTL languages
[22:42:11] *** Quits: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net) (Quit: Textual IRC Client: www.textualapp.com)
[22:43:43] <kimundi> Oh hey, libsyntax uses option iterators a lot
[22:45:35] <brson> strcat: last night i was thinking i don't want to make the intrinsics module public at all and would like to encapsulate the intrinsics that are commonly used but aren't surfaced anywhere else. i'm wondering how you think intrinsics should be organized
[22:47:22] <dbaupp> eddyb: Applicative etc. are just fancy names for simple concepts :)
[22:51:23] <ecr> eddyb: Applicative is the Haskell typeclass for Applicative Functors, which are a middle step between Functors and Monads. 
[22:51:25] <ecr> Functor = values in a context (e.g. a container) that you can map a function over
[22:51:26] <ecr> Applicative = like a Functor but the function can be in a context to (e.g. Option<a -> b> applied to Option<a> gives Option<b>)
[22:51:28] <ecr> Monad = like Applicative but the function can produce a wrapped value (a -> Option<b> rather than a -> b). Applicative will let you apply that to a Option<a> but you'll get a Option<Option<b>>. Monad lets you collapse nested contexts so you can take Option<Option<b>> to just Option<b>.
[22:51:47] *** Quits: yuriks (yuriks@14F330CC.3D924459.5419EADB.IP) (Connection reset by peer)
[22:51:52] <ecr> monad's reputation for complexity is overblown by a scary name
[22:52:00] *** Joins: yuriks (yuriks@C93719AB.4576F2C7.8E0C6B01.IP)
[22:52:06] <ecr> programmers use them all the time really
[22:54:18] <eddyb> what I know is that the IO monad threads pure functions to hide impure actions, and the concept feels silly if I think of it in the context of a language like Rust
[22:55:12] <Eridius> benchmarking doesn't seem to be terribly trustworthy. One run: 407ns/iter (+/- 11). Next run: 363 ns/iter (+/- 11)
[22:55:18] <ecr> that's pretty accurate. Rust isn't pure so an IO monad wouldn't be too useful, but monads are for more that just IO
[22:55:44] <dbaupp> Eridius: it may be external factors like CPU turbo-boost, etc?
[22:56:08] <eddyb> dbaupp: we need a short linux command to stabilize CPU frequency :P
[22:56:31] <eddyb> I know you can fiddle with sysfs but it's not simple/portable
[22:56:45] <strcat> brson: I'd like not having an intrinsics module at all and just having them be a fully hidden implementation detail of other stuff
[22:56:54] <strcat> like only exposing offset through std::ptr
[22:57:16] <eddyb> wait a second, did I just invent a better HKT notation for traits?
[22:57:27] <strcat> and that also allows avoiding a whole layer of function generation
[22:57:43] <strcat> like atm you call push and get a copy of offset, size_of and the underlying offset/size_of intrinsics
[22:57:45] <strcat> etc.
[22:57:48] <ecr> Option, Result, containers, parsers, mutable state, read only state, write only logs, nondeterminism, random values, STM, continuations, and memoization can all be considered as monads
[22:58:22] <ecr> eddyb: what notation?
[22:58:39] <eddyb> trait<T> Functor {fn map<U>(self, f: |T| -> U) -> Self<U>;}
[22:59:53] <eddyb> though "self" there feels ambiguous
[23:00:08] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[23:00:17] <ecr> that'd be how I would write Functor if Rust if we had HKTs
[23:00:30] <ecr> wait
[23:00:32] <ecr> hm
[23:00:57] <eddyb> ecr: thing is, it doesn't need an explicit bound on Self, so we can keep our different-than-haskell trait inheritance model
[23:01:33] *** Quits: jdm (jdm@2F1C87B2.CB89F2A8.6AA50C35.IP) (Ping timeout)
[23:01:37] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[23:01:38] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[23:02:06] *** Quits: canhtak (canhtak@moz-8DFB5E6A.wl.t.ulaval.ca) (Quit: canhtak)
[23:02:14] <ecr> that could work if we're smart enough to infer the kindedness of Self
[23:02:14] <eddyb> trait<T> Functor {fn map<A, B>(self: Self<A>, f: |A| -> B) -> Self<B>;} makes slightly more sense
[23:02:29] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[23:02:35] <eddyb> ecr: trait<T> would give it the "kindedness"
[23:02:44] <eddyb> generic traits are trait Foo<T>
[23:03:33] <brson> strcat: moving where the intrinsics are doesn't remove a level of function indirection unless you expose the intrinsic extern fns themselves and I'm disinclined to do that without changing the way intrinsics work.
[23:03:37] <ecr> i like the second better. make sure people can't write a special Functor instance for Option<int>
[23:03:54] <ecr> because map doesn't depend on T
[23:04:10] <strcat> brson: well they are already the rust ABI, so we'd just have to change how the documentation shows them
[23:04:36] <ecr> eddyb: the second is how i've always seen people write HK rust
[23:04:56] <eddyb> I've seen something like trait HigherKinded<Self: type<T>> but that implies trait Trait: Foo + Bar is trait Trait<Self: Foo + Bar> which is incomplete (we differ from haskell, though it might be hard to find a counterexample in haskell because their dynamicity)
[23:05:02] <brson> strcat: i'm curious to know the compile-time and -O perf impact of removing i.e. the transmute wrapper
[23:05:05] <eddyb> s/dynamicity/dynamic nature/
[23:05:10] <brson> *-O0
[23:05:52] <brson> strcat: there are a few very commonly used intrinsics that probably need to be surfaces somewhere else in the API, like init, uninit, move_val_init
[23:05:53] <ecr> eddyb: dynamic nature? haskell? what
[23:06:06] <ecr> eddyb: only thing more static that Haskell is Coq
[23:06:11] <strcat> brson: std::mem
[23:06:24] <eddyb> ecr: runtime polymorphism. even if it's fake
[23:07:14] <eddyb> ecr: haskell type classes, AFAIK, work like Rust trait objects, but you can do more with them in haskell than you can with even generics in Rust (or they might be similar)
[23:07:35] <eddyb> I'm phrasing this all wrong :/
[23:07:55] *** Quits: lkuper (lkuper@moz-D862222C.dhcp-bl.indiana.edu) (Ping timeout)
[23:08:00] <ecr> eddyb: yeah, but I see what you're talking about now
[23:08:22] <ecr> AFAIK Haskell is all statically dispatched
[23:08:35] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[23:08:44] <ecr> but you can do a lot of fancy things with the type system
[23:09:08] <eddyb> ecr: so Haskell can take something that would be @[@Any] in Rust and use type classes implemented on those types. at least I think you can
[23:09:09] <ecr> there isn't a Haskell analogue of ~Trait though
[23:10:02] <eddyb> ecr: impl Functor for Option {fn map<A>(self: Option<A>, f: |A| -> B) -> Option<B> {match self {Some(x) => Some(f(x)), None => None}}} btw
[23:10:16] <kmc> ecr: there is in GHC Haskell
[23:10:35] <eddyb> at least I haven't seen any speculative syntax that makes as much sense to me as this does
[23:10:47] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[23:10:54] <eddyb> trait<T> Foo vs trait Foo<T> might be able to confuse newcomers :S
[23:10:55] <kmc> (well, aside from unique ownership)
[23:11:05] <ecr> kmc: really?
[23:11:11] <kmc> http://www.haskell.org/haskellwiki/Existential_type
[23:11:42] <ecr> oh right
[23:11:44] <kmc> you can write an existential type with a typeclass constraint (though it's not the only way to use existentials)
[23:11:58] <kmc> and that amounts to capturing the typeclass instance "dictionary" which is like a vtable
[23:12:01] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[23:12:10] <ecr> fair enough
[23:13:51] <ecr> eddyb: that's how I would write it
[23:14:14] <ecr> I think the main question for HKT syntax is how we want to specify higher kinded type parameters
[23:14:24] <ecr> either fully applied: <T, F<T>>
[23:14:31] <ecr> or not <F: * -> *>
[23:14:43] <eddyb> <F<type>>?
[23:14:58] <eddyb> * -> * looks like a type lambda
[23:15:04] <ecr> it is a type lambda
[23:15:07] <dbaupp> eddyb: that's knida exactly what it is
[23:15:26] <ecr> val -> val = functions
[23:15:33] <ecr> type -> val = generics
[23:15:41] <eddyb> which I've heard we should stay away from (in a Scala-related post)
[23:15:41] <ecr> type -> type = type operators/constructors/HKT
[23:15:46] <ecr> val -> type = dependent types
[23:16:40] *** Quits: yuriks (yuriks@C93719AB.4576F2C7.8E0C6B01.IP) (Ping timeout)
[23:17:06] <kimundi> ecr: Woha.
[23:17:14] * kimundi mind blown
[23:17:15] <ecr> kimundi: lambda cube FTW
[23:17:22] <cmr> indeed
[23:17:26] <eddyb> ecr: so struct FixedCapVec<T, static N: uint> {len: uint, data: [T, ..N]} would be a dependent type?
[23:17:34] <kmc> 4 simultaneous type systems in a single rotation of the lambda cube
[23:17:36] <ecr> eddyb: yep
[23:17:48] <eddyb> ecr: even if it's monomorphized at compile-time?
[23:18:14] <ecr> well actually it depends I guess
[23:18:31] <ecr> if you can't promote value uints into type uints, then it's not dependent
[23:18:37] <ecr> but if you can then it is dependent
[23:18:41] <eddyb> that is, N has to be constant (need special VLA handling in that specific case, for dynamic values. something general would never work IMO)
[23:18:50] <ecr> let me think about that
[23:18:54] <eddyb> ecr: ah, like DST for vectors
[23:18:57] <kmc> actually in a sense GHC does *only* dynamic dispatch, because any time you go to use a heap object it might be a thunk generated from anywhere, and you force evaluation by jumping to code pointed to by the first word of the heap object
[23:19:11] <kimundi> eddyb: I constant uint could be considered as a auto generated unit struct in that situation
[23:19:27] *** Joins: yuriks (yuriks@A61B73A9.3D6294A3.10054EA3.IP)
[23:19:31] <kmc> (except that it does pointer tagging to avoid this in some cases; also it has unboxed values which aren't heap objects)
[23:20:19] <eddyb> ecr: the planned DST includes something like this: *[T, ..N] => [T] represented as (*T, N)
[23:20:21] <kimundi> like, with assoziated constants, struct 1; impl 1 { static VAL: uint = 1 }
[23:21:03] <eddyb> ecr: and *T: Trait => *Trait represented as (*Erased, *Trait<for T>::vtable)
[23:21:42] <ecr> eddyb kimundi: I don't think FixedCapVec is dependent here. the type doesn't depend on the value (here the vector) and the capacity is using a type level uint instead of a value level uint.
[23:21:58] <kimundi> ecr: Right
[23:21:59] <ecr> a good example of a dependent type is a length indexed list
[23:22:03] <ecr> so something like
[23:22:05] <eddyb> kimundi: yay template metaprogramming
[23:22:09] <eddyb> ecr: I know that one
[23:22:16] <eddyb> but I gtg, it's late enough here
[23:22:25] <eddyb> ecr: thanks for the enjoyable information :D
[23:22:47] <ecr> Vec<T, N: nat> { data: [T, ..N] } where data never has empty elements
[23:22:49] *** Joins: lpy|afk (lpy@DE46E67C.1B5A1487.7CEBAF5A.IP)
[23:22:54] <ecr> eddyb: sure :)
[23:23:13] <ecr> then you can get nice things like 'append increases length by 1'
[23:23:18] <ecr> and 'map doesn't change length'
[23:23:27] <ecr> in the type system
[23:23:30] <ecr> and check them statically
[23:23:47] <kimundi> Yeah, I need to go to bed too. removing iter() from options can wait till tommorrow, especially if there are a bazillion errors in rustc :P
[23:24:36] *** Quits: eddyb (eddy@moz-92B95652.residential.rdsnet.ro) (Ping timeout)
[23:24:55] *** Quits: lpy|afk (lpy@DE46E67C.1B5A1487.7CEBAF5A.IP) (Ping timeout)
[23:25:04] <ecr> I need to stop procrastinating my project milestone paper by answering type theory questions in irc
[23:25:14] <ecr> will I?
[23:25:20] <ecr> undecidable
[23:25:37] *** Joins: andrew-d_w (andrew-d_w@moz-6214A95C.dk.customer.tdc.net)
[23:26:01] *** Quits: andrew-d_w (andrew-d_w@moz-6214A95C.dk.customer.tdc.net) (Input/output error)
[23:26:23] *** Joins: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net)
[23:27:20] <kimundi> hm... trait Nat<Succ> { static VAL: uint; static SUCC: Succ; }; struct 0; impl Nat<1> for 0 { static VAL: uint = 0; static SUCC: 1 = 1; }
[23:29:11] <Eridius> r? https://github.com/mozilla/rust/pull/12098
[23:29:38] <ecr> kimundi: oh god
[23:30:04] <kimundi> ecr: ;)
[23:30:17] <dbaupp> Eridius: I think the is_utf8 benchmarks are being DCE'd
[23:30:22] <dbaupp> fwiw
[23:30:32] <Eridius> dbaupp: DCE'd? Does that mean decomissioned?
[23:30:49] <dbaupp> Eridius: sorry; dead code eliminated
[23:30:55] <Eridius> oh. hmm
[23:30:57] <dbaupp> i.e. they're optimised to bh.iter(|| {})
[23:30:59] <ecr> kimundi: hold up. when did we get integer constants in type parameterS?
[23:31:04] <cgaebel> is unsigned overflow well-defined in rust?
[23:31:06] <Eridius> without the #[inline(always)] on first_non_utf8_index() it was taking something like 96ns..
[23:31:09] <kimundi> ecr: we didn't
[23:31:32] <ecr> kimundi: ah ok. I figured I couldn't have missed something that big
[23:31:35] <kimundi> cgaebel: yes
[23:31:39] <dbaupp> Eridius: I feel like the iterator will never catch up now
[23:31:39] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[23:31:40] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/7efhAA
[23:31:40] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[23:31:42] <dbaupp> :'(
[23:31:47] <cgaebel> kimundi: thanks
[23:31:52] <dbaupp> my baby
[23:31:53] <Eridius> dbaupp: :'( iterator should be able to win in the lots-of-invalid-sequences case
[23:32:38] <dbaupp> Eridius: theoretically the iterator should be able to be equal speed (if not faster)
[23:32:41] <dbaupp> oh
[23:32:44] * dbaupp has an idea
[23:34:06] <dbaupp> bleh, #[inline(always)]'ing next makes it faster but still not quite that fast
[23:34:29] <dbaupp> Eridius: you can perform a similar optimisation for the lots-of-invalid sequence case
[23:34:42] <dbaupp> for the non-iterator
[23:35:15] <dbaupp> although I guess that may actually be where the iterator is falling down
[23:35:36] <dbaupp> it's putting too much effort/code into sequences of invalid chars
[23:35:58] * dbaupp has another idea
[23:36:29] <Eridius> dbaupp: by "similar optimisation" you mean finding stretches of invalid bytes and pushing all the \uFFFDs at once? I don't think it's worth it
[23:36:30] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[23:36:30] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/WP3pbA
[23:36:30] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[23:36:31] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[23:36:31] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/z2V_aA
[23:36:31] <ghrust> 13rust/06auto 14520b55c 15mr.Shu: Fixed error messages in librustc/back/link.rs...
[23:36:31] <ghrust> 13rust/06auto 1449b7d61 15bors: auto merge of #12065 : mrshu/rust/error-formating-fix, r=alexcrichton...
[23:36:31] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[23:36:45] <Eridius> I see no point in trying to micro-optimize the case of lots of invalids, because that should be rare. As long as it's not too slow I'm happy
[23:37:24] <dbaupp> yeah
[23:38:29] <Eridius> now I just have to remember what the heck prompted me to implement this now... I had something I wanted to use it for
[23:38:35] <Eridius> ;)
[23:39:01] <Eridius> oh hmm I should probably implement BytesContainer for MaybeOwned
[23:39:16] * Eridius wishes he could implement it for Str without blocking concrete impls >_<
[23:40:15] <dbaupp> Eridius: Yurume had a good suggestion for MaybeOwned
[23:40:34] <ecr> what's MaybeOwned?
[23:40:36] <dbaupp> Essentially replace SendStr with MaybeOwned<'static>
[23:40:51] <dbaupp> ecr: MaybeOwned { Slice(&str), Owned(~str) }
[23:40:55] <dbaupp> *enu
[23:40:56] <dbaupp> m
[23:41:04] <ecr> huh
[23:41:16] <ecr> ok
[23:42:24] <Eridius> dbaupp: hmm, interesting. Would that work?
[23:44:05] <dbaupp> Eridius: yes
[23:44:29] *** Parts: ecr (chatzilla@moz-B30F97C9.dhcp4.washington.edu) ()
[23:44:55] *** Joins: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net)
[23:44:55] *** ChanServ sets mode: +o tjc
[23:57:48] <Luqman> strcat: did you ever figure out the debuginfo test failures?
[23:58:03] <strcat> Luqman: something else broke that I'm unable to figure out 
[23:58:06] <strcat> since then
[23:58:17] <Luqman> oh, what?
[23:58:27] <strcat> x86_64-unknown-linux-gnu/stage2/bin/compiletest: error while loading shared libraries: libcollections-6cc47867-0.10-pre.so: cannot open shared object file: No such file or directory
[23:58:39] <strcat> I think --disable-rpath is broken again
[23:59:10] <strcat> anyway make check doesn't work for me anymore

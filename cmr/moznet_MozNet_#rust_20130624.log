[00:00:01] <enticeing> addchstr
[00:00:04] *** Joins: doy (doy@moz-5FE28A32.akrasiac.org)
[00:00:43] <enticeing> it takes a *chtype, which is a *c_uint
[00:01:45] <enticeing> i can get it to run by using as_c_str, and casting it `as chtype_p`, but it just outputs gibberish
[00:01:59] *** Joins: Aetherspawn (Aetherspaw@moz-8811D9F0.static.tpgi.com.au)
[00:02:07] *** Joins: maxli1 (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[00:02:10] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Connection reset by peer)
[00:02:12] <aatch> enticeing, hmm, I can't even find addchstr
[00:02:25] *** maxli1 is now known as maxli
[00:02:29] <enticeing> it's in the manpage curs_addchstr
[00:02:35] <enticeing> if i remember
[00:02:43] <aatch> Found it.
[00:03:15] <enticeing> i thought it could've been unicode at first, but that doesn't make sense
[00:03:20] *** Quits: heftig (heftig@moz-9C5216F6.dip0.t-ipconnect.de) (Quit: Quitting)
[00:03:48] <aatch> enticeing, to start, probably should use the addchnstr variants.
[00:04:25] <enticeing> i'm thinking now it's in the cast from *i8 to *u32
[00:05:02] <aatch> enticeing, yes, just give me a moment.
[00:05:53] <aatch> Ok, you should be able to convert a string to a ~[char]
[00:06:36] <aatch> since it looks like it uses c_uint for individual characters
[00:07:54] <doener> this block_ -> Block refactoring is going to kill me... each change introduces more errors :-/
[00:08:39] <aatch> doener, oh yeah.
[00:08:43] <aatch> I tried that...
[00:08:52] *** Joins: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com)
[00:09:07] <aatch> doener, may I suggest changing fn_ctxt, first.
[00:09:46] <doener> because it's less work or because they interact?
[00:10:05] <aatch> because they interact. I found it was easier to work from the top down
[00:10:38] *** Joins: rjbailey (jake@moz-329F29A3.lightspeed.sntcca.sbcglobal.net)
[00:11:00] <aatch> When I first started refactoring, I tried to change CrateContext to be passed as &(mut) everywhere.
[00:11:04] <enticeing> aatch: how do i cast a string to a ~[char] then, and how do i get c to see that as a *c_uint
[00:11:11] *** Joins: dbaupp (Thunderbir@moz-73E90475.lns20.syd6.internode.on.net)
[00:11:24] *** Joins: heftig (heftig@moz-9C5216F6.dip0.t-ipconnect.de)
[00:11:28] <aatch> Heh, doesn't seem to be a function for it...
[00:11:54] <enticeing> also, i wish there was a .to_c_str for strings
[00:12:23] <engla> strcat: maybe flat_map is better than chain_map since vec already has flat_map too
[00:12:56] <cmr> enticeing: A string is much different than a ~[char]
[00:13:09] <cmr> enticeing: Is string is utf-8 encoding, a ~[char] is a vector of ucs-4 characters
[00:13:43] <aatch> rusti: let s = "String"; s.iter().collect()
[00:13:46] -rusti- <anon>:9:27: 10:5 error: cannot determine a type for this bounded type parameter: unconstrained type
[00:13:46] -rusti- <anon>:9          let s = "String"; s.iter().collect()
[00:13:46] -rusti- <anon>:10     };
[00:13:46] -rusti- application terminated with error code 101
[00:14:16] <cmr> rusti: let s = "String"; s.iter().collect::<~[char]>()
[00:14:18] -rusti- ~['S', 't', 'r', 'i', 'n', 'g']
[00:14:56] <aatch> There should probably be a function for that.
[00:15:06] <aatch> Though it would pretty much just be that line.
[00:15:13] <aatch> s/function/method
[00:15:57] <enticeing> cmr: i'm pretty much trying to get a string as a *c_uint without anything bad happening
[00:16:05] <cmr> oh
[00:16:13] * cmr didn't read the scrollback
[00:16:42] <aatch> enticeing, well you'll need to convert it to a ~[char], since curses wants an array of uints
[00:17:03] *** Quits: threecreepio (jdp@moz-DB2D70E9.cust.bredbandsbolaget.se) (Quit: threecreepio)
[00:17:14] <aatch> Though you will need to use the `addchnstr` variant
[00:17:15] *** Joins: Sorella (queen@B12A78F5.BA14766C.95C8B7C6.IP)
[00:17:16] <engla> rusti: fn to_vec<A, T: Iterator<A>>(mut it: T) -> ~[A] { it.collect() };  let s = "String"; to_vec(s.iter())
[00:17:17] -rusti- ~['S', 't', 'r', 'i', 'n', 'g']
[00:17:30] <enticeing> aatch: any particular reason i need addchnstr?
[00:17:42] <aatch> because then it doesn't need to be null-terminated
[00:17:51] <heftig> with str as utf-8 and char as ucs-4, i wonder how well rust does for win32 development, which i think uses utf-16le
[00:18:50] <cmr> There's a to_utf16 or something like that
[00:19:58] <heftig> is windows little-endian even on ARM?
[00:20:27] <aatch> without the null-terminator, curses doesn't know when the array ends. Since that line we gave you just makes a vector of characters, there's no null-terminator
[00:20:53] <enticeing> i could just wrap addchstr as addchnstr then
[00:21:08] <enticeing> but how do i get addchstr to take the vector
[00:21:08] <aatch> enticeing, also, as a general rule, it's better to use variants that take lengths
[00:21:12] <aatch> mcuh less likely to break
[00:22:30] <aatch> enticeing, you can use vec::raw::as_imm_buf
[00:22:35] <dbaupp> enticeing: vec::as_imm_buf gives you a *T
[00:22:51] <aatch> which takes a closure, passing the pointer and the length
[00:23:13] <dbaupp> aatch: (I don't think it's in raw?)
[00:23:14] *** Quits: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP) (Ping timeout)
[00:23:23] * aatch aatch checks
[00:23:25] <aatch> bah
[00:23:29] * aatch fails IRC
[00:23:54] <aatch> it is not, you are correct dbaupp 
[00:24:35] *** Quits: rjbailey (jake@moz-329F29A3.lightspeed.sntcca.sbcglobal.net) (Ping timeout)
[00:25:13] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[00:25:13] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/FE-4Zw
[00:25:13] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[00:26:17] *** Joins: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP)
[00:26:20] *** Joins: zucchini (Mibbit@95879FC5.102D9800.D35A31DF.IP)
[00:27:40] <enticeing> what's the second value in as_imm_buf ?
[00:27:57] *** Joins: barosl (barosl@E287D94F.C81E10FB.7544CABF.IP)
[00:28:12] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[00:28:12] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/XLEQSQ
[00:28:12] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[00:28:15] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[00:28:15] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/EYgQZw
[00:28:15] <ghrust> 13rust/06auto 14c75f8a4 15Alex Crichton: Rename all files with the 'rc' extension
[00:28:15] <ghrust> 13rust/06auto 142ca8047 15Alex Crichton: Add the `warnings` lint attribute
[00:28:15] <ghrust> 13rust/06auto 1488fe136 15Alex Crichton: Deny common lints by default for lib{std,extra}
[00:28:17] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[00:28:41] <enticeing> okay, getting closer to working properly
[00:29:12] *** Quits: BitPuffin (quassel@moz-49828767.cust.tele2.se) (Ping timeout)
[00:29:48] <enticeing> now, instead of "Hello, world!", i'm getting "Hlo ol!"
[00:29:54] <enticeing> i'm skipping every other character
[00:29:58] <zucchini> hi
[00:30:39] <dbaupp> enticeing: what's the line?
[00:30:42] <enticeing> aatch: this is what i have right now http://sprunge.us/NeIN
[00:30:42] <zucchini> I'm trying to implement a buffered io::Reader
[00:31:31] <dbaupp> enticeing: do chtype_p and char have the same size? 
[00:31:47] <enticeing> that's probably it
[00:31:57] <enticeing> chtype_p is just *c_uint
[00:32:46] <steven_is_false> Is there a way to get an RSS feed of commits that link to isrustfastyet?
[00:32:48] <zucchini> and it seems to me that the signature for read is wrong
[00:32:48] <zucchini> i.e. it needs to take a &mut self arg
[00:32:48] <zucchini> is there a way around this that I haven't thought of?
[00:32:48] <zucchini> specifically, when I call read(buf, len), I might need to update self, by pull data out of an internal buffer
[00:33:23] <zucchini> rust 0.6 gets around this, as in that version of rust, there were mutable fields on structs
[00:33:23] <zucchini> but they're gone, and now it seems it's impossible to implement a buffered reader
[00:33:27] <cmr> steven_is_false: no
[00:33:32] <steven_is_false> cmr: okay
[00:33:35] <dbaupp> enticeing: just googling quickly, it looks like chtype is `unsigned long`?
[00:33:52] <cmr> steven_is_false: actually maybe? isrustfastyet just pulls from the buildbots where all `auto` builds succeed
[00:34:03] <cmr> steven_is_false: so, check http://buildbot.rust-lang.org/
[00:34:03] <dbaupp> zucchini: I think there's the `Cell` type
[00:34:18] <dbaupp> zucchini: (which is internally mutable)
[00:34:28] <heftig> isrustfastyet seems to be rather noisy
[00:34:35] <zucchini> ah, hmm, okay
[00:34:40] <dbaupp> zucchini: and you can also wrap your reader in @mut to make it mutable
[00:34:43] <enticeing> dbaupp: here it is from the c header http://sprunge.us/ZhXW
[00:34:50] <cmr> heftig: it always has been, but it's especially noisy now because multiple builds run on same hardware at once
[00:35:12] <dbaupp> heftig: yeah, there's nothing I can do about it :(
[00:35:16] <cmr> heftig: some of them run on *different* hardware across builds, some go to EC2, etc.
[00:35:25] <heftig> cmr: ew.
[00:35:26] <cmr> heftig: basically the data is useless right now :p
[00:35:34] <heftig> can you count processor cycles instead of realtime?
[00:35:39] <cmr> no
[00:35:45] <cmr> the data is reported by the buildbots themselves
[00:35:52] <cmr> which we don't really have control over
[00:36:41] <dbaupp> heftig: buildbot reports the start/end time of each step, but that's all :(
[00:36:52] <dbaupp> enticeing: so it looks like it is unsigned long?
[00:37:01] <enticeing> looks that way
[00:37:17] <enticeing> looks like it's swallowing up an extra char in the conversion
[00:37:30] <dbaupp> you'll have to convert the [char] to [c_ulong] by hand
[00:37:39] <aatch> dbaupp, that's actually not too hard
[00:37:58] <cmr> long is defined to be at least 32bits isn't it?
[00:38:05] <dbaupp> `s.iter().transform(|c| c as c_ulong).collect::<~[c_ulong]>()`
[00:38:11] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Quit: Leaving.)
[00:38:22] <enticeing> so looks like my ffi has it as c_uint when it should be c_ulong
[00:38:29] <aatch> heh "by hand"
[00:38:58] <dbaupp> (is curses unicode aware?)
[00:39:01] <aatch> dbaupp, though wouldn't the transform closure be (|&c| c as c_ulong)
[00:39:06] <cmr> Oh yeah
[00:39:11] <cmr> enticeing: are you using ncursesw?
[00:39:15] <enticeing> yes
[00:39:16] *** Quits: vk (chatzilla@moz-389FEE13.hsd1.ca.comcast.net) (Quit: ChatZilla 0.9.90 [Firefox 22.0/20130617145905])
[00:39:17] <cmr> ok
[00:39:35] <dbaupp> aatch: nope, the string iter is Iterator<char>
[00:39:40] <enticeing> well, ncurses code would work fine run with ncursesw anyways
[00:39:50] <dbaupp> aatch: (since char is always an immediate.)
[00:39:51] <aatch> Ncurses also store attributes on the characters too
[00:40:03] *** Joins: victorporof (victorporo@70DEDDA.9004F55.9B1E38F4.IP)
[00:40:32] <aatch> dbaupp, fair enough. I though that transform was .transform(&fn(&T) -> U) -> Iterator<U>
[00:41:51] <zucchini> dbaupp: awesome, Cell is what I needed, thanks!
[00:42:11] *** Quits: victorporof (victorporo@70DEDDA.9004F55.9B1E38F4.IP) (Ping timeout)
[00:42:30] <aatch> heh, Cell is such a hack...
[00:43:12] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[00:43:12] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14e3529eb to 14f827561: 02http://git.io/N3iJvQ
[00:43:12] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[00:43:15] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[00:43:15] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/RB_W6Q
[00:43:15] <ghrust> 13rust/06auto 14f3966e4 15Honza Strnad: Added filtered method for Option type
[00:43:15] <ghrust> 13rust/06auto 14ac4211e 15bors: auto merge of #7279 : hanny24/rust/master, r=msullivan...
[00:43:15] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[00:43:55] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[00:43:55] *** ChanServ sets mode: +o brson
[00:43:58] <enticeing> wheeel, it's working now
[00:44:45] *** Joins: rjbailey (jake@moz-329F29A3.lightspeed.sntcca.sbcglobal.net)
[00:45:23] <enticeing> this finally did it: http://sprunge.us/EiKA
[00:45:26] <enticeing> thanks for the help guys
[00:45:35] *** Joins: roo (Mibbit@moz-F063C494.ip.windstream.net)
[00:45:35] <aatch> cmr, what was the ICE you got in subst?
[00:45:44] <cmr> aatch: opened an issue
[00:45:47] *** Quits: Jesin (Jessin_@moz-157A63DD.cc.lehigh.edu) (Input/output error)
[00:45:52] <cmr> https://github.com/mozilla/rust/issues/7332
[00:45:54] <enticeing> one thing that's bugging me, what's the second value in as_imm_buf?
[00:46:00] <cmr> oh I didn't paste the log
[00:46:12] <aatch> cmr, that's why I was asking.
[00:46:16] <cmr> enticeing: closure to execute
[00:46:35] <enticeing> it takes a T and a uint though
[00:46:37] <aatch> Depending on what the ICE is, sully may already have a fix
[00:46:40] <enticeing> what is the uint for?
[00:46:44] <aatch> enticeing, the length of the vector
[00:46:46] <strcat> aatch: you have r+ powers right?
[00:46:47] <dbaupp> enticeing: length
[00:46:48] <enticeing> ah, thanks
[00:46:49] <cmr> rust: task failed at 'index out of bounds: the len is 0 but the index is 0', /home/cmr/hacking/rust/src/librustc/middle/subst.rs:58
[00:46:52] <strcat> aatch: https://github.com/mozilla/rust/pull/7334 r?
[00:46:59] <cmr> enticeing: oh sorry
[00:47:18] * cmr stops trying to be helpful, is too groggy
[00:47:21] <dbaupp> strcat: \o/
[00:47:22] <aatch> strcat, I do. I mean, I'm able to commit to the repo, so it would be silly for my not to be.
[00:47:53] <cmr> strcat: that conflicts with one of my PRs that removes/updates a bunch of xfailed tests
[00:47:57] <sully> is 7332 a dupe?
[00:47:59] <cmr> strcat: it was r+'d, want to fold it in?
[00:48:00] <strcat> cmr: ;[
[00:48:01] <doener> requiring 'self on &mut self is strange
[00:48:05] <strcat> cmr: yeah, which?
[00:48:18] <cmr> https://github.com/mozilla/rust/pull/7309
[00:48:28] *** Quits: zucchini (Mibbit@95879FC5.102D9800.D35A31DF.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[00:48:38] <cmr> sully: I do not know
[00:48:58] <dbaupp> doener: it shouldn't be required?
[00:49:03] <strcat> cmr: there
[00:49:24] <cmr> strcat: thanks :)
[00:49:53] <doener> dbaupp: I have to add it right now to make rustc shut up
[00:50:06] <dbaupp> doener: oh, I see
[00:50:09] <cmr> `Showing 22 changed files with 120 additions and 549 deletions.` delicious
[00:50:41] <dbaupp> doener: (it used to be &[mut] self implicitly had 'self, but that was too restrictive)
[00:51:32] <doener> hm, how so? Doesn't self always live as long as, well, self?
[00:51:41] <enticeing> aatch: so the ones that take null-terminated strings should just take the size and pass that to the sized ones?
[00:51:58] <aatch> strcat, approved.
[00:52:11] *** Joins: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net)
[00:52:24] <aatch> enticeing, Well ideally you should construct a safe API over it.
[00:52:27] <strcat> aatch: going to add a p=1 to it so I can hurry up and remove all the each methods
[00:52:28] *** Quits: roo (Mibbit@moz-F063C494.ip.windstream.net) (Quit: http://www.mibbit.com ajax IRC Client)
[00:52:52] <dbaupp> doener: not really sure of the details, strcat knows more though
[00:53:08] <strcat> 'self is unrelated to "self" now
[00:53:09] <strcat> completely
[00:53:19] <dbaupp> strcat: but previously?
[00:53:26] <dbaupp> (why did it have to change?)
[00:53:26] <aatch> So as a consumer, you don't need to worry about those details
[00:53:32] <strcat> previously it was implicitly on any &self or &mut self
[00:53:35] <strcat> now it's unrelated
[00:53:42] <strcat> it won't have to be called 'self in the future too
[00:53:46] <strcat> the 'self name isn't special
[00:53:53] <dbaupp> yup...
[00:54:07] <strcat> it's just the only name allowed for a type parameter other than 'static right now, due to legacy reasons
[00:54:12] <dbaupp> doener's question is "Doesn't self always live as long as, well, self?"
[00:54:29] <aatch> strcat, Ahh, you edited my comment. That's creepy...
[00:54:34] <strcat> aatch: yep! :D
[00:54:50] <aatch> (Also, you can just do your own p=n in another comment)
[00:55:08] <cmr> http://rustlog.octayn.net/
[00:55:16] <strcat> aatch: ah didn't realize that
[00:55:19] <cmr> I'll probably update that daily/twice daily
[00:55:28] <cmr> if anyone cares, more for me to remember what I did :p
[00:55:57] <aatch> strcat, heh, it's not like bors is well-documented.
[00:55:58] <strcat> dbaupp: also, http://strcat.zapto.org:8000/
[00:56:07] <strcat> silly rusti web interface
[00:56:28] <strcat> really need a CDN to grab ace from.... it's huge
[00:56:48] <cmr> mooch off of github
[00:57:10] <strcat> need to submit it to cdnjs
[00:57:13] <strcat> the new version
[00:57:21] *** Joins: Thad (chatzilla@moz-C35F90AE.tx.res.rr.com)
[00:57:22] *** Joins: BitPuffin (quassel@moz-49828767.cust.tele2.se)
[00:58:05] <strcat> the auto-indent is really bad
[00:58:05] *** Quits: doener (doener@moz-121949B3.unitymediagroup.de) (Ping timeout)
[00:58:11] <Thad> How do I get the debug output for rustllvm during compile ?  I forgot...
[00:58:12] <strcat> maybe the rust mode is just bad
[00:58:29] <strcat> it doesn't indent after a brace ;\
[00:58:40] <dbaupp> strcat: that's awesome
[00:58:43] <strcat> but hey, it has a vim mode with text objects
[00:58:46] <strcat> so I forgive it
[00:59:10] <strcat> dbaupp: yep, need to make it into a web-service-in-a-vm and then talk to graydon about deploying it to rust-lang.org
[00:59:41] <dbaupp> steven_is_false: I'm planning a rewrite of IRFY, so I'll look into adding and RSS :)
[00:59:42] <dbaupp> *an
[00:59:49] <dbaupp> strcat: awesome
[01:00:12] <bjz> nmatsakis: ping
[01:00:38] <acrichto> r? https://github.com/mozilla/rust/pull/7113
[01:01:35] <strcat> acrichto: r+
[01:01:44] <acrichto> strcat: thanks!
[01:01:46] <dbaupp> strcat: I beat you ;P
[01:01:46] <strcat> heh dbaupp already did it
[01:02:02] <dbaupp> acrichto: good luck :)
[01:02:13] <strcat> removing mine so bors doesn't panic
[01:02:22] <aatch> I just want to say: Good Luck, we're all counting on you.
[01:02:26] <strcat> aatch: oh and the creepiest part is that I could edit your comment because the PR is from my repo
[01:02:30] <acrichto> maybe one of these days...
[01:02:38] <strcat> not because it's the rust repo (it doesn't count as that)
[01:03:08] * dbaupp thinks strcat should tell graydon again
[01:03:20] <strcat> yeah but what's the solution? ;p
[01:03:23] *** Joins: cowboyd (cowboyd@moz-DD0FF83.lightspeed.austtx.sbcglobal.net)
[01:03:24] <aatch> strcat, yeah...
[01:03:39] <strcat> sometimes I fix typos in other people's comments/issues
[01:03:42] <strcat> :D
[01:03:51] <dbaupp> strcat: a comment on the PR with the hash in it? (e.g. `r+ abadf00d`)
[01:03:54] <aatch> strcat, maybe comment on the PR with the hash?
[01:04:00] <aatch> dbaupp, heh, same idea
[01:04:02] <acrichto> also r? https://github.com/mozilla/rust/pull/7291
[01:04:05] <dbaupp> aatch: :D
[01:04:20] <aatch> Great minds think alike.
[01:04:22] <aatch> Also, ours
[01:04:24] <strcat> cmr: ahhh a test failed :[
[01:04:26] <strcat> sec
[01:04:34] <dbaupp> aatch: heh
[01:04:52] <strcat> one you un-xfailed
[01:04:57] <Thad> How do I get the debug output for rustllvm during compile ?  I forgot...
[01:04:58] * strcat will just amend it
[01:05:13] <aatch> Thad, what do you mean?
[01:05:26] *** Quits: rjbailey (jake@moz-329F29A3.lightspeed.sntcca.sbcglobal.net) (Ping timeout)
[01:05:35] <Thad> during extracting of rustllvm.dll ... it doesn't do anything for 30 mins +
[01:06:07] <aatch> extracting of, as in from the tarball?
[01:06:50] <Thad> hmm, looks that way.. it fires off the extracting... bits at the beginning of compile (this is a from scratch compile, btw)  fresh and new.
[01:07:23] <Thad> hmm VERBOSE=1 is not enough... still stuck on the extracting of rustllvm.dll
[01:07:24] <aatch> Thad, you're on Windows, right? Are you using the -j flag for make?
[01:07:27] <Thad> Yepa
[01:07:28] <Thad> yeap
[01:07:34] <aatch> Ok, don't use -j
[01:07:43] <aatch> it's pretty much broken on windows
[01:07:44] <Thad> ah.
[01:08:05] <Thad> can't use -j at all on Windows ?  or just the LLVM compile part ?
[01:08:21] <aatch> Thad, not sure. I'm just going by what I've heard
[01:08:23] <Thad> guess I can test both ways to Sunday
[01:09:01] <strcat> cmr: I bet it's going to break on windows too.... should run it through
[01:09:04] <Thad> ah... OK, -j is not good to use for the LLVM compile part... it's happily singing along now... I'll try with -j once I have the stage0 built
[01:09:24] <Thad> aatch: thanks for the tip !
[01:09:25] <strcat> you need -j #
[01:09:28] <strcat> or you're going to go oom
[01:09:41] <Thad> oom ??
[01:09:44] <strcat> out of memory
[01:09:53] <strcat> it will start 1000 compile jobs ;\
[01:09:56] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[01:09:56] <ghrust> 01[13rust01] 15thestinger 04force-pushed 06try from 14fe66af3 to 14e63455a: 02http://git.io/k471pw
[01:09:56] <ghrust> 13rust/06try 1443f78b5 15Daniel Micay: remove old_iter...
[01:09:56] <ghrust> 13rust/06try 14e63455a 15Corey Richardson: Fix/annotate a variety of xfails
[01:09:56] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[01:09:57] <Thad> with 32 GB ?
[01:10:02] <strcat> -j12 or something
[01:10:05] <strcat> Thad: sure
[01:10:08] <Thad> ouch
[01:10:15] <strcat> it will start a compile job for every file in LLVM's repo
[01:10:18] <strcat> pretty much
[01:10:19] <aatch> strcat, are you sure?
[01:10:22] <strcat> all the .cpp files
[01:10:23] <Thad> so ... REALLY BROKEN LIKE HUMPTY DUMPTY.
[01:10:37] <strcat>  If the -j option is given without an argument, make will not limit the number of jobs that can run
[01:10:38] <strcat>             simultaneously.
[01:10:59] <aatch> Oh right. I never tried it sans number
[01:11:05] <strcat> anyway after a certain point the context switching outweighs the benefits
[01:11:22] <strcat> like has SCHED_BATCH for that
[01:11:30] <strcat> chrt -b make -j16
[01:11:30] *** Joins: roo (jesse.rudo@moz-1669C300.dynamic.ip.windstream.net)
[01:11:31] <strcat> ;p
[01:11:38] <aatch> I do like the -l flag
[01:11:49] <strcat> linux has*
[01:12:20] <aatch> doesn't start new jobs if the load average is over a certain amount.
[01:13:15] <Luqman> i've never run into oom with just -j but i have run into proccess limits. probably didn't help that i was also building two copies of firefox at the same time though :P
[01:13:41] <strcat> Luqman: depends on how well made the makefile is
[01:13:55] <strcat> if they really list the deps well, it can start so many at a time
[01:14:20] <strcat> and how much memory it needs to compile a file
[01:15:03] <strcat> dbaupp: it'd be so awesome to have all the code samples in the tutorial as executable/editable blocks one day
[01:15:07] *** Quits: kini (kini@moz-92AA953A.members.linode.com) (Ping timeout)
[01:15:17] <dbaupp> strcat: that'd be amazing
[01:15:17] <strcat> need some machine with a huge amount of memory though :(
[01:15:32] <dbaupp> or compile rustc with emscripten
[01:15:40] * strcat doesn't think that'll work ;p
[01:15:42] *** Joins: kini (kini@moz-92AA953A.members.linode.com)
[01:15:44] <dbaupp> (that seems unlikely to work very well in a web browser though)
[01:15:49] <strcat> it needs files
[01:15:55] <aatch> strcat, that said, one of the major blockers was the address spaces
[01:15:57] <strcat> calls the linker, etc.
[01:16:04] *** kimundi is now known as zz_kimundi
[01:16:04] <strcat> aatch: yeah to run rust
[01:16:07] <strcat> but to run rustc is another thing
[01:16:08] <dbaupp> it also needs > 1GB RAM
[01:16:14] <aatch> Although I think that was just rust in general.
[01:16:16] <strcat> dbaupp: more if you compiled to js
[01:16:31] <strcat> typed arrays probably have some overhead
[01:16:40] * aatch is very happy that we don't have addrspace(0) everywhere now.
[01:16:41] <dbaupp> strcat: more than > 1GB is still > 1GB ;P
[01:17:05] <dcolish> has anyone run into link errors with rustllvm when building with rustpkg? https://gist.github.com/dcolish/5847172
[01:17:08] <strcat> dbaupp: well to compile the code samples it only uses 70MiB to 200MiB
[01:17:21] <strcat> rusti is limited to 128MiB of memory and we rarely hit it
[01:17:24] <dbaupp> strcat: ah, right. yeah
[01:17:44] <aatch> dcolish, is rustc even set up to be built with rustpkg?
[01:18:09] <dcolish> rustc isnt being built afaik
[01:18:13] <dcolish> its another package
[01:18:15] <dcolish> rust-http-client
[01:18:38] <aatch> dcolish, huh...
[01:19:00] <dcolish> I'm trying to get that package to build with rustpkg
[01:19:10] <dbaupp> dcolish: well it does say "WARNING: The Rust package manager is experimental and may be unstable"
[01:19:14] <dcolish> sure
[01:19:22] <dcolish> but i'm not shy of fixing it
[01:19:48] <aatch> dcolish, try running rustpkg with RUST_LOG=rustpkg
[01:19:58] <aatch> to get all the debug output
[01:20:06] <dbaupp> (there doesn't appear to be any bugs open with the same error)
[01:20:14] *** Quits: RageOfThou (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[01:20:22] <dcolish> its interesting that its using rustc's lib dir not the ${prefix}/lib dir for linking
[01:20:28] <dcolish> i see rustllvm in the prefix dir
[01:20:44] <dcolish> so if i can adjust the linker path it'll probably work, but its not clear how or where
[01:20:52] <dcolish> i guess link_args?
[01:20:53] <strcat> the rustc library directory is for compiling rust programs with rustc
[01:20:56] <strcat> the /usr/lib one isn't
[01:20:59] <strcat> it's for rustc itself
[01:21:08] <aatch> dcolish, well the two dirs are for rustc itself, and other programs.
[01:21:41] <bjz> would a `const xmlChar *` be a `const *xmlChar`?
[01:21:42] <aatch> rustllvm isn't for general usage (though it could be argued that neither librustc or libsyntax are either, but that's neither here not there)
[01:21:52] <aatch> bjz, just leave the const off
[01:22:04] <strcat> yes * is immutable
[01:22:11] <strcat> if it's *not* const you need *mut
[01:22:28] <bjz> why does rust have const then?
[01:22:35] <strcat> bjz: const doesn't mean immutable
[01:22:44] <strcat> it means read-only through that reference
[01:22:49] <dcolish> shouldnt rustc already be linked against that its lib dir and use the /usr/lib dir for linking newly compiler programs?
[01:22:49] <strcat> and it's close to deprecated
[01:22:57] <strcat> dcolish: no
[01:23:11] <strcat> dcolish: it's a cross-compiler, the target dir is there to compile for a target
[01:23:17] <dcolish> ah
[01:23:19] <strcat> using the same /usr/lib would mean building a stage3 afaik
[01:23:35] <dcolish> hmm
[01:23:43] <strcat> the /usr/lib ones are built with the stage1 compiler and the /usr/lib/rustc/ ones are built with the stage2 compiler
[01:23:45] <strcat> they aren't the same
[01:24:00] <strcat> would need to compile another stage for them to be the same
[01:24:14] *** Joins: rjbailey (jake@moz-329F29A3.lightspeed.sntcca.sbcglobal.net)
[01:24:26] <strcat> as in built a stage3 compiler with the stage2 libs
[01:24:27] <aatch> Which is why that is exactly what a snapshot does
[01:24:34] <strcat> build*
[01:24:43] <aatch> stage0 is actually stage3 from the past.
[01:24:53] <strcat> I should start doing that for my Arch package
[01:24:55] <strcat> so it can be smaller
[01:25:01] <strcat> can make the target libs symlinks
[01:25:07] <strcat> where host == target
[01:25:10] <Jeaye> rusti: let v: ~[1, 2, 3]; v.iter().enumerate().advance |(i, x)| { println(fmt!("%?: %?", i, x)); }
[01:25:11] -rusti- <anon>:9:18: 9:19 error: expected type, found token LIT_INT_UNSUFFIXED(1)
[01:25:11] -rusti- <anon>:9          let v: ~[1, 2, 3]; v.iter().enumerate().advance |(i, x)| { println(fmt!("%?: %?", i, x)); }
[01:25:11] -rusti-                            ^
[01:25:11] -rusti- application terminated with error code 101
[01:25:30] <bjz> strcat: so const will be removed?
[01:25:36] <strcat> bjz: not necessarily
[01:25:37] <Jeaye> rusti: let v = ~[1, 2, 3]; v.iter().enumerate().advance |(i, x)| { println(fmt!("%?: %?", i, x)); }
[01:25:39] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/KcBE
[01:25:43] <strcat> bjz: but you shouldn't use it unless you really need it
[01:25:45] <strcat> and you probably don't
[01:25:45] <aatch> strcat, well if you don't mind a little extra work, snap-stage3 will get you a tarball.
[01:26:06] <aatch> of a stage3 build compiler.
[01:26:13] <bjz> strcat: would be better if it had a different name to reduce confusion. like, `readonly`
[01:26:29] <aatch> bjz, it's supposed to be similar to C++'s const
[01:26:31] <Jeaye> What am I missing there?
[01:26:40] <strcat> cmr: unconstrained-region.rs hits a codegen bug :(
[01:27:00] <strcat> Jeaye: you're using for loop syntax without a for loop
[01:27:17] <Jeaye> Ah!
[01:27:28] <Jeaye> rusti: let v = ~[1, 2, 3]; for v.iter().enumerate().advance |(i, x)| { println(fmt!("%?: %?", i, x)); }
[01:27:28] -rusti- 0: &1
[01:27:29] -rusti- 1: &2
[01:27:29] -rusti- 2: &3
[01:27:29] -rusti- ()
[01:27:40] <bjz> aatch: oh ok
[01:27:40] <Jeaye> strcat: :P
[01:27:53] <dcolish> well just incase here's that build with logging https://gist.github.com/dcolish/5847198
[01:28:55] <aatch> dcolish, huh, that's really odd
[01:29:10] <steven_is_false> How do I divide the space of possible hashes up among buckets?
[01:29:18] <strcat> cmr: https://github.com/mozilla/rust/issues/7336
[01:29:29] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[01:29:29] <ghrust> 01[13rust01] 15thestinger 04force-pushed 06try from 14e63455a to 14e119fd5: 02http://git.io/k471pw
[01:29:29] <ghrust> 13rust/06try 14e119fd5 15Corey Richardson: Fix/annotate a variety of xfails
[01:29:29] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[01:29:49] <steven_is_false> Like I have foo.hash(), and a constant BUCKETS_AMOUNT, how do I distribute the values foo evenly amount the buckets?
[01:30:13] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[01:30:18] <dcolish> aatch: i think i narrowed it down a little. that package uses a custom makefile which could be invoking rustc incorrectly
[01:30:20] <steven_is_false> The thing that is confusing me is how do I keep this from overflowing?
[01:31:01] <steven_is_false> As I understand it all I need to do is key.hash() * BUCKETS_AMOUNT / u64::max_value() but in a way that doesn't overflow.
[01:31:01] <aatch> dcolish, yeah, I was thinking that it might be an issue with rust-http-client
[01:31:06] <dbaupp> steven_is_false: hash % BUCKETS_AMOUNT
[01:31:13] <dbaupp> ?
[01:31:20] <steven_is_false> dbaupp: Right, that's sensible.
[01:31:59] <aatch> steven_is_false, ^^^ that works because you generally assume that key.hash() is a good hash.
[01:32:22] <dcolish> aatch: yeah i'm thinking that its build might be broken right now. its not building even off its master with just the Makefile
[01:32:24] <strcat> assumes that all of the bits hold equal entropy
[01:32:43] <strcat> ofc if you don't have a good hash... you're screwed in many cases anyway
[01:33:52] <aatch> entropy per bit ~= 1 for a really good hash
[01:34:46] <steven_is_false> How can I access the hash() method of the HashUtil trait?
[01:35:06] <aatch> steven_is_false, you just need to `use` it in
[01:35:12] *** Quits: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP) (Ping timeout)
[01:35:31] <steven_is_false> aatch: Got it.
[01:37:17] <strcat> that's really not good
[01:37:45] <strcat> an innocent little test segfaulting
[01:37:58] <bjz> strcat: would I need all these functions? http://www.xmlsoft.org/html/libxml-SAX2.html
[01:38:01] <strcat> looks like closures are totally broken
[01:38:20] <aatch> strcat, uh oh.
[01:38:29] <bjz> strcat: some of the structs are pretty complex, dunno if it's worth doing all of them
[01:38:30] <strcat> aatch: https://github.com/mozilla/rust/issues/7336 this one
[01:38:35] <aatch> strcat, any idea how?
[01:38:37] <strcat> bjz: I forget ;(
[01:38:45] <strcat> aatch: no, but it's a simple test
[01:38:54] <strcat> aatch: try compiling unconstrained-region.rs with rustc
[01:38:55] <bjz> strcat: like, http://www.xmlsoft.org/html/libxml-tree.html#xmlSAXHandler
[01:39:01] <strcat> doesn't matter when the rustc is from
[01:39:02] <strcat> it's xfailed atm
[01:39:38] <aatch> I get a compiler error
[01:40:13] <strcat> -// xfail-test
[01:40:14] <strcat> -// See #3283
[01:40:16] <strcat> -fn foo(blk: &fn(p: &'a fn() -> &'a fn())) {
[01:40:17] <aatch> Saying that the lifetime must be declared
[01:40:18] <strcat> -        let mut state = 0;
[01:40:20] <strcat> -        let statep = &mut state;
[01:40:22] <strcat> +fn foo<'a>(blk: &fn(p: &'a fn() -> &'a fn())) {
[01:40:24] <strcat> +    let mut state = 0;
[01:40:26] <strcat> +    let statep = &mut state;
[01:40:28] <strcat> oh
[01:40:30] *** Joins: victorporof (victorporo@70DEDDA.9004F55.9B1E38F4.IP)
[01:40:30] <strcat> forgot
[01:40:56] <steven_is_false> Hi guys! Can anyone look over my concurrent hashmap code, and see if I've made any errors? http://pastebin.mozilla.org/2556966
[01:41:40] <aatch> strcat, I added the region param, no error
[01:41:46] <strcat> aatch: run it
[01:41:58] <strcat> rusti: fn foo<'a>(blk: &fn(p: &'a fn() -> &'a fn())) { let mut state = 0; let statep = &mut state; do blk { || { *statep = 1; } }  do foo |p| { p()() }
[01:41:58] -rusti- <anon>:12:0: 12:1 error: file ended with unbalanced delimiters
[01:41:58] -rusti- <anon>:12 }
[01:41:58] -rusti-           ^
[01:41:59] -rusti- application terminated with error code 101
[01:42:08] <strcat> rusti: fn foo<'a>(blk: &fn(p: &'a fn() -> &'a fn())) { let mut state = 0; let statep = &mut state; do blk { || { *statep = 1; } } }  do foo |p| { p()() }
[01:42:09] -rusti- application terminated abnormally with signal 4 (Illegal instruction)
[01:42:10] <aatch> my version of rustc here is ~1 week old
[01:42:27] <aatch> and I don't get any errors running it either
[01:42:35] <strcat> aatch: maybe a regression then
[01:42:38] *** Quits: victorporof (victorporo@70DEDDA.9004F55.9B1E38F4.IP) (Ping timeout)
[01:42:40] <strcat> I noticed some other codegen bugs recently
[01:42:43] <strcat> with closures
[01:42:50] <aatch> strcat, ah, it only happens with optimizations on here
[01:43:00] <strcat> aatch: weird, I'm not optimizing
[01:44:23] *** Quits: RMF (RMF@moz-8C13D5A2.dsl.telepac.pt) (Ping timeout)
[01:44:41] <strcat> rusti: fn foo<'a>(blk: &fn(p: &'a fn() -> &'a fn())) { let mut state = 0; let statep = &mut state; do blk { || { *statep = 1; } } }  do foo |p| { p()() }
[01:44:43] -rusti- application terminated abnormally with signal 4 (Illegal instruction)
[01:44:51] <strcat> rusti: fn foo<'a>(blk: &fn(p: &'a fn() -> &'a fn())) { let mut state = 0; let statep = &mut state; do blk { || { *statep = 1; } } }  do foo |p| { p()() }
[01:44:52] -rusti- application terminated abnormally with signal 4 (Illegal instruction)
[01:44:59] <strcat> [109976.437905] traps: out[17317] trap invalid opcode ip:400a39 sp:10c4fc0 error:0 in out[400000+1000]
[01:45:43] <strcat> there's no opcode at 400a39
[01:45:50] <strcat> seems like the function is misaligned or something?
[01:45:54] <strcat> ;\
[01:46:01] <strcat> or the pointer points at the wrong place
[01:46:22] <strcat>   400a35: 49 bb 00 00 00 00 00  movabs $0x0,%r11
[01:46:23] <strcat>   400a3c: 00 00 00 
[01:46:25] <strcat>   400a3f: e8 60 02 00 00        callq  400ca4 <__morestack>
[01:46:36] <aatch> Hmm, if I output assembly, then compile with clang I get a canary death
[01:46:50] <strcat> aha, so the stack canary errors are still around
[01:47:02] * strcat thinks this is why jemalloc was dying
[01:47:18] <strcat> brson: any idea? ^
[01:47:18] <aatch> so rustc -S ..., then clang foo.s <link flags>
[01:47:31] <strcat> aatch: weird :[
[01:48:01] <aatch> And that's during startup
[01:48:13] <strcat> does it work on another file?
[01:48:17] *** Joins: RMF (RMF@moz-2DCE560B.dsl.telepac.pt)
[01:48:41] <strcat> http://buildbot.rust-lang.org/builders/try-mac/builds/558/steps/test/logs/stdio segfaults on mac too
[01:48:44] <strcat> not linux specific
[01:49:11] <aatch> I've seen that particular error quite often on cross-compiled mac builds
[01:49:25] <aatch> It's possible we're using the wrong alignment in places.
[01:49:35] <strcat> well it's not good
[01:49:38] <strcat> ;p
[01:51:18] <aatch> ok, so rust -> assembly -> exe works fine for a hello world
[01:51:48] <strcat> I think if we fix this issue we can use jemalloc again :(
[01:52:02] * strcat is bad at dealing with this kind of bug though
[01:54:10] <bjz> strcat: there seems to be a whole load of typedefs from http://www.xmlsoft.org/html/libxml-tree.html
[01:54:22] <bjz> strcat: were you saying I wouldn't need the tree?
[01:54:35] <strcat> bjz: you don't need the tree
[01:54:45] <strcat> bjz: you just need the SAX thing, I think there's some struct with function pointers you have to make
[01:54:48] <strcat> and you pass it in
[01:54:51] <strcat> and it just calls your callbacks
[01:55:01] <strcat> don't remember the exact details. you need like 4 function calls and a struct though
[01:55:06] <bjz> xmlSAXLocator?
[01:55:35] <bjz> xmlSAXHandler?
[01:55:58] *** Quits: rjbailey (jake@moz-329F29A3.lightspeed.sntcca.sbcglobal.net) (Ping timeout)
[01:56:12] <bjz> http://www.xmlsoft.org/html/libxml-SAX2.html#xmlSAX2InitDefaultSAXHandler
[01:56:55] <bjz> http://www.xmlsoft.org/html/libxml-SAX2.html#xmlSAX2SetDocumentLocator
[01:57:07] <strcat> bjz: yep that's what you need, an xmlSAXHandler
[01:57:21] <strcat> bjz: don't think that Locator one is what you want
[01:57:57] <bjz> xmlSAX2InitDefaultSAXHandler, xmlSAX2InitHtmlDefaultSAXHandler, htmlDefaultSAXHandlerInit, xmlSAX2InitDocbDefaultSAXHandler, docbDefaultSAXHandlerInit, xmlDefaultSAXHandlerInit
[01:58:00] <aatch> strcat, hmm, I get `traps: test[6586] trap invalid opcode ip:4009b9 sp:7fb51bc4ea40 error:0 in test[400000+1000]` but there is code at that location
[01:58:18] <bjz> are the ones that seem to be dealing  with the handler
[01:58:36] <strcat> bjz: http://gaiacrtn.free.fr/articles/libxml2_sax2.html
[01:59:12] *** Quits: illissius (illissius@moz-19397A63.catv.broadband.hu) (Ping timeout)
[01:59:25] <aatch> strcat, Ah, objdump has 'ud2' at that location which is "undefined instruction"
[02:01:34] *** Quits: Thad (chatzilla@moz-C35F90AE.tx.res.rr.com) (Quit: ChatZilla 0.9.90 [Firefox 22.0/20130617145905])
[02:01:40] <dcolish> ok if i drop the pkg.rs and use lib.rs it builds fine
[02:01:58] <dcolish> i guess something odd if going on with that during linking
[02:02:05] <dcolish> s/if/is/
[02:02:10] <strcat> aatch: :(
[02:02:18] <aatch> Uh, this is odd... LLVM seems aware that shit is wrong. emits a @llvm.trap there
[02:02:21] * strcat is surprised any rust manages to work ;[
[02:02:29] <strcat> aatch: what does llvm-lint say?
[02:02:37] <aatch> nothing, that's the strange thing
[02:02:42] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[02:03:00] <aatch> And the lint pass is run /before/ optimization
[02:05:37] *** Quits: enticeing (user@1983AA36.E4834407.EAAB5301.IP) (Client exited)
[02:08:29] <aatch> strcat, so looking at the pre-optimized code, for some reason it stores 0x12345678 in the "refcount" field in the header.
[02:08:51] <aatch> when it goes to call the closure
[02:09:08] <strcat> huh
[02:09:12] <aatch> I know
[02:09:16] <strcat> incorrect glue I guess?
[02:09:22] <strcat> very, very strange
[02:09:24] <aatch> And it's always that
[02:09:38] <aatch> every closure-call sequence
[02:09:41] *** Joins: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu)
[02:10:16] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[02:10:39] <strcat> aatch: does that actually cause the problem?
[02:10:41] *** Joins: xLII (xLII@4BED3CB3.F5F53E8A.2D6DB75E.IP)
[02:10:42] <strcat> or it's unrelated
[02:10:42] <bjz> strcat: what does memset do in http://gaiacrtn.free.fr/articles/libxml2_sax2.html
[02:10:56] <strcat> bjz: zeroes the whole struct
[02:11:00] <strcat> bjz: as in sets the ptrs to null
[02:11:02] <aatch> strcat, dunno. checking it out now
[02:11:10] <strcat> bjz: if they're null it won't try to call them ;p
[02:11:14] <bjz> strcat: ahh
[02:11:33] <bjz> strcat: I'm guessing I'd just null them all?
[02:11:39] <aatch> strcat, ok, so it's deliberate
[02:11:45] <strcat> bjz: yes and then initialize the ones you care about to extern fns
[02:12:03] <strcat> bjz: depending on the structure you care about
[02:12:11] <strcat> bjz: you need to use the context to store your state
[02:12:15] <bjz> strcat: cool
[02:12:17] <aatch> it's nuking the ref count (for some reason)
[02:12:38] <bjz> strcat: so for: http://www.opengl.org/discussion_boards/showthread.php/181927-New-XML-based-API-Registry-released?p=1251775
[02:13:04] <strcat> bjz: well what's the structure of the xml files?
[02:13:12] <bjz> strcat: https://cvs.khronos.org/svn/repos/ogl/trunk/doc/registry/public/api/gl.xml
[02:13:19] <bjz> strcat: sorry for being dumb
[02:13:36] <strcat> bjz: so you have to store your current state
[02:13:42] <strcat> "inside namespace foo"
[02:13:56] <strcat> and just set up code to work on the start/end elements and text nodes
[02:14:05] <strcat> keeping in mind that it will split up text nodes into parts
[02:14:33] <strcat>     <enums namespace="NVPathRenderingMask" type="bitmask">
[02:14:35] <strcat> so here
[02:14:41] <strcat> it calls your start element callback
[02:14:50] <strcat> you set namespace = Some("NVPathRenderingMask") or whatever
[02:14:52] <bjz> ok
[02:14:59] <strcat> then it hands you
[02:15:00] <strcat>         <enum value="0x01"        name="GL_BOLD_BIT_NV"/>
[02:15:03] <strcat> etc.
[02:15:04] <bjz> startElementNs?
[02:15:14] <strcat> bjz: I think just startElement?
[02:15:24] <bjz> oh
[02:15:25] <strcat> Ns means namespace (as in xml namespace, they use colons)
[02:15:25] <bjz> yup
[02:15:27] <bjz> startElement
[02:15:40] <strcat> bjz: yeah need to look for startElement/endElement at a minimum
[02:15:54] <strcat> and handle.... 'characters' or whatever they call it for text nodes (it splits them though)
[02:15:56] <steven_is_false> There should be an implementation of clone for &'static str. It'd be really easy too. It'd be the identity.
[02:16:15] <strcat> steven_is_false: other slices too
[02:16:19] <strcat> I'll do it right now
[02:16:20] *** Quits: BitPuffin (quassel@moz-49828767.cust.tele2.se) (Ping timeout)
[02:16:25] <steven_is_false> strcat: Thanks!
[02:16:31] *** Joins: jrfeenst (jrfeenst@moz-F912484F.cpe.norwoodlight.com)
[02:16:32] <bjz> strcat: http://www.xmlsoft.org/html/libxml-parser.html#startElementSAXFunc
[02:16:39] <bjz> found that
[02:16:46] <strcat> bjz: that's just the type declaration
[02:16:50] <strcat> of *your* function
[02:16:53] <bjz> I know
[02:16:57] <strcat> ah, okay
[02:16:58] <bjz> the callback type
[02:17:02] <bjz> extern fn
[02:17:06] <strcat> anyway I like the SAX one because you just make your own state handling
[02:17:08] <bjz> *u8 for now
[02:17:12] <strcat> don't need to worry about 20000 tree functions
[02:17:14] <strcat> too much pain
[02:17:19] *** Quits: jrfeenst (jrfeenst@moz-F912484F.cpe.norwoodlight.com) (Quit: jrfeenst)
[02:17:41] <strcat> I've mostly dealt with ones like the 38GiB wikipedia db dumps ;p
[02:17:50] <strcat> so you have to use SAX anyway since you can't load that as a tree
[02:18:29] *** Quits: int3_ (int3_@moz-C0E38A24.dsl.static.sonic.net) (Client exited)
[02:18:53] <bjz> thanks tons for your help
[02:18:56] * dbaupp thinks strcat just needs more ram
[02:19:03] <bjz> x)
[02:19:06] *** Joins: kdj (kyle@FA39BFBF.D27A4F86.8BEFA1E3.IP)
[02:19:44] <strcat> bjz: np
[02:20:25] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[02:20:37] <bjz> ugh, error is a: typedef void (XMLCDECL *errorSAXFunc) (void *ctx, const char *msg, ...) LIBXML_ATTR_FORMAT(2,3)
[02:20:52] <bjz> what would I do with the vararg?
[02:21:11] <strcat> bjz: if you don't actually need the vararg part you can ignore it
[02:21:14] <strcat> cdecl is caller cleanup
[02:21:20] <strcat> if you don't handle args, it's okay
[02:21:33] <bjz> ok
[02:21:33] <aatch> strcat, woah. Ok, after one of the passes, it produces this lovely IR: "store i64* undef, i64** null, align 536870912"
[02:21:35] <strcat> otherwise.... I guess you need a wrapper in C
[02:21:41] <strcat> aatch: nice
[02:21:44] <strcat> aatch: that's... amazing
[02:22:01] <aatch> which is 0x20000000
[02:22:24] <kdj> Hi all. quick question... coming back to playing with rust... mutable vectors in a struct, where elements can be changed in an impl function... any examples of that somewhere?
[02:22:25] <aatch> I think I found the bug...
[02:22:53] <bjz> strcat: so just: extern fn foo(ctx: *_void,  msg: *char)
[02:22:58] <strcat> bjz: yep
[02:23:07] <strcat> c_char
[02:23:13] <bjz> yeah woops
[02:23:18] <bjz> you get the idea
[02:23:24] <strcat> bjz: probably want *mut for ctx though
[02:23:33] <strcat> since you have to store all your state in it
[02:23:59] * aatch thinks it might be an LLVM bug
[02:24:02] <strcat> and iirc if you want to break out, there's something function you have to call to tell the parser to stawp
[02:24:13] <strcat> aatch: it's doubtful though
[02:24:23] <strcat> aatch: go ask in #llvm ;p
[02:24:28] <strcat> aatch: https://github.com/mozilla/rust/pull/7337 r?
[02:24:36] <aatch> yeah, but it turns something normal-looking into that ^^^
[02:24:52] <strcat> steven_is_false: ^ implemented
[02:24:59] <aatch> then turns that into a trap
[02:25:36] <Luqman> r? again https://github.com/mozilla/rust/pull/7269
[02:25:54] <strcat> Luqman: r+
[02:26:03] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[02:26:49] <strcat> aatch: meh you know what, I'm going to shove it into my other pull.
[02:26:56] <aatch> strcat, fair enough
[02:27:05] *** Quits: goffrie (goffrie@moz-9153684F.dsl.ncf.ca) (Ping timeout)
[02:27:46] *** Joins: goffrie (goffrie@moz-9153684F.dsl.ncf.ca)
[02:28:05] *** Joins: z0w0 (zack@moz-DD233ABD.lnse4.woo.bigpond.net.au)
[02:29:11] <strcat> and maybe I'll land some other ones...
[02:29:27] <steven_is_false> Okay, so I've worked on my concurrent hash map implementation a bit more. Here it is http://pastebin.mozilla.org/2557026 . Can anyone see any obvious problems with it?
[02:33:00] *** Quits: goffrie (goffrie@moz-9153684F.dsl.ncf.ca) (Quit: Lost terminal)
[02:33:06] *** Quits: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net) (Ping timeout)
[02:33:10] <dbaupp> steven_is_false: does it compile?
[02:33:20] <steven_is_false> dbaupp: yep
[02:33:23] <dbaupp> cool!
[02:34:00] <steven_is_false> Using tasks to implement the hashmaps it was partitioned into was a bit silly but it was an interesting learning exercise.
[02:34:20] *** Quits: tcsc (tcsc@moz-ADC0ED45.hsd1.ct.comcast.net) (Quit: computer sleeping)
[02:35:52] <zslayton> Could someone point me to an example of the syntax for writing a generic trait implementation in terms of another trait? (e.g. providing an impl of a trait for Floating types)
[02:40:05] <aatch> zslayton, impl<T:Trait> Extension for T { ... }
[02:40:31] <aatch> Though I'm not sure if you can extend traits defined in other crates
[02:40:48] <zslayton> Oh, hrm.
[02:40:56] <zslayton> That might be alright in this instance. 
[02:40:59] *** Joins: victorporof (victorporo@70DEDDA.9004F55.9B1E38F4.IP)
[02:41:07] <zslayton> I'll give it a go
[02:41:09] <zslayton> Thanks!
[02:41:41] <dbaupp> aatch: it should work fine cross-crate... I think...
[02:41:56] <aatch> dbaupp, I know there are limitation on extension impls
[02:42:20] <dbaupp> zslayton: (using that technique means that you can't impl Extension for any thing else, but there's no other way.)
[02:42:50] <kdj> Okay, well, as an example, this doesn't compile: https://gist.github.com/kyledj/4748eeb67399dc4a35ee
[02:43:04] <kdj> I can't figure out how to declare that vector as mutable in the declaration
[02:43:13] *** Quits: victorporof (victorporo@70DEDDA.9004F55.9B1E38F4.IP) (Ping timeout)
[02:43:33] <aatch> kdj, in `add` you want &mut self
[02:43:35] <dbaupp> kdj: you need `&mut self` instead of `&self` for add
[02:43:36] <acrichto> kdj: the 'fn add' needs '&mut self' instead of just '&self' to notate that the fields of 'self' as well are mutable
[02:43:41] <kdj> Ah!
[02:43:48] <kdj> Thanks to all of you!
[02:43:49] <kdj> :D
[02:43:59] <aatch> In triplicate!
[02:44:01] <kdj> Makes perfect sense
[02:44:15] <zslayton> dbaupp: So if I do: impl<T:Float> SomeTrait for T{}, I can't do it again later for <T:Integral> ?
[02:44:24] <dbaupp> zslayton: nope :(
[02:44:55] <zslayton> dbaupp: Bummer. Is that planned functionality, or just a limitation to live with?
[02:45:17] <dbaupp> the technique used in the stdlib to get around this is a macro that expans to the impl, so you just write trait_impl!(float), trait_impl!(f32), ...
[02:45:36] <steven_is_false> Oh shoot! I don't think I can use a RWARC to implement a concurrent hashmap because HashMap is not Const right?
[02:45:46] <strcat> std::hashmap is Const.
[02:45:56] <steven_is_false> Oh good then
[02:46:07] <dbaupp> zslayton: I think this exact one is a limitation required for a coherent type system (e.g. what if a type impl'd both Float and Integral, which impl of SomeTrait applys?)
[02:46:16] <strcat> only @mut, RcMut, Cell, &mut, &const (and anything that owns them) is non-Const
[02:46:31] <steven_is_false> okay.
[02:46:34] <dbaupp> *applies
[02:46:34] <zslayton> dbaupp: That makes sense. Good call.
[02:46:37] <acrichto> kinda weird that &const is non-Const ...
[02:46:54] <strcat> acrichto: being renamed to Freeze and &const will probably be removed
[02:46:59] <dbaupp> maybe const should be renamed `readonly`?
[02:47:01] <zslayton> dbaupp: I was toying with some code and noticed that someone had commented "Replace these macro impls with a generic trait impl"
[02:47:06] <strcat> dbaupp: removed* ;p
[02:47:08] <acrichto> strcat: how does & differ from &const?
[02:47:09] <zslayton> dbaupp: So I thought that technique was being phased out.
[02:47:14] <dbaupp> strcat: well, that too
[02:47:17] <strcat> acrichto: & points to immutable data
[02:47:21] <strcat> acrichto: and you can take & deeper into &
[02:47:28] <aatch> strcat, by the way, this is the problem point: https://gist.github.com/Aatch/5847420
[02:47:31] <strcat> acrichto: &const can't be borrowed from and it points to possibly mutable memory
[02:47:35] <strcat> you can't mutate *through* &const
[02:47:43] <dbaupp> zslayton: well, it's not great, but there's not really a way to get around it at all
[02:47:47] <acrichto> odd...
[02:47:54] <dbaupp> zslayton: and, really, it's not that bad
[02:48:01] <acrichto> strcat: what's the use case for that kind of pointer?
[02:48:08] <strcat> aatch: can you post it to the bug?
[02:48:12] <dbaupp> zslayton: (what was the code in question?)
[02:48:14] <aatch> strcat, sure
[02:48:21] <strcat> acrichto: if you actually need to read from somewhere that you could be writing to, it might never be a valid use case
[02:48:22] <strcat> it's rarely used
[02:48:35] <strcat> I doubt there's a single appropriate use case in the rust codebase
[02:48:48] <zslayton> dbaupp: I was looking at stats.rs in libextra, which has a comment saying "We should make this more generic instead of just for f64" (paraphrased)
[02:48:58] <acrichto> strcat: is there anything known that's preventing it from being removed?
[02:48:58] <zslayton> dbaupp: So I was toying with that as a first project
[02:49:36] <strcat> acrichto: I think we should move dynamic borrows of @mut from the language to the library before removing it
[02:49:37] <zslayton> dbaupp: I looked to strconv.rs for examples and noticed line 121's FIXME
[02:49:43] <strcat> because it means more stuff will be freezing it
[02:49:51] <zslayton> dbaupp: Which looks to replace a macro impl with a generic trait impl
[02:49:55] <strcat> I think it was mostly used to work around @mut borrows
[02:50:13] <dbaupp> zslayton: I see...
[02:50:16] <strcat> really hard to reason about right now.
[02:50:24] <strcat> well
[02:50:30] <strcat> it depends on how much &const is used.
[02:50:38] <acrichto> strcat: oh I guess that there's no perf penalty if you take &const from @mut as opposed to taking a &
[02:50:46] <strcat> acrichto: there's less of one
[02:50:51] <strcat> acrichto: yeah
[02:51:00] <strcat> since & freezes it, &const doesn't have to
[02:51:08] <dbaupp> zslayton: yeah, I'm not sure it's actually possible to do the replacement
[02:51:16] <strcat> acrichto: *but* it means we can't have a moving gc for @mut
[02:51:21] <strcat> acrichto: & and &mut pin the @mut
[02:51:24] <dbaupp> zslayton: (for the coherence reason.)
[02:51:33] *** Quits: peripatetic (Mibbit@moz-B5928FE2.hsd1.wa.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[02:51:56] <zslayton> dbaupp: Good to know. I'll try to move forward with a macro impl then.
[02:52:05] <acrichto> strcat: but if there were no &const we could have a moving gc?
[02:52:17] <strcat> acrichto: for @mut
[02:52:24] <dcolish> are there any crates which currently build external dependencies with rustpkg?
[02:52:25] <strcat> not for @, without adding dynamic pinning stuff
[02:52:39] <strcat> acrichto: since @mut already tracks borrows
[02:52:44] <dbaupp> zslayton: in any case, it'd be awesome if Stats could become StatsIterator, impl'd as `impl <F: Real, I: Iterator<F>> StatIterator for I { ... }`
[02:52:51] <acrichto> strcat: but you can still take & and &mut to pass around all over the place?
[02:53:06] <strcat> acrichto: but the @mut knows about whether it's borrowed form
[02:53:08] <strcat> always
[02:53:19] <dbaupp> zslayton: (this would preferably use an "online" algorithm for as much as possible)
[02:53:24] <acrichto> strcat: but how would you find what to rewrite?
[02:53:40] <strcat> acrichto: git grep '&const' ?
[02:53:43] <strcat> there's not much
[02:54:01] <strcat> heh lots of false positives
[02:54:05] <zslayton> dbaupp: Noted! I'll look around at other Iterator trait implementations (I hope those exist!) and see what I can do.
[02:54:10] <acrichto> strcat: no as in a moving gc rewrites pointers, but it'd have to rewrite & and &mut and even if @mut knows it's borrowed how do you know what to rewrite in memory/regs?
[02:54:19] <strcat> acrichto: no it just treats it as pinned
[02:54:22] <strcat> if it's borrowed from
[02:54:40] <strcat> 99% of the time they shouldn't be pinned
[02:54:46] <acrichto> strcat: as in it doesn't actually move everything, just most things?
[02:54:58] <strcat> acrichto: it moves everything that's not borrowed from
[02:55:16] <acrichto> strcat: but how does that work b/c then you don't get the benefits of compaction?
[02:55:26] *** Quits: joelteon (joel@moz-317E8D0C.io) (Ping timeout)
[02:55:35] <strcat> acrichto: it can still compact it
[02:55:41] <strcat> most of them are not going to be borrowed from
[02:55:50] *** Quits: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP) (Ping timeout)
[02:56:01] <acrichto> you still have to keep track of holes because it's not guaranteed that everything was compacted
[02:56:09] <acrichto> the heap you're moving out of might still have stuff lying around
[02:56:19] <dbaupp> zslayton: (hm, actually Real could probably weakened to `Signed + Ord` if we forgo .std_dev and just leave .var... not sure if that's a good idea)
[02:56:25] <strcat> acrichto: it already has to know about everything in the heap
[02:56:42] <dbaupp> zslayton: in any case, weakening Real to `Algebraic + Signed + Ord` should work
[02:56:45] <strcat> afaik
[02:57:01] <dcolish> ah i figured it out, you cannot import rustpkg otherwise that linker error happens
[02:57:09] <strcat> acrichto: anyway probably doesn't matter
[02:57:10] <acrichto> strcat: but isn't the whole point of compaction that eventually you'll come back to use the original heap you moved out of, but if you can't guarantee that it's empty you can't actually get a malloc which is basically increment a pointer
[02:57:18] <dbaupp> dcolish: file a bug? :)
[02:57:28] <steven_is_false> If a thread uses the read method of the RWARC over the write method it is faster right?
[02:57:50] <strcat> acrichto: if you can move *everything* sure
[02:57:53] <aatch> steven_is_false, what do you mean?
[02:57:57] <strcat> but I think there are still benefits of moving some things
[02:58:03] <strcat> anyway @/@mut are never going to be fast
[02:58:10] <strcat> especially @mut because of dynamic borrows
[02:58:10] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[02:58:11] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/RB_W6Q
[02:58:11] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[02:58:15] <steven_is_false> aatch: THere are two methods write, and read. But read is redundant. I'm guessing read is faster.
[02:58:25] <acrichto> strcat: yeah, well thanks for the info :)
[02:58:28] <dcolish> dbaupp: no doubt, just need to figure out the process for that
[02:58:32] <strcat> I just hope we don't keep crippling the rest of the language because of them... like having the headers on ~ ;\
[02:58:33] <aatch> steven_is_false, no, one does a reader lock, the other is a writer lock
[02:58:56] <steven_is_false> aatch: I don't follow.
[02:58:58] <dbaupp> dcolish: https://github.com/mozilla/rust/issues/new :)
[02:59:08] <zslayton> dbaupp: I'll see if I can get A+S+O to work this week. I'm still picking up the syntax, so I'm making plenty of dumb mistakes.
[02:59:16] <aatch> steven_is_false, you can have multiple readers at once, but if somebody tries to write, it has to wait for all the readers to be done
[02:59:21] <dcolish> dbaupp: there's not a more formal process?
[02:59:23] <dbaupp> zslayton: awesome!
[02:59:26] <aatch> And vice-versa
[02:59:27] <dbaupp> dcolish: nope
[02:59:38] <dcolish> oh sweet, well i'll get one started then
[02:59:49] <acrichto> strcat: so why would we want explicit borrowing of @mut before removing &const?
[02:59:54] <steven_is_false> So having a reader lock, and a writer lock is generally an optimization but also has effects on semantics?
[03:00:18] <strcat> acrichto: because it's a terrible language feature and we should be encouraging people to pass @mut by-value
[03:00:19] <aatch> steven_is_false, kinda. Basically it allows for non-destructive concurrent access
[03:00:33] <dbaupp> dcolish: (if you want feedback, through the link in here after you file it :) but a bug filed is better than one not filed)
[03:00:47] *** Quits: zz_kimundi (kimundi@moz-F117C49A.dip0.t-ipconnect.de) (Ping timeout)
[03:00:50] <acrichto> strcat: so that's why there should be explicit borrowing of @mut, but why does that imply &const should stay around until then?
[03:00:50] <strcat> acrichto: the point of &const is being able to write the same code for @mut-things and non-@mut things
[03:00:50] <aatch> reading memory is fine, and you can have any number reading from memory. But writing is where race conditions happen.
[03:00:52] <steven_is_false> aatch: Shouldn't there be an overwrite method dual to the read method then?
[03:01:05] <strcat> acrichto: I guess it doesn't have to
[03:01:08] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[03:01:08] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/0Ywngw
[03:01:08] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[03:01:11] <acrichto> strcat: but if it's discouraged from being used anyway...
[03:01:11] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[03:01:11] <ghrust> 01[13rust01] 15bors pushed 6 new commits to 06auto: 02http://git.io/vf9WYg
[03:01:11] <ghrust> 13rust/06auto 14c65eb1a 15Daniel Micay: remove old_iter...
[03:01:11] <ghrust> 13rust/06auto 14e0edb1f 15Corey Richardson: Fix/annotate a variety of xfails
[03:01:11] <ghrust> 13rust/06auto 1460afd83 15Daniel Micay: xfail test again for now (issue #7336)
[03:01:13] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[03:01:17] <steven_is_false> overwrite : fn (&self, &fn() -> T)
[03:01:38] <aatch> steven_is_false, RWARC is more about locking than anything else
[03:01:47] <steven_is_false> Or maybe fn overwrite <U> (&self, &fn() -> (T, U)) -> U?
[03:02:13] <aatch> steven_is_false, how would that differ from a write lock?
[03:02:20] <steven_is_false> If a thread completely overwrites a value without depending on the previous one then there can be optimizations right?
[03:02:41] <aatch> steven_is_false, not really.
[03:03:00] <steven_is_false> Couldn't any write only lock be aborted when someone else tries to grab it?
[03:03:11] <aatch> You can't "abort" a lock
[03:03:12] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[03:03:17] <strcat> acrichto: &const still might be useful in some cases I guess
[03:03:22] <aatch> if you have a lock, you have a lock until you release it.
[03:03:26] <steven_is_false> aatch: Right, it'd be called something else.
[03:03:27] <strcat> I just think it'd be bad to remove it before really figuring out if we need it anywhere
[03:03:43] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz)
[03:03:51] <acrichto> strcat: I think I'll see how much usage I can remove obviously and see what happens, maybe not remove the whole thing entirely just yet
[03:03:58] <strcat> acrichto: maybe we should lint it off
[03:04:10] <roo> is there any way to declare lifetimes for anonymous function types?
[03:04:13] *** Joins: zz_kimundi (kimundi@moz-9E8229F3.dip0.t-ipconnect.de)
[03:04:14] <acrichto> oh that's a good idea
[03:04:38] *** zz_kimundi is now known as kimundi
[03:04:38] <roo> or rather, in them
[03:04:50] <steven_is_false> aatch: Here's a use case for a overwrite function.
[03:05:08] <steven_is_false> aatch: I have a buffer of RenderCommands to send to my render thread.
[03:05:33] <steven_is_false> I overwrite the RenderCommands each time I update my state.
[03:05:42] <steven_is_false> * From the simulator thread.
[03:06:02] <steven_is_false> While the render thread continuously reads from the RenderCommands buffer.
[03:06:40] <aatch> steven_is_false, ok, but if there is a thread that is reading RenderCommands while you are overwriting it, it can end up with an inconsistent view of the memory.
[03:07:08] <steven_is_false> aatch: Well, that's why it's wrapped up in a RWARC abstraction.
[03:07:53] <aatch> But what use is an overwrite method? It'd just be a laughably thin wrapper over write()
[03:08:10] <aatch> there's no optimizations you can make for that case because it's all about the locks
[03:08:52] <aatch> You need the write lock before you do anything, even read.
[03:09:03] <aatch> (if you want to then write)
[03:09:48] <steven_is_false> aatch: The write lock, and the reader lock are implementation details. Maybe there's a different way of implementing it that allow for optimizations in this case?
[03:10:20] <aatch> steven_is_false, there really aren't. Short of transactional memory.
[03:10:34] <steven_is_false> Of course, burden of proof would be on me to show an alternative way of doing things.
[03:10:48] <steven_is_false> I just thought someone here might have a few ideas.
[03:11:04] *** Joins: joelteon (joel@moz-317E8D0C.io)
[03:11:16] <aatch> steven_is_false, writing is writing, it doesn't make a difference if you read first or not.
[03:11:24] <aatch> since the issue isn't the reading at all.
[03:11:26] *** Joins: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP)
[03:12:15] <steven_is_false> aatch: What about using a double buffer?
[03:12:37] <steven_is_false> aatch: The value can be written to one buffer while the other is read.
[03:13:00] <steven_is_false> Although nvm multiple guys can read from one buffer at once.
[03:13:35] <bblum> hell yes
[03:13:40] <bblum> finally got my stuff in the tree
[03:14:04] <steven_is_false> aatch: How could overwrite be optimized for STM?
[03:14:09] <aatch> steven_is_false, well you could use double-buffering if you used an UnsafeAtomicRC, then you could actual avoid locks altogether.
[03:15:15] <steven_is_false> okay.
[03:15:28] <steven_is_false> I'm going to take a break to think a bit now.
[03:15:39] <aatch> Yeah, between a reference count and an atomic pointer swap, you could use double-buffing for it.
[03:16:17] <steven_is_false> bblum: Cool, what was it?
[03:16:50] <zslayton> I'd like to define a trait with a single function which takes a vector of primitives and returns a primitive of the same type. e.g. (pub trait MyTrait{ fn some_func(&[f64]) -> f64;} but not specific to f64). Is there some way to express that?
[03:16:55] <aatch> steven_is_false, https://github.com/mozilla/rust/pull/7314
[03:17:12] <bblum> steven_is_false: trait bounds and kind-checking of closure bounds
[03:18:47] <dbaupp> zslayton: do you want the primitive to depend on the exact trait impl, or should some_func be able to take any primitive for every impl of that trait?
[03:18:52] <steven_is_false> zslayton: It sounds like you'd want some sort of Primitive trait.
[03:19:22] <dbaupp> zslayton: `fn some_func<F: My + Traits>(&[F]) -> F` for the second case
[03:20:01] <dbaupp> zslayton: (`Float` is the trait for floating point primitives, btw.)
[03:21:43] <zslayton> dbaupp: That's perfect, thanks.
[03:22:36] <zslayton> dbaupp: If the function is a method, how do I assign that type signature to the "self" param?
[03:22:46] <zslayton> dbaupp: All the examples featuring self tend to leave it unadorned with types
[03:23:02] <dbaupp> zslayton: oh, that comes from the impls themselves
[03:24:02] <dbaupp> something like `trait MyTrait<F> { fn some_func(&self) -> F; } impl<'self, F: Float> MyTrait<F> for &'self [F] { fn some_func(&self) -> F { ... } }`
[03:25:11] <aatch> bblum, when your commit gets through the master tests, I'll make a new snapshot.
[03:25:19] <zslayton> dbaupp: Shew, I'm glad I asked. I wouldn't have put that together easily. I didn't know traits could be parameterized. Thanks!
[03:25:21] <dbaupp> zslayton: (in an trait, self has type `Self` which is whatever is on the right of the `for`.)
[03:25:35] <zslayton> dbaupp: (Also useful, thank you)
[03:25:53] <acrichto> strcat: it looks like &const is useless b/c &mut can be implicitly converted to &, but *const is still somewhat useful because an implementation on * won't be implemented for *mut
[03:26:11] <strcat> acrichto: you can have both &mut and &const though
[03:26:20] <dbaupp> zslayton: although, actually writing `Self` is only legal in `trait .. { ... }`, you have to write the full concrete type in an `impl`.
[03:26:24] <strcat> and you can cast *mut as * (it should be implicit)
[03:26:44] <dbaupp> zslayton: e.g `trait New { fn new() -> Self; } impl New for uint { fn new() -> uint { 0 } }`
[03:27:20] *** Quits: Sorella (queen@B12A78F5.BA14766C.95C8B7C6.IP) (Quit: (quit))
[03:27:27] <acrichto> strcat: yes but &const can easily be removed and everything still works
[03:27:41] <acrichto> strcat: as in you don't lose an expressiveness
[03:28:16] <strcat> acrichto: well with &const you can have a reference to a and also &mut a.b
[03:28:34] <strcat> ofc with & you could just take an & ref to each other field
[03:28:38] <acrichto> strcat: in theory, but it looks like no one does that in rustc
[03:28:50] <strcat> acrichto: yeah that's what I meant earlier
[03:28:51] *** Joins: int3_ (int3_@moz-C0E38A24.dsl.static.sonic.net)
[03:29:01] <strcat> I doubt any code currently uses &const for anything useful
[03:29:05] <strcat> it's an extreme edge case
[03:29:10] <dbaupp> strcat: it looks like windows is doing that unresolved `std::...` thing again :(
[03:29:13] <acrichto> I think I'll remove as much usage as I can, and maybe create a lint attribute
[03:30:47] *** Quits: int3_ (int3_@moz-C0E38A24.dsl.static.sonic.net) (Ping timeout)
[03:31:01] *** Quits: RMF (RMF@moz-2DCE560B.dsl.telepac.pt) (Quit: Textual IRC Client: www.textualapp.com)
[03:34:24] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[03:34:25] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14f8fdb34 to 14ac4211e: 02http://git.io/N3iJvQ
[03:34:25] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[03:34:27] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[03:34:28] <ghrust> 01[13rust01] 15bors pushed 6 new commits to 06auto: 02http://git.io/rVLc6w
[03:34:28] <ghrust> 13rust/06auto 14c65eb1a 15Daniel Micay: remove old_iter...
[03:34:28] <ghrust> 13rust/06auto 14e0edb1f 15Corey Richardson: Fix/annotate a variety of xfails
[03:34:28] <ghrust> 13rust/06auto 1460afd83 15Daniel Micay: xfail test again for now (issue #7336)
[03:34:29] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[03:34:53] <strcat> stupid windows
[03:37:20] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[03:39:43] *** Joins: vk (chatzilla@moz-389FEE13.hsd1.ca.comcast.net)
[03:40:35] <steven_is_false> The Container trait isn't usable for concurrent data structures (a pointer must be returned.)
[03:41:30] *** Joins: victorporof (victorporo@70DEDDA.9004F55.9B1E38F4.IP)
[03:43:04] *** Quits: heftig (heftig@moz-9C5216F6.dip0.t-ipconnect.de) (Ping timeout)
[03:43:19] <steven_is_false> So I made my concurrent hash map, and I'm wondering, is there any use for it in particular?
[03:43:37] *** Quits: victorporof (victorporo@70DEDDA.9004F55.9B1E38F4.IP) (Ping timeout)
[03:43:57] <strcat> is there any speed benefit to something like that? seems like context switching is going to be more expensive than hashing
[03:44:35] <steven_is_false> strcat: It's faster than RWARC<HashMap> (if it's done right.)
[03:45:09] <steven_is_false> But I guess a lot of time the overhead, and extra complexity probable wouldn't be worth it.
[03:45:43] * aatch should get around to implementing some general lock-free data structures.
[03:46:47] <steven_is_false> aatch: Well it's not surprizing that they haven't been implemented yet. There's not much need for them in a compiler.
[03:47:06] <steven_is_false> It is surprizing that Servo hasn't driven the development of them though.
[03:47:13] *** Quits: zslayton (Mibbit@moz-14AA87A9.nyc.res.rr.com) (Quit: http://www.mibbit.com ajax IRC Client)
[03:47:25] *** Joins: heftig (heftig@moz-603B6D4A.dip0.t-ipconnect.de)
[03:47:28] <aatch> steven_is_false, true. Also, we only recently got the required support. Previously they were a hassle to deal with.
[03:48:11] <steven_is_false> aatch: How so?
[03:49:01] <aatch> you had to directly call the intrinsics on a pointer.
[03:49:27] <aatch> Also, it wasn't that long ago we get support for atomic load and store!
[03:49:42] <steven_is_false> aatch: Wasn't there still RWARCs?
[03:50:15] <aatch> steven_is_false, yes, but they only use a compare-and-swap
[03:51:03] <steven_is_false> aatch: Right but can't one use tricks to reduce the chance of locks interfering with one another (partitioning a hash map into multiple smaller ones for example?)
[03:51:35] <aatch> steven_is_false, sure, but I haven't even /looked/ at Servo.
[03:51:44] <steven_is_false> aatch: Fair enough.
[03:52:16] *** Quits: dbaupp (Thunderbir@moz-73E90475.lns20.syd6.internode.on.net) (Ping timeout)
[03:52:35] <aatch> Also, with those datastructures being so hard to get right, I imagine that somebody working on Servo isn't really interested in taking all that time out.
[03:53:46] <aatch> lock-free/wait-free datastructures are used more in a "we need more speed", and even then, they aren't always faster than locking.
[03:55:45] <steven_is_false> Yes the simplest approach is often the best.
[03:55:46] <steven_is_false>  
[03:56:26] <aatch> they are also often more memory hungry, or at least less kind to it. Since you can't really use locking on anything bigger than 1 word (there is a double-word copy-and-swap on some archs), you end up with far more indirection.
[03:56:28] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[03:56:36] <aatch> I mean atomics, not locking
[03:57:08] <steven_is_false> aatch: Even just purely using locking there are still interesting datastructures to create.
[03:57:34] <steven_is_false> As well, creating new threads also allows one to optimize things.
[03:57:49] <aatch> steven_is_false, oh yes. I'm just explaining that robust lock-and-wait free datastructures are exceedingly difficult to get right.
[03:58:18] <steven_is_false> Fair enough
[03:58:31] <aatch> memory management is especially complex, though at least Rust makes it somewhat easier to handle compared to C.
[03:58:45] *** Quits: roo (jesse.rudo@moz-1669C300.dynamic.ip.windstream.net) (Ping timeout)
[03:59:45] <steven_is_false> What's a good benchmark for concurrent hashmaps?
[03:59:48] *** Joins: roo (jesse.rudo@moz-BA462CB7.ip.windstream.net)
[04:00:03] <aatch> steven_is_false, whats your intended access pattern look like?
[04:00:05] <steven_is_false> I need to know if my implementation is actually fast, or not.
[04:00:55] <aatch> since for a locking structure, lock contention is normally the killer
[04:01:09] <steven_is_false> aatch: I'll make some benchmarks for that then.
[04:01:13] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[04:01:13] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 142aa4c6a to 14ac4211e: 02http://git.io/N3iJvQ
[04:01:13] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[04:01:16] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[04:01:16] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/UE9Igw
[04:01:16] <ghrust> 13rust/06auto 141a27f6e 15Alex Crichton: Rename all files with the 'rc' extension
[04:01:16] <ghrust> 13rust/06auto 14d20f573 15Alex Crichton: Add the `warnings` lint attribute
[04:01:16] <ghrust> 13rust/06auto 14b2427c7 15Alex Crichton: Deny common lints by default for lib{std,extra}
[04:01:18] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[04:02:02] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[04:06:10] <strcat> nooo
[04:10:34] *** Joins: Sodel_the_V (user@moz-853663E1.va.shawcable.net)
[04:11:18] *** Quits: heftig (heftig@moz-603B6D4A.dip0.t-ipconnect.de) (Ping timeout)
[04:13:31] <steven_is_false> So the following version of my hashmap code, http://pastebin.mozilla.org/2557266 , gives 8885 dangling allocations when benchmarking. Can anyone help me figure out where they are coming from?
[04:14:21] <strcat> acrichto: some unused warnings on win32
[04:14:25] <acrichto> strcat: argh
[04:14:28] <strcat> from cfg'ed off stuff
[04:16:14] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[04:16:14] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 149b93327 to 14ac4211e: 02http://git.io/N3iJvQ
[04:16:14] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[04:16:58] *** Joins: dualhbridge (dad@moz-9FEE6D3B.maine.res.rr.com)
[04:17:25] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[04:17:26] <ghrust> 01[13rust01] 15Aatch fast-forwarded 06snap-stage3 from 146759ce4 to 14f827561: 02http://git.io/bfAoVw
[04:17:26] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[04:17:32] <acrichto> strcat: r? https://github.com/mozilla/rust/pull/7113
[04:17:50] <strcat> r+
[04:17:54] <acrichto> woo thanks
[04:18:36] <aatch> Hopefully this snapshot won
[04:18:44] <aatch> 't take 10 hours of babysitting.
[04:19:42] <aatch> Oh crap.
[04:19:52] * strcat wants no_drop_flag finished ;p
[04:20:23] <aatch> Both the linux slaves for snap-stage3 are offline...
[04:20:42] <strcat> :[
[04:20:50] <strcat> aatch: just wait
[04:20:53] <strcat> aatch: it might spin up a bot?
[04:21:00] <aatch> I don't think so.
[04:21:29] *** Joins: heftig (heftig@moz-603B6D4A.dip0.t-ipconnect.de)
[04:22:11] <aatch> since the linux-snap-stage3 builders are only on those two builders.
[04:22:38] <aatch> It's the same thing that stops linux builds running on windows machines.
[04:22:56] <strcat> ah
[04:23:17] <steven_is_false> The following benchmark tests the following number of threads writing to the hashmap at the same time. http://pastebin.mozilla.org/2557299
[04:23:28] <steven_is_false> Are these good results?
[04:23:46] <strcat> don't know
[04:24:27] <strcat> how fast is that compared to RWARC?
[04:24:39] *** Joins: brson (brson@72B1AFF8.AD1E507F.3688B332.IP)
[04:24:39] *** ChanServ sets mode: +o brson
[04:24:44] <steven_is_false> strcat: I'll check
[04:24:48] <aatch> Ah brson!
[04:25:25] <aatch> I'm trying to do a snapshot, but the two linux slaves for it are offline...
[04:25:44] <aatch> brson, anything you might be able to do about it?
[04:26:27] <steven_is_false> This was the result of RWARC http://pastebin.mozilla.org/2557300
[04:27:00] <brson> aatch: I don't think I can do anything from here, no.
[04:27:50] <aatch> brson, dammit... Oh well...
[04:33:47] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[04:42:00] *** Joins: victorporof (victorporo@70DEDDA.9004F55.9B1E38F4.IP)
[04:44:07] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Client exited)
[04:44:14] *** Quits: victorporof (victorporo@70DEDDA.9004F55.9B1E38F4.IP) (Ping timeout)
[04:47:17] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[04:47:49] <aatch> Well we now have a new BSD snapshot...
[04:48:04] <aatch> -.-
[04:49:11] *** Quits: lucian (lucian@moz-22A14C6A.cable.virginmedia.com) (Ping timeout)
[04:49:25] * strcat hates this error
[04:49:33] <strcat> error: internal compiler error: ty::Region#subst(): Reference to self region when given substs with no self region: substs(self_r=None, self_ty=None, tps=[char])
[04:49:36] <strcat> nooo
[04:52:08] <steven_is_false> Is there a version of iter for extra::test::BenchHarness that lets one setup, and tear things down outside of the timer?
[04:53:14] <aatch> steven_is_false, that's what you do... setup before iter and tear down after.
[04:53:18] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[04:53:31] <steven_is_false> aatch: Right but I need to setup, and teardown inside of iter.
[04:54:30] <steven_is_false> do b.iter_foo |bench| { let x = expensive_create(); do bench { etc...
[04:54:41] *** Quits: Sodel_the_V (user@moz-853663E1.va.shawcable.net) (Quit: Eaten by a grue)
[04:54:53] <steven_is_false> I can't drag expensive_create outside of iter because x is consumed inside the benchmark
[04:59:14] <strcat> oh well narrowed it down
[04:59:55] <strcat> I can write collect with FromIterator
[04:59:57] <dcolish> ok finally got rust-http-client to build with rustpkg but its basically circumventing all the build in stuff because it has an external dependency on http_parser https://gist.github.com/dcolish/5847806
[04:59:59] <strcat> I just can't use it in certain places
[05:00:01] <strcat> we'll see...
[05:00:03] <dcolish> seems a little gross
[05:01:50] <aatch> strcat, I think I'm starting to narrow down where we get stuff wrong.
[05:02:04] <strcat> aatch: \o/
[05:02:25] <aatch> I figure that it's because of the undef that appears.
[05:04:06] <strcat> if only I could see the place rustc was actually dying...
[05:04:08] <strcat> as in line
[05:05:09] *** Parts: steven_is_false (user@moz-144077DE.bchsia.telus.net) (ERC Version 5.3 (IRC client for Emacs))
[05:05:56] *** Joins: pyrac (pyrac@moz-9180E00E.w86-201.abo.wanadoo.fr)
[05:06:00] <aatch> Well, that undef is the result of the SROA pass.
[05:06:13] <strcat> aatch: but we must be doing something wrong then
[05:06:15] <strcat> clang uses SROA
[05:06:32] <aatch> strcat, it's perfectly valid, it's definately undefined.
[05:06:49] <strcat> as in the optimization is valid?
[05:06:56] <aatch> strcat, yep.
[05:06:59] <aatch> I'll explain
[05:10:10] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[05:10:10] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/OQRCXA
[05:10:11] <ghrust> 13rust/06auto 141a27f6e 15Alex Crichton: Rename all files with the 'rc' extension
[05:10:11] <ghrust> 13rust/06auto 14d20f573 15Alex Crichton: Add the `warnings` lint attribute
[05:10:11] <ghrust> 13rust/06auto 14c47d57f 15Alex Crichton: Deny common lints by default for lib{std,extra}
[05:10:13] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[05:10:23] <aatch> We alloca a box, with an i8 in it, we get a pointer to that i8, cast that pointer (i8*) to an i64***, we then follow that down all the way down to the i64, store to it, then do the return stuff.
[05:10:24] <strcat> dammit
[05:11:24] <aatch> So we allocate, on the stack, a box, which is undefined, we then go through 3 levels of indirection, each of which is an undef pointer, and do stuff with it.
[05:11:51] <aatch> The only defined value is the pointer to the i8 at the end of the box.
[05:11:53] <strcat> wonderful ;p
[05:12:09] <aatch> which, when we load from it, is back to being undefined.
[05:12:11] <strcat> how do we end up with seemingly working code in some cases again? ;p
[05:12:40] <aatch> In this case, that i64 is the captured variable from the environment.
[05:12:55] <aatch> I'm reading this about 2/3rds of the way into the pipeline.
[05:13:10] <aatch> so I'm not exactly sure how it relates to the original code.
[05:13:46] <aatch> Basically, the optimizations result in a store to NULL, so LLVM just emits a trap
[05:14:11] <aatch> which is deliberately an invalid instruction.
[05:14:35] <aatch> I'm guessing that the 0x20000000 align is just a poison value.
[05:15:09] *** Quits: roo (jesse.rudo@moz-BA462CB7.ip.windstream.net) (Ping timeout)
[05:15:33] *** Joins: roo (jesse.rudo@moz-87409356.dynamic.ip.windstream.net)
[05:15:41] <aatch> More accurately, its a store of `undef` to null, not a store of some value, which probably makes a difference.
[05:16:39] <aatch> I'm gonna put the before and after on the issue
[05:27:31] <aatch> strcat: https://github.com/mozilla/rust/issues/7336#issuecomment-19889643
[05:29:28] <strcat> aatch: when you finish this one I have more! :P
[05:29:36] <strcat> 7 more, to be precise ;[
[05:29:41] <aatch> ugh
[05:29:45] * strcat doesn't feel like reporting them since they could be the same issue
[05:29:54] <aatch> I'm pretty sure we're just missing a store somewhere.
[05:30:23] <aatch> it's just the "somewhere" that's hard to find.
[05:30:41] <aatch> I'm so glad I'm using ArchLinux.
[05:31:57] <strcat> the end of std::iter
[05:32:01] <strcat> will become extra::iter
[05:32:11] <strcat> and then it can be kicked out of the stdlib some day...
[05:34:08] <aatch> Ok, so that box is the environment.
[05:37:18] <aatch> Yep, we have an indirection that shouldn't be there.
[05:37:36] <aatch> I think so anyway.
[05:39:11] *** Quits: xLII (xLII@4BED3CB3.F5F53E8A.2D6DB75E.IP) (Ping timeout)
[05:39:50] *** Quits: cowboyd (cowboyd@moz-DD0FF83.lightspeed.austtx.sbcglobal.net) (Client exited)
[05:40:18] <strcat> hm
[05:40:21] <strcat> brson: you around?
[05:41:42] <aatch> strcat, you got a smaller example?
[05:41:46] <brson> strcat: maybe
[05:41:46] <strcat> aatch: no
[05:42:04] <strcat> brson: any idea why a pretty print test for a run-pass module would fail? what is it actually comparing against?
[05:42:09] <aatch> More accurately, one that doesn't have a closure that takes a closure that returns a closure
[05:42:13] <brson> is --disable-optimize still the right thing to do for development? I usually turn optimizations on to build a fast compiler
[05:42:14] <strcat> http://buildbot.rust-lang.org/builders/auto-linux-64-opt/builds/85/steps/test/logs/stdio
[05:42:28] *** Joins: victorporof (victorporo@70DEDDA.9004F55.9B1E38F4.IP)
[05:42:29] <aatch> brson, unless you're only doing stage1, no
[05:42:42] <strcat> the 'expected' one has an extra space and no newline at the end
[05:42:52] <strcat> but I don't see where the expected one comes from for a run-pass test
[05:43:02] <aatch> the produced compiler is slower enough to wipe out the gains from not optimizing the later stages
[05:43:08] *** Quits: Luqman (laden@moz-DCEF6040.csclub.uwaterloo.ca) (Ping timeout)
[05:43:09] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[05:43:09] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14c222f4a to 14ac4211e: 02http://git.io/N3iJvQ
[05:43:09] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[05:43:13] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[05:43:13] <ghrust> 01[13rust01] 15bors pushed 5 new commits to 06auto: 02http://git.io/VpypMA
[05:43:13] <ghrust> 13rust/06auto 14c5400a8 15Palmer Cox: Create a crypto submodule and move the SHA-1 implementation into it.
[05:43:13] <ghrust> 13rust/06auto 14e1b8c67 15Palmer Cox: Improve the SHA-1 implementation...
[05:43:13] <ghrust> 13rust/06auto 1489eef0b 15Palmer Cox: Create a Digest trait for common methods on digests and convert the SHA-1 implementation to use it....
[05:43:16] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[05:44:18] <aatch> Which is why it's not uncommon for auto-linux-64-opt-vg to beat auto-linux-64-nopt 
[05:44:29] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[05:44:37] *** Quits: victorporof (victorporo@70DEDDA.9004F55.9B1E38F4.IP) (Ping timeout)
[05:44:37] <strcat> aatch: I'll give you some more examples in a sec
[05:44:42] <strcat> but they may be different bugs :(
[05:44:48] <strcat> they involve closures too
[05:44:50] <brson> aatch: it's testing that repeated pretty-printing produces identical results after 2 steps or so
[05:45:06] <aatch> do they give the same error message?
[05:45:15] <strcat> brson: using --opt-level=1 instead of -O might be worth it
[05:45:20] <strcat> brson: ah
[05:45:43] <strcat> brson: I just need to xfail it, this test was xfailed before
[05:45:52] <strcat> cmr un-xfailed it and I cherry-picked his commit
[05:45:58] <strcat> xfail-pretty works, right?
[05:46:03] <brson> strcat: yes
[05:48:14] <strcat> aatch: https://github.com/thestinger/rust/commit/3ab5ec4b7c854290ad1bc5192c70cbc0856a5fa7 added this commit - r? (I'll just add your r+ at the end again)
[05:49:59] <aatch> Looks fine to me
[05:50:16] * strcat hopes it all goes fine next time
[05:50:34] <strcat> un-xfailing the tests only actually worked on 2/3 of them ;p, since they are platform-specific issues...
[05:51:29] <strcat> anyway the last thing keeping std::iter in libstd is the Times trait.
[05:51:37] *** Quits: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca) (Connection reset by peer)
[05:51:39] *** Quits: H4199 (chatzilla@moz-64E556D3.austin.res.rr.com) (Ping timeout)
[05:52:31] <aatch> hah, LLVM can't inline the closure during the inline pass.
[05:52:43] <aatch> Or atleast, not without more information
[05:53:17] <strcat> aatch: I'm curious whether it can with llvm.invariant on it
[05:53:20] <strcat> on the code ptr
[05:53:41] <strcat> not that it's the most important thing atm ;p
[05:53:54] <aatch> strcat, probably. I mean, it gets it after doing some other passes that happen before inlining
[05:53:56] *** Joins: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net)
[05:54:03] <strcat> ah
[05:55:18] *** Joins: themgt (themgt@moz-453E9466.phlapa.fios.verizon.net)
[05:55:18] *** Quits: themgt (themgt@moz-453E9466.phlapa.fios.verizon.net) (Client exited)
[05:55:46] <strcat> error: internal compiler error: ty::Region#subst(): Reference to self region when given substs with no self region: substs(self_r=None, self_ty=None, tps=[char])
[05:55:48] <strcat> nooooooo
[05:55:57] <strcat> it didn't happen in stage0 ;\
[05:56:14] <strcat> ah it's from the default method I bet
[05:56:28] <aatch> heh, it reduces the function pointer call down as part of SROA
[05:56:46] <aatch> Then it can inline it.
[05:58:53] <aatch> Hmm, seems to think that the store to the variable is dead (I replaced it with 543210)
[05:59:37] *** Quits: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Ping timeout)
[05:59:40] <acrichto> r? https://github.com/mozilla/rust/pull/7113 it go so close last time!
[06:01:11] <strcat> aatch: another default method bug
[06:01:27] *** Quits: tav (tav@moz-5ED3AF3C.range86-152.btcentralplus.com) (Quit: tav)
[06:01:32] <aatch> strcat, yeah... there are a lot of them...
[06:01:41] <strcat> acrichto: looks like it's not updated yet?
[06:02:09] <acrichto> strcat: whoops, should be updated now
[06:02:16] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz)
[06:02:29] <strcat> acrichto: r+
[06:02:37] <acrichto> strcat: thanks again :)
[06:03:39] *** Quits: roo (jesse.rudo@moz-87409356.dynamic.ip.windstream.net) (Ping timeout)
[06:04:36] <acrichto> strcat: can you comment out the import of FromIterator in your latest commit as well? it should be an unused import until that impl is uncommented
[06:04:40] *** Joins: roo (jesse.rudo@moz-D06DC201.dynamic.ip.windstream.net)
[06:05:08] <strcat> acrichto: there's another impl above actually
[06:05:09] <aatch> strcat, Getting closer: https://gist.github.com/Aatch/5847420
[06:05:18] <strcat> acrichto: I commented out the one that uses the size hint
[06:05:24] <strcat> (and removed the stage markers)
[06:05:40] <acrichto> oh yeah nvmd
[06:05:56] <aatch> there's a dead store somewhere.
[06:07:00] <strcat> curse you default methods ;p
[06:07:02] <strcat>  SO CLOSE to working
[06:07:08] <strcat> and now I get no benefit from it again :)
[06:08:03] *** Quits: igl (igl@moz-1C2169A4.adsl.alicedsl.de) (Connection reset by peer)
[06:08:51] *** Quits: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu) (Quit: Leaving)
[06:12:49] *** Quits: doomlord_ (walter@moz-6651F8D4.range86-145.btcentralplus.com) (Ping timeout)
[06:12:58] *** Joins: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[06:13:08] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[06:13:11] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[06:13:35] *** Quits: pyrac (pyrac@moz-9180E00E.w86-201.abo.wanadoo.fr) (Quit: pyrac)
[06:13:43] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[06:16:24] *** Quits: bytbox (s@moz-D83E9B31.wireless.umd.edu) (Ping timeout)
[06:16:57] *** Joins: pyrac (pyrac@moz-9180E00E.w86-201.abo.wanadoo.fr)
[06:17:09] *** Joins: xLII (xLII@4BED3CB3.F5F53E8A.2D6DB75E.IP)
[06:19:28] *** Joins: Luqman (laden@moz-DCEF6040.csclub.uwaterloo.ca)
[06:20:52] <aatch> strcat, ok, so I'm pretty sure there is a store missing somewhere.
[06:21:06] <aatch> Or atleast something is off
[06:22:53] *** Quits: roo (jesse.rudo@moz-D06DC201.dynamic.ip.windstream.net) (Ping timeout)
[06:23:34] *** Joins: roo (jesse.rudo@moz-D06DC201.dynamic.ip.windstream.net)
[06:23:42] *** Joins: sankha93 (Instantbir@E1095B37.93C78442.8B6C1D65.IP)
[06:24:12] *** Joins: xazax_hun (Mibbit@6655692F.3B222813.3F580572.IP)
[06:25:31] *** Joins: roo_ (jesse.rudo@moz-562050E5.dynamic.ip.windstream.net)
[06:26:09] *** Quits: roo (jesse.rudo@moz-D06DC201.dynamic.ip.windstream.net) (Ping timeout)
[06:26:50] *** roo_ is now known as roo
[06:27:33] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[06:32:34] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[06:33:07] *** Joins: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net)
[06:33:14] *** Quits: pyrac (pyrac@moz-9180E00E.w86-201.abo.wanadoo.fr) (Quit: pyrac)
[06:34:24] *** Joins: fabiand (fabiand@moz-A2365E79.adsl.alicedsl.de)
[06:34:50] <aatch> Dear god, so many opaque boxes!
[06:37:33] *** Joins: ramige (ramige@moz-28AD658E.dynamic.ip.windstream.net)
[06:39:22] *** Joins: pyrac (pyrac@moz-9180E00E.w86-201.abo.wanadoo.fr)
[06:39:24] *** Quits: pyrac (pyrac@moz-9180E00E.w86-201.abo.wanadoo.fr) (Quit: pyrac)
[06:41:14] *** Quits: brson (brson@72B1AFF8.AD1E507F.3688B332.IP) (Quit: leaving)
[06:42:18] *** Quits: devbug (quassel@moz-E1DE087C.bchsia.telus.net) (Broken pipe)
[06:43:01] *** Joins: victorporof (victorporo@70DEDDA.9004F55.9B1E38F4.IP)
[06:44:03] *** Quits: sankha93 (Instantbir@E1095B37.93C78442.8B6C1D65.IP) (Ping timeout)
[06:44:46] *** Quits: roo (jesse.rudo@moz-562050E5.dynamic.ip.windstream.net) (Ping timeout)
[06:45:05] *** Quits: victorporof (victorporo@70DEDDA.9004F55.9B1E38F4.IP) (Ping timeout)
[06:45:36] *** Joins: roo (jesse.rudo@moz-1C159FA9.dynamic.ip.windstream.net)
[06:46:04] *** Quits: xLII (xLII@4BED3CB3.F5F53E8A.2D6DB75E.IP) (Ping timeout)
[06:48:58] *** Joins: sankha93 (Instantbir@E1095B37.93C78442.8B6C1D65.IP)
[06:49:05] *** Quits: roo (jesse.rudo@moz-1C159FA9.dynamic.ip.windstream.net) (Ping timeout)
[06:49:26] *** Joins: roo (jesse.rudo@moz-90EC2844.dynamic.ip.windstream.net)
[06:52:13] *** Joins: victorporof (victorporo@70DEDDA.9004F55.9B1E38F4.IP)
[06:53:51] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzz)
[06:56:34] <aatch> Looks like there's some weirdness around inlining.
[06:58:55] <bjz_> is there a function for converting a null-terminated C array into a vector?
[06:59:10] <bjz_> I can only see ones that use lengths
[06:59:15] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[06:59:34] <aatch> now, it wouldn't be too hard to roll your own though.
[06:59:37] <aatch> no*
[07:00:06] <bjz_> seems like something that should be in there
[07:00:15] <bjz_> was just asking before I did
[07:00:26] *** Quits: roo (jesse.rudo@moz-90EC2844.dynamic.ip.windstream.net) (Ping timeout)
[07:00:47] *** Joins: roo (jesse.rudo@moz-C156F8C.dynamic.ip.windstream.net)
[07:01:06] *** Joins: xLII (xLII@4B24E74C.8EF580C8.6B1291C6.IP)
[07:02:58] *** Joins: jaen (jaen@4A42275B.6A94545C.43DC2829.IP)
[07:05:23] <aatch> strcat, Ok, so I have another piece of the puzzle.
[07:07:41] *** Quits: roo (jesse.rudo@moz-C156F8C.dynamic.ip.windstream.net) (Ping timeout)
[07:07:46] <bjz_> what is the puzzle you folks have been working on?
[07:07:56] <bjz_> been only vaguely following
[07:08:32] <aatch> the lifetimes llvm inserts means that a call to the actual function behind the closure is passed a value that is end-of-life
[07:08:55] *** Joins: roo (jesse.rudo@moz-D8B09D93.dynamic.ip.windstream.net)
[07:08:56] <aatch> so everything related to it is killed as a dead store
[07:09:09] <aatch> bjz_, https://github.com/mozilla/rust/issues/7336
[07:12:49] *** Quits: xLII (xLII@4B24E74C.8EF580C8.6B1291C6.IP) (Ping timeout)
[07:17:50] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[07:19:59] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[07:24:24] *** Joins: xLII (xLII@4BED3CB3.F5F53E8A.2D6DB75E.IP)
[07:25:01] *** Quits: roo (jesse.rudo@moz-D8B09D93.dynamic.ip.windstream.net) (Ping timeout)
[07:25:17] *** Joins: roo (jesse.rudo@moz-C26F0D0E.dynamic.ip.windstream.net)
[07:27:44] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[07:30:51] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[07:31:58] *** Quits: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net) (Quit: tikue)
[07:31:59] *** Quits: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Quit: zzz)
[07:33:51] *** Joins: illissius (illissius@moz-19397A63.catv.broadband.hu)
[07:34:30] *** Parts: roo (jesse.rudo@moz-C26F0D0E.dynamic.ip.windstream.net) ()
[07:35:43] *** Joins: threecreepio (jdp@moz-F2D425CF.business.telia.com)
[07:36:38] *** Joins: Sodel_the_V (user@moz-853663E1.va.shawcable.net)
[07:40:05] *** Joins: pyrac (pyrac@EDE6BD92.73C89388.AD05C589.IP)
[07:43:01] *** Quits: jaen (jaen@4A42275B.6A94545C.43DC2829.IP) (Ping timeout)
[07:43:08] *** Quits: lucian (lucian@moz-22A14C6A.cable.virginmedia.com) (Input/output error)
[07:48:21] *** Joins: JDT (Mibbit@moz-B994FA9E.cs.st-andrews.ac.uk)
[07:52:16] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[07:52:16] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/VpypMA
[07:52:16] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[07:53:37] <hoelzro> do I have to 'use' a trait to be able to call its methods on an impl?
[07:53:55] <aatch> hoelzro, yes
[07:54:03] <hoelzro> ah, I see
[07:54:16] * hoelzro thought he had found a bug
[07:55:11] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[07:55:11] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/F9m0Ag
[07:55:11] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[07:55:14] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[07:55:14] <ghrust> 01[13rust01] 15bors pushed 9 new commits to 06auto: 02http://git.io/rm8u1A
[07:55:14] <ghrust> 13rust/06auto 14e2e3923 15Daniel Micay: remove old_iter...
[07:55:15] <ghrust> 13rust/06auto 14adb8ac4 15Corey Richardson: Fix/annotate a variety of xfails
[07:55:15] <ghrust> 13rust/06auto 14369b0a5 15Daniel Micay: xfail tests again for now (issues #7336, #7340)
[07:55:16] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[08:01:07] *** Quits: pyrac (pyrac@EDE6BD92.73C89388.AD05C589.IP) (Quit: pyrac)
[08:03:46] *** Quits: ramige (ramige@moz-28AD658E.dynamic.ip.windstream.net) (Quit: Leaving)
[08:04:10] *** Joins: berak (chatzilla@ADA67576.4742BCFA.1A5CC7E5.IP)
[08:04:11] *** Joins: devbug (quassel@moz-E1DE087C.bchsia.telus.net)
[08:04:45] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Ping timeout)
[08:05:31] *** Parts: berak (chatzilla@ADA67576.4742BCFA.1A5CC7E5.IP) ()
[08:05:35] *** Joins: Blub\w (wry@moz-364C7E2.wireless.dyn.drei.com)
[08:07:21] *** Joins: pnkfelix1 (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net)
[08:08:19] *** Joins: pyrac (pyrac@EDE6BD92.73C89388.AD05C589.IP)
[08:10:40] *** Joins: jpochyla (jpochyla@E1DB45DB.1AFA5C43.5DC06702.IP)
[08:12:23] *** Joins: dbaupp (Thunderbir@moz-73E90475.lns20.syd6.internode.on.net)
[08:17:28] *** Quits: Blub\w (wry@moz-364C7E2.wireless.dyn.drei.com) (Ping timeout)
[08:18:20] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[08:18:34] *** Joins: jaen (jaen@4A42275B.6A94545C.43DC2829.IP)
[08:22:01] *** Joins: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[08:22:22] *** Quits: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP) (Input/output error)
[08:22:22] *** Joins: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[08:24:39] *** Joins: CarpNet (ac@moz-FD24B77.sohonet.co.uk)
[08:32:46] *** Quits: jpochyla (jpochyla@E1DB45DB.1AFA5C43.5DC06702.IP) (Ping timeout)
[08:34:07] *** Joins: Blub\w (wry@moz-74348AEB.wireless.dyn.drei.com)
[08:34:36] *** Quits: Diamond (dick@moz-C01E1CD1.ks.ks.cox.net) (Client exited)
[08:35:12] *** Quits: devbug (quassel@moz-E1DE087C.bchsia.telus.net) (Client exited)
[08:35:40] *** Quits: xLII (xLII@4BED3CB3.F5F53E8A.2D6DB75E.IP) (Ping timeout)
[08:38:14] *** Quits: sankha93 (Instantbir@E1095B37.93C78442.8B6C1D65.IP) (Quit: Instantbird 1.4 -- http://www.instantbird.com)
[08:39:37] *** Joins: sankha93 (Instantbir@E1095B37.93C78442.8B6C1D65.IP)
[08:40:23] *** Quits: threecreepio (jdp@moz-F2D425CF.business.telia.com) (Connection reset by peer)
[08:40:51] *** Joins: threecreepio (jdp@moz-F2D425CF.business.telia.com)
[08:44:23] *** Joins: jpochyla (jpochyla@E1DB45DB.1AFA5C43.5DC06702.IP)
[08:44:28] *** Joins: doener (doener@moz-121949B3.unitymediagroup.de)
[08:44:58] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[08:47:57] *** Joins: EXetoC (ex@moz-2DBEB1E4.customer.t3.se)
[08:49:11] <aatch> strcat, I put more info on the issue.
[08:49:22] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[08:49:49] *** Quits: JDT (Mibbit@moz-B994FA9E.cs.st-andrews.ac.uk) (Quit: http://www.mibbit.com ajax IRC Client)
[08:50:20] <aatch> I've pretty much run out of ideas though
[08:51:21] *** Joins: cr (anonymous@moz-23291665.dip0.t-ipconnect.de)
[08:52:46] *** Joins: xLII (xLII@4BED3CB3.F5F53E8A.2D6DB75E.IP)
[08:52:56] *** Joins: roo (jesse.rudo@moz-367344B6.dynamic.ip.windstream.net)
[08:58:33] *** Joins: mhi (mhi@moz-4814EA55.sanctioned.net)
[08:59:53] *** Quits: roo (jesse.rudo@moz-367344B6.dynamic.ip.windstream.net) (Ping timeout)
[09:00:15] *** Joins: roo (jesse.rudo@moz-307E4F6.dynamic.ip.windstream.net)
[09:03:10] *** Quits: xazax_hun (Mibbit@6655692F.3B222813.3F580572.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[09:03:26] *** Joins: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com)
[09:06:38] <doomlord> how do i cast a constant zero as a parameterized type - i tried fn foo<T>(..) { if x >   (0 as T) ... }  - error message "non-scalar cas: `<VI0>` as `'a`"
[09:07:05] *** Joins: Diamond (dick@moz-C01E1CD1.ks.ks.cox.net)
[09:08:56] <roo> yeah I do not think casting is that general. Only between numeric types, and from pointer types to raw pointers/numeric I think.
[09:08:58] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[09:09:38] *** Quits: jaen (jaen@4A42275B.6A94545C.43DC2829.IP) (Ping timeout)
[09:10:34] *** Parts: mhi (mhi@moz-4814EA55.sanctioned.net) ()
[09:10:38] <dbaupp> doomlord: you need to use the Zero trait, `fn foo<T: Zero + Ord(...) { if x > Zero::zero() ... }
[09:11:00] <dbaupp> err, `fn foo<T: Zero + Ord>(...) ...`
[09:11:38] *** Quits: roo (jesse.rudo@moz-307E4F6.dynamic.ip.windstream.net) (Ping timeout)
[09:12:16] *** Joins: roo (jesse.rudo@moz-E459660A.dynamic.ip.windstream.net)
[09:13:10] *** Joins: jaen (jaen@4A42275B.6A94545C.43DC2829.IP)
[09:14:06] <roo> doomlord: you probably want to constrain your generic type to ord, like fn foo<T: Ord>(..,t: T) { if x > T ... }
[09:14:59] <doomlord> thanks
[09:16:00] <roo> though that probably wont work if x is an int or something. Generally you would only compare two members of the same type with >
[09:16:04] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Client exited)
[09:16:36] <doomlord> right they are the same type
[09:17:04] *** Quits: pyrac (pyrac@EDE6BD92.73C89388.AD05C589.IP) (Quit: pyrac)
[09:18:59] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[09:20:20] *** Joins: MaikKlein (maik@moz-1DE1C7D5.dip0.t-ipconnect.de)
[09:20:56] *** Joins: BitPuffin (quassel@moz-49828767.cust.tele2.se)
[09:23:43] <doomlord> fn repeated<T:Ord,Zero>(count:T, myfunc:&fn(x:T)->T){
[09:23:43] <doomlord> 	let mut i:T=count;
[09:23:43] <doomlord> 	while i>(0 as T) { myfunc(i); i-=(1 as T)}
[09:23:43] <doomlord> }
[09:24:30] <doomlord> "error non scalar cast cannot caastVI0 as 'a' ...
[09:24:44] <dbaupp> doomlord: you need to use Zero::zero()
[09:24:58] <doomlord> ahhh. makes sense,ok
[09:25:52] <doomlord> yikes is that in some module i need to bring in
[09:26:09] <dbaupp> you also need the One and Sub traits, but you can just replace these with `Num`, i.e. `fn repeated<T: Num + Ord>(count: T, ...) {}`
[09:26:37] <dbaupp> rusti: let x: uint = std::num::Zero::zero(); x
[09:26:39] -rusti- 0
[09:27:27] <doomlord> i haven't updated, i must..
[09:28:17] <dbaupp> well, core::num::Zero
[09:29:40] <doomlord> its not finding stuff, but i haven't got a new version for a while and I'm aware the numeric traits have had a big rework
[09:30:19] <dbaupp> what's the error message?
[09:31:26] <doomlord> rustc 0.6 (6dd20c8 2013-03-30 15:42:43 -0700)
[09:31:26] <doomlord>  << for reference
[09:32:10] <doomlord> the error is :test.rs:36:18: 36:22 error: use of undeclared type name `Zero`
[09:32:10] <doomlord> test.rs:36 fn repeated<T:Ord+Zero+One+Sub>(count:T, myfunc:&fn(x:T)->T){
[09:32:26] *** Joins: marijn (user@moz-577CFCBA.dip0.t-ipconnect.de)
[09:32:35] <dbaupp> well, did you import them?
[09:32:47] *** Joins: spider-mario (spidermari@moz-B8FA2FF4.rev.sfr.net)
[09:33:03] <dbaupp> `use {core,std}::num::{Zero,One};`
[09:33:23] <dbaupp> (choose whichever of core/std is the appropriate one.)
[09:34:12] <dbaupp> in any case, yes, you should update
[09:35:03] <doomlord> ok i wasn't doing the 'use' .. its still complaining, but update first..
[09:35:24] *** Quits: MaikKlein (maik@moz-1DE1C7D5.dip0.t-ipconnect.de) (Ping timeout)
[09:36:13] <doomlord> should this work - use core::num::*;
[09:36:26] <dbaupp> yes
[09:36:42] <dbaupp> (is it the same error message?)
[09:37:02] <doomlord> lost it.. i'll update and  get back to this
[09:37:11] *** Joins: Earnestly (earnest@87814665.5364A5FA.922AD825.IP)
[09:38:14] <marijn> how does implementation (impl) visibility currently work? do you still have to import them? is there any kind of ambiguity resolution?
[09:38:44] <cmr> marijn: there is no ambiguity resolution unfortunately
[09:39:07] <cmr> you don't have to import impls though, and visisbility modifiers on impls was removed
[09:39:08] *** Quits: BitPuffin (quassel@moz-49828767.cust.tele2.se) (Ping timeout)
[09:39:19] <marijn> so they are global, in effect?
[09:39:43] <cmr> yup
[09:39:48] <cmr> there's an issue open about it
[09:39:53] <cmr> it is causing lots of problems
[09:40:51] <marijn> interesting. i'll try to find the issue
[09:41:19] *** Joins: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP)
[09:41:31] *** Quits: xLII (xLII@4BED3CB3.F5F53E8A.2D6DB75E.IP) (Ping timeout)
[09:42:00] <dbaupp> marijn: #5898 I think is the one cmr is referring to
[09:42:54] <dbaupp> (the impls are only in scope when the corresponding trait is in scope, I think, so they aren't quite global.)
[09:43:25] <marijn> thanks. reading.
[09:44:15] <cmr> strcat: it's really weird that a test failed :S
[09:44:29] <cmr> strcat: I made sure they all passed, that was the point of the PR
[09:44:30] <strcat> cmr: one? ;p
[09:44:51] <strcat> cmr: 2 failed from not working on 32-bit, 2 failed from issues I had to open about buggy codegen
[09:45:06] <strcat> and we found a pretty printer bug (didn't converge)
[09:45:25] *** Joins: Blei (Philipp@moz-9C19FD1.ethz.ch)
[09:45:27] <strcat> cmr: https://github.com/mozilla/rust/pull/7334 look at the follow up ones
[09:45:38] <strcat> oh and ofc stupid windows was windows
[09:45:40] * strcat cries
[09:45:43] <strcat> about to land though
[09:46:01] <strcat> anyway, 4 bugs were found
[09:46:03] <strcat> good times.
[09:47:32] <cmr> sorry about that then :)
[09:48:09] <strcat> cmr: it's fine ;p
[09:48:50] <cmr> At least they have issues open about them now
[09:49:10] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[09:50:10] <strcat> not the pretty printer one
[09:50:13] <strcat> can't be bothered
[09:50:26] <cmr> I don't really understand the point of the pretty printer tests tbh
[09:50:29] *** Quits: roo (jesse.rudo@moz-E459660A.dynamic.ip.windstream.net) (Ping timeout)
[09:50:34] <cmr> Most of them are xfailed and nobody cares
[09:53:49] *** Joins: roo (jesse.rudo@moz-B7BE0BEB.dynamic.ip.windstream.net)
[09:54:12] *** Quits: anri (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net) (Ping timeout)
[09:55:48] <doomlord> are virtuals the reason C++ *doesn't* get tagged unions (preference on the language designers' part for extensible frameworks)
[09:55:56] *** Joins: anri (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net)
[09:56:16] <strcat> doomlord: boost::variant
[09:56:20] <strcat> planned to land in a standard
[09:57:02] *** Joins: artagnon (uid7560@moz-A588D045.irccloud.com)
[09:57:07] *** Parts: artagnon (uid7560@moz-A588D045.irccloud.com) ()
[09:57:19] <doomlord> i tend to distinguish talk about language capabilities from standard library 
[09:57:38] <strcat> doomlord: C++ doesn't have containers without the library either
[09:57:49] <monk> initial reaction to boost::variant was "AWESOME", then I tried it and experienced the errors if you get your static visitor slightly wrong /o\
[09:57:54] <doomlord> yes but if it didn't have them... you could write them
[09:57:59] <strcat> the whole philosophy of C++ *now* is that almost everything should be a library feature
[09:58:06] <doomlord> the langauge has everything needed to write the containers
[09:58:19] <strcat> and the language has everything needed to write a tagged union type
[09:58:31] <doomlord> as elegantly as in rust?
[09:58:41] <strcat> it doesn't have pattern matching
[09:58:44] <strcat> built-in
[09:58:49] *** Joins: nano (nano@moz-972880B.superkabel.de)
[09:59:04] <strcat> can still do it if you don't mind writing visitor metadata for each type
[09:59:11] *** Joins: mw (mw@moz-A9E8FEAA.adsl.highway.telekom.at)
[09:59:32] <strcat> it has tagged unions as much as it has hash tables
[09:59:37] <doomlord> tahts what i mean :)
[09:59:53] <doomlord> rust has language support, c++ .. you can sort of emulate them
[09:59:55] *** Joins: obk (Mibbit@5832C6FA.C88E081E.27150B55.IP)
[10:00:01] <strcat> not emulate
[10:00:04] <strcat> C++ has tagged unions
[10:00:09] <strcat> there's no emulation or hacks
[10:00:28] <strcat> you can implement them in templates - which are strictly more powerful than rust's type system
[10:00:39] <illissius> way, way more powerful :)
[10:01:07] <strcat> http://en.cppreference.com/w/cpp/types/aligned_union this silly thing is implemented as a fold over size/align + alignas
[10:01:13] <strcat> using templates
[10:01:23] <doomlord> but with rusts' tagged unions, you can declare it all in one place. as far as i can see, the language support is helpful
[10:01:42] <strcat> boost::variant<int, std::string, double> v;
[10:01:44] <strcat> v = 5.5;
[10:02:00] *** Quits: cr (anonymous@moz-23291665.dip0.t-ipconnect.de) (Quit: cr)
[10:02:01] <strcat> or you can roll them manually
[10:02:25] <strcat> like anything in C++ they're verbose and have unsafe holes lurking....
[10:02:27] <doomlord> enum Shape { Circle{x:int,y:int,r:int}, Rectangle{x0:int,y0:int,x1:int,y1:int} } >>> c++ equiv?
[10:02:49] <doomlord> right thats the thing. "roll manually", or emualte it with templates..
[10:02:56] <strcat> not "emulate"
[10:02:56] <doomlord> .. i understand you can get the same binary layout...
[10:03:08] <strcat> are rust's hash tables "emulated" because we implemented them as a library type?
[10:03:09] <doomlord> what word should i be using inplace of emulate
[10:03:17] <strcat> implement
[10:03:32] <strcat> rust can't implement ADTs in the type system - they have to be written into the compiler
[10:03:43] <obk> I'm getting a compilation error trying to build rust on SUSE SLES11 with GCC 4.8.0: https://gist.github.com/anonymous/5849030 - any ideas?
[10:03:44] <strcat> is it a good thing that they are? yes - they are elegant, and we have great syntax/support for pattern matching
[10:03:52] <strcat> but unlike C++, we *can't* implement them as a library feature
[10:03:54] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[10:03:59] <doomlord> so i should say... "rust implements tagged unions in the compiler. C++ allows the user to manually implemnet tagged unions"
[10:04:13] <strcat> or the stdlib
[10:04:34] <illissius> is boost::variant really a tagged union? does boost::variant<int, int> make sense?
[10:04:41] *** Parts: marijn (user@moz-577CFCBA.dip0.t-ipconnect.de) (ERC Version 5.3 (IRC client for Emacs))
[10:04:53] <strcat> illissius: no, but there's another boost type that can do that
[10:04:59] <cmr> obk: I succesfully build with gcc 4.8.1... try building the master branch instead of 0.6
[10:05:00] <strcat> illissius: variant isn't really a full sum type
[10:05:07] <illissius> yeah that's what I meant
[10:05:08] <illissius> ok
[10:05:13] <strcat> making a real sum type needs C++11
[10:05:28] <obk> cmr: Thanks, will try
[10:05:36] <strcat> and 99% of boost is C++98 with a few C++11 features poorly strapped on ;p
[10:05:45] <illissius> well
[10:05:59] <doomlord> tuples are another thing. so, you can "implement" tuples in C++ with templates. but Rust has actual tuples as a languaeg feature, it can use them more elegantly, IMO
[10:06:25] <illissius> make an *efficient* real sum type needs C++11, but instead of unrestricted unions you can just use void* and allocate on the heap in C++03, no?
[10:06:30] <illissius> *making
[10:06:41] <strcat> illissius: or hardcode specific cases
[10:06:43] <doomlord> i dont think of Rust (or similar) tuples in the same way as tuple<foo,bar,baz> ...
[10:07:09] <strcat> illissius: C++11 adds alignas
[10:07:23] <strcat> and you need that to allocate the storage without compiler-specific hacks (like boost::variant uses)
[10:07:32] <illissius> oh, alignment. >_>
[10:07:36] <doomlord> interesting point raised, can you get at metadata of the tagged unions in rust
[10:07:39] <monk> doomlord: I think it's easier to generalise over tuples in C++ though
[10:07:45] <illissius> yeah
[10:07:47] <strcat> illissius: alignment is the main thing they need to hack around :)
[10:07:54] <strcat> before C++11
[10:07:57] <illissius> C++ lets you implement things like deriving as a library too :)
[10:08:00] <cmr> doomlord: no, and the ABI of enums is explicitly undefined
[10:08:07] <illissius> just abstract over all tuples/tagged unions with variadic templates
[10:08:34] <strcat> illissius: and their visitor thing is really a hack since there were no lambdas + variadic templates to use
[10:08:36] <Blei> what is this? can't gdb catch assertions on windows?
[10:08:49] <strcat> Blei: failure isn't implemented on windows
[10:08:56] <doomlord> now you're giving me cold feet.. "templates are way more powerful than rusts' type system" .. :)
[10:09:00] <Blei> it's an assertion in llvm
[10:09:07] <strcat> Blei: oh, catch abort then
[10:09:17] <Blei> strcat: will try, thanks
[10:09:27] <doomlord> but rust is safer/more elegant for what it does 
[10:09:47] <cmr> doomlord: well, they are. but we also have macros and syntax extensions :)
[10:09:56] <illissius> you can implement a lot of the expressiveness of Rust as a C++ library (though match is a hard one)
[10:10:01] <illissius> but you can't implement the safety
[10:10:23] <strcat> can't implement the safety without making a restricted subset of C++ enforced by a compiler at least, with something like rust's borrowck, etc.
[10:10:28] <strcat> and then you've implemented rust ;p
[10:10:29] <obk> A question about casts in rust. I need a heterogenous data structure (configuration key/value store). Basically I can "put a value of some type a at some string key" and "get value of type a from some string key". The type a may be different for different keys. If this were C++, I'd use dynamic_cast to make it safe. What's the rust equivalent?
[10:11:02] <doomlord> .. and if you;re going to implement a compiler,might aswell clean up the syntax while you're at it ..
[10:11:05] <illissius> strcat: unless you also add lifetimes it'll be less expressive :p
[10:11:06] <strcat> obk: are all the types known?
[10:11:07] <doomlord> yes, make rust
[10:11:23] <strcat> obk: as in do you know all the possible types in advance
[10:11:28] <strcat> or is it dynamic
[10:11:46] <obk> strcat: Ideally no, but let's assume so for a second
[10:12:01] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[10:12:15] *** Quits: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Client exited)
[10:12:16] <strcat> rusti: enum Value { String(~str), Number(f64), Array(~[Value]) }; let x = Array(~[Number(5.5), String(~"foo")]); x
[10:12:22] -rusti- timeout triggered!
[10:12:26] <strcat> rusti: enum Value { String(~str), Number(f64), Array(~[Value]) }; let x = Array(~[Number(5.5), String(~"foo")]); x
[10:12:27] -rusti- Array(~[Number(5.5), String(~"foo")])
[10:12:40] <strcat> enums are tagged unions, so you can just list out the possible types
[10:12:44] <strcat> and pattern match out
[10:12:51] *** Joins: xLII (xLII@4BED3CB3.F5F53E8A.2D6DB75E.IP)
[10:13:21] <obk> Ok, but what if I didn't know the list of types in advanced (the real case)?
[10:13:22] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[10:13:24] <strcat> if you *don't* know all the types, you can cast to a trait object (as in ~Ord, &Ord or @Ord), which has a vtable (can't get the type back out though)
[10:13:41] <obk> I don't follow (rust newbie here).
[10:13:52] <strcat> obk: do you know about traits yet?
[10:13:56] <obk> I don't have a common trait for the values.
[10:14:05] <obk> It could be "anything"
[10:14:21] <strcat> obk: we don't have anything like a dynamic Any type yet
[10:14:27] <obk> Ah
[10:14:32] <cmr> there's not really any way to safely implement that is there?
[10:14:41] <strcat> cmr: with more reflection support, you could
[10:14:46] <obk> Not without a runtime penalty...
[10:14:59] <strcat> trait *objects* have a runtime penalty too
[10:15:01] <illissius> obk: if you're not afraid of unsafe { }, another way would be with a phantom type: struct Key<T>(~str);, then make sure the only way you can get a Key<T> for a given T is if it refers to a value in the store of type T. then store the actual values as void* and cast to-and-fro.. not sure what the Rust way to do that last bit is
[10:15:06] <illissius> *c_void and transmute?
[10:15:17] <strcat> he'd probably need a way to reflect on the type though
[10:15:27] *** Joins: roo_ (jesse.rudo@moz-7DF1B84E.dynamic.ip.windstream.net)
[10:15:41] <obk> There's cast::unsafe or something like that, I thought to avoid that. I suppose that could work, yes.
[10:15:44] * strcat doesn't think we have anything like type ids/tags
[10:15:45] *** Quits: roo (jesse.rudo@moz-B7BE0BEB.dynamic.ip.windstream.net) (Ping timeout)
[10:15:54] <obk> Would be pretty efficient too.
[10:16:06] <obk> And potentially "safe" if I am careful implementing it.
[10:16:07] <illissius> also not sure how to keep that from breaking if you can have more than one instance of the data structure
[10:16:08] <obk> Thanks!
[10:16:11] <illissius> maybe you couldn't?
[10:16:19] <strcat> obk: you'd have to know all the types to make it safe though
[10:16:33] <strcat> and then you could use an enum
[10:16:45] <obk> I could instantiate struct Key<T> for each new one, no?
[10:17:08] <obk> Ah, I see - I'd need to do an unsafe cast to put the key in the configuration. Yes. Unsafe.
[10:17:15] <strcat> but how do you check which type is stored?
[10:17:25] <obk> Hmmm.
[10:17:26] <strcat> need trust at some point
[10:17:30] <strcat> to add a new type into it
[10:17:31] <obk> Yes, alas.
[10:17:47] <obk> I don't suppose rust has anything like atoms/symbols/etc.
[10:17:49] <obk> :-)
[10:18:01] <obk> (Global ones, I mean)
[10:18:37] <obk> I could emulate them I guess - basically split the configuration to a multitude of configuration<T>....
[10:19:06] <strcat> well you could just restrict the types
[10:19:11] <cmr> Hm, actualy
[10:19:19] <cmr> Well, no
[10:19:22] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[10:19:22] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/rm8u1A
[10:19:22] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[10:19:31] <strcat> I mean you could invent a new object system in rust if you wanted ;p
[10:19:41] <obk> Pretty much :-)
[10:19:46] <strcat> take json + extend it to a js-like thing with @fn "methods"
[10:20:10] <illissius> obk: say you have struct HetStore { ... }; let sa = HetStore::new(); let sb = HetStore::new(); let ki: Key<int> = sa.store("foo", 5); let kc: Key<@char> = sb.store("foo", @'c');... now how do you make sure you only use ki with sa and kc with sb?
[10:20:25] <strcat> yay it merged
[10:20:27] <strcat> goodbye old_iter
[10:20:31] <strcat> std::iter, you're next.
[10:20:33] <cmr> and good ridance
[10:20:49] <cmr> We could really use a #[deprecated]
[10:21:05] <obk> Well, you'd need getInt, getString, etc.
[10:21:23] <cmr> obk: just get<T>
[10:21:27] <strcat> or match out
[10:21:29] <obk> Right, of course.
[10:21:56] <obk> Well, I got my answer... "tradeoffs, tradeoffs everywhere you look" :-)
[10:22:08] <cmr> yup
[10:22:12] * obk has to go
[10:22:13] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[10:22:13] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/l71kHA
[10:22:13] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[10:22:15] <illissius> hm
[10:22:16] <obk> Thanks for the help!
[10:22:22] *** Parts: obk (Mibbit@5832C6FA.C88E081E.27150B55.IP) ()
[10:22:27] <illissius> oh well.
[10:22:30] <strcat> aatch: still need to finish no_drop_flag ;p
[10:23:24] <illissius> (was going to say you could prevent the unsafety if you kept a pointer to the HetStore in the key and failed dynamically if you used a key with a different HetStore than the one you got it from)
[10:23:27] *** Joins: shaybba (Mibbit@moz-68873E97.range109-157.btcentralplus.com)
[10:24:06] <cmr> That doesn't really work when you want to serialize the configuration though, does it?
[10:25:11] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[10:25:11] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/l71kHA
[10:25:11] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[10:25:12] <strcat> need something like json but where you define a schema with ADTs up front ;p
[10:25:12] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[10:25:12] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/SBgFGg
[10:25:12] <ghrust> 13rust/06auto 149a5e6a3 15Luqman Aden: Change finalize -> drop.
[10:25:12] <ghrust> 13rust/06auto 14f6cb035 15bors: auto merge of #7269 : luqmana/rust/drop, r=thestinger...
[10:25:12] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[10:25:15] <illissius> oh, maybe.
[10:26:13] *** Quits: roo_ (jesse.rudo@moz-7DF1B84E.dynamic.ip.windstream.net) (Ping timeout)
[10:26:57] *** Parts: mw (mw@moz-A9E8FEAA.adsl.highway.telekom.at) ()
[10:26:58] <shaybba> quick question how to get into alpha?
[10:27:15] <strcat> into alpha?
[10:27:49] <cmr> shaybba: this isn't a channel for the Rust game, it's for the programming language
[10:27:49] *** Joins: roo (jesse.rudo@moz-7DF1B84E.dynamic.ip.windstream.net)
[10:27:56] <cmr> if that's what you're talking about
[10:28:11] <shaybba> oh sry :P
[10:28:15] *** Parts: shaybba (Mibbit@moz-68873E97.range109-157.btcentralplus.com) ()
[10:28:26] <cmr> strcat: http://www.playrust.com/
[10:28:33] *** Joins: xazax (Mibbit@6655692F.3B222813.3F580572.IP)
[10:28:45] <strcat> lol
[10:28:46] *** Joins: Ble1 (Philipp@moz-9C19FD1.ethz.ch)
[10:28:54] *** Quits: Blei (Philipp@moz-9C19FD1.ethz.ch) (Ping timeout)
[10:30:00] *** Quits: vk (chatzilla@moz-389FEE13.hsd1.ca.comcast.net) (Quit: ChatZilla 0.9.90 [Firefox 22.0/20130617145905])
[10:30:10] *** Joins: pnkfelix|rcirc (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net)
[10:30:32] <roo> why was the name rust chosen anyhow? I don't see the language as being very rust-like.
[10:30:59] *** Quits: jpochyla (jpochyla@E1DB45DB.1AFA5C43.5DC06702.IP) (Ping timeout)
[10:31:13] *** Joins: MaikKlein (maik@moz-129BB64.dip0.t-ipconnect.de)
[10:31:16] <cmr> roo: I remember reading something like it was only supposed to use existant programming language techniques and not be a research language
[10:31:21] <cmr> thus, "rust": old
[10:31:23] <illissius>  "avoid new ideas"
[10:31:33] <roo> ah, i see.
[10:31:44] *** Quits: sankha93 (Instantbir@E1095B37.93C78442.8B6C1D65.IP) (Ping timeout)
[10:31:50] *** Joins: sankha94 (Instantbir@47958A96.B1950BBF.8B6C1D65.IP)
[10:32:30] *** Quits: Ble1 (Philipp@moz-9C19FD1.ethz.ch) (Ping timeout)
[10:32:49] <xazax> anyways it is funny, new features of C++11 like lambdas/closures and new features of java was available for example in lisp in about 40 years ago xD
[10:33:20] <strcat> in a different form though
[10:33:59] <strcat> stack-based closures (without needing an executable stack/heap) are pretty awesome
[10:34:33] <xazax> yeah :D but every time when someone asks why it is named rust I can't resist thinking about this one :D
[10:36:27] *** Joins: roo_ (jesse.rudo@moz-6297C614.dynamic.ip.windstream.net)
[10:36:31] <roo_> well, I have more fp background than c++ or java so most of it isn't that new to me, but some of it is only old in a sense that it has been in quite a few research languages.
[10:36:44] *** Quits: MaikKlein (maik@moz-129BB64.dip0.t-ipconnect.de) (Ping timeout)
[10:37:02] *** Quits: roo (jesse.rudo@moz-7DF1B84E.dynamic.ip.windstream.net) (Ping timeout)
[10:41:00] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.1)
[10:41:30] *** Quits: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com) (Ping timeout)
[10:41:41] <doener> hm, why can a program run just fine with a function taking a @mut Foo, but fail with a dynamic borrow check error when the same argument is changed to &mut Foo?
[10:42:52] <illissius> right.. on the one hand old != mainstream. on the other hand "avoid new ideas" wasn't necessarily 100% successful :) (e.g. I'm not sure if borrowing / borrow checking has precedent?)
[10:43:20] <roo_> more like a big rusty spaceship that just fell out of the sky, rather than a bag of rusty hammers
[10:44:26] <illissius> doener: presumably it's being read/written through some other @mut reference while it's being loaned out as &mut?
[10:44:54] <cmr> roo_: hah, I like that one
[10:45:22] <cmr> illissius: iirc niko said in a recent meeting we were pushing the envelope on regions
[10:46:00] *** Quits: roo_ (jesse.rudo@moz-6297C614.dynamic.ip.windstream.net) (Ping timeout)
[10:46:03] *** Joins: BitPuffin (quassel@moz-49828767.cust.tele2.se)
[10:47:32] *** Quits: jaen (jaen@4A42275B.6A94545C.43DC2829.IP) (Quit: WeeChat 0.4.1)
[10:47:38] *** Joins: Blei (Philipp@moz-D88CD29.ethz.ch)
[10:47:48] <illissius> really? Rust's regions don't seem to give as fine-grained control as Disciple, though I only have a superficial understanding of the latter (somewhat-less-superficial but not necessarily "deep" of the former)
[10:48:08] <cmr> it had to do with its interaction with another feature
[10:48:14] <cmr> I'd have to look to see what the exact comment was
[10:48:44] <illissius> ah i see.
[10:49:21] <doener> illissius: I guess my question is: Why is the same course of action valid with just @mut, but invalid with &mut?
[10:49:49] *** Quits: Blei (Philipp@moz-D88CD29.ethz.ch) (Ping timeout)
[10:49:55] <illissius> doener: if you borrow an @mut as &mut, the *only* reference it's allowed to be read/written through for the lifetime of the borrow is that &mut
[10:50:10] <illissius> if there's no borrow you can read/write through any of the @mut references without conflict
[10:50:19] <doener> ok, so &mut has additional guarantees
[10:50:23] <illissius> right
[10:50:50] <illissius> &mut borrow => can't be read, written, or borrowed through any other reference
[10:51:15] <illissius> & borrow => can't be written or mut-borrowed through any reference
[10:53:41] <illissius> doener: it's a type system invariant that an &mut is always the only alias to an object that it can be mutated through, and that for as long as there's an & alias to an object, it's immutable
[10:53:52] <illissius> in the case of @mut this is enforced dynamically.
[10:57:12] <dbaupp> doener: I also think that loans of @mut are too long by default (i.e. the extend for the whole block, I think), so wrapping the call in a dummy block (just {}) might fix it
[10:57:22] <dbaupp> *they extend
[10:58:12] *** Joins: roo (jesse.rudo@moz-A7D6E46C.dynamic.ip.windstream.net)
[10:58:43] <doener> dbaupp: not in those places where I tried it ;-) The fact that nested calls aren't correctly handled is more annoying though
[10:59:19] <dbaupp> doener: ah, right :)
[10:59:30] <cmr> nested calls is the most annoying limitation of rust right now imo
[10:59:50] <dbaupp> cmr: really?
[11:00:00] *** Joins: jpochyla (jpochyla@E1DB45DB.1AFA5C43.5DC06702.IP)
[11:00:09] <doener> $ git diff HEAD^^ | grep -c 5074
[11:00:09] <doener> 79
[11:00:27] <cmr> dbaupp: yeah, it's the one I hit most often at least
[11:00:31] <dbaupp> I'd vote for #5898 being up there
[11:00:33] <doener> the FIXMEs I had to add because of it
[11:00:44] <dbaupp> (that's the one I keep hitting.)
[11:00:54] *** Quits: xLII (xLII@4BED3CB3.F5F53E8A.2D6DB75E.IP) (Ping timeout)
[11:01:07] <cmr> well that's just a bug :p
[11:01:15] <dbaupp> doener: :(
[11:01:26] <dbaupp> cmr: so are nested calls?
[11:01:57] <cmr> dbaupp: I guess. To me it's just a side-effect of the borrowck rules though
[11:02:03] <dbaupp> cmr: do you mean foo.bar(foo.baz())?
[11:02:07] <cmr> yes
[11:02:25] <dbaupp> that's definitely just a bug, if baz doesn't return a borrowed pointer
[11:02:58] *** Joins: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP)
[11:03:13] <dbaupp> (doesn't `let tmp = foo.baz(); foo.bar(tmp)` work in that case?)
[11:03:14] <doener> foo(borrowed, bar(borrowed))
[11:03:36] <cmr> dbaupp: yes
[11:03:37] <doener> has to be written as: let tmp = bar(borrowed); foo(borrowed, tmp);
[11:03:55] <dbaupp> yeah, that's definitely a bug :(
[11:04:23] *** Quits: sankha94 (Instantbir@47958A96.B1950BBF.8B6C1D65.IP) (Ping timeout)
[11:04:57] <dbaupp> (there's also `for [1,2,3].iter().advance` => `let v = [1,2,3]; for v.iter().advance`, which is annoying :/)
[11:05:52] *** Quits: jpochyla (jpochyla@E1DB45DB.1AFA5C43.5DC06702.IP) (Ping timeout)
[11:09:10] *** Joins: sankha93 (Instantbir@47958A96.B1950BBF.8B6C1D65.IP)
[11:10:01] *** Quits: roo (jesse.rudo@moz-A7D6E46C.dynamic.ip.windstream.net) (Ping timeout)
[11:13:08] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[11:13:08] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14f6cb035 to 14dfb7de8: 02http://git.io/N3iJvQ
[11:13:08] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[11:13:13] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[11:13:13] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/JESpNA
[11:13:13] <ghrust> 13rust/06auto 141841b31 15Alex Crichton: Add 'static mut' items to the language
[11:13:13] <ghrust> 13rust/06auto 148fdc8f3 15Alex Crichton: Support foreign 'static mut' variables as well
[11:13:14] <ghrust> 13rust/06auto 14771a1eb 15bors: auto merge of #7291 : alexcrichton/rust/static-mut, r=pcwalton...
[11:13:16] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[11:17:54] <bjz> ooh
[11:19:07] <thiez> there is something strange about the rust benchmarks, after running with RUST_BENCH=1 I have a program that is using 320GB of virtual memory... :p
[11:19:21] <cmr> thiez: yes the task spawning ones go berserk
[11:19:43] <cmr> has to do with stacks not being freed or somesuch
[11:19:43] <dbaupp> thiez: o_O
[11:19:51] <thiez> it is rather funny, but I imagine running on x86 might be tricky.
[11:19:58] <thiez> 354G virt and growing
[11:19:58] <thiez> :D
[11:20:00] <cmr> Mine got up to >1TB before I finally was able to kill it
[11:20:09] <cmr> (I didn't notice until I was already swapped into oblivion)
[11:20:17] <thiez> graph-500 appears to be the problem
[11:20:18] <dbaupp> https://github.com/mozilla/rust/pull/7111 right?
[11:20:27] <cmr> graph-500 shouldn't be a problem
[11:20:35] <cmr> that one runs and terminates normally
[11:20:45] <thiez> they all run normally.
[11:20:46] <cmr> dbaupp: yeah I think so
[11:21:11] <cmr> thiez: not task-perf-one-million or task-perf-linked-failure :)
[11:21:17] <cmr> at least not here
[11:21:42] <cmr> I think task-perf-spawnalot was a problem too, don't recall
[11:21:55] <thiez> cmr: you can r+ these days, yes?
[11:22:01] <cmr> yes
[11:22:21] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[11:22:32] *** Joins: jpochyla (jpochyla@E1DB45DB.1AFA5C43.5DC06702.IP)
[11:22:39] *** Joins: ramige (ramige@moz-28AD658E.dynamic.ip.windstream.net)
[11:23:15] <thiez> https://github.com/mozilla/rust/pull/7193 could you have a look? It originally removed the xfail from threadring, but I reverted that (and had to rebase)
[11:23:30] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[11:24:09] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[11:25:12] <cmr> Nevermind the comment, was in a later commit :)
[11:27:05] <thiez> I really admire people who can do 1 commit for each change, I always forget :D
[11:27:40] <dbaupp> thiez: I often `rebase -i` to merge little fixes back into their parent commit
[11:27:50] <dbaupp> (but I still don't get 1 commit for each change :( )
[11:28:20] <cmr> git commit -p is your friend!
[11:29:05] <thiez> -p?
[11:29:14] *** Joins: Blei (Philipp@moz-D88CD29.ethz.ch)
[11:29:22] <dbaupp> thiez: 'partial'
[11:29:23] <thiez> oh, patch, I'll give that a shot
[11:29:30] <dbaupp> oh, that too.
[11:29:31] <cmr> Interactively select which changes in the diff to include
[11:29:39] <thiez> that seems nice
[11:31:49] <cmr> Is an LLVM assertion considered to fall under I-ICE, I-crash, or I-wrong?
[11:33:06] <Blei> i would guess crash
[11:33:19] <dbaupp> (I would say ICE)
[11:33:30] * cmr puts it under all three
[11:33:40] <dbaupp> I'm not sure, but I have a feeling crash = runtime crash of a compiled program
[11:33:48] <cmr> that's what I thought too
[11:33:54] <cmr> and wrong being incorrect codegen
[11:33:58] <cmr> but *shrug*
[11:34:00] <thiez> dbaupp: that's what I thought, but it doesn't appear to be used that way if you filter on I-crash
[11:34:51] *** Quits: Blei (Philipp@moz-D88CD29.ethz.ch) (Ping timeout)
[11:35:30] <dbaupp> thiez: oh? just looking now, it seems that quite a lot are runtime crashes/segfaults...
[11:37:47] <thiez> there are some LLVM asserts in there too :)
[11:38:11] <dbaupp> cmr: do you happen to know how large the rust metadata in std/extra is if it's not compressed?
[11:38:14] <dbaupp> thiez: yup :)
[11:38:22] <cmr> dbaupp: Uhh iirc ~2.6MB
[11:38:26] <cmr> for std
[11:38:36] <cmr> might be 2.4
[11:38:38] <dbaupp> ok, so not too big
[11:38:44] <cmr> that's pretty huge if you ask me
[11:38:57] <dbaupp> heh
[11:39:09] <cmr> That also might be the compressed number
[11:39:13] *** Quits: heftig (heftig@moz-603B6D4A.dip0.t-ipconnect.de) (Quit: Quitting)
[11:39:41] <dbaupp> well, I was thinking of implementing an option that allowed rust to emit/read the metadata uncompressed, because that would make things like irc-rusti and play.rust-lang.org much faster
[11:39:54] <dbaupp> (well, slightly faster.)
[11:40:11] <dbaupp> and presumably a few 10's of MB of disk space doesn't really matter for them
[11:40:16] <cmr> "
[11:40:19] <cmr> I think the eventual ideal move here is to compress each item's metadata and ast separately and fix how we load metadata to only decompress the necessary items. But picking a different compressor, or different encoding, is certainly also fine.
[11:40:21] <cmr> "
[11:40:23] <cmr> IS what graydon said about it btw
[11:40:53] <dbaupp> yeah, well, presumably no compress would always be faster
[11:41:03] <dbaupp> *compression
[11:41:06] *** Quits: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com) (Ping timeout)
[11:41:07] <cmr> Anyway the switch from deflate to lz4 caused a 1MB increase in size, and given that the compression ratios were usually pretty decent, I'm thinking it was more along the lines of 6MB+
[11:41:20] <dbaupp> yeah, still pretty small, for this purpose
[11:41:24] <cmr> yeah
[11:41:50] * dbaupp puts that idea on his list of things to try
[11:42:08] <cmr> I was experimenting with xz but got bored and gave up, better wins elsewhere :)
[11:42:31] *** Joins: Blei (philipp@moz-D88CD29.ethz.ch)
[11:42:57] <dbaupp> the decompression was ~25% for small programs, right?
[11:43:31] <dbaupp> (of the time)
[11:43:36] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[11:45:05] <cmr> it's ~16% right now
[11:45:52] <dbaupp> hm
[11:46:06] * dbaupp moves it lower on the list
[11:46:08] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[11:46:08] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14771a1eb to 14dfb7de8: 02http://git.io/N3iJvQ
[11:46:08] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[11:46:09] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[11:46:09] <ghrust> 01[13rust01] 15bors pushed 8 new commits to 06auto: 02http://git.io/jIQFUA
[11:46:09] <ghrust> 13rust/06auto 14a4a8a4a 15Matthijs Hofstra: Fixed os:: and int:: not being in scope, changed io::println to println
[11:46:09] <ghrust> 13rust/06auto 143b1ace9 15Matthijs Hofstra: Updated copyright year on shootout-binarytrees.rs
[11:46:10] <cmr> Then 4.34% in ebml::reader::vuint_t and 2.38% in io::u64_from_be_bytes
[11:46:10] <ghrust> 13rust/06auto 14b306f9f 15Matthijs Hofstra: Changed shootout-chameneos-redux output to conform to the 'official' output format.
[11:46:12] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[11:47:01] <thiez> hey, how did my stuff make it to the top of bors' queue?
[11:47:07] <dbaupp> eurgh, why are we encoding the data in a non-native endianness?
[11:47:14] <doener> thiez: low PR number
[11:47:16] <dbaupp> thiez: it sorts by pull request number
[11:47:19] <cmr> dbaupp: because ebml is awful
[11:47:31] <dbaupp> cmr: why are we using ebml then? :((
[11:47:39] <thiez> ah, I expected it would sort by r+ date/time
[11:48:12] <cmr> dbaupp: no idea
[11:48:14] *** Joins: xLII (xLII@4BED3CB3.F5F53E8A.2D6DB75E.IP)
[11:48:29] <cmr> dbaupp: replacements to evaluate would probably be http://kentonv.github.io/capnproto/, http://msgpack.org/, or http://code.google.com/p/protobuf/
[11:48:36] <dbaupp> thiez: presumably it's either easier to sort by pr number, or it means that we don't get old pull requests hanging around for ages
[11:48:50] <dbaupp> cmr: yup, those are what I would've though too
[11:48:57] *** Joins: heftig (heftig@moz-603B6D4A.dip0.t-ipconnect.de)
[11:48:58] <cmr> cap'n proto being my favorite
[11:50:39] *** Quits: Sodel_the_V (user@moz-853663E1.va.shawcable.net) (Quit: Eaten by a grue)
[11:50:41] *** Quits: threecreepio (jdp@moz-F2D425CF.business.telia.com) (Quit: threecreepio)
[11:50:57] *** Joins: threecreepio (jdp@moz-F2D425CF.business.telia.com)
[11:52:20] *** Quits: BitPuffin (quassel@moz-49828767.cust.tele2.se) (Ping timeout)
[11:52:30] <illissius> that does look nice!
[11:53:14] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[11:54:52] * dbaupp wonders if cap'n proto schemas tokenise
[11:55:08] <cmr> Now you're thinking with portals :D
[11:55:22] <dbaupp> rusti: stringify!(struct MyType $foo("bar") { })
[11:55:23] -rusti- "struct MyType $ foo ( \"bar\" ) { }"
[11:55:35] <dbaupp> rusti: stringify!(# foo)
[11:55:35] -rusti- "# foo"
[11:55:42] <dbaupp> cool!
[11:55:57] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[11:56:03] * dbaupp adds writing a cap'n proto syntax extension to his todo list
[11:56:19] <dbaupp> rusti: stringify!(  myMethod(myParam :Text $baz(9)) :Void $baz(8);)
[11:56:20] -rusti- "myMethod ( myParam : Text $ baz ( 9 ) ) : Void $ baz ( 8 ) ;"
[11:56:29] <cmr> I will be very happy to see metadata rewritten... the code is pretty gnarly atm
[11:56:38] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[11:56:41] <cmr> Also happy to see the atrocity that is ebml gone
[11:56:58] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[11:57:07] <dbaupp> do you happen to know if there has to be no space in $bar (and :Void) etc?
[11:57:19] *** Joins: nano (nano@moz-972880B.superkabel.de)
[11:57:21] <cmr> no
[11:57:29] <cmr> (no I don't know)
[11:58:05] <dbaupp> hm, "Do not implement your own schema parser. The schema language is more complicated than it looks, and the algorithm to determine offsets of fields is subtle"
[11:58:29] <illissius> wonder how cap'n proto handles validation? i.e. that the data you got over the wire is actually of the type you thought it was?
[11:58:41] *** Joins: BitPuffin (quassel@moz-49828767.cust.tele2.se)
[11:58:44] <dbaupp> maybe a syntax extension that converts its argument back to a string and then throws it into the capnpc parser.
[11:59:30] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[12:03:50] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[12:03:55] *** Joins: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[12:04:10] <doener> illissius: hm, looking at http://smallcultfollowing.com/babysteps/blog/2012/11/18/imagine-never-hearing-the-phrase-aliasable/ I'm not sure I understand why &mut needs exclusive access. The given example uses an immutable borrow
[12:04:31] *** Joins: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net)
[12:05:33] <doener> on a contained element anyway, which IIRC causes an immutable borrow on the container even for mutable borrowed pointers
[12:05:50] *** Quits: sankha93 (Instantbir@47958A96.B1950BBF.8B6C1D65.IP) (Quit: Instantbird 1.4 -- http://www.instantbird.com)
[12:05:56] <illissius> doener: you mean why the "&mut is the only alias you can mutate through" invariant exists at all?
[12:06:05] <doener> yes
[12:06:13] <illissius> it's to rule out iterator invalidation and similar problems
[12:08:18] <illissius> e.g. you take out a reference to the inside of a structure (even just an enum or ~) and some other code modifies it in a way that invalidates the memory your reference is pointing to
[12:08:20] *** Quits: robn (robn@moz-76B0302C.static.internode.on.net) (Quit: Coyote finally caught me)
[12:08:26] *** Joins: robn (robn@moz-76B0302C.static.internode.on.net)
[12:08:39] *** Quits: threecreepio (jdp@moz-F2D425CF.business.telia.com) (Quit: threecreepio)
[12:08:53] <illissius> that's as relevant with (hypothetically) two &mut pointers as it is with &mut and &, because of course you can read through &mut, not just write
[12:08:55] *** Joins: threecreepio (jdp@moz-F2D425CF.business.telia.com)
[12:09:05] *** Quits: threecreepio (jdp@moz-F2D425CF.business.telia.com) (Quit: threecreepio)
[12:09:39] <doener> struct Foo { x: int }; let foo Foo { x:5 }; let a = &mut foo.x; let b = &mut foo.x;
[12:09:57] <doener> how can I invalidate "a" by writing through "b" or vice versa?
[12:10:14] <dbaupp> struct Foo { x: ~[1,2,3] }; let foo Foo { x:5 }; let a = &mut foo.x[0]; let b = &mut foo.x; *b = ~[]
[12:10:30] <dbaupp> (err, x: ~[int] and x:~[1,2,3], respectively)
[12:10:42] <illissius> doener: you can't in that case, but.. what dbaupp said
[12:10:45] <cmr> doener: (the aliasing guarantees also allow optimizations)
[12:11:03] <illissius> (which is merely icing)
[12:11:16] <doener> dbaupp: those are borrows on different things. The first borrow is on a contained element, which freezes the container, I'm fine with that.
[12:11:26] *** Joins: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net)
[12:12:18] *** Quits: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[12:12:34] <cmr> r? https://github.com/mozilla/rust/pull/7346
[12:13:11] <dbaupp> cmr: r+
[12:13:16] <dbaupp> let i = 0; let j = 0; let a = ~[~[1,2]]; let x = &mut a[i]; let z = &*x[1]; let y = &mut a[j]; *y = ~[]
[12:13:17] <cmr> thanks
[12:13:17] <dbaupp> doener: ^
[12:13:24] <indutny> hey people
[12:13:31] <indutny> question to guys aware of ty stuff
[12:13:36] <dbaupp> doener: (it's sorta complicated, but imagine rust didn't know what i and j were.)
[12:13:42] <indutny> how can I change bounds of some specific ty?
[12:13:48] <indutny> say I've newly created ty
[12:13:53] <indutny> and want to add some trait bounds to it
[12:14:06] <dbaupp> indutny: is this in user-space code, or in the compiler code?
[12:14:08] <illissius> doener: well, if you're holding an &mut to something, you can borrow an &mut to the inside of the something from it, yes? so if you have two &mut to the same thing, you can have one of them do an inner-borrow, and the other outer-mutate, and then you have problems
[12:14:14] <indutny> dbaupp: compiler code
[12:14:16] <thiez> doener: so what if we have fn firstElem<'a,T>(arr: &'a mut [T]) -> &'a mut T { arr[0] }
[12:14:22] <dbaupp> indutny: where?
[12:14:30] <indutny> oh, that's a long way
[12:14:36] <indutny> and I've almost finished the patch
[12:14:37] <indutny> I guess
[12:14:38] <illissius> and if &mut aliasing is unrestricted the compiler can't really do much to prevent it
[12:14:59] <indutny> its about picking methods from extensions
[12:15:08] <indutny> its not using bound information
[12:15:11] <dbaupp> indutny: (none of those answers where talking to you, btw.)
[12:15:12] *** Joins: cr (anonymous@8515A7D.8B38C502.16E13E53.IP)
[12:15:15] <dbaupp> *were
[12:15:25] <indutny> great
[12:15:25] <indutny> :P
[12:15:33] <dbaupp> indutny: you mean #5898?
[12:15:45] <dbaupp> https://github.com/mozilla/rust/issues/5898
[12:15:51] <dbaupp> or
[12:15:56] <indutny> yes
[12:16:04] <dbaupp> cool!
[12:16:07] * dbaupp wants that fixed
[12:16:12] <indutny> I found a place where it happens
[12:16:26] <illissius> there should be a bot that auto-pastes links.
[12:16:29] <illissius> and titles
[12:16:36] <dbaupp> what to you mean?
[12:16:51] <indutny> dbaupp: you asked me?
[12:16:56] <dbaupp> illissius: linkifying #<num> would be neat
[12:16:58] <dbaupp> indutny: yes
[12:17:13] <dbaupp> indutny: "a place where it happens" = the cause of the bug?
[12:17:18] <indutny> yes
[12:17:26] <dbaupp> oh, where?
[12:17:30] *** Quits: cr (anonymous@8515A7D.8B38C502.16E13E53.IP) (Ping timeout)
[12:18:11] <Jesse> dbaupp: rust is #1!
[12:18:11] <indutny> secret :P
[12:18:17] <indutny> I want to fix it myself
[12:18:27] <indutny> otherwise it'd be spending whole night in vain
[12:18:34] <dbaupp> indutny: I won't fix it! but I can be more help if I know what i'm looking at :)
[12:18:45] <indutny> ah
[12:18:47] <indutny> ok :)
[12:18:52] <indutny> if you promise
[12:18:52] <indutny> impl_self_ty
[12:19:01] <indutny> it just creates ty's for all trait bounds
[12:19:07] <indutny> and they're never filled
[12:19:11] <dbaupp> indutny: (are you indutny on github?)
[12:19:13] <indutny> yes
[12:19:34] <indutny> I think so
[12:19:35] <indutny> :P
[12:20:00] <bstrie> dbaupp: that doesn't prove anything, you have to ask the indutny on github if they're the same person as the indutny on irc
[12:20:17] <indutny> hahaha
[12:20:19] <indutny> gosh :P
[12:20:24] <dbaupp> indutny: there, I even "assigned" you to the bug
[12:20:25] <indutny> does it matter that much?
[12:20:32] <indutny> oh nice
[12:20:38] <indutny> is it possible when I'm not in team?
[12:20:48] <indutny> h
[12:20:51] <dbaupp> nope... I just left a comment :)
[12:20:52] <indutny> there = some internal place
[12:21:01] <indutny> nice
[12:21:02] <indutny> :)
[12:21:21] <dbaupp> anyway, ty's for the trait bounds...
[12:21:26] * dbaupp looks at the code
[12:21:46] *** Quits: xLII (xLII@4BED3CB3.F5F53E8A.2D6DB75E.IP) (Ping timeout)
[12:21:47] <indutny> yeah
[12:21:52] <indutny> I've almost figured it out
[12:21:57] <indutny> there is a code in vtable
[12:21:58] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Quit: Computer has gone to sleep.)
[12:22:03] <indutny> that performs lookup and chooses appropriate ty
[12:22:49] <indutny> ah wait
[12:23:16] <indutny> it just needs to be resolved...
[12:23:17] <indutny> probably
[12:23:29] <dbaupp> I'm guessing the problem is just the way that it just discards `ity.generics.type_param_defs`
[12:24:08] <indutny> well, yes...
[12:24:17] <indutny> they're just ending up as V3, V4...
[12:24:21] <indutny> without any bounds
[12:24:24] <indutny> but vtable somehow resolves them
[12:24:32] <indutny> probably using resolve_type_vars_in_trait_ref_if_possible
[12:26:25] <dbaupp> hm, yes
[12:26:30] <indutny> no :)
[12:26:34] <indutny> ok, I'll continue looking
[12:26:38] <indutny> sorry for spoilering it
[12:27:20] <dbaupp> I'd *guess* that you'd need to preserve the type parameter information and then iterate over all possible methods in typeck/check/method.rs
[12:27:27] <dbaupp> but I have no idea how that code works
[12:29:11] <indutny> well...
[12:29:17] <indutny> it seems that I just need to resolve those tys
[12:32:20] *** Joins: jdm (jdm@88F51059.F3BBB17D.144F44FA.IP)
[12:33:39] <dbaupp> indutny: niko wrote most of that code (nmatsakis on IRC), so you could probably ping him sometime when you're both on
[12:33:52] <indutny> great
[12:33:56] <indutny> thank you for a tip
[12:41:04] *** Joins: MaikKlein (maik@moz-129BB64.dip0.t-ipconnect.de)
[12:44:40] <cmr> What are the exact semantics of &const?
[12:44:42] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[12:45:36] <cmr> (and *const I suppose)
[12:45:41] *** Joins: nano (nano@moz-972880B.superkabel.de)
[12:46:21] <dbaupp> cmr: const means "data is read only through this reference"
[12:46:36] <dbaupp> (but can be modified by another reference)
[12:46:47] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[12:46:52] <cmr> Why is it being removed?
[12:47:06] <cmr> Or, desired to be removed.
[12:47:13] <cmr> From the language, that is.
[12:47:25] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[12:47:37] <dbaupp> fn foo(a: &mut int, b: &const int) { println(b.to_str()); *a = 2; println(b.to_str()); } let mut x = 1; foo(&mut x, &const x);
[12:47:45] <dbaupp> rusti: fn foo(a: &mut int, b: &const int) { println(b.to_str()); *a = 2; println(b.to_str()); } let mut x = 1; foo(&mut x, &const x);
[12:47:47] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/EHTM
[12:48:21] <dbaupp> rusti: fn foo(a: &mut int, b: &const int) { println(fmt!("%?", b)); *a = 2; println(fmt!("%?", b)); } let mut x = 1; foo(&mut x, &const x);
[12:48:22] -rusti- &const 1
[12:48:22] -rusti- &const 2
[12:48:22] -rusti- ()
[12:48:53] *** Joins: hansjorg (hansjorg@moz-EECB5F79.static.cust.telenor.com)
[12:48:54] <dbaupp> cmr: not sure of the exact reasoning, but I think it's essentially regarded as a hack to get around borrowck
[12:49:04] <cmr> Alright
[12:49:13] <dbaupp> (I think leave strcat or someone to review that PR, since acrichto and strcat were talking about it before.)
[12:49:15] *** Joins: nano (nano@moz-972880B.superkabel.de)
[12:49:18] *** Quits: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net) (Ping timeout)
[12:50:42] <cmr> sure
[12:50:57] <thiez> not having &const would make seperation logic very happy.
[12:51:11] *** Joins: sankha93 (Instantbir@BA7CBBCC.291909EC.8B6C1D65.IP)
[12:51:15] <cmr> it'd be nice if those two commits weren't bundled in the same PR but with cycle time being what it is..
[12:51:16] *** Quits: Earnestly (earnest@87814665.5364A5FA.922AD825.IP) (Ping timeout)
[12:52:55] <dbaupp> cmr: if you're ok with it, you could put your #2773 pr in with your other one
[12:53:20] <cmr> dbaupp: the xfails one?
[12:53:26] <cmr> dbaupp: strcat merged that one with one of his
[12:53:32] <cmr> because there were conflicts
[12:53:39] <dbaupp> https://github.com/mozilla/rust/pull/7310
[12:53:44] <cmr> Oh
[12:54:10] <cmr> Yeah sure
[12:54:21] *** Quits: Blei (philipp@moz-D88CD29.ethz.ch) (Quit: WeeChat 0.4.1)
[12:54:21] <dbaupp> the queue's getting emptier, so it's probably not that important
[12:54:37] <thiez> looks like cycle times are improving somewhat
[12:54:45] *** Parts: Lovot (root@AE31FB56.8153C3BF.F3C9A2D9.IP) (rust)
[12:54:53] *** Quits: jpochyla (jpochyla@E1DB45DB.1AFA5C43.5DC06702.IP) (Ping timeout)
[12:55:01] <cmr> According to isrustfastyet, yes
[12:55:57] <dbaupp> (that is just a subset of the builds)
[12:55:58] <dbaupp> sec
[12:56:25] <thiez> dbaupp: so in reality it's slower?
[12:56:55] <dbaupp> thiez: yeah, i think that's just the fastest builds, in fact
[12:56:58] <cmr> it's better than what it was when it was ridiculous, ie ~4-6 hours
[12:58:31] <thiez> it still seems like a bad sign to see people trying to combine multiple PRs just to speed it up
[13:00:47] <dbaupp> thiez: well, in theory a commit is the unit of change, especially when it is a single line deletion
[13:03:12] <thiez> if that's the case perhaps we should do some statistics. if the chance of a random PR getting rejected is below 50% then it makes sense to always pull two PRs at once and test them both, then if that fails test them separately
[13:03:30] <thiez> no wait, it should be below 33%?
[13:03:57] <cmr> I don't think changes like that to the system are desirable
[13:04:03] <cmr> what we have now is simple and works very well
[13:04:09] <cmr> rustc just has awful performance
[13:04:14] *** Joins: Blei (Philipp@moz-D88CD29.ethz.ch)
[13:04:31] <cmr> cycle times would be lower, but to fend off master breakage we need to test everything we can
[13:04:50] <dbaupp> thiez: brendanc has ideas about octopus merges/tests
[13:04:59] *** Joins: xLII (xLII@4BED3CB3.F5F53E8A.2D6DB75E.IP)
[13:05:44] <thiez> cmr: everything would still get tested, it would just be faster in the average case, especially when we run tidy/pretty first
[13:06:12] * dbaupp thinks it's silly that tidy only runs after 15 minutes of building
[13:06:18] <cmr> agree about that
[13:06:37] <thiez> perhaps we should have a separate buildbot that ONLY runs tidy, and runs it on every PR, even those without r+
[13:07:05] <cmr> that would be nice actually, and would avoid reviewers having to check formatting
[13:07:10] <thiez> of course in an ideal world we would all do a full make check before committing ;)
[13:07:31] <cmr> would help especially for new contributors
[13:07:47] *** Joins: Earnestly (earnest@87814665.5364A5FA.922AD825.IP)
[13:07:57] <dbaupp> we could have several buildbots roaming over the PRs and testing them preemptively
[13:08:13] <dbaupp> so an r+ could be an automatic merge in some cases
[13:08:33] *** Quits: Blei (Philipp@moz-D88CD29.ethz.ch) (Ping timeout)
[13:08:42] <dbaupp> http://huonw.github.io/isrustfastyet/all.html btw
[13:08:43] <cmr> mmm. even just doing a stage0 build on all the archs would be a good litmus test
[13:08:45] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[13:09:13] <cmr> no valgrind etc
[13:09:20] <cmr> Or --parse-only
[13:09:32] <dbaupp> how often do PRs not parse??
[13:09:33] <cmr> now that I think about it make tidy should do --parse-only if it doesn't already
[13:09:48] *** Joins: Blei (Philipp@moz-92058B1D.ethz.ch)
[13:09:56] <thiez> yeah I think dbaupp is correct here... :p
[13:10:01] <cmr> dbaupp: don't think I've seen one, but it only takes a few seconds to run
[13:10:12] <thiez> that happens rarely, and even if it happens it will only take a few seconds with the current system
[13:10:18] *** Quits: hansjorg (hansjorg@moz-EECB5F79.static.cust.telenor.com) (Quit: Leaving.)
[13:10:29] <dbaupp> cmr: make tidy just runs etc/tidy.py
[13:10:49] <cmr> Blei: green-squiggle is very nice ^_^
[13:11:06] <Blei> cmr: thanks :D
[13:11:24] <cmr> Blei: I still would like to see the caret the diagnostic color and the squggle white though :p
[13:11:35] <Blei> cmr: write a PR ;)
[13:11:40] <cmr> pft!
[13:11:44] * cmr adds it to his list
[13:12:03] <SiegeLord> Does everybody use a black background terminal or something? :P
[13:12:20] <Blei> yes. who doesn't, in this day and age? ;)
[13:12:27] <Blei> osx users?
[13:12:29] <cmr> SiegeLord: Well presumably if you're using a white/light background your color scheme has white readable
[13:12:36] <cmr> and if it doesn't, your color scheme sucks :p
[13:12:50] <SiegeLord> These colors really should be configurable
[13:12:57] <cmr> in rustc?
[13:13:02] <SiegeLord> Yes
[13:13:17] <cmr> Should be a simple change, the diagnostic printing is rather self-contained
[13:13:26] <dbaupp> cmr: does it at least detect that it's going to a tty?
[13:13:30] <Blei> or maybe we should just have 2 sets of colors, for light and dark backgrounds
[13:13:32] <Blei> like vim
[13:13:43] <Blei> dbaupp: it does
[13:13:55] <Blei> at least on unix
[13:13:55] <dbaupp> Blei: cool
[13:15:27] <Blei> we could add a command line switch, something like --color=(auto-bright|auto-dark|bright|dark|none)
[13:15:49] <Blei> with auto-dark being the default
[13:16:45] <thiez> okay, so once the odds of a PR passing all tests approaches 72% it becomes cheaper to optimistically merge two PRs at the same time
[13:16:57] <dbaupp> cmr: you shouldn't ever need + IteratorUtil<T>
[13:17:15] <dbaupp> thiez: analytically, or experimentally?
[13:17:27] <cmr> dbaupp: I need it for .advance
[13:17:35] <cmr> for now
[13:17:38] <dbaupp> cmr: importing IteratorUtil should work
[13:17:44] <cmr> I have a fixme for it
[13:17:49] <thiez> dbaupp: based on my really awful analysis :p
[13:18:00] <dbaupp> cmr: (since Iterator implies IteratorUtil, always)
[13:18:19] <cmr> dbaupp: oh hey, fancy
[13:18:30] <dbaupp> cmr: in fact... it should work without it... since IteratorUtil is in the prelude
[13:18:34] <dbaupp> (i think)
[13:18:40] <dbaupp> thiez: :D
[13:19:38] <thiez> rusti: let single_cost = 1.0 ; let pass_chance = 0.72 ; pass_chance * pass_chance * single_cost + 3.0 * single_cost * (1.0-(pass_chance * pass_chance))
[13:19:39] -rusti- 1.9632
[13:20:03] <thiez> but that assumes no deviation is pass chance, which is not entirely reasonable :p
[13:20:42] <thiez> I should have paid more attention at statistics, who knew they might come in handy some day? :(
[13:20:56] <cmr> What kind do I need to dereference a &mut T?
[13:20:57] <dbaupp> x^2 + 3(1 - x^2) = 3 - 2x^2 => x = sqrt(1.5)
[13:21:07] * dbaupp is confused
[13:21:09] <cmr> oh wait I was reading the error wrong
[13:21:10] <cmr> nvm
[13:21:59] *** Quits: xLII (xLII@4BED3CB3.F5F53E8A.2D6DB75E.IP) (Ping timeout)
[13:22:20] <dbaupp> oh, right, we want 3 - 2x^2 < 2
[13:22:24] * dbaupp is silly
[13:22:50] <dbaupp> rusti: let single_cost = 1.0 ; let pass_chance = 0.5f.sqrt(); pass_chance * pass_chance * single_cost + 3.0 * single_cost * (1.0-(pass_chance * pass_chance))
[13:22:51] -rusti- 2
[13:23:18] <thiez> okay you win.
[13:23:22] * thiez applauds.
[13:23:32] <dbaupp> thiez: heh ;P
[13:23:34] *** Quits: jhark (jhark@moz-B9920504.jhark.net) (Ping timeout)
[13:24:50] <MaikKlein> hm
[13:24:59] <MaikKlein> rusti: -0.5f.sqrt()
[13:25:00] -rusti- -0.70710678
[13:25:03] <MaikKlein> oO
[13:25:12] <MaikKlein> rusti: (-0.5f).sqrt()
[13:25:13] -rusti- 0
[13:25:13] <thiez> rusti: (-0.5f).sqrt
[13:25:13] -rusti- <anon>:9:9: 9:21 error: attempted to take value of method `sqrt` on type `float` (try writing an anonymous function)
[13:25:13] -rusti- <anon>:9          (-0.5f).sqrt
[13:25:14] -rusti-                   ^~~~~~~~~~~~
[13:25:14] -rusti- error: aborting due to previous error
[13:25:14] -rusti- application terminated with error code 101
[13:25:33] <dbaupp> rusti: (-0.5f).sqrt().is_NaN()
[13:25:33] -rusti- false
[13:25:39] <thiez> that is interesting.
[13:25:42] <dbaupp> ?
[13:25:53] <thiez> perhaps taking sqrt of a negative number is undefined in C? :p
[13:25:55] <dbaupp> rusti: (-1f32).sqrt().is_NaN()
[13:25:56] -rusti- false
[13:26:00] *** Joins: xLII (xLII@FD599B33.EEA22DFE.F298944D.IP)
[13:26:09] <jensnockert> thiez: It is defined.
[13:26:20] <jensnockert> rusti: (-1f32).sqrt()
[13:26:20] -rusti- 0
[13:26:26] <jensnockert> But that is wrong.
[13:26:28] <thiez> but we're using LLVM intrinsics as I recall
[13:26:32] <jensnockert> I think we're using LLVM intrinsics.
[13:26:35] <dbaupp> thiez: yeah
[13:26:42] <jensnockert> And then not checking for FP exceptions.
[13:26:46] <thiez> they probably follow the C semantics because LLVM loves clang
[13:26:52] <dbaupp> MaikKlein: nice work, you found a bug!
[13:26:58] <MaikKlein> :D
[13:27:05] <thiez> or the lack of C semantics ^^
[13:27:27] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[13:27:48] <jensnockert> Not really surprising that the LLVM intrinsic doesn't follow IEEE 754 :S
[13:27:53] <engla> If x is less than -0, a domain error occurs, and a NaN is returned.
[13:28:18] <dbaupp> thiez: printf("%f\n", sqrtf(-1.0)) => "-nan"
[13:28:28] <thiez> odd.
[13:28:31] <cmr> Hm, almost got my interner code working
[13:28:32] <Jesse> checking FP exceptions is sketchy if the compiler is allowed to constant-fold or dead-code-eliminate your arithmetic
[13:28:35] <cmr> only problem right now is:
[13:28:41] <cmr> interner.rs:63:12: 63:16 error: cannot borrow immutable argument as mutable
[13:28:43] <cmr> interner.rs:63         for init.advance |v| {
[13:28:45] <cmr>                            ^~~~
[13:28:57] <cmr> it's declare (init: U)
[13:29:04] *** Quits: Blei (Philipp@moz-92058B1D.ethz.ch) (Quit: Blei)
[13:29:04] <cmr> I would have thought that is a move?
[13:29:10] <thiez> Jesse: I suspect the compiler isn't allowed to do those things when the FP exceptions depend on them being executed?
[13:29:15] *** Joins: Blei (Philipp@moz-92058B1D.ethz.ch)
[13:29:28] <dbaupp> cmr: yeah, but it's the same as `let init = foo`
[13:29:35] <dbaupp> cmr: (mut init: U) should work
[13:29:48] <dbaupp> (or `let mut init = init;` in the body)
[13:29:51] <jensnockert> You can constant fold the FP exceptions as well.
[13:30:04] <Jesse> i think this is why floating point division by zero is undefined behavior in some versions of C/C++
[13:30:25] <thiez> jensnockert: at that point checking them ceases being sketchy :)
[13:30:29] <cmr> Oh weird
[13:30:38] <cmr> dbaupp: thanks
[13:30:43] <jensnockert> Jesse: No, that's because for some floating point hardware it is undefined.
[13:31:00] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[13:31:01] <dbaupp> cmr: it's not weird... it's just rust's immutability-by-default.
[13:31:05] *** Parts: Blei (Philipp@moz-92058B1D.ethz.ch) ()
[13:31:09] *** Joins: Blei (Philipp@moz-92058B1D.ethz.ch)
[13:31:10] <MaikKlein> wait
[13:31:15] *** Joins: hansjorg_ (hansjorg@moz-41C5CE61.redpill-linpro.com)
[13:31:19] *** Quits: doy (doy@moz-5FE28A32.akrasiac.org) (Ping timeout)
[13:31:21] <MaikKlein> u can't advance on an immutable object?
[13:31:39] <dbaupp> MaikKlein: not an immutable iterator
[13:31:45] <cmr> MaikKlein: no, it consumes a value from the iterator
[13:31:45] <dbaupp> MaikKlein: .advance modifies the iterator
[13:32:03] <cmr> (well, .next modified the iterator, no?)
[13:32:04] <MaikKlein> oh right
[13:32:17] <dbaupp> rusti: let v = [1,2,3]; let it = v.iter(); println(fmt!("%?", it.next()))
[13:32:18] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/jibH
[13:32:19] <dbaupp> cmr: yeah
[13:32:27] <dbaupp> rusti: let v = [1,2,3]; let mut it = v.iter(); println(fmt!("%?", it.next()))
[13:32:28] -rusti- Some(&1)
[13:32:28] -rusti- ()
[13:32:41] *** Quits: xLII (xLII@FD599B33.EEA22DFE.F298944D.IP) (Ping timeout)
[13:32:49] <dbaupp> rusti: let v = [1,2,3]; let mut it = v.iter(); println(fmt!("%?", it)); println(fmt!("%?", it.next())); println(fmt!("%?", it))
[13:32:50] -rusti- {ptr: (0x20d5e90 as *()), end: (0x20d5ea8 as *()), lifetime: &1}
[13:32:50] -rusti- Some(&1)
[13:32:51] -rusti- {ptr: (0x20d5e98 as *()), end: (0x20d5ea8 as *()), lifetime: &1}
[13:32:51] -rusti- ()
[13:32:55] *** Joins: xLII (xLII@FD599B33.EEA22DFE.F298944D.IP)
[13:33:01] *** Joins: saml (sam@moz-14C16814.cst.lightpath.net)
[13:33:15] * dbaupp wishes we could remove the lifetime flag
[13:35:05] <MaikKlein> hm
[13:35:06] * jensnockert wishes we could have full IEEE 754 support.
[13:35:21] <doener> oh wow, no dynamic borrow failure in stage1
[13:35:25] <MaikKlein> so [1,2,3,4].iter() is an mutable iterator by default?
[13:36:11] <bstrie> MaikKlein: I think you have to use .mut_iter() to get a mutable one
[13:36:54] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[13:37:04] <MaikKlein> rusti: for ~[1,2,3,4].iter().advance |x| { }
[13:37:05] -rusti- <anon>:9:31: 9:38 error: `for` must be followed by a block call
[13:37:05] -rusti- <anon>:9          for ~[1,2,3,4].iter().advance |x| { }
[13:37:05] -rusti-                                         ^~~~~~~
[13:37:05] -rusti- application terminated with error code 101
[13:37:24] *** Joins: Ble1 (Philipp@moz-92058B1D.ethz.ch)
[13:37:41] <dbaupp> MaikKlein: yes
[13:37:55] <MaikKlein> rusti: ~[1,2,3,4].iter().advance().collect()
[13:37:57] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/TTBH
[13:38:11] <dbaupp> bstrie: the iterator object itself is mutable, since rvalues can be borrowed as mutable
[13:38:22] <bstrie> dbaupp: then what's .mut_iter for?
[13:38:25] *** Quits: Blei (Philipp@moz-92058B1D.ethz.ch) (Ping timeout)
[13:38:34] <dbaupp> bstrie: for mutating the elements of the vector
[13:38:48] <bstrie> what's the use of having a mutable iterator over an immutable object?
[13:38:48] <dbaupp> rusti: ~[1,2,3,4].iter().collect::<~[int]>()
[13:38:49] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/DbJY
[13:39:00] <dbaupp> rusti: ~[1i,2,3,4].iter().collect::<~[int]>()
[13:39:01] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/XBiB
[13:39:12] <dbaupp> rusti: ~[1i,2,3,4].iter().collect::<~[&int]>()
[13:39:14] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/HRYc
[13:39:15] *** Joins: mw (mw@moz-7FBFE83C.adsl.highway.telekom.at)
[13:39:20] <dbaupp> bstrie: I'm not sure I understand
[13:39:22] *** Joins: doy (doy@moz-5FE28A32.akrasiac.org)
[13:39:28] <bstrie> dbaupp: that makes two of us :)
[13:39:43] <bstrie> you say the iterator object itself is mutable
[13:39:44] <dbaupp> rusti: let s = "abcd"; s.iter().collect::<~[char]>()
[13:39:45] -rusti- ~['a', 'b', 'c', 'd']
[13:39:57] <dbaupp> bstrie: ah, right.
[13:39:58] <bstrie> but you say that you can only change the object being iterated over if you use mut_iter
[13:40:04] <cmr> Right
[13:40:24] <cmr> mut_iter gives you &mut, rather than &
[13:40:32] <dbaupp> bstrie: .iter() returns VecIterator, and this return value has to be mutable to be useable
[13:40:35] <bstrie> so my question is why you'd want to mutate an iterator, rather than mutating the underlying object
[13:40:49] <cmr> bstrie: next() isn't immutable
[13:41:10] <dbaupp> the iterator has to preserve its state
[13:41:18] <MaikKlein> but when do we ever need an iterator were we can't call .next on it?
[13:41:27] <dbaupp> MaikKlein: .advance calls .next
[13:41:34] <dbaupp> MaikKlein: (as does .collect)
[13:41:35] *** Joins: doomsplayer (xLII@FD599B33.EEA22DFE.F298944D.IP)
[13:41:43] <dbaupp> MaikKlein: wait...
[13:41:43] *** Quits: xLII (xLII@FD599B33.EEA22DFE.F298944D.IP) (Ping timeout)
[13:41:46] <MaikKlein> dbaupp, yes but I thought cmr had an example where it was not possible?
[13:41:49] <dbaupp> I misunderstood your question
[13:41:59] <cmr> MaikKlein: only time is when you'd be using size_hint to preallocate
[13:42:18] <dbaupp> MaikKlein: yes, an immutable Iterator isn't very useful
[13:42:45] <MaikKlein> ok
[13:42:46] <thiez> MaikKlein: were you going to file an issue on the .sqrt() bug?
[13:43:16] *** Quits: doomsplayer (xLII@FD599B33.EEA22DFE.F298944D.IP) (Ping timeout)
[13:43:25] <MaikKlein> thiez, oh I can do that ofc
[13:43:27] <thiez> if not I'll do it
[13:43:33] <thiez> but since you found it... :)
[13:43:42] *** Quits: untothebreach (paul@15A17709.47300931.30F15291.IP) (Quit: leaving)
[13:43:55] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[13:44:24] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[13:44:33] <cmr> Another problem with Interner (https://gist.github.com/cmr/5846269)
[13:44:40] <cmr> For clarity:
[13:44:42] <cmr> interner.rs:125:38: 125:55 error: failed to find an implementation of trait Interner<<V10>> for [&'static str, .. 3]
[13:44:44] <cmr> interner.rs:125         let i: SimpleInterner<~str> = Interner::prefill(names);
[13:44:46] <cmr>                                                       ^~~~~~~~~~~~~~~~~
[13:44:50] <cmr> But I do want to use names.iter(), but that makes the error undeciperable :p
[13:45:20] <cmr> (it's the same with ~"Alan" and so on)
[13:45:34] <dbaupp> cmr: try &[]
[13:45:55] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[13:46:03] <cmr> dbaupp: Same thing
[13:46:06] <cmr> interner.rs:125:38: 125:55 error: failed to find an implementation of trait Interner<<V10>> for std::vec::VecIterator<,~str>
[13:46:08] <cmr> interner.rs:125         let i: SimpleInterner<~str> = Interner::prefill(names.iter());
[13:46:10] <cmr>                                            
[13:46:12] <cmr> (without .iter(), interner.rs:125:38: 125:55 error: failed to find an implementation of trait Interner<<V10>> for &[~str]
[13:46:37] <dbaupp> cmr: using the code from the gist exactly?
[13:46:38] <cmr> dbaupp: I think it's a bug
[13:47:21] <cmr> dbaupp: updated the gist, now it is exact
[13:47:40] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[13:47:55] <cmr> I think it's trying to use the type of the parameter as the <T> of the Interner, instead of as the <U> of the method
[13:48:10] <cmr> Maybe I need prefil::<Iterator<~str>>(...)?
[13:48:24] <MaikKlein> rusti: println(fmt!("%?",(-(0.5f)).sqrt()))
[13:48:25] -rusti- 0
[13:48:25] -rusti- ()
[13:49:24] *** Joins: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com)
[13:49:35] <MaikKlein> println(fmt!("%?",(-(0.5f)).sqrt().is_NaN()))
[13:49:41] <MaikKlein> rusti: println(fmt!("%?",(-(0.5f)).sqrt().is_NaN()))
[13:49:42] -rusti- false
[13:49:42] -rusti- ()
[13:49:45] <MaikKlein> lol
[13:49:52] <MaikKlein> on my rust version this works
[13:50:00] <MaikKlein> and it is from 10 hours ago 
[13:50:08] <cmr> MaikKlein: Are you compiling with -O?
[13:50:19] <MaikKlein> no
[13:50:23] <cmr> try that
[13:50:31] *** Joins: cr (anonymous@A488030B.C4D4A1E0.1A5CC7E5.IP)
[13:50:35] <dbaupp> Yeah, I get NaN
[13:50:46] <dbaupp> cmr: rusti is compiling without -O
[13:50:50] <cmr> Oh it is?
[13:50:53] <dbaupp> (irc-rusti)
[13:51:04] <dbaupp> it'd be way to slow if it was
[13:51:04] <MaikKlein> is rusti always up to date?
[13:51:11] <cmr> MaikKlein: updated daily
[13:51:11] <dbaupp> MaikKlein: it's a nightly build
[13:51:30] <cmr> I get `true` without -O, `false` with it.
[13:51:31] <dbaupp> rusti: std::run::run_program("rustc", [~"--version"])
[13:51:31] -rusti- <anon>:9:9: 9:30 error: unresolved name `std::run::run_program`.
[13:51:33] -rusti- <anon>:9          std::run::run_program("rustc", [~"--version"])
[13:51:35] -rusti-                   ^~~~~~~~~~~~~~~~~~~~~
[13:51:37] -rusti- error: aborting due to previous error
[13:51:39] -rusti- application terminated with error code 101
[13:51:56] <MaikKlein> so I might want to update to the recent master before I write a bugreport
[13:52:13] <cmr> MaikKlein: I don't think anything has been pulled that would affect this
[13:52:26] <cmr> and I'm using latest master and can confirm
[13:52:26] <Ble1> wasn't there another bug with floating point code?
[13:52:58] <dbaupp> rusti: println(std::str::from_bytes(std::run::process_output("rustc", [~"--version"]).output))
[13:52:59] -rusti- rustc 0.6 (df166ba 2013-06-22 12:59:37 -0700)
[13:52:59] -rusti- host: x86_64-unknown-linux-gnu
[13:52:59] -rusti- ()
[13:53:01] *** Ble1 is now known as Blei
[13:53:10] <dbaupp> Blei: there are quite a few
[13:53:14] *** Quits: cr (anonymous@A488030B.C4D4A1E0.1A5CC7E5.IP) (Ping timeout)
[13:53:26] <dbaupp> (there's one about printing/reading them)
[13:53:59] <dbaupp> MaikKlein: what hash is your rustc?
[13:56:34] <dbaupp> hm, I get NaN without optimisations, and 0 with -O
[13:56:39] <MaikKlein> dc4560d
[13:57:15] <dbaupp> aatch: ping
[13:57:46] <indutny> yikes
[13:57:51] <indutny> I've almost fixed it!
[13:57:58] <cmr> indutny: :D
[13:58:02] <dbaupp> indutny: yay!
[13:58:02] <indutny> only need to do one more check
[13:58:07] <indutny> so it seems to be a nasty hack
[13:58:15] * dbaupp hats #5898
[13:58:18] <indutny> and it'll be probably worth refactoring later on
[13:58:18] <MaikKlein> rusti: 1/0
[13:58:19] -rusti- rust: task failed at 'attempted to divide by zero', <anon>:9
[13:58:19] -rusti- rust: domain main @0x1f551b0 root task failed
[13:58:19] -rusti- application terminated with error code 101
[13:58:20] <dbaupp> *hates
[13:58:31] <dbaupp> rusti: 1f/0f
[13:58:32] -rusti- inf
[13:58:36] <cmr> indutny: if you can, do cleanup
[13:58:58] <cmr> indutny: adding more bad code to trans doesn't help anyone (except dbaupp, maybe :p)
[13:59:00] <dbaupp> indutny: when you submit a PR, just @ mention 'nikomatsakis' asking for advice :)
[13:59:11] <dbaupp> cmr: (it's not trans ;) )
[13:59:18] <MaikKlein> why is 1f/0f inf?
[13:59:21] <cmr> Oh, it was purely typeck?
[13:59:25] <MaikKlein> and 1/0 throws and error?
[13:59:29] <thiez> MaikKlein: I think it's defined like that
[13:59:34] <dbaupp> cmr: typeck and infer I think
[13:59:37] <thiez> MaikKlein: because int/uint has no infinity
[13:59:40] <cmr> MaikKlein: floats vs int, ieee 754
[13:59:58] <thiez> rusti: 1f/-0f
[13:59:59] <indutny> ok
[13:59:59] -rusti- -inf
[14:00:11] <indutny> cmr: it helps me :P
[14:00:12] <MaikKlein> hm ok
[14:00:14] *** kimundi is now known as zz_kimundi
[14:01:00] <dbaupp> indutny: (you can get around #5898 by renaming the methods)
[14:01:02] <thiez> hmmn, do we have official 'undefined behaviour' in rust?
[14:01:10] <indutny> dbaupp: I don't like it
[14:01:22] <indutny> this way I need to postfix all methods in asm.rs
[14:01:28] <indutny> pushq/popq instead of push/pop
[14:01:34] <dbaupp> thiez: good timing http://www.reddit.com/r/rust/comments/1gys8y/does_rust_have_undefined_behaviour/
[14:01:47] <dbaupp> (not that that has anything useful to say)
[14:02:00] <dbaupp> indutny: the convention is postfixing with an '_'
[14:02:01] <thiez> reddit is under heavy load right now :p
[14:02:07] <Blei> thiez: shifting integers by more than their width is undefined iirc
[14:02:10] <dbaupp> thiez: try again
[14:02:58] <thiez> Blei: but can the compiler optimize 'fn foo(x: int) -> bool { (x+1) > x } to true, like in C?
[14:03:08] *** Joins: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[14:03:11] *** Joins: jaen (jaen@moz-27C20102.play-internet.pl)
[14:03:16] <thiez> or do we have wrap-around semantics for our signed types?
[14:03:23] <MaikKlein> did I file the bug correctly? https://github.com/mozilla/rust/issues/7347
[14:03:26] <cmr> rusti: fn foo(x: int) -> bool { (x+1) > x }
[14:03:26] -rusti- ()
[14:03:44] <thiez> rusti runs without -O so it's no a good test for undefined behaviour :D
[14:03:50] <cmr> rusti: fn foo(x: int) -> bool { (x+1) > x } foo(0xFFFFFFFF)
[14:03:51] -rusti- true
[14:04:10] <cmr> rusti: fn foo(x: int) -> bool { (x+1) > x } foo(0xFFFFFFF0)
[14:04:11] -rusti- true
[14:04:13] <MaikKlein> -O -0
[14:04:19] <Blei> thiez: i actually don't know.
[14:04:26] <dbaupp> Blei, thiez: https://github.com/mozilla/rust/issues/1877
[14:04:41] <Blei> i'd guess that most undefined behaviour is "inherited" from llvm
[14:04:57] <cmr> thiez: The compiler shouldn't allow overflow.
[14:05:14] <dbaupp> cmr: rusti is 64-bit
[14:05:19] <thiez> cmr: really? why not
[14:05:20] <cmr> oh right
[14:05:24] <cmr> rusti: fn foo(x: i32) -> bool { (x+1) > x } foo(0xFFFFFFF0)
[14:05:25] -rusti- true
[14:05:27] <cmr> rusti: fn foo(x: i32) -> bool { (x+1) > x } foo(0xFFFFFFFF)
[14:05:27] -rusti- true
[14:05:28] <dbaupp> rusti: fn foo(x: i8) -> bool { (x+1) > x } foo(0xFF)
[14:05:29] -rusti- true
[14:05:38] <cmr> thiez: Because it's undefined behavior!
[14:05:44] <thiez> cmr: not if we define it! :p
[14:05:45] <cmr> thiez: especially across different architectures
[14:05:48] <dbaupp> rusti: fn foo(x: i8) -> bool { (x+1) > x } foo(0x7F)
[14:05:49] -rusti- false
[14:06:01] <dbaupp> cmr: (0xFF = -1)
[14:06:02] <thiez> how many architectures don't use 2complement?
[14:06:15] <MaikKlein> what is i8?
[14:06:24] <dbaupp> MaikKlein: 8-bit signed integer
[14:06:38] <MaikKlein> dbaupp, both on x86 and x64?
[14:06:44] *** Joins: yoshi (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP)
[14:06:46] <dbaupp> MaikKlein: there is {i,u}{8,16,32,64}
[14:06:53] <dbaupp> MaikKlein: and those are fixed size
[14:07:08] <dbaupp> (uint and int are platform word-size)
[14:07:08] <MaikKlein> that's actually quite nice
[14:07:32] <thiez> it seems right-shift on signed types in undefined in C++
[14:07:37] *** Joins: jorendorff (jorendorff@moz-1747FB68.hsd1.tn.comcast.net)
[14:07:46] <MaikKlein> really?
[14:07:57] <thiez> rusti: fn foo(x: i8) -> i8 { x >> 1 } foo(2)
[14:07:58] -rusti- 1
[14:08:24] <thiez> rusti: fn foo(x: i8) -> i8 { x >> 1 } foo(1)
[14:08:24] -rusti- 0
[14:08:29] <thiez> hmn, we don't use that
[14:08:44] <dbaupp> rusti: fn foo(x: i8) -> i8 { x >> 1 } foo(-1)
[14:08:45] -rusti- -1
[14:08:57] <dbaupp> fn foo(x: i8) -> i8 { x >> 1 } foo(-20)
[14:09:04] <MaikKlein> how do I declare bytes again?
[14:09:08] <dbaupp> rusti: fn foo(x: i8) -> i8 { x >> 1 } foo(-20)
[14:09:09] -rusti- -10
[14:09:16] <dbaupp> MaikKlein: what do you mean?
[14:09:19] <MaikKlein> u8=
[14:09:21] <MaikKlein> nvm
[14:09:26] <dbaupp> rusti: fn foo(x: i8) -> i8 { x >> 1 } foo(-21)
[14:09:27] -rusti- -11
[14:09:58] <MaikKlein> dbaupp, I just misread your answer from before
[14:10:30] <doomlord> trying to find length of a vector.. foo : &[T] - .length, .size, .count , .num with & without ()
[14:10:56] <bstrie> doomlord: try .len()
[14:11:00] <MaikKlein> so an f32 is 32bit?
[14:11:03] <doomlord> lol :) the one i dont
[14:11:14] <bstrie> rusti: [1,2,3].len()
[14:11:16] -rusti- 3
[14:11:17] <doomlord> thanks
[14:11:43] <MaikKlein> rusti: !(5u)
[14:11:44] -rusti- 18446744073709551610
[14:11:53] <MaikKlein> rusti: !(5u8)
[14:11:54] -rusti- 250
[14:11:56] <bstrie> MaikKlein: f32 is a single, f64 is a double
[14:12:07] <bstrie> personally I adore that rust doesn't call them doubles
[14:12:14] <jedestep> are there any known issues with unused import warnings
[14:12:15] <bstrie> literally the worst name for a type since "string"
[14:12:19] <cmr> doomlord: there is documentation you know :p
[14:12:26] <doomlord> i couldn't find it 
[14:12:57] <bstrie> doomlord: blame cmr for not being able to find the documentation
[14:13:02] <cmr> http://static.rust-lang.org/doc/std/vec.html#implementation-of-container-for-t-where-t
[14:13:10] <MaikKlein> bstrie, has f32 the same size on an x86 then on an x64?
[14:13:10] <cmr> doomlord: don't blame me, I'm trying to fix the problem :p
[14:13:30] <doomlord> i mean i've seen the tutorials, i saw the bit on vectors.
[14:13:39] <bstrie> MaikKlein: I presume so, yes. "float" is the type that can change per-platform
[14:13:49] <cmr> rustdoc just generates incomprehensible, impossible-to-navigate documentation right now
[14:14:10] <MaikKlein> do we have a size of operator?
[14:14:16] <cmr> std::sys::size_of
[14:14:19] <Blei> no, but a size_of function
[14:14:36] <MaikKlein> rusti: std::sys::size_of(1.0f32)
[14:14:37] -rusti- <anon>:9:9: 10:5 error: this function takes 0 parameters but 1 parameter was supplied
[14:14:37] -rusti- <anon>:9          std::sys::size_of(1.0f32)
[14:14:37] -rusti- <anon>:10     };
[14:14:37] -rusti- error: aborting due to previous error
[14:14:37] -rusti- application terminated with error code 101
[14:14:41] <SiegeLord> I don't really see the point behind 'float'
[14:14:47] <cmr> rusti: std::sys::size_of::<f32>()
[14:14:48] -rusti- 4
[14:14:59] <MaikKlein> oh
[14:15:03] <MaikKlein> ok
[14:15:04] <cmr> SiegeLord: neither can anyone else, slated for removal iirc
[14:15:08] <SiegeLord> Unless it represents something like 'real' in D
[14:15:29] <dcolish> marco expansions happen during the cu_expand phase of the driver right?
[14:15:36] <MaikKlein> rusti: std::sys::size_of::<f64>()
[14:15:36] -rusti- 8
[14:15:40] <cmr> It's supposed to be a "fast" float, for the platform, but what is "fast"?
[14:15:57] <MaikKlein> I don't understand
[14:15:57] <cmr> And when you don't have SSE, x87 is "fast", which is 80 bits, not 32 or 64
[14:15:58] <dbaupp> SiegeLord: I heard someone have a half-decent argument for it, can't remember what the argument was, or who the person was
[14:16:11] <cmr> (on x86)
[14:16:20] <MaikKlein> how many bits are a byte? I thought it is 4?
[14:16:22] <dbaupp> dcolish: basically, yes
[14:16:22] <bstrie> rusti: std::sys::size_of::<int>()
[14:16:23] -rusti- 8
[14:16:25] <cmr> MaikKlein: 8
[14:16:28] <dbaupp> MaikKlein: 8
[14:16:29] <bstrie> rusti: std::sys::size_of::<float>()
[14:16:29] <SiegeLord> Like 'real' in D is 80 bits long
[14:16:30] -rusti- 8
[14:16:31] <cmr> MaikKlein: size_of is number of bytes
[14:16:32] <MaikKlein> really
[14:16:36] <bstrie> rusti: std::sys::size_of::<char>()
[14:16:37] -rusti- 4
[14:16:37] <MaikKlein> :X
[14:16:46] <bstrie> rusti: std::sys::size_of::<f32>()
[14:16:46] <thiez> how to use trait 'One'?
[14:16:47] -rusti- 4
[14:16:55] <dbaupp> rusti: sts::sys::size_of::<u8>()
[14:16:56] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/ILDA
[14:16:59] <cmr> rusti: let x: u8 = std::num::One(); x
[14:17:00] <jedestep> rusti: std::sys::size_of<bool>()
[14:17:01] -rusti- <anon>:9:21: 9:34 error: unresolved name `std::num::One`.
[14:17:01] -rusti- <anon>:9          let x: u8 = std::num::One(); x
[14:17:01] -rusti-                               ^~~~~~~~~~~~~
[14:17:01] -rusti- error: aborting due to previous error
[14:17:01] -rusti- application terminated with error code 101
[14:17:01] -rusti- <anon>:9:27: 9:31 error: unresolved name `bool`.
[14:17:01] <dbaupp> thiez: One::one()
[14:17:02] -rusti- <anon>:9          std::sys::size_of<bool>()
[14:17:02] *** concrete.mozilla.org sets mode: +M 
[14:17:04] -rusti-                                     ^~~~
[14:17:07] -rusti- error: aborting due to previous error
[14:17:09] <cmr> rusti: let x: u8 = std::num::One::onew(); x
[14:17:09] -rusti- application terminated with error code 101
[14:17:10] -rusti- <anon>:9:21: 9:40 error: unresolved name `std::num::One::onew`.
[14:17:13] -rusti- <anon>:9          let x: u8 = std::num::One::onew(); x
[14:17:14] <cmr> bah
[14:17:15] <MaikKlein> is rusti on a x64?
[14:17:15] -rusti-                               ^~~~~~~~~~~~~~~~~~~
[14:17:17] -rusti- error: aborting due to previous error
[14:17:19] <cmr> MaikKlein: yes
[14:17:19] -rusti- application terminated with error code 101
[14:18:09] *** zz_kimundi is now known as kimundi
[14:19:15] <MaikKlein> so in rust it doesn't matter if you program on a x64 or on a x86? 
[14:19:28] <cmr> MaikKlein: not if you use fixed width types. in theory.
[14:19:29] <MaikKlein> all types have the same size?
[14:19:39] <cmr> int/uint/float are machine-dependant sizes
[14:19:40] <MaikKlein> ah
[14:19:44] <MaikKlein> int is not fixed then?
[14:19:46] <cmr> no
[14:19:47] <MaikKlein> ok
[14:19:56] <bstrie> use i32 or i64 if you want fixed
[14:20:00] <cmr> It is whatever size needed to contain a pointer, signed.
[14:20:25] <MaikKlein> would it be a good habit to always use fixed types?
[14:20:31] <cmr> no
[14:20:42] <cmr> uint is needed for indexing for example
[14:21:02] <SiegeLord> cmr: If anybody ever makes a concrete implelemntation of a OpenCL backend, then the "fast" float would be f32
[14:21:29] *** Quits: dbaupp (Thunderbir@moz-73E90475.lns20.syd6.internode.on.net) (Quit: dbaupp)
[14:21:33] *** Joins: dbaupp (Thunderbir@moz-73E90475.lns20.syd6.internode.on.net)
[14:21:35] <SiegeLord> It's not 100% apparent to me that 64 bit int is the "fast" int on 64 bits
[14:21:42] <dcolish> dbaupp: ok, so i'm getting this error when trying to use a macro in a pkg.rs, https://gist.github.com/dcolish/5850389
[14:21:53] *** Quits: sk (sk@61A494B3.BA40E8A.AAC02D62.IP) (Quit: Leaving)
[14:21:53] <MaikKlein> rusti: 5ui
[14:21:53] -rusti- <anon>:9:11: 9:12 error: expected `;` or `}` after expression but found `i`
[14:21:53] -rusti- <anon>:9          5ui
[14:21:53] -rusti-                     ^
[14:21:54] -rusti- application terminated with error code 101
[14:22:00] <dcolish> does that mean the macro wasnt found?
[14:22:02] *** concrete.mozilla.org sets mode: -M 
[14:22:08] <cmr> SiegeLord: with sse it requires more cache lines and register space, which is why it's not as "fast"
[14:22:15] <MaikKlein> rusti: 5ui8
[14:22:16] -rusti- <anon>:9:11: 9:13 error: expected `;` or `}` after expression but found `i8`
[14:22:16] -rusti- <anon>:9          5ui8
[14:22:16] -rusti-                     ^~
[14:22:16] -rusti- application terminated with error code 101
[14:22:19] <dbaupp> dcolish: can you run with `RUST_LOG=::rt::backtrace ...`
[14:22:24] <dbaupp> dcolish: ?
[14:22:26] <dcolish> oh awesome
[14:22:27] <SiegeLord> Either way, floating point is hard enough to get right without platform dependent precision butting in
[14:22:36] <dbaupp> rusti: 5u8
[14:22:37] -rusti- 5
[14:22:39] <cmr> SiegeLord: (also you mean float, not int, right?)
[14:22:42] <dbaupp> MaikKlein: ^
[14:22:46] <pauls> dcolish: looks like an internal error.
[14:22:58] <MaikKlein> dbaupp, haha i am stupid
[14:23:11] <pauls> Somehow, a macro failed to get processed by the expander?
[14:23:12] <thiez> so how do you register a nick on this irc server?
[14:23:13] <SiegeLord> cmr: I meant int by analogy (if 'float' is the fast floating point, s 'int' also not the fast integer?)
[14:23:15] <dbaupp> SiegeLord: uint/int aren't the fast int's, I think they're the word-size/pointer-size
[14:23:24] <cmr> SiegeLord: what dbaupp said
[14:23:31] <MaikKlein> do we have unsigned floats?
[14:23:36] <pauls> dcolish: what's the code that caused it?
[14:23:40] <cmr> MaikKlein: there is no such thing
[14:23:40] <dbaupp> MaikKlein: nope
[14:23:41] <thiez> MaikKlein: nope
[14:23:41] <MaikKlein> rusti: 10.5uf32
[14:23:42] -rusti- <anon>:9:13: 9:17 error: expected `;` or `}` after expression but found `uf32`
[14:23:42] -rusti- <anon>:9          10.5uf32
[14:23:42] -rusti-                       ^~~~
[14:23:42] -rusti- application terminated with error code 101
[14:23:44] <dcolish> dbaupp: https://gist.github.com/5850404
[14:23:58] <MaikKlein> cmr, was just wondering :)
[14:24:05] <kimundi> MaikKlein: Not really, a ieee float always has a sign bit
[14:24:08] <dcolish> pauls: use of any debug! macros in a pkg.rs file
[14:24:17] *** Joins: jpochyla (jpochyla@E1DB45DB.1AFA5C43.5DC06702.IP)
[14:24:21] <cmr> MaikKlein: http://grouper.ieee.org/groups/754/
[14:24:37] <dcolish> i think it has to do with how compile_rest is being called by the crate compiler
[14:24:42] <pauls> dcolish: oh, this must have something to do with the way that pkg.rs works. I guess it doesn't have an expansion step?
[14:24:51] <dbaupp> dcolish: it's failing in syntax::ast_map::map_crate in driver.rs
[14:25:10] <Blei> thiez: https://wiki.mozilla.org/IRC#Register_your_nickname
[14:25:33] <dcolish> damn it, i need an emacs, "open this in github" macro
[14:27:07] <dcolish> driver is called from here https://github.com/mozilla/rust/blob/master/src/librustpkg/util.rs#L287
[14:27:16] *** Quits: Earnestly (earnest@87814665.5364A5FA.922AD825.IP) (Quit: WeeChat 0.4.2-dev)
[14:27:33] <SiegeLord> I dunno... I've always heard that word size = fast
[14:27:33] <thiez> Blei: thanks :)
[14:27:58] <dbaupp> dcolish: yes... it appears to be expanding macros
[14:28:02] <thiez> one would expect a processor to be optimized for its own words
[14:28:29] <cmr> SiegeLord: and it usually is. but fast is not the definition of int/uint
[14:28:34] <dcolish> dbaupp: that was my assumption as well, so I'll need to check out what map_crate is doing then
[14:29:09] <SiegeLord> Should have been called 'word' ;)
[14:29:14] <SiegeLord> I miss DWORD etc
[14:29:57] *** Parts: ramige (ramige@moz-28AD658E.dynamic.ip.windstream.net) (Leaving)
[14:30:05] *** Quits: sankha93 (Instantbir@BA7CBBCC.291909EC.8B6C1D65.IP) (Ping timeout)
[14:30:24] <cmr> SiegeLord: example: hypothetical architecture with 32-bit micro controlling a 256-bit accelerator core. word size is 32 bits, but the fast int is going to be 256 bit
[14:30:27] <dbaupp> dcolish: what hash is your rustc?
[14:30:27] *** Joins: sankha93 (Instantbir@BA7CBBCC.291909EC.8B6C1D65.IP)
[14:30:32] <cmr> This isn't far fetched either: see parallela
[14:30:50] <thiez> rusti: use std::num::*; fn foo<T:One+Ord+Add<T,T>>(n:T)->bool{(n+One::one())>n} (foo(127i8),foo(32767i16),foo(2147483647i32))
[14:30:51] -rusti- (false, false, false)
[14:30:52] <cmr> SiegeLord: ( a slow 32bit micro, that is)
[14:30:52] <indutny> I wonder at which stage rust knows about all trait impls for struct in crate
[14:31:01] <indutny> I mean all visible impls
[14:31:06] <indutny> typeck?
[14:31:08] <indutny> earlier?
[14:31:09] <indutny> later?
[14:31:24] <dbaupp> indutny: it has to know about them for typeck
[14:31:30] <dcolish> dbaupp: 433c86554c22845509ac4bfaed0edfb1909d8ad3
[14:31:30] <indutny> ok, good
[14:31:34] <indutny> thanks
[14:31:38] <SiegeLord> Well, same thing can be said about a 256 bit float co-processor :P
[14:31:47] <thiez> cmr: since rust doesn't have a 256bit integer, we wouldn't really lose anything on such a machine :p
[14:32:26] *** Joins: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[14:32:27] <dcolish> it looks like its trying to get the macros id and failing
[14:32:45] <dbaupp> dcolish: can you put up your pkg.rs?
[14:32:46] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[14:32:49] <dcolish> sure
[14:33:18] <cmr> SiegeLord: Right, but there's more to performance than just speed of operation. There's also fetching it from memory, cache, storage size, back-and-forth with the coprocessor, etc.
[14:33:28] <dcolish> dbaupp: https://gist.github.com/5850461
[14:33:35] <cmr> SiegeLord: which is why it's a hard question, and one rust shouldn't decide on (that is my argument against 'float')
[14:33:44] *** Joins: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net)
[14:33:47] <SiegeLord> Yeah, I can agree with that
[14:33:53] <indutny> dbaupp: it seems that I can only cure some of such situations...
[14:34:04] <dcolish> its the addition of `debug!`
[14:34:04] <indutny> I need to think of better approach
[14:34:06] <thiez> cmr: I imagine usually one would want the highest-precision float by default, rather than the most efficient one
[14:34:13] <dcolish> without that it works as I'd expect
[14:34:19] <SiegeLord> Which is why I like 'real', (the definition of which is the maximum precision offered by the CPU)
[14:34:19] <cmr> thiez: machine-dependant float is insane imo
[14:34:36] <thiez> but then one would always use f64
[14:34:37] <thiez> hmmn
[14:34:42] <dbaupp> dcolish: hm, how do I actually run it?
[14:34:53] * dbaupp has never used pkg.rs's
[14:35:00] <dcolish> it needs to use rustpkg
[14:35:02] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[14:35:11] * dbaupp hasn't even used rustpkg much
[14:35:18] <dcolish> I can come up with a simpler example
[14:35:21] <dcolish> one sec
[14:35:43] <dbaupp> dcolish: do I just run `rustpkg pkg.rs`?
[14:35:50] <dbaupp> (or `rustpkg build`?)
[14:35:58] <SiegeLord> thiez: With x87 you can get more precision than f64
[14:36:00] <thiez> perhaps fn(x:float) should be a shortcut for fn<T:Float>(x:T) ;)
[14:36:10] <Blei> yes! found the problem!
[14:36:20] *** Quits: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net) (Quit: ["Textual IRC Client: www.textualapp.com"])
[14:36:20] <thiez> SiegeLord: I am aware of that, D uses that
[14:36:27] <cmr> Doesn't SSE have large scalar float operations too?
[14:36:28] <Blei> my intrinsic patch might land after all!
[14:36:47] <pauls> nmatsakis: I would probably attend a Boston Rust meetup.
[14:37:07] <doomlord> http://pastebin.com/54TVSbfa <<< messing with rust features to do this common pattern i use,  finding the 'best' item from a collection.. any comments? does somethign like this already exist?
[14:37:14] <dcolish> dbaupp: no it needs to live in a sub dir like this: https://gist.github.com/5850487
[14:38:30] *** Quits: Blei (Philipp@moz-92058B1D.ethz.ch) (Quit: Blei)
[14:38:48] <dcolish> ok here's a simpler example https://gist.github.com/5850499
[14:39:04] <SiegeLord> doomlord: I'd use an iterator... more generic and possibly faster (no bounds checking)
[14:39:34] <doomlord> so it could work across all sequences, ok
[14:39:39] <dbaupp> dcolish: what invocation do I use for rustpkg??
[14:39:52] <thiez> doomlord: use an iterator, get the first element, calculate its score, then fold those results over the rest of the iterator? :)
[14:40:22] <doomlord> the 'fold' being conditionally replace 'current iterations' best' ?
[14:40:30] <cmr> doomlord: you probably want to use the TotalOrd trait I think
[14:40:35] <thiez> doomlord: correct
[14:40:46] <SiegeLord> I forget, was there a plan to add size hints to iterators?
[14:40:47] <dcolish> dbaupp: assuming your cwd has a tree in it like src/break-macro,  `rustpkg build break-macro` 
[14:40:50] <cmr> SiegeLord: already done
[14:41:03] <doomlord> ... and factor out the inner loop -  findBest(initialScore,initialBest, ...)
[14:41:05] <dcolish> well "src/break-macro/pkg.rs"
[14:41:07] <SiegeLord> cmr: Where might I find an example?
[14:41:24] <cmr> SiegeLord: I use it https://gist.github.com/cmr/5846269#file-interner-rs-L59
[14:41:26] <cmr> there
[14:41:45] <doomlord> on previous generation consoles i would have fretted about how this can be done without conditonals
[14:41:56] <doomlord> ^ without branches rather
[14:41:56] <dbaupp> dcolish: cool, reproduced, etc :)
[14:41:58] <dbaupp> dcolish: what a strange bug
[14:42:20] <dcolish> yeah, its got me for sure
[14:42:32] <SiegeLord> Hmm... I wonder how you'd indicate an infinite iterator
[14:42:43] <doomlord> thinking in terms of bounds checking being there is new for me.
[14:43:01] <SiegeLord> Oh, it's using a default method, isn't it
[14:43:04] <SiegeLord> Pretty sweet
[14:43:20] <dbaupp> dcolish: looks like it is not expanding macros
[14:43:40] <cmr> doomlord: you need to use vec::raw if you want unsafe operations (like, "no bounds checking")
[14:43:43] <dbaupp> dcolish: `macro_rules! a{()=>{{}}} fn main() {}` gives a similar error
[14:43:45] *** Parts: dualhbridge (dad@moz-9FEE6D3B.maine.res.rr.com) ()
[14:43:52] <SiegeLord> I think it shouldn't use an Option, but enum SizeHint {Finite(uint), Infinite, Unknown}
[14:44:05] <doomlord> an iterator seems the way forward, but i like the fold idea 
[14:44:09] <doomlord> more^
[14:44:13] <dbaupp> dcolish: (also, I though rustpkg wasn't supposed to use main, but rather fn's like `build` and `clean`?)
[14:44:17] <dcolish> which is odd because util::compile_create_from_input is calling driver::compile_upto with from: driver::cu_expand
[14:44:21] <dbaupp> doomlord: you fold an iterator
[14:44:32] <cmr> SiegeLord: probably, send a PR
[14:44:42] <dcolish> dbaupp: all the pkg_do stuff doesnt quite work afaict
[14:44:49] <doomlord> TotalOrd ... differs from Ord how
[14:44:51] <SiegeLord> I'll think about it... I'm not 100% sure it's a good idea
[14:45:04] *** Quits: barosl (barosl@E287D94F.C81E10FB.7544CABF.IP) (Quit:  .)
[14:45:09] <dbaupp> rusti: let v = [1,2,3,4]; v.iter().fold(0, |sum, &x| sum + x)
[14:45:10] -rusti- 10
[14:45:16] <dbaupp> dcolish: oh, ok
[14:45:21] <dcolish> it really just parses pkg.rs, compiles, and calls run::process_status
[14:45:23] <cmr> doomlord: ord is some silly math thing about a < b not implying !(b < a)
[14:45:32] <dbaupp> dcolish: I see
[14:45:52] <dcolish> i do see comments about supporting that later
[14:45:53] <cmr> http://en.wikipedia.org/wiki/Total_order
[14:46:32] <dbaupp> dcolish: you should probably file a bug :)
[14:46:37] <dcolish> yeah
[14:46:54] <doomlord> is there a tutorial on rust's HOFs (map,filter,fold..)
[14:46:55] <dcolish> dont know if this is a bug in the compiler or rustpkg
[14:47:18] <dcolish> i wonder if i can reproduce by setting up the driver stuff and running that without rustpkg
[14:47:39] <dbaupp> doomlord: nope
[14:48:11] <dbaupp> doomlord: well, there is a "tutorial" in std::iterator. The definitions of the functions and the tests.
[14:48:21] <doomlord> lol :) ok
[14:48:40] <doomlord> tests...fair enough
[14:48:53] <dcolish> i like that, "the tests are the tutorial!"
[14:49:21] <dcolish> a riff on "the code is the documentation" :)
[14:49:31] <dbaupp> dcolish: well, it's not how it's meant to be
[14:49:41] <dbaupp> but it's what we've got right now
[14:50:33] <dcolish> no doubt
[14:50:47] <dcolish> its hard to write all that stuff and produce code and run a project, etc etc etc
[14:50:47] *** Quits: MaikKlein (maik@moz-129BB64.dip0.t-ipconnect.de) (Ping timeout)
[14:51:20] <dbaupp> I think strcat (who did the majority of the work with the iterators) has been asked to write something for 0.7
[14:51:25] <cmr> also code changes so fast that docs are almost out of date immediately
[14:51:36] * dbaupp isn't sure it'll be finished by then
[14:51:38] <cmr> dbaupp: he said he would too
[14:51:45] <dbaupp> cmr: hopefully
[14:51:45] <doomlord> i can imagine tests being easier to keep in sync..
[14:51:45] *** Joins: tav (tav@moz-5ED3AF3C.range86-152.btcentralplus.com)
[14:52:04] <cmr> like, steve klabnik wrote vec docs, and they were invalidated by an iterator pull request within the day :p
[14:52:09] <dbaupp> doomlord: well, yeah, it's compulsory that they're sync
[14:52:28] <SiegeLord> Aren't the code examples checked by make check?
[14:52:34] <doomlord> i'm guessing from what you've just shown you say [1,2,4,5].iter().fold(..) ..not [1,2,3,4].fold(..)
[14:52:41] <acrichto> r? https://github.com/mozilla/rust/pull/7113
[14:53:03] <dbaupp> doomlord: yes, for the moment
[14:53:03] <engla> doomlord: right, except rust requires you to store the vec in a variable at the moment
[14:53:17] *** Quits: xazax (Mibbit@6655692F.3B222813.3F580572.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[14:53:22] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Connection reset by peer)
[14:53:25] <engla> let v = [..]; v.iter().fold(...)
[14:53:39] *** Joins: sebcrozet (Mibbit@moz-6DA639AF.w80-13.abo.wanadoo.fr)
[14:53:56] <doomlord> i seem to be able to do [1,2,3].map() ... is that old?
[14:54:14] <dbaupp> doomlord: yes
[14:54:20] <doomlord> i seem to be able to do [1,2,3].map() ... is that old?
[14:54:24] <doomlord> oops
[14:54:25] *** Joins: sk (sk@61A494B3.BA40E8A.AAC02D62.IP)
[14:54:31] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[14:54:32] <sebcrozet> Is there a trait for object having a "default value" (kind of default constructor)?
[14:54:37] <acrichto> cmr: I think github is mixing up the commits, but 59f99db is actually the head of the request
[14:54:40] <dbaupp> engla: (the temporary storage is only required for literals)
[14:54:45] <cmr> acrichto: bah
[14:54:46] <engla> yeah
[14:54:54] <dbaupp> sebcrozet: "Zero" is a little bit like that
[14:54:58] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[14:54:59] *** Quits: illissius (illissius@moz-19397A63.catv.broadband.hu) (Ping timeout)
[14:55:11] <dbaupp> sebcrozet: but we're likely to invent `Empty` or `Default` or `Init` or something
[14:55:18] <acrichto> cmr: I think the commits are sorted chronologically instead of in a tree, but I'm not sure about that...
[14:55:31] <dbaupp> acrichto: yeah, I think so, I've noticed that too
[14:55:57] <doomlord> fn main() {
[14:55:57] <doomlord> 	let array=~[1i,4i,3i,10i,-15i];
[14:55:57] <doomlord> 	println((&array).to_str());
[14:55:57] <doomlord> 	println((&array).filter(|&x|{x>2}).to_str());
[14:55:57] <doomlord>  <<< not liking this, segmentation fault
[14:56:01] <sebcrozet> dbaupp: Great. Zero would be a bit wierd trait for that since it has the is_zero method.
[14:56:02] <engla> you can misrepresent a repo hilariously on github by just reversing the dates in the history
[14:56:14] <dbaupp> doomlord: .filter is bad
[14:56:31] <dbaupp> doomlord: (that's what's causing the segfault)
[14:57:05] <cmr> doomlord: you want .iter().filter()
[14:57:25] <dbaupp> (it's probably .filter_ because of #5898)
[14:57:29] <cmr> oh, right
[14:59:17] <doomlord> is that the permanent plan.. collection.iter().filter(..)
[14:59:30] <cmr> no
[14:59:38] <cmr> see http://cmr.github.io/blog/2013/06/22/this-week-in-rust/
[14:59:47] <cmr> it will be collection.filter(...) eventually
[14:59:57] *** Joins: Earnestly (earnest@87814665.5364A5FA.922AD825.IP)
[15:00:02] <doomlord> some convinience wrappers.. ok i'll read
[15:00:26] <cmr> Well .iter() is a compiler bug workaround  :p
[15:00:35] <doomlord> ah.... lol
[15:00:45] <engla> hm is it?
[15:00:47] <dbaupp> cmr: not entirely
[15:00:58] <doener> https://gist.github.com/dotdash/5850672 -- what the heck?
[15:00:59] <thiez> doomlord: http://pastebin.com/aEZtNz6M
[15:01:35] <cmr> doener: ...nice
[15:02:21] <doener> cmr: am I missing anything or are the last few blocks totally pointless?
[15:02:32] <cmr> doener: and the first few...
[15:03:05] <doener> yeah, but those empty blocks are "normal". The others are simple unreachable though
[15:03:08] <dbaupp> doener: that's presumably incorrect
[15:03:09] <cmr> Yeah
[15:03:25] <doener> s/simple/simply/
[15:03:29] <dbaupp> since I guess we want to actually call the rust_env_lock fns
[15:03:53] <doener> it's called once, in the <label>:1 block
[15:03:56] <dbaupp> (oh, right, it's being called in the first blcok)
[15:04:01] <dbaupp> :/
[15:04:13] *** Quits: sebcrozet (Mibbit@moz-6DA639AF.w80-13.abo.wanadoo.fr) (Quit: http://www.mibbit.com ajax IRC Client)
[15:04:30] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[15:04:30] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/jIQFUA
[15:04:30] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[15:05:57] <acrichto> r? https://github.com/mozilla/rust/pull/7291
[15:06:41] <dbaupp> acrichto: done
[15:06:47] <acrichto> dbaupp: thanks!
[15:07:26] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[15:07:26] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/JVmkrg
[15:07:26] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[15:07:29] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[15:07:29] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/MtuM2Q
[15:07:29] <ghrust> 13rust/06auto 144c2c606 15Alex Crichton: Rename all files with the 'rc' extension
[15:07:29] <ghrust> 13rust/06auto 1426b4af5 15Alex Crichton: Add the `warnings` lint attribute
[15:07:29] <ghrust> 13rust/06auto 1459f99db 15Alex Crichton: Deny common lints by default for lib{std,extra}
[15:07:30] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[15:07:43] <cmr> great timing
[15:07:52] <cmr> thiez: yay benchmark stuff landed!
[15:07:53] <dbaupp> cmr: (different PR)
[15:08:09] <cmr> dbaupp: I re-r+'d that one a few minutes ago
[15:08:20] <dbaupp> cmr: ah
[15:08:28] <dbaupp> cmr: in which case, I agree
[15:09:29] *** Joins: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com)
[15:11:03] <thiez> yay benchmarks :)
[15:11:23] <thiez> cmr: you were going to keep track of the benchmarks somewhere, correct?
[15:16:41] *** Quits: dbaupp (Thunderbir@moz-73E90475.lns20.syd6.internode.on.net) (Ping timeout)
[15:17:12] <cmr> thiez: As in actually running them?
[15:17:20] <doener> seems that something is wrong with the monomorphization
[15:17:35] <thiez> doomlord: I have a version without the copy now, should this interest you https://gist.github.com/Thiez/5850798
[15:17:58] <thiez> cmr: someone recently said they intended to keep track of the benchmark results, but I'm awful at remembering names
[15:18:07] <cmr> thiez: yeah that's me
[15:18:50] <cmr> thiez: still knocking the kinks out of the system
[15:19:17] <thiez> what values will you keep track of? runtime and memory I assume?
[15:19:40] <cmr> Yes, and it has to measure them independantly, because memory profiling skews runtime (although by a constant factor, afaict)
[15:19:53] <cmr> you've seen the memory graphs right?
[15:19:59] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[15:20:24] <thiez> yes, I like them
[15:20:52] <thiez> and they already sort-of contain the runtime
[15:21:05] <cmr> right, it's just not a very accurate measure of runtime
[15:22:10] *** Joins: jhark (jhark@moz-B9920504.jhark.net)
[15:23:30] *** Joins: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[15:24:19] *** Quits: jaen (jaen@moz-27C20102.play-internet.pl) (Ping timeout)
[15:25:15] *** Joins: ysuzuki (ysuzuki@moz-285468F7.net219126120.t-com.ne.jp)
[15:26:17] *** Joins: H4199 (chatzilla@moz-64E556D3.austin.res.rr.com)
[15:29:17] *** Quits: Blub\w (wry@moz-74348AEB.wireless.dyn.drei.com) (Ping timeout)
[15:29:50] *** kimundi is now known as zz_kimundi
[15:32:58] *** Quits: hansjorg_ (hansjorg@moz-41C5CE61.redpill-linpro.com) (Quit: leaving)
[15:33:38] *** Joins: hansjorg_ (hansjorg@moz-41C5CE61.redpill-linpro.com)
[15:37:10] <steven_is_false> Bleh, I really wish once functions were implemented.
[15:37:32] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[15:37:39] <cmr> steven_is_false: https://github.com/mozilla/rust/pull/7244
[15:38:19] <steven_is_false> cmr: Great!
[15:38:44] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[15:39:20] *** Joins: jaen (jaen@moz-9968C5CB.play-internet.pl)
[15:41:13] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[15:41:20] *** Quits: jpochyla (jpochyla@E1DB45DB.1AFA5C43.5DC06702.IP) (Ping timeout)
[15:44:54] *** Joins: tjc (tjc@moz-BBBC84F5.static.lnbh.ca.charter.com)
[15:44:54] *** ChanServ sets mode: +o tjc
[15:45:32] <cmr> tjc: I think it was SiegeLord who would really like a design document for rustpkg, he also had some concerns (how was open source bridge?)
[15:45:50] *** Joins: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[15:46:00] *** Joins: jpochyla (jpochyla@E1DB45DB.1AFA5C43.5DC06702.IP)
[15:46:05] <SiegeLord> I was going to write up an email, but first I wanted to check what other languages did
[15:46:20] <tjc> SiegeLord: Were you looking for something that wasn't in the (admittedly bare-bones) documentation for rustpkg?
[15:46:26] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[15:46:42] <tjc> that is: https://github.com/mozilla/rust/blob/master/doc/rustpkg.md
[15:47:20] <tjc> OSB was great -- a pretty good amount of questions
[15:47:26] <bjz_> what do once functions do? why are they useful?
[15:47:52] <cmr> bjz_: they ensure a closure is only called once, so you can move into it
[15:48:01] <cmr> or, rather, move from out of your environment
[15:48:04] <bjz_> ah ok
[15:48:09] <SiegeLord> tjc: I'd need a lot of text to express my concerns... heh
[15:48:10] <bjz_> makes sense
[15:48:23] <cmr> bblum described why/what they are useful for a lot in last week's meeting
[15:48:38] <tjc> SiegeLord: Heh, well, as I understand it, we're modeling it on Go pretty closely. my understanding of what Go does is pretty much secondhand through graydon :-)
[15:48:52] <cmr> tjc: you saw the go horror story, yeah?
[15:49:01] <tjc> cmr: which one? ;-)
[15:49:05] <bjz_> ?
[15:49:16] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[15:49:16] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/31LnTg
[15:49:16] <ghrust> 13rust/06auto 141841b31 15Alex Crichton: Add 'static mut' items to the language
[15:49:16] <ghrust> 13rust/06auto 148fdc8f3 15Alex Crichton: Support foreign 'static mut' variables as well
[15:49:17] <ghrust> 13rust/06auto 14b94f89f 15Alex Crichton: Fix 'static mut' tests
[15:49:18] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[15:49:32] <thiez> ooh, we have globals now?
[15:49:40] <bjz_> that kickstarter project?
[15:49:50] <cmr> bjz_: yeah that's the one
[15:49:55] <thiez> bjz_: https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-06-18 <- talking about once fns
[15:49:58] <cmr> I can't find it now
[15:50:06] <SiegeLord> tjc: The two big concerns are: I think the current design conflates the location you get the package with the package identity and that the workspaces seem counterintuitive to how I expect packages to behave (e.g. .deb/.rpm)
[15:51:34] <tjc> SiegeLord: Hmm, well, currently in rustpkg we want packages to be self-describing, so I'm not sure how to get around the first concern
[15:51:38] <tjc> can you elaborate on the second concern?
[15:51:59] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[15:52:13] <doener> cmr: http://www.kickstarter.com/projects/2066438441/haunts-the-manse-macabre/posts/373466
[15:52:16] <doener> this one?
[15:52:44] <tjc> Oh, yeah, I did see that
[15:52:46] <SiegeLord> tjc: Re the first thing... we already have the #[link] attribute, it seems rustpkg proposes a parallel crate identity specification method
[15:52:50] <cmr> doener: yeah
[15:53:02] <SiegeLord> I found that they don't interact well with each other
[15:53:21] <tjc> SiegeLord: It's more like that if you leave out the #[link] attribute, rustpkg will fill in defaults inferred from package location
[15:53:27] <tjc> but you can still override that
[15:53:43] <SiegeLord> As for the second... I sort of expect rustpkg install to install to some central location, rather than the current directory
[15:53:50] *** Joins: MaikKlein (maik@moz-129BB64.dip0.t-ipconnect.de)
[15:54:22] <cmr> steven_is_false: the cleanups you have been doing are great btw, don't stop :)
[15:54:34] <tjc> as far as preventing the problem that kickstarter project had, I opened https://github.com/mozilla/rust/issues/6480
[15:54:47] *** Joins: Excureo (c@moz-B0B6F5C3.static.knwc.wa.charter.com)
[15:54:49] <tjc> basically saying "make locally cached code read-only"
[15:54:56] <steven_is_false> cmr: :)
[15:55:07] <tjc> SiegeLord: You can still override where it installs to by setting the RUST_PATH, but that's not implemented yet
[15:56:29] *** Parts: Tad (Tom@moz-2036EE54.kimsufi.com) (Leaving)
[15:56:40] <cmr> SiegeLord: fwiw it's similar to what npm does right now, although slightly more obtuse in that it's a hidden directory
[15:56:57] <MaikKlein> haha do you often missclick on close & comment on github too?
[15:57:48] <SiegeLord> My only experience with packages is the Debian .deb business... so this alternate method seemed puzzling to me
[15:58:50] <thiez> MaikKlein: I once accidentally closed (and subsequently reopened) the same issue twice in five minutes ><
[16:00:32] <bblum> steven_is_false: are you stewartgallus
[16:00:41] *** Joins: jensnock_ (jensnocker@moz-8BE55278.customer.t3.se)
[16:01:13] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Ping timeout)
[16:02:19] <cmr> bblum: missed a leading s, but yes he is
[16:02:38] <SiegeLord> But anyway, my issues need thinking and expansion... IRC is not a good medium for me :P
[16:02:40] <steven_is_false> bblum: Yes
[16:02:48] <steven_is_false> I am Steven Stewart-Gallus
[16:03:11] <MaikKlein> thiez, haha I always read too fast. It's like blablabla comment for me :(
[16:03:13] <bblum> and also false, apparently
[16:03:30] <steven_is_false> IRC is informal for me, and so I go by steven_is_false. GitHub is formal so I go by sstewartgallus there.
[16:03:44] *** Joins: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP)
[16:03:45] <bblum> steven_is_false: so the problem with one-shot closures is we decided against putting them in 1.0
[16:03:54] <MaikKlein> does rusti here use -O or not?
[16:04:02] <steven_is_false> bblum: okay?
[16:04:05] <bblum> you'll note in my pull request that for stack closures, you don't get the move-out privilege unless you compile with -Z once-fns
[16:04:31] <bblum> but not for heap closures, since those will be... replaced... anyway
[16:04:57] <bblum> with a macro-generated trait kind of thing that will let you move out anyway (that exploits explicit-self)
[16:05:54] *** Quits: jensnock_ (jensnocker@moz-8BE55278.customer.t3.se) (Ping timeout)
[16:06:09] *** Quits: bstrie (ben@moz-D5A1D0F5.members.linode.com) (Quit: leaving)
[16:06:12] <indutny> nmatsakis: hoya
[16:06:14] <indutny> yt?
[16:06:24] <steven_is_false> Isn't using a trait going to be slow because of an extra degree of indirection through the vtable?
[16:06:36] <cmr> steven_is_false: only trait objects use vtables
[16:07:13] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[16:07:29] <steven_is_false> cmr: And bblum was stating that heap once closures will be replaced by a macro-generated trait kind of thing.
[16:07:52] <MaikKlein> does the IRC rusti use optimize?
[16:08:08] <bblum> steven_is_false: vtable will be no slower than the old way
[16:08:16] <cmr> MaikKlein: I dunno.. I think it does, you would have to ask strcat when he is online
[16:08:16] <bblum> a closure is a trait with a 1-element vtable
[16:08:38] <steven_is_false> bblum: That seems ugly that a closure is a 1-element vtable.
[16:08:59] <bblum> why
[16:09:04] <MaikKlein> cmr, someone from before said that it doesn't use -O right? because the .sqrt bug may only happen on -O
[16:09:12] <steven_is_false> Maybe I'm mistaken about how vtables are implemented in Rust?
[16:09:32] *** Joins: eschweic (Adium@2557E599.66715431.D25A875A.IP)
[16:10:05] <bblum> steven_is_false: think about how a closure must be represented
[16:10:07] <steven_is_false> bblum: Anyways I'll trust that there are good reasons for things being the way they are.
[16:10:14] <bblum> a pair of a function pointer an an environment packet, right?
[16:10:43] <bblum> compare that to how a trait with "fn run()" looks in memory
[16:10:52] <thiez> MaikKlein: we tested in this channel, and (-5.0).sqrt() was 0
[16:10:59] <thiez> rusti: (-5.0f32).sqrt()
[16:11:00] -rusti- 0
[16:11:13] *** Quits: jpochyla (jpochyla@E1DB45DB.1AFA5C43.5DC06702.IP) (Ping timeout)
[16:12:05] *** Joins: themgt (themgt@moz-453E9466.phlapa.fios.verizon.net)
[16:12:05] *** Quits: themgt (themgt@moz-453E9466.phlapa.fios.verizon.net) (Client exited)
[16:12:43] <MaikKlein> rusti: (-5.0f).sqrt()
[16:12:43] -rusti- 0
[16:12:43] <cmr> doener: what are you working on atm?
[16:12:54] <MaikKlein> rusti: (-0.5f).sqrt()
[16:12:55] -rusti- 0
[16:13:00] <MaikKlein> hm
[16:13:21] *** Joins: jpochyla (jpochyla@E1DB45DB.1AFA5C43.5DC06702.IP)
[16:14:02] <doener> cmr: writing a bug report for the repeated function body. Been working on a refactor on block_, but using methods on Block is way too slow, so I'm back at trying to get rid of the double indirection on self
[16:14:14] <MaikKlein> rusti: -0.5f.sqrt()
[16:14:15] -rusti- -0.70710678
[16:14:22] *** Parts: mw (mw@moz-7FBFE83C.adsl.highway.telekom.at) ()
[16:14:25] <MaikKlein> rusti: (-0.5f).sqrt()
[16:14:26] -rusti- 0
[16:14:31] <cmr> doener: were you going to look at the pathological behavior of match?
[16:14:46] <MaikKlein> now I am confused
[16:15:03] <cmr> MaikKlein: -0.5f.sqrt() is -(0.5f.sqrt())
[16:15:10] <thiez> MaikKlein: rusti also accepts queries. The -0.5f.sqrt() one 'works' because it is parsed as -(0.5f.sqrt())
[16:15:46] <doener> cmr: the block refactoring was a first step in that direction... When I tried to tackle the empty blocks caused by scoping, I ran into dynamic borrow failures again, and tried to get those turned into static ones
[16:16:04] <MaikKlein> yes thats why i tested it with 
[16:16:04] <MaikKlein> rusti:(-(0.5f)).sqrt()
[16:16:06] -rusti- 0
[16:16:08] <MaikKlein> hm
[16:16:26] <MaikKlein> either way
[16:16:35] <MaikKlein> is 0 correct?
[16:16:40] <cmr> no
[16:16:48] <cmr> it should be NaN
[16:16:53] <MaikKlein> NaN shouldn't be a number
[16:16:53] <MaikKlein> y
[16:17:27] <cmr> rusti: std::Float::NaN::<f64>()
[16:17:28] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/ZSFC
[16:17:38] <MaikKlein> rusti: (-0.5f).sqrt().is_NaN
[16:17:38] -rusti- <anon>:9:9: 9:30 error: attempted to take value of method `is_NaN` on type `float` (try writing an anonymous function)
[16:17:38] -rusti- <anon>:9          (-0.5f).sqrt().is_NaN
[16:17:38] -rusti-                   ^~~~~~~~~~~~~~~~~~~~~
[16:17:38] -rusti- error: aborting due to previous error
[16:17:39] -rusti- application terminated with error code 101
[16:17:42] <cmr> rusti: std::num::Float::NaN::<f64>()
[16:17:43] -rusti- NaN
[16:18:00] <MaikKlein> rusti: (-0.5f).sqrt().is_NaN()
[16:18:00] -rusti- false
[16:18:07] <thiez> let nan = 0.0/0.0; nan
[16:18:11] <thiez> rusti: let nan = 0.0/0.0; nan
[16:18:12] -rusti- NaN
[16:18:17] <thiez> that's how you get one :)
[16:18:33] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[16:18:37] <steven_is_false> rusti: botsnack
[16:18:38] -rusti- "nom nom"
[16:18:50] <steven_is_false> rusti: "fetch"
[16:18:50] -rusti- "fetch"
[16:19:17] <steven_is_false> rusti: [1, 2, 3] + [1]
[16:19:18] -rusti- <anon>:9:9: 9:24 error: binary operation + cannot be applied to type `[<VI2>, .. 3]`
[16:19:18] -rusti- <anon>:9          [1, 2, 3] + [1]
[16:19:18] -rusti-                   ^~~~~~~~~~~~~~~
[16:19:18] -rusti- error: aborting due to previous error
[16:19:18] -rusti- application terminated with error code 101
[16:19:23] <steven_is_false> rusti: ~[1, 2, 3] + [1]
[16:19:24] -rusti- ~[1, 2, 3, 1]
[16:19:37] <steven_is_false> rusti: botsnack
[16:19:38] -rusti- "nom nom"
[16:19:46] <steven_is_false> rusti: "Good boy!"
[16:19:46] -rusti- "Good boy!"
[16:19:51] <thiez> botsnack.slice(0,3)
[16:19:55] <thiez> rusti: botsnack.slice(0,3)
[16:19:56] -rusti- "nom"
[16:20:11] <jedestep> any suggestions on how i could create something akin to a mock object?
[16:20:15] <thiez> you can probably get its 'magic' values by telling it to print its source file
[16:20:29] <jedestep> i would like to test my network code without, you know, having sockets open all over the place
[16:20:57] <thiez> if the network API uses traits, then you could easily create mock implementations
[16:21:00] *** Quits: tjc (tjc@moz-BBBC84F5.static.lnbh.ca.charter.com) (Ping timeout)
[16:21:13] <thiez> I don't know if that is the case however
[16:21:33] <jedestep> sadly it does not appear to use traits
[16:21:39] <jedestep> that was my initial thought
[16:21:40] *** Joins: tjc (tjc@moz-BBBC84F5.static.lnbh.ca.charter.com)
[16:21:40] *** ChanServ sets mode: +o tjc
[16:23:50] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[16:23:54] *** Quits: sankha93 (Instantbir@BA7CBBCC.291909EC.8B6C1D65.IP) (Quit: Instantbird 1.4 -- http://www.instantbird.com)
[16:24:05] <thiez> then perhaps you could copy the io-stuff, put it in your own mod, and then 'use std::io = mymod::io;'
[16:24:32] <thiez> (yes, inconvenient)
[16:24:41] *** Joins: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net)
[16:24:50] <jedestep> well at least the impact is somewhat minimized since the tests are in their own mod
[16:25:32] *** Joins: eholk (eholk@moz-3EC295FB.uconnect.utah.edu)
[16:25:40] <MaikKlein> btw
[16:25:58] <MaikKlein> [1,2,3,4] is not a more like an array right?
[16:25:58] *** Joins: seth (seth@FA4B6067.3BBD3C46.DD3002AF.IP)
[16:26:09] <MaikKlein> do we still call this a vector in rust?
[16:26:13] *** Joins: dualhbridge (dad@moz-9FEE6D3B.maine.res.rr.com)
[16:26:14] *** Joins: bnicholson (bnicholson@2557E599.66715431.D25A875A.IP)
[16:26:26] <cmr> MaikKlein: it's called a fixed-size vector afaik..
[16:26:59] <thiez> you'll usually want to use &[] tho
[16:28:55] *** Parts: dualhbridge (dad@moz-9FEE6D3B.maine.res.rr.com) ()
[16:28:57] *** zz_kimundi is now known as kimundi
[16:29:22] <MaikKlein> rusti: let a = [1,2,3,4]; let b=a; a[0]
[16:29:22] -rusti- <anon>:9:32: 9:33 warning: unused variable: `b` [-W unused-variable (default)]
[16:29:23] -rusti- <anon>:9          let a = [1,2,3,4]; let b=a; a[0]
[16:29:23] -rusti-                                          ^
[16:29:23] -rusti- 1
[16:29:26] <engla> and &[] is a slice
[16:29:46] <MaikKlein> so [] doesn't get moved by default
[16:29:51] *** Joins: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca)
[16:30:00] <MaikKlein> ok wouldn't make too much sense
[16:30:10] <MaikKlein> or ..
[16:30:10] <MaikKlein> hm
[16:30:58] <MaikKlein> btw if I have 1000 tasks but all of those should read from a [], is the possible?
[16:31:12] <cmr> if it's static, yes
[16:31:17] <cmr> You really don't want [] though
[16:31:19] <MaikKlein> to share constant information even if it is task local memory
[16:31:26] <cmr> It's also not [], it's [,..n]
[16:31:29] <cmr> fixed length n
[16:32:14] <MaikKlein> would [1,2,3,4] be static by default?
[16:32:25] *** Quits: seth (seth@FA4B6067.3BBD3C46.DD3002AF.IP) (Input/output error)
[16:32:28] <MaikKlein> ok yeah probably
[16:32:38] <MaikKlein> or
[16:32:54] <cmr> no, nothing is a static by default
[16:32:56] <MaikKlein> rusti: let a = [1,2,3,4]; a[0] = 1
[16:32:56] -rusti- <anon>:9:28: 9:31 error: cannot assign to immutable vec content
[16:32:56] -rusti- <anon>:9          let a = [1,2,3,4]; a[0] = 1
[16:32:56] -rusti-                                      ^~~
[16:32:56] -rusti- error: aborting due to previous error
[16:32:56] -rusti- application terminated with error code 101
[16:33:22] <cmr> rusti: static x: &'static [uint] = &[1, 2, 3, 4, 5]; x
[16:33:23] -rusti- &[1, 2, 3, 4, 5]
[16:34:05] *** Joins: seth (seth@FA4B6067.3BBD3C46.DD3002AF.IP)
[16:35:23] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzz)
[16:36:08] *** Quits: z0w0 (zack@moz-DD233ABD.lnse4.woo.bigpond.net.au) (Client exited)
[16:38:28] *** Quits: seth (seth@FA4B6067.3BBD3C46.DD3002AF.IP) (Ping timeout)
[16:39:30] *** Joins: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[16:39:51] *** Parts: steven_is_false (user@moz-144077DE.bchsia.telus.net) (ERC Version 5.3 (IRC client for Emacs))
[16:40:47] <thiez> soon: static x: &'static mut [uint] = &mut [1,2,3,4,5]; :D
[16:41:45] *** kimundi is now known as zz_kimundi
[16:41:56] *** Quits: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu) (Ping timeout)
[16:42:20] *** Joins: seth (seth@FA4B6067.3BBD3C46.DD3002AF.IP)
[16:45:08] <cmr> thiez: static mut x, no?
[16:45:31] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Quit: jedestep)
[16:45:35] <cmr> hm
[16:45:40] <thiez> cmr: I don't know, I haven't looked at the PR in detail
[16:45:45] <cmr> acrichto: did you look into how static mut interacts with #[static_assert]?
[16:45:46] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[16:46:05] <acrichto> cmr: it's a compiler error to put a static_assert on a 'static mut'
[16:46:33] <cmr> acrichto: ICE or explicit failure?
[16:46:33] <acrichto> cmr: https://github.com/mozilla/rust/pull/7291/files#L12R2133
[16:46:34] *** Quits: seth (seth@FA4B6067.3BBD3C46.DD3002AF.IP) (Ping timeout)
[16:46:40] <acrichto> explicit failure
[16:46:45] <cmr> oh, ok
[16:46:46] <cmr> nice :)
[16:47:18] *** Quits: MaikKlein (maik@moz-129BB64.dip0.t-ipconnect.de) (Ping timeout)
[16:48:19] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[16:48:19] *** ChanServ sets mode: +o dherman
[16:49:47] *** Joins: graydon (graydon@3853DDD.39EEDBB3.D758B1AA.IP)
[16:49:47] *** ChanServ sets mode: +qo graydon graydon
[16:49:48] *** Quits: yoshi (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[16:50:01] *** Joins: mark_edward (quassel@moz-4A5B1251.wisolt4.epbfi.com)
[16:50:07] *** Joins: Blub\w (wry@moz-74348AEB.wireless.dyn.drei.com)
[16:50:24] *** Joins: seth (seth@FA4B6067.3BBD3C46.DD3002AF.IP)
[16:50:29] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[16:50:30] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[16:52:05] *** Joins: Palmik (palmik@moz-CC484FDD.tmcz.cz)
[16:52:31] <cmr> pauls: ping
[16:52:40] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[16:52:53] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[16:52:55] <indutny> nmatsakis: ping
[16:52:55] *** Quits: Palmik (palmik@moz-CC484FDD.tmcz.cz) (Quit: leaving)
[16:52:59] *** Joins: Palmik (palmik@moz-CC484FDD.tmcz.cz)
[16:53:12] *** Joins: nano (nano@moz-972880B.superkabel.de)
[16:54:00] <SiegeLord> Why do static variables require type annotation?
[16:54:19] *** Quits: Aetherspawn (Aetherspaw@moz-8811D9F0.static.tpgi.com.au) (Connection reset by peer)
[16:55:41] <thiez> SiegeLord: could you give an example?
[16:56:00] <SiegeLord> rusti: static a = 5;
[16:56:00] -rusti- <anon>:9:18: 9:19 error: expected `:` but found `=`
[16:56:00] -rusti- <anon>:9          static a = 5;
[16:56:00] -rusti-                            ^
[16:56:01] -rusti- application terminated with error code 101
[16:56:08] <SiegeLord> rusti: static a : int = 5;
[16:56:10] -rusti- ()
[16:56:24] <thiez> that one is really not surprising
[16:56:37] <nmatsakis> indutny: pong
[16:56:43] <SiegeLord> thiez: Why not?
[16:56:48] <thiez> rusti: fn foo() { let a = 5; } foo() ; "Done"
[16:56:49] -rusti- <anon>:9:24: 9:25 warning: unused variable: `a` [-W unused-variable (default)]
[16:56:49] -rusti- <anon>:9          fn foo() { let a = 5; } foo() ; "Done"
[16:56:49] -rusti-                                  ^
[16:56:49] -rusti- "Done"
[16:56:53] <thiez> oh, it works?
[16:56:56] * thiez is surprised.
[16:56:57] *** Joins: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[16:57:06] <thiez> since when does that work? :p
[16:57:55] <thiez> what is more surprising is that static a = 5i32; does not work
[16:57:56] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[16:58:18] <SiegeLord> Maybe it's a compiler pass thing... like it can't typecheck at that time
[16:58:26] <thiez> it's a parser thing where the type is not optional, perhaps rust type inference can't do it.
[16:59:52] *** zz_kimundi is now known as kimundi
[17:00:37] <indutny> nmatsakis: pang
[17:00:41] *** Quits: eschweic (Adium@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[17:00:45] <indutny> nmatsakis: can you please take a look at https://github.com/mozilla/rust/pull/7351
[17:00:49] <indutny> once you'll have a free minute
[17:01:24] <indutny> particularly at this https://github.com/indutny/rust/commit/f868ef0a7e5d85978210ab93e4f51ea9565a8ac3
[17:01:32] <nmatsakis> indutny: ok. I'm at a conference today so I'll be slow
[17:01:37] <indutny> ah
[17:01:38] <indutny> well
[17:01:46] <indutny> ok, any help would be welcome anyway
[17:01:47] <indutny> :)
[17:01:49] <nmatsakis> indutny: what is the question about this commit?
[17:01:51] <indutny> trying to fix #5898
[17:02:09] <indutny> nmatsakis: its fixing bug with multiple extensions with the same method names
[17:02:11] <nmatsakis> indutny: warning, I have a total rewrite of that code in progress :)
[17:02:17] <indutny> nmatsakis: aaaah, finally :)
[17:02:18] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[17:02:18] <indutny> ok
[17:02:23] <graydon> SiegeLord: generally because our rule has been "items can be checked and translated independently", also to some extent for documentation. same sort of reasons functions require full signatures.
[17:02:24] <indutny> nmatsakis: will it fix the problem?
[17:02:33] <nmatsakis> indutny: I don't know, not sure which problem you're looking at, gimme a sec 
[17:02:42] *** Quits: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP) (Ping timeout)
[17:02:52] <indutny> nmatsakis: method::lookup isn't taking in account trait bounds in impl
[17:02:58] *** Quits: jpochyla (jpochyla@E1DB45DB.1AFA5C43.5DC06702.IP) (Ping timeout)
[17:02:58] <indutny> basically this problem
[17:03:05] <graydon> SiegeLord: "whole program inference" is something we have considered a bit of a .. potential cognitive burden
[17:03:06] <indutny> nmatsakis: when choosing candidates
[17:03:07] *** Joins: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP)
[17:03:10] <nmatsakis> indutny: ah, this is a tricky problem, rather subtle.
[17:03:16] *** Joins: eschweic (Adium@2557E599.66715431.D25A875A.IP)
[17:03:22] <indutny> nmatsakis: yes, there're not enough info at this stage
[17:03:33] <indutny> nmatsakis: I thought about changing code to allow propagating multiple candidates
[17:03:38] <nmatsakis> indutny: it's actually not obvious how to even SPECIFY the right behavior;
[17:03:42] <indutny> nmatsakis: and choosing one at resolution phase
[17:03:44] <nmatsakis> indutny: i've been working on a write-up,
[17:03:49] <nmatsakis> indutny: specifying what we hsould do,
[17:04:04] <nmatsakis> indutny: and suggesting a unified algorithm that unifies the method-call machinery + vtable-matching machinery,
[17:04:17] <indutny> yikes
[17:04:20] <nmatsakis> indutny: basically we hvae two bits of code that both do the same thing, and neithre one does it sufficiently.
[17:04:26] <indutny> yep
[17:04:34] <indutny> they need each other
[17:04:43] <indutny> but run in separate phases
[17:04:46] *** Joins: Blei (Philipp@moz-650B9C6A.cust.bluewin.ch)
[17:05:02] *** Joins: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP)
[17:05:07] <cmr> graydon: Also the inference missing right now is all the inference that has ABI implications. I do not think inference should ever touch an ABI
[17:05:09] <nmatsakis> indutny: yes, so I was working on unifying them into one thing, and eliminating the phasing altogether.
[17:05:19] *** Quits: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk) (Ping timeout)
[17:05:34] <indutny> nmatsakis: great!
[17:05:40] <indutny> looks like I can walk around
[17:05:43] <indutny> and have some rest, finally
[17:05:51] <Blei> hi, could someone who's not on windows compile this code: https://gist.github.com/Blei/5851645
[17:05:52] <indutny> but anyway, I learned a lot
[17:06:00] <Blei> and tell me if llvm dies or not?
[17:06:01] <nmatsakis> indutny: the writeup I was talking about has been long delayed, but it's high priority for me right now,
[17:06:08] <indutny> cool
[17:06:22] <nmatsakis> indutny: so I hope to finish it up this week, maybe next week
[17:06:30] <cmr> Blei: llvm does with rustc: ../../../../../src/llvm/include/llvm/Support/Casting.h:231: typename enable_if<is_same<Y, typename simplify_type<Y>::SimpleType>, typename cast_retty<X, Y *>::ret_type>::type llvm::cast(Y *) [X = llvm::Function, Y = llvm::Value]: Assertion `isa<X>(Val) && "cast<Ty>() argument of incompatible type!"' failed.
[17:06:30] <indutny> please let me know if I can help you
[17:06:42] <Blei> cmr: ok, thanks
[17:06:49] <nmatsakis> indutny: ok, I'll ping you 
[17:06:56] <Blei> cmr: that's the reason my intrinsic overhaul died on windows
[17:07:02] <indutny> nmatsakis: just in case - my email is fedor@indutny.com
[17:07:26] <Blei> it only died on windows because of the combined run-pass tests...
[17:07:48] <cmr> Blei: ah. well, good thing it's not some funky windows-specific stuff, right? :)
[17:08:02] <Blei> very true!
[17:08:21] <SiegeLord> graydon: Thanks, that makes sense
[17:08:27] *** Quits: seth (seth@FA4B6067.3BBD3C46.DD3002AF.IP) (Ping timeout)
[17:08:38] *** Quits: pnkfelix1 (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net) (Quit: Leaving.)
[17:08:52] <indutny> cmr: may I ask you to r? it again https://github.com/mozilla/rust/pull/7257 ?
[17:09:02] <indutny> I think I've fixed windows build failure
[17:09:02] <nmatsakis> indutny: ok.
[17:09:18] *** Joins: ecr (ereed@2557E599.66715431.D25A875A.IP)
[17:09:24] *** Quits: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP) (Quit: eatkinson)
[17:09:30] <cmr> indutny: promise? :p
[17:09:39] *** Joins: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP)
[17:09:58] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[17:10:03] <indutny> cmr: not really
[17:10:08] <indutny> don't have any win machine at hand
[17:10:22] <indutny> but it should work
[17:10:27] <indutny> if rustc has reported all errors there
[17:11:27] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[17:11:48] *** Quits: pnkfelix|rcirc (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net) (Input/output error)
[17:12:15] *** Quits: mark_edward (quassel@moz-4A5B1251.wisolt4.epbfi.com) (Client exited)
[17:12:16] <steven_is_false> I want to fix extra::arc::RWARC so I can move owned data inside the closure passed to write.
[17:12:32] <steven_is_false> The usual way of doing this would be to add a write_with method but this is clunky.
[17:12:43] *** Joins: seth (seth@FA4B6067.3BBD3C46.DD3002AF.IP)
[17:12:51] <steven_is_false> Would I have to add a write_cond_with method as well?
[17:14:07] *** Parts: steven_is_false (user@moz-144077DE.bchsia.telus.net) (ERC Version 5.3 (IRC client for Emacs))
[17:15:09] *** Quits: Blei (Philipp@moz-650B9C6A.cust.bluewin.ch) (Connection reset by peer)
[17:15:40] *** Joins: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk)
[17:16:09] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[17:16:09] *** ChanServ sets mode: +o brson
[17:16:21] *** Quits: seth (seth@FA4B6067.3BBD3C46.DD3002AF.IP) (Connection reset by peer)
[17:17:01] *** Joins: mschifer (Adium@2557E599.66715431.D25A875A.IP)
[17:17:02] *** Joins: azita (Azita@2557E599.66715431.D25A875A.IP)
[17:17:40] *** Joins: Blei (philipp@moz-650B9C6A.cust.bluewin.ch)
[17:20:03] <doomlord> with teething problems .. rust should still be better thn plain C , i guess? does anyone here genuinely finnd it more productive than advanced  mature languages yet
[17:20:30] <cmr> teething problems?
[17:20:41] <doomlord> compiler bugs
[17:20:53] <SiegeLord> I'm sure I'll never make a malloc bug with Rust... that's a common error in C for me
[17:20:55] *** Quits: tjc (tjc@moz-BBBC84F5.static.lnbh.ca.charter.com) (Ping timeout)
[17:20:55] <doomlord> there are a few aren't there
[17:21:19] *** Joins: tjc (tjc@moz-BBBC84F5.static.lnbh.ca.charter.com)
[17:21:19] *** ChanServ sets mode: +o tjc
[17:21:31] <cmr> more than a few :P
[17:21:43] *** Quits: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk) (Ping timeout)
[17:21:59] <pauls> cmr: pong
[17:22:20] <cmr> pauls: do you know why gensym is part of the libsyntax interner and why it does what it does?
[17:22:25] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[17:22:25] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 143dac414 to 14c6515ee: 02http://git.io/N3iJvQ
[17:22:25] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[17:22:27] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[17:22:27] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/Ah1vrA
[17:22:27] <ghrust> 13rust/06auto 14079b07d 15Fedor Indutny: libc: support functions from sys/mman.h...
[17:22:27] <ghrust> 13rust/06auto 14ddd6f59 15Fedor Indutny: libc: add POSIX-compatible sysconf consts...
[17:22:27] <ghrust> 13rust/06auto 14b0aa882 15Fedor Indutny: libc: (u)int => c_(u)int for consts
[17:22:29] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[17:22:33] *** Joins: mark_edward (quassel@moz-4A5B1251.wisolt4.epbfi.com)
[17:22:42] <cmr> I'm working on a new interner (trait) (hopefully shared with servo, maybe) https://gist.github.com/cmr/5846269
[17:22:54] <pauls> cmr: It might be used; if not, it's just because I expected hygiene to use it.
[17:23:13] <doomlord> are most of your users c++ refugees, or coming from elsewhere (eg expecting haskell features or whatever)
[17:23:33] <cmr> pauls: well what it does is add the string into the internal array, but not to the internal hashmap (ie, you can reintern an identical string and get a new id)
[17:23:46] <cmr> doomlord: a lot of us are C/C++ refugees I think.
[17:23:47] <doomlord> i gather the go community is more people advancing from scripting languages than c++ migrants
[17:23:56] <pauls> cmr: right; I think I used it in a couple places.
[17:24:14] <cmr> pauls: is there any particular reason the regular intern method couldn't be used?
[17:24:18] <pauls> The name comes from Scheme.
[17:24:37] <pauls> The goal is to make a fresh symbol that can't collide with anything else.
[17:24:50] <cmr> yes but the interner doesn't actually do that, another function (fresh_name) does that
[17:24:59] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[17:25:03] *** Quits: tjc (tjc@moz-BBBC84F5.static.lnbh.ca.charter.com) (Ping timeout)
[17:25:05] <pauls> Instead of naming something `temp` in generated code...
[17:25:17] <pauls> ...since `temp` might be used by someone else...
[17:25:44] <pauls> ...you come up with a "name" whose spelling is irrelevant.
[17:26:24] *** Quits: Boreeas (Boreeas@moz-F35C832D.boreeas.net) (Quit: ZNC - http://znc.in)
[17:26:25] <pauls> It doesn't get added to the table, so that no one can generate the same identifier, regardless of what name they pick.
[17:26:58] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[17:27:05] <cmr> ah so it's the tag that matters to the rest of the code, not the string representation?
[17:27:21] <pauls> cmr: yes, the string is just to display to users.
[17:27:21] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[17:27:31] *** Joins: Boreeas (Boreeas@moz-F35C832D.boreeas.net)
[17:27:33] <cmr> pauls: alright, that's the bit I wasn't getting, thanks!
[17:27:46] <pauls> cmr: sorry! Happy to help!
[17:28:02] *** Joins: tjc (tjc@moz-BBBC84F5.static.lnbh.ca.charter.com)
[17:28:02] *** ChanServ sets mode: +o tjc
[17:28:22] *** Joins: echristo (echristo@D423593A.D6CCE4AE.77834EAA.IP)
[17:29:35] *** Quits: paulproteus (quassel@rose.makesad.us) (Ping timeout)
[17:29:51] *** Quits: tjc (tjc@moz-BBBC84F5.static.lnbh.ca.charter.com) (Ping timeout)
[17:30:15] *** Joins: tjc (tjc@moz-BBBC84F5.static.lnbh.ca.charter.com)
[17:30:15] *** ChanServ sets mode: +o tjc
[17:31:25] *** Joins: paulproteus (quassel@moz-E86A3B42.makesad.us)
[17:31:40] <graydon> I have been thinking it might be nice to establish a new set of tests in the testsuite that do 3-way comparisons for "code equivalences"
[17:31:57] *** Quits: tjc (tjc@moz-BBBC84F5.static.lnbh.ca.charter.com) (Ping timeout)
[17:32:02] <graydon> that is, write something using high level constructs, then write the same thing using low level constructs, then write the same thing in (say) C
[17:32:17] <graydon> and check that the un-optimized and/or optimized versions wind up roughly the same, size-wise
[17:32:24] <doomlord> thats a brilliant idea, i was going to ask for such a thing
[17:32:28] *** Joins: tjc (tjc@moz-BBBC84F5.static.lnbh.ca.charter.com)
[17:32:28] *** ChanServ sets mode: +o tjc
[17:33:21] *** Quits: CarpNet (ac@moz-FD24B77.sohonet.co.uk) (Quit: Leaving)
[17:36:09] *** Quits: Blub\w (wry@moz-74348AEB.wireless.dyn.drei.com) (Quit: bbl)
[17:37:27] <cmr> graydon: I have a hunch that a lot of those tests are going to fail out of the gate :)
[17:38:05] <graydon> yes
[17:38:09] <graydon> but that's the point!
[17:38:20] <graydon> they're a nice way of figuring out how we're doing terrible codegen :)
[17:39:13] <bblum> strcat: your s/each/iter.advance/ patch got all up in my business
[17:40:36] <cmr> https://gist.github.com/cmr/5846269 has one failure left:
[17:40:40] <cmr> interner.rs:125:38: 125:55 error: failed to find an implementation of trait Interner<<V10>> for std::vec::VecIterator<,~str>
[17:40:42] <cmr> interner.rs:125         let i: SimpleInterner<~str> = Interner::prefill(names.iter());
[17:40:44] <cmr>                                                       ^~~~~~~~~~~~~~~~~
[17:41:06] <cmr> And I have no idea why, I've tried every variation of Interner::prefill::<stuff>(...)
[17:41:14] *** Quits: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP) (Ping timeout)
[17:41:22] *** Joins: PS1 (ps1@DFB8B06.FFF4F268.C6E4398C.IP)
[17:41:53] <ecr> How would I remove a sequence of trailing null bytes from a string?
[17:42:42] *** Quits: PS1 (ps1@DFB8B06.FFF4F268.C6E4398C.IP) (Client exited)
[17:43:41] *** Quits: ysuzuki (ysuzuki@moz-285468F7.net219126120.t-com.ne.jp) (Client exited)
[17:44:23] <Blei> rusti: "abc\x00\x00".trim_right(|c| c == (0 as char))
[17:44:24] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/WSCM
[17:44:54] <Blei> rusti: "abc\x00\x00".trim_right_chars(|c| c == (0 as char))
[17:44:56] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/iJDY
[17:45:30] <ecr> rusti: "abc\x00\x00".trim_right_chars(|c: char| c == (0 as char))
[17:45:30] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/hGRR
[17:46:09] <ecr> rusti: "abc\x00\x00".trim_right_chars(|&c| c == (0 as char))
[17:46:11] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/UgSj
[17:46:54] <Blei> rusti: do "abc\x00\x00".trim_right_chars |c: char| {c == (0 as char)}
[17:46:55] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/SZPG
[17:47:00] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[17:47:05] *** Quits: jaen (jaen@moz-9968C5CB.play-internet.pl) (Ping timeout)
[17:47:08] <ecr> rusti: "abc\x00\x00".trim_right_chars(|&c: &char| c == 0 as char))
[17:47:09] -rusti- <anon>:9:67: 9:68 error: incorrect close delimiter: `)`
[17:47:09] -rusti- <anon>:9          "abc\x00\x00".trim_right_chars(|&c: &char| c == 0 as char))
[17:47:09] -rusti-                                                                             ^
[17:47:10] -rusti- application terminated with error code 101
[17:47:44] <cmr> Er, I don't know where you're seeing your trim_right_chars definition
[17:48:00] <cmr> rusti: "foo\x00\x00".trim_right_chars('\x00')
[17:48:02] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/ieUg
[17:48:30] <cmr> rusti: let c = '\x00'; "foo\x00\x00".trim_right_chars(&c)
[17:48:32] -rusti- "foo"
[17:48:38] <Blei> hrm
[17:48:44] <cmr> fn trim_right_chars<C: CharEq>(&self, to_trim: &C) -> &'self str
[17:48:56] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[17:49:16] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Client exited)
[17:49:21] <ecr> thanks cmr, Blei.
[17:50:35] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[17:50:47] <Blei> cmr: how does the trim_right() function work? i'm confused
[17:51:08] *** Joins: bent (chatzilla@moz-BE33DA21.fw1.sfo1.mozilla.net)
[17:51:45] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[17:51:53] <cmr> Blei: since it just wants something implementing CharEq, you can have an object that returns 'true' for any given character
[17:51:56] *** Quits: tjc (tjc@moz-BBBC84F5.static.lnbh.ca.charter.com) (Ping timeout)
[17:52:08] <cmr> it being trim_right_chars
[17:54:00] <Blei> rusti: "abc\x00\x00".trim_right_chars(&|c| c == (0 as char))
[17:54:01] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/EPWM
[17:54:03] *** Quits: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[17:54:07] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[17:54:09] *** Parts: samebchase (samuel@moz-7519FE69.net) ()
[17:54:17] <Blei> rusti: "abc\x00\x00".trim_right_chars(&|c: char| c == (0 as char))
[17:54:19] -rusti- "abc"
[17:54:23] <Blei> ah, finally
[17:54:36] <Blei> interesting that it doesn't auto-borrow
[17:54:48] *** Joins: zippity (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP)
[17:54:52] <Blei> well, actually that's normal i guess
[17:55:21] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[17:55:23] <cmr>  impl CharEq for extern "Rust" fn(char) -> bool {
[17:55:25] <cmr>      #[inline]
[17:55:27] <cmr>      fn matches(&self, c: char) -> bool { (*self)(c) }
[17:55:29] <cmr>      fn only_ascii(&self) -> bool { false }
[17:55:31] <cmr>  }
[17:55:34] <cmr> that is really fancy
[17:56:17] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[17:57:15] <Blei> i would have expected that do notation worked here
[17:57:46] <cmr> It... should
[17:57:50] <cmr> it's implemented for closures
[17:58:02] <cmr> Although only &fn, so maybe that is why
[17:58:06] *** Quits: tav (tav@moz-5ED3AF3C.range86-152.btcentralplus.com) (Quit: tav)
[17:58:10] <cmr> But do uses &fn doesn't it?
[17:58:12] * cmr doesn't know
[17:58:18] <Blei> that's what i thought as well
[17:59:01] <Blei> rusti: do "abc\x00\x00".trim_right_chars() |c: char| {c == (0 as char)}
[17:59:02] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/UDac
[17:59:19] <cmr> rusti: do "abc\x00\x00".trim_right_chars |c: char| {c == (0 as char)
[17:59:20] -rusti- <anon>:12:0: 12:1 error: file ended with unbalanced delimiters
[17:59:20] -rusti- <anon>:12 }
[17:59:20] -rusti-           ^
[17:59:20] -rusti- application terminated with error code 101
[17:59:24] <cmr> rusti: do "abc\x00\x00".trim_right_chars |c: char| {c == (0 as char)}
[17:59:25] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/QJVj
[17:59:52] <cmr> Does it want a & &fn?
[18:00:02] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[18:00:09] <Blei> i can't imagine why
[18:00:18] <cmr> I think this might be a bug
[18:00:20] <Blei> i suppose it's a bug
[18:00:35] <ecr> do "abc\x00\x00".trim_right_chars |&c: &char| { c == (0 as char) }
[18:00:40] <engla> It probably needs the & to find the right type for the trait
[18:00:40] <ecr> derp
[18:00:56] <ecr> rusti: do "abc\x00\x00".trim_right_chars |&c: &char| { c == (0 as char) }
[18:00:57] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/XSRO
[18:00:58] <Blei> engla: but do notation does produce a &fn
[18:01:15] <cmr> engla: what I'm thinking is that it doesn't see that CharEq is implemented for &fn, and thus a closure is valid there.
[18:01:21] <Blei> ah, yeah
[18:01:22] <cmr> the main error is: <anon>:9:26: 9:71 error: last argument in `do` call has non-closure type: &<V4>
[18:01:30] <Blei> fn trim_chars<C: CharEq>(&self, to_trim: &C) -> &'self str;
[18:01:38] <Blei> so C = &fn -> &&fn
[18:01:39] <engla> ok true, of course it wants &&
[18:01:44] *** Joins: seth (seth@2557E599.66715431.D25A875A.IP)
[18:02:03] <bblum> hmm uh oh
[18:02:20] <bblum> #915 0x00007ffff610f868 in middle::trans::type_of::type_of::_d3a97bd223c0786::_07pre ()
[18:02:24] <bblum> dwarf2-frame.c:1115: internal-error: Unknown CFA rule.
[18:02:26] <bblum> A problem internal to GDB has been detected,
[18:02:34] <Blei> 915??
[18:02:40] *** Joins: Amanieu (amanieu@F8743EDC.3BC5FFFE.66E16416.IP)
[18:02:44] <bblum> yeah 914 stack frames of type_of came before
[18:02:46] <Blei> that's ... a lot
[18:02:52] <ecr> bblum: abandon all hope ye who enter here
[18:03:05] <bblum> haha it wants me to create a core file of GDB itself
[18:03:09] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[18:03:22] <bblum> thankyoubutno.jpg
[18:03:23] <Blei> heh, recursive debugging
[18:03:53] <Blei> would gdb die when you'd try to show the backtrace of the backtrace that made the old gdb die?
[18:04:02] <bblum> unlikely
[18:05:35] *** Quits: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP) (Ping timeout)
[18:07:25] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[18:07:25] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1462020f3 to 14c6515ee: 02http://git.io/N3iJvQ
[18:07:25] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[18:07:52] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Quit: Computer has gone to sleep.)
[18:08:26] *** Joins: pcwalton (pcwalton@43CB6079.66715431.D25A875A.IP)
[18:08:26] *** ChanServ sets mode: +o pcwalton
[18:09:05] <cmr> I'm just going to remove the prefill method for now :(
[18:11:46] *** Quits: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP) (Quit: eatkinson)
[18:12:18] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[18:12:30] *** Quits: eschweic (Adium@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[18:12:33] *** Joins: jaen (jaen@moz-9968C5CB.play-internet.pl)
[18:14:16] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[18:14:39] *** Joins: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP)
[18:17:45] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[18:19:39] <acrichto> aww it looks like master mac is sad again
[18:20:03] *** Quits: jdm (jdm@88F51059.F3BBB17D.144F44FA.IP) (Ping timeout)
[18:21:53] *** Joins: eschweic (Adium@2557E599.66715431.D25A875A.IP)
[18:23:00] *** Joins: zslayton (Mibbit@1D191528.269AFE30.6A3AF4D7.IP)
[18:23:54] <zslayton> Is the Reflection API in a usable state? I've seen it mentioned in a handful of old blog posts and have a project in mind that could make use of it.
[18:25:17] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[18:26:58] *** Joins: WerTra (tratra@moz-7A147B17.pool.ukrtel.net)
[18:27:06] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[18:28:07] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[18:29:24] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[18:29:41] <graydon> acrichto: sad as in wedged?
[18:29:48] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[18:30:02] <acrichto> graydon: yes, hour of no output (one of my pr's failed for the same reason)
[18:30:15] <acrichto> http://buildbot.rust-lang.org/builders/master-mac/builds/144
[18:30:43] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[18:30:52] <graydon> grum
[18:30:58] *** Joins: tjc (tjc@moz-95EF7BC4.dhcp.mtpk.ca.charter.com)
[18:30:58] *** ChanServ sets mode: +o tjc
[18:31:14] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[18:31:16] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[18:31:18] <graydon> mac4
[18:31:22] <strcat> graydon: oh the bot for doing linux snapshots is offline
[18:31:27] <strcat> aatch was making one and ran into it
[18:31:27] <graydon> it's running 5 jobs
[18:31:35] <graydon> that's enough that it's likely paging
[18:31:42] <graydon> http://buildbot.rust-lang.org/buildslaves  <-- the actual slave list
[18:31:57] <strcat> need to cancel failed builds automatically
[18:32:10] <graydon> brendanc sent a patch for that, my goal is to enable it today
[18:32:26] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[18:32:47] <graydon> brendanc may also be able to help with another bit of advice, which is "how to make the max_builds limit actually apply to total number of jobs on a given slave, overall, not just a given slave:builder pair"
[18:32:53] <brendanc> only very lightly tested. seems to work, but I haven't worried about corner cases
[18:33:10] <graydon> brendanc: better than nothing! I think strcat spent the weekend manually doing what that patch does :(
[18:33:15] <graydon> strcat heroism ++
[18:33:16] <brendanc> hehe
[18:33:23] * strcat made a script to do it
[18:33:25] <strcat> ;p
[18:33:39] <sully> hm, damn it
[18:33:49] <sully> getting a segfault
[18:34:10] <brendanc> max_builds one confused me tbh, I didn't think it was a per-builder limit
[18:34:10] <strcat> sully: where?
[18:34:30] <sully> running the compiler, after making a trans change
[18:34:31] <sully> probably my fault
[18:34:55] <brendanc> wonder if buildbot just got confused across a reconfig or something
[18:35:22] <strcat> no more old_iter! :)
[18:35:52] *** Quits: WerTra (tratra@moz-7A147B17.pool.ukrtel.net) (Ping timeout)
[18:35:59] *** Joins: marijn (user@moz-C7120E80.dip0.t-ipconnect.de)
[18:37:02] <graydon> brendanc: it doesn't appear to be? I can try restarting it on the next pause
[18:37:10] <brendanc> oh still happening?
[18:37:18] <graydon> brendanc: I have many of them set to 1 or 2, yet still see slaves running many more builds
[18:37:19] <graydon> yeah
[18:37:30] *** Joins: diegoyam (quassel@FF9B1514.A4EC3D18.3A1EC144.IP)
[18:37:41] <graydon> I mean, I _think_ I'm setting that limit properly
[18:37:45] <graydon> maybe my configury isn't going in right
[18:37:58] <graydon> is there any way to debug buildbot to ask it what the config vals for slaves-in-memory are, currently?
[18:37:58] <brendanc> worst case could perhaps use buildbot locks I suppose. but I'll go look at the slave code again
[18:38:11] <brendanc> there's manhole, but you have to enable it
[18:38:15] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz)
[18:38:20] <brendanc> maybe reconfig can activate it
[18:38:23] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[18:38:24] <graydon> can I enable it without a restart?
[18:38:29] <brendanc> maybe :)
[18:38:33] <brendanc> probably
[18:38:34] <graydon> (is manhole exposed on a public TCP port?)
[18:38:47] <brendanc> wherever you configure it
[18:38:49] <graydon> heh. ok. I'll read up on it
[18:39:13] <graydon> I'll turn on ssh access for now
[18:39:27] *** Joins: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net)
[18:39:35] <brendanc> port (string or int) - what port should the Manhole listen on? This is a strports specification string, like 'tcp:12345' or 'tcp:12345:interface=127.0.0.1'. Bare integers are treated as a simple tcp port.
[18:40:35] <marijn> does impl visibility still work the way it used to work way back when? and what is this coherence check that i see some issues talk about?
[18:40:45] <brendanc> https://github.com/buildbot/buildbot/blob/buildbot-0.8.5/master/buildbot/buildslave.py looks fairly clear to me, shouldn't be per-builder
[18:40:45] <strcat> graydon: btw I made a little web interface for the evalbot: http://strcat.zapto.org:8000/
[18:41:06] <brendanc> (canStartBuild)
[18:41:17] <strcat> graydon: could make a qemu image or something to deploy to rust-lang.org - it'd need a lot of memory though, ideally (since each rustc takes 70-200)
[18:41:48] <graydon> strcat: \o/
[18:42:28] *** Quits: Diamond (dick@moz-C01E1CD1.ks.ks.cox.net) (Client exited)
[18:42:33] <graydon> brendanc: yeah, weird
[18:42:57] *** Quits: eholk (eholk@moz-3EC295FB.uconnect.utah.edu) (Quit: eholk)
[18:43:37] <Blei> strcat: very cool!
[18:44:10] <bblum> can i make check-pretty and only test particular test cases
[18:44:48] <brendanc> graydon: guess I'd check that your buildbot's code is the same as that though :)
[18:45:38] <graydon> indeed
[18:47:03] <marijn> nmatsakis: ping!
[18:48:12] *** Quits: Earnestly (earnest@87814665.5364A5FA.922AD825.IP) (Ping timeout)
[18:48:18] <nmatsakis> marijn: pong!
[18:48:35] *** Joins: Earnestly (earnest@639E83C4.94D0CBFF.5411983D.IP)
[18:49:12] <marijn> nmatsakis: i was wondering what the current way impls are scoped/resolved is, and what the 'coherence check' does, and whether there's anything written about this
[18:49:33] <marijn> nmatsakis: (i found the meeting notes from 2012-06-26, but the terminology seems out of date, and probably the solutions outlined there aren't what got implemented)
[18:50:12] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[18:51:15] <nmatsakis> marijn: impls are global, as in Haskell. The coherence check enforces this. So there should be at most one impl of a trait for a given set of type parameters
[18:51:28] <nmatsakis> marijn: (well, Haskell makes this optional)
[18:51:48] <marijn> nmatsakis: by which rules does it enforce it?
[18:51:52] <nmatsakis> marijn: (we found the importing etc of impls wasn't buying us much and added complications for things like deriving etc)
[18:51:54] *** Quits: lucian (lucian@moz-22A14C6A.cable.virginmedia.com) (Ping timeout)
[18:52:02] <nmatsakis> marijn: well, there are a couple of rules, the first one is the no orphan rule,
[18:52:02] <marijn> nmatsakis: and what about use cases like having different hashing algorithms as traits?
[18:52:09] <nmatsakis> marijn: use newtypes.
[18:52:16] <nmatsakis> marijn: in fact thta was one of the motivating counter-examples,
[18:52:26] <nmatsakis> marijn: because it introduces the possibility of having conflicting impls in scope
[18:52:31] <marijn> nmatsakis: okay. (and yes, I know about coherence probs with hashing)
[18:52:33] <nmatsakis> marijn: unless we integrate the impl into the type
[18:52:38] <marijn> nmatsakis: maybe this should be mentioned in the ref manual somewhere
[18:52:40] <nmatsakis> marijn: right, I remember discussing it with you at some point
[18:53:05] <nmatsakis> marijn: yes no doubt. The trait system in general needs more specificaiton, I am in the process of trying to write a first draft at tha t(have been saying that for a while, need to finish up)
[18:53:47] <marijn> nmatsakis: the draft at http://pcwalton.github.io/blog/2012/05/28/coherence/ seems heavy-handed, and doesn't mention orphans, so its' probably not the current set of rules
[18:54:01] <nmatsakis> marijn: the rules are more heavy-handed than they need to be,
[18:54:20] <nmatsakis> marijn: but I don't know whether they correspond to that post or not.
[18:54:33] <marijn> nmatsakis: okay. i guess i'll read the code
[18:54:35] <nmatsakis> marijn: undoubtedly not exactly
[18:54:49] <nmatsakis> marijn: in general though it's pretty simple;
[18:54:55] <marijn> nmatsakis: was the 'discriminate impls by specificity' idea given up on?
[18:55:00] <nmatsakis> marijn: it's illegal if there is an instantiation of the type variables such tath two impls correspond to the same types
[18:55:10] <nmatsakis> marijn: we don't currently take bounds on the type parameters into account, except for Copy bounds,
[18:55:17] <nmatsakis> marijn: but that's one area we could be smarter,
[18:55:25] <nmatsakis> marijn: and we probably treat the Self type more specifically than it ought to be,
[18:55:32] <nmatsakis> marijn: we do not discriminate impls by specificity.
[18:55:35] <marijn> and no same-module-as-(trait|type) restriction?
[18:55:52] <nmatsakis> marijn: that's the orphan rule.
[18:55:54] *** Joins: cowboyd (cowboyd@moz-1BD02A1E.sw.biz.rr.com)
[18:56:04] <nmatsakis> marijn: that rule is still enforced.
[18:56:06] <marijn> nmatsakis: okay. what is an orphan?
[18:56:29] <nmatsakis> marijn: an impl where neither the trait nor any of the types involved are defined in the current crate
[18:56:36] <nmatsakis> marijn: it's haskell's term...
[18:56:52] *** Quits: zslayton (Mibbit@1D191528.269AFE30.6A3AF4D7.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[18:57:32] *** Joins: Diamond (dick@moz-C01E1CD1.ks.ks.cox.net)
[18:57:55] <marijn> nmatsakis: right. might get in the way when defining an impl of string/tuple/int/etc types, no?
[18:58:07] <nmatsakis> marijn: not usually, since usually you define the trait in question too
[18:58:22] <nmatsakis> marijn: but yes, it can. the biggest problem is applying a trait from one crate to a type from another. 
[18:59:05] *** Joins: WerTra (tratra@moz-7A147B17.pool.ukrtel.net)
[18:59:12] <jedestep> any advice on how i could create something akin to a mock object
[18:59:48] <nmatsakis> jedestep: basically you'd have to define a trait for the operations, with multiple impls (the real one, and the mock one)
[19:00:22] <jedestep> right now i'm looking to mock out some objects in extra::net_tcp which do not implement any traits
[19:00:26] *** Joins: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP)
[19:00:46] <jedestep> earlier it was suggested that i simply copy/paste the module into some different module and have it implement a trait, this is far from ideal but if there's no alternative i can do it
[19:01:42] *** Quits: zippity (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[19:02:12] *** Quits: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com) (Ping timeout)
[19:03:32] *** Quits: eschweic (Adium@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[19:03:53] <nmatsakis> not sure, this is a downside of the tight static linking that Rust provides
[19:04:53] <jedestep> blargh
[19:05:29] <jedestep> i wish i was more well-versed in how other mocking frameworks are built
[19:05:33] *** Quits: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP) (Quit: eatkinson)
[19:06:38] *** Joins: roo (jesse.rudo@moz-41A5F2FD.dynamic.ip.windstream.net)
[19:06:45] <nmatsakis> jedestep: Java-based frameworks have similar difficulties; I think the answer is essentially that you have to write the code with respect to traits, not specific types (in Java, with respect to interfaces, not classes).
[19:09:21] <WerTra> any msvc builds planned for 0.7?
[19:09:45] *** Joins: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP)
[19:10:56] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[19:10:56] *** ChanServ sets mode: +o brson
[19:10:57] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[19:11:16] <graydon> no
[19:12:16] *** Joins: jpf (jan@moz-A8C26A15.org)
[19:12:57] <indutny> cmr: what's up with bors?
[19:13:11] <indutny> those tests seems to be totally unrelated...
[19:13:12] <indutny> or am I wrong?
[19:14:02] *** Quits: Earnestly (earnest@639E83C4.94D0CBFF.5411983D.IP) (Connection reset by peer)
[19:14:22] *** Joins: Earnestly (earnest@639E83C4.94D0CBFF.5411983D.IP)
[19:15:02] *** Quits: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP) (Ping timeout)
[19:16:48] <engla> it happens
[19:16:52] *** Parts: marijn (user@moz-C7120E80.dip0.t-ipconnect.de) (ERC Version 5.3 (IRC client for Emacs))
[19:18:15] <engla> is there a way to export macros from a crate?
[19:18:19] <thiez> bblum: you can, with TESTNAME=
[19:18:59] *** Quits: kini (kini@moz-92AA953A.members.linode.com) (Ping timeout)
[19:21:04] *** Quits: Excureo (c@moz-B0B6F5C3.static.knwc.wa.charter.com) (Ping timeout)
[19:21:40] <bblum> thiez: thakns
[19:21:42] <bblum> thanks
[19:22:01] <thiez> I don't think you can give multiple different files at once though.
[19:22:43] *** Joins: mib_xzv2x1 (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP)
[19:22:45] *** Joins: eschweic (Adium@2557E599.66715431.D25A875A.IP)
[19:23:21] *** Joins: SimonSapin (simon@moz-D0C2F181.zone2.bethere.co.uk)
[19:24:00] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[19:24:01] *** Joins: eschweic1 (Adium@2557E599.66715431.D25A875A.IP)
[19:24:07] *** Quits: eschweic (Adium@2557E599.66715431.D25A875A.IP) (Connection reset by peer)
[19:24:18] *** Joins: eholk (eholk@moz-3EC295FB.uconnect.utah.edu)
[19:24:24] *** Quits: roo (jesse.rudo@moz-41A5F2FD.dynamic.ip.windstream.net) (Ping timeout)
[19:24:36] *** Joins: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com)
[19:25:24] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Connection reset by peer)
[19:25:25] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[19:26:02] *** Quits: eholk (eholk@moz-3EC295FB.uconnect.utah.edu) (Ping timeout)
[19:27:35] *** Parts: WerTra (tratra@moz-7A147B17.pool.ukrtel.net) ()
[19:27:44] *** Joins: Excureo (c@moz-B0B6F5C3.static.knwc.wa.charter.com)
[19:29:13] *** Joins: eholk (eholk@moz-3EC295FB.uconnect.utah.edu)
[19:30:25] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[19:31:55] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[19:34:21] <thiez> bblum: perhaps try something like this: for i in $(git diff --name-status HEAD HEAD~5 | egrep -o '[^/]+\.rs$') ; do rm tmp/*.log ; rm tmp/*.ok ; make check-stage1-pretty TESTNAME="$i" ; done | egrep '^test '
[19:34:36] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[19:34:36] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Textual IRC Client: www.textualapp.com)
[19:34:45] <thiez> (for testing only the files changed in the last 5 commits)
[19:36:31] *** Joins: roo (jesse.rudo@moz-65FDD8A9.dynamic.ip.windstream.net)
[19:37:31] *** Joins: MaikKlein (maik@moz-129BB64.dip0.t-ipconnect.de)
[19:39:39] <sully> hey, I just pushed a pull request for a default methods generics bug
[19:39:40] <sully> https://github.com/mozilla/rust/pull/7356
[19:39:50] <sully> I'd ask nmatsakis to review, but he is busy conferencing, right?
[19:39:53] <sully> could somebody take a look at it
[19:41:01] <thiez> I'll take a look, but I can't r+
[19:41:45] <Eridius> I just took a look, but I know absolutely nothing about the compiler, so it's all a big mystery to me ;)
[19:42:14] <strcat> sully: btw did you see https://github.com/mozilla/rust/issues/7341 ? seems like it's not passing along the types properly
[19:42:20] *** Quits: Amanieu (amanieu@F8743EDC.3BC5FFFE.66E16416.IP) (Quit: leaving)
[19:42:24] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[19:42:25] <strcat> maybe it's the same as another bug you're working on though
[19:43:08] <sully> oh, ugh, I guess that doesn't surprise me
[19:43:19] <sully> is there a test for that?
[19:43:44] <strcat> sully: well there's now a block of code you can uncomment in vec.rs to trigger it
[19:43:55] <strcat> sully: replace the FromIterator impl that's uncommented with the commented one
[19:44:12] <strcat> calling .size_hint (a default method) from it (a generic impl) hits it
[19:44:22] <strcat> well - also it will only build in stage1 soo...
[19:44:24] <strcat> sec
[19:45:17] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[19:45:32] <strcat> sully: http://ix.io/6lM that should hit it - I haven't whittled it down to a standalone test yet
[19:46:06] *** Joins: cmr_cmr_ (cmr_cmr_@moz-E7EA111C.clients.kiwiirc.com)
[19:46:16] *** cmr_cmr_ is now known as cmr_
[19:46:25] *** Joins: Azdle (Azdle@moz-B334B496.hfc.comcastbusiness.net)
[19:46:28] <strcat> the difference is just that the broken version calls a default method on the trait
[19:46:43] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[19:46:45] <sully> ok
[19:47:19] *** Quits: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net) (Quit: Jesse)
[19:48:04] <sully> ok, hm, what is the right way to actually test this?
[19:48:15] <sully> since stage0 it fails with a typecheck error
[19:48:23] <tjc> brson: r? https://github.com/mozilla/rust/pull/7357
[19:49:06] <strcat> sully: sec, let me figure it out again
[19:49:42] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[19:49:47] <bblum> hey uh
[19:49:50] <strcat> sully: did you apply the diff? uncommenting it isn't actually enough
[19:49:53] <steven_is_false> There was syntax introduced for unit tuples right?
[19:49:55] <bblum> if a compile-fail test case emits two different errors on the same line
[19:49:58] <sully> strcat: oh, ok
[19:50:01] <bblum> but the test case only has a "//~ ERROR" for one of them
[19:50:07] <cmr_> steven_is_false: no? unit struct is struct Foo();
[19:50:09] <bblum> will that fail? (it seems so) and what should i do about it?
[19:50:14] <cmr_> steven_is_false: unit itself is just ()
[19:50:24] <steven_is_false> cmr: For macros.
[19:50:39] <steven_is_false> In python it's (foo,)
[19:50:52] <strcat> rusti: ((), (1,))
[19:50:54] -rusti- ((), (1,))
[19:50:58] <strcat> rusti: ((), (1,), (1, 2))
[19:50:59] -rusti- ((), (1,), (1, 2))
[19:51:01] <cmr_> bblum: there's //~ ^ ERROR or some such to indicate the error happened on a line above
[19:51:03] <steven_is_false> rusti: (4,)
[19:51:04] -rusti- (4,)
[19:51:16] <steven_is_false> rusti: let(x,) = (4,); x
[19:51:17] -rusti- 4
[19:51:20] <bblum> cmr_: i mean do i have to list error messages for both errors or what
[19:51:29] <bblum> like, i'm confused that it fails, since the error matches at least one of them
[19:51:31] <cmr_> bblum: yes
[19:51:35] <bblum> i see
[19:51:38] <cmr_> all errors need to be accounted for
[19:51:42] <strcat> yet another codegen bug seemingly related to closures
[19:51:42] <bblum> there's also //~^^ ERROR for two lines above right
[19:51:46] <cmr_> yup
[19:51:49] <cmr_> for n ^
[19:51:51] *** Quits: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net) (Quit: carllerche)
[19:52:10] <cmr_> (and I checked, that is the syntax)
[19:52:39] *** Joins: bstrie (ben@moz-EBF8B9B5.zoominternet.net)
[19:52:49] *** Quits: SimonSapin (simon@moz-D0C2F181.zone2.bethere.co.uk) (Ping timeout)
[19:53:29] <sully> ok, reproducing
[19:53:33] <sully> reproduced, rather
[19:53:39] <sully> sigh, I was hoping that I accidentally had fixed it
[19:53:44] <strcat> heh
[19:54:03] <steven_is_false> rusti: (4,)
[19:54:04] -rusti- (4,)
[19:54:07] <steven_is_false> rusti: (4,4,)
[19:54:08] -rusti- (4, 4)
[19:54:16] <strcat> sully: the actual type T: Iterator<A> resolves to uses a region (like VecIterator<'self, A>) so it seems related to that
[19:54:32] <sully> *gulp*
[19:54:36] * strcat doesn't know how that code works
[19:54:39] <strcat> maybe nmatsakis can help
[19:55:07] *** Joins: pyrac (pyrac@moz-9180E00E.w86-201.abo.wanadoo.fr)
[19:55:44] <steven_is_false> rusti: let (x, y,) = (0, 3); x
[19:55:44] -rusti- <anon>:9:19: 9:20 error: unexpected token: `)`
[19:55:44] -rusti- <anon>:9          let (x, y,) = (0, 3); x
[19:55:45] -rusti-                             ^
[19:55:45] -rusti- application terminated with error code 101
[19:55:56] *** Parts: steven_is_false (user@moz-144077DE.bchsia.telus.net) (ERC Version 5.3 (IRC client for Emacs))
[19:56:19] <bblum> regionz
[19:56:41] <strcat> sully: hopefully it's something as simple as making default methods do what non-default methods do ;p
[19:57:04] <strcat> but I guess a default method can have a region parameter itself...
[19:57:04] *** Joins: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net)
[19:57:27] <cmr_> when will the great renaming reach the rustc codebase?
[19:57:44] <sully> hm, failure happening in trans
[19:57:55] *** Joins: robert (robertknig@moz-C34822AC.range86-166.btcentralplus.com)
[19:58:14] *** Quits: MaikKlein (maik@moz-129BB64.dip0.t-ipconnect.de) (Ping timeout)
[19:58:24] <thiez> cmr_: which great renaming might that be?
[19:58:34] *** Quits: cmr_ (cmr_cmr_@moz-E7EA111C.clients.kiwiirc.com) (Quit: http://www.kiwiirc.com/ - A hand crafted IRC client)
[20:00:18] <sully> so yeah, the failure being in trans is good and bad
[20:01:55] <thiez> aatch: I was looking at your work_queue.rs
[20:02:37] <thiez> and I was wondering why steal() needs to check for owned_ptr_val(&0) != 0, but pop() does not?
[20:02:53] <thiez> *owned_ptr_val(&o)
[20:03:52] *** Quits: itdaniher (it@moz-C885C25B.mit.edu) (Quit: leaving)
[20:05:02] *** Quits: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP) (Ping timeout)
[20:07:21] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[20:08:52] *** Joins: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP)
[20:12:15] <brendanc> graydon: if you can't figure out what's going on with max_builds, you could try creating a lock for each slave with the max count set to max_builds, then giving each slave an argument like locks=["slavelock"]
[20:13:10] *** Quits: eholk (eholk@moz-3EC295FB.uconnect.utah.edu) (Quit: eholk)
[20:14:16] *** Joins: eholk (eholk@moz-3EC295FB.uconnect.utah.edu)
[20:14:28] *** Joins: Jesse (jruderman@2557E599.66715431.D25A875A.IP)
[20:14:37] *** Joins: MaikKlein (maik@moz-129BB64.dip0.t-ipconnect.de)
[20:16:11] *** Quits: Blei (philipp@moz-650B9C6A.cust.bluewin.ch) (Quit: WeeChat 0.4.1)
[20:16:50] <MaikKlein> is rust jit a serious project? 
[20:17:01] <MaikKlein> or more are research project
[20:17:27] <strcat> it's just LLVM's JIT
[20:17:30] <strcat> no reason it can't work well
[20:17:38] <strcat> not that it will ever be useful
[20:17:47] <bstrie> what are the make commands to run under valgrind?
[20:18:09] <strcat> VALGRIND_COMPILE=1 make check
[20:18:21] <bstrie> is there one of those for helgrind too?
[20:18:23] <thiez> strcat: why would you say that?
[20:18:29] <MaikKlein> but it's probably not a goal for 1.0 right?
[20:18:43] <sully> oh, argh
[20:18:46] <strcat> thiez: because the JIT warmup is very long and it's slow anyway
[20:18:57] <Luqman> bstrie: aren't they configure flags? --enable-valgrind/helgrind
[20:18:58] <strcat> what's the use case?
[20:18:58] <sully> my test case minimization for the segfault bug I introduced was completely bogus
[20:19:30] <MaikKlein> for me the use case would be fast compiles
[20:19:31] *** Joins: sw17ch (sw17ch@moz-39D8564F.wndsny.tds.net)
[20:19:49] <MaikKlein> if it is even faster, dunno
[20:19:54] <thiez> strcat: can it be forced to compile straight away? I was thinking it would be nice if you could send functions to another rust program and have them executed there
[20:20:08] <strcat> thiez: you could serialize + use AOT compilation too
[20:20:18] <strcat> it'd probably be faster to compile, and faster to run
[20:20:25] <thiez> AOT?
[20:20:28] <strcat> ahead-of-time
[20:20:33] <thiez> ah
[20:20:35] <thiez> fair enough
[20:20:40] <strcat> the JIT is only going to be faster to start than AOT compilation on big codebases
[20:21:33] <bstrie> we should make it so that the built-in rusti just makes a call over the internet to strcat's rusti
[20:21:37] <strcat> and our unoptimized IR is still way too bad... but that'll get fixed
[20:21:37] <thiez> I suppose JIT wouldn't make sense for the worker-scenario as you wouldn't send small inexpensive computations to another machine anyway
[20:21:56] <strcat> thiez: you could just serialize the AST + compile them
[20:22:04] <thiez> that would be pretty cool.
[20:22:15] <sully> hm, does zero.rs still work?
[20:22:16] <strcat> a JIT lets you start a big program fairly quickly (rustc, for example) and optimize as you go
[20:22:24] <strcat> but for small ones it's useless
[20:22:38] <bstrie> sully: pcwalton might know
[20:22:47] <MaikKlein> so there is no speed improvement on compilation?
[20:23:07] <MaikKlein> or maybe I am just confused now
[20:23:11] <Luqman> sully: it should, though i think you'd need to add the new sized lang item
[20:23:21] <sully> ok, that seems to be the problem, yeah
[20:23:23] <sully> what is sized?
[20:24:09] <Luqman> sully: just add #[lang="sized"] pub trait Sized {}
[20:24:44] <sully> yeah, got it
[20:25:21] <sully> hrm, getting unresolved references to clock_gettime, dlsym, dladdr
[20:25:33] <bstrie> wait... we're currently shipping valgrind with rust?
[20:25:46] <bstrie> or is that something else in the src/rt/vg/ dir
[20:25:46] <MaikKlein> doesn't jit mean I don't compile anything before I need it?
[20:26:09] <bstrie> MaikKlein: you still usually compile the source code to bytecode
[20:26:44] <MaikKlein> bstrie, is this faster than the usual compiling?
[20:26:49] <graydon> brendanc: ok, I will try that once I try the manhole to see if it works. thanks.
[20:27:10] <bstrie> MaikKlein: it can be. you can also cache the bytecode (i.e. python's .pyc files)
[20:27:37] <strcat> MaikKlein: the JIT is 100% useless right now
[20:27:50] <strcat> our unoptimized IR is way too bad
[20:28:11] *** Joins: Jesin (Jessin_@moz-157A63DD.cc.lehigh.edu)
[20:28:16] <strcat> it takes ages to start up and runs incredibly slowly... and it generates incorrect code
[20:28:27] <doomlord> jit.. seems like if you want that there are many other languags.. the point of rust is another AOT alternative to c++ ...
[20:28:37] <MaikKlein> it just would be cool to use jit in the future for faster recompiles or sth
[20:28:49] <strcat> MaikKlein: it won't actually output a binary
[20:29:13] <MaikKlein> strcat, ok
[20:29:37] <bstrie> well I suppose it's true that as long as the majority of our build time is in the llvm optimization pass, compiling just to llvm bytecode would save us some time up front, at the cost of awful runtime speed
[20:29:49] <strcat> the point is to start up a *large* program quickly without optimizing any of it except for the hot spots
[20:30:22] <strcat> but that requires unoptimized IR comparable to clang
[20:30:25] <strcat> to be at all useful
[20:30:53] <strcat> or it has to optimize the whole codebase and will take much longer than just using -O1...
[20:31:39] *** Quits: roo (jesse.rudo@moz-65FDD8A9.dynamic.ip.windstream.net) (Ping timeout)
[20:31:55] *** Quits: Excureo (c@moz-B0B6F5C3.static.knwc.wa.charter.com) (Ping timeout)
[20:32:25] *** Joins: roo (jesse.rudo@moz-2E0A90D0.dynamic.ip.windstream.net)
[20:33:26] *** Quits: tjc (tjc@moz-95EF7BC4.dhcp.mtpk.ca.charter.com) (Quit: Places to go, people to annoy)
[20:33:40] <strcat> rusti: let xs = [1, 2, 3]; let ys: ~[int] = xs.rev_iter().collect(); ys
[20:33:42] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/WGFX
[20:33:52] <strcat> rusti: let xs = [1, 2, 3]; let ys: ~[int] = xs.rev_iter().transform(|&x| x).collect(); ys
[20:33:53] -rusti- ~[3, 2, 1]
[20:34:08] * strcat wishes that could be called map
[20:34:31] *** Quits: pcwalton (pcwalton@43CB6079.66715431.D25A875A.IP) (Quit: pcwalton)
[20:34:48] <bstrie> strcat: is that blocked on that generics conflict bug?
[20:34:53] <strcat> yep
[20:35:04] <bstrie> ok, I figured it would be called map_ then :P
[20:35:11] *** Joins: Kruppe (user@moz-4DDA8AB8.uwaterloo.ca)
[20:35:16] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[20:35:22] <bstrie> perhaps we can nominate that bug for 0.8
[20:35:22] <MaikKlein> rusti: (-0.5f).sqrt().is_NaN()
[20:35:23] -rusti- false
[20:35:23] <strcat> that was before I started doing that underscore thing as a workaround
[20:35:39] <MaikKlein> strcat, you are the thestinger on github right?
[20:35:42] <strcat> yes
[20:35:47] <strcat> bstrie: oh don't worry it'll fix itself
[20:35:53] <bstrie> ...why?
[20:35:57] <strcat> I'm forcing traits on everyone with iterators
[20:35:57] <MaikKlein> strcat, are you sure that rusti doesn't use -O?
[20:36:00] <strcat> they'll get fixed now
[20:36:02] <strcat> :D
[20:36:04] <bstrie> haha
[20:36:08] *** Quits: pyrac (pyrac@moz-9180E00E.w86-201.abo.wanadoo.fr) (Quit: pyrac)
[20:36:08] <bstrie> I see
[20:36:20] *** Joins: Excureo (c@moz-B0B6F5C3.static.knwc.wa.charter.com)
[20:36:22] <strcat> want to write 'for xs.enumerate |(i, x)| {}' ? fix type bounds on trait type params
[20:36:24] <strcat> ;p
[20:36:33] <strcat> can't have Iterable yet
[20:36:36] *** Quits: Palmik (palmik@moz-CC484FDD.tmcz.cz) (Quit: Lost terminal)
[20:37:02] <MaikKlein> strcat, because (-0.5f).sqrt().is_NaN() evaluates in rusti here to false, while it evaluates on the current master to true, but it evaluates to false if I compile it with -O
[20:37:39] <MaikKlein> this makes me think that rusti here uses -O
[20:37:41] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Connection reset by peer)
[20:37:49] <bstrie> strcat: instead of a trailing underscore, you should have made the suffix something like "_3429_"
[20:37:49] <thiez> why does it make you sad?
[20:37:57] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[20:38:09] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[20:38:09] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[20:38:12] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[20:38:15] <bstrie> ...
[20:38:18] <bstrie> strcat: instead of a trailing underscore, you should have made the suffix something like "_3429_"
[20:38:20] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[20:38:32] <strcat> bstrie: ;p
[20:38:42] *** Quits: fabiand (fabiand@moz-A2365E79.adsl.alicedsl.de) (Quit: Verlassend)
[20:38:48] <strcat> bstrie: the issue number! ;p
[20:39:11] <thiez> MaikKlein: irc messages have a max length of what, 512 characters? so a program can't be that complex, so it doesn't take much effort to optimize compared to how long it might run, so why not run rusti with -O ?
[20:39:41] <strcat> MaikKlein: the irc bot doesn't use -O
[20:40:16] <bstrie> strcat: the issue number *and* a unicode frowny face, to really drive the point home
[20:40:39] <acrichto> MaikKlein: this is likely an LLVM optimization bug that may only show up on OSX instead of other platforms
[20:40:42] <strcat> MaikKlein: let me update it
[20:41:04] <acrichto> MaikKlein: or we're generating invalid IR and it just gets optimized differently on different platforms
[20:41:12] <strcat> acrichto: we are generating invalid IR
[20:41:14] <strcat> all over the place
[20:41:29] <acrichto> strcat: well, something about glue is invalid
[20:41:31] <strcat> it's surprising how little we see the weird corruption issues we have
[20:41:32] <acrichto> and then glue is all over the place
[20:41:44] <strcat> acrichto: sure, but we compile so many things wrong
[20:41:47] *** Joins: pcwalton (pcwalton@2557E599.66715431.D25A875A.IP)
[20:41:47] *** ChanServ sets mode: +o pcwalton
[20:42:05] <acrichto> I've looked at the messages and I can't even understand what's unvalid about it :(
[20:42:14] <strcat> acrichto: those are just the ones lint catches
[20:42:17] <strcat> those are low hanging fruit
[20:42:20] <strcat> that's only the tip of the iceberg
[20:42:32] <acrichto> oh dear
[20:42:51] <strcat> the lint pass is like -Wall on gcc, it catches a tiny fraction of bugs
[20:42:57] <strcat> it can't verify correctness
[20:43:16] <acrichto> strcat: well do we actually know what's generating invalid IR or just that invalid ir is probably being generated?
[20:43:26] <strcat> I know that many things compile to invalid IR
[20:43:39] <bstrie> how do we test for them, then
[20:43:49] <acrichto> what's the threshold for being "invalid"?
[20:44:01] <strcat> acrichto: not well defined? memory corruption?
[20:44:16] <acrichto> strcat: that doesn't always mean it's LLVM though
[20:44:33] <strcat> acrichto: https://github.com/mozilla/rust/issues/7336#issuecomment-19895471 tiny little example
[20:44:38] <strcat> acrichto: I'm not saying it's LLVM
[20:44:41] <strcat> I'm saying we output invalid IR
[20:44:57] <strcat> if we compiled to assembly, I'd be saying we output invalid asm
[20:45:34] <strcat> I have ~100 code samples lying around that segfault or get SIGILL, slowly reporting them as good bugs one at a time
[20:45:43] <strcat> no point of dumping them all on the tracker
[20:45:53] <acrichto> yeah I guess so, although it is good to keep track of them
[20:45:54] <strcat> but we can't even compile a 10 line program with a stack closure right...
[20:46:13] <strcat> we have the whole "appears to work" thing going on
[20:46:23] <strcat> we fix symptoms as they pop up - but our codegen is completely flawed ;\
[20:46:58] <strcat> our run-pass tests only catch a crash/failure
[20:47:12] <strcat> we need IR tests
[20:47:16] <strcat> like clang has
[20:48:06] <strcat> you can teach rustc to make more invalid pointer casts and pass all the tests
[20:48:09] <strcat> doesn't mean it's correct
[20:48:13] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[20:48:48] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[20:49:21] <strcat> I just think we aren't really taking it seriously enough... we can't compile 'fn main() { let x = ~5; let y = x }' correctly
[20:49:52] <thiez> that doesn't work? oO
[20:50:11] <strcat> thiez: it doesn't crash
[20:50:14] <strcat> it's invalid code though
[20:50:22] <strcat> as in invalid IR with undefined behaviour
[20:50:23] *** Quits: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP) (Quit: buildmaster reconfigured: bot disconnecting)
[20:50:40] <strcat> and sometimes LLVM compiles it so that our tests fail - yeah
[20:50:41] <thiez> could you elaborate on what is wrong about it?
[20:51:00] <strcat> thiez: undefined behaviour from pointer casts mostly
[20:51:11] <strcat> we have lots of undefined stores
[20:51:20] <strcat> the lint pass doesn't catch most of this stuff
[20:51:20] <graydon> bors is offline presently, fyi
[20:51:24] <graydon> hacking on buildbot a bit
[20:51:25] <thiez> that's quite awful
[20:51:32] <strcat> Undefined behavior: Call return type mismatches callee return type
[20:51:34] <strcat>   %14 = call %"struct.std::sys::TypeDesc[#1]"* bitcast (i64 ({ i64, %tydesc*, i8*, i8*, i8 }*, i64)* @_ZN4cast14transmute_299117_4b765accdc6169d33_00E to %"struct.std::sys::TypeDesc[#1]"* ({ i64, %tydesc*, i8*, i8*, i8 }*, i8*)*)({ i64, %tydesc*, i8*, i8*, i8 }* undef, i8* %13)
[20:51:36] <strcat> Undefined behavior: Call return type mismatches callee return type
[20:51:38] <strcat>   %25 = call i8* bitcast (i64 ({ i64, %tydesc*, i8*, i8*, i8 }*, i64)* @_ZN4cast14transmute_299117_4b765accdc6169d33_00E to i8* ({ i64, %tydesc*, i8*, i8*, i8 }*, %"enum.std::libc::types::common::c95::c_void[#1]"*)*)({ i64, %tydesc*, i8*, i8*, i8 }* undef, %"enum.std::libc::types::common::c95::c_void[#1]"* %24)
[20:51:40] <strcat> Undefined behavior: Call return type mismatches callee return type
[20:51:42] <strcat>   %8 = call %"enum.std::libc::types::common::c95::c_void[#1]"* bitcast (i64 ({ i64, %tydesc*, i8*, i8*, i8 }*, i64)* @_ZN4cast14transmute_299117_4b765accdc6169d33_00E to %"enum.std::libc::types::common::c95::c_void[#1]"* ({ i64, %tydesc*, i8*, i8*, i8 }*, i8*)*)({ i64, %tydesc*, i8*, i8*, i8 }* undef, i8* %7)
[20:51:44] <strcat> fn main { let x = ~5; }
[20:51:46] <strcat> but there's more undef behaviour that it's just not linting
[20:52:01] <strcat> so yeah, we can't blame anything on LLVM bugs ;p
[20:52:05] *** Joins: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP)
[20:52:15] *** Quits: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP) (Quit: buildmaster reconfigured: bot disconnecting)
[20:52:25] <thiez> shouldn't LLVM complain about these things?
[20:52:29] <bstrie> just have an intern rewrite trans
[20:52:34] <strcat> thiez: LLVM can't cure undef behaviour
[20:52:36] <thiez> as long as they are silent we can all live happy and never know about it
[20:52:40] <strcat> LLVM IR isn't much different than C
[20:52:41] <thiez> no sure, but it could warn
[20:52:46] <strcat> thiez: -Z llvm-lint
[20:52:51] <strcat> how about flipping it on by default?
[20:52:54] <thiez> I agree
[20:52:58] *** Joins: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP)
[20:53:05] <strcat> sure, it'll spam a few million warnings during a rustc compile - but maybe we'll fix it
[20:53:06] <thiez> not looking forward to it though :p
[20:53:15] <MaikKlein> oh what is going on here 
[20:53:22] <MaikKlein> :D
[20:53:32] <strcat> thiez: it's only silent until a snippet of code fails for an unknown reason
[20:53:43] <MaikKlein> acrichto, but I am on linux not OSX
[20:53:47] <strcat> imagine writing a serious project in rust, and having lets say 20k lines of code
[20:54:01] <strcat> and there';s some horrible codegen failure, making it segfault or corrupt memory
[20:54:07] <thiez> it's a miracle we have rustc working
[20:54:08] <strcat> there's absolutely no chance of tracking it down
[20:54:28] <strcat> thiez: "working"
[20:54:34] <acrichto> MaikKlein: oh that's unfortunate :(
[20:54:39] <strcat> we don't have enough tests, and we're missing classes of tests
[20:54:49] * strcat should figure out how to make IR tests
[20:55:06] <MaikKlein> what does IR stand for?
[20:55:21] <doener> intermediate representation
[20:55:45] <thiez> it seems 'transmute' generates wrong IR a lot of the time
[20:55:50] <thiez> perhaps someone could start there
[20:56:04] <MaikKlein> thanks
[20:56:21] <bstrie> MaikKlein: the IR is our bytecode
[20:56:30] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[20:56:47] *** Joins: tjc (tjc@moz-D530ECE9.lightspeed.irvnca.sbcglobal.net)
[20:56:47] *** ChanServ sets mode: +o tjc
[20:56:52] <thiez> perhaps we should create an issue and tag it E-easy, it'll be fun :p
[20:56:59] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[20:57:05] <strcat> thiez: "easy" ;p
[20:57:16] <doener> IIRC someone said that the return type lint warnings maybe false positives
[20:57:38] <MaikKlein> bstrie, haha okay I just wanted to ask this
[20:57:43] <strcat> doener: they're never false positives afaik
[20:57:48] <strcat> if it says something is undef, it's undef
[20:58:00] <strcat> doesn't mean it ever compiles to invalid code, but LLVM is free to do that in the future
[20:58:18] <doener> https://botbot.me/mozilla/rust/msg/3989127/
[20:58:28] <thiez> yeah, imagine it just assigning undef to all those values
[20:58:40] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Quit: Leaving.)
[20:58:55] <strcat> it doesn't warn about most invalid pointer casts, sadly
[20:59:01] <strcat> we do really, really bad things with casts
[20:59:57] <strcat> I have plenty of examples if someone wants to waste hours of their life trying to pin down where it goes wrong in trans ;p
[21:00:35] <strcat> https://github.com/mozilla/rust/issues/7355 this one is fun because if you insert printlns, it changes the behaviour
[21:01:30] *** Quits: robert (robertknig@moz-C34822AC.range86-166.btcentralplus.com) (Ping timeout)
[21:01:55] * strcat shrugs
[21:02:31] <brson> i'm thinking of starting an integration branch to pull in the trivial pull requests and take load off bors. is anybody else doing this?
[21:02:46] <tjc> brson: good idea
[21:02:49] <strcat> brson: I did it a few times
[21:03:06] <strcat> landed 8-9 doc pulls together on the weekend, etc.
[21:03:09] <strcat> but mostly with my own pulls...
[21:03:37] <mcpherrin> brson: you could call it "incoming" ;)
[21:03:44] <tikue> mcpherrin: was just thinking that
[21:03:47] <tikue> :P
[21:04:50] <tjc> plus a change...
[21:05:35] <bblum> i miss 'try'
[21:06:13] *** Joins: q66_ (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[21:06:13] *** Quits: q66_ (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Client exited)
[21:06:15] <strcat> bblum: just have to manually spin up builds
[21:06:21] *** Quits: mark_edward (quassel@moz-4A5B1251.wisolt4.epbfi.com) (Ping timeout)
[21:06:21] * strcat does it all the time for windows/osx
[21:06:30] <strcat> hijack the master bots ;p
[21:06:54] *** Quits: Jesin (Jessin_@moz-157A63DD.cc.lehigh.edu) (Ping timeout)
[21:07:27] <strcat> try-win is broken
[21:09:19] *** Joins: Jesin (Jessin_@moz-157A63DD.cc.lehigh.edu)
[21:10:24] <bblum> brson: so toddaaro and i were just talking about what kind of locks would have to be used to protect a linked failure group
[21:10:50] <bblum> my old implementation uses exclusives (pthread mutexes) which could block the scheduler thread in case of contention
[21:11:04] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Client exited)
[21:11:14] <bblum> (and the user can control how long the critical section is -- O(n) in number of active generations and/or number of live tasks in group)
[21:11:44] <bblum> we thought perhaps using my sync::Mutex, which blocks on a pipe in case of contention, would be better
[21:11:50] <bblum> it would involve moving MutexARC to libstd though
[21:12:45] <pcwalton> strcat: you know about D ranges, right? how do Rust iterators differ from them>?
[21:12:50] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Ping timeout)
[21:12:56] <strcat> pcwalton: Iterator is the same as ForwardRange
[21:13:11] <strcat> pcwalton: we could rename Iterator -> Range/ForwardRange and next -> pop_front
[21:13:22] <strcat> and then add BidirectionalRange with pop_back, etc.
[21:13:22] <pcwalton> do ranges have extra functionality?
[21:13:25] <strcat> pcwalton: yeah
[21:13:41] <strcat> bidirectional (pop from both ends) and random access
[21:13:50] <pcwalton> ah, I see
[21:13:58] <pcwalton> I guess we could add that stuff backwards compatibly
[21:14:07] <strcat> other than renaming Iterator/next
[21:14:32] <pcwalton> well, I think most people like next() better than pop_front :)
[21:14:39] <pcwalton> pop_front feels so verbose
[21:14:47] <strcat> pcwalton: well it's rarely used manually
[21:14:55] <pcwalton> still
[21:15:16] <pcwalton> I don't see much of an advance over next() and prev()
[21:15:17] <tikue> Range makes me think of [1, 2, 3, N-3, N-2, N-1,]
[21:15:23] *** Joins: itdaniher (it@moz-C885C25B.mit.edu)
[21:15:25] <strcat> pcwalton: prev means something different though
[21:15:27] <pcwalton> given that next() and prev() are Java
[21:15:37] <bblum> can i get the eyes of someone who's familiar with trans
[21:15:41] <strcat> lets say slices were the generic range for vectors
[21:15:43] <pcwalton> I can try
[21:15:57] <strcat> let mut xs = &[1, 2, 3, 4, 5]; xs.pop_back()
[21:15:58] <sp3d> bblum: human sacrifices are not the answer D:
[21:16:02] <strcat> it would be &[1, 2, 3 ,4]
[21:16:03] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[21:16:08] *** Quits: jorendorff (jorendorff@moz-1747FB68.hsd1.tn.comcast.net) (Quit: jorendorff)
[21:16:11] *** Joins: illissius (illissius@moz-19397A63.catv.broadband.hu)
[21:16:14] <bblum> pcwalton: this commit https://github.com/bblum/rust/commit/c5490f94 causes rustc to blow up on stack with 900 frames of trans::type_of::type_of
[21:16:20] <bblum> seems fairly innocuous to me
[21:16:34] <strcat> so for example 'deque' could implement a bidirectional iterator
[21:16:39] <pcwalton> bblum: possibly something wrong with sizing_type_of
[21:16:44] <strcat> with pop_front, pop_back and specialized pop_front_n and pop_back_n
[21:16:53] <strcat> but it can't provide a slice, since it's not contiguous
[21:17:06] <strcat> slices are like a non-generic D range
[21:17:14] *** Quits: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP) (Quit: My MacBook has gone to sleep. ZZZzzz)
[21:17:29] <strcat> except ranges are usually represented as ptr_to_start, ptr_to_end to make the iteration faster
[21:17:38] *** Quits: tjc (tjc@moz-D530ECE9.lightspeed.irvnca.sbcglobal.net) (Quit: zzzzzzzzzz)
[21:17:39] <toddaaro> bblum: having a rust-space mutex available sounds like it would be nice
[21:17:41] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[21:17:54] <toddaaro> bblum: and I don't see any harm it would do
[21:17:54] <strcat> to iterate with a slice you have to offset the ptr and decrease the len with each iteration
[21:18:27] <pcwalton> we could change slices to be ptr-to-start, ptr-to-end
[21:18:38] <bblum> toddaaro: i still think you should try writing one
[21:18:41] <bblum> it's a good exercise
[21:18:45] <toddaaro> bblum: the only arguments against a port I see are 1) work that could be elsewhere and 2) potentially confusing rust programers
[21:19:05] <bblum> why would rust programmers be confused; they wouldn't see this at all
[21:19:06] <toddaaro> I should at some point, I need to finish this refactoring though, my context-swap perforance is not good
[21:19:19] <toddaaro> so if it is never exported yes, that would be the case
[21:19:33] <toddaaro> but maybe it would be useful for some rust user usecases
[21:19:34] <bblum> it's an internal implementation detail
[21:19:39] <bblum> uh well
[21:19:41] <strcat> pcwalton: the vast majority of for loops are with external iterators now btw
[21:19:43] <bblum> we already have such a thing :P
[21:19:43] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[21:19:51] <pcwalton> strcat: yeah, I saw, thanks for that work
[21:19:55] <pcwalton> I'm rebasing my stuff on top of it
[21:19:56] <bblum> toddaaro: how else do you think RWARC would work
[21:20:05] <toddaaro> bblum: rwarc?
[21:20:13] <bblum> toddaaro: extra::arc::RWARC
[21:20:16] <toddaaro> bblum: my typing speed, insert above
[21:20:48] <toddaaro> RWARC doesn't use kernel-mutexes?
[21:21:30] <bblum> of course not
[21:21:54] <toddaaro> I somehow never caught that detail
[21:22:15] <bblum> pcwalton: the weird thing is it doesn't crash until stage1 :|
[21:22:20] <strcat> % git grep for | grep -c '\.each'
[21:22:22] <strcat> 148
[21:22:24] <strcat> strcat@thinktank i ~/projects/rust iterator % git grep for | grep -c '\.advance'
[21:22:26] <strcat> 1050
[21:22:26] <bblum> it compiles fine, but the compiler built out of that doesn't work
[21:22:28] <strcat> ever so slightly closer
[21:22:33] <pcwalton> bblum: it's probably related to the trait bounds thing
[21:22:41] <bblum> which thing?
[21:22:42] <pcwalton> which isn't snapshotted yet, no?
[21:22:44] <toddaaro> bblum: so there is no "optional", we don't want to lose RWARC so the mutex has to end up in the new runtime
[21:22:46] <pcwalton> I thought you landed something related to trait bounds
[21:22:58] *** Quits: eschweic1 (Adium@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[21:23:07] <bblum> pcwalton: well, closure bounds, in this case
[21:23:21] <bblum> so the stage0 compiler should ignore the fn:Copy bound
[21:23:47] <bblum> which makes it even more suspicious that that change would cause stage1 to crash
[21:24:29] <strcat> brson: btw you can use cherry-pick to avoid the merge commits
[21:24:36] <strcat> if they're single-commit ones at least, it's easy
[21:24:46] <strcat> git fetch foo.git branch && git cherry-pick FETCH_HEAD
[21:25:07] <strcat> not that it matters
[21:25:23] *** Joins: eschweic (Adium@2557E599.66715431.D25A875A.IP)
[21:25:47] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[21:25:47] *** ChanServ sets mode: +o dherman
[21:25:58] *** Quits: eschweic (Adium@2557E599.66715431.D25A875A.IP) (Connection reset by peer)
[21:25:59] <bblum> toddaaro: that doesn't matter
[21:25:59] *** Joins: eschweic (Adium@2557E599.66715431.D25A875A.IP)
[21:26:10] <bblum> toddaaro: the mutex isn't in danger; the mutex is implemented in extra::sync already
[21:26:15] <bblum> question is whether to use it
[21:26:59] <pcwalton> strcat: next()/peek()/prev()/peek_prev()?
[21:27:09] <toddaaro> bblum: ah, I guess I didn't quite follow your original comment then, "moving MutexARC to libstd"
[21:27:24] <strcat> pcwalton: not sure, I just think 'prev' would be confusing
[21:27:29] <pcwalton> I just read andrei's article on ranges
[21:27:39] <strcat> because with C++ style iterators, prev would move the iterator back 1
[21:28:14] <pcwalton> isn't that basically the same thing?
[21:28:18] <strcat> pcwalton: well
[21:28:25] <strcat> [1, 2, 3, 4, 5, 6]
[21:28:27] <strcat>  ^
[21:28:31] <strcat> [1, 2, 3, 4, 5, 6]
[21:28:34] <strcat>    ^
[21:28:38] <strcat> C++ style iterator
[21:28:42] <strcat> and 'prev' would move it back to 1
[21:29:02] <strcat> a D one would start as &[1, 2, 3, 4, 5, 6] and pop_front would make &[2, 3, 4, 5, 6]
[21:29:07] <strcat> pop_back would make &[2, 3, 4, 5]
[21:29:14] <strcat> you can't ever get back to 1
[21:29:22] <pcwalton> oh, weird
[21:29:24] <thiez> please don't name pop_front and pop_back :p
[21:29:30] <thiez> name them*
[21:29:42] <strcat> pcwalton: D ranges are basically a generalization of our slices
[21:29:51] <strcat> the full implementation with random access + bidirectional + forward
[21:29:57] <mcpherrin> thiez: I agree.  It should be soda_front and soda_back
[21:29:58] <strcat> so 'iterating' is slicing into a slice
[21:30:18] <thiez> mcpherrin: your API made me thirsty.
[21:30:40] <pcwalton> I'm confused, don't you sometimes want to go backwards though?
[21:30:56] <pcwalton> like in a linked list or whatever
[21:32:34] *** Joins: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk)
[21:32:46] <strcat> pcwalton: possibly, not sure if D ranges handle that case though
[21:32:51] <strcat> you could always just copy the range
[21:33:14] <strcat> unless it's &mut, in rust
[21:33:43] <strcat> pcwalton: a safe vector iterator would be slower if it could go backwards
[21:33:50] <strcat> would need to know about start, current, end
[21:33:50] <pcwalton> strcat: I'm mostly just making sure that we get the interface right for Rust
[21:33:52] <pcwalton> right
[21:34:07] <pcwalton> I don't want to just copy D -- rather I want to make sure we have a reason for everything that we do, because iteration is important
[21:34:12] <pcwalton> to get right
[21:34:16] <bblum> eholk: ping
[21:34:19] <strcat> yeah I left out range stuff for now
[21:34:29] <strcat> until there's actually a useful algorithm that can use it
[21:34:32] <eholk> bblum: pong
[21:34:45] <pcwalton> as long as we can add it later if we need it without terrible pain
[21:34:50] <bblum> eholk: did you ever do better than 16 characters in a row
[21:34:58] <tikue> for (i, el) in elements.enumerate(): { do_something_with_prev(elements[i - 1]); } // wouldn't this be functionally equivalent
[21:35:20] <pcwalton> tikue: not if elements is a linked list
[21:35:27] <tikue> ah
[21:35:29] <eholk> bblum: i don't think so
[21:35:30] <pcwalton> list-ref is O(n)
[21:35:35] <bblum> eholk: i took another look at your thing; the "/_" syntax is gone now so we lost two possible characters, but i realized you could put the code inside a macro and get a "$" after the "."
[21:35:36] <tikue> right
[21:35:52] <eholk> bblum: oh, nice!
[21:35:57] <bblum> so i'm at 15
[21:35:57] <strcat> pcwalton: I think the important part is getting Iterator and Iterable solid (we can't make Iterable yet)
[21:36:06] <strcat> pcwalton: Iterable needs type bounds on trait type parameters to work
[21:36:10] <bblum> eholk: [do foo::<~@&*()>{;}].$x()
[21:36:23] <strcat> trait Iterable<A, T: Iterable<A>> { fn iter(&self) -> T; }
[21:36:26] <eholk> bblum: excellent
[21:36:46] <strcat> and then things like enumerate can be default methods provided for Iterable
[21:37:14] <pcwalton> strcat: right
[21:38:15] <strcat> pcwalton: I think the D abstraction for bidirectional/random is better than the C++ one though, if we do add it
[21:38:28] <strcat> you can always take more than one iterator from the container or clone them
[21:38:32] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[21:38:35] <pcwalton> tying begin and end together is better yeah
[21:38:38] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Ping timeout)
[21:39:01] <strcat> instead of p++ and then p--
[21:39:06] <strcat> you can just copy p, then increment
[21:39:21] <strcat> we need a way to take disjoint &mut slices
[21:39:27] <eholk> bblum: could you use _ as a variable name?
[21:39:38] <strcat> [1, 2, 3, 4, 5] -> &mut [1, 2] and &mut [3, 4, 5]
[21:39:44] <bblum> eholk: i could use _x
[21:40:01] <eholk> yeah, and then you'd be back up to 16, right?
[21:40:30] *** Quits: roo (jesse.rudo@moz-2E0A90D0.dynamic.ip.windstream.net) (Ping timeout)
[21:40:40] <brson> bblum: Moving various sync types to std is potentially fine. My current thinking though is that preemptable linked failure is an expense we can't afford
[21:41:12] *** Quits: cowboyd (cowboyd@moz-1BD02A1E.sw.biz.rr.com) (Client exited)
[21:41:14] <bblum> eholk: check it. 17.
[21:41:14] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[21:41:14] *** ChanServ sets mode: +o dherman
[21:41:20] <bblum> do foo::<~@&*()>{;[]}.$_x()
[21:41:31] <bblum> i got the opening bracket inside the sequence
[21:41:49] <bblum> the type of "foo" had to change to be fn(fn() -> [(), ..0])
[21:41:52] <bblum> which is remarkably silly
[21:42:54] <bblum> if i could get a region variable in there, i'd have the ' character too
[21:43:06] <eholk> bblum: nice!
[21:43:28] <eholk> it'd be fun to make a genetic algorithm to try to do better. It'd also have the side effect of standardizing the rules
[21:43:29] <thiez> Would be nice if the ast visitor actually had comments that informed me what they visit
[21:43:41] <indutny> cmr: you still there?
[21:43:47] <bblum> eholk: sounds like a sigbovik paper (toddaaro suggestion)
[21:44:00] <eholk> let's do it!
[21:44:25] <thiez> so which of these qualifies as a function/method call, and which are declarations: visit_fn, visit_ty_method, visit_trait_method, visit_struct_method?
[21:47:14] *** Joins: jorendorff (jorendorff@moz-1747FB68.hsd1.tn.comcast.net)
[21:47:26] <jld> We've discovered the Rust version of Perl Golf?
[21:48:24] <pcwalton> more like the obfuscated perl contest
[21:49:05] * jld tries to figure out what a JARH .signature would do
[21:49:53] <cmr> indutny: am now
[21:49:59] *** Joins: tcsc (tcsc@moz-ADC0ED45.hsd1.ct.comcast.net)
[21:50:07] <indutny> cmr: great, I've noticed that my PR failed again
[21:50:07] <strcat> pcwalton: anyway it's mostly held back by compiler bugs atm :(
[21:50:09] <indutny> first of all -sorry
[21:50:25] <indutny> next - do you have any idea why there're so many test failures?
[21:50:30] <indutny> they look mostly unrelated
[21:50:32] <strcat> the method resolve problem for generic impls, some remaining default method issues, trait bounds on trait types
[21:50:36] <strcat> my least favourite bugs!
[21:50:41] <indutny> hahahah
[21:50:49] <indutny> strcat: its totally borked
[21:50:58] <indutny> glad that nmatsakis is working towards it
[21:51:05] <strcat> default methods are *soooo* close to working enough
[21:51:15] <indutny> what's default methods?
[21:51:26] <strcat> well here's the iterator one
[21:51:28] <strcat>     fn size_hint(&self) -> (Option<uint>, Option<uint>) { (None, None) }
[21:51:29] <tcsc> for a static array literal do you always have to explicitly indicate the size?
[21:51:32] <strcat> it provides a default impl in the trait
[21:51:40] <bblum> can i write a macro parameterized over a region
[21:51:52] *** Joins: dualhbridge (dad@moz-9FEE6D3B.maine.res.rr.com)
[21:52:07] *** Quits: jorendorff (jorendorff@moz-1747FB68.hsd1.tn.comcast.net) (Ping timeout)
[21:52:14] <strcat> bblum: well it can take a region as a token ;p
[21:52:42] *** Parts: dualhbridge (dad@moz-9FEE6D3B.maine.res.rr.com) ()
[21:52:42] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (No route to host)
[21:52:44] <bblum> as a... token?
[21:52:53] <bblum> i wanna write like macro_rules! foo ( ($r:region) => ... )
[21:52:55] <strcat> iterator!{impl VecIterator -> &'self T, 1}
[21:53:08] <indutny> strcat: ah, for any type
[21:53:08] <strcat> bblum: oh
[21:53:14] <tcsc> e.g. is there an equivalent of c/c++'s `static int foo[] = { 0, 1, 2, 3, 4 }` instead of `static foo: [int, ..5] = [0, 1, 2, 3, 4, 5];`
[21:53:20] <strcat> bblum: I'm not entirely sure - I know it allows them in types
[21:53:26] <strcat> might not be split up :(
[21:53:49] <cmr> tcsc: You could do &'static [int]
[21:53:56] <cmr> tcsc: which is a slice instead of a fixed-size vec
[21:54:00] <cmr> indutny: looking
[21:55:08] <tcsc> cmr: if i have a large array of precomputed data, would that be a good way to store it? 
[21:55:13] <cmr> brson: what is your incoming branch? a bunch of trivial stuff to queue up and push at once?
[21:55:25] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[21:55:31] <cmr> tcsc: static foo: &'static [] is as good as any
[21:57:20] <cmr> Why do we still have test_inherit_env? Didn't we agree it was fragile and not-belonging in the test suite?
[21:57:25] <brson> cmr: yes
[21:57:40] <brson> I was thinking of calling it 'easy' but thought that might be offensive to contributors
[21:57:45] <cmr> heh
[21:58:11] *** Quits: diegoyam (quassel@FF9B1514.A4EC3D18.3A1EC144.IP) (Ping timeout)
[21:58:19] <strcat> E-easy is for tricking someone else into doing something tedious for you, obviously :D
[21:58:57] <cmr> strcat: I called out that trick in my "contributing to rust" post :p
[21:59:31] <bblum> eholk: ok i think i can get 2 more if i use lang items
[21:59:39] *** Joins: roo (jesse.rudo@moz-3625D9C5.dynamic.ip.windstream.net)
[22:00:27] <cmr> strcat: your packages are a godsend for my netbook
[22:00:37] <strcat> cmr: :)
[22:00:45] *** Quits: bytbox (s@moz-D83E9B31.wireless.umd.edu) (Ping timeout)
[22:01:25] <cmr> graydon: ping
[22:01:34] <indutny> cmr: so you agree it was random
[22:01:34] <indutny> :)
[22:01:37] <graydon> cmr: pong
[22:01:38] <cmr> indutny: yeah
[22:01:53] <indutny> I guess something with servers
[22:02:11] <cmr> graydon: Would it be possible to close the tree after the queue clears up a bit? I want to land a "great renaming" patch for the rust codebase
[22:02:19] <graydon> cmr: yes
[22:02:23] <cmr> It.. touches everything
[22:02:35] <tcsc> okay, thanks. another question: how do i import a macro from another module? neither `use my_mod` nor `use my_mod::my_macro` seem to work
[22:02:55] <cmr> tcsc: you need the #[macro_escape]; attribute, I think
[22:03:05] <graydon> for major touches-everything changes it's easiest if I turn off bors for a bit, let you rebase, put it up front with top priority, and let it in
[22:03:14] <graydon> happy to do that on days you have such changes pending
[22:03:34] <cmr> graydon: I'll wait till the weekend, don't want to disrupt real work :)
[22:03:52] * strcat just landed the iterator one with p=1 and rebasing faster than a bors cycle ;p
[22:03:56] <cmr> Or, at least, 'till friday evening
[22:04:00] *** Joins: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP)
[22:04:07] <jack> how do you turn an *mut foo into an *foo? &*foo?
[22:04:07] <cmr> strcat: yeah but it took a week
[22:04:23] <strcat> cmr: well the last one did
[22:04:24] <brson> jack: yes
[22:04:33] <strcat> removing old_iter took a day 
[22:04:43] <brson> jack: then assign it to a *foo variable to coerce the borrowed pointer to an unsafe
[22:05:11] *** Quits: spider-mario (spidermari@moz-B8FA2FF4.rev.sfr.net) (Input/output error)
[22:05:21] *** Joins: diegoyam (quassel@FF9B1514.A4EC3D18.3A1EC144.IP)
[22:06:13] <strcat> rusti: let mut x = 5; let y: uint = &mut x as *mut int as *int as uint; y
[22:06:14] -rusti- 24055696
[22:06:20] <cmr> rusti: let x: *mut int = 6u as *mut int; x as *int
[22:06:21] -rusti- 6
[22:06:25] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[22:06:26] <cmr> jack: ^ too
[22:09:18] *** Joins: timot (timot@58CC50AE.F194A95C.898DC978.IP)
[22:09:22] *** Quits: sw17ch (sw17ch@moz-39D8564F.wndsny.tds.net) (Input/output error)
[22:09:55] <acrichto> could https://github.com/mozilla/rust/pull/7113 get a @bors: rety for later?
[22:10:33] <strcat> acrichto: done
[22:10:41] <jack> brson: is it possible/desireable to have rust auto cast *mut Foo to *Foo just like it does &Foo to *Foo?
[22:11:08] <acrichto> strcat: could you also get https://github.com/mozilla/rust/pull/7291 as well? I think those both died with timing/paging
[22:11:22] <strcat> acrichto: yep
[22:11:27] *** Quits: Jesin (Jessin_@moz-157A63DD.cc.lehigh.edu) (Ping timeout)
[22:11:28] <acrichto> strcat: thanks!
[22:11:38] <strcat> hopefully it worked
[22:11:39] <cmr> brson: some candidates for your incoming branch: https://github.com/mozilla/rust/pull/7315 https://github.com/mozilla/rust/pull/7310
[22:12:05] *** Quits: EXetoC (ex@moz-2DBEB1E4.customer.t3.se) (Quit: WeeChat 0.4.1)
[22:12:38] <bblum> eholk: got 19
[22:12:39] *** Joins: Jesin (Jessin_@moz-157A63DD.cc.lehigh.edu)
[22:12:41] <bblum> using the Neg and Not traits
[22:12:47] <acrichto> cmr: while you're renaming, you should try to remove #[no_std] as well (only libstd should need it)
[22:12:56] <cmr> acrichto: sure thing
[22:13:02] <bblum> eholk: it took me a bit of thought for how to get around "cannot provide an extension implementation for a trait not defined in this crate"
[22:13:05] <bblum> but behold
[22:13:07] <bblum> do foo::<~@&*()>{;!-[]}.$_x()
[22:13:18] *** Quits: rfw (rfw@moz-C65A114.rfw.name) (Ping timeout)
[22:13:27] <thiez> bblum: what *are* you doing? oO
[22:13:33] <eholk> bblum: what is ! in this context?
[22:13:46] <cmr> that scares me
[22:13:47] *** Quits: roo (jesse.rudo@moz-3625D9C5.dynamic.ip.windstream.net) (Ping timeout)
[22:13:59] <strcat> thiez: he stopped being human and became a fuzzer
[22:14:06] <cmr> heh
[22:14:15] <bblum> eholk: ! and - are the lang-item traits Not and Neg respcetively
[22:14:17] <bblum> ! is bit-negation
[22:14:22] <brson> cmr: thanks
[22:14:24] <eholk> ahh, okay
[22:14:48] <brson> jack: that coercion seems ok to me, but nmatsakis would know best
[22:15:11] <strcat> jack: *mut to * is fine
[22:15:16] *** Quits: MaikKlein (maik@moz-129BB64.dip0.t-ipconnect.de) (Ping timeout)
[22:15:23] *** Quits: Kruppe (user@moz-4DDA8AB8.uwaterloo.ca) (Ping timeout)
[22:15:30] <strcat> the only way *mut vs * would matter is if we did alias analysis stuff on it
[22:15:37] <nmatsakis> well...
[22:15:38] <thiez> strcat: I suppose once the compiler has improved to the point where it doesn't segfault/ICE on 10-line programs, we could get a nice fuzzer for it
[22:15:42] <strcat> so the only way it wouldn't be fine is if you said it was * and modified through it
[22:15:53] <cmr> thiez: there was an AST fuzzer
[22:16:00] <cmr> it rotted away tough
[22:16:00] <nmatsakis> I mean, it's fine, but it makes it harder to maintain correctness with respect to * mutability decls
[22:16:11] *** Joins: roo (jesse.rudo@moz-8B7A21DC.dynamic.ip.windstream.net)
[22:16:11] *** Quits: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com) (Ping timeout)
[22:16:19] <nmatsakis> jack: you can use *const, which might be better.
[22:16:33] <thiez> I thought we were getting rid of const?
[22:16:35] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[22:16:42] *** Joins: rfw (rfw@moz-C65A114.rfw.name)
[22:16:49] <nmatsakis> well, it lives on for now... :) but yes, I kno.
[22:16:51] <nmatsakis> *know
[22:16:53] <jack> nmatsakis, brson: the use case is that many C APIs take a *mut in some calls but have lots of calls tha take *. if i keep the types correct, i have to write &*foo a _lot_
[22:16:56] *** Quits: lucian (lucian@moz-22A14C6A.cable.virginmedia.com) (Input/output error)
[22:17:01] <thiez> doesn't it make sense for * to imply what we currently refer to as 'const' since it's unsafe anyway?
[22:17:18] <nmatsakis> thiez: yes, probably
[22:17:20] <bblum> eholk: i am still missing %, ^, #, ', ", ,, /, and ?
[22:17:28] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[22:17:28] *** ChanServ sets mode: +o brson
[22:17:31] <bblum> also ` \ and |
[22:17:37] <jack> currently most of the ffi code i've seen just treats everything as * regardless of mutability
[22:17:37] <nmatsakis> jack: right, I figured. well I'm not necessarily opposed to adding such a coercion---or maybe even just removing the idea of *mut vs *...
[22:17:52] <Luqman> nicklist off
[22:17:58] <brson> i do try to use *mut
[22:18:20] <brson> I *think* i find it helpful
[22:18:28] <cmr> nmatsakis: since it can't be enforced at all, I don't think it's very useful.
[22:18:37] <eholk> bblum: what is # used for now?
[22:18:46] <thiez> brson: how scared are we w.r.t. the ABA-problem? :p
[22:19:00] <jack> nmatsakis: in that case i'll file a bug for it. if we're going to have both, we don't want to discourage *mut use, which is currently the case. or at least i feel like i'm being punished for "doing it right"
[22:19:00] <bblum> eholk: i don't think anything?
[22:19:25] <bblum> eholk: it probably still parses but is deprecated
[22:19:26] <nmatsakis> jack: yeah. I do wonder if we just shouldn't have both though.
[22:19:38] <eholk> bblum: ah, okay 
[22:19:45] <jack> nmatsakis: and treat everything as *mut?
[22:19:47] <brson> thiez: i'm not afraid of ABBA
[22:19:49] <nmatsakis> jack: basically right
[22:20:33] <cmr> Should extra::serialize be in std?
[22:20:38] <cmr> Serialization is pretty important
[22:21:01] <bblum> eholk: my entire program is somewhat longer than yours due to the need for a crate-local type and several impls
[22:21:04] <bblum> https://gist.github.com/bblum/5854174
[22:21:27] <cmr>  [do foo::<~@&*()>{;}]/_.
[22:21:30] <cmr> what does that even do
[22:21:30] <thiez> brson: I'm asking since I've had that lockless message-queue thing lying around for a while, but it's not ABA-proof, and to get it like that would probably require something like adding double-word CAS to the compiler, which isn't even available on many platforms
[22:21:44] <bblum> i was disappointed i couldn't get a region variable named '_
[22:21:46] <bblum> i was so close
[22:22:18] <cmr> on second thought I don't want to know
[22:22:43] <bblum> cmr: [element1, element2, ... elementN]/_ used to be the syntax for a fixed-size vector 
[22:22:55] <brson> thiez: when you say it's not ABA proof does that mean it's not correct?
[22:22:56] <bblum> you'd write [...]/5 for a 5-element, and the _ means "compiler figure it out for me"
[22:23:08] *** Quits: tcsc (tcsc@moz-ADC0ED45.hsd1.ct.comcast.net) (Quit: computer sleeping)
[22:23:23] <brson> does #[link_name] no longer exist?
[22:23:25] <cmr> strcat: you killed old_iter didn't you?
[22:23:29] <strcat> cmr: it's gon
[22:23:30] <strcat> e
[22:23:33] <bblum> brson: ABA is a correctness issue; http://en.wikipedia.org/wiki/ABA_problem
[22:23:42] <cmr> strcat: it's still used in libsyntax, opt_vec.rs?
[22:23:42] <strcat> cmr: about to wipe out even more
[22:23:47] *** Quits: cdidd (cdidd@A88661A.4F80CCBA.62D8163C.IP) (Ping timeout)
[22:23:50] <strcat> cmr: no it's gone
[22:23:56] <thiez> brson: it means that it's vulnerable to a rare bug where you do a CAS but it changes to something else, then back to it's original value without you noticing
[22:23:59] <cmr> strcat: when did the change land?
[22:24:08] <strcat> uhh, last night?
[22:24:12] *** Joins: cdidd (cdidd@A88661A.4F80CCBA.62D8163C.IP)
[22:24:14] <thiez> it's really quite annoying.
[22:24:15] <strcat> I went to sleep before it landed
[22:24:20] <cmr> weird, I pulled this morning :\
[22:24:37] <strcat> cmr: there are still plenty of internal iterators but no more old_iter
[22:24:40] <brson> bblum: thanks. I know what ABA is
[22:24:45] <eholk> bblum: can you replace the . with += ?
[22:25:14] <cmr> | * | e2e3923 - remove old_iter (17 hours ago) <Daniel Micay>
[22:25:16] <bblum> thiez: you solve it with a 2-word cas where the 2nd is a generation counter, right?
[22:25:17] <cmr> is in my repo
[22:25:19] <bblum> eholk: good thinking
[22:25:28] <cmr> but I still see opt_vec.rs, and it's still using old_iter
[22:25:29] <thiez> bblum: yes, that is the usual solution
[22:25:29] <toddaaro> bblum: yea, that is a standard solution
[22:25:44] <strcat> cmr: opt_vec exists, doesn't use old_iter though...
[22:25:45] <toddaaro> bblum: just the akward "basically no platforms have this" situation
[22:25:54] <cmr> Oh it did change
[22:26:01] *** Quits: roo (jesse.rudo@moz-8B7A21DC.dynamic.ip.windstream.net) (Ping timeout)
[22:26:02] <cmr> hurp
[22:26:05] <thiez> or on some platforms you have LL/SC which is even better, but LLVM doesn't even have intrinsics for that
[22:26:08] <cmr> strcat: sorry for the bother :p
[22:26:12] <toddaaro> thiez: LL/SC?
[22:26:14] <bblum> brson: ok, sorry for presuming
[22:26:18] *** kimundi is now known as zz_kimundi
[22:26:21] <thiez> load-linked store-conditional
[22:26:22] <strcat> I just made an external iterator for it
[22:26:28] <strcat> https://github.com/mozilla/rust/blob/master/src/libsyntax/opt_vec.rs#L145
[22:26:42] <thiez> basically your hardware tracks if the value has changed since you loaded it
[22:26:43] <toddaaro> thiez: so the cpu just watches for ABA and tells you?
[22:26:46] <toddaaro> that is awesome
[22:26:54] *** Joins: EXetoC (ex@moz-2DBEB1E4.customer.t3.se)
[22:27:08] <thiez> I think it might actually be more common that 2CAS
[22:27:18] <toddaaro> seems expensive to implement in hardware though - do you know how it works?
[22:27:29] <bblum> eholk: no i think += was removed
[22:27:51] <eholk> i don't suppose ^ is a unary operator, is it?
[22:27:59] <bblum> no that's xor
[22:28:16] <eholk> is [,] legal?
[22:28:17] <thiez> toddaaro: I imagine it's written straight to the shared cache, which could easily keep track, but I have no idea :)
[22:28:19] <brson> thiez: so what is the effect that the ABA bug has on this message queue?
[22:28:37] <bblum> eholk: no but (e,) is
[22:28:45] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[22:28:48] <bblum> eholk: for comma, i was thinking instantiating foo at two types
[22:28:53] <bblum> but i don't know how to name the 2nd type
[22:29:02] <bblum> foo::<@&*~(), ???>
[22:29:14] <bblum> what i was really hoping for was a lifetime instantiation
[22:29:18] <thiez> brson: in some rare cases it might crash and burn horribly, when multiple threads are adding messages while messages are being read
[22:29:23] <bblum> foo::<'_,~@&*()>
[22:29:42] <bblum> but i don't think you can do that explicitly
[22:29:42] <thiez> but I can't really tell how rare. I never ran into crashing and burning, but since these things are nondeterministic there's no way to tell :(
[22:30:13] <thiez> strictly speaking the standard double word CAS solution only makes it even rarer, but doesn't solve it entirely
[22:30:23] <eholk> bblum: it's too bad you can't pass operators as functions
[22:30:35] <thiez> but at that point it is rare enough that it's more likely for your computer to randomly explode :p
[22:30:43] <thiez> even more rare*
[22:30:46] <toddaaro> brson: I think a specific failure could be a queue that happens to only have one message, and that message is a single word representing an enum like Wake, so a "dequeue Wake enqueue Wake" would be invisible potentially?
[22:30:49] <eholk> bblum: then you could replace [] with [+,%]
[22:30:57] <bblum> yeah
[22:31:06] <toddaaro> ABA failures might actually be a risk if we are storing enums like that
[22:31:28] *** Quits: mib_xzv2x1 (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[22:31:49] *** Joins: devbug (quassel@moz-E1DE087C.bchsia.telus.net)
[22:32:10] <toddaaro> thiez: LL/SC would actually solve this right?
[22:32:24] <thiez> toddaaro: yup, but it's not on x86/x64
[22:32:41] <toddaaro> is it coming soon?
[22:32:52] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[22:33:02] <thiez> which is amazing, I mean seriously, we have packed decimal adding but not useful concurrency stuff :p
[22:33:03] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Connection reset by peer)
[22:33:07] <thiez> nope
[22:33:13] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[22:33:13] <toddaaro> oh well
[22:33:17] <thiez> we have to make do with double-word cas
[22:33:20] <pcwalton> we have RDRAND
[22:33:29] <pcwalton> but no LL/SC
[22:34:21] *** Quits: cdidd (cdidd@A88661A.4F80CCBA.62D8163C.IP) (Ping timeout)
[22:34:30] <bblum> eholk: originally i had impl Neg<()> for [(), ..0] but it wouldn't let me impl extensions that trait/type pair
[22:34:41] <bblum> the Hello struct is critical to the success
[22:34:41] *** Quits: diegoyam (quassel@FF9B1514.A4EC3D18.3A1EC144.IP) (Ping timeout)
[22:34:48] <brson> thiez: I think we need to solve this. It sounds scary
[22:34:52] <toddaaro> thiez: do you have any ABA solving thoughts other than 2CAS? People use these datastructures all over the place so presumably they are evading the issue
[22:35:09] <toddaaro> thiez brson : can we twiddle one side of the pointers?
[22:35:18] <eholk> bblum: huh, i think that's the first time i've seen an empty struct
[22:35:29] <bblum> eholk: yeah they're new since last summer
[22:35:57] * eholk needs to write more Rust again
[22:36:16] <thiez> toddaaro: that would be tricky on x86. On x64 we would presumably have enough bits in the pointer to get away with it
[22:36:41] <cmr> thiez: please don't do it
[22:36:52] <cmr> thiez: some correctness tools zero the upper bits/error on write to them
[22:36:56] <cmr> because it's very wrong to do
[22:37:06] <cmr> even if x64 only has a 48 bit virtual address space right now
[22:37:40] <brson> thiez: what paper are you basing this queue off of? do they not address this problem?
[22:39:11] <strcat> rusti: let b = 5u8 as bool; (b, b as u8)
[22:39:12] -rusti- (true, 5)
[22:39:19] <strcat> pcwalton: would that be hard to fix ^?
[22:39:29] <pcwalton> erp
[22:39:32] <pcwalton> probably easy to fix
[22:39:33] <toddaaro> thiez: which algorithm did you implement? michael scott?
[22:39:43] *** Joins: cdidd (cdidd@A88661A.4F80CCBA.62D8163C.IP)
[22:40:11] <nmatsakis> thiez: what architectures lack the 2cas operation?
[22:40:18] <bblum> rusti: let b = 4u8 as bool; (b, b as u8)
[22:40:19] -rusti- (true, 4)
[22:40:20] <pcwalton> that sounds like that could cause problems elsewhere
[22:40:26] <strcat> pcwalton: it does
[22:40:27] <thiez> toddaaro: I think that was it, I originally got it from The Art of Multiprocessor Programming, but that uses Java so the GC takes care of ABA for us, but I think they use the michael scott one
[22:40:32] <thiez> let me check :)
[22:40:32] <strcat> pcwalton: breaks match
[22:40:35] <strcat> well
[22:40:37] <strcat> kind of...
[22:40:39] <strcat> it's really weird
[22:40:44] <tikue> rusti: let b = 5u8; (b, b as bool)
[22:40:45] -rusti- (5, true)
[22:40:52] <strcat> we put range asserts on bool loads now
[22:40:58] <strcat> so it's really bad
[22:41:04] <bblum> rusti: match (5u8 as bool) { true => "good", false => "bad" }
[22:41:05] -rusti- "bad"
[22:41:28] <bblum> rusti: match (5u8 as bool) { false => "good", true => "bad" }
[22:41:29] -rusti- "bad"
[22:41:37] <bblum> that's the stupidest
[22:41:38] <ecr> well then
[22:41:39] <strcat> pcwalton: I think we should be treating them as i1 except for storage, like clang
[22:41:42] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[22:41:44] <strcat> but maybe that's a major change
[22:41:44] <sully> that is hilarious.
[22:41:50] <pcwalton> yeah, let's do what clang does
[22:41:54] <sully> "noncanonical bools"
[22:42:09] <strcat> pcwalton: it truncates to i1 immediately after a load and does zext for a store
[22:42:17] <strcat> and passes as i1 zeroext
[22:42:19] <strcat> for functions
[22:42:19] <toddaaro> thiez: I'd have to think about this - it might be that ABA doesn't matter at all with enums as those aren't things that get CASed (bblum got me thinking)
[22:42:26] <tikue> rusti: 5u32 as bool
[22:42:26] -rusti- true
[22:42:29] <toddaaro> thiez: so in that case ABA is less risky
[22:42:34] <tikue> rusti: 5 as bool
[22:42:34] -rusti- true
[22:42:35] <Jesse> clang has -fsanitize=bool: Load of a bool value which is neither true nor false.
[22:42:41] <bblum> fantasize bool
[22:42:41] <ecr> rusti: 0 as bool
[22:42:42] -rusti- false
[22:42:43] <thiez> toddaaro: it uses a linked-list kind of queue
[22:42:51] <strcat> pcwalton: I guess 'as' should be doing zext to i1
[22:42:52] <thiez> so the problem is in the malloc/free :)
[22:42:58] <pcwalton> yeah
[22:43:01] *** Joins: diegoyam (quassel@FF9B1514.A4EC3D18.3A1EC144.IP)
[22:43:04] <strcat> err
[22:43:06] <strcat> I mean truncate
[22:43:15] <strcat> whatever it is ;p
[22:43:32] <nmatsakis> cmr: regarding the compile-time measurements for https://github.com/mozilla/rust/pull/7262, when I measured locally I saw (a) no significant diff in LLVM instrs generated and (b) no significant diff in runtime...
[22:43:40] <toddaaro> thiez: ok - I think a workstealing dequeue is what hits ABA if you queue an enum, as those use an array representation
[22:43:49] <nmatsakis> cmr: however I had to do a lot of rebasing, maybe the comparison point wasn't quite right?
[22:43:59] <Jesse> "as bool" shouldn't be a thing at all. be explicit (x != 0) or (x & 1 == 1).
[22:44:04] <cmr> nmatsakis: want me to re-bench?
[22:44:13] <thiez> toddaaro: I never cas the actual values, I have containers
[22:44:13] <nmatsakis> cmr: yes, if it's easy to do.
[22:44:17] <cmr> nmatsakis: it is :D
[22:44:21] <strcat> Jesse: true, could just remove 'as bool'
[22:44:24] <cmr> nmatsakis: is it rebased against *current master*?
[22:44:27] <toddaaro> thiez: yea, with a linked-list structure that would be the case
[22:44:29] * pcwalton never liked "as bool"
[22:44:38] <thiez> toddaaro: https://github.com/Thiez/rust/blob/ll-message-queue/src/libstd/rt/message_queue.rs
[22:44:39] <strcat> it being wrong is a good reason to rm it ;p
[22:44:44] <Jesse> strcat++
[22:44:49] <thiez> I think that's the latest version
[22:45:09] <nmatsakis> cmr: just freshly rebased. it'll screw up bors queue, but whatever.
[22:45:13] <strcat> rusti: let x = 5u8 as bool; x == true
[22:45:14] -rusti- false
[22:45:15] * nmatsakis hopes not badly.
[22:45:16] <strcat> rusti: let x = 5u8 as bool; x == false
[22:45:17] -rusti- false
[22:45:31] <nmatsakis> cmr: whta I mean is, I'll lose my place in line :) but I'd like to be sure I don't make things run slow
[22:45:33] <strcat> rusti: let x = 5u8 as bool; match x { true => 1, false => 2 }
[22:45:34] -rusti- 2
[22:45:50] <strcat> rusti: let x = 5u8 as bool; if x == true { 2 } else { 3 }
[22:45:51] -rusti- 3
[22:45:56] <strcat> rusti: let x = 5u8 as bool; if x == true { 2 } else if x == false { 3 }
[22:45:56] <thiez> rusti: let x = 5u8 != std::num::Zero::zero() ; x
[22:45:57] <nmatsakis> cmr: so yeah pull now it should be rebased against *current master*
[22:45:58] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/ASCb
[22:45:58] -rusti- true
[22:46:04] <toddaaro> thiez: I guess I'm stumped as to ABA solutions, I'll ask the lock-free data structure people I know about it though
[22:46:23] <toddaaro> thiez: if we can't rely on pointer twiddling or 2CAS that is a bit icky
[22:46:39] <nmatsakis> graydon: er, do I mess up bors if I force-push when it's already enqueued?
[22:46:44] <cmr> nmatsakis: seems some buildbots are down anyway, you could p=1 it, shouldn't take long to measure... (~25 minutes)
[22:46:49] <strcat> nmatsakis: no
[22:46:54] <nmatsakis> graydon: (but not yet started building or anything)
[22:46:59] <graydon> nmatsakis: force-push to where?
[22:47:06] <nmatsakis> graydon: that is, force-push to my branc.
[22:47:07] <strcat> you mean to your PR right?
[22:47:10] <strcat> nmatsakis: even if it's currently building it handles it okay - it just cancels and tries again
[22:47:10] <nmatsakis> yes.
[22:47:12] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[22:47:19] <tikue> rusti: match 5u8 as bool { 5u8 as bool => true, false => false }
[22:47:20] -rusti- <anon>:9:33: 9:35 error: expected `=>` but found `as`
[22:47:20] -rusti- <anon>:9          match 5u8 as bool { 5u8 as bool => true, false => false }
[22:47:20] -rusti-                                           ^~
[22:47:20] -rusti- application terminated with error code 101
[22:47:20] *** Quits: diegoyam (quassel@FF9B1514.A4EC3D18.3A1EC144.IP) (Ping timeout)
[22:47:45] <graydon> nmatsakis: it'll forget about your branch and forget about why it was building the thing it's already building (assuming it's building something)
[22:47:54] <thiez> toddaaro: I think the nicest thing would be to have some ABA-proof atomic-type, that could use 2cas on x64/x86, and ll/sc on other machines
[22:47:57] *** Quits: bnicholson (bnicholson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[22:48:05] <thiez> then many of these algorithms could be implemented safely
[22:48:11] <nmatsakis> graydon: ok, right now it was r+'d, but not yet at top of queue. presumably it'll just drop off queue?
[22:48:14] <graydon> nmatsakis: you're essentially disconnecting work-it-is-doing from any records of why it might be doing that, so it'll just move on to new work
[22:48:25] <toddaaro> thiez: yea, that would be ideal, but there would still need to be a fallback for the less-enlightened architectures
[22:48:31] <thiez> I suppose it could be done with the asm!() syntax extension, but I have no idea how that works.
[22:48:45] <strcat> nmatsakis: just don't do what I did when it went haywire ;p
[22:48:47] <graydon> nmatsakis: it sees a chain of PR -> head pull -> r+-on-head-pull -> results-from-buildbot-on-head-pull
[22:48:48] <thiez> well, brson already has a blocking queue that should work for those cases
[22:48:55] <thiez> that could be the default
[22:48:56] <graydon> if you break any link in that chain, it has no idea there was anything else there before
[22:48:57] <sully> it seems reasonable to me to disallow casting int -> bool
[22:48:57] <cmr> nmatsakis: we're pretty close to a snapshot, I could make it quicklike (although potentially less accurate) and bench stage1, if you want. If this didn't change codegen at all, it'll be fine
[22:48:59] <strcat> it was lagging by 30 mins so it hadn't picked up a close of a PR
[22:49:00] <bblum> thiez:  that would be a pretty useful primitive
[22:49:02] <strcat> and I'd reopened it
[22:49:05] <strcat> and it saw the saw commit twice
[22:49:07] <nmatsakis> graydon: ok. that's more or less what I assumed.
[22:49:08] <strcat> and... went insane
[22:49:11] <nmatsakis> cmr: this definitely changes codegen :)
[22:49:14] <nmatsakis> cmr: just do the full run...
[22:49:17] <cmr> nmatsakis: alrighty :)
[22:49:26] <cmr> Oh, closes 5 bugs in one
[22:49:35] <cmr> You trumped.. Blei, I think, who got a 4-in-one
[22:49:47] <nmatsakis> cmr: I suspect there are a few more bugs I could pick off...
[22:49:54] <nmatsakis> cmr: ...I just got tired of searching for them.
[22:50:02] <cmr> heh
[22:50:10] <cmr> triage will pick them up eventually
[22:50:17] <strcat> pcwalton: we have similar issues with 'as char'
[22:50:25] <strcat> that's a tougher problem
[22:50:29] <strcat> but...
[22:50:37] <strcat> rusti: -1u32 as char
[22:50:38] -rusti- rust: task failed at 'assertion failed: s.len() <= pad', /build/rust-git/src/rust/src/libstd/char.rs:211
[22:50:38] -rusti- rust: domain main @0xcee1b0 root task failed
[22:50:38] -rusti- application terminated with error code 101
[22:50:43] <strcat> wat
[22:50:50] <strcat> rusti: let x = -1u32 as char;
[22:50:51] -rusti- <anon>:9:13: 9:14 warning: unused variable: `x` [-W unused-variable (default)]
[22:50:51] -rusti- <anon>:9          let x = -1u32 as char;
[22:50:51] -rusti-                       ^
[22:50:54] -rusti- ()
[22:50:55] <strcat> oh fmt dies
[22:52:12] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[22:52:26] <tikue> rusti: let five = 5u8 as bool; match five { five => true, _ => false }
[22:52:26] -rusti- <anon>:9:60: 9:61 error: unreachable pattern
[22:52:26] -rusti- <anon>:9          let five = 5u8 as bool; match five { five => true, _ => false }
[22:52:26] -rusti-                                                                      ^
[22:52:27] -rusti- error: aborting due to previous error
[22:52:27] -rusti- application terminated with error code 101
[22:52:53] <thiez> rusti: let x = -1u32 as char; x as u32
[22:52:54] -rusti- 4294967295
[22:53:06] <thiez> why do we allow -1u32 anyway?
[22:53:21] <strcat> thiez: because - isn't part of the literal
[22:53:28] <tikue> why wouldn't you?
[22:53:30] <strcat> in the grammar
[22:53:32] <thiez> rusti: let x = (-1)u32; x
[22:53:32] -rusti- <anon>:9:21: 9:24 error: expected `;` but found `u32`
[22:53:33] -rusti- <anon>:9          let x = (-1)u32; x
[22:53:33] -rusti-                               ^~~
[22:53:33] -rusti- application terminated with error code 101
[22:53:36] *** Quits: lucian (lucian@moz-22A14C6A.cable.virginmedia.com) (Ping timeout)
[22:53:41] <strcat> thiez: other way ;p
[22:53:46] <thiez> rusti: let x = (-1) as u32; x
[22:53:47] -rusti- 4294967295
[22:53:50] <thiez> well that is a shame :D
[22:53:51] <strcat> I mean
[22:53:56] <strcat> rusti: -(1u8)
[22:53:57] -rusti- 255
[22:54:00] <tikue> thiez: why is that a shame
[22:54:03] <strcat> is how it parses -1u8
[22:54:13] <thiez> we ran into a funny situation earlier today
[22:54:15] <cmr> tikue: because it's an invalid value for that type..
[22:54:19] <thiez> rusti: -5.0.sqrt()
[22:54:20] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/SVBh
[22:54:30] <thiez> rusti: -5.0f.sqrt()
[22:54:31] -rusti- -2.23606798
[22:55:03] <thiez> . has higher precedence than unary - :D
[22:55:29] <cmr> also
[22:55:30] <tikue> cmr: 2^32 is 4293967296, why is it an invalid value?
[22:55:38] <cmr> rusti: (-5.0f).sqrt()
[22:55:39] -rusti- NaN
[22:55:44] *** Joins: diegoyam (quassel@FF9B1514.A4EC3D18.3A1EC144.IP)
[22:55:47] <cmr> whoa why is that behaving differently now
[22:55:50] <cmr> tikue: -1 is invalid.
[22:55:55] <cmr> tikue: it's out of bounds
[22:56:10] <tikue> cmr: you think you shouldn't be able to cast from int to uint?
[22:56:12] <thiez> tikue: for one, 2^32 does not fit in any 32-bit register :p
[22:56:16] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Quit: jedestep)
[22:56:28] <strcat> tikue: the literal isn't an int
[22:56:35] <cmr> tikue: not implicitly, in the literal syntax.
[22:56:38] <tikue> thiez: yes but 2^32 - 1does
[22:56:39] <strcat> he just wants - to be part of the literal
[22:56:53] <cmr> rusti: let x: u32 = 5; x = -1; x
[22:56:54] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/ZQbD
[22:57:00] <cmr> rusti: let mut x: u32 = 5; x = -1; x
[22:57:01] -rusti- <anon>:9:17: 9:18 warning: value assigned to `x` is never read [-W dead-assignment (default)]
[22:57:01] -rusti- <anon>:9          let mut x: u32 = 5; x = -1; x
[22:57:01] -rusti-                           ^
[22:57:01] -rusti- 4294967295
[22:57:06] <thiez> let x: u32 = -1; x
[22:57:12] <thiez> rusti: let x: u32 = -1; x
[22:57:13] -rusti- 4294967295
[22:57:18] <thiez> that is even worse :p
[22:57:23] <strcat> not really
[22:57:26] <strcat> -1 could be an int there
[22:57:30] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[22:57:30] *** ChanServ sets mode: +o dherman
[22:57:36] <tikue> thiez: I think it's reasonable behavior, idk
[22:57:45] <cmr> tikue: It's reasonable, it's just incorrect.
[22:58:02] <cmr> Makes perfect sense, but it shouldn't be allowed.
[22:58:07] <thiez> rusti: let x = 5i32; let y: u32 = x; x
[22:58:08] -rusti- <anon>:9:36: 9:37 error: mismatched types: expected `u32` but found `i32` (expected u32 but found i32)
[22:58:08] -rusti- <anon>:9          let x = 5i32; let y: u32 = x; x
[22:58:08] -rusti-                                              ^
[22:58:08] -rusti- error: aborting due to previous error
[22:58:08] -rusti- application terminated with error code 101
[22:58:09] <tikue> cmr: why is it incorrect?
[22:58:14] <thiez> that's why.
[22:58:18] <cmr> tikue: because -1 is an invalid value for a u32
[22:58:19] <thiez> we can't assign ints to uints
[22:58:26] <thiez> but we can when it's a literal
[22:58:35] <strcat> thiez: it's not actually doing what you think
[22:58:41] <strcat> rusti: let x = 1u8; -x
[22:58:42] -rusti- 255
[22:58:43] <tikue> cmr: -1 could just be considered shorthand for 32 ones
[22:58:44] <strcat> when it sees
[22:58:49] <strcat> let x: u8 = -1;
[22:58:52] <strcat> it infers 1 to be a u8
[22:58:55] <strcat> and then it runs - on it
[22:59:00] * thiez cries a little.
[22:59:26] <cmr> tikue: Use num::max_value() if you want that
[22:59:28] <thiez> I suppose unary minus never makes sense on an unsigned value anyway
[22:59:41] <strcat> rusti: -5u8
[22:59:42] -rusti- 251
[22:59:43] *** Quits: Jesin (Jessin_@moz-157A63DD.cc.lehigh.edu) (Quit: Leaving)
[22:59:49] <tikue> thiez: why shouldn't literals be able to be interpreted as either int or uint?
[22:59:54] <strcat> thiez: 0u8 - 5
[22:59:56] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[23:00:00] <strcat> rusti: : 0u8 - 5
[23:00:00] -rusti- <anon>:9:9: 9:10 error: unexpected token: `:`
[23:00:00] -rusti- <anon>:9          : 0u8 - 5
[23:00:01] -rusti-                   ^
[23:00:01] -rusti- application terminated with error code 101
[23:00:06] <strcat> rusti: 0u8 - 5
[23:00:07] -rusti- 251
[23:00:17] <thiez> ohwell
[23:00:17] <cmr> tikue: It makes sense to the machine and in 2s complement, but it's completely invalid math.
[23:00:25] <strcat> cmr: no it isn't
[23:00:27] <strcat> it's valid math
[23:00:33] <thiez> I guess we can define everything to be 2-complement and be done with it
[23:00:35] <strcat> https://en.wikipedia.org/wiki/Modular_arithmetic
[23:00:41] <cmr> ok, modular arith doesn't count :p
[23:00:43] *** Quits: Azdle (Azdle@moz-B334B496.hfc.comcastbusiness.net) (Quit: Leaving)
[23:00:44] <strcat> yes it does
[23:00:53] <thiez> rusti: (-5u8,!5u8)
[23:00:54] -rusti- (251, 250)
[23:00:57] <strcat> don't use hardware-signed ints if you don't want modular arithmetic ;p
[23:01:04] <strcat> u8 is math modulo 256
[23:01:11] <strcat> that's what it's defined to be
[23:01:18] *** Quits: Voomer (Voomer@moz-E97E8EB7.br.br.cox.net) (Ping timeout)
[23:02:04] <cmr> I just think literals should be bounded by the bounds of the type they are going to be stored in... and over/underflow shouldn't be allowed outside of unsafe blocks.
[23:02:10] <cmr> just my opinion though
[23:02:17] <strcat> cmr: it's well defined
[23:02:20] <strcat> perfectly safe
[23:02:27] <cmr> strcat: perfectly safe but easy to make bugs with it.
[23:02:36] <thiez> cmr: I disagree with you there
[23:02:38] <strcat> cmr: so use a proper type
[23:02:45] <strcat> use a big int
[23:03:05] *** Joins: bnicholson (bnicholson@2557E599.66715431.D25A875A.IP)
[23:03:09] <strcat> int, uint, i{8,16,32,64}, u{8,16,32,64} are clearly defined as wrapping
[23:03:20] <thiez> strcat: we have an official definition? :p
[23:03:24] <strcat> yes
[23:03:41] <strcat> it's well defined as wrapping, we ask LLVM for well-defined wrapping behaviour
[23:03:47] <thiez> nice, since i{8,16,32,64} overflow is undefined in C
[23:04:00] <strcat> thiez: clang/gcc have -fwrapv though
[23:04:12] <thiez> fair enough
[23:04:27] <strcat> in LLVM IR, clang marks signed int operations as nsw
[23:04:32] <strcat> to explicitly *make them* undefined
[23:04:38] <strcat> so it can optimize based on that assumption
[23:04:56] <strcat> nuw and nsw stand for No Unsigned Wrap and No Signed Wrap, respectively. If the nuw and/or nsw keywords are present, the result value of the add is a poison value if unsigned and/or signed overflow, respectively, occurs.
[23:05:09] <strcat> and using a poison value is undef behaviour
[23:05:33] <thiez> I really like how LLVM works on the inside
[23:05:41] *** Joins: Voomer (Voomer@moz-E97E8EB7.br.br.cox.net)
[23:05:58] <strcat> bool even(int x) { return !(x & 1) }
[23:06:02] <strcat> valid even function in C
[23:06:06] <strcat> now..
[23:06:11] <strcat> bool even(int x) { INT_MAX + x; return !(x & 1) }
[23:06:36] <thiez> bool foo(int x) { return (x+1)>x } :p
[23:06:50] <strcat> the compiler can assume x is always 0
[23:06:54] <strcat> due to INT_MAX + x being there
[23:07:09] <strcat> LLVM actually understands certain things like that to be 'assertions' of type properties
[23:07:33] <pcwalton> stage0 librustc trans is 110 s for me, stage1 is 15 s
[23:07:37] <pcwalton> that's swapping I'm sure
[23:07:53] <cmr> pcwalton: you know, you can watch htop to figure out when you swap :p
[23:07:54] <pcwalton> LLVM passes are 247 s -> 239 s
[23:08:00] <tikue> strcat: so you're saying that that second even function is broken in LLVM?
[23:08:05] <pcwalton> also swapping
[23:08:14] <pcwalton> we need to just dump everything before running LLVM passes
[23:08:16] <strcat> tikue: no I'm saying it's only guaranteed to work for 0, in any C compiler
[23:08:24] <cmr> pcwalton: that's what I thought!
[23:08:25] <tikue> strcat: gotcha
[23:08:26] <strcat> tikue: and yes - clang/gcc will optimize with that assumption
[23:08:31] <strcat> tikue: undefined behaviour is fun
[23:08:39] *** Quits: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Quit: msingle)
[23:08:39] <strcat> they can see 'oh look, undef behaviour happens if x isn't 0'
[23:08:42] <strcat> therefore, x is *always* 0
[23:08:52] <thiez> yes, I love those
[23:08:54] <cmr> pcwalton: There's almost 750MB of gunk that sticks around for no reason
[23:09:01] <pcwalton> cmr: yeah
[23:09:06] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[23:09:10] <pcwalton> fixing that would massively improve my productivity
[23:09:17] <strcat> if (x > y) { puts("foo"); INT_MAX + 1 } else { puts("bar") }
[23:09:21] <strcat> so
[23:09:26] <strcat> it can optimize that to puts("bar")
[23:09:41] <strcat> and also assume that x isn't *ever* greater than y
[23:09:49] <strcat> so you can see how undefined behaviour can propagate :)
[23:09:55] <tikue> :|
[23:09:57] <cmr> pcwalton: I think an easy bandaid fix would be dumping the IR to disk, starting a new task to load and run llvm on that, and killing all the other tasks
[23:10:03] <pcwalton> cmr: it's even easier
[23:10:11] <pcwalton> just stop all the other tasks
[23:10:13] <pcwalton> no shared memory
[23:10:18] <sp3d> strcat: really, it can move "back in time" to erase the puts("foo")?
[23:10:20] <pcwalton> send the ModuleRef back and destroy everything else
[23:10:25] <strcat> sp3d: yes
[23:10:34] <strcat> sp3d: it sees undef behaviour could happen, it's allowed to assume it never does
[23:10:35] *** Quits: Excureo (c@moz-B0B6F5C3.static.knwc.wa.charter.com) (Ping timeout)
[23:10:38] <strcat> and compilers do that.
[23:10:42] <cmr> pcwalton: Ah, because LLVM stuff isn't task-local, right? it's internal to llvm?
[23:10:46] <pcwalton> yeah
[23:10:49] <cmr> fancy :D
[23:10:59] <sp3d> hrm
[23:11:03] <strcat> sp3d: the specific examples may not yet optimize to what they could - but the point is they *could*
[23:11:09] <strcat> and there are lots of examples of programs breaking
[23:11:10] <sp3d> yeah
[23:11:11] <strcat> gcc 4.8 came out
[23:11:13] <strcat> zlib broke
[23:11:13] <cmr> pcwalton: I'm slowly working on removing all/most of the @ from syntax
[23:11:14] <graydon> pcwalton: we dump everything we can before running llvm
[23:11:17] <strcat> why? zlib used undef behaviour
[23:11:21] <sp3d> I understand the general idea but didn't think it reached quite so far
[23:11:21] <cmr> graydon: I'm not convinced that is true.
[23:11:21] <pcwalton> graydon: hmm
[23:11:24] <strcat> and gcc optimized out critical loops completely
[23:11:35] <pcwalton> graydon: based on the graphs I've seen from cmr that doesn't seem true
[23:11:38] <cmr> graydon: http://octayn.net/rustc.png the flatline after the big spike is llvm.
[23:12:02] <strcat> sp3d: yeah it's scarier than people realize
[23:12:11] <strcat> when compilers get better, lots of code is going to break
[23:12:11] <cmr> graydon: the bumpy plateaus after the initial spike are typeck and the big spike is borrowck and then trans, I think
[23:12:38] <strcat> and this is why we need to fix the undef behaviour in our IR ;p
[23:12:40] *** Joins: Excureo (c@moz-B0B6F5C3.static.knwc.wa.charter.com)
[23:12:54] <pcwalton> does the LLVM lint tell us all of it?
[23:12:59] <cmr> no
[23:13:02] <cmr> it's nowhere near comprehensive
[23:13:03] <strcat> pcwalton: just ones it can easily statically catch
[23:13:09] <strcat> and not even all of the ones it *could* statically catch
[23:13:11] <pcwalton> sure
[23:13:23] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[23:13:30] <pcwalton> obviously undefined behavior includes all of the borrow check unsoundnesses for example
[23:13:40] <pcwalton> but I'm wondering if there's egregious stuff we know about that isn't caught by the linter
[23:13:41] <strcat> we do a lot of weird pointer casts that are trivially invalid but it doesn't show up in lint
[23:13:42] <graydon>     let (llcx, llmod, link_meta) = { ... entire compilation ... };
[23:13:52] <pcwalton> ah
[23:13:53] <bblum> toddaaro: brson: i'm inclined to say ABA may not be a problem on message_queue because each user only reads or writes; no user does both... but i haven't thought hard enough to say it with confidence
[23:14:03] <bblum> thiez too
[23:14:10] <graydon> you tell me. maybe we're not freeing properly, but we _do_ have it structured to dump nearly everything.
[23:14:12] <pcwalton> graydon: is it do spawn { ... entire compilation ... }?
[23:14:16] <doener> strcat: do you have an example for such a cast?
[23:14:20] <pcwalton> that won't free cycles
[23:14:34] <graydon> that's true. and we keep the AST.
[23:14:39] <cmr> the ast is huge
[23:14:50] <graydon> we could hoist this a bit higher
[23:14:52] <strcat> doener: I have a few recent bug reports with some examples
[23:14:58] <graydon> see compile_rest in driver.rs
[23:14:59] <strcat> we haven;t figured out exactly where they go wrong though...
[23:15:02] <graydon> feel free
[23:15:10] <strcat> as in it's obviously invalid but... where does it come from?
[23:15:10] <cmr> I think the ast is the initial rapid rise in the graph
[23:15:17] <cmr> So, ~500MB
[23:15:25] <cmr> (I'm almost certain of it)
[23:15:26] <graydon> quite possibly
[23:15:40] <graydon> the data structures could not be less memory-efficient if they tried :(
[23:15:45] <cmr> Yeah seriously
[23:15:47] <doener> strcat: I've been looking for casting rules for LLVM, but couldn't find anything useful, that's why I'm asking
[23:15:50] <cmr> I'm going through and cleaning up libsyntax
[23:15:52] <cmr> but... it's not easy
[23:15:59] <cmr> some of the code is very obviously *very* old
[23:16:10] <brson> when does jclements return?
[23:16:12] <strcat> doener: well we get alignment wrong, for example
[23:16:28] <strcat> doener: we can't allocate an i8 array and cast to i16
[23:16:39] <pcwalton> throwing away the AST should reduce the peak a lot
[23:16:46] <strcat> directly at least
[23:16:56] <thiez> bblum: that doesn't make a difference I think
[23:17:08] <thiez> bblum: it'll still go kaboom in some cases :D
[23:17:11] <strcat> (that's a bad example ;p)
[23:17:14] <cmr> graydon: it would also allow us to run more builds on a builder, right?
[23:17:19] <cmr> if memory usage were halfed
[23:17:20] <bblum> thiez: example?
[23:17:25] <graydon> cmr: yes
[23:17:32] <graydon> cmr: and land a gc, and many other nice things
[23:17:35] <graydon> don't let me discourage you!
[23:17:36] <graydon> sorry
[23:17:37] <strcat> doener: http://llvm.org/docs/GetElementPtr.html there's a lot here, that we likely violate
[23:18:09] * strcat shrugs
[23:18:17] <cmr> pcwalton: I don't really feel like fixing it, too much other work going on right now..
[23:18:29] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[23:18:34] * cmr bows towards the alter of git-stash
[23:18:36] <strcat> There is currently no checker for the getelementptr rules. Currently, the only way to do this is to manually check each place in your front-end where GetElementPtr operators are created.
[23:18:51] <strcat> (we need IR tests ;p)
[23:19:46] <cmr> pcwalton: http://www.ug.it.usyd.edu.au/~hwil7821/rust-bench/core-std.rs.png
[23:19:52] <cmr> pcwalton: best annotation of the various stages atm
[23:20:01] *** Quits: eholk (eholk@moz-3EC295FB.uconnect.utah.edu) (Quit: eholk)
[23:20:10] <cmr> (that graph uses jemalloc I think, and is a short build, thus the very different shape)
[23:20:16] <thiez> bblum: eh, I'd have to draw a picture I think. Regardless, after popping the node is free'd immediately, and another task could then reacquire its address when it does malloc
[23:20:33] <bblum> thiez: hmm
[23:20:36] <bblum> hmm
[23:20:39] <bblum> i think i believe it
[23:20:46] <thiez> so it doesn't require 1 thread to both push and pop, because that could be divided between 2 threads
[23:20:48] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[23:20:55] <strcat> doener: for example, if we ever do offsets from null with integers
[23:20:55] *** Joins: eholk (eholk@moz-3EC295FB.uconnect.utah.edu)
[23:20:57] <strcat> like 
[23:21:01] <thiez> they conspire to break my beautiful queue ;)
[23:21:08] <bblum> B pushes a block; A does a nonatomic read; C removes B's block, B pushes another block; A compare-and-swap
[23:21:13] <bblum> yes
[23:21:47] <strcat> rusti: /* this is undefined */ let a = 5; let x: *int = 0 as *int; let y: uint = &a as *int as uint; x.offset(y)
[23:21:49] -rusti- 218561664
[23:22:01] <strcat> rusti: /* this is undefined */ let a = 5; let x: *int = 0 as *int; let y: uint = &a as *int as uint; unsafe { *(x.offset(y)) }
[23:22:02] -rusti- application terminated abnormally with signal 11 (Segmentation fault)
[23:22:08] <strcat> whoops
[23:22:09] <strcat> sec
[23:22:30] <strcat> offset doesn't use bytes, forgot
[23:22:35] *** Quits: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP) (Quit: My MacBook has gone to sleep. ZZZzzz)
[23:22:46] <cmr> pcwalton: anyway, there's very obvious wins to be had here, on the order of 70MB for small builds, and probably almost a gig for librustc builds...
[23:22:49] <strcat> rusti: /* this is undefined */ let a = 5u8; let x: *u8 = 0 as *u8; let y: uint = &a as *u8 as uint; unsafe { *(x.offset(y)) }
[23:22:50] -rusti- 5
[23:22:55] *** Joins: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP)
[23:22:56] <pcwalton> cmr: right
[23:22:58] <cmr> pcwalton: just my guestimation
[23:23:08] * cmr goes off to eat
[23:23:25] <thiez> strcat: that is both horrible and pretty awesome
[23:23:41] <strcat> anyway offsets from null are undefined
[23:23:44] <thiez> is it truly undefined tho?
[23:23:47] <strcat> thiez: yes
[23:23:56] *** Quits: Excureo (c@moz-B0B6F5C3.static.knwc.wa.charter.com) (Ping timeout)
[23:23:58] <strcat> it works, but it's undefined
[23:23:58] <thiez> I imagine in C they are, because NULL is not required to be 0
[23:24:03] <strcat> with -O it could break
[23:24:11] *** Quits: jyasskin_w (jyasskin@DAF66858.C60FE7DC.4065847B.IP) (Client exited)
[23:24:18] <strcat> thiez: if you use inttoptr with 0, it's allowed
[23:24:23] <strcat> but LLVM considers it undefined with a null ptr
[23:24:38] <thiez> it's not a null ptr, it's a 0 ptr
[23:24:53] <doener> null is defined to be zero in llvm
[23:24:57] <thiez> rust-nulls are better than c-nulls
[23:25:01] <strcat> doener: but offsets from null are undefined
[23:25:20] <strcat> The underlying integer computation is sufficiently defined; null has a defined value  zero  and you can add whatever value you want to it.
[23:25:22] <strcat> However, its invalid to access (load from or store to) an LLVM-aware object with such a pointer. This includes GlobalVariables, Allocas, and objects pointed to by noalias pointers.
[23:25:24] <doener> strcat: I was replying to thiez' "it's not a null ptr"
[23:25:26] <strcat> ah
[23:25:28] *** Joins: Excureo (c@moz-B0B6F5C3.static.knwc.wa.charter.com)
[23:25:40] <thiez> strcat: why would they do that?
[23:25:41] <strcat> just an example of the *kind* of rule we don't pay attention to - we may never actually do that specific thing with null
[23:25:45] <strcat> thiez: optimizations
[23:26:13] <thiez> oh, I guess it makes sense
[23:26:34] <strcat> thiez: you might wonder why it's so important to make signed int overflow undef
[23:26:50] <bblum> siiiigh
[23:26:51] <strcat> the reason is basically the halting problem
[23:26:52] <kalenedrael> singed int
[23:27:00] <strcat> it's easy to prove loops don't do anything
[23:27:06] <strcat> and they can prove a lot of loops terminate
[23:27:08] <bblum> tried to switch all the handwritten IterBytes impls in librustc to deriving
[23:27:08] <thiez> struct S(x:int,y:int) ; let p: *S = 0; p.x and p.y are undefined for optimizing
[23:27:13] <bblum> it makes it blow its stack
[23:27:19] <strcat> but there are plenty of loops that they can see are no-ops but can't prove are halting
[23:27:35] * bblum is binary searching on his diff to figure out which impl is busted
[23:27:40] <strcat> so because signed int overflow is undef, they can usually just see 'oh, this would eventually overflow - it MUST halt'
[23:27:55] <strcat> evil optimizations like that.
[23:27:56] <acrichto> bblum: have any of them been tagged wth #[inline]?
[23:27:59] <thiez> I like how they reason about programs, but it's evil :D
[23:28:15] <thiez> hmmn, what happens when I...
[23:28:31] <bblum> acrichto: none that are still on my suspect list
[23:28:33] <thiez> rusti: #[inline(always) fn foo() { foo() } foo()
[23:28:33] -rusti- <anon>:10:4: 10:5 error: incorrect close delimiter: `}`
[23:28:34] -rusti- <anon>:10     };
[23:28:34] -rusti-               ^
[23:28:34] -rusti- application terminated with error code 101
[23:28:34] <strcat> thiez: it's fun to run common C programs with clang's -fsanitize
[23:28:48] <acrichto> bblum: aww I guess nothing's big enough for that to be an issue anyway
[23:28:49] <thiez> rusti: #[inline(always) fn foo() { foo() } foo();
[23:28:49] -rusti- <anon>:10:4: 10:5 error: incorrect close delimiter: `}`
[23:28:49] -rusti- <anon>:10     };
[23:28:50] -rusti-               ^
[23:28:50] -rusti- application terminated with error code 101
[23:28:53] <strcat> thiez: there's an LLVM bug that allows it to optimize out infinite recursion (rusti has optimizations off though)
[23:29:00] <thiez> rusti: #[inline(always)] fn foo() { foo() } foo();
[23:29:01] -rusti- application terminated abnormally with signal 9 (Killed)
[23:29:03] <thiez> boom :D
[23:29:05] <strcat> oom
[23:29:15] <strcat> [188314.516585] Task in /playpen/21113 killed as a result of limit of /playpen/21113
[23:29:17] <strcat> [188314.516587] memory: usage 131072kB, limit 131072kB, failcnt 55
[23:29:39] <thiez> so does the compiler go boom, or the program?
[23:29:41] <strcat> with optimizations it could optimize it to an infinite loop
[23:29:43] <strcat> thiez: program
[23:29:57] <strcat> but it has a bug that would make it remove it completely...
[23:30:19] <strcat> thiez: anyway C is weird, and LLVM's IR is made for optimizing C ;p
[23:30:24] <thiez> rusti: #[inline(always)] fn foo() { bar() } #[inline(always)] fn bar() { foo() }  foo();
[23:30:25] -rusti- application terminated abnormally with signal 9 (Killed)
[23:30:26] <bblum> acrichto: good thinking though
[23:30:50] <thiez> I like how LLVM is sane about not inlining even though I tell it to.
[23:31:17] <strcat> it will still try
[23:31:25] <tikue> rusti: struct S { s: Option<S> }
[23:31:26] -rusti- ()
[23:31:43] <tikue> rusti: struct S { s: @S }
[23:31:44] -rusti- <anon>:9:9: 9:27 error: this type cannot be instantiated without an instance of itself; consider using `Option<main::S>`
[23:31:44] -rusti- <anon>:9          struct S { s: @S }
[23:31:44] -rusti-                   ^~~~~~~~~~~~~~~~~~
[23:31:44] -rusti- error: aborting due to previous error
[23:31:44] -rusti- application terminated with error code 101
[23:31:46] <strcat> rusti: struct S { s: Option<S> }
[23:31:47] -rusti- ()
[23:31:54] <strcat> huh.
[23:31:57] <strcat> why does it allow that?
[23:32:05] <thiez> you didn't know?
[23:32:07] <tikue> strcat: you don't want it to allow that?
[23:32:17] <strcat> it's an infinite size struct.
[23:32:18] <tikue> strcat: how would you recommend making linked lists otherwise
[23:32:23] <tikue> strcat: no it's not
[23:32:26] <strcat> it is
[23:32:41] <thiez> tikue: with Option<[@~]S>
[23:32:44] <pcwalton> tikue: yes it is
[23:32:47] <thiez> and I assure you it is :D
[23:32:53] <pcwalton> you want Option<~S>
[23:32:58] <strcat> rusti: rusti: struct S { s: Option<S> }; std::sys::size_of::<S>()
[23:32:59] -rusti- <anon>:9:14: 9:15 error: expected `;` or `}` after expression but found `:`
[23:32:59] -rusti- <anon>:9          rusti: struct S { s: Option<S> }; std::sys::size_of::<S>()
[23:32:59] -rusti-                        ^
[23:32:59] -rusti- application terminated with error code 101
[23:32:59] <tikue> ah
[23:33:03] <strcat> rusti: struct S { s: Option<S> }; std::sys::size_of::<S>()
[23:33:04] -rusti- Killed
[23:33:04] -rusti- application terminated with error code 137
[23:33:10] <tikue> I believe :)
[23:33:27] <strcat> the compiler itself goes OOM there
[23:33:44] *** Quits: Excureo (c@moz-B0B6F5C3.static.knwc.wa.charter.com) (Ping timeout)
[23:33:45] <thiez> rusti: struct S { next: *S }
[23:33:46] -rusti- ()
[23:33:50] <tikue> struct S { s: Option<S> }; S { s: None }
[23:33:54] <strcat> the exit code is from the bash script, it returns 128 + SIGNUM on signal deaths
[23:34:05] <strcat> SIGKILL is 9, so 137 ;p
[23:34:32] *** Joins: Excureo (c@moz-B0B6F5C3.static.knwc.wa.charter.com)
[23:34:40] <strcat> rusti: struct List { next: Option<~List> } std::sys::size_of::<List>()
[23:34:41] -rusti- 8
[23:34:46] <tikue> pcwalton: so struct S { s: Option<~S> } is the most idiomatic solution?
[23:35:06] <pcwalton> yes
[23:35:08] <strcat> tikue: yes, or Option<@S> for a persistent list
[23:35:19] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Quit: WeeChat 0.4.1)
[23:35:22] <bstrie> "I'm still waiting for the insight that makes closures usefully cool instead of a scary way to hide mutable state. Any great examples?" <-- anyone want to oblige john carmack?
[23:35:33] <strcat> owned singly linked lists aren't really a useful type
[23:35:36] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[23:36:02] <eschweic> rusti: let x = (1, 1); let mut a = 0; let mut b = 0; (a, b) = x; (a, b)
[23:36:04] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/ZBSd
[23:36:15] <thiez> bstrie: we don't really hide mutable state most of the time, so I'm not sure we can help John ;)
[23:36:16] <eschweic> dang
[23:36:48] <Eridius> bstrie: has john ever implemented an API that takes a function callback and a `void*` context pointer? Tell him that's a desugared closure ;)
[23:37:13] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[23:37:20] <bstrie> thiez: "I have no issue at all with capturing immutable state, and I don't have enough experience to decry arbitrary capture, but it gives me pause." now's your chance to tell john carmack about closing over immutable data in rust :P
[23:37:23] <tikue> strcat: I'd agree with that. 
[23:37:37] *** Joins: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net)
[23:37:46] *** Quits: Excureo (c@moz-B0B6F5C3.static.knwc.wa.charter.com) (Ping timeout)
[23:38:02] <Eridius> bstrie: if he has no problem with capturing immutable state, then why is he complaining about closures? They're not inherently mutable
[23:38:09] <BitPuffin> when will 0.7 come you think?
[23:38:26] <BitPuffin> I'm kind of hesitant
[23:38:31] <BitPuffin> I want to begin some work with rust
[23:38:39] <BitPuffin> but it may not be stable enough for that yet
[23:39:03] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[23:39:13] <thiez> bstrie: I think this is the first and the last time in my life I will regret not having twitter :p
[23:39:35] * thiez sits back and enjoys this unique moment.
[23:39:43] *** Joins: Excureo (c@moz-B0B6F5C3.static.knwc.wa.charter.com)
[23:40:12] <bblum> SIGH.
[23:40:19] <bblum>  150 // NB: Do not replace this with #[deriving(Eq)]. The automatically-derived
[23:40:19] <thiez> bstrie: besides, people use Cell for capturing mutable state all the time
[23:40:19] <bblum>  151 // implementation will not recurse through sty and you will get stack
[23:40:19] <bblum>  152 // exhaustion.
[23:40:36] <bstrie> Eridius: I don't know, why don't *you* ask him :)
[23:40:47] <Eridius> bstrie: hah, I have no desire to engage Carmack, especially not on twitter
[23:41:02] *** Quits: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com) (Client exited)
[23:41:13] <bstrie> presuming that john carmack is mistaken is like thinking there's a bug in your compiler
[23:41:23] *** Joins: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com)
[23:41:24] <strcat> bblum: https://github.com/mozilla/rust/issues/6553 tangentially related
[23:41:28] <bstrie> and we all know the latter is impossible
[23:41:38] <Eridius> bstrie: depends on the compiler. Is it rust's compiler? ;)
[23:41:40] <brson> BitPuffin: 0.7 probably isn't this week. maybe next
[23:41:52] <BitPuffin> brson: or really? cool!
[23:41:54] <BitPuffin> what's new?
[23:41:57] * strcat wonders how much of the compiler depends on that though :[
[23:42:09] <thiez> Eridius: that proves that Rust truly is exceptional
[23:42:11] <strcat> and we can do an impl for T: Const and *also* T: Owned yet
[23:42:38] <BitPuffin> on the other hand, the fact that mozilla is building a browser engine with rust maybe it's stable enough
[23:43:00] <bblum> strcat: well no, so, the handwritten iterbytes implementation recursed through the *T pointer, and the deriving implementation did not
[23:43:06] <strcat> bblum: oh
[23:43:07] <brson> BitPuffin: release notes are here: https://github.com/mozilla/rust/blob/master/RELEASES.txt
[23:43:08] *** Quits: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com) (Ping timeout)
[23:43:24] *** Quits: Excureo (c@moz-B0B6F5C3.static.knwc.wa.charter.com) (Ping timeout)
[23:43:25] <strcat> bblum: I read 'not recurse' as 'recurse' :)
[23:43:30] <bblum> strcat: me too at first
[23:43:34] <brson> BitPuffin: Rust is still not stable enough for the real world
[23:44:09] <strcat> brson: in the real world people write half working things in invalid C :p
[23:44:22] <strcat> I think it's still easier to write a correct program in rust than C or C++
[23:44:25] <strcat> even with all the bugs
[23:44:42] <bblum> yeah you're not really going to run into soundness holes by accident
[23:44:49] <bblum> well, with the @Trait problem, you might...
[23:45:03] <strcat> well you'd have to be crazy to use trait objects at this point ;p
[23:45:08] <thiez> brson: do you recall what was wrong with https://github.com/mozilla/rust/pull/6581? The details seem to be unavailable
[23:45:24] *** Joins: Excureo (c@moz-B0B6F5C3.static.knwc.wa.charter.com)
[23:45:52] <thiez> hmmn, where are the trait vtables stored?
[23:46:02] <brson> thiez: there was one test case that failed. I don't remember why. I really want to get that fixed for 0.7 though. it's pretty nasty
[23:46:17] <thiez> are they allocated when you create a trait object, or are they already in the generated binary somewhere?
[23:46:28] <thiez> brson: would be nice, then the benchmarks are fixed.
[23:46:45] <thiez> also earlier I ran the benchmarks with RUST_BENCH on, and they took over 300GB virtual memory :D
[23:47:01] <thiez> probably caused by that bug
[23:47:10] <brson> thiez: probably yes
[23:48:25] <tikue> BitPuffin: servo and rust have sort of a symbiotic relationship -- it's not being developed in rust because rust is "ready" so much as because it's a good testbed. Servo development helps expose weaknesses in rust as much as rust helps servo do things that haven't been done before in browsers
[23:48:53] *** Joins: tjc (tjc@moz-D530ECE9.lightspeed.irvnca.sbcglobal.net)
[23:48:53] *** ChanServ sets mode: +o tjc
[23:48:53] <BitPuffin> hmm, I see
[23:49:52] *** Quits: azita (Azita@2557E599.66715431.D25A875A.IP) (Quit: azita)
[23:58:29] <aatch> strcat, I'm pretty sure I figured out the codegen issue
[23:58:36] <strcat> aatch: :D
[23:58:40] <cmr> which?
[23:58:45] <aatch> The closure one.
[23:58:50] <cmr> which? :p
[23:58:58] <aatch> And it might not actually be a codegen bug.
[23:59:03] <strcat> https://github.com/mozilla/rust/issues/7336
[23:59:10] <cmr> ah
[23:59:10] <strcat> aatch: what else? ;p
[23:59:13] <aatch> Or more accurately, it's not a bug in trans per-se
[23:59:31] <aatch> I'm pretty sure it's to do with the way we capture environment vars
[23:59:33] <cmr> aatch: The really cofnusing part, is that the test ran fine on my machine, when I ran make check with it un-xfailed
[23:59:41] <cmr> (I un-xfailed it during my partial xfail cleanup)
[23:59:45] <aatch> cmr, did you optimize it?
[23:59:52] <cmr> aatch: Erm, not sure actually
[23:59:55] <strcat> try with/without -O
